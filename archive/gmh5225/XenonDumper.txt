Project Path: arc_gmh5225_XenonDumper_ey73lbjn

Source Tree:

```txt
arc_gmh5225_XenonDumper_ey73lbjn
├── README.md
├── XenonDumper
│   ├── AppConf.xml
│   ├── Functions.cpp
│   ├── Functions.h
│   ├── HVFuncs.cpp
│   ├── HVFuncs.h
│   ├── Media
│   │   ├── Build_XZP.bat
│   │   ├── COMPLETED_RESOURCES
│   │   │   ├── 0_skin.xui
│   │   │   ├── 1_scene.xui
│   │   │   ├── Background
│   │   │   ├── ButtonBACK.png
│   │   │   ├── XenonLogo.png
│   │   │   ├── button_a.png
│   │   │   ├── button_b.png
│   │   │   ├── button_x.png
│   │   │   └── button_y.png
│   │   ├── Simple360NandFlasher.xex
│   │   └── XD_res.xzp
│   ├── XenonDumper.cpp
│   ├── XenonDumper.vcxproj
│   ├── XenonDumper.vcxproj.filters
│   ├── XuiClasses.cpp
│   ├── XuiClasses.h
│   ├── libs
│   │   ├── Atg
│   │   │   ├── AtgAnimation.cpp
│   │   │   ├── AtgAnimation.h
│   │   │   ├── AtgApobase.h
│   │   │   ├── AtgApp.cpp
│   │   │   ├── AtgApp.h
│   │   │   ├── AtgAudio.cpp
│   │   │   ├── AtgAudio.h
│   │   │   ├── AtgAvatarRenderer.cpp
│   │   │   ├── AtgAvatarRenderer.h
│   │   │   ├── AtgBound.cpp
│   │   │   ├── AtgBound.h
│   │   │   ├── AtgCamera.cpp
│   │   │   ├── AtgCamera.h
│   │   │   ├── AtgCollision.cpp
│   │   │   ├── AtgCollision.h
│   │   │   ├── AtgConsole.cpp
│   │   │   ├── AtgConsole.h
│   │   │   ├── AtgDebugDraw.cpp
│   │   │   ├── AtgDebugDraw.h
│   │   │   ├── AtgDevice.cpp
│   │   │   ├── AtgDevice.h
│   │   │   ├── AtgDsp.cpp
│   │   │   ├── AtgDsp.h
│   │   │   ├── AtgEnumStrings.cpp
│   │   │   ├── AtgEnumStrings.h
│   │   │   ├── AtgFont.cpp
│   │   │   ├── AtgFont.h
│   │   │   ├── AtgFrame.cpp
│   │   │   ├── AtgFrame.h
│   │   │   ├── AtgFramework.lib
│   │   │   ├── AtgFramework2010.vcxproj
│   │   │   ├── AtgFramework2010.vcxproj.filters
│   │   │   ├── AtgFrameworkWin322010.vcxproj
│   │   │   ├── AtgFrameworkWin322010.vcxproj.filters
│   │   │   ├── AtgHelp.cpp
│   │   │   ├── AtgHelp.h
│   │   │   ├── AtgHttp.cpp
│   │   │   ├── AtgHttp.h
│   │   │   ├── AtgInput.cpp
│   │   │   ├── AtgInput.h
│   │   │   ├── AtgJson.cpp
│   │   │   ├── AtgJson.h
│   │   │   ├── AtgLight.cpp
│   │   │   ├── AtgLight.h
│   │   │   ├── AtgLockFreePipe.h
│   │   │   ├── AtgMaterials.cpp
│   │   │   ├── AtgMaterials.h
│   │   │   ├── AtgMediaLocator.cpp
│   │   │   ├── AtgMediaLocator.h
│   │   │   ├── AtgMesh.cpp
│   │   │   ├── AtgMesh.h
│   │   │   ├── AtgMeta.h
│   │   │   ├── AtgMetaVMX.h
│   │   │   ├── AtgModel.cpp
│   │   │   ├── AtgModel.h
│   │   │   ├── AtgNamedTypedObject.cpp
│   │   │   ├── AtgNamedTypedObject.h
│   │   │   ├── AtgNuiCommon.cpp
│   │   │   ├── AtgNuiCommon.h
│   │   │   ├── AtgNuiHandRefinement.cpp
│   │   │   ├── AtgNuiHandRefinement.h
│   │   │   ├── AtgNuiJointConverter.cpp
│   │   │   ├── AtgNuiJointConverter.h
│   │   │   ├── AtgNuiJointFilter.cpp
│   │   │   ├── AtgNuiJointFilter.h
│   │   │   ├── AtgNuiMenu.cpp
│   │   │   ├── AtgNuiMenu.h
│   │   │   ├── AtgNuiRelativeCoordinates.cpp
│   │   │   ├── AtgNuiRelativeCoordinates.h
│   │   │   ├── AtgNuiVisualization.cpp
│   │   │   ├── AtgNuiVisualization.h
│   │   │   ├── AtgPostProcess.cpp
│   │   │   ├── AtgPostProcess.h
│   │   │   ├── AtgResource.cpp
│   │   │   ├── AtgResource.h
│   │   │   ├── AtgResourceDatabase.cpp
│   │   │   ├── AtgResourceDatabase.h
│   │   │   ├── AtgRest.cpp
│   │   │   ├── AtgRest.h
│   │   │   ├── AtgScene.cpp
│   │   │   ├── AtgScene.h
│   │   │   ├── AtgSceneAll.h
│   │   │   ├── AtgSceneFileParser.cpp
│   │   │   ├── AtgSceneFileParser.h
│   │   │   ├── AtgSceneMesh.cpp
│   │   │   ├── AtgSceneMesh.h
│   │   │   ├── AtgSessionManager.cpp
│   │   │   ├── AtgSessionManager.h
│   │   │   ├── AtgSignIn.cpp
│   │   │   ├── AtgSignIn.h
│   │   │   ├── AtgSimpleShaders.cpp
│   │   │   ├── AtgSimpleShaders.h
│   │   │   ├── AtgSkeletalAnimation.cpp
│   │   │   ├── AtgSkeletalAnimation.h
│   │   │   ├── AtgSpectralDisplay.cpp
│   │   │   ├── AtgSpectralDisplay.h
│   │   │   ├── AtgUtil.cpp
│   │   │   ├── AtgUtil.h
│   │   │   ├── AtgVer.h
│   │   │   ├── AtgWavebank.cpp
│   │   │   ├── AtgWavebank.h
│   │   │   ├── AtgXime.cpp
│   │   │   ├── AtgXime.h
│   │   │   ├── AtgXmlParser.cpp
│   │   │   ├── AtgXmlParser.h
│   │   │   ├── AtgXmlWriter.cpp
│   │   │   ├── AtgXmlWriter.h
│   │   │   ├── XTLOnPC.cpp
│   │   │   ├── XTLOnPC.h
│   │   │   ├── stdafx.cpp
│   │   │   └── stdafx.h
│   │   └── xkelib
│   │       ├── Release21256.0
│   │       │   ├── xkelib.lastbuildstate
│   │       │   └── xkelib.vcxproj.FileListAbsolute.txt
│   │       ├── _tools
│   │       │   ├── _readme.txt
│   │       │   ├── _runit.bat
│   │       │   ├── deffix
│   │       │   │   ├── deffix
│   │       │   │   │   ├── deffix.cpp
│   │       │   │   │   ├── deffix.vcxproj
│   │       │   │   │   ├── deffix.vcxproj.filters
│   │       │   │   │   ├── stdafx.cpp
│   │       │   │   │   ├── stdafx.h
│   │       │   │   │   ├── types.h
│   │       │   │   │   ├── util.cpp
│   │       │   │   │   └── util.h
│   │       │   │   └── deffix.sln
│   │       │   ├── deffix.exe
│   │       │   ├── dump_libheader.bat
│   │       │   ├── dump_libheader_multidrop.bat
│   │       │   ├── list_exports_for_lib.idc
│   │       │   ├── manuals_kernel.txt
│   │       │   └── manuals_xam.txt
│   │       ├── exttypes.h
│   │       ├── kernel
│   │       │   ├── _kernelext.h
│   │       │   ├── console_type.h
│   │       │   ├── keDriver.h
│   │       │   ├── keFileInfo.h
│   │       │   ├── keNand.h
│   │       │   ├── kePrivateStructs.h
│   │       │   ├── keSmc.h
│   │       │   ├── keXConfig.h
│   │       │   ├── keXeCrypt.h
│   │       │   ├── keXeKeys.h
│   │       │   ├── keXexInfo.h
│   │       │   ├── kernelExpEnum.h
│   │       │   ├── kernelext20871.0.def
│   │       │   ├── kernelext21119.0.def
│   │       │   ├── kernelext21173.0.def
│   │       │   ├── kernelext21250.0.def
│   │       │   └── kernelext21256.0.def
│   │       ├── kernelext.exp
│   │       ├── kernelext.lib
│   │       ├── syssock.h
│   │       ├── xam
│   │       │   ├── _xamext.h
│   │       │   ├── xamExpEnum.h
│   │       │   ├── xamNet.h
│   │       │   ├── xamTask.h
│   │       │   ├── xamXContent.h
│   │       │   ├── xamext20871.0.def
│   │       │   ├── xamext21119.0.def
│   │       │   ├── xamext21173.0.def
│   │       │   ├── xamext21250.0.def
│   │       │   └── xamext21256.0.def
│   │       ├── xamext.exp
│   │       ├── xamext.lib
│   │       ├── xapiext.h
│   │       ├── xkelib.h
│   │       ├── xkelib.vcxproj
│   │       └── xkelib.vcxproj.filters
│   ├── stdafx.cpp
│   └── stdafx.h
└── XenonDumper.sln

```

`README.md`:

```md
# XenonDumper
Custom Xbox 360 application designed to dump the files & data required to use the [Xenon Xbox 360 Low Level Emulator](https://github.com/xenon-emu/xenon).

> [!NOTE]
> This app is **unofficial** and is in no way affiliated with the [xenon-emu](https://github.com/xenon-emu) project or creators.

## Features
Dumps the following files:
- **fuses.txt** - Contains the systems unique fusesets in the same format as they are when dumping via xell.
- **1bl.bin** - The first bootloader stored in the Secure ROM of the systems CPU.
- **flashdmp.bin** - The systems nand flash. This is handled automatically by booting into Simple360NandFlasher & utilising it's built in "AutoMode" set to dump.

## Requirements
This app supports both retail & developer kernels with the required patches to allow the install and use of HV expansions.<br>
The following setups should work:
- Retail consoles modified using hardware modifications (**RGH or JTAG**) and running either a patched retail 17559 kernel (freeboot) or a patched developer 17489 (or 17559 when spoofed) kernel ([RGLoader](https://github.com/RGLoader)). 
- Retail consoles exploited using [BadUpdate](https://github.com/grimdoomer/Xbox360BadUpdate) & the patches provided by [XeUnshackle](https://github.com/Byrom90/XeUnshackle).
- Development Kit consoles running a 17489 recovery & shadowboot such as [RGLoader](https://github.com/RGLoader).

## Credits
- [Swizzy](https://github.com/Swizzy) - Simple 360 NAND Flasher.
```

`XenonDumper.sln`:

```sln
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.33529.622
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "XenonDumper", "XenonDumper\XenonDumper.vcxproj", "{652C7D60-BC02-4E09-96DD-930012345678}"
	ProjectSection(ProjectDependencies) = postProject
		{83FEF217-22EE-4768-80BF-9F48D5B4564C} = {83FEF217-22EE-4768-80BF-9F48D5B4564C}
		{91D208A6-9936-47FD-9659-67205C3EB0AB} = {91D208A6-9936-47FD-9659-67205C3EB0AB}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "AtgFramework", "XenonDumper\libs\Atg\AtgFramework2010.vcxproj", "{91D208A6-9936-47FD-9659-67205C3EB0AB}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "libs", "libs", "{E537647F-46A4-47CA-9E02-1AD98F81DCC2}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "xkelib", "XenonDumper\libs\xkelib\xkelib.vcxproj", "{83FEF217-22EE-4768-80BF-9F48D5B4564C}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release_LTCG|Xbox 360 = Release_LTCG|Xbox 360
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{652C7D60-BC02-4E09-96DD-930012345678}.Release_LTCG|Xbox 360.ActiveCfg = Release_LTCG|Xbox 360
		{652C7D60-BC02-4E09-96DD-930012345678}.Release_LTCG|Xbox 360.Build.0 = Release_LTCG|Xbox 360
		{91D208A6-9936-47FD-9659-67205C3EB0AB}.Release_LTCG|Xbox 360.ActiveCfg = Release_LTCG|Xbox 360
		{91D208A6-9936-47FD-9659-67205C3EB0AB}.Release_LTCG|Xbox 360.Build.0 = Release_LTCG|Xbox 360
		{83FEF217-22EE-4768-80BF-9F48D5B4564C}.Release_LTCG|Xbox 360.ActiveCfg = Release21256.0|Xbox 360
		{83FEF217-22EE-4768-80BF-9F48D5B4564C}.Release_LTCG|Xbox 360.Build.0 = Release21256.0|Xbox 360
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{91D208A6-9936-47FD-9659-67205C3EB0AB} = {E537647F-46A4-47CA-9E02-1AD98F81DCC2}
		{83FEF217-22EE-4768-80BF-9F48D5B4564C} = {E537647F-46A4-47CA-9E02-1AD98F81DCC2}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {E8404F68-0862-4782-B33F-6FFBCF29C27C}
	EndGlobalSection
EndGlobal

```

`XenonDumper/AppConf.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<xex>
  <format>
    <compressed/>
  </format>
  <mediatypes>
    <default/>
    <allpackages/>
  </mediatypes>
  <gameregion>
    <all/>
  </gameregion>
      <!-- Our xex privileges -->
  <privilege id="0"/> <!-- No Force Reboot -->
  <section file="Media/XD_res.xzp" name="XDR" memory="RO"/>
  <section file="Media/Simple360NandFlasher.xex" name="S360NF" memory="RO"/>

</xex>
```

`XenonDumper/Functions.cpp`:

```cpp
#include"stdafx.h"
#include <time.h>

HMODULE hAPP = NULL;
BOOL IsDevkit = FALSE;

// =========================  ENABLE DEBUG PRINTS  ====================================
#ifdef _DEBUG
VOID Byrom_Print(const CHAR* fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	vfprintf(stdout, fmt, args);
	va_end(args);
}

#endif

VOID XNotify(PWCHAR text)
{
	XNotifyQueueUI(XNOTIFYUI_TYPE_PREFERRED_REVIEW, 0, 2, text, NULL);
}

PWCHAR LinkWChar(PWCHAR Text, ...) {
	WCHAR Buffer[0x1000], MessageBuffer[0x100];;

	va_list pArgList;
	va_start(pArgList, Text);
	vswprintf(Buffer, Text, pArgList);
	va_end(pArgList);

	swprintf(MessageBuffer, Buffer);

	return MessageBuffer;
}

BOOL FileExists(PCHAR path)
{
	OBJECT_ATTRIBUTES obAtrib;
	FILE_NETWORK_OPEN_INFORMATION netInfo;
	STRING filePath;
	RtlInitAnsiString(&filePath, path); //  = 0x10
	InitializeObjectAttributes(&obAtrib, &filePath, 0x40, NULL);
	if (path[0] != '\\')
		obAtrib.RootDirectory = (HANDLE)0xFFFFFFFD;
	if (NT_SUCCESS(NtQueryFullAttributesFile(&obAtrib, &netInfo)))
	{
		// filter out directories from the result
		if ((netInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
			return TRUE;
	}
	return FALSE;
}

#define INVALID_FILE_ATTRIBUTES -1
BOOL DirectoryExists(LPCTSTR szPath)
{
	DWORD dwAttrib = GetFileAttributes(szPath);

	return (dwAttrib != INVALID_FILE_ATTRIBUTES &&
		(dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
}

BOOL CWriteFile(const CHAR* FilePath, const VOID* Data, DWORD Size)
{
	HANDLE fHandle = CreateFile(FilePath, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (fHandle == INVALID_HANDLE_VALUE)
	{
		DbgPrint("[CWriteFile] INVALID_HANDLE_VALUE. Error: %X", GetLastError());
		return FALSE;
	}

	DWORD writeSize = Size;
	if (WriteFile(fHandle, Data, writeSize, &writeSize, NULL) != TRUE)
	{
		DbgPrint("[CWriteFile] WriteFile failed. Error: %X", GetLastError());
		return FALSE;
	}
	CloseHandle(fHandle);

	return TRUE;
}

HRESULT CreateMount(const char* szDrive, const char* szDevice, BOOL System) {
	STRING DeviceName, LinkName;
	CHAR szDestinationDrive[MAX_PATH];
	sprintf_s(szDestinationDrive, MAX_PATH, System ? OBJ_SYS_STRING : OBJ_USR_STRING, szDrive);
	RtlInitAnsiString(&DeviceName, szDevice);
	RtlInitAnsiString(&LinkName, szDestinationDrive);
	ObDeleteSymbolicLink(&LinkName);
	return (HRESULT)ObCreateSymbolicLink(&LinkName, &DeviceName);
}

```

`XenonDumper/Functions.h`:

```h
#ifndef __Functions_H__
#define __Functions_H__
#pragma once
//using std::string;

extern HMODULE hAPP;
extern BOOL IsDevkit;

// =========================  ENABLE DEBUG PRINTS  ====================================
#define _DEBUG

#ifdef _DEBUG
VOID Byrom_Print(const CHAR* fmt, ...);
#define DbgPrint(x, ...) { do { Byrom_Print("[XenonDumper] "  x "\n", __VA_ARGS__); } while(0); }
#endif

#ifndef _DEBUG
#define DbgPrint
#endif

VOID XNotify(PWCHAR text);
PWCHAR LinkWChar(PWCHAR Text, ...);
BOOL FileExists(PCHAR path);
BOOL DirectoryExists(LPCTSTR szPath);
BOOL CWriteFile(const CHAR* FilePath, const VOID* Data, DWORD Size);

#define MOUNT_FLASH "Flash:"
#define DEVICE_FLASH "\\Device\\Flash"
HRESULT CreateMount(const char* szDrive, const char* szDevice, BOOL System);

#endif // !__Functions_H
```

`XenonDumper/HVFuncs.cpp`:

```cpp
#include "stdafx.h"

#pragma warning(push)
#pragma warning(disable:4826) // Get rid of the sign-extended warning

#define HvxCall QWORD _declspec(naked)
DWORD HvPeekPokeExpID = 0x48565050;
namespace Hvx
{
	const BYTE HvPeekPokeExp[] = {
		0x48, 0x58, 0x50, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x34, 0x1F, 0xD6, 0xDA,
		0x2F, 0xCA, 0xA8, 0x17, 0xF0, 0x30, 0xCC, 0x44, 0x0A, 0x41, 0xFA, 0x7C, 0xA0, 0xC1, 0xFD, 0x33,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x7A, 0x02, 0x59, 0x43, 0x9E, 0xE6, 0x93, 0xD5, 0x01, 0xC9, 0x48, 0x4D, 0xB2, 0xBF, 0x9D, 0x18,
		0xA9, 0x16, 0x5E, 0xFF, 0x1E, 0xD5, 0xB6, 0xA8, 0x79, 0x60, 0xA8, 0x2F, 0xC1, 0x8D, 0x20, 0x8A,
		0xEB, 0x46, 0xC3, 0x01, 0xEC, 0xC4, 0xDB, 0xDF, 0xA1, 0x04, 0xD1, 0xDF, 0x23, 0x69, 0x5E, 0xCC,
		0x50, 0xC3, 0xF4, 0xDD, 0xA4, 0x80, 0x7D, 0x05, 0x2D, 0x57, 0xFF, 0x60, 0xA5, 0x58, 0x69, 0x27,
		0x9A, 0x33, 0x70, 0xE8, 0xC2, 0x82, 0xDC, 0xDA, 0xE2, 0x4D, 0xE1, 0xF8, 0xA1, 0xD2, 0xCC, 0x8D,
		0x98, 0x05, 0xD1, 0xA3, 0x2E, 0x37, 0x06, 0x0F, 0xF7, 0xEF, 0x70, 0xEF, 0x28, 0xD7, 0xAE, 0xD5,
		0x5B, 0x19, 0x1B, 0x13, 0x50, 0x0D, 0x15, 0x00, 0x92, 0x01, 0xEE, 0x38, 0xA7, 0x61, 0xB1, 0xA1,
		0x27, 0xBF, 0xB0, 0x42, 0x0F, 0x07, 0xC3, 0x8F, 0x78, 0xAD, 0xAF, 0x87, 0x8F, 0x34, 0x8A, 0xA6,
		0x69, 0x7D, 0x40, 0xB6, 0x5C, 0x9E, 0x01, 0xEC, 0x9F, 0x5E, 0x78, 0x30, 0x09, 0x5A, 0x21, 0xFF,
		0x35, 0x8C, 0x13, 0xBE, 0xBC, 0x92, 0x67, 0xE3, 0x17, 0x0B, 0x09, 0x1C, 0xE2, 0x9D, 0xEC, 0xFD,
		0xFB, 0x6C, 0x49, 0x3A, 0xCC, 0xE7, 0x99, 0xB6, 0xB3, 0x8A, 0x8F, 0xEF, 0xF7, 0xA0, 0x28, 0x4F,
		0x72, 0xC7, 0x3D, 0xD7, 0xCC, 0xEB, 0xB2, 0x1B, 0x74, 0x93, 0xD7, 0x02, 0x05, 0xD5, 0xE1, 0x25,
		0x35, 0xD7, 0xE0, 0x50, 0xEA, 0xCF, 0x82, 0x69, 0xE3, 0x3B, 0x6F, 0xFA, 0x13, 0xF0, 0x5B, 0xD9,
		0x1A, 0xB0, 0xD3, 0x0B, 0x85, 0x4D, 0x6A, 0xFC, 0x31, 0x45, 0xC3, 0xA3, 0xFA, 0x7E, 0xDA, 0x93,
		0x84, 0xD4, 0xE7, 0xFA, 0xAB, 0x7C, 0x22, 0x96, 0x54, 0x69, 0x7F, 0xC9, 0xF8, 0xC4, 0x5A, 0xC2,
		0x82, 0x99, 0x34, 0x46, 0x81, 0x6F, 0x06, 0x33, 0x19, 0x94, 0x74, 0xA4, 0x76, 0x02, 0x4F, 0xB9,
		0x48, 0x56, 0x50, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x60, 0x00, 0x00, 0x01, 0x90,
		0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00,
		0x7D, 0x88, 0x02, 0xA6, 0xFB, 0xE1, 0xFF, 0xF0, 0xF9, 0x81, 0xFF, 0xF8, 0x94, 0x21, 0xFF, 0x00,
		0x7C, 0x9F, 0x23, 0x78, 0x2C, 0x1F, 0x00, 0x00, 0x41, 0x82, 0x00, 0xC0, 0x2C, 0x1F, 0x00, 0x01,
		0x41, 0x82, 0x00, 0xC0, 0x2C, 0x1F, 0x00, 0x02, 0x41, 0x82, 0x00, 0xC0, 0x2C, 0x1F, 0x00, 0x03,
		0x41, 0x82, 0x00, 0xC0, 0x2C, 0x1F, 0x00, 0x0A, 0x41, 0x82, 0x00, 0x64, 0x2C, 0x1F, 0x00, 0x05,
		0x41, 0x82, 0x00, 0xD4, 0x2C, 0x1F, 0x00, 0x06, 0x41, 0x82, 0x00, 0xD4, 0x2C, 0x1F, 0x00, 0x07,
		0x41, 0x82, 0x00, 0xD4, 0x2C, 0x1F, 0x00, 0x08, 0x41, 0x82, 0x00, 0xD4, 0x2C, 0x1F, 0x00, 0x0B,
		0x40, 0x80, 0x00, 0x00, 0x80, 0x60, 0x00, 0x4C, 0x7C, 0x62, 0x1A, 0x14, 0x80, 0x63, 0x00, 0x08,
		0x7C, 0x69, 0x03, 0xA6, 0x7C, 0xC3, 0x33, 0x78, 0x38, 0x80, 0x00, 0x01, 0x4E, 0x80, 0x04, 0x21,
		0x7C, 0x66, 0x1B, 0x78, 0x7C, 0xE9, 0x03, 0xA6, 0x2C, 0x1F, 0x00, 0x04, 0x41, 0x82, 0x00, 0x6C,
		0x2C, 0x1F, 0x00, 0x09, 0x41, 0x82, 0x00, 0xA0, 0x48, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x05,
		0x7C, 0xA6, 0x2B, 0x78, 0x3C, 0x80, 0x7C, 0x60, 0x50, 0xA6, 0x54, 0x6A, 0x60, 0x84, 0x02, 0xA6,
		0x50, 0xC4, 0x32, 0xE8, 0x7C, 0x68, 0x02, 0xA6, 0x38, 0x63, 0x00, 0x30, 0x90, 0x83, 0x00, 0x00,
		0x7C, 0x00, 0x18, 0x6C, 0x7C, 0x00, 0x1F, 0xAC, 0x7C, 0x00, 0x04, 0xAC, 0x4C, 0x00, 0x01, 0x2C,
		0x7C, 0x79, 0x4A, 0xA6, 0x48, 0x00, 0x00, 0x98, 0x88, 0x65, 0x00, 0x00, 0x48, 0x00, 0x00, 0x90,
		0xA0, 0x65, 0x00, 0x00, 0x48, 0x00, 0x00, 0x88, 0x80, 0x65, 0x00, 0x00, 0x48, 0x00, 0x00, 0x80,
		0xE8, 0x65, 0x00, 0x00, 0x48, 0x00, 0x00, 0x78, 0x8B, 0xE5, 0x00, 0x00, 0x9B, 0xE6, 0x00, 0x00,
		0x38, 0xA5, 0x00, 0x01, 0x38, 0xC6, 0x00, 0x01, 0x42, 0x00, 0xFF, 0xF0, 0x38, 0x60, 0x00, 0x00,
		0x48, 0x00, 0x00, 0x5C, 0x98, 0xC5, 0x00, 0x00, 0x48, 0x00, 0x00, 0x40, 0xB0, 0xC5, 0x00, 0x00,
		0x48, 0x00, 0x00, 0x38, 0x90, 0xC5, 0x00, 0x00, 0x48, 0x00, 0x00, 0x30, 0xF8, 0xC5, 0x00, 0x00,
		0x48, 0x00, 0x00, 0x28, 0x8B, 0xE6, 0x00, 0x00, 0x9B, 0xE5, 0x00, 0x00, 0x7C, 0x00, 0x28, 0x6C,
		0x7C, 0x00, 0x2F, 0xAC, 0x7C, 0x00, 0x04, 0xAC, 0x4C, 0x00, 0x01, 0x2C, 0x38, 0xA5, 0x00, 0x01,
		0x38, 0xC6, 0x00, 0x01, 0x42, 0x00, 0xFF, 0xE0, 0x38, 0x60, 0x00, 0x00, 0x7C, 0x00, 0x28, 0x6C,
		0x7C, 0x00, 0x2F, 0xAC, 0x7C, 0x00, 0x04, 0xAC, 0x4C, 0x00, 0x01, 0x2C, 0x38, 0x21, 0x01, 0x00,
		0xEB, 0xE1, 0xFF, 0xF0, 0xE9, 0x81, 0xFF, 0xF8, 0x7D, 0x88, 0x03, 0xA6, 0x4E, 0x80, 0x00, 0x20
	};

	namespace SysCalls
	{
		static HvxCall HvxGetVersion(DWORD magic, DWORD mode, UINT64 dest, UINT64 src, UINT32 len, UINT64 arg_r8 = NULL) // Freeboot uses this as a backdoor
		{
			__asm
			{
				li r0, 0 // HvxGetVersion
				sc
				blr
			}
		}


		//static HvxCall HvxPostOutput(BYTE code)
		static HvxCall HvxPostOutput(BYTE code, UINT64 shellCodeAddress) // BadUpdate exploit uses this as a backdoor
		{
			__asm
			{
				li	r0, 0xD
				sc
				blr
			}
		}

		static HvxCall HvxKeysExecute(PVOID pvPayload, DWORD cbPayload, QWORD Arg1, QWORD Arg2, QWORD Arg3, QWORD Arg4)
		{
			__asm
			{
				li	r0, 0x40
				sc
				blr
			}
		}

		static HvxCall HvxExpansionInstall(DWORD PhysicalAddress, DWORD CodeSize) {
			if (IsDevkit)
			{
				__asm
				{
					li	r0, 0x70
					sc
					blr
				}
			}
			else
			{
				__asm
				{
					li	r0, 0x72
					sc
					blr
				}
			}
		}

		static HvxCall HvxExpansionCall(DWORD ExpansionId, QWORD Param1 = 0, QWORD Param2 = 0, QWORD Param3 = 0, QWORD Param4 = 0) {
			if (IsDevkit)
			{
				__asm
				{
					li	r0, 0x71
					sc
					blr
				}
			}
			else
			{
				__asm
				{
					li	r0, 0x73
					sc
					blr
				}
			}
		}

	}

	HRESULT InitHvPeekPokeExp()
	{
		DbgPrint("Init HV expansion");
		// Allocate physical memory for this expansion
		VOID* pPhysExp = XPhysicalAlloc(0x1000, MAXULONG_PTR, 0, PAGE_READWRITE);
		DWORD physExpAdd = (DWORD)MmGetPhysicalAddress(pPhysExp);

		// Copy over our expansion data
		ZeroMemory(pPhysExp, 0x1000);
		memcpy(pPhysExp, HvPeekPokeExp, sizeof(HvPeekPokeExp));

		HRESULT result = (HRESULT)HvExpansionInstall(physExpAdd, 0x1000);

		// Free our allocated data
		XPhysicalFree(pPhysExp);

		// Return our install result
		return result;
	}

	// wrappers for syscalls (for organization)
	QWORD HvGetVersion(DWORD magic, DWORD mode, UINT64 dest, UINT64 src, UINT32 len, UINT64 arg_r8)
	{
		return SysCalls::HvxGetVersion(magic, mode, dest, src, len, arg_r8);
	}
	//QWORD HvPostOutput(BYTE code)
	QWORD HvPostOutput(BYTE code, UINT64 shellCodeAddress)
	{
		return SysCalls::HvxPostOutput(code, shellCodeAddress);
	}
	QWORD HvKeysExecute(PVOID pvPayload, DWORD cbPayload, QWORD arg1 = NULL, QWORD arg2 = NULL, QWORD arg3 = NULL, QWORD arg4 = NULL)
	{
		return SysCalls::HvxKeysExecute(pvPayload, cbPayload, arg1, arg2, arg3, arg4);
	}
	QWORD HvExpansionInstall(DWORD PhysicalAddress, DWORD CodeSize)
	{
		return SysCalls::HvxExpansionInstall(PhysicalAddress, CodeSize);
	}
	QWORD HvExpansionCall(DWORD ExpansionId, QWORD Param1 = NULL, QWORD Param2 = NULL, QWORD Param3 = NULL, QWORD Param4 = NULL)
	{
		return SysCalls::HvxExpansionCall(ExpansionId, Param1, Param2, Param3, Param4);
	}

	BYTE    HvPeekBYTE(QWORD Address) {
		return (BYTE)HvExpansionCall(HvPeekPokeExpID, PEEK_BYTE, Address);
	}
	WORD    HvPeekWORD(QWORD Address) {
		return (WORD)HvExpansionCall(HvPeekPokeExpID, PEEK_WORD, Address);
	}
	DWORD   HvPeekDWORD(QWORD Address) {
		return (DWORD)HvExpansionCall(HvPeekPokeExpID, PEEK_DWORD, Address);
	}
	QWORD   HvPeekQWORD(QWORD Address) {
		return HvExpansionCall(HvPeekPokeExpID, PEEK_QWORD, Address);
	}
	HRESULT HvPeekBytes(QWORD Address, PVOID Buffer, DWORD Size) {

		// Create a physical buffer to peek into
		VOID* data = XPhysicalAlloc(Size, MAXULONG_PTR, 0, PAGE_READWRITE);
		ZeroMemory(data, Size);

		HRESULT result = (HRESULT)HvExpansionCall(HvPeekPokeExpID,
			PEEK_BYTES, Address, (QWORD)MmGetPhysicalAddress(data), Size);

		// If its successful copy it back
		if (result == S_OK) memcpy(Buffer, data, Size);

		// Free our physical data and return our result
		XPhysicalFree(data);
		return result;
	}
	HRESULT HvPokeBYTE(QWORD Address, BYTE Value) {
		return (HRESULT)HvExpansionCall(HvPeekPokeExpID, POKE_BYTE, Address, Value);
	}
	HRESULT HvPokeWORD(QWORD Address, WORD Value) {
		return (HRESULT)HvExpansionCall(HvPeekPokeExpID, POKE_WORD, Address, Value);
	}
	HRESULT HvPokeDWORD(QWORD Address, DWORD Value) {
		return (HRESULT)HvExpansionCall(HvPeekPokeExpID, POKE_DWORD, Address, Value);
	}
	HRESULT HvPokeQWORD(QWORD Address, QWORD Value) {
		return (HRESULT)HvExpansionCall(HvPeekPokeExpID, POKE_QWORD, Address, Value);
	}
	HRESULT HvPokeBytes(QWORD Address, PVOID Buffer, DWORD Size) {

		// Create a physical buffer to poke from
		VOID* data = XPhysicalAlloc(Size, MAXULONG_PTR, 0, PAGE_READWRITE);
		memcpy(data, Buffer, Size);

		HRESULT result = (HRESULT)HvExpansionCall(HvPeekPokeExpID,
			POKE_BYTES, Address, (QWORD)MmGetPhysicalAddress(data), Size);

		// Free our physical data and return our result
		XPhysicalFree(data);
		return result;
	}
	QWORD HvPeekSPR(SOC_SPRS SPR) {
		return HvExpansionCall(HvPeekPokeExpID, PEEK_SPR, SPR, 0, 0);
	}
	QWORD HvPokeSPR(SOC_SPRS SPR, QWORD Value) {
		return HvExpansionCall(HvPeekPokeExpID, POKE_SPR, SPR, Value, 0);
	}
	QWORD HvGetFuseline(DWORD fuse)
	{
		if ((fuse * 0x40) < 0x300)
			return HvPeekQWORD(SPACE_FUSES + ((fuse * 0x40) << 3));
		return 0;
	}

	// DUMP 1BL ROM
	DWORD Dump1blMagic()
	{
		DWORD Magic = HvPeekDWORD(MEM_1BL_LOC);
		DbgPrint("1BL Magic: %08X", Magic);
		return Magic;
	}

	HRESULT HvDump1blRom(PVOID Buffer) {
		DbgPrint("Dumping 1bl...");
		// Create a physical buffer to peek into
		VOID* data = XPhysicalAlloc(MEM_1BL_SZ, MAXULONG_PTR, 0, PAGE_READWRITE);
		ZeroMemory(data, MEM_1BL_SZ);

		HRESULT result = (HRESULT)HvExpansionCall(HvPeekPokeExpID,
			PEEK_BYTES, MEM_1BL_LOC, (QWORD)MmGetPhysicalAddress(data), MEM_1BL_SZ);

		// If its successful copy it back
		if (result == S_OK) memcpy(Buffer, data, MEM_1BL_SZ);

		// Free our physical data and return our result
		XPhysicalFree(data);
		return result;
	}

	// Check if we have access via the peek poke expansion
	BOOL CheckPPExpHVAccess()
	{
		DWORD Magic = HvPeekWORD(0);
		DbgPrint("[CheckPPExpHVAccess] HV Magic: %04X", Magic);
		if (Magic != 0x5E4E && Magic != 0x4E4E) // Dev & Ret HV Magic
		{
			DbgPrint("[CheckPPExpHVAccess] FAIL");
			return FALSE;
		}
		DbgPrint("[CheckPPExpHVAccess] SUCCESS!");
		return TRUE;
	}

	BOOL SetupPPExpHVAccess()
	{
		HRESULT res = InitHvPeekPokeExp();

		if (res != ERROR_SUCCESS)
		{
			DbgPrint("[SetupPPExpHVAccess] FAIL");
			return FALSE;
		}
		
		DbgPrint("[SetupPPExpHVAccess] SUCCESS!");
		return TRUE;
	}


	BOOL ToggleMemProtect(BOOL state)
	{
		if (state)
		{
			if (Hvx::HvGetVersion(0x72627472, SET_PROT_ON) == 1)
			{
				DbgPrint("Memory protections re-enabled!");
				return TRUE;
			}
			else
				DbgPrint("Failed to set memory protection status!");
		}
		else
		{
			if (Hvx::HvGetVersion(0x72627472, SET_PROT_OFF) == 1)
			{
				DbgPrint("Memory protections disabled!");
				return TRUE;
			}
			else
				DbgPrint("Failed to set memory protection status!");
		}

		return FALSE; // If we reached here it failed...
	}

	
}
#pragma warning(pop)

```

`XenonDumper/HVFuncs.h`:

```h
#pragma once
#include "stdafx.h"

#define MEM_1BL_LOC 0x8000020000000000ULL
#define MEM_1BL_SZ 0x8000

typedef unsigned __int64 QWORD;
#define SPACE_FUSES 0x8000020000020000ULL
extern DWORD HvPeekPokeExpID;
namespace Hvx
{

	// syscalls
	QWORD HvGetVersion(DWORD magic, DWORD mode, UINT64 dest = NULL, UINT64 src = NULL, UINT32 len = NULL, UINT64 arg_r8 = NULL);
	QWORD HvPostOutput(BYTE code, UINT64 shellCodeAddress);
	QWORD HvKeysExecute(PVOID pvPayload, DWORD cbPayload, QWORD arg1, QWORD arg2, QWORD arg3, QWORD arg4);
	QWORD HvExpansionInstall(DWORD PhysicalAddress, DWORD CodeSize);
	QWORD HvExpansionCall(DWORD ExpansionId, QWORD Param1, QWORD Param2, QWORD Param3, QWORD Param4);


	typedef enum _PEEK_POKE_TYPE {
		PEEK_BYTE = 0,
		PEEK_WORD = 1,
		PEEK_DWORD = 2,
		PEEK_QWORD = 3,
		PEEK_BYTES = 4,
		POKE_BYTE = 5,
		POKE_WORD = 6,
		POKE_DWORD = 7,
		POKE_QWORD = 8,
		POKE_BYTES = 9,
		PEEK_SPR = 10,
		POKE_SPR = 11
	} PEEK_POKE_TYPE;
	typedef enum _SOC_SPRS {
		SPR_XER = 0x1,
		SPR_LR = 0x8,
		SPR_CTR = 0x9,
		SPR_DSISR = 0x12,
		SPR_DAR = 0x13,
		SPR_DEC = 0x16,
		SPR_SDR1 = 0x19,
		SPR_SRR0 = 0x1A,
		SPR_SRR1 = 0x1B,
		SPR_ACCR = 0x1D,
		SPR_CTRL_R = 0x88,
		SPR_CTRL_W = 0x98,
		SPR_VRSAVE = 0x100,
		SPR_SPRG3_R = 0x103,
		SPR_TB_R = 0x10C,
		SPR_TBU_R = 0x10D,
		SPR_SPRG0 = 0x110,
		SPR_SPRG1 = 0x111,
		SPR_SPRG2 = 0x112,
		SPR_SPRG3 = 0x113,
		SPR_TBL_W = 0x11C,
		SPR_TBU_W = 0x11D,
		SPR_PVR = 0x11F,
		SPR_HSPRG0 = 0x130,
		SPR_HSPRG1 = 0x131,
		SPR_HDEC = 0x136,
		SPR_HIOR = 0x137,
		SPR_RMOR = 0x138,
		SPR_HRMOR = 0x139,
		SPR_HSRR0 = 0x13A,
		SPR_HSRR1 = 0x13B,
		SPR_LPCR = 0x13E,
		SPR_LPIDR = 0x13F,
		SPR_TSRL = 0x380,
		SPR_TSRR = 0x381,
		SPR_TSCR = 0x399,
		SPR_TTR = 0x39A,
		SPR_TLB_HINT = 0x3B2,
		SPR_TLB_INDEX = 0x3B3,
		SPR_TLB_VPN = 0x3B4,
		SPR_TLB_RPN = 0x3B5,
		SPR_TLB_RMT = 0x3B7,
		SPR_DRSR0 = 0x3B8,
		SPR_DRMR0 = 0x3B9,
		SPR_DCIDR0 = 0x3BA,
		SPR_DRSR1 = 0x3BB,
		SPR_DRMR1 = 0x3BC,
		SPR_DCIDR1 = 0x3BD,
		SPR_IRSR0 = 0x3D0,
		SPR_IRMR0 = 0x3D1,
		SPR_ICIDR0 = 0x3D2,
		SPR_IRSR1 = 0x3D3,
		SPR_IRMR1 = 0x3D4,
		SPR_ICIDR1 = 0x3D5,
		SPR_HID0 = 0x3F0,
		SPR_HID1 = 0x3F1,
		SPR_IABR = 0x3F2,
		SPR_HID4 = 0x3F4,
		SPR_DABR = 0x3F5,
		SPR_HID5 = 0x3F6,
		SPR_DABRX = 0x3F7,
		SPR_TDABRX = 0x3F8,
		SPR_HID6 = 0x3F9,
		SPR_HID7 = 0x3FA,
		SPR_TIABR = 0x3FB,
		SPR_BKMK = 0x3FC,
		SPR_TDABR = 0x3FD,
		SPR_PIR = 0x3FF
	} SOC_SPRS;
	

	// reading with the expansion
	BYTE    HvPeekBYTE(QWORD Address);
	WORD    HvPeekWORD(QWORD Address);
	DWORD   HvPeekDWORD(QWORD Address);
	QWORD   HvPeekQWORD(QWORD Address);
	HRESULT HvPeekBytes(QWORD Address, PVOID Buffer, DWORD Size);
	// writing with the expansion
	HRESULT HvPokeBYTE(QWORD Address, BYTE Value);
	HRESULT HvPokeWORD(QWORD Address, WORD Value);
	HRESULT HvPokeDWORD(QWORD Address, DWORD Value);
	HRESULT HvPokeQWORD(QWORD Address, QWORD Value);
	HRESULT HvPokeBytes(QWORD Address, PVOID Buffer, DWORD Size);
	// get/set SPR
	QWORD   HvPeekSPR(SOC_SPRS SPR);
	QWORD   HvPokeSPR(SOC_SPRS SPR, QWORD Value);
	// get fuselines
	QWORD	HvGetFuseline(DWORD fuse);


	BOOL CheckPPExpHVAccess();
	BOOL SetupPPExpHVAccess();

	DWORD Dump1blMagic();
	HRESULT HvDump1blRom(PVOID Buffer);

	
#define SET_PROT_ON		3
#define SET_PROT_OFF	2
	BOOL ToggleMemProtect(BOOL state);
}
```

`XenonDumper/Media/Build_XZP.bat`:

```bat
@if exist XD_res.xzp del XD_res.xzp

@pushd COMPLETED_RESOURCES

@set XUIPKG="%XEDK%\bin\win32\xuipkg.exe" /nologo

@set XUI_XZP="%~dp0%XD_res.xzp"
@set XUI_FILES=*.*

@echo Building XD_res.xzp

%XUIPKG% /R /O %XUI_XZP% %XUI_FILES%

@popd

@cmd /k
```

`XenonDumper/Media/COMPLETED_RESOURCES/0_skin.xui`:

```xui
<XuiCanvas version="000c">
<Properties>
<Width>640.000000</Width>
<Height>480.000000</Height>
</Properties>
<XuiVisual>
<Properties>
<Id>XuiSceneBlank</Id>
<Width>319.000000</Width>
<Height>130.000000</Height>
</Properties>
<Timelines>
<NamedFrames>
<NamedFrame>
<Name>Normal</Name>
<Time>0</Time>
</NamedFrame>
<NamedFrame>
<Name>EndNormal</Name>
<Time>1</Time>
</NamedFrame>
<NamedFrame>
<Name>Focus</Name>
<Time>2</Time>
</NamedFrame>
<NamedFrame>
<Name>EndFocus</Name>
<Time>3</Time>
<Command>stop</Command>
</NamedFrame>
</NamedFrames>
</Timelines>
</XuiVisual>
<XuiVisual>
<Properties>
<Id>XuiScene</Id>
<Width>405.000000</Width>
<Height>244.000000</Height>
</Properties>
<XuiGroup>
<Properties>
<Id>graphic_groupbackground</Id>
<Width>406.000000</Width>
<Height>243.000000</Height>
<Anchor>15</Anchor>
</Properties>
<XuiFigure>
<Properties>
<Id>graphic_middle</Id>
<Width>383.338287</Width>
<Height>218.008255</Height>
<Position>11.337891,12.496086,0.000000</Position>
<Anchor>15</Anchor>
<Stroke>
<Properties>
<StrokeColor>0xff000000</StrokeColor>
</Properties>
</Stroke>
<Fill>
<Properties>
<FillType>2</FillType>
<FillColor>0xff000000</FillColor>
<Gradient>
<Properties>
<NumStops>2</NumStops>
<StopColor index="0">0xe1ebebeb</StopColor>
<StopColor index="1">0x64ebebeb</StopColor>
<StopPos index="0">0.000000</StopPos>
<StopPos index="1">1.000000</StopPos>
</Properties>
</Gradient>
<Rotation>-90.000000</Rotation>
</Properties>
</Fill>
<Closed>true</Closed>
<Points>4,383.338287,218.008255,383.338287,218.008255,0.000000,218.008255,1,0.000000,218.008255,0.000000,218.008255,0.000000,0.000000,1,0.000000,0.000000,0.000000,0.000000,383.338287,0.000000,1,383.338287,0.000000,383.338287,0.000000,383.338287,218.008255,1,</Points>
</Properties>
</XuiFigure>
<XuiFigure>
<Properties>
<Id>graphic_Left</Id>
<Width>11.337882</Width>
<Height>218.010712</Height>
<Position>0.000000,12.496086,0.000000</Position>
<Anchor>11</Anchor>
<Stroke>
<Properties>
<StrokeColor>0xff000000</StrokeColor>
</Properties>
</Stroke>
<Fill>
<Properties>
<FillType>2</FillType>
<FillColor>0xff000000</FillColor>
<Gradient>
<Properties>
<NumStops>2</NumStops>
<StopColor index="0">0xe1ebebeb</StopColor>
<StopColor index="1">0x64ebebeb</StopColor>
<StopPos index="0">0.000000</StopPos>
<StopPos index="1">1.000000</StopPos>
</Properties>
</Gradient>
<Rotation>-90.000000</Rotation>
</Properties>
</Fill>
<Closed>true</Closed>
<Points>4,11.337882,218.008255,11.337882,218.008255,0.000000,218.010712,1,0.000000,218.010712,0.000000,218.010712,0.000000,0.001961,1,0.000000,0.001961,0.000000,0.001961,11.337882,0.000000,1,11.337882,0.000000,11.337882,0.000000,11.337882,218.008255,1,</Points>
</Properties>
</XuiFigure>
<XuiFigure>
<Properties>
<Id>graphic_Right</Id>
<Width>11.323822</Width>
<Height>218.010712</Height>
<Position>394.676178,12.496086,0.000000</Position>
<Anchor>14</Anchor>
<Stroke>
<Properties>
<StrokeColor>0xff000000</StrokeColor>
</Properties>
</Stroke>
<Fill>
<Properties>
<FillType>2</FillType>
<FillColor>0xff000000</FillColor>
<Gradient>
<Properties>
<NumStops>2</NumStops>
<StopColor index="0">0xe1ebebeb</StopColor>
<StopColor index="1">0x64ebebeb</StopColor>
<StopPos index="0">0.000000</StopPos>
<StopPos index="1">1.000000</StopPos>
</Properties>
</Gradient>
<Rotation>-90.000000</Rotation>
</Properties>
</Fill>
<Closed>true</Closed>
<Points>4,11.323822,218.010712,11.323822,218.010712,0.000000,218.008255,1,0.000000,218.008255,0.000000,218.008255,0.000000,0.000000,1,0.000000,0.000000,0.000000,0.000000,11.323822,0.001961,1,11.323822,0.001961,11.323822,0.001961,11.323822,218.010712,1,</Points>
</Properties>
</XuiFigure>
<XuiFigure>
<Properties>
<Id>graphic_LeftTop</Id>
<Width>41.327381</Width>
<Height>12.498047</Height>
<Anchor>3</Anchor>
<Stroke>
<Properties>
<StrokeColor>0xff000000</StrokeColor>
</Properties>
</Stroke>
<Fill>
<Properties>
<FillType>2</FillType>
<FillColor>0xff000000</FillColor>
<Gradient>
<Properties>
<NumStops>2</NumStops>
<StopColor index="0">0x96ebebeb</StopColor>
<StopColor index="1">0xe1ebebeb</StopColor>
<StopPos index="0">0.000000</StopPos>
<StopPos index="1">1.000000</StopPos>
</Properties>
</Gradient>
<Rotation>-90.000000</Rotation>
</Properties>
</Fill>
<Closed>true</Closed>
<Points>5,0.000000,12.498047,0.000000,12.498047,0.000000,7.000000,1,0.000000,7.000000,0.000000,3.133789,3.133789,0.000000,1,7.000000,0.000000,7.000000,0.000000,41.327381,0.000000,1,41.327381,0.000000,41.327381,0.000000,41.327381,12.496088,1,41.327381,12.496088,41.327381,12.496088,0.000000,12.498047,1,</Points>
</Properties>
</XuiFigure>
<XuiFigure>
<Properties>
<Id>graphic_RightTop</Id>
<Width>41.321045</Width>
<Height>12.498047</Height>
<Position>364.672119,0.000000,0.000000</Position>
<Anchor>6</Anchor>
<Stroke>
<Properties>
<StrokeColor>0xff000000</StrokeColor>
</Properties>
</Stroke>
<Fill>
<Properties>
<FillType>2</FillType>
<FillColor>0xff000000</FillColor>
<Gradient>
<Properties>
<NumStops>2</NumStops>
<StopColor index="0">0x96ebebeb</StopColor>
<StopColor index="1">0xe1ebebeb</StopColor>
<StopPos index="0">0.000000</StopPos>
<StopPos index="1">1.000000</StopPos>
</Properties>
</Gradient>
<Rotation>-90.000000</Rotation>
</Properties>
</Fill>
<Closed>true</Closed>
<Points>5,41.321045,12.498047,41.321045,12.498047,41.321045,7.000000,1,41.321045,7.000000,41.321045,3.133789,38.187256,0.000000,1,34.321045,0.000000,34.321045,0.000000,0.000000,0.000000,1,0.000000,0.000000,0.000000,0.000000,0.000000,12.496088,1,0.000000,12.496088,0.000000,12.496088,41.321045,12.498047,1,</Points>
</Properties>
</XuiFigure>
<XuiFigure>
<Properties>
<Id>graphic_Top</Id>
<Width>323.344696</Width>
<Height>12.496088</Height>
<Position>41.327381,0.000000,0.000000</Position>
<Anchor>7</Anchor>
<Stroke>
<Properties>
<StrokeColor>0xff000000</StrokeColor>
</Properties>
</Stroke>
<Fill>
<Properties>
<FillType>2</FillType>
<FillColor>0xff000000</FillColor>
<Gradient>
<Properties>
<NumStops>2</NumStops>
<StopColor index="0">0x96ebebeb</StopColor>
<StopColor index="1">0xe1ebebeb</StopColor>
<StopPos index="0">0.000000</StopPos>
<StopPos index="1">1.000000</StopPos>
</Properties>
</Gradient>
<Rotation>-90.000000</Rotation>
</Properties>
</Fill>
<Closed>true</Closed>
<Points>4,0.000000,12.496088,0.000000,12.496088,0.000000,0.000000,1,0.000000,0.000000,0.000000,0.000000,323.344696,0.000000,1,323.344696,0.000000,323.344696,0.000000,323.344696,12.496088,1,323.344696,12.496088,323.344696,12.496088,0.000000,12.496088,1,</Points>
</Properties>
</XuiFigure>
<XuiFigure>
<Properties>
<Id>graphic_RightBot</Id>
<Width>41.327454</Width>
<Height>12.498047</Height>
<Position>364.665710,230.501953,0.000000</Position>
<Anchor>12</Anchor>
<Stroke>
<Properties>
<StrokeColor>0xff000000</StrokeColor>
</Properties>
</Stroke>
<Fill>
<Properties>
<FillType>2</FillType>
<FillColor>0xff000000</FillColor>
<Gradient>
<Properties>
<NumStops>2</NumStops>
<StopColor index="0">0x64ebebeb</StopColor>
<StopColor index="1">0x96ebebeb</StopColor>
<StopPos index="0">0.000000</StopPos>
<StopPos index="1">0.992157</StopPos>
</Properties>
</Gradient>
<Rotation>-90.000000</Rotation>
</Properties>
</Fill>
<Closed>true</Closed>
<Points>5,41.327454,0.000000,41.327454,0.000000,41.327454,5.498047,1,41.327454,5.498047,41.327454,9.364258,38.193665,12.498047,1,34.327454,12.498047,34.327454,12.498047,0.000000,12.498047,1,0.000000,12.498047,0.000000,12.498047,0.000000,0.002380,1,0.000000,0.002380,0.000000,0.002380,41.327454,0.000000,1,</Points>
</Properties>
</XuiFigure>
<XuiFigure>
<Properties>
<Id>graphic_LeftBot</Id>
<Width>41.321018</Width>
<Height>12.498047</Height>
<Position>0.000000,230.501953,0.000000</Position>
<Anchor>9</Anchor>
<Stroke>
<Properties>
<StrokeColor>0xff000000</StrokeColor>
</Properties>
</Stroke>
<Fill>
<Properties>
<FillType>2</FillType>
<FillColor>0xff000000</FillColor>
<Gradient>
<Properties>
<NumStops>2</NumStops>
<StopColor index="0">0x64ebebeb</StopColor>
<StopColor index="1">0x96ebebeb</StopColor>
<StopPos index="0">0.000000</StopPos>
<StopPos index="1">0.992157</StopPos>
</Properties>
</Gradient>
<Rotation>-90.000000</Rotation>
</Properties>
</Fill>
<Closed>true</Closed>
<Points>5,0.000000,0.000000,0.000000,0.000000,0.000000,5.498047,1,0.000000,5.498047,0.000000,9.364258,3.133789,12.498047,1,7.000000,12.498047,7.000000,12.498047,41.321018,12.498047,1,41.321018,12.498047,41.321018,12.498047,41.321018,0.002380,1,41.321018,0.002380,41.321018,0.002380,0.000000,0.000000,1,</Points>
</Properties>
</XuiFigure>
<XuiFigure>
<Properties>
<Id>graphic_Bot</Id>
<Width>323.344635</Width>
<Height>12.487854</Height>
<Position>41.321022,230.504333,0.000000</Position>
<Anchor>13</Anchor>
<Stroke>
<Properties>
<StrokeColor>0xff000000</StrokeColor>
</Properties>
</Stroke>
<Fill>
<Properties>
<FillType>2</FillType>
<FillColor>0xff000000</FillColor>
<Gradient>
<Properties>
<NumStops>2</NumStops>
<StopColor index="0">0x64ebebeb</StopColor>
<StopColor index="1">0x96ebebeb</StopColor>
<StopPos index="0">0.000000</StopPos>
<StopPos index="1">0.992157</StopPos>
</Properties>
</Gradient>
<Rotation>-90.000000</Rotation>
</Properties>
</Fill>
<Closed>true</Closed>
<Points>4,323.344635,0.000000,323.344635,0.000000,323.344635,12.487854,1,323.344635,12.487854,323.344635,12.487854,0.000000,12.487854,1,0.000000,12.487854,0.000000,12.487854,0.000000,0.000000,1,0.000000,0.000000,0.000000,0.000000,323.344635,0.000000,1,</Points>
</Properties>
</XuiFigure>
</XuiGroup>
<XuiTextPresenter>
<Properties>
<Id>XuiTextPresenter</Id>
<Width>406.000000</Width>
<Height>40.000000</Height>
<Anchor>5</Anchor>
<TextColor>0xff0f0f0f</TextColor>
<PointSize>18.000000</PointSize>
<TextStyle>1040</TextStyle>
</Properties>
</XuiTextPresenter>
<Timelines>
<NamedFrames>
<NamedFrame>
<Name>Normal</Name>
<Time>0</Time>
</NamedFrame>
<NamedFrame>
<Name>EndNormal</Name>
<Time>1</Time>
<Command>stop</Command>
</NamedFrame>
<NamedFrame>
<Name>Focus</Name>
<Time>2</Time>
</NamedFrame>
<NamedFrame>
<Name>EndFocus</Name>
<Time>3</Time>
<Command>stop</Command>
</NamedFrame>
</NamedFrames>
</Timelines>
</XuiVisual>
<XuiVisual>
<Properties>
<Id>Byrom_LegendBtn</Id>
<Width>167.000000</Width>
<Height>80.000000</Height>
</Properties>
<XuiTextPresenter>
<Properties>
<Id>XuiTextPresenter1</Id>
<Width>167.000000</Width>
<Height>22.000000</Height>
<Position>0.000000,57.000000,0.000000</Position>
<TextColor>0xffebebeb</TextColor>
<PointSize>13.000000</PointSize>
<TextStyle>5140</TextStyle>
</Properties>
</XuiTextPresenter>
<XuiImagePresenter>
<Properties>
<Id>XuiImagePresenter1</Id>
<Width>70.000000</Width>
<Height>54.000000</Height>
<Position>48.000000,0.000000,0.000000</Position>
<SizeMode>4</SizeMode>
</Properties>
</XuiImagePresenter>
<Timelines>
<NamedFrames>
<NamedFrame>
<Name>Normal</Name>
<Time>0</Time>
</NamedFrame>
<NamedFrame>
<Name>EndNormal</Name>
<Time>1</Time>
<Command>stop</Command>
</NamedFrame>
<NamedFrame>
<Name>Press</Name>
<Time>2</Time>
</NamedFrame>
<NamedFrame>
<Name>EndPress</Name>
<Time>3</Time>
<Command>stop</Command>
</NamedFrame>
<NamedFrame>
<Name>NormalDisable</Name>
<Time>4</Time>
<Command>stop</Command>
</NamedFrame>
<NamedFrame>
<Name>EndNormalDisable</Name>
<Time>5</Time>
<Command>stop</Command>
</NamedFrame>
</NamedFrames>
<Timeline>
<Id>XuiTextPresenter1</Id>
<TimelineProp>Show</TimelineProp>
<KeyFrame>
<Time>0</Time>
<Interpolation>1</Interpolation>
<Prop>true</Prop>
</KeyFrame>
<KeyFrame>
<Time>4</Time>
<Interpolation>1</Interpolation>
<Prop>false</Prop>
</KeyFrame>
<KeyFrame>
<Time>5</Time>
<Interpolation>1</Interpolation>
<Prop>false</Prop>
</KeyFrame>
</Timeline>
<Timeline>
<Id>XuiImagePresenter1</Id>
<TimelineProp>Show</TimelineProp>
<KeyFrame>
<Time>0</Time>
<Interpolation>0</Interpolation>
<Prop>true</Prop>
</KeyFrame>
<KeyFrame>
<Time>4</Time>
<Interpolation>0</Interpolation>
<Prop>false</Prop>
</KeyFrame>
<KeyFrame>
<Time>5</Time>
<Interpolation>0</Interpolation>
<Prop>false</Prop>
</KeyFrame>
</Timeline>
</Timelines>
</XuiVisual>
</XuiCanvas>

```

`XenonDumper/Media/COMPLETED_RESOURCES/1_scene.xui`:

```xui
<XuiCanvas version="000c">
<Properties>
<Id>XuiCanvas</Id>
<Width>1280.000000</Width>
<Height>720.000000</Height>
</Properties>
<XuiScene>
<Properties>
<Id>MainScene</Id>
<Width>1280.000000</Width>
<Height>720.000000</Height>
<DesignTimeData>[LayerFolders]4|-Modifiable text|1|+|0|-Button A|1|+|0|-Button Back|1|+|2[/LayerFolders]</DesignTimeData>
<ClassOverride>MainScene</ClassOverride>
<Visual>XuiSceneBlank</Visual>
</Properties>
<XuiImage>
<Properties>
<Id>ImgBackground</Id>
<Width>1280.000000</Width>
<Height>720.000000</Height>
<Position>-1.000000,0.000000,0.000000</Position>
<SizeMode>4</SizeMode>
<ImagePath>Background</ImagePath>
</Properties>
</XuiImage>
<XuiText>
<Properties>
<Id>textWatermark</Id>
<Width>124.666718</Width>
<Height>32.000000</Height>
<Position>991.333313,636.000000,0.000000</Position>
<Opacity>0.200000</Opacity>
<Text>Byrom</Text>
<TextColor>0xffebebeb</TextColor>
<DropShadowColor>0x800f0f0f</DropShadowColor>
<TextStyle>4628</TextStyle>
</Properties>
</XuiText>
<XuiButton>
<Properties>
<Id>btnExitApp</Id>
<Width>167.000000</Width>
<Height>80.000000</Height>
<Position>1025.000000,522.000000,0.000000</Position>
<Visual>Byrom_LegendBtn</Visual>
<UnfocusedInput>true</UnfocusedInput>
<Text>Exit App</Text>
<ImagePath>ButtonBACK.png</ImagePath>
<PressKey>22549</PressKey>
</Properties>
</XuiButton>
<XuiButton>
<Properties>
<Id>btnAccept</Id>
<Width>167.000000</Width>
<Height>80.000000</Height>
<Position>1025.000000,296.000000,0.000000</Position>
<Visual>Byrom_LegendBtn</Visual>
<UnfocusedInput>true</UnfocusedInput>
<Text>Dump Files</Text>
<ImagePath>button_a.png</ImagePath>
<PressKey>22528</PressKey>
</Properties>
</XuiButton>
<XuiText>
<Properties>
<Id>textPrompt</Id>
<Width>763.599976</Width>
<Height>413.000000</Height>
<Position>198.799973,184.199982,0.000000</Position>
<Text>This unofficial app will dump all the required files and data to use the Xenon Emulator.

All files can be found in the "console" directory upon completion.

- Press the A button to continue -</Text>
<TextColor>0xffebeb0f</TextColor>
<DropShadowColor>0x800f0f0f</DropShadowColor>
<PointSize>18.000000</PointSize>
<TextStyle>5124</TextStyle>
</Properties>
</XuiText>
<XuiText>
<Properties>
<Id>textHeader</Id>
<Width>522.536072</Width>
<Height>32.000000</Height>
<Position>133.191956,97.631935,0.000000</Position>
<Text>Xenon Dumper</Text>
<TextColor>0xffebebeb</TextColor>
<DropShadowColor>0x800f0f0f</DropShadowColor>
<PointSize>20.000000</PointSize>
<TextStyle>4372</TextStyle>
</Properties>
</XuiText>
<XuiImage>
<Properties>
<Id>img_XenonEmu</Id>
<Width>80.000000</Width>
<Height>80.000000</Height>
<Position>1172.000000,627.000000,0.000000</Position>
<ImagePath>XenonLogo.png</ImagePath>
</Properties>
</XuiImage>
<XuiText>
<Properties>
<Id>textXenonEmuGit</Id>
<Width>660.599976</Width>
<Position>289.799988,619.199951,0.000000</Position>
<Text>https://github.com/xenon-emu/xenon</Text>
<TextColor>0xffebebeb</TextColor>
<DropShadowColor>0x800f0f0f</DropShadowColor>
<TextStyle>4356</TextStyle>
</Properties>
</XuiText>
<XuiText>
<Properties>
<Id>textXenonDumperGit</Id>
<Width>660.599976</Width>
<Position>289.799988,649.199951,0.000000</Position>
<Text>https://github.com/Byrom90/XenonDumper</Text>
<TextColor>0xffebebeb</TextColor>
<DropShadowColor>0x800f0f0f</DropShadowColor>
<TextStyle>4356</TextStyle>
</Properties>
</XuiText>
</XuiScene>
</XuiCanvas>

```

`XenonDumper/XenonDumper.cpp`:

```cpp
#include "stdafx.h"

HRESULT RenderGame(IDirect3DDevice9* pDevice)
{
	// Render game graphics.
	pDevice->Clear(
		0,
		NULL,
		D3DCLEAR_TARGET | D3DCLEAR_STENCIL | D3DCLEAR_ZBUFFER,
		D3DCOLOR_ARGB(255, 32, 32, 64),
		1.0,
		0);

	return S_OK;
}

HRESULT InitD3D(IDirect3DDevice9** ppDevice,
	D3DPRESENT_PARAMETERS* pd3dPP)
{
	IDirect3D9* pD3D;

	pD3D = Direct3DCreate9(D3D_SDK_VERSION);

	// Set up the presentation parameters.
	ZeroMemory(pd3dPP, sizeof(D3DPRESENT_PARAMETERS));
	pd3dPP->BackBufferWidth = 1280;
	pd3dPP->BackBufferHeight = 720;
	pd3dPP->BackBufferFormat = D3DFMT_A8R8G8B8;
	pd3dPP->BackBufferCount = 1;
	pd3dPP->MultiSampleType = D3DMULTISAMPLE_NONE;
	pd3dPP->SwapEffect = D3DSWAPEFFECT_DISCARD;
	pd3dPP->EnableAutoDepthStencil = TRUE;
	pd3dPP->AutoDepthStencilFormat = D3DFMT_D24S8;
	pd3dPP->PresentationInterval = D3DPRESENT_INTERVAL_ONE;

	// Create the device.
	return pD3D->CreateDevice(
		0,
		D3DDEVTYPE_HAL,
		NULL,
		D3DCREATE_HARDWARE_VERTEXPROCESSING,
		pd3dPP,
		ppDevice);
}


BOOL bShouldExit = FALSE;
// Entry point of the title.
int __cdecl main()
{
	DbgPrint("Starting...");

	IsDevkit = *(DWORD*)0x8E038610 & 0x8000 ? FALSE : TRUE;
	DbgPrint("IsDevkit: %s", IsDevkit ? "TRUE" : "FALSE");

	if (CreateMount(MOUNT_FLASH, DEVICE_FLASH, FALSE)) // Set the flash mount so we can access the font
	{
		DbgPrint("Failed to set flash mount!");
		return 1;
	}

	hAPP = GetModuleHandle(NULL);

	IDirect3DDevice9* pDevice;
	D3DPRESENT_PARAMETERS d3dpp;
	HRESULT hr;

	// Initialize D3D
	hr = InitD3D(&pDevice, &d3dpp);
	if (FAILED(hr)) {
		DbgPrint("Failed initializing D3D! Exiting...");
		return 1;
	}

	// Declare an instance of the XUI framework.
	CMyApp app;

	// Initialize the application.
	hr = app.InitShared(pDevice, &d3dpp,
		XuiD3DXTextureLoader);

	if (FAILED(hr))
	{
		DbgPrint("Failed initializing application! Exiting...\n");
		return 1;
	}


	// Register a default typeface
	HRESULT fontresult = app.RegisterDefaultTypeface(L"Tahoma", L"file://flash:/XenonJKLatin.xtt"); // Use the system font that already exists on the flash

	DbgPrint("Font register result: %08X", fontresult); 

	if (app.LoadSkin(LinkWChar(L"section://%08X,XDR#0_skin.xur", hAPP)) == 0)
	{
		if (app.LoadFirstScene(L"", LinkWChar(L"section://%08X,XDR#1_scene.xur", hAPP), NULL))
		{
			DbgPrint("Failed to load scene! Exiting...");
			XNotify(L"Failed to load scene!");
			bShouldExit = TRUE;
		}
	}
	else
	{
		DbgPrint("Failed to load skin! Exiting...");
		XNotify(L"Failed to load skin!");
		bShouldExit = TRUE;
	}

	while (!bShouldExit) {
		// Render game graphics.
		RenderGame(pDevice);

		// Update XUI
		app.RunFrame();

		// Render XUI
		hr = app.Render();

		// Update XUI Timers
		hr = XuiTimersRun();

		// Present the frame.
		pDevice->Present(NULL, NULL, NULL, NULL);

	}
	// Free resources, unregister custom classes, and exit.
	DbgPrint("Exiting...");
	app.Uninit();
	pDevice->Release();
}



```

`XenonDumper/XenonDumper.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release_LTCG|Xbox 360">
      <Configuration>Release_LTCG</Configuration>
      <Platform>Xbox 360</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectName>XenonDumper</ProjectName>
    <ProjectGuid>{652C7D60-BC02-4E09-96DD-930012345678}</ProjectGuid>
    <RootNamespace>XuiTutorial</RootNamespace>
    <Keyword>Win32Proj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <UseOfAtl>false</UseOfAtl>
    <PlatformToolset>2010-01</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">$(Configuration)\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">$(Configuration)\</IntDir>
    <RemoteRoot Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">devkit:\$(SolutionName)</RemoteRoot>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'" />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">
    <LibraryPath>$(Xbox360TechPreviewLibrary);$(XDKInstallDir)\lib\xbox;</LibraryPath>
    <ImageXexOutput>$(OutDir)$(ProjectName).xex</ImageXexOutput>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Full</Optimization>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <StringPooling>true</StringPooling>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <OpenMPSupport>FALSE</OpenMPSupport>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <ExceptionHandling>false</ExceptionHandling>
      <AdditionalIncludeDirectories>libs\Atg;libs\Szp;libs\xkelib;libs\XboxTLS;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;NDEBUG;_XBOX;XBOX;XBOX_SAMPLE;_XBOX_CRT_DEPRECATE_INSECURE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <ForceConformanceInForLoopScope>true</ForceConformanceInForLoopScope>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <AssemblerOutput>NoListing</AssemblerOutput>
      <AnalyzeStalls>false</AnalyzeStalls>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
    </ClCompile>
    <Link>
      <AdditionalOptions>/ignore:4089  %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>xnet.lib;xact3.lib;xuirunltcg.lib;xuirenderltcg.lib;xaudio2.lib;xmcore.lib;xmedia2.lib;d3d9ltcg.lib;d3dx9.lib;xgraphics.lib;xapilib.lib;xaudio2.lib;x3daudioltcg.lib;xmcoreltcg.lib;xboxkrnl.lib;xbdm.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <SetChecksum>true</SetChecksum>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <AdditionalLibraryDirectories>libs\Atg;libs\Szp\Release_LTCG;libs\xkelib;libs\XboxTLS\Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
    <ImageXex>
      <ConfigurationFile>AppConf.xml</ConfigurationFile>
      <AdditionalSections>
      </AdditionalSections>
      <TitleID>
      </TitleID>
    </ImageXex>
    <Deploy>
      <DeploymentType>
      </DeploymentType>
      <DvdEmulationType>ZeroSeekTimes</DvdEmulationType>
      <DeploymentFiles>$(RemoteRoot)=$(ImagePath);</DeploymentFiles>
      <ExcludedFromBuild>false</ExcludedFromBuild>
    </Deploy>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="HVFuncs.cpp" />
    <ClCompile Include="XenonDumper.cpp" />
    <ClCompile Include="Functions.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="XuiClasses.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Functions.h" />
    <ClInclude Include="HVFuncs.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="XuiClasses.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
</Project>
```

`XenonDumper/XenonDumper.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns:atg="http://atg.xbox.com" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="XenonDumper.cpp" />
    <ClCompile Include="Functions.cpp" />
    <ClCompile Include="stdafx.cpp" />
    <ClCompile Include="XuiClasses.cpp" />
    <ClCompile Include="HVFuncs.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Functions.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="XuiClasses.h" />
    <ClInclude Include="HVFuncs.h" />
  </ItemGroup>
</Project>
```

`XenonDumper/XuiClasses.cpp`:

```cpp
#include "stdafx.h"

#pragma region APP
// Register custom classes.
HRESULT CMyApp::RegisterXuiClasses()
{
	CMainScene::Register();
	return S_OK;
}

// Unregister custom classes.
HRESULT CMyApp::UnregisterXuiClasses()
{
	CMainScene::Unregister();
	return S_OK;
}
#pragma endregion


#define DUMP_DIR		"GAME:\\console"
#define PATH_1BL		DUMP_DIR "\\1bl.bin"
#define PATH_FUSES		DUMP_DIR "\\fuses.txt"

#define NAND_DIR		"GAME:\\nand"
#define PATH_NAND_AUTO	NAND_DIR "\\simpleflasher.cmd"
#define PATH_NAND_XEX	NAND_DIR "\\Simple360NandFlasher.xex"
#define RES_NAND_XEX	"S360NF"

//==============================================================================================================================================================================
//
//			CLASS TO HANDLE THE MainScene
//
//==============================================================================================================================================================================
#pragma region Overlay
extern BOOL bShouldExit;

BOOL KillControls = FALSE;

// Default yellow colour used for text 0xFFEBEB0F
DWORD YellowTextCol = 0xFFEBEB0F;
// Red for error 0xFFFF0000
DWORD RedTextCol = 0xFFFF0000;
HRESULT CMainScene::SetTextColour(HXUIOBJ TextObject, DWORD dwTextColour)
{
	HRESULT ret = S_FALSE;
	DWORD dwId; XUIElementPropVal pVal;
	ret = XuiObjectGetPropertyId(TextObject, L"TextColor", &dwId);
	if (ret == S_OK) {
		pVal.SetColorVal(dwTextColour);
		ret = XuiObjectSetProperty(TextObject, dwId, 0, &pVal);
	}
	return ret;
}

BOOL CreateFusesTxt()
{
	FILE* fd;
	fopen_s(&fd, PATH_FUSES, "w");
	if (fd != NULL)
	{
		QWORD FuseArray[12];
		for (int i = 0; i < 12; i++)
		{
			FuseArray[i] = Hvx::HvGetFuseline(i);
			DbgPrint("fuseset %02d: %016llx", i, FuseArray[i]);
			fprintf(fd, "fuseset %02d: %016llx\n", i, FuseArray[i]); 
		}
		// CPUKey
		DbgPrint("Your CPU key : %016llX%016llX", FuseArray[3], FuseArray[5]); // fuse lines 3 & 5
		fprintf(fd, "\nYour CPU key : %016llX%016llX\n", FuseArray[3], FuseArray[5]);
		// DVDKey
		BYTE DVDKeyBytes[16];
		QWORD kvAddress = Hvx::HvPeekQWORD(IsDevkit ? 0x00000002000162E0 : 0x00000002000163C0);
		Hvx::HvPeekBytes(kvAddress + 0x100, DVDKeyBytes, 16);
		DbgPrint("Your DVD key : %016llX%016llX", *(QWORD*)(DVDKeyBytes), *(QWORD*)(DVDKeyBytes + 8));
		fprintf(fd, "Your DVD key : %016llX%016llX", *(QWORD*)(DVDKeyBytes), *(QWORD*)(DVDKeyBytes + 8));

		fclose(fd);
		return TRUE;
	}
	return FALSE;
}

BOOL Save1blToFile()
{
	BYTE RomBuf[MEM_1BL_SZ];
	ZeroMemory(RomBuf, MEM_1BL_SZ);
	HRESULT res = Hvx::HvDump1blRom(RomBuf);
	if (!res)
	{
		if (CWriteFile(PATH_1BL, &RomBuf, sizeof(RomBuf)) == TRUE)
		{
			return TRUE;
		}
		DbgPrint("[Save1blToFile] Failed to write file!");
	}
	else
	{
		DbgPrint("[Save1blToFile] HV exp call failed! %08X", res);
	}
	return FALSE;
}

BOOL CreateNandDumpAutofile()
{
	FILE* fd;
	fopen_s(&fd, PATH_NAND_AUTO, "w");
	if (fd != NULL)
	{
		fprintf(fd, "dump");
		fclose(fd);
		return TRUE;
	}
	return FALSE;
}

BOOL CreateNandDumpXex()
{
	VOID* pSectionData;
	DWORD dwSectionSize;

	HMODULE hModule = GetModuleHandle(NULL);

	if (XGetModuleSection(hModule, RES_NAND_XEX, &pSectionData, &dwSectionSize))
	{
		if (CWriteFile(PATH_NAND_XEX, pSectionData, dwSectionSize) == TRUE)
		{
			return TRUE;
		}
	}

	return FALSE;
}

VOID CMainScene::SetFailedText(wstring ErrorText) // Sets failed text as well as disable the A button to prevent further input. User must exit using the back button
{
	btnAccept.SetEnable(FALSE);
	btnAccept.SetShow(FALSE);
	SetTextColour(textPrompt, RedTextCol);
	textPrompt.SetText(ErrorText.c_str());
	
}

HRESULT CMainScene::OnInit(XUIMessageInit* pInitData,
	BOOL& bHandled)
{
	GetChildById(L"textPrompt", &textPrompt);
	GetChildById(L"btnAccept", &btnAccept);
	GetChildById(L"btnExitApp", &btnExitApp);
	GetChildById(L"ImgBackground", &ImgBackground);
	
	if ((IsDevkit && !(XboxKrnlVersion->Build >= 17489)) || (!IsDevkit && XboxKrnlVersion->Build != 17559))
	{
		SetFailedText(L"Unsupported kernel version!\nThis app only supports versions 17559 Retail & 17489 (or 17559 spoofed) Developer.\n- Press the Back button to exit -");
	}
	else
	{
		if (!Hvx::CheckPPExpHVAccess()) // Check if we have pp access. We can't do anything without it
		{
			if (!Hvx::SetupPPExpHVAccess()) // If not we try to setup the expansion. If we fail here we're done
			{
				SetFailedText(L"Unable to obtain HV access via expansion!\nHV access is required to proceed.\n- Press the Back button to exit -");
			}
		}
	}

	return S_OK;
}



BOOL bStage1Complete = FALSE;
HRESULT CMainScene::OnNotifyPress(HXUIOBJ hObjPressed, BOOL& bHandled)
{
	
	if (KillControls) {
		bHandled = TRUE;
		return S_OK;
	}

	if (hObjPressed == btnExitApp)
	{
		bShouldExit = TRUE;
	}
	else if (hObjPressed == btnAccept)
	{
		KillControls = TRUE;
		

		if (!bStage1Complete) // Dump the fuses and 1bl
		{
			if (!DirectoryExists(DUMP_DIR)) CreateDirectory(DUMP_DIR, NULL);

			if (!CreateFusesTxt()) SetFailedText(L"Failed to dump fuses!\n- Press the Back button to exit -");
			else
			{
				if (!Save1blToFile()) SetFailedText(L"Failed to dump 1bl.bin!\n- Press the Back button to exit -");
				else
				{
					bStage1Complete = TRUE;
					textPrompt.SetText(L"fuses.txt & 1bl.bin have now been dumped!\nNand dumping will be handled by Simple360NandFlasher.\nThis is automated and should not require any buttons to be pressed.\n- Press the A button to continue -");
					btnAccept.SetText(L"Continue");
				}
			}
		}
		else // Setup and launch simple 360 in automode for dumping
		{
			if (!DirectoryExists(NAND_DIR)) CreateDirectory(NAND_DIR, NULL);

			if (CreateNandDumpAutofile() && CreateNandDumpXex()) XLaunchNewImage(PATH_NAND_XEX, 0);
			else SetFailedText(L"Failed to automate the launch of Simple360NandFlasher!\nNOTE: You can still dump your nand manually.\n- Press the Back button to exit -");
		}
		KillControls = FALSE;
	}

	bHandled = TRUE;
	return S_OK;
}


/*
HRESULT CMainScene::OnTimer(XUIMessageTimer* pTimer, BOOL& bHandled)
{
	// which timer is it?
	switch (pTimer->nId)
	{
	
	default:
		break;
	}

	bHandled = TRUE;

	return(S_OK);
}
*/
```

`XenonDumper/XuiClasses.h`:

```h
#ifndef __XuiClasses_H__
#define __XuiClasses_H__
#pragma once

class CMyApp : public CXuiModule
{
protected:
	// Override so that CMyApp can register classes.
	virtual HRESULT RegisterXuiClasses();

	// Override so that CMyApp can unregister classes. 
	virtual HRESULT UnregisterXuiClasses();
};


//==============================================================================================================================================================================
//
//			CLASS TO HANDLE THE Main Scene
//
//==============================================================================================================================================================================
#pragma region MainScene
class CMainScene : public CXuiSceneImpl
{
	//private:
public:
	XUI_IMPLEMENT_CLASS(CMainScene, L"MainScene", XUI_CLASS_SCENE)
protected:
	CXuiTextElement textPrompt;
	CXuiControl btnExitApp, btnAccept;
	CXuiImageElement ImgBackground;
	
	// Handler for the XM_INIT message.
	HRESULT OnInit(XUIMessageInit* pInitData, BOOL& bHandled);
	HRESULT OnNotifyPress(HXUIOBJ hObjPressed, BOOL& bHandled);
	//HRESULT OnTimer(XUIMessageTimer* pTimer, BOOL& bHandled);
	HRESULT SetTextColour(HXUIOBJ TextObject, DWORD dwTextColour);

	VOID SetFailedText(wstring ErrorText);

	// Message map.
	XUI_BEGIN_MSG_MAP()
		XUI_ON_XM_INIT(OnInit)
		XUI_ON_XM_NOTIFY_PRESS(OnNotifyPress)
		//XUI_ON_XM_TIMER(OnTimer)
		XUI_END_MSG_MAP()

};
#pragma endregion

#endif
```

`XenonDumper/libs/Atg/AtgAnimation.cpp`:

```cpp
//-----------------------------------------------------------------------------
// AtgAnimation.cpp
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include <vector>
#include <algorithm>
#include "AtgAnimation.h"
#include "AtgScene.h"

namespace ATG
{
    const StringID AnimationTransformTrack::TypeID( L"AnimationTransformTrack" );
    const StringID Animation::TypeID( L"Animation" );

#define KEY_SEARCH_DISTANCE     4

    //----------------------------------------------------------------------------------
    // Name: AnimationKeyArray constructor
    // Desc: Initializes an AnimationKeyArray class to null values, and verifies the
    //       dimension is valid.
    //----------------------------------------------------------------------------------
    AnimationKeyArray::AnimationKeyArray( DWORD dwValueDimension )
        : m_dwValueDimension( dwValueDimension ),
          m_pFloatData( NULL ),
          m_dwSize( 0 ),
          m_dwCapacity( 0 )
    {
        assert( m_dwValueDimension > 0 );
    }


    //----------------------------------------------------------------------------------
    // Name: AnimationKeyArray destructor
    // Desc: Cleans up the memory allocations.
    //----------------------------------------------------------------------------------
    AnimationKeyArray::~AnimationKeyArray()
    {
        delete[] m_pFloatData;
        m_pFloatData = NULL;
        m_dwCapacity = 0;
        m_dwSize = 0;
        m_dwValueDimension = 0;
    }


    //----------------------------------------------------------------------------------
    // Name: Resize()
    // Desc: Increases the size of the key storage buffer.  Ideally, your initialization
    //       code should call this method once with the total number of keys, so no
    //       further resizes will be necessary.
    //----------------------------------------------------------------------------------
    VOID AnimationKeyArray::Resize( DWORD dwNewCapacity )
    {
        assert( dwNewCapacity > m_dwCapacity );
        assert( m_dwValueDimension > 0 );

        // Allocate and clear new buffer.
        DWORD dwFloatCount = ( m_dwValueDimension + 1 ) * dwNewCapacity;
        FLOAT* pNewBuffer = new FLOAT[ dwFloatCount ];
        ZeroMemory( pNewBuffer, dwFloatCount * sizeof( FLOAT ) );

        // Copy existing contents to new buffer.
        if( m_pFloatData != NULL )
        {
            DWORD dwExistingSize = m_dwSize * ( m_dwValueDimension + 1 ) * sizeof( FLOAT );
            XMemCpy( pNewBuffer, m_pFloatData, dwExistingSize );
            delete[] m_pFloatData;
            m_pFloatData = NULL;
        }

        // Update buffer pointer and capacity.
        m_pFloatData = pNewBuffer;
        m_dwCapacity = dwNewCapacity;
    }


    //----------------------------------------------------------------------------------
    // Name: PointToBuffer()
    // Desc: Initializes the key array with a pointer to a pre-allocated key array.
    //       This is the most preferred method of initialization if you already have the
    //       key data in memory, such as from a resource loader.
    //----------------------------------------------------------------------------------
    VOID AnimationKeyArray::PointToBuffer( FLOAT* pBuffer, DWORD dwBufferSizeBytes, DWORD dwKeyCount, DWORD dwValueDimension )
    {
        // Sanity checks.
        assert( pBuffer != NULL );
        assert( dwBufferSizeBytes == ( dwKeyCount * ( dwValueDimension + 1 ) * sizeof( FLOAT ) ) );

        // Destroy any existing buffer.
        if( m_pFloatData != NULL )
            delete[] m_pFloatData;

        // Initialize with new buffer.
        m_pFloatData = pBuffer;
        m_dwCapacity = dwKeyCount;
        m_dwSize = dwKeyCount;
        m_dwValueDimension = dwValueDimension;
    }


    //----------------------------------------------------------------------------------
    // Name: AddKey()
    // Desc: Increases the size member by one.  If there is not enough capacity to
    //       accomodate the new key, the capacity is increased.
    //       The index of the new key is returned.
    //       This is not an optimal way to fill this structure, but it is convenient
    //       for serialized loading.
    //----------------------------------------------------------------------------------
    DWORD AnimationKeyArray::AddKey()
    {
        assert( m_dwSize <= m_dwCapacity );
        if( m_dwSize == m_dwCapacity )
        {
            DWORD dwNewSize = m_dwCapacity + ( m_dwCapacity >> 1 );
            dwNewSize = max( 4, dwNewSize );
            Resize( dwNewSize );
        }
        DWORD dwResult = m_dwSize;
        ++m_dwSize;
        return dwResult;
    }


    //----------------------------------------------------------------------------------
    // Name: SetKeyValue()
    // Desc: Changes a key's value vector to a new value.
    //----------------------------------------------------------------------------------
    VOID AnimationKeyArray::SetKeyValue( DWORD dwKeyIndex, XMVECTOR vValue )
    {
        FLOAT* pValueData = GetKeyValue( dwKeyIndex );
        switch( m_dwValueDimension )
        {
        case 3:
            XMStoreFloat3( (XMFLOAT3*)pValueData, vValue );
            return;
        case 4:
            XMStoreFloat4( (XMFLOAT4*)pValueData, vValue );
            return;
        case 2:
            XMStoreFloat2( (XMFLOAT2*)pValueData, vValue );
            return;
        }
    }

    struct KeyTempStruct
    {
        FLOAT       fTime;
        DWORD       dwOriginalIndex;
    };


    //----------------------------------------------------------------------------------
    // Name: KeyTimeSortFunction
    // Desc: Helper function for the SortKeys() method, used with a STL sort.
    //----------------------------------------------------------------------------------
    BOOL KeyTimeSortFunction( const KeyTempStruct& A, const KeyTempStruct& B )
    {
        return A.fTime <= B.fTime;
    }


    //----------------------------------------------------------------------------------
    // Name: SortKeys()
    // Desc: Sorts the keys by time, in ascending order.  This should not be used
    //       unless the keys were loaded in a serial fashion, and sort order is not
    //       guaranteed.  If this class is initialized using PointToBuffer(), and the
    //       data is already sorted, you do not need to sort again.
    //----------------------------------------------------------------------------------
    VOID AnimationKeyArray::SortKeys()
    {
        if( m_dwSize == 0 )
            return;
        typedef std::vector<KeyTempStruct> KeyTempList;
        KeyTempList SortingList;
        SortingList.reserve( m_dwSize );
        for( DWORD i = 0; i < m_dwSize; i++ )
        {
            KeyTempStruct ts;
            ts.fTime = GetKeyTime( i );
            ts.dwOriginalIndex = i;
            SortingList.push_back( ts );
        }
        std::sort( SortingList.begin(), SortingList.end(), KeyTimeSortFunction );

        DWORD dwKeySizeBytes = ( m_dwValueDimension + 1 ) * sizeof( FLOAT );
        DWORD dwTotalSizeBytes = dwKeySizeBytes * m_dwSize;
        BYTE* pSortedKeys = new BYTE[ dwTotalSizeBytes ];
        BYTE* pCurrentSortedKey = pSortedKeys;
        for( DWORD i = 0; i < SortingList.size(); i++ )
        {
            KeyTempStruct& ts = SortingList[i];
            BYTE* pOriginalKey = (BYTE*)m_pFloatData + dwKeySizeBytes * ts.dwOriginalIndex;
            XMemCpy( pCurrentSortedKey, pOriginalKey, dwKeySizeBytes );
            pCurrentSortedKey += dwKeySizeBytes;
        }
        XMemCpy( m_pFloatData, pSortedKeys, dwTotalSizeBytes );
        delete[] pSortedKeys;
    }


    //----------------------------------------------------------------------------------
    // Name: FindKey()
    // Desc: Finds the key corresponding to the given time, using a starting hint and
    //       a preferred search direction.  This method is optimized to avoid float
    //       branches, by using a "time code" for each key and the search parameter.
    //       The time code is nothing more than a non-negative float treated as a DWORD.
    //       Non-negative floats treated as ints can be compared and sorted like ints.
    //----------------------------------------------------------------------------------
    DWORD AnimationKeyArray::FindKey( FLOAT fTime, DWORD dwKeyIndexHint, BOOL bPlayForward ) const
    {
        // Input checking.
        assert( fTime >= 0.0f );
        assert( m_dwSize > 0 );
        assert( dwKeyIndexHint < m_dwSize );

        // Timecode is an integer re-expression of the float time, used to compare times 
        // faster. Branching and comparing on float values is expensive on Xbox 360.
        DWORD dwTimeCode = *(DWORD*)&fTime;

        // Check if the time is less than the first key.
        if( dwTimeCode < GetKeyTimeCode( 0 ) )
            return 0;

        // Quick search a few keys, in a linear fashion with wraparound.
        INT iIncrement = -1 + ( (INT)( bPlayForward & 1 ) << 1 );
        for( INT i = 0; i < KEY_SEARCH_DISTANCE; i++ )
        {
            DWORD dwIndex = (DWORD)( (INT)( dwKeyIndexHint + m_dwSize ) + ( iIncrement * i ) ) % m_dwSize;
            DWORD dwTimeCodeTest = GetKeyTimeCode( dwIndex );
            // Check if we're looking at the last key.
            if( dwIndex == ( m_dwSize - 1 ) )
            {
                // If the time code is after the last key, the last key is the right key.
                if( dwTimeCode >= dwTimeCodeTest )
                    return dwIndex;
            }
            else
            {
                // If the time code comes before the key we're looking at, go to the next
                // key.
                if( dwTimeCode < dwTimeCodeTest )
                    continue;
                // If the time code comes before the next key, then we are on the right key.
                DWORD dwTimeCodeTestNext = GetKeyTimeCode( dwIndex + 1 );
                if( dwTimeCode < dwTimeCodeTestNext )
                    return dwIndex;
            }
        }

        // We didn't find the right key in the quick search.
        // Perform a binary search.
        DWORD dwStartIndex = 0;
        DWORD dwEndIndex = m_dwSize - 1;
        while( dwEndIndex > dwStartIndex )
        {
            // Get the middle index in the range, biased upwards.
            DWORD dwTestIndex = ( dwStartIndex + dwEndIndex + 1 ) >> 1;
            DWORD dwTestTimeCode = GetKeyTimeCode( dwTestIndex );
            if( dwTestTimeCode < dwTimeCode )
                dwStartIndex = dwTestIndex;
            else if( dwTestTimeCode > dwTimeCode )
                dwEndIndex = dwTestIndex - 1;
            else
                return dwTestIndex;
        }
        return dwStartIndex;
    }


    //----------------------------------------------------------------------------------
    // Name: SampleVector()
    // Desc: Linearly interpolates between neighboring keys using a time parameter.
    //       The user of this method should store a DWORD key index hint, which will be
    //       updated each time a search is performed.  The hint reduces most searches
    //       to O(1), and when the hint fails, the performance of the search is
    //       O(log n).
    //       If the search time falls outside the key times, the result will be either
    //       the first key's value or the last key's value.
    //----------------------------------------------------------------------------------
    XMVECTOR AnimationKeyArray::SampleVector( FLOAT fTime, DWORD* pKeyIndexHint, BOOL bPlayForward ) const
    {
        // If we were given a hint, use it.
        DWORD dwKeyIndexHint = 0;
        if( pKeyIndexHint != NULL )
            dwKeyIndexHint = *pKeyIndexHint;

        // Find the key.
        DWORD dwKeyIndex = FindKey( fTime, dwKeyIndexHint, bPlayForward );

        // Update the hint so it can be used next time.
        if( pKeyIndexHint != NULL )
            *pKeyIndexHint = dwKeyIndex;

        // Check if the time is before the first key or after the last key.
        // In this case, we do not need to lerp.
        DWORD dwTimeCode = *(DWORD*)&fTime;
        if( ( dwKeyIndex == m_dwSize - 1 ) ||
            ( dwKeyIndex == 0 && dwTimeCode < GetKeyTimeCode( dwKeyIndex ) ) )
        {
            return GetKeyVector( dwKeyIndex );
        }

        // Extract the start and end times and values.
        FLOAT fStartTime = GetKeyTime( dwKeyIndex );
        XMVECTOR vStart = GetKeyVector( dwKeyIndex );
        FLOAT fEndTime = GetKeyTime( dwKeyIndex + 1 );
        XMVECTOR vEnd = GetKeyVector( dwKeyIndex + 1 );

        // Perform the lerp.
        FLOAT fParam = ( fTime - fStartTime ) / ( fEndTime - fStartTime );
        return XMVectorLerp( vStart, vEnd, fParam );
    }



    //----------------------------------------------------------------------------------
    // Name: SampleVectorLooping()
    // Desc: Linearly interpolates between neighboring keys using a time parameter.
    //       The user of this method should store a DWORD key index hint, which will be
    //       updated each time a search is performed.  The hint reduces most searches
    //       to O(1), and when the hint fails, the performance of the search is
    //       O(log n).
    //       If the search time falls outside the key times, the result will be either
    //       the first key's value or the last key's value.
    //----------------------------------------------------------------------------------
    XMVECTOR AnimationKeyArray::SampleVectorLooping( FLOAT fTime, FLOAT fDuration, DWORD* pKeyIndexHint, BOOL bPlayForward ) const
    {
        // If we were given a hint, use it.
        DWORD dwKeyIndexHint = 0;
        if( pKeyIndexHint != NULL )
            dwKeyIndexHint = *pKeyIndexHint;

        // Find the key.
        DWORD dwKeyIndex = FindKey( fTime, dwKeyIndexHint, bPlayForward );

        // Update the hint so it can be used next time.
        if( pKeyIndexHint != NULL )
            *pKeyIndexHint = dwKeyIndex;

        // Check if the time is before the first key or after the last key.
        // In this case, we do not need to lerp.
        DWORD dwTimeCode = *(DWORD*)&fTime;
        FLOAT fStartTime, fEndTime;
        XMVECTOR vStart, vEnd;

        if( dwKeyIndex == 0 && dwTimeCode < GetKeyTimeCode( dwKeyIndex ) )
        {
            fStartTime = GetKeyTime( m_dwSize - 1 ) - fDuration;
            vStart = GetKeyVector( m_dwSize - 1 );
            fEndTime = GetKeyTime( dwKeyIndex );
            vEnd = GetKeyVector( dwKeyIndex );
        }
        else if( dwKeyIndex == m_dwSize - 1 )
        {
            fStartTime = GetKeyTime( dwKeyIndex );
            vStart = GetKeyVector( dwKeyIndex );
            fEndTime = GetKeyTime( 0 ) + fDuration;
            vEnd = GetKeyVector( 0 );
        }
        else
        {
            // Extract the start and end times and values.
            fStartTime = GetKeyTime( dwKeyIndex );
            vStart = GetKeyVector( dwKeyIndex );
            fEndTime = GetKeyTime( dwKeyIndex + 1 );
            vEnd = GetKeyVector( dwKeyIndex + 1 );
        }

        // Perform the lerp.
        FLOAT fParam = ( fTime - fStartTime ) / ( fEndTime - fStartTime );
        return XMVectorLerp( vStart, vEnd, fParam );
    }

} // namespace ATG

```

`XenonDumper/libs/Atg/AtgAnimation.h`:

```h
//-----------------------------------------------------------------------------
// AtgAnimation.h
//
// Animation data structures for keyframed animation.
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef ATG_ANIMATION_H
#define ATG_ANIMATION_H

#include <assert.h>
#include "AtgResourceDatabase.h"

namespace ATG
{
    //----------------------------------------------------------------------------------
    // Name: class AnimationKeyArray
    // Desc: A data structure that holds an array of multidimensional animation keys.
    //       Each key consists of a non-negative float time and at least one float value.
    //       It is crucial that key times be non-negative, since this class is optimized
    //       to avoid float branches, since they cause a performance penalty on the
    //       Xbox 360 CPU.
    //       The class is also optimized to be initialized with a pre-sorted array of
    //       keys, using the PointToBuffer() method.
    //----------------------------------------------------------------------------------
    class AnimationKeyArray
    {
    public:
        // Constructor and destructor
        AnimationKeyArray( DWORD dwValueDimension );
        ~AnimationKeyArray();

        // Initialization
        VOID        Resize( DWORD dwNewCapacity );
        VOID        PointToBuffer( FLOAT* pBuffer, DWORD dwBufferSizeBytes, DWORD dwKeyCount, DWORD dwValueDimension );

        // Data access
        DWORD       GetKeyCount() const { return m_dwSize; }
        DWORD       GetCapacity() const { return m_dwCapacity; }
        FLOAT       GetKeyTime( DWORD dwKeyIndex ) const
        {
            assert( dwKeyIndex < m_dwSize );
            DWORD dwIndex = dwKeyIndex * ( m_dwValueDimension + 1 );
            return m_pFloatData[ dwIndex ];
        }
        FLOAT*      GetKeyValue( DWORD dwKeyIndex )
        {
            assert( dwKeyIndex < m_dwSize );
            DWORD dwIndex = dwKeyIndex * ( m_dwValueDimension + 1 ) + 1;
            return &m_pFloatData[ dwIndex ];
        }
        const FLOAT*    GetKeyValue( DWORD dwKeyIndex ) const
        {
            assert( dwKeyIndex < m_dwSize );
            DWORD dwIndex = dwKeyIndex * ( m_dwValueDimension + 1 ) + 1;
            return &m_pFloatData[ dwIndex ];
        }
        XMVECTOR    GetKeyVector( DWORD dwKeyIndex ) const
        {
            assert( m_dwValueDimension > 1 && m_dwValueDimension < 5 );
            const FLOAT* pFloatData = GetKeyValue( dwKeyIndex );
            switch( m_dwValueDimension )
            {
            case 3:
                return XMLoadFloat3( (const XMFLOAT3*)pFloatData );
            case 4:
                return XMLoadFloat4( (const XMFLOAT4*)pFloatData );
            case 2:
                return XMLoadFloat2( (const XMFLOAT2*)pFloatData );
            }
            return XMVectorZero();
        }
        FLOAT       GetKeyScalar( DWORD dwKeyIndex )
        {
            assert( m_dwValueDimension == 1 );
            FLOAT* pFloatData = GetKeyValue( dwKeyIndex );
            return *pFloatData;
        }

        // Data update functions
        // Note: Ideally, these should not be executed at runtime, since they are a
        //       slow way of updating this structure.
        DWORD       AddKey();
        VOID        SetKeyTime( DWORD dwKeyIndex, FLOAT fTime ) const
        {
            assert( dwKeyIndex < m_dwSize );
            assert( fTime >= 0.0f );
            DWORD dwIndex = dwKeyIndex * ( m_dwValueDimension + 1 );
            m_pFloatData[ dwIndex ] = fTime;
        }
        VOID        SetKeyValue( DWORD dwKeyIndex, XMVECTOR vValue );
        VOID        SortKeys();

        // Key search and sampling
        DWORD       FindKey( FLOAT fTime, DWORD dwKeyIndexHint, BOOL bPlayForward ) const;
        XMVECTOR    SampleVector( FLOAT fTime, DWORD* pKeyIndexHint, BOOL bPlayForward ) const;
        XMVECTOR    SampleVectorLooping( FLOAT fTime, FLOAT fDuration, DWORD* pKeyIndexHint, BOOL bPlayForward ) const;

    protected:
        DWORD       GetKeyTimeCode( DWORD dwKeyIndex ) const
        {
            assert( dwKeyIndex < m_dwSize );
            DWORD dwIndex = dwKeyIndex * ( m_dwValueDimension + 1 );
            return *(DWORD*)&m_pFloatData[ dwIndex ];            
        }
    protected:
        FLOAT*      m_pFloatData;
        DWORD       m_dwValueDimension;
        DWORD       m_dwCapacity;
        DWORD       m_dwSize;
    };

    
    //----------------------------------------------------------------------------------
    // Name: class AnimationTransformTrack
    // Desc: An animation track that contains a 3D position curve, a 4D quaternion
    //       orientation curve, and a 3D scaling curve, all stored as keyframed
    //       sequences.
    //----------------------------------------------------------------------------------
    class AnimationTransformTrack : public NamedTypedObject
    {
        DEFINE_TYPE_INFO();

    public:
        AnimationTransformTrack()
            : m_PositionKeys( 3 ),
              m_OrientationKeys( 4 ),
              m_ScaleKeys( 3 )
        {
        }

        AnimationKeyArray& GetPositionKeys() { return m_PositionKeys; }
        AnimationKeyArray& GetOrientationKeys() { return m_OrientationKeys; }
        AnimationKeyArray& GetScaleKeys() { return m_ScaleKeys; }

        XMVECTOR SamplePosition( FLOAT fTime, DWORD* pLastKeyIndex = NULL, BOOL bPlayingForward = TRUE ) const
        {
            if( m_PositionKeys.GetKeyCount() == 0 )
                return XMVectorZero();
            return m_PositionKeys.SampleVector( fTime, pLastKeyIndex, bPlayingForward );
        }
        XMVECTOR SampleOrientation( FLOAT fTime, DWORD* pLastKeyIndex = NULL, BOOL bPlayingForward = TRUE ) const
        {
            if( m_OrientationKeys.GetKeyCount() == 0 )
                return XMQuaternionIdentity();
            return m_OrientationKeys.SampleVector( fTime, pLastKeyIndex, bPlayingForward );
        }
        XMVECTOR SampleScale( FLOAT fTime, DWORD* pLastKeyIndex = NULL, BOOL bPlayingForward = TRUE ) const
        {
            if( m_ScaleKeys.GetKeyCount() == 0 )
                return XMVectorSet( 1, 1, 1, 1 );
            return m_ScaleKeys.SampleVector( fTime, pLastKeyIndex, bPlayingForward );
        }

        XMVECTOR SamplePositionLooping( FLOAT fTime, FLOAT fDuration, DWORD* pLastKeyIndex = NULL, BOOL bPlayingForward = TRUE ) const
        {
            if( m_PositionKeys.GetKeyCount() == 0 )
                return XMVectorZero();
            return m_PositionKeys.SampleVectorLooping( fTime, fDuration, pLastKeyIndex, bPlayingForward );
        }
        XMVECTOR SampleOrientationLooping( FLOAT fTime, FLOAT fDuration, DWORD* pLastKeyIndex = NULL, BOOL bPlayingForward = TRUE ) const
        {
            if( m_OrientationKeys.GetKeyCount() == 0 )
                return XMQuaternionIdentity();
            return m_OrientationKeys.SampleVectorLooping( fTime, fDuration, pLastKeyIndex, bPlayingForward );
        }
        XMVECTOR SampleScaleLooping( FLOAT fTime, FLOAT fDuration, DWORD* pLastKeyIndex = NULL, BOOL bPlayingForward = TRUE ) const
        {
            if( m_ScaleKeys.GetKeyCount() == 0 )
                return XMVectorSet( 1, 1, 1, 1 );
            return m_ScaleKeys.SampleVectorLooping( fTime, fDuration, pLastKeyIndex, bPlayingForward );
        }

    protected:
        AnimationKeyArray   m_PositionKeys;
        AnimationKeyArray   m_OrientationKeys;
        AnimationKeyArray   m_ScaleKeys;
    };

    typedef std::vector<AnimationTransformTrack*> AnimationTransformTrackVector;


    //----------------------------------------------------------------------------------
    // Name: class Animation
    // Desc: A graphics resource that contains a list of animation tracks, as well as
    //       a duration for the animation.
    //----------------------------------------------------------------------------------
    class Animation : public Resource
    {
        DEFINE_TYPE_INFO();

    public:
        Animation()
            : m_fDuration( 0.0f )
        {
        }
        ~Animation();

        VOID SetDuration( FLOAT fDuration ) { m_fDuration = fDuration; }
        FLOAT GetDuration() const { return m_fDuration; }

        VOID AddAnimationTrack( AnimationTransformTrack* pTrack ) { m_Tracks.push_back( pTrack ); }
        DWORD GetAnimationTrackCount() const { return (DWORD)m_Tracks.size(); }
        AnimationTransformTrack* GetAnimationTrack( DWORD dwIndex ) { return m_Tracks[dwIndex]; }

    protected:
        AnimationTransformTrackVector   m_Tracks;
        FLOAT                           m_fDuration;
    };

} // namespace ATG

#endif // ATG_ANIMATION_H
```

`XenonDumper/libs/Atg/AtgApobase.h`:

```h
//--------------------------------------------------------------------------------------
// SampleAPOBase.h
//
// XNA Developer Connection
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#pragma once
#include <crtdbg.h>
#include <xapobase.h>

namespace ATG
{
//--------------------------------------------------------------------------------------
// CSampleXAPOBase
//
// Template class that provides a default class factory implementation and typesafe
// parameter passing for our sample xAPO classes
//--------------------------------------------------------------------------------------
template<typename APOClass, typename ParameterClass>
class CSampleXAPOBase
    : public CXAPOParametersBase
{
public:
    static HRESULT CreateInstance( void* pInitData, UINT32 cbInitData, APOClass** ppAPO );

    //
    // IXAPO
    //
    STDMETHOD(LockForProcess) (
        UINT32 InputLockedParameterCount,
        const XAPO_LOCKFORPROCESS_BUFFER_PARAMETERS *pInputLockedParameters,
        UINT32 OutputLockedParameterCount,
        const XAPO_LOCKFORPROCESS_BUFFER_PARAMETERS *pOutputLockedParameters );

    STDMETHOD_(void, Process) (
        UINT32 InputProcessParameterCount,
        const XAPO_PROCESS_BUFFER_PARAMETERS *pInputProcessParameters,
        UINT32 OutputProcessParameterCount,
        XAPO_PROCESS_BUFFER_PARAMETERS *pOutputProcessParameters,
        BOOL IsEnabled);

protected:
    CSampleXAPOBase();
    ~CSampleXAPOBase(void);

    //
    // Accessors
    //
    const WAVEFORMATEX& WaveFormat(){ return m_wfx; }

    //
    // Overrides
    //
    void OnSetParameters (const void* pParams, UINT32 cbParams)
    {
        _ASSERT( cbParams == sizeof( ParameterClass ) );
        cbParams;
        OnSetParameters( *(ParameterClass*)pParams );
    }

    //
    // Overridables
    //

    // Process a frame of audio. Marked pure virtual because without
    // this function there's not much point in having an xAPO.
    virtual void DoProcess(
        const ParameterClass& params,
        FLOAT32* __restrict pData,
        UINT32 cFrames,
        UINT32 cChannels,
        BOOL bIsEnabled  ) = 0;

    // Do any necessary calculations in response to parameter changes.
    // NOT marked pure virtual because there may not be a reason to
    // do additional calculations when parameters are set.
    virtual void OnSetParameters( const ParameterClass& ){}

private:
    // Ring buffer needed by CXAPOParametersBase
    ParameterClass  m_parameters[3];

    // Format of the audio we're processing
    WAVEFORMATEX    m_wfx;

    // Registration properties defining this xAPO class.
    static XAPO_REGISTRATION_PROPERTIES m_regProps;


};

//--------------------------------------------------------------------------------------
// CSampleAPOBase::m_regProps
//
// Registration properties for the sample xAPO classes.
//--------------------------------------------------------------------------------------
template<typename APOClass, typename ParameterClass>
__declspec(selectany) XAPO_REGISTRATION_PROPERTIES CSampleXAPOBase<APOClass, ParameterClass>::m_regProps = {
            __uuidof(APOClass),
            L"SampleAPO",
            L"Copyright (C)2008 Microsoft Corporation",
            1,
            0,
            XAPO_FLAG_INPLACE_REQUIRED
            | XAPO_FLAG_CHANNELS_MUST_MATCH
            | XAPO_FLAG_FRAMERATE_MUST_MATCH
            | XAPO_FLAG_BITSPERSAMPLE_MUST_MATCH
            | XAPO_FLAG_BUFFERCOUNT_MUST_MATCH
            | XAPO_FLAG_INPLACE_SUPPORTED,
            1, 1, 1, 1 };

//--------------------------------------------------------------------------------------
// Name: CSampleXAPOBase::CreateInstance
// Desc: Class factory for sample xAPO objects
//--------------------------------------------------------------------------------------
template<typename APOClass, typename ParameterClass>
HRESULT CSampleXAPOBase<APOClass, ParameterClass>::CreateInstance( void* pInitData, UINT32 cbInitData, APOClass** ppAPO )
{
    _ASSERT( ppAPO );
    HRESULT hr = S_OK;

    *ppAPO = new APOClass;

    hr = (*ppAPO)->Initialize( pInitData, cbInitData );
    return hr;
}


//--------------------------------------------------------------------------------------
// Name: CSampleXAPOBase::CSampleXAPOBase
// Desc: Constructor
//--------------------------------------------------------------------------------------
template<typename APOClass, typename ParameterClass>
CSampleXAPOBase<APOClass, ParameterClass>::CSampleXAPOBase( )
: CXAPOParametersBase( &m_regProps, (BYTE*)m_parameters, sizeof( ParameterClass ), FALSE )
{
#ifdef _XBOX_VER
    XMemSet( (BYTE*)m_parameters, 0, sizeof( m_parameters ) );
#else
    ZeroMemory( m_parameters, sizeof( m_parameters ) );
#endif
}

//--------------------------------------------------------------------------------------
// Name: CSampleXAPOBase::~CSampleXAPOBase
// Desc: Destructor
//--------------------------------------------------------------------------------------
template<typename APOClass, typename ParameterClass>
CSampleXAPOBase<APOClass, ParameterClass>::~CSampleXAPOBase()
{

}

//--------------------------------------------------------------------------------------
// Name: CSampleXAPOBase::LockForProcess
// Desc: Overridden so that we can remember the wave format of the signal
//       we're supposed to be processing
//--------------------------------------------------------------------------------------
template<typename APOClass, typename ParameterClass>
HRESULT CSampleXAPOBase<APOClass, ParameterClass>::LockForProcess(
    UINT32 InputLockedParameterCount,
    const XAPO_LOCKFORPROCESS_BUFFER_PARAMETERS *pInputLockedParameters,
    UINT32 OutputLockedParameterCount,
    const XAPO_LOCKFORPROCESS_BUFFER_PARAMETERS *pOutputLockedParameters )
{
    HRESULT hr = CXAPOParametersBase::LockForProcess(
        InputLockedParameterCount,
        pInputLockedParameters,
        OutputLockedParameterCount,
        pOutputLockedParameters );

    if( SUCCEEDED( hr ) )
    {
        // Copy the wave format. Note that we're using memcpy rather than XMemCpy
        // because XMemCpy is really only beneficial for larger blocks of memory.
        memcpy( &m_wfx, pInputLockedParameters[0].pFormat, sizeof( WAVEFORMATEX ) );
    }
    return hr;
}

//--------------------------------------------------------------------------------------
// Name: CSampleXAPOBase::Process
// Desc: Overridden to call this class's typesafe version
//--------------------------------------------------------------------------------------
template<typename APOClass, typename ParameterClass>
void CSampleXAPOBase<APOClass, ParameterClass>::Process(
    UINT32 InputProcessParameterCount,
    const XAPO_PROCESS_BUFFER_PARAMETERS *pInputProcessParameters,
    UINT32 OutputProcessParameterCount,
    XAPO_PROCESS_BUFFER_PARAMETERS *pOutputProcessParameters,
    BOOL IsEnabled)
{
    _ASSERT( IsLocked() );
    _ASSERT( InputProcessParameterCount == 1 );
    _ASSERT( OutputProcessParameterCount == 1 );
    _ASSERT( pInputProcessParameters[0].pBuffer == pOutputProcessParameters[0].pBuffer );

    UNREFERENCED_PARAMETER( OutputProcessParameterCount );
    UNREFERENCED_PARAMETER( InputProcessParameterCount );
    UNREFERENCED_PARAMETER( pOutputProcessParameters );
    UNREFERENCED_PARAMETER( IsEnabled );

    ParameterClass* pParams;
    pParams = (ParameterClass*)BeginProcess();
    if ( pInputProcessParameters[0].BufferFlags == XAPO_BUFFER_SILENT )
    {
        memset( pInputProcessParameters[0].pBuffer, 0,
                pInputProcessParameters[0].ValidFrameCount * m_wfx.nChannels * sizeof(FLOAT32) );

        DoProcess(
            *pParams,
            (FLOAT32* __restrict)pInputProcessParameters[0].pBuffer,
            pInputProcessParameters[0].ValidFrameCount,
            m_wfx.nChannels,
            IsEnabled );
    }
    else if( pInputProcessParameters[0].BufferFlags == XAPO_BUFFER_VALID )
    {
        DoProcess(
            *pParams,
            (FLOAT32* __restrict)pInputProcessParameters[0].pBuffer,
            pInputProcessParameters[0].ValidFrameCount,
            m_wfx.nChannels,
            IsEnabled );
    }
    EndProcess();

}

} // namespace ATG
```

`XenonDumper/libs/Atg/AtgApp.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// AtgApp.cpp
//
// Application class for samples
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#include "stdafx.h"
#include "AtgApp.h"
#include "AtgUtil.h"

// Ignore warning about "unused" pD3D variable
#pragma warning( disable: 4189 )

namespace ATG
{

//--------------------------------------------------------------------------------------
// Globals
//--------------------------------------------------------------------------------------

// Global access to the main D3D device
D3DDevice* g_pd3dDevice = NULL;

// Private access to the main D3D device
D3DDevice* Application::m_pd3dDevice = NULL;

// The device-creation presentation params with reasonable defaults
D3DPRESENT_PARAMETERS Application::m_d3dpp =
{
    640,                // BackBufferWidth;
    480,                // BackBufferHeight;
    D3DFMT_A8R8G8B8,    // BackBufferFormat;
    1,                  // BackBufferCount;
    D3DMULTISAMPLE_NONE,// MultiSampleType;
    0,                  // MultiSampleQuality;
    D3DSWAPEFFECT_DISCARD, // SwapEffect;
    NULL,               // hDeviceWindow;
    FALSE,              // Windowed;
    TRUE,               // EnableAutoDepthStencil;
    D3DFMT_D24S8,       // AutoDepthStencilFormat;
    0,                  // Flags;
    0,                  // FullScreen_RefreshRateInHz;
    D3DPRESENT_INTERVAL_IMMEDIATE, // FullScreen_PresentationInterval;
};

// Extra flags to use at Direct3D device creation time
DWORD Application::m_dwDeviceCreationFlags = 0;

//--------------------------------------------------------------------------------------
// Name: Run()
// Desc: Creates the D3D device, calls Initialize() and enters an infinite loop
//       calling Update() and Render()
//--------------------------------------------------------------------------------------
VOID Application::Run()
{
    HRESULT hr;

    // Create Direct3D
    LPDIRECT3D9 pD3D = Direct3DCreate9( D3D_SDK_VERSION );

    // Create the D3D device
    if( FAILED( hr = pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL,
                                         m_dwDeviceCreationFlags,
                                         &m_d3dpp, ( ::D3DDevice** )&m_pd3dDevice ) ) )
    {
        ATG_PrintError( "Could not create D3D device!\n" );
        DebugBreak();
    }

    pD3D->Release();

    // Allow global access to the device
    g_pd3dDevice = m_pd3dDevice;

    // Initialize the app's device-dependent objects
    if( FAILED( hr = Initialize() ) )
    {
        ATG_PrintError( "Call to Initialize() failed!\n" );
        DebugBreak();
    }

    // Run the game loop
    for(; ; )
    {
        // Update the scene
        Update();

        // Render the scene
        Render();
    }
}

} // namespace ATG

```

`XenonDumper/libs/Atg/AtgApp.h`:

```h
//--------------------------------------------------------------------------------------
// AtgApp.h
//
// Application class for samples
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#pragma once
#ifndef ATGAPP_H
#define ATGAPP_H

// Use the overloaded D3DDevice class
#include "AtgDevice.h"


// Disable warning C4324: structure padded due to __declspec(align())
// Warning C4324 comes up often in samples derived from the Application class, since 
// they use XMVECTOR, XMMATRIX, and other member data types that must be aligned.
#pragma warning( disable:4324 )


namespace ATG
{

// Global access to the main D3D device
extern D3DDevice* g_pd3dDevice;


//--------------------------------------------------------------------------------------
// Error codes
//--------------------------------------------------------------------------------------
#define ATGAPPERR_MEDIANOTFOUND       0x82000003


//--------------------------------------------------------------------------------------
// A base class for creating sample Xbox applications. To create a simple
// Xbox application, simply derive this class and override the following
// functions:
//    Initialize() - To initialize the device-dependant objects
//    Update()     - To animate the scene
//    Render()     - To render the scene
//--------------------------------------------------------------------------------------
class Application
{
public:
    // Main objects used for creating and rendering the 3D scene
    static D3DPRESENT_PARAMETERS m_d3dpp;
    static D3DDevice* m_pd3dDevice;
    static DWORD m_dwDeviceCreationFlags;

    // Overridable functions
    virtual HRESULT Initialize() = 0;
    virtual HRESULT Update() = 0;
    virtual HRESULT Render() = 0;

    // Function to create and run the application
    VOID            Run();
};

} // namespace ATG

#endif // ATGAPP_H

```

`XenonDumper/libs/Atg/AtgAudio.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// AtgAudio.cpp
//
// Simple WAV file reader and other audio utilities.
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------

#include "stdafx.h"
#include "AtgAudio.h"
#include "AtgUtil.h"

namespace ATG
{



//--------------------------------------------------------------------------------------
// RIFF chunk type that contains loop point information
//--------------------------------------------------------------------------------------
struct WAVESAMPLE
{
    DWORD dwSize;
    WORD UnityNote;
    SHORT FineTune;
    LONG Gain;
    DWORD dwOptions;
    DWORD dwSampleLoops;
};


//--------------------------------------------------------------------------------------
// Loop point (contained in WSMP chunk)
//--------------------------------------------------------------------------------------
struct WAVESAMPLE_LOOP
{
    DWORD dwSize;
    DWORD dwLoopType;
    DWORD dwLoopStart;
    DWORD dwLoopLength;
};


//--------------------------------------------------------------------------------------
// RIFF chunk that may contain loop point information
//--------------------------------------------------------------------------------------
struct SAMPLER
{
    DWORD dwManufacturer;
    DWORD dwProduct;
    DWORD dwSamplePeriod;
    DWORD dwMIDIUnityNote;
    DWORD dwMIDIPitchFraction;
    DWORD dwSMPTEFormat;
    DWORD dwSMPTEOffset;
    DWORD dwNumSampleLoops;
    DWORD dwSamplerData;
};


//--------------------------------------------------------------------------------------
// Loop point contained in SMPL chunk
//--------------------------------------------------------------------------------------
struct SAMPLER_LOOP
{
    DWORD dwCuePointID;
    DWORD dwType;
    DWORD dwStart;
    DWORD dwEnd;
    DWORD dwFraction;
    DWORD dwPlayCount;
};


//--------------------------------------------------------------------------------------
// Name: RiffChunk()
// Desc: Constructor
//--------------------------------------------------------------------------------------
RiffChunk::RiffChunk()
{
    // Initialize defaults
    m_fccChunkId = 0;
    m_pParentChunk = NULL;
    m_hFile = INVALID_HANDLE_VALUE;
    m_dwDataOffset = 0;
    m_dwDataSize = 0;
    m_dwFlags = 0;
}


//--------------------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initializes the Riff chunk for use
//--------------------------------------------------------------------------------------
VOID RiffChunk::Initialize( FOURCC fccChunkId, const RiffChunk* pParentChunk,
                            HANDLE hFile )
{
    m_fccChunkId = fccChunkId;
    m_pParentChunk = pParentChunk;
    m_hFile = hFile;
}


//--------------------------------------------------------------------------------------
// Name: Open()
// Desc: Opens an existing chunk
//--------------------------------------------------------------------------------------
HRESULT RiffChunk::Open()
{
    LONG lOffset = 0;

    // Seek to the first byte of the parent chunk's data section
    if( m_pParentChunk )
    {
        lOffset = m_pParentChunk->m_dwDataOffset;

        // Special case the RIFF chunk
        if( ATG_FOURCC_RIFF == m_pParentChunk->m_fccChunkId )
            lOffset += sizeof( FOURCC );
    }

    // Read each child chunk header until we find the one we're looking for
    for(; ; )
    {
        if( INVALID_SET_FILE_POINTER == SetFilePointer( m_hFile, lOffset, NULL, FILE_BEGIN ) )
            return HRESULT_FROM_WIN32( GetLastError() );

        RIFFHEADER rhRiffHeader;
        DWORD dwRead;
        if( 0 == ReadFile( m_hFile, &rhRiffHeader, sizeof( rhRiffHeader ), &dwRead, NULL ) )
            return HRESULT_FROM_WIN32( GetLastError() );
        rhRiffHeader.dwDataSize = __loadwordbytereverse( 0, &rhRiffHeader.dwDataSize );

        // Hit EOF without finding it
        if( 0 == dwRead )
            return E_FAIL;

        // Check if we found the one we're looking for
        if( m_fccChunkId == rhRiffHeader.fccChunkId )
        {
            // Save the chunk size and data offset
            m_dwDataOffset = lOffset + sizeof( rhRiffHeader );
            m_dwDataSize = rhRiffHeader.dwDataSize;

            // Success
            m_dwFlags |= RIFFCHUNK_FLAGS_VALID;

            return S_OK;
        }

        lOffset += sizeof( rhRiffHeader ) + rhRiffHeader.dwDataSize;
    }
}


//--------------------------------------------------------------------------------------
// Name: ReadData()
// Desc: Reads from the file
//--------------------------------------------------------------------------------------
HRESULT RiffChunk::ReadData( LONG lOffset, VOID* pData, DWORD dwDataSize, OVERLAPPED* pOL ) const
{
    HRESULT hr = S_OK;

    OVERLAPPED defaultOL = {0};
    OVERLAPPED* pOverlapped = pOL;
    if( !pOL )
    {
        pOverlapped = &defaultOL;
    }

    // Seek to the offset
    pOverlapped->Offset = m_dwDataOffset + lOffset;

    // Read from the file
    DWORD dwRead;
    if( SUCCEEDED( hr ) && 0 == ReadFile( m_hFile, pData, dwDataSize, &dwRead, pOverlapped ) )
        hr = HRESULT_FROM_WIN32( GetLastError() );

    if( SUCCEEDED( hr ) && !pOL )
    {
        // we're using the default overlapped structure, which means that even if the
        // read was async, we need to act like it was synchronous.
        if( !GetOverlappedResult( m_hFile, pOverlapped, &dwRead, TRUE ) )
            hr = HRESULT_FROM_WIN32( GetLastError() );
    }
    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: WaveFile()
// Desc: Constructor
//--------------------------------------------------------------------------------------
WaveFile::WaveFile()
{
    m_hFile = INVALID_HANDLE_VALUE;
}


//--------------------------------------------------------------------------------------
// Name: ~WaveFile()
// Desc: Denstructor
//--------------------------------------------------------------------------------------
WaveFile::~WaveFile()
{
    Close();
}


//--------------------------------------------------------------------------------------
// Name: Open()
// Desc: Initializes the object
//--------------------------------------------------------------------------------------
HRESULT WaveFile::Open( const CHAR* strFileName )
{
    // If we're already open, close
    Close();

    // Open the file
    m_hFile = CreateFile(
        strFileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL );

    if( INVALID_HANDLE_VALUE == m_hFile )
        return HRESULT_FROM_WIN32( GetLastError() );

    // Initialize the chunk objects
    m_RiffChunk.Initialize( ATG_FOURCC_RIFF, NULL, m_hFile );
    m_FormatChunk.Initialize( ATG_FOURCC_FORMAT, &m_RiffChunk, m_hFile );
    m_DataChunk.Initialize( ATG_FOURCC_DATA, &m_RiffChunk, m_hFile );
    m_WaveSampleChunk.Initialize( ATG_FOURCC_WSMP, &m_RiffChunk, m_hFile );
    m_SamplerChunk.Initialize( ATG_FOURCC_SMPL, &m_RiffChunk, m_hFile );
    m_DpdsChunk.Initialize( ATG_FOURCC_DPDS, &m_RiffChunk, m_hFile );
    m_SeekChunk.Initialize( ATG_FOURCC_SEEK, &m_RiffChunk, m_hFile );

    HRESULT hr = m_RiffChunk.Open();
    if( FAILED( hr ) )
        return hr;

    hr = m_FormatChunk.Open();
    if( FAILED( hr ) )
        return hr;

    hr = m_DataChunk.Open();
    if( FAILED( hr ) )
        return hr;

    // Wave Sample and Sampler chunks are not required
    m_WaveSampleChunk.Open();
    m_SamplerChunk.Open();

    // Dpds chunk is valid only for XWMA files
    m_DpdsChunk.Open();

    // Seek chunk is valid only for XMA files
    m_SeekChunk.Open();

    // Validate the file type
    FOURCC fccType;
    hr = m_RiffChunk.ReadData( 0, &fccType, sizeof( fccType ), NULL );
    if( FAILED( hr ) )
        return hr;

    if( ATG_FOURCC_WAVE != fccType && ATG_FOURCC_XWMA != fccType)
        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: GetFormat()
// Desc: Gets the wave file format.
//--------------------------------------------------------------------------------------
HRESULT WaveFile::GetFormat( WAVEFORMATEXTENSIBLE* pwfxFormat, XMA2WAVEFORMATEX* pXma2Format ) const
{
    assert( pwfxFormat );

    DWORD dwValidSize = m_FormatChunk.GetDataSize();

    // Must be at least as large as a WAVEFORMAT to be valid
    if( dwValidSize < sizeof( WAVEFORMAT ) )
        return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

    // Read the format chunk into the buffer
    HRESULT hr = m_FormatChunk.ReadData( 0, pwfxFormat, min( dwValidSize, sizeof( WAVEFORMATEXTENSIBLE ) ), NULL );
    if( FAILED( hr ) )
        return hr;

    // Endian conversion for WAVEFORMAT base structure
    pwfxFormat->Format.wFormatTag = __loadshortbytereverse( 0, &pwfxFormat->Format.wFormatTag );
    pwfxFormat->Format.nChannels = __loadshortbytereverse( 0, &pwfxFormat->Format.nChannels );
    pwfxFormat->Format.nSamplesPerSec = __loadwordbytereverse( 0, &pwfxFormat->Format.nSamplesPerSec );
    pwfxFormat->Format.nAvgBytesPerSec = __loadwordbytereverse( 0, &pwfxFormat->Format.nAvgBytesPerSec );
    pwfxFormat->Format.nBlockAlign = __loadshortbytereverse( 0, &pwfxFormat->Format.nBlockAlign );

    switch( pwfxFormat->Format.wFormatTag )
    {
        case WAVE_FORMAT_PCM:
        case WAVE_FORMAT_WMAUDIO3:
        case WAVE_FORMAT_WMAUDIO2:
            if( dwValidSize < sizeof( PCMWAVEFORMAT ) )
                return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

            pwfxFormat->Format.wBitsPerSample = __loadshortbytereverse( 0, &pwfxFormat->Format.wBitsPerSample );
            break;

        case WAVE_FORMAT_EXTENSIBLE:
            if( dwValidSize < sizeof( WAVEFORMATEXTENSIBLE ) )
                return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

            // Endianness conversion
            pwfxFormat->Format.wBitsPerSample = __loadshortbytereverse( 0, &pwfxFormat->Format.wBitsPerSample );
            pwfxFormat->Format.cbSize = __loadshortbytereverse( 0, &pwfxFormat->Format.cbSize );

            pwfxFormat->Samples.wReserved = __loadshortbytereverse( 0, &pwfxFormat->Samples.wReserved );
            pwfxFormat->dwChannelMask = __loadwordbytereverse( 0, &pwfxFormat->dwChannelMask );
            pwfxFormat->SubFormat.Data1 = __loadwordbytereverse( 0, &pwfxFormat->SubFormat.Data1 );
            pwfxFormat->SubFormat.Data2 = __loadshortbytereverse( 0, &pwfxFormat->SubFormat.Data2 );
            pwfxFormat->SubFormat.Data3 = __loadshortbytereverse( 0, &pwfxFormat->SubFormat.Data3 );
            // Data4 is a array of char, not needed to convert
            break;

        case WAVE_FORMAT_XMA2:
            if( dwValidSize != sizeof( XMA2WAVEFORMATEX ) )
                return HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

            // Need second structure to store the result
            if( !pXma2Format )
                return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );

            hr = m_FormatChunk.ReadData( 0, pXma2Format, sizeof( XMA2WAVEFORMATEX ), NULL );
            if( FAILED( hr ) )
                return hr;

            // Endian conversion
            {
                pwfxFormat->Format.wBitsPerSample = __loadshortbytereverse( 0, &pwfxFormat->Format.wBitsPerSample );
                pwfxFormat->Format.cbSize = __loadshortbytereverse( 0, &pwfxFormat->Format.cbSize );

                pXma2Format->wfx = pwfxFormat->Format;

                pXma2Format->NumStreams = __loadshortbytereverse( 0, &pXma2Format->NumStreams );
                pXma2Format->ChannelMask = __loadwordbytereverse( 0, &pXma2Format->ChannelMask );
                pXma2Format->SamplesEncoded = __loadwordbytereverse( 0, &pXma2Format->SamplesEncoded );
                pXma2Format->BytesPerBlock = __loadwordbytereverse( 0, &pXma2Format->BytesPerBlock );
                pXma2Format->PlayBegin = __loadwordbytereverse( 0, &pXma2Format->PlayBegin );
                pXma2Format->PlayLength = __loadwordbytereverse( 0, &pXma2Format->PlayLength );
                pXma2Format->LoopBegin = __loadwordbytereverse( 0, &pXma2Format->LoopBegin );
                pXma2Format->LoopLength = __loadwordbytereverse( 0, &pXma2Format->LoopLength );
                pXma2Format->BlockCount = __loadshortbytereverse( 0, &pXma2Format->BlockCount );
            }
            break;

        default:
            // Unsupported!
            return HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
    }

    // Zero out remaining bytes, in case enough bytes were not read
    if( dwValidSize < sizeof( WAVEFORMATEXTENSIBLE ) )
        ZeroMemory( ( BYTE* )pwfxFormat + dwValidSize, sizeof( WAVEFORMATEXTENSIBLE ) - dwValidSize );

    return S_OK;
}

//--------------------------------------------------------------------------------------
// Name: ReadSampleRaw()
// Desc: Reads data from the audio file. No endianness conversion is performed.
//--------------------------------------------------------------------------------------
HRESULT WaveFile::ReadSampleRaw( DWORD dwPosition, VOID* pBuffer,
                              DWORD dwBufferSize, DWORD* pdwRead ) const
{
    // Don't read past the end of the data chunk
    DWORD dwDuration;
    GetDuration( &dwDuration );

    if( dwPosition + dwBufferSize > dwDuration )
        dwBufferSize = dwDuration - dwPosition;

    HRESULT hr = S_OK;
    if( dwBufferSize )
        hr = m_DataChunk.ReadData( ( LONG )dwPosition, pBuffer, dwBufferSize, NULL );

    if( pdwRead )
        *pdwRead = dwBufferSize;

    return hr;
}


//--------------------------------------------------------------------------------------
// Name: ReadSample()
// Desc: Reads data from the audio file.
//--------------------------------------------------------------------------------------
HRESULT WaveFile::ReadSample( DWORD dwPosition, VOID* pBuffer,
                              DWORD dwBufferSize, DWORD* pdwRead ) const
{
    HRESULT hr = S_OK;
    hr = ReadSampleRaw(dwPosition, pBuffer, dwBufferSize, pdwRead);

    if (FAILED( hr ))
    {
        return hr;
    }

    // Check bit size for endianness conversion.
    WAVEFORMATEXTENSIBLE wfxFormat;
    GetFormat( &wfxFormat );

    //Endianness conversion
    switch( wfxFormat.Format.wFormatTag )
    {
        case WAVE_FORMAT_PCM:
            if( wfxFormat.Format.wBitsPerSample == 16 )
            {
                SHORT* pBufferShort = ( SHORT* )pBuffer;
                for( DWORD i = 0; i < dwBufferSize / sizeof( SHORT ); i++ )
                    pBufferShort[i] = __loadshortbytereverse( 0, &pBufferShort[i] );
            }
            break;

        case WAVE_FORMAT_EXTENSIBLE:
            if( wfxFormat.Format.wBitsPerSample == 16 )
            {
                SHORT* pBufferShort = ( SHORT* )pBuffer;
                for( DWORD i = 0; i < dwBufferSize / sizeof( SHORT ); i++ )
                    pBufferShort[i] = __loadshortbytereverse( 0, &pBufferShort[i] );
            }
            else if( wfxFormat.Format.wBitsPerSample == 32 )
            {
                DWORD* pBufferDWord = ( DWORD* )pBuffer;
                for( DWORD i = 0; i < dwBufferSize / sizeof( DWORD ); i++ )
                    pBufferDWord[i] = __loadwordbytereverse( 0, &pBufferDWord[i] );
            }
            // 24 doesn't need converted...
            break;
    }

    return hr;
}


//--------------------------------------------------------------------------------------
// Name: GetLoopRegion()
// Desc: Gets the loop region, in terms of samples
//--------------------------------------------------------------------------------------
HRESULT WaveFile::GetLoopRegion( DWORD* pdwStart, DWORD* pdwLength ) const
{
    assert( pdwStart != NULL );
    assert( pdwLength != NULL );
    HRESULT hr = S_OK;

    *pdwStart = 0;
    *pdwLength = 0;

    // First, look for a MIDI-style SMPL chunk, then for a DLS-style WSMP chunk.
    BOOL bGotLoopRegion = FALSE;
    if( !bGotLoopRegion && m_SamplerChunk.IsValid() )
    {
        // Read the SAMPLER struct from the chunk
        SAMPLER smpl;
        hr = m_SamplerChunk.ReadData( 0, &smpl, sizeof( SAMPLER ), NULL );
        if( FAILED( hr ) )
            return hr;

        //Endianness conversion
        LONG* pLong = ( LONG* )&smpl;
        for( INT i = 0; i < sizeof( SAMPLER ) / sizeof( LONG ); i++ )
            *pLong++ = __loadwordbytereverse( i, &smpl );


        // Check if the chunk contains any loop regions
        if( smpl.dwNumSampleLoops > 0 )
        {
            SAMPLER_LOOP smpl_loop;
            hr = m_SamplerChunk.ReadData( sizeof( SAMPLER ), &smpl_loop, sizeof( SAMPLER_LOOP ), NULL );
            if( FAILED( hr ) )
                return E_FAIL;

            //Endianness conversion
            pLong = ( LONG* )&smpl_loop;
            for( INT i = 0; i < sizeof( SAMPLER_LOOP ) / sizeof( LONG ); i++ )
                *pLong++ = __loadwordbytereverse( i, &smpl_loop );

            // Documentation on the SMPL chunk indicates that dwStart and
            // dwEnd are stored as byte-offsets, rather than sample counts,
            // but SoundForge stores sample counts, so we'll go with that.
            *pdwStart = smpl_loop.dwStart;
            *pdwLength = smpl_loop.dwEnd - smpl_loop.dwStart + 1;
            bGotLoopRegion = TRUE;
        }
    }

    if( !bGotLoopRegion && m_WaveSampleChunk.IsValid() )
    {
        // Read the WAVESAMPLE struct from the chunk
        WAVESAMPLE ws;
        hr = m_WaveSampleChunk.ReadData( 0, &ws, sizeof( WAVESAMPLE ), NULL );
        if( FAILED( hr ) )
            return hr;

        // Endianness conversion
        ws.dwSize = __loadwordbytereverse( 0, &ws.dwSize );
        ws.UnityNote = __loadshortbytereverse( 0, &ws.UnityNote );
        ws.FineTune = __loadshortbytereverse( 0, &ws.FineTune );
        ws.Gain = __loadwordbytereverse( 0, &ws.Gain );
        ws.dwOptions = __loadwordbytereverse( 0, &ws.dwOptions );
        ws.dwSampleLoops = __loadwordbytereverse( 0, &ws.dwSampleLoops );

        // Check if the chunk contains any loop regions
        if( ws.dwSampleLoops > 0 )
        {
            // Read the loop region
            WAVESAMPLE_LOOP wsl;
            hr = m_WaveSampleChunk.ReadData( ws.dwSize, &wsl, sizeof( WAVESAMPLE_LOOP ), NULL );
            if( FAILED( hr ) )
                return hr;

            //Endianness conversion
            LONG* l = ( LONG* )&wsl;
            for( INT i = 0; i < sizeof( WAVESAMPLE_LOOP ) / sizeof( LONG ); i++ )
                *l++ = __loadwordbytereverse( i, &wsl );

            // Fill output vars with the loop region
            *pdwStart = wsl.dwLoopStart;
            *pdwLength = wsl.dwLoopLength;
            bGotLoopRegion = TRUE;
        }
    }

    // Couldn't find either chunk, or they didn't contain loop points
    if( !bGotLoopRegion )
        return E_FAIL;

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: GetLoopRegionBytes()
// Desc: Gets the loop region, in terms of bytes
//--------------------------------------------------------------------------------------
HRESULT WaveFile::GetLoopRegionBytes( DWORD* pdwStart, DWORD* pdwLength ) const
{
    assert( pdwStart != NULL );
    assert( pdwLength != NULL );

    // If no loop region is explicitly specified, loop the entire file
    *pdwStart = 0;
    GetDuration( pdwLength );

    // We'll need the wave format to convert from samples to bytes
    WAVEFORMATEXTENSIBLE wfx;
    if( FAILED( GetFormat( &wfx ) ) )
        return E_FAIL;

    // See if the file contains an embedded loop region
    DWORD dwLoopStartSamples;
    DWORD dwLoopLengthSamples;
    if( FAILED( GetLoopRegion( &dwLoopStartSamples, &dwLoopLengthSamples ) ) )
        return S_FALSE;

    // For PCM, multiply by bytes per sample
    DWORD cbBytesPerSample = wfx.Format.nChannels * wfx.Format.wBitsPerSample / 8;
    *pdwStart = dwLoopStartSamples * cbBytesPerSample;
    *pdwLength = dwLoopLengthSamples * cbBytesPerSample;

    return S_OK;
}

//--------------------------------------------------------------------------------------
// Name: GetPacketCumulativeBytesSize()
// Desc: Gets the packet count and the total byte size of the 'dpds' chunk.
//--------------------------------------------------------------------------------------
HRESULT WaveFile::GetPacketCumulativeBytesSize( DWORD* pdwPacketCount, DWORD* pdwBufferSize )
{
    assert( m_DpdsChunk.IsValid() );

    if (!m_DpdsChunk.IsValid())
        return E_HANDLE;

    WAVEFORMATEXTENSIBLE wfxFormat;
    GetFormat( &wfxFormat );
    
    // Packet count: length of the 'data' chunk divided by number of bytes per packet
    *pdwPacketCount = Duration() / wfxFormat.Format.nBlockAlign;

    *pdwBufferSize = m_DpdsChunk.GetDataSize();

    return S_OK;
}

//--------------------------------------------------------------------------------------
// Name: GetPacketCumulativeBytes()
// Desc: Gets the dpds structure data.
//--------------------------------------------------------------------------------------
HRESULT WaveFile::GetPacketCumulativeBytes( DWORD* pdwData )
{
    assert( m_DpdsChunk.IsValid() );
    assert( pdwData != NULL );

    HRESULT hr = S_OK;

    if (!m_DpdsChunk.IsValid())
        return E_HANDLE;

    DWORD dwPacketCount;
    DWORD dwBufferSize;

    hr = GetPacketCumulativeBytesSize( &dwPacketCount, &dwBufferSize );
    if( FAILED( hr ) )
        return hr;

    hr = m_DpdsChunk.ReadData( 0, pdwData, dwBufferSize, NULL );
    if( FAILED( hr ) )
        return hr;

    // Endianness conversion
    #if defined(_XBOX)
        for (DWORD dw=0; dw<dwPacketCount; dw++) {
            pdwData[dw] = _byteswap_ulong(pdwData[dw]);
        }
    #endif

    return S_OK;
}

//--------------------------------------------------------------------------------------
// Name: GetSeekTableSize()
// Desc: Gets the total byte size of the 'seek' chunk.
//--------------------------------------------------------------------------------------
HRESULT WaveFile::GetSeekTableSize( DWORD* pdwBufferSize )
{
    assert( m_SeekChunk.IsValid() );

    if ( !m_SeekChunk.IsValid() )
        return E_HANDLE;

    *pdwBufferSize = m_SeekChunk.GetDataSize();

    return S_OK;
}

//--------------------------------------------------------------------------------------
// Name: GetSeekTable()
// Desc: Gets the seek table.
//--------------------------------------------------------------------------------------
HRESULT WaveFile::GetSeekTable( DWORD* pdwData )
{
    assert( m_SeekChunk.IsValid() );
    assert( pdwData != NULL );

    HRESULT hr = S_OK;

    if ( !m_SeekChunk.IsValid() )
        return E_HANDLE;

    DWORD dwBufferSize;

    hr = GetSeekTableSize( &dwBufferSize );
    if( FAILED( hr ) )
        return hr;

    hr = m_SeekChunk.ReadData( 0, pdwData, dwBufferSize, NULL );
    if( FAILED( hr ) )
        return hr;

    return S_OK;
}

//--------------------------------------------------------------------------------------
// Name: Close()
// Desc: Closes the object
//--------------------------------------------------------------------------------------
VOID WaveFile::Close()
{
    if( m_hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( m_hFile );
        m_hFile = INVALID_HANDLE_VALUE;
    }
}


} // namespace ATG

```

`XenonDumper/libs/Atg/AtgAudio.h`:

```h
//--------------------------------------------------------------------------------------
// AtgAudio.h
//
// Simple WAV file reader and other audio utilities.
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------

#pragma once
#ifndef ATGAUDIO_H
#define ATGAUDIO_H

#include <audiodefs.h>
#include <xma2defs.h>

namespace ATG
{
//--------------------------------------------------------------------------------------
// FourCC definitions
//--------------------------------------------------------------------------------------
const DWORD ATG_FOURCC_RIFF = 'RIFF';
const DWORD ATG_FOURCC_WAVE = 'WAVE';
const DWORD ATG_FOURCC_XWMA = 'XWMA';
const DWORD ATG_FOURCC_DPDS = 'dpds';
const DWORD ATG_FOURCC_SEEK = 'seek';
const DWORD ATG_FOURCC_FORMAT = 'fmt ';
const DWORD ATG_FOURCC_DATA = 'data';
const DWORD ATG_FOURCC_WSMP = 'wsmp';
const DWORD ATG_FOURCC_SMPL = 'lsmp';



//--------------------------------------------------------------------------------------
// Misc type definitions
//--------------------------------------------------------------------------------------
typedef DWORD FOURCC, *PFOURCC, *LPFOURCC;


//--------------------------------------------------------------------------------------
// For parsing WAV files
//--------------------------------------------------------------------------------------
struct RIFFHEADER
{
    FOURCC fccChunkId;
    DWORD dwDataSize;
};

#define RIFFCHUNK_FLAGS_VALID   0x00000001


//--------------------------------------------------------------------------------------
// Name: class RiffChunk
// Desc: RIFF chunk utility class
//--------------------------------------------------------------------------------------
class RiffChunk
{
    FOURCC m_fccChunkId;       // Chunk identifier
    const RiffChunk* m_pParentChunk;     // Parent chunk
    HANDLE m_hFile;
    DWORD m_dwDataOffset;     // Chunk data offset
    DWORD m_dwDataSize;       // Chunk data size
    DWORD m_dwFlags;          // Chunk flags

public:
            RiffChunk();

    // Initialization
    VOID    Initialize( FOURCC fccChunkId, const RiffChunk* pParentChunk,
                        HANDLE hFile );
    HRESULT Open();
    BOOL    IsValid() const
    {
        return !!( m_dwFlags & RIFFCHUNK_FLAGS_VALID );
    }

    // Data
    HRESULT ReadData( LONG lOffset, VOID* pData, DWORD dwDataSize, OVERLAPPED* pOL ) const;

    // Chunk information
    FOURCC  GetChunkId() const
    {
        return m_fccChunkId;
    }
    DWORD   GetDataSize() const
    {
        return m_dwDataSize;
    }

private:
    // prevent copying so that we don't have to duplicate file handles
            RiffChunk( const RiffChunk& );
    RiffChunk& operator =( const RiffChunk& );
};

//--------------------------------------------------------------------------------------
// Name: class WaveFile
// Desc: Wave file utility class
//--------------------------------------------------------------------------------------
class WaveFile
{
    HANDLE m_hFile;            // File handle
    RiffChunk m_RiffChunk;        // RIFF chunk
    RiffChunk m_FormatChunk;      // Format chunk
    RiffChunk m_DataChunk;        // Data chunk
    RiffChunk m_WaveSampleChunk;  // Wave Sample chunk
    RiffChunk m_SamplerChunk;     // Sampler chunk
    RiffChunk m_DpdsChunk;        // Packet cumulative bytes chunk (XWMA only)
    RiffChunk m_SeekChunk;        // Seek chunk (XMA only)

public:
            WaveFile();
            ~WaveFile();

    // Initialization
    HRESULT Open( const CHAR* strFileName );
    VOID    Close();

    // File format
    HRESULT GetFormat( WAVEFORMATEXTENSIBLE* pwfxFormat, XMA2WAVEFORMATEX* pXma2Format = NULL ) const;

    // File data
    HRESULT ReadSample( DWORD dwPosition, VOID* pBuffer, DWORD dwBufferSize,
                        DWORD* pdwRead ) const;

    // File data - no endianness conversion is performed
    HRESULT ReadSampleRaw( DWORD dwPosition, VOID* pBuffer, DWORD dwBufferSize,
                        DWORD* pdwRead ) const;

    // Loop region
    HRESULT GetLoopRegion( DWORD* pdwStart, DWORD* pdwLength ) const;
    HRESULT GetLoopRegionBytes( DWORD* pdwStart, DWORD* pdwLength ) const;

    // File properties
    VOID    GetDuration( DWORD* pdwDuration ) const
    {
        *pdwDuration = m_DataChunk.GetDataSize();
    }
    DWORD   Duration() const
    {
        return m_DataChunk.GetDataSize();
    }

    // The 'dpds' chunk - packet cumulative bytes. Returns the packet count and the total structure size, in bytes.
    // The packet count is for the client to index the structure returned by GetPacketCumulativeBytes.
    // The buffer size is the total size, in bytes, of the structure. The client can use this value to allocate a pointer to
    // pass to GetPacketCumulativeBytes.
    // This function should be used with XWMA files only.
    HRESULT GetPacketCumulativeBytesSize( DWORD* pdwPacketCount, DWORD* pdwBufferSize );

    // The 'dpds' chunk - packet cumulative bytes. Returns the structure data.
    // 'pdwData' should point to a memory block large enough to hold all the data. The exact number of bytes
    // required can be obtained by calling GetPacketCumulativeBytes.
    // This function should be used with XWMA files only.
    HRESULT GetPacketCumulativeBytes( DWORD* pdwData );

    // The 'seek' chunk - seek table. Returns the total structure size, in bytes.
    // The buffer size is the total size, in bytes, of the structure. The client can use this value to allocate a pointer to
    // pass to GetSeekTable.
    // This function should be used with XMA files only.
    HRESULT GetSeekTableSize( DWORD* pdwBufferSize );

    // The 'seek' chunk - seek table. Returns the structure data.
    // 'pdwData' should point to a memory block large enough to hold all the data. The exact number of bytes
    // required can be obtained by calling GetSeekTableSize.
    // This function should be used with XMA files only.
    HRESULT GetSeekTable( DWORD* pdwData );

private:
    // prevent copying so that we don't have to duplicate file handles
            WaveFile( const WaveFile& );
    WaveFile& operator =( const WaveFile& );
};


} // namespace ATG


#endif // ATGAUDIO_H

```

`XenonDumper/libs/Atg/AtgAvatarRenderer.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// AvatarRenderer.cpp
//
// A class for rendering an XBox avatar.  This class is similar to the IXAtgAvatarRenderer
// interface provided in the XDK
//
// Microsoft Advanced Technology Group
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#include "stdafx.h"
#include "AtgAvatarRenderer.h"
#include <xgraphics.h>
#include "AtgUtil.h"

namespace ATG
{

inline DWORD RoundUpToAlign( DWORD value, DWORD align )
{
    assert( ( align & ( align - 1 ) ) == 0 );   // checks the align is a power of two
    return ( ( value + align - 1 ) & ~( align - 1 ) );
}


//--------------------------------------------------------------------------------------
// Name: CreateAvatar()
// Desc: Create the avatar.  Normally XAvatarGetAssets would be used to create the avatar.
//       In this case, since there is no Avatar library for Windows, the avatar is loaded
//       from file that was previously saved from an avatar on Xbox 360.  The data is
//       endian swapped, and pointers are fixed up to arrive at the final avatar.  
//--------------------------------------------------------------------------------------
HRESULT AvatarRenderer::CreateAvatar( XAVATAR_METADATA& metadata )
{
    // Set all pose joints to identity and all texture layers to frame zero on construction. 
    XAVATAR_SKELETON_POSE_JOINT jointIdentity;
    jointIdentity.Position = XMVectorSet( 0.0f, 0.0f, 0.0f, 1.0f );
    jointIdentity.Rotation = XMQuaternionIdentity();
    jointIdentity.Scale    = XMVectorSet( 1.0f, 1.0f, 1.0f, 1.0f );
    for ( INT j = 0; j < XAVATAR_MAX_SKELETON_JOINTS; ++j )
    {
        m_AvatarJointPose[ j ] = jointIdentity;
    }
    ZeroMemory( m_dwTextureLayers, sizeof( m_dwTextureLayers ) );

    // Retrieve the required CPU and GPU buffer sizes. If we cannot get
    // these sizes then the initialization fails.
    DWORD cpuBufferSize, gpuBufferSize;
    RETURN_ON_FAIL( XAvatarGetAssetsResultSize( XAVATAR_COMPONENT_MASK_ALL, &cpuBufferSize, &gpuBufferSize ) );
    
    // Calculate the joint buffer size required per joint buffer, and then
    // add this to the overall GPU allocation size.
    const DWORD jointBufferSize   = XAVATAR_MAX_SKELETON_JOINTS * 12 * sizeof( FLOAT );
    const DWORD gpuAllocSize      = RoundUpToAlign( gpuBufferSize, GPU_MEMORY_BUFFER_ALIGN );
    
    // Attempt to allocate the CPU and GPU buffers with the appropriate 
    // alignments. We add a little extra to the GPU buffer for joints.
    m_pAssets = reinterpret_cast<XAVATAR_ASSETS*>( XMemAlloc( cpuBufferSize, MAKE_XALLOC_ATTRIBUTES( 0, TRUE, TRUE, FALSE, SAMPLE_ALLOCATOR_ID, XALLOC_ALIGNMENT_4, XALLOC_MEMPROTECT_READWRITE, FALSE, XALLOC_MEMTYPE_HEAP ) ) );
    m_pGpuBuffer = reinterpret_cast<BYTE*>( XPhysicalAlloc( gpuAllocSize, MAXULONG_PTR, GPU_MEMORY_BUFFER_ALIGN, PAGE_READWRITE | PAGE_WRITECOMBINE ) );
    m_pJointBuffer = reinterpret_cast<BYTE*>( XPhysicalAlloc( jointBufferSize * JOINT_BUFFER_COUNT, MAXULONG_PTR, 4, PAGE_READWRITE | PAGE_WRITECOMBINE ) );

    // If we failed to allocate memory then fail.
    if ( !m_pAssets || !m_pGpuBuffer )//|| !m_pJointBuffer )
    {
        return E_OUTOFMEMORY;
    }

    // Construct the joint vertex buffers in place in the GPU buffer.
    for ( INT jbi =  0; jbi < JOINT_BUFFER_COUNT; ++jbi )
    {
        XGSetVertexBufferHeader( jointBufferSize, 0, 0, 0, &m_JointBufferVBs[ jbi ] );
        XGOffsetResourceAddress( &m_JointBufferVBs[ jbi ], &m_pJointBuffer[ jbi * jointBufferSize ] );
    }

    m_dwJointBufferIndex = 0;

    // Get the avatar assets
    if ( ERROR_SUCCESS != XAvatarGetAssets( &metadata, XAVATAR_COMPONENT_MASK_ALL, 0, cpuBufferSize, m_pAssets, gpuAllocSize, m_pGpuBuffer, NULL ) )
    {
        return E_FAIL;
    }

    // Populate vertex buffers, index buffers, and texture headers for all component models.
    for ( DWORD cmi = 0; cmi < m_pAssets->ComponentCount; ++cmi )
    {
        // Reference this component model.
        const XAVATAR_MODEL* model = &m_pAssets->pComponentModels[ cmi ];

        // Skip models with no geometry
        if ( model->GlobalIndexBufferSize == 0 )
        {
            continue;
        }

        // Construct the vertex buffer in place, pointing at the global
        // vertex buffer for this model.
        XGSetVertexBufferHeader( model->GlobalVertexBufferSize, 0, 0, 0, &m_VertexBuffers[ cmi ] );
        XGOffsetResourceAddress( &m_VertexBuffers[ cmi ], model->pGlobalVertexBuffer );

        // Construct the index buffer in place, pointing at the global
        // index buffer for this model.
        XGSetIndexBufferHeader ( model->GlobalIndexBufferSize, 0, D3DFMT_INDEX16, 0, 0, &m_IndexBuffers[ cmi ] );
        XGOffsetResourceAddress( &m_IndexBuffers[ cmi ], model->pGlobalIndexBuffer );

        // Construct textures in place.
        for ( DWORD ti = 0; ti < model->TextureCount; ++ti )
        {
            // Reference this texture.
            const XAVATAR_TEXTURE* texture = &model->pTextures[ ti ];

            // Reference the address of the first layer of this texture.
            BYTE* layerData = texture->pBaseData;

            // Iterate over all layers of this texture, creating the D3D
            // textures that reference that layer data.
            for ( DWORD li = 0; li < texture->LayerCount; ++li )
            {
                // Construct the layer texture, pointing at the
                // layer data for this texture and layer.
                XGSetTextureHeader( texture->Width,
                                    texture->Height, 
                                    1, 0, texture->Format, 0, 
                                    ( UINT )( layerData + li * texture->BaseSize ), 
                                    0, 0, &m_Textures[ cmi ][ ti ][ li ] , 0, 0 );

            }
        }
    }

    // Zero the shader structure before we begin to load shaders.
    ZeroMemory( m_D3dShaders, sizeof( m_D3dShaders ) );

    // Define the vertex structure for the "head" shaders. These have six
    // UV sets, for a total of 52 bytes per vertex in stream 0.
    const D3DVERTEXELEMENT9 headDeclDesc[] =
    {
        { 0,  0, D3DDECLTYPE_FLOAT3,    D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION,     0 }, // XAVATAR_VERTEX_POSITION
        { 0, 12, D3DDECLTYPE_HEND3N,    D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_NORMAL,       0 }, // XAVATAR_VERTEX_NORMAL
        { 0, 16, D3DDECLTYPE_UBYTE4N,   D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_BLENDWEIGHT,  0 }, // XAVATAR_VERTEX_WEIGHTS
        { 0, 20, D3DDECLTYPE_UBYTE4,    D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_BLENDINDICES, 0 }, // XAVATAR_VERTEX_BINDINGS
        { 0, 24, D3DDECLTYPE_D3DCOLOR,  D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_COLOR,        0 }, // XAVATAR_VERTEX_COLOR
        { 0, 28, D3DDECLTYPE_FLOAT16_2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD,     0 }, // XAVATAR_VERTEX_UV
        { 0, 32, D3DDECLTYPE_FLOAT16_2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD,     1 }, // XAVATAR_VERTEX_UV
        { 0, 36, D3DDECLTYPE_FLOAT16_2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD,     2 }, // XAVATAR_VERTEX_UV
        { 0, 40, D3DDECLTYPE_FLOAT16_2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD,     3 }, // XAVATAR_VERTEX_UV
        { 0, 44, D3DDECLTYPE_FLOAT16_2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD,     4 }, // XAVATAR_VERTEX_UV
        { 0, 48, D3DDECLTYPE_FLOAT16_2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD,     5 }, // XAVATAR_VERTEX_UV
        { 1,  0, D3DDECLTYPE_FLOAT4,    D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD,     6 }, // Joint buffer.
        { 1, 16, D3DDECLTYPE_FLOAT4,    D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD,     7 }, // Joint buffer.
        { 1, 32, D3DDECLTYPE_FLOAT4,    D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD,     8 }, // Joint buffer.
        D3DDECL_END()
    };

    // Define the vertex structure for the "body" shaders. These have three
    // UV sets, for a total of 40 bytes per vertex in stream 0.
    const D3DVERTEXELEMENT9 bodyDeclDesc[] =
    {
        { 0,  0, D3DDECLTYPE_FLOAT3,    D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION,     0 }, // XAVATAR_VERTEX_POSITION
        { 0, 12, D3DDECLTYPE_HEND3N,    D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_NORMAL,       0 }, // XAVATAR_VERTEX_NORMAL
        { 0, 16, D3DDECLTYPE_UBYTE4N,   D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_BLENDWEIGHT,  0 }, // XAVATAR_VERTEX_WEIGHTS
        { 0, 20, D3DDECLTYPE_UBYTE4,    D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_BLENDINDICES, 0 }, // XAVATAR_VERTEX_BINDINGS
        { 0, 24, D3DDECLTYPE_D3DCOLOR,  D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_COLOR,        0 }, // XAVATAR_VERTEX_COLOR
        { 0, 28, D3DDECLTYPE_FLOAT16_2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD,     0 }, // XAVATAR_VERTEX_UV
        { 0, 32, D3DDECLTYPE_FLOAT16_2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD,     1 }, // XAVATAR_VERTEX_UV
        { 0, 36, D3DDECLTYPE_FLOAT16_2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD,     2 }, // XAVATAR_VERTEX_UV
        { 1,  0, D3DDECLTYPE_FLOAT4,    D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD,     6 }, // Joint buffer.
        { 1, 16, D3DDECLTYPE_FLOAT4,    D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD,     7 }, // Joint buffer.
        { 1, 32, D3DDECLTYPE_FLOAT4,    D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD,     8 }, // Joint buffer.
        D3DDECL_END()
    };

    // Define the vertex structure for the "shiny body" shaders. These have two
    // UV sets, for a total of 36 bytes per vertex in stream 0.
    const D3DVERTEXELEMENT9 shinyDeclDesc[] =
    {
        { 0,  0, D3DDECLTYPE_FLOAT3,    D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION,     0 }, // XAVATAR_VERTEX_POSITION
        { 0, 12, D3DDECLTYPE_HEND3N,    D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_NORMAL,       0 }, // XAVATAR_VERTEX_NORMAL
        { 0, 16, D3DDECLTYPE_UBYTE4N,   D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_BLENDWEIGHT,  0 }, // XAVATAR_VERTEX_WEIGHTS
        { 0, 20, D3DDECLTYPE_UBYTE4,    D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_BLENDINDICES, 0 }, // XAVATAR_VERTEX_BINDINGS
        { 0, 24, D3DDECLTYPE_D3DCOLOR,  D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_COLOR,        0 }, // XAVATAR_VERTEX_COLOR
        { 0, 28, D3DDECLTYPE_FLOAT16_2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD,     0 }, // XAVATAR_VERTEX_UV
        { 0, 32, D3DDECLTYPE_FLOAT16_2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD,     1 }, // XAVATAR_VERTEX_UV
        { 1,  0, D3DDECLTYPE_FLOAT4,    D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD,     6 }, // Joint buffer.
        { 1, 16, D3DDECLTYPE_FLOAT4,    D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD,     7 }, // Joint buffer.
        { 1, 32, D3DDECLTYPE_FLOAT4,    D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD,     8 }, // Joint buffer.
        D3DDECL_END()
    };

    IDirect3DDevice9& device = *m_pd3dDevice;

    HRESULT hr;

    // Create the head and body vertex declarations. We will add appropriate
    // references for each shader later.
    D3DVertexDeclaration *headDecl, *bodyDecl, *shinyDecl;
    if ( !SUCCEEDED( hr = device.CreateVertexDeclaration( bodyDeclDesc,  &bodyDecl  ) ) ||
         !SUCCEEDED( hr = device.CreateVertexDeclaration( headDeclDesc,  &headDecl  ) ) ||
         !SUCCEEDED( hr = device.CreateVertexDeclaration( shinyDeclDesc, &shinyDecl ) )  )
    {
        return E_FAIL;
    }

    // Create all vertex shaders. We will add appropriate references for 
    // each shader later.
    D3DVertexShader *bodyVs, *headOpaqueVs,*bodyShinyVs;
    ATG::LoadVertexShader( "game:\\media\\shaders\\body_vs.xvu", &bodyVs );
    ATG::LoadVertexShader( "game:\\media\\shaders\\head_opaque_vs.xvu", &headOpaqueVs );
    ATG::LoadVertexShader( "game:\\media\\shaders\\body_shiny_vs.xvu", &bodyShinyVs );

    // Create all pixel shaders. We will add appropriate references for each
    // shader later.
    D3DPixelShader *bodyOpaquePs, *headOpaquePs, *bodyTranspPs;
    D3DPixelShader *bodyShinyOpaquePs, *bodyShinyTranspPs;
    ATG::LoadPixelShader( "game:\\media\\shaders\\body_opaque_ps.xpu", &bodyOpaquePs );
    ATG::LoadPixelShader( "game:\\media\\shaders\\head_opaque_ps.xpu", &headOpaquePs );
    ATG::LoadPixelShader( "game:\\media\\shaders\\body_transparent_ps.xpu", &bodyTranspPs );
    ATG::LoadPixelShader( "game:\\media\\shaders\\body_shiny_opaque_ps.xpu", &bodyShinyOpaquePs );
    ATG::LoadPixelShader( "game:\\media\\shaders\\body_shiny_transparent_ps.xpu", &bodyShinyTranspPs );

    // Set declaration, vertex and pixel shaders for each material.
    m_D3dShaders[ XAVATAR_SHADER_BODY_OPAQUE            ].m_VertexDeclaration  = bodyDecl;
    m_D3dShaders[ XAVATAR_SHADER_BODY_OPAQUE            ].m_VertexShader       = bodyVs;
    m_D3dShaders[ XAVATAR_SHADER_BODY_OPAQUE            ].m_PixelShader        = bodyOpaquePs;

    m_D3dShaders[ XAVATAR_SHADER_BODY_TRANSPARENT       ].m_VertexDeclaration  = bodyDecl;
    m_D3dShaders[ XAVATAR_SHADER_BODY_TRANSPARENT       ].m_VertexShader       = bodyVs;
    m_D3dShaders[ XAVATAR_SHADER_BODY_TRANSPARENT       ].m_PixelShader        = bodyTranspPs;

    m_D3dShaders[ XAVATAR_SHADER_BODY_SHINY_OPAQUE      ].m_VertexDeclaration  = shinyDecl;
    m_D3dShaders[ XAVATAR_SHADER_BODY_SHINY_OPAQUE      ].m_VertexShader       = bodyShinyVs;
    m_D3dShaders[ XAVATAR_SHADER_BODY_SHINY_OPAQUE      ].m_PixelShader        = bodyShinyOpaquePs;

    m_D3dShaders[ XAVATAR_SHADER_BODY_SHINY_TRANSPARENT ].m_VertexDeclaration  = shinyDecl;
    m_D3dShaders[ XAVATAR_SHADER_BODY_SHINY_TRANSPARENT ].m_VertexShader       = bodyShinyVs;
    m_D3dShaders[ XAVATAR_SHADER_BODY_SHINY_TRANSPARENT ].m_PixelShader        = bodyShinyTranspPs;

    m_D3dShaders[ XAVATAR_SHADER_HEAD_OPAQUE            ].m_VertexDeclaration  = headDecl;
    m_D3dShaders[ XAVATAR_SHADER_HEAD_OPAQUE            ].m_VertexShader       = headOpaqueVs;
    m_D3dShaders[ XAVATAR_SHADER_HEAD_OPAQUE            ].m_PixelShader        = headOpaquePs;
 
    // Add appropriate references to each declaration and shader.
    for ( INT s = 0; s < XAVATAR_SHADER_COUNT; ++s )
    {
        m_D3dShaders[ s ].m_VertexDeclaration ->AddRef();
        m_D3dShaders[ s ].m_VertexShader      ->AddRef();
        m_D3dShaders[ s ].m_PixelShader       ->AddRef();
    }

    // Set light color. 
    m_vLightColor    [ 0 ] = XMVectorSet( +0.200f, +0.100f, +0.050f, 1.0f );
    m_vLightColor    [ 1 ] = XMVectorSet( +0.100f, +0.100f, +0.200f, 1.0f );
    m_vLightColor    [ 2 ] = XMVectorSet( +0.400f, +0.400f, +0.400f, 1.0f );

    // Set light direction. 
    m_vLightDirection[ 0 ] = XMVectorSet( +0.342f, +0.000f, -0.940f, 1.0f );
    m_vLightDirection[ 1 ] = XMVectorSet( +1.000f, +0.000f, +0.000f, 1.0f );
    m_vLightDirection[ 2 ] = XMVectorSet( -0.500f, -0.612f, -0.612f, 1.0f );

    // Clear the shader texture index and constant register maps to invalid
    // values so we will know immediately if we get an invalid value.
    FillMemory( m_ShaderTextureIndexMap,     sizeof( m_ShaderTextureIndexMap     ), 0xff );
    FillMemory( m_PixelConstantRegisterMap,  sizeof( m_PixelConstantRegisterMap  ), 0xff );
    FillMemory( m_VertexConstantRegisterMap, sizeof( m_VertexConstantRegisterMap ), 0xff );

    // Set up mappings for texture usages to the appropriate shader index.
    // We only provide mappings for textures that have no UVs. Textures with
    // UVs will automatically be mapped to the corresponding texture index.
    m_ShaderTextureIndexMap[ XAVATAR_SHADER_PARAM_USAGE_TEXTURE_REFLECTION ][ XAVATAR_SHADER_BODY_SHINY_OPAQUE      ] = 2;
    m_ShaderTextureIndexMap[ XAVATAR_SHADER_PARAM_USAGE_TEXTURE_REFLECTION ][ XAVATAR_SHADER_BODY_SHINY_TRANSPARENT ] = 2;

    // Set up mappings for all pixel constants to the appropriate register.
    m_PixelConstantRegisterMap[ XAVATAR_SHADER_PARAM_USAGE_PIXEL_CONSTANT_COLOR_CUSTOM_0        ] = 210;
    m_PixelConstantRegisterMap[ XAVATAR_SHADER_PARAM_USAGE_PIXEL_CONSTANT_COLOR_CUSTOM_1        ] = 211;
    m_PixelConstantRegisterMap[ XAVATAR_SHADER_PARAM_USAGE_PIXEL_CONSTANT_COLOR_CUSTOM_2        ] = 212;
    m_PixelConstantRegisterMap[ XAVATAR_SHADER_PARAM_USAGE_PIXEL_CONSTANT_TRANSPARENCY          ] = 213;
    m_PixelConstantRegisterMap[ XAVATAR_SHADER_PARAM_USAGE_PIXEL_CONSTANT_REFLECTIVITY          ] = 214;
    m_PixelConstantRegisterMap[ XAVATAR_SHADER_PARAM_USAGE_PIXEL_CONSTANT_COLOR_SKIN            ] = 215;
    m_PixelConstantRegisterMap[ XAVATAR_SHADER_PARAM_USAGE_PIXEL_CONSTANT_COLOR_HAIR            ] = 216;
    m_PixelConstantRegisterMap[ XAVATAR_SHADER_PARAM_USAGE_PIXEL_CONSTANT_COLOR_MOUTH           ] = 217;
    m_PixelConstantRegisterMap[ XAVATAR_SHADER_PARAM_USAGE_PIXEL_CONSTANT_COLOR_IRIS            ] = 218;
    m_PixelConstantRegisterMap[ XAVATAR_SHADER_PARAM_USAGE_PIXEL_CONSTANT_COLOR_EYEBROW         ] = 219;
    m_PixelConstantRegisterMap[ XAVATAR_SHADER_PARAM_USAGE_PIXEL_CONSTANT_COLOR_EYE_SHADOW      ] = 220;    
    m_PixelConstantRegisterMap[ XAVATAR_SHADER_PARAM_USAGE_PIXEL_CONSTANT_COLOR_FACIAL_HAIR     ] = 221;    
    m_PixelConstantRegisterMap[ XAVATAR_SHADER_PARAM_USAGE_PIXEL_CONSTANT_COLOR_SKIN_FEATURE_1  ] = 222;
    m_PixelConstantRegisterMap[ XAVATAR_SHADER_PARAM_USAGE_PIXEL_CONSTANT_COLOR_SKIN_FEATURE_2  ] = 223;
    m_PixelConstantRegisterMap[ XAVATAR_SHADER_PARAM_USAGE_PIXEL_CONSTANT_COLOR_RIMLIGHT        ] = 5;

    // We can now remove the local reference to each declaration and shader.
    SAFE_RELEASE( headDecl );
    SAFE_RELEASE( bodyDecl );
    SAFE_RELEASE( shinyDecl );
    SAFE_RELEASE( bodyVs );
    SAFE_RELEASE( headOpaqueVs );
    SAFE_RELEASE( bodyOpaquePs );
    SAFE_RELEASE( headOpaquePs );
    SAFE_RELEASE( bodyTranspPs );
    SAFE_RELEASE( bodyShinyOpaquePs );
    SAFE_RELEASE( bodyShinyTranspPs );
    SAFE_RELEASE( bodyShinyVs );
    
	RebuildJoints();

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: RebuildJoints()
// Desc: Rebuilds the joints from the current pose. 
//--------------------------------------------------------------------------------------
HRESULT AvatarRenderer::RebuildJoints()
{
    // Intermediate storage for the joint transforms and 12-FLOAT packed
    // transposes, which is how we present the data to the vertex shader.    
    static XMMATRIX  matJointTransforms[ XAVATAR_MAX_SKELETON_JOINTS ];
    static XMFLOAT4A transposes[ XAVATAR_MAX_SKELETON_JOINTS * 3 ];
    
    // First, build joint transforms in world-space.
    for ( DWORD j = 0; j < m_pAssets->pSkeleton->Count; ++j )
    {
        // Reference the relevant components for building this joint.
        const XAVATAR_SKELETON_POSE_JOINT&     offset    = m_AvatarJointPose[ j ];
        const XAVATAR_SKELETON_JOINT&          skelJoint = m_pAssets->pSkeleton->pJoints[ j ];
        const XAVATAR_SKELETON_POSE_JOINT&     bindPose  = skelJoint.BindPose.Local;
        const XAVATAR_SKELETON_HIERARCHY_JOINT hierarchy = skelJoint.Hierarchy;

        // Make sure that the parent has already been processed
        assert( j == 0 || hierarchy.Parent < j );

        // Generate the bindpose transform for this joint.
        XMMATRIX bindPoseT;
        bindPoseT = XMMatrixRotationQuaternion( bindPose.Rotation );
        bindPoseT = XMMatrixMultiply( bindPoseT, XMMatrixScalingFromVector( bindPose.Scale ) );
        bindPoseT.r[ 3 ] = bindPose.Position;

        // Generate the offset transform for this joint.
        XMMATRIX offsetT;
        offsetT = XMMatrixRotationQuaternion( offset.Rotation );
        offsetT = XMMatrixMultiply( offsetT, XMMatrixScalingFromVector( offset.Scale ) );
        offsetT.r[ 3 ] = offset.Position;

        // Retrieve the parent transform, or the basis for joint zero.
        XMMATRIX parentT = ( j ? matJointTransforms[ hierarchy.Parent ] : XMMatrixIdentity() );

        // Generate the joint transform by applying the bindpose to the 
        // offset, and then transforming by the parent transform.
        matJointTransforms[ j ] = XMMatrixMultiply( XMMatrixMultiply( offsetT, bindPoseT ), parentT );
    }

    // Now pre-multiply these joint transforms by the inverse bind-pose 
    // transform for that joint. This gives us a final transform that 
    // converts model-space vertices into skinned vertices in one multiply.
    // We take the transposes of these transforms and pack them into 12
    // floats for presentation to the vertex shader.
    for ( DWORD j = 0; j < m_pAssets->pSkeleton->Count; ++j )
    {
        // Reference the bindpose data for this joint.
        const XAVATAR_SKELETON_BINDPOSE_JOINT& bindPose = m_pAssets->pSkeleton->pJoints[ j ].BindPose;

        // Generate the bindpose transform for this joint, and preapply
        // it to the joint transform to generate the final transform.
        XMVECTOR determinant;
        XMMATRIX invBindPoseT;
        invBindPoseT = XMMatrixRotationQuaternion( bindPose.Rotation );
        invBindPoseT.r[ 3 ] = bindPose.Position;
        invBindPoseT = XMMatrixInverse( &determinant, invBindPoseT );
        XMMATRIX transform = XMMatrixMultiply ( invBindPoseT, matJointTransforms[ j ] );

        // Take the transpose and pack it into 12 floats, which is the
        // required format for our vertex shader.
        XMMATRIX transpose = XMMatrixTranspose( transform );
        XMStoreFloat4A( &transposes[ j * 3 + 0 ], transpose.r[ 0 ] );
        XMStoreFloat4A( &transposes[ j * 3 + 1 ], transpose.r[ 1 ] );
        XMStoreFloat4A( &transposes[ j * 3 + 2 ], transpose.r[ 2 ] );
    }

    // We now loop until we get an exclusive lock on the current joint
    // buffer. We only increment the buffer while we hold the lock.
    VOID*            pCurrJointData;
    D3DVertexBuffer* pCurrJointBuffer;
    for ( ; ; )
    {
        // Select the next joint buffer, into which we copy the data.
        DWORD dwCurrBufferIndex = m_dwJointBufferIndex;
        DWORD dwNextBufferIndex = ( dwCurrBufferIndex + 1 ) % JOINT_BUFFER_COUNT;
        pCurrJointBuffer       = &m_JointBufferVBs[ dwNextBufferIndex ];

        // Warn on joint buffer contention
        #ifdef _DEBUG
        {
            // If the current joint buffer is still busy, give
            // a warning about contention for the buffer.
            if( pCurrJointBuffer->IsBusy( ) )
            {
                // Regulates how often warnings like this appear.
                static const FLOAT JOINT_BUFFER_SET_WARN_INTERVAL_S = 10.0f;

                // Ensure we use a constant tick count throughout this
                // block.
                DWORD tickCount = GetTickCount();

                // Start out "last warning" time as double what we need
                // for a warning to spew
                static DWORD tickCountAtLastWarning = tickCount - (DWORD)(JOINT_BUFFER_SET_WARN_INTERVAL_S * 1000.0f * 2.0f);

                // Short-hand for the time that has passed (in seconds) 
                // since last warning was issued.
                FLOAT timeSinceLastWarning = (FLOAT)(tickCount - tickCountAtLastWarning) / 1000.0f;

                // If we haven't spewed out warning for a while, do so.
                if( timeSinceLastWarning > JOINT_BUFFER_SET_WARN_INTERVAL_S )
                {
                    ATG::DebugSpew( "WARNING: Avatar joint buffer is still in use by the device during update. Increase the joint buffer count." );
                    tickCountAtLastWarning = tickCount;
                }            
            }
        }
        #endif // _DEBUG

        // Lock the buffer ready to copy in the transposed transforms.
        if ( !SUCCEEDED( pCurrJointBuffer->Lock( 0, 0, &pCurrJointData, 0 ) ) )
        {
            return E_FAIL;
        }

        if ( m_dwJointBufferIndex == dwCurrBufferIndex )
        {
            m_dwJointBufferIndex = dwNextBufferIndex;
            break;
        }
    }

    // Copy the 12-FLOAT packed, transposed joint transforms into the
    // joint buffer, ready to be presented to the vertex shader.
    XMemCpyStreaming_WriteCombined( pCurrJointData, transposes, sizeof( transposes ) );

    // Unlock the joint buffer.
    if ( !SUCCEEDED( pCurrJointBuffer->Unlock() ) )
    {
        return E_FAIL;
    }
    
    // Return success.
    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: Render()
// Desc: Renders the avatar.
//--------------------------------------------------------------------------------------
VOID AvatarRenderer::Render( XMMATRIX matWorld, XMMATRIX matView, XMMATRIX matProj )
{

    // Set up device state and shader constants
    PreRender( &matWorld, &matView, &matProj );

    // Iterate over all component models and render opaque materials.
    for ( DWORD cmi = 0; cmi < m_pAssets->ComponentCount; ++cmi )
    {
        RenderOpaque( cmi,
                      &m_JointBufferVBs[ m_dwJointBufferIndex ] );
    }

    // Iterate over all component models and render transparent materials.
    for ( DWORD cmi = 0; cmi < m_pAssets->ComponentCount; ++cmi )
    {
        RenderTransparent( cmi,
                           &m_JointBufferVBs[ m_dwJointBufferIndex ] );
    }

    // End the render pass
    PostRender( );
}


//--------------------------------------------------------------------------------------
// Name: PreRender()
// Desc: Begin the rendering pass. This should be invoked before the
//       RenderOpaque() and RenderTransparent() functions, and
//       matched with a call to PostRender() once the pass is complete.
//--------------------------------------------------------------------------------------
HRESULT AvatarRenderer::PreRender(  const XMMATRIX*     modelTransform,
                                    const XMMATRIX*     viewTransform,
                                    const XMMATRIX*     projectionTransform )
{
     XMMATRIX modelViewTransform = *modelTransform * *viewTransform;

    m_pd3dDevice->SetVertexShaderConstantF( 0, (FLOAT*)&modelViewTransform, 4 );
    m_pd3dDevice->SetVertexShaderConstantF( 4, (FLOAT*)projectionTransform, 4 );

    // set lights
    FLOAT ambientColor [ 4 ] = { 0.55f, 0.55f, 0.550f, 1.0f };

    XMVECTOR lightDirection[ 3 ];
    lightDirection[ 0 ] = XMVector3Normalize( m_vLightDirection[ 0 ] );
    lightDirection[ 1 ] = XMVector3Normalize( m_vLightDirection[ 1 ] );
    lightDirection[ 2 ] = XMVector3Normalize( XMVector3TransformNormal( XMVectorScale( m_vLightDirection[ 2 ], -1.0f ), *viewTransform ) );

    m_pd3dDevice->SetPixelShaderConstantF(   0, &m_vLightColor [ 2 ].x, 1 );
    m_pd3dDevice->SetPixelShaderConstantF(   1, &lightDirection[ 2 ].x, 1 );
    m_pd3dDevice->SetPixelShaderConstantF(   2, &m_vLightColor [ 0 ].x, 1 );
    m_pd3dDevice->SetPixelShaderConstantF(   3, &lightDirection[ 0 ].x, 1 );
    m_pd3dDevice->SetPixelShaderConstantF( 100, &m_vLightColor [ 1 ].x, 1 );
    m_pd3dDevice->SetPixelShaderConstantF( 101, &lightDirection[ 1 ].x, 1 );
    m_pd3dDevice->SetPixelShaderConstantF(   4, ambientColor,           1 );

    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CW );

    m_pd3dDevice->SetSamplerState_Inline( 0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 0, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 1, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 1, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 1, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 2, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 2, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 2, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 3, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 3, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 3, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 4, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 4, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 4, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 5, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 5, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 5, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 6, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 6, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 6, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 7, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 7, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 7, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 8, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 8, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetSamplerState_Inline( 8, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR );

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: RenderOpaque()
// Desc: Render an opaque model. Make sure to call the PreRender()
//       function to set up the render state appropriately for the pass.
//--------------------------------------------------------------------------------------
HRESULT AvatarRenderer::RenderOpaque( DWORD dwModelIndex, D3DVertexBuffer* pJointBuffer )
{
    XAVATAR_MODEL*      pModel = &m_pAssets->pComponentModels[ dwModelIndex ];
    D3DVertexBuffer*    pVertexBuffer = &m_VertexBuffers[ dwModelIndex ];
    D3DIndexBuffer*     pIndexBuffer = &m_IndexBuffers[ dwModelIndex ];

    // If the model is empty then we have nothing to do here.
    if ( !pModel->GlobalIndexBufferSize )
    {
        return S_OK;
    }

    // Defines the shaders we consider when performing the opaque pass.
    static const XAVATAR_SHADER OPAQUE_SHADERS[] = 
    { 
        XAVATAR_SHADER_BODY_SHINY_OPAQUE,
        XAVATAR_SHADER_BODY_OPAQUE, 
        XAVATAR_SHADER_HEAD_OPAQUE,
    };

    // Set up the render state for the opaque render pass.
    m_pd3dDevice->SetRenderState_Inline( D3DRS_ALPHATESTENABLE,  TRUE                );
    m_pd3dDevice->SetRenderState_Inline( D3DRS_ALPHAFUNC,        D3DCMP_GREATEREQUAL );
    m_pd3dDevice->SetRenderState_Inline( D3DRS_ALPHAREF,         0x80                );
    m_pd3dDevice->SetRenderState_Inline( D3DRS_ZENABLE,          TRUE                );
    m_pd3dDevice->SetRenderState_Inline( D3DRS_ZWRITEENABLE,     TRUE                );

    D3DBLENDSTATE blendState;
    blendState.SrcBlend       = D3DBLEND_ONE;
    blendState.BlendOp        = D3DBLENDOP_ADD;
    blendState.DestBlend      = D3DBLEND_ZERO;
    blendState.SrcBlendAlpha  = D3DBLEND_ONE;
    blendState.BlendOpAlpha   = D3DBLENDOP_ADD;
    blendState.DestBlendAlpha = D3DBLEND_ZERO;
    m_pd3dDevice->SetBlendState( 0, blendState );

    m_pd3dDevice->SetIndices( pIndexBuffer );

    m_pd3dDevice->SetStreamSource( 1, pJointBuffer, 0, 12 * sizeof( FLOAT ) );

    // Render all appropriate batches of this model as normal opaque.
    for ( INT osi = 0; osi < ARRAYSIZE( OPAQUE_SHADERS ); ++osi )
    {
        // The current shader we are looking for.
        const XAVATAR_SHADER currentShader = OPAQUE_SHADERS[ osi ];

        // Set the vertex declaration and shader for the current shader.
        m_pd3dDevice->SetVertexDeclaration( m_D3dShaders[ currentShader ].m_VertexDeclaration  );
        m_pd3dDevice->SetVertexShader     ( m_D3dShaders[ currentShader ].m_VertexShader       );
        m_pd3dDevice->SetPixelShader      ( m_D3dShaders[ currentShader ].m_PixelShader        );

        // Render all batches of this model that use this shader.
        for ( DWORD bi = 0; bi < pModel->BatchCount; ++bi )
        {
            // Reference the current batch.
            const XAVATAR_TRIANGLE_BATCH& batch = pModel->pBatches[ bi ];

            // If this batch uses the current shader then we render it.
            if ( batch.ShaderInstance.Shader == currentShader )
            {
                SetShaderTexturesAndConstants( dwModelIndex, &batch.ShaderInstance, pModel->pTextures, m_dwTextureLayers );
                m_pd3dDevice->SetStreamSource( 0, pVertexBuffer, batch.pVertices - pModel->pGlobalVertexBuffer, batch.VertexStride );
                m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, 0, 0, ( WORD* )batch.pIndices - ( WORD* )pModel->pGlobalIndexBuffer, batch.TriangleCount );
                ClearShaderTexturesAndConstants( );
            }
        }
    }

    // Reset the device. Clear vertex declaration and shaders set above.
    m_pd3dDevice->SetVertexDeclaration( 0 );
    m_pd3dDevice->SetVertexShader     ( 0 );
    m_pd3dDevice->SetPixelShader      ( 0 );

    // Reset the device. Clear vertex buffer stream sources set above.
    m_pd3dDevice->SetStreamSource( 0, 0, 0, 0 );
    m_pd3dDevice->SetStreamSource( 1, 0, 0, 0 );

    // Reset the device: Clear the index buffer source set above.
    m_pd3dDevice->SetIndices( 0 );

    // Return success.
    return S_OK;
}

//--------------------------------------------------------------------------------------
// Name: RenderTransparent()
// Desc: Render a model in the transparent pass.  Make sure to call the PreRender()
//       function to set up the render state appropriately for the pass.
//--------------------------------------------------------------------------------------
HRESULT AvatarRenderer::RenderTransparent( DWORD dwModelIndex, D3DVertexBuffer* pJointBuffer )
{
     XAVATAR_MODEL*      pModel = &m_pAssets->pComponentModels[ dwModelIndex ];
    D3DVertexBuffer*    pVertexBuffer = &m_VertexBuffers[ dwModelIndex ];
    D3DIndexBuffer*     pIndexBuffer = &m_IndexBuffers[ dwModelIndex ];

    // If the model is empty then we have nothing to do here.
    if ( !pModel->GlobalIndexBufferSize )
    {
        return S_OK;
    }

    // Defines the shaders we consider when performing the transparent pass.
    const XAVATAR_SHADER TRANSPARENT_SHADERS[] = 
    { 
        XAVATAR_SHADER_BODY_SHINY_TRANSPARENT,
        XAVATAR_SHADER_BODY_TRANSPARENT, 
    };

    // Set up the render state for the transparent render pass.
    m_pd3dDevice->SetRenderState_Inline( D3DRS_ALPHATESTENABLE,          FALSE );
    m_pd3dDevice->SetRenderState_Inline( D3DRS_ZENABLE,                  TRUE  );
    m_pd3dDevice->SetRenderState_Inline( D3DRS_ZWRITEENABLE,             FALSE );
    m_pd3dDevice->SetRenderState_Inline( D3DRS_HIGHPRECISIONBLENDENABLE, TRUE  );

    D3DBLENDSTATE blendState;
    blendState.SrcBlend       = D3DBLEND_SRCALPHA;
    blendState.BlendOp        = D3DBLENDOP_ADD;
    blendState.DestBlend      = D3DBLEND_INVSRCALPHA;
    blendState.SrcBlendAlpha  = D3DBLEND_ONE;
    blendState.BlendOpAlpha   = D3DBLENDOP_ADD;
    blendState.DestBlendAlpha = D3DBLEND_INVSRCALPHA;
    m_pd3dDevice->SetBlendState( 0, blendState );

    m_pd3dDevice->SetIndices( pIndexBuffer );

    // Set the joint buffer as a stream source on the device.
    m_pd3dDevice->SetStreamSource( 1, pJointBuffer, 0, 12 * sizeof( FLOAT ) );

    // Render all appropriate batches of this model as transparent.
    for ( INT tsi = 0; tsi < ARRAYSIZE( TRANSPARENT_SHADERS ); ++tsi )
    {
        // The current shader we are looking for.
        const XAVATAR_SHADER currentShader = TRANSPARENT_SHADERS[ tsi ];

        // Set the vertex declaration and shader for the current shader.
        m_pd3dDevice->SetVertexDeclaration( m_D3dShaders[ currentShader ].m_VertexDeclaration  );
        m_pd3dDevice->SetVertexShader     ( m_D3dShaders[ currentShader ].m_VertexShader       );
        m_pd3dDevice->SetPixelShader      ( m_D3dShaders[ currentShader ].m_PixelShader        );

        // Render all batches of this model that use this shader.
        for ( DWORD bi = 0; bi < pModel->BatchCount; ++bi )
        {
            // Reference the current batch.
            const XAVATAR_TRIANGLE_BATCH& batch = pModel->pBatches[ bi ];

            // If this batch uses the current shader then we render it.
            if ( batch.ShaderInstance.Shader == currentShader )
            {
                SetShaderTexturesAndConstants( dwModelIndex, &batch.ShaderInstance, pModel->pTextures, m_dwTextureLayers );
                m_pd3dDevice->SetStreamSource( 0, pVertexBuffer, batch.pVertices - pModel->pGlobalVertexBuffer, batch.VertexStride );
                m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, 0, 0, ( WORD* )batch.pIndices - ( WORD* )pModel->pGlobalIndexBuffer, batch.TriangleCount );
                ClearShaderTexturesAndConstants( );
            }
        }
    }

    // Reset the device. Clear vertex declaration and shaders set above.
    m_pd3dDevice->SetVertexDeclaration( 0 );
    m_pd3dDevice->SetVertexShader     ( 0 );
    m_pd3dDevice->SetPixelShader      ( 0 );

    // Reset the device. Clear vertex buffer stream sources set above.
    m_pd3dDevice->SetStreamSource( 0, 0, 0, 0 );
    m_pd3dDevice->SetStreamSource( 1, 0, 0, 0 );

    // Reset the device: Clear the index buffer source set above.
    m_pd3dDevice->SetIndices( 0 );

    // Return success.
    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: PostRender()
// Desc: Complete the normal rendering pass.
//--------------------------------------------------------------------------------------
HRESULT AvatarRenderer::PostRender( )
{
    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: SetShaderTexturesAndConstants()
// Desc: Complete the normal rendering pass. Removes textures and shader settings
//       from the render state.
//--------------------------------------------------------------------------------------
VOID AvatarRenderer::SetShaderTexturesAndConstants(
    DWORD                           dwModelIndex,
    const XAVATAR_SHADER_INSTANCE*  shaderInstance,
    const XAVATAR_TEXTURE*          modelTextures,
    const DWORD*                    animatedTextureLayers )
{
    assert( modelTextures );
    assert( animatedTextureLayers );

    const XAVATAR_SHADER shader = shaderInstance->Shader;

    for ( INT pi = 0; pi < XAVATAR_SHADER_INSTANCE_MAX_PARAMS; ++pi )
    {
        const XAVATAR_SHADER_PARAM& param = shaderInstance->Params[ pi ];

        switch ( param.Type )
        {
            case ( XAVATAR_SHADER_PARAM_TYPE_NONE ):
            {
                assert( param.Usage == XAVATAR_SHADER_PARAM_USAGE_NONE );
                break;
            }

            case ( XAVATAR_SHADER_PARAM_TYPE_VERTEX_CONSTANT ):
            {
                const BYTE reg = GetVertexConstantRegister( &param, shader );
                m_pd3dDevice->SetVertexShaderConstantF( reg, param.Data.Constant.Value, 1 );
                break;
            }

            case ( XAVATAR_SHADER_PARAM_TYPE_PIXEL_CONSTANT ):
            {
                const BYTE reg = GetPixelConstantRegister( &param );
                m_pd3dDevice->SetPixelShaderConstantF( reg, param.Data.Constant.Value, 1 );
                break;
            }

            case ( XAVATAR_SHADER_PARAM_TYPE_TEXTURE ):
            {
                const XAVATAR_TEXTURE& texture = modelTextures[ param.Data.Texture.Index ];

                DWORD layerIndex   = 0; 
                switch ( param.Usage )
                {
                    case ( XAVATAR_SHADER_PARAM_USAGE_TEXTURE_EYEBROW_LEFT  ):
                    {
                        layerIndex = animatedTextureLayers[ XAVATAR_ANIMATED_TEXTURE_EYEBROW_LEFT ];
                        break;
                    }
                    case ( XAVATAR_SHADER_PARAM_USAGE_TEXTURE_EYEBROW_RIGHT ):
                    {
                        layerIndex = animatedTextureLayers[ XAVATAR_ANIMATED_TEXTURE_EYEBROW_RIGHT ];
                        break;
                    }
                    case ( XAVATAR_SHADER_PARAM_USAGE_TEXTURE_EYE_LEFT  ):
                    {
                        layerIndex = animatedTextureLayers[ XAVATAR_ANIMATED_TEXTURE_EYE_LEFT ];
                        break;
                    }
                    case ( XAVATAR_SHADER_PARAM_USAGE_TEXTURE_EYE_RIGHT ):
                    {
                        layerIndex = animatedTextureLayers[ XAVATAR_ANIMATED_TEXTURE_EYE_RIGHT ];
                        break;
                    }
                    case ( XAVATAR_SHADER_PARAM_USAGE_TEXTURE_MOUTH ):
                    {
                        layerIndex = animatedTextureLayers[ XAVATAR_ANIMATED_TEXTURE_MOUTH ];
                        break;
                    }
 
                }
            
                layerIndex = ( layerIndex < texture.LayerCount ? layerIndex : 0 );
                D3DTexture* textureHeader = &m_Textures[ dwModelIndex ][ param.Data.Texture.Index ][ layerIndex ];

                const WORD index = GetShaderTextureIndex( param, shader );
                m_pd3dDevice->SetTexture( index, textureHeader );
                m_pd3dDevice->SetSamplerState( index, D3DSAMP_ADDRESSU, ( ( param.Data.Texture.Flags & XAVATAR_TEXTURE_FLAGS_WRAP_U ) ? D3DTADDRESS_WRAP : D3DTADDRESS_CLAMP ) );
                m_pd3dDevice->SetSamplerState( index, D3DSAMP_ADDRESSV, ( ( param.Data.Texture.Flags & XAVATAR_TEXTURE_FLAGS_WRAP_V ) ? D3DTADDRESS_WRAP : D3DTADDRESS_CLAMP ) );
                break;
            }

            default:
            {
                // There are no other types
                assert( 0 );
            }
        }
    }
}


//--------------------------------------------------------------------------------------
// Name: GetVertexConstantRegister()
// Desc: Retrieve the constant register for a given vertex shader and parameter usage. 
//--------------------------------------------------------------------------------------
inline BYTE AvatarRenderer::GetVertexConstantRegister(  const XAVATAR_SHADER_PARAM* param,
                                                XAVATAR_SHADER              shader ) const
{
    assert( shader < XAVATAR_SHADER_COUNT );
    assert( param->Type == XAVATAR_SHADER_PARAM_TYPE_VERTEX_CONSTANT );
    assert( param->Usage < XAVATAR_SHADER_PARAM_USAGE_COUNT );
    assert( m_VertexConstantRegisterMap[ param->Usage ][ shader ] != 0xffff );
    return  m_VertexConstantRegisterMap[ param->Usage ][ shader ];
}


//--------------------------------------------------------------------------------------
// Name: GetPixelConstantRegister()
// Desc: Retrieve the texture index or constant start register for a
//       given parameter usage. Note: Pixel constants are uniform 
//       across all shaders.
//--------------------------------------------------------------------------------------
inline BYTE AvatarRenderer::GetPixelConstantRegister( const XAVATAR_SHADER_PARAM* param ) const
{
    assert( param->Type == XAVATAR_SHADER_PARAM_TYPE_PIXEL_CONSTANT );
    assert( param->Usage < XAVATAR_SHADER_PARAM_USAGE_COUNT );
    assert( m_PixelConstantRegisterMap[ param->Usage ] != 0xffff );
    return  m_PixelConstantRegisterMap[ param->Usage ];
}

//--------------------------------------------------------------------------------------
// Name: GetShaderTextureIndex()
// Desc: Retrieve the texture index for a given shader and parameter usage. 
//--------------------------------------------------------------------------------------
inline WORD AvatarRenderer::GetShaderTextureIndex(  const XAVATAR_SHADER_PARAM& param,
                                            XAVATAR_SHADER              shader ) const
{
    assert( shader < XAVATAR_SHADER_COUNT );
    assert( param.Type == XAVATAR_SHADER_PARAM_TYPE_TEXTURE );
    assert( param.Usage < XAVATAR_SHADER_PARAM_USAGE_COUNT );

    if ( param.Data.Texture.UvIndex != XAVATAR_INVALID_UV_INDEX )
    {
        assert( m_ShaderTextureIndexMap[ param.Usage ][ shader ] == 0xff );
        return param.Data.Texture.UvIndex;
    }
    else
    {
        assert( m_ShaderTextureIndexMap[ param.Usage ][ shader ] != 0xff );
        return  m_ShaderTextureIndexMap[ param.Usage ][ shader ];
    }
}


//--------------------------------------------------------------------------------------
// Name: ClearShaderTexturesAndConstants()
// Desc: Remove textures and shader settings from the render state.
//--------------------------------------------------------------------------------------
HRESULT AvatarRenderer::ClearShaderTexturesAndConstants( )
{
    m_pd3dDevice->SetTexture( 0, 0 );
    m_pd3dDevice->SetTexture( 1, 0 );
    m_pd3dDevice->SetTexture( 2, 0 );
    m_pd3dDevice->SetTexture( 3, 0 );
    m_pd3dDevice->SetTexture( 4, 0 );
    m_pd3dDevice->SetTexture( 5, 0 );

    return S_OK;
}

} // namespace ATG



```

`XenonDumper/libs/Atg/AtgAvatarRenderer.h`:

```h
//--------------------------------------------------------------------------------------
// AvatarRenderer.h
//
// A class for rendering an Xbox avatar.  This class is similar to the IXAvatarRenderer
// interface provided in the XDK
//
// Microsoft Advanced Technology Group
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------

#include <xtl.h>
#include <xboxmath.h>
#include <algorithm>
#include <xavatar.h>
#include "AtgUtil.h"

namespace ATG
{
	#define GPU_MEMORY_BUFFER_ALIGN 4096        // 4k alignment for textures
	#define SAMPLE_ALLOCATOR_ID 0

	static const DWORD JOINT_BUFFER_COUNT = 2;  // double buffered to allow skinning using vfetch

	class AvatarRenderer
	{
	public:
		AvatarRenderer( D3DDevice* pDevice, XAVATAR_METADATA& metadata ) :  m_pAssets(NULL),
											   m_pGpuBuffer(NULL)
		{
			m_pd3dDevice = pDevice;
			CreateAvatar( metadata );
		}
		~AvatarRenderer()
		{
			if( m_pAssets )
			{
				XMemFree( m_pAssets, MAKE_XALLOC_ATTRIBUTES( 0, 
															 TRUE, 
															 TRUE, 
															 FALSE, 
															 SAMPLE_ALLOCATOR_ID, 
															 XALLOC_ALIGNMENT_4, 
															 XALLOC_MEMPROTECT_READWRITE, 
															 FALSE, XALLOC_MEMTYPE_HEAP ) );

				m_pAssets = NULL;
			}

			if( m_pGpuBuffer )
			{
				XPhysicalFree( m_pGpuBuffer );
				m_pGpuBuffer = NULL;
			}

			if( m_pJointBuffer )
			{
				XPhysicalFree( m_pJointBuffer );
				m_pJointBuffer = NULL;
			}

			// Remove appropriate references to each declaration and shader.
			for ( INT i = 0; i < ARRAYSIZE( m_D3dShaders ); ++i )
			{
				// Remove the reference to this vertex declarations, shaders and pixel shaders if we have them 
				SAFE_RELEASE( m_D3dShaders[ i ].m_VertexDeclaration );
				SAFE_RELEASE( m_D3dShaders[ i ].m_VertexShader );
				SAFE_RELEASE( m_D3dShaders[ i ].m_PixelShader );
			}
		}
		VOID Render( XMMATRIX matWorld, XMMATRIX matView, XMMATRIX matProj );
		VOID Update( )
		{
			RebuildJoints();
		}
		VOID SetJoints( XAVATAR_SKELETON_POSE_JOINT joints[] )
		{
			for( DWORD i = 0; i < XAVATAR_MAX_SKELETON_JOINTS; i++ )
			{
				m_AvatarJointPose[i] = joints[i];
			}
		}

		XAVATAR_SKELETON* GetSkeleton(){ return m_pAssets->pSkeleton;}

	private:
		HRESULT         CreateAvatar( XAVATAR_METADATA& metaData );
		HRESULT         RebuildJoints( );

		WORD GetShaderTextureIndex( const XAVATAR_SHADER_PARAM& param, XAVATAR_SHADER shader ) const;
		VOID SetShaderTexturesAndConstants( DWORD                           dwModelIndex,
											const XAVATAR_SHADER_INSTANCE*  shaderInstance,
											const XAVATAR_TEXTURE*          modelTextures,
											const DWORD*                    animatedTextureLayers ) ;

		BYTE GetPixelConstantRegister(  const XAVATAR_SHADER_PARAM* param ) const;
		BYTE GetVertexConstantRegister( const XAVATAR_SHADER_PARAM* param,
										XAVATAR_SHADER              shader ) const;


		HRESULT PreRender(          const XMMATRIX*     modelTransform,
									const XMMATRIX*     viewTransform,
									const XMMATRIX*     projectionTransform );
		HRESULT RenderOpaque(       DWORD dwModelIndex, D3DVertexBuffer* pJointBuffer );
		HRESULT RenderTransparent(  DWORD dwModelIndex, D3DVertexBuffer* pJointBuffer );
		HRESULT PostRender( );

		HRESULT ClearShaderTexturesAndConstants( );

	private:
		// Raw avatar asset buffers.  These hold the data retrieved by XAvatarGetAssets()
		XAVATAR_ASSETS*             m_pAssets;            // asset buffer
		BYTE*                       m_pGpuBuffer;         // GPU buffer
		BYTE*                       m_pJointBuffer;

		// Shaders and vertex decls
		struct D3dShaders_t
		{
			D3DVertexDeclaration*   m_VertexDeclaration;
			D3DVertexShader*        m_VertexShader;
			D3DPixelShader*         m_PixelShader;
		};
		D3dShaders_t                m_D3dShaders[ XAVATAR_SHADER_COUNT ];

		// Lookup tables for converting shader parameters to GPU registers
		BYTE                        m_ShaderTextureIndexMap    [ XAVATAR_SHADER_PARAM_USAGE_COUNT ][ XAVATAR_SHADER_COUNT ];
		BYTE                        m_VertexConstantRegisterMap[ XAVATAR_SHADER_PARAM_USAGE_COUNT ][ XAVATAR_SHADER_COUNT ];
		BYTE                        m_PixelConstantRegisterMap [ XAVATAR_SHADER_PARAM_USAGE_COUNT ];

		// Vertex buffers, index buffers, and texture headers for each of the components
		D3DVertexBuffer             m_VertexBuffers[ XAVATAR_COMPONENT_COUNT ];
		D3DIndexBuffer              m_IndexBuffers [ XAVATAR_COMPONENT_COUNT ];
		D3DTexture                  m_Textures     [ XAVATAR_COMPONENT_COUNT ][ XAVATAR_MAX_TEXTURES_PER_MODEL ][ XAVATAR_MAX_LAYERS_PER_TEXTURE ];

		// Animation data - updated every frame from the animation assets
		XAVATAR_SKELETON_POSE_JOINT m_AvatarJointPose[ XAVATAR_MAX_SKELETON_JOINTS    ]; // animated pos/rot/scale for the cur frame
	    
		// Lights
		XMVECTOR                    m_vLightColor[3];
		XMVECTOR                    m_vLightDirection[3];

		// Texture animation data
		DWORD                       m_dwTextureLayers[ XAVATAR_ANIMATED_TEXTURE_COUNT ]; // animated texture IDs for the cur frame

		D3DVertexBuffer             m_JointBufferVBs[ JOINT_BUFFER_COUNT ];  // Joints ready to be consumed by GPU
		DWORD                       m_dwJointBufferIndex;                    // current joint buffer in use

		D3DDevice*                  m_pd3dDevice;
	    
	};

}; // namespace ATG
```

`XenonDumper/libs/Atg/AtgBound.cpp`:

```cpp
//-----------------------------------------------------------------------------
// AtgBound.cpp
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "AtgCollision.h"
#include "AtgBound.h"

namespace ATG
{

const EnumStringMap Bound::BoundType_StringMap[] =
{
    { Bound::No_Bound, L"NULL" },
    { Bound::Sphere_Bound, L"SPHERE" },
    { Bound::Frustum_Bound, L"FRUSTUM" },
    { Bound::OBB_Bound, L"OBB" },
    { Bound::AABB_Bound, L"AABB" },
    { 0, NULL },
};


//-----------------------------------------------------------------------------
// Name: Bound::operator*
// Desc: transforms the bound by the current matrix
//-----------------------------------------------------------------------------
Bound Bound::operator*( CXMMATRIX World ) const
{
    //$OPTIMIZE: store matrix decomposed    
    XMVECTOR Translation = World.r[3];
    FLOAT Scale = XMVectorGetX( XMVector3Length( World.r[2] ) );
    XMVECTOR Rotation = XMQuaternionNormalize( XMQuaternionRotationMatrix( World ) );

    // switch based off this bounds type and call the correct
    // bound transform function
    switch( m_Type )
    {
        case Bound::Sphere_Bound:
        {
            Sphere WorldSphere = GetSphere();
            TransformSphere( &WorldSphere,
                             &WorldSphere,
                             Scale,
                             Rotation,
                             Translation );
            return Bound( WorldSphere );
        }
        case Bound::Frustum_Bound:
        {
            Frustum WorldFrustum = GetFrustum();
            TransformFrustum( &WorldFrustum,
                              &WorldFrustum,
                              Scale,
                              Rotation,
                              Translation );
            return Bound( WorldFrustum );
        }
        case Bound::OBB_Bound:
        {
            OrientedBox WorldObb = GetObb();
            TransformOrientedBox( &WorldObb,
                                  &WorldObb,
                                  Scale,
                                  Rotation,
                                  Translation );
            return Bound( WorldObb );
        }
        case Bound::AABB_Bound:
        {
            AxisAlignedBox WorldAabb = GetAabb();
            TransformAxisAlignedBox( &WorldAabb,
                                     &WorldAabb,
                                     Scale,
                                     Rotation,
                                     Translation );
            return Bound( WorldAabb );
        }
        case Bound::No_Bound:
            return Bound();
    }

    return Bound();
}


//-----------------------------------------------------------------------------
// Name: Bound::Collide
// Desc: collides this bound with an obb
//-----------------------------------------------------------------------------
BOOL Bound::Collide( const OrientedBox& Obb ) const
{
    // switch on bound type and call the correct intersection function
    switch( m_Type )
    {
        case Bound::Sphere_Bound:
            return IntersectSphereOrientedBox( &GetSphere(), &Obb );
        case Bound::Frustum_Bound:
            return ( BOOL )IntersectOrientedBoxFrustum( &Obb, &GetFrustum() );
        case Bound::OBB_Bound:
            return IntersectOrientedBoxOrientedBox( &GetObb(), &Obb );
        case Bound::AABB_Bound:
            return IntersectAxisAlignedBoxOrientedBox( &GetAabb(), &Obb );
        case Bound::No_Bound:
            return TRUE;
    }

    return FALSE;
}


//-----------------------------------------------------------------------------
// Name: Bound::Collide
// Desc: collides this bound with a sphere
//-----------------------------------------------------------------------------
BOOL Bound::Collide( const Sphere& Sphere ) const
{
    switch( m_Type )
    {
        case Bound::Sphere_Bound:
            return IntersectSphereSphere( &GetSphere(), &Sphere );
        case Bound::Frustum_Bound:
            return ( BOOL )IntersectSphereFrustum( &Sphere, &GetFrustum() );
        case Bound::OBB_Bound:
            return IntersectSphereOrientedBox( &Sphere, &GetObb() );
        case Bound::AABB_Bound:
            return IntersectSphereAxisAlignedBox( &Sphere, &GetAabb() );
        case Bound::No_Bound:
            return TRUE;
    }

    return FALSE;
}


//-----------------------------------------------------------------------------
// Name: Bound::Collide
// Desc: collides this bound with an axis aligned box
//-----------------------------------------------------------------------------
BOOL Bound::Collide( const AxisAlignedBox& Aabb ) const
{
    switch( m_Type )
    {
        case Bound::Sphere_Bound:
            return IntersectSphereAxisAlignedBox( &GetSphere(), &Aabb );
        case Bound::Frustum_Bound:
            return ( BOOL )IntersectAxisAlignedBoxFrustum( &Aabb, &GetFrustum() );
        case Bound::OBB_Bound:
            return IntersectAxisAlignedBoxOrientedBox( &Aabb, &GetObb() );
        case Bound::AABB_Bound:
            return IntersectAxisAlignedBoxAxisAlignedBox( &GetAabb(), &Aabb );
        case Bound::No_Bound:
            return TRUE;
    }

    return FALSE;
}


//-----------------------------------------------------------------------------
// Name: Bound::Collide
// Desc: collides this bound with a frustum
//-----------------------------------------------------------------------------
BOOL Bound::Collide( const Frustum& Frustum ) const
{
    switch( m_Type )
    {
        case Bound::Sphere_Bound:
            return ( BOOL )IntersectSphereFrustum( &GetSphere(), &Frustum );
        case Bound::Frustum_Bound:
            return ( BOOL )IntersectFrustumFrustum( &GetFrustum(), &Frustum );
        case Bound::OBB_Bound:
            return ( BOOL )IntersectOrientedBoxFrustum( &GetObb(), &Frustum );
        case Bound::AABB_Bound:
            return ( BOOL )IntersectAxisAlignedBoxFrustum( &GetAabb(), &Frustum );
        case Bound::No_Bound:
            return TRUE;
    }

    return FALSE;
}


//-----------------------------------------------------------------------------
// Name: Bound::Collide
// Desc: collides this bound with another bound
//-----------------------------------------------------------------------------
BOOL Bound::Collide( const Bound& Other ) const
{
    switch( Other.m_Type )
    {
        case Bound::Sphere_Bound:
            return Collide( Other.GetSphere() );
        case Bound::Frustum_Bound:
            return Collide( Other.GetFrustum() );
        case Bound::OBB_Bound:
            return Collide( Other.GetObb() );
        case Bound::AABB_Bound:
            return Collide( Other.GetAabb() );
        case Bound::No_Bound:
            return TRUE;
    }

    return FALSE;
}


VOID Bound::Merge( const Bound& Other )
{
    Sphere OtherSphere;
    OtherSphere.Center = Other.GetCenter();
    OtherSphere.Radius = Other.GetMaxRadius();

    if( m_Type == Bound::No_Bound )
    {
        SetSphere( OtherSphere );
        return;
    }

    Sphere ThisSphere;
    if( m_Type != Bound::Sphere_Bound )
    {
        // convert this bound into a sphere
        ThisSphere.Center = GetCenter();
        ThisSphere.Radius = GetMaxRadius();
    }
    else
    {
        ThisSphere = GetSphere();
    }

    XMVECTOR vThisCenter = XMLoadFloat3( &ThisSphere.Center );
    XMVECTOR vOtherCenter = XMLoadFloat3( &OtherSphere.Center );
    XMVECTOR vThisToOther = XMVectorSubtract( vOtherCenter, vThisCenter );
    XMVECTOR vDistance = XMVector3LengthEst( vThisToOther );

    FLOAT fCombinedDiameter = XMVectorGetX( vDistance ) + ThisSphere.Radius + OtherSphere.Radius;
    if( fCombinedDiameter <= ( ThisSphere.Radius * 2 ) )
    {
        SetSphere( ThisSphere );
        return;
    }
    if( fCombinedDiameter <= ( OtherSphere.Radius * 2 ) )
    {
        SetSphere( OtherSphere );
        return;
    }

    XMVECTOR vDirectionNorm = XMVector3Normalize( vThisToOther );

    XMVECTOR vRadius = XMVectorSet( ThisSphere.Radius, OtherSphere.Radius, 0, 0 );
    XMVECTOR vThisRadius = XMVectorSplatX( vRadius );
    XMVECTOR vOtherRadius = XMVectorSplatY( vRadius );
    XMVECTOR vCombinedDiameter = vThisRadius + vDistance + vOtherRadius;
    XMVECTOR vMaxDiameter = XMVectorMax( vCombinedDiameter, vThisRadius * 2 );
    vMaxDiameter = XMVectorMax( vMaxDiameter, vOtherRadius * 2 );
    XMVECTOR vMaxRadius = vMaxDiameter * 0.5f;
    ThisSphere.Radius = XMVectorGetX( vMaxRadius );
    vMaxRadius -= vThisRadius;
    XMVECTOR vCombinedCenter = vThisCenter + vMaxRadius * vDirectionNorm;
    XMStoreFloat3( &ThisSphere.Center, vCombinedCenter );
    SetSphere( ThisSphere );
}


//-----------------------------------------------------------------------------
// Name: Bound::SetSphere
// Desc: sets this bound to a sphere
//-----------------------------------------------------------------------------
VOID Bound::SetSphere( const Sphere& Sphere )
{
    m_Type = Bound::Sphere_Bound;
    memcpy( m_Data, &Sphere, sizeof( Sphere ) );
}


//-----------------------------------------------------------------------------
// Name: Bound::GetSphere
// Desc: Gets the current bound as a sphere.
//-----------------------------------------------------------------------------
const Sphere& Bound::GetSphere() const
{
    assert( m_Type == Bound::Sphere_Bound );
    return *( Sphere* )m_Data;
}


//-----------------------------------------------------------------------------
// Name: Bound::SetAabb
// Desc: sets this bound to an axis aligned box
//-----------------------------------------------------------------------------
VOID Bound::SetAabb( const AxisAlignedBox& Aabb )
{
    m_Type = Bound::AABB_Bound;
    memcpy( m_Data, &Aabb, sizeof( Aabb ) );
}


//-----------------------------------------------------------------------------
// Name: Bound::GetAabb
// Desc: Gets the current bound as an axis aligned box.
//-----------------------------------------------------------------------------
const AxisAlignedBox& Bound::GetAabb() const
{
    assert( m_Type == Bound::AABB_Bound );
    return *( AxisAlignedBox* )m_Data;
}


//-----------------------------------------------------------------------------
// Name: Bound::SetObb
// Desc: sets this bound to an oriented box
//-----------------------------------------------------------------------------
VOID Bound::SetObb( const OrientedBox& Obb )
{
    m_Type = Bound::OBB_Bound;
    memcpy( m_Data, &Obb, sizeof( Obb ) );
}


//-----------------------------------------------------------------------------
// Name: Bound::GetObb
// Desc: Gets this bound as an oriented box
//-----------------------------------------------------------------------------
const OrientedBox& Bound::GetObb() const
{
    assert( m_Type == Bound::OBB_Bound );
    return *( OrientedBox* )m_Data;
}


//-----------------------------------------------------------------------------
// Name: Bound::SetFrustum
// Desc: sets this bound to a frustum
//-----------------------------------------------------------------------------
VOID Bound::SetFrustum( const Frustum& Frustum )
{
    m_Type = Bound::Frustum_Bound;
    memcpy( m_Data, &Frustum, sizeof( Frustum ) );
}


//-----------------------------------------------------------------------------
// Name: Bound::GetFrustum
// Desc: Gets this bound as a frustum
//-----------------------------------------------------------------------------
const Frustum& Bound::GetFrustum() const
{
    assert( m_Type == Bound::Frustum_Bound );
    return *( Frustum* )m_Data;
}


//-----------------------------------------------------------------------------
// Name: Bound::GetCenter
// Desc: Gets the center of the bound.
//-----------------------------------------------------------------------------
XMFLOAT3 Bound::GetCenter() const
{
    switch( m_Type )
    {
        case Bound::Sphere_Bound:
            return *( ( XMFLOAT3* )&GetSphere().Center );
        case Bound::Frustum_Bound:
            return *( ( XMFLOAT3* )&GetFrustum().Origin );
        case Bound::OBB_Bound:
            return *( ( XMFLOAT3* )&GetObb().Center );
        case Bound::AABB_Bound:
            return *( ( XMFLOAT3* )&GetAabb().Center );
        case Bound::No_Bound:
            break;
    }

    return XMFLOAT3( 0.0f, 0.0f, 0.0f );
}


//-----------------------------------------------------------------------------
// Name: Bound::GetMaxRadius
// Desc: Computes the maximum radius of the bound.
//-----------------------------------------------------------------------------
FLOAT Bound::GetMaxRadius() const
{
    switch( m_Type )
    {
        case Bound::Sphere_Bound:
        {
            float Radius = GetSphere().Radius;
            return Radius;
        }

        case Bound::Frustum_Bound:
        {
            FLOAT MaxZ = abs( GetFrustum().Far - GetFrustum().Near );
            FLOAT MaxX = abs( GetFrustum().LeftSlope * GetFrustum().Far - GetFrustum().RightSlope * GetFrustum().Far );
            FLOAT MaxY = abs( GetFrustum().TopSlope * GetFrustum().Far - GetFrustum().BottomSlope * GetFrustum().Far );
            return max( MaxZ, max( MaxX, MaxY ) );
        }

        case Bound::OBB_Bound:
        {
            XMVECTOR v = XMVector3Length( XMLoadFloat3( &( GetObb().Extents ) ) );
            return XMVectorGetX( v );
        }
        case Bound::AABB_Bound:
        {
            XMVECTOR v = XMVector3Length( XMLoadFloat3( &( GetAabb().Extents ) ) );
            return XMVectorGetX( v );
        }
        case Bound::No_Bound:
            break;
    }

    return 0.0f;
}

} // namespace ATG

```

`XenonDumper/libs/Atg/AtgBound.h`:

```h
//-----------------------------------------------------------------------------
// AtgBound.h
//
// A bound in a union of four basic bound types: frustum, AAbb, Obb, and
// sphere.  Bounds can be collided against one another.  
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef ATG_BOUND_H
#define ATG_BOUND_H

namespace ATG
{

struct AxisAlignedBox;
struct OrientedBox;
struct Frustum;
struct Sphere;

//-----------------------------------------------------------------------------
// Name: EnumStringMap
// Desc: Maps values to strings
//-----------------------------------------------------------------------------    
#ifndef ENUMSTRINGMAP_DEFINED
struct EnumStringMap
{
    DWORD Value;
    const WCHAR* szName;
};
#define ENUMSTRINGMAP_DEFINED
#endif

//$TODO: try to get the bounds in a union, once xboxmath.h has had empty
//       constructors removed
//-----------------------------------------------------------------------------
class Bound
{
public:
    enum BoundType
    {
        No_Bound,
        Sphere_Bound,
        Frustum_Bound,
        OBB_Bound,
        AABB_Bound,
        ForceDWORD = 0x7FFFFFFF
    };

    static const EnumStringMap  BoundType_StringMap[];

    // construct/destruct a bound
    Bound() { Clear(); }
    Bound( const Sphere& Sphere ) { SetSphere( Sphere ); }
    Bound( const Frustum& Frustum ){ SetFrustum( Frustum ); }
    Bound( const AxisAlignedBox& Aabb ){ SetAabb( Aabb ); }
    Bound( const OrientedBox& Obb ){ SetObb( Obb ); }
    Bound( const Bound& Other ){ *this = Other; }

    VOID Clear() { m_Type = Bound::No_Bound; }

    // collision with other primitives
    BOOL            Collide( const Bound& Other ) const;
    BOOL            Collide( const Frustum& Frustum ) const;
    BOOL            Collide( const Sphere& Sphere ) const;
    BOOL            Collide( const AxisAlignedBox& Aabb ) const;
    BOOL            Collide( const OrientedBox& pObb ) const;

    // merge with another bound
    VOID            Merge( const Bound& Other );

    // transformation
    Bound           operator*( CXMMATRIX Matrix ) const;

    // get-sets
    // Note that the get functions will assert if you try to
    // get a type not equal to the bounds current BoundType
    BoundType                   GetType() const { return m_Type; }
    const Sphere&           GetSphere() const;
    VOID                        SetSphere( const Sphere& Sphere );
    const Frustum&          GetFrustum() const;
    VOID                        SetFrustum( const Frustum& Frustum );
    const AxisAlignedBox&   GetAabb() const;
    VOID                        SetAabb( const AxisAlignedBox& Aabb );
    const OrientedBox&      GetObb() const;
    VOID                        SetObb( const OrientedBox& Obb );

    // gets the center of the bound. 
    XMFLOAT3       GetCenter() const;

    // gets the bound's maximum radius
    FLOAT          GetMaxRadius() const;

private:
    BoundType       m_Type;
    
    // Data must be big enough to hold the union of all the bound types.
    BYTE            m_Data[ sizeof( FLOAT ) * 13 ];

};

} // namespace ATG

#endif // ATG_BOUND_H

```

`XenonDumper/libs/Atg/AtgCamera.cpp`:

```cpp
//-----------------------------------------------------------------------------
// AtgCamera.cpp
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "AtgCollision.h"
#include "AtgCamera.h"

namespace ATG
{

CONST StringID Camera::TypeID( L"Camera" );
CONST EnumStringMap Projection::ProjectionType_StringMap[] =
{
    { Projection::Perspective, L"Perspective" },
    { Projection::Orthographic, L"Orthographic" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
// Name: Projection::GetFrustum
//-----------------------------------------------------------------------------
Frustum Projection::GetFrustum() CONST
{
    Frustum Temp;
    XMMATRIX Proj = GetMatrix();
    ComputeFrustumFromProjection( &Temp, &Proj );
    return Temp;
}


//-----------------------------------------------------------------------------
// Name: Projection::GetMatrix
//-----------------------------------------------------------------------------
XMMATRIX Projection::GetMatrix() CONST
{
    XMMATRIX Proj;
    if( m_Type == Projection::Perspective )
    {
        Proj = XMMatrixPerspectiveLH( m_Width, m_Height, m_ZNear, m_ZFar );
    }
    else if( m_Type == Projection::Orthographic )
    {
        Proj = XMMatrixOrthographicLH( m_Width, m_Height, m_ZNear, m_ZFar );
    }
    else
        assert( FALSE );

    return Proj;
}


//-----------------------------------------------------------------------------
// Name: Projection::SetFovXFovY
//-----------------------------------------------------------------------------
VOID Projection::SetFovXFovY( FLOAT FovX, FLOAT FovY, FLOAT ZNear, FLOAT ZFar )
{
    m_ZNear = ZNear;
    m_ZFar = ZFar;
    m_Type = Projection::Perspective;

    m_Width = ( 2.0f * m_ZNear ) * tanf( FovX / 2.0f );
    m_Height = ( 2.0f * m_ZNear ) * tanf( FovY / 2.0f );
}


//-----------------------------------------------------------------------------
// Name: Projection::SetFovYAspect
//-----------------------------------------------------------------------------
VOID Projection::SetFovYAspect( FLOAT FovY, FLOAT Aspect, FLOAT ZNear, FLOAT ZFar )
{
    m_ZNear = ZNear;
    m_ZFar = ZFar;
    m_Type = Projection::Perspective;


    m_Height = 2.0f * m_ZNear * tanf( FovY / 2 );
    m_Width = m_Height * Aspect;
}


//-----------------------------------------------------------------------------
// Name: Projection::SetFovXAspect
//-----------------------------------------------------------------------------
VOID Projection::SetFovXAspect( FLOAT FovX, FLOAT Aspect, FLOAT ZNear, FLOAT ZFar )
{
    m_ZNear = ZNear;
    m_ZFar = ZFar;
    m_Type = Projection::Perspective;


    m_Width = 2.0f * m_ZNear * tanf( FovX / 2 );
    m_Height = m_Width / Aspect;

}


//-----------------------------------------------------------------------------
// Name: Projection::SetOrthographic
//-----------------------------------------------------------------------------
VOID Projection::SetOrthographic( FLOAT Width, FLOAT Height, FLOAT ZNear, FLOAT ZFar )
{
    m_ZNear = ZNear;
    m_ZFar = ZFar;
    m_Type = Projection::Orthographic;
    m_Width = Width;
    m_Height = Height;
}


//-----------------------------------------------------------------------------
// Name: Projection::GetFovX
//-----------------------------------------------------------------------------
FLOAT Projection::GetFovX() CONST
{
    assert( m_Type == Projection::Perspective );
    return atanf( m_Width / ( 2.0f * m_ZNear ) ) * 2.0f;
}


//----------------------------------------------------------------------------
// Name: Projection::GetFovY
//-----------------------------------------------------------------------------
FLOAT Projection::GetFovY() CONST
{
    assert( m_Type == Projection::Perspective );
    return atanf( m_Height / ( 2.0f * m_ZNear ) ) * 2.0f;
}


//-----------------------------------------------------------------------------
// Name: Camera::UpdateBounds
//-----------------------------------------------------------------------------
VOID Camera::UpdateBound()
{
    SetLocalBound( Bound( m_Projection.GetFrustum() ) );
}

} // namespace ATG

```

`XenonDumper/libs/Atg/AtgCamera.h`:

```h
//-----------------------------------------------------------------------------
// AtgCamera.h
//
// describes a camera in the scene
//
// $OPTIMIZE: Pool Allocate
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef ATG_CAMERA_H
#define ATG_CAMERA_H

#include "AtgFrame.h"

namespace ATG
{

//-----------------------------------------------------------------------------
// Name: Projection
// Desc: simple projection class to handle various projection types.
//-----------------------------------------------------------------------------
class Projection
{
public:

    enum ProjectionType
    {
        Perspective,
        Orthographic,

        ForceDWORD = 0x7fffffff
    };      
    
    static CONST EnumStringMap ProjectionType_StringMap[];

    // set projection
    VOID            SetFovXFovY( FLOAT FovX, FLOAT FovY, FLOAT ZNear, FLOAT ZFar );
    VOID            SetFovYAspect( FLOAT FovY, FLOAT Aspect, FLOAT ZNear, FLOAT ZFar );
    VOID            SetFovXAspect( FLOAT FovX, FLOAT Aspect, FLOAT ZNear, FLOAT ZFar );
    VOID            SetOrthographic( FLOAT Width, FLOAT Height, FLOAT ZNear, FLOAT ZFar );

    // get projection data
    XMMATRIX            GetMatrix() CONST;
    Frustum             GetFrustum() CONST;
    FLOAT               GetFovX() CONST;
    FLOAT               GetFovY() CONST;
    ProjectionType      GetType() CONST { return m_Type; }
    FLOAT               GetZNear() CONST { return m_ZNear; }
    FLOAT               GetZFar() CONST { return m_ZFar; }
    FLOAT               GetWidth() CONST { return m_Width; }
    FLOAT               GetHeight() CONST { return m_Height; }

private:
    ProjectionType m_Type;
    FLOAT m_ZNear;
    FLOAT m_ZFar;
    FLOAT m_Width;
    FLOAT m_Height;
};

//-----------------------------------------------------------------------------
// Name: Camera
// Desc: basic camera class
//-----------------------------------------------------------------------------
class Camera : public Frame
{
    DEFINE_TYPE_INFO();
public:
    //  viewport
    VOID                SetViewport( CONST D3DVIEWPORT9& Viewport ) { m_Viewport = Viewport; }
    CONST D3DVIEWPORT9& GetViewport() CONST { return m_Viewport; }

    // view matrices
    XMMATRIX            GetLocalView() CONST { XMVECTOR pD; return XMMatrixInverse( &pD, GetLocalTransform() ); }
    XMMATRIX            GetWorldView() { XMVECTOR pD; return XMMatrixInverse( &pD, GetWorldTransform() ); }
    XMMATRIX            GetLocalInvView() CONST { return GetLocalTransform(); }
    XMMATRIX            GetWorldInvView() { return GetWorldTransform(); }

    // Focal length
    FLOAT               GetFocalLength() CONST { return m_fFocalLength; }
    VOID                SetFocalLength( FLOAT fFocalLength ) { m_fFocalLength = fFocalLength; }

    // Projection
    CONST Projection&   GetProjection() CONST { return m_Projection; }
    VOID                SetProjection( CONST Projection& Proj ) { m_Projection = Proj; UpdateBound(); }

    // Clear color
    DWORD               GetClearColor() CONST { return m_dwClearColor; }
    VOID                SetClearColor( DWORD ClearColor ) { m_dwClearColor = ClearColor; }

private:
    VOID UpdateBound();

    Projection m_Projection;
    FLOAT m_fFocalLength;
    D3DVIEWPORT9 m_Viewport;
    DWORD m_dwClearColor;
};

} // namespace ATG

#endif // ATG_CAMERA_H

```

`XenonDumper/libs/Atg/AtgCollision.cpp`:

```cpp
//-------------------------------------------------------------------------------------
// ATGCollision.cpp
//  
// An opimtized collision library based on XNAMath
//  
// Microsoft XNA Developer Connection
// Copyright (c) Microsoft Corporation. All rights reserved.
//-------------------------------------------------------------------------------------

#include "stdafx.h"
#include "AtgCollision.h"

namespace ATG
{

static const XMVECTOR g_UnitQuaternionEpsilon =
{
    1.0e-4f, 1.0e-4f, 1.0e-4f, 1.0e-4f
};
static const XMVECTOR g_UnitVectorEpsilon =
{
    1.0e-4f, 1.0e-4f, 1.0e-4f, 1.0e-4f
};
static const XMVECTOR g_UnitPlaneEpsilon =
{
    1.0e-4f, 1.0e-4f, 1.0e-4f, 1.0e-4f
};


//-----------------------------------------------------------------------------
// Return TRUE if any of the elements of a 3 vector are equal to 0xffffffff.
// Slightly more efficient than using XMVector3EqualInt.
//-----------------------------------------------------------------------------
static inline BOOL XMVector3AnyTrue( FXMVECTOR V )
{
    XMVECTOR C;

    // Duplicate the fourth element from the first element.
    C = XMVectorSwizzle( V, 0, 1, 2, 0 );

    return XMComparisonAnyTrue( XMVector4EqualIntR( C, XMVectorTrueInt() ) );
}



//-----------------------------------------------------------------------------
// Return TRUE if all of the elements of a 3 vector are equal to 0xffffffff.
// Slightly more efficient than using XMVector3EqualInt.
//-----------------------------------------------------------------------------
static inline BOOL XMVector3AllTrue( FXMVECTOR V )
{
    XMVECTOR C;

    // Duplicate the fourth element from the first element.
    C = XMVectorSwizzle( V, 0, 1, 2, 0 );

    return XMComparisonAllTrue( XMVector4EqualIntR( C, XMVectorTrueInt() ) );
}



//-----------------------------------------------------------------------------
// Return TRUE if the vector is a unit vector (length == 1).
//-----------------------------------------------------------------------------
static inline BOOL XMVector3IsUnit( FXMVECTOR V )
{
    XMVECTOR Difference = XMVector3Length( V ) - XMVectorSplatOne();

    return XMVector4Less( XMVectorAbs( Difference ), g_UnitVectorEpsilon );
}



//-----------------------------------------------------------------------------
// Return TRUE if the quaterion is a unit quaternion.
//-----------------------------------------------------------------------------
static inline BOOL XMQuaternionIsUnit( FXMVECTOR Q )
{
    XMVECTOR Difference = XMVector4Length( Q ) - XMVectorSplatOne();

    return XMVector4Less( XMVectorAbs( Difference ), g_UnitQuaternionEpsilon );
}



//-----------------------------------------------------------------------------
// Return TRUE if the plane is a unit plane.
//-----------------------------------------------------------------------------
static inline BOOL XMPlaneIsUnit( FXMVECTOR Plane )
{
    XMVECTOR Difference = XMVector3Length( Plane ) - XMVectorSplatOne();

    return XMVector4Less( XMVectorAbs( Difference ), g_UnitPlaneEpsilon );
}



//-----------------------------------------------------------------------------
// Transform a plane by a rotation and translation.
//-----------------------------------------------------------------------------
static inline XMVECTOR TransformPlane( FXMVECTOR Plane, FXMVECTOR Rotation, FXMVECTOR Translation )
{
    XMVECTOR Normal = XMVector3Rotate( Plane, Rotation );
    XMVECTOR D = XMVectorSplatW( Plane ) - XMVector3Dot( Normal, Translation );

    return XMVectorInsert( Normal, D, 0, 0, 0, 0, 1 );
}



//-----------------------------------------------------------------------------
// Return the point on the line segement (S1, S2) nearest the point P.
//-----------------------------------------------------------------------------
static inline XMVECTOR PointOnLineSegmentNearestPoint( FXMVECTOR S1, FXMVECTOR S2, FXMVECTOR P )
{
    XMVECTOR Dir = S2 - S1;
    XMVECTOR Projection = ( XMVector3Dot( P, Dir ) - XMVector3Dot( S1, Dir ) );
    XMVECTOR LengthSq = XMVector3Dot( Dir, Dir );

    XMVECTOR t = Projection * XMVectorReciprocal( LengthSq );
    XMVECTOR Point = S1 + t * Dir;

    // t < 0
    XMVECTOR SelectS1 = XMVectorLess( Projection, XMVectorZero() );
    Point = XMVectorSelect( Point, S1, SelectS1 );

    // t > 1
    XMVECTOR SelectS2 = XMVectorGreater( Projection, LengthSq );
    Point = XMVectorSelect( Point, S2, SelectS2 );

    return Point;
}



//-----------------------------------------------------------------------------
// Test if the point (P) on the plane of the triangle is inside the triangle 
// (V0, V1, V2).
//-----------------------------------------------------------------------------
static inline XMVECTOR PointOnPlaneInsideTriangle( FXMVECTOR P, FXMVECTOR V0, FXMVECTOR V1, CXMVECTOR V2 )
{
    // Compute the triangle normal.
    XMVECTOR N = XMVector3Cross( V2 - V0, V1 - V0 );

    // Compute the cross products of the vector from the base of each edge to 
    // the point with each edge vector.
    XMVECTOR C0 = XMVector3Cross( P - V0, V1 - V0 );
    XMVECTOR C1 = XMVector3Cross( P - V1, V2 - V1 );
    XMVECTOR C2 = XMVector3Cross( P - V2, V0 - V2 );

    // If the cross product points in the same direction as the normal the the
    // point is inside the edge (it is zero if is on the edge).
    XMVECTOR Zero = XMVectorZero();
    XMVECTOR Inside0 = XMVectorGreaterOrEqual( XMVector3Dot( C0, N ), Zero );
    XMVECTOR Inside1 = XMVectorGreaterOrEqual( XMVector3Dot( C1, N ), Zero );
    XMVECTOR Inside2 = XMVectorGreaterOrEqual( XMVector3Dot( C2, N ), Zero );

    // If the point inside all of the edges it is inside.
    return XMVectorAndInt( XMVectorAndInt( Inside0, Inside1 ), Inside2 );
}



//-----------------------------------------------------------------------------
// Find the approximate smallest enclosing bounding sphere for a set of 
// points. Exact computation of the smallest enclosing bounding sphere is 
// possible but is slower and requires a more complex algorithm.
// The algorithm is based on  Jack Ritter, "An Efficient Bounding Sphere", 
// Graphics Gems.
//-----------------------------------------------------------------------------
VOID ComputeBoundingSphereFromPoints( Sphere* pOut, UINT Count, const XMFLOAT3* pPoints, UINT Stride )
{
    XMASSERT( pOut );
    XMASSERT( Count > 0 );
    XMASSERT( pPoints );

    // Find the points with minimum and maximum x, y, and z
    XMVECTOR MinX, MaxX, MinY, MaxY, MinZ, MaxZ;

    MinX = MaxX = MinY = MaxY = MinZ = MaxZ = XMLoadFloat3( pPoints );

    for( UINT i = 1; i < Count; i++ )
    {
        XMVECTOR Point = XMLoadFloat3( ( XMFLOAT3* )( ( BYTE* )pPoints + i * Stride ) );

        float px = XMVectorGetX( Point );
        float py = XMVectorGetY( Point );
        float pz = XMVectorGetZ( Point );

        if( px < XMVectorGetX( MinX ) )
            MinX = Point;

        if( px > XMVectorGetX( MaxX ) )
            MaxX = Point;

        if( py < XMVectorGetY( MinY ) )
            MinY = Point;

        if( py > XMVectorGetY( MaxY ) )
            MaxY = Point;

        if( pz < XMVectorGetZ( MinZ ) )
            MinZ = Point;

        if( pz > XMVectorGetZ( MaxZ ) )
            MaxZ = Point;
    }

    // Use the min/max pair that are farthest apart to form the initial sphere.
    XMVECTOR DeltaX = MaxX - MinX;
    XMVECTOR DistX = XMVector3Length( DeltaX );

    XMVECTOR DeltaY = MaxY - MinY;
    XMVECTOR DistY = XMVector3Length( DeltaY );

    XMVECTOR DeltaZ = MaxZ - MinZ;
    XMVECTOR DistZ = XMVector3Length( DeltaZ );

    XMVECTOR Center;
    XMVECTOR Radius;

    if( XMVector3Greater( DistX, DistY ) )
    {
        if( XMVector3Greater( DistX, DistZ ) )
        {
            // Use min/max x.
            Center = ( MaxX + MinX ) * 0.5f;
            Radius = DistX * 0.5f;
        }
        else
        {
            // Use min/max z.
            Center = ( MaxZ + MinZ ) * 0.5f;
            Radius = DistZ * 0.5f;
        }
    }
    else // Y >= X
    {
        if( XMVector3Greater( DistY, DistZ ) )
        {
            // Use min/max y.
            Center = ( MaxY + MinY ) * 0.5f;
            Radius = DistY * 0.5f;
        }
        else
        {
            // Use min/max z.
            Center = ( MaxZ + MinZ ) * 0.5f;
            Radius = DistZ * 0.5f;
        }
    }

    // Add any points not inside the sphere.
    for( UINT i = 0; i < Count; i++ )
    {
        XMVECTOR Point = XMLoadFloat3( ( XMFLOAT3* )( ( BYTE* )pPoints + i * Stride ) );

        XMVECTOR Delta = Point - Center;

        XMVECTOR Dist = XMVector3Length( Delta );

        if( XMVector3Greater( Dist, Radius ) )
        {
            // Adjust sphere to include the new point.
            Radius = ( Radius + Dist ) * 0.5f;
            Center += ( XMVectorReplicate( 1.0f ) - Radius * XMVectorReciprocal( Dist ) ) * Delta;
        }
    }

    XMStoreFloat3( &pOut->Center, Center );
    XMStoreFloat( &pOut->Radius, Radius );

    return;
}



//-----------------------------------------------------------------------------
// Find the minimum axis aligned bounding box containing a set of points.
//-----------------------------------------------------------------------------
VOID ComputeBoundingAxisAlignedBoxFromPoints( AxisAlignedBox* pOut, UINT Count, const XMFLOAT3* pPoints, UINT Stride )
{
    XMASSERT( pOut );
    XMASSERT( Count > 0 );
    XMASSERT( pPoints );

    // Find the minimum and maximum x, y, and z
    XMVECTOR vMin, vMax;

    vMin = vMax = XMLoadFloat3( pPoints );

    for( UINT i = 1; i < Count; i++ )
    {
        XMVECTOR Point = XMLoadFloat3( ( XMFLOAT3* )( ( BYTE* )pPoints + i * Stride ) );

        vMin = XMVectorMin( vMin, Point );
        vMax = XMVectorMax( vMax, Point );
    }

    // Store center and extents.
    XMStoreFloat3( &pOut->Center, ( vMin + vMax ) * 0.5f );
    XMStoreFloat3( &pOut->Extents, ( vMax - vMin ) * 0.5f );

    return;
}



//-----------------------------------------------------------------------------
static inline BOOL SolveCubic( FLOAT e, FLOAT f, FLOAT g, FLOAT* t, FLOAT* u, FLOAT* v )
{
    FLOAT p, q, h, rc, d, theta, costh3, sinth3;

    p = f - e * e / 3.0f;
    q = g - e * f / 3.0f + e * e * e * 2.0f / 27.0f;
    h = q * q / 4.0f + p * p * p / 27.0f;

    if( h > 0.0 )
    {
        return FALSE; // only one real root
    }

    if( ( h == 0.0 ) && ( q == 0.0 ) ) // all the same root
    {
        *t = - e / 3;
        *u = - e / 3;
        *v = - e / 3;

        return TRUE;
    }

    d = sqrtf( q * q / 4.0f - h );
    if( d < 0 )
        rc = -powf( -d, 1.0f / 3.0f );
    else
        rc = powf( d, 1.0f / 3.0f );

    theta = acosf( -q / ( 2.0f * d ) );
    costh3 = cosf( theta / 3.0f );
    sinth3 = sqrtf( 3.0f ) * sinf( theta / 3.0f );
    *t = 2.0f * rc * costh3 - e / 3.0f;
    *u = -rc * ( costh3 + sinth3 ) - e / 3.0f;
    *v = -rc * ( costh3 - sinth3 ) - e / 3.0f;

    return TRUE;
}



//-----------------------------------------------------------------------------
static inline XMVECTOR CalculateEigenVector( FLOAT m11, FLOAT m12, FLOAT m13,
                                             FLOAT m22, FLOAT m23, FLOAT m33, FLOAT e )
{
    FLOAT f1, f2, f3;

    FLOAT fTmp[3];
    fTmp[0] = ( FLOAT )( m12 * m23 - m13 * ( m22 - e ) );
    fTmp[1] = ( FLOAT )( m13 * m12 - m23 * ( m11 - e ) );
    fTmp[2] = ( FLOAT )( ( m11 - e ) * ( m22 - e ) - m12 * m12 );

    XMVECTOR vTmp = XMLoadFloat3( (XMFLOAT3*)fTmp );

    if( XMVector3Equal( vTmp, XMVectorZero() ) ) // planar or linear
    {
        // we only have one equation - find a valid one
        if( ( m11 - e != 0.0 ) || ( m12 != 0.0 ) || ( m13 != 0.0 ) )
        {
            f1 = m11 - e; f2 = m12; f3 = m13;
        }
        else if( ( m12 != 0.0 ) || ( m22 - e != 0.0 ) || ( m23 != 0.0 ) )
        {
            f1 = m12; f2 = m22 - e; f3 = m23;
        }
        else if( ( m13 != 0.0 ) || ( m23 != 0.0 ) || ( m33 - e != 0.0 ) )
        {
            f1 = m13; f2 = m23; f3 = m33 - e;
        }
        else
        {
            // error, we'll just make something up - we have NO context
            f1 = 1.0; f2 = 0.0; f3 = 0.0;
        }

        if( f1 == 0.0 )
            vTmp = XMVectorSetX( vTmp, 0.0f );
        else
            vTmp = XMVectorSetX( vTmp, 1.0f );

        if( f2 == 0.0 )
            vTmp = XMVectorSetY( vTmp, 0.0f );
        else
            vTmp = XMVectorSetY( vTmp, 1.0f );

        if( f3 == 0.0 )
        {
            vTmp = XMVectorSetZ( vTmp, 0.0f );
            // recalculate y to make equation work
            if( m12 != 0.0 )
                vTmp = XMVectorSetY( vTmp, ( FLOAT )( -f1 / f2 ) );
        }
        else
        {
            vTmp = XMVectorSetZ( vTmp, ( FLOAT )( ( f2 - f1 ) / f3 ) );
        }
    }

    if( XMVectorGetX( XMVector3LengthSq( vTmp ) ) > 1e-5f )
    {
        return XMVector3Normalize( vTmp );
    }
    else
    {
        // Multiply by a value large enough to make the vector non-zero.
        vTmp *= 1e5f;
        return XMVector3Normalize( vTmp );
    }
}



//-----------------------------------------------------------------------------
static inline BOOL CalculateEigenVectors( FLOAT m11, FLOAT m12, FLOAT m13,
                                          FLOAT m22, FLOAT m23, FLOAT m33,
                                          FLOAT e1, FLOAT e2, FLOAT e3,
                                          XMVECTOR* pV1, XMVECTOR* pV2, XMVECTOR* pV3 )
{
    XMVECTOR vTmp, vUp, vRight;

    BOOL v1z, v2z, v3z, e12, e13, e23;

    vUp = XMVectorSetBinaryConstant( 0, 1, 0, 0 );
    vRight = XMVectorSetBinaryConstant( 1, 0, 0, 0 );

    *pV1 = CalculateEigenVector( m11, m12, m13, m22, m23, m33, e1 );
    *pV2 = CalculateEigenVector( m11, m12, m13, m22, m23, m33, e2 );
    *pV3 = CalculateEigenVector( m11, m12, m13, m22, m23, m33, e3 );

    v1z = v2z = v3z = FALSE;

    XMVECTOR Zero = XMVectorZero();

    if ( XMVector3Equal( *pV1, Zero ) )
        v1z = TRUE;

    if ( XMVector3Equal( *pV2, Zero ) )
        v2z = TRUE;

    if ( XMVector3Equal( *pV3, Zero ))
        v3z = TRUE;

    e12 = ( fabsf( XMVectorGetX( XMVector3Dot( *pV1, *pV2 ) ) ) > 0.1f ); // check for non-orthogonal vectors
    e13 = ( fabsf( XMVectorGetX( XMVector3Dot( *pV1, *pV3 ) ) ) > 0.1f );
    e23 = ( fabsf( XMVectorGetX( XMVector3Dot( *pV2, *pV3 ) ) ) > 0.1f );

    if( ( v1z && v2z && v3z ) || ( e12 && e13 && e23 ) ||
        ( e12 && v3z ) || ( e13 && v2z ) || ( e23 && v1z ) ) // all eigenvectors are 0- any basis set
    {
        *pV1 = XMVectorSetBinaryConstant( 1, 0, 0, 0 );
        *pV2 = XMVectorSetBinaryConstant( 0, 1, 0, 0 );
        *pV3 = XMVectorSetBinaryConstant( 0, 0, 1, 0 );
        return TRUE;
    }

    if( v1z && v2z )
    {
        vTmp = XMVector3Cross( vUp, *pV3 );
        if( XMVectorGetX( XMVector3LengthSq( vTmp ) ) < 1e-5f )
        {
            vTmp = XMVector3Cross( vRight, *pV3 );
        }
        *pV1 = XMVector3Normalize( vTmp );
        *pV2 = XMVector3Cross( *pV3, *pV1 );
        return TRUE;
    }

    if( v3z && v1z )
    {
        vTmp = XMVector3Cross( vUp, *pV2 );
        if( XMVectorGetX( XMVector3LengthSq( vTmp ) ) < 1e-5f )
        {
            vTmp = XMVector3Cross( vRight, *pV2 );
        }
        *pV3 = XMVector3Normalize( vTmp );
        *pV1 = XMVector3Cross( *pV2, *pV3 );
        return TRUE;
    }

    if( v2z && v3z )
    {
        vTmp = XMVector3Cross( vUp, *pV1 );
        if( XMVectorGetX( XMVector3LengthSq( vTmp ) ) < 1e-5f )
        {
            vTmp = XMVector3Cross( vRight, *pV1 );
        }
        *pV2 = XMVector3Normalize( vTmp );
        *pV3 = XMVector3Cross( *pV1, *pV2 );
        return TRUE;
    }

    if( ( v1z ) || e12 )
    {
        *pV1 = XMVector3Cross( *pV2, *pV3 );
        return TRUE;
    }

    if( ( v2z ) || e23 )
    {
        *pV2 = XMVector3Cross( *pV3, *pV1 );
        return TRUE;
    }

    if( ( v3z ) || e13 )
    {
        *pV3 = XMVector3Cross( *pV1, *pV2 );
        return TRUE;
    }

    return TRUE;
}



//-----------------------------------------------------------------------------
static inline BOOL CalculateEigenVectorsFromCovarianceMatrix( FLOAT Cxx, FLOAT Cyy, FLOAT Czz,
                                                              FLOAT Cxy, FLOAT Cxz, FLOAT Cyz,
                                                              XMVECTOR* pV1, XMVECTOR* pV2, XMVECTOR* pV3 )
{
    FLOAT e, f, g, ev1, ev2, ev3;

    // Calculate the eigenvalues by solving a cubic equation.
    e = -( Cxx + Cyy + Czz );
    f = Cxx * Cyy + Cyy * Czz + Czz * Cxx - Cxy * Cxy - Cxz * Cxz - Cyz * Cyz;
    g = Cxy * Cxy * Czz + Cxz * Cxz * Cyy + Cyz * Cyz * Cxx - Cxy * Cyz * Cxz * 2.0f - Cxx * Cyy * Czz;

    if( !SolveCubic( e, f, g, &ev1, &ev2, &ev3 ) )
    {
        // set them to arbitrary orthonormal basis set
        *pV1 = XMVectorSetBinaryConstant( 1, 0, 0, 0 );
        *pV2 = XMVectorSetBinaryConstant( 0, 1, 0, 0 );
        *pV3 = XMVectorSetBinaryConstant( 0, 0, 1, 0 );
        return FALSE;
    }

    return CalculateEigenVectors( Cxx, Cxy, Cxz, Cyy, Cyz, Czz, ev1, ev2, ev3, pV1, pV2, pV3 );
}



//-----------------------------------------------------------------------------
// Find the approximate minimum oriented bounding box containing a set of 
// points.  Exact computation of minimum oriented bounding box is possible but 
// is slower and requires a more complex algorithm.
// The algorithm works by computing the inertia tensor of the points and then
// using the eigenvectors of the intertia tensor as the axes of the box.
// Computing the intertia tensor of the convex hull of the points will usually 
// result in better bounding box but the computation is more complex. 
// Exact computation of the minimum oriented bounding box is possible but the
// best know algorithm is O(N^3) and is significanly more complex to implement.
//-----------------------------------------------------------------------------
VOID ComputeBoundingOrientedBoxFromPoints( OrientedBox* pOut, UINT Count, const XMFLOAT3* pPoints, UINT Stride )
{
    static CONST XMVECTORI32 PermuteXXY =
                 {
                    XM_PERMUTE_0X, XM_PERMUTE_0X, XM_PERMUTE_0Y, XM_PERMUTE_0W
                 };
    static CONST XMVECTORI32 PermuteYZZ =
                 {
                    XM_PERMUTE_0Y, XM_PERMUTE_0Z, XM_PERMUTE_0Z, XM_PERMUTE_0W
                 };

    XMASSERT( pOut );
    XMASSERT( Count > 0 );
    XMASSERT( pPoints );

    XMVECTOR CenterOfMass = XMVectorZero();

    // Compute the center of mass and inertia tensor of the points.
    for( UINT i = 0; i < Count; i++ )
    {
        XMVECTOR Point = XMLoadFloat3( ( XMFLOAT3* )( ( BYTE* )pPoints + i * Stride ) );

        CenterOfMass += Point;
    }

    CenterOfMass *= XMVectorReciprocal( XMVectorReplicate( FLOAT( Count ) ) );

    // Compute the inertia tensor of the points around the center of mass.
    // Using the center of mass is not strictly necessary, but will hopefully
    // improve the stability of finding the eigenvectors.
    XMVECTOR XX_YY_ZZ = XMVectorZero();
    XMVECTOR XY_XZ_YZ = XMVectorZero();

    for( UINT i = 0; i < Count; i++ )
    {
        XMVECTOR Point = XMLoadFloat3( ( XMFLOAT3* )( ( BYTE* )pPoints + i * Stride ) ) - CenterOfMass;

        XX_YY_ZZ += Point * Point;

        XMVECTOR XXY = XMVectorPermute( Point, Point, PermuteXXY );
        XMVECTOR YZZ = XMVectorPermute( Point, Point, PermuteYZZ );

        XY_XZ_YZ += XXY * YZZ;
    }

    XMVECTOR v1, v2, v3;

    // Compute the eigenvectors of the inertia tensor.
    CalculateEigenVectorsFromCovarianceMatrix( XMVectorGetX( XX_YY_ZZ ), XMVectorGetY( XX_YY_ZZ ),
                                               XMVectorGetZ( XX_YY_ZZ ),
                                               XMVectorGetX( XY_XZ_YZ ), XMVectorGetY( XY_XZ_YZ ),
                                               XMVectorGetZ( XY_XZ_YZ ),
                                               &v1, &v2, &v3 );

    // Put them in a matrix.
    XMMATRIX R;

    R.r[0] = XMVectorSetW( v1, 0.f );
    R.r[1] = XMVectorSetW( v2, 0.f );
    R.r[2] = XMVectorSetW( v3, 0.f );
    R.r[3] = XMVectorSetBinaryConstant( 0, 0, 0, 1 );

    // Multiply by -1 to convert the matrix into a right handed coordinate 
    // system (Det ~= 1) in case the eigenvectors form a left handed 
    // coordinate system (Det ~= -1) because XMQuaternionRotationMatrix only 
    // works on right handed matrices.
    XMVECTOR Det = XMMatrixDeterminant( R );

    if( XMVector4Less( Det, XMVectorZero() ) )
    {
        const XMVECTORF32 VectorNegativeOne =
        {
            -1.0f, -1.0f, -1.0f, -1.0f
        };

        R.r[0] *= VectorNegativeOne;
        R.r[1] *= VectorNegativeOne;
        R.r[2] *= VectorNegativeOne;
    }

    // Get the rotation quaternion from the matrix.
    XMVECTOR Orientation = XMQuaternionRotationMatrix( R );

    // Make sure it is normal (in case the vectors are slightly non-orthogonal).
    Orientation = XMQuaternionNormalize( Orientation );

    // Rebuild the rotation matrix from the quaternion.
    R = XMMatrixRotationQuaternion( Orientation );

    // Build the rotation into the rotated space.
    XMMATRIX InverseR = XMMatrixTranspose( R );

    // Find the minimum OBB using the eigenvectors as the axes.
    XMVECTOR vMin, vMax;

    vMin = vMax = XMVector3TransformNormal( XMLoadFloat3( pPoints ), InverseR );

    for( UINT i = 1; i < Count; i++ )
    {
        XMVECTOR Point = XMVector3TransformNormal( XMLoadFloat3( ( XMFLOAT3* )( ( BYTE* )pPoints + i * Stride ) ),
                                                   InverseR );

        vMin = XMVectorMin( vMin, Point );
        vMax = XMVectorMax( vMax, Point );
    }

    // Rotate the center into world space.
    XMVECTOR Center = ( vMin + vMax ) * 0.5f;
    Center = XMVector3TransformNormal( Center, R );

    // Store center, extents, and orientation.
    XMStoreFloat3( &pOut->Center, Center );
    XMStoreFloat3( &pOut->Extents, ( vMax - vMin ) * 0.5f );
    XMStoreFloat4( &pOut->Orientation, Orientation );

    return;
}



//-----------------------------------------------------------------------------
// Build a frustum from a persepective projection matrix.  The matrix may only
// contain a projection; any rotation, translation or scale will cause the
// constructed frustum to be incorrect.
//-----------------------------------------------------------------------------
VOID ComputeFrustumFromProjection( Frustum* pOut, XMMATRIX* pProjection )
{
    XMASSERT( pOut );
    XMASSERT( pProjection );

    // Corners of the projection frustum in homogenous space.
    static XMVECTOR HomogenousPoints[6] =
    {
        {  1.0f,  0.0f, 1.0f, 1.0f },   // right (at far plane)
        { -1.0f,  0.0f, 1.0f, 1.0f },   // left
        {  0.0f,  1.0f, 1.0f, 1.0f },   // top
        {  0.0f, -1.0f, 1.0f, 1.0f },   // bottom

        { 0.0f, 0.0f, 0.0f, 1.0f },     // near
        { 0.0f, 0.0f, 1.0f, 1.0f }      // far
    };

    XMVECTOR Determinant;
    XMMATRIX matInverse = XMMatrixInverse( &Determinant, *pProjection );

    // Compute the frustum corners in world space.
    XMVECTOR Points[6];

    for( INT i = 0; i < 6; i++ )
    {
        // Transform point.
        Points[i] = XMVector4Transform( HomogenousPoints[i], matInverse );
    }

    pOut->Origin = XMFLOAT3( 0.0f, 0.0f, 0.0f );
    pOut->Orientation = XMFLOAT4( 0.0f, 0.0f, 0.0f, 1.0f );

    // Compute the slopes.
    Points[0] = Points[0] * XMVectorReciprocal( XMVectorSplatZ( Points[0] ) );
    Points[1] = Points[1] * XMVectorReciprocal( XMVectorSplatZ( Points[1] ) );
    Points[2] = Points[2] * XMVectorReciprocal( XMVectorSplatZ( Points[2] ) );
    Points[3] = Points[3] * XMVectorReciprocal( XMVectorSplatZ( Points[3] ) );

    pOut->RightSlope = XMVectorGetX( Points[0] );
    pOut->LeftSlope = XMVectorGetX( Points[1] );
    pOut->TopSlope = XMVectorGetY( Points[2] );
    pOut->BottomSlope = XMVectorGetY( Points[3] );

    // Compute near and far.
    Points[4] = Points[4] * XMVectorReciprocal( XMVectorSplatW( Points[4] ) );
    Points[5] = Points[5] * XMVectorReciprocal( XMVectorSplatW( Points[5] ) );

    pOut->Near = XMVectorGetZ( Points[4] );
    pOut->Far = XMVectorGetZ( Points[5] );

    return;
}



//-----------------------------------------------------------------------------
// Build the 6 frustum planes from a frustum.
//-----------------------------------------------------------------------------
VOID ComputePlanesFromFrustum( const Frustum* pVolume, XMVECTOR* pPlane0, XMVECTOR* pPlane1, XMVECTOR* pPlane2,
                               XMVECTOR* pPlane3, XMVECTOR* pPlane4, XMVECTOR* pPlane5 )
{
    XMASSERT( pVolume );
    XMASSERT( pPlane0 );
    XMASSERT( pPlane1 );
    XMASSERT( pPlane2 );
    XMASSERT( pPlane3 );
    XMASSERT( pPlane4 );
    XMASSERT( pPlane5 );

    // Load origin and orientation of the frustum.
    XMVECTOR Origin = XMLoadFloat3( &pVolume->Origin );
    XMVECTOR Orientation = XMLoadFloat4( &pVolume->Orientation );

    // Build the frustum planes.
    XMVECTOR Plane0 = XMVectorSet( 0.0f, 0.0f, -1.0f, pVolume->Near );
    XMVECTOR Plane1 = XMVectorSet( 0.0f, 0.0f, 1.0f, -pVolume->Far );
    XMVECTOR Plane2 = XMVectorSet( 1.0f, 0.0f, -pVolume->RightSlope, 0.0f );
    XMVECTOR Plane3 = XMVectorSet( -1.0f, 0.0f, pVolume->LeftSlope, 0.0f );
    XMVECTOR Plane4 = XMVectorSet( 0.0f, 1.0f, -pVolume->TopSlope, 0.0f );
    XMVECTOR Plane5 = XMVectorSet( 0.0f, -1.0f, pVolume->BottomSlope, 0.0f );

    Plane0 = TransformPlane( Plane0, Orientation, Origin );
    Plane1 = TransformPlane( Plane1, Orientation, Origin );
    Plane2 = TransformPlane( Plane2, Orientation, Origin );
    Plane3 = TransformPlane( Plane3, Orientation, Origin );
    Plane4 = TransformPlane( Plane4, Orientation, Origin );
    Plane5 = TransformPlane( Plane5, Orientation, Origin );

    *pPlane0 = XMPlaneNormalize( Plane0 );
    *pPlane1 = XMPlaneNormalize( Plane1 );
    *pPlane2 = XMPlaneNormalize( Plane2 );
    *pPlane3 = XMPlaneNormalize( Plane3 );
    *pPlane4 = XMPlaneNormalize( Plane4 );
    *pPlane5 = XMPlaneNormalize( Plane5 );
}



//-----------------------------------------------------------------------------
// Transform a sphere by an angle preserving transform.
//-----------------------------------------------------------------------------
VOID TransformSphere( Sphere* pOut, const Sphere* pIn, FLOAT Scale, FXMVECTOR Rotation, FXMVECTOR Translation )
{
    XMASSERT( pOut );
    XMASSERT( pIn );
    XMASSERT( XMQuaternionIsUnit( Rotation ) );

    // Load the center of the sphere.
    XMVECTOR Center = XMLoadFloat3( &pIn->Center );

    // Transform the center of the sphere.
    Center = XMVector3Rotate( Center * XMVectorReplicate( Scale ), Rotation ) + Translation;

    // Store the center sphere.
    XMStoreFloat3( &pOut->Center, Center );

    // Scale the radius of the pshere.
    pOut->Radius = pIn->Radius * Scale;

    return;
}



//-----------------------------------------------------------------------------
// Transform an axis aligned box by an angle preserving transform.
//-----------------------------------------------------------------------------
VOID TransformAxisAlignedBox( AxisAlignedBox* pOut, const AxisAlignedBox* pIn, FLOAT Scale, FXMVECTOR Rotation,
                              FXMVECTOR Translation )
{
    XMASSERT( pOut );
    XMASSERT( pIn );
    XMASSERT( XMQuaternionIsUnit( Rotation ) );

    static XMVECTOR Offset[8] =
    {
        { -1.0f, -1.0f, -1.0f, 0.0f },
        { -1.0f, -1.0f,  1.0f, 0.0f },
        { -1.0f,  1.0f, -1.0f, 0.0f },
        { -1.0f,  1.0f,  1.0f, 0.0f },
        {  1.0f, -1.0f, -1.0f, 0.0f },
        {  1.0f, -1.0f,  1.0f, 0.0f },
        {  1.0f,  1.0f, -1.0f, 0.0f },
        {  1.0f,  1.0f,  1.0f, 0.0f }
    };

    // Load center and extents.
    XMVECTOR Center = XMLoadFloat3( &pIn->Center );
    XMVECTOR Extents = XMLoadFloat3( &pIn->Extents );

    XMVECTOR VectorScale = XMVectorReplicate( Scale );

    // Compute and transform the corners and find new min/max bounds.
    XMVECTOR Corner = Center + Extents * Offset[0];
    Corner = XMVector3Rotate( Corner * VectorScale, Rotation ) + Translation;

    XMVECTOR Min, Max;
    Min = Max = Corner;

    for( INT i = 1; i < 8; i++ )
    {
        Corner = Center + Extents * Offset[i];
        Corner = XMVector3Rotate( Corner * VectorScale, Rotation ) + Translation;

        Min = XMVectorMin( Min, Corner );
        Max = XMVectorMax( Max, Corner );
    }

    // Store center and extents.
    XMStoreFloat3( &pOut->Center, ( Min + Max ) * 0.5f );
    XMStoreFloat3( &pOut->Extents, ( Max - Min ) * 0.5f );

    return;
}



//-----------------------------------------------------------------------------
// Transform an oriented box by an angle preserving transform.
//-----------------------------------------------------------------------------
VOID TransformOrientedBox( OrientedBox* pOut, const OrientedBox* pIn, FLOAT Scale, FXMVECTOR Rotation,
                           FXMVECTOR Translation )
{
    XMASSERT( pOut );
    XMASSERT( pIn );
    XMASSERT( XMQuaternionIsUnit( Rotation ) );

    // Load the box.
    XMVECTOR Center = XMLoadFloat3( &pIn->Center );
    XMVECTOR Extents = XMLoadFloat3( &pIn->Extents );
    XMVECTOR Orientation = XMLoadFloat4( &pIn->Orientation );

    XMASSERT( XMQuaternionIsUnit( Orientation ) );

    // Composite the box rotation and the transform rotation.
    Orientation = XMQuaternionMultiply( Orientation, Rotation );

    // Transform the center.
    XMVECTOR VectorScale = XMVectorReplicate( Scale );
    Center = XMVector3Rotate( Center * VectorScale, Rotation ) + Translation;

    // Scale the box extents.
    Extents = Extents * VectorScale;

    // Store the box.
    XMStoreFloat3( &pOut->Center, Center );
    XMStoreFloat3( &pOut->Extents, Extents );
    XMStoreFloat4( &pOut->Orientation, Orientation );

    return;
}



//-----------------------------------------------------------------------------
// Transform a frustum by an angle preserving transform.
//-----------------------------------------------------------------------------
VOID TransformFrustum( Frustum* pOut, const Frustum* pIn, FLOAT Scale, FXMVECTOR Rotation, FXMVECTOR Translation )
{
    XMASSERT( pOut );
    XMASSERT( pIn );
    XMASSERT( XMQuaternionIsUnit( Rotation ) );

    // Load the frustum.
    XMVECTOR Origin = XMLoadFloat3( &pIn->Origin );
    XMVECTOR Orientation = XMLoadFloat4( &pIn->Orientation );

    XMASSERT( XMQuaternionIsUnit( Orientation ) );

    // Composite the frustum rotation and the transform rotation.
    Orientation = XMQuaternionMultiply( Orientation, Rotation );

    // Transform the origin.
    Origin = XMVector3Rotate( Origin * XMVectorReplicate( Scale ), Rotation ) + Translation;

    // Store the frustum.
    XMStoreFloat3( &pOut->Origin, Origin );
    XMStoreFloat4( &pOut->Orientation, Orientation );

    // Scale the near and far distances (the slopes remain the same).
    pOut->Near = pIn->Near * Scale;
    pOut->Far = pIn->Far * Scale;

    // Copy the slopes.
    pOut->RightSlope = pIn->RightSlope;
    pOut->LeftSlope = pIn->LeftSlope;
    pOut->TopSlope = pIn->TopSlope;
    pOut->BottomSlope = pIn->BottomSlope;

    return;
}



//-----------------------------------------------------------------------------
// Point in sphere test.
//-----------------------------------------------------------------------------
BOOL IntersectPointSphere( FXMVECTOR Point, const Sphere* pVolume )
{
    XMASSERT( pVolume );

    XMVECTOR Center = XMLoadFloat3( &pVolume->Center );
    XMVECTOR Radius = XMVectorReplicatePtr( &pVolume->Radius );

    XMVECTOR DistanceSquared = XMVector3LengthSq( Point - Center );
    XMVECTOR RadiusSquared = Radius * Radius;

    return XMVector4LessOrEqual( DistanceSquared, RadiusSquared );
}



//-----------------------------------------------------------------------------
// Point in axis aligned box test.
//-----------------------------------------------------------------------------
BOOL IntersectPointAxisAlignedBox( FXMVECTOR Point, const AxisAlignedBox* pVolume )
{
    XMASSERT( pVolume );

    XMVECTOR Center = XMLoadFloat3( &pVolume->Center );
    XMVECTOR Extents = XMLoadFloat3( &pVolume->Extents );

    return XMVector3InBounds( Point - Center, Extents );
}



//-----------------------------------------------------------------------------
// Point in oriented box test.
//-----------------------------------------------------------------------------
BOOL IntersectPointOrientedBox( FXMVECTOR Point, const OrientedBox* pVolume )
{
    XMASSERT( pVolume );

    XMVECTOR Center = XMLoadFloat3( &pVolume->Center );
    XMVECTOR Extents = XMLoadFloat3( &pVolume->Extents );
    XMVECTOR Orientation = XMLoadFloat4( &pVolume->Orientation );

    XMASSERT( XMQuaternionIsUnit( Orientation ) );

    // Transform the point to be local to the box.
    XMVECTOR TPoint = XMVector3InverseRotate( Point - Center, Orientation );

    return XMVector3InBounds( TPoint, Extents );
}



//-----------------------------------------------------------------------------
// Point in frustum test.
//-----------------------------------------------------------------------------
BOOL IntersectPointFrustum( FXMVECTOR Point, const Frustum* pVolume )
{
    static const XMVECTORU32 SelectW = {XM_SELECT_0, XM_SELECT_0, XM_SELECT_0, XM_SELECT_1};
    static const XMVECTORU32 SelectZ = {XM_SELECT_0, XM_SELECT_0, XM_SELECT_1, XM_SELECT_0};

    static const XMVECTOR BasePlanes[6] = 
    {
        {  0.0f,  0.0f, -1.0f, 0.0f },
        {  0.0f,  0.0f,  1.0f, 0.0f },
        {  1.0f,  0.0f,  0.0f, 0.0f },
        { -1.0f,  0.0f,  0.0f, 0.0f },
        {  0.0f,  1.0f,  0.0f, 0.0f },
        {  0.0f, -1.0f,  0.0f, 0.0f },
    };

    XMASSERT( pVolume );

    // Build frustum planes.
    XMVECTOR Planes[6];
    Planes[0] = XMVectorSelect( BasePlanes[0], XMVectorSplatX(  XMLoadFloat( &pVolume->Near ) ),
                                SelectW );
    Planes[1] = XMVectorSelect( BasePlanes[1], XMVectorSplatX( -XMLoadFloat( &pVolume->Far ) ),
                                SelectW );
    Planes[2] = XMVectorSelect( BasePlanes[2], XMVectorSplatX( -XMLoadFloat( &pVolume->RightSlope ) ),
                                SelectZ );
    Planes[3] = XMVectorSelect( BasePlanes[3], XMVectorSplatX(  XMLoadFloat( &pVolume->LeftSlope ) ),
                                SelectZ );
    Planes[4] = XMVectorSelect( BasePlanes[4], XMVectorSplatX( -XMLoadFloat( &pVolume->TopSlope ) ),
                                SelectZ );
    Planes[5] = XMVectorSelect( BasePlanes[5], XMVectorSplatX(  XMLoadFloat( &pVolume->BottomSlope ) ),
                                SelectZ );

    // Load origin and orientation.
    XMVECTOR Origin = XMLoadFloat3( &pVolume->Origin );
    XMVECTOR Orientation = XMLoadFloat4( &pVolume->Orientation );

    XMASSERT( XMQuaternionIsUnit( Orientation ) );

    // Transform point into local space of frustum.
    XMVECTOR TPoint = XMVector3InverseRotate( Point - Origin, Orientation );

    // Set w to one.
    TPoint = XMVectorInsert( TPoint, XMVectorSplatOne(), 0, 0, 0, 0, 1);

    XMVECTOR Zero = XMVectorZero();
    XMVECTOR Outside = Zero;

    // Test point against each plane of the frustum.
    for( INT i = 0; i < 6; i++ )
    {
        XMVECTOR Dot = XMVector4Dot( TPoint, Planes[i] );
        Outside = XMVectorOrInt( Outside, XMVectorGreater( Dot, Zero ) );
    }

    return XMVector4NotEqualInt( Outside, XMVectorTrueInt() );
}



//-----------------------------------------------------------------------------
// Compute the intersection of a ray (Origin, Direction) with a triangle 
// (V0, V1, V2).  Return TRUE if there is an intersection and also set *pDist 
// to the distance along the ray to the intersection.
// 
// The algorithm is based on Moller, Tomas and Trumbore, "Fast, Minimum Storage 
// Ray-Triangle Intersection", Journal of Graphics Tools, vol. 2, no. 1, 
// pp 21-28, 1997.
//-----------------------------------------------------------------------------
BOOL IntersectRayTriangle( FXMVECTOR Origin, FXMVECTOR Direction, FXMVECTOR V0, CXMVECTOR V1, CXMVECTOR V2,
                           FLOAT* pDist )
{
    XMASSERT( pDist );
    XMASSERT( XMVector3IsUnit( Direction ) );

    static const XMVECTOR Epsilon =
    {
        1e-20f, 1e-20f, 1e-20f, 1e-20f
    };

    XMVECTOR Zero = XMVectorZero();

    XMVECTOR e1 = V1 - V0;
    XMVECTOR e2 = V2 - V0;

    // p = Direction ^ e2;
    XMVECTOR p = XMVector3Cross( Direction, e2 );

    // det = e1 * p;
    XMVECTOR det = XMVector3Dot( e1, p );

    XMVECTOR u, v, t;

    if( XMVector3GreaterOrEqual( det, Epsilon ) )
    {
        // Determinate is positive (front side of the triangle).
        XMVECTOR s = Origin - V0;

        // u = s * p;
        u = XMVector3Dot( s, p );

        XMVECTOR NoIntersection = XMVectorLess( u, Zero );
        NoIntersection = XMVectorOrInt( NoIntersection, XMVectorGreater( u, det ) );

        // q = s ^ e1;
        XMVECTOR q = XMVector3Cross( s, e1 );

        // v = Direction * q;
        v = XMVector3Dot( Direction, q );

        NoIntersection = XMVectorOrInt( NoIntersection, XMVectorLess( v, Zero ) );
        NoIntersection = XMVectorOrInt( NoIntersection, XMVectorGreater( u + v, det ) );

        // t = e2 * q;
        t = XMVector3Dot( e2, q );

        NoIntersection = XMVectorOrInt( NoIntersection, XMVectorLess( t, Zero ) );

        if( XMVector4EqualInt( NoIntersection, XMVectorTrueInt() ) )
            return FALSE;
    }
    else if( XMVector3LessOrEqual( det, -Epsilon ) )
    {
        // Determinate is negative (back side of the triangle).
        XMVECTOR s = Origin - V0;

        // u = s * p;
        u = XMVector3Dot( s, p );

        XMVECTOR NoIntersection = XMVectorGreater( u, Zero );
        NoIntersection = XMVectorOrInt( NoIntersection, XMVectorLess( u, det ) );

        // q = s ^ e1;
        XMVECTOR q = XMVector3Cross( s, e1 );

        // v = Direction * q;
        v = XMVector3Dot( Direction, q );

        NoIntersection = XMVectorOrInt( NoIntersection, XMVectorGreater( v, Zero ) );
        NoIntersection = XMVectorOrInt( NoIntersection, XMVectorLess( u + v, det ) );

        // t = e2 * q;
        t = XMVector3Dot( e2, q );

        NoIntersection = XMVectorOrInt( NoIntersection, XMVectorGreater( t, Zero ) );

        if ( XMVector4EqualInt( NoIntersection, XMVectorTrueInt() ) )
            return FALSE;
    }
    else
    {
        // Parallel ray.
        return FALSE;
    }

    XMVECTOR inv_det = XMVectorReciprocal( det );

    t *= inv_det;

    // u * inv_det and v * inv_det are the barycentric cooridinates of the intersection.

    // Store the x-component to *pDist
    XMStoreFloat( pDist, t );

    return TRUE;
}



//-----------------------------------------------------------------------------
// Compute the intersection of a ray (Origin, Direction) with a sphere.
//-----------------------------------------------------------------------------
BOOL IntersectRaySphere( FXMVECTOR Origin, FXMVECTOR Direction, const Sphere* pVolume, FLOAT* pDist )
{
    XMASSERT( pVolume );
    XMASSERT( pDist );
    XMASSERT( XMVector3IsUnit( Direction ) );

    XMVECTOR Center = XMLoadFloat3( &pVolume->Center );
    XMVECTOR Radius = XMVectorReplicatePtr( &pVolume->Radius );

    // l is the vector from the ray origin to the center of the sphere.
    XMVECTOR l = Center - Origin;

    // s is the projection of the l onto the ray direction.
    XMVECTOR s = XMVector3Dot( l, Direction );

    XMVECTOR l2 = XMVector3Dot( l, l );

    XMVECTOR r2 = Radius * Radius;

    // m2 is squared distance from the center of the sphere to the projection.
    XMVECTOR m2 = l2 - s * s;

    XMVECTOR NoIntersection;

    // If the ray origin is outside the sphere and the center of the sphere is 
    // behind the ray origin there is no intersection.
    NoIntersection = XMVectorAndInt( XMVectorLess( s, XMVectorZero() ), XMVectorGreater( l2, r2 ) );

    // If the squared distance from the center of the sphere to the projection
    // is greater than the radius squared the ray will miss the sphere.
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorGreater( m2, r2 ) );

    // The ray hits the sphere, compute the nearest intersection point.
    XMVECTOR q = XMVectorSqrt( r2 - m2 );
    XMVECTOR t1 = s - q;
    XMVECTOR t2 = s + q;

    XMVECTOR OriginInside = XMVectorLessOrEqual( l2, r2 );
    XMVECTOR t = XMVectorSelect( t1, t2, OriginInside );

    if( XMVector4NotEqualInt( NoIntersection, XMVectorTrueInt() ) )
    {
        // Store the x-component to *pDist.
        XMStoreFloat( pDist, t );
        return TRUE;
    }

    return FALSE;
}



//-----------------------------------------------------------------------------
// Compute the intersection of a ray (Origin, Direction) with an axis aligned 
// box using the slabs method.
//-----------------------------------------------------------------------------
BOOL IntersectRayAxisAlignedBox( FXMVECTOR Origin, FXMVECTOR Direction, const AxisAlignedBox* pVolume, FLOAT* pDist )
{
    XMASSERT( pVolume );
    XMASSERT( pDist );
    XMASSERT( XMVector3IsUnit( Direction ) );

    static const XMVECTOR Epsilon =
    {
        1e-20f, 1e-20f, 1e-20f, 1e-20f
    };
    static const XMVECTOR FltMin =
    {
        -FLT_MAX, -FLT_MAX, -FLT_MAX, -FLT_MAX
    };
    static const XMVECTOR FltMax =
    {
        FLT_MAX, FLT_MAX, FLT_MAX, FLT_MAX
    };

    // Load the box.
    XMVECTOR Center = XMLoadFloat3( &pVolume->Center );
    XMVECTOR Extents = XMLoadFloat3( &pVolume->Extents );

    // Adjust ray origin to be relative to center of the box.
    XMVECTOR TOrigin = Center - Origin;

    // Compute the dot product againt each axis of the box.
    // Since the axii are (1,0,0), (0,1,0), (0,0,1) no computation is necessary.
    XMVECTOR AxisDotOrigin = TOrigin;
    XMVECTOR AxisDotDirection = Direction;

    // if (fabs(AxisDotDirection) <= Epsilon) the ray is nearly parallel to the slab.
    XMVECTOR IsParallel = XMVectorLessOrEqual( XMVectorAbs( AxisDotDirection ), Epsilon );

    // Test against all three axii simultaneously.
    XMVECTOR InverseAxisDotDirection = XMVectorReciprocal( AxisDotDirection );
    XMVECTOR t1 = ( AxisDotOrigin - Extents ) * InverseAxisDotDirection;
    XMVECTOR t2 = ( AxisDotOrigin + Extents ) * InverseAxisDotDirection;

    // Compute the max of min(t1,t2) and the min of max(t1,t2) ensuring we don't
    // use the results from any directions parallel to the slab.
    XMVECTOR t_min = XMVectorSelect( XMVectorMin( t1, t2 ), FltMin, IsParallel );
    XMVECTOR t_max = XMVectorSelect( XMVectorMax( t1, t2 ), FltMax, IsParallel );

    // t_min.x = maximum( t_min.x, t_min.y, t_min.z );
    // t_max.x = minimum( t_max.x, t_max.y, t_max.z );
    t_min = XMVectorMax( t_min, XMVectorSplatY( t_min ) );  // x = max(x,y)
    t_min = XMVectorMax( t_min, XMVectorSplatZ( t_min ) );  // x = max(max(x,y),z)
    t_max = XMVectorMin( t_max, XMVectorSplatY( t_max ) );  // x = min(x,y)
    t_max = XMVectorMin( t_max, XMVectorSplatZ( t_max ) );  // x = min(min(x,y),z)

    // if ( t_min > t_max ) return FALSE;
    XMVECTOR NoIntersection = XMVectorGreater( XMVectorSplatX( t_min ), XMVectorSplatX( t_max ) );

    // if ( t_max < 0.0f ) return FALSE;
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorLess( XMVectorSplatX( t_max ), XMVectorZero() ) );

    // if (IsParallel && (-Extents > AxisDotOrigin || Extents < AxisDotOrigin)) return FALSE;
    XMVECTOR ParallelOverlap = XMVectorInBounds( AxisDotOrigin, Extents );
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorAndCInt( IsParallel, ParallelOverlap ) );

    if( !XMVector3AnyTrue( NoIntersection ) )
    {
        // Store the x-component to *pDist
        XMStoreFloat( pDist, t_min );
        return TRUE;
    }

    return FALSE;
}



//-----------------------------------------------------------------------------
// Compute the intersection of a ray (Origin, Direction) with an oriented box
// using the slabs method.
//-----------------------------------------------------------------------------
BOOL IntersectRayOrientedBox( FXMVECTOR Origin, FXMVECTOR Direction, const OrientedBox* pVolume, FLOAT* pDist )
{
    XMASSERT( pVolume );
    XMASSERT( pDist );
    XMASSERT( XMVector3IsUnit( Direction ) );

    static const XMVECTOR Epsilon =
    {
        1e-20f, 1e-20f, 1e-20f, 1e-20f
    };
    static const XMVECTOR FltMin =
    {
        -FLT_MAX, -FLT_MAX, -FLT_MAX, -FLT_MAX
    };
    static const XMVECTOR FltMax =
    {
        FLT_MAX, FLT_MAX, FLT_MAX, FLT_MAX
    };
    static const XMVECTORI32 SelectY =
    {
        XM_SELECT_0, XM_SELECT_1, XM_SELECT_0, XM_SELECT_0
    };
    static const XMVECTORI32 SelectZ =
    {
        XM_SELECT_0, XM_SELECT_0, XM_SELECT_1, XM_SELECT_0
    };

    // Load the box.
    XMVECTOR Center = XMLoadFloat3( &pVolume->Center );
    XMVECTOR Extents = XMLoadFloat3( &pVolume->Extents );
    XMVECTOR Orientation = XMLoadFloat4( &pVolume->Orientation );

    XMASSERT( XMQuaternionIsUnit( Orientation ) );

    // Get the boxes normalized side directions.
    XMMATRIX R = XMMatrixRotationQuaternion( Orientation );

    // Adjust ray origin to be relative to center of the box.
    XMVECTOR TOrigin = Center - Origin;

    // Compute the dot product againt each axis of the box.
    XMVECTOR AxisDotOrigin = XMVector3Dot( R.r[0], TOrigin );
    AxisDotOrigin = XMVectorSelect( AxisDotOrigin, XMVector3Dot( R.r[1], TOrigin ), SelectY );
    AxisDotOrigin = XMVectorSelect( AxisDotOrigin, XMVector3Dot( R.r[2], TOrigin ), SelectZ );

    XMVECTOR AxisDotDirection = XMVector3Dot( R.r[0], Direction );
    AxisDotDirection = XMVectorSelect( AxisDotDirection, XMVector3Dot( R.r[1], Direction ), SelectY );
    AxisDotDirection = XMVectorSelect( AxisDotDirection, XMVector3Dot( R.r[2], Direction ), SelectZ );

    // if (fabs(AxisDotDirection) <= Epsilon) the ray is nearly parallel to the slab.
    XMVECTOR IsParallel = XMVectorLessOrEqual( XMVectorAbs( AxisDotDirection ), Epsilon );

    // Test against all three axes simultaneously.
    XMVECTOR InverseAxisDotDirection = XMVectorReciprocal( AxisDotDirection );
    XMVECTOR t1 = ( AxisDotOrigin - Extents ) * InverseAxisDotDirection;
    XMVECTOR t2 = ( AxisDotOrigin + Extents ) * InverseAxisDotDirection;

    // Compute the max of min(t1,t2) and the min of max(t1,t2) ensuring we don't
    // use the results from any directions parallel to the slab.
    XMVECTOR t_min = XMVectorSelect( XMVectorMin( t1, t2 ), FltMin, IsParallel );
    XMVECTOR t_max = XMVectorSelect( XMVectorMax( t1, t2 ), FltMax, IsParallel );

    // t_min.x = maximum( t_min.x, t_min.y, t_min.z );
    // t_max.x = minimum( t_max.x, t_max.y, t_max.z );
    t_min = XMVectorMax( t_min, XMVectorSplatY( t_min ) );  // x = max(x,y)
    t_min = XMVectorMax( t_min, XMVectorSplatZ( t_min ) );  // x = max(max(x,y),z)
    t_max = XMVectorMin( t_max, XMVectorSplatY( t_max ) );  // x = min(x,y)
    t_max = XMVectorMin( t_max, XMVectorSplatZ( t_max ) );  // x = min(min(x,y),z)

    // if ( t_min > t_max ) return FALSE;
    XMVECTOR NoIntersection = XMVectorGreater( XMVectorSplatX( t_min ), XMVectorSplatX( t_max ) );

    // if ( t_max < 0.0f ) return FALSE;
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorLess( XMVectorSplatX( t_max ), XMVectorZero() ) );

    // if (IsParallel && (-Extents > AxisDotOrigin || Extents < AxisDotOrigin)) return FALSE;
    XMVECTOR ParallelOverlap = XMVectorInBounds( AxisDotOrigin, Extents );
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorAndCInt( IsParallel, ParallelOverlap ) );

    if( !XMVector3AnyTrue( NoIntersection ) )
    {
        // Store the x-component to *pDist
        XMStoreFloat( pDist, t_min );
        return TRUE;
    }

    return FALSE;
}



//-----------------------------------------------------------------------------
// Test if two triangles intersect.
//
// The final test of algorithm is based on Shen, Heng, and Tang, "A Fast 
// Triangle-Triangle Overlap Test Using Signed Distances", Journal of Graphics 
// Tools, vol. 8, no. 1, pp 17-23, 2003 and Guigue and Devillers, "Fast and 
// Robust Triangle-Triangle Overlap Test Using Orientation Predicates", Journal 
// of Graphics Tools, vol. 8, no. 1, pp 25-32, 2003.
//
// The final test could be considered an edge-edge separating plane test with
// the 9 possible cases narrowed down to the only two pairs of edges that can 
// actaully result in a seperation.
//-----------------------------------------------------------------------------
BOOL IntersectTriangleTriangle( FXMVECTOR A0, FXMVECTOR A1, FXMVECTOR A2, CXMVECTOR B0, CXMVECTOR B1, CXMVECTOR B2 )
{
    static const XMVECTOR Epsilon =
    {
        1e-20f, 1e-20f, 1e-20f, 1e-20f
    };
    static const XMVECTORI32 SelectY =
    {
        XM_SELECT_0, XM_SELECT_1, XM_SELECT_0, XM_SELECT_0
    };
    static const XMVECTORI32 SelectZ =
    {
        XM_SELECT_0, XM_SELECT_0, XM_SELECT_1, XM_SELECT_0
    };
    static const XMVECTORI32 Select0111 =
    {
        XM_SELECT_0, XM_SELECT_1, XM_SELECT_1, XM_SELECT_1
    };
    static const XMVECTORI32 Select1011 =
    {
        XM_SELECT_1, XM_SELECT_0, XM_SELECT_1, XM_SELECT_1
    };
    static const XMVECTORI32 Select1101 =
    {
        XM_SELECT_1, XM_SELECT_1, XM_SELECT_0, XM_SELECT_1
    };

    XMVECTOR Zero = XMVectorZero();

    // Compute the normal of triangle A.
    XMVECTOR N1 = XMVector3Cross( A1 - A0, A2 - A0 );

    // Assert that the triangle is not degenerate.
    XMASSERT( !XMVector3Equal( N1, Zero ) );

    // Test points of B against the plane of A.
    XMVECTOR BDist = XMVector3Dot( N1, B0 - A0 );
    BDist = XMVectorSelect( BDist, XMVector3Dot( N1, B1 - A0 ), SelectY );
    BDist = XMVectorSelect( BDist, XMVector3Dot( N1, B2 - A0 ), SelectZ );

    // Ensure robustness with co-planar triangles by zeroing small distances.
    UINT BDistIsZeroCR;
    XMVECTOR BDistIsZero = XMVectorGreaterR( &BDistIsZeroCR, Epsilon, XMVectorAbs( BDist ) );
    BDist = XMVectorSelect( BDist, Zero, BDistIsZero );

    UINT BDistIsLessCR;
    XMVECTOR BDistIsLess = XMVectorGreaterR( &BDistIsLessCR, Zero, BDist );

    UINT BDistIsGreaterCR;
    XMVECTOR BDistIsGreater = XMVectorGreaterR( &BDistIsGreaterCR, BDist, Zero );

    // If all the points are on the same side we don't intersect.
    if( XMComparisonAllTrue( BDistIsLessCR ) || XMComparisonAllTrue( BDistIsGreaterCR ) )
        return FALSE;

    // Compute the normal of triangle B.
    XMVECTOR N2 = XMVector3Cross( B1 - B0, B2 - B0 );

    // Assert that the triangle is not degenerate.
    XMASSERT( !XMVector3Equal( N2, Zero ) );

    // Test points of A against the plane of B.
    XMVECTOR ADist = XMVector3Dot( N2, A0 - B0 );
    ADist = XMVectorSelect( ADist, XMVector3Dot( N2, A1 - B0 ), SelectY );
    ADist = XMVectorSelect( ADist, XMVector3Dot( N2, A2 - B0 ), SelectZ );

    // Ensure robustness with co-planar triangles by zeroing small distances.
    UINT ADistIsZeroCR;
    XMVECTOR ADistIsZero = XMVectorGreaterR( &ADistIsZeroCR, Epsilon, XMVectorAbs( ADist ) );
    ADist = XMVectorSelect( ADist, Zero, ADistIsZero );

    UINT ADistIsLessCR;
    XMVECTOR ADistIsLess = XMVectorGreaterR( &ADistIsLessCR, Zero, ADist );

    UINT ADistIsGreaterCR;
    XMVECTOR ADistIsGreater = XMVectorGreaterR( &ADistIsGreaterCR, ADist, Zero );

    // If all the points are on the same side we don't intersect.
    if( XMComparisonAllTrue( ADistIsLessCR ) || XMComparisonAllTrue( ADistIsGreaterCR ) )
        return FALSE;

    // Special case for co-planar triangles.
    if( XMComparisonAllTrue( ADistIsZeroCR ) || XMComparisonAllTrue( BDistIsZeroCR ) )
    {
        XMVECTOR Axis, Dist, MinDist;

        // Compute an axis perpindicular to the edge (points out).
        Axis = XMVector3Cross( N1, A1 - A0 );
        Dist = XMVector3Dot( Axis, A0 );

        // Test points of B against the axis.
        MinDist = XMVector3Dot( B0, Axis );
        MinDist = XMVectorMin( MinDist, XMVector3Dot( B1, Axis ) );
        MinDist = XMVectorMin( MinDist, XMVector3Dot( B2, Axis ) );
        if( XMVector4GreaterOrEqual( MinDist, Dist ) )
            return FALSE;

        // Edge (A1, A2)
        Axis = XMVector3Cross( N1, A2 - A1 );
        Dist = XMVector3Dot( Axis, A1 );

        MinDist = XMVector3Dot( B0, Axis );
        MinDist = XMVectorMin( MinDist, XMVector3Dot( B1, Axis ) );
        MinDist = XMVectorMin( MinDist, XMVector3Dot( B2, Axis ) );
        if( XMVector4GreaterOrEqual( MinDist, Dist ) )
            return FALSE;

        // Edge (A2, A0)
        Axis = XMVector3Cross( N1, A0 - A2 );
        Dist = XMVector3Dot( Axis, A2 );

        MinDist = XMVector3Dot( B0, Axis );
        MinDist = XMVectorMin( MinDist, XMVector3Dot( B1, Axis ) );
        MinDist = XMVectorMin( MinDist, XMVector3Dot( B2, Axis ) );
        if( XMVector4GreaterOrEqual( MinDist, Dist ) )
            return FALSE;

        // Edge (B0, B1)
        Axis = XMVector3Cross( N2, B1 - B0 );
        Dist = XMVector3Dot( Axis, B0 );

        MinDist = XMVector3Dot( A0, Axis );
        MinDist = XMVectorMin( MinDist, XMVector3Dot( A1, Axis ) );
        MinDist = XMVectorMin( MinDist, XMVector3Dot( A2, Axis ) );
        if( XMVector4GreaterOrEqual( MinDist, Dist ) )
            return FALSE;

        // Edge (B1, B2)
        Axis = XMVector3Cross( N2, B2 - B1 );
        Dist = XMVector3Dot( Axis, B1 );

        MinDist = XMVector3Dot( A0, Axis );
        MinDist = XMVectorMin( MinDist, XMVector3Dot( A1, Axis ) );
        MinDist = XMVectorMin( MinDist, XMVector3Dot( A2, Axis ) );
        if( XMVector4GreaterOrEqual( MinDist, Dist ) )
            return FALSE;

        // Edge (B2,B0)
        Axis = XMVector3Cross( N2, B0 - B2 );
        Dist = XMVector3Dot( Axis, B2 );

        MinDist = XMVector3Dot( A0, Axis );
        MinDist = XMVectorMin( MinDist, XMVector3Dot( A1, Axis ) );
        MinDist = XMVectorMin( MinDist, XMVector3Dot( A2, Axis ) );
        if( XMVector4GreaterOrEqual( MinDist, Dist ) )
            return FALSE;

        return TRUE;
    }

    //
    // Find the single vertex of A and B (ie the vertex on the opposite side
    // of the plane from the other two) and reorder the edges so we can compute 
    // the signed edge/edge distances.
    //
    // if ( (V0 >= 0 && V1 <  0 && V2 <  0) ||
    //      (V0 >  0 && V1 <= 0 && V2 <= 0) ||
    //      (V0 <= 0 && V1 >  0 && V2 >  0) ||
    //      (V0 <  0 && V1 >= 0 && V2 >= 0) ) then V0 is singular;
    //
    // If our singular vertex is not on the positive side of the plane we reverse
    // the triangle winding so that the overlap comparisons will compare the 
    // correct edges with the correct signs.
    //
    XMVECTOR ADistIsLessEqual = XMVectorOrInt( ADistIsLess, ADistIsZero );
    XMVECTOR ADistIsGreaterEqual = XMVectorOrInt( ADistIsGreater, ADistIsZero );

    XMVECTOR AA0, AA1, AA2;
    bool bPositiveA;

    if( XMVector3AllTrue( XMVectorSelect( ADistIsGreaterEqual, ADistIsLess, Select0111 ) ) ||
        XMVector3AllTrue( XMVectorSelect( ADistIsGreater, ADistIsLessEqual, Select0111 ) ) )
    {
        // A0 is singular, crossing from positive to negative.
        AA0 = A0; AA1 = A1; AA2 = A2;
        bPositiveA = true;
    }
    else if( XMVector3AllTrue( XMVectorSelect( ADistIsLessEqual, ADistIsGreater, Select0111 ) ) ||
             XMVector3AllTrue( XMVectorSelect( ADistIsLess, ADistIsGreaterEqual, Select0111 ) ) )
    {
        // A0 is singular, crossing from negative to positive.
        AA0 = A0; AA1 = A2; AA2 = A1;
        bPositiveA = false;
    }
    else if( XMVector3AllTrue( XMVectorSelect( ADistIsGreaterEqual, ADistIsLess, Select1011 ) ) ||
             XMVector3AllTrue( XMVectorSelect( ADistIsGreater, ADistIsLessEqual, Select1011 ) ) )
    {
        // A1 is singular, crossing from positive to negative.
        AA0 = A1; AA1 = A2; AA2 = A0;
        bPositiveA = true;
    }
    else if( XMVector3AllTrue( XMVectorSelect( ADistIsLessEqual, ADistIsGreater, Select1011 ) ) ||
             XMVector3AllTrue( XMVectorSelect( ADistIsLess, ADistIsGreaterEqual, Select1011 ) ) )
    {
        // A1 is singular, crossing from negative to positive.
        AA0 = A1; AA1 = A0; AA2 = A2;
        bPositiveA = false;
    }
    else if( XMVector3AllTrue( XMVectorSelect( ADistIsGreaterEqual, ADistIsLess, Select1101 ) ) ||
             XMVector3AllTrue( XMVectorSelect( ADistIsGreater, ADistIsLessEqual, Select1101 ) ) )
    {
        // A2 is singular, crossing from positive to negative.
        AA0 = A2; AA1 = A0; AA2 = A1;
        bPositiveA = true;
    }
    else if( XMVector3AllTrue( XMVectorSelect( ADistIsLessEqual, ADistIsGreater, Select1101 ) ) ||
             XMVector3AllTrue( XMVectorSelect( ADistIsLess, ADistIsGreaterEqual, Select1101 ) ) )
    {
        // A2 is singular, crossing from negative to positive.
        AA0 = A2; AA1 = A1; AA2 = A0;
        bPositiveA = false;
    }
    else
    {
        XMASSERT( FALSE );
        return FALSE;
    }

    XMVECTOR BDistIsLessEqual = XMVectorOrInt( BDistIsLess, BDistIsZero );
    XMVECTOR BDistIsGreaterEqual = XMVectorOrInt( BDistIsGreater, BDistIsZero );

    XMVECTOR BB0, BB1, BB2;
    bool bPositiveB;

    if( XMVector3AllTrue( XMVectorSelect( BDistIsGreaterEqual, BDistIsLess, Select0111 ) ) ||
        XMVector3AllTrue( XMVectorSelect( BDistIsGreater, BDistIsLessEqual, Select0111 ) ) )
    {
        // B0 is singular, crossing from positive to negative.
        BB0 = B0; BB1 = B1; BB2 = B2;
        bPositiveB = true;
    }
    else if( XMVector3AllTrue( XMVectorSelect( BDistIsLessEqual, BDistIsGreater, Select0111 ) ) ||
             XMVector3AllTrue( XMVectorSelect( BDistIsLess, BDistIsGreaterEqual, Select0111 ) ) )
    {
        // B0 is singular, crossing from negative to positive.
        BB0 = B0; BB1 = B2; BB2 = B1;
        bPositiveB = false;
    }
    else if( XMVector3AllTrue( XMVectorSelect( BDistIsGreaterEqual, BDistIsLess, Select1011 ) ) ||
             XMVector3AllTrue( XMVectorSelect( BDistIsGreater, BDistIsLessEqual, Select1011 ) ) )
    {
        // B1 is singular, crossing from positive to negative.
        BB0 = B1; BB1 = B2; BB2 = B0;
        bPositiveB = true;
    }
    else if( XMVector3AllTrue( XMVectorSelect( BDistIsLessEqual, BDistIsGreater, Select1011 ) ) ||
             XMVector3AllTrue( XMVectorSelect( BDistIsLess, BDistIsGreaterEqual, Select1011 ) ) )
    {
        // B1 is singular, crossing from negative to positive.
        BB0 = B1; BB1 = B0; BB2 = B2;
        bPositiveB = false;
    }
    else if( XMVector3AllTrue( XMVectorSelect( BDistIsGreaterEqual, BDistIsLess, Select1101 ) ) ||
             XMVector3AllTrue( XMVectorSelect( BDistIsGreater, BDistIsLessEqual, Select1101 ) ) )
    {
        // B2 is singular, crossing from positive to negative.
        BB0 = B2; BB1 = B0; BB2 = B1;
        bPositiveB = true;
    }
    else if( XMVector3AllTrue( XMVectorSelect( BDistIsLessEqual, BDistIsGreater, Select1101 ) ) ||
             XMVector3AllTrue( XMVectorSelect( BDistIsLess, BDistIsGreaterEqual, Select1101 ) ) )
    {
        // B2 is singular, crossing from negative to positive.
        BB0 = B2; BB1 = B1; BB2 = B0;
        bPositiveB = false;
    }
    else
    {
        XMASSERT( FALSE );
        return FALSE;
    }

    XMVECTOR Delta0, Delta1;

    // Reverse the direction of the test depending on whether the singular vertices are
    // the same sign or different signs.
    if( bPositiveA ^ bPositiveB )
    {
        Delta0 = ( BB0 - AA0 );
        Delta1 = ( AA0 - BB0 );
    }
    else
    {
        Delta0 = ( AA0 - BB0 );
        Delta1 = ( BB0 - AA0 );
    }

    // Check if the triangles overlap on the line of intersection between the
    // planes of the two triangles by finding the signed line distances.
    XMVECTOR Dist0 = XMVector3Dot( Delta0, XMVector3Cross( ( BB2 - BB0 ), ( AA2 - AA0 ) ) );
    if( XMVector4Greater( Dist0, Zero ) )
        return FALSE;

    XMVECTOR Dist1 = XMVector3Dot( Delta1, XMVector3Cross( ( BB1 - BB0 ), ( AA1 - AA0 ) ) );
    if( XMVector4Greater( Dist1, Zero ) )
        return FALSE;

    return TRUE;
}



//-----------------------------------------------------------------------------
BOOL IntersectTriangleSphere( FXMVECTOR V0, FXMVECTOR V1, FXMVECTOR V2, const Sphere* pVolume )
{
    XMASSERT( pVolume );

    // Load the sphere.    
    XMVECTOR Center = XMLoadFloat3( &pVolume->Center );
    XMVECTOR Radius = XMVectorReplicatePtr( &pVolume->Radius );

    // Compute the plane of the triangle (has to be normalized).
    XMVECTOR N = XMVector3Normalize( XMVector3Cross( V1 - V0, V2 - V0 ) );

    // Assert that the triangle is not degenerate.
    XMASSERT( !XMVector3Equal( N, XMVectorZero() ) );

    // Find the nearest feature on the triangle to the sphere.
    XMVECTOR Dist = XMVector3Dot( Center - V0, N );

    // If the center of the sphere is farther from the plane of the triangle than
    // the radius of the sphere, then there cannot be an intersection.
    XMVECTOR NoIntersection = XMVectorLess( Dist, -Radius );
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorGreater( Dist, Radius ) );

    // Project the center of the sphere onto the plane of the triangle.
    XMVECTOR Point = Center - ( N * Dist );

    // Is it inside all the edges? If so we intersect because the distance 
    // to the plane is less than the radius.
    XMVECTOR Intersection = PointOnPlaneInsideTriangle( Point, V0, V1, V2 );

    // Find the nearest point on each edge.
    XMVECTOR RadiusSq = Radius * Radius;

    // Edge 0,1
    Point = PointOnLineSegmentNearestPoint( V0, V1, Center );

    // If the distance to the center of the sphere to the point is less than 
    // the radius of the sphere then it must intersect.
    Intersection = XMVectorOrInt( Intersection, XMVectorLessOrEqual( XMVector3LengthSq( Center - Point ), RadiusSq ) );

    // Edge 1,2
    Point = PointOnLineSegmentNearestPoint( V1, V2, Center );

    // If the distance to the center of the sphere to the point is less than 
    // the radius of the sphere then it must intersect.
    Intersection = XMVectorOrInt( Intersection, XMVectorLessOrEqual( XMVector3LengthSq( Center - Point ), RadiusSq ) );

    // Edge 2,0
    Point = PointOnLineSegmentNearestPoint( V2, V0, Center );

    // If the distance to the center of the sphere to the point is less than 
    // the radius of the sphere then it must intersect.
    Intersection = XMVectorOrInt( Intersection, XMVectorLessOrEqual( XMVector3LengthSq( Center - Point ), RadiusSq ) );

    return XMVector4EqualInt( XMVectorAndCInt( Intersection, NoIntersection ), XMVectorTrueInt() );
}



//-----------------------------------------------------------------------------
BOOL IntersectTriangleAxisAlignedBox( FXMVECTOR V0, FXMVECTOR V1, FXMVECTOR V2, const AxisAlignedBox* pVolume )
{
    XMASSERT( pVolume );

    static CONST XMVECTORI32 Permute0W1Z0Y0X =
                 {
                    XM_PERMUTE_0W, XM_PERMUTE_1Z, XM_PERMUTE_0Y, XM_PERMUTE_0X
                 };
    static CONST XMVECTORI32 Permute0Z0W1X0Y =
                 {
                    XM_PERMUTE_0Z, XM_PERMUTE_0W, XM_PERMUTE_1X, XM_PERMUTE_0Y
                 };
    static CONST XMVECTORI32 Permute1Y0X0W0Z =
                 {
                    XM_PERMUTE_1Y, XM_PERMUTE_0X, XM_PERMUTE_0W, XM_PERMUTE_0Z
                 };

    XMVECTOR Zero = XMVectorZero();

    // Load the box.
    XMVECTOR Center = XMLoadFloat3( &pVolume->Center );
    XMVECTOR Extents = XMLoadFloat3( &pVolume->Extents );

    XMVECTOR BoxMin = Center - Extents;
    XMVECTOR BoxMax = Center + Extents;

    // Test the axes of the box (in effect test the AAB against the minimal AAB 
    // around the triangle).
    XMVECTOR TriMin = XMVectorMin( XMVectorMin( V0, V1 ), V2 );
    XMVECTOR TriMax = XMVectorMax( XMVectorMax( V0, V1 ), V2 );

    // for each i in (x, y, z) if a_min(i) > b_max(i) or b_min(i) > a_max(i) then disjoint
    XMVECTOR Disjoint = XMVectorOrInt( XMVectorGreater( TriMin, BoxMax ), XMVectorGreater( BoxMin, TriMax ) );
    if( XMVector3AnyTrue( Disjoint ) )
        return FALSE;

    // Test the plane of the triangle.
    XMVECTOR Normal = XMVector3Cross( V1 - V0, V2 - V0 );
    XMVECTOR Dist = XMVector3Dot( Normal, V0 );

    // Assert that the triangle is not degenerate.
    XMASSERT( !XMVector3Equal( Normal, Zero ) );

    // for each i in (x, y, z) if n(i) >= 0 then v_min(i)=b_min(i), v_max(i)=b_max(i)
    // else v_min(i)=b_max(i), v_max(i)=b_min(i)
    XMVECTOR NormalSelect = XMVectorGreater( Normal, Zero );
    XMVECTOR V_Min = XMVectorSelect( BoxMax, BoxMin, NormalSelect );
    XMVECTOR V_Max = XMVectorSelect( BoxMin, BoxMax, NormalSelect );

    // if n dot v_min + d > 0 || n dot v_max + d < 0 then disjoint
    XMVECTOR MinDist = XMVector3Dot( V_Min, Normal );
    XMVECTOR MaxDist = XMVector3Dot( V_Max, Normal );

    XMVECTOR NoIntersection = XMVectorGreater( MinDist, Dist );
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorLess( MaxDist, Dist ) );

    // Move the box center to zero to simplify the following tests.
    XMVECTOR TV0 = V0 - Center;
    XMVECTOR TV1 = V1 - Center;
    XMVECTOR TV2 = V2 - Center;

    // Test the edge/edge axes (3*3).
    XMVECTOR e0 = TV1 - TV0;
    XMVECTOR e1 = TV2 - TV1;
    XMVECTOR e2 = TV0 - TV2;

    // Make w zero.
    e0 = XMVectorInsert( e0, Zero, 0, 0, 0, 0, 1 );
    e1 = XMVectorInsert( e1, Zero, 0, 0, 0, 0, 1 );
    e2 = XMVectorInsert( e2, Zero, 0, 0, 0, 0, 1 );

    XMVECTOR Axis;
    XMVECTOR p0, p1, p2;
    XMVECTOR Min, Max;
    XMVECTOR Radius;

    // Axis == (1,0,0) x e0 = (0, -e0.z, e0.y)
    Axis = XMVectorPermute( e0, -e0, Permute0W1Z0Y0X );
    p0 = XMVector3Dot( TV0, Axis );
    // p1 = XMVector3Dot( V1, Axis ); // p1 = p0;
    p2 = XMVector3Dot( TV2, Axis );
    Min = XMVectorMin( p0, p2 );
    Max = XMVectorMax( p0, p2 );
    Radius = XMVector3Dot( Extents, XMVectorAbs( Axis ) );
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorGreater( Min, Radius ) );
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorLess( Max, -Radius ) );

    // Axis == (1,0,0) x e1 = (0, -e1.z, e1.y)
    Axis = XMVectorPermute( e1, -e1, Permute0W1Z0Y0X );
    p0 = XMVector3Dot( TV0, Axis );
    p1 = XMVector3Dot( TV1, Axis );
    // p2 = XMVector3Dot( V2, Axis ); // p2 = p1;
    Min = XMVectorMin( p0, p1 );
    Max = XMVectorMax( p0, p1 );
    Radius = XMVector3Dot( Extents, XMVectorAbs( Axis ) );
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorGreater( Min, Radius ) );
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorLess( Max, -Radius ) );

    // Axis == (1,0,0) x e2 = (0, -e2.z, e2.y)
    Axis = XMVectorPermute( e2, -e2, Permute0W1Z0Y0X );
    p0 = XMVector3Dot( TV0, Axis );
    p1 = XMVector3Dot( TV1, Axis );
    // p2 = XMVector3Dot( V2, Axis ); // p2 = p0;
    Min = XMVectorMin( p0, p1 );
    Max = XMVectorMax( p0, p1 );
    Radius = XMVector3Dot( Extents, XMVectorAbs( Axis ) );
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorGreater( Min, Radius ) );
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorLess( Max, -Radius ) );

    // Axis == (0,1,0) x e0 = (e0.z, 0, -e0.x)
    Axis = XMVectorPermute( e0, -e0, Permute0Z0W1X0Y );
    p0 = XMVector3Dot( TV0, Axis );
    // p1 = XMVector3Dot( V1, Axis ); // p1 = p0;
    p2 = XMVector3Dot( TV2, Axis );
    Min = XMVectorMin( p0, p2 );
    Max = XMVectorMax( p0, p2 );
    Radius = XMVector3Dot( Extents, XMVectorAbs( Axis ) );
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorGreater( Min, Radius ) );
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorLess( Max, -Radius ) );

    // Axis == (0,1,0) x e1 = (e1.z, 0, -e1.x)
    Axis = XMVectorPermute( e1, -e1, Permute0Z0W1X0Y );
    p0 = XMVector3Dot( TV0, Axis );
    p1 = XMVector3Dot( TV1, Axis );
    // p2 = XMVector3Dot( V2, Axis ); // p2 = p1;
    Min = XMVectorMin( p0, p1 );
    Max = XMVectorMax( p0, p1 );
    Radius = XMVector3Dot( Extents, XMVectorAbs( Axis ) );
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorGreater( Min, Radius ) );
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorLess( Max, -Radius ) );

    // Axis == (0,0,1) x e2 = (e2.z, 0, -e2.x)
    Axis = XMVectorPermute( e2, -e2, Permute0Z0W1X0Y );
    p0 = XMVector3Dot( TV0, Axis );
    p1 = XMVector3Dot( TV1, Axis );
    // p2 = XMVector3Dot( V2, Axis ); // p2 = p0;
    Min = XMVectorMin( p0, p1 );
    Max = XMVectorMax( p0, p1 );
    Radius = XMVector3Dot( Extents, XMVectorAbs( Axis ) );
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorGreater( Min, Radius ) );
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorLess( Max, -Radius ) );

    // Axis == (0,0,1) x e0 = (-e0.y, e0.x, 0)
    Axis = XMVectorPermute( e0, -e0, Permute1Y0X0W0Z );
    p0 = XMVector3Dot( TV0, Axis );
    // p1 = XMVector3Dot( V1, Axis ); // p1 = p0;
    p2 = XMVector3Dot( TV2, Axis );
    Min = XMVectorMin( p0, p2 );
    Max = XMVectorMax( p0, p2 );
    Radius = XMVector3Dot( Extents, XMVectorAbs( Axis ) );
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorGreater( Min, Radius ) );
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorLess( Max, -Radius ) );

    // Axis == (0,0,1) x e1 = (-e1.y, e1.x, 0)
    Axis = XMVectorPermute( e1, -e1, Permute1Y0X0W0Z );
    p0 = XMVector3Dot( TV0, Axis );
    p1 = XMVector3Dot( TV1, Axis );
    // p2 = XMVector3Dot( V2, Axis ); // p2 = p1;
    Min = XMVectorMin( p0, p1 );
    Max = XMVectorMax( p0, p1 );
    Radius = XMVector3Dot( Extents, XMVectorAbs( Axis ) );
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorGreater( Min, Radius ) );
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorLess( Max, -Radius ) );

    // Axis == (0,0,1) x e2 = (-e2.y, e2.x, 0)
    Axis = XMVectorPermute( e2, -e2, Permute1Y0X0W0Z );
    p0 = XMVector3Dot( TV0, Axis );
    p1 = XMVector3Dot( TV1, Axis );
    // p2 = XMVector3Dot( V2, Axis ); // p2 = p0;
    Min = XMVectorMin( p0, p1 );
    Max = XMVectorMax( p0, p1 );
    Radius = XMVector3Dot( Extents, XMVectorAbs( Axis ) );
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorGreater( Min, Radius ) );
    NoIntersection = XMVectorOrInt( NoIntersection, XMVectorLess( Max, -Radius ) );

    return XMVector4NotEqualInt( NoIntersection, XMVectorTrueInt() );
}



//-----------------------------------------------------------------------------
BOOL IntersectTriangleOrientedBox( FXMVECTOR V0, FXMVECTOR V1, FXMVECTOR V2, const OrientedBox* pVolume )
{
    XMASSERT( pVolume );

    // Load the box center & orientation.
    XMVECTOR Center = XMLoadFloat3( &pVolume->Center );
    XMVECTOR Orientation = XMLoadFloat4( &pVolume->Orientation );

    XMASSERT( XMQuaternionIsUnit( Orientation ) );

    // Transform the triangle vertices into the space of the box.
    XMVECTOR TV0 = XMVector3InverseRotate( V0 - Center, Orientation );
    XMVECTOR TV1 = XMVector3InverseRotate( V1 - Center, Orientation );
    XMVECTOR TV2 = XMVector3InverseRotate( V2 - Center, Orientation );

    AxisAlignedBox Box;
    Box.Center = XMFLOAT3( 0.0f, 0.0f, 0.0f );
    Box.Extents = pVolume->Extents;

    // Use the triangle vs axis aligned box intersection routine.
    return IntersectTriangleAxisAlignedBox( TV0, TV1, TV2, &Box );
}



//-----------------------------------------------------------------------------
BOOL IntersectSphereSphere( const Sphere* pVolumeA, const Sphere* pVolumeB )
{
    XMASSERT( pVolumeA );
    XMASSERT( pVolumeB );

    // Load A.
    XMVECTOR CenterA = XMLoadFloat3( &pVolumeA->Center );
    XMVECTOR RadiusA = XMVectorReplicatePtr( &pVolumeA->Radius );

    // Load B.
    XMVECTOR CenterB = XMLoadFloat3( &pVolumeB->Center );
    XMVECTOR RadiusB = XMVectorReplicatePtr( &pVolumeB->Radius );

    // Distance squared between centers.    
    XMVECTOR Delta = CenterB - CenterA;
    XMVECTOR DistanceSquared = XMVector3LengthSq( Delta );

    // Sum of the radii sqaured.
    XMVECTOR RadiusSquared = RadiusA + RadiusB;
    RadiusSquared = RadiusSquared * RadiusSquared;

    return XMVector4LessOrEqual( DistanceSquared, RadiusSquared );
}



//-----------------------------------------------------------------------------
BOOL IntersectSphereAxisAlignedBox( const Sphere* pVolumeA, const AxisAlignedBox* pVolumeB )
{
    XMASSERT( pVolumeA );
    XMASSERT( pVolumeB );

    XMVECTOR SphereCenter = XMLoadFloat3( &pVolumeA->Center );
    XMVECTOR SphereRadius = XMVectorReplicatePtr( &pVolumeA->Radius );

    XMVECTOR BoxCenter = XMLoadFloat3( &pVolumeB->Center );
    XMVECTOR BoxExtents = XMLoadFloat3( &pVolumeB->Extents );

    XMVECTOR BoxMin = BoxCenter - BoxExtents;
    XMVECTOR BoxMax = BoxCenter + BoxExtents;

    // Find the distance to the nearest point on the box.
    // for each i in (x, y, z)
    // if (SphereCenter(i) < BoxMin(i)) d2 += (SphereCenter(i) - BoxMin(i)) ^ 2
    // else if (SphereCenter(i) > BoxMax(i)) d2 += (SphereCenter(i) - BoxMax(i)) ^ 2

    XMVECTOR d = XMVectorZero();

    // Compute d for each dimension.
    XMVECTOR LessThanMin = XMVectorLess( SphereCenter, BoxMin );
    XMVECTOR GreaterThanMax = XMVectorGreater( SphereCenter, BoxMax );

    XMVECTOR MinDelta = SphereCenter - BoxMin;
    XMVECTOR MaxDelta = SphereCenter - BoxMax;

    // Choose value for each dimension based on the comparison.
    d = XMVectorSelect( d, MinDelta, LessThanMin );
    d = XMVectorSelect( d, MaxDelta, GreaterThanMax );

    // Use a dot-product to square them and sum them together.
    XMVECTOR d2 = XMVector3Dot( d, d );

    return XMVector4LessOrEqual( d2, XMVectorMultiply( SphereRadius, SphereRadius ) );
}



//-----------------------------------------------------------------------------
BOOL IntersectSphereOrientedBox( const Sphere* pVolumeA, const OrientedBox* pVolumeB )
{
    XMASSERT( pVolumeA );
    XMASSERT( pVolumeB );

    XMVECTOR SphereCenter = XMLoadFloat3( &pVolumeA->Center );
    XMVECTOR SphereRadius = XMVectorReplicatePtr( &pVolumeA->Radius );

    XMVECTOR BoxCenter = XMLoadFloat3( &pVolumeB->Center );
    XMVECTOR BoxExtents = XMLoadFloat3( &pVolumeB->Extents );
    XMVECTOR BoxOrientation = XMLoadFloat4( &pVolumeB->Orientation );

    XMASSERT( XMQuaternionIsUnit( BoxOrientation ) );

    // Transform the center of the sphere to be local to the box.
    // BoxMin = -BoxExtents
    // BoxMax = +BoxExtents
    SphereCenter = XMVector3InverseRotate( SphereCenter - BoxCenter, BoxOrientation );

    // Find the distance to the nearest point on the box.
    // for each i in (x, y, z)
    // if (SphereCenter(i) < BoxMin(i)) d2 += (SphereCenter(i) - BoxMin(i)) ^ 2
    // else if (SphereCenter(i) > BoxMax(i)) d2 += (SphereCenter(i) - BoxMax(i)) ^ 2

    XMVECTOR d = XMVectorZero();

    // Compute d for each dimension.
    XMVECTOR LessThanMin = XMVectorLess( SphereCenter, -BoxExtents );
    XMVECTOR GreaterThanMax = XMVectorGreater( SphereCenter, BoxExtents );

    XMVECTOR MinDelta = SphereCenter + BoxExtents;
    XMVECTOR MaxDelta = SphereCenter - BoxExtents;

    // Choose value for each dimension based on the comparison.
    d = XMVectorSelect( d, MinDelta, LessThanMin );
    d = XMVectorSelect( d, MaxDelta, GreaterThanMax );

    // Use a dot-product to square them and sum them together.
    XMVECTOR d2 = XMVector3Dot( d, d );

    return XMVector4LessOrEqual( d2, XMVectorMultiply( SphereRadius, SphereRadius ) );
}



//-----------------------------------------------------------------------------
BOOL IntersectAxisAlignedBoxAxisAlignedBox( const AxisAlignedBox* pVolumeA, const AxisAlignedBox* pVolumeB )
{
    XMASSERT( pVolumeA );
    XMASSERT( pVolumeB );

    XMVECTOR CenterA = XMLoadFloat3( &pVolumeA->Center );
    XMVECTOR ExtentsA = XMLoadFloat3( &pVolumeA->Extents );

    XMVECTOR CenterB = XMLoadFloat3( &pVolumeB->Center );
    XMVECTOR ExtentsB = XMLoadFloat3( &pVolumeB->Extents );

    XMVECTOR MinA = CenterA - ExtentsA;
    XMVECTOR MaxA = CenterA + ExtentsA;

    XMVECTOR MinB = CenterB - ExtentsB;
    XMVECTOR MaxB = CenterB + ExtentsB;

    // for each i in (x, y, z) if a_min(i) > b_max(i) or b_min(i) > a_max(i) then return FALSE
    XMVECTOR Disjoint = XMVectorOrInt( XMVectorGreater( MinA, MaxB ), XMVectorGreater( MinB, MaxA ) );

    return !XMVector3AnyTrue( Disjoint );
}



//-----------------------------------------------------------------------------
BOOL IntersectAxisAlignedBoxOrientedBox( const AxisAlignedBox* pVolumeA, const OrientedBox* pVolumeB )
{
    XMASSERT( pVolumeA );
    XMASSERT( pVolumeB );

    // Make the axis aligned box oriented and do an OBB vs OBB test.
    OrientedBox BoxA;

    BoxA.Center = pVolumeA->Center;
    BoxA.Extents = pVolumeA->Extents;
    BoxA.Orientation.x = 0.0f;
    BoxA.Orientation.y = 0.0f;
    BoxA.Orientation.z = 0.0f;
    BoxA.Orientation.w = 1.0f;

    return IntersectOrientedBoxOrientedBox( &BoxA, pVolumeB );
}



//-----------------------------------------------------------------------------
// Fast oriented box / oriented box intersection test using the separating axis 
// theorem.
//-----------------------------------------------------------------------------
BOOL IntersectOrientedBoxOrientedBox( const OrientedBox* pVolumeA, const OrientedBox* pVolumeB )
{
    static CONST XMVECTORI32 Permute0W1Z0Y0X =
                 {
                    XM_PERMUTE_0W, XM_PERMUTE_1Z, XM_PERMUTE_0Y, XM_PERMUTE_0X
                 };
    static CONST XMVECTORI32 Permute0Z0W1X0Y =
                 {
                    XM_PERMUTE_0Z, XM_PERMUTE_0W, XM_PERMUTE_1X, XM_PERMUTE_0Y
                 };
    static CONST XMVECTORI32 Permute1Y0X0W0Z =
                 {
                    XM_PERMUTE_1Y, XM_PERMUTE_0X, XM_PERMUTE_0W, XM_PERMUTE_0Z
                 };
    static CONST XMVECTORI32 PermuteWZYX =
                 {
                    XM_PERMUTE_0W, XM_PERMUTE_0Z, XM_PERMUTE_0Y, XM_PERMUTE_0X
                 };
    static CONST XMVECTORI32 PermuteZWXY =
                 {
                    XM_PERMUTE_0Z, XM_PERMUTE_0W, XM_PERMUTE_0X, XM_PERMUTE_0Y
                 };
    static CONST XMVECTORI32 PermuteYXWZ =
                 {
                    XM_PERMUTE_0Y, XM_PERMUTE_0X, XM_PERMUTE_0W, XM_PERMUTE_0Z
                 };

    XMASSERT( pVolumeA );
    XMASSERT( pVolumeB );

    // Build the 3x3 rotation matrix that defines the orientation of B relative to A.
    XMVECTOR A_quat = XMLoadFloat4( &pVolumeA->Orientation );
    XMVECTOR B_quat = XMLoadFloat4( &pVolumeB->Orientation );

    XMASSERT( XMQuaternionIsUnit( A_quat ) );
    XMASSERT( XMQuaternionIsUnit( B_quat ) );

    XMVECTOR Q = XMQuaternionMultiply( A_quat, XMQuaternionConjugate( B_quat ) );
    XMMATRIX R = XMMatrixRotationQuaternion( Q );

    // Compute the translation of B relative to A.
    XMVECTOR A_cent = XMLoadFloat3( &pVolumeA->Center );
    XMVECTOR B_cent = XMLoadFloat3( &pVolumeB->Center );
    XMVECTOR t = XMVector3InverseRotate( B_cent - A_cent, A_quat );

    //
    // h(A) = extents of A.
    // h(B) = extents of B.
    //
    // a(u) = axes of A = (1,0,0), (0,1,0), (0,0,1)
    // b(u) = axes of B relative to A = (r00,r10,r20), (r01,r11,r21), (r02,r12,r22)
    //  
    // For each possible separating axis l:
    //   d(A) = sum (for i = u,v,w) h(A)(i) * abs( a(i) dot l )
    //   d(B) = sum (for i = u,v,w) h(B)(i) * abs( b(i) dot l )
    //   if abs( t dot l ) > d(A) + d(B) then disjoint
    //

    // Load extents of A and B.
    XMVECTOR h_A = XMLoadFloat3( &pVolumeA->Extents );
    XMVECTOR h_B = XMLoadFloat3( &pVolumeB->Extents );

    // Rows. Note R[0,1,2]X.w = 0.
    XMVECTOR R0X = R.r[0];
    XMVECTOR R1X = R.r[1];
    XMVECTOR R2X = R.r[2];

    R = XMMatrixTranspose( R );

    // Columns. Note RX[0,1,2].w = 0.
    XMVECTOR RX0 = R.r[0];
    XMVECTOR RX1 = R.r[1];
    XMVECTOR RX2 = R.r[2];

    // Absolute value of rows.
    XMVECTOR AR0X = XMVectorAbs( R0X );
    XMVECTOR AR1X = XMVectorAbs( R1X );
    XMVECTOR AR2X = XMVectorAbs( R2X );

    // Absolute value of columns.
    XMVECTOR ARX0 = XMVectorAbs( RX0 );
    XMVECTOR ARX1 = XMVectorAbs( RX1 );
    XMVECTOR ARX2 = XMVectorAbs( RX2 );

    // Test each of the 15 possible seperating axii.
    XMVECTOR d, d_A, d_B;

    // l = a(u) = (1, 0, 0)
    // t dot l = t.x
    // d(A) = h(A).x
    // d(B) = h(B) dot abs(r00, r01, r02)
    d = XMVectorSplatX( t );
    d_A = XMVectorSplatX( h_A );
    d_B = XMVector3Dot( h_B, AR0X );
    XMVECTOR NoIntersection = XMVectorGreater( XMVectorAbs(d), XMVectorAdd( d_A, d_B ) );

    // l = a(v) = (0, 1, 0)
    // t dot l = t.y
    // d(A) = h(A).y
    // d(B) = h(B) dot abs(r10, r11, r12)
    d = XMVectorSplatY( t );
    d_A = XMVectorSplatY( h_A );
    d_B = XMVector3Dot( h_B, AR1X );
    NoIntersection = XMVectorOrInt( NoIntersection, 
                                    XMVectorGreater( XMVectorAbs(d), XMVectorAdd( d_A, d_B ) ) );

    // l = a(w) = (0, 0, 1)
    // t dot l = t.z
    // d(A) = h(A).z
    // d(B) = h(B) dot abs(r20, r21, r22)
    d = XMVectorSplatZ( t );
    d_A = XMVectorSplatZ( h_A );
    d_B = XMVector3Dot( h_B, AR2X );
    NoIntersection = XMVectorOrInt( NoIntersection, 
                                    XMVectorGreater( XMVectorAbs(d), XMVectorAdd( d_A, d_B ) ) );

    // l = b(u) = (r00, r10, r20)
    // d(A) = h(A) dot abs(r00, r10, r20)
    // d(B) = h(B).x
    d = XMVector3Dot( t, RX0 );
    d_A = XMVector3Dot( h_A, ARX0 );
    d_B = XMVectorSplatX( h_B );
    NoIntersection = XMVectorOrInt( NoIntersection, 
                                    XMVectorGreater( XMVectorAbs(d), XMVectorAdd( d_A, d_B ) ) );

    // l = b(v) = (r01, r11, r21)
    // d(A) = h(A) dot abs(r01, r11, r21)
    // d(B) = h(B).y
    d = XMVector3Dot( t, RX1 );
    d_A = XMVector3Dot( h_A, ARX1 );
    d_B = XMVectorSplatY( h_B );
    NoIntersection = XMVectorOrInt( NoIntersection, 
                                    XMVectorGreater( XMVectorAbs(d), XMVectorAdd( d_A, d_B ) ) );

    // l = b(w) = (r02, r12, r22)
    // d(A) = h(A) dot abs(r02, r12, r22)
    // d(B) = h(B).z
    d = XMVector3Dot( t, RX2 );
    d_A = XMVector3Dot( h_A, ARX2 );
    d_B = XMVectorSplatZ( h_B );
    NoIntersection = XMVectorOrInt( NoIntersection, 
                                    XMVectorGreater( XMVectorAbs(d), XMVectorAdd( d_A, d_B ) ) );

    // l = a(u) x b(u) = (0, -r20, r10)
    // d(A) = h(A) dot abs(0, r20, r10)
    // d(B) = h(B) dot abs(0, r02, r01)
    d = XMVector3Dot( t, XMVectorPermute( RX0, -RX0, Permute0W1Z0Y0X ) );
    d_A = XMVector3Dot( h_A, XMVectorPermute( ARX0, ARX0, PermuteWZYX ) );
    d_B = XMVector3Dot( h_B, XMVectorPermute( AR0X, AR0X, PermuteWZYX ) );
    NoIntersection = XMVectorOrInt( NoIntersection, 
                                    XMVectorGreater( XMVectorAbs(d), XMVectorAdd( d_A, d_B ) ) );

    // l = a(u) x b(v) = (0, -r21, r11)
    // d(A) = h(A) dot abs(0, r21, r11)
    // d(B) = h(B) dot abs(r02, 0, r00)
    d = XMVector3Dot( t, XMVectorPermute( RX1, -RX1, Permute0W1Z0Y0X ) );
    d_A = XMVector3Dot( h_A, XMVectorPermute( ARX1, ARX1, PermuteWZYX ) );
    d_B = XMVector3Dot( h_B, XMVectorPermute( AR0X, AR0X, PermuteZWXY ) );
    NoIntersection = XMVectorOrInt( NoIntersection, 
                                    XMVectorGreater( XMVectorAbs(d), XMVectorAdd( d_A, d_B ) ) );

    // l = a(u) x b(w) = (0, -r22, r12)
    // d(A) = h(A) dot abs(0, r22, r12)
    // d(B) = h(B) dot abs(r01, r00, 0)
    d = XMVector3Dot( t, XMVectorPermute( RX2, -RX2, Permute0W1Z0Y0X ) );
    d_A = XMVector3Dot( h_A, XMVectorPermute( ARX2, ARX2, PermuteWZYX ) );
    d_B = XMVector3Dot( h_B, XMVectorPermute( AR0X, AR0X, PermuteYXWZ ) );
    NoIntersection = XMVectorOrInt( NoIntersection, 
                                    XMVectorGreater( XMVectorAbs(d), XMVectorAdd( d_A, d_B ) ) );

    // l = a(v) x b(u) = (r20, 0, -r00)
    // d(A) = h(A) dot abs(r20, 0, r00)
    // d(B) = h(B) dot abs(0, r12, r11)
    d = XMVector3Dot( t, XMVectorPermute( RX0, -RX0, Permute0Z0W1X0Y ) );
    d_A = XMVector3Dot( h_A, XMVectorPermute( ARX0, ARX0, PermuteZWXY ) );
    d_B = XMVector3Dot( h_B, XMVectorPermute( AR1X, AR1X, PermuteWZYX ) );
    NoIntersection = XMVectorOrInt( NoIntersection, 
                                    XMVectorGreater( XMVectorAbs(d), XMVectorAdd( d_A, d_B ) ) );

    // l = a(v) x b(v) = (r21, 0, -r01)
    // d(A) = h(A) dot abs(r21, 0, r01)
    // d(B) = h(B) dot abs(r12, 0, r10)
    d = XMVector3Dot( t, XMVectorPermute( RX1, -RX1, Permute0Z0W1X0Y ) );
    d_A = XMVector3Dot( h_A, XMVectorPermute( ARX1, ARX1, PermuteZWXY ) );
    d_B = XMVector3Dot( h_B, XMVectorPermute( AR1X, AR1X, PermuteZWXY ) );
    NoIntersection = XMVectorOrInt( NoIntersection, 
                                    XMVectorGreater( XMVectorAbs(d), XMVectorAdd( d_A, d_B ) ) );

    // l = a(v) x b(w) = (r22, 0, -r02)
    // d(A) = h(A) dot abs(r22, 0, r02)
    // d(B) = h(B) dot abs(r11, r10, 0)
    d = XMVector3Dot( t, XMVectorPermute( RX2, -RX2, Permute0Z0W1X0Y ) );
    d_A = XMVector3Dot( h_A, XMVectorPermute( ARX2, ARX2, PermuteZWXY ) );
    d_B = XMVector3Dot( h_B, XMVectorPermute( AR1X, AR1X, PermuteYXWZ ) );
    NoIntersection = XMVectorOrInt( NoIntersection, 
                                    XMVectorGreater( XMVectorAbs(d), XMVectorAdd( d_A, d_B ) ) );

    // l = a(w) x b(u) = (-r10, r00, 0)
    // d(A) = h(A) dot abs(r10, r00, 0)
    // d(B) = h(B) dot abs(0, r22, r21)
    d = XMVector3Dot( t, XMVectorPermute( RX0, -RX0, Permute1Y0X0W0Z ) );
    d_A = XMVector3Dot( h_A, XMVectorPermute( ARX0, ARX0, PermuteYXWZ ) );
    d_B = XMVector3Dot( h_B, XMVectorPermute( AR2X, AR2X, PermuteWZYX ) );
    NoIntersection = XMVectorOrInt( NoIntersection, 
                                    XMVectorGreater( XMVectorAbs(d), XMVectorAdd( d_A, d_B ) ) );

    // l = a(w) x b(v) = (-r11, r01, 0)
    // d(A) = h(A) dot abs(r11, r01, 0)
    // d(B) = h(B) dot abs(r22, 0, r20)
    d = XMVector3Dot( t, XMVectorPermute( RX1, -RX1, Permute1Y0X0W0Z ) );
    d_A = XMVector3Dot( h_A, XMVectorPermute( ARX1, ARX1, PermuteYXWZ ) );
    d_B = XMVector3Dot( h_B, XMVectorPermute( AR2X, AR2X, PermuteZWXY ) );
    NoIntersection = XMVectorOrInt( NoIntersection, 
                                    XMVectorGreater( XMVectorAbs(d), XMVectorAdd( d_A, d_B ) ) );

    // l = a(w) x b(w) = (-r12, r02, 0)
    // d(A) = h(A) dot abs(r12, r02, 0)
    // d(B) = h(B) dot abs(r21, r20, 0)
    d = XMVector3Dot( t, XMVectorPermute( RX2, -RX2, Permute1Y0X0W0Z ) );
    d_A = XMVector3Dot( h_A, XMVectorPermute( ARX2, ARX2, PermuteYXWZ ) );
    d_B = XMVector3Dot( h_B, XMVectorPermute( AR2X, AR2X, PermuteYXWZ ) );
    NoIntersection = XMVectorOrInt( NoIntersection, 
                                    XMVectorGreater( XMVectorAbs(d), XMVectorAdd( d_A, d_B ) ) );

    // No seperating axis found, boxes must intersect.
    return XMVector4NotEqualInt( NoIntersection, XMVectorTrueInt() );
}



//-----------------------------------------------------------------------------
// Exact triangle vs frustum test.
// Return values: 0 = no intersection, 
//                1 = intersection, 
//                2 = triangle is completely inside frustum
//-----------------------------------------------------------------------------
INT IntersectTriangleFrustum( FXMVECTOR V0, FXMVECTOR V1, FXMVECTOR V2, const Frustum* pVolume )
{
    XMASSERT( pVolume );

    // Build the frustum planes (NOTE: D is negated from the usual).
    XMVECTOR Planes[6];
    Planes[0] = XMVectorSet( 0.0f, 0.0f, -1.0f, -pVolume->Near );
    Planes[1] = XMVectorSet( 0.0f, 0.0f, 1.0f, pVolume->Far );
    Planes[2] = XMVectorSet( 1.0f, 0.0f, -pVolume->RightSlope, 0.0f );
    Planes[3] = XMVectorSet( -1.0f, 0.0f, pVolume->LeftSlope, 0.0f );
    Planes[4] = XMVectorSet( 0.0f, 1.0f, -pVolume->TopSlope, 0.0f );
    Planes[5] = XMVectorSet( 0.0f, -1.0f, pVolume->BottomSlope, 0.0f );

    // Load origin and orientation of the frustum.
    XMVECTOR Origin = XMLoadFloat3( &pVolume->Origin );
    XMVECTOR Orientation = XMLoadFloat4( &pVolume->Orientation );

    XMASSERT( XMQuaternionIsUnit( Orientation ) );

    // Transform triangle into the local space of frustum.
    XMVECTOR TV0 = XMVector3InverseRotate( V0 - Origin, Orientation );
    XMVECTOR TV1 = XMVector3InverseRotate( V1 - Origin, Orientation );
    XMVECTOR TV2 = XMVector3InverseRotate( V2 - Origin, Orientation );

    // Test each vertex of the triangle against the frustum planes.
    XMVECTOR Outside = XMVectorFalseInt();
    XMVECTOR InsideAll = XMVectorTrueInt();

    for( INT i = 0; i < 6; i++ )
    {
        XMVECTOR Dist0 = XMVector3Dot( TV0, Planes[i] );
        XMVECTOR Dist1 = XMVector3Dot( TV1, Planes[i] );
        XMVECTOR Dist2 = XMVector3Dot( TV2, Planes[i] );

        XMVECTOR MinDist = XMVectorMin( Dist0, Dist1 );
        MinDist = XMVectorMin( MinDist, Dist2 );
        XMVECTOR MaxDist = XMVectorMax( Dist0, Dist1 );
        MaxDist = XMVectorMax( MaxDist, Dist2 );

        XMVECTOR PlaneDist = XMVectorSplatW( Planes[i] );

        // Outside the plane?
        Outside = XMVectorOrInt( Outside, XMVectorGreater( MinDist, PlaneDist ) );

        // Fully inside the plane?
        InsideAll = XMVectorAndInt( InsideAll, XMVectorLessOrEqual( MaxDist, PlaneDist ) );
    }

    // If the triangle is outside any of the planes it is outside. 
    if ( XMVector4EqualInt( Outside, XMVectorTrueInt() ) )
        return 0;

    // If the triangle is inside all planes it is fully inside.
    if ( XMVector4EqualInt( InsideAll, XMVectorTrueInt() ) )
        return 2;

    // Build the corners of the frustum.
    XMVECTOR RightTop = XMVectorSet( pVolume->RightSlope, pVolume->TopSlope, 1.0f, 0.0f );
    XMVECTOR RightBottom = XMVectorSet( pVolume->RightSlope, pVolume->BottomSlope, 1.0f, 0.0f );
    XMVECTOR LeftTop = XMVectorSet( pVolume->LeftSlope, pVolume->TopSlope, 1.0f, 0.0f );
    XMVECTOR LeftBottom = XMVectorSet( pVolume->LeftSlope, pVolume->BottomSlope, 1.0f, 0.0f );
    XMVECTOR Near = XMVectorReplicatePtr( &pVolume->Near );
    XMVECTOR Far = XMVectorReplicatePtr( &pVolume->Far );

    XMVECTOR Corners[8];
    Corners[0] = RightTop * Near;
    Corners[1] = RightBottom * Near;
    Corners[2] = LeftTop * Near;
    Corners[3] = LeftBottom * Near;
    Corners[4] = RightTop * Far;
    Corners[5] = RightBottom * Far;
    Corners[6] = LeftTop * Far;
    Corners[7] = LeftBottom * Far;

    // Test the plane of the triangle.
    XMVECTOR Normal = XMVector3Cross( V1 - V0, V2 - V0 );
    XMVECTOR Dist = XMVector3Dot( Normal, V0 );

    XMVECTOR MinDist, MaxDist;
    MinDist = MaxDist = XMVector3Dot( Corners[0], Normal );
    for( INT i = 1; i < 8; i++ )
    {
        XMVECTOR Temp = XMVector3Dot( Corners[i], Normal );
        MinDist = XMVectorMin( MinDist, Temp );
        MaxDist = XMVectorMax( MaxDist, Temp );
    }

    Outside = XMVectorOrInt( XMVectorGreater( MinDist, Dist ), XMVectorLess( MaxDist, Dist ) );   
    if ( XMVector4EqualInt( Outside, XMVectorTrueInt() ) )
        return 0;

    // Check the edge/edge axes (3*6).
    XMVECTOR TriangleEdgeAxis[3];
    TriangleEdgeAxis[0] = V1 - V0;
    TriangleEdgeAxis[1] = V2 - V1;
    TriangleEdgeAxis[2] = V0 - V2;

    XMVECTOR FrustumEdgeAxis[6];
    FrustumEdgeAxis[0] = RightTop;
    FrustumEdgeAxis[1] = RightBottom;
    FrustumEdgeAxis[2] = LeftTop;
    FrustumEdgeAxis[3] = LeftBottom;
    FrustumEdgeAxis[4] = RightTop - LeftTop;
    FrustumEdgeAxis[5] = LeftBottom - LeftTop;

    for( INT i = 0; i < 3; i++ )
    {
        for( INT j = 0; j < 6; j++ )
        {
            // Compute the axis we are going to test.
            XMVECTOR Axis = XMVector3Cross( TriangleEdgeAxis[i], FrustumEdgeAxis[j] );

            // Find the min/max of the projection of the triangle onto the axis.
            XMVECTOR MinA, MaxA;

            XMVECTOR Dist0 = XMVector3Dot( V0, Axis );
            XMVECTOR Dist1 = XMVector3Dot( V1, Axis );
            XMVECTOR Dist2 = XMVector3Dot( V2, Axis );

            MinA = XMVectorMin( Dist0, Dist1 );
            MinA = XMVectorMin( MinA, Dist2 );
            MaxA = XMVectorMax( Dist0, Dist1 );
            MaxA = XMVectorMax( MaxA, Dist2 );

            // Find the min/max of the projection of the frustum onto the axis.
            XMVECTOR MinB, MaxB;

            MinB = MaxB = XMVector3Dot( Axis, Corners[0] );

            for( INT k = 1; k < 8; k++ )
            {
                XMVECTOR Temp = XMVector3Dot( Axis, Corners[k] );
                MinB = XMVectorMin( MinB, Temp );
                MaxB = XMVectorMax( MaxB, Temp );
            }

            // if (MinA > MaxB || MinB > MaxA) reject;
            Outside = XMVectorOrInt( Outside, XMVectorGreater( MinA, MaxB ) );
            Outside = XMVectorOrInt( Outside, XMVectorGreater( MinB, MaxA ) );
        }
    }

    if ( XMVector4EqualInt( Outside, XMVectorTrueInt() ) )
        return 0;

    // If we did not find a separating plane then the triangle must intersect the frustum.
    return 1;
}



//-----------------------------------------------------------------------------
// Exact sphere vs frustum test.  The algorithm first checks the sphere against
// the planes of the frustum, then if the plane checks were indeterminate finds
// the nearest feature (plane, line, point) on the frustum to the center of the
// sphere and compares the distance to the nearest feature to the radius of the 
// sphere (it is so cool that all the comment lines above are the same length).
// Return values: 0 = no intersection, 
//                1 = intersection, 
//                2 = sphere is completely inside frustum
//-----------------------------------------------------------------------------
INT IntersectSphereFrustum( const Sphere* pVolumeA, const Frustum* pVolumeB )
{
    XMASSERT( pVolumeA );
    XMASSERT( pVolumeB );

    XMVECTOR Zero = XMVectorZero();

    // Build the frustum planes.
    XMVECTOR Planes[6];
    Planes[0] = XMVectorSet( 0.0f, 0.0f, -1.0f, pVolumeB->Near );
    Planes[1] = XMVectorSet( 0.0f, 0.0f, 1.0f, -pVolumeB->Far );
    Planes[2] = XMVectorSet( 1.0f, 0.0f, -pVolumeB->RightSlope, 0.0f );
    Planes[3] = XMVectorSet( -1.0f, 0.0f, pVolumeB->LeftSlope, 0.0f );
    Planes[4] = XMVectorSet( 0.0f, 1.0f, -pVolumeB->TopSlope, 0.0f );
    Planes[5] = XMVectorSet( 0.0f, -1.0f, pVolumeB->BottomSlope, 0.0f );

    // Normalize the planes so we can compare to the sphere radius.
    Planes[2] = XMVector3Normalize( Planes[2] );
    Planes[3] = XMVector3Normalize( Planes[3] );
    Planes[4] = XMVector3Normalize( Planes[4] );
    Planes[5] = XMVector3Normalize( Planes[5] );

    // Load origin and orientation of the frustum.
    XMVECTOR Origin = XMLoadFloat3( &pVolumeB->Origin );
    XMVECTOR Orientation = XMLoadFloat4( &pVolumeB->Orientation );

    XMASSERT( XMQuaternionIsUnit( Orientation ) );

    // Load the sphere.
    XMVECTOR Center = XMLoadFloat3( &pVolumeA->Center );
    XMVECTOR Radius = XMVectorReplicatePtr( &pVolumeA->Radius );

    // Transform the center of the sphere into the local space of frustum.
    Center = XMVector3InverseRotate( Center - Origin, Orientation );

    // Set w of the center to one so we can dot4 with the plane.
    Center = XMVectorInsert( Center, XMVectorSplatOne(), 0, 0, 0, 0, 1);

    // Check against each plane of the frustum.
    XMVECTOR Outside = XMVectorFalseInt();
    XMVECTOR InsideAll = XMVectorTrueInt();
    XMVECTOR CenterInsideAll = XMVectorTrueInt();

    XMVECTOR Dist[6];

    for( INT i = 0; i < 6; i++ )
    {
        Dist[i] = XMVector4Dot( Center, Planes[i] );

        // Outside the plane?
        Outside = XMVectorOrInt( Outside, XMVectorGreater( Dist[i], Radius ) );

        // Fully inside the plane?
        InsideAll = XMVectorAndInt( InsideAll, XMVectorLessOrEqual( Dist[i], -Radius ) );

        // Check if the center is inside the plane.
        CenterInsideAll = XMVectorAndInt( CenterInsideAll, XMVectorLessOrEqual( Dist[i], Zero ) );
    }

    // If the sphere is outside any of the planes it is outside. 
    if ( XMVector4EqualInt( Outside, XMVectorTrueInt() ) )
        return 0;

    // If the sphere is inside all planes it is fully inside.
    if ( XMVector4EqualInt( InsideAll, XMVectorTrueInt() ) )
        return 2;

    // If the center of the sphere is inside all planes and the sphere intersects 
    // one or more planes then it must intersect.
    if ( XMVector4EqualInt( CenterInsideAll, XMVectorTrueInt() ) )
        return 1;

    // The sphere may be outside the frustum or intersecting the frustum.
    // Find the nearest feature (face, edge, or corner) on the frustum 
    // to the sphere.

    // The faces adjacent to each face are:
    static const INT adjacent_faces[6][4] =
    {
        { 2, 3, 4, 5 },    // 0
        { 2, 3, 4, 5 },    // 1
        { 0, 1, 4, 5 },    // 2
        { 0, 1, 4, 5 },    // 3
        { 0, 1, 2, 3 },    // 4
        { 0, 1, 2, 3 }
    };  // 5

    XMVECTOR Intersects = XMVectorFalseInt();

    // Check to see if the nearest feature is one of the planes.
    for( INT i = 0; i < 6; i++ )
    {
        // Find the nearest point on the plane to the center of the sphere.
        XMVECTOR Point = Center - (Planes[i] * Dist[i]);

        // Set w of the point to one.
        Point = XMVectorInsert( Point, XMVectorSplatOne(), 0, 0, 0, 0, 1 );
        
        // If the point is inside the face (inside the adjacent planes) then
        // this plane is the nearest feature.
        XMVECTOR InsideFace = XMVectorTrueInt();
        
        for ( INT j = 0; j < 4; j++ )
        {
            INT plane_index = adjacent_faces[i][j];

            InsideFace = XMVectorAndInt( InsideFace,
                           XMVectorLessOrEqual( XMVector4Dot( Point, Planes[plane_index] ), Zero ) );
        }
     
        // Since we have already checked distance from the plane we know that the
        // sphere must intersect if this plane is the nearest feature.
        Intersects = XMVectorOrInt( Intersects, 
                                    XMVectorAndInt( XMVectorGreater( Dist[i], Zero ), InsideFace ) );
    }

    if ( XMVector4EqualInt( Intersects, XMVectorTrueInt() ) )
        return 1;

    // Build the corners of the frustum.
    XMVECTOR RightTop = XMVectorSet( pVolumeB->RightSlope, pVolumeB->TopSlope, 1.0f, 0.0f );
    XMVECTOR RightBottom = XMVectorSet( pVolumeB->RightSlope, pVolumeB->BottomSlope, 1.0f, 0.0f );
    XMVECTOR LeftTop = XMVectorSet( pVolumeB->LeftSlope, pVolumeB->TopSlope, 1.0f, 0.0f );
    XMVECTOR LeftBottom = XMVectorSet( pVolumeB->LeftSlope, pVolumeB->BottomSlope, 1.0f, 0.0f );
    XMVECTOR Near = XMVectorReplicatePtr( &pVolumeB->Near );
    XMVECTOR Far = XMVectorReplicatePtr( &pVolumeB->Far );

    XMVECTOR Corners[8];
    Corners[0] = RightTop * Near;
    Corners[1] = RightBottom * Near;
    Corners[2] = LeftTop * Near;
    Corners[3] = LeftBottom * Near;
    Corners[4] = RightTop * Far;
    Corners[5] = RightBottom * Far;
    Corners[6] = LeftTop * Far;
    Corners[7] = LeftBottom * Far;

    // The Edges are:
    static const INT edges[12][2] =
    {
        { 0, 1 }, { 2, 3 }, { 0, 2 }, { 1, 3 },    // Near plane
        { 4, 5 }, { 6, 7 }, { 4, 6 }, { 5, 7 },    // Far plane
        { 0, 4 }, { 1, 5 }, { 2, 6 }, { 3, 7 },
    }; // Near to far

    XMVECTOR RadiusSq = Radius * Radius;

    // Check to see if the nearest feature is one of the edges (or corners).
    for( INT i = 0; i < 12; i++ )
    {
        INT ei0 = edges[i][0];
        INT ei1 = edges[i][1];

        // Find the nearest point on the edge to the center of the sphere.
        // The corners of the frustum are included as the endpoints of the edges.
        XMVECTOR Point = PointOnLineSegmentNearestPoint( Corners[ei0], Corners[ei1], Center );

        XMVECTOR Delta = Center - Point;

        XMVECTOR DistSq = XMVector3Dot( Delta, Delta );

        // If the distance to the center of the sphere to the point is less than 
        // the radius of the sphere then it must intersect.
        Intersects = XMVectorOrInt( Intersects, XMVectorLessOrEqual( DistSq, RadiusSq ) );
    }

    if ( XMVector4EqualInt( Intersects, XMVectorTrueInt() ) )
        return 1;

    // The sphere must be outside the frustum.
    return 0;
}



//-----------------------------------------------------------------------------
// Exact axis alinged box vs frustum test.  Constructs an oriented box and uses
// the oriented box vs frustum test.
//
// Return values: 0 = no intersection, 
//                1 = intersection, 
//                2 = box is completely inside frustum
//-----------------------------------------------------------------------------
INT IntersectAxisAlignedBoxFrustum( const AxisAlignedBox* pVolumeA, const Frustum* pVolumeB )
{
    XMASSERT( pVolumeA );
    XMASSERT( pVolumeB );

    // Make the axis aligned box oriented and do an OBB vs frustum test.
    OrientedBox BoxA;

    BoxA.Center = pVolumeA->Center;
    BoxA.Extents = pVolumeA->Extents;
    BoxA.Orientation.x = 0.0f;
    BoxA.Orientation.y = 0.0f;
    BoxA.Orientation.z = 0.0f;
    BoxA.Orientation.w = 1.0f;

    return IntersectOrientedBoxFrustum( &BoxA, pVolumeB );
}


//-----------------------------------------------------------------------------
// Exact oriented box vs frustum test.
// Return values: 0 = no intersection, 
//                1 = intersection, 
//                2 = box is completely inside frustum
//-----------------------------------------------------------------------------
INT IntersectOrientedBoxFrustum( const OrientedBox* pVolumeA, const Frustum* pVolumeB )
{
    XMASSERT( pVolumeA );
    XMASSERT( pVolumeB );

    static const XMVECTORI32 SelectY =
    {
        XM_SELECT_0, XM_SELECT_1, XM_SELECT_0, XM_SELECT_0
    };
    static const XMVECTORI32 SelectZ =
    {
        XM_SELECT_0, XM_SELECT_0, XM_SELECT_1, XM_SELECT_0
    };

    XMVECTOR Zero = XMVectorZero();

    // Build the frustum planes.
    XMVECTOR Planes[6];
    Planes[0] = XMVectorSet( 0.0f, 0.0f, -1.0f, pVolumeB->Near );
    Planes[1] = XMVectorSet( 0.0f, 0.0f, 1.0f, -pVolumeB->Far );
    Planes[2] = XMVectorSet( 1.0f, 0.0f, -pVolumeB->RightSlope, 0.0f );
    Planes[3] = XMVectorSet( -1.0f, 0.0f, pVolumeB->LeftSlope, 0.0f );
    Planes[4] = XMVectorSet( 0.0f, 1.0f, -pVolumeB->TopSlope, 0.0f );
    Planes[5] = XMVectorSet( 0.0f, -1.0f, pVolumeB->BottomSlope, 0.0f );

    // Load origin and orientation of the frustum.
    XMVECTOR Origin = XMLoadFloat3( &pVolumeB->Origin );
    XMVECTOR FrustumOrientation = XMLoadFloat4( &pVolumeB->Orientation );

    XMASSERT( XMQuaternionIsUnit( FrustumOrientation ) );

    // Load the box.
    XMVECTOR Center = XMLoadFloat3( &pVolumeA->Center );
    XMVECTOR Extents = XMLoadFloat3( &pVolumeA->Extents );
    XMVECTOR BoxOrientation = XMLoadFloat4( &pVolumeA->Orientation );

    XMASSERT( XMQuaternionIsUnit( BoxOrientation ) );

    // Transform the oriented box into the space of the frustum in order to 
    // minimize the number of transforms we have to do.
    Center = XMVector3InverseRotate( Center - Origin, FrustumOrientation );
    BoxOrientation = XMQuaternionMultiply( BoxOrientation, XMQuaternionConjugate( FrustumOrientation ) );

    // Set w of the center to one so we can dot4 with the plane.
    Center = XMVectorInsert( Center, XMVectorSplatOne(), 0, 0, 0, 0, 1);

    // Build the 3x3 rotation matrix that defines the box axes.
    XMMATRIX R = XMMatrixRotationQuaternion( BoxOrientation );

    // Check against each plane of the frustum.
    XMVECTOR Outside = XMVectorFalseInt();
    XMVECTOR InsideAll = XMVectorTrueInt();
    XMVECTOR CenterInsideAll = XMVectorTrueInt();

    for( INT i = 0; i < 6; i++ )
    {
        // Compute the distance to the center of the box.
        XMVECTOR Dist = XMVector4Dot( Center, Planes[i] );

        // Project the axes of the box onto the normal of the plane.  Half the
        // length of the projection (sometime called the "radius") is equal to
        // h(u) * abs(n dot b(u))) + h(v) * abs(n dot b(v)) + h(w) * abs(n dot b(w))
        // where h(i) are extents of the box, n is the plane normal, and b(i) are the 
        // axes of the box.
        XMVECTOR Radius = XMVector3Dot( Planes[i], R.r[0] );
        Radius = XMVectorSelect( Radius, XMVector3Dot( Planes[i], R.r[1] ), SelectY );
        Radius = XMVectorSelect( Radius, XMVector3Dot( Planes[i], R.r[2] ), SelectZ );
        Radius = XMVector3Dot( Extents, XMVectorAbs( Radius ) );

        // Outside the plane?
        Outside = XMVectorOrInt( Outside, XMVectorGreater( Dist, Radius ) );

        // Fully inside the plane?
        InsideAll = XMVectorAndInt( InsideAll, XMVectorLessOrEqual( Dist, -Radius ) );

        // Check if the center is inside the plane.
        CenterInsideAll = XMVectorAndInt( CenterInsideAll, XMVectorLessOrEqual( Dist, Zero ) );
    }

    // If the box is outside any of the planes it is outside. 
    if ( XMVector4EqualInt( Outside, XMVectorTrueInt() ) )
        return 0;

    // If the box is inside all planes it is fully inside.
    if ( XMVector4EqualInt( InsideAll, XMVectorTrueInt() ) )
        return 2;

    // If the center of the box is inside all planes and the box intersects 
    // one or more planes then it must intersect.
    if ( XMVector4EqualInt( CenterInsideAll, XMVectorTrueInt() ) )
        return 1;

    // Build the corners of the frustum.
    XMVECTOR RightTop = XMVectorSet( pVolumeB->RightSlope, pVolumeB->TopSlope, 1.0f, 0.0f );
    XMVECTOR RightBottom = XMVectorSet( pVolumeB->RightSlope, pVolumeB->BottomSlope, 1.0f, 0.0f );
    XMVECTOR LeftTop = XMVectorSet( pVolumeB->LeftSlope, pVolumeB->TopSlope, 1.0f, 0.0f );
    XMVECTOR LeftBottom = XMVectorSet( pVolumeB->LeftSlope, pVolumeB->BottomSlope, 1.0f, 0.0f );
    XMVECTOR Near = XMVectorReplicatePtr( &pVolumeB->Near );
    XMVECTOR Far = XMVectorReplicatePtr( &pVolumeB->Far );

    XMVECTOR Corners[8];
    Corners[0] = RightTop * Near;
    Corners[1] = RightBottom * Near;
    Corners[2] = LeftTop * Near;
    Corners[3] = LeftBottom * Near;
    Corners[4] = RightTop * Far;
    Corners[5] = RightBottom * Far;
    Corners[6] = LeftTop * Far;
    Corners[7] = LeftBottom * Far;

    // Test against box axes (3)
    {
        // Find the min/max values of the projection of the frustum onto each axis.
        XMVECTOR FrustumMin, FrustumMax;

        FrustumMin = XMVector3Dot( Corners[0], R.r[0] );
        FrustumMin = XMVectorSelect( FrustumMin, XMVector3Dot( Corners[0], R.r[1] ), SelectY );
        FrustumMin = XMVectorSelect( FrustumMin, XMVector3Dot( Corners[0], R.r[2] ), SelectZ );
        FrustumMax = FrustumMin;

        for( INT i = 1; i < 8; i++ )
        {
            XMVECTOR Temp = XMVector3Dot( Corners[i], R.r[0] );
            Temp = XMVectorSelect( Temp, XMVector3Dot( Corners[i], R.r[1] ), SelectY );
            Temp = XMVectorSelect( Temp, XMVector3Dot( Corners[i], R.r[2] ), SelectZ );

            FrustumMin = XMVectorMin( FrustumMin, Temp );
            FrustumMax = XMVectorMax( FrustumMax, Temp );
        }

        // Project the center of the box onto the axes.
        XMVECTOR BoxDist = XMVector3Dot( Center, R.r[0] );
        BoxDist = XMVectorSelect( BoxDist, XMVector3Dot( Center, R.r[1] ), SelectY );
        BoxDist = XMVectorSelect( BoxDist, XMVector3Dot( Center, R.r[2] ), SelectZ );

        // The projection of the box onto the axis is just its Center and Extents.
        // if (min > box_max || max < box_min) reject;
        XMVECTOR Result = XMVectorOrInt( XMVectorGreater( FrustumMin, BoxDist + Extents ),
                                          XMVectorLess( FrustumMax, BoxDist - Extents ) );

        if( XMVector3AnyTrue( Result ) )
            return 0;
    }

    // Test against edge/edge axes (3*6).
    XMVECTOR FrustumEdgeAxis[6];

    FrustumEdgeAxis[0] = RightTop;
    FrustumEdgeAxis[1] = RightBottom;
    FrustumEdgeAxis[2] = LeftTop;
    FrustumEdgeAxis[3] = LeftBottom;
    FrustumEdgeAxis[4] = RightTop - LeftTop;
    FrustumEdgeAxis[5] = LeftBottom - LeftTop;

    for( INT i = 0; i < 3; i++ )
    {
        for( INT j = 0; j < 6; j++ )
        {
            // Compute the axis we are going to test.
            XMVECTOR Axis = XMVector3Cross( R.r[i], FrustumEdgeAxis[j] );

            // Find the min/max values of the projection of the frustum onto the axis.
            XMVECTOR FrustumMin, FrustumMax;

            FrustumMin = FrustumMax = XMVector3Dot( Axis, Corners[0] );

            for( INT k = 1; k < 8; k++ )
            {
                XMVECTOR Temp = XMVector3Dot( Axis, Corners[k] );
                FrustumMin = XMVectorMin( FrustumMin, Temp );
                FrustumMax = XMVectorMax( FrustumMax, Temp );
            }

            // Project the center of the box onto the axis.
            XMVECTOR Dist = XMVector3Dot( Center, Axis );

            // Project the axes of the box onto the axis to find the "radius" of the box.
            XMVECTOR Radius = XMVector3Dot( Axis, R.r[0] );
            Radius = XMVectorSelect( Radius, XMVector3Dot( Axis, R.r[1] ), SelectY );
            Radius = XMVectorSelect( Radius, XMVector3Dot( Axis, R.r[2] ), SelectZ );
            Radius = XMVector3Dot( Extents, XMVectorAbs( Radius ) );

            // if (center > max + radius || center < min - radius) reject;
            Outside = XMVectorOrInt( Outside, XMVectorGreater( Dist, FrustumMax + Radius ) );
            Outside = XMVectorOrInt( Outside, XMVectorLess( Dist, FrustumMin - Radius ) );
        }
    }

    if ( XMVector4EqualInt( Outside, XMVectorTrueInt() ) )
        return 0;

    // If we did not find a separating plane then the box must intersect the frustum.
    return 1;
}



//-----------------------------------------------------------------------------
// Exact frustum vs frustum test.
// Return values: 0 = no intersection, 
//                1 = intersection, 
//                2 = frustum A is completely inside frustum B
//-----------------------------------------------------------------------------
INT IntersectFrustumFrustum( const Frustum* pVolumeA, const Frustum* pVolumeB )
{
    XMASSERT( pVolumeA );
    XMASSERT( pVolumeB );

    // Load origin and orientation of frustum B.
    XMVECTOR OriginB = XMLoadFloat3( &pVolumeB->Origin );
    XMVECTOR OrientationB = XMLoadFloat4( &pVolumeB->Orientation );

    XMASSERT( XMQuaternionIsUnit( OrientationB ) );

    // Build the planes of frustum B.
    XMVECTOR AxisB[6];
    AxisB[0] = XMVectorSet( 0.0f, 0.0f, -1.0f, 0.0f );
    AxisB[1] = XMVectorSet( 0.0f, 0.0f, 1.0f, 0.0f );
    AxisB[2] = XMVectorSet( 1.0f, 0.0f, -pVolumeB->RightSlope, 0.0f );
    AxisB[3] = XMVectorSet( -1.0f, 0.0f, pVolumeB->LeftSlope, 0.0f );
    AxisB[4] = XMVectorSet( 0.0f, 1.0f, -pVolumeB->TopSlope, 0.0f );
    AxisB[5] = XMVectorSet( 0.0f, -1.0f, pVolumeB->BottomSlope, 0.0f );

    XMVECTOR PlaneDistB[6];
    PlaneDistB[0] = -XMVectorReplicatePtr( &pVolumeB->Near );
    PlaneDistB[1] = XMVectorReplicatePtr( &pVolumeB->Far );
    PlaneDistB[2] = XMVectorZero();
    PlaneDistB[3] = XMVectorZero();
    PlaneDistB[4] = XMVectorZero();
    PlaneDistB[5] = XMVectorZero();

    // Load origin and orientation of frustum A.
    XMVECTOR OriginA = XMLoadFloat3( &pVolumeA->Origin );
    XMVECTOR OrientationA = XMLoadFloat4( &pVolumeA->Orientation );

    XMASSERT( XMQuaternionIsUnit( OrientationA ) );

    // Transform frustum A into the space of the frustum B in order to 
    // minimize the number of transforms we have to do.
    OriginA = XMVector3InverseRotate( OriginA - OriginB, OrientationB );
    OrientationA = XMQuaternionMultiply( OrientationA, XMQuaternionConjugate( OrientationB ) );

    // Build the corners of frustum A (in the local space of B).
    XMVECTOR RightTopA = XMVectorSet( pVolumeA->RightSlope, pVolumeA->TopSlope, 1.0f, 0.0f );
    XMVECTOR RightBottomA = XMVectorSet( pVolumeA->RightSlope, pVolumeA->BottomSlope, 1.0f, 0.0f );
    XMVECTOR LeftTopA = XMVectorSet( pVolumeA->LeftSlope, pVolumeA->TopSlope, 1.0f, 0.0f );
    XMVECTOR LeftBottomA = XMVectorSet( pVolumeA->LeftSlope, pVolumeA->BottomSlope, 1.0f, 0.0f );
    XMVECTOR NearA = XMVectorReplicatePtr( &pVolumeA->Near );
    XMVECTOR FarA = XMVectorReplicatePtr( &pVolumeA->Far );

    RightTopA = XMVector3Rotate( RightTopA, OrientationA );
    RightBottomA = XMVector3Rotate( RightBottomA, OrientationA );
    LeftTopA = XMVector3Rotate( LeftTopA, OrientationA );
    LeftBottomA = XMVector3Rotate( LeftBottomA, OrientationA );

    XMVECTOR CornersA[8];
    CornersA[0] = OriginA + RightTopA * NearA;
    CornersA[1] = OriginA + RightBottomA * NearA;
    CornersA[2] = OriginA + LeftTopA * NearA;
    CornersA[3] = OriginA + LeftBottomA * NearA;
    CornersA[4] = OriginA + RightTopA * FarA;
    CornersA[5] = OriginA + RightBottomA * FarA;
    CornersA[6] = OriginA + LeftTopA * FarA;
    CornersA[7] = OriginA + LeftBottomA * FarA;

    // Check frustum A against each plane of frustum B.
    XMVECTOR Outside = XMVectorFalseInt();
    XMVECTOR InsideAll = XMVectorTrueInt();

    for( INT i = 0; i < 6; i++ )
    {
        // Find the min/max projection of the frustum onto the plane normal.
        XMVECTOR Min, Max;

        Min = Max = XMVector3Dot( AxisB[i], CornersA[0] );

        for( INT j = 1; j < 8; j++ )
        {
            XMVECTOR Temp = XMVector3Dot( AxisB[i], CornersA[j] );
            Min = XMVectorMin( Min, Temp );
            Max = XMVectorMax( Max, Temp );
        }

        // Outside the plane?
        Outside = XMVectorOrInt( Outside, XMVectorGreater( Min, PlaneDistB[i] ) );

        // Fully inside the plane?
        InsideAll = XMVectorAndInt( InsideAll, XMVectorLessOrEqual( Max, PlaneDistB[i] ) );
    }

    // If the frustum A is outside any of the planes of frustum B it is outside. 
    if ( XMVector4EqualInt( Outside, XMVectorTrueInt() ) )
        return 0;

    // If frustum A is inside all planes of frustum B it is fully inside.
    if ( XMVector4EqualInt( InsideAll, XMVectorTrueInt() ) )
        return 2;

    // Build the corners of frustum B.
    XMVECTOR RightTopB = XMVectorSet( pVolumeB->RightSlope, pVolumeB->TopSlope, 1.0f, 0.0f );
    XMVECTOR RightBottomB = XMVectorSet( pVolumeB->RightSlope, pVolumeB->BottomSlope, 1.0f, 0.0f );
    XMVECTOR LeftTopB = XMVectorSet( pVolumeB->LeftSlope, pVolumeB->TopSlope, 1.0f, 0.0f );
    XMVECTOR LeftBottomB = XMVectorSet( pVolumeB->LeftSlope, pVolumeB->BottomSlope, 1.0f, 0.0f );
    XMVECTOR NearB = XMVectorReplicatePtr( &pVolumeB->Near );
    XMVECTOR FarB = XMVectorReplicatePtr( &pVolumeB->Far );

    XMVECTOR CornersB[8];
    CornersB[0] = RightTopB * NearB;
    CornersB[1] = RightBottomB * NearB;
    CornersB[2] = LeftTopB * NearB;
    CornersB[3] = LeftBottomB * NearB;
    CornersB[4] = RightTopB * FarB;
    CornersB[5] = RightBottomB * FarB;
    CornersB[6] = LeftTopB * FarB;
    CornersB[7] = LeftBottomB * FarB;

    // Build the planes of frustum A (in the local space of B).
    XMVECTOR AxisA[6];
    XMVECTOR PlaneDistA[6];

    AxisA[0] = XMVectorSet( 0.0f, 0.0f, -1.0f, 0.0f );
    AxisA[1] = XMVectorSet( 0.0f, 0.0f, 1.0f, 0.0f );
    AxisA[2] = XMVectorSet( 1.0f, 0.0f, -pVolumeA->RightSlope, 0.0f );
    AxisA[3] = XMVectorSet( -1.0f, 0.0f, pVolumeA->LeftSlope, 0.0f );
    AxisA[4] = XMVectorSet( 0.0f, 1.0f, -pVolumeA->TopSlope, 0.0f );
    AxisA[5] = XMVectorSet( 0.0f, -1.0f, pVolumeA->BottomSlope, 0.0f );

    AxisA[0] = XMVector3Rotate( AxisA[0], OrientationA );
    AxisA[1] = -AxisA[0];
    AxisA[2] = XMVector3Rotate( AxisA[2], OrientationA );
    AxisA[3] = XMVector3Rotate( AxisA[3], OrientationA );
    AxisA[4] = XMVector3Rotate( AxisA[4], OrientationA );
    AxisA[5] = XMVector3Rotate( AxisA[5], OrientationA );

    PlaneDistA[0] = XMVector3Dot( AxisA[0], CornersA[0] );  // Re-use corner on near plane.
    PlaneDistA[1] = XMVector3Dot( AxisA[1], CornersA[4] );  // Re-use corner on far plane.
    PlaneDistA[2] = XMVector3Dot( AxisA[2], OriginA );
    PlaneDistA[3] = XMVector3Dot( AxisA[3], OriginA );
    PlaneDistA[4] = XMVector3Dot( AxisA[4], OriginA );
    PlaneDistA[5] = XMVector3Dot( AxisA[5], OriginA );

    // Check each axis of frustum A for a seperating plane (5).
    for( INT i = 0; i < 6; i++ )
    {
        // Find the minimum projection of the frustum onto the plane normal.
        XMVECTOR Min;

        Min = XMVector3Dot( AxisA[i], CornersB[0] );

        for( INT j = 1; j < 8; j++ )
        {
            XMVECTOR Temp = XMVector3Dot( AxisA[i], CornersB[j] );
            Min = XMVectorMin( Min, Temp );
        }

        // Outside the plane?
        Outside = XMVectorOrInt( Outside, XMVectorGreater( Min, PlaneDistA[i] ) );
    }

    // If the frustum B is outside any of the planes of frustum A it is outside. 
    if ( XMVector4EqualInt( Outside, XMVectorTrueInt() ) )
        return 0;

    // Check edge/edge axes (6 * 6).
    XMVECTOR FrustumEdgeAxisA[6];
    FrustumEdgeAxisA[0] = RightTopA;
    FrustumEdgeAxisA[1] = RightBottomA;
    FrustumEdgeAxisA[2] = LeftTopA;
    FrustumEdgeAxisA[3] = LeftBottomA;
    FrustumEdgeAxisA[4] = RightTopA - LeftTopA;
    FrustumEdgeAxisA[5] = LeftBottomA - LeftTopA;

    XMVECTOR FrustumEdgeAxisB[6];
    FrustumEdgeAxisB[0] = RightTopB;
    FrustumEdgeAxisB[1] = RightBottomB;
    FrustumEdgeAxisB[2] = LeftTopB;
    FrustumEdgeAxisB[3] = LeftBottomB;
    FrustumEdgeAxisB[4] = RightTopB - LeftTopB;
    FrustumEdgeAxisB[5] = LeftBottomB - LeftTopB;

    for( INT i = 0; i < 6; i++ )
    {
        for( INT j = 0; j < 6; j++ )
        {
            // Compute the axis we are going to test.
            XMVECTOR Axis = XMVector3Cross( FrustumEdgeAxisA[i], FrustumEdgeAxisB[j] );

            // Find the min/max values of the projection of both frustums onto the axis.
            XMVECTOR MinA, MaxA;
            XMVECTOR MinB, MaxB;

            MinA = MaxA = XMVector3Dot( Axis, CornersA[0] );
            MinB = MaxB = XMVector3Dot( Axis, CornersB[0] );

            for( INT k = 1; k < 8; k++ )
            {
                XMVECTOR TempA = XMVector3Dot( Axis, CornersA[k] );
                MinA = XMVectorMin( MinA, TempA );
                MaxA = XMVectorMax( MaxA, TempA );

                XMVECTOR TempB = XMVector3Dot( Axis, CornersB[k] );
                MinB = XMVectorMin( MinB, TempB );
                MaxB = XMVectorMax( MaxB, TempB );
            }

            // if (MinA > MaxB || MinB > MaxA) reject
            Outside = XMVectorOrInt( Outside, XMVectorGreater( MinA, MaxB ) );
            Outside = XMVectorOrInt( Outside, XMVectorGreater( MinB, MaxA ) );
        }
    }

    // If there is a seperating plane, then the frustums do not intersect.
    if ( XMVector4EqualInt( Outside, XMVectorTrueInt() ) )
        return 0;

    // If we did not find a separating plane then the frustums intersect.
    return 1;
}



//-----------------------------------------------------------------------------
static inline void FastIntersectTrianglePlane( FXMVECTOR V0, FXMVECTOR V1, FXMVECTOR V2, CXMVECTOR Plane,
                                        XMVECTOR& Outside, XMVECTOR& Inside )
{
    // Plane0
    XMVECTOR Dist0 = XMVector4Dot( V0, Plane );
    XMVECTOR Dist1 = XMVector4Dot( V1, Plane );
    XMVECTOR Dist2 = XMVector4Dot( V2, Plane );

    XMVECTOR MinDist = XMVectorMin( Dist0, Dist1 );
    MinDist = XMVectorMin( MinDist, Dist2 );

    XMVECTOR MaxDist = XMVectorMax( Dist0, Dist1 );
    MaxDist = XMVectorMax( MaxDist, Dist2 );

    XMVECTOR Zero = XMVectorZero();

    // Outside the plane?
    Outside = XMVectorGreater( MinDist, Zero );

    // Fully inside the plane?
    Inside = XMVectorLess( MaxDist, Zero );
}



//-----------------------------------------------------------------------------
// Test a triangle vs 6 planes (typically forming a frustum).
// Return values: 0 = no intersection, 
//                1 = may be intersecting, 
//                2 = triangle is inside all planes
//-----------------------------------------------------------------------------
INT IntersectTriangle6Planes( FXMVECTOR V0, FXMVECTOR V1, FXMVECTOR V2, CXMVECTOR Plane0, CXMVECTOR Plane1,
                              CXMVECTOR Plane2, CXMVECTOR Plane3, CXMVECTOR Plane4, CXMVECTOR Plane5 )
{
    XMVECTOR One = XMVectorSplatOne();

    // Set w of the points to one so we can dot4 with a plane.
    XMVECTOR TV0 = XMVectorInsert(V0, One, 0, 0, 0, 0, 1);
    XMVECTOR TV1 = XMVectorInsert(V1, One, 0, 0, 0, 0, 1);
    XMVECTOR TV2 = XMVectorInsert(V2, One, 0, 0, 0, 0, 1);

    XMVECTOR Outside, Inside;

    // Test against each plane.
    FastIntersectTrianglePlane( TV0, TV1, TV2, Plane0, Outside, Inside );

    XMVECTOR AnyOutside = Outside;
    XMVECTOR AllInside = Inside;

    FastIntersectTrianglePlane( TV0, TV1, TV2, Plane1, Outside, Inside );
    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    FastIntersectTrianglePlane( TV0, TV1, TV2, Plane2, Outside, Inside );
    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    FastIntersectTrianglePlane( TV0, TV1, TV2, Plane3, Outside, Inside );
    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    FastIntersectTrianglePlane( TV0, TV1, TV2, Plane4, Outside, Inside );
    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    FastIntersectTrianglePlane( TV0, TV1, TV2, Plane5, Outside, Inside );
    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    // If the triangle is outside any plane it is outside.
    if ( XMVector4EqualInt( AnyOutside, XMVectorTrueInt() ) )
        return 0;

    // If the triangle is inside all planes it is inside.
    if ( XMVector4EqualInt( AllInside, XMVectorTrueInt() ) )
        return 2;

    // The triangle is not inside all planes or outside a plane, it may intersect.
    return 1;
}



//-----------------------------------------------------------------------------
static inline void FastIntersectSpherePlane( FXMVECTOR Center, FXMVECTOR Radius, FXMVECTOR Plane,
                                      XMVECTOR& Outside, XMVECTOR& Inside )
{
    XMVECTOR Dist = XMVector4Dot( Center, Plane );

    // Outside the plane?
    Outside = XMVectorGreater( Dist, Radius );

    // Fully inside the plane?
    Inside = XMVectorLess( Dist, -Radius );
}



//-----------------------------------------------------------------------------
// Test a sphere vs 6 planes (typically forming a frustum).
// Return values: 0 = no intersection, 
//                1 = may be intersecting, 
//                2 = sphere is inside all planes
//-----------------------------------------------------------------------------
INT IntersectSphere6Planes( const Sphere* pVolume, FXMVECTOR Plane0, FXMVECTOR Plane1, FXMVECTOR Plane2,
                            CXMVECTOR Plane3, CXMVECTOR Plane4, CXMVECTOR Plane5 )
{
    XMASSERT( pVolume );

    // Load the sphere.
    XMVECTOR Center = XMLoadFloat3( &pVolume->Center );
    XMVECTOR Radius = XMVectorReplicatePtr( &pVolume->Radius );

    // Set w of the center to one so we can dot4 with a plane.
    Center = XMVectorInsert( Center, XMVectorSplatOne(), 0, 0, 0, 0, 1);

    XMVECTOR Outside, Inside;

    // Test against each plane.
    FastIntersectSpherePlane( Center, Radius, Plane0, Outside, Inside );

    XMVECTOR AnyOutside = Outside;
    XMVECTOR AllInside = Inside;

    FastIntersectSpherePlane( Center, Radius, Plane1, Outside, Inside );
    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    FastIntersectSpherePlane( Center, Radius, Plane2, Outside, Inside );
    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    FastIntersectSpherePlane( Center, Radius, Plane3, Outside, Inside );
    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    FastIntersectSpherePlane( Center, Radius, Plane4, Outside, Inside );
    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    FastIntersectSpherePlane( Center, Radius, Plane5, Outside, Inside );
    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    // If the sphere is outside any plane it is outside.
    if ( XMVector4EqualInt( AnyOutside, XMVectorTrueInt() ) )
        return 0;

    // If the sphere is inside all planes it is inside.
    if ( XMVector4EqualInt( AllInside, XMVectorTrueInt() ) )
        return 2;

    // The sphere is not inside all planes or outside a plane, it may intersect.
    return 1;
}



//-----------------------------------------------------------------------------
static inline void FastIntersectAxisAlignedBoxPlane( FXMVECTOR Center, FXMVECTOR Extents, FXMVECTOR Plane,
                                              XMVECTOR& Outside, XMVECTOR& Inside )
{
    // Compute the distance to the center of the box.
    XMVECTOR Dist = XMVector4Dot( Center, Plane );

    // Project the axes of the box onto the normal of the plane.  Half the
    // length of the projection (sometime called the "radius") is equal to
    // h(u) * abs(n dot b(u))) + h(v) * abs(n dot b(v)) + h(w) * abs(n dot b(w))
    // where h(i) are extents of the box, n is the plane normal, and b(i) are the 
    // axes of the box. In this case b(i) = [(1,0,0), (0,1,0), (0,0,1)].
    XMVECTOR Radius = XMVector3Dot( Extents, XMVectorAbs( Plane ) );

    // Outside the plane?
    Outside = XMVectorGreater( Dist, Radius );

    // Fully inside the plane?
    Inside = XMVectorLess( Dist, -Radius );
}



//-----------------------------------------------------------------------------
// Test an axis alinged box vs 6 planes (typically forming a frustum).
// Return values: 0 = no intersection, 
//                1 = may be intersecting, 
//                2 = box is inside all planes
//-----------------------------------------------------------------------------
INT IntersectAxisAlignedBox6Planes( const AxisAlignedBox* pVolume, FXMVECTOR Plane0, FXMVECTOR Plane1,
                                    FXMVECTOR Plane2, CXMVECTOR Plane3, CXMVECTOR Plane4, CXMVECTOR Plane5 )
{
    XMASSERT( pVolume );

    // Load the box.
    XMVECTOR Center = XMLoadFloat3( &pVolume->Center );
    XMVECTOR Extents = XMLoadFloat3( &pVolume->Extents );

    // Set w of the center to one so we can dot4 with a plane.
    Center = XMVectorInsert( Center, XMVectorSplatOne(), 0, 0, 0, 0, 1 );

    XMVECTOR Outside, Inside;

    // Test against each plane.
    FastIntersectAxisAlignedBoxPlane( Center, Extents, Plane0, Outside, Inside );

    XMVECTOR AnyOutside = Outside;
    XMVECTOR AllInside = Inside;

    FastIntersectAxisAlignedBoxPlane( Center, Extents, Plane1, Outside, Inside );
    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    FastIntersectAxisAlignedBoxPlane( Center, Extents, Plane2, Outside, Inside );
    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    FastIntersectAxisAlignedBoxPlane( Center, Extents, Plane3, Outside, Inside );
    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    FastIntersectAxisAlignedBoxPlane( Center, Extents, Plane4, Outside, Inside );
    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    FastIntersectAxisAlignedBoxPlane( Center, Extents, Plane5, Outside, Inside );
    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    // If the box is outside any plane it is outside.
    if ( XMVector4EqualInt( AnyOutside, XMVectorTrueInt() ) )
        return 0;

    // If the box is inside all planes it is inside.
    if ( XMVector4EqualInt( AllInside, XMVectorTrueInt() ) )
        return 2;

    // The box is not inside all planes or outside a plane, it may intersect.
    return 1;
}



//-----------------------------------------------------------------------------
static inline void FastIntersectOrientedBoxPlane( FXMVECTOR Center, FXMVECTOR Extents, FXMVECTOR Axis0, CXMVECTOR Axis1,
                                          CXMVECTOR Axis2, CXMVECTOR Plane, XMVECTOR& Outside, XMVECTOR& Inside )
{
    // Compute the distance to the center of the box.
    XMVECTOR Dist = XMVector4Dot( Center, Plane );

    // Project the axes of the box onto the normal of the plane.  Half the
    // length of the projection (sometime called the "radius") is equal to
    // h(u) * abs(n dot b(u))) + h(v) * abs(n dot b(v)) + h(w) * abs(n dot b(w))
    // where h(i) are extents of the box, n is the plane normal, and b(i) are the 
    // axes of the box.
    XMVECTOR Radius = XMVector3Dot( Plane, Axis0 );
    Radius = XMVectorInsert( Radius, XMVector3Dot( Plane, Axis1 ), 0, 0, 1, 0, 0 );
    Radius = XMVectorInsert( Radius, XMVector3Dot( Plane, Axis2 ), 0, 0, 0, 1, 0 );
    Radius = XMVector3Dot( Extents, XMVectorAbs( Radius ) );

    // Outside the plane?
    Outside = XMVectorGreater( Dist, Radius );

    // Fully inside the plane?
    Inside = XMVectorLess( Dist, -Radius );
}



//-----------------------------------------------------------------------------
// Test an oriented box vs 6 planes (typically forming a frustum).
// Return values: 0 = no intersection, 
//                1 = may be intersecting, 
//                2 = box is inside all planes
//-----------------------------------------------------------------------------
INT IntersectOrientedBox6Planes( const OrientedBox* pVolume, FXMVECTOR Plane0, FXMVECTOR Plane1, FXMVECTOR Plane2,
                                 CXMVECTOR Plane3, CXMVECTOR Plane4, CXMVECTOR Plane5 )
{
    XMASSERT( pVolume );

    // Load the box.
    XMVECTOR Center = XMLoadFloat3( &pVolume->Center );
    XMVECTOR Extents = XMLoadFloat3( &pVolume->Extents );
    XMVECTOR BoxOrientation = XMLoadFloat4( &pVolume->Orientation );

    XMASSERT( XMQuaternionIsUnit( BoxOrientation ) );

    // Set w of the center to one so we can dot4 with a plane.
    Center = XMVectorInsert( Center, XMVectorSplatOne(), 0, 0, 0, 0, 1 );

    // Build the 3x3 rotation matrix that defines the box axes.
    XMMATRIX R = XMMatrixRotationQuaternion( BoxOrientation );

    XMVECTOR Outside, Inside;

    // Test against each plane.
    FastIntersectOrientedBoxPlane( Center, Extents, R.r[0], R.r[1], R.r[2], Plane0, Outside, Inside );

    XMVECTOR AnyOutside = Outside;
    XMVECTOR AllInside = Inside;

    FastIntersectOrientedBoxPlane( Center, Extents, R.r[0], R.r[1], R.r[2], Plane1, Outside, Inside );
    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    FastIntersectOrientedBoxPlane( Center, Extents, R.r[0], R.r[1], R.r[2], Plane2, Outside, Inside );
    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    FastIntersectOrientedBoxPlane( Center, Extents, R.r[0], R.r[1], R.r[2], Plane3, Outside, Inside );
    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    FastIntersectOrientedBoxPlane( Center, Extents, R.r[0], R.r[1], R.r[2], Plane4, Outside, Inside );
    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    FastIntersectOrientedBoxPlane( Center, Extents, R.r[0], R.r[1], R.r[2], Plane5, Outside, Inside );
    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    // If the box is outside any plane it is outside.
    if ( XMVector4EqualInt( AnyOutside, XMVectorTrueInt() ) )
        return 0;

    // If the box is inside all planes it is inside.
    if ( XMVector4EqualInt( AllInside, XMVectorTrueInt() ) )
        return 2;

    // The box is not inside all planes or outside a plane, it may intersect.
    return 1;
}



//-----------------------------------------------------------------------------
static inline void FastIntersectFrustumPlane( FXMVECTOR Point0, FXMVECTOR Point1, FXMVECTOR Point2, CXMVECTOR Point3,
                                      CXMVECTOR Point4, CXMVECTOR Point5, CXMVECTOR Point6, CXMVECTOR Point7,
                                      CXMVECTOR Plane, XMVECTOR& Outside, XMVECTOR& Inside )
{
    // Find the min/max projection of the frustum onto the plane normal.
    XMVECTOR Min, Max, Dist;

    Min = Max = XMVector3Dot( Plane, Point0 );

    Dist = XMVector3Dot( Plane, Point1 );
    Min = XMVectorMin( Min, Dist );
    Max = XMVectorMax( Max, Dist );

    Dist = XMVector3Dot( Plane, Point2 );
    Min = XMVectorMin( Min, Dist );
    Max = XMVectorMax( Max, Dist );

    Dist = XMVector3Dot( Plane, Point3 );
    Min = XMVectorMin( Min, Dist );
    Max = XMVectorMax( Max, Dist );

    Dist = XMVector3Dot( Plane, Point4 );
    Min = XMVectorMin( Min, Dist );
    Max = XMVectorMax( Max, Dist );

    Dist = XMVector3Dot( Plane, Point5 );
    Min = XMVectorMin( Min, Dist );
    Max = XMVectorMax( Max, Dist );

    Dist = XMVector3Dot( Plane, Point6 );
    Min = XMVectorMin( Min, Dist );
    Max = XMVectorMax( Max, Dist );

    Dist = XMVector3Dot( Plane, Point7 );
    Min = XMVectorMin( Min, Dist );
    Max = XMVectorMax( Max, Dist );

    XMVECTOR PlaneDist = -XMVectorSplatW( Plane );

    // Outside the plane?
    Outside = XMVectorGreater( Min, PlaneDist );

    // Fully inside the plane?
    Inside = XMVectorLess( Max, PlaneDist );
}



//-----------------------------------------------------------------------------
// Test a frustum vs 6 planes (typically forming another frustum).
// Return values: 0 = no intersection, 
//                1 = may be intersecting, 
//                2 = frustum is inside all planes
//-----------------------------------------------------------------------------
INT IntersectFrustum6Planes( const Frustum* pVolume, FXMVECTOR Plane0, FXMVECTOR Plane1, FXMVECTOR Plane2,
                             CXMVECTOR Plane3, CXMVECTOR Plane4, CXMVECTOR Plane5 )
{
    XMASSERT( pVolume );

    // Load origin and orientation of the frustum.
    XMVECTOR Origin = XMLoadFloat3( &pVolume->Origin );
    XMVECTOR Orientation = XMLoadFloat4( &pVolume->Orientation );

    XMASSERT( XMQuaternionIsUnit( Orientation ) );

    // Set w of the origin to one so we can dot4 with a plane.
    Origin = XMVectorInsert( Origin, XMVectorSplatOne(), 0, 0, 0, 0, 1 );

    // Build the corners of the frustum (in world space).
    XMVECTOR RightTop = XMVectorSet( pVolume->RightSlope, pVolume->TopSlope, 1.0f, 0.0f );
    XMVECTOR RightBottom = XMVectorSet( pVolume->RightSlope, pVolume->BottomSlope, 1.0f, 0.0f );
    XMVECTOR LeftTop = XMVectorSet( pVolume->LeftSlope, pVolume->TopSlope, 1.0f, 0.0f );
    XMVECTOR LeftBottom = XMVectorSet( pVolume->LeftSlope, pVolume->BottomSlope, 1.0f, 0.0f );
    XMVECTOR Near = XMVectorSet( pVolume->Near, pVolume->Near, pVolume->Near, 0.0f );
    XMVECTOR Far = XMVectorSet( pVolume->Far, pVolume->Far, pVolume->Far, 0.0f );

    RightTop = XMVector3Rotate( RightTop, Orientation );
    RightBottom = XMVector3Rotate( RightBottom, Orientation );
    LeftTop = XMVector3Rotate( LeftTop, Orientation );
    LeftBottom = XMVector3Rotate( LeftBottom, Orientation );

    XMVECTOR Corners0 = Origin + RightTop * Near;
    XMVECTOR Corners1 = Origin + RightBottom * Near;
    XMVECTOR Corners2 = Origin + LeftTop * Near;
    XMVECTOR Corners3 = Origin + LeftBottom * Near;
    XMVECTOR Corners4 = Origin + RightTop * Far;
    XMVECTOR Corners5 = Origin + RightBottom * Far;
    XMVECTOR Corners6 = Origin + LeftTop * Far;
    XMVECTOR Corners7 = Origin + LeftBottom * Far;

    XMVECTOR Outside, Inside;

    // Test against each plane.
    FastIntersectFrustumPlane( Corners0, Corners1, Corners2, Corners3, 
                               Corners4, Corners5, Corners6, Corners7, 
                               Plane0, Outside, Inside );

    XMVECTOR AnyOutside = Outside;
    XMVECTOR AllInside = Inside;

    FastIntersectFrustumPlane( Corners0, Corners1, Corners2, Corners3, 
                               Corners4, Corners5, Corners6, Corners7, 
                               Plane1, Outside, Inside );

    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    FastIntersectFrustumPlane( Corners0, Corners1, Corners2, Corners3, 
                               Corners4, Corners5, Corners6, Corners7, 
                               Plane2, Outside, Inside );

    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    FastIntersectFrustumPlane( Corners0, Corners1, Corners2, Corners3, 
                               Corners4, Corners5, Corners6, Corners7, 
                               Plane3, Outside, Inside );

    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    FastIntersectFrustumPlane( Corners0, Corners1, Corners2, Corners3, 
                               Corners4, Corners5, Corners6, Corners7, 
                               Plane4, Outside, Inside );

    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    FastIntersectFrustumPlane( Corners0, Corners1, Corners2, Corners3, 
                               Corners4, Corners5, Corners6, Corners7, 
                               Plane5, Outside, Inside );

    AnyOutside = XMVectorOrInt( AnyOutside, Outside );
    AllInside = XMVectorAndInt( AllInside, Inside );

    // If the frustum is outside any plane it is outside.
    if ( XMVector4EqualInt( AnyOutside, XMVectorTrueInt() ) )
        return 0;

    // If the frustum is inside all planes it is inside.
    if ( XMVector4EqualInt( AllInside, XMVectorTrueInt() ) )
        return 2;

    // The frustum is not inside all planes or outside a plane, it may intersect.
    return 1;
}



//-----------------------------------------------------------------------------
INT IntersectTrianglePlane( FXMVECTOR V0, FXMVECTOR V1, FXMVECTOR V2, CXMVECTOR Plane )
{
    XMVECTOR One = XMVectorSplatOne();

    XMASSERT( XMPlaneIsUnit( Plane ) );

    // Set w of the points to one so we can dot4 with a plane.
    XMVECTOR TV0 = XMVectorInsert(V0, One, 0, 0, 0, 0, 1);
    XMVECTOR TV1 = XMVectorInsert(V1, One, 0, 0, 0, 0, 1);
    XMVECTOR TV2 = XMVectorInsert(V2, One, 0, 0, 0, 0, 1);

    XMVECTOR Outside, Inside;
    FastIntersectTrianglePlane( TV0, TV1, TV2, Plane, Outside, Inside );

    // If the triangle is outside any plane it is outside.
    if ( XMVector4EqualInt( Outside, XMVectorTrueInt() ) )
        return 0;

    // If the triangle is inside all planes it is inside.
    if ( XMVector4EqualInt( Inside, XMVectorTrueInt() ) )
        return 2;

    // The triangle is not inside all planes or outside a plane it intersects.
    return 1;
}



//-----------------------------------------------------------------------------
INT IntersectSpherePlane( const Sphere* pVolume, FXMVECTOR Plane )
{
    XMASSERT( pVolume );
    XMASSERT( XMPlaneIsUnit( Plane ) );

    // Load the sphere.
    XMVECTOR Center = XMLoadFloat3( &pVolume->Center );
    XMVECTOR Radius = XMVectorReplicatePtr( &pVolume->Radius );

    // Set w of the center to one so we can dot4 with a plane.
    Center = XMVectorInsert( Center, XMVectorSplatOne(), 0, 0, 0, 0, 1 );

    XMVECTOR Outside, Inside;
    FastIntersectSpherePlane( Center, Radius, Plane, Outside, Inside );

    // If the sphere is outside any plane it is outside.
    if ( XMVector4EqualInt( Outside, XMVectorTrueInt() ) )
        return 0;

    // If the sphere is inside all planes it is inside.
    if ( XMVector4EqualInt( Inside, XMVectorTrueInt() ) )
        return 2;

    // The sphere is not inside all planes or outside a plane it intersects.
    return 1;
}



//-----------------------------------------------------------------------------
INT IntersectAxisAlignedBoxPlane( const AxisAlignedBox* pVolume, FXMVECTOR Plane )
{
    XMASSERT( pVolume );
    XMASSERT( XMPlaneIsUnit( Plane ) );

    // Load the box.
    XMVECTOR Center = XMLoadFloat3( &pVolume->Center );
    XMVECTOR Extents = XMLoadFloat3( &pVolume->Extents );

    // Set w of the center to one so we can dot4 with a plane.
    Center = XMVectorInsert( Center, XMVectorSplatOne(), 0, 0, 0, 0, 1);

    XMVECTOR Outside, Inside;
    FastIntersectAxisAlignedBoxPlane( Center, Extents, Plane, Outside, Inside );

    // If the box is outside any plane it is outside.
    if ( XMVector4EqualInt( Outside, XMVectorTrueInt() ) )
        return 0;

    // If the box is inside all planes it is inside.
    if ( XMVector4EqualInt( Inside, XMVectorTrueInt() ) )
        return 2;

    // The box is not inside all planes or outside a plane it intersects.
    return 1;
}



//-----------------------------------------------------------------------------
INT IntersectOrientedBoxPlane( const OrientedBox* pVolume, FXMVECTOR Plane )
{
    XMASSERT( pVolume );
    XMASSERT( XMPlaneIsUnit( Plane ) );

    // Load the box.
    XMVECTOR Center = XMLoadFloat3( &pVolume->Center );
    XMVECTOR Extents = XMLoadFloat3( &pVolume->Extents );
    XMVECTOR BoxOrientation = XMLoadFloat4( &pVolume->Orientation );

    XMASSERT( XMQuaternionIsUnit( BoxOrientation ) );

    // Set w of the center to one so we can dot4 with a plane.
    Center = XMVectorInsert( Center, XMVectorSplatOne(), 0, 0, 0, 0, 1);

    // Build the 3x3 rotation matrix that defines the box axes.
    XMMATRIX R = XMMatrixRotationQuaternion( BoxOrientation );

    XMVECTOR Outside, Inside;
    FastIntersectOrientedBoxPlane( Center, Extents, R.r[0], R.r[1], R.r[2], Plane, Outside, Inside );

    // If the box is outside any plane it is outside.
    if ( XMVector4EqualInt( Outside, XMVectorTrueInt() ) )
        return 0;

    // If the box is inside all planes it is inside.
    if ( XMVector4EqualInt( Inside, XMVectorTrueInt() ) )
        return 2;

    // The box is not inside all planes or outside a plane it intersects.
    return 1;
}



//-----------------------------------------------------------------------------
INT IntersectFrustumPlane( const Frustum* pVolume, FXMVECTOR Plane )
{
    XMASSERT( pVolume );
    XMASSERT( XMPlaneIsUnit( Plane ) );

    // Load origin and orientation of the frustum.
    XMVECTOR Origin = XMLoadFloat3( &pVolume->Origin );
    XMVECTOR Orientation = XMLoadFloat4( &pVolume->Orientation );

    XMASSERT( XMQuaternionIsUnit( Orientation ) );

    // Set w of the origin to one so we can dot4 with a plane.
    Origin = XMVectorInsert( Origin, XMVectorSplatOne(), 0, 0, 0, 0, 1);

    // Build the corners of the frustum (in world space).
    XMVECTOR RightTop = XMVectorSet( pVolume->RightSlope, pVolume->TopSlope, 1.0f, 0.0f );
    XMVECTOR RightBottom = XMVectorSet( pVolume->RightSlope, pVolume->BottomSlope, 1.0f, 0.0f );
    XMVECTOR LeftTop = XMVectorSet( pVolume->LeftSlope, pVolume->TopSlope, 1.0f, 0.0f );
    XMVECTOR LeftBottom = XMVectorSet( pVolume->LeftSlope, pVolume->BottomSlope, 1.0f, 0.0f );
    XMVECTOR Near = XMVectorSet( pVolume->Near, pVolume->Near, pVolume->Near, 0.0f );
    XMVECTOR Far = XMVectorSet( pVolume->Far, pVolume->Far, pVolume->Far, 0.0f );

    RightTop = XMVector3Rotate( RightTop, Orientation );
    RightBottom = XMVector3Rotate( RightBottom, Orientation );
    LeftTop = XMVector3Rotate( LeftTop, Orientation );
    LeftBottom = XMVector3Rotate( LeftBottom, Orientation );

    XMVECTOR Corners0 = Origin + RightTop * Near;
    XMVECTOR Corners1 = Origin + RightBottom * Near;
    XMVECTOR Corners2 = Origin + LeftTop * Near;
    XMVECTOR Corners3 = Origin + LeftBottom * Near;
    XMVECTOR Corners4 = Origin + RightTop * Far;
    XMVECTOR Corners5 = Origin + RightBottom * Far;
    XMVECTOR Corners6 = Origin + LeftTop * Far;
    XMVECTOR Corners7 = Origin + LeftBottom * Far;

    XMVECTOR Outside, Inside;
    FastIntersectFrustumPlane( Corners0, Corners1, Corners2, Corners3, 
                               Corners4, Corners5, Corners6, Corners7, 
                               Plane, Outside, Inside );

    // If the frustum is outside any plane it is outside.
    if ( XMVector4EqualInt( Outside, XMVectorTrueInt() ) )
        return 0;

    // If the frustum is inside all planes it is inside.
    if ( XMVector4EqualInt( Inside, XMVectorTrueInt() ) )
        return 2;

    // The frustum is not inside all planes or outside a plane it intersects.
    return 1;
}

}; // namespace

```

`XenonDumper/libs/Atg/AtgCollision.h`:

```h
//-------------------------------------------------------------------------------------
// ATGCollision.h
//  
// An opimtized collision library based on XNAMath
//  
// Microsoft XNA Developer Connection
// Copyright (c) Microsoft Corporation. All rights reserved.
//-------------------------------------------------------------------------------------

#pragma once

#ifndef ATG_COLLISION_H
#define ATG_COLLISION_H

#include <xnamath.h>

namespace ATG
{

//-----------------------------------------------------------------------------
// Bounding volumes structures.
//
// The bounding volume structures are setup for near minimum size because there
// are likely to be many of them, and memory bandwidth and space will be at a
// premium relative to CPU cycles on Xbox 360.
//-----------------------------------------------------------------------------

struct Sphere
{
    XMFLOAT3 Center;            // Center of the sphere.
    FLOAT Radius;               // Radius of the sphere.
};

struct AxisAlignedBox
{
    XMFLOAT3 Center;            // Center of the box.
    XMFLOAT3 Extents;           // Distance from the center to each side.
};

struct OrientedBox
{
    XMFLOAT3 Center;            // Center of the box.
    XMFLOAT3 Extents;           // Distance from the center to each side.
    XMFLOAT4 Orientation;       // Unit quaternion representing rotation (box -> world).
};

struct Frustum
{
    XMFLOAT3 Origin;            // Origin of the frustum (and projection).
    XMFLOAT4 Orientation;       // Unit quaternion representing rotation.

    FLOAT RightSlope;           // Positive X slope (X/Z).
    FLOAT LeftSlope;            // Negative X slope.
    FLOAT TopSlope;             // Positive Y slope (Y/Z).
    FLOAT BottomSlope;          // Negative Y slope.
    FLOAT Near, Far;            // Z of the near plane and far plane.
};



//-----------------------------------------------------------------------------
// Bounding volume construction.
//-----------------------------------------------------------------------------
VOID ComputeBoundingSphereFromPoints( Sphere* pOut, UINT Count, const XMFLOAT3* pPoints, UINT Stride );
VOID ComputeBoundingAxisAlignedBoxFromPoints( AxisAlignedBox* pOut, UINT Count, const XMFLOAT3* pPoints, UINT Stride );
VOID ComputeBoundingOrientedBoxFromPoints( OrientedBox* pOut, UINT Count, const XMFLOAT3* pPoints, UINT Stride );
VOID ComputeFrustumFromProjection( Frustum* pOut, XMMATRIX* pProjection );
VOID ComputePlanesFromFrustum( const Frustum* pVolume, XMVECTOR* pPlane0, XMVECTOR* pPlane1, XMVECTOR* pPlane2,
                               XMVECTOR* pPlane3, XMVECTOR* pPlane4, XMVECTOR* pPlane5 );



//-----------------------------------------------------------------------------
// Bounding volume transforms.
//-----------------------------------------------------------------------------
VOID TransformSphere( Sphere* pOut, const Sphere* pIn, FLOAT Scale, FXMVECTOR Rotation, FXMVECTOR Translation );
VOID TransformAxisAlignedBox( AxisAlignedBox* pOut, const AxisAlignedBox* pIn, FLOAT Scale, FXMVECTOR Rotation,
                              FXMVECTOR Translation );
VOID TransformOrientedBox( OrientedBox* pOut, const OrientedBox* pIn, FLOAT Scale, FXMVECTOR Rotation,
                           FXMVECTOR Translation );
VOID TransformFrustum( Frustum* pOut, const Frustum* pIn, FLOAT Scale, FXMVECTOR Rotation, FXMVECTOR Translation );



//-----------------------------------------------------------------------------
// Intersection testing routines.
//-----------------------------------------------------------------------------
BOOL IntersectPointSphere( FXMVECTOR Point, const Sphere* pVolume );
BOOL IntersectPointAxisAlignedBox( FXMVECTOR Point, const AxisAlignedBox* pVolume );
BOOL IntersectPointOrientedBox( FXMVECTOR Point, const OrientedBox* pVolume );
BOOL IntersectPointFrustum( FXMVECTOR Point, const Frustum* pVolume );
BOOL IntersectRayTriangle( FXMVECTOR Origin, FXMVECTOR Direction, FXMVECTOR V0, CXMVECTOR V1, CXMVECTOR V2,
                           FLOAT* pDist );
BOOL IntersectRaySphere( FXMVECTOR Origin, FXMVECTOR Direction, const Sphere* pVolume, FLOAT* pDist );
BOOL IntersectRayAxisAlignedBox( FXMVECTOR Origin, FXMVECTOR Direction, const AxisAlignedBox* pVolume, FLOAT* pDist );
BOOL IntersectRayOrientedBox( FXMVECTOR Origin, FXMVECTOR Direction, const OrientedBox* pVolume, FLOAT* pDist );
BOOL IntersectTriangleTriangle( FXMVECTOR A0, FXMVECTOR A1, FXMVECTOR A2, CXMVECTOR B0, CXMVECTOR B1, CXMVECTOR B2 );
BOOL IntersectTriangleSphere( FXMVECTOR V0, FXMVECTOR V1, FXMVECTOR V2, const Sphere* pVolume );
BOOL IntersectTriangleAxisAlignedBox( FXMVECTOR V0, FXMVECTOR V1, FXMVECTOR V2, const AxisAlignedBox* pVolume );
BOOL IntersectTriangleOrientedBox( FXMVECTOR V0, FXMVECTOR V1, FXMVECTOR V2, const OrientedBox* pVolume );
BOOL IntersectSphereSphere( const Sphere* pVolumeA, const Sphere* pVolumeB );
BOOL IntersectSphereAxisAlignedBox( const Sphere* pVolumeA, const AxisAlignedBox* pVolumeB );
BOOL IntersectSphereOrientedBox( const Sphere* pVolumeA, const OrientedBox* pVolumeB );
BOOL IntersectAxisAlignedBoxAxisAlignedBox( const AxisAlignedBox* pVolumeA, const AxisAlignedBox* pVolumeB );
BOOL IntersectAxisAlignedBoxOrientedBox( const AxisAlignedBox* pVolumeA, const OrientedBox* pVolumeB );
BOOL IntersectOrientedBoxOrientedBox( const OrientedBox* pVolumeA, const OrientedBox* pVolumeB );



//-----------------------------------------------------------------------------
// Frustum intersection testing routines.
// Return values: 0 = no intersection, 
//                1 = intersection, 
//                2 = A is completely inside B
//-----------------------------------------------------------------------------
INT IntersectTriangleFrustum( FXMVECTOR V0, FXMVECTOR V1, FXMVECTOR V2, const Frustum* pVolume );
INT IntersectSphereFrustum( const Sphere* pVolumeA, const Frustum* pVolumeB );
INT IntersectAxisAlignedBoxFrustum( const AxisAlignedBox* pVolumeA, const Frustum* pVolumeB );
INT IntersectOrientedBoxFrustum( const OrientedBox* pVolumeA, const Frustum* pVolumeB );
INT IntersectFrustumFrustum( const Frustum* pVolumeA, const Frustum* pVolumeB );




//-----------------------------------------------------------------------------
// Test vs six planes (usually forming a frustum) intersection routines.
// The intended use for these routines is for fast culling to a view frustum.  
// When the volume being tested against a view frustum is small relative to the
// view frustum it is usually either inside all six planes of the frustum or 
// outside one of the planes of the frustum. If neither of these cases is true
// then it may or may not be intersecting the frustum. Outside a plane is 
// defined as being on the positive side of the plane (and inside negative).
// Return values: 0 = volume is outside one of the planes (no intersection),
//                1 = not completely inside or completely outside (intersecting),
//                2 = volume is inside all the planes (completely inside)
//-----------------------------------------------------------------------------
INT IntersectTriangle6Planes( FXMVECTOR V0, FXMVECTOR V1, FXMVECTOR V2, CXMVECTOR Plane0, CXMVECTOR Plane1,
                              CXMVECTOR Plane2, CXMVECTOR Plane3, CXMVECTOR Plane4, CXMVECTOR Plane5 );
INT IntersectSphere6Planes( const Sphere* pVolume, FXMVECTOR Plane0, FXMVECTOR Plane1, FXMVECTOR Plane2,
                            CXMVECTOR Plane3, CXMVECTOR Plane4, CXMVECTOR Plane5 );
INT IntersectAxisAlignedBox6Planes( const AxisAlignedBox* pVolume, FXMVECTOR Plane0, FXMVECTOR Plane1,
                                    FXMVECTOR Plane2, CXMVECTOR Plane3, CXMVECTOR Plane4, CXMVECTOR Plane5 );
INT IntersectOrientedBox6Planes( const OrientedBox* pVolume, FXMVECTOR Plane0, FXMVECTOR Plane1, FXMVECTOR Plane2,
                                 CXMVECTOR Plane3, CXMVECTOR Plane4, CXMVECTOR Plane5 );
INT IntersectFrustum6Planes( const Frustum* pVolume, FXMVECTOR Plane0, FXMVECTOR Plane1, FXMVECTOR Plane2,
                             CXMVECTOR Plane3, CXMVECTOR Plane4, CXMVECTOR Plane5 );


//-----------------------------------------------------------------------------
// Volume vs plane intersection testing routines.
// Return values: 0 = volume is outside the plane (on the positive sideof the plane),
//                1 = volume intersects the plane,
//                2 = volume is inside the plane (on the negative side of the plane) 
//-----------------------------------------------------------------------------
INT IntersectTrianglePlane( FXMVECTOR V0, FXMVECTOR V1, FXMVECTOR V2, CXMVECTOR Plane );
INT IntersectSpherePlane( const Sphere* pVolume, FXMVECTOR Plane );
INT IntersectAxisAlignedBoxPlane( const AxisAlignedBox* pVolume, FXMVECTOR Plane );
INT IntersectOrientedBoxPlane( const OrientedBox* pVolume, FXMVECTOR Plane );
INT IntersectFrustumPlane( const Frustum* pVolume, FXMVECTOR Plane );

}; // namespace

#endif // ATG_COLLISION_H
```

`XenonDumper/libs/Atg/AtgConsole.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// AtgConsole.cpp
//
// Console class for simple applications that need no input and only console output.
// Use this INSTEAD of AtgApplication.
//
// Requires .TGA/.ABC files for the console font. 
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#include "stdafx.h"
#include <malloc.h>
#include "AtgConsole.h"
#include "AtgFont.h"
#include "AtgUtil.h"

// Ignore warning about "unused" pD3D variable
#pragma warning( disable: 4189 )

namespace ATG
{

//--------------------------------------------------------------------------------------
// Declarations
//--------------------------------------------------------------------------------------
// Global access to the main D3D device
extern D3DDevice* g_pd3dDevice;


//--------------------------------------------------------------------------------------
// Static variables
//--------------------------------------------------------------------------------------

// Private access to the main D3D device
D3DDevice* Console::m_pd3dDevice = NULL;


//--------------------------------------------------------------------------------------
// Structures
//--------------------------------------------------------------------------------------

// The device-creation presentation params with reasonable defaults
D3DPRESENT_PARAMETERS Console::m_d3dpp =
{
    640,                // BackBufferWidth;
    480,                // BackBufferHeight;
    D3DFMT_A8R8G8B8,    // BackBufferFormat;
    1,                  // BackBufferCount;
    D3DMULTISAMPLE_NONE,// MultiSampleType;
    0,                  // MultiSampleQuality;
    D3DSWAPEFFECT_DISCARD, // SwapEffect;
    NULL,               // hDeviceWindow;
    FALSE,              // Windowed;
    TRUE,               // EnableAutoDepthStencil;
    D3DFMT_D24S8,       // AutoDepthStencilFormat;
    0,                  // Flags;
    0,                  // FullScreen_RefreshRateInHz;
    D3DPRESENT_INTERVAL_IMMEDIATE, // FullScreen_PresentationInterval;
};


//--------------------------------------------------------------------------------------
// Name: Console()
// Desc: Initialize variables
//--------------------------------------------------------------------------------------
Console::Console()
{
    m_Buffer = NULL;
    m_Lines = NULL;
    m_bOutputToDebugChannel = FALSE;
	m_nScrollOffset = 0;
}


//--------------------------------------------------------------------------------------
// Name: ~Console()
// Desc: Destroy object
//--------------------------------------------------------------------------------------
Console::~Console()
{
    Destroy();
}


//--------------------------------------------------------------------------------------
// Name: Create()
// Desc: Initialize the class, create D3D and the font texture
//--------------------------------------------------------------------------------------
HRESULT Console::Create( LPCSTR strFontFileName, D3DCOLOR colBackColor,
                         D3DCOLOR colTextColor, UINT nLines )
{
    // Create Direct3D
    LPDIRECT3D9 pD3D = Direct3DCreate9( D3D_SDK_VERSION );

    m_d3dpp.BackBufferWidth = SCREEN_SIZE_X_720p;
    m_d3dpp.BackBufferHeight = SCREEN_SIZE_Y_720p;

    // Calculate the safe area
    UINT uiSafeAreaPct = SAFE_AREA_PCT_HDTV;

    m_cxSafeArea = ( m_d3dpp.BackBufferWidth * uiSafeAreaPct ) / 100;
    m_cySafeArea = ( m_d3dpp.BackBufferHeight * uiSafeAreaPct ) / 100;

    m_cxSafeAreaOffset = ( m_d3dpp.BackBufferWidth - m_cxSafeArea ) / 2;
    m_cySafeAreaOffset = ( m_d3dpp.BackBufferHeight - m_cySafeArea ) / 2;

    // Create the D3D device
    HRESULT hr = pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL,
                                     D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                     &m_d3dpp, ( ::D3DDevice** )&m_pd3dDevice );
    if( FAILED( hr ) )
    {
        ATG_PrintError( "Could not create D3D device!\n" );
        DebugBreak();
    }

    // Allow global access to the device
    g_pd3dDevice = m_pd3dDevice;

    // Create the font
    hr = m_Font.Create( strFontFileName );
    if( FAILED( hr ) )
    {
        ATG_PrintError( "Could not create font.\n" );
        DebugBreak();
    }

    // Save the colors
    m_colBackColor = colBackColor;
    m_colTextColor = colTextColor;

    // Calculate the number of lines on the screen
    FLOAT fCharWidth, fCharHeight;
    m_Font.GetTextExtent( L"i", &fCharWidth, &fCharHeight, FALSE );

    m_cScreenHeight = ( UINT )( m_cySafeArea / fCharHeight );
    m_cScreenWidth = ( UINT )( m_cxSafeArea / fCharWidth );

    m_cScreenHeightVirtual = max( m_cScreenHeight, nLines );

    m_fLineHeight = fCharHeight;

    // Allocate memory to hold the lines
    m_Buffer = new WCHAR[ m_cScreenHeightVirtual * ( m_cScreenWidth + 1 ) ];
    m_Lines = new WCHAR*[ m_cScreenHeightVirtual ];

    // Set the line pointers as indexes into the buffer
    for( UINT i = 0; i < m_cScreenHeightVirtual; i++ )
    {
        m_Lines[ i ] = m_Buffer + ( m_cScreenWidth + 1 ) * i;
    }

    m_bSuspendFlag = FALSE;

    // Clear the screen
    Clear();

    return hr;
}


//--------------------------------------------------------------------------------------
// Name: Clear()
// Desc: Clear the screen
//--------------------------------------------------------------------------------------
VOID Console::Clear()
{
    m_nCurLine = 0;
    m_cCurLineLength = 0;
    ZeroMemory( m_Buffer, m_cScreenHeightVirtual * ( m_cScreenWidth + 1 ) * sizeof( WCHAR ) );

    Render();
}


//--------------------------------------------------------------------------------------
// Name: IncrementLine()
// Desc: Skip to the next line
//--------------------------------------------------------------------------------------
VOID Console::IncrementLine()
{
    m_nCurLine = ( m_nCurLine + 1 ) % m_cScreenHeightVirtual;
    m_cCurLineLength = 0;
    ZeroMemory( m_Lines[m_nCurLine], ( m_cScreenWidth + 1 ) * sizeof( WCHAR ) );
}


//--------------------------------------------------------------------------------------
// Name: ScrollUp()
// Desc: Scroll the text window upwards
//--------------------------------------------------------------------------------------
VOID Console::ScrollUp( INT nLines )
{
    // Scroll exactly one page height if requested
    if( nLines >= PAGE_UP )
    {
        nLines = ( INT )m_cScreenHeight;
    }
    else if( nLines <= PAGE_DOWN )
    {
        nLines = -( INT )m_cScreenHeight;
    }

    m_nScrollOffset += nLines;

    m_nScrollOffset %= m_cScreenHeightVirtual;
}


//--------------------------------------------------------------------------------------
// Name: Destroy()
// Desc: Tear everything down
//--------------------------------------------------------------------------------------
VOID Console::Destroy()
{
    // Delete the memory we've allocated
    if( m_Lines )
    {
        delete[] m_Lines;
        m_Lines = NULL;
    }

    if( m_Buffer )
    {
        delete[] m_Buffer;
        m_Buffer = NULL;
    }

    // Destroy the font
    m_Font.Destroy();

    if( m_pd3dDevice )
    {
        // Give GPU control back to the title
	    if( m_bSuspendFlag )
		    m_pd3dDevice->Resume();

        // Release the D3D resources
        m_pd3dDevice->Release();
    }

    m_pd3dDevice = NULL;
    g_pd3dDevice = NULL;

}


//--------------------------------------------------------------------------------------
// Name: Render()
// Desc: Render the console to the screen
//--------------------------------------------------------------------------------------
VOID Console::Render()
{
    // Give GPU control back to us
    if( m_bSuspendFlag )
        m_pd3dDevice->Resume();

    // Render the background
    RenderBackground( m_colBackColor, m_colBackColor );

    // The top line
    UINT nTextLine = ( m_nCurLine - m_cScreenHeight + m_cScreenHeightVirtual - m_nScrollOffset + 1 )
        % m_cScreenHeightVirtual;


    m_Font.Begin();

    for( UINT nScreenLine = 0; nScreenLine < m_cScreenHeight; nScreenLine++ )
    {
        m_Font.DrawText( ( FLOAT )( m_cxSafeAreaOffset ),
                         ( FLOAT )( m_cySafeAreaOffset + m_fLineHeight * nScreenLine ),
                         m_colTextColor, m_Lines[nTextLine] );

        nTextLine = ( nTextLine + 1 ) % m_cScreenHeightVirtual;
    }

    m_Font.End();

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    // Take away GPU control so that the Guide can be rendered
    m_bSuspendFlag = TRUE;
    m_pd3dDevice->Suspend();
}


//--------------------------------------------------------------------------------------
// Name: Add( CHAR )
// Desc: Convert ANSI to WCHAR and add to the current line
//--------------------------------------------------------------------------------------
VOID Console::Add( CHAR ch )
{
    WCHAR wch;

    INT ret = MultiByteToWideChar( CP_ACP,        // ANSI code page
                                   0,             // No flags
                                   &ch,           // Character to convert
                                   1,             // Convert one byte
                                   &wch,          // Target wide character buffer
                                   1 );           // One wide character

    assert( ret == 1 );

    Add( wch );
}



//--------------------------------------------------------------------------------------
// Name: Add( WCHAR )
// Desc: Add a wide character to the current line
//--------------------------------------------------------------------------------------
VOID Console::Add( WCHAR wch )
{
    // If this is a newline, just increment lines and move on
    if( wch == L'\n' )
    {
        IncrementLine();
        return;
    }

    BOOL bIncrementLine = FALSE;  // Whether to wrap to the next line

    if( m_cCurLineLength == m_cScreenWidth )
    {
        bIncrementLine = TRUE;
    }
    else
    {
        // Try to append the character to the line
        m_Lines[ m_nCurLine ][ m_cCurLineLength ] = wch;

        if( m_Font.GetTextWidth( m_Lines[ m_nCurLine ] ) > m_cxSafeArea )
        {
            // The line is too long, we need to wrap the character to the next line
            m_Lines[ m_nCurLine][ m_cCurLineLength ] = L'\0';
            bIncrementLine = TRUE;
        }
    }

    // If we need to skip to the next line, do so
    if( bIncrementLine )
    {
        IncrementLine();
        m_Lines[ m_nCurLine ][0] = wch;
    }

    m_cCurLineLength++;
}


//--------------------------------------------------------------------------------------
// Name: Format()
// Desc: Output a variable argument list using a format string
//--------------------------------------------------------------------------------------
VOID Console::Format( _In_z_ _Printf_format_string_ LPCSTR strFormat, ... )
{
    va_list pArgList;
    va_start( pArgList, strFormat );
    FormatV( strFormat, pArgList );
    va_end( pArgList );
}

VOID Console::Format( _In_z_ _Printf_format_string_ LPCWSTR wstrFormat, ... )
{
    va_list pArgList;
    va_start( pArgList, wstrFormat );
    FormatV( wstrFormat, pArgList );
    va_end( pArgList );
}


//--------------------------------------------------------------------------------------
// Name: FormatV()
// Desc: Output a va_list using a format string
//--------------------------------------------------------------------------------------
VOID Console::FormatV( _In_z_ _Printf_format_string_ LPCSTR strFormat, va_list pArgList )
{
    // Count the required length of the string
    DWORD dwStrLen = _vscprintf( strFormat, pArgList ) + 1;    // +1 = null terminator
    CHAR* strMessage = ( CHAR* )_malloca( dwStrLen );
    vsprintf_s( strMessage, dwStrLen, strFormat, pArgList );

    // Output the string to the console
	DWORD uStringLength = strlen( strMessage );
    for( DWORD i = 0; i < uStringLength; i++ )
    {
        Add( strMessage[i] );
    }

    // Output the string to the debug channel, if requested
    if( m_bOutputToDebugChannel )
    {
        OutputDebugStringA( strMessage );
    }

    // Render the new output
    Render();

    _freea( strMessage );
}

VOID Console::FormatV( _In_z_ _Printf_format_string_ LPCWSTR wstrFormat, va_list pArgList )
{
    // Count the required length of the string
    DWORD dwStrLen = _vscwprintf( wstrFormat, pArgList ) + 1;    // +1 = null terminator
    WCHAR* strMessage = ( WCHAR* )_malloca( dwStrLen * sizeof( WCHAR ) );
    vswprintf_s( strMessage, dwStrLen, wstrFormat, pArgList );

    // Output the string to the console
	DWORD uStringLength = wcslen( strMessage );
    for( DWORD i = 0; i < uStringLength; i++ )
    {
        Add( strMessage[i] );
    }

    // Output the string to the debug channel, if requested
    if( m_bOutputToDebugChannel )
    {
        OutputDebugStringW( strMessage );
    }

    // Render the new output
    Render();

    _freea( strMessage );

}

}
;  // namespace

```

`XenonDumper/libs/Atg/AtgConsole.h`:

```h
//--------------------------------------------------------------------------------------
// AtgConsole.h
//
// Console class for simple applications that need no input and only console output.
// Use this INSTEAD of AtgApplication.
//
// Requires .TGA/.ABC files for the console font. 
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#pragma once
#ifndef ATGCONSOLE_H
#define ATGCONSOLE_H

#include <xtl.h>
#include "AtgDevice.h"
#include "AtgFont.h"

namespace ATG
{

//--------------------------------------------------------------------------------------
// Name: class Console
// Desc: Class to implement the console.
//--------------------------------------------------------------------------------------
class Console
{
public:
                    Console();
                    ~Console();

    // Initialization
    HRESULT         Create( LPCSTR strFontFileName,
                            D3DCOLOR colBackColor,
                            D3DCOLOR colTextColor,
                            UINT nLines = 0 );

    VOID            Destroy();

    // Clear the screen
    VOID            Clear();

    // Console output
    virtual VOID    Format( _In_z_ _Printf_format_string_ LPCSTR strFormat, ... );
    virtual VOID    Format( _In_z_ _Printf_format_string_ LPCWSTR wstrFormat, ... );
    virtual VOID    FormatV( _In_z_ _Printf_format_string_ LPCSTR strFormat, va_list pArgList );
    virtual VOID    FormatV( _In_z_ _Printf_format_string_ LPCWSTR wstrFormat, va_list pArgList );

    // Send output to debug channel
    VOID            SendOutputToDebugChannel( BOOL bOutputToDebugChannel )
    {
        m_bOutputToDebugChannel = bOutputToDebugChannel;
    }

    // method for rendering the console
    VOID            Render();

    // method for scrolling the text window up/down
    VOID            ScrollUp( INT nLines );

    static const INT PAGE_UP    = +255;
    static const INT PAGE_DOWN  = -255;

private:
    // Constants
    static const UINT SCREEN_SIZE_X_DEFAULT    = 640;
    static const UINT SCREEN_SIZE_Y_DEFAULT    = 480;
    static const UINT SCREEN_SIZE_X_720p       = 1280;
    static const UINT SCREEN_SIZE_Y_720p       = 720;

    static const UINT SAFE_AREA_PCT_4x3        = 85;
    static const UINT SAFE_AREA_PCT_HDTV       = 90;

    // Safe area dimensions
    UINT m_cxSafeArea;
    UINT m_cySafeArea;

    UINT m_cxSafeAreaOffset;
    UINT m_cySafeAreaOffset;

    // Send console output to debug channel
    BOOL m_bOutputToDebugChannel;

    // Main objects used for creating and rendering the 3D scene
    static D3DPRESENT_PARAMETERS m_d3dpp;
    static D3DDevice* m_pd3dDevice;

    // Font for rendering text
    Font m_Font;

    // Colors
    D3DCOLOR m_colBackColor;
    D3DCOLOR m_colTextColor;

    // Text Buffers
    UINT m_cScreenHeight;        // height in lines of screen area
    UINT m_cScreenHeightVirtual; // height in lines of text storage buffer
    UINT m_cScreenWidth;         // width in characters
    FLOAT m_fLineHeight;          // height of a single line in pixels

    WCHAR* m_Buffer;               // buffer big enough to hold a full screen
    WCHAR** m_Lines;                // pointers to individual lines
    UINT m_nCurLine;             // index of current line being written to
    UINT m_cCurLineLength;       // length of the current line
    INT m_nScrollOffset;        // offset to display text (in lines)

    BOOL m_bSuspendFlag;         // Device suspended tracking flag

    // Add a character to the current line
    VOID            Add( CHAR ch );
    VOID            Add( WCHAR wch );

    // Increment to the next line
    VOID            IncrementLine();
};

}
// namespace ATG

#endif

```

`XenonDumper/libs/Atg/AtgDebugDraw.cpp`:

```cpp
//-----------------------------------------------------------------------------
// AtgDebugDraw.cpp
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "AtgDevice.h"
#include "AtgDebugDraw.h"
#include "AtgSimpleShaders.h"
#include "AtgUtil.h"

namespace ATG
{

extern D3DDevice* g_pd3dDevice;

XMMATRIX g_matViewProjection;

VOID DebugDraw::SetViewProjection( const XMMATRIX& matViewProjection )
{
    g_matViewProjection = matViewProjection;
}

VOID DebugDraw::DrawAxes( const XMMATRIX& matWorld )
{
    SimpleShaders::SetDeclPosColor();
    static const MeshVertexPC verts[] =
    {
        { XMFLOAT3( 0.0f, 0.0f, 0.0f ), 0xFFFF0000 },
        { XMFLOAT3( 1.0f, 0.0f, 0.0f ), 0xFFFF0000 },
        { XMFLOAT3( 0.0f, 0.0f, 0.0f ), 0xFF00FF00 },
        { XMFLOAT3( 0.0f, 1.0f, 0.0f ), 0xFF00FF00 },
        { XMFLOAT3( 0.0f, 0.0f, 0.0f ), 0xFF0000FF },
        { XMFLOAT3( 0.0f, 0.0f, 1.0f ), 0xFF0000FF },
    };
    SimpleShaders::BeginShader_Transformed_VertexColor( matWorld * g_matViewProjection );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 3, ( const VOID* )verts, sizeof( MeshVertexPC ) );
    SimpleShaders::EndShader();
}

VOID DebugDraw::DrawCubeWireframe( const XMMATRIX& matWorld, D3DCOLOR Color )
{
    SimpleShaders::SetDeclPos();
    static const MeshVertexP verts[] =
    {
        XMFLOAT3( -1, -1, -1 ),
        XMFLOAT3( 1, -1, -1 ),
        XMFLOAT3( 1, -1, 1 ),
        XMFLOAT3( -1, -1, 1 ),
        XMFLOAT3( -1, 1, -1 ),
        XMFLOAT3( 1, 1, -1 ),
        XMFLOAT3( 1, 1, 1 ),
        XMFLOAT3( -1, 1, 1 ),
    };
    static const WORD indices[] =
    {
        0, 1,
        1, 2,
        2, 3,
        3, 0,
        4, 5,
        5, 6,
        6, 7,
        7, 4,
        0, 4,
        1, 5,
        2, 6,
        3, 7
    };
    SimpleShaders::BeginShader_Transformed_ConstantColor( matWorld * g_matViewProjection, Color );
    g_pd3dDevice->DrawIndexedPrimitiveUP( D3DPT_LINELIST, 0, 8, 12, ( const VOID* )indices,
                                          D3DFMT_INDEX16, ( const VOID* )verts, sizeof( MeshVertexP ) );
    SimpleShaders::EndShader();
}

VOID DebugDraw::DrawCubeWireframe( const XMFLOAT3& Center, const XMFLOAT3& HalfSize, D3DCOLOR Color )
{
    XMMATRIX matWorld = XMMatrixIdentity();
    matWorld._11 = HalfSize.x;
    matWorld._22 = HalfSize.y;
    matWorld._33 = HalfSize.z;
    matWorld._41 = Center.x;
    matWorld._42 = Center.y;
    matWorld._43 = Center.z;
    DrawCubeWireframe( matWorld, Color );
}

VOID DebugDraw::DrawLineSegment( const XMFLOAT3& Origin, const XMFLOAT3& End, D3DCOLOR Color )
{
    MeshVertexP verts[2];
    memcpy( &verts[0], &Origin, 3 * sizeof( FLOAT ) );
    memcpy( &verts[1], &End, 3 * sizeof( FLOAT ) );
    SimpleShaders::SetDeclPos();
    SimpleShaders::BeginShader_Transformed_ConstantColor( g_matViewProjection, Color );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, ( const VOID* )verts, sizeof( MeshVertexP ) );
    SimpleShaders::EndShader();
}

VOID DebugDraw::DrawRay( const XMFLOAT3& Origin, const XMFLOAT3& Direction, BOOL bNormalize, D3DCOLOR Color )
{
    MeshVertexP verts[3];
    memcpy( &verts[0], &Origin, 3 * sizeof( FLOAT ) );

    XMVECTOR RayOrigin = XMLoadFloat3( &Origin );
    XMVECTOR RayDirection = XMLoadFloat3( &Direction );
    XMVECTOR NormDirection = XMVector3Normalize( RayDirection );
    if( bNormalize )
        RayDirection = NormDirection;

    XMVECTOR PerpVector;
    XMVECTOR CrossVector = XMVectorSet( 0, 1, 0, 0 );
    PerpVector = XMVector3Cross( NormDirection, CrossVector );

    if( XMVector3Equal( XMVector3LengthSq( PerpVector ), XMVectorSet( 0, 0, 0, 0 ) ) )
    {
        CrossVector = XMVectorSet( 0, 0, 1, 0 );
        PerpVector = XMVector3Cross( NormDirection, CrossVector );
    }
    PerpVector = XMVector3Normalize( PerpVector );

    XMStoreFloat3( ( XMFLOAT3* )&verts[1], XMVectorAdd( RayDirection, RayOrigin ) );
    PerpVector = XMVectorScale( PerpVector, 0.0625f );
    NormDirection = XMVectorScale( NormDirection, -0.25f );
    RayDirection = XMVectorAdd( PerpVector, RayDirection );
    RayDirection = XMVectorAdd( NormDirection, RayDirection );
    XMStoreFloat3( ( XMFLOAT3* )&verts[2], XMVectorAdd( RayDirection, RayOrigin ) );

    SimpleShaders::SetDeclPos();
    SimpleShaders::BeginShader_Transformed_ConstantColor( g_matViewProjection, Color );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_LINESTRIP, 2, ( const VOID* )verts, sizeof( MeshVertexP ) );
    SimpleShaders::EndShader();
}

VOID DebugDraw::DrawRing( const XMFLOAT3& Origin, const XMFLOAT3& MajorAxis, const XMFLOAT3& MinorAxis,
                          D3DCOLOR Color )
{
    static const DWORD dwRingSegments = 32;
    MeshVertexP verts[ dwRingSegments + 1 ];

    XMVECTOR vOrigin = XMLoadFloat3( &Origin );
    XMVECTOR vMajor = XMLoadFloat3( &MajorAxis );
    XMVECTOR vMinor = XMLoadFloat3( &MinorAxis );

    FLOAT fAngleDelta = XM_2PI / ( float )dwRingSegments;
    // Instead of calling cos/sin for each segment we calculate
    // the sign of the angle delta and then incrementally calculate sin
    // and cosine from then on.
    XMVECTOR cosDelta = XMVectorReplicate( cosf( fAngleDelta ) );
    XMVECTOR sinDelta = XMVectorReplicate( sinf( fAngleDelta ) );
    XMVECTOR incrementalSin = XMVectorZero();
    static const XMVECTOR initialCos =
    {
        1.0f, 1.0f, 1.0f, 1.0f
    };
    XMVECTOR incrementalCos = initialCos;
    for( DWORD i = 0; i < dwRingSegments; i++ )
    {
        XMVECTOR Pos;
        Pos = XMVectorMultiplyAdd( vMajor, incrementalCos, vOrigin );
        Pos = XMVectorMultiplyAdd( vMinor, incrementalSin, Pos );
        XMStoreFloat3( ( XMFLOAT3* )&verts[i], Pos );
        // Standard formula to rotate a vector.
        XMVECTOR newCos = incrementalCos * cosDelta - incrementalSin * sinDelta;
        XMVECTOR newSin = incrementalCos * sinDelta + incrementalSin * cosDelta;
        incrementalCos = newCos;
        incrementalSin = newSin;
    }
    verts[ dwRingSegments ] = verts[0];

    SimpleShaders::SetDeclPos();
    SimpleShaders::BeginShader_Transformed_ConstantColor( g_matViewProjection, Color );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_LINESTRIP, dwRingSegments, ( const VOID* )verts, sizeof( MeshVertexP ) );
    SimpleShaders::EndShader();
}

VOID DebugDraw::DrawSphere( const XMFLOAT3& Origin, FLOAT fRadius, D3DCOLOR Color )
{
    DrawRing( Origin, XMFLOAT3( fRadius, 0, 0 ), XMFLOAT3( 0, 0, fRadius ), Color );
    DrawRing( Origin, XMFLOAT3( fRadius, 0, 0 ), XMFLOAT3( 0, fRadius, 0 ), Color );
    DrawRing( Origin, XMFLOAT3( 0, fRadius, 0 ), XMFLOAT3( 0, 0, fRadius ), Color );
}

VOID DebugDraw::DrawGrid( const XMFLOAT3& XAxis, const XMFLOAT3& YAxis, const XMFLOAT3& Origin, INT iXDivisions,
                          INT iYDivisions, D3DCOLOR Color )
{
    iXDivisions = max( 1, iXDivisions );
    iYDivisions = max( 1, iYDivisions );

    // build grid geometry
    INT iLineCount = iXDivisions + iYDivisions + 2;
    XMFLOAT3* pLines = new XMFLOAT3[ 2 * iLineCount ];

    XMVECTOR vX = XMLoadFloat3( &XAxis );
    XMVECTOR vY = XMLoadFloat3( &YAxis );
    XMVECTOR vOrigin = XMLoadFloat3( &Origin );

    for( INT i = 0; i <= iXDivisions; i++ )
    {
        FLOAT fPercent = ( FLOAT )i / ( FLOAT )iXDivisions;
        fPercent = ( fPercent * 2.0f ) - 1.0f;
        XMVECTOR vScale = XMVectorScale( vX, fPercent );
        vScale = XMVectorAdd( vScale, vOrigin );
        XMStoreFloat3( &pLines[ ( i * 2 ) ], XMVectorSubtract( vScale, vY ) );
        XMStoreFloat3( &pLines[ ( i * 2 ) + 1 ], XMVectorAdd( vScale, vY ) );
    }

    INT iStartIndex = ( iXDivisions + 1 ) * 2;
    for( INT i = 0; i <= iYDivisions; i++ )
    {
        FLOAT fPercent = ( FLOAT )i / ( FLOAT )iYDivisions;
        fPercent = ( fPercent * 2.0f ) - 1.0f;
        XMVECTOR vScale = XMVectorScale( vY, fPercent );
        vScale = XMVectorAdd( vScale, vOrigin );
        XMStoreFloat3( &pLines[ ( i * 2 ) + iStartIndex ], XMVectorSubtract( vScale, vX ) );
        XMStoreFloat3( &pLines[ ( i * 2 ) + 1 + iStartIndex ], XMVectorAdd( vScale, vX ) );
    }

    // draw grid
    SimpleShaders::SetDeclPos();
    SimpleShaders::BeginShader_Transformed_ConstantColor( g_matViewProjection, Color );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, iLineCount, pLines, sizeof( XMFLOAT3 ) );
    SimpleShaders::EndShader();

    delete[] pLines;
}

VOID DebugDraw::DrawTriangle( const XMFLOAT3& PointA, const XMFLOAT3& PointB, const XMFLOAT3& PointC, D3DCOLOR Color )
{
    XMFLOAT3 Verts[4];
    Verts[0] = PointA;
    Verts[1] = PointB;
    Verts[2] = PointC;
    Verts[3] = PointA;

    SimpleShaders::SetDeclPos();
    SimpleShaders::BeginShader_Transformed_ConstantColor( g_matViewProjection, Color );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_LINESTRIP, 3, &Verts, sizeof( XMFLOAT3 ) );
    SimpleShaders::EndShader();
}

VOID DebugDraw::DrawConeWireframe( const XMFLOAT3& CenterBase, const XMFLOAT3& Axis, FLOAT fBaseRadius,
                                   FLOAT fTopRadius, D3DCOLOR Color )
{
    XMVECTOR vAxis = XMLoadFloat3( &Axis );
    XMVECTOR vAxisNorm = XMVector3Normalize( vAxis );

    // compute orthogonal vectors for the base of the cone
    XMVECTOR vBaseVectorX = XMVector3Normalize( XMVector3Orthogonal( vAxisNorm ) );
    XMVECTOR vBaseVectorZ = XMVector3Cross( vAxisNorm, vBaseVectorX );
    XMVECTOR vBaseVectorXScale = XMVectorScale( vBaseVectorX, fBaseRadius );
    XMVECTOR vBaseVectorZScale = XMVectorScale( vBaseVectorZ, fBaseRadius );

    // draw base ring
    if( fBaseRadius != 0 )
    {
        XMFLOAT3 BaseRingAxisX, BaseRingAxisZ;
        XMStoreFloat3( &BaseRingAxisX, vBaseVectorXScale );
        XMStoreFloat3( &BaseRingAxisZ, vBaseVectorZScale );
        DrawRing( CenterBase, BaseRingAxisX, BaseRingAxisZ, Color );
    }

    // compute center top location
    XMVECTOR vCenterTop = XMLoadFloat3( &CenterBase );
    vCenterTop = XMVectorAdd( vCenterTop, vAxis );

    // compute orthogonal vectors for the top of the cone
    XMVECTOR vTopVectorXScale = XMVectorScale( vBaseVectorX, fTopRadius );
    XMVECTOR vTopVectorZScale = XMVectorScale( vBaseVectorZ, fTopRadius );

    // build top ring
    if( fTopRadius != 0 )
    {
        XMFLOAT3 CenterTop;
        XMStoreFloat3( &CenterTop, vCenterTop );
        XMFLOAT3 TopRingAxisX, TopRingAxisZ;
        XMStoreFloat3( &TopRingAxisX, vTopVectorXScale );
        XMStoreFloat3( &TopRingAxisZ, vTopVectorZScale );
        DrawRing( CenterTop, TopRingAxisX, TopRingAxisZ, Color );
    }

    // build walls
    XMVECTOR vCenterBase = XMLoadFloat3( &CenterBase );
    const DWORD dwDivisions = 8;
    XMFLOAT3 WallVerts[ dwDivisions * 2 ];
    for( DWORD i = 0; i < dwDivisions; ++i )
    {
        FLOAT fTheta = ( ( FLOAT )i * XM_2PI ) / ( FLOAT )dwDivisions;
        XMVECTOR vSin, vCos;
        XMVectorSinCos( &vSin, &vCos, XMVectorReplicate( fTheta ) );
        XMVECTOR vBottom = vCenterBase + vBaseVectorXScale * vSin + vBaseVectorZScale * vCos;
        XMVECTOR vTop = vCenterTop + vTopVectorXScale * vSin + vTopVectorZScale * vCos;
        XMStoreFloat3( &WallVerts[ i * 2 ], vBottom );
        XMStoreFloat3( &WallVerts[ i * 2 + 1 ], vTop );
    }

    // draw walls
    SimpleShaders::SetDeclPos();
    SimpleShaders::BeginShader_Transformed_ConstantColor( g_matViewProjection, Color );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, dwDivisions, WallVerts, sizeof( XMFLOAT3 ) );
    SimpleShaders::EndShader();
}

VOID DebugDraw::DrawConeWireframe( const XMMATRIX& matWorld, FLOAT fBaseRadius, FLOAT fTopRadius, D3DCOLOR Color )
{
    XMVECTOR vCenterBase = matWorld.r[3];
    XMVECTOR vAxisY = matWorld.r[1];
    XMFLOAT3 CenterBase, Axis;
    XMStoreFloat3( &CenterBase, vCenterBase );
    XMStoreFloat3( &Axis, vAxisY );
    DrawConeWireframe( CenterBase, Axis, fBaseRadius, fTopRadius, Color );
}

VOID DebugDraw::DrawQuad( const XMFLOAT3& CornerA, const XMFLOAT3& CornerB, const XMFLOAT3& CornerC, D3DCOLOR Color )
{
    XMVECTOR vCornerA = XMLoadFloat3( &CornerA );
    XMVECTOR vCornerB = XMLoadFloat3( &CornerB );
    XMVECTOR vCornerC = XMLoadFloat3( &CornerC );

    XMVECTOR vCornerD = vCornerB + vCornerC - vCornerA;

    XMFLOAT3 vCorners[4];
    XMStoreFloat3( &vCorners[0], vCornerB );
    XMStoreFloat3( &vCorners[1], vCornerA );
    XMStoreFloat3( &vCorners[2], vCornerC );
    XMStoreFloat3( &vCorners[3], vCornerD );

    SimpleShaders::SetDeclPos();
    SimpleShaders::BeginShader_Transformed_ConstantColor( g_matViewProjection, Color );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADLIST, 1, vCorners, sizeof( XMFLOAT3 ) );
    SimpleShaders::EndShader();
}

VOID DebugDraw::DrawQuad( const XMFLOAT3& CornerA, const XMFLOAT3& CornerB, const XMFLOAT3& CornerC,
                          const XMFLOAT3& CornerD, D3DCOLOR Color )
{
    XMFLOAT3 vCorners[4];
    vCorners[0] = CornerA;
    vCorners[1] = CornerB;
    vCorners[2] = CornerC;
    vCorners[3] = CornerD;

    SimpleShaders::SetDeclPos();
    SimpleShaders::BeginShader_Transformed_ConstantColor( g_matViewProjection, Color );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADLIST, 1, vCorners, sizeof( XMFLOAT3 ) );
    SimpleShaders::EndShader();
}


VOID DebugDraw::DrawTexturedQuad( const XMFLOAT3& CornerA, const XMFLOAT3& CornerB, const XMFLOAT3& CornerC,
                                  const XMFLOAT2& UVRepeat, D3DTexture* pTexture )
{
    XMVECTOR vCornerA = XMLoadFloat3( &CornerA );
    XMVECTOR vCornerB = XMLoadFloat3( &CornerB );
    XMVECTOR vCornerC = XMLoadFloat3( &CornerC );

    XMVECTOR vCornerD = vCornerB + vCornerC - vCornerA;

    FLOAT vCorners[4 * 5];
    XMStoreFloat3( ( XMFLOAT3* )&vCorners[0], vCornerB );
    vCorners[3] = UVRepeat.x;
    vCorners[4] = 0.0f;
    XMStoreFloat3( ( XMFLOAT3* )&vCorners[5], vCornerA );
    vCorners[8] = 0.0f;
    vCorners[9] = 0.0f;
    XMStoreFloat3( ( XMFLOAT3* )&vCorners[10], vCornerC );
    vCorners[13] = 0.0f;
    vCorners[14] = UVRepeat.y;
    XMStoreFloat3( ( XMFLOAT3* )&vCorners[15], vCornerD );
    vCorners[18] = UVRepeat.x;
    vCorners[19] = UVRepeat.y;

    SimpleShaders::SetDeclPosTex();
    SimpleShaders::BeginShader_Transformed_Textured( g_matViewProjection, pTexture );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADLIST, 1, vCorners, 5 * sizeof( FLOAT ) );
    SimpleShaders::EndShader();
}

VOID DebugDraw::DrawCubeQuery( const XMFLOAT3& Center, const XMFLOAT3& HalfSize )
{
    // Index buffer data for a cube (using a quad list).
    static const WORD pIndexData[] =
    {
        3, 2, 0, 1,
        1, 0, 4, 5,
        3, 1, 5, 7,
        2, 3, 7, 6,
        0, 2, 6, 4,
        5, 4, 6, 7
    };
    static const XMFLOAT3 pVertexData[] =
    {
        XMFLOAT3( -1, -1, -1 ),
        XMFLOAT3( 1, -1, -1 ),
        XMFLOAT3( -1, -1, 1 ),
        XMFLOAT3( 1, -1, 1 ),
        XMFLOAT3( -1, 1, -1 ),
        XMFLOAT3( 1, 1, -1 ),
        XMFLOAT3( -1, 1, 1 ),
        XMFLOAT3( 1, 1, 1 )
    };

    XMMATRIX matTranslate = XMMatrixTranslationFromVector( XMLoadFloat3( &Center ) );
    XMMATRIX matScale = XMMatrixScalingFromVector( XMLoadFloat3( &HalfSize ) );
    XMMATRIX matTransform = matScale * matTranslate * g_matViewProjection;

    SimpleShaders::SetDeclPos();
    SimpleShaders::BeginShader_Transformed_DepthOnly( matTransform );
    g_pd3dDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID );
    g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    g_pd3dDevice->DrawIndexedPrimitiveUP( D3DPT_QUADLIST, 0, 8, 6, pIndexData, D3DFMT_INDEX16,
                                          pVertexData, sizeof( XMFLOAT3 ) );
    SimpleShaders::EndShader();
}


VOID DebugDraw::DrawScreenSpaceLine( const XMFLOAT2& Origin, const XMFLOAT2& End, D3DCOLOR Color, FLOAT fLineWidth )
{
    DrawScreenSpaceLine( Origin, Color, End, Color, fLineWidth );
}


VOID DebugDraw::DrawScreenSpaceLine( const XMFLOAT2& Origin, D3DCOLOR OriginColor, const XMFLOAT2& End, D3DCOLOR EndColor, FLOAT fLineWidth )
{
    ATG::MeshVertexPC Vertices[ 2 ];
    Vertices[0].Position = XMFLOAT3( Origin.x, Origin.y, 0 );
    Vertices[0].Color    = OriginColor;
    Vertices[1].Position = XMFLOAT3( End.x, End.y, 0 );
    Vertices[1].Color    = EndColor;


    DWORD dwLineWidthSaved;
    g_pd3dDevice->GetRenderState( D3DRS_LINEWIDTH, &dwLineWidthSaved );
    g_pd3dDevice->SetRenderState( D3DRS_LINEWIDTH, *((DWORD*)&fLineWidth));

    SimpleShaders::SetDeclPosColor();
    SimpleShaders::BeginShader_PreTransformed_VertexColor();
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, FALSE );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_LINESTRIP, 1, Vertices, sizeof( ATG::MeshVertexPC ) );
    SimpleShaders::EndShader();
    g_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );


    g_pd3dDevice->SetRenderState( D3DRS_LINEWIDTH, dwLineWidthSaved );
}


VOID DebugDraw::DrawScreenSpaceLineList( const XMFLOAT2 Points[], UINT PointCount, D3DCOLOR Color, FLOAT fLineWidth )
{
    ATG::MeshVertexPC* Vertices = new ATG::MeshVertexPC[ PointCount ];
    for( UINT i = 0; i < PointCount; ++i )
    {
        Vertices[i].Position = XMFLOAT3( Points[i].x, Points[i].y, 0 );
        Vertices[i].Color    = Color;
    }

    DWORD dwLineWidthSaved;
    g_pd3dDevice->GetRenderState( D3DRS_LINEWIDTH, &dwLineWidthSaved );
    g_pd3dDevice->SetRenderState( D3DRS_LINEWIDTH, *((DWORD*)&fLineWidth));

    SimpleShaders::SetDeclPosColor();
    SimpleShaders::BeginShader_PreTransformed_VertexColor();
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, FALSE );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_LINESTRIP, PointCount - 1, Vertices, sizeof( ATG::MeshVertexPC ) );
    SimpleShaders::EndShader();
    g_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );


    g_pd3dDevice->SetRenderState( D3DRS_LINEWIDTH, dwLineWidthSaved );

    delete[] Vertices;
}


VOID DebugDraw::DrawScreenSpaceRect( const D3DRECT& Rect, FLOAT fLineWidth, D3DCOLOR Color )
{
    XMFLOAT2 Origin( ( FLOAT )Rect.x1, ( FLOAT )Rect.y1 );
    XMFLOAT2 Size( ( FLOAT )( Rect.x2 - Rect.x1 ), ( FLOAT )( Rect.y2 - Rect.y1 ) );
    DrawScreenSpaceRect( Origin, Size, fLineWidth, Color );
}

VOID DebugDraw::DrawScreenSpaceRect( const XMFLOAT2& Origin, const XMFLOAT2& Size, FLOAT fLineWidth, D3DCOLOR Color )
{
    DWORD dwQuadCount = 1;
    XMFLOAT4 Vertices[12];
    if( fLineWidth > 0 )
    {
        dwQuadCount = 4;
        Vertices[0] = XMFLOAT4( Origin.x, Origin.y, 0, 1 );
        Vertices[1] = XMFLOAT4( Origin.x + Size.x, Origin.y, 0, 1 );
        Vertices[2] = XMFLOAT4( Origin.x, Origin.y + fLineWidth, 0, 1 );

        Vertices[3] = XMFLOAT4( Origin.x + Size.x - fLineWidth, Origin.y, 0, 1 );
        Vertices[4] = XMFLOAT4( Origin.x + Size.x, Origin.y, 0, 1 );
        Vertices[5] = XMFLOAT4( Origin.x + Size.x - fLineWidth, Origin.y + Size.y, 0, 1 );

        Vertices[ 6] = XMFLOAT4( Origin.x, Origin.y + Size.y - fLineWidth, 0, 1 );
        Vertices[ 7] = XMFLOAT4( Origin.x + Size.x, Origin.y + Size.y - fLineWidth, 0, 1 );
        Vertices[ 8] = XMFLOAT4( Origin.x, Origin.y + Size.y, 0, 1 );

        Vertices[ 9] = XMFLOAT4( Origin.x, Origin.y, 0, 1 );
        Vertices[10] = XMFLOAT4( Origin.x + fLineWidth, Origin.y, 0, 1 );
        Vertices[11] = XMFLOAT4( Origin.x, Origin.y + Size.y, 0, 1 );
    }
    else
    {
        Vertices[0] = XMFLOAT4( Origin.x, Origin.y, 0, 1 );
        Vertices[1] = XMFLOAT4( Origin.x + Size.x, Origin.y, 0, 1 );
        Vertices[2] = XMFLOAT4( Origin.x, Origin.y + Size.y, 0, 1 );
    }

    SimpleShaders::SetDeclPosT();
    SimpleShaders::BeginShader_PreTransformed_ConstantColor( Color );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
    g_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, FALSE );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_RECTLIST, dwQuadCount, Vertices, sizeof( XMFLOAT4 ) );
    SimpleShaders::EndShader();
    g_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );
}

VOID DebugDraw::DrawScreenSpaceTexturedRectPatch( const D3DRECT& Rect, XMFLOAT2 UVTopLeft, XMFLOAT2 UVTopRight, XMFLOAT2 UVBottomLeft, const D3DBaseTexture* pTexture, BOOL bDepthTexture )
{
    SimpleShaders::SetDeclPosTex();
    if( bDepthTexture )
    {
        SimpleShaders::BeginShader_PreTransformed_DepthTextured( pTexture );
    }
    else
    {
        SimpleShaders::BeginShader_PreTransformed_Textured( pTexture );
    }
    MeshVertexPT* pVertexData = NULL;
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
    g_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, FALSE );
    
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP );
    HRESULT hr = g_pd3dDevice->BeginVertices( D3DPT_RECTLIST, 3, sizeof( MeshVertexPT ), ( VOID** )&pVertexData );
    // The ring buffer may run out of space when tiling, doing z-prepasses,
    // or using BeginCommandBuffer. If so, make the buffer larger.
    if( FAILED( hr ) )
        FatalError( "Ring buffer out of memory.\n" );
    assert( pVertexData != NULL );
    pVertexData[0].Position = XMFLOAT3( ( FLOAT )Rect.x1, ( FLOAT )Rect.y1, 0 );
    pVertexData[0].TexCoord = UVTopLeft;
    pVertexData[1].Position = XMFLOAT3( ( FLOAT )Rect.x2, ( FLOAT )Rect.y1, 0 );
    pVertexData[1].TexCoord = UVTopRight;
    pVertexData[2].Position = XMFLOAT3( ( FLOAT )Rect.x1, ( FLOAT )Rect.y2, 0 );
    pVertexData[2].TexCoord = UVBottomLeft;
    g_pd3dDevice->EndVertices();
    SimpleShaders::EndShader();
    g_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );
}

VOID DebugDraw::DrawScreenSpaceTexturedRectPatchPointSampled ( const D3DRECT& Rect, XMFLOAT2 UVTopLeft, XMFLOAT2 UVTopRight, XMFLOAT2 UVBottomLeft, const D3DBaseTexture* pTexture, BOOL bDepthTexture )
{
    SimpleShaders::SetDeclPosTex();
    if( bDepthTexture )
    {
        SimpleShaders::BeginShader_PreTransformed_DepthTextured( pTexture );
    }
    else
    {
        SimpleShaders::BeginShader_PreTransformed_Textured( pTexture );
    }
    MeshVertexPT* pVertexData = NULL;
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
    g_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, FALSE );
    
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_POINT );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_POINT );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP );
    HRESULT hr = g_pd3dDevice->BeginVertices( D3DPT_RECTLIST, 3, sizeof( MeshVertexPT ), ( VOID** )&pVertexData );
    // The ring buffer may run out of space when tiling, doing z-prepasses,
    // or using BeginCommandBuffer. If so, make the buffer larger.
    if( FAILED( hr ) )
        FatalError( "Ring buffer out of memory.\n" );
    assert( pVertexData != NULL );
    pVertexData[0].Position = XMFLOAT3( ( FLOAT )Rect.x1, ( FLOAT )Rect.y1, 0 );
    pVertexData[0].TexCoord = UVTopLeft;
    pVertexData[1].Position = XMFLOAT3( ( FLOAT )Rect.x2, ( FLOAT )Rect.y1, 0 );
    pVertexData[1].TexCoord = UVTopRight;
    pVertexData[2].Position = XMFLOAT3( ( FLOAT )Rect.x1, ( FLOAT )Rect.y2, 0 );
    pVertexData[2].TexCoord = UVBottomLeft;
    g_pd3dDevice->EndVertices();
    SimpleShaders::EndShader();
    g_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );
}

VOID DebugDraw::DrawScreenSpaceTexturedRect( const D3DRECT& Rect, const D3DBaseTexture* pTexture, BOOL bDepthTexture )
{
    SimpleShaders::SetDeclPosTex();
    if( bDepthTexture )
    {
        SimpleShaders::BeginShader_PreTransformed_DepthTextured( pTexture );
    }
    else
    {
        SimpleShaders::BeginShader_PreTransformed_Textured( pTexture );
    }
    MeshVertexPT* pVertexData = NULL;
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
    g_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, FALSE );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP );
    HRESULT hr = g_pd3dDevice->BeginVertices( D3DPT_RECTLIST, 3, sizeof( MeshVertexPT ), ( VOID** )&pVertexData );
    // The ring buffer may run out of space when tiling, doing z-prepasses,
    // or using BeginCommandBuffer. If so, make the buffer larger.
    if( FAILED( hr ) )
        FatalError( "Ring buffer out of memory.\n" );
    assert( pVertexData != NULL );
    pVertexData[0].Position = XMFLOAT3( ( FLOAT )Rect.x1, ( FLOAT )Rect.y1, 0 );
    pVertexData[0].TexCoord = XMFLOAT2( 0, 0 );
    pVertexData[1].Position = XMFLOAT3( ( FLOAT )Rect.x2, ( FLOAT )Rect.y1, 0 );
    pVertexData[1].TexCoord = XMFLOAT2( 1, 0 );
    pVertexData[2].Position = XMFLOAT3( ( FLOAT )Rect.x1, ( FLOAT )Rect.y2, 0 );
    pVertexData[2].TexCoord = XMFLOAT2( 0, 1 );
    g_pd3dDevice->EndVertices();
    SimpleShaders::EndShader();
    g_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );
}

VOID DebugDraw::DrawScreenSpaceTexturedRectColored( const D3DRECT& Rect, const D3DBaseTexture* pTexture, D3DCOLOR Color )
{
    SimpleShaders::SetDeclPosTex();
    SimpleShaders::BeginShader_PreTransformed_TexturedConstantColor( pTexture, Color );
    MeshVertexPT* pVertexData = NULL;
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
    g_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, FALSE );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP );
    HRESULT hr = g_pd3dDevice->BeginVertices( D3DPT_RECTLIST, 3, sizeof( MeshVertexPT ), ( VOID** )&pVertexData );
    // The ring buffer may run out of space when tiling, doing z-prepasses,
    // or using BeginCommandBuffer. If so, make the buffer larger.
    if( FAILED( hr ) )
        FatalError( "Ring buffer out of memory.\n" );
    assert( pVertexData != NULL );
    pVertexData[0].Position = XMFLOAT3( ( FLOAT )Rect.x1, ( FLOAT )Rect.y1, 0 );
    pVertexData[0].TexCoord = XMFLOAT2( 0, 0 );
    pVertexData[1].Position = XMFLOAT3( ( FLOAT )Rect.x2, ( FLOAT )Rect.y1, 0 );
    pVertexData[1].TexCoord = XMFLOAT2( 1, 0 );
    pVertexData[2].Position = XMFLOAT3( ( FLOAT )Rect.x1, ( FLOAT )Rect.y2, 0 );
    pVertexData[2].TexCoord = XMFLOAT2( 0, 1 );
    g_pd3dDevice->EndVertices();
    SimpleShaders::EndShader();
    g_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );
}

VOID DebugDraw::DrawBound( const Bound& bound, D3DCOLOR Color )
{
    switch( bound.GetType() )
    {
        case Bound::Sphere_Bound:
            DrawSphere( bound.GetSphere(), Color );
            return;
        case Bound::Frustum_Bound:
            DrawFrustum( bound.GetFrustum(), Color );
            return;
        case Bound::AABB_Bound:
            DrawAabb( bound.GetAabb(), Color );
            return;
        case Bound::OBB_Bound:
            DrawObb( bound.GetObb(), Color );
            return;
    }
}

VOID DebugDraw::DrawSphere( const Sphere& sphere, D3DCOLOR Color )
{
    DrawSphere( sphere.Center, sphere.Radius, Color );
}

VOID DebugDraw::DrawFrustum( const Frustum& frustum, D3DCOLOR Color )
{
    // compute corner points

    XMVECTOR Origin = XMVectorSet( frustum.Origin.x, frustum.Origin.y, frustum.Origin.z, 0 );
    FLOAT Near = frustum.Near;
    FLOAT Far = frustum.Far;
    FLOAT RightSlope = frustum.RightSlope;
    FLOAT LeftSlope = frustum.LeftSlope;
    FLOAT TopSlope = frustum.TopSlope;
    FLOAT BottomSlope = frustum.BottomSlope;

    XMFLOAT3 CornerPoints[8];
    CornerPoints[0] = XMFLOAT3( RightSlope * Near, TopSlope * Near, Near );
    CornerPoints[1] = XMFLOAT3( LeftSlope * Near, TopSlope * Near, Near );
    CornerPoints[2] = XMFLOAT3( LeftSlope * Near, BottomSlope * Near, Near );
    CornerPoints[3] = XMFLOAT3( RightSlope * Near, BottomSlope * Near, Near );

    CornerPoints[4] = XMFLOAT3( RightSlope * Far, TopSlope * Far, Far );
    CornerPoints[5] = XMFLOAT3( LeftSlope * Far, TopSlope * Far, Far );
    CornerPoints[6] = XMFLOAT3( LeftSlope * Far, BottomSlope * Far, Far );
    CornerPoints[7] = XMFLOAT3( RightSlope * Far, BottomSlope * Far, Far );

    XMVECTOR Orientation = XMLoadFloat4( &frustum.Orientation );
    XMMATRIX Mat = XMMatrixRotationQuaternion( Orientation );
    for( UINT i = 0; i < 8; i++ )
    {
        XMVECTOR Result = XMVector3Transform( XMLoadFloat3( &CornerPoints[i] ), Mat );
        Result = XMVectorAdd( Result, Origin );
        XMStoreFloat3( &CornerPoints[i], Result );
    }

    XMFLOAT3 Lines[12 * 2];

    Lines[0] = CornerPoints[0];
    Lines[1] = CornerPoints[1];
    Lines[2] = CornerPoints[1];
    Lines[3] = CornerPoints[2];
    Lines[4] = CornerPoints[2];
    Lines[5] = CornerPoints[3];
    Lines[6] = CornerPoints[3];
    Lines[7] = CornerPoints[0];

    Lines[8] = CornerPoints[0];
    Lines[9] = CornerPoints[4];
    Lines[10] = CornerPoints[1];
    Lines[11] = CornerPoints[5];
    Lines[12] = CornerPoints[2];
    Lines[13] = CornerPoints[6];
    Lines[14] = CornerPoints[3];
    Lines[15] = CornerPoints[7];

    Lines[16] = CornerPoints[4];
    Lines[17] = CornerPoints[5];
    Lines[18] = CornerPoints[5];
    Lines[19] = CornerPoints[6];
    Lines[20] = CornerPoints[6];
    Lines[21] = CornerPoints[7];
    Lines[22] = CornerPoints[7];
    Lines[23] = CornerPoints[4];

    // draw frustum

    SimpleShaders::SetDeclPos();
    SimpleShaders::BeginShader_Transformed_ConstantColor( g_matViewProjection, Color );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 12, Lines, sizeof( XMFLOAT3 ) );
    SimpleShaders::EndShader();
}

VOID DebugDraw::DrawAabb( const AxisAlignedBox& box, D3DCOLOR Color )
{
    XMMATRIX matWorld = XMMatrixScaling( box.Extents.x, box.Extents.y, box.Extents.z );
    XMVECTOR position = XMLoadFloat3( &box.Center );
    matWorld.r[3] = XMVectorSelect( matWorld.r[3], position, XMVectorSelectControl( 1, 1, 1, 0 ) );

    DrawCubeWireframe( matWorld, Color );
}

VOID DebugDraw::DrawObb( const OrientedBox& obb, D3DCOLOR Color )
{
    XMMATRIX matWorld = XMMatrixRotationQuaternion( XMLoadFloat4( &obb.Orientation ) );
    XMMATRIX matScale = XMMatrixScaling( obb.Extents.x, obb.Extents.y, obb.Extents.z );
    matWorld = XMMatrixMultiply( matScale, matWorld );
    XMVECTOR position = XMLoadFloat3( &obb.Center );
    matWorld.r[3] = XMVectorSelect( matWorld.r[3], position, XMVectorSelectControl( 1, 1, 1, 0 ) );

    DrawCubeWireframe( matWorld, Color );
}

} // namespace ATG

```

`XenonDumper/libs/Atg/AtgDebugDraw.h`:

```h
//-----------------------------------------------------------------------------
// AtgDebugDraw.h
//
// A rendering library for drawing simple primitives.  These are not optimized for
// speed - just ease of use.
//
// You must initialize the SimpleShaders class in AtgSimpleShaders.h/.cpp before using
// the debug primitives.
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef ATGDEBUGDRAW_H
#define ATGDEBUGDRAW_H

#include <xboxmath.h>
#include "AtgBound.h"
#include "AtgCollision.h"

namespace ATG
{

class DebugDraw
{
public:
    // Call SetViewProjection with your camera matrix before using the draw calls.
    static VOID SetViewProjection( const XMMATRIX& matViewProjection );

    // Debug draw commands.  All vectors and sizes are in world space.
    static VOID DrawAxes( const XMMATRIX& matWorld );
    static VOID DrawCubeWireframe( const XMFLOAT3& Center, const XMFLOAT3& HalfSize, D3DCOLOR Color );
    static VOID DrawCubeWireframe( const XMMATRIX& matWorld, D3DCOLOR Color );
    static VOID DrawLineSegment( const XMFLOAT3& Origin, const XMFLOAT3& End, D3DCOLOR Color );
    static VOID DrawRay( const XMFLOAT3& Origin, const XMFLOAT3& Direction, BOOL bNormalize, D3DCOLOR Color );
    static VOID DrawRing( const XMFLOAT3& Origin, const XMFLOAT3& MajorAxis, const XMFLOAT3& MinorAxis,
                          D3DCOLOR Color );
    static VOID DrawSphere( const XMFLOAT3& Origin, FLOAT fRadius, D3DCOLOR Color );
    static VOID DrawGrid( const XMFLOAT3& XAxis, const XMFLOAT3& YAxis, const XMFLOAT3& Origin, INT iXDivisions,
                          INT iYDivisions, D3DCOLOR Color );
    static VOID DrawTriangle( const XMFLOAT3& PointA, const XMFLOAT3& PointB, const XMFLOAT3& PointC, D3DCOLOR Color );
    static VOID DrawConeWireframe( const XMFLOAT3& CenterBase, const XMFLOAT3& Axis, FLOAT fBaseRadius,
                                   FLOAT fTopRadius, D3DCOLOR Color );
    static VOID DrawConeWireframe( const XMMATRIX& matWorld, FLOAT fBaseRadius, FLOAT fTopRadius, D3DCOLOR Color );
    static VOID DrawQuad( const XMFLOAT3& CornerA, const XMFLOAT3& CornerB, const XMFLOAT3& CornerC, D3DCOLOR Color );
    static VOID DrawQuad( const XMFLOAT3& CornerA, const XMFLOAT3& CornerB, const XMFLOAT3& CornerC, const XMFLOAT3& CornerD, D3DCOLOR Color );
    static VOID DrawTexturedQuad( const XMFLOAT3& CornerA, const XMFLOAT3& CornerB, const XMFLOAT3& CornerC,
                                  const XMFLOAT2& UVRepeat, D3DTexture* pTexture );
    static VOID DrawCubeQuery( const XMFLOAT3& Center, const XMFLOAT3& HalfSize );

    // Screen space debug draw primitives.  The viewport is disabled when drawing these primitives.
    // If the line width is less than 0, the screen space rect is drawn solid.
    static VOID DrawScreenSpaceLine( const XMFLOAT2& Origin, const XMFLOAT2& End, D3DCOLOR Color, FLOAT fLineWidth = 1 );
    static VOID DrawScreenSpaceLine( const XMFLOAT2& Origin, D3DCOLOR OriginColor, const XMFLOAT2& End, D3DCOLOR EndColor, FLOAT fLineWidth = 1 );
    static VOID DrawScreenSpaceLineList( const XMFLOAT2 Points[], UINT PointCount, D3DCOLOR Color, FLOAT fLineWidth = 1 );
    static VOID DrawScreenSpaceRect( const XMFLOAT2& Origin, const XMFLOAT2& Size, FLOAT fLineWidth, D3DCOLOR Color );
    static VOID DrawScreenSpaceRect( const D3DRECT& Rect, FLOAT fLineWidth, D3DCOLOR Color );
    static VOID DrawScreenSpaceTexturedRect( const D3DRECT& Rect, const D3DBaseTexture* pTexture, BOOL bDepthTexture =
                                             FALSE );
    static VOID DrawScreenSpaceTexturedRectColored( const D3DRECT& Rect, const D3DBaseTexture* pTexture, D3DCOLOR Color );

    static VOID DrawScreenSpaceTexturedRectPatch( const D3DRECT& Rect, XMFLOAT2 UVTopLeft, XMFLOAT2 UVTopRight, XMFLOAT2 UVBottomLeft, const D3DBaseTexture* pTexture, BOOL bDepthTexture =
                                             FALSE );
    static VOID DrawScreenSpaceTexturedRectPatchPointSampled( const D3DRECT& Rect, XMFLOAT2 UVTopLeft, XMFLOAT2 UVTopRight, XMFLOAT2 UVBottomLeft, const D3DBaseTexture* pTexture, BOOL bDepthTexture =
                                             FALSE );

    // Debug bounds drawing.
    static VOID DrawBound( const Bound& bound, D3DCOLOR Color );
    static VOID DrawSphere( const Sphere& sphere, D3DCOLOR Color );
    static VOID DrawFrustum( const Frustum& frustum, D3DCOLOR Color );
    static VOID DrawObb( const OrientedBox& obb, D3DCOLOR Color );
    static VOID DrawAabb( const AxisAlignedBox& box, D3DCOLOR Color );
};

} // namespace ATG

#endif

```

`XenonDumper/libs/Atg/AtgDevice.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// AtgDevice.cpp
//
// Over-loaded device to trap and optimize certain calls to D3D
//
// Microsoft Game Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#include "stdafx.h"
#include <vector>
#include "AtgDevice.h"
#include "AtgUtil.h"

namespace ATG
{

// Data structure to pair vertex elements with a previously-created vertex decl
struct VTX_DECL
{
    D3DVERTEXELEMENT9 pElements[MAXD3DDECLLENGTH];
    DWORD dwNumElements;
    D3DVertexDeclaration* pDeclaration;
};

//--------------------------------------------------------------------------------------
// Name: CreatePooledVertexDeclaration()
// Desc: Function to coalesce vertex declarations into a shared pool of vertex declarations
//--------------------------------------------------------------------------------------
HRESULT WINAPI CreatePooledVertexDeclaration( const D3DVERTEXELEMENT9* pVertexElements,
                                              D3DVertexDeclaration** ppVertexDeclaration )
{
    static std::vector <VTX_DECL> m_VertexDecls;

    // Count the number of vertex elements
    DWORD dwNumElements = 0;
    while( pVertexElements[dwNumElements].Stream < 16 )
        dwNumElements++;

    assert( dwNumElements <= MAXD3DDECLLENGTH );

    // Check for a previously-created vertex decl
    for( unsigned int i = 0; i < m_VertexDecls.size(); i++ )
    {
        if( ( m_VertexDecls[i].dwNumElements == dwNumElements ) &&
            ( !memcmp( m_VertexDecls[i].pElements, pVertexElements, sizeof( D3DVERTEXELEMENT9 ) * dwNumElements ) ) )
        {
            // If found, return it
            ( *ppVertexDeclaration ) = m_VertexDecls[i].pDeclaration;
            return S_OK;
        }
    }

    // No previously-created vertex decl was found, so create one
    ( *ppVertexDeclaration ) = D3DDevice_CreateVertexDeclaration( pVertexElements );

    // And save a record of it
    VTX_DECL d;
    XMemCpy( d.pElements, pVertexElements, sizeof( D3DVERTEXELEMENT9 ) * dwNumElements );
    d.dwNumElements = dwNumElements;
    d.pDeclaration = ( *ppVertexDeclaration );
    d.pDeclaration->AddRef();
    m_VertexDecls.push_back( d );

    return S_OK;
}

} // namespace ATG

#ifdef _XBOX

namespace ATG
{

//--------------------------------------------------------------------------------------
// Name: CreateVertexDeclaration()
// Desc: Overloaded function to coalesce vertex declarations
//--------------------------------------------------------------------------------------
HRESULT WINAPI D3DDevice::CreateVertexDeclaration( const D3DVERTEXELEMENT9* pVertexElements,
                                                  D3DVertexDeclaration** ppVertexDeclaration )
{
    return CreatePooledVertexDeclaration( pVertexElements, ppVertexDeclaration );
}


//--------------------------------------------------------------------------------------
// Name: SetVertexDeclaration()
// Desc: Overloaded function to avoid redundant calls to D3D
//--------------------------------------------------------------------------------------
D3DVOID WINAPI D3DDevice::SetVertexDeclaration( D3DVertexDeclaration* pDecl )
{
    static D3DVertexDeclaration* g_pDecl = NULL;
    // Synchronize with current D3D device state, to catch subsystems that do not go
    // through this codepath
    D3DVertexDeclaration* pCurrentDecl = D3DDevice_GetVertexDeclaration( this );
    g_pDecl = pCurrentDecl;
    if( pCurrentDecl != NULL )
        pCurrentDecl->Release();
    // Only update decl if it has changed
    if( g_pDecl != pDecl )
    {
        D3DDevice_SetVertexDeclaration( this, pDecl );
        g_pDecl = pDecl;
    }
    D3DVOIDRETURN;
}


//--------------------------------------------------------------------------------------
// Name: SetVertexShader()
// Desc: Overloaded function to avoid redundant calls to D3D
//--------------------------------------------------------------------------------------
D3DVOID WINAPI D3DDevice::SetVertexShader( D3DVertexShader* pShader )
{
    static D3DVertexShader* g_pShader = NULL;
    // Synchronize with current D3D device state, to catch subsystems that do not go
    // through this codepath
    D3DVertexShader* pCurrentVS = NULL;
    D3DDevice_GetVertexShader( this, &pCurrentVS );
    g_pShader = pCurrentVS;
    if( pCurrentVS != NULL )
        pCurrentVS->Release();
    // Only update shader if it has changed
    if( g_pShader != pShader )
    {
        D3DDevice_SetVertexShader( this, pShader );
        g_pShader = pShader;
    }
    D3DVOIDRETURN;
}


//--------------------------------------------------------------------------------------
// Name: SetPixelShader()
// Desc: Overloaded function to avoid redundant calls to D3D
//--------------------------------------------------------------------------------------
D3DVOID WINAPI D3DDevice::SetPixelShader( D3DPixelShader* pShader )
{
    static D3DPixelShader* g_pShader = NULL;
    // Synchronize with current D3D device state, to catch subsystems that do not go
    // through this codepath
    D3DPixelShader* pCurrentPS = NULL;
    D3DDevice_GetPixelShader( this, &pCurrentPS );
    g_pShader = pCurrentPS;
    if( pCurrentPS != NULL )
        pCurrentPS->Release();
    // Only update shader if it has changed
    if( g_pShader != pShader )
    {
        D3DDevice_SetPixelShader( this, pShader );
        g_pShader = pShader;
    }
    D3DVOIDRETURN;
}


} // namespace ATG

#endif // _XBOX

```

`XenonDumper/libs/Atg/AtgDevice.h`:

```h
//--------------------------------------------------------------------------------------
// AtgDevice.h
//
// Over-loaded device to trap and optimize certain calls to D3D
//
// Microsoft Game Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#pragma once
#ifndef ATGDEVICE_H
#define ATGDEVICE_H

namespace ATG
{

//--------------------------------------------------------------------------------------
// Name: CreatePooledVertexDeclaration()
// Desc: Function to coalesce vertex declarations into a shared pool of vertex declarations
//--------------------------------------------------------------------------------------
HRESULT WINAPI CreatePooledVertexDeclaration( const D3DVERTEXELEMENT9* pVertexElements,
                                              D3DVertexDeclaration** ppVertexDeclaration );
}

#ifdef _XBOX

namespace ATG
{

//--------------------------------------------------------------------------------------
// struct ATG::D3DDevice
// Over-loaded device to trap and optimize certain calls to D3D
//--------------------------------------------------------------------------------------
struct D3DDevice : public ::D3DDevice
{
    D3DVOID WINAPI SetVertexShader( D3DVertexShader *pShader );
    D3DVOID WINAPI SetPixelShader( D3DPixelShader* pShader );
    D3DVOID WINAPI SetVertexDeclaration( D3DVertexDeclaration *pDecl);
    HRESULT WINAPI CreateVertexDeclaration( const D3DVERTEXELEMENT9* pVertexElements,
                                            D3DVertexDeclaration **ppVertexDeclaration );
};


} // namespace ATG

#endif // _XBOX

#endif // ATGDEVICE_H

```

`XenonDumper/libs/Atg/AtgDsp.cpp`:

```cpp
#include "stdafx.h"
#include "ATGDsp.h"

#define _USE_MATH_DEFINES
#include <math.h>

namespace ATG
{

void CalcLowpassCoeffs( float Fc, float Q, vector4_out coeffsA, vector4_out coeffsB )
{
    Q = ( float )__fsel( Q, Q, .0001f );
    Fc = ( float )__fsel( Fc, Fc, FLT_EPSILON * 2.0f );

    float w0 = ( float )M_PI * Fc;
    float sin0 = sin( w0 );
    float cos0 = cos( w0 );

    float alpha = sin0 / ( 2.0f * Q );

    float a0 = alpha + 1.0f;
    coeffsA.v[0] = ( -2.0f * cos0 ) / a0;
    coeffsA.v[1] = ( 1.0f - alpha ) / a0;
    coeffsA.v[2] = 0.0f;
    coeffsA.v[3] = 0.0f;

    coeffsB.v[0] = ( ( 1.0f - cos0 ) / 2.0f ) / a0;
    coeffsB.v[1] = ( 1.0f - cos0 ) / a0;
    coeffsB.v[2] = ( ( 1.0f - cos0 ) / 2.0f ) / a0;
    coeffsB.v[3] = 0.0f;
}
void CalcHighpassCoeffs( float Fc, float Q, vector4_out coeffsA, vector4_out coeffsB )
{
    Q = (float)__fsel( Q, Q, .0001f );
    Fc = (float)__fsel( Fc, Fc, FLT_EPSILON * 2.0f );

    float w0 = (float)M_PI*Fc;
    float sin0 = sin(w0);
    float cos0 = cos(w0);

    float alpha = sin0/(2.0f*Q);

    float a0 = alpha + 1.0f;
    coeffsA.v[0] =( -2.0f * cos0)/a0;
    coeffsA.v[1] = (1.0f - alpha)/a0;
    coeffsA.v[2] = 0.0f;
    coeffsA.v[3] = 0.0f;

    coeffsB.v[0] = ((1.0f + cos0)/2.0f)/a0;
    coeffsB.v[1] = (-(1.0f + cos0))/a0;
    coeffsB.v[2] = ((1.0f + cos0)/2.0f)/a0;
    coeffsB.v[3] = 0.0f;
}

void CalcBandpassCoeffs( float Fc, float Q, float gain, vector4_out coeffsA, vector4_out coeffsB )
{
    Q = ( float )__fsel( Q, Q, .0001f );
    Fc = ( float )__fsel( Fc, Fc, FLT_EPSILON * 2.0f );

    float w0 = ( float )M_PI * Fc;
    float sin0 = sin( w0 );
    float cos0 = cos( w0 );

    float alpha = sin0 / ( 2.0f * Q );


    float a0 = alpha + 1.0f;
    coeffsA.v[0] = ( -2.0f * cos0 ) / a0;
    coeffsA.v[1] = ( 1.0f - alpha ) / a0;
    coeffsA.v[2] = 0.0f;
    coeffsA.v[3] = 0.0f;

    coeffsB.v[0] = gain * ( sin0 / 2.0f ) / a0;
    coeffsB.v[1] = 0.0f;
    coeffsB.v[2] = gain * ( -sin0 / 2.0f ) / a0;
    coeffsB.v[3] = 0.0f;
}

//
// Distortion compressor used for Radioize effect
//
__vector4 CalcDistortionCompressorCoeffs( float t, float r, float k )
{
    __vector4 coeffs;

    float denom = -8*k*t - 3*t*t*t + t*t*t*t - 8*t*k*k -3*k*t*t*t + 2*k*k*t*t + 6*k*k +2*t*t + 11*k*t*t;
    coeffs.v[0] = -0.5f * ( ( -3*k + 4*t - 3 + 3*k*r - 4*t*r + 3*r ) / denom ); 
    coeffs.v[1] = ( 2*k*k*r - 2*k*k + 2*k*r - 2*k - 3*t*t*r + 3*t*t + 2*r - 2 ) / denom;
    coeffs.v[2] = -0.5f * ( t * ( -8*k*k + 8*k*k*r - 9*r*k*t + 9*k*t - 8*k + 8*k*r - 9*t*r + 9*t - 8 + 8*r ) / denom );
    coeffs.v[3] = ( 9*k*t*t - 8*t*k*k + 2*t*t*r + t*t*t*t*r - 3*t*t*t*r + 2*t*t*k*k*r + 2*k*t*t*r - 3*t*t*t*k*r - 8*k*t + 6*k*k ) / denom;

    return coeffs;
}

void WINAPI CalcSoftKneeCompressorParams( float t, float k, float r, SoftKneeCompressorParams* pParams )
{
    pParams->ratio.v[0] = r;
    pParams->ratio = __vspltw( pParams->ratio, 0 );

    pParams->threshold1.v[0] = t - k / 2.0f;
    pParams->threshold1 = __vspltw( pParams->threshold1, 0 );

    pParams->threshold2.v[0] = t + k / 2.0f;
    pParams->threshold2 = __vspltw( pParams->threshold2, 0 );

    //
    // Generated from the following Maple code:
    // f := proc (x) options operator, arrow; a*x^4+b*x^3+c*x^2+d*x end proc;
    // s := proc (t, k, r) options operator, arrow; {
    //                  f(t-(1/2)*k) = t-(1/2)*k, eval(diff(f(x), x), x = t-(1/2)*k) = 1, 
    //                  eval(diff(f(x), x), x = t+(1/2)*k) = r, 
    //                  eval(diff(f(x), x), x = t) = r + ( 1- r )/2 } end proc;  
    // solve(s(t,k,r),{a,b,c}) end proc;
    //
    float a = -2 * (r - 1) / (k * k + 4 * t * k + 4 * t * t) / k;
    float b = 8 * (r - 1) / (k * k + 4 * t * k + 4 * t * t) / k * t;
    float c = (1 / k * (-20 * t * t * r + 20 * t * t + 4 * t * k * r - 4 * t * k + 3 * k * k * r - 3 * k * k) / (k * k + 4 * t * k + 4 * t * t)) / (float)0.2e1;
    float d = ((k * k + k * k * r - 4 * t * k * r + 8 * t * k + 4 * t * t * r - 4 * t * t) / k / (2 * t + k)) / (float)0.2e1;

    pParams->coeffs.v[0] = a;
    pParams->coeffs.v[1] = b;
    pParams->coeffs.v[2] = c;
    pParams->coeffs.v[3] = d;

    // evaluate the transfer polynomial at t+ k/2--this gives us the 
    // amplitude at the end of the knee
    if( k != 0 )
    {
        float x = t + k / 2.0f;
        pParams->endOfKneeValue.v[0] =
            a * x * x * x * x
            + b * x * x * x
            + c * x * x
            + d * x;
        pParams->endOfKneeValue = __vspltw( pParams->endOfKneeValue, 0 );
    }
    else
    {
        pParams->endOfKneeValue = pParams->threshold1;
    }
}



}
// namespace ATG

```

`XenonDumper/libs/Atg/AtgDsp.h`:

```h
//--------------------------------------------------------------------------------------
// ATGDsp.h
//
// XNA Developer Connection
// Copyright (C) Microsoft Corporation. All rights reserved.
//
// A set of optimized "building blocks" for DSP work. Common DSP algorithms are
// represented by inline functions whose names end in "Core." Many algorithms also 
// have associated helper functions which are used to calculate parameters. 
//
// In the interests of runtime speed, all core functions are implemented entirely
// in VMX. Unless otherwise noted, each function processes four samples at a time.
//--------------------------------------------------------------------------------------
#pragma once

#include "ATGMetaVMX.h"


namespace ATG
{
//--------------------------------------------------------------------------------------
// DelayLine
//
// Helper class for representing digital delay lines
//
// In digital audio, a delay line represents something like a queue, where samples
// are written at one end and retrieved from elsewhere--either at the other end of
// the queue, or at some intermediate point called a "tap."
//
// Even though delay lines are queuelike in concept, for efficiency they're usually
// implemented as circular buffers. This template implements a statically-sized array
// with a read pointer and a write pointer. To support the concept of taps, the array
// can be accessed via operator []. Since the buffer is circular, an out of bounds 
// index will simply wrap around. Negative indices are also supported, since in DSP
// literature delayed samples are often represented using a negative offset from 
// the current time. However, to keep things from getting too freaky, indices are
// limited to the range {-N...N}
//--------------------------------------------------------------------------------------
template<typename T, long N> class DelayLine
{
public:
                DelayLine()
                {
                    Clear();
                }

    //
    // Const and non-const index operators
    //
    // Note that indices are alwasy calculated as an offset 
    // from the current read pointer.
    //
    const T& operator[]( int idx ) const
    {
        _ASSERT( idx < N && idx > -N );
        return m_data[ ( m_writePtr + idx + N ) % N ];
    }

    T& operator[]( int idx )
    {
        _ASSERT( idx < N && idx > -N );
        return m_data[ ( m_writePtr + idx + N ) % N ];
    }

    //
    // Head/tail access
    //
    // Because the buffer is circular, the "head" is just the
    // item at the current write pointer. The write pointer 
    // increments as items are pushed, so the "tail" is always
    // one greater than the current write pointer.
    //
    const T& Head() const
    {
        return operator[]( 0 );
    }
    T& Head()
    {
        return operator[]( 0 );
    }
    const T& Tail() const
    {
        return operator[]( 1 );
    }
    T& Tail()
    {
        return operator[]( 1 );
    }

    //
    // "Push" increments the read pointer and writes a value
    // to the new head location. 
    //
    // Note that there's no corresponding "Pop" because the
    // queue size is fixed; each push is effectively a pop
    // as well since the new head value overwrites the old
    // tail.
    //
    void        Push( const T& value )
    {
        Head() = value;
        m_writePtr++;
        m_writePtr %= N;
    }

    void        Clear()
    {
        XMemSet( m_data, 0, sizeof( m_data ) ); m_writePtr = 0;
    }
    static long Length()
    {
        return N;
    }

private:
    T           m_data[N];
    int m_writePtr;
};



//--------------------------------------------------------------------------------------
// Root-Mean-Square (RMS)
// 
// RMS is an estimate of the energy present in a signal. The samples are squared and
// then averaged over some period of time, then the root of the average is taken.
// Usually a running average is more useful than a total, so a delay line is used
// to keep track of the window over which the samples are averaged. The windowLen
// value is the number of four-element vectors in the window, NOT the number of samples.
// The number of samples is windowLen * 4.
//
// The accumulator vector is used to maintain the algorithm's internal state. It should
// be initialized to zero.
//
//--------------------------------------------------------------------------------------
template<DWORD windowLen> __vector4 __forceinline RmsCore( vector4_in input, DelayLine<__vector4, windowLen>* __restrict window, vector4_inout accumulator, __vector4 oneOverWindowLen )
 {
    // 
    // Square the four newest input samples
    //
    __vector4 square = __vmulfp( input, input );

    // Grab the four oldest squared samples, then push the four
    // newest
    //
    __vector4 tail = window->Tail();
    window->Push( square );

    //
    // Compute the running average over the four samples. For each 
    // sample we conceptually need to add the new value while
    // simultaneously subtracting the oldest value in the window.
    // For efficiency we'll do the subtractions in parallel, 
    // then accumulate using rotate/inserts and adds.
    //
    __vector4 abcd = __vsubfp( square, tail );

    __vector4 total = __vmsum4fp( abcd, Ones );

    __vector4 _abc = __vrlimi( __vzero(), abcd, 7, 3 );
    __vector4 __ab = __vrlimi( __vzero(), abcd, 3, 2 );
    __vector4 ___a = __vrlimi( __vzero(), abcd, 1, 1 );


    //
    // The output is the accumulator value plus the accumulation
    // of each input sample
    // 
    __vector4 output = accumulator;
    output = __vaddfp( output, __vaddfp( abcd, _abc ) );
    output = __vaddfp( output, __vaddfp( __ab, ___a ) );

    accumulator = __vaddfp( accumulator, total );

    // Compute the average by dividing the accumulated totals by
    // the window length.
    //
    output = __vmulfp( output, oneOverWindowLen );

    // Take the square root of the average. This code uses the VMX
    // reciprocal square root estimate instruction, which is only
    // accurate to about 12 bits. That's probably enough precision
    // for most applications, but for highest fidelity we'd want
    // to refine the result with an iteration or two of Newton's method.
    //
    __vector4 isZero = __vcmpgefp( __vzero(), output );
    output = __vmulfp( output, __vrsqrtefp( output ) );
    output = __vsel( output, __vzero(), isZero );

    return output;
}

//--------------------------------------------------------------------------------------
// Automatic gain control
//
// Varies the gain on an input signal based on how greatly the signal's RMS differs
// from a target value.
//
// If this function is used in conjunction with RMSCore and the window length is long
// enough, the effect will be to keep the output signal fairly close to the input
// signal without overly distorting the audio. Shorter windows, non-RMS values, or
// animated target values can be useful for special effects. 
//
//--------------------------------------------------------------------------------------
__vector4 __forceinline AgcCore( vector4_in input, vector4_out output, vector4_in rms, vector4_in target )
{
    __vector4 absAmp = __vand( rms, vectorNonSignBits.v );
    __vector4 diff = __vsubfp( target, absAmp );
    __vector4 gain = __vaddfp( Ones, __vmulfp( diff, __vrefp( rms ) ) );
    output = __vsel( __vmulfp( input, gain ), __vzero(), __vcmpgefp( __vzero(), rms ) );
}

//--------------------------------------------------------------------------------------
// Filter
//
// This is a standard "Direct Form 1" biquad filter implementation, which can be
// used to represent several different types of filter depending on the coefficients
// used. Helpers to generate a few different filter types are included. 
// 
// Biquad filters are IIR, or Infinite Impulse Response, designs. In practice this 
// means that the filter uses a feedback mechanism: each calculation requires not
// only an input sample but also a number of previous samples from both the input
// and the output. The particular design used here is optimal because it requires 
// exactly four output samples, which means that the output can be recycled one 
// vector at a time.
//--------------------------------------------------------------------------------------
void CalcLowpassCoeffs( float Fc, float Q, vector4_out coeffsA, vector4_out coeffsB );
void CalcHighpassCoeffs( float Fc, float Q, vector4_out coeffsA, vector4_out coeffsB );
void CalcBandpassCoeffs( float Fc, float Q, float gain, vector4_out coeffsA, vector4_out coeffsB );

const static __vector4 DelayLinePermute1 = { vpermY0.f, vpermZ0.f, vpermW0.f, vpermX1.f };
const static __vector4 DelayLinePermute2 = { vpermZ0.f, vpermW0.f, vpermX1.f, vpermY1.f };
const static __vector4 DelayLinePermute3 = { vpermW0.f, vpermX1.f, vpermY1.f, vpermZ1.f };

void __forceinline FilterCore( 
                vector4_in  input,
                vector4_out output,
                vector4_in  prevInput, 
                vector4_in  prevOutput,
                vector4_in  coeffA,
                vector4_in  coeffB )
{
    // Vectors of samples are defined such that X is the earliest in time and W is the
    // latest. This is the reverse of the way the filter coefficients are declared: 
    // A.X should be multipled with the most recent output. We need to reverse one of the
    // two sets of vectors. 
    __vector4 A = __vpermwi( coeffA, 0xe4 );
    __vector4 B = __vpermwi( coeffB, 0xe4 );

    __vector4 xValues = __vperm( prevInput, input, DelayLinePermute1 );
    __vector4 yValues = prevOutput;
    __vector4 outValue = __vsubfp( __vmsum4fp( xValues, B ), __vmsum4fp( yValues, A ) );
    output = outValue;


    xValues = __vperm( prevInput, input, DelayLinePermute2 );
    yValues = __vrlimi( outValue, yValues, 0xE, 1 ); // ( XYZW, OOOO ) -> YZWO
    outValue = __vsubfp( __vmsum4fp( xValues, B ), __vmsum4fp( yValues, A ) );
    output = __vrlimi( output, outValue, 4, 0 );

    xValues = __vperm( prevInput, input, DelayLinePermute3 );
    yValues = __vrlimi( outValue, yValues, 0xE, 1 ); // ( XYZW, OOOO ) -> YZWO
    outValue = __vsubfp( __vmsum4fp( xValues, B ), __vmsum4fp( yValues, A ) );
    output = __vrlimi( output, outValue, 2, 0 );

    xValues = input;
    yValues = __vrlimi( outValue, yValues, 0xE, 1 ); // ( XYZW, OOOO ) -> YZWO
    outValue = __vsubfp( __vmsum4fp( xValues, B ), __vmsum4fp( yValues, A ) );
    output = __vrlimi( output, outValue, 1, 0 );

}


//--------------------------------------------------------------------------------------
// Compressor
//
// Compressors are a more sophisticated version of automatic gain control. Rather 
// than simply adjusting the gain toward a target, they reduce gain on louder 
// material while leaving softer material unchanged. The basic transfer function (plot
// of input vs. output) of a compressor is a diagonal line of slope 1 from the origin
// to a point called the threshold. After that point, the line's slope is less than
// one. The new slope is called the compressor's ratio. For historical reasons the
// ratio is usually written as a reciprocal--for instance, a ratio of .1 would be
// described as 10:1 compression.
//
// A compressor whose transfer function transitions abruptly at the threshold is
// called a "hard-knee" compressor. More sophisticated compressors transition
// gradually, usually preserving C1 or C2 continuity along the transfer function.
// This is called "soft-knee" compression.
//
// This compressor has three important parameters:
//      Ratio       - the compression ratio as described above
//      Knee        - the width of the transition between no compression (1:1) and 
//                    full compression (<1/ratio>:1).
//      Threshold   - the center point of the transition
//
//--------------------------------------------------------------------------------------
struct SoftKneeCompressorParams
{
    __vector4 threshold1;
    __vector4 threshold2;
    __vector4 ratio;
    __vector4 coeffs;
    __vector4 endOfKneeValue;
};
void WINAPI CalcSoftKneeCompressorParams( float threshold, float knee, float ratio,
                                          SoftKneeCompressorParams* out_pParams );

//
// Creating the "soft knee" requires a fourth-order polynomial evaluation.
// This is a useful function in its own right, so it's exposed independently.
//
__vector4 __forceinline EvalPolynomial4( vector4_in coeffs, vector4_in x )
{
    // Splat the coefficients so we can do four samples in parallel
    //
    __vector4 a = __vspltw( coeffs, 0 );
    __vector4 b = __vspltw( coeffs, 1 );
    __vector4 c = __vspltw( coeffs, 2 );
    __vector4 d = __vspltw( coeffs, 3 );

    // Take the square, cube, and fourth power of each sample
    //
    __vector4 x2 = __vmulfp( x, x );
    __vector4 x3 = __vmulfp( x, x2 );
    __vector4 x4 = __vmulfp( x2, x2 );

    // fmadd the coefficients with the corresponding
    // samples
    __vector4 y = __vmaddfp( x, d,
        __vmaddfp( x2, c,
        __vmaddfp( x3, b,
        __vmulfp( x4, a ) ) ) );

    return y;
}

void __forceinline SoftKneeCompressorCore( 
    vector4_in input,
    vector4_out output, 
    vector4_in threshold1,
    vector4_in threshold2,
    vector4_in ratio,
    vector4_in coeffs,
    vector4_in endOfKneeValue )
{
    // 
    // Get the input's absolute value and its reciprocal
    //
    __vector4 x = __vand( input, vectorNonSignBits.v );
    __vector4 oneOverX = __vrefp( x );

    //
    // Two evaluations: t1 is the polynomial at x.
    // t2 is the line that comes after the polynomial,
    // whose slope is the compressor's ratio.
    //
    __vector4 t1 = EvalPolynomial4( coeffs, x );
    __vector4 t2 = __vmaddfp( __vsubfp( x, threshold2 ), ratio, endOfKneeValue );

    //
    // Use vsel to figure out which value is valid: Below threshold1 we
    // return x, in the knee range we return the polynomial at x, above that
    // we return x * the ratio. We clamp to 1.0f.
    //
    __vector4 transfer = __vsel( x, t1, __vcmpgefp( x, threshold1 ) );
    transfer = __vsel( transfer, t2, __vcmpgefp( x, threshold2 ) );
    
    output = __vsel( __vmulfp( transfer, oneOverX ), __vzero(), __vcmpeqfp( x, __vzero() ) );
	output = __vsel(output,Ones,__vcmpgefp(output,Ones));

}

} // Namespace ATG

```

`XenonDumper/libs/Atg/AtgEnumStrings.cpp`:

```cpp
//-----------------------------------------------------------------------------
// enumstrings.cpp
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "AtgEnumStrings.h"
#include "AtgLight.h"
#include "AtgCamera.h"
#include "AtgBound.h"

namespace ATG
{

//-----------------------------------------------------------------------------
EnumStringMap D3DXREGISTER_SET_StringMap[] =
{
    { D3DXRS_BOOL, L"BOOL" },
    { D3DXRS_INT4, L"INT4" },
    { D3DXRS_FLOAT4, L"FLOAT4" },
    { D3DXRS_SAMPLER, L"SAMPLER" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DXPARAMETER_CLASS_StringMap[] = 
{
    { D3DXPC_SCALAR, L"SCALAR" },
    { D3DXPC_VECTOR, L"VECTOR" },
    { D3DXPC_MATRIX_ROWS, L"MATRIX_ROWS" },
    { D3DXPC_MATRIX_COLUMNS, L"MATRIX_COLUMNS" },
    { D3DXPC_OBJECT, L"OBJECT" },
    { D3DXPC_STRUCT, L"STRUCT" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DXPARAMETER_TYPE_StringMap[] =
{
    { D3DXPT_VOID, L"VOID" },
    { D3DXPT_BOOL, L"BOOL" },
    { D3DXPT_INT, L"INT" },
    { D3DXPT_FLOAT, L"FLOAT" },
    { D3DXPT_STRING, L"STRING" },
    { D3DXPT_TEXTURE, L"TEXTURE" },
    { D3DXPT_TEXTURE1D, L"TEXTURE1D" },
    { D3DXPT_TEXTURE2D, L"TEXTURE2D" },
    { D3DXPT_TEXTURE3D, L"TEXTURE3D" },
    { D3DXPT_TEXTURECUBE, L"TEXTURECUBE" },
    { D3DXPT_SAMPLER, L"SAMPLER" },
    { D3DXPT_SAMPLER1D, L"SAMPLER1D" },
    { D3DXPT_SAMPLER2D, L"SAMPLER2D" },
    { D3DXPT_SAMPLER3D, L"SAMPLER3D" },
    { D3DXPT_SAMPLERCUBE, L"SAMPLERCUBE" },
    { D3DXPT_PIXELSHADER, L"PIXELSHADER" },
    { D3DXPT_VERTEXSHADER, L"VERTEXSHADER" },
    { D3DXPT_PIXELFRAGMENT, L"PIXELFRAGMENT" },
    { D3DXPT_VERTEXFRAGMENT, L"VERTEXFRAGMENT" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DFORMAT_StringMap[] = 
{
    { D3DFMT_DXT1, L"DXT1" },
    { D3DFMT_LIN_DXT1, L"LIN_DXT1" },
    { D3DFMT_DXT2, L"DXT2" },
    { D3DFMT_LIN_DXT2, L"LIN_DXT2" },
    { D3DFMT_DXT3, L"DXT3" },
    { D3DFMT_LIN_DXT3, L"LIN_DXT3" },
    { D3DFMT_DXT4, L"DXT4" },
    { D3DFMT_LIN_DXT4, L"LIN_DXT4" },
    { D3DFMT_DXT5, L"DXT5" },
    { D3DFMT_LIN_DXT5, L"LIN_DXT5" },
    { D3DFMT_DXN, L"DXN" },
    { D3DFMT_LIN_DXN, L"LIN_DXN" },
    { D3DFMT_A8, L"A8" },
    { D3DFMT_LIN_A8, L"LIN_A8" },
    { D3DFMT_L8, L"L8" },
    { D3DFMT_LIN_L8, L"LIN_L8" },
    { D3DFMT_R5G6B5, L"R5G6B5" },
    { D3DFMT_LIN_R5G6B5, L"LIN_R5G6B5" },
    { D3DFMT_R6G5B5, L"R6G5B5" },
    { D3DFMT_LIN_R6G5B5, L"LIN_R6G5B5" },
    { D3DFMT_L6V5U5, L"L6V5U5" },
    { D3DFMT_LIN_L6V5U5, L"LIN_L6V5U5" },
    { D3DFMT_X1R5G5B5, L"X1R5G5B5" },
    { D3DFMT_LIN_X1R5G5B5, L"LIN_X1R5G5B5" },
    { D3DFMT_A1R5G5B5, L"A1R5G5B5" },
    { D3DFMT_LIN_A1R5G5B5, L"LIN_A1R5G5B5" },
    { D3DFMT_A4R4G4B4, L"A4R4G4B4" },
    { D3DFMT_LIN_A4R4G4B4, L"LIN_A4R4G4B4" },
    { D3DFMT_X4R4G4B4, L"X4R4G4B4" },
    { D3DFMT_LIN_X4R4G4B4, L"LIN_X4R4G4B4" },
    { D3DFMT_Q4W4V4U4, L"Q4W4V4U4" },
    { D3DFMT_LIN_Q4W4V4U4, L"LIN_Q4W4V4U4" },
    { D3DFMT_A8L8, L"A8L8" },
    { D3DFMT_LIN_A8L8, L"LIN_A8L8" },
    { D3DFMT_G8R8, L"G8R8" },
    { D3DFMT_LIN_G8R8, L"LIN_G8R8" },
    { D3DFMT_V8U8, L"V8U8" },
    { D3DFMT_LIN_V8U8, L"LIN_V8U8" },
    { D3DFMT_D16, L"D16" },
    { D3DFMT_LIN_D16, L"LIN_D16" },
    { D3DFMT_L16, L"L16" },
    { D3DFMT_LIN_L16, L"LIN_L16" },
    { D3DFMT_R16F, L"R16F" },
    { D3DFMT_LIN_R16F, L"LIN_R16F" },
    { D3DFMT_R16F_EXPAND, L"R16F_EXPAND" },
    { D3DFMT_LIN_R16F_EXPAND, L"LIN_R16F_EXPAND" },
    { D3DFMT_UYVY, L"UYVY" },
    { D3DFMT_LIN_UYVY, L"LIN_UYVY" },
    { D3DFMT_G8R8_G8B8, L"G8R8_G8B8" },
    { D3DFMT_LIN_G8R8_G8B8, L"LIN_G8R8_G8B8" },
    { D3DFMT_R8G8_B8G8, L"R8G8_B8G8" },
    { D3DFMT_LIN_R8G8_B8G8, L"LIN_R8G8_B8G8" },
    { D3DFMT_YUY2, L"YUY2" },
    { D3DFMT_LIN_YUY2, L"LIN_YUY2" },
    { D3DFMT_A8R8G8B8, L"A8R8G8B8" },
    { D3DFMT_LIN_A8R8G8B8, L"LIN_A8R8G8B8" },
    { D3DFMT_X8R8G8B8, L"X8R8G8B8" },
    { D3DFMT_LIN_X8R8G8B8, L"LIN_X8R8G8B8" },
    { D3DFMT_A8B8G8R8, L"A8B8G8R8" },
    { D3DFMT_LIN_A8B8G8R8, L"LIN_A8B8G8R8" },
    { D3DFMT_X8B8G8R8, L"X8B8G8R8" },
    { D3DFMT_LIN_X8B8G8R8, L"LIN_X8B8G8R8" },
    { D3DFMT_X8L8V8U8, L"X8L8V8U8" },
    { D3DFMT_LIN_X8L8V8U8, L"LIN_X8L8V8U8" },
    { D3DFMT_Q8W8V8U8, L"Q8W8V8U8" },
    { D3DFMT_LIN_Q8W8V8U8, L"LIN_Q8W8V8U8" },
    { D3DFMT_A2R10G10B10, L"A2R10G10B10" },
    { D3DFMT_LIN_A2R10G10B10, L"LIN_A2R10G10B10" },
    { D3DFMT_X2R10G10B10, L"X2R10G10B10" },
    { D3DFMT_LIN_X2R10G10B10, L"LIN_X2R10G10B10" },
    { D3DFMT_A2B10G10R10, L"A2B10G10R10" },
    { D3DFMT_LIN_A2B10G10R10, L"LIN_A2B10G10R10" },
    { D3DFMT_A2W10V10U10, L"A2W10V10U10" },
    { D3DFMT_LIN_A2W10V10U10, L"LIN_A2W10V10U10" },
    { D3DFMT_A16L16, L"A16L16" },
    { D3DFMT_LIN_A16L16, L"LIN_A16L16" },
    { D3DFMT_G16R16, L"G16R16" },
    { D3DFMT_LIN_G16R16, L"LIN_G16R16" },
    { D3DFMT_V16U16, L"V16U16" },
    { D3DFMT_LIN_V16U16, L"LIN_V16U16" },
    { D3DFMT_R10G11B11, L"R10G11B11" },
    { D3DFMT_LIN_R10G11B11, L"LIN_R10G11B11" },
    { D3DFMT_R11G11B10, L"R11G11B10" },
    { D3DFMT_LIN_R11G11B10, L"LIN_R11G11B10" },
    { D3DFMT_W10V11U11, L"W10V11U11" },
    { D3DFMT_LIN_W10V11U11, L"LIN_W10V11U11" },
    { D3DFMT_W11V11U10, L"W11V11U10" },
    { D3DFMT_LIN_W11V11U10, L"LIN_W11V11U10" },
    { D3DFMT_G16R16F, L"G16R16F" },
    { D3DFMT_LIN_G16R16F, L"LIN_G16R16F" },
    { D3DFMT_G16R16F_EXPAND, L"G16R16F_EXPAND" },
    { D3DFMT_LIN_G16R16F_EXPAND, L"LIN_G16R16F_EXPAND" },
    { D3DFMT_L32, L"L32" },
    { D3DFMT_LIN_L32, L"LIN_L32" },
    { D3DFMT_R32F, L"R32F" },
    { D3DFMT_LIN_R32F, L"LIN_R32F" },
    { D3DFMT_A16B16G16R16, L"A16B16G16R16" },
    { D3DFMT_LIN_A16B16G16R16, L"LIN_A16B16G16R16" },
    { D3DFMT_Q16W16V16U16, L"Q16W16V16U16" },
    { D3DFMT_LIN_Q16W16V16U16, L"LIN_Q16W16V16U16" },
    { D3DFMT_A16B16G16R16F, L"A16B16G16R16F" },
    { D3DFMT_LIN_A16B16G16R16F, L"LIN_A16B16G16R16F" },
    { D3DFMT_A16B16G16R16F_EXPAND, L"A16B16G16R16F_EXPAND" },
    { D3DFMT_LIN_A16B16G16R16F_EXPAND, L"LIN_A16B16G16R16F_EXPAND" },
    { D3DFMT_A32L32, L"A32L32" },
    { D3DFMT_LIN_A32L32, L"LIN_A32L32" },
    { D3DFMT_G32R32, L"G32R32" },
    { D3DFMT_LIN_G32R32, L"LIN_G32R32" },
    { D3DFMT_V32U32, L"V32U32" },
    { D3DFMT_LIN_V32U32, L"LIN_V32U32" },
    { D3DFMT_G32R32F, L"G32R32F" },
    { D3DFMT_LIN_G32R32F, L"LIN_G32R32F" },
    { D3DFMT_A32B32G32R32, L"A32B32G32R32" },
    { D3DFMT_LIN_A32B32G32R32, L"LIN_A32B32G32R32" },
    { D3DFMT_Q32W32V32U32, L"Q32W32V32U32" },
    { D3DFMT_LIN_Q32W32V32U32, L"LIN_Q32W32V32U32" },
    { D3DFMT_A32B32G32R32F, L"A32B32G32R32F" },
    { D3DFMT_LIN_A32B32G32R32F, L"LIN_A32B32G32R32F" },
    { D3DFMT_A2B10G10R10F_EDRAM, L"A2B10G10R10F_EDRAM" },
    { D3DFMT_G16R16_EDRAM, L"G16R16_EDRAM" },
    { D3DFMT_A16B16G16R16_EDRAM, L"A16B16G16R16_EDRAM" },
    { D3DFMT_G16R16, L"G16R16" },
    { D3DFMT_A16B16G16R16, L"A16B16G16R16" },
    { D3DFMT_LE_X8R8G8B8, L"LE_X8R8G8B8" },
    { D3DFMT_LE_A8R8G8B8, L"LE_A8R8G8B8" },
    { D3DFMT_LE_X2R10G10B10, L"LE_X2R10G10B10" },
    { D3DFMT_LE_A2R10G10B10, L"LE_A2R10G10B10" },
    { D3DFMT_INDEX16, L"INDEX16" },
    { D3DFMT_INDEX32, L"INDEX32" },
    { D3DFMT_VERTEXDATA, L"VERTEXDATA" },
    { DWORD(D3DFMT_UNKNOWN), L"UNKNOWN" },
    { D3DFMT_DXT3A, L"DXT3A" },
    { D3DFMT_LIN_DXT3A, L"LIN_DXT3A" },
    { D3DFMT_DXT3A_1111, L"DXT3A_1111" },
    { D3DFMT_LIN_DXT3A_1111, L"LIN_DXT3A_1111" },
    { D3DFMT_DXT5A, L"DXT5A" },
    { D3DFMT_LIN_DXT5A, L"LIN_DXT5A" },
    { D3DFMT_CTX1, L"CTX1" },
    { D3DFMT_LIN_CTX1, L"LIN_CTX1" },
    { D3DFMT_D24S8, L"D24S8" },
    { D3DFMT_LIN_D24S8, L"LIN_D24S8" },
    { D3DFMT_D24X8, L"D24X8" },
    { D3DFMT_LIN_D24X8, L"LIN_D24X8" },
    { D3DFMT_D24FS8, L"D24FS8" },
    { D3DFMT_LIN_D24FS8, L"LIN_D24FS8" },
    { D3DFMT_D32, L"D32" },
    { D3DFMT_LIN_D32, L"LIN_D32" },
    { 0, NULL }
};


//-----------------------------------------------------------------------------
EnumStringMap D3DX_FILTER_StringMap[] = 
{
    { D3DX_DEFAULT, L"DEFAULT" },
    { D3DX_FILTER_NONE, L"FILTER_NONE" },
    { D3DX_FILTER_POINT, L"FILTER_POINT" },
    { D3DX_FILTER_LINEAR, L"FILTER_LINEAR" },
    { D3DX_FILTER_TRIANGLE, L"FILTER_TRIANGLE" },
    { D3DX_FILTER_BOX, L"FILTER_BOX" },
    { D3DX_FILTER_MIRROR_U, L"FILTER_MIRROR_U" },
    { D3DX_FILTER_MIRROR_V, L"FILTER_MIRROR_V" },
    { D3DX_FILTER_MIRROR_W, L"FILTER_MIRROR_W" },
    { D3DX_FILTER_MIRROR, L"FILTER_MIRROR" },
    { D3DX_FILTER_DITHER, L"FILTER_DITHER" },
    { D3DX_FILTER_SRGB_IN, L"FILTER_SRGB_IN" },
    { D3DX_FILTER_SRGB_OUT, L"FILTER_SRGB_OUT" },
    { D3DX_FILTER_SRGB, L"FILTER_SRGB" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DDECLTYPE_StringMap[] = 
{
    { D3DDECLTYPE_FLOAT1, L"FLOAT1" },
    { D3DDECLTYPE_FLOAT2, L"FLOAT2" },
    { D3DDECLTYPE_FLOAT3, L"FLOAT3" },
    { D3DDECLTYPE_FLOAT4, L"FLOAT4" },
    { D3DDECLTYPE_INT1, L"INT1" },
    { D3DDECLTYPE_INT2, L"INT2" },
    { D3DDECLTYPE_INT4, L"INT4" },
    { D3DDECLTYPE_UINT1, L"UINT1" },
    { D3DDECLTYPE_UINT2, L"UINT2" },
    { D3DDECLTYPE_UINT4, L"UINT4" },
    { D3DDECLTYPE_INT1N, L"INT1N" },
    { D3DDECLTYPE_INT2N, L"INT2N" },
    { D3DDECLTYPE_INT4N, L"INT4N" },
    { D3DDECLTYPE_UINT1N, L"UINT1N" },
    { D3DDECLTYPE_UINT2N, L"UINT2N" },
    { D3DDECLTYPE_UINT4N, L"UINT4N" },
    { D3DDECLTYPE_D3DCOLOR, L"D3DCOLOR" },
    { D3DDECLTYPE_UBYTE4, L"UBYTE4" },
    { D3DDECLTYPE_BYTE4, L"BYTE4" },
    { D3DDECLTYPE_UBYTE4N, L"UBYTE4N" },
    { D3DDECLTYPE_BYTE4N, L"BYTE4N" },
    { D3DDECLTYPE_SHORT2, L"SHORT2" },
    { D3DDECLTYPE_SHORT4, L"SHORT4" },
    { D3DDECLTYPE_USHORT2, L"USHORT2" },
    { D3DDECLTYPE_USHORT4, L"USHORT4" },
    { D3DDECLTYPE_SHORT2N, L"SHORT2N" },
    { D3DDECLTYPE_SHORT4N, L"SHORT4N" },
    { D3DDECLTYPE_USHORT2N, L"USHORT2N" },
    { D3DDECLTYPE_USHORT4N, L"USHORT4N" },
    { D3DDECLTYPE_UDEC3, L"UDEC3" },
    { D3DDECLTYPE_DEC3, L"DEC3" },
    { D3DDECLTYPE_UDEC3N, L"UDEC3N" },
    { D3DDECLTYPE_DEC3N, L"DEC3N" },
    { D3DDECLTYPE_UDHEN3, L"UDHEN3" },
    { D3DDECLTYPE_DHEN3, L"DHEN3" },
    { D3DDECLTYPE_UDHEN3N, L"UDHEN3N" },
    { D3DDECLTYPE_DHEN3N, L"DHEN3N" },
    { D3DDECLTYPE_UHEND3, L"UHEND3" },
    { D3DDECLTYPE_HEND3, L"HEND3" },
    { D3DDECLTYPE_UHEND3N, L"UHEND3N" },
    { D3DDECLTYPE_HEND3N, L"HEND3N" },
    { D3DDECLTYPE_FLOAT16_2, L"FLOAT16_2" },
    { D3DDECLTYPE_FLOAT16_4, L"FLOAT16_4" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DDECLMETHOD_StringMap[] = 
{
    { D3DDECLMETHOD_DEFAULT, L"DEFAULT" },
    { D3DDECLMETHOD_PARTIALU, L"PARTIALU" },
    { D3DDECLMETHOD_PARTIALV, L"PARTIALV" },
    { D3DDECLMETHOD_CROSSUV, L"CROSSUV" },
    { D3DDECLMETHOD_UV, L"UV" },
    { D3DDECLMETHOD_LOOKUP, L"LOOKUP" },
    { D3DDECLMETHOD_LOOKUPPRESAMPLED, L"LOOKUPPRESAMPLED" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DDECLUSAGE_StringMap[] = 
{
    { D3DDECLUSAGE_POSITION, L"POSITION" },
    { D3DDECLUSAGE_BLENDWEIGHT, L"BLENDWEIGHT" },
    { D3DDECLUSAGE_BLENDINDICES, L"BLENDINDICES" },
    { D3DDECLUSAGE_NORMAL, L"NORMAL" },
    { D3DDECLUSAGE_PSIZE, L"PSIZE" },
    { D3DDECLUSAGE_TEXCOORD, L"TEXCOORD" },
    { D3DDECLUSAGE_TANGENT, L"TANGENT" },
    { D3DDECLUSAGE_BINORMAL, L"BINORMAL" },
    { D3DDECLUSAGE_TESSFACTOR, L"TESSFACTOR" },
    { D3DDECLUSAGE_COLOR, L"COLOR" },
    { D3DDECLUSAGE_FOG, L"FOG" },
    { D3DDECLUSAGE_DEPTH, L"DEPTH" },
    { D3DDECLUSAGE_SAMPLE, L"SAMPLE" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DFILLMODE_StringMap[] =
{
    { D3DFILL_POINT, L"POINT" },
    { D3DFILL_WIREFRAME, L"WIREFRAME" },
    { D3DFILL_SOLID, L"SOLID" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DBLEND_StringMap[] =
{
    { D3DBLEND_ZERO, L"ZERO" },
    { D3DBLEND_ONE, L"ONE" },
    { D3DBLEND_SRCCOLOR, L"SRCCOLOR" },
    { D3DBLEND_INVSRCCOLOR, L"INVSRCCOLOR" },
    { D3DBLEND_SRCALPHA, L"SRCALPHA" },
    { D3DBLEND_INVSRCALPHA, L"INVSRCALPHA" },
    { D3DBLEND_DESTCOLOR, L"DESTCOLOR" },
    { D3DBLEND_INVDESTCOLOR, L"INVDESTCOLOR" },
    { D3DBLEND_DESTALPHA, L"DESTALPHA" },
    { D3DBLEND_INVDESTALPHA, L"INVDESTALPHA" },
    { D3DBLEND_BLENDFACTOR, L"BLENDFACTOR" },
    { D3DBLEND_INVBLENDFACTOR, L"INVBLENDFACTOR" },
    { D3DBLEND_CONSTANTALPHA, L"CONSTANTALPHA" },
    { D3DBLEND_INVCONSTANTALPHA, L"INVCONSTANTALPHA" },
    { D3DBLEND_SRCALPHASAT, L"SRCALPHASAT" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DBLENDOP_StringMap[] =
{
    { D3DBLENDOP_ADD, L"ADD" },
    { D3DBLENDOP_SUBTRACT, L"SUBTRACT" },
    { D3DBLENDOP_MIN, L"MIN" },
    { D3DBLENDOP_MAX, L"MAX" },
    { D3DBLENDOP_REVSUBTRACT, L"REVSUBTRACT" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DTEXTUREADDRESS_StringMap[] =
{
    { D3DTADDRESS_WRAP, L"WRAP" },
    { D3DTADDRESS_MIRROR, L"MIRROR" },
    { D3DTADDRESS_CLAMP, L"CLAMP" },
    { D3DTADDRESS_BORDER, L"BORDER" },
    { D3DTADDRESS_MIRRORONCE, L"MIRRORONCE" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DCULL_StringMap[] =
{
    { D3DCULL_NONE, L"NONE" },
    { D3DCULL_CW, L"CW" },
    { D3DCULL_CCW, L"CCW" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DCMPFUNC_StringMap[] =
{
    { D3DCMP_NEVER, L"NEVER" },
    { D3DCMP_LESS, L"LESS" },
    { D3DCMP_EQUAL, L"EQUAL" },
    { D3DCMP_LESSEQUAL, L"LESSEQUAL" },
    { D3DCMP_GREATER, L"GREATER" },
    { D3DCMP_NOTEQUAL, L"NOTEQUAL" },
    { D3DCMP_GREATEREQUAL, L"GREATEREQUAL" },
    { D3DCMP_ALWAYS, L"ALWAYS" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DSTENCILOP_StringMap[] =
{
    { D3DSTENCILOP_KEEP, L"KEEP" },
    { D3DSTENCILOP_ZERO, L"ZERO" },
    { D3DSTENCILOP_REPLACE, L"REPLACE" },
    { D3DSTENCILOP_INCRSAT, L"INCRSAT" },
    { D3DSTENCILOP_DECRSAT, L"DECRSAT" },
    { D3DSTENCILOP_INVERT, L"INVERT" },
    { D3DSTENCILOP_INCR, L"INCR" },
    { D3DSTENCILOP_DECR, L"DECR" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DFOGMODE_StringMap[] =
{
    { D3DFOG_NONE, L"NONE" },
    { D3DFOG_EXP, L"EXP" },
    { D3DFOG_EXP2, L"EXP2" },
    { D3DFOG_LINEAR, L"LINEAR" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DZBUFFERTYPE_StringMap[] =
{
    { D3DZB_FALSE, L"FALSE" },
    { D3DZB_TRUE, L"TRUE" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DPRIMITIVETYPE_StringMap[] =
{
    { D3DPT_POINTLIST , L"POINTLIST " },
    { D3DPT_LINELIST, L"LINELIST" },
    { D3DPT_LINESTRIP, L"LINESTRIP" },
    { D3DPT_TRIANGLELIST, L"TRIANGLELIST" },
    { D3DPT_TRIANGLESTRIP, L"TRIANGLESTRIP" },
    { D3DPT_TRIANGLEFAN, L"TRIANGLEFAN" },
    { 0, NULL },
}; 

//-----------------------------------------------------------------------------
EnumStringMap D3DTRANSFORMSTATETYPE_StringMap[] =
{
    { D3DTS_VIEW, L"VIEW" },
    { D3DTS_PROJECTION, L"PROJECTION" },
    { D3DTS_TEXTURE0, L"TEXTURE0" },
    { D3DTS_TEXTURE1, L"TEXTURE1" },
    { D3DTS_TEXTURE2, L"TEXTURE2" },
    { D3DTS_TEXTURE3, L"TEXTURE3" },
    { D3DTS_TEXTURE4, L"TEXTURE4" },
    { D3DTS_TEXTURE5, L"TEXTURE5" },
    { D3DTS_TEXTURE6, L"TEXTURE6" },
    { D3DTS_TEXTURE7, L"TEXTURE7" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DWRAP_StringMap[] =
{
    { D3DWRAP_U, L"U" },
    { D3DWRAP_V, L"V" },
    { D3DWRAP_W, L"W" },
    { D3DWRAPCOORD_0, L"0" },
    { D3DWRAPCOORD_1, L"1" },
    { D3DWRAPCOORD_2, L"2" },
    { D3DWRAPCOORD_3, L"3" },
     { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DMATERIALCOLORSOURCE_StringMap[] =
{
    { D3DMCS_MATERIAL, L"MATERIAL" },
    { D3DMCS_COLOR1, L"COLOR1" },
    { D3DMCS_COLOR2, L"COLOR2" },
     { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DDEBUGMONITORTOKENS_StringMap[] =
{
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DVERTEXBLENDFLAGS_StringMap[] =
{
    { D3DVBF_DISABLE, L"DISABLE" },
    { D3DVBF_1WEIGHTS, L"1WEIGHTS" },
    { D3DVBF_2WEIGHTS, L"2WEIGHTS" },
    { D3DVBF_3WEIGHTS , L"3WEIGHTS " },
    { D3DVBF_TWEENING, L"TWEENING" },
    { D3DVBF_0WEIGHTS, L"0WEIGHTS" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DPATCHEDGESTYLE_StringMap[] =
{
    { D3DPATCHEDGE_DISCRETE, L"DISCRETE" },
    { D3DPATCHEDGE_CONTINUOUS, L"CONTINUOUS" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DDEGREETYPE_StringMap[] =
{
    { D3DDEGREE_LINEAR, L"LINEAR" },
    { D3DDEGREE_QUADRATIC, L"QUADRATIC" },
    { D3DDEGREE_CUBIC, L"CUBIC" },
    { D3DDEGREE_QUINTIC, L"QUINTIC" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DTEXTUREFILTERTYPE_StringMap[] =
{
    { D3DTEXF_NONE, L"NONE" },
    { D3DTEXF_POINT, L"POINT" },
    { D3DTEXF_LINEAR, L"LINEAR" },
    { D3DTEXF_ANISOTROPIC, L"ANISOTROPIC" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DTRILINEARTHRESHOLD_StringMap[] =
{
    { D3DTRILINEAR_IMMEDIATE, L"IMMEDIATE" },
    { D3DTRILINEAR_ONESIXTH, L"ONESIXTH" },
    { D3DTRILINEAR_ONEFOURTH, L"ONEFOURTH" },
    { D3DTRILINEAR_THREEEIGHTHS, L"THREEEIGHTHS" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DTEXTUREOP_StringMap[] =
{
    { D3DTOP_DISABLE, L"DISABLE" },
    { D3DTOP_SELECTARG1, L"SELECTARG1" },
    { D3DTOP_SELECTARG2, L"SELECTARG2" },
    { D3DTOP_MODULATE, L"MODULATE" },
    { D3DTOP_MODULATE2X, L"MODULATE2X" },
    { D3DTOP_MODULATE4X, L"MODULATE4X" },
    { D3DTOP_ADD, L"ADD" },
    { D3DTOP_ADDSIGNED, L"ADDSIGNED" },
    { D3DTOP_ADDSIGNED2X, L"ADDSIGNED2X" },
    { D3DTOP_SUBTRACT, L"SUBTRACT" },
    { D3DTOP_ADDSMOOTH, L"ADDSMOOTH" },
    { D3DTOP_BLENDDIFFUSEALPHA, L"BLENDDIFFUSEALPHA" },
    { D3DTOP_BLENDTEXTUREALPHA, L"BLENDTEXTUREALPHA" },
    { D3DTOP_BLENDFACTORALPHA, L"BLENDFACTORALPHA" },
    { D3DTOP_BLENDTEXTUREALPHAPM, L"BLENDTEXTUREALPHAPM" },
    { D3DTOP_BLENDCURRENTALPHA, L"BLENDCURRENTALPHA" },
    { D3DTOP_PREMODULATE, L"PREMODULATE" },
    { D3DTOP_MODULATEALPHA_ADDCOLOR, L"ADDCOLOR" },
    { D3DTOP_MODULATECOLOR_ADDALPHA, L"ADDALPHA" },
    { D3DTOP_MODULATEINVALPHA_ADDCOLOR, L"ADDCOLOR" },
    { D3DTOP_MODULATEINVCOLOR_ADDALPHA, L"ADDALPHA" },
    { D3DTOP_BUMPENVMAP, L"BUMPENVMAP" },
    { D3DTOP_BUMPENVMAPLUMINANCE, L"BUMPENVMAPLUMINANCE" },
    { D3DTOP_DOTPRODUCT3, L"DOTPRODUCT3" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DTA_StringMap[] =
{
    { D3DTA_SELECTMASK, L"SELECTMASK" },
    { D3DTA_DIFFUSE, L"DIFFUSE" },
    { D3DTA_CURRENT, L"CURRENT" },
    { D3DTA_TEXTURE, L"TEXTURE" },
    { D3DTA_TFACTOR, L"TFACTOR" },
    { D3DTA_SPECULAR, L"SPECULAR" },
    { D3DTA_TEMP, L"TEMP" },
    { D3DTA_CONSTANT, L"CONSTANT" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DTA_FLAGS_StringMap[] =
{
    { D3DTA_COMPLEMENT, L"COMPLEMENT" },
    { D3DTA_ALPHAREPLICATE, L"ALPHAREPLICATE" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DTEXTURETRANSFORMFLAGS_StringMap[] =
{
    { D3DTTFF_DISABLE, L"DISABLE" },
    { D3DTTFF_COUNT1, L"COUNT1" },
    { D3DTTFF_COUNT2, L"COUNT2" },
    { D3DTTFF_COUNT3, L"COUNT3" },
    { D3DTTFF_COUNT4, L"COUNT4" },
    { D3DTTFF_PROJECTED, L"PROJECTED" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DTSS_TCI_FLAGS_StringMap[] =
{
    { D3DTSS_TCI_CAMERASPACENORMAL, L"CAMERASPACENORMAL" },
    { D3DTSS_TCI_CAMERASPACEPOSITION, L"CAMERASPACEPOSITION" },
    { D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR, L"CAMERASPACEREFLECTIONVECTOR" },
    { D3DTSS_TCI_SPHEREMAP, L"SPHEREMAP" },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
EnumStringMap D3DCLEAR_StringMap[] =
{
    { D3DCLEAR_STENCIL, L"STENCIL" },
    { D3DCLEAR_TARGET, L"TARGET" },
    { D3DCLEAR_ZBUFFER, L"ZBUFFER" },
    { 0, NULL },
};

EnumStringMap D3DMULTISAMPLE_TYPE_StringMap[] = 
{
    { D3DMULTISAMPLE_NONE, L"NONE" },
    { D3DMULTISAMPLE_2_SAMPLES, L"2_SAMPLES" },
    { D3DMULTISAMPLE_4_SAMPLES, L"4_SAMPLES" },
    { 0, NULL },
};



//-----------------------------------------------------------------------------
StateStringMap D3DRENDERSTATETYPE_StateStringMap[] = 
{
    { D3DRS_VIEWPORTENABLE, L"VIEWPORTENABLE", STATE_TYPE_BOOL }, 
    { D3DRS_ZENABLE, L"ZENABLE", STATE_TYPE_ENUM, D3DZBUFFERTYPE_StringMap }, 
    { D3DRS_FILLMODE, L"FILLMODE", STATE_TYPE_ENUM, D3DFILLMODE_StringMap },
    { D3DRS_ZWRITEENABLE, L"ZWRITEENABLE", STATE_TYPE_BOOL },
    { D3DRS_ALPHATESTENABLE, L"ALPHATESTENABLE", STATE_TYPE_BOOL },
    { D3DRS_SRCBLEND, L"SRCBLEND", STATE_TYPE_ENUM, D3DBLEND_StringMap },
    { D3DRS_DESTBLEND, L"DESTBLEND", STATE_TYPE_ENUM, D3DBLEND_StringMap },
    { D3DRS_CULLMODE, L"CULLMODE", STATE_TYPE_ENUM, D3DCULL_StringMap },
    { D3DRS_ZFUNC, L"ZFUNC" , STATE_TYPE_ENUM, D3DCMPFUNC_StringMap },
    { D3DRS_ALPHAREF, L"ALPHAREF", STATE_TYPE_COLOR },
    { D3DRS_ALPHAFUNC, L"ALPHAFUNC", STATE_TYPE_ENUM, D3DCMPFUNC_StringMap },
//    { D3DRS_DITHERENABLE, L"DITHERENABLE", STATE_TYPE_BOOL },
    { D3DRS_ALPHABLENDENABLE, L"ALPHABLENDENABLE", STATE_TYPE_BOOL },
    { D3DRS_STENCILENABLE , L"STENCILENABLE", STATE_TYPE_BOOL },
    { D3DRS_STENCILFAIL , L"STENCILFAIL", STATE_TYPE_ENUM, D3DSTENCILOP_StringMap },
    { D3DRS_STENCILZFAIL , L"STENCILZFAIL", STATE_TYPE_ENUM, D3DSTENCILOP_StringMap },
    { D3DRS_STENCILPASS , L"STENCILPASS", STATE_TYPE_ENUM, D3DSTENCILOP_StringMap },
    { D3DRS_STENCILFUNC , L"STENCILFUNC", STATE_TYPE_ENUM, D3DCMPFUNC_StringMap },
    { D3DRS_STENCILREF , L"STENCILREF", STATE_TYPE_MASK },
    { D3DRS_STENCILMASK , L"STENCILMASK", STATE_TYPE_MASK },
    { D3DRS_STENCILWRITEMASK , L"STENCILWRITEMASK", STATE_TYPE_MASK },
    { D3DRS_WRAP0 , L"WRAP0", STATE_TYPE_ENUM, D3DWRAP_StringMap },
    { D3DRS_WRAP1 , L"WRAP1", STATE_TYPE_ENUM, D3DWRAP_StringMap },
    { D3DRS_WRAP2 , L"WRAP2", STATE_TYPE_ENUM, D3DWRAP_StringMap },
    { D3DRS_WRAP3 , L"WRAP3", STATE_TYPE_ENUM, D3DWRAP_StringMap },
    { D3DRS_WRAP4 , L"WRAP4", STATE_TYPE_ENUM, D3DWRAP_StringMap },
    { D3DRS_WRAP5 , L"WRAP5", STATE_TYPE_ENUM, D3DWRAP_StringMap },
    { D3DRS_WRAP6 , L"WRAP6", STATE_TYPE_ENUM, D3DWRAP_StringMap },
    { D3DRS_WRAP7 , L"WRAP7", STATE_TYPE_ENUM, D3DWRAP_StringMap },
    { D3DRS_CLIPPLANEENABLE , L"CLIPPLANEENABLE", STATE_TYPE_BOOL },
    { D3DRS_MULTISAMPLEANTIALIAS , L"MULTISAMPLEANTIALIAS", STATE_TYPE_BOOL },
    { D3DRS_MULTISAMPLEMASK , L"MULTISAMPLEMASK", STATE_TYPE_MASK },
//    { D3DRS_PATCHEDGESTYLE , L"PATCHEDGESTYLE", STATE_TYPE_ENUM,  D3DPATCHEDGESTYLE_StringMap },
    { D3DRS_COLORWRITEENABLE , L"COLORWRITEENABLE", STATE_TYPE_COLOR },
    { D3DRS_BLENDOP , L"BLENDOP", STATE_TYPE_ENUM, D3DBLENDOP_StringMap },
//    { D3DRS_POSITIONDEGREE , L"POSITIONDEGREE", STATE_TYPE_ENUM, D3DDEGREETYPE_StringMap },
//    { D3DRS_NORMALDEGREE , L"NORMALDEGREE", STATE_TYPE_ENUM, D3DDEGREETYPE_StringMap },
    { D3DRS_SCISSORTESTENABLE , L"SCISSORTESTENABLE", STATE_TYPE_BOOL },
    { D3DRS_SLOPESCALEDEPTHBIAS , L"SLOPESCALEDEPTHBIAS", STATE_TYPE_FLOAT },
//    { D3DRS_ANTIALIASEDLINEENABLE , L"ANTIALIASEDLINEENABLE", STATE_TYPE_BOOL },
    { D3DRS_MINTESSELLATIONLEVEL , L"MINTESSELLATIONLEVEL" , STATE_TYPE_FLOAT },
    { D3DRS_MAXTESSELLATIONLEVEL , L"MAXTESSELLATIONLEVEL", STATE_TYPE_FLOAT },
//    { D3DRS_ADAPTIVETESS_X , L"ADAPTIVETESS_X", STATE_TYPE_FLOAT },
//    { D3DRS_ADAPTIVETESS_Y , L"ADAPTIVETESS_Y", STATE_TYPE_FLOAT },
//    { D3DRS_ADAPTIVETESS_Z , L"ADAPTIVETESS_Z", STATE_TYPE_FLOAT },
//    { D3DRS_ADAPTIVETESS_W , L"ADAPTIVETESS_W", STATE_TYPE_FLOAT },
//    { D3DRS_ENABLEADAPTIVETESSELLATION , L"ENABLEADAPTIVETESSELLATION" , STATE_TYPE_BOOL },
    { D3DRS_TWOSIDEDSTENCILMODE , L"TWOSIDEDSTENCILMODE", STATE_TYPE_BOOL },
    { D3DRS_CCW_STENCILFAIL , L"CCW_STENCILFAIL", STATE_TYPE_ENUM, D3DSTENCILOP_StringMap },
    { D3DRS_CCW_STENCILZFAIL , L"CCW_STENCILZFAIL", STATE_TYPE_ENUM, D3DSTENCILOP_StringMap },
    { D3DRS_CCW_STENCILPASS , L"CCW_STENCILPASS", STATE_TYPE_ENUM, D3DSTENCILOP_StringMap },
    { D3DRS_CCW_STENCILFUNC , L"CCW_STENCILFUNC", STATE_TYPE_ENUM, D3DCMPFUNC_StringMap },
    { D3DRS_COLORWRITEENABLE1 , L"COLORWRITEENABLE1", STATE_TYPE_COLOR },
    { D3DRS_COLORWRITEENABLE2 , L"COLORWRITEENABLE2", STATE_TYPE_COLOR },
    { D3DRS_COLORWRITEENABLE3 , L"COLORWRITEENABLE3", STATE_TYPE_COLOR },
    { D3DRS_BLENDFACTOR , L"BLENDFACTOR", STATE_TYPE_COLOR },
//    { D3DRS_SRGBWRITEENABLE , L"SRGBWRITEENABLE", STATE_TYPE_BOOL },
    { D3DRS_DEPTHBIAS , L"DEPTHBIAS", STATE_TYPE_FLOAT },
    { D3DRS_WRAP8 , L"WRAP8", STATE_TYPE_ENUM, D3DWRAP_StringMap },
    { D3DRS_WRAP9 , L"WRAP9", STATE_TYPE_ENUM, D3DWRAP_StringMap },
    { D3DRS_WRAP10 , L"WRAP10", STATE_TYPE_ENUM, D3DWRAP_StringMap },
    { D3DRS_WRAP11 , L"WRAP11", STATE_TYPE_ENUM, D3DWRAP_StringMap },
    { D3DRS_WRAP12 , L"WRAP12", STATE_TYPE_ENUM, D3DWRAP_StringMap },
    { D3DRS_WRAP13 , L"WRAP13", STATE_TYPE_ENUM, D3DWRAP_StringMap },
    { D3DRS_WRAP14 , L"WRAP14", STATE_TYPE_ENUM, D3DWRAP_StringMap },
    { D3DRS_WRAP15 , L"WRAP15", STATE_TYPE_ENUM, D3DWRAP_StringMap },
    { D3DRS_SEPARATEALPHABLENDENABLE , L"SEPARATEALPHABLENDENABLE", STATE_TYPE_BOOL },
    { D3DRS_SRCBLENDALPHA , L"SRCBLENDALPHA", STATE_TYPE_ENUM, D3DBLEND_StringMap },
    { D3DRS_DESTBLENDALPHA , L"DESTBLENDALPHA", STATE_TYPE_ENUM, D3DBLEND_StringMap },
    { D3DRS_BLENDOPALPHA , L"BLENDOPALPHA", STATE_TYPE_ENUM, D3DBLEND_StringMap },
    { 0, NULL },
};


//-----------------------------------------------------------------------------
StateStringMap D3DSAMPLERSTATETYPE_StateStringMap[] = 
{
    { D3DSAMP_ADDRESSU, L"ADDRESSU", STATE_TYPE_ENUM, D3DTEXTUREADDRESS_StringMap },
    { D3DSAMP_ADDRESSV, L"ADDRESSV", STATE_TYPE_ENUM, D3DTEXTUREADDRESS_StringMap },
    { D3DSAMP_ADDRESSW, L"ADDRESSW", STATE_TYPE_ENUM, D3DTEXTUREADDRESS_StringMap },
    { D3DSAMP_BORDERCOLOR, L"BORDERCOLOR", STATE_TYPE_COLOR },
    { D3DSAMP_MAGFILTER, L"MAGFILTER", STATE_TYPE_ENUM, D3DTEXTUREFILTERTYPE_StringMap },
    { D3DSAMP_MINFILTER, L"MINFILTER", STATE_TYPE_ENUM, D3DTEXTUREFILTERTYPE_StringMap },
    { D3DSAMP_MIPFILTER, L"MIPFILTER", STATE_TYPE_ENUM, D3DTEXTUREFILTERTYPE_StringMap },
    { D3DSAMP_MIPMAPLODBIAS, L"MIPMAPLODBIAS", STATE_TYPE_FLOAT },
    { D3DSAMP_MAXMIPLEVEL, L"MAXMIPLEVEL", STATE_TYPE_UINT },
    { D3DSAMP_MAXANISOTROPY, L"MAXANISOTROPY", STATE_TYPE_UINT },
    { D3DSAMP_MAGFILTERZ, L"MAGFILTERZ", STATE_TYPE_ENUM, D3DTEXTUREFILTERTYPE_StringMap },
    { D3DSAMP_MINFILTERZ, L"MINFILTERZ", STATE_TYPE_ENUM, D3DTEXTUREFILTERTYPE_StringMap },
    { D3DSAMP_SEPARATEZFILTERENABLE, L"SEPARATEZFILTERENABLE", STATE_TYPE_BOOL },
    { D3DSAMP_MINMIPLEVEL, L"MINMIPLEVEL", STATE_TYPE_UINT },
    { D3DSAMP_TRILINEARTHRESHOLD, L"TRILINEARTHRESHOLD", STATE_TYPE_ENUM, D3DTRILINEARTHRESHOLD_StringMap },
    { D3DSAMP_ANISOTROPYBIAS, L"D3DSAMP_ANISOTROPYBIAS", STATE_TYPE_FLOAT },
    { D3DSAMP_HGRADIENTEXPBIAS, L"HGRADIENTEXPBIAS", STATE_TYPE_INT },
    { D3DSAMP_VGRADIENTEXPBIAS, L"VGRADIENTEXPBIAS", STATE_TYPE_INT },
    { D3DSAMP_WHITEBORDERCOLORW, L"WHITEBORDERCOLORW", STATE_TYPE_BOOL },
    { D3DSAMP_POINTBORDERENABLE, L"POINTBORDERENABLE", STATE_TYPE_BOOL },
    { 0, NULL },
};

//-----------------------------------------------------------------------------
StateStringMap D3DTEXTURESTAGESTATETYPE_StateStringMap[] = 
{
    { D3DTSS_COLOROP, L"COLOROP", STATE_TYPE_ENUM, D3DTEXTUREOP_StringMap },
    { D3DTSS_COLORARG1, L"COLORARG1", STATE_TYPE_ENUM_WITH_FLAGS, D3DTA_StringMap, D3DTA_FLAGS_StringMap },
    { D3DTSS_COLORARG2, L"COLORARG2", STATE_TYPE_ENUM_WITH_FLAGS, D3DTA_StringMap , D3DTA_FLAGS_StringMap},
    { D3DTSS_ALPHAOP, L"ALPHAOP", STATE_TYPE_ENUM, D3DTEXTUREOP_StringMap },
    { D3DTSS_ALPHAARG1, L"ALPHAARG1", STATE_TYPE_ENUM_WITH_FLAGS, D3DTA_StringMap, D3DTA_FLAGS_StringMap },
    { D3DTSS_ALPHAARG2, L"ALPHAARG2", STATE_TYPE_ENUM_WITH_FLAGS, D3DTA_StringMap, D3DTA_FLAGS_StringMap },
    { D3DTSS_BUMPENVMAT00, L"BUMPENVMAT00", STATE_TYPE_FLOAT },
    { D3DTSS_BUMPENVMAT01, L"BUMPENVMAT01", STATE_TYPE_FLOAT },
    { D3DTSS_BUMPENVMAT10, L"BUMPENVMAT10", STATE_TYPE_FLOAT },
    { D3DTSS_BUMPENVMAT11, L"BUMPENVMAT11", STATE_TYPE_FLOAT },
    { D3DTSS_TEXCOORDINDEX, L"TEXCOORDINDEX", STATE_TYPE_UINT_WITH_FLAGS, NULL, D3DTSS_TCI_FLAGS_StringMap },
    { D3DTSS_BUMPENVLSCALE, L"BUMPENVLSCALE", STATE_TYPE_FLOAT },
    { D3DTSS_BUMPENVLOFFSET, L"BUMPENVLOFFSET", STATE_TYPE_FLOAT },
    { D3DTSS_TEXTURETRANSFORMFLAGS, L"TEXTURETRANSFORMFLAGS", STATE_TYPE_ENUM, D3DTEXTURETRANSFORMFLAGS_StringMap },
    { D3DTSS_COLORARG0, L"COLORARG0", STATE_TYPE_ENUM_WITH_FLAGS, D3DTA_StringMap, D3DTA_FLAGS_StringMap },
    { D3DTSS_ALPHAARG0, L"ALPHAARG0", STATE_TYPE_ENUM_WITH_FLAGS, D3DTA_StringMap, D3DTA_FLAGS_StringMap },
    { D3DTSS_RESULTARG, L"RESULTARG", STATE_TYPE_ENUM_WITH_FLAGS, D3DTA_StringMap, D3DTA_FLAGS_StringMap },
    { D3DTSS_CONSTANT, L"CONSTANT", STATE_TYPE_COLOR },
    { 0, NULL },
};


//-----------------------------------------------------------------------------
BOOL GetValueFromString( CONST WCHAR* szValue,
                         CONST EnumStringMap* pEnumStringMap,
                         DWORD& Value )
{
    while( pEnumStringMap->szName != NULL )
    {
        if( _wcsicmp( pEnumStringMap->szName, szValue ) == 0 )
        {
            Value = pEnumStringMap->Value;
            return TRUE;
        }
        pEnumStringMap++;
    }
    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL GetStringFromValue( CONST DWORD Value,
                         CONST EnumStringMap* pEnumStringMap,
                         CONST WCHAR*& strString )
{
    while( pEnumStringMap->szName != NULL )
    {
        if( pEnumStringMap->Value == Value )
        {
            strString = pEnumStringMap->szName;
            return TRUE;
        }
        pEnumStringMap++;
    }
    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL GetValueFromStringPartial( CONST WCHAR* szValue,
                                CONST EnumStringMap* pEnumStringMap,
                                DWORD& Value )
{
    while( pEnumStringMap->szName != NULL )
    {
        if( wcsstr( szValue, pEnumStringMap->szName ) != NULL )
        {
            Value = pEnumStringMap->Value;
            return TRUE;
        }
        pEnumStringMap++;
    }
    return FALSE;
}

//-----------------------------------------------------------
// Utility function

CONST WCHAR* SkipPast( CONST WCHAR* szString, CONST WCHAR* szSkipChars )
{
    if( szString == NULL )
        return NULL;

    for( ;; )
    {
        if( szString[0] == NULL )
            break;

        CONST WCHAR* ptr;
        for( ptr = szSkipChars; ptr[0] != NULL; ptr++ )
        {
            if( szString[0] == ptr[0] )
            {
                szString++;
                break;
            }
        }
        if( ptr[0] == NULL )
            break;
    }
    return szString;
}

//-----------------------------------------------------------------------------
BOOL GetStateAndValueFromStrings( CONST WCHAR* szState, CONST WCHAR* szValue, 
                                  StateStringMap* pStateStringMap,
                                  DWORD &State, DWORD &Value )
{
    
    while( pStateStringMap->szName != NULL )
    {        
        if( _wcsnicmp( pStateStringMap->szName, szState, wcslen(pStateStringMap->szName) ) == 0 )
        {
            State = pStateStringMap->Value;
            switch( pStateStringMap->Type )
            {
                case STATE_TYPE_ENUM:
                {
                    EnumStringMap* pEnumStringMap = pStateStringMap->EnumValues;
                    while( pEnumStringMap->szName != NULL )
                    {
                        if( _wcsnicmp( pEnumStringMap->szName, szValue, wcslen( pEnumStringMap->szName)  ) == 0 )
                        {
                            Value = pEnumStringMap->Value;
                            return TRUE;
                        }
                        pEnumStringMap++;
                    }
                    return FALSE;
                }

                case STATE_TYPE_ENUM_WITH_FLAGS:
                {
                    assert( pStateStringMap->FlagValues );

                    EnumStringMap* pEnumStringMap = pStateStringMap->EnumValues;
                    Value = 0;
                    while( pEnumStringMap->szName != NULL )
                    {
                        if( _wcsnicmp( pEnumStringMap->szName, szValue, wcslen( pEnumStringMap->szName)  ) == 0 )
                        {
                            Value = pEnumStringMap->Value;
                            break;
                        }
                        pEnumStringMap++;
                    }

                    while( *szValue != NULL )
                    {
                        szValue = SkipPast( szValue, L"| " );

                        if( *szValue != NULL )
                        {
                            EnumStringMap* pStringMap = pStateStringMap->FlagValues;
                            while( pStringMap->szName != NULL )
                            {
                                assert( pEnumStringMap->szName );
                                if( _wcsnicmp( pStringMap->szName, szValue, wcslen( pEnumStringMap->szName ) ) == 0 )
                                {
                                    Value |= pStringMap->Value;
                                    break;
                                }
                                pStringMap++;
                            }

                            // not found
                            if( pStringMap->szName == NULL )
                                return FALSE;
                         }
                    }
                    
                    return TRUE;
                    break;
                    
                }
                case STATE_TYPE_UINT_WITH_FLAGS:
                {
                    assert( !"Tested" ); 

                    assert( pStateStringMap->FlagValues );
                    Value = 0;
                    
                    DWORD NumRead = swscanf_s( szValue, L"%x", &Value );
                    if( NumRead != 1 )
                        return FALSE;

                    while( *szValue != NULL )
                    {
                        szValue = SkipPast( szValue, L"| " );

                        if( *szValue != NULL )
                        {
                            EnumStringMap* pEnumStringMap = pStateStringMap->FlagValues;
                            while( pEnumStringMap->szName != NULL )
                            {
                                if( _wcsnicmp( pEnumStringMap->szName, szValue, wcslen( pEnumStringMap->szName ) ) == 0 )
                                {
                                    Value |= pEnumStringMap->Value;
                                    break;
                                }
                                pEnumStringMap++;
                            }
                            // not found
                            if( pEnumStringMap->szName == NULL )
                                return FALSE;
                         }
                    }

                    return TRUE;
                }
                case STATE_TYPE_FLOAT:
                {
                    DWORD NumRead = swscanf_s( szValue, L"%f", &Value );
                     if( NumRead != 1 )
                        return FALSE;
                     return TRUE;
                }
                case STATE_TYPE_COLOR:
                case STATE_TYPE_MASK:
                {
                    DWORD NumRead = swscanf_s( szValue, L"%x", &Value );
                     if( NumRead != 1 )
                        return FALSE;
                     return TRUE;
                }
                case STATE_TYPE_UINT:
                {
                    DWORD NumRead = swscanf_s( szValue, L"%u", &Value );
                    if( NumRead != 1 )
                        return FALSE;
                    return TRUE;
                }
                case STATE_TYPE_INT:
                {
                    DWORD NumRead = swscanf_s( szValue, L"%d", &Value );
                    if( NumRead != 1 )
                        return FALSE;
                    return TRUE;
                }
                case STATE_TYPE_BOOL:
                {
                    if( _wcsicmp( szValue, L"TRUE" ) )
                        Value = TRUE;
                    else if( _wcsicmp( szValue, L"FALSE" ) )
                        Value = FALSE;
                    else
                        return FALSE;
                    return TRUE;

                }
                default:
                {
                    return FALSE;
                }
                        
            }
        }
        pStateStringMap++;
    }
    
    return FALSE;
}

} // namespace ATG

```

`XenonDumper/libs/Atg/AtgEnumStrings.h`:

```h
//-----------------------------------------------------------------------------
// AtgEnumStrings.h
//
// converts ATG and D3D enums to and frome strings
// 
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef ATG_ENUMSTRINGS_H
#define ATG_ENUMSTRINGS_H

namespace ATG
{

//-----------------------------------------------------------------------------
// holds a single entry in the enum table
//-----------------------------------------------------------------------------
#ifndef ENUMSTRINGMAP_DEFINED
struct EnumStringMap
{
    DWORD Value;
    CONST WCHAR* szName;
};
#define ENUMSTRINGMAP_DEFINED
#endif
//-----------------------------------------------------------------------------
// what kind of d3d state does this value represent
//-----------------------------------------------------------------------------
enum StateType
{
    STATE_TYPE_ENUM,
    STATE_TYPE_ENUM_WITH_FLAGS,
    STATE_TYPE_FLOAT,
    STATE_TYPE_COLOR,
    STATE_TYPE_MASK,
    STATE_TYPE_BOOL,
    STATE_TYPE_UINT,
    STATE_TYPE_INT,
    STATE_TYPE_UINT_WITH_FLAGS,
    STATE_TYPE_DWORD_COMPILE    = 0x7fffffff,
};

//-----------------------------------------------------------------------------
// contains a single entry in the state table
//-----------------------------------------------------------------------------
struct StateStringMap
{
    DWORD                    Value;
    CONST WCHAR*             szName;
    StateType                Type;
    EnumStringMap* EnumValues;
    EnumStringMap* FlagValues;
};

//-----------------------------------------------------------------------------
// gets a DWORD value from a state
//-----------------------------------------------------------------------------
BOOL GetValueFromString( CONST WCHAR* szValue,
                         CONST EnumStringMap* pEnumStringMap,
                         DWORD& Value );

//-----------------------------------------------------------------------------
// gets a string from state
//-----------------------------------------------------------------------------
BOOL GetStringFromValue( CONST DWORD Value,
                         CONST EnumStringMap* pEnumStringMap,
                         CONST WCHAR*& strString );

//-----------------------------------------------------------------------------
// gets a DWORD value from a state
// first partial substring match from the table wins
//-----------------------------------------------------------------------------
BOOL GetValueFromStringPartial( CONST WCHAR* szValue,
                                CONST EnumStringMap* pEnumStringMap,
                                DWORD& Value );

//-----------------------------------------------------------------------------
// given a string representation of the state and its value, returns the 
// DWORD state and value.
// The value string may be bools, floats, color, enum with mask, etc.
//-----------------------------------------------------------------------------
BOOL GetStateAndValueFromStrings( CONST WCHAR* szState, CONST WCHAR* szValue, 
                                  StateStringMap* pStateStringMap,
                                  DWORD &State, DWORD &Value );

//-----------------------------------------------------------------------------
// enum and state tables
//-----------------------------------------------------------------------------
extern EnumStringMap D3DX_FILTER_StringMap[]; 
extern EnumStringMap D3DXREGISTER_SET_StringMap[];
extern EnumStringMap D3DXPARAMETER_CLASS_StringMap[];
extern EnumStringMap D3DXPARAMETER_TYPE_StringMap[];
extern EnumStringMap D3DFORMAT_StringMap[];
extern EnumStringMap D3DDECLTYPE_StringMap[];
extern EnumStringMap D3DDECLMETHOD_StringMap[];
extern EnumStringMap D3DDECLUSAGE_StringMap[];
extern EnumStringMap D3DFILLMODE_StringMap[];
extern EnumStringMap D3DBLEND_StringMap[];
extern EnumStringMap D3DBLENDOP_StringMap[];
extern EnumStringMap D3DTEXTUREADDRESS_StringMap[];
extern EnumStringMap D3DCULL_StringMap[];
extern EnumStringMap D3DCMPFUNC_StringMap[];
extern EnumStringMap D3DSTENCILOP_StringMap[];
extern EnumStringMap D3DFOGMODE_StringMap[];
extern EnumStringMap D3DZBUFFERTYPE_StringMap[];
extern EnumStringMap D3DPRIMITIVETYPE_StringMap[];
extern EnumStringMap D3DTRANSFORMSTATETYPE_StringMap[];
extern EnumStringMap D3DWRAP_StringMap[];
extern EnumStringMap D3DMATERIALCOLORSOURCE_StringMap[];
extern EnumStringMap D3DDEBUGMONITORTOKENS_StringMap[];
extern EnumStringMap D3DVERTEXBLENDFLAGS_StringMap[];
extern EnumStringMap D3DPATCHEDGESTYLE_StringMap[];
extern EnumStringMap D3DDEGREETYPE_StringMap[];
extern EnumStringMap D3DTEXTUREFILTERTYPE_StringMap[];
extern EnumStringMap D3DTEXTUREOP_StringMap[];
extern EnumStringMap D3DTA_StringMap[];
extern EnumStringMap D3DTA_FLAGS_StringMap[];
extern EnumStringMap D3DTEXTURETRANSFORMFLAGS_StringMap[];
extern EnumStringMap D3DTSS_TCI_FLAGS_StringMap[];
extern EnumStringMap D3DCLEAR_StringMap[];
extern StateStringMap D3DRENDERSTATETYPE_StateStringMap[];
extern StateStringMap D3DSAMPLERSTATETYPE_StateStringMap[];
extern StateStringMap D3DTEXTURESTAGESTATETYPE_StateStringMap[];
extern EnumStringMap D3DTRILINEARTHRESHOLD_StringMap[];
extern EnumStringMap D3DMULTISAMPLE_TYPE_StringMap[];

} // namespace ATG

#endif

```

`XenonDumper/libs/Atg/AtgFont.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// AtgFont.cpp
//
// Font class for samples. For details, see header.
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#include "stdafx.h"
#include <xgraphics.h>
#include "AtgDevice.h"
#include "AtgFont.h"
#include "AtgUtil.h"
#include "AtgApp.h"

namespace ATG
{

//
// These two structures are mapped to data loaded from disk.
// DO NOT ALTER ANY ENTRIES OR YOU WILL BREAK 
// COMPATIBILITY WITH THE FONT FILE
//

// Font description

#define ATGCALCFONTFILEHEADERSIZE(x) ( sizeof(DWORD) + (sizeof(FLOAT)*4) + sizeof(WORD) + (sizeof(WCHAR)*(x)) )
#define ATGFONTFILEVERSION 5

typedef struct FontFileHeaderImage_t {
    DWORD m_dwFileVersion;          // Version of the font file (Must match FONTFILEVERSION)
    FLOAT m_fFontHeight;            // Height of the font strike in pixels
    FLOAT m_fFontTopPadding;        // Padding above the strike zone
    FLOAT m_fFontBottomPadding;     // Padding below the strike zone
    FLOAT m_fFontYAdvance;          // Number of pixels to move the cursor for a line feed
    WORD m_cMaxGlyph;               // Number of font characters (Should be an odd number to maintain DWORD Alignment)
    WCHAR m_TranslatorTable[1];     // ASCII to Glyph lookup table, NOTE: It's m_cMaxGlyph+1 in size.
                                    // Entry 0 maps to the "Unknown" glyph.    
} FontFileHeaderImage_t;

// Font strike array. Immediately follows the FontFileHeaderImage_t
// structure image

typedef struct FontFileStrikesImage_t {
    DWORD m_dwNumGlyphs;            // Size of font strike array (First entry is the unknown glyph)
    GLYPH_ATTR m_Glyphs[1];         // Array of font strike uv's etc... NOTE: It's m_dwNumGlyphs in size
} FontFileStrikesImage_t; 

//--------------------------------------------------------------------------------------
// Vertex and pixel shaders for font rendering
// Please note the removal of comment or dead lines...
// They are commented out because the shader compiler has no use for them.
//--------------------------------------------------------------------------------------
static const CHAR g_strFontShader[] =
    "struct VS_IN\n"
    "{\n"
        "float2 Pos : POSITION;\n"
        "float2 Tex : TEXCOORD0;\n"
        "float4 ChannelSelector : TEXCOORD1;\n"
    "};\n"
//  "\n"
    "struct VS_OUT\n"
    "{\n"
        "float4 Position : POSITION;\n"
        "float4 Diffuse : COLOR0_center;\n"
        "float2 TexCoord0 : TEXCOORD0;\n"
        "float4 ChannelSelector : TEXCOORD1;\n"
    "};\n"
//  "\n"
    "uniform float4 Color : register(c1);\n"
    "uniform float2 TexScale : register(c2);\n"
//  "\n"
    "sampler FontTexture : register(s0);\n"
//  "\n"
    "VS_OUT FontVertexShader( VS_IN In )\n"
    "{\n"
        "VS_OUT Out;\n"
        "Out.Position.x  = (In.Pos.x-0.5);\n"
        "Out.Position.y  = (In.Pos.y-0.5);\n"
        "Out.Position.z  = ( 0.0 );\n"
        "Out.Position.w  = ( 1.0 );\n"
        "Out.Diffuse = Color;\n"
        "Out.TexCoord0.x = In.Tex.x * TexScale.x;\n"
        "Out.TexCoord0.y = In.Tex.y * TexScale.y;\n"
        "Out.ChannelSelector = In.ChannelSelector;\n"
        "return Out;\n"
    "}\n"
 // "\n"
    "float4 FontPixelShader( VS_OUT In ) : COLOR0\n"
    "{\n"
//      "// Fetch a texel from the font texture\n"
        "float4 FontTexel = tex2D( FontTexture, In.TexCoord0 );\n"
//      "\n"
        "if( dot( In.ChannelSelector, float4(1,1,1,1) ) )\n"
        "{\n"
//          "// Select the color from the channel\n"
            "float value = dot( FontTexel, In.ChannelSelector );\n"
//          "\n"
//          "// For white pixels, the high bit is 1 and the low\n"
//          "// bits are luminance, so r0.a will be > 0.5. For the\n"
//          "// RGB channel, we want to lop off the msb and shift\n"
//          "// the lower bits up one bit. This is simple to do\n"
//          "// with the _bx2 modifier. Since these pixels are\n"
//          "// opaque, we emit a 1 for the alpha channel (which\n"
//          "// is 0.5 x2 ).\n"
//          "\n"
//          "// For black pixels, the high bit is 0 and the low\n"
//          "// bits are alpha, so r0.a will be < 0.5. For the RGB\n"
//          "// channel, we emit zero. For the alpha channel, we\n"
//          "// just use the x2 modifier to scale up the low bits\n"
//          "// of the alpha.\n"
            "float4 Color;\n"
            "Color.rgb = ( value > 0.5f ? 2*value-1 : 0.0f );\n"
            "Color.a = 2 * ( value > 0.5f ? 1.0f : value );\n"
//          "\n"
//          "// Return the texture color modulated with the vertex\n"
//          "// color\n"
            "return Color * In.Diffuse;\n"
        "}\n"
        "else\n"
        "{\n"
            "return FontTexel * In.Diffuse;\n"
        "}\n"
    "}\n";

//
// These are shared assets common among all instances of AtgFont
//

typedef struct AtgFont_Locals_t {
    D3DVertexDeclaration* m_pFontVertexDecl;    // Shared vertex buffer
    D3DVertexShader* m_pFontVertexShader;       // Created vertex shader
    D3DPixelShader* m_pFontPixelShader;         // Created pixel shader
} AtgFont_Locals_t;

// All elements are defaulted to NULL
static AtgFont_Locals_t s_AtgFontLocals;    // Global static instance

//--------------------------------------------------------------------------------------
// Name: CreateFontShaders()
// Desc: Creates the global font shaders
//--------------------------------------------------------------------------------------

HRESULT Font::CreateFontShaders()
{   
    //
    // There are only two states the globals could be in,
    // Initialized, in which the ref count is increased,
    // Uninialized, in which the vertex/pixel shaders need to be
    // started up and a vertex array created.
    ///
    
    HRESULT Result;         // Returned error code
    if (!s_AtgFontLocals.m_pFontVertexDecl)
    {
        // Use the do {} while(0); trick for a fake goto
        // It simplies tear down on error conditions.

        do {
        
            // Step #1, create my vertex array with 16 bytes per entry
            // Floats for the position,
            // shorts for the uvs
            // 32 bit packed ARGB 8:8:8:8 for color

            static const D3DVERTEXELEMENT9 decl[] =
            {
                { 0,  0, D3DDECLTYPE_FLOAT2,   D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0 },
                { 0,  8, D3DDECLTYPE_USHORT2,  D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, 0 },
                { 0, 12, D3DDECLTYPE_D3DCOLOR, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, 1 },
                D3DDECL_END()
            };
            
            // Cache this global into a register
            D3DDevice *pd3dDevice = g_pd3dDevice;

            Result = pd3dDevice->CreateVertexDeclaration( decl, &s_AtgFontLocals.m_pFontVertexDecl );
            if ( SUCCEEDED( Result ) )
            {

                // Step #2, create my vertex shader
                ID3DXBuffer* pShaderCode;
                Result = D3DXCompileShader( g_strFontShader, sizeof(g_strFontShader)-1 ,
                    NULL, NULL, "FontVertexShader", "vs.2.0", 0,&pShaderCode, NULL, NULL );
                if ( SUCCEEDED( Result ) )
                {
                    Result = pd3dDevice->CreateVertexShader( ( DWORD* )pShaderCode->GetBufferPointer(),
                        &s_AtgFontLocals.m_pFontVertexShader );
                    // Release the compiled shader
                    pShaderCode->Release();
                    
                    if( SUCCEEDED( Result ) )
                    {
                        
                        // Step #3, create my pixel shader

                        Result = D3DXCompileShader( g_strFontShader, sizeof(g_strFontShader)-1 ,
                            NULL, NULL, "FontPixelShader", "ps.2.0", 0,&pShaderCode, NULL, NULL );
                        if ( SUCCEEDED( Result ) )
                        {
                            Result = pd3dDevice->CreatePixelShader( ( DWORD* )pShaderCode->GetBufferPointer(),
                                &s_AtgFontLocals.m_pFontPixelShader );
                            // Release the compiled shader
                            pShaderCode->Release();

                            if ( SUCCEEDED( Result ) ) 
                            {
                                Result = S_OK;      // I'm good. 
                                break;              // Skip the teardown code
                            }
                        }
                        // If the code got to here, a fatal error has occured
                        // and a clean shutdown needs to be performed.

                        s_AtgFontLocals.m_pFontVertexShader->Release();
                    }
                    // Ensure the pointer is NULL
                    s_AtgFontLocals.m_pFontVertexShader = NULL;
                }
                s_AtgFontLocals.m_pFontVertexDecl->Release();
            }
            // Ensure this pointer is NULL    
            s_AtgFontLocals.m_pFontVertexDecl = NULL;
        } while (0);            // Exit point for the break command.
        return Result;
    }
    else
    {
    //
    // Already initialized, so just add to the ref counts
    //

        s_AtgFontLocals.m_pFontVertexDecl->AddRef();
        s_AtgFontLocals.m_pFontVertexShader->AddRef();
        s_AtgFontLocals.m_pFontPixelShader->AddRef();
        Result = S_OK;      // Everything is fine
    }
    return Result;          // Return the error code if any
}

//--------------------------------------------------------------------------------------
// Name: ReleaseFontShaders()
// Desc: Releases the font shaders by reference
//--------------------------------------------------------------------------------------

VOID Font::ReleaseFontShaders()
{
    // Safely release shaders
    // NOTE: They are released in reverse order of creation
    // to make sure any interdependencies are dealt with

    if( ( s_AtgFontLocals.m_pFontPixelShader != NULL ) && ( s_AtgFontLocals.m_pFontPixelShader->Release() == 0 ) )
        s_AtgFontLocals.m_pFontPixelShader = NULL;
    if( ( s_AtgFontLocals.m_pFontVertexShader != NULL ) && ( s_AtgFontLocals.m_pFontVertexShader->Release() == 0 ) )
        s_AtgFontLocals.m_pFontVertexShader = NULL;
    if( ( s_AtgFontLocals.m_pFontVertexDecl != NULL ) && ( s_AtgFontLocals.m_pFontVertexDecl->Release() == 0 ) )
        s_AtgFontLocals.m_pFontVertexDecl = NULL;
}

//--------------------------------------------------------------------------------------
// Name: Font()
// Desc: Constructor
//--------------------------------------------------------------------------------------
Font::Font()
{
    m_pFontTexture = NULL;

    m_dwNumGlyphs = 0L;
    m_Glyphs = NULL;

    m_fCursorX = 0.0f;
    m_fCursorY = 0.0f;

    m_fXScaleFactor = 1.0f;
    m_fYScaleFactor = 1.0f;
    m_fSlantFactor = 0.0f;
    m_bRotate = FALSE;
    m_dRotCos = cos( 0.0 );
    m_dRotSin = sin( 0.0 );

    m_cMaxGlyph = 0;
    m_TranslatorTable = NULL;

    m_dwNestedBeginCount = 0L;
}


//--------------------------------------------------------------------------------------
// Name: ~Font()
// Desc: Destructor
//--------------------------------------------------------------------------------------
Font::~Font()
{
    Destroy();
}


//--------------------------------------------------------------------------------------
// Name: Create()
// Desc: Create the font's internal objects (texture and array of glyph info)
//       using the XPR packed resource file
//--------------------------------------------------------------------------------------
HRESULT Font::Create( const CHAR* strFontFileName )
{
    // Create the font
    if( FAILED( m_xprResource.Create( strFontFileName ) ) )
        return E_FAIL;

    return Create( m_xprResource.GetTexture( "FontTexture" ),
                   m_xprResource.GetData( "FontData" ) );
}


//--------------------------------------------------------------------------------------
// Name: Create()
// Desc: Create the font's internal objects (texture and array of glyph info)
//--------------------------------------------------------------------------------------
HRESULT Font::Create( D3DTexture* pFontTexture, const VOID* pFontData )
{
    // Save a copy of the texture
    m_pFontTexture = pFontTexture;

    // Check version of file (to make sure it matches up with the FontMaker tool)
    const BYTE* pData = static_cast<const BYTE*>(pFontData);
    DWORD dwFileVersion = reinterpret_cast<const FontFileHeaderImage_t *>(pData)->m_dwFileVersion;

    if( dwFileVersion == ATGFONTFILEVERSION )
    {
        m_fFontHeight = reinterpret_cast<const FontFileHeaderImage_t *>(pData)->m_fFontHeight;
        m_fFontTopPadding = reinterpret_cast<const FontFileHeaderImage_t *>(pData)->m_fFontTopPadding;
        m_fFontBottomPadding = reinterpret_cast<const FontFileHeaderImage_t *>(pData)->m_fFontBottomPadding;
        m_fFontYAdvance = reinterpret_cast<const FontFileHeaderImage_t *>(pData)->m_fFontYAdvance;

        // Point to the translator string which immediately follows the 4 floats
        m_cMaxGlyph = reinterpret_cast<const FontFileHeaderImage_t *>(pData)->m_cMaxGlyph;
  
        m_TranslatorTable = const_cast<FontFileHeaderImage_t*>(reinterpret_cast<const FontFileHeaderImage_t *>(pData))->m_TranslatorTable;

        pData += ATGCALCFONTFILEHEADERSIZE( m_cMaxGlyph + 1 );

        // Read the glyph attributes from the file
        m_dwNumGlyphs = reinterpret_cast<const FontFileStrikesImage_t *>(pData)->m_dwNumGlyphs;
        m_Glyphs = reinterpret_cast<const FontFileStrikesImage_t *>(pData)->m_Glyphs;        // Pointer
    }
    else
    {
        ATG_PrintError( "Incorrect version number on font file!\n" );
        return E_FAIL;
    }

    // Create the vertex and pixel shaders for rendering the font
    if( FAILED( CreateFontShaders() ) )
    {
        ATG_PrintError( "Could not create font shaders!\n" );
        return E_FAIL;
    }

    // Initialize the window
    D3DDISPLAYMODE DisplayMode;
    g_pd3dDevice->GetDisplayMode( 0, &DisplayMode );
    m_rcWindow.x1 = 0;
    m_rcWindow.y1 = 0;
    m_rcWindow.x2 = DisplayMode.Width;
    m_rcWindow.y2 = DisplayMode.Height;

    // Determine whether we should save/restore state
    m_bSaveState = TRUE;

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroy the font object
//--------------------------------------------------------------------------------------
VOID Font::Destroy()
{
    m_pFontTexture = NULL;
    m_dwNumGlyphs = 0L;
    m_Glyphs = NULL;
    m_cMaxGlyph = 0;
    m_TranslatorTable = NULL;
    m_dwNestedBeginCount = 0L;

    // Safely release shaders
    ReleaseFontShaders();

    if( m_xprResource.Initialized() )
    {
        m_xprResource.Destroy();
    }
}


//--------------------------------------------------------------------------------------
// Name: SetWindow()
// Desc: Sets the  and the bounds rect for drawing text and resets the cursor position
//--------------------------------------------------------------------------------------
VOID Font::SetWindow(const D3DRECT &rcWindow )
{
    m_rcWindow.x1 = rcWindow.x1;
    m_rcWindow.y1 = rcWindow.y1;
    m_rcWindow.x2 = rcWindow.x2;
    m_rcWindow.y2 = rcWindow.y2;

    m_fCursorX = 0.0f;
    m_fCursorY = 0.0f;
}


//--------------------------------------------------------------------------------------
// Name: SetWindow()
// Desc: Sets the  and the bounds rect for drawing text and resets the cursor position
//--------------------------------------------------------------------------------------
VOID Font::SetWindow( LONG x1, LONG y1, LONG x2, LONG y2 )
{
    m_rcWindow.x1 = x1;
    m_rcWindow.y1 = y1;
    m_rcWindow.x2 = x2;
    m_rcWindow.y2 = y2;

    m_fCursorX = 0.0f;
    m_fCursorY = 0.0f;
}

//--------------------------------------------------------------------------------------
// Name: GetWindow()
// Desc: Gets the current bounds rect for drawing
//--------------------------------------------------------------------------------------
VOID Font::GetWindow( D3DRECT &rcWindow ) const
{
    rcWindow = m_rcWindow;      // NOTE: This is a structure copy
}

//--------------------------------------------------------------------------------------
// Name: SetCursorPosition()
// Desc: Sets the cursor position for drawing text
//--------------------------------------------------------------------------------------
VOID Font::SetCursorPosition( FLOAT fCursorX, FLOAT fCursorY )
{
    m_fCursorX = floorf( fCursorX );
    m_fCursorY = floorf( fCursorY );
}


//--------------------------------------------------------------------------------------
// Name: SetScaleFactors()
// Desc: Sets X and Y scale factor to make rendered text bigger or smaller.
//       Note that since text is pre-anti-aliased and therefore point-filtered,
//       any scale factors besides 1.0f will degrade the quality.
//--------------------------------------------------------------------------------------

// inlined in atgfont.h

//--------------------------------------------------------------------------------------
// Name: SetSlantFactor()
// Desc: Sets the slant factor for rendering slanted text.
//--------------------------------------------------------------------------------------

// inlined in atgfont.h

//--------------------------------------------------------------------------------------
// Name: SetRotation()
// Desc: Sets the rotation factor in radians for rendering tilted text.
//--------------------------------------------------------------------------------------
VOID Font::SetRotationFactor( FLOAT fRotationFactor )
{
    m_bRotate = fRotationFactor != 0;

    m_dRotCos = cos( fRotationFactor );     // NOTE: Using double precision
    m_dRotSin = sin( fRotationFactor );
}


//--------------------------------------------------------------------------------------
// Name: GetTextExtent()
// Desc: Get the dimensions of a text string
//--------------------------------------------------------------------------------------

VOID Font::GetTextExtent( const WCHAR* strText, FLOAT* pWidth,
                          FLOAT* pHeight, BOOL bFirstLineOnly ) const
{
    assert( pWidth != NULL );
    assert( pHeight != NULL );

    // Set default text extent in output parameters
    int iWidth = 0;
    FLOAT fHeight = 0.0f;

    if( strText )
    {
        // Initialize counters that keep track of text extent
        int ix = 0;
        FLOAT fy = m_fFontHeight;       // One character high to start
        if( fy > fHeight )
            fHeight = fy;

        // Loop through each character and update text extent
        DWORD letter;
        while( (letter = *strText) != 0 )
        {
            ++strText;

            // Handle newline character
            if( letter == L'\n' )
            {
                if( bFirstLineOnly )
                    break;
                ix = 0;
                fy += m_fFontYAdvance;
                // since the height has changed, test against the height extent
                if( fy > fHeight )
                    fHeight = fy;
           }

            // Handle carriage return characters by ignoring them. This helps when
            // displaying text from a file.
            if( letter == L'\r' )
                continue;

            // Translate unprintable characters
            const GLYPH_ATTR* pGlyph;
            
            if( letter > m_cMaxGlyph )
                letter = 0;     // Out of bounds?
            else
                letter = m_TranslatorTable[letter];     // Remap ASCII to glyph

            pGlyph = &m_Glyphs[letter];                 // Get the requested glyph

            // Get text extent for this character's glyph
            ix += pGlyph->wOffset;
            ix += pGlyph->wAdvance;

            // Since the x widened, test against the x extent

            if( ix > iWidth )
                iWidth = ix;
        }
    }

    // Convert the width to a float here, load/hit/store. :(
    FLOAT fWidth = static_cast<FLOAT>(iWidth);          // Delay the use if fWidth to reduce LHS pain
    // Apply the scale factor to the result
    fHeight *= m_fYScaleFactor;
     // Store the final results
    *pHeight = fHeight;

    fWidth *= m_fXScaleFactor;
    *pWidth = fWidth;
}

//--------------------------------------------------------------------------------------
// Name: GetTextWidth()
// Desc: Returns the width in pixels of a text string
//--------------------------------------------------------------------------------------
FLOAT Font::GetTextWidth( const WCHAR* strText ) const
{
    FLOAT fTextWidth;
    FLOAT fTextHeight;
    GetTextExtent( strText, &fTextWidth, &fTextHeight );
    return fTextWidth;
}


//--------------------------------------------------------------------------------------
// Name: Begin()
// Desc: Prepares the font vertex buffers for rendering.
//--------------------------------------------------------------------------------------
VOID Font::Begin()
{
    PIXBeginNamedEvent( 0, "Text Rendering" );

    // Set state on the first call
    if( 0 == m_dwNestedBeginCount )
    {
        // Cache the global pointer into a register
        ATG::D3DDevice *pD3dDevice = g_pd3dDevice;
        assert( pD3dDevice );
        // Save state
        if( m_bSaveState )
        {
            // Note, we are not saving the texture, vertex, or pixel shader,
            //       since it's not worth the performance. We're more interested
            //       in saving state that would cause hard to find problems.
            pD3dDevice->GetRenderState( D3DRS_ALPHABLENDENABLE,
                                          &m_dwSavedState[ SAVEDSTATE_D3DRS_ALPHABLENDENABLE ] );
            pD3dDevice->GetRenderState( D3DRS_SRCBLEND, &m_dwSavedState[ SAVEDSTATE_D3DRS_SRCBLEND ] );
            pD3dDevice->GetRenderState( D3DRS_DESTBLEND, &m_dwSavedState[ SAVEDSTATE_D3DRS_DESTBLEND ] );
            pD3dDevice->GetRenderState( D3DRS_BLENDOP, &m_dwSavedState[ SAVEDSTATE_D3DRS_BLENDOP ] );
            pD3dDevice->GetRenderState( D3DRS_ALPHATESTENABLE, &m_dwSavedState[ SAVEDSTATE_D3DRS_ALPHATESTENABLE ] );
            pD3dDevice->GetRenderState( D3DRS_ALPHAREF, &m_dwSavedState[ SAVEDSTATE_D3DRS_ALPHAREF ] );
            pD3dDevice->GetRenderState( D3DRS_ALPHAFUNC, &m_dwSavedState[ SAVEDSTATE_D3DRS_ALPHAFUNC ] );
            pD3dDevice->GetRenderState( D3DRS_FILLMODE, &m_dwSavedState[ SAVEDSTATE_D3DRS_FILLMODE ] );
            pD3dDevice->GetRenderState( D3DRS_CULLMODE, &m_dwSavedState[ SAVEDSTATE_D3DRS_CULLMODE ] );
            pD3dDevice->GetRenderState( D3DRS_ZENABLE, &m_dwSavedState[ SAVEDSTATE_D3DRS_ZENABLE ] );
            pD3dDevice->GetRenderState( D3DRS_STENCILENABLE, &m_dwSavedState[ SAVEDSTATE_D3DRS_STENCILENABLE ] );
            pD3dDevice->GetRenderState( D3DRS_VIEWPORTENABLE, &m_dwSavedState[ SAVEDSTATE_D3DRS_VIEWPORTENABLE ] );
            pD3dDevice->GetSamplerState( 0, D3DSAMP_MINFILTER, &m_dwSavedState[ SAVEDSTATE_D3DSAMP_MINFILTER ] );
            pD3dDevice->GetSamplerState( 0, D3DSAMP_MAGFILTER, &m_dwSavedState[ SAVEDSTATE_D3DSAMP_MAGFILTER ] );
            pD3dDevice->GetSamplerState( 0, D3DSAMP_ADDRESSU, &m_dwSavedState[ SAVEDSTATE_D3DSAMP_ADDRESSU ] );
            pD3dDevice->GetSamplerState( 0, D3DSAMP_ADDRESSV, &m_dwSavedState[ SAVEDSTATE_D3DSAMP_ADDRESSV ] );
        }

        // Set the texture scaling factor as a vertex shader constant
        D3DSURFACE_DESC TextureDesc;
        m_pFontTexture->GetLevelDesc( 0, &TextureDesc );		// Get the description
 
        // Set render state
        pD3dDevice->SetTexture( 0, m_pFontTexture );
 
        // Read the TextureDesc here to ensure no load/hit/store from GetLevelDesc()
        FLOAT vTexScale[4];
        vTexScale[0] = 1.0f / TextureDesc.Width;		// LHS due to int->float conversion
        vTexScale[1] = 1.0f / TextureDesc.Height;
        vTexScale[2] = 0.0f;
        vTexScale[3] = 0.0f;
        
        pD3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
        pD3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
        pD3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
        pD3dDevice->SetRenderState( D3DRS_BLENDOP, D3DBLENDOP_ADD );
        pD3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, TRUE );
        pD3dDevice->SetRenderState( D3DRS_ALPHAREF, 0x08 );
        pD3dDevice->SetRenderState( D3DRS_ALPHAFUNC, D3DCMP_GREATEREQUAL );
        pD3dDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID );
        pD3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
        pD3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
        pD3dDevice->SetRenderState( D3DRS_STENCILENABLE, FALSE );
        pD3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, FALSE );
        pD3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
        pD3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
        pD3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
        pD3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP );
        
        pD3dDevice->SetVertexDeclaration( s_AtgFontLocals.m_pFontVertexDecl );
        pD3dDevice->SetVertexShader( s_AtgFontLocals.m_pFontVertexShader );
        pD3dDevice->SetPixelShader( s_AtgFontLocals.m_pFontPixelShader );

        // Set the texture scaling factor as a vertex shader constant
        // Call here to avoid load hit store from writing to vTexScale above
        pD3dDevice->SetVertexShaderConstantF( 2, vTexScale, 1 );
    }

    // Keep track of the nested begin/end calls.
    m_dwNestedBeginCount++;
}


//--------------------------------------------------------------------------------------
// Name: DrawText()
// Desc: Draws text as textured polygons
//--------------------------------------------------------------------------------------
VOID Font::DrawText( DWORD dwColor, const WCHAR* strText, DWORD dwFlags,
                     FLOAT fMaxPixelWidth )
{
    DrawText( m_fCursorX, m_fCursorY, dwColor, strText, dwFlags, fMaxPixelWidth );
}


//--------------------------------------------------------------------------------------
// Name: DrawText()
// Desc: Draws text as textured polygons
//       TODO: This function should use the Begin/SetVertexData/End() API when it
//       becomes available.
//--------------------------------------------------------------------------------------
VOID Font::DrawText( FLOAT fOriginX, FLOAT fOriginY, DWORD dwColor,
                     const WCHAR* strText, DWORD dwFlags, FLOAT fMaxPixelWidth )
{
    if( NULL == strText )    return;
    if( L'\0' == strText[0] ) return;
 
    // Create a PIX user-defined event that encapsulates all of the text draw calls.
    // This makes DrawText calls easier to recognize in PIX captures, and it makes
    // them take up fewer entries in the event list.
    PIXBeginNamedEvent( dwColor, "DrawText: %S", strText );

    // Set the color as a vertex shader constant
    FLOAT vColor[4];
    vColor[0] = ( ( dwColor & 0x00ff0000 ) >> 16L ) / 255.0F;
    vColor[1] = ( ( dwColor & 0x0000ff00 ) >> 8L ) / 255.0F;
    vColor[2] = ( ( dwColor & 0x000000ff ) >> 0L ) / 255.0F;
    vColor[3] = ( ( dwColor & 0xff000000 ) >> 24L ) / 255.0F;

    // Set up stuff to prepare for drawing text
    Begin();

    // Perform the actual storing of the color constant here to prevent
    // a load-hit-store by inserting work between the store and the use of
    // the vColor array.
    g_pd3dDevice->SetVertexShaderConstantF( 1, vColor, 1 );

    // Set the starting screen position
    if( ( fOriginX < 0.0f ) || ( ( dwFlags & ATGFONT_RIGHT ) && ( fOriginX <= 0.0f ) ) )
    {
        fOriginX += ( m_rcWindow.x2 - m_rcWindow.x1 );
    }
    if( fOriginY < 0.0f )
    {
        fOriginY += ( m_rcWindow.y2 - m_rcWindow.y1 );
    }

    m_fCursorX = floorf( fOriginX );
    m_fCursorY = floorf( fOriginY );

    // Adjust for padding
    fOriginY -= m_fFontTopPadding;

    FLOAT fEllipsesPixelWidth = m_fXScaleFactor * 3.0f * ( m_Glyphs[m_TranslatorTable[L'.']].wOffset +
                                                           m_Glyphs[m_TranslatorTable[L'.']].wAdvance );

    if( dwFlags & ATGFONT_TRUNCATED )
    {
        // Check if we will really need to truncate the string
        if( fMaxPixelWidth <= 0.0f )
        {
            dwFlags &= ( ~ATGFONT_TRUNCATED );
        }
        else
        {
            FLOAT w, h;
            GetTextExtent( strText, &w, &h, TRUE );

            // If not, then clear the flag
            if( w <= fMaxPixelWidth )
                dwFlags &= ( ~ATGFONT_TRUNCATED );
        }
    }

    // If vertically centered, offset the starting m_fCursorY value
    if( dwFlags & ATGFONT_CENTER_Y )
    {
        FLOAT w, h;
        GetTextExtent( strText, &w, &h );
        m_fCursorY = floorf( m_fCursorY - (h * 0.5f) );
    }

    // Add window offsets
    FLOAT Winx = static_cast<FLOAT>(m_rcWindow.x1);
    FLOAT Winy = static_cast<FLOAT>(m_rcWindow.y1);
    fOriginX += Winx;
    fOriginY += Winy;
    m_fCursorX += Winx;
    m_fCursorY += Winy;

    // Set a flag so we can determine initial justification effects
    BOOL bStartingNewLine = TRUE;

    DWORD dwNumEllipsesToDraw = 0;

    // Begin drawing the vertices

    // Declared as volatile to force writing in ascending
    // address order. It prevents out of sequence writing in write combined
    // memory.

    volatile FLOAT* pVertex;

    DWORD dwNumChars = wcslen( strText ) + ( dwFlags & ATGFONT_TRUNCATED ? 3 : 0 );
    HRESULT hr = g_pd3dDevice->BeginVertices( D3DPT_QUADLIST, 4 * dwNumChars, sizeof( XMFLOAT4 ) ,
                                              ( VOID** )&pVertex );
    // The ring buffer may run out of space when tiling, doing z-prepasses,
    // or using BeginCommandBuffer. If so, make the buffer larger.
    if( FAILED( hr ) )
        FatalError( "Ring buffer out of memory.\n" );

    bStartingNewLine = TRUE;

    // Draw four vertices for each glyph
    while( *strText )
    {
        WCHAR letter;

        if( dwNumEllipsesToDraw )
        {
            letter = L'.';
        }
        else
        {
            // If starting text on a new line, determine justification effects
            if( bStartingNewLine )
            {
                if( dwFlags & ( ATGFONT_RIGHT | ATGFONT_CENTER_X ) )
                {
                    // Get the extent of this line
                    FLOAT w, h;
                    GetTextExtent( strText, &w, &h, TRUE );

                    // Offset this line's starting m_fCursorX value
                    if( dwFlags & ATGFONT_RIGHT )
                        m_fCursorX = floorf( fOriginX - w );
                    if( dwFlags & ATGFONT_CENTER_X )
                        m_fCursorX = floorf( fOriginX - w * 0.5f );
                }
                bStartingNewLine = FALSE;
            }

            // Get the current letter in the string
            letter = *strText++;

            // Handle the newline character
            if( letter == L'\n' )
            {
                m_fCursorX = fOriginX;
                m_fCursorY += m_fFontYAdvance * m_fYScaleFactor;
                bStartingNewLine = TRUE;
                continue;
            }

            // Handle carriage return characters by ignoring them. This helps when
            // displaying text from a file.
            if( letter == L'\r' )
                continue;
        }

        // Translate unprintable characters
        const GLYPH_ATTR* pGlyph = &m_Glyphs[ ( letter <= m_cMaxGlyph ) ? m_TranslatorTable[letter] : 0 ];

        FLOAT fOffset = m_fXScaleFactor * ( FLOAT )pGlyph->wOffset;
        FLOAT fAdvance = m_fXScaleFactor * ( FLOAT )pGlyph->wAdvance;
        FLOAT fWidth = m_fXScaleFactor * ( FLOAT )pGlyph->wWidth;
        FLOAT fHeight = m_fYScaleFactor * m_fFontHeight;

        if( 0 == dwNumEllipsesToDraw )
        {
            if( dwFlags & ATGFONT_TRUNCATED )
            {
                // Check if we will be exceeded the max allowed width
                if( m_fCursorX + fOffset + fWidth + fEllipsesPixelWidth + m_fSlantFactor > fOriginX + fMaxPixelWidth )
                {
                    // Yup, draw the three ellipses dots instead
                    dwNumEllipsesToDraw = 3;
                    continue;
                }
            }
        }

        // Setup the screen coordinates
        m_fCursorX += fOffset;
        FLOAT X4 = m_fCursorX;
        FLOAT X1 = X4 + m_fSlantFactor;
        FLOAT X3 = X4 + fWidth;
        FLOAT X2 = X1 + fWidth;
        FLOAT Y1 = m_fCursorY;
        FLOAT Y3 = Y1 + fHeight;
        FLOAT Y2 = Y1;
        FLOAT Y4 = Y3;

        // Rotate the points by the rotation factor
        if( m_bRotate )
        {
            RotatePoint( &X1, &Y1, fOriginX, fOriginY );
            RotatePoint( &X2, &Y2, fOriginX, fOriginY );
            RotatePoint( &X3, &Y3, fOriginX, fOriginY );
            RotatePoint( &X4, &Y4, fOriginX, fOriginY );
        }

        m_fCursorX += fAdvance;

        // Select the RGBA channel that the compressed glyph is stored in
        // Takes a 4 bit per pixel ARGB value and expand it to an 8 bit per pixel ARGB value

        DWORD dwChannelSelector = pGlyph->wMask;        // Convert to 32 bit
        // Perform the conversion without branching

        // Splat the 4 bit per pixels from 0x1234 to 0x01020304
        dwChannelSelector = ((dwChannelSelector&0xF000)<<(24-12))|((dwChannelSelector&0xF00)<<(16-8))|
            ((dwChannelSelector&0xF0)<<(8-4))|(dwChannelSelector&0xF);

        // Perform a vectorized multiply to make 0x01020304 into 0x11223344
        dwChannelSelector *= 0x11;

        // Add the vertices to draw this glyph

        DWORD tu1 = pGlyph->tu1;        // Convert shorts to 32 bit longs for in register merging
        DWORD tv1 = pGlyph->tv1;
        DWORD tu2 = pGlyph->tu2;
        DWORD tv2 = pGlyph->tv2;

        // NOTE: The vertexs are 2 floats for the screen coordinates,
        // followed by two USHORTS for the u/vs of the character,
        // terminated with the ARGB 32 bit color.
        // This makes for 16 bytes per vertex data (Easier to read)
        // Second NOTE: The uvs are merged and written using a DWORD due
        // to the write combining hardware being only able to handle 32,
        // 64 and 128 writes. Never store to write combined memory with
        // 8 or 16 bit instructions. You've been warned.

        pVertex[0] = X1;
        pVertex[1] = Y1;
        reinterpret_cast<volatile DWORD *>(pVertex)[2] = (tu1<<16)|tv1;         // Merged using big endian rules
        reinterpret_cast<volatile DWORD *>(pVertex)[3] = dwChannelSelector;
        pVertex[4] = X2;
        pVertex[5] = Y2;
        reinterpret_cast<volatile DWORD *>(pVertex)[6] = (tu2<<16)|tv1;         // Merged using big endian rules
        reinterpret_cast<volatile DWORD *>(pVertex)[7] = dwChannelSelector;
        pVertex[8] = X3;
        pVertex[9] = Y3;
        reinterpret_cast<volatile DWORD *>(pVertex)[10] = (tu2<<16)|tv2;        // Merged using big endian rules
        reinterpret_cast<volatile DWORD *>(pVertex)[11] = dwChannelSelector;
        pVertex[12] = X4;
        pVertex[13] = Y4;
        reinterpret_cast<volatile DWORD *>(pVertex)[14] = (tu1<<16)|tv2;        // Merged using big endian rules
        reinterpret_cast<volatile DWORD *>(pVertex)[15] = dwChannelSelector;
        pVertex+=16;

        // If drawing ellipses, exit when they're all drawn
        if( dwNumEllipsesToDraw )
        {
            if( --dwNumEllipsesToDraw == 0 )
                break;
        }

        dwNumChars--;
    }

    // Since we allocated vertex data space based on the string length, we now need to
    // add some dummy verts for any skipped characters (like newlines, etc.)
    while( dwNumChars )
    {
        pVertex[0] = 0;
        pVertex[1] = 0;
        pVertex[2] = 0;
        pVertex[3] = 0;
        pVertex[4] = 0;
        pVertex[5] = 0;
        pVertex[6] = 0;
        pVertex[7] = 0;
        pVertex[8] = 0;
        pVertex[9] = 0;
        pVertex[10] = 0;
        pVertex[11] = 0;
        pVertex[12] = 0;
        pVertex[13] = 0;
        pVertex[14] = 0;
        pVertex[15] = 0;
        pVertex+=16;
        dwNumChars--;
    }

    // Stop drawing vertices
    g_pd3dDevice->EndVertices();

    // Undo window offsets
    m_fCursorX -= Winx;
    m_fCursorY -= Winy;

    // Call End() to complete the begin/end pair for drawing text
    End();

    // Close off the user-defined event opened with PIXBeginNamedEvent.
    PIXEndNamedEvent();
}


//--------------------------------------------------------------------------------------
// Name: End()
// Desc: Paired call that restores state set in the Begin() call.
//--------------------------------------------------------------------------------------
VOID Font::End()
{
    assert( m_dwNestedBeginCount > 0 );
    if( --m_dwNestedBeginCount > 0 )
    {
        PIXEndNamedEvent();
        return;
    }

    // Restore state
    if( m_bSaveState )
    {
        // Cache the global pointer into a register
        ATG::D3DDevice *pD3dDevice = g_pd3dDevice;
        pD3dDevice->SetTexture( 0, NULL );
        pD3dDevice->SetVertexDeclaration( NULL );
        pD3dDevice->SetVertexShader( NULL );
        pD3dDevice->SetPixelShader( NULL );
        pD3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, m_dwSavedState[ SAVEDSTATE_D3DRS_ALPHABLENDENABLE ] );
        pD3dDevice->SetRenderState( D3DRS_SRCBLEND, m_dwSavedState[ SAVEDSTATE_D3DRS_SRCBLEND ] );
        pD3dDevice->SetRenderState( D3DRS_DESTBLEND, m_dwSavedState[ SAVEDSTATE_D3DRS_DESTBLEND ] );
        pD3dDevice->SetRenderState( D3DRS_BLENDOP, m_dwSavedState[ SAVEDSTATE_D3DRS_BLENDOP ] );
        pD3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, m_dwSavedState[ SAVEDSTATE_D3DRS_ALPHATESTENABLE ] );
        pD3dDevice->SetRenderState( D3DRS_ALPHAREF, m_dwSavedState[ SAVEDSTATE_D3DRS_ALPHAREF ] );
        pD3dDevice->SetRenderState( D3DRS_ALPHAFUNC, m_dwSavedState[ SAVEDSTATE_D3DRS_ALPHAFUNC ] );
        pD3dDevice->SetRenderState( D3DRS_FILLMODE, m_dwSavedState[ SAVEDSTATE_D3DRS_FILLMODE ] );
        pD3dDevice->SetRenderState( D3DRS_CULLMODE, m_dwSavedState[ SAVEDSTATE_D3DRS_CULLMODE ] );
        pD3dDevice->SetRenderState( D3DRS_ZENABLE, m_dwSavedState[ SAVEDSTATE_D3DRS_ZENABLE ] );
        pD3dDevice->SetRenderState( D3DRS_STENCILENABLE, m_dwSavedState[ SAVEDSTATE_D3DRS_STENCILENABLE ] );
        pD3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, m_dwSavedState[ SAVEDSTATE_D3DRS_VIEWPORTENABLE ] );
        pD3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, m_dwSavedState[ SAVEDSTATE_D3DSAMP_MINFILTER ] );
        pD3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, m_dwSavedState[ SAVEDSTATE_D3DSAMP_MAGFILTER ] );
        pD3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSU, m_dwSavedState[ SAVEDSTATE_D3DSAMP_ADDRESSU ] );
        pD3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSV, m_dwSavedState[ SAVEDSTATE_D3DSAMP_ADDRESSV ] );
    }

    PIXEndNamedEvent();
}


//--------------------------------------------------------------------------------------
// Name: CreateTexture()
// Desc: Creates a texture and renders a text string into it.
//--------------------------------------------------------------------------------------
LPDIRECT3DTEXTURE9 Font::CreateTexture( const WCHAR* strText, D3DCOLOR dwBackgroundColor,
                                        D3DCOLOR dwTextColor, D3DFORMAT d3dFormat )
{
    // Make sure the format is tiled (otherwise the Resolve will fail)
    if( FALSE == XGIsTiledFormat( d3dFormat ) )
    {
        ATG_PrintError( "Format must be tiled!\n" );
        return NULL;
    }

    // Calculate texture dimensions
    FLOAT fTexWidth, fTexHeight;
    GetTextExtent( strText, &fTexWidth, &fTexHeight );
    DWORD dwWidth = XGNextMultiple( ( DWORD )fTexWidth, 32 );
    DWORD dwHeight = XGNextMultiple( ( DWORD )fTexHeight, 32 );

    // Create a render target
    LPDIRECT3DSURFACE9 pNewRenderTarget;
    ATG::D3DDevice *pD3dDevice = g_pd3dDevice;
    if( FAILED( pD3dDevice->CreateRenderTarget( dwWidth, dwHeight, d3dFormat, D3DMULTISAMPLE_NONE,
                                                  0L, FALSE, &pNewRenderTarget, NULL ) ) )
    {
        ATG_PrintError( "Could not create a render target for the font texture!\n" );
        return NULL;
    }

    // Create the texture
    LPDIRECT3DTEXTURE9 pNewTexture;
    if( FAILED( pD3dDevice->CreateTexture( dwWidth, dwHeight, 1, 0L, d3dFormat,
                                             D3DPOOL_DEFAULT, &pNewTexture, NULL ) ) )
    {
        ATG_PrintError( "Could not create a font texture!\n" );
        pNewRenderTarget->Release();
        return NULL;
    }

    // Get the current backbuffer and zbuffer
    LPDIRECT3DSURFACE9 pOldRenderTarget;
    pD3dDevice->GetRenderTarget( 0, &pOldRenderTarget );

    // Set the new texture as the render target
    pD3dDevice->SetRenderTarget( 0, pNewRenderTarget );
    pD3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, dwBackgroundColor, 1.0f, 0L );

    // Render the text
    D3DRECT rcSaved;
    GetWindow(rcSaved);
    SetWindow( 0, 0, dwWidth, dwHeight );
    DrawText( dwWidth * 0.5f, dwHeight * 0.5f, dwTextColor, strText, ATGFONT_CENTER_X | ATGFONT_CENTER_Y );

    // Resolve to the texture
    pD3dDevice->Resolve( 0L, NULL, pNewTexture, NULL, 0, 0, NULL, 0, 0, NULL );

    // Restore the render target
    pD3dDevice->SetRenderTarget( 0, pOldRenderTarget );
    if( pOldRenderTarget != NULL)
        pOldRenderTarget->Release();
    pNewRenderTarget->Release();
    SetWindow(rcSaved);

    // Return the new texture
    return pNewTexture;
}


//--------------------------------------------------------------------------------------
// Name: RotatePoint()
// Desc: Rotate a 2D point around the origin
//-------------------------------------------------------------------------------------
VOID Font::RotatePoint( FLOAT* X, FLOAT* Y, DOUBLE OriginX, DOUBLE OriginY ) const
{
    DOUBLE dTempX = *X - OriginX;
    DOUBLE dTempY = *Y - OriginY;
    DOUBLE dXprime = OriginX + ( m_dRotCos * dTempX - m_dRotSin * dTempY );
    DOUBLE dYprime = OriginY + ( m_dRotSin * dTempX + m_dRotCos * dTempY );

    *X = static_cast<FLOAT>( dXprime );
    *Y = static_cast<FLOAT>( dYprime );
}

} // namespace ATG



```

`XenonDumper/libs/Atg/AtgFont.h`:

```h
//--------------------------------------------------------------------------------------
// AtgFont.h
//
// Texture-based font class. This class reads .abc font files that are generated by the
// FontMaker tool (and optionally compressed, or "packed", with the FontPacker tool).
// These .abc files are used to create a texture with all the font's glyphs, and also
// extract information on the dimensions of each glyph.
//
// Once created, this class is used to render text in screenspace with the following
// function:
//    DrawText( fScreenSpaceX, fScreenSpaceY, dwTextColor, strText, dwFlags );
//
// For performance, you should batch multiple DrawText calls together between Begin()
// and End() calls, as in the following example:
//    pFont->Begin();
//    pFont->DrawText( ... );
//    pFont->DrawText( ... );
//    pFont->DrawText( ... );
//    pFont->End();
//
// Font files may have embedded, artistically-colored custom glyphs, such as wingdings
// and gamepad buttons. The default font(s) used by the samples use many such custom
// glyphs. For convenience, constants have been defined to reference these glyphs in a
// string, such as:
//    pFont->DrawText( L"Press " GLYPH_A_BUTTON " to continue." );
//
// The size (extent) of the text can be computed with the following function:
//    GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight, bUseFirstLineOnly );
//
// Finally, the font class can create a texture to hold rendered text, which is useful
// for static text that must be rendered for many frames, or can even be used within a
// 3D scene. (For instance, for a player's name on a jersey.) Use the following function
// for this:
//    CreateTexture( strText, dwBackColor, dwTextColor, d3dTextureFormat );
//
// See the XDK docs for more information.
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#pragma once
#ifndef ATGFONT_H
#define ATGFONT_H

#ifndef ATGRESOURCE_H
#include "AtgResource.h"
#endif

namespace ATG
{

//--------------------------------------------------------------------------------------
// Flags for the Font::DrawText() function (Or them together to combine features)
//--------------------------------------------------------------------------------------
#define ATGFONT_LEFT       0x00000000
#define ATGFONT_RIGHT      0x00000001
#define ATGFONT_CENTER_X   0x00000002
#define ATGFONT_CENTER_Y   0x00000004
#define ATGFONT_TRUNCATED  0x00000008


//--------------------------------------------------------------------------------------
// Name: GLYPH_ATTR
// Desc: Structure to hold information about one glyph (font character image)
//--------------------------------------------------------------------------------------
typedef struct GLYPH_ATTR
{
    WORD tu1, tv1, tu2, tv2;    // Texture coordinates for the image
    SHORT wOffset;              // Pixel offset for glyph start
    SHORT wWidth;               // Pixel width of the glyph
    SHORT wAdvance;             // Pixels to advance after the glyph
    WORD wMask;                 // Channel mask
} GLYPH_ATTR;


//--------------------------------------------------------------------------------------
// Name: SavedStates
// Desc: List of states to save.  We use an enum so that the list can evolve over time
//          without worrying about re-ordering, inserting, or removing saved states.
//--------------------------------------------------------------------------------------
enum SavedStates
{
    SAVEDSTATE_D3DRS_ALPHABLENDENABLE,
    SAVEDSTATE_D3DRS_SRCBLEND,
    SAVEDSTATE_D3DRS_DESTBLEND,
    SAVEDSTATE_D3DRS_BLENDOP,
    SAVEDSTATE_D3DRS_ALPHATESTENABLE,
    SAVEDSTATE_D3DRS_ALPHAREF,
    SAVEDSTATE_D3DRS_ALPHAFUNC,
    SAVEDSTATE_D3DRS_FILLMODE,
    SAVEDSTATE_D3DRS_CULLMODE,
    SAVEDSTATE_D3DRS_ZENABLE,
    SAVEDSTATE_D3DRS_STENCILENABLE,
    SAVEDSTATE_D3DRS_VIEWPORTENABLE,
    SAVEDSTATE_D3DSAMP_MINFILTER,
    SAVEDSTATE_D3DSAMP_MAGFILTER,
    SAVEDSTATE_D3DSAMP_ADDRESSU,
    SAVEDSTATE_D3DSAMP_ADDRESSV,

    SAVEDSTATE_COUNT
};

//--------------------------------------------------------------------------------------
// Name: Font
// Desc: Class to implement texture-based font rendering. A .tga image file of the
//       pre-rendered font is used to create the texture. A .abc file contains info for
//       spacing the font characters (aka glyphs).
//--------------------------------------------------------------------------------------
class Font
{
public:
    PackedResource m_xprResource;

    // Font vertical dimensions taken from the font file
    FLOAT m_fFontHeight;        // Height of the font strike in pixels
    FLOAT m_fFontTopPadding;    // Padding above the strike zone
    FLOAT m_fFontBottomPadding; // Padding below the strike zone
    FLOAT m_fFontYAdvance;      // Number of pixels to move the cursor for a line feed

    FLOAT m_fXScaleFactor;      // Scaling constants
    FLOAT m_fYScaleFactor;
    FLOAT m_fSlantFactor;       // For italics
    DOUBLE m_dRotCos;           // Precalculated sine and cosine for italic like rotation
    DOUBLE m_dRotSin;

    D3DRECT m_rcWindow;         // Bounds rect if the text window, modify via accessors only!
    FLOAT m_fCursorX;           // Current text cursor
    FLOAT m_fCursorY;

    // Translator table for supporting unicode ranges
    DWORD m_cMaxGlyph;          // Number of entries in the translator table
    WCHAR* m_TranslatorTable;   // ASCII to glyph lookup table

    // Glyph data for the font
    DWORD m_dwNumGlyphs;        // Number of valid glyphs
    const GLYPH_ATTR* m_Glyphs; // Array of glyphs

    // D3D rendering objects
    D3DTexture* m_pFontTexture;

    // Saved state for rendering (if not using a pure device)
    DWORD m_dwSavedState[ SAVEDSTATE_COUNT ];
    DWORD m_dwNestedBeginCount;
    BOOL m_bSaveState;

    BOOL m_bRotate;


public:
    // Accessor functions
    inline D3DTexture* GetTexture() const
    {
        return m_pFontTexture;
    }
    inline FLOAT GetFontHeight() const
    {
        return m_fFontYAdvance;
    }
    inline VOID SetSlantFactor( FLOAT fSlantFactor )
    {
        m_fSlantFactor = fSlantFactor;
    }

    inline VOID SetScaleFactors( FLOAT fXScaleFactor, FLOAT fYScaleFactor )
    {
        m_fXScaleFactor = fXScaleFactor;
        m_fYScaleFactor = fYScaleFactor;
    }

public:
    Font();
    ~Font();

    // Functions to create and destroy the internal objects
    HRESULT Create( const CHAR* strFontFileName );
    HRESULT Create( D3DTexture* pFontTexture, const VOID* pFontData );
    VOID    Destroy();

    // Returns the dimensions of a text string
    VOID    GetTextExtent( const WCHAR* strText, FLOAT* pWidth,
                           FLOAT* pHeight, BOOL bFirstLineOnly=FALSE ) const;
    FLOAT   GetTextWidth( const WCHAR* strText ) const;

    VOID    SetWindow(const D3DRECT &rcWindow );
    VOID    SetWindow( LONG x1, LONG y1, LONG x2, LONG y2 );
    VOID    GetWindow(D3DRECT &rcWindow) const;
    VOID    SetCursorPosition( FLOAT fCursorX, FLOAT fCursorY );
    VOID    SetRotationFactor( FLOAT fRotationFactor );

    // Function to create a texture containing rendered text
    D3DTexture* CreateTexture( const WCHAR* strText,
                               D3DCOLOR dwBackgroundColor = 0x00000000,
                               D3DCOLOR dwTextColor = 0xffffffff,
                               D3DFORMAT d3dFormat = D3DFMT_A8R8G8B8 );

    // Public calls to render text. Callers can simply call DrawText(), but for
    // performance, they should batch multiple calls together, bracketed by calls to
    // Begin() and End().
    VOID    Begin();
    VOID    DrawText( DWORD dwColor, const WCHAR* strText, DWORD dwFlags=0L,
                      FLOAT fMaxPixelWidth = 0.0f );
    VOID    DrawText( FLOAT sx, FLOAT sy, DWORD dwColor, const WCHAR* strText,
                      DWORD dwFlags=0L, FLOAT fMaxPixelWidth = 0.0f );
    VOID    End();

private:
    // Internal helper functions
    HRESULT CreateFontShaders();
    VOID ReleaseFontShaders();
    VOID RotatePoint( FLOAT* X, FLOAT* Y, DOUBLE OriginX, DOUBLE OriginY ) const;
};


//--------------------------------------------------------------------------------------
// Defines for special characters. Note this depends on the font used, but all samples
// are coded to use the same basic font
//--------------------------------------------------------------------------------------
#define GLYPH_A_BUTTON      L"\400"
#define GLYPH_B_BUTTON      L"\401"
#define GLYPH_X_BUTTON      L"\402"
#define GLYPH_Y_BUTTON      L"\403"
#define GLYPH_WHITE_BUTTON  L"\404"
#define GLYPH_BLACK_BUTTON  L"\405"
#define GLYPH_LEFT_BUTTON   L"\406"
#define GLYPH_RIGHT_BUTTON  L"\407"
#define GLYPH_START_BUTTON  L"\410\411"
#define GLYPH_BACK_BUTTON   L"\412\413"

#define GLYPH_LEFT_HAND     L"\414"
#define GLYPH_RIGHT_HAND    L"\415"
#define GLYPH_UP_HAND       L"\416"
#define GLYPH_DOWN_HAND     L"\417"

#define GLYPH_BULLET        L"\500"
#define GLYPH_STAR_1        L"\501"
#define GLYPH_STAR_2        L"\502"
#define GLYPH_STAR_3        L"\503"
#define GLYPH_STAR_4        L"\504"
#define GLYPH_STAR_5        L"\505"

#define GLYPH_BIG_X         L"\506"
#define GLYPH_HAND          L"\507"
#define GLYPH_CHECK_MARK    L"\510"
#define GLYPH_X_MARK        L"\511"
#define GLYPH_SKULL         L"\512"

#define GLYPH_LEFT_TICK     L"\514"
#define GLYPH_RIGHT_TICK    L"\515"
#define GLYPH_UP_TICK       L"\516"
#define GLYPH_DOWN_TICK     L"\517"

#define GLYPH_HOLLOW_CIRCLE L"\600"
#define GLYPH_FILLED_CIRCLE L"\601"

#define GLYPH_LR_ARROW      L"\612"
#define GLYPH_UD_ARROW      L"\613"
#define GLYPH_LEFT_ARROW    L"\614"
#define GLYPH_RIGHT_ARROW   L"\615"
#define GLYPH_UP_ARROW      L"\616"
#define GLYPH_DOWN_ARROW    L"\617"

} // namespace ATG

#endif // ATGFONT_H

```

`XenonDumper/libs/Atg/AtgFrame.cpp`:

```cpp
//-----------------------------------------------------------------------------
// AtgFrame.cpp
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "AtgFrame.h"
#include <float.h>

namespace ATG
{

CONST StringID Frame::TypeID( L"Frame" );


//-----------------------------------------------------------------------------
// Name: Frame::Frame()
//-----------------------------------------------------------------------------
Frame::Frame()
{
    m_pParent = NULL;
    m_pNextSibling = NULL;
    m_pFirstChild = NULL;

    SetCachedWorldTransformDirty();
    m_LocalTransform = XMMatrixIdentity();
}


//-----------------------------------------------------------------------------
// Name: Frame::Frame()
//-----------------------------------------------------------------------------
Frame::Frame( const StringID& Name, CXMMATRIX matLocalTransform )
{
    m_pParent = NULL;
    m_pNextSibling = NULL;
    m_pFirstChild = NULL;

    SetCachedWorldTransformDirty();
    m_LocalTransform = matLocalTransform;
    SetName( Name );
}


//-----------------------------------------------------------------------------
// Name: Frame::~Frame()
//-----------------------------------------------------------------------------
Frame::~Frame()
{
    SetParent( NULL );
}


//-----------------------------------------------------------------------------
// Name: Frame::AddChild()
//-----------------------------------------------------------------------------
VOID Frame::AddChild( Frame* pChild )
{
    assert( pChild );
    pChild->SetParent( this );
}


//-----------------------------------------------------------------------------
// Name: Frame::SetParent()
//-----------------------------------------------------------------------------
VOID Frame::SetParent( Frame* pParent )
{
    Frame* pSrch, *pLast;

    UpdateCachedWorldTransformIfNeeded();

    if( m_pParent )
    {
        pLast = NULL;
        for( pSrch = m_pParent->m_pFirstChild; pSrch; pSrch = pSrch->m_pNextSibling )
        {
            if( pSrch == this )
                break;
            pLast = pSrch;
        }

        // If we can't find this frame in the old parent's list, assert
        assert( pSrch );

        // Remove us from the list
        if( pLast )
        {
            pLast->m_pNextSibling = m_pNextSibling;
        }
        else // at the beginning of the list
        {
            m_pParent->m_pFirstChild = m_pNextSibling;
        }

        m_pNextSibling = NULL;
        m_pParent = NULL;
    }

    // Add us to the new parent's list               
    if( pParent )
    {
        m_pParent = pParent;
        m_pNextSibling = pParent->m_pFirstChild;
        pParent->m_pFirstChild = this;
    }

    // now we update our local transform to match the old world transform
    // (i.e. move under our new parent's frame with no detectable change)

    XMMATRIX worldMatrix = m_CachedWorldTransform;
    SetWorldTransform( worldMatrix );
}


//-----------------------------------------------------------------------------
// Name: Frame::IsAncestor()
// Desc: Returns TRUE if the specified frame is an ancestor of this frame
//       ancestor = parent, parent->parent, etc.
//       Also returns TRUE if specified frame is NULL.
//-----------------------------------------------------------------------------
BOOL Frame::IsAncestor( Frame* pOtherFrame )
{
    if( pOtherFrame == NULL )
        return TRUE;
    if( pOtherFrame == this )
        return FALSE;
    Frame* pFrame = GetParent();
    while( pFrame != NULL )
    {
        if( pFrame == pOtherFrame )
            return TRUE;
        pFrame = pFrame->GetParent();
    }
    return FALSE;
}


//-----------------------------------------------------------------------------
// Name: Frame::IsChild()
// Desc: Returns TRUE if the specified frame is a direct child of this frame
//-----------------------------------------------------------------------------
BOOL Frame::IsChild( Frame* pOtherFrame )
{
    if( pOtherFrame == NULL )
        return FALSE;
    Frame* pChild = GetFirstChild();
    while( pChild != NULL )
    {
        if( pChild == pOtherFrame )
            return TRUE;
        pChild = pChild->GetNextSibling();
    }
    return FALSE;
}


//-----------------------------------------------------------------------------
// Name: Frame::GetWorldPosition()
//-----------------------------------------------------------------------------
XMVECTOR Frame::GetWorldPosition()
{
    UpdateCachedWorldTransformIfNeeded();
    return m_CachedWorldTransform.r[3];
}


//-----------------------------------------------------------------------------
// Name: Frame::SetWorldPosition()
//-----------------------------------------------------------------------------
VOID Frame::SetWorldPosition( CONST XMVECTOR &NewPosition )
 {
    UpdateCachedWorldTransformIfNeeded();
    XMMATRIX ModifiedWorldTransform = m_CachedWorldTransform;

    ModifiedWorldTransform.r[3] = NewPosition;

    SetWorldTransform( ModifiedWorldTransform );
}


//-----------------------------------------------------------------------------
// Name: Frame::GetWorldTransform()
//-----------------------------------------------------------------------------
const XMMATRIX& Frame::GetWorldTransform()
{
    UpdateCachedWorldTransformIfNeeded();
    return m_CachedWorldTransform;
}

//-----------------------------------------------------------------------------
// Name: Frame::GetWorldRight()
//-----------------------------------------------------------------------------
XMVECTOR Frame::GetWorldRight()
{
    UpdateCachedWorldTransformIfNeeded();
    return m_CachedWorldTransform.r[0];
}


//-----------------------------------------------------------------------------
// Name: Frame::GetWorldUp()
//-----------------------------------------------------------------------------
XMVECTOR Frame::GetWorldUp()
{
    UpdateCachedWorldTransformIfNeeded();
    return m_CachedWorldTransform.r[1];
}


//-----------------------------------------------------------------------------
// Name: Frame::GetWorldDirection()
//-----------------------------------------------------------------------------
XMVECTOR Frame::GetWorldDirection()
{
    UpdateCachedWorldTransformIfNeeded();
    return m_CachedWorldTransform.r[2];
}


//-----------------------------------------------------------------------------
// Name: Frame::SetWorldTransform()
//-----------------------------------------------------------------------------
VOID Frame::SetWorldTransform( CONST XMMATRIX& WorldTransform )
{
    XMMATRIX ParentInverse;
    XMVECTOR vDeterminant;

    if ( m_pParent )
    {    
        m_pParent->UpdateCachedWorldTransformIfNeeded();
        ParentInverse = XMMatrixInverse( &vDeterminant, m_pParent->m_CachedWorldTransform );
        
        // Parent's matrix should be invertible
        assert( XMVectorGetX( vDeterminant ) != 0.0f );
        
        m_LocalTransform = XMMatrixMultiply( WorldTransform, ParentInverse );        
    }
    else
    {
        m_LocalTransform = WorldTransform;    
    }

    SetCachedWorldTransformDirty();
}


//-----------------------------------------------------------------------------
// Name: Frame::UpdateCachedWorldTransformIfNeeded()
//-----------------------------------------------------------------------------
VOID Frame::UpdateCachedWorldTransformIfNeeded()
{
    if( IsCachedWorldTransformDirty() )
    {
        if( m_pParent )
        {
            m_pParent->UpdateCachedWorldTransformIfNeeded();
            m_CachedWorldTransform = XMMatrixMultiply( m_LocalTransform, m_pParent->m_CachedWorldTransform );
            m_CachedWorldBound = m_LocalBound * m_CachedWorldTransform;
        }
        else
        {
            m_CachedWorldTransform = m_LocalTransform;
            m_CachedWorldBound = m_LocalBound * m_CachedWorldTransform;
        }
    }
}


//-----------------------------------------------------------------------------
// Name: Frame::SetCachedWorldTransformDirty()
//-----------------------------------------------------------------------------
VOID Frame::SetCachedWorldTransformDirty()
{
    Frame* pChild;
    SetCachedWorldTransformDirtyLocal();

    for( pChild = m_pFirstChild; pChild; pChild = pChild->m_pNextSibling )
    {
        pChild->SetCachedWorldTransformDirty();
    }
}


//-----------------------------------------------------------------------------
// Name: Frame::DisconnectFromParent
// Desc: Removes parent link from the object, and converts world transform
//       to local transform.  This method is only to be used on clones of
//       scene objects, since the parent is not notified of the disconnection.
//-----------------------------------------------------------------------------
VOID Frame::DisconnectFromParent()
{
    // Debug check to make sure the parent really isn't the parent of this clone
#ifdef _DEBUG
    if( m_pParent != NULL )
    {
        assert( !m_pParent->IsChild( this ) );
    }
#endif

    UpdateCachedWorldTransformIfNeeded();
    m_pParent = NULL;
    SetWorldTransform( m_CachedWorldTransform );
}

} // namespace ATG

```

`XenonDumper/libs/Atg/AtgFrame.h`:

```h
//-----------------------------------------------------------------------------
// AtgFrame.h
//
// Describes a frame in the scene- a frame is a named typed object
// with a set of bounds and part of a transform heirarchy
//
// $OPTIMIZE: Pool Allocate
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef ATG_FRAME_H
#define ATG_FRAME_H

#include "AtgNamedTypedObject.h"
#include "AtgBound.h"

namespace ATG
{

//-----------------------------------------------------------------------------
// Name: Frame
// Desc: An named typed object with a frame of reference and a bound
//       Note: X is Right, Y is Up, and Z is Forward
//-----------------------------------------------------------------------------
class Frame : public NamedTypedObject
{
    DEFINE_TYPE_INFO();

public:
    Frame();
    Frame( const StringID& Name, CXMMATRIX matLocalTransform );
    ~Frame();

    // frame hierarchy
    VOID                        AddChild( Frame* pChild );
    VOID                        SetParent( Frame* pParent );  // Set to NULL to unparent
    
    Frame*                      GetFirstChild() CONST { return m_pFirstChild; }
    Frame*                      GetNextSibling() CONST { return m_pNextSibling; }
    Frame*                      GetParent() CONST { return m_pParent; }
    BOOL                        IsAncestor( Frame* pOtherFrame );
    BOOL                        IsChild( Frame* pOtherFrame );

    // cloned object support
    VOID                        DisconnectFromParent();    
        
    // local position
    XMVECTOR                    GetLocalPosition() CONST { return m_LocalTransform.r[3]; }
    VOID                        SetLocalPosition( CONST XMVECTOR& NewPosition ) { SetCachedWorldTransformDirty(); m_LocalTransform.r[3] = NewPosition; }
   
    // world position
    XMVECTOR                    GetWorldPosition();
    VOID                        SetWorldPosition( CONST XMVECTOR& NewPosition );

    // local transform
    const XMMATRIX&             GetLocalTransform() CONST { return m_LocalTransform; }
    VOID                        SetLocalTransform( CONST XMMATRIX& LocalTransform ) { SetCachedWorldTransformDirty(); m_LocalTransform = LocalTransform; }

    // world transform
    const XMMATRIX&             GetWorldTransform();
    VOID                        SetWorldTransform( CONST XMMATRIX& WorldTransform );

    // basis vectors
    XMVECTOR                    GetLocalRight() CONST { return m_LocalTransform.r[0]; }
    XMVECTOR                    GetLocalUp() CONST { return m_LocalTransform.r[1]; }
    XMVECTOR                    GetLocalDirection() CONST { return m_LocalTransform.r[2]; }      

    XMVECTOR                    GetWorldRight();
    XMVECTOR                    GetWorldUp();
    XMVECTOR                    GetWorldDirection();

    // bound    
    VOID                        SetLocalBound( const Bound& bound ) { m_LocalBound = bound; SetCachedWorldTransformDirty(); }
    CONST Bound&                GetLocalBound() CONST { return m_LocalBound; }
    CONST Bound&                GetWorldBound() { UpdateCachedWorldTransformIfNeeded(); return m_CachedWorldBound; }

private:
    VOID                        UpdateCachedWorldTransformIfNeeded();
    VOID                        SetCachedWorldTransformDirty();
    // Set the first element of m_CachedWorldTransform to a magic value to indicate that the cached
    // transform is invalid.
    VOID                        SetCachedWorldTransformDirtyLocal() { *(DWORD*)&m_CachedWorldTransform = 0xFFFFFFFF; }
    // An integer compare is used to check for the cached transforms validity because this avoids
    // the cost of doing a floating-point compare. Also, an integer compare allows the 0xFFFFFFFF
    // value to be used, which would evaluate to an uncomparable NAN as a float.
    // An integer comparison is faster than a floating-point comparison on this case because the value
    // to be compared is in memory, rather than in the floating-point registers.
    BOOL                        IsCachedWorldTransformDirty() const { return *(const DWORD*)&m_CachedWorldTransform == 0xFFFFFFFF; }

    XMMATRIX                    m_LocalTransform;
    XMMATRIX                    m_CachedWorldTransform;    

    Bound                       m_LocalBound;
    Bound                       m_CachedWorldBound;
    
    Frame*                      m_pParent;
    Frame*                      m_pNextSibling;
    Frame*                      m_pFirstChild;
};

} // namespace ATG

#endif // ATG_FRAME_H

```

`XenonDumper/libs/Atg/AtgFramework2010.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release_LTCG|Xbox 360">
      <Configuration>Release_LTCG</Configuration>
      <Platform>Xbox 360</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectName>AtgFramework</ProjectName>
    <ProjectGuid>{91D208A6-9936-47FD-9659-67205C3EB0AB}</ProjectGuid>
    <RootNamespace>AtgFramework</RootNamespace>
    <Keyword>XboxProj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseOfAtl>false</UseOfAtl>
    <CharacterSet>MultiByte</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>2010-01</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">Release_LTCG\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">Release_LTCG\</IntDir>
    <OutputFile Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">$(OutDir)$(ProjectName).lib</OutputFile>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'" />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">
    <ClCompile>
      <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>
      <Optimization>Full</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;_XBOX;XBOX;LTCG;_XBOX_CRT_DEPRECATE_INSECURE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <ExceptionHandling>false</ExceptionHandling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <ForceConformanceInForLoopScope>true</ForceConformanceInForLoopScope>
      <RuntimeTypeInfo>false</RuntimeTypeInfo>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(OutDir)$(ProjectName).pch</PrecompiledHeaderOutputFile>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_LTCG|Xbox 360'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="AtgXmlParser.cpp" />
    <ClCompile Include="AtgXmlWriter.cpp" />
    <ClCompile Include="AtgAnimation.cpp" />
    <ClCompile Include="AtgCamera.cpp" />
    <ClCompile Include="AtgFrame.cpp" />
    <ClCompile Include="AtgLight.cpp" />
    <ClCompile Include="AtgMaterials.cpp" />
    <ClCompile Include="AtgModel.cpp" />
    <ClCompile Include="AtgNamedTypedObject.cpp" />
    <ClCompile Include="AtgResourceDatabase.cpp" />
    <ClCompile Include="AtgScene.cpp" />
    <ClCompile Include="AtgSceneMesh.cpp" />
    <ClCompile Include="AtgSkeletalAnimation.cpp" />
    <ClCompile Include="AtgBound.cpp" />
    <ClCompile Include="AtgCollision.cpp" />
    <ClCompile Include="AtgAvatarRenderer.cpp" />
    <ClCompile Include="AtgDebugDraw.cpp" />
    <ClCompile Include="AtgFont.cpp" />
    <ClCompile Include="AtgMesh.cpp" />
    <ClCompile Include="AtgPostProcess.cpp" />
    <ClCompile Include="AtgSimpleShaders.cpp" />
    <ClCompile Include="AtgEnumStrings.cpp" />
    <ClCompile Include="AtgMediaLocator.cpp" />
    <ClCompile Include="AtgResource.cpp" />
    <ClCompile Include="AtgSceneFileParser.cpp" />
    <ClCompile Include="AtgHttp.cpp" />
    <ClCompile Include="AtgJson.cpp" />
    <ClCompile Include="AtgRest.cpp" />
    <ClCompile Include="AtgApp.cpp" />
    <ClCompile Include="AtgConsole.cpp" />
    <ClCompile Include="AtgDevice.cpp" />
    <ClCompile Include="AtgHelp.cpp" />
    <ClCompile Include="AtgInput.cpp" />
    <ClCompile Include="AtgAudio.cpp" />
    <ClCompile Include="ATGDsp.cpp" />
    <ClCompile Include="ATGSpectralDisplay.cpp" />
    <ClCompile Include="AtgWavebank.cpp" />
    <ClCompile Include="AtgUtil.cpp" />
    <ClCompile Include="AtgXime.cpp" />
    <ClCompile Include="AtgSessionManager.cpp" />
    <ClCompile Include="AtgSignIn.cpp" />
    <ClCompile Include="ATGNuiJointFilter.cpp" />
    <ClCompile Include="AtgNuiCommon.cpp" />
    <ClCompile Include="AtgNuiHandRefinement.cpp" />
    <ClCompile Include="AtgNuiJointConverter.cpp" />
    <ClCompile Include="AtgNuiMenu.cpp" />
    <ClCompile Include="AtgNuiRelativeCoordinates.cpp" />
    <ClCompile Include="AtgNuiVisualization.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="AtgXmlParser.h" />
    <ClInclude Include="AtgXmlWriter.h" />
    <ClInclude Include="AtgAnimation.h" />
    <ClInclude Include="AtgCamera.h" />
    <ClInclude Include="AtgFrame.h" />
    <ClInclude Include="AtgLight.h" />
    <ClInclude Include="AtgMaterials.h" />
    <ClInclude Include="AtgModel.h" />
    <ClInclude Include="AtgNamedTypedObject.h" />
    <ClInclude Include="AtgResourceDatabase.h" />
    <ClInclude Include="AtgScene.h" />
    <ClInclude Include="AtgSceneAll.h" />
    <ClInclude Include="AtgSceneMesh.h" />
    <ClInclude Include="AtgSkeletalAnimation.h" />
    <ClInclude Include="AtgBound.h" />
    <ClInclude Include="AtgCollision.h" />
    <ClInclude Include="AtgAvatarRenderer.h" />
    <ClInclude Include="AtgDebugDraw.h" />
    <ClInclude Include="AtgFont.h" />
    <ClInclude Include="AtgMesh.h" />
    <ClInclude Include="AtgPostProcess.h" />
    <ClInclude Include="AtgSimpleShaders.h" />
    <ClInclude Include="AtgEnumStrings.h" />
    <ClInclude Include="AtgMediaLocator.h" />
    <ClInclude Include="AtgResource.h" />
    <ClInclude Include="AtgSceneFileParser.h" />
    <ClInclude Include="AtgApp.h" />
    <ClInclude Include="AtgHttp.h" />
    <ClInclude Include="AtgJson.h" />
    <ClInclude Include="AtgRest.h" />
    <ClInclude Include="AtgConsole.h" />
    <ClInclude Include="AtgDevice.h" />
    <ClInclude Include="AtgHelp.h" />
    <ClInclude Include="AtgInput.h" />
    <ClInclude Include="AtgAudio.h" />
    <ClInclude Include="ATGDsp.h" />
    <ClInclude Include="ATGSpectralDisplay.h" />
    <ClInclude Include="AtgWavebank.h" />
    <ClInclude Include="AtgLockFreePipe.h" />
    <ClInclude Include="AtgUtil.h" />
    <ClInclude Include="AtgXime.h" />
    <ClInclude Include="AtgSessionManager.h" />
    <ClInclude Include="AtgSignIn.h" />
    <ClInclude Include="ATGNuiJointFilter.h" />
    <ClInclude Include="AtgNuiCommon.h" />
    <ClInclude Include="AtgNuiHandRefinement.h" />
    <ClInclude Include="AtgNuiJointConverter.h" />
    <ClInclude Include="AtgNuiMenu.h" />
    <ClInclude Include="AtgNuiRelativeCoordinates.h" />
    <ClInclude Include="AtgNuiVisualization.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`XenonDumper/libs/Atg/AtgFramework2010.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="XML">
      <UniqueIdentifier>{7f5ba7b8-bc2d-474a-a7ea-26c8515cc057}</UniqueIdentifier>
    </Filter>
    <Filter Include="Scene">
      <UniqueIdentifier>{ca3dd9a1-0513-4280-af50-f3b7062440f1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Collision">
      <UniqueIdentifier>{9bb73257-dff5-43ba-a104-063589528afa}</UniqueIdentifier>
    </Filter>
    <Filter Include="Rendering">
      <UniqueIdentifier>{803a5d87-6f9d-4013-9ff5-62ede0051b1b}</UniqueIdentifier>
    </Filter>
    <Filter Include="File Loading">
      <UniqueIdentifier>{6e0fe610-2149-4ace-830b-44368a77d42c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Sample Framework">
      <UniqueIdentifier>{03b179ba-2861-4ece-b231-d9765a33d543}</UniqueIdentifier>
    </Filter>
    <Filter Include="Audio">
      <UniqueIdentifier>{bf51b448-e49e-4203-8909-55c02fff650d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Misc">
      <UniqueIdentifier>{34b439cf-5014-4410-95ba-62f24de5393b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Online">
      <UniqueIdentifier>{677dac40-1476-46fd-a19f-c663bd81e8ae}</UniqueIdentifier>
    </Filter>
    <Filter Include="Nui">
      <UniqueIdentifier>{e45e0408-167a-42d6-b51c-cf9bf278e408}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AtgXmlParser.cpp">
      <Filter>XML</Filter>
    </ClCompile>
    <ClCompile Include="AtgXmlWriter.cpp">
      <Filter>XML</Filter>
    </ClCompile>
    <ClCompile Include="AtgAnimation.cpp">
      <Filter>Scene</Filter>
    </ClCompile>
    <ClCompile Include="AtgCamera.cpp">
      <Filter>Scene</Filter>
    </ClCompile>
    <ClCompile Include="AtgFrame.cpp">
      <Filter>Scene</Filter>
    </ClCompile>
    <ClCompile Include="AtgLight.cpp">
      <Filter>Scene</Filter>
    </ClCompile>
    <ClCompile Include="AtgMaterials.cpp">
      <Filter>Scene</Filter>
    </ClCompile>
    <ClCompile Include="AtgModel.cpp">
      <Filter>Scene</Filter>
    </ClCompile>
    <ClCompile Include="AtgNamedTypedObject.cpp">
      <Filter>Scene</Filter>
    </ClCompile>
    <ClCompile Include="AtgResourceDatabase.cpp">
      <Filter>Scene</Filter>
    </ClCompile>
    <ClCompile Include="AtgScene.cpp">
      <Filter>Scene</Filter>
    </ClCompile>
    <ClCompile Include="AtgSceneMesh.cpp">
      <Filter>Scene</Filter>
    </ClCompile>
    <ClCompile Include="AtgSkeletalAnimation.cpp">
      <Filter>Scene</Filter>
    </ClCompile>
    <ClCompile Include="AtgBound.cpp">
      <Filter>Collision</Filter>
    </ClCompile>
    <ClCompile Include="AtgCollision.cpp">
      <Filter>Collision</Filter>
    </ClCompile>
    <ClCompile Include="AtgAvatarRenderer.cpp">
      <Filter>Rendering</Filter>
    </ClCompile>
    <ClCompile Include="AtgDebugDraw.cpp">
      <Filter>Rendering</Filter>
    </ClCompile>
    <ClCompile Include="AtgFont.cpp">
      <Filter>Rendering</Filter>
    </ClCompile>
    <ClCompile Include="AtgMesh.cpp">
      <Filter>Rendering</Filter>
    </ClCompile>
    <ClCompile Include="AtgPostProcess.cpp">
      <Filter>Rendering</Filter>
    </ClCompile>
    <ClCompile Include="AtgSimpleShaders.cpp">
      <Filter>Rendering</Filter>
    </ClCompile>
    <ClCompile Include="AtgEnumStrings.cpp">
      <Filter>File Loading</Filter>
    </ClCompile>
    <ClCompile Include="AtgMediaLocator.cpp">
      <Filter>File Loading</Filter>
    </ClCompile>
    <ClCompile Include="AtgResource.cpp">
      <Filter>File Loading</Filter>
    </ClCompile>
    <ClCompile Include="AtgSceneFileParser.cpp">
      <Filter>File Loading</Filter>
    </ClCompile>
    <ClCompile Include="AtgApp.cpp">
      <Filter>Sample Framework</Filter>
    </ClCompile>
    <ClCompile Include="AtgConsole.cpp">
      <Filter>Sample Framework</Filter>
    </ClCompile>
    <ClCompile Include="AtgDevice.cpp">
      <Filter>Sample Framework</Filter>
    </ClCompile>
    <ClCompile Include="AtgHelp.cpp">
      <Filter>Sample Framework</Filter>
    </ClCompile>
    <ClCompile Include="AtgInput.cpp">
      <Filter>Sample Framework</Filter>
    </ClCompile>
    <ClCompile Include="AtgAudio.cpp">
      <Filter>Audio</Filter>
    </ClCompile>
    <ClCompile Include="ATGDsp.cpp">
      <Filter>Audio</Filter>
    </ClCompile>
    <ClCompile Include="ATGSpectralDisplay.cpp">
      <Filter>Audio</Filter>
    </ClCompile>
    <ClCompile Include="AtgWavebank.cpp">
      <Filter>Audio</Filter>
    </ClCompile>
    <ClCompile Include="AtgUtil.cpp">
      <Filter>Misc</Filter>
    </ClCompile>
    <ClCompile Include="AtgXime.cpp">
      <Filter>Misc</Filter>
    </ClCompile>
    <ClCompile Include="AtgHttp.cpp">
      <Filter>Online</Filter>
    </ClCompile>
    <ClCompile Include="AtgJson.cpp">
      <Filter>Online</Filter>
    </ClCompile>
    <ClCompile Include="AtgRest.cpp">
      <Filter>Online</Filter>
    </ClCompile>
    <ClCompile Include="AtgSessionManager.cpp">
      <Filter>Online</Filter>
    </ClCompile>
    <ClCompile Include="AtgSignIn.cpp">
      <Filter>Online</Filter>
    </ClCompile>
    <ClCompile Include="ATGNuiJointFilter.cpp">
      <Filter>Nui</Filter>
    </ClCompile>
    <ClCompile Include="AtgNuiCommon.cpp">
      <Filter>Nui</Filter>
    </ClCompile>
    <ClCompile Include="AtgNuiHandRefinement.cpp">
      <Filter>Nui</Filter>
    </ClCompile>
    <ClCompile Include="AtgNuiJointConverter.cpp">
      <Filter>Nui</Filter>
    </ClCompile>
    <ClCompile Include="AtgNuiVisualization.cpp">
      <Filter>Nui</Filter>
    </ClCompile>
    <ClCompile Include="AtgNuiRelativeCoordinates.cpp">
      <Filter>Nui</Filter>
    </ClCompile>
    <ClCompile Include="AtgNuiMenu.cpp">
      <Filter>Nui</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AtgAnimation.h">
      <Filter>Scene</Filter>
    </ClInclude>
	<ClInclude Include="AtgMaterials.h">
      <Filter>Scene</Filter>
    </ClInclude>
    <ClInclude Include="AtgSceneMesh.h">
      <Filter>Scene</Filter>
    </ClInclude>
    <ClInclude Include="AtgSkeletalAnimation.h">
      <Filter>Scene</Filter>
    </ClInclude>
    <ClInclude Include="AtgAvatarRenderer.h">
      <Filter>Rendering</Filter>
    </ClInclude>
    <ClInclude Include="AtgFont.h">
      <Filter>Rendering</Filter>
    </ClInclude>
    <ClInclude Include="AtgMesh.h">
      <Filter>Rendering</Filter>
    </ClInclude>
    <ClInclude Include="AtgPostProcess.h">
      <Filter>Rendering</Filter>
    </ClInclude>
    <ClInclude Include="AtgMediaLocator.h">
      <Filter>File Loading</Filter>
    </ClInclude>
    <ClInclude Include="AtgResource.h">
      <Filter>File Loading</Filter>
    </ClInclude>
    <ClInclude Include="AtgSceneFileParser.h">
      <Filter>File Loading</Filter>
    </ClInclude>
    <ClInclude Include="AtgApp.h">
      <Filter>Sample Framework</Filter>
    </ClInclude>
    <ClInclude Include="AtgConsole.h">
      <Filter>Sample Framework</Filter>
    </ClInclude>
    <ClInclude Include="AtgDevice.h">
      <Filter>Sample Framework</Filter>
    </ClInclude>
    <ClInclude Include="AtgHelp.h">
      <Filter>Sample Framework</Filter>
    </ClInclude>
    <ClInclude Include="AtgInput.h">
      <Filter>Sample Framework</Filter>
    </ClInclude>
    <ClInclude Include="AtgAudio.h">
      <Filter>Audio</Filter>
    </ClInclude>
    <ClInclude Include="ATGDsp.h">
      <Filter>Audio</Filter>
    </ClInclude>
    <ClInclude Include="ATGSpectralDisplay.h">
      <Filter>Audio</Filter>
    </ClInclude>
    <ClInclude Include="AtgWavebank.h">
      <Filter>Audio</Filter>
    </ClInclude>
    <ClInclude Include="AtgLockFreePipe.h">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="AtgUtil.h">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="AtgXime.h">
      <Filter>Misc</Filter>
    </ClInclude>
    <ClInclude Include="AtgHttp.h">
      <Filter>Online</Filter>
    </ClInclude>
    <ClInclude Include="AtgJson.h">
      <Filter>Online</Filter>
    </ClInclude>
    <ClInclude Include="AtgRest.h">
      <Filter>Online</Filter>
    </ClInclude>
    <ClInclude Include="AtgSessionManager.h">
      <Filter>Online</Filter>
    </ClInclude>
    <ClInclude Include="AtgSignIn.h">
      <Filter>Online</Filter>
    </ClInclude>
    <ClInclude Include="ATGNuiJointFilter.h">
      <Filter>Nui</Filter>
    </ClInclude>
    <ClInclude Include="AtgNuiCommon.h">
      <Filter>Nui</Filter>
    </ClInclude>
    <ClInclude Include="AtgNuiHandRefinement.h">
      <Filter>Nui</Filter>
    </ClInclude>
    <ClInclude Include="AtgNuiJointConverter.h">
      <Filter>Nui</Filter>
    </ClInclude>
    <ClInclude Include="AtgNuiVisualization.h">
      <Filter>Nui</Filter>
    </ClInclude>
    <ClInclude Include="AtgNuiMenu.h">
      <Filter>Nui</Filter>
    </ClInclude>
    <ClInclude Include="AtgXmlParser.h">
      <Filter>XML</Filter>
    </ClInclude>
    <ClInclude Include="AtgXmlWriter.h">
      <Filter>XML</Filter>
    </ClInclude>
    <ClInclude Include="AtgCamera.h">
      <Filter>Scene</Filter>
    </ClInclude>
    <ClInclude Include="AtgFrame.h">
      <Filter>Scene</Filter>
    </ClInclude>
    <ClInclude Include="AtgLight.h">
      <Filter>Scene</Filter>
    </ClInclude>
    <ClInclude Include="AtgModel.h">
      <Filter>Scene</Filter>
    </ClInclude>
    <ClInclude Include="AtgNamedTypedObject.h">
      <Filter>Scene</Filter>
    </ClInclude>
    <ClInclude Include="AtgResourceDatabase.h">
      <Filter>Scene</Filter>
    </ClInclude>
    <ClInclude Include="AtgScene.h">
      <Filter>Scene</Filter>
    </ClInclude>
    <ClInclude Include="AtgSceneAll.h">
      <Filter>Scene</Filter>
    </ClInclude>
    <ClInclude Include="AtgBound.h">
      <Filter>Collision</Filter>
    </ClInclude>
    <ClInclude Include="AtgCollision.h">
      <Filter>Collision</Filter>
    </ClInclude>
    <ClInclude Include="AtgDebugDraw.h">
      <Filter>Rendering</Filter>
    </ClInclude>
    <ClInclude Include="AtgSimpleShaders.h">
      <Filter>Rendering</Filter>
    </ClInclude>
    <ClInclude Include="AtgEnumStrings.h">
      <Filter>File Loading</Filter>
    </ClInclude>
    <ClInclude Include="AtgNuiRelativeCoordinates.h">
      <Filter>Nui</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`XenonDumper/libs/Atg/AtgFrameworkWin322010.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{AFB1BA2F-4069-4856-ACED-9970622BD4AF}</ProjectGuid>
    <RootNamespace>AtgFrameworkWin32</RootNamespace>
    <Keyword>Win32Proj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)_$(Platform)_2010\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(Configuration)_$(Platform)_2010\</IntDir>
    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)_$(Platform)_2010\</OutDir>
    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(Configuration)_$(Platform)_2010\</IntDir>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>$(XEDK)\include;$(XEDK)\include\win32;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;_PC;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>true</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderOutputFile>$(Configuration)_$(Platform)_2010/$(TargetName).pch</PrecompiledHeaderOutputFile>
      <ObjectFileName>$(Configuration)_$(Platform)_2010/</ObjectFileName>
      <ProgramDataBaseFileName>$(Configuration)_$(Platform)_2010/vc70.pdb</ProgramDataBaseFileName>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
    </ClCompile>
    <Lib>
      <OutputFile>$(OutDir)AtgFrameworkWin32.lib</OutputFile>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <AdditionalIncludeDirectories>$(XEDK)\include;$(XEDK)\include\win32;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;_PC;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderOutputFile>$(Configuration)_$(Platform)_2010/$(TargetName).pch</PrecompiledHeaderOutputFile>
      <ObjectFileName>$(Configuration)_$(Platform)_2010/</ObjectFileName>
      <ProgramDataBaseFileName>$(Configuration)_$(Platform)_2010/vc70.pdb</ProgramDataBaseFileName>
      <WarningLevel>Level4</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Lib>
      <OutputFile>$(OutDir)AtgFrameworkWin32.lib</OutputFile>
    </Lib>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="AtgAnimation.cpp" />
    <ClCompile Include="AtgApp.cpp" />
    <ClCompile Include="AtgBound.cpp" />
    <ClCompile Include="AtgCamera.cpp" />
    <ClCompile Include="AtgCollision.cpp" />
    <ClCompile Include="AtgDebugDraw.cpp" />
    <ClCompile Include="AtgDevice.cpp" />
    <ClCompile Include="AtgEnumStrings.cpp" />
    <ClCompile Include="AtgFrame.cpp" />
    <ClCompile Include="AtgLight.cpp" />
    <ClCompile Include="AtgMaterials.cpp" />
    <ClCompile Include="AtgModel.cpp" />
    <ClCompile Include="AtgNamedTypedObject.cpp" />
    <ClCompile Include="AtgResource.cpp" />
    <ClCompile Include="AtgResourceDatabase.cpp" />
    <ClCompile Include="AtgScene.cpp" />
    <ClCompile Include="AtgSceneFileParser.cpp" />
    <ClCompile Include="AtgSceneMesh.cpp" />
    <ClCompile Include="AtgSimpleShaders.cpp" />
    <ClCompile Include="AtgUtil.cpp" />
    <ClCompile Include="AtgXmlParser.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="XTLOnPC.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="AtgAnimation.h" />
    <ClInclude Include="AtgApp.h" />
    <ClInclude Include="AtgBound.h" />
    <ClInclude Include="AtgCamera.h" />
    <ClInclude Include="AtgCollision.h" />
    <ClInclude Include="AtgDebugDraw.h" />
    <ClInclude Include="AtgDevice.h" />
    <ClInclude Include="AtgEnumStrings.h" />
    <ClInclude Include="AtgFrame.h" />
    <ClInclude Include="AtgLight.h" />
    <ClInclude Include="AtgMaterials.h" />
    <ClInclude Include="AtgModel.h" />
    <ClInclude Include="AtgNamedTypedObject.h" />
    <ClInclude Include="AtgResource.h" />
    <ClInclude Include="AtgResourceDatabase.h" />
    <ClInclude Include="AtgScene.h" />
    <ClInclude Include="AtgSceneAll.h" />
    <ClInclude Include="AtgSceneFileParser.h" />
    <ClInclude Include="AtgSceneMesh.h" />
    <ClInclude Include="AtgSimpleShaders.h" />
    <ClInclude Include="AtgSkeletalAnimation.h" />
    <ClInclude Include="AtgUtil.h" />
    <ClInclude Include="AtgXmlParser.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="XTLOnPC.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`XenonDumper/libs/Atg/AtgFrameworkWin322010.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="AtgAnimation.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AtgApp.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AtgBound.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AtgCamera.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AtgCollision.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AtgDebugDraw.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AtgDevice.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AtgEnumStrings.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AtgFrame.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AtgLight.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AtgMaterials.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AtgModel.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AtgNamedTypedObject.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AtgResource.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AtgResourceDatabase.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AtgScene.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AtgSceneFileParser.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AtgSceneMesh.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AtgSimpleShaders.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AtgUtil.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AtgXmlParser.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="XTLOnPC.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="AtgAnimation.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AtgApp.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AtgBound.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AtgCamera.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AtgCollision.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AtgDebugDraw.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AtgDevice.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AtgEnumStrings.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AtgFrame.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AtgLight.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AtgMaterials.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AtgModel.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AtgNamedTypedObject.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AtgResource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AtgResourceDatabase.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AtgScene.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AtgSceneAll.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AtgSceneFileParser.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AtgSceneMesh.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AtgSimpleShaders.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AtgSkeletalAnimation.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AtgUtil.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AtgXmlParser.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="XTLOnPC.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`XenonDumper/libs/Atg/AtgHelp.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// AtgHelp.cpp
//
// Support class for rendering a help image of a gamepad with labelled callouts to the
// gamepad controls.
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#include "stdafx.h"
#include "AtgDevice.h"
#include "AtgFont.h"
#include "AtgHelp.h"
#include "AtgResource.h"
#include "AtgUtil.h"

namespace ATG
{

// Global access to the main D3D device
extern D3DDevice* g_pd3dDevice;


//--------------------------------------------------------------------------------------
// Constants for rendering callouts on the help screen. The order of these callouts is
// in agreement with the enum structure in AtgHelp.h
//--------------------------------------------------------------------------------------
struct HELP_CALLOUT_POS
{
    XMFLOAT2 Button;

    struct
    {
        XMFLOAT2 Line;
        XMFLOAT2 Text;
    }
        Placement[2];

    DWORD dwFontFlags;
};

static struct
{
    FLOAT fButtonX, fButtonY;
    FLOAT fLine1X,  fLine1Y, fText1X, fText1Y;
    FLOAT fLine2X,  fLine2Y, fText2X, fText2Y;
    DWORD dwFontFlags;
} g_vHelpCallouts[] =
{
    // Left thumbstick
    { 511.0f, 271.0f,
        428.0f, 285.0f,  426.0f, 275.0f,
        428.0f, 285.0f,  426.0f, 275.0f,
        ATGFONT_RIGHT },

    // Right thumbstick 
    { 701.0f, 351.0f,
        701.0f, 447.0f,  711.0f, 447.0f,
        701.0f, 447.0f,  711.0f, 447.0f,
        ATGFONT_RIGHT },

    // D-pad
    { 577.0f, 353.0f,
        521.0f, 381.0f,  521.0f, 381.0f,
        521.0f, 381.0f,  521.0f, 381.0f,
        ATGFONT_RIGHT },

    // Back button
    { 595.0f, 276.0f,
        595.0f, 122.0f,  605.0f,  97.0f,
        595.0f, 122.0f,  605.0f,  72.0f,
        ATGFONT_RIGHT },

    // Start button
    { 686.0f, 273.0f,
        686.0f, 122.0f,  676.0f,  97.0f,
        686.0f, 122.0f,  676.0f,  72.0f,
        ATGFONT_LEFT },

    // X button
    { 732.0f, 272.0f,
        759.0f, 447.0f,  759.0f, 447.0f,
        759.0f, 447.0f,  759.0f, 447.0f,
        ATGFONT_LEFT },

    // Y button
    { 763.0f, 235.0f,
        843.0f, 235.0f,  845.0f, 222.0f,
        843.0f, 235.0f,  845.0f, 222.0f,
        ATGFONT_LEFT },

    // A button
    { 765.0f, 308.0f,
        800.0f, 372.0f,  800.0f, 372.0f,
        800.0f, 372.0f,  800.0f, 372.0f,
        ATGFONT_LEFT },

    // B button
    { 796.0f, 271.0f,
        824.0f, 297.0f,  824.0f, 297.0f,
        824.0f, 297.0f,  824.0f, 297.0f,
        ATGFONT_LEFT },

    // Left shoulder button
    { 509.0f, 199.0f,
        462.0f, 117.0f,  460.0f, 107.0f,
        462.0f, 117.0f,  460.0f, 107.0f,
        ATGFONT_RIGHT },

    // Right shoulder button
    { 763.0f, 193.0f,
        815.0f, 117.0f,  817.0f, 107.0f,
        815.0f, 117.0f,  817.0f, 107.0f,
        ATGFONT_LEFT },

    // Misc callout: bottom left
    {   0.0f,   0.0f,
        0.0f,   0.0f,  128.0f, 618.0f,
        0.0f,   0.0f,  128.0f, 588.0f,
        ATGFONT_LEFT },

    // Misc callout: bottom center
    {   0.0f,   0.0f,
        0.0f,   0.0f,  640.0f, 618.0f,
        0.0f,   0.0f,  640.0f, 588.0f,
        ATGFONT_CENTER_X },

    // Misc callout: bottom right
    {   0.0f,   0.0f,
        0.0f,   0.0f, 1152.0f, 618.0f,
        0.0f,   0.0f, 1152.0f, 588.0f,
        ATGFONT_RIGHT },

    // Left Trigger
    { 465.0f, 230.0f,
        412.0f, 177.0f,  410.0f, 167.0f,
        412.0f, 177.0f,  410.0f, 167.0f,
        ATGFONT_RIGHT },

    // Right Trigger
    { 813.0f, 230.0f,
        865.0f, 177.0f,  867.0f, 167.0f,
        865.0f, 177.0f,  867.0f, 167.0f,
        ATGFONT_LEFT },
};

static HELP_CALLOUT_POS* g_pHelpCallouts = ( HELP_CALLOUT_POS* )&g_vHelpCallouts[0];


//--------------------------------------------------------------------------------------
// Vertex and pixel shaders for rendering the help screen
//--------------------------------------------------------------------------------------
static const CHAR* g_strHelpShader =
    " struct VS_IN                                          "
    " {                                                     "
    "     float2 Pos            : POSITION;                 "
    "     float2 Tex            : TEXCOORD0;                "
    " };                                                    "
    "                                                       "
    " struct VS_OUT                                         "
    " {                                                     "
    "     float4 Position       : POSITION;                 "
    "     float2 TexCoord0      : TEXCOORD0;                "
    " };                                                    "
    "                                                       "
    " VS_OUT HelpVertexShader( VS_IN In )                   "
    " {                                                     "
    "     VS_OUT Out;                                       "
    "     Out.Position.x  = In.Pos.x;                       "
    "     Out.Position.y  = In.Pos.y;                       "
    "     Out.Position.z  = 0.0;                            "
    "     Out.Position.w  = 1.0;                            "
    "     Out.TexCoord0.x = In.Tex.x;                       "
    "     Out.TexCoord0.y = In.Tex.y;                       "
    "     return Out;                                       "
    " }                                                     "
    "                                                       "
    "sampler Texture : register(s0);                        "
    "                                                       "
    "float4 HelpPixelShader( VS_OUT In ) : COLOR0           "
    "{                                                      "
    "    return tex2D( Texture, In.TexCoord0 );             "
    "}                                                      "
    "                                                       "
    "float4 DarkPixelShader( [unused] VS_OUT In ) : COLOR0  "
    "{                                                      "
    "    return float4( 0.0f, 0.0f, 0.0f, 0.65f);           "
    "}                                                      ";


static D3DVertexDeclaration* g_pHelpVertexDecl = NULL;
static D3DVertexShader* g_pHelpVertexShader = NULL;
static D3DPixelShader* g_pHelpPixelShader = NULL;
static D3DPixelShader* g_pDarkPixelShader = NULL;


//--------------------------------------------------------------------------------------
// Name: Create()
// Desc: Creates the help class internal objects
//--------------------------------------------------------------------------------------
HRESULT Help::Create( const CHAR* strResource )
{
    // Create the gamepad resource
    if( FAILED( m_xprResource.Create( strResource ) ) )
        return E_FAIL;

    return Create( &m_xprResource );
}


//--------------------------------------------------------------------------------------
// Name: Create()
// Desc: Creates the help class' internal objects
//--------------------------------------------------------------------------------------
HRESULT Help::Create( const PackedResource* pResource )
{
    // Get access to the gamepad texture
    m_pGamepadTexture = pResource->GetTexture( "GamepadTexture" );

    // Load the texture used for pointing help text at specific buttons
    m_pLineTexture = pResource->GetTexture( "HelpCalloutTexture" );

    // Create vertex declaration
    if( NULL == g_pHelpVertexDecl )
    {
        static const D3DVERTEXELEMENT9 decl[] =
        {
            { 0, 0, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0 },
            { 0, 8, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, 0 },
            D3DDECL_END()
        };

        if( FAILED( g_pd3dDevice->CreateVertexDeclaration( decl, &g_pHelpVertexDecl ) ) )
            return E_FAIL;
    }

    // Create vertex shader
    ID3DXBuffer* pShaderCode;
    if( NULL == g_pHelpVertexShader )
    {
        if( FAILED( D3DXCompileShader( g_strHelpShader, strlen( g_strHelpShader ),
                                       NULL, NULL, "HelpVertexShader", "vs.2.0", 0,
                                       &pShaderCode, NULL, NULL ) ) )
            return E_FAIL;

        if( FAILED( g_pd3dDevice->CreateVertexShader( ( DWORD* )pShaderCode->GetBufferPointer(),
                                                      &g_pHelpVertexShader ) ) )
            return E_FAIL;

        pShaderCode->Release();
    }

    // Create pixel shader.
    if( NULL == g_pHelpPixelShader )
    {
        if( FAILED( D3DXCompileShader( g_strHelpShader, strlen( g_strHelpShader ),
                                       NULL, NULL, "HelpPixelShader", "ps.2.0", 0,
                                       &pShaderCode, NULL, NULL ) ) )
            return E_FAIL;

        if( FAILED( g_pd3dDevice->CreatePixelShader( ( DWORD* )pShaderCode->GetBufferPointer(),
                                                     &g_pHelpPixelShader ) ) )
            return E_FAIL;

        pShaderCode->Release();
    }

    if( NULL == g_pDarkPixelShader )
    {
        if( FAILED( D3DXCompileShader( g_strHelpShader, strlen( g_strHelpShader ),
                                       NULL, NULL, "DarkPixelShader", "ps.2.0", 0,
                                       &pShaderCode, NULL, NULL ) ) )
            return E_FAIL;

        if( FAILED( g_pd3dDevice->CreatePixelShader( ( DWORD* )pShaderCode->GetBufferPointer(),
                                                     &g_pDarkPixelShader ) ) )
            return E_FAIL;

        pShaderCode->Release();
    }

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: Render()
// Desc: Renders the gamepad help image and its labelled callouts
//--------------------------------------------------------------------------------------
VOID Help::Render( Font* pFont, const HELP_CALLOUT* pTags, DWORD dwNumCallouts )
{
#ifdef ALLOW_CALLOUT_EDITTING
    // Use the shoulder buttons, triggers, and dpad to edit callout positions
    XINPUT_STATE CurrInputState;
    static XINPUT_STATE LastInputState = {0};
    static DWORD dwCurrCallout = 0;

    if( XInputGetState( 0, &CurrInputState ) == ERROR_SUCCESS )
    {
        if( ( 0 != (CurrInputState.Gamepad.wButtons&XINPUT_GAMEPAD_LEFT_SHOULDER) ) &&
            ( 0 == (LastInputState.Gamepad.wButtons&XINPUT_GAMEPAD_LEFT_SHOULDER) ) )
            dwCurrCallout = (dwCurrCallout+dwNumCallouts-1) % dwNumCallouts;
        if( ( 0 != (CurrInputState.Gamepad.wButtons&XINPUT_GAMEPAD_RIGHT_SHOULDER) ) &&
            ( 0 == (LastInputState.Gamepad.wButtons&XINPUT_GAMEPAD_RIGHT_SHOULDER) ) )
            dwCurrCallout = (dwCurrCallout+dwNumCallouts+1) % dwNumCallouts;

        HELP_CALLOUT_POS* pCallout = &g_pHelpCallouts[pTags[dwCurrCallout].wControl];
        XMFLOAT2* pPos1 = &pCallout->Button;
        XMFLOAT2* pPos2 = &pCallout->Placement[pTags[dwCurrCallout].wPlacement].Line;
        XMFLOAT2* pPos3 = &pCallout->Placement[pTags[dwCurrCallout].wPlacement].Text;

        if( CurrInputState.Gamepad.bLeftTrigger )
        {
            pPos1->x -= CurrInputState.Gamepad.wButtons&XINPUT_GAMEPAD_DPAD_LEFT  ? 1.0f : 0.0f;
            pPos1->x += CurrInputState.Gamepad.wButtons&XINPUT_GAMEPAD_DPAD_RIGHT ? 1.0f : 0.0f;
            pPos1->y -= CurrInputState.Gamepad.wButtons&XINPUT_GAMEPAD_DPAD_UP    ? 1.0f : 0.0f;
            pPos1->y += CurrInputState.Gamepad.wButtons&XINPUT_GAMEPAD_DPAD_DOWN  ? 1.0f : 0.0f;
        }
        else if( CurrInputState.Gamepad.bRightTrigger )
        {
            pPos2->x -= CurrInputState.Gamepad.wButtons&XINPUT_GAMEPAD_DPAD_LEFT  ? 1.0f : 0.0f;
            pPos2->x += CurrInputState.Gamepad.wButtons&XINPUT_GAMEPAD_DPAD_RIGHT ? 1.0f : 0.0f;
            pPos2->y -= CurrInputState.Gamepad.wButtons&XINPUT_GAMEPAD_DPAD_UP    ? 1.0f : 0.0f;
            pPos2->y += CurrInputState.Gamepad.wButtons&XINPUT_GAMEPAD_DPAD_DOWN  ? 1.0f : 0.0f;
            pPos3->x -= CurrInputState.Gamepad.wButtons&XINPUT_GAMEPAD_DPAD_LEFT  ? 1.0f : 0.0f;
            pPos3->x += CurrInputState.Gamepad.wButtons&XINPUT_GAMEPAD_DPAD_RIGHT ? 1.0f : 0.0f;
            pPos3->y -= CurrInputState.Gamepad.wButtons&XINPUT_GAMEPAD_DPAD_UP    ? 1.0f : 0.0f;
            pPos3->y += CurrInputState.Gamepad.wButtons&XINPUT_GAMEPAD_DPAD_DOWN  ? 1.0f : 0.0f;
        }

        memcpy( &LastInputState, &CurrInputState, sizeof(XINPUT_STATE) );
    }
#endif // ALLOW_CALLOUT_EDITTING

    // Calculate a scale factor based on the video mode
    D3DDISPLAYMODE ModeDesc;
    XGTEXTURE_DESC TextureDesc;
    g_pd3dDevice->GetDisplayMode( 0, &ModeDesc );
    XGGetTextureDesc( m_pGamepadTexture, 0, &TextureDesc );

    FLOAT fScale = ModeDesc.Width / 1280.0f;
    FLOAT h = fScale * 720 * 0.48f;
    FLOAT w = TextureDesc.Width * h / TextureDesc.Height;
    FLOAT x = ( ModeDesc.Width - w ) / 2;
    FLOAT y = ( ModeDesc.Height - h ) / 2;

    D3DRECT rcSaved = pFont->m_rcWindow;
    pFont->SetWindow( 0, 0, ModeDesc.Width, ModeDesc.Height );

    // Setup the gamepad vertices
    struct VERTEX
    {
        FLOAT sx, sy;
        FLOAT tu, tv;
    };

    // Set up state for rendering the gamepad
    g_pd3dDevice->SetVertexDeclaration( g_pHelpVertexDecl );
    g_pd3dDevice->SetVertexShader( g_pHelpVertexShader );
    g_pd3dDevice->SetTexture( 0, m_pGamepadTexture );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID );
    g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
    g_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
    g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    g_pd3dDevice->SetRenderState( D3DRS_BLENDOP, D3DBLENDOP_ADD );

    // Draw the scene-darkening quad
    {
        VERTEX GamepadVertices[4] =
        {
            {                0.0f,                 0.0f, 0.0f, 0.0f },
            { 1.0f * ModeDesc.Width,                 0.0f, 1.0f, 0.0f },
            { 1.0f * ModeDesc.Width, 1.0f * ModeDesc.Height, 1.0f, 1.0f },
            {                0.0f, 1.0f * ModeDesc.Height, 0.0f, 1.0f },
        };

        g_pd3dDevice->SetPixelShader( g_pDarkPixelShader );
        g_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADLIST, 1, GamepadVertices, sizeof( GamepadVertices[0] ) );
    }

    // Draw the gamepad image
    {
        VERTEX GamepadVertices[4] =
        {
            { x,   y,   0.0f, 0.0f },
            { x + w, y,   1.0f, 0.0f },
            { x + w, y + h, 1.0f, 1.0f },
            { x,   y + h, 0.0f, 1.0f },
        };

        g_pd3dDevice->SetPixelShader( g_pHelpPixelShader );
        g_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADLIST, 1, GamepadVertices, sizeof( GamepadVertices[0] ) );
    }

    // Set state to draw the lines
    g_pd3dDevice->SetTexture( 0, m_pLineTexture );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );

    for( DWORD i = 0; i < dwNumCallouts; i++ )
    {
        if( pTags[i].wControl >= ARRAYSIZE( g_vHelpCallouts ) )
            continue;

        HELP_CALLOUT_POS* pCallout = &g_pHelpCallouts[pTags[i].wControl];
        XMFLOAT2 line1 = pCallout->Button;
        XMFLOAT2 line2 = pCallout->Placement[pTags[i].wPlacement].Line;
        line1.x = fScale * ( line1.x - 640 ) + ModeDesc.Width / 2;
        line1.y = fScale * ( line1.y - 360 ) + ModeDesc.Height / 2;
        line2.x = fScale * ( line2.x - 640 ) + ModeDesc.Width / 2;
        line2.y = fScale * ( line2.y - 360 ) + ModeDesc.Height / 2;
        XMVECTOR vc = XMVector2Normalize( XMVectorSet( line2.y - line1.y, -line2.x + line1.x, 0, 0 ) );

#ifdef ALLOW_CALLOUT_EDITTING
        if( dwCurrCallout == i )
            vc *= 2;
#endif // ALLOW_CALLOUT_EDITTING

        // Initialize the callout line vertices
        VERTEX LineVertices[4] =
        {
            { ( line1.x - 2 * vc.x ), ( line1.y - 2 * vc.y ), 0.0f, 0.0f },
            { ( line1.x + 2 * vc.x ), ( line1.y + 2 * vc.y ), 1.0f, 0.0f },
            { ( line2.x + 2 * vc.x ), ( line2.y + 2 * vc.y ), 1.0f, 1.0f },
            { ( line2.x - 2 * vc.x ), ( line2.y - 2 * vc.y ), 0.0f, 1.0f },
        };

        g_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADLIST, 1, LineVertices, sizeof( LineVertices[0] ) );
    }

    // Turn the viewport back on
    g_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, TRUE );

    // Prepare font for rendering
    pFont->Begin();
    static FLOAT fFontXScale = 1.0f;
    static FLOAT fFontYScale = 1.0f;
    pFont->SetScaleFactors( fFontXScale * fScale, fFontYScale * fScale );

    // Render the callouts
    for( DWORD i = 0; i < dwNumCallouts; i++ )
    {
        if( pTags[i].wControl >= ARRAYSIZE( g_vHelpCallouts ) )
            continue;

        HELP_CALLOUT_POS* pCallout = &g_pHelpCallouts[pTags[i].wControl];
        XMFLOAT2 pos = pCallout->Placement[pTags[i].wPlacement].Text;
        pos.x = fScale * ( pos.x - 640 ) + ModeDesc.Width / 2;
        pos.y = fScale * ( pos.y - 360 ) + ModeDesc.Height / 2;

        // Draw the callout text
        pFont->DrawText( pos.x, pos.y, 0xffffffff,
                         pTags[i].strText, g_pHelpCallouts[pTags[i].wControl].dwFontFlags );
    }

    // Flush the text drawing
    pFont->SetScaleFactors( 1.0f, 1.0f );
    pFont->End();

    pFont->m_rcWindow = rcSaved;
}


} // namespace ATG

```

`XenonDumper/libs/Atg/AtgHelp.h`:

```h
//--------------------------------------------------------------------------------------
// AtgHelp.h
//
// Support class for rendering a help image of a gamepad with labelled callouts to the
// gamepad controls.
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#pragma once
#ifndef ATGHELP_H
#define ATGHELP_H

#include "AtgFont.h"
#include "AtgResource.h"

namespace ATG
{


//--------------------------------------------------------------------------------------
// Name: struct ATGHELP_CALLOUT
// Desc: Structure for callout information, used to label controls when rendering an
//       image of an Xbox gamepad. An app will define an array of of these, one for
//       each game pad control used.
//--------------------------------------------------------------------------------------
struct HELP_CALLOUT
{
    WORD wControl;    // An index to identify a control, as enum'ed below
    WORD wPlacement;  // An offset to pick from one of the possible placements
    WCHAR* strText;     // Text to draw when rendering this callout
};


//--------------------------------------------------------------------------------------
// Name: class Help
// Desc: Class for rendering a help image of a gamepad with labelled callouts.
//--------------------------------------------------------------------------------------
class Help
{
    PackedResource m_xprResource;
    D3DTexture* m_pGamepadTexture;
    D3DTexture* m_pLineTexture;

public:
            Help()
            {
            }
            ~Help()
            {
            }

    // Functions to create and destroy the internal objects
    HRESULT Create( const CHAR* pResource );
    HRESULT Create( const PackedResource* pResource );

    // Renders the help screen (using a caller-supplied font)
    VOID    Render( Font* pFont, const HELP_CALLOUT* pTags, DWORD dwNumCallouts );
};


//--------------------------------------------------------------------------------------
// Constants used to identify callout positions
//--------------------------------------------------------------------------------------
enum
{
    HELP_LEFT_STICK,
    HELP_RIGHT_STICK,
    HELP_DPAD,
    HELP_BACK_BUTTON,
    HELP_START_BUTTON,
    HELP_X_BUTTON,
    HELP_Y_BUTTON,
    HELP_A_BUTTON,
    HELP_B_BUTTON,
    HELP_LEFT_SHOULDER,
    HELP_RIGHT_SHOULDER,
    HELP_BOTTOM_LEFT,
    HELP_BOTTOM_CENTER,
    HELP_BOTTOM_RIGHT,
    HELP_LEFT_TRIGGER,
    HELP_RIGHT_TRIGGER,

    // Temporary mappings until the samples are ported over to the new names
    HELP_WHITE_BUTTON   = HELP_LEFT_SHOULDER,
    HELP_BLACK_BUTTON   = HELP_RIGHT_SHOULDER,
    HELP_LEFT_BUTTON    = HELP_BOTTOM_LEFT,
    HELP_RIGHT_BUTTON   = HELP_BOTTOM_RIGHT,
    HELP_LEFTSTICK      = HELP_LEFT_STICK,
    HELP_RIGHTSTICK     = HELP_RIGHT_STICK,
    HELP_MISC_CALLOUT   = HELP_BOTTOM_LEFT,
    HELP_MISC_CALLOUT_2 = HELP_BOTTOM_CENTER,
    HELP_MISC_CALLOUT_3 = HELP_BOTTOM_RIGHT,
};


//--------------------------------------------------------------------------------------
// Placement options for each callout, used as an offset into the above list
//--------------------------------------------------------------------------------------
enum
{
    HELP_PLACEMENT_1    = 0,   // Callout has one line of text
    HELP_PLACEMENT_2    = 1    // Callout has two lines of text
};

} // namespace ATG

#endif // ATGHELP_H

```

`XenonDumper/libs/Atg/AtgHttp.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// ATGHttp
//
// Uses XHttp/XAuth to manage HTTP(s) connections and XSTS tokens 
// 
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------


#include "stdafx.h"

#include "AtgHttp.h"
#include "AtgUtil.h"

#define PROXY_TYPE XHTTP_ACCESS_TYPE_DEFAULT_PROXY

// shared token if requested during init
PRELYING_PARTY_TOKEN g_pSharedToken = NULL;

// the auth manager can cache a single token currently, alternatively each endpoint will get its own token
BOOL g_useSharedToken = FALSE;


namespace ATG
{
namespace HTTP
{

CHAR *STATES[] = {
    "Idle",
    "Init",
    "SendingRequest",
    "RequestSent",
    "ReceivingResponse",
    "ResponseHeaderAvailable",
    "ReceivingResponseHeader",
    "ReceivingResponseBody",
    "ResponseDataAvailable",
    "ResponseReceived",
    "Completed",
    "ErrorEncountered",
};

static CONST CHAR * STS_TOKEN_HEADER = "Authorization: XBL2.0 x="; // xboxlive specific header used for RESTful services
static CONST CHAR * STS_TOKEN_HEADER_END = "\r\n";

// NOTE: defaults added to header unless alternative is specifed in the calls
static CONST CHAR * CONTENT_TYPE_HEADER = "Content-Type: application/json\r\n";
static CONST CHAR * CONTRACT_VERSION_HEADER = "x-xbl-contract-version: 1\r\n";


//--------------------------------------------------------------------------------------
// static EngineThread
//
// static routine that simply take a this pointer parameter then calls into the real 
// object's RealEngineThread routine
//--------------------------------------------------------------------------------------
DWORD AuthManager::EngineThread (LPVOID lpThreadParameter)
{
    AuthManager *manager = (AuthManager *) lpThreadParameter;

    if (manager == NULL)
    {
        ATG::FatalError("[XAUTHMANAGER] null manager pointer passed\n");
    }

    return manager->RealEngineThread();
}


//--------------------------------------------------------------------------------------
// RealEngineThread
//
// worker thread for auth manager.  This thread ensures we consistently pump the dowork
// routines.
//--------------------------------------------------------------------------------------
DWORD AuthManager::RealEngineThread()
{
    while (!m_fShutdown)
    {
        Sleep(33); 

        HRESULT hr = DoWork();
        if (hr != S_OK)
        {
            ATG::DebugSpew("[XAUTHMANAGER] DoWork failure: %x\n", hr);
        }
    }
    
    return 0;
}


//--------------------------------------------------------------------------------------
// AuthManager::Startup
//
// initialize the XHTTP and XAuth libraries.
//--------------------------------------------------------------------------------------
HRESULT AuthManager::Startup(CHAR * pszCustomUserAgent, BOOL fBypassSecurity, HANDLE *workerThread, BOOL fSharedToken, DWORD dwUserIndex)
{
    hr = S_OK;
    XAUTH_SETTINGS settings;

    // specify if we are going to use a common token for all endpoints or if each gets its own 
    // NOTE: currently only caching a single token and also only dealing with single player scenarios (one user token)
    g_useSharedToken = fSharedToken;
    m_dwUserIndex = dwUserIndex;

    if (!XHttpStartup(0, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }

    memset(&settings, 0, sizeof(settings));
    settings.SizeOfStruct = sizeof(settings);
    settings.Flags = 0;
    if (fBypassSecurity)
    {
        settings.Flags |= XAUTH_FLAG_BYPASS_SECURITY;
    }

    hr = XAuthStartup(&settings);
    if (FAILED(hr))
    {
        return hr;
    }

    if ( pszCustomUserAgent != NULL )
    {
        m_szUserAgent = pszCustomUserAgent;
    }

    // open up an XHTTP session
    m_hSession = XHttpOpen(m_szUserAgent,
                           PROXY_TYPE,
                           NULL,
                           NULL,
                           XHTTP_FLAG_ASYNC);
    if (m_hSession == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }

    DWORD dwThreadId = 0;
    m_hEngineThread = CreateThread(NULL, 0, EngineThread, this, 0, &dwThreadId);
    *workerThread = m_hEngineThread;

    return hr;
}


//--------------------------------------------------------------------------------------
// AuthManager::Shutdown
//
// call this routine to shutdown the auth manager
//--------------------------------------------------------------------------------------
VOID AuthManager::Shutdown()
{
    // shutdown the main engine pump thread
    if (m_hEngineThread != NULL)
    {
        m_fShutdown = TRUE;
        WaitForSingleObject(m_hEngineThread,INFINITE);
        CloseHandle(m_hEngineThread);
    }
    
    if (m_hSession != NULL)
    {
        XHttpCloseHandle(m_hSession);
        m_hSession = NULL;
    }

    for (DWORD index=0; index < m_vectorEndpoints.size(); index++)
    {
        m_vectorEndpoints[index]->DestroyEndpoint();
        delete m_vectorEndpoints[index]; 
    }

    XAuthShutdown();
    XHttpShutdown();
}


//--------------------------------------------------------------------------------------
// AuthManager::CreateEndpoint
//
//--------------------------------------------------------------------------------------
AuthManager::AuthEndpoint * AuthManager::CreateEndpoint(CONST CHAR * pszUrl, BOOL requireToken)
{
    AuthEndpoint * endpoint = NULL;
    hr = S_OK;

    if (pszUrl == NULL)
    {
        ATG::DebugSpew("[XAUTHMANAGER] CreateEndpoint failure of NULL URL\n");
        return NULL;
    }

    endpoint = AuthEndpoint::CreateEndpoint(); 
    hr = endpoint->InitializeEndpoint(pszUrl, requireToken, m_hSession, m_dwUserIndex);

    if ( hr == S_OK )
    {
        m_vectorEndpoints.push_back(endpoint);
    }
    else
    {
        endpoint->DestroyEndpoint();
        endpoint = NULL;
    }

    return endpoint;
}


//--------------------------------------------------------------------------------------
// AuthManager::RemoveEndpoint
//
// routine removes endpoint from the endpoint vector and destroys it
//--------------------------------------------------------------------------------------
VOID AuthManager::RemoveEndpoint(AuthEndpoint *endpoint)
{
    endpoint->CloseRequest();
        
    // remove endpoint from the worker array
    for (DWORD i=0; i<m_vectorEndpoints.size(); i++) 
    {
        if (m_vectorEndpoints[i] == endpoint)
        {
            m_vectorEndpoints.erase(m_vectorEndpoints.begin() + i);
            endpoint->DestroyEndpoint();

            break;
        }
    }

    delete endpoint;
}


//--------------------------------------------------------------------------------------
// AuthManager::DoWork
//
// This routine ensures that all the related handles are closed for the endpoint
//--------------------------------------------------------------------------------------
HRESULT AuthManager::DoWork()
{
   HRESULT hr = S_OK;

    for (DWORD index=0; index < m_vectorEndpoints.size(); index++)
    {
        if (m_vectorEndpoints[index] != NULL)
        {
            hr = m_vectorEndpoints[index]->DoWork();
            if (hr != S_OK)
            {
                return hr;
            }
        }
    }

    return hr;
}


// AuthEndpoint ROUTINES ///////////////////////////////////////////////////////////////////////////////////////////
AuthManager::AuthEndpoint * AuthManager::AuthEndpoint::CreateEndpoint()
{
    return new AuthEndpoint();
}

BOOL AuthManager::AuthEndpoint::RequestCompleted() CONST
{
    return (m_state == Completed || m_state == ErrorEncountered);
}

VOID AuthManager::AuthEndpoint::MoveStateTo(CONST XAUTHENDPOINT_STATES state)
{
#ifdef DEBUGMODE
    ATG::DebugSpew("[XAUTHMANAGER] state change to: %s\n", STATES[state]); 
#endif
    m_state = state;
}

VOID AuthManager::AuthEndpoint::SetBytesRead(DWORD dwBytesRead)
{
    m_cbBytesRead = dwBytesRead;
}

AuthManager::AuthEndpoint::XAUTHENDPOINT_STATES AuthManager::AuthEndpoint::GetCurrentState() CONST
{
    return m_state;
}

CONST BYTE *AuthManager::AuthEndpoint::GetReadBuffer() CONST
{
    return m_readBuffer;
}

CONST DWORD AuthManager::AuthEndpoint::GetHTTPStatusCode() CONST
{
    return m_dwHttpStatusCode;
}

CONST CHAR *AuthManager::AuthEndpoint::GetETagHeader() CONST     
{
    if(strlen(m_szETag) == 0)
    {
        return NULL;
    }

    return m_szETag;
}


//--------------------------------------------------------------------------------------
// AuthEndpoint::InitializeEndpoint
//
//--------------------------------------------------------------------------------------
HRESULT AuthManager::AuthEndpoint::InitializeEndpoint(CONST CHAR * pszUrl, BOOL requireToken, HINTERNET session, DWORD userIndex)
{
    hr = S_OK;

    if (pszUrl == NULL)
    {
        return E_INVALIDARG;
    }

    // if the URL will need an STS token, we need to query for it and store it until we make the actual request
    if (requireToken && g_pSharedToken == NULL)
    {
        if (m_pToken == NULL)
        {
            hr = XAuthGetToken(
                userIndex, 
                pszUrl,
                strlen(pszUrl),
                &m_pToken,
                NULL);

            if (FAILED(hr))
            {
                ATG::DebugSpew("[XAUTHMANAGER] failed to get a token %x\n", hr); 
                return hr;
            }

            if (g_useSharedToken == TRUE)
            {
                g_pSharedToken = m_pToken;
            }
        }
    }
    else if (requireToken)
    {
        m_pToken = g_pSharedToken;
    }

    // allocate the required endpoint memory here... read and header buffers
    m_readBuffer = (BYTE *) malloc(RECEIVE_BUFFER_SIZE);
    m_szETag = (CHAR *) malloc(MAX_HEADER_LENGTH);
    m_szHeader = (CHAR *) malloc(MAX_HEADER_LENGTH);
    // end allocations.

    m_hSession = session; 

    // initialize request data
    m_pszUrl = pszUrl;
    m_pszVerb = NULL;
    m_pszRequestData = NULL;
    m_requestDataSize = 0;

    memset(m_szHostName, 0, MAX_HOSTNAME_LENGTH);
    memset(m_readBuffer, 0, RECEIVE_BUFFER_SIZE);
    memset(m_szETag, 0, MAX_HEADER_LENGTH);
    memset(m_szHeader, 0, MAX_HEADER_LENGTH);
    memset(&m_urlComp, 0, sizeof(m_urlComp));

    m_urlComp.dwStructSize = sizeof(m_urlComp);
    m_urlComp.lpszHostName = m_szHostName;
    m_urlComp.dwHostNameLength = MAX_HOSTNAME_LENGTH;
    m_urlComp.lpszUrlPath = NULL;
    m_urlComp.dwUrlPathLength = (DWORD) -1;
    
    // crack the URL into url components
    if (!XHttpCrackUrl(m_pszUrl,
                      strlen(m_pszUrl),
                      (ICU_ESCAPE | ICU_DECODE),
                      &m_urlComp))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }

    if (m_urlComp.nScheme == INTERNET_SCHEME_HTTPS)
    {
        m_dwFlags |= XHTTP_FLAG_SECURE;
    }


    return hr;
}


//--------------------------------------------------------------------------------------
// AuthEndpoint::DestroyEndpoint
//
//--------------------------------------------------------------------------------------
VOID AuthManager::AuthEndpoint::DestroyEndpoint()
{
    if (m_readBuffer != NULL)
    {
        free(m_readBuffer);
    }

    if (m_szETag != NULL)
    {
        free(m_szETag);
    }

    if (m_szHeader != NULL)
    {
        free(m_szHeader);
    }

    if (m_pToken != NULL && g_useSharedToken == FALSE)
    {
        XAuthFreeToken(m_pToken);
    }
}


//--------------------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------------------
HRESULT AuthManager::AuthEndpoint::MakeSyncRequest(CONST CHAR *pszVerb, CONST CHAR *pszContentHeader, CONST CHAR *pszData, DWORD cbSize)
{
    HRESULT hr = OpenRequest(pszVerb, pszContentHeader, pszData, cbSize);

    while (!RequestCompleted())
    {
        // Here we are polling the endpoint waiting for the request to be completed
        Sleep(33);
    }

#ifdef DEBUGMODE
    ATG::DebugSpew("[XAUTHMANAGER] HTTP response %d\n",GetHTTPStatusCode());
    ATG::DebugSpew("[XAUTHMANAGER] %s\n", GetReadBuffer());
#endif

    return hr;
}


//--------------------------------------------------------------------------------------
// AuthEndpoint::OpenRequest
//
// this routine establishes an endpoint request for a URL
//
// If there is custom data to add to the GET/PUT/POST/DELETE/... request you can 
// pass it in here as well.  
//--------------------------------------------------------------------------------------
HRESULT AuthManager::AuthEndpoint::OpenRequest(CONST CHAR *pszVerb, CONST CHAR *pszContentHeader, CONST CHAR *pszData, DWORD cbSize)
{
    hr = S_OK;

    if (pszVerb == NULL)
    {
        return E_INVALIDARG;
    }

    if (m_state != Idle)
    {
        DebugSpew("[XAUTHMANAGER] failed to open request\n");
        return E_UNEXPECTED; 
    }

    m_pszVerb = pszVerb;
    m_pszRequestData = pszData;
    m_requestDataSize = cbSize;

    // connect to the hostname/port for the session object
    m_hConnect = XHttpConnect(m_hSession,
                              m_urlComp.lpszHostName,
                              m_urlComp.nPort,
                              m_dwFlags);
    if (m_hConnect == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }

    // open the actual request and specify the action verb and url path
    // however the final request will not be submitted until XhttpSendRequest occurs
    m_hRequest = XHttpOpenRequest(m_hConnect,
                                  m_pszVerb, 
                                  m_urlComp.lpszUrlPath,
                                  NULL,
                                  NULL,
                                  NULL,
                                  0);
    if (m_hRequest == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }

    // specify the callback routine to be used by XHTTP
    XHttpSetStatusCallback(m_hRequest,
                           StatusCallback,
                           XHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS,
                           NULL);

    // set the custom header if specified
    m_szContentTypeHeader = pszContentHeader;

    // put the auth manager state machine in the "Init" state
    MoveStateTo(Init);
    
    return hr;
}


//--------------------------------------------------------------------------------------
// AuthEndpoint::CloseRequest
//
// This routine ensures that all the related handles are closed for the endpoint
//--------------------------------------------------------------------------------------
VOID AuthManager::AuthEndpoint::CloseRequest()
{
    if (m_hRequest != NULL)
    {
        XHttpCloseHandle(m_hRequest);
        m_hRequest = NULL;
    }

    if (m_hConnect != NULL)
    {
        XHttpCloseHandle(m_hConnect);
        m_hConnect = NULL;
    }

    m_state = Idle;
    m_readBuffer[0] = 0;
    m_szETag[0] = 0;
}


//--------------------------------------------------------------------------------------
// AuthEndpoint::DoWork
//
// routine houses the core processing state machine for the endpoint request
// this routine also is used to do the DoWork pumping for XHTTP
//
// we need the statemachine below due to the asyncronous nature of XHTTP calls
// and coordinating with the XHTTP callback.
//--------------------------------------------------------------------------------------
HRESULT AuthManager::AuthEndpoint::DoWork()
{
    HRESULT hr = S_OK;
    
    switch(m_state)
    {
        case Idle:
        {
            // not expected to do anything
        }
        break;
        
        case Init:
        {
            CHAR * pszHeader = NULL;
            DWORD cbHeader = 0;
            CHAR * pszCur = m_szHeader;

            m_szHeader[0] = 0; 

            if (m_pToken != NULL) // use a token
            {
                strcat_s(pszCur, MAX_HEADER_LENGTH, STS_TOKEN_HEADER);
                strcat_s(pszCur, MAX_HEADER_LENGTH, (CONST CHAR *)m_pToken->pToken);
                strcat_s(pszCur, MAX_HEADER_LENGTH, STS_TOKEN_HEADER_END);

                if ( m_szContentTypeHeader != NULL )
                {
                    strcat_s(pszCur, MAX_HEADER_LENGTH, m_szContentTypeHeader);
                }
                else
                {
                    strcat_s(pszCur, MAX_HEADER_LENGTH, CONTENT_TYPE_HEADER);
                    strcat_s(pszCur, MAX_HEADER_LENGTH, CONTRACT_VERSION_HEADER); 
                }

                cbHeader = strlen(pszCur); 
                pszHeader = m_szHeader;
            }
            else 
            {
                if ( m_szContentTypeHeader != NULL )
                {
                    strcat_s(pszCur, MAX_HEADER_LENGTH, m_szContentTypeHeader);
                }
                else
                {
                    strcat_s(pszCur, MAX_HEADER_LENGTH, CONTENT_TYPE_HEADER);
                    strcat_s(pszCur, MAX_HEADER_LENGTH, CONTRACT_VERSION_HEADER); 
                }

                cbHeader = strlen(pszCur); 
                pszHeader = m_szHeader;
            }

            // here we pass the header and the initial custom request data
            // NOTE: totalsize will always be custom data size due to keeping the class simple and keeping the request as a single call
            if (XHttpSendRequest(m_hRequest,
                pszHeader,
                cbHeader,
                m_pszRequestData, 
                m_requestDataSize, 
                m_requestDataSize, 
                (DWORD_PTR)this))
            {
                MoveStateTo(SendingRequest);
            }
            else
            {
                DebugSpew("[XAUTHMANAGER] Cannot send request!\n");
                MoveStateTo(ErrorEncountered);
            }
        } 
        break;

        case SendingRequest:
        {
            // statemachine will be updated in the callback
        }
        break;

        case RequestSent:
        {
            if (XHttpReceiveResponse(m_hRequest, NULL))
            {
                MoveStateTo(ReceivingResponseHeader);
            }
            else
            {
                DebugSpew("[XAUTHMANAGER] Cannot receive response!\n");
                MoveStateTo(ErrorEncountered);
            }
        }
        break;

        case ReceivingResponse:
        {
            // statemachine will be updated in the callback
        }
        break;

        case ReceivingResponseHeader:
        {
            // statemachine will be updated in the callback, expected move: ReponseHeaderAvailable
        }
        break;
                                         
        case ResponseHeaderAvailable:
        {
            hr = GetResponseETagHeader(m_hRequest, m_szETag);
            if(hr != HRESULT_FROM_WIN32(ERROR_XHTTP_HEADER_NOT_FOUND) && FAILED(hr))
            {
                 DebugSpew("[XAUTHMANAGER] GetResponseETagHEader failed! hr=0x%x!\n", hr);
                 MoveStateTo(ErrorEncountered);
            }

            hr = GetResponseStatusCode(m_hRequest, &m_dwHttpStatusCode);
            if (FAILED(hr))
            {
                DebugSpew("[XAUTHMANAGER] GetResponseStatusCode failed! hr=0x%x!\n", hr);
                MoveStateTo(ErrorEncountered);
            }
            else if (m_dwHttpStatusCode >= HTTP_STATUS_BAD_REQUEST)
            {
                DebugSpew("[XAUTHMANAGER] Server returned error status code %d!\n", m_dwHttpStatusCode);
                MoveStateTo(ErrorEncountered);
            }
            else // NOTE: if we get a 403/404 we do still have data that maybe helpful
            {
                hr = GetResponseContentLength(m_hRequest, &m_dwContentLength);
                if (FAILED(hr))
                {
                    DebugSpew("[XAUTHMANAGER] GetResponseContentLength failed hr=0x%x!\n", hr);
                    MoveStateTo(ErrorEncountered);
                }
                else if (m_dwContentLength > 0)
                {
#ifdef DEBUGMODE
                    DebugSpew("[XAUTHMANAGER] GetResponseContentLength size =%d!\n", m_dwContentLength);
#endif
                    m_dwContentLengthRemaining = m_dwContentLength;
                    MoveStateTo(ReceivingResponseBody);
                }
                else
                {
                    MoveStateTo(ResponseReceived);
                }
            }
        }
        break;

        case ReceivingResponseBody:
        {
            MoveStateTo(ReceivingResponse);
            m_cbBytesToRead = (m_dwContentLengthRemaining < RECEIVE_BUFFER_SIZE) ? m_dwContentLengthRemaining : RECEIVE_BUFFER_SIZE;
#ifdef DEBUGMODE
            DebugSpew("[XAUTHMANAGER] bytes to read %d\n", m_cbBytesToRead);
#endif
            if (m_cbBytesToRead == 0)
            {
                MoveStateTo(ResponseReceived);
            }
            else if (!XHttpReadData(m_hRequest,
                                    m_readBuffer,
                                    m_cbBytesToRead,
                                    NULL))
            {
                DebugSpew("[XAUTHMANAGER] failed to read repsonse body!\n");
                MoveStateTo(ErrorEncountered);
            }
        }
        break;

        case ResponseDataAvailable:
        {
            m_dwContentLengthRemaining -= m_cbBytesRead;
            DebugSpew("buffer: %s\n", m_readBuffer);
            MoveStateTo(ReceivingResponseBody);
        }
        break;

        case ResponseReceived:
        {
            MoveStateTo(Completed);
        }
        break;

        case ErrorEncountered: __fallthrough
        case Completed:
        {
            // final state
            return HRESULT_FROM_WIN32(m_hAsyncResult.dwError);
        }
        break;

        default:
        {
            FatalError("[XAUTHMANAGER] invalid state\n");
        }
        break;
    }

    assert(m_hSession != NULL);

    if (!XHttpDoWork(m_hSession, 0))
    {
        MoveStateTo(ErrorEncountered);
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


//--------------------------------------------------------------------------------------
// AuthEndpoint::StatusCallback
//
// routine is the sole callback for XHTTP and is called during DoWork pumps.
// this routine is used to change the core state of the processing state machine
// based on the XHTTP_CALLBACK_STATUS recieved
//--------------------------------------------------------------------------------------
VOID CALLBACK AuthManager::AuthEndpoint::StatusCallback(HINTERNET hInternet,
                                                        DWORD_PTR dwpContext,
                                                        DWORD dwInternetStatus,
                                                        LPVOID lpvStatusInformation,
                                                        DWORD dwStatusInformationSize)
{
    AuthEndpoint * pxas = (AuthEndpoint *) dwpContext; 
    assert(pxas != NULL);
    
    switch (dwInternetStatus)
    {
        case XHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE:
        {
            pxas->MoveStateTo(RequestSent);
        }
        break;

        case XHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE:
        {
            assert(pxas->GetCurrentState() == ReceivingResponseHeader);
            pxas->MoveStateTo(ResponseHeaderAvailable);
        }
        break;

        case XHTTP_CALLBACK_STATUS_READ_COMPLETE:
        {
            pxas->SetBytesRead(dwStatusInformationSize);
#ifdef DEBUGMODE
            ATG::DebugSpew("[XAUTHMANAGER] read complete with sizeof: %d\n", dwStatusInformationSize); 
#endif
            pxas->MoveStateTo(ResponseDataAvailable);
        }
        break;

        case XHTTP_CALLBACK_STATUS_REQUEST_ERROR:
        {
            memcpy_s( &pxas->m_hAsyncResult, sizeof(XHTTP_ASYNC_RESULT), (XHTTP_ASYNC_RESULT*) lpvStatusInformation, sizeof(XHTTP_ASYNC_RESULT) );

            DebugSpew("[XAUTHMANAGER] encountered request error %x!\n", pxas->m_hAsyncResult.dwError);
            pxas->MoveStateTo(ErrorEncountered);
        }
        break;

        case XHTTP_CALLBACK_STATUS_WRITE_COMPLETE: __fallthrough 
        case XHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE: 
        {
            // do nothing
            DebugSpew("[XAUTHMANAGER] Unsupported state!\n");
            pxas->MoveStateTo(ErrorEncountered);
        }
        break;
        
        case XHTTP_CALLBACK_STATUS_REDIRECT: __fallthrough
        case XHTTP_CALLBACK_STATUS_HANDLE_CLOSING:
        {
            // do nothing
        }
        break;
        
        default:
        {
            FatalError("[XAUTHMANAGER] invalid state\n");
        }
    }
}


//--------------------------------------------------------------------------------------
// AuthEndpoint::GetResponseStatusCode
//
// call AuthManager::GetResponseHeader to retrieve the HTTP status code 
//--------------------------------------------------------------------------------------
HRESULT AuthManager::AuthEndpoint::GetResponseStatusCode(
    HINTERNET hRequest,
    DWORD * pdwStatusCode
)
{
    hr = S_OK;
    DWORD dwBufferLength = sizeof(DWORD);
    
    assert(pdwStatusCode != NULL);
    hr = GetResponseHeader(hRequest,
                           (XHTTP_QUERY_STATUS_CODE | XHTTP_QUERY_FLAG_NUMBER),
                           XHTTP_HEADER_NAME_BY_INDEX,
                           pdwStatusCode,
                           &dwBufferLength);
    
    return hr;
}

//--------------------------------------------------------------------------------------
// AuthEndpoint::GetResponseStatusCode
//
// call AuthManager::GetResponseHeader to retrieve the HTTP ETag header 
//--------------------------------------------------------------------------------------
HRESULT AuthManager::AuthEndpoint::GetResponseETagHeader(
    HINTERNET hRequest,
    CHAR * szETag
)
{
    hr = S_OK;
    DWORD dwBufferLength = MAX_HEADER_LENGTH;

    assert(szETag != NULL);
    hr = GetResponseHeader(hRequest,
                           XHTTP_QUERY_CUSTOM,
                           "ETag",
                           szETag,
                           &dwBufferLength);
    
    return hr;
}


//--------------------------------------------------------------------------------------
// AuthEndpoint::GetLastErrorCode
//
// call AuthManager::GetLastErrorCode to retrieve and clear the last error status code
//--------------------------------------------------------------------------------------
HRESULT AuthManager::AuthEndpoint::GetLastErrorCode()
{
    hr = m_hAsyncResult.dwError;

    return hr;
}


//--------------------------------------------------------------------------------------
// AuthEndpoint::GetResponseContentLength
//
// call AuthManager::GetResponseHeader to retrieve the content length of the response
//--------------------------------------------------------------------------------------
HRESULT AuthManager::AuthEndpoint::GetResponseContentLength(
    HINTERNET hRequest,
    DWORD * pdwContentLength
)
{
    hr = S_OK;
    DWORD dwBufferLength = sizeof(DWORD);
    assert(pdwContentLength != NULL);
    hr = GetResponseHeader(hRequest,
                           (XHTTP_QUERY_CONTENT_LENGTH | XHTTP_QUERY_FLAG_NUMBER),
                           XHTTP_HEADER_NAME_BY_INDEX,
                           pdwContentLength,
                           &dwBufferLength);

    return hr;
}


//--------------------------------------------------------------------------------------
// AuthEndpoint::GetResponseHeader
//
// this routine is mainly used for GetResponseStatusCode and GetResponseContentLength
// routine uses XHttpQueryHeaders
//--------------------------------------------------------------------------------------
HRESULT AuthManager::AuthEndpoint::GetResponseHeader(
    HINTERNET hRequest,
    DWORD dwInfoLevel,
    CONST CHAR * pszHeader,
    VOID * pvBuffer,
    DWORD * pdwBufferLength
    )
{
    hr = S_OK;
    
    assert(pdwBufferLength != NULL);

    if (!XHttpQueryHeaders(hRequest,
                           dwInfoLevel,
                           pszHeader,
                           pvBuffer,
                           pdwBufferLength,
                           XHTTP_NO_HEADER_INDEX)) 
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

} // namespace HTTP
} // namespace ATG


```

`XenonDumper/libs/Atg/AtgHttp.h`:

```h
//--------------------------------------------------------------------------------------
// ATGHttp
//
// Uses XHttp/XAuth to manage HTTP(s) connections and XSTS tokens 
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------


#pragma once
#ifndef ATGHTTP_H
#define ATGHTTP_H

#include <xtl.h>
#include <xhttp.h>
#include <xauth.h>
#include <assert.h>
#include <stdio.h>
#include <vector>


namespace ATG
{
namespace HTTP
{

#define MAX_HOSTNAME_LENGTH 128           // maximum size for the hostname
#define MAX_HEADER_LENGTH   16384         // maximum token size expected
#define MAX_URL_LENGTH      1024          // each endpoint URL size max as specified by the NSAL
#define RECEIVE_BUFFER_SIZE 16384         // buffer size for reading HTTP data

#define ATGHTTP_DEFAULT_USER_AGENT "ATGHTTP_XBOX360"  // default user agent string


//--------------------------------------------------------------------------------------
// class AuthManager
//
// This class handles XHTTP and XAuth code usage for the samples.
// We want to deal with the endpoints at a higher level of abstraction.
// AuthManager manages XHTTP/XAuth endpoint requests and responses as well as token usage
//--------------------------------------------------------------------------------------
class AuthManager
{
public:
    class AuthEndpoint; // TODO: make private and manage internally

    AuthManager()
    {
        m_hSession = NULL;
        m_hEngineThread = NULL;
        m_fShutdown = FALSE;
        m_szUserAgent = ATGHTTP_DEFAULT_USER_AGENT;
    }

    ~AuthManager()
    {
    }

    HRESULT Startup(CHAR * pszCustomUserAgent, BOOL fBypassSecurity, HANDLE *workerThread, BOOL fSharedToken, DWORD dwUserIndex);
    VOID Shutdown();

    AuthEndpoint * CreateEndpoint(CONST CHAR * pszUrl, BOOL requireToken);
    VOID RemoveEndpoint(AuthEndpoint *endpoint);

    HRESULT DoWork();
    static DWORD __stdcall EngineThread(LPVOID lpThreadParameter);
    DWORD RealEngineThread();


private:
    // endpoints vector
    std::vector<AuthEndpoint *> m_vectorEndpoints; 

    // user agent string
    CONST CHAR *m_szUserAgent;

    // main XHTTP session handle
    HINTERNET m_hSession;

    // auth engine thread
    HANDLE m_hEngineThread;

    // application shutdown
    BOOL m_fShutdown;

    // reused HR
    HRESULT hr;

    // user index used to aquire the token (NOTE: currently only handling single player scenarios)
    DWORD m_dwUserIndex;
};



//--------------------------------------------------------------------------------------
// class AuthManager::AuthEndpoint
//
//--------------------------------------------------------------------------------------
class AuthManager::AuthEndpoint
{

public:

    // states for the authendpoint state machine
    enum XAUTHENDPOINT_STATES
    {
        Idle,
        Init,
        SendingRequest,
        RequestSent,
        ReceivingResponse,
        ResponseHeaderAvailable,
        ReceivingResponseHeader,
        ReceivingResponseBody,
        ResponseDataAvailable,
        ResponseReceived,
        Completed,
        ErrorEncountered,
    };


    AuthEndpoint()
    {
        m_state = Idle;

        m_pToken = NULL;
        m_readBuffer = NULL;
        m_szETag = NULL;
        m_szContentTypeHeader = NULL;
        m_szHeader = NULL;

        m_pszUrl = NULL;
        m_pszVerb = NULL;
        m_pszRequestData = NULL;
        m_requestDataSize = 0;

        m_cbBytesRead = 0;
        m_cbBytesToRead = 0;

        m_dwHttpStatusCode = 0;
        m_dwContentLength = 0;
        m_dwContentLengthRemaining = 0;
        
        m_hSession = NULL;
        m_hConnect = NULL;
        m_hRequest = NULL;

        m_hAsyncResult.dwError = S_OK;

        m_dwFlags = 0;
    }

    ~AuthEndpoint()
    {
    }

    static AuthEndpoint * CreateEndpoint();
    HRESULT InitializeEndpoint(CONST CHAR * pszUrl, BOOL requireToken, HINTERNET session, DWORD userIndex);
    VOID DestroyEndpoint();
    HRESULT MakeSyncRequest(CONST CHAR *pszVerb, CONST CHAR *pszContentHeader, CONST CHAR *pszData, DWORD cbSize);
    HRESULT OpenRequest(CONST CHAR *pszVerb, CONST CHAR *pszContentHeader, CONST CHAR *pszData, DWORD cbSize);
    VOID CloseRequest();
    BOOL RequestCompleted() CONST;
    HRESULT DoWork();
    CONST BYTE *GetReadBuffer() CONST;
    CONST CHAR *GetETagHeader() CONST;   
    CONST DWORD GetHTTPStatusCode() CONST;
    
    HRESULT GetLastErrorCode(); 

    HRESULT hr;
    XHTTP_ASYNC_RESULT m_hAsyncResult;

private:

    XAUTHENDPOINT_STATES GetCurrentState() CONST;
    VOID MoveStateTo(CONST XAUTHENDPOINT_STATES state);
    VOID SetBytesRead(DWORD dwBytesRead);

    static VOID CALLBACK StatusCallback(HINTERNET hInternet,
                                        DWORD_PTR dwpContext,
                                        DWORD dwInternetStatus,
                                        LPVOID lpvStatusInformation,
                                        DWORD dwStatusInformationSize);
    HRESULT GetResponseStatusCode(HINTERNET hRequest,
                                  DWORD * pdwStatusCode);
    HRESULT GetResponseETagHeader(HINTERNET hRequest,
                                  CHAR * szETag);
    HRESULT GetResponseContentLength(HINTERNET hRequest,
                                     DWORD * pdwContentLength);
    HRESULT GetResponseHeader(HINTERNET hRequest,
                              DWORD dwInfoLevel,
                              CONST CHAR * pszHeader,
                              VOID * pvBuffer,
                              DWORD * pdwBufferLength);
    
    
    CONST CHAR * m_pszUrl;      // endpoint URL
    
    CHAR m_szHostName[MAX_HOSTNAME_LENGTH];
    BYTE *m_readBuffer;         // read buffer used for HTTP reading
    CHAR *m_szETag;             // buffer for ETag
    CONST CHAR *m_szContentTypeHeader;// custom header to replace default "Content-Type" header
    CHAR *m_szHeader;           // request header (this generally contains the STS token, and additional header info like "Content-Type")
    PRELYING_PARTY_TOKEN m_pToken;
    
    CONST CHAR *m_pszVerb;            // GET, PUT, POST, DELETE
    CONST CHAR *m_pszRequestData;     // custom data to go with your verb
    DWORD m_requestDataSize;          // size of custom data

    DWORD m_cbBytesRead;        // member variable used to track how many bytes last read
    URL_COMPONENTS m_urlComp;   // XHttpCrackUrl populates the url components
    DWORD m_dwFlags; 

    DWORD m_dwHttpStatusCode;
    DWORD m_dwContentLength;
    DWORD m_dwContentLengthRemaining;
    DWORD m_cbBytesToRead;

    XAUTHENDPOINT_STATES m_state; 

    // HINTERNET handles
    HINTERNET m_hSession;
    HINTERNET m_hConnect;
    HINTERNET m_hRequest;
};


} // namespace HTTP
} // namespace ATG

#endif // ATGAUTH_H

```

`XenonDumper/libs/Atg/AtgInput.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// AtgInput.cpp
//
// Input helper functions for samples
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#include "stdafx.h"
#include <xbdm.h>
#include "AtgInput.h"

namespace ATG
{

//--------------------------------------------------------------------------------------
// Globals
//--------------------------------------------------------------------------------------

// Instance of static member variables
GAMEPAD   Input::m_Gamepads[4];
GAMEPAD   Input::m_DefaultGamepad;

// Deadzone pseudo-constants for the thumbsticks
SHORT GAMEPAD::LEFT_THUMB_DEADZONE  = XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE;
SHORT GAMEPAD::RIGHT_THUMB_DEADZONE = XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE;


//--------------------------------------------------------------------------------------
// Name: ConvertThumbstickValue()
// Desc: Converts SHORT thumbstick values to FLOAT, while enforcing a deadzone
//--------------------------------------------------------------------------------------
inline FLOAT ConvertThumbstickValue( SHORT sThumbstickValue, SHORT sDeadZone )
{
    if( sThumbstickValue > +sDeadZone )
    {
        return (sThumbstickValue-sDeadZone) / (32767.0f-sDeadZone);
    }
    if( sThumbstickValue < -sDeadZone )
    {
        return (sThumbstickValue+sDeadZone+1.0f) / (32767.0f-sDeadZone);
    }
    return 0.0f;
}


//--------------------------------------------------------------------------------------
// Name: GetInput()
// Desc: Processes input from the gamepads
//--------------------------------------------------------------------------------------
VOID Input::GetInput( GAMEPAD* pGamepads )
{
    // Initial the static data structures
    static BOOL bInitialized = FALSE;
    if( FALSE == bInitialized )
    {
        ZeroMemory( m_Gamepads,        sizeof(m_Gamepads) );
        ZeroMemory( &m_DefaultGamepad, sizeof(m_DefaultGamepad) );
        bInitialized = TRUE;
    }

    // If the user did not specify a list of gamepads, use the global list
    if( NULL == pGamepads )
        pGamepads = m_Gamepads;

    // Loop through all gamepads
    for( DWORD i=0; i < XUSER_MAX_COUNT; i++ )
    {
        // Read the input state
        XINPUT_STATE InputState;
        BOOL bWasConnected = pGamepads[i].bConnected;
        pGamepads[i].bConnected = ( XInputGetState( i, &InputState ) == ERROR_SUCCESS ) ? TRUE : FALSE;

        // Track insertion and removals
        pGamepads[i].bRemoved  = (  bWasConnected && !pGamepads[i].bConnected ) ? TRUE : FALSE;
        pGamepads[i].bInserted = ( !bWasConnected &&  pGamepads[i].bConnected ) ? TRUE : FALSE;

        if( FALSE == pGamepads[i].bConnected )
            continue;

        // Store the capabilities of the device
        if( TRUE == pGamepads[i].bInserted )
        {
            ZeroMemory( &pGamepads[i], sizeof(m_Gamepads[i]) );
            pGamepads[i].bConnected = TRUE;
            pGamepads[i].bInserted  = TRUE;
            XInputGetCapabilities( i, XINPUT_FLAG_GAMEPAD, &pGamepads[i].caps );
        }

        // Copy gamepad to local structure
        memcpy( &pGamepads[i], &InputState.Gamepad, sizeof(XINPUT_GAMEPAD) );

        // Put Xbox device input for the gamepad into our custom format
        pGamepads[i].fX1 = ConvertThumbstickValue( pGamepads[i].sThumbLX, GAMEPAD::LEFT_THUMB_DEADZONE );
        pGamepads[i].fY1 = ConvertThumbstickValue( pGamepads[i].sThumbLY, GAMEPAD::LEFT_THUMB_DEADZONE );
        pGamepads[i].fX2 = ConvertThumbstickValue( pGamepads[i].sThumbRX, GAMEPAD::RIGHT_THUMB_DEADZONE );
        pGamepads[i].fY2 = ConvertThumbstickValue( pGamepads[i].sThumbRY, GAMEPAD::RIGHT_THUMB_DEADZONE );

        // Get the boolean buttons that have been pressed since the last
        // call. Each button is represented by one bit.
        pGamepads[i].wPressedButtons = ( pGamepads[i].wLastButtons ^ pGamepads[i].wButtons ) & pGamepads[i].wButtons;
        pGamepads[i].wLastButtons    = pGamepads[i].wButtons;

        // Figure out if the left trigger has been pressed or released
        BOOL bPressed = ( pGamepads[i].bLeftTrigger > XINPUT_GAMEPAD_TRIGGER_THRESHOLD );

        if( bPressed )
            pGamepads[i].bPressedLeftTrigger = !pGamepads[i].bLastLeftTrigger;
        else
            pGamepads[i].bPressedLeftTrigger = FALSE;

        // Store the state for next time
        pGamepads[i].bLastLeftTrigger = bPressed;

        // Figure out if the right trigger has been pressed or released
        bPressed = ( pGamepads[i].bRightTrigger > XINPUT_GAMEPAD_TRIGGER_THRESHOLD );

        if( bPressed )
            pGamepads[i].bPressedRightTrigger = !pGamepads[i].bLastRightTrigger;
        else
            pGamepads[i].bPressedRightTrigger = FALSE;

        // Store the state for next time
        pGamepads[i].bLastRightTrigger = bPressed;

        // Set the user index for this gamepad
        pGamepads[i].dwUserIndex = i;
    }
}


//--------------------------------------------------------------------------------------
// Name: ClampToShort()
// Desc: Takes an integer input and clamps it to fit in a short, to avoid wrapping.
//--------------------------------------------------------------------------------------
SHORT ClampToShort(INT input)
{
    // Use min/max from windef.h. Define NOMINMAX if you don't want these
    // macros defined.
    input = min(input, SHRT_MAX);
    input = max(input, SHRT_MIN);
    return (SHORT)input;
}


//--------------------------------------------------------------------------------------
// Name: GetMergedInput()
// Desc: Processes input from all gamepads and merge it into one input. This is done for
//       expediency in samples and is not typically useful or advised for games.
//       If the pdwActiveGamePadsMask is non-NULL, then returns active gamepads.
//       
//--------------------------------------------------------------------------------------
GAMEPAD* Input::GetMergedInput( DWORD dwMask, DWORD* pdwActiveGamePadsMask )
{
    // Get input for ALL the gamepads
    GetInput();

    // Sum input across ALL gamepads into one default structure.
    ZeroMemory( &m_DefaultGamepad, sizeof(m_DefaultGamepad) );
    INT  iThumbLX = 0;
    INT  iThumbLY = 0;
    INT  iThumbRX = 0;
    INT  iThumbRY = 0;
    BOOL bActiveThumbs[XUSER_MAX_COUNT]  = { 0 };
    BOOL bActiveButtons[XUSER_MAX_COUNT] = { 0 };

    for( DWORD i=0; i < XUSER_MAX_COUNT; i++ )
    {
        if( m_Gamepads[i].bConnected && ( !dwMask || ( dwMask & ( 1 << i ) ) ) )
        {
            SHORT sThumbLX = 0;
            SHORT sThumbLY = 0;
            SHORT sThumbRX = 0;
            SHORT sThumbRY = 0;

            // Only account for thumbstick info beyond the deadzone
            // Note that this is a simplification of the deadzone. The dead
            // zone is when the thumb stick is at or near its 'home' position.
            // If the thumb stick is pushed all the way to the left then, even
            // though the y-coordinates are still in the dead-zone range, they
            // are actually considered significant. This dead-zone ignoring
            // code will ignore the y-coordinate in a horizontal block all the
            // way across, and will ignore the x-coordinate in a vertical block
            // all the way up/down. This simplification lets us normalize the
            // coordinates into a simple +-1.0 range, but for delicate control
            // (subtle steering when pushing forward) this technique will not
            // be sufficient.
            if( m_Gamepads[i].sThumbLX > GAMEPAD::LEFT_THUMB_DEADZONE ||
                m_Gamepads[i].sThumbLX < -GAMEPAD::LEFT_THUMB_DEADZONE )
                sThumbLX = m_Gamepads[i].sThumbLX;
            if( m_Gamepads[i].sThumbLY > GAMEPAD::LEFT_THUMB_DEADZONE ||
                m_Gamepads[i].sThumbLY < -GAMEPAD::LEFT_THUMB_DEADZONE )
                sThumbLY = m_Gamepads[i].sThumbLY;
            if( m_Gamepads[i].sThumbRX > GAMEPAD::RIGHT_THUMB_DEADZONE ||
                m_Gamepads[i].sThumbRX < -GAMEPAD::RIGHT_THUMB_DEADZONE )
                sThumbRX = m_Gamepads[i].sThumbRX;
            if( m_Gamepads[i].sThumbRY > GAMEPAD::RIGHT_THUMB_DEADZONE ||
                m_Gamepads[i].sThumbRY < -GAMEPAD::RIGHT_THUMB_DEADZONE )
                sThumbRY = m_Gamepads[i].sThumbRY;

            // Sum up the raw thumbstick inputs, as long as the thumbstick
            // is outside of the dead-zone. This is different from the
            // summing above where the x and y values are accepted or
            // discarded separately.
            if( m_Gamepads[i].sThumbRX > GAMEPAD::RIGHT_THUMB_DEADZONE ||
                m_Gamepads[i].sThumbRX < -GAMEPAD::RIGHT_THUMB_DEADZONE ||
                m_Gamepads[i].sThumbRY > GAMEPAD::RIGHT_THUMB_DEADZONE ||
                m_Gamepads[i].sThumbRY < -GAMEPAD::RIGHT_THUMB_DEADZONE )
            {
                iThumbRX += m_Gamepads[i].sThumbRX;
                iThumbRY += m_Gamepads[i].sThumbRY;
            }

            if( m_Gamepads[i].sThumbLX > GAMEPAD::LEFT_THUMB_DEADZONE ||
                m_Gamepads[i].sThumbLX < -GAMEPAD::LEFT_THUMB_DEADZONE ||
                m_Gamepads[i].sThumbLY > GAMEPAD::LEFT_THUMB_DEADZONE ||
                m_Gamepads[i].sThumbLY < -GAMEPAD::LEFT_THUMB_DEADZONE )
            {
                iThumbLX += m_Gamepads[i].sThumbLX;
                iThumbLY += m_Gamepads[i].sThumbLY;
            }

            // Keep track of which gamepads are active
            if( sThumbLX!=0 || sThumbLY!=0 || sThumbRX!=0 || sThumbRY!=0 )
                bActiveThumbs[i] = TRUE;

            m_DefaultGamepad.fX1 += m_Gamepads[i].fX1;
            m_DefaultGamepad.fY1 += m_Gamepads[i].fY1;
            m_DefaultGamepad.fX2 += m_Gamepads[i].fX2;
            m_DefaultGamepad.fY2 += m_Gamepads[i].fY2;

            m_DefaultGamepad.wButtons        |= m_Gamepads[i].wButtons;
            m_DefaultGamepad.wPressedButtons |= m_Gamepads[i].wPressedButtons;
            m_DefaultGamepad.wLastButtons    |= m_Gamepads[i].wLastButtons;

            if( m_Gamepads[i].wButtons != m_Gamepads[i].wLastButtons )
                bActiveButtons[i] = TRUE;

            for( DWORD b=0; b<8; b++ )
            {
                m_DefaultGamepad.bLeftTrigger         |= m_Gamepads[i].bLeftTrigger;
                m_DefaultGamepad.bPressedLeftTrigger  |= m_Gamepads[i].bPressedLeftTrigger;
                m_DefaultGamepad.bLastLeftTrigger     |= m_Gamepads[i].bLastLeftTrigger;

                m_DefaultGamepad.bRightTrigger        |= m_Gamepads[i].bRightTrigger;
                m_DefaultGamepad.bPressedRightTrigger |= m_Gamepads[i].bPressedRightTrigger;
                m_DefaultGamepad.bLastRightTrigger    |= m_Gamepads[i].bLastRightTrigger;

                if( m_Gamepads[i].bLeftTrigger != m_Gamepads[i].bLastLeftTrigger )
                    bActiveButtons[i] = TRUE;
                if( m_Gamepads[i].bRightTrigger != m_Gamepads[i].bLastRightTrigger )
                    bActiveButtons[i] = TRUE;
            }
        }
    }

    // Clamp summed thumbstick values to proper range
    m_DefaultGamepad.sThumbLX = ClampToShort(iThumbLX);
    m_DefaultGamepad.sThumbLY = ClampToShort(iThumbLY);
    m_DefaultGamepad.sThumbRX = ClampToShort(iThumbRX);
    m_DefaultGamepad.sThumbRY = ClampToShort(iThumbRY);

    // Fill pActiveGamePadsMask
    if ( pdwActiveGamePadsMask != NULL )
    {
        DWORD dwActiveGamePadsMask = 0;
        for( DWORD i=0; i<XUSER_MAX_COUNT; i++ )
        {
            if( bActiveButtons[i] || bActiveThumbs[i] || m_Gamepads[i].wPressedButtons )
            {
                dwActiveGamePadsMask |= 1 << i;
            }
        }

        *pdwActiveGamePadsMask = dwActiveGamePadsMask;
    }

    // Assign an active gamepad
    for( DWORD i=0; i<XUSER_MAX_COUNT; i++ )
    {
        if( bActiveButtons[i] )
        {
            m_DefaultGamepad.dwUserIndex = i;
            break;
        }

        if( bActiveThumbs[i] )
        {
            m_DefaultGamepad.dwUserIndex = i;
            break;
        }
    }

    // Handle a convenient reboot sequence for all samples
    if( ( m_DefaultGamepad.bLeftTrigger  > 128 ) &&
        ( m_DefaultGamepad.bRightTrigger > 128 ) &&
        ( m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_RIGHT_SHOULDER ) )
    {
        // Reboot the dev kit
        XLaunchNewImage( "", 0 );
    }

    return &m_DefaultGamepad;
}

} // namespace ATG

```

`XenonDumper/libs/Atg/AtgInput.h`:

```h
//--------------------------------------------------------------------------------------
// AtgInput.h
//
// Input helper functions for samples
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#pragma once
#ifndef ATGINPUT_H
#define ATGINPUT_H

namespace ATG
{

//--------------------------------------------------------------------------------------
// Name: struct ATGGAMEPAD
// Desc: Structure for holding Gamepad data
//--------------------------------------------------------------------------------------
struct GAMEPAD : public XINPUT_GAMEPAD
{
    // The following members are inherited from XINPUT_GAMEPAD:
    //    WORD    wButtons;
    //    BYTE    bLeftTrigger;
    //    BYTE    bRightTrigger;
    //    SHORT   sThumbLX;
    //    SHORT   sThumbLY;
    //    SHORT   sThumbRX;
    //    SHORT   sThumbRY;

    // Thumb stick values converted to range [-1,+1]
    FLOAT      fX1;
    FLOAT      fY1;
    FLOAT      fX2;
    FLOAT      fY2;

    // Records the state (when last updated) of the buttons.
    // These remain set as long as the button is pressed.
    WORD       wLastButtons;
    BOOL       bLastLeftTrigger;
    BOOL       bLastRightTrigger;

    // Records which buttons were pressed this frame - only set on
    // the frame that the button is first pressed.
    WORD       wPressedButtons;
    BOOL       bPressedLeftTrigger;
    BOOL       bPressedRightTrigger;

    // Device properties
    XINPUT_CAPABILITIES caps;
    BOOL       bConnected;

    // Flags for whether game pad was just inserted or removed
    BOOL       bInserted;
    BOOL       bRemoved;

    // The user index associated with this gamepad
    DWORD      dwUserIndex;

    // Deadzone pseudo-constants for the thumbsticks
    static SHORT LEFT_THUMB_DEADZONE;
    static SHORT RIGHT_THUMB_DEADZONE;
};


//--------------------------------------------------------------------------------------
// Name: class Input
// Desc: Class to manage input devices
//--------------------------------------------------------------------------------------
class Input
{
public:
    // Global access to input states
    static GAMEPAD   m_Gamepads[4];
    static GAMEPAD   m_DefaultGamepad;

    // Processes input from the game pad
    static VOID GetInput( GAMEPAD* pGamepads = NULL );

    // Processes input from all 4 gamepads and merge it into one input
    static GAMEPAD* GetMergedInput( DWORD dwMask = 0, DWORD* pdwActiveGamePadsMask = NULL );
};

} // namespace ATG

#endif // ATGINPUT_H

```

`XenonDumper/libs/Atg/AtgJson.cpp`:

```cpp



//--------------------------------------------------------------------------------------
// Light Weight JSON object reader based on XJSON
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------


#include "stdafx.h"

#include "AtgJson.h"
#include "AtgUtil.h"

namespace ATG
{
namespace JSON
{

//#define DEBUGMODE
#ifdef DEBUGMODE
#define ENABLE_PANIC // use to enable a "panic" mode for parser
CHAR * JSON_TOKENS[] = {
    "Json_NotStarted",
    "Json_BeginArray",
    "Json_EndArray",
    "Json_BeginObject",
    "Json_EndObject",
    "Json_String",
    "Json_Number",
    "Json_True",
    "Json_False",
    "Json_Null",
    "Json_FieldName",
    "Json_NameSeparator",   // ':' ?
    "Json_ObjectSeparator", // '.' inside an object
    "Json_ValueSeparator"   // ',' inside an array
};
#endif


DWORD g_inObject = 0;      // object counter
DWORD g_inArray = 0;       // array counter
BOOL  g_isSpecial = FALSE; // used for custom objects that are not represented as arrays in JSON


//--------------------------------------------------------------------------------------
// AtgJsonReader::ParseJSON
//
// recursive parse function for JSON objects.  (objects can contain objects)
// generic json parser that de-serializes the data into the bp based on tag information
//
// while this routine works for the JSON tested with, it has not been stress tested 
// with fuzz data.  XJSON(d).lib has been fuzz tested extensively however.
//--------------------------------------------------------------------------------------
HRESULT AtgJsonReader::ParseJSON(HJSONPARSER &p, VOID *bp, PropertyTag *pt, DWORD size, VOID *parent)
{
    JSONTOKENTYPE token;
    DWORD toklen;
    DWORD parsed;
    WCHAR outbuf[MAXTOKENSIZE];
    HRESULT hr = S_OK;
    
    VOID *poke = NULL; // this is a pointer into the field we want to write data to

    PropertyTag *tag = NULL; // this is the property tag of the class we want to write data to
    
#ifdef ENABLE_PANIC
    DWORD start_time = GetTickCount();
    CONST DWORD panic_time = 2000; //NOTE: if we are taking a few seconds to parse the JSON, something went wrong so we should panic and bail out with error code
#endif


    // walk the stream of tokens looking for a matching fieldname.  
    // With a fieldname and matching tags for the object, we can poke the data into it.
    do
    {
        hr = XJSONReadToken(p, &token, &toklen, &parsed);
        if (hr == JSON_E_OUT_OF_BUFFER)
            break; // legitimately ran out of buffer, we are done

        hr = XJSONGetTokenValue(p, outbuf, MAXTOKENSIZE); 

#ifdef ENABLE_PANIC
        if (GetTickCount() - start_time > panic_time)
        {
            ATG::DebugSpew("[ATGJSON] panic out as we are taking too long");
            break;
        }
#endif

#ifdef DEBUGMODE
        ATG::DebugSpew("[ATGJSON] outbuf: %ws %s %d\n", outbuf, JSON_TOKENS[t], hr);
#endif

        // handle the token type
        switch(token)
        {
        
        case Json_FieldName:
#ifdef DEBUGMODE
            ATG::DebugSpew("[ATGJSON] property field = %ws\n", outbuf);
#endif
            // NOTE: linear walk over tags (results in NxN algorithm)
            for (DWORD i=0; i<size; i++)
            {
                if (wcscmp(pt[i].fieldname, outbuf) == 0)
                {
#ifdef DEBUGMODE
                    ATG::DebugSpew("[ATGJSON] matched\n");
#endif
                    poke = (VOID *) ((int) bp + pt[i].offset);
                    tag = &pt[i];
                    if (tag->dt == DT_ARRAY)
                    {
                        g_isSpecial = true;
                    }
                    else
                    {
                        g_isSpecial = false;
                    }
                    break;
                }
            }
#ifdef DEBUGMODE
            if (poke == NULL)
            {
                ATG::DebugSpew("[ATGJSON] not matched\n"); // NOTE: great point to realize what is missing
            }
#endif
            break;

        case Json_BeginArray:
            g_inArray++;
            g_isSpecial = false;
            
            if (tag == NULL) 
                break; // if we dont have a tag, we cant do anything

            if (tag->dt == DT_ARRAY) 
            {
                parent = poke;
                poke = NULL;
                tag = NULL;
            }
            break;
        
        case Json_EndArray:
            g_inArray--;
#ifdef DEBUGMODE
            ATG::DebugSpew("[ATGJSON] end array\n");
#endif
            break;
        
        case Json_BeginObject:
            g_inObject++;
            if (g_isSpecial) 
            {
                parent = poke;
            }
            if ((g_inArray>0 || g_isSpecial) && parent != NULL)
            {
#ifdef DEBUGMODE
                ATG::DebugSpew("[ATGJSON] new object in array\n");
#endif
                g_isSpecial = FALSE; 
                ICollectionBase *b = (ICollectionBase *) parent;
                ICollectionBase *newobject = (ICollectionBase *) b->GetNewObject();
                poke = NULL;
                tag = NULL;
                
                ParseJSON(p, newobject, (PropertyTag *) b->GetTags(), b->GetTagSize(), parent);
            }
            break;
        
        case Json_EndObject:

            g_inObject--;
            if (g_inArray>0)
                return 0; 
            break;
        
        case Json_String:
        case Json_Number:
            if (poke != NULL)
            {
                assert (tag != NULL);

                switch (tag->dt)
                {
                case DT_STRING:
                    {
                        // sprintf conversion here and change all DT_STRING to CHAR*
                        sprintf_s((CHAR *) poke, tag->stringSize, "%ws", outbuf); 
                        poke = NULL;
                        tag = NULL;
                    }
                    break;

                case DT_INT:
                    {
                        DWORD *d = (DWORD *) poke;
                        DWORD foo = (DWORD) _wtoi64(outbuf); 

                        *d = foo;

                        poke = NULL;
                        tag = NULL;
                    }
                    break;

                case DT_INT64: 
                    {
                        unsigned __int64 *d = (unsigned __int64 *) poke;
                        unsigned __int64 foo = _wtoi64(outbuf); 

                        *d = foo;

                        poke = NULL;
                        tag = NULL;
                    }
                    break;

                default:
                    ATG::DebugSpew("[ATGJSON] unknown DT_TYPE passed\n");
                } // end switch on tag->dt
            }
            break;
        
        case Json_True:
            if (poke != NULL)
            {
                if (tag->dt != DT_INT)
                {
                    ATG::DebugSpew("[ATGJSON] Json_True requires DT_INT\n");
                }
                else
                {
                    DWORD *d = (DWORD *) poke;
                    *d = 1;
                    poke = NULL;
                    tag = NULL;
                }
            }
            break;
        
        case Json_False:
            if (poke != NULL)
            {
                if (tag->dt != DT_INT)
                {
                    ATG::DebugSpew("[ATGJSON] Json_False requires DT_INT\n");
                }
                else
                {
                    DWORD *d = (DWORD *) poke;
                    *d = 0;
                    poke = NULL;
                    tag = NULL;
                }
            }
            break;
        
        case Json_Null:
            break;
        
        case Json_NameSeparator:
            break;
        
        case Json_ObjectSeparator:  // '.' inside an object
            break;
        
        case Json_ValueSeparator:   // ',' inside an array
            break;
        
        default:
            ATG::DebugSpew("[ATGJSON] error, unknown token.  Parsed=%d\n", parsed);
            return 0;

        }
    }
    while (1); 

    return hr;
}


//--------------------------------------------------------------------------------------
// Parse
//
//--------------------------------------------------------------------------------------
HRESULT AtgJsonReader::Parse(CONST BYTE *inbuf, VOID *bp, PropertyTag *pt, DWORD size) 
{ 
    HJSONPARSER p = XJSONInitialize();
    
    HRESULT hr = XJSONSetBuffer(p, (CONST CHAR *) inbuf, strlen((CONST CHAR *) inbuf), FALSE);

    if (hr != S_OK)
    {
        return hr;
    }

    g_inObject = 0; 
    g_inArray = 0;
    g_isSpecial = FALSE;

    hr = ParseJSON(p, bp, pt, size, NULL);

    XJSONDestroy(p);

    return hr;
}

} // end namespace JSON
} // end namespace ATG

```

`XenonDumper/libs/Atg/AtgJson.h`:

```h



//--------------------------------------------------------------------------------------
// Light Weight JSON reader reader based on XJSON
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------

#pragma once
#ifndef ATGJSON_H
#define ATGJSON_H


//--------------------------------------------------------------------------------------
// INCLUDES
//--------------------------------------------------------------------------------------
#include <xtl.h>
#include <assert.h>
#include <XJSONParser.h>
#include <vector>



namespace ATG
{
namespace JSON
{

//--------------------------------------------------------------------------------------
// DEFINES
//--------------------------------------------------------------------------------------
#define MAXTOKENSIZE 10000 


//--------------------------------------------------------------------------------------
// STRUCTS
//--------------------------------------------------------------------------------------
enum DATATYPE
{
    DT_NONE = 0,
    DT_STRING,
    DT_INT,     
    DT_INT64,
    DT_ARRAY
};


//--------------------------------------------------------------------------------------
// struct PropertyTag
//
// this is used to define a RESTful object for reading
//--------------------------------------------------------------------------------------
struct PropertyTag
{
    WCHAR *fieldname; // e.g. "titleId"
    DATATYPE dt;
    DWORD offset;
    DWORD stringSize;
};


//--------------------------------------------------------------------------------------
// class ICollectionBase
//
// pure virtual base class
// generic interface for all nested user defined objects to be deserialized
// awesome as the JSON serializer can access the nested objects through this interface
// and not care about the underlying user type
//--------------------------------------------------------------------------------------
class ICollectionBase
{
public:
    virtual VOID *GetNewObject() = 0; 
    virtual VOID *GetTags() = 0;
    virtual int GetTagSize() = 0;
};


//--------------------------------------------------------------------------------------
// class Collection : public ICollectionBase
//
// with this awesome abstraction with a pure virtual interface base class we can remove
// the need to known what Type we are actually deserializing in the parser as it is
// implicit in the template declaration of the user type
//--------------------------------------------------------------------------------------
template <typename Type> class Collection : public ICollectionBase
{
public:
    Collection() {}
    
    ~Collection()
    {
        object_array.clear();
    }
    
    VOID *GetNewObject() 
    {
        Type *t = new Type();
        object_array.push_back(t);
        return t;
    }

    Type *operator[](int i)
    {
        return object_array[i];
    }

    VOID *GetTags()
    {
        return Type::tags;
    }

    int GetTagSize()
    {
        return Type::tagsize;
    }

    int GetArraySize()
    {
        return object_array.size();
    }

private:
    std::vector<Type *> object_array;
};


//--------------------------------------------------------------------------------------
// class AtgJsonReader
//
//--------------------------------------------------------------------------------------
class AtgJsonReader
{
public:
    static HRESULT Parse(CONST BYTE *inbuf, VOID *bp, PropertyTag *pt, DWORD size);

private:
    static HRESULT ParseJSON(HJSONPARSER &p, VOID *bp, PropertyTag *pt, DWORD size, VOID *parent);
};

} // end namespace JSON
} // end namespace ATG

#endif

```

`XenonDumper/libs/Atg/AtgLight.cpp`:

```cpp
//-----------------------------------------------------------------------------
// AtgLight.cpp
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "AtgCollision.h"
#include "AtgBound.h"
#include "AtgLight.h"

namespace ATG
{

CONST StringID Light::TypeID( L"Light" );
CONST StringID AmbientLight::TypeID( L"AmbientLight" );
CONST StringID PointLight::TypeID( L"PointLight" );
CONST StringID SpotLight::TypeID( L"SpotLight" );
CONST StringID DirectionalLight::TypeID( L"DirectionalLight" );

CONST EnumStringMap Light::FalloffType_StringMap[] =
{
    { Light::LinearFalloff, L"LINEAR" },
    { Light::SquaredFalloff, L"SQUARED" },
    { Light::NoFalloff, L"NONE" },
    { 0, NULL },
};

CONST EnumStringMap Light::LightFlags_StringMap[] =
{
    { Light::NoFlags, L"NONE" },
    { Light::IsShadowCaster, L"SHADOWCASTER" },
    { 0, NULL },
};

D3DCOLOR Light::GetD3DColor() const
{
    XMVECTOR vColor = GetColor();
    vColor = XMVectorClamp( vColor, XMVectorZero(), XMVectorReplicate( 1.0f ) );

    XMFLOAT4A vec;
    XMStoreFloat4A( &vec, vColor );

    D3DCOLOR Color = D3DCOLOR_COLORVALUE( vec.x, vec.y, vec.z, vec.w );
    return Color;
}

//-----------------------------------------------------------------------------
// Name: PointLight::SetLocalRange
//-----------------------------------------------------------------------------
VOID PointLight::SetLocalRange( FLOAT fRange )
{
    Sphere sphere;

    m_fRange = fRange;

    // build new bound
    XMStoreFloat3( &( sphere.Center ), XMVectorZero() );
    sphere.Radius = m_fRange;

    SetLocalBound( Bound( sphere ) );
}

//-----------------------------------------------------------------------------
// Name: PointLight::GetWorldRange
//-----------------------------------------------------------------------------
FLOAT PointLight::GetWorldRange()
{
    // assume uniform scale.  get scale from length of x axis
    XMVECTOR Scale = XMVector3Length( GetWorldTransform().r[0] );
    return GetLocalRange() * XMVectorGetX( Scale );
}


//--------------------------------------------------------------------------------------
// Name: PointLight::SetWorldRange()
//--------------------------------------------------------------------------------------
VOID PointLight::SetWorldRange( FLOAT fRange )
{
    // assume uniform scale.  get scale from length of x axis
    XMVECTOR Scale = XMVector3Length( GetWorldTransform().r[0] );
    SetLocalRange( fRange / XMVectorGetX( Scale ) );
}


//--------------------------------------------------------------------------------------
// Name: SpotLight::SetWorldRange()
//--------------------------------------------------------------------------------------
VOID SpotLight::SetWorldRange( FLOAT fRange )
{
    // assume uniform scale.  get scale from length of x axis
    XMVECTOR Scale = XMVector3Length( GetWorldTransform().r[0] );
    SetLocalRange( fRange / XMVectorGetX( Scale ) );
}


//-----------------------------------------------------------------------------
// Name: SpotLight::RecalculateBound
//-----------------------------------------------------------------------------
VOID SpotLight::RecalculateBound()
{
    Frustum frustum;

    /*
      FLOAT FovY = m_fOuterAngle;
      FLOAT ZNear = m_fRange * 1e-4f;
      FLOAT ZFar = m_fRange;
      FLOAT h = ( 2.0f * ZNear) / ( 1.0f/tanf(FovY/2.0f)) ;
      
      //$OPTIMIZE: store matrix in decomposed form
      XMMATRIX Projection = XMMatrixPerspectiveLH( h, h, ZNear, ZFar );
     */
    XMMATRIX Projection = GetLightProjection();

    ComputeFrustumFromProjection( &frustum, &Projection );

    SetLocalBound( Bound( frustum ) );
}


//-----------------------------------------------------------------------------
// Name: PointLight::GetWorldRange
//-----------------------------------------------------------------------------
FLOAT SpotLight::GetWorldRange()
{
    // assume uniform scale.  get scale from length of x axis
    XMVECTOR Scale = XMVector3Length( GetWorldTransform().r[0] );
    return GetLocalRange() * XMVectorGetX( Scale );
}

} // namespace ATG

```

`XenonDumper/libs/Atg/AtgLight.h`:

```h
//-----------------------------------------------------------------------------
// AtgLight.h
//
// describes the different lights types
//
// $OPTIMIZE: Pool Allocate
//            Should we cache transformed bounds?
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef ATG_LIGHT_H
#define ATG_LIGHT_H

#include <vector>
#include "AtgFrame.h"

namespace ATG
{

//-----------------------------------------------------------------------------
// Name: Light
// Desc: Base Light Type
//-----------------------------------------------------------------------------
class Light : public Frame
{
    DEFINE_TYPE_INFO();

    enum LightFlags
    {
        NoFlags         = 0,
        IsShadowCaster  = 0x1,
        IsDisabled      = 0x2,
        ForceDWORDFlags = 0x7fffffff,
    };

    enum FalloffType
    {
        NoFalloff           = 0,
        LinearFalloff       = 1,
        SquaredFalloff      = 2,
        ForceDWORDFalloff   = 0x7fffffff,
    };

    static CONST EnumStringMap Light::LightFlags_StringMap[];
    static CONST EnumStringMap Light::FalloffType_StringMap[];

public:
    Light()
        : m_Color( XMVectorZero() ),
          m_dwFlags( 0 )
    {
    }

    CONST std::vector<StringID>&    GetLightGroups() { return m_LightGroups; }
    VOID                            AddLightGroup( CONST StringID& ID ) { m_LightGroups.push_back( ID ); }

    XMVECTOR                        GetColor() CONST { return m_Color; };
    VOID                            SetColor( XMVECTOR Color ) { m_Color = Color; }
    D3DCOLOR GetD3DColor() const;

    DWORD                           GetFlags() const { return m_dwFlags; }
    VOID                            ClearFlag( LightFlags dwFlag ) { m_dwFlags &= ~dwFlag; }
    VOID                            SetFlag( LightFlags dwFlag ) { m_dwFlags |= dwFlag; }
    BOOL                            TestFlag( LightFlags dwFlag ) const { return ( m_dwFlags & dwFlag ) == dwFlag; }

protected:
    XMVECTOR m_Color;
    WORD m_dwFlags;
    std::vector <StringID> m_LightGroups;
};


//-----------------------------------------------------------------------------
// Name: AmbientLight
// Desc: Non-bounded ambient light.  Summed if more than one on a model
//-----------------------------------------------------------------------------
class AmbientLight : public Light
{
    DEFINE_TYPE_INFO();
public:
};


//-----------------------------------------------------------------------------
// Name: PointLight
// Desc: Sphere bounded by sphere radius
//-----------------------------------------------------------------------------
class PointLight : public Light
{
    DEFINE_TYPE_INFO();
public:
            PointLight() : m_fRange( 0.0f ),
                           m_FalloffType( Light::LinearFalloff )
            {
            }

    FLOAT                GetLocalRange()
    CONST
    {
        return m_fRange;
    };
    VOID    SetLocalRange( FLOAT fRange );

    FLOAT   GetWorldRange();
    VOID    SetWorldRange( FLOAT fRange );

    FalloffType          GetFalloff()
    CONST
    {
        return m_FalloffType;
    };
    VOID    SetFalloff( FalloffType Falloff )
    {
        m_FalloffType = Falloff;
    }

private:
    FLOAT m_fRange;
    FalloffType m_FalloffType;
};


//-----------------------------------------------------------------------------
// Name: DirectionalLight
// Desc: Directional Light, non-bounded - get Direction with GetWorldForward
//-----------------------------------------------------------------------------
class DirectionalLight : public Light
{
    DEFINE_TYPE_INFO();
public:

    // direction
    VOID        SetLocalDirection( XMVECTOR& Direction );
    VOID        SetWorldDirection( XMVECTOR& Direction );

    VOID        SetLightViewProjection( const DWORD dwIndex, CXMMATRIX matVP )
    {
        XMStoreFloat4x4( &m_matLightViewProj[dwIndex], matVP );
    }
    XMMATRIX    GetLightViewProjection( const DWORD dwIndex ) const
    {
        return XMLoadFloat4x4( &m_matLightViewProj[dwIndex] );
    }

protected:
    XMFLOAT4X4  m_matLightViewProj[2];
};


//-----------------------------------------------------------------------------
// spot light, bounded by a frustum derived from its outer cone
//-----------------------------------------------------------------------------
class SpotLight : public Light
{
    DEFINE_TYPE_INFO();
public:
                SpotLight() : m_fRange( 0.0f ),
                              m_FalloffType( Light::LinearFalloff ),
                              m_SpotFalloffType( Light::LinearFalloff ),
                              m_fInnerAngle( XM_PIDIV4 ),
                              m_fOuterAngle( XM_PIDIV4 )
                {
                }

    // direction
    VOID        SetLocalDirection( XMVECTOR& Direction );
    VOID        SetWorldDirection( XMVECTOR& Direction );

    FLOAT               GetLocalRange()
    CONST
    {
        return m_fRange;
    };
    VOID        SetLocalRange( FLOAT fRange )
    {
        m_fRange = fRange; RecalculateBound();
    }

    FLOAT       GetWorldRange();
    VOID        SetWorldRange( FLOAT fRange );

    FLOAT               GetInnerAngle()
    CONST
    {
        return m_fInnerAngle;
    };
    VOID        SetInnerAngle( FLOAT fInnerAngle )
    {
        m_fInnerAngle = fInnerAngle; RecalculateBound();
    }

    FLOAT               GetOuterAngle()
    CONST
    {
        return m_fOuterAngle;
    };
    VOID        SetOuterAngle( FLOAT fOuterAngle )
    {
        m_fOuterAngle = fOuterAngle; RecalculateBound();
    }

    FalloffType         GetFalloff()
    CONST
    {
        return m_FalloffType;
    };
    VOID        SetFalloff( FalloffType Falloff )
    {
        m_FalloffType = Falloff;
    }

    FalloffType         GetSpotFalloff()
    CONST
    {
        return m_SpotFalloffType;
    };
    VOID        SetSpotFalloff( FalloffType Falloff )
    {
        m_SpotFalloffType = Falloff;
    }

    XMMATRIX    GetLightProjection()
    {
        return XMMatrixPerspectiveFovLH( m_fOuterAngle, 1.0f, 0.1f, GetWorldRange() );
    }
    XMMATRIX    GetLightView()
    {
        XMVECTOR vD; return XMMatrixInverse( &vD, GetWorldTransform() );
    }
    XMMATRIX    GetLightViewProjection()
    {
        return GetLightView() * GetLightProjection();
    }

private:
    VOID        RecalculateBound();

    FLOAT m_fRange;
    FLOAT m_fInnerAngle;
    FLOAT m_fOuterAngle;

    FalloffType m_FalloffType;
    FalloffType m_SpotFalloffType;
};

} // namespace ATG

#endif // ATG_LIGHT_H

```

`XenonDumper/libs/Atg/AtgLockFreePipe.h`:

```h
//--------------------------------------------------------------------------------------
// AtgLockFreePipe.h
//
// See the "Lockless Programming Considerations for Xbox 360 and Microsoft Windows"
// article in the Xbox XDK for more details.
//
// http://msdn2.microsoft.com/en-us/library/bb310595.aspx
//
// XNA Developer Connection
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#pragma once

#include <sal.h>

#ifdef _XBOX_VER
    // Prevent the CPU from rearranging loads
    // and stores, sufficiently for read-acquire
    // and write-release.
    #define ATGImportBarrier __lwsync
    #define ATGExportBarrier __lwsync
#else
    #pragma pack(push)
    #pragma pack(8)
    #include <windows.h>
    #pragma pack (pop)

    extern "C"
        void _ReadWriteBarrier();
    #pragma intrinsic(_ReadWriteBarrier)

    // Prevent the compiler from rearranging loads
    // and stores, sufficiently for read-acquire
    // and write-release. This is sufficient on
    // x86 and x64.
    #define ATGImportBarrier _ReadWriteBarrier
    #define ATGExportBarrier _ReadWriteBarrier
#endif

namespace ATG
{

//
// Pipe class designed for use by at most two threads: one reader, one writer.
// Access by more than two threads isn't guaranteed to be safe. 
// 
// In order to provide efficient access the size of the buffer is passed
// as a template parameter and restricted to powers of two less than 31.
//

template <BYTE cbBufferSizeLog2> class LockFreePipe
{
public:
    LockFreePipe() : m_readOffset( 0 ),
                     m_writeOffset( 0 )
                     {
                     }

    DWORD                       GetBufferSize() const
    {
        return c_cbBufferSize;
    }

    __forceinline unsigned long BytesAvailable() const
    {
        return m_writeOffset - m_readOffset;
    }

    bool __forceinline          Read( void* pvDest, unsigned long cbDest )
    {
        // Store the read and write offsets into local variables--this is
        // essentially a snapshot of their values so that they stay constant
        // for the duration of the function (and so we don't end up with cache 
        // misses due to false sharing).
        DWORD readOffset = m_readOffset;
        DWORD writeOffset = m_writeOffset;

        // Compare the two offsets to see if we have anything to read.
        // Note that we don't do anything to synchronize the offsets here.
        // Really there's not much we *can* do unless we're willing to completely
        // synchronize access to the entire object. We have to assume that as we 
        // read, someone else may be writing, and the write offset we have now
        // may be out of date by the time we read it. Fortunately that's not a
        // very big deal. We might miss reading some data that was just written.
        // But the assumption is that we'll be back before long to grab more data
        // anyway.
        //
        // Note that this comparison works because we're careful to constrain
        // the total buffer size to be a power of 2, which means it will divide
        // evenly into ULONG_MAX+1. That, and the fact that the offsets are 
        // unsigned, means that the calculation returns correct results even
        // when the values wrap around.
        DWORD cbAvailable = writeOffset - readOffset;
        if( cbDest > cbAvailable )
        {
            return false;
        }

        // The data has been made available, but we need to make sure
        // that our view on the data is up to date -- at least as up to
        // date as the control values we just read. We need to prevent
        // the compiler or CPU from moving any of the data reads before
        // the control value reads. This import barrier serves this
        // purpose, on Xbox 360 and on Windows.

        // Reading a control value and then having a barrier is known
        // as a "read-acquire."
        ATGImportBarrier();

        unsigned char* pbDest = ( unsigned char* )pvDest;

        unsigned long actualReadOffset = readOffset & c_sizeMask;
        unsigned long bytesLeft = cbDest;

        //
        // Copy from the tail, then the head. Note that there's no explicit
        // check to see if the write offset comes between the read offset
        // and the end of the buffer--that particular condition is implicitly
        // checked by the comparison with AvailableToRead(), above. If copying
        // cbDest bytes off the tail would cause us to cross the write offset,
        // then the previous comparison would have failed since that would imply
        // that there were less than cbDest bytes available to read.
        //
        unsigned long cbTailBytes = min( bytesLeft, c_cbBufferSize - actualReadOffset );
        memcpy( pbDest, m_pbBuffer + actualReadOffset, cbTailBytes );
        bytesLeft -= cbTailBytes;

        if( bytesLeft )
        {
            memcpy( pbDest + cbTailBytes, m_pbBuffer, bytesLeft );
        }

        // When we update the read offset we are, effectively, 'freeing' buffer
        // memory so that the writing thread can use it. We need to make sure that
        // we don't free the memory before we have finished reading it. That is,
        // we need to make sure that the write to m_readOffset can't get reordered
        // above the reads of the buffer data. The only way to guarantee this is to
        // have an export barrier to prevent both compiler and CPU rearrangements.
        ATGExportBarrier();

        // Advance the read offset. From the CPUs point of view this is several
        // operations--read, modify, store--and we'd normally want to make sure that
        // all of the operations happened atomically. But in the case of a single
        // reader, only one thread updates this value and so the only operation that
        // must be atomic is the store. That's lucky, because 32-bit aligned stores are
        // atomic on all modern processors.
        // 
        readOffset += cbDest;
        m_readOffset = readOffset;

        return true;
    }

    bool __forceinline          Write( const void* pvSrc, unsigned long cbSrc )
    {
        // Reading the read offset here has the same caveats as reading
        // the write offset had in the Read() function above. 
        DWORD readOffset = m_readOffset;
        DWORD writeOffset = m_writeOffset;

        // Compute the available write size. This comparison relies on
        // the fact that the buffer size is always a power of 2, and the
        // offsets are unsigned integers, so that when the write pointer
        // wraps around the subtraction still yields a value (assuming
        // we haven't messed up somewhere else) between 0 and c_cbBufferSize - 1.
        DWORD cbAvailable = c_cbBufferSize - ( writeOffset - readOffset );
        if( cbSrc > cbAvailable )
        {
            return false;
        }

        // It is theoretically possible for writes of the data to be reordered
        // above the reads to see if the data is available. Improbable perhaps,
        // but possible. This barrier guarantees that the reordering will not
        // happen.
        ATGImportBarrier();

        // Write the data
        const unsigned char* pbSrc = ( const unsigned char* )pvSrc;
        unsigned long actualWriteOffset = writeOffset & c_sizeMask;
        unsigned long bytesLeft = cbSrc;

        // See the explanation in the Read() function as to why we don't 
        // explicitly check against the read offset here.
        unsigned long cbTailBytes = min( bytesLeft, c_cbBufferSize - actualWriteOffset );
        memcpy( m_pbBuffer + actualWriteOffset, pbSrc, cbTailBytes );
        bytesLeft -= cbTailBytes;

        if( bytesLeft )
        {
            memcpy( m_pbBuffer, pbSrc + cbTailBytes, bytesLeft );
        }

        // Now it's time to update the write offset, but since the updated position
        // of the write offset will imply that there's data to be read, we need to 
        // make sure that the data all actually gets written before the update to
        // the write offset. The writes could be reordered by the compiler (on any
        // platform) or by the CPU (on Xbox 360). We need a barrier which prevents
        // the writes from being reordered past each other.
        //
        // Having a barrier and then writing a control value is called "write-release."
        ATGExportBarrier();

        // See comments in Read() as to why this operation isn't interlocked.
        writeOffset += cbSrc;
        m_writeOffset = writeOffset;

        return true;
    }

private:
    // Values derived from the buffer size template parameter
    //
    const static BYTE c_cbBufferSizeLog2 = min( cbBufferSizeLog2, 31 );
    const static DWORD c_cbBufferSize = ( 1 << c_cbBufferSizeLog2 );
    const static DWORD c_sizeMask = c_cbBufferSize - 1;

    // Leave these private and undefined to prevent their use
    LockFreePipe( const LockFreePipe& );
    LockFreePipe& operator =( const LockFreePipe& );

    // Member data
    //
    BYTE                        m_pbBuffer[c_cbBufferSize];
    // Note that these offsets are not clamped to the buffer size.
    // Instead the calculations rely on wrapping at ULONG_MAX+1.
    // See the comments in Read() for details.
    volatile DWORD __declspec( align( 4 ) ) m_readOffset;
    volatile DWORD __declspec( align( 4 ) ) m_writeOffset;
};

}
//namespace ATG

```

`XenonDumper/libs/Atg/AtgMaterials.cpp`:

```cpp
//-----------------------------------------------------------------------------
// AtgMaterials.cpp
//
// Materials classes for the scene hierarchy.  These classes support FXLite
// materials as well as pixel/vertex shader materials.
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "AtgMaterials.h"
#include "AtgSceneAll.h"
#include "AtgUtil.h"

namespace ATG
{
    const StringID BaseMaterial::TypeID( L"BaseMaterial" );
    const StringID MaterialInstance::TypeID( L"MaterialInstance" );
    const StringID MaterialImplementation::TypeID( L"MaterialImplementation" );
    const StringID FXLiteMaterialImplementation::TypeID( L"FXLiteMaterialImplementation" );
    const StringID ShaderMaterialImplementation::TypeID( L"ShaderMaterialImplementation" );

    CHAR g_strConvertBuffer[ 512 ];
    inline const CHAR* ConvertString( const WCHAR* strWide )
    {
        WideCharToMultiByte( CP_ACP, 0, strWide, wcslen( strWide ) + 1, g_strConvertBuffer, ARRAYSIZE( g_strConvertBuffer ), NULL, NULL );
        g_strConvertBuffer[ ARRAYSIZE( g_strConvertBuffer ) - 1 ] = '\0';
        return g_strConvertBuffer;
    }


    inline VOID CreateMediaPath( CHAR* strDest, UINT uDestLength, const WCHAR* strSrcPath, const CHAR* strMediaSubDirectory, const CHAR* strMediaRootPath )
    {
        const WCHAR* strFilename = wcsrchr( strSrcPath, L'/' );
        if( strFilename == NULL )
        {
            strFilename = wcsrchr( strSrcPath, L'\\' );
        }
        if( strFilename == NULL )
        {
            strFilename = strSrcPath;
        }
        else
        {
            strFilename++;
        }
        strcpy_s( strDest, uDestLength, strMediaRootPath );
        if( strMediaSubDirectory != NULL )
        {
            strcat_s( strDest, uDestLength, strMediaSubDirectory );
            strcat_s( strDest, uDestLength, "\\" );
        }
        UINT uLength = strlen( strDest );
        WideCharToMultiByte( CP_ACP, 0, strFilename, wcslen( strFilename ) + 1, strDest + uLength, uDestLength - uLength, NULL, NULL );
        // Guarantee that the buffer is null terminated.
        strDest[ uDestLength - 1 ] = 0;
    }


    inline VOID BindTextureHelper( MaterialParameter& mp, const CHAR* strMediaRootPath, Scene* pScene )
    {
        switch( mp.Type )
        {
        case MaterialParameter::RPT_Texture2D:
            {
                CHAR strTexturePath[MAX_PATH];
                Texture* pTexResource = NULL;
                CreateMediaPath( strTexturePath, MAX_PATH, mp.strValue, "textures", strMediaRootPath );
                pTexResource = pScene->GetResourceDatabase()->AddTexture2D( strTexturePath );
                if( pTexResource == NULL )
                    pTexResource = pScene->GetResourceDatabase()->GetDefaultTexture2D();
                mp.pValue = pTexResource;
                break;
            }
        case MaterialParameter::RPT_TextureCube:
            {
                CHAR strTexturePath[MAX_PATH];
                Texture* pTexResource = NULL;
                CreateMediaPath( strTexturePath, MAX_PATH, mp.strValue, "textures", strMediaRootPath );
                pTexResource = pScene->GetResourceDatabase()->AddTextureCube( strTexturePath );
                if( pTexResource == NULL )
                    pTexResource = pScene->GetResourceDatabase()->GetDefaultTextureCube();
                mp.pValue = pTexResource;
                break;
            }
        case MaterialParameter::RPT_Texture3D:
            {
                CHAR strTexturePath[MAX_PATH];
                Texture* pTexResource = NULL;
                CreateMediaPath( strTexturePath, MAX_PATH, mp.strValue, "textures", strMediaRootPath );
                pTexResource = pScene->GetResourceDatabase()->AddTextureVolume( strTexturePath );
                if( pTexResource == NULL )
                    pTexResource = pScene->GetResourceDatabase()->GetDefaultTexture2D();
                mp.pValue = pTexResource;
                break;
            }
        }
    }


    inline DWORD FindRawParameterHelper( const StringID Name, const MaterialParameterVector* pParams )
    {
        DWORD dwCount = (DWORD)pParams->size();
        for( DWORD i = 0; i < dwCount; ++i )
        {
            const MaterialParameter& mp = (*pParams)[i];
            if( mp.strName == Name )
                return i;
        }
        return (DWORD)-1;
    }


    //----------------------------------------------------------------------------------
    // BaseMaterial
    //----------------------------------------------------------------------------------

    CHAR BaseMaterial::m_strMediaRootPath[ MAX_PATH ] = "game:\\media\\";

    BaseMaterial::BaseMaterial()
        : m_pMaterialImplementation( NULL ),
          m_bTexturesBound( FALSE )
    { }


    VOID BaseMaterial::SetMediaRootPath( const CHAR* strMediaRootPath )
    {
        strcpy_s( m_strMediaRootPath, strMediaRootPath );
    }


    BaseMaterial* BaseMaterial::CreateFXLiteMaterial( StringID MaterialName,
                                                      StringID FXLiteFilePath,
                                                      StringID TechniqueName )
    {
        BaseMaterial* pMaterial = new BaseMaterial();
        pMaterial->SetName( MaterialName );

        MaterialParameter mp;
        mp.Type = MaterialParameter::RPT_String;
        mp.strName = L"EffectFile";
        mp.strValue = FXLiteFilePath;
        pMaterial->AddRawParameter( mp );

        if( TechniqueName != NULL )
        {
            mp.strName = L"EffectTechnique";
            mp.strValue = TechniqueName;
            pMaterial->AddRawParameter( mp );
        }

        return pMaterial;
    }


    BaseMaterial* BaseMaterial::CreateShaderMaterial( StringID MaterialName,
                                                      StringID VertexShaderFileName,
                                                      StringID VertexShaderEntryPoint,
                                                      StringID PixelShaderFileName,
                                                      StringID PixelShaderEntryPoint )
    {
        BaseMaterial* pMaterial = new BaseMaterial();
        pMaterial->SetName( MaterialName );

        MaterialParameter mp;
        mp.Type = MaterialParameter::RPT_String;
        mp.strName = L"VertexShader";
        mp.strValue = VertexShaderFileName;
        pMaterial->AddRawParameter( mp );

        mp.strName = L"VertexShaderEntryPoint";
        mp.strValue = VertexShaderEntryPoint;
        pMaterial->AddRawParameter( mp );

        if( PixelShaderFileName != NULL )
        {
            assert( PixelShaderEntryPoint != NULL );
            mp.strName = L"PixelShader";
            mp.strValue = PixelShaderFileName;
            pMaterial->AddRawParameter( mp );

            mp.strName = L"PixelShaderEntryPoint";
            mp.strValue = PixelShaderEntryPoint;
            pMaterial->AddRawParameter( mp );
        }

        return pMaterial;
    }


    MaterialInstanceData BaseMaterial::InitializeInstance( MaterialInstance* pMaterialInstance )
    {
        if( m_pMaterialImplementation == NULL )
        {
            InitializeImplementation();
        }

        if( m_pMaterialImplementation != NULL )
            return m_pMaterialImplementation->CreateInstanceData( pMaterialInstance );

        return NULL;
    }


    VOID BaseMaterial::InitializeImplementation()
    {
        assert( m_pMaterialImplementation == NULL );

        // Figure out what type of material implementation we need to create
        if( FXLiteMaterialImplementation::IsFXLiteMaterial( this ) )
        {
            // Effect material
            m_pMaterialImplementation = new FXLiteMaterialImplementation( this );
            return;
        }

        if( ShaderMaterialImplementation::IsShaderMaterial( this ) )
        {
            // Shader material
            m_pMaterialImplementation = new ShaderMaterialImplementation( this );
        }
    }


    VOID BaseMaterial::ChangeDevice( ::D3DDevice* pd3dDevice )
    {
        if( m_pMaterialImplementation != NULL )
            m_pMaterialImplementation->ChangeDevice( pd3dDevice );
    }


    VOID BaseMaterial::BindTextures( const CHAR* strMediaRootPath, Scene* pScene )
    {
        if( m_bTexturesBound )
            return;

        DWORD dwCount = GetRawParameterCount();
        for( DWORD i = 0; i < dwCount; ++i )
        {
            MaterialParameter& mp = GetRawParameter( i );
            BindTextureHelper( mp, strMediaRootPath, pScene );
        }

        m_bTexturesBound = TRUE;
    }


    DWORD BaseMaterial::FindRawParameter( const StringID Name ) const
    {
        return FindRawParameterHelper( Name, &m_RawParameters );
    }


    DWORD BaseMaterial::GetPassCount() const
    {
        assert( m_pMaterialImplementation != NULL );
        return m_pMaterialImplementation->GetPassCount();
    }


    VOID BaseMaterial::BeginPass( MaterialInstanceData Data, DWORD dwIndex )
    {
        assert( m_pMaterialImplementation != NULL );
        m_pMaterialImplementation->BeginPass( Data, dwIndex );
    }


    VOID BaseMaterial::EndPass( MaterialInstanceData Data )
    {
        assert( m_pMaterialImplementation != NULL );
        m_pMaterialImplementation->EndPass( Data );
    }


    VOID BaseMaterial::BeginMaterial( MaterialInstanceData Data, ::D3DDevice* pd3dDevice, DWORD dwMaterialVariant )
    {
        assert( m_pMaterialImplementation != NULL );
        m_pMaterialImplementation->BeginMaterial( Data, pd3dDevice, dwMaterialVariant );
    }


    VOID BaseMaterial::EndMaterial( MaterialInstanceData Data )
    {
        assert( m_pMaterialImplementation != NULL );
        m_pMaterialImplementation->EndMaterial( Data );
    }


    //----------------------------------------------------------------------------------
    // MaterialInstance
    //----------------------------------------------------------------------------------

    MaterialInstance::MaterialInstance()
        : m_bTexturesBound( FALSE ),
          m_bTransparent( FALSE ),
          m_dwCurrentBindingIndex( 0 )
    {
        AllocateMaterialBindings( 1 );
    }


    VOID MaterialInstance::AllocateMaterialBindings( DWORD dwMaxCount )
    {
        MaterialPair mp = { 0 };
        m_MaterialBindings.resize( dwMaxCount, mp );
    }


    VOID MaterialInstance::SetMaterialBindingIndex( DWORD dwIndex )
    {
        assert( dwIndex >= 0 && dwIndex < GetMaterialBindingCount() );
        m_dwCurrentBindingIndex = dwIndex;
    }


    VOID MaterialInstance::SetBaseMaterial( BaseMaterial* pBM )
    {
        BaseMaterial* pCurrentMaterial = GetBaseMaterial();
        if( pCurrentMaterial == pBM )
            return;

        if( pCurrentMaterial != NULL && pCurrentMaterial->GetMaterialImplementation() != NULL )
            pCurrentMaterial->GetMaterialImplementation()->DestroyInstanceData( GetInstanceData() );

        MaterialPair mp = { pBM, NULL };
        m_MaterialBindings[m_dwCurrentBindingIndex] = mp;
    }


    VOID MaterialInstance::Initialize()
    {
        if( GetBaseMaterial() == NULL || GetInstanceData() != NULL )
            return;

        m_MaterialBindings[m_dwCurrentBindingIndex].pMaterialInstanceData = GetBaseMaterial()->InitializeInstance( this );
    }


    VOID MaterialInstance::BindTextures( const CHAR* strMediaRootPath, Scene* pScene )
    {
        if( m_bTexturesBound )
            return;

        DWORD dwCount = GetRawParameterCount();
        for( DWORD i = 0; i < dwCount; ++i )
        {
            MaterialParameter& mp = GetRawParameter( i );
            BindTextureHelper( mp, strMediaRootPath, pScene );
        }

        m_bTexturesBound = TRUE;

        if( GetBaseMaterial() != NULL )
            GetBaseMaterial()->BindTextures( strMediaRootPath, pScene );
    }


    DWORD MaterialInstance::FindRawParameter( const StringID Name ) const
    {
        return FindRawParameterHelper( Name, &m_RawParameters );
    }


    DWORD MaterialInstance::GetPassCount() const
    {
        assert( GetBaseMaterial() != NULL );
        return GetBaseMaterial()->GetPassCount();
    }


    VOID MaterialInstance::BeginPass( DWORD dwIndex )
    {
        assert( GetBaseMaterial() != NULL );
        GetBaseMaterial()->BeginPass( GetInstanceData(), dwIndex );
    }


    VOID MaterialInstance::EndPass()
    {
        assert( GetBaseMaterial() != NULL );
        GetBaseMaterial()->EndPass( GetInstanceData() );
    }


    VOID MaterialInstance::BeginMaterial( ::D3DDevice* pd3dDevice, DWORD dwMaterialVariant )
    {
        assert( GetBaseMaterial() != NULL );
        GetBaseMaterial()->BeginMaterial( GetInstanceData(), pd3dDevice, dwMaterialVariant );
    }


    VOID MaterialInstance::EndMaterial()
    {
        assert( GetBaseMaterial() != NULL );
        GetBaseMaterial()->EndMaterial( GetInstanceData() );
    }


    VOID MaterialInstance::BeginMaterialSinglePass( ::D3DDevice* pd3dDevice, DWORD dwMaterialVariant )
    {
        assert( GetPassCount() == 1 );
        BeginMaterial( pd3dDevice, dwMaterialVariant );
        BeginPass( 0 );
    }


    VOID MaterialInstance::EndMaterialSinglePass()
    {
        EndPass();
        EndMaterial();
    }

    //-------------------------------------------------------------------------
    // Shader Include Handler
    //-------------------------------------------------------------------------

    ShaderIncludeHandler::ShaderIncludeHandler( const CHAR* strBasePath )
    {
        strcpy_s( m_strBasePath, strBasePath );
        CHAR* pLastSlash = strrchr( m_strBasePath, '\\' );
        if( pLastSlash != NULL )
            pLastSlash[1] = '\0';
    }

    HRESULT ShaderIncludeHandler::Open( D3DXINCLUDE_TYPE IncludeType, LPCSTR pFileName, LPCVOID pParentData,
        LPCVOID* ppData, UINT* pBytes, /* OUT */ LPSTR pFullPath, DWORD cbFullPath )
    {
        CHAR strIncludeFileName[MAX_PATH];
        strcpy_s( strIncludeFileName, m_strBasePath );
        strcat_s( strIncludeFileName, pFileName );

        strcpy_s( pFullPath, cbFullPath, strIncludeFileName );

        HANDLE hFile = ::CreateFile( strIncludeFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL );
        if ( hFile == INVALID_HANDLE_VALUE )
        {
            ATG::DebugSpew( "ATG::ShaderIncludeHandler error: Could not load shader include file \"%s\".\n", strIncludeFileName );
            return E_FAIL;
        }

        DWORD dwSize, dwWritten;
        dwSize = GetFileSize( hFile, NULL );

        CHAR* pFileBuffer = new CHAR[ dwSize + 1 ];

        if( !ReadFile(hFile, pFileBuffer, dwSize, &dwWritten, NULL ))
        {
            ATG::DebugSpew( "ATG::ShaderIncludeHandler error: Could not load shader include file \"%s\".\n", strIncludeFileName );
            CloseHandle( hFile );
            return E_FAIL;
        }

        CloseHandle( hFile );
        pFileBuffer[ dwSize ] = '\0';

        *ppData = (VOID*)pFileBuffer;
        *pBytes = dwSize;

        return S_OK;
    }


    HRESULT ShaderIncludeHandler::Close( LPCVOID pData )
    {
        delete[] pData;
        return S_OK;
    }

    //-------------------------------------------------------------------------
    // FXLite Material Implementation
    //-------------------------------------------------------------------------

    FXLEffectPool* g_pFXLiteEffectPool = NULL;
    VOID FXLiteMaterialImplementation::SetParameterPool( FXLEffectPool* pEffectPool )
    {
        g_pFXLiteEffectPool = pEffectPool;
    }

    D3DTexture* g_pNullSamplerTexture = NULL;
    VOID FXLiteMaterialImplementation::SetNullSamplerTexture( D3DTexture* pTexture )
    {
        g_pNullSamplerTexture = pTexture;
    }

    FXLiteMaterialImplementation::FXLiteMaterialImplementation( BaseMaterial* pBaseMaterial )
        : m_dwPassCount( 0 ),
          m_hTechnique( NULL ),
          m_pEffect( NULL )
    {
        assert( pBaseMaterial != NULL );
        DWORD dwParamIndex = pBaseMaterial->FindRawParameter( L"EffectFile" );
        if( dwParamIndex == (DWORD)-1 )
        {
            DebugSpew( "WARNING: FXLite material %S does not have an EffectFile parameter.\n", pBaseMaterial->GetName().GetSafeString() );
            return;
        }

        const WCHAR* strFileName = pBaseMaterial->GetRawParameter( dwParamIndex ).strValue;
        CHAR strFileNameAscii[ MAX_PATH ];
        CreateMediaPath( strFileNameAscii, ARRAYSIZE( strFileNameAscii ), strFileName, "Effects", BaseMaterial::GetMediaRootPath() );

        HANDLE hFile = ::CreateFile( strFileNameAscii, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL );
        if ( hFile == INVALID_HANDLE_VALUE )
        {
            return;
        }

        DWORD dwSize, dwRead;
        dwSize = GetFileSize( hFile, NULL );

        CHAR *pFileBuffer = new CHAR[ dwSize + 1 ];

        if( !ReadFile( hFile, pFileBuffer, dwSize, &dwRead, NULL ))
        {
            CloseHandle( hFile );
            delete[] pFileBuffer;
            return;
        }

        CloseHandle( hFile );
        pFileBuffer[ dwSize ] = '\0';

        if( (BYTE)pFileBuffer[0] > 0x7f )
        {
            // binary object file
            CreateBinary( (BYTE*)pFileBuffer );
        }
        else
        {
            // ASCII effect source code
            D3DXMACRO* pMacros = CreateMacroList( pBaseMaterial );
            ShaderIncludeHandler SIH( strFileNameAscii );
            CreateAscii( pFileBuffer, pMacros, &SIH );
            if( pMacros != NULL )
                delete[] pMacros;
        }

        delete[] pFileBuffer;

        DWORD dwParamCount = pBaseMaterial->GetRawParameterCount();
        for( DWORD i = 0; i < dwParamCount; ++i )
        {
            CopyParamDataToEffect( m_pEffect, &pBaseMaterial->GetRawParameter( i ) );
        }

        SetNullSamplerParameters();

        dwParamIndex = pBaseMaterial->FindRawParameter( L"EffectTechnique" );
        const WCHAR* strTechniqueName = NULL;
        if( dwParamIndex != (DWORD)-1 )
            strTechniqueName = pBaseMaterial->GetRawParameter( dwParamIndex ).strValue;
        if( strTechniqueName == NULL )
            m_hTechnique = m_pEffect->GetTechniqueHandleFromIndex( 0 );
        else
            m_hTechnique = m_pEffect->GetTechniqueHandle( ConvertString( strTechniqueName ) );

        FXLTECHNIQUE_DESC TechDesc;
        m_pEffect->GetTechniqueDesc( m_hTechnique, &TechDesc );
        m_dwPassCount = (DWORD)TechDesc.Passes;
    }

    BOOL FXLiteMaterialImplementation::IsFXLiteMaterial( BaseMaterial* pMaterial )
    {
        assert( pMaterial != NULL );
        DWORD dwIndex = pMaterial->FindRawParameter( L"EffectFile" );
        return ( dwIndex != (DWORD)-1 );
    }

    D3DXMACRO* FXLiteMaterialImplementation::CreateMacroList( BaseMaterial* pBaseMaterial )
    {
        return NULL;
    }

    VOID FXLiteMaterialImplementation::CreateBinary( BYTE* pBuffer )
    {
        if( m_pEffect != NULL )
            m_pEffect->Release();

        HRESULT hr = FXLCreateEffect( NULL, pBuffer, g_pFXLiteEffectPool, &m_pEffect );
        if( FAILED( hr ) )
        {
            DebugSpew( "FXLite effect creation error.\n" );
        }
    }

    VOID FXLiteMaterialImplementation::SetNullSamplerParameters()
    {
        assert( m_pEffect != NULL );
        FXLEFFECT_DESC EffectDesc;
        m_pEffect->GetEffectDesc( &EffectDesc );
        for( DWORD i = 0; i < EffectDesc.Parameters; ++i )
        {
            FXLHANDLE hParam = m_pEffect->GetParameterHandleFromIndex( i );
            FXLPARAMETER_DESC ParamDesc;
            m_pEffect->GetParameterDesc( hParam, &ParamDesc );
            if( ParamDesc.Class == FXLDCLASS_SAMPLER ||
                ParamDesc.Class == FXLDCLASS_SAMPLER1D ||
                ParamDesc.Class == FXLDCLASS_SAMPLER2D ||
                ParamDesc.Class == FXLDCLASS_SAMPLER3D ||
                ParamDesc.Class == FXLDCLASS_SAMPLERCUBE )
            {
                D3DBaseTexture* pTex = NULL;
                m_pEffect->GetSampler( hParam, &pTex );
                if( pTex == NULL )
                    m_pEffect->SetSampler( hParam, g_pNullSamplerTexture );
            }
        }
    }

    VOID FXLiteMaterialImplementation::CreateAscii( const CHAR* strFileBuffer, const D3DXMACRO* pMacros, ShaderIncludeHandler* pShaderIncludeHandler )
    {
        ID3DXBuffer *pBuffer = NULL, *pErrorBuffer = NULL;
        DWORD dwCompileFlags = 0;

        FXLCompileEffect( strFileBuffer, strlen( strFileBuffer ), pMacros, pShaderIncludeHandler, dwCompileFlags, &pBuffer, &pErrorBuffer );

        if( pErrorBuffer != NULL )
        {
            DebugSpew( "FXLite error: %s\n", (const CHAR*)pErrorBuffer->GetBufferPointer() );
            pErrorBuffer->Release();
        }

        if( pBuffer == NULL )
        {
            return;
        }

        CreateBinary( (BYTE*)pBuffer->GetBufferPointer() );
        pBuffer->Release();
    }

    MaterialInstanceData FXLiteMaterialImplementation::CreateInstanceData( MaterialInstance* pMaterialInstance )
    {
        assert( pMaterialInstance != NULL );

        if( m_pEffect == NULL )
            return NULL;

        /*
        if( m_pEffect->m_dwDevice == 0 )
        {
            ATG_PrintWarning( "Material instance being created before FXLiteMaterial is assigned a D3D device.\n" );
        }
        */

        FXLiteMaterialInstanceData* pInstanceData = new FXLiteMaterialInstanceData;
        m_pEffect->CreateInstance( &pInstanceData->pEffect );

        DWORD dwParamCount = pMaterialInstance->GetRawParameterCount();
        for( DWORD i = 0; i < dwParamCount; ++i )
        {
            CopyParamDataToEffect( pInstanceData->pEffect, &pMaterialInstance->GetRawParameter( i ) );
        }
        return (MaterialInstanceData)pInstanceData;
    }

    VOID FXLiteMaterialImplementation::DestroyInstanceData( MaterialInstanceData Data )
    {
        FXLiteMaterialInstanceData* pInstanceData = (FXLiteMaterialInstanceData*)Data;
        assert( pInstanceData != NULL );
        assert( pInstanceData->pEffect != NULL );
        pInstanceData->pEffect->Release();

        delete pInstanceData;
    }

    VOID FXLiteMaterialImplementation::ChangeDevice( ::D3DDevice* pd3dDevice )
    {
        if( m_pEffect != NULL )
            m_pEffect->ChangeDevice( pd3dDevice );
    }

    VOID FXLiteMaterialImplementation::CopyParamDataToEffect( FXLEffect* pEffect, MaterialParameter* pParam )
    {
        assert( pParam != NULL );
        assert( pEffect != NULL );

        if( pParam->Type == MaterialParameter::RPT_String )
            return;

        const CHAR* strParamName = ConvertString( pParam->strName );
        FXLHANDLE hParam = pEffect->GetParameterHandle( strParamName );
        if( hParam == NULL )
            return;

        FXLPARAMETER_DESC desc;
        pEffect->GetParameterDesc( hParam, &desc );
        switch( desc.Type )
        {
        case FXLDTYPE_INT:
            switch( desc.Class )
            {
            case FXLDCLASS_SCALAR:
                assert( pParam->Type == MaterialParameter::RPT_Int );
                pEffect->SetScalarI( hParam, &pParam->iValue );
                break;
            }
            break;
        case FXLDTYPE_BOOL:
            switch( desc.Class )
            {
            case FXLDCLASS_SCALAR:
                if( pParam->Type == MaterialParameter::RPT_Bool )
                {
                    pEffect->SetScalarB( hParam, &pParam->bValue );
                }
                else if( pParam->Type == MaterialParameter::RPT_Int )
                {
                    BOOL bValue = ( pParam->iValue != 0 );
                    pEffect->SetScalarB( hParam, &bValue );
                }
                break;
            }
            break;
        case FXLDTYPE_FLOAT:
            switch( desc.Class )
            {
            case FXLDCLASS_SCALAR:
                assert( pParam->dwCount == 1 );
                if( pParam->Type == MaterialParameter::RPT_Float )
                {
                    pEffect->SetScalarF( hParam, &pParam->fValue );
                }
                else if( pParam->Type == MaterialParameter::RPT_Int )
                {
                    FLOAT fValue = (FLOAT)pParam->iValue;
                    pEffect->SetScalarF( hParam, &fValue );
                }
                break;
            case FXLDCLASS_VECTOR:
                assert( pParam->Type == MaterialParameter::RPT_Float );
                assert( pParam->dwCount == desc.Rows * desc.Columns );
                pEffect->SetVectorF( hParam, pParam->pFloatValues );
                break;
            }
            break;
        case FXLDTYPE_SAMPLER:
            switch( desc.Class )
            {
            case FXLDCLASS_SAMPLER2D:
            case FXLDCLASS_SAMPLER:
            case FXLDCLASS_SAMPLERCUBE:
                {
                    assert( pParam->Type == MaterialParameter::RPT_Texture2D ||
                            pParam->Type == MaterialParameter::RPT_Texture3D ||
                            pParam->Type == MaterialParameter::RPT_TextureCube );
                    Texture* pTexResource = (Texture*)pParam->pValue;
                    if( pTexResource != NULL )
                        pEffect->SetSampler( hParam, pTexResource->GetD3DTexture() );
                    else
                        pEffect->SetSampler( hParam, g_pNullSamplerTexture );
                    break;
                }
            }
            break;
        }
    }

    VOID FXLiteMaterialImplementation::BeginPass( MaterialInstanceData Data, DWORD dwIndex )
    {
        FXLiteMaterialInstanceData* pInstanceData = (FXLiteMaterialInstanceData*)Data;
        pInstanceData->pEffect->BeginPassFromIndex( dwIndex );
        pInstanceData->pEffect->Commit();
    }

    VOID FXLiteMaterialImplementation::EndPass( MaterialInstanceData Data )
    {
        FXLiteMaterialInstanceData* pInstanceData = (FXLiteMaterialInstanceData*)Data;
        pInstanceData->pEffect->EndPass();
    }

    VOID FXLiteMaterialImplementation::BeginMaterial( MaterialInstanceData Data, ::D3DDevice* pd3dDevice, DWORD dwMaterialVariant )
    {
        FXLiteMaterialInstanceData* pInstanceData = (FXLiteMaterialInstanceData*)Data;
        assert( pInstanceData != NULL );
        pInstanceData->pEffect->ChangeDevice( pd3dDevice );
        FXLHANDLE hTechnique = m_hTechnique;
        if( dwMaterialVariant != 0 )
            hTechnique = (FXLHANDLE)dwMaterialVariant;
        pInstanceData->pEffect->BeginTechnique( hTechnique, 0 );
    }

    VOID FXLiteMaterialImplementation::EndMaterial( MaterialInstanceData Data )
    {
        FXLiteMaterialInstanceData* pInstanceData = (FXLiteMaterialInstanceData*)Data;
        pInstanceData->pEffect->EndTechnique();
    }


    //-------------------------------------------------------------------------
    // Shader Material Implementation
    //-------------------------------------------------------------------------

    ShaderMaterialImplementation::ShaderMaterialImplementation( BaseMaterial* pBaseMaterial )
        : m_pVertexShader( NULL ),
          m_pPixelShader( NULL ),
          m_pVertexShaderConstantTable( NULL ),
          m_pPixelShaderConstantTable( NULL )
    {
        // find vertex shader parameter
        DWORD dwParamIndex = pBaseMaterial->FindRawParameter( L"VertexShader" );
        if( dwParamIndex == (DWORD)-1 )
        {
            DebugSpew( "WARNING: Shader material %S does not have an VertexShader parameter.\n", pBaseMaterial->GetName().GetSafeString() );
            return;
        }

        // load vertex shader
        const WCHAR* strFileName = pBaseMaterial->GetRawParameter( dwParamIndex ).strValue;
        CHAR strFileNameAscii[ MAX_PATH ];
        CreateMediaPath( strFileNameAscii, ARRAYSIZE( strFileNameAscii ), strFileName, "Shaders", BaseMaterial::GetMediaRootPath() );

        HRESULT hr = ATG::LoadVertexShader( strFileNameAscii, &m_pVertexShader, &m_pVertexShaderConstantTable );

        if( FAILED( hr ) || m_pVertexShader == NULL )
        {
            DebugSpew( "ERROR: Could not load vertex shader for shader material %S.\n", pBaseMaterial->GetName().GetSafeString() );
            return;
        }

        // find pixel shader parameter (it's optional)
        dwParamIndex = pBaseMaterial->FindRawParameter( L"PixelShader" );
        if( dwParamIndex != -1 )
        {
            // load pixel shader
            strFileName = pBaseMaterial->GetRawParameter( dwParamIndex ).strValue;
            CreateMediaPath( strFileNameAscii, ARRAYSIZE( strFileNameAscii ), strFileName, "Shaders", BaseMaterial::GetMediaRootPath() );

            hr = ATG::LoadPixelShader( strFileNameAscii, &m_pPixelShader, &m_pPixelShaderConstantTable );

            if( FAILED( hr ) || m_pPixelShader == NULL )
            {
                DebugSpew( "ERROR: Could not load pixel shader for shader material %S.\n", pBaseMaterial->GetName().GetSafeString() );
            }
        }

        // bind all of the base material parameters
        DWORD dwParamCount = pBaseMaterial->GetRawParameterCount();
        for( DWORD i = 0; i < dwParamCount; ++i )
        {
            MaterialParameter& mp = pBaseMaterial->GetRawParameter( i );
            BindParameter( NULL, &mp );
        }
    }

    VOID ShaderMaterialImplementation::BindParameter( ShaderMaterialInstanceData* pInstanceData, MaterialParameter* pMP )
    {
        if( pMP->Type == MaterialParameter::RPT_String )
            return;

        const CHAR* strNameAscii = ConvertString( pMP->strName.GetSafeString() );

        D3DXCONSTANT_DESC ConstantDesc = { 0 };
        D3DXHANDLE hConstant = NULL;

        // Search for the parameter in the pixel shader constant table
        if( m_pPixelShaderConstantTable != NULL )
        {
            hConstant = m_pPixelShaderConstantTable->GetConstantByName( NULL, strNameAscii );
            if( hConstant != NULL )
            {
                UINT uValue = 1;
                m_pPixelShaderConstantTable->GetConstantDesc( hConstant, &ConstantDesc, &uValue );
                switch( pMP->Type )
                {
                case MaterialParameter::RPT_Bool:
                    ConstantDesc.RegisterIndex += 128;
                    break;
                case MaterialParameter::RPT_Float:
                    ConstantDesc.RegisterIndex += 256;
                    break;
                }
            }
        }
        // Search for the parameter in the vertex shader constant table
        if( hConstant == NULL && m_pVertexShaderConstantTable != NULL )
        {
            hConstant = m_pVertexShaderConstantTable->GetConstantByName( NULL, strNameAscii );
            if( hConstant != NULL )
            {
                UINT uValue = 1;
                m_pVertexShaderConstantTable->GetConstantDesc( hConstant, &ConstantDesc, &uValue );
            }
        }

        const WCHAR* strHint = pMP->strHint;
        if( ( strHint == NULL || strHint[0] == L'\0' ) && hConstant == NULL )
            return;

        // Use the hint field in the parameter to decode a shader constant register
        if( hConstant == NULL && strHint != NULL )
        {
            switch( strHint[0] )
            {
            case 's':
                ConstantDesc.Type = D3DXPT_TEXTURE;
                ConstantDesc.RegisterIndex = _wtoi( strHint + 1 );
                ConstantDesc.RegisterCount = 1;
                break;
            case 'c':
                ConstantDesc.Type = D3DXPT_FLOAT;
                ConstantDesc.RegisterIndex = _wtoi( strHint + 1 );
                ConstantDesc.RegisterCount = 1;
                break;
            }
        }

        // If the parameter was specified as an int parameter, and the shader matches it
        // to a float parameter, convert the parameter to a float parameter
        if( pMP->Type == MaterialParameter::RPT_Int && ConstantDesc.Type == D3DXPT_FLOAT )
        {
            pMP->fValue = (FLOAT)pMP->iValue;
            pMP->Type = MaterialParameter::RPT_Float;
            pMP->dwCount = 1;
            pMP->pFloatValues = NULL;
        }

        switch( pMP->Type )
        {
        case MaterialParameter::RPT_Texture2D:
        case MaterialParameter::RPT_Texture3D:
        case MaterialParameter::RPT_TextureCube:
            {
                // texture sampler parameter
                assert( ConstantDesc.Type == D3DXPT_TEXTURE ||
                        ConstantDesc.Type == D3DXPT_TEXTURE1D ||
                        ConstantDesc.Type == D3DXPT_TEXTURE2D ||
                        ConstantDesc.Type == D3DXPT_TEXTURE3D ||
                        ConstantDesc.Type == D3DXPT_SAMPLER ||
                        ConstantDesc.Type == D3DXPT_SAMPLER1D ||
                        ConstantDesc.Type == D3DXPT_SAMPLER2D ||
                        ConstantDesc.Type == D3DXPT_SAMPLER3D );
                if( pMP->pValue == NULL )
                    break;
                BoundTexture bt;
                bt.pTextureResource = (Texture*)pMP->pValue;
                DWORD dwSamplerIndex = ConstantDesc.RegisterIndex;
                assert( dwSamplerIndex < 16 );
                bt.dwSamplerIndex = dwSamplerIndex;
                if( pInstanceData != NULL )
                    pInstanceData->m_BoundTextures.push_back( bt );
                else
                    m_BoundTextures.push_back( bt );
                break;
            }
        case MaterialParameter::RPT_Float:
            {
                // float parameter
                assert( ConstantDesc.Type == D3DXPT_FLOAT );
                BoundFloatConstant bfc;
                bfc.dwConstantIndex = ConstantDesc.RegisterIndex;
                bfc.dwConstantCount = ConstantDesc.RegisterCount;
                assert( bfc.dwConstantCount < 256 );
                assert( bfc.dwConstantIndex < 512 );
                if( pMP->dwCount == 1 )
                    bfc.pFloatData = &pMP->fValue;
                else
                    bfc.pFloatData = pMP->pFloatValues;
                if( pInstanceData != NULL )
                    pInstanceData->m_BoundFloatConstants.push_back( bfc );
                else
                    m_BoundFloatConstants.push_back( bfc );
                break;
            }
        case MaterialParameter::RPT_Bool:
            {
                // float parameter
                assert( ConstantDesc.Type == D3DXPT_BOOL );
                BoundBoolConstant bbc;
                bbc.dwConstantIndex = ConstantDesc.RegisterIndex;
                bbc.dwConstantCount = ConstantDesc.RegisterCount;
                assert( bbc.dwConstantCount == 1 );
                assert( bbc.dwConstantIndex < 256 );
                bbc.pBoolData = &pMP->bValue;
                if( pInstanceData != NULL )
                    pInstanceData->m_BoundBoolConstants.push_back( bbc );
                else
                    m_BoundBoolConstants.push_back( bbc );
                break;
            }
        }
    }

    BOOL ShaderMaterialImplementation::IsShaderMaterial( BaseMaterial* pMaterial )
    {
        assert( pMaterial != NULL );
        DWORD dwIndex = pMaterial->FindRawParameter( L"VertexShader" );
        return ( dwIndex != (DWORD)-1 );
    }

    MaterialInstanceData ShaderMaterialImplementation::CreateInstanceData( MaterialInstance* pMaterialInstance )
    {
        assert( pMaterialInstance != NULL );

        DWORD dwParamCount = pMaterialInstance->GetRawParameterCount();
        if( dwParamCount == 0 )
            return NULL;

        ShaderMaterialInstanceData* pInstanceData = new ShaderMaterialInstanceData;

        for( DWORD i = 0; i < dwParamCount; ++i )
        {
            MaterialParameter& mp = pMaterialInstance->GetRawParameter( i );
            BindParameter( pInstanceData, &mp );
        }

        return (MaterialInstanceData)pInstanceData;
    }

    VOID ShaderMaterialImplementation::DestroyInstanceData( MaterialInstanceData Data )
    {
        ShaderMaterialInstanceData* pInstanceData = (ShaderMaterialInstanceData*)Data;
        if( pInstanceData != NULL )
            delete pInstanceData;
    }

    VOID ShaderMaterialImplementation::ChangeDevice( ::D3DDevice* pd3dDevice )
    {
    }

    VOID ShaderMaterialImplementation::BeginPass( MaterialInstanceData Data, DWORD dwIndex )
    {
    }

    VOID ShaderMaterialImplementation::EndPass( MaterialInstanceData Data )
    {
    }

    VOID ShaderMaterialImplementation::BeginMaterial( MaterialInstanceData Data, ::D3DDevice* pd3dDevice, DWORD dwMaterialVariant )
    {
        // set vertex and pixel shaders
        if( ( dwMaterialVariant & DoNotSetShaders ) == 0 )
        {
            D3DVertexShader* pCurrentVertexShader = NULL;
            pd3dDevice->GetVertexShader( &pCurrentVertexShader );
            if( pCurrentVertexShader != m_pVertexShader )
            {
                pd3dDevice->SetVertexShader( m_pVertexShader );
            }
            if( pCurrentVertexShader != NULL )
            {
                pCurrentVertexShader->Release();
            }

            D3DPixelShader* pCurrentPixelShader = NULL;
            pd3dDevice->GetPixelShader( &pCurrentPixelShader );
            if( pCurrentPixelShader != m_pPixelShader )
            {
                pd3dDevice->SetPixelShader( m_pPixelShader );
            }
            if( pCurrentPixelShader != NULL )
            {
                pCurrentPixelShader->Release();
            }
        }

        // set base material parameters
        DWORD dwCount = (DWORD)m_BoundTextures.size();
        for( DWORD i = 0; i < dwCount; ++i )
        {
            const BoundTexture& bt = m_BoundTextures[i];
            D3DBaseTexture* pTexture = bt.pTextureResource->GetD3DTexture();
            pd3dDevice->SetTexture( bt.dwSamplerIndex, pTexture );
        }
        dwCount = (DWORD)m_BoundFloatConstants.size();
        for( DWORD i = 0; i < dwCount; ++i )
        {
            const BoundFloatConstant& bfc = m_BoundFloatConstants[i];
            if( bfc.dwConstantIndex < 256 )
                pd3dDevice->SetVertexShaderConstantF( bfc.dwConstantIndex, bfc.pFloatData, bfc.dwConstantCount );
            else
                pd3dDevice->SetPixelShaderConstantF( bfc.dwConstantIndex - 256, bfc.pFloatData, bfc.dwConstantCount );
        }
        dwCount = (DWORD)m_BoundBoolConstants.size();
        for( DWORD i = 0; i < dwCount; ++i )
        {
            const BoundBoolConstant& bbc = m_BoundBoolConstants[i];
            if( bbc.dwConstantIndex < 128 )
                pd3dDevice->SetVertexShaderConstantB( bbc.dwConstantIndex, bbc.pBoolData, bbc.dwConstantCount );
            else
                pd3dDevice->SetPixelShaderConstantB( bbc.dwConstantIndex - 128, bbc.pBoolData, bbc.dwConstantCount );
        }

        // set material instance parameters
        ShaderMaterialInstanceData* pInstanceData = (ShaderMaterialInstanceData*)Data;
        if( pInstanceData != NULL )
        {
            dwCount = (DWORD)pInstanceData->m_BoundTextures.size();
            for( DWORD i = 0; i < dwCount; ++i )
            {
                const BoundTexture& bt = pInstanceData->m_BoundTextures[i];
                D3DBaseTexture* pTexture = bt.pTextureResource->GetD3DTexture();
                pd3dDevice->SetTexture( bt.dwSamplerIndex, pTexture );
            }
            dwCount = (DWORD)pInstanceData->m_BoundFloatConstants.size();
            for( DWORD i = 0; i < dwCount; ++i )
            {
                const BoundFloatConstant& bfc = pInstanceData->m_BoundFloatConstants[i];
                if( bfc.dwConstantIndex < 256 )
                    pd3dDevice->SetVertexShaderConstantF( bfc.dwConstantIndex, bfc.pFloatData, bfc.dwConstantCount );
                else
                    pd3dDevice->SetPixelShaderConstantF( bfc.dwConstantIndex - 256, bfc.pFloatData, bfc.dwConstantCount );
            }
            dwCount = (DWORD)pInstanceData->m_BoundBoolConstants.size();
            for( DWORD i = 0; i < dwCount; ++i )
            {
                const BoundBoolConstant& bbc = pInstanceData->m_BoundBoolConstants[i];
                if( bbc.dwConstantIndex < 128 )
                    pd3dDevice->SetVertexShaderConstantB( bbc.dwConstantIndex, bbc.pBoolData, bbc.dwConstantCount );
                else
                    pd3dDevice->SetPixelShaderConstantB( bbc.dwConstantIndex - 128, bbc.pBoolData, bbc.dwConstantCount );
            }
        }
    }

    VOID ShaderMaterialImplementation::EndMaterial( MaterialInstanceData Data )
    {
    }

}

```

`XenonDumper/libs/Atg/AtgMaterials.h`:

```h
//-----------------------------------------------------------------------------
// AtgMaterials.h
//
// Materials classes for the scene hierarchy.  These classes support FXLite
// materials as well as pixel/vertex shader materials.
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef ATG_MATERIALS_H
#define ATG_MATERIALS_H

#include <d3d9.h>

#include <fxl.h>
#include <vector>
#include "AtgResourceDatabase.h"

namespace ATG
{
    class BaseMaterial;
    class MaterialInstance;
    class Scene;

    //----------------------------------------------------------------------------------
    // Name: MaterialParameter
    // Desc: Struct to hold material parameter information that has been loaded from a
    //       scene file.
    //----------------------------------------------------------------------------------
    struct MaterialParameter
    {
    public:
        MaterialParameter()
            : strName( NULL ),
              dwCount( 1 ),
              Type( RPT_Other ),
              pValue( NULL ),
              bValue( FALSE ),
              strValue( NULL )
        {
        }
        enum ParameterType
        {
            RPT_Other = 0,
            RPT_Bool,
            RPT_Int,
            RPT_Float,
            RPT_String,
            RPT_Texture2D,
            RPT_TextureCube,
            RPT_Texture3D
        };
        StringID            strName;
        DWORD               dwCount;
        ParameterType       Type;
        union 
        {
            VOID*           pValue;
            FLOAT*          pFloatValues;
        };
        union
        {
            BOOL            bValue;
            INT             iValue;
            FLOAT           fValue;
        };
        StringID            strValue;
        StringID            strHint;
    };
    typedef std::vector<MaterialParameter> MaterialParameterVector;

    typedef VOID* MaterialInstanceData;


    //----------------------------------------------------------------------------------
    // Name: MaterialImplementation
    // Desc: Interface class that describes an implementation of a material, such as an
    //       FXLite effect or a set of shaders.  It is also responsible for generating
    //       and destroying instance data specific to material instances.
    //----------------------------------------------------------------------------------
    class MaterialImplementation : public NamedTypedObject
    {
        DEFINE_TYPE_INFO();
    public:
        virtual DWORD GetPassCount() const = NULL;
        virtual VOID BeginPass( MaterialInstanceData Data, DWORD dwIndex ) = NULL;
        virtual VOID EndPass( MaterialInstanceData Data ) = NULL;
        virtual VOID BeginMaterial( MaterialInstanceData Data, ::D3DDevice* pd3dDevice, DWORD dwMaterialVariant ) = NULL;
        virtual VOID EndMaterial( MaterialInstanceData Data ) = NULL;
        virtual MaterialInstanceData CreateInstanceData( MaterialInstance* pMaterialInstance ) = NULL;
        virtual VOID DestroyInstanceData( MaterialInstanceData Data ) = NULL;
        virtual VOID ChangeDevice( ::D3DDevice* pd3dDevice ) = NULL;
    };


    //----------------------------------------------------------------------------------
    // Name: ShaderIncludeHandler
    // Desc: Boilerplate code to process include files for the D3DX shader compiler and
    //       FXLite shader compiler.
    //----------------------------------------------------------------------------------
    class ShaderIncludeHandler : public ID3DXInclude
    {
    public:
        ShaderIncludeHandler( const CHAR* strBasePath );
        HRESULT __stdcall Open( D3DXINCLUDE_TYPE IncludeType, LPCSTR pFileName, LPCVOID pParentData,
                      LPCVOID* ppData, UINT* pBytes, /* OUT */ LPSTR pFullPath, DWORD cbFullPath);
        HRESULT __stdcall Close( LPCVOID pData );
    protected:
        CHAR        m_strBasePath[ MAX_PATH ];
    };


    //----------------------------------------------------------------------------------
    // Name: FXLiteMaterialImplementation
    // Desc: A material implementation class that uses FXLite to set up shaders and
    //       renderstate.
    //----------------------------------------------------------------------------------
    class FXLiteMaterialImplementation : public MaterialImplementation
    {
        DEFINE_TYPE_INFO();
    public:
        FXLiteMaterialImplementation( BaseMaterial* pBaseMaterial );
        ~FXLiteMaterialImplementation();

        static BOOL IsFXLiteMaterial( BaseMaterial* pMaterial );

        virtual DWORD GetPassCount() const { return m_dwPassCount; }
        virtual VOID BeginPass( MaterialInstanceData Data, DWORD dwIndex );
        virtual VOID EndPass( MaterialInstanceData Data );
        virtual VOID BeginMaterial( MaterialInstanceData Data, ::D3DDevice* pd3dDevice, DWORD dwMaterialVariant );
        virtual VOID EndMaterial( MaterialInstanceData Data );
        virtual MaterialInstanceData CreateInstanceData( MaterialInstance* pMaterialInstance );
        virtual VOID DestroyInstanceData( MaterialInstanceData Data );
        virtual VOID ChangeDevice( ::D3DDevice* pd3dDevice );

        static VOID SetParameterPool( FXLEffectPool* pEffectPool );
        static VOID SetNullSamplerTexture( D3DTexture* pTexture );

    protected:
        D3DXMACRO* CreateMacroList( BaseMaterial* pBaseMaterial );
        VOID CreateBinary( BYTE* pBuffer );
        VOID CreateAscii( const CHAR* strFileBuffer, const D3DXMACRO* pMacros, ShaderIncludeHandler* pShaderIncludeHandler );
        static VOID CopyParamDataToEffect( FXLEffect* pEffect, MaterialParameter* pParam );
        VOID SetNullSamplerParameters();

    public:
        DWORD           m_dwPassCount;
        FXLHANDLE       m_hTechnique;
        FXLEffect*      m_pEffect;

        struct FXLiteMaterialInstanceData
        {
            FXLEffect*  pEffect;
        };
    };


    //----------------------------------------------------------------------------------
    // Name: ShaderMaterialImplementation
    // Desc: A material implementation class that uses vertex and pixel shaders.
    //----------------------------------------------------------------------------------
    class ShaderMaterialImplementation : public MaterialImplementation
    {
        DEFINE_TYPE_INFO();
    public:
        enum MaterialFlags
        {
            DoNotSetShaders = 1,
        };
    public:
        ShaderMaterialImplementation( BaseMaterial* pBaseMaterial );
        ~ShaderMaterialImplementation();

        static BOOL IsShaderMaterial( BaseMaterial* pMaterial );

        virtual DWORD GetPassCount() const { return 1; }
        virtual VOID BeginPass( MaterialInstanceData Data, DWORD dwIndex );
        virtual VOID EndPass( MaterialInstanceData Data );
        virtual VOID BeginMaterial( MaterialInstanceData Data, ::D3DDevice* pd3dDevice, DWORD dwMaterialVariant );
        virtual VOID EndMaterial( MaterialInstanceData Data );
        virtual MaterialInstanceData CreateInstanceData( MaterialInstance* pMaterialInstance );
        virtual VOID DestroyInstanceData( MaterialInstanceData Data );
        virtual VOID ChangeDevice( ::D3DDevice* pd3dDevice );
    protected:
        struct BoundTexture
        {
            DWORD       dwSamplerIndex;
            Texture*    pTextureResource;
        };
        typedef std::vector<BoundTexture>   BoundTextureVector;

        struct BoundFloatConstant
        {
            DWORD           dwConstantIndex;
            DWORD           dwConstantCount;
            const FLOAT*    pFloatData;
        };
        typedef std::vector<BoundFloatConstant>     BoundFloatConstantVector;

        struct BoundBoolConstant
        {
            DWORD           dwConstantIndex;
            DWORD           dwConstantCount;
            const BOOL*     pBoolData;
        };
        typedef std::vector<BoundBoolConstant>     BoundBoolConstantVector;

        struct ShaderMaterialInstanceData
        {
            BoundTextureVector          m_BoundTextures;
            BoundFloatConstantVector    m_BoundFloatConstants;
            BoundBoolConstantVector     m_BoundBoolConstants;
        };

        VOID BindParameter( ShaderMaterialInstanceData* pInstanceData, MaterialParameter* pMP );

    public:
        D3DVertexShader*            m_pVertexShader;
        D3DPixelShader*             m_pPixelShader;
        ID3DXConstantTable*         m_pVertexShaderConstantTable;
        ID3DXConstantTable*         m_pPixelShaderConstantTable;
        BoundTextureVector          m_BoundTextures;
        BoundFloatConstantVector    m_BoundFloatConstants;
        BoundBoolConstantVector     m_BoundBoolConstants;
    };


    //----------------------------------------------------------------------------------
    // Name: BaseMaterial
    // Desc: Class that represents a single material type in the resource database.
    //       BaseMaterial holds data that is common to all instances of a material type,
    //       such as shaders and renderstate.
    //       Most material data is held in material instances, which are used by models
    //       in the scene.
    //----------------------------------------------------------------------------------
    class BaseMaterial : public Resource
    {
        DEFINE_TYPE_INFO();
    public:
        BaseMaterial();
        ~BaseMaterial();

        static BaseMaterial* CreateFXLiteMaterial( StringID MaterialName, 
                                                   StringID FXLiteFilePath, 
                                                   StringID TechniqueName = NULL );

        static BaseMaterial* CreateShaderMaterial( StringID MaterialName,
                                                   StringID VertexShaderFileName,
                                                   StringID VertexShaderEntryPoint,
                                                   StringID PixelShaderFileName = NULL,
                                                   StringID PixelShaderEntryPoint = NULL );

        DWORD GetRawParameterCount() const { return (DWORD)m_RawParameters.size(); }
        DWORD AddRawParameter( const MaterialParameter& RawParam ) { m_RawParameters.push_back( RawParam ); return GetRawParameterCount() - 1; }
        MaterialParameter& GetRawParameter( DWORD dwIndex ) { return m_RawParameters[dwIndex]; }
        DWORD FindRawParameter( const StringID Name ) const;

        MaterialInstanceData InitializeInstance( MaterialInstance* pMaterialInstance );

        static VOID SetMediaRootPath( const CHAR* strMediaRootPath );
        static const CHAR* GetMediaRootPath() { return m_strMediaRootPath; }

        MaterialImplementation* GetMaterialImplementation() const { return m_pMaterialImplementation; }
        VOID InitializeImplementation();
        VOID ChangeDevice( ::D3DDevice* pd3dDevice );

        VOID BindTextures( const CHAR* strMediaRootPath, Scene* pScene );

        DWORD GetPassCount() const;
        VOID BeginPass( MaterialInstanceData Data, DWORD dwIndex );
        VOID EndPass( MaterialInstanceData Data );
        VOID BeginMaterial( MaterialInstanceData Data, ::D3DDevice* pd3dDevice, DWORD dwMaterialVariant );
        VOID EndMaterial( MaterialInstanceData Data );

    protected:
        MaterialParameterVector     m_RawParameters;
        MaterialImplementation*     m_pMaterialImplementation;
        BOOL                        m_bTexturesBound;
        static CHAR                 m_strMediaRootPath[ MAX_PATH ];
    };


    //----------------------------------------------------------------------------------
    // Name: MaterialInstance
    // Desc: Class that represents an instance of a material.  For example, a material
    //       might be a particular vertex and pixel shader, where an instance would be
    //       the textures and renderstates used with those shaders for rendering a
    //       particular model.
    //----------------------------------------------------------------------------------
    class MaterialInstance : public NamedTypedObject
    {
        DEFINE_TYPE_INFO();
    public:
        MaterialInstance();
        ~MaterialInstance();

        DWORD GetRawParameterCount() const { return (DWORD)m_RawParameters.size(); }
        DWORD AddRawParameter( const MaterialParameter& RawParam ) { m_RawParameters.push_back( RawParam ); return GetRawParameterCount() - 1; }
        MaterialParameter& GetRawParameter( DWORD dwIndex ) { return m_RawParameters[dwIndex]; }
        DWORD FindRawParameter( const StringID Name ) const;

        VOID SetMaterialBindingIndex( DWORD dwIndex = 0 );
        DWORD GetMaterialBindingIndex() const { return m_dwCurrentBindingIndex; }
        VOID AllocateMaterialBindings( DWORD dwMaxCount );
        DWORD GetMaterialBindingCount() const { return (DWORD)m_MaterialBindings.size(); }

        VOID SetBaseMaterial( BaseMaterial* pBM );
        BaseMaterial* GetBaseMaterial() const { return m_MaterialBindings[m_dwCurrentBindingIndex].pMaterial; }

        VOID SetBaseMaterialName( StringID Name ) { m_OriginalMaterialName = Name; }
        StringID GetBaseMaterialName() const { return m_OriginalMaterialName; }

        VOID Initialize();
        VOID BindTextures( const CHAR* strMediaRootPath, Scene* pScene );

        DWORD GetPassCount() const;
        VOID BeginPass( DWORD dwIndex );
        VOID EndPass();
        VOID BeginMaterial( ::D3DDevice* pd3dDevice, DWORD dwMaterialVariant = 0 );
        VOID EndMaterial();

        VOID BeginMaterialSinglePass( ::D3DDevice* pd3dDevice, DWORD dwMaterialVariant = 0 );
        VOID EndMaterialSinglePass();

        BOOL IsTransparent() const { return m_bTransparent; }
        VOID SetTransparent( BOOL bTransparent ) { m_bTransparent = bTransparent; }

    protected:
        MaterialInstanceData GetInstanceData() const { return m_MaterialBindings[m_dwCurrentBindingIndex].pMaterialInstanceData; }

        struct MaterialPair
        {
            BaseMaterial*           pMaterial;
            MaterialInstanceData    pMaterialInstanceData;
        };
        typedef std::vector<MaterialPair> MaterialPairVector;
        MaterialPairVector          m_MaterialBindings;
        DWORD                       m_dwCurrentBindingIndex;

        StringID                    m_OriginalMaterialName;
        MaterialParameterVector     m_RawParameters;
        BOOL                        m_bTexturesBound;
        BOOL                        m_bTransparent;
    };
}

#endif

```

`XenonDumper/libs/Atg/AtgMediaLocator.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// AtgMediaLocator.cpp
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------


#include "stdafx.h"
#include <xuiresource.h.>
#include "AtgMediaLocator.h"


namespace ATG
{


const WCHAR XZP_SEPARATOR  = L'#';
const WCHAR MEDIA_FOLDER[] = { L"media/" };

//--------------------------------------------------------------------------------------
// Name: LocateMediaFolder()
// Desc: Retrieve the path to the media folder that sits inside the xzp archive 
//       specified in szPackage. If the function succeeds, it returns TRUE and 
//       szMediaPath contains the relative path to the media folder 
//       (eg: "..\..\media\"). If the function fails, it returns FALSE and szMediaPath
//       is unaffected.
//--------------------------------------------------------------------------------------
BOOL LocateMediaFolder( LPWSTR szMediaPath, DWORD dwMediaPathSize, LPCWSTR szPackage )
{
    // Open the archive file
    HXUIPACKAGE hPackage;
    HRESULT hr = XuiResourceOpenPackage( const_cast< LPWSTR >( szPackage ), &hPackage, FALSE );
    if( hr != S_OK )
        return FALSE;

    UINT entryCount = XuiResourceGetPackageEntryCount( hPackage );
    WCHAR szLocator[ LOCATOR_SIZE ];
    UINT LocatorSize = ARRAYSIZE( szLocator );
    for( UINT i = 0; i < entryCount; ++ i )
    {
        hr = XuiResourceGetPackageEntryInfo( hPackage, i, szLocator, &LocatorSize, NULL, NULL, NULL );

        LPWSTR szPathStart = wcschr( szLocator, XZP_SEPARATOR ) + 1;
        assert( szPathStart != NULL );

        LPWSTR szMediaFolder = wcsstr( szPathStart, MEDIA_FOLDER );
        if( szMediaFolder != NULL )
        {
            wcsncpy_s( szMediaPath, 
                       dwMediaPathSize, 
                       szPathStart, 
                       szMediaFolder + wcslen( MEDIA_FOLDER ) - szPathStart );
            XuiResourceReleasePackage( hPackage );
            return TRUE;
            break;
        }
    }

    XuiResourceReleasePackage( hPackage );
    return FALSE;
}


//--------------------------------------------------------------------------------------
// Name: ComposeResourceLocator()
// Desc: Combines the strings from szPackage, szBaseDirectory, szPath and szFile into a 
//       valid resource locator. If successful, the function returns TRUE and szLocator 
//       points to the newly composed resource locator. If it fails, the function 
//       returns FALSE and the content of szLocator is undetermined.
//
// Note: szPackage is required and cannot be NULL, the other input parameters can be set 
//       to NULL if desired.
//--------------------------------------------------------------------------------------
BOOL ComposeResourceLocator( LPWSTR szLocator, DWORD dwLocatorSize, 
                             LPCWSTR szPackage, LPCWSTR szBaseDirectory, LPCWSTR szPath, LPCWSTR szFile )
{
    assert( szPackage != NULL );

    if( wcscpy_s( szLocator, dwLocatorSize, szPackage ) != 0 )
        return FALSE;

    if( wcscat_s( szLocator, dwLocatorSize, L"#" ) != 0 )
        return FALSE;

    if( szBaseDirectory != NULL )
    {
        if( wcscat_s( szLocator, dwLocatorSize, szBaseDirectory ) != 0 )
            return FALSE;
    }

    if( szPath != NULL )
    {
        if( wcscat_s( szLocator, dwLocatorSize, szPath ) != 0 )
            return FALSE;
    }

    if( szFile != NULL )
    {
        if( wcscat_s( szLocator, dwLocatorSize, szFile ) != 0 )
            return FALSE;
    }

    return TRUE;
}
    

//--------------------------------------------------------------------------------------
// Name: MediaLocator::MediaLocator()
// Desc: Constructs a MediaLocator object with default values. The caller should call 
//       SetPackage() before using the class.
//--------------------------------------------------------------------------------------
MediaLocator::MediaLocator()
{ 
    m_szPackage[ 0 ] = L'\0'; 
    m_szMediaPath[ 0 ] = L'\0'; 
}


//--------------------------------------------------------------------------------------
// Name: MediaLocator::MediaLocator()
// Desc: Constructs a MediaLocator object for use with the specified xzp archive.
//--------------------------------------------------------------------------------------
MediaLocator::MediaLocator( LPCWSTR szPackage ) 
{ 
    wcscpy_s( m_szPackage, szPackage ); 
    m_szMediaPath[ 0 ] = L'\0'; 
}


//--------------------------------------------------------------------------------------
// Name: MediaLocator::SetPackage()
// Desc: Replace the current working xzp archive with a new one.
//--------------------------------------------------------------------------------------
VOID MediaLocator::SetPackage( LPCWSTR szPackage )
{ 
    wcscpy_s( m_szPackage, szPackage ); 
    m_szMediaPath[ 0 ] = L'\0'; 
}

//--------------------------------------------------------------------------------------
// Name: MediaLocator::GetMediaPath()
// Desc: Retrieves the path to the media folder that sits inside the xzp archive.
//--------------------------------------------------------------------------------------
LPCWSTR MediaLocator::GetMediaPath() const
{ 
    if( m_szMediaPath[ 0 ] == L'\0' && m_szPackage[ 0 ] != L'\0' )
    { 
        LocateMediaFolder( m_szMediaPath, ARRAYSIZE( m_szMediaPath ), m_szPackage ); 
    } 
    
    return m_szMediaPath; 
}


//--------------------------------------------------------------------------------------
// Name: MediaLocator::ComposeResourceLocator()
// Desc: If succesful, returns TRUE and szLocator contains the resource locator for the
//       file identified by szPath and szFile that sits inside the media folder of the 
//       xzp archive. It returns FALSE upon failure.
//--------------------------------------------------------------------------------------
BOOL MediaLocator::ComposeResourceLocator( LPWSTR szLocator, DWORD dwLocatorSize, 
                                           LPCWSTR szPath, LPCWSTR szFile         ) const
{ 
   if( m_szPackage[ 0 ] == L'\0' )
       return FALSE;

   return ATG::ComposeResourceLocator( szLocator, dwLocatorSize, m_szPackage, GetMediaPath(), szPath, szFile ); 
}


} // namespace ATG
```

`XenonDumper/libs/Atg/AtgMediaLocator.h`:

```h
//--------------------------------------------------------------------------------------
// AtgMediaLocator.h
//
// Helper functions and class providing support for locating media files inside and xzp 
// archive.
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------


#pragma once
#ifndef ATGMEDIALOCATOR_H
#define ATGMEDIALOCATOR_H


namespace ATG
{


const DWORD LOCATOR_SIZE = 256; // Use this to allocate space to hold a ResourceLocator string 


BOOL LocateMediaFolder(  LPWSTR szMediaPath, DWORD dwMediaPathSize, LPWSTR szPackage );

BOOL ComposeResourceLocator( LPWSTR szLocator, DWORD dwLocatorSize, LPCWSTR szPackage, LPCWSTR szBaseDirectory, LPCWSTR szPath, LPCWSTR szFile );


//--------------------------------------------------------------------------------------
// Name: class MediaLocator
// Desc: Find paths to files in the media folder that sits inside an xzp archive.
//--------------------------------------------------------------------------------------
class MediaLocator
{
public:
    MediaLocator();
    MediaLocator( LPCWSTR szPackage );
    ~MediaLocator() {}

    VOID SetPackage( LPCWSTR szPackage );
    LPCWSTR GetMediaPath() const;

    BOOL ComposeResourceLocator( LPWSTR szLocator, DWORD dwpLocatorSize, LPCWSTR szPath, LPCWSTR szFile ) const;

private:
    MediaLocator( const MediaLocator& mediaLocator );
    MediaLocator& operator =( const MediaLocator& mediaLocator );

    WCHAR m_szPackage[ LOCATOR_SIZE ];
    mutable WCHAR m_szMediaPath[ LOCATOR_SIZE ];
};


} // namespace ATG


#endif // ATGMEDIARESOURCE_H
```

`XenonDumper/libs/Atg/AtgMesh.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// AtgMesh.cpp
//
// Support code for loading sample geometry. See the header for details.
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#include "stdafx.h"
#include "AtgDevice.h"
#include "AtgMesh.h"
#include "AtgResource.h"
#include "AtgUtil.h"

namespace ATG
{

extern D3DDevice* g_pd3dDevice;


//--------------------------------------------------------------------------------------
// Name: Mesh2()
// Desc: Constructor
//--------------------------------------------------------------------------------------
Mesh2::Mesh2()
{
    m_pAllocatedSysMem = NULL;
    m_pAllocatedVidMem = NULL;
    m_pMeshData = NULL;
}


//--------------------------------------------------------------------------------------
// Name: ~Mesh2()
// Desc: Destructor
//--------------------------------------------------------------------------------------
Mesh2::~Mesh2()
{
    delete[] m_pAllocatedSysMem;
    if( m_pAllocatedVidMem )
        XPhysicalFree( m_pAllocatedVidMem );
}


//--------------------------------------------------------------------------------------
// Name: Create()
// Desc: Creates a mesh from an XBG file
//--------------------------------------------------------------------------------------
HRESULT Mesh2::Create( const CHAR* strFilename, const PackedResource* pResource )
{
    // Open the file
    DWORD dwNumBytesRead;
    HANDLE hFile = CreateFile( strFilename, GENERIC_READ, FILE_SHARE_READ, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL );
    if( hFile == INVALID_HANDLE_VALUE )
    {
        ATG_PrintError( "File not found!\n" );
        return E_FAIL;
    }

    // Read the magic number
    XBG_HEADER xbgHeader;
    if( !ReadFile( hFile, &xbgHeader, sizeof( XBG_HEADER ), &dwNumBytesRead, NULL ) )
    {
        CloseHandle( hFile );
        ATG_PrintError( "Unable to read file header!\n" );
        return E_FAIL;
    }

    if( xbgHeader.dwMagic != XBG7_FILE_ID )
    {
        CloseHandle( hFile );
        ATG_PrintError( "Invalid XBG file type!\n" );
        return E_FAIL;
    }

    // Read in system memory objects
    DWORD dwSysMemSize = xbgHeader.dwSysMemSize;
    m_pAllocatedSysMem = ( VOID* )new BYTE[dwSysMemSize];

    if( !ReadFile( hFile, m_pAllocatedSysMem, dwSysMemSize, &dwNumBytesRead, NULL ) )
    {
        CloseHandle( hFile );
        ATG_PrintError( "Unable to read system memory objects!\n" );
        return E_FAIL;
    }

    // Read in video memory objects
    DWORD dwVidMemSize = xbgHeader.dwVidMemSize;
    m_pAllocatedVidMem = ( BYTE* )XPhysicalAllocEx( dwVidMemSize, 0, MAXULONG_PTR,
                                                    D3DVERTEXBUFFER_ALIGNMENT,
                                                    PAGE_READWRITE | PAGE_WRITECOMBINE );

    if( !ReadFile( hFile, m_pAllocatedVidMem, dwVidMemSize, &dwNumBytesRead, NULL ) )
    {
        CloseHandle( hFile );
        ATG_PrintError( "Unable to read video memory objects!\n" );
        return E_FAIL;
    }

    // Done with the file
    CloseHandle( hFile );

    // Now we need to patch the mesh data. Any pointers read from the file were
    // stored as file offsets. So, we simply need to add a base address to patch
    // things up.
    MESH_FRAME* pFrames = ( MESH_FRAME* )m_pAllocatedSysMem;

    DWORD dwPatchOffset = ( DWORD )m_pAllocatedSysMem - sizeof( XBG_HEADER );

    // Note: for a simple mesh class, we only consider the first frame
    m_pMeshData = ( MESH_DATA* )( ( DWORD )pFrames[0].m_pMeshData + dwPatchOffset );

    // Patch up the GPU addresses
    XGOffsetResourceAddress( &m_pMeshData->m_VB, m_pAllocatedVidMem );
    XGOffsetResourceAddress( &m_pMeshData->m_IB, m_pAllocatedVidMem );

    // Create a vertex declaration for the mesh
    g_pd3dDevice->CreateVertexDeclaration( m_pMeshData->m_VertexElements, &m_pMeshData->m_pVertexDecl );

    // Finally, create any textures used by the meshes' subsets. In this 
    // implementation, we are pulling textures out of the passed in resource.
    if( pResource )
    {
        for( DWORD i = 0; i < m_pMeshData->m_dwNumSubsets; i++ )
        {
            m_pMeshData->m_pSubsets[i].pTexture = pResource->GetTexture( m_pMeshData->m_pSubsets[i].strTexture );
        }
    }

    return S_OK;
}


//-------------------------------------------------------------------------------------
// Name: Render()
// Desc: Renders the mesh geometry
//-------------------------------------------------------------------------------------
VOID MESH_DATA::Render( DWORD dwFlags )
{
    if( m_dwNumVertices == 0 )
        return;

    // Set the vertex stream
    g_pd3dDevice->SetStreamSource( 0, &m_VB, 0, m_dwVertexSize );
    g_pd3dDevice->SetIndices( &m_IB );

    // Set the vertex declaration
    if( 0 == ( dwFlags & MESH_NOVERTEXDECL ) )
        g_pd3dDevice->SetVertexDeclaration( m_pVertexDecl );

    // Render the subsets
    for( DWORD i = 0; i < m_dwNumSubsets; i++ )
    {
        BOOL bRender = FALSE;

        // Render the opaque subsets, unless the user asked us not to
        if( 0 == ( dwFlags & MESH_ALPHAONLY ) )
        {
            if( 0 == ( dwFlags & MESH_NOMATERIALS ) )
            {
                if( m_pSubsets[i].mtrl.Diffuse.a >= 1.0f )
                    bRender = TRUE;
            }
            else
                bRender = TRUE;
        }

        // Render the transparent subsets, unless the user asked us not to
        if( 0 == ( dwFlags & MESH_OPAQUEONLY ) )
        {
            if( 0 == ( dwFlags & MESH_NOMATERIALS ) )
            {
                if( m_pSubsets[i].mtrl.Diffuse.a < 1.0f )
                    bRender = TRUE;
            }
        }

        if( bRender )
        {
            // Set the texture, unless the user asked us not to
            if( 0 == ( dwFlags & MESH_NOTEXTURES ) && m_pSubsets[i].pTexture )
                g_pd3dDevice->SetTexture( 0, m_pSubsets[i].pTexture );

            // Draw the mesh subset
            g_pd3dDevice->DrawIndexedPrimitive( m_dwPrimType, 0, 0, m_dwNumVertices,
                                                m_pSubsets[i].dwIndexStart,
                                                m_pSubsets[i].dwPrimitiveCount );
        }
    }
}


//--------------------------------------------------------------------------------------
// Name: Mesh()
// Desc: Constructor
//--------------------------------------------------------------------------------------
Mesh::Mesh()
{
    m_pAllocatedSysMem = NULL;
    m_pAllocatedVidMem = NULL;
    m_pFrames = NULL;
    m_dwNumFrames = 0;
}


//--------------------------------------------------------------------------------------
// Name: ~Mesh()
// Desc: Destructor
//--------------------------------------------------------------------------------------
Mesh::~Mesh()
{
    delete[] m_pAllocatedSysMem;
    if( m_pAllocatedVidMem )
        XPhysicalFree( m_pAllocatedVidMem );
}


//--------------------------------------------------------------------------------------
// Name: Create()
// Desc: Creates a mesh from an XBG file
//--------------------------------------------------------------------------------------
HRESULT Mesh::Create( const CHAR* strFilename, const PackedResource* pResource )
{
    // Open the file
    DWORD dwNumBytesRead;
    HANDLE hFile = CreateFile( strFilename, GENERIC_READ, FILE_SHARE_READ, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL );
    if( hFile == INVALID_HANDLE_VALUE )
    {
        ATG_PrintError( "File not found!\n" );
        return E_FAIL;
    }

    // Read the magic number
    XBG_HEADER xbgHeader;
    if( !ReadFile( hFile, &xbgHeader, sizeof( XBG_HEADER ), &dwNumBytesRead, NULL ) )
    {
        CloseHandle( hFile );
        ATG_PrintError( "Unable to read file header!\n" );
        return E_FAIL;
    }

    if( xbgHeader.dwMagic != XBG7_FILE_ID )
    {
        CloseHandle( hFile );
        ATG_PrintError( "Invalid XBG file type!\n" );
        return E_FAIL;
    }

    // Read in system memory objects
    DWORD dwSysMemSize = xbgHeader.dwSysMemSize;
    m_pAllocatedSysMem = ( VOID* )new BYTE[dwSysMemSize];
    if( !m_pAllocatedSysMem )
    {
        CloseHandle( hFile );
        ATG_PrintError( "Unable to allocate system memory!\n" );
        return E_FAIL;
    }

    if( !ReadFile( hFile, m_pAllocatedSysMem, dwSysMemSize, &dwNumBytesRead, NULL ) )
    {
        CloseHandle( hFile );
        ATG_PrintError( "Unable to read system memory objects!\n" );
        return E_FAIL;
    }

    // Read in video memory objects
    DWORD dwVidMemSize = xbgHeader.dwVidMemSize;
    m_pAllocatedVidMem = ( BYTE* )XPhysicalAllocEx( dwVidMemSize, 0, MAXULONG_PTR,
                                                    D3DVERTEXBUFFER_ALIGNMENT,
                                                    PAGE_READWRITE | PAGE_WRITECOMBINE );

    if( !m_pAllocatedVidMem )
    {
        CloseHandle( hFile );
        ATG_PrintError( "Unable to allocate video memory!\n" );
        return E_FAIL;
    }

    if( !ReadFile( hFile, m_pAllocatedVidMem, dwVidMemSize, &dwNumBytesRead, NULL ) )
    {
        CloseHandle( hFile );
        ATG_PrintError( "Unable to read video memory objects!\n" );
        return E_FAIL;
    }

    // Done with the file
    CloseHandle( hFile );

    // Now we need to patch the mesh data. Any pointers read from the file were
    // stored as file offsets. So, we simply need to add a base address to patch
    // things up.
    DWORD dwPatchOffset = ( DWORD )m_pAllocatedSysMem - sizeof( XBG_HEADER );

    m_pFrames = ( MESH_FRAME* )m_pAllocatedSysMem;
    m_dwNumFrames = xbgHeader.dwNumFrames;

    for( DWORD i = 0; i < m_dwNumFrames; i++ )
    {
        MESH_FRAME* pFrame = &m_pFrames[i];

        // Patch up the frame and meshdata pointers
        if( pFrame->m_pMeshData )
            pFrame->m_pMeshData = ( MESH_DATA* )( ( DWORD )pFrame->m_pMeshData + dwPatchOffset );
        if( pFrame->m_pChild )
            pFrame->m_pChild = ( MESH_FRAME* )( ( DWORD )pFrame->m_pChild + dwPatchOffset );
        if( pFrame->m_pNext )
            pFrame->m_pNext = ( MESH_FRAME* )( ( DWORD )pFrame->m_pNext + dwPatchOffset );

        if( pFrame->m_pMeshData && pFrame->m_pMeshData->m_dwNumSubsets )
        {
            // Patch up the GPU addresses
            XGOffsetResourceAddress( &pFrame->m_pMeshData->m_VB, m_pAllocatedVidMem );
            XGOffsetResourceAddress( &pFrame->m_pMeshData->m_IB, m_pAllocatedVidMem );

            // Create a vertex declaration for the mesh
            g_pd3dDevice->CreateVertexDeclaration( pFrame->m_pMeshData->m_VertexElements,
                                                   &pFrame->m_pMeshData->m_pVertexDecl );

            // Finally, create any textures used by the meshes' subsets. In this 
            // implementation, we are pulling textures out of the passed in resource.
            if( pResource )
            {
                for( DWORD j = 0; j < pFrame->m_pMeshData->m_dwNumSubsets; j++ )
                {
                    MESH_SUBSET* pSubset = &pFrame->m_pMeshData->m_pSubsets[j];
                    pSubset->pTexture = pResource->GetTexture( pSubset->strTexture );
                }
            }
        }
    }

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: Write()
// Desc: Writes the mesh to an XBG file
//--------------------------------------------------------------------------------------
HRESULT Mesh::Write( const CHAR* strFilename )
{
    // Open the file
    DWORD dwNumBytesWritten;
    HANDLE hFile = CreateFile( strFilename, FILE_ALL_ACCESS, 0, NULL,
                               CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
    if( hFile == INVALID_HANDLE_VALUE )
    {
        ATG_PrintError( "File not found!\n" );
        return E_FAIL;
    }

    // Compute storage requirements
    DWORD g_dwFrameSpace = 0;
    DWORD g_dwMeshSpace = 0;
    DWORD g_dwVertexSpace = 0;
    DWORD g_dwIndexSpace = 0;

    for( DWORD i = 0; i < m_dwNumFrames; i++ )
    {
        MESH_FRAME* pFrame = &m_pFrames[i];
        MESH_DATA* pMesh = pFrame->m_pMeshData;

        DWORD dwIndexSize = pMesh->m_IB.Common & D3DINDEXBUFFER_INDEX32 ? sizeof( DWORD ) : sizeof( WORD );

        g_dwFrameSpace += sizeof( MESH_FRAME );
        g_dwMeshSpace += sizeof( MESH_DATA ) - sizeof( MESH_SUBSET );
        g_dwMeshSpace += sizeof( MESH_SUBSET ) * pMesh->m_dwNumSubsets;
        g_dwIndexSpace += ( ( dwIndexSize * pMesh->m_dwNumIndices + ( 4096 - 1 ) ) / 4096 ) * 4096;
        g_dwVertexSpace += ( ( pMesh->m_dwVertexSize * pMesh->m_dwNumVertices + ( 4096 - 1 ) ) / 4096 ) * 4096;
    }
    DWORD dwNumSysMemBytes = g_dwFrameSpace + g_dwMeshSpace;
    DWORD dwNumVidMemBytes = g_dwIndexSpace + g_dwVertexSpace;

    // Read the magic number
    XBG_HEADER xbgHeader;
    xbgHeader.dwMagic = XBG7_FILE_ID;
    xbgHeader.dwSysMemSize = dwNumSysMemBytes;
    xbgHeader.dwVidMemSize = dwNumVidMemBytes;
    xbgHeader.dwNumFrames = m_dwNumFrames;
    WriteFile( hFile, &xbgHeader, sizeof( XBG_HEADER ), &dwNumBytesWritten, NULL );

    DWORD g_dwFramesFileOffset = sizeof( XBG_HEADER );
    DWORD g_dwMeshesFileOffset = g_dwFramesFileOffset + g_dwFrameSpace;
    DWORD g_dwIndicesFileOffset = 0;
    DWORD g_dwVerticesFileOffset = g_dwIndexSpace;

    // Write the frames
    for( DWORD i = 0; i < m_dwNumFrames; i++ )
    {
        MESH_FRAME* pFrame = &m_pFrames[i];
        MESH_DATA* pMesh = pFrame->m_pMeshData;

        // Write out the frame
        MESH_FRAME frame = *pFrame;
        frame.Pad[0] = 0x11111111;

        if( pFrame->m_pChild )
        {
            DWORD dwOffset = ( DWORD )pFrame->m_pChild - ( DWORD )m_pFrames;
            frame.m_pChild = ( MESH_FRAME* )( g_dwFramesFileOffset + dwOffset );
        }
        if( pFrame->m_pNext )
        {
            DWORD dwOffset = ( DWORD )pFrame->m_pNext - ( DWORD )m_pFrames;
            frame.m_pNext = ( MESH_FRAME* )( g_dwFramesFileOffset + dwOffset );
        }

        frame.m_pMeshData = ( MESH_DATA* )g_dwMeshesFileOffset;
        g_dwMeshesFileOffset += ( sizeof( MESH_DATA ) - sizeof( MESH_SUBSET ) ) + sizeof( MESH_SUBSET ) *
            pMesh->m_dwNumSubsets;

        // Write out frame info
        WriteFile( hFile, &frame, sizeof( MESH_FRAME ), &dwNumBytesWritten, NULL );
    }

    // Write the meshes
    for( DWORD i = 0; i < m_dwNumFrames; i++ )
    {
        MESH_FRAME* pFrame = &m_pFrames[i];
        MESH_DATA* pMesh = pFrame->m_pMeshData;

        DWORD dwIndexSize = pMesh->m_IB.Common & D3DINDEXBUFFER_INDEX32 ? sizeof( DWORD ) : sizeof( WORD );
        D3DFORMAT d3dIndexFormat = pMesh->m_IB.Common & D3DINDEXBUFFER_INDEX32 ? D3DFMT_INDEX32 : D3DFMT_INDEX16;

        // Write out the meshdata
        MESH_DATA mesh = *pMesh;

        if( pMesh->m_dwNumVertices )
        {
            XGSetVertexBufferHeader( pMesh->m_dwNumVertices * pMesh->m_dwVertexSize,
                                     0, D3DPOOL_DEFAULT, g_dwVerticesFileOffset,
                                     &mesh.m_VB );
            g_dwVerticesFileOffset += ( ( pMesh->m_dwVertexSize * pMesh->m_dwNumVertices + ( 4096 - 1 ) ) / 4096 ) *
                4096;
        }

        if( mesh.m_dwNumIndices )
        {
            XGSetIndexBufferHeader( pMesh->m_dwNumIndices * dwIndexSize,
                                    0, d3dIndexFormat, D3DPOOL_DEFAULT, g_dwIndicesFileOffset,
                                    &mesh.m_IB );
            g_dwIndicesFileOffset += ( ( pMesh->m_dwNumIndices * dwIndexSize + ( 4096 - 1 ) ) / 4096 ) * 4096;
        }

        mesh.m_pVertexDecl = NULL;

        // Write out mesh info
        WriteFile( hFile, &mesh, sizeof( MESH_DATA ) - sizeof( MESH_SUBSET ), &dwNumBytesWritten, NULL );

        // Write out subset data
        for( DWORD j = 0; j < pMesh->m_dwNumSubsets; j++ )
        {
            MESH_SUBSET subset = pMesh->m_pSubsets[j];
            subset.Pad[0] = 0x11111111;
            subset.pTexture = NULL;

            WriteFile( hFile, &subset, sizeof( MESH_SUBSET ), &dwNumBytesWritten, NULL );
        }
    }

    static BYTE Pad[4096] =
    {
        0
    };

    // Write indices
    for( DWORD i = 0; i < m_dwNumFrames; i++ )
    {
        MESH_FRAME* pFrame = &m_pFrames[i];
        MESH_DATA* pMesh = pFrame->m_pMeshData;

        if( pMesh->m_dwNumIndices )
        {
            VOID* pIndexData;
            DWORD dwIndexSize = pMesh->m_IB.Common & D3DINDEXBUFFER_INDEX32 ? sizeof( DWORD ) : sizeof( WORD );
            DWORD dwSize = pMesh->m_dwNumIndices * dwIndexSize;

            pMesh->m_IB.Lock( 0, 0, &pIndexData, 0 );
            WriteFile( hFile, pIndexData, dwSize, &dwNumBytesWritten, NULL );
            pMesh->m_IB.Unlock();

            // Pad to aligment
            DWORD dwPadSize = ( 4096 - ( dwSize % 4096 ) ) % 4096;
            if( dwPadSize )
                WriteFile( hFile, Pad, dwPadSize, &dwNumBytesWritten, NULL );
        }
    }

    // Write vertices
    for( DWORD i = 0; i < m_dwNumFrames; i++ )
    {
        MESH_FRAME* pFrame = &m_pFrames[i];
        MESH_DATA* pMesh = pFrame->m_pMeshData;

        if( pMesh->m_dwNumVertices )
        {
            VOID* pVertexData;
            DWORD dwSize = pMesh->m_dwNumVertices * pMesh->m_dwVertexSize;

            pMesh->m_VB.Lock( 0, 0, &pVertexData, 0 );
            WriteFile( hFile, pVertexData, dwSize, &dwNumBytesWritten, NULL );
            pMesh->m_VB.Unlock();

            // Pad to aligment
            DWORD dwPadSize = ( 4096 - ( dwSize % 4096 ) ) % 4096;
            if( dwPadSize )
                WriteFile( hFile, Pad, dwPadSize, &dwNumBytesWritten, NULL );
        }
    }

    // Done with the file
    CloseHandle( hFile );

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: Render()
// Desc: Renders the hierarchy of frames and meshes
//--------------------------------------------------------------------------------------
VOID Mesh::Render( DWORD dwFlags )
{
    if( m_pFrames )
        RenderFrame( m_pFrames, dwFlags );
}


//--------------------------------------------------------------------------------------
// Name: RenderFrame()
// Desc: Renders a frame (save state, apply matrix, render children, restore)
//--------------------------------------------------------------------------------------
VOID Mesh::RenderFrame( const MESH_FRAME* pFrame, DWORD dwFlags )
{
    // Apply the frame's local transform
    XMMATRIX matSavedWorld = m_matWorld;
    m_matWorld = XMMatrixMultiply( pFrame->m_matTransform, m_matWorld );

    // Render the mesh data
    if( pFrame->m_pMeshData->m_dwNumSubsets )
    {
        // Call the callback, so the app can tweak state before rendering the mesh
        DWORD dwFrame = pFrame - m_pFrames;
        RenderMeshCallback( dwFrame, pFrame, dwFlags );

        RenderMesh( pFrame->m_pMeshData, dwFlags );
    }

    // Render any child frames
    if( pFrame->m_pChild )
        RenderFrame( pFrame->m_pChild, dwFlags );

    // Restore the transformation matrix
    m_matWorld = matSavedWorld;

    // Render any sibling frames
    if( pFrame->m_pNext )
        RenderFrame( pFrame->m_pNext, dwFlags );
}


//--------------------------------------------------------------------------------------
// Name: RenderMesh()
// Desc: Renders the mesh geometry
//--------------------------------------------------------------------------------------
VOID Mesh::RenderMesh( MESH_DATA* pMesh, DWORD dwFlags )
{
    D3DVertexBuffer* pVB = &pMesh->m_VB;
    DWORD dwNumVertices = pMesh->m_dwNumVertices;
    D3DIndexBuffer* pIB = &pMesh->m_IB;
    DWORD dwVertexSize = pMesh->m_dwVertexSize;
    D3DPRIMITIVETYPE dwPrimType = pMesh->m_dwPrimType;
    DWORD dwNumSubsets = pMesh->m_dwNumSubsets;
    MESH_SUBSET* pSubsets = &pMesh->m_pSubsets[0];

    if( dwNumVertices == 0 )
        return;

    // Set the vertex stream
    g_pd3dDevice->SetStreamSource( 0, pVB, 0, dwVertexSize );
    g_pd3dDevice->SetIndices( pIB );

    // Set the vertex declaration
    if( 0 == ( dwFlags & MESH_NOVERTEXDECL ) )
    {
        g_pd3dDevice->SetVertexDeclaration( pMesh->m_pVertexDecl );
    }

    // Render the subsets
    for( DWORD i = 0; i < dwNumSubsets; i++ )
    {
        BOOL bRender = FALSE;

        // Render the opaque subsets, unless the user asked us not to
        if( 0 == ( dwFlags & MESH_ALPHAONLY ) )
        {
            if( 0 == ( dwFlags & MESH_NOMATERIALS ) )
            {
                if( pSubsets[i].mtrl.Diffuse.a >= 1.0f )
                    bRender = TRUE;
            }
            else
                bRender = TRUE;
        }

        // Render the transparent subsets, unless the user asked us not to
        if( 0 == ( dwFlags & MESH_OPAQUEONLY ) )
        {
            if( 0 == ( dwFlags & MESH_NOMATERIALS ) )
            {
                if( pSubsets[i].mtrl.Diffuse.a < 1.0f )
                    bRender = TRUE;
            }
        }

        if( bRender )
        {
            // Set the texture, unless the user asked us not to
            if( 0 == ( dwFlags & MESH_NOTEXTURES ) && pSubsets[i].pTexture )
                g_pd3dDevice->SetTexture( 0, pSubsets[i].pTexture );

            // Call the callback, so the app can tweak state before rendering
            // each subset
            BOOL bRenderSubset = RenderCallback( i, &pSubsets[i], dwFlags );

            // Draw the mesh subset
            if( bRenderSubset )
            {
                g_pd3dDevice->DrawIndexedPrimitive( dwPrimType, 0, 0, 0,
                                                    pSubsets[i].dwIndexStart,
                                                    pSubsets[i].dwPrimitiveCount );
            }
        }
    }
}


//--------------------------------------------------------------------------------------
// Name: ComputeRadius()
// Desc: Finds the furthest point from zero on the mesh.
//--------------------------------------------------------------------------------------
FLOAT Mesh::ComputeRadius()
{
    return ComputeFrameRadius( m_pFrames, XMMatrixIdentity() );
}


//--------------------------------------------------------------------------------------
// Name: ComputeFrameRadius()
// Desc: Calls ComputeMeshRadius for each frame with the correct transform
//--------------------------------------------------------------------------------------
FLOAT Mesh::ComputeFrameRadius( const MESH_FRAME* pFrame, const XMMATRIX matParent )
{
    // Apply the frame's local transform
    XMMATRIX matWorld = XMMatrixMultiply( pFrame->m_matTransform, matParent );

    FLOAT fRadius = 0.0f;

    // Compute bounds for the mesh data
    if( pFrame->m_pMeshData->m_dwNumSubsets )
        fRadius = ComputeMeshRadius( pFrame->m_pMeshData, matWorld );

    // Compute bounds for any child frames
    if( pFrame->m_pChild )
    {
        FLOAT fChildRadius = ComputeFrameRadius( pFrame->m_pChild, matWorld );

        if( fChildRadius > fRadius )
            fRadius = fChildRadius;
    }

    // Compute bounds for any sibling frames
    if( pFrame->m_pNext )
    {
        FLOAT fSiblingRadius = ComputeFrameRadius( pFrame->m_pNext, matParent );

        if( fSiblingRadius > fRadius )
            fRadius = fSiblingRadius;
    }

    return fRadius;
}


//--------------------------------------------------------------------------------------
// Name: ComputeMeshRadius()
// Desc: Finds the furthest point from zero on the mesh
//--------------------------------------------------------------------------------------
FLOAT Mesh::ComputeMeshRadius( MESH_DATA* pMesh, const XMMATRIX mat )
{
    DWORD dwNumVertices = pMesh->m_dwNumVertices;
    DWORD dwVertexSize = pMesh->m_dwVertexSize;
    FLOAT fMaxDist2 = 0.0f;

    BYTE* pVertexData;
    pMesh->m_VB.Lock( 0, 0, ( VOID** )&pVertexData, D3DLOCK_READONLY );

    while( dwNumVertices-- )
    {
        XMFLOAT3* pVertex = ( XMFLOAT3* )pVertexData;
        XMVECTOR vPos = XMVectorSet( pVertex->x, pVertex->y, pVertex->z, 0 );
        vPos = XMVector3TransformCoord( vPos, mat );

        FLOAT fDist2 = vPos.x * vPos.x + vPos.y * vPos.y + vPos.z * vPos.z;

        if( fDist2 > fMaxDist2 )
            fMaxDist2 = fDist2;

        pVertexData += dwVertexSize;
    }

    pMesh->m_VB.Unlock();

    return sqrtf( fMaxDist2 );
}


//--------------------------------------------------------------------------------------
// Name: UnionBox()
// Desc: Take the union of two boxes
//--------------------------------------------------------------------------------------
static VOID UnionBox( XMVECTOR& vUnionMin, XMVECTOR& vUnionMax,
                      const XMVECTOR vMin, const XMVECTOR vMax )
{
    vUnionMin = XMVectorMinimize( vUnionMin, vMin );
    vUnionMax = XMVectorMaximize( vUnionMax, vMax );
}


//--------------------------------------------------------------------------------------
// Name: ComputeBoundingBox()
// Desc: Calculates the bounding box of the entire hierarchy.
//--------------------------------------------------------------------------------------
VOID Mesh::ComputeBoundingBox( XMVECTOR& vMin, XMVECTOR& vMax )
{
    ComputeFrameBoundingBox( m_pFrames, XMMatrixIdentity(), vMin, vMax );
}


//--------------------------------------------------------------------------------------
// Name: ComputeFrameBoundingBox()
// Desc: Calls ComputeMeshBoundingBox for each frame with the correct transform.
//--------------------------------------------------------------------------------------
VOID Mesh::ComputeFrameBoundingBox( const MESH_FRAME* pFrame, const XMMATRIX matParent,
                                    XMVECTOR& vMin, XMVECTOR& vMax )
{
    // Initialize bounds to be reset on the first UnionBox
    vMin.x = vMin.y = vMin.z = +FLT_MAX;
    vMax.x = vMax.y = vMax.z = -FLT_MAX;

    // Apply the frame's local transform
    XMMATRIX matWorld = XMMatrixMultiply( pFrame->m_matTransform, matParent );

    // Compute bounds for the mesh data
    if( pFrame->m_pMeshData->m_dwNumSubsets )
    {
        XMVECTOR vMeshMin, vMeshMax;
        ComputeMeshBoundingBox( pFrame->m_pMeshData, matWorld, vMeshMin, vMeshMax );
        UnionBox( vMin, vMax, vMeshMin, vMeshMax );
    }

    // Compute bounds for any child frames
    if( pFrame->m_pChild )
    {
        XMVECTOR vChildMin, vChildMax;
        ComputeFrameBoundingBox( pFrame->m_pChild, matWorld, vChildMin, vChildMax );
        UnionBox( vMin, vMax, vChildMin, vChildMax );
    }

    // Compute bounds for any sibling frames
    if( pFrame->m_pNext )
    {
        XMVECTOR vSiblingMin, vSiblingMax;
        ComputeFrameBoundingBox( pFrame->m_pNext, matParent, vSiblingMin, vSiblingMax );
        UnionBox( vMin, vMax, vSiblingMin, vSiblingMax );
    }
}


//--------------------------------------------------------------------------------------
// Name: ComputeMeshBoundingBox()
// Desc: Calculate the bounding box of the transformed mesh.
//--------------------------------------------------------------------------------------
VOID Mesh::ComputeMeshBoundingBox( MESH_DATA* pMesh, const XMMATRIX mat,
                                   XMVECTOR& vMin, XMVECTOR& vMax )
{
    // Initialize bounds to be reset on the first point
    vMin.x = vMin.y = vMin.z = +FLT_MAX;
    vMax.x = vMax.y = vMax.z = -FLT_MAX;

    DWORD dwNumVertices = pMesh->m_dwNumVertices;
    DWORD dwVertexSize = pMesh->m_dwVertexSize;

    BYTE* pVertexData;
    pMesh->m_VB.Lock( 0, 0, ( VOID** )&pVertexData, D3DLOCK_READONLY );

    while( dwNumVertices-- )
    {
        XMFLOAT3* pVertex = ( XMFLOAT3* )pVertexData;
        XMVECTOR vPos = XMVectorSet( pVertex->x, pVertex->y, pVertex->z, 0 );
        vPos = XMVector3TransformCoord( vPos, mat );

        UnionBox( vMin, vMax, vPos, vPos );  // Expand the bounding box to include the point
        pVertexData += dwVertexSize;
    }
    pMesh->m_VB.Unlock();
}

} // namespace ATG

```

`XenonDumper/libs/Atg/AtgMesh.h`:

```h
//--------------------------------------------------------------------------------------
// AtgMesh.h
//
// Support code for loading geometry stored in .xbg files. These files are typically
// converted from .x geometry files using the MakeXBG tool. See that tool for more
// information.
//
// XBG files were designed to minimize overhead in the loading and rendering process on
// the Xbox. The data in a .xbg file is basically stored in one system memory chunk,
// and one video memory chunk. Therefore, loading a .xbg file is simply two fread()
// calls followed by some patch up (which turns file offsets into real pointers).
//
// Geometry files are loaded into arrays of the following structures. MESH_FRAME
// structures contain data to make a frame hierarchy (such as "next" and "child"
// pointers, plus a transformation matrix). The XMMESH_DATA structure contains data for
// rendering a mesh (such as the vertex buffer, num of indices, etc.). Finally, the
// MESH_SUBSET structure contains subset properties (materials and textures) and
// primitive ranges (start index, index count, etc.) for each subset of the data in the
// MESH_DATA structure.
//
// To use this class, simply instantiate the class, and call Create(). Thereafter, the
// mesh can be rendered with the Render() call. Some render flags are available (see
// below) to limit what gets rendered. For instance, an app might want to render opaque
// subsets only, or use a custom vertex shader. For truly custom control, override the
// Mesh class with a new RenderCallback() function, and put any custom pre-rendering
// code in the callback. The typical use for this is to pass data to a custom vertex
// shader.
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#pragma once
#ifndef ATGMESH_H
#define ATGMESH_H

namespace ATG
{


// Forware declaration
class PackedResource;


// Rendering flags. Default is no flags (0x00000000)
enum
{
    MESH_OPAQUEONLY     = 0x00000001, // Only render opaque subsets
    MESH_ALPHAONLY      = 0x00000002, // Only render alpha subsets

    MESH_NOMATERIALS    = 0x00000010, // Do not use mesh materials
    MESH_NOTEXTURES     = 0x00000020, // Do not use mesh textures
    MESH_NOFVF          = 0x00000040, // Do not use the FVF for the mesh
    MESH_NOVERTEXDECL   = 0x00000080, // Do not use the vertex decl for the mesh
};


// The magic number to identify .xbg files
const DWORD XBG7_FILE_ID = ( ( ( DWORD )'X' << 24 ) | ( ( ( DWORD )'B' << 16 ) ) | ( ( ( DWORD )'G' << 8 ) ) |
                             ( 7 << 0 ) );


//--------------------------------------------------------------------------------------
// Header for a .xbg file
//--------------------------------------------------------------------------------------
struct XBG_HEADER
{
    DWORD dwMagic;
    DWORD dwSysMemSize;
    DWORD dwVidMemSize;
    DWORD dwNumFrames;
};


//--------------------------------------------------------------------------------------
// Struct to hold data for rendering a mesh
//--------------------------------------------------------------------------------------
struct MESH_SUBSET
{
    D3DMATERIAL9 mtrl;
    LPDIRECT3DTEXTURE9 pTexture;
    CHAR    strTexture[64];
    DWORD dwVertexStart;
    DWORD dwVertexCount;
    DWORD dwIndexStart;
    DWORD dwIndexCount;
    DWORD dwPrimitiveCount;
    DWORD   Pad[1];
};


//--------------------------------------------------------------------------------------
// Struct to hold data for a mesh
//--------------------------------------------------------------------------------------
struct MESH_DATA
{
    D3DVertexBuffer m_VB;            // Mesh geometry
    DWORD m_dwNumVertices;
    D3DIndexBuffer m_IB;
    DWORD m_dwNumIndices;

    D3DVERTEXELEMENT9   m_VertexElements[16];
    D3DVertexDeclaration* m_pVertexDecl;
    DWORD m_dwVertexSize;
    D3DPRIMITIVETYPE m_dwPrimType;

    DWORD m_dwNumSubsets;  // Subset info, for rendering
    MESH_SUBSET         m_pSubsets[1];

    VOID                Render( DWORD dwFlags = 0L );
};


//--------------------------------------------------------------------------------------
// Struct to provide a hierarchial layout of meshes.
//--------------------------------------------------------------------------------------
__declspec( align( 16 ) ) struct MESH_FRAME
{
    CHAR    m_strName[64];
    XMMATRIX m_matTransform;  // Make sure this is 16-byte aligned!
    MESH_DATA* m_pMeshData;
    MESH_FRAME* m_pChild;
    MESH_FRAME* m_pNext;
    DWORD   Pad[1];
};


//--------------------------------------------------------------------------------------
// Name: class Mesh
// Desc: Class for loading geometry files, and rendering the resulting hierarchy of
//       meshes and frames.
//--------------------------------------------------------------------------------------
class Mesh
{
    // Memory allocated during file loading. Ptrs are retained for cleanup.
    VOID* m_pAllocatedSysMem;
    VOID* m_pAllocatedVidMem;

public:
    // Hierarchy (frames and meshes) of loaded geometry
    MESH_FRAME* m_pFrames;
    DWORD m_dwNumFrames;

    // Matrix transform set
    XMMATRIX m_matWorld;
    XMMATRIX m_matView;
    XMMATRIX m_matProj;

                    Mesh();
    virtual         ~Mesh();

    // Creation function. Call this function to create the hierarchy of frames
    // and meshes from a geometry file.
    HRESULT         Create( const CHAR* strFilename, const PackedResource* pResource = NULL );

    // Function to write a mesh back to a file
    HRESULT         Write( const CHAR* strFilename );

    // Access functions
    MESH_FRAME* GetFrame( DWORD i )
    {
        return &m_pFrames[i];
    }
    MESH_DATA* GetMesh( DWORD i )
    {
        return m_pFrames[i].m_pMeshData;
    }

    // Overridable callback function (called before each mesh is rendered). 
    virtual VOID    RenderMeshCallback( DWORD dwFrame, const MESH_FRAME* pFrame, DWORD dwFlags )
    {
    }

    // Overridable callback function (called before each subset is rendered). 
    // This is useful for setting vertex shader constants, etc., before
    // rendering.
    virtual BOOL    RenderCallback( DWORD dwSubset, const MESH_SUBSET* pSubset, DWORD dwFlags )
    {
        return TRUE;
    }

    // Render function. Call this function to render the hierarchy of frames
    // and meshes.
    VOID            Render( DWORD dwFlags = 0x00000000 );

    // Function to find the radius of sphere centered at zero enclosing mesh.
    FLOAT           ComputeRadius();

    // Find the bounding box of all the subsets
    VOID            ComputeBoundingBox( XMVECTOR& vMin, XMVECTOR& vMax );

    // Internal rendering functions
    virtual VOID    RenderFrame( const MESH_FRAME* pMesh, DWORD dwFlags );
    virtual VOID    RenderMesh( MESH_DATA* pMesh, DWORD dwFlags );
    // Internal functions to find the radius of sphere centered at zero enclosing mesh.
    FLOAT           ComputeFrameRadius( const MESH_FRAME* pFrame, const XMMATRIX matParentMatrix );
    FLOAT           ComputeMeshRadius( MESH_DATA* pMesh, const XMMATRIX mat );

    // Internal functions to find the bounding box of the mesh.
    VOID            ComputeFrameBoundingBox( const MESH_FRAME* pFrame, const XMMATRIX matParentMatrix, XMVECTOR& vMin,
                                             XMVECTOR& vMax );
    VOID            ComputeMeshBoundingBox( MESH_DATA* pMesh, const XMMATRIX mat, XMVECTOR& vMin, XMVECTOR& vMax );
};


//--------------------------------------------------------------------------------------
// Name: class Mesh2
// Desc: Class for loading geometry files, and rendering the resulting hierarchy of
//       meshes and frames.
//--------------------------------------------------------------------------------------
class Mesh2
{
    // Memory allocated during file loading. Ptrs are retained for cleanup.
    VOID* m_pAllocatedSysMem;
    VOID* m_pAllocatedVidMem;

public:
    // Mesh data
    MESH_DATA* m_pMeshData;

public:
    // Constructor/destructor
            Mesh2();
    virtual ~Mesh2();

    // Creation function. Call this function to create the hierarchy of frames
    // and meshes from a geometry file.
    HRESULT Create( const CHAR* strFilename, const PackedResource* pResource = NULL );

    MESH_DATA* GetMesh() const
    {
        return m_pMeshData;
    }
};

} // namespace ATG

#endif // ATGMESH_H

```

`XenonDumper/libs/Atg/AtgMeta.h`:

```h
#pragma once

//
// Metaprogramming tools
//
// Template metaprogramming is a way to evaluate expressions
// and generate code at compile time rather than at run time.
// If used correctly, it can pick up where the optimizer leaves
// off and let you unroll loops, hoist variables, and select
// optimized implementations for performance-critical functionality.
// Used incorrectly, it can kill your build with cryptic errors
// or cripple it with astoundingly slow compile times.
//
// Some areas of Xbox 360 code can benefit greatly from judicious
// use of template metaprogramming. It's especially helpful when
// writing VMX128 code, since the 360's vector unit craves huge
// amounts of data and doesn't always play nicely with traditional
// batch processing techniques.
//
// The types, templates and concepts in this header are designed
// for Xbox 360-specific tasks. They are not intended to be an
// all-purpose metaprogramming solution.
//

//
// NOTA BENE:
// Do not make the choice to use these classes lightly! Even when
// used correctly, they will increase compile times by an order
// of magnitude. This is especially true on release builds, where
// their effect is to generate huge working sets for the optimizer.
// Isolate files that include this header into areas of code that
// won't be recompiled often.
//


namespace ATG{
    //
    // CompileTimeInt
    //
    // Although it's possible to use integers as template parameters,
    // there are some important differences between integral parameters
    // and type parameters. This class helps iron out some of those
    // differences by effectively creating a new type for each unique
    // integer value used by the application. 
    //
    // This class conforms to a simple pattern for "meta-values." A
    // meta-value is a compile-time value that can be manipulated by
    // "meta-ops" or compile-time operations. A meta-value in this 
    // system is any type that has a public const static integral 
    // member called "value."
    //
    template< int V >
    struct CompileTimeInt
    {
        typedef CompileTimeInt<V> type;
        enum{ value = V};
            
        operator int() { return value; }
        
    };


    //
    // CompileTimeLoop
    //
    // This template emits multiple calls to the same function. Pass it the
    // name of the function you want to call and a set of parameters. By default,
    // CompileTimeLoop expects the parameters to be arrays (or some class that implements
    // operator []). Each time it calls the function, it increments the array
    // index. This makes it very easy to process an entire batch of data in
    // one call. It's faster in most cases than using a loop for the same 
    // purpose, because the code it emits is automatically "unrolled."
    //
    // CompileTimeLoop works by specializing a template class. The general
    // version of the template takes a starting index and a count. You
    // call the function "unroll." It then calls successive versions of
    // itself recursively, incrementing index and decrementing
    // count each time. The specialization is for count==0. When count
    // drops to zero the specialized version is called. This version
    // of the function is empty and so the recursion halts.
    //
    // In order to make CompileTimeLoop as easy to use as possible,
    // CompileTimeLoop::unroll is overloaded for functions of up
    // to twenty parameters. The overloading is done through a set
    // of macro expansions. Skip past the "helper macros" section to see
    // the class definition of CompileTimeLoop.


    // HELPER MACROS FOR LOOP
    //
    // These macros are primarily intended to make the rest of the file
    // more readable by eliminating redundant code.
    //
    #define DUP1( M, name ) M( name##0 )
    #define DUP2( M, name ) DUP1( M, name ), M( name##1 )
    #define DUP3( M, name ) DUP2( M, name ), M( name##2 )
    #define DUP4( M, name ) DUP3( M, name ), M( name##3 )
    #define DUP5( M, name ) DUP4( M, name ), M( name##4 )
    #define DUP6( M, name ) DUP5( M, name ), M( name##5 )
    #define DUP7( M, name ) DUP6( M, name ), M( name##6 )
    #define DUP8( M, name ) DUP7( M, name ), M( name##7 )
    #define DUP9( M, name ) DUP8( M, name ), M( name##8 )
    #define DUP10( M, name ) DUP9( M, name ), M( name##9 )
    #define DUP11( M, name ) DUP10( M, name ), M( name##10 )
    #define DUP12( M, name ) DUP11( M, name ), M( name##11 )
    #define DUP13( M, name ) DUP12( M, name ), M( name##12 )
    #define DUP14( M, name ) DUP13( M, name ), M( name##13 )
    #define DUP15( M, name ) DUP14( M, name ), M( name##14 )
    #define DUP16( M, name ) DUP15( M, name ), M( name##15 )
    #define DUP17( M, name ) DUP16( M, name ), M( name##16 )
    #define DUP18( M, name ) DUP17( M, name ), M( name##17 )
    #define DUP19( M, name ) DUP18( M, name ), M( name##18 )
    #define DUP20( M, name ) DUP19( M, name ), M( name##19 )

    #define DUP_ARGNAME( name ) name
    #define DUP_ARGINDEXED( name ) name##[CurrentIndex()]
    #define LOOP_TEMPLATE_ARG( name ) typename name##_t
    #define LOOP_FUNCTION_ARG( name ) name##_t& name

    #define LOOP_UNROLLER_FN( DUP_MACRO )                                           \
        template< typename fn_t, DUP_MACRO( LOOP_TEMPLATE_ARG, arg )>                   \
        static __forceinline void Unroll( fn_t fn, DUP_MACRO( LOOP_FUNCTION_ARG, arg ) )\
    {                                                                               \
        fn( DUP_MACRO( DUP_ARGINDEXED, arg ) );                                      \
        CompileTimeLoop<index + 1, count - 1>::Unroll                                \
        ( fn, DUP_MACRO( DUP_ARGNAME, arg ) );                                 \
    }                                               

    #define LOOP_UNROLLER_FN_EMPTY( DUP_MACRO )                                         \
        template< typename fn_t, DUP_MACRO( LOOP_TEMPLATE_ARG, arg )>                   \
        static __forceinline void Unroll( fn_t fn, DUP_MACRO( LOOP_FUNCTION_ARG, arg ) )\
    {}                                                                                   


    template<int index, int count>
    class CompileTimeLoop
    {
    public:
        typedef CompileTimeInt<index> CurrentIndex;

        template<typename fn_t>
        static __forceinline void Unroll( fn_t fn )
        {
            fn();
            loop<index+1,count-1>::unroll(fn);
        }

        LOOP_UNROLLER_FN( DUP1 );
        LOOP_UNROLLER_FN( DUP2 );
        LOOP_UNROLLER_FN( DUP3 );
        LOOP_UNROLLER_FN( DUP4 );
        LOOP_UNROLLER_FN( DUP5 );
        LOOP_UNROLLER_FN( DUP6 );
        LOOP_UNROLLER_FN( DUP7 );
        LOOP_UNROLLER_FN( DUP8 );
        LOOP_UNROLLER_FN( DUP9 );
        LOOP_UNROLLER_FN( DUP10 );
        LOOP_UNROLLER_FN( DUP11 );
        LOOP_UNROLLER_FN( DUP12 );
        LOOP_UNROLLER_FN( DUP13 );
        LOOP_UNROLLER_FN( DUP14 );
        LOOP_UNROLLER_FN( DUP15 );
        LOOP_UNROLLER_FN( DUP16 );
        LOOP_UNROLLER_FN( DUP17 );
        LOOP_UNROLLER_FN( DUP18 );
        LOOP_UNROLLER_FN( DUP19 );
        LOOP_UNROLLER_FN( DUP20 );

    };


    template<int index>
    class CompileTimeLoop<index, 0>
    {
    public:
        template<typename fn_t>  static __forceinline void Unroll( fn_t fn ){}

        LOOP_UNROLLER_FN_EMPTY( DUP1 );
        LOOP_UNROLLER_FN_EMPTY( DUP2 );
        LOOP_UNROLLER_FN_EMPTY( DUP3 );
        LOOP_UNROLLER_FN_EMPTY( DUP4 );
        LOOP_UNROLLER_FN_EMPTY( DUP5 );
        LOOP_UNROLLER_FN_EMPTY( DUP6 );
        LOOP_UNROLLER_FN_EMPTY( DUP7 );
        LOOP_UNROLLER_FN_EMPTY( DUP8 );
        LOOP_UNROLLER_FN_EMPTY( DUP9 );
        LOOP_UNROLLER_FN_EMPTY( DUP10 );
        LOOP_UNROLLER_FN_EMPTY( DUP11 );
        LOOP_UNROLLER_FN_EMPTY( DUP12 );
        LOOP_UNROLLER_FN_EMPTY( DUP13 );
        LOOP_UNROLLER_FN_EMPTY( DUP14 );
        LOOP_UNROLLER_FN_EMPTY( DUP15 );
        LOOP_UNROLLER_FN_EMPTY( DUP16 );
        LOOP_UNROLLER_FN_EMPTY( DUP17 );
        LOOP_UNROLLER_FN_EMPTY( DUP18 );
        LOOP_UNROLLER_FN_EMPTY( DUP19 );
        LOOP_UNROLLER_FN_EMPTY( DUP20 );
    };


    //
    // Classes for compile-time calculation
    // 
    // These classes define a simple expression tree paradigm for doing
    // compile-time calculations. These classes borrow ideas from boost::mpl
    // and other metaprogramming libraries, but are considerably simpler
    // and less capable. The purpose of these classes is to support fancier
    // looping than the simple monotonically increasing index that 
    // CompileTimeLoop offers as a default. The MetaExpression classes are
    // meant to be used in conjunction with the CompileTimeIndexer classes
    // defined below.
    //
    // In this system an "Expression" is a class that has an embedded template
    // type named "eval." Expressions operate on values, which are classes like
    // CompileTimeInt that have a const static integral member named value.
    // Most expressions evaluate to other expressions, so taken together the 
    // MetaExpressions classes form a tiny little functional language.
    // 
    // eval is always templated on a class which represents the expression's
    // "ambient environment"--that is, data defined outside the expression that
    // is available to the expression and its subexpressions during evaluation.
    // The primary motivator behind the "ambient" idea is to provide a way for
    // expressions to access the current index when evaluating as part of 
    // CompileTimeLoop, but the concept can be extended to provide other ambient
    // data as well.
    //

    //
    // Basic mathematical expressions
    //
    template<class A> struct Negate { template<class ambient> struct eval : CompileTimeInt< -(A::eval<ambient>::value) >{}; };
    template<class A, class B> struct Add { template<class ambient> struct eval : CompileTimeInt< A::eval<ambient>::value + B::eval<ambient>::value >{}; };
    template<class A, class B> struct Sub { template<class ambient> struct eval : CompileTimeInt< A::eval<ambient>::value - B::eval<ambient>::value >{}; };
    template<class A, class B> struct Mul { template<class ambient> struct eval : CompileTimeInt< A::eval<ambient>::value * B::eval<ambient>::value >{}; };
    template<class A, class B> struct Div { template<class ambient> struct eval : CompileTimeInt< A::eval<ambient>::value / B::eval<ambient>::value >{}; };
    template<class A, class B> struct Mod { template<class ambient> struct eval : CompileTimeInt< A::eval<ambient>::value % B::eval<ambient>::value >{}; };
    template<class A, class B, class C> struct Select { template<class ambient> struct eval : CompileTimeInt< A::eval<ambient>::value ? B::eval<ambient>::value : C::eval<ambient>::value >{}; };

    // This is the ambient environment passed to every expression in the tree.
    // It's defined as a struct even though it contains only one value, because
    // defining it this way makes adding new values trivial but defining it as
    // an int would have repercussions all the way through the system.
    //
    template<int index> struct Ambient{ const static int Index = index;};


    //
    // Special compile-time expressions
    //
    // These classes are designed to fill multiple roles. They are "leaf" 
    // expressions, evaluating to value classes rather than to expression
    // classes. They also have overloaded operators that allow them to be
    // used in logical, though somewhat syntactically sketchy, ways when
    // passing them to CompileTimeLoop. For instance, 
    //      CompileTimeLoop<m,n>::Unroll( fn, Index() );
    // will pass the current index value to "fn" every time it's called.
    // Where this is really useful is things like VMX splatting. For
    // instance, here's code to splat each member of a source vector
    // out to one of four different destination vectors:
    //      CompileTimeLoop<0,4>::Unroll( 
    //                              vspltw, 
    //                              destVectors, 
    //                              Indexer<Div<Index,Constant<4> >(src), 
    //                              Index() );
    //
    
    template< int V > struct Constant
        : CompileTimeInt<V>
    { 
        template<class ambient> struct eval : CompileTimeInt<V>{}; 
        
        CompileTimeInt<V> operator[](int){ return CompileTimeInt<V>(); } 
    };

    struct Index
    { 
        template< class ambient > struct eval : CompileTimeInt< ambient::Index >{}; 
        template<int index> CompileTimeInt<index> operator[](CompileTimeInt<index> n){ return CompileTimeInt<index>(); } 
    };


    //
    // Indexers
    //
    // CompileTimeLoop's default functionality is great if you want to process
    // every array member identically and in order. But sometimes you need 
    // more flexibility than that. To handle more complex processing we 
    // introduce the concept of "indexers." These are distinct from
    // "iterators," although the two concepts are very similar. The reason 
    // for the distinction is to emphasize the random-access nature of the 
    // indexing.
    //
    // Indexers are classes that implement operator[]. The default indexers 
    // defined here are parameterized using the MetaExpression templates, 
    // so they should be flexible enough for most purposes.
    //

    // Helper class--encapsulates the MetaExpression part of things
    template< class OperationT >
    class IndexTransform
    {
        template< int E >
        int operator[]( CompileTimeInt<E> element ) const { return OperationT::eval< Ambient<E> >(); }
    };

    //
    // Indexer for constant arrays
    //
    template< typename SequenceT, typename ElementT, class TransformT >
    class ConstCompileTimeIndex
    {
    public:
        typedef SequenceT SequenceType;
        typedef SequenceT ElementType;

        ConstCompileTimeIndex( SequenceT sequence ): m_sequence( sequence ){}

        template< int E >
        const ElementT& operator[]( CompileTimeInt<E> element ) const { return m_sequence[m_transform[element]]; }

    private:
        SequenceT m_sequence;
        TransformT m_transform;
    };

    //
    // Indexer for non-const arrays
    //
    template< typename SequenceT, typename ElementT, class TransformT >
    class CompileTimeIndex
    {
    public:
        CompileTimeIndex( SequenceT sequence ): m_sequence(sequence){}

        template< int E >
        ElementT& operator[]( CompileTimeInt<E> element ) { return m_sequence[m_transform[element]]; }

        template< int E >
        const ElementT& operator[]( CompileTimeInt<E> element ) const { return m_sequence[m_transform[element]]; }

    private:
        SequenceT m_sequence;
        TransformT m_transform;
    };

    //
    // Wraps a uniform value so that it can be used in CompileTimeLoop 
    // and anywhere else that expects an array. The [] operator returns 
    // the same value no matter what the index is.
    //
    template< typename T >
    class IdentityIndexer
    {
    public:
        IdentityIndexer( T& value ): m_value(value){}

        T& operator[]( int ) { return m_value; }

        const T& operator[]( int ) const { return m_value; }

    private:
        T& m_value;
    };

    //
    // const-only version of the above
    //
    template< typename T >
    class ConstIdentityIndexer
    {
    public:
        ConstIdentityIndexer( const T& value ): m_value(value){}

        const T& operator[]( int ) const { return m_value; }

    private:
        const T& m_value;
    };

    //
    // Type switch for indexers, to select the correct
    // type based on the constness and indirection level
    // of the type parameter.
    //
    template< class ExpressionT >
    struct CompileTimeIndexSwitch
    {
        typedef IndexTransform<ExpressionT> TransformT;

        template<typename T> struct specialize{
            typedef IdentityIndexer<T> type; };

        template<typename T> struct specialize<const T>{
            typedef ConstIdentityIndexer<T> type; };

        template<typename T> struct specialize< const T* >{ 
            typedef ConstCompileTimeIndex<const T*, T, TransformT> type; };
        
        template<typename T> struct specialize< T* >{ 
            typedef CompileTimeIndex<T*, T, TransformT> type; };

    };

    //
    // Template factory for indexers. Implemented as a template function to
    // make the compiler deduce the type of sequence and make it easier to
    // support types other than vanilla C arrays.
    //
    template< class ExpressionT, typename T >
    typename CompileTimeIndexSwitch<ExpressionT>::specialize<T>::type Indexer( T in )
    { 
        return typename CompileTimeIndexSwitch<ExpressionT>::specialize<T>::type( in ); 
    }

    template<typename T>
    typename CompileTimeIndexSwitch<Constant<0> >::specialize<T>::type Uniform( T& in )
    {
        return typename CompileTimeIndexSwitch<Constant<0> >::specialize<T>::type( in ); 
    }


} // namespace ATG















```

`XenonDumper/libs/Atg/AtgMetaVMX.h`:

```h
#pragma once

#include "AtgMeta.h"
#include <vectorintrinsics.h>

namespace ATG{

    //
    // Recommended types for passing __vector4
    //
    typedef const __vector4 __declspec(passinreg) vector4_in;
    typedef __vector4 __declspec(passinreg)& vector4_out;
    typedef __vector4 __declspec(passinreg)& vector4_inout;
    typedef __vector4* __restrict vector4_ptr;

    //
    // Wrappers for VMX compiler intrinsics
    // 
    // VMX intrinsics can't be used as functors--they look like functions
    // but they have no storage, which makes things all confused. Plus, they
    // are mostly defined with return types, which makes them harder to use
    // with CompileTimeLoop. Fortunately they can be wrapped in functions
    // with no loss of efficiency as long as the functions are inlined.
    //
    void __forceinline vor( vector4_out result, vector4_in a, vector4_in b ){ result = __vor( a, b ); }
    void __forceinline vand( vector4_out result, vector4_in a, vector4_in b ){ result = __vand( a, b ); }

    void __forceinline vcmpgefp( vector4_out result, vector4_in a, vector4_in b ){ result = __vcmpgefp( a, b ); }
    void __forceinline vcmpgtfp( vector4_out result, vector4_in a, vector4_in b ){ result = __vcmpgtfp( a, b ); }

    void __forceinline vcmpgefp_vor( vector4_out result, vector4_in a, vector4_in b ){ result = __vor( result, __vcmpgefp( a, b ) ); }
    void __forceinline vcmpgtfp_vor( vector4_out result, vector4_in a, vector4_in b ){ result = __vor( result, __vcmpgtfp( a, b ) ); }
    void __forceinline vcmpgefp_vand( vector4_out result, vector4_in a, vector4_in b ){ result = __vand( result, __vcmpgefp( a, b ) ); }
    void __forceinline vcmpgtfp_vand( vector4_out result, vector4_in a, vector4_in b ){ result = __vand( result, __vcmpgtfp( a, b ) ); }

    void __forceinline vmulfp( vector4_out result, vector4_in a, vector4_in b ){ result = __vmulfp( a, b ); }
    void __forceinline vaddfp( vector4_out result, vector4_in a, vector4_in b ){ result = __vaddfp( a, b ); }
    void __forceinline vsubfp( vector4_out result, vector4_in a, vector4_in b ){ result = __vsubfp( a, b ); }
    void __forceinline vmaddfp( vector4_out result, vector4_in mul1, vector4_in mul2, vector4_in add ){ result = __vmaddfp( mul1, mul2, add ); }
    void __forceinline vmsum4fp( vector4_out result, vector4_in mul1, vector4_in mul2 ){ result = __vmsum4fp( mul1, mul2 ); }
    void __forceinline vmsum3fp( vector4_out result, vector4_in mul1, vector4_in mul2 ){ result = __vmsum3fp( mul1, mul2 ); }


    //
    // Things do get a little tricky when the intrinsic takes a constant
    // parameter, because the value for the parameter has to be known at
    // compile time in order for the compiler to emit the right machine code.
    // This could be solved in many cases by wrapping the intrinsic in 
    // a function template, but you can't pass a template function to another
    // template function if the second function isn't expecting a template.
    // We get around this problem by using functor structs--structures that
    // overload operator() and templatize the overload. The struct object
    // is what gets passed to CompileTimeLoop, which sees it as just another
    // function. When the operator actually gets called, the compiler 
    // deduces the correct integer to call it with.
    //
    struct vspltw_t
    {
        template<int element>
        void __forceinline operator()(vector4_out result, vector4_in src, CompileTimeInt<element> e ){ result = __vspltw( src, element ); }
    };
    __declspec(selectany) vspltw_t vspltw;

    struct vinsert_t
    {
        template<int srcE, int destE>
        void __forceinline operator()(vector4_out result, vector4_in src, CompileTimeInt<srcE> srcElement, CompileTimeInt<destE> destElement )
        { 
            result = __vrlimi( result, src, 8>>destE, ((destE-srcE)+3)%3);
        }
    };
    __declspec(selectany) vinsert_t vinsert;

    union fdw{ DWORD dw; float f; };
    const static fdw vpermX0 = { 0x00010203 };
    const static fdw vpermY0 = { 0x04050607 };
    const static fdw vpermZ0 = { 0x08090a0b };
    const static fdw vpermW0 = { 0x0c0d0e0f };
    const static fdw vpermX1 = { 0x10111213 };
    const static fdw vpermY1 = { 0x14151617 };
    const static fdw vpermZ1 = { 0x18191a1b };
    const static fdw vpermW1 = { 0x1c1d1e1f };

    union __declspec(align(16)) vdw{ DWORD dw[4]; __vector4 v; };
    const static __vector4 Ones = { 1.0f, 1.0f, 1.0f, 1.0f };
    const static vdw vectorSignBits = { 0x80000000, 0x80000000, 0x80000000, 0x80000000 };
    const static vdw vectorNonSignBits = { 0x7fffffff, 0x7fffffff, 0x7fffffff, 0x7fffffff };
} // namespace ATG
```

`XenonDumper/libs/Atg/AtgModel.cpp`:

```cpp
//-----------------------------------------------------------------------------
// model.cpp
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "AtgSceneMesh.h"
#include "AtgMaterials.h"
#include "AtgModel.h"

namespace ATG
{

CONST StringID Model::TypeID( L"Model" );
    
//-----------------------------------------------------------------------------
// Name: Model::AddMesh()
//-----------------------------------------------------------------------------
VOID Model::AddMesh( BaseMesh* pMesh, DWORD dwMeshMappingFlags )
{
    assert( pMesh );
    MeshMapping mi;

    mi.pMesh = pMesh;
    mi.dwFlags = dwMeshMappingFlags;
    m_MeshMappings.push_back( mi );
}


//-----------------------------------------------------------------------------
// Name: Model::GetMesh()
//-----------------------------------------------------------------------------
BaseMesh* Model::GetMesh( CONST WCHAR* strName ) CONST
{
    for( UINT i = 0; i < m_MeshMappings.size(); i++ )
    {
        if( m_MeshMappings[i].pMesh->GetName() == strName )
            return m_MeshMappings[i].pMesh;
    }
    return NULL;
}


//-----------------------------------------------------------------------------
// Name: Model::RemoveMesh()
//-----------------------------------------------------------------------------
BOOL Model::RemoveMesh( CONST BaseMesh* pMesh )
{ 
    std::vector<MeshMapping>::iterator i;
    for( i = m_MeshMappings.begin(); i != m_MeshMappings.end(); i++ )
    {
        if( i->pMesh == pMesh )
        {
            m_MeshMappings.erase(i);
            return TRUE;
        }
    }
    return FALSE;
}


//-----------------------------------------------------------------------------
// Name: Model::AddMaterial()
//-----------------------------------------------------------------------------
VOID Model::AddMaterial( UINT MeshIndex, UINT MaterialIndex, MaterialInstance* pMaterial )
{
    // assert that the mesh index is valid
    assert( MeshIndex < m_MeshMappings.size() );

    // assign the material
    // $TODO: maybe do this a better way, if things are added out-of-order
    if( MaterialIndex == m_MeshMappings[MeshIndex].Materials.size() )
    {
        m_MeshMappings[MeshIndex].Materials.push_back( pMaterial );
    }
    else
    {
        m_MeshMappings[MeshIndex].Materials[MaterialIndex] = pMaterial;
    }
};

//-----------------------------------------------------------------------------
// Name: Model::GetMeshFlagUnion()
//-----------------------------------------------------------------------------
DWORD Model::GetMeshFlagUnion() CONST 
{
    DWORD dwFlagUnion = 0;
    for( UINT i = 0; i < m_MeshMappings.size(); i++ )
        dwFlagUnion |= m_MeshMappings[i].pMesh->GetFlags();
    return dwFlagUnion;
}


//-----------------------------------------------------------------------------
// Name: Model::GetMeshMappingFlagUnion()
//-----------------------------------------------------------------------------
DWORD Model::GetMeshMappingFlagUnion() CONST 
{
    DWORD dwFlagUnion = 0;
    for( UINT i = 0; i < m_MeshMappings.size(); i++ )
        dwFlagUnion |= m_MeshMappings[i].dwFlags;
    return dwFlagUnion;
}


BOOL Model::ContainsOpaqueSubsets() const
{
    DWORD dwMeshMappingCount = ( DWORD )m_MeshMappings.size();
    for( DWORD i = 0; i < dwMeshMappingCount; ++i )
    {
        const MeshMapping& mm = m_MeshMappings[i];
        DWORD dwMaterialCount = ( DWORD )mm.Materials.size();
        for( DWORD j = 0; j < dwMaterialCount; ++j )
        {
            MaterialInstance* pMaterial = mm.Materials[j];
            if( !pMaterial->IsTransparent() )
                return TRUE;
        }
    }
    return FALSE;
}


BOOL Model::ContainsTransparentSubsets() const
{
    DWORD dwMeshMappingCount = ( DWORD )m_MeshMappings.size();
    for( DWORD i = 0; i < dwMeshMappingCount; ++i )
    {
        const MeshMapping& mm = m_MeshMappings[i];
        DWORD dwMaterialCount = ( DWORD )mm.Materials.size();
        for( DWORD j = 0; j < dwMaterialCount; ++j )
        {
            MaterialInstance* pMaterial = mm.Materials[j];
            if( pMaterial->IsTransparent() )
                return TRUE;
        }
    }
    return FALSE;
}

} // namespace ATG

```

`XenonDumper/libs/Atg/AtgModel.h`:

```h
//-----------------------------------------------------------------------------
// AtgModel.h
//
// A model can has several meshes.  Each mesh may or may not have materials
// assigned to its subsets.  Note that the meshes may be shadow proxies,
// optimized shadows buffer meshes, etc.
//
// $OPTIMIZE: Pool Allocate
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef ATG_MODEL_H
#define ATG_MODEL_H

#include <vector>
#include "AtgFrame.h"
#include "AtgBound.h"

namespace ATG
{

class MaterialInstance;
class BaseMesh;

//-----------------------------------------------------------------------------
// Name: MeshMapping
// Desc: A model can contain several meshes.  Each mesh has materials assigned to it.
//-----------------------------------------------------------------------------
struct MeshMapping
{
    enum MeshMappingFlags
    {
        NoFlags             = 0,
        IsShadowCaster      = 0x1,
        IsShadowReceiver    = 0x2,
        IsTransparent       = 0x4,
        ForceDWORD          = 0x7fffffff
    };

    BaseMesh* pMesh;
    DWORD dwFlags;
    std::vector <MaterialInstance*> Materials;
};


//-----------------------------------------------------------------------------
// Name: Model
//-----------------------------------------------------------------------------
class Model : public Frame
{
    DEFINE_TYPE_INFO();    
public:  
    // Adds meshes and materials to the model.
    VOID    AddMesh( BaseMesh* pMesh, DWORD dwMeshMappingFlags );
    VOID    AddMaterial( UINT MeshIndex, UINT MaterialIndex, MaterialInstance* pMaterial );

    // Gets the union of all the mesh flags on this model (MeshFlags enum in the Mesh class )
    DWORD                       GetMeshFlagUnion() CONST;

    // Gets the union of all the mesh instance flags (MeshMappingFlags enum above)
    DWORD                       GetMeshMappingFlagUnion() CONST;
       
    // Get the mesh instances (mesh instance = mesh + assigned materials)
    UINT                        GetNumMeshMappings() CONST { return m_MeshMappings.size(); }         
    MeshMapping&                GetMeshMapping( UINT Index ) { return m_MeshMappings[Index]; }
    BaseMesh*                   GetMesh( CONST WCHAR* strName ) CONST;
    BOOL                        RemoveMesh( CONST BaseMesh* pMesh );
    BOOL    ContainsTransparentSubsets() const;
    BOOL    ContainsOpaqueSubsets() const;

    // Get the light groups this model is in.  In order to be lit by a light, the 
    // model and light must be in the same group and their bounds must be intersecting.
    std::vector <StringID>& GetLightGroups()
    {
        return m_LightGroups;
    }

private:
    std::vector <StringID> m_LightGroups;
    std::vector <MeshMapping> m_MeshMappings;
};

} // namespace ATG

#endif // ATG_MODEL_H

```

`XenonDumper/libs/Atg/AtgNamedTypedObject.cpp`:

```cpp
//-----------------------------------------------------------------------------
// AtgNamedTypedObject.cpp
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "AtgNamedTypedObject.h"

namespace ATG
{

CONST WCHAR*             StringID::s_EmptyString = L"";
CONST StringID           NamedTypedObject::TypeID( L"NamedTypedObject" );

//-----------------------------------------------------------------------------
// Name: StringID::GetStringTable
// Desc: returns static string table data- used to ensure initialization is done
//-----------------------------------------------------------------------------
std::list<CONST WCHAR *>* StringID::GetStringTable() 
{
    static std::list<CONST WCHAR *> s_StringLists[ StringID_HASHSIZE ];  
    return s_StringLists;
}

//-----------------------------------------------------------------------------
// Name: StringID::operator==
// Desc: compare a string with a WCHAR 
//-----------------------------------------------------------------------------
BOOL StringID::operator== ( CONST WCHAR* strRHS ) CONST
{
    if( strRHS == NULL )
    {
        if( m_strString == s_EmptyString )
            return TRUE;
        return FALSE;
    }

    if( m_strString == strRHS )
        return TRUE;

    return ( wcscmp( m_strString, strRHS ) == 0 );
}

//-----------------------------------------------------------------------------
// Name: StringID::AddString 
// Desc: Add a string to the string table
//-----------------------------------------------------------------------------
CONST WCHAR* StringID::AddString( CONST WCHAR* strString )
{
    if( strString == NULL )
        return NULL;
    if( strString[0] == NULL )
        return s_EmptyString;

    int uBucketIndex = HashString( strString ) % StringID_HASHSIZE;
    std::list<CONST WCHAR*>& CurrentList = GetStringTable()[ uBucketIndex ];

    std::list<CONST WCHAR*>::iterator iter = CurrentList.begin();
    std::list<CONST WCHAR*>::iterator end = CurrentList.end();

    while( iter != end )
    {
        CONST WCHAR* strTest = *iter;
        if( wcscmp( strTest, strString ) == 0 )
            return strTest;
        ++iter;
    }
    
    // $OPTIMIZE: use a fixed size allocator here
    DWORD bufferLength = wcslen( strString ) + 1;
    WCHAR* strCopy = new WCHAR[ bufferLength ];
    wcscpy_s( strCopy, bufferLength, strString );
    CurrentList.push_back( strCopy );
    return strCopy;
}


//-----------------------------------------------------------------------------
// Name: StringID::HashString
// Desc: Create a hash value from a string
//-----------------------------------------------------------------------------
DWORD StringID::HashString( CONST WCHAR* strString )
{
    DWORD HashVal = 0;        
    CONST WCHAR *pChar;

    for ( pChar = strString; *pChar; pChar++ )
    {
        HashVal += *pChar * 193951;
        HashVal *= 399283;
    }
    return HashVal;
}


//-----------------------------------------------------------------------------
// Name: NameIndexedCollection::iterator::iterator()
//-----------------------------------------------------------------------------
NameIndexedCollection::iterator::iterator()
{
    m_pCollection = NULL;    
    m_iCurBucket = 0;
}

//-----------------------------------------------------------------------------
// Name: NameIndexedCollection::iterator::operator*()
// Desc: iterator dereference
//-----------------------------------------------------------------------------
NamedTypedObject* NameIndexedCollection::iterator::operator*()
{
    return *m_iter;
}


//-----------------------------------------------------------------------------
// Name: NameIndexedCollection::iterator::operator=()
// Desc: iterator assignment operator
//-----------------------------------------------------------------------------
NameIndexedCollection::iterator& 
NameIndexedCollection::iterator::operator=( CONST NameIndexedCollection::iterator& iRHS)
{
    m_pCollection = iRHS.m_pCollection;
    m_iter = iRHS.m_iter;
    m_iCurBucket = iRHS.m_iCurBucket;
    return (*this);
}


//-----------------------------------------------------------------------------
// Name: NameIndexedCollection::iterator::operator==()
// Desc: iterator comparison operator
//-----------------------------------------------------------------------------
BOOL NameIndexedCollection::iterator::operator==( CONST NameIndexedCollection::iterator& iRHS)
{
    if ( ( m_pCollection == iRHS.m_pCollection ) &&
         ( m_iCurBucket == iRHS.m_iCurBucket ) && 
         ( m_iter == iRHS.m_iter ) )   
        return TRUE;
    return FALSE;
}


//-----------------------------------------------------------------------------
// Name: NameIndexedCollection::iterator::operator!=()
// Desc: iterator comparison operator
//-----------------------------------------------------------------------------
BOOL NameIndexedCollection::iterator::operator!=( CONST NameIndexedCollection::iterator& iRHS)
{
    if ( ( m_pCollection == iRHS.m_pCollection ) &&
         ( m_iCurBucket == iRHS.m_iCurBucket ) && 
         ( m_iter == iRHS.m_iter ) )    
        return FALSE;
    return TRUE;
}


//-----------------------------------------------------------------------------
// Name: NameIndexedCollection::iterator::operator++()
// Desc: iterator increment
//-----------------------------------------------------------------------------
NameIndexedCollection::iterator& 
NameIndexedCollection::iterator::operator++( int )
{    
    assert( m_pCollection );

    // increment the iterator
    m_iter++;    

    // if we are at the end of a bucket, move to the next bucket
    while ( ( m_iter == m_pCollection->s_Lists[ m_iCurBucket ].end() ) &&
            ( m_iCurBucket < DEFAULT_COLLECTION_HASHSIZE - 1 ) )
    {        
        m_iCurBucket++;        
        m_iter = m_pCollection->s_Lists[ m_iCurBucket ].begin();
    }
        
    return (*this);
}


//-----------------------------------------------------------------------------
// Name: NameIndexedCollection::Add()
//-----------------------------------------------------------------------------
VOID NameIndexedCollection::Add( NamedTypedObject *pObjectToAdd )
{
    assert( pObjectToAdd );
    
    int iBucket = StringID::HashString( pObjectToAdd->GetName() ) % DEFAULT_COLLECTION_HASHSIZE;
    
    // $OPTIMIZE: use a fixed size allocator here
    s_Lists[ iBucket ].push_back( pObjectToAdd );            
}


//-----------------------------------------------------------------------------
// Name: NameIndexedCollection::Remove()
//-----------------------------------------------------------------------------
VOID NameIndexedCollection::Remove( NamedTypedObject *pObjectToRemove )
{
    assert( pObjectToRemove );
    
    int iBucket = StringID::HashString( pObjectToRemove->GetName() ) % DEFAULT_COLLECTION_HASHSIZE;
    s_Lists[ iBucket ].remove( pObjectToRemove );            
}


//-----------------------------------------------------------------------------
// Name: NameIndexedCollection::Find()
//-----------------------------------------------------------------------------
NamedTypedObject* NameIndexedCollection::Find( CONST WCHAR* strName )
{
    std::list<NamedTypedObject *>::iterator i;
    
    int iBucket = StringID::HashString( strName ) % DEFAULT_COLLECTION_HASHSIZE;    

    for ( i = s_Lists[ iBucket ].begin(); i != s_Lists[ iBucket ].end(); ++i )
    {
        if ( (*i)->GetName() == strName )
            break;
    }
    
    if ( i == s_Lists[ iBucket ].end() )
        return NULL;
    
    return (*i);
}


//-----------------------------------------------------------------------------
// Name: NameIndexedCollection::FindTyped()
//-----------------------------------------------------------------------------
NamedTypedObject* NameIndexedCollection::FindTyped( CONST WCHAR* strName, const StringID TypeID )
{
    std::list<NamedTypedObject *>::iterator i;

    int iBucket = StringID::HashString( strName ) % DEFAULT_COLLECTION_HASHSIZE;    

    for ( i = s_Lists[ iBucket ].begin(); i != s_Lists[ iBucket ].end(); ++i )
    {
        NamedTypedObject* pNTO = (*i);
        if ( pNTO->IsDerivedFrom( TypeID ) && pNTO->GetName() == strName )
            break;
    }

    if ( i == s_Lists[ iBucket ].end() )
        return NULL;

    return (*i);
}


DWORD NameIndexedCollection::Size()
{
    DWORD dwSize = 0;
    for( DWORD i = 0; i < DEFAULT_COLLECTION_HASHSIZE; i++ )
    {
        dwSize += s_Lists[i].size();
    }
    return dwSize;
}


//-----------------------------------------------------------------------------
// Name: NameIndexedCollection::begin()
//-----------------------------------------------------------------------------
NameIndexedCollection::iterator NameIndexedCollection::begin()
{
    NameIndexedCollection::iterator rtn;

    rtn.m_pCollection = this;
    rtn.m_iCurBucket = 0;
    rtn.m_iter = s_Lists[ rtn.m_iCurBucket ].begin();
    
    // if we are at the end of a bucket, move to the next bucket
    while ( ( rtn.m_iter == s_Lists[ rtn.m_iCurBucket ].end() ) &&
            ( rtn.m_iCurBucket != DEFAULT_COLLECTION_HASHSIZE - 1 ) )
    {        
        rtn.m_iCurBucket++;
        rtn.m_iter = s_Lists[ rtn.m_iCurBucket ].begin();
    }
        
    return rtn;
}


//----------------------------------------------------------------------------
// Name: NameIndexedCollection::end()
//-----------------------------------------------------------------------------
NameIndexedCollection::iterator NameIndexedCollection::end()
{
    NameIndexedCollection::iterator rtn;

    rtn.m_pCollection = this;
    rtn.m_iCurBucket = DEFAULT_COLLECTION_HASHSIZE - 1;
    rtn.m_iter = s_Lists[ DEFAULT_COLLECTION_HASHSIZE - 1].end();    
    
    return rtn;
}

} // namespace ATG

```

`XenonDumper/libs/Atg/AtgNamedTypedObject.h`:

```h
//-----------------------------------------------------------------------------
// ATGNamedTypedObject.h
//
// Base class for all scene objects that are named and typed
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef ATG_NamedTypedObject_H
#define ATG_NamedTypedObject_H

// C4127: conditional expression is constant
// this shows up when using STL without exception handling
#pragma warning(disable:4127)

#include <list>

namespace ATG
{

//-----------------------------------------------------------------------------
// Name: DEFINE_TYPE_INFO
// Desc: Creates a type based on the NamedTypedObject class.  Use this in any
//       classes derived from NamedTypedObject to get the IsDerived() functionality.
//-----------------------------------------------------------------------------
#ifndef DEFINE_TYPE_INFO
#define DEFINE_TYPE_INFO() \
    public: \
        virtual BOOL IsDerivedFrom( ATG::StringID _TypeID ) CONST  { if( _TypeID == TypeID ) return TRUE;  return __super::IsDerivedFrom( _TypeID ); } \
        virtual const ATG::StringID Type() CONST { return TypeID; } \
        static const ATG::StringID TypeID; 
#endif


//-----------------------------------------------------------------------------
// Name: StringID
// Desc: Memory management for strings- strings will be inserted into a hash
//       table uniquely, and can be referenced by pointer.  If you want to 
//       insert a string case-insensitively, use SetCaseInsensitive
//-----------------------------------------------------------------------------    

// This is the number of lists in the string hashtable - should be prime
const int StringID_HASHSIZE = 61;

class StringID
{
public:
    // Constructors
    StringID()                          { m_strString = s_EmptyString; }    
    StringID( CONST WCHAR* strString )  { m_strString = AddString( strString ); }
    StringID( CONST StringID& other )   { m_strString = other.m_strString; }

    // Assignment
    StringID& operator= ( CONST StringID& RHS ) { m_strString = RHS.m_strString; return *this; }    
    StringID& operator= ( CONST WCHAR* strRHS ) { m_strString = AddString( strRHS ); return *this; }

    // Comparison
    BOOL operator== ( CONST StringID& RHS ) CONST { return m_strString == RHS.m_strString; }    
    BOOL operator== ( CONST WCHAR* strRHS ) CONST;
    BOOL IsEmptyString() const { return m_strString == s_EmptyString; }

    // Casting
    operator CONST WCHAR* () CONST { return m_strString; }
    CONST WCHAR* GetSafeString() CONST { return ( m_strString ? m_strString : L"null" ); }
    
    // Hash lookup function
    static DWORD        HashString( CONST WCHAR* strString );    
protected:
    static CONST WCHAR* AddString( CONST WCHAR* strString );
    static std::list<CONST WCHAR *>* GetStringTable();

protected:
    CONST WCHAR*                    m_strString;               
    static CONST WCHAR*             s_EmptyString;
};

//-----------------------------------------------------------------------------
// Name: EnumStringMap
// Desc: Maps values to strings
//-----------------------------------------------------------------------------    
#ifndef ENUMSTRINGMAP_DEFINED
struct EnumStringMap
{
    DWORD        Value;
    CONST WCHAR* szName;
};
#define ENUMSTRINGMAP_DEFINED
#endif

//-----------------------------------------------------------------------------
// Name: NamedTypedObject
// Desc: The base class that all name-referenced objects inheirit from.
//       They have a StringID name and a static class StringID type.
//-----------------------------------------------------------------------------    

//! class name="NamedTypedObject" Desc="Base class for exposed objects"
//!    property name="Name" Desc="Name of the Object" Get=GetName Set=SetName

class NamedTypedObject
{    
// Because NamedTypedObject has no base class we explicitly define the type info here- most classes
// will us the DEFINE_TYPE_INFO macro, with an explicit callout in the .cpp file.
// TypeID is public so you can use NamedTypedObject::TypeID for comparisons without an instance.

public:
    virtual BOOL                IsDerivedFrom( StringID _TypeID ) CONST { return ( _TypeID == TypeID ); }    
    virtual const StringID      Type() CONST { return TypeID; }
    static const StringID       TypeID;

public:        
    CONST StringID&             GetName() CONST { return m_Name; };
    VOID                        SetName( CONST StringID& Name ) { m_Name = Name; }
    
private:
    StringID                    m_Name;
};


//-----------------------------------------------------------------------------
// Name: NameIndexedCollection
// Desc: A hash table, referenceable by name of NamedTypedObject objects
//-----------------------------------------------------------------------------    

// This is the number of lists in the collection hashtable - should be prime
// $TODO: Allow the size to be settable on a collection basis

const int DEFAULT_COLLECTION_HASHSIZE = 61;

class NameIndexedCollection
{
public:
    // iterator for the collection - it is made so you can 
    // delete the object at the current position and STILL do a ++
    // safely afterwards
    class iterator
    {
    friend class NameIndexedCollection;
    public:
        iterator();      

        NamedTypedObject*   operator*();
        iterator&               operator++( int ); // only postfix defined 
        iterator&               operator=( CONST iterator& iRHS );
        BOOL                    operator==( CONST iterator& iRHS );
        BOOL                    operator!=( CONST iterator& iRHS );
    private:   
        NameIndexedCollection*                  m_pCollection;
        std::list<NamedTypedObject*>::iterator  m_iter;        
        int                                         m_iCurBucket;
    };
    friend class NameIndexedCollection::iterator;
        
    VOID    Add( NamedTypedObject *pObjectToAdd );        // Add a NamedTypedObject to the collection        
    VOID    Remove( NamedTypedObject *pObjectToRemove );  // Remove a NamedTypedObject from the collection        
    NamedTypedObject* Find( CONST WCHAR* strName );       // Find a NamedTypedObject in the collection
    NamedTypedObject* FindTyped( CONST WCHAR* strName, const StringID TypeID );       // Find a NamedTypedObject of a certain type in the collection
    DWORD   Size();
       
    iterator        begin();
    iterator        end();
private:
    std::list<NamedTypedObject *> s_Lists[ DEFAULT_COLLECTION_HASHSIZE ];     
};

} // namespace ATG

#endif // ATG_NamedTypedObject_H

```

`XenonDumper/libs/Atg/AtgNuiCommon.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// AtgNuiCommon.cpp
//
// Common defines and macros for NUI samples 
//
// Advanced Technology Group (ATG)
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------

#include "stdafx.h"
#include "AtgNuiCommon.h"

namespace ATG
{

    //--------------------------------------------------------------------------------------
    // Name: struct QUALITY_FLAG_STRING
    // Desc: Maps identity  or head orientaion quality flags to human readable strings
    //--------------------------------------------------------------------------------------
    struct QUALITY_FLAG_STRING
    {
        DWORD dwFlag;
        WCHAR* pwszPrompt;
    };


    //--------------------------------------------------------------------------------------
    // Name: s_IdentityQualityStringTable[]
    // Desc  List of strings representing quality flags to be displayed to the player.
    //
    // Note: The strings are listed in order of priority. When more than one flag is set, 
    //       only the first matching string in the list is displayed.
    //--------------------------------------------------------------------------------------
    static const QUALITY_FLAG_STRING s_IdentityQualityStringTable[] =
    {
        { NUI_IDENTITY_QUALITY_ENVIRONMENT_TOO_DARK,            L"Make sure your room is well lit." },
        { NUI_IDENTITY_QUALITY_ENVIRONMENT_TOO_BRIGHT,          L"Avoid pointing lights directly at the sensor." },

        { NUI_IDENTITY_QUALITY_USER_OCCLUDED_FACE,              L"Don't cover your face." },
        { NUI_IDENTITY_QUALITY_USER_OCCLUDED_BODY,              L"Put your hands down." },

        { NUI_IDENTITY_QUALITY_USER_BODY_TURNED,                L"Face the sensor." },
        { NUI_IDENTITY_QUALITY_USER_NOT_UPRIGHT,                L"Stand up straight." },

        { NUI_IDENTITY_QUALITY_USER_FAR_AWAY,                   L"Move closer to the sensor." },
        { NUI_IDENTITY_QUALITY_USER_CLOSE,                      L"Move away from the sensor." },

        { NUI_IDENTITY_QUALITY_USER_CLIPPED_AT_LEFT,            L"Move to the right." },
        { NUI_IDENTITY_QUALITY_USER_CLIPPED_AT_RIGHT,           L"Move to the left." },

                                                                
        // Displaying the following text is not enough to handle this situation correctly as it usually requires tilting the sensor 
        // and should be handled by the title's play space management code.
        { NUI_IDENTITY_QUALITY_USER_CLIPPED_AT_TOP,             L"You are too close. Move away from the sensor." },	

        { NUI_IDENTITY_QUALITY_ENVIRONMENT_FACE_DETECT_FAILURE, L"Kinect can't see your face clearly.\nIf the problem persists, go to the Kinect Tuner." },

        { NUI_IDENTITY_QUALITY_USER_CLIPPED_AT_BOTTOM,          L"" }, // This specific situation usually requires tilting the sensor and should be handled 
                                                                       // by the title's play space management code. 
    };

    //--------------------------------------------------------------------------------------
    // Name: s_HeadOrientationQualityStringTable[]
    // Desc  List of strings representing quality flags to be displayed to the player.
    //
    // Note: The strings are listed in order of priority. When more than one flag is set, 
    //       only the first matching string in the list is displayed.
    //--------------------------------------------------------------------------------------
    static const QUALITY_FLAG_STRING s_HeadOrientationQualityStringTable[] =
    {
        { NUI_HEAD_ORIENTATION_QUALITY_TOO_DARK,                L"Make sure your room is well lit." },

        { NUI_HEAD_ORIENTATION_QUALITY_HANDS_OCCLUDING_FACE,    L"Don't cover your face." },

        { NUI_HEAD_ORIENTATION_QUALITY_CLOSE_TO_LEFT,           L"Move to the right." },
        { NUI_HEAD_ORIENTATION_QUALITY_CLOSE_TO_RIGHT,          L"Move to the left." },

        // Displaying the following text is not enough to handle this situation correctly as it usually requires tilting the sensor 
        // and should be handled by the title's play space management code.
        { NUI_HEAD_ORIENTATION_QUALITY_CLOSE_TO_TOP,            L"You are too close. Move away from the sensor." },

        { NUI_HEAD_ORIENTATION_QUALITY_FACE_DETECT_FAILURE,     L"Kinect can't see your face clearly.\nIf the problem persists, go to the Kinect Tuner." },

        { NUI_HEAD_ORIENTATION_QUALITY_CLOSE_TO_BOTTOM,         L"" }, // This specific situation usually requires tilting the sensor and should be handled 
                                                                       // by the title's play space management code. 

        { NUI_HEAD_ORIENTATION_QUALITY_FAILURE,                 L"" }, // the orientation result is invalid
    };

    //--------------------------------------------------------------------------------------
    // Outputs verbose error message from NUI errors
    //--------------------------------------------------------------------------------------
    VOID NuiPrintError( HRESULT hResult, const CHAR* szFunctionName )
    {
        switch (hResult)
        {
        case E_INVALIDARG:
            ATG_PrintError( "%s failed with E_INVALIDARG\n", szFunctionName );
            break;

        case E_NUI_ALREADY_INITIALIZED:
            ATG_PrintError( "%s failed with E_NUI_ALREADY_INITIALIZED\n", szFunctionName );
            break;

        case E_NUI_DATABASE_NOT_FOUND:
            ATG_PrintError( "%s failed with E_NUI_DATABASE_NOT_FOUND\n", szFunctionName );
            break;

        case E_NUI_DATABASE_VERSION_MISMATCH:
            ATG_PrintError( "%s failed with E_NUI_DATABASE_VERSION_MISMATCH\n", szFunctionName );
            break;

        case E_OUTOFMEMORY:
            ATG_PrintError( "%s failed with E_OUTOFMEMORY\n", szFunctionName );
            break;

        case E_NUI_DEVICE_NOT_READY:
            ATG_PrintError( "%s failed with E_NUI_DEVICE_NOT_READY\n", szFunctionName );
            break;

        case E_NUI_DEVICE_NOT_CONNECTED:
            ATG_PrintError( "%s failed with E_NUI_DEVICE_NOT_CONNECTED\n", szFunctionName );
            break;

        case E_NUI_FEATURE_NOT_INITIALIZED:
            ATG_PrintError( "%s failed with E_NUI_FEATURE_NOT_INITIALIZED\n", szFunctionName );
            break;

        case E_NUI_IMAGE_STREAM_IN_USE:
            ATG_PrintError( "%s failed with E_NUI_IMAGE_STREAM_IN_USE\n", szFunctionName );
            break;

        default:
            ATG_PrintError( "%s failed with 0x%x\n", szFunctionName, (UINT)hResult );
        }
    }

    //--------------------------------------------------------------------------------------
    // Applies tilt correction to the skeleton data data. Source and destination can be the same
    //--------------------------------------------------------------------------------------
    VOID ApplyTiltCorrectionInPlayerSpace( NUI_SKELETON_FRAME* pDstSkeleton, const NUI_SKELETON_FRAME* pSrcSkeleton )
    {
        assert( pDstSkeleton );
        assert( pSrcSkeleton );

        if ( !pDstSkeleton ||
             !pSrcSkeleton )
        {
            return;
        }

        static const XMVECTOR vUp = XMVectorSet( 0.0f, 1.0f, 0.0f, 0.0f );
        static XMVECTOR vAverageSpine[ NUI_SKELETON_COUNT ] = { XMVectorZero(), XMVectorZero(), XMVectorZero(),
                                                                XMVectorZero(), XMVectorZero(), XMVectorZero() };
        static XMVECTOR vAverageNormalToGravity = pSrcSkeleton->vNormalToGravity;

        // Get a valid up vector
        XMVECTOR vNormToGrav = pSrcSkeleton->vNormalToGravity;

        // Check for an invalid up vector (we will synthesize it from
        // the floor plane if that data is present). If we can't get an up
        // vector, we default to 0.0, 1.0, 0.0 instead.
        if ( fabs(vNormToGrav.x) < FLT_EPSILON &&
             fabs(vNormToGrav.y) < FLT_EPSILON &&
             fabs(vNormToGrav.z) < FLT_EPSILON )
        {
            vNormToGrav = vUp;
        }

        // Calculate running average of vector
        vAverageNormalToGravity = XMVectorLerp( vAverageNormalToGravity, vNormToGrav, 0.1f );

        // Generate the leveling matrix and apply it to all points on any skeletons
        // which are currently being tracked. 
        XMMATRIX matLevel = NuiTransformMatrixLevel( vAverageNormalToGravity );

        for ( INT i = 0 ; i < NUI_SKELETON_COUNT; i++ )
        {
            const NUI_SKELETON_DATA* pSkeletonData = &pSrcSkeleton->SkeletonData[ i ];
            XMVECTOR vSpine = pSkeletonData->SkeletonPositions[ NUI_SKELETON_POSITION_SPINE ];

            if ( pSkeletonData->eTrackingState != NUI_SKELETON_TRACKED )
            {
                vAverageSpine[ i ] = XMVectorZero();
                continue;
            }
            else
            {
                UINT uCompareResults;
                XMVectorEqualR( &uCompareResults, XMVectorZero(), vAverageSpine[ i ] );

                // if still set to zero, then start the running average
                if( XMComparisonAllTrue( uCompareResults ) )
                {
                    vAverageSpine[ i ] = vSpine;
                }
            }

            // Running average of spine
            vAverageSpine[ i ] = XMVectorLerp( vAverageSpine[ i ], vSpine, 0.1f );

            XMFLOAT4 fAverageSpine;
            XMStoreFloat4( &fAverageSpine, vAverageSpine[ i ] );
            XMMATRIX matTranslateToOrigin = XMMatrixTranslation( -fAverageSpine.x, 0, -fAverageSpine.z );
            XMMATRIX matTranslateFromOrigin = XMMatrixTranslation( fAverageSpine.x, 0, fAverageSpine.z );
            XMMATRIX matTransformation = matTranslateToOrigin * matLevel * matTranslateFromOrigin;

            for ( UINT j = 0; j < NUI_SKELETON_POSITION_COUNT; j++ )
            {
                pDstSkeleton->SkeletonData[ i ].SkeletonPositions[ j ] = XMVector3Transform( pSkeletonData->SkeletonPositions[ j ], matLevel );
            }
        }
    }


    //--------------------------------------------------------------------------------------
    // Name: GetQualityFlagPrompt()
    // Desc: Returns a human readable text string that explains the most important quality 
    //       flag.
    //--------------------------------------------------------------------------------------
    const WCHAR* GetQualityFlagPrompt( const QUALITY_FLAG_STRING* pQualityStringTable, DWORD dwQualityStringCount, DWORD dwQualityFlags )
    {
        WCHAR* pwszPrompt = L"";

        if( dwQualityFlags > 0 )
        {
            for( DWORD i = 0; i < dwQualityStringCount; i++)
            {
                if( dwQualityFlags & pQualityStringTable[ i ].dwFlag )
                {
                    pwszPrompt = pQualityStringTable[ i ].pwszPrompt;
                    break;
                }
            }
        }

        return pwszPrompt;
    }


    //--------------------------------------------------------------------------------------
    // Name: GetIdentityQualityFlagPrompt()
    // Desc: Returns a human readable text string that explains the most important quality 
    //       flag.
    //
    // Note: See the s_IdentityQualityStringTable[] for the order of importance of the flags
    //--------------------------------------------------------------------------------------
    const WCHAR* GetIdentityQualityFlagPrompt( DWORD dwIdentityQualityFlags )
    {
        return  GetQualityFlagPrompt( s_IdentityQualityStringTable, _countof( s_IdentityQualityStringTable), dwIdentityQualityFlags );
    }

    //--------------------------------------------------------------------------------------
    // Name: GetHeadOrientationQualityFlagPrompt()
    // Desc: Returns a human readable text string that explains the most important quality 
    //       flag.
    //
    // Note: See the s_HeadOrientationQualityStringTable[] for the order of importance of
    //       the flags
    //--------------------------------------------------------------------------------------
    const WCHAR* GetHeadOrientationQualityFlagPrompt( DWORD dwHeadOrientationQualityFlags )
    {
        return  GetQualityFlagPrompt( s_HeadOrientationQualityStringTable, _countof( s_HeadOrientationQualityStringTable ), dwHeadOrientationQualityFlags );
    }

};

```

`XenonDumper/libs/Atg/AtgNuiCommon.h`:

```h
//--------------------------------------------------------------------------------------
// AtgNuiCommon.h
//
// Common defines and macros for NUI samples 
//
// Advanced Technology Group (ATG)
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------

#pragma once
#ifndef ATG_NUI_COMMON_H
#define ATG_NUI_COMMON_H

#include <NuiApi.h>
#include "AtgUtil.h"

namespace ATG
{
    // NuiSkeletonGetNextFrame and NuiImageStreamGetNextFrame require a maximum wait time to be passed into the function.  
    // If this is 0, then the app can easily become 1 frame behind the camera introducing lag into the system.
    // This value is a maximum time so the app will likely return before the 10 ms.
    // 10 to 15 ms has been a good amount of time to wait.
    // Alternatively an application could do 10 to 15 ms of work and pass in 0.
    #define NUI_CAMERA_TIMEOUT_DEFAULT 10

    // The event set via NuiSetFrameEndEvent is used to synchronize reads with NuiSkeletonGetNextFrame and NuiImageStreamGetNextFrame.
    // When waiting on this event, the timeout needs to be long enough that frame processing will complete and be synchronized.
    // 100 ms ensures proper synchronization with NUI when using NuiSetFrameEndEvent.
    // When using NuiSetFrameEndEvent, calls to NuiSkeletonGetNextFrame and NuiImageStreamGetNextFrame should use a timeout of 0.
    #define NUI_FRAME_END_TIMEOUT_DEFAULT 100

    VOID NuiPrintError( HRESULT hResult, const CHAR* szFunctionName );

    VOID ApplyTiltCorrectionInPlayerSpace( NUI_SKELETON_FRAME* pDstSkeleton, const NUI_SKELETON_FRAME* pSrcSkeleton );

    const WCHAR* GetIdentityQualityFlagPrompt( DWORD dwIdentityQualityFlags );
    const WCHAR* GetHeadOrientationQualityFlagPrompt( DWORD dwHeadOrientationQualityFlags );
};

#endif // ATG_NUI_COMMON_H
```

`XenonDumper/libs/Atg/AtgNuiHandRefinement.cpp`:

```cpp

// ********************************************************************************************************* //
// --------------------------------------------------------------------------------------------------------- //
//
// Copyright (c) Microsoft Corporation
//
// --------------------------------------------------------------------------------------------------------- //
// ********************************************************************************************************* //

#include "stdafx.h"
#include "AtgNuiHandRefinement.h"
#include <math.h>

// ********************************************************************************************************* //
//
//  Namespace:
//

namespace ATG
{

//--------------------------------------------------------------------------------------
// Name: struct SpiralSearchLocation
// Desc: An array of these makes up the spiraling outward search pattern that is used
//  to build a mask around the hand
//--------------------------------------------------------------------------------------
struct SpiralSearchLocation
{
    INT2Vector m_iSearchSpot;
    INT m_iSearchDirection;
    INT m_iOffsetIn80x60;
    INT m_iOffsetIn12x12;
};

// The 50 or so entries in this mask are precalculated to result in exact offsets 
// for the spiral search.  So the offset calculation is now a lookup and an addition.
SpiralSearchLocation g_UnrolledNeighborSearchSpiral[] = 
{
    // ring 1 
    INT2Vector(-1, 0), 4, 0, 0,
    INT2Vector(-1, -1), 5, 0, 0, 
    INT2Vector(0, -1), 6, 0, 0, 
    INT2Vector(1, -1), 7, 0, 0, 
    INT2Vector(1, 0), 0, 0, 0, 
    INT2Vector(1, 1), 1, 0, 0, 
    INT2Vector(0, 1), 2, 0, 0,
    INT2Vector(-1, 1), 3, 0, 0,

    //ring 2
    INT2Vector(-2, 0), 4, 0, 0,
    INT2Vector(-2, -1), 4, 0, 0, 
    INT2Vector(-2, -2), 5, 0, 0,
    INT2Vector(-1, -2), 6, 0, 0,
    INT2Vector(0, -2), 6, 0, 0, 
    INT2Vector(1, -2), 6, 0, 0, 
    INT2Vector(2, -2), 7, 0, 0, 
    INT2Vector(2, -1), 0, 0, 0, 
    INT2Vector(2, 0), 0, 0, 0, 
    INT2Vector(2, 1), 0, 0, 0, 
    INT2Vector(2, 2), 1, 0, 0, 
    INT2Vector(1, 2), 2, 0, 0, 
    INT2Vector(0, 2), 2, 0, 0,
    INT2Vector(-1, 2), 2, 0, 0,
    INT2Vector(-2, 2), 3, 0, 0,
    INT2Vector(-2, 1), 4, 0, 0,

    //ring 3
    INT2Vector(-3, 0), 4, 0, 0,
    INT2Vector(-3, -1), 4, 0, 0,
    INT2Vector(-3, -2), 4, 0, 0,
    INT2Vector(-3, -3), 5, 0, 0,
    INT2Vector(-2, -3), 6, 0, 0,
    INT2Vector(-1, -3), 6, 0, 0,
    INT2Vector(0, -3), 6, 0, 0,
    INT2Vector(1, -3), 6, 0, 0,
    INT2Vector(2, -3), 6, 0, 0,
    INT2Vector(3, -3), 7, 0, 0,
    INT2Vector(3, -2), 0, 0, 0,
    INT2Vector(3, -1), 0, 0, 0,
    INT2Vector(3, 0), 0, 0, 0,
    INT2Vector(3, 1), 0, 0, 0,
    INT2Vector(3, 2), 0, 0, 0,
    INT2Vector(3, 3), 1, 0, 0,
    INT2Vector(2, 3), 2, 0, 0,
    INT2Vector(1, 3), 2, 0, 0,
    INT2Vector(0, 3), 2, 0, 0,
    INT2Vector(-1, 3), 2, 0, 0,
    INT2Vector(-2, 3), 2, 0, 0,
    INT2Vector(-3, 3), 3, 0, 0,
    INT2Vector(-3, 2), 4, 0, 0,
    INT2Vector(-3, 1), 4, 0, 0,

    //ring 4
    INT2Vector(-4, 0), 4, 0, 0,
    INT2Vector(-4, -1), 4, 0, 0,
    INT2Vector(-4, -2), 4, 0, 0,
    INT2Vector(-4, -3), 4, 0, 0,
    INT2Vector(-4, -4), 5, 0, 0,
    INT2Vector(-3, -4), 6, 0, 0,
    INT2Vector(-2, -4), 6, 0, 0,
    INT2Vector(-1, -4), 6, 0, 0,
    INT2Vector(0, -4), 6, 0, 0,
    INT2Vector(1, -4), 6, 0, 0,
    INT2Vector(2, -4), 6, 0, 0,
    INT2Vector(3, -4), 6, 0, 0,
    INT2Vector(4, -4), 7, 0, 0,
    INT2Vector(4, -3), 0, 0, 0,
    INT2Vector(4, -2), 0, 0, 0,
    INT2Vector(4, -1), 0, 0, 0,
    INT2Vector(4, 0), 0, 0, 0,
    INT2Vector(4, 1), 0, 0, 0,
    INT2Vector(4, 2), 0, 0, 0,
    INT2Vector(4, 3), 0, 0, 0,
    INT2Vector(4, 4), 1, 0, 0,
    INT2Vector(3, 4), 2, 0, 0,
    INT2Vector(2, 4), 2, 0, 0,
    INT2Vector(1, 4), 2, 0, 0,
    INT2Vector(0, 4), 2, 0, 0,
    INT2Vector(-1, 4), 2, 0, 0,
    INT2Vector(-2, 4), 2, 0, 0,
    INT2Vector(-3, 4), 2, 0, 0,
    INT2Vector(-4, 4), 3, 0, 0,
    INT2Vector(-4, 3), 4, 0, 0,
    INT2Vector(-4, 2), 4, 0, 0,
    INT2Vector(-4, 1), 4, 0, 0,

    //ring5
    INT2Vector(-5, 0), 4, 0, 0,
    INT2Vector(-5, -1), 4, 0, 0,
    INT2Vector(-5, -2), 4, 0, 0,
    INT2Vector(-5, -3), 4, 0, 0,
    INT2Vector(-5, -4), 4, 0, 0,
    INT2Vector(-5, -5), 5, 0, 0,
    INT2Vector(-4, -5), 6, 0, 0,
    INT2Vector(-3, -5), 6, 0, 0,
    INT2Vector(-2, -5), 6, 0, 0,
    INT2Vector(-1, -5), 6, 0, 0,
    INT2Vector(0, -5), 6, 0, 0,
    INT2Vector(1, -5), 6, 0, 0,
    INT2Vector(2, -5), 6, 0, 0,
    INT2Vector(3, -5), 6, 0, 0,
    INT2Vector(4, -5), 6, 0, 0,
    INT2Vector(5, -5), 7, 0, 0,
    INT2Vector(5, -4), 0, 0, 0,
    INT2Vector(5, -3), 0, 0, 0,
    INT2Vector(5, -2), 0, 0, 0,
    INT2Vector(5, -1), 0, 0, 0,
    INT2Vector(5, 0), 0, 0, 0,
    INT2Vector(5, 1), 0, 0, 0,
    INT2Vector(5, 2), 0, 0, 0,
    INT2Vector(5, 3), 0, 0, 0,
    INT2Vector(5, 4), 0, 0, 0,
    INT2Vector(5, 5), 1, 0, 0,
    INT2Vector(4, 5), 2, 0, 0,
    INT2Vector(3, 5), 2, 0, 0,
    INT2Vector(2, 5), 2, 0, 0,
    INT2Vector(1, 5), 2, 0, 0,
    INT2Vector(0, 5), 2, 0, 0,
    INT2Vector(-1, 5), 2, 0, 0,
    INT2Vector(-2, 5), 2, 0, 0,
    INT2Vector(-3, 5), 2, 0, 0,
    INT2Vector(-4, 5), 2, 0, 0,
    INT2Vector(-5, 5), 3, 0, 0,
    INT2Vector(-5, 4), 4, 0, 0,
    INT2Vector(-5, 3), 4, 0, 0,
    INT2Vector(-5, 2), 4, 0, 0,
    INT2Vector(-5, 1), 4, 0, 0

};

// The search diretions used to walk along the arm.  The vector between the elbow and 
// the hand can be wrong. It is mostly correct.  These directions are used to search the 8
// cardinal directions and diagonals that correspond to a give elbow hand direction.

enum SearchDirections
{
    SEARCHDIRECTION_FORWARD = 0,
    SEARCHDIRECTION_DIAGONAL_LEFT,
    SEARCHDIRECTION_DIAGONAL_RIGHT,
    SEARCHDIRECTION_ORTHOGONAL_LEFT,
    SEARCHDIRECTION_ORTHOGONAL_RIGHT,
    SEARCHDIRECTION_COUNT
};

// When walking to the end of the hand. we're looking for small changes as we're trying to stay on the arm.
// If the change is greater than 4 centimeters or 3 centimeters (depending on fall back code)
// we don't want to follow that direction.
static CONST INT g_iWalktoEndofHandThesholds[] = { 40, 30 };

// We start at the beginning of this list of thresholds and continue 
// building masks until we build a valid threshold.
static CONST INT g_iBuildMaskThresholds[] = {130, 80, 50, 30};

// This bias is added to the difference between the neighbor and the current pixel to
// bias towards the directions that are more aligned to the elbow hand vector.
static CONST INT g_iBiasFor5SearchDirections[] = {0, 40, 40, 80, 80};

// We test the hand against the depth map. If the hand is much closer to the camera than the map
// then we know that we have a compound fracture.
static CONST INT g_iDistanceOffDepthMaptoWarrantLargeSearch = 100;

// This smaller threshold tells us the bone is only poking out of the arm a little.
static CONST INT g_iDistanceOffDepthMaptoWarrantSmallSearch = 20;

// Number of iterations to walk along the arm in the 80x60 map.
static CONST INT g_nWalkToEdgeIterations = 12; 

// These two thresholds are used to build a 3 division histogram for segmenting the hand away from the body
static CONST INT g_iCenterFor320x240CloseThreshold = 50;
static CONST INT g_iCenterFor320x240FarThreshold = 150;

// - in y is up
// The search directions for the 8 surrounding pixels
static CONST INT2Vector g_SpiralSearchOffsets[] =
{
    INT2Vector(-1, 0),
    INT2Vector(-1, -1),
    INT2Vector(0, -1),
    INT2Vector(1, -1),
    INT2Vector(1, 0),
    INT2Vector(1, 1),
    INT2Vector(0, 1),
    INT2Vector(-1, 1)
};

// Do it branchless on PPC
// These are branchless instructions to avoid branch mispredictions
// Determine the difference between them.
// diff = (a<b) ? (a-b) : 0;
// a-(a-b) = b; // Flip if (a<b)
// b+(a-b) = a; // Flip if (a>b)
#define GETMIN(dst,a,b) diff = a-b; mask = diff>>31; diff = diff&mask; dst = b+diff    
#define GETMAX(dst,a,b) diff = a-b; mask = diff>>31; diff = diff&mask; dst = a-diff  

// This abs function is much faster but assumes I'm only comparing shorts.
__forceinline INT INTABSFAST( INT iIn )
{
    INT i = (iIn ^ (iIn >> 31)) - (iIn >> 31);
    return i;
}
static CONST INT g_iMaxImageDepth = NUI_IMAGE_DEPTH_MAXIMUM >> NUI_IMAGE_PLAYER_INDEX_SHIFT;

//--------------------------------------------------------------------------------------
// Simplifies passing the depth maps.
//--------------------------------------------------------------------------------------
struct DepthMaps
{
    USHORT* m_pData320x240;
    INT m_iShortPitch320x240;
    USHORT* m_pData80x60Min;
    INT m_iShortPitch80x60Min;
};

// These offsets represent 4 groups of xy coordinates
// This makes indexing memory a lookup and an addition.
// InitUnrolledNeighborSearchSpiral fills in these values because they depend upon pitch.
INT g_SpiralSearchOffsets80x60[] = {0,0,0,0,0,0,0,0};
INT g_SpiralSearchOffsets12x12[] = {0,0,0,0,0,0,0,0};

//--------------------------------------------------------------------------------------
// Name: InitUnrolledNeighborSearchSpiral()
// Desc: Fills in the offsets for the search structure. Now an offset can be calculated 
// for any location in the search spiral with a simple addition.
//--------------------------------------------------------------------------------------
VOID InitUnrolledNeighborSearchSpiral( INT iShortPitch80x60Min )
{
    // This is not thread safe
    if ( g_UnrolledNeighborSearchSpiral[0].m_iOffsetIn12x12 != 0 ) return;
        
    INT iSearchIterations = ARRAYSIZE( g_UnrolledNeighborSearchSpiral );
    g_UnrolledNeighborSearchSpiral[0].m_iOffsetIn80x60 = g_UnrolledNeighborSearchSpiral[0].m_iSearchSpot.iX + 
        (g_UnrolledNeighborSearchSpiral[0].m_iSearchSpot.iY ) * iShortPitch80x60Min;
    g_UnrolledNeighborSearchSpiral[0].m_iOffsetIn12x12 = g_UnrolledNeighborSearchSpiral[0].m_iSearchSpot.iX + 
        (g_UnrolledNeighborSearchSpiral[0].m_iSearchSpot.iY ) * g_iNuiRefinementKernelSize80x60;

    for ( INT iIndex = 1; iIndex < iSearchIterations; ++iIndex )
    {
        SpiralSearchLocation* pPrevious = &g_UnrolledNeighborSearchSpiral[iIndex-1];
        SpiralSearchLocation* pCurrent = &g_UnrolledNeighborSearchSpiral[iIndex];
        pCurrent->m_iOffsetIn80x60 = 
            pCurrent->m_iSearchSpot.iX - pPrevious->m_iSearchSpot.iX + 
            ( pCurrent->m_iSearchSpot.iY -  pPrevious->m_iSearchSpot.iY ) * iShortPitch80x60Min;
        pCurrent->m_iOffsetIn12x12 = 
            pCurrent->m_iSearchSpot.iX - pPrevious->m_iSearchSpot.iX + 
            ( pCurrent->m_iSearchSpot.iY -  pPrevious->m_iSearchSpot.iY ) * g_iNuiRefinementKernelSize80x60;
    }
    g_SpiralSearchOffsets80x60[0] = -1;
    g_SpiralSearchOffsets80x60[1] = -1 - iShortPitch80x60Min;
    g_SpiralSearchOffsets80x60[2] = -iShortPitch80x60Min;
    g_SpiralSearchOffsets80x60[3] = 1 - iShortPitch80x60Min;
    g_SpiralSearchOffsets80x60[4] = 1;
    g_SpiralSearchOffsets80x60[5] = 1 + iShortPitch80x60Min;
    g_SpiralSearchOffsets80x60[6] = iShortPitch80x60Min;
    g_SpiralSearchOffsets80x60[7] = -1 + iShortPitch80x60Min;
    g_SpiralSearchOffsets12x12[0] = -1;
    g_SpiralSearchOffsets12x12[1] = -1 - g_iNuiRefinementKernelSize80x60;
    g_SpiralSearchOffsets12x12[2] = -g_iNuiRefinementKernelSize80x60;
    g_SpiralSearchOffsets12x12[3] = 1 - g_iNuiRefinementKernelSize80x60;
    g_SpiralSearchOffsets12x12[4] = 1;
    g_SpiralSearchOffsets12x12[5] = 1 + g_iNuiRefinementKernelSize80x60;
    g_SpiralSearchOffsets12x12[6] = g_iNuiRefinementKernelSize80x60;
    g_SpiralSearchOffsets12x12[7] = -1 + g_iNuiRefinementKernelSize80x60;
    
}

//--------------------------------------------------------------------------------------
// Name: Clamp80x60()
// Desc: Clamps values to be valid lookup valus in a 80x60 map
//--------------------------------------------------------------------------------------
__forceinline void Clamp80x60( INT* pX, INT* pY )
{
    INT diff, mask;
    INT iMin;
    GETMIN( iMin, 79, *pX );
    GETMAX( *pX, iMin, 0 ); 
    GETMIN( iMin, 59, *pY );
    GETMAX( *pY, iMin, 0 ); 
}

//--------------------------------------------------------------------------------------
// Name: Clamp80x60()
// Desc: Clamps values to be valid lookup valus in a 320x240 map
//--------------------------------------------------------------------------------------
__forceinline void Clamp320x240( INT* pX, INT* pY )
{
    INT diff, mask;
    INT iMin;
    GETMIN( iMin, 319, *pX );
    GETMAX( *pX, iMin, 0 ); 
    GETMIN( iMin, 239, *pY );
    GETMAX( *pY, iMin, 0 ); 
}

//-----------------------------------------------------------------------------
// Name: TransformWorldToScreen320x240
// Desc:Transforms from world coordinates to camera coordinates.
//
// - w: The world coordinates (in milimeters)
// - screenY: The x coordinate in camera space
// - screenY: The y coordinate in camera space
//-----------------------------------------------------------------------------
__forceinline void TransformWorldToScreen320x240(
                                   _In_ XMVECTOR w, 
                                   _In_ FLOAT FOV_X_DEGREES, 
                                   _Out_ INT* pScreenX, 
                                   _Out_ INT* pScreenY)
{
    static FLOAT TAN_FOV_PER_PIXEL_INV = ( (320.0f)/2.0f ) / tan( XMConvertToRadians( NUI_CAMERA_DEPTH_NOMINAL_HORIZONTAL_FOV * 0.5f ) );
    *pScreenX = (INT)( ( w.x * TAN_FOV_PER_PIXEL_INV ) /w.z + (320.0f)/2.0f );
    *pScreenY = (INT)( (240.0f)/2.0f - ( w.y * TAN_FOV_PER_PIXEL_INV ) /w.z );
}

//-----------------------------------------------------------------------------
// Name: TransformWorldToScreen80x60
// Desc:Transforms from world coordinates to camera coordinates.
//
// - w: The world coordinates (in milimeters)
// - screenY: The x coordinate in camera space
// - screenY: The y coordinate in camera space
//-----------------------------------------------------------------------------
__forceinline void TransformWorldToScreen80x60(
                                   _In_ XMVECTOR w, 
                                   _Out_ INT3Vector* pCoord )
{
    static FLOAT TAN_FOV_PER_PIXEL_INV = ( (80.0f)/2.0f ) / 
        tan( XMConvertToRadians( NUI_CAMERA_DEPTH_NOMINAL_HORIZONTAL_FOV * 0.5f ) );
    pCoord->iX = (INT)( ( w.x * TAN_FOV_PER_PIXEL_INV ) /w.z + (80.0f)/2.0f );
    pCoord->iY = (INT)( 60.0f / 2.0f - ( w.y * TAN_FOV_PER_PIXEL_INV ) /w.z );
    pCoord->iZ = (INT)( XMVectorGetZ( w ) * 1000.0f);
}

//-----------------------------------------------------------------------------
// Name: TransformScreenToWorld320x240
// Desc: Transforms from camera to world coordinates. The world coordinates are 
// represented in milimeters.
//
// - screenX: The x coordinate
// - screenY: The y coordinate
// - screenZ: The depth
// - pWX:     The x position of the point in world space
// - pWY:     The y position of the point in world space
// - pWZ:     The z position of the point in world space
//-----------------------------------------------------------------------------
__forceinline void TransformScreenToWorld320x240(
                                   _In_ FLOAT screenX, 
                                   _In_ FLOAT screenY, 
                                   _In_ FLOAT screenZ, 
                                   _Out_ XMVECTOR* pW)
{
    static const FLOAT TAN_FOV_PER_PIXEL = 
        tan( XMConvertToRadians( NUI_CAMERA_DEPTH_NOMINAL_HORIZONTAL_FOV * 0.5f ) ) / ( ((FLOAT)320)/2.0f);

    pW->x = ( ( screenX - ( 320.0f ) / 2.0f ) * screenZ * TAN_FOV_PER_PIXEL );
    pW->y = ( ( ( 240.0f ) / 2.0f - screenY ) * screenZ * TAN_FOV_PER_PIXEL );
    pW->z = (FLOAT)screenZ;
    pW->w = 1.0f;
}

//-----------------------------------------------------------------------------
// Name: TransformScreenToWorld80x60
// Desc: Transforms from camera to world coordinates. The world coordinates are 
// represented in milimeters.
//
// - screenX: The x coordinate
// - screenY: The y coordinate
// - screenZ: The depth
// - pWX:     The x position of the point in world space
// - pWY:     The y position of the point in world space
// - pWZ:     The z position of the point in world space
//-----------------------------------------------------------------------------
__forceinline void TransformScreenToWorld80x60(
                                   _In_ FLOAT screenX, 
                                   _In_ FLOAT screenY, 
                                   _In_ FLOAT screenZ, 
                                   _Out_ XMVECTOR* pW )
{
    static const FLOAT TAN_FOV_PER_PIXEL = 
        tan( XMConvertToRadians( NUI_CAMERA_DEPTH_NOMINAL_HORIZONTAL_FOV * 0.5f ) ) / ( ((FLOAT)80)/2.0f);

    pW->x = ( ( screenX - ( 80.0f ) / 2.0f ) * screenZ * TAN_FOV_PER_PIXEL );
    pW->y = ( ( (60.0f)/2.0f - (FLOAT)screenY ) * screenZ * TAN_FOV_PER_PIXEL );
    pW->z = screenZ;
    pW->w = 1.0f;
}

//--------------------------------------------------------------------------------------
// Name: FindAverageForHand320x240
// Desc: This function uses the location in the 80x60 map to calculate the average from 
// the 320x240 depth map.
//--------------------------------------------------------------------------------------
INT FindAverageForHand320x240 ( DepthMaps* __restrict pDMS,
                               RefinementData* __restrict pRefinementData,
                               HandSpecificData* __restrict pHandSpecificData,
                               XMVECTOR* __restrict pRefinedHand,
                               OptionalRefinementData* __restrict pOptionalRefinementData,
                               OptionalHandSpecificData* __restrict pEHSP
                              )
{
    static CONST INT iBeginOffsetfor12x12ThresholdSearch = -3;
    static CONST INT iEbdOffsetfor12x12ThresholdSearch = 9;

    INT iShortPitch320x240 = pDMS->m_iShortPitch320x240;
    USHORT* pDepth320x240 = pDMS->m_pData320x240;
    INT iShortPitch80x60 = pDMS->m_iShortPitch80x60Min;
    USHORT* pDepth80x60 = pDMS->m_pData80x60Min;

    INT3Vector iRefinedPosition80x60 = pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60;

    INT3Vector iSearchLocation320x240 = pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60;
    iSearchLocation320x240.iX *= 4;
    iSearchLocation320x240.iY *= 4;
    iSearchLocation320x240.iZ = pDepth80x60[pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iX +
        pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iY * iShortPitch80x60] >> NUI_IMAGE_PLAYER_INDEX_SHIFT;

#ifdef DEBUG_COMPUTE_AND_SHOW_VISUALIZATION
    memset( &pHandSpecificData->m_VisualizeHandFramesData, 2, sizeof (VisualizeHandFramesData) );
#endif

    INT2Range XRange, YRange;
    XRange.iMin = 0;
    XRange.iMax = g_iNuiRefinementKernelSize80x60;
    YRange.iMin = 0;
    YRange.iMax = g_iNuiRefinementKernelSize80x60;
    const INT iNumSearchPixels = g_iNuiRefinementKernelCenter80x60;

    if ( iRefinedPosition80x60.iX < iNumSearchPixels )
    {
        XRange.iMin = iNumSearchPixels - iRefinedPosition80x60.iX;
    }
    if ( iRefinedPosition80x60.iX > ( 80 + iNumSearchPixels - XRange.iMax ) )
    {
        XRange.iMax = 80 + iNumSearchPixels - iRefinedPosition80x60.iX;
    }
    if ( iRefinedPosition80x60.iY < iNumSearchPixels )
    {
        YRange.iMin = iNumSearchPixels - iRefinedPosition80x60.iY;
    }
    if ( iRefinedPosition80x60.iY > ( 60 + iNumSearchPixels - YRange.iMax ) )
    {
        YRange.iMax = 60 + iNumSearchPixels - iRefinedPosition80x60.iY;
    }

    // Build a 3 level histrogram of the 12 x 12  grid in the 320x240 around the hand
    // This will help position the ellipsoid
    INT2Range iCenterIn320X ( iSearchLocation320x240.iX + iBeginOffsetfor12x12ThresholdSearch,
        iSearchLocation320x240.iX + iEbdOffsetfor12x12ThresholdSearch );
    INT2Range iCenterIn320Y ( iSearchLocation320x240.iY + iBeginOffsetfor12x12ThresholdSearch, 
        iSearchLocation320x240.iY + iEbdOffsetfor12x12ThresholdSearch );

    Clamp320x240( &iCenterIn320X.iMin, &iCenterIn320Y.iMin );
    Clamp320x240( &iCenterIn320X.iMax, &iCenterIn320Y.iMax );

    INT3Vector iCloseThresholdPosition( 0,0,0 );
    INT3Vector iFarThresholdPosition( 0,0,0 );

    INT iLessThanCloseThreshold = 0;
    INT iLessThanFarThreshold = 0;

    PIXBeginNamedEvent( 0, "Find Pivot" );

    for ( INT iY320x240 = iCenterIn320Y.iMin; iY320x240 < iCenterIn320Y.iMax; ++iY320x240 )
    {
        for ( INT iX320x240 = iCenterIn320X.iMin; iX320x240 < iCenterIn320X.iMax; ++iX320x240 )
        {
            USHORT uValue = pDepth320x240[iY320x240 * iShortPitch320x240 + iX320x240];
            USHORT uDepth = uValue >> NUI_IMAGE_PLAYER_INDEX_SHIFT;
            INT iDiff = INTABSFAST ((INT)uDepth - iSearchLocation320x240.iZ );
            if ( iDiff < g_iCenterFor320x240CloseThreshold )
            {
                ++ iLessThanCloseThreshold;
                iCloseThresholdPosition.iX += iX320x240;
                iCloseThresholdPosition.iY += iY320x240;
                iCloseThresholdPosition.iZ += (INT)uDepth;
            }
            if ( iDiff < g_iCenterFor320x240FarThreshold )
            {
                ++ iLessThanFarThreshold;
                iFarThresholdPosition.iX += iX320x240;
                iFarThresholdPosition.iY += iY320x240;
                iFarThresholdPosition.iZ += (INT)uDepth;
            }
        }
    }

    // Determine which of hte thresholds use of the first two segments in our 3 segment histogram.
    if ( iLessThanCloseThreshold != 0 && iLessThanCloseThreshold > g_iNuiRefinementHalfKernelSize320x240 )
    {
        iCloseThresholdPosition.iX /= iLessThanCloseThreshold;
        iCloseThresholdPosition.iY /= iLessThanCloseThreshold;
        iCloseThresholdPosition.iZ /= iLessThanCloseThreshold;
        iSearchLocation320x240 = iCloseThresholdPosition;
        pEHSP->m_SearchSphereCenter320x240 = iSearchLocation320x240;
    }
    else if ( iLessThanFarThreshold != 0 )
    {
        iFarThresholdPosition.iX /= iLessThanFarThreshold;
        iFarThresholdPosition.iY /= iLessThanFarThreshold;
        iFarThresholdPosition.iZ /= iLessThanFarThreshold;
        iSearchLocation320x240 = iFarThresholdPosition;
        pEHSP->m_SearchSphereCenter320x240 = iSearchLocation320x240;
    }
    PIXEndNamedEvent();

// It is important to maintain the slow unoptimized version because it is much easier to understand
#define USE_FAST_HARD_TO_READ_VMX_CODE_TO_COMPUTE_AVERAGE 1
#ifdef USE_FAST_HARD_TO_READ_VMX_CODE_TO_COMPUTE_AVERAGE
    INT iBytePitch320x240 = iShortPitch320x240 * 2;

    SHORT iOffsetCloseToBody = pHandSpecificData->m_iOffsetForHandCloseToBody;

    __declspec(align(16)) SHORT OffsetCloseToBody[] = 
    { 
        iOffsetCloseToBody, iOffsetCloseToBody, iOffsetCloseToBody, iOffsetCloseToBody,
        iOffsetCloseToBody, iOffsetCloseToBody, iOffsetCloseToBody, iOffsetCloseToBody
    };

    __vector4 vmxOffsetCloseToBody = __lvlx( OffsetCloseToBody, 0 );

    static __vector4 vSingleBitPerHalf = __vspltish( 1 );
    static __vector4 v8ChannelShiftRight3 = __vspltish( 3 );
    static __vector4 v8ChannelShiftRight4 = __vspltish( 4 );

    __declspec(align(16)) SHORT v8WayDepth[8];
    v8WayDepth[0] = (SHORT)iSearchLocation320x240.iZ;
    v8WayDepth[1] = v8WayDepth[0];
    v8WayDepth[2] = v8WayDepth[0];
    v8WayDepth[3] = v8WayDepth[0];
    v8WayDepth[4] = v8WayDepth[0];
    v8WayDepth[5] = v8WayDepth[0];
    v8WayDepth[6] = v8WayDepth[0];
    v8WayDepth[7] = v8WayDepth[0];
    __vector4 vmxDepth8 = __lvx( v8WayDepth, 0 );

    __declspec(align(16)) static const BYTE Merge2Rows[] = 
    { 
        0, 1, 2, 3,
        4, 5, 6, 7,
        16, 17, 18, 19,
        20, 21, 22, 23 
    };
    static const __vector4 vmxMergeTwoRows = __lvlx( Merge2Rows, 0 );

    __declspec(align(16)) static const SHORT Sub80x60Offsets[] = 
    { 
        0, 1, 2, 3,
        0, 1, 2, 3
    };
    static const __vector4 vmxSub80x60Offsets = __lvlx( Sub80x60Offsets, 0 );

    __declspec(align(16)) static const BYTE PermuteForIndividualXLocations[] = 
    { 
        0, 1, 2, 3,
        4, 5, 6, 7,
        0, 1, 2, 3,
        4, 5, 6, 7
    };
    static const __vector4 vmxPermuteForIndividualXLocations = __lvlx( PermuteForIndividualXLocations, 0 );

    __declspec(align(16)) static const BYTE PermuteForIndividualYLocationsFirst8[] = 
    { 
        8, 9, 8, 9,
        8, 9, 8, 9,
        10, 11, 10, 11,
        10, 11, 10, 11
    };
    static const __vector4 vmxPermuteForIndividualYLocationsFirst8 = __lvlx( PermuteForIndividualYLocationsFirst8, 0 );

    __declspec(align(16)) static const BYTE PermuteForIndividualYLocationsSecond8[] = 
    { 
        12, 13, 12, 13,
        12, 13, 12, 13,
        14, 15, 14, 15,
        14, 15, 14, 15
    };
    static const __vector4 vmxPermuteForIndividualYLocationsSecond8 = __lvlx( PermuteForIndividualYLocationsSecond8, 0 );

    __declspec(align(16)) CONST SHORT CopiesOfSearchLocationXANDY[] = 
    { 
        -(CONST SHORT)iSearchLocation320x240.iX, -(CONST SHORT)iSearchLocation320x240.iX, 
        -(CONST SHORT)iSearchLocation320x240.iX, -(CONST SHORT)iSearchLocation320x240.iX,
        -(CONST SHORT)iSearchLocation320x240.iY, -(CONST SHORT)iSearchLocation320x240.iY,
        -(CONST SHORT)iSearchLocation320x240.iY, -(CONST SHORT)iSearchLocation320x240.iY
    };
    const __vector4 vmxCopiesOfSearchLocationXANDY = __lvlx( CopiesOfSearchLocationXANDY, 0 );
    
    __declspec(align(16)) CONST SHORT MaxSquaredRadius[] = 
    { 
        (CONST SHORT)pEHSP->m_iSquaredSizeOfHandTheshold, (CONST SHORT)pEHSP->m_iSquaredSizeOfHandTheshold, 
        (CONST SHORT)pEHSP->m_iSquaredSizeOfHandTheshold, (CONST SHORT)pEHSP->m_iSquaredSizeOfHandTheshold,
        (CONST SHORT)pEHSP->m_iSquaredSizeOfHandTheshold, (CONST SHORT)pEHSP->m_iSquaredSizeOfHandTheshold,
        (CONST SHORT)pEHSP->m_iSquaredSizeOfHandTheshold, (CONST SHORT)pEHSP->m_iSquaredSizeOfHandTheshold
    };
    CONST __vector4 vmxMaxSquaredRadius = __lvlx( MaxSquaredRadius, 0 );

    __declspec(align(16)) static CONST BYTE CreateXSquaredPerm[] = 
    { 
        0, 1, 2, 3,
        4, 5, 6, 7,
        0, 1, 2, 3,
        4, 5, 6, 7
    };
    static const __vector4 vmxCreateXSquaredPerm = __lvlx( CreateXSquaredPerm, 0 );

    __declspec(align(16)) static const BYTE CreateYSquaredPermFirst8[] = 
    { 
        8, 9, 8, 9,
        8, 9, 8, 9,
        10, 11, 10, 11,
        10, 11, 10, 11
    };
    static const __vector4 vmxCreateYSquaredPermFirst8 = __lvlx( CreateYSquaredPermFirst8, 0 );

    __declspec(align(16)) static const BYTE ReplicateIteratorFor4x4Population[] = 
    { 
        0, 1, 0, 1,
        0, 1, 0, 1,
        2, 3, 2, 3,
        2, 3, 2, 3
    };
    static const __vector4 vmxReplicateIteratorFor4x4Population = __lvlx( ReplicateIteratorFor4x4Population, 0 );
    
    __declspec(align(16)) static const BYTE CreateYSquaredPermSecond8[] = 
    { 
        12, 13, 12, 13,
        12, 13, 12, 13,
        14, 15, 14, 15,
        14, 15, 14, 15
    };
    static const __vector4 vmxCreateYSquaredPermSecond8 = __lvlx( CreateYSquaredPermSecond8, 0 );

    PIXBeginNamedEvent( 0xffffffff, "Expensive Average" );
        
    __vector4 vmxFinal4WayDepth = __vzero();
    __vector4 vmxFinal4WayX = __vzero();
    __vector4 vmxFinal4WayY = __vzero();
    __vector4 vmxFinalConnt = __vzero();

    static CONST __declspec(align(16)) SHORT IncrementXOuterLoop[] = 
    {
       4,0,0,0,0,0,0,0
    };
    static CONST __vector4 vmxIncrementXOuterLoop = __lvlx( IncrementXOuterLoop, 0 );

    __declspec(align(16))SHORT IncrementYOuterLoop[] = 
    {
       (SHORT)(-4*(XRange.iMax - XRange.iMin )),4,0,0,0,0,0,0
    };
    __vector4 vmxIncrementYOuterLoop = __lvlx( IncrementYOuterLoop, 0 );

    __declspec(align(16)) SHORT InitialLoopValues[] = 
    {
       (SHORT)((XRange.iMin - iNumSearchPixels + iRefinedPosition80x60.iX) * 4),
       (SHORT)((YRange.iMin - iNumSearchPixels + iRefinedPosition80x60.iY) * 4),
       0,0,0,0,0,0
    };
    __vector4 vmxInitialLoopValues = __lvlx( InitialLoopValues, 0 );

    __vector4 vmxXYIterator = vmxInitialLoopValues;
    
    INT iOffset = ((YRange.iMin - iNumSearchPixels + iRefinedPosition80x60.iY) * 4) * iBytePitch320x240 
        + ((XRange.iMin - iNumSearchPixels + iRefinedPosition80x60.iX) * 4) * 2;

    // 8 shorts per row
    // 2 rows per voxel
    __declspec(align(16)) USHORT TemporaryMemoryFor320x240Copy[ 8 * 2 * g_iNuiRefinementKernelSize80x60 * g_iNuiRefinementKernelSize80x60 ];
    XMemSet( TemporaryMemoryFor320x240Copy, 0, sizeof(TemporaryMemoryFor320x240Copy) );
    INT iCurrentCopyLocationByte = 0;
    iCurrentCopyLocationByte = ( 32 * g_iNuiRefinementKernelSize80x60);   
    INT iBeginXOffset = XRange.iMin * 32;
    INT iEndXOffset = (g_iNuiRefinementKernelSize80x60 - XRange.iMax) * 32;

    for ( INT iY12x12 = YRange.iMin; iY12x12 < YRange.iMax; ++iY12x12 )
    {
        iCurrentCopyLocationByte += iBeginXOffset;
        for ( INT iX12x12 = XRange.iMin; iX12x12 < XRange.iMax; ++iX12x12 )
        {       
            if ( pEHSP->m_bValid80x60Voxels[iY12x12][iX12x12] )
            {
                __vector4 vmxRow1;
                __vector4 vmxRow2;
                __vector4 vmxRow3;
                __vector4 vmxRow4;
                INT iTouchOffset = iOffset;
                __dcbt( iTouchOffset, pDepth320x240 );
                iTouchOffset += iBytePitch320x240;
                __dcbt( iTouchOffset, pDepth320x240 );
                iTouchOffset += iBytePitch320x240;
                __dcbt( iTouchOffset, pDepth320x240 );
                iTouchOffset += iBytePitch320x240;
                __dcbt( iTouchOffset, pDepth320x240 );

                INT iLoadOffset = iOffset;
                vmxRow1 = __vor (__lvlx( pDepth320x240, iLoadOffset ),
                    __lvrx( pDepth320x240,  iLoadOffset + 16 ) );
                iLoadOffset+=iBytePitch320x240;
                vmxRow2 = __vor (__lvlx( pDepth320x240,  iLoadOffset ),
                    __lvrx( pDepth320x240, iLoadOffset + 16 ) );
                iLoadOffset+=iBytePitch320x240;
                vmxRow3 = __vor (__lvlx( pDepth320x240, iLoadOffset ),
                    __lvrx( pDepth320x240,  iLoadOffset + 16 ) );
                iLoadOffset+=iBytePitch320x240;
                vmxRow4 = __vor (__lvlx( pDepth320x240,  iLoadOffset ),
                    __lvrx( pDepth320x240, iLoadOffset + 16 ) );

////////////////////////////////////////////////////////////////////////////////////////////////////
                // Compute squared distance for first 8 depth values.
                __vector4 vmxFinalRow = __vperm( vmxRow1, vmxRow2, vmxMergeTwoRows );
                
                __vector4 vmxFirst8ShiftedDepths = __vsrh( vmxFinalRow, v8ChannelShiftRight3 );
                vmxFirst8ShiftedDepths = __vaddshs(vmxFirst8ShiftedDepths, vmxOffsetCloseToBody );
                __vector4 vmxDepthDiff = __vsubuhs( __vmaxuh( vmxFirst8ShiftedDepths, vmxDepth8 ), __vminuh( vmxFirst8ShiftedDepths, vmxDepth8 ) );
                __vector4 vmxDepthDiffNormalized = __vaddshs( __vsrh( vmxDepthDiff, v8ChannelShiftRight3 ),
                                                   __vsrh( vmxDepthDiff, v8ChannelShiftRight4 ) );

                __vector4 vmxFirst4Shorts2Floats = __vupkhsh( vmxDepthDiffNormalized );
                __vector4 vmxFloatCompareDepths = __vcfsx( vmxFirst4Shorts2Floats, 0 );
                __vector4 vmxFirst4Squared = __vmulfp( vmxFloatCompareDepths, vmxFloatCompareDepths );
                __vector4 vmxFirst4SquaredShorts =  __vctsxs( vmxFirst4Squared, 0 );

                __vector4 vmxSecond4Shorts2Floats = __vupklsh( vmxDepthDiffNormalized );
                vmxFloatCompareDepths = __vcfsx( vmxSecond4Shorts2Floats, 0 );
                __vector4 vmxSecond4Squared = __vmulfp( vmxFloatCompareDepths, vmxFloatCompareDepths );
                __vector4 vmxSecond4SquaredShorts =  __vctsxs( vmxSecond4Squared, 0 );
            
                __vector4 vmxFirst8SquaredDepths;
                vmxFirst8SquaredDepths = __vpkuwus(vmxFirst4SquaredShorts, vmxSecond4SquaredShorts );
////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////
                // Compute distance squared for second 8 depth values.
                vmxFinalRow = __vperm( vmxRow3, vmxRow4, vmxMergeTwoRows );
                
                __vector4 vmxSecond8ShiftedDepths = __vsrh( vmxFinalRow, v8ChannelShiftRight3 );
                vmxSecond8ShiftedDepths = __vaddshs(vmxSecond8ShiftedDepths, vmxOffsetCloseToBody );
                vmxDepthDiff = __vsubuhs( __vmaxuh( vmxSecond8ShiftedDepths, vmxDepth8 ), __vminuh( vmxSecond8ShiftedDepths, vmxDepth8 ) );
                vmxDepthDiffNormalized = __vaddshs( __vsrh( vmxDepthDiff, v8ChannelShiftRight3 ),
                                                   __vsrh( vmxDepthDiff, v8ChannelShiftRight4 ) );

                vmxFirst4Shorts2Floats = __vupkhsh( vmxDepthDiffNormalized );
                vmxFloatCompareDepths = __vcfsx( vmxFirst4Shorts2Floats, 0 );
                vmxFirst4Squared = __vmulfp( vmxFloatCompareDepths, vmxFloatCompareDepths );
                vmxFirst4SquaredShorts =  __vctsxs( vmxFirst4Squared, 0 );

                vmxSecond4Shorts2Floats = __vupklsh( vmxDepthDiffNormalized );
                vmxFloatCompareDepths = __vcfsx( vmxSecond4Shorts2Floats, 0 );
                vmxSecond4Squared = __vmulfp( vmxFloatCompareDepths, vmxFloatCompareDepths );
                vmxSecond4SquaredShorts =  __vctsxs( vmxSecond4Squared, 0 );
            
                __vector4 vmxSecond8SquaredDepths;
                vmxSecond8SquaredDepths = __vpkuwus(vmxFirst4SquaredShorts, vmxSecond4SquaredShorts );
////////////////////////////////////////////////////////////////////////////////////////////////////

                // Compute the difference for X, Y Values
////////////////////////////////////////////////////////////////////////////////////////////////////
                __vector4 vmxOffsetsIn320x240XY;
                vmxOffsetsIn320x240XY = __vperm( vmxXYIterator, __vzero(), vmxReplicateIteratorFor4x4Population );

                __vector4 vmxXYDifferences;
                __vector4 vmxIndividualXYOffsets;
                vmxIndividualXYOffsets =  __vaddshs ( vmxOffsetsIn320x240XY, vmxSub80x60Offsets );
                vmxXYDifferences = __vaddshs( vmxIndividualXYOffsets, vmxCopiesOfSearchLocationXANDY  );


                __vector4 vmxSignedUnpackHigh = __vupkhsh( vmxXYDifferences );
                vmxFloatCompareDepths = __vcfsx( vmxSignedUnpackHigh, 0 );
                vmxFirst4Squared = __vmulfp( vmxFloatCompareDepths, vmxFloatCompareDepths );
                vmxFirst4SquaredShorts =  __vctsxs( vmxFirst4Squared, 0 );

                __vector4 vmxSignedUnpackLow =  __vupklsh( vmxXYDifferences );
                vmxFloatCompareDepths = __vcfsx( vmxSignedUnpackLow, 0 );
                vmxSecond4Squared = __vmulfp( vmxFloatCompareDepths, vmxFloatCompareDepths );
                vmxSecond4SquaredShorts =  __vctsxs( vmxSecond4Squared, 0 ); 
            
                __vector4 vmxSquaredXYDepths;
                vmxSquaredXYDepths = __vpkuwus(vmxFirst4SquaredShorts, vmxSecond4SquaredShorts );
////////////////////////////////////////////////////////////////////////////////////////////////////

                // Compute the X diffRows
////////////////////////////////////////////////////////////////////////////////////////////////////
                __vector4 vmxFirst8SquaredXValues;
                vmxFirst8SquaredXValues = __vperm( vmxSquaredXYDepths, __vzero(), vmxCreateXSquaredPerm );
                __vector4 vmxSecond8SquaredXValues;
                vmxSecond8SquaredXValues = __vperm( vmxSquaredXYDepths, __vzero(), vmxCreateXSquaredPerm );
////////////////////////////////////////////////////////////////////////////////////////////////////

                // Compute the X diffRows
////////////////////////////////////////////////////////////////////////////////////////////////////
                __vector4 vmxFirst8SquaredYValues;
                vmxFirst8SquaredYValues = __vperm( vmxSquaredXYDepths, __vzero(), vmxCreateYSquaredPermFirst8  );
                __vector4 vmxSecond8SquaredYValues;
                vmxSecond8SquaredYValues = __vperm( vmxSquaredXYDepths, __vzero(), vmxCreateYSquaredPermSecond8  );
////////////////////////////////////////////////////////////////////////////////////////////////////
                
                // Compute TotalDifference Per Depth
///////////////////////////////////////////////////////////////////////////////////////////////////////
                __vector4 vmxDifferenceForFirst8;
                vmxDifferenceForFirst8 = __vadduhs( __vadduhs( vmxFirst8SquaredDepths, vmxFirst8SquaredXValues ) ,
                    vmxFirst8SquaredYValues );
                __vector4 vmxDifferenceForSecond8;
                vmxDifferenceForSecond8 = __vadduhs( __vadduhs( vmxSecond8SquaredDepths, vmxSecond8SquaredXValues ) ,
                    vmxSecond8SquaredYValues );
///////////////////////////////////////////////////////////////////////////////////////////////////////

                // Calculate the sub pixels that pass the threshold
///////////////////////////////////////////////////////////////////////////////////////////////////////
                __vector4 vmxValidFirst8;
                vmxValidFirst8 = __vcmpgtuh( vmxMaxSquaredRadius, vmxDifferenceForFirst8 );
                __vector4 vmxValidSecond8;
                vmxValidSecond8 = __vcmpgtuh( vmxMaxSquaredRadius, vmxDifferenceForSecond8 );
///////////////////////////////////////////////////////////////////////////////////////////////////////
                

                // Calculate the actual X, Y values of the sub 80x60 blocks that will be averaged should 
                //they pass the test
///////////////////////////////////////////////////////////////////////////////////////////////////////
                __vector4 vmxXLocationsFirst8;
                __vector4 vmxXLocationsSecond8;
                __vector4 vmxYLocationsFirst8;
                __vector4 vmxYLocationsSecond8;
                vmxXLocationsFirst8 = __vperm( vmxIndividualXYOffsets, __vzero(), vmxPermuteForIndividualXLocations );
                vmxXLocationsSecond8 = __vperm( vmxIndividualXYOffsets, __vzero(), vmxPermuteForIndividualXLocations );
                vmxYLocationsFirst8 = __vperm( vmxIndividualXYOffsets, __vzero(), vmxPermuteForIndividualYLocationsFirst8 );
                vmxYLocationsSecond8 = __vperm( vmxIndividualXYOffsets, __vzero(), vmxPermuteForIndividualYLocationsSecond8 );

                vmxFirst8ShiftedDepths = __vand( vmxValidFirst8, vmxFirst8ShiftedDepths );
                vmxSecond8ShiftedDepths = __vand( vmxValidSecond8, vmxSecond8ShiftedDepths );
                __stvx( vmxFirst8ShiftedDepths, TemporaryMemoryFor320x240Copy, iCurrentCopyLocationByte );
                __stvx( vmxSecond8ShiftedDepths, TemporaryMemoryFor320x240Copy, iCurrentCopyLocationByte + 16 );

                vmxXLocationsFirst8 = __vand( vmxValidFirst8, vmxXLocationsFirst8 );
                vmxXLocationsSecond8 = __vand( vmxValidSecond8, vmxXLocationsSecond8 );
                vmxYLocationsFirst8 = __vand( vmxValidFirst8, vmxYLocationsFirst8 );
                vmxYLocationsSecond8 = __vand( vmxValidSecond8, vmxYLocationsSecond8 );
                __vector4 vmxCountFirst8 = __vand( vmxValidFirst8, vSingleBitPerHalf );
                __vector4 vmxCountSecond8 = __vand( vmxValidSecond8, vSingleBitPerHalf );

                __vector4 vmxAddin;
                vmxAddin= __vupkhsh( vmxFirst8ShiftedDepths );
                vmxFinal4WayDepth = __vadduws( vmxAddin, vmxFinal4WayDepth );
                vmxAddin= __vupklsh( vmxFirst8ShiftedDepths );
                vmxFinal4WayDepth = __vadduws( vmxAddin, vmxFinal4WayDepth );
                vmxAddin= __vupkhsh( vmxSecond8ShiftedDepths );
                vmxFinal4WayDepth = __vadduws( vmxAddin, vmxFinal4WayDepth );
                vmxAddin= __vupklsh( vmxSecond8ShiftedDepths );
                vmxFinal4WayDepth = __vadduws( vmxAddin, vmxFinal4WayDepth );
                
                vmxAddin= __vupkhsh( vmxXLocationsFirst8 );
                vmxFinal4WayX = __vadduws( vmxAddin, vmxFinal4WayX );
                vmxAddin= __vupklsh( vmxXLocationsFirst8 );
                vmxFinal4WayX = __vadduws( vmxAddin, vmxFinal4WayX );
                vmxAddin= __vupkhsh( vmxXLocationsSecond8 );
                vmxFinal4WayX = __vadduws( vmxAddin, vmxFinal4WayX );
                vmxAddin= __vupklsh( vmxXLocationsSecond8 );
                vmxFinal4WayX = __vadduws( vmxAddin, vmxFinal4WayX );

                vmxAddin= __vupkhsh( vmxYLocationsFirst8 );
                vmxFinal4WayY = __vadduws( vmxAddin, vmxFinal4WayY );
                vmxAddin= __vupklsh( vmxYLocationsFirst8 );
                vmxFinal4WayY = __vadduws( vmxAddin, vmxFinal4WayY );
                vmxAddin= __vupkhsh( vmxYLocationsSecond8 );
                vmxFinal4WayY = __vadduws( vmxAddin, vmxFinal4WayY );
                vmxAddin= __vupklsh( vmxYLocationsSecond8 );
                vmxFinal4WayY = __vadduws( vmxAddin, vmxFinal4WayY );

                vmxAddin= __vupkhsh( vmxCountFirst8 );
                vmxFinalConnt = __vadduws( vmxAddin, vmxFinalConnt );
                vmxAddin= __vupklsh( vmxCountFirst8 );
                vmxFinalConnt = __vadduws( vmxAddin, vmxFinalConnt );
                vmxAddin= __vupkhsh( vmxCountSecond8 );
                vmxFinalConnt = __vadduws( vmxAddin, vmxFinalConnt );
                vmxAddin= __vupklsh( vmxCountSecond8 );
                vmxFinalConnt = __vadduws( vmxAddin, vmxFinalConnt );
#ifdef DEBUG_COMPUTE_AND_SHOW_VISUALIZATION
                
                __declspec(align(16)) SHORT Depths[16];
                __stvx( vmxValidFirst8, Depths, 0 );
                __stvx( vmxValidSecond8, Depths, 16 );
                for ( INT iY4x4 = 0; iY4x4 < 4; ++iY4x4 )   
                {
                    for ( INT iX4x4 = 0; iX4x4 < 4; ++iX4x4 )
                    {
                        if ( Depths[iY4x4*4+iX4x4] != 0 )
                        {
                            pHandSpecificData->m_VisualizeHandFramesData.m_FrameData[iY12x12*4+iY4x4][iX12x12*4+iX4x4] = 1;    
                        }
                        else 
                        {
                            pHandSpecificData->m_VisualizeHandFramesData.m_FrameData[iY12x12*4+iY4x4][iX12x12*4+iX4x4] = 0;    
                        }
                    }                
                }
#endif
            }
            iCurrentCopyLocationByte += 32;
            vmxXYIterator = __vaddshs( vmxIncrementXOuterLoop, vmxXYIterator );
            iOffset += 8;
        }
        iCurrentCopyLocationByte += iEndXOffset;
        vmxXYIterator = __vaddshs( vmxIncrementYOuterLoop, vmxXYIterator );
        
        iOffset -= (8*(XRange.iMax - XRange.iMin ));
        iOffset += iBytePitch320x240 * 4; // we're doing 4 rows at a tim
    }


    if ( pOptionalRefinementData->m_dwFlags & ATG_REFINE_HANDS_FLAG_CALCULATE320x240MASK )
    {
        memset( pEHSP->m_uHandDepthValues320x240, 0, sizeof(pEHSP->m_uHandDepthValues320x240) );

        INT iIndexIntoDepthValues = YRange.iMin * 4 * g_iNuiRefinementKernelSize320x240;
        INT iCurrentCopyLocation = 0;
        for ( INT iY12x12 = YRange.iMin; iY12x12 < YRange.iMax; ++iY12x12 )
        {
            for ( INT iX12x12 = 0; iX12x12 < g_iNuiRefinementKernelSize80x60; ++iX12x12 )
            {
                
                for ( INT iCopy4x4TileIndex=0; iCopy4x4TileIndex < 4; ++iCopy4x4TileIndex )
                {
                   pEHSP->m_uHandDepthValues320x240[iIndexIntoDepthValues++] = 
                      TemporaryMemoryFor320x240Copy[iCurrentCopyLocation++]; 
                }
                iIndexIntoDepthValues -=4;
                iIndexIntoDepthValues +=g_iNuiRefinementKernelSize320x240;

                for ( INT iCopy4x4TileIndex=0; iCopy4x4TileIndex < 4; ++iCopy4x4TileIndex )
                {
                   pEHSP->m_uHandDepthValues320x240[iIndexIntoDepthValues++] = 
                      TemporaryMemoryFor320x240Copy[iCurrentCopyLocation++]; 
                }
                iIndexIntoDepthValues -=4;
                iIndexIntoDepthValues +=g_iNuiRefinementKernelSize320x240;

                for ( INT iCopy4x4TileIndex=0; iCopy4x4TileIndex < 4; ++iCopy4x4TileIndex )
                {
                   pEHSP->m_uHandDepthValues320x240[iIndexIntoDepthValues++] = 
                      TemporaryMemoryFor320x240Copy[iCurrentCopyLocation++]; 
                }
                iIndexIntoDepthValues -=4;
                iIndexIntoDepthValues +=g_iNuiRefinementKernelSize320x240;

                for ( INT iCopy4x4TileIndex=0; iCopy4x4TileIndex < 4; ++iCopy4x4TileIndex )
                {
                   pEHSP->m_uHandDepthValues320x240[iIndexIntoDepthValues++] = 
                      TemporaryMemoryFor320x240Copy[iCurrentCopyLocation++]; 
                }
                iIndexIntoDepthValues -= g_iNuiRefinementKernelSize320x240;
                iIndexIntoDepthValues -= g_iNuiRefinementKernelSize320x240;
                iIndexIntoDepthValues -= g_iNuiRefinementKernelSize320x240;
                
            }
            iIndexIntoDepthValues +=g_iNuiRefinementKernelSize320x240;
            iIndexIntoDepthValues +=g_iNuiRefinementKernelSize320x240;
            iIndexIntoDepthValues +=g_iNuiRefinementKernelSize320x240;

        }
    }
    PIXEndNamedEvent();


    __declspec(align(16)) INT Counts[4];
    __stvx( vmxFinalConnt, Counts, 0 );
    INT iTotalCountVMX;
    iTotalCountVMX = Counts[0] + Counts[1] + Counts[2] + Counts[3];


    if ( iTotalCountVMX == 0 )
    {
        *pRefinedHand = pHandSpecificData->m_vRawHand;
    }
    else 
    {
        __declspec(align(16)) INT Depths[4];
        __stvx( vmxFinal4WayDepth, Depths, 0 );
        INT iDepth;
        iDepth = ( Depths[0] + Depths[1] + Depths[2] + Depths[3] );
        FLOAT fDepth;
        fDepth = (FLOAT) iDepth / (FLOAT) iTotalCountVMX;
        __declspec(align(16)) INT Xs[4];
        __stvx( vmxFinal4WayX, Xs, 0 );
        INT iXValue;
        iXValue = ( Xs[0] + Xs[1] + Xs[2] + Xs[3] );
        FLOAT fXValue;
        fXValue = (FLOAT)iXValue / (FLOAT)iTotalCountVMX;
        __declspec(align(16)) INT Ys[4];
        __stvx( vmxFinal4WayY, Ys, 0 );
        INT iYValue;
        iYValue = ( Ys[0] + Ys[1] + Ys[2] + Ys[3] );
        FLOAT fYValue;
        fYValue = (FLOAT)iYValue / (FLOAT)iTotalCountVMX;

        TransformScreenToWorld320x240( fXValue, 
                                       fYValue, 
                                       fDepth / 1000.0f,
                                       pRefinedHand
                                     );
    }
    return iTotalCountVMX;
#else
    PIXBeginNamedEvent( 0xffffffff, "Expensive Average" );
    
    // 8 shorts per row
    // 2 rows per voxel
    __declspec(align(128)) USHORT TemporaryMemoryFor320x240Copy[ 8 * 2 * g_iNuiRefinementKernelSize80x60 * g_iNuiRefinementKernelSize80x60 ];
    XMemSet( TemporaryMemoryFor320x240Copy, 0, sizeof(TemporaryMemoryFor320x240Copy) );
    INT iCurrentCopyLocationByte = 0;
    iCurrentCopyLocationByte = ( 32 * g_iNuiRefinementKernelSize80x60);   
    INT iBeginXOffset = XRange.iMin * 32;
    INT iAverageX = 0;
    INT iAverageY = 0;
    INT iAverageZ = 0;
    INT iTotalCount = 0;
    if ( pOptionalRefinementData->m_dwFlags & ATG_REFINE_HANDS_FLAG_CALCULATE320x240MASK )
    {
        memset( pEHSP->m_uHandDepthValues320x240, 0, sizeof(pEHSP->m_uHandDepthValues320x240) );
    }

    for ( INT iY12x12 = YRange.iMin; iY12x12 < YRange.iMax; ++iY12x12 )
    {
        iCurrentCopyLocationByte += iBeginXOffset;
        for ( INT iX12x12 = XRange.iMin; iX12x12 < XRange.iMax; ++iX12x12 )
        {       
            if ( pEHSP->m_bValid80x60Voxels[iY12x12][iX12x12] )
            {

                INT iX80x60 = iX12x12 - iNumSearchPixels + iRefinedPosition80x60.iX;
                INT iY80x60 = iY12x12 - iNumSearchPixels + iRefinedPosition80x60.iY;

                INT iX320x240 = iX80x60 * 4;
                INT iY320x240 = iY80x60 * 4;
                
                //char temp[255];
                for ( INT iY4x4 = 0; iY4x4 < 4; ++iY4x4 )   
                {
                    INT iFinalY = iY320x240 + iY4x4;
                    for ( INT iX4x4 = 0; iX4x4 < 4; ++iX4x4 )
                    {
                        INT iFinalX = iX320x240 + iX4x4;  

                        assert( iFinalX < 320 );
                        assert( iFinalY < 240 );
                        USHORT uValue = pDepth320x240[ iFinalY * iShortPitch320x240 + iFinalX ];
                        {
                            USHORT uDepth = uValue >> 3;
                            INT iDepthDiff = ( (INT)uDepth - iSearchLocation320x240.iZ );
                            // Body pixels are sometimes acccidentally averaged in the hands 
                            // bias slight towars pixels in front of the hand.
                            
                            iDepthDiff = (iDepthDiff / 16) + (iDepthDiff / 8);
                            INT iDepthDiffSquared = iDepthDiff * iDepthDiff;

                            INT iDist = ( iFinalX - iSearchLocation320x240.iX ) * ( iFinalX - iSearchLocation320x240.iX ) + 
                                ( iFinalY - iSearchLocation320x240.iY ) * ( iFinalY - iSearchLocation320x240.iY ) +
                                iDepthDiffSquared ;
                            if ( iDist < pEHSP->m_iSquaredSizeOfHandTheshold )
                            {
                                iAverageX += iFinalX;
                                iAverageY += iFinalY;
                                ++iTotalCount;
                                iAverageZ += (INT)uDepth;
#ifdef DEBUG_COMPUTE_AND_SHOW_VISUALIZATION
                                pHandSpecificData->m_VisualizeHandFramesData.m_FrameData[iY12x12*4+iY4x4][iX12x12*4+iX4x4] = 1;    
#endif
                                if ( pOptionalRefinementData->m_dwFlags & ATG_REFINE_HANDS_FLAG_CALCULATE320x240MASK )
                                {
                                    pEHSP->m_uHandDepthValues320x240[
                                        (iY12x12 * 4 + iY4x4) * g_iNuiRefinementKernelSize320x240
                                        + (iX12x12 * 4 + iX4x4) 
                                    ] = uDepth;
                                }

                            }
#ifdef DEBUG_COMPUTE_AND_SHOW_VISUALIZATION
                            else 
                            {
                                pHandSpecificData->m_VisualizeHandFramesData.m_FrameData[iY12x12*4+iY4x4][iX12x12*4+iX4x4] = 0;    
                            }
#endif
                        }
                    }
                }
            }
        }
    }
    PIXEndNamedEvent();

    if ( iTotalCount == 0 )
    {
        *pRefinedHand = pHandSpecificData->m_vRawHand;
    }
    else 
    {        
        TransformScreenToWorld320x240( (FLOAT)iAverageX / (FLOAT)iTotalCount, 
                            (FLOAT)iAverageY / (FLOAT)iTotalCount, 
                           (FLOAT)iAverageZ / (FLOAT)(1000.0f*(FLOAT)iTotalCount ),
                            pRefinedHand
                            );
    }
    return iTotalCount;

#endif
}


//--------------------------------------------------------------------------------------
// Name: CalculateSearchDirections
// Desc: This function calculates the closest search direction to the hand elbow vector.
//--------------------------------------------------------------------------------------
__forceinline VOID CalculateSearchDirection( INT iHandX, INT iHandY, INT iElbowX, INT iElbowY, INT* pSearch )
{
    static CONST FLOAT fPIDIV8 =  XM_PI / 8.0f;

    FLOAT fAngle = 0.0f;
    FLOAT fDirection[] = { (FLOAT)( iHandX - iElbowX  ), 
        (FLOAT)( iHandY - iElbowY ) };

    fAngle = atan2f( fDirection[1], fDirection[0] );
    fAngle += XM_PI + fPIDIV8;
    fAngle /= XM_PI;
    fAngle *= 4.0f;
    fAngle = fAngle;
    INT iAngle = (INT)fAngle;
    iAngle %= 8;
    iAngle = iAngle;
    *pSearch = iAngle;

}

//--------------------------------------------------------------------------------------
// Name: RefineWith320x240
// Desc: Take the 80x60 coordinate to the 320x240 map for refinement
// It also takes care of interpolating betwee raw and refined data when necessary.
//--------------------------------------------------------------------------------------
BOOL RefineWith320x240( DepthMaps* __restrict pDMS,
                        RefinementData* __restrict pRefinementData,
                        HandSpecificData* __restrict pHandSpecificData,
                        OptionalRefinementData* __restrict pOptionalRefinementData,
                        OptionalHandSpecificData* __restrict pOHSP
                      )
{
    static CONST FLOAT fTetheringDistanceLimit = 0.1f;
    static CONST FLOAT fInterpolateBetweenRawAndRefinedDecayRate = 0.8f;
    XMVECTOR vRefinedHand;
    INT iPixelsReturned = 0;

    if ( !pHandSpecificData->m_bRevertedToRawData ) 
    {       
        PIXBeginNamedEvent( 0xffffffff, "FindAverageForHand320x240" );
        iPixelsReturned = FindAverageForHand320x240( pDMS,
            pRefinementData,
            pHandSpecificData,
            &vRefinedHand,
            pOptionalRefinementData,
            pOHSP
        );
        PIXEndNamedEvent();
    }
    else 
    {
        #ifdef DEBUG_COMPUTE_AND_SHOW_VISUALIZATION
            iPixelsReturned = FindAverageForHand320x240( pDMS,
                pRefinementData,
                pHandSpecificData,
                &vRefinedHand,
                pOptionalRefinementData,
                pOHSP
            );
        #endif
        vRefinedHand = pHandSpecificData->m_vRawHand;
    }

    assert( pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iX < 80 );
    assert( pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iY < 60 );

    pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iZ = 
        pDMS->m_pData80x60Min[pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iX + 
                            pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iY * 
                            pDMS->m_iShortPitch80x60Min] >> NUI_IMAGE_PLAYER_INDEX_SHIFT;

    XMVECTOR vPreviousRefinedHand;
    if ( pRefinementData->m_bFirstTimeThrough )
    {
        vPreviousRefinedHand = vRefinedHand;
    }
    else
    {
        vPreviousRefinedHand = pHandSpecificData->m_vRefinedHand;
    }
    XMVECTOR tetherVector = vRefinedHand - vPreviousRefinedHand;
    FLOAT interpolationValue = min( 1.0f, XMVector3Length(tetherVector).x / fTetheringDistanceLimit );
    vRefinedHand = vPreviousRefinedHand + tetherVector * interpolationValue;
    
    if ( pHandSpecificData->m_bRevertedToRawDataPreviousFrame != pHandSpecificData->m_bRevertedToRawData )
    {
        pHandSpecificData->m_vOffsetRawToRefined =  pHandSpecificData->m_vRefinedHand - vRefinedHand;
    }

    pHandSpecificData->m_vOffsetRawToRefined *= fInterpolateBetweenRawAndRefinedDecayRate;
    pHandSpecificData->m_vRefinedHand = vRefinedHand + pHandSpecificData->m_vOffsetRawToRefined;
    pHandSpecificData->m_bRevertedToRawDataPreviousFrame = pHandSpecificData->m_bRevertedToRawData;

    return TRUE;

}

//--------------------------------------------------------------------------------------
// Name: ClimbOntoHand80x60
// Desc: Climb onto the highest close point.  This will help climb onto the arm if the 
// skeleton is off the depth map.
//--------------------------------------------------------------------------------------
VOID ClimbOntoHand80x60 (   DepthMaps* __restrict pDMS, 
                            RefinementData* __restrict pRefinementData, 
                            HandSpecificData* __restrict pHandSpecificData )
{

    static CONST INT iBiggestPossibleDifferenceForJump = -150; 
    XMFLOAT4 fHandElbowDiff;
    USHORT* pDepth80x60Min = pDMS->m_pData80x60Min;
    INT iShortPitch80x60Min = pDMS->m_iShortPitch80x60Min;

    assert( pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iX < 80 );
    assert( pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iY < 60 );

    USHORT u80x60Raw = pDepth80x60Min[ pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iX + 
        pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iY * iShortPitch80x60Min ];
    INT i80x60RawDepth = (INT)(u80x60Raw >> NUI_IMAGE_PLAYER_INDEX_SHIFT);

    // when ST puts the arm out in space it's not on the depth map. so we're looking for the arm to be closer than the raw depth map position.
    INT iDiff = i80x60RawDepth - pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iZ;

    if ( iDiff > g_iDistanceOffDepthMaptoWarrantLargeSearch || i80x60RawDepth == 0 ) 
    {
        INT2Vector iHandJumpSeedLocation(pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iX, 
            pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iY);
        INT2Vector iHandToElbow( pHandSpecificData->m_INT3ScreenSpaceElbow80x60.iX - pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iX,
                                 pHandSpecificData->m_INT3ScreenSpaceElbow80x60.iY - pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iY );

        iHandToElbow.iX /=2;
        iHandToElbow.iY /=2;

        iHandJumpSeedLocation.iX += iHandToElbow.iX;
        iHandJumpSeedLocation.iY += iHandToElbow.iY;

        Clamp80x60( &iHandJumpSeedLocation.iX, &iHandJumpSeedLocation.iY );

        // search 7x7 grid
        INT2Range iXRange( iHandJumpSeedLocation.iX - 3, iHandJumpSeedLocation.iX + 4 );
        INT2Range iYRange( iHandJumpSeedLocation.iY - 3, iHandJumpSeedLocation.iY + 4 );

        iXRange.iMin = max( iXRange.iMin, 0 );
        iXRange.iMax = min( iXRange.iMax, 79 );
        iYRange.iMin = max( iYRange.iMin, 0 );
        iYRange.iMax = min( iYRange.iMax, 59 );
        INT iSmallestDiff = INT_MAX;
        INT3Vector iSmallestLocation = pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60;
        for ( INT iY = iYRange.iMin; iY < iYRange.iMax; ++iY )
        {
            for ( INT iX = iXRange.iMin; iX < iXRange.iMax; ++iX )
            {
                USHORT uCurrentValue = pDepth80x60Min[ iX + iY * iShortPitch80x60Min ]; 
                USHORT uDepth = uCurrentValue >> NUI_IMAGE_PLAYER_INDEX_SHIFT;
                if ( uDepth != 0 )
                {
                    iDiff = ( (INT)uDepth - pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iZ );

                    if ( iDiff < iSmallestDiff ) 
                    {
                        iSmallestDiff = iDiff;
                        iSmallestLocation.iX = iX;
                        iSmallestLocation.iY = iY;
                        iSmallestLocation.iZ = (INT)uDepth;
                    }
                }
            }
        }
        pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60 = iSmallestLocation;

    }        
    else if ( iDiff > g_iDistanceOffDepthMaptoWarrantSmallSearch )  
    {
        //do a small search

        // search 3x3 grid
        INT2Vector iHandJumpSeedLocation( pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iX, 
            pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iY);
        Clamp80x60( &iHandJumpSeedLocation.iX, &iHandJumpSeedLocation.iY );

        INT2Range iXRange( iHandJumpSeedLocation.iX - 1, iHandJumpSeedLocation.iX + 2 );
        INT2Range iYRange( iHandJumpSeedLocation.iY - 1, iHandJumpSeedLocation.iY + 2 );
        iXRange.iMin = max( iXRange.iMin, 0 );
        iXRange.iMax = min( iXRange.iMax, 79 );
        iYRange.iMin = max( iYRange.iMin, 0 );
        iYRange.iMax = min( iYRange.iMax, 59 );
        INT iSmallestDiff = INT_MAX;
        INT3Vector iSmallestLocation = pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60;
        for ( INT iY = iYRange.iMin; iY < iYRange.iMax; ++iY )
        {
            for ( INT iX = iXRange.iMin; iX < iXRange.iMax; ++iX )
            {
                USHORT uCurrentValue = pDepth80x60Min[ iX + iY * iShortPitch80x60Min ]; 
                USHORT uDepth = uCurrentValue >> NUI_IMAGE_PLAYER_INDEX_SHIFT;
                if ( uDepth != 0 )
                {
                    iDiff = ( (INT)uDepth - pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iZ );
                    if ( iDiff < iSmallestDiff && iDiff > iBiggestPossibleDifferenceForJump ) // we're only searching 1 pixel so we're looking for small differences  
                    {
                        iSmallestDiff = iDiff;
                        iSmallestLocation.iX = iX;
                        iSmallestLocation.iY = iY;
                        iSmallestLocation.iZ = (INT)uDepth;
                    }
                }
            }
        }
        pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60 = iSmallestLocation;
    }

#ifdef DEBUG_COMPUTE_AND_SHOW_VISUALIZATION
    pHandSpecificData->m_INT3ScreenSpaceHandJumpOnArm80x60 = pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60;
#endif

}

//--------------------------------------------------------------------------------------
// Name: WalkToEndOfHand80x60SingleDirection
// Desc: Follows the 5 closest directions to the passed in direction until a large edge 
// is found.  Stores the new end position into the hand-specific data as the new refined 
// hand.
//--------------------------------------------------------------------------------------
INT3Vector WalkToEndOfHand80x60SingleDirection( INT iDirection,
                                               INT3Vector iStartLocation,
                                               INT iWalkToEndOfHandThreshold, 
                                               DepthMaps* __restrict pDMS, 
                                               RefinementData* __restrict pRefinementData, 
                                               HandSpecificData* __restrict pHandSpecificData,
                                               INT iDirectionCount )
{
    INT iDirections[SEARCHDIRECTION_COUNT];
    iDirections[SEARCHDIRECTION_FORWARD] = (iDirection );
    iDirections[SEARCHDIRECTION_DIAGONAL_LEFT] = (iDirection + 7) % 8;
    iDirections[SEARCHDIRECTION_DIAGONAL_RIGHT] = (iDirection + 1) % 8;
    iDirections[SEARCHDIRECTION_ORTHOGONAL_LEFT] = (iDirection + 6) % 8;
    iDirections[SEARCHDIRECTION_ORTHOGONAL_RIGHT] = (iDirection + 2) % 8;

    INT iShortPitch80x60Min = pDMS->m_iShortPitch80x60Min;
    USHORT* pDepth80x60Min = pDMS->m_pData80x60Min;
   
    INT iSmallestValue = g_iMaxImageDepth;
    INT iOffset[] = {0,0};

    INT3Vector WalkLocation = iStartLocation; 
    INT iCurrentMarchLocationDepth = 0;
    INT iLastSmallestIndex = -1;
    INT iSmallestTest = -1;

    assert( iStartLocation.iX < 80 );
    assert( iStartLocation.iY < 60 );

    for ( INT iWalkIndex = 0; iWalkIndex < g_nWalkToEdgeIterations; ++iWalkIndex )
    {   
        WalkLocation.iX = iStartLocation.iX + iOffset[0];
        WalkLocation.iY = iStartLocation.iY + iOffset[1];

        Clamp80x60( &WalkLocation.iX, &WalkLocation.iY );
        
        assert( WalkLocation.iX < 80 );
        assert( WalkLocation.iY < 60 );

        iCurrentMarchLocationDepth = pDepth80x60Min[ WalkLocation.iX + WalkLocation.iY * iShortPitch80x60Min ] >> NUI_IMAGE_PLAYER_INDEX_SHIFT;

        INT3Vector EdgeWalkLocation = WalkLocation;
        EdgeWalkLocation.iZ = iCurrentMarchLocationDepth;
        // Find the average for the potential search directions

        iSmallestTest = -1;
        iSmallestValue = g_iMaxImageDepth;
        INT iOffLimitsDirection = -1;
        if ( iLastSmallestIndex == SEARCHDIRECTION_ORTHOGONAL_LEFT )
        {
            iOffLimitsDirection = SEARCHDIRECTION_ORTHOGONAL_RIGHT;
        }
        else if ( iLastSmallestIndex == SEARCHDIRECTION_ORTHOGONAL_RIGHT )
        {
            iOffLimitsDirection = SEARCHDIRECTION_ORTHOGONAL_LEFT;
        }

        for ( INT iIndex = 0; iIndex < iDirectionCount; ++iIndex )
        {
            EdgeWalkLocation.iX = iStartLocation.iX + 
                iOffset[0] + g_SpiralSearchOffsets[iDirections[iIndex]].iX;
            EdgeWalkLocation.iY = iStartLocation.iY + 
                iOffset[1] + g_SpiralSearchOffsets[iDirections[iIndex]].iY;

            Clamp80x60( &EdgeWalkLocation.iX, &EdgeWalkLocation.iY );

            assert( EdgeWalkLocation.iX < 80 );
            assert( EdgeWalkLocation.iY < 60 );

            USHORT uValue = pDepth80x60Min[ EdgeWalkLocation.iX + EdgeWalkLocation.iY * iShortPitch80x60Min ]; 
            INT iDepth = uValue >> NUI_IMAGE_PLAYER_INDEX_SHIFT;
            INT iDiff = iDepth - iCurrentMarchLocationDepth;
            if ( ( iDiff ) < iWalkToEndOfHandThreshold )
            {
                iDiff = INTABSFAST( iDiff );
                INT Test = iDiff + g_iBiasFor5SearchDirections[iIndex];
                if ( iSmallestValue > Test && iIndex != iOffLimitsDirection && iDiff < 150 )
                {
                    iSmallestTest = iIndex;
                    iSmallestValue = Test;
                }
            }
        }
        
        iLastSmallestIndex = iSmallestTest;

        if ( iSmallestTest == -1 )
        {
            break;
        }
        iOffset[0] += g_SpiralSearchOffsets[iDirections[iSmallestTest]].iX; 
        iOffset[1] += g_SpiralSearchOffsets[iDirections[iSmallestTest]].iY; 


    }
    INT3Vector iWalkedLocation;
    iWalkedLocation.iX = iStartLocation.iX + iOffset[0];
    iWalkedLocation.iY = iStartLocation.iY + iOffset[1];
    Clamp80x60( &iWalkedLocation.iX, &iWalkedLocation.iY );
    iWalkedLocation.iZ = pDepth80x60Min[ iWalkedLocation.iX + iWalkedLocation.iY * iShortPitch80x60Min ] >> NUI_IMAGE_PLAYER_INDEX_SHIFT; 

    return iWalkedLocation;

}

//--------------------------------------------------------------------------------------
// Name: WalkToEndofHand80x60
// Desc: Follow the current position away from the elbow towards the end of the hand
// 
//--------------------------------------------------------------------------------------
VOID WalkToEndofHand80x60 ( DepthMaps* __restrict pDMS, 
                            RefinementData* __restrict pRefinementData, 
                            HandSpecificData* __restrict pHandSpecificData, 
                            OptionalHandSpecificData* __restrict pExtraData )
{

    INT iDirection1;

    CalculateSearchDirection( 
        pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iX, 
        pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iY, 
        pHandSpecificData->m_INT3ScreenSpaceElbow80x60.iX, 
        pHandSpecificData->m_INT3ScreenSpaceElbow80x60.iY, &iDirection1 );
    INT iDirection2 = ( iDirection1  + 1 ) % 8;
    INT iDirection3 = ( iDirection1  + 7 ) % 8;

    INT3Vector iDirection1Vector;
    INT3Vector iDirection2Vector;
    INT3Vector iDirection3Vector;

    BOOL bWalkWasValid = FALSE;
    
    INT3Vector idiff;
    idiff.iX = pHandSpecificData->m_INT3ScreenSpaceHandRaw80x60.iX - pRefinementData->m_INT3ScreenSpaceSpine80x60.iX;
    idiff.iY = pHandSpecificData->m_INT3ScreenSpaceHandRaw80x60.iY - pRefinementData->m_INT3ScreenSpaceSpine80x60.iY;
    idiff.iX *= idiff.iX;
    idiff.iY *= idiff.iY;
    INT3Vector INT3WalkAwayFromPoint;

    INT3WalkAwayFromPoint = pHandSpecificData->m_INT3ScreenSpaceElbow80x60;


    static CONST INT iIterations = sizeof(g_iWalktoEndofHandThesholds) / sizeof(INT);
    for ( INT iIndex = 0; iIndex < iIterations && !bWalkWasValid; ++iIndex )
    {
        PIXBeginNamedEvent( 0, "Walk to End of Hand Direction 1" );
        iDirection1Vector = WalkToEndOfHand80x60SingleDirection( iDirection1, 
                pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60,
                g_iWalktoEndofHandThesholds[iIndex], pDMS, pRefinementData, pHandSpecificData, SEARCHDIRECTION_COUNT );
        PIXEndNamedEvent();
        PIXBeginNamedEvent( 0, "Walk to End of Hand Direction 2" );
            iDirection2Vector = WalkToEndOfHand80x60SingleDirection( iDirection2,
                pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60,
                g_iWalktoEndofHandThesholds[iIndex], pDMS, pRefinementData, pHandSpecificData, SEARCHDIRECTION_COUNT );
        PIXEndNamedEvent();
        PIXBeginNamedEvent( 0, "Walk to End of Hand Direction 3" );
            iDirection3Vector = WalkToEndOfHand80x60SingleDirection( iDirection3,
                pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60,
                g_iWalktoEndofHandThesholds[iIndex], pDMS, pRefinementData, pHandSpecificData, SEARCHDIRECTION_COUNT );
        PIXEndNamedEvent();

        idiff.iX = iDirection1Vector.iX - INT3WalkAwayFromPoint.iX;
        idiff.iY = iDirection1Vector.iY - INT3WalkAwayFromPoint.iY;
        idiff.iZ = ( iDirection1Vector.iZ - INT3WalkAwayFromPoint.iZ ) / 24;
        INT iDistance1 = idiff.iX * idiff.iX + idiff.iY * idiff.iY + idiff.iZ * idiff.iZ;

        idiff.iX = iDirection2Vector.iX - INT3WalkAwayFromPoint.iX;
        idiff.iY = iDirection2Vector.iY - INT3WalkAwayFromPoint.iY;
        idiff.iZ = ( iDirection2Vector.iZ - INT3WalkAwayFromPoint.iZ ) / 24;
        INT iDistance2 = idiff.iX * idiff.iX + idiff.iY * idiff.iY + idiff.iZ * idiff.iZ;

        idiff.iX = iDirection3Vector.iX - INT3WalkAwayFromPoint.iX;
        idiff.iY = iDirection3Vector.iY - INT3WalkAwayFromPoint.iY;
        idiff.iZ = ( iDirection3Vector.iZ - INT3WalkAwayFromPoint.iZ ) / 24;
        INT iDistance3 = idiff.iX * idiff.iX + idiff.iY * idiff.iY + idiff.iZ * idiff.iZ;

        INT3Vector iDirectionVector;
        INT iTestDifference;

        INT iBestDirection = 0;
        if ( iDistance1 >= iDistance2 && iDistance1 >= iDistance3 )
        {
            iBestDirection = iDirection1;
            iDirectionVector = iDirection1Vector;
            idiff = iDirectionVector;
            idiff.iX -= pHandSpecificData->m_INT3ScreenSpaceHandRaw80x60.iX;
            idiff.iY -= pHandSpecificData->m_INT3ScreenSpaceHandRaw80x60.iY;
        }
        else if ( iDistance2 >= iDistance3 )
        {
            iBestDirection = iDirection2;
            iDirectionVector = iDirection2Vector;
            idiff = iDirectionVector;
            idiff.iX -= pHandSpecificData->m_INT3ScreenSpaceHandRaw80x60.iX;
            idiff.iY -= pHandSpecificData->m_INT3ScreenSpaceHandRaw80x60.iY;
        }
        else 
        {
            iBestDirection = iDirection3;
            iDirectionVector = iDirection3Vector;
            idiff = iDirectionVector;
            idiff.iX -= pHandSpecificData->m_INT3ScreenSpaceHandRaw80x60.iX;
            idiff.iY -= pHandSpecificData->m_INT3ScreenSpaceHandRaw80x60.iY;
        }
        iTestDifference = idiff.iX * idiff.iX + idiff.iY * idiff.iY;
        INT iDirection = 0;
        CalculateSearchDirection( iDirectionVector.iX, iDirectionVector.iY, 
            pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iX, 
            pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iY, &iDirection );
        if ( iTestDifference < pRefinementData->m_iSpillDistanceSquared )
        {
                pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60 = iDirectionVector;
                bWalkWasValid = TRUE;
        }
    }
    if ( !bWalkWasValid )
    {
        pHandSpecificData->m_bRevertedToRawData = TRUE;
    }

#ifdef DEBUG_COMPUTE_AND_SHOW_VISUALIZATION
    pHandSpecificData->m_INT3ScreenSpaceHandWalkToEndofArm80x60 = pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60;
#endif

}


//--------------------------------------------------------------------------------------
// Name: InitializeHand
// Desc: Resets all of the hand specific data. Calculates hand specific data 
// such as the search radius and limb lengths
//--------------------------------------------------------------------------------------
VOID InitializeHand( NUI_SKELETON_POSITION_INDEX eHand, 
                    NUI_SKELETON_POSITION_INDEX eElbow,
                    RefinementData* __restrict pRefinementData,
                    const XMVECTOR pSkeletonJoints[NUI_SKELETON_POSITION_COUNT], 
                    HandSpecificData* __restrict pHandData,
                    OptionalHandSpecificData* __restrict pEHSP )
{
    static CONST FLOAT fScaleToRadiusSize = 20.0f;
    

#ifdef DEBUG_COMPUTE_AND_SHOW_VISUALIZATION
    memset( &pHandData->m_INT3ScreenSpaceHandJumpOnArm80x60, 0, sizeof(INT3Vector) );    
    memset( &pHandData->m_INT3ScreenSpaceHandWalkToEndofArm80x60, 0, sizeof(INT3Vector) );    
    memset( &pHandData->m_INT3ScreenSpaceHandCenterAroundEndofArm80x60, 0, sizeof(INT3Vector) );    
#endif

    pHandData->m_iOffsetForHandCloseToBody = 0;
    FLOAT fSearchRadiusAtNearPlane =( pRefinementData->m_fHeadToSpine * fScaleToRadiusSize);
    
    FLOAT fRadius = fSearchRadiusAtNearPlane / XMVectorGetZ( pSkeletonJoints[eHand] );
    INT iSize =  sizeof( OptionalHandSpecificData );
    memset( pEHSP, 0, iSize );
    pEHSP->m_iVoxelSearchRadius = min( (INT)fRadius, g_iNuiRefinementKernelMaxSize80x60 );
    // scale from 80x60 to 320x240
    fRadius *= 4.0f;
    fRadius = min( fRadius, g_fNuiRefinementHalfKernelSize320x240 );

    pEHSP->m_iSquaredSizeOfHandTheshold = (INT) ( fRadius * fRadius );

    pHandData->m_vRawElbow = pSkeletonJoints[eElbow];
    pHandData->m_vRawHand = pSkeletonJoints[eHand];

    TransformWorldToScreen80x60( pHandData->m_vRawElbow, 
        &pHandData->m_INT3ScreenSpaceElbow80x60 );
    
    TransformWorldToScreen80x60( pSkeletonJoints[eHand], 
        &pHandData->m_INT3ScreenSpaceHandRaw80x60 );
    ATG::INT3Vector* ScreenHand = &pHandData->m_INT3ScreenSpaceHandRaw80x60;
    if ( ScreenHand->iX < 0 ||  ScreenHand->iX > 79 || ScreenHand->iY < 0|| ScreenHand->iY > 59 )
    {
        pHandData->m_bRevertedToRawData = TRUE;
    }
    else
    {
        pHandData->m_bRevertedToRawData = FALSE;
    }
    pHandData->m_INT3ScreenSpaceHandRefined80x60  = pHandData->m_INT3ScreenSpaceHandRaw80x60;
    Clamp80x60( &pHandData->m_INT3ScreenSpaceHandRefined80x60.iX, &pHandData->m_INT3ScreenSpaceHandRefined80x60.iY );
    pHandData->m_eHand = eHand;

}

//--------------------------------------------------------------------------------------
// Name: BuildValidMaskWithSearchSpiral80x60()
// Desc: Builds the mask that is used to threshold the hand from the body and optimize 
// the 320x240 search.  
//--------------------------------------------------------------------------------------
VOID BuildValidMaskWithSearchSpiral80x60( DepthMaps* __restrict pDMS,
                                          RefinementData* __restrict pRefinementData,
                                          INT3Vector Position80x60,
                                          BOOL* __restrict pValid80x60Voxels,
                                          INT iThresholdForNeighbor,
                                          INT iNegativeThresholdForNeighbor
                                         )
{

    PIXBeginNamedEvent( 0, "BuildValidVoxelMaskWithSearchSpiral80x60" );

    INT2Vector iKernelCenter(g_iNuiRefinementKernelCenter80x60, g_iNuiRefinementKernelCenter80x60);
    // start the center position of he mask to on
    pValid80x60Voxels[ iKernelCenter.iY * g_iNuiRefinementKernelSize80x60 + iKernelCenter.iX ] = TRUE;
    
    USHORT* pDepth80x60Min = pDMS->m_pData80x60Min;
    INT iShortPitch80x60Min = pDMS->m_iShortPitch80x60Min;
    
    static INT iSearchIterations = sizeof( g_UnrolledNeighborSearchSpiral ) / sizeof( SpiralSearchLocation ) ;
    INT2Vector CurrentRingLocation80x60;
    INT2Vector CurrentTestLocationVoxel;
    SpiralSearchLocation* pCurrentSpiral;
    INT iLastKnownDepth = Position80x60.iZ;
    INT iCurrentRing80x60Location = Position80x60.iY * iShortPitch80x60Min + Position80x60.iX;
    for ( INT iIter =0; iIter <  iSearchIterations; ++iIter )
    {
        pCurrentSpiral = &g_UnrolledNeighborSearchSpiral[iIter];
        CurrentRingLocation80x60.iX = Position80x60.iX + pCurrentSpiral->m_iSearchSpot.iX;
        CurrentRingLocation80x60.iY = Position80x60.iY + pCurrentSpiral->m_iSearchSpot.iY;
        iCurrentRing80x60Location += pCurrentSpiral->m_iOffsetIn80x60;
        if ( CurrentRingLocation80x60.iX < 80 && CurrentRingLocation80x60.iX > -1 && CurrentRingLocation80x60.iY < 60 && CurrentRingLocation80x60.iY > -1 )
        // this is the only value that needs to be tested to keeps us from reading outside of the buffer.
        //all other buffers will be calculated to point inwards from this buffer and therefore don't need to be calculated.
        {
            INT iCurrentDepth= pDepth80x60Min[ iCurrentRing80x60Location ] >> NUI_IMAGE_PLAYER_INDEX_SHIFT;
            // 3 interations of unrolled loop
            {
                INT iCurrentLocation12x12 = ( iKernelCenter.iY + pCurrentSpiral->m_iSearchSpot.iY )  
                    * g_iNuiRefinementKernelSize80x60 + (iKernelCenter.iX + pCurrentSpiral->m_iSearchSpot.iX );
                INT iTestLocation12x12 = iCurrentLocation12x12 + 
                    g_SpiralSearchOffsets12x12[pCurrentSpiral->m_iSearchDirection];
                
                if ( pValid80x60Voxels[iTestLocation12x12] )
                {
                    INT iTestDepthLocation80x60 = 
                        (iCurrentRing80x60Location + g_SpiralSearchOffsets80x60[pCurrentSpiral->m_iSearchDirection]);

                    INT iDepthForTestLocation = pDepth80x60Min[ iTestDepthLocation80x60 ] >> NUI_IMAGE_PLAYER_INDEX_SHIFT;

                    INT iDiff = iCurrentDepth - iDepthForTestLocation;
                    if ( ( iDiff ) < iThresholdForNeighbor && iDiff > iNegativeThresholdForNeighbor )
                    {
                        iLastKnownDepth = iCurrentDepth;
                        pValid80x60Voxels[ iCurrentLocation12x12 ] = TRUE;   
                    }
                }
            }
            {
                INT iDirection = (pCurrentSpiral->m_iSearchDirection+1)%8;
                INT iCurrentLocation12x12 = ( iKernelCenter.iY + pCurrentSpiral->m_iSearchSpot.iY )  * g_iNuiRefinementKernelSize80x60 + 
                             (iKernelCenter.iX + pCurrentSpiral->m_iSearchSpot.iX );
                INT iTestLocation12x12 = iCurrentLocation12x12 + g_SpiralSearchOffsets12x12[iDirection];
                
                if ( pValid80x60Voxels[iTestLocation12x12] )
                {
                    INT iTestDepthLocation80x60 = 
                        (iCurrentRing80x60Location + g_SpiralSearchOffsets80x60[iDirection]);

                    INT iDepthForTestLocation = pDepth80x60Min[ iTestDepthLocation80x60 ] >> NUI_IMAGE_PLAYER_INDEX_SHIFT;

                    INT iDiff = iCurrentDepth - iDepthForTestLocation;
                    if ( ( iDiff ) < iThresholdForNeighbor && iDiff > iNegativeThresholdForNeighbor )
                    {
                        iLastKnownDepth = iCurrentDepth;
                        pValid80x60Voxels[ iCurrentLocation12x12 ] = TRUE;   
                    }
                }
            }
            {
                INT iDirection = (pCurrentSpiral->m_iSearchDirection+7)%8;
                INT iCurrentLocation12x12 = ( iKernelCenter.iY + pCurrentSpiral->m_iSearchSpot.iY )  * g_iNuiRefinementKernelSize80x60 + 
                             (iKernelCenter.iX + pCurrentSpiral->m_iSearchSpot.iX );
                INT iTestLocation12x12 = iCurrentLocation12x12 + g_SpiralSearchOffsets12x12[iDirection];
                
                if ( pValid80x60Voxels[iTestLocation12x12] )
                {
                    INT iTestDepthLocation80x60 = 
                        (iCurrentRing80x60Location + g_SpiralSearchOffsets80x60[iDirection]);

                    INT iDepthForTestLocation = pDepth80x60Min[ iTestDepthLocation80x60 ] >> NUI_IMAGE_PLAYER_INDEX_SHIFT;

                    INT iDiff = iCurrentDepth - iDepthForTestLocation;
                    if ( ( iDiff ) < iThresholdForNeighbor && iDiff > iNegativeThresholdForNeighbor )
                    {
                        iLastKnownDepth = iCurrentDepth;
                        pValid80x60Voxels[ iCurrentLocation12x12 ] = TRUE;   
                    }
                }
            }
        }

        
    }
    PIXEndNamedEvent();

}

//--------------------------------------------------------------------------------------
// Name: MaskTooCloseToBodyToCenter()
// Desc: Determines if the mask is too close to the body for centering to be helpful.
//--------------------------------------------------------------------------------------
BOOL MaskTooCloseToBodyToCenter (   INT iDirection,
                                    DepthMaps* __restrict pDMS,
                                    RefinementData* __restrict pRefinementData,
                                    HandSpecificData* __restrict pHandSpecificData,
                                    BOOL* __restrict pValid80x60Voxels )
{
    INT diff, mask;
    INT2Vector iCurrentGridCell;
    USHORT* pDepth80x60Min = pDMS->m_pData80x60Min;
    INT iShortPitch80x60Min = pDMS->m_iShortPitch80x60Min;

    INT iMaxValueOfOuterVoxelMask = 0;
    INT2Vector iTest;

    INT iX,iY;
    for ( INT iOuter= 0; iOuter < 11; ++iOuter )
    {
        iX = iOuter;
        iY = 0;
        if ( pValid80x60Voxels[iY*g_iNuiRefinementKernelSize80x60+iX] )
        {
            iTest.iX = iX;
            iTest.iY = iY;
            iTest.iX += -g_iNuiRefinementKernelCenter80x60 + pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iX;
            iTest.iY += -g_iNuiRefinementKernelCenter80x60 + pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iY;
            if ( iTest.iX >=0 && iTest.iX < 80 && iTest.iY >=0 && iTest.iY < 60 )
            {
                INT iDepth = pDepth80x60Min[iTest.iX + iTest.iY * iShortPitch80x60Min] >> NUI_IMAGE_PLAYER_INDEX_SHIFT;
                GETMAX( iMaxValueOfOuterVoxelMask, iMaxValueOfOuterVoxelMask, iDepth ); 
            }
        }
        iX = iOuter;
        iY = 10;
        if ( pValid80x60Voxels[iY*g_iNuiRefinementKernelSize80x60+iX] )
        {
            iTest.iX = iX;
            iTest.iY = iY;
            iTest.iX += -g_iNuiRefinementKernelCenter80x60 + pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iX;
            iTest.iY += -g_iNuiRefinementKernelCenter80x60 + pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iY;
            if ( iTest.iX >=0 && iTest.iX < 80 && iTest.iY >=0 && iTest.iY < 60 )
            {
                INT iDepth = pDepth80x60Min[iTest.iX + iTest.iY * iShortPitch80x60Min] >> NUI_IMAGE_PLAYER_INDEX_SHIFT;
                GETMAX( iMaxValueOfOuterVoxelMask, iMaxValueOfOuterVoxelMask, iDepth ); 
            }
        }
        iX = 0;
        iY = iOuter;
        if ( pValid80x60Voxels[iY*g_iNuiRefinementKernelSize80x60+iX] )
        {
            iTest.iX = iX;
            iTest.iY = iY;
            iTest.iX += -g_iNuiRefinementKernelCenter80x60 + pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iX;
            iTest.iY += -g_iNuiRefinementKernelCenter80x60 + pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iY;
            if ( iTest.iX >=0 && iTest.iX < 80 && iTest.iY >=0 && iTest.iY < 60 )
            {
                INT iDepth = pDepth80x60Min[iTest.iX + iTest.iY * iShortPitch80x60Min] >> NUI_IMAGE_PLAYER_INDEX_SHIFT;
                GETMAX( iMaxValueOfOuterVoxelMask, iMaxValueOfOuterVoxelMask, iDepth ); 
            }
        }
        iX = 10;
        iY = iOuter;
        if ( pValid80x60Voxels[iY*g_iNuiRefinementKernelSize80x60+iX] )
        {
            iTest.iX = iX;
            iTest.iY = iY;
            iTest.iX += -g_iNuiRefinementKernelCenter80x60 + pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iX;
            iTest.iY += -g_iNuiRefinementKernelCenter80x60 + pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iY;
            if ( iTest.iX >=0 && iTest.iX < 80 && iTest.iY >=0 && iTest.iY < 60 )
            {
                INT iDepth = pDepth80x60Min[iTest.iX + iTest.iY * iShortPitch80x60Min] >> NUI_IMAGE_PLAYER_INDEX_SHIFT;
                GETMAX( iMaxValueOfOuterVoxelMask, iMaxValueOfOuterVoxelMask, iDepth ); 
            }
        }
    }
    {
        INT iDirections[] = { iDirection, ( iDirection + 1 ) % 8, ( iDirection + 7 ) % 8 };
        INT iOutOfVoxelValue = g_iMaxImageDepth; 
        INT iZeros = 0;
        for ( INT iIndex = 0; iIndex < 3; ++iIndex )
        {
            
            iTest.iX = g_SpiralSearchOffsets[iDirections[iIndex]].iX * 2; 
            iTest.iY = g_SpiralSearchOffsets[iDirections[iIndex]].iY * 2; 
            if ( !pValid80x60Voxels[ ( iTest.iY + g_iNuiRefinementKernelCenter80x60 ) * 
                g_iNuiRefinementKernelSize80x60 + iTest.iX + g_iNuiRefinementKernelCenter80x60] )
            iTest.iX += pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iX;
            iTest.iY += pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iY;
            if ( iTest.iX >=0 && iTest.iX < 80 && iTest.iY >=0 && iTest.iY < 60 )
            {
                INT iDepth = pDepth80x60Min[iTest.iY * iShortPitch80x60Min + iTest.iX ] >> NUI_IMAGE_PLAYER_INDEX_SHIFT;
                if ( iDepth == 0 )
                {
                    ++iZeros;
                }
                else
                {
                    GETMIN( iOutOfVoxelValue, iDepth, iOutOfVoxelValue );
                }
            }
        }
        if ( iZeros > 1 ) 
        {
            return TRUE;
        }
        if ( iOutOfVoxelValue != g_iMaxImageDepth )
        {
            if ( ( iOutOfVoxelValue - iMaxValueOfOuterVoxelMask ) > 200 )
            {
                return TRUE;
            }
            if ( ( iOutOfVoxelValue - iMaxValueOfOuterVoxelMask ) < -30 )
            {
                pHandSpecificData->m_iOffsetForHandCloseToBody = 50;
            }
            if ( ( iOutOfVoxelValue - iMaxValueOfOuterVoxelMask ) < 30 )
            {
                pHandSpecificData->m_iOffsetForHandCloseToBody = 30;
            }
        }
    }
    return FALSE;
}

//--------------------------------------------------------------------------------------
// Name: MaskSpill()
// Desc: Determines if the mask spilled off the hand and passed the end of the hand.
//--------------------------------------------------------------------------------------
BOOL MaskSpill( BOOL* __restrict pValid80x60Voxels, INT2Vector INT2SearchNormal )
{
    INT iEdgeCount = 0;
    INT2Vector iCurrentGridCell;  
    for ( INT iSidesIndex = 0; iSidesIndex < 10; ++iSidesIndex )
    {
       
        iCurrentGridCell.iX = iSidesIndex;
        iCurrentGridCell.iY = 0;
        if ( pValid80x60Voxels[iCurrentGridCell.iY*g_iNuiRefinementKernelSize80x60+iCurrentGridCell.iX] )
        {
            ++iEdgeCount;
        }
        iCurrentGridCell.iX = iSidesIndex;
        iCurrentGridCell.iY = 10;
        if ( pValid80x60Voxels[iCurrentGridCell.iY*g_iNuiRefinementKernelSize80x60+iCurrentGridCell.iX] )
        {
            ++iEdgeCount;
        }
        iCurrentGridCell.iX = 0;
        iCurrentGridCell.iY = iSidesIndex;
        if ( pValid80x60Voxels[iCurrentGridCell.iY*g_iNuiRefinementKernelSize80x60+iCurrentGridCell.iX] )
        {
            ++iEdgeCount;
        }
        iCurrentGridCell.iX = 10;
        iCurrentGridCell.iY = iSidesIndex;
        if ( pValid80x60Voxels[iCurrentGridCell.iY*g_iNuiRefinementKernelSize80x60+iCurrentGridCell.iX] )
        {
            ++iEdgeCount;
        }
    }
    if ( iEdgeCount > 3 )
    {

        INT2Vector iVectorToCell;
        BOOL iSpillDetected = FALSE;
        for ( INT iSidesIndex = 0; iSidesIndex < 10 && !iSpillDetected; ++iSidesIndex )
        {
            
            iCurrentGridCell.iX = iSidesIndex;
            iCurrentGridCell.iY = 0;
            if ( pValid80x60Voxels[iCurrentGridCell.iY*g_iNuiRefinementKernelSize80x60+iCurrentGridCell.iX] )
            {
                iVectorToCell.iX =  iCurrentGridCell.iX - g_iNuiRefinementKernelCenter80x60;
                iVectorToCell.iY =  iCurrentGridCell.iY - g_iNuiRefinementKernelCenter80x60;
                INT iTest = iVectorToCell.iX * INT2SearchNormal.iX + iVectorToCell.iY * INT2SearchNormal.iY;
                if ( iTest < 0 )
                {
                    return TRUE;
                }
            }
            iCurrentGridCell.iX = iSidesIndex;
            iCurrentGridCell.iY = 10;
            if ( pValid80x60Voxels[iCurrentGridCell.iY*g_iNuiRefinementKernelSize80x60+iCurrentGridCell.iX] )
            {
                iVectorToCell.iX =  iCurrentGridCell.iX - g_iNuiRefinementKernelCenter80x60;
                iVectorToCell.iY =  iCurrentGridCell.iY - g_iNuiRefinementKernelCenter80x60;
                INT iTest = iVectorToCell.iX * INT2SearchNormal.iX + iVectorToCell.iY * INT2SearchNormal.iY;
                if ( iTest < 0 )
                {
                    return TRUE;
                }
            }
            iCurrentGridCell.iX = 0;
            iCurrentGridCell.iY = iSidesIndex;
            if ( pValid80x60Voxels[iCurrentGridCell.iY*g_iNuiRefinementKernelSize80x60+iCurrentGridCell.iX] )
            {
                iVectorToCell.iX =  iCurrentGridCell.iX - g_iNuiRefinementKernelCenter80x60;
                iVectorToCell.iY =  iCurrentGridCell.iY - g_iNuiRefinementKernelCenter80x60;
                INT iTest = iVectorToCell.iX * INT2SearchNormal.iX + iVectorToCell.iY * INT2SearchNormal.iY;
                if ( iTest < 0 )
                {
                    return TRUE;
                }
            }
            iCurrentGridCell.iX = 10;
            iCurrentGridCell.iY = iSidesIndex;
            if ( pValid80x60Voxels[iCurrentGridCell.iY*g_iNuiRefinementKernelSize80x60+iCurrentGridCell.iX] )
            {
                iVectorToCell.iX =  iCurrentGridCell.iX - g_iNuiRefinementKernelCenter80x60;
                iVectorToCell.iY =  iCurrentGridCell.iY - g_iNuiRefinementKernelCenter80x60;
                INT iTest = iVectorToCell.iX * INT2SearchNormal.iX + iVectorToCell.iY * INT2SearchNormal.iY;
                if ( iTest < 0 )
                {
                    return TRUE;
                }
            }
        }
    }
    return FALSE;       
}

//--------------------------------------------------------------------------------------
// Name: CenterMaskOnEndOfHand()
// Desc: Center the mask on the end of the hand.
//--------------------------------------------------------------------------------------
VOID CenterMaskOnEndOfHand( DepthMaps* __restrict pDMS,
                            RefinementData* __restrict pRefinementData,
                            HandSpecificData* __restrict pHandSpecificData,
                            OptionalHandSpecificData* __restrict pEHSP,
                            INT iFinalThreshold,
                            INT2Vector iNormal )
{
    INT diff, mask;
    INT2Vector iAverage(0,0 );
    INT iCount = 0;
    for ( INT iY = 0; iY < 11; ++iY )
    {
        for ( INT iX = 0; iX < 11; ++iX )
        {
            if ( pEHSP->m_bValid80x60Voxels[iY][iX] )
            {
                iAverage.iX += iX;
                iAverage.iY += iY;
                ++iCount;
            }
        }    
    }
    if ( iCount != 0 )
    {
        iAverage.iX -= ( g_iNuiRefinementKernelCenter80x60 * iCount );
        iAverage.iX *= 20;
        iAverage.iX /= 30;
        iAverage.iX /= iCount;
        iAverage.iX += g_iNuiRefinementKernelCenter80x60;

        iAverage.iY -= ( g_iNuiRefinementKernelCenter80x60 * iCount );
        iAverage.iY *= 20;
        iAverage.iY /= 30;
        iAverage.iY /= iCount;
        iAverage.iY += g_iNuiRefinementKernelCenter80x60;

        GETMIN( iAverage.iX, (g_iNuiRefinementKernelSize80x60-1), iAverage.iX );
        GETMIN( iAverage.iY, (g_iNuiRefinementKernelSize80x60-1), iAverage.iY );
        if ( pEHSP->m_bValid80x60Voxels[iAverage.iY][iAverage.iX] )
        {
            BOOL bValidVoxelsTemp[ g_iNuiRefinementKernelSize80x60 ][ g_iNuiRefinementKernelSize80x60 ];
            memset( bValidVoxelsTemp, 0, sizeof( bValidVoxelsTemp ) );
            INT3Vector iNewTestPosition =  pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60;
            iNewTestPosition.iX += iAverage.iX - g_iNuiRefinementKernelCenter80x60;
            iNewTestPosition.iY += iAverage.iY - g_iNuiRefinementKernelCenter80x60;
            Clamp80x60( &iNewTestPosition.iX, &iNewTestPosition.iY );
            iNewTestPosition.iZ = pDMS->m_pData80x60Min[ iNewTestPosition.iY * pDMS->m_iShortPitch80x60Min
                + iNewTestPosition.iX ] >> NUI_IMAGE_PLAYER_INDEX_SHIFT;

            BuildValidMaskWithSearchSpiral80x60( pDMS, pRefinementData, iNewTestPosition,
                &bValidVoxelsTemp[0][0], iFinalThreshold, -200);

            BOOL bSpill = MaskSpill( &bValidVoxelsTemp[0][0], iNormal );

            if ( !bSpill )
            {
                pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60 = iNewTestPosition;
                memcpy( pEHSP->m_bValid80x60Voxels, bValidVoxelsTemp, sizeof( bValidVoxelsTemp ) );
            }
            //pRefinementData
        }
    }
}

//--------------------------------------------------------------------------------------
// Name: FillInCracksInMask()
// Desc: Those mask entries that are turned off but share more than one valid mask edge
// are turned on.
//--------------------------------------------------------------------------------------
VOID FillInCracksInMask( HandSpecificData* __restrict pHandSpecificData,
                         OptionalHandSpecificData* __restrict pEHSP )
{
    // we're going to fill in the voxel mask a touch.
    INT diff, mask;
    if ( !pHandSpecificData->m_bRevertedToRawData )
    {
        BOOL bValid80x60VoxelsCopy[g_iNuiRefinementKernelSize80x60][g_iNuiRefinementKernelSize80x60];
        memset( bValid80x60VoxelsCopy, 0, sizeof( bValid80x60VoxelsCopy ) );

        for ( INT iY = 0; iY < 11; ++iY )
        {
            for ( INT iX = 0; iX < 11; ++iX )
            {
                if ( pEHSP->m_bValid80x60Voxels[iY][iX] )
                {
                    bValid80x60VoxelsCopy[iY][iX] = TRUE;   
                }
                else 
                {
                    BOOL iNeighborCount = 0;
                    INT iXMinus1 = iX-1;
                    INT iYMinus1= iY -1;
                    GETMAX( iXMinus1, iXMinus1, 0 ); 
                    GETMAX( iYMinus1, iYMinus1, 0 ); 
                    
                    iNeighborCount+= pEHSP->m_bValid80x60Voxels[iYMinus1][iXMinus1];
                    iNeighborCount+= pEHSP->m_bValid80x60Voxels[iYMinus1][iX];
                    iNeighborCount+= pEHSP->m_bValid80x60Voxels[iYMinus1][iX+1];

                    iNeighborCount+= pEHSP->m_bValid80x60Voxels[iY][iXMinus1];
                    iNeighborCount+= pEHSP->m_bValid80x60Voxels[iY][iX+1];

                    iNeighborCount+= pEHSP->m_bValid80x60Voxels[iY+1][iXMinus1];
                    iNeighborCount+= pEHSP->m_bValid80x60Voxels[iY+1][iX];
                    iNeighborCount+= pEHSP->m_bValid80x60Voxels[iY+1][iX+1];
                    if ( iNeighborCount > 1 ) 
                    {
                        bValid80x60VoxelsCopy[iY][iX] = TRUE;   
                    }
                }
            }    
        }
        memcpy( pEHSP->m_bValid80x60Voxels, bValid80x60VoxelsCopy, sizeof( bValid80x60VoxelsCopy ) );
    }
}    

//--------------------------------------------------------------------------------------
// Name: BuildValidMaskAndCenter()
// Desc: Iterativly build the mask.  Attempt to center it.  Fill in the cracks in the 
// mask.
//--------------------------------------------------------------------------------------
VOID BuildValidMaskAndCenter ( DepthMaps* __restrict pDMS,
                                    RefinementData* __restrict pRefinementData,
                                    HandSpecificData* __restrict pHandSpecificData,
                                    OptionalHandSpecificData* __restrict pEHSP )
{
    if ( pHandSpecificData->m_bRevertedToRawData ) return;
    
    // Build the first mask, iterate over the potential thresholds untill we find one that doesn't spill
////////////////////////////////////
    INT iFinalThreshold = g_iBuildMaskThresholds[0];
    INT2Vector iNormal( pHandSpecificData->m_INT3ScreenSpaceElbow80x60.iX - pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iX,
        pHandSpecificData->m_INT3ScreenSpaceElbow80x60.iY - pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60.iY );

    BOOL bSpillDetected = TRUE;
    // stay on point we settled on if we risk jumping into the weeds.
    static INT nMaskThresholds = sizeof(g_iBuildMaskThresholds) / sizeof( INT );
    for ( INT iThesholdIndex = 0; iThesholdIndex < nMaskThresholds && bSpillDetected; ++iThesholdIndex )
    {
        INT iSize = sizeof(BOOL) * g_iNuiRefinementKernelSize80x60 * g_iNuiRefinementKernelSize80x60;
        memset( pEHSP->m_bValid80x60Voxels, 0, iSize );

        BuildValidMaskWithSearchSpiral80x60( pDMS, pRefinementData, 
            pHandSpecificData->m_INT3ScreenSpaceHandRefined80x60,
            &pEHSP->m_bValid80x60Voxels[0][0], g_iBuildMaskThresholds[iThesholdIndex], -200 );//-iThresholds[iThesholdIndex] );

        bSpillDetected  = MaskSpill( &pEHSP->m_bValid80x60Voxels[0][0], iNormal );
        iFinalThreshold = g_iBuildMaskThresholds[iThesholdIndex];
    
    }
    if ( bSpillDetected ) pHandSpecificData->m_bRevertedToRawData = TRUE;
//////////////////////////

    INT iDirection;

    CalculateSearchDirection( pHandSpecificData->m_INT3ScreenSpaceHandRaw80x60.iX, 
        pHandSpecificData->m_INT3ScreenSpaceHandRaw80x60.iY, 
        pHandSpecificData->m_INT3ScreenSpaceElbow80x60.iX, 
        pHandSpecificData->m_INT3ScreenSpaceElbow80x60.iY, &iDirection );

    BOOL bMaskGoodEnoughToCenter;
    bMaskGoodEnoughToCenter = MaskTooCloseToBodyToCenter( iDirection, pDMS, pRefinementData, pHandSpecificData, 
            &pEHSP->m_bValid80x60Voxels[0][0] );

    // if the Mask is Suficient quality, center it on the end of the hand.
    if ( !pHandSpecificData->m_bRevertedToRawData && bMaskGoodEnoughToCenter && iFinalThreshold != 30 )
    {
        CenterMaskOnEndOfHand( pDMS, pRefinementData, pHandSpecificData, pEHSP, iFinalThreshold, iNormal );
    }

    FillInCracksInMask( pHandSpecificData, pEHSP );
}

//--------------------------------------------------------------------------------------
// Name: CenterPointOnHandAverageSearch
// Desc: Find the hand inthe 80x60 map
//--------------------------------------------------------------------------------------
VOID Search80x60HandForTheEndOfHand ( DepthMaps* __restrict pDMS,
                                      RefinementData* __restrict pRefinementData,
                                      HandSpecificData* __restrict pHandSpecificData,
                                      OptionalHandSpecificData* __restrict pEHSP )
{
    ClimbOntoHand80x60( pDMS, pRefinementData, pHandSpecificData );
    if ( pHandSpecificData->m_bRevertedToRawData )
    {
        return;
    }

    PIXBeginNamedEvent( 0, "Walk to End of Hand" );
    WalkToEndofHand80x60( pDMS, pRefinementData, pHandSpecificData, pEHSP );
    PIXEndNamedEvent();
    if ( pHandSpecificData->m_bRevertedToRawData )
    {
        return;
    }

    BuildValidMaskAndCenter( pDMS, pRefinementData, pHandSpecificData, pEHSP );
    
}

// We really need to test the tracking state of the joint, but we don't want to break the public API in
// approved libs, so simply check for (0,0,0,0)
__forceinline BOOL IsJointValid( XMVECTOR vJoint )
{
    return XMVector4NotEqual( vJoint, XMVectorZero() );
}

//--------------------------------------------------------------------------------------
// Name: RefineHandsCore()
// Desc: Internal function that refine hands calls to do hand refinement
//--------------------------------------------------------------------------------------
HRESULT RefineHandsCore(_In_     USHORT*                  __restrict pDepth80x60Min,
                        _In_     INT                                 iShortPitch80x60Min,
                        _In_     USHORT*                  __restrict pDepth320x240,
                        _In_     INT                                 iShortPitch320x240,
                        _In_     INT                                 iSegmentationIndex,
                        _In_     const XMVECTOR                      pSkeletonJoints[NUI_SKELETON_POSITION_COUNT],
                        _In_     DWORD                               dwFlags,
                        _Inout_  RefinementData*          __restrict pRefinementData, 
                        _Out_opt_ OptionalRefinementData* __restrict pOptionalRefinementData
                        )
{
    OptionalRefinementData StackAllocatedOptionalRefinmentData;
    // some validation of parameters

    if ( dwFlags & ATG_REFINE_HANDS_FLAG_CALCULATE320x240MASK && pOptionalRefinementData == NULL )
    {
        return E_INVALIDARG;
    }

    if ( pOptionalRefinementData == NULL )
    {
        pOptionalRefinementData = &StackAllocatedOptionalRefinmentData;
    }
    pOptionalRefinementData->m_dwFlags = dwFlags;
    DepthMaps dms;
    dms.m_pData320x240 = pDepth320x240;
    dms.m_iShortPitch320x240 = iShortPitch320x240;
    dms.m_pData80x60Min = pDepth80x60Min;
    dms.m_iShortPitch80x60Min = iShortPitch80x60Min;
    
    InitUnrolledNeighborSearchSpiral( iShortPitch80x60Min );
    pRefinementData->m_uSegmentationIndex = (USHORT) iSegmentationIndex; 

    __analysis_assume( sizeof(pSkeletonJoints) ==  NUI_SKELETON_POSITION_COUNT * 16 );

    XMVECTOR vSpine = pSkeletonJoints[NUI_SKELETON_POSITION_SPINE];
    XMVECTOR vHead  = pSkeletonJoints[NUI_SKELETON_POSITION_HEAD];
    TransformWorldToScreen80x60( vSpine, &pRefinementData->m_INT3ScreenSpaceSpine80x60 );
    TransformWorldToScreen80x60( vHead, &pRefinementData->m_INT3ScreenSpaceHead80x60 );
    INT3Vector iDist = pRefinementData->m_INT3ScreenSpaceSpine80x60;
    iDist.iX -= pRefinementData->m_INT3ScreenSpaceHead80x60.iX;
    iDist.iY -= pRefinementData->m_INT3ScreenSpaceHead80x60.iY;

    iDist.iX *= iDist.iX;
    iDist.iY *= iDist.iY;

    FLOAT fdist = sqrtf( (FLOAT)(iDist.iX + iDist.iY ) );
    pRefinementData->m_fHeadToSpine80x60 = fdist;


    if ( pRefinementData->m_fHeadToSpine80x60 <= 13.0f )
    {
        pRefinementData->m_iSpillDistanceSquared = 25;
    }
    else 
    {
        pRefinementData->m_iSpillDistanceSquared = 82;
    }

    if ( IsJointValid( vSpine ) && IsJointValid( vHead ) )
    {
        XMVECTOR vHeadToSpine = vHead - vSpine;
        FLOAT fLength = XMVectorGetX( XMVector3Length( vHeadToSpine ) );

        if ( pRefinementData->m_fHeadToSpine == 0.0f )
        {
            pRefinementData->m_fHeadToSpine = fLength;
        }
        else 
        {
            pRefinementData->m_fHeadToSpine = 0.8f * pRefinementData->m_fHeadToSpine + 0.2f * fLength;
        }
    }

    // Check if right hand is valid
    XMVECTOR vHand  = pSkeletonJoints[ NUI_SKELETON_POSITION_HAND_RIGHT ];
    XMVECTOR vElbow = pSkeletonJoints[ NUI_SKELETON_POSITION_ELBOW_RIGHT ];
    if ( IsJointValid( vHand ) &&
         IsJointValid( vElbow ) )
    {
        InitializeHand( NUI_SKELETON_POSITION_HAND_RIGHT, NUI_SKELETON_POSITION_ELBOW_RIGHT, pRefinementData,
                        pSkeletonJoints, &pRefinementData->m_RightHandData, &pOptionalRefinementData->m_RightHand );

        PIXBeginNamedEvent( 0, "Refine80x60search Right" );
            Search80x60HandForTheEndOfHand( &dms, pRefinementData, &pRefinementData->m_RightHandData, 
                &pOptionalRefinementData->m_RightHand );
        PIXEndNamedEvent( );

        PIXBeginNamedEvent( 0, "Refine320x240search Right" );
            RefineWith320x240( &dms,
                pRefinementData, &pRefinementData->m_RightHandData, pOptionalRefinementData,
                &pOptionalRefinementData->m_RightHand );
        PIXEndNamedEvent( );
    }
 
    // Check if left hand is valid
    vHand  = pSkeletonJoints[ NUI_SKELETON_POSITION_HAND_LEFT ];
    vElbow = pSkeletonJoints[ NUI_SKELETON_POSITION_ELBOW_LEFT ];
    if ( IsJointValid( vHand ) &&
         IsJointValid( vElbow ) )
    {
        InitializeHand( NUI_SKELETON_POSITION_HAND_LEFT, NUI_SKELETON_POSITION_ELBOW_LEFT, pRefinementData,
                        pSkeletonJoints, &pRefinementData->m_LeftHandData, &pOptionalRefinementData->m_LeftHand);

        PIXBeginNamedEvent( 0, "Refine80x60search Left" );
            Search80x60HandForTheEndOfHand( &dms, pRefinementData, &pRefinementData->m_LeftHandData, 
                &pOptionalRefinementData->m_LeftHand );
        PIXEndNamedEvent( );

        PIXBeginNamedEvent( 0, "Refine320x240search Left" );
            RefineWith320x240( &dms,
                pRefinementData, &pRefinementData->m_LeftHandData, pOptionalRefinementData,
                &pOptionalRefinementData->m_LeftHand );
        PIXEndNamedEvent( );
    }

    return S_OK;
}

//--------------------------------------------------------------------------------------
// Name: RefineHands
// Desc: Uses the 80x60 map to find the hand and then refines with the 320x240 map.
//--------------------------------------------------------------------------------------
HRESULT RefineHands (   _In_        LPDIRECT3DTEXTURE9                      pDepthAndSegmentationTexture320x240,
                        _In_        LPDIRECT3DTEXTURE9                      pDepthAndSegmentationTexture80x60,
                        _In_        INT                                     iSkeletonDataSlot,
                        _In_        const NUI_SKELETON_FRAME*   __restrict pSkeletonFrame,
                        _In_        DWORD                                   dwFlags,
                        _Inout_     RefinementData*             __restrict pRefinementData,
                        _In_opt_    const D3DLOCKED_RECT*       __restrict pDepthRect320x240,
                        _In_opt_    const D3DLOCKED_RECT*       __restrict pDepthRect80x60,
                        _Out_opt_   OptionalRefinementData*        __restrict pOptionalRefinementData
                 )
{
    if ( pDepthAndSegmentationTexture320x240 == NULL ||
         pDepthAndSegmentationTexture80x60 == NULL ||
         iSkeletonDataSlot < 0 ||
         iSkeletonDataSlot >= NUI_SKELETON_COUNT )
    {
        return E_INVALIDARG;
    }


    D3DLOCKED_RECT Rect320x240;
    D3DLOCKED_RECT Rect80x60;

    if ( pDepthRect320x240 == NULL )
    {
        pDepthAndSegmentationTexture320x240->LockRect( 0, &Rect320x240, 0, D3DLOCK_READONLY );
        pDepthRect320x240 = &Rect320x240;
    }
    if ( pDepthRect80x60 == NULL )
    {
        pDepthAndSegmentationTexture80x60->LockRect( 0, &Rect80x60, 0, D3DLOCK_READONLY );
        pDepthRect80x60 = &Rect80x60;
    }
    if ( pDepthRect320x240->Pitch < (320 * 2) || ( pDepthRect80x60->Pitch < (80 * 2) ) )
    {
        return E_INVALIDARG;
    }

    USHORT *pDepth80x60 = (USHORT *)pDepthRect80x60->pBits;
    INT iShortPitch80x60 = pDepthRect80x60->Pitch / sizeof(USHORT);
    USHORT *pDepth320x240 = (USHORT *)pDepthRect320x240->pBits;
    INT iShortPitch320x240 = pDepthRect320x240->Pitch / sizeof(USHORT);

    if ( iShortPitch80x60 < 0 ||
         iShortPitch320x240 < 0 ||
         pDepth80x60 == NULL ||
         pDepth320x240 == NULL )
    {
        pDepthAndSegmentationTexture320x240->UnlockRect( 0 );
        pDepthAndSegmentationTexture80x60->UnlockRect( 0 );
        return E_FAIL;
    }

    // Reset when the tracking changed.
    DWORD dwCurrentTrackingID = pSkeletonFrame->SkeletonData[iSkeletonDataSlot].dwTrackingID;
    if ( pRefinementData->m_dwLastTrackingID != dwCurrentTrackingID )
    {
        pRefinementData->Reset();
        pRefinementData->m_dwLastTrackingID = dwCurrentTrackingID;
    }

    PIXBeginNamedEvent( 0, "Refine Both Hands Core" );
    HRESULT hr = RefineHandsCore( pDepth80x60,
        iShortPitch80x60,
        pDepth320x240,
        iShortPitch320x240,
        iSkeletonDataSlot + 1, // segmentation index is SkeletonData Slot + 1
        pSkeletonFrame->SkeletonData[iSkeletonDataSlot].SkeletonPositions,
        dwFlags,
        pRefinementData,
        pOptionalRefinementData 
    );
    PIXEndNamedEvent( );

    if ( pDepthRect320x240 != NULL )
    {
        pDepthAndSegmentationTexture320x240->UnlockRect( 0 );
    }
    if ( pDepthRect80x60 != NULL )
    {
        pDepthAndSegmentationTexture80x60->UnlockRect( 0 );
    }
    pRefinementData->m_bFirstTimeThrough = FALSE;
    return hr;
}

// ********************************************************************************************************* //
// ********************************************************************************************************* //

}//namespace NuiHandRefinement


```

`XenonDumper/libs/Atg/AtgNuiHandRefinement.h`:

```h
// ********************************************************************************************************* //
// --------------------------------------------------------------------------------------------------------- //
//
// Copyright (c) Microsoft Corporation
//
// --------------------------------------------------------------------------------------------------------- //
// ********************************************************************************************************* //

#ifndef _ATG_NUI_HAND_REFINEMENT_H
#define _ATG_NUI_HAND_REFINEMENT_H

//#define DEBUG_COMPUTE_AND_SHOW_VISUALIZATION 1
// When this is defined hand refinement calculates expensive debug information.
// The HandRefinement sample uses this for visualziation.


// ********************************************************************************************************* //
//
//  Namespace:
//

#include <nuiapi.h>

namespace ATG
{

static CONST INT g_iNuiRefinementKernelSize320x240 = 48;  // The size of the mask that we use to find the average hand value
static CONST INT g_iNuiRefinementHalfKernelSize320x240 = 24; // Half the size of the above mask
static CONST FLOAT g_fNuiRefinementHalfKernelSize320x240 = 24.0f; // Half the size of the above mask
static CONST INT g_iNuiRefinementKernelSize80x60 = 12;  // Each 4x4 block in the 320x240 mask maps to one vlaue in the 80x60 mask
static CONST INT g_iNuiRefinementKernelCenter80x60 = 5; // The 5,5 location is the actual center of the kernel
static CONST INT g_iNuiRefinementKernelMaxSize80x60 = 6; // The biggest possible 80x60 radius


#define ATG_REFINE_HANDS_FLAG_CALCULATE320x240MASK                  0x00000001
// This flag tells us to fill in the user provided pointer with a mask of the 320x240 values used in hand refinement

//--------------------------------------------------------------------------------------
// Trivial struct to wrap up 3 INTs so I don't have to use arrays
//--------------------------------------------------------------------------------------
// TODO the February XDK has an XMINT3 that I could use instead of this class.  
// This should be used when the code is ready for this dependency.
struct INT3Vector
{
    INT3Vector() {};
    INT3Vector( INT iInX, INT iInY, INT iInZ )
    {
        iX = iInX;
        iY = iInY;
        iZ = iInZ;
    };
    INT iX, iY, iZ;
};

//--------------------------------------------------------------------------------------
// Trivial struct to wrap up 2 INTs so I don't have to use arrays
//--------------------------------------------------------------------------------------
struct INT2Vector
{
    INT2Vector() {};
    INT2Vector( INT iInX, INT iInY )
    {
        iX = iInX;
        iY = iInY;
    };
    INT iX, iY;
};

//--------------------------------------------------------------------------------------
// Trivial struct to wrap a range of ints so I don't need 2 variables for a min and max
//--------------------------------------------------------------------------------------
struct INT2Range
{
    INT2Range(){};
    INT2Range( INT iInMin, INT iInMax){
        iMin = iInMin;
        iMax = iInMax;
    };
    INT iMin, iMax;
};

#ifdef DEBUG_COMPUTE_AND_SHOW_VISUALIZATION

//--------------------------------------------------------------------------------------
// Debug data used by apps to visualize the pixels that were used in the final hand 
// average.
//--------------------------------------------------------------------------------------
class VisualizeHandFramesData {
public:
    CHAR m_FrameData[ g_iNuiRefinementKernelSize320x240 ][ g_iNuiRefinementKernelSize320x240 ];
};
#endif

//--------------------------------------------------------------------------------------
// Keeps intermediate data for one hand.  
//--------------------------------------------------------------------------------------
struct HandSpecificData
{
    HandSpecificData() 
    {
        Reset();
    };
    ~HandSpecificData(){};

    VOID Reset()
    {
        m_vRawHand = XMVectorZero();
        m_vRefinedHand = XMVectorZero();
        m_vRawElbow = XMVectorZero();
        m_vOffsetRawToRefined = XMVectorZero();
        m_INT3ScreenSpaceHandRaw80x60.iX = 0;
        m_INT3ScreenSpaceHandRaw80x60.iY = 0;
        m_INT3ScreenSpaceHandRaw80x60.iZ = 0;
        m_INT3ScreenSpaceHandRefined80x60.iX = 0;
        m_INT3ScreenSpaceHandRefined80x60.iY = 0;
        m_INT3ScreenSpaceHandRefined80x60.iZ = 0;
        m_INT3ScreenSpaceElbow80x60.iX = 0;
        m_INT3ScreenSpaceElbow80x60.iY = 0;
        m_INT3ScreenSpaceElbow80x60.iZ = 0;
        m_bRevertedToRawData = FALSE;
        m_bRevertedToRawDataPreviousFrame = FALSE;
        m_eHand = (NUI_SKELETON_POSITION_INDEX)0; 
        m_iOffsetForHandCloseToBody = 0;
#ifdef DEBUG_COMPUTE_AND_SHOW_VISUALIZATION
        memset( &m_VisualizeHandFramesData, 0, sizeof( VisualizeHandFramesData ) );
#endif
    };
    
    XMVECTOR m_vRawHand;                                            // The hand that was received from the Raw skeleton.
    XMVECTOR m_vRefinedHand;                                        // The refined hand that will be returned to the user.
    XMVECTOR m_vRawElbow;                                           // The Elbow that correlates to the hand. i.e. right hand uses right elbow
    XMVECTOR m_vOffsetRawToRefined;                                 // An Offset that is set to interpolate between raw and refined data when we must fall back to raw data

    INT3Vector m_INT3ScreenSpaceHandRaw80x60;                         // The Raw hand in screen space. 
    INT3Vector m_INT3ScreenSpaceElbow80x60;                           // The Raw elbow in screen space.
    INT3Vector m_INT3ScreenSpaceHandRefined80x60;                     // The refined hand position in 80x60 space.

    NUI_SKELETON_POSITION_INDEX m_eHand;                              // NUI_SKELETON_POSITION_INDEX
    SHORT m_iOffsetForHandCloseToBody;                              // This is calculated when we determine the voxel mask.  It's used in the 320x240 to position the collision ellipsoid.

    BOOL m_bRevertedToRawData;                                      // Set this to true when we need to fall back to raw data
    BOOL m_bRevertedToRawDataPreviousFrame;                         // True when we fell back to raw data on the previous frame

#ifdef DEBUG_COMPUTE_AND_SHOW_VISUALIZATION
    INT3Vector m_INT3ScreenSpaceHandJumpOnArm80x60;                   // The hand after jumping onto the arm.
    INT3Vector m_INT3ScreenSpaceHandWalkToEndofArm80x60;              // The hand after walking to the end of the arm.
    INT3Vector m_INT3ScreenSpaceHandCenterAroundEndofArm80x60;        // The hand after centering on the arm.
    VisualizeHandFramesData m_VisualizeHandFramesData;        
#endif

};

//--------------------------------------------------------------------------------------
// This struct can optionally be passed in by apps that want to leverage some of the
// calculations performed by hand refinement.  The Hand Control samples uses this data
// to calculate the orientation of the hand mask.
//--------------------------------------------------------------------------------------
struct OptionalHandSpecificData
{
    OptionalHandSpecificData()
    {
        m_iVoxelSearchRadius = 0;
        m_iSquaredSizeOfHandTheshold = 0;
        memset( m_bValid80x60Voxels, 0, sizeof( m_bValid80x60Voxels ) );
        memset( m_iSpillDirectionSquaredLength, 0, sizeof( m_iSpillDirectionSquaredLength ) );
        memset( &m_SearchSphereCenter320x240, 0, sizeof( m_SearchSphereCenter320x240 ) );
        memset( &m_uHandDepthValues320x240, 0, sizeof( m_uHandDepthValues320x240 ) );
    };

    ~OptionalHandSpecificData(){};

    USHORT m_uHandDepthValues320x240[g_iNuiRefinementKernelSize320x240*g_iNuiRefinementKernelSize320x240];
    BOOL m_bValid80x60Voxels[g_iNuiRefinementKernelSize80x60][g_iNuiRefinementKernelSize80x60];
    INT m_iVoxelSearchRadius;
    INT m_iSquaredSizeOfHandTheshold;
    INT3Vector m_SearchSphereCenter320x240;
    INT m_iSpillDirectionSquaredLength[8];

};

//--------------------------------------------------------------------------------------
// This struct can optionally be passed in by apps that want to leverage some of the
// calculations performed by hand refinement.  The Hand Control samples uses this data
// to calculate the orientation of hte hand mask.
//--------------------------------------------------------------------------------------
struct OptionalRefinementData
{
public:
    OptionalRefinementData(): m_dwFlags( 0 ) {};
    OptionalHandSpecificData m_RightHand;
    OptionalHandSpecificData m_LeftHand;
    DWORD m_dwFlags;
};

//--------------------------------------------------------------------------------------
// This is the main hand refinement structure.  It stores some intermediate data as well 
// as the final refined hands.
//--------------------------------------------------------------------------------------
class RefinementData
{
public:
    RefinementData ()
    {
        Reset();
    };
    VOID Reset()
    {
        m_dwLastTrackingID = 0;
        m_LeftHandData.Reset();
        m_RightHandData.Reset();
        m_uSegmentationIndex = 0;
        m_fHeadToSpine = 0.0f;
        m_fHeadToSpine80x60 = 0.0f;
        m_iSpillDistanceSquared = 0; 
        m_INT3ScreenSpaceSpine80x60.iX = 0;
        m_INT3ScreenSpaceSpine80x60.iY = 0;
        m_INT3ScreenSpaceSpine80x60.iZ = 0;
        m_INT3ScreenSpaceHead80x60.iX = 0;
        m_INT3ScreenSpaceHead80x60.iY = 0;
        m_INT3ScreenSpaceHead80x60.iZ = 0;
        m_bFirstTimeThrough = TRUE;
    }
    XMVECTOR GetRefinedRight()
    {
        return m_RightHandData.m_vRefinedHand;
    }
    XMVECTOR GetRefinedLeft()
    {
        return m_LeftHandData.m_vRefinedHand;
    }
    ~RefinementData(){};

    DWORD m_dwLastTrackingID;
    HandSpecificData m_LeftHandData;
    HandSpecificData m_RightHandData;
    FLOAT m_fHeadToSpine80x60;
    FLOAT m_fHeadToSpine;
    INT3Vector m_INT3ScreenSpaceSpine80x60;                     
    INT3Vector m_INT3ScreenSpaceHead80x60;                     
    INT m_iSpillDistanceSquared; // The number of voxels we can walk and not spill.  
                                 // This value is squared to run faster.
    USHORT m_uSegmentationIndex;
    BOOL m_bFirstTimeThrough;

};

//--------------------------------------------------------------------------------------
// Name: RefineHands
// Desc: Uses the 80x60 map to find the hand and then refines with the 320x240 map.
//--------------------------------------------------------------------------------------
HRESULT RefineHands (  
                    _In_        LPDIRECT3DTEXTURE9                      pDepthAndSegmentationTexture320x240,
                    _In_        LPDIRECT3DTEXTURE9                      pDepthAndSegmentationTexture80x60,
                    _In_        INT                                     iSkeletonDataSlot,
                    _In_        const NUI_SKELETON_FRAME*    __restrict pSkeletonFrame,
                    _In_        DWORD                                   dwFlags,
                    _Inout_     RefinementData*              __restrict pRefinementData,
                    _In_opt_    const D3DLOCKED_RECT*        __restrict pDepthRect320x240,
                    _In_opt_    const D3DLOCKED_RECT*        __restrict pDepthRect80x60,
                    _Out_opt_   OptionalRefinementData*      __restrict pOptionalRefinementData
                 );


// ********************************************************************************************************* //
// ********************************************************************************************************* //

}//namespace NuiHandRefinement

// --------------------------------------------------------------------------------------------------------- //

#endif//__HANDREFINEMENTINTERNAL_H__


```

`XenonDumper/libs/Atg/AtgNuiJointConverter.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// AtgNuiJointConverter.cpp
//
// Demonstrates a method of constraining NUI joints to plausible human biometrics.  This 
// method attaches a set of cone constraints to the joints, and prohibits movement of
// the child bone of that joint outside of the cone.  If the bone does move outside the 
// cone, it is adjusted to lie on the closest point of the cone.
//
// Microsoft Advanced Technology Group
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------

#include <stdafx.h>
#include <xboxmath.h>
#include "AtgNuiJointConverter.h"
#include "AtgSimpleShaders.h"
#include "AtgDebugDraw.h"

namespace ATG
{

const XMVECTOR vBaseDir =           {  1.0f,   0.0f,  0.0f, 0.0f};
const XMVECTOR vHipCenterDir =      {  0.0f,   1.0f,  0.0f, 0.0f};
const XMVECTOR vSpineDir =          {  0.0f,  .985f,-.174f, 0.0f};
const XMVECTOR vShoulderCenterDir = {  1.0f,   0.0f,  0.0f, 0.0f};
const XMVECTOR vNeckDir =           {  0.0f,  .707f, .707f, 0.0f};
const XMVECTOR vCollarLeftDir =     { -1.0f,   0.0f,  0.0f, 0.0f};
const XMVECTOR vShoulderLeftDir =   { -1.0f,   0.0f,  0.0f, 0.0f};
const XMVECTOR vElbowLeftDir =      { -1.0f,   0.0f,  0.0f, 0.0f};
const XMVECTOR vWristLeftDir =      { -1.0f,   0.0f,  0.0f, 0.0f};
const XMVECTOR vCollarRightDir =    {  1.0f,   0.0f,  0.0f, 0.0f};
const XMVECTOR vShoulderRightDir =  {  1.0f,   0.0f,  0.0f, 0.0f};
const XMVECTOR vElbowRightDir =     {  1.0f,   0.0f,  0.0f, 0.0f};
const XMVECTOR vWristRightDir =     {  1.0f,   0.0f,  0.0f, 0.0f};
const XMVECTOR vPelvisLeftDir =     {-.707f, -.707f,  0.0f, 0.0f};
const XMVECTOR vHipLeftDir =        {  0.0f,  -1.0f,  0.0f, 0.0f};
const XMVECTOR vKneeLeftDir =       {  0.0f,  -1.0f,  0.0f, 0.0f};
const XMVECTOR vAnkleLeftDir =      {  0.0f, -.707f,-.707f, 0.0f};
const XMVECTOR vPelvisRightDir =    { .707f, -.707f,  0.0f, 0.0f};
const XMVECTOR vHipRightDir =       {  0.0f,  -1.0f,  0.0f, 0.0f};
const XMVECTOR vKneeRightDir =      {  0.0f,  -1.0f,  0.0f, 0.0f};
const XMVECTOR vAnkleRightDir =     {  0.0f, -.707f,-.707f, 0.0f};

IntermediateJointDesc g_IntJointDesc[ INTERMEDIATE_JOINT_COUNT ] =
{ 
    {  vBaseDir,           (NUI_SKELETON_POSITION_INDEX)(-1),        NUI_SKELETON_POSITION_HIP_CENTER, (INTERMEDIATE_JOINT_INDEX)(-1),      },
    {  vHipCenterDir,      NUI_SKELETON_POSITION_HIP_CENTER,         NUI_SKELETON_POSITION_SPINE,            INT_BASE,                      },
    {  vSpineDir,          NUI_SKELETON_POSITION_SPINE,              NUI_SKELETON_POSITION_SHOULDER_CENTER,  INT_HIP_CENTER,                },
    {  vShoulderCenterDir, NUI_SKELETON_POSITION_SHOULDER_CENTER,    NUI_SKELETON_POSITION_SHOULDER_CENTER,  INT_SPINE,                     },
    {  vNeckDir,           NUI_SKELETON_POSITION_SHOULDER_CENTER,    NUI_SKELETON_POSITION_HEAD,             INT_SPINE,                     },
    {  vCollarLeftDir,     NUI_SKELETON_POSITION_SHOULDER_CENTER,    NUI_SKELETON_POSITION_SHOULDER_LEFT,    INT_SPINE,                     },
    {  vShoulderLeftDir,   NUI_SKELETON_POSITION_SHOULDER_LEFT,      NUI_SKELETON_POSITION_ELBOW_LEFT,       INT_COLLAR_LEFT,               },
    {  vElbowLeftDir,      NUI_SKELETON_POSITION_ELBOW_LEFT,         NUI_SKELETON_POSITION_WRIST_LEFT,       INT_SHOULDER_LEFT,             },
    {  vWristLeftDir,      NUI_SKELETON_POSITION_WRIST_LEFT,         NUI_SKELETON_POSITION_HAND_LEFT,        INT_ELBOW_LEFT,                },
    {  vCollarRightDir,    NUI_SKELETON_POSITION_SHOULDER_CENTER,    NUI_SKELETON_POSITION_SHOULDER_RIGHT,   INT_SPINE,                     },
    {  vShoulderRightDir,  NUI_SKELETON_POSITION_SHOULDER_RIGHT,     NUI_SKELETON_POSITION_ELBOW_RIGHT,      INT_COLLAR_RIGHT,              },
    {  vElbowRightDir,     NUI_SKELETON_POSITION_ELBOW_RIGHT,        NUI_SKELETON_POSITION_WRIST_RIGHT,      INT_SHOULDER_RIGHT,            },
    {  vWristRightDir,     NUI_SKELETON_POSITION_WRIST_RIGHT,        NUI_SKELETON_POSITION_HAND_RIGHT,       INT_ELBOW_RIGHT,               },
    {  vPelvisLeftDir,     NUI_SKELETON_POSITION_HIP_CENTER,         NUI_SKELETON_POSITION_HIP_LEFT,         INT_BASE,                      },
    {  vHipLeftDir,        NUI_SKELETON_POSITION_HIP_LEFT,           NUI_SKELETON_POSITION_KNEE_LEFT,        INT_PELVIS_LEFT,               },
    {  vKneeLeftDir,       NUI_SKELETON_POSITION_KNEE_LEFT,          NUI_SKELETON_POSITION_ANKLE_LEFT,       INT_HIP_LEFT,                  },
    {  vAnkleLeftDir,      NUI_SKELETON_POSITION_ANKLE_LEFT,         NUI_SKELETON_POSITION_FOOT_LEFT,        INT_KNEE_LEFT,                 },
    {  vPelvisRightDir,    NUI_SKELETON_POSITION_HIP_CENTER,         NUI_SKELETON_POSITION_HIP_RIGHT,        INT_BASE,                      },
    {  vHipRightDir,       NUI_SKELETON_POSITION_HIP_RIGHT,          NUI_SKELETON_POSITION_KNEE_RIGHT,       INT_PELVIS_RIGHT,              },
    {  vKneeRightDir,      NUI_SKELETON_POSITION_KNEE_RIGHT,         NUI_SKELETON_POSITION_ANKLE_RIGHT,      INT_HIP_RIGHT,                 },
    {  vAnkleRightDir,     NUI_SKELETON_POSITION_ANKLE_RIGHT,        NUI_SKELETON_POSITION_FOOT_RIGHT,       INT_KNEE_RIGHT,                },
};                                                                                                                  
                                                        

// Mapping from intermediate skeleton to avatar skeleton. The NUI joints are first converted to an intermediate skeleton which holds joint rotations.
// Then the joints are remapped to an avatar skeleton, and converted to the avatar transformation space.  This struct contains the information needed
// to map from the intermediate skeleton to the avatar skeleton.
typedef struct IntermediateToAvatarMap_s
{
    INTERMEDIATE_JOINT_INDEX    m_intJoint;             // Intermediate skeleton joint
    AvatarJointRef              m_avatarJoint;          // Avatar joint corresponding to the intermediate joint
    AvatarJointRef              m_avatarParentJoint;    // Avatar joint parent
} IntermediateToAvatarMap;

const IntermediateToAvatarMap  g_IntermediateToAvatarMap[] =
{
    { INT_BASE,             BASE,  INVALID, },
    { INT_HIP_CENTER,       BACKA, BASE,    },
    { INT_SPINE,            BACKB, BACKA,   },
    { INT_NECK,             NECK,  BACKB,   },
      
    { INT_SHOULDER_RIGHT,   LF_S,  BACKB,   },
    { INT_ELBOW_RIGHT,      LF_E,  LF_S,    },
    { INT_WRIST_RIGHT,      LF_W,  LF_E,    },
      
    { INT_SHOULDER_LEFT,    RT_S,  BACKB,   },
    { INT_ELBOW_LEFT,       RT_E,  RT_S,    },
    { INT_WRIST_LEFT,       RT_W,  RT_E,    },
      
    { INT_HIP_RIGHT,        LF_H,  BASE,    },
    { INT_KNEE_RIGHT,       LF_K,  LF_H,    },
      
    { INT_HIP_LEFT,         RT_H,  BASE,    },
    { INT_KNEE_LEFT,        RT_K,  RT_H,    },
};


//--------------------------------------------------------------------------------------
// Name: NuiJointConverter()
// Desc: Constructor
//--------------------------------------------------------------------------------------
NuiJointConverter::NuiJointConverter( )
{
    Initialize();
}


//--------------------------------------------------------------------------------------
// Name: AddJointConstraint()
// Desc: Adds a joint constraint to the system.  
//--------------------------------------------------------------------------------------
VOID NuiJointConverter::AddJointConstraint(INTERMEDIATE_JOINT_INDEX joint, XMVECTOR vDir, FLOAT fAngle)
{
    m_jointConstraints[m_dwNumJointConstraints].m_intJoint = joint;
    m_jointConstraints[m_dwNumJointConstraints].m_vDir = vDir;
    m_jointConstraints[m_dwNumJointConstraints].m_fAngle = fAngle;

    // Initialize the constraint value to 0.  This tracks the proximity of the joint to the constraint limit
    m_jointConstraints[m_dwNumJointConstraints].m_fConstraint = 0.0f;

    m_dwNumJointConstraints++;
}


//--------------------------------------------------------------------------------------
// Name: AddDefaultConstraints()
// Desc: Adds a set of default joint constraints.  This is a good set of constraints for
//       plausible human biomechanics.
//--------------------------------------------------------------------------------------
VOID NuiJointConverter::AddDefaultConstraints( )
{
    AddJointConstraint( INT_SHOULDER_RIGHT, XMVectorSet(  0.7f,  0.0f,   .7f, 1.0f ),  80.0f );
    AddJointConstraint( INT_SHOULDER_LEFT,  XMVectorSet( -0.7f,  0.0f,   .7f, 1.0f ),  80.0f );

    AddJointConstraint( INT_ELBOW_RIGHT,    XMVectorSet(  0.0f,  0.0f,  1.0f, 1.0f ),  90.0f );
    AddJointConstraint( INT_ELBOW_LEFT,     XMVectorSet(  0.0f,  0.0f,  1.0f, 1.0f ),  90.0f );

    AddJointConstraint( INT_WRIST_RIGHT,    XMVectorSet(  1.0f,  0.0f,  0.0f, 1.0f ),  40.0f );
    AddJointConstraint( INT_WRIST_LEFT,     XMVectorSet( -1.0f,  0.0f,  0.0f, 1.0f ),  40.0f );

    AddJointConstraint( INT_HIP_RIGHT,      XMVectorSet(  0.0f, -1.0f,  1.0f, 1.0f ),  70.0f );
    AddJointConstraint( INT_HIP_LEFT,       XMVectorSet(  0.0f, -1.0f,  1.0f, 1.0f ),  70.0f );

    AddJointConstraint( INT_KNEE_RIGHT,     XMVectorSet(  0.0f, -0.5f, -1.0f, 1.0f ),  60.0f );
    AddJointConstraint( INT_KNEE_LEFT,      XMVectorSet(  0.0f, -0.5f, -1.0f, 1.0f ),  60.0f );

    AddJointConstraint( INT_ANKLE_RIGHT,    XMVectorSet(  0.0f,  0.0f,  1.0f, 1.0f ),  60.0f );
    AddJointConstraint( INT_ANKLE_LEFT,     XMVectorSet(  0.0f,  0.0f,  1.0f, 1.0f ),  60.0f );

    AddJointConstraint( INT_SPINE,          XMVectorSet(  0.0f,  1.0f,  0.0f, 1.0f ),  50.0f );
    AddJointConstraint( INT_HIP_CENTER,     XMVectorSet(  0.0f,  1.0f,  0.3f, 1.0f ),  90.0f );

    AddJointConstraint( INT_NECK,           XMVectorSet(  0.0f,  1.0f,  0.3f, 1.0f ),  40.0f );
}


//--------------------------------------------------------------------------------------
// Name: Initalize()
// Desc: Initialize the skeleton and set to bind pose
//--------------------------------------------------------------------------------------
VOID NuiJointConverter::Initialize( )
{
    m_dwNumJointConstraints = 0;

    // Set the scale factor to mirror Z by default.  This puts the skeleton facing the
    // viewer as if the viewer were looking at a mirror.
    m_vJointScaleFactor = XMVectorSet( 1, 1, -1, 0);  
    
    ZeroMemory( &m_NuiSkeleton, sizeof(NUI_SKELETON_DATA) );

    for( DWORD i = 0; i < ARRAYSIZE( m_qBindPose ); ++i )
    {
        m_qBindPose[i] = XMQuaternionIdentity();
    }

    for( DWORD i = 0; i < ARRAYSIZE(m_IntJoints); ++i )
    {
        m_IntJoints[i].doubleExponentialFilter.m_qFilteredLocal = XMQuaternionIdentity();
        m_IntJoints[i].doubleExponentialFilter.m_qTrend = XMQuaternionIdentity();
        m_IntJoints[i].doubleExponentialFilter.m_uStarted = 0;
        m_PreviousIntJoints[i].doubleExponentialFilter.m_qFilteredLocal = XMQuaternionIdentity();
        m_PreviousIntJoints[i].doubleExponentialFilter.m_qTrend = XMQuaternionIdentity();
        m_PreviousIntJoints[i].doubleExponentialFilter.m_uStarted = 0;
    }
}


//--------------------------------------------------------------------------------------
// Name: ConvertCameraToAvatarSkeleton()
// Desc: Entry point for skeleton conversion.  Updates the skeleton to the current frame
//       and converts to Avatar format
//--------------------------------------------------------------------------------------
VOID NuiJointConverter::ConvertNuiToAvatarSkeleton( const NUI_SKELETON_DATA* pNuiSkeleton, XAVATAR_SKELETON_POSE_JOINT* pAvatarJoints )
{
    ConvertNuiJoints( pNuiSkeleton, FALSE );

    if( pAvatarJoints != NULL )
    {
        // Initialize rotations to zero
        XMVECTOR VIdentity = XMQuaternionIdentity();		// 0,0,0,1
        XMVECTOR VOne = XMVectorSplatOne();					// 1,1,1,1
        for ( INT j = 0; j < XAVATAR_MAX_SKELETON_JOINTS; ++j )
        {
            pAvatarJoints[ j ].Position = VIdentity;
            pAvatarJoints[ j ].Rotation = VIdentity;
            pAvatarJoints[ j ].Scale = VOne;
        }
        GetAvatarRotations( pAvatarJoints );
    }
}


//--------------------------------------------------------------------------------------
// Name: ConvertNuiJoints()
// Desc: Entry point for skeleton conversion, if avatar joint creation is not desired.
//       Performs optional joint orientation smoothing before applying constraints.
//--------------------------------------------------------------------------------------
VOID NuiJointConverter::ConvertNuiJoints( const NUI_SKELETON_DATA* pNuiSkeleton, BOOL bFilterJointOrientations )
{
    SetSkeleton( pNuiSkeleton );
    Update( bFilterJointOrientations );
}


//--------------------------------------------------------------------------------------
// Name: SetSkeleton()
// Desc: Set the local copy of the skeleton data
//--------------------------------------------------------------------------------------
VOID NuiJointConverter::SetSkeleton( const NUI_SKELETON_DATA* pSkeleton )
{
    XMemCpy( &m_NuiSkeleton, pSkeleton, sizeof(NUI_SKELETON_DATA ) );
}


//--------------------------------------------------------------------------------------
// Name: QuaternionAngle
// Desc: Returns the amount of rotation in the given quaternion, in radians.
//--------------------------------------------------------------------------------------
inline FLOAT QuaternionAngle( XMVECTOR qRotation )
{
    XMVECTOR vAxis;
    FLOAT fAngle;
    XMQuaternionToAxisAngle( &vAxis, &fAngle, XMQuaternionNormalize( qRotation ) );
    return fAngle;
}


//--------------------------------------------------------------------------------------
// Name: EnsureQuaternionNeighborhood
// Desc: Ensures that quaternions qA and qB are in the same 3D sphere in 4D space.
//--------------------------------------------------------------------------------------
inline VOID EnsureQuaternionNeighborhood( const XMVECTOR& qA, XMVECTOR& qB )
{
    if( XMVectorGetX( XMQuaternionDot( qA, qB ) ) < 0 )
    {
        // Negate the second quaternion, to place it in the opposite 3D sphere.
        qB = -qB;
    }
}


//--------------------------------------------------------------------------------------
// Name: RotationBetweenQuaternions
// Desc: Returns a quaternion that represents a rotation qR such that qA * qR = qB.
//--------------------------------------------------------------------------------------
inline XMVECTOR RotationBetweenQuaternions( XMVECTOR qA, XMVECTOR qB )
{
    EnsureQuaternionNeighborhood( qA, qB );
    return XMQuaternionMultiply( XMQuaternionInverse( qA ), qB );
}


//--------------------------------------------------------------------------------------
// Name: EnhancedQuaternionSlerp
// Desc: Performs a quaternion slerp, after placing both input quaternions in the same
//       3D sphere.
//--------------------------------------------------------------------------------------
inline XMVECTOR EnhancedQuaternionSlerp( XMVECTOR qA, XMVECTOR qB, FLOAT T )
{
    EnsureQuaternionNeighborhood( qA, qB );
    return XMQuaternionSlerp( qA, qB, T );
}


//--------------------------------------------------------------------------------------
// Name: DoubleExponentialJointOrientationFilter
// Desc: Implements a double exponential smoothing filter on the skeleton joint orientation
//       quaternions.
//--------------------------------------------------------------------------------------
VOID NuiJointConverter::DoubleExponentialJointOrientationFilter()
{
    static FLOAT fSmoothing      = 0.75f;        // [0..1], lower values is closer to the raw data and more noisy
    static FLOAT fCorrection     = 0.75f;        // [0..1], higher values correct faster and feel more responsive
    static FLOAT fPrediction     = 0.75f;       // [0..n], how many frames into the future we want to predict
    static FLOAT fJitterRadius   = 0.10f;       // The deviation angle in radians that defines jitter
    static FLOAT fMaxDeviationRadius = 0.10f;   // The maximum angle in radians that filtered positions are allowed to deviate from raw data

    XMVECTOR qPrevRawOrientation;
    XMVECTOR qPrevFilteredOrientation;
    XMVECTOR qPrevTrend;
    XMVECTOR qRawOrientation;
    XMVECTOR qFilteredOrientation;
    XMVECTOR qPredictedOrientation;
    XMVECTOR qDiff;
    XMVECTOR qTrend;
    FLOAT fDiff;
    BOOL bOrientationIsValid;

    for (INT i = 0; i < ARRAYSIZE(m_IntJoints); i++)
    {
        qRawOrientation             = m_IntJoints[i].quatLocal;
        qPrevFilteredOrientation    = m_PreviousIntJoints[i].doubleExponentialFilter.m_qFilteredLocal;
        qPrevTrend                  = m_PreviousIntJoints[i].doubleExponentialFilter.m_qTrend;
        bOrientationIsValid         = TRUE;

        if (!bOrientationIsValid)
        {
            m_IntJoints[i].doubleExponentialFilter.m_uStarted = 0;
        }

        // Initial start values or reset values
        if (m_IntJoints[i].doubleExponentialFilter.m_uStarted == 0)
        {
            // Use raw position and zero trend for first value
            qFilteredOrientation = qRawOrientation;
            qTrend = XMQuaternionIdentity();
            m_IntJoints[i].doubleExponentialFilter.m_uStarted++;
        }
        else if (m_IntJoints[i].doubleExponentialFilter.m_uStarted == 1)
        {
            // Use average of two positions and calculate proper trend for end value
            qPrevRawOrientation = m_PreviousIntJoints[i].quatLocal;
            qFilteredOrientation = EnhancedQuaternionSlerp( qPrevRawOrientation, qRawOrientation, 0.5f );
            qDiff = RotationBetweenQuaternions( qFilteredOrientation, qPrevFilteredOrientation );
            qTrend = EnhancedQuaternionSlerp( qPrevTrend, qDiff, fCorrection );
            m_IntJoints[i].doubleExponentialFilter.m_uStarted++;
        }
        else
        {
            // First apply a jitter filter
            qDiff = RotationBetweenQuaternions( qRawOrientation, qPrevFilteredOrientation );
            fDiff = fabs( QuaternionAngle( qDiff ) );

            if (fDiff <= fJitterRadius)
            {
                qFilteredOrientation = EnhancedQuaternionSlerp( qPrevFilteredOrientation, qRawOrientation, fDiff / fJitterRadius );
            }
            else
            {
                qFilteredOrientation = qRawOrientation;
            }

            // Now the double exponential smoothing filter
            qFilteredOrientation = EnhancedQuaternionSlerp( qFilteredOrientation, XMQuaternionMultiply( qPrevFilteredOrientation, qPrevTrend ), fSmoothing );

            qDiff = RotationBetweenQuaternions( qFilteredOrientation, qPrevFilteredOrientation );
            qTrend = EnhancedQuaternionSlerp( qPrevTrend, qDiff, fCorrection );
        }      

        // Use the trend and predict into the future to reduce latency
        qPredictedOrientation = XMQuaternionMultiply( qFilteredOrientation, EnhancedQuaternionSlerp( XMQuaternionIdentity(), qTrend, fPrediction ) );

        // Check that we are not too far away from raw data
        qDiff = RotationBetweenQuaternions( qPredictedOrientation, qFilteredOrientation );
        fDiff = fabs( QuaternionAngle( qDiff ) );

        if (fDiff > fMaxDeviationRadius)
        {
            qPredictedOrientation = EnhancedQuaternionSlerp( qFilteredOrientation, qPredictedOrientation, fMaxDeviationRadius / fDiff );
        }

        qPredictedOrientation = XMQuaternionNormalize( qPredictedOrientation );
        qFilteredOrientation = XMQuaternionNormalize( qFilteredOrientation );

        // Store current values
        m_IntJoints[i].doubleExponentialFilter.m_qFilteredLocal = qFilteredOrientation;
        m_IntJoints[i].doubleExponentialFilter.m_qTrend = qTrend;

        // Apply predicted orientation to joint
        m_IntJoints[i].quatLocal = qPredictedOrientation;
        XMVECTOR qParentRot = XMQuaternionIdentity();
        if( g_IntJointDesc[i].parentIdx != -1 )
        {
            qParentRot = m_IntJoints[g_IntJointDesc[i].parentIdx].quatWorld;
        }
        m_IntJoints[i].quatWorld = XMQuaternionMultiply( qParentRot, m_IntJoints[i].quatLocal );
    }
}


//--------------------------------------------------------------------------------------
// Name: Update()
// Desc: Update the skeleton with the latest skeleton data.  
//
//       1. Apply filter(s)
//       2. Convert the positions to our coordinate system
//       3. Calculate joint rotations from the positional data
//--------------------------------------------------------------------------------------
VOID NuiJointConverter::Update( BOOL bEnableJointOrientationFilter )
{
    // Perform collision detection
    CollideSkeleton( &m_NuiSkeleton );

    // Convert coordinates to our system
    ScaleJoints();

    // Calculate joint rotations from joint positions
    CalculateJointRotations();

    // Apply orientation smoothing filter
    if( bEnableJointOrientationFilter )
    {
        DoubleExponentialJointOrientationFilter();
    }

    // Calculate the constraints
    ApplyJointConstraints();

    // Save joint orientations for use next frame in the filter
    if( bEnableJointOrientationFilter )
    {
        XMemCpy( &m_PreviousIntJoints, &m_IntJoints, sizeof( m_IntJoints ) );
    }
}


//--------------------------------------------------------------------------------------
// Name: DistanceToLineSegment()
// Desc: find the distance from a point to a line.  Return the normal for offset use.
//
//--------------------------------------------------------------------------------------
VOID NuiJointConverter::DistanceToLineSegment(XMVECTOR x0, XMVECTOR x1, XMVECTOR p, float* distance, XMVECTOR* normal) const
{
    // find the vector from x0 to x1
    XMVECTOR vLine = x1 - x0;
    XMVECTOR vLineLength = XMVector3Length( vLine );
    FLOAT fLineLength = XMVectorGetX( vLineLength );
    XMVECTOR vLineToPoint = p - x0;

    const FLOAT epsilon = 0.0001f;
    // if the line is too short skip
    if( fLineLength > epsilon )
    {
        FLOAT t = XMVectorGetX( XMVector3Dot(vLine, vLineToPoint) ) / fLineLength;
        
        // projection is longer than the line itself so find distance to end point of line
        if( t > fLineLength )
        {
            vLineToPoint = p - x1;
        }
        // find distance to line
        else if(t >= 0.0f) 
        {
            XMVECTOR vNormalPoint = vLine;
			
            // Perform the float->vector conversion once by combining t/fLineLength
            vNormalPoint *= (t/fLineLength);
            vNormalPoint += x0;
            vLineToPoint = p - vNormalPoint;
        }
    }
    
    // The distance is the size ofthe final computed line
    XMVECTOR vVecLength = XMVector3Length( vLineToPoint );
    *distance = XMVectorGetX(vVecLength);
    
    // The normal is the final line normalized
    *normal = vLineToPoint / (*distance);
}


//--------------------------------------------------------------------------------------
// Name: CollideSkeleton()
// Desc: Keep the skeleton's hands and wrists from puncturing its body.
//
//--------------------------------------------------------------------------------------
VOID NuiJointConverter::CollideSkeleton( NUI_SKELETON_DATA* pSkeleton )
{
    
    const FLOAT ShoulderExtend = 0.5f;
    const FLOAT HipExtend = 6.0f;
    const FLOAT CollisionTolerance = 1.01f;

    if (pSkeleton->eSkeletonPositionTrackingState[NUI_SKELETON_POSITION_SHOULDER_CENTER] != NUI_SKELETON_POSITION_NOT_TRACKED
        && pSkeleton->eSkeletonPositionTrackingState[NUI_SKELETON_POSITION_HIP_CENTER] != NUI_SKELETON_POSITION_NOT_TRACKED )
    {
        XMVECTOR vLShoulderDiff =  pSkeleton->SkeletonPositions[NUI_SKELETON_POSITION_SHOULDER_LEFT] - 
            pSkeleton->SkeletonPositions[NUI_SKELETON_POSITION_SHOULDER_CENTER];
        XMVECTOR vLShoulderLength = XMVector3Length( vLShoulderDiff );
        XMVECTOR vRShoulderDiff =  pSkeleton->SkeletonPositions[NUI_SKELETON_POSITION_SHOULDER_RIGHT] - 
            pSkeleton->SkeletonPositions[NUI_SKELETON_POSITION_SHOULDER_CENTER];
        XMVECTOR vRShoulderLength = XMVector3Length( vRShoulderDiff );
        // The distance beween shoulders is averaged for the radius
        float cylinderRadius = ( XMVectorGetX(vLShoulderLength) + XMVectorGetX(vRShoulderLength) ) * 0.5f;
        
        // Calculate the shoulder center and the hip center.  Extend them up and down respectively.
        XMVECTOR vShoulderCenter = pSkeleton->SkeletonPositions[NUI_SKELETON_POSITION_SHOULDER_CENTER];
        XMVECTOR vHipCenter = pSkeleton->SkeletonPositions[NUI_SKELETON_POSITION_HIP_CENTER];
        XMVECTOR vHipShoulder = vHipCenter - vShoulderCenter;
        XMVECTOR vHipShoulderNormalized = XMVector3Normalize( vHipShoulder );
        vShoulderCenter = vShoulderCenter - ( vHipShoulderNormalized * ( ShoulderExtend * cylinderRadius ) );
        vHipCenter = vHipCenter + ( vHipShoulderNormalized * ( HipExtend * cylinderRadius ) );
        
        // Increse radius to account for bulky avatars
        cylinderRadius *= 1.5f;
       
        // joints to collide
        static const INT collisionIndices[] = { NUI_SKELETON_POSITION_WRIST_LEFT, NUI_SKELETON_POSITION_HAND_LEFT, 
            NUI_SKELETON_POSITION_WRIST_RIGHT, NUI_SKELETON_POSITION_HAND_RIGHT };
        
        for(INT i=0; i<ARRAYSIZE(collisionIndices); i++)
        {
            XMVECTOR vCollisionJoint = pSkeleton->SkeletonPositions[collisionIndices[i]];
            float distance;
            XMVECTOR normal;
            DistanceToLineSegment( vShoulderCenter, vHipCenter, vCollisionJoint, &distance, &normal);
            // if distance is within the cylinder then push the joint out and away from the cylinder
            if( distance < cylinderRadius )
            {
                XMVECTOR vMoveJointAmount = normal;
                vMoveJointAmount *= ((cylinderRadius - distance) * CollisionTolerance);
                vCollisionJoint += normal * ((cylinderRadius - distance) * CollisionTolerance);
                pSkeleton->SkeletonPositions[collisionIndices[i]] = vCollisionJoint;
            }
        }
    }
}


//--------------------------------------------------------------------------------------
// Name: ScaleJoints()
// Desc: Scale the joints.  A negative scale factor can be used to flip the coordinate system or mirror joints.
//--------------------------------------------------------------------------------------
VOID NuiJointConverter::ScaleJoints( )
{
    for( INT nJoint = 0; nJoint < NUI_SKELETON_POSITION_COUNT; ++nJoint )
    {
        m_NuiSkeleton.SkeletonPositions[nJoint] = XMVectorMultiply( m_NuiSkeleton.SkeletonPositions[ nJoint ], m_vJointScaleFactor );
    }
}


//--------------------------------------------------------------------------------------
// Name: CalculateJointRotations()
// Desc: Calculate joint rotations from joint positions. This function assumes that the 
//       bind pose is in a particular configuration (each joint in the bind pose aligns
//       with an axis).  It would be more correct to sync the bind pose with the user.
//--------------------------------------------------------------------------------------
VOID NuiJointConverter::CalculateJointRotations()
{
    // Initialize quaternions to identity
    for( INT i = 0; i < INTERMEDIATE_JOINT_COUNT; ++i)
    {
        m_IntJoints[i].quatWorld = XMQuaternionIdentity();
    }

    // Calculate hip direction and assign it to the base joint
    XMVECTOR hipDir = XMVectorSubtract(  m_NuiSkeleton.SkeletonPositions[ NUI_SKELETON_POSITION_HIP_RIGHT ], 
                                         m_NuiSkeleton.SkeletonPositions[ NUI_SKELETON_POSITION_HIP_LEFT ] ); 
    hipDir.y = 0;
    hipDir = XMVector3Normalize(hipDir);
    XMVECTOR hipRot = GetShortestRotationBetweenVecs( hipDir, XMVectorSet(1.0f, 0.0f, 0.0f, 0.0f) );

    m_IntJoints[ INT_BASE ].quatLocal = hipRot;
    m_IntJoints[ INT_BASE ].quatWorld = hipRot;

    // Get the rotations from the orientation of the bone
    for( int i = 0; i < ARRAYSIZE( m_IntJoints ); ++i )
    {
        if( g_IntJointDesc[i].startNuiJoint == -1 )
        {
            continue;
        }

        XMVECTOR qParentRot;
        if( g_IntJointDesc[i].parentIdx == -1 )
        {
            qParentRot = XMQuaternionIdentity();
        }
        else
        {
            qParentRot = m_IntJoints[g_IntJointDesc[i].parentIdx].quatWorld;
        }

        XMMATRIX matParentRot = XMMatrixRotationQuaternion( qParentRot );

        if( m_NuiSkeleton.eSkeletonPositionTrackingState[ g_IntJointDesc[i].endNuiJoint] == NUI_SKELETON_POSITION_NOT_TRACKED ||
            m_NuiSkeleton.eSkeletonPositionTrackingState[ g_IntJointDesc[i].startNuiJoint] == NUI_SKELETON_POSITION_NOT_TRACKED )
        {
            m_IntJoints[ i ].eTrackingState = NUI_SKELETON_POSITION_NOT_TRACKED;
        }
        else if( m_NuiSkeleton.eSkeletonPositionTrackingState[ g_IntJointDesc[i].endNuiJoint] == NUI_SKELETON_POSITION_INFERRED ||
                 m_NuiSkeleton.eSkeletonPositionTrackingState[ g_IntJointDesc[i].startNuiJoint] == NUI_SKELETON_POSITION_INFERRED )
        {
            m_IntJoints[ i ].eTrackingState = NUI_SKELETON_POSITION_INFERRED;
        }
        else
        {
            m_IntJoints[ i ].eTrackingState = NUI_SKELETON_POSITION_TRACKED;
        }

        if( m_IntJoints[ i ].eTrackingState == NUI_SKELETON_POSITION_NOT_TRACKED )
        {
            m_IntJoints[ i ].quatLocal = XMQuaternionIdentity();
        }
        else
        {
            // Calculate the local rotation based on the vector from the joint to its child.
            XMVECTOR vDir = XMVectorSubtract( m_NuiSkeleton.SkeletonPositions[ g_IntJointDesc[i].endNuiJoint ],
                                              m_NuiSkeleton.SkeletonPositions[ g_IntJointDesc[i].startNuiJoint ] );
            vDir = XMVector3Normalize( vDir );

            // Transform the direction of the NUI bone into local space so that it can be compared to the local bind pose direction
            vDir = XMVector3Transform( vDir, XMMatrixRotationQuaternion(XMQuaternionInverse( XMQuaternionMultiply( m_qBindPose[i], qParentRot ) ) ) );

            // Find the rotation between the skeleton's direction and the desired bone direction.  This is the joint's local rotation.
            XMVECTOR qRot = GetShortestRotationBetweenVecs( vDir,  g_IntJointDesc[i].vBoneDir );
            m_IntJoints[ i ].quatLocal = XMQuaternionNormalize( qRot );

            // Rebuild the world transform.  World = Parent * BindPose * Local
            m_IntJoints[i].quatWorld = XMQuaternionMultiply(m_IntJoints[i].quatLocal, XMQuaternionMultiply( m_qBindPose[i], qParentRot ) );
        }

        // Convert local rotation to world space
        m_IntJoints[i].quatWorld = XMQuaternionMultiply(m_IntJoints[i].quatLocal, XMQuaternionMultiply( m_qBindPose[i], qParentRot ) );
    }
}


//--------------------------------------------------------------------------------------
// Name: ApplyJointConstraints()
// Desc: Determine joint constraints and constrain rotations.
//--------------------------------------------------------------------------------------
VOID NuiJointConverter::ApplyJointConstraints()
{
    // Calculate constraint values.  0.0-1.0 means the bone is within the constraint cone.  Greater than 1.0 means 
    // it lies outside the constraint cone.
    for( DWORD i = 0; i < m_dwNumJointConstraints; i++)
    {
        // Get the constraint direction in world space
        XMVECTOR quatConstraintLocalToWorld;
        quatConstraintLocalToWorld = m_IntJoints[g_IntJointDesc[m_jointConstraints[i].m_intJoint].parentIdx].quatWorld;
        XMMATRIX matConstraintLocalToWorld = XMMatrixRotationQuaternion( quatConstraintLocalToWorld );

        XMVECTOR constraintDirWS;
        constraintDirWS = XMVector3Normalize( m_jointConstraints[i].m_vDir );
        constraintDirWS = XMVector4Transform( constraintDirWS, matConstraintLocalToWorld );
        
        // Get the bone direction in world space
        XMVECTOR boneJoints[2];
        boneJoints[0] = GetNuiSkeletonJointPos( g_IntJointDesc[m_jointConstraints[i].m_intJoint].startNuiJoint );
        boneJoints[1] = GetNuiSkeletonJointPos( g_IntJointDesc[m_jointConstraints[i].m_intJoint].endNuiJoint );

        XMVECTOR boneDirWS = boneJoints[1] - boneJoints[0];
        boneDirWS = XMVector3Normalize( boneDirWS );

        // Calculate the constraint value.  0.0 is in the center of the constraint cone, 1.0 and above are outside the cone.
        FLOAT cosConstraintAngle = cosf( XMConvertToRadians( m_jointConstraints[i].m_fAngle ) );
        FLOAT boneDot = XMVector3Dot(constraintDirWS, boneDirWS).x;

        m_jointConstraints[i].m_fConstraint = (1.0f - boneDot)/(1.0f - cosConstraintAngle);
    }

    // Calculate bone lengths and local space bone vectors
    for(int i = 0; i < ARRAYSIZE(m_IntJoints); i++)
    {
        // Get a vector from the start joint to the end joint.
        XMVECTOR vJointPos[2];
        vJointPos[0] = GetNuiSkeletonJointPos( g_IntJointDesc[i].startNuiJoint );
        vJointPos[1] = GetNuiSkeletonJointPos( g_IntJointDesc[i].endNuiJoint );
        XMVECTOR vBoneVectorWS = vJointPos[1] - vJointPos[0];

        // Calculate the length of the bone vector
        m_IntJoints[i].fBoneLength = XMVector3Length( vBoneVectorWS ).x;
        
        // Transform the bone vector to local space
        XMVECTOR quatLocalToWorld = m_IntJoints[g_IntJointDesc[i].parentIdx].quatWorld;
        XMMATRIX matWorldToLocal;
        matWorldToLocal = XMMatrixRotationQuaternion( XMQuaternionInverse( quatLocalToWorld ) );

        m_IntJoints[i].vBoneVectorLS = XMVector4Transform( vBoneVectorWS, matWorldToLocal );
    }

    for( UINT nJointConstraintIdx = 0; nJointConstraintIdx < m_dwNumJointConstraints; nJointConstraintIdx++ )
    {
        // If the joint has a parent, constrain the bone direction to be within the constraint cone
        INT nIntJointIdx = m_jointConstraints[nJointConstraintIdx].m_intJoint;
        NUI_SKELETON_POSITION_INDEX parentIdx = g_IntJointDesc[ nIntJointIdx ].startNuiJoint;
        if( parentIdx != (NUI_SKELETON_POSITION_INDEX)(-1) )
        {
            XMVECTOR vParentPos = XMVectorZero();
            vParentPos = GetNuiSkeletonJointPos( parentIdx );
        
            XMMATRIX matTransform;
            XMVECTOR quatParentLStoWS;
            quatParentLStoWS = m_IntJoints[ g_IntJointDesc[nIntJointIdx].parentIdx ].quatWorld;

            // If the bone lies outside the constraint
            if( nJointConstraintIdx != -1 && 
                m_jointConstraints[nJointConstraintIdx].m_fConstraint > 1.0f )
            {
                // Transform bone vector to world space
                XMVECTOR quatBoneLStoWS;
                quatBoneLStoWS = m_IntJoints[g_IntJointDesc[nIntJointIdx].parentIdx].quatWorld;
                XMMATRIX matBoneLStoWS = XMMatrixRotationQuaternion( quatBoneLStoWS );
                XMVECTOR vBoneVecWS = XMVector4Transform( m_IntJoints[nIntJointIdx].vBoneVectorLS, matBoneLStoWS );
                if( m_IntJoints[nIntJointIdx].eTrackingState == NUI_SKELETON_POSITION_NOT_TRACKED ||
                    XMVector3LengthSq( vBoneVecWS ).x  < .001f )
                {
                    m_IntJoints[ nIntJointIdx ].quatLocal = XMQuaternionIdentity();
                }
                else
                {
                    // Transform constraint axis to world space
                    XMVECTOR quatConstraintLStoWS;
                    quatConstraintLStoWS = m_IntJoints[g_IntJointDesc[nIntJointIdx].parentIdx].quatWorld;
                    XMMATRIX matConstraintLStoWS = XMMatrixRotationQuaternion( quatConstraintLStoWS );

                    XMVECTOR vConstraintAxisWS = XMVector4Transform( m_jointConstraints[ nJointConstraintIdx ].m_vDir, matConstraintLStoWS );

                    // Calculate the axis of rotation between the constraint axis and the bone direction
                    XMVECTOR vRotAxis = XMVector3Cross( vConstraintAxisWS, vBoneVecWS  );
                    vRotAxis = XMVector3Normalize(vRotAxis);
                    
                    // Rotate the constraint axis to the edge of the cone in the direction of the original bone.  
                    XMMATRIX matConstrainedRot = XMMatrixRotationAxis( vRotAxis, XMConvertToRadians( m_jointConstraints[nJointConstraintIdx].m_fAngle ) );
                    XMVECTOR vConstrainedVecWS = XMVector4Transform( vConstraintAxisWS, matConstrainedRot );
                    vConstrainedVecWS = XMVector3Normalize( vConstrainedVecWS );

                    // Create the joint local space and world space rotations from the constrained direction

                    // Transform the bind pose direction into the parent's world space
                    XMMATRIX matParentRot;
                    if( g_IntJointDesc[nIntJointIdx].parentIdx == -1 )
                    {
                        matParentRot = XMMatrixIdentity();
                    }
                    else
                    {
                        matParentRot = XMMatrixRotationQuaternion( m_IntJoints[g_IntJointDesc[nIntJointIdx].parentIdx].quatWorld );
                    }

                    XMVECTOR vBoneDir = XMVector3Transform( g_IntJointDesc[ nIntJointIdx ].vBoneDir, matParentRot );

                    m_IntJoints[ nIntJointIdx ].quatLocal = GetShortestRotationBetweenVecs( vConstrainedVecWS, vBoneDir );
                    m_IntJoints[ nIntJointIdx ].quatLocal = XMQuaternionNormalize( m_IntJoints[ nIntJointIdx ].quatLocal );
                }
            }
        }
    }

    m_vReconstructedPos[ NUI_SKELETON_POSITION_HIP_CENTER ] = GetNuiSkeletonJointPos( NUI_SKELETON_POSITION_HIP_CENTER );

    // Recalculate world space rotations
    for(int i = 0; i < ARRAYSIZE(g_IntJointDesc); i++)
    {
        if( g_IntJointDesc[i].parentIdx < 0 )
        {
            m_IntJoints[i].quatWorld = m_IntJoints[i].quatLocal;
        }
        else
        {
            // Calculate joint positions based on the constrained skeleton
            XMMATRIX matTransform = XMMatrixRotationQuaternion( m_IntJoints[ i ].quatWorld );

            XMVECTOR vOffset = XMVector3Normalize(g_IntJointDesc[i].vBoneDir) * m_IntJoints[i].fBoneLength;
            vOffset = XMVector4Transform( vOffset, matTransform);

            assert( g_IntJointDesc[i].endNuiJoint >= 0  && g_IntJointDesc[i].startNuiJoint >= 0 );
            m_vReconstructedPos[ g_IntJointDesc[i].endNuiJoint] = m_vReconstructedPos[ g_IntJointDesc[i].startNuiJoint ] + vOffset;
        }
    }
}


//--------------------------------------------------------------------------------------
// Name: DrawSkeleton()
// Desc: Debug rendering of skeleton
//--------------------------------------------------------------------------------------
VOID NuiJointConverter::DrawSkeleton( D3DDevice* pd3dDevice, XMMATRIX matWVP ) const
{
    static FLOAT PointSize = 7.0f;
    pd3dDevice->SetRenderState( D3DRS_POINTSIZE, *((DWORD*)&PointSize));
    pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE);

    static XMVECTOR verts[2];

    ATG::SimpleShaders::SetDeclPos();

    pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE);
    pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE);
    pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE);

    PIXBeginNamedEvent( 0, "Joint Constraint Skeleton");
    
    for( DWORD i = 0; i < m_dwNumJointConstraints; i++)
    {
        XMVECTOR vert;
        XMVECTOR quat;
        vert = GetNuiSkeletonJointPos( g_IntJointDesc[m_jointConstraints[i].m_intJoint].startNuiJoint );
        quat = m_IntJoints[g_IntJointDesc[m_jointConstraints[i].m_intJoint].parentIdx].quatWorld;

        XMMATRIX constraintMat = XMMatrixRotationQuaternion(quat);
        XMVECTOR dir;
        dir = XMVector3Normalize( m_jointConstraints[i].m_vDir );
        dir = XMVector4Transform( dir, constraintMat );

        // Draw the cone of the constraint
        static FLOAT coneLength = .08f;
        FLOAT coneHeight = coneLength * cosf( XMConvertToRadians( m_jointConstraints[i].m_fAngle) );
        FLOAT coneRadius = coneLength * sinf( XMConvertToRadians( m_jointConstraints[i].m_fAngle) );
        
        dir = dir * coneHeight;

        XMFLOAT3 coneDir;
        XMFLOAT3 centerBase;
        XMStoreVector3( &coneDir, dir );
        XMStoreVector3( &centerBase, vert);

        ATG::DebugDraw::SetViewProjection( matWVP );

        static FLOAT LineWidth = 1.0f;
        pd3dDevice->SetRenderState( D3DRS_LINEWIDTH, *((DWORD*)&LineWidth));

        ATG::DebugDraw::DrawConeWireframe( centerBase, coneDir, 0.0f, coneRadius, D3DCOLOR_ARGB(255,255,255,255));
    }

    // Draw bones
    static float fLineWidth = 1.0f;
    pd3dDevice->SetRenderState( D3DRS_LINEWIDTH, *((DWORD*)&fLineWidth));
    for( DWORD j = 0; j < ARRAYSIZE( g_IntJointDesc ); j++)
    {
        if( g_IntJointDesc[j].startNuiJoint == -1 )
            continue;

        verts[0] = GetNuiSkeletonJointPos( g_IntJointDesc[j].startNuiJoint );
        verts[1] = GetNuiSkeletonJointPos( g_IntJointDesc[j].endNuiJoint );
        XMFLOAT3 verts2[2];
        XMStoreVector3(&verts2[0],verts[0]);
        XMStoreVector3(&verts2[1],verts[1]);

        static FLOAT nearZ = -2.0f;
        static FLOAT farZ= -1.7f;
        FLOAT depth = ( verts[0].z - nearZ ) / (farZ - nearZ);
        if( depth > 1.0f) depth = 1.0f;
        if( depth < 0.0f) depth = 0.0f;

        D3DCOLOR boneColor = D3DCOLOR_ARGB(255,(INT)(depth * 87),(INT)(depth * 154),168);

        // Draw bones as red if they are outside the constraint cone.
        for( DWORD i = 0; i < m_dwNumJointConstraints; i++)
        {
            if( m_jointConstraints[i].m_intJoint == (INTERMEDIATE_JOINT_INDEX)j &&
                m_jointConstraints[i].m_fConstraint > 1.0f )
            {
                boneColor = D3DCOLOR_ARGB(255,255,0,0);
            }
        }

        ATG::SimpleShaders::BeginShader_Transformed_ConstantColor( matWVP, boneColor );

        pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, ( const VOID* )verts2, sizeof( XMFLOAT3 ) );
        ATG::SimpleShaders::EndShader();

        // Draw reconstructed bones
        ATG::SimpleShaders::BeginShader_Transformed_ConstantColor( matWVP, D3DCOLOR_ARGB(255,255,255,255));
        XMStoreVector3(&verts2[0],m_vReconstructedPos[g_IntJointDesc[j].startNuiJoint]);
        XMStoreVector3(&verts2[1],m_vReconstructedPos[g_IntJointDesc[j].endNuiJoint]);

        pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, ( const VOID* )verts2, sizeof( XMFLOAT3 ) );

        ATG::SimpleShaders::EndShader();
    }

    // Draw joints and X, Y, and Z axes
    for(DWORD j = 0; j < INTERMEDIATE_JOINT_COUNT; ++j)
    {
        XMVECTOR quat;
        quat = m_IntJoints[j].quatWorld;
        verts[0] = GetNuiSkeletonJointPos( g_IntJointDesc[j].endNuiJoint );
    
        ATG::SimpleShaders::BeginShader_Transformed_ConstantColor( matWVP, D3DCOLOR_ARGB(255,139,29,22));
        pd3dDevice->DrawPrimitiveUP( D3DPT_POINTLIST, 1, verts, sizeof(XMVECTOR) );
        ATG::SimpleShaders::EndShader();

        XMVECTOR vXAxis, vYAxis, vZAxis;
        static FLOAT fAxisSize = .08f;
        vXAxis = XMVectorSet( fAxisSize, 0.0f, 0.0f, 1.0f );
        vYAxis = XMVectorSet( 0.0f, fAxisSize, 0.0f, 1.0f );
        vZAxis = XMVectorSet( 0.0f, 0.0f, fAxisSize, 1.0f );

        XMMATRIX rotation = XMMatrixRotationQuaternion( quat );
        vXAxis = XMVector4Transform(vXAxis, rotation);
        vYAxis = XMVector4Transform(vYAxis, rotation);
        vZAxis = XMVector4Transform(vZAxis, rotation);
    
        fLineWidth = 1.0f;
        pd3dDevice->SetRenderState( D3DRS_LINEWIDTH, *((DWORD*)&fLineWidth));

        verts[1] = verts[0] + vXAxis;
        ATG::SimpleShaders::BeginShader_Transformed_ConstantColor( matWVP, D3DCOLOR_ARGB(255,255,0,0));
        pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, verts, sizeof(XMVECTOR) );
        ATG::SimpleShaders::EndShader();

        verts[1] = verts[0] + vYAxis;
        ATG::SimpleShaders::BeginShader_Transformed_ConstantColor( matWVP, D3DCOLOR_ARGB(255,0,255,0));
        pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, verts, sizeof(XMVECTOR) );
        ATG::SimpleShaders::EndShader();

        verts[1] = verts[0] + vZAxis;
        ATG::SimpleShaders::BeginShader_Transformed_ConstantColor( matWVP, D3DCOLOR_ARGB(255,0,0,255));
        pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, verts, sizeof(XMVECTOR) );
        ATG::SimpleShaders::EndShader();

    }

    PIXEndNamedEvent();
}


//--------------------------------------------------------------------------------------
// Name: GetNuiSkeletonJointPos()
// Desc: Returns the joint data for a particular joint
//--------------------------------------------------------------------------------------
XMVECTOR NuiJointConverter::GetNuiSkeletonJointPos( NUI_SKELETON_POSITION_INDEX	jointName  ) const
{
    return m_NuiSkeleton.SkeletonPositions[ jointName ];
}


//--------------------------------------------------------------------------------------
// Name: GetNuiSkeleton()
// Desc: Returns the joint data for a particular joint
//--------------------------------------------------------------------------------------
VOID NuiJointConverter::GetNuiSkeletonData( NUI_SKELETON_DATA*	pResult ) const
{
    assert( pResult != NULL );
    XMemCpy( pResult, &m_NuiSkeleton, sizeof( NUI_SKELETON_DATA ));
    for(UINT i = 0; i < NUI_SKELETON_POSITION_COUNT; i++)
    {
        pResult->SkeletonPositions[i] = m_vReconstructedPos[i];
        pResult->SkeletonPositions[i].z *= -1.0f;
    }
}
    
//--------------------------------------------------------------------------------------
// Name: GetAvatarRotations()
// Desc: Convert the skeleton rotations to the avatar skeleton
//--------------------------------------------------------------------------------------
VOID NuiJointConverter::GetAvatarRotations( XAVATAR_SKELETON_POSE_JOINT* pAvatarJoints )
{
    // Clear out all avatar rotations to identity
    for(INT i = XAVATAR_MAX_SKELETON_JOINTS-1; i >= 1; --i)
    {
        pAvatarJoints[i].Rotation = XMQuaternionIdentity();
    }

    // Apply the retargeted skeleton to the avatar
    for ( INT i = 0; i < ARRAYSIZE( g_IntermediateToAvatarMap ); ++i )
    {
        pAvatarJoints[g_IntermediateToAvatarMap[i].m_avatarJoint].Rotation = m_IntJoints[ g_IntermediateToAvatarMap[i].m_intJoint ].quatWorld;
    }

    // Set the position for the base joint
    XMVECTOR vJointPos;
    if( m_NuiSkeleton.eSkeletonPositionTrackingState[ NUI_SKELETON_POSITION_HIP_CENTER ] == NUI_SKELETON_POSITION_NOT_TRACKED )
    {
        vJointPos = XMVectorSet(0.0f, 0.0f, -2.0f, 0.0f);
    }
    else
    {
        vJointPos = GetNuiSkeletonJointPos( NUI_SKELETON_POSITION_HIP_CENTER );
    }

    pAvatarJoints[0].Position = vJointPos;

    // Convert joint rotations from world space to local space.  We go backwards from the highest index so that the parent joints
    // have world space rotations when their children request it.
    for (  INT i = ARRAYSIZE(g_IntermediateToAvatarMap) - 1; i >= 1; --i )
    {
        XMVECTOR qInvParentRot = XMQuaternionInverse( pAvatarJoints[ g_IntermediateToAvatarMap[i].m_avatarParentJoint ].Rotation );
        pAvatarJoints[ g_IntermediateToAvatarMap[i].m_avatarJoint ].Rotation = XMQuaternionMultiply( pAvatarJoints[ g_IntermediateToAvatarMap[i].m_avatarJoint ].Rotation, qInvParentRot);
    }

    // Modify the rotation of the wrists about the axis of the wrist depending on the shoulder and elbow rotations
    // Since there is no way to get an actual wrist rotation, this makes it possible for the avatar to wave with
    // hands facing forward.
    
    // Left hand
    ModifyWrist( pAvatarJoints, LF_W, LF_E, LF_S, 1.0f );

    // Right Hand
    ModifyWrist( pAvatarJoints, RT_W, RT_E, RT_S, -1.0f);
}

//--------------------------------------------------------------------------------------
// Name: ModifyWrist()
// Desc: Modify the rotation of the wrist to show the hand forward when the arm is in a
//       waving position.  As the camera gives only joint positions, there is no way 
//       to determine wrist rotation, so we simply guess at it according to the arm
//       position
//--------------------------------------------------------------------------------------
VOID NuiJointConverter::ModifyWrist( XAVATAR_SKELETON_POSE_JOINT* pAvatarJoints, AvatarJointRef wrist, AvatarJointRef elbow, AvatarJointRef shoulder, FLOAT fShoulderAngleScale )
{
    XMVECTOR vElbowAxis;
    FLOAT fElbowAngle;
    XMQuaternionToAxisAngle( &vElbowAxis, &fElbowAngle, pAvatarJoints[elbow].Rotation );

    // Since the shoulder can rotate more freely, we have to do some work to find the rotation about Z
    XMVECTOR vShoulderAxis;
    FLOAT fShoulderAngle;
    XMMATRIX matRotation = XMMatrixRotationQuaternion( pAvatarJoints[shoulder].Rotation );
    XMVECTOR vRotated = XMVector3Transform( XMVectorSet(1.0f, 0.0f, 0.0f, 0.0f), matRotation );
    vRotated.z = 0.0f;      // zero out the z component so we get a pure z rotation
    XMVECTOR quatZRot = GetShortestRotationBetweenVecs( vRotated, XMVectorSet(1.0f, 0.0f, 0.0f, 0.0f) );
    XMQuaternionToAxisAngle( &vShoulderAxis, &fShoulderAngle, quatZRot );
    if( vShoulderAxis.z < 0)
    {
        fShoulderAngle *= -1.0f;
    }

    // Now use the shoulder and elbow rotation information to create a rotation for the wrist
    FLOAT fShoulderLerpAmount = max( min( fShoulderAngleScale * fShoulderAngle/XM_PIDIV4, 1.0f ), 0.0f );
    FLOAT fLerpAmount = max( min( fElbowAngle/1.2f +  fShoulderLerpAmount, 1.0f ), 0.0f );
    FLOAT fWristRot = fLerpAmount * -XM_PIDIV2;
    XMVECTOR vAxisRot = XMQuaternionRotationAxis( XMVectorSet(1.0f, 0.0f, 0.0f, 0.0f), fWristRot );
    pAvatarJoints[wrist].Rotation = XMQuaternionMultiply( vAxisRot, pAvatarJoints[wrist].Rotation );
    pAvatarJoints[wrist].Rotation = XMQuaternionNormalize( pAvatarJoints[wrist].Rotation );

}

} // namespace ATG
```

`XenonDumper/libs/Atg/AtgNuiJointConverter.h`:

```h
//--------------------------------------------------------------------------------------
// AtgNuiJointConverter.h
//
// Demonstrates a method of constraining NUI joints to plausible human biometrics.  This 
// method attaches a set of cone constraints to the joints, and prohibits movement of
// the child bone of that joint outside of the cone.  If the bone does move outside the 
// cone, it is adjusted to lie on the closest point of the cone.
//
// Microsoft Advanced Technology Group
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------

#pragma once
#ifndef ATG_NUIJOINTCONVERTER_H
#define ATG_NUIJOINTCONVERTER_H

#include <assert.h>
#include <xavatar.h>
#include <xtl.h>
#include <xboxmath.h>
#include <NuiApi.h>

namespace ATG
{

    // Avatar joints in the order documented in the XDK docs.
    enum AvatarJointRef{
        BASE = 0,
        BACKA,
        LF_H,
        RT_H,
        SC_BASE,
        BACKB,
        LF_K,
        LF_SC_H,
        RT_K,
        RT_SC_H,
        SC_BACKA,
        LF_A,
        LF_C,
        LF_SC_K,
        NECK,
        RT_A,
        RT_C,
        RT_SC_K,
        SC_BACKB,
        HEAD,
        LF_S,
        LF_T,
        RT_S,
        RT_T,
        SC_NECK,
        LF_E,
        LF_SC_S,
        LF_SC_S_SK,
        RT_E,
        RT_SC_S,
        RT_SC_S_SK,
        LF_E_SKIN,
        LF_SC_E,
        LF_W,
        RT_E_SKIN,
        RT_SC_E,
        RT_W,
        LF_FINGA,
        LF_FINGB,
        LF_FINGC,
        LF_FINGD,
        LF_PROP,
        LF_SPECIAL,
        LF_THUMB,
        RT_FINGA,
        RT_FINGB,
        RT_FINGC,
        RT_FINGD,
        RT_PROP,
        RT_SPECIAL,
        RT_THUMB,
        LF_FINGA1,
        LF_FINGB1,
        LF_FINGC1,
        LF_FINGD1,
        LF_THUMB1,
        RT_FINGA1,
        RT_FINGB1,
        RT_FINGC1,
        RT_FINGD1,
        RT_THUMB1,
        LF_FINGA2,
        LF_FINGB2,
        LF_FINGC2,
        LF_FINGD2,
        LF_THUMB2,
        RT_FINGA2,
        RT_FINGB2,
        RT_FINGC2,
        RT_FINGD2,
        RT_THUMB2,
        INVALID = 99
    };

    static const INT g_nNumSkeletonFrames   = 10; // The number of frames of camera data to buffer


    //-------------------------------------------------------------------------------------
    // Name: GetShortestRotationBetweenVecs()
    // Desc: Find the shortest rotation between two vectors and return in quaternion form
    //-------------------------------------------------------------------------------------
    inline XMVECTOR GetShortestRotationBetweenVecs( XMVECTOR v1, XMVECTOR v2 )
    {
        XMVECTOR v1Norm = XMVector3Normalize(v1);
        XMVECTOR v2Norm = XMVector3Normalize(v2);
        FLOAT angle = XMScalarACos( XMVectorGetX(XMVector3Dot(v1Norm, v2Norm)) );
        XMVECTOR axis = XMVector3Cross( v2Norm, v1Norm );

        // Check to see if the angle is very small, in which case, the cross product becomes unstable,
        // so set the axis to a default.  It doesn't matter much what this axis is, as the rotation angle 
        // will be near zero anyway.
        if( angle < 0.001f)
            axis = XMVectorSet( 1.0f, 0.0f, 0.0f, 0.0f );

        if( XMVectorGetX(XMVector3Length(axis)) < .001f )
            return XMQuaternionIdentity();

        axis = XMVector3Normalize(axis);
        XMVECTOR qRot = XMQuaternionRotationAxis( axis, angle );

        assert( XMVector3Dot(XMVector3Transform( v2Norm, XMMatrixRotationQuaternion( qRot ) ), v1Norm).x > .99f  );

        return qRot;
    }

    enum INTERMEDIATE_JOINT_INDEX
    {
        INT_BASE = 0,
        INT_HIP_CENTER,
        INT_SPINE,
        INT_SHOULDER_CENTER,
        INT_NECK,
        INT_COLLAR_LEFT,
        INT_SHOULDER_LEFT,
        INT_ELBOW_LEFT,
        INT_WRIST_LEFT,
        INT_COLLAR_RIGHT,
        INT_SHOULDER_RIGHT,
        INT_ELBOW_RIGHT,
        INT_WRIST_RIGHT,
        INT_PELVIS_LEFT,
        INT_HIP_LEFT,
        INT_KNEE_LEFT,
        INT_ANKLE_LEFT,
        INT_PELVIS_RIGHT,
        INT_HIP_RIGHT,
        INT_KNEE_RIGHT,
        INT_ANKLE_RIGHT,
        INTERMEDIATE_JOINT_COUNT
    };

    __declspec(align(16))
    typedef struct JointConstraint_s
    {
        XMVECTOR                    m_vDir;                 // Constraint cone direction
        INTERMEDIATE_JOINT_INDEX    m_intJoint;             // Intermediate joint
        FLOAT                       m_fAngle;               // Constraint cone angle
        FLOAT                       m_fConstraint;          // calculated dynamic value of constraint
    } JointConstraint;

    const DWORD MAX_JOINT_CONSTRAINTS = 100;

    __declspec(align(16))
    typedef struct IntermediateJoint
    {
        XMVECTOR quatLocal;
        XMVECTOR quatWorld;
        XMVECTOR vBoneVectorLS;                             // Local space bone vector
        FLOAT    fBoneLength;                               // Bone length
        NUI_SKELETON_POSITION_TRACKING_STATE eTrackingState;
        struct
        {
            XMVECTOR    m_qFilteredLocal;
            XMVECTOR    m_qTrend;
            UINT        m_uStarted;
        } doubleExponentialFilter;
    } IntermediateJoint;

    __declspec(align(16))
    typedef struct IntermediateJointDesc
    {
        XMVECTOR                        vBoneDir;               // Local space orientation of the joint
        NUI_SKELETON_POSITION_INDEX     startNuiJoint;          // Starting Nui joint for this bone
        NUI_SKELETON_POSITION_INDEX     endNuiJoint;            // End Nui joint for this bone
        INTERMEDIATE_JOINT_INDEX        parentIdx;              // Parent intermediate joint
    }IntermediateJointDesc;

    extern IntermediateJointDesc g_IntJointDesc[ INTERMEDIATE_JOINT_COUNT ];

    //--------------------------------------------------------------------------------------
    // Name: class NuiJointConverter
    // Desc: Converts a Camera skeleton to avatar joint rotations
    //--------------------------------------------------------------------------------------
    class NuiJointConverter
    {
    public:
        NuiJointConverter();
        VOID  ConvertNuiJoints( const NUI_SKELETON_DATA* pNuiSkeleton, BOOL bFilterJointOrientations );
        VOID  ConvertNuiToAvatarSkeleton( const NUI_SKELETON_DATA* pNuiSkeleton, XAVATAR_SKELETON_POSE_JOINT* pAvatarJoints );
        VOID  DrawSkeleton( ::D3DDevice* pd3dDevice, XMMATRIX matWVP ) const;
        VOID  AddJointConstraint( INTERMEDIATE_JOINT_INDEX joint, XMVECTOR vDir, FLOAT fAngle ); 
        VOID  AddDefaultConstraints( );
        VOID  GetNuiSkeletonData( NUI_SKELETON_DATA* pResult ) const;
        VOID  SetBindDir( INTERMEDIATE_JOINT_INDEX index, XMVECTOR vDir ) { g_IntJointDesc[index].vBoneDir = vDir; } 
        VOID  SetJointScaleFactor( XMVECTOR vScaleFactor ) { m_vJointScaleFactor = vScaleFactor; }
        VOID  SetBindPose( INTERMEDIATE_JOINT_INDEX index, XMVECTOR qRot ){ m_qBindPose[index] = qRot; }
        XMVECTOR GetLocalRot( INTERMEDIATE_JOINT_INDEX index ) { return m_IntJoints[index].quatLocal; }

    private:
        VOID  Initialize();
        VOID  Update( BOOL bEnableJointOrientationFilter );
        VOID  SetSkeleton( const NUI_SKELETON_DATA* pJoints );
        VOID  CollideSkeleton( NUI_SKELETON_DATA* pSkeleton );
        VOID  GetAvatarRotations( XAVATAR_SKELETON_POSE_JOINT* pAvatarJoints );
        VOID  ScaleJoints();
        VOID  CalculateJointRotations();
        VOID  DoubleExponentialJointOrientationFilter();
        VOID  ApplyJointConstraints();
        XMVECTOR GetNuiSkeletonJointPos( NUI_SKELETON_POSITION_INDEX jointIndex ) const;
        VOID  ModifyWrist( XAVATAR_SKELETON_POSE_JOINT* pAvatarJoints, AvatarJointRef wrist, AvatarJointRef elbow,
                           AvatarJointRef shoulder, FLOAT fShoulderAngleScale );

        VOID DistanceToLineSegment( XMVECTOR x0, XMVECTOR x1, XMVECTOR p, float* distance, XMVECTOR* normal ) const;

    private:
        NUI_SKELETON_DATA		m_NuiSkeleton;
        DWORD                   m_dwNumJointConstraints;
        JointConstraint		    m_jointConstraints[ MAX_JOINT_CONSTRAINTS ];
        IntermediateJoint       m_IntJoints[ INTERMEDIATE_JOINT_COUNT ];
        IntermediateJoint       m_PreviousIntJoints[ INTERMEDIATE_JOINT_COUNT ];
        XMVECTOR                m_qBindPose[ INTERMEDIATE_JOINT_COUNT ];
        XMVECTOR                m_vReconstructedPos[NUI_SKELETON_POSITION_COUNT];
        XMVECTOR                m_vJointScaleFactor;
    };
};

#endif // #ifdef ATG_NUIJOINTCONVERTER_H
```

`XenonDumper/libs/Atg/AtgNuiJointFilter.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// AtgNuiJointFilter.cpp
//
// This file contains various filters for filtering Joints
//
// Microsoft Game Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------

#include "stdafx.h"
#include "ATGNuiJointFilter.h"

namespace ATG
{
    //-------------------------------------------------------------------------------------
    // Name: Lerp()
    // Desc: Linear interpolation between two floatss
    //-------------------------------------------------------------------------------------
    inline FLOAT Lerp( FLOAT f1, FLOAT f2, FLOAT fBlend )
    {
        return f1 + (f2-f1) * fBlend;
    }
 
    
    //--------------------------------------------------------------------------------------
    // The Blend Update function adds a new frame and then creates an average by summing and dividing the new joints
    // This could be done without storing 10 frames of history if memory is a concern.
    //--------------------------------------------------------------------------------------
    VOID FilterBlendJoint::Update( const XMVECTOR* pJoints )
    {
        
        memcpy( &m_pSkeletonsData[ m_iCurrentFrame ], pJoints, sizeof( FilterSkeletonData ) );
        ++ m_iCurrentFrame;
        m_iCurrentFrame %= m_nFramesToAverage;

        memset( &m_FilteredSkeleton, 0, sizeof( FilterSkeletonData ) );
        for ( int index=0; index < m_nFramesToAverage; ++index )
        {
            for ( int iCount = 0; iCount < NUI_SKELETON_POSITION_COUNT; ++iCount )
            {
                m_FilteredSkeleton.m_Positions[iCount] += m_pSkeletonsData[index].m_Positions[iCount];
            }
        }
        for ( int iCount = 0; iCount < NUI_SKELETON_POSITION_COUNT; ++iCount )
        {
            m_FilteredSkeleton.m_Positions[iCount] /= (FLOAT)m_nFramesToAverage;
        }
        

    }
    //--------------------------------------------------------------------------------------
    // Return a pointer to the filtered joints
    //--------------------------------------------------------------------------------------

    XMVECTOR* FilterBlendJoint::GetFilteredJoints( )
    {
        return &m_FilteredSkeleton.m_Positions[0];
    }

    //--------------------------------------------------------------------------------------
    // The VelDamp function estimates velocity as part of the smoothing function
    // 
    //--------------------------------------------------------------------------------------
    VOID FilterVelDamp::Update( const XMVECTOR* pJoints )
    {
        if ( m_iPreviousFrame == -1 )
        {
            memcpy( &m_SkeletonData[0], pJoints, sizeof( FilterSkeletonData ) );
            m_iPreviousFrame = 1;

			// Redundancy to ensure both previous and current frames are checked
			if ( m_iCurrentFrame == -1 )
			{
				memcpy( &m_SkeletonData[1], pJoints, sizeof( FilterSkeletonData ) );
				m_iCurrentFrame = 0;
			}
        }
        else if ( m_iCurrentFrame == -1 )
        {
            memcpy( &m_SkeletonData[1], pJoints, sizeof( FilterSkeletonData ) );
            m_iCurrentFrame = 0;    
        }
        else 
        {
            ++m_iPreviousFrame;
            m_iPreviousFrame%=2;
            ++m_iCurrentFrame;
            m_iCurrentFrame%=2;
            memcpy( &m_SkeletonData[m_iCurrentFrame], pJoints, sizeof( FilterSkeletonData ) );
            
            static const FLOAT  fAlphaCoeff = 0.4f;
            static const FLOAT  fBetaCoeff = ( fAlphaCoeff * fAlphaCoeff ) / ( 2.0f - fAlphaCoeff );
            
            FilterSkeletonData* pPreviousSkeleton = &m_SkeletonData[m_iPreviousFrame];
            FilterSkeletonData* pCurrentSkeleton = &m_SkeletonData[m_iCurrentFrame];
            FilterVelocitySingleEstimate* pPreviousEstimate = &m_VelocityEstimate[m_iPreviousFrame];
            FilterVelocitySingleEstimate* pCurrentEstimate = &m_VelocityEstimate[m_iCurrentFrame];

            XMVECTOR            vPredicted;
            XMVECTOR            vError;

            for ( INT joint = 0; joint < NUI_SKELETON_POSITION_COUNT ; ++joint )
            {
                // Calculate vPredicted position using last frames corrected position and velocity.
                vPredicted = XMVectorAdd( pPreviousSkeleton->m_Positions[ joint ], 
                    pPreviousEstimate->m_vEstVel[ joint ] );

                // Calculate vError between vPredicted and measured position.
                vError = XMVectorSubtract( pCurrentSkeleton->m_Positions[ joint ], vPredicted );

                // Calculate corrected position.
                pCurrentSkeleton->m_Positions[ joint ] = XMVectorAdd( vPredicted, vError * fAlphaCoeff );

                // Calculate corrected velocity.
                pCurrentEstimate->m_vEstVel[ joint ]= XMVectorAdd( pPreviousEstimate->m_vEstVel[ joint ], vError * fBetaCoeff );
            }

        }
    }
    //--------------------------------------------------------------------------------------
    // Return the filtered joints.
    //--------------------------------------------------------------------------------------

    XMVECTOR* FilterVelDamp::GetFilteredJoints( )
    {
        return &m_SkeletonData[m_iCurrentFrame].m_Positions[0];
    }

    //--------------------------------------------------------------------------------------
    // if joint is 0 it is not valid.
    //--------------------------------------------------------------------------------------
    inline BOOL JointPositionIsValid(XMVECTOR vJointPosition)
    {
        return (vJointPosition.x != 0.0f ||
                vJointPosition.y != 0.0f ||
                vJointPosition.z != 0.0f);
    }



    // Description of connected joints
    typedef struct Bone
    {
        NUI_SKELETON_POSITION_INDEX startJoint;
        NUI_SKELETON_POSITION_INDEX endJoint;
    } Bone;


    // Define the bones in the skeleton using joint indices
    const Bone g_Bones[] =
    {
        // Spine
        {  NUI_SKELETON_POSITION_HIP_CENTER, NUI_SKELETON_POSITION_SPINE  },                // Spine to hip center
        {  NUI_SKELETON_POSITION_SPINE, NUI_SKELETON_POSITION_SHOULDER_CENTER },            // Neck bottom to spine

        // Head
        { NUI_SKELETON_POSITION_SHOULDER_CENTER, NUI_SKELETON_POSITION_HEAD  },             // Top of head to top of neck

        // Right arm
        { NUI_SKELETON_POSITION_SHOULDER_CENTER, NUI_SKELETON_POSITION_SHOULDER_RIGHT },    // Neck bottom to right shoulder internal
        { NUI_SKELETON_POSITION_SHOULDER_RIGHT, NUI_SKELETON_POSITION_ELBOW_RIGHT },        // Right shoulder internal to right elbow
        { NUI_SKELETON_POSITION_ELBOW_RIGHT, NUI_SKELETON_POSITION_WRIST_RIGHT },           // Right elbow to right wrist
        { NUI_SKELETON_POSITION_WRIST_RIGHT, NUI_SKELETON_POSITION_HAND_RIGHT },            // Right wrist to right hand

        // Left arm
        { NUI_SKELETON_POSITION_SHOULDER_CENTER, NUI_SKELETON_POSITION_SHOULDER_LEFT },     // Neck bottom to left shoulder internal
        { NUI_SKELETON_POSITION_SHOULDER_LEFT, NUI_SKELETON_POSITION_ELBOW_LEFT },          // Left shoulder internal to left elbow
        { NUI_SKELETON_POSITION_ELBOW_LEFT, NUI_SKELETON_POSITION_WRIST_LEFT },             // Left elbow to left wrist
        { NUI_SKELETON_POSITION_WRIST_LEFT, NUI_SKELETON_POSITION_HAND_LEFT },              // Left wrist to left hand

        // Right leg and foot
        { NUI_SKELETON_POSITION_HIP_RIGHT, NUI_SKELETON_POSITION_KNEE_RIGHT },              // Right hip internal to right knee
        { NUI_SKELETON_POSITION_KNEE_RIGHT, NUI_SKELETON_POSITION_ANKLE_RIGHT },            // Right knee to right ankle

        { NUI_SKELETON_POSITION_ANKLE_RIGHT, NUI_SKELETON_POSITION_FOOT_RIGHT },            // Left ankle to left foot 

        // Left leg and foot
        { NUI_SKELETON_POSITION_HIP_LEFT, NUI_SKELETON_POSITION_KNEE_LEFT },                // Left hip internal to left knee
        { NUI_SKELETON_POSITION_KNEE_LEFT, NUI_SKELETON_POSITION_ANKLE_LEFT },              // Left knee to left ankle

        { NUI_SKELETON_POSITION_ANKLE_LEFT, NUI_SKELETON_POSITION_FOOT_LEFT },              // Left ankle to left foot 

        // Hips
        { NUI_SKELETON_POSITION_HIP_CENTER, NUI_SKELETON_POSITION_HIP_RIGHT },              // Right hip to hip center
        { NUI_SKELETON_POSITION_HIP_CENTER, NUI_SKELETON_POSITION_HIP_LEFT }                // Hip center to left hip

    };

    const UINT g_numBones = ARRAYSIZE( g_Bones );

    //--------------------------------------------------------------------------------------
    // Name: CombiJointFilter()
    // Desc: A filter for the positional data.  This filter uses a combination of velocity 
    //       position history to filter the joint positions.
    //--------------------------------------------------------------------------------------
    VOID FilterCombination::Update( const XMVECTOR* pJointPositions )
    {
        // Process each joint
        for ( UINT nJoint = 0; nJoint < NUI_SKELETON_POSITION_COUNT; ++nJoint )
        {
            // Remember where the camera thinks this joint should be
            m_History[ nJoint ].m_vWantedPos = pJointPositions[ nJoint ];

            XMVECTOR vDelta;
            vDelta = XMVectorSubtract( m_History[ nJoint ].m_vWantedPos, m_History[ nJoint ].m_vLastWantedPos);
            {
                XMVECTOR vBlended;

                // Calculate the vBlended value - could optimize this by remembering the running total and
                // subtracting the oldest value and then adding the newest. Saves adding them all up on each frame.
                vBlended = XMVectorZero();
                for( UINT k = 0; k < m_nUseTaps; ++k)
                {
                    vBlended = XMVectorAdd( vBlended, m_History[ nJoint ].m_vPrevDeltas[k] );
                }
                vBlended = vBlended / ((FLOAT)m_nUseTaps);

                FLOAT fDeltaLength;
                FLOAT fBlendedLength;
                m_History[ nJoint ].m_fWantedLocalBlendRate = m_fDefaultApplyRate;
                m_History[ nJoint ].m_bActive[0] = FALSE;
                m_History[ nJoint ].m_bActive[1] = FALSE;
                m_History[ nJoint ].m_bActive[2] = FALSE;

                XMVECTOR vDeltaLength = XMVector3Length( vDelta );
                XMVECTOR vBlendedLength = XMVector3Length( vBlended );
                fDeltaLength = XMVectorGetX( vDeltaLength );
                fBlendedLength = XMVectorGetX( vBlendedLength );

                // Does the current velocity and history have a reasonable magnitude?
                if( fDeltaLength   >= m_fDeltaLengthThreshold &&
                    fBlendedLength >= m_fBlendedLengthThreshold )
                {
                    FLOAT fDotProd;
                    FLOAT fConfidence;
                    XMVECTOR vDeltaOne;
                    XMVECTOR vBlendedOne;

                    if( m_bDotProdNormalize )
                    {
                        vDeltaOne = XMVector3Normalize( vDelta );
                        vBlendedOne = XMVector3Normalize( vBlended );
                        XMVECTOR vDotProd = XMVector3Dot( vDeltaOne, vBlendedOne );
                        fDotProd = XMVectorGetX( vDotProd );
                    }
                    else
                    {
                        XMVECTOR vDotProd = XMVector3Dot( vDelta, vBlended );
                        fDotProd = XMVectorGetX( vDotProd );
                    }

                    // Is the current frame aligned to the recent history?
                    if( fDotProd >= m_fDotProdThreshold )
                    {
                        fConfidence = fDotProd;
                        m_History[ nJoint ].m_fWantedLocalBlendRate = min( fConfidence, 1.0f );
                        m_History[ nJoint ].m_bActive[0] = TRUE;
                    }
                }

                assert( m_History[ nJoint ].m_fWantedLocalBlendRate <= 1.0f );
            }

            // Push the previous deltas down the history
            for( INT j = m_nUseTaps-2; j >= 0; --j )
            {
                m_History[ nJoint ].m_vPrevDeltas[j+1] = m_History[ nJoint ].m_vPrevDeltas[j];
            }

            // Store the current history
            m_History[ nJoint ].m_vPrevDeltas[0] = vDelta;	

            // Remember where the camera thought this joint was on the this frame
            m_History[ nJoint ].m_vLastWantedPos = m_History[ nJoint ].m_vWantedPos;
        }

        // Secondary and tertiary blending
        for ( UINT pass = 0; pass < 2; ++pass )
        {
            for ( UINT bone = 0; bone < g_numBones; ++bone )
            {
                FLOAT fRate1;
                FLOAT fRate2;

                fRate1 = m_History[ g_Bones[bone].startJoint ].m_fWantedLocalBlendRate;
                fRate2 = m_History[ g_Bones[bone].endJoint ].m_fWantedLocalBlendRate;

                // Blend down? Start to end
                if( (fRate1 * m_fDownBlendRate) > fRate2)
                {
                    // Yes, apply
                    m_History[ g_Bones[bone].endJoint ].m_fWantedLocalBlendRate = ( fRate1 * m_fDownBlendRate );

                    // Flag
                    m_History[ g_Bones[bone].endJoint ].m_bActive[pass+1] = TRUE;
                }
                // Blend down? End to start
                if( ( fRate2 * m_fDownBlendRate ) > fRate1)
                {
                    // Yes, apply
                    m_History[ g_Bones[bone].startJoint ].m_fWantedLocalBlendRate = ( fRate2 * m_fDownBlendRate );

                    // Flag
                    m_History[ g_Bones[bone].startJoint ].m_bActive[pass+1] = TRUE;
                }
            }
        }

        // Apply
        for ( UINT joint = 0; joint < NUI_SKELETON_POSITION_COUNT; ++joint )
        {
            // Blend the blend rate
            m_History[ joint ].m_fActualLocalBlendRate = 
                    Lerp(m_History[ joint ].m_fActualLocalBlendRate,
                         m_History[ joint ].m_fWantedLocalBlendRate,
                         m_fBlendBlendRate);

            // Blend the actual position towards the wanted positon
            m_History[ joint ].m_vPos = 
                    XMVectorLerp(m_History[ joint ].m_vPos,
                                 m_History[ joint ].m_vWantedPos,
                                 m_History[ joint ].m_fActualLocalBlendRate);
            m_FilteredJoints[ joint ] = m_History[ joint ].m_vPos;
        }
    }


    //--------------------------------------------------------------------------------------
    // Implementation of a Holt Double Exponential Smoothing filter. The double exponential
    // smooths the curve and predicts.  There is also noise jitter removal. And maximum
    // prediction bounds.  The paramaters are commented in the init function.
    //--------------------------------------------------------------------------------------
    VOID FilterDoubleExponential::Update( const NUI_SKELETON_DATA* pSkeletonData )
    {
        // Check for divide by zero. Use an epsilon of a 10th of a millimeter
        m_fJitterRadius = max(0.0001f, m_fJitterRadius);

        NUI_TRANSFORM_SMOOTH_PARAMETERS SmoothingParams;

        for (UINT i = 0; i < NUI_SKELETON_POSITION_COUNT; i++)
        {
            SmoothingParams.fSmoothing      = m_fSmoothing;
            SmoothingParams.fCorrection     = m_fCorrection;
            SmoothingParams.fPrediction     = m_fPrediction;
            SmoothingParams.fJitterRadius   = m_fJitterRadius;
            SmoothingParams.fMaxDeviationRadius = m_fMaxDeviationRadius;

            // If inferred, we smooth a bit more by using a bigger jitter radius
            if (pSkeletonData->eSkeletonPositionTrackingState[i] == NUI_SKELETON_POSITION_INFERRED)
            {
                SmoothingParams.fJitterRadius       *= 2.0f;
                SmoothingParams.fMaxDeviationRadius *= 2.0f;
            }

            Update( pSkeletonData, i, SmoothingParams );
        }
    }

    VOID FilterDoubleExponential::Update( const NUI_SKELETON_DATA* pSkeletonData, UINT i, NUI_TRANSFORM_SMOOTH_PARAMETERS smoothingParams )
    {
        XMVECTOR vPrevRawPosition;
        XMVECTOR vPrevFilteredPosition;
        XMVECTOR vPrevTrend;
        XMVECTOR vRawPosition;
        XMVECTOR vFilteredPosition;
        XMVECTOR vPredictedPosition;
        XMVECTOR vDiff;
        XMVECTOR vTrend;
        XMVECTOR vLength;
        FLOAT fDiff;
        BOOL bJointIsValid;

        const XMVECTOR* __restrict pJointPositions = pSkeletonData->SkeletonPositions;

        vRawPosition            = pJointPositions[i];
        vPrevFilteredPosition   = m_History[i].m_vFilteredPosition;
        vPrevTrend              = m_History[i].m_vTrend;
        vPrevRawPosition        = m_History[i].m_vRawPosition;
        bJointIsValid           = JointPositionIsValid(vRawPosition);

        // If joint is invalid, reset the filter
        if (!bJointIsValid)
        {
            m_History[i].m_dwFrameCount = 0;
        }

        // Initial start values
        if (m_History[i].m_dwFrameCount == 0)
        {
            vFilteredPosition = vRawPosition;
            vTrend = XMVectorZero();
            m_History[i].m_dwFrameCount++;
        }
        else if (m_History[i].m_dwFrameCount == 1)
        {
            vFilteredPosition = XMVectorScale(XMVectorAdd(vRawPosition, vPrevRawPosition), 0.5f);
            vDiff = XMVectorSubtract(vFilteredPosition, vPrevFilteredPosition);
            vTrend = XMVectorAdd(XMVectorScale(vDiff, smoothingParams.fCorrection), XMVectorScale(vPrevTrend, 1.0f - smoothingParams.fCorrection));
            m_History[i].m_dwFrameCount++;
        }
        else
        {              
            // First apply jitter filter
            vDiff = XMVectorSubtract(vRawPosition, vPrevFilteredPosition);
            vLength = XMVector3Length(vDiff);
            fDiff = fabs(XMVectorGetX(vLength));

            if (fDiff <= smoothingParams.fJitterRadius)
            {
                vFilteredPosition = XMVectorAdd(XMVectorScale(vRawPosition, fDiff/smoothingParams.fJitterRadius),
                                                XMVectorScale(vPrevFilteredPosition, 1.0f - fDiff/smoothingParams.fJitterRadius));
            }
            else
            {
                vFilteredPosition = vRawPosition;
            }

            // Now the double exponential smoothing filter
            vFilteredPosition = XMVectorAdd(XMVectorScale(vFilteredPosition, 1.0f - smoothingParams.fSmoothing),
                                            XMVectorScale(XMVectorAdd(vPrevFilteredPosition, vPrevTrend), smoothingParams.fSmoothing));


            vDiff = XMVectorSubtract(vFilteredPosition, vPrevFilteredPosition);
            vTrend = XMVectorAdd(XMVectorScale(vDiff, smoothingParams.fCorrection), XMVectorScale(vPrevTrend, 1.0f - smoothingParams.fCorrection));
        }      

        // Predict into the future to reduce latency
        vPredictedPosition = XMVectorAdd(vFilteredPosition, XMVectorScale(vTrend, smoothingParams.fPrediction));

        // Check that we are not too far away from raw data
        vDiff = XMVectorSubtract(vPredictedPosition, vRawPosition);
        vLength = XMVector3Length(vDiff);
        fDiff = fabs(XMVectorGetX(vLength));

        if (fDiff > smoothingParams.fMaxDeviationRadius)
        {
            vPredictedPosition = XMVectorAdd(XMVectorScale(vPredictedPosition, smoothingParams.fMaxDeviationRadius/fDiff),
                                             XMVectorScale(vRawPosition, 1.0f - smoothingParams.fMaxDeviationRadius/fDiff));
        }

        // Save the data from this frame
        m_History[i].m_vRawPosition      = vRawPosition;
        m_History[i].m_vFilteredPosition = vFilteredPosition;
        m_History[i].m_vTrend            = vTrend;
        
        // Output the data
        m_FilteredJoints[i] = vPredictedPosition;
        m_FilteredJoints[i].w = 1.0f;
    }


    //--------------------------------------------------------------------------------------
    // The Taylor Series smooths and removes jitter based on a taylor series expansion
    //--------------------------------------------------------------------------------------
    VOID FilterTaylorSeries::Update( const XMVECTOR* pJointPositions )
    {
        const FLOAT fJitterRadius = 0.05f;
        const FLOAT fAlphaCoef  = 1.0f - m_fSmoothing;
        const FLOAT fBetaCoeff  = (fAlphaCoef * fAlphaCoef ) / ( 2 - fAlphaCoef );

        XMVECTOR vRawPos;
        // Velocity, accelaration and Jolt are 1st, 2nd and 3rd degree derivatives of position respectively. 
        XMVECTOR vCurFilteredPos, vEstVelocity, vEstAccelaration, vEstJolt;
        XMVECTOR vPrevFilteredPos, vPrevEstVelocity, vPrevEstAccelaration, vPrevEstJolt;
        XMVECTOR vDiff;
        FLOAT fDiff;

        XMVECTOR vPredicted, vError;
        XMVECTOR vConstants = { 0.0f, 1.0f, 0.5f, 0.1667f };

        for (INT i = 0; i < NUI_SKELETON_POSITION_COUNT; i++)
        {
            vRawPos             = pJointPositions[i];
            vPrevFilteredPos    = m_History[i].vPos;
            vPrevEstVelocity    = m_History[i].vEstVelocity;
            vPrevEstAccelaration = m_History[i].vEstAccelaration;
            vPrevEstJolt        = m_History[i].vEstJolt;

            if (!JointPositionIsValid(vPrevFilteredPos))
            {
                vCurFilteredPos = vRawPos;
                vEstVelocity      = XMVectorZero();
                vEstAccelaration     = XMVectorZero();
                vEstJolt     = XMVectorZero();
            }
            else if (!JointPositionIsValid(vRawPos))
            {
                vCurFilteredPos = vPrevFilteredPos;
                vEstVelocity = vPrevEstVelocity;
                vEstAccelaration = vPrevEstAccelaration;
                vEstJolt = vPrevEstJolt;
            }
            else
            {
                // If the current and previous frames have valid data, perform interpolation

                vDiff = XMVectorSubtract(vPrevFilteredPos, vRawPos);
                fDiff = fabs(XMVector3Length(vDiff).x);

                if (fDiff <= fJitterRadius)
                {
                    vCurFilteredPos = XMVectorAdd(XMVectorScale(vRawPos, fDiff/fJitterRadius),
                                                  XMVectorScale(vPrevFilteredPos, 1.0f - fDiff/fJitterRadius));
                }
                else
                {
                    vCurFilteredPos = vRawPos;
                }

                vPredicted  = XMVectorAdd(vPrevFilteredPos, vPrevEstVelocity);
                vPredicted  = XMVectorAdd(vPredicted, vPrevEstAccelaration * (vConstants.y * vConstants.y * vConstants.z));
                vPredicted  = XMVectorAdd(vPredicted, vPrevEstJolt * (vConstants.y * vConstants.y * vConstants.y * vConstants.w));
                vError      = XMVectorSubtract(vCurFilteredPos, vPredicted);

                vCurFilteredPos = XMVectorAdd(vPredicted, vError * fAlphaCoef);
                vEstVelocity = XMVectorAdd(vPrevEstVelocity, vError * fBetaCoeff);
                vEstAccelaration = XMVectorSubtract(vEstVelocity, vPrevEstVelocity);
                vEstJolt = XMVectorSubtract(vEstAccelaration, vPrevEstAccelaration);
            }

            // Update the state
            m_History[i].vPos = vCurFilteredPos;
            m_History[i].vEstVelocity = vEstVelocity;
            m_History[i].vEstAccelaration = vEstAccelaration;
            m_History[i].vEstJolt = vEstJolt;
          
            // Output the data
            m_FilteredJoints[i]     = vCurFilteredPos;
            m_FilteredJoints[i].w   = 1.0f;
        }
    }


    //--------------------------------------------------------------------------------------
    // Name: FilterAdaptiveDoubleExponential::Init()
    // Desc: Initializes the filter
    //--------------------------------------------------------------------------------------
    VOID FilterAdaptiveDoubleExponential::Init()
    {
        // Paramters for a high latency filter with smooth results, but laggy.
        m_HighLatencySmoothingParams.fSmoothing             = 0.6f;
        m_HighLatencySmoothingParams.fCorrection            = 0.2f;
        m_HighLatencySmoothingParams.fPrediction            = 0.1f;
        m_HighLatencySmoothingParams.fJitterRadius          = 0.1f;
        m_HighLatencySmoothingParams.fMaxDeviationRadius    = 0.1f;

        // Paramters for a low latency fitler with somewhat smooth results, but responsive
        m_LowLatencySmoothingParams.fSmoothing              = 0.5f;
        m_LowLatencySmoothingParams.fCorrection             = 0.5f;
        m_LowLatencySmoothingParams.fPrediction             = 0.5f;
        m_LowLatencySmoothingParams.fJitterRadius           = 0.1f;
        m_LowLatencySmoothingParams.fMaxDeviationRadius     = 0.1f;

        Reset();
        m_DoubleExponentialFilter.Init();
    }


    //--------------------------------------------------------------------------------------
    // Name: FilterAdaptiveDoubleExponential::UpdateSmoothingParameters()
    // Desc: Updates the smoothing parameters based on the smoothing filter's trend
    //--------------------------------------------------------------------------------------
    VOID FilterAdaptiveDoubleExponential::Update( const NUI_SKELETON_DATA* pSkeletonData, const FLOAT fDeltaTime  )
    {
        for (UINT i = 0; i < NUI_SKELETON_POSITION_COUNT; i++)
        {
            XMVECTOR vPreviousPosition  = m_DoubleExponentialFilter.m_History[ i ].m_vRawPosition;
            XMVECTOR vCurrentPosition   = pSkeletonData->SkeletonPositions[ i ];
            XMVECTOR vVelocity          = ( vCurrentPosition - vPreviousPosition ) / fDeltaTime;
            FLOAT fVelocity             = fabsf( XMVectorGetX( XMVector3Length( vVelocity ) ) );

            UpdateSmoothingParameters( i, fVelocity, pSkeletonData->eSkeletonPositionTrackingState[i] );

            m_DoubleExponentialFilter.Update( pSkeletonData, i, m_SmoothingParams[ i ] );
        }

        // Copy filtered data to output data
        XMemCpy( m_FilteredJoints, m_DoubleExponentialFilter.GetFilteredJoints(), sizeof( m_FilteredJoints ) );

    }


    //--------------------------------------------------------------------------------------
    // Name: FilterAdaptiveDoubleExponential::UpdateSmoothingParameters()
    // Desc: Updates the smoothing parameters of a joint based on he current joint velocity
    //--------------------------------------------------------------------------------------
    VOID FilterAdaptiveDoubleExponential::UpdateSmoothingParameters( UINT i, FLOAT fVelocity, NUI_SKELETON_POSITION_TRACKING_STATE eTrackingState )
    {
        assert( i < NUI_SKELETON_POSITION_COUNT );

        NUI_TRANSFORM_SMOOTH_PARAMETERS LerpedParams;

        static const FLOAT fBigJitterThreshold      = 5.0f;     // meters per second
        static const FLOAT fLowLatencyThreshold     = 1.5f;     // meters per second
        static const FLOAT fHighLatencyThreshold    = 0.25f;    // meters per second

        BOOL bDetectBigJitter = FALSE;

        // Parameters for hands should should be the same as wrists, otherwise they look unnatural
        switch( i )
        {
        case NUI_SKELETON_POSITION_HAND_LEFT:
            XMemCpy( &m_SmoothingParams[ NUI_SKELETON_POSITION_HAND_LEFT ], &m_SmoothingParams[ NUI_SKELETON_POSITION_WRIST_LEFT ], sizeof( NUI_TRANSFORM_SMOOTH_PARAMETERS ) );
            break;

        case NUI_SKELETON_POSITION_HAND_RIGHT:
            XMemCpy( &m_SmoothingParams[ NUI_SKELETON_POSITION_HAND_RIGHT ], &m_SmoothingParams[ NUI_SKELETON_POSITION_WRIST_RIGHT ], sizeof( NUI_TRANSFORM_SMOOTH_PARAMETERS ) );
            break;

        case NUI_SKELETON_POSITION_FOOT_LEFT:
            XMemCpy( &m_SmoothingParams[ NUI_SKELETON_POSITION_FOOT_LEFT ], &m_SmoothingParams[ NUI_SKELETON_POSITION_ANKLE_LEFT ], sizeof( NUI_TRANSFORM_SMOOTH_PARAMETERS ) );
            break;

        case NUI_SKELETON_POSITION_FOOT_RIGHT:
            XMemCpy( &m_SmoothingParams[ NUI_SKELETON_POSITION_FOOT_RIGHT ], &m_SmoothingParams[ NUI_SKELETON_POSITION_ANKLE_RIGHT ], sizeof( NUI_TRANSFORM_SMOOTH_PARAMETERS ) );
            break;

        default:
            {
                // Lerp between high and low latency params
                FLOAT fLerp = max( 0.0f, min( 1.0f, ( fVelocity - fHighLatencyThreshold ) / ( fLowLatencyThreshold - fHighLatencyThreshold ) ) );

                // Detected a big jitter
                if ( fVelocity > fBigJitterThreshold ||
                     fLerp - m_fPreviousLerp[ i ] > 0.999f )
                {
                    bDetectBigJitter = TRUE;
                    fLerp = ( fLerp * 0.25f ) + ( m_fPreviousLerp[ i ] * 0.75f );
                }

                m_fPreviousLerp[ i ] = fLerp;

                LerpedParams.fSmoothing = m_HighLatencySmoothingParams.fSmoothing + fLerp * ( m_LowLatencySmoothingParams.fSmoothing - m_HighLatencySmoothingParams.fSmoothing );
                LerpedParams.fCorrection = m_HighLatencySmoothingParams.fCorrection + fLerp * ( m_LowLatencySmoothingParams.fCorrection - m_HighLatencySmoothingParams.fCorrection );
                LerpedParams.fPrediction = m_HighLatencySmoothingParams.fPrediction + fLerp * ( m_LowLatencySmoothingParams.fPrediction - m_HighLatencySmoothingParams.fPrediction );
                LerpedParams.fJitterRadius = m_HighLatencySmoothingParams.fJitterRadius + fLerp * ( m_LowLatencySmoothingParams.fJitterRadius - m_HighLatencySmoothingParams.fJitterRadius );
                LerpedParams.fMaxDeviationRadius = m_HighLatencySmoothingParams.fMaxDeviationRadius + fLerp * ( m_LowLatencySmoothingParams.fMaxDeviationRadius - m_HighLatencySmoothingParams.fMaxDeviationRadius );

                XMemCpy( &m_SmoothingParams[ i ], &LerpedParams, sizeof( NUI_TRANSFORM_SMOOTH_PARAMETERS ) );               
            }
        }
        
        if ( bDetectBigJitter )
        {
            m_SmoothingParams[ i ].fJitterRadius *= 2.0f;
            m_SmoothingParams[ i ].fMaxDeviationRadius *= 2.0f;
            m_SmoothingParams[ i ].fPrediction /= 2.0f;
        }
        else if ( eTrackingState == NUI_SKELETON_POSITION_INFERRED )
        {
            // if the joint is not tracked, but inferred, we make sure it gets smoothed more by doubling the jitter radius
            m_SmoothingParams[ i ].fJitterRadius *= 2.0f;
            m_SmoothingParams[ i ].fMaxDeviationRadius *= 2.0f;
        }      
    }

}
```

`XenonDumper/libs/Atg/AtgNuiJointFilter.h`:

```h
//--------------------------------------------------------------------------------------
// AtgNuiJointFilter.h
//
// This file contains various filters for filtering Joints
//
// Microsoft Game Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------


#pragma once
#ifndef ATG_NUI_JOINT_FILTER_H
#define ATG_NUI_JOINT_FILTER_H

#include <xtl.h>
#include <nuiapi.h>
#include <xnamath.h>

namespace ATG
{

    class FilterTaylorSeries
    {

    public:
        FilterTaylorSeries( ) {Init();}

        // Amount of smoothing
        VOID Init( FLOAT fSmoothing = 0.5f )
        {
            m_fSmoothing = fSmoothing;
            Reset();
        };

        VOID Reset()
        {
            XMemSet( m_FilteredJoints, 0, sizeof( m_FilteredJoints )  );
            XMemSet( m_History, 0, sizeof( m_History ) );
        }

        VOID Update( const XMVECTOR* pJoints );

        XMVECTOR* GetFilteredJoints() {return &m_FilteredJoints[0];}

    private:
        struct FilterTaylorSeriesData
        {
            XMVECTOR vPos;                  // Position
            XMVECTOR vEstVelocity;          // First  degree derivative of position
            XMVECTOR vEstAccelaration;      // Second degree derivative of position
            XMVECTOR vEstJolt;              // Third  degree derivative of position
        };

        XMVECTOR m_FilteredJoints[NUI_SKELETON_POSITION_COUNT];
        FilterTaylorSeriesData m_History[NUI_SKELETON_POSITION_COUNT];
        FLOAT m_fSmoothing;

    };

    class FilterBlendJoint 
    {
    public:

        FilterBlendJoint() : m_pSkeletonsData( NULL ), m_nFramesToAverage( 0 ), m_iCurrentFrame( 0 )
        {
            Init( 10 );
        };

        ~FilterBlendJoint() { delete[] m_pSkeletonsData; };

        VOID Init( INT nFramesToAverage )
        {
            m_nFramesToAverage = nFramesToAverage;
            m_pSkeletonsData = new FilterSkeletonData[ nFramesToAverage ];
            Reset();
        };

        VOID Reset()
        {
            memset( &m_FilteredSkeleton, 0, sizeof( FilterSkeletonData ) );
            memset( m_pSkeletonsData, 0, sizeof( FilterSkeletonData ) * m_nFramesToAverage );
            m_iCurrentFrame = 0;    
        }

        VOID Update( const XMVECTOR* pJoints );

        XMVECTOR* GetFilteredJoints( );    

    private:
        struct FilterSkeletonData
        {
            XMVECTOR m_Positions[NUI_SKELETON_POSITION_COUNT];
        };

        FilterSkeletonData m_FilteredSkeleton;
        FilterSkeletonData* m_pSkeletonsData;
        INT m_nFramesToAverage;
        INT m_iCurrentFrame;
    };

    class FilterVelDamp    
    {
    public:
        FilterVelDamp()
        {
            Init();
        };

        VOID Init( )
        {
            Reset();
        }

        VOID Reset()
        {
            memset( m_SkeletonData, 0, sizeof(FilterSkeletonData) * 2 );
            memset( m_VelocityEstimate, 0, sizeof(FilterVelocitySingleEstimate) * 2 );
            m_iCurrentFrame = -1;
            m_iPreviousFrame = -1;    
        }

        VOID Update( const XMVECTOR* pJoints );

        XMVECTOR* GetFilteredJoints( );    

    private:
        struct FilterSkeletonData
        {
            XMVECTOR m_Positions[NUI_SKELETON_POSITION_COUNT];
        };
        
        struct FilterVelocitySingleEstimate
        {
            XMVECTOR m_vEstVel[NUI_SKELETON_POSITION_COUNT];
        };
        
        FilterSkeletonData m_SkeletonData[2];
        FilterVelocitySingleEstimate m_VelocityEstimate[2];
        INT m_iCurrentFrame;
        INT m_iPreviousFrame;
    };


    // Holt Double Exponential Smoothing filter
    class FilterDoubleExponentialData
    {
    public:
        XMVECTOR m_vRawPosition;
        XMVECTOR m_vFilteredPosition;
        XMVECTOR m_vTrend;
        DWORD    m_dwFrameCount;
    };

    class FilterDoubleExponential
    {
    public:
        FilterDoubleExponential() {Init();}

        VOID Init(FLOAT fSmoothing = 0.25f, FLOAT fCorrection = 0.25f, FLOAT fPrediction = 0.25f, FLOAT fJitterRadius = 0.03f, FLOAT fMaxDeviationRadius = 0.05f)
        {
            m_fMaxDeviationRadius = fMaxDeviationRadius; // Size of the max prediction radius Can snap back to noisy data when too high
            m_fSmoothing = fSmoothing;                   // How much smothing will occur.  Will lag when too high
            m_fCorrection = fCorrection;                 // How much to correct back from prediction.  Can make things springy
            m_fPrediction = fPrediction;                 // Amount of prediction into the future to use. Can over shoot when too high
            m_fJitterRadius = fJitterRadius;             // Size of the radius where jitter is removed. Can do too much smoothing when too high
            Reset();
        }

        VOID Reset()
        {
            XMemSet(m_FilteredJoints, 0, sizeof(m_FilteredJoints));
            XMemSet(m_History, 0, sizeof(m_History));
        }

        VOID Update( const NUI_SKELETON_DATA* pSkeletonData );

        XMVECTOR* GetFilteredJoints() {return &m_FilteredJoints[0];}

        // we need to be able to dynamically change the smoothing parameters for the filter
        friend class FilterAdaptiveDoubleExponential;

    private:
        XMVECTOR m_FilteredJoints[NUI_SKELETON_POSITION_COUNT];
        FilterDoubleExponentialData m_History[NUI_SKELETON_POSITION_COUNT];
        FLOAT m_fSmoothing;
        FLOAT m_fCorrection;
        FLOAT m_fPrediction;
        FLOAT m_fJitterRadius;
        FLOAT m_fMaxDeviationRadius;

        VOID Update( const NUI_SKELETON_DATA* pSkeletonData, UINT i, NUI_TRANSFORM_SMOOTH_PARAMETERS smoothingParams );
    };

    class FilterCombinationData
    {
    public:
        static const DWORD MAX_COMBINATION_FILTER_TAPS = 10;
        XMVECTOR	m_vPrevDeltas[ MAX_COMBINATION_FILTER_TAPS ];	
        XMVECTOR	m_vWantedPos;					
        XMVECTOR	m_vLastWantedPos;				
        XMVECTOR	m_vPos;						
        FLOAT	    m_fWantedLocalBlendRate;
        FLOAT	    m_fActualLocalBlendRate;
        BOOL	    m_bActive[3];					// Primary/secondary/tertiary

    };

    class FilterCombination
    {
    public:
        FilterCombination() {Init();}

        VOID Init( FLOAT fDefaultApplyRate = 0.055f, 
                   FLOAT fDotProdThreshold = 0.20f,
                   FLOAT fDeltaLengthThreshold = .002f,
                   FLOAT fBlendedLengthThreshold = .005f,
                   BOOL bDotProdNormalize = TRUE,
                   INT nUseTaps = 4,
                   FLOAT fDownBlendRate = .5f,
                   FLOAT fBlendBlendRate = .1f
                )
        {
            m_fDefaultApplyRate = fDefaultApplyRate;
            m_fDotProdThreshold = fDotProdThreshold;
            m_fDeltaLengthThreshold = fDeltaLengthThreshold;
            m_fBlendedLengthThreshold = fBlendedLengthThreshold;
            m_bDotProdNormalize = bDotProdNormalize;
            m_nUseTaps = nUseTaps;
            m_fDownBlendRate = fDownBlendRate;
            m_fBlendBlendRate = fBlendBlendRate;
            Reset();
        }

        VOID Reset()
        {
            XMemSet(m_FilteredJoints, 0, sizeof(m_FilteredJoints));
            XMemSet(m_History, 0, sizeof(m_History));
        }

        VOID Update( const XMVECTOR* pJointPositions );

        XMVECTOR* GetFilteredJoints() {return &m_FilteredJoints[0];}

    private:
        XMVECTOR m_FilteredJoints[NUI_SKELETON_POSITION_COUNT];
        FilterCombinationData m_History[NUI_SKELETON_POSITION_COUNT];
          
        FLOAT m_fDefaultApplyRate;
        FLOAT m_fDotProdThreshold;
        FLOAT m_fDeltaLengthThreshold;
        FLOAT m_fBlendedLengthThreshold;
        BOOL  m_bDotProdNormalize;
        UINT  m_nUseTaps;
        FLOAT m_fDownBlendRate;
        FLOAT m_fBlendBlendRate;

    };

    // Dynamically adjust the smoothing parameters for each joint using a double exponential smoothing filter
    // The velocity of each joint is evaluated which means that for a joint moving slowly, it will
    // be smoother with higher latency, but for a joint moving faster it will be less smooth by with
    // lower latency
    class FilterAdaptiveDoubleExponential
    {
    public:
        FilterAdaptiveDoubleExponential() { Init(); }

        VOID Init();

        VOID Reset()
        {
            m_DoubleExponentialFilter.Reset();
            XMemSet( m_FilteredJoints, 0, sizeof( m_FilteredJoints ) );            
            for ( UINT i = 0; i < NUI_SKELETON_POSITION_COUNT; i++ )
            {
                XMemCpy( &m_SmoothingParams[ i ], &m_HighLatencySmoothingParams, sizeof( m_HighLatencySmoothingParams ) );
                m_fPreviousLerp[ i ] = 0.0f;
            }
        }

        VOID Update( const NUI_SKELETON_DATA* pSkeletonData, const FLOAT fDeltaTime );

        XMVECTOR* GetFilteredJoints() {return &m_FilteredJoints[0];}

    private:
        XMVECTOR m_FilteredJoints[NUI_SKELETON_POSITION_COUNT];

        NUI_TRANSFORM_SMOOTH_PARAMETERS m_HighLatencySmoothingParams;
        NUI_TRANSFORM_SMOOTH_PARAMETERS m_LowLatencySmoothingParams;
        NUI_TRANSFORM_SMOOTH_PARAMETERS m_SmoothingParams[NUI_SKELETON_POSITION_COUNT];
        FLOAT m_fPreviousLerp[NUI_SKELETON_POSITION_COUNT];

        FilterDoubleExponential m_DoubleExponentialFilter;

        VOID UpdateSmoothingParameters( UINT i, FLOAT fVelocity, NUI_SKELETON_POSITION_TRACKING_STATE eTrackingState );
        
    };
}

#endif // #define ATG_NUI_JOINT_FILTER_H


```

`XenonDumper/libs/Atg/AtgNuiMenu.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// AtgNuiMenu.cpp
//
// Microsoft Advanced Technology Group
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------

#include "stdafx.h"
#include "AtgNuiMenu.h"

#include <assert.h>
#include <nuihandles.h>
#include "AtgDebugDraw.h"


namespace ATG
{

const FLOAT SPINNER_RANGE = 2.0f;  // Spinner upper limit value. It is twice the lenght of 
                                   // the spinner object to account for the back and forth motion.


//--------------------------------------------------------------------------------------
// Name: GetSkeletonIndexFromTrackingID()
// Desc: Given a valid trackingID retrieves the corresponding SkeletonIndex. If the 
//       trackingID is not found, returns NUI_IDENTITY_MAX_ENROLLMENT_COUNT.
//--------------------------------------------------------------------------------------
DWORD GetSkeletonIndexFromTrackingID( const NUI_SKELETON_FRAME* pSkeletonFrame, DWORD dwTrackingID )
{
    assert( dwTrackingID != NUI_SKELETON_INVALID_TRACKING_ID );

    for( DWORD dwSkeletonIndex = 0; dwSkeletonIndex < NUI_SKELETON_COUNT; ++ dwSkeletonIndex )
    {
        if( pSkeletonFrame->SkeletonData[ dwSkeletonIndex ].dwTrackingID == dwTrackingID )
        {
            return dwSkeletonIndex;
        }
    }
    
    return NUI_SKELETON_COUNT;
}


//--------------------------------------------------------------------------------------
// Name: IsMenuItemSelectable()
// Desc: Returns TRUE if the specified menu item is of a selectable type and FALSE 
//       otherwise. 
//--------------------------------------------------------------------------------------
BOOL IsMenuItemSelectable( const NUI_MENU_ITEM* pMenuItem )
{
    if( pMenuItem->eItemType == NUI_MENU_ITEM_BUTTON || pMenuItem->eItemType == NUI_MENU_ITEM_CHECK_BOX )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//--------------------------------------------------------------------------------------
// Name: NuiMenu::NuiMenu()
// Desc: Constructs an instance of NuiMenu.
//--------------------------------------------------------------------------------------
NuiMenu::NuiMenu()
:m_bIsDisabled( FALSE ),
 m_dwItemCount( 0 ),
 m_dwColumnCount( 0 ),
 m_dwRowCount( 0 ),
 m_dwHoveredItemID( NUI_MENU_ITEM_ID_NONE ), 
 m_eHoveredItemState( HOVERED_ITEM_STATE_NOT_SELECTED ),
 m_fRightHandCursor( 0.0f, 0.0f ),
 m_pd3dDevice( NULL ),
 m_dwBackBufferWidth( 0 ),
 m_dwBackBufferHeight( 0 ),
 m_pFont( NULL )
{
    ZeroMemory( &m_settings, sizeof( m_settings ) );

    m_settings.dwCursorSizeInPixels      = NUI_MENU_DEFAULT_CROSSHAIR_SIZE;
    m_settings.dwCursorThicknessInPixels = NUI_MENU_DEFAULT_CROSSHAIR_THICKNESS;
    m_settings.dwHoverTime               = NUI_MENU_DEFAULT_HOVER_TIME;

    m_settings.cursorColor               = NUI_MENU_DEFAULT_CURSOR_COLOR;
    m_settings.panelColor                = NUI_MENU_DEFAULT_PANEL_COLOR;
    m_settings.selectableColor           = NUI_MENU_DEFAULT_SELECTABLE_COLOR;
    m_settings.selectedColor             = NUI_MENU_DEFAULT_SELECTED_COLOR;
    m_settings.staticColor               = NUI_MENU_DEFAULT_STATIC_COLOR;
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::~NuiMenu()
// Desc: Release any acquired resources. 
//--------------------------------------------------------------------------------------
NuiMenu::~NuiMenu()
{
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::Initialize()
// Desc: Provides this instance of NuiMenu with system resources it needs. Must be 
//       called only once after the menu object has been created.
//
// NOTE: The data pointed to by pd3dDevice and pFont must persist for the life
//       duration of thisobject.
//--------------------------------------------------------------------------------------
HRESULT NuiMenu::Initialize( ::D3DDevice* pd3dDevice, DWORD dwBackBufferWidth, DWORD dwBackBufferHeight, ATG::Font* pFont )
{
    assert( pd3dDevice != NULL );
    assert( pFont != NULL );
    
    if( m_pd3dDevice != NULL )
    {
        return E_FAIL; // Object is already initialized.
    }
    
    m_pd3dDevice = pd3dDevice;

    m_dwBackBufferWidth  = dwBackBufferWidth;
    m_dwBackBufferHeight = dwBackBufferHeight;

    m_pFont = pFont;

    // No need to check the return value because NuiHandlesArmsInit always returns S_OK, unless the parameter is NULL.
    NuiHandlesArmsInit( &m_HandlesArms );

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::SetMenuLayout()
// Desc: Sets the menu layout to use. 
//--------------------------------------------------------------------------------------
VOID NuiMenu::SetMenuLayout( NUI_MENU_ITEM aMenuItem[], DWORD dwItemCount, DWORD dwColumnCount, DWORD dwRowCount )
{
    m_pMenuItemList     = aMenuItem;
    m_dwItemCount       = dwItemCount;
    m_dwColumnCount     = dwColumnCount;
    m_dwRowCount        = dwRowCount;

    ClearActiveItem();
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::Update()
// Desc: Updates the internal menu states based on the player's right hand movements.
//--------------------------------------------------------------------------------------
HRESULT NuiMenu::Update( const NUI_SKELETON_FRAME* pUnfilteredSkeletonFrame, 
                         DWORD dwControllingTrackingID, 
                         const NUI_IMAGE_FRAME* pDepthFrame320x240, 
                         const NUI_IMAGE_FRAME* pDepthFrame80x60 )
{
    // Nothing to update if the whole menu is disabled
    if( m_bIsDisabled )
    {
        return S_OK;
    }

    // Retrieve the skeleton corresponding to the controlling tracking ID
    DWORD dwSkeletonIndex = GetSkeletonIndexFromTrackingID( pUnfilteredSkeletonFrame, dwControllingTrackingID );
    if( dwSkeletonIndex >= NUI_SKELETON_COUNT )
    {
        return E_FAIL;
    }

    // Keep our internal object time in sync with the skeleton frame time
    m_liCurrentTime = pUnfilteredSkeletonFrame->liTimeStamp;

    // Pass the new frame data to NuiHandles and retrieve the right hand position.
    // NuiHandlesArmsUpdate() always return S_OK unless one of the parameters is incorrectly specified.
    NuiHandlesArmsUpdate( &m_HandlesArms, dwSkeletonIndex, pUnfilteredSkeletonFrame, pDepthFrame320x240, NULL, pDepthFrame80x60, NULL );
    m_fRightHandCursor = GetXYForVector( NuiHandlesArmGetScreenSpaceLocation( &m_HandlesArms, NUI_HANDLES_ARMS_HANDEDNESS_RIGHT_ARM ) );

    // Clear the hovered item info if we have stopped hovereing said item since last tick    
    if( m_dwHoveredItemID != NUI_MENU_ITEM_ID_NONE && ! IsCursorOverItem( GetMenuItemFromItemID( m_dwHoveredItemID ) ) )
    {
        m_dwHoveredItemID = NUI_MENU_ITEM_ID_NONE;
    }

    // Find which selectable item the cursor is hovering, if any
    if( m_dwHoveredItemID == NUI_MENU_ITEM_ID_NONE )
    {
        for( DWORD i = 0; i < m_dwItemCount; ++ i )
        {
            if( IsMenuItemSelectable( &m_pMenuItemList[ i ] ) && IsCursorOverItem( &m_pMenuItemList[ i ] ) )
            {
                m_liHoverBeginTime = m_liCurrentTime;
                m_dwHoveredItemID  = m_pMenuItemList[ i ].dwItemID;
                break;
            }
        }
    }

    // Ensure the item being hovered was not disabled or hidden between two ticks
    if( m_dwHoveredItemID != NUI_MENU_ITEM_ID_NONE && 
        ( ! GetMenuItemFromItemID( m_dwHoveredItemID )->bEnabled || 
          GetMenuItemFromItemID( m_dwHoveredItemID )->bHidden ) )
    {
        m_dwHoveredItemID = NUI_MENU_ITEM_ID_NONE;
    }
 
    // Update the selection state for the hovered item
    if( m_dwHoveredItemID == NUI_MENU_ITEM_ID_NONE )
    {
        m_eHoveredItemState = HOVERED_ITEM_STATE_NOT_SELECTED;
    }
    else
    {
        // If the item has been hovered for the required amount of time, update it to the correct state.
        if( m_liCurrentTime.QuadPart - m_liHoverBeginTime.QuadPart >= m_settings.dwHoverTime )
        {
            if( m_eHoveredItemState == HOVERED_ITEM_STATE_NOT_SELECTED )
            {
                m_eHoveredItemState = HOVERED_ITEM_STATE_JUST_SELECTED;
            }
            else if( m_eHoveredItemState == HOVERED_ITEM_STATE_JUST_SELECTED )
            {
                m_eHoveredItemState = HOVERED_ITEM_STATE_SELECTED;
            }
        }
        else
        {
            m_eHoveredItemState = HOVERED_ITEM_STATE_NOT_SELECTED;
        }
    }

    // Update all spinners
    for( DWORD i = 0; i < m_dwItemCount; ++ i )
    {
        if( m_pMenuItemList[ i ].eItemType == NUI_MENU_ITEM_SPINNER && 
            m_pMenuItemList[ i ].bEnabled && ! m_pMenuItemList[ i ].bHidden )
        {
            // SPINNER_RANGE is twice the distance of an actual on screen spinner so that 
            // when rendered on screen moves back and forth 
            m_pMenuItemList[ i ].fValue += NUI_MENU_DEFAULT_SPINNER_SPEED;
            if( m_pMenuItemList[ i ].fValue >= SPINNER_RANGE )
            {
                m_pMenuItemList[ i ].fValue -= SPINNER_RANGE;
            }
        }
    }

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::Render()
// Desc: Renders the menu items and the cursor.
//--------------------------------------------------------------------------------------
VOID NuiMenu::Render() const
{ 
    assert( m_pd3dDevice != NULL );

    // Nothing to render.
    if( m_pMenuItemList == NULL )
    {
        return;
    }

    // Render each item in listed order
    for( DWORD dwItemIndex = 0; dwItemIndex < m_dwItemCount; ++ dwItemIndex )
    {
        // Only render items that aren't hidden
        if( ! m_pMenuItemList[ dwItemIndex ].bHidden )
        {
            switch( m_pMenuItemList[ dwItemIndex ].eItemType )
            {
                // Render a button. Buttons are shown in different colors depending on whether they are disabled, 
                // selectable or selected
                case NUI_MENU_ITEM_BUTTON:
                {
                    D3DCOLOR color = m_settings.staticColor;
                    if( m_pMenuItemList[ dwItemIndex ].dwItemID == m_dwHoveredItemID )
                    {
                        color = m_settings.selectedColor;
                    }
                    else if( m_pMenuItemList[ dwItemIndex ].bEnabled && ! m_bIsDisabled )
                    {
                        color = m_settings.selectableColor;
                    }
                    
                    DrawButton( &m_pMenuItemList[ dwItemIndex ].Location, m_pMenuItemList[ dwItemIndex ].szText, color );
                    break;
                }

                // Render a check box. Check boxes are shown in different colors depending on whether they are disabled, 
                // selectable or selected
                case NUI_MENU_ITEM_CHECK_BOX:
                {
                    D3DCOLOR color = m_settings.staticColor;
                    if( m_pMenuItemList[ dwItemIndex ].dwItemID == m_dwHoveredItemID )
                    {
                        color = m_settings.selectedColor;
                    }
                    else if( m_pMenuItemList[ dwItemIndex ].bEnabled && ! m_bIsDisabled )
                    {
                        color = m_settings.selectableColor;
                    }

    
                    DrawCheckBox( &m_pMenuItemList[ dwItemIndex ].Location, m_pMenuItemList[ dwItemIndex ].szText, color, m_pMenuItemList[ dwItemIndex ].fValue > 0.0f );
                    break;
                }

                case NUI_MENU_ITEM_FRAME:
                    DrawFrame( &m_pMenuItemList[ dwItemIndex ].Location, m_settings.staticColor );
                    break;

                case NUI_MENU_ITEM_PANEL:
                    DrawPanel( &m_pMenuItemList[ dwItemIndex ].Location, m_settings.panelColor );
                    break;

                case NUI_MENU_ITEM_PROGRESS_BAR:
                    DrawProgressBar( &m_pMenuItemList[ dwItemIndex ].Location, m_pMenuItemList[ dwItemIndex ].fValue, m_settings.staticColor );
                    break;

                case NUI_MENU_ITEM_SPINNER:
                    DrawSpinner( &m_pMenuItemList[ dwItemIndex ].Location, m_pMenuItemList[ dwItemIndex ].fValue, m_settings.staticColor );
                    break;

                case NUI_MENU_ITEM_TEXT:
                    DrawText( &m_pMenuItemList[ dwItemIndex ].Location, m_pMenuItemList[ dwItemIndex ].szText, m_settings.staticColor, m_pMenuItemList[ dwItemIndex ].dwValue );
                    break;

                default:
                    assert( false );
                    break;
            }
        }
    }

    // Add an alignment grid on top of the menu, if requested.
    if( m_settings.bDrawGuide )
    {
        DrawAlignmentGrid();
    }

    // Draw the cursor last, unless the whole menu is disabled
    if( ! m_bIsDisabled )
    {
        DrawCursor();
    }

} 


//--------------------------------------------------------------------------------------
// Name: NuiMenu::GetActiveItem()
// Desc: Returns the active button or check box. Return NUI_MENU_ITEM_ID_NONE if no 
//       button or check box is currently selected.
//--------------------------------------------------------------------------------------
DWORD NuiMenu::GetActiveItem() const
{
    // Ensure the selected state is returned only once
    if( m_eHoveredItemState == HOVERED_ITEM_STATE_JUST_SELECTED )
    { 
        assert( m_dwHoveredItemID != NUI_MENU_ITEM_ID_NONE );
        assert( GetMenuItemFromItemID( m_dwHoveredItemID )->bEnabled );

        return m_dwHoveredItemID;
    } 
        
    return NUI_MENU_ITEM_ID_NONE; 
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::ClearActiveItem()
// Desc: Clears the active selection and progress made so far. The selection process will 
//       restart at the next call to Update() 
//--------------------------------------------------------------------------------------
VOID NuiMenu::ClearActiveItem()
{
    m_dwHoveredItemID   = NUI_MENU_ITEM_ID_NONE;
    m_eHoveredItemState = HOVERED_ITEM_STATE_NOT_SELECTED;
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::GetMenuSettings()
// Desc: Obtains the current menu settings.
//--------------------------------------------------------------------------------------
VOID NuiMenu::GetMenuSettings( NUI_MENU_SETTINGS* pNuiMenuSettings ) const
{
    assert( pNuiMenuSettings != NULL );

    XMemCpy( pNuiMenuSettings, &m_settings, sizeof( NUI_MENU_SETTINGS ) );
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::SetMenuSettings()
// Desc: CHnages the settings for this object.
//--------------------------------------------------------------------------------------
VOID NuiMenu::SetMenuSettings( const NUI_MENU_SETTINGS* pNuiMenuSettings )
{
    assert( pNuiMenuSettings != NULL );

    XMemCpy( &m_settings, pNuiMenuSettings, sizeof( NUI_MENU_SETTINGS ) );
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::EnableItem()
// Desc: Enables the specified item. Returns E_FAIL if the item doesn't exist.
//--------------------------------------------------------------------------------------
HRESULT NuiMenu::EnableItem( DWORD dwItemID )
{
    NUI_MENU_ITEM* pItem = GetMenuItemFromItemID( dwItemID );
    if( pItem == NULL )
    {
        return E_FAIL;
    }

    pItem->bEnabled = TRUE;
    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::DisableItem()
// Desc: Disables the specified item. Disabled items are shown but cannot be selected.
//       Returns E_FAIL if the item doesn't exist.
//--------------------------------------------------------------------------------------
HRESULT NuiMenu::DisableItem( DWORD dwItemID )
{
    NUI_MENU_ITEM* pItem = GetMenuItemFromItemID( dwItemID );
    if( pItem == NULL )
    {
        return E_FAIL;
    }

    pItem->bEnabled = FALSE;
    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::ShowItem()
// Desc: The specified item will be made visible. Returns E_FAIL if the item doesn't 
//       exist.
//--------------------------------------------------------------------------------------
HRESULT NuiMenu::ShowItem( DWORD dwItemID )
{
    NUI_MENU_ITEM* pItem = GetMenuItemFromItemID( dwItemID );
    if( pItem == NULL )
    {
        return E_FAIL;
    }

    pItem->bHidden = FALSE;
    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::HideItem()
// Desc: The specified item will be hidden. Hidden items are also inactive.
//       Returns E_FAIL if the item doesn't exist.
//--------------------------------------------------------------------------------------
HRESULT NuiMenu::HideItem( DWORD dwItemID )
{
    NUI_MENU_ITEM* pItem = GetMenuItemFromItemID( dwItemID );
    if( pItem == NULL )
    {
        return E_FAIL;
    }

    pItem->bHidden = TRUE;
    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::SetItemText()
// Desc: Sets the text of a specific item.
//--------------------------------------------------------------------------------------
HRESULT NuiMenu::SetItemText( DWORD dwItemID, LPCWSTR wszText )
{
    NUI_MENU_ITEM* pItem = GetMenuItemFromItemID( dwItemID );
    if( pItem == NULL )
    {
        return E_FAIL;
    }

    pItem->szText = wszText;
    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::SetItemSelectedState()
// Desc: Sets the selectable state of a selectable item.
//--------------------------------------------------------------------------------------
HRESULT NuiMenu::SetItemSelectedState( DWORD dwItemID, BOOL bSelected )
{
    NUI_MENU_ITEM* pItem = GetMenuItemFromItemID( dwItemID );
    if( pItem == NULL )
    {
        return E_FAIL;
    }

    if( ! IsMenuItemSelectable( pItem ) )
    {
        return E_FAIL;
    }

    pItem->bValue = bSelected;
    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::SetItemProgress()
// Desc: Sets the progress for a progress bar item.
//--------------------------------------------------------------------------------------
HRESULT NuiMenu::SetItemProgress( DWORD dwItemID, FLOAT fProgress )
{
    assert( fProgress >= 0.0f && fProgress <= 1.0f );

    NUI_MENU_ITEM* pItem = GetMenuItemFromItemID( dwItemID );
    if( pItem == NULL )
    {
        return E_FAIL;
    }

    if( pItem->eItemType != NUI_MENU_ITEM_PROGRESS_BAR )
    {
        return E_FAIL;
    }

    pItem->fValue = fProgress;
    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::DrawAlignmentGrid()
// Desc: Draws a grid to help align menu items on screen
//--------------------------------------------------------------------------------------
VOID NuiMenu::DrawAlignmentGrid() const
{
    assert( m_dwColumnCount > 0 );
    assert( m_dwRowCount > 0 );


    D3DCOLOR GridColor     = 0xffff0000;
    FLOAT    GridThickness = 1.0f;

    for( DWORD dwX = 0; dwX < m_dwColumnCount; ++ dwX )
    {
        ATG::DebugDraw::DrawScreenSpaceLine( ConvertPointToScreenSpace( dwX, 0 ), 
                                             ConvertPointToScreenSpace( dwX, m_dwRowCount ),
                                             GridColor, GridThickness );
    }

    for( DWORD dwY = 0; dwY < m_dwRowCount; ++ dwY )
    {
        ATG::DebugDraw::DrawScreenSpaceLine( ConvertPointToScreenSpace( 0,               dwY ), 
                                             ConvertPointToScreenSpace( m_dwColumnCount, dwY ),
                                             GridColor, GridThickness );
    }

    ATG::DebugDraw::DrawScreenSpaceLine( XMFLOAT2( m_dwBackBufferWidth - 1.0f, 0.0f ), 
                                         XMFLOAT2( m_dwBackBufferWidth - 1.0f, m_dwBackBufferHeight - 1.0f ),
                                         GridColor, GridThickness );

    ATG::DebugDraw::DrawScreenSpaceLine( XMFLOAT2( 0.0f,                       m_dwBackBufferHeight - 1.0f ), 
                                         XMFLOAT2( m_dwBackBufferWidth - 1.0f, m_dwBackBufferHeight - 1.0f ),
                                         GridColor, GridThickness );
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::DrawButton()
// Desc: Draws a button of the specified color on screen. The string specified by 
//       wszText is centered inside the button.
//--------------------------------------------------------------------------------------
VOID NuiMenu::DrawButton( const D3DRECT* pLocation, LPCWSTR wszText, D3DCOLOR color ) const
{
    DrawFrame( pLocation, color );
    DrawText( pLocation, wszText, color, ATGFONT_CENTER_X );
}

   
//--------------------------------------------------------------------------------------
// Name: NuiMenu::DrawCheckBox()
// Desc: Draws a check box of the specified color on screen. The string specified by 
//       wszText will be displayed to the right of the check box. bChecked indicates 
//       whether the box should be ffilled or empty.
//--------------------------------------------------------------------------------------
VOID NuiMenu::DrawCheckBox( const D3DRECT* pLocation, LPCWSTR wszText, D3DCOLOR color, BOOL bChecked ) const
{
    D3DRECT CheckBoxLocationInPixel;
    ConvertRectToScreenSpace( pLocation, &CheckBoxLocationInPixel );
    DWORD dwHeight = CheckBoxLocationInPixel.y2 - CheckBoxLocationInPixel.y1;

    D3DRECT TextLocationInPixel = CheckBoxLocationInPixel;

    DWORD dwCheckBoxSize = ( DWORD )( dwHeight * 0.5f );
    CheckBoxLocationInPixel.y1 += ( LONG )( ( dwHeight - dwCheckBoxSize ) * 0.5f );
    CheckBoxLocationInPixel.y2 = CheckBoxLocationInPixel.y1 + dwCheckBoxSize;
    CheckBoxLocationInPixel.x2 = CheckBoxLocationInPixel.x1 + dwCheckBoxSize;

    ATG::DebugDraw::DrawScreenSpaceRect( CheckBoxLocationInPixel, bChecked ? 0.0f : ( FLOAT )m_settings.dwCursorThicknessInPixels, color );

    TextLocationInPixel.x1 += ( LONG )( dwCheckBoxSize * 1.5f );

    m_pFont->Begin();

    D3DRECT rc;
    m_pFont->GetWindow( rc );
    m_pFont->SetWindow( TextLocationInPixel );

    FLOAT fXScaleFactor = m_pFont->m_fXScaleFactor;
    FLOAT fYScaleFactor = m_pFont->m_fYScaleFactor;
    FLOAT fScale = dwHeight * 0.5f / m_pFont->GetFontHeight();
    m_pFont->SetScaleFactors( fScale, fScale );

    m_pFont->DrawText( 0.0f, dwHeight * 0.5f, color, wszText, ATGFONT_LEFT | ATGFONT_CENTER_Y );            

    m_pFont->SetScaleFactors( fXScaleFactor, fYScaleFactor );
    m_pFont->SetWindow( rc );
    m_pFont->End();
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::DrawCursor()
// Desc: Draw a crosshair cursor. The cursor will have a small progress bar displayed 
//       underneath, if it is hovering a selectable item.
//--------------------------------------------------------------------------------------
VOID NuiMenu::DrawCursor() const
{
    FLOAT fCrosshairHalfSize = m_settings.dwCursorSizeInPixels / 2.0f;

    // Draw progress bar if the cursor is hovering an item
    if( m_dwHoveredItemID != NUI_MENU_ITEM_ID_NONE )
    {
        INT iHoverTime = INT( m_liCurrentTime.QuadPart - m_liHoverBeginTime.QuadPart );
        FLOAT fRatio = iHoverTime / ( FLOAT )m_settings.dwHoverTime;    
        if( fRatio <= 1.0f )
        {
            ATG::DebugDraw::DrawScreenSpaceRect( XMFLOAT2( m_fRightHandCursor.x - fCrosshairHalfSize, m_fRightHandCursor.y + fCrosshairHalfSize + m_settings.dwCursorSizeInPixels / 10 ), 
                                                 XMFLOAT2( ( FLOAT )m_settings.dwCursorSizeInPixels, m_settings.dwCursorSizeInPixels * 0.2f ), 1, m_settings.cursorColor );
        
            ATG::DebugDraw::DrawScreenSpaceRect( XMFLOAT2( m_fRightHandCursor.x - fCrosshairHalfSize, m_fRightHandCursor.y + fCrosshairHalfSize + m_settings.dwCursorSizeInPixels / 10 ), 
                                                 XMFLOAT2( ( FLOAT )m_settings.dwCursorSizeInPixels * fRatio, m_settings.dwCursorSizeInPixels * 0.2f ), 0, m_settings.cursorColor );
        }
    }

    // Draw the cursor.
    ATG::DebugDraw::DrawScreenSpaceLine( XMFLOAT2( m_fRightHandCursor.x - fCrosshairHalfSize, m_fRightHandCursor.y ), 
                                         XMFLOAT2( m_fRightHandCursor.x + fCrosshairHalfSize, m_fRightHandCursor.y ), 
                                         m_settings.cursorColor, ( FLOAT )m_settings.dwCursorThicknessInPixels );

    ATG::DebugDraw::DrawScreenSpaceLine( XMFLOAT2( m_fRightHandCursor.x, m_fRightHandCursor.y - fCrosshairHalfSize ), 
                                         XMFLOAT2( m_fRightHandCursor.x, m_fRightHandCursor.y + fCrosshairHalfSize ), 
                                         m_settings.cursorColor, ( FLOAT )m_settings.dwCursorThicknessInPixels );
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::DrawFrame()
// Desc: Draws a frame of the specified color on screen.
//--------------------------------------------------------------------------------------
VOID NuiMenu::DrawFrame( const D3DRECT* pLocation, D3DCOLOR color ) const
{
    D3DRECT LocationInPixel;
    ConvertRectToScreenSpace( pLocation, &LocationInPixel );

    ATG::DebugDraw::DrawScreenSpaceRect( LocationInPixel, ( FLOAT )m_settings.dwCursorThicknessInPixels, color );
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::DrawPanel()
// Desc: Draws a filled box of the specified color on screen.
//--------------------------------------------------------------------------------------
VOID NuiMenu::DrawPanel( const D3DRECT* pLocation, D3DCOLOR color ) const
{
    D3DRECT LocationInPixel;
    ConvertRectToScreenSpace( pLocation, &LocationInPixel );

    ATG::DebugDraw::DrawScreenSpaceRect( LocationInPixel, 0, color );
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::DrawProgressBar()
// Desc: Draws a progress bar of the specified color on screen. fProgress must be between 
//       0.0f and 1.0f
//--------------------------------------------------------------------------------------
VOID NuiMenu::DrawProgressBar( const D3DRECT* pLocation, FLOAT fProgress, D3DCOLOR color ) const
{
    assert( fProgress >= 0.0f && fProgress <= 1.0f );

    D3DRECT LocationInPixel;
    ConvertRectToScreenSpace( pLocation, &LocationInPixel );

    ATG::DebugDraw::DrawScreenSpaceRect( LocationInPixel, ( FLOAT )m_settings.dwCursorThicknessInPixels, color );

    DWORD dwRange =  LocationInPixel.x2 - LocationInPixel.x1;

    D3DRECT BarLocationInPixel;
    BarLocationInPixel.x1 = LocationInPixel.x1;
    BarLocationInPixel.y1 = LocationInPixel.y1;
    BarLocationInPixel.x2 = LocationInPixel.x1 + ( LONG )( dwRange * fProgress );
    BarLocationInPixel.y2 = LocationInPixel.y2;
    ATG::DebugDraw::DrawScreenSpaceRect( BarLocationInPixel, 0, color );
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::DrawSpinner()
// Desc: Draws a spinner item on screen.
//--------------------------------------------------------------------------------------
VOID NuiMenu::DrawSpinner( const D3DRECT* pLocation, FLOAT fProgress, D3DCOLOR color ) const
{
    assert( fProgress >= 0.0f && fProgress <= SPINNER_RANGE );

    D3DRECT LocationInPixel;
    ConvertRectToScreenSpace( pLocation, &LocationInPixel );

    ATG::DebugDraw::DrawScreenSpaceRect( LocationInPixel, ( FLOAT )m_settings.dwCursorThicknessInPixels, color );

    DWORD dwBoxSize = LocationInPixel.y2 - LocationInPixel.y1;
    DWORD dwRange =  LocationInPixel.x2 - LocationInPixel.x1 - dwBoxSize;

    if( fProgress > 1.0f )
    {
        fProgress = fabs( fProgress - SPINNER_RANGE );
    }

    D3DRECT SpinnerLocationInPixel;
    SpinnerLocationInPixel.x1 = ( LONG )( LocationInPixel.x1 + dwRange * fProgress );
    SpinnerLocationInPixel.y1 = LocationInPixel.y1;
    SpinnerLocationInPixel.x2 = SpinnerLocationInPixel.x1 + dwBoxSize;
    SpinnerLocationInPixel.y2 = LocationInPixel.y2;
    ATG::DebugDraw::DrawScreenSpaceRect( SpinnerLocationInPixel, 0, color );
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::DrawText()
// Desc: Draws a text item on screen. The text can be left aligned or centered 
//       horizontally.
//--------------------------------------------------------------------------------------
VOID NuiMenu::DrawText( const D3DRECT* pLocation, LPCWSTR wszText, D3DCOLOR color, DWORD dwHorizontalAlignment  ) const
{
    D3DRECT LocationInPixel;
    ConvertRectToScreenSpace( pLocation, &LocationInPixel );

    DWORD dwWidth  = LocationInPixel.x2 - LocationInPixel.x1;
    DWORD dwHeight = LocationInPixel.y2 - LocationInPixel.y1;

    m_pFont->Begin();

    D3DRECT rc;
    m_pFont->GetWindow( rc );
    m_pFont->SetWindow( LocationInPixel );

    FLOAT fXScaleFactor = m_pFont->m_fXScaleFactor;
    FLOAT fYScaleFactor = m_pFont->m_fYScaleFactor;
    FLOAT fScale = dwHeight * 0.5f / m_pFont->GetFontHeight();
    m_pFont->SetScaleFactors( fScale, fScale );

   
    if( dwHorizontalAlignment & ATGFONT_CENTER_X )
    {
        m_pFont->DrawText( dwWidth * 0.5f, dwHeight * 0.5f, color, wszText, ATGFONT_CENTER_X | ATGFONT_CENTER_Y );            
    }
    else
    {
        m_pFont->DrawText( 0.0f, dwHeight * 0.5f, color, wszText, ATGFONT_LEFT | ATGFONT_CENTER_Y );            
    }

    m_pFont->SetScaleFactors( fXScaleFactor, fYScaleFactor );
    m_pFont->SetWindow( rc );
    m_pFont->End();    
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::GetMenuItemFromItemID()
// Desc: Given a valid item ID, returns the corresponding item for the item list. It 
//       returns NULL if the item doesn't exist.
//--------------------------------------------------------------------------------------
const NUI_MENU_ITEM* NuiMenu::GetMenuItemFromItemID( DWORD dwItemID ) const
{
    assert( dwItemID != NUI_MENU_ITEM_ID_NONE );
    assert( dwItemID != NUI_MENU_ITEM_ID_UNDEFINED );

    for( DWORD dwItemIndex = 0; dwItemIndex < m_dwItemCount; ++ dwItemIndex )
    {
        if( m_pMenuItemList[ dwItemIndex ].dwItemID == dwItemID )
        {
            return &m_pMenuItemList[ dwItemIndex ];
        }
    }

    assert( false );
    return NULL;
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::GetMenuItemFromItemID()
// Desc: constless version of GetMenuItemFromItemID()
//--------------------------------------------------------------------------------------
NUI_MENU_ITEM* NuiMenu::GetMenuItemFromItemID( DWORD dwItemID )
{
    return const_cast< NUI_MENU_ITEM* >( const_cast< const NuiMenu* >( this )->GetMenuItemFromItemID( dwItemID ) );
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::IsCursorOverItem()
// Desc: Returns TRUE if the cursor is on top of the specified item.
//--------------------------------------------------------------------------------------
BOOL NuiMenu::IsCursorOverItem( const NUI_MENU_ITEM* pMenuItem ) const
{
    D3DRECT LocationInScreenSpace;
    ConvertRectToScreenSpace( &pMenuItem->Location, &LocationInScreenSpace );

    if ( m_fRightHandCursor.x < LocationInScreenSpace.x1 || m_fRightHandCursor.x > LocationInScreenSpace.x2 ||
         m_fRightHandCursor.y < LocationInScreenSpace.y1 || m_fRightHandCursor.y > LocationInScreenSpace.y2    )
        {
            return FALSE;
        }

    return TRUE;
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::ConvertRectToScreenSpace()
// Desc: Converts a rectangle from menu units to the actual on screen position.
//--------------------------------------------------------------------------------------
VOID NuiMenu::ConvertRectToScreenSpace( const D3DRECT* pLocation, D3DRECT* pLocationInScreenSpace ) const
{
    assert( pLocation != NULL );
    assert( pLocationInScreenSpace != NULL );

    assert( m_dwColumnCount > 0 );
    assert( m_dwRowCount > 0 );

    pLocationInScreenSpace->x1 = ( DWORD )( pLocation->x1 / ( FLOAT )m_dwColumnCount  * m_dwBackBufferWidth  );
    pLocationInScreenSpace->y1 = ( DWORD )( pLocation->y1 / ( FLOAT )m_dwRowCount     * m_dwBackBufferHeight );
    pLocationInScreenSpace->x2 = ( DWORD )( pLocation->x2 / ( FLOAT )m_dwColumnCount  * m_dwBackBufferWidth  );
    pLocationInScreenSpace->y2 = ( DWORD )( pLocation->y2 / ( FLOAT )m_dwRowCount     * m_dwBackBufferHeight );
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::ConvertPointToScreenSpace()
// Desc: Converts a point from menu units to the actual on screen position.
//--------------------------------------------------------------------------------------
XMFLOAT2 NuiMenu::ConvertPointToScreenSpace( DWORD dwX, DWORD dwY ) const
{
    assert( m_dwColumnCount > 0 );
    assert( m_dwRowCount > 0 );

    return XMFLOAT2( dwX / ( FLOAT )m_dwColumnCount  * m_dwBackBufferWidth, dwY / ( FLOAT )m_dwRowCount * m_dwBackBufferHeight );
}


//--------------------------------------------------------------------------------------
// Name: NuiMenu::GetXYForVector()
// Desc: Map normalized space coordinates to screen space.
//--------------------------------------------------------------------------------------
XMFLOAT2 NuiMenu::GetXYForVector( FXMVECTOR vNormalizedSpace ) const
{
    assert( m_dwBackBufferWidth  > 0 );
    assert( m_dwBackBufferHeight > 0 );

    XMFLOAT2 rt;
    rt.x = XMVectorGetX( vNormalizedSpace ) * m_dwBackBufferWidth + m_dwBackBufferWidth;           
    rt.y = m_dwBackBufferHeight - ( XMVectorGetY( vNormalizedSpace ) * m_dwBackBufferHeight / 2 + m_dwBackBufferHeight / 2 );

    return rt;
}


}; // namespace ATG
```

`XenonDumper/libs/Atg/AtgNuiMenu.h`:

```h
//--------------------------------------------------------------------------------------
// AtgNuiMenu.h
//
//
// Advanced Technology Group (ATG)
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------

#pragma once
#ifndef ATG_NUI_MENU_H
#define ATG_NUI_MENU_H


#include <NuiApi.h>
#include <nuihandles.h>
#include "AtgFont.h"


//--------------------------------------------------------------------------------------
// Name: NUI_MENU_ITEM macros
// Desc: Series of helper macros that ensure proper initialization of NUI_MENU_ITEM 
//       structures.
//--------------------------------------------------------------------------------------
#define ATG_NUI_MENU_ITEM_BUTTON( X, Y, Width, Height, dwItemID, szText )    { dwItemID, ATG::NUI_MENU_ITEM_BUTTON,       TRUE, FALSE, { X, Y, X + Width, Y + Height }, szText, 0 }
#define ATG_NUI_MENU_ITEM_CHECK_BOX( X, Y, Width, Height, dwItemID, szText ) { dwItemID, ATG::NUI_MENU_ITEM_CHECK_BOX,    TRUE, FALSE, { X, Y, X + Width, Y + Height }, szText, 0 }
#define ATG_NUI_MENU_ITEM_FRAME( X, Y, Width, Height, dwItemID )             { dwItemID, ATG::NUI_MENU_ITEM_FRAME,        TRUE, FALSE, { X, Y, X + Width, Y + Height }, NULL,   0 }
#define ATG_NUI_MENU_ITEM_PANEL( X, Y, Width, Height, dwItemID )             { dwItemID, ATG::NUI_MENU_ITEM_PANEL,        TRUE, FALSE, { X, Y, X + Width, Y + Height }, NULL,   0 }
#define ATG_NUI_MENU_ITEM_PROGRESS_BAR( X, Y, Width, Height, dwItemID )      { dwItemID, ATG::NUI_MENU_ITEM_PROGRESS_BAR, TRUE, FALSE, { X, Y, X + Width, Y + Height }, NULL,   0 }
#define ATG_NUI_MENU_ITEM_SPINNER( X, Y, Width, Height, dwItemID )           { dwItemID, ATG::NUI_MENU_ITEM_SPINNER,      TRUE, FALSE, { X, Y, X + Width, Y + Height }, NULL,   0 }
#define ATG_NUI_MENU_ITEM_TEXT( X, Y, Width, Height, dwItemID, szText )      { dwItemID, ATG::NUI_MENU_ITEM_TEXT,         TRUE, FALSE, { X, Y, X + Width, Y + Height }, szText, ATGFONT_CENTER_X }
#define ATG_NUI_MENU_ITEM_TEXT_LEFT( X, Y, Width, Height, dwItemID, szText ) { dwItemID, ATG::NUI_MENU_ITEM_TEXT,         TRUE, FALSE, { X, Y, X + Width, Y + Height }, szText, ATGFONT_LEFT }


namespace ATG
{

// Cursor sizes
const DWORD NUI_MENU_DEFAULT_CROSSHAIR_SIZE         = 40;     // in pixels
const DWORD NUI_MENU_DEFAULT_CROSSHAIR_THICKNESS    =  3;     // in pixels

// Time in milliseconds the cursor must hover over a button in order to select it.
// 1.2 seconds seem a reasonable time, being neither to quick or too slow...
const DWORD NUI_MENU_DEFAULT_HOVER_TIME = 750;  

// Default spinner speed
const FLOAT NUI_MENU_DEFAULT_SPINNER_SPEED = 0.06f;

// Default color used for drawing a menu
const D3DCOLOR NUI_MENU_DEFAULT_CURSOR_COLOR      = 0xffffffff;
const D3DCOLOR NUI_MENU_DEFAULT_PANEL_COLOR       = 0xff000000;
const D3DCOLOR NUI_MENU_DEFAULT_SELECTABLE_COLOR  = 0xff006600;
const D3DCOLOR NUI_MENU_DEFAULT_SELECTED_COLOR    = 0xff00ff00;
const D3DCOLOR NUI_MENU_DEFAULT_STATIC_COLOR      = 0xffffffff;


// Pre-defined menu item values.
const DWORD NUI_MENU_ITEM_ID_NONE       = 0xffffffff;
const DWORD NUI_MENU_ITEM_ID_UNDEFINED  = 0xfffffffe;


//--------------------------------------------------------------------------------------
// Name: enum HOVERED_ITEM_STATE
// Desc: Specifies the state of an item being hovered by the cursor. 
//--------------------------------------------------------------------------------------
enum HOVERED_ITEM_STATE
{
    HOVERED_ITEM_STATE_NOT_SELECTED = 0, // The cursor maybe hovering the item but the time threshold hasn't been met.
    HOVERED_ITEM_STATE_JUST_SELECTED,    // The selection time threshold was just pass during the present menu update. 
    HOVERED_ITEM_STATE_SELECTED,         // The selection is still selected. No new notification will be sent.
};


//--------------------------------------------------------------------------------------
// Name: struct NUI_MENU_SETTINGS 
// Desc: Defines menu wide configurable settings
//--------------------------------------------------------------------------------------
struct NUI_MENU_SETTINGS
{
    DWORD dwCursorSizeInPixels;      // Width and height of the cursor in pixels.
    DWORD dwCursorThicknessInPixels; // Thickness of the lines defining the cursor, in pixels.
    DWORD dwHoverTime;               // Time, in millisecond, that the cursor must hover a item before it is selected.

    D3DCOLOR cursorColor;     // Color used to draw the curor
    D3DCOLOR panelColor;      // Color used to draw opaque panel items
    D3DCOLOR selectableColor; // Color used to display selectable buttons
    D3DCOLOR selectedColor;   // Color used to display buttons when the cursor is on top
    D3DCOLOR staticColor;     // Color used for non-selectable displaying menu items

    BOOL bDrawGuide; // If TRUE, a helper alignment grid will be drawn on top of the menu items.
};


//--------------------------------------------------------------------------------------
// Name: enum NUI_MENU_ITEM_TYPE 
// Desc: Supported menu item types
//--------------------------------------------------------------------------------------
enum NUI_MENU_ITEM_TYPE 
{ 
    NUI_MENU_ITEM_BUTTON = 0,   // A button is a selectable item
    NUI_MENU_ITEM_CHECK_BOX,    // Check boxes are selectable square with text on the right.
    NUI_MENU_ITEM_FRAME,        // A frame is a rectangle outline and is a static item
    NUI_MENU_ITEM_PANEL,        // A Panel is a filled rectangle, static item
    NUI_MENU_ITEM_PROGRESS_BAR, // Static item that graphically indicates some measure of progress 
    NUI_MENU_ITEM_SPINNER,      // A squre moving right to left to right indicating the system is 
                                // perforing an operation
    NUI_MENU_ITEM_TEXT ,        // A static text item that can either be centered or left aligned

    NUI_MENU_ITEM_COUNT         // Maximum number of items supported by NuiMenu
};


//--------------------------------------------------------------------------------------
// Name: struct NUI_MENU_ITEM
// Desc: Holds all data pertaining to a specific item.
//--------------------------------------------------------------------------------------
struct NUI_MENU_ITEM
{
    DWORD               dwItemID;  // ID to uniquely identify this item.
    NUI_MENU_ITEM_TYPE  eItemType; // Type of item.
    BOOL                bEnabled;  // Item is enabled if this is set to TRUE
    BOOL                bHidden;   // Item is hidden if this is set to TRUE
    D3DRECT             Location;  // On-screen corrdinates 
    LPCWSTR             szText;    // Point to the item text.
    
    union
    {
        // Extra data specific to different item types.
        // The dwValue must be the first item of the union, for initialization macros to work correctly.
        DWORD dwValue;
        BOOL  bValue;
        FLOAT fValue;
    };
};


//--------------------------------------------------------------------------------------
// Name: class NuiMenu
// Desc: Handles selecting menu items, rendering, etc.
//--------------------------------------------------------------------------------------
class NuiMenu
{
public:
    NuiMenu();
	~NuiMenu();

    HRESULT Initialize( ::D3DDevice* pd3dDevice, DWORD dwBackBufferWidth, DWORD dwBackBufferHeight, ATG::Font* pFont );

    VOID SetMenuLayout( NUI_MENU_ITEM aMenuItem[], DWORD dwItemCount, DWORD dwColumnCount, DWORD dwRowCount );

    HRESULT Update( const NUI_SKELETON_FRAME* pUnfilteredSkeletonFrame, 
                    DWORD dwControllingTrackingID, 
                    const NUI_IMAGE_FRAME* pDepthFrame320x240, 
                    const NUI_IMAGE_FRAME* pDepthFrame80x60 );

    VOID Render() const;

    DWORD GetActiveItem() const;
    VOID ClearActiveItem();

    VOID GetMenuSettings( NUI_MENU_SETTINGS* pNuiMenuSettings ) const ;
    VOID SetMenuSettings( const NUI_MENU_SETTINGS* pNuiMenuSettings );

    VOID DisableMenu() { if( ! m_bIsDisabled ){ m_bIsDisabled = TRUE; ClearActiveItem(); } };
    VOID EnableMenu() { if( m_bIsDisabled ){ m_bIsDisabled = FALSE; NuiHandlesArmsInit( &m_HandlesArms ); } };

    HRESULT EnableItem( DWORD dwItemID );
    HRESULT DisableItem( DWORD dwItemID );

    HRESULT ShowItem( DWORD dwItemID );
    HRESULT HideItem( DWORD dwItemID );

    HRESULT SetItemText( DWORD dwItemID, LPCWSTR wszText );
    HRESULT SetItemSelectedState( DWORD dwItemID, BOOL bSelected );
    HRESULT SetItemProgress( DWORD dwItemID, FLOAT fProgress );


private:
    NuiMenu( const NuiMenu& rhs );
    NuiMenu& operator =( const NuiMenu& rhs );

    VOID DrawAlignmentGrid() const;
    VOID DrawButton( const D3DRECT* pLocation, LPCWSTR wszText, D3DCOLOR color ) const;
    VOID DrawCheckBox( const D3DRECT* pLocation, LPCWSTR wszText, D3DCOLOR color, BOOL bChecked ) const;
    VOID DrawCursor() const;
    VOID DrawFrame( const D3DRECT* pLocation, D3DCOLOR color ) const;
    VOID DrawPanel( const D3DRECT* pLocation, D3DCOLOR color ) const;
    VOID DrawProgressBar( const D3DRECT* pLocation, FLOAT fProgress, D3DCOLOR color ) const;
    VOID DrawSpinner( const D3DRECT* pLocation, FLOAT fProgress, D3DCOLOR color ) const;
    VOID DrawText( const D3DRECT* pLocation, LPCWSTR wszText, D3DCOLOR color, DWORD dwHorizontalAlignment ) const;

    const NUI_MENU_ITEM* GetMenuItemFromItemID( DWORD dwItemID ) const;
    NUI_MENU_ITEM* GetMenuItemFromItemID( DWORD dwItemID );

    BOOL IsCursorOverItem( const NUI_MENU_ITEM* pMenuItem ) const;
    
    VOID ConvertRectToScreenSpace( const D3DRECT* pLocation, D3DRECT* pLocationInScreenSpace ) const;
    XMFLOAT2 ConvertPointToScreenSpace( DWORD dwX, DWORD dwY ) const;
    XMFLOAT2 GetXYForVector( FXMVECTOR vNormalizedSpace ) const;

    // Menu wide configuration information
    BOOL               m_bIsDisabled; // The whole menu is disabled when set to TRUE. 
    NUI_MENU_SETTINGS  m_settings;    // Settings currently in use.

    // Menu information as defined by the calling application.
    NUI_MENU_ITEM*     m_pMenuItemList; // Pointer to a static list of menu item held by the calling application.
    DWORD              m_dwItemCount;   // Number of menu items in the preceding item list
    DWORD              m_dwColumnCount; // Number of horizontal menu units
    DWORD              m_dwRowCount;    // Number of vertical menu units 

    // Data related to the item curently being hovered, if it is a selectable item.
    DWORD              m_dwHoveredItemID;   // The item ID of the item being hovered or NUI_MENU_ITEM_ID_NONE
    LARGE_INTEGER      m_liHoverBeginTime;  // Time at which the cursor moved onto the item
    HOVERED_ITEM_STATE m_eHoveredItemState; // Selection state of the hovered item.

    LARGE_INTEGER      m_liCurrentTime; // Current time. Updated from the SkeletonFrame each time the Update function is called.

    // Cursor tracking info
    NUI_HANDLES_ARMS   m_HandlesArms;      // Nui handle data structure
    XMFLOAT2           m_fRightHandCursor; // Right hand ( and cursor ) location

    // System resources used by MenuManager.
    ::D3DDevice*       m_pd3dDevice;
    DWORD              m_dwBackBufferWidth;
    DWORD              m_dwBackBufferHeight;
    ATG::Font*         m_pFont;
};


}; // namespace ATG


#endif // ATG_NUI_MENU_H
```

`XenonDumper/libs/Atg/AtgNuiRelativeCoordinates.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// AtgNuiReletiveCoordinates.cpp
//
// This class maintains a body reletive coordainte system for NUI Samples
//
// Microsoft Advanced Technology Group
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------

#include "stdafx.h"
#include "AtgNuiRelativeCoordinates.h"
#include "AtgUtil.h"

namespace ATG
{
    //-------------------------------------------------------------------------------------
    // Name: Lerp()
    // Desc: Linear interpolation between two floats
    //-------------------------------------------------------------------------------------
    inline FLOAT Lerp( FLOAT f1, FLOAT f2, FLOAT fBlend )
    {
        return f1 + (f2-f1) * fBlend;
    }

 
    SpineRelativeCameraSpaceCoordinateSystem::SpineRelativeCameraSpaceCoordinateSystem( ) : 
        m_dwLastTrackingID( 0 ),
        m_fAverageSpineHeadLength( 0.0f ),
        m_vAverageNormalToGravity( XMVectorZero() )
    {    
        m_vAverageSpine = XMVectorSet( 0.0f, 0.0f, 0.0f, 1.0f ); 
        m_vRightHandRelative = XMVectorSet( 0.0f, 0.0f, 0.0f, 0.0f ); 
        m_vLeftHandRelative = XMVectorSet( 0.0f, 0.0f, 0.0f, 0.0f );

        // Call the updates function with default parameters
        SetUpdateRates(); 
    }

    //--------------------------------------------------------------------------------------
    // Name: SetUpdateRates()
    // Desc: Initializes the update rates used for filtering the spine coordinates and 
    //       body size related lengths used in this class. These are left and right hand length, 
    //       shoulder length, and spine to head length.  An update rate closer to 1.0f results 
    //       in more smoothing and adds some lagging when there is a fast body movement. 
    //--------------------------------------------------------------------------------------
    VOID SpineRelativeCameraSpaceCoordinateSystem::SetUpdateRates( FLOAT fSpineUpdateRate, FLOAT fBodySizeUpdateRate )
    {
        m_fBodySizeUpdateRate = max( 0.0f, min( 1.0f, fBodySizeUpdateRate ) );
        m_fSpineUpdateRate = max( 0.0f, min( 1.0f, fSpineUpdateRate ) );
    }

    //--------------------------------------------------------------------------------------
    // Name: Reset()
    // Desc: Resets the coordinate system. This method should be called if this class
    //       is to be used for a new player skeleton.
    //--------------------------------------------------------------------------------------
    VOID SpineRelativeCameraSpaceCoordinateSystem::Reset( )
    {
        m_vAverageNormalToGravity = XMVectorZero();
        m_dwLastTrackingID = 0;
        m_fAverageSpineHeadLength = 0.0f;
        m_vAverageSpine = XMVectorSet( 0.0f, 0.0f, 0.0f, 1.0f ); 
        m_vRightHandRelative = XMVectorSet( 0.0f, 0.0f, 0.0f, 0.0f ); 
        m_vLeftHandRelative = XMVectorSet( 0.0f, 0.0f, 0.0f, 0.0f );
    }

    //--------------------------------------------------------------------------------------
    // Name: Update()
    // Desc: Adds a new frame of positions, updates the coordiante system, and calculates 
    //       left and right hand.
    //--------------------------------------------------------------------------------------
    VOID SpineRelativeCameraSpaceCoordinateSystem::Update( const NUI_SKELETON_FRAME* pRawSkeletonFrame, INT iSkeletonIndex, XMVECTOR vLeft, XMVECTOR vRight )
    {
        if ( pRawSkeletonFrame == NULL ) return;
        if ( iSkeletonIndex < 0 || iSkeletonIndex >= NUI_SKELETON_COUNT ) return;
        CONST XMVECTOR *pSkeletonPosition = &pRawSkeletonFrame->SkeletonData[iSkeletonIndex].SkeletonPositions[0];

        if ( m_dwLastTrackingID != pRawSkeletonFrame->SkeletonData[iSkeletonIndex].dwTrackingID )
        {
            m_vAverageNormalToGravity = pRawSkeletonFrame->vNormalToGravity;
        }
        else
        {
            m_vAverageNormalToGravity = m_fSpineUpdateRate * m_vAverageNormalToGravity +
                 pRawSkeletonFrame->vNormalToGravity * ( 1.0f - m_fSpineUpdateRate );
        }
        
#if 0
        CHAR out[255];
        sprintf_s( out, "x=%f,y=%f,z=%f,w=%f\n", pRawSkeletonFrame->vNormalToGravity.x, pRawSkeletonFrame->vNormalToGravity.y, pRawSkeletonFrame->vNormalToGravity.z, pRawSkeletonFrame->vNormalToGravity.w );
        OutputDebugString( out );
#endif 
        m_matRotateToNormalToGravity = NuiTransformMatrixLevel( m_vAverageNormalToGravity );
        XMVECTOR vSpineTilted = XMVector3Transform( pSkeletonPosition[NUI_SKELETON_POSITION_SPINE], m_matRotateToNormalToGravity );
        XMVECTOR vHeadTilted = XMVector3Transform( pSkeletonPosition[NUI_SKELETON_POSITION_HEAD], m_matRotateToNormalToGravity );
        m_vLeftHandRelative = XMVector3Transform( vLeft, m_matRotateToNormalToGravity );
        m_vRightHandRelative = XMVector3Transform( vRight, m_matRotateToNormalToGravity );


        FLOAT fSpineHeadLength = XMVectorGetY( vHeadTilted ) - XMVectorGetY( vSpineTilted );
        if ( m_dwLastTrackingID != pRawSkeletonFrame->SkeletonData[iSkeletonIndex].dwTrackingID )
        {
            m_dwLastTrackingID = pRawSkeletonFrame->SkeletonData[iSkeletonIndex].dwTrackingID;
            m_vAverageSpine = vSpineTilted;
            m_fAverageSpineHeadLength = fSpineHeadLength;
        }
        else
        {
            m_vAverageSpine = m_vAverageSpine * m_fSpineUpdateRate + 
                vSpineTilted * ( 1.0f - m_fSpineUpdateRate );
            m_fAverageSpineHeadLength = ATG::Lerp( fSpineHeadLength, m_fAverageSpineHeadLength, m_fBodySizeUpdateRate );
        }

        m_vEstiamtedPivotOffsetLeft = XMVectorSet( m_fAverageSpineHeadLength * 0.3f, m_fAverageSpineHeadLength * 0.1f, 0.0f, 0.0f );
        m_vEstiamtedPivotOffsetRight = XMVectorSet( -m_fAverageSpineHeadLength * 0.3f, m_fAverageSpineHeadLength * 0.1f, 0.0f, 0.0f );
        m_vRightHandRelative -= m_vAverageSpine;
        m_vRightHandRelative += m_vEstiamtedPivotOffsetRight;
        m_vLeftHandRelative -= m_vAverageSpine;
        m_vLeftHandRelative += m_vEstiamtedPivotOffsetLeft;
        static XMVECTOR vFlipZ = XMVectorSet( 1.0f, 1.0f, -1.0f, 1.0f );
        m_vRightHandRelative *= vFlipZ;
        m_vLeftHandRelative *= vFlipZ;

    }

    //--------------------------------------------------------------------------------------
    // Name: Update()
    // Desc: Returns the Right hand in the body reletive coordinate system.
    //--------------------------------------------------------------------------------------
    XMVECTOR SpineRelativeCameraSpaceCoordinateSystem::GetRightHandReletive()
    {
        return m_vRightHandRelative;
    }

    //--------------------------------------------------------------------------------------
    // Name: Update()
    // Desc: Returns the left hand in the body reletive coordinate system.
    //--------------------------------------------------------------------------------------
    XMVECTOR SpineRelativeCameraSpaceCoordinateSystem::GetLeftHandReletive() 
    {
        return m_vLeftHandRelative;    
    }

} // namespace ATG


```

`XenonDumper/libs/Atg/AtgNuiRelativeCoordinates.h`:

```h
//--------------------------------------------------------------------------------------
// AtgNuiReletiveCoordinates.h
//
// This class maintains a body reletive coordainte system for NUI Samples
//
// Microsoft Advanced Technology Group
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------

#pragma once

#ifndef _ATG_NUI_BODY_RELETIVE_COORDINATES_
#define _ATG_NUI_BODY_RELETIVE_COORDINATES_

#include <nuiapi.h>
#include <xnamath.h>
#include "ATGNuiJointFilter.h"
#include "AtgUtil.h"

#pragma warning( disable:4324 )

namespace ATG
{

static const FLOAT BODY_RELATIVE_SPINE_UPDATE_RATE = 0.95f;
static const FLOAT BODY_RELATIVE_BODY_SIZE_UPDATE_RATE = 0.98f;

class SpineRelativeCameraSpaceCoordinateSystem
{
public:

    SpineRelativeCameraSpaceCoordinateSystem( );

    VOID SetUpdateRates( FLOAT fSpineUpdateRate = BODY_RELATIVE_SPINE_UPDATE_RATE, FLOAT fBodySizeUpdateRate = BODY_RELATIVE_BODY_SIZE_UPDATE_RATE );

    VOID Reset( );

    VOID Update( const NUI_SKELETON_FRAME* pRawSkeletonFrame, INT iSkeletonIndex, XMVECTOR vLeft, XMVECTOR vRight );

    XMVECTOR GetRightHandReletive( );
    XMVECTOR GetLeftHandReletive( );    
    XMVECTOR GetAverageSpine( ) { return m_vAverageSpine; };
    XMMATRIX GetRotateToNormalToGravityMatrix() { return m_matRotateToNormalToGravity; };
    XMVECTOR GetEstiamtedPivotOffsetLeft() { return m_vEstiamtedPivotOffsetLeft; };
    XMVECTOR GetEstiamtedPivotOffsetRight() { return m_vEstiamtedPivotOffsetRight; };
    FLOAT GetAverageSpineHeadLength() { return m_fAverageSpineHeadLength; };

private:

    DWORD       m_dwLastTrackingID;
    
    XMVECTOR    m_vAverageSpine;
    FLOAT       m_fAverageSpineHeadLength;

    FLOAT       m_fBodySizeUpdateRate;
    FLOAT       m_fSpineUpdateRate;
    
    XMVECTOR    m_vAverageNormalToGravity;
    XMVECTOR    m_vRightHandRelative;       
    XMVECTOR    m_vLeftHandRelative;
    XMMATRIX    m_matRotateToNormalToGravity;
    XMVECTOR    m_vEstiamtedPivotOffsetLeft;
    XMVECTOR    m_vEstiamtedPivotOffsetRight;

   
};

} // namespace ATG

#endif  // _ATG_NUI_BODY_RELETIVE_COORDINATES_
```

`XenonDumper/libs/Atg/AtgNuiVisualization.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// AtgNuiVisualization.cpp
//
// Visualization tools for Kinect
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#include "stdafx.h"
#include "AtgDebugDraw.h"
#include "AtgNuiVisualization.h"
#include "AtgUtil.h"


const FLOAT EPSILON = 5.96e-08f;

#define MIN( v1, v2) ( v1 ) < ( v2 ) ? ( v1 ) : ( v2 )
#define MAX( v1, v2) ( v1 ) > ( v2 ) ? ( v1 ) : ( v2 )
#define CLAMP( value, min, max ) MIN( max, MAX( value, min ) )

namespace ATG
{

BOOL ClipLineToRect( XMFLOAT2* origin, XMFLOAT2* end, FLOAT fLeft, FLOAT fTop, FLOAT fWidth, FLOAT fHeight )
{
    FLOAT fBottom = fTop + fHeight;
    FLOAT fRight  = fLeft + fWidth;

    if( origin->x > fLeft && origin->x < fRight &&
        origin->y > fTop && origin->y < fBottom &&
        end->x > fLeft && end->x < fRight       &&
        end->y > fTop && end->y < fBottom          )
    {
        return TRUE;
    }

    if( origin->x < fLeft && end->x < fLeft     ||
        origin->x > fRight && end->x > fRight      )
    {
        return FALSE;
    }

    if( origin->y < fTop && end->y < fTop       ||
        origin->y > fBottom && end->y > fBottom    )
    {
        return FALSE;
    }

    if( XMScalarNearEqual( origin->x, end->x, EPSILON ) )
    {
        origin->y = CLAMP( origin->y, fTop, fBottom );
        end->y = CLAMP( end->y, fTop, fBottom );
    }
    else if( XMScalarNearEqual( origin->y, end->y, EPSILON ) )
    {
        origin->x = CLAMP( origin->x, fLeft, fRight );
        end->x = CLAMP( end->x, fLeft, fRight );
    }
    else
    {
        FLOAT fSlope = ( end->y - origin->y ) / ( end->x - origin->x );
        FLOAT fYIntercept = ( origin->y - origin->x * fSlope );

        if( origin->x < fLeft )
        {
            origin->x = fLeft;
            origin->y = fSlope * origin->x + fYIntercept;
        }
        else if( origin->x > fRight )
        {
            origin->x = fRight;
            origin->y = fSlope * origin->x + fYIntercept;
        }

        if( end->x < fLeft )
        {
            end->x = fLeft;
            end->y = fSlope * end->x + fYIntercept;
        }
        else if( end->x > fRight )
        {
            end->x = fRight;
            end->y = fSlope * end->x + fYIntercept;
        }

        if( origin->y < fTop )
        {
            origin->y = fTop;
            origin->x = ( origin->y - fYIntercept ) / fSlope;
        }
        else if( origin->y > fBottom )
        {
            origin->y = fBottom;
            origin->x = ( origin->y - fYIntercept ) / fSlope;
        }

        if( end->y < fTop )
        {
            end->y = fTop;
            end->x = ( end->y - fYIntercept ) / fSlope;
        }
        else if( end->y > fBottom )
        {
            end->y = fBottom;
            end->x = ( end->y - fYIntercept ) / fSlope;
        }
    }

    if( origin->x > fLeft - 0.5f && origin->x < fRight + 0.5f &&
        origin->y > fTop - 0.5f && origin->y < fBottom + 0.5f &&
        end->x > fLeft - 0.5f && end->x < fRight + 0.5f       &&
        end->y > fTop - 0.5f && end->y < fBottom + 0.5f          )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

// By default, use green when a bone is tracked and red when it is inferred.
#define BONE_CONFIDENCE_TRACKED_COLOR   0xff00ff00
#define BONE_CONFIDENCE_INFERRED_COLOR  0xffff0000


// Define the bones in the skeleton using joint indices
const NUI_VISUALIZATION_BONE_JOINTS g_SkeletonBoneList[] =
{
    // Head
    { NUI_SKELETON_POSITION_HEAD,            NUI_SKELETON_POSITION_SHOULDER_CENTER },  // Top of head to top of neck

    // Right arm
    { NUI_SKELETON_POSITION_SHOULDER_CENTER, NUI_SKELETON_POSITION_SHOULDER_RIGHT },   // Neck bottom to right shoulder internal
    { NUI_SKELETON_POSITION_SHOULDER_RIGHT,  NUI_SKELETON_POSITION_ELBOW_RIGHT },      // Right shoulder internal to right elbow
    { NUI_SKELETON_POSITION_ELBOW_RIGHT,     NUI_SKELETON_POSITION_WRIST_RIGHT },      // Right elbow to right wrist
    { NUI_SKELETON_POSITION_WRIST_RIGHT,     NUI_SKELETON_POSITION_HAND_RIGHT },       // Right wrist to right hand

    // Left arm
    { NUI_SKELETON_POSITION_SHOULDER_CENTER, NUI_SKELETON_POSITION_SHOULDER_LEFT },    // Neck bottom to left shoulder internal
    { NUI_SKELETON_POSITION_SHOULDER_LEFT,   NUI_SKELETON_POSITION_ELBOW_LEFT },       // Left shoulder internal to left elbow
    { NUI_SKELETON_POSITION_ELBOW_LEFT,      NUI_SKELETON_POSITION_WRIST_LEFT },       // Left elbow to left wrist
    { NUI_SKELETON_POSITION_WRIST_LEFT,      NUI_SKELETON_POSITION_HAND_LEFT },        // Left wrist to left hand

    // Right leg and foot
    { NUI_SKELETON_POSITION_HIP_RIGHT,       NUI_SKELETON_POSITION_KNEE_RIGHT  },      // Right hip internal to right knee
    { NUI_SKELETON_POSITION_KNEE_RIGHT,      NUI_SKELETON_POSITION_ANKLE_RIGHT },      // Right knee to right ankle
    { NUI_SKELETON_POSITION_ANKLE_RIGHT,     NUI_SKELETON_POSITION_FOOT_RIGHT },       // Right ankle to right foot

    // Left leg and foot
    { NUI_SKELETON_POSITION_HIP_LEFT,        NUI_SKELETON_POSITION_KNEE_LEFT  },       // Left hip internal to left knee
    { NUI_SKELETON_POSITION_KNEE_LEFT,       NUI_SKELETON_POSITION_ANKLE_LEFT },       // Left knee to left ankle
    { NUI_SKELETON_POSITION_ANKLE_LEFT,      NUI_SKELETON_POSITION_FOOT_LEFT },        // Left ankle to left foot

    // Spine
    { NUI_SKELETON_POSITION_SHOULDER_CENTER, NUI_SKELETON_POSITION_SPINE },            // Neck bottom to spine
    { NUI_SKELETON_POSITION_SPINE,           NUI_SKELETON_POSITION_HIP_CENTER },       // Spine to hip center

    // Hips
    { NUI_SKELETON_POSITION_HIP_RIGHT,       NUI_SKELETON_POSITION_HIP_CENTER },       // Right hip to hip center
    { NUI_SKELETON_POSITION_HIP_CENTER,      NUI_SKELETON_POSITION_HIP_LEFT }          // Hip center to left hip
};

const UINT g_uSkeletonBoneCount = ARRAYSIZE( g_SkeletonBoneList );


//-------------------------------------------------------------------------------------
// Video and pixel shader definitions
//-------------------------------------------------------------------------------------
static const char*  g_strVideoShaderHLSL =
    " struct VS_OUT                                                              "
    " {                                                                          "
    "     float4 Position : POSITION;                                            "
    "     float2 TexCoord : TEXCOORD0;                                           "
    " };                                                                         "
    "                                                                            "
    " sampler VideoTexture : register(s0);                                       "
    "                                                                            "
    " VS_OUT VideoVertexShader( const float3 Position : POSITION,                "
    "                           const float2 TexCoord : TEXCOORD0 )              "
    " {                                                                          "
    "     VS_OUT Output;                                                         "
    "     Output.Position.x  = ( Position.x-0.5);                                "
    "     Output.Position.y  = ( Position.y-0.5);                                "
    "     Output.Position.z  = ( 0.0 );                                          "
    "     Output.Position.w  = ( 1.0 );                                          "
    "     Output.TexCoord = TexCoord;                                            "
    "     return Output;                                                         "
    " }                                                                          "
    "                                                                            "
    " float4 VideoPixelShader( VS_OUT Input ) : COLOR                            "
    " {                                                                          "
    "     return tex2D( VideoTexture, Input.TexCoord );                          "
    " }                                                                          ";

struct VideoFeedVertex
{
    FLOAT vPosition[ 3 ];
    FLOAT vTexCoords[ 2 ];
};

struct DepthPreviewVertex
{
    FLOAT x, y;
    FLOAT u, v;
};

//--------------------------------------------------------------------------------------
// Name: NUI_VISUALIZATION_SKELETON_RENDER_INFO::SplatTrackedColor
// Desc: Initializes a NUI_VISUALIZATION_SKELETON_RENDER_INFO structure.
//--------------------------------------------------------------------------------------
VOID NUI_VISUALIZATION_SKELETON_RENDER_INFO::Initialize( D3DCOLOR trackedColor, D3DCOLOR inferredColor, BOOL draw )
{ 
    for( UINT i = 0; i < NUI_SKELETON_POSITION_COUNT; ++ i )
    {
        bDraw[ i ] = draw;
        TrackedColor[ i ] = trackedColor; 
        InferredColor[ i ] = inferredColor;
    }
}


//--------------------------------------------------------------------------------------
// Name: NUI_VISUALIZATION_SKELETON_RENDER_INFO::SplatTrackedColor
// Desc: Set the color used to draw a tracked skeleton joint to the same value for the 
//       all the joints of the specified skeleton.
//--------------------------------------------------------------------------------------
VOID NUI_VISUALIZATION_SKELETON_RENDER_INFO::SplatTrackedColor( D3DCOLOR trackedColor) 
{ 
    for( UINT i = 0; i < NUI_SKELETON_POSITION_COUNT; ++ i )
    {
        TrackedColor[ i ] = trackedColor; 
    }
}


//--------------------------------------------------------------------------------------
// Name: NUI_VISUALIZATION_SKELETON_RENDER_INFO::SplatInferredColor
// Desc: Set the color used to draw a inferred skeleton joint to the same value for the 
//       all the joints of the specified skeleton.
//--------------------------------------------------------------------------------------
VOID NUI_VISUALIZATION_SKELETON_RENDER_INFO::SplatInferredColor( D3DCOLOR inferredColor )
{ 
    for( UINT i = 0; i < NUI_SKELETON_POSITION_COUNT; ++ i ) 
    {
        InferredColor[ i ] = inferredColor;
    }
}


//--------------------------------------------------------------------------------------
// Name: NuiVisualization
// Desc: Constructs a NuiVisualization object.
//--------------------------------------------------------------------------------------
NuiVisualization::NuiVisualization()
:m_bIsInitialized( FALSE ),
 m_pSmoothDepthTexture( NULL ),
 m_pSmoothDepthTextureSwap( NULL ),
 m_pNuiDepthTexture( NULL ),
 m_pDepthPreviewPS( NULL ),
 m_pDepthPreviewSmoothingVS( NULL ),
 m_bColorIsNew( FALSE ),
 m_colorDisplaying( 0 ),
 m_depthDisplaying( 0 ),
 m_colorImageResolution( NUI_IMAGE_RESOLUTION_640x480 ),
 m_dwColorStreamWidth( 640 ),
 m_dwColorStreamHeight( 480 ),
 m_dwNestedBeginCount( 0 )
{
    for( UINT i = 0 ; i < 2; ++ i )
    {
        m_pColorTexture[ i ] = NULL;
        m_pDepthTexture[ i ] = NULL;
    }

    XMemSet( &m_SkeletonFrame, 0, sizeof( NUI_SKELETON_FRAME ) );
    XMemSet( &m_colorViewArea, 0, sizeof( m_colorViewArea) );

    for( UINT i = 0 ; i < NUI_SKELETON_COUNT; ++ i )
        m_SkeletonRenderInfo[ i ].Initialize( BONE_CONFIDENCE_TRACKED_COLOR, BONE_CONFIDENCE_INFERRED_COLOR );
}

//--------------------------------------------------------------------------------------
// Name: ~NuiVisualization
// Desc: Destroys the object and releases all the buffers previously allocated.
//--------------------------------------------------------------------------------------
NuiVisualization::~NuiVisualization()
{
}


//--------------------------------------------------------------------------------------
// Name: Initialize
// Desc: Allocates and initializes the required buffers and system resources.
//       Use dwComponentsToProcess to specify which component NuiVisualization will 
//       process. Use flags a combination of the NUI_INITIALIZE_FLAGS flags.
//       Currently NUI_INITIALIZE_FLAG_USES_COLOR, NUI_INITIALIZE_FLAG_USES_DEPTH, 
//       NUI_INITIALIZE_FLAG_USES_DEPTH_AND_PLAYER_INDEX
//       and NUI_INITIALIZE_FLAG_USES_SKELETON flags are supported,
//       if NUI_INITIALIZE_FLAG_USES_COLOR is specified for dwComponentsToProcess then the 
//       colorImageResolution must a value from NUI_IMAGE_RESOLUTION. Otherwise, the 
//       value is ignored.
//--------------------------------------------------------------------------------------
HRESULT NuiVisualization::Initialize( ::D3DDevice* pd3dDevice, DWORD dwComponentsToProcess, 
                                      NUI_IMAGE_RESOLUTION colorImageResolution,
                                      BOOL bRenderDashStyleDepthPreview )
{
    // Pre-conditions
    assert( !m_bIsInitialized );

    m_pd3dDevice = pd3dDevice;
    m_dwComponentsToProcess = dwComponentsToProcess;

    // Set the dimension of each stream since we will be using them during visualization
    if( m_dwComponentsToProcess & NUI_INITIALIZE_FLAG_USES_COLOR )
    {
        m_colorImageResolution = colorImageResolution;
        switch( colorImageResolution )
        {
            case NUI_IMAGE_RESOLUTION_320x240:
                m_dwColorStreamWidth  = 320;
                m_dwColorStreamHeight = 240;
                break;

            case NUI_IMAGE_RESOLUTION_640x480:
                m_dwColorStreamWidth  = 640;
                m_dwColorStreamHeight = 480;
                break;

            default:
                assert( false ); //Unrecognized RESOLUTION
                m_dwColorStreamWidth  = 640;
                m_dwColorStreamHeight = 480;
                break;
        }
    }

    // Setup a ramp lookup table to display depth values as colors
    InitializeDepthColorTable();

    // Compile vertex shader.
    ID3DXBuffer* pVertexShaderCode;
    ID3DXBuffer* pVertexErrorMsg;
    HRESULT hr = D3DXCompileShader( g_strVideoShaderHLSL,
                                   ( UINT )strlen( g_strVideoShaderHLSL ),
                                   NULL,
                                   NULL,
                                   "VideoVertexShader",
                                   "vs_2_0",
                                   0,
                                   &pVertexShaderCode,
                                   &pVertexErrorMsg,
                                   NULL );
    if( FAILED( hr ) )
    {
        return E_FAIL;
    }

    // Create vertex shader.
    pd3dDevice->CreateVertexShader( ( DWORD* )pVertexShaderCode->GetBufferPointer(),
                                    &m_pVideoVertexShader );

    // Compile pixel shader.
    ID3DXBuffer* pPixelShaderCode;
    ID3DXBuffer* pPixelErrorMsg;

    hr = D3DXCompileShader( g_strVideoShaderHLSL,
                            ( UINT )strlen( g_strVideoShaderHLSL ),
                            NULL,
                            NULL,
                            "VideoPixelShader",
                            "ps_2_0",
                            0,
                            &pPixelShaderCode,
                            &pPixelErrorMsg,
                            NULL );
    if( FAILED( hr ) )
    {
        return E_FAIL;
    }

    // Create pixel shader.
    pd3dDevice->CreatePixelShader( ( DWORD* )pPixelShaderCode->GetBufferPointer(),
                                   &m_pVideoPixelShaderRGB );

    // Define the vertex elements and
    // Create a vertex declaration from the element descriptions.
    static const D3DVERTEXELEMENT9 VertexElements[] =
    {
        { 0,  0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0 },
        { 0, 12, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, 0 },
        D3DDECL_END()
    };
    pd3dDevice->CreateVertexDeclaration( VertexElements, &m_pVideoVertexDecl );

    for( UINT i = 0; i < 2; ++ i)
    {
        if( m_dwComponentsToProcess & NUI_INITIALIZE_FLAG_USES_COLOR )
        {
            // Initialize color stream video texture
            if( FAILED( InitializeVideoTextures( pd3dDevice, &m_pColorTexture[ i ], m_dwColorStreamWidth, m_dwColorStreamHeight ) ) )
            {
                return E_FAIL;
            }
        }

        if( m_dwComponentsToProcess & ( NUI_INITIALIZE_FLAG_USES_DEPTH | NUI_INITIALIZE_FLAG_USES_DEPTH_AND_PLAYER_INDEX ) )
        {
            // Initialize depth stream video texture
            if( FAILED( InitializeVideoTextures( pd3dDevice, &m_pDepthTexture[ i ], s_dwDepthStreamWidth, s_dwDepthStreamHeight ) ) )
            {
                return E_FAIL;
            }
        }
    }

    // Are we going to be rendering the dash-style depth-preview?
    if( bRenderDashStyleDepthPreview )
    {
        // Create the vertex and pixel shaders.
        if( FAILED( LoadVertexShader( "game:\\Media\\Shaders\\DepthPreviewSmoothingVS.xvu", &m_pDepthPreviewSmoothingVS ) ) )
        {
            return E_FAIL;
        }

        if( FAILED( LoadPixelShader( "game:\\Media\\Shaders\\DepthPreviewPS.xpu", &m_pDepthPreviewPS ) ) )
        {
            return E_FAIL;
        }

        // Create the depth preview textures.
        if( FAILED( pd3dDevice->CreateTexture( s_dwDashStyleDepthPreviewWidth,
                                               s_dwDashStyleDepthPreviewHeight,
                                               1, 0,
                                               D3DFMT_LIN_D16,
                                               0, 
                                               &m_pSmoothDepthTexture, NULL ) ) )
        {
            return E_FAIL;
        }

        if( FAILED( pd3dDevice->CreateTexture( s_dwDashStyleDepthPreviewWidth,
                                               s_dwDashStyleDepthPreviewHeight,
                                               1, 0,
                                               D3DFMT_LIN_D16,
                                               0, 
                                               &m_pSmoothDepthTextureSwap, NULL ) ) )
        {
            return E_FAIL;
        }
    }

    m_bIsInitialized = TRUE;
    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: Shutdown
// Desc: Releases the resources allocated in the Initialize method.
//       Any call to Initialize method should be macthed with a call to this 
//       Shutdown method.
//--------------------------------------------------------------------------------------
HRESULT NuiVisualization::Shutdown()
{
    if( m_pVideoVertexDecl != NULL )
    {
        m_pVideoVertexDecl->Release();
        m_pVideoVertexDecl = NULL;
    }
    
    if( m_pVideoPixelShaderRGB != NULL )
    {
        m_pVideoPixelShaderRGB->Release();
        m_pVideoPixelShaderRGB = NULL;
    }

    if( m_pVideoVertexShader != NULL )
    {
        m_pVideoVertexShader->Release();
        m_pVideoVertexShader = NULL;
    }

    SAFE_RELEASE( m_pSmoothDepthTexture );
    SAFE_RELEASE( m_pSmoothDepthTextureSwap );
    SAFE_RELEASE( m_pDepthPreviewPS );
    SAFE_RELEASE( m_pDepthPreviewSmoothingVS );
    SAFE_RELEASE( m_pNuiDepthTexture );

    m_pSmoothDepthTexture = NULL;
    m_pSmoothDepthTextureSwap = NULL;
    m_pDepthPreviewPS = NULL;
    m_pDepthPreviewSmoothingVS = NULL;
    m_pNuiDepthTexture = NULL;
    
    m_bIsInitialized = FALSE;

    return S_OK;
}

//--------------------------------------------------------------------------------------
// Name: SetColorTexture
// Desc: Sets the color stream buffer to be displayed next time DisplayColorStream is 
//       called.
//--------------------------------------------------------------------------------------
HRESULT NuiVisualization::SetColorTexture( IDirect3DTexture9* pColorTexture, const NUI_IMAGE_VIEW_AREA* pViewArea /* = NULL */ )
{
    // Pre-conditions
    assert( m_bIsInitialized );
    assert( m_dwComponentsToProcess & NUI_INITIALIZE_FLAG_USES_COLOR );

    PIXBeginNamedEvent( 0, "VisualizeStreams - Fill ColorMap" );
    if( pColorTexture )
    {
        // Clear texture
        UINT textureID = m_colorDisplaying == 0 ? 1 : 0;
        D3DLOCKED_RECT Locked;
        if( FAILED( m_pColorTexture[ textureID ]->LockRect( 0, &Locked, NULL, 0 ) ) )
        {
            PIXEndNamedEvent();
            return E_FAIL;
        }

        D3DLOCKED_RECT LockedSrc;
        if( FAILED( pColorTexture->LockRect( 0, &LockedSrc, NULL, D3DLOCK_READONLY ) ) )
        {
            m_pColorTexture[ textureID ]->UnlockRect( 0 );
            PIXEndNamedEvent();
            return E_FAIL;
        }
        
        // Fill in the colormap data
        XMemCpyStreaming( Locked.pBits, LockedSrc.pBits, Locked.Pitch * m_dwColorStreamHeight );

        pColorTexture->UnlockRect( 0 );		
        m_pColorTexture[ textureID ]->UnlockRect( 0 );

        m_bColorIsNew = TRUE;
    }
    PIXEndNamedEvent();
    
    if (pViewArea != NULL)
    {
        m_colorViewArea = *pViewArea;
    } else {
        XMemSet( &m_colorViewArea, 0, sizeof( m_colorViewArea) );
    }
    
    return ERROR_SUCCESS;
}


//--------------------------------------------------------------------------------------
// Name: SetDepthTexture
// Desc: Sets the depth stream buffer to be displayed next time DisplayDepthStream is 
//       called.
//--------------------------------------------------------------------------------------
HRESULT NuiVisualization::SetDepthTexture( IDirect3DTexture9* pDepthTexture, BOOL bColorize )
{
    // Pre-conditions
    assert( m_bIsInitialized );
    assert( m_dwComponentsToProcess & ( NUI_INITIALIZE_FLAG_USES_DEPTH | NUI_INITIALIZE_FLAG_USES_DEPTH_AND_PLAYER_INDEX ) );

    PIXBeginNamedEvent( 0, "VisualizeStreams - Fill DepthMap" );
    if( pDepthTexture )
    {
        // Make a copy of the depth texture, so we can leverage the real depth values.
        SAFE_RELEASE( m_pNuiDepthTexture );
        m_pNuiDepthTexture = pDepthTexture;
        m_pNuiDepthTexture->AddRef();

        UINT textureID = m_depthDisplaying == 0 ? 1 : 0;
        D3DLOCKED_RECT Locked;
        if( FAILED( m_pDepthTexture[ textureID ]->LockRect( 0, &Locked, NULL, 0 ) ) )
        {
            PIXEndNamedEvent();
            return E_FAIL;
        }

        D3DLOCKED_RECT LockedSrc;
        if( FAILED( pDepthTexture->LockRect( 0, &LockedSrc, NULL, D3DLOCK_READONLY ) ) )
        {
            pDepthTexture->UnlockRect( 0 );		
            PIXEndNamedEvent();
            return E_FAIL;
        }

        // Fill in the depthmap data
        DWORD* lpBits = ( DWORD* )Locked.pBits;
        USHORT* pDepthMapCur = ( USHORT* )LockedSrc.pBits;
        
        for( UINT y = 0; y < s_dwDepthStreamHeight; ++ y )
        {
            for( UINT x = 0; x < s_dwDepthStreamWidth; ++ x )
            {
                if( bColorize )
                {
                    // To colorize the depth values, normalize the depth value against a maximum depth
                    // value to be colorized and lookup into the color table
                    const static FLOAT fMaxDepth = 3500.0f;                           // use 3.5 meters as max depth to colorize
                    const static UINT uNormalize = (UINT) ceil( fMaxDepth / 511.0 );
                    UINT uIndex = min( (USHORT)( pDepthMapCur[ x ] >> 3 ) / uNormalize, 511 );
                
                    lpBits[x] = m_DepthColorTable[ uIndex ];
                }
                else
                {
                    const static FLOAT fMaxDepth = 3500.0f;
                    const static UINT uNormalize = (UINT) ceil( fMaxDepth / 254.0 );
                    UINT uValue = min( (USHORT)( pDepthMapCur[ x ] >> 3 ) / uNormalize, 254 );

                    lpBits[x] = D3DCOLOR_RGBA( uValue, uValue, uValue, 0xff ); 
                }
            }
            lpBits += Locked.Pitch / sizeof( DWORD );
            pDepthMapCur += LockedSrc.Pitch / sizeof( USHORT );
        }

        pDepthTexture->UnlockRect( 0 );		
        m_pDepthTexture[ textureID ]->UnlockRect( 0 );
        m_depthDisplaying = m_depthDisplaying == 0 ? 1 : 0;
    }
    PIXEndNamedEvent();

    return ERROR_SUCCESS;
}


//--------------------------------------------------------------------------------------
// Name: SetSkeletons
// Desc: Sets the skeletons to be displayed next time DisplaySkeletons is called.
//--------------------------------------------------------------------------------------
HRESULT NuiVisualization::SetSkeletons( const NUI_SKELETON_FRAME* pSkeletonFrame )
{
    // Pre-conditions
    assert( m_bIsInitialized );
    assert( m_dwComponentsToProcess & NUI_INITIALIZE_FLAG_USES_SKELETON );

    XMemCpy( &m_SkeletonFrame, pSkeletonFrame, sizeof( NUI_SKELETON_FRAME ) );
    return ERROR_SUCCESS;
}


//--------------------------------------------------------------------------------------
// Name: SetSkeletonRenderInfo
// Desc: Sets the rendering options for the specified skeleton.
//--------------------------------------------------------------------------------------
HRESULT NuiVisualization::SetSkeletonRenderInfo( DWORD dwSkeletonIndex, const NUI_VISUALIZATION_SKELETON_RENDER_INFO* pSkeletonRenderInfo )
{ 
    assert( dwSkeletonIndex < NUI_SKELETON_COUNT ); 
    
    XMemCpy( &m_SkeletonRenderInfo[ dwSkeletonIndex ], pSkeletonRenderInfo, sizeof( NUI_VISUALIZATION_SKELETON_RENDER_INFO ) ); 

    return ERROR_SUCCESS; 
}


//--------------------------------------------------------------------------------------
// Name: GetSkeletonRenderInfo
// Desc: Retrieves the rendering options for the specifed skeleton.
//--------------------------------------------------------------------------------------
HRESULT NuiVisualization::GetSkeletonRenderInfo( DWORD dwSkeletonIndex, NUI_VISUALIZATION_SKELETON_RENDER_INFO* pSkeletonRenderInfo ) 
{  
    assert( dwSkeletonIndex < NUI_SKELETON_COUNT );
    
    XMemCpy( pSkeletonRenderInfo, &m_SkeletonRenderInfo[ dwSkeletonIndex ], sizeof( NUI_VISUALIZATION_SKELETON_RENDER_INFO ) ); 
    
    return ERROR_SUCCESS; 
}


//--------------------------------------------------------------------------------------
// Name: BeginRender
// Desc: Set renderstates to draw as overlay
//--------------------------------------------------------------------------------------
VOID NuiVisualization::BeginRender()
{
    // Set state on the first call
    if( m_dwNestedBeginCount == 0 )
    {
        // Note, we are not saving the texture, vertex, or pixel shader,
        //       since it's not worth the performance. We're more interested
        //       in saving state that would cause hard to find problems.
        m_pd3dDevice->GetRenderState( D3DRS_ALPHABLENDENABLE,
                                      &m_dwSavedState[ SAVEDSTATE_D3DRS_ALPHABLENDENABLE ] );
        m_pd3dDevice->GetRenderState( D3DRS_SRCBLEND, &m_dwSavedState[ SAVEDSTATE_D3DRS_SRCBLEND ] );
        m_pd3dDevice->GetRenderState( D3DRS_DESTBLEND, &m_dwSavedState[ SAVEDSTATE_D3DRS_DESTBLEND ] );
        m_pd3dDevice->GetRenderState( D3DRS_BLENDOP, &m_dwSavedState[ SAVEDSTATE_D3DRS_BLENDOP ] );
        m_pd3dDevice->GetRenderState( D3DRS_ALPHATESTENABLE, &m_dwSavedState[ SAVEDSTATE_D3DRS_ALPHATESTENABLE ] );
        m_pd3dDevice->GetRenderState( D3DRS_ALPHAREF, &m_dwSavedState[ SAVEDSTATE_D3DRS_ALPHAREF ] );
        m_pd3dDevice->GetRenderState( D3DRS_ALPHAFUNC, &m_dwSavedState[ SAVEDSTATE_D3DRS_ALPHAFUNC ] );
        m_pd3dDevice->GetRenderState( D3DRS_FILLMODE, &m_dwSavedState[ SAVEDSTATE_D3DRS_FILLMODE ] );
        m_pd3dDevice->GetRenderState( D3DRS_CULLMODE, &m_dwSavedState[ SAVEDSTATE_D3DRS_CULLMODE ] );
        m_pd3dDevice->GetRenderState( D3DRS_ZENABLE, &m_dwSavedState[ SAVEDSTATE_D3DRS_ZENABLE ] );
        m_pd3dDevice->GetRenderState( D3DRS_STENCILENABLE, &m_dwSavedState[ SAVEDSTATE_D3DRS_STENCILENABLE ] );
        m_pd3dDevice->GetRenderState( D3DRS_VIEWPORTENABLE, &m_dwSavedState[ SAVEDSTATE_D3DRS_VIEWPORTENABLE ] );
        m_pd3dDevice->GetSamplerState( 0, D3DSAMP_MINFILTER, &m_dwSavedState[ SAVEDSTATE_D3DSAMP_MINFILTER ] );
        m_pd3dDevice->GetSamplerState( 0, D3DSAMP_MAGFILTER, &m_dwSavedState[ SAVEDSTATE_D3DSAMP_MAGFILTER ] );
        m_pd3dDevice->GetSamplerState( 0, D3DSAMP_ADDRESSU, &m_dwSavedState[ SAVEDSTATE_D3DSAMP_ADDRESSU ] );
        m_pd3dDevice->GetSamplerState( 0, D3DSAMP_ADDRESSV, &m_dwSavedState[ SAVEDSTATE_D3DSAMP_ADDRESSV ] );

        // Set up some render states
        m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
        m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
        m_pd3dDevice->SetRenderState( D3DRS_BLENDOP, D3DBLENDOP_ADD );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF, 0x08 );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC, D3DCMP_GREATEREQUAL );
        m_pd3dDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID );
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
        m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE, FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, FALSE );
        m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_POINT );
        m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_POINT );
        m_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
        m_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP );
    }

    // Keep track of the nested begin/end calls.
    ++ m_dwNestedBeginCount;
}


//--------------------------------------------------------------------------------------
// Name: EndRender
// Desc: Restore renderstates
//--------------------------------------------------------------------------------------
VOID NuiVisualization::EndRender()
{
    assert( m_dwNestedBeginCount > 0 );

    if( -- m_dwNestedBeginCount > 0 )
        return;

    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetVertexDeclaration( NULL );
    m_pd3dDevice->SetVertexShader( NULL );
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, m_dwSavedState[ SAVEDSTATE_D3DRS_ALPHABLENDENABLE ] );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, m_dwSavedState[ SAVEDSTATE_D3DRS_SRCBLEND ] );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, m_dwSavedState[ SAVEDSTATE_D3DRS_DESTBLEND ] );
    m_pd3dDevice->SetRenderState( D3DRS_BLENDOP, m_dwSavedState[ SAVEDSTATE_D3DRS_BLENDOP ] );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, m_dwSavedState[ SAVEDSTATE_D3DRS_ALPHATESTENABLE ] );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF, m_dwSavedState[ SAVEDSTATE_D3DRS_ALPHAREF ] );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC, m_dwSavedState[ SAVEDSTATE_D3DRS_ALPHAFUNC ] );
    m_pd3dDevice->SetRenderState( D3DRS_FILLMODE, m_dwSavedState[ SAVEDSTATE_D3DRS_FILLMODE ] );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, m_dwSavedState[ SAVEDSTATE_D3DRS_CULLMODE ] );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, m_dwSavedState[ SAVEDSTATE_D3DRS_ZENABLE ] );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE, m_dwSavedState[ SAVEDSTATE_D3DRS_STENCILENABLE ] );
    m_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, m_dwSavedState[ SAVEDSTATE_D3DRS_VIEWPORTENABLE ] );
    m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, m_dwSavedState[ SAVEDSTATE_D3DSAMP_MINFILTER ] );
    m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, m_dwSavedState[ SAVEDSTATE_D3DSAMP_MAGFILTER ] );
    m_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSU, m_dwSavedState[ SAVEDSTATE_D3DSAMP_ADDRESSU ] );
    m_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSV, m_dwSavedState[ SAVEDSTATE_D3DSAMP_ADDRESSV ] );
}


//--------------------------------------------------------------------------------------
// Name: RenderColorStream
// Desc: Displays the most recent color stream buffer.
//--------------------------------------------------------------------------------------
HRESULT NuiVisualization::RenderColorStream( FLOAT fX, FLOAT fY, FLOAT fWidth, FLOAT fHeight )
{
    // Pre-conditions
    assert( m_bIsInitialized );
    assert( m_dwComponentsToProcess & NUI_INITIALIZE_FLAG_USES_COLOR );

    // Render video texture
    PIXBeginNamedEvent( 0, "VisualizeStreams - Render ColorMap" );
    
    // Set up render states
    BeginRender();

    m_pd3dDevice->SetPixelShader( m_pVideoPixelShaderRGB );

    m_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, FALSE );
    m_pd3dDevice->SetVertexShader( m_pVideoVertexShader );
    m_pd3dDevice->SetVertexDeclaration( m_pVideoVertexDecl );

    if( m_bColorIsNew )
    {
        m_colorDisplaying = m_colorDisplaying == 0 ? 1 : 0;
        m_bColorIsNew = FALSE;
    }
    m_pd3dDevice->SetTexture( 0, m_pColorTexture[ m_colorDisplaying ] );

    // Fill in the VB for depth stream texture
    VideoFeedVertex g_SnapshotVertices[] =
    {
        //  x             y               z   u  v
        {   fX,           fY,             0,  0, 0 },
        {   fX + fWidth,  fY,             0,  1, 0 },
        {   fX,           fY + fHeight,   0,  0, 1 },
    };

    VideoFeedVertex* pVertices;

    m_pd3dDevice->BeginVertices( D3DPT_RECTLIST, 3, sizeof( *g_SnapshotVertices ), &(VOID*&)pVertices );
    memcpy( pVertices, g_SnapshotVertices, sizeof( g_SnapshotVertices ) );
    m_pd3dDevice->EndVertices();

    m_pd3dDevice->SetStreamSource( 0, NULL, 0, 0 );

    m_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, TRUE );
    PIXEndNamedEvent();

    EndRender();
    return ERROR_SUCCESS;
}

HRESULT NuiVisualization::RenderCustomDepthStream( FLOAT fX, FLOAT fY, FLOAT fWidth, FLOAT fHeight, LPDIRECT3DTEXTURE9 pTexture )
{
    // Pre-conditions
    assert( m_bIsInitialized );
    assert( m_dwComponentsToProcess & ( NUI_INITIALIZE_FLAG_USES_DEPTH | NUI_INITIALIZE_FLAG_USES_DEPTH_AND_PLAYER_INDEX ) );

    PIXBeginNamedEvent( 0, "VisualizeStreams - Render DepthMap" );
    
    // Set up render states
    BeginRender();

    m_pd3dDevice->SetPixelShader( m_pVideoPixelShaderRGB );

    m_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, FALSE );
    m_pd3dDevice->SetVertexShader( m_pVideoVertexShader );
    m_pd3dDevice->SetVertexDeclaration( m_pVideoVertexDecl );

    m_pd3dDevice->SetTexture( 0, pTexture );

    // Fill in the VB for depth stream texture
    VideoFeedVertex g_SnapshotVertices[] =
    {
        //  x             y               z   u  v
        {   fX,           fY,             0,  0, 0 },
        {   fX + fWidth,  fY,             0,  1, 0 },
        {   fX,           fY + fHeight,   0,  0, 1 },
    };

    VideoFeedVertex* pVertices;

    m_pd3dDevice->BeginVertices( D3DPT_RECTLIST, 3, sizeof( *g_SnapshotVertices ), &(VOID*&)pVertices );
    memcpy( pVertices, g_SnapshotVertices, sizeof( g_SnapshotVertices ) );
    m_pd3dDevice->EndVertices();

    m_pd3dDevice->SetStreamSource( 0, NULL, 0, 0 );

    m_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, TRUE );
    PIXEndNamedEvent();

    EndRender();
    return ERROR_SUCCESS;
}

HRESULT NuiVisualization::RenderDashStyleDepthPreview( FLOAT fX, FLOAT fY, FLOAT fWidth, FLOAT fHeight )
{
    // Early out if nothing to display.
    if( NULL == m_pNuiDepthTexture )
        return S_OK;

    PIXBeginNamedEvent( 0, "VisualizeStreams - Render Dash-Style Preview" );

    // Set state we need...(and cache current values for restore later).
    m_pd3dDevice->GetRenderState( D3DRS_VIEWPORTENABLE, &m_dwSavedState[ SAVEDSTATE_D3DRS_VIEWPORTENABLE ] );
    m_pd3dDevice->GetRenderState( D3DRS_ZENABLE, &m_dwSavedState[ SAVEDSTATE_D3DRS_ZENABLE ] );

    m_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );

    // Smooth the depth texture
    D3DTexture * pSrcTexture = m_pNuiDepthTexture;
    D3DTexture * pDstTexture = m_pSmoothDepthTexture;

    // Set the pixel shader here, although we don't use it until later.
    m_pd3dDevice->SetPixelShader( m_pDepthPreviewPS );

    // Do 3 passes to smooth the depth-map.
    DWORD dwIteration = 3;
    do
    {
        // Basically just memexport the averaged depth values, ping-ponging between textures.
        m_pd3dDevice->SetTexture( D3DVERTEXTEXTURESAMPLER0, pSrcTexture );
        m_pd3dDevice->SetSamplerFilterStates( D3DVERTEXTEXTURESAMPLER0, D3DTEXF_POINT, D3DTEXF_POINT, D3DTEXF_POINT, 1 );
        GPU_MEMEXPORT_STREAM_CONSTANT MemExportStreamConstant;
        GPU_SET_MEMEXPORT_STREAM_CONSTANT( &MemExportStreamConstant,
                                            ( USHORT* )( pDstTexture->Format.BaseAddress << GPU_TEXTURE_ADDRESS_SHIFT ),
                                            s_dwDashStyleDepthPreviewPitch * s_dwDashStyleDepthPreviewHeight,
                                            SURFACESWAP_LOW_RED,
                                            GPUSURFACENUMBER_UINTEGER,
                                            GPUCOLORFORMAT_16,
                                            GPUENDIAN128_8IN16 );

        m_pd3dDevice->SetVertexShaderConstantF( 0, ( FLOAT* ) &MemExportStreamConstant, 1 );
        m_pd3dDevice->SetVertexShader( m_pDepthPreviewSmoothingVS );
        m_pd3dDevice->BeginExport( 0, pDstTexture, D3DBEGINEXPORT_VERTEXSHADER );
        m_pd3dDevice->DrawPrimitive( D3DPT_POINTLIST, 0, s_dwDashStyleDepthPreviewWidth * s_dwDashStyleDepthPreviewHeight );
        m_pd3dDevice->EndExport( 0, pDstTexture, 0 );

        // Swap (ping-pong) our textures until the final pass.
        if( --dwIteration )
        {
            pSrcTexture = pDstTexture;
            pDstTexture = ( pDstTexture == m_pSmoothDepthTexture ) ? m_pSmoothDepthTextureSwap : m_pSmoothDepthTexture;
        }
    } 
    while( dwIteration > 0 );

    // Unset the vertex shader texture.
    m_pd3dDevice->SetTexture( D3DVERTEXTEXTURESAMPLER0, NULL );

    // Now set up to actually render the smoothed depth map, with lights, etc.
    m_pd3dDevice->SetTexture( 0, pDstTexture );
    m_pd3dDevice->SetVertexDeclaration( m_pVideoVertexDecl );
    m_pd3dDevice->SetVertexShader( m_pVideoVertexShader );
    m_pd3dDevice->SetSamplerFilterStates( 0, D3DTEXF_POINT, D3DTEXF_POINT, D3DTEXF_POINT, 1 );

    enum PLAYER_DATA_PARTS
    {
        PLAYER_HEAD = 0,
        PLAYER_NECK,
        PLAYER_SHOULDER,
        PLAYER_LEFT_HAND,
        PLAYER_RIGHT_HAND,
        PLAYER_PLANE,
    };

    // Initialize our tracking vectors.
    // Use tracked hands as light sources.
    XMVECTOR PlayerData[ NUI_SKELETON_COUNT ];
    XMVECTOR TrackedLeftHandPos[ NUI_SKELETON_COUNT ];
    XMVECTOR TrackedRightHandPos[ NUI_SKELETON_COUNT ];
    XMemSet( TrackedLeftHandPos, 0, sizeof( TrackedLeftHandPos ) );
    XMemSet( TrackedRightHandPos, 0, sizeof( TrackedRightHandPos ) );

    // Get all tracked hand positions
    INT nFirstTrackedPlayer = -1;
    for( UINT i = 0; i < NUI_SKELETON_COUNT; ++i )
    {
        if( m_SkeletonFrame.SkeletonData[ i ].eTrackingState == NUI_SKELETON_TRACKED )
        {
            if( nFirstTrackedPlayer == -1 )
                nFirstTrackedPlayer = i;

            if( m_SkeletonFrame.SkeletonData[ i ].eSkeletonPositionTrackingState[ NUI_SKELETON_POSITION_HAND_LEFT ] != NUI_SKELETON_POSITION_NOT_TRACKED )
            {
                TrackedLeftHandPos[ i ] = m_SkeletonFrame.SkeletonData[ i ].SkeletonPositions[ NUI_SKELETON_POSITION_HAND_LEFT ];
            }
            if( m_SkeletonFrame.SkeletonData[ i ].eSkeletonPositionTrackingState[ NUI_SKELETON_POSITION_HAND_RIGHT ] != NUI_SKELETON_POSITION_NOT_TRACKED )
            {
                TrackedRightHandPos[ i ] = m_SkeletonFrame.SkeletonData[ i ].SkeletonPositions[ NUI_SKELETON_POSITION_HAND_RIGHT ];
            }
        }
    }

    // If we find a tracked player, grab their hand positions.
    if( nFirstTrackedPlayer != -1 )
    {
        PlayerData[ PLAYER_HEAD ] = m_SkeletonFrame.SkeletonData[ nFirstTrackedPlayer ].SkeletonPositions[ NUI_SKELETON_POSITION_HEAD ];
        PlayerData[ PLAYER_NECK ] = m_SkeletonFrame.SkeletonData[ nFirstTrackedPlayer ].SkeletonPositions[ NUI_SKELETON_POSITION_SHOULDER_CENTER ];
        PlayerData[ PLAYER_SHOULDER ] = m_SkeletonFrame.SkeletonData[ nFirstTrackedPlayer ].SkeletonPositions[ NUI_SKELETON_POSITION_SHOULDER_RIGHT ];
        if( m_SkeletonFrame.SkeletonData[ nFirstTrackedPlayer ].eSkeletonPositionTrackingState[ NUI_SKELETON_POSITION_HAND_LEFT ] != NUI_SKELETON_POSITION_NOT_TRACKED )
        {
            PlayerData[ PLAYER_LEFT_HAND ] = m_SkeletonFrame.SkeletonData[ nFirstTrackedPlayer ].SkeletonPositions[ NUI_SKELETON_POSITION_HAND_LEFT ];
        }
        if( m_SkeletonFrame.SkeletonData[ nFirstTrackedPlayer ].eSkeletonPositionTrackingState[ NUI_SKELETON_POSITION_HAND_RIGHT ] != NUI_SKELETON_POSITION_NOT_TRACKED )
        {
            PlayerData[ PLAYER_RIGHT_HAND ] = m_SkeletonFrame.SkeletonData[ nFirstTrackedPlayer ].SkeletonPositions[ NUI_SKELETON_POSITION_HAND_RIGHT ];
        }

        XMVECTOR v1 = PlayerData[ PLAYER_HEAD ] - PlayerData[ PLAYER_NECK ];
        XMVECTOR v2 = PlayerData[ PLAYER_SHOULDER ] - PlayerData[ PLAYER_NECK ];
        if( XMVectorGetX( XMVector3Length( v1 ) ) == 0 || XMVectorGetX( XMVector3Length( v2 ) ) == 0 )
        {
            // If we don't get valid data to be able to calculate our player plane, we should probably just flag this player as not tracked.
            nFirstTrackedPlayer = -1;
        }
        else
        {
            XMVECTOR Normal = XMVector3Normalize( XMVector3Cross( v2, v1 ) );
            FLOAT d = XMVectorGetX( XMVector3Dot( Normal, PlayerData[ PLAYER_HEAD ] ) );
            PlayerData[ PLAYER_PLANE ] = XMVectorSetW( Normal, -d );
        }
    }

    // Set shader constants.
    m_pd3dDevice->SetPixelShaderConstantF( 1, ( FLOAT* ) PlayerData, 6 );

    BOOL Engaged = ( nFirstTrackedPlayer != -1 ) ? FALSE : TRUE;
    BOOL EngagedConst[ 4 ] = { Engaged, Engaged, Engaged, Engaged };
    m_pd3dDevice->SetPixelShaderConstantB( 0, EngagedConst, 1 );

    m_pd3dDevice->SetPixelShaderConstantF( 8, ( FLOAT* ) &TrackedLeftHandPos, 6 );
    m_pd3dDevice->SetPixelShaderConstantF( 14, ( FLOAT* ) &TrackedRightHandPos, 6 );
    XMVECTOR OpacityConst = XMVectorSet( 1.0f, 1.0f, 1.0f, 1.0f );
    m_pd3dDevice->SetPixelShaderConstantF( 20, ( FLOAT* )&OpacityConst, 1 );

    // Fill in the VB for depth stream texture
    VideoFeedVertex SnapshotVertices[] =
    {
        //  x             y               z   u  v
        {   fX,           fY,             0,  0, 0 },
        {   fX + fWidth,  fY,             0,  1, 0 },
        {   fX,           fY + fHeight,   0,  0, 1 },
    };

    VideoFeedVertex* pVertices;

    m_pd3dDevice->BeginVertices( D3DPT_RECTLIST, 3, sizeof( *SnapshotVertices ), &(VOID*&)pVertices );
    memcpy( pVertices, SnapshotVertices, sizeof( SnapshotVertices ) );
    m_pd3dDevice->EndVertices();

    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ONE );

    // Restore render states.
    m_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, m_dwSavedState[ SAVEDSTATE_D3DRS_VIEWPORTENABLE ] );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, m_dwSavedState[ SAVEDSTATE_D3DRS_ZENABLE ] );

    PIXEndNamedEvent();

    return ERROR_SUCCESS;
}


//--------------------------------------------------------------------------------------
// Name: RenderDepthStream
// Desc: Displays the most recent depth stream buffer.
//--------------------------------------------------------------------------------------
HRESULT NuiVisualization::RenderDepthStream( FLOAT fX, FLOAT fY, FLOAT fWidth, FLOAT fHeight )
{
    return RenderCustomDepthStream( fX, fY, fWidth, fHeight, m_pDepthTexture[ m_depthDisplaying ] );
}


XMFLOAT2 g_ScreenSpaceJoints[ NUI_SKELETON_POSITION_COUNT ];


//--------------------------------------------------------------------------------------
// Name: RenderSkeletons
// Desc: Displays all tracked skeletons from the most recent skeleton frame buffer.
//--------------------------------------------------------------------------------------
HRESULT NuiVisualization::RenderSkeletons( FLOAT fX, FLOAT fY, FLOAT fWidth, FLOAT fHeight, BOOL bClip, BOOL bRegisterToColor )
{
    // Set up render states
    BeginRender();

    for( DWORD dwSkeletonIndex = 0; dwSkeletonIndex < NUI_SKELETON_COUNT; ++ dwSkeletonIndex )
    {
        if( m_SkeletonFrame.SkeletonData[ dwSkeletonIndex ].eTrackingState == NUI_SKELETON_TRACKED )
        {
            RenderSingleSkeleton( dwSkeletonIndex, fX, fY, fWidth, fHeight, bClip, bRegisterToColor );
        }
    }


    EndRender();
    return ERROR_SUCCESS;
}

//--------------------------------------------------------------------------------------
// Name: GetJointProjectedLocation
// Desc: Computes the projected position of a specific skeleton joint.
//--------------------------------------------------------------------------------------
XMFLOAT2 NuiVisualization::GetJointProjectedLocation( DWORD dwSkeletonIndex, NUI_SKELETON_POSITION_INDEX SkeletonPositionIndex, FLOAT fWidth, FLOAT fHeight, BOOL bRegisterToColor ) const
{
    XMFLOAT3 vJointLocation;
    XMStoreFloat3( &vJointLocation, m_SkeletonFrame.SkeletonData[ dwSkeletonIndex ].SkeletonPositions[ SkeletonPositionIndex ] );

    // Check for divide by zero
    if ( fabs( vJointLocation.z ) > FLT_EPSILON  )
    {
        // Note:  Without tilt correction, any projection will be off, as the skeleton positions 
        //        are camera-relative, with Up as ( 0, 1, 0), which the axis of the camera may
        //        not be aligned to. You can see this by turning on and off tilt correction
        //        in the sample.

        LONG plDepthX, plDepthY, plColorX, plColorY;
        USHORT usDepthValue;
        NuiTransformSkeletonToDepthImage( m_SkeletonFrame.SkeletonData[ dwSkeletonIndex ].SkeletonPositions[ SkeletonPositionIndex ],
                                          &plDepthX, &plDepthY, &usDepthValue );
        
        if ( bRegisterToColor )
        {
            HRESULT hr = NuiImageGetColorPixelCoordinatesFromDepthPixel( m_colorImageResolution,
                                                                         &m_colorViewArea,
                                                                         plDepthX,
                                                                         plDepthY,
                                                                         usDepthValue,
                                                                         &plColorX,
                                                                         &plColorY );

            if ( SUCCEEDED( hr ) )
            {
                return XMFLOAT2( plColorX * fWidth / m_dwColorStreamWidth, plColorY * fWidth / m_dwColorStreamWidth );       
            }
            else
            {
                // When a corresponding color value isn't avaible, use the raw depth value instead. 
                return XMFLOAT2( plDepthX * fWidth / s_dwDepthStreamWidth, plDepthY * fHeight / s_dwDepthStreamHeight );       
            }
        }
        else
        {
            return XMFLOAT2( plDepthX * fWidth / s_dwDepthStreamWidth, plDepthY * fHeight / s_dwDepthStreamHeight );       
        }
    }
    else
    {
        // A joint that is so close to the camera that its Z value is 0 can simply be drawn directly 
        // at the center of the 2D plane.
        return XMFLOAT2( fWidth * 0.5f , fHeight * 0.5f  );       
    }
}


//--------------------------------------------------------------------------------------
// Name: RenderSingleSkeleton
// Desc: Displays a skeleton based on the most skeleton frame buffer.
//--------------------------------------------------------------------------------------
HRESULT NuiVisualization::RenderSingleSkeleton( DWORD dwSkeletonIndex, FLOAT fX, FLOAT fY, FLOAT fWidth, FLOAT fHeight, BOOL bClip, BOOL bRegisterToColor )
{
    // Pre-conditions
    assert( m_bIsInitialized );
    assert( dwSkeletonIndex < NUI_SKELETON_COUNT );
    assert( m_dwComponentsToProcess & NUI_INITIALIZE_FLAG_USES_SKELETON );
    if( bRegisterToColor )
    {
        assert( m_dwComponentsToProcess & NUI_INITIALIZE_FLAG_USES_COLOR );
    }
    
    PIXBeginNamedEvent( 0, __FUNCTION__ );


    // There is nothing to draw if the player isn't tracked.
    if ( m_SkeletonFrame.SkeletonData[ dwSkeletonIndex ].eTrackingState != NUI_SKELETON_TRACKED )
    {
        PIXEndNamedEvent();
        return ERROR_SUCCESS;
    }
        
    XMFLOAT2 vScreenSpaceJoints[ NUI_SKELETON_POSITION_COUNT ];

    // Set up render states
    BeginRender();

    // Project the world space joints into screen space
    for ( UINT i = 0; i < NUI_SKELETON_POSITION_COUNT; ++ i )
    {
        g_ScreenSpaceJoints[ i ] = GetJointProjectedLocation( dwSkeletonIndex, ( NUI_SKELETON_POSITION_INDEX )i, fWidth, fHeight, bRegisterToColor );
    }


    // Locate the beginning of the confidence array. We'll index into this array in the next loop.
    const NUI_SKELETON_POSITION_TRACKING_STATE *pSkeletonTrackingState = &m_SkeletonFrame.SkeletonData[ dwSkeletonIndex ].eSkeletonPositionTrackingState[ 0 ];
    const NUI_VISUALIZATION_SKELETON_RENDER_INFO *pSkeletonRenderInfo = &m_SkeletonRenderInfo[ dwSkeletonIndex ];

    // Draw each bone in the skeleton using the screen space joints
    for( UINT i = 0; i < g_uSkeletonBoneCount; i++ )
    {
        // Asign a color to each joint based on the confidence level. Don't draw a bone if one of its joints has no confidence.

        D3DCOLOR startColor;
        if( pSkeletonTrackingState[ g_SkeletonBoneList[ i ].StartJoint ] == NUI_SKELETON_POSITION_NOT_TRACKED || 
            !pSkeletonRenderInfo->bDraw[ g_SkeletonBoneList[ i ].StartJoint ] )
        {
            // A joint in the bone wasn't tracked during skeleton tracking...
            continue;
        }
        else if( pSkeletonTrackingState[ g_SkeletonBoneList[ i ].StartJoint ] == NUI_SKELETON_POSITION_TRACKED )
        {
            startColor = pSkeletonRenderInfo->TrackedColor[ g_SkeletonBoneList[ i ].StartJoint ];
        }
        else if( pSkeletonTrackingState[ g_SkeletonBoneList[ i ].StartJoint ] == NUI_SKELETON_POSITION_INFERRED )
        {
            startColor = pSkeletonRenderInfo->InferredColor[ g_SkeletonBoneList[ i ].StartJoint ];
        }
        else
        {
            assert( false );
            continue;
        }

        D3DCOLOR endColor;
        if( pSkeletonTrackingState[ g_SkeletonBoneList[ i ].EndJoint ] == NUI_SKELETON_POSITION_NOT_TRACKED || 
            !pSkeletonRenderInfo->bDraw[ g_SkeletonBoneList[ i ].EndJoint ] )
        {
            // A joint in the bone wasn't tracked during skeleton tracking...
            continue;
        }
        if( pSkeletonTrackingState[ g_SkeletonBoneList[ i ].EndJoint ] == NUI_SKELETON_POSITION_TRACKED )
        {
            endColor = pSkeletonRenderInfo->TrackedColor[ g_SkeletonBoneList[ i ].EndJoint ];
        }
        else if( pSkeletonTrackingState[ g_SkeletonBoneList[ i ].EndJoint ] == NUI_SKELETON_POSITION_INFERRED )
        {
            endColor = pSkeletonRenderInfo->InferredColor[ g_SkeletonBoneList[ i ].EndJoint ];
        }
        else
        {
            assert( false );
            continue;
        }

        // Vertically center the 1:1 aspect ratio projected skeleton over the destination area.
        // Draw the bone over the depth image
        XMFLOAT2 pntArray[ 2 ];
        pntArray[ 0 ].x = g_ScreenSpaceJoints[ g_SkeletonBoneList[ i ].StartJoint ].x + fX;
        pntArray[ 0 ].y = g_ScreenSpaceJoints[ g_SkeletonBoneList[ i ].StartJoint ].y + fY;
        pntArray[ 1 ].x = g_ScreenSpaceJoints[ g_SkeletonBoneList[ i ].EndJoint ].x + fX;
        pntArray[ 1 ].y = g_ScreenSpaceJoints[ g_SkeletonBoneList[ i ].EndJoint ].y + fY;

        if( !bClip || ClipLineToRect( &pntArray[ 0 ], &pntArray[ 1 ], fX, fY, fWidth, fHeight ) )
        {
            ATG::DebugDraw::DrawScreenSpaceLine( pntArray[ 0 ], startColor, pntArray[ 1 ], endColor, 3 );
        }

    }

    PIXEndNamedEvent();

    EndRender();
    return ERROR_SUCCESS;
}


//--------------------------------------------------------------------------------------
// Name: InitializeDepthColorTable()
// Desc: Initialize the lookup table to display depth values in color
//--------------------------------------------------------------------------------------
VOID NuiVisualization::InitializeDepthColorTable()
{
    // Build depth map visualization color table. Rainbow linear gradient mirrored at
    // center point with gradual dimming starting at center point to start of table.
    
    const INT iHalfTableSize    = ARRAYSIZE( m_DepthColorTable ) / 2;
    FLOAT fGutter               = 0.2f;   
    INT iTableIndex             = iHalfTableSize;
    FLOAT fStep                 = ( 1.0f - ( fGutter * 2.0f ) ) / iHalfTableSize;

    for( FLOAT t = fGutter; t < ( 1.0f - fGutter ); t += fStep )
    {
        FLOAT fColor[ 3 ]       = { 0, 0, 0 };
        FLOAT fBand             = 0.7f;
        const FLOAT fCurveExp   = 2.0f;   
        const FLOAT fBandGap    = 1.0f - fBand;
         
        for( INT i = 0; i < 3; ++ i ) 
        {
            FLOAT s = ( t - fBandGap * 0.5f * i ) / fBand;
            if ( ( s >= 0 ) && ( s <= 1 ) )
            {
                fColor[ i ] = powf( sinf( s * XM_PI * 2.0f - XM_PI * 0.5f ) * 0.5f + 0.5f, fCurveExp );
            }
        }

        m_DepthColorTable[ iTableIndex++ ] = D3DCOLOR_RGBA( (BYTE)( fColor[ 0 ] * 255.0f ),
                                                            (BYTE)( fColor[ 1 ] * 255.0f ),
                                                            (BYTE)( fColor[ 2 ] * 255.0f ),
                                                            0xff );
    }
    
    for( INT i = 0; i < iHalfTableSize; ++ i )
    {
        COLORREF s = m_DepthColorTable[ ARRAYSIZE( m_DepthColorTable ) - 1 - i ];
        
        FLOAT fDim = ( FLOAT )i / (FLOAT)iHalfTableSize;
        
        m_DepthColorTable[ i ] = D3DCOLOR_RGBA( ( BYTE )( (FLOAT)D3DCOLOR_GETRED( s ) * ( 0.25f + ( fDim * 0.75f ) ) ),
                                                ( BYTE )( (FLOAT)D3DCOLOR_GETGREEN( s ) * ( 0.25f + ( fDim * 0.75f ) ) ),
                                                ( BYTE )( (FLOAT)D3DCOLOR_GETBLUE( s ) * ( 0.25f + ( fDim * 0.75f ) ) ),
                                                 0xff );
    }
}


//--------------------------------------------------------------------------------------
// Name: InitializeVideoTextures()
// Desc: Recreates the m_pVideoTextures array of D3D textures using the current
//       resolution and pixel format settings.
//--------------------------------------------------------------------------------------
HRESULT NuiVisualization::InitializeVideoTextures( D3DDevice* pd3dDevice, 
                                                   IDirect3DTexture9** ppVideoTexture, 
                                                   DWORD dwWidth, DWORD dwHeight )
{
    HRESULT hr;

    // Release the old texture
    if( *ppVideoTexture != NULL )
    {
        (*ppVideoTexture)->BlockUntilNotBusy();
        (*ppVideoTexture)->Release();
        *ppVideoTexture = NULL;
    }

       
    // Create the new texture using the current resolution and pixel format
    hr = pd3dDevice->CreateTexture( dwWidth, dwHeight, 1, 0,
        GetAs16SRGBFormat( D3DFMT_LIN_X8R8G8B8 ), D3DPOOL_MANAGED, ppVideoTexture, NULL );
    if( FAILED( hr ) )
    {
        return E_FAIL;
    }

    // Clear texture
    D3DLOCKED_RECT Locked;
    if( FAILED( (*ppVideoTexture)->LockRect( 0, &Locked, NULL, 0 ) ) )
        return E_FAIL;

    // Fill the texture with black
    DWORD* lpBits = ( DWORD* )Locked.pBits;
    for( UINT k = 0; k < Locked.Pitch * dwHeight / 4; ++ k ) 
        *lpBits++ = 0xff000000;

    (*ppVideoTexture)->UnlockRect( 0 );

    return S_OK;
}

} // namespace ATG
```

`XenonDumper/libs/Atg/AtgNuiVisualization.h`:

```h
//--------------------------------------------------------------------------------------
// AtgNuiVisualization.h
//
// Visualization tools for Kinect
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#pragma once

#pragma warning(push)
#pragma warning(disable : 4324)

#include <NuiApi.h>


namespace ATG
{

//------------------------------------------------------------------------
// Name: struct NUI_VISUALIZATION_BONE_JOINTS
// Desc: Holds the index to the two joints defining a bone. 
//------------------------------------------------------------------------
struct NUI_VISUALIZATION_BONE_JOINTS
{
    NUI_SKELETON_POSITION_INDEX StartJoint;
    NUI_SKELETON_POSITION_INDEX EndJoint;
};

// Global list of skeleton bones available to all sample.
extern const NUI_VISUALIZATION_BONE_JOINTS g_SkeletonBoneList[];
extern const UINT g_uSkeletonBoneCount;


//------------------------------------------------------------------------
// Name: struct NUI_VISUALIZATION_SKELETON_RENDER_INFO
// Desc: Holds the rendering options for a specific skeleton.
//------------------------------------------------------------------------
struct NUI_VISUALIZATION_SKELETON_RENDER_INFO
{
    BOOL     bDraw[ NUI_SKELETON_POSITION_COUNT ];
    D3DCOLOR TrackedColor[ NUI_SKELETON_POSITION_COUNT ];
    D3DCOLOR InferredColor[ NUI_SKELETON_POSITION_COUNT ];

    VOID Initialize( D3DCOLOR trackedColor, D3DCOLOR inferredColor, BOOL draw = TRUE );
    VOID SplatTrackedColor( D3DCOLOR trackedColor);
    VOID SplatInferredColor( D3DCOLOR inferredColor ); 
};


//------------------------------------------------------------------------
// Name: class NuiVisualization
// Desc: Visualization support for Kinect.
//------------------------------------------------------------------------
class NuiVisualization
{
public:
    NuiVisualization();
    ~NuiVisualization();


    HRESULT Initialize( ::D3DDevice* pd3dDevice, DWORD dwComponentsToProcess, 
    	                NUI_IMAGE_RESOLUTION colorImageResolution = NUI_IMAGE_RESOLUTION_640x480,
                        BOOL bRenderDashStyleDepthPreview = FALSE );
	HRESULT Shutdown();

    HRESULT SetColorTexture( IDirect3DTexture9* pColorTexture, const NUI_IMAGE_VIEW_AREA* pViewArea = NULL );
    HRESULT SetDepthTexture( IDirect3DTexture9* pDepthTexture, BOOL bColorize = TRUE );
    HRESULT SetSkeletons( const NUI_SKELETON_FRAME* pSkeletonFrame );

    HRESULT SetSkeletonRenderInfo( DWORD dwSkeletonIndex, const NUI_VISUALIZATION_SKELETON_RENDER_INFO* pSkeletonRenderInfo );
    HRESULT GetSkeletonRenderInfo( DWORD dwSkeletonIndex, NUI_VISUALIZATION_SKELETON_RENDER_INFO* pSkeletonRenderInfo );

    XMFLOAT2 GetJointProjectedLocation( DWORD dwSkeletonIndex, NUI_SKELETON_POSITION_INDEX SkeletonPositionIndex, FLOAT fWidth, FLOAT fHeight, BOOL bRegisterToColor = FALSE ) const;

    VOID BeginRender();
    VOID EndRender();

    HRESULT RenderColorStream( FLOAT fX, FLOAT fY, FLOAT fWidth, FLOAT fHeight );
    HRESULT RenderDepthStream( FLOAT fX, FLOAT fY, FLOAT fWidth, FLOAT fHeight );
    HRESULT RenderSkeletons( FLOAT fX, FLOAT fY, FLOAT fWidth, FLOAT fHeight, BOOL bClip = FALSE, BOOL bRegisterToColor = FALSE );
    HRESULT RenderSingleSkeleton( DWORD dwSkeletonIndex, FLOAT fX, FLOAT fY, FLOAT fWidth, FLOAT fHeight, BOOL bClip = FALSE, BOOL bRegisterToColor = FALSE );
    HRESULT RenderCustomDepthStream( FLOAT fX, FLOAT fY, FLOAT fWidth, FLOAT fHeight, LPDIRECT3DTEXTURE9 pTexture );
    HRESULT RenderDashStyleDepthPreview( FLOAT fX, float fY, float fWidth, FLOAT fHeight );


    inline D3DCOLOR* GetColorTable() 
    {
        return &m_DepthColorTable[0];
    }
    inline const IDirect3DTexture9* GetVis320x240Texture ()
    {
        return m_pDepthTexture[ m_depthDisplaying ];
    }

private:
    NuiVisualization( const NuiVisualization& rhs );
    NuiVisualization& operator =( const NuiVisualization& rhs );

    VOID InitializeDepthColorTable();
    HRESULT InitializeVideoTextures( D3DDevice* pd3dDevice, 
                                     IDirect3DTexture9** ppVideoTexture, 
                                     DWORD dwWidth, DWORD dwHeight );
    
    // List of states to save.  We use an enum so that the list can evolve over time
    // without worrying about re-ordering, inserting, or removing saved states.
    enum SAVEDSTATES
    {
        SAVEDSTATE_D3DRS_ALPHABLENDENABLE,
        SAVEDSTATE_D3DRS_SRCBLEND,
        SAVEDSTATE_D3DRS_DESTBLEND,
        SAVEDSTATE_D3DRS_BLENDOP,
        SAVEDSTATE_D3DRS_ALPHATESTENABLE,
        SAVEDSTATE_D3DRS_ALPHAREF,
        SAVEDSTATE_D3DRS_ALPHAFUNC,
        SAVEDSTATE_D3DRS_FILLMODE,
        SAVEDSTATE_D3DRS_CULLMODE,
        SAVEDSTATE_D3DRS_ZENABLE,
        SAVEDSTATE_D3DRS_STENCILENABLE,
        SAVEDSTATE_D3DRS_VIEWPORTENABLE,
        SAVEDSTATE_D3DSAMP_MINFILTER,
        SAVEDSTATE_D3DSAMP_MAGFILTER,
        SAVEDSTATE_D3DSAMP_ADDRESSU,
        SAVEDSTATE_D3DSAMP_ADDRESSV,

        SAVEDSTATE_MAX
    };

    IDirect3DVertexDeclaration9* m_pVideoVertexDecl;     // Vertex format declaration
    IDirect3DVertexShader9*      m_pVideoVertexShader;   // Vertex Shader
    IDirect3DPixelShader9*       m_pVideoPixelShaderRGB; // Pixel Shader for RGB image

    BOOL m_bIsInitialized;
    BOOL m_bColorIsNew;      
    UINT m_colorDisplaying;
    UINT m_depthDisplaying;
    IDirect3DTexture9* m_pColorTexture[ 2 ];
    IDirect3DTexture9* m_pDepthTexture[ 2 ];

    // Depth preview declarations, shaders and textures.
    IDirect3DVertexShader9*         m_pDepthPreviewVS;
    IDirect3DPixelShader9*          m_pDepthPreviewPS;
    IDirect3DVertexShader9*         m_pDepthPreviewSmoothingVS;
    IDirect3DTexture9*              m_pSmoothDepthTexture;
    IDirect3DTexture9*              m_pSmoothDepthTextureSwap;
    IDirect3DTexture9*              m_pNuiDepthTexture;

    // Caller supplied information.
    ::D3DDevice* m_pd3dDevice;
    DWORD m_dwComponentsToProcess;

    // Each color streams can have different dimensions but the depth stream is always 320 X 240.
    NUI_IMAGE_RESOLUTION m_colorImageResolution;
    DWORD m_dwColorStreamWidth;
    DWORD m_dwColorStreamHeight;
    NUI_IMAGE_VIEW_AREA m_colorViewArea;
    const static DWORD s_dwDepthStreamWidth = 320;
    const static DWORD s_dwDepthStreamHeight = 240;
    const static DWORD s_dwDashStyleDepthPreviewWidth = 128;
    const static DWORD s_dwDashStyleDepthPreviewPitch = 128;
    const static DWORD s_dwDashStyleDepthPreviewHeight = 96;

    // D3D State  preserving information
    DWORD m_dwNestedBeginCount;
    DWORD m_dwSavedState[ SAVEDSTATE_MAX ];

    // Holds the data for all skeletons for a given frame. 
    NUI_SKELETON_FRAME m_SkeletonFrame;
    NUI_VISUALIZATION_SKELETON_RENDER_INFO m_SkeletonRenderInfo[ NUI_SKELETON_COUNT ];

    // Color lookup table to display depth values as color. Depth values can be displayed
    // as color values in many different ways, we chose to use a ramp lookup table
    D3DCOLOR    m_DepthColorTable[ 512 ];
};

} // namespace ATG

#pragma warning(pop)
```

`XenonDumper/libs/Atg/AtgPostProcess.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// AtgPostProcess.cpp
//
// Commonly used post-processing effects (like bloom, blur, etc.)
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#include "stdafx.h"
#include "AtgDevice.h"
#include "AtgPostProcess.h"
#include "AtgUtil.h"


namespace ATG
{

//--------------------------------------------------------------------------------------
// Mappings to shader constants that are used in the HLSL shaders
//--------------------------------------------------------------------------------------
const DWORD PSCONST_fMiddleGray = 5;
const DWORD PSCONST_fElapsedTime = 7;

const DWORD PSCONST_avSampleOffsets = 0;
const DWORD PSCONST_avSampleWeights = 16;

//--------------------------------------------------------------------------------------
// Constants and external variables
//--------------------------------------------------------------------------------------

// When drawing a full-screen quad, trial-n-error shows that using a grid can be better
// due to the GPU's rasterization rules and minimizing texture cache misses
static const DWORD g_dwQuadGridSizeX = 8; // 1280 / 8 = 160
static const DWORD g_dwQuadGridSizeY = 1; //  720 / 1 = 720
static const DWORD g_dwNumQuadsInGrid = g_dwQuadGridSizeX * g_dwQuadGridSizeY;

const DWORD MAX_SAMPLES = 16;      // Maximum number of texture grabs

// A stack of render targets used for convenient pushing/popping of render targets
std::stack <LPDIRECT3DSURFACE9> g_pRenderTargetStack;

// A stack of render states used for convenient pushing/popping of render state
std::stack <RENDERSTATE> g_dwRenderStateStack;


//--------------------------------------------------------------------------------------
// Name: GaussianDistribution()
// Desc: Computes a two-parameter (x,y) Gaussian distrubution using the given
//       standard deviation (rho)
//--------------------------------------------------------------------------------------
inline FLOAT GaussianDistribution( FLOAT x, FLOAT y, FLOAT rho )
{
    return expf( -( x * x + y * y ) / ( 2 * rho * rho ) ) / sqrtf( 2 * XM_PI * rho * rho );
}


//--------------------------------------------------------------------------------------
// Name: GetSampleOffsets_DownScale4x4()
// Desc: Get the texcoord offsets to be used inside the DownScale4x4 pixel shader.
//--------------------------------------------------------------------------------------
VOID PostProcess::GetSampleOffsets_DownScale4x4( DWORD dwTexWidth, DWORD dwTexHeight,
                                                 XMVECTOR* pvSampleOffsets )
{
    FLOAT tu = 1.0f / ( FLOAT )dwTexWidth;
    FLOAT tv = 1.0f / ( FLOAT )dwTexHeight;

    // Sample from the 16 surrounding points. Since the center point will be in the
    // exact center of 16 texels, a 1.5f offset is needed to specify a texel center.
    for( int y = 0; y < 4; y++ )
    {
        for( int x = 0; x < 4; x++ )
        {
            pvSampleOffsets->x = ( ( FLOAT )x - 1.5f ) * tu;
            pvSampleOffsets->y = ( ( FLOAT )y - 1.5f ) * tv;
            pvSampleOffsets++;
        }
    }
}


//--------------------------------------------------------------------------------------
// Name: GetSampleOffsets_DownScale3x3()
// Desc: Get the texcoord offsets to be used inside the DownScale3x3 pixel shader.
//--------------------------------------------------------------------------------------
VOID PostProcess::GetSampleOffsets_DownScale3x3( DWORD dwTexWidth, DWORD dwTexHeight,
                                                 XMVECTOR* pvSampleOffsets )
{
    FLOAT tu = 1.0f / ( FLOAT )dwTexWidth;
    FLOAT tv = 1.0f / ( FLOAT )dwTexHeight;

    // Sample from the 9 surrounding points. Since the center point will be in the exact
    // center of 4 texels, a 1.0f offset is needed to specify a texel center.
    for( int x = 0; x < 3; x++ )
    {
        for( int y = 0; y < 3; y++ )
        {
            pvSampleOffsets->x = ( x - 1.0f ) * tu;
            pvSampleOffsets->y = ( y - 1.0f ) * tv;
            pvSampleOffsets++;
        }
    }
}


//--------------------------------------------------------------------------------------
// Name: GetSampleOffsets_DownScale2x2()
// Desc: Get the texcoord offsets to be used inside the DownScale2x2 pixel shader.
//--------------------------------------------------------------------------------------
VOID PostProcess::GetSampleOffsets_DownScale2x2( DWORD dwTexWidth, DWORD dwTexHeight,
                                                 XMVECTOR* pvSampleOffsets )
{
    FLOAT tu = 1.0f / ( FLOAT )dwTexWidth;
    FLOAT tv = 1.0f / ( FLOAT )dwTexHeight;

    // Sample from the 4 surrounding points. Since the center point will be in the exact
    // center of 4 texels, a 0.5f offset is needed to specify a texel center.
    for( int y = 0; y < 2; y++ )
    {
        for( int x = 0; x < 2; x++ )
        {
            pvSampleOffsets->x = ( ( FLOAT )x - 0.5f ) * tu;
            pvSampleOffsets->y = ( ( FLOAT )y - 0.5f ) * tv;
            pvSampleOffsets++;
        }
    }
}


//--------------------------------------------------------------------------------------
// Name: GetSampleOffsets_GaussBlur5x5()
// Desc: Get the texcoord offsets to be used inside the GaussBlur5x5 pixel shader.
//--------------------------------------------------------------------------------------
VOID PostProcess::GetSampleOffsets_GaussBlur5x5( DWORD dwTexWidth, DWORD dwTexHeight,
                                                 XMVECTOR* pvTexCoordOffsets,
                                                 XMVECTOR* pvSampleWeights,
                                                 FLOAT fMultiplier )
{
    FLOAT tu = 1.0f / ( FLOAT )dwTexWidth;
    FLOAT tv = 1.0f / ( FLOAT )dwTexHeight;

    XMVECTOR vWhite = XMVectorSet( 1.0f, 1.0f, 1.0f, 1.0f );

    FLOAT fTotalWeight = 0.0f;
    DWORD index = 0;
    for( int x = -2; x <= 2; x++ )
    {
        for( int y = -2; y <= 2; y++ )
        {
            // Exclude pixels with a block distance greater than 2. This will
            // create a kernel which approximates a 5x5 kernel using only 13
            // sample points instead of 25; this is necessary since 2.0 shaders
            // only support 16 texture grabs.
            if( fabs( ( FLOAT )x ) + fabs( ( FLOAT )y ) > 2.0f )
                continue;

            // Get the unscaled Gaussian intensity for this offset
            pvTexCoordOffsets[index].x = ( FLOAT )x * tu;
            pvTexCoordOffsets[index].y = ( FLOAT )y * tv;
            pvTexCoordOffsets[index].z = 0.0f;
            pvTexCoordOffsets[index].w = 0.0f;

            pvSampleWeights[index] = vWhite * GaussianDistribution( ( FLOAT )x, ( FLOAT )y, 1.0f );

            fTotalWeight += pvSampleWeights[index].x;

            index++;
        }
    }

    // Divide the current weight by the total weight of all the samples; Gaussian
    // blur kernels add to 1.0f to ensure that the intensity of the image isn't
    // changed when the blur occurs. An optional multiplier variable is used to
    // add or remove image intensity during the blur.
    for( DWORD i = 0; i < index; i++ )
    {
        pvSampleWeights[i] /= fTotalWeight;
        pvSampleWeights[i] *= fMultiplier;
    }
}


//--------------------------------------------------------------------------------------
// Name: GetSampleOffsets_Bloom()
// Desc: Get the texcoord offsets to be used inside the Bloom pixel shader.
//--------------------------------------------------------------------------------------
VOID PostProcess::GetSampleOffsets_Bloom( DWORD dwTextureWidth, DWORD dwTextureHeight,
                                          FLOAT fAngle, XMVECTOR* pvTexCoordOffsets,
                                          XMVECTOR* pvColorWeights, FLOAT fDeviation,
                                          FLOAT fMultiplier )
{
    FLOAT tu = cosf( fAngle ) / ( FLOAT )dwTextureWidth;
    FLOAT tv = sinf( fAngle ) / ( FLOAT )dwTextureHeight;

    // Fill the center texel
    FLOAT fWeight = fMultiplier * GaussianDistribution( 0, 0, fDeviation );
    pvColorWeights[0] = XMVectorSet( fWeight, fWeight, fWeight, 1.0f );
    pvTexCoordOffsets[0] = XMVectorSet( 0.0f, 0.0f, 0.0f, 0.0f );

    // Fill the first half
    for( DWORD i = 1; i < 8; i++ )
    {
        // Get the Gaussian intensity for this offset
        fWeight = fMultiplier * GaussianDistribution( ( FLOAT )i, 0, fDeviation );
        pvColorWeights[i] = XMVectorSet( fWeight, fWeight, fWeight, 1.0f );
        pvTexCoordOffsets[i] = XMVectorSet( i * tu, i * tv, 0.0f, 0.0f );
    }

    // Mirror to the second half
    for( DWORD i = 8; i < 15; i++ )
    {
        pvColorWeights[i] = pvColorWeights[i - 7];
        pvTexCoordOffsets[i] = -pvTexCoordOffsets[i - 7];
    }
}


//--------------------------------------------------------------------------------------
// Name: GetSampleOffsets_Star()
// Desc: Get the texcoord offsets to be used inside the Star pixel shader.
//--------------------------------------------------------------------------------------
VOID PostProcess::GetSampleOffsets_Star( DWORD dwTexSize, XMVECTOR* pvTexCoordOffsets,
                                         XMVECTOR* pvColorWeights, FLOAT fDeviation )
{
    FLOAT tu = 1.0f / ( FLOAT )dwTexSize;

    // Fill the center texel
    FLOAT fWeight = 1.0f * GaussianDistribution( 0, 0, fDeviation );
    pvColorWeights[0] = XMVectorSet( fWeight, fWeight, fWeight, 1.0f );
    pvTexCoordOffsets[0] = XMVectorSet( 0.0f, 0.0f, 0.0f, 0.0f );

    // Fill the first half
    for( DWORD i = 1; i < 8; i++ )
    {
        // Get the Gaussian intensity for this offset
        fWeight = 1.0f * GaussianDistribution( ( FLOAT )i, 0, fDeviation );
        pvColorWeights[i] = XMVectorSet( fWeight, fWeight, fWeight, 1.0f );
        pvTexCoordOffsets[i] = XMVectorSet( i * tu, 0.0f, 0.0f, 0.0f );
    }

    // Mirror to the second half
    for( DWORD i = 8; i < 15; i++ )
    {
        pvColorWeights[i] = pvColorWeights[i - 7];
        pvTexCoordOffsets[i] = -pvTexCoordOffsets[i - 7];
    }
}


//-----------------------------------------------------------------------------
// Name: ClearTexture()
// Desc: Helper function for RestoreDeviceObjects to clear a texture surface
//-----------------------------------------------------------------------------
VOID PostProcess::ClearTexture( LPDIRECT3DTEXTURE9 pTexture, DWORD dwClearColor )
{
    // Make sure that the required shaders and objects exist
    assert( pTexture );

    DWORD OldFormat = pTexture->Format.DataFormat;
    if( pTexture->Format.DataFormat == GPUTEXTUREFORMAT_8_8_8_8_AS_16_16_16_16 )
    {
        pTexture->Format.DataFormat = GPUTEXTUREFORMAT_8_8_8_8;
    }

    // Create and set a render target for the texture
    PushRenderTarget( 0, CreateRenderTarget( pTexture ) );

    g_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, dwClearColor, 1.0f, 0L );

    g_pd3dDevice->Resolve( D3DRESOLVE_RENDERTARGET0, NULL, pTexture, NULL,
                           0, 0, NULL, 0.0f, 0, NULL );

    // Cleanup and exit
    PopRenderTarget( 0 )->Release();

    pTexture->Format.DataFormat = OldFormat;
}


//--------------------------------------------------------------------------------------
// Name: DrawScreenSpaceQuad()
// Desc: Draw a viewport-aligned quad using screen-space coordinates
//--------------------------------------------------------------------------------------
VOID PostProcess::DrawScreenSpaceQuad( FLOAT w, FLOAT h, FLOAT fMaxU, FLOAT fMaxV )
{
    // Make sure that the required shaders and objects exist
    assert( m_pQuadVtxDecl );
    assert( m_pScreenSpaceVS );

    // Define vertices for the screen-space rect
    XMFLOAT4 v[3];
    v[0] = XMFLOAT4( 0, 0, 0.0f, 0.0f );
    v[1] = XMFLOAT4( w, 0, fMaxU, 0.0f );
    v[2] = XMFLOAT4( 0, h, 0.0f, fMaxV );

    // Set states for drawing the quad
    PushRenderState( D3DRS_VIEWPORTENABLE, FALSE );
    PushRenderState( D3DRS_ZENABLE, FALSE );
    PushRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
    PushRenderState( D3DRS_HALFPIXELOFFSET, TRUE );

    // Draw the quad
    g_pd3dDevice->SetVertexDeclaration( m_pQuadVtxDecl );
    g_pd3dDevice->SetVertexShader( m_pScreenSpaceVS );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_RECTLIST, 1, v, sizeof( v[0] ) );

    PopRenderStates();
}


//--------------------------------------------------------------------------------------
// Name: DrawFullScreenQuad()
// Desc: Draw a viewport-aligned quad covering the entire render target
//--------------------------------------------------------------------------------------
VOID PostProcess::DrawFullScreenQuad()
{
    // Make sure that the required shaders and objects exist
    assert( m_pQuadVtxDecl );
    assert( m_pQuadVB );
    assert( m_pScreenSpaceVS );

    // Set states for drawing the rect
    PushRenderState( D3DRS_VIEWPORTENABLE, TRUE );
    PushRenderState( D3DRS_ZENABLE, FALSE );
    PushRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
    PushRenderState( D3DRS_HALFPIXELOFFSET, TRUE );

    // Draw the rect
    g_pd3dDevice->SetVertexDeclaration( m_pQuadVtxDecl );
    g_pd3dDevice->SetVertexShader( m_pScreenSpaceVS );
    g_pd3dDevice->SetStreamSource( 0, m_pQuadVB, 0, sizeof( XMFLOAT4 ) );
    g_pd3dDevice->DrawPrimitive( D3DPT_RECTLIST, 0, g_dwNumQuadsInGrid );

    PopRenderStates();
}


//--------------------------------------------------------------------------------------
// Name: BrightPassFilterTexture()
// Desc: Run the bright-pass filter on m_pScaledSceneTexture and place the result
//       in m_pBrightPassTexture
//--------------------------------------------------------------------------------------
VOID PostProcess::BrightPassFilterTexture( LPDIRECT3DTEXTURE9 pSrcTexture,
                                           LPDIRECT3DTEXTURE9 pAdaptedLuminanceTexture,
                                           FLOAT fMiddleGrayKeyValue,
                                           LPDIRECT3DTEXTURE9 pDstTexture )
{
    // Make sure that the required shaders and objects exist
    assert( m_pBrightPassFilterPS );
    assert( pSrcTexture && pDstTexture );

    XGTEXTURE_DESC SrcDesc;
    XGGetTextureDesc( pSrcTexture, 0, &SrcDesc );

    // Create and set a render target
    PushRenderTarget( 0L, CreateRenderTarget( pDstTexture ) );

    // Get the offsets to be used within the GaussBlur5x5 pixel shader
    XMVECTOR avSampleOffsets[MAX_SAMPLES];
    XMVECTOR avSampleWeights[MAX_SAMPLES];
    GetSampleOffsets_GaussBlur5x5( SrcDesc.Width, SrcDesc.Height, avSampleOffsets, avSampleWeights );
    g_pd3dDevice->SetPixelShaderConstantF( PSCONST_avSampleOffsets, ( FLOAT* )avSampleOffsets, MAX_SAMPLES );
    g_pd3dDevice->SetPixelShaderConstantF( PSCONST_avSampleWeights, ( FLOAT* )avSampleWeights, MAX_SAMPLES );
    g_pd3dDevice->SetPixelShaderConstantF( PSCONST_fMiddleGray, &fMiddleGrayKeyValue, 1 );
    g_pd3dDevice->SetPixelShader( m_pBrightPassFilterPS );

    g_pd3dDevice->SetTexture( 0, pSrcTexture );
    g_pd3dDevice->SetTexture( 1, pAdaptedLuminanceTexture );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_POINT );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_POINT );
    g_pd3dDevice->SetSamplerState( 1, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetSamplerState( 1, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetSamplerState( 1, D3DSAMP_MINFILTER, D3DTEXF_POINT );
    g_pd3dDevice->SetSamplerState( 1, D3DSAMP_MAGFILTER, D3DTEXF_POINT );

    // Draw a fullscreen quad to sample the RT
    DrawFullScreenQuad();

    g_pd3dDevice->Resolve( D3DRESOLVE_RENDERTARGET0, NULL, pDstTexture, NULL,
                           0, 0, NULL, 1.0f, 0L, NULL );

    // Cleanup and return
    PopRenderTarget( 0L )->Release();
    g_pd3dDevice->SetPixelShader( NULL );
}


//--------------------------------------------------------------------------------------
// Name: SampleLuminance()
// Desc: Measure the average log luminance in the scene.
//--------------------------------------------------------------------------------------
VOID PostProcess::SampleLuminance( LPDIRECT3DTEXTURE9 pSrcTexture, BOOL bInitial,
                                   LPDIRECT3DTEXTURE9 pDstTexture )
{
    // Make sure that the required shaders and objects exist
    assert( m_pSampleLumInitialPS );
    assert( m_pSampleLumFinalPS );
    assert( pSrcTexture && pDstTexture );

    XGTEXTURE_DESC SrcDesc;
    XGGetTextureDesc( pSrcTexture, 0, &SrcDesc );

    // Create and set a render target
    PushRenderTarget( 0L, CreateRenderTarget( pDstTexture ) );

    // Sample initial luminance
    if( bInitial )
    {
        // Initialize the sample offsets for the initial luminance pass.
        XMVECTOR avSampleOffsets[MAX_SAMPLES];
        GetSampleOffsets_DownScale3x3( SrcDesc.Width, SrcDesc.Height, avSampleOffsets );
        g_pd3dDevice->SetPixelShaderConstantF( PSCONST_avSampleOffsets, ( FLOAT* )avSampleOffsets, MAX_SAMPLES );
        g_pd3dDevice->SetPixelShader( m_pSampleLumInitialPS );

        g_pd3dDevice->SetTexture( 0, pSrcTexture );
        g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
        g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
        g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
        g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
    }
    else // ( bIntial == FALSE )
    {
        // Perform the final pass of the average luminance calculation. This pass
        // performs an exp() operation to return a single texel cooresponding to the
        // average luminance of the scene in m_pToneMapTexture.

        XMVECTOR avSampleOffsets[MAX_SAMPLES];
        GetSampleOffsets_DownScale4x4( SrcDesc.Width, SrcDesc.Height, avSampleOffsets );
        g_pd3dDevice->SetPixelShaderConstantF( PSCONST_avSampleOffsets, ( FLOAT* )avSampleOffsets, MAX_SAMPLES );
        g_pd3dDevice->SetPixelShader( m_pSampleLumFinalPS );

        g_pd3dDevice->SetTexture( 0, pSrcTexture );
        g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_POINT );
        g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_POINT );
        g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
        g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP );
    }

    // Draw a fullscreen quad to sample the RT
    DrawFullScreenQuad();

    g_pd3dDevice->Resolve( D3DRESOLVE_RENDERTARGET0, NULL, pDstTexture, NULL,
                           0, 0, NULL, 1.0f, 0L, NULL );

    // Cleanup and return
    PopRenderTarget( 0L )->Release();
    g_pd3dDevice->SetPixelShader( NULL );
}


//--------------------------------------------------------------------------------------
// Name: AdaptLuminance()
// Desc: Adapt the luminance over time and place the result in pDstTexture
//--------------------------------------------------------------------------------------
VOID PostProcess::AdaptLuminance( LPDIRECT3DTEXTURE9 pAdaptedLuminanceTexture,
                                  LPDIRECT3DTEXTURE9 pToneMapTexture,
                                  FLOAT fElapsedTime,
                                  LPDIRECT3DTEXTURE9 pDstTexture )
{
    // Make sure that the required shaders and objects exist
    assert( m_pCalculateAdaptedLumPS );
    assert( pAdaptedLuminanceTexture && pToneMapTexture && pDstTexture );

    // Create and set a render target
    PushRenderTarget( 0L, CreateRenderTarget( pDstTexture ) );

    // This simulates the light adaptation that occurs when moving from a dark area to
    // a bright area, or vice versa. The m_pTexAdaptedLuminance texture stores a single
    // texel cooresponding to the user's adapted level.
    g_pd3dDevice->SetPixelShaderConstantF( PSCONST_fElapsedTime, &fElapsedTime, 1 );
    g_pd3dDevice->SetPixelShader( m_pCalculateAdaptedLumPS );

    g_pd3dDevice->SetTexture( 0, pAdaptedLuminanceTexture );
    g_pd3dDevice->SetTexture( 1, pToneMapTexture );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_POINT );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_POINT );
    g_pd3dDevice->SetSamplerState( 1, D3DSAMP_MAGFILTER, D3DTEXF_POINT );
    g_pd3dDevice->SetSamplerState( 1, D3DSAMP_MINFILTER, D3DTEXF_POINT );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetSamplerState( 1, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetSamplerState( 1, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP );

    // Draw a fullscreen quad to sample the RT
    DrawFullScreenQuad();

    g_pd3dDevice->Resolve( D3DRESOLVE_RENDERTARGET0, NULL, pDstTexture, NULL,
                           0, 0, NULL, 1.0f, 0L, NULL );

    // Cleanup and return
    PopRenderTarget( 0L )->Release();
    g_pd3dDevice->SetPixelShader( NULL );
}


//--------------------------------------------------------------------------------------
// Name: GaussBlur5x5Texture()
// Desc: Perform a 5x5 gaussian blur on pSrcTexture and place the result in pDstTexture
//--------------------------------------------------------------------------------------
VOID PostProcess::GaussBlur5x5Texture( LPDIRECT3DTEXTURE9 pSrcTexture,
                                       LPDIRECT3DTEXTURE9 pDstTexture,
                                       DWORD dwEdramOffset )
{
    // Make sure that the required shaders and objects exist
    assert( m_pGaussBlur5x5PS );
    assert( pSrcTexture && pDstTexture );

    XGTEXTURE_DESC SrcDesc;
    XGGetTextureDesc( pSrcTexture, 0, &SrcDesc );

    // Create and set a render target
    D3DSURFACE_PARAMETERS surfaceParams =
    {
        0
    };
    surfaceParams.Base = dwEdramOffset;
    PushRenderTarget( 0L, CreateRenderTarget( pDstTexture, &surfaceParams ) );

    XMVECTOR avSampleOffsets[MAX_SAMPLES];
    XMVECTOR avSampleWeights[MAX_SAMPLES];
    GetSampleOffsets_GaussBlur5x5( SrcDesc.Width, SrcDesc.Height, avSampleOffsets, avSampleWeights );
    g_pd3dDevice->SetPixelShaderConstantF( PSCONST_avSampleOffsets, ( FLOAT* )avSampleOffsets, MAX_SAMPLES );
    g_pd3dDevice->SetPixelShaderConstantF( PSCONST_avSampleWeights, ( FLOAT* )avSampleWeights, MAX_SAMPLES );
    g_pd3dDevice->SetPixelShader( m_pGaussBlur5x5PS );

    g_pd3dDevice->SetTexture( 0, pSrcTexture );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_POINT );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_POINT );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP );

    // Draw a fullscreen quad to sample the RT
    DrawFullScreenQuad();

    g_pd3dDevice->Resolve( D3DRESOLVE_RENDERTARGET0, NULL, pDstTexture, NULL,
                           0, 0, NULL, 1.0f, 0L, NULL );

    // Cleanup and return
    PopRenderTarget( 0L )->Release();
    g_pd3dDevice->SetPixelShader( NULL );
}


//--------------------------------------------------------------------------------------
// Name: Downsample4x4Texture()
// Desc: Scale down pSrcTexture by 1/4 x 1/4 and place the result in pDstTexture
//--------------------------------------------------------------------------------------
VOID PostProcess::Downsample4x4Texture( LPDIRECT3DTEXTURE9 pSrcTexture,
                                        LPDIRECT3DTEXTURE9 pDstTexture )
{
    // Make sure that the required shaders and objects exist
    assert( m_pDownScale4x4PS );
    assert( pSrcTexture && pDstTexture );

    XGTEXTURE_DESC SrcDesc;
    XGGetTextureDesc( pSrcTexture, 0, &SrcDesc );

    // Create and set a render target
    PushRenderTarget( 0L, CreateRenderTarget( pDstTexture ) );

    // Get the sample offsets used within the pixel shader
    XMVECTOR avSampleOffsets[MAX_SAMPLES];
    GetSampleOffsets_DownScale4x4( SrcDesc.Width, SrcDesc.Height, avSampleOffsets );
    g_pd3dDevice->SetPixelShaderConstantF( PSCONST_avSampleOffsets, ( FLOAT* )avSampleOffsets, MAX_SAMPLES );
    g_pd3dDevice->SetPixelShader( m_pDownScale4x4PS );

    g_pd3dDevice->SetTexture( 0, pSrcTexture );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_POINT );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP );

    // Draw a fullscreen quad
    DrawFullScreenQuad();

    g_pd3dDevice->Resolve( D3DRESOLVE_RENDERTARGET0, NULL, pDstTexture, NULL,
                           0, 0, NULL, 1.0f, 0L, NULL );

    // Cleanup and return
    PopRenderTarget( 0L )->Release();
    g_pd3dDevice->SetPixelShader( NULL );
}


//--------------------------------------------------------------------------------------
// Name: CopyTexture()
// Desc: Copy the src texture to the dst texture. The scale can (and should) be changed.
//--------------------------------------------------------------------------------------
VOID PostProcess::CopyTexture( LPDIRECT3DTEXTURE9 pSrcTexture,
                               LPDIRECT3DTEXTURE9 pDstTexture,
                               LPDIRECT3DPIXELSHADER9 pPixelShader,
                               DWORD dwEdramOffset )
{
    if( NULL == pPixelShader )
        pPixelShader = m_pCopyTexturePS;

    // Make sure that the required shaders and objects exist
    assert( pPixelShader );
    assert( pSrcTexture && pDstTexture );

    XGTEXTURE_DESC SrcDesc;
    XGGetTextureDesc( pSrcTexture, 0, &SrcDesc );

    // Create and set a render target
    D3DSURFACE_PARAMETERS surfaceParams =
    {
        0
    };
    surfaceParams.Base = dwEdramOffset;
    PushRenderTarget( 0L, CreateRenderTarget( pDstTexture, &surfaceParams ) );

    // Scale and copy the src texture
    g_pd3dDevice->SetPixelShader( pPixelShader );

    g_pd3dDevice->SetTexture( 0, pSrcTexture );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MIPFILTER, D3DTEXF_POINT );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP );

    // Draw a fullscreen quad to sample the RT
    DrawFullScreenQuad();

    XGTEXTURE_DESC DstDesc;
    XGGetTextureDesc( pDstTexture, 0, &DstDesc );
    DWORD ColorExpBias = 0;

    if( DstDesc.Format == D3DFMT_G16R16_SIGNED_INTEGER )            ColorExpBias = ( DWORD )
            D3DRESOLVE_EXPONENTBIAS( 10 );
    else if( DstDesc.Format == D3DFMT_A16B16G16R16_SIGNED_INTEGER ) ColorExpBias = ( DWORD )
            D3DRESOLVE_EXPONENTBIAS( 10 );

    g_pd3dDevice->Resolve( D3DRESOLVE_RENDERTARGET0 | ColorExpBias, NULL, pDstTexture, NULL,
                           0, 0, NULL, 1.0f, 0L, NULL );

    // Cleanup and return
    PopRenderTarget( 0L )->Release();
    g_pd3dDevice->SetPixelShader( NULL );
}


//--------------------------------------------------------------------------------------
// Name: BuildMipMaps()
// Desc: Generate mip maps from the base texture
//--------------------------------------------------------------------------------------
VOID PostProcess::BuildMipMaps( LPDIRECT3DTEXTURE9 pTexture )
{
    // Make sure that the required shaders and objects exist
    assert( m_pCopyTexturePS );
    assert( pTexture );

    DWORD dwNumMipLevels = pTexture->GetLevelCount();

    // Create and set a render target
    PushRenderTarget( 0L, CreateRenderTarget( pTexture ) );

    // Scale and copy the src texture
    g_pd3dDevice->SetPixelShader( m_pCopyTexturePS );

    g_pd3dDevice->SetTexture( 0, pTexture );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MIPFILTER, D3DTEXF_POINT );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP );

    D3DVIEWPORT9 vp;
    g_pd3dDevice->GetViewport( &vp );

    for( DWORD i = 1; i < dwNumMipLevels; i++ )
    {
        XGTEXTURE_DESC Desc;
        XGGetTextureDesc( pTexture, i, &Desc );
        vp.Width = Desc.Width;
        vp.Height = Desc.Height;
        g_pd3dDevice->SetViewport( &vp );
        g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINMIPLEVEL, i - 1 );

        // Draw a fullscreen quad to sample the RT
        DrawFullScreenQuad();

        DWORD ColorExpBias = 0;

        if( Desc.Format == D3DFMT_G16R16_SIGNED_INTEGER )            ColorExpBias = (DWORD) D3DRESOLVE_EXPONENTBIAS(10);
        else if( Desc.Format == D3DFMT_A16B16G16R16_SIGNED_INTEGER ) ColorExpBias = (DWORD) D3DRESOLVE_EXPONENTBIAS(10);

        g_pd3dDevice->Resolve( D3DRESOLVE_RENDERTARGET0 | ColorExpBias, NULL, pTexture, NULL,
                               i, 0, NULL, 1.0f, 0L, NULL );
    }

    // Cleanup and return
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINMIPLEVEL, 13 );
    PopRenderTarget( 0L )->Release();
    g_pd3dDevice->SetPixelShader( NULL );
}


//--------------------------------------------------------------------------------------
// Name: Downsample2x2Texture()
// Desc: Scale down pSrcTexture by 1/2 x 1/2 and place the result in pDstTexture
//--------------------------------------------------------------------------------------
VOID PostProcess::Downsample2x2Texture( LPDIRECT3DTEXTURE9 pSrcTexture,
                                        LPDIRECT3DTEXTURE9 pDstTexture,
                                        DWORD dwEdramOffset )
{
    // Make sure that the required shaders and objects exist
    assert( m_pDownScale2x2PS );
    assert( pSrcTexture && pDstTexture );

    XGTEXTURE_DESC SrcDesc;
    XGGetTextureDesc( pSrcTexture, 0, &SrcDesc );

    // Create and set a render target
    D3DSURFACE_PARAMETERS surfaceParams = { 0 };
    surfaceParams.Base = dwEdramOffset;
    PushRenderTarget( 0L, CreateRenderTarget( pDstTexture, &surfaceParams ) );

    XMVECTOR avSampleOffsets[MAX_SAMPLES];
    GetSampleOffsets_DownScale2x2( SrcDesc.Width, SrcDesc.Height, avSampleOffsets );
    g_pd3dDevice->SetPixelShaderConstantF( PSCONST_avSampleOffsets, ( FLOAT* )avSampleOffsets, MAX_SAMPLES );

    // Create an exact 1/2 x 1/2 copy of the source texture
    g_pd3dDevice->SetPixelShader( m_pDownScale2x2PS );

    g_pd3dDevice->SetTexture( 0, pSrcTexture );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_POINT );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP );

    // TODO: This should use border addressing with a black border!
    //m_pStarSourceTexture->Format.ClampX      = GPUCLAMP_CLAMP_TO_BORDER;
    //m_pStarSourceTexture->Format.ClampY      = GPUCLAMP_CLAMP_TO_BORDER;
    //m_pStarSourceTexture->Format.BorderColor = GPUBORDERCOLOR_ABGR_BLACK;
    //g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSU, D3DTADDRESS_BORDER );
    //g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSV, D3DTADDRESS_BORDER );

    // Draw a fullscreen quad to sample the RT
    DrawFullScreenQuad();

    g_pd3dDevice->Resolve( D3DRESOLVE_RENDERTARGET0, NULL, pDstTexture, NULL,
                           0, 0, NULL, 1.0f, 0L, NULL );

    // Cleanup and return
    PopRenderTarget( 0L )->Release();
    g_pd3dDevice->SetPixelShader( NULL );
}


//--------------------------------------------------------------------------------------
// Name: BloomTexture()
// Desc: Bloom the pSrcTexture and place the result in pDstTexture
//--------------------------------------------------------------------------------------
VOID PostProcess::BloomTexture( LPDIRECT3DTEXTURE9 pSrcTexture,
                                BOOL bBloomAcrossWidth,
                                LPDIRECT3DTEXTURE9 pDstTexture,
                                FLOAT fSize, FLOAT fBrightness )
{
    // Make sure that the required shaders and objects exist
    assert( m_pBloomPS );
    assert( pSrcTexture && pDstTexture );

    XGTEXTURE_DESC SrcDesc;
    XGGetTextureDesc( pSrcTexture, 0, &SrcDesc );

    // Create and set a render target
    PushRenderTarget( 0L, CreateRenderTarget( pDstTexture ) );

    XMVECTOR avSampleOffsets[MAX_SAMPLES];
    XMVECTOR avSampleWeights[MAX_SAMPLES];

    if( bBloomAcrossWidth )
        GetSampleOffsets_Bloom( SrcDesc.Width, SrcDesc.Height, 0.0f * XM_PIDIV2, avSampleOffsets, avSampleWeights,
                                fSize, fBrightness );
    else
        GetSampleOffsets_Bloom( SrcDesc.Width, SrcDesc.Height, 1.0f * XM_PIDIV2, avSampleOffsets, avSampleWeights,
                                fSize, fBrightness );

    g_pd3dDevice->SetPixelShaderConstantF( PSCONST_avSampleOffsets, ( FLOAT* )avSampleOffsets, MAX_SAMPLES );
    g_pd3dDevice->SetPixelShaderConstantF( PSCONST_avSampleWeights, ( FLOAT* )avSampleWeights, MAX_SAMPLES );
    g_pd3dDevice->SetPixelShader( m_pBloomPS );

    g_pd3dDevice->SetTexture( 0, pSrcTexture );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_POINT );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_POINT );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP );

    // Draw a fullscreen quad to sample the RT
    DrawFullScreenQuad();

    g_pd3dDevice->Resolve( D3DRESOLVE_RENDERTARGET0, NULL, pDstTexture, NULL,
                           0, 0, NULL, 1.0f, 0L, NULL );

    // Cleanup and return
    PopRenderTarget( 0L )->Release();
    g_pd3dDevice->SetPixelShader( NULL );
}


//--------------------------------------------------------------------------------------
// Name: RenderStarLine()
// Desc: Merge the ppSrcTextures and place the result in pDstTexture
//--------------------------------------------------------------------------------------
VOID PostProcess::RenderStarLine( LPDIRECT3DTEXTURE9 pSrcTexture, DWORD dwNumSamples,
                                  FLOAT fAttenuation, FLOAT fAttnPowScale,
                                  XMVECTOR* colors, DWORD pass,
                                  FLOAT fStepU, FLOAT fStepV,
                                  LPDIRECT3DTEXTURE9 pDstTexture )
{
    // Make sure that the required shaders and objects exist
    assert( m_pStarPS );
    assert( pSrcTexture && pDstTexture );

    // Create and set a render target
    PushRenderTarget( 0L, CreateRenderTarget( pDstTexture ) );

    XMVECTOR avSampleOffsets[MAX_SAMPLES];
    XMVECTOR avSampleWeights[MAX_SAMPLES];

    // Sampling configration for each stage
    for( DWORD i = 0; i < dwNumSamples; i++ )
    {
        FLOAT lum = powf( fAttenuation, fAttnPowScale * i );

        avSampleWeights[i] = colors[i] * lum * ( pass + 1.0f ) * 0.5f;

        // Offset of sampling coordinate
        avSampleOffsets[i].x = fStepU * i;
        avSampleOffsets[i].y = fStepV * i;
        if( fabs( avSampleOffsets[i].x ) >= 0.9f || fabs( avSampleOffsets[i].y ) >= 0.9f )
        {
            avSampleOffsets[i].x = 0.0f;
            avSampleOffsets[i].y = 0.0f;
            avSampleWeights[i] *= 0.0f;
        }
    }

    g_pd3dDevice->SetPixelShader( m_pStarPS );
    g_pd3dDevice->SetPixelShaderConstantF( PSCONST_avSampleOffsets, ( FLOAT* )avSampleOffsets, MAX_SAMPLES );
    g_pd3dDevice->SetPixelShaderConstantF( PSCONST_avSampleWeights, ( FLOAT* )avSampleWeights, MAX_SAMPLES );

    g_pd3dDevice->SetTexture( 0, pSrcTexture );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetSamplerState( 0, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP );

    // Draw a fullscreen quad to sample the RT
    DrawFullScreenQuad();

    g_pd3dDevice->Resolve( D3DRESOLVE_RENDERTARGET0, NULL, pDstTexture, NULL,
                           0, 0, NULL, 1.0f, 0L, NULL );

    // Cleanup and return
    PopRenderTarget( 0L )->Release();
    g_pd3dDevice->SetPixelShader( NULL );
}


//--------------------------------------------------------------------------------------
// Name: MergeTextures()
// Desc: Merge the ppSrcTextures and place the result in pDstTexture
//--------------------------------------------------------------------------------------
VOID PostProcess::MergeTextures( LPDIRECT3DTEXTURE9* ppSrcTextures,
                                 DWORD dwNumSrcTextures,
                                 LPDIRECT3DTEXTURE9 pDstTexture )
{
    // Make sure that the required shaders and objects exist
    assert( m_pMergeTexturesPS[dwNumSrcTextures] );
    assert( ppSrcTextures && pDstTexture );

    // Create and set a render target
    PushRenderTarget( 0L, CreateRenderTarget( pDstTexture ) );

    XMVECTOR avSampleWeights[MAX_SAMPLES];
    const XMVECTOR vWhite = XMVectorSet( 1.0f, 1.0f, 1.0f, 1.0f );
    for( DWORD i = 0; i < dwNumSrcTextures; i++ )
    {
        g_pd3dDevice->SetTexture( i, ppSrcTextures[i] );
        g_pd3dDevice->SetSamplerState( i, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
        g_pd3dDevice->SetSamplerState( i, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
        g_pd3dDevice->SetSamplerState( i, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
        g_pd3dDevice->SetSamplerState( i, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP );

        avSampleWeights[i] = vWhite * 1.0f / ( FLOAT )dwNumSrcTextures;
    }

    g_pd3dDevice->SetPixelShaderConstantF( PSCONST_avSampleWeights, ( FLOAT* )avSampleWeights, dwNumSrcTextures );
    g_pd3dDevice->SetPixelShader( m_pMergeTexturesPS[dwNumSrcTextures] );

    // Draw a fullscreen quad to sample the RT
    DrawFullScreenQuad();

    g_pd3dDevice->Resolve( D3DRESOLVE_RENDERTARGET0, NULL, pDstTexture, NULL,
                           0, 0, NULL, 1.0f, 0L, NULL );

    // Cleanup and return
    PopRenderTarget( 0L )->Release();
    g_pd3dDevice->SetPixelShader( NULL );
}


//--------------------------------------------------------------------------------------
// Name: AddTextures()
// Desc: Add the ppSrcTextures and place the result in pDstTexture
//--------------------------------------------------------------------------------------
VOID PostProcess::AddTextures( LPDIRECT3DTEXTURE9* ppSrcTextures,
                               DWORD dwNumSrcTextures,
                               LPDIRECT3DTEXTURE9 pDstTexture )
{
    // Make sure that the required shaders and objects exist
    assert( m_pMergeTexturesPS[dwNumSrcTextures] );
    assert( ppSrcTextures && pDstTexture );

    // Create and set a render target
    PushRenderTarget( 0L, CreateRenderTarget( pDstTexture ) );

    XMVECTOR avSampleWeights[MAX_SAMPLES];
    const XMVECTOR vWhite = XMVectorSet( 1.0f, 1.0f, 1.0f, 1.0f );
    for( DWORD i = 0; i < dwNumSrcTextures; i++ )
    {
        g_pd3dDevice->SetTexture( i, ppSrcTextures[i] );
        g_pd3dDevice->SetSamplerState( i, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
        g_pd3dDevice->SetSamplerState( i, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
        g_pd3dDevice->SetSamplerState( i, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP );
        g_pd3dDevice->SetSamplerState( i, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP );

        avSampleWeights[i] = vWhite;
    }

    g_pd3dDevice->SetPixelShaderConstantF( PSCONST_avSampleWeights, ( FLOAT* )avSampleWeights, dwNumSrcTextures );
    g_pd3dDevice->SetPixelShader( m_pMergeTexturesPS[dwNumSrcTextures] );

    // Draw a fullscreen quad to sample the RT
    DrawFullScreenQuad();

    g_pd3dDevice->Resolve( D3DRESOLVE_RENDERTARGET0, NULL, pDstTexture, NULL,
                           0, 0, NULL, 1.0f, 0L, NULL );

    // Cleanup and return
    PopRenderTarget( 0L )->Release();
    g_pd3dDevice->SetPixelShader( NULL );
}


//--------------------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize the effects library
//--------------------------------------------------------------------------------------
HRESULT PostProcess::Initialize()
{
    // Create a vertex buffer for screen-space effects
    g_pd3dDevice->CreateVertexBuffer( 3 * g_dwNumQuadsInGrid * sizeof( XMFLOAT4 ),
                                      0L, 0L, D3DPOOL_DEFAULT, &m_pQuadVB, NULL );
    XMFLOAT4* v;
    m_pQuadVB->Lock( 0, 0, ( VOID** )&v, 0 );

    FLOAT fGridDimX = 2.0f / ( FLOAT )g_dwQuadGridSizeX;
    FLOAT fGridDimY = 2.0f / ( FLOAT )g_dwQuadGridSizeY;
    FLOAT fGridDimU = 1.0f / ( FLOAT )g_dwQuadGridSizeX;
    FLOAT fGridDimV = 1.0f / ( FLOAT )g_dwQuadGridSizeY;
    FLOAT T = +1.0f;
    FLOAT V0 = 0.0f;
    for( DWORD y = 0; y < g_dwQuadGridSizeY; y++ )
    {
        FLOAT L = -1.0f;
        FLOAT U0 = 0.0f;
        for( DWORD x = 0; x < g_dwQuadGridSizeX; x++ )
        {
            FLOAT R = L + fGridDimX;
            FLOAT B = T - fGridDimY;
            FLOAT U1 = U0 + fGridDimU;
            FLOAT V1 = V0 + fGridDimV;

            *v++ = XMFLOAT4( L, T, U0, V0 ); // x, y, tu, tv
            *v++ = XMFLOAT4( R, T, U1, V0 ); // x, y, tu, tv
            *v++ = XMFLOAT4( L, B, U0, V1 ); // x, y, tu, tv
            L += fGridDimX;
            U0 += fGridDimU;
        }
        T -= fGridDimY;
        V0 += fGridDimV;
    }
    m_pQuadVB->Unlock();

    // Create common vertex declaration used by all the screen-space effects
    static const D3DVERTEXELEMENT9 decl[] =
    {
        { 0, 0, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0 },
        { 0, 8, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_TEXCOORD, 0 },
        D3DDECL_END()
    };

    g_pd3dDevice->CreateVertexDeclaration( decl, &m_pQuadVtxDecl );

    // Create shaders. Note that it's okay if these do not load, as long as the app does
    // not later try to use them. An assert will fire otherwise. This is so that the app
    // only needs to supply shaders that it actually intends to use.
    ATG::LoadVertexShader( "game:\\Media\\Shaders\\ScreenSpaceShader.xvu", &m_pScreenSpaceVS );
    ATG::LoadPixelShader( "game:\\Media\\Shaders\\CopyTexture.xpu", &m_pCopyTexturePS );
    ATG::LoadPixelShader( "game:\\Media\\Shaders\\Bloom.xpu", &m_pBloomPS );
    ATG::LoadPixelShader( "game:\\Media\\Shaders\\Star.xpu", &m_pStarPS );
    ATG::LoadPixelShader( "game:\\Media\\Shaders\\SampleLumInitial.xpu", &m_pSampleLumInitialPS );
    ATG::LoadPixelShader( "game:\\Media\\Shaders\\SampleLumFinal.xpu", &m_pSampleLumFinalPS );
    ATG::LoadPixelShader( "game:\\Media\\Shaders\\CalculateAdaptedLum.xpu", &m_pCalculateAdaptedLumPS );
    ATG::LoadPixelShader( "game:\\Media\\Shaders\\DownScale4x4.xpu", &m_pDownScale4x4PS );
    ATG::LoadPixelShader( "game:\\Media\\Shaders\\DownScale2x2.xpu", &m_pDownScale2x2PS );
    ATG::LoadPixelShader( "game:\\Media\\Shaders\\GaussBlur5x5.xpu", &m_pGaussBlur5x5PS );
    ATG::LoadPixelShader( "game:\\Media\\Shaders\\BrightPassFilter.xpu", &m_pBrightPassFilterPS );
    ATG::LoadPixelShader( "game:\\Media\\Shaders\\MergeTextures_1.xpu", &m_pMergeTexturesPS[1] );
    ATG::LoadPixelShader( "game:\\Media\\Shaders\\MergeTextures_2.xpu", &m_pMergeTexturesPS[2] );
    ATG::LoadPixelShader( "game:\\Media\\Shaders\\MergeTextures_3.xpu", &m_pMergeTexturesPS[3] );
    ATG::LoadPixelShader( "game:\\Media\\Shaders\\MergeTextures_4.xpu", &m_pMergeTexturesPS[4] );
    ATG::LoadPixelShader( "game:\\Media\\Shaders\\MergeTextures_5.xpu", &m_pMergeTexturesPS[5] );
    ATG::LoadPixelShader( "game:\\Media\\Shaders\\MergeTextures_6.xpu", &m_pMergeTexturesPS[6] );
    ATG::LoadPixelShader( "game:\\Media\\Shaders\\MergeTextures_7.xpu", &m_pMergeTexturesPS[7] );
    ATG::LoadPixelShader( "game:\\Media\\Shaders\\MergeTextures_8.xpu", &m_pMergeTexturesPS[8] );

    return S_OK;
}

}
;

```

`XenonDumper/libs/Atg/AtgPostProcess.h`:

```h
//--------------------------------------------------------------------------------------
// AtgPostProcess.h
//
// Commonly used post-processing effects (like bloom, blur, etc.)
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#pragma once
#ifndef ATGPOSTPROCESS_H
#define ATGPOSTPROCESS_H

#include <xtl.h>
#include <xboxmath.h>
#include <stack>
#include "AtgDevice.h"

namespace ATG
{

// External access to the global D3D device
extern D3DDevice* g_pd3dDevice;

// Special formats to keep full range of 16-bit fixed point render targets.  
// Textures using these formats should ideally use exp biases as follows:
//  1) -15 on sampling (Format.ExpAdjust in texture header)
//  2) +5 on write to render target (pParameters->ColorExpBias in CreateRenderTarget)
//  3) +10 on resolve (D3DRESOLVE_EXPONENTBIAS Flags in Resolve)
// With this setup you can losslessly traverse a full loop from EDRAM to texture to EDRAM,
// without making any shader changes.
static const D3DFORMAT D3DFMT_G16R16_SIGNED_INTEGER = ( D3DFORMAT )MAKED3DFMT2(
    GPUTEXTUREFORMAT_16_16, GPUENDIAN_8IN16, TRUE, GPUSIGN_SIGNED,
    GPUSIGN_SIGNED, GPUSIGN_SIGNED, GPUSIGN_SIGNED, GPUNUMFORMAT_INTEGER,
    GPUSWIZZLE_X, GPUSWIZZLE_Y, GPUSWIZZLE_0, GPUSWIZZLE_0 );
static const D3DFORMAT D3DFMT_A16B16G16R16_SIGNED_INTEGER = ( D3DFORMAT )MAKED3DFMT2(
    GPUTEXTUREFORMAT_16_16_16_16, GPUENDIAN_8IN16, TRUE, GPUSIGN_SIGNED,
    GPUSIGN_SIGNED, GPUSIGN_SIGNED, GPUSIGN_SIGNED, GPUNUMFORMAT_INTEGER,
    GPUSWIZZLE_X, GPUSWIZZLE_Y, GPUSWIZZLE_Z, GPUSWIZZLE_W );

//-----------------------------------------------------------------------------
// Name: CreateRenderTarget()
// Desc: Helper function to set a render target for a texture
//-----------------------------------------------------------------------------
inline LPDIRECT3DSURFACE9 CreateRenderTarget( const LPDIRECT3DTEXTURE9 pTexture,
                                              D3DSURFACE_PARAMETERS* pSurfaceParams = NULL )
{
    XGTEXTURE_DESC Desc;
    XGGetTextureDesc( pTexture, 0, &Desc );

    D3DSURFACE_PARAMETERS SurfaceParams = {0};
    if( NULL == pSurfaceParams )
    {
        pSurfaceParams = &SurfaceParams;
    }

    if( Desc.Format == D3DFMT_G16R16_SIGNED_INTEGER )               pSurfaceParams->ColorExpBias += 5;
    else if( Desc.Format == D3DFMT_A16B16G16R16_SIGNED_INTEGER )    pSurfaceParams->ColorExpBias += 5;

    // Some texture formats can't be used as render target formats.  Special
    // case the ones we use
    if( Desc.Format == D3DFMT_R5G6B5 )                         Desc.Format = D3DFMT_X8R8G8B8;
    else if( Desc.Format == D3DFMT_G16R16 )                         Desc.Format = D3DFMT_G16R16_EDRAM;
    else if( Desc.Format == D3DFMT_G16R16_SIGNED_INTEGER )          Desc.Format = D3DFMT_G16R16_EDRAM;
    else if( Desc.Format == D3DFMT_A16B16G16R16 )                   Desc.Format = D3DFMT_A16B16G16R16_EDRAM;
    else if( Desc.Format == D3DFMT_A16B16G16R16_SIGNED_INTEGER )    Desc.Format = D3DFMT_A16B16G16R16_EDRAM;
    else if( Desc.Format == D3DFMT_R16F_EXPAND )                    Desc.Format = D3DFMT_R32F;
    else if( Desc.Format == D3DFMT_R16F )                           Desc.Format = D3DFMT_R32F;
    else if( Desc.Format == D3DFMT_G16R16F_EXPAND )                 Desc.Format = D3DFMT_G16R16F;
    else if( Desc.Format == D3DFMT_A16B16G16R16F_EXPAND )           Desc.Format = D3DFMT_A16B16G16R16F;

    LPDIRECT3DSURFACE9 pRenderTarget;
    g_pd3dDevice->CreateRenderTarget( Desc.Width, Desc.Height, Desc.Format,
                                      D3DMULTISAMPLE_NONE, 0, FALSE,
                                      &pRenderTarget, pSurfaceParams );
    return pRenderTarget;
}


//-----------------------------------------------------------------------------
// Name: PushRenderTarget()/PopRenderTarget()
// Desc: Helper functions for setting/restoring render targets
//-----------------------------------------------------------------------------
extern std::stack <LPDIRECT3DSURFACE9> g_pRenderTargetStack;


// Pushes a render target onto a stack of saved states
inline VOID PushRenderTarget( DWORD dwRenderTargetID,
                              const LPDIRECT3DSURFACE9 pNewRenderTarget = NULL )
{
    LPDIRECT3DSURFACE9 pOldRenderTarget;
    g_pd3dDevice->GetRenderTarget( dwRenderTargetID, &pOldRenderTarget );
    if( pNewRenderTarget )
        g_pd3dDevice->SetRenderTarget( dwRenderTargetID, pNewRenderTarget );

    g_pRenderTargetStack.push( pOldRenderTarget );
    g_pRenderTargetStack.push( pNewRenderTarget );
}


// Pops a saved render target from a stack of saved states
inline LPDIRECT3DSURFACE9 PopRenderTarget( DWORD dwRenderTargetID )
{
    LPDIRECT3DSURFACE9 pNewRenderTarget = g_pRenderTargetStack.top(); g_pRenderTargetStack.pop();
    LPDIRECT3DSURFACE9 pOldRenderTarget = g_pRenderTargetStack.top(); g_pRenderTargetStack.pop();

    g_pd3dDevice->SetRenderTarget( dwRenderTargetID, pOldRenderTarget );
    if( pOldRenderTarget )
        pOldRenderTarget->Release();

    return pNewRenderTarget;
}


//-----------------------------------------------------------------------------
// Name: PushRenderState()/PopRenderState()
// Desc: Helper functions for setting/restoring render targets
//-----------------------------------------------------------------------------
struct RENDERSTATE
{
    D3DRENDERSTATETYPE dwRenderState;
    DWORD dwValue;
};

extern std::stack <RENDERSTATE> g_dwRenderStateStack;

// Pushes a render state onto a stack of saved states
inline VOID PushRenderState( DWORD dwRenderState, DWORD dwValue )
{
    DWORD dwOriginalValue;
    g_pd3dDevice->GetRenderState( ( D3DRENDERSTATETYPE )dwRenderState, &dwOriginalValue );

    RENDERSTATE rs;
    rs.dwRenderState = ( D3DRENDERSTATETYPE )dwRenderState;
    rs.dwValue = dwOriginalValue;
    g_dwRenderStateStack.push( rs );

    g_pd3dDevice->SetRenderState( ( D3DRENDERSTATETYPE )dwRenderState, dwValue );
}


// Pops a saved render state from a stack of saved states
inline VOID PopRenderStates()
{
    for( int i = 0; !g_dwRenderStateStack.empty(); ++i, g_dwRenderStateStack.pop() )
    {
        RENDERSTATE rs = g_dwRenderStateStack.top();

        g_pd3dDevice->SetRenderState( rs.dwRenderState, rs.dwValue );
    }
}


//--------------------------------------------------------------------------------------
// Name: class PostProcess
// Desc: Library of commonly used post-processing effects
//--------------------------------------------------------------------------------------
class PostProcess
{
    LPDIRECT3DVERTEXBUFFER9 m_pQuadVB;
    LPDIRECT3DVERTEXDECLARATION9 m_pQuadVtxDecl;
    LPDIRECT3DVERTEXSHADER9 m_pScreenSpaceVS;
    LPDIRECT3DPIXELSHADER9 m_pCopyTexturePS;
    LPDIRECT3DPIXELSHADER9 m_pBloomPS;
    LPDIRECT3DPIXELSHADER9 m_pStarPS;
    LPDIRECT3DPIXELSHADER9 m_pSampleLumInitialPS;
    LPDIRECT3DPIXELSHADER9 m_pSampleLumFinalPS;
    LPDIRECT3DPIXELSHADER9 m_pCalculateAdaptedLumPS;
    LPDIRECT3DPIXELSHADER9 m_pDownScale4x4PS;
    LPDIRECT3DPIXELSHADER9 m_pDownScale2x2PS;
    LPDIRECT3DPIXELSHADER9 m_pGaussBlur5x5PS;
    LPDIRECT3DPIXELSHADER9 m_pBrightPassFilterPS;
    LPDIRECT3DPIXELSHADER9  m_pMergeTexturesPS[9];

    // Sample offset calculation. These offsets are passed to corresponding pixel shaders.
    VOID    GetSampleOffsets_GaussBlur5x5( DWORD dwTextureWidth, DWORD dwTextureHeight,
                                           OUT XMVECTOR* pvTexCoordOffsets,
                                           OUT XMVECTOR* vSampleWeights,
                                           OPTIONAL FLOAT fMultiplier=1.0f );
    VOID    GetSampleOffsets_Bloom( DWORD dwTextureWidth, DWORD dwTextureHeight,
                                    FLOAT fAngle, OUT XMVECTOR* pvTexCoordOffsets,
                                    OUT XMVECTOR* pvColorWeights, FLOAT fDeviation,
                                    FLOAT OPTIONAL fMultiplier=1.0f );
    VOID    GetSampleOffsets_Star( DWORD dwTextureSize,
                                   OUT XMVECTOR* pvTexCoordOffsets,
                                   OUT XMVECTOR* pvColorWeights, FLOAT fDeviation );
    VOID    GetSampleOffsets_DownScale4x4( DWORD dwWidth, DWORD dwHeight,
                                           OUT XMVECTOR* pvSampleOffsets );
    VOID    GetSampleOffsets_DownScale3x3( DWORD dwWidth, DWORD dwHeight,
                                           OUT XMVECTOR* pvSampleOffsets );
    VOID    GetSampleOffsets_DownScale2x2( DWORD dwWidth, DWORD dwHeight,
                                           OUT XMVECTOR* pvSampleOffsets );

public:
    HRESULT Initialize();

    // Post-processing source textures creation
    VOID    ClearTexture( LPDIRECT3DTEXTURE9 pTexture,
                          OPTIONAL DWORD dwClearColor = 0x00000000 );
    VOID    CopyTexture( LPDIRECT3DTEXTURE9 pSrcTexture,
                         LPDIRECT3DTEXTURE9 pDstTexture,
                         LPDIRECT3DPIXELSHADER9 pPixelShader = NULL,
                         OPTIONAL DWORD         dwEdramOffset = 0 );
    VOID    BuildMipMaps( LPDIRECT3DTEXTURE9 pTexture );
    VOID    Downsample2x2Texture( LPDIRECT3DTEXTURE9 pSrcTexture,
                                  LPDIRECT3DTEXTURE9 pDstTexture,
                                  OPTIONAL DWORD     dwEdramOffset = 0 );
    VOID    Downsample4x4Texture( LPDIRECT3DTEXTURE9 pSrcTexture,
                                  LPDIRECT3DTEXTURE9 pDstTexture );
    VOID    GaussBlur5x5Texture( LPDIRECT3DTEXTURE9 pSrcTexture,
                                 LPDIRECT3DTEXTURE9 pDstTexture,
                                 OPTIONAL DWORD     dwEdramOffset = 0 );
    VOID    BrightPassFilterTexture( LPDIRECT3DTEXTURE9 pSrcTexture,
                                     LPDIRECT3DTEXTURE9 pAdaptedLuminanceTexture, 
                                     FLOAT              fMiddleGrayKeyValue,
                                     LPDIRECT3DTEXTURE9 pDstTexture );
    VOID    AddTextures( LPDIRECT3DTEXTURE9* ppSrcTextures,
                         DWORD dwNumSrcTextures,
                         LPDIRECT3DTEXTURE9 pDstTexture );
    VOID    MergeTextures( LPDIRECT3DTEXTURE9* ppSrcTextures,
                           DWORD dwNumSrcTextures,
                           LPDIRECT3DTEXTURE9 pDstTexture );
    VOID    AdaptLuminance( LPDIRECT3DTEXTURE9 pAdaptedLuminanceTexture, 
                            LPDIRECT3DTEXTURE9 pToneMapTexture, 
                            FLOAT fElapsedTime,
                            LPDIRECT3DTEXTURE9 pDstTexture );
    VOID    SampleLuminance( LPDIRECT3DTEXTURE9 pSrcTexture, BOOL bInitial,
                             LPDIRECT3DTEXTURE9 pDstTexture );
    VOID    BloomTexture( LPDIRECT3DTEXTURE9 pSrcTexture, BOOL bBloomAcrossWidth,
                          LPDIRECT3DTEXTURE9 pDstTexture,
                          FLOAT fSize = 3.0f, FLOAT fBrightness = 2.0f );
    VOID    RenderStarLine( LPDIRECT3DTEXTURE9 pSrcTexture, DWORD dwNumSamples,
                            FLOAT fAttenuation, FLOAT fAttnPowScale,
                            XMVECTOR* colors, DWORD pass,
                            FLOAT fStepU, FLOAT fStepV, 
                            LPDIRECT3DTEXTURE9 pDstTexture );

    VOID    DrawScreenSpaceQuad( FLOAT fWidth, FLOAT fHeight,
                                 FLOAT fMaxU=1.0f, FLOAT fMaxV=1.0f );
    VOID    DrawFullScreenQuad();
};

}
// namespace ATG

#endif // ATGPOSTPROCESS_H

```

`XenonDumper/libs/Atg/AtgResource.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// AtgResource.cpp
//
// Loads resources from an XPR (Xbox Packed Resource) file
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#include "stdafx.h"
#include "AtgDevice.h"
#include "AtgResource.h"
#include "AtgUtil.h"

namespace ATG
{


// Global access to the main D3D device
extern D3DDevice* g_pd3dDevice;


//--------------------------------------------------------------------------------------
// Magic values to identify XPR files
//--------------------------------------------------------------------------------------
struct XPR_HEADER
{
    DWORD dwMagic;
    DWORD dwHeaderSize;
    DWORD dwDataSize;
};

const DWORD XPR2_MAGIC_VALUE = 0x58505232;

const DWORD eXALLOCAllocatorId_AtgResource = eXALLOCAllocatorId_GameMax;


//--------------------------------------------------------------------------------------
// Name: PackedResource
//--------------------------------------------------------------------------------------
PackedResource::PackedResource()
{
    m_pSysMemData = NULL;
    m_dwSysMemDataSize = 0L;
    m_pVidMemData = NULL;
    m_dwVidMemDataSize = 0L;
    m_pResourceTags = NULL;
    m_dwNumResourceTags = 0L;
    m_bInitialized = FALSE;
}


//--------------------------------------------------------------------------------------
// Name: PackedResource
//--------------------------------------------------------------------------------------
PackedResource::~PackedResource()
{
    Destroy();
}


//--------------------------------------------------------------------------------------
// Name: GetData
// Desc: Loads all the texture resources from the given XPR.
//--------------------------------------------------------------------------------------
VOID* PackedResource::GetData( const CHAR* strName ) const
{
    if( NULL == m_pResourceTags || NULL == strName )
        return NULL;

    for( DWORD i = 0; i < m_dwNumResourceTags; i++ )
    {
        if( !_stricmp( strName, m_pResourceTags[i].strName ) )
        {
            return &m_pSysMemData[m_pResourceTags[i].dwOffset];
        }
    }

    return NULL;
}


//--------------------------------------------------------------------------------------
// Name: AllocateContiguousMemory()
// Desc: Wrapper for XMemAlloc
//--------------------------------------------------------------------------------------
static __forceinline void* AllocateContiguousMemory( DWORD Size, DWORD Alignment,
                                                     DWORD Protection = XALLOC_MEMPROTECT_WRITECOMBINE )
{
    return XMemAlloc( Size, MAKE_XALLOC_ATTRIBUTES( 0, 0, 0, 0, eXALLOCAllocatorId_AtgResource,
                                                    Alignment, Protection, 0,
                                                    XALLOC_MEMTYPE_PHYSICAL ) );
}


//--------------------------------------------------------------------------------------
// Name: FreeContiguousMemory()
// Desc: Wrapper for XMemFree
//--------------------------------------------------------------------------------------
static __forceinline VOID FreeContiguousMemory( VOID* pData )
{
    return XMemFree( pData, MAKE_XALLOC_ATTRIBUTES( 0, 0, 0, 0, eXALLOCAllocatorId_AtgResource,
                                                    0, 0, 0, XALLOC_MEMTYPE_PHYSICAL ) );
}


//--------------------------------------------------------------------------------------
// Name: Create
// Desc: Loads all the texture resources from the given XPR.
//--------------------------------------------------------------------------------------
HRESULT PackedResource::Create( const CHAR* strFilename )
{
    // Open the file
    DWORD dwNumBytesRead;
    HANDLE hFile = CreateFile( strFilename, GENERIC_READ, FILE_SHARE_READ, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL );
    if( hFile == INVALID_HANDLE_VALUE )
    {
        ATG_PrintError( "File <%s> not found\n", strFilename );
        return E_FAIL;
    }

    // Read in and verify the XPR magic header
    XPR_HEADER xprh;
    if( !ReadFile( hFile, &xprh, sizeof( XPR_HEADER ), &dwNumBytesRead, NULL ) )
    {
        ATG_PrintError( "Error reading XPR header in file <%s>\n", strFilename );
        CloseHandle( hFile );
        return E_FAIL;
    }

#ifdef _PC
    XGEndianSwapMemory( &xprh, &xprh, XGENDIAN_8IN32, sizeof(DWORD), sizeof(XPR_HEADER)/sizeof(DWORD) );
#endif

    if( xprh.dwMagic != XPR2_MAGIC_VALUE )
    {
        ATG_PrintError( "Invalid Xbox Packed Resource (.xpr) file: Magic = 0x%08lx\n", xprh.dwMagic );
        CloseHandle( hFile );
        return E_FAIL;
    }

    // Compute memory requirements
    m_dwSysMemDataSize = xprh.dwHeaderSize;
    m_dwVidMemDataSize = xprh.dwDataSize;

    // Allocate memory
    m_pSysMemData = new BYTE[m_dwSysMemDataSize];
    if( m_pSysMemData == NULL )
    {
        ATG_PrintError( "Could not allocate system memory.\n" );
        m_dwSysMemDataSize = 0;
        return E_FAIL;
    }
    m_pVidMemData = ( BYTE* )AllocateContiguousMemory( m_dwVidMemDataSize, XALLOC_PHYSICAL_ALIGNMENT_4K );
    if( m_pVidMemData == NULL )
    {
        ATG_PrintError( "Could not allocate physical memory.\n" );
        m_dwSysMemDataSize = 0;
        m_dwVidMemDataSize = 0;
        delete[] m_pSysMemData;
        m_pSysMemData = NULL;
        return E_FAIL;
    }

    // Read in the data from the file
    if( !ReadFile( hFile, m_pSysMemData, m_dwSysMemDataSize, &dwNumBytesRead, NULL ) ||
        !ReadFile( hFile, m_pVidMemData, m_dwVidMemDataSize, &dwNumBytesRead, NULL ) )
    {
        ATG_PrintError( "Unable to read Xbox Packed Resource (.xpr) file\n" );
        CloseHandle( hFile );
        return E_FAIL;
    }

    // Done with the file
    CloseHandle( hFile );

#ifdef _PC
    XGEndianSwapData( m_pSysMemData, m_pSysMemData, XGENDIAN_8IN32 );
#endif

    // Extract resource table from the header data
    m_dwNumResourceTags = *( DWORD* )( m_pSysMemData + 0 );
    m_pResourceTags = ( RESOURCE* )( m_pSysMemData + 4 );

#ifdef _PC
    XGEndianSwapMemory( m_pResourceTags, m_pResourceTags, XGENDIAN_8IN32, sizeof(DWORD), m_dwNumResourceTags * ( sizeof(RESOURCE) / sizeof(DWORD) ) );
#endif

    // Patch up the resources
    for( DWORD i = 0; i < m_dwNumResourceTags; i++ )
    {
        m_pResourceTags[i].strName = ( CHAR* )( m_pSysMemData + ( DWORD )m_pResourceTags[i].strName );

        // Fixup the texture memory
        if( ( m_pResourceTags[i].dwType & 0xffff0000 ) == ( RESOURCETYPE_TEXTURE & 0xffff0000 ) )
        {
            D3DTexture* pTexture = ( D3DTexture* )&m_pSysMemData[m_pResourceTags[i].dwOffset];
#ifdef _PC
            XGEndianSwapTextureHeader( pTexture );
#endif

            // Adjust Base address according to where memory was allocated
            XGOffsetBaseTextureAddress( pTexture, m_pVidMemData, m_pVidMemData );

            // Let PIX know the name of the texture
            PIXSetTextureName(pTexture, m_pResourceTags[i].strName);
        }
    }

    m_bInitialized = TRUE;

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: GetResourceTags
// Desc: Retrieves the resource tags
//--------------------------------------------------------------------------------------
VOID PackedResource::GetResourceTags( DWORD* pdwNumResourceTags,
                                      RESOURCE** ppResourceTags ) const
{
    if( pdwNumResourceTags )
        ( *pdwNumResourceTags ) = m_dwNumResourceTags;

    if( ppResourceTags )
        ( *ppResourceTags ) = m_pResourceTags;
}


//--------------------------------------------------------------------------------------
// Name: Destroy
// Desc: Cleans up the packed resource data
//--------------------------------------------------------------------------------------
VOID PackedResource::Destroy()
{
    delete[] m_pSysMemData;
    m_pSysMemData = NULL;
    m_dwSysMemDataSize = 0L;

    if( m_pVidMemData != NULL )
        FreeContiguousMemory( m_pVidMemData );
    m_pVidMemData = NULL;
    m_dwVidMemDataSize = 0L;

    m_pResourceTags = NULL;
    m_dwNumResourceTags = 0L;

    m_bInitialized = FALSE;
}

//--------------------------------------------------------------------------------------
// Name: Initialized
// Desc: Indicates whether the packed resource has been successfully initialized
//--------------------------------------------------------------------------------------
BOOL PackedResource::Initialized() const
{
    return m_bInitialized;
}

} // namespace ATG

```

`XenonDumper/libs/Atg/AtgResource.h`:

```h
//--------------------------------------------------------------------------------------
// AtgResource.h
//
// Loads resources from an XPR (Xbox Packed Resource) file.
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#pragma once
#ifndef ATGRESOURCE_H
#define ATGRESOURCE_H

namespace ATG
{

//--------------------------------------------------------------------------------------
// Name tag for resources. An app may initialize this structure, and pass
// it to the resource's Create() function. From then on, the app may call
// GetResource() to retrieve a resource using an ascii name.
//--------------------------------------------------------------------------------------
struct RESOURCE
{
    DWORD dwType;
    DWORD dwOffset;
    DWORD dwSize;
    CHAR* strName;
};


// Resource types
enum
{
    RESOURCETYPE_USERDATA       = ( ( 'U' << 24 ) | ( 'S' << 16 ) | ( 'E' << 8 ) | ( 'R' ) ),
    RESOURCETYPE_TEXTURE        = ( ( 'T' << 24 ) | ( 'X' << 16 ) | ( '2' << 8 ) | ( 'D' ) ),
    RESOURCETYPE_CUBEMAP        = ( ( 'T' << 24 ) | ( 'X' << 16 ) | ( 'C' << 8 ) | ( 'M' ) ),
    RESOURCETYPE_VOLUMETEXTURE  = ( ( 'T' << 24 ) | ( 'X' << 16 ) | ( '3' << 8 ) | ( 'D' ) ),
    RESOURCETYPE_VERTEXBUFFER   = ( ( 'V' << 24 ) | ( 'B' << 16 ) | ( 'U' << 8 ) | ( 'F' ) ),
    RESOURCETYPE_INDEXBUFFER    = ( ( 'I' << 24 ) | ( 'B' << 16 ) | ( 'U' << 8 ) | ( 'F' ) ),
    RESOURCETYPE_EOF            = 0xffffffff
};


//--------------------------------------------------------------------------------------
// Name: PackedResource
//--------------------------------------------------------------------------------------
class PackedResource
{
protected:
    BYTE* m_pSysMemData;        // Alloc'ed memory for resource headers etc.
    DWORD m_dwSysMemDataSize;

    BYTE* m_pVidMemData;        // Alloc'ed memory for resource data, etc.
    DWORD m_dwVidMemDataSize;

    RESOURCE* m_pResourceTags;      // Tags to associate names with the resources
    DWORD m_dwNumResourceTags;  // Number of resource tags
    BOOL m_bInitialized;       // Resource is fully initialized

public:
    // Loads the resources out of the specified bundle
    HRESULT Create( const CHAR* strFilename );

    VOID    Destroy();

    BOOL    Initialized() const;

    // Retrieves the resource tags
    VOID    GetResourceTags( DWORD* pdwNumResourceTags, RESOURCE** ppResourceTags ) const;

    // Helper function to make sure a resource is registered
    D3DResource* RegisterResource( D3DResource* pResource ) const
    {
        return pResource;
    }

    // Functions to retrieve resources by their offset
    VOID* GetData( DWORD dwOffset ) const
    {
        return &m_pSysMemData[dwOffset];
    }

    D3DResource* GetResource( DWORD dwOffset ) const
    {
        return RegisterResource( ( D3DResource* )GetData( dwOffset ) );
    }

    D3DTexture* GetTexture( DWORD dwOffset ) const
    {
        return ( D3DTexture* )GetResource( dwOffset );
    }

    D3DArrayTexture* GetArrayTexture( DWORD dwOffset ) const
    {
        return ( D3DArrayTexture* )GetResource( dwOffset );
    }

    D3DCubeTexture* GetCubemap( DWORD dwOffset ) const
    {
        return ( D3DCubeTexture* )GetResource( dwOffset );
    }

    D3DVolumeTexture* GetVolumeTexture( DWORD dwOffset ) const
    {
        return ( D3DVolumeTexture* )GetResource( dwOffset );
    }

    D3DVertexBuffer* GetVertexBuffer( DWORD dwOffset ) const
    {
        return ( D3DVertexBuffer* )GetResource( dwOffset );
    }

    // Functions to retrieve resources by their name
    VOID* GetData( const CHAR* strName ) const;

    D3DResource* GetResource( const CHAR* strName ) const
    {
        return RegisterResource( ( D3DResource* )GetData( strName ) );
    }

    D3DTexture* GetTexture( const CHAR* strName ) const
    {
        return ( D3DTexture* )GetResource( strName );
    }

    D3DArrayTexture* GetArrayTexture( const CHAR* strName ) const
    {
        return ( D3DArrayTexture* )GetResource( strName );
    }

    D3DCubeTexture* GetCubemap( const CHAR* strName ) const
    {
        return ( D3DCubeTexture* )GetResource( strName );
    }

    D3DVolumeTexture* GetVolumeTexture( const CHAR* strName ) const
    {
        return ( D3DVolumeTexture* )GetResource( strName );
    }

    D3DVertexBuffer* GetVertexBuffer( const CHAR* strName ) const
    {
        return ( D3DVertexBuffer* )GetResource( strName );
    }

            PackedResource();
            ~PackedResource();
};

} // namespace ATG

#endif // ATGRESOURCE_H

```

`XenonDumper/libs/Atg/AtgResourceDatabase.cpp`:

```cpp
//-----------------------------------------------------------------------------
// meshdata.cpp
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "AtgDevice.h"
#include "AtgResourceDatabase.h"
#include "AtgResource.h"
#include "AtgUtil.h"

namespace ATG
{

extern D3DDevice* g_pd3dDevice;

// Define TypeIDs
CONST StringID Resource::TypeID( L"Resource" );
CONST StringID VertexData::TypeID( L"VertexData" );
CONST StringID IndexData::TypeID( L"IndexData" );
CONST StringID SubsetDesc::TypeID( L"SubsetDesc" );
CONST StringID Texture::TypeID( L"Texture" );
CONST StringID Texture2D::TypeID( L"Texture2D" );
CONST StringID TextureCube::TypeID( L"TextureCube" );
CONST StringID TextureVolume::TypeID( L"TextureVolume" );

ResourceDatabase::ResourceDatabase()
        : m_pDefaultTexture2D( NULL ),
          m_pDefaultTextureCube( NULL ),
          m_pBlackTexture2D( NULL ),
          m_pBlueTexture2D( NULL ),
          m_pWhiteTexture2D( NULL )
{
#ifdef PROFILE
    // Enable the PIX Texture Tracker feature
    PIXEnableTextureTracking(
        0,   // default to hardware thread 5
        0,   // default to 4MB of capture buffer
        NULL // default to no callback
            );
#endif
}

//-----------------------------------------------------------------------------
// Name: VertexData::VertexData()
//-----------------------------------------------------------------------------
VertexData::VertexData()
{
    m_pVertexDecl = NULL;
    m_NumVertices = 0;
    ZeroMemory( m_dwStreamStrides, sizeof( m_dwStreamStrides ) );
}


//-----------------------------------------------------------------------------
// Name: VertexData::~VertexData()
//-----------------------------------------------------------------------------
VertexData::~VertexData()
{
    // release vertex data members
    if( m_pVertexDecl )    
        m_pVertexDecl->Release();
    for( DWORD i = 0; i < m_VertexStreams.size(); i++ )
    {
        if( m_VertexStreams[i].pVertexBuffer )
            m_VertexStreams[i].pVertexBuffer->Release();
    }
}


//-----------------------------------------------------------------------------
// Name: VertexData::AddVertexStream()
//-----------------------------------------------------------------------------
VOID VertexData::AddVertexStream( LPDIRECT3DVERTEXBUFFER9 pBuffer, DWORD Stride, DWORD NumVerts, DWORD Divider )
{
    // vertex buffers are assumed to have the correct bound
    assert( pBuffer );

    DWORD dwStreamIndex = (DWORD)m_VertexStreams.size();
    assert( dwStreamIndex < MaxStreamCount );
    m_dwStreamStrides[dwStreamIndex] = Stride;

    VertexStream Stream;
    Stream.pVertexBuffer = pBuffer;
    Stream.Divider = Divider;
    Stream.Stride = Stride;
    m_VertexStreams.push_back( Stream );
    m_NumVertices += NumVerts;

    pBuffer->AddRef();
}


//-----------------------------------------------------------------------------
// Name: VertexData::SetVertexDecl()
//-----------------------------------------------------------------------------
VOID VertexData::SetVertexDecl( LPDIRECT3DVERTEXDECLARATION9 pVertexDecl )
{
    if( m_pVertexDecl )
    {
        m_pVertexDecl->Release();
    }

    m_pVertexDecl = pVertexDecl;
   
    if( m_pVertexDecl )
    {
        m_pVertexDecl->AddRef();    
    }
}


VOID VertexData::AppendVertexDecl( LPDIRECT3DVERTEXDECLARATION9 pVertexDecl, DWORD dwStreamIndex )
{
    if( m_pVertexDecl == NULL )
    {
        SetVertexDecl( pVertexDecl );
        return;
    }

    DWORD dwExistingCount = MAXD3DDECLLENGTH + 1;
    D3DVERTEXELEMENT9 ExistingElements[MAXD3DDECLLENGTH + 1];
    m_pVertexDecl->GetDeclaration( ExistingElements, (UINT*)&dwExistingCount );

    DWORD dwNewCount = MAXD3DDECLLENGTH + 1;
    D3DVERTEXELEMENT9 NewElements[MAXD3DDECLLENGTH + 1];
    pVertexDecl->GetDeclaration( NewElements, (UINT*)&dwNewCount );

    AppendVertexElements( ExistingElements, dwStreamIndex, NewElements, 0, 0 );

    D3DVertexDeclaration* pNewDecl = D3DDevice_CreateVertexDeclaration( ExistingElements );
    SetVertexDecl( pNewDecl );
}


//-----------------------------------------------------------------------------
// Name: IndexData::IndexData()
//-----------------------------------------------------------------------------
IndexData::IndexData()
{
    m_pIndexBuffer = NULL;
}


//-----------------------------------------------------------------------------
// Name: IndexData::~IndexData()
//-----------------------------------------------------------------------------
IndexData::~IndexData()
{
    if( m_pIndexBuffer )
        m_pIndexBuffer->Release(); // release index buffer    
}


//-----------------------------------------------------------------------------
// Name: IndexData::~IndexData()
//-----------------------------------------------------------------------------
VOID IndexData::SetIndexBuffer( D3DIndexBuffer* pIndexBuffer )
{
    if( m_pIndexBuffer )
        m_pIndexBuffer->Release();
    
    m_pIndexBuffer = pIndexBuffer;    

    if( m_pIndexBuffer )
        m_pIndexBuffer->AddRef();
}


ResourceDatabase::~ResourceDatabase()
{
    m_pDefaultTexture2D = NULL;
    m_pDefaultTextureCube = NULL;

    {
        std::list<VOID*>::iterator iter = m_PhysicalAllocations.begin();
        std::list<VOID*>::iterator end = m_PhysicalAllocations.end();
        while( iter != end )
        {
            XPhysicalFree( *iter );
            ++iter;
        }
        m_PhysicalAllocations.clear();

        iter = m_VirtualAllocations.begin();
        end = m_VirtualAllocations.end();
        while( iter != end )
        {
            delete[] *iter;
            ++iter;
        }
        m_VirtualAllocations.clear();
    }

    {
        std::list<PackedResource*>::iterator iter = m_BundledResources.begin();
        std::list<PackedResource*>::iterator end = m_BundledResources.end();
        while( iter != end )
        {
            delete *iter;
            ++iter;
        }
        m_BundledResources.clear();
    }

    {
        NameIndexedCollection::iterator iter = m_Resources.begin();
        NameIndexedCollection::iterator end = m_Resources.end();
        while( iter != end )
        {
            Resource* pResource = (Resource*)*iter;
            if( pResource->bFromPackedResource == FALSE )
            {
                delete pResource;
            }
            iter++;
        }
    }
}


//-----------------------------------------------------------------------------
// Name: ResourceDatabase::AddTexture2D
//-----------------------------------------------------------------------------
Texture2D* ResourceDatabase::AddTexture2D(  CONST CHAR* strFilename, 
                                            DWORD Width, DWORD Height,
                                            D3DFORMAT Format, DWORD Filter,
                                            DWORD MipLevels, DWORD MipFilter )
{
    WCHAR wszConvertedFilename[ _MAX_PATH ];
    Texture2D *pTexture = NULL;
    Resource *pResource = NULL;

    const CHAR* strFileOnly = strrchr( strFilename, '\\' );
    if( strFileOnly == NULL )
    {
        strFileOnly = strFilename;
    }
    else
    {
        strFileOnly++;
    }
    
    MultiByteToWideChar( CP_ACP, 0, strFileOnly, strlen( strFileOnly ) + 1, wszConvertedFilename, MAX_PATH );
    _wcslwr_s( wszConvertedFilename );

    pResource = FindResource( wszConvertedFilename );
    if ( pResource )
    {
        // $ERROR: report error of duplicate name
        assert( pResource->IsDerivedFrom( Texture2D::TypeID ) );
        return (Texture2D*)pResource;            
    }

    LPDIRECT3DTEXTURE9 pD3DTexture;

    Format = D3DFMT_DXT5;
    MipLevels = 0;

    HRESULT hr = D3DXCreateTextureFromFileEx( g_pd3dDevice, 
                                              strFilename, 
                                              Width, Height, MipLevels,
                                              0,
                                              Format,
                                              D3DPOOL_MANAGED,//D3DPOOL_DEFAULT,
                                              Filter, MipFilter, 0, NULL, NULL, 
                                              &pD3DTexture );
    if ( FAILED( hr ) )
    {
        ATG::DebugSpew( "Could not load 2D texture %s.\n", strFilename );
        return NULL;
    }
    
    pTexture = new Texture2D;
    pTexture->SetName( wszConvertedFilename );
    pTexture->SetD3DTexture( pD3DTexture );
    pD3DTexture->Release();

    AddResource( pTexture );
    return pTexture;
}


//-----------------------------------------------------------------------------
// Name: ResourceDatabase::AddTextureCube
//-----------------------------------------------------------------------------
TextureCube* ResourceDatabase::AddTextureCube(  CONST CHAR* strFilename, 
                                                DWORD Size, D3DFORMAT Format, DWORD Filter,
                                                DWORD MipLevels, DWORD MipFilter )
{
    WCHAR wszConvertedFilename[ _MAX_PATH ];
    TextureCube *pTexture = NULL;
    Resource *pResource = NULL;
    
    const CHAR* strFileOnly = strrchr( strFilename, '\\' );
    if( strFileOnly == NULL )
    {
        strFileOnly = strFilename;
    }
    else
    {
        strFileOnly++;
    }

    MultiByteToWideChar( CP_ACP, 0, strFileOnly, strlen( strFileOnly ) + 1, wszConvertedFilename, MAX_PATH );
    _wcslwr_s( wszConvertedFilename );

    pResource = FindResource( wszConvertedFilename );
    if ( pResource )
    {
        // $ERROR: report error of duplicate name
        assert( pResource->IsDerivedFrom( TextureCube::TypeID ) );
        return (TextureCube*)pResource;            
    }

    LPDIRECT3DCUBETEXTURE9 pD3DTexture;

    HRESULT hr = D3DXCreateCubeTextureFromFileEx( g_pd3dDevice, 
                                              strFilename, 
                                              Size, MipLevels,
                                              0,
                                              Format,
                                              D3DPOOL_MANAGED,//D3DPOOL_DEFAULT,
                                              Filter, MipFilter, 0, NULL, NULL, 
                                              &pD3DTexture );
    if ( FAILED( hr ) )
    {
        ATG::DebugSpew( "Could not load cubemap texture %s.\n", strFilename );
        return NULL;
    }
    
    pTexture = new TextureCube;
    pTexture->SetName( wszConvertedFilename );
    pTexture->SetD3DTexture( pD3DTexture );
    pD3DTexture->Release();
    
    AddResource( pTexture );
    return pTexture;
}


//-----------------------------------------------------------------------------
// Name: ResourceDatabase::AddTextureVolume
//-----------------------------------------------------------------------------
TextureVolume* ResourceDatabase::AddTextureVolume( CONST CHAR* strFilename, 
                                    DWORD Width, DWORD Height, DWORD Depth,
                                    D3DFORMAT Format, DWORD Filter, 
                                    DWORD MipLevels, DWORD MipFilter )
{
    WCHAR wszConvertedFilename[ _MAX_PATH ];
    TextureVolume *pTexture = NULL;
    Resource *pResource = NULL;
    
    const CHAR* strFileOnly = strrchr( strFilename, '\\' );
    if( strFileOnly == NULL )
    {
        strFileOnly = strFilename;
    }
    else
    {
        strFileOnly++;
    }

    MultiByteToWideChar( CP_ACP, 0, strFileOnly, strlen( strFileOnly ) + 1, wszConvertedFilename, MAX_PATH );
    _wcslwr_s( wszConvertedFilename );

    pResource = FindResource( wszConvertedFilename );
    if ( pResource )
    {
        // $ERROR: report error of duplicate name
        assert( pResource->IsDerivedFrom( TextureVolume::TypeID ) );
        return (TextureVolume*)pResource;            
    }

    LPDIRECT3DVOLUMETEXTURE9 pD3DTexture;

    HRESULT hr = D3DXCreateVolumeTextureFromFileEx( g_pd3dDevice, 
                                              strFilename, 
                                              Width, Height, Depth, MipLevels,
                                              0,
                                              Format,
                                              D3DPOOL_MANAGED,//D3DPOOL_DEFAULT,
                                              Filter, MipFilter, 0, NULL, NULL, 
                                              &pD3DTexture );
    if ( FAILED( hr ) )
    {
        ATG::DebugSpew( "Could not load volume texture %s.\n", strFilename );
        return NULL;
    }
    
    pTexture = new TextureVolume;
    pTexture->SetName( wszConvertedFilename );
    pTexture->SetD3DTexture( pD3DTexture );
    pD3DTexture->Release();

    AddResource( pTexture );
    return pTexture;
}


Texture2D* CreateColorTexture( D3DCOLOR Color )
{
    D3DTexture* pTexture = NULL;
    g_pd3dDevice->CreateTexture( 1, 1, 0, 0, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, &pTexture, NULL );
        
#ifdef PROFILE
    // Report texture to texture tracker
    PIXReportNewTexture( pTexture );
    PIXSetTextureName( pTexture, "::CreateColorTexture" );
#endif

    assert( pTexture != NULL );
    D3DLOCKED_RECT LockRect;
    pTexture->LockRect( 0, &LockRect, NULL, 0 );
    *(DWORD*)LockRect.pBits = Color;
    pTexture->UnlockRect( 0 );

    Texture2D* pTexture2D = new Texture2D();
    pTexture2D->SetD3DTexture( pTexture );
    return pTexture2D;
}


VOID ResourceDatabase::CreateDefaultResources()
{
    if( m_pBlackTexture2D == NULL )
        CreateBlackTexture();
    if( m_pBlueTexture2D == NULL )
        CreateBlueTexture();
    if( m_pWhiteTexture2D == NULL )
        CreateWhiteTexture();

    Texture2D* pDefaultNormalMap = new Texture2D();
    pDefaultNormalMap->SetName( L"default-normalmap.dds" );
    pDefaultNormalMap->SetD3DTexture( m_pBlueTexture2D->GetD3DTexture() );
    AddResource( pDefaultNormalMap );

    Texture2D* pDefaultDiffuse = CreateColorTexture( 0xFF808080 );
    pDefaultDiffuse->SetName( L"default.dds" );
    AddResource( pDefaultDiffuse );

    Texture2D* pDefaultSpecMap = new Texture2D();
    pDefaultSpecMap->SetName( L"default-specularmap.dds" );
    pDefaultSpecMap->SetD3DTexture( m_pWhiteTexture2D->GetD3DTexture() );
    AddResource( pDefaultSpecMap );
}


Texture2D* ResourceDatabase::CreateBlackTexture()
{
    Texture2D* pTexture2D = CreateColorTexture( 0 );
    pTexture2D->SetName( L"black" );

    AddResource( pTexture2D );
    m_pBlackTexture2D = pTexture2D;
    return m_pBlackTexture2D;
}


Texture2D* ResourceDatabase::CreateBlueTexture()
{
    Texture2D* pTexture2D = CreateColorTexture( 0xFF8080FF );
    pTexture2D->SetName( L"blue" );

    AddResource( pTexture2D );
    m_pBlueTexture2D = pTexture2D;
    return m_pBlueTexture2D;
}


Texture2D* ResourceDatabase::CreateWhiteTexture()
{
    Texture2D* pTexture2D = CreateColorTexture( 0xFFFFFFFF );
    pTexture2D->SetName( L"white" );

    AddResource( pTexture2D );
    m_pWhiteTexture2D = pTexture2D;
    return m_pWhiteTexture2D;
}


VOID ResourceDatabase::AddBundledResources( PackedResource* pBundledResourceTable )
{
    assert( pBundledResourceTable != NULL );
    m_BundledResources.push_back( pBundledResourceTable );

    RESOURCE* pTags = NULL;
    DWORD dwResourceCount = 0;
    WCHAR strNameTemp[256];
    pBundledResourceTable->GetResourceTags( &dwResourceCount, &pTags );
    DWORD i = 0;
    while( i < dwResourceCount )
    {
        MultiByteToWideChar( CP_ACP, 0, pTags[i].strName, strlen( pTags[i].strName ) + 1, strNameTemp, 256 );
        _wcslwr_s( strNameTemp );
        switch( pTags[i].dwType )
        {
        case RESOURCETYPE_TEXTURE:
            {
                Texture2D* pTexture = new Texture2D();
                pTexture->SetName( strNameTemp );
                pTexture->bFromPackedResource = TRUE;
                DWORD dwOffset = pTags[ i ].dwOffset;
                D3DTexture* pD3DTexture = pBundledResourceTable->GetTexture( dwOffset );
                pTexture->SetD3DTexture( pD3DTexture );
                AddResource( pTexture );
#ifdef PROFILE
                // Report texture to texture tracker
                PIXReportNewTexture( pD3DTexture );
                CHAR strConverted[256];
                strConverted[0] = 0;
                wcstombs_s( 0, strConverted, strNameTemp, _countof(strConverted) );  
                PIXSetTextureName( pD3DTexture, TEXT(strConverted) );
#endif
                break;
            }
        case RESOURCETYPE_CUBEMAP:
            {
                TextureCube* pTexture = new TextureCube();
                pTexture->SetName( strNameTemp );
                pTexture->bFromPackedResource = TRUE;
                DWORD dwOffset = pTags[ i ].dwOffset;
                D3DCubeTexture* pD3DTexture = pBundledResourceTable->GetCubemap( dwOffset );
                pTexture->SetD3DTexture( pD3DTexture );
                AddResource( pTexture );
#ifdef PROFILE
                // Report texture to texture tracker
                PIXReportNewTexture( pD3DTexture );
                CHAR strConverted[256];
                strConverted[0] = 0;
                wcstombs_s( 0, strConverted, strNameTemp, _countof(strConverted) );  
                PIXSetTextureName( pD3DTexture, TEXT(strConverted) );
#endif
               break;
            }
        case RESOURCETYPE_VOLUMETEXTURE:
            {
                TextureVolume* pTexture = new TextureVolume();
                pTexture->SetName( strNameTemp );
                pTexture->bFromPackedResource = TRUE;
                DWORD dwOffset = pTags[ i ].dwOffset;
                D3DVolumeTexture* pD3DTexture = pBundledResourceTable->GetVolumeTexture( dwOffset );
                pTexture->SetD3DTexture( pD3DTexture );
                AddResource( pTexture );
#ifdef PROFILE
                // Report texture to texture tracker
                PIXReportNewTexture( pD3DTexture );
                CHAR strConverted[256];
                strConverted[0] = 0;
                wcstombs_s( 0, strConverted, strNameTemp, _countof(strConverted) );  
                PIXSetTextureName( pD3DTexture, TEXT(strConverted) );
#endif
              break;
            }
        case RESOURCETYPE_VERTEXBUFFER:
        case RESOURCETYPE_INDEXBUFFER:
        case RESOURCETYPE_USERDATA:
        default:
            {
                // not supported yet
                DebugSpew( "Unsupported resource type %d for resource \"%s\".\n", pTags[i].dwType, pTags[i].strName );
                break;
            }
        }
        ++i;
    }
}

VOID* ResourceDatabase::PhysicalAlloc( DWORD dwSize, DWORD dwAlignment, DWORD dwFlags )
{
    VOID* pBuf = XPhysicalAlloc( dwSize, MAXULONG_PTR, dwAlignment, dwFlags );
    m_PhysicalAllocations.push_back( pBuf );
    return pBuf;
}

VOID* ResourceDatabase::VirtualAlloc( DWORD dwSize, DWORD dwFlags )
{
    VOID* pBuf = new BYTE[ dwSize ];
    m_VirtualAllocations.push_back( pBuf );
    return pBuf;
}

Texture2D* ResourceDatabase::SetDefaultTexture2D( const WCHAR* strResourceName )
{
    m_pDefaultTexture2D = (Texture2D*)FindResource( strResourceName );
    return m_pDefaultTexture2D;
}

TextureCube* ResourceDatabase::SetDefaultTextureCube( const WCHAR* strResourceName )
{
    m_pDefaultTextureCube = (TextureCube*)FindResource( strResourceName );
    return m_pDefaultTextureCube;
}

}

```

`XenonDumper/libs/Atg/AtgResourceDatabase.h`:

```h
//-----------------------------------------------------------------------------
// Resource.h
//
// Describes the database that manages native static resources
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef ATG_RESOURCEDATABASE_H
#define ATG_RESOURCEDATABASE_H

#include <vector>
#include <fxl.h>
#include "AtgNamedTypedObject.h"

namespace ATG
{

//-----------------------------------------------------------------------------
// Name: Resource
// Desc: Base class for static resources
//-----------------------------------------------------------------------------    
class Resource : public NamedTypedObject
{
    DEFINE_TYPE_INFO();
public:
    Resource()
        : bFromPackedResource( FALSE )
    {
    }
    BOOL        bFromPackedResource;
};


//-----------------------------------------------------------------------------
// A vertex stream consists of a single vertex buffer and its divider
//-----------------------------------------------------------------------------
struct VertexStream
{
    DWORD                      Divider;
    DWORD                      Stride;
    LPDIRECT3DVERTEXBUFFER9    pVertexBuffer;
};


//-----------------------------------------------------------------------------
// Name: VertexData
// Desc: VertexData has multiple streams.  The number of vertices in each
//        stream times its divider must equal the number of vertices specified 
//        in the VertexData structure
//-----------------------------------------------------------------------------
class VertexData : public Resource
{
    DEFINE_TYPE_INFO();
public:    
    VertexData();
    ~VertexData();

    static const DWORD MaxStreamCount = 4;

    // adds streams
    VOID                    AddVertexStream( LPDIRECT3DVERTEXBUFFER9 pBuffer, DWORD Stride, DWORD VertexCount, DWORD Divider = 1 );
    
    // accessors
    LPDIRECT3DVERTEXDECLARATION9    GetVertexDecl() CONST { return m_pVertexDecl; }
    VOID                            SetVertexDecl( LPDIRECT3DVERTEXDECLARATION9 pVertexDecl );
    VOID                            AppendVertexDecl( LPDIRECT3DVERTEXDECLARATION9 pVertexDecl, DWORD dwStreamIndex );

    DWORD                           GetNumVertexStreams() CONST { return m_VertexStreams.size(); }        
    CONST VertexStream*             GetVertexStream( DWORD Index ) CONST { return &m_VertexStreams[ Index ]; }    
    DWORD                           GetNumVertices() CONST { return m_NumVertices; }
    const DWORD*                    GetStreamStrides() CONST { return &m_dwStreamStrides[0]; };
    
private:
    DWORD                           m_NumVertices;
    // one decl to describe all of the streams in this structre
    LPDIRECT3DVERTEXDECLARATION9    m_pVertexDecl;
    std::vector< VertexStream > m_VertexStreams;
    DWORD                           m_dwStreamStrides[MaxStreamCount];
};


//-----------------------------------------------------------------------------
// Name: IndexData
//-----------------------------------------------------------------------------
class IndexData : public Resource
{
    DEFINE_TYPE_INFO();
public:    
    IndexData();
    ~IndexData();

    VOID                    SetIndexBuffer( LPDIRECT3DINDEXBUFFER9 pIndexBuffer );
    LPDIRECT3DINDEXBUFFER9  GetIndexBuffer() CONST { return m_pIndexBuffer; }
    
    DWORD                   GetNumIndices() CONST { return m_NumIndices; }
    VOID                    SetNumIndices( DWORD NumIndices ) { m_NumIndices = NumIndices; }
private:
    DWORD                   m_NumIndices;
    LPDIRECT3DINDEXBUFFER9  m_pIndexBuffer;
};


//-----------------------------------------------------------------------------
// Name: SubsetDesc
// Desc: describes the subets in a mesh, if it has any
//-----------------------------------------------------------------------------
class SubsetDesc : public Resource
{
    DEFINE_TYPE_INFO();
public:
    D3DPRIMITIVETYPE         GetPrimitiveType() CONST { return m_PrimitiveType; }
    VOID                     SetPrimitiveType( D3DPRIMITIVETYPE pt ) { m_PrimitiveType = pt; }

    DWORD                    GetStartIndex() CONST { return m_StartIndex; }
    VOID                     SetStartIndex( DWORD si ) { m_StartIndex = si; }
    
    DWORD                    GetNumPrimitives()  CONST { return m_NumPrimitives; }
    VOID                     SetNumPrimitives( DWORD np ) { m_NumPrimitives = np; }

private:
    D3DPRIMITIVETYPE         m_PrimitiveType;
    DWORD                    m_StartIndex;
    DWORD                    m_NumPrimitives;
};


//-----------------------------------------------------------------------------
// Name: Texture
// Desc: encapsulates a texture
//-----------------------------------------------------------------------------
class Texture : public Resource
{
    DEFINE_TYPE_INFO();   
public:
    Texture() { m_pD3DTexture = NULL; }
    ~Texture() { if( m_pD3DTexture != NULL ) m_pD3DTexture->Release(); }

    virtual LPDIRECT3DBASETEXTURE9  GetD3DTexture() { return m_pD3DTexture; };
    virtual VOID                    SetD3DTexture( LPDIRECT3DBASETEXTURE9 pTex ) 
    {
        if( m_pD3DTexture != NULL )
            m_pD3DTexture->Release();
        m_pD3DTexture = pTex; 
        m_pD3DTexture->AddRef(); 
    }

protected:
    LPDIRECT3DBASETEXTURE9 m_pD3DTexture;
};


//-----------------------------------------------------------------------------
// Name: Texture2D
// Desc: encapsulates a 2D texture
//-----------------------------------------------------------------------------
class Texture2D : public Texture
{
    DEFINE_TYPE_INFO();
};


//-----------------------------------------------------------------------------
// Name: TextureVolume
// Desc: encapsulates a volume texture
//-----------------------------------------------------------------------------
class TextureVolume : public Texture
{
    DEFINE_TYPE_INFO();
};


//-----------------------------------------------------------------------------
// Name: TextureCube
// Desc: encapsulates a cube texture
//-----------------------------------------------------------------------------
class TextureCube : public Texture
{
    DEFINE_TYPE_INFO();    
};

class PackedResource;
//-----------------------------------------------------------------------------
// Name: ResourceDatabase
// Desc: Contains non-instance resources
//-----------------------------------------------------------------------------    
class ResourceDatabase
{
public:
    ResourceDatabase();
    ~ResourceDatabase();

    // Add generic resources (bundled file loaders will use these)
    VOID            AddResource( Resource *pResource ) { m_Resources.Add( pResource ); }
    Resource*       FindResource( CONST WCHAR* szName ) { return (Resource*) m_Resources.Find( szName ); }
    Resource*       FindResourceOfType( CONST WCHAR* szName, const StringID TypeID ) { return (Resource*) m_Resources.FindTyped( szName, TypeID ); }
    VOID            AddBundledResources( PackedResource* pBundledResourceTable );

    VOID*           PhysicalAlloc( DWORD dwSize, DWORD dwAlignment, DWORD dwFlags );
    VOID*           VirtualAlloc( DWORD dwSize, DWORD dwFlags );

    // Add Texture resources from a file
    Texture2D*      AddTexture2D( CONST CHAR* strFilename, 
                                    DWORD Width = 0, DWORD Height = 0,
                                    D3DFORMAT Format = D3DFMT_UNKNOWN, DWORD Filter = D3DX_DEFAULT,
                                    DWORD MipLevels = 0, DWORD MipFilter = D3DX_DEFAULT );

    TextureCube*    AddTextureCube( CONST CHAR* strFilename, 
                                    DWORD Size = 0,
                                    D3DFORMAT Format = D3DFMT_UNKNOWN, DWORD Filter = D3DX_DEFAULT,
                                    DWORD MipLevels = 0, DWORD MipFilter = D3DX_DEFAULT );

    TextureVolume*  AddTextureVolume( CONST CHAR* strFilename, 
                                    DWORD Width = 0, DWORD Height = 0, DWORD Depth = 0, 
                                    D3DFORMAT Format = D3DFMT_UNKNOWN, DWORD Filter = D3DX_DEFAULT,
                                    DWORD MipLevels = 0, DWORD MipFilter = D3DX_DEFAULT );    
    
    // Default resources
    VOID            CreateDefaultResources();

    Texture2D*      SetDefaultTexture2D( const WCHAR* strResourceName );
    TextureCube*    SetDefaultTextureCube( const WCHAR* strResourceName );

    Texture2D*      GetDefaultTexture2D() const { return m_pDefaultTexture2D; }
    TextureCube*    GetDefaultTextureCube() const { return m_pDefaultTextureCube; }

    Texture2D*      GetBlackTexture() const { return m_pBlackTexture2D; }
    Texture2D*      CreateBlackTexture();

    Texture2D*      GetBlueTexture() const { return m_pBlueTexture2D; }
    Texture2D*      CreateBlueTexture();

    Texture2D*      GetWhiteTexture() const { return m_pWhiteTexture2D; }
    Texture2D*      CreateWhiteTexture();

private:
    NameIndexedCollection           m_Resources;
    Texture2D*                      m_pDefaultTexture2D;
    Texture2D*                      m_pBlackTexture2D;
    Texture2D*                      m_pBlueTexture2D;
    Texture2D*                      m_pWhiteTexture2D;
    TextureCube*                    m_pDefaultTextureCube;
    std::list< PackedResource* >    m_BundledResources;
    std::list< VOID* >              m_PhysicalAllocations;
    std::list< VOID* >              m_VirtualAllocations;
};

} // namespace ATG

#endif // ATG_RESOURCE_H

```

`XenonDumper/libs/Atg/AtgRest.cpp`:

```cpp

//--------------------------------------------------------------------------------------
// RESTFUL Objects for Xbox LIVE endpoint wrapper layer
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------


#include "stdafx.h"

#include "AtgREST.h"


namespace ATG
{
namespace REST
{

//--------------------------------------------------------------------------------------
// INCLUDES
//--------------------------------------------------------------------------------------
#include "AtgREST.h"


//--------------------------------------------------------------------------------------
// GLOBALS
//--------------------------------------------------------------------------------------
CHAR BASEURL[] = "https://services.part.xboxlive.com";   // PartnerNet
//CHAR BASEURL[] = "https://services.cert.xboxlive.com"; // CertNet
//CHAR BASEURL[] = "https://services.xboxlive.com";      //Production


//--------------------------------------------------------------------------------------
// AtgREST::Initialize
//
//--------------------------------------------------------------------------------------
HRESULT AtgREST::Initialize(CHAR *titleId, CHAR *groupId, DWORD dwUserIndex) 
{
    HRESULT hr = m_Auth.Startup(NULL, FALSE, &m_hWorkerThread, TRUE, dwUserIndex);
    if (hr != S_OK)
    {
        ATG::FatalError("Failed to Initialize: %x\n", hr);
    }

    if (titleId != NULL)
    {
        strcpy_s(m_titleId, titleId); 
    }

    if (groupId != NULL)
    {
        strcpy_s(m_groupId, groupId);
    }

    return hr;
}

//--------------------------------------------------------------------------------------
// AtgREST::Shutdown
//
//--------------------------------------------------------------------------------------
HRESULT AtgREST::Shutdown()
{
    m_Auth.Shutdown(); 
    return S_OK;
}


//--------------------------------------------------------------------------------------
// JSON PropertyTag descriptions for the RESTFUL-Objects
// tags are used to describe the JSON objects to deserialize
//--------------------------------------------------------------------------------------

PropertyTag NoObject::tags[] = {
    L"",                    DT_NONE,   0, NO_STRSIZE,
};
DWORD NoObject::tagsize = 0;


PropertyTag UsersMe::tags[] = {
    L"xuid",                DT_INT64,   offsetof(UsersMe, xuid),     NO_STRSIZE,
    L"gamerTag",            DT_STRING,  offsetof(UsersMe, gamerTag), GAMERTAG_STRSIZE,
};
DWORD UsersMe::tagsize = ARRAY_SIZE(UsersMe::tags);


PropertyTag Players::tags[] = {
    L"xuid",                DT_INT64,   offsetof(Players, xuid),                   NO_STRSIZE,
    L"gamertag",            DT_STRING,  offsetof(Players, gamertag),               GAMERTAG_STRSIZE,
    L"seatIndex",           DT_INT,     offsetof(Players, seatIndex),              NO_STRSIZE,
    L"customData",          DT_STRING,  offsetof(Players, customData),             CUSTOMDATA_STRSIZE,           
    L"isCurrentlyInSession",DT_INT,     offsetof(Players, isCurrentlyInSession),   NO_STRSIZE,
};
DWORD Players::tagsize = ARRAY_SIZE(Players::tags);


PropertyTag Sessions::tags[] = {
    L"sessionId",           DT_STRING,  offsetof(Sessions, sessionId),       DEFAULT_STRSIZE,
    L"titleId",             DT_INT,     offsetof(Sessions, titleId),         NO_STRSIZE,
    L"variant",             DT_INT,     offsetof(Sessions, variant),         NO_STRSIZE,
    L"displayName",         DT_STRING,  offsetof(Sessions, displayName),     DEFAULT_STRSIZE,
    L"customData",          DT_STRING,  offsetof(Sessions, customData),      CUSTOMDATA_STRSIZE,
    L"maxPlayers",          DT_INT,     offsetof(Sessions, maxPlayers),      NO_STRSIZE,
    L"seatsAvailable",      DT_INT,     offsetof(Sessions, seatsAvailable),  NO_STRSIZE,
    L"isClosed",            DT_INT,     offsetof(Sessions, isClosed),        NO_STRSIZE,
    L"hasEnded",            DT_INT,     offsetof(Sessions, hasEnded),        NO_STRSIZE,
    L"roster",              DT_ARRAY,   offsetof(Sessions, roster),          NO_STRSIZE, // collection of player objects
};
DWORD Sessions::tagsize = ARRAY_SIZE(Sessions::tags);


PropertyTag Request::tags[] = {
    L"RequestId",           DT_STRING,  offsetof(Request, RequestId),  DEFAULT_STRSIZE,
};
DWORD Request::tagsize = ARRAY_SIZE(Request::tags);


PropertyTag RequestStatus::tags[] = {
    L"SessionId",           DT_STRING,  offsetof(RequestStatus, SessionId), DEFAULT_STRSIZE,
    L"Status",              DT_STRING,  offsetof(RequestStatus, Status),    DEFAULT_STRSIZE,
};
DWORD RequestStatus::tagsize = ARRAY_SIZE(RequestStatus::tags);


PropertyTag GameMessages::tags[] = {
    L"queueIndex",          DT_INT,     offsetof(GameMessages, queueIndex),     NO_STRSIZE,
    L"sequenceNumber",      DT_INT,     offsetof(GameMessages, sequenceNumber), NO_STRSIZE,
    L"senderXuid",          DT_INT64,   offsetof(GameMessages, senderXuid),     NO_STRSIZE,
    L"data",                DT_STRING,  offsetof(GameMessages, data),           BIG_STRSIZE,
};
DWORD GameMessages::tagsize = ARRAY_SIZE(GameMessages::tags);


PropertyTag MessageArray::tags[] = {
    L"messages",            DT_ARRAY,   offsetof(MessageArray, messages), NO_STRSIZE, // collection of player objects
};
DWORD MessageArray::tagsize = ARRAY_SIZE(MessageArray::tags);


//--------------------------------------------------------------------------------------
// AtgREST::MakeWebRequest
//
// shared function used in each wrapper based on the custom JSON type we are working
// with
//--------------------------------------------------------------------------------------
template<typename Type> Type* AtgREST::MakeWebRequest(CHAR *customHeader, CHAR *url, CHAR *verb, CHAR *data, Type *p, HttpResponse &response)
{
    ATG::HTTP::AuthManager::AuthEndpoint *endpoint;
    endpoint = m_Auth.CreateEndpoint(url, TRUE);

    DWORD len = 0;
    if (data != NULL)
    {
        len = strlen(data);
    }

    // open up a request to the endpoint 
    HRESULT hr = endpoint->MakeSyncRequest(verb, customHeader, data, len);
    if (hr != S_OK)
    {
        ATG::FatalError("Failed to OpenRequest: %x\n", hr);
    }

    p = NULL;

    response.returnCode = endpoint->GetHTTPStatusCode();

    if (response.returnCode == HTTP_STATUS_OK) 
    {
        p = new Type();
        AtgJsonReader::Parse(endpoint->GetReadBuffer(), p, p->tags, p->tagsize);
    }
    
    endpoint->CloseRequest();

    m_Auth.RemoveEndpoint(endpoint);

    return p;
}


//--------------------------------------------------------------------------------------
// AtgREST::GetMe
//
//--------------------------------------------------------------------------------------
UsersMe * AtgREST::GetMe(HttpResponse &response)
{
    CHAR URL[] = "/users/me/id";
    CHAR FULLURL[URL_STRSIZE]; 

    sprintf_s(FULLURL, URL_STRSIZE, "%s%s", BASEURL, URL);

    UsersMe *me = NULL;
    me = MakeWebRequest<UsersMe>(NULL, FULLURL, "GET", NULL, me, response);
    return me;
}


//--------------------------------------------------------------------------------------
// AtgREST::CreateAsyncSession
//
// ...
//--------------------------------------------------------------------------------------
Sessions * AtgREST::CreateAsyncSession(INT variant, INT maxPlayers, CHAR *displayName, HttpResponse &response)
{
    CHAR URL[] = "/system/multiplayer/sessions";
    CHAR FULLURL[URL_STRSIZE];
    CHAR buf[MAXTOKENSIZE]; 

    sprintf_s(FULLURL, URL_STRSIZE, "%s%s", BASEURL, URL);

    sprintf_s(buf, MAXTOKENSIZE, "{\"titleId\":%s,\"groupId\":\"%s\",\"variant\":%d,\"displayName\":\"%s\",\"maxPlayers\":%d,\"visibility\":\"Everyone\"}", m_titleId, m_groupId, variant, displayName, maxPlayers);

    Sessions *s = NULL;
    s = MakeWebRequest<Sessions>(NULL, FULLURL, "POST", buf, s, response);
    return s;
}


//--------------------------------------------------------------------------------------
// AtgREST::GetAsyncSession
// ...
//--------------------------------------------------------------------------------------
Sessions * AtgREST::GetAsyncSession(CHAR *sessionid, HttpResponse &response)
{
    CHAR URL[] = "/system/multiplayer/sessions/";
    CHAR FULLURL[URL_STRSIZE];

    sprintf_s(FULLURL, URL_STRSIZE, "%s%s%s", BASEURL, URL, sessionid);

    Sessions *s = NULL;
    s = MakeWebRequest<Sessions>(NULL, FULLURL, "GET", NULL, s, response);
    return s;
}


//--------------------------------------------------------------------------------------
// AtgREST::JoinAsyncSession
//
//--------------------------------------------------------------------------------------
Players * AtgREST::JoinAsyncSession(CHAR *sessionid, CHAR *xuid, CHAR *gamertag, HttpResponse &response)
{
    CHAR URL[] = "/system/multiplayer/sessions/";
    CHAR FULLURL[256];
    CHAR buf[MAXTOKENSIZE]; 

    sprintf_s(FULLURL, URL_STRSIZE, "%s%s%s/players", BASEURL, URL, sessionid);

    sprintf_s(buf, MAXTOKENSIZE, "{\"xuid\":\"%s\",\"gamertag\":\"%s\"}", xuid, gamertag);

    Players *player = NULL;
    player = MakeWebRequest<Players>(NULL, FULLURL, "POST", buf, player, response);
    return player;
}


//--------------------------------------------------------------------------------------
// AtgREST::SendAsyncMPMessage
//
//--------------------------------------------------------------------------------------
VOID AtgREST::SendAsyncMPMessage(CHAR *sessionId, CHAR *xuid, CHAR *data, DWORD queueNum, HttpResponse &response)
{
    CHAR FULLURL[URL_STRSIZE];
    CHAR buf[MAXTOKENSIZE*2]; 

    sprintf_s(FULLURL, URL_STRSIZE, "%s/system/multiplayer/sessions/%s/queues/%d/messages", "https://activeservices.part.xboxlive.com", sessionId, queueNum);

    sprintf_s(buf, (MAXTOKENSIZE*2), "%s%s%s%s%s", "{\"senderXuid\":", xuid, ",\"data\":\"", data, "\"}");

    // NOTE: need to create the return type object for this
    NoObject *empty = NULL;
    empty = MakeWebRequest<NoObject>(NULL, FULLURL, "POST", buf, empty, response);
    delete empty;
    return;
}


//--------------------------------------------------------------------------------------
// AtgREST::GetAsyncMPMessage
//
//--------------------------------------------------------------------------------------
MessageArray * AtgREST::GetAsyncMPMessage(CHAR *sessionId, DWORD startAfterSeqNum, DWORD queueNum, DWORD timeout, HttpResponse &response)
{
    CHAR FULLURL[URL_STRSIZE];

    if (startAfterSeqNum == 0)
    {
        sprintf_s(FULLURL, URL_STRSIZE, "%s/system/multiplayer/sessions/%s/queues/%d/messages", "https://activeservices.part.xboxlive.com", sessionId, queueNum);
    }
    else
    {
        sprintf_s(FULLURL, URL_STRSIZE, "%s/system/multiplayer/sessions/%s/queues/%d/messages?startAfterSeqNum=%d&timeout=%d", "https://activeservices.part.xboxlive.com", sessionId, queueNum, startAfterSeqNum, timeout);
    }

    MessageArray *m = NULL;
    m = MakeWebRequest<MessageArray>(NULL, FULLURL, "GET", NULL, m, response);
    return m;
}


//--------------------------------------------------------------------------------------
// AtgREST::DeleteAsyncMPMessage
//
//--------------------------------------------------------------------------------------
VOID AtgREST::DeleteAsyncMPMessage(HttpResponse &response)
{
// DELETE /system/mutiplayer/sessions/{sessionId}/queues/{queueIndex}/messages
}


//--------------------------------------------------------------------------------------
// AtgREST::UpdateSessionPlayer
//
//--------------------------------------------------------------------------------------
VOID AtgREST::UpdateSessionPlayer(HttpResponse &response)
{
// POST /system/multiplayer/sessions/{sessionid}/players/xuid({xuid})
}

//--------------------------------------------------------------------------------------
// AtgREST::UpdateSession
//
//--------------------------------------------------------------------------------------
VOID AtgREST::UpdateSession(HttpResponse &response)
{
// POST /system/multiplayer/sessions/{sessionid}
}

//--------------------------------------------------------------------------------------
// AtgREST::RemovePlayer
//
//--------------------------------------------------------------------------------------
VOID AtgREST::RemovePlayer(HttpResponse &response)
{
// DELETE /system/multiplayer/sessions/{sessionid}/players/xuid({xuid})

}


//--------------------------------------------------------------------------------------
// AtgREST::GetUserSessions
//
//--------------------------------------------------------------------------------------
VOID AtgREST::GetUserSessions(CHAR *xuid, HttpResponse &response)
{
    CHAR FULLURL[URL_STRSIZE];

    sprintf_s(FULLURL, URL_STRSIZE, "%s/users/xuid(%s)/multiplayer/sessions?titleId=%s", BASEURL, xuid, m_titleId);

    NoObject *empty = NULL;
    empty = MakeWebRequest<NoObject>(NULL, FULLURL, "GET", NULL, empty, response);
    delete empty;
    return;
}


//--------------------------------------------------------------------------------------
// AtgREST::GetMessages
//
//--------------------------------------------------------------------------------------
VOID AtgREST::GetMessages(CHAR *xuid, HttpResponse &response)
{
    CHAR FULLURL[URL_STRSIZE];

    sprintf_s(FULLURL, URL_STRSIZE, "%s/messages/users/xuid(%s)/inbox", BASEURL, xuid);

    NoObject *empty = NULL;
    empty = MakeWebRequest<NoObject>(NULL, FULLURL, "GET", NULL, empty, response);
    delete empty;
    return;
}


//--------------------------------------------------------------------------------------
// AtgREST::SendMessage
//
//--------------------------------------------------------------------------------------
VOID AtgREST::SendMessage(CHAR *sessionId, HttpResponse &response)
{
    CHAR FULLURL[URL_STRSIZE];

    sprintf_s(FULLURL, URL_STRSIZE, "%s/system/messaging/outbox", BASEURL);

    // NOTE: not completed

    return;
}


//--------------------------------------------------------------------------------------
// AtgREST::DeleteMessage
//
//--------------------------------------------------------------------------------------
VOID AtgREST::DeleteMessage(CHAR *xuid, HttpResponse &response)
{
    CHAR FULLURL[URL_STRSIZE];

    sprintf_s(FULLURL, URL_STRSIZE, "%susers/xuid(%s)/inbox/%s", BASEURL, xuid, "messageid");

    NoObject *empty = NULL;
    empty = MakeWebRequest<NoObject>(NULL, FULLURL, "DELETE", NULL, empty, response);
    delete empty;
    return;
}


//--------------------------------------------------------------------------------------
// AtgREST::CreateMatchmakingRequest
//
//--------------------------------------------------------------------------------------
Request * AtgREST::CreateMatchmakingRequest(CHAR *xuid, CHAR *sessionid, DWORD giveupDuration, DWORD seatsOccupied, DWORD minSeats, DWORD maxSeats, CHAR *custom, HttpResponse &response)
{
    CHAR FULLURL[URL_STRSIZE];
    CHAR buf[MAXTOKENSIZE]; 

    sprintf_s(FULLURL, URL_STRSIZE, "%s/users/xuid(%s)/multiplayer/matchrequests", BASEURL, xuid);

    if (sessionid == NULL)
        sprintf_s(buf, MAXTOKENSIZE, "{\"TitleId\":%s,\"GroupId\":\"%s\",\"GiveupDuration\":%d,\"PostbackUrl\":null,\"SeatsOccupied\":%d,\"MinSeats\":%d,\"MaxSeats\":%d,\"MatchCriteria\":{\"Restriction\":\"MatchAny\",\"Custom\":\"%s\"}}", m_titleId, m_groupId, giveupDuration, seatsOccupied, minSeats, maxSeats, custom);
    else
        sprintf_s(buf, MAXTOKENSIZE, "{\"SessionId\":\"%s\",\"TitleId\":%s,\"GroupId\":\"%s\",\"GiveupDuration\":%d,\"PostbackUrl\":null,\"SeatsOccupied\":%d,\"MinSeats\":%d,\"MaxSeats\":%d,\"MatchCriteria\":{\"Restriction\":\"PreserveSession\",\"Custom\":\"%s\"}}", sessionid, m_titleId, m_groupId, giveupDuration, seatsOccupied, minSeats, maxSeats, custom);

    Request *req = NULL;
    req = MakeWebRequest<Request>(NULL, FULLURL, "POST", buf, req, response);
    return req;   
}


//--------------------------------------------------------------------------------------
// AtgREST::GetMatchmakingRequestStatus
//
//--------------------------------------------------------------------------------------
RequestStatus * AtgREST::GetMatchmakingRequestStatus(CHAR *xuid, CHAR *request, DWORD timeout, HttpResponse &response)
{
    CHAR FULLURL[URL_STRSIZE];

    sprintf_s(FULLURL, URL_STRSIZE, "%s/users/xuid(%s)/multiplayer/matchrequests/%s?timeout=%d", BASEURL, xuid, request, timeout);

    RequestStatus *status = NULL;
    status = MakeWebRequest<RequestStatus>(NULL, FULLURL, "GET", NULL, status, response);
    return status;   
}


//--------------------------------------------------------------------------------------
// AtgREST::CancelMatchmakingRequestStatus
//
//--------------------------------------------------------------------------------------
VOID AtgREST::CancelMatchmakingRequestStatus(CHAR *xuid, CHAR *requestId, HttpResponse &response)
{
    CHAR FULLURL[URL_STRSIZE];
    sprintf_s(FULLURL, URL_STRSIZE, "%s/users/xuid(%s)/multiplayer/matchrequests/%s", BASEURL, xuid, requestId);

    NoObject *empty = NULL;
    empty = MakeWebRequest<NoObject>(NULL, FULLURL, "DELETE", NULL, empty, response);
    delete empty;
    return;   
}


//--------------------------------------------------------------------------------------
// Base64::EncodeChunk1
//
// encode 1 byte of raw data
//--------------------------------------------------------------------------------------
VOID Base64::EncodeChunk1(BYTE *rawData, BYTE *encodedData)
{
    BYTE val1 = rawData[0] >> 2; // first 6 bits
    BYTE val2 = ((rawData[0] & 0x03) << 4);

    encodedData[0] = Base64Table[val1];
    encodedData[1] = Base64Table[val2];
    encodedData[2] = '=';
    encodedData[3] = '=';
}


//--------------------------------------------------------------------------------------
// Base64::EncodeChunk2
//
// encode 2 bytes of raw data
//--------------------------------------------------------------------------------------

VOID Base64::EncodeChunk2(BYTE *rawData, BYTE *encodedData)
{
    BYTE val1 = rawData[0] >> 2; // first 6 bits
    BYTE val2 = ((rawData[0] & 0x03) << 4) | (rawData[1] >> 4); // last 2 bits of first byte + first 4 bits of second byte
    BYTE val3 = ((rawData[1] & 0x0F) << 2);

    encodedData[0] = Base64Table[val1];
    encodedData[1] = Base64Table[val2];
    encodedData[2] = Base64Table[val3];
    encodedData[3] = '=';
}


//--------------------------------------------------------------------------------------
// Base64::EncodeChunk3
//
// convert 3 8bit normal bytes (24bits total) into 4 64bit base64
//--------------------------------------------------------------------------------------
VOID Base64::EncodeChunk3(BYTE *rawData, BYTE *encodedData)
{
    BYTE val1 = rawData[0] >> 2; // first 6 bits
    BYTE val2 = ((rawData[0] & 0x03) << 4) | (rawData[1] >> 4); // last 2 bits of first byte + first 4 bits of second byte
    BYTE val3 = ((rawData[1] & 0x0F) << 2) | (rawData[2] >> 6); // last 4 bits of second byte and first 2 bits of last byte
    BYTE val4 = (rawData[2] << 2); // last 6 bits
    val4 = val4 >> 2;

    encodedData[0] = Base64Table[val1];
    encodedData[1] = Base64Table[val2];
    encodedData[2] = Base64Table[val3];
    encodedData[3] = Base64Table[val4];
}

//--------------------------------------------------------------------------------------
// Base64::DecodeChunk
//
// base64 comes in 4 6-bit group bundles, process one bundle
//--------------------------------------------------------------------------------------
VOID Base64::DecodeChunk(BYTE *encodedData, BYTE *outData)
{
    DWORD out = 0;

    // get 4 6-bit groups
    DWORD a = Base64Decode[encodedData[0]];
    DWORD b = Base64Decode[encodedData[1]];
    DWORD c = Base64Decode[encodedData[2]];
    DWORD d = Base64Decode[encodedData[3]];
    
    // combine 4 6-bit entries into 8bit array (3 bytes or lower 24 bits)
    out = (a << 18) | (b << 12) | (c << 6) | d;

    // write out 24bits that are now grouped together correctly
    if (outData != NULL)
    {
        BYTE *p = (BYTE *) &out;
        outData[0] = p[1];
        outData[1] = p[2];
        outData[2] = p[3];
    }
}

//--------------------------------------------------------------------------------------
// Base64::EncodeData
//
// Encode a string into Base64
//--------------------------------------------------------------------------------------
VOID Base64::EncodeData(BYTE *data, BYTE *outData, DWORD cbData)
{
    while ((int) cbData > 0)
    {
        if (cbData == 1)
        {
            EncodeChunk1(data, outData);
            cbData -= 1;
            data += 1;
            outData += 4;
        }
        else if (cbData == 2)
        {
            EncodeChunk2(data, outData);
            cbData -= 2;
            data += 2;
            outData += 4;
        }
        else
        {
            EncodeChunk3(data, outData);
            cbData -= 3;
            data += 3;
            outData += 4;
        }
    }
    *outData = 0;
}


//--------------------------------------------------------------------------------------
// Base64::DecodeData
//
// Decode a base64 string
//--------------------------------------------------------------------------------------
VOID Base64::DecodeData(BYTE *data, BYTE *outData, DWORD cbData)
{
    while ((int) cbData > 0)
    {
        DecodeChunk(data, outData);

        cbData -= 4;
        data += 4;
        outData += 3;
    }
    *outData = 0;
}

//--------------------------------------------------------------------------------------
// Base64::ConstructTables
//
// Function builds both Base64 encode and decode look-up tables (used for faster processing)
//--------------------------------------------------------------------------------------
VOID Base64::ConstructTables()
{
    for(BYTE i='A'; i<='Z'; i++)
    {
        BYTE val = i - 'A';
        Base64Decode[i] = val;
        Base64Table[val] = i;
    }

    for(BYTE i='a'; i<='z'; i++)
    {
        BYTE val = i - 'a' + 26;
        Base64Decode[i] = val;
        Base64Table[val] = i;
    }

    for (BYTE i='0'; i<='9'; i++)
    {
        BYTE val = i - '0' + 52;
        Base64Decode[i] = val;
        Base64Table[val] = i;
    }

    Base64Decode['+'] = 62;
    Base64Table[62] = '+';

    Base64Decode['/'] = 63;
    Base64Table[63] = '/';

    Base64Decode['='] = 0; //padding means no bytes existed so zero bits
}


} // end namespace REST
} // end namespace ATG


```

`XenonDumper/libs/Atg/AtgRest.h`:

```h


//--------------------------------------------------------------------------------------
// RESTFUL Objects for Xbox LIVE endpoint wrapper layer
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------

#pragma once
#ifndef ROBLIVE_H
#define ROBLIVE_H


//--------------------------------------------------------------------------------------
// INCLUDES
//--------------------------------------------------------------------------------------
#include <xtl.h>
#include <malloc.h>
#include <stdio.h>
#include "AtgInput.h"
#include "AtgUtil.h"
#include "AtgConsole.h"
#include "AtgHttp.h"
#include "AtgJson.h"


namespace ATG
{
namespace REST
{

// ATGREST sits on top of the HTTP and JSON components
using namespace ATG::HTTP;
using namespace ATG::JSON;

#define NO_STRSIZE          0
#define GAMERTAG_STRSIZE    16
#define CUSTOMDATA_STRSIZE  1024
#define DEFAULT_STRSIZE     256
#define BIG_STRSIZE         10000
#define URL_STRSIZE         256

#define TITLEID_STRSIZE     12
#define GROUPID_STRSIZE     40

//----------------------------------------------------------------------------------------------
// JSON representation classes for AtgJsonReader (Based on the Xbox LIVE REST API definitions)
//----------------------------------------------------------------------------------------------
class AtgREST;

class NoObject
{
public:
    // no publics, used simply to make webrequest when we dont care about JSON
private: 
    friend AtgREST;
    static PropertyTag tags[];
    static DWORD tagsize;
};


class UsersMe
{
public:
    XUID xuid;
    CHAR gamerTag[GAMERTAG_STRSIZE]; // string sizes are put into tags

private:
    friend AtgREST;
    static PropertyTag tags[];
    static DWORD tagsize;
};

class Players
{
public:
    XUID xuid;
    CHAR gamertag[GAMERTAG_STRSIZE]; 
    INT  seatIndex;
    CHAR customData[CUSTOMDATA_STRSIZE]; 
    BOOL isCurrentlyInSession;

private:
    friend AtgREST;
    friend Collection<Players>;
    static PropertyTag tags[];
    static DWORD tagsize;
};

class Sessions
{
public:
    CHAR  sessionId[DEFAULT_STRSIZE]; 
    DWORD titleId;
    INT   variant;
    CHAR  displayName[DEFAULT_STRSIZE]; 
    //creationTime
    CHAR  customData[CUSTOMDATA_STRSIZE]; 
    INT   maxPlayers;
    INT   seatsAvailable;
    BOOL  isClosed;
    BOOL  hasEnded;
    Collection<Players> roster;

private: 
    friend AtgREST;
    static PropertyTag tags[];
    static DWORD tagsize;
};

class Request
{
public:
    CHAR RequestId[DEFAULT_STRSIZE]; 

private: 
    friend AtgREST;
    static PropertyTag tags[];
    static DWORD tagsize;
};


class RequestStatus
{
public:
    CHAR SessionId[DEFAULT_STRSIZE]; 
    CHAR Status[DEFAULT_STRSIZE]; 

private: 
    friend AtgREST;
    static PropertyTag tags[];
    static DWORD tagsize;
};

class GameMessages
{
public:
    INT queueIndex;
    INT sequenceNumber;
    XUID senderXuid;
    //DateTime timeStampe;
    CHAR data[BIG_STRSIZE]; 

private: 
    friend AtgREST;
    friend Collection<GameMessages>;
    static PropertyTag tags[];
    static DWORD tagsize;
};


class MessageArray
{
public:
    Collection<GameMessages> messages;

private: 
    friend AtgREST;
    static PropertyTag tags[];
    static DWORD tagsize;
};


//--------------------------------------------------------------------------------------
// class Base64
//
// simple base64 encoder/decoder.  Easy to re-use.
//--------------------------------------------------------------------------------------
class Base64
{
public:
    VOID ConstructTables();
    VOID EncodeData(BYTE *data, BYTE *outData, DWORD cbData);
    VOID DecodeData(BYTE *data, BYTE *outData, DWORD cbData);

private:
    VOID DecodeChunk(BYTE *encodedData, BYTE *outData);
    VOID EncodeChunk1(BYTE *rawData, BYTE *encodedData);
    VOID EncodeChunk2(BYTE *rawData, BYTE *encodedData);
    VOID EncodeChunk3(BYTE *rawData, BYTE *encodedData);

    BYTE Base64Table [64]; 
    BYTE Base64Decode[256]; 

};


//--------------------------------------------------------------------------------------
// class HttpResponse
//
// this class is used for each wrapper to return up the HTTP response information
// if the function fails, it will return NULL and then the client can use this class 
// to understand why the call failed
//--------------------------------------------------------------------------------------
class HttpResponse
{
public:
    DWORD returnCode;
};


//--------------------------------------------------------------------------------------
// class AtgREST
//
// RESTFUL Objects for Xbox LIVE endpoint wrapper layer
//--------------------------------------------------------------------------------------
class AtgREST 
{
public:
    AtgREST() {};

    HRESULT Initialize(CHAR *titleId, CHAR *groupId, DWORD dwUserIndex);
    HRESULT Shutdown();

    template<typename Type> Type* MakeWebRequest(CHAR *customHeader, CHAR *url, CHAR *verb, CHAR *data, Type *p, HttpResponse &response);

    Sessions* CreateAsyncSession(INT variant, INT maxPlayers, CHAR *displayName, HttpResponse &response);
    Players* JoinAsyncSession(CHAR *sessionid, CHAR *xuid, CHAR *gamertag, HttpResponse &response); 
    Sessions* GetAsyncSession(CHAR *sessionid, HttpResponse &response); 
    Request* CreateMatchmakingRequest(CHAR *xuid, CHAR *sessionid, DWORD giveupDuration, DWORD seatsOccupied, DWORD minSeats, DWORD maxSeats, CHAR *custom, HttpResponse &response);
    RequestStatus* GetMatchmakingRequestStatus(CHAR *xuid, CHAR *request, DWORD timeout, HttpResponse &response);
    VOID CancelMatchmakingRequestStatus(CHAR *xuid, CHAR *requestId, HttpResponse &response);
    UsersMe* GetMe(HttpResponse &response);
    VOID GetMessages(CHAR *xuid, HttpResponse &response);
    VOID SendMessage(CHAR *sessionId, HttpResponse &response);
    VOID DeleteMessage(CHAR *xuid, HttpResponse &response);
    VOID SendAsyncMPMessage(CHAR *sessionId, CHAR *xuid, CHAR *data, DWORD queueNum, HttpResponse &response);
    MessageArray* GetAsyncMPMessage(CHAR *sessionId, DWORD startAfterSeqNum, DWORD queueNum, DWORD timeout, HttpResponse &response);
    VOID DeleteAsyncMPMessage(HttpResponse &response);
    VOID UpdateSessionPlayer(HttpResponse &response);
    VOID UpdateSession(HttpResponse &response);
    VOID RemovePlayer(HttpResponse &response);
    VOID GetUserSessions(CHAR *xuid, HttpResponse &response);

private:
    AuthManager m_Auth;
    HANDLE      m_hWorkerThread;
    CHAR        m_titleId[TITLEID_STRSIZE]; // string representation of 32 bit number
    CHAR        m_groupId[GROUPID_STRSIZE]; // string representation of the title group id
};


} // end namespace REST
} // end namespace ATG

#endif

```

`XenonDumper/libs/Atg/AtgScene.cpp`:

```cpp
//-----------------------------------------------------------------------------
// scene.cpp
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "AtgMaterials.h"
#include "AtgModel.h"
#include "AtgScene.h"
#include "AtgSceneMesh.h"
#include "AtgResourceDatabase.h"

namespace ATG
{

CONST StringID Scene::TypeID( L"Scene" );

//-----------------------------------------------------------------------------
// Name: Scene::Scene
//-----------------------------------------------------------------------------
Scene::Scene()
{
    m_pResourceDatabase = NULL;
    FXLCreateEffectPool( &m_pGlobalParameterPool );
    m_pResourceDatabase = new ResourceDatabase();
}

Scene::~Scene()
{
    m_pGlobalParameterPool->Release();
    m_pGlobalParameterPool = NULL;
    delete m_pResourceDatabase;
    m_pResourceDatabase = NULL;
}

VOID Scene::Render( ::D3DDevice* pd3dDevice, BOOL bSetTextures )
{
    ATG::NameIndexedCollection::iterator i;

    for( i = GetInstanceList()->begin(); i != GetInstanceList()->end(); i++ )
    {
        // Select models from the object list.
        if( ( *i )->IsDerivedFrom( ATG::Model::TypeID ) )
        {
            ATG::Model* pModel = ( ATG::Model* )( *i );

            // Loop over mesh mappings.
            DWORD dwMeshMappingCount = pModel->GetNumMeshMappings();
            for( DWORD dwMapIndex = 0; dwMapIndex < dwMeshMappingCount; ++dwMapIndex )
            {
                ATG::MeshMapping& mm = pModel->GetMeshMapping( dwMapIndex );
                ATG::BaseMesh* pMesh = mm.pMesh;

                // Loop over mesh subsets.
                DWORD dwSubsetCount = pMesh->GetNumSubsets();
                for( DWORD dwSubsetIndex = 0; dwSubsetIndex < dwSubsetCount; ++dwSubsetIndex )
                {
                    if( bSetTextures )
                    {
                        ATG::MaterialInstance* pMaterial = mm.Materials[ dwSubsetIndex ];

                        for( DWORD j = 0; j < pMaterial->GetRawParameterCount(); ++j )
                        {
                            // Retrieve diffuse texture and normalmaps and set it
                            ATG::MaterialParameter& param = pMaterial->GetRawParameter( j );
                            if( param.pValue != NULL )
                            {
                                ATG::Texture2D* pTex2D = ( ATG::Texture2D* )param.pValue;

                                pd3dDevice->SetTexture( j, pTex2D->GetD3DTexture() );
                            }
                        }
                    }

                    // Render the mesh subset.
                    pMesh->RenderSubset( dwSubsetIndex, pd3dDevice );
                }
            }
        }
    }
}

} // namespace ATG

```

`XenonDumper/libs/Atg/AtgScene.h`:

```h
//-----------------------------------------------------------------------------
// AtgScene.h
//
// describes a scene which can own per-scene materials and animations
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef ATG_SCENE_H
#define ATG_SCENE_H

#include <list>
#include "AtgFrame.h"
#include <fxl.h>

namespace ATG
{

class ResourceDatabase;
class EffectGlobalParameterPool;

//-----------------------------------------------------------------------------
// Name: Scene
// Desc: A database containing meshes, materials, and model instances
//-----------------------------------------------------------------------------
class Scene : public Frame
{
    DEFINE_TYPE_INFO();
public:
    Scene();
    ~Scene();

    ResourceDatabase*       GetResourceDatabase() { return m_pResourceDatabase; }

    VOID                    AddObject( NamedTypedObject *pObject ) { m_InstanceDatabase.Add( pObject ); }
    NamedTypedObject*       FindObject( CONST WCHAR* szName ) { return m_InstanceDatabase.Find( szName ); }
    NamedTypedObject*       FindObjectOfType( CONST WCHAR* szName, const StringID TypeID ) { return m_InstanceDatabase.FindTyped( szName, TypeID ); }
    VOID                    RemoveObject( NamedTypedObject *pObject ) { m_InstanceDatabase.Remove( pObject ); }
    FXLEffectPool*          GetEffectParameterPool() { return m_pGlobalParameterPool; }
    NameIndexedCollection*  GetInstanceList() { return &m_InstanceDatabase; }

    VOID                    SetFileName( const CHAR* strFileName ) { strcpy_s( m_strFileName, strFileName ); }
    VOID                    SetMediaRootPath( const CHAR* strMediaRootPath ) { strcpy_s( m_strMediaRootPath,
                                                                                         strMediaRootPath ); }
    const CHAR*             GetFileName() const { return m_strFileName; }
    const CHAR*             GetMediaRootPath() const { return m_strMediaRootPath; }

    VOID                    Render( ::D3DDevice* pd3dDevice, BOOL bSetTextures = TRUE );

private:
    FXLEffectPool* m_pGlobalParameterPool;
    ResourceDatabase* m_pResourceDatabase;
    NameIndexedCollection m_InstanceDatabase;
    CHAR m_strFileName[MAX_PATH];
    CHAR m_strMediaRootPath[MAX_PATH];
};

} // namespace ATG

#endif // ATG_SCENE_H

```

`XenonDumper/libs/Atg/AtgSceneAll.h`:

```h
//-----------------------------------------------------------------------------
// AtgSceneAll.h
//
// Convenience header file that includes all of the ATG scene-related header files.
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef ATGSCENEALL_H
#define ATGSCENEALL_H

#include "AtgBound.h"
#include "AtgCollision.h"
#include "AtgFrame.h"
#include "AtgResourceDatabase.h"
#include "AtgScene.h"
#include "AtgLight.h"
#include "AtgMaterials.h"
#include "AtgSceneMesh.h"
#include "AtgModel.h"
#include "AtgCamera.h"
#include "AtgXmlParser.h"
#include "AtgSceneFileParser.h"
#include "AtgAnimation.h"
#include "AtgSkeletalAnimation.h"

#endif

```

`XenonDumper/libs/Atg/AtgSceneFileParser.cpp`:

```cpp
//-----------------------------------------------------------------------------
// AtgSceneFileParser.cpp
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

//--------------------------------------------------------------------------------------
//
// This XML parser is somewhat unique, in that it bundles up the results from each SAX
// callback and distributes a smaller set of callbacks to the actual loader methods
// implemented in ProcessMeshData, ProcessFrameData, etc.
//
// For example, consider this sample XML document:
//
// <A>foobar</A>
//
// A straight SAX callback class would receive 3 callbacks:
// ElementBegin( "A" )
// ElementContent( "foobar" )
// ElementEnd( "A" )
//
// The problem is that the content is disassociated from the tag that it belongs to,
// especially since the ATG SAX parser may deliver multiple ElementContent() callbacks
// if the element content is particularly large.
//
// The ElementBegin(), ElementContent(), and ElementEnd() handlers implemented in
// SceneFileParser cache and accumulate the results into m_CurrentElementDesc, and then
// only call two handlers after that - HandleElementData() and HandleElementEnd().
// The data callback includes the name of the begin tag as well as any content between
// the begin and end tags.
//
// So, the same XML document is presented to the loader code like this:
// HandleElementData() strElementName = "A" strElementBody = "foobar" bEndElement = FALSE
// HandleElementEnd() strElementName = "A" strElementBody = "" bEndElement = TRUE
//
// Not only does this reduce complexity, it fits the XATG file format better because
// most of the data is in a rough key-value format, like <Size>3.0</Size>.
//
//--------------------------------------------------------------------------------------

#include "stdafx.h"
#include "AtgDevice.h"
#include "AtgSceneFileParser.h"
#include "AtgEnumStrings.h"
#include "AtgSceneAll.h"
#include "AtgResource.h"
#include "AtgUtil.h"

namespace ATG
{

#define MATCH_ELEMENT_NAME(x) (_wcsicmp(m_CurrentElementDesc.strElementName,x)==0)
#define MIN_SAFE_VERSION        1.6f

const BOOL g_bDebugXMLParser = FALSE;

extern D3DDevice* g_pd3dDevice;

Scene*              g_pCurrentScene = NULL;
Frame*              g_pRootFrame = NULL;
DWORD               g_dwLoaderFlags = 0;
CHAR                g_strMediaRootPath[MAX_PATH];
DWORD*              g_pLoadProgress = NULL;
BYTE*               g_pBinaryBlobData = NULL;

CRITICAL_SECTION*   g_pD3DCriticalSection = NULL;

CHAR                g_strParseError[256];

HRESULT SceneFileParser::PrepareForThreadedLoad( CRITICAL_SECTION* pCriticalSection )
{
    g_pD3DCriticalSection = pCriticalSection;
    return S_OK;
}

VOID SceneFileParser::AcquireDirect3D()
{
    if( g_pD3DCriticalSection != NULL )
    {
        EnterCriticalSection( g_pD3DCriticalSection );
        g_pd3dDevice->AcquireThreadOwnership();
    }
}

VOID SceneFileParser::ReleaseDirect3D()
{
    if( g_pD3DCriticalSection != NULL )
    {
        g_pd3dDevice->ReleaseThreadOwnership();
        LeaveCriticalSection( g_pD3DCriticalSection );
    }
}

HRESULT SceneFileParser::LoadXATGFile( const CHAR* strFilename, Scene* pScene, Frame* pRootFrame, DWORD dwFlags,
                                       DWORD* pLoadProgress )
{
    XMLParser parser;
    SceneFileParser XATGParser;

    g_strParseError[0] = '\0';

    parser.RegisterSAXCallbackInterface( &XATGParser );
    g_pCurrentScene = pScene;
    g_pBinaryBlobData = NULL;
    g_pRootFrame = ( pRootFrame != NULL ) ? pRootFrame : pScene;
    g_dwLoaderFlags = dwFlags;
    g_pLoadProgress = pLoadProgress;
    XATGParser.m_Context.pCurrentObject = pScene;
    XATGParser.m_Context.pCurrentParentFrame = NULL;
    XATGParser.m_Context.pCurrentParentObject = NULL;

    // extract media root path from scene filename
    strcpy_s( g_strMediaRootPath, strFilename );
    CHAR* pSceneDir = strstr( g_strMediaRootPath, "scenes\\" );
    if( pSceneDir != NULL )
    {
        *pSceneDir = '\0';
    }
    else
    {
        pSceneDir = strrchr( g_strMediaRootPath, '\\' );
        assert( pSceneDir != NULL );
        *pSceneDir = '\0';
    }

    ATG::BaseMaterial::SetMediaRootPath( g_strMediaRootPath );

    HRESULT hr = parser.ParseXMLFile( strFilename );

    if( SUCCEEDED( hr ) )
    {
        pScene->SetFileName( strFilename );
        pScene->SetMediaRootPath( g_strMediaRootPath );
        CollapseSceneFrames( g_pRootFrame );
    }

    g_pLoadProgress = NULL;
    return hr;
}

const CHAR* SceneFileParser::GetParseErrorMessage()
{
    return g_strParseError;
}

VOID SceneFileParser::SetParseProgress( DWORD dwProgress )
{
    if( g_pLoadProgress != NULL )
        *g_pLoadProgress = dwProgress;
}

VOID SceneFileParser::Error( HRESULT hError, const CHAR* strMessage )
{
    OutputDebugString( strMessage );
    OutputDebugString( "\n" );
    strcpy_s( g_strParseError, strMessage );
}

HRESULT SceneFileParser::EndDocument()
{
    if( strlen( g_strParseError ) > 0 )
        return E_FAIL;
    return S_OK;
}


inline BOOL ErrorHasOccurred()
{
    return ( g_strParseError[0] != '\0' );
}


HRESULT SceneFileParser::ElementBegin( const WCHAR* strName, UINT NameLen, const XMLAttribute* pAttributes,
                                       UINT NumAttributes )
{
    // Check if an error has been encountered in scene parsing.
    if( ErrorHasOccurred() )
        return E_FAIL;

    // Distribute an accumulated begin+content package if one exists.
    HandleElementData();

    // Start a new begin+content package.
    // Copy the begin tag name to the current element desc.
    wcsncpy_s( m_CurrentElementDesc.strElementName, strName, NameLen );
    // Clear out the accumulated element body.
    m_CurrentElementDesc.strElementBody[0] = L'\0';
    // Copy all attributes from the begin tag into the current element desc.
    CopyAttributes( pAttributes, NumAttributes );
    return S_OK;
}

HRESULT SceneFileParser::ElementContent( const WCHAR* strData, UINT DataLen, BOOL More )
{
    // Accumulate this element content into the current desc body content.
    wcsncat_s( m_CurrentElementDesc.strElementBody, strData, DataLen );
    return S_OK;
}

HRESULT SceneFileParser::ElementEnd( const WCHAR* strName, UINT NameLen )
{
    // Check if an error has been encountered in scene parsing.
    if( ErrorHasOccurred() )
        return E_FAIL;

    // Distribute an accumulated begin+content package if one exists.
    HandleElementData();

    // Copy the end tag name into the current element desc.
    wcsncpy_s( m_CurrentElementDesc.strElementName, strName, NameLen );
    // Clear out the element body.
    m_CurrentElementDesc.strElementBody[0] = L'\0';
    // Distribute the end tag.
    HandleElementEnd();
    // Clear out the element name.
    m_CurrentElementDesc.strElementName[0] = L'\0';
    return S_OK;
}

VOID SceneFileParser::CopyAttributes( const XMLAttribute* pAttributes, UINT uAttributeCount )
{
    m_CurrentElementDesc.Attributes.clear();
    for( UINT i = 0; i < uAttributeCount; i++ )
    {
        XMLElementAttribute Attribute;
        wcsncpy_s( Attribute.strName, pAttributes[i].strName, pAttributes[i].NameLen );
        wcsncpy_s( Attribute.strValue, pAttributes[i].strValue, pAttributes[i].ValueLen );
        m_CurrentElementDesc.Attributes.push_back( Attribute );
    }
}

BOOL SceneFileParser::FindAttribute( const WCHAR* strName, WCHAR* strDest, UINT uDestLength )
{
    const WCHAR* strValue = FindAttribute( strName );
    if( strValue != NULL )
    {
        wcscpy_s( strDest, uDestLength, strValue );
        return TRUE;
    }
    strDest[0] = L'\0';
    return FALSE;
}

const WCHAR* SceneFileParser::FindAttribute( const WCHAR* strName )
{
    for( UINT i = 0; i < m_CurrentElementDesc.Attributes.size(); i++ )
    {
        const XMLElementAttribute& Attribute = m_CurrentElementDesc.Attributes[i];
        if( _wcsicmp( Attribute.strName, strName ) == 0 )
        {
            return Attribute.strValue;
        }
    }
    return NULL;
}

BOOL SceneFileParser::SetObjectNameFromAttribute( NamedTypedObject* pNTO )
{
    const WCHAR* strName = FindAttribute( L"Name" );
    if( strName != NULL )
    {
        pNTO->SetName( strName );
        return TRUE;
    }
    return FALSE;
}


VOID ScrubFloatString( WCHAR* strFloatString )
{
    WCHAR* pChar = strFloatString;
    while( *pChar != L'\0' )
    {
        if( *pChar == L'{' || *pChar == L'}' || *pChar == L',' || *pChar == L'\t' )
            *pChar = L' ';
        pChar++;
    }
}


XMVECTOR ScanVector3( const WCHAR* strThreeFloats )
{
    WCHAR strTemp[100];
    wcscpy_s( strTemp, strThreeFloats );
    ScrubFloatString( strTemp );

    XMFLOAT4A vResult;
    memset( &vResult, 0, sizeof(vResult ));
    swscanf_s( strTemp, L"%f %f %f",
               &vResult.x, &vResult.y, &vResult.z );
     
    return XMLoadVector4A( &vResult );
}


XMVECTOR ScanVector4( const WCHAR* strFourFloats )
{
    WCHAR strTemp[100];
    wcscpy_s( strTemp, strFourFloats );
    ScrubFloatString( strTemp );
    
    XMFLOAT4A vResult;
    memset( &vResult, 0, sizeof(vResult ));

    swscanf_s( strTemp, L"%f %f %f %f",
               &vResult.x, &vResult.y, &vResult.z, &vResult.w );

    return XMLoadVector4A( &vResult );
}


XMVECTOR ScanColorARGBtoRGBA( const WCHAR* strColorARGB )
{
    XMVECTOR vColor = ScanVector4( strColorARGB );
    return XMVectorSwizzle( vColor, 1, 2, 3, 0 );
}


//--------------------------------------------------------------------------------------
// Name: HandleElementData()
// Desc: This method gets "first crack" at a begin tag + content combo.
//       It identifies certain high-level tags and sets the loader state appropriately.
//--------------------------------------------------------------------------------------
VOID SceneFileParser::HandleElementData()
{
    // If the tag name is blank, return.
    if( wcslen( m_CurrentElementDesc.strElementName ) == 0 )
        return;
    // We are processing a begin tag.
    m_CurrentElementDesc.bEndElement = FALSE;

    // Check for certain high-level tags and set the loader current object type.
    if( MATCH_ELEMENT_NAME( L"StaticMesh" ) || MATCH_ELEMENT_NAME( L"Mesh" ) )
    {
        m_Context.CurrentObjectType = XATG_MESH;
    }
    else if( MATCH_ELEMENT_NAME( L"Frame" ) )
    {
        m_Context.CurrentObjectType = XATG_FRAME;
    }
    else if( MATCH_ELEMENT_NAME( L"Model" ) )
    {
        m_Context.CurrentObjectType = XATG_MODEL;
    }
    else if( MATCH_ELEMENT_NAME( L"MaterialInstance" ) )
    {
        m_Context.CurrentObjectType = XATG_MATERIAL;
    }
    else if( MATCH_ELEMENT_NAME( L"AmbientLight" ) )
    {
        m_Context.CurrentObjectType = XATG_AMBIENTLIGHT;
    }
    else if( MATCH_ELEMENT_NAME( L"DirectionalLight" ) )
    {
        m_Context.CurrentObjectType = XATG_DIRECTIONALLIGHT;
    }
    else if( MATCH_ELEMENT_NAME( L"PointLight" ) )
    {
        m_Context.CurrentObjectType = XATG_POINTLIGHT;
    }
    else if( MATCH_ELEMENT_NAME( L"SpotLight" ) )
    {
        m_Context.CurrentObjectType = XATG_SPOTLIGHT;
    }
    else if( MATCH_ELEMENT_NAME( L"PerspectiveCamera" ) )
    {
        m_Context.CurrentObjectType = XATG_CAMERA;
    }
    else if( MATCH_ELEMENT_NAME( L"Animation" ) )
    {
        m_Context.CurrentObjectType = XATG_ANIMATION;
    }

    // Distribute the data to the appropriate loader function.
    DistributeElementToLoaders();
}


//--------------------------------------------------------------------------------------
// Name: HandleElementEnd()
// Desc: This method gets "first crack" at an end tag.
//       It labels the tag state as "end tag" and passes the tag onto the loader
//       methods.
//--------------------------------------------------------------------------------------
VOID SceneFileParser::HandleElementEnd()
{
    // We are processing an end tag.
    m_CurrentElementDesc.bEndElement = TRUE;

    // Distribute the end tag to the appropriate loader function.
    DistributeElementToLoaders();
}


//--------------------------------------------------------------------------------------
// Name: DistributeElementToLoaders()
// Desc: This method calls the correct loader method based on the type of the current
//       object that we're parsing.  In general, a high level tag sets the object type,
//       and then this method sends all child tags of that high level tag to the right
//       loader method.
//--------------------------------------------------------------------------------------
VOID SceneFileParser::DistributeElementToLoaders()
{
    switch( m_Context.CurrentObjectType )
    {
        case XATG_NONE:
            ProcessRootData();
            break;
        case XATG_FRAME:
            ProcessFrameData();
            break;
        case XATG_MESH:
        case XATG_VERTEXBUFFER:
        case XATG_INDEXBUFFER:
        case XATG_VERTEXDECLELEMENT:
        case XATG_INDEXBUFFERSUBSET:
        case XATG_SKINNEDMESHINFLUENCES:
            ProcessMeshData();
            break;
        case XATG_MODEL:
            ProcessModelData();
            break;
        case XATG_MATERIAL:
            ProcessMaterialData();
            break;
        case XATG_AMBIENTLIGHT:
        case XATG_DIRECTIONALLIGHT:
        case XATG_POINTLIGHT:
        case XATG_SPOTLIGHT:
            ProcessLightData();
            break;
        case XATG_CAMERA:
            ProcessCameraData();
            break;
        case XATG_ANIMATION:
            ProcessAnimationData();
            break;
        default:
            assert( FALSE );
            break;
    }
}

VOID SceneFileParser::ProcessRootData()
{
    if( !m_CurrentElementDesc.bEndElement )
    {
        if( MATCH_ELEMENT_NAME( L"XFileATG" ) )
        {
            WCHAR strAttributeValue[256];
            if( FindAttribute( L"Version", strAttributeValue, ARRAYSIZE( strAttributeValue ) ) )
            {
                FLOAT fVersion = ( FLOAT )_wtof( strAttributeValue );
                if( fVersion < MIN_SAFE_VERSION )
                {
                    Error( E_FAIL, "File version is out of date." );
                }
            }
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"PhysicalMemoryFile" ) )
        {
            CHAR strFileName[MAX_PATH];
            strcpy_s( strFileName, g_strMediaRootPath );
            CHAR strBlobFile[MAX_PATH];
            WideCharToMultiByte( CP_ACP, 0, m_CurrentElementDesc.strElementBody,
                                 wcslen( m_CurrentElementDesc.strElementBody ) + 1, strBlobFile, MAX_PATH, NULL,
                                 NULL );
            strcat_s( strFileName, strBlobFile );
            HANDLE hFile = CreateFile( strFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                                       FILE_FLAG_SEQUENTIAL_SCAN, NULL );
            if( hFile == INVALID_HANDLE_VALUE )
            {
                Error( E_FAIL, "Could not find physical memory blob file." );
                return;
            }
            DWORD dwFileSize = GetFileSize( hFile, NULL );
            assert( dwFileSize > 0 );
            g_pBinaryBlobData = ( BYTE* )g_pCurrentScene->GetResourceDatabase()->PhysicalAlloc( dwFileSize, 0,
                                                                                                PAGE_READWRITE |
                                                                                                PAGE_WRITECOMBINE );
            DWORD dwBytesRead = 0;
            if( !ReadFile( hFile, g_pBinaryBlobData, dwFileSize, &dwBytesRead, 0 ) )
            {
                CloseHandle( hFile );
                return;
            }
            CloseHandle( hFile );
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"BundledResources" ) )
        {
            CHAR strFileName[MAX_PATH];
            strcpy_s( strFileName, g_strMediaRootPath );
            CHAR strBundleFile[MAX_PATH];
            WideCharToMultiByte( CP_ACP, 0, m_CurrentElementDesc.strElementBody,
                                 wcslen( m_CurrentElementDesc.strElementBody ) + 1, strBundleFile, MAX_PATH, NULL,
                                 NULL );
            strcat_s( strFileName, strBundleFile );
            PackedResource* pPackedResource = new PackedResource();
            //AcquireDirect3D();
            pPackedResource->Create( strFileName );
            //ReleaseDirect3D();
            g_pCurrentScene->GetResourceDatabase()->AddBundledResources( pPackedResource );
            return;
        }
    }
    else
    {
    }
}


VOID SceneFileParser::ProcessFrameData()
{
    Frame* pFrame = ( Frame* )m_Context.pCurrentObject;
    if( !m_CurrentElementDesc.bEndElement )
    {
        if( MATCH_ELEMENT_NAME( L"Frame" ) )
        {
            if( m_Context.pCurrentObject == NULL )
            {
                // If we are the first frame, our parent is the root frame
                m_Context.pCurrentObject = g_pRootFrame;
            }
            pFrame = new Frame;
            pFrame->SetParent( ( Frame* )m_Context.pCurrentObject );
            pFrame->SetLocalTransform( XMMatrixIdentity() );
            m_Context.pCurrentParentFrame = ( Frame* )m_Context.pCurrentObject;
            m_Context.pCurrentObject = pFrame;
            m_Context.CurrentObjectType = XATG_FRAME;
            SetObjectNameFromAttribute( pFrame );
            const WCHAR* strMatrix = FindAttribute( L"Matrix" );
            if( strMatrix != NULL )
            {
                WCHAR strTemp[512];
                wcscpy_s( strTemp, strMatrix );
                ScrubFloatString( strTemp );
                XMMATRIX Matrix;
                swscanf_s( strTemp,
                           L"%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f",
                           &Matrix._11, &Matrix._12, &Matrix._13, &Matrix._14,
                           &Matrix._21, &Matrix._22, &Matrix._23, &Matrix._24,
                           &Matrix._31, &Matrix._32, &Matrix._33, &Matrix._34,
                           &Matrix._41, &Matrix._42, &Matrix._43, &Matrix._44 );
                pFrame->SetLocalTransform( Matrix );
            }
            return;
        }
        else if( g_bDebugXMLParser )
        {
            WCHAR s[100];
            swprintf_s( s, L"Frame tag: %s\n", m_CurrentElementDesc.strElementName );
            OutputDebugStringW( s );
        }
    }
    else
    {
        if( MATCH_ELEMENT_NAME( L"Frame" ) )
        {
            g_pCurrentScene->AddObject( pFrame );

            m_Context.pCurrentObject = m_Context.pCurrentParentFrame;

            if( m_Context.pCurrentParentFrame != NULL )
                m_Context.pCurrentParentFrame = m_Context.pCurrentParentFrame->GetParent();

            m_Context.CurrentObjectType = XATG_FRAME;
            return;
        }
    }
}

WCHAR* AdvanceToken( WCHAR* pCurrentToken )
{
    pCurrentToken = wcschr( pCurrentToken, L' ' );
    if( pCurrentToken == NULL )
        return NULL;
    while( *pCurrentToken == L' ' )
        pCurrentToken++;
    if( *pCurrentToken == '\0' )
        return NULL;
    return pCurrentToken;
}

VOID SceneFileParser::CrackVertex( BYTE* pDest, const D3DVERTEXELEMENT9* pVertexElements, DWORD dwStreamIndex )
{
    WCHAR strSrc[1024];
    wcscpy_s( strSrc, m_CurrentElementDesc.strElementBody );
    ScrubFloatString( strSrc );
    WCHAR* pChar = strSrc;
    if( *pChar == L' ' )
        pChar = AdvanceToken( pChar );
    const D3DVERTEXELEMENT9* pCurrentElement = pVertexElements;
    while( pCurrentElement->Stream != 0xFF && pChar != NULL )
    {
        if( pCurrentElement->Stream != dwStreamIndex )
        {
            ++pCurrentElement;
            continue;
        }
        switch( pCurrentElement->Type )
        {
            case D3DDECLTYPE_FLOAT4:
                *( FLOAT* )pDest = ( FLOAT )_wtof( pChar );
                pChar = AdvanceToken( pChar );
                pDest += 4;
                // fallthru
            case D3DDECLTYPE_FLOAT3:
                *( FLOAT* )pDest = ( FLOAT )_wtof( pChar );
                pChar = AdvanceToken( pChar );
                pDest += 4;
                // fallthru
            case D3DDECLTYPE_FLOAT2:
                *( FLOAT* )pDest = ( FLOAT )_wtof( pChar );
                pChar = AdvanceToken( pChar );
                pDest += 4;
                // fallthru
            case D3DDECLTYPE_FLOAT1:
                *( FLOAT* )pDest = ( FLOAT )_wtof( pChar );
                pChar = AdvanceToken( pChar );
                pDest += 4;
                break;
            case D3DDECLTYPE_FLOAT16_4:
                *( D3DXFLOAT16* )pDest = D3DXFLOAT16( ( FLOAT )_wtof( pChar ) );
                pChar = AdvanceToken( pChar );
                pDest += 2;
                *( D3DXFLOAT16* )pDest = D3DXFLOAT16( ( FLOAT )_wtof( pChar ) );
                pChar = AdvanceToken( pChar );
                pDest += 2;
                // fallthru
            case D3DDECLTYPE_FLOAT16_2:
                *( D3DXFLOAT16* )pDest = D3DXFLOAT16( ( FLOAT )_wtof( pChar ) );
                pChar = AdvanceToken( pChar );
                pDest += 2;
                *( D3DXFLOAT16* )pDest = D3DXFLOAT16( ( FLOAT )_wtof( pChar ) );
                pChar = AdvanceToken( pChar );
                pDest += 2;
                break;
            case D3DDECLTYPE_DEC3N:
            {
                FLOAT Vec[3];
                Vec[0] = ( FLOAT )_wtof( pChar );
                pChar = AdvanceToken( pChar );
                Vec[1] = ( FLOAT )_wtof( pChar );
                pChar = AdvanceToken( pChar );
                Vec[2] = ( FLOAT )_wtof( pChar );
                pChar = AdvanceToken( pChar );
                XMXDECN4 DecN4( Vec[0], Vec[1], Vec[2], 1 );
                *( DWORD* )pDest = DecN4.v;
                pDest += 4;
                break;
            }
            case D3DDECLTYPE_D3DCOLOR:
            case D3DDECLTYPE_UBYTE4:
            case D3DDECLTYPE_UBYTE4N:
                *( DWORD* )pDest = ( DWORD )_wtoi( pChar );
                pDest += 4;
                pChar = AdvanceToken( pChar );
                break;
            case D3DDECLTYPE_SHORT4:
            case D3DDECLTYPE_SHORT4N:
            case D3DDECLTYPE_USHORT4:
            case D3DDECLTYPE_USHORT4N:
                *( WORD* )pDest = ( WORD )_wtoi( pChar );
                pChar = AdvanceToken( pChar );
                pDest += 2;
                *( WORD* )pDest = ( WORD )_wtoi( pChar );
                pChar = AdvanceToken( pChar );
                pDest += 2;
                // fallthru
            case D3DDECLTYPE_SHORT2:
            case D3DDECLTYPE_SHORT2N:
            case D3DDECLTYPE_USHORT2:
            case D3DDECLTYPE_USHORT2N:
                *( WORD* )pDest = ( WORD )_wtoi( pChar );
                pChar = AdvanceToken( pChar );
                pDest += 2;
                *( WORD* )pDest = ( WORD )_wtoi( pChar );
                pChar = AdvanceToken( pChar );
                pDest += 2;
                break;
            default:
                // unsupported vertex type
                Error( E_FAIL, "Unsupported vertex declaration element type." );
                break;
        }
        ++pCurrentElement;
    }
}

VOID SceneFileParser::ProcessMeshData()
{
    BaseMesh* pMesh = ( BaseMesh* )m_Context.pCurrentObject;
    typedef std::vector <D3DVERTEXELEMENT9> VertexElementArray;
    if( !m_CurrentElementDesc.bEndElement )
    {
        // start tag + body processing
        if( MATCH_ELEMENT_NAME( L"StaticMesh" ) || MATCH_ELEMENT_NAME( L"Mesh" ) )
        {
            const WCHAR* strSubD = FindAttribute( L"SubD" );
            const WCHAR* strSkinned = FindAttribute( L"Skinned" );
            BaseMesh* pBaseMesh = NULL;
            if( strSubD != NULL )
            {
                pBaseMesh = new CatmullClarkMesh;
            }
            else if( strSkinned != NULL )
            {
                pBaseMesh = new SkinnedMesh;
            }
            else
            {
                pBaseMesh = new StaticMesh;
            }
            m_Context.pCurrentObject = pBaseMesh;
            m_Context.dwUserDataIndex = 0;
            SetObjectNameFromAttribute( pBaseMesh );
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"InfluenceObjects" ) )
        {
            assert( pMesh->Type() == SkinnedMesh::TypeID );
            m_Context.CurrentObjectType = XATG_SKINNEDMESHINFLUENCES;
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"VertexBuffer" ) )
        {
            if( pMesh->GetVertexData( 0 ) == NULL )
            {
                VertexData* pVertexData = new VertexData;
                pMesh->SetVertexData( 0, pVertexData );
                SetObjectNameFromAttribute( pVertexData );
            }
            m_Context.CurrentObjectType = XATG_VERTEXBUFFER;
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"IndexBuffer" ) )
        {
            IndexData* pIndexData = new IndexData;
            pMesh->SetIndexData( 0, pIndexData );
            m_Context.CurrentObjectType = XATG_INDEXBUFFER;
            const WCHAR* strValue = FindAttribute( L"IndexSize" );
            D3DFORMAT IndexFormat = D3DFMT_INDEX16;
            if( strValue != NULL )
            {
                DWORD dwSize = ( DWORD )_wtoi( strValue );
                if( dwSize == 32 )
                    IndexFormat = D3DFMT_INDEX32;
            }
            strValue = FindAttribute( L"IndexCount" );
            if( strValue != NULL )
            {
                assert( IndexFormat == D3DFMT_INDEX16 || IndexFormat == D3DFMT_INDEX32 );
                DWORD dwIndexCount = ( DWORD )_wtoi( strValue );
                DWORD dwBufferSize = dwIndexCount * sizeof( WORD );
                if( IndexFormat == D3DFMT_INDEX32 )
                    dwBufferSize *= 2;
                D3DIndexBuffer* pIndexBuffer = new D3DIndexBuffer;
                XGSetIndexBufferHeader( dwBufferSize, 0, IndexFormat, D3DPOOL_MANAGED, 0, pIndexBuffer );
                VOID* pBuffer = g_pCurrentScene->GetResourceDatabase()->PhysicalAlloc( dwBufferSize, 32,
                                                                                       PAGE_READWRITE |
                                                                                       PAGE_WRITECOMBINE );
                XGOffsetResourceAddress( pIndexBuffer, pBuffer );

                pIndexData->SetIndexBuffer( pIndexBuffer );
                pIndexData->SetNumIndices( dwIndexCount );
                VOID* pIndices = NULL;
                pIndexBuffer->Lock( 0, 0, &pIndices, 0 );
                m_Context.pUserData = pIndices;
                pIndexBuffer->Release();
            }
            m_Context.dwUserDataIndex = IndexFormat;
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"VertexDecls" ) )
        {
            m_Context.pUserData = new VertexElementArray;
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"VertexDecl" ) )
        {
            m_Context.CurrentObjectType = XATG_VERTEXDECLELEMENT;
            VertexElementArray* pElements = ( VertexElementArray* )m_Context.pUserData;
            D3DVERTEXELEMENT9 element;
            ZeroMemory( &element, sizeof( D3DVERTEXELEMENT9 ) );
            const WCHAR* strValue = FindAttribute( L"Type" );
            DWORD dwValue = 0;
            if( strValue != NULL )
            {
                GetValueFromString( strValue, D3DDECLTYPE_StringMap, dwValue );
                element.Type = dwValue;
            }
            strValue = FindAttribute( L"Offset" );
            if( strValue != NULL )
            {
                element.Offset = ( WORD )_wtoi( strValue );
            }
            strValue = FindAttribute( L"Method" );
            if( strValue != NULL )
            {
                GetValueFromString( strValue, D3DDECLMETHOD_StringMap, dwValue );
                element.Method = ( BYTE )dwValue;
            }
            strValue = FindAttribute( L"Usage" );
            if( strValue != NULL )
            {
                GetValueFromString( strValue, D3DDECLUSAGE_StringMap, dwValue );
                element.Usage = ( BYTE )dwValue;
            }
            strValue = FindAttribute( L"UsageIndex" );
            if( strValue != NULL )
            {
                element.UsageIndex = ( BYTE )_wtoi( strValue );
            }
            pElements->push_back( element );
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"IBSubset" ) )
        {
            m_Context.CurrentObjectType = XATG_INDEXBUFFERSUBSET;
            SubsetDesc* pSubsetDesc = new SubsetDesc;
            pSubsetDesc->SetStartIndex( 0 );
            pSubsetDesc->SetNumPrimitives( 0 );
            pSubsetDesc->SetPrimitiveType( D3DPT_TRIANGLELIST );
            SetObjectNameFromAttribute( pSubsetDesc );
            const WCHAR* strValue = FindAttribute( L"StartIndex" );
            if( strValue != NULL )
            {
                pSubsetDesc->SetStartIndex( _wtoi( strValue ) );
            }
            strValue = FindAttribute( L"PrimitiveType" );
            if( strValue != NULL )
            {
                if( _wcsicmp( L"TriangleList", strValue ) == 0 )
                {
                    pSubsetDesc->SetPrimitiveType( D3DPT_TRIANGLELIST );
                }
                else if( _wcsicmp( L"TriangleStrip", strValue ) == 0 )
                {
                    pSubsetDesc->SetPrimitiveType( D3DPT_TRIANGLESTRIP );
                }
                else if( _wcsicmp( L"QuadList", strValue ) == 0 )
                {
                    pSubsetDesc->SetPrimitiveType( D3DPT_QUADLIST );
                }
                else if( _wcsicmp( L"QuadPatchList", strValue ) == 0 )
                {
                    pSubsetDesc->SetPrimitiveType( (D3DPRIMITIVETYPE)-1 );
                }
            }
            strValue = FindAttribute( L"IndexCount" );
            if( strValue != NULL )
            {
                INT iIndexCount = _wtoi( strValue );
                switch( (INT)pSubsetDesc->GetPrimitiveType() )
                {
                    case D3DPT_TRIANGLELIST:
                        pSubsetDesc->SetNumPrimitives( iIndexCount / 3 );
                        break;
                    case D3DPT_QUADLIST:
                        pSubsetDesc->SetNumPrimitives( iIndexCount / 4 );
                        break;
                    case D3DPT_TRIANGLESTRIP:
                        pSubsetDesc->SetNumPrimitives( iIndexCount - 2 );
                        break;
                    case -1:
                        pSubsetDesc->SetNumPrimitives( iIndexCount );
                        break;
                    default:
                        pSubsetDesc->SetNumPrimitives( iIndexCount / 3 );
                        break;
                }
            }
            pMesh->AddSubsetDesc( pSubsetDesc );
            return;
        }
        else if( m_Context.CurrentObjectType == XATG_VERTEXBUFFER )
        {
            VertexData* pVertexData = pMesh->GetVertexData( 0 );
            if( pVertexData->GetVertexDecl() == NULL )
                return;
            BYTE* pVerts = ( BYTE* )m_Context.pUserData;
            DWORD dwStreamIndex = m_Context.dwUserDataIndex;
            D3DVERTEXELEMENT9 DeclElements[MAXD3DDECLLENGTH + 1];
            DWORD dwElementCount = MAXD3DDECLLENGTH + 1;
            D3DVertexDeclaration* pDecl = pVertexData->GetVertexDecl();
            pDecl->GetDeclaration( DeclElements, ( UINT* )&dwElementCount );
            DWORD dwVertexSize = D3DXGetDeclVertexSize( DeclElements, dwStreamIndex );
            if( MATCH_ELEMENT_NAME( L"Vertices" ) )
            {
                const WCHAR* strValue = FindAttribute( L"Count" );
                assert( strValue != NULL );
                DWORD dwVertexCount = ( DWORD )_wtoi( strValue );
                DWORD dwVBSize = dwVertexCount * dwVertexSize;
                D3DVertexBuffer* pVB = new D3DVertexBuffer;
                XGSetVertexBufferHeader( dwVBSize, 0, D3DPOOL_MANAGED, 0, pVB );
                VOID* pBuffer = g_pCurrentScene->GetResourceDatabase()->PhysicalAlloc( dwVBSize, 32,
                                                                                       PAGE_READWRITE |
                                                                                       PAGE_WRITECOMBINE );
                XGOffsetResourceAddress( pVB, pBuffer );
                pVertexData->AddVertexStream( pVB, dwVertexSize, dwVertexCount, 1 );
                assert( pVertexData->GetNumVertexStreams() == ( dwStreamIndex + 1 ) );
                pVB->Lock( 0, 0, ( VOID** )&pVerts, 0 );
                m_Context.pUserData = pVerts;
                pVB->Release();
                return;
            }
            else if( MATCH_ELEMENT_NAME( L"E" ) )
            {
                CrackVertex( pVerts, DeclElements, dwStreamIndex );
                pVerts += dwVertexSize;
                m_Context.pUserData = pVerts;
                return;
            }
            else if( MATCH_ELEMENT_NAME( L"PhysicalBinaryData" ) )
            {
                WCHAR strValue[50];
                FindAttribute( L"Offset", strValue, ARRAYSIZE( strValue ) );
                DWORD dwOffset = _wtoi( strValue );
                FindAttribute( L"Size", strValue, ARRAYSIZE( strValue ) );
                DWORD dwSize = _wtoi( strValue );
                FindAttribute( L"Count", strValue, ARRAYSIZE( strValue ) );
                DWORD dwCount = _wtoi( strValue );
                assert( ( dwSize / dwCount ) == dwVertexSize );
                D3DVertexBuffer* pVB = new D3DVertexBuffer;
                XGSetVertexBufferHeader( dwSize, 0, D3DPOOL_MANAGED, 0, pVB );
                VOID* pBuffer = ( VOID* )( g_pBinaryBlobData + dwOffset );
                XGOffsetResourceAddress( pVB, pBuffer );
                pVertexData->AddVertexStream( pVB, dwVertexSize, dwCount, 1 );
                assert( pVertexData->GetNumVertexStreams() == ( dwStreamIndex + 1 ) );
                m_Context.pUserData = NULL;
                pVB->Release();
                return;
            }
        }
        else if( m_Context.CurrentObjectType == XATG_INDEXBUFFER )
        {
            IndexData* pIndexData = pMesh->GetIndexData( 0 );
            WORD* pIndices = ( WORD* )m_Context.pUserData;
            if( MATCH_ELEMENT_NAME( L"E" ) )
            {
                if( m_Context.dwUserDataIndex == D3DFMT_INDEX32 )
                {
                    DWORD* pIndices32 = ( DWORD* )pIndices;
                    *pIndices32 = ( DWORD )_wtoi( m_CurrentElementDesc.strElementBody );
                    pIndices32++;
                    m_Context.pUserData = pIndices32;
                    return;
                }
                *pIndices = ( WORD )_wtoi( m_CurrentElementDesc.strElementBody );
                pIndices++;
                m_Context.pUserData = pIndices;
                return;
            }
            else if( MATCH_ELEMENT_NAME( L"PhysicalBinaryData" ) )
            {
                WCHAR strValue[50];
                FindAttribute( L"Offset", strValue, ARRAYSIZE( strValue ) );
                DWORD dwOffset = _wtoi( strValue );
                FindAttribute( L"Size", strValue, ARRAYSIZE( strValue ) );
                DWORD dwSize = _wtoi( strValue );
                FindAttribute( L"Count", strValue, ARRAYSIZE( strValue ) );
                DWORD dwCount = _wtoi( strValue );

                D3DFORMAT IndexFormat = ( D3DFORMAT )m_Context.dwUserDataIndex;
                assert( IndexFormat == D3DFMT_INDEX16 || IndexFormat == D3DFMT_INDEX32 );
                DWORD dwBufferSize = dwCount * sizeof( WORD );
                if( IndexFormat == D3DFMT_INDEX32 )
                    dwBufferSize *= 2;
                assert( dwSize == dwBufferSize );

                D3DIndexBuffer* pIB = new D3DIndexBuffer;
                XGSetIndexBufferHeader( dwSize, 0, IndexFormat, D3DPOOL_MANAGED, 0, pIB );
                VOID* pBuffer = ( VOID* )( g_pBinaryBlobData + dwOffset );
                XGOffsetResourceAddress( pIB, pBuffer );
                pIndexData->SetIndexBuffer( pIB );
                pIndexData->SetNumIndices( dwCount );
                m_Context.pUserData = NULL;
                pIB->Release();
                return;
            }
        }
        else if( m_Context.CurrentObjectType == XATG_SKINNEDMESHINFLUENCES )
        {
            if( MATCH_ELEMENT_NAME( L"E" ) )
            {
                assert( pMesh->Type() == SkinnedMesh::TypeID );
                SkinnedMesh* pSkinMesh = ( SkinnedMesh* )pMesh;
                pSkinMesh->AddInfluence( m_CurrentElementDesc.strElementBody );
                return;
            }
        }
        else if( g_bDebugXMLParser )
        {
            WCHAR s[100];
            swprintf_s( s, L"Mesh tag: %s\n", m_CurrentElementDesc.strElementName );
            OutputDebugStringW( s );
        }
    }
    else
    {
        // end tag processing
        if( MATCH_ELEMENT_NAME( L"VertexBuffer" ) )
        {
            DWORD dwStreamIndex = m_Context.dwUserDataIndex;
            if( pMesh->GetVertexData( 0 )->GetVertexStream( dwStreamIndex ) != NULL && m_Context.pUserData != NULL )
            {
                m_Context.pUserData = NULL;
                pMesh->GetVertexData( 0 )->GetVertexStream( dwStreamIndex )->pVertexBuffer->Unlock();
            }
            // next stream
            m_Context.dwUserDataIndex++;
            m_Context.CurrentObjectType = XATG_MESH;
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"IndexBuffer" ) )
        {
            if( pMesh->GetIndexData( 0 )->GetIndexBuffer() != NULL && m_Context.pUserData != NULL )
            {
                m_Context.pUserData = NULL;
                pMesh->GetIndexData( 0 )->GetIndexBuffer()->Unlock();
            }
            m_Context.CurrentObjectType = XATG_MESH;
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"VertexDecl" ) )
        {
            m_Context.CurrentObjectType = XATG_VERTEXBUFFER;
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"IBSubset" ) )
        {
            m_Context.CurrentObjectType = XATG_MESH;
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"InfluenceObjects" ) )
        {
            m_Context.CurrentObjectType = XATG_MESH;
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"VertexDecls" ) )
        {
            VertexElementArray* pElements = ( VertexElementArray* )m_Context.pUserData;
            D3DVERTEXELEMENT9 EndElement = D3DDECL_END();
            pElements->push_back( EndElement );
            D3DVertexDeclaration* pVertexDecl = NULL;
            D3DVERTEXELEMENT9* pElementList = &( pElements->front() );
            // Create or find an existing vertex decl using the vertex decl pool.
            CreatePooledVertexDeclaration( pElementList, &pVertexDecl );
            DWORD dwStreamIndex = m_Context.dwUserDataIndex;
            pMesh->GetVertexData( 0 )->AppendVertexDecl( pVertexDecl, dwStreamIndex );
            delete pElements;
            m_Context.pUserData = NULL;
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"StaticMesh" ) || MATCH_ELEMENT_NAME( L"Mesh" ) )
        {
            g_pCurrentScene->AddObject( pMesh );
            m_Context.pCurrentObject = NULL;
            m_Context.CurrentObjectType = XATG_FRAME;
            return;
        }
    }
}

VOID SceneFileParser::ProcessModelData()
{
    Model* pModel = ( Model* )m_Context.pCurrentObject;
    if( !m_CurrentElementDesc.bEndElement )
    {
        if( MATCH_ELEMENT_NAME( L"Model" ) )
        {
            pModel = new Model;
            pModel->GetLightGroups().push_back( L"default" );
            m_Context.pCurrentParentFrame = ( Frame* )m_Context.pCurrentObject;
            m_Context.pCurrentObject = pModel;
            pModel->SetParent( m_Context.pCurrentParentFrame );
            pModel->SetLocalTransform( XMMatrixIdentity() );
            DWORD dwModelFlags = MeshMapping::IsShadowCaster | MeshMapping::IsShadowReceiver;
            const WCHAR* strValue = FindAttribute( L"ShadowCaster" );
            if( strValue != NULL )
            {
                if( strValue[0] == L'0' || strValue[0] == L'F' || strValue[0] == L'f' )
                    dwModelFlags &= ~MeshMapping::IsShadowCaster;
            }
            strValue = FindAttribute( L"ShadowReceiver" );
            if( strValue != NULL )
            {
                if( strValue[0] == L'0' || strValue[0] == L'F' || strValue[0] == L'f' )
                    dwModelFlags &= ~MeshMapping::IsShadowReceiver;
            }
            strValue = FindAttribute( L"Mesh" );
            if( strValue != NULL )
            {
                BaseMesh* pMesh = NULL;
                NamedTypedObject* pObj = g_pCurrentScene->FindObject( strValue );
                if( pObj == NULL )
                {
                    Error( E_FAIL, "Model references a non-existent mesh." );
                    return;
                }

                assert( pObj->IsDerivedFrom( L"Mesh" ) );
                pMesh = ( BaseMesh* )pObj;

                if( pMesh != NULL )
                {
                    pModel->AddMesh( pMesh, dwModelFlags );
                }
            }
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"SubsetMaterialMapping" ) )
        {
            const WCHAR* strValue = FindAttribute( L"SubsetName" );
            DWORD dwSubsetIndex = 0;
            if( strValue != NULL )
            {
                if( pModel->GetNumMeshMappings() == 0 )
                {
                    Error( E_FAIL, "Model has subset mappings but no mesh." );
                    return;
                }

                StringID SubsetID = strValue;
                UINT MeshIndex = pModel->GetNumMeshMappings() - 1;
                BaseMesh* pMesh = pModel->GetMeshMapping( MeshIndex ).pMesh;

                // can only map materials to renderable meshes
                if( !( pMesh->GetFlags() & BaseMesh::IsRenderable ) )
                {
                    Error( E_FAIL, "Model has a subset mapping to a non-renderable mesh." );
                    return;
                }

                for(; dwSubsetIndex < pMesh->GetNumSubsets(); dwSubsetIndex++ )
                {
                    if( pMesh->GetSubsetDesc( dwSubsetIndex )->GetName() == SubsetID )
                        break;
                }

                if( dwSubsetIndex == pMesh->GetNumSubsets() )
                {
                    Error( E_FAIL, "Subset mapping has a non-existent subset name." );
                    return;
                }
                m_Context.pUserData = ( VOID* )dwSubsetIndex;
            }
            strValue = FindAttribute( L"MaterialName" );
            if( strValue != NULL )
            {
                MaterialInstance* pMaterial = ( MaterialInstance* )g_pCurrentScene->FindObjectOfType( strValue,
                                                                                                      MaterialInstance
                                                                                                      ::TypeID );
                pModel->AddMaterial( 0, dwSubsetIndex, pMaterial );
                if( pMaterial->IsTransparent() )
                {
                    MeshMapping& mm = pModel->GetMeshMapping( 0 );
                    mm.dwFlags |= MeshMapping::IsTransparent;
                }
            }
        }
        else if( MATCH_ELEMENT_NAME( L"SphereBound" ) )
        {
            Sphere sph;
            sph.Center = XMFLOAT3( 0, 0, 0 );
            sph.Radius = 0;
            const WCHAR* strValue = FindAttribute( L"Center" );
            if( strValue != NULL )
            {
                XMVECTOR vCenter = ScanVector3( strValue );
                XMStoreFloat3( &sph.Center, vCenter );
            }
            strValue = FindAttribute( L"Radius" );
            if( strValue != NULL )
            {
                sph.Radius = ( FLOAT )_wtof( strValue );
            }
            Bound DefaultBound( sph );
            pModel->SetLocalBound( DefaultBound );
            m_Context.dwUserDataIndex = 0;
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"AxisAlignedBoxBound" ) )
        {
            AxisAlignedBox aabb;
            aabb.Center = XMFLOAT3( 0, 0, 0 );
            aabb.Extents = XMFLOAT3( 0, 0, 0 );
            const WCHAR* strValue = FindAttribute( L"Center" );
            if( strValue != NULL )
            {
                XMVECTOR vCenter = ScanVector3( strValue );
                XMStoreFloat3( &aabb.Center, vCenter );
            }
            strValue = FindAttribute( L"Extents" );
            if( strValue != NULL )
            {
                XMVECTOR vExtents = ScanVector3( strValue );
                XMStoreFloat3( &aabb.Extents, vExtents );
            }
            Bound DefaultBound( aabb );
            pModel->SetLocalBound( DefaultBound );
            m_Context.dwUserDataIndex = 1;
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"OrientedBoxBound" ) )
        {
            OrientedBox obb;
            obb.Center = XMFLOAT3( 0, 0, 0 );
            obb.Extents = XMFLOAT3( 0, 0, 0 );
            obb.Orientation = XMFLOAT4( 0, 0, 0, 1 );
            const WCHAR* strValue = FindAttribute( L"Center" );
            if( strValue != NULL )
            {
                XMVECTOR vCenter = ScanVector3( strValue );
                XMStoreFloat3( &obb.Center, vCenter );
            }
            strValue = FindAttribute( L"Extents" );
            if( strValue != NULL )
            {
                XMVECTOR vExtents = ScanVector3( strValue );
                XMStoreFloat3( &obb.Extents, vExtents );
            }
            strValue = FindAttribute( L"Orientation" );
            if( strValue != NULL )
            {
                XMVECTOR vOrientation = ScanVector4( strValue );
                XMStoreFloat4( &obb.Orientation, vOrientation );
            }
            Bound DefaultBound( obb );
            pModel->SetLocalBound( DefaultBound );
            m_Context.dwUserDataIndex = 2;
            return;
        }
        else if( g_bDebugXMLParser )
        {
            WCHAR s[100];
            swprintf_s( s, L"Model tag: %s\n", m_CurrentElementDesc.strElementName );
            OutputDebugStringW( s );
        }
    }
    else
    {
        if( MATCH_ELEMENT_NAME( L"Model" ) )
        {
            Model* pLocalModel = ( Model* )m_Context.pCurrentObject;

            g_pCurrentScene->AddObject( pLocalModel );

            m_Context.pCurrentObject = m_Context.pCurrentParentFrame;
            m_Context.pCurrentParentFrame = m_Context.pCurrentParentFrame->GetParent();
            m_Context.CurrentObjectType = XATG_FRAME;
            return;
        }
    }
}

VOID SceneFileParser::ProcessMaterialData()
{
    MaterialInstance* pMaterialInstance = ( MaterialInstance* )m_Context.pCurrentObject;
    if( !m_CurrentElementDesc.bEndElement )
    {
        if( MATCH_ELEMENT_NAME( L"MaterialInstance" ) )
        {
            pMaterialInstance = new MaterialInstance();
            m_Context.pCurrentObject = pMaterialInstance;
            m_Context.dwCurrentParameterIndex = 0;
            if( SetObjectNameFromAttribute( pMaterialInstance ) )
                g_pCurrentScene->AddObject( pMaterialInstance );
            const WCHAR* strTransparent = FindAttribute( L"Transparent" );
            if( strTransparent != NULL )
            {
                pMaterialInstance->SetTransparent( TRUE );
            }
            const WCHAR* strBaseMaterialName = FindAttribute( L"MaterialName" );
            if( strBaseMaterialName != NULL )
            {
                BaseMaterial* pBaseMaterial = ( BaseMaterial* )g_pCurrentScene->GetResourceDatabase
                    ()->FindResourceOfType( strBaseMaterialName, BaseMaterial::TypeID );
                if( pBaseMaterial == NULL )
                {
                    pBaseMaterial = new BaseMaterial();
                    pBaseMaterial->SetName( strBaseMaterialName );
                    g_pCurrentScene->GetResourceDatabase()->AddResource( pBaseMaterial );
                    m_Context.pUserData = pBaseMaterial;
                }
                else
                {
                    m_Context.pUserData = NULL;
                }
                pMaterialInstance->SetBaseMaterial( pBaseMaterial );
                pMaterialInstance->SetBaseMaterialName( pBaseMaterial->GetName() );
            }
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"ParamString" ) )
        {
            assert( pMaterialInstance != NULL );
            const WCHAR* strParamName = FindAttribute( L"Name" );
            if( strParamName == NULL )
                return;
            MaterialParameter mp;
            mp.strName = strParamName;
            mp.Type = MaterialParameter::RPT_String;
            const WCHAR* strParamHint = FindAttribute( L"Hint" );
            if( strParamHint != NULL )
            {
                mp.strHint = strParamHint;
            }
            const WCHAR* strParamType = FindAttribute( L"Type" );
            if( strParamType != NULL )
            {
                // further decode parameter based on type
                if( _wcsicmp( strParamType, L"texture2d" ) == 0 )
                {
                    mp.Type = MaterialParameter::RPT_Texture2D;
                }
                else if( _wcsicmp( strParamType, L"texture3d" ) == 0 )
                {
                    mp.Type = MaterialParameter::RPT_Texture3D;
                }
                else if( _wcsicmp( strParamType, L"texturecube" ) == 0 )
                {
                    mp.Type = MaterialParameter::RPT_TextureCube;
                }
            }
            const WCHAR* strInstanceParam = FindAttribute( L"InstanceParam" );
            if( strInstanceParam == NULL && pMaterialInstance->GetBaseMaterial() != NULL )
            {
                if( m_Context.pUserData != NULL )
                    m_Context.dwCurrentParameterIndex = pMaterialInstance->GetBaseMaterial()->AddRawParameter( mp ) | 0x8000;
                else
                    m_Context.dwCurrentParameterIndex = 0x8000;
            }
            else
            {
                m_Context.dwCurrentParameterIndex = pMaterialInstance->AddRawParameter( mp );
            }
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"ParamFloat" ) )
        {
            assert( pMaterialInstance != NULL );
            const WCHAR* strParamName = FindAttribute( L"Name" );
            if( strParamName == NULL )
                return;
            MaterialParameter mp;
            mp.strName = strParamName;
            mp.Type = MaterialParameter::RPT_Float;

            DWORD dwCount = 1;
            const WCHAR* strCount = FindAttribute( L"Count" );
            if( strCount != NULL )
                dwCount = _wtoi( strCount );
            if( dwCount > 16 )
                dwCount = 16;
            if( dwCount > 1 )
            {
                mp.pFloatValues = new FLOAT[ dwCount ];
                ZeroMemory( mp.pFloatValues, dwCount * sizeof( FLOAT ) );
            }
            mp.dwCount = dwCount;
            m_Context.dwUserDataIndex = 0;

            const WCHAR* strParamHint = FindAttribute( L"Hint" );
            if( strParamHint != NULL )
            {
                mp.strHint = strParamHint;
            }
            const WCHAR* strInstanceParam = FindAttribute( L"InstanceParam" );
            if( strInstanceParam == NULL && pMaterialInstance->GetBaseMaterial() != NULL )
            {
                if( m_Context.pUserData != NULL )
                    m_Context.dwCurrentParameterIndex = pMaterialInstance->GetBaseMaterial()->AddRawParameter( mp ) | 0x8000;
                else
                    m_Context.dwCurrentParameterIndex = 0x8000;
            }
            else
            {
                m_Context.dwCurrentParameterIndex = pMaterialInstance->AddRawParameter( mp );
            }
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"ParamBool" ) )
        {
            assert( pMaterialInstance != NULL );
            const WCHAR* strParamName = FindAttribute( L"Name" );
            if( strParamName == NULL )
                return;
            MaterialParameter mp;
            mp.strName = strParamName;
            mp.Type = MaterialParameter::RPT_Bool;

            const WCHAR* strParamHint = FindAttribute( L"Hint" );
            if( strParamHint != NULL )
            {
                mp.strHint = strParamHint;
            }
            const WCHAR* strInstanceParam = FindAttribute( L"InstanceParam" );
            if( strInstanceParam == NULL && pMaterialInstance->GetBaseMaterial() != NULL )
            {
                if( m_Context.pUserData != NULL )
                    m_Context.dwCurrentParameterIndex = pMaterialInstance->GetBaseMaterial()->AddRawParameter( mp ) | 0x8000;
                else
                    m_Context.dwCurrentParameterIndex = 0x8000;
            }
            else
            {
                m_Context.dwCurrentParameterIndex = pMaterialInstance->AddRawParameter( mp );
            }
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"ParamInt" ) )
        {
            assert( pMaterialInstance != NULL );
            const WCHAR* strParamName = FindAttribute( L"Name" );
            if( strParamName == NULL )
                return;
            MaterialParameter mp;
            mp.strName = strParamName;
            mp.Type = MaterialParameter::RPT_Int;

            const WCHAR* strParamHint = FindAttribute( L"Hint" );
            if( strParamHint != NULL )
            {
                mp.strHint = strParamHint;
            }
            const WCHAR* strInstanceParam = FindAttribute( L"InstanceParam" );
            if( strInstanceParam == NULL && pMaterialInstance->GetBaseMaterial() != NULL )
            {
                if( m_Context.pUserData != NULL )
                    m_Context.dwCurrentParameterIndex = pMaterialInstance->GetBaseMaterial()->AddRawParameter( mp ) | 0x8000;
                else
                    m_Context.dwCurrentParameterIndex = 0x8000;
            }
            else
            {
                m_Context.dwCurrentParameterIndex = pMaterialInstance->AddRawParameter( mp );
            }
        }
        else if( MATCH_ELEMENT_NAME( L"Value" ) )
        {
            assert( pMaterialInstance != NULL );
            BOOL bBaseParam = m_Context.dwCurrentParameterIndex & 0x8000;
            DWORD dwParamIndex = m_Context.dwCurrentParameterIndex & 0x7FFF;
            MaterialParameter* pMP = NULL;
            if( bBaseParam && m_Context.pUserData == NULL )
                return;
            if( bBaseParam )
                pMP = &pMaterialInstance->GetBaseMaterial()->GetRawParameter( dwParamIndex );
            else
                pMP = &pMaterialInstance->GetRawParameter( dwParamIndex );

            switch( pMP->Type )
            {
                case MaterialParameter::RPT_String:
                case MaterialParameter::RPT_Texture2D:
                case MaterialParameter::RPT_Texture3D:
                case MaterialParameter::RPT_TextureCube:
                    pMP->strValue = m_CurrentElementDesc.strElementBody;
                    break;
                case MaterialParameter::RPT_Bool:
                {
                    WCHAR c = m_CurrentElementDesc.strElementBody[0];
                    pMP->bValue = ( c == L'1' || c == L'T' || c == L't' );
                    break;
                }
                case MaterialParameter::RPT_Int:
                    pMP->iValue = _wtoi( m_CurrentElementDesc.strElementBody );
                    break;
                case MaterialParameter::RPT_Float:
                {
                    FLOAT fValue = ( FLOAT )_wtof( m_CurrentElementDesc.strElementBody );
                    if( pMP->dwCount == 1 )
                    {
                        pMP->fValue = fValue;
                    }
                    else
                    {
                        assert( m_Context.dwUserDataIndex < pMP->dwCount );
                        pMP->pFloatValues[ m_Context.dwUserDataIndex ] = fValue;
                        m_Context.dwUserDataIndex++;
                    }
                    break;
                }
            }
            return;
        }
    }
    else
    {
        if( MATCH_ELEMENT_NAME( L"MaterialInstance" ) )
        {
            // Bind textures to material instance parameters and base material parameters
            if( ( g_dwLoaderFlags & XATGLOADER_DONOTBINDTEXTURES ) == 0 )
            {
                pMaterialInstance->BindTextures( g_strMediaRootPath, g_pCurrentScene );
            }
            // Initialize material instance from base material, if one exists
            if( ( g_dwLoaderFlags & XATGLOADER_DONOTINITIALIZEMATERIALS ) == 0 )
            {
                pMaterialInstance->Initialize();
            }
            m_Context.pCurrentObject = NULL;
            m_Context.dwCurrentParameterIndex = 0;
            m_Context.dwUserDataIndex = 0;
            m_Context.CurrentObjectType = XATG_FRAME;
            return;
        }
    }
}

VOID SceneFileParser::ProcessLightData()
{
    Light* pLight = ( Light* )m_Context.pCurrentObject;
    if( !m_CurrentElementDesc.bEndElement )
    {
        if( MATCH_ELEMENT_NAME( L"AmbientLight" ) )
        {
            pLight = new AmbientLight;
            m_Context.pCurrentParentFrame = ( Frame* )m_Context.pCurrentObject;
            m_Context.pCurrentObject = pLight;
            pLight->SetParent( m_Context.pCurrentParentFrame );
            pLight->SetLocalTransform( XMMatrixIdentity() );
            SetObjectNameFromAttribute( pLight );
            const WCHAR* strValue = FindAttribute( L"Color" );
            if( strValue != NULL )
            {
                XMVECTOR Color = ScanColorARGBtoRGBA( strValue );
                pLight->SetColor( Color );
            }
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"DirectionalLight" ) )
        {
            pLight = new DirectionalLight;
            m_Context.pCurrentParentFrame = ( Frame* )m_Context.pCurrentObject;
            m_Context.pCurrentObject = pLight;
            pLight->SetParent( m_Context.pCurrentParentFrame );
            pLight->SetLocalTransform( XMMatrixIdentity() );
            SetObjectNameFromAttribute( pLight );
            const WCHAR* strValue = FindAttribute( L"Color" );
            if( strValue != NULL )
            {
                XMVECTOR Color = ScanColorARGBtoRGBA( strValue );
                pLight->SetColor( Color );
            }
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"PointLight" ) )
        {
            PointLight* pPointLight = new PointLight;
            pLight = pPointLight;
            m_Context.pCurrentParentFrame = ( Frame* )m_Context.pCurrentObject;
            m_Context.pCurrentObject = pLight;
            pLight->SetParent( m_Context.pCurrentParentFrame );
            pLight->SetLocalTransform( XMMatrixIdentity() );
            SetObjectNameFromAttribute( pLight );
            const WCHAR* strValue = FindAttribute( L"Color" );
            if( strValue != NULL )
            {
                XMVECTOR Color = ScanColorARGBtoRGBA( strValue );
                pLight->SetColor( Color );
            }
            strValue = FindAttribute( L"Range" );
            if( strValue != NULL )
            {
                pPointLight->SetLocalRange( ( FLOAT )_wtof( strValue ) );
            }
            strValue = FindAttribute( L"Falloff" );
            if( strValue != NULL )
            {
                Light::FalloffType Falloff = Light::NoFalloff;
                GetValueFromString( strValue, Light::FalloffType_StringMap, ( DWORD& )Falloff );
                pPointLight->SetFalloff( Falloff );
            }
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"SpotLight" ) )
        {
            SpotLight* pSpotLight = new SpotLight;
            pLight = pSpotLight;
            m_Context.pCurrentParentFrame = ( Frame* )m_Context.pCurrentObject;
            m_Context.pCurrentObject = pLight;
            pLight->SetParent( m_Context.pCurrentParentFrame );
            pLight->SetLocalTransform( XMMatrixIdentity() );
            SetObjectNameFromAttribute( pLight );
            const WCHAR* strValue = FindAttribute( L"Color" );
            if( strValue != NULL )
            {
                XMVECTOR Color = ScanColorARGBtoRGBA( strValue );
                pLight->SetColor( Color );
            }
            strValue = FindAttribute( L"Range" );
            if( strValue != NULL )
            {
                pSpotLight->SetLocalRange( ( FLOAT )_wtof( strValue ) );
            }
            strValue = FindAttribute( L"Falloff" );
            if( strValue != NULL )
            {
                Light::FalloffType Falloff = Light::NoFalloff;
                GetValueFromString( strValue, Light::FalloffType_StringMap, ( DWORD& )Falloff );
                pSpotLight->SetFalloff( Falloff );
            }
            strValue = FindAttribute( L"SpotlightFalloff" );
            if( strValue != NULL )
            {
                Light::FalloffType Falloff = Light::NoFalloff;
                GetValueFromString( strValue, Light::FalloffType_StringMap, ( DWORD& )Falloff );
                pSpotLight->SetSpotFalloff( Falloff );
            }
            FLOAT fInnerAngle = XM_PIDIV2;
            FLOAT fOuterAngle = XM_PIDIV2;
            strValue = FindAttribute( L"InnerAngle" );
            if( strValue != NULL )
            {
                fInnerAngle = ( FLOAT )_wtof( strValue );
            }
            strValue = FindAttribute( L"OuterAngle" );
            if( strValue != NULL )
            {
                fOuterAngle = ( FLOAT )_wtof( strValue );
            }
            if( fInnerAngle < 0 )
                fInnerAngle = 0;
            if( fInnerAngle > XM_PI )
                fInnerAngle = XM_PI;
            if( fOuterAngle > XM_PI )
                fOuterAngle = XM_PI;
            if( fOuterAngle < fInnerAngle )
                fOuterAngle = fInnerAngle;
            pSpotLight->SetInnerAngle( fInnerAngle );
            pSpotLight->SetOuterAngle( fOuterAngle );
            return;
        }
        else if( g_bDebugXMLParser )
        {
            WCHAR s[100];
            swprintf_s( s, L"Light tag: %s\n", m_CurrentElementDesc.strElementName );
            OutputDebugStringW( s );
        }
    }
    else
    {
        if( MATCH_ELEMENT_NAME( L"AmbientLight" ) ||
            MATCH_ELEMENT_NAME( L"DirectionalLight" ) ||
            MATCH_ELEMENT_NAME( L"PointLight" ) ||
            MATCH_ELEMENT_NAME( L"SpotLight" ) )
        {
            pLight->AddLightGroup( L"default" );
            pLight->SetFlag( Light::IsShadowCaster );
            g_pCurrentScene->AddObject( pLight );

            m_Context.pCurrentObject = m_Context.pCurrentParentFrame;
            m_Context.pCurrentParentFrame = m_Context.pCurrentParentFrame->GetParent();
            m_Context.CurrentObjectType = XATG_FRAME;
            return;
        }
    }
}
VOID SceneFileParser::ProcessCameraData()
{
    Camera* pCamera = ( Camera* )m_Context.pCurrentObject;
    if( !m_CurrentElementDesc.bEndElement )
    {
        if( MATCH_ELEMENT_NAME( L"PerspectiveCamera" ) )
        {
            // Create a new camera and set it up with some default values
            pCamera = new Camera;
            pCamera->SetFocalLength( 10.0f );
            pCamera->SetClearColor( 0x00070720 );

            D3DVIEWPORT9 Viewport;
            Viewport.X = 0;
            Viewport.Y = 0;
            Viewport.Width = 640; // $TODO: Make this scale based on the actual screen size
            Viewport.Height = 480;
            Viewport.MinZ = 0.0f;
            Viewport.MaxZ = 1.0f;
            pCamera->SetViewport( Viewport );

            {
                Projection proj;
                proj.SetFovXAspect( 0.7f, ( FLOAT )Viewport.Width / ( FLOAT )Viewport.Height, 0.01f, 1000.0f );
                pCamera->SetProjection( proj );
            }

            m_Context.pCurrentParentFrame = ( Frame* )m_Context.pCurrentObject;
            m_Context.pCurrentObject = pCamera;
            pCamera->SetParent( m_Context.pCurrentParentFrame );
            pCamera->SetLocalTransform( XMMatrixIdentity() );

            SetObjectNameFromAttribute( pCamera );
            const WCHAR* strValue = FindAttribute( L"EyePoint" );
            if( strValue != NULL )
            {
                XMVECTOR LocalPosition = ScanVector3( strValue );
                LocalPosition = XMVectorSetW( LocalPosition, 1 );
                pCamera->SetLocalPosition( LocalPosition );
            }
            const WCHAR* strValueDir = FindAttribute( L"LookDirection" );
            const WCHAR* strValueUp = FindAttribute( L"UpDirection" );
            if( strValueDir != NULL && strValueUp != NULL )
            {
                XMVECTOR vLocalDirection = ScanVector3( strValueDir );
                vLocalDirection = XMVector3Normalize( vLocalDirection );
                XMVECTOR vLocalUpDirection = ScanVector3( strValueUp );
                vLocalUpDirection = XMVector3Normalize( vLocalUpDirection );
                XMVECTOR vLocalRightDirection = XMVector3Cross( vLocalUpDirection, vLocalDirection );
                vLocalUpDirection = XMVector3Cross( vLocalDirection, vLocalRightDirection );
                vLocalDirection = XMVector3Cross( vLocalRightDirection, vLocalUpDirection );
                XMMATRIX matLocalTransform = pCamera->GetLocalTransform();
                matLocalTransform.r[0] = XMVector3Normalize( vLocalRightDirection );
                matLocalTransform.r[1] = XMVector3Normalize( vLocalUpDirection );
                matLocalTransform.r[2] = XMVector3Normalize( vLocalDirection );
                pCamera->SetLocalTransform( matLocalTransform );
            }
            /*
            strValue = FindAttribute( L"LookDirection" );
            if( strValue != NULL )
            {
            XMVECTOR LocalDirection;
            swscanf_s( strValue, L"%f, %f, %f", 
            &LocalDirection.x, &LocalDirection.y, &LocalDirection.z );                
            LocalDirection.w = 0;
            XMMATRIX mTransform;
            mTransform = pCamera->GetLocalTransform();
            
            mTransform.r[2] = LocalDirection;
            mTransform.r[0] = XMVector3Cross( mTransform.r[1], mTransform.r[2] );               
            mTransform.r[0] = XMVector3Normalize( mTransform.r[0] );
            mTransform.r[1] = XMVector3Cross( mTransform.r[2], mTransform.r[0] );
            
            pCamera->SetLocalTransform( mTransform );
            }
            strValue = FindAttribute( L"UpDirection" );
            if( strValue != NULL )
            {
            XMVECTOR LocalUpDirection;
            swscanf_s( strValue, L"%f, %f, %f", 
            &LocalUpDirection.x, &LocalUpDirection.y, &LocalUpDirection.z );
            LocalUpDirection.w = 0;
            
            XMMATRIX mTransform;
            mTransform = pCamera->GetLocalTransform();
            mTransform.r[1] = LocalUpDirection;
            mTransform.r[0] = XMVector3Cross( mTransform.r[1], mTransform.r[2] );                
            mTransform.r[0] = XMVector3Normalize( mTransform.r[0] );
            mTransform.r[2] = XMVector3Cross( mTransform.r[0], mTransform.r[1] );
            
            pCamera->SetLocalTransform( mTransform );
            }
            */
            strValue = FindAttribute( L"FieldOfView" );
            if( strValue != NULL )
            {
                Projection proj = pCamera->GetProjection();
                FLOAT fFOV = ( FLOAT )_wtof( strValue );
                FLOAT fAspect = proj.GetFovX() / proj.GetFovY();
                proj.SetFovXAspect( fFOV, fAspect, proj.GetZNear(), proj.GetZFar() );
                pCamera->SetProjection( proj );
            }
            strValue = FindAttribute( L"Aspect" );
            if( strValue != NULL )
            {
                Projection proj = pCamera->GetProjection();
                FLOAT fAspect = ( FLOAT )_wtof( strValue );
                proj.SetFovXAspect( proj.GetFovX(), fAspect, proj.GetZNear(), proj.GetZFar() );
                pCamera->SetProjection( proj );
            }
            strValue = FindAttribute( L"ZNear" );
            if( strValue != NULL )
            {
                Projection proj = pCamera->GetProjection();
                FLOAT fZNear = ( FLOAT )_wtof( strValue );
                proj.SetFovXFovY( proj.GetFovX(), proj.GetFovY(), fZNear, proj.GetZFar() );
                pCamera->SetProjection( proj );
            }
            strValue = FindAttribute( L"ZFar" );
            if( strValue != NULL )
            {
                Projection proj = pCamera->GetProjection();
                FLOAT fZFar = ( FLOAT )_wtof( strValue );
                proj.SetFovXFovY( proj.GetFovX(), proj.GetFovY(), proj.GetZNear(), fZFar );
                pCamera->SetProjection( proj );
            }
            return;
        }
        else if( g_bDebugXMLParser )
        {
            WCHAR s[100];
            swprintf_s( s, L"Camera tag: %s\n", m_CurrentElementDesc.strElementName );
            OutputDebugStringW( s );
        }
    }
    else
    {
        if( MATCH_ELEMENT_NAME( L"PerspectiveCamera" ) )
        {
            g_pCurrentScene->AddObject( pCamera );
            m_Context.pCurrentObject = m_Context.pCurrentParentFrame;
            m_Context.pCurrentParentFrame = m_Context.pCurrentParentFrame->GetParent();
            m_Context.CurrentObjectType = XATG_FRAME;
            return;
        }
    }
}


VOID SceneFileParser::ProcessAnimationData()
{
    Animation* pAnimation = NULL;
    AnimationTransformTrack* pTrack = NULL;
    if( m_Context.pCurrentParentObject != NULL )
    {
        pTrack = ( AnimationTransformTrack* )m_Context.pCurrentObject;
        pAnimation = ( Animation* )m_Context.pCurrentParentObject;
    }
    else
    {
        pAnimation = ( Animation* )m_Context.pCurrentObject;
    }
    if( !m_CurrentElementDesc.bEndElement )
    {
        if( MATCH_ELEMENT_NAME( L"Animation" ) )
        {
            Animation* pNewAnimation = new Animation();
            m_Context.pCurrentObject = pNewAnimation;
            assert( m_Context.pCurrentParentObject == NULL );
            SetObjectNameFromAttribute( pNewAnimation );
            const WCHAR* strDuration = FindAttribute( L"Duration" );
            if( strDuration != NULL )
                pNewAnimation->SetDuration( ( FLOAT )_wtof( strDuration ) );
            g_pCurrentScene->AddObject( pNewAnimation );
            g_pCurrentScene->GetResourceDatabase()->AddResource( pNewAnimation );
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"AnimationTrack" ) )
        {
            assert( pAnimation != NULL );
            AnimationTransformTrack* pNewTrack = new AnimationTransformTrack();
            assert( m_Context.pCurrentParentObject == NULL );
            m_Context.pCurrentParentObject = pAnimation;
            m_Context.pCurrentObject = pNewTrack;
            SetObjectNameFromAttribute( pNewTrack );
            pAnimation->AddAnimationTrack( pNewTrack );
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"PositionKeys" ) )
        {
            m_Context.dwUserDataIndex = 0;
            const WCHAR* strValue = FindAttribute( L"Count" );
            if( strValue != NULL )
            {
                DWORD dwCount = ( DWORD )_wtoi( strValue );
                if( pTrack )
                    pTrack->GetPositionKeys().Resize( dwCount );
            }
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"OrientationKeys" ) )
        {
            m_Context.dwUserDataIndex = 1;
            const WCHAR* strValue = FindAttribute( L"Count" );
            if( strValue != NULL )
            {
                DWORD dwCount = ( DWORD )_wtoi( strValue );
                if( pTrack )
                    pTrack->GetOrientationKeys().Resize( dwCount );
            }
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"ScaleKeys" ) )
        {
            m_Context.dwUserDataIndex = 2;
            const WCHAR* strValue = FindAttribute( L"Count" );
            if( strValue != NULL )
            {
                DWORD dwCount = ( DWORD )_wtoi( strValue );
                if( pTrack )
                    pTrack->GetScaleKeys().Resize( dwCount );
            }
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"PositionKey" ) )
        {
            assert( pTrack != NULL );
            DWORD dwKeyIndex = pTrack->GetPositionKeys().AddKey();
            m_Context.dwCurrentParameterIndex = dwKeyIndex;
            m_Context.dwUserDataIndex = 0;
            const WCHAR* strValue = FindAttribute( L"Time" );
            if( strValue != NULL )
            {
                FLOAT fTime = ( FLOAT )_wtof( strValue );
                pTrack->GetPositionKeys().SetKeyTime( dwKeyIndex, fTime );
            }
            strValue = FindAttribute( L"Position" );
            if( strValue != NULL )
            {
                XMVECTOR vPosition = ScanVector3( strValue );
                pTrack->GetPositionKeys().SetKeyValue( dwKeyIndex, vPosition );
            }
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"OrientationKey" ) )
        {
            assert( pTrack != NULL );
            DWORD dwKeyIndex = pTrack->GetOrientationKeys().AddKey();
            m_Context.dwCurrentParameterIndex = dwKeyIndex;
            m_Context.dwUserDataIndex = 1;
            const WCHAR* strValue = FindAttribute( L"Time" );
            if( strValue != NULL )
            {
                FLOAT fTime = ( FLOAT )_wtof( strValue );
                pTrack->GetOrientationKeys().SetKeyTime( dwKeyIndex, fTime );
            }
            strValue = FindAttribute( L"Orientation" );
            if( strValue != NULL )
            {
                XMVECTOR vOrientation = ScanVector4( strValue );
                pTrack->GetOrientationKeys().SetKeyValue( dwKeyIndex, vOrientation );
            }
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"ScaleKey" ) )
        {
            assert( pTrack != NULL );
            DWORD dwKeyIndex = pTrack->GetScaleKeys().AddKey();
            m_Context.dwCurrentParameterIndex = dwKeyIndex;
            m_Context.dwUserDataIndex = 2;
            const WCHAR* strValue = FindAttribute( L"Time" );
            if( strValue != NULL )
            {
                FLOAT fTime = ( FLOAT )_wtof( strValue );
                pTrack->GetScaleKeys().SetKeyTime( dwKeyIndex, fTime );
            }
            strValue = FindAttribute( L"Scale" );
            if( strValue != NULL )
            {
                XMVECTOR vScale = ScanVector3( strValue );
                pTrack->GetScaleKeys().SetKeyValue( dwKeyIndex, vScale );
            }
            return;
        }
        else if( g_bDebugXMLParser )
        {
            WCHAR s[100];
            swprintf_s( s, L"Animation tag: %s\n", m_CurrentElementDesc.strElementName );
            OutputDebugStringW( s );
        }
    }
    else
    {
        if( MATCH_ELEMENT_NAME( L"Animation" ) )
        {
            m_Context.pCurrentObject = NULL;
            m_Context.CurrentObjectType = XATG_FRAME;
            return;
        }
        else if( MATCH_ELEMENT_NAME( L"AnimationTrack" ) )
        {
            assert( pTrack != NULL );
            pTrack->GetPositionKeys().SortKeys();
            pTrack->GetScaleKeys().SortKeys();
            pTrack->GetOrientationKeys().SortKeys();
            m_Context.dwCurrentParameterIndex = 0;
            m_Context.pCurrentObject = m_Context.pCurrentParentObject;
            m_Context.pCurrentParentObject = NULL;
            return;
        }
    }
}


VOID SceneFileParser::CollapseSceneFrames( Frame* pFrame )
{
    // If we only have one non-pure-frame child and we're a frame, we'll merge 
    Frame* pSrch = NULL, *pMergeFrame = NULL, *pNext = NULL;
    int iCount = 0;
    for( pSrch = pFrame->GetFirstChild(); pSrch; pSrch = pSrch->GetNextSibling() )
    {
        if( pSrch->Type() != Frame::TypeID )
        {
            pMergeFrame = pSrch;
            iCount++;
        }
    }

    if( iCount == 1 )
    {
        XMMATRIX mTransform;

        // this will automatically do the right thing to the local transform
        pMergeFrame->SetParent( pFrame->GetParent() );

        // reparent all other children of this frame
        for( pSrch = pFrame->GetFirstChild(); pSrch; pSrch = pNext )
        {
            pNext = pSrch->GetNextSibling();
            pSrch->SetParent( pMergeFrame );
        }
        pFrame->SetParent( NULL );
        g_pCurrentScene->RemoveObject( pFrame );

        // if we change the name, we need to remove and re-add to the current scene
        g_pCurrentScene->RemoveObject( pMergeFrame );
        pMergeFrame->SetName( pFrame->GetName() );
        g_pCurrentScene->AddObject( pMergeFrame );

        delete pFrame;
        pFrame = pMergeFrame;
    }

    for( pSrch = pFrame->GetFirstChild(); pSrch; pSrch = pNext )
    {
        pNext = pSrch->GetNextSibling();
        if( pSrch->Type() == Frame::TypeID )
            CollapseSceneFrames( pSrch );
    }
}

} // namespace ATG

```

`XenonDumper/libs/Atg/AtgSceneFileParser.h`:

```h
//-------------------------------------------------------------------------------------
//  AtgSceneFileParser.h
//
//  A SAX-based parser to read the ATG scene file format.
//
//  Xbox Advanced Technology Group
//  Copyright (C) Microsoft Corporation. All rights reserved.
//-------------------------------------------------------------------------------------

#pragma once
#ifndef ATG_SCENEFILEPARSER_H
#define ATG_SCENEFILEPARSER_H

#include <vector>
#include "AtgXmlParser.h"
#include "AtgSceneAll.h"

namespace ATG
{

enum XATGObjectLoaderType
{
    XATG_NONE = 0,
    XATG_MESH,
    XATG_SKINNEDMESHINFLUENCES,
    XATG_VERTEXBUFFER,
    XATG_INDEXBUFFER,
    XATG_VERTEXDECLELEMENT,
    XATG_INDEXBUFFERSUBSET,
    XATG_FRAME,
    XATG_MODEL,
    XATG_MATERIAL,
    XATG_AMBIENTLIGHT,
    XATG_DIRECTIONALLIGHT,
    XATG_POINTLIGHT,
    XATG_SPOTLIGHT,
    XATG_CAMERA,
    XATG_ANIMATION,
};

struct XMLElementAttribute
{
    WCHAR   strName[100];
    WCHAR   strValue[256];
};
typedef std::vector <XMLElementAttribute> XMLElementAttributeList;

class XMLElementDesc
{
public:
            XMLElementDesc()
            {
                strElementName[0] = L'\0';
                strElementBody[0] = L'\0';
                bEndElement = FALSE;
            }
    WCHAR   strElementName[128];
    WCHAR   strElementBody[1024];
    XMLElementAttributeList Attributes;
    BOOL bEndElement;
};

class Frame;
class ParameterDesc;

class XATGParserContext
{
public:
    XATGParserContext() : CurrentObjectType( XATG_NONE ),
                          pCurrentObject( NULL ),
                          pUserData( NULL ),
                          pCurrentParentFrame( NULL ),
                          pCurrentParentObject( NULL )
    {
    }
    XATGObjectLoaderType CurrentObjectType;
    VOID* pCurrentObject;
    VOID* pUserData;
    DWORD dwUserDataIndex;
    Frame* pCurrentParentFrame;
    VOID* pCurrentParentObject;
    DWORD dwCurrentParameterIndex;
};

class Scene;

enum XATGLoaderFlags
{
    XATGLOADER_DONOTINITIALIZEMATERIALS = 1,
    XATGLOADER_EFFECTSELECTORPARAMETERS = 2,
    XATGLOADER_DONOTBINDTEXTURES        = 4,
};

class SceneFileParser : public ISAXCallback
{
public:
    static HRESULT  PrepareForThreadedLoad( CRITICAL_SECTION* pCriticalSection );
    static HRESULT  LoadXATGFile( const CHAR* strFileName, Scene* pScene, Frame* pRootFrame, DWORD dwFlags = 0,
                                  DWORD* pLoadProgress = NULL );
    static const CHAR* GetParseErrorMessage();

    virtual HRESULT StartDocument()
    {
        return S_OK;
    }
    virtual HRESULT EndDocument();

    virtual HRESULT ElementBegin( const WCHAR* strName, UINT NameLen,
                                  const XMLAttribute* pAttributes, UINT NumAttributes );
    virtual HRESULT ElementContent( const WCHAR* strData, UINT DataLen, BOOL More );
    virtual HRESULT ElementEnd( const WCHAR* strName, UINT NameLen );

    virtual HRESULT CDATABegin()
    {
        return S_OK;
    }
    virtual HRESULT CDATAData( const WCHAR* strCDATA, UINT CDATALen, BOOL bMore )
    {
        return S_OK;
    }
    virtual HRESULT CDATAEnd()
    {
        return S_OK;
    }
    virtual VOID    SetParseProgress( DWORD dwProgress );

    virtual VOID    Error( HRESULT hError, const CHAR* strMessage );

protected:
    XATGParserContext m_Context;
    XMLElementDesc m_CurrentElementDesc;

    VOID            CopyAttributes( const XMLAttribute* pAttributes, UINT uAttributeCount );
    VOID            HandleElementData();
    VOID            HandleElementEnd();
    VOID            DistributeElementToLoaders();

    BOOL            FindAttribute( const WCHAR* strName, WCHAR* strDest, UINT uDestLength );
    const WCHAR* FindAttribute( const WCHAR* strName );
    BOOL            SetObjectNameFromAttribute( NamedTypedObject* pNTO );

    VOID            AcquireDirect3D();
    VOID            ReleaseDirect3D();

    VOID            ProcessRootData();
    VOID            ProcessMeshData();
    VOID            ProcessFrameData();
    VOID            ProcessModelData();
    VOID            ProcessMaterialData();
    VOID            ProcessLightData();
    VOID            ProcessCameraData();
    VOID            ProcessAnimationData();
    VOID            CrackVertex( BYTE* pDest, const D3DVERTEXELEMENT9* pVertexElements, DWORD dwStreamIndex );

    static VOID     CollapseSceneFrames( Frame* pFrame );
};

} // namespace ATG

#endif

```

`XenonDumper/libs/Atg/AtgSceneMesh.cpp`:

```cpp
//-----------------------------------------------------------------------------
// mesh.cpp
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "AtgDevice.h"
#include "AtgSceneMesh.h"
#include "AtgResourceDatabase.h"

namespace ATG
{

extern D3DDevice* g_pd3dDevice;

CONST StringID BaseMesh::TypeID( L"Mesh" );
CONST StringID StaticMesh::TypeID( L"StaticMesh" );
CONST StringID SkinnedMesh::TypeID( L"SkinnedMesh" );
const StringID CatmullClarkMesh::TypeID( L"CatmullClarkMesh" );

//-----------------------------------------------------------------------------
// Name: StaticMesh::StaticMesh()
//-----------------------------------------------------------------------------
StaticMesh::StaticMesh()
{
    m_pVertexData = NULL;
    m_pIndexData = NULL;
    m_dwFlags = BaseMesh::IsRenderable;
}


//-----------------------------------------------------------------------------
// Name: StaticMesh::GetNumVertices()
//-----------------------------------------------------------------------------
UINT StaticMesh::GetNumVertices() CONST
{    
    assert( m_pVertexData );
    return m_pVertexData->GetNumVertices();
}


//-----------------------------------------------------------------------------
// Name: StaticMesh::GetNumPrimitives()
//-----------------------------------------------------------------------------
UINT StaticMesh::GetNumPrimitives() CONST
{
    UINT NumPrims = 0;
    for( UINT i = 0; i < m_Subsets.size(); i++ )
        NumPrims += m_Subsets[i]->GetNumPrimitives();

    return NumPrims;
}


//-----------------------------------------------------------------------------
// Name: StaticMesh::HasVertexElementType()
//-----------------------------------------------------------------------------
BOOL StaticMesh::HasVertexElementType( UINT Index, D3DDECLUSAGE Usage ) CONST
{    
    static D3DVERTEXELEMENT9 VertexElements[128];
    UINT NumElements = 128;

    assert( Index == 0 );

    // $ERRORREPORT
    BOOL bResult = FAILED( m_pVertexData->GetVertexDecl()->GetDeclaration( VertexElements, &NumElements ) );
    assert( !bResult );
    // get rid of warning in release build
    bResult = ( NumElements == 0 );

    UINT DeclSize = D3DXGetDeclLength( VertexElements );
    for( UINT i = 0; i < DeclSize; i++ )
    {
        if( VertexElements[i].Usage == Usage )
            return TRUE;
    }

    return FALSE;
}


//-----------------------------------------------------------------------------
// Name: StaticMesh::RenderSubset()
//-----------------------------------------------------------------------------
UINT StaticMesh::RenderSubset( UINT SubsetIndex, ::D3DDevice* pd3dDevice, DWORD dwFlags ) CONST
{
    if( pd3dDevice == NULL )
        pd3dDevice = g_pd3dDevice;
    assert( pd3dDevice != NULL );

    SubsetDesc* pDesc = m_Subsets[ SubsetIndex ];

    assert( m_pVertexData );
    assert( m_pIndexData );
    assert( pDesc );
    BOOL bResult = FALSE;

    LPDIRECT3DVERTEXDECLARATION9 pVertexDecl = m_pVertexData->GetVertexDecl();

    // streams
    for( UINT i = 0; i < m_pVertexData->GetNumVertexStreams(); i++ )
    {
        UINT Stride = m_pVertexData->GetVertexStream( i )->Stride;

        if( dwFlags & BaseMesh::ZeroStreamStrides )
            Stride = 0;

        // $ERRORREPORT
        bResult = FAILED( pd3dDevice->SetStreamSource( i,
                                                       m_pVertexData->GetVertexStream( i )->pVertexBuffer,
                                                       0,
                                                       Stride ) );
        assert( !bResult );
    }

    // $ERRORREPORT
    if( !( dwFlags & BaseMesh::NoVertexDecl ) )
    {
        bResult = FAILED( pd3dDevice->SetVertexDeclaration( pVertexDecl ) );
        assert( !bResult );
    }

    // $ERRORREPORT
    bResult = FAILED( pd3dDevice->SetIndices( m_pIndexData->GetIndexBuffer() ) );
    assert( !bResult );

    // $ERRORREPORT
    bResult = FAILED( pd3dDevice->DrawIndexedPrimitive( pDesc->GetPrimitiveType(), 0, 0,
                                                        m_pVertexData->GetNumVertices(),
                                                        pDesc->GetStartIndex(),
                                                        pDesc->GetNumPrimitives() ) );
    assert( !bResult );

    return pDesc->GetNumPrimitives();
}

SkinnedMesh::SkinnedMesh()
{
    m_pVertexData = NULL;
    m_pIndexData = NULL;
    m_dwFlags = BaseMesh::IsRenderable | BaseMesh::IsSkinnable;
}

CatmullClarkMesh::CatmullClarkMesh()
{
    m_pVertexData = NULL;
    m_pIndexData = NULL;
    m_dwFlags = BaseMesh::IsRenderable | BaseMesh::IsSkinnable;
}

} // namespace ATG

```

`XenonDumper/libs/Atg/AtgSceneMesh.h`:

```h
//-----------------------------------------------------------------------------
// AtgSceneMesh.h
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef ATG_MESH_H
#define ATG_MESH_H

#include <vector>
#include "AtgNamedTypedObject.h"

namespace ATG
{

class VertexData;
class IndexData;
class SubsetDesc;

class BaseMesh : public NamedTypedObject
{
    DEFINE_TYPE_INFO();
public:
    enum RenderSubsetFlags
    {
        NoVertexDecl = 1,
        ZeroStreamStrides = 2,
    };

    enum MeshFlags
    {        
        NoFlags =                0x0,      
        IsSkinnable =            0x1,
        IsMorphable =            0x2,
        IsRenderable =           0x4,
        IsStencilShadowCasting = 0x8,
        IsShadowBufferCasting =  0x10,
        IsSortable =             0x20,        
        IsEnabled =              0x40,      
     
        ForceDWORD =           0x7fffffff
    };

    BaseMesh() : m_dwFlags( BaseMesh::NoFlags )        {}
    
    // IsSkinnable
    virtual VOID    Skin( XMMATRIX* pPallet )      {}
    
    // IsMorphable
    virtual VOID    Morph( FLOAT* pWeights )       {}
    
    // IsRenderable
    virtual UINT            GetNumSubsets() CONST { return 0; }
    virtual UINT            RenderSubset( UINT Index, ::D3DDevice* pd3dDevice = NULL, DWORD dwFlags = 0 ) CONST { return 0; }
    virtual SubsetDesc*     GetSubsetDesc( UINT Index ) CONST { return NULL; }
    virtual VOID            AddSubsetDesc( SubsetDesc *pSD ) {}
    virtual VOID            SetSubsetDesc( UINT Index ) {}
    virtual BOOL            HasVertexElementType( UINT Index, D3DDECLUSAGE Usage ) CONST { return FALSE; }
    
    // IsStencilShadowCasting
    virtual UINT            RenderStencilShadow( CONST XMVECTOR& LightPos, FLOAT ExtensionAmmount ) CONST { return 0; }
    
    // IsShadowBufferCasting
    virtual UINT            RenderShadowBuffer() CONST { return 0; }
    
    // IsSortable
    virtual VOID            Sort( CONST XMVECTOR& Plane ) { return; }

    // Number of primitives and vertices, for debug output
    virtual UINT            GetNumVertices() CONST { return 0; }
    virtual UINT            GetNumPrimitives() CONST { return 0; }

    // get vertex data from mesh
    virtual UINT            GetNumVertexDatas() CONST { return 0; }
    virtual VertexData*     GetVertexData( UINT Index ) CONST { return NULL; }
    virtual VOID            SetVertexData( UINT Index, VertexData* pData ) {}
    
    // Get index data from mesh
    virtual UINT            GetNumIndexDatas() CONST { return 0; }
    virtual IndexData*      GetIndexData( UINT Index ) CONST { return NULL; }
    virtual VOID            SetIndexData( UINT Index, IndexData* pData ) {}

    // Flags
    DWORD                   GetFlags()                      { return m_dwFlags; }
    VOID                    ClearFlag( MeshFlags dwFlag )   { m_dwFlags &= ~dwFlag; }    
    VOID                    SetFlag( MeshFlags dwFlag )     { m_dwFlags |= dwFlag; }

protected:    
    DWORD                   m_dwFlags;
};



//-----------------------------------------------------------------------------
// Represents a static, non-skinned mesh
//-----------------------------------------------------------------------------

class StaticMesh : public BaseMesh
{
    DEFINE_TYPE_INFO();
public:    
    StaticMesh();

    virtual UINT                    GetNumVertices() CONST;
    virtual UINT                    GetNumPrimitives() CONST;
    
    virtual UINT                    GetNumSubsets() CONST { return m_Subsets.size(); };  
    virtual SubsetDesc*         GetSubsetDesc( UINT Index ) CONST { return m_Subsets[ Index ]; }
    virtual VOID                    SetSubsetDesc( UINT Index, SubsetDesc* pDesc ) { m_Subsets[ Index ] = pDesc; }
    virtual VOID                    AddSubsetDesc( SubsetDesc *pSD ) { m_Subsets.push_back( pSD ); }
    virtual UINT                    RenderSubset( UINT Index, ::D3DDevice* pd3dDevice = NULL, DWORD dwFlags = 0 ) CONST;
    virtual BOOL                    HasVertexElementType( UINT Index, D3DDECLUSAGE Usage ) CONST;
    

    virtual UINT                    GetNumVertexDatas() CONST { return 1; };
    virtual VertexData*         GetVertexData( UINT Index ) CONST { return m_pVertexData; };
    virtual VOID                    SetVertexData( UINT Index, VertexData* pData ) { m_pVertexData = pData; }

    virtual UINT                    GetNumIndexDatas() CONST { return 1; };
    virtual IndexData*          GetIndexData( UINT Index ) CONST { return m_pIndexData; }
    virtual VOID                    SetIndexData( UINT Index, IndexData* pData ) { m_pIndexData = pData; }

protected:
    std::vector<SubsetDesc*>    m_Subsets;
    VertexData*                 m_pVertexData;
    IndexData*                  m_pIndexData;    
};

class SkinnedMesh : public StaticMesh
{
    DEFINE_TYPE_INFO();
public:
    SkinnedMesh();

    VOID AddInfluence( StringID strInfluenceName ) { m_InfluenceNames.push_back( strInfluenceName ); }
    DWORD GetInfluenceCount() const { return (DWORD)m_InfluenceNames.size(); }
    const StringID GetInfluence( DWORD dwIndex ) const { return m_InfluenceNames[dwIndex]; }

protected:
    std::vector<StringID>       m_InfluenceNames;
};

class CatmullClarkMesh : public SkinnedMesh
{
    DEFINE_TYPE_INFO();
public:
    CatmullClarkMesh();
};

} // namespace ATG

#endif // ATG_MESH_H

```

`XenonDumper/libs/Atg/AtgSessionManager.cpp`:

```cpp
#include "stdafx.h"
#include "AtgUtil.h"
#include "AtgSessionManager.h"
#define DebugSpew ATG::DebugSpew
#define FatalError ATG::FatalError
#define XNKIDToInt64 ATG::XNKIDToInt64

//------------------------------------------------------------------------
// Name: SessionManager()
// Desc: Public constructor
//------------------------------------------------------------------------
SessionManager::SessionManager() 
{
    Reset();
}

//------------------------------------------------------------------------
// Name: Reset()
// Desc: Resets this SessionManager instance to its creation state
//------------------------------------------------------------------------
VOID SessionManager::Reset()
{
    m_bIsInitialized            = FALSE;
    m_SessionCreationReason     = SessionCreationReasonNone;
    m_dwSessionFlags            = 0;
    m_dwOwnerController         = XUSER_MAX_COUNT + 1;
    m_xuidOwner                 = INVALID_XUID;
    m_SessionState              = SessionStateNone;
    m_migratedSessionState      = SessionStateNone;
    m_bIsMigratedSessionHost    = FALSE;
    m_hSession                  = INVALID_HANDLE_VALUE;
    m_qwSessionNonce            = 0;
    m_strSessionError           = NULL;
    m_bUsingQoS                 = FALSE;
    m_pRegistrationResults      = NULL;
    ZeroMemory( &m_SessionInfo, sizeof( XSESSION_INFO ) );
    ZeroMemory( &m_NewSessionInfo, sizeof( XSESSION_INFO ) );
    ZeroMemory( &m_migratedSessionID, sizeof( XNKID ) );    
}


//------------------------------------------------------------------------
// Name: ~SessionManager()
// Desc: Public destructor
//------------------------------------------------------------------------
SessionManager::~SessionManager()
{
    // Close our XSession handle to clean up resources held by it
    if( m_hSession != INVALID_HANDLE_VALUE && 
        m_hSession != NULL )
    {
        XCloseHandle( m_hSession );
    }
}


//------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initializes this SessionManager instance
//------------------------------------------------------------------------
BOOL SessionManager::Initialize( SessionManagerInitParams initParams )
{
    if( m_bIsInitialized )
    {
        DebugSpew( "SessionManager already initialized. Reinitializing..\n" );
    }

    m_SessionCreationReason         = initParams.m_SessionCreationReason;
    m_dwSessionFlags                = initParams.m_dwSessionFlags;
    m_bIsHost                       = initParams.m_bIsHost;
    m_Slots[SLOTS_TOTALPUBLIC]      = initParams.m_dwMaxPublicSlots;
    m_Slots[SLOTS_TOTALPRIVATE]     = initParams.m_dwMaxPrivateSlots;
    m_Slots[SLOTS_FILLEDPUBLIC]     = 0;
    m_Slots[SLOTS_FILLEDPRIVATE]    = 0;
    m_Slots[SLOTS_ZOMBIEPUBLIC]     = 0;
    m_Slots[SLOTS_ZOMBIEPRIVATE]    = 0;

    m_bIsInitialized = TRUE;
    return TRUE;
}

//------------------------------------------------------------------------
// Name: IsInitialized()
// Desc: Queries SessionManager initialization state
//------------------------------------------------------------------------
BOOL SessionManager::IsInitialized()
{
    return m_bIsInitialized;
}

//------------------------------------------------------------------------
// Name: IsSessionDeleted()
// Desc: Returns TRUE if the XSession for this instance
//       has a 0 sessionID; otherwise false
//------------------------------------------------------------------------
BOOL SessionManager::IsSessionDeleted( VOID ) const
{
    static const XNKID zero = {0};

    if( m_SessionState == SessionStateDeleted )
    {
        return TRUE;
    }

    BOOL bIsSessionDeleted = FALSE;

    if( m_hSession == INVALID_HANDLE_VALUE || m_hSession == NULL )
    {
        // If the session hasn't been created yet, return false
        if ( m_SessionState < SessionStateCreated )
        {
            bIsSessionDeleted = FALSE;
        }
        else
        {
            bIsSessionDeleted = TRUE;
        }

        return bIsSessionDeleted;
    }

    // Call XSessionGetDetails first time to get back the size 
    // of the results buffer we need
    DWORD cbResults = 0;

    DWORD ret = XSessionGetDetails( m_hSession,
                                    &cbResults,
                                    NULL,
                                    NULL ); 

    if( ( ret != ERROR_INSUFFICIENT_BUFFER ) || ( cbResults == 0 ) )
    {
        DebugSpew( "SessionManager::IsSessionDeleted - Failed on first call to XSessionGetDetails, hr=0x%08x\n", ret );
        return FALSE;
    }
    
    XSESSION_LOCAL_DETAILS* pSessionDetails = (XSESSION_LOCAL_DETAILS*)new BYTE[ cbResults ];
    if( pSessionDetails == NULL )
    {
        FatalError( "SessionManager::IsSessionDeleted - Failed to allocate buffer.\n" );
    }

    // Call second time to fill our results buffer
    ret = XSessionGetDetails( m_hSession,
                              &cbResults,
                              pSessionDetails,
                              NULL ); 

    if( ret != ERROR_SUCCESS )
    {
        DebugSpew( "SessionManager::IsSessionDeleted - XSessionGetDetails failed with error %d\n", ret );
        return FALSE;
    }

    // Iterate through the returned results
    const XNKID sessionID = pSessionDetails->sessionInfo.sessionID;

    if ( !memcmp( &sessionID, &zero, sizeof( sessionID ) ) )
    {
        bIsSessionDeleted = TRUE;
    }

    if ( pSessionDetails )
    {
        delete [] pSessionDetails;
    }

    return bIsSessionDeleted;
}

//------------------------------------------------------------------------
// Name: IsPlayerInSession()
// Desc: Uses XSessionGetDetails API to determine if a player is in the session
//------------------------------------------------------------------------
BOOL SessionManager::IsPlayerInSession( const XUID xuidPlayer, const DWORD dwUserIndex ) const
{
    if( m_hSession == INVALID_HANDLE_VALUE || m_hSession == NULL )
    {
        DebugSpew( "SessionManager::IsPlayerInSession - Session handle invalid. Perhaps session has been deleted?\n" );
        return FALSE;
    }

    // Call XSessionGetDetails first time to get back the size 
    // of the results buffer we need
    DWORD cbResults = 0;

    DWORD ret = XSessionGetDetails( m_hSession,
                                    &cbResults,
                                    NULL,
                                    NULL ); 

    if( ( ret != ERROR_INSUFFICIENT_BUFFER ) || ( cbResults == 0 ) )
    {
        DebugSpew( "SessionManager::IsPlayerInSession - Failed on first call to XSessionGetDetails, hr=0x%08x\n", ret );
        return FALSE;
    }

    // Increase our buffer size to include an estimate of the maximum number
    // of players allowed in the session
    const DWORD dwMaxMembers = m_Slots[SLOTS_TOTALPUBLIC] + m_Slots[SLOTS_TOTALPRIVATE];
    cbResults += dwMaxMembers * sizeof(XSESSION_MEMBER);
    
    XSESSION_LOCAL_DETAILS* pSessionDetails = (XSESSION_LOCAL_DETAILS*)new BYTE[ cbResults ];
    if( pSessionDetails == NULL )
    {
        FatalError( "SessionManager::IsPlayerInSession - Failed to allocate buffer.\n" );
    }

    // Call second time to fill our results buffer
    ret = XSessionGetDetails( m_hSession,
                              &cbResults,
                              pSessionDetails,
                              NULL ); 

    if( ret != ERROR_SUCCESS )
    {
        DebugSpew( "SessionManager::IsPlayerInSession - XSessionGetDetails failed with error %d\n", ret );
        return FALSE;
    }

    const BOOL bIsValidUserIndex = ( dwUserIndex < XUSER_MAX_COUNT );
    BOOL bIsInSession = FALSE;
    for ( DWORD i = 0; i < pSessionDetails->dwReturnedMemberCount; ++i )
    {
        if( ( bIsValidUserIndex && ( pSessionDetails->pSessionMembers[i].dwUserIndex == dwUserIndex ) ) ||
            ( xuidPlayer == pSessionDetails->pSessionMembers[i].xuidOnline ) )
        {
            bIsInSession = TRUE;
            break;
        }
    }

    if ( pSessionDetails )
    {
        delete [] pSessionDetails;
    }

    return bIsInSession;
}

//------------------------------------------------------------------------
// Name: DebugDumpSessionDetails()
// Desc: Dumps session deletes
//------------------------------------------------------------------------
VOID SessionManager::DebugDumpSessionDetails() const
{
    #ifdef _DEBUG

    if( m_hSession == INVALID_HANDLE_VALUE || m_hSession == NULL )
    {
        DebugSpew( "SessionManager::DebugDumpSessionDetails - Session handle invalid. Perhaps session has been deleted?\n" );
        return;
    }

    // Call XSessionGetDetails first time to get back the size 
    // of the results buffer we need
    DWORD cbResults = 0;

    DWORD ret = XSessionGetDetails( m_hSession,
                                    &cbResults,
                                    NULL,
                                    NULL ); 

    if( ( ret != ERROR_INSUFFICIENT_BUFFER ) || ( cbResults == 0 ) )
    {
        DebugSpew( "SessionManager::DebugDumpSessionDetails - Failed on first call to XSessionGetDetails, hr=0x%08x\n", ret );
        return;
    }

    // Increase our buffer size to include an estimate of the maximum number
    // of players allowed in the session
    const DWORD dwMaxMembers = m_Slots[SLOTS_TOTALPUBLIC] + m_Slots[SLOTS_TOTALPRIVATE];
    cbResults += dwMaxMembers * sizeof(XSESSION_MEMBER);
    
    XSESSION_LOCAL_DETAILS* pSessionDetails = (XSESSION_LOCAL_DETAILS*)new BYTE[ cbResults ];
    if( pSessionDetails == NULL )
    {
        FatalError( "SessionManager::DebugDumpSessionDetails - Failed to allocate buffer.\n" );
    }

    // Call second time to fill our results buffer
    ret = XSessionGetDetails( m_hSession,
                              &cbResults,
                              pSessionDetails,
                              NULL ); 

    if( ret != ERROR_SUCCESS )
    {
        DebugSpew( "SessionManager::DebugDumpSessionDetails - XSessionGetDetails failed with error %d\n", ret );
        return;
    }

    // Iterate through the returned results
    DebugSpew( "***************** DebugDumpSessionDetails *****************\n" \
                    "instance: %p\n" \
                    "sessionID: %016I64X\n" \
                    "Matchmaking session?: %s\n" \
                    "m_hSession: %p\n" \
                    "bIsHost: %d\n" \
                    "sessionstate: %s\n" \
                    "qwSessionNonce: %I64u\n" \
                    "dwUserIndexHost: %d\n" \
                    "dwGameType: %d\n" \
                    "dwGameMode: %d\n" \
                    "dwFlags: 0x%x\n" \
                    "dwMaxPublicSlots: %d\n" \
                    "dwMaxPrivateSlots: %d\n" \
                    "dwAvailablePublicSlots: %d\n" \
                    "dwAvailablePrivateSlots: %d\n" \
                    "dwActualMemberCount: %d\n" \
                    "dwReturnedMemberCount: %d\n" \
                    "xnkidArbitration: %016I64X\n",
                    this,
                    GetSessionIDAsInt(),
                    ( HasSessionFlags( XSESSION_CREATE_USES_MATCHMAKING ) ) ? "Yes" : "No",
                    m_hSession,
                    m_bIsHost,
                    g_astrSessionState[m_SessionState],
                    m_qwSessionNonce,
                    pSessionDetails->dwUserIndexHost,
                    pSessionDetails->dwGameType,
                    pSessionDetails->dwGameMode,
                    pSessionDetails->dwFlags,
                    pSessionDetails->dwMaxPublicSlots,
                    pSessionDetails->dwMaxPrivateSlots,
                    pSessionDetails->dwAvailablePublicSlots,
                    pSessionDetails->dwAvailablePrivateSlots,
                    pSessionDetails->dwActualMemberCount,
                    pSessionDetails->dwReturnedMemberCount,
                    XNKIDToInt64( pSessionDetails->xnkidArbitration ) );

    for ( DWORD i = 0; i < pSessionDetails->dwReturnedMemberCount; ++i )
    {
        DebugSpew( "***************** XSESSION_MEMBER %d *****************\n" \
                   "Online XUID: 0x%016I64X\n" \
                   "dwUserIndex: %d\n" \
                   "dwFlags: 0x%x\n",
                   i,
                   pSessionDetails->pSessionMembers[i].xuidOnline,
                   pSessionDetails->pSessionMembers[i].dwUserIndex,
                   pSessionDetails->pSessionMembers[i].dwFlags );    
    }

    if ( pSessionDetails )
    {
        delete [] pSessionDetails;
    }

    #endif
}

//------------------------------------------------------------------------
// Name: DebugValidateExpectedSlotCounts()
// Desc: Makes sure slot counts are consistent with what is stored with
//       the XSession
//------------------------------------------------------------------------
BOOL SessionManager::DebugValidateExpectedSlotCounts( const BOOL bBreakOnDifferent ) const
{
    BOOL bSlotCountsDiffer = FALSE;
    assert (m_SessionState < SessionStateCount);

    #ifdef _DEBUG

    if( m_hSession == INVALID_HANDLE_VALUE || m_hSession == NULL )
    {
        DebugSpew( "SessionManager::DebugValidateExpectedSlotCounts - Session handle invalid. Perhaps session has been deleted?\n" );
        return !bSlotCountsDiffer;
    }

    // Call XSessionGetDetails first time to get back the size 
    // of the results buffer we need
    DWORD cbResults = 0;

    DWORD ret = XSessionGetDetails( m_hSession,
                                    &cbResults,
                                    NULL,
                                    NULL ); 

    if( ( ret != ERROR_INSUFFICIENT_BUFFER ) || ( cbResults == 0 ) )
    {
        DebugSpew( "SessionManager::DebugValidateExpectedSlotCounts - Failed on first call to XSessionGetDetails, hr=0x%08x\n", ret );
        return FALSE;
    }
    
    XSESSION_LOCAL_DETAILS* pSessionDetails = (XSESSION_LOCAL_DETAILS*)new BYTE[ cbResults ];
    if( pSessionDetails == NULL )
    {
        FatalError( "SessionManager::DebugValidateExpectedSlotCounts - Failed to allocate buffer.\n" );
    }

    // Call second time to fill our results buffer
    ret = XSessionGetDetails( m_hSession,
                              &cbResults,
                              pSessionDetails,
                              NULL ); 

    if( ret != ERROR_SUCCESS )
    {
        DebugSpew( "SessionManager::DebugValidateExpectedSlotCounts - XSessionGetDetails failed with error %d\n", ret );
        return FALSE;
    }

    const XNKID sessionID = pSessionDetails->sessionInfo.sessionID;

    const DWORD dwMaxPublicSlots        = m_Slots[SLOTS_TOTALPUBLIC];
    const DWORD dwMaxPrivateSlots       = m_Slots[SLOTS_TOTALPRIVATE];
    const DWORD dwAvailablePublicSlots  = m_Slots[SLOTS_TOTALPUBLIC] - m_Slots[SLOTS_FILLEDPUBLIC];
    const DWORD dwAvailablePrivateSlots = m_Slots[SLOTS_TOTALPRIVATE] - m_Slots[SLOTS_FILLEDPRIVATE];

    bSlotCountsDiffer = ( pSessionDetails->dwMaxPublicSlots != dwMaxPublicSlots  ||
                          pSessionDetails->dwMaxPrivateSlots != dwMaxPrivateSlots );

    // XSessionGetDetails only returns dwAvailablePublicSlots and dwAvailablePrivateSlots data
    // for:
    // 1. matchmaking sessions,
    // 2. sessions that are joinable during gameplay,
    // 3. sessions that aren't deleted
    //
    // Therefore it only makes sense to compare against are expected slot counts if all of
    // these conditions are met
    const BOOL bIsMatchmakingSession     = HasSessionFlags( XSESSION_CREATE_USES_MATCHMAKING );

    const BOOL bJoinable                 = !HasSessionFlags( XSESSION_CREATE_USES_ARBITRATION ) &&
                                           !HasSessionFlags( XSESSION_CREATE_JOIN_IN_PROGRESS_DISABLED );

    if( bIsMatchmakingSession && 
        ( m_SessionState != SessionStateDeleted ) &&
        ( ( m_SessionState != SessionStateInGame ) || ( ( m_SessionState == SessionStateInGame ) && bJoinable ) ) )
    {
        bSlotCountsDiffer |= ( pSessionDetails->dwAvailablePublicSlots != dwAvailablePublicSlots ||
                               pSessionDetails->dwAvailablePrivateSlots != dwAvailablePrivateSlots );
    }

    // Any differences detected?
    if( !bSlotCountsDiffer )
    {
        goto Terminate;
    }

    // Spew expected/actual slot counts
    DebugSpew( "***************** DebugValidateExpectedSlotCounts *****************\n" \
                    "instance: %p\n" \
                    "sessionID: %016I64X\n" \
                    "m_hSession: %p\n" \
                    "bIsHost: %d\n" \
                    "sessionstate: %s\n" \
                    "dwMaxPublicSlots        expected: %d;    actual: %d\n" \
                    "dwMaxPrivateSlots       expected: %d;    actual: %d\n",
                    this,
                    XNKIDToInt64( sessionID ),
                    m_hSession,
                    m_bIsHost,
                    g_astrSessionState[m_SessionState],
                    dwMaxPublicSlots, pSessionDetails->dwMaxPublicSlots,
                    dwMaxPrivateSlots, pSessionDetails->dwMaxPrivateSlots );

    if( HasSessionFlags( XSESSION_CREATE_USES_MATCHMAKING ) )
    {
        DebugSpew( "dwAvailablePublicSlots  expected: %d;    actual: %d\n" \
                   "dwAvailablePrivateSlots expected: %d;    actual: %d\n",
                   dwAvailablePublicSlots, pSessionDetails->dwAvailablePublicSlots,
                   dwAvailablePrivateSlots, pSessionDetails->dwAvailablePrivateSlots );
    }

    if( bBreakOnDifferent & bSlotCountsDiffer )
    {
        DebugBreak();
    }

Terminate:
    if ( pSessionDetails )
    {
        delete [] pSessionDetails;
    }

    #endif

    return !bSlotCountsDiffer;
}

//------------------------------------------------------------------------
// Name: GetSessionCreationReason()
// Desc: Retrieves session creation reason
//------------------------------------------------------------------------
SessionCreationReason SessionManager::GetSessionCreationReason( VOID ) const
{
    return m_SessionCreationReason;        
}

//------------------------------------------------------------------------
// Name: GetSessionState()
// Desc: Retrieves current session state
//------------------------------------------------------------------------
SessionState SessionManager::GetSessionState( VOID ) const
{
    return m_SessionState;        
}

//------------------------------------------------------------------------
// Name: GetSessionStateString()
// Desc: Retrieves current session state
//------------------------------------------------------------------------
const char* SessionManager::GetSessionStateString( VOID ) const
{
    return g_astrSessionState[m_SessionState];
}

//------------------------------------------------------------------------
// Name: SetSessionOwner()
// Desc: Sets current session owner
//------------------------------------------------------------------------
VOID SessionManager::SetSessionOwner( const DWORD dwOwnerController )
{
    m_dwOwnerController = dwOwnerController;
    XUserGetXUID( m_dwOwnerController, &m_xuidOwner );
}

//------------------------------------------------------------------------
// Name: GetSessionOwner()
// Desc: Retrieves current session owner
//------------------------------------------------------------------------
DWORD SessionManager::GetSessionOwner( VOID ) const
{
    return m_dwOwnerController;
}

//------------------------------------------------------------------------
// Name: GetSessionOwner()
// Desc: Retrieves current session owner XUID
//------------------------------------------------------------------------
XUID SessionManager::GetSessionOwnerXuid( VOID ) const
{
    return m_xuidOwner;
}

//------------------------------------------------------------------------
// Name: IsSessionOwner()
// Desc: Retrieves current session owner
//------------------------------------------------------------------------
BOOL SessionManager::IsSessionOwner( const DWORD dwController ) const
{
    return ( dwController == m_dwOwnerController );
}

//------------------------------------------------------------------------
// Name: IsSessionOwner()
// Desc: Retrieves current session owner
//------------------------------------------------------------------------
BOOL SessionManager::IsSessionOwner( const XUID xuidOwner ) const
{
    return ( xuidOwner == m_xuidOwner );
}

//------------------------------------------------------------------------
// Name: IsSessionHost()
// Desc: True if this SessionManager instance is the session host,
//       else false
//------------------------------------------------------------------------
BOOL SessionManager::IsSessionHost( VOID ) const
{
    return m_bIsHost;
}

//------------------------------------------------------------------------
// Name: MakeSessionHost()
// Desc: Make this SessionManager instance the session host. 
//------------------------------------------------------------------------
VOID SessionManager::MakeSessionHost( VOID )
{
    m_bIsHost = TRUE;
}

//------------------------------------------------------------------------
// Name: GetSessionNonce()
// Desc: Function to retrieve current session nonce
//------------------------------------------------------------------------
ULONGLONG SessionManager::GetSessionNonce( VOID ) const
{
    return m_qwSessionNonce;
}

//------------------------------------------------------------------------
// Name: SetSessionNonce()
// Desc: Function to set the session nonce
//       Only non-hosts should ever call this method
//------------------------------------------------------------------------
VOID SessionManager::SetSessionNonce( const ULONGLONG qwNonce )
{    
    if( m_bIsHost )
    {
        FatalError( "Only non-hosts should call this function!\n" );
    }

    m_qwSessionNonce = qwNonce;

    DebugDumpSessionDetails();
}

//------------------------------------------------------------------------
// Name: SetHostInAddr()
// Desc: Sets the IN_ADDR of the session host
//------------------------------------------------------------------------
VOID SessionManager::SetHostInAddr( const IN_ADDR& inaddr )
{
    m_HostInAddr = inaddr;
}

//------------------------------------------------------------------------
// Name: GetHostInAddr()
// Desc: Returns the IN_ADDR of the session host
//------------------------------------------------------------------------
IN_ADDR SessionManager::GetHostInAddr( VOID ) const
{
    return m_HostInAddr;
}


//------------------------------------------------------------------------
// Name: GetSessionID()
// Desc: Function to retrieve current session ID
//------------------------------------------------------------------------
XNKID SessionManager::GetSessionID( VOID )  const
{
    return m_SessionInfo.sessionID;
}

//------------------------------------------------------------------------
// Name: GetSessionIDAsInt()
// Desc: Function to retrieve current session ID as an __int64
//------------------------------------------------------------------------
__int64 SessionManager::GetSessionIDAsInt( VOID )  const
{
    // XNKID's are big-endian. Convert to little-endian if needed.
    #ifdef LIVE_ON_WINDOWS
        XNKID sessionID = m_SessionInfo.sessionID;
        for( BYTE i = 0; i < 4; ++i )
        {
            BYTE temp = (BYTE)( *( (BYTE*)&sessionID + i ) ); //temp = sessionID[ i ]
            *( (BYTE*)&sessionID + i ) = (BYTE)( *( (BYTE*)&sessionID + 8 - i - 1 ) ); //sessionID[ i ] = sessionID[ 8 - i - 1 ]
            *( (BYTE*)&sessionID + 8 - i - 1 ) = temp; //sessionID[ 8 - i - 1 ] = temp                     
        }
        return *(const __int64*)&sessionID;
    #else        
        return *(const __int64*)&m_SessionInfo.sessionID;
    #endif
}

//------------------------------------------------------------------------
// Name: GetMigratedSessionID()
// Desc: Function to retrieve the session ID of the session while
//       it is being migrated. This method can only be called
//       when this session manager instance is actively migrating a session
//------------------------------------------------------------------------
XNKID SessionManager::GetMigratedSessionID( VOID )  const
{
    if( !( m_SessionState >= SessionStateMigrateHost &&
           m_SessionState <= SessionStateMigratedHost ) )
    {
        FatalError( "GetMigratedSessionID called in state %s!\n", GetSessionStateString() );
    }

    return m_migratedSessionID;
}


//------------------------------------------------------------------------
// Name: SetSessionState()
// Desc: Sets current session state
//------------------------------------------------------------------------
VOID SessionManager::SetSessionState( const SessionState newState )
{
    m_SessionState = newState;
}

//------------------------------------------------------------------------
// Name: CheckSessionState()
// Desc: Checks if session in the expected state
//------------------------------------------------------------------------
BOOL SessionManager::CheckSessionState( const SessionState expectedState )  const
{
    SessionState actual = GetSessionState();

    if( actual != expectedState )
    {
        FatalError( "SessionManager instance in invalid state. Expected: %d; Got: %d\n", 
                    expectedState, actual );
    }

    return TRUE;
}

//------------------------------------------------------------------------
// Name: GetRegistrationResults()
// Desc: Retrieves last results from registering this client for
//       arbitratrion
//------------------------------------------------------------------------
const PXSESSION_REGISTRATION_RESULTS SessionManager::GetRegistrationResults()  const
{
    return (const PXSESSION_REGISTRATION_RESULTS)m_pRegistrationResults;    
}

//------------------------------------------------------------------------
// Name: SwitchToState()
// Desc: Changes to a new session state and performs initialization 
//       for the new state
//------------------------------------------------------------------------
VOID SessionManager::SwitchToState( SessionState newState )
{
    // Ignore transitions to the same state
    if( m_SessionState == newState )
    {
        return;
    }

    // If we're in state SessionStateMigratedHost, force a switch to 
    // the state we were in prior to migration
    if( m_SessionState == SessionStateMigratedHost )
    {
        DebugSpew( "SessionManager %016I64X (instance %p): Detected to be in state SessionStateMigratedHost. " \
                   "Switching to correct pre-migration state\n",
                   XNKIDToInt64( m_SessionInfo.sessionID ),
                   this );
        
        SwitchToPreHostMigrationState();
    }

    assert( m_SessionState < _countof( g_astrSessionState ) );
    DebugSpew( "SessionManager %016I64X (instance %p): Switching from session state %s to %s\n", 
               XNKIDToInt64( m_SessionInfo.sessionID ), 
               this, 
               g_astrSessionState[m_SessionState], 
               g_astrSessionState[newState] );

    // Clean up from the previous state
    switch( m_SessionState )
    {
        case SessionStateDeleted:
            //Reset();

            // Clear out our slots and update our presence info
            m_Slots[ SLOTS_FILLEDPUBLIC  ] = 0;
            m_Slots[ SLOTS_FILLEDPRIVATE ] = 0;
            m_Slots[ SLOTS_ZOMBIEPUBLIC ]  = 0;
            m_Slots[ SLOTS_ZOMBIEPRIVATE ] = 0;

            if( m_pRegistrationResults )
            {
                delete[] m_pRegistrationResults;
                m_pRegistrationResults = NULL;
            }
            break;

        case SessionStateMigratedHost:
            m_bIsMigratedSessionHost = FALSE;
            break;

        case SessionStateRegistering:
        case SessionStateInGame:
        case SessionStateNone:
        case SessionStateCreating:
        case SessionStateWaitingForRegistration:
        case SessionStateStarting:
        case SessionStateEnding:
        case SessionStateDeleting:
        default:
            break;
    }

    // Initialize the next state
    switch( newState )
    {
        case SessionStateCreated:
            if( !IsSessionHost() )
            {
                // Re-entering this state is a bad thing, since
                // that would wipe out the session nonce
                assert( m_SessionState != SessionStateCreated );
                
                // XSessionCreate would have
                // returned a 0 session nonce,
                // so set our session nonce
                // to a random value that we'll
                // replace once we get the
                // true nonce from the session host
                int retVal = XNetRandom( (BYTE *)&m_qwSessionNonce, sizeof( m_qwSessionNonce ) );
                if ( retVal )
                {
                    FatalError( "XNetRandom failed: %d\n", retVal );
                }
                DebugDumpSessionDetails();
            }
            break;

        case SessionStateMigratedHost:
            // Copy m_NewSessionInfo into m_SessionInfo
            // and zero out m_NewSessionInfo
            m_SessionInfo = m_NewSessionInfo; 
            ZeroMemory( &m_NewSessionInfo, sizeof( XSESSION_INFO ) );
            break;

        case SessionStateEnded:
            // If this is an arbitrated session, we might have slots occupied by zombies. Free up those slots
            // and zero out our zombie slot counts
            if( m_dwSessionFlags & XSESSION_CREATE_USES_ARBITRATION )
            {
                m_Slots[ SLOTS_FILLEDPRIVATE ] -= m_Slots[ SLOTS_ZOMBIEPRIVATE ];
                m_Slots[ SLOTS_FILLEDPRIVATE ] = max( m_Slots[ SLOTS_FILLEDPRIVATE ], 0 );

                m_Slots[ SLOTS_FILLEDPUBLIC ] -= m_Slots[ SLOTS_ZOMBIEPUBLIC ];
                m_Slots[ SLOTS_FILLEDPUBLIC ] = max( m_Slots[ SLOTS_FILLEDPUBLIC ], 0 );


                m_Slots[ SLOTS_ZOMBIEPRIVATE ] = 0;
                m_Slots[ SLOTS_ZOMBIEPUBLIC ]  = 0;
            }
            break;

        case SessionStateDeleted:
            if( ( m_hSession != INVALID_HANDLE_VALUE ) && 
                ( m_hSession != NULL ) )
            {
                XCloseHandle( m_hSession );
                m_hSession = NULL;
            }
            break;

        case SessionStateNone:
        case SessionStateIdle:
        case SessionStateWaitingForRegistration:
        case SessionStateRegistered:
        case SessionStateInGame:
        default:
            break;
    }

    m_SessionState = newState;
}

//------------------------------------------------------------------------
// Name: NotifyOverlappedOperationCancelled()
// Desc: Lets this instance know that the current overlapped operation
//       was cancelled.
//------------------------------------------------------------------------
HRESULT SessionManager::NotifyOverlappedOperationCancelled( const XOVERLAPPED* const pXOverlapped )
{
    //
    // Only certain states can be rolled back to the previous state
    switch( m_SessionState )
    {
    case SessionStateCreating:
        m_SessionState = SessionStateNone;
        break;
    case SessionStateRegistering:
        m_SessionState = SessionStateIdle;
        break;
    case SessionStateStarting:
        m_SessionState = HasSessionFlags( XSESSION_CREATE_USES_ARBITRATION ) ? SessionStateRegistered : SessionStateIdle;
        break;
    case SessionStateEnding:
        m_SessionState = SessionStateInGame;
        break;
    case SessionStateDeleting:
        m_SessionState = SessionStateEnded;
        break;
    }    

    return S_OK;
}


//------------------------------------------------------------------------
// Name: SwitchToPreHostMigrationState()
// Desc: Switches the current session state back to what it was
//       prior to host migration
//------------------------------------------------------------------------
VOID SessionManager::SwitchToPreHostMigrationState()
{
    // We can only transition to this state from SessionStateMigratedHost
    assert( m_SessionState == SessionStateMigratedHost );

    // Zero out m_migratedSessionID
    ZeroMemory( &m_migratedSessionID, sizeof( XNKID ) );

    // Return session state to what it was before migration started
    // and set m_migratedSessionState to a blank state
    m_SessionState           = m_migratedSessionState;
    m_migratedSessionState   = SessionStateNone;
    m_bIsMigratedSessionHost = FALSE;

    DebugDumpSessionDetails();
}


//------------------------------------------------------------------------
// Name: HasSessionFlags()
// Desc: Checks if passed-in flags are set for the current session
//------------------------------------------------------------------------
BOOL SessionManager::HasSessionFlags( const DWORD dwFlags )  const
{
    BOOL bHasFlags = FALSE;
    
    // What flags in m_dwSessionFlags and dwFlags are different?
    DWORD dwDiffFlags = m_dwSessionFlags ^ dwFlags;

    // If none of dwDiffFlags are in dwFlags,
    // we have a match
    if( ( dwDiffFlags & dwFlags ) == 0 )
    {
        bHasFlags = TRUE;
    }

    return bHasFlags;
}

//------------------------------------------------------------------------
// Name: FlipSessionFlags()
// Desc: XORs the state of the current session's
//       flags with that of the passed-in flags
//------------------------------------------------------------------------
VOID SessionManager::FlipSessionFlags( const DWORD dwFlags )
{ 
    m_dwSessionFlags ^= dwFlags;

    DebugSpew( "FlipSessionFlags: New session flags: %d\n", m_dwSessionFlags );
}

//------------------------------------------------------------------------
// Name: ClearSessionFlags()
// Desc: Clear the passed-in flags for the
//       current session
//------------------------------------------------------------------------
VOID SessionManager::ClearSessionFlags( const DWORD dwFlags )
{ 
    m_dwSessionFlags &= ~dwFlags; 

    DebugSpew( "ClearSessionFlags: New session flags: %d\n", m_dwSessionFlags );
}

//------------------------------------------------------------------------
// Name: SetSessionInfo()
// Desc: Set session info data. This only be called outside of an
//       active session
//------------------------------------------------------------------------
VOID SessionManager::SetSessionInfo( const XSESSION_INFO& session_info )
{
    SessionState actual = GetSessionState();
    if( m_SessionState > SessionStateCreating && m_SessionState < SessionStateDelete )
    {
        FatalError( "SessionManager instance in invalid state: %s\n", g_astrSessionState[actual] );
    }

    m_SessionInfo = session_info;
}

//------------------------------------------------------------------------
// Name: SetNewSessionInfo()
// Desc: Set session info data for the new session we will migrate this
//       session to. This only be called inside of an active session
//------------------------------------------------------------------------
VOID SessionManager::SetNewSessionInfo( const XSESSION_INFO& session_info,
                                        const BOOL bIsNewSessionHost )
{
    SessionState actual = GetSessionState();
    if( m_SessionState < SessionStateCreated || m_SessionState >= SessionStateDelete )
    {
        FatalError( "SessionManager instance in invalid state: %d\n", actual );
    }

    m_NewSessionInfo         = session_info;
    m_bIsMigratedSessionHost = bIsNewSessionHost;

    // Cache current session ID for a possible host migration scenario..
    memcpy( &m_migratedSessionID, &m_SessionInfo.sessionID, sizeof( XNKID ) ); 
}

//------------------------------------------------------------------------
// Name: SetSessionFlags()
// Desc: Set session flags. Optionally first clears all currently set 
//       flags. This only be called outside of an active session
//------------------------------------------------------------------------
VOID SessionManager::SetSessionFlags( const DWORD dwFlags, const BOOL fClearExisting  )
{
    SessionState actual = GetSessionState();
    if( m_SessionState > SessionStateCreating && m_SessionState < SessionStateDelete )
    {
        FatalError( "SessionManager instance in invalid state: %s\n", g_astrSessionState[actual] );
    }

    if( fClearExisting )
    {
        m_dwSessionFlags = 0;
    }

    m_dwSessionFlags |= dwFlags;

    DebugSpew( "SetSessionFlags: New session flags: %d\n", m_dwSessionFlags );
}

//------------------------------------------------------------------------
// Name: GetSessionFlags()
// Desc: Returns current session flags
//------------------------------------------------------------------------
DWORD SessionManager::GetSessionFlags()  const
{
    return m_dwSessionFlags;
}

//------------------------------------------------------------------------
// Name: GetSessionInfo()
// Desc: Returns current XSESSION_INFO
//------------------------------------------------------------------------
const XSESSION_INFO& SessionManager::GetSessionInfo() const
{
    return m_SessionInfo;
}

//------------------------------------------------------------------------
// Name: GetMaxSlotCounts()
// Desc: Returns current maximum slot counts
//------------------------------------------------------------------------
VOID SessionManager::GetMaxSlotCounts( DWORD& dwMaxPublicSlots, DWORD& dwMaxPrivateSlots )  const
{
    dwMaxPublicSlots  = m_Slots[SLOTS_TOTALPUBLIC];
    dwMaxPrivateSlots = m_Slots[SLOTS_TOTALPRIVATE];

//    DebugValidateExpectedSlotCounts();
}

//------------------------------------------------------------------------
// Name: GetFilledSlotCounts()
// Desc: Returns current filled slot counts
//------------------------------------------------------------------------
VOID SessionManager::GetFilledSlotCounts( DWORD& dwFilledPublicSlots, DWORD& dwFilledPrivateSlots ) const
{
    dwFilledPublicSlots  = m_Slots[SLOTS_FILLEDPUBLIC];
    dwFilledPrivateSlots = m_Slots[SLOTS_FILLEDPRIVATE];

//    DebugValidateExpectedSlotCounts();
}

//------------------------------------------------------------------------
// Name: SetMaxSlotCounts()
// Desc: Sets current maximum slot counts
//------------------------------------------------------------------------
VOID SessionManager::SetMaxSlotCounts( const DWORD dwMaxPublicSlots, const DWORD dwMaxPrivateSlots )
{
    #ifdef _DEBUG
    DebugSpew( "SetMaxSlotCounts(%016I64X): Old: [%d, %d, %d, %d]\n",
               XNKIDToInt64( m_SessionInfo.sessionID ),
               m_Slots[SLOTS_TOTALPUBLIC],
               m_Slots[SLOTS_TOTALPRIVATE],
               m_Slots[SLOTS_FILLEDPUBLIC],
               m_Slots[SLOTS_FILLEDPRIVATE]);
    #endif

    m_Slots[SLOTS_TOTALPUBLIC]  = dwMaxPublicSlots;
    m_Slots[SLOTS_TOTALPRIVATE] = dwMaxPrivateSlots;

    #ifdef _DEBUG
    DebugSpew( "SetMaxSlotCounts(%016I64X): New: [%d, %d, %d, %d]\n",
               XNKIDToInt64( m_SessionInfo.sessionID ),
               m_Slots[SLOTS_TOTALPUBLIC],
               m_Slots[SLOTS_TOTALPRIVATE],
               m_Slots[SLOTS_FILLEDPUBLIC],
               m_Slots[SLOTS_FILLEDPRIVATE]);
    #endif
}

//------------------------------------------------------------------------
// Name: SetFilledSlotCounts()
// Desc: Sets current filled slot counts
//------------------------------------------------------------------------
VOID SessionManager::SetFilledSlotCounts( const DWORD dwFilledPublicSlots, DWORD dwFilledPrivateSlots )
{
    #ifdef _DEBUG
    DebugSpew( "SetFilledSlotCounts(%016I64X): Old: [%d, %d, %d, %d]\n",
               XNKIDToInt64( m_SessionInfo.sessionID ),
               m_Slots[SLOTS_TOTALPUBLIC],
               m_Slots[SLOTS_TOTALPRIVATE],
               m_Slots[SLOTS_FILLEDPUBLIC],
               m_Slots[SLOTS_FILLEDPRIVATE]);               
    #endif

    m_Slots[SLOTS_FILLEDPUBLIC]  = dwFilledPublicSlots;
    m_Slots[SLOTS_FILLEDPRIVATE] = dwFilledPrivateSlots;

    #ifdef _DEBUG
    DebugSpew( "SetFilledSlotCounts(%016I64X): New: [%d, %d, %d, %d]\n",
               XNKIDToInt64( m_SessionInfo.sessionID ),
               m_Slots[SLOTS_TOTALPUBLIC],
               m_Slots[SLOTS_TOTALPRIVATE],
               m_Slots[SLOTS_FILLEDPUBLIC],
               m_Slots[SLOTS_FILLEDPRIVATE]);
    #endif
}

//------------------------------------------------------------------------
// Name: GetSessionError()
// Desc: Returns session error string
//------------------------------------------------------------------------
WCHAR* SessionManager::GetSessionError()  const
{
    return m_strSessionError;
}

//------------------------------------------------------------------------
// Name: SetSessionError()
// Desc: Sets session error string
//------------------------------------------------------------------------
VOID SessionManager::SetSessionError( WCHAR* error )
{
    m_strSessionError = error;
}


//--------------------------------------------------------------------------------------
// Name: StartQoSListener()
// Desc: Turn on the Quality of Service Listener for the current session
//--------------------------------------------------------------------------------------
VOID SessionManager::StartQoSListener( BYTE* data, const UINT dataLen, const DWORD bitsPerSec )
{
    DWORD flags = XNET_QOS_LISTEN_SET_DATA;
    if( bitsPerSec )
    {
        flags |= XNET_QOS_LISTEN_SET_BITSPERSEC;
    }
    if( !m_bUsingQoS )
    {
        flags |= XNET_QOS_LISTEN_ENABLE;
    }
    DWORD dwRet;
    dwRet = XNetQosListen( &( m_SessionInfo.sessionID ), data, dataLen, bitsPerSec, flags );
    if( ERROR_SUCCESS != dwRet )
    {
        FatalError( "Failed to start QoS listener, error 0x%08x\n", dwRet );
    }
    m_bUsingQoS = TRUE;
}


//--------------------------------------------------------------------------------------
// Name: StopQoSListener()
// Desc: Turn off the Quality of Service Listener for the current session
//--------------------------------------------------------------------------------------
VOID SessionManager::StopQoSListener()
{
    if( m_bUsingQoS )
    {
        DWORD dwRet;
        dwRet = XNetQosListen( &( m_SessionInfo.sessionID ), NULL, 0, 0,
                               XNET_QOS_LISTEN_RELEASE );
        if( ERROR_SUCCESS != dwRet )
        {
            DebugSpew( "Warning: Failed to stop QoS listener, error 0x%08x\n", dwRet );
        }
        m_bUsingQoS = FALSE;
    }
}

//------------------------------------------------------------------------
// Name: CreateSession()
// Desc: Creates a session
//------------------------------------------------------------------------
HRESULT SessionManager::CreateSession( XOVERLAPPED* pXOverlapped )
{
    // Make sure our instance is in the right state
    SessionState actual = GetSessionState();
    if( actual != SessionStateNone && actual != SessionStateDeleted  )
    {
        FatalError( "Wrong state: %s\n", g_astrSessionState[actual] );
    }

    // Modify session flags if host
    if( m_bIsHost )
    {
        m_dwSessionFlags |= XSESSION_CREATE_HOST;
    }
    else
    {
        // Turn off host bit
        m_dwSessionFlags &= ~XSESSION_CREATE_HOST;
    }

    // If we're just in a Matchmaking session, we can only specify the 
    // XSESSION_CREATE_JOIN_IN_PROGRESS_DISABLED modifier
    if( !( m_dwSessionFlags & XSESSION_CREATE_USES_PRESENCE ) && 
         ( m_dwSessionFlags & XSESSION_CREATE_USES_MATCHMAKING ) && 
         ( m_dwSessionFlags & XSESSION_CREATE_MODIFIERS_MASK ) )
    {
        // turn off all modifiers
        m_dwSessionFlags &= ~XSESSION_CREATE_MODIFIERS_MASK;

        // turn on XSESSION_CREATE_JOIN_IN_PROGRESS_DISABLED
        m_dwSessionFlags |= XSESSION_CREATE_JOIN_IN_PROGRESS_DISABLED;
    }

    // Call XSessionCreate
    DWORD ret = XSessionCreate( m_dwSessionFlags,
                                m_dwOwnerController,
                                m_Slots[SLOTS_TOTALPRIVATE],
                                m_Slots[SLOTS_TOTALPUBLIC],
                                &m_qwSessionNonce,
                                &m_SessionInfo,
                                pXOverlapped,
                                &m_hSession );

    if( pXOverlapped && ( ret == ERROR_IO_PENDING ) )
    {
        SwitchToState( SessionStateCreating );
    }
    else if( !pXOverlapped )
    {
        SwitchToState( SessionStateCreated );
    }

    return HRESULT_FROM_WIN32( ret );
}

//------------------------------------------------------------------------
// Name: StartSession()
// Desc: Starts the current session
//------------------------------------------------------------------------
HRESULT SessionManager::StartSession( XOVERLAPPED* pXOverlapped )
{
    DWORD ret = XSessionStart( m_hSession,
                               0,
                               pXOverlapped );

    if( pXOverlapped && ( ret == ERROR_IO_PENDING ) )
    {
        SwitchToState( SessionStateStarting );
    }
    else if( !pXOverlapped )
    {
        SwitchToState( SessionStateInGame );
    }

    return HRESULT_FROM_WIN32( ret );
}

//------------------------------------------------------------------------
// Name: EndSession()
// Desc: Ends the current session
//------------------------------------------------------------------------
HRESULT SessionManager::EndSession( XOVERLAPPED* pXOverlapped )
{
    DWORD ret = XSessionEnd( m_hSession, pXOverlapped );

    if( pXOverlapped && ( ret == ERROR_IO_PENDING ) )
    {
        SwitchToState( SessionStateEnding );
    }
    else if( !pXOverlapped )
    {
        SwitchToState( SessionStateEnded );
    }

    return HRESULT_FROM_WIN32( ret );
}

//------------------------------------------------------------------------
// Name: DeleteSession()
// Desc: Deletes the current session
//------------------------------------------------------------------------
HRESULT SessionManager::DeleteSession( XOVERLAPPED* pXOverlapped )
{
    // Make sure our instance is in the right state
    SessionState actual = GetSessionState();
    if( actual < SessionStateCreated )
    {
        FatalError( "Wrong state: %s\n", g_astrSessionState[actual] );
    }

    SwitchToState( SessionStateDelete );

    // Stop QoS listener if it's running
    StopQoSListener();

    // Call XSessionDelete
    DWORD ret = XSessionDelete( m_hSession, pXOverlapped );

    if( pXOverlapped && ( ret == ERROR_IO_PENDING ) )
    {
        SwitchToState( SessionStateDeleting );
    }
    else if( !pXOverlapped )
    {
        SwitchToState( SessionStateDeleted );
    }

    return HRESULT_FROM_WIN32( ret );
}


//------------------------------------------------------------------------
// Name: MigrateSession()
// Desc: Migrates the current session
//------------------------------------------------------------------------
HRESULT SessionManager::MigrateSession( XOVERLAPPED* pXOverlapped )
{
    // Make sure our instance is in the right state
    SessionState actual = GetSessionState();
    if( actual < SessionStateCreated || actual >= SessionStateDelete  )
    {
        FatalError( "Wrong state: %s\n", g_astrSessionState[actual] );
    }

    m_migratedSessionState = m_SessionState;

    DWORD ret = XSessionMigrateHost( m_hSession,
                                     ( m_bIsMigratedSessionHost ) ? m_dwOwnerController : XUSER_INDEX_NONE,
                                     &m_NewSessionInfo,
                                     pXOverlapped );

    if( pXOverlapped && ( ret == ERROR_IO_PENDING ) )
    {
        SwitchToState( SessionStateMigratingHost );
    }
    else if( !pXOverlapped )
    {
        SwitchToState( SessionStateMigratedHost );
    }

    return HRESULT_FROM_WIN32( ret );
}

//------------------------------------------------------------------------
// Name: ModifySessionFlags()
// Desc: Modifies session flags
//------------------------------------------------------------------------
HRESULT SessionManager::ModifySessionFlags( const DWORD dwFlags, 
                                                                              const BOOL bClearFlags,
                                                                              XOVERLAPPED* pXOverlapped )
{
    SessionState actual = GetSessionState();
    if( m_SessionState <= SessionStateCreating || m_SessionState >= SessionStateDelete )
    {
        FatalError( "SessionManager instance in invalid state: %s\n", g_astrSessionState[actual] );
    }

    DWORD dwNewFlags = dwFlags;

    // If no flags in the modifiers mask are specified, do nothing
    if( ( dwNewFlags & XSESSION_CREATE_MODIFIERS_MASK ) == 0 )
    {
        return ERROR_SUCCESS;
    }

    // Flags cannot be modified for arbitrated sessions
    if( m_dwSessionFlags & XSESSION_CREATE_USES_ARBITRATION )
    {
        return ERROR_SUCCESS;
    }

    // Add host bit to dwFlags if host; otherwise remove
    if( m_bIsHost )
    {
        dwNewFlags |= XSESSION_CREATE_HOST;
    }
    else
    {
        // Turn off host bit
        dwNewFlags &= ~XSESSION_CREATE_HOST;
    }

    // Apply allowable session modifier flags to our session flags
    if( bClearFlags )
    {
        m_dwSessionFlags ^= dwNewFlags & MODIFY_FLAGS_ALLOWED;
    }
    else
    {
        m_dwSessionFlags |= dwNewFlags & MODIFY_FLAGS_ALLOWED;
    }

    // Re-insert host bit if host
    if( m_bIsHost )
    {
        m_dwSessionFlags |= XSESSION_CREATE_HOST;
    }

    DebugSpew( "ProcessModifySessionFlagsMessage: New session flags: %d\n", m_dwSessionFlags );

    DWORD ret = XSessionModify( m_hSession,
                                m_dwSessionFlags,
                                m_Slots[SLOTS_TOTALPUBLIC],
                                m_Slots[SLOTS_TOTALPRIVATE],
                                pXOverlapped );

    return HRESULT_FROM_WIN32( ret );
}

//------------------------------------------------------------------------
// Name: ModifySkill()
// Desc: Modifies TrueSkill(TM)
//------------------------------------------------------------------------
HRESULT SessionManager::ModifySkill( const DWORD dwNumXuids, 
                                     const XUID* pXuids, 
                                     XOVERLAPPED* pXOverlapped )
{
    SessionState actual = GetSessionState();
    if( m_SessionState <= SessionStateCreating || m_SessionState >= SessionStateDelete )
    {
        FatalError( "SessionManager instance in invalid state: %s\n", g_astrSessionState[actual] );
    }

    DWORD ret = XSessionModifySkill( m_hSession,
                                     dwNumXuids,
                                     pXuids,
                                     pXOverlapped );

    return HRESULT_FROM_WIN32( ret );
}

//------------------------------------------------------------------------
// Name: RegisterArbitration()
// Desc: Registers the current session for arbitration
//------------------------------------------------------------------------
HRESULT SessionManager::RegisterArbitration( XOVERLAPPED* pXOverlapped )
{
    SessionState actual = GetSessionState();
    if( actual < SessionStateCreated || actual >= SessionStateStarting )
    {
        FatalError( "Wrong state: %s\n", g_astrSessionState[actual] );
    }

    // Call once to determine size of results buffer
    DWORD cbRegistrationResults = 0;

    DWORD ret = XSessionArbitrationRegister( m_hSession,
                                             0,
                                             m_qwSessionNonce,
                                             &cbRegistrationResults,
                                             NULL,
                                             NULL ); 

    if( ( ret != ERROR_INSUFFICIENT_BUFFER ) || ( cbRegistrationResults == 0 ) )
    {
        DebugSpew( "Failed on first call to XSessionArbitrationRegister, hr=0x%08x\n", ret );
        return ERROR_FUNCTION_FAILED;
    }

    m_pRegistrationResults = (PXSESSION_REGISTRATION_RESULTS)new BYTE[cbRegistrationResults];
    if( m_pRegistrationResults == NULL )
    {
        DebugSpew( "Failed to allocate buffer.\n" );
        return ERROR_FUNCTION_FAILED;
    }

    // Call second time to fill our results buffer
    ret = XSessionArbitrationRegister( m_hSession,
                                       0,
                                       m_qwSessionNonce,
                                       &cbRegistrationResults,
                                       m_pRegistrationResults,
                                       pXOverlapped ); 

    if( pXOverlapped && ( ret == ERROR_IO_PENDING ) )
    {
        SwitchToState( SessionStateRegistering );
    }
    else if( !pXOverlapped )
    {
        SwitchToState( SessionStateRegistered );
    }

    return HRESULT_FROM_WIN32( ret );
}

//------------------------------------------------------------------------
// Name: AddLocalPlayers()
// Desc: Add local players to the session
//------------------------------------------------------------------------
HRESULT SessionManager::AddLocalPlayers( const DWORD dwUserCount,
                                         DWORD* pdwUserIndices,
                                         const BOOL* pfPrivateSlots,
                                         XOVERLAPPED* pXOverlapped )
{
    SessionState actual = GetSessionState();
    if( actual < SessionStateCreating || actual >= SessionStateDelete )
    {
        FatalError( "Wrong state: %s\n", g_astrSessionState[actual] );
    }

    DWORD ret = ERROR_SUCCESS;

    // Do nothing if the session is already deleted
    if( m_SessionState == SessionStateDeleted )
    {
        return HRESULT_FROM_WIN32( ret );
    }

    for ( DWORD  i = 0; i < dwUserCount; ++i )
    {
        XUID xuid;
        XUserGetXUID( pdwUserIndices[i], &xuid );

        DebugSpew( "Processing local user: index: %d; xuid: 0x%016I64X; bInvited: %d\n", 
                   pdwUserIndices[ i ], xuid, pfPrivateSlots[ i ] );

        // If xuid is already in the session, don't re-add
        if( IsPlayerInSession( xuid ) )
        {
            pdwUserIndices[ i ] = XUSER_INDEX_NONE;
        }
    }

    ret = XSessionJoinLocal( m_hSession,
                             dwUserCount,
                             pdwUserIndices,
                             pfPrivateSlots,
                             pXOverlapped );


    // Update slot counts
    for ( DWORD i = 0; i < dwUserCount; ++i )
    {
        m_Slots[ SLOTS_FILLEDPRIVATE ] += ( pfPrivateSlots[ i ] ) ? 1 : 0;
        m_Slots[ SLOTS_FILLEDPUBLIC ] += ( pfPrivateSlots[ i ] ) ? 0 : 1;
    }

    if( m_Slots[ SLOTS_FILLEDPRIVATE ] > m_Slots[ SLOTS_TOTALPRIVATE ] )
    {
        DWORD diff = m_Slots[ SLOTS_FILLEDPRIVATE ] - m_Slots[ SLOTS_TOTALPRIVATE ];
        m_Slots[ SLOTS_FILLEDPUBLIC ] += diff;

        assert( m_Slots[ SLOTS_FILLEDPUBLIC ] <= m_Slots[ SLOTS_TOTALPUBLIC ] );
        if( m_Slots[ SLOTS_FILLEDPUBLIC ] > m_Slots[ SLOTS_TOTALPUBLIC ] )
        {
            FatalError( "Too many slots filled!\n" );
        }

        m_Slots[ SLOTS_FILLEDPRIVATE ] = m_Slots[ SLOTS_TOTALPRIVATE ];
    }

    DebugDumpSessionDetails();
    DebugValidateExpectedSlotCounts();

    return HRESULT_FROM_WIN32( ret );
}

//------------------------------------------------------------------------
// Name: AddRemotePlayers()
// Desc: Adds remote players to the session
//------------------------------------------------------------------------
HRESULT SessionManager::AddRemotePlayers( const DWORD dwXuidCount,
                                          XUID* pXuids,
                                          const BOOL* pfPrivateSlots,
                                          XOVERLAPPED* pXOverlapped )
{
    SessionState actual = GetSessionState();
    if( actual < SessionStateCreating || actual >= SessionStateDelete )
    {
        FatalError( "Wrong state: %s\n", g_astrSessionState[actual] );
    }

    for ( DWORD i=0; i<dwXuidCount; ++i )
    {
        DebugSpew( "AddRemotePlayers: 0x%016I64X; bInvited: %d\n", pXuids[ i ], pfPrivateSlots[ i ] );
    }

    DWORD ret = ERROR_SUCCESS;

    // Do nothing if the session is already deleted
    if( m_SessionState == SessionStateDeleted )
    {
        return HRESULT_FROM_WIN32( ret );
    }

    for ( DWORD  i = 0; i < dwXuidCount; ++i )
    {
        DebugSpew( "Processing remote user: 0x%016I64X; bInvited: %d\n", 
                   pXuids[ i ], pfPrivateSlots[ i ] );

        // If msg.m_pXuids[ i ] is already in the session, don't re-add
        if( IsPlayerInSession( pXuids[ i ] ) )
        {
            pXuids[ i ] = INVALID_XUID;

            DebugSpew( "Remote user: 0x%016I64X already in the session!\n", 
                       pXuids[ i ] );
        }
    }

    ret = XSessionJoinRemote( m_hSession,
                              dwXuidCount,
                              pXuids,
                              pfPrivateSlots,
                              pXOverlapped );

    // Update slot counts
    for ( DWORD i = 0; i < dwXuidCount; ++i )
    {
        m_Slots[ SLOTS_FILLEDPRIVATE ] += ( pfPrivateSlots[ i ] ) ? 1 : 0;
        m_Slots[ SLOTS_FILLEDPUBLIC ]  += ( pfPrivateSlots[ i ] ) ? 0 : 1;
    }

    if( m_Slots[ SLOTS_FILLEDPRIVATE ] > m_Slots[ SLOTS_TOTALPRIVATE ] )
    {
        DWORD diff = m_Slots[ SLOTS_FILLEDPRIVATE ] - m_Slots[ SLOTS_TOTALPRIVATE ];
        m_Slots[ SLOTS_FILLEDPUBLIC ] += diff;

        assert( m_Slots[ SLOTS_FILLEDPUBLIC ] <= m_Slots[ SLOTS_TOTALPUBLIC ] );
        if( m_Slots[ SLOTS_FILLEDPUBLIC ] > m_Slots[ SLOTS_TOTALPUBLIC ] )
        {
            FatalError( "Too many slots filled!\n" );
        }

        m_Slots[ SLOTS_FILLEDPRIVATE ] = m_Slots[ SLOTS_TOTALPRIVATE ];
    }

    DebugDumpSessionDetails();
    DebugValidateExpectedSlotCounts();

    return HRESULT_FROM_WIN32( ret );
}

//------------------------------------------------------------------------
// Name: RemoveLocalPlayers()
// Desc: Add local players to the session
//------------------------------------------------------------------------
HRESULT SessionManager::RemoveLocalPlayers( const DWORD dwUserCount,
                                            const DWORD* pdwUserIndices,
                                            const BOOL* pfPrivateSlots,
                                            XOVERLAPPED* pXOverlapped )
{
    SessionState actual = GetSessionState();
    if( actual < SessionStateCreated || actual >= SessionStateDelete )
    {
        FatalError( "Wrong state: %s\n", g_astrSessionState[actual] );
    }

    DWORD ret = ERROR_SUCCESS;

    // Do nothing if the session is already deleted
    if( m_SessionState == SessionStateDeleted )
    {
        return HRESULT_FROM_WIN32( ret );
    }

    #ifdef _DEBUG
    for( DWORD i = 0; i < dwUserCount; ++i )
    {
        XUID xuid;
        XUserGetXUID( i, &xuid );
        DebugSpew( "%016I64X: ProcessRemoveLocalPlayerMessage: 0x%016I64X\n", 
                   GetSessionIDAsInt(), 
                   xuid );
    }
    #endif

    ret = XSessionLeaveLocal( m_hSession,
                              dwUserCount,
                              pdwUserIndices,
                              pXOverlapped );

    // If the session is arbitrated and gameplay is happening, then the player will still be
    // kept in the session so stats can be reported, so we don't want to modify our slot counts
    const BOOL bPlayersKeptForStatsReporting = ( ( m_dwSessionFlags & XSESSION_CREATE_USES_ARBITRATION ) && 
                                                 ( m_SessionState == SessionStateInGame ) );

    if( !bPlayersKeptForStatsReporting )
    {
        for ( DWORD i = 0; i < dwUserCount; ++i )
        {
            m_Slots[ SLOTS_FILLEDPRIVATE ] -= ( pfPrivateSlots[ i ] ) ? 1 : 0;
            m_Slots[ SLOTS_FILLEDPUBLIC ]  -= ( pfPrivateSlots[ i ] ) ? 0 : 1;

            m_Slots[ SLOTS_FILLEDPRIVATE ] = max( m_Slots[ SLOTS_FILLEDPRIVATE ], 0 );
            m_Slots[ SLOTS_FILLEDPUBLIC ]  = max( m_Slots[ SLOTS_FILLEDPUBLIC ], 0 );
        }
    }
    else
    {
        DebugSpew( "%016I64X: ProcessRemoveLocalPlayerMessage: Arbitrated session, so leaving players become zombies and not updating local slot counts\n", 
                   GetSessionIDAsInt() );

        for ( DWORD i = 0; i < dwUserCount; ++i )
        {
            m_Slots[ SLOTS_ZOMBIEPRIVATE ] += ( pfPrivateSlots[ i ] ) ? 1 : 0;
            m_Slots[ SLOTS_ZOMBIEPUBLIC ]  += ( pfPrivateSlots[ i ] ) ? 0 : 1;
        }
    }

    DebugDumpSessionDetails();
    DebugValidateExpectedSlotCounts();

    return HRESULT_FROM_WIN32( ret );
}

//------------------------------------------------------------------------
// Name: RemoveRemotePlayers()
// Desc: Remove remote players to the session
//------------------------------------------------------------------------
HRESULT SessionManager::RemoveRemotePlayers( const DWORD dwXuidCount,
                                             const XUID* pXuids,
                                             const BOOL* pfPrivateSlots,
                                             XOVERLAPPED* pXOverlapped )
{
    SessionState actual = GetSessionState();
    if( actual < SessionStateCreated || actual >= SessionStateDelete )
    {
        FatalError( "Wrong state: %s\n", g_astrSessionState[actual] );
    }

    #ifdef _DEBUG
    for( DWORD i = 0; i < dwXuidCount; ++i )
    {
        DebugSpew( "%016I64X: ProcessRemoveRemotePlayerMessage: 0x%016I64X\n", 
                   GetSessionIDAsInt(), 
                   pXuids[i] );
    }
    #endif

    DWORD ret = XSessionLeaveRemote( m_hSession,
                                     dwXuidCount,
                                     pXuids,
                                     pXOverlapped );

    {
        // If the session is arbitrated and gameplay is happening, then the player will still be
        // kept in the session so stats can be reported, so we don't want to modify our slot counts
        const BOOL bPlayersKeptForStatsReporting = ( ( m_dwSessionFlags & XSESSION_CREATE_USES_ARBITRATION ) && 
                                                     ( m_SessionState == SessionStateInGame ) );

        if( !bPlayersKeptForStatsReporting )
        {
            for ( DWORD i = 0; i < dwXuidCount; ++i )
            {
                m_Slots[ SLOTS_FILLEDPRIVATE ] -= ( pfPrivateSlots[ i ] ) ? 1 : 0;
                m_Slots[ SLOTS_FILLEDPUBLIC ]  -= ( pfPrivateSlots[ i ] ) ? 0 : 1;

                m_Slots[ SLOTS_FILLEDPRIVATE ] = max( m_Slots[ SLOTS_FILLEDPRIVATE ], 0 );
                m_Slots[ SLOTS_FILLEDPUBLIC ]  = max( m_Slots[ SLOTS_FILLEDPUBLIC ], 0 );
            }
        }
        else
        {
            DebugSpew( "%016I64X: ProcessRemoveRemotePlayerMessage: Arbitrated session, so leaving players become zombies and not updating local slot counts\n", 
                       GetSessionIDAsInt() );

            for ( DWORD i = 0; i < dwXuidCount; ++i )
            {
                m_Slots[ SLOTS_ZOMBIEPRIVATE ] += ( pfPrivateSlots[ i ] ) ? 1 : 0;
                m_Slots[ SLOTS_ZOMBIEPUBLIC ]  += ( pfPrivateSlots[ i ] ) ? 0 : 1;
            }
        }
    }

    DebugDumpSessionDetails();
    DebugValidateExpectedSlotCounts();

    return HRESULT_FROM_WIN32( ret );
}


//------------------------------------------------------------------------
// Name: WriteStats()
// Desc: Write stats for a player in the session
//------------------------------------------------------------------------
HRESULT SessionManager::WriteStats( const XUID xuid,
                                    const DWORD dwNumViews,
                                    const XSESSION_VIEW_PROPERTIES *pViews,
                                    XOVERLAPPED* pXOverlapped )
{
    SessionState actual = GetSessionState();
    if( actual < SessionStateInGame || actual >= SessionStateEnding )
    {
        FatalError( "Wrong state: %s\n", g_astrSessionState[actual] );
    }

    DebugSpew( "%016I64X: ProcessWriteStatsMessage: 0x%016I64X\n", 
               GetSessionIDAsInt(), 
               xuid );

    DWORD ret = XSessionWriteStats( m_hSession,
                                    xuid,
                                    dwNumViews,
                                    pViews,
                                    pXOverlapped );

    return HRESULT_FROM_WIN32( ret );
}

```

`XenonDumper/libs/Atg/AtgSessionManager.h`:

```h
//-----------------------------------------------------------------------------
// AtgSessionManager.h
//
// Class for managing all session-related activity for a single
// XSession instance
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------------------
const DWORD MODIFY_FLAGS_ALLOWED = XSESSION_CREATE_USES_ARBITRATION |
                                   XSESSION_CREATE_INVITES_DISABLED |
                                   XSESSION_CREATE_JOIN_VIA_PRESENCE_DISABLED |
                                   XSESSION_CREATE_JOIN_IN_PROGRESS_DISABLED;

//------------------------------------------------------------------------
// Name: enum SessionState
// Desc: Session state enumeration       
//------------------------------------------------------------------------
enum SessionState
{
    SessionStateNone,
    SessionStateCreate,                 // XSessionCreate task created
    SessionStateCreating,               // XSessionCreate has been called
    SessionStateCreated,                // XSessionCreate has returned
    SessionStateIdle,                   // Session waiting for prompts
    SessionStateWaitingForRegistration, // Session waiting to register with arbitration
    SessionStateRegister,               // XSessionArbitrationRegister task created
    SessionStateRegistering,            // XSessionArbitrationRegister has been called
    SessionStateRegistered,             // XSessionArbitrationRegiste has returned
    SessionStateStart,                  // XSessionStart task created
    SessionStateStarting,               // XSessionStart has been called
    SessionStateInGame,                 // XSessionStart has returned
    SessionStateMigrateHost,            // XSessionMigrateHost task created
    SessionStateMigratingHost,          // XSessionMigrateHost has been called
    SessionStateMigratedHost,           // XSessionMigrateHost has returned
    SessionStateEnd,                    // XSessionEnd task created
    SessionStateEnding,                 // XSessionEnd has been called
    SessionStateEnded,                  // XSessionEnd has returned
    SessionStateDelete,                 // XSessionDelete task created
    SessionStateDeleting,               // XSessionDelete has been called, session is invalid
    SessionStateDeleted,                // XSessionDelete has returned, session is invalid
    SessionStateCount,                  // Count of SessionState enumeration values
};

static const char* g_astrSessionState[SessionStateCount] =
{
    "SessionStateNone",
    "SessionStateCreate",                 // XSessionCreate task created
    "SessionStateCreating",               // XSessionCreate has been called
    "SessionStateCreated",                // XSessionCreate has returned
    "SessionStateIdle",                   // Session waiting for prompts
    "SessionStateWaitingForRegistration", // Session waiting to register with arbitration
    "SessionStateRegister",               // XSessionArbitrationRegister task created
    "SessionStateRegistering",            // XSessionArbitrationRegister has been called
    "SessionStateRegistered",             // XSessionArbitrationRegiste has returned
    "SessionStateStart",                  // XSessionStart task created
    "SessionStateStarting",               // XSessionStart has been called
    "SessionStateInGame",                 // XSessionStart has returned
    "SessionStateMigrateHost",            // XSessionMigrateHost task created
    "SessionStateMigratingHost",          // XSessionMigrateHost has been called
    "SessionStateMigratedHost",           // XSessionMigrateHost has returned
    "SessionStateEnd",                    // XSessionEnd task created
    "SessionStateEnding",                 // XSessionEnd has been called
    "SessionStateEnded",                  // XSessionEnd has returned
    "SessionStateDelete",                 // XSessionDelete task created
    "SessionStateDeleting",               // XSessionDelete has been called, session is invalid
    "SessionStateDeleted"                 // XSessionDelete has returned, session is invalid
};


//------------------------------------------------------------------------
// Name: enum SessionState
// Desc: Slot types for the session       
//------------------------------------------------------------------------
typedef enum _SLOTS
{
    SLOTS_TOTALPUBLIC,
    SLOTS_TOTALPRIVATE,
    SLOTS_FILLEDPUBLIC,
    SLOTS_FILLEDPRIVATE,
    SLOTS_ZOMBIEPUBLIC,
    SLOTS_ZOMBIEPRIVATE,
    SLOTS_MAX
} SLOTS;

//------------------------------------------------------------------------
// Name: enum SessionCreationType
// Desc: Enum to track the reason for creation of this SessionManager instance
//------------------------------------------------------------------------
enum SessionCreationReason
{
    SessionCreationReasonNone,
    SessionCreationReasonAmbiguous,
    SessionCreationReasonHosting,
    SessionCreationReasonJoinFromSearch
};

//------------------------------------------------------------------------
// Name: struct SessionManagerInitParams
// Desc: Initialization parameters       
//------------------------------------------------------------------------
struct SessionManagerInitParams
{
    SessionCreationReason           m_SessionCreationReason;                
    DWORD                           m_dwSessionFlags;
    BOOL                            m_bIsHost;
    UINT                            m_dwMaxPublicSlots;
    UINT                            m_dwMaxPrivateSlots;
};

//--------------------------------------------------------------------------------------
// Name: class SessionManager
// Desc: Class for managing all XSession-related calls for a single LIVE session. 
//--------------------------------------------------------------------------------------
class SessionManager
{
public:

    SessionManager( VOID );
    virtual ~SessionManager( VOID );

    BOOL Initialize( SessionManagerInitParams initParams );
    BOOL IsInitialized( VOID );

    SessionCreationReason GetSessionCreationReason( VOID ) const;

    DWORD GetSessionOwner( VOID ) const;
    XUID GetSessionOwnerXuid( VOID ) const;
    VOID SetSessionOwner( const DWORD dwOwnerController );
    BOOL IsSessionOwner( const DWORD dwController ) const;
    BOOL IsSessionOwner( const XUID xuidOwner ) const;
    BOOL IsPlayerInSession( const XUID xuidPlayer, const DWORD dwUserIndex = (DWORD)-1 ) const;

    BOOL IsSessionHost( VOID ) const;
    VOID MakeSessionHost( VOID );

    ULONGLONG GetSessionNonce( VOID ) const;
    VOID SetSessionNonce( const ULONGLONG qwNonce );

    VOID SetHostInAddr( const IN_ADDR& inaddr );
    IN_ADDR GetHostInAddr( VOID ) const;

    XNKID GetSessionID( VOID ) const;
    __int64 GetSessionIDAsInt( VOID ) const;
    XNKID GetMigratedSessionID( VOID ) const;

    BOOL HasSessionFlags( const DWORD dwFlags ) const;
    DWORD GetSessionFlags( VOID ) const;

    VOID GetMaxSlotCounts( DWORD& dwMaxPublicSlots, DWORD& dwMaxPrivateSlots ) const;
    VOID GetFilledSlotCounts( DWORD& dwFilledPublicSlots, DWORD& dwFilledPrivateSlots ) const;

    VOID SetMaxSlotCounts( const DWORD dwMaxPublicSlots, const DWORD dwMaxPrivateSlots );
    VOID SetFilledSlotCounts( const DWORD dwFilledPublicSlots, const DWORD dwFilledPrivateSlots );

    const XSESSION_INFO& GetSessionInfo( VOID ) const;
    VOID SetSessionInfo( const XSESSION_INFO& session_info );
    VOID SetNewSessionInfo( const XSESSION_INFO& session_info, const BOOL bIsNewSessionHost );

    VOID SetSessionFlags( const DWORD dwFlags, const BOOL fClearExisting = FALSE );
    VOID FlipSessionFlags( const DWORD dwFlags );
    VOID ClearSessionFlags( const DWORD dwFlags );

    WCHAR* GetSessionError( VOID ) const;
    VOID SetSessionError( WCHAR* error );

    SessionState GetSessionState( VOID ) const;
    const char* GetSessionStateString( VOID ) const;
    VOID SwitchToState( const SessionState newState );
    VOID SwitchToPreHostMigrationState();

    const PXSESSION_REGISTRATION_RESULTS GetRegistrationResults() const;

    VOID StartQoSListener( BYTE* data, const UINT dataLen, const DWORD bitsPerSec );

    BOOL IsProcessingOverlappedOperation( VOID ) const;
    DWORD GetOverlappedExtendedError( VOID ) const;

    BOOL IsSessionDeleted() const;

    VOID DebugDumpSessionDetails( VOID ) const;

    BOOL DebugValidateExpectedSlotCounts( const BOOL bBreakOnDifferent = TRUE ) const;

    //
    // Following functions call XSession APIs synchronously or asynchronously
    //
    HRESULT CreateSession( XOVERLAPPED* pXOverlapped = NULL );
    HRESULT StartSession( XOVERLAPPED* pXOverlapped = NULL );
    HRESULT EndSession( XOVERLAPPED* pXOverlapped = NULL );    
    HRESULT DeleteSession( XOVERLAPPED* pXOverlapped = NULL );

    HRESULT AddLocalPlayers( const DWORD dwUserCount,
                             DWORD* pdwUserIndices,
                             const BOOL* pfPrivateSlots,
                             XOVERLAPPED* pXOverlapped = NULL );

    HRESULT AddRemotePlayers( const DWORD dwXuidCount,
                              XUID* pXuids,
                              const BOOL* pfPrivateSlots,
                              XOVERLAPPED* pXOverlapped = NULL );

    HRESULT RemoveLocalPlayers( const DWORD dwUserCount,
                                const DWORD* pdwUserIndices,
                                const BOOL* pfPrivateSlots,
                                XOVERLAPPED* pXOverlapped = NULL );

    HRESULT RemoveRemotePlayers( const DWORD dwXuidCount,
                                 const XUID* pXuids,
                                 const BOOL* pfPrivateSlots,
                                 XOVERLAPPED* pXOverlapped = NULL );

    HRESULT ModifySkill( const DWORD dwNumXuids, const XUID* pXuids, XOVERLAPPED* pXOverlapped = NULL );

    HRESULT ModifySessionFlags( const DWORD dwFlags, const BOOL bClearFlags = FALSE, XOVERLAPPED* pXOverlapped = NULL );

    HRESULT WriteStats( const XUID xuid, const DWORD dwNumViews, const XSESSION_VIEW_PROPERTIES *pViews, XOVERLAPPED* pXOverlapped = NULL );

    HRESULT MigrateSession( XOVERLAPPED* pXOverlapped = NULL );

    HRESULT RegisterArbitration( XOVERLAPPED* pXOverlapped = NULL );

    HRESULT NotifyOverlappedOperationCancelled( const XOVERLAPPED* const pXOverlapped );

protected:
    VOID Reset( VOID );
    VOID SetSessionState( const SessionState newState );
    BOOL CheckSessionState( const SessionState expectedState ) const;
    VOID StopQoSListener();
    
private:
    SessionManager& operator=( const SessionManager& ref ) {}

protected:
    SessionCreationReason   m_SessionCreationReason;    // Creation reason
    BOOL                    m_bIsInitialized;           // Initialized?
    BOOL                    m_bIsHost;                  // Is hosting
    BOOL                    m_bUsingQoS;                // Is the QoS listener enabled
    DWORD                   m_dwOwnerController;        // Which controller created the session
    XUID                    m_xuidOwner;                // XUID of gamer who created the session
    WCHAR*                  m_strSessionError;          // Error message for current session
    ULONGLONG               m_qwSessionNonce;           // Session nonce
    XSESSION_INFO           m_SessionInfo;              // Session ID, key, and host address 
    XSESSION_INFO           m_NewSessionInfo;           // New session ID, key, and host address 
    BOOL                    m_bIsMigratedSessionHost;   // Is hosting migrated session?
    XNKID                   m_migratedSessionID;        // Session ID of migrated session
    HANDLE                  m_hSession;                 // Session handle
    SessionState            m_SessionState;             // Current session state
    SessionState            m_migratedSessionState;     // Session state of migrated session
    DWORD                   m_dwSessionFlags;           // Flags for the current session  exit?
    UINT                    m_Slots[ SLOTS_MAX ];       // Filled/open slots for the session
    IN_ADDR                 m_HostInAddr;               // Host IP address
    
    PXSESSION_REGISTRATION_RESULTS m_pRegistrationResults;
};

```

`XenonDumper/libs/Atg/AtgSignIn.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// AtgSignIn.cpp
//
// Handler for automatic signin
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#include "stdafx.h"
#include "AtgSignIn.h"
#include "AtgUtil.h"

namespace ATG
{

//--------------------------------------------------------------------------------------
// Static members
//--------------------------------------------------------------------------------------

DWORD  SignIn::m_dwMinUsers                   = 0;     
DWORD  SignIn::m_dwMaxUsers                   = 4;     
BOOL   SignIn::m_bRequireOnlineUsers          = FALSE; 
DWORD  SignIn::m_dwSignInPanes                = 4;     
HANDLE SignIn::m_hNotification                = NULL;  
DWORD  SignIn::m_dwSignedInUserMask           = 0;     
DWORD  SignIn::m_dwNumSignedInUsers           = 0;     
DWORD  SignIn::m_dwOnlineUserMask             = 0;     
DWORD  SignIn::m_dwFirstSignedInUser          = (DWORD)-1;
BOOL   SignIn::m_bSystemUIShowing             = FALSE; 
BOOL   SignIn::m_bNeedToShowSignInUI          = FALSE; 
BOOL   SignIn::m_bMessageBoxShowing           = FALSE;
BOOL   SignIn::m_bSigninUIWasShown            = FALSE;
XOVERLAPPED SignIn::m_Overlapped              = {0};
LPCWSTR SignIn::m_pwstrButtons[2]             = { L"Exit", L"Sign In" };
MESSAGEBOX_RESULT SignIn::m_MessageBoxResult  = {0};

//--------------------------------------------------------------------------------------
// Name: Initialize()
// Desc: Sets up variables and creates notification listener
//--------------------------------------------------------------------------------------
VOID SignIn::Initialize( DWORD dwMinUsers,
                         DWORD dwMaxUsers,
                         BOOL bRequireOnlineUsers,
                         DWORD dwSignInPanes )
{
    // Sanity check inputs
    assert( dwMaxUsers <= 4 && dwMinUsers <= dwMaxUsers );
    assert( dwSignInPanes <= 4 && dwSignInPanes != 3 );

    // Assign variables
    m_dwMinUsers = dwMinUsers;
    m_dwMaxUsers = dwMaxUsers;
    m_bRequireOnlineUsers = bRequireOnlineUsers;
    m_dwSignInPanes = dwSignInPanes;

    // Register our notification listener
    m_hNotification = XNotifyCreateListener( XNOTIFY_SYSTEM | XNOTIFY_LIVE );
    if( m_hNotification == NULL || m_hNotification == INVALID_HANDLE_VALUE )
    {
        ATG::FatalError( "Failed to create state notification listener.\n" );
    }

    // Query who is signed in
    QuerySigninStatus();
}


//--------------------------------------------------------------------------------------
// Name: QuerySigninStatus()
// Desc: Query signed in status of all users.
//--------------------------------------------------------------------------------------
VOID SignIn::QuerySigninStatus()
{
    m_dwSignedInUserMask = 0;
    m_dwOnlineUserMask = 0;

    // Count the signed-in users
    m_dwNumSignedInUsers = 0;
    m_dwFirstSignedInUser = ( DWORD )-1;

    for( UINT nUser = 0;
         nUser < XUSER_MAX_COUNT;
         nUser++ )
    {
        XUSER_SIGNIN_STATE State = XUserGetSigninState( nUser );

        if( State != eXUserSigninState_NotSignedIn )
        {
            // Check whether the user is online
            BOOL bUserOnline =
                State == eXUserSigninState_SignedInToLive;

            m_dwOnlineUserMask |= bUserOnline << nUser;

            // If we want Online users only, only count signed-in users
            if( !m_bRequireOnlineUsers || bUserOnline )
            {
                m_dwSignedInUserMask |= ( 1 << nUser );

                if( m_dwFirstSignedInUser == ( DWORD )-1 )
                {
                    m_dwFirstSignedInUser = nUser;
                }

                ++m_dwNumSignedInUsers;
            }
        }
    }

    // check to see if we need to invoke the signin UI
    m_bNeedToShowSignInUI = !AreUsersSignedIn();
}

//--------------------------------------------------------------------------------------
// Name: Update()
// Desc: Does required per-frame processing for signin
//--------------------------------------------------------------------------------------
DWORD SignIn::Update()
{
    assert( m_hNotification != NULL );  // ensure Initialize() was called

    DWORD dwRet = 0;

    // Check for system notifications
    DWORD dwNotificationID;
    ULONG_PTR ulParam;

    //
    // For XN_SYS_SIGNINCHANGED, handle the case where the system sends a spurious
    // notification. See  the FAQ on 
    // Xbox 360 Central: https://xds.xbox.com/xbox360/nav.aspx?Page=devsupport/sitefaq.htm#misc17
    // for a description of the workaround
    //
    static const DWORD dwTimeBeforeTrustingSignInChangedNotif = 1000;
    static DWORD dwQuestionableSigninChangeNotifReceived = GetTickCount();
    static UINT  cQuestionableSigninChangeNotifReceived = 0;

    if( XNotifyGetNext( m_hNotification, 0, &dwNotificationID, &ulParam ) )
    {
        switch( dwNotificationID )
        {
            case XN_SYS_SIGNINCHANGED:

                // Query who is signed in
                QuerySigninStatus();

                //
                // Might be a "spurious notification". See comments above.
                if( m_dwSignedInUserMask == 0 )
                {
                    ++cQuestionableSigninChangeNotifReceived;
                    if( cQuestionableSigninChangeNotifReceived == 1 )
                    {
                        // If a second signin changed notification arrives within dwTimeBeforeTrustingSignInChangedNotif,
                        // trust it instead of this one
                        dwQuestionableSigninChangeNotifReceived = GetTickCount();
                    }
                    else if( ( cQuestionableSigninChangeNotifReceived > 1 )  && 
                             ( GetTickCount() - dwQuestionableSigninChangeNotifReceived <= dwTimeBeforeTrustingSignInChangedNotif ) )
                    {
                        dwRet |= SIGNIN_USERS_CHANGED;
                    }
                }
                else
                {
                    dwRet |= SIGNIN_USERS_CHANGED;
                }

                // Reset dwQuestionableSigninChangeNotifReceived to 0 if the notification is valid
                if( dwRet & SIGNIN_USERS_CHANGED )
                {
                    cQuestionableSigninChangeNotifReceived = 0;
                }

                break;

            case XN_SYS_UI:
                dwRet |= SYSTEM_UI_CHANGED;
                m_bSystemUIShowing = static_cast<BOOL>( ulParam );

                // check to see if we need to invoke the signin UI
                m_bNeedToShowSignInUI = !AreUsersSignedIn();
                break;

            case XN_LIVE_CONNECTIONCHANGED:
                dwRet |= CONNECTION_CHANGED;
                break;

        } // switch( dwNotificationID )
    } // if( XNotifyGetNext() )

    // If there are not enough or too many profiles signed in, display an 
    // error message box prompting the user to either sign in again or exit the sample
    if( !m_bMessageBoxShowing && !m_bSystemUIShowing && m_bSigninUIWasShown && !AreUsersSignedIn() )
    {
        DWORD dwResult;

        ZeroMemory( &m_Overlapped, sizeof( XOVERLAPPED ) );

        WCHAR strMessage[512];
        swprintf_s( strMessage, L"Incorrect number of profiles signed in. You must sign in at least %d"
                    L" and at most %d profiles. Currently there are %d profiles signed in.",
                    m_dwMinUsers, m_dwMaxUsers, m_dwNumSignedInUsers );

        dwResult = XShowMessageBoxUI( XUSER_INDEX_ANY,
                                      L"Signin Error",   // Message box title
                                      strMessage,                 // Message
                                      ARRAYSIZE( m_pwstrButtons ),// Number of buttons
                                      m_pwstrButtons,             // Button captions
                                      0,                          // Button that gets focus
                                      XMB_ERRORICON,              // Icon to display
                                      &m_MessageBoxResult,        // Button pressed result
                                      &m_Overlapped );

        if( dwResult != ERROR_IO_PENDING )
            ATG::FatalError( "Failed to invoke message box UI, error %d\n", dwResult );

        m_bSystemUIShowing = TRUE;
        m_bMessageBoxShowing = TRUE;
    }

    // Wait until the message box is discarded, then either exit or show the signin UI again
    if( m_bMessageBoxShowing && XHasOverlappedIoCompleted( &m_Overlapped ) )
    {
        m_bMessageBoxShowing = FALSE;

        if( XGetOverlappedResult( &m_Overlapped, NULL, TRUE ) == ERROR_SUCCESS )
        {
            switch( m_MessageBoxResult.dwButtonPressed )
            {
                case 0:     // Reboot to the launcher
                    XLaunchNewImage( "", 0 );
                    break;

                case 1:     // Show the signin UI again
                    ShowSignInUI();
                    m_bSigninUIWasShown = FALSE;
                    break;
            }
        }
    }

    // Check to see if we need to invoke the signin UI
    if( !m_bMessageBoxShowing && m_bNeedToShowSignInUI && !m_bSystemUIShowing )
    {
        m_bNeedToShowSignInUI = FALSE;

        DWORD ret = XShowSigninUI(
            m_dwSignInPanes,
            m_bRequireOnlineUsers ? XSSUI_FLAGS_SHOWONLYONLINEENABLED : 0 );

        if( ret != ERROR_SUCCESS )
        {
            ATG::FatalError( "Failed to invoke signin UI, error %d\n", ret );
        }
        else
        {
            m_bSystemUIShowing = TRUE;
            m_bSigninUIWasShown = TRUE;
        }
    }

    return dwRet;
}

//--------------------------------------------------------------------------------------
// Name: CheckPrivilege()
// Desc: Test to see if a user has a required privilege
//--------------------------------------------------------------------------------------
BOOL SignIn::CheckPrivilege( DWORD dwController, XPRIVILEGE_TYPE priv )
{
    BOOL bResult;

    return
        ( XUserCheckPrivilege( dwController, priv, &bResult ) == ERROR_SUCCESS ) &&
        bResult;
}

} // namespace ATG

```

`XenonDumper/libs/Atg/AtgSignIn.h`:

```h
//--------------------------------------------------------------------------------------
// AtgSignIn.h
//
// Helper class to automatically handle signin
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#pragma once
#ifndef ATGSIGNIN_H
#define ATGSIGNIN_H

namespace ATG
{

//--------------------------------------------------------------------------------------
// Name: class SignIn
// Desc: Class to manage maintaining signed-in users. This class is a singleton; all
//       members are static
//--------------------------------------------------------------------------------------
class SignIn
{
public:
    // Flags that can be returned from Update()
    static enum SIGNIN_UPDATE_FLAGS
    {
        SIGNIN_USERS_CHANGED    = 0x00000001,
        SYSTEM_UI_CHANGED       = 0x00000002,
        CONNECTION_CHANGED      = 0x00000004
    };

    // Check users that are signed in
    static DWORD    GetSignedInUserCount()
    {
        return m_dwNumSignedInUsers;
    }
    static DWORD    GetSignedInUserMask()
    {
        return m_dwSignedInUserMask;
    }
    static BOOL     IsUserSignedIn( DWORD dwController )
    {
        return ( m_dwSignedInUserMask & ( 1 << dwController ) ) != 0;
    }

    static BOOL     AreUsersSignedIn()
    {
        return ( m_dwNumSignedInUsers >= m_dwMinUsers ) &&
            ( m_dwNumSignedInUsers <= m_dwMaxUsers );
    }

    // Get the first signed-in user
    static DWORD    GetSignedInUser()
    {
        return m_dwFirstSignedInUser;
    }

    // Check users that are signed into live
    static DWORD    GetOnlineUserMask()
    {
        return m_dwOnlineUserMask;
    }
    static BOOL     IsUserOnline( DWORD dwController )
    {
        return ( m_dwOnlineUserMask & ( 1 << dwController ) ) != 0;
    }

    // Check the presence of system UI
    static BOOL     IsSystemUIShowing()
    {
        return m_bSystemUIShowing || m_bNeedToShowSignInUI;
    }

    // Function to reinvoke signin UI
    static VOID     ShowSignInUI()
    {
        m_bNeedToShowSignInUI = TRUE;
    }

    // Check privileges for a signed-in users
    static BOOL     CheckPrivilege( DWORD dwController, XPRIVILEGE_TYPE priv );

    // Methods to drive autologin
    static VOID Initialize( 
        DWORD dwMinUsers, 
        DWORD dwMaxUsers,
        BOOL  bRequireOnlineUsers,
        DWORD dwSignInPanes );

    static DWORD    Update();

private:

    // Private constructor to prevent instantiation
                    SignIn();

    // Parameters
    static DWORD m_dwMinUsers;             // minimum users to accept as signed in
    static DWORD m_dwMaxUsers;             // maximum users to accept as signed in
    static BOOL m_bRequireOnlineUsers;    // online profiles only
    static DWORD m_dwSignInPanes;          // number of panes to show in signin UI

    // Internal variables
    static HANDLE m_hNotification;                // listener to accept notifications
    static DWORD m_dwSignedInUserMask;           // bitfields for signed-in users
    static DWORD m_dwFirstSignedInUser;          // first signed-in user
    static DWORD m_dwNumSignedInUsers;           // number of signed-in users
    static DWORD m_dwOnlineUserMask;             // users who are online
    static BOOL m_bSystemUIShowing;             // system UI present
    static BOOL m_bNeedToShowSignInUI;          // invoking signin UI necessary
    static BOOL m_bMessageBoxShowing;           // is retry signin message box showing?
    static BOOL m_bSigninUIWasShown;            // was the signin ui shown at least once?
    static XOVERLAPPED m_Overlapped;              // message box overlapped struct
    static LPCWSTR  m_pwstrButtons[2];             // message box buttons
    static MESSAGEBOX_RESULT m_MessageBoxResult;  // message box button pressed

    static VOID     QuerySigninStatus();              // Query signed in users

};

} // namespace ATG

#endif // ATGSIGNIN_H

```

`XenonDumper/libs/Atg/AtgSimpleShaders.cpp`:

```cpp
//-----------------------------------------------------------------------------
// AtgSimpleShaders.cpp
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "AtgDevice.h"
#include "AtgSimpleShaders.h"
#include "AtgUtil.h"

namespace ATG
{

extern D3DDevice* g_pd3dDevice;
::D3DDevice* g_pSimpleShadersDevice = NULL;

// effect objects
FXLEffect* g_pSimpleShaderEffect = NULL;
FXLEffectPool* g_pParameterPool = NULL;

// common vertex declarations
D3DVertexDeclaration* g_pVertexDeclPos = NULL;
D3DVertexDeclaration* g_pVertexDeclPosColor = NULL;
D3DVertexDeclaration* g_pVertexDeclPosT = NULL;
D3DVertexDeclaration* g_pVertexDeclPosTexCoord = NULL;
D3DVertexDeclaration* g_pVertexDeclPosColorTexCoord = NULL;

// technique handles
FXLHANDLE g_hTechniqueTransformedDepthOnly = NULL;
FXLHANDLE g_hTechniqueTransformedConstantColor = NULL;
FXLHANDLE g_hTechniqueTransformedVertexColor = NULL;
FXLHANDLE g_hTechniqueTransformedTextured = NULL;
FXLHANDLE g_hTechniqueTransformedTexturedConstantColor = NULL;
FXLHANDLE g_hTechniqueTransformedTexturedVertexColor = NULL;
FXLHANDLE g_hTechniquePreTransformedConstantColor = NULL;
FXLHANDLE g_hTechniquePreTransformedVertexColor = NULL;
FXLHANDLE g_hTechniquePreTransformedTextured = NULL;
FXLHANDLE g_hTechniquePreTransformedDepthTextured = NULL;
FXLHANDLE g_hTechniquePreTransformedTexturedConstantColor = NULL;
FXLHANDLE g_hTechniquePreTransformedTexturedVertexColor = NULL;
FXLHANDLE g_hTechniquePreTransformedDepthOnly = NULL;
FXLHANDLE g_hTechniquePreTransformedDownsampleDepth = NULL;
FXLHANDLE g_hTechniquePreTransformedDownsampleDepthArray = NULL;

// parameter handles
FXLHANDLE g_hWVP = NULL;
FXLHANDLE g_hConstantColor = NULL;
FXLHANDLE g_hSampler = NULL;

// parameter data
D3DXCOLOR g_ConstantColorData;

static const D3DVERTEXELEMENT9 g_PosVertexElements[] =
{
    { 0,     0, D3DDECLTYPE_FLOAT3,     0,  D3DDECLUSAGE_POSITION,  0 },
    D3DDECL_END()
};

static const D3DVERTEXELEMENT9 g_PosColorVertexElements[] =
{
    { 0,     0, D3DDECLTYPE_FLOAT3,     0,  D3DDECLUSAGE_POSITION,  0 },
    { 0,    12, D3DDECLTYPE_D3DCOLOR,   0,  D3DDECLUSAGE_COLOR,     0 },
    D3DDECL_END()
};

static const D3DVERTEXELEMENT9 g_PosTVertexElements[] =
{
    { 0,     0, D3DDECLTYPE_FLOAT4,     0,  D3DDECLUSAGE_POSITION,  0 },
    D3DDECL_END()
};

static const D3DVERTEXELEMENT9 g_PosTexCoordVertexElements[] =
{
    { 0,     0, D3DDECLTYPE_FLOAT3,     0,  D3DDECLUSAGE_POSITION,  0 },
    { 0,    12, D3DDECLTYPE_FLOAT2,     0,  D3DDECLUSAGE_TEXCOORD,  0 },
    D3DDECL_END()
};

static const D3DVERTEXELEMENT9 g_PosColorTexCoordVertexElements[] =
{
    { 0,     0, D3DDECLTYPE_FLOAT3,     0,  D3DDECLUSAGE_POSITION,  0 },
    { 0,    12, D3DDECLTYPE_D3DCOLOR,   0,  D3DDECLUSAGE_COLOR,     0 },
    { 0,    16, D3DDECLTYPE_FLOAT2,     0,  D3DDECLUSAGE_TEXCOORD,  0 },
    D3DDECL_END()
};

VOID SimpleShaders::Initialize( const CHAR* strShaderFileName, FXLEffectPool* pEffectPool )
{
    g_pParameterPool = pEffectPool;

    if( g_pSimpleShadersDevice == NULL )
        BindToNewDevice( g_pd3dDevice );

    // create vertex decls
    CreatePooledVertexDeclaration( g_PosVertexElements, &g_pVertexDeclPos );
    CreatePooledVertexDeclaration( g_PosColorVertexElements, &g_pVertexDeclPosColor );
    CreatePooledVertexDeclaration( g_PosTVertexElements, &g_pVertexDeclPosT );
    CreatePooledVertexDeclaration( g_PosTexCoordVertexElements, &g_pVertexDeclPosTexCoord );
    CreatePooledVertexDeclaration( g_PosColorTexCoordVertexElements, &g_pVertexDeclPosColorTexCoord );

    // create FXLite effect
    if( strShaderFileName == NULL )
        strShaderFileName = "game:\\media\\effects\\simpleshaders.fxobj";
    VOID* pEffectData = NULL;
    ATG::LoadFile( strShaderFileName, &pEffectData, NULL );
    FXLCreateEffect( g_pSimpleShadersDevice, pEffectData, pEffectPool, &g_pSimpleShaderEffect );
    ATG::UnloadFile( pEffectData );

    if( g_pSimpleShaderEffect == NULL )
    {
        FatalError( "Could not initialize SimpleShaders with FX file \"%s\".\n", strShaderFileName );
        return;
    }

    // get technique handles
    g_hTechniqueTransformedDepthOnly = g_pSimpleShaderEffect->GetTechniqueHandle( "Transformed_DepthOnly" );
    g_hTechniqueTransformedConstantColor = g_pSimpleShaderEffect->GetTechniqueHandle( "Transformed_ConstantColor" );
    g_hTechniqueTransformedVertexColor = g_pSimpleShaderEffect->GetTechniqueHandle( "Transformed_VertexColor" );
    g_hTechniqueTransformedTextured = g_pSimpleShaderEffect->GetTechniqueHandle( "Transformed_Textured" );
    g_hTechniqueTransformedTexturedConstantColor = g_pSimpleShaderEffect->GetTechniqueHandle( "Transformed_TextureConstantColor" );
    g_hTechniqueTransformedTexturedVertexColor = g_pSimpleShaderEffect->GetTechniqueHandle( "Transformed_TextureVertexColor" );

    g_hTechniquePreTransformedConstantColor = g_pSimpleShaderEffect->GetTechniqueHandle( "PreTransformed_ConstantColor" );
    g_hTechniquePreTransformedVertexColor = g_pSimpleShaderEffect->GetTechniqueHandle( "PreTransformed_VertexColor" );
    g_hTechniquePreTransformedTextured = g_pSimpleShaderEffect->GetTechniqueHandle( "PreTransformed_Textured" );
    g_hTechniquePreTransformedDepthTextured = g_pSimpleShaderEffect->GetTechniqueHandle( "PreTransformed_DepthTextured" );
    g_hTechniquePreTransformedTexturedConstantColor = g_pSimpleShaderEffect->GetTechniqueHandle( "PreTransformed_TextureConstantColor" );
    g_hTechniquePreTransformedTexturedVertexColor = g_pSimpleShaderEffect->GetTechniqueHandle( "PreTransformed_TextureVertexColor" );
    g_hTechniquePreTransformedDepthOnly = g_pSimpleShaderEffect->GetTechniqueHandle( "PreTransformed_DepthOnly" );
    g_hTechniquePreTransformedDownsampleDepth = g_pSimpleShaderEffect->GetTechniqueHandle( "PreTransformed_DownsampleDepth" );
    g_hTechniquePreTransformedDownsampleDepthArray = g_pSimpleShaderEffect->GetTechniqueHandle( "PreTransformed_DownsampleDepthArray" );

    // get parameter handles
    g_hWVP = g_pSimpleShaderEffect->GetParameterHandle( "world_view_proj_matrix" );
    g_hConstantColor = g_pSimpleShaderEffect->GetParameterHandle( "simpleshader_constant_color" );
    g_hSampler = g_pSimpleShaderEffect->GetParameterHandle( "simpleshader_sampler" );
}

VOID SimpleShaders::Terminate()
{
    if( g_pSimpleShaderEffect != NULL )
    {
        g_pSimpleShaderEffect->Release();
        g_pSimpleShaderEffect = NULL;
    }

    delete g_pVertexDeclPos;
    delete g_pVertexDeclPosColor;
    delete g_pVertexDeclPosT;
    delete g_pVertexDeclPosTexCoord;
    delete g_pVertexDeclPosColorTexCoord;
}


VOID SimpleShaders::BindToNewDevice( ::D3DDevice* pNewDevice )
{
    g_pSimpleShadersDevice = pNewDevice;
    if( g_pSimpleShaderEffect != NULL )
        g_pSimpleShaderEffect->ChangeDevice( g_pSimpleShadersDevice );
}


VOID SimpleShaders::SetDeclPos()
{
    g_pSimpleShadersDevice->SetVertexDeclaration( g_pVertexDeclPos );
}

VOID SimpleShaders::SetDeclPosColor()
{
    g_pSimpleShadersDevice->SetVertexDeclaration( g_pVertexDeclPosColor );
}

VOID SimpleShaders::SetDeclPosT()
{
    g_pSimpleShadersDevice->SetVertexDeclaration( g_pVertexDeclPosT );
}

VOID SimpleShaders::SetDeclPosTex()
{
    g_pSimpleShadersDevice->SetVertexDeclaration( g_pVertexDeclPosTexCoord );
}

VOID SimpleShaders::SetDeclPosColorTex()
{
    g_pSimpleShadersDevice->SetVertexDeclaration( g_pVertexDeclPosColorTexCoord );
}

inline VOID BeginMaterial( FXLHANDLE hTechnique )
{
    g_pSimpleShaderEffect->BeginTechnique( hTechnique, 0 );
    g_pSimpleShaderEffect->BeginPassFromIndex( 0 );
    g_pSimpleShaderEffect->Commit();
}

VOID SimpleShaders::BeginShader_Transformed_DepthOnly( const XMMATRIX& matWVP )
{
    g_pSimpleShaderEffect->SetMatrixF4x4( g_hWVP, ( FLOAT* )&matWVP );

    BeginMaterial( g_hTechniqueTransformedDepthOnly );
}

VOID SimpleShaders::BeginShader_Transformed_ConstantColor( const XMMATRIX& matWVP, D3DCOLOR Color )
{
    g_pSimpleShaderEffect->SetMatrixF4x4( g_hWVP, ( FLOAT* )&matWVP );
    g_ConstantColorData = D3DXCOLOR( Color );
    g_pSimpleShaderEffect->SetVectorF( g_hConstantColor, ( FLOAT* )&g_ConstantColorData );

    BeginMaterial( g_hTechniqueTransformedConstantColor );
}

VOID SimpleShaders::BeginShader_Transformed_VertexColor( const XMMATRIX& matWVP )
{
    g_pSimpleShaderEffect->SetMatrixF4x4( g_hWVP, ( FLOAT* )&matWVP );
    BeginMaterial( g_hTechniqueTransformedVertexColor );
}

VOID SimpleShaders::BeginShader_Transformed_Textured( const XMMATRIX& matWVP, const D3DBaseTexture* pTexture )
{
    g_pSimpleShaderEffect->SetMatrixF4x4( g_hWVP, ( FLOAT* )&matWVP );
    g_pSimpleShaderEffect->SetSampler( g_hSampler, pTexture );
    BeginMaterial( g_hTechniqueTransformedTextured );
}

VOID SimpleShaders::BeginShader_Transformed_TexturedConstantColor( const XMMATRIX& matWVP,
                                                                   const D3DBaseTexture* pTexture, D3DCOLOR Color )
{
    g_pSimpleShaderEffect->SetMatrixF4x4( g_hWVP, ( FLOAT* )&matWVP );
    g_pSimpleShaderEffect->SetSampler( g_hSampler, pTexture );
    g_ConstantColorData = D3DXCOLOR( Color );
    g_pSimpleShaderEffect->SetVectorF( g_hConstantColor, ( FLOAT* )&g_ConstantColorData );
    BeginMaterial( g_hTechniqueTransformedTexturedConstantColor );
}

VOID SimpleShaders::BeginShader_Transformed_TexturedVertexColor( const XMMATRIX& matWVP,
                                                                 const D3DBaseTexture* pTexture )
{
    g_pSimpleShaderEffect->SetMatrixF4x4( g_hWVP, ( FLOAT* )&matWVP );
    g_pSimpleShaderEffect->SetSampler( g_hSampler, pTexture );
    BeginMaterial( g_hTechniqueTransformedTexturedVertexColor );
}

VOID SimpleShaders::BeginShader_PreTransformed_ConstantColor( D3DCOLOR Color )
{
    g_ConstantColorData = D3DXCOLOR( Color );
    g_pSimpleShaderEffect->SetVectorF( g_hConstantColor, ( FLOAT* )&g_ConstantColorData );

    BeginMaterial( g_hTechniquePreTransformedConstantColor );
}

VOID SimpleShaders::BeginShader_PreTransformed_VertexColor()
{
    BeginMaterial( g_hTechniquePreTransformedVertexColor );
}

VOID SimpleShaders::BeginShader_PreTransformed_Textured( const D3DBaseTexture* pTexture )
{
    g_pSimpleShaderEffect->SetSampler( g_hSampler, pTexture );
    BeginMaterial( g_hTechniquePreTransformedTextured );
}

VOID SimpleShaders::BeginShader_PreTransformed_DepthTextured( const D3DBaseTexture* pTexture )
{
    g_pSimpleShaderEffect->SetSampler( g_hSampler, pTexture );
    BeginMaterial( g_hTechniquePreTransformedDepthTextured );
}

VOID SimpleShaders::BeginShader_PreTransformed_TexturedConstantColor( const D3DBaseTexture* pTexture, D3DCOLOR Color )
{
    g_pSimpleShaderEffect->SetSampler( g_hSampler, pTexture );
    g_ConstantColorData = D3DXCOLOR( Color );
    g_pSimpleShaderEffect->SetVectorF( g_hConstantColor, ( FLOAT* )&g_ConstantColorData );
    BeginMaterial( g_hTechniquePreTransformedTexturedConstantColor );
}

VOID SimpleShaders::BeginShader_PreTransformed_TexturedVertexColor( const D3DBaseTexture* pTexture )
{
    g_pSimpleShaderEffect->SetSampler( g_hSampler, pTexture );
    BeginMaterial( g_hTechniquePreTransformedTexturedVertexColor );
}

VOID SimpleShaders::BeginShader_PreTransformed_DepthOnly()
{
    BeginMaterial( g_hTechniquePreTransformedDepthOnly );
}

VOID SimpleShaders::BeginShader_PreTransformed_DownsampleDepth( const D3DBaseTexture* pDepthTexture )
{
    g_pSimpleShaderEffect->SetSampler( g_hSampler, pDepthTexture );
    BeginMaterial( g_hTechniquePreTransformedDownsampleDepth );
}

VOID SimpleShaders::BeginShader_PreTransformed_DownsampleDepthArray( const D3DBaseTexture* pDepthArrayTexture,
                                                                     DWORD dwSliceIndex )
{
    const DWORD dwMaxSlices = pDepthArrayTexture->Format.Size.Stack.Depth + 1;
    FLOAT fSliceCoord = ( FLOAT )( 2 * dwSliceIndex + 1 ) / ( FLOAT )( dwMaxSlices * 2 );
    XMFLOAT4 vZCoordinate( fSliceCoord, fSliceCoord, fSliceCoord, fSliceCoord );
    g_pSimpleShaderEffect->SetVectorF( g_hConstantColor, ( FLOAT* )&vZCoordinate );
    g_pSimpleShaderEffect->SetSampler( g_hSampler, pDepthArrayTexture );
    BeginMaterial( g_hTechniquePreTransformedDownsampleDepthArray );
}

VOID SimpleShaders::EndShader()
{
    g_pSimpleShaderEffect->EndPass();
    g_pSimpleShaderEffect->EndTechnique();
}

} // namespace ATG

```

`XenonDumper/libs/Atg/AtgSimpleShaders.h`:

```h
//-----------------------------------------------------------------------------
// AtgSimpleShaders.h
//
// A library of standard shaders, vertex structs, and vertex declarations for use in
// simple rendering.  In a way, this is a replacement for what the fixed function
// pipeline provided.
//
// This code is dependent on a piece of content - media/simpleshaders.fx
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef ATGSIMPLESHADERS_H
#define ATGSIMPLESHADERS_H

#include <xboxmath.h>
#include <fxl.h>

namespace ATG
{

struct MeshVertexP
{
public:
    XMFLOAT3 Position;
    static size_t Size()
    {
        return sizeof( MeshVertexP );
    }
};

struct MeshVertexPTransformed
{
public:
    XMFLOAT4 PositionT;
    static size_t Size()
    {
        return sizeof( MeshVertexPTransformed );
    }
};

struct MeshVertexPC
{
public:
    XMFLOAT3 Position;
    D3DCOLOR Color;
    static size_t Size()
    {
        return sizeof( MeshVertexPC );
    }
};

struct MeshVertexPT
{
public:
    XMFLOAT3 Position;
    XMFLOAT2 TexCoord;
    static size_t Size()
    {
        return sizeof( MeshVertexPT );
    }
};

struct MeshVertexPCT
{
public:
    XMFLOAT3 Position;
    D3DCOLOR Color;
    XMFLOAT2 TexCoord;
    static size_t Size()
    {
        return sizeof( MeshVertexPCT );
    }
};

class SimpleShaders
{
public:
    static VOID Initialize( const CHAR* strShaderFileName, FXLEffectPool* pEffectPool );
    static VOID Terminate();

    static VOID BindToNewDevice( ::D3DDevice* pNewDevice );

    static VOID SetDeclPos();
    static VOID SetDeclPosT();
    static VOID SetDeclPosColor();
    static VOID SetDeclPosTex();
    static VOID SetDeclPosColorTex();

    static VOID BeginShader_Transformed_ConstantColor( const XMMATRIX& matWVP, D3DCOLOR Color );
    static VOID BeginShader_Transformed_VertexColor( const XMMATRIX& matWVP );
    static VOID BeginShader_Transformed_Textured( const XMMATRIX& matWVP, const D3DBaseTexture* pTexture );
    static VOID BeginShader_Transformed_TexturedConstantColor( const XMMATRIX& matWVP, const D3DBaseTexture* pTexture, D3DCOLOR Color );
    static VOID BeginShader_Transformed_TexturedVertexColor( const XMMATRIX& matWVP, const D3DBaseTexture* pTexture );
    static VOID BeginShader_Transformed_DepthOnly( const XMMATRIX& matWVP );

    static VOID BeginShader_PreTransformed_ConstantColor( D3DCOLOR Color );
    static VOID BeginShader_PreTransformed_VertexColor();
    static VOID BeginShader_PreTransformed_Textured( const D3DBaseTexture* pTexture );
    static VOID BeginShader_PreTransformed_DepthTextured( const D3DBaseTexture* pDepthTexture );
    static VOID BeginShader_PreTransformed_TexturedConstantColor( const D3DBaseTexture* pTexture, D3DCOLOR Color );
    static VOID BeginShader_PreTransformed_TexturedVertexColor( const D3DBaseTexture* pTexture );
    static VOID BeginShader_PreTransformed_DepthOnly();
    static VOID BeginShader_PreTransformed_DownsampleDepth( const D3DBaseTexture* pDepthTexture );
    static VOID BeginShader_PreTransformed_DownsampleDepthArray( const D3DBaseTexture* pDepthArrayTexture, DWORD dwSliceIndex );

    static VOID EndShader();
};

} // namespace ATG

#endif

```

`XenonDumper/libs/Atg/AtgSkeletalAnimation.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// AtgSkeletalAnimation.cpp
//
// Xbox Game Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------

#include "stdafx.h"
#include "AtgSkeletalAnimation.h"

namespace ATG
{

//--------------------------------------------------------------------------------------
// Name: Skeleton::Initialize()
// Desc: Initializes a skeleton struct from a hierarchy of frames in a scene.
//--------------------------------------------------------------------------------------
VOID Skeleton::Initialize( ATG::Frame* pSkeletonRootFrame )
{
    // Build skeleton data structure from the scene hierarchy.
    BuildFromFrameHierarchy( pSkeletonRootFrame, -1 );

    // Allocate bind poses for the skeleton.
    DWORD dwBoneCount = GetBoneCount();
    m_BindPoseLocal.Allocate( dwBoneCount );
    m_InverseBindPose.Allocate( dwBoneCount );

    // Build local bind pose and inverse bind pose.
    for( DWORD i = 0; i < dwBoneCount; ++i )
    {
        ATG::Frame* pFrame = m_FrameVector[i];
        XMMATRIX matWorld = pFrame->GetWorldTransform();
        XMVECTOR vDummy;
        XMMATRIX matInvWorld = XMMatrixInverse( &vDummy, matWorld );
        XMMATRIX matLocal = pFrame->GetLocalTransform();

        m_BindPoseLocal.StoreTransform( i, matLocal );
        m_InverseBindPose.StoreTransform( i, matInvWorld );
    }
}


//--------------------------------------------------------------------------------------
// Name: Skeleton::BuildFromFrameHierarchy
// Desc: Recursive function that walks a frame hierarchy and creates vectors of frame
//       pointers and parent indices.
//--------------------------------------------------------------------------------------
VOID Skeleton::BuildFromFrameHierarchy( ATG::Frame* pRootFrame, INT iParentIndex )
{
    assert( pRootFrame != NULL );
    m_FrameVector.push_back( pRootFrame );
    INT iCurrentIndex = ( INT )m_ParentIndex.size();
    m_ParentIndex.push_back( iParentIndex );

    ATG::Frame* pChild = pRootFrame->GetFirstChild();
    while( pChild != NULL )
    {
        BuildFromFrameHierarchy( pChild, iCurrentIndex );
        pChild = pChild->GetNextSibling();
    }
}


//--------------------------------------------------------------------------------------
// Name: Skeleton::FindBone()
// Desc: Searches for a frame of a given name and returns the index in the skeleton.
//--------------------------------------------------------------------------------------
INT Skeleton::FindBone( const ATG::StringID name )
{
    DWORD dwCount = GetBoneCount();
    for( DWORD i = 0; i < dwCount; ++i )
    {
        if( m_FrameVector[i]->GetName() == name )
            return ( INT )i;
    }
    return -1;
}


//--------------------------------------------------------------------------------------
// Name: SkeletonInstance::Initialize()
// Desc: Initializes a skeleton instance and allocates poses to match the bone count of
//       the skeleton.
//--------------------------------------------------------------------------------------
VOID SkeletonInstance::Initialize( Skeleton* pSkeleton, DWORD dwSkinnedMeshBindingCount )
{
    m_pActiveAnimation = NULL;
    m_pSkeleton = pSkeleton;
    m_LocalPose.Allocate( pSkeleton->GetBoneCount() );
    m_WorldPose.Allocate( pSkeleton->GetBoneCount() );

    m_qJointRotOffset = new XMVECTOR[pSkeleton->GetBoneCount() ];
    for( DWORD i = 0; i < m_pSkeleton->GetBoneCount(); i++)
    {
        m_qJointRotOffset[i] = XMQuaternionIdentity();
    }

    m_vJointPosOffset = new XMVECTOR[pSkeleton->GetBoneCount() ];
    for( DWORD i = 0; i < m_pSkeleton->GetBoneCount(); i++)
    {
        m_vJointPosOffset[i] = XMVectorZero();
    }

    if( m_pSkinnedMeshBindings != NULL )
    {
        if( dwSkinnedMeshBindingCount != m_dwSkinnedMeshBindingCount )
        {
            delete m_pSkinnedMeshBindings;
            m_pSkinnedMeshBindings = NULL;
        }
    }

    if( m_pSkinnedMeshBindings == NULL )
        m_pSkinnedMeshBindings = new SkinnedMeshBinding[ dwSkinnedMeshBindingCount ];

    m_dwSkinnedMeshBindingCount = dwSkinnedMeshBindingCount;
}


//--------------------------------------------------------------------------------------
// Name: SkeletonInstance::BindSkinnedMesh
// Desc: Creates a skinned mesh binding.
//--------------------------------------------------------------------------------------
VOID SkeletonInstance::BindSkinnedMesh( DWORD dwIndex, ATG::SkinnedMesh* pSkinnedMesh )
{
    assert( dwIndex < m_dwSkinnedMeshBindingCount );
    SkinnedMeshBinding& Binding = m_pSkinnedMeshBindings[ dwIndex ];
    Binding.m_pSkinnedMesh = pSkinnedMesh;

    // Build skinning palette.  The transform buffer will be supplied at runtime.
    DWORD dwInfluenceCount = pSkinnedMesh->GetInfluenceCount();
    Binding.m_BoneMatrixPalette.m_dwPoseSize = dwInfluenceCount;
    Binding.m_BoneMatrixPalette.m_pTransforms = NULL;

    // Map influence bones in the skinned mesh to skeleton bones.
    Binding.m_pSkinInfluenceToSkeletonBone = new INT[ dwInfluenceCount ];
    for( DWORD i = 0; i < dwInfluenceCount; ++i )
    {
        const ATG::StringID strInfluenceName = Binding.m_pSkinnedMesh->GetInfluence( i );
        INT iBoneIndex = m_pSkeleton->FindBone( strInfluenceName );
        Binding.m_pSkinInfluenceToSkeletonBone[i] = iBoneIndex;
    }
}


//--------------------------------------------------------------------------------------
// Name: SkeletonInstance::CreateAnimationBinding()
//--------------------------------------------------------------------------------------
AnimationBinding* SkeletonInstance::CreateAnimationBinding( ATG::Animation* pAnimation )
{
    // Create animation binding and initialize it.
    if( m_pActiveAnimation == NULL )
        m_pActiveAnimation = new AnimationBinding;
    m_pActiveAnimation->Initialize( this, pAnimation );
    return m_pActiveAnimation;
}


//--------------------------------------------------------------------------------------
// Name: SkeletonInstance::UpdateAnimation
// Desc: Samples the active animation, creating new local and world pose transforms.
//--------------------------------------------------------------------------------------
VOID SkeletonInstance::UpdateAnimation( FLOAT fDeltaTime )
{
    // Update the animation clock.
    if( m_pActiveAnimation )
        m_pActiveAnimation->Tick( fDeltaTime );

    // Initialize the local pose with the bind pose local transforms.
    m_pSkeleton->m_BindPoseLocal.CopyToPose( &m_LocalPose );

    // Sample animation tracks into the local pose.
    if( m_pActiveAnimation )
        m_pActiveAnimation->SampleAnimationToLocalPose( &m_LocalPose );

    // Apply rotation and position offsets
    for( DWORD iBoneIndex = 0; iBoneIndex <  m_pSkeleton->GetBoneCount(); iBoneIndex++)
    {
        XMVECTOR qOrientation = XMLoadFloat4(&m_LocalPose.m_pPositionsOrientations[iBoneIndex*2+1]);
        qOrientation = XMQuaternionMultiply( m_qJointRotOffset[ iBoneIndex ], qOrientation );
        XMStoreFloat4( &m_LocalPose.m_pPositionsOrientations[iBoneIndex*2+1], qOrientation );

        XMVECTOR vPos = XMLoadFloat4(&m_LocalPose.m_pPositionsOrientations[iBoneIndex*2]);
        vPos += m_vJointPosOffset[iBoneIndex];
        XMStoreFloat4( &m_LocalPose.m_pPositionsOrientations[iBoneIndex*2], vPos );
    }
}


//--------------------------------------------------------------------------------------
// Name: SkeletonInstance::BuildWorldPose()
// Desc: Create the World pose from the Local pose
//--------------------------------------------------------------------------------------
VOID SkeletonInstance::BuildWorldPose()
{
    // The root bone's world pose is the local pose.
    m_WorldPose.StoreTransform( 0, m_LocalPose.LoadTransform( 0 ) );

    // Compute the world pose for each bone.
    const DWORD dwBoneCount = m_pSkeleton->GetBoneCount();
    for( DWORD i = 1; i < dwBoneCount; ++i )
    {
        // Determine the parent index for the local bone.
        INT iParentBoneIndex = m_pSkeleton->m_ParentIndex[i];
        assert( iParentBoneIndex >= 0 && iParentBoneIndex < ( INT )dwBoneCount );

        // Load the local transform and the parent's world transform.
        XMMATRIX matLocal = m_LocalPose.LoadTransform( i );
        XMMATRIX matParentWorld = m_WorldPose.LoadTransform( iParentBoneIndex );

        // Compute the world transform for this bone, and store it into the world pose.
        XMMATRIX matWorld = XMMatrixMultiply( matLocal, matParentWorld );
        m_WorldPose.StoreTransform( i, matWorld );
    }
}


//--------------------------------------------------------------------------------------
// Name: SkeletonInstance::CreateBonePalette
// Desc: For a given skinned mesh index, creates the bone palette from the world pose
//       and the skeleton's inverse bind pose.
//--------------------------------------------------------------------------------------
VOID SkeletonInstance::CreateBonePalette( DWORD dwSkinnedMeshIndex, VOID* pDestBonePalette, BOOL bDestPaletteHalf4 )
{
    assert( dwSkinnedMeshIndex < m_dwSkinnedMeshBindingCount );
    SkinnedMeshBinding& Binding = m_pSkinnedMeshBindings[ dwSkinnedMeshIndex ];

    // Update skin palette buffer pointer.
    // This allows the animation system to write its results directly into the memory
    // used by the GPU or the CPU for skinning.
    assert( pDestBonePalette != NULL );
    if( bDestPaletteHalf4 )
        Binding.m_BoneMatrixPalette.m_pTransformsHalf = ( XMHALF4* )pDestBonePalette;
    else
        Binding.m_BoneMatrixPalette.m_pTransforms = ( XMFLOAT4A* )pDestBonePalette;

    // Compute skinning transforms (also known as composite transforms).
    // We only need to compute the ones used by the skinned mesh.
    const DWORD dwPaletteCount = Binding.GetPaletteSize();
    for( DWORD i = 0; i < dwPaletteCount; ++i )
    {
        // Determine skin influence to bone index mapping.
        // Usually, not all bones in the skeleton influence the mesh.
        INT iSourceBoneIndex = Binding.m_pSkinInfluenceToSkeletonBone[i];
        assert( iSourceBoneIndex >= 0 && iSourceBoneIndex < ( INT )m_pSkeleton->GetBoneCount() );

        // Load the world transform for the bone, as well as the inverse bind pose transform.
        XMMATRIX matWorld = m_WorldPose.LoadTransform( iSourceBoneIndex );
        XMMATRIX matInvBindPose = m_pSkeleton->m_InverseBindPose.LoadTransform( iSourceBoneIndex );

        // Compute the composite transform, transpose it for consumption by the GPU,
        // and store it into the skin palette.  The transform is ready to be used for
        // mesh deformation.
        XMMATRIX matComposite = matInvBindPose * matWorld;
        matComposite = XMMatrixTranspose( matComposite );
        if( bDestPaletteHalf4 )
            Binding.m_BoneMatrixPalette.StoreTransformHalf( i, matComposite );
        else
            Binding.m_BoneMatrixPalette.StoreTransform( i, matComposite );
    }
}


//--------------------------------------------------------------------------------------
// Name: AnimationBinding::Initialize()
// Desc: Creates a binding between animation tracks and skeleton bone indices.
//--------------------------------------------------------------------------------------
VOID AnimationBinding::Initialize( SkeletonInstance* pSkeletonInstance, ATG::Animation* pAnimation )
{
    m_pSkeletonInstance = pSkeletonInstance;
    m_pAnimation = pAnimation;
    m_fPlaybackTime = 0;
    m_fPlaybackSpeed = 1.0f;
    DWORD dwTrackCount = m_pAnimation->GetAnimationTrackCount();

    if( m_dwTrackCount != 0 && m_dwTrackCount != dwTrackCount )
    {
        //delete old memory
        delete[] m_pAnimationTrackToSkeletonBone;
        m_pAnimationTrackToSkeletonBone = NULL;
        delete[] m_pPositionTrackLastKey;
        m_pPositionTrackLastKey = NULL;
        delete[] m_pOrientationTrackLastKey;
        m_pOrientationTrackLastKey = NULL;
    }

    // Map animation tracks to bone indices.

    if( m_pAnimationTrackToSkeletonBone == NULL )
        m_pAnimationTrackToSkeletonBone = new INT[ dwTrackCount ];

    Skeleton* pSkeleton = m_pSkeletonInstance->m_pSkeleton;
    for( DWORD i = 0; i < dwTrackCount; ++i )
    {
        ATG::AnimationTransformTrack* pTrack = m_pAnimation->GetAnimationTrack( i );
        INT iBoneIndex = pSkeleton->FindBone( pTrack->GetName() );
        m_pAnimationTrackToSkeletonBone[i] = iBoneIndex;
    }

    // Create buffers to hold the last sampled key.  These make animation curve sampling
    // much faster.
    if( m_pPositionTrackLastKey == NULL )
        m_pPositionTrackLastKey = new DWORD[ dwTrackCount ];
    ZeroMemory( m_pPositionTrackLastKey, dwTrackCount * sizeof( DWORD ) );

    if( m_pOrientationTrackLastKey == NULL )
        m_pOrientationTrackLastKey = new DWORD[ dwTrackCount ];
    ZeroMemory( m_pOrientationTrackLastKey, dwTrackCount * sizeof( DWORD ) );

    m_dwTrackCount = dwTrackCount;

}


//--------------------------------------------------------------------------------------
// Name: AnimationBinding::SampleAnimationToLocalPose()
// Desc: Samples each transform track to local transform components (position and
//       orientation).
//--------------------------------------------------------------------------------------
VOID AnimationBinding::SampleAnimationToLocalPose( PoseDecomp* pLocalPose )
{
    const DWORD dwTrackCount = m_pAnimation->GetAnimationTrackCount();
    const FLOAT fDuration = m_pAnimation->GetDuration();
    for( DWORD i = 0; i < dwTrackCount; ++i )
    {
        // Determine track index to bone index mapping.
        INT iBoneIndex = m_pAnimationTrackToSkeletonBone[i];
        if( iBoneIndex == -1 )
            continue;
        assert( iBoneIndex < ( INT )pLocalPose->m_dwPoseSize );

        // Sample the animation track.
        // We keep track of the last key index used to accelerate the key search.
        const ATG::AnimationTransformTrack* pTrack = m_pAnimation->GetAnimationTrack( i );
        XMVECTOR vPosition = pTrack->SamplePositionLooping( m_fPlaybackTime, fDuration, &m_pPositionTrackLastKey[i] );
        XMVECTOR qOrientation = pTrack->SampleOrientationLooping( m_fPlaybackTime,
                                                                  fDuration, &m_pOrientationTrackLastKey[i] );
        qOrientation = XMQuaternionNormalize( qOrientation );

        // Store the local transform into the local pose.
        pLocalPose->StorePositionOrientation( iBoneIndex, vPosition, qOrientation );
    }
}

} // namespace ATG
```

`XenonDumper/libs/Atg/AtgSkeletalAnimation.h`:

```h
//--------------------------------------------------------------------------------------
// AtgSkeletalAnimation.h
//
// A set of structs and methods for performing skeletal animation.
//
// Xbox Game Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------

#pragma once

#ifndef ATG_SKELETAL_ANIMATION_H
#define ATG_SKELETAL_ANIMATION_H

#include <assert.h>
#include <xnamath.h>
#include <vector>
#include "AtgScene.h"
#include "AtgSceneMesh.h"
#include "AtgAnimation.h"


extern "C"
    void _WriteBarrier();
#pragma intrinsic(_WriteBarrier)

namespace ATG
{

static const DWORD g_dwMaxBoneCount = 80;

//--------------------------------------------------------------------------------------
// Name: struct PoseDecomp
// Desc: Stores an array of interleaved position vectors and orientation quaternions.
//--------------------------------------------------------------------------------------
struct
PoseDecomp
{
    DWORD m_dwPoseSize;
    XMFLOAT4A* m_pPositionsOrientations;

    PoseDecomp()
    {
        m_pPositionsOrientations = NULL;
    }

    VOID Allocate( DWORD dwBoneCount )
    {
        if( m_dwPoseSize != dwBoneCount && m_pPositionsOrientations != NULL )
        {
            delete[] m_pPositionsOrientations;
            m_pPositionsOrientations = NULL;
        }
        m_dwPoseSize = dwBoneCount;
        if( m_pPositionsOrientations == NULL )
        {
            m_pPositionsOrientations = new XMFLOAT4A[ dwBoneCount * 2 ];
        }
    }
    VOID CopyToPose( PoseDecomp* pDestPose )
    {
        assert( m_dwPoseSize == pDestPose->m_dwPoseSize );
        XMemCpy( pDestPose->m_pPositionsOrientations, m_pPositionsOrientations, m_dwPoseSize * 2 * sizeof
                 ( XMFLOAT4A ) );
    }
    VOID StorePositionOrientation( DWORD dwIndex, const XMVECTOR vPos, const XMVECTOR qOrientation )
    {
        dwIndex *= 2;
        XMStoreFloat4A( &m_pPositionsOrientations[ dwIndex ], vPos );
        XMStoreFloat4A( &m_pPositionsOrientations[ dwIndex + 1 ], qOrientation );
    }
    VOID StoreTransform( DWORD dwIndex, CXMMATRIX matTransform )
    {
        XMVECTOR vPos = matTransform.r[3];
        XMVECTOR qOrientation = XMQuaternionRotationMatrix( matTransform );
        StorePositionOrientation( dwIndex, vPos, qOrientation );
    }
    XMMATRIX LoadTransform( DWORD dwIndex ) const
    {
        static const XMVECTOR vSelectW = XMVectorSelectControl( 0, 0, 0, 1 );
        static const XMVECTOR vOne = XMVectorReplicate( 1.0f );

        dwIndex *= 2;
        XMVECTOR vPos = XMLoadFloat4A( &m_pPositionsOrientations[ dwIndex ] );
        XMVECTOR qOrientation = XMLoadFloat4A( &m_pPositionsOrientations[ dwIndex + 1 ] );
        // Compose a transform matrix from the rotation quaternion and the position vector.
        XMMATRIX matTransform = XMMatrixRotationQuaternion( qOrientation );
        matTransform.r[3] = XMVectorSelect( vPos, vOne, vSelectW );
        return matTransform;
    }
#if defined ( _PPC_ )
    VOID Prefetch() const
    {
        DWORD dwSize = m_dwPoseSize * 2 * sizeof( XMFLOAT4A );
        for( DWORD i = 0; i < dwSize; i += 128 )
            __dcbt( i, m_pPositionsOrientations );
    }
#else
    VOID Prefetch() const
    {
        // Do not prefetch data, if not running on Xbox
    }
#endif
    VOID BlendPoses( const PoseDecomp* __restrict pSrcPoseA, const PoseDecomp* __restrict pSrcPoseB, FLOAT fLerpFactor )
    {
        const XMVECTOR vLerpFactor = XMVectorReplicate( fLerpFactor );
        assert( m_dwPoseSize == pSrcPoseA->m_dwPoseSize && m_dwPoseSize == pSrcPoseB->m_dwPoseSize );
        pSrcPoseA->Prefetch();
        pSrcPoseB->Prefetch();
        DWORD dwArrayIndex = 0;
        for( DWORD i = 0; i < m_dwPoseSize; ++i )
        {
            XMVECTOR vPosA = XMLoadFloat4A( &pSrcPoseA->m_pPositionsOrientations[dwArrayIndex] );
            XMVECTOR vPosB = XMLoadFloat4A( &pSrcPoseB->m_pPositionsOrientations[dwArrayIndex] );
            XMVECTOR vBlendedPos = XMVectorLerpV( vPosA, vPosB, vLerpFactor );
            XMStoreFloat4A( &m_pPositionsOrientations[dwArrayIndex], vBlendedPos );
            XMVECTOR vOrientationA = XMLoadFloat4A( &pSrcPoseA->m_pPositionsOrientations[dwArrayIndex + 1] );
            XMVECTOR vOrientationB = XMLoadFloat4A( &pSrcPoseB->m_pPositionsOrientations[dwArrayIndex + 1] );
            XMVECTOR vBlendedOrientation = XMQuaternionSlerpV( vOrientationA, vOrientationB, vLerpFactor );
            XMStoreFloat4A( &m_pPositionsOrientations[dwArrayIndex + 1], vBlendedOrientation );
            dwArrayIndex += 2;
        }
    }
};


//--------------------------------------------------------------------------------------
// Name: struct Pose4x4
// Desc: Stores an array of aligned 4x4 transform matrices.
//--------------------------------------------------------------------------------------
struct Pose4x4
{
    DWORD m_dwPoseSize;
    XMFLOAT4X4A* m_pTransforms;

                Pose4x4()
                {
                    m_pTransforms = NULL;
                }
    VOID        Allocate( DWORD dwBoneCount )
    {
        if( m_dwPoseSize != dwBoneCount && m_pTransforms != NULL )
        {
            delete[] m_pTransforms;
            m_pTransforms = NULL;
        }

        m_dwPoseSize = dwBoneCount;
        if( m_pTransforms == NULL )
        {
            m_pTransforms = new XMFLOAT4X4A[ dwBoneCount ];
        }
    }
    VOID        CopyToPose( Pose4x4* pDestPose ) const
    {
        assert( m_dwPoseSize == pDestPose->m_dwPoseSize );
        XMemCpy( pDestPose->m_pTransforms, m_pTransforms, m_dwPoseSize * sizeof( XMFLOAT4X4A ) );
    }
    XMMATRIX    LoadTransform( DWORD dwIndex ) const
    {
        return XMLoadFloat4x4A( &m_pTransforms[ dwIndex ] );
    }
    VOID        StoreTransform( DWORD dwIndex, CXMMATRIX matTransform )
    {
        XMStoreFloat4x4A( &m_pTransforms[ dwIndex ], matTransform );
    }
};

//--------------------------------------------------------------------------------------
// Name: struct Pose3x4
// Desc: Stores an array of aligned 3x4 transposed transform matrices.
//       This is the type of transform matrix consumed by the GPU or CPU as a bone
//       palette matrix.  The perspective components of the matrix in the fourth
//       row are not needed for skinning, therefore they are omitted.
//--------------------------------------------------------------------------------------
struct Pose3x4
{
    DWORD m_dwPoseSize;
    union
    {
        XMFLOAT4A* m_pTransforms;
        XMHALF4* m_pTransformsHalf;
    };

                Pose3x4()
                {
                    m_pTransforms = NULL;
                }

    VOID        Allocate( const DWORD dwBoneCount )
    {
        if( m_dwPoseSize != dwBoneCount && m_pTransforms != NULL )
        {
            delete[] m_pTransforms;
            m_pTransforms = NULL;
        }

        m_dwPoseSize = dwBoneCount;
        if( m_pTransforms == NULL )
        {
            m_pTransforms = new XMFLOAT4A[ dwBoneCount * 3 ];
        }
    }
    VOID        AllocateHalf( const DWORD dwBoneCount )
    {
        if( m_dwPoseSize != dwBoneCount && m_pTransformsHalf != NULL )
        {
            delete[] m_pTransformsHalf;
            m_pTransformsHalf = NULL;
        }

        m_dwPoseSize = dwBoneCount;
        if( m_pTransformsHalf == NULL )
        {
            m_pTransformsHalf = new XMHALF4[ dwBoneCount * 3 ];
        }
    }
    VOID        StoreTransform( const DWORD dwIndex, CXMMATRIX matTransform )
    {
        // Writing the 3x4 matrix to memory.
        // Note the usage of write barriers here; they instruct the compiler not to
        // reorder the writes, in case we're writing to write-combined memory.
        // If the writes happen out of order, the CPU's store-gathering hardware that
        // is used for write-combined memory will not be used effectively, and the 
        // entire write operation will be much slower.
        XMFLOAT4A* pDest = &m_pTransforms[ dwIndex * 3 ];
        XMStoreFloat4A( pDest++, matTransform.r[0] );
        _WriteBarrier();
        XMStoreFloat4A( pDest++, matTransform.r[1] );
        _WriteBarrier();
        XMStoreFloat4A( pDest, matTransform.r[2] );
    }
    VOID        StoreTransformHalf( const DWORD dwIndex, CXMMATRIX matTransform )
    {
        // Writing the 3x4 matrix to memory.
        // Note the usage of write barriers here; they instruct the compiler not to
        // reorder the writes, in case we're writing to write-combined memory.
        // If the writes happen out of order, the CPU's store-gathering hardware that
        // is used for write-combined memory will not be used effectively, and the 
        // entire write operation will be much slower.
        XMHALF4* pDest = &m_pTransformsHalf[ dwIndex * 3 ];
        XMStoreHalf4( pDest++, matTransform.r[0] );
        _WriteBarrier();
        XMStoreHalf4( pDest++, matTransform.r[1] );
        _WriteBarrier();
        XMStoreHalf4( pDest, matTransform.r[2] );
    }
    // Note: LoadTransform does not fill in the fourth row of the matrix.
    XMMATRIX    LoadTransform( const DWORD dwIndex ) const
    {
        XMMATRIX matTransform;
        XMFLOAT4A* pSrc = &m_pTransforms[ dwIndex * 3 ];
        matTransform.r[0] = XMLoadFloat4A( pSrc++ );
        matTransform.r[1] = XMLoadFloat4A( pSrc++ );
        matTransform.r[2] = XMLoadFloat4A( pSrc );
        return matTransform;
    }
    XMMATRIX    LoadTransformHalf( const DWORD dwIndex ) const
    {
        XMMATRIX matTransform;
        XMHALF4* pSrc = &m_pTransformsHalf[ dwIndex * 3 ];
        matTransform.r[0] = XMLoadHalf4( pSrc++ );
        matTransform.r[1] = XMLoadHalf4( pSrc++ );
        matTransform.r[2] = XMLoadHalf4( pSrc );
        return matTransform;
    }
};


//--------------------------------------------------------------------------------------
// Name: struct Skeleton
// Desc: Represents a hierarchy of bone transforms that point back to frames within
//       a scene hierarchy.
//       The bind pose is the "resting" pose of the skeleton, and the inverse bind
//       pose is computed and cached at load time to be used at runtime for skinning.
//--------------------------------------------------------------------------------------
struct Skeleton
{
    std::vector <ATG::Frame*> m_FrameVector;
    std::vector <INT> m_ParentIndex;
    PoseDecomp m_BindPoseLocal;
    Pose4x4 m_InverseBindPose;

    VOID    Initialize( ATG::Frame* pSkeletonRootFrame );
    DWORD   GetBoneCount() const
    {
        assert( m_FrameVector.size() == m_ParentIndex.size() );
        return m_FrameVector.size();
    }
    INT     FindBone( const ATG::StringID name );

private:
    VOID    BuildFromFrameHierarchy( ATG::Frame* pRootFrame, INT iParentIndex );
};


//--------------------------------------------------------------------------------------
// Name: struct SkinnedMeshBinding
// Desc: Represents a mapping between the bones that influence a skinned mesh and the
//       bones in a skeleton instance.
//--------------------------------------------------------------------------------------
struct SkinnedMeshBinding
{
    ATG::SkinnedMesh* m_pSkinnedMesh;
    INT* m_pSkinInfluenceToSkeletonBone;
    Pose3x4 m_BoneMatrixPalette;

    DWORD GetPaletteSize() const
    {
        return m_BoneMatrixPalette.m_dwPoseSize;
    }
};


//--------------------------------------------------------------------------------------
// Name: struct SkeletonInstance
// Desc: Represents the animated state of a skeleton.
//       Manages bindings to an animation track set and a group of skinned meshes.
//--------------------------------------------------------------------------------------
struct AnimationBinding;
struct SkeletonInstance
{
    Skeleton* m_pSkeleton;
    PoseDecomp m_LocalPose;
    Pose4x4 m_WorldPose;
    AnimationBinding* m_pActiveAnimation;
    SkinnedMeshBinding* m_pSkinnedMeshBindings;
    
    XMVECTOR* m_qJointRotOffset;
    XMVECTOR* m_vJointPosOffset;

    DWORD m_dwSkinnedMeshBindingCount;
            SkeletonInstance()
            {
                m_pActiveAnimation = NULL;
                m_pSkinnedMeshBindings = NULL;
                m_pSkeleton = NULL;
                m_qJointRotOffset = NULL;
                m_vJointPosOffset = NULL;
            }
    VOID    Initialize( Skeleton* pSkeleton, DWORD dwSkinnedMeshBindingCount );
    VOID    BindSkinnedMesh( DWORD dwIndex, ATG::SkinnedMesh* pSkinnedMesh );
    AnimationBinding* CreateAnimationBinding( ATG::Animation* pAnimation );
    VOID    UpdateAnimation( FLOAT fDeltaTime );
    VOID    SetJointRotationOffset( DWORD jointIndex, XMVECTOR qRot ) {m_qJointRotOffset[jointIndex] = qRot;}
    VOID    SetJointPositionOffset( DWORD jointIndex, XMVECTOR vPos ) {m_vJointPosOffset[jointIndex] = vPos;}
    VOID    BuildWorldPose();
    VOID    CreateBonePalette( DWORD dwSkinnedMeshIndex, VOID* pDestBonePalette, BOOL bDestPaletteHalf4 );
};


//--------------------------------------------------------------------------------------
// Name: struct AnimationBinding
// Desc: Represents a mapping between tracks in an animation and bones in a skeleton
//       instance.  Also holds "last key" values that accelerate curve sampling at
//       runtime.
//--------------------------------------------------------------------------------------
struct AnimationBinding
{
    SkeletonInstance* m_pSkeletonInstance;
    ATG::Animation* m_pAnimation;
    INT* m_pAnimationTrackToSkeletonBone;
    DWORD* m_pPositionTrackLastKey;
    DWORD* m_pOrientationTrackLastKey;
    FLOAT m_fPlaybackTime;
    FLOAT m_fPlaybackSpeed;
    DWORD m_dwTrackCount;

            AnimationBinding()
            {
                m_pAnimationTrackToSkeletonBone = NULL;
                m_pPositionTrackLastKey = NULL;
                m_pOrientationTrackLastKey = NULL;
                m_dwTrackCount = 0;
            }
    VOID    Initialize( SkeletonInstance* pSkeletonInstance, ATG::Animation* pAnimation );
    VOID    Tick( FLOAT fDeltaTime )
    {
        m_fPlaybackTime += ( fDeltaTime * m_fPlaybackSpeed );
        m_fPlaybackTime = fmodf( m_fPlaybackTime, m_pAnimation->GetDuration() );
    }
    VOID    SampleAnimationToLocalPose( PoseDecomp* pLocalPose );
};

} //namespace ATG

#endif

```

`XenonDumper/libs/Atg/AtgSpectralDisplay.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// ATGSpectralDisplay.cpp
//
// XNA Developer Connection
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#include "stdafx.h"
#include "ATGSpectralDisplay.h"
#include "AtgUtil.h"
#include "XDSP.h"

namespace ATG
{

//--------------------------------------------------------------------------------------
// Name: CWaveDisplay::CWaveDisplay
// Desc: Constructor
//--------------------------------------------------------------------------------------
CWaveDisplay::CWaveDisplay()
: m_nSamples(0)
, m_hSampleCount( NULL )
, m_hAmplitudeSampler( NULL )
, m_pAmplitudeTexture( NULL )
, m_pEffect( NULL )
, m_pSampleBuffer( NULL )
{
}

//--------------------------------------------------------------------------------------
// Name: CWaveDisplay::Initialize
// Desc: Initilization for the waveform-rendering
//--------------------------------------------------------------------------------------
HRESULT CWaveDisplay::Initialize( ::IDirect3DDevice9* pDevice, UINT nSamples )
{
    HRESULT hr = S_OK;

    m_nSamples = nSamples;
	m_pSampleBuffer = new FLOAT[m_nSamples];
	InitializeCriticalSectionAndSpinCount(&m_cs, 1000);

    //
    // Load and compile the wave display effect
    //
    VOID* pCode;
    DWORD dwSize;
    if( FAILED( LoadFile( "game:\\Media\\Effects\\audio.fx", &pCode, &dwSize ) ) )
        FatalError( "Couldn't load file\n" );

    // Compile an effect
    LPD3DXBUFFER pEffectData;
    LPD3DXBUFFER pErrorList;

    DWORD CompileFlags = D3DXSHADER_FXLPARAMETERS_AS_VARIABLE_NAMES;

    if( FAILED( FXLCompileEffect( (CHAR*)pCode, dwSize,
        NULL, NULL,
        CompileFlags,
        &pEffectData, &pErrorList ) ) )
    {
        pErrorList->Release();
        FatalError( "Couldn't compile effect\n" );
    }

    // Create effect
    if( FAILED( FXLCreateEffect( pDevice, pEffectData->GetBufferPointer(),
        NULL, &m_pEffect ) ) )
        FatalError( "Couldn't compile audio.fx\n" );

    UnloadFile( pCode );
    pEffectData->Release();

    //
    // Create texture to hold wave sample values
    //
    if( FAILED( pDevice->CreateTexture( nSamples, 1, 1, 0, D3DFMT_LIN_R32F, 0, &m_pAmplitudeTexture, NULL )))
        FatalError( "Couldn't create texture for wave output" );

    // Initialize unity roots lookup table used by FFT functions
    XDSP::FFTInitializeUnityTable(m_UnityTable, nBins);

    // Zero-fill the wave texture
    D3DLOCKED_RECT rect;
    m_pAmplitudeTexture->LockRect( 0, &rect, NULL, 0 );
    memset( rect.pBits, 0, nSamples * sizeof(float) );
    m_pAmplitudeTexture->UnlockRect(0);

    m_hSampleCount = m_pEffect->GetParameterHandle( "nSamples" );
    if( m_hSampleCount )
        m_pEffect->SetFloat( m_hSampleCount, (float)nSamples );
    m_hAmplitudeSampler = m_pEffect->GetParameterHandle( "amplitude_sampler" );
    if( m_hAmplitudeSampler )
        m_pEffect->SetSampler( m_hAmplitudeSampler, m_pAmplitudeTexture );

    m_hMin = m_pEffect->GetParameterHandle( "rangeMin" );
    m_hMax = m_pEffect->GetParameterHandle( "rangeMax" );

    return hr;
}

//--------------------------------------------------------------------------------------
// Name: CWaveDisplay::~CWaveDisplay
// Desc: Destructor, free textures
//--------------------------------------------------------------------------------------
CWaveDisplay::~CWaveDisplay(void)
{
    if( m_pEffect )
        m_pEffect->Release();

    if( m_pAmplitudeTexture )
        m_pAmplitudeTexture->Release();

	delete[] m_pSampleBuffer;
}


//--------------------------------------------------------------------------------------
// Name: CWaveDisplay::Update
// Desc: Copies amplitude data into texture. Optionally generates frequencies.
//--------------------------------------------------------------------------------------
HRESULT CWaveDisplay::Update(float* __restrict pSamples, const BOOL bMonitorTimeDomain )
{
    // This path will generate 256 frequency values
    if( !bMonitorTimeDomain )
    {
        static __vector4 realSamples[nBins/4] = {0};
        static __vector4 imaginarySamples[nBins/4] = {0};
        static float scratch[nBins] = {0};

        memset( realSamples, 0, sizeof( realSamples ) );
        memset( imaginarySamples, 0, sizeof( imaginarySamples ) );
        memset( scratch, 0, sizeof( scratch ) );

        memcpy_s((void* __restrict)realSamples, sizeof(realSamples), (void* __restrict)pSamples, min(m_nSamples, nBins) * sizeof(FLOAT));

        //Run the result through an FFT to analyze the frequency response.
        XDSP::FFT(realSamples, imaginarySamples, m_UnityTable, nBins);
        //Convert to polar form
        XDSP::FFTPolar(realSamples, realSamples, imaginarySamples, nBins);

        // The FFT produces samples out of order; get them back into order
        // of increasing frequency
        XDSP::FFTUnswizzle((XDSP::XVECTOR*)scratch, realSamples, nBinsLog2);

        // convert to a more useful display format: throw away the
        // "negative" samples and change to logarithmic.
        //
        int nBands = 64;
        int bandWidth = nSamples / nBands;

		float exponent = log( (float)( nBins / 2 ) ) / log( 2.0f );
        exponent /= (float)nBands;
        for( int j = 0; j < nBands; ++j )
        {
            int low = (int)floor( pow( 2.0f, exponent * (float)j ) );
            int high = (int)ceil( pow( 2.0f, exponent * (float)(j+1) ) );
            float energy = 0;
            float binwidth = 0;
            for( int bin = low; ( bin < high ) && ( bin < (nBins/2) ); ++bin )
            {
                energy += scratch[bin];
                binwidth += 1.0f;
            }

            const float biasScale = 4.0f / binwidth;
            for( int x = 0; x < bandWidth; ++x )
            {
                ((float*)pSamples)[j*bandWidth + x] = energy * biasScale;
            }

        }
    }

	// Note: we double buffer the samples so that we can collect data and render
	//       it on separate threads. To make this work efficiently requires a
	//       bit more work than this, but at this point would require extensive
	//       changes. So for now, we do it inefficiently and move data around.
	EnterCriticalSection(&m_cs);
	memcpy((void* __restrict) m_pSampleBuffer, (void* __restrict )pSamples, m_nSamples * sizeof(FLOAT));
	LeaveCriticalSection(&m_cs);

    return S_OK;
}

//--------------------------------------------------------------------------------------
// Name: CWaveDisplay::Render
// Desc: Does actual drawing of amplitude texture.
//--------------------------------------------------------------------------------------
HRESULT CWaveDisplay::Render( ::IDirect3DDevice9* pDevice, const D3DRECT& pBounds )
{
    HRESULT hr = S_OK;

    D3DVIEWPORT9 vpOld;
    hr = pDevice->GetViewport( &vpOld );

	D3DLOCKED_RECT rect;

	hr = m_pAmplitudeTexture->LockRect( 0, &rect, NULL, 0 );
	if( SUCCEEDED( hr ) )
	{
		EnterCriticalSection(&m_cs);
		memcpy( rect.pBits, m_pSampleBuffer, m_nSamples * sizeof( float ) );
		LeaveCriticalSection(&m_cs);
		hr = m_pAmplitudeTexture->UnlockRect(0);
	}

    if( SUCCEEDED( hr ) )
    {
        D3DVIEWPORT9 vpNew = { 0, 0, 0, 0, 0.0f, 1.0f };
        vpNew.X = pBounds.x1;
        vpNew.Y = pBounds.y1;
        vpNew.Width = pBounds.x2 - pBounds.x1;
        vpNew.Height = pBounds.y2 - pBounds.y1;
        hr = pDevice->SetViewport( &vpNew );
    }

    m_pEffect->BeginTechniqueFromIndex( 0, 0 );
    m_pEffect->BeginPassFromIndex( 0 );

    // Set the wave data texture
    m_pEffect->SetSampler( m_hAmplitudeSampler, m_pAmplitudeTexture );
    m_pEffect->Commit();

    hr = FAILED(hr) ? hr : pDevice->SetVertexDeclaration( NULL );
    hr = FAILED(hr) ? hr : pDevice->SetStreamSource( 0, NULL, 0, 0 );
    hr = FAILED(hr) ? hr : pDevice->DrawTessellatedPrimitive( D3DTPT_QUADPATCH, 0, m_nSamples );

    // Unset the wave data texture so that we can put new data into it
    m_pEffect->SetSampler( m_hAmplitudeSampler, NULL );
    m_pEffect->Commit();

    m_pEffect->EndPass();
    m_pEffect->EndTechnique();

    hr = FAILED(hr) ? hr : pDevice->SetViewport( &vpOld );

    return hr;
}

//--------------------------------------------------------------------------------------
// Name: CWaveDisplay::SetRange
// Desc: Set min/max range of FXL
//--------------------------------------------------------------------------------------
void CWaveDisplay::SetRange( float min, float max )
{
    m_pEffect->SetFloat( m_hMin, min );
    m_pEffect->SetFloat( m_hMax, max );
}

//--------------------------------------------------------------------------------------
// Name: CMonitorAPO::CMonitorAPO
// Desc: Constructor
//--------------------------------------------------------------------------------------
CMonitorAPO::CMonitorAPO()
: CSampleXAPOBase<CMonitorAPO, MonitorAPOParams>()
{
}

//--------------------------------------------------------------------------------------
// Name: CMonitorAPO::~CMonitorAPO
// Desc: Destructor
//--------------------------------------------------------------------------------------
CMonitorAPO::~CMonitorAPO()
{
}


//--------------------------------------------------------------------------------------
// Name: CMonitorAPO::DoProcess
// Desc: Process by copying off a portion of the samples to another thread via a LF pipe
//--------------------------------------------------------------------------------------
void CMonitorAPO::DoProcess( const MonitorAPOParams& params, FLOAT32* __restrict pData, UINT32 cFrames, UINT32 cChannels, BOOL bIsEnabled )
{
    if (!bIsEnabled)
        return;

    if( cFrames )
    {
        MonitorAPOPipe* pipe = params.pipe;
        if( pipe )
            pipe->Write( pData, cFrames * cChannels * (WaveFormat().wBitsPerSample >> 3) );
    }
}

} // Namespace ATG

```

`XenonDumper/libs/Atg/AtgSpectralDisplay.h`:

```h
//--------------------------------------------------------------------------------------
// SpectralDisplay.h
//
// XNA Developer Connection
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#pragma once
#include <xtl.h>
#include <fxl.h>
#include "ATGAPOBase.h"
#include "AtgLockFreePipe.h"

namespace ATG
{

#ifndef MONITOR_APO_PIPE_LEN
#define MONITOR_APO_PIPE_LEN 14
#endif

typedef ATG::LockFreePipe<MONITOR_APO_PIPE_LEN> MonitorAPOPipe;

struct MonitorAPOParams
{
    MonitorAPOPipe *pipe;
};

class __declspec( uuid("{A4945B8A-EB14-4c96-8067-DF726B528091}"))
CMonitorAPO
: public CSampleXAPOBase<CMonitorAPO, MonitorAPOParams>
{
public:
    CMonitorAPO();
    ~CMonitorAPO();

    void DoProcess( const MonitorAPOParams&, FLOAT32* __restrict pData, UINT32 cFrames, UINT32 cChannels, BOOL bEnabled );
};

class CWaveDisplay
{
public:
    CWaveDisplay();
    ~CWaveDisplay();

    const static DWORD NSAMPLESLOG2 = 8;
    const static DWORD nSamples = 1 << NSAMPLESLOG2;

    HRESULT Initialize( ::IDirect3DDevice9* pDevice, UINT nSamples );
    HRESULT Update( float* __restrict pSamples, const BOOL bMonitorTimeDomain = TRUE );
    HRESULT Render( ::IDirect3DDevice9* pDevice, const D3DRECT& pBounds );

    void SetRange( float min, float max );
private:
    // unity table, used with FFT
    const static int nBinsLog2 = 8;
    const static int nBins = 1 << nBinsLog2;
    __vector4 m_UnityTable[nBins];

	CRITICAL_SECTION m_cs;
    UINT m_nSamples;
	FLOAT* m_pSampleBuffer;

    // FX objects
    FXLEffect*  m_pEffect;

    // Handles for the effect
    FXLHANDLE   m_hAmplitudeSampler;
    FXLHANDLE   m_hSampleCount;
    FXLHANDLE   m_hMin;
    FXLHANDLE   m_hMax;

    IDirect3DTexture9*  m_pAmplitudeTexture;
	
};


} // NameSpace ATG

```

`XenonDumper/libs/Atg/AtgUtil.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// AtgUtil.cpp
//
// Helper functions and typing shortcuts for samples
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#include "stdafx.h"
#include "AtgDevice.h"
#include "AtgUtil.h"

namespace ATG
{

// Global access to the main D3D device
extern D3DDevice* g_pd3dDevice;

// Static shaders used for helper functions
static D3DVertexDeclaration* g_pGradientVertexDecl = NULL;
static D3DVertexShader* g_pGradientVertexShader = NULL;
static D3DPixelShader* g_pGradientPixelShader = NULL;

// Structure used to name threads
typedef struct tagTHREADNAME_INFO
{
    DWORD dwType;     // must be 0x1000
    LPCSTR szName;    // pointer to name (in user address space)
    DWORD dwThreadID; // thread ID (-1 = caller thread)
    DWORD dwFlags;    // reserved for future use, must be zero
} THREADNAME_INFO;

// Linear to high-precision texture format mapping table. Maps GPU standard formats to equivalent high-precision sampling format
// (i.e. _AS_16_16_16_16 etc). Used to create good sRGB formats for textures.
// Any entry that has no mapping just maps to the same format value.
const DWORD g_MapLinearToSrgbGpuFormat[] = 
{
    GPUTEXTUREFORMAT_1_REVERSE,
    GPUTEXTUREFORMAT_1,
    GPUTEXTUREFORMAT_8,
    GPUTEXTUREFORMAT_1_5_5_5,
    GPUTEXTUREFORMAT_5_6_5,
    GPUTEXTUREFORMAT_6_5_5,
    GPUTEXTUREFORMAT_8_8_8_8_AS_16_16_16_16,
    GPUTEXTUREFORMAT_2_10_10_10_AS_16_16_16_16,
    GPUTEXTUREFORMAT_8_A,
    GPUTEXTUREFORMAT_8_B,
    GPUTEXTUREFORMAT_8_8,
    GPUTEXTUREFORMAT_Cr_Y1_Cb_Y0_REP,     
    GPUTEXTUREFORMAT_Y1_Cr_Y0_Cb_REP,      
    GPUTEXTUREFORMAT_16_16_EDRAM,          
    GPUTEXTUREFORMAT_8_8_8_8_A,
    GPUTEXTUREFORMAT_4_4_4_4,
    GPUTEXTUREFORMAT_10_11_11_AS_16_16_16_16,
    GPUTEXTUREFORMAT_11_11_10_AS_16_16_16_16,
    GPUTEXTUREFORMAT_DXT1_AS_16_16_16_16,
    GPUTEXTUREFORMAT_DXT2_3_AS_16_16_16_16,  
    GPUTEXTUREFORMAT_DXT4_5_AS_16_16_16_16,
    GPUTEXTUREFORMAT_16_16_16_16_EDRAM,
    GPUTEXTUREFORMAT_24_8,
    GPUTEXTUREFORMAT_24_8_FLOAT,
    GPUTEXTUREFORMAT_16,
    GPUTEXTUREFORMAT_16_16,
    GPUTEXTUREFORMAT_16_16_16_16,
    GPUTEXTUREFORMAT_16_EXPAND,
    GPUTEXTUREFORMAT_16_16_EXPAND,
    GPUTEXTUREFORMAT_16_16_16_16_EXPAND,
    GPUTEXTUREFORMAT_16_FLOAT,
    GPUTEXTUREFORMAT_16_16_FLOAT,
    GPUTEXTUREFORMAT_16_16_16_16_FLOAT,
    GPUTEXTUREFORMAT_32,
    GPUTEXTUREFORMAT_32_32,
    GPUTEXTUREFORMAT_32_32_32_32,
    GPUTEXTUREFORMAT_32_FLOAT,
    GPUTEXTUREFORMAT_32_32_FLOAT,
    GPUTEXTUREFORMAT_32_32_32_32_FLOAT,
    GPUTEXTUREFORMAT_32_AS_8,
    GPUTEXTUREFORMAT_32_AS_8_8,
    GPUTEXTUREFORMAT_16_MPEG,
    GPUTEXTUREFORMAT_16_16_MPEG,
    GPUTEXTUREFORMAT_8_INTERLACED,
    GPUTEXTUREFORMAT_32_AS_8_INTERLACED,
    GPUTEXTUREFORMAT_32_AS_8_8_INTERLACED,
    GPUTEXTUREFORMAT_16_INTERLACED,
    GPUTEXTUREFORMAT_16_MPEG_INTERLACED,
    GPUTEXTUREFORMAT_16_16_MPEG_INTERLACED,
    GPUTEXTUREFORMAT_DXN,
    GPUTEXTUREFORMAT_8_8_8_8_AS_16_16_16_16,
    GPUTEXTUREFORMAT_DXT1_AS_16_16_16_16,
    GPUTEXTUREFORMAT_DXT2_3_AS_16_16_16_16,
    GPUTEXTUREFORMAT_DXT4_5_AS_16_16_16_16,
    GPUTEXTUREFORMAT_2_10_10_10_AS_16_16_16_16,
    GPUTEXTUREFORMAT_10_11_11_AS_16_16_16_16,
    GPUTEXTUREFORMAT_11_11_10_AS_16_16_16_16,
    GPUTEXTUREFORMAT_32_32_32_FLOAT,
    GPUTEXTUREFORMAT_DXT3A,
    GPUTEXTUREFORMAT_DXT5A,
    GPUTEXTUREFORMAT_CTX1,
    GPUTEXTUREFORMAT_DXT3A_AS_1_1_1_1,
    GPUTEXTUREFORMAT_8_8_8_8_GAMMA_EDRAM,
    GPUTEXTUREFORMAT_2_10_10_10_FLOAT_EDRAM,
};


//--------------------------------------------------------------------------------------
// Name: DebugSpewV()
// Desc: Internal helper function
//--------------------------------------------------------------------------------------
static VOID DebugSpewV( const CHAR* strFormat, const va_list pArgList )
{
    CHAR str[2048];
    // Use the secure CRT to avoid buffer overruns. Specify a count of
    // _TRUNCATE so that too long strings will be silently truncated
    // rather than triggering an error.
    _vsnprintf_s( str, _TRUNCATE, strFormat, pArgList );
    OutputDebugStringA( str );
}


//--------------------------------------------------------------------------------------
// Name: DebugSpew()
// Desc: Prints formatted debug spew
//--------------------------------------------------------------------------------------
#ifdef  _Printf_format_string_  // VC++ 2008 and later support this annotation
VOID CDECL DebugSpew( _In_z_ _Printf_format_string_ const CHAR* strFormat, ... )
#else
VOID CDECL DebugSpew( const CHAR* strFormat, ... )
#endif
{
    va_list pArgList;
    va_start( pArgList, strFormat );
    DebugSpewV( strFormat, pArgList );
    va_end( pArgList );
}


//--------------------------------------------------------------------------------------
// Name: FatalError()
// Desc: Prints formatted debug spew and breaks into the debugger. Exits the application.
//--------------------------------------------------------------------------------------
#ifdef  _Printf_format_string_  // VC++ 2008 and later support this annotation
VOID CDECL FatalError( _In_z_ _Printf_format_string_ const CHAR* strFormat, ... )
#else
VOID CDECL FatalError( const CHAR* strFormat, ... )
#endif
{
    va_list pArgList;
    va_start( pArgList, strFormat );
    DebugSpewV( strFormat, pArgList );
    va_end( pArgList );

    DebugBreak();

    exit(0);
}

//--------------------------------------------------------------------------------------
// Name: GetAs16SRGBFormat()
// Desc: Get an sRGB format that's good for sampling.
//--------------------------------------------------------------------------------------
D3DFORMAT GetAs16SRGBFormat( D3DFORMAT fmtBase )
{
      return ( D3DFORMAT )(
        (fmtBase & ~(D3DFORMAT_TEXTUREFORMAT_MASK | D3DFORMAT_SIGNX_MASK | D3DFORMAT_SIGNY_MASK | D3DFORMAT_SIGNZ_MASK)) |
            (g_MapLinearToSrgbGpuFormat[ (fmtBase & D3DFORMAT_TEXTUREFORMAT_MASK) >> D3DFORMAT_TEXTUREFORMAT_SHIFT] << D3DFORMAT_TEXTUREFORMAT_SHIFT) |
            (GPUSIGN_GAMMA << D3DFORMAT_SIGNX_SHIFT) |
            (GPUSIGN_GAMMA << D3DFORMAT_SIGNY_SHIFT) |
            (GPUSIGN_GAMMA << D3DFORMAT_SIGNZ_SHIFT)
      );
}

//--------------------------------------------------------------------------------------
// Name: GetAs16SRGBFormatGPU()
// Desc: Get a GPU sRGB format that's good for sampling.
//--------------------------------------------------------------------------------------
DWORD GetAs16SRGBFormatGPU( D3DFORMAT fmtBase )
{
    return g_MapLinearToSrgbGpuFormat[ (fmtBase & D3DFORMAT_TEXTUREFORMAT_MASK) >> D3DFORMAT_TEXTUREFORMAT_SHIFT ];
}

//--------------------------------------------------------------------------------------
// Name: ConvertTextureToAs16SRGBFormat()
// Desc: Get a GPU sRGB format that's good for sampling.
//--------------------------------------------------------------------------------------
void ConvertTextureToAs16SRGBFormat( D3DTexture *pTexture )
{
    // First thing, mark the texture SignX, SignY and SignZ as sRGB.
    pTexture->Format.SignX = GPUSIGN_GAMMA;
    pTexture->Format.SignY = GPUSIGN_GAMMA;
    pTexture->Format.SignZ = GPUSIGN_GAMMA;

    // Get the texture format...
    XGTEXTURE_DESC desc;
    XGGetTextureDesc( pTexture, 0, &desc );

    // ...and convert it to a "good" format (AS_16_16_16_16).
    pTexture->Format.DataFormat = GetAs16SRGBFormatGPU( desc.Format );
}


//--------------------------------------------------------------------------------------
// Name: GetVideoSettings()
// Desc: Returns the default display mode of 720P, and queries hardware for Widescreen
//--------------------------------------------------------------------------------------
VOID GetVideoSettings( UINT* pdwDisplayWidth, UINT* pdwDisplayHeight,
                       BOOL* pbWidescreen )
{
    // Query the hardware for video settings so we can determine if WideScreen is enabled.
    XVIDEO_MODE VideoMode;
    XGetVideoMode( &VideoMode );
    if( pbWidescreen )       ( *pbWidescreen ) = VideoMode.fIsWideScreen;
    
    // Resolution is always 720P. The hardware scaler will up or down-scale as needed.
    if( pdwDisplayWidth )    ( *pdwDisplayWidth ) = 1280;
    if( pdwDisplayHeight )   ( *pdwDisplayHeight ) = 720;
}


//--------------------------------------------------------------------------------------
// Name: GetTitleSafeArea()
// Desc: Returns the title safe area for the given display mode
//--------------------------------------------------------------------------------------
D3DRECT GetTitleSafeArea()
{
    D3DDISPLAYMODE mode;
    g_pd3dDevice->GetDisplayMode( 0, &mode );

    D3DRECT rcSafeArea;
    rcSafeArea.x1 = ( LONG )( mode.Width * 0.1f );
    rcSafeArea.y1 = ( LONG )( mode.Height * 0.1f );
    rcSafeArea.x2 = ( LONG )( mode.Width * 0.9f );
    rcSafeArea.y2 = ( LONG )( mode.Height * 0.9f );
    return rcSafeArea;
}


//--------------------------------------------------------------------------------------
// Name: CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized UVW vectors
//--------------------------------------------------------------------------------------
HRESULT CreateNormalizationCubeMap( DWORD dwSize, D3DCubeTexture** ppCubeMap )
{
    // Create the cube map
    HRESULT hr = g_pd3dDevice->CreateCubeTexture( dwSize, 1, 0, D3DFMT_LIN_Q8W8V8U8,
                                                  D3DPOOL_DEFAULT, ppCubeMap, NULL );
    if( FAILED( hr ) )
    {
        ATG_PrintError( "CreateCubeTexture() failed.\n" );
        return hr;
    }

    // Allocate temp space for swizzling the cubemap surfaces
    DWORD* pSourceBits = new DWORD[ dwSize * dwSize ];

    // Fill all six sides of the cubemap
    for( DWORD i = 0; i < 6; i++ )
    {
        // Lock the i'th cubemap surface
        D3DSurface* pCubeMapFace;
        ( *ppCubeMap )->GetCubeMapSurface( ( D3DCUBEMAP_FACES )i, 0, &pCubeMapFace );

        // Write the RGBA-encoded normals to the surface pixels
        DWORD* pPixel = pSourceBits;
        FLOAT w, h;

        for( DWORD y = 0; y < dwSize; y++ )
        {
            h = ( FLOAT )y / ( FLOAT )( dwSize - 1 );  // 0 to 1
            h = ( h * 2.0f ) - 1.0f;           // -1 to 1

            for( DWORD x = 0; x < dwSize; x++ )
            {
                w = ( FLOAT )x / ( FLOAT )( dwSize - 1 );   // 0 to 1
                w = ( w * 2.0f ) - 1.0f;            // -1 to 1

                XMFLOAT3A n;
                memset(&n, 0, sizeof(n));

                // Calc the normal for this texel
                switch( i )
                {
                    case D3DCUBEMAP_FACE_POSITIVE_X:    // +x
                        n.x = +1.0;
                        n.y = -h;
                        n.z = -w;
                        break;

                    case D3DCUBEMAP_FACE_NEGATIVE_X:    // -x
                        n.x = -1.0;
                        n.y = -h;
                        n.z = +w;
                        break;

                    case D3DCUBEMAP_FACE_POSITIVE_Y:    // y
                        n.x = +w;
                        n.y = +1.0;
                        n.z = +h;
                        break;

                    case D3DCUBEMAP_FACE_NEGATIVE_Y:    // -y
                        n.x = +w;
                        n.y = -1.0;
                        n.z = -h;
                        break;

                    case D3DCUBEMAP_FACE_POSITIVE_Z:    // +z
                        n.x = +w;
                        n.y = -h;
                        n.z = +1.0;
                        break;

                    case D3DCUBEMAP_FACE_NEGATIVE_Z:    // -z
                        n.x = -w;
                        n.y = -h;
                        n.z = -1.0;
                        break;
                }

                // Store the normal as an signed QWVU vector
                XMVECTOR t = XMVector3Normalize( XMLoadFloat3A( &n ) );
                *pPixel++ = VectorToQWVU( t );
            }
        }

        // Swizzle the result into the cubemap face surface
        D3DLOCKED_RECT lock;
        pCubeMapFace->LockRect( &lock, 0, 0L );
        memcpy( lock.pBits, pSourceBits, dwSize * dwSize * sizeof( DWORD ) );
        pCubeMapFace->UnlockRect();

        // Release the cubemap face
        pCubeMapFace->Release();
    }

    delete [] pSourceBits;
    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: LoadFile()
// Desc: Helper function to load a file
//--------------------------------------------------------------------------------------
HRESULT LoadFile( const CHAR* strFileName, VOID** ppFileData, DWORD* pdwFileSize )
{
    assert( ppFileData );
    if( pdwFileSize )
        *pdwFileSize = 0L;

    // Open the file for reading
    HANDLE hFile = CreateFile( strFileName, GENERIC_READ, 0, NULL,
                               OPEN_EXISTING, 0, NULL );

    if( INVALID_HANDLE_VALUE == hFile )
        return E_HANDLE;

    DWORD dwFileSize = GetFileSize( hFile, NULL );
    VOID* pFileData = malloc( dwFileSize );

    if( NULL == pFileData )
    {
        CloseHandle( hFile );
        return E_OUTOFMEMORY;
    }

    DWORD dwBytesRead;
    if( !ReadFile( hFile, pFileData, dwFileSize, &dwBytesRead, NULL ) )
    {
        CloseHandle( hFile );
        free( pFileData );
        return E_FAIL;
    }

    // Finished reading file
    CloseHandle( hFile );

    if( dwBytesRead != dwFileSize )
    {
        free( pFileData );
        return E_FAIL;
    }

    if( pdwFileSize )
        *pdwFileSize = dwFileSize;
    *ppFileData = pFileData;

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: UnloadFile()
// Desc: Matching unload
//--------------------------------------------------------------------------------------
VOID UnloadFile( VOID* pFileData )
{
    assert( pFileData != NULL );
    free( pFileData );
}


//--------------------------------------------------------------------------------------
// Name: LoadFilePhysicalMemory()
// Desc: Helper function to load a file into physicall memory
//--------------------------------------------------------------------------------------
HRESULT LoadFilePhysicalMemory( const CHAR* strFileName, VOID** ppFileData,
                                DWORD* pdwFileSize, DWORD dwAlignment )
{
    assert( ppFileData );
    if( pdwFileSize )
        *pdwFileSize = 0L;

    // Open the file for reading
    HANDLE hFile = CreateFile( strFileName, GENERIC_READ, 0, NULL,
                               OPEN_EXISTING, 0, NULL );

    if( INVALID_HANDLE_VALUE == hFile )
        return E_HANDLE;

    DWORD dwFileSize = GetFileSize( hFile, NULL );
    VOID* pFileData = XPhysicalAlloc( dwFileSize, MAXULONG_PTR, dwAlignment, PAGE_READWRITE );

    if( NULL == pFileData )
    {
        CloseHandle( hFile );
        return E_OUTOFMEMORY;
    }

    DWORD dwBytesRead;
    if( !ReadFile( hFile, pFileData, dwFileSize, &dwBytesRead, NULL ) )
    {
        CloseHandle( hFile );
        XPhysicalFree( pFileData );
        return E_FAIL;
    }

    // Finished reading file
    CloseHandle( hFile );

    if( dwBytesRead != dwFileSize )
    {
        XPhysicalFree( pFileData );
        return E_FAIL;
    }

    if( pdwFileSize )
        *pdwFileSize = dwFileSize;
    *ppFileData = pFileData;

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: UnloadFilePhysicalMemory()
// Desc: Matching unload
//--------------------------------------------------------------------------------------
VOID UnloadFilePhysicalMemory( VOID* pFileData )
{
    assert( pFileData != NULL );
    XPhysicalFree( pFileData );
}


//--------------------------------------------------------------------------------------
// Name: SaveFile()
// Desc: Helper function to save a file
//--------------------------------------------------------------------------------------
HRESULT SaveFile( const CHAR* strFileName, VOID* pFileData, DWORD dwFileSize )
{
    // Open the file for reading
    HANDLE hFile = CreateFile( strFileName, GENERIC_WRITE, 0, NULL,
                               CREATE_ALWAYS, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_HANDLE;

    DWORD dwBytesWritten;
    WriteFile( hFile, pFileData, dwFileSize, &dwBytesWritten, NULL );

    // Finished reading file
    CloseHandle( hFile );

    if( dwBytesWritten != dwFileSize )
        return E_FAIL;

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: SetVertexElement()
// Desc: Helper function for creating vertex declarations
//--------------------------------------------------------------------------------------
inline D3DVERTEXELEMENT9 SetVertexElement( WORD& Offset, DWORD Type,
                                           BYTE Usage, BYTE UsageIndex )
{
    D3DVERTEXELEMENT9 Element;
    Element.Stream = 0;
    Element.Offset = Offset;
    Element.Type = Type;
    Element.Method = D3DDECLMETHOD_DEFAULT;
    Element.Usage = Usage;
    Element.UsageIndex = UsageIndex;

    switch( Type )
    {
        case D3DDECLTYPE_FLOAT1:   Offset += 1*sizeof(FLOAT); break;
        case D3DDECLTYPE_FLOAT2:   Offset += 2*sizeof(FLOAT); break;
        case D3DDECLTYPE_FLOAT3:   Offset += 3*sizeof(FLOAT); break;
        case D3DDECLTYPE_FLOAT4:   Offset += 4*sizeof(FLOAT); break;
        case D3DDECLTYPE_D3DCOLOR: Offset += 1*sizeof(DWORD); break;
    }
    return Element;
}


//--------------------------------------------------------------------------------------
// Name: BuildVertexDeclFromFVF()
// Desc: Helper function to create vertex declarations
//--------------------------------------------------------------------------------------
VOID BuildVertexDeclFromFVF( DWORD dwFVF, D3DVERTEXELEMENT9* pDecl )
{
    WORD wOffset = 0;

    // Handle position
    switch( dwFVF & D3DFVF_POSITION_MASK )
    {
        case D3DFVF_XYZ:
            *pDecl++ = SetVertexElement( wOffset, D3DDECLTYPE_FLOAT3, D3DDECLUSAGE_POSITION, 0 ); break;
        case D3DFVF_XYZW:
            *pDecl++ = SetVertexElement( wOffset, D3DDECLTYPE_FLOAT4, D3DDECLUSAGE_POSITION, 0 ); break;
        case D3DFVF_XYZB1:
            *pDecl++ = SetVertexElement( wOffset, D3DDECLTYPE_FLOAT3, D3DDECLUSAGE_POSITION, 0 );
            *pDecl++ = SetVertexElement( wOffset, D3DDECLTYPE_FLOAT1, D3DDECLUSAGE_BLENDWEIGHT, 0 ); break;
        case D3DFVF_XYZB2:
            *pDecl++ = SetVertexElement( wOffset, D3DDECLTYPE_FLOAT3, D3DDECLUSAGE_POSITION, 0 );
            *pDecl++ = SetVertexElement( wOffset, D3DDECLTYPE_FLOAT2, D3DDECLUSAGE_BLENDWEIGHT, 0 ); break;
        case D3DFVF_XYZB3:
            *pDecl++ = SetVertexElement( wOffset, D3DDECLTYPE_FLOAT3, D3DDECLUSAGE_POSITION, 0 );
            *pDecl++ = SetVertexElement( wOffset, D3DDECLTYPE_FLOAT3, D3DDECLUSAGE_BLENDWEIGHT, 0 ); break;
        case D3DFVF_XYZB4:
            *pDecl++ = SetVertexElement( wOffset, D3DDECLTYPE_FLOAT3, D3DDECLUSAGE_POSITION, 0 );
            *pDecl++ = SetVertexElement( wOffset, D3DDECLTYPE_FLOAT4, D3DDECLUSAGE_BLENDWEIGHT, 0 ); break;
    }

    // Handle normal, diffuse, and specular
    if( dwFVF & D3DFVF_NORMAL )    *pDecl++ = SetVertexElement( wOffset, D3DDECLTYPE_FLOAT3, D3DDECLUSAGE_NORMAL, 0 );
    if( dwFVF & D3DFVF_DIFFUSE )   *pDecl++ = SetVertexElement( wOffset, D3DDECLTYPE_D3DCOLOR, D3DDECLUSAGE_COLOR, 0 );
    if( dwFVF & D3DFVF_SPECULAR )  *pDecl++ = SetVertexElement( wOffset, D3DDECLTYPE_D3DCOLOR, D3DDECLUSAGE_COLOR, 1 );

    // Handle texture coordinates
    DWORD dwNumTextures = ( dwFVF & D3DFVF_TEXCOUNT_MASK ) >> D3DFVF_TEXCOUNT_SHIFT;

    for( DWORD i = 0; i < dwNumTextures; i++ )
    {
        LONG lTexCoordSize = ( dwFVF & ( 0x00030000 << ( i * 2 ) ) );

        if( lTexCoordSize == D3DFVF_TEXCOORDSIZE1(i) ) *pDecl++ = SetVertexElement( wOffset, D3DDECLTYPE_FLOAT1, D3DDECLUSAGE_TEXCOORD, (BYTE)i );
        if( lTexCoordSize == D3DFVF_TEXCOORDSIZE2(i) ) *pDecl++ = SetVertexElement( wOffset, D3DDECLTYPE_FLOAT2, D3DDECLUSAGE_TEXCOORD, (BYTE)i );
        if( lTexCoordSize == D3DFVF_TEXCOORDSIZE3(i) ) *pDecl++ = SetVertexElement( wOffset, D3DDECLTYPE_FLOAT3, D3DDECLUSAGE_TEXCOORD, (BYTE)i );
        if( lTexCoordSize == D3DFVF_TEXCOORDSIZE4(i) ) *pDecl++ = SetVertexElement( wOffset, D3DDECLTYPE_FLOAT4, D3DDECLUSAGE_TEXCOORD, (BYTE)i );
    }

    // End the declarator
    pDecl->Stream = 0xff;
    pDecl->Offset = 0;
    pDecl->Type = ( DWORD )D3DDECLTYPE_UNUSED;
    pDecl->Method = 0;
    pDecl->Usage = 0;
    pDecl->UsageIndex = 0;
}



//--------------------------------------------------------------------------------------
// Vertex and pixel shaders for gradient background rendering
//--------------------------------------------------------------------------------------
static const CHAR* g_strGradientShader =
    "struct VS_IN                                              \n"
    "{                                                         \n"
    "   float4   Position     : POSITION;                      \n"
    "   float4   Color        : COLOR0;                        \n"
    "};                                                        \n"
    "                                                          \n"
    "struct VS_OUT                                             \n"
    "{                                                         \n"
    "   float4 Position       : POSITION;                      \n"
    "   float4 Diffuse        : COLOR0;                        \n"
    "};                                                        \n"
    "                                                          \n"
    "VS_OUT GradientVertexShader( VS_IN In )                   \n"
    "{                                                         \n"
    "   VS_OUT Out;                                            \n"
    "   Out.Position = In.Position;                            \n"
    "   Out.Diffuse  = In.Color;                               \n"
    "   return Out;                                            \n"
    "}                                                         \n"
    "                                                          \n"
    "                                                          \n"
    "float4 GradientPixelShader( VS_OUT In ) : COLOR0          \n"
    "{                                                         \n"
    "   return In.Diffuse;                                     \n"
    "}                                                         \n";


//--------------------------------------------------------------------------------------
// Name: CreateGradientShaders()
// Desc: Creates the global gradient shaders
//--------------------------------------------------------------------------------------
HRESULT CreateGradientShaders()
{
    // Create vertex declaration
    if( NULL == g_pGradientVertexDecl )
    {
        static const D3DVERTEXELEMENT9 decl[] =
        {
            { 0,  0, D3DDECLTYPE_FLOAT4,   D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0 },
            { 0, 16, D3DDECLTYPE_D3DCOLOR, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_COLOR,    0 },
            D3DDECL_END()
        };

        if( FAILED( g_pd3dDevice->CreateVertexDeclaration( decl, &g_pGradientVertexDecl ) ) )
            return E_FAIL;
    }

    // Create vertex shader
    if( NULL == g_pGradientVertexShader )
    {
        ID3DXBuffer* pShaderCode;
        if( FAILED( D3DXCompileShader( g_strGradientShader, strlen( g_strGradientShader ),
                                       NULL, NULL, "GradientVertexShader", "vs.2.0", 0,
                                       &pShaderCode, NULL, NULL ) ) )
            return E_FAIL;

        if( FAILED( g_pd3dDevice->CreateVertexShader( ( DWORD* )pShaderCode->GetBufferPointer(),
                                                      &g_pGradientVertexShader ) ) )
            return E_FAIL;

        pShaderCode->Release();
    }

    // Create pixel shader.
    if( NULL == g_pGradientPixelShader )
    {
        ID3DXBuffer* pShaderCode;
        if( FAILED( D3DXCompileShader( g_strGradientShader, strlen( g_strGradientShader ),
                                       NULL, NULL, "GradientPixelShader", "ps.2.0", 0,
                                       &pShaderCode, NULL, NULL ) ) )
            return E_FAIL;

        if( FAILED( g_pd3dDevice->CreatePixelShader( ( DWORD* )pShaderCode->GetBufferPointer(),
                                                     &g_pGradientPixelShader ) ) )
            return E_FAIL;

        pShaderCode->Release();
    }

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: RenderBackground()
// Desc: Draws a gradient filled background
//--------------------------------------------------------------------------------------
VOID RenderBackground( DWORD dwTopColor, DWORD dwBottomColor )
{
    // Save state
    DWORD dwZFunc;
    g_pd3dDevice->GetRenderState( D3DRS_ZFUNC, &dwZFunc );

    // Set state
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_ZFUNC, D3DCMP_ALWAYS );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID );
    g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
    g_pd3dDevice->SetRenderState( D3DRS_VIEWPORTENABLE, TRUE );

    // Draw a background-filling quad
    struct VERTEX
    {
        FLOAT sx, sy, sz, rhw;
        DWORD Color;
    };

    VERTEX v[3] =
    {
        { -1.0f,  1.0f, 1.0f, 1.0f, dwTopColor },
        {  1.0f,  1.0f, 1.0f, 1.0f, dwTopColor },
        { -1.0f, -1.0f, 1.0f, 1.0f, dwBottomColor },
    };

    // The shaders will be created on the first call to CreateGradientShaders()
    // and then re-used for subsequent calls
    if( FAILED( CreateGradientShaders() ) )
        FatalError( "Couldn't create shaders for RenderBackground" );

    g_pd3dDevice->SetVertexDeclaration( g_pGradientVertexDecl );
    g_pd3dDevice->SetVertexShader( g_pGradientVertexShader );
    g_pd3dDevice->SetPixelShader( g_pGradientPixelShader );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_RECTLIST, 1, v, sizeof( VERTEX ) );

    // Restore state
    g_pd3dDevice->SetRenderState( D3DRS_ZFUNC, dwZFunc );
}


//--------------------------------------------------------------------------------------
// Name: LoadConstantTable()
// Desc: Creates a D3DX constant table object from the microcode constant table
//       contained within a microcode shader code buffer.
//       Returns NULL if no constant table is present in the shader.
//--------------------------------------------------------------------------------------
LPD3DXCONSTANTTABLE LoadConstantTable( VOID* pShaderCode )
{
    // Get the D3DXSHADER_CONSTANTTABLE structure. 
    const D3DXSHADER_CONSTANTTABLE* pDXShaderConstantTable;
    DWORD dwTableSize = 0;

    HRESULT hr = XGMicrocodeGetConstantTable( pShaderCode, &pDXShaderConstantTable, &dwTableSize );

    if( FAILED( hr ) )
    {
        return NULL;
    }

    if( dwTableSize > 0 )
    {
        // Get the LPD3DXCONSTANTTABLE object from the D3DXSHADER_CONSTANTTABLE structure. 
        D3DXSHADER_CONSTANTTABLE* pNativeConstantTable = ( D3DXSHADER_CONSTANTTABLE* )malloc( dwTableSize );
        assert( pNativeConstantTable != NULL );

        XGCopyUCodeToNativeConstantTable( pDXShaderConstantTable, pNativeConstantTable, dwTableSize );

        LPD3DXCONSTANTTABLE pConstantTableObject = NULL;

        hr = XGCreateConstantTable( pNativeConstantTable, dwTableSize, &pConstantTableObject );

        free( pNativeConstantTable );

        if( FAILED( hr ) )
        {
            return NULL;
        }

        return pConstantTableObject;
    }

    return NULL;
}


//--------------------------------------------------------------------------------------
// Name: LoadVertexShader()
// Desc: Loads pre-compiled vertex shader microcode from the specified file and
//       creates a vertex shader resource.
//--------------------------------------------------------------------------------------
HRESULT LoadVertexShader( const CHAR* strFileName, LPDIRECT3DVERTEXSHADER9* ppVS,
                          LPD3DXCONSTANTTABLE* ppConstantTable )
{
    HRESULT hr;
    VOID* pCode = NULL;
    ( *ppVS ) = NULL;

    if( FAILED( hr = LoadFile( strFileName, &pCode ) ) )
        return hr;
    if( FAILED( hr = g_pd3dDevice->CreateVertexShader( ( DWORD* )pCode, ppVS ) ) )
    {
        UnloadFile( pCode );
        return hr;
    }
    if( ppConstantTable != NULL )
    {
        *ppConstantTable = LoadConstantTable( pCode );
    }
    UnloadFile( pCode );

    return hr;
}


//--------------------------------------------------------------------------------------
// Name: LoadPixelShader()
// Desc: Loads pre-compiled pixel shader microcode from the specified file and
//       creates a pixel shader resource.
//--------------------------------------------------------------------------------------
HRESULT LoadPixelShader( const CHAR* strFileName, LPDIRECT3DPIXELSHADER9* ppPS, LPD3DXCONSTANTTABLE* ppConstantTable )
{
    HRESULT hr;
    VOID* pCode = NULL;
    ( *ppPS ) = NULL;

    if( FAILED( hr = LoadFile( strFileName, &pCode ) ) )
        return hr;
    if( FAILED( hr = g_pd3dDevice->CreatePixelShader( ( DWORD* )pCode, ppPS ) ) )
    {
        UnloadFile( pCode );
        return hr;
    }
    if( ppConstantTable != NULL )
    {
        *ppConstantTable = LoadConstantTable( pCode );
    }
    UnloadFile( pCode );

    return hr;
}


//--------------------------------------------------------------------------------------
// Name: AppendVertexElements()
// Desc: Helper function for building an array of vertex elements.
//--------------------------------------------------------------------------------------
VOID AppendVertexElements( D3DVERTEXELEMENT9* pDstElements, DWORD dwSrcStream,
                           D3DVERTEXELEMENT9* pSrcElements, DWORD dwSrcUsageIndex,
                           DWORD dwSrcOffset )
{
    // Find the end of the destination stream
    while( pDstElements->Stream != 0xff && pDstElements->Type != 0L )
        pDstElements++;

    // Add the source elements
    for(; ; )
    {
        pDstElements->Stream = ( WORD )dwSrcStream;
        pDstElements->Offset = pSrcElements->Offset + ( WORD )dwSrcOffset;
        pDstElements->Type = pSrcElements->Type;
        pDstElements->Method = pSrcElements->Method;
        pDstElements->Usage = pSrcElements->Usage;
        pDstElements->UsageIndex = ( BYTE )dwSrcUsageIndex;

        if( pSrcElements->Stream == 0xff )
        {
            pDstElements->Stream = 0xff;
            pDstElements->Offset = 0;
            pDstElements->Type = ( DWORD )D3DDECLTYPE_UNUSED;
            pDstElements->Method = 0;
            pDstElements->Usage = 0;
            pDstElements->UsageIndex = 0;
            break;
        }

        pSrcElements++;
        pDstElements++;
    }
}


//--------------------------------------------------------------------------------------
// Name: SetThreadName()
// Desc: Set the name of the given thread so that it will show up in the Threads Window
//       in Visual Studio and in PIX timing captures.
//--------------------------------------------------------------------------------------
VOID SetThreadName( DWORD dwThreadID, LPCSTR strThreadName )
{
    THREADNAME_INFO info;
    info.dwType = 0x1000;
    info.szName = strThreadName;
    info.dwThreadID = dwThreadID;
    info.dwFlags = 0;

    __try
    {
        RaiseException( 0x406D1388, 0, sizeof(info) / sizeof(DWORD), (DWORD*)&info );
    }
    __except( GetExceptionCode()== 0x406D1388 ? 
                EXCEPTION_CONTINUE_EXECUTION : EXCEPTION_EXECUTE_HANDLER ) 
    {
        __noop;
    }
}


} // namespace ATG

```

`XenonDumper/libs/Atg/AtgUtil.h`:

```h
//--------------------------------------------------------------------------------------
// AtgUtil.h
//
// Helper functions and typing shortcuts for samples
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#pragma once
#ifndef ATGUTIL_H
#define ATGUTIL_H

#include <xboxmath.h>
#include <stdio.h>
#include <assert.h>

namespace ATG
{

//--------------------------------------------------------------------------------------
// Some macro definitions
//--------------------------------------------------------------------------------------

#ifndef SAFE_RELEASE
#define SAFE_RELEASE(x) { if ( (x) != NULL && (x)->Release() == 0 ) { (x) = NULL; } }
#endif

#ifndef SAFE_DELETE
#define SAFE_DELETE(x) { if ( (x) != NULL ) { delete (x); (x) = NULL; } }
#endif

#ifndef SAFE_DELETE_ARRAY
#define SAFE_DELETE_ARRAY(p) { if(p) { delete[] (p);   (p) = NULL; } }
#endif

#ifndef ARRAY_SIZE
#define ARRAY_SIZE(x) ( sizeof(x) / sizeof(x[0] ) )
#endif

#ifndef RETURN_ON_FAIL
#define RETURN_ON_FAIL(fn) { HRESULT ATG_hr; if ( FAILED( ATG_hr = (fn) ) ) return ATG_hr;}
#endif

#ifndef RETURN_ON_NULL
#define RETURN_ON_NULL(x) { if ( (x) == NULL ) return E_FAIL;}
#endif


//--------------------------------------------------------------------------------------
// Debug spew and error handling routines
//--------------------------------------------------------------------------------------
#ifdef  _Printf_format_string_  // VC++ 2008 and later support this annotation
VOID CDECL DebugSpew( _In_z_ _Printf_format_string_ const CHAR*, ... );  // Un-modified debug spew
VOID CDECL __declspec(noreturn) FatalError( _In_z_ _Printf_format_string_ const CHAR*, ... ); // Debug spew with a forced break and exit
#else
VOID CDECL DebugSpew( const CHAR*, ... );  // Un-modified debug spew
VOID CDECL __declspec(noreturn) FatalError( const CHAR*, ... ); // Debug spew with a forced break and exit
#endif

// Macros for printing warnings/errors with prepended file and line numbers
#define ATG_PrintWarning ATG::DebugSpew( "%s(%d): warning: ", __FILE__, __LINE__ ), ATG::DebugSpew
#define ATG_PrintError   ATG::DebugSpew( "%s(%d): error: ",   __FILE__, __LINE__ ), ATG::DebugSpew
#define ATG_PrintError2   ATG::DebugSpew( "%s(%d): error: ",   __FILE__, __LINE__ ), ATG::DebugSpew, ATG::DebugSpew

// Avoid compiler warnings for unused variables
#define ATG_Unused( x )   ((VOID)(x))

// Assert in debug but still execute code in release
// Useful for validating expected return values from functions
#ifdef _DEBUG
    #define ATG_Verify( e ) assert( e )
#else
    #define ATG_Verify( e ) ATG_Unused( e )
#endif    

//--------------------------------------------------------------------------------------
// Miscellaneous helper functions
//--------------------------------------------------------------------------------------

// For converting a FLOAT to a DWORD (useful for SetRenderState() calls)
inline DWORD FtoDW( FLOAT f )
{
    return *( ( DWORD* )&f );
}


#ifdef _XBOX_VER
// For reinterpreting an XNKID as a 64-bit int, for printing it out.
inline __int64 XNKIDToInt64( const XNKID& xnkid )
{
    assert(sizeof(xnkid) == sizeof(__int64));
    return *(const __int64*)&xnkid;
}
#endif


//--------------------------------------------------------------------------------------
// Name: class Timer
// Desc: Helper class to perform timer operations
//       For stop-watch timer functionality, use:
//          Start()           - To start the timer
//          Stop()            - To stop (or pause) the timer
//          Reset()           - To reset the timer
//          GetTime()         - Returns current time or last stopped time
//
//       For app-timing and per-frame updates, use:
//          GetAbsoluteTime() - To get the absolute system time
//          GetAppTime()      - To get the running time since construction
//                              (which is usually the start of the app)
//          GetElapsedTime()  - To get the time that elapsed since the previous call
//                              GetElapsedTime() call
//          SingleStep()      - To advance the timer by a time delta
//
//       For framerate computation, use the following functions:
//          MarkFrame()       - Increments an internal frame counter
//          GetFrameRate()    - Returns a string with the current frame rate
//--------------------------------------------------------------------------------------
class Timer
{
public:
    DOUBLE m_fLastElapsedAbsoluteTime;
    DOUBLE m_fBaseAbsoluteTime;

    DOUBLE m_fLastElapsedTime;
    DOUBLE m_fBaseTime;
    DOUBLE m_fStopTime;
    BOOL m_bTimerStopped;

    WCHAR   m_strFrameRate[16];
    DWORD m_dwNumFrames;
    DOUBLE m_fLastFPSTime;

    LARGE_INTEGER m_PerfFreq;

            Timer()
            {
                QueryPerformanceFrequency( &m_PerfFreq );
                DOUBLE fTime = GetAbsoluteTime();

                m_fBaseAbsoluteTime = fTime;
                m_fLastElapsedAbsoluteTime = fTime;

                m_fBaseTime = fTime;
                m_fStopTime = 0.0;
                m_fLastElapsedTime = fTime;
                m_bTimerStopped = FALSE;

                m_strFrameRate[0] = L'\0';
                m_dwNumFrames = 0;
                m_fLastFPSTime = fTime;
            }

    DOUBLE  GetAbsoluteTime()
    {
        LARGE_INTEGER Time;
        QueryPerformanceCounter( &Time );
        DOUBLE fTime = ( DOUBLE )Time.QuadPart / ( DOUBLE )m_PerfFreq.QuadPart;
        return fTime;
    }

    DOUBLE  GetTime()
    {
        // Get either the current time or the stop time, depending
        // on whether we're stopped and what command was sent
        return ( m_fStopTime != 0.0 ) ? m_fStopTime : GetAbsoluteTime();
    }

    DOUBLE  GetElapsedTime()
    {
        DOUBLE fTime = GetAbsoluteTime();

        DOUBLE fElapsedAbsoluteTime = ( DOUBLE )( fTime - m_fLastElapsedAbsoluteTime );
        m_fLastElapsedAbsoluteTime = fTime;
        return fElapsedAbsoluteTime;
    }

    // Return the current time
    DOUBLE  GetAppTime()
    {
        return GetTime() - m_fBaseTime;
    }

    // Reset the timer
    DOUBLE  Reset()
    {
        DOUBLE fTime = GetTime();

        m_fBaseTime = fTime;
        m_fLastElapsedTime = fTime;
        m_fStopTime = 0;
        m_bTimerStopped = FALSE;
        return 0.0;
    }

    // Start the timer
    VOID    Start()
    {
        DOUBLE fTime = GetAbsoluteTime();

        if( m_bTimerStopped )
            m_fBaseTime += fTime - m_fStopTime;
        m_fStopTime = 0.0;
        m_fLastElapsedTime = fTime;
        m_bTimerStopped = FALSE;
    }

    // Stop the timer
    VOID    Stop()
    {
        DOUBLE fTime = GetTime();

        if( !m_bTimerStopped )
        {
            m_fStopTime = fTime;
            m_fLastElapsedTime = fTime;
            m_bTimerStopped = TRUE;
        }
    }

    // Advance the timer by 1/10th second
    VOID    SingleStep( DOUBLE fTimeAdvance )
    {
        m_fStopTime += fTimeAdvance;
    }

    VOID    MarkFrame()
    {
        m_dwNumFrames++;
    }

    WCHAR* GetFrameRate()
    {
        DOUBLE fTime = GetAbsoluteTime();

        // Only re-compute the FPS (frames per second) once per second
        if( fTime - m_fLastFPSTime > 1.0 )
        {
            DOUBLE fFPS = m_dwNumFrames / ( fTime - m_fLastFPSTime );
            m_fLastFPSTime = fTime;
            m_dwNumFrames = 0L;
            swprintf_s( m_strFrameRate, L"%0.02f fps", ( FLOAT )fFPS );
        }
        return m_strFrameRate;
    }
};


//--------------------------------------------------------------------------------------
// Name: VectorToRGBA()
// Desc: Converts a normal into an RGBA vector
//--------------------------------------------------------------------------------------
inline D3DCOLOR VectorToRGBA( const XMVECTOR vec, FLOAT fHeight = 1.0f )
{
    XMFLOAT3A v;
    XMStoreFloat3A(&v, vec);

    D3DCOLOR r = ( D3DCOLOR )( ( v.x + 1.0f ) * 127.5f );
    D3DCOLOR g = ( D3DCOLOR )( ( v.y + 1.0f ) * 127.5f );
    D3DCOLOR b = ( D3DCOLOR )( ( v.z + 1.0f ) * 127.5f );
    D3DCOLOR a = ( D3DCOLOR )( 255.0f * fHeight );
    return( ( a << 24L ) + ( r << 16L ) + ( g << 8L ) + ( b << 0L ) );
}


//--------------------------------------------------------------------------------------
// Name: VectorToQWVU()
// Desc: Converts a normal into a signed QWVU vector
//--------------------------------------------------------------------------------------
inline D3DCOLOR VectorToQWVU( const XMVECTOR vec, FLOAT fHeight = 1.0f )
{
    XMFLOAT3A v2;
    XMStoreFloat3A(&v2, vec);

    LONG u = LONG( v2.x * 127.5f ) & 0xFF;
    LONG v = LONG( v2.y * 127.5f ) & 0xFF;
    LONG w = LONG( v2.z * 127.5f ) & 0xFF;
    LONG q = LONG( 127.5f * fHeight ) & 0xFF;
    return( ( q << 24L ) | ( w << 16L ) | ( v << 8L ) | ( u << 0L ) );
}

//--------------------------------------------------------------------------------------
// Name: GetAs16SRGBFormat()
// Desc: Get an sRGB format that's good for sampling.
//--------------------------------------------------------------------------------------
D3DFORMAT GetAs16SRGBFormat( D3DFORMAT fmtBase );

//--------------------------------------------------------------------------------------
// Name: GetAs16SRGBFormatGPU()
// Desc: Get a GPU sRGB format that's good for sampling.
//--------------------------------------------------------------------------------------
DWORD GetAs16SRGBFormatGPU( D3DFORMAT fmtBase );

//--------------------------------------------------------------------------------------
// Name: ConvertTextureToAs16SRGBFormat()
// Desc: Get a GPU sRGB format that's good for sampling.
//--------------------------------------------------------------------------------------
void ConvertTextureToAs16SRGBFormat( D3DTexture *pTexture );

//--------------------------------------------------------------------------------------
// Name: GetVideoSettings()
// Desc: Return various display settings
//--------------------------------------------------------------------------------------
VOID GetVideoSettings( UINT* pdwDisplayWidth=NULL, UINT* pdwDisplayHeight=NULL,
                       BOOL* pbWidescreen=NULL );


//--------------------------------------------------------------------------------------
// Name: GetTitleSafeArea()
// Desc: Returns the title safe area for the given display mode
//--------------------------------------------------------------------------------------
D3DRECT GetTitleSafeArea();


//--------------------------------------------------------------------------------------
// Name: CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors
//--------------------------------------------------------------------------------------
HRESULT CreateNormalizationCubeMap( DWORD dwSize, D3DCubeTexture** ppCubeMap );


//--------------------------------------------------------------------------------------
// Load/save binary files
//--------------------------------------------------------------------------------------
HRESULT SaveFile( const CHAR* strFileName, VOID* pFileData, DWORD dwFileSize );
HRESULT LoadFile( const CHAR* strFileName, VOID** ppFileData,
                  DWORD* pdwFileSize = NULL );
VOID UnloadFile( VOID* pFileData );

HRESULT LoadFilePhysicalMemory( const CHAR* strFileName, VOID** ppFileData,
                                DWORD* pdwFileSize = NULL, DWORD dwAlignment = 0 );
VOID UnloadFilePhysicalMemory( VOID* pFileData );


//--------------------------------------------------------------------------------------
// Name: BuildVertexDeclFromFVF()
// Desc: Returns a vertex declaration element array for an FVF code
//--------------------------------------------------------------------------------------
VOID BuildVertexDeclFromFVF( DWORD dwFVF, D3DVERTEXELEMENT9* pDecl );


//--------------------------------------------------------------------------------------
// Name: RenderBackground()
// Desc: Draws a gradient filled background
//--------------------------------------------------------------------------------------
VOID RenderBackground( DWORD dwTopColor, DWORD dwBottomColor );


//--------------------------------------------------------------------------------------
// Name: Load*Shader()
// Desc: Loads and creates shaders from file
//--------------------------------------------------------------------------------------
HRESULT LoadVertexShader( const CHAR* strFileName, LPDIRECT3DVERTEXSHADER9* ppVS, LPD3DXCONSTANTTABLE* ppConstantTable = NULL );
HRESULT LoadPixelShader( const CHAR* strFileName, LPDIRECT3DPIXELSHADER9* ppPS, LPD3DXCONSTANTTABLE* ppConstantTable = NULL );


//--------------------------------------------------------------------------------------
// Name: AppendVertexElements()
// Desc: Helper function for building an array of vertex elements.
//--------------------------------------------------------------------------------------
VOID AppendVertexElements( D3DVERTEXELEMENT9* pDstElements, DWORD dwSrcStream,
                           D3DVERTEXELEMENT9* pSrcElements, DWORD dwSrcUsageIndex,
                           DWORD dwSrcOffset=0 );

//--------------------------------------------------------------------------------------
// Name: SetThreadName()
// Desc: Set the name of the given thread so that it will show up in the Threads Window
//       in Visual Studio
//--------------------------------------------------------------------------------------
VOID SetThreadName( DWORD dwThreadID, LPCSTR strThreadName );

} // namespace ATG

#endif // ATGUTIL_H

```

`XenonDumper/libs/Atg/AtgVer.h`:

```h
//--------------------------------------------------------------------------------------
// AtgVer.h
//
// Copyright information for samples and tools
//
// XNA Developer Connection.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#pragma once
#ifndef ATGVER_H
#define ATGVER_H

#ifndef ATG_COPYRIGHT_STR
#   define ATG_COPYRIGHT_STR           "Copyright (c) 2000-2010 Microsoft Corporation. All rights reserved.\n\n"
#endif

#ifndef ATG_ABOUT_COPYRIGHT_STR
#   define ATG_ABOUT_COPYRIGHT_STR     "\251 2010 Microsoft Corporation. All rights reserved."
#endif

#endif // ATGVER_H

```

`XenonDumper/libs/Atg/AtgWavebank.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// CWavebank.cpp
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#include "stdafx.h"
#include <xtl.h>
#include "AtgUtil.h"
#include "AtgWavebank.h"
#include "xma2defs.h"

namespace ATG
{

//--------------------------------------------------------------------------------------
// Name: CWavebank::Ctor
// Desc: 
//--------------------------------------------------------------------------------------
CWavebank::CWavebank() :
    m_dwFileSize(0),
    m_pDataEntry(NULL),
    m_pSeekData(NULL),
    m_hFile(INVALID_HANDLE_VALUE)
{
}


//--------------------------------------------------------------------------------------
// Name: CWavebank::Dtor
// Desc: 
//--------------------------------------------------------------------------------------
CWavebank::~CWavebank()
{
    Close();
}


//--------------------------------------------------------------------------------------
// Name: CWavebank::Open
// Desc: Open the wave bank file and verify
//--------------------------------------------------------------------------------------
HRESULT CWavebank::Open( const CHAR* strFileName )
{
    assert( strFileName != NULL );

    HRESULT hr = S_OK;

    // Open the file
    m_hFile = CreateFile(
        strFileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0L,
        NULL );
    if( m_hFile == INVALID_HANDLE_VALUE )
        ATG::FatalError( "Error opening Wavebank file\n" );

    //
    // Load header
    //
    DWORD cbBytesRead;
    if( !ReadFile( m_hFile, &m_wavebankHeader, sizeof( WAVEBANKHEADER ), &cbBytesRead, NULL ) )
        ATG::FatalError( "Couldn't read wavebank header\n" );

    // Verify header
    if( WAVEBANK_HEADER_SIGNATURE != m_wavebankHeader.dwSignature )
    {
        ATG::FatalError( "Invalid Wavebank format\n" );
    }
    if( WAVEBANK_HEADER_VERSION < m_wavebankHeader.dwHeaderVersion )
    {
        ATG::FatalError(
            "Wave bank version (%i) more recent than this tool supports (%i).\n",
            m_wavebankHeader.dwHeaderVersion, WAVEBANK_HEADER_VERSION );
    }

    //
    // Load WAVEBANKDATA
    //
    SetFilePointer( m_hFile, m_wavebankHeader.Segments[WAVEBANK_SEGIDX_BANKDATA].dwOffset, 0, SEEK_SET );
    if( !ReadFile( m_hFile, &m_wavebankData, sizeof( WAVEBANKDATA ), &cbBytesRead, NULL ) )
        ATG::FatalError( "Couldn't read wavebank data block\n" );


    //
    // Load entries
    //
    DWORD cbEntries = m_wavebankHeader.Segments[WAVEBANK_SEGIDX_ENTRYMETADATA].dwLength;
    m_pDataEntry = new WAVEBANKENTRY[ cbEntries / sizeof( WAVEBANKENTRY ) ];
    SetFilePointer( m_hFile, m_wavebankHeader.Segments[WAVEBANK_SEGIDX_ENTRYMETADATA].dwOffset, 0, SEEK_SET );
    if( !ReadFile( m_hFile, m_pDataEntry, cbEntries, &cbBytesRead, NULL ) )
        ATG::FatalError( "Couldn't read wavebank entry metadata\n" );

    //
    // Load seek tables (if any)
    //
    DWORD cbSeekTables = m_wavebankHeader.Segments[WAVEBANK_SEGIDX_SEEKTABLES].dwLength;
    if (cbSeekTables > 0 )
    {
        m_pSeekData = new BYTE[ cbSeekTables ];
        SetFilePointer( m_hFile, m_wavebankHeader.Segments[WAVEBANK_SEGIDX_SEEKTABLES].dwOffset, 0, SEEK_SET );
        if( !ReadFile( m_hFile, m_pSeekData, cbSeekTables, &cbBytesRead, NULL ) )
           ATG::FatalError( "Couldn't read wavebank seek tables\n" );
    } 

    return hr;
}


//--------------------------------------------------------------------------------------
// Name: CWavebank::Close
// Desc: 
//--------------------------------------------------------------------------------------
VOID CWavebank::Close()
{
    delete [] m_pDataEntry;
    m_pDataEntry = NULL;

    delete [] m_pSeekData;
    m_pSeekData = NULL;

    CloseHandle( m_hFile );
    m_hFile = INVALID_HANDLE_VALUE;
}


//--------------------------------------------------------------------------------------
// Name: CWavebank::GetEntries
// Desc: Retrieve a number of entries in the wavebank
//--------------------------------------------------------------------------------------
DWORD CWavebank::GetEntryCount( void ) const
{
    return m_wavebankData.dwEntryCount;
}


//--------------------------------------------------------------------------------------
// Name: CWavebank::GetFormat
// Desc: Get a wave format
//--------------------------------------------------------------------------------------
HRESULT CWavebank::GetEntryFormat( const DWORD dwEntry, WAVEFORMATEX* pFormat ) const
{
    assert( m_pDataEntry != NULL );
    assert( pFormat != NULL );

    // Check entry #
    if( dwEntry >= m_wavebankData.dwEntryCount )
        return S_FALSE;

    const WAVEBANKMINIWAVEFORMAT& miniFmt =
        m_wavebankData.dwFlags & WAVEBANK_FLAGS_COMPACT
        ? m_wavebankData.CompactFormat
        : m_pDataEntry[ dwEntry ].Format;

    switch( miniFmt.wFormatTag )
    {
        case WAVEBANKMINIFORMAT_TAG_PCM:
            pFormat->wFormatTag = WAVE_FORMAT_PCM;
            pFormat->cbSize = 0;
            break;

        case WAVEBANKMINIFORMAT_TAG_XMA:
            pFormat->wFormatTag = WAVE_FORMAT_XMA2;
            pFormat->cbSize = sizeof(XMA2WAVEFORMATEX) - sizeof(WAVEFORMATEX);
            {
                XMA2WAVEFORMATEX* xma2Fmt = reinterpret_cast<XMA2WAVEFORMATEX*>(pFormat);

                WORD wBlockCount = 0;

                // See if we have a seek table and use it for the block count
                if ( m_pSeekData != NULL )
                {
                    WAVEBANKOFFSET offset = ((WAVEBANKOFFSET*)m_pSeekData)[ dwEntry ];
                    if (offset != 0xffffffff) /* XACTOFFSET_INVALID */
                    {
                        const DWORD* pEntrySeekTable = reinterpret_cast<const DWORD*>(m_pSeekData + sizeof(WAVEBANKOFFSET)*m_wavebankData.dwEntryCount + offset);
                        wBlockCount = (WORD)pEntrySeekTable[0];
                    }
                }

                miniFmt.XMA2FillFormatEx( xma2Fmt, wBlockCount, &m_pDataEntry[ dwEntry ] );
            }
            break;

        case WAVEBANKMINIFORMAT_TAG_WMA:
            pFormat->wFormatTag = (miniFmt.wBitsPerSample & 0x1) ? WAVE_FORMAT_WMAUDIO3 : WAVE_FORMAT_WMAUDIO2;
            pFormat->cbSize = 0;
            break;

        default:
            // WAVEBANKMINIFORMAT_TAG_ADPCM is only valid for Windows
            return E_FAIL;
    }

    pFormat->nChannels = miniFmt.nChannels;
    pFormat->wBitsPerSample = miniFmt.BitsPerSample();
    pFormat->nBlockAlign = (WORD) miniFmt.BlockAlign();
    pFormat->nSamplesPerSec = miniFmt.nSamplesPerSec;
    pFormat->nAvgBytesPerSec = miniFmt.nSamplesPerSec * miniFmt.wBlockAlign;

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: CWavebank::GetDuration
// Desc: Get a duration of a wave entry
//--------------------------------------------------------------------------------------
DWORD CWavebank::GetEntryLengthInBytes( const DWORD dwEntry ) const
{
    assert( m_pDataEntry != NULL );

    DWORD result = 0;

    // Check entry #
    if( dwEntry < m_wavebankData.dwEntryCount )
    {
        // Fill out format data
        result = m_pDataEntry[ dwEntry ].PlayRegion.dwLength;
    }

    return result;
}


//--------------------------------------------------------------------------------------
// Name: CWavebank::GetEntryData
// Desc: Retrieve a pointer of sample data
//--------------------------------------------------------------------------------------
HRESULT CWavebank::GetEntryData( const DWORD dwEntry, void** pSample ) const
{
    assert( m_pDataEntry != NULL );
    assert( pSample );
    *pSample = NULL;

    HRESULT hr = S_OK;

    // Check entry #
    if( dwEntry >= m_wavebankData.dwEntryCount )
        hr = S_FALSE;

    *pSample = new BYTE[m_pDataEntry[dwEntry].PlayRegion.dwLength];

    DWORD cbRead;
    SetFilePointer( m_hFile, m_pDataEntry[dwEntry].PlayRegion.dwOffset, 0L, SEEK_SET );
    if( !ReadFile( m_hFile, ( *pSample ), m_pDataEntry[dwEntry].PlayRegion.dwLength, &cbRead, NULL ) )
        hr = E_FAIL;

    if( FAILED( hr ) )
    {
        delete *pSample;
        pSample = NULL;
    }
    return hr;
}

//--------------------------------------------------------------------------------------
// Name: CWavebank::GetEntryOffset
// Desc: Retrieve a pointer of sample data
//--------------------------------------------------------------------------------------
DWORD CWavebank::GetEntryOffset( const DWORD dwEntry ) const
{
    assert( m_pDataEntry != NULL );

    DWORD result = 0;

    // Check entry #
    if( dwEntry < m_wavebankData.dwEntryCount )
    {
        result =
            0//m_wavebankHeader.Segments[WAVEBANK_SEGIDX_ENTRYWAVEDATA].dwOffset
            + m_pDataEntry[ dwEntry ].PlayRegion.dwOffset;
    }
    return result;
}



} // namespace ATG

```

`XenonDumper/libs/Atg/AtgWavebank.h`:

```h
//--------------------------------------------------------------------------------------
// CWavebank.h
//
// Class for handling wavebank
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#pragma once

#include <XAct3wb.h>
namespace ATG
{
//--------------------------------------------------------------------------------------
// Name: CWavebank
// Desc: Class to handle the Wavebank file
//--------------------------------------------------------------------------------------
class CWavebank
{
public:
            CWavebank();
            ~CWavebank();

    // Initialization
    // Open a wavebank. The function allocates buffer for a wavebank
    HRESULT Open( const CHAR* strFileName );
    // Close the wavebank
    VOID    Close();
    // Get # of wave entries in the wavebank
    DWORD   GetEntryCount( void ) const;
    // Get a wave format of the wave entry
    HRESULT GetEntryFormat( const DWORD dwEntry, WAVEFORMATEX* pFormat ) const;
    // Get a duration of the wave entry
    DWORD   GetEntryLengthInBytes( const DWORD dwEntry ) const;
    // Get offset of the wave entry in the bank file
    DWORD   GetEntryOffset( const DWORD dwEntry ) const;
    // Get samples of the wave entry
    HRESULT GetEntryData( const DWORD dwEntry, void** pData ) const;
private:
    DWORD m_dwFileSize;
    WAVEBANKHEADER m_wavebankHeader;
    WAVEBANKDATA m_wavebankData;
    WAVEBANKENTRY* m_pDataEntry;
    BYTE* m_pSeekData;
    HANDLE m_hFile;
};
}

```

`XenonDumper/libs/Atg/AtgXime.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// AtgXime.cpp
//
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//
//
// ** This sample has been modified to run with the XDK Xime Stub library by stevdai **
//
//--------------------------------------------------------------------------------------

#include "stdafx.h"
#include <malloc.h>
#include "AtgXime.h"
#include "AtgUtil.h"
#include "AtgXmlParser.h"


namespace ATG
{
//#define DEBUG_CLEAR_USER_DIC
//#define XEX_TITLE_DIC_FILE_LOCATOR
//--------------------------------------------------------------------------------------
// Globals
//--------------------------------------------------------------------------------------

FILE* Xime::fpUserDic = NULL;

BOOL   Xime::g_bIsStaticXime = FALSE;
BOOL   Xime::m_bLoadTitleDictionary = TRUE; 
WCHAR  Xime::m_StringBuffer[ NUM_STRINGBUFFER ];
WCHAR  Xime::m_CandidateListBuffer[ NUM_STRINGBUFFER ];
char   Xime::m_UserDicMemory[ XEIME_JP_SIZE_OF_USERDIC ];

BOOL   bGetClauseInfo = FALSE;
byte   *g_pvMemoryBlock = NULL;
byte   *g_pvCandidateFilterTable = NULL;

// Japanese Dictionaries
const int   Xime::iNumDicsJP                        = 6;
const char  *szFontFile                             = "game:\\media\\ximecandidatefilter.bin";
const char  Xime::szXEXTitleDicPath[]               = "game:\\media\\XimeJPTitleDictionary.xex";
const char  Xime::szXEXTitleDicPathFileLocator[]    = "game:\\media\\XimeJPTitleDictionary.xex,titledic";
const char  *szLocatorTemplate1                     = "section://%4x,%s#%s";   // For XUI package
const char  *szLocatorTemplate2                     = "section://%4x,%s";      // For Single Section

XOVERLAPPED Xime::s_imeOverLapped = { 0 };
// Chinese Dictionaries
const int   Xime::iNumDicsTC = 1;
const char  Xime::szBopomofoDicPath[]="game:\\media\\ximechtbopomofo.dic";

XIME_KEYMAPPING Xime::m_InputKeymap[] = {
    { MODE_INPUT | MODE_JKT, VK_SHIFT,   XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_ALT | XINPUT_KEYSTROKE_SHIFT, 0, 0, (IMECALLBACK)Xime::SwitchLanguage },  //for Japanese, Hangul, Bopomofo
    { MODE_INPUT | MODE_JKT, VK_RETURN,  XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_COMPLETE, (IMECALLBACK)Xime::Complete },         //for Japanese, Hangul, Bopomofo
    { MODE_INPUT | MODE_JKT, VK_SEPARATOR,XINPUT_KEYSTROKE_KEYDOWN,0, XIME_KEY_COMPLETE, (IMECALLBACK)Xime::Complete },         //for Japanese, Hangul, Bopomofo, special conversion
    { MODE_INPUT | MODE_JKT, VK_BACK,    XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_BACKSPACE, NULL },                               //for Japanese, Hangul, Bopomofo
    { MODE_INPUT | MODE_JKT, VK_DELETE,  XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_DELETE,    NULL },                               //for Japanese, Hangul, Bopomofo
    { MODE_INPUT | MODE_JKT, VK_HOME,    XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_HOME,      NULL },                               //for Japanese, Hangul, Bopomofo
    { MODE_INPUT | MODE_JKT, VK_END,     XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_END,       NULL },                               //for Japanese, Hangul, Bopomofo
    { MODE_INPUT | MODE_JKT, VK_RIGHT,   XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_RIGHT,     NULL },                               //for Japanese, Hangul, Bopomofo
    { MODE_INPUT | MODE_JKT, VK_LEFT,    XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_LEFT,      NULL },                               //for Japanese, Hangul, Bopomofo
    
    { MODE_INPUT | MODE_KR,  VK_PRIOR,   XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_COMPLETE,  NULL },                               // for Hangul
    { MODE_INPUT | MODE_KR,  VK_NEXT,    XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_COMPLETE,  NULL },                               // for Hangul
    { MODE_INPUT | MODE_KR,  VK_INSERT,  XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_COMPLETE,  NULL },                               // for Hangul

    { MODE_INPUT | MODE_JP,  VK_SPACE,   XINPUT_KEYSTROKE_KEYDOWN, XINPUT_KEYSTROKE_SHIFT | XINPUT_KEYSTROKE_CTRL | XINPUT_KEYSTROKE_ALT,   XIME_KEY_CONVERT, (IMECALLBACK)Xime::Convert },         //for Japanese
    { MODE_INPUT | MODE_TC,  VK_SPACE,   XINPUT_KEYSTROKE_KEYDOWN,  XINPUT_KEYSTROKE_ALT,   XIME_KEY_CONVERT, (IMECALLBACK)Xime::Convert },      //for , Bopomofo

    { MODE_INPUT | MODE_JP,  VK_CONVERT, XINPUT_KEYSTROKE_KEYDOWN,  XINPUT_KEYSTROKE_CTRL | XINPUT_KEYSTROKE_ALT,   XIME_KEY_CONVERT, (IMECALLBACK)Xime::Convert },         //for Japanese, Bopomofo
    { MODE_INPUT | MODE_JP,  VK_CONVERT, XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_SHIFT , XINPUT_KEYSTROKE_CTRL | XINPUT_KEYSTROKE_ALT,   XIME_KEY_CONVERT, (IMECALLBACK)Xime::Convert },         //for Japanese, Bopomofo
    { MODE_INPUT | MODE_JP,  VK_NONCONVERT, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_KATAKANA_CANDIDATE , (IMECALLBACK)Xime::NonConvert },            //for Japanese

    { MODE_INPUT | MODE_JKT, VK_ESCAPE,  XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_FLUSH, NULL },                                                   //for Japanese, Bopomofo
    { MODE_INPUT | MODE_JP,  VK_F6,      XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_ALL_HIRAGANA, (IMECALLBACK)Xime::AllConvert },                   //for Japanese, special conversion
    { MODE_INPUT | MODE_JP,  VK_F7,      XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_ALL_KATAKANA, (IMECALLBACK)Xime::AllConvert },                   //for Japanese, special conversion
    { MODE_INPUT | MODE_JP,  VK_F9,      XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_ALL_ALPHANUMERIC_FULL_WIDTH, (IMECALLBACK)Xime::AllConvert },    //for Japanese, special conversion
    { MODE_INPUT | MODE_JP,  VK_F10,     XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_ALL_ALPHANUMERIC_HALF_WIDTH, (IMECALLBACK)Xime::AllConvert },    //for Japanese, special conversion
    { MODE_INPUT | MODE_JP,  L'U',       XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_CTRL, 0,   XIME_KEY_ALL_HIRAGANA, (IMECALLBACK)Xime::AllConvert },   //for Japanese, special conversion
    { MODE_INPUT | MODE_JP,  L'I',       XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_CTRL, 0,   XIME_KEY_ALL_KATAKANA, (IMECALLBACK)Xime::AllConvert },   //for Japanese, special conversion
    { MODE_INPUT | MODE_JP,  L'P',       XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_CTRL, 0,   XIME_KEY_ALL_ALPHANUMERIC_FULL_WIDTH, (IMECALLBACK)Xime::AllConvert },          //for Japanese, special conversion
    { MODE_INPUT | MODE_JP,  L'O',       XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_CTRL, 0,   XIME_KEY_ALL_ALPHANUMERIC_HALF_WIDTH, (IMECALLBACK)Xime::AllConvert },          //for Japanese, special conversion
    { MODE_INPUT | MODE_JP,  VK_KANA,    XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_MODE_JP_ROMAJI_HIRAGANA_WITH_FULLWIDTH_ALPHANUMERIC, (IMECALLBACK)Xime::ChangeInputMode },          //for Japanese, special conversion
    { MODE_INPUT | MODE_JP,  VK_KANA,    XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_SHIFT, 0, XIME_MODE_JP_ROMAJI_KATAKANA_WITH_FULLWIDTH_ALPHANUMERIC, (IMECALLBACK)Xime::ChangeInputMode },          //for Japanese, special conversion
    { MODE_INPUT | MODE_JP,  VK_KANA,    XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_ALT, 0, XIME_MODE_JP_KANAINPUT_WITH_KEYSTROKE_SHIFTFLAG_OFF, (IMECALLBACK)Xime::ToggleKeyboardLayout },          //for Japanese, special conversion

    { MODE_INPUT | MODE_JP,  VK_CAPITAL, XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_MODE_JP_HALFWIDTH_ALPHANUMERIC, (IMECALLBACK)Xime::ChangeInputMode },                            //for Japanese
    { MODE_INPUT | MODE_JP,  VK_KANJI,   XINPUT_KEYSTROKE_KEYDOWN, 0, 0, (IMECALLBACK)Xime::ToggleIME },                            //for Japanese, special conversion, when dashboard is set to Japanese
    { MODE_INPUT | MODE_JP,  VK_KANJI,   XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_ALT, 0, 0, (IMECALLBACK)Xime::ToggleIME },     //for Japanese, special conversion, when dashboard is set to Japanese
    { MODE_INPUT | MODE_JP,  VK_OEM_3,   XINPUT_KEYSTROKE_KEYDOWN, 0, 0, (IMECALLBACK)Xime::ToggleIME },                            //for Japanese, special conversion, when dashboard is set to non-Japanese
    { MODE_INPUT | MODE_JP,  VK_OEM_3,   XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_ALT, 0, 0, (IMECALLBACK)Xime::ToggleIME },     //for Japanese, special conversion, when dashboard is set to non-Japanese
    { MODE_INPUT | MODE_KR,  VK_HANGUL,  XINPUT_KEYSTROKE_KEYDOWN, 0, 0, (IMECALLBACK)Xime::ToggleIME },
    { MODE_INPUT | MODE_TC,  VK_SPACE,   XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_CTRL, 0, 0, (IMECALLBACK)Xime::ToggleIME },    //for Bopomofo

    // Convert mode
    { MODE_CONVERT | MODE_JKT, VK_SHIFT,  XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_ALT | XINPUT_KEYSTROKE_SHIFT, 0, 0, (IMECALLBACK)Xime::SwitchLanguage },  //for Japanese, Bopomofo
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_RETURN,XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_COMPLETE, (IMECALLBACK)Xime::Complete },//for Japanese, Bopomofo
    { MODE_CONVERT | MODE_JP,  VK_SEPARATOR, XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_COMPLETE, (IMECALLBACK)Xime::Complete },     //for Japanese, Bopomofo
    { MODE_CONVERT | MODE_JP,  VK_RIGHT, XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_RIGHT, (IMECALLBACK)Xime::ChangeFocus },         //for Japanese, Hangul
    { MODE_CONVERT | MODE_JP,  VK_LEFT,  XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_LEFT, (IMECALLBACK)Xime::ChangeFocus },          //for Japanese, Hangul
    { MODE_CONVERT | MODE_JP,  VK_RIGHT, XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_SHIFT, 0,   XIME_KEY_RIGHT, (IMECALLBACK)Xime::ChangeClauseLength },          //for Japanese, Hangul
    { MODE_CONVERT | MODE_JP,  VK_LEFT,  XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_SHIFT, 0,   XIME_KEY_LEFT, (IMECALLBACK)Xime::ChangeClauseLength },           //for Japanese, Hangul
    { MODE_CONVERT | MODE_JP,  VK_ESCAPE,XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_FLUSH, (IMECALLBACK)Xime::Revert },              //for Japanese
    { MODE_CONVERT | MODE_TC,  VK_ESCAPE,XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_FLUSH, NULL },                                   //for Bopomofo
    { MODE_CONVERT | MODE_JP,  VK_BACK,  XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_FLUSH, (IMECALLBACK)Xime::Revert },              //for Japanese
    { MODE_CONVERT | MODE_TC,  VK_BACK,  XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_UNICODE, (IMECALLBACK)Xime::NothingToDo },       //for Bopomofo
    { MODE_CONVERT | MODE_JP,  VK_SPACE, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_NEXT, (IMECALLBACK)Xime::SetCandidate },                      //for Japanese, Bopomofo
    { MODE_CONVERT | MODE_TC,  VK_SPACE, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_TOP_OF_NEXT_PAGE, (IMECALLBACK)Xime::SetCandidate },          //for Japanese, Bopomofo
    { MODE_CONVERT | MODE_JP,  VK_CONVERT, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_NEXT, (IMECALLBACK)Xime::SetCandidate },                    //for Japanese, Bopomofo
    { MODE_CONVERT | MODE_JP,  VK_CONVERT, XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_SHIFT, 0, (XIMEKEY)XIME_INDEX_PREV, (IMECALLBACK)Xime::SetCandidate },           //for Japanese, Bopomofo
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_UP,    XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_PREV, (IMECALLBACK)Xime::SetCandidate },             //for Japanese, Bopomofo
    { MODE_CONVERT | MODE_JP,  VK_SPACE, XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_SHIFT, 0,   (XIMEKEY)XIME_INDEX_PREV, (IMECALLBACK)Xime::SetCandidate },           //for Japanese, Bopomofo
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_DOWN,  XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_NEXT, (IMECALLBACK)Xime::SetCandidate },             //for Japanese, Bopomofo
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_PRIOR, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_TOP_OF_PREV_PAGE, (IMECALLBACK)Xime::SetCandidate }, //for Japanese, Bopomofo
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_NEXT,  XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_TOP_OF_NEXT_PAGE, (IMECALLBACK)Xime::SetCandidate }, //for Japanese, Bopomofo
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_HOME,  XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_TOP, (IMECALLBACK)Xime::SetCandidate },              //for Japanese, Bopomofo
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_END,   XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_END, (IMECALLBACK)Xime::SetCandidate },              //for Japanese, Bopomofo
    { MODE_CONVERT | MODE_JP,  VK_NONCONVERT, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_HIRAGANA_KATAKANA_TOGGLE, (IMECALLBACK)Xime::SetCandidate },            //for Japanese
    { MODE_CONVERT | MODE_JP,  VK_F6,    XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_HIRAGANA_CANDIDATE, (IMECALLBACK)Xime::SetCandidate },        //for Japanese
    { MODE_CONVERT | MODE_JP,  VK_F7,    XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_KATAKANA_CANDIDATE, (IMECALLBACK)Xime::SetCandidate },        //for Japanese
    { MODE_CONVERT | MODE_JP,  L'U',     XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_CTRL, 0,   (XIMEKEY)XIME_INDEX_HIRAGANA_CANDIDATE, (IMECALLBACK)Xime::SetCandidate },      //for Japanese
    { MODE_CONVERT | MODE_JP,  L'I',     XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_CTRL, 0,   (XIMEKEY)XIME_INDEX_KATAKANA_CANDIDATE, (IMECALLBACK)Xime::SetCandidate },      //for Japanese
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_NUMPAD0, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_CURRENT_PAGE_OFFSET, (IMECALLBACK)Xime::HandleNumpadConversion },          //for Japanese, special conversion
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_NUMPAD1, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_CURRENT_PAGE_OFFSET, (IMECALLBACK)Xime::HandleNumpadConversion },          //for Japanese, special conversion
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_NUMPAD2, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_CURRENT_PAGE_OFFSET, (IMECALLBACK)Xime::HandleNumpadConversion },          //for Japanese, special conversion
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_NUMPAD3, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_CURRENT_PAGE_OFFSET, (IMECALLBACK)Xime::HandleNumpadConversion },          //for Japanese, special conversion
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_NUMPAD4, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_CURRENT_PAGE_OFFSET, (IMECALLBACK)Xime::HandleNumpadConversion },          //for Japanese, special conversion
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_NUMPAD5, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_CURRENT_PAGE_OFFSET, (IMECALLBACK)Xime::HandleNumpadConversion },          //for Japanese, special conversion
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_NUMPAD6, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_CURRENT_PAGE_OFFSET, (IMECALLBACK)Xime::HandleNumpadConversion },          //for Japanese, special conversion
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_NUMPAD7, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_CURRENT_PAGE_OFFSET, (IMECALLBACK)Xime::HandleNumpadConversion },          //for Japanese, special conversion
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_NUMPAD8, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_CURRENT_PAGE_OFFSET, (IMECALLBACK)Xime::HandleNumpadConversion },          //for Japanese, special conversion
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_NUMPAD9, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_CURRENT_PAGE_OFFSET, (IMECALLBACK)Xime::HandleNumpadConversion },          //for Japanese, special conversion
    { MODE_CONVERT | MODE_JP,  VK_KANJI, XINPUT_KEYSTROKE_KEYDOWN, 0, 0, (IMECALLBACK)Xime::ToggleIME },                                //for Japanese, special conversion, when dashboard is set to Japanese
    { MODE_CONVERT | MODE_JP,  VK_KANJI, XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_ALT, 0, 0, (IMECALLBACK)Xime::ToggleIME },         //for Japanese, special conversion, when dashboard is set to Japanese
    { MODE_CONVERT | MODE_JP,  VK_OEM_3, XINPUT_KEYSTROKE_KEYDOWN, 0, 0, (IMECALLBACK)Xime::ToggleIME },                                //for Japanese, special conversion, when dashboard is set to English
    { MODE_CONVERT | MODE_JP,  VK_OEM_3, XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_ALT, 0, 0, (IMECALLBACK)Xime::ToggleIME },         //for Japanese, special conversion, when dashboard is set to English
    { MODE_CONVERT | MODE_TC,  VK_SPACE, XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_CTRL, 0, 0, (IMECALLBACK)Xime::ToggleIME },

    { MODE_CONVERT | MODE_JP | MODE_TC, VK_0, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_CURRENT_PAGE_OFFSET, (IMECALLBACK)Xime::HandleNumpadConversion },          //for Japanese, special conversion
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_1, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_CURRENT_PAGE_OFFSET, (IMECALLBACK)Xime::HandleNumpadConversion },          //for Japanese, special conversion
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_2, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_CURRENT_PAGE_OFFSET, (IMECALLBACK)Xime::HandleNumpadConversion },          //for Japanese, special conversion
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_3, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_CURRENT_PAGE_OFFSET, (IMECALLBACK)Xime::HandleNumpadConversion },          //for Japanese, special conversion
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_4, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_CURRENT_PAGE_OFFSET, (IMECALLBACK)Xime::HandleNumpadConversion },          //for Japanese, special conversion
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_5, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_CURRENT_PAGE_OFFSET, (IMECALLBACK)Xime::HandleNumpadConversion },          //for Japanese, special conversion
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_6, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_CURRENT_PAGE_OFFSET, (IMECALLBACK)Xime::HandleNumpadConversion },          //for Japanese, special conversion
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_7, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_CURRENT_PAGE_OFFSET, (IMECALLBACK)Xime::HandleNumpadConversion },          //for Japanese, special conversion
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_8, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_CURRENT_PAGE_OFFSET, (IMECALLBACK)Xime::HandleNumpadConversion },          //for Japanese, special conversion
    { MODE_CONVERT | MODE_JP | MODE_TC, VK_9, XINPUT_KEYSTROKE_KEYDOWN, 0, (XIMEKEY)XIME_INDEX_CURRENT_PAGE_OFFSET, (IMECALLBACK)Xime::HandleNumpadConversion },          //for Japanese, special conversion

    // All conversion mode
    { MODE_ALLCONVERT | MODE_JKT, VK_SHIFT,  XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_ALT | XINPUT_KEYSTROKE_SHIFT, 0, 0, (IMECALLBACK)Xime::SwitchLanguage },  //for Japanese, Bopomofo
    { MODE_ALLCONVERT | MODE_JP,  VK_RETURN,  XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_COMPLETE, (IMECALLBACK)Xime::Complete },        //for Japanese, Bopomofo
    { MODE_ALLCONVERT | MODE_JP,  VK_SEPARATOR,XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_COMPLETE, (IMECALLBACK)Xime::Complete },       //for Japanese, Bopomofo
    { MODE_ALLCONVERT | MODE_JP,  VK_ESCAPE,  XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_FLUSH, (IMECALLBACK)Xime::AllRevert },          //for Japanese, Bopomofo
    { MODE_ALLCONVERT | MODE_JP,  VK_BACK,    XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_FLUSH, (IMECALLBACK)Xime::AllRevert },          //for Japanese, Bopomofo
    { MODE_ALLCONVERT | MODE_JP,  VK_F6,      XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_ALL_HIRAGANA, (IMECALLBACK)Xime::AllConvert },          //for Japanese, special conversion
    { MODE_ALLCONVERT | MODE_JP,  VK_F7,      XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_ALL_KATAKANA, (IMECALLBACK)Xime::AllConvert },          //for Japanese, special conversion
    { MODE_ALLCONVERT | MODE_JP,  VK_F9,      XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_ALL_ALPHANUMERIC_FULL_WIDTH, (IMECALLBACK)Xime::AllConvert },           //for Japanese, special conversion
    { MODE_ALLCONVERT | MODE_JP,  VK_F10,     XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_ALL_ALPHANUMERIC_HALF_WIDTH, (IMECALLBACK)Xime::AllConvert },           //for Japanese, special conversion
    { MODE_ALLCONVERT | MODE_JP,  L'U',       XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_CTRL, 0,   XIME_KEY_ALL_HIRAGANA, (IMECALLBACK)Xime::AllConvert },   //for Japanese, special conversion
    { MODE_ALLCONVERT | MODE_JP,  L'I',       XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_CTRL, 0,   XIME_KEY_ALL_KATAKANA, (IMECALLBACK)Xime::AllConvert },   //for Japanese, special conversion
    { MODE_ALLCONVERT | MODE_JP,  L'P',       XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_CTRL, 0,   XIME_KEY_ALL_ALPHANUMERIC_FULL_WIDTH, (IMECALLBACK)Xime::AllConvert },          //for Japanese, special conversion
    { MODE_ALLCONVERT | MODE_JP,  L'O',       XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_CTRL, 0,   XIME_KEY_ALL_ALPHANUMERIC_HALF_WIDTH, (IMECALLBACK)Xime::AllConvert },          //for Japanese, special conversion
    { MODE_ALLCONVERT | MODE_JP,  VK_SPACE,   XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_CONVERT, (IMECALLBACK)Xime::Convert },         //for Japanese, Bopomofo
    { MODE_ALLCONVERT | MODE_JP,  VK_CONVERT, XINPUT_KEYSTROKE_KEYDOWN, 0, XIME_KEY_CONVERT, (IMECALLBACK)Xime::Convert },         //for Japanese, Bopomofo
    { MODE_ALLCONVERT | MODE_JP,  VK_CONVERT, XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_SHIFT, 0, XIME_KEY_CONVERT, (IMECALLBACK)Xime::Convert },         //for Japanese, Bopomofo
    
    { MODE_ALLCONVERT | MODE_JP,  VK_KANJI,   XINPUT_KEYSTROKE_KEYDOWN, 0, 0, (IMECALLBACK)Xime::ToggleIME },                         //for Japanese, special conversion, when dashboard is set to Japanese
    { MODE_ALLCONVERT | MODE_JP,  VK_KANJI,   XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_ALT, 0, 0, (IMECALLBACK)Xime::ToggleIME },  //for Japanese, special conversion, when dashboard is set to Japanese
    { MODE_ALLCONVERT | MODE_JP,  VK_OEM_3,   XINPUT_KEYSTROKE_KEYDOWN, 0, 0, (IMECALLBACK)Xime::ToggleIME },                         //for Japanese, special conversion, when dashboard is set to non-Japanese
    { MODE_ALLCONVERT | MODE_JP,  VK_OEM_3,   XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_ALT, 0, 0, (IMECALLBACK)Xime::ToggleIME },  //for Japanese, special conversion, when dashboard is set to non-Japanese

    { MODE_OFF | MODE_JKT, VK_SHIFT,  XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_ALT | XINPUT_KEYSTROKE_SHIFT, 0, 0, (IMECALLBACK)Xime::SwitchLanguage },  //for Japanese, Hangul, Bopomofo
    { MODE_OFF | MODE_JP, VK_KANJI,   XINPUT_KEYSTROKE_KEYDOWN, 0, 0, (IMECALLBACK)Xime::ToggleIME },                                 //for Japanese, special conversion, when dashboard is set to Japanese
    { MODE_OFF | MODE_JP, VK_KANJI,   XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_ALT, 0, 0, (IMECALLBACK)Xime::ToggleIME },          //for Japanese, special conversion, when dashboard is set to Japanese
    { MODE_OFF | MODE_JP, VK_OEM_3,   XINPUT_KEYSTROKE_KEYDOWN, 0, 0, (IMECALLBACK)Xime::ToggleIME },                                 //for Japanese, special conversion, when dashboard is set to non_Japanese
    { MODE_OFF | MODE_JP, VK_OEM_3,   XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_ALT, 0, 0, (IMECALLBACK)Xime::ToggleIME },          //for Japanese, special conversion, when dashboard is set to non_Japanese
    { MODE_OFF | MODE_KR, VK_HANGUL,  XINPUT_KEYSTROKE_KEYDOWN, 0, 0, (IMECALLBACK)Xime::ToggleIME },
    { MODE_OFF | MODE_TC, VK_SPACE,   XINPUT_KEYSTROKE_KEYDOWN | XINPUT_KEYSTROKE_CTRL, 0, 0, (IMECALLBACK)Xime::ToggleIME },

};
static const DWORD NUM_INPUT_KEYMAP = sizeof(Xime::m_InputKeymap)/sizeof(Xime::m_InputKeymap[0]);

//---------------------------------------------------------------
//   Lookup Table For Japanese (Hiragana character) Non-alphabet characters
//---------------------------------------------------------------
HID_LOOKUP_TABLE JapaneseHiraganaNonAlphabetic[] = {
                                          { 0x1e,   0x38,   0,      0 },
/*HID_USAGE_INDEX_KEYBOARD_ONE*/          { 0x306C, 0x306C, 0x30CC, 0x30CC }, // nu, nu
/*HID_USAGE_INDEX_KEYBOARD_TWO*/          { 0x3075, 0x3075, 0x30D5, 0x30D5 }, // fu, fu
/*HID_USAGE_INDEX_KEYBOARD_THREE*/        { 0x3042, 0x3041, 0x30A2, 0x30A1 }, // a, a (small)
/*HID_USAGE_INDEX_KEYBOARD_FOUR*/         { 0x3046, 0x3045, 0x30A6, 0x30A5 }, // u, u (small)
/*HID_USAGE_INDEX_KEYBOARD_FIVE*/         { 0x3048, 0x3047, 0x30A8, 0x30A7 }, // e, e (small)
/*HID_USAGE_INDEX_KEYBOARD_SIX*/          { 0x304A, 0x3049, 0x30AA, 0x30A9 }, // o, o (small)
/*HID_USAGE_INDEX_KEYBOARD_SEVEN*/        { 0x3084, 0x3083, 0x30E4, 0x30E3 }, // ya, ya (small)
/*HID_USAGE_INDEX_KEYBOARD_EIGHT*/        { 0x3086, 0x3085, 0x30E6, 0x30E5 }, // yu, yu (small)
/*HID_USAGE_INDEX_KEYBOARD_NINE*/         { 0x3088, 0x3087, 0x30E8, 0x30E7 }, // yo, yo (small)
/*HID_USAGE_INDEX_KEYBOARD_ZERO*/         { 0x308F, 0x3092, 0x30EF, 0x30F2 }, // wa, o
/*HID_USAGE_INDEX_KEYBOARD_RETURN*/       { 0x000A, 0x000A, 0x000A, 0x000A }, //LF,LF
/*HID_USAGE_INDEX_KEYBOARD_ESCAPE*/       { 0x001B, 0x001B, 0x001B, 0x001B }, //ESC,ESC
/*HID_USAGE_INDEX_KEYBOARD_BACKSPACE*/    { 0x0008, 0x0008, 0x0008, 0x0008 }, //BS
/*HID_USAGE_INDEX_KEYBOARD_TAB*/          { 0x0000, 0x0000, 0x0000, 0x0000 }, //TAB is not supported
/*HID_USAGE_INDEX_KEYBOARD_SPACEBAR*/     { 0x0020, 0x0020, 0x0020, 0x0020 }, //SPACE,SPACE
/*HID_USAGE_INDEX_KEYBOARD_MINUS*/        { 0x307B, 0x307B, 0x30DB, 0x30DB }, // ho, ho
/*HID_USAGE_INDEX_KEYBOARD_EQUALS*/       { 0x3078, 0x3078, 0x30D8, 0x30D8 }, // he, he
/*HID_USAGE_INDEX_KEYBOARD_OPEN_BRACE*/   { 0x309B, 0x309B, 0x309B, 0x309B }, // voiced sound mark, voiced sound mark
/*HID_USAGE_INDEX_KEYBOARD_CLOSE_BRACE*/  { 0x309C, 0x300C, 0x309C, 0x300C }, // semi-voiced sound mark, left corner bracket
/*HID_USAGE_INDEX_KEYBOARD_BACKSLASH*/    { 0x0000, 0x0000, 0x0000, 0x0000 }, // no character, no character
/*HID_USAGE_INDEX_KEYBOARD_NON_US_TILDE*/ { 0x3080, 0x300D, 0x30E0, 0x300D }, // mu, right corner bracket
/*HID_USAGE_INDEX_KEYBOARD_COLON*/        { 0x308C, 0x308C, 0x30EC, 0x30EC }, // re, re
/*HID_USAGE_INDEX_KEYBOARD_QUOTE*/        { 0x3051, 0x3051, 0x30B1, 0x30B1 }, // ke, ke
/*HID_USAGE_INDEX_KEYBOARD_TILDE*/        { 0x0000, 0x0000, 0x0000, 0x0000 }, // no character, no character (Japanese/English toggle)
/*HID_USAGE_INDEX_KEYBOARD_COMMA*/        { 0x306D, 0x3001, 0x30CD, 0x3001 }, // ne, ideographic comma
/*HID_USAGE_INDEX_KEYBOARD_PERIOD*/       { 0x308B, 0x3002, 0x30EB, 0x3002 }, // ru,ideographic full stop
/*HID_USAGE_INDEX_KEYBOARD_QUESTION*/     { 0x3081, 0x30FB, 0x30E1, 0x30FB }  // me, middle dot
};

//---------------------------------------------------------------
//   Lookup Table For Japanese (Hiragana character) alphabet characters
//---------------------------------------------------------------
HID_LOOKUP_TABLE JapaneseHiraganaAlphabetic[] = {
                                          { 0x04,   0x1d,   0,      0 },
/*HID_USAGE_INDEX_KEYBOARD_aA*/           { 0x3061, 0x3061, 0x30C1, 0x30C1 },  // chi, chi
/*HID_USAGE_INDEX_KEYBOARD_bB*/           { 0x3053, 0x3053, 0x30B3, 0x30B3 },  // ko, ko
/*HID_USAGE_INDEX_KEYBOARD_cC*/           { 0x305D, 0x305D, 0x30BD, 0x30BD },  // so, so
/*HID_USAGE_INDEX_KEYBOARD_dD*/           { 0x3057, 0x3057, 0x30B7, 0x30B7 },  // shi, shi
/*HID_USAGE_INDEX_KEYBOARD_eE*/           { 0x3044, 0x3043, 0x30A4, 0x30A3 },  // i, i (small)
/*HID_USAGE_INDEX_KEYBOARD_fF*/           { 0x306F, 0x306F, 0x30CF, 0x30CF },  // ha, ha
/*HID_USAGE_INDEX_KEYBOARD_gG*/           { 0x304D, 0x304D, 0x30AD, 0x30AD },  // ki, ki
/*HID_USAGE_INDEX_KEYBOARD_hH*/           { 0x304F, 0x304F, 0x30AF, 0x30AF },  // ku, ku
/*HID_USAGE_INDEX_KEYBOARD_iI*/           { 0x306B, 0x306B, 0x30CB, 0x30CB },  // ni, ni
/*HID_USAGE_INDEX_KEYBOARD_jJ*/           { 0x307E, 0x307E, 0x30DE, 0x30DE },  // ma, ma
/*HID_USAGE_INDEX_KEYBOARD_kK*/           { 0x306E, 0x306E, 0x30CE, 0x30CE }, // no, no
/*HID_USAGE_INDEX_KEYBOARD_lL*/           { 0x308A, 0x308A, 0x30EA, 0x30EA }, // ri, ri
/*HID_USAGE_INDEX_KEYBOARD_mM*/           { 0x3082, 0x3082, 0x30E2, 0x30E2 }, // mo, mo
/*HID_USAGE_INDEX_KEYBOARD_nN*/           { 0x307F, 0x307F, 0x30DF, 0x30DF }, // mi, mi
/*HID_USAGE_INDEX_KEYBOARD_oO*/           { 0x3089, 0x3089, 0x30E9, 0x30E9 }, // ra,ra
/*HID_USAGE_INDEX_KEYBOARD_pP*/           { 0x305B, 0x305B, 0x30BB, 0x30BB }, // se, se
/*HID_USAGE_INDEX_KEYBOARD_qQ*/           { 0x305F, 0x305F, 0x30BF, 0x30BF }, // ta, ta
/*HID_USAGE_INDEX_KEYBOARD_rR*/           { 0x3059, 0x3059, 0x30B9, 0x30B9 }, // su, su
/*HID_USAGE_INDEX_KEYBOARD_sS*/           { 0x3068, 0x3068, 0x30C8, 0x30C8 }, // to, to
/*HID_USAGE_INDEX_KEYBOARD_tT*/           { 0x304B, 0x304B, 0x30AB, 0x30AB }, // ka, ka
/*HID_USAGE_INDEX_KEYBOARD_uU*/           { 0x306A, 0x306A, 0x30CA, 0x30CA }, // na, na
/*HID_USAGE_INDEX_KEYBOARD_vV*/           { 0x3072, 0x3072, 0x30D2, 0x30D2 }, // hi, hi
/*HID_USAGE_INDEX_KEYBOARD_wW*/           { 0x3066, 0x3066, 0x30C6, 0x30C6 }, // te, te
/*HID_USAGE_INDEX_KEYBOARD_xX*/           { 0x3055, 0x3055, 0x30B5, 0x30B5 }, // sa, sa
/*HID_USAGE_INDEX_KEYBOARD_yY*/           { 0x3093, 0x3093, 0x30F3, 0x30F3 }, // n, n
/*HID_USAGE_INDEX_KEYBOARD_zZ*/           { 0x3064, 0x3063, 0x30C4, 0x30C3 }  // tsu, tsu (small)
};


//---------------------------------------------------------------
//   Lookup Table For Korean Non-alphabet characters
//---------------------------------------------------------------
HID_LOOKUP_TABLE KoreanNonAlphabetic[] = {
                                          { 0x1e,   0x38,   0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_ONE*/          { 0x0031, 0x0021, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_TWO*/          { 0x0032, 0x0040, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_THREE*/        { 0x0033, 0x0023, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_FOUR*/         { 0x0034, 0x0024, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_FIVE*/         { 0x0035, 0x0025, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_SIX*/          { 0x0036, 0x005E, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_SEVEN*/        { 0x0037, 0x0026, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_EIGHT*/        { 0x0038, 0x002A, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_NINE*/         { 0x0039, 0x0028, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_ZERO*/         { 0x0030, 0x0029, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_RETURN*/       { 0x000A, 0x000A, 0, 0 }, // LF,LF
/*HID_USAGE_INDEX_KEYBOARD_ESCAPE*/       { 0x001B, 0x001B, 0, 0 }, // ESC,ESC
/*HID_USAGE_INDEX_KEYBOARD_BACKSPACE*/    { 0x0008, 0x0008, 0, 0 }, // BS
/*HID_USAGE_INDEX_KEYBOARD_TAB*/          { 0x0000, 0x0000, 0, 0 }, // TAB is not supported
/*HID_USAGE_INDEX_KEYBOARD_SPACEBAR*/     { 0x0020, 0x0020, 0, 0 }, // SPACE,SPACE
/*HID_USAGE_INDEX_KEYBOARD_MINUS*/        { 0x002D, 0x005F, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_EQUALS*/       { 0x003D, 0x002B, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_OPEN_BRACE*/   { 0x005B, 0x007B, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_CLOSE_BRACE*/  { 0x005D, 0x007D, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_BACKSLASH*/    { 0x005C, 0x007C, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_NON_US_TILDE*/ { 0x0000, 0x0000, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_COLON*/        { 0x003B, 0x003A, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_QUOTE*/        { 0x0027, 0x0022, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_TILDE*/        { 0x0060, 0x007E, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_COMMA*/        { 0x002C, 0x003C, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_PERIOD*/       { 0x002E, 0x003E, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_QUESTION*/     { 0x002F, 0x003F, 0, 0 }, // 
};

//---------------------------------------------------------------
//   Lookup Table For Korean alphabet characters
//---------------------------------------------------------------
HID_LOOKUP_TABLE KoreanAlphabetic[] = {
                                          { 0x04,   0x1d,   0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_aA*/           { 0x3141, 0x3141, 0, 0 }, // Mieum, Mieum
/*HID_USAGE_INDEX_KEYBOARD_bB*/           { 0x3160, 0x3160, 0, 0 }, // Yu, Yu
/*HID_USAGE_INDEX_KEYBOARD_cC*/           { 0x314A, 0x314A, 0, 0 }, // Chieuch, Chieuch
/*HID_USAGE_INDEX_KEYBOARD_dD*/           { 0x3147, 0x3147, 0, 0 }, // leung, leung
/*HID_USAGE_INDEX_KEYBOARD_eE*/           { 0x3137, 0x3138, 0, 0 }, // Tikeut, Ssangtikeut
/*HID_USAGE_INDEX_KEYBOARD_fF*/           { 0x3139, 0x3139, 0, 0 }, // Rieul, Rieul
/*HID_USAGE_INDEX_KEYBOARD_gG*/           { 0x314E, 0x314E, 0, 0 }, // Hieuh, Hieuh
/*HID_USAGE_INDEX_KEYBOARD_hH*/           { 0x3157, 0x3157, 0, 0 }, // O, O
/*HID_USAGE_INDEX_KEYBOARD_iI*/           { 0x3151, 0x3151, 0, 0 }, // Ya, Ya
/*HID_USAGE_INDEX_KEYBOARD_jJ*/           { 0x3153, 0x3153, 0, 0 }, // Eo, Eo
/*HID_USAGE_INDEX_KEYBOARD_kK*/           { 0x314F, 0x314F, 0, 0 }, // A, A
/*HID_USAGE_INDEX_KEYBOARD_lL*/           { 0x3163, 0x3163, 0, 0 }, // I, I
/*HID_USAGE_INDEX_KEYBOARD_mM*/           { 0x3161, 0x3161, 0, 0 }, // Eu, Eu
/*HID_USAGE_INDEX_KEYBOARD_nN*/           { 0x315C, 0x315C, 0, 0 }, // U, U
/*HID_USAGE_INDEX_KEYBOARD_oO*/           { 0x3150, 0x3152, 0, 0 }, // Ae, Yae
/*HID_USAGE_INDEX_KEYBOARD_pP*/           { 0x3154, 0x3156, 0, 0 }, // E, Ye
/*HID_USAGE_INDEX_KEYBOARD_qQ*/           { 0x3142, 0x3143, 0, 0 }, // Pieup, Ssangpieup
/*HID_USAGE_INDEX_KEYBOARD_rR*/           { 0x3131, 0x3132, 0, 0 }, // Kiyeok, Ssangkiyeok
/*HID_USAGE_INDEX_KEYBOARD_sS*/           { 0x3134, 0x3134, 0, 0 }, // Nieun, Nieun
/*HID_USAGE_INDEX_KEYBOARD_tT*/           { 0x3145, 0x3146, 0, 0 }, // Sios, Ssangsios
/*HID_USAGE_INDEX_KEYBOARD_uU*/           { 0x3155, 0x3155, 0, 0 }, // Yeo, Yeo
/*HID_USAGE_INDEX_KEYBOARD_vV*/           { 0x314D, 0x314D, 0, 0 }, // Phieuph, Phieuph
/*HID_USAGE_INDEX_KEYBOARD_wW*/           { 0x3148, 0x3149, 0, 0 }, // Cieuc, Ssangcieuc
/*HID_USAGE_INDEX_KEYBOARD_xX*/           { 0x314C, 0x314C, 0, 0 }, // Thieuth, Thieuth
/*HID_USAGE_INDEX_KEYBOARD_yY*/           { 0x315B, 0x315B, 0, 0 }, // Yo, Yo
/*HID_USAGE_INDEX_KEYBOARD_zZ*/           { 0x314B, 0x314B, 0, 0 }  // Khieukh, Khieukh
};

//---------------------------------------------------------------
//   Lookup Table For 10 key
//---------------------------------------------------------------
WCHAR TenKeyTable[] = {
// From 0x54 to 0x63
/*HID_USAGE_INDEX_TENKEY_SEPARATOR*/      L'/',
/*HID_USAGE_INDEX_TENKEY_**/              L'*',
/*HID_USAGE_INDEX_TENKEY_-*/              L'-',
/*HID_USAGE_INDEX_TENKEY_+*/              L'+',
/*HID_USAGE_INDEX_TENKEY_ENTER*/          0x0013,
/*HID_USAGE_INDEX_TENKEY_1*/              L'1',
/*HID_USAGE_INDEX_TENKEY_2*/              L'2',
/*HID_USAGE_INDEX_TENKEY_3*/              L'3',
/*HID_USAGE_INDEX_TENKEY_4*/              L'4',
/*HID_USAGE_INDEX_TENKEY_5*/              L'5',
/*HID_USAGE_INDEX_TENKEY_6*/              L'6',
/*HID_USAGE_INDEX_TENKEY_7*/              L'7',
/*HID_USAGE_INDEX_TENKEY_8*/              L'8',
/*HID_USAGE_INDEX_TENKEY_9*/              L'9',
/*HID_USAGE_INDEX_TENKEY_0*/              L'0',
/*HID_USAGE_INDEX_TENKEY_.*/              L'.'
};


//---------------------------------------------------------------
//   Lookup Table For ChineseTraditional (Bopomofo) Non-alphabet characters
//---------------------------------------------------------------
HID_LOOKUP_TABLE ChineseTraditionalBopomofoNonAlphabetic[] = {
                                          { 0x1e,  0x38,   0,      0 },
/*HID_USAGE_INDEX_KEYBOARD_ONE*/          { 0x3105, 0x3105, 0, 0 }, // Half pinyin B
/*HID_USAGE_INDEX_KEYBOARD_TWO*/          { 0x3109, 0x3109, 0, 0 }, // Half pinyin D
/*HID_USAGE_INDEX_KEYBOARD_THREE*/        { 0x02C7, 0x02C7, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_FOUR*/         { 0x02CB, 0x02CB, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_FIVE*/         { 0x3113, 0x3113, 0, 0 }, //
/*HID_USAGE_INDEX_KEYBOARD_SIX*/          { 0x02CA, 0x02CA, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_SEVEN*/        { 0x02D9, 0x02D9, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_EIGHT*/        { 0x311A, 0x311A, 0, 0 }, //
/*HID_USAGE_INDEX_KEYBOARD_NINE*/         { 0x311E, 0x311E, 0, 0 }, //
/*HID_USAGE_INDEX_KEYBOARD_ZERO*/         { 0x3122, 0x3122, 0, 0 }, //
/*HID_USAGE_INDEX_KEYBOARD_RETURN*/       { 0x000A, 0x000A, 0, 0 }, //LF,LF
/*HID_USAGE_INDEX_KEYBOARD_ESCAPE*/       { 0x001B, 0x001B, 0, 0 }, //ESC,ESC
/*HID_USAGE_INDEX_KEYBOARD_BACKSPACE*/    { 0x0008, 0x0008, 0, 0 }, //BS
/*HID_USAGE_INDEX_KEYBOARD_TAB*/          { 0x0000, 0x0000, 0, 0 }, //TAB is not supported
/*HID_USAGE_INDEX_KEYBOARD_SPACEBAR*/     { 0x0020, 0x0020, 0, 0 }, //SPACE,SPACE
/*HID_USAGE_INDEX_KEYBOARD_MINUS*/        { 0x3126, 0x3126, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_EQUALS*/       { 0x003D, 0x002B, 0, 0 }, // '=', '+'
/*HID_USAGE_INDEX_KEYBOARD_OPEN_BRACE*/   { 0x005B, 0x007B, 0, 0 }, // '[', '{'
/*HID_USAGE_INDEX_KEYBOARD_CLOSE_BRACE*/  { 0x005D, 0x007D, 0, 0 }, // ']', '}'
/*HID_USAGE_INDEX_KEYBOARD_BACKSLASH*/    { 0x005C, 0x007C, 0, 0 }, // Backslash, Vertical Line
/*HID_USAGE_INDEX_KEYBOARD_NON_US_TILDE*/ { 0x0000, 0x0000, 0, 0 }, // Not on US keyboard
/*HID_USAGE_INDEX_KEYBOARD_COLON*/        { 0x3124, 0x3124, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_QUOTE*/        { 0x0027, 0x0022, 0, 0 }, // ''', '"'
/*HID_USAGE_INDEX_KEYBOARD_TILDE*/        { 0x0060, 0x007E, 0, 0 }, // '`', '~'
/*HID_USAGE_INDEX_KEYBOARD_COMMA*/        { 0x311D, 0x311D, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_PERIOD*/       { 0x3121, 0x3121, 0, 0 }, // 
/*HID_USAGE_INDEX_KEYBOARD_QUESTION*/     { 0x3125, 0x3125, 0, 0 }  // 
};

//---------------------------------------------------------------
//   Lookup Table For Chinese (Bopomofo) alphabet characters
//---------------------------------------------------------------
HID_LOOKUP_TABLE ChineseTraditionalBopomofoAlphabetic[] = {
                                          { 0x04,   0x1d,  0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_aA*/           { 0x3107, 0x3107, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_bB*/           { 0x3116, 0x3116, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_cC*/           { 0x310F, 0x310F, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_dD*/           { 0x310E, 0x310E, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_eE*/           { 0x310D, 0x310D, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_fF*/           { 0x3111, 0x3111, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_gG*/           { 0x3115, 0x3115, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_hH*/           { 0x3118, 0x3118, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_iI*/           { 0x311B, 0x311B, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_jJ*/           { 0x3128, 0x3128, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_kK*/           { 0x311C, 0x311C, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_lL*/           { 0x3120, 0x3120, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_mM*/           { 0x3129, 0x3129, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_nN*/           { 0x3119, 0x3119, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_oO*/           { 0x311F, 0x311F, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_pP*/           { 0x3123, 0x3123, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_qQ*/           { 0x3106, 0x3106, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_rR*/           { 0x3110, 0x3110, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_sS*/           { 0x310B, 0x310B, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_tT*/           { 0x3114, 0x3114, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_uU*/           { 0x3127, 0x3127, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_vV*/           { 0x3112, 0x3112, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_wW*/           { 0x310A, 0x310A, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_xX*/           { 0x310C, 0x310C, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_yY*/           { 0x3117, 0x3117, 0, 0 },
/*HID_USAGE_INDEX_KEYBOARD_zZ*/           { 0x3108, 0x3108, 0, 0 },
};

XIMEPOS_LOOKUP_TABLE XimeposTable[] = 
{
    XIMEPOS_NOUN,                           L"XIMEPOS_NOUN",
    XIMEPOS_PSEUDO_NOUN_SURU,               L"XIMEPOS_PSEUDO_NOUN_SURU",
    XIMEPOS_PSEUDO_NOUN_ZURU,               L"XIMEPOS_PSEUDO_NOUN_ZURU",
    XIMEPOS_ADJECTIVAL_NOUN,                L"XIMEPOS_ADJECTIVAL_NOUN",
    XIMEPOS_ADVERBIAL_NOUN,                 L"XIMEPOS_ADVERBIAL_NOUN",
    XIMEPOS_PSEUDO_ADJECTIVAL_NOUN,         L"XIMEPOS_PSEUDO_ADJECTIVAL_NOUN",
    XIMEPOS_HUMAN_NAME,                     L"XIMEPOS_HUMAN_NAME",
    XIMEPOS_FAMILY_NAME,                    L"XIMEPOS_FAMILY_NAME",
    XIMEPOS_GIVEN_NAME,                     L"XIMEPOS_GIVEN_NAME",
    XIMEPOS_PLACE_NAME,                     L"XIMEPOS_PLACE_NAME",
    XIMEPOS_PROPER_NOUN,                    L"XIMEPOS_PROPER_NOUN",
    XIMEPOS_VERB_5THSTEP_A_WA,              L"XIMEPOS_VERB_5THSTEP_A_WA",
    XIMEPOS_VERB_5THSTEP_KA,                L"XIMEPOS_VERB_5THSTEP_KA",
    XIMEPOS_VERB_5THSTEP_GA,                L"XIMEPOS_VERB_5THSTEP_GA",
    XIMEPOS_VERB_5THSTEP_SA,                L"XIMEPOS_VERB_5THSTEP_SA",
    XIMEPOS_VERB_5THSTEP_TA,                L"XIMEPOS_VERB_5THSTEP_TA",
    XIMEPOS_VERB_5THSTEP_NA,                L"XIMEPOS_VERB_5THSTEP_NA",
    XIMEPOS_VERB_5THSTEP_BA,                L"XIMEPOS_VERB_5THSTEP_BA",
    XIMEPOS_VERB_5THSTEP_MA,                L"XIMEPOS_VERB_5THSTEP_MA",
    XIMEPOS_VERB_5THSTEP_RA,                L"XIMEPOS_VERB_5THSTEP_RA",
    XIMEPOS_VERB_1STSTEP,                   L"XIMEPOS_VERB_1STSTEP",
    XIMEPOS_ADJECTIVE,                      L"XIMEPOS_ADJECTIVE",
    XIMEPOS_NOMINAL_ADJECTIVE,              L"XIMEPOS_NOMINAL_ADJECTIVE",
    XIMEPOS_ADVERB,                         L"XIMEPOS_ADVERB",
    XIMEPOS_ADNOUN,                         L"XIMEPOS_ADNOUN",
    XIMEPOS_CONJUNCTION,                    L"XIMEPOS_CONJUNCTION",
    XIMEPOS_INTERJECTION,                   L"XIMEPOS_INTERJECTION",
    XIMEPOS_PREFIX,                         L"XIMEPOS_PREFIX",
    XIMEPOS_SUFFIX,                         L"XIMEPOS_SUFFIX",
    XIMEPOS_SUFFIX_FOR_NUMERALS,            L"XIMEPOS_SUFFIX_FOR_NUMERALS",
    XIMEPOS_SINGLE_KANJI,                   L"XIMEPOS_SINGLE_KANJI",
    XIMEPOS_FACE_MARK,                      L"XIMEPOS_FACE_MARK",
    XIMEPOS_IDIOM,                          L"XIMEPOS_IDIOM",
};

#ifdef DEBUG_USER_DIC_TEST
void SaveUserDic(void* mem, int size){

    FILE *fp;
    fopen_s(&fp, "game:\\media\\user.dic", "wb");
    if( fp )
    {
        fwrite(mem, 1, size, fp);
        fclose(fp);
    }
}
#endif  //DEBUG_USER_DIC_TEST

//--------------------------------------------------------------------------------------
// Name: EnumerateDictionarySummary
// Desc: Enumerate XEX based title dictionary
//--------------------------------------------------------------------------------------
void Xime::EnumerateDictionarySummary()
{
    HMODULE hModule = LoadLibrary( szXEXTitleDicPath );
    if( !hModule )
    {
        return;
    }

    // Make Locator
    char szLocator[ MAX_PATH ];
    sprintf_s( szLocator, szLocatorTemplate2, hModule, "titledic" );

    //
    // Example of using XIMEEnumerateDictionarySummaryEx
    //
    DWORD dwNumOfDic = 2;
    WCHAR buff1[ 256 ], buff2[ 256 ];
    XIME_ENUM_TITLE_DICTIONARY_EX XimeEnumTitleDic[ 2 ];
    
    XimeEnumTitleDic[ 0 ].pcszDicFile               = szXEXTitleDicPathFileLocator; // File locator
    XimeEnumTitleDic[ 0 ].pwszDictionaryTitleString = buff1;
    XimeEnumTitleDic[ 0 ].cwchDictionaryTitleString = ARRAYSIZE( buff1 );

    XimeEnumTitleDic[ 1 ].pcszDicFile               = szLocator;                    // Resource locator
    XimeEnumTitleDic[ 1 ].pwszDictionaryTitleString = buff2;
    XimeEnumTitleDic[ 1 ].cwchDictionaryTitleString = ARRAYSIZE( buff2 );

    XIMEEnumerateDictionarySummaryEx( &dwNumOfDic, XimeEnumTitleDic, NULL );

    FreeLibrary( hModule );
}

//--------------------------------------------------------------------------------------
// Name: SetInputLanguage
// Desc: Set the Input Language for IME
//--------------------------------------------------------------------------------------
HRESULT Xime::SetInputLanguage( IMEMODE eLanguage )
{
    XIMEClose();

    // Free any previous allocated memory
    if( g_pvMemoryBlock )
    {
        delete [] g_pvMemoryBlock;
        g_pvMemoryBlock = NULL;
    }
    if( g_pvCandidateFilterTable )
    {
        delete [] g_pvCandidateFilterTable;
        g_pvCandidateFilterTable = NULL;
    }

    //
    // Example of using user index
    //
    m_dwUserIndex = XUSER_INDEX_ANY;
    XUID    xuid;
    char    GamerName[ 256 ];

    for( int i = 0; i < XUSER_MAX_COUNT; i++ )
    {
        // check for signed in user
        if( XUserGetXUID( i, &xuid ) == ERROR_SUCCESS)
        {
            // Found an active user index
            if( XUserGetName( i, GamerName, ARRAYSIZE(GamerName)) == ERROR_SUCCESS )
            {
                m_dwUserIndex = i;
                break;
            }
        }
    }

    HMODULE hModule = NULL;

    switch ( eLanguage )
    {
    case MODE_JP:
        {
            EnumerateDictionarySummary();

            m_CurrentLanguage = MODE_JP;

            //Initialize parameters
            int nNumOfDic = 0;
            m_JPUserWord = 0;
            XIME_CREATE_EX      XimeJpCreate = { 0 };
            LPCSTR              XimeDic[ iNumDicsJP ];
            ZeroMemory( XimeDic, sizeof( XimeDic ) );

            //
            // Load XEX title dic (resource locator)
            //
            hModule = LoadLibrary( szXEXTitleDicPath );
            if( hModule )
            {
                // Set title dic
                //
                // Load XEX title dic (file locator)
                //
                XimeDic[ nNumOfDic++ ] = szXEXTitleDicPathFileLocator;     // File locator

                char szLocator[ MAX_PATH ];
                sprintf_s( szLocator, szLocatorTemplate2, hModule, "titledic" );                
                XimeDic[ nNumOfDic++ ] = szLocator;    // resource locator
            }
                        
            //
            // Example of using fixed memory when creating XIME
            //
            int MemorySize = 2 * 1024 * 1024;   // 2MB
            g_pvMemoryBlock = new byte[ MemorySize ];  
            if( g_pvMemoryBlock )
            {
                XimeJpCreate.pvMemoryBlock = (void*)g_pvMemoryBlock;
                XimeJpCreate.dwSizeOfMemory = MemorySize;
                DWORD dwRequiredSizeofMemory;
                XimeJpCreate.pdwRequiredSizeOfMemory = &dwRequiredSizeofMemory;
            }
            else
            {
                XimeJpCreate.pvMemoryBlock           = NULL;
                XimeJpCreate.dwSizeOfMemory          = 0;
                XimeJpCreate.pdwRequiredSizeOfMemory = NULL;
            }
            
            //
            // Open bit table file
            //
            BOOL    fSetFontFile = FALSE;
            DWORD   dwRead;
            HANDLE  handleIn = CreateFileA( szFontFile, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, NULL );
            if( handleIn != INVALID_HANDLE_VALUE )
            {
                DWORD dwSize = GetFileSize( handleIn, NULL );
                if( dwSize != -1 )
                {
                    g_pvCandidateFilterTable = (LPBYTE)new BYTE[ dwSize ];
                    if( g_pvCandidateFilterTable )
                    {
                        if( ReadFile( handleIn, g_pvCandidateFilterTable, dwSize, &dwRead, NULL ) )
                        {
                            if( dwSize == dwRead )
                            {
                                fSetFontFile = TRUE;    
                            }
                        }
                    }
                }
            }

            //Initialzie IME
            XimeJpCreate.dwNumberOfDictionaries         = nNumOfDic;
            XimeJpCreate.pcszDicFile                    = ( nNumOfDic == 0 ) ? NULL : &XimeDic[0];
            XimeJpCreate.dwProcessor                    = 0;
            XimeJpCreate.pvCandidateFilterTable         = ( fSetFontFile ) ? g_pvCandidateFilterTable : NULL;
            XimeJpCreate.dwNumberOfCandidateListInPage  = NUM_CANDIATEINPAGE;
            XimeJpCreate.eXimeVocabularyOption          = XIME_VOCABULARY_STANDARD;

            // Create XIME
            DWORD dw = XIMECreateEx( m_dwUserIndex, XIMEJPInit, &XimeJpCreate );
            if( dw != ERROR_SUCCESS )
            {
                return E_FAIL;
            }
            
            // Count curent user register words
            UpdateJPUserWordNumber();

            m_iInputMode = XIME_MODE_JP_ROMAJI_HIRAGANA_WITH_FULLWIDTH_ALPHANUMERIC;
            m_iKeyboardLayout = XIME_LAYOUT_ALPHANUMERIC;

            if( handleIn != INVALID_HANDLE_VALUE )
            {
                CloseHandle( handleIn );
            }

            if( hModule )
            {
                FreeLibrary( hModule );
            }
                            
         }
        break;

    case MODE_KR:
        m_CurrentLanguage = MODE_KR;
        if( XIMECreateEx( XUSER_INDEX_ANY, XIMEKRInit, NULL ) != ERROR_SUCCESS )
            return E_FAIL;
        m_iInputMode = XIME_MODE_KR_HANGUL;
        break;

    case MODE_TC:
        {
            //Initialize parameters
            XIME_CREATE_EX    XimeChtCreate = { 0 };
            XimeChtCreate.dwNumberOfCandidateListInPage = NUM_CANDIATEINPAGE;
            XimeChtCreate.eXimeVocabularyOption         = XIME_VOCABULARY_STANDARD;    

            m_CurrentLanguage = MODE_TC;
            if( XIMECreateEx( XUSER_INDEX_ANY, XIMECHBopomofoInit, &XimeChtCreate ) != ERROR_SUCCESS )
                return E_FAIL;
            m_iInputMode = XIME_MODE_CHT_BOPOMOFO;
        }
        break;

    default:
        return E_FAIL;
    }

    // Reset the input character limit after each time we toggle the language
    XIMESetCharacterLimit( m_dwInputCharacterLength );
    
    SetCurrentMode( MODE_INPUT );
    m_bNeedBlocking = FALSE;
    m_dwCharsInXime = 0;

    m_bIMEOn = TRUE;
    m_bCompleted = FALSE;

    ZeroMemory( &m_Key, sizeof( m_Key ) );
    ZeroMemory( &m_LastKey, sizeof( m_LastKey ) );
    m_CompletedString.clear();
    m_bGotClause = FALSE;

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: Init
// Desc: Initialize the XIME
//--------------------------------------------------------------------------------------
HRESULT Xime::Init( IMEMODE eLanguage, DWORD dwCharLength, D3DPRESENT_PARAMETERS * pD3DParam )
{
    assert( pD3DParam != NULL );

#ifdef DEBUG_USER_DIC_TEST
    ZeroMemory(m_UserDicMemory, XEIME_JP_SIZE_OF_USERDIC);
#endif // DEBUG_USER_DIC_TEST

    if( SetInputLanguage( eLanguage ) != S_OK  )
        return E_FAIL;

    m_BackBufferWidth = (float)pD3DParam->BackBufferWidth;
    m_BackBufferHeight = (float)pD3DParam->BackBufferHeight;

    m_dwInputCharacterLength = ( dwCharLength == 0 ) ? DEFAULT_CHARACTERLENGTH : dwCharLength;
    XIMESetCharacterLimit( m_dwInputCharacterLength );

    m_bUpdateInputLength = FALSE;

    ZeroMemory( &s_imeOverLapped, sizeof( s_imeOverLapped ) );
    s_imeOverLapped.hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    if( s_imeOverLapped.hEvent == NULL ){
        ATG::DebugSpew( "Couldn't create event.\n" );
        return E_FAIL;
    }

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: Update
// Desc: Update Xime
//--------------------------------------------------------------------------------------
HRESULT Xime::Update()
{
    HRESULT hr;

    //Check request queue status
    if( !m_RequestList.empty() )
    {
        XIMEREQUEST  &xr = m_RequestList.front();
        if( XHasOverlappedIoCompleted( &xr.ov ) )
        {
            // Check error code.
            DWORD dwResult = XGetOverlappedResult( &xr.ov, NULL, false );
            if( dwResult == ERROR_SUCCESS )
            {
                if( xr.dwRequestId == NEED_TO_DISABLE_LIST )
                    m_bShowCandidateList = FALSE;
                else if( xr.dwRequestId == NEED_TO_COMPLETE )
                    Complete(this, NULL);
            }
            else if( dwResult == ERROR_NO_DATA )
            {
                m_bCompleted = TRUE;
                m_bGotClause = FALSE;
                m_LastKey = xr.key;
            }
            m_RequestList.pop_front();
        }
        if( m_bNeedBlocking )
            return S_OK;
    }
    else
        m_bNeedBlocking = FALSE;

    hr = XInputGetKeystroke( XUSER_INDEX_ANY, XINPUT_FLAG_KEYBOARD, &m_Key );
    if( hr != ERROR_SUCCESS )
        return hr;
    
    //Just ingnore released key
    if( m_Key.Flags & XINPUT_KEYSTROKE_KEYUP ) return S_OK;

    // Ignore some flags
    m_Key.Flags &= ~( XINPUT_KEYSTROKE_VALIDUNICODE |
                      XINPUT_KEYSTROKE_CAPSLOCK |
                      XINPUT_KEYSTROKE_NUMLOCK |
                      XINPUT_KEYSTROKE_ROMAJI |
                      XINPUT_KEYSTROKE_HIRAGANA |
                      XINPUT_KEYSTROKE_HANGUL |
                      XINPUT_KEYSTROKE_BOPOMOFO |
                      XINPUT_KEYSTROKE_CHAJEI |
                      XINPUT_KEYSTROKE_REMOTE |
                      XINPUT_KEYSTROKE_REPEAT );

    DWORD   dwFlags = m_CurrentImeMode | m_CurrentLanguage;
    XIMEKEY eControlKey = XIME_KEY_UNICODE;
    ATG::IMECALLBACK  CallBack = NULL;
    int i;

    // Look up Unicode from HID before looking up a keymap table
    // due to I wanted to convert VirtualKey, too. (for KR)
    INT iInputMode = m_iInputMode;
    LayoutConversion( &m_Key, &iInputMode );

    if( m_bUpdateInputLength )
    {
        // Reset IME string length
        XIMESetCharacterLimit( m_dwInputCharacterLength );
        
        m_bUpdateInputLength = FALSE;
    }

    // Look up a table...
    for( i = 0; i < NUM_INPUT_KEYMAP; i++ )
    {
        if( (dwFlags & m_InputKeymap[ i ].dwFlags) == dwFlags
            && m_Key.VirtualKey == m_InputKeymap[ i ].wVK
            && ((m_Key.Flags & ~m_InputKeymap[ i ].wIgnoredXinputFlags) == m_InputKeymap[ i ].wXinputFlags) )
        {
            eControlKey = m_InputKeymap[ i ].eControlKey;
            CallBack = m_InputKeymap[ i ].function;
            break;
        }
    }

    if( CallBack )
    {
        // Then, invoke callback
        hr = CallBack( this, &m_InputKeymap[ i ] );

        // in order to insert a unicode character if hr is S_FALSE.
        eControlKey = XIME_KEY_UNICODE;
    }
    else if( !m_bIMEOn )
    {
        hr = ERROR_SERVICE_DISABLED;
    }
    else
    {
        hr = S_FALSE;
    }

    if( hr == S_FALSE && (m_Key.Unicode || eControlKey != XIME_KEY_UNICODE) )
    {
        hr = S_OK;

        if( eControlKey == XIME_KEY_UNICODE &&
            (m_CurrentImeMode == MODE_CONVERT || m_CurrentImeMode == MODE_ALLCONVERT) )
        {
            //
            // #142426, In CHT
            // Flush candidate list for ASCI charachters.
            // Determine candidate list for Bopomofo characters.
            //
            if( m_CurrentLanguage == MODE_TC && ( m_Key.Unicode >= 0x21 && m_Key.Unicode <= 0x7E ) )
            {
                XIMEInsertCharacter( '\0', XIME_KEY_FLUSH, iInputMode, NULL );
            }
            else
            {
                Complete( this, NULL );
            }
            //this->m_bNeedBlocking = TRUE;
            // Need to block since input mode has been changed
            SetCurrentMode( MODE_INPUT );
        }

        //Input some letters
        XIMEREQUEST request = { 0 };
        m_RequestList.push_back( request );

        if( eControlKey != XIME_KEY_UNICODE )
        {
            // API does not accept Unicode value except when using XIME_KEY_UNICODE
            m_Key.Unicode = 0x0;
        }
        // save the keystroke for pop back when this call is not taken the key.
        m_RequestList.back().key = m_Key;

        XIMEInsertCharacter( m_Key.Unicode,
                             eControlKey,
                             iInputMode,
                             &m_RequestList.back().ov );

        m_dwCharsInXime++;
    }
    return hr;
}


//--------------------------------------------------------------------------------------
// Name: GetString
// Desc: RetrieveString
//--------------------------------------------------------------------------------------
HRESULT Xime::GetString( std::wstring & stringOut )
{
    if( !IsStringReady() ) 
        return ERROR_NOT_READY;
    stringOut = m_CompletedString;
    m_bCompleted = FALSE;
    m_CompletedString.clear();

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: IsStringReady
// Desc:
//--------------------------------------------------------------------------------------
BOOL Xime::IsStringReady( void )
{
    if( !m_RequestList.empty() ) return FALSE;
    if( m_CompletedString.empty() )
    {
        if( m_bGotClause )
            m_bCompleted = FALSE;
        return FALSE;
    }
    return TRUE;
}


//--------------------------------------------------------------------------------------
// Name: Render
// Desc: Render Xime
//--------------------------------------------------------------------------------------
HRESULT Xime::Render( HXUIDC hDC, HXUIFONT hFont, float fPosX, float fPosY )
{
    assert( hDC != NULL );
    assert( hFont != NULL );

    DWORD   dwRet = ERROR_SUCCESS;
    DWORD   dwFocus = 0;
    DWORD   dwCursor = 0;
    DWORD   dwClauses = 0;
    DWORD   dwDeterminedClause = 0;

    DWORD   dwNumCandidate = 0;
    DWORD   dwCandidateIndex = 0;
    DWORD   dwHighLightIndexInlist;
    DWORD   dwNumberOfCandidateStringsInList;
    bool    bListAvailable = false;

    // we need to get the clause info until XIME will complete
    // even if the ime state is off.
    if( !IsIMEOn() )
    {
        return ERROR_SERVICE_DISABLED;
    }

    // clear for XIMEGetClauseInfo behavior
    dwNumberOfCandidateStringsInList = 0; 

    // Reading string buffer
    WCHAR wszReadingString[64];
    wszReadingString[ 0 ] = 0;
   
    // Retrieve current clause information of IME
    dwRet = XIMEGetClauseInfo( &dwFocus,
                               &dwClauses,
                               &dwCursor,
                               &dwDeterminedClause,
                               m_StringBuffer,
                               sizeof( m_StringBuffer ) / sizeof( WCHAR ),
                               NULL,
                               &dwNumberOfCandidateStringsInList,
                               wszReadingString,
                               ARRAYSIZE( wszReadingString ) );
    if( dwRet != ERROR_SUCCESS ) return E_FAIL;
    
    // Chinese XIME has the auto-conversion behavior.
    // so, the current mode has to be controlled by Chinese XIME
    if( m_CurrentLanguage == MODE_TC )
    {
        if( dwNumberOfCandidateStringsInList > 0 )
        {
            SetCurrentMode( MODE_CONVERT );
            m_bShowCandidateList = TRUE;
        }
        else
        {
            SetCurrentMode( MODE_INPUT );
        }
    }

    // Retrieve candidate list if IME is in conversion mode
    if( m_CurrentImeMode == MODE_CONVERT )
    {
        DWORD dwRequiredCandidate;
        dwRet = XIMEGetCandidateListInfo( m_CandidateListBuffer,
                                          sizeof( m_CandidateListBuffer ) / sizeof( WCHAR ),
                                          &dwRequiredCandidate,
                                          &dwCandidateIndex,
                                          &dwNumCandidate,
                                          &dwHighLightIndexInlist,
                                          &dwNumberOfCandidateStringsInList );
        if( dwRet == ERROR_SUCCESS ) bListAvailable = true;
    }

    // Begin Xui rendering
    XuiRenderBegin( hDC, D3DCOLOR_ARGB( 255, 0, 0, 0 ) );

    // Set the view
    D3DXMATRIX matView;
    D3DXMatrixIdentity( &matView );
    XuiRenderSetViewTransform( hDC, &matView );

    WCHAR * pString = m_StringBuffer;
    D3DCOLOR color;

    // we get the determined string exactly
    // instead of getting it after completed signal of XIME_KEY_COMPLETE
    m_bGotClause = TRUE;

    DWORD  dwDeterminedLength;
    if( dwDeterminedClause == 0 )
    {
        m_CompletedString += pString;
        dwDeterminedLength = wcslen( pString );
        m_bCompleted = TRUE;
    }
    else
    {
        assert( dwDeterminedClause == dwDeterminedClause );
        dwDeterminedLength = 0;
    }

    m_CurrentString = L"";

    //Show typed string
    color = COLOR_NORMAL;

    float fX = fPosX;

    // Render clause, candidate list
    for( DWORD i = 0; i < dwClauses; i++ )
    {
        if( i == dwFocus )
        {
            // Draw focus string
            color = COLOR_FOCUS;
            float fWidth, fHeight;
            DrawText( hDC, hFont, color, fX, fPosY, pString, &fWidth, &fHeight );
            if( bListAvailable && m_bShowCandidateList )
            {
                float fY = fPosY + fHeight;
                WCHAR* pCandidateString = m_CandidateListBuffer;

                // draw candidate list
                for( DWORD j = 0; j < dwNumCandidate; j++ )
                {
                    if( j == dwCandidateIndex )
                        color = COLOR_FOCUS;
                    else
                        color = COLOR_LIST;

                    DrawText( hDC, hFont, color, fX, fY, pCandidateString, NULL, &fHeight );
                    INT iStrLen = wcslen( pCandidateString );
                    pCandidateString += iStrLen + 1;
                    fY += fHeight;
                }
            }
            fX += fWidth;
        }
        else
        {
            // Draw other clause strings in IME
            color = ( i == dwDeterminedClause ) ? COLOR_NORMAL : COLOR_INIME;
            float fWidth;
            DrawText( hDC, hFont, color, fX, fPosY, pString, &fWidth );
            fX += fWidth;
        }
        m_CurrentString += pString;

        INT iStrLen = wcslen( pString );
        pString += iStrLen + 1;
    }

    // We don't count m_dwCharsInXime correctly in Backspace, ESC and etc...
    // So we refresh m_dwCharsInXime every time.
    m_dwCharsInXime = m_CurrentString.length() - dwDeterminedLength;

    //Show cursor
    if( (DWORD)color == COLOR_FOCUS && m_CurrentLanguage == MODE_KR )
    {
        // drew box cursor in DrawText
    }
    else if( dwCursor >= 0 && dwCursor <= (DWORD)m_CurrentString.length() )
    {
        // Measure the cursor position
        pString = (WCHAR* )m_CurrentString.c_str();
        XUIRect clipRect( 0, 0, m_BackBufferWidth, m_BackBufferHeight );
        if( dwCursor )
            XuiMeasureText( hFont, pString, dwCursor,
                            XUI_FONT_STYLE_NORMAL | XUI_FONT_STYLE_SINGLE_LINE,
                            0, &clipRect );
        else
            clipRect.right = 0; //Work around for XuiMeasureText behaivor

        // Draw the cursor if it's inside a screen
        color = COLOR_NORMAL;
        if( fPosX + clipRect.right < m_BackBufferWidth )
            DrawText( hDC, hFont, color, fPosX + clipRect.right, fPosY, L"|" );
    }

    // Complete Xui rendering
    XuiRenderEnd( hDC );
    XuiRenderPresent( hDC, NULL, NULL, NULL );

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: DrawText
// Desc: Draw text at the given coordinates with the given color.
//--------------------------------------------------------------------------------------
void Xime::DrawText( HXUIDC hdc, HXUIFONT hFont, D3DCOLOR color, float x, float y,
                     LPCWSTR text, float * pfX, float * pfY )
{
    assert( hdc != NULL );
    assert( hFont != NULL );
    assert( text );

    // Measure the text
    XUIRect clipRect( 0, 0, m_BackBufferWidth - x, m_BackBufferHeight - y );
    XuiMeasureText( hFont, text, -1, XUI_FONT_STYLE_NORMAL | XUI_FONT_STYLE_SINGLE_LINE,
                    0, &clipRect );

    // Set the text position in the device context
    D3DXMATRIX matXForm;
    D3DXMatrixIdentity( &matXForm );
    matXForm._41 = x;
    matXForm._42 = y;
    XuiRenderSetTransform( hdc, &matXForm );

    // Select the font and color into the device context
    XuiSelectFont( hdc, hFont );
    XuiSetColorFactor( hdc, (DWORD)color );

    if( (DWORD)color == COLOR_FOCUS && m_CurrentLanguage == MODE_KR )
    {
        HXUIBRUSH hBrush;
        XuiCreateSolidBrush( (DWORD)color, &hBrush );
        XuiSelectBrush( hdc, hBrush );
        XuiFillRect( hdc, &clipRect );
        XuiDestroyBrush( hBrush );
        XuiSetColorFactor( hdc, 0xFF000000 );
    }

    // Draw the text
    XuiDrawText( hdc, text, XUI_FONT_STYLE_NORMAL, 0, &clipRect );

    if( pfX != NULL ) *pfX = clipRect.GetWidth();
    if( pfY != NULL ) *pfY = clipRect.GetHeight();
    return;
}


//--------------------------------------------------------------------------------------
// Callback functions
//--------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------
// Name: Convert
// Desc: Start a conversion process
//--------------------------------------------------------------------------------------
HRESULT Xime::Convert( Xime * pXIME, XIME_KEYMAPPING * pKey )
{
    assert( pXIME != NULL );
    assert( pKey != NULL );

    //Input some letters
    XIMEREQUEST request = { 0 };
    pXIME->m_RequestList.push_back( request );

    // save the keystroke for pop back when this call is not taken the key.
    pXIME->m_RequestList.back().key = pXIME->m_Key;

    if( !pXIME->m_dwCharsInXime )
    {
        // Just input white space
        XIMEInsertCharacter( L' ',
                             XIME_KEY_UNICODE,
                             pXIME->m_iInputMode,
                             &pXIME->m_RequestList.back().ov );

    }
    else
    {
        pXIME->SetCurrentMode( MODE_CONVERT );

        // do convert
        XIMEInsertCharacter( 0,
                             XIME_KEY_CONVERT,
                             pXIME->m_iInputMode,
                             &pXIME->m_RequestList.back().ov );

        // Build candidate list
        BuildCandidateList( pXIME, pKey );
    }

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: NonConvert
// Desc: Process the [No convert] key 
//--------------------------------------------------------------------------------------
HRESULT Xime::NonConvert( Xime * pXIME, XIME_KEYMAPPING * pKey )
{
    // #143421, when there are no reading strings, do nothing!
    if( !pXIME->m_dwCharsInXime )
    {   
        return S_OK;
    }

    // start the convert 
    Convert( pXIME, pKey );
    pXIME->SetCurrentMode( MODE_CONVERT );

    // and set the XIMEKEY
    SetCandidate( pXIME, pKey );

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: ChangeFocus
// Desc: Chang clause focus
//--------------------------------------------------------------------------------------
HRESULT Xime::ChangeFocus( Xime * pXIME, XIME_KEYMAPPING * pKey )
{
    assert( pXIME != NULL );
    assert( pKey != NULL );
    assert( pXIME->m_CurrentImeMode == MODE_CONVERT );

    XIMEREQUEST request = { 0 };
    pXIME->m_RequestList.push_back( request );

    BOOL bMoveToRight = ( pKey->wVK == VK_RIGHT ? TRUE : FALSE );
    XIMEMoveClauseFocus( bMoveToRight, &pXIME->m_RequestList.back().ov );

    BuildCandidateList( pXIME, pKey );

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: ChangeClauseLength
// Desc: Change clause length in focus
//--------------------------------------------------------------------------------------
HRESULT Xime::ChangeClauseLength( Xime * pXIME, XIME_KEYMAPPING * pKey )
{
    assert( pXIME != NULL );
    assert( pKey != NULL );
    assert( pXIME->m_CurrentImeMode == MODE_CONVERT );

    XIMEREQUEST request = { 0 };
    pXIME->m_RequestList.push_back( request );

    BOOL bExpand = ( pKey->wVK == VK_RIGHT ? TRUE : FALSE );
    XIMEChangeClauseLength( bExpand, &pXIME->m_RequestList.back().ov );

    BuildCandidateList( pXIME, pKey );

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: Revert
// Desc: Revert conversion
//--------------------------------------------------------------------------------------
HRESULT Xime::Revert( Xime * pXIME, XIME_KEYMAPPING * pKey )
{
    assert( pXIME != NULL );
    assert( pKey != NULL );
    assert( pXIME->m_CurrentImeMode == MODE_CONVERT );

    pXIME->SetCurrentMode( MODE_INPUT );

    XIMEREQUEST request = { 0 };
    pXIME->m_RequestList.push_back( request );

    XIMERevertString( &pXIME->m_RequestList.back().ov );

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: SetCandidate
// Desc: Notify a candidate to IME
//--------------------------------------------------------------------------------------
HRESULT Xime::SetCandidate( Xime * pXIME, XIME_KEYMAPPING * pKey )
{
    assert( pXIME != NULL );
    assert( pKey != NULL );
    assert( pXIME->m_CurrentImeMode == MODE_CONVERT );

    XIMEREQUEST request = { 0 };
    pXIME->m_RequestList.push_back( request );

    XIMESetCandidateIndex( (XIMEINDEX)pKey->eControlKey,
                           0,
                           pXIME->m_CurrentLanguage == MODE_JP,
                           &pXIME->m_RequestList.back().ov );
   
    pXIME->m_bShowCandidateList = TRUE;
    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: BuildCandidateList
// Desc: Request candidate list to IME
//--------------------------------------------------------------------------------------
HRESULT Xime::BuildCandidateList( Xime * pXIME, XIME_KEYMAPPING * pKey )
{
    assert( pXIME != NULL );
    assert( pKey != NULL );

    XIMEREQUEST request = { 0 };
    pXIME->m_RequestList.push_back( request );
    XIMEBuildCandidateList( &pXIME->m_RequestList.back().ov );

    pXIME->m_bShowCandidateList = (pXIME->m_CurrentLanguage == MODE_TC);

    return S_OK;
}

//--------------------------------------------------------------------------------------
// Name: SwitchLanguage
// Desc: Switch Language for IME, JP->KR->CH
//--------------------------------------------------------------------------------------
HRESULT Xime::SwitchLanguage(Xime * pXIME)
{
    switch( pXIME->m_CurrentLanguage )
    {
    case MODE_JP:

#ifdef DEBUG_USER_DIC_TEST
        if ( XIMEUpdateUserDicMemory(&s_imeOverLapped) == ERROR_IO_INCOMPLETE )
        {
           // Wait for overlapped function to complete
           while (!XHasOverlappedIoCompleted(&s_imeOverLapped))
               Sleep(50);
           HRESULT result = XGetOverlappedResult( &s_imeOverLapped, NULL, TRUE );
           if (result == ERROR_SUCCESS)
           {
               OutputDebugStringA( "update user dic successfully!!\n" );
           }
           else
           {
               OutputDebugStringA( "update user dic error!!\n" );
           }
        }
  
        SaveUserDic( m_UserDicMemory, sizeof(m_UserDicMemory) );

#endif  // DEBUG_USER_DIC_TEST

        pXIME->SetInputLanguage( MODE_KR );
        break;
    case MODE_KR:
        pXIME->SetInputLanguage( MODE_TC );
        break;
    case MODE_TC:
        pXIME->SetInputLanguage( MODE_JP );
        break;
    default:
        return E_FAIL;
    }

    return S_OK;
}
 
//--------------------------------------------------------------------------------------
// Name: Complete
// Desc: Complete IME conversion
//--------------------------------------------------------------------------------------
HRESULT Xime::Complete( Xime * pXIME, XIME_KEYMAPPING * pKey )
{
    static int c = 0;

    assert( pXIME != NULL );

    XIMEREQUEST request = { 0 };
    pXIME->m_RequestList.push_back( request );

    if( pXIME->m_CurrentLanguage == MODE_TC &&
        pXIME->m_CurrentImeMode == MODE_CONVERT &&
        pKey != NULL )
    {
        // if it's not auto-completion before XIME_KEY_UNICODE,
        // CHT Bopomofo has to complete after the candidate index is updated.
        pXIME->m_RequestList.back().dwRequestId = NEED_TO_COMPLETE;
        pXIME->m_bNeedBlocking = TRUE;

        //XIMESetCandidateIndex( XIME_INDEX_CURRENT, 0, TRUE, &pXIME->m_RequestList.back().ov );
    }
    else
    {
        // save the keystroke for pop back when this call is not taken the key.
        pXIME->m_RequestList.back().key = (pKey != NULL)? pXIME->m_Key : XINPUT_KEYSTROKE();
        
        XIMEInsertCharacter( 0,
                             XIME_KEY_COMPLETE,
                             pXIME->m_iInputMode,
                             &pXIME->m_RequestList.back().ov );

        
        // We always change the mode to MODE_INPUT, and
        // we will get the completed string after XIME_KEY_COMPLETE is done.
        pXIME->SetCurrentMode( MODE_INPUT );
        pXIME->m_bCompleted = TRUE;
    }

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: HandleNumpadConversion
// Desc: Handle numpad inputs
//--------------------------------------------------------------------------------------
HRESULT Xime::HandleNumpadConversion( Xime * pXIME, XIME_KEYMAPPING * pKey )
{
    assert( pXIME != NULL );
    assert( pKey != NULL );

    if( !pXIME->m_bShowCandidateList )
        return S_FALSE;

    XIMEREQUEST request = { 0 };
    pXIME->m_RequestList.push_back( request );

    DWORD dwIndex = (pKey->wVK >= VK_NUMPAD0)? pKey->wVK-VK_NUMPAD1 : pKey->wVK-VK_1;
    if( dwIndex > 9)
        dwIndex = 10;

    DWORD dwRet = XIMESetCandidateIndex( XIME_INDEX_CURRENT_PAGE_OFFSET,
                                         dwIndex, true,
                                         &pXIME->m_RequestList.back().ov );

    //
    // we can't process the next command until XIMESetCandidateIndex completes successfully
    //
    if( dwRet == ERROR_SUCCESS || dwRet == ERROR_IO_INCOMPLETE )
    {
        if( pXIME->m_CurrentLanguage == MODE_JP )
        {
            pXIME->m_RequestList.back().dwRequestId = NEED_TO_DISABLE_LIST;
        }
        else if( pXIME->m_CurrentLanguage == MODE_TC )
        {
            // CHT Bopomofo needs to complete after the candidate index is updated.
            pXIME->m_RequestList.back().dwRequestId = NEED_TO_COMPLETE;
            pXIME->m_bNeedBlocking = TRUE;
        }
    }
    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: AllConvert
// Desc: Start a conversion process
//--------------------------------------------------------------------------------------
HRESULT Xime::AllConvert( Xime * pXIME, XIME_KEYMAPPING * pKey )
{
    assert( pXIME != NULL );
    assert( pKey != NULL );

    pXIME->SetCurrentMode( MODE_ALLCONVERT );
    //Input some letters
    XIMEREQUEST request = { 0 };
    pXIME->m_RequestList.push_back( request );

    // save the keystroke for pop back when this call is not taken the key.
    pXIME->m_RequestList.back().key = pXIME->m_Key;
    XIMEInsertCharacter( 0,
                         pKey->eControlKey,
                         pXIME->m_iInputMode,
                         &pXIME->m_RequestList.back().ov );

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: AllRevert
// Desc: Revert all conversion
//--------------------------------------------------------------------------------------
HRESULT Xime::AllRevert( Xime * pXIME, XIME_KEYMAPPING * pKey )
{
    assert( pXIME != NULL );
    assert( pKey != NULL );
    assert( pXIME->m_CurrentImeMode == MODE_ALLCONVERT );

    pXIME->SetCurrentMode( MODE_INPUT );

    XIMEREQUEST request = { 0 };
    pXIME->m_RequestList.push_back( request );

    // save the keystroke for pop back when this call is not taken the key.
    pXIME->m_RequestList.back().key = pXIME->m_Key;

    XIMEInsertCharacter(  0,
                          XIME_KEY_REVERT,
                          pXIME->m_iInputMode,
                          &pXIME->m_RequestList.back().ov );

    return S_OK;
}

//--------------------------------------------------------------------------------------
// Name: ChangeInputMode
// Desc: Change IME input mode
//--------------------------------------------------------------------------------------
HRESULT Xime::ChangeInputMode( Xime * pXIME, XIME_KEYMAPPING * pKey )
{
    assert( pXIME != NULL );
    assert( pKey != NULL );
    assert( pXIME->m_CurrentImeMode == MODE_INPUT );

    pXIME->m_iInputMode = pKey->eControlKey;

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: SetCurrentMode
// Desc: Switch current IME mode
//--------------------------------------------------------------------------------------
void    Xime::SetCurrentMode( IMEMODE mode )
{
    assert( mode == MODE_OFF || mode == MODE_CONVERT || mode == MODE_INPUT || mode == MODE_ALLCONVERT );

    if( m_CurrentImeMode != mode )
    {
        m_bNeedBlocking = TRUE;
    }
    m_CurrentImeMode = mode;
}


//--------------------------------------------------------------------------------------
// Name: ToggleIME
// Desc: Toggle IME
//--------------------------------------------------------------------------------------
HRESULT Xime::ToggleIME( Xime * pXIME )
{
    assert( pXIME != NULL );

    if ( ( pXIME->m_CurrentLanguage == MODE_JP ) && pXIME->m_Key.VirtualKey )   // if it's not from Gamepad
    {
        if ( XGetLanguage() == XC_LANGUAGE_JAPANESE )
        {
            if ( pXIME->m_Key.Unicode )                                         // no change if it's VK_OEM_3 when dash is Japanese
                return pXIME->m_bIMEOn ? S_FALSE : S_OK;
        }
        else
        {
            if ( pXIME->m_Key.Unicode != L'`' )                                 // only toggle IME if it's [~/`] key when dash is non-Japanese
                return pXIME->m_bIMEOn ? S_FALSE : S_OK;
        }
    }

    if( pXIME->m_bIMEOn )
    {
        // We like Flush as IME toggle behavior.
        XIMEREQUEST request = { 0 };
        pXIME->m_RequestList.push_back( request );

        // #142425, need to send XIME_KEY_FLUSH instead of XIME_KEY_COMPLETE For chinese traditional(MODE_TC)
        if( pXIME->m_CurrentImeMode == MODE_INPUT )
        {
            XIMEInsertCharacter( 0,
                             pXIME->m_CurrentLanguage == MODE_TC ? XIME_KEY_FLUSH : XIME_KEY_COMPLETE,
                             pXIME->m_iInputMode,
                             &pXIME->m_RequestList.back().ov );
        }
        else
        {
            XIMEInsertCharacter( 0,
                                 XIME_KEY_COMPLETE,
                                 pXIME->m_iInputMode,
                                 &pXIME->m_RequestList.back().ov );
        }
        

        pXIME->m_bCompleted = TRUE;
        // Need to block since input mode has been changed
        pXIME->SetCurrentMode( MODE_OFF );
        pXIME->m_bIMEOn = FALSE;

        // drop this keystroke.
        ZeroMemory( &pXIME->m_Key, sizeof( XINPUT_KEYSTROKE ) );
    }
    else
    {
        pXIME->SetCurrentMode( MODE_INPUT );
        pXIME->m_bIMEOn = TRUE;
    }

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: ToggleKeyboardLayout
// Desc: Toggle Keyboard layout
//--------------------------------------------------------------------------------------
HRESULT Xime::ToggleKeyboardLayout( Xime * pXIME, XIME_KEYMAPPING * pKey )
{
    assert( pXIME != NULL );
    assert( pKey != NULL );

    if( pXIME->m_CurrentLanguage == MODE_JP )
    {
        if( pXIME->m_iKeyboardLayout == XIME_LAYOUT_ALPHANUMERIC )
        {
            pXIME->m_iKeyboardLayout = XIME_LAYOUT_KANA;
        }
        else
        {
            pXIME->m_iKeyboardLayout = XIME_LAYOUT_ALPHANUMERIC;
        }
    }

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: LayoutConversion
// Desc: Keyboard layout conversion routine. Language specific
//--------------------------------------------------------------------------------------
HRESULT Xime::LayoutConversion( XINPUT_KEYSTROKE* pKey, INT* pInputMode )
{
    if( m_CurrentLanguage == MODE_JP )
    {
        if( m_iKeyboardLayout == XIME_LAYOUT_KANA && 
            ( ( *pInputMode & XIME_LAYOUT_MASK ) == XIME_LAYOUT_KANA ||
            ( *pInputMode & XIME_COMBINE_MASK ) == XIME_COMBINE_ROMAJI_HIRAGANA ||
            ( *pInputMode & XIME_COMBINE_MASK ) == XIME_COMBINE_ROMAJI_KATAKANA ) )
        {
            HidUnicodeLookUp( pKey,
                              m_bIMEOn,
                              m_iInputMode == XIME_MODE_JP_ROMAJI_KATAKANA_WITH_FULLWIDTH_ALPHANUMERIC,
                              JapaneseHiraganaNonAlphabetic,
                              JapaneseHiraganaAlphabetic );
            *pInputMode = XIME_LANGUAGE_JAPANESE | XIME_LAYOUT_KANA |
                          ( pKey->Flags & XINPUT_KEYSTROKE_SHIFT ? XIME_COMBINE_KANA_SHIFT : 0 );
        }
        else
        {
            // for ten-key input
            HidUnicodeLookUp( pKey, FALSE, FALSE, NULL, NULL );
        }
    }
    else if( m_CurrentLanguage == MODE_KR )
    {
        if( XGetLanguage() != XC_LANGUAGE_KOREAN && pKey->HidCode == 0xe6 ) // Right-ALT key
        {
            pKey->VirtualKey = VK_HANGUL;
            pKey->Flags &= ~( XINPUT_KEYSTROKE_ALT | XINPUT_KEYSTROKE_ALTGR );
        }
        else
        {
            HidUnicodeLookUp( pKey,
                              m_bIMEOn,
                              FALSE,
                              KoreanNonAlphabetic,
                              KoreanAlphabetic );
        }
        *pInputMode = XIME_LANGUAGE_HANGUL;// | XIME_LAYOUT_HANGUL;
    }
    else if( m_CurrentLanguage == MODE_TC )
    {
        HidUnicodeLookUp( pKey,
                          m_bIMEOn,
                          FALSE,
                          ChineseTraditionalBopomofoNonAlphabetic,
                          ChineseTraditionalBopomofoAlphabetic );
        *pInputMode = XIME_LANGUAGE_BOPOMOFO; // | XIME_LAYOUT_BOPOMOFO;
    }

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Name: HidUnicodeLookUp
// Desc: Look up Non-alphabet characters (Kana, Hangul, bopomofo)
//--------------------------------------------------------------------------------------
VOID Xime::HidUnicodeLookUp( XINPUT_KEYSTROKE* pKey, BOOL fImeOn, BOOL fKana,
                              HID_LOOKUP_TABLE * pTable, HID_LOOKUP_TABLE * pTable2 )
{
    HID_LOOKUP_TABLE *pLookupTable = NULL;
    DWORD  dwHidCode = pKey->HidCode;

    // always look up even if IME is off
    if( ( dwHidCode >= 0x54 ) && ( dwHidCode <= 0x63 ) )
    {
        // convert ten-key
        pKey->Unicode = TenKeyTable[ dwHidCode - 0x54 ];
    }

    else if( !fImeOn )
    {
        // IME is off
    }

    // look up when IME is on
    else if( pTable && dwHidCode >= pTable[ 0 ].wHiragana && dwHidCode <= pTable[ 0 ].wHiraganaShifted )
    {
        pLookupTable = pTable;
    }
    else if( pTable2 &&  dwHidCode >= pTable2[ 0 ].wHiragana && dwHidCode <= pTable2[ 0 ].wHiraganaShifted )
    {
        pLookupTable = pTable2;
    }
    else if( dwHidCode == 0x87 )
    {
        //
        // Handle the special Japanese international keycode for the prolonged sound mark
        //
        pKey->Unicode = fKana ? 0x30ED : 0x308D; // ro character
    }
    else if( dwHidCode == 0x89 )
    {
        pKey->Unicode = 0x30FC; // Prolonged sound mark
    }

    if( pLookupTable )
    {
        dwHidCode -= pLookupTable[ 0 ].wHiragana-1;
        if( fKana )
        {
            if(pKey->Flags & XINPUT_KEYSTROKE_SHIFT)
                pKey->Unicode = pLookupTable[ dwHidCode ].wKatakanaShifted;
            else
                pKey->Unicode = pLookupTable[ dwHidCode ].wKatakana;
        }
        else
        {
            if(pKey->Flags & XINPUT_KEYSTROKE_SHIFT)
                pKey->Unicode = pLookupTable[ dwHidCode ].wHiraganaShifted;
            else
                pKey->Unicode = pLookupTable[ dwHidCode ].wHiragana;
        }
    }

    return;
}

//--------------------------------------------------------------------------------------
// Name: XimeposLookup
// Desc: Ximepos STRING->Value lookup, JP mode only
//--------------------------------------------------------------------------------------
XIMEPOS Xime::XimeposLookup(LPCWSTR pStr)
{
    XIMEPOS_LOOKUP_TABLE *pTable = XimeposTable;
    for( UINT i = 0; i < sizeof( XimeposTable ) / sizeof( XIMEPOS_LOOKUP_TABLE ) ; i++, pTable++ )
    {
        if ( _wcsicmp( pStr, pTable->string ) == 0 )
            return pTable->value;
    }

    return (XIMEPOS)0;
}

//--------------------------------------------------------------------------------------
// Name: LoadJPUserWordFile
// Desc: Load and Register Word to from XML file,JP mode only
//--------------------------------------------------------------------------------------
HRESULT Xime::LoadJPUserWordFile(const CHAR* strUserWordFile)
{
    if( m_CurrentLanguage != MODE_JP )
        return S_FALSE;

    XMLParser wordParser;
    UserWordFileCallback wordCallback;

    wordParser.RegisterSAXCallbackInterface( &wordCallback );
    HRESULT hr = wordParser.ParseXMLFile( strUserWordFile );
    
    UpdateJPUserWordNumber();

    return hr;
}

//--------------------------------------------------------------------------------------
// Name: RegisterJPUserWord
// Desc: Register one word, JP mode only
//--------------------------------------------------------------------------------------
HRESULT Xime::RegisterJPUserWord(LPCWSTR pReading, LPCWSTR pDisplay, LPCWSTR pImePos)
{
    DWORD addtionResult;
    BOOL fComplete;

    XOVERLAPPED myXOverLapped = { 0 };

    if ( pReading[ 0 ] && pDisplay[ 0 ] && pImePos[ 0 ] )
    {
        XIMEPOS pos = Xime::XimeposLookup( pImePos );
        if ( pos )
        {
            //if ( XIMERegisterUserWord( pReading, pDisplay, pos, &s_imeOverLapped ) == ERROR_IO_INCOMPLETE )
            if ( XIMERegisterUserWord( pReading, pDisplay, pos, &myXOverLapped ) == ERROR_IO_INCOMPLETE )
            {
                // Wait for overlapped function to complete
                while ( ( fComplete = XHasOverlappedIoCompleted( &myXOverLapped ) ) == FALSE ) 
                    SwitchToThread();

                DWORD result = XGetOverlappedResult( &myXOverLapped, &addtionResult, TRUE );
                
                if ( result == ERROR_SUCCESS )
                {
                    return S_OK;
                    // registered successfully
                }
                else if ( result == ERROR_ALREADY_EXISTS )
                {
                    return S_OK;
                    // already registered
                }

                return S_OK;
            }
        }
    }

    return S_FALSE;
}

HRESULT Xime::DeleteJPUserWordAll()
{
    if( m_CurrentLanguage != MODE_JP )
        return S_FALSE;

    XIMEDeleteUserWord( XIME_DELETE_ALL_USER_WORDS, &s_imeOverLapped );
    while ( !XHasOverlappedIoCompleted( &s_imeOverLapped ) )
        Sleep( 50 );

    HRESULT result = XGetOverlappedResult( &s_imeOverLapped, NULL, TRUE );
    
    UpdateJPUserWordNumber();
    if ( result == ERROR_SUCCESS )
        return S_OK;
    else
        return S_FALSE;
}

//--------------------------------------------------------------------------------------bb
// Name: UpdateJPUserWordNumber
// Desc: Get the number of words that has been registered, JP mode only
//--------------------------------------------------------------------------------------
void Xime::UpdateJPUserWordNumber()
{
    if( m_CurrentLanguage != MODE_JP )
        return;

    // Max number of user registered words is 100
    DWORD number = 100;
    
    //XIME_USER_WORD XimeUserWords[100];
    //XIMEEnumerateUserWords( 0, &number, XimeUserWords, &s_imeOverLapped );
    DWORD dwRet = XIMEEnumerateUserWords( 0, &number, NULL, &s_imeOverLapped );
    if( dwRet != ERROR_IO_INCOMPLETE )
    {   
        m_JPUserWord = 0;
        return;
    }

    while ( !XHasOverlappedIoCompleted( &s_imeOverLapped ) )
        Sleep( 50 );

    m_JPUserWord = number;
}

};// namespace ATG

```

`XenonDumper/libs/Atg/AtgXime.h`:

```h
//--------------------------------------------------------------------------------------
// AtgXime.h
//
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#pragma once
#ifndef ATGXIME_H
#define ATGXIME_H

#include <xui.h>
#include <xime.h>
#include <list>
#include <string>
#include "AtgXmlParser.h"

//#define DEBUG_USER_DIC_TEST               // For testing purpose to not delete the contents of user dictionray when ending Japanese
//#define DEBUG_FLUSH_LEARNING              // For testing purpose to flush all learning words at once
//#define DEBUG_DELETE_SINGLE_REG_WORD      // For testing purpose to delete 1 registered word 

namespace ATG
{

//--------------------------------------------------------------------------------------
// Definitions
//--------------------------------------------------------------------------------------

    const D3DCOLOR COLOR_NORMAL = D3DCOLOR_ARGB( 255, 255, 255, 255 );
    const D3DCOLOR COLOR_INIME  = D3DCOLOR_ARGB( 255, 128, 128, 128 );
    const D3DCOLOR COLOR_LIST   = D3DCOLOR_ARGB( 255, 128, 128, 128 );
    const D3DCOLOR COLOR_FOCUS  = D3DCOLOR_ARGB( 255, 255, 255, 0 );

    enum IMEMODE {
        MODE_INPUT      = 0x1,
        MODE_CONVERT    = 0x2,
        MODE_ALLCONVERT = 0x4,
        MODE_OFF        = 0x8, 
        MODE_JP         = 0x10,
        MODE_KR         = 0x20,
        MODE_TC         = 0x40, 
        MODE_SC         = 0x80, 

        MODE_JKT        = ( MODE_JP | MODE_KR | MODE_TC ),
        MODE_JKTS       = ( MODE_JP | MODE_KR | MODE_TC | MODE_SC)

    };

    class   Xime;
    struct  XIME_KEYMAPPING;
    typedef HRESULT (*IMECALLBACK)( Xime *, XIME_KEYMAPPING * pKey ) ;

    struct XIME_KEYMAPPING{
        DWORD   dwFlags;
        WORD    wVK;
        WORD    wXinputFlags;
        WORD    wIgnoredXinputFlags;
        union {
            DWORD dwUnicode;
            XIMEKEY eControlKey;
        };
        IMECALLBACK     function;
    };

    struct XIMEREQUEST{
        DWORD dwRequestId;
        XOVERLAPPED ov;
        XINPUT_KEYSTROKE key;
    };
    const DWORD NEED_TO_DISABLE_LIST = 1; // magic number; for JP's SetCandidate()
    const DWORD NEED_TO_COMPLETE = 2;     // magic number; for CHT's Complete()

typedef std::list< ATG::XIMEREQUEST > RequestList;

struct HID_LOOKUP_TABLE {
        WCHAR wHiragana;
        WCHAR wHiraganaShifted;
        WCHAR wKatakana;
        WCHAR wKatakanaShifted;
};

struct XIMEPOS_LOOKUP_TABLE{
    XIMEPOS value;
    LPCWSTR string;
};

    const UINT  XIME_DIC_ENTRY_WORD_LENGTH = 16;

class Xime
{
public:
    static BOOL g_bIsStaticXime;
    static XIME_KEYMAPPING m_InputKeymap[];
    static BOOL m_bLoadTitleDictionary;
    DWORD  m_dwUserIndex;

    // XIME methods
    BOOL    IsIMEOn( void ) { return m_bIMEOn || m_bCompleted || m_dwCharsInXime != 0; };
    HRESULT SetInputLanguage(IMEMODE eLanguage);
    HRESULT Init( IMEMODE eLanguage, DWORD dwCharLength, D3DPRESENT_PARAMETERS * pD3DParam );
    HRESULT Update();
    HRESULT Render( HXUIDC hDC, HXUIFONT hFont, float fPosX, float fPofY );
    BOOL    IsStringReady( void );
    HRESULT GetString( std::wstring & stringOut );
    // Get IME modes
    INT     GetInputMode( void ) { return m_iInputMode; };
    INT     GetKeyboardLayout( void ) { return m_iKeyboardLayout; };
    IMEMODE GetCurrentLanguage( void ) { return m_CurrentLanguage; };
    HRESULT GetLastKey( XINPUT_KEYSTROKE * pKey ) { XINPUT_KEYSTROKE *pSrcKey;
                                                    if( IsIMEOn() )
                                                    {
                                                        if( m_bCompleted )
                                                        {
                                                            memset( pKey, 0, sizeof(XINPUT_KEYSTROKE) );
                                                            return S_OK;
                                                        }
                                                        pSrcKey = &m_LastKey;
                                                    }
                                                    else
                                                        pSrcKey = &m_Key;
                                                    memcpy( pKey, pSrcKey, sizeof(XINPUT_KEYSTROKE) );
                                                    memset( pSrcKey, 0, sizeof(XINPUT_KEYSTROKE) );
                                                    return S_OK;
                                                  };
    DWORD   GetInputCharacterLength( void ) { return m_dwInputCharacterLength; };
    VOID    SetInputCharacterLength( DWORD dwLength ) { m_dwInputCharacterLength = dwLength; m_bUpdateInputLength = TRUE; };
    VOID    EnumerateDictionarySummary();
    static  HRESULT SwitchLanguage(Xime *pXime);
    static  HRESULT ToggleIME( Xime * pXime );

    HRESULT LoadJPUserWordFile(const CHAR* strUserWordFile);
    static  HRESULT RegisterJPUserWord(LPCWSTR pReading, LPCWSTR pDisplay, LPCWSTR pImePos);

    HRESULT DeleteJPUserWordAll();
    UINT    GetJPUserWordNumber(){ return m_JPUserWord; };

private:
    // Dictionaries
    static const int   iNumDicsJP;
    static const int   iNumDicsTC;
    static const char  szMainDicPath[];
    static const char  szSubDicPath[];
    static const char  szTitleDicPath[];
    static const char  szXEXTitleDicPathFileLocator[];
    static const char  szXEXTitleDicPath[];
    static const char  szBopomofoDicPath[];
    
    static const INT NUM_STRINGBUFFER =512;
    static const INT NUM_CANDIATEINPAGE = 5;
    
    static const DWORD DEFAULT_CHARACTERLENGTH = 32;

    static XOVERLAPPED s_imeOverLapped;

    static WCHAR  m_StringBuffer[ NUM_STRINGBUFFER ];
    static WCHAR  m_CandidateListBuffer[ NUM_STRINGBUFFER ];
    
    static FILE   *fpUserDic;
    static char   m_UserDicMemory[ XEIME_JP_SIZE_OF_USERDIC ];

    //Callbacks
    static HRESULT Convert( Xime * pXime, XIME_KEYMAPPING * pKey );
    static HRESULT NonConvert( Xime * pXime, XIME_KEYMAPPING * pKey );
    static HRESULT ChangeFocus( Xime * pXime, XIME_KEYMAPPING * pKey );
    static HRESULT ChangeClauseLength( Xime * pXime, XIME_KEYMAPPING * pKey );
    static HRESULT Revert( Xime * pXime, XIME_KEYMAPPING * pKey );
    static HRESULT BuildCandidateList( Xime * pXime, XIME_KEYMAPPING * pKey );
    static HRESULT SetCandidate( Xime * pXime, XIME_KEYMAPPING * pKey );
    static HRESULT Complete( Xime * pXime, XIME_KEYMAPPING * pKey );
    static HRESULT HandleNumpadInput( Xime * pXime, XIME_KEYMAPPING * pKey );
    static HRESULT HandleNumpadConversion( Xime * pXime, XIME_KEYMAPPING * pKey );

    static HRESULT AllConvert( Xime * pXime, XIME_KEYMAPPING * pKey );
    static HRESULT AllRevert( Xime * pXime, XIME_KEYMAPPING * pKey );
    static HRESULT ChangeInputMode( Xime * pXime, XIME_KEYMAPPING * pKey );

    //Japanese specific routines
    static HRESULT ToggleKeyboardLayout( Xime * pXime, XIME_KEYMAPPING * pKey );

    HRESULT LayoutConversion( XINPUT_KEYSTROKE* pKey, INT* pIntputMode );

    // Bopomofo specific routines
    static HRESULT NothingToDo( Xime * pXime, XIME_KEYMAPPING * pKey ) { return ERROR_SUCCESS; }

    void    DrawText( HXUIDC hdc, HXUIFONT hFont, D3DCOLOR color,
                      float x, float y, LPCWSTR text,
                      float * fX = NULL, float * fY = NULL );
    void    SetCurrentMode( IMEMODE );

    // Language specific routine for non ALPHANUMERIC layout
    VOID    HidUnicodeLookUp( XINPUT_KEYSTROKE* pKey, BOOL fImeOn, BOOL fKana,
                              HID_LOOKUP_TABLE * pTable, HID_LOOKUP_TABLE * pTable2 );
    
    static  XIMEPOS XimeposLookup(LPCWSTR pStr);
    // block function, shouldn't be called every frame
    void    UpdateJPUserWordNumber(); 

    RequestList         m_RequestList;
    IMEMODE             m_CurrentImeMode;
    IMEMODE             m_CurrentLanguage;
    BOOL                m_bShowCandidateList;
    BOOL                m_bNeedBlocking;
    
    float               m_BackBufferWidth;
    float               m_BackBufferHeight;
    BOOL                m_bCompleted;
    DWORD               m_dwCharsInXime;
    INT                 m_iInputMode;
    INT                 m_iKeyboardLayout;
    BOOL                m_bIMEOn;
    DWORD               m_dwInputCharacterLength;
    BOOL                m_bUpdateInputLength;
    BOOL                m_bGotClause;

    XINPUT_KEYSTROKE    m_Key;
    XINPUT_KEYSTROKE    m_LastKey;

    std::wstring        m_CurrentString;
    std::wstring        m_CompletedString;
    UINT                m_JPUserWord;
};



class UserWordFileCallback : public ISAXCallback
{
public:
    virtual HRESULT  StartDocument() { return S_OK; };
    virtual HRESULT  EndDocument() { return S_OK; };

    virtual HRESULT  ElementBegin( CONST WCHAR* strName, UINT NameLen, CONST XMLAttribute *pAttributes, UINT NumAttributes )
    {
        WCHAR wAttName[32] = L"";
        WCHAR wReading[32] = L"";
        WCHAR wDisplay[32] = L"";;
        WCHAR wXIMEPOS[32] = L"";;

        if (NameLen >31)
            return S_FALSE;
        else
            wcsncpy_s( wAttName, strName, NameLen);
        
        if  ( _wcsicmp(wAttName,L"USERWORD") == 0)
        {
            return S_OK;
        }
        else if ( _wcsicmp(wAttName,L"ENTRY") == 0)
        {
            for(UINT i = 0; i < NumAttributes; i++)
            {
                wcsncpy_s( wAttName, pAttributes[i].strName, pAttributes[i].NameLen);
                if (_wcsicmp(wAttName,L"READING")==0)
                {
                    if (pAttributes[i].ValueLen <= XIME_DIC_ENTRY_WORD_LENGTH)
                        wcsncpy_s( wReading, pAttributes[i].strValue, pAttributes[i].ValueLen);
                }
                else if (_wcsicmp(wAttName,L"DISPLAY")==0)
                {
                    if (pAttributes[i].ValueLen <= XIME_DIC_ENTRY_WORD_LENGTH)
                        wcsncpy_s( wDisplay, pAttributes[i].strValue, pAttributes[i].ValueLen);
                }
                else if (_wcsicmp(wAttName,L"XIMEPOS")==0)
                {
                    if (pAttributes[i].ValueLen <= 31)
                        wcsncpy_s( wXIMEPOS, pAttributes[i].strValue, pAttributes[i].ValueLen);
                }
            }
            return Xime::RegisterJPUserWord(wReading , wDisplay , wXIMEPOS);
        }
        else
        {
            return S_FALSE;
        }
    };
    
    virtual HRESULT  ElementContent( CONST WCHAR *strData, UINT DataLen, BOOL More ) {    return S_OK;   };

    virtual HRESULT  ElementEnd( CONST WCHAR *strName, UINT NameLen ){       return S_OK;    };

    virtual HRESULT  CDATABegin( )  { return S_OK; };

    virtual HRESULT  CDATAData( CONST WCHAR *strCDATA, UINT CDATALen, BOOL bMore ){ return S_OK; };

    virtual HRESULT  CDATAEnd( ){ return S_OK; };

    virtual VOID     Error( HRESULT hError, CONST CHAR *strMessage )    {     OutputDebugString("Error when Parsing user word XML\n");    };

};



}; // namespace ATG

#endif

```

`XenonDumper/libs/Atg/AtgXmlParser.cpp`:

```cpp
//-------------------------------------------------------------------------------------
//  AtgXmlParser.cpp
//  
//  Simple callback non-validating XML parser implementation.
//
//  Xbox Advanced Technology Group.
//  Copyright (C) Microsoft Corporation. All rights reserved.
//-------------------------------------------------------------------------------------

#include "stdafx.h"
#include "AtgXmlParser.h"

namespace ATG
{

//-------------------------------------------------------------------------------------
// Name: XMLParser::XMLParser
//-------------------------------------------------------------------------------------
XMLParser::XMLParser()
{
    m_pWritePtr = m_pWriteBuf;
    m_pReadPtr = m_pReadBuf;
    m_pISAXCallback = NULL;
    m_hFile = INVALID_HANDLE_VALUE;
}

//-------------------------------------------------------------------------------------
// Name: XMLParser::~XMLParser
//-------------------------------------------------------------------------------------
XMLParser::~XMLParser()
{    
}


//-------------------------------------------------------------------------------------
// Name: XMLParser::FillBuffer
// Desc: Reads a block from the current open file
//-------------------------------------------------------------------------------------
VOID XMLParser::FillBuffer()
{
    DWORD NChars;

    m_pReadPtr = m_pReadBuf;

    if( m_hFile == NULL )
    {
        if( m_uInXMLBufferCharsLeft > XML_READ_BUFFER_SIZE )                    
            NChars = XML_READ_BUFFER_SIZE;
        else
            NChars = m_uInXMLBufferCharsLeft;
        
        CopyMemory( m_pReadBuf, m_pInXMLBuffer, NChars );
        m_uInXMLBufferCharsLeft -= NChars;
        m_pInXMLBuffer += NChars;
    }
    else
    {
        if( !ReadFile( m_hFile, m_pReadBuf, XML_READ_BUFFER_SIZE, &NChars, NULL ))
        {
            return;
        }
    }

    m_dwCharsConsumed += NChars;
    __int64 iProgress = m_dwCharsTotal ? (( (__int64)m_dwCharsConsumed * 1000 ) / (__int64)m_dwCharsTotal) : 0;
    m_pISAXCallback->SetParseProgress( (DWORD)iProgress );

    m_pReadBuf[ NChars ] = '\0';
    m_pReadBuf[ NChars + 1] = '\0';
}


//-------------------------------------------------------------------------------------
// Name: XMLParser::SkipNextAdvance
// Desc: Puts the last character read back on the input stream
//-------------------------------------------------------------------------------------
VOID XMLParser::SkipNextAdvance()
{
    m_bSkipNextAdvance = TRUE;
}


//-------------------------------------------------------------------------------------
// Name: XMLParser::ConsumeSpace
// Desc: Skips spaces in the current stream 
//-------------------------------------------------------------------------------------
HRESULT XMLParser::ConsumeSpace()
{
    HRESULT hr;

    // Skip spaces
    if( FAILED( hr = AdvanceCharacter() ) )
        return hr;

    while ( ( m_Ch == ' ' ) || ( m_Ch == '\t' ) ||
            ( m_Ch == '\n' ) || ( m_Ch == '\r' ) )
    {
        if( FAILED( hr = AdvanceCharacter() ) )
            return hr;
    } 
    SkipNextAdvance();   
    return S_OK;
}


//-------------------------------------------------------------------------------------
// Name: XMLParser::ConvertEscape
// Desc: Copies and converts an escape sequence into m_pWriteBuf 
//-------------------------------------------------------------------------------------
HRESULT XMLParser::ConvertEscape()
{      
    HRESULT hr;
    WCHAR wVal = 0;
        
    if( FAILED( hr = AdvanceCharacter() ) )
        return hr;

    // all escape sequences start with &, so ignore the first character    
    
    if( FAILED( hr = AdvanceCharacter() ) )
        return hr;
    
    if ( m_Ch == '#' )     // character as hex or decimal
    {
        if( FAILED( hr = AdvanceCharacter() ) )
            return hr;
        if ( m_Ch == 'x' )     // hex number
        {
            if( FAILED( hr = AdvanceCharacter() ) )
                return hr;
            
            while ( m_Ch != ';' )
            {                
                wVal *= 16;

                if ( ( m_Ch >= '0' ) && ( m_Ch <= '9' ) )
                {
                    wVal += m_Ch - '0';
                }
                else if ( ( m_Ch >= 'a' ) && ( m_Ch <= 'f' ) )
                {
                    wVal += m_Ch - 'a' + 10;
                }
                else if ( ( m_Ch >= 'A' ) && ( m_Ch <= 'F' ) )
                {
                    wVal += m_Ch - 'A' + 10;
                }                     
                else
                {
                    Error( E_INVALID_XML_SYNTAX, "Expected hex digit as part of &#x escape sequence" );                        
                    return E_INVALID_XML_SYNTAX; 
                }

                if( FAILED( hr = AdvanceCharacter() ) )
                    return hr;
            }
        }
        else                    // decimal number
        {
            while ( m_Ch != ';' )
            {                
                wVal *= 10;

                if ( ( m_Ch >= '0' ) && ( m_Ch <= '9' ) )
                {
                    wVal += m_Ch - '0';
                }
                else
                {
                    Error( E_INVALID_XML_SYNTAX, "Expected decimal digit as part of &# escape sequence" );                        
                    return E_INVALID_XML_SYNTAX;
                }

                if( FAILED( hr = AdvanceCharacter() ) )
                    return hr;
            }
        }

        // copy character into the buffer
        m_Ch = wVal;

        return S_OK;
    }  

    // must be an entity reference

    WCHAR *pEntityRefVal = m_pWritePtr;
    UINT EntityRefLen;

    SkipNextAdvance();
    if( FAILED( hr = AdvanceName() ) )
        return hr;
      
    EntityRefLen = (UINT)( m_pWritePtr - pEntityRefVal );
    m_pWritePtr = pEntityRefVal;

    if ( EntityRefLen == 0 )
    {
        Error( E_INVALID_XML_SYNTAX, "Expecting entity name after &" );                        
        return E_INVALID_XML_SYNTAX;
    }

    if( !wcsncmp( pEntityRefVal, L"lt", EntityRefLen ) )
        wVal = '<';
    else if( !wcsncmp( pEntityRefVal, L"gt", EntityRefLen ) )
        wVal = '>';
    else if( !wcsncmp( pEntityRefVal, L"amp", EntityRefLen ) )
        wVal = '&';
    else if( !wcsncmp( pEntityRefVal, L"apos", EntityRefLen ) )
        wVal = '\'';
    else if( !wcsncmp( pEntityRefVal, L"quot", EntityRefLen ) )
        wVal = '"';
    else
    {
        Error( E_INVALID_XML_SYNTAX, "Unrecognized entity name after & - (should be lt, gt, amp, apos, or quot)" );                        
        return E_INVALID_XML_SYNTAX;   // return false if unrecognized token sequence
    }

    if( FAILED( hr = AdvanceCharacter() ) )
        return hr;

    if( m_Ch != ';' )
    {
        Error( E_INVALID_XML_SYNTAX, "Expected terminating ; for entity reference" );                                            
        return E_INVALID_XML_SYNTAX;   // malformed reference - needs terminating ;
    }
    
    m_Ch = wVal;
    return S_OK;
}


//-------------------------------------------------------------------------------------
// Name: XMLParser::AdvanceAttrVal
// Desc: Copies an attribute value into m_pWrite buf, skipping surrounding quotes
//-------------------------------------------------------------------------------------
HRESULT XMLParser::AdvanceAttrVal()
{
    HRESULT hr;
    WCHAR wQuoteChar;

    if( FAILED( hr = AdvanceCharacter() ) )
        return hr;

    if( ( m_Ch != '"' ) && ( m_Ch != '\'' ) )
    {        
        Error( E_INVALID_XML_SYNTAX, "Attribute values must be enclosed in quotes" );     
        return E_INVALID_XML_SYNTAX;
    }

    wQuoteChar = m_Ch;
    
    for( ;; )
    {
        if( FAILED( hr = AdvanceCharacter() ) )
            return hr;      
        else if( m_Ch == wQuoteChar )     
            break;        
        else if( m_Ch == '&' )
        {
            SkipNextAdvance();
            if( FAILED( hr = ConvertEscape() ) )
                return hr;  
        }
        else if( m_Ch == '<' )   
        {
            Error( E_INVALID_XML_SYNTAX, "Illegal character '<' in element tag" );     
            return E_INVALID_XML_SYNTAX;        
        }
        
        // copy character into the buffer
        
        if( m_pWritePtr - m_pWriteBuf >= XML_WRITE_BUFFER_SIZE ) 
        {
            Error( E_INVALID_XML_SYNTAX, "Total element tag size may not be more than %d characters", XML_WRITE_BUFFER_SIZE );     
            return E_INVALID_XML_SYNTAX;               
        }
        
        *m_pWritePtr = m_Ch;
        m_pWritePtr++;        
    }
    return S_OK;
}


//-------------------------------------------------------------------------------------
// Name: XMLParser::AdvanceName
// Desc: Copies a name into the m_pWriteBuf - returns TRUE on success, FALSE on failure
//       Ignores leading whitespace.  Currently does not support unicode names
//-------------------------------------------------------------------------------------
HRESULT XMLParser::AdvanceName()
{   
    HRESULT hr;

    if( FAILED( hr = AdvanceCharacter() ) )
        return hr; 

    if( ( ( m_Ch < 'A' ) || ( m_Ch > 'Z' ) ) &&
        ( ( m_Ch < 'a' ) || ( m_Ch > 'z' ) ) &&
        ( m_Ch != '_' ) && ( m_Ch != ':' ) )
    {
        Error( E_INVALID_XML_SYNTAX, "Names must start with an alphabetic character or _ or :" );     
        return E_INVALID_XML_SYNTAX;   
    }

    while( ( ( m_Ch >= 'A' ) && ( m_Ch <= 'Z' ) ) ||
           ( ( m_Ch >= 'a' ) && ( m_Ch <= 'z' ) ) ||
           ( ( m_Ch >= '0' ) && ( m_Ch <= '9' ) ) ||
           ( m_Ch == '_' ) || ( m_Ch == ':' ) ||
           ( m_Ch == '-' ) || ( m_Ch == '.' ) )
    {

        if( m_pWritePtr - m_pWriteBuf >= XML_WRITE_BUFFER_SIZE )
        {
            Error( E_INVALID_XML_SYNTAX, "Total element tag size may not be more than %d characters", XML_WRITE_BUFFER_SIZE );     
            return E_INVALID_XML_SYNTAX;
        }        

        *m_pWritePtr = m_Ch;
        m_pWritePtr++;

        if( FAILED( hr = AdvanceCharacter() ) )
            return hr; 
    }
    
    SkipNextAdvance();
    return S_OK;
}


//-------------------------------------------------------------------------------------
// Name: XMLParser::AdvanceCharacter
// Desc: Copies the character at *m_pReadPtr to m_Ch
//       handling difference in UTF16 / UTF8, and big/little endian
//       and getting another chunk of the file if needed
//       Returns S_OK if there are more characters, E_ABORT for no characters to read
//-------------------------------------------------------------------------------------
HRESULT XMLParser::AdvanceCharacter( BOOL bOkToFail )
{  
    if( m_bSkipNextAdvance )
    {
        m_bSkipNextAdvance = FALSE;
        return S_OK;
    }

    // If we hit EOF in the middle of a character,
    // it's ok-- we'll just have a corrupt last character 
    // (the buffer is padded with double NULLs )

    if ( ( m_pReadPtr[0] == '\0' ) && ( m_pReadPtr[1] == '\0' ) )
    {
        // Read more from the file
        FillBuffer(); 

        // We are at EOF if it is still NULL
        if ( ( m_pReadPtr[0] == '\0' ) && ( m_pReadPtr[1] == '\0' ) )
        {
            if( !bOkToFail )
            {
                Error( E_INVALID_XML_SYNTAX, "Unexpected EOF while parsing XML file" );     
                return E_INVALID_XML_SYNTAX;
            }
            else
            {
                return E_FAIL;
            }
        }
    }       

    if( m_bUnicode == FALSE )
    {
        m_Ch = *((CHAR *)m_pReadPtr);
        m_pReadPtr++;
    }
    else // if( m_bUnicode == TRUE )
    {
        m_Ch = *((WCHAR *)m_pReadPtr);
        
        if( m_bReverseBytes )
        {
            m_Ch = ( m_Ch << 8 ) + ( m_Ch >> 8 );
        }
        
        m_pReadPtr += 2;       
    }

    if( m_Ch == '\n' )
    {
        m_pISAXCallback->m_LineNum++;
        m_pISAXCallback->m_LinePos = 0;
    }
    else if( m_Ch != '\r' )
        m_pISAXCallback->m_LinePos++;
    
    return S_OK;
}


//-------------------------------------------------------------------------------------
// Name: XMLParser::AdvanceElement
// Desc: Builds <element> data, calls callback 
//-------------------------------------------------------------------------------------
HRESULT XMLParser::AdvanceElement()
{    
    HRESULT hr;

    // write ptr at the beginning of the buffer
    m_pWritePtr = m_pWriteBuf;
    
    if( FAILED( hr = AdvanceCharacter() ) )
        return hr; 
    
    // if first character wasn't '<', we wouldn't be here
    
    if( FAILED( hr = AdvanceCharacter() ) )
        return hr; 

    if( m_Ch == '!' )
    {
        if( FAILED( hr = AdvanceCharacter() ) ) 
            return hr; 
        if ( m_Ch == '-' )
        {
            if( FAILED( hr = AdvanceCharacter() ) ) 
                return hr; 
            if( m_Ch != '-' )                       
            {
                Error( E_INVALID_XML_SYNTAX, "Expecting '-' after '<!-'" );
                return E_INVALID_XML_SYNTAX;
            }
            if( FAILED( hr = AdvanceComment() ) )   
                return hr; 
            return S_OK;
        }
    
        if( m_Ch != '[' )     
        {
            Error( E_INVALID_XML_SYNTAX, "Expecting '<![CDATA['" );
            return E_INVALID_XML_SYNTAX;
        }
        if( FAILED( hr = AdvanceCharacter() ) ) 
            return hr;             
        if( m_Ch != 'C' )                       
        {
            Error( E_INVALID_XML_SYNTAX, "Expecting '<![CDATA['" );
            return E_INVALID_XML_SYNTAX;
        }
        if( FAILED( hr = AdvanceCharacter() ) ) 
            return hr;             
        if( m_Ch != 'D' )                       
        {
            Error( E_INVALID_XML_SYNTAX, "Expecting '<![CDATA['" );
            return E_INVALID_XML_SYNTAX;
        }
        if( FAILED( hr = AdvanceCharacter() ) ) 
            return hr;             
        if( m_Ch != 'A' )                       
        {
            Error( E_INVALID_XML_SYNTAX, "Expecting '<![CDATA['" );
            return E_INVALID_XML_SYNTAX;
        }
        if( FAILED( hr = AdvanceCharacter() ) ) 
            return hr; 
        if( m_Ch != 'T' )                       
        {
            Error( E_INVALID_XML_SYNTAX, "Expecting '<![CDATA['" );
            return E_INVALID_XML_SYNTAX;
        }
        if( FAILED( hr = AdvanceCharacter() ) ) 
            return hr; 
        if( m_Ch != 'A' )                       
        {
            Error( E_INVALID_XML_SYNTAX, "Expecting '<![CDATA['" );
            return E_INVALID_XML_SYNTAX;
        }
        if( FAILED( hr = AdvanceCharacter() ) ) 
            return hr; 
        if( m_Ch != '[' )                       
        {
            Error( E_INVALID_XML_SYNTAX, "Expecting '<![CDATA['" );
            return E_INVALID_XML_SYNTAX;
        }
        if( FAILED( hr = AdvanceCDATA() ) )     
            return hr;
    }
    else if( m_Ch == '/' ) 
    {
        WCHAR *pEntityRefVal = m_pWritePtr;
     
        if( FAILED( hr = AdvanceName() ) ) 
            return hr;

        if( FAILED( m_pISAXCallback->ElementEnd( pEntityRefVal, 
                                                (UINT) ( m_pWritePtr - pEntityRefVal ) ) ) )
            return E_ABORT;
        
        if( FAILED( hr = ConsumeSpace() ) ) 
            return hr;

        if( FAILED( hr = AdvanceCharacter() ) ) 
            return hr;  

        if( m_Ch != '>' )
        {
            Error( E_INVALID_XML_SYNTAX, "Expecting '>' after name for closing entity reference" );
            return E_INVALID_XML_SYNTAX;
        }
    }
    else if( m_Ch == '?' )  
    {
        // just skip any xml header tag since not really important after identifying character set
        for( ;; )
        {
            if( FAILED( hr = AdvanceCharacter() ) )             
                return hr;           
            
            if ( m_Ch == '>' )
                return S_OK;
        }
    }
    else
    {
        XMLAttribute   Attributes[ XML_MAX_ATTRIBUTES_PER_ELEMENT ]; 
        UINT           NumAttrs;

        WCHAR *pEntityRefVal = m_pWritePtr;
        UINT  EntityRefLen;

        NumAttrs = 0;
    
        SkipNextAdvance();

        // Entity tag
        if( FAILED( hr = AdvanceName() ) ) 
            return hr;

        EntityRefLen = (UINT)( m_pWritePtr - pEntityRefVal );

        if( FAILED( hr = ConsumeSpace() ) ) 
            return hr;
        
        if( FAILED( hr = AdvanceCharacter() ) )
            return hr;         
                
        // read attributes
        while( ( m_Ch != '>' ) && ( m_Ch != '/' ) )
        {
            SkipNextAdvance();

            if ( NumAttrs >= XML_MAX_ATTRIBUTES_PER_ELEMENT )
            {
                 Error( E_INVALID_XML_SYNTAX, "Elements may not have more than %d attributes", XML_MAX_ATTRIBUTES_PER_ELEMENT );                     
                return E_INVALID_XML_SYNTAX;                
            }

            Attributes[ NumAttrs ].strName = m_pWritePtr;
            
            // Attribute name
            if( FAILED( hr = AdvanceName() ) )
                return hr;
            
            Attributes[ NumAttrs ].NameLen = (UINT)( m_pWritePtr - Attributes[ NumAttrs ].strName );

            if( FAILED( hr = ConsumeSpace() ) )
                return hr;

            if( FAILED( hr = AdvanceCharacter() ) ) 
                return hr;         

            if( m_Ch != '=' ) 
            {
                Error( E_INVALID_XML_SYNTAX, "Expecting '=' character after attribute name" );
                return E_INVALID_XML_SYNTAX;
            }
              
            if( FAILED( hr = ConsumeSpace() ) ) 
                return hr;

            Attributes[ NumAttrs ].strValue = m_pWritePtr;

            if( FAILED( hr = AdvanceAttrVal() ) )
                return hr;

            Attributes[ NumAttrs ].ValueLen = (UINT)( m_pWritePtr - 
                Attributes[ NumAttrs ].strValue );

            ++NumAttrs;
                   
            if( FAILED( hr = ConsumeSpace() ) )
                return hr;                       

            if( FAILED( hr = AdvanceCharacter() ) )
                return hr;         
        }

        if( m_Ch == '/' )
        {
            if( FAILED( hr = AdvanceCharacter() ) )
                return hr;         
            if( m_Ch != '>' )
            {
                Error( E_INVALID_XML_SYNTAX, "Expecting '>' after '/' in element tag" );
                return E_INVALID_XML_SYNTAX;
            }

            if( FAILED( m_pISAXCallback->ElementBegin( pEntityRefVal, EntityRefLen, 
                                                       Attributes, NumAttrs ) ) )
                return E_ABORT;

            if( FAILED( m_pISAXCallback->ElementEnd( pEntityRefVal, EntityRefLen ) ) )
                return E_ABORT;
        }
        else
        {
            if( FAILED( m_pISAXCallback->ElementBegin( pEntityRefVal, EntityRefLen, 
                                                       Attributes, NumAttrs ) ) )
                return E_ABORT;
        }
    }

    return S_OK;
}


//-------------------------------------------------------------------------------------
// Name: XMLParser::AdvanceCDATA
// Desc: Read a CDATA section
//-------------------------------------------------------------------------------------
HRESULT XMLParser::AdvanceCDATA()
{
    HRESULT hr;
    WORD wStage = 0;
    
    if( FAILED( m_pISAXCallback->CDATABegin() ) )
        return E_ABORT;

    for( ;; )
    {
        if( FAILED( hr = AdvanceCharacter() ) )
            return hr;
        
        *m_pWritePtr = m_Ch;
        m_pWritePtr++;
                        
        if( ( m_Ch == ']' ) && ( wStage == 0 ) )
            wStage = 1;
        else if( ( m_Ch == ']' ) && ( wStage == 1 ) )
            wStage = 2;
        else if( ( m_Ch == '>' ) && ( wStage == 2 ) )
        {
            m_pWritePtr -= 3;
            break;
        }
        else
            wStage = 0;

        if( m_pWritePtr - m_pWriteBuf >= XML_WRITE_BUFFER_SIZE )
        {
            if( FAILED( m_pISAXCallback->CDATAData( m_pWriteBuf, (UINT)( m_pWritePtr - m_pWriteBuf ), TRUE ) ) )
                return E_ABORT;
            m_pWritePtr = m_pWriteBuf;
        }        
    }
    
    if( FAILED( m_pISAXCallback->CDATAData( m_pWriteBuf, (UINT)( m_pWritePtr - m_pWriteBuf ), FALSE ) ) )
        return E_ABORT;

    m_pWritePtr = m_pWriteBuf;

    if( FAILED( m_pISAXCallback->CDATAEnd() ) )
        return E_ABORT;
    
    return S_OK;
}

//-------------------------------------------------------------------------------------
// Name: XMLParser::AdvanceComment
// Desk: Skips over a comment
//-------------------------------------------------------------------------------------
HRESULT XMLParser::AdvanceComment()
{
    HRESULT hr;
    WORD wStage;

    wStage = 0;
    for( ;; )
    {
        if( FAILED( hr = AdvanceCharacter() ) )
            return hr;
        
        if (( m_Ch == '-' ) && ( wStage == 0 ))
            wStage = 1;
        else if (( m_Ch == '-' ) && ( wStage == 1 ))
            wStage = 2;
        else if (( m_Ch == '>' ) && ( wStage == 2 ))                    
            break;        
        else
            wStage = 0;      
    }
    
    return S_OK;
}


//-------------------------------------------------------------------------------------
// Name: XMLParser::RegisterSAXCallbackInterface
// Desc: Registers callback interface 
//-------------------------------------------------------------------------------------
VOID XMLParser::RegisterSAXCallbackInterface( ISAXCallback *pISAXCallback )
{
    m_pISAXCallback = pISAXCallback;
}


//-------------------------------------------------------------------------------------
// Name: XMLParser::GetSAXCallbackInterface
// Desc: Returns current callback interface 
//-------------------------------------------------------------------------------------
ISAXCallback* XMLParser::GetSAXCallbackInterface()
{
    return m_pISAXCallback;
}


//-------------------------------------------------------------------------------------
// Name: XMLParser::MainParseLoop
// Desc: Main Loop to Parse Data - source agnostic
//-------------------------------------------------------------------------------------
HRESULT XMLParser::MainParseLoop()
{
    BOOL bWhiteSpaceOnly = TRUE;
    HRESULT hr = S_OK;

    if( FAILED( m_pISAXCallback->StartDocument() ) )
        return E_ABORT;
    
    m_pWritePtr = m_pWriteBuf;

    FillBuffer();

    if ( *((WCHAR *) m_pReadBuf ) == 0xFEFF )
    {
        m_bUnicode = TRUE;
        m_bReverseBytes = FALSE;
        m_pReadPtr += 2;
    }
    else if ( *((WCHAR *) m_pReadBuf ) == 0xFFFE )    
    {
        m_bUnicode = TRUE;
        m_bReverseBytes = TRUE;
        m_pReadPtr += 2;        
    }
    else if ( *((WCHAR *) m_pReadBuf ) == 0x003C )    
    {
        m_bUnicode = TRUE;      
        m_bReverseBytes = FALSE;
    }
    else if ( *((WCHAR *) m_pReadBuf ) == 0x3C00 )    
    {
        m_bUnicode = TRUE;
        m_bReverseBytes = TRUE;        
    }
    else if ( m_pReadBuf[ 0 ] == 0x3C )
    {
        m_bUnicode = FALSE;     
        m_bReverseBytes = FALSE;        
    }
    else
    {        
        Error( E_INVALID_XML_SYNTAX, "Unrecognized encoding (parser does not support UTF-8 language encodings)" );
        return E_INVALID_XML_SYNTAX;        
    }
            
    for( ;; )
    {
        if( FAILED( AdvanceCharacter( TRUE ) ) )
        {
            if ( ( (UINT) ( m_pWritePtr - m_pWriteBuf ) != 0 ) && ( !bWhiteSpaceOnly ) )
            {                
                if( FAILED( m_pISAXCallback->ElementContent( m_pWriteBuf, (UINT)( m_pWritePtr - m_pWriteBuf ), FALSE ) ) )                
                    return E_ABORT;                                    

                bWhiteSpaceOnly = TRUE;
            }
            
            if( FAILED( m_pISAXCallback->EndDocument() ) )
                return E_ABORT;
                
            return S_OK;            
        }

        if( m_Ch == '<' )
        {
            if( ( (UINT) ( m_pWritePtr - m_pWriteBuf ) != 0 ) && ( !bWhiteSpaceOnly ) )
            {                
                if( FAILED( m_pISAXCallback->ElementContent( m_pWriteBuf, (UINT)( m_pWritePtr - m_pWriteBuf ), FALSE ) ) )                
                    return E_ABORT;                

                bWhiteSpaceOnly = TRUE;
            }

            SkipNextAdvance();

            m_pWritePtr = m_pWriteBuf;

            if( FAILED( hr = AdvanceElement() ) )              
                return hr;                     

            m_pWritePtr = m_pWriteBuf;
        }
        else 
        {
            if( m_Ch == '&' )
            {
                SkipNextAdvance();
                if( FAILED( hr = ConvertEscape() ) )                                                                              
                    return hr;            
            }

            if( bWhiteSpaceOnly && ( m_Ch != ' ' ) && ( m_Ch != '\n' ) && ( m_Ch != '\r' ) && 
                                    ( m_Ch != '\t' ) ) 
            {
                bWhiteSpaceOnly = FALSE;
            }

            *m_pWritePtr = m_Ch;
            m_pWritePtr++;
            
            if( m_pWritePtr - m_pWriteBuf >= XML_WRITE_BUFFER_SIZE )
            {
                if( !bWhiteSpaceOnly )
                {                    
                    if( FAILED( m_pISAXCallback->ElementContent( m_pWriteBuf, 
                                                                    ( UINT ) ( m_pWritePtr - m_pWriteBuf ), 
                                                                    TRUE ) ) )
                    {
                        return E_ABORT;                        
                    }
                }

                m_pWritePtr = m_pWriteBuf;
                bWhiteSpaceOnly = TRUE;
            }
        }         
    }
}


//-------------------------------------------------------------------------------------
// Name: XMLParser::ParseXMLFile
// Desc: Builds element data
//-------------------------------------------------------------------------------------
HRESULT XMLParser::ParseXMLFile( CONST CHAR *strFilename )
{    
    HRESULT hr;

    if( m_pISAXCallback == NULL )
        return E_NOINTERFACE;

    m_pISAXCallback->m_LineNum = 1;  
    m_pISAXCallback->m_LinePos = 0;
    m_pISAXCallback->m_strFilename = strFilename;  // save this off only while we parse the file

    m_bSkipNextAdvance = FALSE;
    m_pReadPtr = m_pReadBuf;   
    
    m_pReadBuf[ 0 ] = '\0';
    m_pReadBuf[ 1 ] = '\0';    
   
    m_pInXMLBuffer = NULL;
    m_uInXMLBufferCharsLeft = 0;
    m_hFile = CreateFile( strFilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL );    

    if( m_hFile == INVALID_HANDLE_VALUE )
    {        
        Error( E_COULD_NOT_OPEN_FILE, "Error opening file" );
        hr = E_COULD_NOT_OPEN_FILE;
       
    }
    else
    {
        LARGE_INTEGER iFileSize;
        GetFileSizeEx( m_hFile, &iFileSize );
        m_dwCharsTotal = (DWORD)iFileSize.QuadPart;
        m_dwCharsConsumed = 0;
        hr = MainParseLoop();
    }
    
    // Close the file
    if( m_hFile != INVALID_HANDLE_VALUE )
        CloseHandle( m_hFile );
    m_hFile = INVALID_HANDLE_VALUE;

    // we no longer own strFilename, so un-set it
    m_pISAXCallback->m_strFilename = NULL;  

    return hr;
}

//-------------------------------------------------------------------------------------
// Name: XMLParser::ParseXMLFile
// Desc: Builds element data
//-------------------------------------------------------------------------------------
HRESULT XMLParser::ParseXMLBuffer( CONST CHAR *strBuffer, UINT uBufferSize )
{    
    HRESULT hr;
 
    if( m_pISAXCallback == NULL )
        return E_NOINTERFACE;

    m_pISAXCallback->m_LineNum = 1;  
    m_pISAXCallback->m_LinePos = 0;
    m_pISAXCallback->m_strFilename = "";  // save this off only while we parse the file

    m_bSkipNextAdvance = FALSE;
    m_pReadPtr = m_pReadBuf;
    
    m_pReadBuf[ 0 ] = '\0';
    m_pReadBuf[ 1 ] = '\0';    

    m_hFile = NULL;
    m_pInXMLBuffer = strBuffer;
    m_uInXMLBufferCharsLeft = uBufferSize;
    m_dwCharsTotal = uBufferSize;
    m_dwCharsConsumed = 0;
    
    hr = MainParseLoop();

    // we no longer own strFilename, so un-set it
    m_pISAXCallback->m_strFilename = NULL;  

    return hr;
}

//-------------------------------------------------------------------------------------
// XMLParser::Error()      
//      Logs an error through the callback interface
//-------------------------------------------------------------------------------------
#ifdef  _Printf_format_string_  // VC++ 2008 and later support this annotation
VOID XMLParser::Error( HRESULT hErr, _In_z_ _Printf_format_string_ CONST CHAR* strFormat, ... )
#else
VOID XMLParser::Error( HRESULT hErr, CONST CHAR* strFormat, ... )
#endif
{
    CONST INT MAX_OUTPUT_STR = 160;
    CHAR strBuffer[ MAX_OUTPUT_STR ];
    va_list pArglist;
    va_start( pArglist, strFormat );

    vsprintf_s( strBuffer, strFormat, pArglist );
    
    m_pISAXCallback->Error( hErr, strBuffer );
    va_end( pArglist );
}

} // namespace ATG

```

`XenonDumper/libs/Atg/AtgXmlParser.h`:

```h
//-------------------------------------------------------------------------------------
//  AtgXmlParser.h
//
//  XMLParser and SAX interface declaration
//
//  Xbox Advanced Technology Group
//  Copyright (C) Microsoft Corporation. All rights reserved.
//-------------------------------------------------------------------------------------

#pragma once
#ifndef ATGXMLPARSER_H
#define ATGXMLPARSER_H

namespace ATG
{

//-----------------------------------------------------------------------------
// error returns from XMLParse
//-----------------------------------------------------------------------------
#define _ATGFAC 0x61B
#define E_COULD_NOT_OPEN_FILE   MAKE_HRESULT(1, _ATGFAC, 0x0001 )
#define E_INVALID_XML_SYNTAX    MAKE_HRESULT(1, _ATGFAC, 0x0002 )


CONST UINT XML_MAX_ATTRIBUTES_PER_ELEMENT  =   32;
CONST UINT XML_MAX_NAME_LENGTH             =   128;
CONST UINT XML_READ_BUFFER_SIZE            =   2048;
CONST UINT XML_WRITE_BUFFER_SIZE           =   2048;   

// No tag can be longer than XML_WRITE_BUFFER_SIZE - an error will be returned if 
// it is

//-------------------------------------------------------------------------------------
struct XMLAttribute
{
    WCHAR*  strName;
    UINT    NameLen;
    WCHAR*  strValue;
    UINT    ValueLen;       
};

//-------------------------------------------------------------------------------------
class ISAXCallback
{
friend class XMLParser;
public:
    ISAXCallback() {};
    virtual ~ISAXCallback() {};

    virtual HRESULT  StartDocument() = 0;
    virtual HRESULT  EndDocument() = 0;

    virtual HRESULT  ElementBegin( CONST WCHAR* strName, UINT NameLen, 
                                   CONST XMLAttribute *pAttributes, UINT NumAttributes ) = 0;
    virtual HRESULT  ElementContent( CONST WCHAR *strData, UINT DataLen, BOOL More ) = 0;
    virtual HRESULT  ElementEnd( CONST WCHAR *strName, UINT NameLen ) = 0;

    virtual HRESULT  CDATABegin( ) = 0;
    virtual HRESULT  CDATAData( CONST WCHAR *strCDATA, UINT CDATALen, BOOL bMore ) = 0;
    virtual HRESULT  CDATAEnd( ) = 0;

    virtual VOID     Error( HRESULT hError, CONST CHAR *strMessage ) = 0;

    virtual VOID     SetParseProgress( DWORD dwProgress ) { }

    const CHAR*      GetFilename() { return m_strFilename; }
    UINT             GetLineNumber() { return m_LineNum; }
    UINT             GetLinePosition() { return m_LinePos; }

private:
    CONST CHAR *m_strFilename;
    UINT        m_LineNum;
    UINT        m_LinePos;
};


//-------------------------------------------------------------------------------------
class XMLParser
{
public:    
    XMLParser();
    ~XMLParser();
   
    //      Register an interface inheiriting from ISAXCallback
    VOID            RegisterSAXCallbackInterface( ISAXCallback *pISAXCallback );
    
    //      Get the registered interface
    ISAXCallback*   GetSAXCallbackInterface();    

    //      ParseXMLFile returns one of the following:
    //         E_COULD_NOT_OPEN_FILE - couldn't open the file    
    //         E_INVALID_XML_SYNTAX - bad XML syntax according to this parser
    //         E_NOINTERFACE - RegisterSAXCallbackInterface not called
    //         E_ABORT - callback returned a fail code
    //         S_OK - file parsed and completed   

    HRESULT    ParseXMLFile( CONST CHAR *strFilename );                              
    
    //      Parses from a buffer- if you pass a WCHAR buffer (and cast it), it will 
    //         correctly detect it and use unicode instead.  Return codes are the
    //         same as for ParseXMLFile

    HRESULT    ParseXMLBuffer( CONST CHAR* strBuffer, UINT uBufferSize );    

private:      
    HRESULT    MainParseLoop();

    HRESULT    AdvanceCharacter( BOOL bOkToFail = FALSE ); 
    VOID       SkipNextAdvance();           

    HRESULT    ConsumeSpace();            
    HRESULT    ConvertEscape();           
    HRESULT    AdvanceElement();           
    HRESULT    AdvanceName();            
    HRESULT    AdvanceAttrVal();           
    HRESULT    AdvanceCDATA();           
    HRESULT    AdvanceComment();          

    VOID    FillBuffer();
    
#ifdef  _Printf_format_string_  // VC++ 2008 and later support this annotation
    VOID    Error( HRESULT hRet, _In_z_ _Printf_format_string_ CONST CHAR* strFormat, ... );
#else
    VOID    Error( HRESULT hRet, CONST CHAR* strFormat, ... );
#endif

    ISAXCallback*   m_pISAXCallback;    

    HANDLE          m_hFile;    
    CONST CHAR*     m_pInXMLBuffer; 
    UINT            m_uInXMLBufferCharsLeft;
    DWORD           m_dwCharsTotal;
    DWORD           m_dwCharsConsumed;

    BYTE            m_pReadBuf[ XML_READ_BUFFER_SIZE + 2 ]; // room for a trailing NULL
    WCHAR           m_pWriteBuf[ XML_WRITE_BUFFER_SIZE ];    

    BYTE*           m_pReadPtr;
    WCHAR*          m_pWritePtr;        // write pointer within m_pBuf      

    BOOL            m_bUnicode;         // TRUE = 16-bits, FALSE = 8-bits
    BOOL            m_bReverseBytes;    // TRUE = reverse bytes, FALSE = don't reverse
    
    BOOL            m_bSkipNextAdvance;
    WCHAR           m_Ch;               // Current character being parsed
};

}  // namespace ATG

#endif

```

`XenonDumper/libs/Atg/AtgXmlWriter.cpp`:

```cpp
//-------------------------------------------------------------------------------------
//  AtgXmlWriter.h
//  
//  A simple XML writer.
//  
//  Xbox Advanced Technology Group
//  Copyright (C) Microsoft Corporation. All rights reserved.
//-------------------------------------------------------------------------------------

#include "stdafx.h"
#include "AtgXmlWriter.h"

#define WRITE_BUFFER_SIZE 16384

namespace ATG
{

//----------------------------------------------------------------------------------
// Name: XMLWriter
// Desc: constructor for the XML writer class.
//----------------------------------------------------------------------------------
XMLWriter::XMLWriter() : m_strBuffer( NULL ),
                         m_uBufferSizeRemaining( 0 ),
                         m_hFile( INVALID_HANDLE_VALUE ),
                         m_strNameStackTop( m_strNameStack ),
                         m_uIndentCount( 0 )
{
}


//----------------------------------------------------------------------------------
// Name: XMLWriter
// Desc: constructor for the XML writer class.
//----------------------------------------------------------------------------------
XMLWriter::XMLWriter( const CHAR* strFileName )
{
    Initialize( strFileName );
}


//----------------------------------------------------------------------------------
// Name: XMLWriter
// Desc: constructor for the XML writer class.
//----------------------------------------------------------------------------------
XMLWriter::XMLWriter( CHAR* strBuffer, UINT uBufferSize )
{
    Initialize( strBuffer, uBufferSize );
}


//----------------------------------------------------------------------------------
// Name: ~XMLWriter
// Desc: Destructor for the XML writer class.
//----------------------------------------------------------------------------------
XMLWriter::~XMLWriter()
{
    Close();
}


//----------------------------------------------------------------------------------
// Name: Initialize
// Desc: Sets up the XML writer to write to a file.
//----------------------------------------------------------------------------------
VOID XMLWriter::Initialize( const CHAR* strFileName )
{
    m_strBuffer = new CHAR[WRITE_BUFFER_SIZE];
    m_strBufferStart = m_strBuffer;
    m_uBufferSizeRemaining = WRITE_BUFFER_SIZE;
    m_bOpenTagFinished = TRUE;
    m_bWriteCloseTagIndent = FALSE;
    m_hFile = CreateFile( strFileName, FILE_WRITE_DATA, 0, NULL, CREATE_ALWAYS, FILE_FLAG_SEQUENTIAL_SCAN, NULL );
    m_strNameStack[0] = '\0';
    m_strNameStackTop = m_strNameStack;
    m_NameStackPositions.clear();
    SetIndentCount( 4 );
    m_bWriteNewlines = TRUE;
}


//----------------------------------------------------------------------------------
// Name: Initialize
// Desc: Sets up the XML writer to write to a string buffer.
//----------------------------------------------------------------------------------
VOID XMLWriter::Initialize( CHAR* strBuffer, UINT uBufferSize )
{
    m_strBuffer = strBuffer;
    m_strBufferStart = m_strBuffer;
    m_uBufferSizeRemaining = uBufferSize;
    m_hFile = INVALID_HANDLE_VALUE;
    m_bOpenTagFinished = TRUE;
    m_bWriteCloseTagIndent = FALSE;
    m_strNameStack[0] = '\0';
    m_strNameStackTop = m_strNameStack;
    m_NameStackPositions.clear();
    SetIndentCount( 0 );
    m_bWriteNewlines = FALSE;
}


//----------------------------------------------------------------------------------
// Name: Close
// Desc: Cleans up the output of the XML writing operation.
//----------------------------------------------------------------------------------
VOID XMLWriter::Close()
{
    if( m_hFile != INVALID_HANDLE_VALUE )
    {
        FlushBufferToFile();
        CloseHandle( m_hFile );
        delete[] m_strBufferStart;
        m_strBufferStart = NULL;
        m_strBuffer = NULL;
        m_hFile = INVALID_HANDLE_VALUE;
    }
    if( m_strBuffer != NULL )
    {
        m_strBuffer = NULL;
        m_strBufferStart = NULL;
        m_uBufferSizeRemaining = 0;
    }
}


VOID XMLWriter::FlushBufferToFile()
{
    if( m_uBufferSizeRemaining >= WRITE_BUFFER_SIZE || m_hFile == INVALID_HANDLE_VALUE )
        return;
    DWORD dwBytesWritten = 0;
    WriteFile( m_hFile, m_strBufferStart, WRITE_BUFFER_SIZE - m_uBufferSizeRemaining, &dwBytesWritten, NULL );
    m_uBufferSizeRemaining = WRITE_BUFFER_SIZE;
    m_strBuffer = m_strBufferStart;
}


//----------------------------------------------------------------------------------
// Name: SetIndentCount
// Desc: Builds a string with the correct amount of indentation spaces.
//----------------------------------------------------------------------------------
VOID XMLWriter::SetIndentCount( UINT uSpaces )
{
    m_uIndentCount = ( uSpaces > 8 ) ? 8 : uSpaces;
    if( m_uIndentCount > 0 )
        memset( m_strIndent, ' ', m_uIndentCount );
    m_strIndent[ m_uIndentCount ] = '\0';
}


//----------------------------------------------------------------------------------
// Name: StartElement
// Desc: Writes the beginning of an XML open tag.
//----------------------------------------------------------------------------------
BOOL XMLWriter::StartElement( const CHAR* strName )
{
    if( !m_bOpenTagFinished )
    {
        if( !EndOpenTag() )
            return FALSE;
        if( !WriteNewline() )
            return FALSE;
    }
    BOOL result = TRUE;
    result &= WriteIndent();
    PushName( strName );
    result &= OutputStringFast( "<", 1 );
    result &= OutputString( strName );
    m_bOpenTagFinished = FALSE;
    m_bWriteCloseTagIndent = FALSE;
    return result;
}


//----------------------------------------------------------------------------------
// Name: EndElement
// Desc: Writes an element close tag corresponding with the most recent open tag.
//----------------------------------------------------------------------------------
BOOL XMLWriter::EndElement()
{
    const CHAR* strName = PopName();
    if( strName == NULL )
        return FALSE;
    BOOL result = TRUE;
    if( !m_bOpenTagFinished )
    {
        m_bOpenTagFinished = TRUE;
        result &= OutputStringFast( " />", 3 );
        result &= WriteNewline();
        m_bWriteCloseTagIndent = TRUE;
        return result;
    }
    if( m_bWriteCloseTagIndent )
        result &= WriteIndent();
    result &= OutputStringFast( "</", 2 );
    result &= OutputString( strName );
    result &= OutputStringFast( ">", 1 );
    result &= WriteNewline();
    m_bWriteCloseTagIndent = TRUE;
    return result;
}


//----------------------------------------------------------------------------------
// Name: WriteElement
// Desc: Convenience function to write an XML element with a body and no attributes.
//----------------------------------------------------------------------------------
BOOL XMLWriter::WriteElement( const CHAR* strName, const CHAR* strBody )
{
    BOOL result = TRUE;
    result &= StartElement( strName );
    result &= WriteString( strBody );
    result &= EndElement();
    return result;
}


//----------------------------------------------------------------------------------
// Name: WriteElement
// Desc: Convenience function to write an XML element with a body and no attributes.
//----------------------------------------------------------------------------------
BOOL XMLWriter::WriteElement( const CHAR* strName, INT iBody )
{
    BOOL result = TRUE;
    result &= StartElement( strName );
    CHAR strTemp[32];
    _itoa_s( iBody, strTemp, 10 );
    result &= WriteString( strTemp );
    result &= EndElement();
    return result;
}


//----------------------------------------------------------------------------------
// Name: WriteElement
// Desc: Convenience function to write an XML element with a body and no attributes.
//----------------------------------------------------------------------------------
BOOL XMLWriter::WriteElement( const CHAR* strName, FLOAT fBody )
{
    BOOL result = TRUE;
    result &= StartElement( strName );
    CHAR strTemp[32];
    sprintf_s( strTemp, "%f", fBody );
    result &= WriteString( strTemp );
    result &= EndElement();
    return result;
}


//----------------------------------------------------------------------------------
// Name: WriteElementFormat
// Desc: Convenience function to write an XML element with a body and no attributes.
//----------------------------------------------------------------------------------
BOOL XMLWriter::WriteElementFormat( const CHAR* strName, _In_z_ _Printf_format_string_ const CHAR* strFormat, ... )
{
    BOOL result = TRUE;
    result &= StartElement( strName );
    CHAR strTemp[512];
    va_list args;
    va_start( args, strFormat );
    vsprintf_s( strTemp, strFormat, args );
    result &= WriteString( strTemp );
    result &= EndElement();
    return result;
}


//----------------------------------------------------------------------------------
// Name: StartCDATA
// Desc: Starts a CDATA block.
//----------------------------------------------------------------------------------
BOOL XMLWriter::StartCDATA()
{
    BOOL bResult = TRUE;
    if( !m_bOpenTagFinished )
    {
        if( !EndOpenTag() )
            return FALSE;
        if( !WriteNewline() )
            return FALSE;
    }
    bResult &= WriteIndent();
    bResult &= OutputStringFast( "<![CDATA[", 9 );
    return bResult;
}


//----------------------------------------------------------------------------------
// Name: EndCDATA
// Desc: Ends a CDATA block.
//----------------------------------------------------------------------------------
BOOL XMLWriter::EndCDATA()
{
    BOOL bResult = TRUE;
    bResult &= OutputStringFast( "]]>", 3 );
    bResult &= WriteNewline();
    m_bWriteCloseTagIndent = TRUE;
    return bResult;
}


//----------------------------------------------------------------------------------
// Name: WriteCDATA
// Desc: Writes a CDATA block.
//----------------------------------------------------------------------------------
BOOL XMLWriter::WriteCDATA( const CHAR* strData, DWORD dwDataLength )
{
    BOOL bResult = StartCDATA();
    bResult &= OutputStringFast( strData, dwDataLength );
    bResult &= EndCDATA();
    return bResult;
}


//----------------------------------------------------------------------------------
// Name: StartComment
// Desc: Writes the beginning of an XML comment tag.
//----------------------------------------------------------------------------------
BOOL XMLWriter::StartComment( BOOL bInline )
{
    if( !m_bOpenTagFinished )
    {
        if( !EndOpenTag() )
            return FALSE;
        if( !bInline && !WriteNewline() )
            return FALSE;
    }
    BOOL result = TRUE;
    if( !bInline )
        result &= WriteIndent();
    result &= OutputStringFast( "<!-- ", 5 );
    m_bOpenTagFinished = TRUE;
    m_bWriteCloseTagIndent = FALSE;
    m_bInlineComment = bInline;
    return result;
}


//----------------------------------------------------------------------------------
// Name: EndComment
// Desc: Writes a comment close tag.
//----------------------------------------------------------------------------------
BOOL XMLWriter::EndComment()
{
    BOOL result = TRUE;
    result &= OutputStringFast( " -->", 4 );
    if( !m_bInlineComment )
        result &= WriteNewline();
    m_bWriteCloseTagIndent = !m_bInlineComment;
    return result;
}


//----------------------------------------------------------------------------------
// Name: WriteComment
// Desc: Convenience function to write an entire comment.
//----------------------------------------------------------------------------------
BOOL XMLWriter::WriteComment( const CHAR* strComment, BOOL bInline )
{
    BOOL result = TRUE;
    result &= StartComment( bInline );
    result &= WriteString( strComment );
    result &= EndComment();
    return result;
}


//----------------------------------------------------------------------------------
// Name: AddAttributeFormat
// Desc: Adds a key-value attribute pair to an XML open tag.  This must be called
//       after calling StartElement(), but before calling WriteString() or
//       EndElement().
//----------------------------------------------------------------------------------
BOOL XMLWriter::AddAttributeFormat( const CHAR* strName, _In_z_ _Printf_format_string_ const CHAR* strFormat, ... )
{
    if( m_bOpenTagFinished )
        return FALSE;
    BOOL result = TRUE;
    result &= OutputStringFast( " ", 1 );
    result &= OutputString( strName );
    result &= OutputStringFast( "=\"", 2 );
    CHAR strTemp[256];
    va_list args;
    va_start( args, strFormat );
    vsprintf_s( strTemp, strFormat, args );
    result &= OutputString( strTemp );
    result &= OutputStringFast( "\"", 1 );
    return result;
}


//----------------------------------------------------------------------------------
// Name: AddAttribute
// Desc: Adds a key-value attribute pair to an XML open tag.  This must be called
//       after calling StartElement(), but before calling WriteString() or
//       EndElement().
//----------------------------------------------------------------------------------
BOOL XMLWriter::AddAttribute( const CHAR* strName, const CHAR* strValue )
{
    if( m_bOpenTagFinished )
        return FALSE;
    BOOL result = TRUE;
    result &= OutputStringFast( " ", 1 );
    result &= OutputString( strName );
    result &= OutputStringFast( "=\"", 2 );
    result &= OutputString( strValue );
    result &= OutputStringFast( "\"", 1 );
    return result;
}


//----------------------------------------------------------------------------------
// Name: AddAttribute
// Desc: Adds a key-value attribute pair to an XML open tag.  This must be called
//       after calling StartElement(), but before calling WriteString() or
//       EndElement().
//----------------------------------------------------------------------------------
BOOL XMLWriter::AddAttribute( const CHAR* strName, const WCHAR* wstrValue )
{
    CHAR strTemp[256];
    WideCharToMultiByte( CP_ACP, 0, wstrValue, ( INT )wcslen( wstrValue ) + 1, strTemp, 256, NULL, NULL );
    return AddAttribute( strName, strTemp );
}


//----------------------------------------------------------------------------------
// Name: AddAttribute
// Desc: Adds a key-value attribute pair to an XML open tag.  This must be called
//       after calling StartElement(), but before calling WriteString() or
//       EndElement().
//----------------------------------------------------------------------------------
BOOL XMLWriter::AddAttribute( const CHAR* strName, INT iValue )
{
    CHAR strTemp[20];
    _itoa_s( iValue, strTemp, 10 );
    return AddAttribute( strName, strTemp );
}


//----------------------------------------------------------------------------------
// Name: AddAttribute
// Desc: Adds a key-value attribute pair to an XML open tag.  This must be called
//       after calling StartElement(), but before calling WriteString() or
//       EndElement().
//----------------------------------------------------------------------------------
BOOL XMLWriter::AddAttribute( const CHAR* strName, FLOAT fValue )
{
    CHAR strTemp[20];
    sprintf_s( strTemp, "%f", fValue );
    return AddAttribute( strName, strTemp );
}


//----------------------------------------------------------------------------------
// Name: WriteString
// Desc: Writes a string after an XML open tag.
//----------------------------------------------------------------------------------
BOOL XMLWriter::WriteString( const CHAR* strText )
{
    if( strText == NULL )
        strText = "";
    if( !m_bOpenTagFinished )
    {
        if( !EndOpenTag() )
            return FALSE;
    }
    return OutputString( strText );
}


//----------------------------------------------------------------------------------
// Name: WriteStringFormat
// Desc: Writes a formatted string after an XML open tag.
//----------------------------------------------------------------------------------
BOOL XMLWriter::WriteStringFormat( _In_z_ _Printf_format_string_ const CHAR* strFormat, ... )
{
    if( !m_bOpenTagFinished )
    {
        if( !EndOpenTag() )
            return FALSE;
    }
    CHAR strTemp[1024];
    va_list args;
    va_start( args, strFormat );
    vsprintf_s( strTemp, strFormat, args );
    return OutputString( strTemp );
}


//----------------------------------------------------------------------------------
// Name: EndOpenTag
// Desc: Writes the closing angle bracket of an XML open tag, and sets the proper
//       state.
//----------------------------------------------------------------------------------
BOOL XMLWriter::EndOpenTag()
{
    assert( !m_bOpenTagFinished );
    OutputStringFast( ">", 1 );
    m_bOpenTagFinished = TRUE;
    return TRUE;
}


//----------------------------------------------------------------------------------
// Name: WriteNewline
// Desc: Writes a new line, if that option is enabled.  Writes a hard return to
//       files, and a soft return to buffers.
//----------------------------------------------------------------------------------
BOOL XMLWriter::WriteNewline()
{
    if( !m_bWriteNewlines )
        return TRUE;
    if( m_hFile != INVALID_HANDLE_VALUE )
        return OutputStringFast( "\r\n", 2 );
    return OutputStringFast( "\n", 1 );
}


//----------------------------------------------------------------------------------
// Name: WriteIndent
// Desc: Writes an indentation using spaces if indentation is enabled.
//----------------------------------------------------------------------------------
BOOL XMLWriter::WriteIndent()
{
    if( m_uIndentCount == 0 )
        return TRUE;
    for( UINT i = 0; i < m_NameStackPositions.size(); i++ )
    {
        if( !OutputStringFast( m_strIndent, m_uIndentCount ) )
            return FALSE;
    }
    return TRUE;
}


//----------------------------------------------------------------------------------
// Name: PushName
// Desc: Pushes an XML tag name onto the stack.  This is used to write an open tag.
//----------------------------------------------------------------------------------
VOID XMLWriter::PushName( const CHAR* strName )
{
    UINT uLen = ( UINT )strlen( strName );
    if( ( m_strNameStackTop - m_strNameStack + uLen ) >= XMLWRITER_NAME_STACK_SIZE )
    {
        assert( false );
        return;
    }
    m_NameStackPositions.push_back( ( UINT )( m_strNameStackTop - m_strNameStack ) );
    DWORD dwBufSize = ARRAYSIZE( m_strNameStack ) - ( m_strNameStackTop - m_strNameStack );
    strcpy_s( m_strNameStackTop, dwBufSize, strName );
    m_strNameStackTop += uLen;
}


//----------------------------------------------------------------------------------
// Name: PopName
// Desc: Pops an XML tag name off the stack.  This is used to write a close tag.
//----------------------------------------------------------------------------------
const CHAR* XMLWriter::PopName()
{
    if( m_NameStackPositions.size() == 0 )
        return NULL;
    UINT uPos = m_NameStackPositions.back();
    m_NameStackPositions.pop_back();
    *m_strNameStackTop = '\0';
    m_strNameStackTop = m_strNameStack + uPos;
    return m_strNameStackTop;
}


//----------------------------------------------------------------------------------
// Name: OutputString
// Desc: Sends a null-terminated string to the output.
//----------------------------------------------------------------------------------
BOOL XMLWriter::OutputString( const CHAR* strText )
{
    assert( strText != NULL );
    return OutputStringFast( strText, ( UINT )strlen( strText ) );
}


//----------------------------------------------------------------------------------
// Name: OutputStringFast
// Desc: Sends a string with a supplied length to the output.
//----------------------------------------------------------------------------------
BOOL XMLWriter::OutputStringFast( const CHAR* strText, UINT uLength )
{
    if( m_hFile != INVALID_HANDLE_VALUE )
    {
        while( uLength >= m_uBufferSizeRemaining )
        {
            memcpy( m_strBuffer, strText, m_uBufferSizeRemaining );
            m_strBuffer += m_uBufferSizeRemaining;
            strText += m_uBufferSizeRemaining;
            uLength -= m_uBufferSizeRemaining;
            m_uBufferSizeRemaining = 0;
            FlushBufferToFile();
        }
        memcpy( m_strBuffer, strText, uLength );
        m_uBufferSizeRemaining -= uLength;
        m_strBuffer += uLength;
        return TRUE;
    }
    else if( m_strBuffer != NULL )
    {
        if( ( uLength + 1 ) > m_uBufferSizeRemaining )
            return FALSE;
        memcpy( m_strBuffer, strText, uLength + 1 );
        m_uBufferSizeRemaining -= uLength;
        m_strBuffer += uLength;
        return TRUE;
    }
    return FALSE;
}

} // namespace ATG

```

`XenonDumper/libs/Atg/AtgXmlWriter.h`:

```h
//-------------------------------------------------------------------------------------
//  AtgXmlWriter.h
//  
//  A simple XML writer.
//  
//  Xbox Advanced Technology Group
//  Copyright (C) Microsoft Corporation. All rights reserved.
//-------------------------------------------------------------------------------------

#pragma once
#ifndef ATGXMLWRITER_H
#define ATGXMLWRITER_H

#include <vector>
#include <xtl.h>

namespace ATG
{

#define XMLWRITER_NAME_STACK_SIZE 255

class XMLWriter
{
public:
                XMLWriter();
                XMLWriter( CHAR* strBuffer, UINT uBufferSize );
                XMLWriter( const CHAR* strFileName );
                ~XMLWriter();

    VOID        Initialize( CHAR* strBuffer, UINT uBufferSize );
    VOID        Initialize( const CHAR* strFileName );
    VOID        Close();

    VOID        SetIndentCount( UINT uSpaces );
    VOID        EnableNewlines( BOOL bWriteNewLines )
    {
        m_bWriteNewlines = bWriteNewLines;
    }

    BOOL        StartElement( const CHAR* strName );
    BOOL        EndElement();
    BOOL        WriteElement( const CHAR* strName, const CHAR* strBody );
    BOOL        WriteElement( const CHAR* strName, INT iBody );
    BOOL        WriteElement( const CHAR* strName, FLOAT fBody );
    BOOL        WriteElementFormat( const CHAR* strName, _In_z_ _Printf_format_string_ const CHAR* strFormat, ... );

    BOOL        StartCDATA();
    BOOL        EndCDATA();
    BOOL        WriteCDATA( const CHAR* strData, DWORD dwDataLength );

    BOOL        StartComment( BOOL bInline = FALSE );
    BOOL        EndComment();
    BOOL        WriteComment( const CHAR* strComment, BOOL bInline = FALSE );

    BOOL        AddAttributeFormat( const CHAR* strName, _In_z_ _Printf_format_string_ const CHAR* strFormat, ... );
    BOOL        AddAttribute( const CHAR* strName, const CHAR* strValue );
    BOOL        AddAttribute( const CHAR* strName, const WCHAR* wstrValue );
    BOOL        AddAttribute( const CHAR* strName, INT iValue );
    BOOL        AddAttribute( const CHAR* strName, FLOAT fValue );

    BOOL        WriteString( const CHAR* strText );
    BOOL        WriteStringFormat( _In_z_ _Printf_format_string_ const CHAR* strFormat, ... );

private:

    VOID        PushName( const CHAR* strName );
    const CHAR* PopName();

    inline BOOL EndOpenTag();
    inline BOOL WriteNewline();
    inline BOOL WriteIndent();

    inline BOOL OutputString( const CHAR* strText );
    inline BOOL OutputStringFast( const CHAR* strText, UINT uLength );
    VOID FlushBufferToFile();

    HANDLE          m_hFile;
    CHAR*           m_strBuffer;
    CHAR*           m_strBufferStart;
    UINT            m_uBufferSizeRemaining;

    CHAR            m_strNameStack[XMLWRITER_NAME_STACK_SIZE];
    CHAR*           m_strNameStackTop;
    UINT            m_uNameStackSize;
    std::vector<UINT>    m_NameStackPositions;
    UINT            m_uIndentCount;
    CHAR            m_strIndent[9];
    BOOL            m_bWriteNewlines;

    BOOL            m_bOpenTagFinished;
    BOOL            m_bWriteCloseTagIndent;
    BOOL            m_bInlineComment;
};

} // namespace ATG

#endif

```

`XenonDumper/libs/Atg/XTLOnPC.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// XTLOnPC.cpp
//
// This module contains functions that allow most of the samples framework to compile
// on Windows using the Win32 XDK libraries.
//
// Some of the XTL memory functions are implemented here since the XTL libraries are
// not implemented in the Win32 XDK libraries.
//
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#include "stdafx.h"
#include <stdio.h>

#ifdef _PC

LPVOID
WINAPI
XPhysicalAlloc(
               SIZE_T                      dwSize,
               ULONG_PTR                   ulPhysicalAddress,
               ULONG_PTR                   ulAlignment,
               DWORD                       flProtect
               )
{
    DWORD vaProtect = 0;

    if (flProtect & PAGE_READONLY)
        vaProtect = PAGE_READONLY;
    else if (flProtect & PAGE_READWRITE)
        vaProtect = PAGE_READWRITE;
    else
        return NULL;

    // Always 4K aligned
    return VirtualAlloc( NULL, dwSize, MEM_COMMIT, vaProtect );
}

VOID
WINAPI
XPhysicalFree(
              LPVOID                      lpAddress
              )
{
    VirtualFree( lpAddress, 0, MEM_RELEASE );
}

LPVOID
WINAPI
XMemAlloc(
          SIZE_T                      dwSize,
          DWORD                       dwAllocAttributes
          )
{
    const PXALLOC_ATTRIBUTES alloc = (PXALLOC_ATTRIBUTES)(&dwAllocAttributes);   

    void *ptr = NULL;

    if ( alloc->dwMemoryType ==  XALLOC_MEMTYPE_HEAP)
    {
        size_t align = 16;

        switch ( alloc->dwAlignment )
        {
        case XALLOC_ALIGNMENT_DEFAULT:
        case XALLOC_ALIGNMENT_16:
            break;
    
        case XALLOC_ALIGNMENT_4:
            align = 4;
            break;
        
        case XALLOC_ALIGNMENT_8:
            align = 8;
            break;
        }

        ptr = _aligned_malloc( dwSize, align );
    }
    else if ( alloc->dwMemoryType == XALLOC_MEMTYPE_PHYSICAL )
    {
        // Always 4K aligned, which works for everything except XALLOC_PHYSICAL_ALIGNMENT_8K, _16K, and _32K
        ptr = VirtualAlloc( NULL, dwSize, MEM_COMMIT, PAGE_READWRITE );
    }

    if (ptr && alloc->dwZeroInitialize )
    {
        memset( ptr, 0, dwSize );
    }

    return ptr;
}

VOID
WINAPI
XMemFree(
         PVOID                       pAddress,
         DWORD                       dwAllocAttributes
         )
{
    if ( !pAddress )
        return;

    const PXALLOC_ATTRIBUTES alloc = (PXALLOC_ATTRIBUTES)(&dwAllocAttributes);

    if ( alloc->dwMemoryType ==  XALLOC_MEMTYPE_HEAP)
    {
        _aligned_free( pAddress );
    }
    else if ( alloc->dwMemoryType == XALLOC_MEMTYPE_PHYSICAL )
    {
        VirtualFree( pAddress, 0, MEM_RELEASE );
    }
}

VOID
WINAPI
XGetVideoMode(
              PXVIDEO_MODE                pVideoMode
              )
{
    // This requires knowing the device, access to DXGI, and other video parameters. For Windows we just return zero data for simplicity
    ZeroMemory( pVideoMode, sizeof( XVIDEO_MODE ) );
}

#endif // ifdef _PC

```

`XenonDumper/libs/Atg/XTLOnPC.h`:

```h
//--------------------------------------------------------------------------------------
// XTLOnPC.h
//
// This module contains functions that allow most of the samples framework to compile
// on Windows using the Win32 XDK libraries.
//
// Some of the XTL memory functions are implemented here since the XTL libraries are
// not implemented in the Win32 XDK libraries.
//
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#pragma once
#ifndef XTLONPC_H
#define XTLONPC_H

#ifdef _PC

#include <sal.h>

#define XMemCpy memcpy
#define XMemSet memset

LPVOID
WINAPI
XPhysicalAlloc(
               __in SIZE_T                      dwSize,
               __in_opt ULONG_PTR               ulPhysicalAddress,
               __in_opt ULONG_PTR               ulAlignment,
               __in DWORD                       flProtect
               );

VOID
WINAPI
XPhysicalFree(
              __in  LPVOID                      lpAddress
              );

LPVOID
WINAPI
XMemAlloc(
          __in    SIZE_T                      dwSize,
          __in    DWORD                       dwAllocAttributes
          );

VOID
WINAPI
XMemFree(
         __in_opt  PVOID                      pAddress,
         __in      DWORD                      dwAllocAttributes
         );

#define XALLOC_MEMTYPE_HEAP                         0
#define XALLOC_MEMTYPE_PHYSICAL                     1

#define XALLOC_MEMPROTECT_WRITECOMBINE_LARGE_PAGES  0
#define XALLOC_MEMPROTECT_NOCACHE                   1
#define XALLOC_MEMPROTECT_READWRITE                 2
#define XALLOC_MEMPROTECT_WRITECOMBINE              3

#define XALLOC_ALIGNMENT_DEFAULT                    0x0
#define XALLOC_ALIGNMENT_4                          0x1
#define XALLOC_ALIGNMENT_8                          0x2
#define XALLOC_ALIGNMENT_16                         0x4

#define XALLOC_PHYSICAL_ALIGNMENT_DEFAULT           0x0 // Default is 4K alignment
#define XALLOC_PHYSICAL_ALIGNMENT_4                 0x2
#define XALLOC_PHYSICAL_ALIGNMENT_8                 0x3
#define XALLOC_PHYSICAL_ALIGNMENT_16                0x4
#define XALLOC_PHYSICAL_ALIGNMENT_32                0x5
#define XALLOC_PHYSICAL_ALIGNMENT_64                0x6
#define XALLOC_PHYSICAL_ALIGNMENT_128               0x7
#define XALLOC_PHYSICAL_ALIGNMENT_256               0x8
#define XALLOC_PHYSICAL_ALIGNMENT_512               0x9
#define XALLOC_PHYSICAL_ALIGNMENT_1K                0xA
#define XALLOC_PHYSICAL_ALIGNMENT_2K                0xB
#define XALLOC_PHYSICAL_ALIGNMENT_4K                0xC
#define XALLOC_PHYSICAL_ALIGNMENT_8K                0xD
#define XALLOC_PHYSICAL_ALIGNMENT_16K               0xE
#define XALLOC_PHYSICAL_ALIGNMENT_32K               0xF

typedef enum _XALLOC_ALLOCATOR_IDS
{
    eXALLOCAllocatorId_GameMin = 0,
    eXALLOCAllocatorId_GameMax = 127,
    eXALLOCAllocatorId_MsReservedMin = 128,
    eXALLOCAllocatorId_D3D = 128,
    eXALLOCAllocatorId_D3DX,
    eXALLOCAllocatorId_XAUDIO,
    eXALLOCAllocatorId_XAPI,
    eXALLOCAllocatorId_XACT,
    eXALLOCAllocatorId_XBOXKERNEL,
    eXALLOCAllocatorId_XBDM,
    eXALLOCAllocatorId_XGRAPHICS,
    eXALLOCAllocatorId_XONLINE,
    eXALLOCAllocatorId_XVOICE,
    eXALLOCAllocatorId_XHV,
    eXALLOCAllocatorId_USB,
    eXALLOCAllocatorId_XMV,
    eXALLOCAllocatorId_SHADERCOMPILER,
    eXALLOCAllocatorId_XUI,
    eXALLOCAllocatorId_XASYNC,
    eXALLOCAllocatorId_XCAM,
    eXALLOCAllocatorId_XVIS,
    eXALLOCAllocatorId_XIME,
    eXALLOCAllocatorId_XFILECACHE,
    eXALLOCAllocatorId_XRN,
    eXALLOCAllocatorId_MsReservedMax = 191,
    eXALLOCAllocatorId_MiddlewareReservedMin = 192,
    eXALLOCAllocatorId_MiddlewareReservedMax = 255,
} XALLOC_ALLOCATOR_IDS;

#if defined(_M_PPCBE)
#pragma bitfield_order(push)
#pragma bitfield_order(lsb_to_msb)
#endif

typedef struct _XALLOC_ATTRIBUTES {
    DWORD                               dwObjectType:13;
    DWORD                               dwHeapTracksAttributes:1;
    DWORD                               dwMustSucceed:1;
    DWORD                               dwFixedSize:1;
    DWORD                               dwAllocatorId:8;
    DWORD                               dwAlignment:4;
    DWORD                               dwMemoryProtect:2;
    DWORD                               dwZeroInitialize:1;
    DWORD                               dwMemoryType:1;
} XALLOC_ATTRIBUTES, *PXALLOC_ATTRIBUTES;

#if defined(_M_PPCBE)
#pragma bitfield_order(pop)
#endif

#define MAKE_XALLOC_ATTRIBUTES(ObjectType,\
    HeapTracksAttributes,\
    MustSucceed,\
    FixedSize,\
    AllocatorId,\
    Alignment,\
    MemoryProtect,\
    ZeroInitialize,\
    MemoryType)\
    ((DWORD)( ObjectType | \
    (HeapTracksAttributes << 13) | \
    (MustSucceed << 14) | \
    (FixedSize << 15) | \
    (AllocatorId << 16) | \
    (Alignment << 24) | \
    (MemoryProtect << 28) | \
    (ZeroInitialize << 30) | \
    (MemoryType << 31)))

#define XALLOC_IS_PHYSICAL(Attributes)  ((BOOL)(Attributes & 0x80000000)!=0)

typedef struct _XVIDEO_MODE {
    DWORD                               dwDisplayWidth;
    DWORD                               dwDisplayHeight;
    BOOL                                fIsInterlaced;
    BOOL                                fIsWideScreen;
    BOOL                                fIsHiDef;
    float                               RefreshRate;
    DWORD                               VideoStandard;
    DWORD                               Reserved[5];
} XVIDEO_MODE, *PXVIDEO_MODE;

#define XC_VIDEO_STANDARD_NTSC_M        1
#define XC_VIDEO_STANDARD_NTSC_J        2
#define XC_VIDEO_STANDARD_PAL_I         3

VOID
WINAPI
XGetVideoMode(
              __out PXVIDEO_MODE                pVideoMode
              );

#endif // ifdef _PC

#endif // XTLONPC_H

```

`XenonDumper/libs/Atg/stdafx.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// stdafx.cpp
//
// This will create a .pch file which will let other source files compile faster.
//
// All other source files must include "stdafx.h" as the first line of non-comment code.
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#include "stdafx.h"

```

`XenonDumper/libs/Atg/stdafx.h`:

```h
//--------------------------------------------------------------------------------------
// stdafx.h
//
// This is a good place to include commonly used header files that rarely change, in
// order to speed up build times.
//
// Xbox Advanced Technology Group.
// Copyright (C) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#ifndef ATGFRAMEWORK_STDAFX_H

#ifdef _XBOX

#include <xtl.h>
#include <ppcintrinsics.h>

#endif // _XBOX

#ifdef _PC

#include <windows.h>
#include <d3d9.h>
#include <d3dx9.h>
#pragma warning(disable:4100)

#include "XTLOnPC.h"

#endif // _PC

#include <xgraphics.h>
#include <xboxmath.h>
#include <stdio.h>
#include <stdarg.h>
#include <assert.h>

// C4127: conditional expression is constant
#pragma warning(disable:4127)

#endif

```

`XenonDumper/libs/xkelib/Release21256.0/xkelib.lastbuildstate`:

```lastbuildstate
#v4.0:2010-01:false
Release21256.0|Xbox 360|C:\Users\Byrom\Desktop\Projects\Xbox_360\GitHub_Public\XenonDumper\|

```

`XenonDumper/libs/xkelib/_tools/_readme.txt`:

```txt
load kernel and xam modules from the symsrv directory in ida against symbols
	- simply place the exe/dll beside the matching .pdb and load the exe/dll with default options with ida, let it load symbols

use the included .idc script to list the exports
	- right click on message window and clear it
	- file -> script -> choose the idc

copy and paste the kernel exports into a file called kernel.def
	- right click on message window, select all, and copy
copy and paste the xam exports into a file called xam.def beside deffix.exe and _runit.bat
	- right click on message window, select all, and copy, paste into a new text file

run _runit.bat

profit, xam.def and kernel.def will now have all functions findable through libdump and sdk libraries commented out
as well as the library version string added directly from the libdump info to the .def header, as well as any manually
added function in manuals_xam.txt. Set up a new target and rename the files accordingly.


```

`XenonDumper/libs/xkelib/_tools/_runit.bat`:

```bat
@echo off

call dump_libheader.bat

if not exist xam.def goto NOXAMDEF
call .\deffix.exe xam.def manuals_xam.txt xam.def
call .\deffix.exe xam.def xav_xam.txt xam.def
call .\deffix.exe xam.def xapi_xam.txt xam.def
goto DOKERNEL
:NOXAMDEF
echo.
echo ERROR! xam.def was not found!

:DOKERNEL
if not exist kernel.def goto NOKERNELDEF
call .\deffix.exe kernel.def xboxkrnl.txt kernel.def
goto EXIT

:NOKERNELDEF
echo.
echo ERROR! kernel.def was not found!

:EXIT
if not exist xapi_xam.txt goto NOTXT1
del /f /q xapi_xam.txt
:NOTXT1
if not exist xav_xam.txt goto NOTXT2
del /f /q xav_xam.txt
:NOTXT2
if not exist xboxkrnl.txt goto NOTXT3
del /f /q xboxkrnl.txt
:NOTXT3
echo.
echo.
echo Done!
pause
exit

```

`XenonDumper/libs/xkelib/_tools/deffix/deffix.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 11.00
# Visual Studio 2010
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "deffix", "deffix\deffix.vcxproj", "{0491C63D-9958-4AAE-8321-0CE2CA735095}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Release|Win32 = Release|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{0491C63D-9958-4AAE-8321-0CE2CA735095}.Debug|Win32.ActiveCfg = Debug|Win32
		{0491C63D-9958-4AAE-8321-0CE2CA735095}.Debug|Win32.Build.0 = Debug|Win32
		{0491C63D-9958-4AAE-8321-0CE2CA735095}.Release|Win32.ActiveCfg = Release|Win32
		{0491C63D-9958-4AAE-8321-0CE2CA735095}.Release|Win32.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`XenonDumper/libs/xkelib/_tools/deffix/deffix/deffix.cpp`:

```cpp
#include "stdafx.h"
#include "util.h"

#define MAX_LINE_SIZE 1024

typedef struct _ITEM_LIST{
	string name;
	DWORD ordinal;
	BOOL disable;
} ITEM_LIST, *PITEM_LIST;

vector<ITEM_LIST> g_items;
vector<string> g_txt;
DWORD deflen, listlen;
BYTE* deffile;
BYTE* listfile;
BOOL hasLibName = FALSE;
string libname;

void usage(void)
{
	printf("command line error, usage:\n");
	printf("deffix infile.def infile.txt outfile\n\n");
}

DWORD getLine(BYTE* data, char* line)
{
	DWORD cnt;
	for(cnt = 0; cnt < MAX_LINE_SIZE; cnt++)
	{
		if((data[cnt] != 0xd)&&(data[cnt] != 0xa)&&(data[cnt+1] != 0x0))
			line[cnt] = (char)data[cnt];
		else
		{
			line[cnt] = 0;
			if((data[cnt+1] == 0xd)||(data[cnt+1] == 0xa)||(data[cnt+1] == 0x0))
				return (cnt+2);
			else
				return cnt+1;
		}
	}
	return 0;
}

void parseDefLine(char* line, int len)
{
	int ps, ps2, curr = 0;
	ITEM_LIST itm;
	string name;
	string ord;
	itm.disable = FALSE;
	if((_strnicmp(line, "LIBRARY", strlen("LIBRARY")) == 0)||(strnicmp(line, "EXPORTS", strlen("EXPORTS")) == 0))
	{
		//printf("skipping LIBRARY/EXPORTS line\n");
		return;
	}
	// remove spaces, tabs and @
	if(line[curr] == ';')
	{
		itm.disable = TRUE;
		curr++;
	}
	if(line[curr] == '\t')
		curr++;
	name = &line[curr];
	ps = name.find_last_of('@',-1);
	ps2 = name.find_first_of('@', 0);
	ord = name.substr(ps+1);
	itm.ordinal = atoi(ord.c_str());
	itm.name = name.substr(0, ps-1);
	if(ps != ps2)
		itm.disable = TRUE;
	//printf("name: %s ordinal: %d disable: %d\n", itm.name.c_str(), itm.ordinal, itm.disable);
	g_items.push_back(itm);
}

void parseTxtLine(char* line, int len)
{
	if(strnicmp(line, "  Symbol name  : ", strlen("  Symbol name  : ")) == 0)
	{
		BOOL demangle = FALSE;
		int pos = strlen("  Symbol name  : ");
		if(line[pos] == '?')
		{
			pos++;
			demangle = TRUE;
		}
		string txt = &line[pos];
		if(demangle)
		{
			int ps = txt.find_first_of('@',0);
			if(ps != -1)
				txt.resize(ps);
		}
		//printf("txt: %s\n", txt.c_str());
		g_txt.push_back(txt);
	}
	else if(!hasLibName)
	{
		if(strnicmp(line, "  DLL name     : ", strlen("  DLL name     : ")) == 0)
			libname = &line[strlen("  DLL name     : ")];
	}
}

void parseDef(void)
{
	DWORD curr = 0, len;
	char line[MAX_LINE_SIZE];
	g_items.clear();
	while(curr < deflen)
	{
		len = getLine(&deffile[curr], line);
// 		printf("line (len %d): %s\n", len, line);
		parseDefLine(line, strlen(line));
		curr+=len;
	}
}

void parseTxt(void)
{
	DWORD curr = 0, len;
	char line[MAX_LINE_SIZE];
	g_txt.clear();
	while(curr < listlen)
	{
		len = getLine(&listfile[curr], line);
//		printf("line (len %d): %s\n", len, line);
		parseTxtLine(line, strlen(line));
		curr+=len;
	}
}

BOOL checkTxtItem(string targ)
{
	DWORD i;
	for(i = 0; i < g_txt.size(); i++)
	{
		if(g_txt.at(i).compare(targ) == 0)
			return TRUE;
	}
	return FALSE;
}

void checkTxt(void)
{
	DWORD i;
	for(i = 0; i < g_items.size(); i++)
	{
		if(checkTxtItem(g_items.at(i).name))
			g_items.at(i).disable = TRUE;
	}
}

int writeOutput(WCHAR* outname)
{
	int cnt = 0;
	HANDLE ofile;
	DeleteFileW(outname);
	ofile = CreateFileW(outname, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if(ofile != INVALID_HANDLE_VALUE)
	{
		char line[MAX_LINE_SIZE];
		DWORD i, bWrote;
		sprintf(line, "LIBRARY %s\n", libname.c_str());
		WriteFile(ofile, line, strlen(line), &bWrote, NULL);
		sprintf(line, "EXPORTS\n");
		WriteFile(ofile, line, strlen(line), &bWrote, NULL);
		for(i = 0; i < g_items.size(); i++)
		{
			if(g_items.at(i).disable)
			{
				sprintf(line, ";\t%s @%d\n", g_items.at(i).name.c_str(), g_items.at(i).ordinal);
				WriteFile(ofile, line, strlen(line), &bWrote, NULL);
				cnt++;
			}
			else
			{
				sprintf(line, "\t%s @%d\n", g_items.at(i).name.c_str(), g_items.at(i).ordinal);
				WriteFile(ofile, line, strlen(line), &bWrote, NULL);
			}
		}
		CloseHandle(ofile);
	}
	else
		printf("error opening %S for writing!\n", outname);
	return cnt;
}

void processFiles(WCHAR* outname)
{
	int tally;
	// parse def info into vector
	printf("parsing def...");
	parseDef();
	printf("done! %d items found.\nparsing txt...", g_items.size());
	parseTxt();
	printf("done! %d items found.\n", g_txt.size());
	// iterate vector to find and mark disabled instances in infile.txt
	printf("tidying things up...\n");
	checkTxt();
	printf("writing result to %S...", outname);
	tally = writeOutput(outname);
	printf("Done!\n%d of %d items were commented out\n", tally, g_items.size());
}

int _tmain(int argc, _TCHAR* argv[])
{
	//int i;
	//printf("argc: %d\n", argc);
	//for(i = 0; i < argc; i++)
	//	printf("arg %d: %S\n", i, argv[i]);
	if(argc != 4)
		usage();
	printf("reading %S to buffer...", argv[1]);
	deffile = loadFileToBuf(argv[1], &deflen);
	if((deffile != NULL)&&(deflen != 0))
	{
		printf("read 0x%x bytes OK\n", deflen);
		printf("reading %S to buffer...", argv[2]);
		listfile = loadFileToBuf(argv[2], &listlen);
		if((listfile != NULL)&&(listlen != 0))
		{
			printf("read 0x%x bytes OK\n", listlen);
			processFiles(argv[3]);
		}
	}
	if(deffile)
		free(deffile);
	if(listfile)
		free(listfile);
	printf("\n\n");
	return 0;
}

```

`XenonDumper/libs/xkelib/_tools/deffix/deffix/deffix.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="deffix.cpp" />
    <ClCompile Include="stdafx.cpp" />
    <ClCompile Include="util.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="types.h" />
    <ClInclude Include="util.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{0491C63D-9958-4AAE-8321-0CE2CA735095}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>deffix</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <DisableSpecificWarnings>4996</DisableSpecificWarnings>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <DisableSpecificWarnings>4996</DisableSpecificWarnings>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`XenonDumper/libs/xkelib/_tools/deffix/deffix/deffix.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="deffix.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="util.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="types.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`XenonDumper/libs/xkelib/_tools/deffix/deffix/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// deffix.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`XenonDumper/libs/xkelib/_tools/deffix/deffix/stdafx.h`:

```h
#pragma once

#include <SDKDDKVer.h>
#include <Windows.h>
#include <stdio.h>
#include <tchar.h>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

#include "types.h"

```

`XenonDumper/libs/xkelib/_tools/deffix/deffix/types.h`:

```h
#ifndef _TYPES_H
#define _TYPES_H

#ifndef _MSC_VER
	#define _fseeki64 fseeko64
	#define _ftelli64 ftello64
#endif

#define u16Rev(x) (((x&0xFF)<<8)+(((x&0xFF00)>>8)))
#define u32Rev(x) ((((x&0xFF)<<24))+(((x&0xFF00)<<8))+(((x&0xFF0000)>>8))+(((x&0xFF000000)>>24)))
#define u64Rev(x) (((x&0xFF)<<56)+((x&0xFF00)<<40)+((x&0xFF0000)<<24)+((x&0xFF000000)<<8)+((x>>8)&0xFF000000)+((x>>24)&0xFF0000)+((x>>40)&0xFF00)+((x>>56)&0xFF))
#define bswap32(x) u32Rev(x)
#define bswap16(x) u16Rev(x)

typedef unsigned char		u8;
typedef unsigned short		u16;
typedef unsigned int		u32;
typedef unsigned long long	u64, QWORD, *PQWORD;
typedef char				s8;
typedef short				s16;
typedef int					s32;
typedef long long			s64;
typedef int                 BOOL;


#endif // _TYPES_H

```

`XenonDumper/libs/xkelib/_tools/deffix/deffix/util.cpp`:

```cpp
#include "stdafx.h"

BYTE* doReadFile(HANDLE fhand, PDWORD len)
{
	DWORD rlen;
	*len = 0;
	rlen = GetFileSize(fhand, NULL);
	if(rlen != 0)
	{
		BYTE* buf = (BYTE*)malloc(rlen+1);
		if(buf != NULL)
		{
			DWORD bRead;
			ZeroMemory(buf, rlen+1);
			if(ReadFile(fhand, buf, rlen, &bRead, NULL))
			{
				*len = bRead;
				CloseHandle(fhand);
				return buf;
			}
			else
				printf("ReadFile error! %d\n", GetLastError());
			free(buf);
		}
		else
			printf("error allocating buffer for file!\n");
	}
	else
		printf("file size is zero!\n");
	CloseHandle(fhand);
	return NULL;
}

BYTE* loadFileToBuf(char* fname, PDWORD len)
{
	if((fname != NULL)&&(len != NULL))
	{
		HANDLE fhand;
		fhand = CreateFileA(fname, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if(fhand != INVALID_HANDLE_VALUE)
		{
			return doReadFile(fhand, len);
		}
		else
			printf("error opening %s for read!\n", fname);
	}
	else
		printf("error, loadfile called with incorrect args!\n");
	return NULL;
}

BYTE* loadFileToBuf(WCHAR* fname, PDWORD len)
{
	if((fname != NULL)&&(len != NULL))
	{
		HANDLE fhand;
		fhand = CreateFileW(fname, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if(fhand != INVALID_HANDLE_VALUE)
		{
			return doReadFile(fhand, len);
		}
		else
			printf("error opening %S for read!\n", fname);
	}
	else
		printf("error, loadfile called with incorrect args!\n");
	return NULL;
}

```

`XenonDumper/libs/xkelib/_tools/deffix/deffix/util.h`:

```h
#pragma once

BYTE* loadFileToBuf(char* fname, PDWORD len);
BYTE* loadFileToBuf(WCHAR* fname, PDWORD len);

```

`XenonDumper/libs/xkelib/_tools/dump_libheader.bat`:

```bat
@echo off
setlocal
if not exist "C:\Program Files (x86)\Microsoft Xbox 360 SDK\bin\win32\dumpbin.exe" goto DUMPBIN2
set DUMPBIN="C:\Program Files (x86)\Microsoft Xbox 360 SDK\bin\win32\dumpbin.exe"
set XBOXKRNL="C:\Program Files (x86)\Microsoft Xbox 360 SDK\lib\xbox\xboxkrnl.lib"
set XAPI="C:\Program Files (x86)\Microsoft Xbox 360 SDK\lib\xbox\xapilib.lib"
set XAV="C:\Program Files (x86)\Microsoft Xbox 360 SDK\lib\xbox\xav.lib"
goto START
:DUMPBIN2
if not exist "C:\Program Files\Microsoft Xbox 360 SDK\bin\win32\dumpbin.exe" goto NODUMPBIN
set DUMPBIN="C:\Program Files\Microsoft Xbox 360 SDK\bin\win32\dumpbin.exe"
set XBOXKRNL="C:\Program Files\Microsoft Xbox 360 SDK\lib\xbox\xboxkrnl.lib"
set XAPI="C:\Program Files\Microsoft Xbox 360 SDK\lib\xbox\xapilib.lib"
set XAV="C:\Program Files\Microsoft Xbox 360 SDK\lib\xbox\xav.lib"

:START
if not exist "%~1" goto NOFILE
echo dumping "%~1"
echo .
echo %DUMPBIN% /headers /OUT:"%~dp0%~n1.txt" "%~1"
%DUMPBIN% /headers /OUT:"%~dp0%~n1.txt" "%~1"
echo Done!
goto EXIT

:NOFILE
echo arguement not supplied, dumping xboxkrnl.lib and xapi.lib headers
echo.
if not exist %XAPI% goto NOXAPI
echo %DUMPBIN% /headers /OUT:"%~dp0xapi_xam.txt" %XAPI%
%DUMPBIN% /headers /OUT:"%~dp0xapi_xam.txt" %XAPI%
echo.
echo.
:NOXAPI
if not exist %XBOXKRNL% goto NOKRNL
echo %DUMPBIN% /headers /OUT:"%~dp0xboxkrnl.txt" %XBOXKRNL%
%DUMPBIN% /headers /OUT:"%~dp0xboxkrnl.txt" %XBOXKRNL%
echo.
echo.
:NOKRNL
if not exist %XAV% goto NOKRNL
echo %DUMPBIN% /headers /OUT:"%~dp0xav_xam.txt" %XAV%
%DUMPBIN% /headers /OUT:"%~dp0xav_xam.txt" %XAV%

:NOXAV
echo Done!
goto EXIT

:NODUMPBIN
echo ERROR! could not find sdk dumpbin.exe

:EXIT
echo.
echo.
endlocal
REM pause
REM exit

```

`XenonDumper/libs/xkelib/_tools/dump_libheader_multidrop.bat`:

```bat
@echo off
setlocal
if not exist "C:\Program Files (x86)\Microsoft Xbox 360 SDK\bin\win32\dumpbin.exe" goto DUMPBIN2
set DUMPBIN="C:\Program Files (x86)\Microsoft Xbox 360 SDK\bin\win32\dumpbin.exe"
set XBOXKRNL="C:\Program Files (x86)\Microsoft Xbox 360 SDK\lib\xbox\xboxkrnl.lib"
set XAPI="C:\Program Files (x86)\Microsoft Xbox 360 SDK\lib\xbox\xapilib.lib"
goto START
:DUMPBIN2
if not exist "C:\Program Files\Microsoft Xbox 360 SDK\bin\win32\dumpbin.exe" goto NODUMPBIN
set DUMPBIN="C:\Program Files\Microsoft Xbox 360 SDK\bin\win32\dumpbin.exe"
set XBOXKRNL="C:\Program Files\Microsoft Xbox 360 SDK\lib\xbox\xboxkrnl.lib"
set XAPI="C:\Program Files\Microsoft Xbox 360 SDK\lib\xbox\xapilib.lib"

:START
FOR %%A IN (%*) DO (
	echo dumping %%A
	REM echo %DUMPBIN% /headers /OUT:"%~dp0%%~nA.txt" %%A
	%DUMPBIN% /headers /OUT:"%~dp0%%~nA.txt" %%A
)
echo Done!
goto EXIT

:NODUMPBIN
echo ERROR! could not find sdk dumpbin.exe

:EXIT
endlocal
REM pause
exit

```

`XenonDumper/libs/xkelib/_tools/list_exports_for_lib.idc`:

```idc
#include <idc.idc>

static parseName(name, str1, str2)
{
	auto nm, end, orig;
	if(strstr(name, str1) == 0)
	{
		end = strstr(name, str2);
		nm = substr(name, 1, end);
//		Message(form("hit: before %s after %s\n", name, nm));
	}
	else
		return name;
	return nm;
}

static getName(ea)
{
	auto nm, ret;
	nm = GetFunctionName(ea);
	if(strlen(nm) == 0)
	{
		nm = NameEx(BADADDR, ea);
		ret = parseName(nm, "_", "__");
	}
	else
		ret = parseName(nm, "?", "@@");
	return ret;
}

static main()
{
	auto x, tst, head, ord, ea, nm, entries, rngcur, rngmax;
	//Message(form("\n Program Entry Points: %d\n \n", GetEntryPointQty()));
	head = 0; rngcur = 0; rngmax = 0x100; tst = 0;
	for (x=0; x < GetEntryPointQty(); x = x+1)
	{
		ord = GetEntryOrdinal(x);
		if((ord & 0xFFFF0000) == 0)
		{
			ea = GetEntryPoint(ord);
			nm = getName(ea);
			if(ord == 1)
				Message(form("\t%s @%d\n", nm, ord));
			else
				Message(form("\t%s @%d\n", nm, ord));
		}
	}
}


```

`XenonDumper/libs/xkelib/_tools/manuals_kernel.txt`:

```txt
  Symbol name  : KiApcNormalRoutineNop
  Symbol name  : _vscprintf
  Symbol name  : vsprintf
  Symbol name  : sprintf
  Symbol name  : _vscwprintf

```

`XenonDumper/libs/xkelib/_tools/manuals_xam.txt`:

```txt
  Symbol name  : RtlOutputDebugString
  Symbol name  : XDebugWarning
  Symbol name  : RtlAllocateHeap
  Symbol name  : RtlReAllocateHeap
  Symbol name  : RtlFreeHeap
  Symbol name  : RtlSizeHeap
  Symbol name  : RtlValidateHeap
  Symbol name  : XDebugWarning
  Symbol name  : PIXAddCounter
  Symbol name  : XMemAlloc
  Symbol name  : XMemFree
  Symbol name  : XMemSize
  Symbol name  : D3DDevice_CreateVertexShader
  Symbol name  : D3DDevice_CreatePixelShader
  Symbol name  : D3DDevice_CreateTexture
  Symbol name  : D3DDevice_CreateVertexDeclaration
  Symbol name  : D3DDevice_Clear
  Symbol name  : D3DDevice_SetRenderState_SrcBlend
  Symbol name  : D3DDevice_SetRenderState_DestBlend
  Symbol name  : D3DResource_Release
  Symbol name  : D3DDevice_Release
  Symbol name  : D3DDevice_SetVertexShader
  Symbol name  : D3DDevice_SetPixelShader
  Symbol name  : D3DDevice_SetTexture
  Symbol name  : D3DDevice_SetVertexDeclaration
  Symbol name  : D3DDevice_DrawVerticesUP
  Symbol name  : D3DDevice_SetVertexShaderConstantF_ParameterCheck
  Symbol name  : D3DDevice_SetSamplerState_ParameterCheck
  Symbol name  : D3DDevice_SetRenderState_ParameterCheck
  Symbol name  : D3DDevice_GetRenderState_ParameterCheck
  Symbol name  : D3DDevice_SetVertexShaderConstantFN
  Symbol name  : D3DDevice_GetRenderState_ZEnable
  Symbol name  : D3DDevice_GetRenderState_CullMode
  Symbol name  : D3DDevice_GetRenderState_AlphaBlendEnable
  Symbol name  : D3DDevice_GetRenderState_SrcBlendAlpha
  Symbol name  : D3DDevice_GetRenderState_DestBlendAlpha
  Symbol name  : D3DDevice_GetRenderState_BlendOp
  Symbol name  : D3DDevice_GetRenderState_ViewportEnable
  Symbol name  : D3DDevice_SetRenderState_ZEnable
  Symbol name  : D3DDevice_SetRenderState_CullMode
  Symbol name  : D3DDevice_SetRenderState_AlphaBlendEnable
  Symbol name  : D3DDevice_SetRenderState_SrcBlendAlpha
  Symbol name  : D3DDevice_SetRenderState_DestBlendAlpha
  Symbol name  : D3DDevice_SetRenderState_BlendOp
  Symbol name  : D3DDevice_SetRenderState_ViewportEnable
  Symbol name  : D3DDevice_SetSamplerState_MagFilter
  Symbol name  : D3DDevice_SetSamplerState_MinFilter
  Symbol name  : XGSetTextureHeader
  Symbol name  : XGGetTextureDesc
  Symbol name  : D3DResource_AddRef
  Symbol name  : D3DDevice_GetRenderTarget
  Symbol name  : D3DDevice_Resolve
  Symbol name  : RtlDebugError

```

`XenonDumper/libs/xkelib/exttypes.h`:

```h
#ifndef __EXTTYPES_H
#define __EXTTYPES_H

typedef unsigned char		u8;
typedef unsigned short		u16;
typedef unsigned int		u32;
typedef unsigned __int64	u64;
typedef unsigned __int64	QWORD;

typedef signed char			s8;
typedef signed short		s16;
typedef signed int			s32;
typedef signed __int64		s64;

typedef QWORD near           *PQWORD;
typedef QWORD far            *LPQWORD;

#define CONSTANT_OBJECT_STRING(s)   { strlen( s ) / sizeof( OCHAR ), (strlen( s ) / sizeof( OCHAR ))+1, s }
#define CMAKE_STRING(s)   {(USHORT)(sizeof(s)-1), (USHORT)(sizeof(s)), (PCHAR)s} // use in declarations
#define MAKE_STRING(s)   {(USHORT)(strlen(s)), (USHORT)((strlen(s))+1), (PCHAR)s} // use in code
#define EXPORTNUM(x) // Just for documentation, thx XBMC!

#define STATUS_SUCCESS	0
#define STATUS_UNSUCCESSFUL              ((NTSTATUS) 0xC0000001)
#define NT_EXTRACT_ST(Status)			((((ULONG)(Status)) >> 30)& 0x3)
#define NT_SUCCESS(Status)              (((NTSTATUS)(Status)) >= 0)
#define NT_INFORMATION(Status)          (NT_EXTRACT_ST(Status) == 1)
#define NT_WARNING(Status)              (NT_EXTRACT_ST(Status) == 2)
#define NT_ERROR(Status)                (NT_EXTRACT_ST(Status) == 3)

#define NEG_ONE_AS_DWORD				((DWORD)-1)

#ifndef ANY_SIZE
#define ANY_SIZE		1
#endif

typedef long			NTSTATUS;
typedef ULONG			ACCESS_MASK;

typedef struct _STRING {
	USHORT Length;
	USHORT MaximumLength;
	PCHAR Buffer;
} STRING, *PSTRING;

typedef struct _CSTRING {
	USHORT Length;
	USHORT MaximumLength;
	CONST char *Buffer;
} CSTRING, *PCSTRING;

typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef STRING			OBJECT_STRING;
typedef CSTRING			COBJECT_STRING;
typedef PSTRING			POBJECT_STRING;
typedef PCSTRING		PCOBJECT_STRING;
typedef STRING			OEM_STRING;
typedef PSTRING			POEM_STRING;
typedef CHAR			OCHAR;
typedef CHAR*			POCHAR;
typedef PSTR			POSTR;
typedef PCSTR			PCOSTR;
typedef CHAR*			PSZ;
typedef CONST CHAR*		PCSZ;
typedef STRING			ANSI_STRING;
typedef PSTRING			PANSI_STRING;
typedef CSTRING			CANSI_STRING;
typedef PCSTRING		PCANSI_STRING;
#define ANSI_NULL		((CHAR)0)     // winnt
typedef CONST UNICODE_STRING*	PCUNICODE_STRING;
#define UNICODE_NULL	((WCHAR)0) // winnt

#define OTEXT(quote) __OTEXT(quote)

typedef struct _IO_STATUS_BLOCK {
	union {
		NTSTATUS Status; // 0x0 sz:0x4
		void * Pointer; // 0x0 sz:0x4
	} st;
	ULONG_PTR Information; // 0x4 sz:0x4
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK; // size 8
C_ASSERT(sizeof(IO_STATUS_BLOCK) == 0x8);

typedef VOID (NTAPI *PIO_APC_ROUTINE) (
	IN PVOID ApcContext,
	IN PIO_STATUS_BLOCK IoStatusBlock,
	IN ULONG Reserved
	);

typedef struct _OBJECT_ATTRIBUTES {
	HANDLE RootDirectory;
	POBJECT_STRING ObjectName;
	ULONG Attributes;
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;

// VOID InitializeObjectAttributes(
//     OUT POBJECT_ATTRIBUTES p,
//     IN STRING n,
//     IN ULONG a,
//     IN HANDLE r)
#define InitializeObjectAttributes( p, name, attrib, root){		\
	(p)->RootDirectory = root;                            \
	(p)->Attributes = attrib;                             \
	(p)->ObjectName = name;                               \
}

typedef struct _OBJECT_DIRECTORY_INFORMATION{
	STRING Name;
	DWORD Type;
} OBJDIR_INFORMATION, *POBJDIR_INFORMATION; // 12b

#ifndef NULL
#define NULL	0
#endif // NULL


#endif // __EXTTYPES_H



```

`XenonDumper/libs/xkelib/kernel/_kernelext.h`:

```h
#ifndef __KERNEL_DEFINES_H
#define __KERNEL_DEFINES_H

#pragma comment(lib, "kernelext")

#include "keFileInfo.h"
#include "keXexInfo.h"
#include "kePrivateStructs.h"
#include "keDriver.h"
#include "keXeCrypt.h"
#include "keXeKeys.h"
#include "keXConfig.h"
#include "keSmc.h"
#include "keNand.h"
#include "kernelExpEnum.h"

#define OBJ_SYS_STRING	"\\System??\\%s"
#define OBJ_USR_STRING	"\\??\\%s"
#define OBJ_SYS_PATH	"\\System??\\"
#define OBJ_USR_PATH	"\\??\\"

// common modules
#define MODULE_KERNEL	"xboxkrnl.exe"
#define MODULE_XAM		"xam.xex"
#define MODULE_SIGNIN	"signin.xex"
#define MODULE_HUD		"hud.xex"
#define MODULE_XBDM		"xbdm.xex"

// some handy intrinsics and macros that are left out...
#define __isync()		__emit(0x4C00012C)

#define doSync(addr) \
	do { \
	__dcbst(0, addr); \
	__sync(); \
	__isync(); \
	} while (0)

#define doLightSync(addr) \
	do { \
	__dcbst(0, addr); \
	__sync(); \
	} while (0)

// debug serial port register
#define DBG_SERIAL_RCV		(DWORD volatile*)0x7FEA1010
#define DBG_SERIAL_XMIT		(DWORD volatile*)0x7FEA1014
#define DBG_SERIAL_STS		(DWORD volatile*)0x7FEA1018
#define DBG_SERIAL_CNTRL	(DWORD volatile*)0x7FEA101C

#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
//UNUSED                                        0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

// Valid values for object Attributes field
#define OBJ_INHERIT             0x00000002L
#define OBJ_PERMANENT           0x00000010L
#define OBJ_EXCLUSIVE           0x00000020L
#define OBJ_CASE_INSENSITIVE    0x00000040L
#define OBJ_OPENIF              0x00000080L
#define OBJ_OPENLINK            0x00000100L
#define OBJ_VALID_ATTRIBUTES    0x000001F2L

// Directory Stuff
#define DIRECTORY_QUERY                 (0x0001)
#define DIRECTORY_TRAVERSE              (0x0002)
#define DIRECTORY_CREATE_OBJECT         (0x0004)
#define DIRECTORY_CREATE_SUBDIRECTORY   (0x0008)
#define DIRECTORY_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0xF)

#define SYMBOLIC_LINK_QUERY (0x0001)

// object type strings
#define OBJ_TYP_SYMBLINK	0x626d7953 // Symb
#define OBJ_TYP_DIRECTORY	0x65726944 // Dire
#define OBJ_TYP_DEVICE		0x69766544 // Devi
#define OBJ_TYP_EVENT		0x76657645 // Evev
#define OBJ_TYP_DEBUG		0x63706d64 // dmpc

// flags for xex load image dwModuleTypeFlags
#define XEX_LOADIMG_FLAG_TITLE_PROCESS   0x00000001
#define XEX_LOADIMG_FLAG_TITLE_IMPORTS   0x00000002
#define XEX_LOADIMG_FLAG_DEBUGGER        0x00000004
#define XEX_LOADIMG_FLAG_DLL             0x00000008
#define XEX_LOADIMG_FLAG_PATCH           0x00000010
#define XEX_LOADIMG_FLAG_PATCH_FULL      0x00000020
#define XEX_LOADIMG_FLAG_PATCH_DELTA     0x00000040
#define XEX_LOADIMG_FLAG_BOUND_PATH      0x40000000
#define XEX_LOADIMG_FLAG_SILENT_LOAD     0x80000000
#define XEX_LOADIMG_TYPE_TITLE 			(XEX_LOADIMG_FLAG_TITLE_PROCESS)
#define XEX_LOADIMG_TYPE_TITLE_DLL 		(XEX_LOADIMG_FLAG_TITLE_PROCESS | XEX_LOADIMG_FLAG_DLL)
#define XEX_LOADIMG_TYPE_SYSTEM_APP 	(XEX_LOADIMG_FLAG_DLL)
#define XEX_LOADIMG_TYPE_SYSTEM_DLL 	(XEX_LOADIMG_FLAG_DLL | XEX_LOADIMG_FLAG_TITLE_IMPORTS)

// flags used by ExCreateThread
#define EX_CREATE_FLAG_SUSPENDED		0x00000001 // thread created suspended
#define EX_CREATE_FLAG_SYSTEM			0x00000002 // create a system thread
#define EX_CREATE_FLAG_TLS_STATIC		0x00000008 // allocates more object memory, KPROCESS.SizeOfTlsSlots+KPROCESS.SizeOfTlsStaticData
#define EX_CREATE_FLAG_PRIORITY1		0x00000020 // sets priority class for the thread to 1 via KeSetPriorityClassThread - foreground
#define EX_CREATE_FLAG_PRIORITY0		0x00000040 // sets priority class for the thread to 0 via KeSetPriorityClassThread - background
#define EX_CREATE_FLAG_RETURN_KTHREAD	0x00000080 // puts PKTHREAD into pHandle instead of the thread HANDLE
#define EX_CREATE_FLAG_TITLE_EXEC		0x00000100 // title execution thread
#define EX_CREATE_FLAG_HIDDEN			0x00000400 // hides the thread from debugger thread list
// { more in here in regards to thread scheduler }
#define EX_CREATE_FLAG_CORE0			0x01000000 // threads starts on 1st cpu core
#define EX_CREATE_FLAG_CORE1			0x02000000 // threads starts on 2nd cpu core
#define EX_CREATE_FLAG_CORE2			0x04000000 // threads starts on 3rd cpu core
#define EX_CREATE_FLAG_CORE3			0x08000000 // threads starts on 4th cpu core
#define EX_CREATE_FLAG_CORE4			0x10000000 // threads starts on 5th cpu core
#define EX_CREATE_FLAG_CORE5			0x20000000 // threads starts on 6th cpu core

// Can be used instead of module name to get module address where XexGetModuleHandle() is called
#define GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS	(PSZ)(-1)

typedef enum _POOL_TYPE {
	PoolTypeThread = 0x0,
	PoolTypeTitle = 0x1,
	PoolTypeSystem = 0x2,
	PoolTypeTitleDebug = 0x3,
	PoolTypeSystemDebug = 0x4,
} POOL_TYPE;

typedef enum { // effects on jtag noted in comment
	HalHaltRoutine = 0x0, // hard poweroff (used by hotplug HDD) HalpPowerDownSystemNow
	HalRebootRoutine = 0x1, // hard reset (video error) HalpRebootSystem
	HalKdRebootRoutine = 0x2, // hard reset (used for dumpwritedump/frozen processor) HalpRebootSystem
	HalFatalErrorRebootRoutine = 0x3, // hard reset HalpRebootSystem
	HalResetSMCRoutine = 0x4, // power off (hard) HalpRebootSystem
	HalPowerDownRoutine = 0x5, // power off (nice) HalpPowerDownSystem
	HalRebootQuiesceRoutine = 0x6, // E79 (lost settings) HalpRebootQuiesceSystem
	HalForceShutdownRoutine = 0x7, // frozen console HalpRequestPowerDownDpc
	HalPowerCycleQuiesceRoutine = 0x8,
	HalMaximumRoutine = 0x9,
} FIRMWARE_REENTRY;

/* description about xex exe headers in memory */
typedef struct _XBOX_HARDWARE_INFO {
	DWORD Flags;
	unsigned char NumberOfProcessors;
	unsigned char PCIBridgeRevisionID;
	unsigned char Reserved[6];
	unsigned short BldrMagic;
	unsigned short BldrFlags;
} XBOX_HARDWARE_INFO, *PXBOX_HARDWARE_INFO;

typedef struct _EX_TITLE_TERMINATE_REGISTRATION
{
	void* NotificationRoutine; // function pointer
	u32 Priority; // xam uses 0x7C800000 for early and 0x0 for late
	LIST_ENTRY ListEntry; // already defined in winnt.h
} EX_TITLE_TERMINATE_REGISTRATION, *PEX_TITLE_TERMINATE_REGISTRATION;

typedef struct _EX_THREAD_REGISTRATION {
	void* NotificationRoutine;
	DWORD Priority;
	LIST_ENTRY ListEntry;
} EX_THREAD_REGISTRATION, *PEX_THREAD_REGISTRATION;

typedef struct _VD_NOTIFICATION_REGISTRATION {
	PVOID NotificationRoutine; // 0x0 sz:0x4 void(*)()
	long Priority; // 0x4 sz:0x4
	LIST_ENTRY ListEntry; // 0x8 sz:0x8
} VD_NOTIFICATION_REGISTRATION, *PVD_NOTIFICATION_REGISTRATION; // size 16
C_ASSERT(sizeof(VD_NOTIFICATION_REGISTRATION) == 0x10);

typedef void (*pfnThreadNotificationRoutine)(PEX_THREAD_REGISTRATION ThisRegistration, PKTHREAD Thread, BOOL Creating);
typedef int (*LP_VD_NOTIFICATION_CALLBACK)(const PVD_NOTIFICATION_REGISTRATION vdReg, DWORD type, void * buf);

typedef struct _XBOX_KRNL_VERSION{
	WORD Major; // for 360 this is always 2
	WORD Minor; // usually 0
	WORD Build; // current version, for example 9199
	WORD Qfe;
} XBOX_KRNL_VERSION, *PXBOX_KRNL_VERSION;

typedef struct _KTIME_STAMP_BUNDLE {
	LARGE_INTEGER InterruptTime; // 0
	LARGE_INTEGER SystemTime; // 8
	DWORD TickCount; // 10
} KTIME_STAMP_BUNDLE, *PKTIME_STAMP_BUNDLE;

typedef struct _LZX_DECOMPRESS {
	LONG WindowSize;
	LONG CpuType;
} LZX_DECOMPRESS, *PLZX_DECOMPRESS;

typedef struct _TIME_FIELDS { 
	SHORT Year; // 0x0 sz:0x2
	SHORT Month; // 0x2 sz:0x2
	SHORT Day; // 0x4 sz:0x2
	SHORT Hour; // 0x6 sz:0x2
	SHORT Minute; // 0x8 sz:0x2
	SHORT Second; // 0xA sz:0x2
	SHORT Milliseconds; // 0xC sz:0x2
	SHORT Weekday; // 0xE sz:0x2
} TIME_FIELDS, *PTIME_FIELDS; // size 16
C_ASSERT(sizeof(TIME_FIELDS) == 0x10);

#ifdef __cplusplus
extern "C" {
#endif

	/*NTSYSAPI
	EXPORTNUM(3)
	VOID
	NTAPI
	DbgPrint(
		IN		const char* s,
		...
	);*/

	NTSYSAPI
	EXPORTNUM(7)
	VOID
	NTAPI
	ExAcquireReadWriteLockExclusive(
		IN OUT	PERWLOCK pExReadWriteLock
	);

	// http://msdn.microsoft.com/en-us/library/ff544520%28v=vs.85%29.aspx
	// pool functions return NULL if there is insufficient memory
	// uses POOL_TYPE NonPagedPool
	// uses tag 'enoN' (None)
	NTSYSAPI
	EXPORTNUM(9)
	PVOID
	NTAPI
	ExAllocatePool(
		IN  	DWORD NumberOfBytes
	);

	// uses POOL_TYPE NonPagedPool
	NTSYSAPI
	EXPORTNUM(10)
	PVOID
	NTAPI
	ExAllocatePoolWithTag(
		IN  DWORD NumberOfBytes,
		IN  DWORD Tag
	);

	NTSYSAPI
	EXPORTNUM(11)
	PVOID
	NTAPI
	ExAllocatePoolTypeWithTag(
		IN  DWORD NumberOfBytes,
		IN  DWORD Tag,
		IN  POOL_TYPE PoolType
	);

	EXPORTNUM(12)
	extern PDWORD ExConsoleGameRegion;

	NTSYSAPI
	EXPORTNUM(13)
	DWORD
	NTAPI
	ExCreateThread(
		IN		PHANDLE pHandle,
		IN		DWORD dwStackSize,
		IN		LPDWORD lpThreadId,
		IN		PVOID apiThreadStartup,
		IN		LPTHREAD_START_ROUTINE lpStartAddress,
		IN		LPVOID lpParameter,
		IN		DWORD dwCreationFlagsMod
	);

	EXPORTNUM(14)
	extern POBJECT_TYPE ExEventObjectType;

	NTSYSAPI
	EXPORTNUM(15)
	VOID
	NTAPI
	ExFreePool(
		IN PVOID  pPool
	);

	NTSYSAPI
	EXPORTNUM(16)
	NTSTATUS
	NTAPI
	ExGetXConfigSetting(
		IN		WORD dwCategory,
		IN		WORD dwSetting,
		OUT		PVOID pBuffer,
		IN		WORD cbBuffer,
		OUT		PWORD szSetting
	);
	
	NTSYSAPI
	EXPORTNUM(17)
	VOID
	NTAPI
	ExInitializeReadWriteLock(
		IN OUT	PERWLOCK pExReadWriteLock
	);
	
	EXPORTNUM(18)
	extern POBJECT_TYPE ExMutantObjectType;

	NTSYSAPI
	EXPORTNUM(20)
	VOID
	NTAPI
	ExRegisterThreadNotification(
		IN OUT	PEX_THREAD_REGISTRATION threadNotification,
		IN		BOOL Create
	);

	NTSYSAPI
	EXPORTNUM(21)
	VOID
	NTAPI
	ExRegisterTitleTerminateNotification(
		IN OUT	PEX_TITLE_TERMINATE_REGISTRATION pTermStruct,
		IN		BOOL bCreate // true create, false destroy existing
	);

	EXPORTNUM(23)
	extern POBJECT_TYPE ExSemaphoreObjectType;

	NTSYSAPI
	EXPORTNUM(24)
	NTSTATUS
	NTAPI
	ExSetXConfigSetting(
		IN		WORD dwCategory,
		IN		WORD dwSetting,
		IN		PVOID pBuffer,
		IN		WORD szSetting
	);

	NTSYSAPI
	EXPORTNUM(25)
	VOID
	NTAPI
	ExTerminateThread(
		IN DWORD  exitCode
	);

	EXPORTNUM(27)
	extern POBJECT_TYPE ExThreadObjectType;

	EXPORTNUM(28)
	extern POBJECT_TYPE ExTimerObjectType;

	NTSYSAPI
	EXPORTNUM(31)
	VOID
	NTAPI
	XeKeysGetConsoleCertificate(
		OUT		PXE_CONSOLE_CERTIFICATE pConsoleCert
	);

	NTSYSAPI
	EXPORTNUM(36)
	VOID
	NTAPI
	HalOpenCloseODDTray(
		IN		DWORD setTray
	);

	NTSYSAPI
	EXPORTNUM(37)
	VOID
	NTAPI
	HalReadWritePCISpace(
		IN		BYTE Bus,
		IN		BYTE Device,
		IN		BYTE Function,
		IN		DWORD offset, // offset from 0 in pci bus+device+function
		IN OUT	PVOID pBuffer,
		IN      DWORD cbBuffer,
		OUT     BOOL isWrite // true if writing, false if reading
	);

	NTSYSAPI
	EXPORTNUM(39)
	VOID
	NTAPI
	HalRegisterSMCNotification(
		IN OUT	PHAL_SMC_REGISTRATION pSmcRegistration,
		IN		BOOL bUnk // seems to be 1 for create and 0 for remove?
	);

	NTSYSAPI
	EXPORTNUM(40)
	VOID
	NTAPI
	HalReturnToFirmware(
		IN		FIRMWARE_REENTRY powerDownMode
	);

	// buffers are 0x10 bytes in length, on cmd that recv no response send NULL for recv
	NTSYSAPI
	EXPORTNUM(41)
	VOID
	NTAPI
	HalSendSMCMessage(
		IN		LPVOID pCommandBuffer,
		OUT		LPVOID pRecvBuffer
	);

	// similar to KfAcquireSpinLock, but acquires lock in kernel on IopDeviceObjectLock
	NTSYSAPI
	EXPORTNUM(46)
	BYTE
	NTAPI
	IoAcquireDeviceObjectLock(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(47)
	PIRP
	NTAPI
	IoAllocateIrp(
		IN		BYTE StackSize
	);

	NTSYSAPI
	EXPORTNUM(48)
	PIRP
	NTAPI
	IoBuildAsynchronousFsdRequest(
		IN		DWORD MajorFunction,
		IN		PDEVICE_OBJECT pDeviceObject,
		IN OUT	PVOID Buffer,
		IN		DWORD Length OPTIONAL,
		IN		PLARGE_INTEGER StartingOffset OPTIONAL,
		IN		PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
	);

	NTSYSAPI
	EXPORTNUM(49)
	PIRP
	NTAPI
	IoBuildDeviceIoControlRequest(
		IN		DWORD IoControlCode,
		IN		PDEVICE_OBJECT pDeviceObject,
		IN		PVOID InputBuffer OPTIONAL,
		IN		DWORD InputBufferLength,
		IN		PVOID OutputBuffer OPTIONAL,
		IN		DWORD OutputBufferLength,
		IN		PKEVENT pEvent OPTIONAL,
		IN OUT	PIO_STATUS_BLOCK pIoStatusBlock
	);

	NTSYSAPI
	EXPORTNUM(50)
	PIRP
	NTAPI
	IoBuildSynchronousFsdRequest(
		IN		DWORD MajorFunction,
		IN		PDEVICE_OBJECT pDeviceObject,
		IN OUT	PVOID Buffer,
		IN		DWORD Length OPTIONAL,
		IN		PLARGE_INTEGER StartingOffset OPTIONAL,
		IN		PKEVENT pEvent,
		IN		PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
	);

	NTSYSAPI
	EXPORTNUM(51)
	NTSTATUS
	NTAPI
	IoCallDriver(
		IN		PDEVICE_OBJECT pDeviceObject,
		IN OUT	PIRP pIrp
	);

	NTSYSAPI
	EXPORTNUM(52)
	NTSTATUS
	NTAPI
	IoCheckShareAccess(
		IN		DWORD DesiredAccess,
		IN		DWORD DesiredShareAccess,
		IN OUT	PFILE_OBJECT  FileObject,
		IN OUT	PSHARE_ACCESS ShareAccess,
		IN		BOOL Update
	);

	NTSYSAPI
	EXPORTNUM(53)
	VOID
	NTAPI
	IoCompleteRequest(
		IN OUT		void* pIrp, // PIRP
		IN OUT		DWORD unk // CHAR PriorityBoost?
	);

	EXPORTNUM(54)
	extern POBJECT_TYPE IoCompletionObjectType;

	NTSYSAPI
	EXPORTNUM(55)
	NTSTATUS
	NTAPI
	IoCreateDevice(
		IN		PDRIVER_OBJECT DriverObject,
		IN		DWORD DeviceExtensionSize, // ??
		IN		PSTRING DeviceName, // opt
		IN		DWORD DeviceType,
		IN		DWORD DeviceCharacteristics,
	//	IN		BOOL Exclusive,
		OUT		PDEVICE_OBJECT *DeviceObject
	);

	NTSYSAPI
	EXPORTNUM(57)
	VOID
	NTAPI
	IoDeleteDevice(
		IN		PDEVICE_OBJECT pDeviceObject
	);

	EXPORTNUM(58)
	extern POBJECT_TYPE IoDeviceObjectType;

	EXPORTNUM(62)
	extern POBJECT_TYPE IoFileObjectType;

	NTSYSAPI
	EXPORTNUM(63)
	VOID
	NTAPI
	IoFreeIrp(
		IN		PIRP pIrp
	);

	NTSYSAPI
	EXPORTNUM(64)
	VOID
	NTAPI
	IoInitializeIrp(
		IN OUT	PIRP pIrp,
		IN		BYTE StackSize
	);

	NTSYSAPI
	EXPORTNUM(65)
	NTSTATUS
	NTAPI
	IoInvalidDeviceRequest(
		IN OUT		void* pDeviceObject, // PDEVICE_OBJECT
		IN OUT		void* pIrp // PIRP
	);

	// returns STATUS_ACCESS_DENIED if not called by a system thread
	NTSYSAPI
	EXPORTNUM(66)
	BOOL
	NTAPI
	ExSetBetaFeaturesEnabled(
		IN		DWORD dwBetaFeature
	);

	NTSYSAPI
	EXPORTNUM(67)
	VOID
	NTAPI
	IoQueueThreadIrp(
		IN		PIRP pIrp
	);

	// use this to release IopDeviceObjectLock aquired with IoAcquireDeviceObjectLock
	NTSYSAPI
	EXPORTNUM(68)
	VOID
	NTAPI
	IoReleaseDeviceObjectLock(
		IN		BYTE oldIrql
	);

	NTSYSAPI
	EXPORTNUM(71)
	VOID
	NTAPI
	IoSetShareAccess(
		IN		DWORD DesiredAccess,
		IN		DWORD DesiredShareAccess,
		IN OUT	PFILE_OBJECT  FileObject,
		OUT		PSHARE_ACCESS ShareAccess
	);

	NTSYSAPI
	EXPORTNUM(72)
	VOID
	NTAPI
	IoStartNextPacket(
		IN		PDEVICE_OBJECT DeviceObject
	);

	NTSYSAPI
	EXPORTNUM(73)
	VOID
	NTAPI
	IoStartNextPacketByKey(
		IN		PDEVICE_OBJECT DeviceObject,
		IN		DWORD key
	);

	NTSYSAPI
	EXPORTNUM(74)
	VOID
	NTAPI
	IoStartPacket(
		IN		PDEVICE_OBJECT DeviceObject,
		IN		PIRP pIrp,
		IN		DWORD key OPTIONAL
	);
	
	NTSYSAPI
	EXPORTNUM(75)
	NTSTATUS
	NTAPI
	IoSynchronousDeviceIoControlRequest(
		IN		DWORD IoControlCode,
		IN		PDEVICE_OBJECT pDeviceObject,
		IN		PVOID InputBuffer OPTIONAL,
		IN		DWORD InputBufferLength,
		IN		PVOID OutputBuffer OPTIONAL,
		IN		DWORD OutputBufferLength,
		IN OUT	PDWORD pIoStatusInfo OPTIONAL // the result from iostatus.information is placed here if present
	);

	NTSYSAPI
	EXPORTNUM(76)
	PIRP
	NTAPI
	IoSynchronousFsdRequest(
		IN		DWORD MajorFunction,
		IN		PDEVICE_OBJECT pDeviceObject,
		IN OUT	PVOID Buffer,
		IN		DWORD Length,
		IN		PLARGE_INTEGER StartingOffset
	);

	NTSYSAPI
	EXPORTNUM(77)
	VOID
	NTAPI
	KeAcquireSpinLockAtRaisedIrql(
		IN OUT	PDWORD spinVar
	);

	NTSYSAPI
	EXPORTNUM(82)
	VOID
	NTAPI
	KeBugCheck(
		IN		DWORD BugCheckCode
	);

	NTSYSAPI
	EXPORTNUM(83)
	VOID
	NTAPI
	KeBugCheckEx(
		IN		DWORD BugCheckCode,
		IN		DWORD BugCheckParameter1,
		IN		DWORD BugCheckParameter2,
		IN		DWORD BugCheckParameter3,
		IN		DWORD BugCheckParameter4 
	);

	NTSYSAPI
	EXPORTNUM(86)
	VOID
	NTAPI
	KeContextFromKframes(
		IN 		PKTRAP_FRAME pktf,
		OUT 	PCONTEXT pctx
	);

	NTSYSAPI
	EXPORTNUM(90)
	NTSTATUS
	NTAPI
	KeDelayExecutionThread(
		IN		KPROCESSOR_MODE WaitMode,
		IN		BOOL Alertable,
		IN		PLARGE_INTEGER Interval
	);

	NTSYSAPI
	EXPORTNUM(95)
	VOID
	NTAPI
	KeEnterCriticalRegion(
		VOID
	);

	// untested
	NTSYSAPI
	EXPORTNUM(97)
	VOID
	NTAPI
	KeFlushCacheRange(
		IN		PVOID address,
		IN		DWORD size
	);

	NTSYSAPI
	EXPORTNUM(102)
	UCHAR // enum _KPROC_TYPE
	NTAPI
	KeGetCurrentProcessType(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(109)
	VOID
	NTAPI
	KeInitializeApc(
		IN		PKAPC Apc,
		IN		PKTHREAD Thread,
		IN		PKKERNEL_ROUTINE KernelRoutine,
		IN		PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,
		IN		PKNORMAL_ROUTINE NormalRoutine OPTIONAL, // UserApcRoutine
		IN		KPROCESSOR_MODE Mode,
		IN		PVOID Context 
	);
	
	NTSYSAPI
	EXPORTNUM(112)
	VOID
	NTAPI
	KeInitializeEvent(
		IN OUT		PKEVENT Event,
		IN			DWORD Type,
		IN			BOOL State
	);

	NTSYSAPI
	EXPORTNUM(118)
	BOOL
	NTAPI
	KeInsertByKeyDeviceQueue(
		IN OUT		PKDEVICE_QUEUE DeviceQueue,
		IN OUT		PKDEVICE_QUEUE_ENTRY DeviceQueueEntry, // part of IRP overlay
		IN			DWORD key
	);

	NTSYSAPI
	EXPORTNUM(119)
	BOOL
	NTAPI
	KeInsertDeviceQueue(
		IN OUT		PKDEVICE_QUEUE DeviceQueue,
		IN OUT		PKDEVICE_QUEUE_ENTRY DeviceQueueEntry // part of IRP overlay
	);

	NTSYSAPI
	EXPORTNUM(122)
	BOOL
	NTAPI
	KeInsertQueueApc(
		IN		PKAPC Apc,
		IN		PVOID SystemArgument1,
		IN		PVOID SystemArgument2,
		IN		DWORD PriorityBoost // KPRIORITY
	);

	NTSYSAPI
	EXPORTNUM(123)
	BOOL
	NTAPI
	KeInsertQueueDpc(
		IN		PKDPC Dpc,
		IN		PVOID SystemArgument1 OPTIONAL,
		IN		PVOID SystemArgument2 OPTIONAL
	);

	NTSYSAPI
	EXPORTNUM(124)
	PDWORD
	NTAPI
	KeIpiGenericCall(
		IN  	PKIPI_BROADCAST_WORKER BroadcastFunction,
		IN  	PDWORD Context
	);

	NTSYSAPI
	EXPORTNUM(125)
	VOID
	NTAPI
	KeLeaveCriticalRegion(
		VOID
	);
	
	NTSYSAPI
	EXPORTNUM(132)
	NTSTATUS
	NTAPI
	KeQuerySystemTime(
		OUT		PFILETIME CurrentTime // LARGE_INTEGER
	);

	// lower with KfLowerIrql - DPC IRQL is 2
	NTSYSAPI
	EXPORTNUM(133)
	BYTE
	NTAPI
	KeRaiseIrqlToDpcLevel(
		VOID
	);
	
	NTSYSAPI
	EXPORTNUM(134)
	VOID
	NTAPI
	KeRegisterDriverNotification(
		IN OUT	PKDRIVER_NOTIFICATION_REGISTRATION pDriverNotification,
		IN		KDRIVER_NOTIFICATION_TYPE dwNotificationType // _KDRIVER_NOTIFICATION_TYPE
	);

	NTSYSAPI
	EXPORTNUM(137)
	VOID
	NTAPI
	KeReleaseSpinLockFromRaisedIrql(
		IN OUT	PDWORD spinVar
	);

	NTSYSAPI
	EXPORTNUM(138)
	PKDEVICE_QUEUE_ENTRY
	NTAPI
	KeRemoveByKeyDeviceQueue(
		IN OUT		PKDEVICE_QUEUE DeviceQueue,
		IN OUT		DWORD key
	);

	NTSYSAPI
	EXPORTNUM(139)
	PKDEVICE_QUEUE_ENTRY
	NTAPI
	KeRemoveDeviceQueue(
		IN OUT		PKDEVICE_QUEUE DeviceQueue
	);
	
	NTSYSAPI
	EXPORTNUM(143)
	VOID
	NTAPI
	KeResetEvent(
		IN OUT		PKEVENT Event
	);

	NTSYSAPI
	EXPORTNUM(146)
	VOID
	NTAPI
	KeResumeThread(
		IN	PKTHREAD thread
	);

	NTSYSAPI
	EXPORTNUM(153)
	LONG
	NTAPI
	KeSetBasePriorityThread(
		IN OUT	PKTHREAD Thread,
		IN		LONG Increment
	);

	NTSYSAPI
	EXPORTNUM(154)
	VOID
	NTAPI
	KeSetCurrentProcessType(
		IN		DWORD ProcessType
	);

	NTSYSAPI
	EXPORTNUM(157)
	HRESULT
	NTAPI
	KeSetEvent(
		IN 		PKEVENT Event,
		IN		DWORD Increment,
		IN		BOOL Wait
	);

	NTSYSAPI
	EXPORTNUM(168)
	BYTE
	NTAPI
	KeStallExecutionProcessor(
		IN		DWORD period
	);

	NTSYSAPI
	EXPORTNUM(169)
	VOID
	NTAPI
	KeSuspendThread(
		IN	PKTHREAD thread
	);

	EXPORTNUM(173)
	extern PKTIME_STAMP_BUNDLE KeTimeStampBundle;

	NTSYSAPI
	EXPORTNUM(176)
	NTSTATUS
	NTAPI
	KeWaitForSingleObject(
		IN		PVOID Object,
		IN		KWAIT_REASON WaitReason,
		IN		WAIT_MODE WaitMode,
		IN		BOOL Alertable,
		IN		PLARGE_INTEGER Timeout OPTIONAL
	);

	/* spinlock example:
	DWORD g_spinvar;
	{
		BYTE irql;
		irql = KfAcquireSpinLock(&g_spinvar);
		... some code
		KfReleaseSpinLock(&g_spinvar, irql);
	}*/
	NTSYSAPI
	EXPORTNUM(177)
	BYTE
	NTAPI
	KfAcquireSpinLock(
		IN OUT	PDWORD spinVar
	);

	NTSYSAPI
	EXPORTNUM(178)
	BYTE
	NTAPI
	KfRaiseIrql(
		IN		BYTE irql
	);
	
	NTSYSAPI
	EXPORTNUM(179)
	VOID
	NTAPI
	KfLowerIrql(
		IN		BYTE irql
	);

	NTSYSAPI
	EXPORTNUM(180)
	VOID
	NTAPI
	KfReleaseSpinLock(
		IN OUT	PDWORD spinVar,
		IN		BYTE oldIrql
	);

	NTSYSAPI
	EXPORTNUM(182)
	HRESULT
	NTAPI
	LDICreateDecompression(
		IN		PVOID pcbDataBlockMax,
		IN		PLZX_DECOMPRESS pvConfiguration,
		IN		PVOID pfn_dec_malloc, // void * (__cdecl *)(unsigned long) dec_malloc,
		IN		PVOID pfn_dec_free, // void (__cdecl *)(void *) dec_free,
		IN		PVOID dec_memory,
		IN		PVOID pcbSrcBufferMin,
		OUT		PHANDLE pmdhHandle
	);

	NTSYSAPI
	EXPORTNUM(183)
	HRESULT
	NTAPI
	LDIDecompress(
		IN		HANDLE hmd,
		IN		PVOID pbSrc,
		IN		DWORD cbSrc,
		IN OUT	PVOID pbDst,
		IN OUT	PDWORD pcbResult
	);
	
	NTSYSAPI
	EXPORTNUM(184)
	HRESULT
	NTAPI
	LDIDestroyDecompression(
		IN		HANDLE hmd
	);

	//  - INCOMPLETE!!
	NTSYSAPI
	EXPORTNUM(185)
	PVOID
	NTAPI
	MmAllocatePhysicalMemory(
		IN		DWORD type, // 0 (2 for system?)
		IN		DWORD size, // 1
		IN		DWORD accessFlags //0x20000004 - gives 1 64k phy alloc
	);

	NTSYSAPI
	EXPORTNUM(190)
	PVOID
	NTAPI
	MmGetPhysicalAddress(
		IN		PVOID Address
	);

	NTSYSAPI
	EXPORTNUM(191)
	BOOL
	NTAPI
	MmIsAddressValid(
		IN		PVOID Address
	);

	NTSYSAPI
	EXPORTNUM(196)
	DWORD
	NTAPI
	MmQueryAddressProtect(
		IN		PVOID Address
	);

	NTSYSAPI
	EXPORTNUM(197)
	DWORD
	NTAPI
	MmQueryAllocationSize(
		IN		PVOID Address
	);

	NTSYSAPI
	EXPORTNUM(198)
	DWORD
	NTAPI
	MmQueryStatistics(
		OUT		PMMSTATISTICS pMmStat
	);

	NTSYSAPI
	EXPORTNUM(199)
	DWORD
	NTAPI
	MmSetAddressProtect(
		IN		PVOID Address,
		IN		DWORD Size,
		IN		DWORD Type
	);// PAGE_READWRITE

	NTSYSAPI
	EXPORTNUM(204)
	PVOID
	NTAPI
	NtAllocateVirtualMemory(
		IN OUT 	LPVOID* lpAddress,
		IN		SIZE_T* dwSize,
		IN		DWORD flAllocationType,
		IN		DWORD flProtect,
		IN		DWORD dwMemoryRegionType
	);

	NTSYSAPI
	EXPORTNUM(207)
	NTSTATUS
	NTAPI
	NtClose(
		IN		HANDLE Handle
	);

	 NTSYSAPI
	 EXPORTNUM(208)
	 NTSTATUS
	 NTAPI
	 NtCreateDirectoryObject(
		 OUT		PHANDLE DirectoryHandle,
		 IN			POBJECT_ATTRIBUTES ObjectAttributes
	 );

	NTSYSAPI
	EXPORTNUM(210)
	NTSTATUS
	NTAPI
	NtCreateFile(
		OUT		PHANDLE FileHandle,
		IN		ACCESS_MASK DesiredAccess,
		IN		POBJECT_ATTRIBUTES ObjectAttributes,
		OUT		PIO_STATUS_BLOCK IoStatusBlock,
		IN		PLARGE_INTEGER AllocationSize OPTIONAL,
		IN		DWORD FileAttributes,
		IN		DWORD ShareAccess,
		IN		DWORD CreateDisposition,
		IN		DWORD CreateOptions
	);

	//  UNTESTED
	NTSYSAPI
	EXPORTNUM(216)
	NTSTATUS
	NTAPI
	NtDeleteFile(
		IN 		POBJECT_ATTRIBUTES ObjectAttributes
	);

	NTSYSAPI
	EXPORTNUM(217)
	NTSTATUS
	NTAPI
	NtDeviceIoControlFile(
		IN		HANDLE FileHandle,
		IN		HANDLE Event OPTIONAL,
		IN		PIO_APC_ROUTINE ApcRoutine OPTIONAL,
		IN		PVOID ApcContext OPTIONAL,
		OUT		PIO_STATUS_BLOCK IoStatusBlock,
		IN		DWORD IoControlCode,
		IN		PVOID InputBuffer OPTIONAL,
		IN		DWORD InputBufferLength,
		OUT		PVOID OutputBuffer OPTIONAL,
		IN		DWORD OutputBufferLength
	);
	
	NTSYSAPI
	EXPORTNUM(218)
	NTSTATUS
	NTAPI
	NtDuplicateObject(
		IN		HANDLE hSourceHandle,
		OUT		HANDLE* lpTargetHandle,
		IN		DWORD dwOptions
	);

	NTSYSAPI
	EXPORTNUM(222)
	NTSTATUS
	NTAPI
	NtOpenDirectoryObject(
		OUT		PHANDLE DirectoryHandle,
		IN		POBJECT_ATTRIBUTES ObjectAttributes
	);

	NTSYSAPI
	EXPORTNUM(223)
	NTSTATUS
	NTAPI
	NtOpenFile(
		OUT		PHANDLE FileHandle,
		IN		ACCESS_MASK DesiredAccess,
		IN		POBJECT_ATTRIBUTES ObjectAttributes,
		OUT		PIO_STATUS_BLOCK IoStatusBlock,
		IN		DWORD ShareAccess,
		IN		DWORD OpenOptions
	);

	NTSYSAPI
	EXPORTNUM(224)
	NTSTATUS
	NTAPI
	NtOpenSymbolicLinkObject(
		OUT		PHANDLE LinkHandle,
		IN		POBJECT_ATTRIBUTES ObjectAttributes
	);

	// UNTESTED!!
	NTSYSAPI
	EXPORTNUM(227)
	NTSTATUS
	NTAPI
	NtQueueApcThread(
		IN		HANDLE ThreadHandle,
		IN		PIO_APC_ROUTINE ApcRoutine,
		IN		PVOID ApcRoutineContext OPTIONAL,
		IN		PIO_STATUS_BLOCK ApcStatusBlock OPTIONAL,
		IN		DWORD ApcReserved OPTIONAL
	);

	NTSYSAPI
	EXPORTNUM(228)
	NTSTATUS
	NTAPI
	NtQueryDirectoryFile(
		IN		HANDLE FileHandle,
		IN		HANDLE Event OPTIONAL,
		IN		PIO_APC_ROUTINE ApcRoutine OPTIONAL,
		IN		PVOID ApcContext OPTIONAL,
		OUT		PIO_STATUS_BLOCK IoStatusBlock,
		OUT		PVOID FileInformation,
		IN		DWORD Length,
		IN		PSTRING FileMask OPTIONAL,
		IN		DWORD Unk // usually 0
	);

	NTSYSAPI
	EXPORTNUM(229)
	NTSTATUS
	NTAPI
	NtQueryDirectoryObject(
		IN		HANDLE DirectoryHandle,
		OUT		PVOID Buffer OPTIONAL,
		IN		DWORD Length,
		IN		BOOL RestartScan,//__in       BOOL  ReturnSingleEntry,
		IN OUT	PDWORD Context,
		OUT		PDWORD ReturnLength OPTIONAL
	);

	NTSYSAPI
	EXPORTNUM(231)
	NTSTATUS
	NTAPI
	NtQueryFullAttributesFile(
		IN		POBJECT_ATTRIBUTES ObjectAttributes,
		OUT		PFILE_NETWORK_OPEN_INFORMATION Attributes
	);

	NTSYSAPI
	EXPORTNUM(232)
	NTSTATUS
	NTAPI
	NtQueryInformationFile(
		IN		HANDLE FileHandle,
		OUT		PIO_STATUS_BLOCK IoStatusBlock,
		OUT		PVOID FileInformation,
		IN		DWORD Length,
		IN		FILE_INFORMATION_CLASS FileInformationClass
	);

	NTSYSAPI
	EXPORTNUM(236)
	NTSTATUS
	NTAPI
	NtQuerySymbolicLinkObject(
		IN		HANDLE LinkHandle,
		IN OUT	PSTRING LinkTarget,
		OUT		PULONG ReturnedLength OPTIONAL
	);

	NTSYSAPI
	EXPORTNUM(239)
	NTSTATUS
	NTAPI
	NtQueryVolumeInformationFile(
		IN 		HANDLE FileHandle,
		OUT 	PIO_STATUS_BLOCK IoStatusBlock,
		OUT 	PVOID FileSystemInformation,
		IN 		DWORD Length,
		IN 		FSINFOCLASS FileSystemInformationClass
	);

	//  UNTESTED
	NTSYSAPI
	EXPORTNUM(240)
	NTSTATUS
	NTAPI
	NtReadFile(
		IN		HANDLE FileHandle,
		IN		HANDLE Event OPTIONAL,
		IN		PIO_APC_ROUTINE ApcRoutine OPTIONAL,
		IN		PVOID ApcContext OPTIONAL,
		OUT		PIO_STATUS_BLOCK IoStatusBlock,
		OUT		PVOID Buffer,
		IN		DWORD Length,
		IN		PLARGE_INTEGER ByteOffset OPTIONAL
	);

	//  UNTESTED
	NTSYSAPI
	EXPORTNUM(241)
	NTSTATUS
	NTAPI
	NtReadFileScatter(
		IN 		HANDLE FileHandle,
		IN 		HANDLE Event OPTIONAL,
		IN 		PIO_APC_ROUTINE ApcRoutine OPTIONAL,
		IN 		PVOID ApcContext OPTIONAL,
		OUT 	PIO_STATUS_BLOCK IoStatusBlock,
		IN 		FILE_SEGMENT_ELEMENT SegmentArray,
		IN 		DWORD Length,
		IN 		PLARGE_INTEGER ByteOffset,
		IN 		PDWORD Key OPTIONAL
	);

	NTSYSAPI
	EXPORTNUM(246)
	NTSTATUS
	NTAPI
	NtSetEvent(
		IN		HANDLE EventHandle,
		OUT		PLONG PreviousState OPTIONAL 
	);	

	NTSYSAPI
	EXPORTNUM(247)
	NTSTATUS
	NTAPI
	NtSetInformationFile(
		IN		HANDLE FileHandle,
		OUT		PIO_STATUS_BLOCK IoStatusBlock,
		IN		PVOID FileInformation,
		IN		DWORD Length,
		IN		FILE_INFORMATION_CLASS FileInformationClass
	);

	NTSYSAPI
	EXPORTNUM(249)
	NTSTATUS
	NTAPI
	NtSetSystemTime(
		IN		PFILETIME SystemTime,  // LARGE_INTEGER
		OUT		PFILETIME PreviousTime // LARGE_INTEGER
	);

	NTSYSAPI
	EXPORTNUM(253)
	NTSTATUS
	NTAPI
	NtWaitForSingleObjectEx(
		IN		HANDLE Handle,
		IN		DWORD WaitMode,
		IN		BOOL Alertable,
		IN		PLARGE_INTEGER Timeout
	);

	NTSYSAPI
	EXPORTNUM(255)
	NTSTATUS
	NTAPI
	NtWriteFile(
		IN		HANDLE FileHandle,
		IN		HANDLE Event OPTIONAL,
		IN		PIO_APC_ROUTINE ApcRoutine OPTIONAL,
		IN		PVOID ApcContext OPTIONAL,
		OUT		PIO_STATUS_BLOCK IoStatusBlock,
		IN		PVOID Buffer,
		IN		DWORD Length,
		IN		PLARGE_INTEGER ByteOffset OPTIONAL
	);


	NTSYSAPI
	EXPORTNUM(258)
	NTSTATUS
	NTAPI
	ObCreateObject(
		IN			POBJECT_TYPE ObjectType,
		IN			POBJECT_ATTRIBUTES ObjectAttributes,
		IN			DWORD ObjectBodySize,
		OUT			PVOID *Object
	);

	NTSYSAPI
	EXPORTNUM(259)
	HRESULT
	NTAPI
	ObCreateSymbolicLink(
		IN		PSTRING SymbolicLinkName,
		IN		PSTRING DeviceName
	);

	NTSYSAPI
	EXPORTNUM(260)
	HRESULT
	NTAPI
	ObDeleteSymbolicLink(
		IN		PSTRING SymbolicLinkName
	);

	NTSYSAPI
	EXPORTNUM(261)
	VOID
	NTAPI
	ObDereferenceObject(
		IN		PVOID Object
	);

	EXPORTNUM(262)
	extern POBJECT_TYPE ObDirectoryObjectType;

	NTSYSAPI
	EXPORTNUM(264)
	NTSTATUS
	NTAPI
	ObInsertObject(
		IN			PVOID Object,
		IN			POBJECT_ATTRIBUTES ObjectAttributes, // not sure, seems it's fed this from ObCreateObject
		IN			DWORD AdditionalReferences, // not sure on this one, could be a bool
		OUT			PHANDLE Handle
	);

	NTSYSAPI
	EXPORTNUM(265)
	BOOL
	NTAPI
	ObIsTitleObject(
		IN		PFILE_OBJECT pFileObject
	);

	NTSYSAPI
	EXPORTNUM(266)
	HRESULT
	NTAPI
	ObLookupAnyThreadByThreadId(
		IN		DWORD dwThreadId,
		OUT		PKTHREAD *pthr
	);

	NTSYSAPI
	EXPORTNUM(271)
	VOID
	NTAPI
	ObReferenceObject(
		IN		PVOID Object
	);

	NTSYSAPI
	EXPORTNUM(272)
	NTSTATUS
	NTAPI
	ObReferenceObjectByHandle(
		IN			HANDLE Handle,
		IN			POBJECT_TYPE ObjectType,
		OUT			PVOID *Object
	);

	NTSYSAPI
	EXPORTNUM(273)
	NTSTATUS
	NTAPI
	ObReferenceObjectByName(
		IN			PSTRING ObjectName,
		IN			DWORD Attributes, // PACCESS_STATE AccessState, ACCESS_MASK DesiredAccess
		IN			POBJECT_TYPE ObjectType,
		IN			PVOID ParseContext OPTIONAL, // KPROCESSOR_MODE AccessMode
		OUT			PVOID* Object
	);

	EXPORTNUM(274)
	extern POBJECT_TYPE ObSymbolicLinkObjectType;

	NTSYSAPI
	EXPORTNUM(275)
	NTSTATUS
	NTAPI
	ObTranslateSymbolicLink(
		IN		PVOID,
		OUT		PANSI_STRING
	);

	NTSYSAPI
	EXPORTNUM(283)
	int
	NTAPI
	RtlCompareMemoryUlong(
		IN   	void* Source,
		IN   	DWORD Length,
		IN   	DWORD Pattern
	);

	// just fake this one and cast to the winnt.h types to avoid conflicts
	//NTSYSAPI
	//EXPORTNUM(293)
	//VOID
	//NTAPI
	//RtlEnterCriticalSection(
	//	IN OUT		void* pMutex
	//);

	NTSYSAPI
	EXPORTNUM(298)
	VOID
	NTAPI
	RtlGetStackLimits(
		IN OUT	PDWORD LimitA,
		IN OUT	PDWORD LimitB
	);

	NTSYSAPI
	EXPORTNUM(299)
	PVOID
	NTAPI
	RtlImageXexHeaderField(
		IN		PVOID XexHeaderBase,
		IN		DWORD ImageField
	);

	NTSYSAPI
	EXPORTNUM(300)
	VOID
	NTAPI
	RtlInitAnsiString(
		IN OUT	PANSI_STRING DestinationString,
		IN		PCSZ  SourceString
	);

	// just fake this one and cast to the winnt.h types to avoid conflicts
	//NTSYSAPI
	//EXPORTNUM(304)
	//VOID
	//NTAPI
	//RtlLeaveCriticalSection(
	//	IN OUT		void* pMutex
	//);

	NTSYSAPI
	EXPORTNUM(305)
	PVOID
	NTAPI
	RtlLookupFunctionEntry(
		IN		PVOID pvOffset
	);

	NTSYSAPI
	EXPORTNUM(313)
	int
	NTAPI
	RtlScprintf(
		IN		const CHAR* Format,
		...
	);

	NTSYSAPI
	EXPORTNUM(314)
	int
	NTAPI
	RtlSnprintf(
		IN		CHAR* Buffer,
		IN		int SizeInBytes,
		IN		const CHAR* Format,
		...
	);
	
	NTSYSAPI
	EXPORTNUM(315)
	int
	NTAPI
	RtlSprintf(
		IN		CHAR* Buffer,
		IN		const CHAR* Format,
		...
	);
	
	NTSYSAPI
	EXPORTNUM(316)
	int
	NTAPI
	RtlScwprintf(
		IN		const WCHAR* Format,
		...
	);

	NTSYSAPI
	EXPORTNUM(317)
	int
	NTAPI
	RtlSnwprintf(
		IN		WCHAR * Buffer,
		IN		DWORD MaxLength,
		IN		LPCWSTR Format,
		...
	);	

	NTSYSAPI
	EXPORTNUM(318)
	int
	NTAPI
	RtlSwprintf(
		IN		WCHAR * Buffer,
		IN		LPCWSTR Format,
		...
	);

	NTSYSAPI
	EXPORTNUM(320)
	NTSTATUS
	NTAPI
	RtlTimeToTimeFields(
		IN		PFILETIME Time, // feed with result from KeQuerySystemTime
		OUT		PTIME_FIELDS TimeFields
	);

	NTSYSAPI
	EXPORTNUM(332)
	int
	NTAPI
	RtlVscprintf(
		IN		const CHAR* Format, 
		IN		va_list va
	);

	NTSYSAPI
	EXPORTNUM(333)
	int
	NTAPI
	RtlVsnprintf(
		IN		CHAR* Buffer, 
		IN		int SizeInBytes, 
		IN		const CHAR* Format, 
		IN		va_list va
	);
	
	NTSYSAPI
	EXPORTNUM(334)
	int
	NTAPI
	RtlVsprintf(
		IN		CHAR* Buffer, 
		IN		const CHAR* Format, 
		IN		va_list va
	);

	NTSYSAPI
	EXPORTNUM(335)
	int
	NTAPI
	RtlVscwprintf(
		IN		const WCHAR* Format, 
		IN		va_list va
	);

	NTSYSAPI
	EXPORTNUM(336)
	int
	NTAPI
	RtlVsnwprintf(
		IN		WCHAR* Buffer,
		IN		int SizeInBytes,
		IN		const WCHAR* Format,
		IN		va_list va
	);

	NTSYSAPI
	EXPORTNUM(337)
	int
	NTAPI
	RtlVswprintf(
		IN		WCHAR* Buffer,
		IN		const WCHAR* Format,
		IN		va_list va
	);

	EXPORTNUM(342)
	extern PXBOX_HARDWARE_INFO XboxHardwareInfo;

	EXPORTNUM(343)
	extern PXBOX_KRNL_VERSION XboxKrnlBaseVersion;

	EXPORTNUM(344)
	extern PXBOX_KRNL_VERSION XboxKrnlVersion;

	//dword pointer in kernel space to current title exe handle
	// PLDR_DATA_TABLE_ENTRY ent = (PLDR_DATA_TABLE_ENTRY)(*XexExecutableModuleHandle);
	//extern PHANDLE XexExecutableModuleHandle;
	EXPORTNUM(403)
	extern PLDR_DATA_TABLE_ENTRY* XexExecutableModuleHandle;

	NTSYSAPI
	EXPORTNUM(404)
	BOOL
	NTAPI
	XexCheckExecutablePrivilege(
		IN		DWORD priviledge
	);

	// ie XexGetModuleHandle("xam.xex", &hand), returns 0 on success
	NTSYSAPI
	EXPORTNUM(405)
	NTSTATUS
	NTAPI
	XexGetModuleHandle(
		IN		PSZ moduleName,
		IN OUT	PHANDLE hand
	);

	// ie XexGetProcedureAddress(hand ,0x50, &addr) returns 0 on success
	NTSYSAPI
	EXPORTNUM(407)
	NTSTATUS
	NTAPI
	XexGetProcedureAddress(
		IN		HANDLE hand,
		IN		DWORD dwOrdinal,
		IN		PVOID pvAddress
	);

	NTSYSAPI
	EXPORTNUM(408)
	NTSTATUS
	NTAPI
	XexLoadExecutable(
		IN		PCHAR szXexName,
		IN OUT	PHANDLE pHandle,
		IN		DWORD dwModuleTypeFlags,
		IN		DWORD dwMinimumVersion
	);

	NTSYSAPI
	EXPORTNUM(409)
	NTSTATUS
	NTAPI
	XexLoadImage(
		IN		LPCSTR szXexName,
		IN		DWORD dwModuleTypeFlags,
		IN		DWORD dwMinimumVersion,
		IN OUT	PHANDLE pHandle
	);

	NTSYSAPI
	EXPORTNUM(410)
	NTSTATUS
	NTAPI
	XexLoadImageFromMemory(
		IN		PVOID pvXexBuffer,
		IN		DWORD dwSize,
		IN		LPCSTR szXexName,
		IN		DWORD dwModuleTypeFlags,
		IN		DWORD dwMinimumVersion,
		IN OUT	PHANDLE pHandle
	);

	NTSYSAPI
	EXPORTNUM(412)
	PVOID // returns pointer to NT header
	NTAPI
	XexPcToFileHeader(
		IN		PVOID address,
		OUT		PLDR_DATA_TABLE_ENTRY* ldatOut // puts pointer to LDR_DATA_TABLE_ENTRY in the address pointer here
	);

	NTSYSAPI
	EXPORTNUM(416)
	HRESULT
	NTAPI
	XexStartExecutable(
		IN		FARPROC TitleProcessInitThreadProc
	);

	NTSYSAPI
	EXPORTNUM(417)
	VOID
	NTAPI
	XexUnloadImage(
		IN		HANDLE moduleHandle
	);

	NTSYSAPI
	EXPORTNUM(418)
	VOID
	NTAPI
	XexUnloadImageAndExitThread(
		IN		HANDLE moduleHandle,
		IN		HANDLE threadHandle
	);

	NTSYSAPI
	EXPORTNUM(420)
	NTSTATUS
	NTAPI
	XexVerifyImageHeaders(
		IN		PIMAGE_XEX_HEADER XexHeader,
		IN		DWORD SizeOfHeaders
	);

	NTSYSAPI
	EXPORTNUM(424)
	PVOID
	NTAPI
	RtlImageDirectoryEntryToData(
		IN		PVOID Base,
		IN		BOOL MappedAsImage,
		IN		WORD DirectoryEntry,
		IN OUT	PDWORD size
	);

	EXPORTNUM(430)
	extern PCHAR ExLoadedCommandLine; // max size 0x200 ie: "default.xex"
	
	EXPORTNUM(431)
	extern PCHAR ExLoadedImageName; // max size 0x100 ie: "\Device\Mass0\xexloader_testing\default.xex"

	NTSYSAPI
	EXPORTNUM(434)
	VOID
	NTAPI
	VdDisplayFatalError(
		IN		DWORD dwErrorCode
	);

	NTSYSAPI
	EXPORTNUM(442)
	VOID
	NTAPI
	VdGetCurrentDisplayInformation(
		IN OUT	PDISPLAY_INFO dispInfo
	);

	EXPORTNUM(446)
	extern D3DDevice* VdGlobalDevice;

	EXPORTNUM(447)
	extern D3DDevice* VdGlobalXamDevice;

	NTSYSAPI
	EXPORTNUM(461)
	PVOID // seems to return RTL_CRITICAL_SECTION VdpNotificationRegistrationListLock
	NTAPI
	VdRegisterGraphicsNotification(
		IN		LP_VD_NOTIFICATION_CALLBACK VdpXamNotificationCallback,
		IN		BOOL unk // seems to be insert/delete toggle
	);

	// when notification is called from kernel, PVD_NOTIFICATION_REGISTRATION is always NULL
	NTSYSAPI
	EXPORTNUM(462)
	VOID
	NTAPI
	VdRegisterXamGraphicsNotification(
		IN		LP_VD_NOTIFICATION_CALLBACK VdpXamNotificationCallback
	);

	NTSYSAPI
	EXPORTNUM(486)
	NTSTATUS
	NTAPI
	XInputdReadState(
		IN		DWORD dwDeviceContext,
		OUT		PDWORD pdwPacketNumber,
		OUT		PXINPUT_GAMEPAD pInputData,
		IN OUT	PBOOL pbUnknown OPTIONAL
	);

	NTSYSAPI
	EXPORTNUM(487)
	NTSTATUS
	NTAPI
	XInputdWriteState(
		IN		DWORD DeviceContext,
		IN		DWORD dwVibrationLevel,
		IN		VOID* pInputData, // PXINPUT_GAMEPAD PXINPUT_OUTPUT_DATA
		IN 		BYTE bAmplitude,
		IN 		BYTE bFrequency,
		IN 		BYTE bOffset
	);

	NTSYSAPI
	EXPORTNUM(569)
	BOOL
	NTAPI
	ExIsBetaFeatureEnabled(
		IN		DWORD dwBetaFeature
	);

	NTSYSAPI
	EXPORTNUM(570)
	VOID
	NTAPI
	XeKeysGetFactoryChallenge(
		IN		PVOID buf
	);

	NTSYSAPI
	EXPORTNUM(571)
	DWORD
	NTAPI
	XeKeysSetFactoryResponse(
		IN		PVOID buf
	);

	NTSYSAPI
	EXPORTNUM(575)
	DWORD
	NTAPI
	XeKeysGetStatus(
		IN OUT	PDWORD sta
	);

	NTSYSAPI
	EXPORTNUM(576)
	NTSTATUS
	NTAPI
	XeKeysGeneratePrivateKey(
		IN		WORD KeyId
	);
	
	// returns the size of the given key number for use with get/set
	NTSYSAPI
	EXPORTNUM(577)
	WORD
	NTAPI
	XeKeysGetKeyProperties(
		IN		DWORD KeyId
	);

	NTSYSAPI
	EXPORTNUM(578)
	NTSTATUS
	NTAPI
	XeKeysSetKey(
		IN		WORD KeyId,
		IN		PVOID KeyBuffer,
		IN		WORD keyLength
	);

	NTSYSAPI
	EXPORTNUM(579)
	NTSTATUS
	NTAPI
	XeKeysGenerateRandomKey(
		IN		WORD KeyId,
		OUT		PVOID KeyBuffer
	);

	NTSYSAPI
	EXPORTNUM(580)
	NTSTATUS
	NTAPI
	XeKeysGetKey(
		IN		WORD KeyId,
		OUT		PVOID KeyBuffer,
		IN OUT	PDWORD keyLength
	);

	NTSYSAPI
	EXPORTNUM(582)
	DWORD
	NTAPI
	XeKeysGetConsoleID(
		OUT		PBYTE databuffer OPTIONAL, // optional, will copy the console ID to this if it's sent
		OUT		char* szBuffer OPTIONAL // optional, will sprintf the data to this if it's sent
	);

	NTSYSAPI
	EXPORTNUM(583)
	NTSTATUS
	NTAPI
	XeKeysGetConsoleType(
		IN OUT	PDWORD ConsoleType
	);

	NTSYSAPI
	EXPORTNUM(585)
	BOOL
	NTAPI
	XeKeysHmacSha(
		IN		XEKEY_INDEX keySel,
		IN		const PBYTE pbInp1,
		IN		DWORD cbInp1,
		IN		const PBYTE pbInp2,
		IN		DWORD cbInp2,
		IN		const PBYTE pbInp3,
		IN		DWORD cbInp3,
		IN OUT	PBYTE pbOut,
		IN		DWORD cbOut
	);

	NTSYSAPI
	EXPORTNUM(596)
	BOOL
	NTAPI
	XeKeysObfuscate(
		IN		XEKEY_OBFUSCATE keySel,
		IN		const PBYTE pbInp1,
		IN		DWORD cbInp1,
		IN OUT	PBYTE pbOut,
		IN		PDWORD cbOut
	);

	NTSYSAPI
	EXPORTNUM(597)
	BOOL
	NTAPI
	XeKeysUnObfuscate(
		IN		XEKEY_OBFUSCATE keySel,
		IN		const PBYTE pbInp1,
		IN		DWORD cbInp1,
		IN OUT	PBYTE pbOut,
		IN		PDWORD cbOut
	);

	NTSYSAPI
	EXPORTNUM(598)
	VOID
	NTAPI
	XeKeysConsolePrivateKeySign(
		IN		BYTE* pbHash,
		OUT		PXE_CONSOLE_SIGNATURE pConsoleSignature
	);

	NTSYSAPI
	EXPORTNUM(599)
	BOOL
	NTAPI
	XeKeysConsoleSignatureVerification(
		IN		PBYTE pbHash, // 0x14 byte hash
		IN		XE_CONSOLE_SIGNATURE sig,
		IN OUT	PDWORD localCertCompareResult // result of comparing the cert to the console cert
	);

	NTSYSAPI
	EXPORTNUM(607)
	DWORD
	NTAPI
	XeKeysExecute(
		IN		PVOID pvPhyBuffer, // must be 0x80 byte aligned
		IN		DWORD len, // code block must be > 0x120 and no larger than 0x10000
		IN OUT	PVOID arg1, // args depend on the code block sent
		IN OUT	PVOID arg2,
		IN OUT	PVOID arg3,
		IN OUT	PVOID arg4
	);

	NTSYSAPI
	EXPORTNUM(609)
	VOID
	NTAPI
	XInputdPowerDownDevice(
		IN		DWORD flag // or the user index with 0x10000000
	);

	NTSYSAPI
	EXPORTNUM(611)
	VOID
	NTAPI
	AniTerminateAnimation(
		VOID
	);
	
	NTSYSAPI
	EXPORTNUM(620)
	VOID
	NTAPI
	HalGetPowerUpCause(
		OUT		PBYTE 	reply
	);

	NTSYSAPI
	EXPORTNUM(629)
	NTSTATUS
	NTAPI
	XexTransformImageKey(
		IN OUT	PVOID pBuf,
		IN		DWORD cbLength
	);

	NTSYSAPI
	EXPORTNUM(650)
	NTSTATUS
	NTAPI
	NtAllocateEncryptedMemory(
		IN   	DWORD memoryRegionType, // 0= auto/thread type, 1= title, 2=system, 3=debug, 4=??
		IN  	SIZE_T Size,
		OUT		LPVOID* pBuffer
	);	

	NTSYSAPI
	EXPORTNUM(690)
	NTSTATUS
	NTAPI
	XeKeysGetMediaID(
		IN OUT	PBYTE pMediaID, // 0x10 bytes
		IN		BOOL fCheckHvAuth // if true checks if dvd auth data is valid first?
	);

	EXPORTNUM(731)
	extern PVOID* UsbdBootEnumerationDoneEvent;

	NTSYSAPI
	EXPORTNUM(738)
	HRESULT
	NTAPI
	LDIResetDecompression(
		IN		HANDLE hmd
	);

	NTSYSAPI
	EXPORTNUM(793)
	NTSTATUS
	NTAPI
	HalReadArgonEeprom(
		IN		ARGON_EEPROM_FIELD field,
		IN OUT	PVOID pvBuffer,
		IN		DWORD dwCbbuf,
		OUT		PWORD pwBufUsed OPTIONAL
	);

	// NTSYSAPI
	// EXPORTNUM(111)
	// VOID
	// NTAPI
	// KeInitializeDpc(
		// OUT		PKDPC Dpc,
		// IN		PVOID DeferredRoutine,
		// IN		PVOID DeferredContext OPTIONAL
	// );

	// NTSYSAPI
	// EXPORTNUM(113)
	// VOID
	// NTAPI
	// KeInitializeInterrupt(
		// OUT		PKINTERRUPT InterruptObject,
		// IN		PVOID ServiceRoutine,
		// IN		PVOID ServiceContext,
		// IN		BYTE Irql,
		// IN		BYTE InterruptMode,
		// IN		BYTE bProcTargetNumber // KAFFINITY ProcessorEnableMask
	// );

	// NTSYSAPI
	// EXPORTNUM(45)
	// NTSTATUS
	// NTAPI
	// KeConnectInterrupt(
		// IN		PKINTERRUPT InterruptObject
	// );


	

// haven't had any reason to touch on these Io functions as of yet
// IoSetIoCompletion @70
// IoCreateFile @56
// IoDismountVolume @59
// IoDismountVolumeByFileHandle @60
// IoDismountVolumeByName @61
// IoCheckShareAccess @52
// IoRemoveShareAccess @69
// IoSetShareAccess @71
	



#ifdef __cplusplus
}
#endif


#endif	//__KERNEL_DEFINES_H


```

`XenonDumper/libs/xkelib/kernel/console_type.h`:

```h
#ifndef __CONSOLE_TYPE_H
#define __CONSOLE_TYPE_H

typedef enum {
	CONSOLE_TYPE_XENON			= 0x00000000,
	CONSOLE_TYPE_ZEPHYR			= 0x10000000,
	CONSOLE_TYPE_FALCON			= 0x20000000,
	CONSOLE_TYPE_JASPER			= 0x30000000,
	CONSOLE_TYPE_TRINITY		= 0x40000000,
	CONSOLE_TYPE_CORONA			= 0x50000000,
	CONSOLE_TYPE_WINDCHESTER	= 0x60000000,
} CONSOLE_TYPE;

#define CONSOLE_TYPE_FLAGS_MASK 	(0xF0000000)
#define CONSOLE_TYPE_FROM_FLAGS 	(XboxHardwareInfo->Flags & CONSOLE_TYPE_FLAGS_MASK)
#define IS_CONSOLE_TYPE_SLIM		(CONSOLE_TYPE_FROM_FLAGS > CONSOLE_TYPE_JASPER)

#endif // __CONSOLE_TYPE_H

```

`XenonDumper/libs/xkelib/kernel/keDriver.h`:

```h
#ifndef __KEDRIVER_H
#define __KEDRIVER_H

#define STATUS_BUFFER_OVERFLOW          ((NTSTATUS)0x80000005)
#define STATUS_NO_MORE_FILES			((NTSTATUS)0x80000006)
#define STATUS_VERIFY_REQUIRED          ((NTSTATUS)0x80000016)

#define STATUS_NOT_IMPLEMENTED			((NTSTATUS)0xC0000002)
#define STATUS_INVALID_PARAMETER		((NTSTATUS)0xC000000D)
#define STATUS_NO_SUCH_DEVICE			((NTSTATUS)0xC000000E)
#define STATUS_INVALID_DEVICE_REQUEST	((NTSTATUS)0xC0000010)
#define STATUS_NO_MEDIA_IN_DEVICE		((NTSTATUS)0xC0000013)
#define STATUS_UNRECOGNIZED_MEDIA		((NTSTATUS)0xC0000014)
#define STATUS_MORE_PROCESSING_REQUIRED	((NTSTATUS)0xC0000016)
#define STATUS_ACCESS_DENIED			((NTSTATUS)0xC0000022)
#define STATUS_BUFFER_TOO_SMALL         ((NTSTATUS)0xC0000023)
#define STATUS_OBJECT_NAME_INVALID		((NTSTATUS)0xC0000033)
#define STATUS_DELETE_PENDING			((NTSTATUS)0xC0000056)
#define STATUS_INSUFFICIENT_RESOURCES	((NTSTATUS)0xC000009A) // poolTypeWithTag fails
#define STATUS_DEVICE_NOT_READY         ((NTSTATUS)0xC00000A3)
#define STATUS_NOT_SUPPORTED			((NTSTATUS)0xC00000BB)
#define STATUS_INVALID_PARAMETER_1		((NTSTATUS)0xC00000EF)
#define STATUS_INVALID_PARAMETER_2		((NTSTATUS)0xC00000F0)
#define STATUS_INVALID_PARAMETER_3		((NTSTATUS)0xC00000F1)
#define STATUS_INVALID_PARAMETER_4		((NTSTATUS)0xC00000F2)
#define STATUS_INVALID_PARAMETER_5		((NTSTATUS)0xC00000F3)
#define STATUS_INVALID_PARAMETER_6		((NTSTATUS)0xC00000F4)
#define STATUS_INVALID_PARAMETER_7		((NTSTATUS)0xC00000F5)
#define STATUS_INVALID_PARAMETER_8		((NTSTATUS)0xC00000F6)
#define STATUS_INVALID_PARAMETER_9		((NTSTATUS)0xC00000F7)
#define STATUS_INVALID_PARAMETER_10		((NTSTATUS)0xC00000F8)
#define STATUS_INVALID_PARAMETER_11		((NTSTATUS)0xC00000F9)
#define STATUS_INVALID_PARAMETER_12		((NTSTATUS)0xC00000FA)
#define STATUS_FILE_CLOSED				((NTSTATUS)0xC0000128)
#define STATUS_IO_DEVICE_ERROR			((NTSTATUS)0xC0000185)

// more devices at http://msdn.microsoft.com/en-us/library/windows/hardware/ff544637%28v=vs.85%29.aspx
#define IO_NO_INCREMENT					0
#define IO_CD_ROM_INCREMENT				1	// FILE_DEVICE_CD_ROM, FILE_DEVICE_CD_ROM_FILE_SYSTEM
#define IO_NETWORK_INCREMENT			2	// FILE_DEVICE_NETWORK, FILE_DEVICE_NETWORK_BROWSER, FILE_DEVICE_NETWORK_FILE_SYSTEM, FILE_DEVICE_PHYSICAL_NETCARD

#define IO_TYPE_ADAPTER                 1
#define IO_TYPE_CONTROLLER              2
#define IO_TYPE_DEVICE                  3
#define IO_TYPE_DRIVER                  4
#define IO_TYPE_FILE                    5
#define IO_TYPE_IRP                     6
#define IO_TYPE_MASTER_ADAPTER          7
#define IO_TYPE_OPEN_PACKET             8
#define IO_TYPE_TIMER                   9
#define IO_TYPE_VPB                     10
#define IO_TYPE_ERROR_LOG               11
#define IO_TYPE_ERROR_MESSAGE           12
#define IO_TYPE_DEVICE_OBJECT_EXTENSION 13

// IRP_NOCACHE – data for this I/O request should be read from the actual backing media and not from cache.
// IRP_PAGING_IO – the I/O operation in question is performing paging I/O. This bit is used by the Memory Manager.
// IRP_MOUNT_COMPLETION – the I/O operation in question is performing a mount operation.
// IRP_SYNCHRONOUS_API – the API in question expects synchronous behavior. While synchronous behavior is advised when this bit is set, it is not required.
// IRP_ASSOCIATED_IRP – the IRP in question is associated with some larger I/O operation.
// IRP_BUFFERED_IO – the AssociatedIrp.SystemBuffer field is valid
// IRP_DEALLOCATE_BUFFER – the system buffer was allocated from pool and should be deallocated by the I/O Manager.
// IRP_INPUT_OPERATION – the I/O operation is for input. This is used by the Memory Manager to indicate a page in operation.
// IRP_SYNCHRONOUS_PAGING_IO – the paging operation should complete synchronously. This bit is used by the Memory Manager.
// IRP_CREATE_OPERATION – the IRP represents a file system create operation.
// IRP_READ_OPERATION – the IRP represents a read operation.
// IRP_WRITE_OPERATION – the IRP represents a write operation.
// IRP_CLOSE_OPERATION – the IRP represents a close operation.
// IRP_DEFER_IO_COMPLETION – the IRP should be processed asynchronously. While asynchronous behavior is advised when this bit is set, it is not required.

// Define I/O Request Packet (IRP) flags
#define IRP_NOCACHE                     0x00000001
#define IRP_SYNCHRONOUS_API             0x00000002
#define IRP_CREATE_OPERATION            0x00000004
#define IRP_CLOSE_OPERATION             0x00000008
#define IRP_DEFER_IO_COMPLETION         0x00000010
#define IRP_UNLOCK_USER_BUFFER          0x00000020
#define IRP_UNMAP_SEGMENT_ARRAY         0x00000040

#define IRP_IO_PRIORITY_MASK            0xFF000000
#define IRP_IO_PRIORITY_SHIFT           24

// Define I/O Request Packet (IRP) flags - windows
//#define IRP_NOCACHE                     0x00000001
//#define IRP_PAGING_IO                   0x00000002
//#define IRP_MOUNT_COMPLETION            0x00000002
//#define IRP_SYNCHRONOUS_API             0x00000004
//#define IRP_ASSOCIATED_IRP              0x00000008 // does KeSetEvent for IRP.UserEvent on complete
//#define IRP_BUFFERED_IO                 0x00000010 // checks PendingReturned on complete
//#define IRP_DEALLOCATE_BUFFER           0x00000020 // does MmLockUnlockBufferPages on complete
//#define IRP_INPUT_OPERATION             0x00000040 // does MmUnlockAndUnmapSegmentArray on complete
//#define IRP_SYNCHRONOUS_PAGING_IO       0x00000040
//#define IRP_CREATE_OPERATION            0x00000080
//#define IRP_READ_OPERATION              0x00000100
//#define IRP_WRITE_OPERATION             0x00000200
//#define IRP_CLOSE_OPERATION             0x00000400
//#define IRP_DEFER_IO_COMPLETION         0x00000800
//#define IRP_OB_QUERY_NAME               0x00001000
//#define IRP_HOLD_DEVICE_QUEUE           0x00002000
//#define IRP_UM_DRIVER_INITIATED_IO      0x00400000  
//// Define I/O request packet (IRP) alternate flags for allocation control.
//#define IRP_QUOTA_CHARGED               0x01
//#define IRP_ALLOCATED_MUST_SUCCEED      0x02
//#define IRP_ALLOCATED_FIXED_SIZE        0x04
//#define IRP_LOOKASIDE_ALLOCATION        0x08

/* IO_STACK_LOCATION.Control from wdm.h in ReactOS*/
#define SL_PENDING_RETURNED               0x01
#define SL_ERROR_RETURNED                 0x02
#define SL_INVOKE_ON_CANCEL               0x20
#define SL_INVOKE_ON_SUCCESS              0x40
#define SL_INVOKE_ON_ERROR                0x80

/* IO_STACK_LOCATION.flags */
// IRP_MJ_CREATE/IRP_MJ_CREATE_NAMED_PIPE
#define SL_OPEN_TARGET_DIRECTORY        0x04
#define SL_CASE_SENSITIVE               0x80 // only added by parse routine
// #define SL_FORCE_ACCESS_CHECK           0x01
// #define SL_OPEN_PAGING_FILE             0x02
// #define SL_STOP_ON_SYMLINK              0x08


// IRP_MJ_READ/IRP_MJ_WRITE
#define SL_FSCACHE_REQUEST              0x01 // for read this bit signals to check args
//#define SL_KEY_SPECIFIED                0x01 
//#define SL_OVERRIDE_VERIFY_VOLUME       0x02
//#define SL_WRITE_THROUGH                0x04
//#define SL_FT_SEQUENTIAL_WRITE          0x08
//#define SL_FORCE_DIRECT_WRITE           0x10
//#define SL_REALTIME_STREAM              0x20

// Device I/O Control
// Same SL_OVERRIDE_VERIFY_VOLUME as for read/write above.
#define SL_READ_ACCESS_GRANTED          0x01
#define SL_WRITE_ACCESS_GRANTED         0x04    // Gap for SL_OVERRIDE_VERIFY_VOLUME

// IRP_MJ_LOCK_CONTROL
#define SL_FAIL_IMMEDIATELY             0x01
#define SL_EXCLUSIVE_LOCK               0x02

// IRP_MJ_DIRECTORY_CONTROL/IRP_MJ_QUERY_EA/IRP_MJ_QUERY_QUOTA
#define SL_RESTART_SCAN                 0x01
//#define SL_RETURN_SINGLE_ENTRY          0x02
//#define SL_INDEX_SPECIFIED              0x04

// IRP_MJ_DIRECTORY_CONTROL
#define SL_WATCH_TREE                   0x01

// IRP_MJ_FILE_SYSTEM_CONTROL
#define SL_ALLOW_RAW_MOUNT              0x01

// IRP_MJ_SET_INFORMATION
#define SL_BYPASS_ACCESS_CHECK          0x01

#define METHOD_BUFFERED                   0
#define METHOD_IN_DIRECT                  1
#define METHOD_OUT_DIRECT                 2
#define METHOD_NEITHER                    3

#define METHOD_DIRECT_TO_HARDWARE       METHOD_IN_DIRECT
#define METHOD_DIRECT_FROM_HARDWARE     METHOD_OUT_DIRECT

// Device Object flags
#define DO_EXCLUSIVE                    0x00000002      
#define DO_DIRECT_IO                    0x00000004      
#define DO_DEVICE_HAS_NAME              0x00000008      
#define DO_DEVICE_INITIALIZING          0x00000010      

// Device Object flags - windows flags just in case
//#define DO_VERIFY_VOLUME                    0x00000002      
//#define DO_BUFFERED_IO                      0x00000004      
//#define DO_EXCLUSIVE                        0x00000008      
//#define DO_DIRECT_IO                        0x00000010      
//#define DO_MAP_IO_BUFFER                    0x00000020      
//#define DO_DEVICE_HAS_NAME                  0x00000040      
//#define DO_DEVICE_INITIALIZING              0x00000080      
//#define DO_SYSTEM_BOOT_PARTITION            0x00000100      
//#define DO_LONG_TERM_REQUESTS               0x00000200      
//#define DO_NEVER_LAST_DEVICE                0x00000400      
//#define DO_SHUTDOWN_REGISTERED              0x00000800      
//#define DO_BUS_ENUMERATED_DEVICE            0x00001000      
//#define DO_POWER_PAGABLE                    0x00002000      
//#define DO_POWER_INRUSH                     0x00004000      
//#define DO_LOW_PRIORITY_FILESYSTEM          0x00010000      
//#define DO_SUPPORTS_TRANSACTIONS            0x00040000      
//#define DO_FORCE_NEITHER_IO                 0x00080000      
//#define DO_VOLUME_DEVICE_OBJECT             0x00100000      
//#define DO_SYSTEM_SYSTEM_PARTITION          0x00200000      
//#define DO_SYSTEM_CRITICAL_PARTITION        0x00400000      
//#define DO_DISALLOW_EXECUTE                 0x00800000

#define FO_SYNCHRONOUS_IO               0x01
#define FO_NO_INTERMEDIATE_BUFFERING    0x04
#define FO_SEQUENTIAL_ONLY              0x08
#define FO_CLEANUP_COMPLETE             0x10
#define FO_HANDLE_CREATED               0x20
#define FO_RANDOM_ACCESS                0x40
#define FO_DISMOUNTED                   0x80

#define FO_SHARED_DELETE                0x02
#define FO_SHARED_WRITE                 0x04
#define FO_SHARED_READ                  0x08
#define FO_DELETE_ACCESS                0x10
#define FO_WRITE_ACCESS                 0x20
#define FO_READ_ACCESS                  0x40

// file object flags - windows flags just in case
//#define FO_FILE_OPEN						0x00000001
//#define FO_SYNCHRONOUS_IO					0x00000002
//#define FO_ALERTABLE_IO						0x00000004
//#define FO_NO_INTERMEDIATE_BUFFERING		0x00000008
//#define FO_WRITE_THROUGH					0x00000010
//#define FO_SEQUENTIAL_ONLY					0x00000020
//#define FO_CACHE_SUPPORTED					0x00000040
//#define FO_NAMED_PIPE						0x00000080
//#define FO_STREAM_FILE						0x00000100
//#define FO_MAILSLOT							0x00000200
//#define FO_GENERATE_AUDIT_ON_CLOSE			0x00000400
//#define FO_QUEUE_IRP_TO_THREAD				FO_GENERATE_AUDIT_ON_CLOSE
//#define FO_DIRECT_DEVICE_OPEN				0x00000800
//#define FO_FILE_MODIFIED					0x00001000
//#define FO_FILE_SIZE_CHANGED				0x00002000
//#define FO_CLEANUP_COMPLETE					0x00004000
//#define FO_TEMPORARY_FILE					0x00008000
//#define FO_DELETE_ON_CLOSE					0x00010000
//#define FO_OPENED_CASE_SENSITIVE			0x00020000
//#define FO_HANDLE_CREATED					0x00040000
//#define FO_FILE_FAST_IO_READ				0x00080000
//#define FO_RANDOM_ACCESS					0x00100000
//#define FO_FILE_OPEN_CANCELLED				0x00200000
//#define FO_VOLUME_OPEN						0x00400000
//#define FO_REMOTE_ORIGIN					0x01000000
//#define FO_DISALLOW_EXCLUSIVE				0x02000000
//#define FO_SKIP_COMPLETION_PORT				FO_DISALLOW_EXCLUSIVE
//#define FO_SKIP_SET_EVENT					0x04000000
//#define FO_SKIP_SET_FAST_IO					0x08000000
//#define FO_INDIRECT_WAIT_OBJECT				0x10000000
//#define FO_SECTION_MINSTORE_TREATMENT		0x20000000


// flags for characteristics of IoCreateDevice, most likely not valid for x360
#define FILE_REMOVABLE_MEDIA                        0x00000001
#define FILE_READ_ONLY_DEVICE                       0x00000002
#define FILE_FLOPPY_DISKETTE                        0x00000004
#define FILE_WRITE_ONCE_MEDIA                       0x00000008
#define FILE_REMOTE_DEVICE                          0x00000010
#define FILE_DEVICE_IS_MOUNTED                      0x00000020
#define FILE_VIRTUAL_VOLUME                         0x00000040
#define FILE_AUTOGENERATED_DEVICE_NAME              0x00000080
#define FILE_DEVICE_SECURE_OPEN                     0x00000100
#define FILE_CHARACTERISTIC_PNP_DEVICE              0x00000800
#define FILE_CHARACTERISTIC_TS_DEVICE               0x00001000
#define FILE_CHARACTERISTIC_WEBDAV_DEVICE           0x00002000
#define FILE_CHARACTERISTIC_CSV                     0x00010000
#define FILE_DEVICE_ALLOW_APPCONTAINER_TRAVERSAL    0x00020000
#define FILE_PORTABLE_DEVICE                        0x00040000

// Define the create disposition values (pIrp->Tail.Overlay.CurrentStackLocation.Parameters.Create.Options >> 24)
#define FILE_SUPERSEDE                  0x00000000
#define FILE_OPEN                       0x00000001
#define FILE_CREATE                     0x00000002
#define FILE_OPEN_IF                    0x00000003
#define FILE_OVERWRITE                  0x00000004
#define FILE_OVERWRITE_IF               0x00000005
#define FILE_MAXIMUM_DISPOSITION        0x00000005

// create/open option flags
#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_REMOTE_INSTANCE               0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#define FILE_OPEN_REQUIRING_OPLOCK              0x00010000
#define FILE_DISALLOW_EXCLUSIVE                 0x00020000
#define FILE_SESSION_AWARE                      0x00040000

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000

//NTSTATUS
//XxxDispatchRead(
//				IN PDEVICE_OBJECT  DeviceObject,
//				IN PIRP  Irp
//				);

// INCOMPLETE!! DEVICE_TYPE
#define FILE_DEVICE_CD_ROM              0x00000002 // SataCdRomDriverObject
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003 // OdfxDriverObject
#define FILE_DEVICE_CONTROLLER          0x00000004 // SataCdRomDispatchIo
#define FILE_DEVICE_HDD	                0x00000007 // SataDiskDriverObject
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008 // nomnil FatwDriverObject FatxDriverObject RawxDriverObject HfspDriverObject
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014 // connectx 'smb' device
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_MASS_STORAGE        0x0000002d // MassIoDriverObject
#define FILE_DEVICE_MASS1				0x0000003a // MassIoDriverObject
#define FILE_DEVICE_MASS2				0x0000003e // MassIoDriverObject
#define FILE_DEVICE_SFCX				0x0000003c // SfcxDriverObject
#define FILE_DEVICE_STFS_FILE_SYSTEM	0x0000003d // StfsCreateDevice
#define FILE_DEVICE_SVOD_FILE_SYSTEM	0x00000040 // SvodCreateDevice
#define FILE_DEVICE_SFCX_MU				0x00000041 // SfcxMuDriverObject
#define FILE_DEVICE_PIAF_DEVICE			0x00000042 // PiafCreateDevice
#define FILE_DEVICE_OMNI_DEIVCE			0x00000043 // NomnilDriverEntry - wireless n
#define FILE_DEVICE_MASS3				0x00000044 // MassIoDriverObject
#define FILE_DEVICE_MASS4				0x00000045 // MassIoDriverObject
#define FILE_DEVICE_PIAF_FILE_SYSTEM	0x00000046 // PiafCreatePartition
#define FILE_DEVICE_DEV_AUTH			0x00000047 // DevAuthIoDriverObject
#define FILE_DEVICE_MMC_SYS				0x00000048 // MmcxInitializeDeviceExtension
#define FILE_DEVICE_MMC_MU				0x00000049 // MmcxMuMountStorage

#define CTL_CODE( DeviceType, Function, Method, Access ) (((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method))
#define CTL_CODE_DEVTYPE(Code)	((Code>>16)&0xFFFF)		// 0xFFFF0000
#define CTL_CODE_FUNCTION(Code)	((Code>>2)&0xFFF)		// 0x00003FFC
#define CTL_CODE_ACCESS(Code)	((Code>>14)&0x3)		// 0x0000C000 - buffered = 0, in direct = 1, out direct = 2, neither = 3
#define CTL_CODE_METHOD(Code)	(Code&0x3)				// 0x00000003 - any = 0, read = 1, write = 2

#define SCSI_CMD_TEST_UNIT_READY				0x00
#define SCSI_CMD_REQUEST_SENSE					0x03
#define SCSI_CMD_FORMAT_UNIT					0x04
#define SCSI_CMD_FORMAT_INQUIRY					0x12
#define SCSI_CMD_START_STOP_UNIT				0x1B
#define SCSI_CMD_PREVENT_ALLOW_MEDIUM_REMOVAL	0x1E
#define SCSI_CMD_READ_FORMAT_CAPACITIES			0x23
#define SCSI_CMD_READ_CAPACITY					0x25
#define SCSI_CMD_READ_10						0x28
#define SCSI_CMD_WRITE_10						0x2A
#define SCSI_CMD_SEEK_10						0x2B
#define SCSI_CMD_WRITE_AND_VERIFY_10			0x2E
#define SCSI_CMD_VERIFY_10						0x2F
#define SCSI_CMD_SYNCHRONIZE_CACHE				0x35
#define SCSI_CMD_WRITE_BUFFER					0x3B
#define SCSI_CMD_READ_BUFFER					0x3C
#define SCSI_CMD_READ_TOC_PMA_ATIP				0x43
#define SCSI_CMD_GET_CONFIGURATION				0x46
#define SCSI_CMD_GET_EVENT_STATUS_NOTIFICATION	0x4A
#define SCSI_CMD_READ_DISC_INFORMATION			0x51
#define SCSI_CMD_READ_TRACK_INFORMATION			0x52
#define SCSI_CMD_RESERVE_TRACK					0x53
#define SCSI_CMD_SEND_OPC_INFORMATION			0x54
#define SCSI_CMD_MODE_SELECT_10					0x55
#define SCSI_CMD_REPAIR_TRACK					0x58
#define SCSI_CMD_MODE_SENSE_10					0x5A
#define SCSI_CMD_CLOSE_TRACK_SESSION			0x5B
#define SCSI_CMD_READ_BUFFER_CAPACITY			0x5C
#define SCSI_CMD_SEND_CUE_SHEET					0x5D
#define SCSI_CMD_REPORT_LUNS					0xA0
#define SCSI_CMD_BLANK							0xA1
#define SCSI_CMD_SECURITY_PROTOCOL_IN			0xA2
#define SCSI_CMD_SEND_KEY						0xA3
#define SCSI_CMD_REPORT_KEY						0xA4
#define SCSI_CMD_LOAD_UNLOAD_MEDIUM				0xA6
#define SCSI_CMD_SET_READ_AHEAD					0xA7
#define SCSI_CMD_READ_12						0xA8
#define SCSI_CMD_WRITE_12						0xAA
#define SCSI_CMD_READ_MEDIA_SERIAL_NUMBER		0xAB
#define SCSI_CMD_GET_PERFORMANCE				0xAC
#define SCSI_CMD_READ_DISC_STRUCTURE			0xAD
#define SCSI_CMD_SECURITY_PROTOCOL_OUT			0xB5
#define SCSI_CMD_SET_STREAMING					0xB6
#define SCSI_CMD_READ_CD_MSF					0xB9
#define SCSI_CMD_SET_CD_SPEED					0xBB
#define SCSI_CMD_MECHANISM_STATUS				0xBD
#define SCSI_CMD_READ_CD 						0xBE
#define SCSI_CMD_SEND_DISC_STRUCTURE			0xBF

typedef VOID (NTAPI *PKNORMAL_ROUTINE)(
	IN		PVOID NormalContext OPTIONAL,
	IN		PVOID SystemArgument1 OPTIONAL,
	IN		PVOID SystemArgument2 OPTIONAL
	);

typedef VOID (NTAPI *PKRUNDOWN_ROUTINE)(
	IN		KAPC *Apc
	);

typedef VOID (NTAPI *PKKERNEL_ROUTINE)(
	IN		KAPC *Apc,
	IN OUT	PKNORMAL_ROUTINE *NormalRoutine OPTIONAL,
	IN OUT	PVOID *NormalContext OPTIONAL,
	IN OUT	PVOID *SystemArgument1 OPTIONAL,
	IN OUT	PVOID *SystemArgument2 OPTIONAL
	);

typedef struct _SCSI_PASS_THROUGH_DIRECT { 
	WORD Length; // 0x0 sz:0x2
	BYTE ScsiStatus; // 0x2 sz:0x1
	BYTE PathId; // 0x3 sz:0x1
	BYTE TargetId; // 0x4 sz:0x1
	BYTE Lun; // 0x5 sz:0x1
	BYTE CdbLength; // 0x6 sz:0x1
	BYTE DataIn; // 0x7 sz:0x1
	DWORD DataTransferLength; // 0x8 sz:0x4
	DWORD TimeOutValue; // 0xC sz:0x4
	void * DataBuffer; // 0x10 sz:0x4
	BYTE Cdb[0x10]; // 0x14 sz:0x10
} SCSI_PASS_THROUGH_DIRECT, *PSCSI_PASS_THROUGH_DIRECT; // size 36
C_ASSERT(sizeof(SCSI_PASS_THROUGH_DIRECT) == 0x24);

typedef enum {
	DriverQuiesceRundown = 0x0,
	DriverQuiesceStartup = 0x1,
	DriverShutdown = 0x2,
} KDRIVER_NOTIFICATION_TYPE;

// function location in array of u32's
typedef enum {
	DEVICEOB_Start = 0,
	DEVICEOB_Del,
	DEVICEOB_Dismount,
	DEVICEOB_FCreate,
	DEVICEOB_FClose,
	DEVICEOB_FRead,
	DEVICEOB_FWrite,
	DEVICEOB_FQuery,
	DEVICEOB_FSet,
	DEVICEOB_FFlush,
	DEVICEOB_FQueryVol,
	DEVICEOB_FDirCntrl,
	DEVICEOB_FDevCntrl,
	DEVICEOB_FCleanup,
} DEVICEOB_FUNS;

typedef struct _DVD_SPINDLE_SPEED_INFO { 
	DWORD CurrentSpeed; // 0x0 sz:0x4
	DWORD MaximumSpeed; // 0x4 sz:0x4
	DWORD FastestSpeed; // 0x8 sz:0x4
	DWORD DesiredSpeed; // 0xC sz:0x4
} DVD_SPINDLE_SPEED_INFO, *PDVD_SPINDLE_SPEED_INFO; // size 16
C_ASSERT(sizeof(DVD_SPINDLE_SPEED_INFO) == 0x10);

typedef struct _XGD2_GET_DRIVE_INFO { 
	DWORD HashTableIndexLBA; // 0x0 sz:0x4 from security sector
	BYTE BCADescriptor; // 0x4 sz:0x1
	BYTE CacheFlags; // 0x5 sz:0x1 based on disk type 0,1,2,3,4 - I've only seen 3 on game disks
	BYTE Reserved[0x2]; // 0x6 sz:0x2
	DWORD LastDiscAuthTime; // 0x8 sz:0x4 time in ticks it took to auth the disk
	DWORD Layer0Length; // 0xC sz:0x4 calculated from security sector, 0x1000 byte sector size
	DWORD Layer1Length; // 0x10 sz:0x4 calculated from security sector, 0x1000 byte sector size
	BYTE HashValueOfTable[0x14]; // 0x14 sz:0x14 from security sector
} XGD2_GET_DRIVE_INFO, *PXGD2_GET_DRIVE_INFO; // size 40
C_ASSERT(sizeof(XGD2_GET_DRIVE_INFO) == 0x28);

typedef struct _XGD2_GET_TEST_INFO { 
	DWORD HashTableIndexLBA; // 0x0 sz:0x4
	BYTE BCADescriptor; // 0x4 sz:0x1
	BYTE Reserved[0x3]; // 0x5 sz:0x3
	DWORD LastDiscAuthTime; // 0x8 sz:0x4
} XGD2_GET_TEST_INFO, *PXGD2_GET_TEST_INFO; // size 12
C_ASSERT(sizeof(XGD2_GET_TEST_INFO) == 0xC);

// this probably isn't right/complete... but it works when dealing with drivers
typedef struct _DISK_GEOMETRY {
	DWORD Sectors; // 0x0 sz:0x4
	DWORD BytesPerSector; // 0x4 sz:0x4
} DISK_GEOMETRY, *PDISK_GEOMETRY; // size 8
C_ASSERT(sizeof(DISK_GEOMETRY) == 0x8);
/* // from MSDN
typedef struct _DISK_GEOMETRY {
LARGE_INTEGER Cylinders;
MEDIA_TYPE    MediaType;
DWORD         TracksPerCylinder;
DWORD         SectorsPerTrack;
DWORD         BytesPerSector;
} DISK_GEOMETRY;
*/

typedef struct _DUMMY_MUTEX { // example default values given
	BYTE Type; // 1 EventSynchronizationObject
	BYTE SpinCount; // 0
	BYTE Size; // 4
	BYTE Inserted; // 0
	DWORD SignalState; // 0
	LIST_ENTRY WaitListHead;
	LONG LockCount; // 0xFFFFFFFF or -1
	LONG RecursionCount; // 0
	HANDLE OwningThread; // 0
} DUMMY_MUTEX, *PDUMMY_MUTEX;
C_ASSERT(sizeof(DUMMY_MUTEX) == 0x1C);

#pragma warning(disable: 4115)
typedef VOID (KDRIVER_NOTIFICATION_ROUTINE)(
	IN		struct _KDRIVER_NOTIFICATION_REGISTRATION* Dpc
	);
typedef KDRIVER_NOTIFICATION_ROUTINE *PKDRIVER_NOTIFICATION_ROUTINE;
#pragma warning(default: 4115)

typedef struct _KDRIVER_NOTIFICATION_REGISTRATION { 
	PKDRIVER_NOTIFICATION_ROUTINE NotificationRoutine; // 0x0 sz:0x4
	long Priority; // 0x4 sz:0x4
	LIST_ENTRY ListEntry; // 0x8 sz:0x8
} KDRIVER_NOTIFICATION_REGISTRATION, *PKDRIVER_NOTIFICATION_REGISTRATION; // size 16
C_ASSERT(sizeof(KDRIVER_NOTIFICATION_REGISTRATION) == 0x10);

typedef struct _KDEVICE_QUEUE_ENTRY { 
	LIST_ENTRY DeviceListEntry; // 0x0 sz:0x8
	DWORD SortKey; // 0x8 sz:0x4
	BYTE Inserted; // 0xC sz:0x1
} KDEVICE_QUEUE_ENTRY, *PKDEVICE_QUEUE_ENTRY; // size 16
C_ASSERT(sizeof(KDEVICE_QUEUE_ENTRY) == 0x10);

typedef struct _KDEVICE_QUEUE{
	short Type; // 0x0 sz:0x2
	BYTE Padding; // 0x2 sz:0x1
	BYTE Busy; // 0x3 sz:0x1
	DWORD Lock; // 0x4 sz:0x4
	LIST_ENTRY DeviceListHead; // 0x8 sz:0x8
} KDEVICE_QUEUE, *PKDEVICE_QUEUE; // 16
C_ASSERT(sizeof(KDEVICE_QUEUE) == 16);

typedef struct _OBJECT_SYMBOLIC_LINK { 
	void * LinkTargetObject; // 0x0 sz:0x4
	STRING LinkTarget; // 0x4 sz:0x8
} OBJECT_SYMBOLIC_LINK, *POBJECT_SYMBOLIC_LINK; // size 12
C_ASSERT(sizeof(OBJECT_SYMBOLIC_LINK) == 0xC);

// the major functions
typedef enum IO_STACK_LOCATION_MJ_FUNCTIONS { // just a quick way to enum CurrentStackLocation.MajorFunction
	IOS_MJ_CREATE = 0,
	IOS_MJ_CLOSE = 1,
	IOS_MJ_READ = 2,
	IOS_MJ_WRITE = 3,
	IOS_MJ_QUERYINFO = 4,
	IOS_MJ_SETINFO = 5,
	IOS_MJ_FLUSHBUF = 6,
	IOS_MJ_QUERYVOLINFO = 7,
	IOS_MJ_DIRECTORYCTRL = 8,
	IOS_MJ_DEVICECTRL = 9,
	IOS_MJ_CLEANUP = 10,
};

typedef void (*DRIVERVOID)(void* pDeviceObject, void* pIrp);
typedef NTSTATUS (*DRIVERLONG)(void* pDeviceObject, void* pIrp);

typedef struct _DRIVER_OBJECT_FUNCTIONS{
	DRIVERLONG DObCreate;
	DRIVERLONG DObClose;
	DRIVERLONG DObRead;
	DRIVERLONG DObWrite;
	DRIVERLONG DObQueryInfo;
	DRIVERLONG DObSetInfo;
	DRIVERLONG DObFlushBuffers;
	DRIVERLONG DObQueryVolumeInfo;
	DRIVERLONG DObDirectoryControl;
	DRIVERLONG DObDeviceControl;
	DRIVERLONG DObCleanup;
} DRIVER_OBJECT_FUNCTIONS, *PDRIVER_OBJECT_FUNCTIONS;

typedef struct _DRIVER_OBJECT{
	DRIVERVOID DriverStartIo; // function pointers
	DRIVERVOID DriverDeleteDevice;
	DRIVERLONG DriverDismountVolume;
	union{
		DRIVERLONG MajorFunction[11];
		DRIVER_OBJECT_FUNCTIONS dObFuns;
	};
} DRIVER_OBJECT, *PDRIVER_OBJECT; //56
C_ASSERT(sizeof(DRIVER_OBJECT) == 56);

typedef void* (*OBJALLOCATE)(DWORD, DWORD, DWORD);
typedef void (*OBJFREE)(PVOID arg1);
typedef void (*OBJCLOSE)(PVOID arg1);
typedef void (*OBJDELETE)(PVOID arg1);
typedef NTSTATUS (*OBJPARSE)(PVOID cObj, PVOID argR4, PVOID argR5, PVOID argR6, LARGE_INTEGER* argR7, PVOID argR8, PVOID argR9); // incomplete!!!

typedef struct _OBJECT_TYPE { 
	OBJALLOCATE AllocateProcedure; // 0x0 sz:0x4		PVOID __stdcall ExAllocatePoolTypeWithTag(DWORD NumberOfBytes, DWORD Tag, POOL_TYPE PoolType)
	OBJFREE FreeProcedure; // 0x4 sz:0x4				VOID __stdcall ExFreePool(PVOID arg1)
	OBJCLOSE CloseProcedure; // 0x8 sz:0x4				VOID __stdcall ExFreePool(VOID arg1)
	OBJDELETE DeleteProcedure; // 0xC sz:0x4			VOID __stdcall ExFreePool(VOID arg1)
	OBJPARSE ParseProcedure; // 0x10 sz:0x4
	void * DefaultObject; // 0x14 sz:0x4
	DWORD PoolTag; // 0x18 sz:0x4
} OBJECT_TYPE, *POBJECT_TYPE; // size 28
C_ASSERT(sizeof(OBJECT_TYPE) == 0x1C);

typedef struct _IO_COMPLETION_CONTEXT{
	void * Port;
	void * Key;
} IO_COMPLETION_CONTEXT, *PIO_COMPLETION_CONTEXT;
C_ASSERT(sizeof(IO_COMPLETION_CONTEXT) == 8);

typedef struct _DEVICE_OBJECT { 
	SHORT Type; // 0x0 sz:0x2
	WORD Size; // 0x2 sz:0x2
	long ReferenceCount; // 0x4 sz:0x4
	PDRIVER_OBJECT DriverObject; // 0x8 sz:0x4
	struct _DEVICE_OBJECT * MountedOrSelfDevice; // 0xC sz:0x4
	void * CurrentIrp; // PIRP * 0x10 sz:0x4
	DWORD Flags; // 0x14 sz:0x4
	void * DeviceExtension; // 0x18 sz:0x4
	BYTE DeviceType; // 0x1C sz:0x1
	BYTE StartIoFlags; // 0x1D sz:0x1
	char StackSize; // 0x1E sz:0x1
	BYTE DeletePending; // 0x1F sz:0x1
	DWORD SectorSize; // 0x20 sz:0x4
	DWORD AlignmentRequirement; // 0x24 sz:0x4
	KDEVICE_QUEUE DeviceQueue; // 0x28 sz:0x10
	KEVENT DeviceLock; // 0x38 sz:0x10
	DWORD StartIoCount; // 0x48 sz:0x4
	DWORD StartIoKey; // 0x4C sz:0x4
} DEVICE_OBJECT, *PDEVICE_OBJECT; // size 80
C_ASSERT(sizeof(DEVICE_OBJECT) == 0x50);

typedef enum DVD_STRUCTURE_FORMAT {
	DvdPhysicalDescriptor,
	DvdCopyrightDescriptor,
	DvdDiskKeyDescriptor,
	DvdBCADescriptor,
	DvdManufacturerDescriptor,
	DvdMaxDescriptor
} DVD_STRUCTURE_FORMAT, *PDVD_STRUCTURE_FORMAT;

typedef struct _DVD_DESCRIPTOR_HEADER {
	WORD Length;
	BYTE Reserved[2];
	BYTE Data[0];
} DVD_DESCRIPTOR_HEADER, *PDVD_DESCRIPTOR_HEADER;

// *********** PACKING STARTS HERE **************//
#pragma pack(push, 1)
// *********** PACKING STARTS HERE **************//

typedef struct _DVD_LAYER_DESCRIPTOR {
	BYTE  BookVersion : 4;
	BYTE  BookType : 4;
	BYTE  MinimumRate : 4;
	BYTE  DiskSize : 4;
	BYTE  LayerType : 4;
	BYTE  TrackPath : 1;
	BYTE  NumberOfLayers : 2;
	BYTE  Reserved1 : 1;
	BYTE  TrackDensity : 4;
	BYTE  LinearDensity : 4;
	DWORD  StartingDataSector;
	DWORD  EndDataSector;
	DWORD  EndLayerZeroSector;
	BYTE  Reserved5 : 7;
	BYTE  BCAFlag : 1;
	BYTE  Reserved6;
} DVD_LAYER_DESCRIPTOR, *PDVD_LAYER_DESCRIPTOR;

typedef struct DVD_READ_STRUCTURE {
	LARGE_INTEGER  BlockByteOffset;
	DVD_STRUCTURE_FORMAT  Format;
	DWORD  SessionId;
	BYTE  LayerNumber;
} DVD_READ_STRUCTURE, *PDVD_READ_STRUCTURE;

typedef struct _SHARE_ACCESS { 
	BYTE OpenCount; // 0x0 sz:0x1
	BYTE Readers; // 0x1 sz:0x1
	BYTE Writers; // 0x2 sz:0x1
	BYTE Deleters; // 0x3 sz:0x1
	BYTE SharedRead; // 0x4 sz:0x1
	BYTE SharedWrite; // 0x5 sz:0x1
	BYTE SharedDelete; // 0x6 sz:0x1
} SHARE_ACCESS, *PSHARE_ACCESS; // size 7
C_ASSERT(sizeof(SHARE_ACCESS) == 0x7);

typedef struct _ERWLOCK { // for ExAcquireReadWriteLockExclusive
	int LockCount; // 0x0 sz:0x4
	DWORD WritersWaitingCount; // 0x4 sz:0x4
	DWORD ReadersWaitingCount; // 0x8 sz:0x4
	DWORD ReadersEntryCount; // 0xC sz:0x4
	KEVENT WriterEvent; // 0x10 sz:0x10
	KSEMAPHORE ReaderSemaphore; // 0x20 sz:0x14
	DWORD SpinLock; // 0x34 sz:0x4
} ERWLOCK, *PERWLOCK; // size 56
C_ASSERT(sizeof(ERWLOCK) == 0x38);

typedef struct _FILE_OBJECT { 
	SHORT Type; // 0x0 sz:0x2
	BYTE Flags; // 0x2 sz:0x1
	BYTE Flags2; // 0x3 sz:0x1
	PDEVICE_OBJECT DeviceObject; // 0x4 sz:0x4
	void * FsContext; // 0x8 sz:0x4
	void * FsContext2; // 0xC sz:0x4
	long FinalStatus; // 0x10 sz:0x4
	LARGE_INTEGER CurrentByteOffset; // 0x14 sz:0x8
	struct _FILE_OBJECT * RelatedFileObject; // 0x1C sz:0x4
	PIO_COMPLETION_CONTEXT CompletionContext; // 0x20 sz:0x4
	long LockCount; // 0x24 sz:0x4
	KEVENT Lock; // 0x28 sz:0x10
	KEVENT Event; // 0x38 sz:0x10
	LIST_ENTRY ProcessListEntry; // 0x48 sz:0x8
	LIST_ENTRY FileSystemListEntry; // 0x50 sz:0x8
	BYTE IoPriority; // 0x58 sz:0x1
	BYTE PoolPadding[0xF]; // 0x59 sz:0xF
} FILE_OBJECT, *PFILE_OBJECT; // size 104
C_ASSERT(sizeof(FILE_OBJECT) == 0x68);

typedef struct _IO_STACK_LOCATION_CREATE { 
	DWORD DesiredAccess; // 0x0 sz:0x4
	DWORD Options; // 0x4 sz:0x4
	WORD FileAttributes; // 0x8 sz:0x2
	WORD ShareAccess; // 0xA sz:0x2
	STRING * RemainingName; // 0xC sz:0x4
} IO_STACK_LOCATION_CREATE, *PIO_STACK_LOCATION_CREATE; // size 16
C_ASSERT(sizeof(IO_STACK_LOCATION_CREATE) == 0x10);

typedef struct _IO_STACK_LOCATION_READ { 
	DWORD Length; // 0x0 sz:0x4
	union {
		DWORD BufferOffset; // 0x4 sz:0x4
		void * CacheBuffer; // 0x4 sz:0x4
	};
	LARGE_INTEGER ByteOffset; // 0x8 sz:0x8
} IO_STACK_LOCATION_READ, *PIO_STACK_LOCATION_READ; // size 16
C_ASSERT(sizeof(IO_STACK_LOCATION_READ) == 0x10);

typedef struct _IO_STACK_LOCATION_WRITE { 
	DWORD Length; // 0x0 sz:0x4
	union {
		DWORD BufferOffset; // 0x4 sz:0x4
		void * CacheBuffer; // 0x4 sz:0x4
	};
	LARGE_INTEGER ByteOffset; // 0x8 sz:0x8
} IO_STACK_LOCATION_WRITE, *PIO_STACK_LOCATION_WRITE; // size 16
C_ASSERT(sizeof(IO_STACK_LOCATION_WRITE) == 0x10);

typedef struct _IO_STACK_LOCATION_QUERYDIRECTORY { 
	DWORD Length; // 0x0 sz:0x4
	STRING * FileName; // 0x4 sz:0x4
} IO_STACK_LOCATION_QUERYDIRECTORY, *PIO_STACK_LOCATION_QUERYDIRECTORY; // size 8
C_ASSERT(sizeof(IO_STACK_LOCATION_QUERYDIRECTORY) == 0x8);

typedef struct _IO_STACK_LOCATION_QUERYFILE { 
	DWORD Length; // 0x0 sz:0x4
	FILE_INFORMATION_CLASS FileInformationClass; // 0x4 sz:0x4
} IO_STACK_LOCATION_QUERYFILE, *PIO_STACK_LOCATION_QUERYFILE; // size 8
C_ASSERT(sizeof(IO_STACK_LOCATION_QUERYFILE) == 0x8);

typedef struct _IO_STACK_LOCATION_SETFILE { 
	DWORD Length; // 0x0 sz:0x4
	FILE_INFORMATION_CLASS FileInformationClass; // 0x4 sz:0x4
	PFILE_OBJECT FileObject; // 0x8 sz:0x4
} IO_STACK_LOCATION_SETFILE, *PIO_STACK_LOCATION_SETFILE; // size 12
C_ASSERT(sizeof(IO_STACK_LOCATION_SETFILE) == 0xC);

typedef struct _IO_STACK_LOCATION_QUERYVOLUME { 
	DWORD Length; // 0x0 sz:0x4
	FSINFOCLASS FsInformationClass; // 0x4 sz:0x4
} IO_STACK_LOCATION_QUERYVOLUME, *PIO_STACK_LOCATION_QUERYVOLUME; // size 8
C_ASSERT(sizeof(IO_STACK_LOCATION_QUERYVOLUME) == 0x8);

typedef struct _IO_STACK_LOCATION_SETVOLUME { 
	DWORD Length; // 0x0 sz:0x4
	FSINFOCLASS FsInformationClass; // 0x4 sz:0x4
} IO_STACK_LOCATION_SETVOLUME, *PIO_STACK_LOCATION_SETVOLUME; // size 8
C_ASSERT(sizeof(IO_STACK_LOCATION_QUERYVOLUME) == 0x8);

typedef struct _IO_STACK_LOCATION_DEVICEIOCONTROL { 
	DWORD OutputBufferLength; // 0x0 sz:0x4
	void * InputBuffer; // 0x4 sz:0x4
	DWORD InputBufferLength; // 0x8 sz:0x4
	DWORD IoControlCode; // 0xC sz:0x4
} IO_STACK_LOCATION_DEVICEIOCONTROL, *PIO_STACK_LOCATION_DEVICEIOCONTROL; // size 16
C_ASSERT(sizeof(IO_STACK_LOCATION_DEVICEIOCONTROL) == 0x10);

typedef struct _IO_STACK_LOCATION_SECTORIO { 
	DWORD Length; // 0x0 sz:0x4
	BYTE * Buffer; // 0x4 sz:0x4
	DWORD SectorNumber; // 0x8 sz:0x4
	DWORD BufferOffset; // 0xC sz:0x4
} IO_STACK_LOCATION_SECTORIO, *PIO_STACK_LOCATION_SECTORIO; // size 16
C_ASSERT(sizeof(IO_STACK_LOCATION_SECTORIO) == 0x10);

typedef struct _IO_STACK_LOCATION_OTHERS { 
	void * Argument1; // 0x0 sz:0x4
	void * Argument2; // 0x4 sz:0x4
	void * Argument3; // 0x8 sz:0x4
	void * Argument4; // 0xC sz:0x4
} IO_STACK_LOCATION_OTHERS, *PIO_STACK_LOCATION_OTHERS; // size 16
C_ASSERT(sizeof(IO_STACK_LOCATION_OTHERS) == 0x10);

typedef union _UIO_STACK_LOCATION_PARMS { 
	IO_STACK_LOCATION_CREATE Create; // 0x0 sz:0x10
	IO_STACK_LOCATION_READ Read; // 0x0 sz:0x10
	IO_STACK_LOCATION_WRITE Write; // 0x0 sz:0x10
	IO_STACK_LOCATION_QUERYDIRECTORY QueryDirectory; // 0x0 sz:0x8
	IO_STACK_LOCATION_QUERYFILE QueryFile; // 0x0 sz:0x8
	IO_STACK_LOCATION_SETFILE SetFile; // 0x0 sz:0xC
	IO_STACK_LOCATION_QUERYVOLUME QueryVolume; // 0x0 sz:0x8
	IO_STACK_LOCATION_SETVOLUME SetVolume; // 0x0 sz:0x8
	IO_STACK_LOCATION_DEVICEIOCONTROL DeviceIoControl; // 0x0 sz:0x10
	IO_STACK_LOCATION_SECTORIO SectorIo; // 0x0 sz:0x10
	IO_STACK_LOCATION_OTHERS Others; // 0x0 sz:0x10
} UIO_STACK_LOCATION_PARMS, *PUIO_STACK_LOCATION_PARMS; // size 16
C_ASSERT(sizeof(UIO_STACK_LOCATION_PARMS) == 0x10);

typedef struct _IO_STACK_LOCATION { 
	BYTE MajorFunction; // 0x0 sz:0x1
	BYTE MinorFunction; // 0x1 sz:0x1
	BYTE Flags; // 0x2 sz:0x1
	BYTE Control; // 0x3 sz:0x1
	UIO_STACK_LOCATION_PARMS Parameters; // 0x4 sz:0x10
	PDEVICE_OBJECT DeviceObject; // 0x14 sz:0x4
	PFILE_OBJECT FileObject; // 0x18 sz:0x4
	void * CompletionRoutine; // 0x1C sz:0x4	function long(*)()
	void * Context; // 0x20 sz:0x4
} IO_STACK_LOCATION, *PIO_STACK_LOCATION; // size 36
C_ASSERT(sizeof(IO_STACK_LOCATION) == 0x24);

// *********** PACKING ENDS HERE **************//
#pragma pack(pop)
// *********** PACKING ENDS HERE **************//

typedef struct _IRP_ASYNC_PARAM { 
	void * UserApcRoutine; // 0x0 sz:0x4 function void(*)()
	void * UserApcContext; // 0x4 sz:0x4
} IRP_ASYNC_PARAM, *PIRP_ASYNC_PARAM; // size 8
C_ASSERT(sizeof(IRP_ASYNC_PARAM) == 0x8);

typedef union _UIRP_OVERLAY { 
	IRP_ASYNC_PARAM AsynchronousParameters; // 0x0 sz:0x8
	LARGE_INTEGER AllocationSize; // 0x0 sz:0x8
} UIRP_OVERLAY, *PUIRP_OVERLAY; // size 8
C_ASSERT(sizeof(UIRP_OVERLAY) == 0x8);

typedef struct _IRP_OVERLAY {
	union{
		KDEVICE_QUEUE_ENTRY DeviceQueueEntry; // 0x0 sz:0x10
		LIST_ENTRY DeviceListEntry; // 0x0 sz:0x8
		void * DriverContext[4]; // 0x0 sz:0x10
	};
	DWORD LockedBufferLength; // 0x10 sz:0x4
	PKTHREAD Thread; // 0x14 sz:0x4
	LIST_ENTRY ListEntry; // 0x18 sz:0x8
	union{
		PIO_STACK_LOCATION CurrentStackLocation; // 0x20 sz:0x4
		DWORD PacketType; // 0x20 sz:0x4
	};
	PFILE_OBJECT OriginalFileObject; // 0x24 sz:0x4
} IRP_OVERLAY, *PIRP_OVERLAY; // size 40
C_ASSERT(sizeof(IRP_OVERLAY) == 0x28);

typedef union _UIRP_TAIL { 
	IRP_OVERLAY Overlay; // 0x0 sz:0x28
	KAPC Apc; // 0x0 sz:0x28
	void * CompletionKey; // 0x0 sz:0x4
} UIRP_TAIL, *PUIRP_TAIL; // size 40
C_ASSERT(sizeof(UIRP_TAIL) == 0x28);

typedef struct _IRP { 
	SHORT Type; // 0x0 sz:0x2
	USHORT Size; // 0x2 sz:0x2
	DWORD Flags; // 0x4 sz:0x4
	LIST_ENTRY ThreadListEntry; // 0x8 sz:0x8
	IO_STATUS_BLOCK IoStatus; // 0x10 sz:0x8
	char StackCount; // 0x18 sz:0x1
	char CurrentLocation; // 0x19 sz:0x1
	BYTE PendingReturned; // 0x1A sz:0x1
	BYTE Cancel; // 0x1B sz:0x1
	void * UserBuffer; // 0x1C sz:0x4
	PIO_STATUS_BLOCK UserIosb; // 0x20 sz:0x4
	PKEVENT UserEvent; // 0x24 sz:0x4
	UIRP_OVERLAY Overlay; // 0x28 sz:0x8
	UIRP_TAIL Tail; // 0x30 sz:0x28
	void * CancelRoutine; // 0x58 sz:0x4  function void(*)()
} IRP, *PIRP; // size 96
C_ASSERT(sizeof(IRP) == 0x60);


// some structs relevant to PCI
typedef struct _PCI_CONF_HDR {
	SHORT DeviceID; // 0
	SHORT VendorID; // 2
	SHORT Status; // 4
	SHORT Command; // 6
	BYTE ClassBase; // 7
	BYTE ClassSub; // 8
	BYTE ClassIf; // 9
	// BYTE Class[3]; // 8 sz 0x3
	BYTE RevisionID; // 0xB
	BYTE BIST; // 0xC
	BYTE HType; // 0xD
	BYTE LatencyTmr; // 0xE
	BYTE CachelineSz; // 0xF
} PCI_CONF_HDR, *PPCI_CONF_HDR;
C_ASSERT(sizeof(PCI_CONF_HDR) == 0x10);

typedef struct _PCI_TYPE_0 {
	PCI_CONF_HDR conf; // 0 sz 0x10
	DWORD BAR[6]; // 0x10 sz 0x18
	DWORD CarbusCIS; // 0x28
	SHORT SubsysID; // 0x2C
	SHORT SubsysVID; // 0x2E
	DWORD ExROMBase; // 0x30
	BYTE Reserved[3]; // 0x34, 0x35, 0x36 sz 3
	BYTE capPtr; // 0x37
	DWORD Reserved2; // 0x38
	BYTE max_lat; // 0x3C
	BYTE min_gnt; // 0x3D
	BYTE int_pin; // 0x3E
	BYTE int_line; // 0x3F
} PCI_TYPE_0, *PPCI_TYPE_0;
C_ASSERT(sizeof(PCI_TYPE_0) == 0x40);

typedef struct _PCI_TYPE_1 {
	PCI_CONF_HDR conf; // 0 sz 0x10
	DWORD BAR[2]; // 0x10 sz 0x8
	BYTE secLatencyTmr; // 0x18
	BYTE subBusNum; // 0x19
	BYTE secBusNum; // 0x1a
	BYTE primBusNum; // 0x1b
	SHORT secStatus; // 0x1c
	BYTE ioLimit; // 0x1e
	BYTE ioBase; // 0x1f
	SHORT memLim; // 0x20
	SHORT memBase; // 0x22
	SHORT prefMemLim; // 0x24
	SHORT prefMemBase; // 0x26
	DWORD prefBaseUpper; // 0x28
	DWORD prefLimUpper; // 0x2C
	SHORT ioLimitUpper; // 0x30
	SHORT ioBaseUpper; // 0x32
	BYTE reserved[3]; // 0x34, 0x35, 0x36 sz 3
	BYTE capPtr; // 0x37
	DWORD ExROMBase; // 0x38
	SHORT bridgeCntrl; // 0x3C
	BYTE int_pin; // 0x3E
	BYTE int_line; // 0x3F
} PCI_TYPE_1, *PPCI_TYPE_1;
C_ASSERT(sizeof(PCI_TYPE_1) == 0x40);




#endif // __KEDRIVER_H

```

`XenonDumper/libs/xkelib/kernel/keFileInfo.h`:

```h
#ifndef __KEFILEINFO_H
#define __KEFILEINFO_H

typedef enum _FILE_INFORMATION_CLASS
{
	FileDirectoryInformation = 0x1,
	FileFullDirectoryInformation = 0x2,
	FileBothDirectoryInformation = 0x3,
	FileBasicInformation = 0x4, // FILE_BASIC_INFORMATION below
	FileStandardInformation = 0x5,
	FileInternalInformation = 0x6,
	FileEaInformation = 0x7,
	FileAccessInformation = 0x8,
	FileNameInformation = 0x9,
	FileRenameInformation = 0xa,
	FileLinkInformation = 0xb,
	FileNamesInformation = 0xc,
	FileDispositionInformation = 0xd, // use sdk FILE_DISPOSITION_INFO
	FilePositionInformation = 0xe, // FILE_POSITION_INFORMATION below
	FileFullEaInformation = 0xf,
	FileModeInformation = 0x10,
	FileAlignmentInformation = 0x11,
	FileAllInformation = 0x12,
	FileAllocationInformation = 0x13, // use sdk FILE_ALLOCATION_INFO
	FileEndOfFileInformation = 0x14, // use sdk FILE_END_OF_FILE_INFO
	FileAlternateNameInformation = 0x15,
	FileStreamInformation = 0x16,
	FileMountPartitionInformation = 0x17,
	FileMountPartitionsInformation = 0x18,
	FilePipeRemoteInformation = 0x19,
	FileSectorInformation = 0x1a,
	FileXctdCompressionInformation = 0x1b,
	FileCompressionInformation = 0x1c,
	FileObjectIdInformation = 0x1d,
	FileCompletionInformation = 0x1e,
	FileMoveClusterInformation = 0x1f,
	FileIoPriorityInformation = 0x20,
	FileReparsePointInformation = 0x21,
	FileNetworkOpenInformation = 0x22,
	FileAttributeTagInformation = 0x23,
	FileTrackingInformation = 0x24,
	FileMaximumInformation = 0x25
} FILE_INFORMATION_CLASS;

typedef enum _FSINFOCLASS {
	FileFsVolumeInformation = 0x1,
	FileFsLabelInformation = 0x2,
	FileFsSizeInformation = 0x3,
	FileFsDeviceInformation = 0x4,
	FileFsAttributeInformation = 0x5,
	FileFsControlInformation = 0x6,
	FileFsFullSizeInformation = 0x7,
	FileFsObjectIdInformation = 0x8,
	FileFsMaximumInformation = 0x9,
} FSINFOCLASS;

//  *******   structs for the data passed with the above classes when using NtSetInformationFile/NtQueryInformationFile

// class FileDirectoryInformation = 0x1
typedef struct _FILE_DIRECTORY_INFORMATION { 
	DWORD NextEntryOffset; // 0x0 sz:0x4
	DWORD FileIndex; // 0x4 sz:0x4
	LARGE_INTEGER CreationTime; // 0x8 sz:0x8
	LARGE_INTEGER LastAccessTime; // 0x10 sz:0x8
	LARGE_INTEGER LastWriteTime; // 0x18 sz:0x8
	LARGE_INTEGER ChangeTime; // 0x20 sz:0x8
	LARGE_INTEGER EndOfFile; // 0x28 sz:0x8
	LARGE_INTEGER AllocationSize; // 0x30 sz:0x8
	DWORD FileAttributes; // 0x38 sz:0x4
	DWORD FileNameLength; // 0x3C sz:0x4
	char FileName[1]; // 0x40 sz:0x1
} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION; // size 72
C_ASSERT(sizeof(FILE_DIRECTORY_INFORMATION) == 0x48);

// class FilePositionInformation = 0xd
typedef struct FILE_POSITION_INFORMATION { // query/set
	LARGE_INTEGER  CurrentByteOffset;
} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;

// class FileBasicInformation = 0x4
typedef struct _FILE_BASIC_INFORMATION {
	LARGE_INTEGER CreationTime;
	LARGE_INTEGER LastAccessTime;
	LARGE_INTEGER LastWriteTime;
	LARGE_INTEGER ChangeTime;
	DWORD FileAttributes;
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;

// returned by a call to 'NtQueryInformationFile' with 0x22 = FileNetworkOpenInformation
typedef struct _FILE_NETWORK_OPEN_INFORMATION { 
	LARGE_INTEGER CreationTime; // 0x0 sz:0x8
	LARGE_INTEGER LastAccessTime; // 0x8 sz:0x8
	LARGE_INTEGER LastWriteTime; // 0x10 sz:0x8
	LARGE_INTEGER ChangeTime; // 0x18 sz:0x8
	LARGE_INTEGER AllocationSize; // 0x20 sz:0x8
	LARGE_INTEGER EndOfFile; // 0x28 sz:0x8
	DWORD FileAttributes; // 0x30 sz:0x4
} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION; // size 56
C_ASSERT(sizeof(FILE_NETWORK_OPEN_INFORMATION) == 0x38);

//  *******   structs related to FSINFOCLASS for use with NtQueryVolumeInformationFile

// class FileFsVolumeInformation = 0x1
typedef struct _FILE_FS_VOLUME_INFORMATION { 
	LARGE_INTEGER VolumeCreationTime; // 0x0 sz:0x8
	DWORD VolumeSerialNumber; // 0x8 sz:0x4
	DWORD VolumeLabelLength; // 0xC sz:0x4
	BYTE SupportsObjects; // 0x10 sz:0x1
	BYTE VolumeLabel[1]; // 0x11 sz:0x1
} FILE_FS_VOLUME_INFORMATION, *PFILE_FS_VOLUME_INFORMATION; // size 24
C_ASSERT(sizeof(FILE_FS_VOLUME_INFORMATION) == 0x18);

// class FileFsLabelInformation = 0x2
typedef struct _FILE_FS_LABEL_INFORMATION { 
	DWORD VolumeLabelLength; // 0x0 sz:0x4
	BYTE VolumeLabel[1]; // 0x4 sz:0x1
} FILE_FS_LABEL_INFORMATION, *PFILE_FS_LABEL_INFORMATION; // size 8
C_ASSERT(sizeof(FILE_FS_LABEL_INFORMATION) == 0x8);

// class FileFsSizeInformation = 0x3
typedef struct _FILE_FS_SIZE_INFORMATION { 
	LARGE_INTEGER TotalAllocationUnits; // 0x0 sz:0x8
	LARGE_INTEGER AvailableAllocationUnits; // 0x8 sz:0x8
	DWORD SectorsPerAllocationUnit; // 0x10 sz:0x4
	DWORD BytesPerSector; // 0x14 sz:0x4
} FILE_FS_SIZE_INFORMATION, *PFILE_FS_SIZE_INFORMATION; // size 24
C_ASSERT(sizeof(FILE_FS_SIZE_INFORMATION) == 0x18);

// class FileFsDeviceInformation = 0x4
typedef struct _FILE_FS_DEVICE_INFORMATION { 
	DWORD DeviceType; // 0x0 sz:0x4
	DWORD Characteristics; // 0x4 sz:0x4
} FILE_FS_DEVICE_INFORMATION, *PFILE_FS_DEVICE_INFORMATION; // size 8
C_ASSERT(sizeof(FILE_FS_DEVICE_INFORMATION) == 0x8);

// class FileFsAttributeInformation = 0x5
typedef struct _FILE_FS_ATTRIBUTE_INFORMATION { 
	DWORD FileSystemAttributes; // 0x0 sz:0x4
	DWORD MaximumComponentNameLength; // 0x4 sz:0x4
	DWORD FileSystemNameLength; // 0x8 sz:0x4
	BYTE FileSystemName[1]; // 0xC sz:0x1
} FILE_FS_ATTRIBUTE_INFORMATION, *PFILE_FS_ATTRIBUTE_INFORMATION; // size 16
C_ASSERT(sizeof(FILE_FS_ATTRIBUTE_INFORMATION) == 0x10);

// class FileFsControlInformation = 0x6
typedef struct _FILE_FS_CONTROL_INFORMATION { 
	LARGE_INTEGER FreeSpaceStartFiltering; // 0x0 sz:0x8
	LARGE_INTEGER FreeSpaceThreshold; // 0x8 sz:0x8
	LARGE_INTEGER FreeSpaceStopFiltering; // 0x10 sz:0x8
	LARGE_INTEGER DefaultQuotaThreshold; // 0x18 sz:0x8
	LARGE_INTEGER DefaultQuotaLimit; // 0x20 sz:0x8
	DWORD FileSystemControlFlags; // 0x28 sz:0x4
} FILE_FS_CONTROL_INFORMATION, *PFILE_FS_CONTROL_INFORMATION; // size 48
C_ASSERT(sizeof(FILE_FS_CONTROL_INFORMATION) == 0x30);

// class FileFsFullSizeInformation = 0x7
typedef struct _FILE_FS_FULL_SIZE_INFORMATION { 
	LARGE_INTEGER TotalAllocationUnits; // 0x0 sz:0x8
	LARGE_INTEGER CallerAvailableAllocationUnits; // 0x8 sz:0x8
	LARGE_INTEGER ActualAvailableAllocationUnits; // 0x10 sz:0x8
	DWORD SectorsPerAllocationUnit; // 0x18 sz:0x4
	DWORD BytesPerSector; // 0x1C sz:0x4
} FILE_FS_FULL_SIZE_INFORMATION, *PFILE_FS_FULL_SIZE_INFORMATION; // size 32
C_ASSERT(sizeof(FILE_FS_FULL_SIZE_INFORMATION) == 0x20);

// class FileFsObjectIdInformation = 0x8
typedef struct _FILE_FS_OBJECTID_INFORMATION { 
	BYTE ObjectId[0x10]; // 0x0 sz:0x10
	BYTE ExtendedInfo[0x30]; // 0x10 sz:0x30
} FILE_FS_OBJECTID_INFORMATION, *PFILE_FS_OBJECTID_INFORMATION; // size 64
C_ASSERT(sizeof(FILE_FS_OBJECTID_INFORMATION) == 0x40);


#endif // __KEFILEINFO_H


```

`XenonDumper/libs/xkelib/kernel/keNand.h`:

```h
#ifndef __KENAND_H
#define __KENAND_H

typedef struct _BLDR_HEADER{
	WORD Magic;
	WORD Build;
	WORD Qfe;
	WORD Flags;
	DWORD Entry;
	DWORD Size;
} BLDR_HEADER, *PBLDR_HEADER;
C_ASSERT(sizeof(BLDR_HEADER) == 0x10);

typedef struct _BLDR_FLASH{ // magic 0xFF4f
	BLDR_HEADER blHeader; // 0
	char achCopyright[0x40]; // 0x10
	BYTE abReserved[0x10]; // 0x50	0x0 filled
	DWORD dwKeyVaultSize; // 0x60	size of the keyvault
	DWORD dwSysUpdateAddr; // 0x64	offset to first cf
	WORD wSysUpdateCount; // 0x68	number of patch slots
	WORD wKeyVaultVersion; // 0x6A	0x0712
	DWORD dwKeyVaultAddr; // 0x6C	offset of the keyvault from 0
	DWORD dwPatchSlotSize; // 0x70	if == 0 then = 0x10000, patch slot size 
	DWORD dwSmcConfigAddr; // 0x74	0x0
	DWORD dwSmcBootSize; // 0x78	size of smc.bin
	DWORD dwSmcBootAddr; // 0x7C	offset of smc.bin from 0
} BLDR_FLASH, *PBLDR_FLASH;
C_ASSERT(sizeof(BLDR_FLASH) == 0x80);

#endif // __KENAND_H

```

`XenonDumper/libs/xkelib/kernel/kePrivateStructs.h`:

```h
#ifndef __KEPRIVATESTRUCTS_H
#define __KEPRIVATESTRUCTS_H

/* **** FIXME ****
_OBJECT_HANDLE_TABLE
_KTHREAD
*/

/* HalReadArgonEeprom read on a falcon jtag at 14719
ArgonEepromErrorBitfield: ret 0x0 read 0x7	: 00 00 00 00 04 00 00
ArgonEepromV12P0		: ret 0x0 read 0x8	: BB 1B B1 13 00 4A 5D 01
ArgonEepromAll			: ret 0x0 read 0x10	: 0F 00 00 00 00 04 00 00 BB 1B B1 13 00 4A 5D 01 */
typedef enum {
	ArgonEepromErrorBitfield = 0x0, // buf size 0xC
	ArgonEepromV12P0 = 0x1, // buf size 8
	ArgonEepromAll = 0x2,
} ARGON_EEPROM_FIELD;

// for KeGetCurrentProcessType()
typedef enum  {
	PROC_IDLE = 0,
	PROC_USER = 1,
	PROC_SYSTEM = 2,
	PROC_DEBUG = 3,
} _KPROC_TYPE;

typedef enum {
	EventNotificationObject = 0x0,
	EventSynchronizationObject = 0x1,
	MutantObject = 0x2,
	ProcessObject = 0x3,
	QueueObject = 0x4,
	SemaphoreObject = 0x5,
	ThreadObject = 0x6,
	Spare1Object = 0x7, // ExAcquireReadWriteLockExclusive
	TimerNotificationObject = 0x8,
	TimerSynchronizationObject = 0x9,
	Spare2Object = 0xA,
	Spare3Object = 0xB,
	Spare4Object = 0xC,
	Spare5Object = 0xD,
	Spare6Object = 0xE,
	Spare7Object = 0xF,
	Spare8Object = 0x10,
	Spare9Object = 0x11,
	ApcObject = 0x12,
	DpcObject = 0x13,
	DeviceQueueObject = 0x14,
	EventPairObject = 0x15,
	InterruptObject = 0x16,
	ProfileObject = 0x17,
} KOBJECTS;

typedef enum {
	NotificationTimer = 0x0,
	SynchronizationTimer = 0x1,
} TIMER_TYPE;

typedef enum {
	Executive = 0x0,
	DelayExecution = 0x1,
	Suspended = 0x2,
	UserRequest = 0x3,
	WrQueue = 0x4,
	WrFsCacheIn = 0x5,
	WrFsCacheOut = 0x6,
	WrReadWriteLock = 0x7,
	WrCriticalSection = 0x8,
	MaximumWaitReason = 0x9,
} KWAIT_REASON;

typedef enum {
	KernelMode = 0x0,
	UserMode = 0x1,
	MaximumMode = 0x2,
} WAIT_MODE;

typedef WAIT_MODE		KPROCESSOR_MODE;

// for 32 bit version splitting/creating
#pragma pack(push, 1)
typedef union _XBOX32VER {
	struct {
	unsigned char Major : 4;
	unsigned char Minor : 4;
	unsigned short Build;
	unsigned char Qfe;
	};
	DWORD asULong;
} XBOX32VER, *PXBOX32VER;
#pragma pack(pop)

typedef ULONG_PTR KIPI_BROADCAST_WORKER (
	__in ULONG_PTR Argument
	);
typedef KIPI_BROADCAST_WORKER *PKIPI_BROADCAST_WORKER;

#pragma warning(disable: 4115)
typedef VOID (KDEFERRED_ROUTINE)(
	IN		struct _KDPC* Dpc,
	IN		PVOID DeferredContext OPTIONAL,
	IN		PVOID SystemArgument1 OPTIONAL,
	IN		PVOID SystemArgument2 OPTIONAL
	);
typedef KDEFERRED_ROUTINE *PKDEFERRED_ROUTINE;

typedef BOOLEAN (NTAPI KSERVICE_ROUTINE)(
	IN		struct _KINTERRUPT *Interrupt,
	IN		PVOID ServiceContext
	);
typedef KSERVICE_ROUTINE *PKSERVICE_ROUTINE;
#pragma warning(default: 4115)

//typedef struct _DISPLAY_INFO{
//	WORD timing1; // 0x0
//	WORD timing2; // 0x2
//	BYTE colorspace; // 0x4
//	BYTE colorformat; // 0x5
//	BYTE padb_1[2]; // 0x6 pad
//	DWORD pitch; // 0x8
//	DWORD format; // 0xC
//	DWORD offsetx; // 0x10
//	DWORD offsety; // 0x14
//	DWORD sw; // 0x18
//	DWORD sh; // 0x1c
//	DWORD dwUnk1;
//	BYTE baUnk1[12];
//	DWORD dwUnk2;
//	BYTE baUnk2[12];
//	WORD waUnk1[6]; // last two may be important
//	DWORD dwAsFloat; // is a float?
//	DWORD dwUnk3;
//	BYTE padb_2[2]; //pad
//	WORD wUnk1;	
//} DISPLAY_INFO, *PDISPLAY_INFO; // total size 0x58 bytes
//C_ASSERT(sizeof(DISPLAY_INFO) == 88);
typedef struct _D3DPRIVATE_RECT {
	LONG x1, y1;
	LONG x2, y2;
} D3DPRIVATE_RECT, *PD3DPRIVATE_RECT;

typedef struct _D3DFILTER_PARAMETERS {
	FLOAT Nyquist;
	FLOAT FlickerFilter;
	FLOAT Beta;
} D3DFILTER_PARAMETERS, *PD3DFILTER_PARAMETERS;

typedef struct _D3DPRIVATE_SCALER_PARAMETERS {
	D3DPRIVATE_RECT		 ScalerSourceRect;
	LONG				 ScaledOutputWidth;
	LONG				 ScaledOutputHeight;
	DWORD				 VirticalFilterType;
	D3DFILTER_PARAMETERS VerticalFilterParameters;
	DWORD				 HorizontalFilterType;
	D3DFILTER_PARAMETERS HorizontalFilterParameters;
} D3DPRIVATE_SCALER_PARAMETERS, *PD3DPRIVATE_SCALER_PARAMETERS;

typedef struct _DISPLAY_INFORMATION {
	WORD						 FrontBufferWidth; // 0 sz 2
	WORD						 FrontBufferHeight; // 0x2 sz 2
	BYTE						 FrontBufferColorFormat; // 0x4 sz 1
	BYTE						 FrontBufferPixelFormat; // 0x5 sz 1
	D3DPRIVATE_SCALER_PARAMETERS ScalerParameters;  // 0x sz 2
	WORD						 DisplayWindowOverscanLeft; // 0x sz 2
	WORD						 DisplayWindowOverscanTop; // 0x sz 2
	WORD						 DisplayWindowOverscanRight; // 0x sz 2
	WORD						 DisplayWindowOverscanBottom; // 0x sz 2
	WORD						 DisplayWidth; // 0x sz 2
	WORD						 DisplayHeight; // 0x sz 2
	FLOAT						 DisplayRefreshRate; // 0x sz 8
	DWORD						 DisplayInterlaced; // 0x sz 4
	BYTE						 DisplayColorFormat; // 0x sz 1
	WORD						 ActualDisplayWidth; // 0x sz 2
} DISPLAY_INFO, *PDISPLAY_INFO;
C_ASSERT(sizeof(DISPLAY_INFO) == 0x58);

// *********** PACKING STARTS HERE **************//
#pragma pack(push, 1)
// *********** PACKING STARTS HERE **************//

typedef enum XboxMemoryRegionFlags{ // for MmQueryAddressProtect
	NoAccess = 0x1,
	ReadOnly = 0x2,
	ReadWrite = 0x4,
	WriteCopy = 0x8,
	Execute = 0x10,
	ExecuteRead = 0x20,
	ExecuteReadWrite = 0x40,
	ExecuteWriteCopy = 0x80,
	Guard = 0x100,
	NoCache = 0x200,
	WriteCombine = 0x400,
	UserReadOnly = 0x1000,
	UserReadWrite = 0x2000
};

typedef struct _MM_STATISTICS{
	DWORD Length;
	DWORD TotalPhysicalPages;
	DWORD KernelPages;
	DWORD TitleAvailablePages;
	DWORD TitleTotalVirtualMemoryBytes;
	DWORD TitleReservedVirtualMemoryBytes;
	DWORD TitlePhysicalPages;
	DWORD TitlePoolPages;
	DWORD TitleStackPages;
	DWORD TitleImagePages;
	DWORD TitleHeapPages;
	DWORD TitleVirtualPages;
	DWORD TitlePageTablePages;
	DWORD TitleCachePages;
	DWORD SystemAvailablePages;
	DWORD SystemTotalVirtualMemoryBytes;
	DWORD SystemReservedVirtualMemoryBytes;
	DWORD SystemPhysicalPages;
	DWORD SystemPoolPages;
	DWORD SystemStackPages;
	DWORD SystemImagePages;
	DWORD SystemHeapPages;
	DWORD SystemVirtualPages;
	DWORD SystemPageTablePages;
	DWORD SystemCachePages;
	DWORD HighestPhysicalPage;
} MM_STATISTICS, *PMMSTATISTICS; // 104
C_ASSERT(sizeof(MM_STATISTICS) == 104);

typedef struct _KINTERRUPT { 
	PKSERVICE_ROUTINE ServiceRoutine; // VOID(*)() 0x0 sz:0x4
	PVOID ServiceContext; // 0x4 sz:0x4
	DWORD SpinLock; // 0x8 sz:0x4
	DWORD ServiceCount; // 0xC sz:0x4
	BYTE BusIrql; // 0x10 sz:0x1
	BYTE Irql; // 0x11 sz:0x1
	BYTE Connected : 1; // 0x12 bfo:0x7
	BYTE Mode : 7; // 0x12 bfo:0x0
// 	BYTE ModeConnected;
	BYTE TargetNumber; // 0x13 sz:0x1
} KINTERRUPT, *PKINTERRUPT; // size 20
C_ASSERT(sizeof(KINTERRUPT) == 0x14);

typedef struct _KTRAP_FRAME { 
	STACK_FRAME_HEADER Header; // 0x0 sz:0x50
	QWORD Gpr0; // 0x50 sz:0x8
	QWORD Gpr1; // 0x58 sz:0x8
	QWORD Gpr2; // 0x60 sz:0x8
	QWORD Gpr3; // 0x68 sz:0x8
	QWORD Gpr4; // 0x70 sz:0x8
	QWORD Gpr5; // 0x78 sz:0x8
	QWORD Gpr6; // 0x80 sz:0x8
	QWORD Gpr7; // 0x88 sz:0x8
	QWORD Gpr8; // 0x90 sz:0x8
	QWORD Gpr9; // 0x98 sz:0x8
	QWORD Gpr10; // 0xA0 sz:0x8
	QWORD Gpr11; // 0xA8 sz:0x8
	QWORD Gpr12; // 0xB0 sz:0x8
	QWORD Gpr13; // 0xB8 sz:0x8
	QWORD Gpr14; // 0xC0 sz:0x8
	QWORD Gpr15; // 0xC8 sz:0x8
	QWORD Gpr16; // 0xD0 sz:0x8
	QWORD Gpr17; // 0xD8 sz:0x8
	QWORD Gpr18; // 0xE0 sz:0x8
	QWORD Gpr19; // 0xE8 sz:0x8
	QWORD Gpr20; // 0xF0 sz:0x8
	QWORD Gpr21; // 0xF8 sz:0x8
	QWORD Gpr22; // 0x100 sz:0x8
	QWORD Gpr23; // 0x108 sz:0x8
	QWORD Gpr24; // 0x110 sz:0x8
	QWORD Gpr25; // 0x118 sz:0x8
	QWORD Gpr26; // 0x120 sz:0x8
	QWORD Gpr27; // 0x128 sz:0x8
	QWORD Gpr28; // 0x130 sz:0x8
	QWORD Gpr29; // 0x138 sz:0x8
	QWORD Gpr30; // 0x140 sz:0x8
	QWORD Gpr31; // 0x148 sz:0x8
	union{
		struct{
			BYTE OldIrql;
			PKINTERRUPT InterruptObject;
			BYTE InterruptIrql;
		} asIrq;
		BYTE ExceptionRecord[0x50];
	} irqExc;
	QWORD Ctr; // 0x1A0 sz:0x8
	DWORD Lr; // 0x1A8 sz:0x4
	DWORD Iar; // 0x1AC sz:0x4
	DWORD Cr; // 0x1B0 sz:0x4
	DWORD Msr; // 0x1B4 sz:0x4
	DWORD Xer; // 0x1B8 sz:0x4
	DWORD UserModeControl; // 0x1BC sz:0x4
} KTRAP_FRAME, *PKTRAP_FRAME; // size 448
C_ASSERT(sizeof(KTRAP_FRAME) == 0x1C0);

typedef struct _KAPC { 
	SHORT Type; // 0x0 sz:0x2
	BYTE ApcMode; // 0x2 sz:0x1
	BYTE Inserted; // 0x3 sz:0x1
	struct _KTHREAD * Thread; // 0x4 sz:0x4
	LIST_ENTRY ApcListEntry; // 0x8 sz:0x8
	void * KernelRoutine; // 0x10 sz:0x4  function void(*)()
	void * RundownRoutine; // 0x14 sz:0x4  function void(*)()
	void * NormalRoutine; // 0x18 sz:0x4  function void(*)()
	void * NormalContext; // 0x1C sz:0x4
	void * SystemArgument1; // 0x20 sz:0x4
	void * SystemArgument2; // 0x24 sz:0x4
} KAPC, *PKAPC; // size 40
C_ASSERT(sizeof(KAPC) == 0x28);

typedef struct _DISPATCHER_HEADER { 
	BYTE Type; // 0x0 sz:0x1
	BYTE Absolute; // 0x1 sz:0x1
	BYTE ProcessType; // 0x2 sz:0x1
	BYTE Inserted; // 0x3 sz:0x1
	LONG SignalState; // 0x4 sz:0x4
	LIST_ENTRY WaitListHead; // 0x8 sz:0x8
} DISPATCHER_HEADER, *PDISPATCHER_HEADER; // size 16
C_ASSERT(sizeof(DISPATCHER_HEADER) == 0x10);

typedef struct _KEVENT { 
	DISPATCHER_HEADER Header; // 0x0 sz:0x10
} KEVENT, *PKEVENT; // size 16
C_ASSERT(sizeof(KEVENT) == 0x10);

typedef struct _KDPC { 
	SHORT Type; // 0x0 sz:0x2
	BYTE InsertedNumber; // 0x2 sz:0x1
	BYTE TargetNumber; // 0x3 sz:0x1
	LIST_ENTRY DpcListEntry; // 0x4 sz:0x8
	PKDEFERRED_ROUTINE DeferredRoutine; // 0xC sz:0x4
	void * DeferredContext; // 0x10 sz:0x4
	void * SystemArgument1; // 0x14 sz:0x4
	void * SystemArgument2; // 0x18 sz:0x4
} KDPC, *PKDPC; // size 28
C_ASSERT(sizeof(KDPC) == 0x1C);

typedef struct _KWAIT_BLOCK {
	LIST_ENTRY WaitListEntry; // 0x0 sz:0x8
	struct _KTHREAD* Thread; // 0x8 sz:0x4
	void * Object; // 0xC sz:0x4
	struct _KWAIT_BLOCK * NextWaitBlock; // 0x10 sz:0x4
	WORD WaitKey; // 0x14 sz:0x2
	WORD WaitType; // 0x16 sz:0x2
} KWAIT_BLOCK, *PKWAIT_BLOCK; // size 24
C_ASSERT(sizeof(KWAIT_BLOCK) == 0x18);

typedef struct _KTIMER { 
	DISPATCHER_HEADER Header; // 0x0 sz:0x10
	ULARGE_INTEGER DueTime; // 0x10 sz:0x8
	LIST_ENTRY TimerListEntry; // 0x18 sz:0x8
	PKDPC Dpc; // 0x20 sz:0x4
	long Period; // 0x24 sz:0x4
} KTIMER, *PKTIMER; // size 40
C_ASSERT(sizeof(KTIMER) == 0x28);

typedef struct _KPROCESS { 
	DWORD ThreadListLock; // 0x0 sz:0x4
	LIST_ENTRY ThreadListHead; // 0x4 sz:0x8
	LONG ThreadQuantum; // 0xC sz:0x4
	DWORD DirectoryTableBase; // 0x10 sz:0x4
	DWORD ThreadCount; // 0x14 sz:0x4
	BYTE IdlePriorityClass; // 0x18 sz:0x1
	BYTE NormalPriorityClass; // 0x19 sz:0x1
	BYTE TimeCriticalPriorityClass; // 0x1A sz:0x1
	BYTE DisableQuantum; // 0x1B sz:0x1
	DWORD DefaultKernelStackSize; // 0x1C sz:0x4
	void * TlsStaticDataImage; // 0x20 sz:0x4
	DWORD SizeOfTlsStaticData; // 0x24 sz:0x4
	DWORD SizeOfTlsStaticDataImage; // 0x28 sz:0x4
	WORD SizeOfTlsSlots; // 0x2C sz:0x2
	BYTE Terminating; // 0x2E sz:0x1
	BYTE ProcessType; // 0x2F sz:0x1
	DWORD TlsSlotBitmap[0x8]; // 0x30 sz:0x20
	DWORD FileObjectListLock; // 0x50 sz:0x4
	LIST_ENTRY FileObjectListHead; // 0x54 sz:0x8
	void * Win32DefaultHeapHandle; // 0x5C sz:0x4
} KPROCESS, *PKPROCESS; // size 96
C_ASSERT(sizeof(KPROCESS) == 0x60);

typedef struct _KSEMAPHORE { 
	DISPATCHER_HEADER Header; // 0x0 sz:0x10
	LONG Limit; // 0x10 sz:0x4
} KSEMAPHORE, *PKSEMAPHORE; // size 20
C_ASSERT(sizeof(KSEMAPHORE) == 0x14);

typedef struct _KQUEUE { 
	DISPATCHER_HEADER Header; // 0x0 sz:0x10
	LIST_ENTRY EntryListHead; // 0x10 sz:0x8
	DWORD CurrentCount; // 0x18 sz:0x4
	DWORD MaximumCount; // 0x1C sz:0x4
	LIST_ENTRY ThreadListHead; // 0x20 sz:0x8
} KQUEUE, *PKQUEUE; // size 40
C_ASSERT(sizeof(KQUEUE) == 0x28);

// *********** PACKING ENDS HERE **************//
#pragma pack(pop)
// *********** PACKING ENDS HERE **************//

typedef struct _KPRCB { 
	struct _KTHREAD* CurrentThread; // 0x0 sz:0x4
	struct _KTHREAD* NextThread; // 0x4 sz:0x4
	struct _KTHREAD* IdleThread; // 0x8 sz:0x4
	BYTE Number; // 0xC sz:0x1
	DWORD SetMember; // 0x10 sz:0x4
	DWORD DpcTime; // 0x14 sz:0x4
	DWORD InterruptTime; // 0x18 sz:0x4
	DWORD InterruptCount; // 0x1C sz:0x4
	volatile DWORD IpiFrozen; // 0x20 sz:0x4
	volatile DWORD CurrentPacket[3]; // 0x24 sz:0xC
	DWORD TargetSet; // 0x30 sz:0x4
	PVOID WorkerRoutine; // 0x34 sz:0x4 Function Pointer
	struct _KPRCB* SignalDone; // 0x38 sz:0x4
	DWORD RequestSummary; // 0x3C sz:0x4
	DWORD DpcInterruptRequested; // 0x40 sz:0x4
	DWORD DpcLock; // 0x44 sz:0x4
	LIST_ENTRY DpcListHead; // 0x48 sz:0x8
	DWORD DpcRoutineActive; // 0x50 sz:0x4
	DWORD ReadyListLock; // 0x54 sz:0x4
	DWORD IdleThreadActive; // 0x58 sz:0x4
	SINGLE_LIST_ENTRY DeferredReadyListHead; // 0x5C sz:0x4
	DWORD ReadySummary; // 0x60 sz:0x4
	DWORD ReadySummaryMask; // 0x64 sz:0x4
	LIST_ENTRY DispatcherReadyListHead[32]; // 0x68 sz:0x100
	KDPC ThreadReaperDpc; // 0x168 sz:0x1C
	LIST_ENTRY ThreadReaperListHead; // 0x184 sz:0x8
	KDPC SwitchProcessorThreadDpc; // 0x18C sz:0x1C
} KPRCB, *PKPRCB; // size 424
C_ASSERT(sizeof(KPRCB) == 0x1A8);

typedef struct _KTHREAD { 
	DISPATCHER_HEADER Header; // 0x0 sz:0x10
	LIST_ENTRY MutantListHead; // 0x10 sz:0x8
	KTIMER Timer; // 0x18 sz:0x28
	KWAIT_BLOCK TimerWaitBlock; // 0x40 sz:0x18
	DWORD KernelTime; // 0x58 sz:0x4
	PVOID StackBase; // 0x5C sz:0x4
	PVOID StackLimit; // 0x60 sz:0x4
	PVOID KernelStack; // 0x64 sz:0x4
	PVOID TlsData; // 0x68 sz:0x4
	BYTE State; // 0x6C sz:0x1
	BYTE Alerted[2]; // 0x6D sz:0x2
	BYTE Alertable; // 0x6F sz:0x1
	BYTE Priority; // 0x70 sz:0x1
	BYTE FpuExceptionEnable; // 0x71 sz:0x1
	BYTE CreateProcessType; // 0x72 sz:0x1
	BYTE CurrentProcessType; // 0x73 sz:0x1
	LIST_ENTRY ApcListHead[2]; // 0x74 sz:0x10
	PKPROCESS Process; // 0x84 sz:0x4
	BYTE KernelApcInProgress; // 0x88 sz:0x1
	BYTE KernelApcPending; // 0x89 sz:0x1
	BYTE UserApcPending; // 0x8A sz:0x1
	BYTE ApcQueueable; // 0x8B sz:0x1
	DWORD ApcQueueLock; // 0x8C sz:0x4
	DWORD ContextSwitches; // 0x90 sz:0x4
	LIST_ENTRY ReadyListEntry; // 0x94 sz:0x8
	union {
		struct {
			WORD MsrEnableMaskHigh; // 0x9C sz:0x2
			WORD MsrEnableMaskLow; // 0x9E sz:0x2
		} hilo;
		DWORD MsrEnableMask; // 0x9C sz:0x4
	} Msr;
	LONG WaitStatus; // 0xA0 sz:0x4
	BYTE WaitIrql; // 0xA4 sz:0x1
	BYTE WaitMode; // 0xA5 sz:0x1
	BYTE WaitNext; // 0xA6 sz:0x1
	BYTE WaitReason; // 0xA7 sz:0x1
	PKWAIT_BLOCK WaitBlockList; // 0xA8 sz:0x4
	DWORD Padding1; // 0xAC sz:0x4
	DWORD KernelApcDisable; // 0xB0 sz:0x4
	LONG Quantum; // 0xB4 sz:0x4
	char Saturation; // 0xB8 sz:0x1
	BYTE BasePriority; // 0xB9 sz:0x1
	BYTE PriorityDecrement; // 0xBA sz:0x1
	BYTE DisableBoost; // 0xBB sz:0x1
	char SuspendCount; // 0xBC sz:0x1
	BYTE Preempted; // 0xBD sz:0x1
	BYTE HasTerminated; // 0xBE sz:0x1
	BYTE CurrentProcessor; // 0xBF sz:0x1
	PKPRCB CurrentPrcb; // 0xC0 sz:0x4
	PKPRCB AffinityPrcb; // 0xC4 sz:0x4
	BYTE IdlePriorityClass; // 0xC8 sz:0x1
	BYTE NormalPriorityClass; // 0xC9 sz:0x1
	BYTE TimeCriticalPriorityClass; // 0xCA sz:0x1
	BYTE HasAsyncTerminated; // 0xCB sz:0x1
	DWORD ActiveTimerListLock; // 0xCC sz:0x4
	PVOID StackAllocatedBase; // 0xD0 sz:0x4
	KAPC SuspendApc; // 0xD4 sz:0x28
	KSEMAPHORE SuspendSemaphore; // 0xFC sz:0x14
	LIST_ENTRY ThreadListEntry; // 0x110 sz:0x8
	PKQUEUE Queue; // 0x118 sz:0x4
	LIST_ENTRY QueueListEntry; // 0x11C sz:0x8
	PVOID UserModeDispatcher; // 0x124 sz:0x4  Function Pointer
	PKTRAP_FRAME UserModeTrapFrame; // 0x128 sz:0x4
	LARGE_INTEGER CreateTime; // 0x130 sz:0x8
	LARGE_INTEGER ExitTime; // 0x138 sz:0x8
	LONG ExitStatus; // 0x140 sz:0x4
	LIST_ENTRY ActiveTimerListHead; // 0x144 sz:0x8
	PVOID ThreadId; // 0x14C sz:0x4
	PVOID StartAddress; // 0x150 sz:0x4 Function Pointer
	struct _LIST_ENTRY IrpList; // 0x154 sz:0x8
	PVOID DebugMonitorData; // 0x15C sz:0x4
	DWORD LastWin32ErrorCode; // 0x160 sz:0x4
	PVOID Win32CurrentFiber; // 0x164 sz:0x4
	DWORD Padding2; // 0x168 sz:0x4
	DWORD CreateOptions; // 0x16C sz:0x4
	float Vscr[4]; // 0x170 sz:0x10
	float Vr[4][128]; // 0x180 sz:0x800
	double Fpscr; // 0x980 sz:0x8
	double Fpr[32]; // 0x988 sz:0x100
	KAPC TerminateApc; // 0xA88 sz:0x28
} KTHREAD, *PKTHREAD; // size 2736
//C_ASSERT(sizeof(KTHREAD) == 0xAB0);

// *********** PACKING STARTS HERE **************//
#pragma pack(push, 1)
// *********** PACKING STARTS HERE **************//

//KPCR is %r13 (pointer)
//PKPCR __declspec(naked) GetThread_KPCR(VOID)
//{
//	asm{
//		mr		r3, r13
//		blr
//	}
//}

typedef struct _KPCR { 
	PVOID TlsData; // 0x0 sz:0x4
	union {
		struct {
			WORD MsrEnableMaskHigh; // 0x4 sz:0x2
			WORD MsrEnableMaskLow; // 0x6 sz:0x2
		} hilo;
		DWORD MsrEnableMask; // 0x4 sz:0x4
	} Msr;
	union {
		struct {
			BYTE DispatchInterrupt; // 0x8 sz:0x1
			BYTE ApcInterrupt; // 0x9 sz:0x1
		} hard;
		WORD SoftwareInterrupt; // 0x8 sz:0x2
	} Int;
	union {
		struct {
			BYTE DpcFpuStateSaved; // 0xA sz:0x1
			BYTE DpcVpuStateSaved; // 0xB sz:0x1
		} sep;
		WORD DpcFpuVpuStateSaved; // 0xA sz:0x2
	} Dpc;
	BYTE DpcCurrentProcessType; // 0xC sz:0x1
	BYTE QuantumEnd; // 0xD sz:0x1
	BYTE TimerRequest; // 0xE sz:0x1
	BYTE HvCr0Save; // 0xF sz:0x1
	PKTHREAD FpuOwnerThread; // 0x10 sz:0x4
	PKTHREAD VpuOwnerThread; // 0x14 sz:0x4
	BYTE CurrentIrql; // 0x18 sz:0x1
	BYTE BackgroundSchedulingActive; // 0x19 sz:0x1
	union {
		struct {
			BYTE StartBackgroundScheduling; // 0x1A sz:0x1
			BYTE StopBackgroundScheduling; // 0x1B sz:0x1
		} sep;
		WORD StartStopBackgroundScheduling; // 0x1A sz:0x2
	} Sched;
	DWORD TimerHand; // 0x1C sz:0x4
	union{
		struct{
			QWORD LrIarSave; // 0x20 sz:0x8
			QWORD CrMsrSave; // 0x28 sz:0x8
			QWORD Gpr13Save; // 0x30 sz:0x8
		} gpSave;
		struct{
			DWORD Gpr1Restore; // 0x20 sz:0x4
			DWORD IarRestore; // 0x24 sz:0x4
			DWORD CrRestore; // 0x28 sz:0x4
			DWORD MsrRestore; // 0x2C sz:0x4
		} gpRest;
	};
	QWORD HvGpr1Save; // 0x38 sz:0x8
	QWORD HvGpr3Save; // 0x40 sz:0x8
	QWORD HvGpr4Save; // 0x48 sz:0x8
	QWORD HvGpr5Save; // 0x50 sz:0x8
	DWORD UserModeControl; // 0x58 sz:0x4
	PVOID PanicStack; // 0x5C sz:0x4
	DWORD DarSave; // 0x60 sz:0x4
	DWORD DsisrSave; // 0x64 sz:0x4
	PVOID DbgLastDpcRoutine; // 0x68 sz:0x4
	DWORD OnInterruptStack; // 0x6C sz:0x4
	PVOID StackBase; // 0x70 sz:0x4
	PVOID StackLimit; // 0x74 sz:0x4
	PVOID InterruptStackBase; // 0x78 sz:0x4
	PVOID InterruptStackLimit; // 0x7C sz:0x4
	PVOID InterruptRoutine[0x20]; // 0x80 sz:0x80
	KPRCB PrcbData; // 0x100 sz:0x1A8
	PKPRCB Prcb; // 0x2A8 sz:0x4
	DWORD Unused; // 0x2AC sz:0x4
	PDWORD PixCurrent; // 0x2B0 sz:0x4
	PDWORD PixLimit; // 0x2B4 sz:0x4
	PDWORD ProfilerCurrent; // 0x2B8 sz:0x4
	PDWORD ProfilerLimit; // 0x2BC sz:0x4
	DWORD ProfilerFlags; // 0x2C0 sz:0x4
	QWORD Contention; // 0x2C8 sz:0x8 -> XProfilerContentionFlag 0x1
	PDWORD MonitorProfileData; // 0x2D0 sz:0x4
	// PcIdleThreadData 0x300
} KPCR, *PKPCR; // size 728
//C_ASSERT(sizeof(KPCR) == 0x2D8);

typedef union _KPCR_PAGE {
	struct{
		KPCR Pcr; // 0x0 sz:0x2D8
		QWORD IdleThreadData[ANYSIZE_ARRAY]; // 0x300 sz:0x0
	} AsSeparate;
	BYTE PcrAsUCHARs[4096]; // 0x0 sz:0x1000
} KPCR_PAGE, *PKPCR_PAGE; // size 4096
C_ASSERT(sizeof(KPCR_PAGE) == 0x1000);
// *********** PACKING ENDS HERE **************//
#pragma pack(pop)
// *********** PACKING ENDS HERE **************//

typedef struct _KSPECIAL_REGISTERS { 
	DWORD KernelDr0; // 0x0 sz:0x4
	DWORD KernelDr1; // 0x4 sz:0x4
	DWORD KernelDr2; // 0x8 sz:0x4
	DWORD KernelDr3; // 0xC sz:0x4
	DWORD KernelDr4; // 0x10 sz:0x4
	DWORD KernelDr5; // 0x14 sz:0x4
	DWORD KernelDr6; // 0x18 sz:0x4
	DWORD KernelDr7; // 0x1C sz:0x4
} KSPECIAL_REGISTERS, *PKSPECIAL_REGISTERS; // size 32
C_ASSERT(sizeof(KSPECIAL_REGISTERS) == 0x20);

typedef struct _KPROCESSOR_STATE { 
	CONTEXT ContextFrame; // 0x0 sz:0xA40
	KSPECIAL_REGISTERS SpecialRegisters; // 0xA40 sz:0x20
} KPROCESSOR_STATE, *PKPROCESSOR_STATE; // size 2656
C_ASSERT(sizeof(KPROCESSOR_STATE) == 0xA60);


typedef struct _OBJECT_HANDLE_TABLE { 
	LONG HandleCount; // 0x0 sz:0x4
	DWORD FirstFreeTableOffset; // 0x4 sz:0x4
	DWORD TableAllocation; // 0x8 sz:0x4
	PVOID** RootTable; // 0xC sz:0x4
	PVOID* BuiltinRootTable[8]; // 0x10 sz:0x20
	DWORD SpinLock; // 0x30 sz:0x4
	BYTE PoolType; // 0x34 sz:0x1
	BYTE Discriminant; // 0x35 sz:0x1
	BYTE Terminating; // 0x36 sz:0x1
} OBJECT_HANDLE_TABLE, *POBJECT_HANDLE_TABLE; // size 56
C_ASSERT(sizeof(OBJECT_HANDLE_TABLE) == 0x38);



#endif // __KEPRIVATESTRUCTS_H

```

`XenonDumper/libs/xkelib/kernel/keSmc.h`:

```h
#ifndef __KESMC_H
#define __KESMC_H

// for HalRegisterSMCNotification
// messageCode 0x83 notifies of PayloadAsUCHARs[0]
// 0x23 - IR event (priority 0 only?)
// 0x60/0x66 - tray events
// 0x70 thermal shutdown event

typedef struct _HAL_SMC_REGISTRATION { 
	void* NotificationRoutine; // 0x0 sz:0x4 function: void Notify(PHAL_SMC_REGISTRATION SMCRegistration, PSMC_MAILBOX_MESSAGE NotificationMessage);
	long Priority; // 0x4 sz:0x4
	LIST_ENTRY ListEntry; // 0x8 sz:0x8
} HAL_SMC_REGISTRATION, *PHAL_SMC_REGISTRATION; // size 16
C_ASSERT(sizeof(HAL_SMC_REGISTRATION) == 0x10);

typedef struct _SMC_MAILBOX_MESSAGE { 
	BYTE MessageCode; // 0x0 sz:0x1
	BYTE PayloadAsUCHARs[0xF]; // 0x1 sz:0xF
} SMC_MAILBOX_MESSAGE, *PSMC_MAILBOX_MESSAGE; // size 16
C_ASSERT(sizeof(SMC_MAILBOX_MESSAGE) == 0x10);

typedef VOID (*SMCNOTIFYROUTINE)(PHAL_SMC_REGISTRATION SMCRegistration, PSMC_MAILBOX_MESSAGE NotificationMessage);

// result from using smc_query_tray or HalRegisterSMCNotification's PayloadAsUCHARs[0]
typedef enum _SMC_TRAY_STATE {
	SMC_TRAY_OPEN = 0x60,
	SMC_TRAY_OPEN_REQUEST = 0x61,
	SMC_TRAY_CLOSE = 0x62,
	SMC_TRAY_OPENING = 0x63,
	SMC_TRAY_CLOSING = 0x64,
	SMC_TRAY_UNKNOWN = 0x65,
	SMC_TRAY_SPINUP = 0x66,
} SMC_TRAY_STATE;

typedef enum SMC_CMD{
	smc_poweron_type = 0x1,
	smc_query_rtc = 0x4,
	smc_query_sensor = 0x7,
	smc_query_tray = 0xA,
	smc_query_avpack = 0xF,
	smc_i2c_read_write = 0x11,
	smc_query_version = 0x12,
	smc_fifo_test = 0x13,
	smc_query_ir_address = 0x16,
	smc_query_tilt_sensor = 0x17,
	smc_read_82_interrupts = 0x1e,
	smc_read_8E_interrupts = 0x20,
	smc_set_standby = 0x82,
	smc_set_time = 0x85,
	smc_set_fan_algorithm = 0x88,
	smc_set_fan_speed_CPU = 0x89,
	smc_set_dvd_tray = 0x8b,
	smc_set_power_led = 0x8c,
	smc_set_audio_mute = 0x8d,
	smc_argon_related = 0x90,
	smc_set_fan_speed_GPU = 0x94, // not present on slim, not used/respected on newer fat
	smc_set_ir_address = 0x95,
	smc_set_dvd_tray_secure = 0x98,
	smc_set_leds = 0x99,
	smc_set_rtc_wake = 0x9a,
	smc_ana_related = 0x9b,
	smc_set_async_operation= 0x9c,
	smc_set_82_interrupts = 0x9d,
	smc_set_9F_interrupts = 0x9f,
};

typedef enum SMC_PWR_REAS{
	SMC_PWR_REAS_11_PWRBTN		= 0x11, // xss5 power button pushed
	SMC_PWR_REAS_12_EJECT		= 0x12, // xss6 eject button pushed
		SMC_PWR_REAS_15_ALARM		= 0x15, // xss guess ~ should be the wake alarm ~
	SMC_PWR_REAS_20_REMOPWR 	= 0x20, // xss2 power button on 3rd party remote/ xbox universal remote
		SMC_PWR_REAS_21_REMOEJC 	= 0x21, // eject button on xbox universal remote
	SMC_PWR_REAS_22_REMOX		= 0x22, // xss3 xbox universal media remote X button
	SMC_PWR_REAS_24_WINBTN		= 0x24, // xss4 windows button pushed IR remote
		SMC_PWR_REAS_30_RESET		= 0x30, // xss HalReturnToFirmware(1 or 2 or 3) = hard reset by smc
		SMC_PWR_REAS_31_RECHARGE_RESET	= 0x31, // after leaving pnc charge mode via power button
	SMC_PWR_REAS_41_KIOSK 		= 0x41, // xss7 console powered on by kiosk pin
	SMC_PWR_REAS_55_WIRELESS 	= 0x55, // xss8 wireless controller middle button/start button pushed to power on controller and console
	SMC_PWR_REAS_56_WIRED_F1	= 0x56, // xss9 wired guide button; fat front top USB port, slim front left USB port
	SMC_PWR_REAS_57_WIRED_F2 	= 0x57, // xssA wired guide button; fat front botton USB port, slim front right USB port
	SMC_PWR_REAS_58_WIRED_R2	= 0x58, // xssB wired guide button; slim back middle USB port
	SMC_PWR_REAS_59_WIRED_R3	= 0x59, // xssC wired guide button; slim back top USB port
	SMC_PWR_REAS_5A_WIRED_R1	= 0x5A, // xssD wired guide button; fat back USB port, slim back bottom USB port
	// possibles/reboot reasons  0x23, 0x2A, 0x42, 0x61, 0x64

	// slim with wired controller when horozontal, 3 back usb ports top to bottom 0x59, 0x58, 0x5A front left 0x56, right 0x57
	// slim with wireless controller w/pnc when horozontal, 3 back usb ports top to bottom 0x55, 0x58, 0x5A front left 0x56, right 0x57
	// fat with wired controller when horozontal, 1 back usb port 0x5A front top 0x56, bottom 0x57
	// fat with wireless controller w/pnc when horozontal, 1 back usb port 0x5A front top 0x56, bottom 0x57
	// Using Microsoft Wireless Controller: 0x55
	// Using Madcatz Wireless Keyboard (Rockband 3 Keyboard - Item Number 98161): 0x55
	// Using Activision Wireless Turntable Controller (DJ Hero Turntable): 0x55
	// Using Drums Controller from Activision Guitar Hero Warriors of Rock: 0x55
	// Using Guitar controller from Activision Guitar Hero 5: 0x55
};


#endif // __KESMC_H

```

`XenonDumper/libs/xkelib/kernel/keXConfig.h`:

```h
// xconfig.h currently updated to 17150
#ifndef _XCONFIG_H
#define _XCONFIG_H

#ifndef __cplusplus
	// disable: warning C4214: nonstandard extension used : bit field types other than int
	#pragma warning(disable:4214)
#endif
/* these settings are located in mobile files and flash config as follows:
XCONFIG_STATIC_SETTINGS					smc config
XCONFIG_STATISTIC_SETTINGS				statistics.settings 0x0 for 0x600
XCONFIG_SECURED_SETTINGS				follows smc config for 0x200
XCONFIG_USER_SETTINGS					mobileB.dat at 0x0 for 0x1FD
XCONFIG_XNET_MACHINE_ACCOUNT_SETTINGS	mobileC.dat at 0x0 for 0x1F0
XCONFIG_XNET_PARAMETERS_SETTINGS		mobileB.dat at 0x400 for 0x1F0
XCONFIG_MEDIA_CENTER_SETTINGS			mobileD.dat at 0x0 for 0x74c
XCONFIG_CONSOLE_SETTINGS				mobileB.dat at 0x200 for 0x1ed
XCONFIG_DVD_SETTINGS					mobileE.dat at 0x0 for 0x298
XCONFIG_IPTV_SETTINGS					mobileB.dat at 0x600 for 0x200
XCONFIG_SYSTEM_SETTINGS					mobileE.dat at 0x400 for 0x20
XCONFIG_DEVKIT_SETTINGS					mobileE.dat at 0x600 for 0x1a
*/
//char* XConfigNames[] = { // names of categories
//	"XCONFIG_STATIC_CATEGORY", 
//	"XCONFIG_STATISTIC_CATEGORY", 
//	"XCONFIG_SECURED_CATEGORY", 
//	"XCONFIG_USER_CATEGORY", 
//	"XCONFIG_XNET_MACHINE_ACCOUNT_CATEGORY", 
//	"XCONFIG_XNET_PARAMETERS_CATEGORY", 
//	"XCONFIG_MEDIA_CENTER_CATEGORY", 
//	"XCONFIG_CONSOLE_CATEGORY", 
//	"XCONFIG_DVD_CATEGORY", 
//	"XCONFIG_IPTV_CATEGORY", 
//	"XCONFIG_SYSTEM_CATEGORY",
//	"XCONFIG_DEVKIT_CATEGORY"
//};

enum { // category enumerator
	//XCONFIG_CATEGORY_TYPES
	XCONFIG_STATIC_CATEGORY = 0x0,					//_XCONFIG_STATIC_SETTINGS
	XCONFIG_STATISTIC_CATEGORY = 0x1,				//_XCONFIG_STATISTIC_SETTINGS
	XCONFIG_SECURED_CATEGORY = 0x2,					//_XCONFIG_SECURED_SETTINGS
	XCONFIG_USER_CATEGORY = 0x3,					//_XCONFIG_USER_SETTINGS
	XCONFIG_XNET_MACHINE_ACCOUNT_CATEGORY = 0x4,	//_XCONFIG_XNET_SETTINGS
	XCONFIG_XNET_PARAMETERS_CATEGORY = 0x5,			//_XCONFIG_XNET_SETTINGS
	XCONFIG_MEDIA_CENTER_CATEGORY = 0x6,			//_XCONFIG_MEDIA_CENTER_SETTINGS
	XCONFIG_CONSOLE_CATEGORY = 0x7, 				//_XCONFIG_CONSOLE_SETTINGS
	XCONFIG_DVD_CATEGORY = 0x8, 					//_XCONFIG_DVD_SETTINGS
	XCONFIG_IPTV_CATEGORY = 0x9, 					//_XCONFIG_IPTV_SETTINGS
	XCONFIG_SYSTEM_CATEGORY = 0xa,					//_XCONFIG_SYSTEM_SETTINGS
	XCONFIG_DEVKIT_CATEGORY = 0xb,					//_XCONFIG_DEVKIT_SETTINGS
	XCONFIG_CATEGORY_MAX
};


#pragma warning(push)
#pragma warning(disable: 4201)  // unnamed struct/union
#pragma pack(push, 1)

/* **************************** _XCONFIG_SECURED_SETTINGS **************************** */
//XCONFIG_SECURED_ENTRIES
enum{
	XCONFIG_SECURED_DATA = 0x0,
	XCONFIG_SECURED_MAC_ADDRESS = 0x1,
	XCONFIG_SECURED_AV_REGION = 0x2,
	XCONFIG_SECURED_GAME_REGION = 0x3,
	XCONFIG_SECURED_DVD_REGION = 0x4,
	XCONFIG_SECURED_RESET_KEY = 0x5,
	XCONFIG_SECURED_SYSTEM_FLAGS = 0x6,
	XCONFIG_SECURED_POWER_MODE = 0x7,
	XCONFIG_SECURED_ONLINE_NETWORK_ID = 0x8,
	XCONFIG_SECURED_POWER_VCS_CONTROL = 0x9,
	XCONFIG_SECURED_MANUFACTURING_SERIAL_NUMBER = 0xA,
	XCONFIG_SECURED_ENTRIES_MAX
};

// _XCONFIG_SECURED_SETTINGS macros for key pointers
#define XK_SECURED_1(x) &x.MACAddress					// key 0x1 6 bytes
#define XK_SECURED_2(x) &x.AVRegion						// key 0x2 4 bytes
#define XK_SECURED_3(x) &x.GameRegion					// key 0x3 2 bytes
#define XK_SECURED_4(x) &x.DVDRegion					// key 0x4 4 bytes
#define XK_SECURED_5(x) &x.ResetKey						// key 0x5 4 bytes
#define XK_SECURED_6(x) &x.OnlineNetworkID				// key 0x8 4 bytes
#define XK_SECURED_7(x) &x.PowerMode					// key 0x7 2 bytes
#define XK_SECURED_8(x) &x.SystemFlags					// key 0x6 4 bytes
#define XK_SECURED_9(x) &x.PowerVcsControl				// key 0x9 2 bytes
#define XK_SECURED_A(x) &x.ManufacturingSerialNumber	// key 0xA 16 bytes

typedef struct _XCONFIG_POWER_MODE{ // used by _XCONFIG_SECURED_SETTINGS
	BYTE VIDDelta;
	BYTE Reserved;
} XCONFIG_POWER_MODE, *PXCONFIG_POWER_MODE;

typedef struct _XCONFIG_POWER_VCS_CONTROL{ // used by _XCONFIG_SECURED_SETTINGS
	USHORT Configured : 1;
	USHORT Reserved : 3;
	USHORT Full : 4;
	USHORT Quiet : 4;
	USHORT Fuse : 4;
} XCONFIG_POWER_VCS_CONTROL, *PXCONFIG_POWER_VCS_CONTROL; // 2 bytes

typedef struct _XCONFIG_SECURED_SETTINGS { 
	DWORD CheckSum; // 0x0 sz:0x4
	DWORD Version; // 0x4 sz:0x4
	char OnlineNetworkID[0x4]; // key 0x8 0x8 sz:0x4
	char Reserved1[0x4]; // 0xC sz:0x4
	char ManufacturingSerialNumber[0x10]; // key 0xA 0x10 sz:0x10
	UCHAR MACAddress[0x6]; // key 0x1 0x20 sz:0x6
	char Reserved3[0x2]; // 0x26 sz:0x2
	DWORD AVRegion; // key 0x2 0x28 sz:0x4
	USHORT GameRegion; // key 0x3 0x2C sz:0x2
	char Reserved4[0x6]; // 0x2E sz:0x6
	DWORD DVDRegion; // key 0x4 0x34 sz:0x4
	DWORD ResetKey; // key 0x5 0x38 sz:0x4
	DWORD SystemFlags; // key 0x6 0x3C sz:0x4
	XCONFIG_POWER_MODE PowerMode; // key 0x7 0x40 sz:0x2
	XCONFIG_POWER_VCS_CONTROL PowerVcsControl; // key 0x9 0x42 sz:0x2
	char ReservedRegion[0x1BC]; // 0x44 sz:0x1BC
} XCONFIG_SECURED_SETTINGS, *PXCONFIG_SECURED_SETTINGS; // size 512
C_ASSERT(sizeof(XCONFIG_SECURED_SETTINGS) == 0x200);


/* **************************** _XCONFIG_CONSOLE_SETTINGS **************************** */
//XCONFIG_CONSOLE_ENTRIES
enum _XCONFIG_CONSOLE_ENTRIES {
	XCONFIG_CONSOLE_DATA = 0x0,
	XCONFIG_CONSOLE_SCREEN_SAVER = 0x1,
	XCONFIG_CONSOLE_AUTO_SHUT_OFF = 0x2,
	XCONFIG_CONSOLE_WIRELESS_SETTINGS = 0x3,
	XCONFIG_CONSOLE_CAMERA_SETTINGS = 0x4,
	XCONFIG_CONSOLE_PLAYTIMERDATA = 0x5,
	XCONFIG_CONSOLE_MEDIA_DISABLEAUTOLAUNCH = 0x6,
	XCONFIG_CONSOLE_KEYBOARD_LAYOUT = 0x7,
	XCONFIG_CONSOLE_PC_TITLE_EXEMPTIONS = 0x8,
	XCONFIG_CONSOLE_NUI = 0x9,
	XCONFIG_CONSOLE_VOICE = 0xA,
	XCONFIG_CONSOLE_RETAIL_EX_FLAGS = 0xB,
	XCONFIG_CONSOLE_UNUSED_2 = 0xC, // previously was XCONFIG_CONSOLE_DASH_FIRST_USE_TUTORIAL_FLAGS = 0xC
	XCONFIG_CONSOLE_TV_DIAGONAL_SIZE_IN_CM = 0xD,
	XCONFIG_CONSOLE_NETWORKSTORAGEDEVICE_SERIALNUMBER = 0xE,
	XCONFIG_CONSOLE_DISCOVERABLE = 0xF,
	XCONFIG_CONSOLE_LIVE_TV_PROVIDER = 0x10,
	XCONFIG_CONSOLE_UNUSED_1 = 0x11, // unknown what this was
	XCONFIG_CONSOLE_CLOSEDCAPTIONINGSTATE = 0x12,
	XCONFIG_CONSOLE_CLOSEDCAPTIONINGSETTINGS = 0x13,
	XCONFIG_CONSOLE_ENCRYPTEDCONTRACTDATA = 0x14,
	XCONFIG_CONSOLE_MAX
};

// _XCONFIG_CONSOLE_SETTINGS macros for key pointers
#define XK_CONSOLE_1(x) &x.ScreenSaver						// key 0x1 2 bytes
#define XK_CONSOLE_2(x) &x.AutoShutoff						// key 0x2 2 bytes
#define XK_CONSOLE_3(x) &x.WirelessSettings					// key 0x3 256 bytes
#define XK_CONSOLE_4(x) &x.CameraSettings					// key 0x4 4 bytes
#define XK_CONSOLE_5(x) &x.PlayTimerData					// key 0x5 20 bytes
#define XK_CONSOLE_6(x) &x.MediaDisableAutoLaunch			// key 0x6 2 bytes
#define XK_CONSOLE_7(x) &x.KeyboardLayout					// key 0x7 2 bytes
#define XK_CONSOLE_8(x) &x.ParentalControlTitleExemptions	// key 0x8 0x64 bytes
#define XK_CONSOLE_9(x) &x.Nui								// key 0x9 0x28 bytes
#define XK_CONSOLE_A(x) &x.VoiceVolumeDucking				// key 0xA 1 byte
#define XK_CONSOLE_B(x) &x.RetailExFlags					// key 0xB 4 bytes
#define XK_CONSOLE_C(x) &x.DashFirstUseTutorialFlags		// key 0xC 4 byte
#define XK_CONSOLE_D(x) &x.TVDiagonalSizeInCm				// key 0xD 2 byte
#define XK_CONSOLE_E(x) &x.NetworkStorageDeviceSerialNumber	// key 0xE 20 byte
#define XK_CONSOLE_F(x) &x.ConsoleDiscoverable				// key 0xF 1 byte
#define XK_CONSOLE_10(x) &x.LiveTVProvider					// key 0x10 4 byte
#define XK_CONSOLE_11(x) &x.Unused							// key 0x11 2 byte
#define XK_CONSOLE_12(x) &x.ClosedCaptioning				// key 0x12 1 byte
#define XK_CONSOLE_13(x) &x.ClosedCaptioningSettings		// key 0x13 4 byte
#define XK_CONSOLE_14(x) &x.EncryptedContractData			// key 0x14 26 byte

typedef struct _XCONFIG_PLAYTIMERDATA {  // used by _XCONFIG_CONSOLE_SETTINGS
	ULARGE_INTEGER uliResetDate; // 0x0 sz:0x8
	DWORD dwPlayTimerFrequency; // 0x8 sz:0x4
	DWORD dwTotalPlayTime; // 0xC sz:0x4
	DWORD dwRemainingPlayTime; // 0x10 sz:0x4
} XCONFIG_PLAYTIMERDATA, *PXCONFIG_PLAYTIMERDATA; // size 20
C_ASSERT(sizeof(XCONFIG_PLAYTIMERDATA) == 0x14);

typedef struct _XCONFIG_NUI { 
	DWORD Flags; // 0x0 sz:0x4
	float DistanceToPlayspace; // 0x4 sz:0x4
	s32 AutoTiltAngle; // 0x8 sz:0x4
	BYTE Reserved[0x10]; // 0xC sz:0x10
} XCONFIG_NUI, *PXCONFIG_NUI; // size 28
C_ASSERT(sizeof(XCONFIG_NUI) == 0x1C);

typedef struct _XCONFIG_PC_TITLE_EXEMPTIONS { 
	DWORD TitleIDs[0x19]; // 0x0 sz:0x64
} XCONFIG_PC_TITLE_EXEMPTIONS, *PXCONFIG_PC_TITLE_EXEMPTIONS; // size 100
C_ASSERT(sizeof(XCONFIG_PC_TITLE_EXEMPTIONS) == 0x64);

//found in xconfig.h of sdk
/*typedef struct _XCLOSEDCAPTIONING_SETTINGS {
	DWORD UseDefaults : 1; // 0x0 bfo:0x0
	DWORD EdgeAttribute : 3; // 0x0 bfo:0x1
	DWORD FontColor : 4; // 0x0 bfo:0x4
	DWORD FontSize : 2; // 0x0 bfo:0x8
	DWORD FontStyle : 4; // 0x0 bfo:0x10
	DWORD FontOpacity : 2; // 0x0 bfo:0x14
	DWORD BackgroundColor : 4; // 0x0 bfo:0x16
	DWORD BackgroundOpacity : 2; // 0x0 bfo:0x20
	DWORD WindowOpacity : 2; // 0x0 bfo:0x22
	DWORD WindowColor : 4; // 0x0 bfo:0x24
	DWORD PreferredLanguage : 4; // 0x0 bfo:0x28
} XCLOSEDCAPTIONING_SETTINGS, *PXCLOSEDCAPTIONING_SETTINGS; // size 4
C_ASSERT(sizeof(XCLOSEDCAPTIONING_SETTINGS) == 0x4);*/


typedef struct _XCONFIG_CONSOLE_SETTINGS { 
	DWORD CheckSum; // 0x0 sz:0x4
	DWORD Version; // 0x4 sz:0x4
	SHORT ScreenSaver; // key 0x1 0x8 sz:0x2
	SHORT AutoShutOff; // key 0x2 0xA sz:0x2
	UCHAR WirelessSettings[0x100]; //key 0x3 0xC sz:0x100
	DWORD CameraSettings; // key 0x4 0x10C sz:0x4
	XCONFIG_NUI Nui; // key 0x9 12625 0x110 sz:0x1C
	XCONFIG_PLAYTIMERDATA PlayTimerData; // key 0x5 0x12C sz:0x14
	SHORT MediaDisableAutoLaunch; // key 0x6 0x140 sz:0x2
	SHORT KeyboardLayout; // key 0x7 0x142 sz:0x2
	XCONFIG_PC_TITLE_EXEMPTIONS ParentalControlTitleExemptions; // key 0x8 0x144 sz:0x64
	UCHAR VoiceVolumeDucking; // key 0xA 0x1A8 sz:0x1
	DWORD RetailExFlags; // key 0xB 0x1A9 sz:0x4
	DWORD DashFirstUseTutorialFlags; // key 0xC 0x1AD sz:0x4 *depreciated as of 164## dash*
	USHORT TVDiagonalSizeInCm; // key 0xD 0x1B1 sz:0x2
	UCHAR NetworkStorageDeviceSerialNumber[0x14]; // key 0xE 0x1B3 sz:0x14
	UCHAR ConsoleDiscoverable; // key 0xF 0x1C7 sz:0x1
	DWORD LiveTVProvider; // key 0x10 0x1C8 sz:0x4
	UCHAR Unused[0x2]; // key 0x11 0x1CC sz:0x2
	UCHAR ClosedCaptioning; // key 0x12 0x1CE sz:0x1
	XCLOSEDCAPTIONING_SETTINGS ClosedCaptioningSettings; // key 0x13 0x1CF sz:0x4
	UCHAR EncryptedContractData[0x1A]; // key 0x14 0x1D3 sz:0x1A
} XCONFIG_CONSOLE_SETTINGS, *PXCONFIG_CONSOLE_SETTINGS; // size 493
C_ASSERT(sizeof(XCONFIG_CONSOLE_SETTINGS) == 0x1ED);



/* **************************** _XCONFIG_DVD_SETTINGS **************************** */
//XCONFIG_DVD_ENTRIES
enum{
	XCONFIG_DVD_ALL = 0x0,
	XCONFIG_DVD_VOLUME_ID = 0x1,
	XCONFIG_DVD_BOOKMARK = 0x2,
	XCONFIG_DVD_ENTRIES_MAX
};

// _XCONFIG_DVD_SETTINGS macros for key pointers
#define XK_DVD_1(x) &x.VolumeId	// key 0x1 20 bytes
#define XK_DVD_2(x) &x.Data		// key 0x2 640 bytes

typedef struct _XCONFIG_DVD_SETTINGS { 
	DWORD Version; // 0x0 sz:0x4
	BYTE VolumeId[0x14]; // 0x4 sz:0x14 key 0x1
	BYTE Data[0x280]; // 0x18 sz:0x280 key 0x2
} XCONFIG_DVD_SETTINGS, *PXCONFIG_DVD_SETTINGS; // size 664
C_ASSERT(sizeof(XCONFIG_DVD_SETTINGS) == 0x298);


/* **************************** _XCONFIG_IPTV_SETTINGS **************************** */
//XCONFIG_IPTV_ENTRIES
enum{
	XCONFIG_IPTV_DATA = 0x0,
	XCONFIG_IPTV_SERVICE_PROVIDER_NAME = 0x1,
	XCONFIG_IPTV_PROVISIONING_SERVER_URL = 0x2,
	XCONFIG_IPTV_SUPPORT_INFO = 0x3,
	XCONFIG_IPTV_BOOTSTRAP_SERVER_URL = 0x4,
	XCONFIG_IPTV_ENTRIES_MAX
};

// _XCONFIG_IPTV_SETTINGS macros for key pointers
#define XK_IPTV_1(x) &x.ServiceProviderName		// key 0x1 120 bytes
#define XK_IPTV_2(x) &x.ProvisioningServerURL	// key 0x2 128 bytes
#define XK_IPTV_3(x) &x.SupportInfo				// key 0x3 128 bytes
#define XK_IPTV_4(x) &x.BootstrapServerURL		// key 0x4 128 bytes

typedef struct _XCONFIG_IPTV_SETTINGS { 
	DWORD CheckSum; // 0x0 sz:0x4
	DWORD Version; // 0x4 sz:0x4
	wchar_t ServiceProviderName[0x3C]; // 0x8 sz:0x78 key 0x1
	wchar_t ProvisioningServerURL[0x40]; // 0x80 sz:0x80 key 0x2
	wchar_t SupportInfo[0x40]; // 0x100 sz:0x80 key 0x3
	wchar_t BootstrapServerURL[0x40]; // 0x180 sz:0x80 key 0x4
} XCONFIG_IPTV_SETTINGS, *PXCONFIG_IPTV_SETTINGS; // size 512
C_ASSERT(sizeof(XCONFIG_IPTV_SETTINGS) == 0x200);


/* **************************** _XCONFIG_MEDIA_CENTER_SETTINGS **************************** */
//XCONFIG_MEDIA_CENTER_ENTRIES
enum{
	XCONFIG_MEDIA_CENTER_DATA = 0x0,
	XCONFIG_MEDIA_CENTER_MEDIA_PLAYER = 0x1,
	XCONFIG_MEDIA_CENTER_XESLED_VERSION = 0x2,
	XCONFIG_MEDIA_CENTER_XESLED_TRUST_SECRET = 0x3,
	XCONFIG_MEDIA_CENTER_XESLED_TRUST_CODE = 0x4,
	XCONFIG_MEDIA_CENTER_XESLED_HOST_ID = 0x5,
	XCONFIG_MEDIA_CENTER_XESLED_KEY = 0x6,
	XCONFIG_MEDIA_CENTER_XESLED_HOST_MAC_ADDRESS = 0x7,
	XCONFIG_MEDIA_CENTER_SERVER_UUID = 0x8,
	XCONFIG_MEDIA_CENTER_SERVER_NAME = 0x9,
	XCONFIG_MEDIA_CENTER_SERVER_FLAG = 0xa,
	XCONFIG_MEDIA_ENTRIES_MAX
};

// _XCONFIG_MEDIA_CENTER_SETTINGS macros for key pointers
#define XK_MC_1(x) &x.MediaPlayer			// key 0x1 20 bytes
#define XK_MC_2(x) &x.XeSledVersion			// key 0x2 10 bytes
#define XK_MC_3(x) &x.XeSledTrustSecret		// key 0x3 20 bytes
#define XK_MC_4(x) &x.XeSledTrustCode		// key 0x4 8 bytes
#define XK_MC_5(x) &x.XeSledHostID			// key 0x5 20 bytes
#define XK_MC_6(x) &x.XeSledKey				// key 0x6 1628 bytes
#define XK_MC_7(x) &x.XeSledHostMACAddress	// key 0x7 6 bytes
#define XK_MC_8(x) &x.ServerUUID			// key 0x8 16 bytes
#define XK_MC_9(x) &x.ServerName			// key 0x9 128 bytes
#define XK_MC_A(x) &x.ServerFlag			// key 0xa 4 bytes

typedef struct _XCONFIG_MEDIA_CENTER_SETTINGS { 
	DWORD CheckSum; // 0x0 sz:0x4
	DWORD Version; // 0x4 sz:0x4
	char MediaPlayer[0x14]; // 0x8 sz:0x14 key 0x1
	BYTE XeSledVersion[0xA]; // 0x1C sz:0xA key 0x2
	BYTE XeSledTrustSecret[0x14]; // 0x26 sz:0x14 key 0x3 
	BYTE XeSledTrustCode[0x8]; // 0x3A sz:0x8 key 0x4
	BYTE XeSledHostID[0x14]; // 0x42 sz:0x14 key 0x5
	BYTE XeSledKey[0x65C]; // 0x56 sz:0x65C key 0x6
	BYTE XeSledHostMACAddress[0x6]; // 0x6B2 sz:0x6 key 0x7
	char ServerUUID[0x10]; // 0x6B8 sz:0x10 key 0x8
	char ServerName[0x80]; // 0x6C8 sz:0x80 key 0x9
	char ServerFlag[0x4]; // 0x748 sz:0x4 key 0xa
} XCONFIG_MEDIA_CENTER_SETTINGS, *PXCONFIG_MEDIA_CENTER_SETTINGS; // size 1868
C_ASSERT(sizeof(XCONFIG_MEDIA_CENTER_SETTINGS) == 0x74C);


/* **************************** _XCONFIG_SYSTEM_SETTINGS **************************** */
//XCONFIG_SYSTEM_ENTRIES
enum{
	XCONFIG_SYSTEM_ALL = 0x0,
	XCONFIG_SYSTEM_ALARM_TIME = 0x1,
	XCONFIG_SYSTEM_PREVIOUS_FLASH_VERSION = 0x2,
	XCONFIG_SYSTEM_RGC_AUTH_DELAY = 0x3,
	XCONFIG_SYSTEM_ENTRIES_MAX
};

// _XCONFIG_SYSTEM_SETTINGS macros for key pointers
#define XK_SYSTEM_1(x) &x.AlarmTime				// key 0x1 8 bytes
#define XK_SYSTEM_2(x) &x.PreviousFlashVersion	// key 0x2 4 bytes
#define XK_SYSTEM_3(x) &x.RgcAuthDelay			// key 0x3 16 bytes

typedef struct _XCONFIG_SYSTEM_SETTINGS{
	DWORD Version; // 0x0 sz:0x4
	LARGE_INTEGER AlarmTime; // key 0x1 0x4 sz:0x8
	DWORD PreviousFlashVersion; // key 0x2 0xC sz:0x4
	ULARGE_INTEGER RgcAuthDelay[2]; // 0x10 sz:0x10
} XCONFIG_SYSTEM_SETTINGS, *PXCONFIG_SYSTEM_SETTINGS; // XConfigSystemSettings; 16 bytes
C_ASSERT(sizeof(XCONFIG_SYSTEM_SETTINGS) == 0x20);


/* **************************** _XCONFIG_USER_SETTINGS **************************** */
//XCONFIG_USER_ENTRIES
enum{
	XCONFIG_USER_DATA = 0x0,
	XCONFIG_USER_TIME_ZONE_BIAS = 0x1,
	XCONFIG_USER_TIME_ZONE_STD_NAME = 0x2,
	XCONFIG_USER_TIME_ZONE_DLT_NAME = 0x3,
	XCONFIG_USER_TIME_ZONE_STD_DATE = 0x4,
	XCONFIG_USER_TIME_ZONE_DLT_DATE = 0x5,
	XCONFIG_USER_TIME_ZONE_STD_BIAS = 0x6,
	XCONFIG_USER_TIME_ZONE_DLT_BIAS = 0x7,
	XCONFIG_USER_DEFAULT_PROFILE = 0x8,
	XCONFIG_USER_LANGUAGE = 0x9,
	XCONFIG_USER_VIDEO_FLAGS = 0xa,
	XCONFIG_USER_AUDIO_FLAGS = 0xb,
	XCONFIG_USER_RETAIL_FLAGS = 0xc,
	XCONFIG_USER_DEVKIT_FLAGS = 0xd,
	XCONFIG_USER_COUNTRY = 0xe,
	XCONFIG_USER_PC_FLAGS = 0xf,
	XCONFIG_USER_SMB_CONFIG = 0x10,
	XCONFIG_USER_LIVE_PUID = 0x11,
	XCONFIG_USER_LIVE_CREDENTIALS = 0x12,
	XCONFIG_USER_AV_COMPOSITE_SCREENSZ = 0x13,
	XCONFIG_USER_AV_COMPONENT_SCREENSZ = 0x14,
	XCONFIG_USER_AV_VGA_SCREENSZ = 0x15,
	XCONFIG_USER_PC_GAME = 0x16,
	XCONFIG_USER_PC_PASSWORD = 0x17,
	XCONFIG_USER_PC_MOVIE = 0x18,
	XCONFIG_USER_PC_GAME_RATING = 0x19,
	XCONFIG_USER_PC_MOVIE_RATING = 0x1a,
	XCONFIG_USER_PC_HINT = 0x1b,
	XCONFIG_USER_PC_HINT_ANSWER = 0x1c,
	XCONFIG_USER_PC_OVERRIDE = 0x1d,
	XCONFIG_USER_MUSIC_PLAYBACK_MODE = 0x1e,
	XCONFIG_USER_MUSIC_VOLUME = 0x1f,
	XCONFIG_USER_MUSIC_FLAGS = 0x20,
	XCONFIG_USER_ARCADE_FLAGS = 0x21,
	XCONFIG_USER_PC_VERSION = 0x22,
	XCONFIG_USER_PC_TV = 0x23,
	XCONFIG_USER_PC_TV_RATING = 0x24,
	XCONFIG_USER_PC_EXPLICIT_VIDEO = 0x25,
	XCONFIG_USER_PC_EXPLICIT_VIDEO_RATING = 0x26,
	XCONFIG_USER_PC_UNRATED_VIDEO = 0x27,
	XCONFIG_USER_PC_UNRATED_VIDEO_RATING = 0x28,
	XCONFIG_USER_VIDEO_OUTPUT_BLACK_LEVELS = 0x29,
	XCONFIG_USER_VIDEO_PLAYER_DISPLAY_MODE = 0x2a,
	XCONFIG_USER_ALTERNATE_VIDEO_TIMING_ID = 0x2b,
	XCONFIG_USER_VIDEO_DRIVER_OPTIONS = 0x2c,
	XCONFIG_USER_MUSIC_UI_FLAGS = 0x2d,
	XCONFIG_USER_VIDEO_MEDIA_SOURCE_TYPE = 0x2e,
	XCONFIG_USER_MUSIC_MEDIA_SOURCE_TYPE = 0x2f,
	XCONFIG_USER_PHOTO_MEDIA_SOURCE_TYPE = 0x30,
	XCONFIG_USER_ENTRIES_MAX
};

// _XCONFIG_USER_SETTINGS macros for key pointers
#define XK_USER_1(x) &x.TimeZoneBias				// key 0x1 4 bytes
#define XK_USER_2(x) &x.TimeZoneStdName				// key 0x2 4 bytes
#define XK_USER_3(x) &x.TimeZoneDltName				// key 0x3 4 bytes
#define XK_USER_4(x) &x.TimeZoneStdDate				// key 0x4 4 bytes
#define XK_USER_5(x) &x.TimeZoneDltDate				// key 0x5 4 bytes
#define XK_USER_6(x) &x.TimeZoneStdBias				// key 0x6 4 bytes
#define XK_USER_7(x) &x.TimeZoneDltBias				// key 0x7 4 bytes
#define XK_USER_8(x) &x.DefaultProfile				// key 0x8 8 bytes
#define XK_USER_9(x) &x.Language					// key 0x9 4 bytes
#define XK_USER_A(x) &x.VideoFlags					// key 0xa 4 bytes
#define XK_USER_B(x) &x.AudioFlags					// key 0xb 4 bytes
#define XK_USER_C(x) &x.RetailFlags					// key 0xc 4 bytes
#define XK_USER_D(x) &x.DevkitFlags					// key 0xd 4  bytes
#define XK_USER_E(x) &x.Country						// key 0xe 1 bytes
#define XK_USER_F(x) &x.ParentalControlFlags		// key 0xf 1 bytes
#define XK_USER_10(x) &x.SMBConfig					// key 0x10 256 bytes
#define XK_USER_11(x) &x.LivePUID					// key 0x11 8 bytes
#define XK_USER_12(x) &x.LiveCredentials			// key 0x12 16 bytes
#define XK_USER_13(x) &x.AvPackHDMIScreenSz			// key 0x13 4 bytes
#define XK_USER_14(x) &x.AvPackComponentScreenSz	// key 0x14 4 bytes
#define XK_USER_15(x) &x.AvPackVGAScreenSz			// key 0x15 4 bytes
#define XK_USER_16(x) &x.ParentalControlGame		// key 0x16 4 bytes
#define XK_USER_17(x) &x.ParentalControlPassword	// key 0x17 4 bytes
#define XK_USER_18(x) &x.ParentalControlMovie		// key 0x18 4 bytes
#define XK_USER_19(x) &x.ParentalControlGameRating	// key 0x19 4 bytes
#define XK_USER_1A(x) &x.ParentalControlMovieRating	// key 0x1a 4 bytes
#define XK_USER_1B(x) &x.ParentalControlHint		// key 0x1b 1 bytes
#define XK_USER_1C(x) &x.ParentalControlHintAnswer	// key 0x1c 32 bytes
#define XK_USER_1D(x) &x.ParentalControlOverride	// key 0x1d 32  bytes
#define XK_USER_1E(x) &x.MusicPlaybackMode			// key 0x1e 4 bytes
#define XK_USER_1F(x) &x.MusicVolume				// key 0x1f 4 bytes
#define XK_USER_20(x) &x.MusicFlags					// key 0x20 4 bytes
#define XK_USER_21(x) &x.ArcadeFlags				// key 0x21 4 bytes
#define XK_USER_22(x) &x.ParentalControlVersion		// key 0x22 4 bytes
#define XK_USER_23(x) &x.ParentalControlTV			// key 0x23 4 bytes
#define XK_USER_24(x) &x.ParentalControlTVRating	// key 0x24 4 bytes
#define XK_USER_25(x) &x.ParentalControlExplicitVideo// key 0x25 4 bytes
#define XK_USER_26(x) &x.ParentalControlExplicitVideoRating// key 0x26 4 bytes
#define XK_USER_27(x) &x.ParentalControlUnratedVideo// key 0x27 4 bytes
#define XK_USER_28(x) &x.ParentalControlUnratedVideoRating// key 0x28 4 bytes
#define XK_USER_29(x) &x.VideoOutputBlackLevels		// key 0x29 4 bytes
#define XK_USER_2A(x) &x.VideoPlayerDisplayMode		// key 0x2a 1 bytes
#define XK_USER_2B(x) &x.AlternateVideoTimingIDs	// key 0x2b 4 bytes
#define XK_USER_2C(x) &x.VideoDriverOptions			// key 0x2c 4 bytes
#define XK_USER_2D(x) &x.MusicUIFlags				// key 0x2d 4 bytes
#define XK_USER_2E(x) &x.VideoMediaSourceType		// key 0x2e 1 bytes
#define XK_USER_2F(x) &x.MusicMediaSourceType		// key 0x2f 1 bytes
#define XK_USER_30(x) &x.PhotoMediaSourceType		// key 0x30 1 bytes

// parental control password stored as hex
// I set it to all X and the value was 01010101, then I set it to all Y and the value was 02020202
// the reset query answer I used was "aaa" which it stored in mobileB as wchar in plaintext
// X 01, Y 02, L 03, R 04, U 05, D 06, LT 09, RT 0A, LB 0B, RB 0C
// numerically in the dash... LT 1, LB 2, RB 3, RT 4, L 5, U 6, D 7, R 8, X 9, Y 0

// These flags are stored in the retail flags (XCONFIG_USER_RETAIL_FLAGS).
//

#define XC_MISC_FLAG_AUTOPOWERDOWN      0x00000001
#define XC_MISC_FLAG_DONT_USE_DST       0x00000002
#define XC_MISC_FLAG_CONNECTIONNOTICE   0x00000004
#define XC_MISC_FLAG_24HCLOCK           0x00000008
#define XC_MISC_FLAG_NO_NOTIFY_DISPLAY  0x00000010
#define XC_MISC_FLAG_NO_NOTIFY_SOUND    0x00000020
#define XC_MISC_FLAG_OOBE_HAS_RUN       0x00000040

#define XC_MISC_FLAG_ALL_MASK           ((XC_MISC_FLAG_AUTOPOWERDOWN) | (XC_MISC_FLAG_DONT_USE_DST) | (XC_MISC_FLAG_CONNECTIONNOTICE) | \
										 (XC_MISC_FLAG_24HCLOCK) | (XC_MISC_FLAG_NO_NOTIFY_DISPLAY) | (XC_MISC_FLAG_NO_NOTIFY_SOUND) | \
										 (XC_MISC_FLAG_OOBE_HAS_RUN))

typedef struct _XCONFIG_TIMEZONE_DATE { // used by _XCONFIG_USER_SETTINGS
	BYTE Month; // 0x0 sz:0x1
	BYTE Day; // 0x1 sz:0x1
	BYTE DayOfWeek; // 0x2 sz:0x1
	BYTE Hour; // 0x3 sz:0x1
} XCONFIG_TIMEZONE_DATE, *PXCONFIG_TIMEZONE_DATE; // size 4
C_ASSERT(sizeof(XCONFIG_TIMEZONE_DATE) == 0x4);

typedef struct _XCONFIG_USER_SETTINGS { 
	DWORD CheckSum; // 0x0 sz:0x4
	DWORD Version; // 0x4 sz:0x4
	DWORD TimeZoneBias; // 0x8 sz:0x4 key 0x1
	char TimeZoneStdName[0x4]; // 0xC sz:0x4 key 0x2
	char TimeZoneDltName[0x4]; // 0x10 sz:0x4 key 0x3
	XCONFIG_TIMEZONE_DATE TimeZoneStdDate; // 0x14 sz:0x4 key 0x4
	XCONFIG_TIMEZONE_DATE TimeZoneDltDate; // 0x18 sz:0x4 key 0x5
	DWORD TimeZoneStdBias; // 0x1C sz:0x4 key 0x6
	DWORD TimeZoneDltBias; // 0x20 sz:0x4 key 0x7
	XUID DefaultProfile; // 0x24 sz:0x8 key 0x8
	DWORD Language; // 0x2C sz:0x4 key 0x9
	DWORD VideoFlags; // 0x30 sz:0x4 key 0xa
	DWORD AudioFlags; // 0x34 sz:0x4 key 0xb
	DWORD RetailFlags; // 0x38 sz:0x4 key 0xc
	DWORD DevkitFlags; // 0x3C sz:0x4 key 0xd
	char Country; // 0x40 sz:0x1 key 0xe
	char ParentalControlFlags; // 0x41 sz:0x1 key 0xf
	BYTE ReservedFlag[0x2]; // 0x42 sz:0x2
	char SMBConfig[0x100]; // 0x44 sz:0x100 key 0x10
	XUID LivePUID; // 0x144 sz:0x8 key 0x11
	char LiveCredentials[0x10]; // 0x14C sz:0x10 key 0x12
	SHORT AVPackHDMIScreenSz[2]; // 0x15C sz:0x4 key 0x13
	SHORT AVPackComponentScreenSz[2]; // 0x160 sz:0x4 key 0x14
	SHORT AVPackVGAScreenSz[2]; // 0x164 sz:0x4 key 0x15
	DWORD ParentalControlGame; // 0x168 sz:0x4 key 0x16
	DWORD ParentalControlPassword; // 0x16C sz:0x4 key 0x17
	DWORD ParentalControlMovie; // 0x170 sz:0x4 key 0x18
	DWORD ParentalControlGameRating; // 0x174 sz:0x4 key 0x19
	DWORD ParentalControlMovieRating; // 0x178 sz:0x4 key 0x1a
	char ParentalControlHint; // 0x17C sz:0x1 key 0x1b
	char ParentalControlHintAnswer[0x20]; // 0x17D sz:0x20 key 0x1c
	char ParentalControlOverride[0x20]; // 0x19D sz:0x20 key 0x1d
	DWORD MusicPlaybackMode; // 0x1BD sz:0x4 key 0x1e
	int MusicVolume; // 0x1C1 sz:0x4 (FLOAT) key 0x1f
	DWORD MusicFlags; // 0x1C5 sz:0x4 key 0x20
	DWORD ArcadeFlags; // 0x1C9 sz:0x4 key 0x21
	DWORD ParentalControlVersion; // 0x1CD sz:0x4 key 0x22
	DWORD ParentalControlTV; // 0x1D1 sz:0x4 key 0x23
	DWORD ParentalControlTVRating; // 0x1D5 sz:0x4 key 0x24
	DWORD ParentalControlExplicitVideo; // 0x1D9 sz:0x4 key 0x25
	DWORD ParentalControlExplicitVideoRating; // 0x1DD sz:0x4 key 0x26
	DWORD ParentalControlUnratedVideo; // 0x1E1 sz:0x4 key 0x27
	DWORD ParentalControlUnratedVideoRating; // 0x1E5 sz:0x4 key 0x28
	DWORD VideoOutputBlackLevels; // 0x1E9 sz:0x4 key 0x29
	BYTE VideoPlayerDisplayMode; // 0x1ED sz:0x1 key 0x2a
	DWORD AlternateVideoTimingIDs; // 0x1EE sz:0x4 key 0x2b
	DWORD VideoDriverOptions; // 0x1F2 sz:0x4 key 0x2c
	DWORD MusicUIFlags; // 0x1F6 sz:0x4 key 0x2d
	char VideoMediaSourceType; // 0x1FA sz:0x1 key 0x2e
	char MusicMediaSourceType; // 0x1FB sz:0x1 key 0x2f
	char PhotoMediaSourceType; // 0x1FC sz:0x1 key 0x30
} XCONFIG_USER_SETTINGS, *PXCONFIG_USER_SETTINGS; // size 509
C_ASSERT(sizeof(XCONFIG_USER_SETTINGS) == 0x1FD);


/* **************************** _XCONFIG_XNET_SETTINGS **************************** */
//XCONFIG_XNET_ENTRIES
enum{
	XCONFIG_XNET_ALL = 0x0,
	XCONFIG_XNET_DATA = 0x1,
	XCONFIG_XNET_ENTRIES_MAX
};

// _XCONFIG_XNET_SETTINGS macros for key pointers
#define XK_XNET_1(x) &x.Data // key 0x01 492 bytes

// decrypted xconfig machine account (mobilec.dat)
typedef struct _XNetConfigSectorHeader { 
	unsigned char abHash[0x14]; // 0x0 sz:0x14
	unsigned char abConfounder[0x8]; // 0x14 sz:0x8
} XNetConfigSectorHeader, *PXNetConfigSectorHeader; // size 28
C_ASSERT(sizeof(XNetConfigSectorHeader) == 0x1C);

typedef struct _NetLogonMachineAccount { 
	XNetConfigSectorHeader Header; // 0x0 sz:0x1C
	unsigned int dwServiceNetworkID; // 0x1C sz:0x4
	unsigned long long qwId; // 0x20 sz:0x8
	char szGamertag[0x10]; // 0x28 sz:0x10
	char szDomain[0x14]; // 0x38 sz:0x14
	char szKerberosRealm[0x18]; // 0x4C sz:0x18
	unsigned char abKey[0x10]; // 0x64 sz:0x10
	unsigned char bCountryIdOfLastLogon; // 0x74 sz:0x1
	unsigned char abReserved[0x177]; // 0x75 sz:0x177
} XNetLogonMachineAccount, *PXNetLogonMachineAccount; // size 492
C_ASSERT(sizeof(XNetLogonMachineAccount) == 0x1EC);

typedef struct _XCONFIG_XNET_SETTINGS{
	unsigned int version;
	union { // key 0x01 492 unsigned chars
		unsigned char abData[492];
		XNetLogonMachineAccount xnAccount; // applies only after decrypting this blob from category XCONFIG_XNET_MACHINE_ACCOUNT_CATEGORY
	} Data;
} XCONFIG_XNET_SETTINGS, *PXCONFIG_XNET_SETTINGS; // 496 unsigned chars
C_ASSERT(sizeof(XCONFIG_XNET_SETTINGS) == 0x1F0);

/* **************************** _XCONFIG_STATISTIC_SETTINGS **************************** */
//XCONFIG_STATISTIC_ENTRIES
enum{
	XCONFIG_STATISTICS_DATA = 0x0,
	XCONFIG_STATISTICS_XUID_MAC_ADDRESS = 0x1,
	XCONFIG_STATISTICS_XUID_COUNT = 0x2,
	XCONFIG_STATISTICS_ODD_FAILURES = 0x3,
	XCONFIG_STATISTICS_HDD_SMART_DATA = 0x4,
	XCONFIG_STATISTICS_UEM_ERRORS = 0x5,
	XCONFIG_STATISTICS_FPM_ERRORS = 0x6,
	XCONFIG_STATISTICS_LAST_REPORT_TIME = 0x7,
	XCONFIG_STATISTICS_BUG_CHECK_DATA = 0x8,
	XCONFIG_STATISTICS_TEMPERATURE = 0x9,
	XCONFIG_STATISTICS_XEKEYS_WRITE_FAILURE = 0xA,
	XCONFIG_STATISTICS_ENTRIES_MAX
};

// _XCONFIG_STATISTIC_SETTINGS macros for key pointers
#define XK_STATISTIC_1(x) &x.XUIDMACAddress		// key 0x1 6 bytes
#define XK_STATISTIC_2(x) &x.XUIDCount			// key 0x2 4 bytes
#define XK_STATISTIC_3(x) &x.ODDFailures		// key 0x3 32 bytes
#define XK_STATISTIC_4(x) &x.HDDSmartData		// key 0x4 512 bytes
#define XK_STATISTIC_5(x) &x.UEMErrors			// key 0x5 100 bytes
#define XK_STATISTIC_6(x) &x.FPMErrors			// key 0x6 56 bytes - 9199 increased 0x38 to 0x60
#define XK_STATISTIC_7(x) &x.LastReportTime		// key 0x7 8 bytes
#define XK_STATISTIC_8(x) &x.BugCheckData		// key 0x8 101 bytes 
#define XK_STATISTIC_9(x) &x.TemperatureData	// key 0x9 200 bytes
#define XK_STATISTIC_A(x) &x.XeKeysWriteFailure	// key 0xa 16 bytes

typedef struct _XCONFIG_XEKEYS_WRITE_FAILURE { 
	LARGE_INTEGER DateTime; // 0x0 sz:0x8
	DWORD Status; // 0x8 sz:0x4
	char File; // 0xC sz:0x1
	char Reserved[0x3]; // 0xD sz:0x3
} XCONFIG_XEKEYS_WRITE_FAILURE, *PXCONFIG_XEKEYS_WRITE_FAILURE; // size 16
C_ASSERT(sizeof(XCONFIG_XEKEYS_WRITE_FAILURE) == 0x10);

typedef struct _XCONFIG_STATISTIC_SETTINGS { 
	DWORD CheckSum; // 0x0 sz:0x4
	DWORD Version; // 0x4 sz:0x4
	char XUIDMACAddress[0x6]; // 0x8 sz:0x6 key 0x1
	char Reserved[0x2]; // 0xE sz:0x2
	DWORD XUIDCount; // 0x10 sz:0x4 key 0x2
	BYTE ODDFailures[0x20]; // 0x14 sz:0x20 key 0x3
	BYTE BugCheckData[0x65]; // 0x34 sz:0x65 key 0x8 
	BYTE TemperatureData[0xC8]; // 0x99 sz:0xC8 key 0x9
	XCONFIG_XEKEYS_WRITE_FAILURE XeKeysWriteFailure; // 0x161 sz:0x10 key 0xa
	char Unused[0x1C3]; // 0x171 sz:0x1C3
	char HDDSmartData[0x200]; // 0x334 sz:0x200 key 0x4
	char UEMErrors[0x64]; // 0x534 sz:0x64 key 0x5
	char FPMErrors[0x60]; // 0x598 sz:0x60 key 0x6
	LARGE_INTEGER LastReportTime; // 0x5F8 sz:0x8 key 0x7
} XCONFIG_STATISTIC_SETTINGS, *PXCONFIG_STATISTIC_SETTINGS; // size 1536
C_ASSERT(sizeof(XCONFIG_STATISTIC_SETTINGS) == 0x600);



/* **************************** _XCONFIG_STATIC_SETTINGS **************************** */
//XCONFIG_STATIC_ENTRIES
enum{
	XCONFIG_STATIC_DATA = 0x0,
	XCONFIG_STATIC_FIRST_POWER_ON_DATE = 0x1,
	XCONFIG_STATIC_SMC_CONFIG = 0x2,
	XCONFIG_STATIC_ENTRIES_MAX
};

// _XCONFIG_STATIC_SETTINGS macros for key pointers
#define XK_STATIC_1(x) &x.FirstPowerOnDate // key 0x1 5 bytes
#define XK_STATIC_2(x) &x.SMCConfig // key 0x2 256 bytes

typedef struct _FanOverride{ // used by _XCONFIG_STATIC_SETTINGS // 01111111 <- normally disabled as 0x7F
	BYTE Enable : 1; // says 7 is bit 0
	BYTE Speed : 7; // says 0 bit 7
} FanOverride, *PFanOverride; // 1 byte
C_ASSERT(sizeof(FanOverride) == 0x1);

typedef struct _Thermal{ // used by _XCONFIG_STATIC_SETTINGS
	BYTE Cpu;
	BYTE Gpu;
	BYTE Edram;
} Thermal, *PThermal; // 3 bytes
C_ASSERT(sizeof(Thermal) == 0x3);

typedef struct _ViperData{ // used by _XCONFIG_STATIC_SETTINGS
	BYTE GpuVoltageNotSetting : 1; // bit 7
	BYTE MemoryVoltageNotSetting : 1; // bit 6 (bit 5 thru 0 unused
	//BYTE unknown : 6; // 1 byte
	BYTE GpuTarget;
	BYTE MemoryTarget;
	BYTE CheckSum;	
} ViperData, *PViperData; // 4 bytes
C_ASSERT(sizeof(ViperData) == 0x4);

typedef struct _TempCalData{ // used by _XCONFIG_STATIC_SETTINGS
	WORD Gain; // 0 sz 2
	WORD Offset; // 2 sz 2
} TempCalData, *PTempCalData; // 4 bytes
C_ASSERT(sizeof(TempCalData) == 0x4);

typedef struct _TempSetting{ // used by _XCONFIG_STATIC_SETTINGS
	TempCalData Cpu;
	TempCalData Gpu;
	TempCalData Edram;
	TempCalData Board; 
} TempSetting, *PTempSetting; // 16 bytes
C_ASSERT(sizeof(TempSetting) == 0x10);

typedef struct _ThermalCalData{ // used by _XCONFIG_STATIC_SETTINGS
	TempSetting therm; // 16 bytes
	char AnaFuseValue;
	Thermal SetPoint; // 3 bytes
	Thermal Overload; // 3 bytes
} ThermalCalData, *PThermalCalData;
C_ASSERT(sizeof(ThermalCalData) == 0x17);

typedef struct _SMCBlock { 
	BYTE StructureVersion; // 0x0 sz:0x1
	BYTE ConfigSource; // 0x1 sz:0x1
	char ClockSelect; // 0x2 sz:0x1
	FanOverride fanOrCpu; // 1 byte 0x3 sz:0x2
	FanOverride fanOrGpu; // 1 byte
	char EjectPressTimeout; // 0x5 sz:0x1
	
	BYTE unknownBits : 1; // 1 byte total for this bitfield
	BYTE MteErrorHandling : 1; // 0x6 bfo:0x6
	BYTE ScreenToolExecutionCount : 2; // 0x6 bfo:0x4
	BYTE ScreenToolFinished : 1; // 0x6 bfo:0x3
	BYTE ScreenToolStarted : 1; // 0x6 bfo:0x2
	BYTE UseTempCalDefaults : 1; // 0x6 bfo:0x1 (checked in smc, bit 1)
	BYTE RadioEnable : 1; // 0x6 bfo:0x0

	char DelayOverloadTimer; // 0x7 sz:0x1
	char MaxOverloadDelta; // 0x8 sz:0x1
	char DropDeadDelta; // 0x9 sz:0x1
	ThermalCalData Temperature; // 0xA sz:0x17
	char MinFanSpeed; // 0x21 sz:0x1
	ViperData Viper; // 0x22 sz:0x4
	BYTE pad4[0x98]; // 0x26 sz:0x98
	TempSetting ThermalSet0; // 0xBE sz:0x10
	BYTE pad5[4]; // 0xCE sz:0x4
	TempSetting ThermalSet1; // 0xD2 sz:0x10
	BYTE pad6[2]; // 0xE2 sz:0x2
	ThermalCalData BackupThermalCalData; // 0xE4 sz:0x17
	BYTE pad7[3]; // 0xFB sz:0x3
	BYTE DoNotUse[2]; // 0xFE sz:0x2
} SMCBlock, *PSMCBlock; // size 256
C_ASSERT(sizeof(SMCBlock) == 0x100);

typedef struct _XCONFIG_STATIC_SETTINGS{
	DWORD CheckSum; // 0x0 sz:0x4 *** see below ***
	DWORD Version; // 0x4 sz:0x4
	char FirstPowerOnDate[5]; // 0x8 sz:0x5 key 0x1
	char reserved; // 0xD sz:0x1
	SMCBlock SMCConfig;  // 0xE sz:0x100 key 0x2
} XCONFIG_STATIC_SETTINGS, *PXCONFIG_STATIC_SETTINGS; // XConfigStaticSettings; 270 bytes
C_ASSERT(sizeof(XCONFIG_STATIC_SETTINGS) == 0x10E);

/* **************************** _XCONFIG_DEVKIT_SETTINGS **************************** */
//XCONFIG_DEVKIT_ENTRIES
enum _XCONFIG_DEVKIT_ENTRIES {
	XCONFIG_DEVKIT_DATA = 0x0,
	XCONFIG_DEVKIT_USBD_ROOT_HUB_PORT_DISABLE_MASK = 0x1,
	XCONFIG_DEVKIT_XAM_FEATURE_ENABLE_DISABLE_MASK = 0x2,
	XCONFIG_DEVKIT_KIOSK_ID = 0x3,
	XCONFIG_DEVKIT_MAX
};

typedef struct _XCONFIG_DEVKIT_XAM_FEATURE_MASK { 
	DWORD DevkitEnableMask; // 0x0 sz:0x4
	DWORD ConsoleDisableMask; // 0x4 sz:0x4
	DWORD Reserved[2]; // 0x8 sz:0x8
} XCONFIG_DEVKIT_XAM_FEATURE_MASK, *PXCONFIG_DEVKIT_XAM_FEATURE_MASK; // size 16
C_ASSERT(sizeof(XCONFIG_DEVKIT_XAM_FEATURE_MASK) == 0x10);

typedef struct _XCONFIG_USBD_ROOT_HUB_PORT_MASK { 
	BYTE Mask[2]; // 0x0 sz:0x2
} XCONFIG_USBD_ROOT_HUB_PORT_MASK, *PXCONFIG_USBD_ROOT_HUB_PORT_MASK; // size 2
C_ASSERT(sizeof(XCONFIG_USBD_ROOT_HUB_PORT_MASK) == 0x2);

typedef struct _XCONFIG_DEVKIT_SETTINGS { 
	DWORD Version; // 0x0 sz:0x4
	XCONFIG_USBD_ROOT_HUB_PORT_MASK UsbdRootHubPortDisableMask; // 0x4 sz:0x2
	XCONFIG_DEVKIT_XAM_FEATURE_MASK XamFeatureMask; // 0x6 sz:0x10
	DWORD KioskId; // 0x16 sz:0x4
} XCONFIG_DEVKIT_SETTINGS, *PXCONFIG_DEVKIT_SETTINGS; // size 22
C_ASSERT(sizeof(XCONFIG_DEVKIT_SETTINGS) == 0x1A);



#pragma warning(pop)  // unnamed struct/union
#pragma pack(pop)


/*
USHORT XConfig_numEntr[XCONFIG_CATEGORY_MAX] = {
	XCONFIG_STATIC_ENTRIES_MAX,
	XCONFIG_STATISTICS_ENTRIES_MAX,
	XCONFIG_SECURED_ENTRIES_MAX,
	XCONFIG_USER_ENTRIES_MAX,
	XCONFIG_XNET_ENTRIES_MAX,
	XCONFIG_XNET_ENTRIES_MAX,
	XCONFIG_MEDIA_ENTRIES_MAX,
	XCONFIG_CONSOLE_MAX,
	XCONFIG_DVD_ENTRIES_MAX,
	XCONFIG_IPTV_ENTRIES_MAX,
	XCONFIG_SYSTEM_ENTRIES_MAX,
	XCONFIG_DEVKIT_ENTRIES_MAX,
}; // the number of entries in each category
*/
/*
// this and internal SMCBlock checksums seem to be the only ones used at this point
//
// use this to calculate XCONFIG_STATIC_SETTINGS.CheckSum
// where data is a BYTE pointer to the full XCONFIG_STATIC_SETTINGS struct
UINT XConfigStaticMainChecksumCalc(PBYTE data)
{
	UINT i, len, sum = 0;
	data += 0x10;
	for(i=0, len=252; i<len; i++)
		sum += data[i]&0xFF;
	sum = (~sum)&0xFFFF;
	return ((sum&0xFF00)<<8)+((sum&0xFF)<<24);
}

// EXAMPLE:
NTSTATUS SetTreshHolds(BYTE cpu, BYTE gpu, BYTE mem, BYTE cpuOff, BYTE gpuOff, BYTE memOff)
{
	XCONFIG_STATIC_SETTINGS xcss;
	DWORD sta;
	WORD sz;
	sta = ExGetXConfigSetting(XCONFIG_STATIC_CATEGORY, XCONFIG_STATIC_DATA, &xcss, sizeof(XCONFIG_STATIC_SETTINGS) , &sz);
	if((sta == 0)&&(sz == sizeof(XCONFIG_STATIC_SETTINGS)))
	{
		xcss.Temperature.SetPoint.Cpu = cpu;
		xcss.Temperature.SetPoint.Gpu = gpu;
		xcss.Temperature.SetPoint.Edram = mem;
		xcss.Temperature.Overload.Cpu = cpuOff;
		xcss.Temperature.Overload.Gpu = gpuOff;
		xcss.Temperature.Overload.Edram = memOff;
		xcss.CheckSum = XConfigStaticChecksumCalc((PBYTE)&xcss);
		sta = ExSetXConfigSetting(XCONFIG_STATIC_CATEGORY, XCONFIG_STATIC_DATA, &xcss, sz);
	}
	return sta;
}
*/

#endif // _XCONFIG_H


```

`XenonDumper/libs/xkelib/kernel/keXeCrypt.h`:

```h
#ifndef __KEXECRYPT_H
#define __KEXECRYPT_H

typedef enum _XE_RSA_KEY_TYPE { // for XeKeysVerifyRSASignature
	XE_PIRS_RSA_KEY = 0x0,
	XE_LIVEDRM_RSA_KEY = 0x1,
	XE_DEVICE_RSA_KEY = 0x2,
	XE_XSIGNER2_RSA_KEY = 0x3,
	XE_MAX_RSA_KEY = 0x4,
} XE_RSA_KEY_TYPE;

#define XECRYPT_DES_BLOCK_SIZE      (0x8)
#define XECRYPT_DES_KEY_SIZE        (0x8)
#define XECRYPT_DES3_KEY_SIZE       (0x18)
#define XECRYPT_AES_BLOCK_SIZE      (0x10)
#define XECRYPT_AES_KEY_SIZE        (0x10)
#define XECRYPT_SHA_DIGEST_SIZE     (0x14)
#define XECRYPT_MD5_DIGEST_SIZE     (0x10)
#define XECRYPT_PARVE_BLOCK_SIZE    (0x8)
#define XECRYPT_PARVE_KEY_SIZE      (0x8)
#define XECRYPT_PARVE_SBOX_SIZE     (0x100)
#define XECRYPT_PARVE_MAC_SIZE      (0x8)


/* ******************* console certificate stuff ******************* */
#pragma pack(push, 1)
typedef struct _XE_CONSOLE_ID {
	union{
		struct {
			BYTE refurbBits : 4;
			BYTE ManufactureMonth : 4;
			DWORD ManufactureYear : 4;
			DWORD MacIndex3 : 8;
			DWORD MacIndex4 : 8;
			DWORD MacIndex5 : 8;
			DWORD Crc : 4;
		} asBits;
		BYTE abData[5];
	};
} XE_CONSOLE_ID, *PXE_CONSOLE_ID; // size 5
C_ASSERT(sizeof(XE_CONSOLE_ID) == 0x5);
#pragma pack(pop)

typedef struct _CONSOLE_PUBLIC_KEY { 
	BYTE PublicExponent[0x4]; // 0x0 sz:0x4
	BYTE Modulus[0x80]; // 0x4 sz:0x80
} CONSOLE_PUBLIC_KEY, *PCONSOLE_PUBLIC_KEY; // size 132
C_ASSERT(sizeof(CONSOLE_PUBLIC_KEY) == 0x84);

typedef struct _XE_CONSOLE_CERTIFICATE { 
	WORD CertSize; // 0x0 sz:0x2
	XE_CONSOLE_ID ConsoleId; // 0x2 sz:0x5
	BYTE ConsolePartNumber[0xB]; // 0x7 sz:0xB
	BYTE Reserved[0x4]; // 0x12 sz:0x4
	WORD Privileges; // 0x16 sz:0x2
	DWORD ConsoleType; // 0x18 sz:0x4
	char ManufacturingDate[0x8]; // 0x1C sz:0x8
	CONSOLE_PUBLIC_KEY ConsolePublicKey; // 0x24 sz:0x84
	BYTE Signature[0x100]; // 0xA8 sz:0x100
} XE_CONSOLE_CERTIFICATE, *PXE_CONSOLE_CERTIFICATE; // size 424
C_ASSERT(sizeof(XE_CONSOLE_CERTIFICATE) == 0x1A8);

typedef struct _XE_CONSOLE_SIGNATURE { 
	XE_CONSOLE_CERTIFICATE Cert; // 0x0 sz:0x1A8
	BYTE Signature[0x80]; // 0x1A8 sz:0x80
} XE_CONSOLE_SIGNATURE, *PXE_CONSOLE_SIGNATURE; // size 552
C_ASSERT(sizeof(XE_CONSOLE_SIGNATURE) == 0x228);

/* ******************* DES stuff ******************* */
typedef struct _XECRYPT_DES_STATE { 
	DWORD keytab[0x10][0x2]; // 0x0 sz:0x80
} XECRYPT_DES_STATE, *PXECRYPT_DES_STATE; // size 128
C_ASSERT(sizeof(XECRYPT_DES_STATE) == 0x80);

/* ******************* DES3 stuff ******************* */
typedef struct _XECRYPT_DES3_STATE { 
	XECRYPT_DES_STATE aDesState[0x3]; // 0x0 sz:0x180
} XECRYPT_DES3_STATE, *PXECRYPT_DES3_STATE; // size 384
C_ASSERT(sizeof(XECRYPT_DES3_STATE) == 0x180);

/* ******************* AES stuff ******************* */
typedef struct _XECRYPT_AES_STATE { 
	BYTE keytabenc[0xB][0x4][0x4]; // 0x0 sz:0xB0
	BYTE keytabdec[0xB][0x4][0x4]; // 0xB0 sz:0xB0
} XECRYPT_AES_STATE, *PXECRYPT_AES_STATE; // size 352
C_ASSERT(sizeof(XECRYPT_AES_STATE) == 0x160);

/* ******************* RC4 stuff ******************* */
typedef struct _XECRYPT_RC4_STATE { 
	BYTE S[0x100]; // 0x0 sz:0x100
	BYTE i; // 0x100 sz:0x1
	BYTE j; // 0x101 sz:0x1
} XECRYPT_RC4_STATE, *PXECRYPT_RC4_STATE; // size 258
C_ASSERT(sizeof(XECRYPT_RC4_STATE) == 0x102);

/* ******************* SHA stuff ******************* */
typedef struct _XECRYPT_SHA_STATE { 
	DWORD count; // 0x0 sz:0x4
	DWORD state[0x5]; // 0x4 sz:0x14
	BYTE buffer[0x40]; // 0x18 sz:0x40
} XECRYPT_SHA_STATE, *PXECRYPT_SHA_STATE; // size 88
C_ASSERT(sizeof(XECRYPT_SHA_STATE) == 0x58);

/* ******************* HMACSHA stuff ******************* */
typedef struct _XECRYPT_HMACSHA_STATE { 
	XECRYPT_SHA_STATE ShaState[0x2]; // 0x0 sz:0xB0
} XECRYPT_HMACSHA_STATE, *PXECRYPT_HMACSHA_STATE; // size 176
C_ASSERT(sizeof(XECRYPT_HMACSHA_STATE) == 0xB0);

/* ******************* MD5 stuff ******************* */
typedef struct _XECRYPT_MD5_STATE { 
	DWORD count; // 0x0 sz:0x4
	DWORD buf[0x4]; // 0x4 sz:0x10
	BYTE in[0x40]; // 0x14 sz:0x40
} XECRYPT_MD5_STATE, *PXECRYPT_MD5_STATE; // size 84
C_ASSERT(sizeof(XECRYPT_MD5_STATE) == 0x54);

/* ******************* HMACMD5 stuff ******************* */
typedef struct _XECRYPT_HMACMD5_STATE { 
	XECRYPT_MD5_STATE Md5State[0x2]; // 0x0 sz:0xA8
} XECRYPT_HMACMD5_STATE, *PXECRYPT_HMACMD5_STATE; // size 168
C_ASSERT(sizeof(XECRYPT_HMACMD5_STATE) == 0xA8);

/* ******************* RSA stuff ******************* */
typedef struct _XECRYPT_RSA { 
	DWORD cqw; // 0x0 sz:0x4
	DWORD dwPubExp; // 0x4 sz:0x4
	QWORD qwReserved; // 0x8 sz:0x8
} XECRYPT_RSA, *PXECRYPT_RSA; // size 16
C_ASSERT(sizeof(XECRYPT_RSA) == 0x10);

typedef struct _XECRYPT_RSAPUB_1024 { 
	XECRYPT_RSA Rsa; // 0x0 sz:0x10
	QWORD aqwM[0x10]; // 0x10 sz:0x80
} XECRYPT_RSAPUB_1024, *PXECRYPT_RSAPUB_1024; // size 144
C_ASSERT(sizeof(XECRYPT_RSAPUB_1024) == 0x90);

typedef struct _XECRYPT_RSAPUB_1536 { 
	XECRYPT_RSA Rsa; // 0x0 sz:0x10
	QWORD aqwM[0x18]; // 0x10 sz:0xC0
} XECRYPT_RSAPUB_1536, *PXECRYPT_RSAPUB_1536; // size 208
C_ASSERT(sizeof(XECRYPT_RSAPUB_1536) == 0xD0);

typedef struct _XECRYPT_RSAPUB_2048 { 
	XECRYPT_RSA Rsa; // 0x0 sz:0x10
	QWORD aqwM[0x20]; // 0x10 sz:0x100
} XECRYPT_RSAPUB_2048, *PXECRYPT_RSAPUB_2048; // size 272
C_ASSERT(sizeof(XECRYPT_RSAPUB_2048) == 0x110);

typedef struct _XECRYPT_RSAPUB_4096 { 
	XECRYPT_RSA Rsa; // 0x0 sz:0x10
	QWORD aqwM[0x40]; // 0x10 sz:0x200
} XECRYPT_RSAPUB_4096, *PXECRYPT_RSAPUB_4096; // size 528
C_ASSERT(sizeof(XECRYPT_RSAPUB_4096) == 0x210);

typedef struct _XECRYPT_RSAPRV_1024 { 
	XECRYPT_RSAPUB_1024 RsaPub; // 0x0 sz:0x10
	QWORD aqwP[0x8]; // 0x90 sz:0x40
	QWORD aqwQ[0x8]; // 0xD0 sz:0x40
	QWORD aqwDP[0x8]; // 0x110 sz:0x40
	QWORD aqwDQ[0x8]; // 0x150 sz:0x40
	QWORD aqwCR[0x8]; // 0x190 sz:0x40
} XECRYPT_RSAPRV_1024, *PXECRYPT_RSAPRV_1024; // size 464
C_ASSERT(sizeof(XECRYPT_RSAPRV_1024) == 0x1D0);

typedef struct _XECRYPT_RSAPRV_1536 { 
	XECRYPT_RSAPUB_1536 RsaPub; // 0x0 sz:0x10
	QWORD aqwP[0xC]; // 0xD0 sz:0x60
	QWORD aqwQ[0xC]; // 0x130 sz:0x60
	QWORD aqwDP[0xC]; // 0x190 sz:0x60
	QWORD aqwDQ[0xC]; // 0x1F0 sz:0x60
	QWORD aqwCR[0xC]; // 0x250 sz:0x60
} XECRYPT_RSAPRV_1536, *PXECRYPT_RSAPRV_1536; // size 688
C_ASSERT(sizeof(XECRYPT_RSAPRV_1536) == 0x2B0);

typedef struct _XECRYPT_RSAPRV_2048 { 
	XECRYPT_RSAPUB_2048 RsaPub; // 0x0 sz:0x10
	QWORD aqwP[0x10]; // 0x110 sz:0x80
	QWORD aqwQ[0x10]; // 0x190 sz:0x80
	QWORD aqwDP[0x10]; // 0x210 sz:0x80
	QWORD aqwDQ[0x10]; // 0x290 sz:0x80
	QWORD aqwCR[0x10]; // 0x310 sz:0x80
} XECRYPT_RSAPRV_2048, *PXECRYPT_RSAPRV_2048; // size 912
C_ASSERT(sizeof(XECRYPT_RSAPRV_2048) == 0x390);

typedef struct _XECRYPT_RSAPRV_4096 { 
	XECRYPT_RSAPUB_4096 RsaPub; // 0x0 sz:0x10
	QWORD aqwP[0x20]; // 0x210 sz:0x100
	QWORD aqwQ[0x20]; // 0x310 sz:0x100
	QWORD aqwDP[0x20]; // 0x410 sz:0x100
	QWORD aqwDQ[0x20]; // 0x510 sz:0x100
	QWORD aqwCR[0x20]; // 0x610 sz:0x100
} XECRYPT_RSAPRV_4096, *PXECRYPT_RSAPRV_4096; // size 1808
C_ASSERT(sizeof(XECRYPT_RSAPRV_4096) == 0x710);

/* ******************* SIG stuff ******************* */
typedef struct _XECRYPT_SIG { 
	QWORD aqwPad[0x1C]; // 0x0 sz:0xE0
	BYTE bOne; // 0xE0 sz:0x1
	BYTE abSalt[0xA]; // 0xE1 sz:0xA
	BYTE abHash[0x14]; // 0xEB sz:0x14
	BYTE bEnd; // 0xFF sz:0x1
} XECRYPT_SIG, *PXECRYPT_SIG; // size 256
C_ASSERT(sizeof(XECRYPT_SIG) == 0x100);

/* ******************* Diffie-Hellman stuff ******************* */
typedef struct _XECRYPT_DH { 
	DWORD cqw; // 0x0 sz:0x4
	DWORD dwReserved; // 0x4 sz:0x4
} XECRYPT_DH, *PXECRYPT_DH; // size 8
C_ASSERT(sizeof(XECRYPT_DH) == 0x8);

typedef struct _XECRYPT_DH_768 { 
	XECRYPT_DH Dh; // 0x0 sz:0x8
	QWORD aqwM[0xC]; // 0x8 sz:0x60
	QWORD aqwG[0xC]; // 0x68 sz:0x60
} XECRYPT_DH_768, *PXECRYPT_DH_768; // size 200
C_ASSERT(sizeof(XECRYPT_DH_768) == 0xC8);

typedef struct _XECRYPT_DH_1024 { 
	XECRYPT_DH Dh; // 0x0 sz:0x8
	QWORD aqwM[0x10]; // 0x8 sz:0x80
	QWORD aqwB[0x10]; // 0x88 sz:0x80
} XECRYPT_DH_1024, *PXECRYPT_DH_1024; // size 264
C_ASSERT(sizeof(XECRYPT_DH_1024) == 0x108);

/* ******************* eliptic curve stuff ******************* */
typedef struct _XECRYPT_ECPUB { 
	DWORD cqw; // 0x0 sz:0x4
	BYTE cbitR; // 0x4 sz:0x1
	BYTE cbitS; // 0x5 sz:0x1
	BYTE cbitA; // 0x6 sz:0x1
	BYTE cbitN; // 0x7 sz:0x1
} XECRYPT_ECPUB, *PXECRYPT_ECPUB; // size 8
C_ASSERT(sizeof(XECRYPT_ECPUB) == 0x8);

typedef struct _XECRYPT_ECPUB_512 { 
	XECRYPT_ECPUB EcPub; // 0x0 sz:0x8
	QWORD aqwM[0x8]; // 0x8 sz:0x40
	QWORD aqwC[0x10]; // 0x48 sz:0x80
	QWORD aqwG[0x10]; // 0xC8 sz:0x80
	QWORD aqwGP[0x10]; // 0x148 sz:0x80
} XECRYPT_ECPUB_512, *PXECRYPT_ECPUB_512; // size 456
C_ASSERT(sizeof(XECRYPT_ECPUB_512) == 0x1C8);

/* ******************* CRL.bin ******************* */
typedef struct _CERTIFICATE_REVOCATION_DATA { 
	DWORD Size; // 0x0 sz:0x4
	DWORD Version; // 0x4 sz:0x4
	DWORD Count; // 0x8 sz:0x4
} CERTIFICATE_REVOCATION_DATA, *PCERTIFICATE_REVOCATION_DATA; // size 12
C_ASSERT(sizeof(CERTIFICATE_REVOCATION_DATA) == 0xC);

typedef struct _CERTIFICATE_REVOCATION_BOX_DATA { 
	LARGE_INTEGER DateStamp; // 0x0 sz:0x8
	BYTE Padding[0x7]; // 0x8 sz:0x7
	BYTE UpdateSequence; // 0xF sz:0x1
} CERTIFICATE_REVOCATION_BOX_DATA, *PCERTIFICATE_REVOCATION_BOX_DATA; // size 16
C_ASSERT(sizeof(CERTIFICATE_REVOCATION_BOX_DATA) == 0x10);

typedef struct _CERTIFICATE_REVOCATION_LIST_HEADER { // typically header is immediately followed by the data, starting with CERTIFICATE_REVOCATION_DATA
	DWORD Signer; // 0x0 sz:0x4
	BYTE ConsoleID[0x5]; // 0x4 sz:0x5
	BYTE Padding[0x3]; // 0x9 sz:0x3
	BYTE Digest[0x14]; // 0xC sz:0x14
	XECRYPT_SIG Signature; // 0x20 sz:0x100
	BYTE Nonce[0x10]; // 0x120 sz:0x10
	BYTE Key[0x10]; // 0x130 sz:0x10
	union {
		CERTIFICATE_REVOCATION_BOX_DATA BoxData; // 0x140 sz:0x10
		BYTE BoxDataAsBYTE[0x10]; // 0x140 sz:0x10
	};
} CERTIFICATE_REVOCATION_LIST_HEADER, *PCERTIFICATE_REVOCATION_LIST_HEADER; // size 336
C_ASSERT(sizeof(CERTIFICATE_REVOCATION_LIST_HEADER) == 0x150);

typedef union _DYNAMIC_REVOCATION_LIST { 
	CERTIFICATE_REVOCATION_LIST_HEADER RevocationList; // 0x0 sz:0x150
	BYTE Reserved[0x8000]; // 0x0 sz:0x8000
} DYNAMIC_REVOCATION_LIST, *PDYNAMIC_REVOCATION_LIST; // size 32768
C_ASSERT(sizeof(DYNAMIC_REVOCATION_LIST) == 0x8000);


/* ******************* HDD security sector ******************* */
// stored at sector 2?
typedef struct _HDD_SECURITY_BLOB { 
	BYTE SerialNumber[0x14]; // 0x0 sz:0x14
	BYTE FirmwareRevision[0x8]; // 0x14 sz:0x8
	BYTE ModelNumber[0x28]; // 0x1C sz:0x28
	BYTE LogoBitmapDigest[0x14]; // 0x44 sz:0x14
	DWORD UserAddressableSectors; // 0x58 sz:0x4
	BYTE Signature[0x100]; // 0x5C sz:0x100
} HDD_SECURITY_BLOB, *PHDD_SECURITY_BLOB; // size 348
C_ASSERT(sizeof(HDD_SECURITY_BLOB) == 0x15C);

/* ******************* DAE.BIN decrypted ******************* */
typedef struct _DVD_AUTH_EX_DATA_D { 
	WORD Flags; // 0x0 sz:0x2
	WORD Reserved02; // 0x2 sz:0x2
	WORD Reserved04; // 0x4 sz:0x2
	WORD Reserved06; // 0x6 sz:0x2
	WORD Reserved08; // 0x8 sz:0x2
	WORD Reserved0A; // 0xA sz:0x2
	WORD Reserved0C; // 0xC sz:0x2
	WORD Reserved0E; // 0xE sz:0x2
} DVD_AUTH_EX_DATA_D, *PDVD_AUTH_EX_DATA_D; // size 16
C_ASSERT(sizeof(DVD_AUTH_EX_DATA_D) == 0x10);

typedef struct _DVD_AUTH_EX_DATA_E { 
	LARGE_INTEGER DateStamp; // 0x0 sz:0x8
	WORD Reserved08; // 0x8 sz:0x2
	WORD Reserved0A; // 0xA sz:0x2
	WORD Reserved0C; // 0xC sz:0x2
	BYTE Reserved0E; // 0xE sz:0x1
	BYTE UpdateSequence; // 0xF sz:0x1
} DVD_AUTH_EX_DATA_E, *PDVD_AUTH_EX_DATA_E; // size 16
C_ASSERT(sizeof(DVD_AUTH_EX_DATA_E) == 0x10);

typedef struct _DVD_AUTH_EX_HEADER { 
	DWORD Signer; // 0x0 sz:0x4
	WORD Size; // 0x4 sz:0x2
	WORD Flags; // 0x6 sz:0x2
	WORD Version; // 0x8 sz:0x2
	WORD Reserved0A; // 0xA sz:0x2
	BYTE DigestTable[0x14]; // 0xC sz:0x14
	BYTE Signature[0x100]; // 0x20 sz:0x100
	DVD_AUTH_EX_DATA_D DataD; // 0x120 sz:0x10
	DVD_AUTH_EX_DATA_E DataE; // 0x130 sz:0x10
	BYTE DigestUnique[0x10]; // 0x140 sz:0x10
} DVD_AUTH_EX_HEADER, *PDVD_AUTH_EX_HEADER; // size 336
C_ASSERT(sizeof(DVD_AUTH_EX_HEADER) == 0x150);

/* ******************* SECDATA.BIN decrypted ******************* */
typedef enum _SOFTWARE_SECURITY_STAT_INDEX {
	SOFTWARE_SECURITY_STAT_RESERVED_FOR_COMPATIBILITY = 0x0, // 0x38 in secdata.bin, all DWORD
	SOFTWARE_SECURITY_STAT_DVD_BOOT_FAILURES = 0x1,
	SOFTWARE_SECURITY_STAT_FUSE_BLOW_FAILURES = 0x2,
	SOFTWARE_SECURITY_STAT_DVD_AUTH_EX_FAILURES = 0x3,
	SOFTWARE_SECURITY_STAT_DVD_AUTH_EX_TIMEOUTS = 0x4,
	SOFTWARE_SECURITY_STAT_MAXIMUM = 0x5,
};

typedef struct _SECDATA_BLOB{
	BYTE abHash[0x10]; // 0 sz 0x10
	BYTE abConfounder[0x8];// 0x10
	BYTE SecurityActivated; // 0x18
	BYTE SecurityLockDownValue; // 0x19
	BYTE pad1[2]; // 0x1A sz 0x2
	WORD wUnkn1; // 0x1C
	WORD wUnkn2; // 0x1E
	FILETIME ftTime; // 0x20
	QWORD cSecurityDetectedError; // 0x28
	QWORD cSecurityActivatedError; // 0x30
	DWORD dwCompatReserved; // 0x38
	DWORD dwDvdBootFailures; // 0x3C
	DWORD dwFuseBlowFailures; // 0x40
	DWORD dwDvdAuthExFailures; // 0x44
	DWORD dwDvdAuthExTimeouts; // 0x48
	BYTE pad2[0x3B4]; // 0x5c

	//QWORD cDvdDetectionError; // 0x38 << old defines
	//QWORD cLockSystemUpdate; // 0x40
	//BYTE pad2[0x3B8]; // 0x48
} SECDATA_BLOB, *PSECDATA_BLOB;
C_ASSERT(sizeof(SECDATA_BLOB) == 0x400);

/* ******************* FCRT.BIN decrypted ******************* */
typedef struct _FCRT_HEADER{
	BYTE abSignature[0x100]; // 0 signature is calculcated with a has of header from abAesFeed to end of abPayloadHash, after abPayloadHash is calculated
	BYTE abAesFeed[0x10]; // 0x100 random value, with first byte being |0x1
	DWORD dwFlags; // 0x110
	DWORD dwVersion; // 0x114
	DWORD dwDataSize; // 0x118
	DWORD dwHeaderSize; // 0x11C
	BYTE abPad[0xC]; // 0x120
	BYTE abPayloadHash[0x14]; // 0x12C sha1 of data following this for dwDataSize
} FCRT_HEADER, *PFCRT_HEADER;
 C_ASSERT(sizeof(FCRT_HEADER) == 0x140);

 /* ******************* EXTENDED.BIN decrypted ******************* */
 typedef struct _EXTENDED_BIN_DATA{
	 BYTE abNonce[0x10]; 				// 0
	 BYTE abConfounder[0x8]; 			// 0x0010
	 BYTE abVidDevPubKey[0x28]; 			// 0x0018 XEKEYEX_VIDEO_DEVICE_PUBLIC_KEY: .set 0x100
	 BYTE abVidDevPrvKey[0x14]; 			// 0x0040 XEKEYEX_VIDEO_DEVICE_PRIVATE_KEY: .set 0x101
	 BYTE abVidDevCert[0x9C4]; 			// 0x0054 XEKEYEX_VIDEO_DEVICE_CERTIFICATE: .set 0x102
	 BYTE abIptvAvPrvKey[0x390]; 		// 0x0A18 XEKEYEX_IPTV_AV_PRIVATE_KEY: .set 0x103
	 BYTE abIptvAuthPrvKey[0x390]; 		// 0x0DA8 XEKEYEX_IPTV_AUTH_PRIVATE_KEY: .set 0x104
	 BYTE abIptvAvCert[0x5DC]; 			// 0x1138 XEKEYEX_IPTV_AV_CERTIFICATE: .set 0x105
	 BYTE abIptvAuthCert[0x5DC]; 		// 0x1714 XEKEYEX_IPTV_AUTH_CERTIFICATE: .set 0x106
	 BYTE abIptvAvSerializedCert[0x5DC]; // 0x1CF0 XEKEYEX_IPTV_AV_SERIALIZED_CERTIFICATE: .set 0x107
	 BYTE abIptvAuthSerializedCert[0x5DC];// 0x22CC XEKEYEX_IPTV_AUTH_SERIALIZED_CERTIFICATE: .set 0x108
	 BYTE abVidDevPrPubKeySign[0x40]; 	// 0x28A8 XEKEYEX_VIDEO_DEVICE_PR_PUBLIC_KEY_SIGN: .set 0x109
	 BYTE abVidDevPrPrvKeySign[0x20]; 	// 0x28C8 XEKEYEX_VIDEO_DEVICE_PR_PRIVATE_KEY_SIGN: .set 0x10A
	 BYTE abVidDevPrPubKeyEnc[0x40]; 	// 0x2908 XEKEYEX_VIDEO_DEVICE_PR_PUBLIC_KEY_ENCRYPT: .set 0x10B
	 BYTE abVidDevPrPrvKeyEnc[0x20]; 	// 0x2948 XEKEYEX_VIDEO_DEVICE_PR_PRIVATE_KEY_ENCRYPT: .set 0x10C
	 BYTE abVidDevPrCert[0x1388];		// 0x2968 XEKEYEX_VIDEO_DEVICE_PR_CERTIFICATE: .set 0x10D
	 BYTE pad[0x310];					// 0x3CF0
 }EXTENDED_BIN_DATA, *PEXTENDED_BIN_DATA;
 C_ASSERT(sizeof(EXTENDED_BIN_DATA) == 0x4000);

/* ******************* Functions ******************* */

#ifdef __cplusplus
extern "C" {
#endif
	NTSYSAPI
	EXPORTNUM(345)
	VOID
	NTAPI
	XeCryptAesKey(
		IN OUT	PXECRYPT_AES_STATE pAesState,
		IN		const PBYTE pbKey
	);

	NTSYSAPI
	EXPORTNUM(346)
	VOID
	NTAPI
	XeCryptAesEcb(
		IN		const PXECRYPT_AES_STATE pAesState,
		IN		const PBYTE pbInp,
		OUT		PBYTE pbOut,
		IN		BOOL fEncrypt
	);

	NTSYSAPI
	EXPORTNUM(347)
	VOID
	NTAPI
	XeCryptAesCbc(
		IN		const PXECRYPT_AES_STATE pAesState,
		IN		const PBYTE pbInp,
		IN		DWORD cbInp,
		OUT		PBYTE pbOut,
		IN		PBYTE pbFeed,
		IN		BOOL fEncrypt
	);

	NTSYSAPI
	EXPORTNUM(348)
	BOOL
	NTAPI
	XeCryptBnDwLeDhEqualBase(
		IN		const PDWORD pdwA,
		IN		const PXECRYPT_DH pDh
	);

	NTSYSAPI
	EXPORTNUM(349)
	BOOL
	NTAPI
	XeCryptBnDwLeDhInvalBase(
		IN		const PDWORD pdwA,
		IN		const PXECRYPT_DH pDh
	);

	NTSYSAPI
	EXPORTNUM(350)
	BOOL
	NTAPI
	XeCryptBnDwLeDhModExp(
		IN		const PDWORD pdwA,
		IN		const PDWORD pdwB,
		IN OUT	PDWORD pdwC,
		IN		const PXECRYPT_DH pDh
	);

	NTSYSAPI
	EXPORTNUM(351)
	VOID
	NTAPI
	XeCryptBnDw_Copy(
		IN		const PDWORD pdwInp,
		OUT		PDWORD pdwOut,
		IN		DWORD cdw
	);

	NTSYSAPI
	EXPORTNUM(352)
	VOID
	NTAPI
	XeCryptBnDw_SwapLeBe(
		IN		const PDWORD pdwInp,
		OUT		PDWORD pdwOut,
		IN		DWORD cdw
	);

	NTSYSAPI
	EXPORTNUM(353)
	VOID
	NTAPI
	XeCryptBnDw_Zero(
		IN OUT	PDWORD pdw,
		IN		DWORD cdw
	);

	NTSYSAPI
	EXPORTNUM(354)
	VOID
	NTAPI
	XeCryptBnDwLePkcs1Format(
		IN		const PBYTE pbHash,
		IN		DWORD dwType,
		IN OUT	PBYTE pbSig,
		IN		DWORD cbSig
	);

	NTSYSAPI
	EXPORTNUM(355)
	BOOL
	NTAPI
	XeCryptBnDwLePkcs1Verify(
		IN		const PBYTE pbHash,
		IN		const PBYTE pbSig,
		IN		DWORD cbSig
	);

	NTSYSAPI
	EXPORTNUM(356)
	BOOL
	NTAPI
	XeCryptBnQwBeSigCreate(
		IN OUT	PXECRYPT_SIG pSig,
		IN		const PBYTE pbHash,
		IN		const PBYTE pbSalt,
		IN		const PXECRYPT_RSA pRsa
	);

	NTSYSAPI
	EXPORTNUM(357)
	VOID
	NTAPI
	XeCryptBnQwBeSigFormat(
		IN OUT	PXECRYPT_SIG pSig,
		IN		const PBYTE pbHash,
		IN		const PBYTE pbSalt
	);

	NTSYSAPI
	EXPORTNUM(358)
	BOOL
	NTAPI
	XeCryptBnQwBeSigVerify(
		IN		PXECRYPT_SIG pSig,
		IN		const PBYTE pbHash,
		IN		const PBYTE pbSalt,
		IN		const PXECRYPT_RSA pRsa
	);
	
	NTSYSAPI
	EXPORTNUM(359)
	BOOL
	NTAPI
	XeCryptBnQwNeModExp(
		IN OUT	PQWORD pqwOut,
		IN		const PQWORD pqwIn,
		IN		const PQWORD pqwInExp,
		IN		const PQWORD pqwInMod,
		IN		DWORD cqw
	);

	NTSYSAPI
	EXPORTNUM(360)
	BOOL
	NTAPI
	XeCryptBnQwNeModExpRoot(
		IN OUT	PQWORD pqwOut,
		IN		const PQWORD pqwIn,
		IN		const PQWORD pqwPP,
		IN		const PQWORD pqwQQ,
		IN		const PQWORD pqwDP,
		IN		const PQWORD pqwDQ,
		IN		const PQWORD pqwCR,
		IN		DWORD cqw
	);

	NTSYSAPI
	EXPORTNUM(361)
	QWORD
	NTAPI
	XeCryptBnQwNeModInv(
		IN		QWORD qw
	);

	NTSYSAPI
	EXPORTNUM(362)
	VOID
	NTAPI
	XeCryptBnQwNeModMul(
		IN		const PQWORD pqwA,
		IN		const PQWORD pqwB,
		IN OUT	PQWORD pqwOut,
		IN		QWORD qwMI,
		IN		const PQWORD pqwM,
		IN		DWORD cqw
	);

	NTSYSAPI
	EXPORTNUM(363)
	BOOL
	NTAPI
	XeCryptBnQwNeRsaKeyGen(
		IN		DWORD cbits,
		IN		DWORD dwPubExp,
		OUT		PXECRYPT_RSA pRsaPub,
		OUT		PXECRYPT_RSA pRsaPrv
	);

	NTSYSAPI
	EXPORTNUM(364)
	BOOL
	NTAPI
	XeCryptBnQwNeRsaPrvCrypt(
		IN		const PQWORD pqwIn,
		IN OUT	PQWORD pqwOut,
		IN		const PXECRYPT_RSA pRsa
	);

	NTSYSAPI
	EXPORTNUM(365)
	BOOL
	NTAPI
	XeCryptBnQwNeRsaPubCrypt(
		IN 		const PQWORD pqwIn,
		IN OUT	PQWORD pqwOut,
		IN		const PXECRYPT_RSA pRsa
	);

	NTSYSAPI
	EXPORTNUM(366)
	VOID
	NTAPI
	XeCryptBnQw_Copy(
		IN		const PQWORD pqwInp,
		OUT		PQWORD pqwOut,
		IN		DWORD cqw
	);

	NTSYSAPI
	EXPORTNUM(367)
	VOID
	NTAPI
	XeCryptBnQw_SwapDwQw(
		IN		const PQWORD pqwInp,
		OUT		PQWORD pqwOut,
		IN		DWORD cqw
	);

	NTSYSAPI
	EXPORTNUM(368)
	VOID
	NTAPI
	XeCryptBnQw_SwapDwQwLeBe(
		IN		const PQWORD pqwInp,
		OUT		PQWORD pqwOut,
		IN		DWORD cqw
	);

	NTSYSAPI
	EXPORTNUM(369)
	VOID
	NTAPI
	XeCryptBnQw_SwapLeBe(
		IN		const PQWORD pqwInp,
		OUT		PQWORD pqwOut,
		IN		DWORD cqw
	);

	NTSYSAPI
	EXPORTNUM(370)
	VOID
	NTAPI
	XeCryptBnQw_Zero(
		IN OUT	PQWORD pqw,
		IN		DWORD cqw
	);

	NTSYSAPI
	EXPORTNUM(371)
	VOID
	NTAPI
	XeCryptChainAndSumMac(
		IN		const PDWORD pdwCD,
		IN		const PDWORD pdwAB,
		IN		const PDWORD pdwInp,
		IN		DWORD cdwInp,
		IN OUT	PDWORD pdwOut
	);

	NTSYSAPI
	EXPORTNUM(372)
	VOID
	NTAPI
	XeCryptDesParity(
		IN		const PBYTE pbInp,
		IN		DWORD cbInp,
		OUT		PBYTE pbOut
	);

	NTSYSAPI
	EXPORTNUM(373)
	VOID
	NTAPI
	XeCryptDesKey(
		IN OUT	PXECRYPT_DES_STATE pDesState,
		IN		const PBYTE pbKey
	);

	NTSYSAPI
	EXPORTNUM(374)
	VOID
	NTAPI
	XeCryptDesEcb(
		IN		const PXECRYPT_DES_STATE pDesState,
		IN		const PBYTE pbInp,
		OUT		PBYTE pbOut,
		IN		BOOL fEncrypt
	);

	NTSYSAPI
	EXPORTNUM(375)
	VOID
	NTAPI
	XeCryptDesCbc(
		IN		const PXECRYPT_DES_STATE pDesState,
		IN		const PBYTE pbInp,
		IN		DWORD cbInp,
		OUT		PBYTE pbOut,
		IN		PBYTE pbFeed,
		IN		BOOL fEncrypt
	);

	NTSYSAPI
	EXPORTNUM(376)
	VOID
	NTAPI
	XeCryptDes3Key(
		IN OUT	PXECRYPT_DES3_STATE pDes3State,
		IN		const PBYTE pbKey
	);

	NTSYSAPI
	EXPORTNUM(377)
	VOID
	NTAPI
	XeCryptDes3Ecb(
		IN		const PXECRYPT_DES3_STATE pDes3State,
		IN		const PBYTE pbInp,
		OUT		PBYTE pbOut,
		IN		BOOL fEncrypt
	);

	NTSYSAPI
	EXPORTNUM(378)
	VOID
	NTAPI
	XeCryptDes3Cbc(
		IN		const PXECRYPT_DES3_STATE pDes3State,
		IN		const PBYTE pbInp,
		IN		DWORD cbInp,
		OUT		PBYTE pbOut,
		IN		PBYTE pbFeed,
		IN		BOOL fEncrypt
	);

	NTSYSAPI
	EXPORTNUM(379)
	VOID
	NTAPI
	XeCryptHmacMd5Init(
		IN OUT	PXECRYPT_HMACMD5_STATE pHmacMd5State,
		IN		const PBYTE pbKey,
		IN		DWORD cbKey
	);

	NTSYSAPI
	EXPORTNUM(380)
	VOID
	NTAPI
	XeCryptHmacMd5Update(
		IN OUT	PXECRYPT_HMACMD5_STATE pHmacMd5State,
		IN		const PBYTE pbInp,
		IN		DWORD cbInp
	);

	NTSYSAPI
	EXPORTNUM(381)
	VOID
	NTAPI
	XeCryptHmacMd5Final(
		IN		PXECRYPT_HMACMD5_STATE pHmacMd5State,
		OUT		PBYTE pbOut,
		IN		DWORD cbOut
	);

	NTSYSAPI
	EXPORTNUM(382)
	VOID
	NTAPI
	XeCryptHmacMd5(
		IN		const PBYTE pbKey,
		IN		DWORD cbKey,
		IN		const PBYTE pbInp1,
		IN		DWORD cbInp1,
		IN		const PBYTE pbInp2,
		IN		DWORD cbInp2,
		IN		const PBYTE pbInp3,
		IN		DWORD cbInp3,
		OUT		PBYTE pbOut,
		IN		DWORD cbOut
	);
	
	NTSYSAPI
	EXPORTNUM(383)
	VOID
	NTAPI
	XeCryptHmacShaInit(
		IN OUT	PXECRYPT_HMACSHA_STATE pHmacShaState,
		IN		const PBYTE pbKey,
		IN		DWORD cbKey
	);

	NTSYSAPI
	EXPORTNUM(384)
	VOID
	NTAPI
	XeCryptHmacShaUpdate(
		IN OUT	PXECRYPT_HMACSHA_STATE pHmacShaState,
		IN		const PBYTE pbInp,
		IN		DWORD cbInp
	);

	NTSYSAPI
	EXPORTNUM(385)
	VOID
	NTAPI
	XeCryptHmacShaFinal(
		IN		PXECRYPT_HMACSHA_STATE pHmacShaState,
		OUT		PBYTE pbOut,
		IN		DWORD cbOut
	);

	NTSYSAPI
	EXPORTNUM(386)
	VOID
	NTAPI
	XeCryptHmacSha(
		IN		const PBYTE pbKey,
		IN		DWORD cbKey,
		IN		const PBYTE pbInp1,
		IN		DWORD cbInp1,
		IN		const PBYTE pbInp2,
		IN		DWORD cbInp2,
		IN		const PBYTE pbInp3,
		IN		DWORD cbInp3,
		OUT		PBYTE pbOut,
		IN		DWORD cbOut
	);

	NTSYSAPI
	EXPORTNUM(387)
	BOOL
	NTAPI
	XeCryptHmacShaVerify(
		IN		const PBYTE pbKey,
		IN		DWORD cbKey,
		IN		const PBYTE pbInp1,
		IN		DWORD cbInp1,
		IN		const PBYTE pbInp2,
		IN		DWORD cbInp2,
		IN		const PBYTE pbInp3,
		IN		DWORD cbInp3,
		IN		const PBYTE pbVer,
		IN		DWORD cbVer
	);

	NTSYSAPI
	EXPORTNUM(388)
	VOID
	NTAPI
	XeCryptMd5Init(
		IN OUT	PXECRYPT_MD5_STATE pMd5State
	);

	NTSYSAPI
	EXPORTNUM(389)
	VOID
	NTAPI
	XeCryptMd5Update(
		IN OUT	PXECRYPT_MD5_STATE pMd5State,
		IN		const PBYTE pbInp,
		IN		DWORD cbInp
	);

	NTSYSAPI
	EXPORTNUM(390)
	VOID
	NTAPI
	XeCryptMd5Final(
		IN		PXECRYPT_MD5_STATE pMd5State,
		OUT		PBYTE pbOut,
		IN		DWORD cbOut
	);

	NTSYSAPI
	EXPORTNUM(391)
	VOID
	NTAPI
	XeCryptMd5(
		IN		const PBYTE pbInp1,
		IN		DWORD cbInp1,
		IN		const PBYTE pbInp2,
		IN		DWORD cbInp2,
		IN		const PBYTE pbInp3,
		IN		DWORD cbInp3,
		OUT		PBYTE pbOut,
		IN		DWORD cbOut
	);

	NTSYSAPI
	EXPORTNUM(392)
	VOID
	NTAPI
	XeCryptParveEcb(
		IN		const PBYTE pbKey,
		IN		const PBYTE pbSbox,
		IN		const PBYTE pbInp,
		IN OUT	PBYTE pbOut
	);

	NTSYSAPI
	EXPORTNUM(393)
	VOID
	NTAPI
	XeCryptParveCbcMac(
		IN		const PBYTE pbKey,
		IN		const PBYTE pbSbox,
		IN		const PBYTE pbIv,
		IN		const PBYTE pbInp,
		IN		DWORD cbInp,
		IN OUT	PBYTE pbOut
	);

	NTSYSAPI
	EXPORTNUM(394)
	VOID
	NTAPI
	XeCryptRandom(
		OUT		BYTE * pb,
		IN		DWORD cb
	);

	NTSYSAPI
	EXPORTNUM(395)
	VOID
	NTAPI
	XeCryptRc4Key(
		IN OUT	PXECRYPT_RC4_STATE pRc4State,
		IN		const PBYTE pbKey,
		IN		DWORD cbKey
	);

	NTSYSAPI
	EXPORTNUM(396)
	VOID
	NTAPI
	XeCryptRc4Ecb(
		IN		PXECRYPT_RC4_STATE pRc4State,
		IN OUT	PBYTE pbInpOut,
		IN		DWORD cbInpOut
	);
	
	NTSYSAPI
	EXPORTNUM(397)
	VOID
	NTAPI
	XeCryptRc4(
		IN		const PBYTE pbKey,
		IN		DWORD cbKey,
		IN OUT	PBYTE pbInpOut,
		IN		DWORD cbInpOut
	);

	NTSYSAPI
	EXPORTNUM(398)
	VOID
	NTAPI
	XeCryptRotSumSha(
		IN		const PBYTE pbInp1,
		IN		DWORD cbInp1,
		IN		const PBYTE pbInp2,
		IN		DWORD cbInp2,
		OUT		PBYTE pbOut,
		IN		DWORD cbOut
	);

	NTSYSAPI
	EXPORTNUM(399)
	VOID
	NTAPI
	XeCryptShaInit(
		IN OUT	PXECRYPT_SHA_STATE pShaState
	);

	NTSYSAPI
	EXPORTNUM(400)
	VOID
	NTAPI
	XeCryptShaUpdate(
		IN OUT	PXECRYPT_SHA_STATE pShaState,
		IN		const PBYTE pbInp,
		IN		DWORD cbInp
	);

	NTSYSAPI
	EXPORTNUM(401)
	VOID
	NTAPI
	XeCryptShaFinal(
		IN		PXECRYPT_SHA_STATE pShaState,
		OUT		PBYTE pbOut,
		IN		DWORD cbOut
	);

	NTSYSAPI
	EXPORTNUM(402)
	VOID
	NTAPI
	XeCryptSha(
		IN		const PBYTE pbInp1,
		IN		DWORD cbInp1,
		IN		const PBYTE pbInp2,
		IN		DWORD cbInp2,
		IN		const PBYTE pbInp3,
		IN		DWORD cbInp3,
		OUT		PBYTE pbOut,
		IN		DWORD cbOut
	);

	NTSYSAPI
	EXPORTNUM(600)
	BOOL
	NTAPI
	XeKeysVerifyRSASignature(
		IN		XE_RSA_KEY_TYPE key,
		IN		const BYTE *pbHash,
		IN		const BYTE *pbSig,
		IN		const BYTE *pubKey
	);

	NTSYSAPI
	EXPORTNUM(806)
	int
	NTAPI
	XeCryptBnQwNeCompare(
		IN		const PQWORD pqwA,
		IN		const PQWORD pqwB,
		IN		DWORD cqw
	);
	/* ** not included
	XeCryptSha256Init @784
	XeCryptSha256Update @785
	XeCryptSha256Final @786
	XeCryptSha256 @787
	XeCryptSha384Init @788
	XeCryptSha384Update @789
	XeCryptSha384Final @792
	XeCryptSha384 @798
	XeCryptSha512Init @799
	XeCryptSha512Update @803
	XeCryptSha512Final @804
	XeCryptSha512 @805
	XeCryptAesCtr @863
	XeCryptAesCbcMac @864
	XeCryptAesDmMac @865
	** */

#ifdef __cplusplus
}
#endif


#endif // __KEXECRYPT_H

```

`XenonDumper/libs/xkelib/kernel/keXeKeys.h`:

```h
#ifndef __KEXEKEYS_H
#define __KEXEKEYS_H

/* note, not all keys are allowed to be accessed directly from kernel! */

#define XEKEY_CONSOLETYPE_DEVKIT	0x00000001
#define XEKEY_CONSOLETYPE_RETAIL	0x00000002
#define XEIKA_DATA_SIGNATURE		0x4F534947 // 'OSIG'
#define XEIKA_DATA_ODD_VERSION		0x1
#define XEIKA_DATA_VERSION			0x1

typedef enum _XEKEY_OBFUSCATE {
	XEKEY_OBFUSCATE_CONSOLE = 0, // uses XEKEY_CONSOLE_OBFUSCATION_KEY = 0x17
	XEKEY_OBFUSCATE_ROAM = 1, // uses XEKEY_ROAMABLE_OBFUSCATION_KEY = 0x19
} XEKEY_OBFUSCATE;

typedef enum _XEKEY_INDEX {
	XEKEY_MANUFACTURING_MODE = 0x0,
	XEKEY_ALTERNATE_KEY_VAULT = 0x1,
	XEKEY_RESTRICTED_PRIVILEGES_FLAGS = 0x2,
	XEKEY_RESERVED_BYTE3 = 0x3,
	XEKEY_ODD_FEATURES = 0x4,
	XEKEY_ODD_AUTHTYPE = 0x5,
	XEKEY_RESTRICTED_HVEXT_LOADER = 0x6,
	XEKEY_POLICY_FLASH_SIZE = 0x7,
	XEKEY_POLICY_BUILTIN_USBMU_SIZE = 0x8,
	XEKEY_RESERVED_DWORD4 = 0x9,
	XEKEY_RESTRICTED_PRIVILEGES = 0xA,
	XEKEY_RESERVED_QWORD2 = 0xB,
	XEKEY_RESERVED_QWORD3 = 0xC,
	XEKEY_RESERVED_QWORD4 = 0xD,
	XEKEY_RESERVED_KEY1 = 0xE,
	XEKEY_RESERVED_KEY2 = 0xF,
	XEKEY_RESERVED_KEY3 = 0x10,
	XEKEY_RESERVED_KEY4 = 0x11,
	XEKEY_RESERVED_RANDOM_KEY1 = 0x12,
	XEKEY_RESERVED_RANDOM_KEY2 = 0x13,
	XEKEY_CONSOLE_SERIAL_NUMBER = 0x14,
	XEKEY_MOBO_SERIAL_NUMBER = 0x15,
	XEKEY_GAME_REGION = 0x16,
	XEKEY_CONSOLE_OBFUSCATION_KEY = 0x17,
	XEKEY_KEY_OBFUSCATION_KEY = 0x18,
	XEKEY_ROAMABLE_OBFUSCATION_KEY = 0x19,
	XEKEY_DVD_KEY = 0x1A,
	XEKEY_PRIMARY_ACTIVATION_KEY = 0x1B,
	XEKEY_SECONDARY_ACTIVATION_KEY = 0x1C,
	XEKEY_GLOBAL_DEVICE_2DES_KEY1 = 0x1D,
	XEKEY_GLOBAL_DEVICE_2DES_KEY2 = 0x1E,
	XEKEY_WIRELESS_CONTROLLER_MS_2DES_KEY1 = 0x1F,
	XEKEY_WIRELESS_CONTROLLER_MS_2DES_KEY2 = 0x20,
	XEKEY_WIRED_WEBCAM_MS_2DES_KEY1 = 0x21,
	XEKEY_WIRED_WEBCAM_MS_2DES_KEY2 = 0x22,
	XEKEY_WIRED_CONTROLLER_MS_2DES_KEY1 = 0x23,
	XEKEY_WIRED_CONTROLLER_MS_2DES_KEY2 = 0x24,
	XEKEY_MEMORY_UNIT_MS_2DES_KEY1 = 0x25,
	XEKEY_MEMORY_UNIT_MS_2DES_KEY2 = 0x26,
	XEKEY_OTHER_XSM3_DEVICE_MS_2DES_KEY1 = 0x27,
	XEKEY_OTHER_XSM3_DEVICE_MS_2DES_KEY2 = 0x28,
	XEKEY_WIRELESS_CONTROLLER_3P_2DES_KEY1 = 0x29,
	XEKEY_WIRELESS_CONTROLLER_3P_2DES_KEY2 = 0x2A,
	XEKEY_WIRED_WEBCAM_3P_2DES_KEY1 = 0x2B,
	XEKEY_WIRED_WEBCAM_3P_2DES_KEY2 = 0x2C,
	XEKEY_WIRED_CONTROLLER_3P_2DES_KEY1 = 0x2D,
	XEKEY_WIRED_CONTROLLER_3P_2DES_KEY2 = 0x2E,
	XEKEY_MEMORY_UNIT_3P_2DES_KEY1 = 0x2F,
	XEKEY_MEMORY_UNIT_3P_2DES_KEY2 = 0x30,
	XEKEY_OTHER_XSM3_DEVICE_3P_2DES_KEY1 = 0x31,
	XEKEY_OTHER_XSM3_DEVICE_3P_2DES_KEY2 = 0x32,
	XEKEY_CONSOLE_PRIVATE_KEY = 0x33,
	XEKEY_XEIKA_PRIVATE_KEY = 0x34,
	XEKEY_CARDEA_PRIVATE_KEY = 0x35,
	XEKEY_CONSOLE_CERTIFICATE = 0x36,
	XEKEY_XEIKA_CERTIFICATE = 0x37,
	XEKEY_CARDEA_CERTIFICATE = 0x38,
	XEKEY_MAX_KEY_INDEX = 0x39,
	// constant keys
	XEKEY_CONSTANT_PIRS_KEY = 0x39,
	XEKEY_CONSTANT_ALT_MASTER_KEY = 0x3A,
	XEKEY_CONSTANT_ALT_LIVE_KEY = 0x3B,
	XEKEY_CONSTANT_MASTER_KEY = 0x3C,
	XEKEY_CONSTANT_LIVE_KEY = 0x3D,
	XEKEY_CONSTANT_XB1_GREEN_KEY = 0x3E,
	XEKEY_CONSTANT_SATA_DISK_SECURITY_KEY = 0x3F,
	XEKEY_CONSTANT_DEVICE_REVOCATION_KEY = 0x40,
	XEKEY_CONSTANT_XMACS_KEY = 0x41,
	XEKEY_CONSTANT_REVOCATION_LIST_NONCE = 0x42,
	XEKEY_CONSTANT_CROSS_PLATFORM_SYSLINK_KEY = 0x43,
	// special keys
	XEKEY_SPECIAL_KEY_VAULT_SIGNATURE = 0x44,
	XEKEY_SPECIAL_SECROM_DIGEST = 0x45,
	XEKEY_SPECIAL_SECDATA = 0x46,
	XEKEY_SPECIAL_DVD_FIRMWARE_KEY = 0x47,
	XEKEY_SPECIAL_DEBUG_UNLOCK = 0x48,
	XEKEY_SPECIAL_DEBUG_UNLOCK_STATE = 0x49,
	XEKEY_SPECIAL_IMAGE_OBFUSCATION_KEY = 0x4A,
	XEKEY_SPECIAL_DVD_HCRT_OBFUSCATION_KEY = 0x4B,
	XEKEY_SPECIAL_ROAMABLE_OBFUSCATION_KEY = 0x4C,
	XEKEY_SPECIAL_DATA_CENTER_KEY = 0x4D,
	XEKEY_MAX_CONSTANT_INDEX = 0x4E,
	// title keys
	XEKEY_TITLE_KEYS_BASE = 0xE0,
	XEKEY_TITLE_KEYS_LIMIT = 0xE8,
	XEKEY_TITLE_KEYS_RESET = 0xF0,
	// secured keys
	XEKEY_SECURED_DATA_BASE = 0x1000,
	XEKEY_SECURED_DATA_LIMIT = 0x2000,
} XEKEY_INDEX;

typedef enum _XEKEYEX_INDEX {
	XEKEYEX_COUNT = 0xE,
	XEKEYEX_START = 0xFF,
	// video device keys
	XEKEYEX_VIDEO_DEVICE_PUBLIC_KEY = 0x100,
	XEKEYEX_VIDEO_DEVICE_PRIVATE_KEY = 0x101,
	XEKEYEX_VIDEO_DEVICE_CERTIFICATE = 0x102,
	// IPTV keys
	XEKEYEX_IPTV_AV_PRIVATE_KEY = 0x103,
	XEKEYEX_IPTV_KEY_FIRST = 0x103,
	XEKEYEX_IPTV_AUTH_PRIVATE_KEY = 0x104,
	XEKEYEX_IPTV_AV_CERTIFICATE = 0x105,
	XEKEYEX_IPTV_AUTH_CERTIFICATE = 0x106,
	XEKEYEX_IPTV_AV_SERIALIZED_CERTIFICATE = 0x107,
	XEKEYEX_IPTV_AUTH_SERIALIZED_CERTIFICATE = 0x108,
	XEKEYEX_IPTV_KEY_LAST = 0x108,
	// more video device keys??
	XEKEYEX_VIDEO_DEVICE_PR_PUBLIC_KEY_SIGN = 0x109,
	XEKEYEX_VIDEO_DEVICE_PR_PRIVATE_KEY_SIGN = 0x10A,
	XEKEYEX_VIDEO_DEVICE_PR_PUBLIC_KEY_ENCRYPT = 0x10B,
	XEKEYEX_VIDEO_DEVICE_PR_PRIVATE_KEY_ENCRYPT = 0x10C,
	XEKEYEX_VIDEO_DEVICE_PR_CERTIFICATE = 0x10D,
	XEKEYEX_MAX_KEY_INDEX = 0x10E,
} XEKEYEX_INDEX;

typedef struct _XEKEYS_EXEC_HEADER {
	WORD magic; // ((this ^ hvmagic) & 0xF000) must equal 0; (this & 0x0F0F) must equal 0x0D0D
	WORD Build; // 2
	WORD Qfe; // 4
	WORD Flags; // 6
	DWORD Entry; // 8 must be 0x10 aligned and > 0x120, and < Size
	DWORD Size; // 0xC must be 0x10 aligned and > 0x120
	BYTE bNonce[0x10]; // data used to decrypt
} XEKEYS_EXEC_HEADER, *PXEKEYS_EXEC_HEADER;

typedef struct _XEIKA_ODD_DATA { 
	BYTE Version; // 0x0 sz:0x1
	BYTE PhaseLevel; // 0x1 sz:0x1
	BYTE InquiryData[0x24]; // 0x2 sz:0x24
} XEIKA_ODD_DATA, *PXEIKA_ODD_DATA; // size 38
C_ASSERT(sizeof(XEIKA_ODD_DATA) == 0x26);

// this is returned by XEKEY_XEIKA_CERTIFICATE, dev doesn't seem to have osig data
typedef struct _XEIKA_DATA { 
	XECRYPT_RSAPUB_2048 PublicKey; // 0x0 sz:0x110
	DWORD Signature; // 0x110 sz:0x4 typically XEIKA_DATA_SIGNATURE
	WORD Version; // 0x114 sz:0x2
	XEIKA_ODD_DATA OddData; // 0x116 sz:0x26
	BYTE Padding[0x4]; // 0x13C sz:0x4
} XEIKA_DATA, *PXEIKA_DATA; // size 320
C_ASSERT(sizeof(XEIKA_DATA) == 0x140); 

#pragma pack(push, 1)
typedef struct _XEIKA_CERTIFICATE { 
	WORD Size; // 0x0 sz:0x2
	XEIKA_DATA Data; // 0x2 sz:0x140
	BYTE Padding[0x1146]; // 0x142 sz:0x1146
	BYTE Reserved[0x100]; // 0x1288 sz:0x100
} XEIKA_CERTIFICATE, *PXEIKA_CERTIFICATE; // size 5000
C_ASSERT(sizeof(XEIKA_CERTIFICATE) == 0x1388);
#pragma pack(pop)



#endif // __KEXEKEYS_H

```

`XenonDumper/libs/xkelib/kernel/keXexInfo.h`:

```h
#ifndef __KEXEXINFO_H
#define __KEXEXINFO_H

// flags for XexLoadImage/XexLoadModule
#define XEX_MODULE_FLAG_TITLE_PROCESS   0x0001
#define XEX_MODULE_FLAG_TITLE_IMPORTS   0x0002
#define XEX_MODULE_FLAG_DEBUGGER        0x0004
#define XEX_MODULE_FLAG_DLL             0x0008
#define XEX_MODULE_FLAG_PATCH           0x0010
#define XEX_MODULE_FLAG_PATCH_FULL      0x0020
#define XEX_MODULE_FLAG_PATCH_DELTA     0x0040
#define XEX_MODULE_FLAG_USER_MODE		0x0080
#define XEX_MODULE_TYPE_TITLE 			(XEX_MODULE_FLAG_TITLE_PROCESS)
#define XEX_MODULE_TYPE_TITLE_DLL 		(XEX_MODULE_FLAG_TITLE_PROCESS | XEX_MODULE_FLAG_DLL)
#define XEX_MODULE_TYPE_SYSTEM_APP 		(XEX_MODULE_FLAG_DLL)
#define XEX_MODULE_TYPE_SYSTEM_DLL 		(XEX_MODULE_FLAG_DLL | XEX_MODULE_FLAG_TITLE_IMPORTS)

#define XEX_MODULE_FLAG_BOUND_PATH      0x40000000
#define XEX_MODULE_FLAG_SILENT_LOAD     0x80000000

typedef enum XEXPRIVS{
	XEX_PRIVILEGE_NO_FORCE_REBOOT					= 0,
	XEX_PRIVILEGE_FOREGROUND_TASKS					= 1,
	XEX_PRIVILEGE_NO_ODD_MAPPING					= 2,
	XEX_PRIVILEGE_HANDLE_MCE_INPUT					= 3,
	XEX_PRIVILEGE_RESTRICT_HUD_FEATURES				= 4,
	XEX_PRIVILEGE_HANDLE_GAMEPAD_DISCONNECT			= 5,
	XEX_PRIVILEGE_INSECURE_SOCKETS					= 6,
	XEX_PRIVILEGE_RESERVED_7						= 7, /*(Xbox1 XSP interop)*/
	XEX_PRIVILEGE_SET_DASH_CONTEXT					= 8,
	XEX_PRIVILEGE_TITLE_USES_GAME_VOICE_CHANNEL		= 9,
	XEX_PRIVILEGE_TITLE_PAL50_INCOMPATIBLE			= 10,
	XEX_PRIVILEGE_TITLE_INSECURE_UTILITYDRIVE		= 11,
	XEX_PRIVILEGE_TITLE_XAM_HOOKS					= 12,
	XEX_PRIVILEGE_TITLE_PII							= 13,
	XEX_PRIVILEGE_CROSSPLATFORM_SYSTEM_LINK			= 14,
	XEX_PRIVILEGE_MULTIDISC_SWAP					= 15,
	XEX_PRIVILEGE_MULTIDISC_INSECURE_MEDIA			= 16,
	XEX_PRIVILEGE_AUTHENTICATION_EX_REQUIRED		= 17,/*(AP25 Media)*/
	XEX_PRIVILEGE_NO_CONFIRM_EXIT					= 18,
	XEX_PRIVILEGE_ALLOW_BACKGROUND_DOWNLOAD			= 19,
	XEX_PRIVILEGE_CREATE_PERSISTABLE_RAMDRIVE		= 20,
	XEX_PRIVILEGE_INHERIT_PERSISTED_RAMDRIVE		= 21,
	XEX_PRIVILEGE_ALLOW_HUD_VIBRATION				= 22,
	XEX_PRIVILEGE_TITLE_BOTH_UTILITY_PARTITIONS		= 23,
	XEX_PRIVILEGE_HANDLE_IPTV_INPUT					= 24,
	XEX_PRIVILEGE_PREFER_BIGBUTTON_INPUT			= 25,
	XEX_PRIVILEGE_RESERVED_26						= 26,
	XEX_PRIVILEGE_MULTIDISC_CROSS_TITLE				= 27,
	XEX_PRIVILEGE_TITLE_INSTALL_INCOMPATIBLE		= 28,
	XEX_PRIVILEGE_ALLOW_AVATAR_GET_METADATA_BY_XUID	= 29,
	XEX_PRIVILEGE_ALLOW_CONTROLLER_SWAPPING			= 30,
	XEX_PRIVILEGE_DASH_EXTENSIBILITY_MODULE			= 31,

	XEX_PRIVILEGE_ALLOW_NETWORK_READ_CANCEL			= 32,
	XEX_PRIVILEGE_UNINTERRUPTABLE_READS				= 33,
	XEX_PRIVILEGE_REQUIRE_EXPERIENCE_FULL			= 34,
	XEX_PRIVILEGE_GAMEVOICE_REQUIRED_UI 			= 35,
	XEX_PRIVILEGE_TITLE_SET_PRESENCE_STRING 		= 36,
	XEX_PRIVILEGE_NATAL_TILT_CONTROL 				= 37,
	XEX_PRIVILEGE_TITLE_REQUIRES_SKELETAL_TRACKING	= 38,
	XEX_PRIVILEGE_TITLE_SUPPORTS_SKELETAL_TRACKING	= 39,
	XEX_PRIVILEGE_USE_LARGE_HDS_FILE_CACHE          = 40,
	XEX_PRIVILEGE_TITLE_SUPPORTS_DEEP_LINK          = 41,
	XEX_PRIVILEGE_TITLE_BODY_PROFILE                = 42,
	XEX_PRIVILEGE_TITLE_WINUSB                      = 43,
	XEX_PRIVILEGE_TITLE_SUPPORTS_DEEP_LINK_REFRESH  = 44,
	XEX_PRIVILEGE_LOCAL_ONLY_SOCKETS                = 45,
	XEX_PRIVILEGE_TITLE_CONTENT_ACQUIRE_AND_DOWNLOAD= 46,

};

typedef struct _CV_INFO_PDB70 {
	DWORD      CvSignature; 
	GUID       Guid;       // unique identifier 
	DWORD      Age;             // an always-incrementing value 
	BYTE       PdbFileName[1];  // zero terminated string with the name of the PDB file 
} CV_INFO_PDB70, *PCV_INFO_PDB70;

typedef struct _PAGE_DESCIPTION {
	DWORD	Size : 28;
	DWORD	Info : 4;
} PAGE_DESCIPTION, *PPAGE_DESCIPTION;
C_ASSERT(sizeof(PAGE_DESCIPTION) == 0x4);

typedef struct _HV_PAGE_INFO { 
	PAGE_DESCIPTION PageDescription; // 0x0 sz:0x4
	BYTE DataDigest[0x14]; // 0x4 sz:0x14
} HV_PAGE_INFO, *PHV_PAGE_INFO; // size 24
C_ASSERT(sizeof(HV_PAGE_INFO) == 0x18);

typedef struct _HV_IMAGE_EXPORT_TABLE { 
	DWORD Magic[3]; // 0x0 sz:0xC
	DWORD ModuleNumber[2]; // 0xC sz:0x8
	DWORD Version[3]; // 0x14 sz:0xC
	DWORD ImageBaseAddress; // 0x20 sz:0x4
	DWORD Count; // 0x24 sz:0x4
	DWORD Base; // 0x28 sz:0x4
} HV_IMAGE_EXPORT_TABLE, *PHV_IMAGE_EXPORT_TABLE; // size 44
C_ASSERT(sizeof(HV_IMAGE_EXPORT_TABLE) == 0x2C);

typedef struct _HV_IMAGE_IMPORT_TABLE { 
	BYTE NextImportDigest[0x14]; // 0x0 sz:0x14
	DWORD ModuleNumber; // 0x14 sz:0x4
	DWORD Version[2]; // 0x18 sz:0x8
	BYTE Unused; // 0x20 sz:0x1
	BYTE ModuleIndex; // 0x21 sz:0x1
	WORD ImportCount; // 0x22 sz:0x2
} HV_IMAGE_IMPORT_TABLE, *PHV_IMAGE_IMPORT_TABLE; // size 36
C_ASSERT(sizeof(HV_IMAGE_IMPORT_TABLE) == 0x24);

typedef struct _XEX_EXECUTION_ID { 
	DWORD MediaID; // 0x0 sz:0x4
	DWORD Version; // 0x4 sz:0x4
	DWORD BaseVersion; // 0x8 sz:0x4
	union {
		DWORD TitleID; // 0xC sz:0x4
		struct {
			WORD PublisherID; // 0xC sz:0x2
			WORD GameID; // 0xE sz:0x2
		};
	};
	BYTE Platform; // 0x10 sz:0x1
	BYTE ExecutableType; // 0x11 sz:0x1
	BYTE DiscNum; // 0x12 sz:0x1
	BYTE DiscsInSet; // 0x13 sz:0x1
	DWORD SaveGameID; // 0x14 sz:0x4
} XEX_EXECUTION_ID, *PXEX_EXECUTION_ID; // size 24
C_ASSERT(sizeof(XEX_EXECUTION_ID) == 0x18);

typedef struct _XEX_IMPORT_TABLE_ENT {
	DWORD ImportDestAddr;
	DWORD ImportStubAddr;
} XEX_IMPORT_TABLE_ENT, *PXEX_IMPORT_TABLE_ENT;

typedef struct _XEX_IMPORT_TABLE { 
	DWORD TableSize;
	BYTE NextImportDigest[20];
	DWORD ModuleNumber;
	DWORD Version[2];
	BYTE Unused;
	BYTE ModuleIndex;
	WORD ImportCount;
	DWORD ImportStubAddr[1];
} XEX_IMPORT_TABLE, *PXEX_IMPORT_TABLE;

typedef struct _XEX_IMPORT_TABLE_ORG { 
	DWORD TableSize; // 0x0 sz:0x4
	HV_IMAGE_IMPORT_TABLE ImportTable; // 0x4 sz:0x24
} XEX_IMPORT_TABLE_ORG, *PXEX_IMPORT_TABLE_ORG; // size 40
C_ASSERT(sizeof(XEX_IMPORT_TABLE_ORG) == 0x28);

typedef struct _XEX_IMPORT_DESCRIPTOR { 
	DWORD Size; // 0x0 sz:0x4
	DWORD NameTableSize; // 0x4 sz:0x4
	DWORD ModuleCount; // 0x8 sz:0x4
	// nametable is here of nametable size
	// followed by modulecount number of xex import tables
} XEX_IMPORT_DESCRIPTOR, *PXEX_IMPORT_DESCRIPTOR; // size 12
C_ASSERT(sizeof(XEX_IMPORT_DESCRIPTOR) == 0xC);

typedef struct _IMAGE_EXPORT_ADDRESS_TABLE { 
	DWORD Magic[3]; // 48 00 00 00 00 48 56 45 48 00 00 00
	DWORD ModuleNumber[2];
	DWORD Version[3];
	DWORD ImageBaseAddress; // must be <<16 to be accurate
	DWORD Count;
	DWORD Base;
	DWORD ordOffset[1]; // ordOffset[0]+ (ImageBaseAddress<<8) = function offset of ordinal 1
} IMAGE_EXPORT_ADDRESS_TABLE, *PIMAGE_EXPORT_ADDRESS_TABLE;

typedef struct _HV_IMAGE_INFO { 
	BYTE Signature[0x100]; // 0x0 sz:0x100
	DWORD InfoSize; // 0x100 sz:0x4
	DWORD ImageFlags; // 0x104 sz:0x4
	DWORD LoadAddress; // 0x108 sz:0x4
	BYTE ImageHash[0x14]; // 0x10C sz:0x14
	DWORD ImportTableCount; // 0x120 sz:0x4
	BYTE ImportDigest[0x14]; // 0x124 sz:0x14
	BYTE MediaID[0x10]; // 0x138 sz:0x10
	BYTE ImageKey[0x10]; // 0x148 sz:0x10
	DWORD ExportTableAddress; // 0x158 sz:0x4
	BYTE HeaderHash[0x14]; // 0x15C sz:0x14
	DWORD GameRegion; // 0x170 sz:0x4
} HV_IMAGE_INFO, *PHV_IMAGE_INFO; // size 372
C_ASSERT(sizeof(HV_IMAGE_INFO) == 0x174);

typedef struct _XEX_SECURITY_INFO { 
	DWORD Size; // 0x0 sz:0x4
	DWORD ImageSize; // 0x4 sz:0x4
	HV_IMAGE_INFO ImageInfo; // 0x8 sz:0x174
	DWORD AllowedMediaTypes; // 0x17C sz:0x4
	DWORD PageDescriptorCount; // 0x180 sz:0x4
} XEX_SECURITY_INFO, *PXEX_SECURITY_INFO; // size 388
C_ASSERT(sizeof(XEX_SECURITY_INFO) == 0x184);

typedef struct _XEX_HEADER_STRING { 
	DWORD Size; // 0x0 sz:0x4
	BYTE Data[1]; // 0x4 sz:0x1
} XEX_HEADER_STRING, *PXEX_HEADER_STRING; // size 8
C_ASSERT(sizeof(XEX_HEADER_STRING) == 0x8);

typedef struct _IMAGE_XEX_HEADER { 
	DWORD Magic; // 0x0 sz:0x4
	DWORD ModuleFlags; // 0x4 sz:0x4
	DWORD SizeOfHeaders; // 0x8 sz:0x4
	DWORD SizeOfDiscardableHeaders; // 0xC sz:0x4
	DWORD SecurityInfo; // 0x10 sz:0x4
	DWORD HeaderDirectoryEntryCount; // 0x14 sz:0x4
} IMAGE_XEX_HEADER, *PIMAGE_XEX_HEADER; // size 24
C_ASSERT(sizeof(IMAGE_XEX_HEADER) == 0x18);

typedef struct _LDR_DATA_TABLE_ENTRY { 
	LIST_ENTRY InLoadOrderLinks;  // 0x0 sz:0x8
	LIST_ENTRY InClosureOrderLinks;  // 0x8 sz:0x8
	LIST_ENTRY InInitializationOrderLinks; // 0x10 sz:0x8
	PVOID NtHeadersBase; // 0x18 sz:0x4
	PVOID ImageBase; // 0x1C sz:0x4
	DWORD SizeOfNtImage; // 0x20 sz:0x4
	UNICODE_STRING FullDllName; // 0x24 sz:0x8
	UNICODE_STRING BaseDllName; // 0x2C sz:0x8
	DWORD Flags; // 0x34 sz:0x4
	DWORD SizeOfFullImage; // 0x38 sz:0x4
	PVOID EntryPoint; // 0x3C sz:0x4
	WORD LoadCount; // 0x40 sz:0x2
	WORD ModuleIndex; // 0x42 sz:0x2
	PVOID DllBaseOriginal; // 0x44 sz:0x4
	DWORD CheckSum; // 0x48 sz:0x4
	DWORD ModuleLoadFlags; // 0x4C sz:0x4
	DWORD TimeDateStamp; // 0x50 sz:0x4
	PVOID LoadedImports; // 0x54 sz:0x4
	PVOID XexHeaderBase; // 0x58 sz:0x4
	union{
		STRING LoadFileName; // 0x5C sz:0x8
		struct {
			PVOID ClosureRoot; // 0x5C sz:0x4 LDR_DATA_TABLE_ENTRY
			PVOID TraversalParent; // 0x60 sz:0x4 LDR_DATA_TABLE_ENTRY
		} asEntry;
	} inf;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY; // size 100
C_ASSERT(sizeof(LDR_DATA_TABLE_ENTRY) == 0x64);

typedef struct _XEX_GAME_RATINGS {
	BYTE	Ratings[0x40];
} XEX_GAME_RATINGS, *PXEX_GAME_RATINGS;

typedef struct _XEX_LAN_KEY {
	BYTE	Key[0x10];
} XEX_LAN_KEY, *PXEX_LAN_KEY;

typedef struct _IMAGE_XEX_DIRECTORY_ENTRY { 
	DWORD Key; // 0x0 sz:0x4
	DWORD Value; // 0x4 sz:0x4
} IMAGE_XEX_DIRECTORY_ENTRY, *PIMAGE_XEX_DIRECTORY_ENTRY; // size 8
C_ASSERT(sizeof(IMAGE_XEX_DIRECTORY_ENTRY) == 0x8);

typedef struct _XEX_SECTION_HEADER { 
	char SectionName[0x8]; // 0x0 sz:0x8
	DWORD VirtualAddress; // 0x8 sz:0x4
	DWORD VirtualSize; // 0xC sz:0x4
} XEX_SECTION_HEADER, *PXEX_SECTION_HEADER; // size 16
C_ASSERT(sizeof(XEX_SECTION_HEADER) == 0x10);

typedef struct _XEX_SECTION_INFO {
	DWORD			   Size;
	XEX_SECTION_HEADER Section[1];
} XEX_SECTION_INFO, *PXEX_SECTION_INFO;

typedef struct _XEX_DATA_DESCRIPTOR { 
	DWORD Size; // 0x0 sz:0x4
	BYTE DataDigest[0x14]; // 0x4 sz:0x14
} XEX_DATA_DESCRIPTOR, *PXEX_DATA_DESCRIPTOR; // size 24
C_ASSERT(sizeof(XEX_DATA_DESCRIPTOR) == 0x18);

typedef struct _XEX_COMPRESSED_DATA_DESCRIPTOR { 
	DWORD WindowSize; // 0x0 sz:0x4
	XEX_DATA_DESCRIPTOR FirstDescriptor; // 0x4 sz:0x18
} XEX_COMPRESSED_DATA_DESCRIPTOR, *PXEX_COMPRESSED_DATA_DESCRIPTOR; // size 28
C_ASSERT(sizeof(XEX_COMPRESSED_DATA_DESCRIPTOR) == 0x1C);

typedef struct _XEX_RAW_DATA_DESCRIPTOR { 
	DWORD DataSize; // 0x0 sz:0x4
	DWORD ZeroSize; // 0x4 sz:0x4
} XEX_RAW_DATA_DESCRIPTOR, *PXEX_RAW_DATA_DESCRIPTOR; // size 8
C_ASSERT(sizeof(XEX_RAW_DATA_DESCRIPTOR) == 0x8);

#define XEX_DATA_FLAG_ENCRYPTED             0x0001
#define XEX_DATA_FORMAT_NONE                0x0000
#define XEX_DATA_FORMAT_RAW                 0x0001
#define XEX_DATA_FORMAT_COMPRESSED          0x0002
#define XEX_DATA_FORMAT_DELTA_COMPRESSED    0x0003

typedef struct _XEX_FILE_DATA_DESCRIPTOR { 
	DWORD Size; // 0x0 sz:0x4
	WORD Flags; // 0x4 sz:0x2
	WORD Format; // 0x6 sz:0x2
	// union {
		// XEX_DATA_DESCRIPTOR data;
		// XEX_RAW_DATA_DESCRIPTOR raw;
		// XEX_COMPRESSED_DATA_DESCRIPTOR compressed;
	// } fmt;
} XEX_FILE_DATA_DESCRIPTOR, *PXEX_FILE_DATA_DESCRIPTOR; // size 8
C_ASSERT(sizeof(XEX_FILE_DATA_DESCRIPTOR) == 0x8);

typedef struct _XEX_DELTA_PATCH_DESCRIPTOR { 
	DWORD Size; // 0x0 sz:0x4
	DWORD TargetVersion; // 0x4 sz:0x4
	DWORD SourceVersion; // 0x8 sz:0x4
	BYTE DigestSource[0x14]; // 0xC sz:0x14
	BYTE ImageKeySource[0x10]; // 0x20 sz:0x10
	DWORD SizeOfTargetHeaders; // 0x30 sz:0x4
	DWORD DeltaHeadersSourceOffset; // 0x34 sz:0x4
	DWORD DeltaHeadersSourceSize; // 0x38 sz:0x4
	DWORD DeltaHeadersTargetOffset; // 0x3C sz:0x4
	DWORD DeltaImageSourceOffset; // 0x40 sz:0x4
	DWORD DeltaImageSourceSize; // 0x44 sz:0x4
	DWORD DeltaImageTargetOffset; // 0x48 sz:0x4
} XEX_DELTA_PATCH_DESCRIPTOR, *PXEX_DELTA_PATCH_DESCRIPTOR; // size 76
C_ASSERT(sizeof(XEX_DELTA_PATCH_DESCRIPTOR) == 0x4C);

typedef struct _XEX_VITAL_STATS { 
	DWORD CheckSum; // 0x0 sz:0x4
	DWORD TimeDateStamp; // 0x4 sz:0x4
} XEX_VITAL_STATS, *PXEX_VITAL_STATS; // size 8
C_ASSERT(sizeof(XEX_VITAL_STATS) == 0x8);

typedef struct _XEX_CALLCAP_IMPORTS { 
	DWORD BeginFunctionThunkAddress; // 0x0 sz:0x4
	DWORD EndFunctionThunkAddress; // 0x4 sz:0x4
} XEX_CALLCAP_IMPORTS, *PXEX_CALLCAP_IMPORTS; // size 8
C_ASSERT(sizeof(XEX_CALLCAP_IMPORTS) == 0x8);

// #if defined(_M_PPCBE)
// #pragma bitfield_order(push, lsb_to_msb)
// #endif

typedef struct _XEXIMAGE_LIBRARY_VERSION { 
	BYTE LibraryName[0x8]; // 0x0 sz:0x8
	WORD MajorVersion; // 0x8 sz:0x2
	WORD MinorVersion; // 0xA sz:0x2
	WORD BuildVersion; // 0xC sz:0x2
	// union{
		// WORD AsWord;
		// struct {
			WORD DebugBuild : 1; // 0xE bfo:0x15
			WORD ApprovedLibrary : 2; // 0xE bfo:0x13
			WORD XEXVersion : 1; // 0xE bfo:0x12
			WORD Unused2 : 1; // 0xE bfo:0x11
			WORD ToolVersion : 1; // 0xE bfo:0x10
			WORD Unused1 : 2; // 0xE bfo:0x8
			WORD QFEVersion : 8; // 0xE bfo:0x0
		// } AsBits;
	// } bf;
} XEXIMAGE_LIBRARY_VERSION, *PXEXIMAGE_LIBRARY_VERSION; // size 16
C_ASSERT(sizeof(XEXIMAGE_LIBRARY_VERSION) == 0x10);

// #if defined(_M_PPCBE)
// #pragma bitfield_order(pop)
// #endif

typedef struct _XEX_TLS_DATA { 
	DWORD TlsSlotCount; // 0x0 sz:0x4
	PVOID AddressOfRawData; // 0x4 sz:0x4
	DWORD SizeOfRawData; // 0x8 sz:0x4
	DWORD SizeOfTlsData; // 0xC sz:0x4
} XEX_TLS_DATA, *PXEX_TLS_DATA; // size 16
C_ASSERT(sizeof(XEX_TLS_DATA) == 0x10);

typedef struct _XEX_SERVICE_ID_LIST { 
	DWORD Size; // 0x0 sz:0x4
	DWORD CustomServiceIDs[0x4]; // 0x4 sz:0x10
} XEX_SERVICE_ID_LIST, *PXEX_SERVICE_ID_LIST; // size 20
C_ASSERT(sizeof(XEX_SERVICE_ID_LIST) == 0x14);

typedef struct _XEX_KEY_VAULT_PRIVILEGES { 
	QWORD Mask; // 0x0 sz:0x8
	QWORD Match; // 0x8 sz:0x8
} XEX_KEY_VAULT_PRIVILEGES, *PXEX_KEY_VAULT_PRIVILEGES; // size 16
C_ASSERT(sizeof(XEX_KEY_VAULT_PRIVILEGES) == 0x10);

typedef struct _XEX_SYSTEM_TIME_RANGE { 
	QWORD Start; // 0x0 sz:0x8
	QWORD End; // 0x8 sz:0x8
} XEX_SYSTEM_TIME_RANGE, *PXEX_SYSTEM_TIME_RANGE; // size 16
C_ASSERT(sizeof(XEX_SYSTEM_TIME_RANGE) == 0x10);

typedef struct _XEX_PAGE_HEAP_OPTIONS { 
	DWORD Size; // 0x0 sz:0x4
	DWORD Flags; // 0x4 sz:0x4
} XEX_PAGE_HEAP_OPTIONS, *PXEX_PAGE_HEAP_OPTIONS; // size 8
C_ASSERT(sizeof(XEX_PAGE_HEAP_OPTIONS) == 0x8);

typedef struct _XEX_CONSOLE_ID_TABLE { 
	DWORD Size; // 0x0 sz:0x4
	// console IDs here, this is just a regular sized struct
	//BYTE abConsoleId[0x5][(size/5)];
} XEX_CONSOLE_ID_TABLE, *PXEX_CONSOLE_ID_TABLE; // size 4
C_ASSERT(sizeof(XEX_CONSOLE_ID_TABLE) == 0x4);

#define XEX_LAN_KEY_SIZE				0x10

#define XEX_HEADER_STRUCT(key, struct)	(((key) << 8) | (sizeof (struct) >> 2))
#define XEX_HEADER_FIXED_SIZE(key, size)(((key) << 8) | ((size) >> 2))
#define XEX_HEADER_ULONG(key) 			(((key) << 8) | 1)
#define XEX_HEADER_FLAG(key) 			((key) << 8)
#define XEX_HEADER_SIZEDSTRUCT(key)		(((key) << 8) | 0xFF)
#define XEX_HEADER_STRING_FIELD(key)	XEX_HEADER_SIZEDSTRUCT(key)


// for RtlImageXexHeaderField, RtlImageXexHeaderString
#define XEX_HEADER_SECTION_TABLE			XEX_HEADER_SIZEDSTRUCT(0x0002)
#define XEX_FILE_DATA_DESCRIPTOR_HEADER		XEX_HEADER_SIZEDSTRUCT(0x0003)
#define XEX_PATCH_FILE_BASE_REFERENCE		XEX_HEADER_FIXED_SIZE(0x0004, 0x14)
#define XEX_HEADER_DELTA_PATCH_DESCRIPTOR	XEX_HEADER_SIZEDSTRUCT(5)
#define XEX_HEADER_KEY_VAULT_PRIVS			XEX_HEADER_STRUCT(0x0040, XEX_KEY_VAULT_PRIVILEGES)
#define XEX_HEADER_TIME_RANGE				XEX_HEADER_STRUCT(0x0041, XEX_SYSTEM_TIME_RANGE)
#define XEX_HEADER_CONSOLE_ID_TABLE			XEX_HEADER_SIZEDSTRUCT(0x0042) // lists disallowed console IDs
#define XEX_HEADER_BOUND_PATH				XEX_HEADER_STRING_FIELD(0x0080)
#define XEX_HEADER_DEVICE_ID				XEX_HEADER_FIXED_SIZE(0x0081, 0x14)
#define XEX_HEADER_ORIGINAL_BASE_ADDRESS	XEX_HEADER_ULONG(0x0100)
#define XEX_HEADER_ENTRY_POINT				XEX_HEADER_FLAG(0x0101)
#define XEX_HEADER_PE_BASE					XEX_HEADER_ULONG(0x0102)
#define XEX_HEADER_IMPORTS					XEX_HEADER_SIZEDSTRUCT(0x0103)
#define XEX_HEADER_PE_EXPORTS				XEX_HEADER_STRUCT(0xE104, IMAGE_DATA_DIRECTORY)
#define XEX_HEADER_VITAL_STATS				XEX_HEADER_STRUCT(0x0180, XEX_VITAL_STATS)
#define XEX_HEADER_CALLCAP_IMPORTS			XEX_HEADER_STRUCT(0x0181, XEX_CALLCAP_IMPORTS)
#define XEX_HEADER_FASTCAP_ENABLED			XEX_HEADER_FLAG(0x0182)
#define XEX_HEADER_PE_MODULE_NAME			XEX_HEADER_STRING_FIELD(0x0183)
#define XEX_HEADER_BUILD_VERSIONS			XEX_HEADER_SIZEDSTRUCT(0x0200)
#define XEX_HEADER_TLS_DATA					XEX_HEADER_STRUCT(0x201, XEX_TLS_DATA)
#define XEX_HEADER_STACK_SIZE				XEX_HEADER_FLAG(0x0202)
#define XEX_HEADER_FSCACHE_SIZE				XEX_HEADER_ULONG(0x203)
#define XEX_HEADER_XAPI_HEAP_SIZE			XEX_HEADER_ULONG(0x204)
#define XEX_HEADER_PAGE_HEAP_SIZE_FLAGS		XEX_HEADER_STRUCT(0x0280, XEX_PAGE_HEAP_OPTIONS)
#define XEX_HEADER_PRIVILEGE(priv)			(XEX_HEADER_FLAG(0x0300)+((priv&~0x1f)<<3))
#define XEX_HEADER_EXECUTION_ID				XEX_HEADER_STRUCT(0x400, XEX_EXECUTION_ID)
#define XEX_HEADER_SERVICE_ID_LIST			XEX_HEADER_SIZEDSTRUCT(0x401)
#define XEX_HEADER_WORKSPACE_SIZE			XEX_HEADER_ULONG(0x402)
#define XEX_HEADER_GAME_RATINGS				XEX_HEADER_FIXED_SIZE(0x403, XEX_NUMBER_GAME_RATING_SYSTEMS)
#define XEX_HEADER_LAN_KEY					XEX_HEADER_FIXED_SIZE(0x404, XEX_LAN_KEY_SIZE) // XEX_LAN_KEY_SIZE size is 0x10
#define XEX_HEADER_MSLOGO					XEX_HEADER_SIZEDSTRUCT(0x0405)
#define XEX_HEADER_MULTIDISK_MEDIA_IDS		XEX_HEADER_SIZEDSTRUCT(0x0406)
#define XEX_HEADER_ALTERNATE_TITLE_IDS		XEX_HEADER_SIZEDSTRUCT(0x0407)
#define XEX_HEADER_ADDITIONAL_TITLE_MEM		XEX_HEADER_ULONG(0x408)


#endif // __KEXEXINFO_H

```

`XenonDumper/libs/xkelib/kernel/kernelExpEnum.h`:

```h
// LIBRARY xboxkrnl.exe@21256.0+1861.0

typedef enum {
	kernelExp_DbgBreakPoint = 1,
	kernelExp_DbgBreakPointWithStatus = 2,
	kernelExp_DbgPrint = 3,
	kernelExp_DbgPrompt = 4,
	kernelExp_DumpGetRawDumpInfo = 5,
	kernelExp_DumpWriteDump = 6,
	kernelExp_ExAcquireReadWriteLockExclusive = 7,
	kernelExp_ExAcquireReadWriteLockShared = 8,
	kernelExp_ExAllocatePool = 9,
	kernelExp_ExAllocatePoolWithTag = 10,
	kernelExp_ExAllocatePoolTypeWithTag = 11,
	kernelExp_ExConsoleGameRegion = 12,
	kernelExp_ExCreateThread = 13,
	kernelExp_ExEventObjectType = 14,
	kernelExp_ExFreePool = 15,
	kernelExp_ExGetXConfigSetting = 16,
	kernelExp_ExInitializeReadWriteLock = 17,
	kernelExp_ExMutantObjectType = 18,
	kernelExp_ExQueryPoolBlockSize = 19,
	kernelExp_ExRegisterThreadNotification = 20,
	kernelExp_ExRegisterTitleTerminateNotification = 21,
	kernelExp_ExReleaseReadWriteLock = 22,
	kernelExp_ExSemaphoreObjectType = 23,
	kernelExp_ExSetXConfigSetting = 24,
	kernelExp_ExTerminateThread = 25,
	kernelExp_ExTerminateTitleProcess = 26,
	kernelExp_ExThreadObjectType = 27,
	kernelExp_ExTimerObjectType = 28,
	kernelExp_MmDoubleMapMemory = 29,
	kernelExp_MmUnmapMemory = 30,
	kernelExp_XeKeysGetConsoleCertificate = 31,
	kernelExp_FscGetCacheElementCount = 32,
	kernelExp_FscSetCacheElementCount = 33,
	kernelExp_HalGetCurrentAVPack = 34,
	kernelExp_HalGpioControl = 35,
	kernelExp_HalOpenCloseODDTray = 36,
	kernelExp_HalReadWritePCISpace = 37,
	kernelExp_HalRegisterPowerDownNotification = 38,
	kernelExp_HalRegisterSMCNotification = 39,
	kernelExp_HalReturnToFirmware = 40,
	kernelExp_HalSendSMCMessage = 41,
	kernelExp_HalSetAudioEnable = 42,
	kernelExp_InterlockedFlushSList = 43,
	kernelExp_InterlockedPopEntrySList = 44,
	kernelExp_InterlockedPushEntrySList = 45,
	kernelExp_IoAcquireDeviceObjectLock = 46,
	kernelExp_IoAllocateIrp = 47,
	kernelExp_IoBuildAsynchronousFsdRequest = 48,
	kernelExp_IoBuildDeviceIoControlRequest = 49,
	kernelExp_IoBuildSynchronousFsdRequest = 50,
	kernelExp_IoCallDriver = 51,
	kernelExp_IoCheckShareAccess = 52,
	kernelExp_IoCompleteRequest = 53,
	kernelExp_IoCompletionObjectType = 54,
	kernelExp_IoCreateDevice = 55,
	kernelExp_IoCreateFile = 56,
	kernelExp_IoDeleteDevice = 57,
	kernelExp_IoDeviceObjectType = 58,
	kernelExp_IoDismountVolume = 59,
	kernelExp_IoDismountVolumeByFileHandle = 60,
	kernelExp_IoDismountVolumeByName = 61,
	kernelExp_IoFileObjectType = 62,
	kernelExp_IoFreeIrp = 63,
	kernelExp_IoInitializeIrp = 64,
	kernelExp_IoInvalidDeviceRequest = 65,
	kernelExp_ExSetBetaFeaturesEnabled = 66,
	kernelExp_IoQueueThreadIrp = 67,
	kernelExp_IoReleaseDeviceObjectLock = 68,
	kernelExp_IoRemoveShareAccess = 69,
	kernelExp_IoSetIoCompletion = 70,
	kernelExp_IoSetShareAccess = 71,
	kernelExp_IoStartNextPacket = 72,
	kernelExp_IoStartNextPacketByKey = 73,
	kernelExp_IoStartPacket = 74,
	kernelExp_IoSynchronousDeviceIoControlRequest = 75,
	kernelExp_IoSynchronousFsdRequest = 76,
	kernelExp_KeAcquireSpinLockAtRaisedIrql = 77,
	kernelExp_KeAlertResumeThread = 78,
	kernelExp_KeAlertThread = 79,
	kernelExp_KeBlowFuses = 80,
	kernelExp_KeBoostPriorityThread = 81,
	kernelExp_KeBugCheck = 82,
	kernelExp_KeBugCheckEx = 83,
	kernelExp_KeCancelTimer = 84,
	kernelExp_KeConnectInterrupt = 85,
	kernelExp_KeContextFromKframes = 86,
	kernelExp_KeContextToKframes = 87,
	kernelExp_KeCreateUserMode = 88,
	kernelExp_KeDebugMonitorData = 89,
	kernelExp_KeDelayExecutionThread = 90,
	kernelExp_KeDeleteUserMode = 91,
	kernelExp_KeDisconnectInterrupt = 92,
	kernelExp_KeEnableFpuExceptions = 93,
	kernelExp_KeEnablePPUPerformanceMonitor = 94,
	kernelExp_KeEnterCriticalRegion = 95,
	kernelExp_KeEnterUserMode = 96,
	kernelExp_KeFlushCacheRange = 97,
	kernelExp_KeFlushCurrentEntireTb = 98,
	kernelExp_KeFlushEntireTb = 99,
	kernelExp_KeFlushUserModeCurrentTb = 100,
	kernelExp_KeFlushUserModeTb = 101,
	kernelExp_KeGetCurrentProcessType = 102,
	kernelExp_KeGetPMWRegister = 103,
	kernelExp_KeGetPRVRegister = 104,
	kernelExp_KeGetSocRegister = 105,
	kernelExp_KeGetSpecialPurposeRegister = 106,
	kernelExp_KeLockL2 = 107,
	kernelExp_KeUnlockL2 = 108,
	kernelExp_KeInitializeApc = 109,
	kernelExp_KeInitializeDeviceQueue = 110,
	kernelExp_KeInitializeDpc = 111,
	kernelExp_KeInitializeEvent = 112,
	kernelExp_KeInitializeInterrupt = 113,
	kernelExp_KeInitializeMutant = 114,
	kernelExp_KeInitializeQueue = 115,
	kernelExp_KeInitializeSemaphore = 116,
	kernelExp_KeInitializeTimerEx = 117,
	kernelExp_KeInsertByKeyDeviceQueue = 118,
	kernelExp_KeInsertDeviceQueue = 119,
	kernelExp_KeInsertHeadQueue = 120,
	kernelExp_KeInsertQueue = 121,
	kernelExp_KeInsertQueueApc = 122,
	kernelExp_KeInsertQueueDpc = 123,
	kernelExp_KeIpiGenericCall = 124,
	kernelExp_KeLeaveCriticalRegion = 125,
	kernelExp_KeLeaveUserMode = 126,
	kernelExp_KePulseEvent = 127,
	kernelExp_KeQueryBackgroundProcessors = 128,
	kernelExp_KeQueryBasePriorityThread = 129,
	kernelExp_KeQueryInterruptTime = 130,
	kernelExp_KeQueryPerformanceFrequency = 131,
	kernelExp_KeQuerySystemTime = 132,
	kernelExp_KeRaiseIrqlToDpcLevel = 133,
	kernelExp_KeRegisterDriverNotification = 134,
	kernelExp_KeReleaseMutant = 135,
	kernelExp_KeReleaseSemaphore = 136,
	kernelExp_KeReleaseSpinLockFromRaisedIrql = 137,
	kernelExp_KeRemoveByKeyDeviceQueue = 138,
	kernelExp_KeRemoveDeviceQueue = 139,
	kernelExp_KeRemoveEntryDeviceQueue = 140,
	kernelExp_KeRemoveQueue = 141,
	kernelExp_KeRemoveQueueDpc = 142,
	kernelExp_KeResetEvent = 143,
	kernelExp_KeRestoreFloatingPointState = 144,
	kernelExp_KeRestoreVectorUnitState = 145,
	kernelExp_KeResumeThread = 146,
	kernelExp_KeRetireDpcList = 147,
	kernelExp_KeRundownQueue = 148,
	kernelExp_KeSaveFloatingPointState = 149,
	kernelExp_KeSaveVectorUnitState = 150,
	kernelExp_KeSetAffinityThread = 151,
	kernelExp_KeSetBackgroundProcessors = 152,
	kernelExp_KeSetBasePriorityThread = 153,
	kernelExp_KeSetCurrentProcessType = 154,
	kernelExp_KeSetCurrentStackPointers = 155,
	kernelExp_KeSetDisableBoostThread = 156,
	kernelExp_KeSetEvent = 157,
	kernelExp_KeSetEventBoostPriority = 158,
	kernelExp_KeSetPMWRegister = 159,
	kernelExp_KeSetPowerMode = 160,
	kernelExp_KeSetPRVRegister = 161,
	kernelExp_KeSetPriorityClassThread = 162,
	kernelExp_KeSetPriorityThread = 163,
	kernelExp_KeSetSocRegister = 164,
	kernelExp_KeSetSpecialPurposeRegister = 165,
	kernelExp_KeSetTimer = 166,
	kernelExp_KeSetTimerEx = 167,
	kernelExp_KeStallExecutionProcessor = 168,
	kernelExp_KeSuspendThread = 169,
	kernelExp_KeSweepDcacheRange = 170,
	kernelExp_KeSweepIcacheRange = 171,
	kernelExp_KeTestAlertThread = 172,
	kernelExp_KeTimeStampBundle = 173,
	kernelExp_KeTryToAcquireSpinLockAtRaisedIrql = 174,
	kernelExp_KeWaitForMultipleObjects = 175,
	kernelExp_KeWaitForSingleObject = 176,
	kernelExp_KfAcquireSpinLock = 177,
	kernelExp_KfRaiseIrql = 178,
	kernelExp_KfLowerIrql = 179,
	kernelExp_KfReleaseSpinLock = 180,
	kernelExp_KiBugCheckData = 181,
	kernelExp_LDICreateDecompression = 182,
	kernelExp_LDIDecompress = 183,
	kernelExp_LDIDestroyDecompression = 184,
	kernelExp_MmAllocatePhysicalMemory = 185,
	kernelExp_MmAllocatePhysicalMemoryEx = 186,
	kernelExp_MmCreateKernelStack = 187,
	kernelExp_MmDeleteKernelStack = 188,
	kernelExp_MmFreePhysicalMemory = 189,
	kernelExp_MmGetPhysicalAddress = 190,
	kernelExp_MmIsAddressValid = 191,
	kernelExp_MmLockAndMapSegmentArray = 192,
	kernelExp_MmLockUnlockBufferPages = 193,
	kernelExp_MmMapIoSpace = 194,
	kernelExp_MmPersistPhysicalMemoryAllocation = 195,
	kernelExp_MmQueryAddressProtect = 196,
	kernelExp_MmQueryAllocationSize = 197,
	kernelExp_MmQueryStatistics = 198,
	kernelExp_MmSetAddressProtect = 199,
	kernelExp_MmSplitPhysicalMemoryAllocation = 200,
	kernelExp_MmUnlockAndUnmapSegmentArray = 201,
	kernelExp_MmUnmapIoSpace = 202,
	kernelExp_Nls844UnicodeCaseTable = 203,
	kernelExp_NtAllocateVirtualMemory = 204,
	kernelExp_NtCancelTimer = 205,
	kernelExp_NtClearEvent = 206,
	kernelExp_NtClose = 207,
	kernelExp_NtCreateDirectoryObject = 208,
	kernelExp_NtCreateEvent = 209,
	kernelExp_NtCreateFile = 210,
	kernelExp_NtCreateIoCompletion = 211,
	kernelExp_NtCreateMutant = 212,
	kernelExp_NtCreateSemaphore = 213,
	kernelExp_NtCreateSymbolicLinkObject = 214,
	kernelExp_NtCreateTimer = 215,
	kernelExp_NtDeleteFile = 216,
	kernelExp_NtDeviceIoControlFile = 217,
	kernelExp_NtDuplicateObject = 218,
	kernelExp_NtFlushBuffersFile = 219,
	kernelExp_NtFreeVirtualMemory = 220,
	kernelExp_NtMakeTemporaryObject = 221,
	kernelExp_NtOpenDirectoryObject = 222,
	kernelExp_NtOpenFile = 223,
	kernelExp_NtOpenSymbolicLinkObject = 224,
	kernelExp_NtProtectVirtualMemory = 225,
	kernelExp_NtPulseEvent = 226,
	kernelExp_NtQueueApcThread = 227,
	kernelExp_NtQueryDirectoryFile = 228,
	kernelExp_NtQueryDirectoryObject = 229,
	kernelExp_NtQueryEvent = 230,
	kernelExp_NtQueryFullAttributesFile = 231,
	kernelExp_NtQueryInformationFile = 232,
	kernelExp_NtQueryIoCompletion = 233,
	kernelExp_NtQueryMutant = 234,
	kernelExp_NtQuerySemaphore = 235,
	kernelExp_NtQuerySymbolicLinkObject = 236,
	kernelExp_NtQueryTimer = 237,
	kernelExp_NtQueryVirtualMemory = 238,
	kernelExp_NtQueryVolumeInformationFile = 239,
	kernelExp_NtReadFile = 240,
	kernelExp_NtReadFileScatter = 241,
	kernelExp_NtReleaseMutant = 242,
	kernelExp_NtReleaseSemaphore = 243,
	kernelExp_NtRemoveIoCompletion = 244,
	kernelExp_NtResumeThread = 245,
	kernelExp_NtSetEvent = 246,
	kernelExp_NtSetInformationFile = 247,
	kernelExp_NtSetIoCompletion = 248,
	kernelExp_NtSetSystemTime = 249,
	kernelExp_NtSetTimerEx = 250,
	kernelExp_NtSignalAndWaitForSingleObjectEx = 251,
	kernelExp_NtSuspendThread = 252,
	kernelExp_NtWaitForSingleObjectEx = 253,
	kernelExp_NtWaitForMultipleObjectsEx = 254,
	kernelExp_NtWriteFile = 255,
	kernelExp_NtWriteFileGather = 256,
	kernelExp_NtYieldExecution = 257,
	kernelExp_ObCreateObject = 258,
	kernelExp_ObCreateSymbolicLink = 259,
	kernelExp_ObDeleteSymbolicLink = 260,
	kernelExp_ObDereferenceObject = 261,
	kernelExp_ObDirectoryObjectType = 262,
	kernelExp_ObGetWaitableObject = 263,
	kernelExp_ObInsertObject = 264,
	kernelExp_ObIsTitleObject = 265,
	kernelExp_ObLookupAnyThreadByThreadId = 266,
	kernelExp_ObLookupThreadByThreadId = 267,
	kernelExp_ObMakeTemporaryObject = 268,
	kernelExp_ObOpenObjectByName = 269,
	kernelExp_ObOpenObjectByPointer = 270,
	kernelExp_ObReferenceObject = 271,
	kernelExp_ObReferenceObjectByHandle = 272,
	kernelExp_ObReferenceObjectByName = 273,
	kernelExp_ObSymbolicLinkObjectType = 274,
	kernelExp_ObTranslateSymbolicLink = 275,
	kernelExp_RtlAnsiStringToUnicodeString = 276,
	kernelExp_RtlAppendStringToString = 277,
	kernelExp_RtlAppendUnicodeStringToString = 278,
	kernelExp_RtlAppendUnicodeToString = 279,
	kernelExp_RtlAssert = 280,
	kernelExp_RtlCaptureContext = 281,
	kernelExp_RtlCompareMemory = 282,
	kernelExp_RtlCompareMemoryUlong = 283,
	kernelExp_RtlCompareString = 284,
	kernelExp_RtlCompareStringN = 285,
	kernelExp_RtlCompareUnicodeString = 286,
	kernelExp_RtlCompareUnicodeStringN = 287,
	kernelExp_RtlCompareUtf8ToUnicode = 288,
	kernelExp_RtlCopyString = 289,
	kernelExp_RtlCopyUnicodeString = 290,
	kernelExp_RtlCreateUnicodeString = 291,
	kernelExp_RtlDowncaseUnicodeChar = 292,
	kernelExp_RtlEnterCriticalSection = 293,
	kernelExp_RtlFillMemoryUlong = 294,
	kernelExp_RtlFreeAnsiString = 295,
// 	kernelExp_RtlFreeAnsiString = 296,
	kernelExp_RtlGetCallersAddress = 297,
	kernelExp_RtlGetStackLimits = 298,
	kernelExp_RtlImageXexHeaderField = 299,
	kernelExp_RtlInitAnsiString = 300,
	kernelExp_RtlInitUnicodeString = 301,
	kernelExp_RtlInitializeCriticalSection = 302,
	kernelExp_RtlInitializeCriticalSectionAndSpinCount = 303,
	kernelExp_RtlLeaveCriticalSection = 304,
	kernelExp_RtlLookupFunctionEntry = 305,
	kernelExp_RtlLowerChar = 306,
	kernelExp_RtlMultiByteToUnicodeN = 307,
	kernelExp_RtlMultiByteToUnicodeSize = 308,
	kernelExp_RtlNtStatusToDosError = 309,
	kernelExp_RtlRaiseException = 310,
	kernelExp_RtlRaiseStatus = 311,
	kernelExp_RtlRip = 312,
	kernelExp_RtlScprintf = 313, // _scprintf
	kernelExp_RtlSnprintf = 314, // _snprintf
	kernelExp_RtlSprintf = 315, // sprintf
	kernelExp_RtlScwprintf = 316, // _scwprintf
	kernelExp_RtlSnwprintf = 317, // _snwprintf
	kernelExp_RtlSwprintf = 318, // _swprintf
	kernelExp_RtlTimeFieldsToTime = 319,
	kernelExp_RtlTimeToTimeFields = 320,
	kernelExp_RtlTryEnterCriticalSection = 321,
	kernelExp_RtlUnicodeStringToAnsiString = 322,
	kernelExp_RtlUnicodeToMultiByteN = 323,
	kernelExp_RtlUnicodeToMultiByteSize = 324,
	kernelExp_RtlUnicodeToUtf8 = 325,
	kernelExp_RtlUnicodeToUtf8Size = 326,
	kernelExp_RtlUnwind = 327,
	kernelExp_RtlUnwind2 = 328,
	kernelExp_RtlUpcaseUnicodeChar = 329,
	kernelExp_RtlUpperChar = 330,
	kernelExp_RtlVirtualUnwind = 331,
	kernelExp_RtlVscprintf = 332, // _vscprintf
	kernelExp_RtlVsnprintf = 333, // _vsnprintf
	kernelExp_RtlVsprintf = 334, // vsprintf
	kernelExp_RtlVscwprintf = 335, // _vscwprintf
	kernelExp_RtlVsnwprintf = 336, // _vsnwprintf
	kernelExp_RtlVswprintf = 337, // _vswprintf
	kernelExp_KeTlsAlloc = 338, // TlsAlloc
	kernelExp_KeTlsFree = 339, // TlsFree
	kernelExp_KeTlsGetValue = 340, // TlsGetValue
	kernelExp_KeTlsSetValue = 341, // TlsSetValue
	kernelExp_XboxHardwareInfo = 342,
	kernelExp_XboxKrnlBaseVersion = 343,
	kernelExp_XboxKrnlVersion = 344,
	kernelExp_XeCryptAesKey = 345,
	kernelExp_XeCryptAesEcb = 346,
	kernelExp_XeCryptAesCbc = 347,
	kernelExp_XeCryptBnDwLeDhEqualBase = 348,
	kernelExp_XeCryptBnDwLeDhInvalBase = 349,
	kernelExp_XeCryptBnDwLeDhModExp = 350,
	kernelExp_XeCryptBnDw_Copy = 351,
	kernelExp_XeCryptBnDw_SwapLeBe = 352,
	kernelExp_XeCryptBnDw_Zero = 353,
	kernelExp_XeCryptBnDwLePkcs1Format = 354,
	kernelExp_XeCryptBnDwLePkcs1Verify = 355,
	kernelExp_XeCryptBnQwBeSigCreate = 356,
	kernelExp_XeCryptBnQwBeSigFormat = 357,
	kernelExp_XeCryptBnQwBeSigVerify = 358,
	kernelExp_XeCryptBnQwNeModExp = 359,
	kernelExp_XeCryptBnQwNeModExpRoot = 360,
	kernelExp_XeCryptBnQwNeModInv = 361,
	kernelExp_XeCryptBnQwNeModMul = 362,
	kernelExp_XeCryptBnQwNeRsaKeyGen = 363,
	kernelExp_XeCryptBnQwNeRsaPrvCrypt = 364,
	kernelExp_XeCryptBnQwNeRsaPubCrypt = 365,
	kernelExp_XeCryptBnQw_Copy = 366,
	kernelExp_XeCryptBnQw_SwapDwQw = 367,
	kernelExp_XeCryptBnQw_SwapDwQwLeBe = 368,
	kernelExp_XeCryptBnQw_SwapLeBe = 369,
	kernelExp_XeCryptBnQw_Zero = 370,
	kernelExp_XeCryptChainAndSumMac = 371,
	kernelExp_XeCryptDesParity = 372,
	kernelExp_XeCryptDesKey = 373,
	kernelExp_XeCryptDesEcb = 374,
	kernelExp_XeCryptDesCbc = 375,
	kernelExp_XeCryptDes3Key = 376,
	kernelExp_XeCryptDes3Ecb = 377,
	kernelExp_XeCryptDes3Cbc = 378,
	kernelExp_XeCryptHmacMd5Init = 379,
	kernelExp_XeCryptHmacMd5Update = 380,
	kernelExp_XeCryptHmacMd5Final = 381,
	kernelExp_XeCryptHmacMd5 = 382,
	kernelExp_XeCryptHmacShaInit = 383,
	kernelExp_XeCryptHmacShaUpdate = 384,
	kernelExp_XeCryptHmacShaFinal = 385,
	kernelExp_XeCryptHmacSha = 386,
	kernelExp_XeCryptHmacShaVerify = 387,
	kernelExp_XeCryptMd5Init = 388,
	kernelExp_XeCryptMd5Update = 389,
	kernelExp_XeCryptMd5Final = 390,
	kernelExp_XeCryptMd5 = 391,
	kernelExp_XeCryptParveEcb = 392,
	kernelExp_XeCryptParveCbcMac = 393,
	kernelExp_XeCryptRandom = 394,
	kernelExp_XeCryptRc4Key = 395,
	kernelExp_XeCryptRc4Ecb = 396,
	kernelExp_XeCryptRc4 = 397,
	kernelExp_XeCryptRotSumSha = 398,
	kernelExp_XeCryptShaInit = 399,
	kernelExp_XeCryptShaUpdate = 400,
	kernelExp_XeCryptShaFinal = 401,
	kernelExp_XeCryptSha = 402,
	kernelExp_XexExecutableModuleHandle = 403,
	kernelExp_XexCheckExecutablePrivilege = 404,
	kernelExp_XexGetModuleHandle = 405,
	kernelExp_XexGetModuleSection = 406,
	kernelExp_XexGetProcedureAddress = 407,
	kernelExp_XexLoadExecutable = 408,
	kernelExp_XexLoadImage = 409,
	kernelExp_XexLoadImageFromMemory = 410,
	kernelExp_XexLoadImageHeaders = 411,
	kernelExp_XexPcToFileHeader = 412,
	kernelExp_XexRegisterLoader = 413,
	kernelExp_XexRegisterPatchDescriptor = 414,
	kernelExp_XexSendDeferredNotifications = 415,
	kernelExp_XexStartExecutable = 416,
	kernelExp_XexUnloadImage = 417,
	kernelExp_XexUnloadImageAndExitThread = 418,
	kernelExp_XexUnloadTitleModules = 419,
	kernelExp_XexVerifyImageHeaders = 420,
	kernelExp___C_specific_handler = 421,
	kernelExp_DbgLoadImageSymbols = 422,
	kernelExp_DbgUnLoadImageSymbols = 423,
	kernelExp_RtlImageDirectoryEntryToData = 424,
	kernelExp_RtlImageNtHeader = 425,
	kernelExp_ExDebugMonitorService = 426,
	kernelExp_MmDbgReadCheck = 427,
	kernelExp_MmDbgReleaseAddress = 428,
	kernelExp_MmDbgWriteCheck = 429,
	kernelExp_ExLoadedCommandLine = 430,
	kernelExp_ExLoadedImageName = 431,
	kernelExp_VdBlockUntilGUIIdle = 432,
	kernelExp_VdCallGraphicsNotificationRoutines = 433,
	kernelExp_VdDisplayFatalError = 434,
	kernelExp_VdEnableClosedCaption = 435,
	kernelExp_VdEnableDisableClockGating = 436,
	kernelExp_VdEnableDisablePowerSavingMode = 437,
	kernelExp_VdEnableRingBufferRPtrWriteBack = 438,
	kernelExp_VdGenerateGPUCSCCoefficients = 439,
	kernelExp_VdGetClosedCaptionReadyStatus = 440,
	kernelExp_VdGetCurrentDisplayGamma = 441,
	kernelExp_VdGetCurrentDisplayInformation = 442,
	kernelExp_VdGetDisplayModeOverride = 443,
	kernelExp_VdGetGraphicsAsicID = 444,
	kernelExp_VdGetSystemCommandBuffer = 445,
	kernelExp_VdGlobalDevice = 446,
	kernelExp_VdGlobalXamDevice = 447,
	kernelExp_VdGpuClockInMHz = 448,
	kernelExp_VdHSIOCalibrationLock = 449,
	kernelExp_VdInitializeEngines = 450,
	kernelExp_VdInitializeRingBuffer = 451,
	kernelExp_VdInitializeScaler = 452,
	kernelExp_VdInitializeScalerCommandBuffer = 453,
	kernelExp_VdIsHSIOTrainingSucceeded = 454,
	kernelExp_VdPersistDisplay = 455,
	kernelExp_VdQuerySystemCommandBuffer = 456,
	kernelExp_VdQueryVideoFlags = 457,
	kernelExp_VdQueryVideoMode = 458,
	kernelExp_VdReadDVERegisterUlong = 459,
	kernelExp_VdReadWriteHSIOCalibrationFlag = 460,
	kernelExp_VdRegisterGraphicsNotification = 461,
	kernelExp_VdRegisterXamGraphicsNotification = 462,
	kernelExp_VdSendClosedCaptionData = 463,
	kernelExp_VdSetCGMSOption = 464,
	kernelExp_VdSetColorProfileAdjustment = 465,
	kernelExp_VdSetCscMatricesOverride = 466,
	kernelExp_VdSetDisplayMode = 467,
	kernelExp_VdSetDisplayModeOverride = 468,
	kernelExp_VdSetGraphicsInterruptCallback = 469,
	kernelExp_VdSetHDCPOption = 470,
	kernelExp_VdSetMacrovisionOption = 471,
	kernelExp_VdSetSystemCommandBuffer = 472,
	kernelExp_VdSetSystemCommandBufferGpuIdentifierAddress = 473,
	kernelExp_VdSetWSSData = 474,
	kernelExp_VdSetWSSOption = 475,
	kernelExp_VdShutdownEngines = 476,
	kernelExp_VdTurnDisplayOff = 477,
	kernelExp_VdTurnDisplayOn = 478,
	kernelExp_VdVerifyMEInitCommand = 479,
	kernelExp_VdWriteDVERegisterUlong = 480,
	kernelExp_XVoicedHeadsetPresent = 481,
	kernelExp_XVoicedSubmitPacket = 482,
	kernelExp_XVoicedClose = 483,
	kernelExp_XVoicedActivate = 484,
	kernelExp_XInputdGetCapabilities = 485,
	kernelExp_XInputdReadState = 486,
	kernelExp_XInputdWriteState = 487,
	kernelExp_XInputdNotify = 488,
	kernelExp_XInputdRawState = 489,
	kernelExp_HidGetCapabilities = 490,
	kernelExp_HidReadKeys = 491,
	kernelExp_XInputdGetDeviceStats = 492,
	kernelExp_XInputdResetDevice = 493,
	kernelExp_XInputdSetRingOfLight = 494,
	kernelExp_XInputdSetRFPowerMode = 495,
	kernelExp_XInputdSetRadioFrequency = 496,
	kernelExp_HidGetLastInputTime = 497,
	kernelExp_XAudioRenderDriverInitialize = 498,
	kernelExp_XAudioRegisterRenderDriverClient = 499,
	kernelExp_XAudioUnregisterRenderDriverClient = 500,
	kernelExp_XAudioSubmitRenderDriverFrame = 501,
	kernelExp_XAudioRenderDriverLock = 502,
	kernelExp_XAudioGetVoiceCategoryVolumeChangeMask = 503,
	kernelExp_XAudioGetVoiceCategoryVolume = 504,
	kernelExp_XAudioSetVoiceCategoryVolume = 505,
	kernelExp_XAudioBeginDigitalBypassMode = 506,
	kernelExp_XAudioEndDigitalBypassMode = 507,
	kernelExp_XAudioSubmitDigitalPacket = 508,
	kernelExp_XAudioQueryDriverPerformance = 509,
	kernelExp_XAudioGetRenderDriverThread = 510,
	kernelExp_XAudioGetSpeakerConfig = 511,
	kernelExp_XAudioSetSpeakerConfig = 512,
	kernelExp_NicSetUnicastAddress = 513,
	kernelExp_NicAttach = 514,
	kernelExp_NicDetach = 515,
	kernelExp_NicXmit = 516,
	kernelExp_NicUpdateMcastMembership = 517,
	kernelExp_NicFlushXmitQueue = 518,
	kernelExp_NicShutdown = 519,
	kernelExp_NicGetLinkState = 520,
	kernelExp_NicGetStats = 521,
	kernelExp_NicGetOpt = 522,
	kernelExp_NicSetOpt = 523,
	kernelExp_DrvSetSysReqCallback = 524,
	kernelExp_DrvSetUserBindingCallback = 525,
	kernelExp_DrvSetContentStorageCallback = 526,
	kernelExp_DrvSetAutobind = 527,
	kernelExp_DrvGetContentStorageNotification = 528,
	kernelExp_MtpdBeginTransaction = 529,
	kernelExp_MtpdCancelTransaction = 530,
	kernelExp_MtpdEndTransaction = 531,
	kernelExp_MtpdGetCurrentDevices = 532,
	kernelExp_MtpdReadData = 533,
	kernelExp_MtpdReadEvent = 534,
	kernelExp_MtpdResetDevice = 535,
	kernelExp_MtpdSendData = 536,
	kernelExp_MtpdVerifyProximity = 537,
	kernelExp_XUsbcamSetCaptureMode = 538,
	kernelExp_XUsbcamGetConfig = 539,
	kernelExp_XUsbcamSetConfig = 540,
	kernelExp_XUsbcamGetState = 541,
	kernelExp_XUsbcamReadFrame = 542,
	kernelExp_XUsbcamSnapshot = 543,
	kernelExp_XUsbcamSetView = 544,
	kernelExp_XUsbcamGetView = 545,
	kernelExp_XUsbcamCreate = 546,
	kernelExp_XUsbcamDestroy = 547,
	kernelExp_XMACreateContext = 548,
	kernelExp_XMAInitializeContext = 549,
	kernelExp_XMAReleaseContext = 550,
	kernelExp_XMAEnableContext = 551,
	kernelExp_XMADisableContext = 552,
	kernelExp_XMAGetOutputBufferWriteOffset = 553,
	kernelExp_XMASetOutputBufferReadOffset = 554,
	kernelExp_XMAGetOutputBufferReadOffset = 555,
	kernelExp_XMASetOutputBufferValid = 556,
	kernelExp_XMAIsOutputBufferValid = 557,
	kernelExp_XMASetInputBuffer0Valid = 558,
	kernelExp_XMAIsInputBuffer0Valid = 559,
	kernelExp_XMASetInputBuffer1Valid = 560,
	kernelExp_XMAIsInputBuffer1Valid = 561,
	kernelExp_XMASetInputBuffer0 = 562,
	kernelExp_XMASetInputBuffer1 = 563,
	kernelExp_XMAGetPacketMetadata = 564,
	kernelExp_XMABlockWhileInUse = 565,
	kernelExp_XMASetLoopData = 566,
	kernelExp_XMASetInputBufferReadOffset = 567,
	kernelExp_XMAGetInputBufferReadOffset = 568,
	kernelExp_ExIsBetaFeatureEnabled = 569,
	kernelExp_XeKeysGetFactoryChallenge = 570,
	kernelExp_XeKeysSetFactoryResponse = 571,
	kernelExp_XeKeysInitializeFuses = 572,
	kernelExp_XeKeysSaveBootLoader = 573,
	kernelExp_XeKeysSaveKeyVault = 574,
	kernelExp_XeKeysGetStatus = 575,
	kernelExp_XeKeysGeneratePrivateKey = 576,
	kernelExp_XeKeysGetKeyProperties = 577,
	kernelExp_XeKeysSetKey = 578,
	kernelExp_XeKeysGenerateRandomKey = 579,
	kernelExp_XeKeysGetKey = 580,
	kernelExp_XeKeysGetDigest = 581,
	kernelExp_XeKeysGetConsoleID = 582,
	kernelExp_XeKeysGetConsoleType = 583,
	kernelExp_XeKeysQwNeRsaPrvCrypt = 584,
	kernelExp_XeKeysHmacSha = 585,
	kernelExp_XInputdPassThroughRFCommand = 586,
	kernelExp_XeKeysAesCbc = 587,
	kernelExp_XeKeysDes2Cbc = 588,
	kernelExp_XeKeysDesCbc = 589,
	kernelExp_XeKeysObscureKey = 590,
	kernelExp_XeKeysHmacShaUsingKey = 591,
	kernelExp_XeKeysSaveBootLoaderEx = 592,
	kernelExp_XeKeysAesCbcUsingKey = 593,
	kernelExp_XeKeysDes2CbcUsingKey = 594,
	kernelExp_XeKeysDesCbcUsingKey = 595,
	kernelExp_XeKeysObfuscate = 596,
	kernelExp_XeKeysUnObfuscate = 597,
	kernelExp_XeKeysConsolePrivateKeySign = 598,
	kernelExp_XeKeysConsoleSignatureVerification = 599,
	kernelExp_XeKeysVerifyRSASignature = 600,
	kernelExp_StfsCreateDevice = 601,
	kernelExp_StfsControlDevice = 602,
	kernelExp_VdSwap = 603,
	kernelExp_HalFsbInterruptCount = 604,
	kernelExp_XeKeysSaveSystemUpdate = 605,
	kernelExp_XeKeysLockSystemUpdate = 606,
	kernelExp_XeKeysExecute = 607,
	kernelExp_XeKeysGetVersions = 608,
	kernelExp_XInputdPowerDownDevice = 609,
	kernelExp_AniBlockOnAnimation = 610,
	kernelExp_AniTerminateAnimation = 611,
	kernelExp_XUsbcamReset = 612,
	kernelExp_AniSetLogo = 613,
	kernelExp_KeCertMonitorData = 614,
	kernelExp_HalIsExecutingPowerDownDpc = 615,
	kernelExp_VdInitializeEDRAM = 616,
	kernelExp_VdRetrainEDRAM = 617,
	kernelExp_VdRetrainEDRAMWorker = 618,
	kernelExp_VdHSIOTrainCount = 619,
	kernelExp_HalGetPowerUpCause = 620,
	kernelExp_VdHSIOTrainingStatus = 621,
	kernelExp_RgcBindInfo = 622,
	kernelExp_VdReadEEDIDBlock = 623,
	kernelExp_VdEnumerateVideoModes = 624,
	kernelExp_VdEnableHDCP = 625,
	kernelExp_VdRegisterHDCPNotification = 626,
	kernelExp_HidReadMouseChanges = 627,
	kernelExp_DumpSetCollectionFacility = 628,
	kernelExp_XexTransformImageKey = 629,
	kernelExp_XAudioOverrideSpeakerConfig = 630,
	kernelExp_XInputdReadTextKeystroke = 631,
	kernelExp_DrvXenonButtonPressed = 632,
	kernelExp_DrvBindToUser = 633,
	kernelExp_XexGetModuleImportVersions = 634,
	kernelExp_RtlComputeCrc32 = 635,
	kernelExp_XeKeysSetRevocationList = 636,
	kernelExp_HalRegisterPowerDownCallback = 637,
	kernelExp_VdGetDisplayDiscoveryData = 638,
	kernelExp_XInputdSendStayAliveRequest = 639,
	kernelExp_XVoicedSendVPort = 640,
	kernelExp_XVoicedGetBatteryStatus = 641,
	kernelExp_XInputdFFGetDeviceInfo = 642,
	kernelExp_XInputdFFSetEffect = 643,
	kernelExp_XInputdFFUpdateEffect = 644,
	kernelExp_XInputdFFEffectOperation = 645,
	kernelExp_XInputdFFDeviceControl = 646,
	kernelExp_XInputdFFSetDeviceGain = 647,
	kernelExp_XInputdFFCancelIo = 648,
	kernelExp_XInputdFFSetRumble = 649,
	kernelExp_NtAllocateEncryptedMemory = 650,
	kernelExp_NtFreeEncryptedMemory = 651,
	kernelExp_XeKeysExSaveKeyVault = 652,
	kernelExp_XeKeysExSetKey = 653,
	kernelExp_XeKeysExGetKey = 654,
	kernelExp_DrvSetDeviceConfigChangeCallback = 655,
	kernelExp_DrvDeviceConfigChange = 656,
	kernelExp_HalRegisterHdDvdRomNotification = 657,
	kernelExp_XeKeysSecurityInitialize = 658,
	kernelExp_XeKeysSecurityLoadSettings = 659,
	kernelExp_XeKeysSecuritySaveSettings = 660,
	kernelExp_XeKeysSecuritySetDetected = 661,
	kernelExp_XeKeysSecurityGetDetected = 662,
	kernelExp_XeKeysSecuritySetActivated = 663,
	kernelExp_XeKeysSecurityGetActivated = 664,
	kernelExp_XeKeysGetProtectedFlag = 667,
	kernelExp_XeKeysSetProtectedFlag = 668,
	kernelExp_KeEnablePFMInterrupt = 669,
	kernelExp_KeDisablePFMInterrupt = 670,
	kernelExp_KeSetProfilerISR = 671,
	kernelExp_VdStartDisplayDiscovery = 672,
	kernelExp_VdSetHDCPRevocationList = 673,
	kernelExp_XeKeysGetUpdateSequence = 674,
	kernelExp_XeKeysDvdAuthExActivate = 675,
	kernelExp_KeGetImagePageTableEntry = 676,
	kernelExp_HalRegisterBackgroundModeTransitionCallback = 677,
	kernelExp_AniStartBootAnimation = 678,
	kernelExp_HalClampUnclampOutputDACs = 679,
	kernelExp_HalPowerDownToBackgroundMode = 680,
	kernelExp_HalNotifyAddRemoveBackgroundTask = 681,
	kernelExp_HalCallBackgroundModeNotificationRoutines = 682,
	kernelExp_HalFsbResetCount = 683,
	kernelExp_HalGetMemoryInformation = 684,
	kernelExp_XInputdGetLastTextInputTime = 685,
	kernelExp_VdEnableWMAProOverHDMI = 686,
	kernelExp_XeKeysRevokeSaveSettings = 687,
	kernelExp_XInputdSetTextMessengerIndicator = 688,
	kernelExp_MicDeviceRequest = 689,
	kernelExp_XeKeysGetMediaID = 690,
	kernelExp_KeGetVidInfo = 692,
	kernelExp_HalNotifyBackgroundModeTransitionComplete = 693,
	kernelExp_IoAcquireCancelSpinLock = 694,
	kernelExp_IoReleaseCancelSpinLock = 695,
	kernelExp_NtCancelIoFile = 696,
	kernelExp_NtCancelIoFileEx = 697,
	kernelExp_HalFinalizePowerLossRecovery = 698,
	kernelExp_HalSetPowerLossRecovery = 699,
	kernelExp_ExReadModifyWriteXConfigSettingUlong = 700,
	kernelExp_HalRegisterXamPowerDownCallback = 701,
	kernelExp_ExCancelAlarm = 702,
	kernelExp_ExInitializeAlarm = 703,
	kernelExp_ExSetAlarm = 704,
	kernelExp_XexActivationGetNonce = 705,
	kernelExp_XexActivationSetLicense = 706,
	kernelExp_IptvSetBoundaryKey = 707,
	kernelExp_IptvSetSessionKey = 708,
	kernelExp_IptvVerifyOmac1Signature = 709,
	kernelExp_IptvGetAesCtrTransform = 710,
	kernelExp_SataCdRomRecordReset = 711,
	kernelExp_XInputdSetTextDeviceKeyLocks = 712,
	kernelExp_XInputdGetTextDeviceKeyLocks = 713,
	kernelExp_XexActivationVerifyOwnership = 714,
	kernelExp_XexDisableVerboseDbgPrint = 715,
	kernelExp_SvodCreateDevice = 716,
	kernelExp_RtlCaptureStackBackTrace = 717,
	kernelExp_XeKeysRevokeUpdateDynamic = 718,
	kernelExp_XexImportTraceEnable = 719,
	kernelExp_ExRegisterXConfigNotification = 720,
	kernelExp_XeKeysSecuritySetStat = 721,
	kernelExp_VdQueryRealVideoMode = 722,
	kernelExp_XexSetExecutablePrivilege = 723,
	kernelExp_XAudioSuspendRenderDriverClients = 724,
	kernelExp_IptvGetSessionKeyHash = 725,
	kernelExp_VdSetCGMSState = 726,
	kernelExp_VdSetSCMSState = 727,
	kernelExp_KeFlushMultipleTb = 728,
	kernelExp_VdGetOption = 729,
	kernelExp_VdSetOption = 730,
	kernelExp_UsbdBootEnumerationDoneEvent = 731,
	kernelExp_StfsDeviceErrorEvent = 732,
	kernelExp_ExTryToAcquireReadWriteLockExclusive = 733,
	kernelExp_ExTryToAcquireReadWriteLockShared = 734,
	kernelExp_XexSetLastKdcTime = 735,
	kernelExp_XInputdControl = 736,
	kernelExp_RmcDeviceRequest = 737,
	kernelExp_LDIResetDecompression = 738,
	kernelExp_NicRegisterDevice = 739,
	kernelExp_UsbdAddDeviceComplete = 740,
	kernelExp_UsbdCancelAsyncTransfer = 741,
	kernelExp_UsbdGetDeviceSpeed = 742,
	kernelExp_UsbdGetDeviceTopology = 743,
	kernelExp_UsbdGetEndpointDescriptor = 744,
	kernelExp_UsbdIsDeviceAuthenticated = 745,
	kernelExp_UsbdOpenDefaultEndpoint = 746,
	kernelExp_UsbdOpenEndpoint = 747,
	kernelExp_UsbdQueueAsyncTransfer = 748,
	kernelExp_UsbdQueueCloseDefaultEndpoint = 749,
	kernelExp_UsbdQueueCloseEndpoint = 750,
	kernelExp_UsbdRemoveDeviceComplete = 751,
	kernelExp_KeRemoveQueueApc = 752,
	kernelExp_UsbdDriverLoadRequiredEvent = 753,
	kernelExp_UsbdGetRequiredDrivers = 754,
	kernelExp_UsbdRegisterDriverObject = 755,
	kernelExp_UsbdUnregisterDriverObject = 756,
	kernelExp_UsbdResetDevice = 758,
	kernelExp_UsbdGetDeviceDescriptor = 759,
	kernelExp_NomnilGetExtension = 760,
	kernelExp_NomnilStartCloseDevice = 761,
	kernelExp_WifiBeginAuthentication = 762,
	kernelExp_WifiCheckCounterMeasures = 763,
	kernelExp_WifiChooseAuthenCipherSetFromBSSID = 764,
	kernelExp_WifiCompleteAuthentication = 765,
	kernelExp_WifiGetAssociationIE = 766,
	kernelExp_WifiOnMICError = 767,
	kernelExp_WifiPrepareAuthenticationContext = 768,
	kernelExp_WifiRecvEAPOLPacket = 769,
	kernelExp_WifiDeduceNetworkType = 770,
	kernelExp_NicUnregisterDevice = 771,
	kernelExp_DumpXitThread = 772,
	kernelExp_XInputdSetWifiChannel = 773,
	kernelExp_NomnilSetLed = 774,
	kernelExp_WifiCalculateRegulatoryDomain = 775,
	kernelExp_WifiSelectAdHocChannel = 776,
	kernelExp_WifiChannelToFrequency = 777,
	kernelExp_MmGetPoolPagesType = 778,
	kernelExp_ExExpansionInstall = 779,
	kernelExp_ExExpansionCall = 780,
	kernelExp_PsCamDeviceRequest = 781,
	kernelExp_McaDeviceRequest = 782,
	kernelExp_DetroitDeviceRequest = 783,
	kernelExp_XeCryptSha256Init = 784,
	kernelExp_XeCryptSha256Update = 785,
	kernelExp_XeCryptSha256Final = 786,
	kernelExp_XeCryptSha256 = 787,
	kernelExp_XeCryptSha384Init = 788,
	kernelExp_XeCryptSha384Update = 789,
	kernelExp_XInputdGetDevicePid = 790,
	kernelExp_HalGetNotedArgonErrors = 791,
	kernelExp_XeCryptSha384Final = 792,
	kernelExp_HalReadArgonEeprom = 793,
	kernelExp_HalWriteArgonEeprom = 794,
	kernelExp_XeKeysFcrtLoad = 795,
	kernelExp_XeKeysFcrtSave = 796,
	kernelExp_XeKeysFcrtSet = 797,
	kernelExp_XeCryptSha384 = 798,
	kernelExp_XeCryptSha512Init = 799,
	kernelExp_XAudioRegisterRenderDriverMECClient = 800,
	kernelExp_XAudioUnregisterRenderDriverMECClient = 801,
	kernelExp_XAudioCaptureRenderDriverFrame = 802,
	kernelExp_XeCryptSha512Update = 803,
	kernelExp_XeCryptSha512Final = 804,
	kernelExp_XeCryptSha512 = 805,
	kernelExp_XeCryptBnQwNeCompare = 806,
	kernelExp_XVoicedGetDirectionalData = 807,
	kernelExp_DrvSetMicArrayStartCallback = 808,
	kernelExp_DevAuthGetStatistics = 809,
	kernelExp_NullCableRequest = 810,
	kernelExp_XeKeysRevokeIsDeviceRevoked = 811,
	kernelExp_DumpUpdateDumpSettings = 812,
	kernelExp_EtxConsumerDisableEventType = 813,
	kernelExp_EtxConsumerEnableEventType = 814,
	kernelExp_EtxConsumerProcessLogs = 815,
	kernelExp_EtxConsumerRegister = 816,
	kernelExp_EtxConsumerUnregister = 817,
	kernelExp_EtxProducerLog = 818,
	kernelExp_EtxProducerLogV = 819,
	kernelExp_EtxProducerRegister = 820,
	kernelExp_EtxProducerUnregister = 821,
	kernelExp_EtxConsumerFlushBuffers = 822,
	kernelExp_EtxProducerLogXwpp = 823,
	kernelExp_EtxProducerLogXwppV = 824,
	kernelExp_UsbdEnableDisableRootHubPort = 825,
	kernelExp_EtxBufferRegister = 826,
	kernelExp_EtxBufferUnregister = 827,
	kernelExp_DumpRegisterDedicatedDataBlock = 828,
	kernelExp_XeKeysDvdAuthExSave = 829,
	kernelExp_XeKeysDvdAuthExInstall = 830,
	kernelExp_XexShimDisable = 831,
	kernelExp_XexShimEnable = 832,
	kernelExp_XexShimEntryDisable = 833,
	kernelExp_XexShimEntryEnable = 834,
	kernelExp_XexShimEntryRegister = 835,
	kernelExp_XexShimLock = 836,
	kernelExp_XboxKrnlVersion4Digit = 837,
	kernelExp_XeKeysObfuscateEx = 838,
	kernelExp_XeKeysUnObfuscateEx = 839,
	kernelExp_XexTitleHash = 840,
	kernelExp_XexTitleHashClose = 841,
	kernelExp_XexTitleHashContinue = 842,
	kernelExp_XexTitleHashOpen = 843,
	kernelExp_XAudioGetRenderDriverTic = 844,
	kernelExp_XAudioEnableDucker = 845,
	kernelExp_XAudioSetDuckerLevel = 846,
	kernelExp_XAudioIsDuckerEnabled = 847,
	kernelExp_XAudioGetDuckerLevel = 848,
	kernelExp_XAudioGetDuckerThreshold = 849,
	kernelExp_XAudioSetDuckerThreshold = 850,
	kernelExp_XAudioGetDuckerAttackTime = 851,
	kernelExp_XAudioSetDuckerAttackTime = 852,
	kernelExp_XAudioGetDuckerReleaseTime = 853,
	kernelExp_XAudioSetDuckerReleaseTime = 854,
	kernelExp_XAudioGetDuckerHoldTime = 855,
	kernelExp_XAudioSetDuckerHoldTime = 856,
	kernelExp_DevAuthShouldAlwaysEnforce = 857,
	kernelExp_XAudioGetUnderrunCount = 858,
	kernelExp_DrvSetAudioLatencyCallback = 859,
	kernelExp_XVoicedIsActiveProcess = 860,
	kernelExp_KeExecuteOnProtectedStack = 861,
	kernelExp_XeKeysVerifyPIRSSignature = 862,
	kernelExp_XeCryptAesCtr = 863,
	kernelExp_XeCryptAesCbcMac = 864,
	kernelExp_XeCryptAesDmMac = 865,
	kernelExp_EmaExecute = 866,
	kernelExp_XeKeysGetTruncatedSecondaryConsoleId = 867,
	kernelExp_ExFreeDebugPool = 868,
	kernelExp_VdQueryVideoCapabilities = 869,
	kernelExp_UsbdGetDeviceRootPortType = 870,
	kernelExp_VdGet3dVideoFormat = 871,
	kernelExp_VdGetWSS2Data = 872,
	kernelExp_VdSet3dVideoFormat = 873,
	kernelExp_VdSetWSS2Data = 874,
	kernelExp_XexReserveCodeBuffer = 875,
	kernelExp_XexCommitCodeBuffer = 876,
	kernelExp_RtlSetVectoredExceptionHandler = 877,
	kernelExp_RtlClearVectoredExceptionHandler = 878,
	kernelExp_XAudioSetProcessFrameCallback = 879,
	kernelExp_UsbdGetRootHubDeviceNode = 880,
	kernelExp_UsbdGetPortDeviceNode = 881,
	kernelExp_UsbdGetNatalHub = 882,
	kernelExp_UsbdGetNatalHardwareVersion = 883,
	kernelExp_UsbdNatalHubRegisterNotificationCallback = 884,
	kernelExp_KeCallAndBlockOnDpcRoutine = 885,
	kernelExp_KeCallAndWaitForDpcRoutine = 886,
	kernelExp_TidDeviceRequest = 887,
	kernelExp_DmPrintData = 888,
	kernelExp_VdSetStudioRGBMode = 889,
	kernelExp_UsbdTitleDriverResetAllUnrecognizedPorts = 890,
	kernelExp_UsbdTitleDriverSetUnrecognizedPort = 891,
	kernelExp_UsbdResetEndpoint = 892,
	kernelExp_UsbdSetTimer = 893,
	kernelExp_UsbdCancelTimer = 894,
	kernelExp_UsbdQueueIsochTransfer = 895,
	kernelExp_KeSetPageRelocationCallback = 896,
	kernelExp_XexRegisterUsermodeModule = 897,
	kernelExp_SerenityDongleRequest = 898,
	kernelExp_TitleDeviceAuthRequest = 899,
	kernelExp_KeRegisterSwapNotification = 900,
	kernelExp_XInputdGetFailedConnectionOrBind = 901,
	kernelExp_XInputdSetFailedConnectionOrBindCallback = 902,
	kernelExp_XInputdSetMinMaxAuthDelay = 904,
	kernelExp_VgcHandler_SetHandlers = 905,
	kernelExp_VvcHandlerCancelTransfers = 906,
	kernelExp_VvcHandlerRetrieveVoiceExtension = 907,
	kernelExp_VeSetHandlers = 916,
	kernelExp_HalConfigureVeDevice = 917,
} kernelExp_Enum;


```

`XenonDumper/libs/xkelib/kernel/kernelext20871.0.def`:

```def
LIBRARY xboxkrnl.exe@20871.0+1861.0
EXPORTS
	DbgBreakPoint @1
	DbgBreakPointWithStatus @2
	DbgPrint @3
	DbgPrompt @4
	DumpGetRawDumpInfo @5
	DumpWriteDump @6
	ExAcquireReadWriteLockExclusive @7
	ExAcquireReadWriteLockShared @8
	ExAllocatePool @9
	ExAllocatePoolWithTag @10
	ExAllocatePoolTypeWithTag @11
	ExConsoleGameRegion @12
	ExCreateThread @13
	ExEventObjectType @14
	ExFreePool @15
	ExGetXConfigSetting @16
	ExInitializeReadWriteLock @17
	ExMutantObjectType @18
	ExQueryPoolBlockSize @19
	ExRegisterThreadNotification @20
	ExRegisterTitleTerminateNotification @21
	ExReleaseReadWriteLock @22
	ExSemaphoreObjectType @23
	ExSetXConfigSetting @24
	ExTerminateThread @25
	ExTerminateTitleProcess @26
	ExThreadObjectType @27
	ExTimerObjectType @28
	MmDoubleMapMemory @29
	MmUnmapMemory @30
	XeKeysGetConsoleCertificate @31
	FscGetCacheElementCount @32
	FscSetCacheElementCount @33
	HalGetCurrentAVPack @34
	HalGpioControl @35
	HalOpenCloseODDTray @36
	HalReadWritePCISpace @37
	HalRegisterPowerDownNotification @38
	HalRegisterSMCNotification @39
	HalReturnToFirmware @40
	HalSendSMCMessage @41
	HalSetAudioEnable @42
	InterlockedFlushSList @43
	InterlockedPopEntrySList @44
	InterlockedPushEntrySList @45
	IoAcquireDeviceObjectLock @46
	IoAllocateIrp @47
	IoBuildAsynchronousFsdRequest @48
	IoBuildDeviceIoControlRequest @49
	IoBuildSynchronousFsdRequest @50
	IoCallDriver @51
	IoCheckShareAccess @52
	IoCompleteRequest @53
	IoCompletionObjectType @54
	IoCreateDevice @55
	IoCreateFile @56
	IoDeleteDevice @57
	IoDeviceObjectType @58
	IoDismountVolume @59
	IoDismountVolumeByFileHandle @60
	IoDismountVolumeByName @61
	IoFileObjectType @62
	IoFreeIrp @63
	IoInitializeIrp @64
	IoInvalidDeviceRequest @65
	ExSetBetaFeaturesEnabled @66
	IoQueueThreadIrp @67
	IoReleaseDeviceObjectLock @68
	IoRemoveShareAccess @69
	IoSetIoCompletion @70
	IoSetShareAccess @71
	IoStartNextPacket @72
	IoStartNextPacketByKey @73
	IoStartPacket @74
	IoSynchronousDeviceIoControlRequest @75
	IoSynchronousFsdRequest @76
	KeAcquireSpinLockAtRaisedIrql @77
	KeAlertResumeThread @78
	KeAlertThread @79
	KeBlowFuses @80
	KeBoostPriorityThread @81
	KeBugCheck @82
	KeBugCheckEx @83
	KeCancelTimer @84
	KeConnectInterrupt @85
	KeContextFromKframes @86
	KeContextToKframes @87
	KeCreateUserMode @88
	KeDebugMonitorData @89
	KeDelayExecutionThread @90
	KeDeleteUserMode @91
	KeDisconnectInterrupt @92
	KeEnableFpuExceptions @93
	KeEnablePPUPerformanceMonitor @94
	KeEnterCriticalRegion @95
	KeEnterUserMode @96
	KeFlushCacheRange @97
	KeFlushCurrentEntireTb @98
	KeFlushEntireTb @99
	KeFlushUserModeCurrentTb @100
	KeFlushUserModeTb @101
	KeGetCurrentProcessType @102
	KeGetPMWRegister @103
	KeGetPRVRegister @104
	KeGetSocRegister @105
	KeGetSpecialPurposeRegister @106
	KeLockL2 @107
	KeUnlockL2 @108
	KeInitializeApc @109
	KeInitializeDeviceQueue @110
	KeInitializeDpc @111
	KeInitializeEvent @112
	KeInitializeInterrupt @113
	KeInitializeMutant @114
	KeInitializeQueue @115
	KeInitializeSemaphore @116
	KeInitializeTimerEx @117
	KeInsertByKeyDeviceQueue @118
	KeInsertDeviceQueue @119
	KeInsertHeadQueue @120
	KeInsertQueue @121
	KeInsertQueueApc @122
	KeInsertQueueDpc @123
	KeIpiGenericCall @124
	KeLeaveCriticalRegion @125
	KeLeaveUserMode @126
	KePulseEvent @127
	KeQueryBackgroundProcessors @128
	KeQueryBasePriorityThread @129
	KeQueryInterruptTime @130
	KeQueryPerformanceFrequency @131
	KeQuerySystemTime @132
	KeRaiseIrqlToDpcLevel @133
	KeRegisterDriverNotification @134
	KeReleaseMutant @135
	KeReleaseSemaphore @136
	KeReleaseSpinLockFromRaisedIrql @137
	KeRemoveByKeyDeviceQueue @138
	KeRemoveDeviceQueue @139
	KeRemoveEntryDeviceQueue @140
	KeRemoveQueue @141
	KeRemoveQueueDpc @142
	KeResetEvent @143
	KeRestoreFloatingPointState @144
	KeRestoreVectorUnitState @145
	KeResumeThread @146
	KeRetireDpcList @147
	KeRundownQueue @148
	KeSaveFloatingPointState @149
	KeSaveVectorUnitState @150
	KeSetAffinityThread @151
	KeSetBackgroundProcessors @152
	KeSetBasePriorityThread @153
	KeSetCurrentProcessType @154
	KeSetCurrentStackPointers @155
	KeSetDisableBoostThread @156
	KeSetEvent @157
	KeSetEventBoostPriority @158
	KeSetPMWRegister @159
	KeSetPowerMode @160
	KeSetPRVRegister @161
	KeSetPriorityClassThread @162
	KeSetPriorityThread @163
	KeSetSocRegister @164
	KeSetSpecialPurposeRegister @165
	KeSetTimer @166
	KeSetTimerEx @167
	KeStallExecutionProcessor @168
	KeSuspendThread @169
	KeSweepDcacheRange @170
	KeSweepIcacheRange @171
	KeTestAlertThread @172
	KeTimeStampBundle @173
	KeTryToAcquireSpinLockAtRaisedIrql @174
	KeWaitForMultipleObjects @175
	KeWaitForSingleObject @176
	KfAcquireSpinLock @177
	KfRaiseIrql @178
	KfLowerIrql @179
	KfReleaseSpinLock @180
	KiBugCheckData @181
	LDICreateDecompression @182
	LDIDecompress @183
	LDIDestroyDecompression @184
	MmAllocatePhysicalMemory @185
	MmAllocatePhysicalMemoryEx @186
	MmCreateKernelStack @187
	MmDeleteKernelStack @188
	MmFreePhysicalMemory @189
	MmGetPhysicalAddress @190
	MmIsAddressValid @191
	MmLockAndMapSegmentArray @192
	MmLockUnlockBufferPages @193
	MmMapIoSpace @194
	MmPersistPhysicalMemoryAllocation @195
	MmQueryAddressProtect @196
	MmQueryAllocationSize @197
	MmQueryStatistics @198
	MmSetAddressProtect @199
	MmSplitPhysicalMemoryAllocation @200
	MmUnlockAndUnmapSegmentArray @201
	MmUnmapIoSpace @202
	Nls844UnicodeCaseTable @203
	NtAllocateVirtualMemory @204
	NtCancelTimer @205
	NtClearEvent @206
	NtClose @207
	NtCreateDirectoryObject @208
	NtCreateEvent @209
	NtCreateFile @210
	NtCreateIoCompletion @211
	NtCreateMutant @212
	NtCreateSemaphore @213
	NtCreateSymbolicLinkObject @214
	NtCreateTimer @215
	NtDeleteFile @216
	NtDeviceIoControlFile @217
	NtDuplicateObject @218
	NtFlushBuffersFile @219
	NtFreeVirtualMemory @220
	NtMakeTemporaryObject @221
	NtOpenDirectoryObject @222
	NtOpenFile @223
	NtOpenSymbolicLinkObject @224
	NtProtectVirtualMemory @225
	NtPulseEvent @226
	NtQueueApcThread @227
	NtQueryDirectoryFile @228
	NtQueryDirectoryObject @229
	NtQueryEvent @230
	NtQueryFullAttributesFile @231
	NtQueryInformationFile @232
	NtQueryIoCompletion @233
	NtQueryMutant @234
	NtQuerySemaphore @235
	NtQuerySymbolicLinkObject @236
	NtQueryTimer @237
	NtQueryVirtualMemory @238
	NtQueryVolumeInformationFile @239
	NtReadFile @240
	NtReadFileScatter @241
	NtReleaseMutant @242
	NtReleaseSemaphore @243
	NtRemoveIoCompletion @244
	NtResumeThread @245
	NtSetEvent @246
	NtSetInformationFile @247
	NtSetIoCompletion @248
	NtSetSystemTime @249
	NtSetTimerEx @250
	NtSignalAndWaitForSingleObjectEx @251
	NtSuspendThread @252
	NtWaitForSingleObjectEx @253
	NtWaitForMultipleObjectsEx @254
	NtWriteFile @255
	NtWriteFileGather @256
	NtYieldExecution @257
	ObCreateObject @258
	ObCreateSymbolicLink @259
	ObDeleteSymbolicLink @260
	ObDereferenceObject @261
	ObDirectoryObjectType @262
	ObGetWaitableObject @263
	ObInsertObject @264
	ObIsTitleObject @265
	ObLookupAnyThreadByThreadId @266
	ObLookupThreadByThreadId @267
	ObMakeTemporaryObject @268
	ObOpenObjectByName @269
	ObOpenObjectByPointer @270
	ObReferenceObject @271
	ObReferenceObjectByHandle @272
	ObReferenceObjectByName @273
	ObSymbolicLinkObjectType @274
	ObTranslateSymbolicLink @275
	RtlAnsiStringToUnicodeString @276
	RtlAppendStringToString @277
	RtlAppendUnicodeStringToString @278
	RtlAppendUnicodeToString @279
	RtlAssert @280
	RtlCaptureContext @281
	RtlCompareMemory @282
	RtlCompareMemoryUlong @283
	RtlCompareString @284
	RtlCompareStringN @285
	RtlCompareUnicodeString @286
	RtlCompareUnicodeStringN @287
	RtlCompareUtf8ToUnicode @288
	RtlCopyString @289
	RtlCopyUnicodeString @290
	RtlCreateUnicodeString @291
	RtlDowncaseUnicodeChar @292
	RtlEnterCriticalSection @293
	RtlFillMemoryUlong @294
	RtlFreeAnsiString @295
	RtlFreeAnsiString2 @296
	RtlGetCallersAddress @297
	RtlGetStackLimits @298
	RtlImageXexHeaderField @299
	RtlInitAnsiString @300
	RtlInitUnicodeString @301
	RtlInitializeCriticalSection @302
	RtlInitializeCriticalSectionAndSpinCount @303
	RtlLeaveCriticalSection @304
	RtlLookupFunctionEntry @305
	RtlLowerChar @306
	RtlMultiByteToUnicodeN @307
	RtlMultiByteToUnicodeSize @308
	RtlNtStatusToDosError @309
	RtlRaiseException @310
	RtlRaiseStatus @311
	RtlRip @312
	_scprintf @313
	_snprintf @314
;	sprintf @315
;	_scwprintf @316
	_snwprintf @317
	_swprintf @318
	RtlTimeFieldsToTime @319
	RtlTimeToTimeFields @320
	RtlTryEnterCriticalSection @321
	RtlUnicodeStringToAnsiString @322
	RtlUnicodeToMultiByteN @323
	RtlUnicodeToMultiByteSize @324
	RtlUnicodeToUtf8 @325
	RtlUnicodeToUtf8Size @326
	RtlUnwind @327
	RtlUnwind2 @328
	RtlUpcaseUnicodeChar @329
	RtlUpperChar @330
	RtlVirtualUnwind @331
;	_vscprintf @332
	_vsnprintf @333
;	vsprintf @334
;	_vscwprintf @335
	_vsnwprintf @336
	_vswprintf @337
	KeTlsAlloc @338
	KeTlsFree @339
	KeTlsGetValue @340
	KeTlsSetValue @341
	XboxHardwareInfo @342
	XboxKrnlBaseVersion @343
	XboxKrnlVersion @344
	XeCryptAesKey @345
	XeCryptAesEcb @346
	XeCryptAesCbc @347
	XeCryptBnDwLeDhEqualBase @348
	XeCryptBnDwLeDhInvalBase @349
	XeCryptBnDwLeDhModExp @350
	XeCryptBnDw_Copy @351
	XeCryptBnDw_SwapLeBe @352
	XeCryptBnDw_Zero @353
	XeCryptBnDwLePkcs1Format @354
	XeCryptBnDwLePkcs1Verify @355
	XeCryptBnQwBeSigCreate @356
	XeCryptBnQwBeSigFormat @357
	XeCryptBnQwBeSigVerify @358
	XeCryptBnQwNeModExp @359
	XeCryptBnQwNeModExpRoot @360
	XeCryptBnQwNeModInv @361
	XeCryptBnQwNeModMul @362
	XeCryptBnQwNeRsaKeyGen @363
	XeCryptBnQwNeRsaPrvCrypt @364
	XeCryptBnQwNeRsaPubCrypt @365
	XeCryptBnQw_Copy @366
	XeCryptBnQw_SwapDwQw @367
	XeCryptBnQw_SwapDwQwLeBe @368
	XeCryptBnQw_SwapLeBe @369
	XeCryptBnQw_Zero @370
	XeCryptChainAndSumMac @371
	XeCryptDesParity @372
	XeCryptDesKey @373
	XeCryptDesEcb @374
	XeCryptDesCbc @375
	XeCryptDes3Key @376
	XeCryptDes3Ecb @377
	XeCryptDes3Cbc @378
	XeCryptHmacMd5Init @379
	XeCryptHmacMd5Update @380
	XeCryptHmacMd5Final @381
	XeCryptHmacMd5 @382
	XeCryptHmacShaInit @383
	XeCryptHmacShaUpdate @384
	XeCryptHmacShaFinal @385
	XeCryptHmacSha @386
	XeCryptHmacShaVerify @387
	XeCryptMd5Init @388
	XeCryptMd5Update @389
	XeCryptMd5Final @390
	XeCryptMd5 @391
	XeCryptParveEcb @392
	XeCryptParveCbcMac @393
	XeCryptRandom @394
	XeCryptRc4Key @395
	XeCryptRc4Ecb @396
	XeCryptRc4 @397
	XeCryptRotSumSha @398
	XeCryptShaInit @399
	XeCryptShaUpdate @400
	XeCryptShaFinal @401
	XeCryptSha @402
	XexExecutableModuleHandle @403
	XexCheckExecutablePrivilege @404
	XexGetModuleHandle @405
	XexGetModuleSection @406
	XexGetProcedureAddress @407
	XexLoadExecutable @408
	XexLoadImage @409
	XexLoadImageFromMemory @410
	XexLoadImageHeaders @411
	XexPcToFileHeader @412
	XexRegisterPatchDescriptor @414
	XexSendDeferredNotifications @415
	XexStartExecutable @416
	XexUnloadImage @417
	XexUnloadImageAndExitThread @418
	XexUnloadTitleModules @419
	XexVerifyImageHeaders @420
	DbgLoadImageSymbols @422
	DbgUnLoadImageSymbols @423
	RtlImageDirectoryEntryToData @424
	RtlImageNtHeader @425
	ExDebugMonitorService @426
	MmDbgReadCheck @427
	MmDbgReleaseAddress @428
	MmDbgWriteCheck @429
	ExLoadedCommandLine @430
	ExLoadedImageName @431
	VdBlockUntilGUIIdle @432
	VdCallGraphicsNotificationRoutines @433
	VdDisplayFatalError @434
	VdEnableClosedCaption @435
	VdEnableDisableClockGating @436
	VdEnableDisablePowerSavingMode @437
	VdEnableRingBufferRPtrWriteBack @438
	VdGenerateGPUCSCCoefficients @439
	VdGetClosedCaptionReadyStatus @440
	VdGetCurrentDisplayGamma @441
	VdGetCurrentDisplayInformation @442
	VdGetDisplayModeOverride @443
	VdGetGraphicsAsicID @444
	VdGetSystemCommandBuffer @445
	VdGlobalDevice @446
	VdGlobalXamDevice @447
	VdGpuClockInMHz @448
	VdHSIOCalibrationLock @449
	VdInitializeEngines @450
	VdInitializeRingBuffer @451
	VdInitializeScaler @452
	VdInitializeScalerCommandBuffer @453
	VdIsHSIOTrainingSucceeded @454
	VdPersistDisplay @455
	VdQuerySystemCommandBuffer @456
	VdQueryVideoFlags @457
	VdQueryVideoMode @458
	VdReadDVERegisterUlong @459
	VdReadWriteHSIOCalibrationFlag @460
	VdRegisterGraphicsNotification @461
	VdRegisterXamGraphicsNotification @462
	VdSendClosedCaptionData @463
	VdSetCGMSOption @464
	VdSetColorProfileAdjustment @465
	VdSetCscMatricesOverride @466
	VdSetDisplayMode @467
	VdSetDisplayModeOverride @468
	VdSetGraphicsInterruptCallback @469
	VdSetHDCPOption @470
	VdSetMacrovisionOption @471
	VdSetSystemCommandBuffer @472
	VdSetSystemCommandBufferGpuIdentifierAddress @473
	VdSetWSSData @474
	VdSetWSSOption @475
	VdShutdownEngines @476
	VdTurnDisplayOff @477
	VdTurnDisplayOn @478
	VdWriteDVERegisterUlong @480
	XVoicedHeadsetPresent @481
	XVoicedSubmitPacket @482
	XVoicedClose @483
	XVoicedActivate @484
	XInputdGetCapabilities @485
	XInputdReadState @486
	XInputdWriteState @487
	XInputdNotify @488
	XInputdRawState @489
	HidGetCapabilities @490
	HidReadKeys @491
	XInputdGetDeviceStats @492
	XInputdResetDevice @493
	XInputdSetRingOfLight @494
	XInputdSetRFPowerMode @495
	XInputdSetRadioFrequency @496
	HidGetLastInputTime @497
	XAudioRenderDriverInitialize @498
	XAudioRegisterRenderDriverClient @499
	XAudioUnregisterRenderDriverClient @500
	XAudioSubmitRenderDriverFrame @501
	XAudioRenderDriverLock @502
	XAudioGetVoiceCategoryVolumeChangeMask @503
	XAudioGetVoiceCategoryVolume @504
	XAudioSetVoiceCategoryVolume @505
	XAudioBeginDigitalBypassMode @506
	XAudioEndDigitalBypassMode @507
	XAudioSubmitDigitalPacket @508
	XAudioQueryDriverPerformance @509
	XAudioGetRenderDriverThread @510
	XAudioGetSpeakerConfig @511
	XAudioSetSpeakerConfig @512
	NicSetUnicastAddress @513
	NicAttach @514
	NicDetach @515
	NicXmit @516
	NicUpdateMcastMembership @517
	NicFlushXmitQueue @518
	NicShutdown @519
	NicGetLinkState @520
	NicGetStats @521
	NicGetOpt @522
	NicSetOpt @523
	DrvSetSysReqCallback @524
	DrvSetUserBindingCallback @525
	DrvSetContentStorageCallback @526
	DrvSetAutobind @527
	DrvGetContentStorageNotification @528
	MtpdBeginTransaction @529
	MtpdCancelTransaction @530
	MtpdEndTransaction @531
	MtpdGetCurrentDevices @532
	MtpdReadData @533
	MtpdReadEvent @534
	MtpdResetDevice @535
	MtpdSendData @536
	MtpdVerifyProximity @537
	XUsbcamSetCaptureMode @538
	XUsbcamGetConfig @539
	XUsbcamSetConfig @540
	XUsbcamGetState @541
	XUsbcamReadFrame @542
	XUsbcamSnapshot @543
	XUsbcamSetView @544
	XUsbcamGetView @545
	XUsbcamCreate @546
	XUsbcamDestroy @547
	XMACreateContext @548
	XMAInitializeContext @549
	XMAReleaseContext @550
	XMAEnableContext @551
	XMADisableContext @552
	XMAGetOutputBufferWriteOffset @553
	XMASetOutputBufferReadOffset @554
	XMAGetOutputBufferReadOffset @555
	XMASetOutputBufferValid @556
	XMAIsOutputBufferValid @557
	XMASetInputBuffer0Valid @558
	XMAIsInputBuffer0Valid @559
	XMASetInputBuffer1Valid @560
	XMAIsInputBuffer1Valid @561
	XMASetInputBuffer0 @562
	XMASetInputBuffer1 @563
	XMAGetPacketMetadata @564
	XMABlockWhileInUse @565
	XMASetLoopData @566
	XMASetInputBufferReadOffset @567
	XMAGetInputBufferReadOffset @568
	ExIsBetaFeatureEnabled @569
	XeKeysGetFactoryChallenge @570
	XeKeysSetFactoryResponse @571
	XeKeysInitializeFuses @572
	XeKeysSaveBootLoader @573
	XeKeysSaveKeyVault @574
	XeKeysGetStatus @575
	XeKeysGeneratePrivateKey @576
	XeKeysGetKeyProperties @577
	XeKeysSetKey @578
	XeKeysGenerateRandomKey @579
	XeKeysGetKey @580
	XeKeysGetDigest @581
	XeKeysGetConsoleID @582
	XeKeysGetConsoleType @583
	XeKeysQwNeRsaPrvCrypt @584
	XeKeysHmacSha @585
	XInputdPassThroughRFCommand @586
	XeKeysAesCbc @587
	XeKeysDes2Cbc @588
	XeKeysDesCbc @589
	XeKeysObscureKey @590
	XeKeysHmacShaUsingKey @591
	XeKeysSaveBootLoaderEx @592
	XeKeysAesCbcUsingKey @593
	XeKeysDes2CbcUsingKey @594
	XeKeysDesCbcUsingKey @595
	XeKeysObfuscate @596
	XeKeysUnObfuscate @597
	XeKeysConsolePrivateKeySign @598
	XeKeysConsoleSignatureVerification @599
	XeKeysVerifyRSASignature @600
	StfsCreateDevice @601
	StfsControlDevice @602
	VdSwap @603
	HalFsbInterruptCount @604
	XeKeysSaveSystemUpdate @605
	XeKeysLockSystemUpdate @606
	XeKeysExecute @607
	XeKeysGetVersions @608
	XInputdPowerDownDevice @609
	AniBlockOnAnimation @610
	AniTerminateAnimation @611
	XUsbcamReset @612
	AniSetLogo @613
	KeCertMonitorData @614
	HalIsExecutingPowerDownDpc @615
	VdInitializeEDRAM @616
	VdRetrainEDRAM @617
	VdRetrainEDRAMWorker @618
	VdHSIOTrainCount @619
	HalGetPowerUpCause @620
	VdHSIOTrainingStatus @621
	RgcBindInfo @622
	VdReadEEDIDBlock @623
	VdEnumerateVideoModes @624
	VdEnableHDCP @625
	VdRegisterHDCPNotification @626
	HidReadMouseChanges @627
	DumpSetCollectionFacility @628
	XexTransformImageKey @629
	XAudioOverrideSpeakerConfig @630
	XInputdReadTextKeystroke @631
	DrvXenonButtonPressed @632
	DrvBindToUser @633
	XexGetModuleImportVersions @634
	RtlComputeCrc32 @635
	XeKeysSetRevocationList @636
	HalRegisterPowerDownCallback @637
	VdGetDisplayDiscoveryData @638
	XInputdSendStayAliveRequest @639
	XVoicedSendVPort @640
	XVoicedGetBatteryStatus @641
	XInputdFFGetDeviceInfo @642
	XInputdFFSetEffect @643
	XInputdFFUpdateEffect @644
	XInputdFFEffectOperation @645
	XInputdFFDeviceControl @646
	XInputdFFSetDeviceGain @647
	XInputdFFCancelIo @648
	XInputdFFSetRumble @649
	NtAllocateEncryptedMemory @650
	NtFreeEncryptedMemory @651
	XeKeysExSaveKeyVault @652
	XeKeysExSetKey @653
	XeKeysExGetKey @654
	DrvSetDeviceConfigChangeCallback @655
	DrvDeviceConfigChange @656
	HalRegisterHdDvdRomNotification @657
	XeKeysSecurityInitialize @658
	XeKeysSecurityLoadSettings @659
	XeKeysSecuritySaveSettings @660
	XeKeysSecuritySetDetected @661
	XeKeysSecurityGetDetected @662
	XeKeysSecuritySetActivated @663
	XeKeysSecurityGetActivated @664
	XeKeysGetProtectedFlag @667
	XeKeysSetProtectedFlag @668
	KeEnablePFMInterrupt @669
	KeDisablePFMInterrupt @670
	KeSetProfilerISR @671
	VdStartDisplayDiscovery @672
	VdSetHDCPRevocationList @673
	XeKeysGetUpdateSequence @674
	XeKeysDvdAuthExActivate @675
	KeGetImagePageTableEntry @676
	HalRegisterBackgroundModeTransitionCallback @677
	AniStartBootAnimation @678
	HalClampUnclampOutputDACs @679
	HalPowerDownToBackgroundMode @680
	HalNotifyAddRemoveBackgroundTask @681
	HalCallBackgroundModeNotificationRoutines @682
	HalFsbResetCount @683
	HalGetMemoryInformation @684
	XInputdGetLastTextInputTime @685
	VdEnableWMAProOverHDMI @686
	XeKeysRevokeSaveSettings @687
	XInputdSetTextMessengerIndicator @688
	MicDeviceRequest @689
	XeKeysGetMediaID @690
	KeGetVidInfo @692
	HalNotifyBackgroundModeTransitionComplete @693
	IoAcquireCancelSpinLock @694
	IoReleaseCancelSpinLock @695
	NtCancelIoFile @696
	NtCancelIoFileEx @697
	HalFinalizePowerLossRecovery @698
	HalSetPowerLossRecovery @699
	ExReadModifyWriteXConfigSettingUlong @700
	HalRegisterXamPowerDownCallback @701
	ExCancelAlarm @702
	ExInitializeAlarm @703
	ExSetAlarm @704
	XexActivationGetNonce @705
	XexActivationSetLicense @706
	IptvSetBoundaryKey @707
	IptvSetSessionKey @708
	IptvVerifyOmac1Signature @709
	IptvGetAesCtrTransform @710
	SataCdRomRecordReset @711
	XInputdSetTextDeviceKeyLocks @712
	XInputdGetTextDeviceKeyLocks @713
	XexActivationVerifyOwnership @714
	XexDisableVerboseDbgPrint @715
	SvodCreateDevice @716
	RtlCaptureStackBackTrace @717
	XeKeysRevokeUpdateDynamic @718
	XexImportTraceEnable @719
	ExRegisterXConfigNotification @720
	XeKeysSecuritySetStat @721
	VdQueryRealVideoMode @722
	XexSetExecutablePrivilege @723
	XAudioSuspendRenderDriverClients @724
	IptvGetSessionKeyHash @725
	VdSetCGMSState @726
	VdSetSCMSState @727
	KeFlushMultipleTb @728
	VdGetOption @729
	VdSetOption @730
	UsbdBootEnumerationDoneEvent @731
	StfsDeviceErrorEvent @732
	ExTryToAcquireReadWriteLockExclusive @733
	ExTryToAcquireReadWriteLockShared @734
	XexSetLastKdcTime @735
	XInputdControl @736
	RmcDeviceRequest @737
	LDIResetDecompression @738
	NicRegisterDevice @739
	UsbdAddDeviceComplete @740
	UsbdCancelAsyncTransfer @741
	UsbdGetDeviceSpeed @742
	UsbdGetDeviceTopology @743
	UsbdGetEndpointDescriptor @744
	UsbdIsDeviceAuthenticated @745
	UsbdOpenDefaultEndpoint @746
	UsbdOpenEndpoint @747
	UsbdQueueAsyncTransfer @748
	UsbdQueueCloseDefaultEndpoint @749
	UsbdQueueCloseEndpoint @750
	UsbdRemoveDeviceComplete @751
	KeRemoveQueueApc @752
	UsbdDriverLoadRequiredEvent @753
	UsbdGetRequiredDrivers @754
	UsbdRegisterDriverObject @755
	UsbdUnregisterDriverObject @756
	UsbdResetDevice @758
	UsbdGetDeviceDescriptor @759
	NomnilGetExtension @760
	NomnilStartCloseDevice @761
	WifiBeginAuthentication @762
	WifiCheckCounterMeasures @763
	WifiChooseAuthenCipherSetFromBSSID @764
	WifiCompleteAuthentication @765
	WifiGetAssociationIE @766
	WifiOnMICError @767
	WifiPrepareAuthenticationContext @768
	WifiRecvEAPOLPacket @769
	WifiDeduceNetworkType @770
	NicUnregisterDevice @771
	DumpXitThread @772
	XInputdSetWifiChannel @773
	NomnilSetLed @774
	WifiCalculateRegulatoryDomain @775
	WifiSelectAdHocChannel @776
	WifiChannelToFrequency @777
	MmGetPoolPagesType @778
	ExExpansionInstall @779
	ExExpansionCall @780
	PsCamDeviceRequest @781
	McaDeviceRequest @782
	DetroitDeviceRequest @783
	XeCryptSha256Init @784
	XeCryptSha256Update @785
	XeCryptSha256Final @786
	XeCryptSha256 @787
	XeCryptSha384Init @788
	XeCryptSha384Update @789
	XInputdGetDevicePid @790
	HalGetNotedArgonErrors @791
	XeCryptSha384Final @792
	HalReadArgonEeprom @793
	HalWriteArgonEeprom @794
	XeKeysFcrtLoad @795
	XeKeysFcrtSave @796
	XeKeysFcrtSet @797
	XeCryptSha384 @798
	XeCryptSha512Init @799
	XAudioRegisterRenderDriverMECClient @800
	XAudioUnregisterRenderDriverMECClient @801
	XAudioCaptureRenderDriverFrame @802
	XeCryptSha512Update @803
	XeCryptSha512Final @804
	XeCryptSha512 @805
	XeCryptBnQwNeCompare @806
	XVoicedGetDirectionalData @807
	DrvSetMicArrayStartCallback @808
	DevAuthGetStatistics @809
	NullCableRequest @810
	XeKeysRevokeIsDeviceRevoked @811
	DumpUpdateDumpSettings @812
	EtxConsumerDisableEventType @813
	EtxConsumerEnableEventType @814
	EtxConsumerProcessLogs @815
	EtxConsumerRegister @816
	EtxConsumerUnregister @817
	EtxProducerLog @818
	EtxProducerLogV @819
	EtxProducerRegister @820
	EtxProducerUnregister @821
	EtxConsumerFlushBuffers @822
	EtxProducerLogXwpp @823
	EtxProducerLogXwppV @824
	UsbdEnableDisableRootHubPort @825
	EtxBufferRegister @826
	EtxBufferUnregister @827
	DumpRegisterDedicatedDataBlock @828
	XeKeysDvdAuthExSave @829
	XeKeysDvdAuthExInstall @830
	XexShimDisable @831
	XexShimEnable @832
	XexShimEntryDisable @833
	XexShimEntryEnable @834
	XexShimEntryRegister @835
	XexShimLock @836
	XboxKrnlVersion4Digit @837
	XeKeysObfuscateEx @838
	XeKeysUnObfuscateEx @839
	XexTitleHash @840
	XexTitleHashClose @841
	XexTitleHashContinue @842
	XexTitleHashOpen @843
	XAudioGetRenderDriverTic @844
	XAudioEnableDucker @845
	XAudioSetDuckerLevel @846
	XAudioIsDuckerEnabled @847
	XAudioGetDuckerLevel @848
	XAudioGetDuckerThreshold @849
	XAudioSetDuckerThreshold @850
	XAudioGetDuckerAttackTime @851
	XAudioSetDuckerAttackTime @852
	XAudioGetDuckerReleaseTime @853
	XAudioSetDuckerReleaseTime @854
	XAudioGetDuckerHoldTime @855
	XAudioSetDuckerHoldTime @856
	DevAuthShouldAlwaysEnforce @857
	XAudioGetUnderrunCount @858
	DrvSetAudioLatencyCallback @859
	XVoicedIsActiveProcess @860
	KeExecuteOnProtectedStack @861
	XeKeysVerifyPIRSSignature @862
	XeCryptAesCtr @863
	XeCryptAesCbcMac @864
	XeCryptAesDmMac @865
	EmaExecute @866
	XeKeysGetTruncatedSecondaryConsoleId @867
	ExFreeDebugPool @868
	VdQueryVideoCapabilities @869
	UsbdGetDeviceRootPortType @870
	VdGet3dVideoFormat @871
	VdGetWSS2Data @872
	VdSet3dVideoFormat @873
	VdSetWSS2Data @874
	XexReserveCodeBuffer @875
	XexCommitCodeBuffer @876
	RtlSetVectoredExceptionHandler @877
	RtlClearVectoredExceptionHandler @878
	XAudioSetProcessFrameCallback @879
	UsbdGetRootHubDeviceNode @880
	UsbdGetPortDeviceNode @881
	UsbdGetNatalHub @882
	UsbdGetNatalHardwareVersion @883
	UsbdNatalHubRegisterNotificationCallback @884
	KeCallAndBlockOnDpcRoutine @885
	KeCallAndWaitForDpcRoutine @886
	TidDeviceRequest @887
	DmPrintData @888
	VdSetStudioRGBMode @889


```

`XenonDumper/libs/xkelib/kernel/kernelext21119.0.def`:

```def
LIBRARY xboxkrnl.exe@21119.0+1861.0
EXPORTS
	DbgBreakPoint @1
	DbgBreakPointWithStatus @2
	DbgPrint @3
	DbgPrompt @4
	DumpGetRawDumpInfo @5
	DumpWriteDump @6
	ExAcquireReadWriteLockExclusive @7
	ExAcquireReadWriteLockShared @8
	ExAllocatePool @9
	ExAllocatePoolWithTag @10
	ExAllocatePoolTypeWithTag @11
	ExConsoleGameRegion @12
	ExCreateThread @13
	ExEventObjectType @14
	ExFreePool @15
	ExGetXConfigSetting @16
	ExInitializeReadWriteLock @17
	ExMutantObjectType @18
	ExQueryPoolBlockSize @19
	ExRegisterThreadNotification @20
	ExRegisterTitleTerminateNotification @21
	ExReleaseReadWriteLock @22
	ExSemaphoreObjectType @23
	ExSetXConfigSetting @24
	ExTerminateThread @25
	ExTerminateTitleProcess @26
	ExThreadObjectType @27
	ExTimerObjectType @28
	MmDoubleMapMemory @29
	MmUnmapMemory @30
	XeKeysGetConsoleCertificate @31
	FscGetCacheElementCount @32
	FscSetCacheElementCount @33
	HalGetCurrentAVPack @34
	HalGpioControl @35
	HalOpenCloseODDTray @36
	HalReadWritePCISpace @37
	HalRegisterPowerDownNotification @38
	HalRegisterSMCNotification @39
	HalReturnToFirmware @40
	HalSendSMCMessage @41
	HalSetAudioEnable @42
	InterlockedFlushSList @43
	InterlockedPopEntrySList @44
	InterlockedPushEntrySList @45
	IoAcquireDeviceObjectLock @46
	IoAllocateIrp @47
	IoBuildAsynchronousFsdRequest @48
	IoBuildDeviceIoControlRequest @49
	IoBuildSynchronousFsdRequest @50
	IoCallDriver @51
	IoCheckShareAccess @52
	IoCompleteRequest @53
	IoCompletionObjectType @54
	IoCreateDevice @55
	IoCreateFile @56
	IoDeleteDevice @57
	IoDeviceObjectType @58
	IoDismountVolume @59
	IoDismountVolumeByFileHandle @60
	IoDismountVolumeByName @61
	IoFileObjectType @62
	IoFreeIrp @63
	IoInitializeIrp @64
	IoInvalidDeviceRequest @65
	ExSetBetaFeaturesEnabled @66
	IoQueueThreadIrp @67
	IoReleaseDeviceObjectLock @68
	IoRemoveShareAccess @69
	IoSetIoCompletion @70
	IoSetShareAccess @71
	IoStartNextPacket @72
	IoStartNextPacketByKey @73
	IoStartPacket @74
	IoSynchronousDeviceIoControlRequest @75
	IoSynchronousFsdRequest @76
	KeAcquireSpinLockAtRaisedIrql @77
	KeAlertResumeThread @78
	KeAlertThread @79
	KeBlowFuses @80
	KeBoostPriorityThread @81
	KeBugCheck @82
	KeBugCheckEx @83
	KeCancelTimer @84
	KeConnectInterrupt @85
	KeContextFromKframes @86
	KeContextToKframes @87
	KeCreateUserMode @88
	KeDebugMonitorData @89
	KeDelayExecutionThread @90
	KeDeleteUserMode @91
	KeDisconnectInterrupt @92
	KeEnableFpuExceptions @93
	KeEnablePPUPerformanceMonitor @94
	KeEnterCriticalRegion @95
	KeEnterUserMode @96
	KeFlushCacheRange @97
	KeFlushCurrentEntireTb @98
	KeFlushEntireTb @99
	KeFlushUserModeCurrentTb @100
	KeFlushUserModeTb @101
	KeGetCurrentProcessType @102
	KeGetPMWRegister @103
	KeGetPRVRegister @104
	KeGetSocRegister @105
	KeGetSpecialPurposeRegister @106
	KeLockL2 @107
	KeUnlockL2 @108
	KeInitializeApc @109
	KeInitializeDeviceQueue @110
	KeInitializeDpc @111
	KeInitializeEvent @112
	KeInitializeInterrupt @113
	KeInitializeMutant @114
	KeInitializeQueue @115
	KeInitializeSemaphore @116
	KeInitializeTimerEx @117
	KeInsertByKeyDeviceQueue @118
	KeInsertDeviceQueue @119
	KeInsertHeadQueue @120
	KeInsertQueue @121
	KeInsertQueueApc @122
	KeInsertQueueDpc @123
	KeIpiGenericCall @124
	KeLeaveCriticalRegion @125
	KeLeaveUserMode @126
	KePulseEvent @127
	KeQueryBackgroundProcessors @128
	KeQueryBasePriorityThread @129
	KeQueryInterruptTime @130
	KeQueryPerformanceFrequency @131
	KeQuerySystemTime @132
	KeRaiseIrqlToDpcLevel @133
	KeRegisterDriverNotification @134
	KeReleaseMutant @135
	KeReleaseSemaphore @136
	KeReleaseSpinLockFromRaisedIrql @137
	KeRemoveByKeyDeviceQueue @138
	KeRemoveDeviceQueue @139
	KeRemoveEntryDeviceQueue @140
	KeRemoveQueue @141
	KeRemoveQueueDpc @142
	KeResetEvent @143
	KeRestoreFloatingPointState @144
	KeRestoreVectorUnitState @145
	KeResumeThread @146
	KeRetireDpcList @147
	KeRundownQueue @148
	KeSaveFloatingPointState @149
	KeSaveVectorUnitState @150
	KeSetAffinityThread @151
	KeSetBackgroundProcessors @152
	KeSetBasePriorityThread @153
	KeSetCurrentProcessType @154
	KeSetCurrentStackPointers @155
	KeSetDisableBoostThread @156
	KeSetEvent @157
	KeSetEventBoostPriority @158
	KeSetPMWRegister @159
	KeSetPowerMode @160
	KeSetPRVRegister @161
	KeSetPriorityClassThread @162
	KeSetPriorityThread @163
	KeSetSocRegister @164
	KeSetSpecialPurposeRegister @165
	KeSetTimer @166
	KeSetTimerEx @167
	KeStallExecutionProcessor @168
	KeSuspendThread @169
	KeSweepDcacheRange @170
	KeSweepIcacheRange @171
	KeTestAlertThread @172
	KeTimeStampBundle @173
	KeTryToAcquireSpinLockAtRaisedIrql @174
	KeWaitForMultipleObjects @175
	KeWaitForSingleObject @176
	KfAcquireSpinLock @177
	KfRaiseIrql @178
	KfLowerIrql @179
	KfReleaseSpinLock @180
	KiBugCheckData @181
	LDICreateDecompression @182
	LDIDecompress @183
	LDIDestroyDecompression @184
	MmAllocatePhysicalMemory @185
	MmAllocatePhysicalMemoryEx @186
	MmCreateKernelStack @187
	MmDeleteKernelStack @188
	MmFreePhysicalMemory @189
	MmGetPhysicalAddress @190
	MmIsAddressValid @191
	MmLockAndMapSegmentArray @192
	MmLockUnlockBufferPages @193
	MmMapIoSpace @194
	MmPersistPhysicalMemoryAllocation @195
	MmQueryAddressProtect @196
	MmQueryAllocationSize @197
	MmQueryStatistics @198
	MmSetAddressProtect @199
	MmSplitPhysicalMemoryAllocation @200
	MmUnlockAndUnmapSegmentArray @201
	MmUnmapIoSpace @202
	Nls844UnicodeCaseTable @203
	NtAllocateVirtualMemory @204
	NtCancelTimer @205
	NtClearEvent @206
	NtClose @207
	NtCreateDirectoryObject @208
	NtCreateEvent @209
	NtCreateFile @210
	NtCreateIoCompletion @211
	NtCreateMutant @212
	NtCreateSemaphore @213
	NtCreateSymbolicLinkObject @214
	NtCreateTimer @215
	NtDeleteFile @216
	NtDeviceIoControlFile @217
	NtDuplicateObject @218
	NtFlushBuffersFile @219
	NtFreeVirtualMemory @220
	NtMakeTemporaryObject @221
	NtOpenDirectoryObject @222
	NtOpenFile @223
	NtOpenSymbolicLinkObject @224
	NtProtectVirtualMemory @225
	NtPulseEvent @226
	NtQueueApcThread @227
	NtQueryDirectoryFile @228
	NtQueryDirectoryObject @229
	NtQueryEvent @230
	NtQueryFullAttributesFile @231
	NtQueryInformationFile @232
	NtQueryIoCompletion @233
	NtQueryMutant @234
	NtQuerySemaphore @235
	NtQuerySymbolicLinkObject @236
	NtQueryTimer @237
	NtQueryVirtualMemory @238
	NtQueryVolumeInformationFile @239
	NtReadFile @240
	NtReadFileScatter @241
	NtReleaseMutant @242
	NtReleaseSemaphore @243
	NtRemoveIoCompletion @244
	NtResumeThread @245
	NtSetEvent @246
	NtSetInformationFile @247
	NtSetIoCompletion @248
	NtSetSystemTime @249
	NtSetTimerEx @250
	NtSignalAndWaitForSingleObjectEx @251
	NtSuspendThread @252
	NtWaitForSingleObjectEx @253
	NtWaitForMultipleObjectsEx @254
	NtWriteFile @255
	NtWriteFileGather @256
	NtYieldExecution @257
	ObCreateObject @258
	ObCreateSymbolicLink @259
	ObDeleteSymbolicLink @260
	ObDereferenceObject @261
	ObDirectoryObjectType @262
	ObGetWaitableObject @263
	ObInsertObject @264
	ObIsTitleObject @265
	ObLookupAnyThreadByThreadId @266
	ObLookupThreadByThreadId @267
	ObMakeTemporaryObject @268
	ObOpenObjectByName @269
	ObOpenObjectByPointer @270
	ObReferenceObject @271
	ObReferenceObjectByHandle @272
	ObReferenceObjectByName @273
	ObSymbolicLinkObjectType @274
	ObTranslateSymbolicLink @275
	RtlAnsiStringToUnicodeString @276
	RtlAppendStringToString @277
	RtlAppendUnicodeStringToString @278
	RtlAppendUnicodeToString @279
	RtlAssert @280
	RtlCaptureContext @281
	RtlCompareMemory @282
	RtlCompareMemoryUlong @283
	RtlCompareString @284
	RtlCompareStringN @285
	RtlCompareUnicodeString @286
	RtlCompareUnicodeStringN @287
	RtlCompareUtf8ToUnicode @288
	RtlCopyString @289
	RtlCopyUnicodeString @290
	RtlCreateUnicodeString @291
	RtlDowncaseUnicodeChar @292
	RtlEnterCriticalSection @293
	RtlFillMemoryUlong @294
	RtlFreeAnsiString @295
	RtlFreeAnsiString2 @296
	RtlGetCallersAddress @297
	RtlGetStackLimits @298
	RtlImageXexHeaderField @299
	RtlInitAnsiString @300
	RtlInitUnicodeString @301
	RtlInitializeCriticalSection @302
	RtlInitializeCriticalSectionAndSpinCount @303
	RtlLeaveCriticalSection @304
	RtlLookupFunctionEntry @305
	RtlLowerChar @306
	RtlMultiByteToUnicodeN @307
	RtlMultiByteToUnicodeSize @308
	RtlNtStatusToDosError @309
	RtlRaiseException @310
	RtlRaiseStatus @311
	RtlRip @312
	_scprintf @313
	_snprintf @314
;	sprintf @315
;	_scwprintf @316
	_snwprintf @317
	_swprintf @318
	RtlTimeFieldsToTime @319
	RtlTimeToTimeFields @320
	RtlTryEnterCriticalSection @321
	RtlUnicodeStringToAnsiString @322
	RtlUnicodeToMultiByteN @323
	RtlUnicodeToMultiByteSize @324
	RtlUnicodeToUtf8 @325
	RtlUnicodeToUtf8Size @326
	RtlUnwind @327
	RtlUnwind2 @328
	RtlUpcaseUnicodeChar @329
	RtlUpperChar @330
	RtlVirtualUnwind @331
;	_vscprintf @332
	_vsnprintf @333
;	vsprintf @334
;	_vscwprintf @335
	_vsnwprintf @336
	_vswprintf @337
	KeTlsAlloc @338
	KeTlsFree @339
	KeTlsGetValue @340
	KeTlsSetValue @341
	XboxHardwareInfo @342
	XboxKrnlBaseVersion @343
	XboxKrnlVersion @344
	XeCryptAesKey @345
	XeCryptAesEcb @346
	XeCryptAesCbc @347
	XeCryptBnDwLeDhEqualBase @348
	XeCryptBnDwLeDhInvalBase @349
	XeCryptBnDwLeDhModExp @350
	XeCryptBnDw_Copy @351
	XeCryptBnDw_SwapLeBe @352
	XeCryptBnDw_Zero @353
	XeCryptBnDwLePkcs1Format @354
	XeCryptBnDwLePkcs1Verify @355
	XeCryptBnQwBeSigCreate @356
	XeCryptBnQwBeSigFormat @357
	XeCryptBnQwBeSigVerify @358
	XeCryptBnQwNeModExp @359
	XeCryptBnQwNeModExpRoot @360
	XeCryptBnQwNeModInv @361
	XeCryptBnQwNeModMul @362
	XeCryptBnQwNeRsaKeyGen @363
	XeCryptBnQwNeRsaPrvCrypt @364
	XeCryptBnQwNeRsaPubCrypt @365
	XeCryptBnQw_Copy @366
	XeCryptBnQw_SwapDwQw @367
	XeCryptBnQw_SwapDwQwLeBe @368
	XeCryptBnQw_SwapLeBe @369
	XeCryptBnQw_Zero @370
	XeCryptChainAndSumMac @371
	XeCryptDesParity @372
	XeCryptDesKey @373
	XeCryptDesEcb @374
	XeCryptDesCbc @375
	XeCryptDes3Key @376
	XeCryptDes3Ecb @377
	XeCryptDes3Cbc @378
	XeCryptHmacMd5Init @379
	XeCryptHmacMd5Update @380
	XeCryptHmacMd5Final @381
	XeCryptHmacMd5 @382
	XeCryptHmacShaInit @383
	XeCryptHmacShaUpdate @384
	XeCryptHmacShaFinal @385
	XeCryptHmacSha @386
	XeCryptHmacShaVerify @387
	XeCryptMd5Init @388
	XeCryptMd5Update @389
	XeCryptMd5Final @390
	XeCryptMd5 @391
	XeCryptParveEcb @392
	XeCryptParveCbcMac @393
	XeCryptRandom @394
	XeCryptRc4Key @395
	XeCryptRc4Ecb @396
	XeCryptRc4 @397
	XeCryptRotSumSha @398
	XeCryptShaInit @399
	XeCryptShaUpdate @400
	XeCryptShaFinal @401
	XeCryptSha @402
	XexExecutableModuleHandle @403
	XexCheckExecutablePrivilege @404
	XexGetModuleHandle @405
	XexGetModuleSection @406
	XexGetProcedureAddress @407
	XexLoadExecutable @408
	XexLoadImage @409
	XexLoadImageFromMemory @410
	XexLoadImageHeaders @411
	XexPcToFileHeader @412
	XexRegisterPatchDescriptor @414
	XexSendDeferredNotifications @415
	XexStartExecutable @416
	XexUnloadImage @417
	XexUnloadImageAndExitThread @418
	XexUnloadTitleModules @419
	XexVerifyImageHeaders @420
	DbgLoadImageSymbols @422
	DbgUnLoadImageSymbols @423
	RtlImageDirectoryEntryToData @424
	RtlImageNtHeader @425
	ExDebugMonitorService @426
	MmDbgReadCheck @427
	MmDbgReleaseAddress @428
	MmDbgWriteCheck @429
	ExLoadedCommandLine @430
	ExLoadedImageName @431
	VdBlockUntilGUIIdle @432
	VdCallGraphicsNotificationRoutines @433
	VdDisplayFatalError @434
	VdEnableClosedCaption @435
	VdEnableDisableClockGating @436
	VdEnableDisablePowerSavingMode @437
	VdEnableRingBufferRPtrWriteBack @438
	VdGenerateGPUCSCCoefficients @439
	VdGetClosedCaptionReadyStatus @440
	VdGetCurrentDisplayGamma @441
	VdGetCurrentDisplayInformation @442
	VdGetDisplayModeOverride @443
	VdGetGraphicsAsicID @444
	VdGetSystemCommandBuffer @445
	VdGlobalDevice @446
	VdGlobalXamDevice @447
	VdGpuClockInMHz @448
	VdHSIOCalibrationLock @449
	VdInitializeEngines @450
	VdInitializeRingBuffer @451
	VdInitializeScaler @452
	VdInitializeScalerCommandBuffer @453
	VdIsHSIOTrainingSucceeded @454
	VdPersistDisplay @455
	VdQuerySystemCommandBuffer @456
	VdQueryVideoFlags @457
	VdQueryVideoMode @458
	VdReadDVERegisterUlong @459
	VdReadWriteHSIOCalibrationFlag @460
	VdRegisterGraphicsNotification @461
	VdRegisterXamGraphicsNotification @462
	VdSendClosedCaptionData @463
	VdSetCGMSOption @464
	VdSetColorProfileAdjustment @465
	VdSetCscMatricesOverride @466
	VdSetDisplayMode @467
	VdSetDisplayModeOverride @468
	VdSetGraphicsInterruptCallback @469
	VdSetHDCPOption @470
	VdSetMacrovisionOption @471
	VdSetSystemCommandBuffer @472
	VdSetSystemCommandBufferGpuIdentifierAddress @473
	VdSetWSSData @474
	VdSetWSSOption @475
	VdShutdownEngines @476
	VdTurnDisplayOff @477
	VdTurnDisplayOn @478
	VdWriteDVERegisterUlong @480
	XVoicedHeadsetPresent @481
	XVoicedSubmitPacket @482
	XVoicedClose @483
	XVoicedActivate @484
	XInputdGetCapabilities @485
	XInputdReadState @486
	XInputdWriteState @487
	XInputdNotify @488
	XInputdRawState @489
	HidGetCapabilities @490
	HidReadKeys @491
	XInputdGetDeviceStats @492
	XInputdResetDevice @493
	XInputdSetRingOfLight @494
	XInputdSetRFPowerMode @495
	XInputdSetRadioFrequency @496
	HidGetLastInputTime @497
	XAudioRenderDriverInitialize @498
	XAudioRegisterRenderDriverClient @499
	XAudioUnregisterRenderDriverClient @500
	XAudioSubmitRenderDriverFrame @501
	XAudioRenderDriverLock @502
	XAudioGetVoiceCategoryVolumeChangeMask @503
	XAudioGetVoiceCategoryVolume @504
	XAudioSetVoiceCategoryVolume @505
	XAudioBeginDigitalBypassMode @506
	XAudioEndDigitalBypassMode @507
	XAudioSubmitDigitalPacket @508
	XAudioQueryDriverPerformance @509
	XAudioGetRenderDriverThread @510
	XAudioGetSpeakerConfig @511
	XAudioSetSpeakerConfig @512
	NicSetUnicastAddress @513
	NicAttach @514
	NicDetach @515
	NicXmit @516
	NicUpdateMcastMembership @517
	NicFlushXmitQueue @518
	NicShutdown @519
	NicGetLinkState @520
	NicGetStats @521
	NicGetOpt @522
	NicSetOpt @523
	DrvSetSysReqCallback @524
	DrvSetUserBindingCallback @525
	DrvSetContentStorageCallback @526
	DrvSetAutobind @527
	DrvGetContentStorageNotification @528
	MtpdBeginTransaction @529
	MtpdCancelTransaction @530
	MtpdEndTransaction @531
	MtpdGetCurrentDevices @532
	MtpdReadData @533
	MtpdReadEvent @534
	MtpdResetDevice @535
	MtpdSendData @536
	MtpdVerifyProximity @537
	XUsbcamSetCaptureMode @538
	XUsbcamGetConfig @539
	XUsbcamSetConfig @540
	XUsbcamGetState @541
	XUsbcamReadFrame @542
	XUsbcamSnapshot @543
	XUsbcamSetView @544
	XUsbcamGetView @545
	XUsbcamCreate @546
	XUsbcamDestroy @547
	XMACreateContext @548
	XMAInitializeContext @549
	XMAReleaseContext @550
	XMAEnableContext @551
	XMADisableContext @552
	XMAGetOutputBufferWriteOffset @553
	XMASetOutputBufferReadOffset @554
	XMAGetOutputBufferReadOffset @555
	XMASetOutputBufferValid @556
	XMAIsOutputBufferValid @557
	XMASetInputBuffer0Valid @558
	XMAIsInputBuffer0Valid @559
	XMASetInputBuffer1Valid @560
	XMAIsInputBuffer1Valid @561
	XMASetInputBuffer0 @562
	XMASetInputBuffer1 @563
	XMAGetPacketMetadata @564
	XMABlockWhileInUse @565
	XMASetLoopData @566
	XMASetInputBufferReadOffset @567
	XMAGetInputBufferReadOffset @568
	ExIsBetaFeatureEnabled @569
	XeKeysGetFactoryChallenge @570
	XeKeysSetFactoryResponse @571
	XeKeysInitializeFuses @572
	XeKeysSaveBootLoader @573
	XeKeysSaveKeyVault @574
	XeKeysGetStatus @575
	XeKeysGeneratePrivateKey @576
	XeKeysGetKeyProperties @577
	XeKeysSetKey @578
	XeKeysGenerateRandomKey @579
	XeKeysGetKey @580
	XeKeysGetDigest @581
	XeKeysGetConsoleID @582
	XeKeysGetConsoleType @583
	XeKeysQwNeRsaPrvCrypt @584
	XeKeysHmacSha @585
	XInputdPassThroughRFCommand @586
	XeKeysAesCbc @587
	XeKeysDes2Cbc @588
	XeKeysDesCbc @589
	XeKeysObscureKey @590
	XeKeysHmacShaUsingKey @591
	XeKeysSaveBootLoaderEx @592
	XeKeysAesCbcUsingKey @593
	XeKeysDes2CbcUsingKey @594
	XeKeysDesCbcUsingKey @595
	XeKeysObfuscate @596
	XeKeysUnObfuscate @597
	XeKeysConsolePrivateKeySign @598
	XeKeysConsoleSignatureVerification @599
	XeKeysVerifyRSASignature @600
	StfsCreateDevice @601
	StfsControlDevice @602
	VdSwap @603
	HalFsbInterruptCount @604
	XeKeysSaveSystemUpdate @605
	XeKeysLockSystemUpdate @606
	XeKeysExecute @607
	XeKeysGetVersions @608
	XInputdPowerDownDevice @609
	AniBlockOnAnimation @610
	AniTerminateAnimation @611
	XUsbcamReset @612
	AniSetLogo @613
	KeCertMonitorData @614
	HalIsExecutingPowerDownDpc @615
	VdInitializeEDRAM @616
	VdRetrainEDRAM @617
	VdRetrainEDRAMWorker @618
	VdHSIOTrainCount @619
	HalGetPowerUpCause @620
	VdHSIOTrainingStatus @621
	RgcBindInfo @622
	VdReadEEDIDBlock @623
	VdEnumerateVideoModes @624
	VdEnableHDCP @625
	VdRegisterHDCPNotification @626
	HidReadMouseChanges @627
	DumpSetCollectionFacility @628
	XexTransformImageKey @629
	XAudioOverrideSpeakerConfig @630
	XInputdReadTextKeystroke @631
	DrvXenonButtonPressed @632
	DrvBindToUser @633
	XexGetModuleImportVersions @634
	RtlComputeCrc32 @635
	XeKeysSetRevocationList @636
	HalRegisterPowerDownCallback @637
	VdGetDisplayDiscoveryData @638
	XInputdSendStayAliveRequest @639
	XVoicedSendVPort @640
	XVoicedGetBatteryStatus @641
	XInputdFFGetDeviceInfo @642
	XInputdFFSetEffect @643
	XInputdFFUpdateEffect @644
	XInputdFFEffectOperation @645
	XInputdFFDeviceControl @646
	XInputdFFSetDeviceGain @647
	XInputdFFCancelIo @648
	XInputdFFSetRumble @649
	NtAllocateEncryptedMemory @650
	NtFreeEncryptedMemory @651
	XeKeysExSaveKeyVault @652
	XeKeysExSetKey @653
	XeKeysExGetKey @654
	DrvSetDeviceConfigChangeCallback @655
	DrvDeviceConfigChange @656
	HalRegisterHdDvdRomNotification @657
	XeKeysSecurityInitialize @658
	XeKeysSecurityLoadSettings @659
	XeKeysSecuritySaveSettings @660
	XeKeysSecuritySetDetected @661
	XeKeysSecurityGetDetected @662
	XeKeysSecuritySetActivated @663
	XeKeysSecurityGetActivated @664
	XeKeysGetProtectedFlag @667
	XeKeysSetProtectedFlag @668
	KeEnablePFMInterrupt @669
	KeDisablePFMInterrupt @670
	KeSetProfilerISR @671
	VdStartDisplayDiscovery @672
	VdSetHDCPRevocationList @673
	XeKeysGetUpdateSequence @674
	XeKeysDvdAuthExActivate @675
	KeGetImagePageTableEntry @676
	HalRegisterBackgroundModeTransitionCallback @677
	AniStartBootAnimation @678
	HalClampUnclampOutputDACs @679
	HalPowerDownToBackgroundMode @680
	HalNotifyAddRemoveBackgroundTask @681
	HalCallBackgroundModeNotificationRoutines @682
	HalFsbResetCount @683
	HalGetMemoryInformation @684
	XInputdGetLastTextInputTime @685
	VdEnableWMAProOverHDMI @686
	XeKeysRevokeSaveSettings @687
	XInputdSetTextMessengerIndicator @688
	MicDeviceRequest @689
	XeKeysGetMediaID @690
	KeGetVidInfo @692
	HalNotifyBackgroundModeTransitionComplete @693
	IoAcquireCancelSpinLock @694
	IoReleaseCancelSpinLock @695
	NtCancelIoFile @696
	NtCancelIoFileEx @697
	HalFinalizePowerLossRecovery @698
	HalSetPowerLossRecovery @699
	ExReadModifyWriteXConfigSettingUlong @700
	HalRegisterXamPowerDownCallback @701
	ExCancelAlarm @702
	ExInitializeAlarm @703
	ExSetAlarm @704
	XexActivationGetNonce @705
	XexActivationSetLicense @706
	IptvSetBoundaryKey @707
	IptvSetSessionKey @708
	IptvVerifyOmac1Signature @709
	IptvGetAesCtrTransform @710
	SataCdRomRecordReset @711
	XInputdSetTextDeviceKeyLocks @712
	XInputdGetTextDeviceKeyLocks @713
	XexActivationVerifyOwnership @714
	XexDisableVerboseDbgPrint @715
	SvodCreateDevice @716
	RtlCaptureStackBackTrace @717
	XeKeysRevokeUpdateDynamic @718
	XexImportTraceEnable @719
	ExRegisterXConfigNotification @720
	XeKeysSecuritySetStat @721
	VdQueryRealVideoMode @722
	XexSetExecutablePrivilege @723
	XAudioSuspendRenderDriverClients @724
	IptvGetSessionKeyHash @725
	VdSetCGMSState @726
	VdSetSCMSState @727
	KeFlushMultipleTb @728
	VdGetOption @729
	VdSetOption @730
	UsbdBootEnumerationDoneEvent @731
	StfsDeviceErrorEvent @732
	ExTryToAcquireReadWriteLockExclusive @733
	ExTryToAcquireReadWriteLockShared @734
	XexSetLastKdcTime @735
	XInputdControl @736
	RmcDeviceRequest @737
	LDIResetDecompression @738
	NicRegisterDevice @739
	UsbdAddDeviceComplete @740
	UsbdCancelAsyncTransfer @741
	UsbdGetDeviceSpeed @742
	UsbdGetDeviceTopology @743
	UsbdGetEndpointDescriptor @744
	UsbdIsDeviceAuthenticated @745
	UsbdOpenDefaultEndpoint @746
	UsbdOpenEndpoint @747
	UsbdQueueAsyncTransfer @748
	UsbdQueueCloseDefaultEndpoint @749
	UsbdQueueCloseEndpoint @750
	UsbdRemoveDeviceComplete @751
	KeRemoveQueueApc @752
	UsbdDriverLoadRequiredEvent @753
	UsbdGetRequiredDrivers @754
	UsbdRegisterDriverObject @755
	UsbdUnregisterDriverObject @756
	UsbdResetDevice @758
	UsbdGetDeviceDescriptor @759
	NomnilGetExtension @760
	NomnilStartCloseDevice @761
	WifiBeginAuthentication @762
	WifiCheckCounterMeasures @763
	WifiChooseAuthenCipherSetFromBSSID @764
	WifiCompleteAuthentication @765
	WifiGetAssociationIE @766
	WifiOnMICError @767
	WifiPrepareAuthenticationContext @768
	WifiRecvEAPOLPacket @769
	WifiDeduceNetworkType @770
	NicUnregisterDevice @771
	DumpXitThread @772
	XInputdSetWifiChannel @773
	NomnilSetLed @774
	WifiCalculateRegulatoryDomain @775
	WifiSelectAdHocChannel @776
	WifiChannelToFrequency @777
	MmGetPoolPagesType @778
	ExExpansionInstall @779
	ExExpansionCall @780
	PsCamDeviceRequest @781
	McaDeviceRequest @782
	DetroitDeviceRequest @783
	XeCryptSha256Init @784
	XeCryptSha256Update @785
	XeCryptSha256Final @786
	XeCryptSha256 @787
	XeCryptSha384Init @788
	XeCryptSha384Update @789
	XInputdGetDevicePid @790
	HalGetNotedArgonErrors @791
	XeCryptSha384Final @792
	HalReadArgonEeprom @793
	HalWriteArgonEeprom @794
	XeKeysFcrtLoad @795
	XeKeysFcrtSave @796
	XeKeysFcrtSet @797
	XeCryptSha384 @798
	XeCryptSha512Init @799
	XAudioRegisterRenderDriverMECClient @800
	XAudioUnregisterRenderDriverMECClient @801
	XAudioCaptureRenderDriverFrame @802
	XeCryptSha512Update @803
	XeCryptSha512Final @804
	XeCryptSha512 @805
	XeCryptBnQwNeCompare @806
	XVoicedGetDirectionalData @807
	DrvSetMicArrayStartCallback @808
	DevAuthGetStatistics @809
	NullCableRequest @810
	XeKeysRevokeIsDeviceRevoked @811
	DumpUpdateDumpSettings @812
	EtxConsumerDisableEventType @813
	EtxConsumerEnableEventType @814
	EtxConsumerProcessLogs @815
	EtxConsumerRegister @816
	EtxConsumerUnregister @817
	EtxProducerLog @818
	EtxProducerLogV @819
	EtxProducerRegister @820
	EtxProducerUnregister @821
	EtxConsumerFlushBuffers @822
	EtxProducerLogXwpp @823
	EtxProducerLogXwppV @824
	UsbdEnableDisableRootHubPort @825
	EtxBufferRegister @826
	EtxBufferUnregister @827
	DumpRegisterDedicatedDataBlock @828
	XeKeysDvdAuthExSave @829
	XeKeysDvdAuthExInstall @830
	XexShimDisable @831
	XexShimEnable @832
	XexShimEntryDisable @833
	XexShimEntryEnable @834
	XexShimEntryRegister @835
	XexShimLock @836
	XboxKrnlVersion4Digit @837
	XeKeysObfuscateEx @838
	XeKeysUnObfuscateEx @839
	XexTitleHash @840
	XexTitleHashClose @841
	XexTitleHashContinue @842
	XexTitleHashOpen @843
	XAudioGetRenderDriverTic @844
	XAudioEnableDucker @845
	XAudioSetDuckerLevel @846
	XAudioIsDuckerEnabled @847
	XAudioGetDuckerLevel @848
	XAudioGetDuckerThreshold @849
	XAudioSetDuckerThreshold @850
	XAudioGetDuckerAttackTime @851
	XAudioSetDuckerAttackTime @852
	XAudioGetDuckerReleaseTime @853
	XAudioSetDuckerReleaseTime @854
	XAudioGetDuckerHoldTime @855
	XAudioSetDuckerHoldTime @856
	DevAuthShouldAlwaysEnforce @857
	XAudioGetUnderrunCount @858
	DrvSetAudioLatencyCallback @859
	XVoicedIsActiveProcess @860
	KeExecuteOnProtectedStack @861
	XeKeysVerifyPIRSSignature @862
	XeCryptAesCtr @863
	XeCryptAesCbcMac @864
	XeCryptAesDmMac @865
	EmaExecute @866
	XeKeysGetTruncatedSecondaryConsoleId @867
	ExFreeDebugPool @868
	VdQueryVideoCapabilities @869
	UsbdGetDeviceRootPortType @870
	VdGet3dVideoFormat @871
	VdGetWSS2Data @872
	VdSet3dVideoFormat @873
	VdSetWSS2Data @874
	XexReserveCodeBuffer @875
	XexCommitCodeBuffer @876
	RtlSetVectoredExceptionHandler @877
	RtlClearVectoredExceptionHandler @878
	XAudioSetProcessFrameCallback @879
	UsbdGetRootHubDeviceNode @880
	UsbdGetPortDeviceNode @881
	UsbdGetNatalHub @882
	UsbdGetNatalHardwareVersion @883
	UsbdNatalHubRegisterNotificationCallback @884
	KeCallAndBlockOnDpcRoutine @885
	KeCallAndWaitForDpcRoutine @886
	TidDeviceRequest @887
	DmPrintData @888
	VdSetStudioRGBMode @889


```

`XenonDumper/libs/xkelib/kernel/kernelext21173.0.def`:

```def
LIBRARY xboxkrnl.exe@21173.0+1861.0
EXPORTS
;	DbgBreakPoint @1
;	DbgBreakPointWithStatus @2
;	DbgPrint @3
;	DbgPrompt @4
;	DumpGetRawDumpInfo @5
;	DumpWriteDump @6
;	ExAcquireReadWriteLockExclusive @7
;	ExAcquireReadWriteLockShared @8
;	ExAllocatePool @9
;	ExAllocatePoolWithTag @10
;	ExAllocatePoolTypeWithTag @11
;	ExConsoleGameRegion @12
;	ExCreateThread @13
;	ExEventObjectType @14
;	ExFreePool @15
;	ExGetXConfigSetting @16
;	ExInitializeReadWriteLock @17
;	ExMutantObjectType @18
;	ExQueryPoolBlockSize @19
;	ExRegisterThreadNotification @20
;	ExRegisterTitleTerminateNotification @21
;	ExReleaseReadWriteLock @22
;	ExSemaphoreObjectType @23
;	ExSetXConfigSetting @24
;	ExTerminateThread @25
;	ExTerminateTitleProcess @26
;	ExThreadObjectType @27
;	ExTimerObjectType @28
;	MmDoubleMapMemory @29
;	MmUnmapMemory @30
;	XeKeysGetConsoleCertificate @31
;	FscGetCacheElementCount @32
;	FscSetCacheElementCount @33
;	HalGetCurrentAVPack @34
;	HalGpioControl @35
;	HalOpenCloseODDTray @36
;	HalReadWritePCISpace @37
;	HalRegisterPowerDownNotification @38
;	HalRegisterSMCNotification @39
;	HalReturnToFirmware @40
;	HalSendSMCMessage @41
;	HalSetAudioEnable @42
;	InterlockedFlushSList @43
;	InterlockedPopEntrySList @44
	InterlockedPushEntrySList @45
;	IoAcquireDeviceObjectLock @46
;	IoAllocateIrp @47
;	IoBuildAsynchronousFsdRequest @48
;	IoBuildDeviceIoControlRequest @49
;	IoBuildSynchronousFsdRequest @50
;	IoCallDriver @51
;	IoCheckShareAccess @52
;	IoCompleteRequest @53
;	IoCompletionObjectType @54
;	IoCreateDevice @55
;	IoCreateFile @56
;	IoDeleteDevice @57
;	IoDeviceObjectType @58
;	IoDismountVolume @59
;	IoDismountVolumeByFileHandle @60
;	IoDismountVolumeByName @61
;	IoFileObjectType @62
;	IoFreeIrp @63
;	IoInitializeIrp @64
;	IoInvalidDeviceRequest @65
;	ExSetBetaFeaturesEnabled @66
;	IoQueueThreadIrp @67
;	IoReleaseDeviceObjectLock @68
;	IoRemoveShareAccess @69
;	IoSetIoCompletion @70
;	IoSetShareAccess @71
;	IoStartNextPacket @72
;	IoStartNextPacketByKey @73
;	IoStartPacket @74
;	IoSynchronousDeviceIoControlRequest @75
;	IoSynchronousFsdRequest @76
;	KeAcquireSpinLockAtRaisedIrql @77
;	KeAlertResumeThread @78
;	KeAlertThread @79
;	KeBlowFuses @80
;	KeBoostPriorityThread @81
;	KeBugCheck @82
;	KeBugCheckEx @83
;	KeCancelTimer @84
;	KeConnectInterrupt @85
;	KeContextFromKframes @86
;	KeContextToKframes @87
;	KeCreateUserMode @88
;	KeDebugMonitorData @89
;	KeDelayExecutionThread @90
;	KeDeleteUserMode @91
;	KeDisconnectInterrupt @92
;	KeEnableFpuExceptions @93
;	KeEnablePPUPerformanceMonitor @94
;	KeEnterCriticalRegion @95
;	KeEnterUserMode @96
;	KeFlushCacheRange @97
;	KeFlushCurrentEntireTb @98
;	KeFlushEntireTb @99
;	KeFlushUserModeCurrentTb @100
;	KeFlushUserModeTb @101
;	KeGetCurrentProcessType @102
;	KeGetPMWRegister @103
;	KeGetPRVRegister @104
;	KeGetSocRegister @105
;	KeGetSpecialPurposeRegister @106
;	KeLockL2 @107
;	KeUnlockL2 @108
;	KeInitializeApc @109
;	KeInitializeDeviceQueue @110
;	KeInitializeDpc @111
;	KeInitializeEvent @112
;	KeInitializeInterrupt @113
;	KeInitializeMutant @114
;	KeInitializeQueue @115
;	KeInitializeSemaphore @116
;	KeInitializeTimerEx @117
;	KeInsertByKeyDeviceQueue @118
;	KeInsertDeviceQueue @119
;	KeInsertHeadQueue @120
;	KeInsertQueue @121
;	KeInsertQueueApc @122
;	KeInsertQueueDpc @123
;	KeIpiGenericCall @124
;	KeLeaveCriticalRegion @125
;	KeLeaveUserMode @126
;	KePulseEvent @127
;	KeQueryBackgroundProcessors @128
;	KeQueryBasePriorityThread @129
;	KeQueryInterruptTime @130
;	KeQueryPerformanceFrequency @131
;	KeQuerySystemTime @132
;	KeRaiseIrqlToDpcLevel @133
;	KeRegisterDriverNotification @134
;	KeReleaseMutant @135
;	KeReleaseSemaphore @136
;	KeReleaseSpinLockFromRaisedIrql @137
;	KeRemoveByKeyDeviceQueue @138
;	KeRemoveDeviceQueue @139
;	KeRemoveEntryDeviceQueue @140
;	KeRemoveQueue @141
;	KeRemoveQueueDpc @142
;	KeResetEvent @143
;	KeRestoreFloatingPointState @144
;	KeRestoreVectorUnitState @145
;	KeResumeThread @146
;	KeRetireDpcList @147
;	KeRundownQueue @148
;	KeSaveFloatingPointState @149
;	KeSaveVectorUnitState @150
;	KeSetAffinityThread @151
;	KeSetBackgroundProcessors @152
;	KeSetBasePriorityThread @153
;	KeSetCurrentProcessType @154
;	KeSetCurrentStackPointers @155
;	KeSetDisableBoostThread @156
;	KeSetEvent @157
;	KeSetEventBoostPriority @158
;	KeSetPMWRegister @159
;	KeSetPowerMode @160
;	KeSetPRVRegister @161
;	KeSetPriorityClassThread @162
;	KeSetPriorityThread @163
;	KeSetSocRegister @164
;	KeSetSpecialPurposeRegister @165
;	KeSetTimer @166
;	KeSetTimerEx @167
;	KeStallExecutionProcessor @168
;	KeSuspendThread @169
;	KeSweepDcacheRange @170
;	KeSweepIcacheRange @171
;	KeTestAlertThread @172
;	KeTimeStampBundle @173
;	KeTryToAcquireSpinLockAtRaisedIrql @174
;	KeWaitForMultipleObjects @175
;	KeWaitForSingleObject @176
;	KfAcquireSpinLock @177
;	KfRaiseIrql @178
;	KfLowerIrql @179
;	KfReleaseSpinLock @180
;	KiBugCheckData @181
;	LDICreateDecompression @182
;	LDIDecompress @183
;	LDIDestroyDecompression @184
;	MmAllocatePhysicalMemory @185
;	MmAllocatePhysicalMemoryEx @186
;	MmCreateKernelStack @187
;	MmDeleteKernelStack @188
;	MmFreePhysicalMemory @189
;	MmGetPhysicalAddress @190
;	MmIsAddressValid @191
;	MmLockAndMapSegmentArray @192
;	MmLockUnlockBufferPages @193
;	MmMapIoSpace @194
;	MmPersistPhysicalMemoryAllocation @195
;	MmQueryAddressProtect @196
;	MmQueryAllocationSize @197
;	MmQueryStatistics @198
;	MmSetAddressProtect @199
;	MmSplitPhysicalMemoryAllocation @200
;	MmUnlockAndUnmapSegmentArray @201
;	MmUnmapIoSpace @202
;	Nls844UnicodeCaseTable @203
;	NtAllocateVirtualMemory @204
;	NtCancelTimer @205
;	NtClearEvent @206
;	NtClose @207
;	NtCreateDirectoryObject @208
;	NtCreateEvent @209
;	NtCreateFile @210
;	NtCreateIoCompletion @211
;	NtCreateMutant @212
;	NtCreateSemaphore @213
;	NtCreateSymbolicLinkObject @214
;	NtCreateTimer @215
;	NtDeleteFile @216
;	NtDeviceIoControlFile @217
;	NtDuplicateObject @218
;	NtFlushBuffersFile @219
;	NtFreeVirtualMemory @220
;	NtMakeTemporaryObject @221
;	NtOpenDirectoryObject @222
;	NtOpenFile @223
;	NtOpenSymbolicLinkObject @224
;	NtProtectVirtualMemory @225
;	NtPulseEvent @226
;	NtQueueApcThread @227
;	NtQueryDirectoryFile @228
;	NtQueryDirectoryObject @229
;	NtQueryEvent @230
;	NtQueryFullAttributesFile @231
;	NtQueryInformationFile @232
;	NtQueryIoCompletion @233
;	NtQueryMutant @234
;	NtQuerySemaphore @235
;	NtQuerySymbolicLinkObject @236
;	NtQueryTimer @237
;	NtQueryVirtualMemory @238
;	NtQueryVolumeInformationFile @239
;	NtReadFile @240
;	NtReadFileScatter @241
;	NtReleaseMutant @242
;	NtReleaseSemaphore @243
;	NtRemoveIoCompletion @244
;	NtResumeThread @245
;	NtSetEvent @246
;	NtSetInformationFile @247
;	NtSetIoCompletion @248
;	NtSetSystemTime @249
;	NtSetTimerEx @250
;	NtSignalAndWaitForSingleObjectEx @251
;	NtSuspendThread @252
;	NtWaitForSingleObjectEx @253
;	NtWaitForMultipleObjectsEx @254
;	NtWriteFile @255
;	NtWriteFileGather @256
;	NtYieldExecution @257
;	ObCreateObject @258
;	ObCreateSymbolicLink @259
;	ObDeleteSymbolicLink @260
;	ObDereferenceObject @261
;	ObDirectoryObjectType @262
;	ObGetWaitableObject @263
;	ObInsertObject @264
;	ObIsTitleObject @265
;	ObLookupAnyThreadByThreadId @266
;	ObLookupThreadByThreadId @267
;	ObMakeTemporaryObject @268
;	ObOpenObjectByName @269
;	ObOpenObjectByPointer @270
;	ObReferenceObject @271
;	ObReferenceObjectByHandle @272
;	ObReferenceObjectByName @273
;	ObSymbolicLinkObjectType @274
;	ObTranslateSymbolicLink @275
;	RtlAnsiStringToUnicodeString @276
;	RtlAppendStringToString @277
;	RtlAppendUnicodeStringToString @278
;	RtlAppendUnicodeToString @279
;	RtlAssert @280
;	RtlCaptureContext @281
;	RtlCompareMemory @282
;	RtlCompareMemoryUlong @283
;	RtlCompareString @284
;	RtlCompareStringN @285
;	RtlCompareUnicodeString @286
;	RtlCompareUnicodeStringN @287
;	RtlCompareUtf8ToUnicode @288
;	RtlCopyString @289
;	RtlCopyUnicodeString @290
;	RtlCreateUnicodeString @291
;	RtlDowncaseUnicodeChar @292
;	RtlEnterCriticalSection @293
;	RtlFillMemoryUlong @294
;	RtlFreeAnsiString @295
	RtlFreeAnsiString2 @296
;	RtlGetCallersAddress @297
;	RtlGetStackLimits @298
;	RtlImageXexHeaderField @299
;	RtlInitAnsiString @300
;	RtlInitUnicodeString @301
;	RtlInitializeCriticalSection @302
;	RtlInitializeCriticalSectionAndSpinCount @303
;	RtlLeaveCriticalSection @304
;	RtlLookupFunctionEntry @305
;	RtlLowerChar @306
;	RtlMultiByteToUnicodeN @307
;	RtlMultiByteToUnicodeSize @308
;	RtlNtStatusToDosError @309
;	RtlRaiseException @310
;	RtlRaiseStatus @311
;	RtlRip @312
	_scprintf @313
	_snprintf @314
;	RtlSprintf @315
	_scwprintf @316
	_snwprintf @317
	_swprintf @318
;	RtlTimeFieldsToTime @319
;	RtlTimeToTimeFields @320
;	RtlTryEnterCriticalSection @321
;	RtlUnicodeStringToAnsiString @322
;	RtlUnicodeToMultiByteN @323
;	RtlUnicodeToMultiByteSize @324
;	RtlUnicodeToUtf8 @325
;	RtlUnicodeToUtf8Size @326
;	RtlUnwind @327
;	RtlUnwind2 @328
;	RtlUpcaseUnicodeChar @329
;	RtlUpperChar @330
;	RtlVirtualUnwind @331
;	_vscprintf @332
	_vsnprintf @333
;	vsprintf @334
;	_vscwprintf @335
	_vsnwprintf @336
	_vswprintf @337
	KeTlsAlloc @338
	KeTlsFree @339
	KeTlsGetValue @340
	KeTlsSetValue @341
;	XboxHardwareInfo @342
;	XboxKrnlBaseVersion @343
;	XboxKrnlVersion @344
;	XeCryptAesKey @345
;	XeCryptAesEcb @346
;	XeCryptAesCbc @347
;	XeCryptBnDwLeDhEqualBase @348
;	XeCryptBnDwLeDhInvalBase @349
;	XeCryptBnDwLeDhModExp @350
;	XeCryptBnDw_Copy @351
;	XeCryptBnDw_SwapLeBe @352
;	XeCryptBnDw_Zero @353
;	XeCryptBnDwLePkcs1Format @354
;	XeCryptBnDwLePkcs1Verify @355
;	XeCryptBnQwBeSigCreate @356
;	XeCryptBnQwBeSigFormat @357
;	XeCryptBnQwBeSigVerify @358
;	XeCryptBnQwNeModExp @359
;	XeCryptBnQwNeModExpRoot @360
;	XeCryptBnQwNeModInv @361
;	XeCryptBnQwNeModMul @362
;	XeCryptBnQwNeRsaKeyGen @363
;	XeCryptBnQwNeRsaPrvCrypt @364
;	XeCryptBnQwNeRsaPubCrypt @365
;	XeCryptBnQw_Copy @366
;	XeCryptBnQw_SwapDwQw @367
;	XeCryptBnQw_SwapDwQwLeBe @368
;	XeCryptBnQw_SwapLeBe @369
;	XeCryptBnQw_Zero @370
;	XeCryptChainAndSumMac @371
;	XeCryptDesParity @372
;	XeCryptDesKey @373
;	XeCryptDesEcb @374
;	XeCryptDesCbc @375
;	XeCryptDes3Key @376
;	XeCryptDes3Ecb @377
;	XeCryptDes3Cbc @378
;	XeCryptHmacMd5Init @379
;	XeCryptHmacMd5Update @380
;	XeCryptHmacMd5Final @381
;	XeCryptHmacMd5 @382
;	XeCryptHmacShaInit @383
;	XeCryptHmacShaUpdate @384
;	XeCryptHmacShaFinal @385
;	XeCryptHmacSha @386
;	XeCryptHmacShaVerify @387
;	XeCryptMd5Init @388
;	XeCryptMd5Update @389
;	XeCryptMd5Final @390
;	XeCryptMd5 @391
;	XeCryptParveEcb @392
;	XeCryptParveCbcMac @393
;	XeCryptRandom @394
;	XeCryptRc4Key @395
;	XeCryptRc4Ecb @396
;	XeCryptRc4 @397
;	XeCryptRotSumSha @398
;	XeCryptShaInit @399
;	XeCryptShaUpdate @400
;	XeCryptShaFinal @401
;	XeCryptSha @402
;	XexExecutableModuleHandle @403
;	XexCheckExecutablePrivilege @404
;	XexGetModuleHandle @405
;	XexGetModuleSection @406
;	XexGetProcedureAddress @407
;	XexLoadExecutable @408
;	XexLoadImage @409
;	XexLoadImageFromMemory @410
;	XexLoadImageHeaders @411
;	XexPcToFileHeader @412
;	KiApcNormalRoutineNop @413
;	XexRegisterPatchDescriptor @414
;	XexSendDeferredNotifications @415
;	XexStartExecutable @416
;	XexUnloadImage @417
;	XexUnloadImageAndExitThread @418
;	XexUnloadTitleModules @419
;	XexVerifyImageHeaders @420
;	__C_specific_handler @421
;	DbgLoadImageSymbols @422
;	DbgUnLoadImageSymbols @423
;	RtlImageDirectoryEntryToData @424
;	RtlImageNtHeader @425
;	ExDebugMonitorService @426
;	MmDbgReadCheck @427
;	MmDbgReleaseAddress @428
;	MmDbgWriteCheck @429
;	ExLoadedCommandLine @430
;	ExLoadedImageName @431
;	VdBlockUntilGUIIdle @432
;	VdCallGraphicsNotificationRoutines @433
;	VdDisplayFatalError @434
;	VdEnableClosedCaption @435
;	VdEnableDisableClockGating @436
;	VdEnableDisablePowerSavingMode @437
;	VdEnableRingBufferRPtrWriteBack @438
;	VdGenerateGPUCSCCoefficients @439
;	VdGetClosedCaptionReadyStatus @440
;	VdGetCurrentDisplayGamma @441
;	VdGetCurrentDisplayInformation @442
;	VdGetDisplayModeOverride @443
;	VdGetGraphicsAsicID @444
;	VdGetSystemCommandBuffer @445
;	VdGlobalDevice @446
;	VdGlobalXamDevice @447
;	VdGpuClockInMHz @448
;	VdHSIOCalibrationLock @449
;	VdInitializeEngines @450
;	VdInitializeRingBuffer @451
;	VdInitializeScaler @452
;	VdInitializeScalerCommandBuffer @453
;	VdIsHSIOTrainingSucceeded @454
;	VdPersistDisplay @455
;	VdQuerySystemCommandBuffer @456
;	VdQueryVideoFlags @457
;	VdQueryVideoMode @458
;	VdReadDVERegisterUlong @459
;	VdReadWriteHSIOCalibrationFlag @460
;	VdRegisterGraphicsNotification @461
;	VdRegisterXamGraphicsNotification @462
;	VdSendClosedCaptionData @463
;	VdSetCGMSOption @464
;	VdSetColorProfileAdjustment @465
;	VdSetCscMatricesOverride @466
;	VdSetDisplayMode @467
;	VdSetDisplayModeOverride @468
;	VdSetGraphicsInterruptCallback @469
	VdSetHDCPOption @470
;	VdSetMacrovisionOption @471
;	VdSetSystemCommandBuffer @472
;	VdSetSystemCommandBufferGpuIdentifierAddress @473
;	VdSetWSSData @474
;	VdSetWSSOption @475
;	VdShutdownEngines @476
;	VdTurnDisplayOff @477
;	VdTurnDisplayOn @478
;	KiApcNormalRoutineNop @479
;	VdWriteDVERegisterUlong @480
;	XVoicedHeadsetPresent @481
;	XVoicedSubmitPacket @482
;	XVoicedClose @483
;	XVoicedActivate @484
;	XInputdGetCapabilities @485
;	XInputdReadState @486
;	XInputdWriteState @487
;	XInputdNotify @488
;	XInputdRawState @489
;	HidGetCapabilities @490
;	HidReadKeys @491
;	XInputdGetDeviceStats @492
;	XInputdResetDevice @493
;	XInputdSetRingOfLight @494
;	XInputdSetRFPowerMode @495
;	XInputdSetRadioFrequency @496
;	HidGetLastInputTime @497
;	XAudioRenderDriverInitialize @498
;	XAudioRegisterRenderDriverClient @499
;	XAudioUnregisterRenderDriverClient @500
;	XAudioSubmitRenderDriverFrame @501
;	XAudioRenderDriverLock @502
;	XAudioGetVoiceCategoryVolumeChangeMask @503
;	XAudioGetVoiceCategoryVolume @504
;	XAudioSetVoiceCategoryVolume @505
;	XAudioBeginDigitalBypassMode @506
;	XAudioEndDigitalBypassMode @507
;	XAudioSubmitDigitalPacket @508
;	XAudioQueryDriverPerformance @509
;	XAudioGetRenderDriverThread @510
;	XAudioGetSpeakerConfig @511
;	XAudioSetSpeakerConfig @512
;	NicSetUnicastAddress @513
;	NicAttach @514
;	NicDetach @515
;	NicXmit @516
;	NicUpdateMcastMembership @517
;	NicFlushXmitQueue @518
;	NicShutdown @519
;	NicGetLinkState @520
;	NicGetStats @521
;	NicGetOpt @522
;	NicSetOpt @523
;	DrvSetSysReqCallback @524
;	DrvSetUserBindingCallback @525
;	DrvSetContentStorageCallback @526
;	DrvSetAutobind @527
;	DrvGetContentStorageNotification @528
;	MtpdBeginTransaction @529
;	MtpdCancelTransaction @530
;	MtpdEndTransaction @531
;	MtpdGetCurrentDevices @532
;	MtpdReadData @533
;	MtpdReadEvent @534
;	MtpdResetDevice @535
;	MtpdSendData @536
;	MtpdVerifyProximity @537
;	XUsbcamSetCaptureMode @538
;	XUsbcamGetConfig @539
;	XUsbcamSetConfig @540
;	XUsbcamGetState @541
;	XUsbcamReadFrame @542
;	XUsbcamSnapshot @543
;	XUsbcamSetView @544
;	XUsbcamGetView @545
;	XUsbcamCreate @546
;	XUsbcamDestroy @547
;	XMACreateContext @548
;	XMAInitializeContext @549
;	XMAReleaseContext @550
;	XMAEnableContext @551
;	XMADisableContext @552
;	XMAGetOutputBufferWriteOffset @553
;	XMASetOutputBufferReadOffset @554
;	XMAGetOutputBufferReadOffset @555
;	XMASetOutputBufferValid @556
;	XMAIsOutputBufferValid @557
;	XMASetInputBuffer0Valid @558
;	XMAIsInputBuffer0Valid @559
;	XMASetInputBuffer1Valid @560
;	XMAIsInputBuffer1Valid @561
;	XMASetInputBuffer0 @562
;	XMASetInputBuffer1 @563
;	XMAGetPacketMetadata @564
;	XMABlockWhileInUse @565
;	XMASetLoopData @566
;	XMASetInputBufferReadOffset @567
;	XMAGetInputBufferReadOffset @568
;	ExIsBetaFeatureEnabled @569
;	XeKeysGetFactoryChallenge @570
;	XeKeysSetFactoryResponse @571
;	XeKeysInitializeFuses @572
;	XeKeysSaveBootLoader @573
;	XeKeysSaveKeyVault @574
;	XeKeysGetStatus @575
;	XeKeysGeneratePrivateKey @576
;	XeKeysGetKeyProperties @577
;	XeKeysSetKey @578
;	XeKeysGenerateRandomKey @579
;	XeKeysGetKey @580
;	XeKeysGetDigest @581
;	XeKeysGetConsoleID @582
;	XeKeysGetConsoleType @583
;	XeKeysQwNeRsaPrvCrypt @584
;	XeKeysHmacSha @585
;	XInputdPassThroughRFCommand @586
;	XeKeysAesCbc @587
;	XeKeysDes2Cbc @588
;	XeKeysDesCbc @589
;	XeKeysObscureKey @590
;	XeKeysHmacShaUsingKey @591
;	XeKeysSaveBootLoaderEx @592
;	XeKeysAesCbcUsingKey @593
;	XeKeysDes2CbcUsingKey @594
;	XeKeysDesCbcUsingKey @595
;	XeKeysObfuscate @596
;	XeKeysUnObfuscate @597
;	XeKeysConsolePrivateKeySign @598
;	XeKeysConsoleSignatureVerification @599
;	XeKeysVerifyRSASignature @600
;	StfsCreateDevice @601
;	StfsControlDevice @602
;	VdSwap @603
;	HalFsbInterruptCount @604
;	XeKeysSaveSystemUpdate @605
;	XeKeysLockSystemUpdate @606
;	XeKeysExecute @607
;	XeKeysGetVersions @608
;	XInputdPowerDownDevice @609
;	AniBlockOnAnimation @610
;	AniTerminateAnimation @611
;	XUsbcamReset @612
;	AniSetLogo @613
;	KeCertMonitorData @614
;	HalIsExecutingPowerDownDpc @615
;	VdInitializeEDRAM @616
;	VdRetrainEDRAM @617
;	VdRetrainEDRAMWorker @618
;	VdHSIOTrainCount @619
;	HalGetPowerUpCause @620
;	VdHSIOTrainingStatus @621
;	RgcBindInfo @622
;	VdReadEEDIDBlock @623
;	VdEnumerateVideoModes @624
;	VdEnableHDCP @625
;	VdRegisterHDCPNotification @626
;	HidReadMouseChanges @627
;	DumpSetCollectionFacility @628
;	XexTransformImageKey @629
;	XAudioOverrideSpeakerConfig @630
;	XInputdReadTextKeystroke @631
;	DrvXenonButtonPressed @632
;	DrvBindToUser @633
;	XexGetModuleImportVersions @634
;	RtlComputeCrc32 @635
;	XeKeysSetRevocationList @636
;	HalRegisterPowerDownCallback @637
;	VdGetDisplayDiscoveryData @638
;	XInputdSendStayAliveRequest @639
;	XVoicedSendVPort @640
;	XVoicedGetBatteryStatus @641
;	XInputdFFGetDeviceInfo @642
;	XInputdFFSetEffect @643
;	XInputdFFUpdateEffect @644
;	XInputdFFEffectOperation @645
;	XInputdFFDeviceControl @646
;	XInputdFFSetDeviceGain @647
;	XInputdFFCancelIo @648
;	XInputdFFSetRumble @649
;	NtAllocateEncryptedMemory @650
;	NtFreeEncryptedMemory @651
;	XeKeysExSaveKeyVault @652
;	XeKeysExSetKey @653
;	XeKeysExGetKey @654
;	DrvSetDeviceConfigChangeCallback @655
;	DrvDeviceConfigChange @656
;	HalRegisterHdDvdRomNotification @657
;	XeKeysSecurityInitialize @658
;	XeKeysSecurityLoadSettings @659
;	XeKeysSecuritySaveSettings @660
;	XeKeysSecuritySetDetected @661
;	XeKeysSecurityGetDetected @662
;	XeKeysSecuritySetActivated @663
;	XeKeysSecurityGetActivated @664
;	XeKeysReserved665 @665
;	XeKeysReserved666 @666
;	XeKeysGetProtectedFlag @667
;	XeKeysSetProtectedFlag @668
;	KeEnablePFMInterrupt @669
;	KeDisablePFMInterrupt @670
;	KeSetProfilerISR @671
;	VdStartDisplayDiscovery @672
;	VdSetHDCPRevocationList @673
;	XeKeysGetUpdateSequence @674
;	XeKeysDvdAuthExActivate @675
;	KeGetImagePageTableEntry @676
;	HalRegisterBackgroundModeTransitionCallback @677
;	AniStartBootAnimation @678
;	HalClampUnclampOutputDACs @679
;	HalPowerDownToBackgroundMode @680
;	HalNotifyAddRemoveBackgroundTask @681
;	HalCallBackgroundModeNotificationRoutines @682
;	HalFsbResetCount @683
;	HalGetMemoryInformation @684
;	XInputdGetLastTextInputTime @685
;	VdEnableWMAProOverHDMI @686
;	XeKeysRevokeSaveSettings @687
;	XInputdSetTextMessengerIndicator @688
;	MicDeviceRequest @689
;	XeKeysGetMediaID @690
;	XeKeysReserved665 @691
;	KeGetVidInfo @692
;	HalNotifyBackgroundModeTransitionComplete @693
;	IoAcquireCancelSpinLock @694
;	IoReleaseCancelSpinLock @695
;	NtCancelIoFile @696
;	NtCancelIoFileEx @697
;	HalFinalizePowerLossRecovery @698
;	HalSetPowerLossRecovery @699
;	ExReadModifyWriteXConfigSettingUlong @700
;	HalRegisterXamPowerDownCallback @701
;	ExCancelAlarm @702
;	ExInitializeAlarm @703
;	ExSetAlarm @704
;	XexActivationGetNonce @705
;	XexActivationSetLicense @706
;	IptvSetBoundaryKey @707
;	IptvSetSessionKey @708
;	IptvVerifyOmac1Signature @709
;	IptvGetAesCtrTransform @710
;	SataCdRomRecordReset @711
;	XInputdSetTextDeviceKeyLocks @712
;	XInputdGetTextDeviceKeyLocks @713
;	XexActivationVerifyOwnership @714
;	XexDisableVerboseDbgPrint @715
;	SvodCreateDevice @716
;	RtlCaptureStackBackTrace @717
;	XeKeysRevokeUpdateDynamic @718
;	XexImportTraceEnable @719
;	ExRegisterXConfigNotification @720
;	XeKeysSecuritySetStat @721
;	VdQueryRealVideoMode @722
;	XexSetExecutablePrivilege @723
;	XAudioSuspendRenderDriverClients @724
;	IptvGetSessionKeyHash @725
;	VdSetCGMSState @726
;	VdSetSCMSState @727
;	KeFlushMultipleTb @728
;	VdGetOption @729
;	VdSetOption @730
;	UsbdBootEnumerationDoneEvent @731
;	StfsDeviceErrorEvent @732
;	ExTryToAcquireReadWriteLockExclusive @733
;	ExTryToAcquireReadWriteLockShared @734
;	XexSetLastKdcTime @735
;	XInputdControl @736
;	RmcDeviceRequest @737
;	LDIResetDecompression @738
;	NicRegisterDevice @739
;	UsbdAddDeviceComplete @740
;	UsbdCancelAsyncTransfer @741
;	UsbdGetDeviceSpeed @742
;	UsbdGetDeviceTopology @743
;	UsbdGetEndpointDescriptor @744
;	UsbdIsDeviceAuthenticated @745
;	UsbdOpenDefaultEndpoint @746
;	UsbdOpenEndpoint @747
;	UsbdQueueAsyncTransfer @748
;	UsbdQueueCloseDefaultEndpoint @749
;	UsbdQueueCloseEndpoint @750
;	UsbdRemoveDeviceComplete @751
;	KeRemoveQueueApc @752
;	UsbdDriverLoadRequiredEvent @753
;	UsbdGetRequiredDrivers @754
;	UsbdRegisterDriverObject @755
;	UsbdUnregisterDriverObject @756
;	UsbdResetDevice @758
;	UsbdGetDeviceDescriptor @759
;	NomnilGetExtension @760
;	NomnilStartCloseDevice @761
;	WifiBeginAuthentication @762
;	WifiCheckCounterMeasures @763
;	WifiChooseAuthenCipherSetFromBSSID @764
;	WifiCompleteAuthentication @765
;	WifiGetAssociationIE @766
;	WifiOnMICError @767
;	WifiPrepareAuthenticationContext @768
;	WifiRecvEAPOLPacket @769
;	WifiDeduceNetworkType @770
;	NicUnregisterDevice @771
;	DumpXitThread @772
;	XInputdSetWifiChannel @773
;	NomnilSetLed @774
;	WifiCalculateRegulatoryDomain @775
;	WifiSelectAdHocChannel @776
;	WifiChannelToFrequency @777
;	MmGetPoolPagesType @778
;	ExExpansionInstall @779
;	ExExpansionCall @780
;	PsCamDeviceRequest @781
;	McaDeviceRequest @782
;	DetroitDeviceRequest @783
;	XeCryptSha256Init @784
;	XeCryptSha256Update @785
;	XeCryptSha256Final @786
;	XeCryptSha256 @787
;	XeCryptSha384Init @788
;	XeCryptSha384Update @789
;	XInputdGetDevicePid @790
;	HalGetNotedArgonErrors @791
;	XeCryptSha384Final @792
;	HalReadArgonEeprom @793
;	HalWriteArgonEeprom @794
;	XeKeysFcrtLoad @795
;	XeKeysFcrtSave @796
;	XeKeysFcrtSet @797
;	XeCryptSha384 @798
;	XeCryptSha512Init @799
;	XAudioRegisterRenderDriverMECClient @800
;	XAudioUnregisterRenderDriverMECClient @801
;	XAudioCaptureRenderDriverFrame @802
;	XeCryptSha512Update @803
;	XeCryptSha512Final @804
;	XeCryptSha512 @805
;	XeCryptBnQwNeCompare @806
;	XVoicedGetDirectionalData @807
;	DrvSetMicArrayStartCallback @808
;	DevAuthGetStatistics @809
;	NullCableRequest @810
;	XeKeysRevokeIsDeviceRevoked @811
;	DumpUpdateDumpSettings @812
;	EtxConsumerDisableEventType @813
;	EtxConsumerEnableEventType @814
;	EtxConsumerProcessLogs @815
;	EtxConsumerRegister @816
;	EtxConsumerUnregister @817
;	EtxProducerLog @818
;	EtxProducerLogV @819
;	EtxProducerRegister @820
;	EtxProducerUnregister @821
;	EtxConsumerFlushBuffers @822
;	EtxProducerLogXwpp @823
;	EtxProducerLogXwppV @824
;	UsbdEnableDisableRootHubPort @825
;	EtxBufferRegister @826
;	EtxBufferUnregister @827
;	DumpRegisterDedicatedDataBlock @828
;	XeKeysDvdAuthExSave @829
;	XeKeysDvdAuthExInstall @830
;	XexShimDisable @831
;	XexShimEnable @832
;	XexShimEntryDisable @833
;	XexShimEntryEnable @834
;	XexShimEntryRegister @835
;	XexShimLock @836
;	XboxKrnlVersion4Digit @837
;	XeKeysObfuscateEx @838
;	XeKeysUnObfuscateEx @839
;	XexTitleHash @840
;	XexTitleHashClose @841
;	XexTitleHashContinue @842
;	XexTitleHashOpen @843
;	XAudioGetRenderDriverTic @844
;	XAudioEnableDucker @845
;	XAudioSetDuckerLevel @846
;	XAudioIsDuckerEnabled @847
;	XAudioGetDuckerLevel @848
;	XAudioGetDuckerThreshold @849
;	XAudioSetDuckerThreshold @850
;	XAudioGetDuckerAttackTime @851
;	XAudioSetDuckerAttackTime @852
;	XAudioGetDuckerReleaseTime @853
;	XAudioSetDuckerReleaseTime @854
;	XAudioGetDuckerHoldTime @855
;	XAudioSetDuckerHoldTime @856
;	DevAuthShouldAlwaysEnforce @857
;	XAudioGetUnderrunCount @858
;	DrvSetAudioLatencyCallback @859
;	XVoicedIsActiveProcess @860
;	KeExecuteOnProtectedStack @861
;	XeKeysVerifyPIRSSignature @862
;	XeCryptAesCtr @863
;	XeCryptAesCbcMac @864
;	XeCryptAesDmMac @865
;	EmaExecute @866
;	XeKeysGetTruncatedSecondaryConsoleId @867
;	ExFreeDebugPool @868
;	VdQueryVideoCapabilities @869
;	UsbdGetDeviceRootPortType @870
;	VdGet3dVideoFormat @871
;	VdGetWSS2Data @872
;	VdSet3dVideoFormat @873
;	VdSetWSS2Data @874
;	XexReserveCodeBuffer @875
;	XexCommitCodeBuffer @876
;	RtlSetVectoredExceptionHandler @877
;	RtlClearVectoredExceptionHandler @878
;	XAudioSetProcessFrameCallback @879
;	UsbdGetRootHubDeviceNode @880
;	UsbdGetPortDeviceNode @881
;	UsbdGetNatalHub @882
;	UsbdGetNatalHardwareVersion @883
;	UsbdNatalHubRegisterNotificationCallback @884
;	KeCallAndBlockOnDpcRoutine @885
;	KeCallAndWaitForDpcRoutine @886
;	TidDeviceRequest @887
;	DmPrintData @888
;	VdSetStudioRGBMode @889
;	UsbdTitleDriverResetAllUnrecognizedPorts @890
;	UsbdTitleDriverSetUnrecognizedPort @891
;	UsbdResetEndpoint @892
;	UsbdSetTimer @893
;	UsbdCancelTimer @894
;	UsbdQueueIsochTransfer @895
;	KeSetPageRelocationCallback @896
;	XexRegisterUsermodeModule @897
;	SerenityDongleRequest @898
;	TitleDeviceAuthRequest @899
;	XInputdGetFailedConnectionOrBind @901
;	XInputdSetFailedConnectionOrBindCallback @902

```

`XenonDumper/libs/xkelib/kernel/kernelext21250.0.def`:

```def
LIBRARY xboxkrnl.exe@21250.0+1861.0
EXPORTS
;	DbgBreakPoint @1
;	DbgBreakPointWithStatus @2
;	DbgPrint @3
;	DbgPrompt @4
;	DumpGetRawDumpInfo @5
;	DumpWriteDump @6
;	ExAcquireReadWriteLockExclusive @7
;	ExAcquireReadWriteLockShared @8
;	ExAllocatePool @9
;	ExAllocatePoolWithTag @10
;	ExAllocatePoolTypeWithTag @11
;	ExConsoleGameRegion @12
;	ExCreateThread @13
;	ExEventObjectType @14
;	ExFreePool @15
;	ExGetXConfigSetting @16
;	ExInitializeReadWriteLock @17
;	ExMutantObjectType @18
;	ExQueryPoolBlockSize @19
;	ExRegisterThreadNotification @20
;	ExRegisterTitleTerminateNotification @21
;	ExReleaseReadWriteLock @22
;	ExSemaphoreObjectType @23
;	ExSetXConfigSetting @24
;	ExTerminateThread @25
;	ExTerminateTitleProcess @26
;	ExThreadObjectType @27
;	ExTimerObjectType @28
;	MmDoubleMapMemory @29
;	MmUnmapMemory @30
;	XeKeysGetConsoleCertificate @31
;	FscGetCacheElementCount @32
;	FscSetCacheElementCount @33
;	HalGetCurrentAVPack @34
;	HalGpioControl @35
;	HalOpenCloseODDTray @36
;	HalReadWritePCISpace @37
;	HalRegisterPowerDownNotification @38
;	HalRegisterSMCNotification @39
;	HalReturnToFirmware @40
;	HalSendSMCMessage @41
;	HalSetAudioEnable @42
;	InterlockedFlushSList @43
;	InterlockedPopEntrySList @44
	InterlockedPushEntrySList @45
;	IoAcquireDeviceObjectLock @46
;	IoAllocateIrp @47
;	IoBuildAsynchronousFsdRequest @48
;	IoBuildDeviceIoControlRequest @49
;	IoBuildSynchronousFsdRequest @50
;	IoCallDriver @51
;	IoCheckShareAccess @52
;	IoCompleteRequest @53
;	IoCompletionObjectType @54
;	IoCreateDevice @55
;	IoCreateFile @56
;	IoDeleteDevice @57
;	IoDeviceObjectType @58
;	IoDismountVolume @59
;	IoDismountVolumeByFileHandle @60
;	IoDismountVolumeByName @61
;	IoFileObjectType @62
;	IoFreeIrp @63
;	IoInitializeIrp @64
;	IoInvalidDeviceRequest @65
;	ExSetBetaFeaturesEnabled @66
;	IoQueueThreadIrp @67
;	IoReleaseDeviceObjectLock @68
;	IoRemoveShareAccess @69
;	IoSetIoCompletion @70
;	IoSetShareAccess @71
;	IoStartNextPacket @72
;	IoStartNextPacketByKey @73
;	IoStartPacket @74
;	IoSynchronousDeviceIoControlRequest @75
;	IoSynchronousFsdRequest @76
;	KeAcquireSpinLockAtRaisedIrql @77
;	KeAlertResumeThread @78
;	KeAlertThread @79
;	KeBlowFuses @80
;	KeBoostPriorityThread @81
;	KeBugCheck @82
;	KeBugCheckEx @83
;	KeCancelTimer @84
;	KeConnectInterrupt @85
;	KeContextFromKframes @86
;	KeContextToKframes @87
;	KeCreateUserMode @88
;	KeDebugMonitorData @89
;	KeDelayExecutionThread @90
;	KeDeleteUserMode @91
;	KeDisconnectInterrupt @92
;	KeEnableFpuExceptions @93
;	KeEnablePPUPerformanceMonitor @94
;	KeEnterCriticalRegion @95
;	KeEnterUserMode @96
;	KeFlushCacheRange @97
;	KeFlushCurrentEntireTb @98
;	KeFlushEntireTb @99
;	KeFlushUserModeCurrentTb @100
;	KeFlushUserModeTb @101
;	KeGetCurrentProcessType @102
;	KeGetPMWRegister @103
;	KeGetPRVRegister @104
;	KeGetSocRegister @105
;	KeGetSpecialPurposeRegister @106
;	KeLockL2 @107
;	KeUnlockL2 @108
;	KeInitializeApc @109
;	KeInitializeDeviceQueue @110
;	KeInitializeDpc @111
;	KeInitializeEvent @112
;	KeInitializeInterrupt @113
;	KeInitializeMutant @114
;	KeInitializeQueue @115
;	KeInitializeSemaphore @116
;	KeInitializeTimerEx @117
;	KeInsertByKeyDeviceQueue @118
;	KeInsertDeviceQueue @119
;	KeInsertHeadQueue @120
;	KeInsertQueue @121
;	KeInsertQueueApc @122
;	KeInsertQueueDpc @123
;	KeIpiGenericCall @124
;	KeLeaveCriticalRegion @125
;	KeLeaveUserMode @126
;	KePulseEvent @127
;	KeQueryBackgroundProcessors @128
;	KeQueryBasePriorityThread @129
;	KeQueryInterruptTime @130
;	KeQueryPerformanceFrequency @131
;	KeQuerySystemTime @132
;	KeRaiseIrqlToDpcLevel @133
;	KeRegisterDriverNotification @134
;	KeReleaseMutant @135
;	KeReleaseSemaphore @136
;	KeReleaseSpinLockFromRaisedIrql @137
;	KeRemoveByKeyDeviceQueue @138
;	KeRemoveDeviceQueue @139
;	KeRemoveEntryDeviceQueue @140
;	KeRemoveQueue @141
;	KeRemoveQueueDpc @142
;	KeResetEvent @143
;	KeRestoreFloatingPointState @144
;	KeRestoreVectorUnitState @145
;	KeResumeThread @146
;	KeRetireDpcList @147
;	KeRundownQueue @148
;	KeSaveFloatingPointState @149
;	KeSaveVectorUnitState @150
;	KeSetAffinityThread @151
;	KeSetBackgroundProcessors @152
;	KeSetBasePriorityThread @153
;	KeSetCurrentProcessType @154
;	KeSetCurrentStackPointers @155
;	KeSetDisableBoostThread @156
;	KeSetEvent @157
;	KeSetEventBoostPriority @158
;	KeSetPMWRegister @159
;	KeSetPowerMode @160
;	KeSetPRVRegister @161
;	KeSetPriorityClassThread @162
;	KeSetPriorityThread @163
;	KeSetSocRegister @164
;	KeSetSpecialPurposeRegister @165
;	KeSetTimer @166
;	KeSetTimerEx @167
;	KeStallExecutionProcessor @168
;	KeSuspendThread @169
;	KeSweepDcacheRange @170
;	KeSweepIcacheRange @171
;	KeTestAlertThread @172
;	KeTimeStampBundle @173
;	KeTryToAcquireSpinLockAtRaisedIrql @174
;	KeWaitForMultipleObjects @175
;	KeWaitForSingleObject @176
;	KfAcquireSpinLock @177
;	KfRaiseIrql @178
;	KfLowerIrql @179
;	KfReleaseSpinLock @180
;	KiBugCheckData @181
;	LDICreateDecompression @182
;	LDIDecompress @183
;	LDIDestroyDecompression @184
;	MmAllocatePhysicalMemory @185
;	MmAllocatePhysicalMemoryEx @186
;	MmCreateKernelStack @187
;	MmDeleteKernelStack @188
;	MmFreePhysicalMemory @189
;	MmGetPhysicalAddress @190
;	MmIsAddressValid @191
;	MmLockAndMapSegmentArray @192
;	MmLockUnlockBufferPages @193
;	MmMapIoSpace @194
;	MmPersistPhysicalMemoryAllocation @195
;	MmQueryAddressProtect @196
;	MmQueryAllocationSize @197
;	MmQueryStatistics @198
;	MmSetAddressProtect @199
;	MmSplitPhysicalMemoryAllocation @200
;	MmUnlockAndUnmapSegmentArray @201
;	MmUnmapIoSpace @202
;	Nls844UnicodeCaseTable @203
;	NtAllocateVirtualMemory @204
;	NtCancelTimer @205
;	NtClearEvent @206
;	NtClose @207
;	NtCreateDirectoryObject @208
;	NtCreateEvent @209
;	NtCreateFile @210
;	NtCreateIoCompletion @211
;	NtCreateMutant @212
;	NtCreateSemaphore @213
;	NtCreateSymbolicLinkObject @214
;	NtCreateTimer @215
;	NtDeleteFile @216
;	NtDeviceIoControlFile @217
;	NtDuplicateObject @218
;	NtFlushBuffersFile @219
;	NtFreeVirtualMemory @220
;	NtMakeTemporaryObject @221
;	NtOpenDirectoryObject @222
;	NtOpenFile @223
;	NtOpenSymbolicLinkObject @224
;	NtProtectVirtualMemory @225
;	NtPulseEvent @226
;	NtQueueApcThread @227
;	NtQueryDirectoryFile @228
;	NtQueryDirectoryObject @229
;	NtQueryEvent @230
;	NtQueryFullAttributesFile @231
;	NtQueryInformationFile @232
;	NtQueryIoCompletion @233
;	NtQueryMutant @234
;	NtQuerySemaphore @235
;	NtQuerySymbolicLinkObject @236
;	NtQueryTimer @237
;	NtQueryVirtualMemory @238
;	NtQueryVolumeInformationFile @239
;	NtReadFile @240
;	NtReadFileScatter @241
;	NtReleaseMutant @242
;	NtReleaseSemaphore @243
;	NtRemoveIoCompletion @244
;	NtResumeThread @245
;	NtSetEvent @246
;	NtSetInformationFile @247
;	NtSetIoCompletion @248
;	NtSetSystemTime @249
;	NtSetTimerEx @250
;	NtSignalAndWaitForSingleObjectEx @251
;	NtSuspendThread @252
;	NtWaitForSingleObjectEx @253
;	NtWaitForMultipleObjectsEx @254
;	NtWriteFile @255
;	NtWriteFileGather @256
;	NtYieldExecution @257
;	ObCreateObject @258
;	ObCreateSymbolicLink @259
;	ObDeleteSymbolicLink @260
;	ObDereferenceObject @261
;	ObDirectoryObjectType @262
;	ObGetWaitableObject @263
;	ObInsertObject @264
;	ObIsTitleObject @265
;	ObLookupAnyThreadByThreadId @266
;	ObLookupThreadByThreadId @267
;	ObMakeTemporaryObject @268
;	ObOpenObjectByName @269
;	ObOpenObjectByPointer @270
;	ObReferenceObject @271
;	ObReferenceObjectByHandle @272
;	ObReferenceObjectByName @273
;	ObSymbolicLinkObjectType @274
;	ObTranslateSymbolicLink @275
;	RtlAnsiStringToUnicodeString @276
;	RtlAppendStringToString @277
;	RtlAppendUnicodeStringToString @278
;	RtlAppendUnicodeToString @279
;	RtlAssert @280
;	RtlCaptureContext @281
;	RtlCompareMemory @282
;	RtlCompareMemoryUlong @283
;	RtlCompareString @284
;	RtlCompareStringN @285
;	RtlCompareUnicodeString @286
;	RtlCompareUnicodeStringN @287
;	RtlCompareUtf8ToUnicode @288
;	RtlCopyString @289
;	RtlCopyUnicodeString @290
;	RtlCreateUnicodeString @291
;	RtlDowncaseUnicodeChar @292
;	RtlEnterCriticalSection @293
;	RtlFillMemoryUlong @294
;	RtlFreeAnsiString @295
;	RtlFreeAnsiString @296
;	RtlGetCallersAddress @297
;	RtlGetStackLimits @298
;	RtlImageXexHeaderField @299
;	RtlInitAnsiString @300
;	RtlInitUnicodeString @301
;	RtlInitializeCriticalSection @302
;	RtlInitializeCriticalSectionAndSpinCount @303
;	RtlLeaveCriticalSection @304
;	RtlLookupFunctionEntry @305
;	RtlLowerChar @306
;	RtlMultiByteToUnicodeN @307
;	RtlMultiByteToUnicodeSize @308
;	RtlNtStatusToDosError @309
;	RtlRaiseException @310
;	RtlRaiseStatus @311
;	RtlRip @312
;	_scprintf @313		; lib name: RtlScprintf
;	_snprintf @314		; lib name: RtlSnprintf
;	sprintf @315		; lib name: RtlSprintf
;	_scwprintf @316		; lib name: RtlScwprintf
;	_snwprintf @317		; lib name: RtlSnwprintf
;	_swprintf @318		; lib name: RtlSwprintf
;	RtlTimeFieldsToTime @319
;	RtlTimeToTimeFields @320
;	RtlTryEnterCriticalSection @321
;	RtlUnicodeStringToAnsiString @322
;	RtlUnicodeToMultiByteN @323
;	RtlUnicodeToMultiByteSize @324
;	RtlUnicodeToUtf8 @325
;	RtlUnicodeToUtf8Size @326
;	RtlUnwind @327
;	RtlUnwind2 @328
;	RtlUpcaseUnicodeChar @329
;	RtlUpperChar @330
;	RtlVirtualUnwind @331
;	_vscprintf @332		; lib name: RtlVscprintf
;	_vsnprintf @333		; lib name: RtlVsnprintf
;	vsprintf @334		; lib name: RtlVsprintf
;	_vscwprintf @335	; lib name: RtlVscwprintf
;	_vsnwprintf @336	; lib name: RtlVsnwprintf
;	_vswprintf @337		; lib name: RtlVswprintf
	KeTlsAlloc @338		; lib name: TlsAlloc
	KeTlsFree @339		; lib name: TlsFree
	KeTlsGetValue @340	; lib name: TlsGetValue
	KeTlsSetValue @341	; lib name: TlsSetValue
;	XboxHardwareInfo @342
;	XboxKrnlBaseVersion @343
;	XboxKrnlVersion @344
;	XeCryptAesKey @345
;	XeCryptAesEcb @346
;	XeCryptAesCbc @347
;	XeCryptBnDwLeDhEqualBase @348
;	XeCryptBnDwLeDhInvalBase @349
;	XeCryptBnDwLeDhModExp @350
;	XeCryptBnDw_Copy @351
;	XeCryptBnDw_SwapLeBe @352
;	XeCryptBnDw_Zero @353
;	XeCryptBnDwLePkcs1Format @354
;	XeCryptBnDwLePkcs1Verify @355
;	XeCryptBnQwBeSigCreate @356
;	XeCryptBnQwBeSigFormat @357
;	XeCryptBnQwBeSigVerify @358
;	XeCryptBnQwNeModExp @359
;	XeCryptBnQwNeModExpRoot @360
;	XeCryptBnQwNeModInv @361
;	XeCryptBnQwNeModMul @362
;	XeCryptBnQwNeRsaKeyGen @363
;	XeCryptBnQwNeRsaPrvCrypt @364
;	XeCryptBnQwNeRsaPubCrypt @365
;	XeCryptBnQw_Copy @366
;	XeCryptBnQw_SwapDwQw @367
;	XeCryptBnQw_SwapDwQwLeBe @368
;	XeCryptBnQw_SwapLeBe @369
;	XeCryptBnQw_Zero @370
;	XeCryptChainAndSumMac @371
;	XeCryptDesParity @372
;	XeCryptDesKey @373
;	XeCryptDesEcb @374
;	XeCryptDesCbc @375
;	XeCryptDes3Key @376
;	XeCryptDes3Ecb @377
;	XeCryptDes3Cbc @378
;	XeCryptHmacMd5Init @379
;	XeCryptHmacMd5Update @380
;	XeCryptHmacMd5Final @381
;	XeCryptHmacMd5 @382
;	XeCryptHmacShaInit @383
;	XeCryptHmacShaUpdate @384
;	XeCryptHmacShaFinal @385
;	XeCryptHmacSha @386
;	XeCryptHmacShaVerify @387
;	XeCryptMd5Init @388
;	XeCryptMd5Update @389
;	XeCryptMd5Final @390
;	XeCryptMd5 @391
;	XeCryptParveEcb @392
;	XeCryptParveCbcMac @393
;	XeCryptRandom @394
;	XeCryptRc4Key @395
;	XeCryptRc4Ecb @396
;	XeCryptRc4 @397
;	XeCryptRotSumSha @398
;	XeCryptShaInit @399
;	XeCryptShaUpdate @400
;	XeCryptShaFinal @401
;	XeCryptSha @402
;	XexExecutableModuleHandle @403
;	XexCheckExecutablePrivilege @404
;	XexGetModuleHandle @405
;	XexGetModuleSection @406
;	XexGetProcedureAddress @407
;	XexLoadExecutable @408
;	XexLoadImage @409
;	XexLoadImageFromMemory @410
;	XexLoadImageHeaders @411
;	XexPcToFileHeader @412
;	KiApcNormalRoutineNop @413
;	XexRegisterPatchDescriptor @414
;	XexSendDeferredNotifications @415
;	XexStartExecutable @416
;	XexUnloadImage @417
;	XexUnloadImageAndExitThread @418
;	XexUnloadTitleModules @419
;	XexVerifyImageHeaders @420
;	__C_specific_handler @421
;	DbgLoadImageSymbols @422
;	DbgUnLoadImageSymbols @423
;	RtlImageDirectoryEntryToData @424
;	RtlImageNtHeader @425
;	ExDebugMonitorService @426
;	MmDbgReadCheck @427
;	MmDbgReleaseAddress @428
;	MmDbgWriteCheck @429
;	ExLoadedCommandLine @430
;	ExLoadedImageName @431
;	VdBlockUntilGUIIdle @432
;	VdCallGraphicsNotificationRoutines @433
;	VdDisplayFatalError @434
;	VdEnableClosedCaption @435
;	VdEnableDisableClockGating @436
;	VdEnableDisablePowerSavingMode @437
;	VdEnableRingBufferRPtrWriteBack @438
;	VdGenerateGPUCSCCoefficients @439
;	VdGetClosedCaptionReadyStatus @440
;	VdGetCurrentDisplayGamma @441
;	VdGetCurrentDisplayInformation @442
;	VdGetDisplayModeOverride @443
;	VdGetGraphicsAsicID @444
;	VdGetSystemCommandBuffer @445
;	VdGlobalDevice @446
;	VdGlobalXamDevice @447
;	VdGpuClockInMHz @448
;	VdHSIOCalibrationLock @449
;	VdInitializeEngines @450
;	VdInitializeRingBuffer @451
;	VdInitializeScaler @452
;	VdInitializeScalerCommandBuffer @453
;	VdIsHSIOTrainingSucceeded @454
;	VdPersistDisplay @455
;	VdQuerySystemCommandBuffer @456
;	VdQueryVideoFlags @457
;	VdQueryVideoMode @458
;	VdReadDVERegisterUlong @459
;	VdReadWriteHSIOCalibrationFlag @460
;	VdRegisterGraphicsNotification @461
;	VdRegisterXamGraphicsNotification @462
;	VdSendClosedCaptionData @463
;	VdSetCGMSOption @464
;	VdSetColorProfileAdjustment @465
;	VdSetCscMatricesOverride @466
;	VdSetDisplayMode @467
;	VdSetDisplayModeOverride @468
;	VdSetGraphicsInterruptCallback @469
	VdSetHDCPOption @470
;	VdSetMacrovisionOption @471
;	VdSetSystemCommandBuffer @472
;	VdSetSystemCommandBufferGpuIdentifierAddress @473
;	VdSetWSSData @474
;	VdSetWSSOption @475
;	VdShutdownEngines @476
;	VdTurnDisplayOff @477
;	VdTurnDisplayOn @478
;	KiApcNormalRoutineNop @479
;	VdWriteDVERegisterUlong @480
;	XVoicedHeadsetPresent @481
;	XVoicedSubmitPacket @482
;	XVoicedClose @483
;	XVoicedActivate @484
;	XInputdGetCapabilities @485
;	XInputdReadState @486
;	XInputdWriteState @487
;	XInputdNotify @488
;	XInputdRawState @489
;	HidGetCapabilities @490
;	HidReadKeys @491
;	XInputdGetDeviceStats @492
;	XInputdResetDevice @493
;	XInputdSetRingOfLight @494
;	XInputdSetRFPowerMode @495
;	XInputdSetRadioFrequency @496
;	HidGetLastInputTime @497
;	XAudioRenderDriverInitialize @498
;	XAudioRegisterRenderDriverClient @499
;	XAudioUnregisterRenderDriverClient @500
;	XAudioSubmitRenderDriverFrame @501
;	XAudioRenderDriverLock @502
;	XAudioGetVoiceCategoryVolumeChangeMask @503
;	XAudioGetVoiceCategoryVolume @504
;	XAudioSetVoiceCategoryVolume @505
;	XAudioBeginDigitalBypassMode @506
;	XAudioEndDigitalBypassMode @507
;	XAudioSubmitDigitalPacket @508
;	XAudioQueryDriverPerformance @509
;	XAudioGetRenderDriverThread @510
;	XAudioGetSpeakerConfig @511
;	XAudioSetSpeakerConfig @512
;	NicSetUnicastAddress @513
;	NicAttach @514
;	NicDetach @515
;	NicXmit @516
;	NicUpdateMcastMembership @517
;	NicFlushXmitQueue @518
;	NicShutdown @519
;	NicGetLinkState @520
;	NicGetStats @521
;	NicGetOpt @522
;	NicSetOpt @523
;	DrvSetSysReqCallback @524
;	DrvSetUserBindingCallback @525
;	DrvSetContentStorageCallback @526
;	DrvSetAutobind @527
;	DrvGetContentStorageNotification @528
;	MtpdBeginTransaction @529
;	MtpdCancelTransaction @530
;	MtpdEndTransaction @531
;	MtpdGetCurrentDevices @532
;	MtpdReadData @533
;	MtpdReadEvent @534
;	MtpdResetDevice @535
;	MtpdSendData @536
;	MtpdVerifyProximity @537
;	XUsbcamSetCaptureMode @538
;	XUsbcamGetConfig @539
;	XUsbcamSetConfig @540
;	XUsbcamGetState @541
;	XUsbcamReadFrame @542
;	XUsbcamSnapshot @543
;	XUsbcamSetView @544
;	XUsbcamGetView @545
;	XUsbcamCreate @546
;	XUsbcamDestroy @547
;	XMACreateContext @548
;	XMAInitializeContext @549
;	XMAReleaseContext @550
;	XMAEnableContext @551
;	XMADisableContext @552
;	XMAGetOutputBufferWriteOffset @553
;	XMASetOutputBufferReadOffset @554
;	XMAGetOutputBufferReadOffset @555
;	XMASetOutputBufferValid @556
;	XMAIsOutputBufferValid @557
;	XMASetInputBuffer0Valid @558
;	XMAIsInputBuffer0Valid @559
;	XMASetInputBuffer1Valid @560
;	XMAIsInputBuffer1Valid @561
;	XMASetInputBuffer0 @562
;	XMASetInputBuffer1 @563
;	XMAGetPacketMetadata @564
;	XMABlockWhileInUse @565
;	XMASetLoopData @566
;	XMASetInputBufferReadOffset @567
;	XMAGetInputBufferReadOffset @568
;	ExIsBetaFeatureEnabled @569
;	XeKeysGetFactoryChallenge @570
;	XeKeysSetFactoryResponse @571
;	XeKeysInitializeFuses @572
;	XeKeysSaveBootLoader @573
;	XeKeysSaveKeyVault @574
;	XeKeysGetStatus @575
;	XeKeysGeneratePrivateKey @576
;	XeKeysGetKeyProperties @577
;	XeKeysSetKey @578
;	XeKeysGenerateRandomKey @579
;	XeKeysGetKey @580
;	XeKeysGetDigest @581
;	XeKeysGetConsoleID @582
;	XeKeysGetConsoleType @583
;	XeKeysQwNeRsaPrvCrypt @584
;	XeKeysHmacSha @585
;	XInputdPassThroughRFCommand @586
;	XeKeysAesCbc @587
;	XeKeysDes2Cbc @588
;	XeKeysDesCbc @589
;	XeKeysObscureKey @590
;	XeKeysHmacShaUsingKey @591
;	XeKeysSaveBootLoaderEx @592
;	XeKeysAesCbcUsingKey @593
;	XeKeysDes2CbcUsingKey @594
;	XeKeysDesCbcUsingKey @595
;	XeKeysObfuscate @596
;	XeKeysUnObfuscate @597
;	XeKeysConsolePrivateKeySign @598
;	XeKeysConsoleSignatureVerification @599
;	XeKeysVerifyRSASignature @600
;	StfsCreateDevice @601
;	StfsControlDevice @602
;	VdSwap @603
;	HalFsbInterruptCount @604
;	XeKeysSaveSystemUpdate @605
;	XeKeysLockSystemUpdate @606
;	XeKeysExecute @607
;	XeKeysGetVersions @608
;	XInputdPowerDownDevice @609
;	AniBlockOnAnimation @610
;	AniTerminateAnimation @611
;	XUsbcamReset @612
;	AniSetLogo @613
;	KeCertMonitorData @614
;	HalIsExecutingPowerDownDpc @615
;	VdInitializeEDRAM @616
;	VdRetrainEDRAM @617
;	VdRetrainEDRAMWorker @618
;	VdHSIOTrainCount @619
;	HalGetPowerUpCause @620
;	VdHSIOTrainingStatus @621
;	RgcBindInfo @622
;	VdReadEEDIDBlock @623
;	VdEnumerateVideoModes @624
;	VdEnableHDCP @625
;	VdRegisterHDCPNotification @626
;	HidReadMouseChanges @627
;	DumpSetCollectionFacility @628
;	XexTransformImageKey @629
;	XAudioOverrideSpeakerConfig @630
;	XInputdReadTextKeystroke @631
;	DrvXenonButtonPressed @632
;	DrvBindToUser @633
;	XexGetModuleImportVersions @634
;	RtlComputeCrc32 @635
;	XeKeysSetRevocationList @636
;	HalRegisterPowerDownCallback @637
;	VdGetDisplayDiscoveryData @638
;	XInputdSendStayAliveRequest @639
;	XVoicedSendVPort @640
;	XVoicedGetBatteryStatus @641
;	XInputdFFGetDeviceInfo @642
;	XInputdFFSetEffect @643
;	XInputdFFUpdateEffect @644
;	XInputdFFEffectOperation @645
;	XInputdFFDeviceControl @646
;	XInputdFFSetDeviceGain @647
;	XInputdFFCancelIo @648
;	XInputdFFSetRumble @649
;	NtAllocateEncryptedMemory @650
;	NtFreeEncryptedMemory @651
;	XeKeysExSaveKeyVault @652
;	XeKeysExSetKey @653
;	XeKeysExGetKey @654
;	DrvSetDeviceConfigChangeCallback @655
;	DrvDeviceConfigChange @656
;	HalRegisterHdDvdRomNotification @657
;	XeKeysSecurityInitialize @658
;	XeKeysSecurityLoadSettings @659
;	XeKeysSecuritySaveSettings @660
;	XeKeysSecuritySetDetected @661
;	XeKeysSecurityGetDetected @662
;	XeKeysSecuritySetActivated @663
;	XeKeysSecurityGetActivated @664
;	XeKeysReserved665 @665
;	XeKeysReserved666 @666
;	XeKeysGetProtectedFlag @667
;	XeKeysSetProtectedFlag @668
;	KeEnablePFMInterrupt @669
;	KeDisablePFMInterrupt @670
;	KeSetProfilerISR @671
;	VdStartDisplayDiscovery @672
;	VdSetHDCPRevocationList @673
;	XeKeysGetUpdateSequence @674
;	XeKeysDvdAuthExActivate @675
;	KeGetImagePageTableEntry @676
;	HalRegisterBackgroundModeTransitionCallback @677
;	AniStartBootAnimation @678
;	HalClampUnclampOutputDACs @679
;	HalPowerDownToBackgroundMode @680
;	HalNotifyAddRemoveBackgroundTask @681
;	HalCallBackgroundModeNotificationRoutines @682
;	HalFsbResetCount @683
;	HalGetMemoryInformation @684
;	XInputdGetLastTextInputTime @685
;	VdEnableWMAProOverHDMI @686
;	XeKeysRevokeSaveSettings @687
;	XInputdSetTextMessengerIndicator @688
;	MicDeviceRequest @689
;	XeKeysGetMediaID @690
;	XeKeysReserved665 @691
;	KeGetVidInfo @692
;	HalNotifyBackgroundModeTransitionComplete @693
;	IoAcquireCancelSpinLock @694
;	IoReleaseCancelSpinLock @695
;	NtCancelIoFile @696
;	NtCancelIoFileEx @697
;	HalFinalizePowerLossRecovery @698
;	HalSetPowerLossRecovery @699
;	ExReadModifyWriteXConfigSettingUlong @700
;	HalRegisterXamPowerDownCallback @701
;	ExCancelAlarm @702
;	ExInitializeAlarm @703
;	ExSetAlarm @704
;	XexActivationGetNonce @705
;	XexActivationSetLicense @706
;	IptvSetBoundaryKey @707
;	IptvSetSessionKey @708
;	IptvVerifyOmac1Signature @709
;	IptvGetAesCtrTransform @710
;	SataCdRomRecordReset @711
;	XInputdSetTextDeviceKeyLocks @712
;	XInputdGetTextDeviceKeyLocks @713
;	XexActivationVerifyOwnership @714
;	XexDisableVerboseDbgPrint @715
;	SvodCreateDevice @716
;	RtlCaptureStackBackTrace @717
;	XeKeysRevokeUpdateDynamic @718
;	XexImportTraceEnable @719
;	ExRegisterXConfigNotification @720
;	XeKeysSecuritySetStat @721
;	VdQueryRealVideoMode @722
;	XexSetExecutablePrivilege @723
;	XAudioSuspendRenderDriverClients @724
;	IptvGetSessionKeyHash @725
;	VdSetCGMSState @726
;	VdSetSCMSState @727
;	KeFlushMultipleTb @728
;	VdGetOption @729
;	VdSetOption @730
;	UsbdBootEnumerationDoneEvent @731
;	StfsDeviceErrorEvent @732
;	ExTryToAcquireReadWriteLockExclusive @733
;	ExTryToAcquireReadWriteLockShared @734
;	XexSetLastKdcTime @735
;	XInputdControl @736
;	RmcDeviceRequest @737
;	LDIResetDecompression @738
;	NicRegisterDevice @739
;	UsbdAddDeviceComplete @740
;	UsbdCancelAsyncTransfer @741
;	UsbdGetDeviceSpeed @742
;	UsbdGetDeviceTopology @743
;	UsbdGetEndpointDescriptor @744
;	UsbdIsDeviceAuthenticated @745
;	UsbdOpenDefaultEndpoint @746
;	UsbdOpenEndpoint @747
;	UsbdQueueAsyncTransfer @748
;	UsbdQueueCloseDefaultEndpoint @749
;	UsbdQueueCloseEndpoint @750
;	UsbdRemoveDeviceComplete @751
;	KeRemoveQueueApc @752
;	UsbdDriverLoadRequiredEvent @753
;	UsbdGetRequiredDrivers @754
;	UsbdRegisterDriverObject @755
;	UsbdUnregisterDriverObject @756
;	UsbdResetDevice @758
;	UsbdGetDeviceDescriptor @759
;	NomnilGetExtension @760
;	NomnilStartCloseDevice @761
;	WifiBeginAuthentication @762
;	WifiCheckCounterMeasures @763
;	WifiChooseAuthenCipherSetFromBSSID @764
;	WifiCompleteAuthentication @765
;	WifiGetAssociationIE @766
;	WifiOnMICError @767
;	WifiPrepareAuthenticationContext @768
;	WifiRecvEAPOLPacket @769
;	WifiDeduceNetworkType @770
;	NicUnregisterDevice @771
;	DumpXitThread @772
;	XInputdSetWifiChannel @773
;	NomnilSetLed @774
;	WifiCalculateRegulatoryDomain @775
;	WifiSelectAdHocChannel @776
;	WifiChannelToFrequency @777
;	MmGetPoolPagesType @778
;	ExExpansionInstall @779
;	ExExpansionCall @780
;	PsCamDeviceRequest @781
;	McaDeviceRequest @782
;	DetroitDeviceRequest @783
;	XeCryptSha256Init @784
;	XeCryptSha256Update @785
;	XeCryptSha256Final @786
;	XeCryptSha256 @787
;	XeCryptSha384Init @788
;	XeCryptSha384Update @789
;	XInputdGetDevicePid @790
;	HalGetNotedArgonErrors @791
;	XeCryptSha384Final @792
;	HalReadArgonEeprom @793
;	HalWriteArgonEeprom @794
;	XeKeysFcrtLoad @795
;	XeKeysFcrtSave @796
;	XeKeysFcrtSet @797
;	XeCryptSha384 @798
;	XeCryptSha512Init @799
;	XAudioRegisterRenderDriverMECClient @800
;	XAudioUnregisterRenderDriverMECClient @801
;	XAudioCaptureRenderDriverFrame @802
;	XeCryptSha512Update @803
;	XeCryptSha512Final @804
;	XeCryptSha512 @805
;	XeCryptBnQwNeCompare @806
;	XVoicedGetDirectionalData @807
;	DrvSetMicArrayStartCallback @808
;	DevAuthGetStatistics @809
;	NullCableRequest @810
;	XeKeysRevokeIsDeviceRevoked @811
;	DumpUpdateDumpSettings @812
;	EtxConsumerDisableEventType @813
;	EtxConsumerEnableEventType @814
;	EtxConsumerProcessLogs @815
;	EtxConsumerRegister @816
;	EtxConsumerUnregister @817
;	EtxProducerLog @818
;	EtxProducerLogV @819
;	EtxProducerRegister @820
;	EtxProducerUnregister @821
;	EtxConsumerFlushBuffers @822
;	EtxProducerLogXwpp @823
;	EtxProducerLogXwppV @824
;	UsbdEnableDisableRootHubPort @825
;	EtxBufferRegister @826
;	EtxBufferUnregister @827
;	DumpRegisterDedicatedDataBlock @828
;	XeKeysDvdAuthExSave @829
;	XeKeysDvdAuthExInstall @830
;	XexShimDisable @831
;	XexShimEnable @832
;	XexShimEntryDisable @833
;	XexShimEntryEnable @834
;	XexShimEntryRegister @835
;	XexShimLock @836
;	XboxKrnlVersion4Digit @837
;	XeKeysObfuscateEx @838
;	XeKeysUnObfuscateEx @839
;	XexTitleHash @840
;	XexTitleHashClose @841
;	XexTitleHashContinue @842
;	XexTitleHashOpen @843
;	XAudioGetRenderDriverTic @844
;	XAudioEnableDucker @845
;	XAudioSetDuckerLevel @846
;	XAudioIsDuckerEnabled @847
;	XAudioGetDuckerLevel @848
;	XAudioGetDuckerThreshold @849
;	XAudioSetDuckerThreshold @850
;	XAudioGetDuckerAttackTime @851
;	XAudioSetDuckerAttackTime @852
;	XAudioGetDuckerReleaseTime @853
;	XAudioSetDuckerReleaseTime @854
;	XAudioGetDuckerHoldTime @855
;	XAudioSetDuckerHoldTime @856
;	DevAuthShouldAlwaysEnforce @857
;	XAudioGetUnderrunCount @858
;	DrvSetAudioLatencyCallback @859
;	XVoicedIsActiveProcess @860
;	KeExecuteOnProtectedStack @861
;	XeKeysVerifyPIRSSignature @862
;	XeCryptAesCtr @863
;	XeCryptAesCbcMac @864
;	XeCryptAesDmMac @865
;	EmaExecute @866
;	XeKeysGetTruncatedSecondaryConsoleId @867
;	ExFreeDebugPool @868
;	VdQueryVideoCapabilities @869
;	UsbdGetDeviceRootPortType @870
;	VdGet3dVideoFormat @871
;	VdGetWSS2Data @872
;	VdSet3dVideoFormat @873
;	VdSetWSS2Data @874
;	XexReserveCodeBuffer @875
;	XexCommitCodeBuffer @876
;	RtlSetVectoredExceptionHandler @877
;	RtlClearVectoredExceptionHandler @878
;	XAudioSetProcessFrameCallback @879
;	UsbdGetRootHubDeviceNode @880
;	UsbdGetPortDeviceNode @881
;	UsbdGetNatalHub @882
;	UsbdGetNatalHardwareVersion @883
;	UsbdNatalHubRegisterNotificationCallback @884
;	KeCallAndBlockOnDpcRoutine @885
;	KeCallAndWaitForDpcRoutine @886
;	TidDeviceRequest @887
;	DmPrintData @888
;	VdSetStudioRGBMode @889
;	UsbdTitleDriverResetAllUnrecognizedPorts @890
;	UsbdTitleDriverSetUnrecognizedPort @891
;	UsbdResetEndpoint @892
;	UsbdSetTimer @893
;	UsbdCancelTimer @894
;	UsbdQueueIsochTransfer @895
;	KeSetPageRelocationCallback @896
;	XexRegisterUsermodeModule @897
;	SerenityDongleRequest @898
;	TitleDeviceAuthRequest @899
;	KeRegisterSwapNotification @900
;	XInputdGetFailedConnectionOrBind @901
;	XInputdSetFailedConnectionOrBindCallback @902
;	XInputdSetMinMaxAuthDelay @904


```

`XenonDumper/libs/xkelib/kernel/kernelext21256.0.def`:

```def
LIBRARY xboxkrnl.exe@21256.0+1861.0
EXPORTS
;	DbgBreakPoint @1
;	DbgBreakPointWithStatus @2
;	DbgPrint @3
;	DbgPrompt @4
;	DumpGetRawDumpInfo @5
;	DumpWriteDump @6
;	ExAcquireReadWriteLockExclusive @7
;	ExAcquireReadWriteLockShared @8
;	ExAllocatePool @9
;	ExAllocatePoolWithTag @10
;	ExAllocatePoolTypeWithTag @11
;	ExConsoleGameRegion @12
;	ExCreateThread @13
;	ExEventObjectType @14
;	ExFreePool @15
;	ExGetXConfigSetting @16
;	ExInitializeReadWriteLock @17
;	ExMutantObjectType @18
;	ExQueryPoolBlockSize @19
;	ExRegisterThreadNotification @20
;	ExRegisterTitleTerminateNotification @21
;	ExReleaseReadWriteLock @22
;	ExSemaphoreObjectType @23
;	ExSetXConfigSetting @24
;	ExTerminateThread @25
;	ExTerminateTitleProcess @26
;	ExThreadObjectType @27
;	ExTimerObjectType @28
;	MmDoubleMapMemory @29
;	MmUnmapMemory @30
;	XeKeysGetConsoleCertificate @31
;	FscGetCacheElementCount @32
;	FscSetCacheElementCount @33
;	HalGetCurrentAVPack @34
;	HalGpioControl @35
;	HalOpenCloseODDTray @36
;	HalReadWritePCISpace @37
;	HalRegisterPowerDownNotification @38
;	HalRegisterSMCNotification @39
;	HalReturnToFirmware @40
;	HalSendSMCMessage @41
;	HalSetAudioEnable @42
;	InterlockedFlushSList @43
;	InterlockedPopEntrySList @44
	InterlockedPushEntrySList @45
;	IoAcquireDeviceObjectLock @46
;	IoAllocateIrp @47
;	IoBuildAsynchronousFsdRequest @48
;	IoBuildDeviceIoControlRequest @49
;	IoBuildSynchronousFsdRequest @50
;	IoCallDriver @51
;	IoCheckShareAccess @52
;	IoCompleteRequest @53
;	IoCompletionObjectType @54
;	IoCreateDevice @55
;	IoCreateFile @56
;	IoDeleteDevice @57
;	IoDeviceObjectType @58
;	IoDismountVolume @59
;	IoDismountVolumeByFileHandle @60
;	IoDismountVolumeByName @61
;	IoFileObjectType @62
;	IoFreeIrp @63
;	IoInitializeIrp @64
;	IoInvalidDeviceRequest @65
;	ExSetBetaFeaturesEnabled @66
;	IoQueueThreadIrp @67
;	IoReleaseDeviceObjectLock @68
;	IoRemoveShareAccess @69
;	IoSetIoCompletion @70
;	IoSetShareAccess @71
;	IoStartNextPacket @72
;	IoStartNextPacketByKey @73
;	IoStartPacket @74
;	IoSynchronousDeviceIoControlRequest @75
;	IoSynchronousFsdRequest @76
;	KeAcquireSpinLockAtRaisedIrql @77
;	KeAlertResumeThread @78
;	KeAlertThread @79
;	KeBlowFuses @80
;	KeBoostPriorityThread @81
;	KeBugCheck @82
;	KeBugCheckEx @83
;	KeCancelTimer @84
;	KeConnectInterrupt @85
;	KeContextFromKframes @86
;	KeContextToKframes @87
;	KeCreateUserMode @88
;	KeDebugMonitorData @89
;	KeDelayExecutionThread @90
;	KeDeleteUserMode @91
;	KeDisconnectInterrupt @92
;	KeEnableFpuExceptions @93
;	KeEnablePPUPerformanceMonitor @94
;	KeEnterCriticalRegion @95
;	KeEnterUserMode @96
;	KeFlushCacheRange @97
;	KeFlushCurrentEntireTb @98
;	KeFlushEntireTb @99
;	KeFlushUserModeCurrentTb @100
;	KeFlushUserModeTb @101
;	KeGetCurrentProcessType @102
;	KeGetPMWRegister @103
;	KeGetPRVRegister @104
;	KeGetSocRegister @105
;	KeGetSpecialPurposeRegister @106
;	KeLockL2 @107
;	KeUnlockL2 @108
;	KeInitializeApc @109
;	KeInitializeDeviceQueue @110
;	KeInitializeDpc @111
;	KeInitializeEvent @112
;	KeInitializeInterrupt @113
;	KeInitializeMutant @114
;	KeInitializeQueue @115
;	KeInitializeSemaphore @116
;	KeInitializeTimerEx @117
;	KeInsertByKeyDeviceQueue @118
;	KeInsertDeviceQueue @119
;	KeInsertHeadQueue @120
;	KeInsertQueue @121
;	KeInsertQueueApc @122
;	KeInsertQueueDpc @123
;	KeIpiGenericCall @124
;	KeLeaveCriticalRegion @125
;	KeLeaveUserMode @126
;	KePulseEvent @127
;	KeQueryBackgroundProcessors @128
;	KeQueryBasePriorityThread @129
;	KeQueryInterruptTime @130
;	KeQueryPerformanceFrequency @131
;	KeQuerySystemTime @132
;	KeRaiseIrqlToDpcLevel @133
;	KeRegisterDriverNotification @134
;	KeReleaseMutant @135
;	KeReleaseSemaphore @136
;	KeReleaseSpinLockFromRaisedIrql @137
;	KeRemoveByKeyDeviceQueue @138
;	KeRemoveDeviceQueue @139
;	KeRemoveEntryDeviceQueue @140
;	KeRemoveQueue @141
;	KeRemoveQueueDpc @142
;	KeResetEvent @143
;	KeRestoreFloatingPointState @144
;	KeRestoreVectorUnitState @145
;	KeResumeThread @146
;	KeRetireDpcList @147
;	KeRundownQueue @148
;	KeSaveFloatingPointState @149
;	KeSaveVectorUnitState @150
;	KeSetAffinityThread @151
;	KeSetBackgroundProcessors @152
;	KeSetBasePriorityThread @153
;	KeSetCurrentProcessType @154
;	KeSetCurrentStackPointers @155
;	KeSetDisableBoostThread @156
;	KeSetEvent @157
;	KeSetEventBoostPriority @158
;	KeSetPMWRegister @159
;	KeSetPowerMode @160
;	KeSetPRVRegister @161
;	KeSetPriorityClassThread @162
;	KeSetPriorityThread @163
;	KeSetSocRegister @164
;	KeSetSpecialPurposeRegister @165
;	KeSetTimer @166
;	KeSetTimerEx @167
;	KeStallExecutionProcessor @168
;	KeSuspendThread @169
;	KeSweepDcacheRange @170
;	KeSweepIcacheRange @171
;	KeTestAlertThread @172
;	KeTimeStampBundle @173
;	KeTryToAcquireSpinLockAtRaisedIrql @174
;	KeWaitForMultipleObjects @175
;	KeWaitForSingleObject @176
;	KfAcquireSpinLock @177
;	KfRaiseIrql @178
;	KfLowerIrql @179
;	KfReleaseSpinLock @180
;	KiBugCheckData @181
;	LDICreateDecompression @182
;	LDIDecompress @183
;	LDIDestroyDecompression @184
;	MmAllocatePhysicalMemory @185
;	MmAllocatePhysicalMemoryEx @186
;	MmCreateKernelStack @187
;	MmDeleteKernelStack @188
;	MmFreePhysicalMemory @189
;	MmGetPhysicalAddress @190
;	MmIsAddressValid @191
;	MmLockAndMapSegmentArray @192
;	MmLockUnlockBufferPages @193
;	MmMapIoSpace @194
;	MmPersistPhysicalMemoryAllocation @195
;	MmQueryAddressProtect @196
;	MmQueryAllocationSize @197
;	MmQueryStatistics @198
;	MmSetAddressProtect @199
;	MmSplitPhysicalMemoryAllocation @200
;	MmUnlockAndUnmapSegmentArray @201
;	MmUnmapIoSpace @202
;	Nls844UnicodeCaseTable @203
;	NtAllocateVirtualMemory @204
;	NtCancelTimer @205
;	NtClearEvent @206
;	NtClose @207
;	NtCreateDirectoryObject @208
;	NtCreateEvent @209
;	NtCreateFile @210
;	NtCreateIoCompletion @211
;	NtCreateMutant @212
;	NtCreateSemaphore @213
;	NtCreateSymbolicLinkObject @214
;	NtCreateTimer @215
;	NtDeleteFile @216
;	NtDeviceIoControlFile @217
;	NtDuplicateObject @218
;	NtFlushBuffersFile @219
;	NtFreeVirtualMemory @220
;	NtMakeTemporaryObject @221
;	NtOpenDirectoryObject @222
;	NtOpenFile @223
;	NtOpenSymbolicLinkObject @224
;	NtProtectVirtualMemory @225
;	NtPulseEvent @226
;	NtQueueApcThread @227
;	NtQueryDirectoryFile @228
;	NtQueryDirectoryObject @229
;	NtQueryEvent @230
;	NtQueryFullAttributesFile @231
;	NtQueryInformationFile @232
;	NtQueryIoCompletion @233
;	NtQueryMutant @234
;	NtQuerySemaphore @235
;	NtQuerySymbolicLinkObject @236
;	NtQueryTimer @237
;	NtQueryVirtualMemory @238
;	NtQueryVolumeInformationFile @239
;	NtReadFile @240
;	NtReadFileScatter @241
;	NtReleaseMutant @242
;	NtReleaseSemaphore @243
;	NtRemoveIoCompletion @244
;	NtResumeThread @245
;	NtSetEvent @246
;	NtSetInformationFile @247
;	NtSetIoCompletion @248
;	NtSetSystemTime @249
;	NtSetTimerEx @250
;	NtSignalAndWaitForSingleObjectEx @251
;	NtSuspendThread @252
;	NtWaitForSingleObjectEx @253
;	NtWaitForMultipleObjectsEx @254
;	NtWriteFile @255
;	NtWriteFileGather @256
;	NtYieldExecution @257
;	ObCreateObject @258
;	ObCreateSymbolicLink @259
;	ObDeleteSymbolicLink @260
;	ObDereferenceObject @261
;	ObDirectoryObjectType @262
;	ObGetWaitableObject @263
;	ObInsertObject @264
;	ObIsTitleObject @265
;	ObLookupAnyThreadByThreadId @266
;	ObLookupThreadByThreadId @267
;	ObMakeTemporaryObject @268
;	ObOpenObjectByName @269
;	ObOpenObjectByPointer @270
;	ObReferenceObject @271
;	ObReferenceObjectByHandle @272
;	ObReferenceObjectByName @273
;	ObSymbolicLinkObjectType @274
;	ObTranslateSymbolicLink @275
;	RtlAnsiStringToUnicodeString @276
;	RtlAppendStringToString @277
;	RtlAppendUnicodeStringToString @278
;	RtlAppendUnicodeToString @279
;	RtlAssert @280
;	RtlCaptureContext @281
;	RtlCompareMemory @282
;	RtlCompareMemoryUlong @283
;	RtlCompareString @284
;	RtlCompareStringN @285
;	RtlCompareUnicodeString @286
;	RtlCompareUnicodeStringN @287
;	RtlCompareUtf8ToUnicode @288
;	RtlCopyString @289
;	RtlCopyUnicodeString @290
;	RtlCreateUnicodeString @291
;	RtlDowncaseUnicodeChar @292
;	RtlEnterCriticalSection @293
;	RtlFillMemoryUlong @294
;	RtlFreeAnsiString @295
;	RtlFreeAnsiString @296
;	RtlGetCallersAddress @297
;	RtlGetStackLimits @298
;	RtlImageXexHeaderField @299
;	RtlInitAnsiString @300
;	RtlInitUnicodeString @301
;	RtlInitializeCriticalSection @302
;	RtlInitializeCriticalSectionAndSpinCount @303
;	RtlLeaveCriticalSection @304
;	RtlLookupFunctionEntry @305
;	RtlLowerChar @306
;	RtlMultiByteToUnicodeN @307
;	RtlMultiByteToUnicodeSize @308
;	RtlNtStatusToDosError @309
;	RtlRaiseException @310
;	RtlRaiseStatus @311
;	RtlRip @312
;	_scprintf @313		; lib name: RtlScprintf
;	_snprintf @314		; lib name: RtlSnprintf
;	sprintf @315		; lib name: RtlSprintf
;	_scwprintf @316		; lib name: RtlScwprintf
;	_snwprintf @317		; lib name: RtlSnwprintf
;	_swprintf @318		; lib name: RtlSwprintf
;	RtlTimeFieldsToTime @319
;	RtlTimeToTimeFields @320
;	RtlTryEnterCriticalSection @321
;	RtlUnicodeStringToAnsiString @322
;	RtlUnicodeToMultiByteN @323
;	RtlUnicodeToMultiByteSize @324
;	RtlUnicodeToUtf8 @325
;	RtlUnicodeToUtf8Size @326
;	RtlUnwind @327
;	RtlUnwind2 @328
;	RtlUpcaseUnicodeChar @329
;	RtlUpperChar @330
;	RtlVirtualUnwind @331
;	_vscprintf @332		; lib name: RtlVscprintf
;	_vsnprintf @333		; lib name: RtlVsnprintf
;	vsprintf @334		; lib name: RtlVsprintf
;	_vscwprintf @335	; lib name: RtlVscwprintf
;	_vsnwprintf @336	; lib name: RtlVsnwprintf
;	_vswprintf @337		; lib name: RtlVswprintf
	KeTlsAlloc @338		; lib name: TlsAlloc
	KeTlsFree @339		; lib name: TlsFree
	KeTlsGetValue @340	; lib name: TlsGetValue
	KeTlsSetValue @341	; lib name: TlsSetValue
;	XboxHardwareInfo @342
;	XboxKrnlBaseVersion @343
;	XboxKrnlVersion @344
;	XeCryptAesKey @345
;	XeCryptAesEcb @346
;	XeCryptAesCbc @347
;	XeCryptBnDwLeDhEqualBase @348
;	XeCryptBnDwLeDhInvalBase @349
;	XeCryptBnDwLeDhModExp @350
;	XeCryptBnDw_Copy @351
;	XeCryptBnDw_SwapLeBe @352
;	XeCryptBnDw_Zero @353
;	XeCryptBnDwLePkcs1Format @354
;	XeCryptBnDwLePkcs1Verify @355
;	XeCryptBnQwBeSigCreate @356
;	XeCryptBnQwBeSigFormat @357
;	XeCryptBnQwBeSigVerify @358
;	XeCryptBnQwNeModExp @359
;	XeCryptBnQwNeModExpRoot @360
;	XeCryptBnQwNeModInv @361
;	XeCryptBnQwNeModMul @362
;	XeCryptBnQwNeRsaKeyGen @363
;	XeCryptBnQwNeRsaPrvCrypt @364
;	XeCryptBnQwNeRsaPubCrypt @365
;	XeCryptBnQw_Copy @366
;	XeCryptBnQw_SwapDwQw @367
;	XeCryptBnQw_SwapDwQwLeBe @368
;	XeCryptBnQw_SwapLeBe @369
;	XeCryptBnQw_Zero @370
;	XeCryptChainAndSumMac @371
;	XeCryptDesParity @372
;	XeCryptDesKey @373
;	XeCryptDesEcb @374
;	XeCryptDesCbc @375
;	XeCryptDes3Key @376
;	XeCryptDes3Ecb @377
;	XeCryptDes3Cbc @378
;	XeCryptHmacMd5Init @379
;	XeCryptHmacMd5Update @380
;	XeCryptHmacMd5Final @381
;	XeCryptHmacMd5 @382
;	XeCryptHmacShaInit @383
;	XeCryptHmacShaUpdate @384
;	XeCryptHmacShaFinal @385
;	XeCryptHmacSha @386
;	XeCryptHmacShaVerify @387
;	XeCryptMd5Init @388
;	XeCryptMd5Update @389
;	XeCryptMd5Final @390
;	XeCryptMd5 @391
;	XeCryptParveEcb @392
;	XeCryptParveCbcMac @393
;	XeCryptRandom @394
;	XeCryptRc4Key @395
;	XeCryptRc4Ecb @396
;	XeCryptRc4 @397
;	XeCryptRotSumSha @398
;	XeCryptShaInit @399
;	XeCryptShaUpdate @400
;	XeCryptShaFinal @401
;	XeCryptSha @402
;	XexExecutableModuleHandle @403
;	XexCheckExecutablePrivilege @404
;	XexGetModuleHandle @405
;	XexGetModuleSection @406
;	XexGetProcedureAddress @407
;	XexLoadExecutable @408
;	XexLoadImage @409
;	XexLoadImageFromMemory @410
;	XexLoadImageHeaders @411
;	XexPcToFileHeader @412
;	KiApcNormalRoutineNop @413		; lib name: XexRegisterLoader
;	XexRegisterPatchDescriptor @414
;	XexSendDeferredNotifications @415
;	XexStartExecutable @416
;	XexUnloadImage @417
;	XexUnloadImageAndExitThread @418
;	XexUnloadTitleModules @419
;	XexVerifyImageHeaders @420
;	__C_specific_handler @421
;	DbgLoadImageSymbols @422
;	DbgUnLoadImageSymbols @423
;	RtlImageDirectoryEntryToData @424
;	RtlImageNtHeader @425
;	ExDebugMonitorService @426
;	MmDbgReadCheck @427
;	MmDbgReleaseAddress @428
;	MmDbgWriteCheck @429
;	ExLoadedCommandLine @430
;	ExLoadedImageName @431
;	VdBlockUntilGUIIdle @432
;	VdCallGraphicsNotificationRoutines @433
;	VdDisplayFatalError @434
;	VdEnableClosedCaption @435
;	VdEnableDisableClockGating @436
;	VdEnableDisablePowerSavingMode @437
;	VdEnableRingBufferRPtrWriteBack @438
;	VdGenerateGPUCSCCoefficients @439
;	VdGetClosedCaptionReadyStatus @440
;	VdGetCurrentDisplayGamma @441
;	VdGetCurrentDisplayInformation @442
;	VdGetDisplayModeOverride @443
;	VdGetGraphicsAsicID @444
;	VdGetSystemCommandBuffer @445
;	VdGlobalDevice @446
;	VdGlobalXamDevice @447
;	VdGpuClockInMHz @448
;	VdHSIOCalibrationLock @449
;	VdInitializeEngines @450
;	VdInitializeRingBuffer @451
;	VdInitializeScaler @452
;	VdInitializeScalerCommandBuffer @453
;	VdIsHSIOTrainingSucceeded @454
;	VdPersistDisplay @455
;	VdQuerySystemCommandBuffer @456
;	VdQueryVideoFlags @457
;	VdQueryVideoMode @458
;	VdReadDVERegisterUlong @459
;	VdReadWriteHSIOCalibrationFlag @460
;	VdRegisterGraphicsNotification @461
;	VdRegisterXamGraphicsNotification @462
;	VdSendClosedCaptionData @463
;	VdSetCGMSOption @464
;	VdSetColorProfileAdjustment @465
;	VdSetCscMatricesOverride @466
;	VdSetDisplayMode @467
;	VdSetDisplayModeOverride @468
;	VdSetGraphicsInterruptCallback @469
	VdSetHDCPOption @470
;	VdSetMacrovisionOption @471
;	VdSetSystemCommandBuffer @472
;	VdSetSystemCommandBufferGpuIdentifierAddress @473
;	VdSetWSSData @474
;	VdSetWSSOption @475
;	VdShutdownEngines @476
;	VdTurnDisplayOff @477
;	VdTurnDisplayOn @478
;	KiApcNormalRoutineNop @479		; lib name: VdVerifyMEInitCommand
;	VdWriteDVERegisterUlong @480
;	XVoicedHeadsetPresent @481
;	XVoicedSubmitPacket @482
;	XVoicedClose @483
;	XVoicedActivate @484
;	XInputdGetCapabilities @485
;	XInputdReadState @486
;	XInputdWriteState @487
;	XInputdNotify @488
;	XInputdRawState @489
;	HidGetCapabilities @490
;	HidReadKeys @491
;	XInputdGetDeviceStats @492
;	XInputdResetDevice @493
;	XInputdSetRingOfLight @494
;	XInputdSetRFPowerMode @495
;	XInputdSetRadioFrequency @496
;	HidGetLastInputTime @497
;	XAudioRenderDriverInitialize @498
;	XAudioRegisterRenderDriverClient @499
;	XAudioUnregisterRenderDriverClient @500
;	XAudioSubmitRenderDriverFrame @501
;	XAudioRenderDriverLock @502
;	XAudioGetVoiceCategoryVolumeChangeMask @503
;	XAudioGetVoiceCategoryVolume @504
;	XAudioSetVoiceCategoryVolume @505
;	XAudioBeginDigitalBypassMode @506
;	XAudioEndDigitalBypassMode @507
;	XAudioSubmitDigitalPacket @508
;	XAudioQueryDriverPerformance @509
;	XAudioGetRenderDriverThread @510
;	XAudioGetSpeakerConfig @511
;	XAudioSetSpeakerConfig @512
;	NicSetUnicastAddress @513
;	NicAttach @514
;	NicDetach @515
;	NicXmit @516
;	NicUpdateMcastMembership @517
;	NicFlushXmitQueue @518
;	NicShutdown @519
;	NicGetLinkState @520
;	NicGetStats @521
;	NicGetOpt @522
;	NicSetOpt @523
;	DrvSetSysReqCallback @524
;	DrvSetUserBindingCallback @525
;	DrvSetContentStorageCallback @526
;	DrvSetAutobind @527
;	DrvGetContentStorageNotification @528
;	MtpdBeginTransaction @529
;	MtpdCancelTransaction @530
;	MtpdEndTransaction @531
;	MtpdGetCurrentDevices @532
;	MtpdReadData @533
;	MtpdReadEvent @534
;	MtpdResetDevice @535
;	MtpdSendData @536
;	MtpdVerifyProximity @537
;	XUsbcamSetCaptureMode @538
;	XUsbcamGetConfig @539
;	XUsbcamSetConfig @540
;	XUsbcamGetState @541
;	XUsbcamReadFrame @542
;	XUsbcamSnapshot @543
;	XUsbcamSetView @544
;	XUsbcamGetView @545
;	XUsbcamCreate @546
;	XUsbcamDestroy @547
;	XMACreateContext @548
;	XMAInitializeContext @549
;	XMAReleaseContext @550
;	XMAEnableContext @551
;	XMADisableContext @552
;	XMAGetOutputBufferWriteOffset @553
;	XMASetOutputBufferReadOffset @554
;	XMAGetOutputBufferReadOffset @555
;	XMASetOutputBufferValid @556
;	XMAIsOutputBufferValid @557
;	XMASetInputBuffer0Valid @558
;	XMAIsInputBuffer0Valid @559
;	XMASetInputBuffer1Valid @560
;	XMAIsInputBuffer1Valid @561
;	XMASetInputBuffer0 @562
;	XMASetInputBuffer1 @563
;	XMAGetPacketMetadata @564
;	XMABlockWhileInUse @565
;	XMASetLoopData @566
;	XMASetInputBufferReadOffset @567
;	XMAGetInputBufferReadOffset @568
;	ExIsBetaFeatureEnabled @569
;	XeKeysGetFactoryChallenge @570
;	XeKeysSetFactoryResponse @571
;	XeKeysInitializeFuses @572
;	XeKeysSaveBootLoader @573
;	XeKeysSaveKeyVault @574
;	XeKeysGetStatus @575
;	XeKeysGeneratePrivateKey @576
;	XeKeysGetKeyProperties @577
;	XeKeysSetKey @578
;	XeKeysGenerateRandomKey @579
;	XeKeysGetKey @580
;	XeKeysGetDigest @581
;	XeKeysGetConsoleID @582
;	XeKeysGetConsoleType @583
;	XeKeysQwNeRsaPrvCrypt @584
;	XeKeysHmacSha @585
;	XInputdPassThroughRFCommand @586
;	XeKeysAesCbc @587
;	XeKeysDes2Cbc @588
;	XeKeysDesCbc @589
;	XeKeysObscureKey @590
;	XeKeysHmacShaUsingKey @591
;	XeKeysSaveBootLoaderEx @592
;	XeKeysAesCbcUsingKey @593
;	XeKeysDes2CbcUsingKey @594
;	XeKeysDesCbcUsingKey @595
;	XeKeysObfuscate @596
;	XeKeysUnObfuscate @597
;	XeKeysConsolePrivateKeySign @598
;	XeKeysConsoleSignatureVerification @599
;	XeKeysVerifyRSASignature @600
;	StfsCreateDevice @601
;	StfsControlDevice @602
;	VdSwap @603
;	HalFsbInterruptCount @604
;	XeKeysSaveSystemUpdate @605
;	XeKeysLockSystemUpdate @606
;	XeKeysExecute @607
;	XeKeysGetVersions @608
;	XInputdPowerDownDevice @609
;	AniBlockOnAnimation @610
;	AniTerminateAnimation @611
;	XUsbcamReset @612
;	AniSetLogo @613
;	KeCertMonitorData @614
;	HalIsExecutingPowerDownDpc @615
;	VdInitializeEDRAM @616
;	VdRetrainEDRAM @617
;	VdRetrainEDRAMWorker @618
;	VdHSIOTrainCount @619
;	HalGetPowerUpCause @620
;	VdHSIOTrainingStatus @621
;	RgcBindInfo @622
;	VdReadEEDIDBlock @623
;	VdEnumerateVideoModes @624
;	VdEnableHDCP @625
;	VdRegisterHDCPNotification @626
;	HidReadMouseChanges @627
;	DumpSetCollectionFacility @628
;	XexTransformImageKey @629
;	XAudioOverrideSpeakerConfig @630
;	XInputdReadTextKeystroke @631
;	DrvXenonButtonPressed @632
;	DrvBindToUser @633
;	XexGetModuleImportVersions @634
;	RtlComputeCrc32 @635
;	XeKeysSetRevocationList @636
;	HalRegisterPowerDownCallback @637
;	VdGetDisplayDiscoveryData @638
;	XInputdSendStayAliveRequest @639
;	XVoicedSendVPort @640
;	XVoicedGetBatteryStatus @641
;	XInputdFFGetDeviceInfo @642
;	XInputdFFSetEffect @643
;	XInputdFFUpdateEffect @644
;	XInputdFFEffectOperation @645
;	XInputdFFDeviceControl @646
;	XInputdFFSetDeviceGain @647
;	XInputdFFCancelIo @648
;	XInputdFFSetRumble @649
;	NtAllocateEncryptedMemory @650
;	NtFreeEncryptedMemory @651
;	XeKeysExSaveKeyVault @652
;	XeKeysExSetKey @653
;	XeKeysExGetKey @654
;	DrvSetDeviceConfigChangeCallback @655
;	DrvDeviceConfigChange @656
;	HalRegisterHdDvdRomNotification @657
;	XeKeysSecurityInitialize @658
;	XeKeysSecurityLoadSettings @659
;	XeKeysSecuritySaveSettings @660
;	XeKeysSecuritySetDetected @661
;	XeKeysSecurityGetDetected @662
;	XeKeysSecuritySetActivated @663
;	XeKeysSecurityGetActivated @664
;	XeKeysReserved665 @665
;	XeKeysReserved666 @666
;	XeKeysGetProtectedFlag @667
;	XeKeysSetProtectedFlag @668
;	KeEnablePFMInterrupt @669
;	KeDisablePFMInterrupt @670
;	KeSetProfilerISR @671
;	VdStartDisplayDiscovery @672
;	VdSetHDCPRevocationList @673
;	XeKeysGetUpdateSequence @674
;	XeKeysDvdAuthExActivate @675
;	KeGetImagePageTableEntry @676
;	HalRegisterBackgroundModeTransitionCallback @677
;	AniStartBootAnimation @678
;	HalClampUnclampOutputDACs @679
;	HalPowerDownToBackgroundMode @680
;	HalNotifyAddRemoveBackgroundTask @681
;	HalCallBackgroundModeNotificationRoutines @682
;	HalFsbResetCount @683
;	HalGetMemoryInformation @684
;	XInputdGetLastTextInputTime @685
;	VdEnableWMAProOverHDMI @686
;	XeKeysRevokeSaveSettings @687
;	XInputdSetTextMessengerIndicator @688
;	MicDeviceRequest @689
;	XeKeysGetMediaID @690
;	XeKeysReserved665 @691
;	KeGetVidInfo @692
;	HalNotifyBackgroundModeTransitionComplete @693
;	IoAcquireCancelSpinLock @694
;	IoReleaseCancelSpinLock @695
;	NtCancelIoFile @696
;	NtCancelIoFileEx @697
;	HalFinalizePowerLossRecovery @698
;	HalSetPowerLossRecovery @699
;	ExReadModifyWriteXConfigSettingUlong @700
;	HalRegisterXamPowerDownCallback @701
;	ExCancelAlarm @702
;	ExInitializeAlarm @703
;	ExSetAlarm @704
;	XexActivationGetNonce @705
;	XexActivationSetLicense @706
;	IptvSetBoundaryKey @707
;	IptvSetSessionKey @708
;	IptvVerifyOmac1Signature @709
;	IptvGetAesCtrTransform @710
;	SataCdRomRecordReset @711
;	XInputdSetTextDeviceKeyLocks @712
;	XInputdGetTextDeviceKeyLocks @713
;	XexActivationVerifyOwnership @714
;	XexDisableVerboseDbgPrint @715
;	SvodCreateDevice @716
;	RtlCaptureStackBackTrace @717
;	XeKeysRevokeUpdateDynamic @718
;	XexImportTraceEnable @719
;	ExRegisterXConfigNotification @720
;	XeKeysSecuritySetStat @721
;	VdQueryRealVideoMode @722
;	XexSetExecutablePrivilege @723
;	XAudioSuspendRenderDriverClients @724
;	IptvGetSessionKeyHash @725
;	VdSetCGMSState @726
;	VdSetSCMSState @727
;	KeFlushMultipleTb @728
;	VdGetOption @729
;	VdSetOption @730
;	UsbdBootEnumerationDoneEvent @731
;	StfsDeviceErrorEvent @732
;	ExTryToAcquireReadWriteLockExclusive @733
;	ExTryToAcquireReadWriteLockShared @734
;	XexSetLastKdcTime @735
;	XInputdControl @736
;	RmcDeviceRequest @737
;	LDIResetDecompression @738
;	NicRegisterDevice @739
;	UsbdAddDeviceComplete @740
;	UsbdCancelAsyncTransfer @741
;	UsbdGetDeviceSpeed @742
;	UsbdGetDeviceTopology @743
;	UsbdGetEndpointDescriptor @744
;	UsbdIsDeviceAuthenticated @745
;	UsbdOpenDefaultEndpoint @746
;	UsbdOpenEndpoint @747
;	UsbdQueueAsyncTransfer @748
;	UsbdQueueCloseDefaultEndpoint @749
;	UsbdQueueCloseEndpoint @750
;	UsbdRemoveDeviceComplete @751
;	KeRemoveQueueApc @752
;	UsbdDriverLoadRequiredEvent @753
;	UsbdGetRequiredDrivers @754
;	UsbdRegisterDriverObject @755
;	UsbdUnregisterDriverObject @756
;	UsbdResetDevice @758
;	UsbdGetDeviceDescriptor @759
;	NomnilGetExtension @760
;	NomnilStartCloseDevice @761
;	WifiBeginAuthentication @762
;	WifiCheckCounterMeasures @763
;	WifiChooseAuthenCipherSetFromBSSID @764
;	WifiCompleteAuthentication @765
;	WifiGetAssociationIE @766
;	WifiOnMICError @767
;	WifiPrepareAuthenticationContext @768
;	WifiRecvEAPOLPacket @769
;	WifiDeduceNetworkType @770
;	NicUnregisterDevice @771
;	DumpXitThread @772
;	XInputdSetWifiChannel @773
;	NomnilSetLed @774
;	WifiCalculateRegulatoryDomain @775
;	WifiSelectAdHocChannel @776
;	WifiChannelToFrequency @777
;	MmGetPoolPagesType @778
;	ExExpansionInstall @779
;	ExExpansionCall @780
;	PsCamDeviceRequest @781
;	McaDeviceRequest @782
;	DetroitDeviceRequest @783
;	XeCryptSha256Init @784
;	XeCryptSha256Update @785
;	XeCryptSha256Final @786
;	XeCryptSha256 @787
;	XeCryptSha384Init @788
;	XeCryptSha384Update @789
;	XInputdGetDevicePid @790
;	HalGetNotedArgonErrors @791
;	XeCryptSha384Final @792
;	HalReadArgonEeprom @793
;	HalWriteArgonEeprom @794
;	XeKeysFcrtLoad @795
;	XeKeysFcrtSave @796
;	XeKeysFcrtSet @797
;	XeCryptSha384 @798
;	XeCryptSha512Init @799
;	XAudioRegisterRenderDriverMECClient @800
;	XAudioUnregisterRenderDriverMECClient @801
;	XAudioCaptureRenderDriverFrame @802
;	XeCryptSha512Update @803
;	XeCryptSha512Final @804
;	XeCryptSha512 @805
;	XeCryptBnQwNeCompare @806
;	XVoicedGetDirectionalData @807
;	DrvSetMicArrayStartCallback @808
;	DevAuthGetStatistics @809
;	NullCableRequest @810
;	XeKeysRevokeIsDeviceRevoked @811
;	DumpUpdateDumpSettings @812
;	EtxConsumerDisableEventType @813
;	EtxConsumerEnableEventType @814
;	EtxConsumerProcessLogs @815
;	EtxConsumerRegister @816
;	EtxConsumerUnregister @817
;	EtxProducerLog @818
;	EtxProducerLogV @819
;	EtxProducerRegister @820
;	EtxProducerUnregister @821
;	EtxConsumerFlushBuffers @822
;	EtxProducerLogXwpp @823
;	EtxProducerLogXwppV @824
;	UsbdEnableDisableRootHubPort @825
;	EtxBufferRegister @826
;	EtxBufferUnregister @827
;	DumpRegisterDedicatedDataBlock @828
;	XeKeysDvdAuthExSave @829
;	XeKeysDvdAuthExInstall @830
;	XexShimDisable @831
;	XexShimEnable @832
;	XexShimEntryDisable @833
;	XexShimEntryEnable @834
;	XexShimEntryRegister @835
;	XexShimLock @836
;	XboxKrnlVersion4Digit @837
;	XeKeysObfuscateEx @838
;	XeKeysUnObfuscateEx @839
;	XexTitleHash @840
;	XexTitleHashClose @841
;	XexTitleHashContinue @842
;	XexTitleHashOpen @843
;	XAudioGetRenderDriverTic @844
;	XAudioEnableDucker @845
;	XAudioSetDuckerLevel @846
;	XAudioIsDuckerEnabled @847
;	XAudioGetDuckerLevel @848
;	XAudioGetDuckerThreshold @849
;	XAudioSetDuckerThreshold @850
;	XAudioGetDuckerAttackTime @851
;	XAudioSetDuckerAttackTime @852
;	XAudioGetDuckerReleaseTime @853
;	XAudioSetDuckerReleaseTime @854
;	XAudioGetDuckerHoldTime @855
;	XAudioSetDuckerHoldTime @856
;	DevAuthShouldAlwaysEnforce @857
;	XAudioGetUnderrunCount @858
;	DrvSetAudioLatencyCallback @859
;	XVoicedIsActiveProcess @860
;	KeExecuteOnProtectedStack @861
;	XeKeysVerifyPIRSSignature @862
;	XeCryptAesCtr @863
;	XeCryptAesCbcMac @864
;	XeCryptAesDmMac @865
;	EmaExecute @866
;	XeKeysGetTruncatedSecondaryConsoleId @867
;	ExFreeDebugPool @868
;	VdQueryVideoCapabilities @869
;	UsbdGetDeviceRootPortType @870
;	VdGet3dVideoFormat @871
;	VdGetWSS2Data @872
;	VdSet3dVideoFormat @873
;	VdSetWSS2Data @874
;	XexReserveCodeBuffer @875
;	XexCommitCodeBuffer @876
;	RtlSetVectoredExceptionHandler @877
;	RtlClearVectoredExceptionHandler @878
;	XAudioSetProcessFrameCallback @879
;	UsbdGetRootHubDeviceNode @880
;	UsbdGetPortDeviceNode @881
;	UsbdGetNatalHub @882
;	UsbdGetNatalHardwareVersion @883
;	UsbdNatalHubRegisterNotificationCallback @884
;	KeCallAndBlockOnDpcRoutine @885
;	KeCallAndWaitForDpcRoutine @886
;	TidDeviceRequest @887
;	DmPrintData @888
;	VdSetStudioRGBMode @889
;	UsbdTitleDriverResetAllUnrecognizedPorts @890
;	UsbdTitleDriverSetUnrecognizedPort @891
;	UsbdResetEndpoint @892
;	UsbdSetTimer @893
;	UsbdCancelTimer @894
;	UsbdQueueIsochTransfer @895
;	KeSetPageRelocationCallback @896
;	XexRegisterUsermodeModule @897
;	SerenityDongleRequest @898
;	TitleDeviceAuthRequest @899
;	KeRegisterSwapNotification @900
;	XInputdGetFailedConnectionOrBind @901
;	XInputdSetFailedConnectionOrBindCallback @902
;	XInputdSetMinMaxAuthDelay @904
;	VgcHandler_SetHandlers @905
;	VvcHandlerCancelTransfers @906
;	VvcHandlerRetrieveVoiceExtension @907
;	VeSetHandlers @916
;	HalConfigureVeDevice @917

```

`XenonDumper/libs/xkelib/syssock.h`:

```h
#ifndef _SYSTEM_SOCKET_H
#define _SYSTEM_SOCKET_H

#define _USE_SYS_SOCKET_REPLACEMENT

#define CUR_VER 0x20352400   //  (((XboxKrnlVersion->Major&0xF)<<28) | ((XboxKrnlVersion->Minor)<<24) | ((XboxKrnlVersion->Build &0xFFFF)<<8) | ((XboxKrnlVersion->Qfe&0xFF)))

#ifdef _USE_SYS_SOCKET_REPLACEMENT
	#define WSAStartup(x,a)						NetDll_WSAStartupEx(XNCALLER_SYSAPP, 2, a, CUR_VER) // x may always need to be 2... just sayin
	#define WSACleanup()						NetDll_WSACleanup(XNCALLER_SYSAPP)
	#define socket(a,t,p)						NetDll_socket(XNCALLER_SYSAPP, a, t ,p)
	#define closesocket(s)						NetDll_closesocket(XNCALLER_SYSAPP, s)
	#define shutdown(s,h)						NetDll_shutdown(XNCALLER_SYSAPP, s, h)
	#define ioctlsocket(s,c,a)					NetDll_ioctlsocket(XNCALLER_SYSAPP, s, c, a)
	#define setsockopt(s,lv,o,v,l)				NetDll_setsockopt(XNCALLER_SYSAPP, s, lv, o, v, l)
	#define getsockopt(s,lv,o,v,l)				NetDll_getsockopt(XNCALLER_SYSAPP, s, lv, o, v, l)
	#define getsockname(s,n,l)					NetDll_getsockname(XNCALLER_SYSAPP, s, n, l)
	#define getpeername(s,n,l)					NetDll_getpeername(XNCALLER_SYSAPP, s, n, l)
	#define bind(s,n,l)							NetDll_bind(XNCALLER_SYSAPP, s, n, l)
	#define connect(s,n,l)						NetDll_connect(XNCALLER_SYSAPP, s, n, l)
	#define listen(s,b)							NetDll_listen(XNCALLER_SYSAPP, s, b)
	#define accept(s,a,l)						NetDll_accept(XNCALLER_SYSAPP, s, a, l)
	#define select(n,r,w,e,t)					NetDll_select(XNCALLER_SYSAPP, n, r, w, e, t)
	#define WSAGetOverlappedResult(s,o,c,w,f)	NetDll_WSAGetOverlappedResult(XNCALLER_SYSAPP, s, o, c, w, f)
	#define WSACancelOverlappedIO(s)			NetDll_WSACancelOverlappedIO(XNCALLER_SYSAPP, s)	
	#define recv(s,b,l,f)						NetDll_recv(XNCALLER_SYSAPP, s, b, l, f)
	#define WSARecv(s,b,c,r,f,o,d) 				NetDll_WSARecv(XNCALLER_SYSAPP, s, b, c, r, f, o, d)
	#define recvfrom(s,b,l,f,a,n)				NetDll_recvfrom(XNCALLER_SYSAPP, s, b, l, f, a, n)
	#define WSARecvFrom(s,b,c,n,f,a,m,o,r)		NetDll_WSARecvFrom(XNCALLER_SYSAPP, s, b, c, n, f, a, m, o, r)
	#define send(s,b,l,f)						NetDll_send(XNCALLER_SYSAPP, s, b, l, f)
	#define WSASend(s,l,b,n,f,p,c)				NetDll_WSASend(XNCALLER_SYSAPP, s, l, b, n, f, p, c)
	#define sendto(s,b,l,f,a,n)					NetDll_sendto(XNCALLER_SYSAPP, s, b, l, f, a, n)
	#define WSASendTo(s,b,c,n,f,a,l,o,r)		NetDll_WSASendTo(XNCALLER_SYSAPP, s, b, c, n, f, a, l, o, r)
	#define WSAEventSelect(s,h,n)				NetDll_WSAEventSelect(XNCALLER_SYSAPP, s, h, n)

	#define inet_addr(c)						NetDll_inet_addr(c)
	#define WSAGetLastError						NetDll_WSAGetLastError
	#define WSASetLastError						NetDll_WSASetLastError
	#define WSACreateEvent						NetDll_WSACreateEvent
	#define WSACloseEvent						NetDll_WSACloseEvent
	#define WSASetEvent							NetDll_WSASetEvent
	#define WSAResetEvent						NetDll_WSAResetEvent
	#define WSAWaitForMultipleEvents			NetDll_WSAWaitForMultipleEvents
	#define __WSAFDIsSet						NetDll___WSAFDIsSet

	#define XNetStartup(p)						NetDll_XNetStartupEx(XNCALLER_SYSAPP, p, CUR_VER) // there is also an actual NetDll_XNetStartup
	#define XNetGetEthernetLinkStatus()			NetDll_XNetGetEthernetLinkStatus(XNCALLER_SYSAPP)
	#define XNetDnsLookup(h,e,x)				NetDll_XNetDnsLookup(XNCALLER_SYSAPP, h, e, x)
	#define XNetDnsRelease(h)					NetDll_XNetDnsRelease(XNCALLER_SYSAPP, h)

	#define XNetCleanup							NetDll_XNetCleanup(XNCALLER_SYSAPP)
	#define XNetRandom(p,c)						NetDll_XNetRandom(XNCALLER_SYSAPP, p, c)
	#define XNetCreateKey(k,p)					NetDll_XNetCreateKey(XNCALLER_SYSAPP, k, p)
	#define XNetRegisterKey(k,p)				NetDll_XNetRegisterKey(XNCALLER_SYSAPP, k, p)
	#define XNetUnregisterKey(k)				NetDll_XNetUnregisterKey(XNCALLER_SYSAPP, k)
	#define XNetServerToInAddr(i,s,p)			NetDll_XNetServerToInAddr(XNCALLER_SYSAPP, i, s, p)
	#define XNetTsAddrToInAddr(t,i,s,p)			NetDll_XNetTsAddrToInAddr(XNCALLER_SYSAPP, t, i, s, p)
	#define XNetInAddrToServer(i,o)				NetDll_XNetInAddrToServer(XNCALLER_SYSAPP, i, o)
	#define XNetInAddrToString(i,p,c)			NetDll_XNetInAddrToString(XNCALLER_SYSAPP, i, p, c)
	#define XNetUnregisterInAddr(i)				NetDll_XNetUnregisterInAddr(XNCALLER_SYSAPP, i)
	#define XNetXnAddrToMachineId(x,i)			NetDll_XNetXnAddrToMachineId(XNCALLER_SYSAPP, x, i)
	#define XNetGetConnectStatus(i)				NetDll_XNetGetConnectStatus(XNCALLER_SYSAPP, i)
	#define XNetQosListen(k,p,c,b,f)			NetDll_XNetQosListen(XNCALLER_SYSAPP, k, p, c, b, f)
	#define XNetQosLookup(c,x,k,y,i,a,s,b,f,h,q)		NetDll_XNetQosLookup(XNCALLER_SYSAPP, c,x,k,y,i,a,s,b,f,h,q)
	#define XNetQosServiceLookup(f,h,q)			NetDll_XNetQosServiceLookup(XNCALLER_SYSAPP,f,h,q)
	#define XNetQosRelease(q)					NetDll_XNetQosRelease(XNCALLER_SYSAPP,q)
	#define XNetGetTitleXnAddr(x)				NetDll_XNetGetTitleXnAddr(XNCALLER_SYSAPP,x)
	#define XNetGetDebugXnAddr(x)				NetDll_XNetGetDebugXnAddr(XNCALLER_SYSAPP,x)
	#define XNetGetBroadcastVersionStatus(r)	NetDll_XNetGetBroadcastVersionStatus(XNCALLER_SYSAPP,r)
	#define XNetQosGetListenStats(k,l)			NetDll_XNetQosGetListenStats(XNCALLER_SYSAPP,k,l)
	#define XNetGetOpt(i,v,c)					NetDll_XNetGetOpt(XNCALLER_SYSAPP,i,v,c)
	#define XNetSetOpt(i,v,c)					NetDll_XNetSetOpt(XNCALLER_SYSAPP,i,v,c)
	

#endif // _USE_SYS_SOCKET_REPLACEMENT


#endif	//_SYSTEM_SOCKET_H

///* new ones */

//NetDll_WSAGetLastError // 0x1B
//NetDll___WSAFDIsSet // 0x22
//NetDll_XNetStartup // 0x33
//NetDll_XNetRandom // 0x35
//NetDll_XNetCreateKey // 0x36
//NetDll_XNetRegisterKey // 0x37
//NetDll_XNetUnregisterKey // 0x38
//NetDll_XNetXnAddrToInAddr // 0x39
//NetDll_XNetServerToInAddr // 0x3A
//NetDll_XNetInAddrToXnAddr // 0x3C
//NetDll_XNetUnregisterInAddr // 0x3F
//NetDll_XNetXnAddrToMachineId // 0x40
//NetDll_XNetConnect // 0x41
//NetDll_XNetGetConnectStatus // 0x42
//NetDll_XNetQosListen // 0x45
//NetDll_XNetQosLookup // 0x46
//NetDll_XNetQosServiceLookup // 0x47
//NetDll_XNetQosRelease // 0x48
//NetDll_XNetGetTitleXnAddr // 0x49
//NetDll_XNetReplaceKey // 0x51


```

`XenonDumper/libs/xkelib/xam/_xamext.h`:

```h
#ifndef __XAMEXT_DEFINES_H
#define __XAMEXT_DEFINES_H

#pragma comment(lib, "xamext")
#pragma comment(lib, "xav")

#include "xamXContent.h"
#include "xamTask.h"
#include "xamNet.h"
#include "xamExpEnum.h"

typedef PVOID                           HXAMAPP, *PHXAMAPP;

typedef enum
{
	XHUDOPENSTATE_NONE = 0x0,
	XHUDOPENSTATE_HALF = 0x1,
	XHUDOPENSTATE_FULL = 0x2,
	XHUDOPENSTATE_ERROR = 0x3,
	XHUDOPENSTATE_NUI_FULL = 0x4,
	XHUDOPENSTATE_NUI_ERROR = 0x5,
	XHUDOPENSTATE_COUNT = 0x6,
} XHUDOPENSTATE, *PXHUDOPENSTATE;

typedef enum {
	XNOTIFYUI_TYPE_FRIENDONLINE = 0,
	XNOTIFYUI_TYPE_GAMEINVITE = 1,
	XNOTIFYUI_TYPE_FRIENDREQUEST = 2,
	XNOTIFYUI_TYPE_GENERIC = 3, // mail icon
	XNOTIFYUI_TYPE_MULTIPENDING = 4,
	XNOTIFYUI_TYPE_PERSONALMESSAGE = 5,
	XNOTIFYUI_TYPE_SIGNEDOUT = 6,
	XNOTIFYUI_TYPE_SIGNEDIN = 7,
	XNOTIFYUI_TYPE_SIGNEDINLIVE = 8,
	XNOTIFYUI_TYPE_SIGNEDINNEEDPASS = 9,
	XNOTIFYUI_TYPE_CHATREQUEST = 10,
	XNOTIFYUI_TYPE_CONNECTIONLOST = 11,
	XNOTIFYUI_TYPE_DOWNLOADCOMPLETE = 12,
	XNOTIFYUI_TYPE_SONGPLAYING = 13, // music icon
	XNOTIFYUI_TYPE_PREFERRED_REVIEW = 14, // happy face icon
	XNOTIFYUI_TYPE_AVOID_REVIEW = 15, // sad face icon
	XNOTIFYUI_TYPE_COMPLAINT = 16, // hammer icon
	XNOTIFYUI_TYPE_CHATCALLBACK = 17,
	XNOTIFYUI_TYPE_REMOVEDMU = 18,
	XNOTIFYUI_TYPE_REMOVEDGAMEPAD = 19,
	XNOTIFYUI_TYPE_CHATJOIN = 20,
	XNOTIFYUI_TYPE_CHATLEAVE = 21,
	XNOTIFYUI_TYPE_GAMEINVITESENT = 22,
	XNOTIFYUI_TYPE_CANCELPERSISTENT = 23,
	XNOTIFYUI_TYPE_CHATCALLBACKSENT = 24,
	XNOTIFYUI_TYPE_MULTIFRIENDONLINE = 25,
	XNOTIFYUI_TYPE_ONEFRIENDONLINE = 26,
	XNOTIFYUI_TYPE_ACHIEVEMENT = 27,
	XNOTIFYUI_TYPE_HYBRIDDISC = 28,
	XNOTIFYUI_TYPE_MAILBOX = 29, // mailbox icon
	// missing a few
	XNOTIFYUI_TYPE_EXCLAIM = 34, // exclamation mark icon
	XNOTIFYUI_TYPE_KICKED = 0x34,
	XNOTIFYUI_TYPE_GARBAGE = 68, // garbage can icon
} XNOTIFYQUEUEUI_TYPE;

typedef enum {
	XNOTIFYUI_PRIORITY_LOW = 0,
	XNOTIFYUI_PRIORITY_DEFAULT = 1,
	XNOTIFYUI_PRIORITY_HIGH = 2,
	XNOTIFYUI_PRIORITY_PERSISTENT = 3,
} XNOTIFYUI_PRIORITY;

typedef enum {
	XTILETYPE_ACHIEVEMENT = 0x0,
	XTILETYPE_GAME_ICON = 0x1,
	XTILETYPE_GAMER_TILE = 0x2,
	XTILETYPE_GAMER_TILE_SMALL = 0x3,
	XTILETYPE_LOCAL_GAMER_TILE = 0x4,
	XTILETYPE_LOCAL_GAMER_TILE_SMALL = 0x5,
	XTILETYPE_BKGND = 0x6,
	XTILETYPE_AWARDED_GAMER_TILE = 0x7,
	XTILETYPE_AWARDED_GAMER_TILE_SMALL = 0x8,
	XTILETYPE_GAMER_TILE_BY_IMAGE_ID = 0x9,
	XTILETYPE_PERSONAL_GAMER_TILE = 0xA,
	XTILETYPE_PERSONAL_GAMER_TILE_SMALL = 0xB,
	XTILETYPE_GAMER_TILE_BY_KEY = 0xC,
	XTILETYPE_AVATAR_GAMER_TILE = 0xD,
	XTILETYPE_AVATAR_GAMER_TILE_SMALL = 0xE,
	XTILETYPE_AVATAR_FULL_BODY = 0xF,
} XTILETYPE;

typedef enum {
	XamLoaderStateNone = 0x0,
	XamLoaderStateBooting = 0x1,
	XamLoaderStateTitleUnloading = 0x2,
	XamLoaderStateTitleLoading = 0x3,
	XamLoaderStateTitleStartup = 0x4,
	XamLoaderStateTitleRunning = 0x5,
} XamLoaderState;

typedef enum  {
	XAM_DEFAULT_IMAGE_SYSTEM = 0x0, 	// "xam" 		"defaultsystemimage.png"
	XAM_DEFAULT_IMAGE_DASHICON = 0x1,	// "xam" 		"dashicon.png"
	XAM_DEFAULT_IMAGE_SETTINGS = 0x2,	// "shrdres" 	"ico_64x_licensestore.png"
	XAM_DEFAULT_IMAGE_ID_COUNT = 0x3,
} XAM_DEFAULT_IMAGE_ID;

typedef enum _DVD_MEDIA_TYPES {
	DVD_MEDIA_TYPE_NONE					= 0x00,
	DVD_MEDIA_TYPE_GAME_XBOX_360		= 0x01,
	DVD_MEDIA_TYPE_GAME_XBOX_ORIGINAL	= 0x02,
	DVD_MEDIA_TYPE_UNKNOWN				= 0x03,
	DVD_MEDIA_TYPE_DVD_AUDIO			= 0x04,
	DVD_MEDIA_TYPE_DVD_MOVIE			= 0x05,
	DVD_MEDIA_TYPE_CD_VIDEO				= 0x06,
	DVD_MEDIA_TYPE_CD_AUDIO				= 0x07,
	DVD_MEDIA_TYPE_CD_DATA				= 0x08,
	DVD_MEDIA_TYPE_GAME_MOVIE_HYBRID	= 0x09,
	DVD_MEDIA_TYPE_DVD_HD				= 0x0A,
} DVD_MEDIA_TYPES;

typedef enum _DVD_TRAY_STATE {
	DVD_TRAY_STATE_EMPTY = 0,
	DVD_TRAY_STATE_CLOSING = 1,
	DVD_TRAY_STATE_OPEN = 2,
	DVD_TRAY_STATE_OPENING = 3,
	DVD_TRAY_STATE_CLOSED = 4,
	DVD_TRAY_STATE_ERROR = 5
} DVD_TRAY_STATE;

typedef enum _STAGING_MODE {
	STAGING_MODE_PRODUCTION = 0x0,
	STAGING_MODE_STAGING = 0x1,
} STAGING_MODE;

// for use with XamDbgSetOutputLevel and XamDbgSetBreakLevel
typedef enum _XDEBUG_LEVEL {
	XDEBUG_ERROR = 1, // ERR
	XDEBUG_WARN, // WRN
	XDEBUG_TRACE, // TRC
	XDEBUG_ENT, // ENT
	XDEBUG_EXT, // EXT
} XDEBUG_LEVEL;

typedef enum _XAM_CACHE_FILE_TYPE {
	XAM_CACHE_ALL = 0x0,
	XAM_CACHE_GAME_TILE = 0x1,				// 'TT'
	XAM_CACHE_ACHIEVEMENT_TILE = 0x2,		// 'AT'
	XAM_CACHE_GAMER_TILE = 0x3,				// 'GT'
	XAM_CACHE_GAMER_TILE_SMALL = 0x4,		// ''
	XAM_CACHE_CUSTOM_GAMER_TILE = 0x5,		// 'CT'
	XAM_CACHE_CUSTOM_GAMER_TILE_SMALL = 0x6,// ''
	XAM_CACHE_FRIEND_MUTE_LIST = 0x7,		// 'FM'
	XAM_CACHE_TICKETS = 0x8,				// 'TK'
	XAM_CACHE_TITLE_NAMES = 0x9,			// 'TN'
	XAM_CACHE_RECENT_PLAYERS = 0xA,			// ''
	XAM_CACHE_TITLE_UPDATE = 0xB,			// 'TU'
	XAM_CACHE_SYSTEM_UPDATE = 0xC,			// 'SU'
	XAM_CACHE_DASHBOARD_APP = 0xD,			// 'DA'
	XAM_CACHE_SPA_FILE = 0xE,				// 'SP'
	XAM_CACHE_GAME_INVITE = 0xF,			// 'GI'
	XAM_CACHE_GAMER_TAG = 0x10,				// 'GA'
	XAM_CACHE_MESSENGER_BUDDIES = 0x11,		// 'MB'
	XAM_CACHE_QOS_HISTORY = 0x12,			// 'QH'
	XAM_CACHE_PROFILE_SETTINGS = 0x13,		// 'PS'
	XAM_CACHE_AVATAR_GAMER_TILE = 0x14,		// 'AV'
	XAM_CACHE_CERT_STORAGE = 0x15,			// 'CA'
	XAM_CACHE_VALIDATE_CERT = 0x16,			// 'VC'
	XAM_CACHE_NUI_SESSION = 0x17,			// 'NS'
	XAM_CACHE_NUI_BIOMETRIC = 0x18,			// 'NB'
	XAM_CACHE_NUI_TROUBLESHOOTER = 0x19,	// 'TS'
	XAM_CACHE_NUI_HIVE_SETTING = 0x1A,		// 'NH'
	XAM_CACHE_XLFS_UPLOADER = 0x1B,			// 'XL'
	XAM_CACHE_DASH_CACHESEEDFILE = 0x1C,	// 'DC'
	XAM_CACHE_ZEST_AUTHENTICATION = 0x1D,	// 'ZA'
	XAM_CACHE_XSTS_TOKEN = 0x1E,			// 'XT'
	XAM_CACHE_LIVEID_DEVICE = 0x1F,			// 'LD'
	XAM_CACHE_CURRENCY_FORMATTING = 0x20,	// 'CF'
} XAM_CACHE_FILE_TYPE;

typedef VOID (CALLBACK *PFNMSGBOXRETURN)(
	IN      INT                         iButtonPressed,
	OUT     PXHUDOPENSTATE              pHudRestoreState
	);

typedef struct _XUIBRUSH*	HXUIBRUSH;

typedef DWORD (*MBOXRESULT)(DWORD r3);

//#define XSSUI_FLAGS_LOCALSIGNINONLY                 0x00000001
//#define XSSUI_FLAGS_SHOWONLYONLINEENABLED           0x00000002
//#define XSSUI_FLAGS_ALLOW_SIGNOUT                   0x00000004
#define XSSUI_FLAGS_NUI			0x00000008
//#define XSSUI_FLAGS_DISALLOW_PLAYAS                 0x00000010
//#define XSSUI_FLAGS_ADDUSER                         0x00010000
//#define XSSUI_FLAGS_ENABLE_GUEST                    0x00080000
//#define XSSUI_FLAGS_CONVERTOFFLINETOGUEST           0x00400000
//#define XSSUI_FLAGS_DISALLOW_GUEST                  0x01000000
//													0x24030000
//													0x20000000
//													0x04000000
//													0x00020000
//													0x00010000 XSSUI_FLAGS_ADDUSER

typedef struct _XSHOWSIGNINUI_PARAMS { 
	DWORD dwTrackingID; // 0x0 sz:0x4
	DWORD dwUserIndex; // 0x4 sz:0x4
	DWORD cPanes; // 0x8 sz:0x4
	DWORD dwFlags; // 0xC sz:0x4
	PXOVERLAPPED pOverlapped; // 0x10 sz:0x4
} XSHOWSIGNINUI_PARAMS, *PXSHOWSIGNINUI_PARAMS; // size 20
C_ASSERT(sizeof(XSHOWSIGNINUI_PARAMS) == 0x14);

typedef struct _MESSAGEBOX_PARAMS { 
	DWORD dwTrackingID; // 0x0 sz:0x4
	DWORD dwUserIndex; // 0x4 sz:0x4
	DWORD eHudType; // 0x8 sz:0x4 enum HUDSCENE
	wchar_t szTitle[0x2B]; // 0xC sz:0x56
	wchar_t szText[0x180]; // 0x62 sz:0x300
	// 2 bytes align when packed
	DWORD cButtons; // 0x364 sz:0x4
	wchar_t rgButtons[3][0x2B]; // 0x368 sz:0x102
	// 2 bytes align when packed
	DWORD dwFocusButton; // 0x46C sz:0x4
	DWORD dwFlags; // 0x470 sz:0x4
	PMESSAGEBOX_RESULT pResult; // 0x474 sz:0x4
	PXOVERLAPPED pOverlapped; // 0x478 sz:0x4
} MESSAGEBOX_PARAMS, *PMESSAGEBOX_PARAMS; // size 1148
C_ASSERT(sizeof(MESSAGEBOX_PARAMS) == 0x47C);

typedef struct _XINPUT_DEVICE_STATS {
	DWORD BatteryLevel; // 0x0 sz:0x4
	DWORD BatteryType; // 0x4 sz:0x4
	DWORD SignalStrength; // 0x8 sz:0x4
	DWORD DeviceType; // 0xC sz:0x4
	DWORD DevicePort; // 0x10 sz:0x4
	DWORD DeviceVersion; // 0x14 sz:0x4
	int Jumped; // 0x18 sz:0x4
} XINPUT_DEVICE_STATS, *PXINPUT_DEVICE_STATS; // size 28
C_ASSERT(sizeof(XINPUT_DEVICE_STATS) == 0x1C);

typedef struct _XINPUT_CAPABILITIES_EX { 
	BYTE Type; // 0x0 sz:0x1
	BYTE SubType; // 0x1 sz:0x1
	WORD Flags; // 0x2 sz:0x2
	XINPUT_GAMEPAD Gamepad; // 0x4 sz:0xC
	XINPUT_VIBRATION Vibration; // 0x10 sz:0x4
	WORD Vid; // 0x14 sz:0x2
	WORD Pid; // 0x16 sz:0x2
	WORD Revision; // 0x18 sz:0x2
	BYTE OriginalSubType; // 0x1A sz:0x1
	BYTE ExtraFlags; // 0x1B sz:0x1
	DWORD Xid; // 0x1C sz:0x4
} XINPUT_CAPABILITIES_EX, *PXINPUT_CAPABILITIES_EX; // size 32
C_ASSERT(sizeof(XINPUT_CAPABILITIES_EX) == 0x20);

// see xinputdefs.h in sdk for others
// #define XINPUT_FLAG_ANYUSER		0x40000000
#define XINPUT_FLAG_SYSTEMAPP	0x80000000

// XamUserGetDeviceContext categories
#define DRV_CATEGORY_INPUT		0x0
#define DRV_CATEGORY_OUTPUT		0x1

typedef enum {
	XDASHLAUNCHDATA_COMMAND_DEFAULT = 0, // 14719
	XDASHLAUNCHDATA_COMMAND_SIGNUP = 1,
	XDASHLAUNCHDATA_COMMAND_NETWORKTROUBLESHOOTER = 2,
	XDASHLAUNCHDATA_COMMAND_ARCADE = 3,
	XDASHLAUNCHDATA_COMMAND_MEMORY = 4,
	//XDASHLAUNCHDATA_COMMAND_ = 5,
	XDASHLAUNCHDATA_COMMAND_MUSICPLAYER = 6, // 14719
	XDASHLAUNCHDATA_COMMAND_PLAYDVD = 7, // 14719
	XDASHLAUNCHDATA_COMMAND_MEDIA_CENTER = 8, // 14719
	XDASHLAUNCHDATA_COMMAND_MEDIANETWORKTROUBLESHOOTER = 9,
	XDASHLAUNCHDATA_COMMAND_ACCOUNTMANAGE_HOME = 10,
	XDASHLAUNCHDATA_COMMAND_ACCOUNTMANAGE_PRIVACY = 11,
	XDASHLAUNCHDATA_COMMAND_ACCOUNTMANAGE_ACCEPTTOU = 12,
	XDASHLAUNCHDATA_COMMAND_ACCOUNTMANAGE_BILLING = 13,
	XDASHLAUNCHDATA_COMMAND_GAMES_DEMOS = 14,
	XDASHLAUNCHDATA_COMMAND_GAMES_TRAILERS = 15,
	XDASHLAUNCHDATA_COMMAND_RETURNFROMENTRYPOINT_MUSIC = 16,
	XDASHLAUNCHDATA_COMMAND_MARKETPLACE_TILES = 17,
	XDASHLAUNCHDATA_COMMAND_SETTINGS = 18,
	XDASHLAUNCHDATA_COMMAND_RETURNFROMENTRYPOINT_GAMES = 19,
	XDASHLAUNCHDATA_COMMAND_FAMILY_SETTINGS = 20, // 14719
	XDASHLAUNCHDATA_COMMAND_RETURNFROMENTRYPOINT_SYSTEM = 21,
	XDASHLAUNCHDATA_COMMAND_OOBE_WELCOME = 22,
	XDASHLAUNCHDATA_COMMAND_GAMES_ARCADE = 23,
	//XDASHLAUNCHDATA_COMMAND_ = , // 24-38
	XDASHLAUNCHDATA_COMMAND_VIDEOPLAYER = 39, // 14719
	XDASHLAUNCHDATA_COMMAND_PICTURE_VIEWER = 44, // 14719
	XDASHLAUNCHDATA_COMMAND_SYSTEM_SETTINGS = 47, // 14719
} XDASHLAUNCHDATA_COMMAND;

typedef struct _XDASHLAUNCHDATA { 
	DWORD dwVersion; // 0x0 sz:0x4
	DWORD dwCommand; // 0x4 sz:0x4
	DWORD dwUserIndex; // 0x8 sz:0x4
	BYTE Reserved[0x3F0]; // 0xC sz:0x3F0
} XDASHLAUNCHDATA, *PXDASHLAUNCHDATA; // size 1020
C_ASSERT(sizeof(XDASHLAUNCHDATA) == 0x3FC);

typedef struct _FU_LAUNCH_DATA { 
	DWORD Source; // 0x0 sz:0x4
	DWORD Reason; // 0x4 sz:0x4
	DWORD LiveEnabled; // 0x8 sz:0x4
	BYTE Padding[0x1F0]; // 0xC sz:0x1F0
	char XBE[0x200]; // 0x1FC sz:0x200
} FU_LAUNCH_DATA, *PFU_LAUNCH_DATA; // size 1020
C_ASSERT(sizeof(FU_LAUNCH_DATA) == 0x3FC);

typedef struct _XLAUNCHDATA_EPIX { 
	DWORD dwID; // 0x0 sz:0x4
	DWORD dwUserIndex; // 0x4 sz:0x4
	DWORD dwFlags; // 0x8 sz:0x4
	wchar_t Param[0x80]; // 0xC sz:0x100
} XLAUNCHDATA_EPIX, *PXLAUNCHDATA_EPIX; // size 268
C_ASSERT(sizeof(XLAUNCHDATA_EPIX) == 0x10C);

typedef struct _XLAUNCHDATA_CAFEBABE { 
	DWORD dwID; // 0x0 sz:0x4 << 0xCAFEBABE
	BYTE Param[0x2C]; // 0x4 sz:0x
	DWORD deviceId; // 0x30 sz:0x4
} XLAUNCHDATA_CAFEBABE, *PXLAUNCHDATA_CAFEBABE; // size 52
C_ASSERT(sizeof(XLAUNCHDATA_CAFEBABE) == 0x34);

// from Xna_TitleLauncher.xex
typedef struct _XLAUNCHDATA_CAFEBABE2 { 
	XLAUNCHDATA_CAFEBABE param; // 0x0
	DWORD unused; // 0x34
	QWORD qwUnk; // 0x38
	BYTE bParm[0x134]; // 0x40
	DWORD dwUnk; // 0x174
} XLAUNCHDATA_CAFEBABE2, *PXLAUNCHDATA_CAFEBABE2; // size 376
C_ASSERT(sizeof(XLAUNCHDATA_CAFEBABE2) == 0x178);

// from Xna_TitleLauncher.xex
typedef struct _XLAUNCHDATA_CAFEBABE3 { 
	XLAUNCHDATA_CAFEBABE param; // 0x0
	DWORD unused; // 0x34
	BYTE bParm[0x200]; // 0x38
} XLAUNCHDATA_CAFEBABE3, *PXLAUNCHDATA_CAFEBABE3; // size 568
C_ASSERT(sizeof(XLAUNCHDATA_CAFEBABE3) == 0x238);

typedef struct _XDASHLAUNCHDATA_XAMUIAPP { 
	DWORD dwID; // 0x0 sz:0x4
	BYTE Reserved[0x3EC]; // 0x4 sz:0x3EC
} XDASHLAUNCHDATA_XAMUIAPP, *PXDASHLAUNCHDATA_XAMUIAPP; // size 1008
C_ASSERT(sizeof(XDASHLAUNCHDATA_XAMUIAPP) == 0x3F0);

typedef struct _XLAUNCHDATA_DASHAPP { 
	char AppName[0x40]; // 0x0 sz:0x40
	DWORD AppParamsSize; // 0x40 sz:0x4
	BYTE AppParams[0x200]; // 0x44 sz:0x200
} XLAUNCHDATA_DASHAPP, *PXLAUNCHDATA_DASHAPP; // size 580
C_ASSERT(sizeof(XLAUNCHDATA_DASHAPP) == 0x244);

typedef struct _XAVATAR_AWARDS_COUNTER { 
	BYTE bEarned; // 0x0 sz:0x1
	BYTE bPossible; // 0x1 sz:0x1
} XAVATAR_AWARDS_COUNTER, *PXAVATAR_AWARDS_COUNTER; // size 2
C_ASSERT(sizeof(XAVATAR_AWARDS_COUNTER) == 0x2);

typedef struct _XUSER_TITLE_PLAYED { 
	DWORD dwTitleId; // 0x0 sz:0x4
	DWORD dwAchievementsPossible; // 0x4 sz:0x4
	DWORD dwAchievementsEarned; // 0x8 sz:0x4
	DWORD dwCredPossible; // 0xC sz:0x4
	DWORD dwCredEarned; // 0x10 sz:0x4
	WORD wReservedAchievementCount; // 0x14 sz:0x2
	XAVATAR_AWARDS_COUNTER AllAvatarAwards; // 0x16 sz:0x2
	XAVATAR_AWARDS_COUNTER MaleAvatarAwards; // 0x18 sz:0x2
	XAVATAR_AWARDS_COUNTER FemaleAvatarAwards; // 0x1A sz:0x2
	DWORD dwReservedFlags; // 0x1C sz:0x4
	FILETIME ftLastLoaded; // 0x20 sz:0x8
	wchar_t wszTitleName[0x40]; // 0x28 sz:0x80
} XUSER_TITLE_PLAYED, *PXUSER_TITLE_PLAYED; // size 168
C_ASSERT(sizeof(XUSER_TITLE_PLAYED) == 0xA8);


// *********** PACKING STARTS HERE **************//
#pragma pack(push, 1)
// *********** PACKING STARTS HERE **************//
typedef struct _XAMACCOUNTINFO { 
	DWORD dwReserved; // 0x0 sz:0x4
	DWORD dwLiveFlags; // 0x4 sz:0x4
	WCHAR szGamerTag[0x10]; // 0x8 sz:0x20
	XUID xuidOnline; // 0x28 sz:0x8
	DWORD dwCachedUserFlags; // 0x30 sz:0x4
	DWORD dwOnlineServiceNetworkID; // 0x34 sz:0x4
	BYTE rgbPasscode[0x4]; // 0x38 sz:0x4
	char szOnlineDomain[0x14]; // 0x3C sz:0x14
	char szOnlineKerberosRealm[0x18]; // 0x50 sz:0x18
	BYTE rgbOnlineKey[0x10]; // 0x68 sz:0x10
	char szUserPassportMembername[0x72]; // 0x78 sz:0x72
	char rgcUserPassportPassword[0x20]; // 0xEA sz:0x20
	char szOwnerPassportMembername[0x72]; // 0x10A sz:0x72
} XAMACCOUNTINFO, *PXAMACCOUNTINFO; // size 380
C_ASSERT(sizeof(XAMACCOUNTINFO) == 0x17C);

typedef struct _PROFILEENUMRESULT { 
	XUID xuidOffline; // 0x0 sz:0x8
	XAMACCOUNTINFO xai; // 0x8 sz:0x17C
	DWORD DeviceID; // 0x184 sz:0x4
} PROFILEENUMRESULT, *PPROFILEENUMRESULT; // size 392
C_ASSERT(sizeof(PROFILEENUMRESULT) == 0x188);




// *********** PACKING ENDS HERE **************//
#pragma pack(pop)
// *********** PACKING ENDS HERE **************//


#ifdef __cplusplus
extern "C" {
#endif
	
	NTSYSAPI
	EXPORTNUM(309)
	HRESULT
	NTAPI
	XNetLogonGetMachineID(
		IN OUT	QWORD* pqwMachineID
	);

	NTSYSAPI
	EXPORTNUM(400)
	HRESULT // returns 0 on success
	NTAPI
	XamInputGetCapabilities(
		IN		DWORD dwUserIndex,
		IN		DWORD dwFlags, // see XINPUT_FLAG
		IN OUT	PXINPUT_CAPABILITIES capStruct
	);

	NTSYSAPI
	EXPORTNUM(401)
	HRESULT
	NTAPI
	XamInputGetState(
		IN		DWORD dwUserIndex,
		IN		DWORD dwDeviceContext, // || flags, games call with this set to 1 to get controller response which seems to be device type 1
		IN OUT	XINPUT_STATE* pInputState
	);
	
	NTSYSAPI
	EXPORTNUM(402)
	HRESULT // returns 0 on success
	NTAPI
	XamInputSetState(
		IN		DWORD dwUserIndex,
		IN		DWORD dwFlags,
		IN		XINPUT_STATE* pInputState, // prob not the right struct!!
		IN 		BYTE bAmplitude,
		IN 		BYTE bFrequency,
		IN 		BYTE bOffset
	);

	NTSYSAPI
	EXPORTNUM(407)
	DWORD
	NTAPI
	XamInputGetDeviceStats(
		IN		DWORD dwUserIndex,
		OUT		PXINPUT_DEVICE_STATS pDeviceStats
	);

	NTSYSAPI
	EXPORTNUM(419)
	DWORD // returns TitleId
	NTAPI
	XamLoaderGetMediaInfo(
		IN OUT	PDWORD pdwMediaType,
		IN OUT	PDWORD pdwTitleId OPTIONAL
	);

	NTSYSAPI
	EXPORTNUM(420)
	VOID
	NTAPI
	XamLoaderLaunchTitle(
		IN		LPCSTR szLaunchPath,
		IN		DWORD dwFlags
		);

	NTSYSAPI
	EXPORTNUM(421)
	NTSTATUS
	NTAPI
	XamLoaderLaunchTitleEx(
		IN		LPCSTR szLaunchPath,
		IN		LPCSTR szMountPath,
		IN		LPCSTR szCmdLine,
		IN		DWORD dwFlags
		);

	NTSYSAPI
	EXPORTNUM(422)
	NTSTATUS
	NTAPI
	XamLoaderSetLaunchData(
		IN		PVOID launchData,
		IN		DWORD cbLaunchData
	);

	NTSYSAPI
	EXPORTNUM(424)
	NTSTATUS
	NTAPI
	XamLoaderGetLaunchData(
		IN		PVOID launchData,
		IN		DWORD cbLaunchData
	);

	NTSYSAPI
	EXPORTNUM(426)
	DVD_TRAY_STATE
	NTAPI
	XamLoaderGetDvdTrayState(
		VOID
	);

	// UNTESTED!!!
	NTSYSAPI
	EXPORTNUM(427)
	HRESULT
	NTAPI
	XamLoaderGetGameInfo(
		IN OUT	LPCWSTR wszTitleName,
		IN		DWORD dwTitleId,
		OUT		PBYTE* ppbUnk,
		OUT		QWORD* pqwUnk
	);

	NTSYSAPI
	EXPORTNUM(429)
	VOID
	NTAPI
	XamLoaderSetSpindleSpeed(
		IN		int Speed
	);

	NTSYSAPI
	EXPORTNUM(430)
	HRESULT
	NTAPI
	XamTaskCreateQueue(
		IN		PHXAMTASKQUEUE hxamtask
	);

	NTSYSAPI
	EXPORTNUM(431)
	HRESULT
	NTAPI
	XamTaskSchedule(
		IN		PXAMTASKPROC pxamtaskproc,
		IN		PVOID pvParam,
		IN		PXAMTASKATTRIBUTES pxamtaskattribs,
		IN		PHXAMTASK phxamtask
	);

	NTSYSAPI
	EXPORTNUM(432)
	VOID
	NTAPI
	XamTaskReschedule(
		IN		HXAMTASK hxamtask
	);

	NTSYSAPI
	EXPORTNUM(433)
	VOID
	NTAPI
	XamTaskCloseHandle(
		IN		HXAMTASKOBJ hxamtask
	);

	NTSYSAPI
	EXPORTNUM(434)
	VOID
	NTAPI
	XamTaskCancel(
		IN		HXAMTASK hxamtask
	);

	NTSYSAPI
	EXPORTNUM(435)
	BOOL
	NTAPI
	XamTaskShouldExit(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(436)
	VOID
	NTAPI
	XamTaskWaitOnCompletion(
		IN		HXAMTASK hxamtask
	);
	
	NTSYSAPI
	EXPORTNUM(437)
	VOID
	NTAPI
	XamTaskModify(
		IN		HXAMTASK hxamtask,
		IN		DWORD dwFlags,
		IN		PXAMTASKPROC pxamtaskproc,
		IN		PVOID pvParam,
		IN		PXAMTASKATTRIBUTES pxamtaskattribs
	);

	NTSYSAPI
	EXPORTNUM(438)
	HXAMTASK
	NTAPI
	XamTaskGetCurrentTask(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(439)
	HRESULT
	NTAPI
	XamTaskGetAttributes(
		IN		HXAMTASK hxamtask,
		IN OUT	PXAMTASKATTRIBUTES pxamtaskattribs
	);
	
	NTSYSAPI
	EXPORTNUM(440)
	DWORD
	NTAPI
	XamExecutingOnBehalfOfTitle(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(443)
	BOOL
	NTAPI
	XamIsSystemTitleId(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(444)
	BOOL
	NTAPI
	XamLoaderIsTitleTerminatePending(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(446)
	DWORD
	NTAPI
	XamLoaderGetPriorTitleId(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(447)
	BOOL
	NTAPI
	XamIsXbox1TitleId(
		IN		DWORD dwTitleId
	);

	NTSYSAPI
	EXPORTNUM(450)
	HRESULT
	NTAPI
	XamTaskGetStatus(
		IN		HXAMTASK hxamtask
	);

	NTSYSAPI
	EXPORTNUM(453)
	NTSTATUS
	NTAPI
	XamGetDefaultSystemImage( // gets "defaultsystemimage.png"
		OUT		PVOID* pImageSource,
		OUT		PDWORD pdwImageLen
	);

	NTSYSAPI
	EXPORTNUM(457)
	NTSTATUS
	NTAPI
	XamGetDefaultImage(
		IN		XAM_DEFAULT_IMAGE_ID index,
		OUT		PVOID* pImageSource,
		OUT		PDWORD pdwImageLen
	);

	NTSYSAPI
	EXPORTNUM(458)
	NTSTATUS // always returns 0
	NTAPI
	XamMuteSound(
		IN		DWORD dwXuiElementMute
	);
	
	NTSYSAPI
	EXPORTNUM(460)
	VOID
	NTAPI
	XamSetDashContext(
		IN		DWORD dwDashContext
	);

	NTSYSAPI
	EXPORTNUM(461)
	DWORD
	NTAPI
	XamGetDashContext(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(462)
	BOOL
	NTAPI
	XamIsCurrentTitleDash(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(463)
	DWORD
	NTAPI
	XamGetCurrentTitleId(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(464)
	VOID
	NTAPI
	XamLoaderSetCurrentTitleIsDash(
		IN		DWORD dwTitleId
	);
	
	NTSYSAPI
	EXPORTNUM(465)
	VOID
	NTAPI
	XamAllocHeapFreeSpace(
		IN		DWORD heapID // enum  XAMALLOC_HEAP_ID
	);

	NTSYSAPI
	EXPORTNUM(466)
	VOID
	NTAPI
	XamSetDashContextEx(
		IN		DWORD dwDashContext,
		IN		QWORD qwSessionId,
		IN		PBYTE pbSessionKey // 0x10 byte in
	);

	NTSYSAPI
	EXPORTNUM(467)
	DWORD // returns dwDashContext
	NTAPI
	XamGetDashContextEx(
		OUT		PQWORD pqwSessionId OPTIONAL,
		OUT		PBYTE pbSessionKey // 0x10 byte out
	);

	NTSYSAPI
	EXPORTNUM(468)
	VOID
	NTAPI
	XamSetHudContext(
		IN		DWORD dwHudContext
	);

	NTSYSAPI
	EXPORTNUM(469)
	DWORD
	NTAPI
	XamGetHudContext(
		VOID
	);
	
	NTSYSAPI
	EXPORTNUM(480)
	NTSTATUS
	NTAPI
	XamDbgPrint(
		IN		DWORD dwAppId,
		IN		const char* s,
		...
	);
	
	NTSYSAPI
	EXPORTNUM(481)
	VOID
	NTAPI
	XamDbgSetOutputLevel(
		IN		DWORD dwAppId, // 0xFE is the only one that sets XDebugOutLevel
		IN		XDEBUG_LEVEL level	// 0-0xF
	);
	
	NTSYSAPI
	EXPORTNUM(482)
	VOID
	NTAPI
	XamDbgSetBreakLevel(
		IN		DWORD dwAppId, // 0xFE is the only one that sets XDebugOutLevel
		IN		XDEBUG_LEVEL level	// 0-0xF
	);

	NTSYSAPI
	EXPORTNUM(483)
	NTSTATUS
	NTAPI
	XamLoaderGetMediaInfoEx(
		IN OUT	PDWORD pdwMediaType,
		IN OUT	PDWORD pdwTitleId,
		IN OUT	PDWORD pdwTypeExt // not entirely clear what this is, needs testing
	);

	NTSYSAPI
	EXPORTNUM(490)
	HRESULT
	NTAPI
	XamAlloc(
		IN      DWORD dwFlags,
		IN      DWORD cb,
		OUT     PVOID* ppv
	);

	NTSYSAPI
	EXPORTNUM(491)
	HRESULT
	NTAPI
	XamAllocEx( // only use for physical allocations
		IN      DWORD dwFlagsEx,
		IN      DWORD dwFlags,
		IN      DWORD cb,
		OUT     PVOID* ppv
	);

	NTSYSAPI
	EXPORTNUM(492)
	VOID
	NTAPI
	XamFree(
		IN     PVOID pv
	);

	// already in xam.h
	// NTSYSAPI
	// EXPORTNUM(500)
	// HRESULT
	// NTAPI
	// XMsgInProcessCall(
		// IN		HXAMAPP hxamapp,
		// IN		DWORD dwMessage,
		// IN OUT	UINT_PTR param1,
		// IN OUT	UINT_PTR param2
		// );

	// already in sdk xam.h
	// NTSYSAPI
	// EXPORTNUM(501)
	// HRESULT
	// NTAPI
	// XMsgCompleteIORequest(
		// IN		PXOVERLAPPED pOverlapped,
		// IN		DWORD dwStatus,
		// IN		DWORD dwExtendedError,
		// IN		ULONG ulBytesTransferred
	// );

	// already in sdk xam.h
	// NTSYSAPI
	// EXPORTNUM(502)
	// HRESULT
	// NTAPI
	// XMsgSystemProcessCall(
		// IN		HXAMAPP hxamapp,
		// IN		DWORD dwMessage,
		// IN		PVOID pUserBuffer,
		// IN		DWORD cbUserBuffer
	// );

	// already in sdk xam.h
	// NTSYSAPI
	// EXPORTNUM(503)
	// HRESULT
	// NTAPI
	// XMsgStartIORequest(
		// IN		HXAMAPP hxamapp,
		// IN		DWORD dwMessage,
		// IN		PXOVERLAPPED pOverlapped,
		// IN		PVOID pUserBuffer,
		// IN		DWORD cbUserBuffer
	// );

	// already in sdk xam.h
	// NTSYSAPI
	// EXPORTNUM(504)
	// HRESULT
	// NTAPI
	// XMsgCancelIORequest(
		// IN		PXOVERLAPPED pOverlapped,
		// IN		BOOL fWait
	// );

	NTSYSAPI
	EXPORTNUM(512)
	BOOL
	NTAPI
	XamFeatureEnabled(
		IN		DWORD dwFeature
	);
	
	NTSYSAPI
	EXPORTNUM(520)
	NTSTATUS
	NTAPI
	XamUserGetDeviceContext(
		IN		DWORD dwUserIndex,
		IN		DWORD dwCategory,
		IN OUT	PDWORD DeviceContext
	);

	NTSYSAPI
	EXPORTNUM(521)
	NTSTATUS
	NTAPI
	XamUserLookupDevice( 
		IN	DWORD dwDeviceContext,
		IN  DWORD dwCategory,
		OUT PDWORD pdwUserIndex
	);

	NTSYSAPI
	EXPORTNUM(522)
	HRESULT
	NTAPI
	XamUserGetXUID(
		IN		DWORD dwUserIndex,
		IN		DWORD unk,
		OUT		PXUID onlineOut
	);

	NTSYSAPI
	EXPORTNUM(523)
	HRESULT
	NTAPI
	XamUserLogon(
		IN		CONST PXUID rgUsers,
		IN		DWORD dwFlags,
		IN		PXOVERLAPPED pOverlapped OPTIONAL
	);

	// already in sdk xam.h
	// NTSYSAPI
	// EXPORTNUM(526)
	// DWORD
	// NTAPI
	// XamUserGetName(
		// IN		DWORD dwUserIndex,
		// IN		LPSTR pUserName,
		// IN		DWORD cchUserName
	// );

	NTSYSAPI
	EXPORTNUM(527)
	LPCWSTR
	NTAPI
	XamLookupCommonStringByIndex(
		IN		DWORD dwIndex
	);

	// already in sdk xam.h
	// NTSYSAPI
	// EXPORTNUM(528)
	// XAMUSER_SIGNIN_STATE
	// NTAPI
	// XamUserGetSigninState(
		// IN		DWORD dwUserIndex
	// );

	NTSYSAPI
	EXPORTNUM(530)
	DWORD
	NTAPI
	XamUserCheckPrivilege(
		IN		DWORD dwUserIndex,
		IN		DWORD dwPrivilegeType,
		OUT		PBOOL pfResult
	);

	NTSYSAPI
	EXPORTNUM(537)
	DWORD
	NTAPI
	XamUserReadProfileSettings(
		DWORD dwTitleId,
		DWORD dwUserIndexRequester,
		DWORD dwNumFor,
		const PXUID pxuidFor,
		DWORD dwNumSettingIds,
		const PDWORD pdwSettingIds,
		PDWORD pcbResults,
		PXUSER_READ_PROFILE_SETTING_RESULT pResults, // in xonline.h
		PXOVERLAPPED pXOverlapped OPTIONAL
	);

	NTSYSAPI
	EXPORTNUM(542)
	BOOL
	NTAPI
	XamUserIsGuest(
		IN		DWORD dwUserIndex
	);

	NTSYSAPI
	EXPORTNUM(545)
	BOOL
	NTAPI
	XamUserIsOnlineEnabled(
		IN		DWORD dwUserIndex
	);

	NTSYSAPI
	EXPORTNUM(551)
	NTSTATUS
	NTAPI
	XamUserGetSigninInfo(
		IN		DWORD userIndex,
		IN		DWORD dwFlags,
		IN OUT	PXUSER_SIGNIN_INFO xSigningInfo
	);

	// already in sdk xam.h
	// NTSYSAPI
	// EXPORTNUM(556)
	// HRESULT
	// NTAPI
	// XamUserGetUsersMissingAvatars(
		// OUT		DWORD* pdwUserIndexMask,
		// IN OUT	PXOVERLAPPED pOverlapped OPTIONAL
	// );

	NTSYSAPI
	EXPORTNUM(561)
	DWORD
	NTAPI
	XamProfileCreateEnumerator(
		IN		XCONTENTDEVICEID DeviceID,
		OUT		PHANDLE phEnum
	);

	NTSYSAPI
	EXPORTNUM(562)
	DWORD
	NTAPI
	XamProfileEnumerate(
		IN		HANDLE hEnum,
		IN		DWORD dwFlags,
		OUT		PPROFILEENUMRESULT pProfileEnumResult,
		IN OUT	PXOVERLAPPED pOverlapped OPTIONAL
	);

	NTSYSAPI
	EXPORTNUM(580)
	HRESULT
	NTAPI
	XamAppLoad(
		IN		LPCSTR appName,
		IN		DWORD dwUserIndex,
		IN		PVOID params,
		IN		DWORD sz,
		IN OUT	PXOVERLAPPED xov,
		OUT		PVOID CSystemAppEntry
	);

	NTSYSAPI
	EXPORTNUM(581)
	VOID
	NTAPI
	XamAppUnloadSelf(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(587)
	HRESULT
	NTAPI
	XamRegisterSysApp(
		IN		HANDLE hInstDLL,
		IN		BYTE AppId,
		IN		PVOID MessageProc, // function
		IN		BOOL ignoreHudMessages
	);

	NTSYSAPI
	EXPORTNUM(588)
	HRESULT
	NTAPI
	XamUnregisterSysApp(
		IN		HANDLE hInstDLL,
		IN		BYTE AppId,
		IN		int xuiModuleId // used by XuiUnregisterModuleId
	);

	// already in sdk xam.h
	// NTSYSAPI
	// EXPORTNUM(590)
	// DWORD
	// NTAPI
	// XamCreateEnumeratorHandle(
		// IN		DWORD dwUserIndex,
		// IN		HXAMAPP hxamapp,
		// IN		DWORD dwMsgIDEnum,
		// IN		DWORD dwMsgIDCloseEnum,
		// IN		DWORD cbSizeOfPrivateEnumStructure,
		// IN		DWORD cItemsRequested,
		// IN		DWORD dwEnumFlags,
		// OUT		PHANDLE phEnum
	// );

	// already in sdk xam.h
	// NTSYSAPI
	// EXPORTNUM(591)
	// DWORD
	// NTAPI
	// XamGetPrivateEnumStructureFromHandle(
		// IN		HANDLE hEnum,
		// OUT		PVOID* ppvObj
	// );

	// NOT TESTED, same as XEnumerate with dwFlags added
	NTSYSAPI
	EXPORTNUM(592)
	DWORD
	NTAPI
	XamEnumerate(
		IN		HANDLE hEnum,
		IN		DWORD dwFlags,
		IN OUT  PVOID pvBuffer,
		IN		DWORD cbBuffer,
		OUT		PDWORD pcItemsReturned OPTIONAL,
		IN		PXOVERLAPPED pOverlapped OPTIONAL
	);

	NTSYSAPI
	EXPORTNUM(599)
	DWORD
	NTAPI
	XamContentLaunchImageFromFileInternal(
		IN		LPCSTR path,
		IN		LPCSTR xex
	);

	NTSYSAPI
	EXPORTNUM(602)
	DWORD
	NTAPI
	XamContentClose(
		IN		LPCSTR pszRootName, // pathtooriginalmapping
		IN OUT	PXOVERLAPPED pOverlapped OPTIONAL
	);

	NTSYSAPI
	EXPORTNUM(605)
	DWORD
	NTAPI
	XamContentCreateDeviceEnumerator(
		IN      DWORD dwContentTypes,
		IN      DWORD dwFlags,
		IN		DWORD cItem,
		OUT		PDWORD pcbBuffer,
		OUT		PHANDLE phEnum
	);

	NTSYSAPI
	EXPORTNUM(606)
	DWORD
	NTAPI
	XamContentGetDeviceData(
		IN		XCONTENTDEVICEID DeviceID,
		OUT		PXDEVICE_DATA pDeviceData
	);
	
	NTSYSAPI
	EXPORTNUM(607)
	DWORD
	NTAPI
	XamContentGetDeviceName(
		IN      XCONTENTDEVICEID            DeviceID,
		OUT     LPWSTR                      pwszName,
		IN      DWORD                       cchName
	);

	NTSYSAPI
	EXPORTNUM(615)
	HRESULT
	NTAPI
	XamContentFlush(
		IN      LPCSTR pszRootName,
		IN      PXOVERLAPPED pOverlapped OPTIONAL
	);

	NTSYSAPI
	EXPORTNUM(617)
	DWORD
	NTAPI
	XamContentOpenFile(
		IN		DWORD dwUserIndex,
		IN		LPCSTR pszRootName,
		IN		LPCSTR pszFileName,
		IN		DWORD dwContentFlags,
		IN		DWORD dwFileCacheSize,
		OUT		PDWORD pdwLicenseMask, OPTIONAL
		IN OUT	PXOVERLAPPED pOverlapped OPTIONAL
	);
	
	NTSYSAPI
	EXPORTNUM(619)
	DWORD
	NTAPI
	XamContentLockUnlockPackageHeaders(
		IN		PXCONTENT_MOUNTED_PACKAGE pMountedPackage,
		IN		BOOL fLock
	);

	NTSYSAPI
	EXPORTNUM(630)
	NTSTATUS
	NTAPI
	XamContentResolveInternal(
		PXCONTENT_DATA_INTERNAL pcdi,
		char *pszPath,
		DWORD cchPath,
		int fCreateDir,
		const char *pszRootName,
		PXOVERLAPPED overlapped
	);

	// untested
	NTSYSAPI
	EXPORTNUM(633)
	DWORD
	NTAPI
	XamContentAggregateCreateEnumerator(
		IN		XUID xuid,
		IN		XCONTENTDEVICEID DeviceId,
		IN		DWORD dwContentType,
		IN		DWORD dwTitleId,
		OUT		PHANDLE phEnum
	);
	
	NTSYSAPI
	EXPORTNUM(638)
	DWORD
	NTAPI
	XamContentClosePackageFile(
		IN		PXCONTENT_MOUNTED_PACKAGE pMountedPackage
	);

	NTSYSAPI
	EXPORTNUM(640)
	NTSTATUS
	NTAPI
	XamGetExecutionId(
		IN OUT	PXEX_EXECUTION_ID* xid
	);
	
	NTSYSAPI
	EXPORTNUM(642)
	DWORD
	NTAPI
	XamGetSystemVersion(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(648)
	DWORD
	NTAPI
	XamContentGetMountedPackageByRootName(
		IN		LPCSTR szRootName,
		IN		BOOL unk,
		IN OUT	PXCONTENT_MOUNTED_PACKAGE* ppMount
	);

	NTSYSAPI
	EXPORTNUM(650)
	DWORD
	NTAPI
	XamNotifyCreateListener(
		IN		QWORD qwAreas,
		IN		DWORD dwArea
	);

	// already in sdk xam.h
	// NTSYSAPI
	// EXPORTNUM(651)
	// BOOL
	// NTAPI
	// XNotifyGetNext(
		// IN		HANDLE hNotification,
		// IN		DWORD dwMsgFilter,
		// OUT		PDWORD pdwId,
		// OUT		PULONG_PTR pParam OPTIONAL
	// );

	// already in sdk xam.h
	// NTSYSAPI
	// EXPORTNUM(652)
	// VOID
	// NTAPI
	// XNotifyPositionUI(
		// IN    DWORD dwPosition
	// );

	// already in sdk xam.h
	// returns 0 on success, 0x65B on error
	// NTSYSAPI
	// EXPORTNUM(653)
	// DWORD
	// NTAPI
	// XNotifyDelayUI(
		// IN		ULONG ulMilliSeconds
	// );

	NTSYSAPI
	EXPORTNUM(654)
	DWORD
	NTAPI
	XNotifyBroadcast(
		IN		DWORD dwNotificationType,
		IN		PVOID pXndata
	);
	
	NTSYSAPI
	EXPORTNUM(656)
	VOID
	NTAPI
	XNotifyQueueUI(
		IN		XNOTIFYQUEUEUI_TYPE exnq,
		IN		DWORD dwUserIndex,
		IN		ULONGLONG qwAreas,
		IN		PWCHAR displayText,
		IN		PVOID contextData
	);

	NTSYSAPI
	EXPORTNUM(657)
	HANDLE
	NTAPI
	XamNotifyCreateListenerInternal(
		IN		ULONGLONG qwAreas,
		IN		BOOL fReceiveInternalNotifications,
		IN		DWORD dwArea // area is 9 or less
	);

	NTSYSAPI
	EXPORTNUM(658)
	VOID
	NTAPI
	XNotifyUISetOptions(
		IN		BOOL pfShow,
		IN		BOOL pfShowMovie,
		IN		BOOL pfPlaySound,
		IN		BOOL pfShowIPTV
	);

	NTSYSAPI
	EXPORTNUM(659)
	VOID
	NTAPI
	XNotifyUIGetOptions(
		IN OUT	BOOL* pfShow OPTIONAL,
		IN OUT	BOOL* pfShowMovie OPTIONAL,
		IN OUT	BOOL* pfPlaySound OPTIONAL,
		IN OUT	BOOL* pfShowIPTV OPTIONAL
	);

	NTSYSAPI
	EXPORTNUM(679)
	DWORD
	NTAPI
	XamUpdateGetCurrentSystemVersion(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(685)
	HRESULT // returns 0 on success
	NTAPI
	XamInputGetCapabilitiesEx(
		IN		DWORD unk1, // can be 0 or 1, anything else returns ERROR_NOT_SUPPORTED - likely DRV_CATEGORY
		IN		DWORD dwUserIndex,
		IN		DWORD dwFlags,	// see XINPUT_FLAG
		IN OUT	PXINPUT_CAPABILITIES_EX capStruct
	);

	NTSYSAPI
	EXPORTNUM(695)
	BOOL
	NTAPI
	XamCacheReset(
		IN		XAM_CACHE_FILE_TYPE FileType
	);

	NTSYSAPI
	EXPORTNUM(714)
	HRESULT
	NTAPI
	XamShowMessageBoxUI(
		IN		DWORD dwUserIndex,
		IN		LPCWSTR wszTitle,
		IN		LPCWSTR wszText,
		IN		DWORD cButtons,
		IN		LPCWSTR* pwszButtons OPTIONAL,
		IN		DWORD dwFocusButton,
		IN		DWORD dwFlags,
		OUT 	PMESSAGEBOX_RESULT pResult,
		IN OUT	PXOVERLAPPED pOverlapped OPTIONAL
	);

	NTSYSAPI
	EXPORTNUM(728)
	DWORD
	NTAPI
	XamShowPasscodeVerifyUI(
		IN		DWORD dwUserIndex,
		IN OUT	PDWORD pdwOutbuf,
		IN OUT	PXOVERLAPPED pOverlapped OPTIONAL
	);

	NTSYSAPI
	EXPORTNUM(745)
	HRESULT
	NTAPI
	XamShowMessageBox(
		IN		DWORD unk,
		IN		LPCWSTR wszTitle,
		IN		LPCWSTR wszText,
		IN		DWORD cButtons,
		IN		LPCWSTR* pwszButtons OPTIONAL,
		IN		DWORD dwFocusButton,
		IN		MBOXRESULT resFun,
		IN		DWORD dwFlags
	);

	NTSYSAPI
	EXPORTNUM(748)
	BOOL
	NTAPI
	XamIsUIActive(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(750)
	DWORD
	NTAPI
	XamUserCreateAchievementEnumerator(
		IN		DWORD dwTitleId,
		IN		DWORD dwUserIndex,
		IN		XUID xuidRequestee,
		IN		DWORD dwDetailFlags,
		IN		DWORD dwStartingIndex,
		IN		DWORD cItem,
		OUT		PDWORD pcbBuffer,
		OUT		PHANDLE ph
	);

	NTSYSAPI
	EXPORTNUM(754)
	DWORD
	NTAPI
	XamReadImage(
		IN		XTILETYPE eTileType,
		IN		DWORD dwTitleId,
		IN		DWORD dwIndex,				// Not 100% sure, needs to be verified
		IN		ULONGLONG ulImageId,		// Not 100% sure, needs to be verified
		OUT		HXUIBRUSH * hImageBrush
	);

	NTSYSAPI
	EXPORTNUM(755)
	DWORD
	NTAPI
	XamUserCreateTitlesPlayedEnumerator(
		IN		DWORD dwTitleId,
		IN		DWORD dwUserIndex,
		IN		XUID xuid,
		IN		DWORD dwStartingIndex,
		IN		DWORD cItem,
		OUT		PDWORD pcbBuffer,
		OUT		PHANDLE ph
	);

	NTSYSAPI
	EXPORTNUM(757)
	DWORD
	NTAPI
	XamReadTileToTexture(
		IN		XTILETYPE eTileType,
		IN		DWORD dwTitleId,
		IN		ULONGLONG qwImageId,
		IN		DWORD dwUserIndex,
		IN OUT	PBYTE pbTextureBuffer,
		IN		DWORD dwPitch,
		IN		DWORD dwHeight,
		IN OUT	PXOVERLAPPED pXOverlapped OPTIONAL
	);

	NTSYSAPI
	EXPORTNUM(795)
	DWORD
	NTAPI
	XamBuildResourceLocator(
		IN		HANDLE hHandle,
		IN		PWCHAR procName,
		IN		LPCWSTR pszResource,
		IN		LPWSTR pszResourceLocator,
		IN  	DWORD cchResourceLocator
	);

	NTSYSAPI
	EXPORTNUM(969)
	DWORD
	NTAPI
	XamHudGetUserIndex(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(992)
	BOOL
	NTAPI
	XamIsMessageBoxActive(
		VOID
	);
	
	NTSYSAPI
	EXPORTNUM(1036)
	BOOL
	NTAPI
	XamIsNuiUIActive(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(1133)
	HRESULT
	NTAPI
	XamShowPasscodeVerifyUIEx(
		IN		DWORD dwUserIndex,
		OUT		PDWORD pdwOutbuf,
		IN		DWORD optMask,
		IN OUT	PXOVERLAPPED pOverlapped OPTIONAL
	);
	
	// already in sdk xam.h
	// NTSYSAPI
	// EXPORTNUM(1183)
	// HRESULT
	// NTAPI
	// XMsgProcessRequest(
		// IN		HXAMAPP hxamapp,
		// IN		DWORD dwMessage,
		// IN		PVOID pvBuffer,
		// IN		DWORD cbBuffer,
		// IN OUT	PXOVERLAPPED pOverlapped
	// );

	NTSYSAPI
	EXPORTNUM(1191)
	XamLoaderState
	NTAPI
	XamLoaderGetState(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(1192)
	DWORD
	NTAPI
	XamTaskQueryProperty(
		IN		HXAMTASK hxamtask,
		IN		DWORD dwPropertyMask
	);

	NTSYSAPI
	EXPORTNUM(1212)
	HRESULT
	NTAPI
	XampXAuthStartup(
		IN		PVOID xas // actually PXAUTH_SETTINGS in xauth.h
	);
	
	NTSYSAPI
	EXPORTNUM(1213)
	VOID
	NTAPI
	XampXAuthShutdown(
		IN OUT	PDWORD unk OPTIONAL // if return is nonzero should use XampXAuthGetTitleBuffer
	);
	
	NTSYSAPI
	EXPORTNUM(1262)
	PVOID
	NTAPI
	XampXAuthGetTitleBuffer(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(1264)
	HRESULT
	NTAPI
	XamUserGetOnlineXUIDFromOfflineXUID(
		IN		XUID offline,
		OUT		PXUID onlineOut
	);

	NTSYSAPI
	EXPORTNUM(1265)
	BOOL
	NTAPI
	XamIsUserUsingMetricSystem(
		IN		DWORD dwUserIndex
	);

	NTSYSAPI
	EXPORTNUM(1285)
	BOOL
	NTAPI
	XamIsUIThread(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(1286)
	VOID
	XamInputSendXenonButtonPress(
		IN		DWORD dwUserIndex
	);

	NTSYSAPI
	EXPORTNUM(1553)
	NTSTATUS
	NTAPI
	XamContentGetDeviceVolumePath(
		IN		DWORD deviceId,
		OUT		PCHAR szDest,
		IN		DWORD dwDestLen,
		IN		BOOL appendBackslash
	);

	NTSYSAPI
	EXPORTNUM(1590)
	BOOL
	NTAPI
	XamNetworkStorageShouldHideFromTitle(
		IN		DWORD dwTitleId
	);

	NTSYSAPI
	EXPORTNUM(1625)
	NTSTATUS
	NTAPI
	XdfLaunchNewImageFromCache(// this is how XNA titles are started, imageName "xna_titlelauncher.xex" and XLAUNCHDATA_CAFEBABE
		IN		PCHAR imageName,
		IN		PVOID launchData,
		IN		DWORD cbLaunchData,
		IN 		DWORD dwFlags
	);
	
	// returns 0 on success, 0x65B on error
	NTSYSAPI
	EXPORTNUM(1671)
	DWORD
	NTAPI
	XamNotifyDelayUIInternal(
		IN		ULONG ulMilliSeconds
	);

	NTSYSAPI
	EXPORTNUM(1800)
	HRESULT
	NTAPI
	XamGetLiveHiveValueA(
		IN		LPCSTR szName,
		IN		LPSTR szValue,
		IN		DWORD cchValue,
		IN		DWORD unk,
		IN OUT	PXOVERLAPPED xov
	);
	
	NTSYSAPI
	EXPORTNUM(1801)
	HRESULT
	NTAPI
	XamGetLiveHiveValueW(
		IN		LPCWSTR szwName,
		IN		LPWSTR wcsValue,
		IN		DWORD cwchValue,
		IN		DWORD unk,
		IN OUT	PXOVERLAPPED xov
	);

	NTSYSAPI
	EXPORTNUM(1802)
	HRESULT
	NTAPI
	XamGetLiveHiveValueDuringLogonAttemptA(
		IN		LPCSTR szName,
		IN		LPSTR szValue,
		IN		DWORD cchValue,
		IN		DWORD unk
	);

	NTSYSAPI
	EXPORTNUM(1804)
	HRESULT
	NTAPI
	XamQueryLiveHiveA(
		IN		LPCSTR szName,
		IN		LPSTR szValue,
		IN		DWORD cchValue,
		IN OUT	PXOVERLAPPED xov
	);

	NTSYSAPI
	EXPORTNUM(1805)
	HRESULT
	NTAPI
	XamQueryLiveHiveW(
		IN		LPCWSTR szwName,
		IN		LPWSTR wcsValue,
		IN		DWORD cwchValue,
		IN OUT	PXOVERLAPPED xov
	);

	NTSYSAPI
	EXPORTNUM(1902)
	VOID
	NTAPI
	XamSetStagingMode(
		STAGING_MODE mode
	);

	NTSYSAPI
	EXPORTNUM(1903)
	STAGING_MODE
	NTAPI
	XamGetStagingMode(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(2011)
	NTSTATUS
	NTAPI
	XamLaunchAvatarEditor(
		IN		DWORD dwUserIndex,
		OUT		DWORD dwFlags,
		OUT		LPCWSTR param
	);

	NTSYSAPI
	EXPORTNUM(2105)
	VOID
	NTAPI
	XamLoaderRebootToDash(
		IN		PXDASHLAUNCHDATA launchdata
	);

	NTSYSAPI
	EXPORTNUM(2275)
	NTSTATUS
	NTAPI
	XamKinectGetHardwareType(
		IN OUT	PDWORD dwUnk1,
		IN OUT	PDWORD dwUnk2
	);

	NTSYSAPI
	EXPORTNUM(2491)
	DWORD
	NTAPI
	XamMediaVerificationCreate(
		IN		DWORD dwHardwareThread
	);

	NTSYSAPI
	EXPORTNUM(2492)
	DWORD
	NTAPI
	XamMediaVerificationClose(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(2493)
	DWORD
	NTAPI
	XamMediaVerificationVerify(
		IN		DWORD dwMilliseconds,
		IN		LPOVERLAPPED lpOverlapped OPTIONAL,
		IN		LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine OPTIONAL
	);

	NTSYSAPI
	EXPORTNUM(2494)
	DWORD
	NTAPI
	XamMediaVerificationFailedBlocks(
		IN OUT	PXSECURITY_FAILURE_INFORMATION pFailureInformation
	);

	NTSYSAPI
	EXPORTNUM(2505)
	HRESULT
	NTAPI
	XamBackgroundDownloadItemAdd(
		DWORD dwUserIdx,
		PBACKGROUND_DOWNLOAD_ITEM pbDlTask,
		PXOVERLAPPED overlapped
	);

	NTSYSAPI
	EXPORTNUM(2510)
	HRESULT
	NTAPI
	XamBackgroundDownloadItemToContentData(
		PBACKGROUND_DOWNLOAD_ITEM pbDlTask,
		DWORD unk,
		PXCONTENT_DATA_INTERNAL pxcData
	);

	NTSYSAPI
	EXPORTNUM(2524)
	BOOL
	NTAPI
	XamBackgroundDownloadSelectDevice(
		DWORD deviceType,
		ULONGLONG size,
		PDWORD deviceID
	);

	NTSYSAPI
	EXPORTNUM(2600)
	NTSTATUS
	NTAPI
	XamSwapDisc(
		IN		BYTE bDiscNum,
		IN		HANDLE hComplete,
		IN		CONST XSWAPDISC_ERROR_TEXT *pErrorStrings
	);

	NTSYSAPI
	EXPORTNUM(2803)
	DWORD
	NTAPI
	XamGetSecurityViolationsDetected(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(2851)
	HRESULT
	NTAPI
	XamTaskGetCompletionStatus(
		IN		HXAMTASK hxamtask
	);

	NTSYSAPI
	EXPORTNUM(2942)
	BOOL
	NTAPI
	XamIsSystemExperienceTitleId(
		IN		DWORD dwTitleId
	);
/* needs work
	NTSYSAPI
	EXPORTNUM(1560)
	NTSTATUS
	NTAPI
	XamNetworkStorageGetStatus(
		IN		DWORD unk1,
		IN OUT	PVOID unk2, // seems to require 0xC bytes
		IN		DWORD unk3,
	);*/
	
	// *** THESE NEED TO BE CHECKED!!! ***

	/* this needs to be added
	NTSYSAPI
	EXPORTNUM(UNKNOWN)
	DWORD
	NTAPI
	XOnlineFindMediaInstanceUrls(
		ULONGLONG qwUserId,
		const char *abMediaInstanceId,
		unsigned long cbResults,
		PFIND_MEDIA_INSTANCE_URLS_RESPONSE pResults,
		PXOVERLAPPED pXOverlapped
	);
	*/

	
#ifdef __cplusplus
}
#endif



#endif // __XAMEXT_DEFINES_H

```

`XenonDumper/libs/xkelib/xam/xamExpEnum.h`:

```h
// LIBRARY xam.xex@21256.0+1861.0

typedef enum {
	xamExp_NetDll_WSAStartup = 1,
	xamExp_NetDll_WSACleanup = 2,
	xamExp_NetDll_socket = 3,
	xamExp_NetDll_closesocket = 4,
	xamExp_NetDll_shutdown = 5,
	xamExp_NetDll_ioctlsocket = 6,
	xamExp_NetDll_setsockopt = 7,
	xamExp_NetDll_getsockopt = 8,
	xamExp_NetDll_getsockname = 9,
	xamExp_NetDll_getpeername = 10,
	xamExp_NetDll_bind = 11,
	xamExp_NetDll_connect = 12,
	xamExp_NetDll_listen = 13,
	xamExp_NetDll_accept = 14,
	xamExp_NetDll_select = 15,
	xamExp_NetDll_WSAGetOverlappedResult = 16,
	xamExp_NetDll_WSACancelOverlappedIO = 17,
	xamExp_NetDll_recv = 18,
	xamExp_NetDll_WSARecv = 19,
	xamExp_NetDll_recvfrom = 20,
	xamExp_NetDll_WSARecvFrom = 21,
	xamExp_NetDll_send = 22,
	xamExp_NetDll_WSASend = 23,
	xamExp_NetDll_sendto = 24,
	xamExp_NetDll_WSASendTo = 25,
	xamExp_NetDll_inet_addr = 26,
	xamExp_NetDll_WSAGetLastError = 27,
	xamExp_NetDll_WSASetLastError = 28,
	xamExp_NetDll_WSACreateEvent = 29,
	xamExp_NetDll_WSACloseEvent = 30,
	xamExp_NetDll_WSASetEvent = 31,
	xamExp_NetDll_WSAResetEvent = 32,
	xamExp_NetDll_WSAWaitForMultipleEvents = 33,
	xamExp_NetDll___WSAFDIsSet = 34,
	xamExp_NetDll_WSAEventSelect = 35,
	xamExp_NetDll_WSAStartupEx = 36,
	xamExp_NetDll_XNetStartup = 51,
	xamExp_NetDll_XNetCleanup = 52,
	xamExp_NetDll_XNetRandom = 53,
	xamExp_NetDll_XNetCreateKey = 54,
	xamExp_NetDll_XNetRegisterKey = 55,
	xamExp_NetDll_XNetUnregisterKey = 56,
	xamExp_NetDll_XNetXnAddrToInAddr = 57,
	xamExp_NetDll_XNetServerToInAddr = 58,
	xamExp_NetDll_XNetTsAddrToInAddr = 59,
	xamExp_NetDll_XNetInAddrToXnAddr = 60,
	xamExp_NetDll_XNetInAddrToServer = 61,
	xamExp_NetDll_XNetInAddrToString = 62,
	xamExp_NetDll_XNetUnregisterInAddr = 63,
	xamExp_NetDll_XNetXnAddrToMachineId = 64,
	xamExp_NetDll_XNetConnect = 65,
	xamExp_NetDll_XNetGetConnectStatus = 66,
	xamExp_NetDll_XNetDnsLookup = 67,
	xamExp_NetDll_XNetDnsRelease = 68,
	xamExp_NetDll_XNetQosListen = 69,
	xamExp_NetDll_XNetQosLookup = 70,
	xamExp_NetDll_XNetQosServiceLookup = 71,
	xamExp_NetDll_XNetQosRelease = 72,
	xamExp_NetDll_XNetGetTitleXnAddr = 73,
	xamExp_NetDll_XNetGetDebugXnAddr = 74,
	xamExp_NetDll_XNetGetEthernetLinkStatus = 75,
	xamExp_NetDll_XNetGetBroadcastVersionStatus = 76,
	xamExp_NetDll_XNetQosGetListenStats = 77,
	xamExp_NetDll_XNetGetOpt = 78,
	xamExp_NetDll_XNetSetOpt = 79,
	xamExp_NetDll_XNetStartupEx = 80,
	xamExp_NetDll_XNetReplaceKey = 81,
	xamExp_NetDll_XNetGetXnAddrPlatform = 82,
	xamExp_NetDll_XNetGetSystemLinkPort = 83,
	xamExp_NetDll_XNetSetSystemLinkPort = 84,
	xamExp_NetDll_XNetDnsReverseLookup = 85,
	xamExp_NetDll_XNetDnsReverseRelease = 86,
	xamExp_NetDll_XnpLoadConfigParams = 101,
	xamExp_NetDll_XnpSaveConfigParams = 102,
	xamExp_NetDll_XnpConfigUPnP = 103,
	xamExp_NetDll_XnpConfig = 104,
	xamExp_NetDll_XnpGetConfigStatus = 105,
	xamExp_NetDll_XnpLoadMachineAccount = 106,
	xamExp_NetDll_XnpSaveMachineAccount = 107,
	xamExp_NetDll_XnpCapture = 108,
	xamExp_NetDll_XnpEthernetInterceptSetCallbacks = 109,
	xamExp_NetDll_XnpEthernetInterceptXmit = 110,
	xamExp_NetDll_XnpEthernetInterceptRecv = 111,
	xamExp_NetDll_XnpLogonGetStatus = 112,
	xamExp_NetDll_XnpLogonGetQFlags = 113,
	xamExp_NetDll_XnpLogonSetQFlags = 114,
	xamExp_NetDll_XnpLogonSetQEvent = 115,
	xamExp_NetDll_XnpLogonClearQEvent = 116,
	xamExp_NetDll_XnpLogonGetQVals = 117,
	xamExp_NetDll_XnpLogonSetQVals = 118,
	xamExp_NetDll_XnpLogonSetPState = 119,
	xamExp_NetDll_XnpGetVlanXboxName = 120,
	xamExp_NetDll_XnpSetVlanXboxName = 121,
	xamExp_NetDll_XnpGetActiveSocketList = 122,
	xamExp_NetDll_XnpNoteSystemTime = 123,
	xamExp_NetDll_XnpRegisterKeyForCallerType = 124,
	xamExp_NetDll_XnpUnregisterKeyForCallerType = 125,
	xamExp_NetDll_XnpLogonGetChallenge = 126,
	xamExp_NetDll_XnpLogonClearChallenge = 127,
	xamExp_NetDll_XnpLogonSetChallengeResponse = 128,
	xamExp_NetDll_XnpGetSecAssocList = 129,
	xamExp_NetDll_XnpGetKeyList = 130,
	xamExp_NetDll_XnpGetQosLookupList = 131,
	xamExp_NetDll_XnpPersistTitleState = 132,
	xamExp_NetDll_XnpReplaceKeyForCallerType = 133,
	xamExp_NetDll_XnpEthernetInterceptSetExtendedReceiveCallback = 134,
	xamExp_NetDll_XnpQosHistoryLoad = 135,
	xamExp_NetDll_XnpQosHistorySaveMeasurements = 136,
	xamExp_NetDll_XnpQosHistoryGetEntries = 137,
	xamExp_NetDll_XnpQosHistoryGetAggregateMeasurement = 138,
	xamExp_NetDll_XnpToolSetCallbacks = 139,
	xamExp_NetDll_XnpToolIpProxyInject = 140,
	xamExp_NetDll_XnpUpdateConfigParams = 141,
	xamExp_NetDll_XnpEthernetInterceptXmitAsIp = 142,
	xamExp_NetDll_XnpConfigUPnPPortAndExternalAddr = 143,
	xamExp_NetDll_XmlDownloadStart = 151,
	xamExp_NetDll_XmlDownloadContinue = 152,
	xamExp_NetDll_XmlDownloadStop = 153,
	xamExp_NetDll_XmlDownloadGetParseTime = 154,
	xamExp_NetDll_XmlDownloadGetReceivedDataSize = 155,
	xamExp_XnpGetXwppMemoryLogSnapshot = 198,
	xamExp_XnpGetXwppRuntimeFilter = 199,
	xamExp_NetDll_XHttpStartup = 201,
	xamExp_NetDll_XHttpShutdown = 202,
	xamExp_NetDll_XHttpOpen = 203,
	xamExp_NetDll_XHttpCloseHandle = 204,
	xamExp_NetDll_XHttpConnect = 205,
	xamExp_NetDll_XHttpSetStatusCallback = 206,
	xamExp_NetDll_XHttpOpenRequest = 207,
	xamExp_NetDll_XHttpOpenRequestUsingMemory = 208,
	xamExp_NetDll_XHttpSendRequest = 209,
	xamExp_NetDll_XHttpReceiveResponse = 210,
	xamExp_NetDll_XHttpQueryHeaders = 211,
	xamExp_NetDll_XHttpReadData = 212,
	xamExp_NetDll_XHttpWriteData = 213,
	xamExp_NetDll_XHttpQueryOption = 214,
	xamExp_NetDll_XHttpSetOption = 215,
	xamExp_NetDll_XHttpDoWork = 216,
	xamExp_NetDll_XHttpSetCredentials = 217,
	xamExp_NetDll_XHttpQueryAuthSchemes = 218,
	xamExp_NetDll_XHttpCrackUrlW = 219,
	xamExp_NetDll_XHttpCrackUrl = 220,
	xamExp_NetDll_XHttpCreateUrl = 221,
	xamExp_NetDll_XHttpCreateUrlW = 222,
	xamExp_NetDll_XHttpResetPerfCounters = 223,
	xamExp_NetDll_XHttpGetPerfCounters = 224,
	xamExp_NetDll_UpnpStartup = 251,
	xamExp_NetDll_UpnpCleanup = 252,
	xamExp_NetDll_UpnpSearchCreate = 253,
	xamExp_NetDll_UpnpSearchGetDevices = 254,
	xamExp_NetDll_UpnpDescribeCreate = 255,
	xamExp_NetDll_UpnpDescribeGetResults = 256,
	xamExp_NetDll_UpnpActionCalculateWorkBufferSize = 257,
	xamExp_NetDll_UpnpActionCreate = 258,
	xamExp_NetDll_UpnpActionGetResults = 259,
	xamExp_NetDll_UpnpEventCreate = 260,
	xamExp_NetDll_UpnpEventGetCurrentState = 261,
	xamExp_NetDll_UpnpEventUnsubscribe = 262,
	xamExp_NetDll_UpnpDoWork = 263,
	xamExp_NetDll_UpnpCloseHandle = 264,
	xamExp_XNetLogonGetLoggedOnUsers = 301,
	xamExp_XNetLogonGetNatType = 302,
	xamExp_XNetLogonTaskStart = 303,
	xamExp_XNetLogonTaskClose = 304,
	xamExp_XNetLogonTaskContinue = 305,
	xamExp_XNetLogonGetServiceInfo = 306,
	xamExp_XNetLogonGetUserPrivileges = 307,
	xamExp_XNetLogonSetConsoleCertificate = 308,
	xamExp_XNetLogonGetMachineID = 309,
	xamExp_XNetLogonGetTitleID = 310,
	xamExp_XNetLogonGetTitleVersion = 311,
	xamExp_XNetLogonGetServiceNetworkID = 312,
	xamExp_XNetLogonGetDnsString = 313,
	xamExp_XNetLogonSetTitleID = 314,
	xamExp_XNetLogonGetExtendedStatus = 315,
	xamExp_XNetLogonClearTicketCaches = 316,
	xamExp_XNetLogonInitOverrideInfo = 317,
	xamExp_XNetLogonGetLastUPnPStatus = 318,
	xamExp_XNetLogonGetFlowToken = 319,
	xamExp_XNetLogonGetTicketOpt = 320,
	xamExp_XNetLogonSetTicketOpt = 321,
	xamExp_XNetLogonGetState = 322,
	xamExp_XamInputGetCapabilities = 400,
	xamExp_XamInputGetState = 401,
	xamExp_XamInputSetState = 402,
	xamExp_XamInputGetKeystroke = 403,
	xamExp_XamInputEnableAutobind = 404,
	xamExp_XamInputRawState = 405,
	xamExp_XamEnableSystemAppInput = 406,
	xamExp_XamInputGetDeviceStats = 407,
	xamExp_XamInputGetKeystrokeEx = 408,
	xamExp_XamInputGetKeystrokeHud = 409,
	xamExp_XamInputSetLayoutKeyboard = 410,
	xamExp_XamInputToggleKeyLocks = 411,
	xamExp_XamInputResetLayoutKeyboard = 412,
	xamExp_XamInputGetKeystrokeHudEx = 413,
	xamExp_XamInputSetKeyboardTranslationHud = 414,
	xamExp_XamSetInactivityTime = 415,
	xamExp_XamEnableInactivityProcessing = 416,
	xamExp_XamResetInactivity = 417,
	xamExp_XamSetInactivityTimeFromConfig = 418,
	xamExp_XamLoaderGetMediaInfo = 419,
	xamExp_XamLoaderLaunchTitle = 420, // XamLaunchNewImage
	xamExp_XamLoaderLaunchTitleEx = 421,
	xamExp_XamLoaderSetLaunchData = 422, // XSetLaunchData
	xamExp_XamLoaderGetLaunchDataSize = 423, // XGetLaunchDataSize
	xamExp_XamLoaderGetLaunchData = 424, // XGetLaunchData
	xamExp_XamLoaderTerminateTitle = 425, // XamTerminateTitle
	xamExp_XamLoaderGetDvdTrayState = 426, // XGetTrayState
	xamExp_XamLoaderGetGameInfo = 427, // XamGetGameInfo
	xamExp_XamLoaderLaunchTitleOnDvd = 428,
	xamExp_XamLoaderSetSpindleSpeed = 429, // XamSetDvdSpindleSpeed
	xamExp_XamTaskCreateQueue = 430,
	xamExp_XamTaskSchedule = 431,
	xamExp_XamTaskReschedule = 432,
	xamExp_XamTaskCloseHandle = 433,
	xamExp_XamTaskCancel = 434,
	xamExp_XamTaskShouldExit = 435,
	xamExp_XamTaskWaitOnCompletion = 436,
	xamExp_XamTaskModify = 437,
	xamExp_XamTaskGetCurrentTask = 438,
	xamExp_XamTaskGetAttributes = 439,
	xamExp_XamExecutingOnBehalfOfTitle = 440,
	xamExp_XamInputSendStayAliveRequest = 441,
	xamExp_XamInputGetUserVibrationLevel = 442,
	xamExp_XamIsSystemTitleId = 443,
	xamExp_XamLoaderIsTitleTerminatePending = 444,
	xamExp_XamLoaderGetPriorTitleId = 446,
	xamExp_XamIsXbox1TitleId = 447,
	xamExp_XamInputSetKeyLocks = 448,
	xamExp_XamInputGetKeyLocks = 449,
	xamExp_XamTaskGetStatus = 450,
	xamExp_XamGetRootObj = 451,
	xamExp_XamDevAuthSetFault = 452,
	xamExp_XamGetDefaultSystemImage = 453,
	xamExp_XamGetWCNConfigFile = 454,
	xamExp_XamSetPowerMode = 455,
	xamExp_XamExecuteChallenge = 456,
	xamExp_XamGetDefaultImage = 457,
	xamExp_XamMuteSound = 458,
	xamExp_XamGetOnlineSchema = 459,
	xamExp_XamSetDashContext = 460,
	xamExp_XamGetDashContext = 461,
	xamExp_XamIsCurrentTitleDash = 462,
	xamExp_XamGetCurrentTitleId = 463,
	xamExp_XamSetCurrentTitleDash = 464,
	xamExp_XamAllocHeapFreeSpace = 465,
	xamExp_XamSetHudContext = 468,
	xamExp_XamGetHudContext = 469,
	xamExp_XCustomSetAction = 472,
	xamExp_XCustomGetLastActionPress = 473,
	xamExp_XCustomSetDynamicActions = 474,
	xamExp_XCustomBroadcastActionEvent = 475,
	xamExp_XCustomGetLastActionPressEx = 476,
	xamExp_XCustomRegisterDynamicActions = 477,
	xamExp_XCustomUnregisterDynamicActions = 478,
	xamExp_XCustomGetCurrentGamercard = 479,
	xamExp_XamDbgPrint = 480,
	xamExp_XamDbgSetOutputLevel = 481,
	xamExp_XamDbgSetBreakLevel = 482,
	xamExp_XamLoaderGetMediaInfoEx = 483,
	xamExp_XamLoaderSetGameInfo = 484,
	xamExp_XamFormatMessage = 485,
	xamExp_XamUniSortCmpString = 486,
	xamExp_XamFormatTimeString = 487,
	xamExp_XamFormatDateString = 488,
	xamExp_XamGetLocaleDateFormat = 489,
	xamExp_XamAlloc = 490,
	xamExp_XamAllocEx = 491,
	xamExp_XamFree = 492,
	xamExp_XamAllocSize = 493,
	xamExp_XamAllocFreeIPTVHeap = 496,
	xamExp_XamDeviceRemap = 497,
	xamExp_XamLoaderGetClearCache = 498,
	xamExp_XamLoaderSetClearCache = 499,
	xamExp_XMsgInProcessCall = 500,
	xamExp_XMsgCompleteIORequest = 501,
	xamExp_XMsgSystemProcessCall = 502,
	xamExp_XMsgStartIORequest = 503,
	xamExp_XMsgCancelIORequest = 504,
	xamExp_XMsgAcquireAsyncMessageFromOverlapped = 505,
	xamExp_XMsgReleaseAsyncMessageToOverlapped = 506,
	xamExp_XamGetOverlappedResult = 507,
	xamExp_XMsgStartIORequestEx = 508,
	xamExp_XamAppAllocateInterappWorkspace = 509,
	xamExp_XamAppGetInterappWorkspace = 510,
	xamExp_XamAppFreeInterappWorkspace = 511,
	xamExp_XamFeatureEnabled = 512,
	xamExp_XamFeatureEnforceImageBudget = 513,
	xamExp_XamFeatureSetMask = 514,
	xamExp_XamFeatureEnableDisable = 515,
	xamExp_XuiControlSetItemAssociation = 516,
	xamExp_XamGetTitleGlobalStorageValue = 517,
	xamExp_XamSetTitleGlobalStorageValue = 518,
	xamExp_XamUserValidateAvatarMetadata = 519,
	xamExp_XamUserGetDeviceContext = 520,
	xamExp_XamUserLookupDevice = 521,
	xamExp_XamUserGetXUID = 522,
	xamExp_XamUserLogon = 523,
	xamExp_XamUserGetGamerTag = 524,
	xamExp_XamUserGetUserIndexMask = 525,
	xamExp_XamUserGetName = 526,
	xamExp_XamLookupCommonStringByIndex = 527,
	xamExp_XamUserGetSigninState = 528,
	xamExp_XamUserGetIndexFromXUID = 529,
	xamExp_XamUserCheckPrivilege = 530,
	xamExp_XamUserAreUsersFriends = 531,
	xamExp_XamSetUserPresetPresenceState = 532,
	xamExp_XamGetUserPresetPresenceState = 533,
	xamExp_XamUserGetUserFlagsFromXUID = 534,
	xamExp_XamUserGetMembershipTypeFromXUID = 535,
	xamExp_XamUserGetOnlineCountryFromXUID = 536,
	xamExp_XamUserReadProfileSettings = 537,
	xamExp_XamUserWriteProfileSettings = 538,
	xamExp_XamUserGetMembershipType = 539,
	xamExp_XamUserGetUserFlags = 540,
	xamExp_XamUserGetRequestedUserIndexMask = 541,
	xamExp_XamUserIsGuest = 542,
	xamExp_XamUserProfileSync = 543,
	xamExp_XamUserFlushLogonQueue = 544,
	xamExp_XamUserIsOnlineEnabled = 545,
	xamExp_XamUserGetCachedUserFlags = 546,
	xamExp_XamAreMixedAccountsSignedIn = 547,
	xamExp_XamUserLogonEx = 548,
	xamExp_XamUserGetSigninInfo = 551,
	xamExp_XamUserIsPartial = 552,
	xamExp_XamUserGetOnlineLanguageFromXUID = 553,
	xamExp_XamUserReadProfileSettingsEx = 554,
	xamExp_XamSystemUpdaterLogon = 555,
	xamExp_XamUserGetUsersMissingAvatars = 556,
	xamExp_XamIsChildAccountSignedIn = 557,
	xamExp_XamUserPrefetchProfileSettings = 558,
	xamExp_XamUserInvalidateProfileSetting = 559,
	xamExp_XamProfileCreate = 560,
	xamExp_XamProfileCreateEnumerator = 561,
	xamExp_XamProfileEnumerate = 562,
	xamExp_XamProfileDelete = 563,
	xamExp_XamProfileGetCreationStatus = 564,
	xamExp_XamProfileFindAccount = 565,
	xamExp_XamProfileRenameAccount = 566,
	xamExp_XamProfileOpen = 567,
	xamExp_XamProfileClose = 568,
	xamExp_XamProfileSaveAccountInfo = 569,
	xamExp_XamProfileLoadAccountInfo = 570,
	xamExp_XamProfileRecoverTitle = 571,
	xamExp_XamProfileSaveWindowsLiveCredentials = 572,
	xamExp_XamProfileLoadWindowsLiveCredentials = 573,
	xamExp_XamProfileIsSaveWindowsLiveCredsEnabled = 574,
	xamExp_XamProfileSetSaveWindowsLiveCredsEnabled = 575,
	xamExp_XamSetProfileReadTestHook = 576,
	xamExp_XamProfileGetLastSync = 577,
	xamExp_XamAccountRecoveryRecoverTitle = 578,
	xamExp_XamProfileControlXgi = 579,
	xamExp_XamAppLoad = 580,
	xamExp_XamAppUnloadSelf = 581,
	xamExp_XamAppUnloadStack = 582,
	xamExp_XamSendMessageToLoadedApps = 583,
	xamExp_XamAppRequestLoad = 584,
	xamExp_XamAppUnrequestLoad = 585,
	xamExp_XamNavigate = 586,
	xamExp_XamRegisterSysApp = 587,
	xamExp_XamUnregisterSysApp = 588,
	xamExp_XamCreateEnumeratorHandle = 590,
	xamExp_XamGetPrivateEnumStructureFromHandle = 591,
	xamExp_XamEnumerate = 592,
	xamExp_XamLoadSysApp = 593,
	xamExp_XamUnloadSysApp = 594,
	xamExp_XamReloadSysApp = 595,
	xamExp_XamAppLoadPass2SysApps = 596,
	xamExp_XamProfileGetLiveLegalLocale = 597,
	xamExp_XamUserIsParentalControlled = 598,
	xamExp_XamContentLaunchImageFromFileInternal = 599,
	xamExp_XamContentCreate = 600,
	xamExp_XamContentCreateEx = 601,
	xamExp_XamContentClose = 602,
	xamExp_XamContentDelete = 603,
	xamExp_XamContentCreateEnumerator = 604,
	xamExp_XamContentCreateDeviceEnumerator = 605,
	xamExp_XamContentGetDeviceData = 606,
	xamExp_XamContentGetDeviceName = 607,
	xamExp_XamContentSetThumbnail = 608,
	xamExp_XamContentGetThumbnail = 609,
	xamExp_XamContentGetCreator = 610,
	xamExp_XamContentLaunchImage = 611,
	xamExp_XamContentGetAttributes = 612,
	xamExp_XamContentGetDeviceState = 613,
	xamExp_XamContentGetLicenseMask = 614,
	xamExp_XamContentFlush = 615,
	xamExp_XamContentResolve = 616,
	xamExp_XamContentOpenFile = 617,
	xamExp_XamContentInstall = 618,
	xamExp_XamContentLockUnlockPackageHeaders = 619,
	xamExp_XamContentCopyInternal = 620,
	xamExp_XamContentMoveInternal = 621,
	xamExp_XamContentGetMetaDataInternal = 622,
	xamExp_XamContentCreateEnumeratorInternal = 623,
	xamExp_XamContentDeleteInternal = 624,
	xamExp_XamContentCreateInternal = 625,
	xamExp_XamContentSetThumbnailInternal = 626,
	xamExp_XamContentLaunchImageInternal = 627,
	xamExp_XamContentWritePackageHeader = 628,
	xamExp_XamContentDismountAndClosePackage = 629,
	xamExp_XamContentResolveInternal = 630,
	xamExp_XamContentGetAttributesInternal = 631,
	xamExp_XamContentOpenFileInternal = 632,
	xamExp_XamContentAggregateCreateEnumerator = 633,
	xamExp_XamContentCreateAndMountPackage = 634,
	xamExp_XamContentOpenPackageFile = 635,
	xamExp_XamContentMountPackage = 636,
	xamExp_XamContentFlushPackage = 637,
	xamExp_XamContentClosePackageFile = 638,
	xamExp_XamContentDuplicateFileHandle = 639,
	xamExp_XamGetExecutionId = 640,
	xamExp_XamGetGameRatings = 641,
	xamExp_XamGetSystemVersion = 642,
	xamExp_XamContentGetLocalizedString = 643,
	xamExp_XamContentGetDefaultDevice = 644,
	xamExp_XamContentInstallInternal = 645,
	xamExp_XamContentGetDeviceSerialNumber = 647,
	xamExp_XamContentGetMountedPackageByRootName = 648,
	xamExp_XamContentRegisterChangeCallback = 649,
	xamExp_XamNotifyCreateListener = 650,
	xamExp_XNotifyGetNext = 651,
	xamExp_XNotifyPositionUI = 652,
	xamExp_XNotifyDelayUI = 653,
	xamExp_XNotifyBroadcast = 654,
	xamExp_XNotifyRegisterArea = 655,
	xamExp_XNotifyQueueUI = 656,
	xamExp_XamNotifyCreateListenerInternal = 657,
	xamExp_XNotifyUISetOptions = 658,
	xamExp_XNotifyUIGetOptions = 659,
	xamExp_XamContentLaunchImageInternalEx = 660,
	xamExp_XamShutdown = 661,
	xamExp_XamAllocDevkitHeapAvailable = 662,
	xamExp_XamNotifyCreateListenerRangeInternal = 663,
	xamExp_XNotifyQueueUIEx = 664,
	xamExp_XamAppRequestLoadEx = 665,
	xamExp_XuiPNGTextureLoader = 666,
	xamExp_XuiRenderGetXuiDevice = 667,
	xamExp_XuiDefault_False = 668,
	xamExp_XamUserGetReportingInfo = 669,
	xamExp_XamUpdateStart = 670,
	xamExp_XamUpdateGetProgress = 671,
	xamExp_XamUpdateFinish = 673,
	xamExp_XamUpdateAttachExtenderInstance = 674,
	xamExp_XamUpdateGetBaseSystemVersion = 678,
	xamExp_XamUpdateGetCurrentSystemVersion = 679,
	xamExp_XamUpdateChainPass3FromPass2 = 683,
	xamExp_XamInputGetCapabilitiesEx = 685,
	xamExp_XamUserIsUnsafeProgrammingAllowed = 686,
	xamExp_XamDevAuthSetFaultEx = 687,
	xamExp_XamUpdateGetData = 688,
	xamExp_XamCacheIntegrityCheck = 689,
	xamExp_XamCacheStoreFile = 690,
	xamExp_XamCacheFetchFile = 691,
	xamExp_XamCacheOpenFile = 692,
	xamExp_XamCacheCloseFile = 693,
	xamExp_XamGetCachedTitleName = 694,
	xamExp_XamCacheReset = 695,
	xamExp_XamGetCachedGamerTag = 696,
	xamExp_XamGetCachedGamerTagW = 697,
	xamExp_XamCacheDeleteFile = 698,
	xamExp_XamCacheRenameFile = 699,
	xamExp_XamShowSigninUI = 700,
	xamExp_XamShowSigninUIEx = 701,
	xamExp_XamShowSigninUIp = 702,
	xamExp_XamShowFriendsUI = 703,
	xamExp_XamShowMessagesUI = 704,
	xamExp_XamShowKeyboardUI = 705,
	xamExp_XamShowQuickChatUI = 706,
	xamExp_XamShowVoiceMailUI = 707,
	xamExp_XamShowGamerCardUI = 708,
	xamExp_XamShowAchievementsUI = 709,
	xamExp_XamShowPlayerReviewUI = 710,
	xamExp_XamShowMarketplaceUI = 711,
	xamExp_XamShowPlayersUI = 712,
	xamExp_XamShowUpdaterUI = 713,
	xamExp_XamShowMessageBoxUI = 714,
	xamExp_XamShowDeviceSelectorUI = 715,
	xamExp_XamShowMessageComposeUI = 716,
	xamExp_XamShowGameInviteUI = 717,
	xamExp_XamShowFriendRequestUI = 718,
	xamExp_XamShowCreateProfileUI = 719,
	xamExp_XamShowGamesUI = 720,
	xamExp_XamShowLiveSignupUI = 721,
	xamExp_XamShowFriendsUIp = 722,
	xamExp_XamShowComplaintUI = 723,
	xamExp_XamShowReputationUI = 724,
	xamExp_XamShowGamerCardUIForXUID = 725,
	xamExp_XamShowForcedNameChangeUI = 726,
	xamExp_XamShowLiveUpsellUI = 727,
	xamExp_XamShowPasscodeVerifyUI = 728,
	xamExp_XamShowDirtyDiscErrorUI = 729,
	xamExp_XamShowSignupCreditCardUI = 730,
	xamExp_XamShowPrivateChatInviteUI = 731,
	xamExp_XamShowMessageBoxUIEx = 732,
	xamExp_XamShowRecentMessageUI = 733,
	xamExp_XamShowRecentMessageUIEx = 734,
	xamExp_XamShowMessagesUIEx = 735,
	xamExp_XamShowAchievementDetailsUI = 736,
	xamExp_XamShowPersonalizationUI = 737,
	xamExp_XamShowChangeGamerTileUI = 738,
	xamExp_XamShowVoiceSettingsUI = 739,
	xamExp_XamShowVideoChatInviteUI = 740,
	xamExp_XamShowCustomMessageComposeUI = 741,
	xamExp_XamShowCustomPlayerListUI = 742,
	xamExp_XamShowMarketplaceDownloadItemsUI = 743,
	xamExp_XamShowMarketplaceUIEx = 744,
	xamExp_XamShowMessageBox = 745,
	xamExp_XamIsSysUiInvokedByXenonButton = 746,
	xamExp_XamIsSysUiInvokedByTitle = 747,
	xamExp_XamIsUIActive = 748,
	xamExp_XamSysUiDisableAutoClose = 749,
	xamExp_XamUserCreateAchievementEnumerator = 750,
	xamExp_XamReadTile = 751,
	xamExp_XamWriteGamerTile = 752,
	xamExp_XamWriteTile = 753,
	xamExp_XamReadImage = 754,
	xamExp_XamUserCreateTitlesPlayedEnumerator = 755,
	xamExp_XamDecompressPNGToTexture = 756,
	xamExp_XamReadTileToTexture = 757,
	xamExp_XamReadString = 758,
	xamExp_XamUserCreateStatsEnumerator = 759,
	xamExp_XamPrepareGamerTiles = 760,
	xamExp_XamClearTitle = 761,
	xamExp_XamReadStrings = 762,
	xamExp_XamWriteGamerTileEx = 763,
	xamExp_XamReadTileEx = 764,
	xamExp_XamReadTileToTextureEx = 765,
	xamExp_XamShowLiveUpsellUIEx = 768,
	xamExp_XamShowJoinSessionInProgressUI = 769,
	xamExp_XamShowGraduateUserUI = 770,
	xamExp_XamShowGamerCardUIForXUIDp = 771,
	xamExp_XamShowGuideUI = 772,
	xamExp_XamShowPartyUI = 773,
	xamExp_XamShowPartyInviteUI = 774,
	xamExp_XamUserAddRecentPlayer = 775,
	xamExp_XamUserUpdateRecentPlayer = 776,
	xamExp_XamUserCreatePlayerEnumerator = 777,
	xamExp_XamParseGamerTileKey = 778,
	xamExp_XamShowCommunitySessionsUI = 779,
	xamExp_XamVoiceCreate = 780,
	xamExp_XamVoiceHeadsetPresent = 781,
	xamExp_XamVoiceSubmitPacket = 782,
	xamExp_XamVoiceClose = 783,
	xamExp_XamVoiceGetBatteryStatus = 784,
	xamExp_XamShowJoinSessionByIdInProgressUI = 787,
	xamExp_XamShowPartyJoinInProgressUI = 788,
	xamExp_XamBuildSharedSystemResourceLocator = 789,
	xamExp_XamSessionCreateHandle = 790,
	xamExp_XamSessionRefObjByHandle = 791,
	xamExp_XamVoiceGetMicArrayStatus = 792,
	xamExp_XamVoiceSetAudioCaptureRoutine = 793,
	xamExp_XamVoiceGetDirectionalData = 794,
	xamExp_XamBuildResourceLocator = 795,
	xamExp_XamBuildLegacySystemResourceLocator = 796,
	xamExp_XamBuildGamercardResourceLocator = 797,
	xamExp_XamBuildDynamicResourceLocator = 798,
	xamExp_XamBuildXamResourceLocator = 799,
	xamExp_XuiAnimRun = 800,
	xamExp_XuiApplyLocale = 801,
	xamExp_XuiBubbleMessage = 802,
	xamExp_XuiControlIsBackButton = 803,
	xamExp_XuiControlIsNavButton = 804,
	xamExp_XuiCreateObject = 805,
	xamExp_XuiDestroyObject = 806,
	xamExp_XuiDynamicCast = 807,
	xamExp_XuiElementAddChild = 808,
	xamExp_XuiElementFindNamedFrame = 809,
	xamExp_XuiElementGetChildById = 810,
	xamExp_XuiElementGetFirstChild = 811,
	xamExp_XuiElementGetFocus = 812,
	xamExp_XuiElementGetFocusUser = 813,
	xamExp_XuiElementGetId = 814,
	xamExp_XuiElementGetLastChild = 815,
	xamExp_XuiElementGetNext = 816,
	xamExp_XuiElementGetParent = 817,
	xamExp_XuiElementGetUserFocus = 818,
	xamExp_XuiElementInitFocus = 819,
	xamExp_XuiElementInitUserFocus = 820,
	xamExp_XuiElementPlayTimeline = 821,
	xamExp_XuiElementSetBounds = 822,
	xamExp_XuiElementSetFocus = 823,
	xamExp_XuiElementSetUserFocus = 824,
	xamExp_XuiElementTreeGetFocus = 825,
	xamExp_XuiFindClass = 826,
	xamExp_XuiFreeStringTable = 827,
	xamExp_XuiGetBaseObject = 828,
	xamExp_XuiGetClass = 829,
	xamExp_XuiGetObjectClass = 830,
	xamExp_XuiGetOuter = 831,
	xamExp_XuiInit = 832,
	xamExp_XuiLoadFromBinary = 833,
	xamExp_XuiLoadStringTableFromFile = 834,
	xamExp_XuiVisualGetBasePath = 835,
	xamExp_XuiLookupStringTable = 836,
	xamExp_XuiNavButtonGetPressPath = 837,
	xamExp_XuiObjectFromHandle = 838,
	xamExp_XuiObjectGetProperty = 839,
	xamExp_XuiObjectGetPropertyId = 840,
	xamExp_XuiProcessInput = 841,
	xamExp_XuiRegisterClass = 842,
	xamExp_XuiRenderBegin = 843,
	xamExp_XuiRenderCreateDC = 844,
	xamExp_XuiRenderDCDeviceChanged = 845,
	xamExp_XuiRenderDestroyDC = 846,
	xamExp_XuiRenderEnd = 847,
	xamExp_XuiRenderGetBackBufferSize = 848,
	xamExp_XuiRenderInit = 849,
	xamExp_XuiRenderInitShared = 850,
	xamExp_XuiRenderPresent = 851,
	xamExp_XuiRenderSetViewTransform = 852,
	xamExp_XuiRenderUninit = 853,
	xamExp_XamShowNuiGuideUI = 854,
	xamExp_XuiSceneCreate = 855,
	xamExp_XuiSceneNavigateBack = 856,
	xamExp_XuiSceneNavigateFirst = 857,
	xamExp_XuiSceneNavigateForward = 858,
	xamExp_XuiScenePlayBackFromTransition = 859,
	xamExp_XuiScenePlayBackToTransition = 860,
	xamExp_XuiScenePlayFromTransition = 861,
	xamExp_XuiScenePlayToTransition = 862,
	xamExp_XuiSendMessage = 863,
	xamExp_XuiSetLocale = 864,
	xamExp_XuiUninit = 865,
	xamExp_XuiUnregisterClass = 866,
	xamExp_XuiTextElementSetText = 867,
	xamExp_XuiSetTimer = 868,
	xamExp_XuiTimersRun = 869,
	xamExp_XuiTextElementGetText = 870,
	xamExp_XuiVisualSetBasePath = 871,
	xamExp_XuiHandleIsValid = 872,
	xamExp_XuiAlloc = 873,
	xamExp_XuiFree = 874,
	xamExp_XuiDefault_True = 875,
	xamExp_XuiDefault_EmptyString = 876,
	xamExp_XuiDefault_IntegerZero = 877,
	xamExp_XuiCopyString = 878,
	xamExp_XuiRealloc = 879,
	xamExp_XuiControlPlayOptionalVisual = 880,
	xamExp_XuiKillTimer = 881,
	xamExp_XuiElementEnableInput = 882,
	xamExp_XuiElementInputEnabled = 883,
	xamExp_XuiIsInstanceOf = 884,
	xamExp_XuiResourceComposeLocator = 885,
	xamExp_XuiResourceLocatorIsAbsolute = 886,
	xamExp_XuiBroadcastMessage = 887,
	xamExp_XuiElementDisallowRecursiveTimelineControl = 888,
	xamExp_XUIElementPropVal_Construct = 889,
	xamExp_XUIElementPropVal_Destruct = 890,
	xamExp_XUIElementPropVal_SetString = 891,
	xamExp_XuiObjectSetProperty = 892,
	xamExp_XuiElementGetOpacity = 893,
	xamExp_XuiElementSetOpacity = 894,
	xamExp_XuiEditSetTextLimit = 895,
	xamExp_XuiEditGetTextLimit = 896,
	xamExp_XuiSliderSetValue = 897,
	xamExp_XuiSliderGetValue = 898,
	xamExp_XuiSliderSetRange = 899,
	xamExp_XuiElementUnlink = 900,
	xamExp_XuiElementInsertChild = 901,
	xamExp_XuiSceneNavigateBackToFirst = 902,
	xamExp_XuiProgressBarSetRange = 903,
	xamExp_XuiProgressBarSetValue = 904,
	xamExp_XuiProgressBarGetValue = 905,
	xamExp_XuiControlAttachVisual = 906,
	xamExp_XuiCreateTextureBrush = 907,
	xamExp_XuiDestroyBrush = 908,
	xamExp_XUIElementPropVal_SetColorFromUint = 909,
	xamExp_XuiFigureSetFill = 910,
	xamExp_XuiSliderGetRange = 911,
	xamExp_XuiFigureSetTexture = 912,
	xamExp_XuiControlGetItemAssociation = 913,
	xamExp_XuiResourceLoadAll = 914,
	xamExp_XuiImageElementSetImagePath = 915,
	xamExp_XuiImageElementGetImagePath = 916,
	xamExp_XuiControlGetVisual = 917,
	xamExp_XuiControlGetNavigation = 918,
	xamExp_XuiLookupStringTableByIndex = 919,
	xamExp_XUIElementPropVal_SetBool = 920,
	xamExp_XuiElementHasFocus = 921,
	xamExp_XUIElementPropVal_SetUint = 922,
	xamExp_XUIElementPropVal_Clear = 923,
	xamExp_XuiEditSetTextFormatInfo = 924,
	xamExp_XuiCreateSolidBrush = 925,
	xamExp_XuiSceneInterruptTransitions = 926,
	xamExp_XuiResourceOpen = 927,
	xamExp_XuiResourceRead = 928,
	xamExp_XuiResourceClose = 929,
	xamExp_XuiVisualCreateInstance = 930,
	xamExp_XuiElementGetTimeline = 931,
	xamExp_XuiElementIsDescendant = 933,
	xamExp_XuiSetMessageFilter = 934,
	xamExp_XuiAttachTextureBrush = 935,
	xamExp_XuiElementBeginRender = 936,
	xamExp_XuiElementEndRender = 937,
	xamExp_XuiDrawShape = 938,
	xamExp_XuiSelectBrushEx = 939,
	xamExp_XuiFigureGetShape = 940,
	xamExp_XuiFillRect = 941,
	xamExp_XuiVec2TransformCoord = 942,
	xamExp_XuiMatrixMultiply = 943,
	xamExp_XuiElementGetXForm = 944,
	xamExp_XuiElementSetPosition = 945,
	xamExp_XuiSelectBrush = 946,
	xamExp_XuiElementRenderChildren = 947,
	xamExp_XuiFreeUnusedTextures = 948,
	xamExp_XuiListEnableItemOverride = 949,
	xamExp_XuiListGetDefaultItemSize = 950,
	xamExp_XuiResourceSeek = 951,
	xamExp_XuiElementDiscardResources = 952,
	xamExp_XuiTabSceneGoto = 953,
	xamExp_XuiTabSceneGetCurrentTab = 954,
	xamExp_XamShowEditProfileUI = 956,
	xamExp_XamShowTermsOfUseUI = 958,
	xamExp_XamShowJoinPartyUI = 959,
	xamExp_XamShowWordRegisterUI = 960,
	xamExp_XamOverrideHudOpenType = 961,
	xamExp_XamShowAchievementsUIEx = 962,
	xamExp_XamUserGetUserTenure = 963,
	xamExp_XamUserGetSubscriptionType = 964,
	xamExp_XamShowGameVoiceChannelUI = 965,
	xamExp_XamShowAvatarAwardsUI = 966,
	xamExp_XamShowAvatarAwardGamesUI = 967,
	xamExp_XamShowVideoRichPresenceUI = 968,
	xamExp_XamHudGetUserIndex = 969,
	xamExp_XGetAudioFlags = 970,
	xamExp_XGetAVPack = 971,
	xamExp_XGetGameRegion = 972,
	xamExp_XGetLanguage = 973,
	xamExp_XapipGetLocale = 974,
	xamExp_XGetVideoFlags = 975,
	xamExp_XGetVideoStandard = 976,
	xamExp_XGetVideoMode = 977,
	xamExp_XamGetLanguage = 978,
	xamExp_XUITimeline_Run = 979,
	xamExp_XamSetAutomation = 980,
	xamExp_XAutomationpBindController = 981,
	xamExp_XAutomationpUnbindController = 982,
	xamExp_XAutomationpInputXenonButton = 983,
	xamExp_XAutomationpInputPress = 984,
	xamExp_XAutomationpInputSetState = 985,
	xamExp_XamEnableOverdraw = 986,
	xamExp_g_XuiAutomation = 987,
	xamExp_XamVoiceGetMicArrayAudio = 988,
	xamExp_XampSystemInput = 989,
	xamExp_XamInputControl = 990,
	xamExp_XuiElementGetPosition = 991,
	xamExp_XamIsMessageBoxActive = 992,
	xamExp_XamIsBackgroundSceneInTransition = 993,
	xamExp_XuiElementTreeHasFocus = 994,
	xamExp_XuiFigureClose = 995,
	xamExp_GamerCardStartup = 996,
	xamExp_GamerCardCleanup = 997,
	xamExp_GamerCardRegisterControls = 998,
	xamExp_GamerCardUnregisterControls = 999,
	xamExp_RtlFindFirstFile = 1000,
	xamExp_RtlFindNextFile = 1001,
	xamExp_RtlGetModuleFileName = 1002,
	xamExp_RtlOutputDebugString = 1003,
	xamExp_RtlRemoveDirectory = 1004,
	xamExp_RtlSleep = 1005,
	xamExp_RtlGetLastError = 1006,
	xamExp_RtlSetLastError = 1007,
	xamExp_RtlSetLastNTError = 1008,
	xamExp_RtlDebugPrint = 1009,
	xamExp_RtlDebugError = 1010,
	xamExp_RtlDebugTrace = 1012,
	xamExp_RtlDebugEntry = 1013,
	xamExp_RtlDebugExit = 1014,
	xamExp_RtlGetAttributesOnHeapAlloc = 1015,
	xamExp_RtlSetAttributesOnHeapAlloc = 1016,
	xamExp_XuiFigureSetShape = 1017,
	xamExp_RtlCreateHeap = 1018,
	xamExp_RtlDestroyHeap = 1019,
	xamExp_RtlAllocateHeap = 1020,
	xamExp_RtlAllocateHeapSlowly = 1021,
	xamExp_RtlReAllocateHeap = 1022,
	xamExp_RtlFreeHeap = 1023,
	xamExp_RtlFreeHeapSlowly = 1024,
	xamExp_RtlSizeHeap = 1025,
	xamExp_RtlZeroHeap = 1026,
	xamExp_RtlDebugWalkHeap = 1027,
	xamExp_RtlWalkHeap = 1028,
	xamExp_RtlLockHeap = 1029,
	xamExp_RtlUnlockHeap = 1030,
	xamExp_RtlValidateHeap = 1031,
	xamExp_RtlDebugCompactHeap = 1032,
	xamExp_RtlCompactHeap = 1033,
	xamExp_XamAppSetTestOption = 1034,
	xamExp_XamAppReportError = 1035,
	xamExp_XamIsNuiUIActive = 1036,
	xamExp_XamVerifyPasscode = 1037,
	xamExp_OutputDebugStringA = 1038,
	xamExp_DebugBreak = 1039,
	xamExp_GetCurrentThreadId = 1040,
	xamExp_XDebugError = 1041,
	xamExp_XDebugWarning = 1042,
	xamExp_RtlDebugSetLevel = 1043,
	xamExp_CloseHandle = 1044,
	xamExp_GetTickCount = 1045,
	xamExp_GetLastError = 1046,
	xamExp_SetFilePointer = 1047,
	xamExp_SetFilePointerEx = 1048,
	xamExp_SetLastError = 1049,
	xamExp_MultiByteToWideChar = 1050,
	xamExp_WideCharToMultiByte = 1051,
	xamExp_ReadFile = 1052,
	xamExp_FlushFileBuffers = 1053,
	xamExp_WriteFile = 1054,
	xamExp_OutputDebugStringW = 1055,
	xamExp_SetEvent = 1056,
	xamExp_XapiFormatTimeOut = 1057,
	xamExp_CreateMutexA = 1058,
	xamExp_OpenMutexA = 1059,
	xamExp_ReleaseMutex = 1060,
	xamExp_WaitForSingleObject = 1061,
	xamExp_WaitForSingleObjectEx = 1062,
	xamExp_GetFileSize = 1063,
	xamExp_GetFileSizeEx = 1064,
	xamExp_XapiDirectoryInformationToFindData = 1065,
	xamExp_XapiFormatObjectAttributes = 1066,
	xamExp_ResetEvent = 1067,
	xamExp_wsprintfA = 1068,
	xamExp_wsprintfW = 1069,
	xamExp_GetOverlappedResult = 1070,
	xamExp_QueryPerformanceCounter = 1071,
	xamExp_QueryPerformanceFrequency = 1072,
	xamExp_LocalAlloc = 1073,
	xamExp_LocalFree = 1074,
	xamExp_RaiseException = 1075,
	xamExp_RtlUniform = 1076,
	xamExp_RtlRandom = 1077,
	xamExp_Sleep = 1078,
	xamExp_SleepEx = 1079,
	xamExp_XMemSet = 1080,
	xamExp_XRegisterThreadNotifyRoutine = 1081,
	xamExp_XGetOverlappedExtendedError = 1082,
	xamExp_XGetOverlappedResult = 1083,
	xamExp_CreateThread = 1084,
	xamExp_ResumeThread = 1085,
	xamExp_ExitThread = 1086,
	xamExp_GetTimeZoneInformation = 1087,
	xamExp_GetSystemTimeAsFileTime = 1088,
	xamExp_SystemTimeToFileTime = 1089,
	xamExp_FileTimeToSystemTime = 1090,
	xamExp_GetSystemTime = 1091,
	xamExp_GetLocalTime = 1092,
	xamExp_CreateDirectoryA = 1093,
	xamExp_CreateEventA = 1094,
	xamExp_CreateFileA = 1095,
	xamExp_DeleteFileA = 1096,
	xamExp_FindFirstFileA = 1097,
	xamExp_FindNextFileA = 1098,
	xamExp_GetFileAttributesA = 1099,
	xamExp_XamLoaderGetCurrentTitleD3DVersion = 1100,
	xamExp_GetFileAttributesExA = 1101,
	xamExp_GetModuleHandleA = 1102,
	xamExp_GetDiskFreeSpaceExA = 1103,
	xamExp_CopyFileA = 1104,
	xamExp_SetEndOfFile = 1105,
	xamExp_XamFamilyAddParentalExemptionToList = 1106,
	xamExp_XamFamilyIsParentalValidationRequired = 1107,
	xamExp_PIXAddCounter = 1110,
	xamExp_SetWaitableTimer = 1112,
	xamExp_CancelWaitableTimer = 1113,
	xamExp_CreateWaitableTimerA = 1114,
	xamExp_DuplicateHandle = 1115,
	xamExp_XapipCreateThread = 1116,
	xamExp_lstrcpyA = 1117,
	xamExp_lstrcpyW = 1118,
	xamExp_lstrcpynA = 1119,
	xamExp_lstrcpynW = 1120,
	xamExp_lstrcatA = 1121,
	xamExp_lstrcatW = 1122,
	xamExp_lstrlenA = 1123,
	xamExp_lstrlenW = 1124,
	xamExp_IsBadReadPtr = 1125,
	xamExp_IsBadWritePtr = 1126,
	xamExp_FileTimeToLocalFileTime = 1127,
	xamExp_XMemCpy = 1128,
	xamExp_XMemCpyStreaming = 1129,
	xamExp_XamHudSetUserIndex = 1130,
	xamExp_XamShowNuiTroubleshooterUI = 1131,
	xamExp_XamTestShowNuiTroubleshooterUI = 1132,
	xamExp_XamShowPasscodeVerifyUIEx = 1133,
	xamExp_XamShowNuiAchievementsUI = 1134,
	xamExp_XamShowNuiCommunitySessionsUI = 1135,
	xamExp_XamShowNuiDeviceSelectorUI = 1136,
	xamExp_XamShowNuiDirtyDiscErrorUI = 1137,
	xamExp_XamShowNuiFriendsUI = 1138,
	xamExp_XamShowNuiGameInviteUI = 1139,
	xamExp_XamShowNuiGamerCardUIForXUID = 1140,
	xamExp_XamShowNuiMarketplaceDownloadItemsUI = 1141,
	xamExp_XamShowNuiMarketplaceUI = 1142,
	xamExp_XamShowNuiMessageBoxUI = 1143,
	xamExp_XamShowNuiPartyUI = 1144,
	xamExp_XamShowNuiFriendRequestUI = 1145,
	xamExp_XamShowNuiSigninUI = 1146,
	xamExp_XamShowNuiControllerRequiredUI = 1147,
	xamExp_XamShowNuiGamesUI = 1148,
	xamExp_XamShowNuiHardwareRequiredUI = 1149,
	xamExp_XamCacheStoreFileByString = 1150,
	xamExp_XamCacheFetchFileByString = 1151,
	xamExp_XamCacheDeleteFileByString = 1152,
	xamExp_XamGetCachedTitleNameEx = 1153,
	xamExp_XamXlfsInitializeUploadQueue = 1154,
	xamExp_XamXlfsUninitializeUploadQueue = 1155,
	xamExp_XamXlfsMountUploadQueueInstance = 1156,
	xamExp_XamXlfsUnmountUploadQueueInstance = 1157,
	xamExp_XamVoiceRecordUserPrivileges = 1158,
	xamExp_XamXlfsInitializeUploadQueueWithTestHooks = 1159,
	xamExp_XamXlfsNotifyContentDeletion = 1160,
	xamExp_XMemAlloc = 1161,
	xamExp_XMemFree = 1162,
	xamExp_XMemSize = 1163,
	xamExp_XamVoiceSetMicArrayIdleUsers = 1164,
	xamExp_XamVoiceMuteMicArray = 1165,
	xamExp_XamVoiceGetMicArrayUnderrunStatus = 1166,
	xamExp_XuiSceneEnableTransitionDependency = 1167,
	xamExp_XamVoiceGetMicArrayAudioEx = 1168,
	xamExp_XamShowLeaveFamilyUI = 1169,
	xamExp_XamUserGetDeviceId = 1170,
	xamExp_XamUpdateEtxLogUpdateTaskStart = 1171,
	xamExp_XamUpdateEtxLogUpdateTaskSuccess = 1172,
	xamExp_XamUpdateEtxLogUpdateTaskFailure = 1173,
	xamExp_XamEtxFlushLogs = 1174,
	xamExp_XamVoiceIsActiveProcess = 1175,
	xamExp_XamInactivityGetInactivityInterruptTime = 1176,
	xamExp_XamInactivitySetInactivityInterruptTime = 1177,
	xamExp_XamInactivityGetLastActivityTime = 1178,
	xamExp_XamInactivitySetDetectionTaskPeriod = 1179,
	xamExp_XamInactivityEnablePowerDown = 1180,
	xamExp_XamUpdateGetChainMarker = 1181,
	xamExp_XGetVideoCapabilities = 1182,
	xamExp_XMsgProcessRequest = 1183,
	xamExp_XGetDisplaySize = 1184,
	xamExp_XamInputNonControllerGetRaw = 1185,
	xamExp_XamInputNonControllerSetRaw = 1186,
	xamExp_XamVoiceSetMicArrayBeamAngle = 1187,
	xamExp_XamUserGetAge = 1188,
	xamExp_XamUserGetAgeGroup = 1189,
	xamExp_XamVoiceGetMicArrayFilenameDesc = 1190,
	xamExp_XamLoaderGetState = 1191,
	xamExp_XamTaskQueryProperty = 1192,
	xamExp_XamGetLocale = 1193,
	xamExp_XamQueryTimeZoneInformation = 1194,
	xamExp_XamSetTimeZoneInformation = 1195,
	xamExp_XamLaunchURI = 1196,
	xamExp_XamShowNuiMessagesUI = 1199,
	xamExp_XMPRegisterCodec = 1200,
	xamExp_XamNavigateBack = 1201,
	xamExp_XamPushBackURI = 1202,
	xamExp_XamUserOverrideDeviceBindings = 1203,
	xamExp_XamUserOverrideBindingCallbacks = 1204,
	xamExp_XamUserOverrideUserInfo = 1205,
	xamExp_XamUserContentRestrictionGetFlags = 1206,
	xamExp_XamUserContentRestrictionGetRating = 1207,
	xamExp_XamUserContentRestrictionCheckAccess = 1208,
	xamExp_XamShowFitnessBodyProfileUI = 1209,
	xamExp_XamFitnessAddBodyProfileRecord = 1210,
	xamExp_XamFamilyGetMembers = 1211,
	xamExp_XampXAuthStartup = 1212,
	xamExp_XampXAuthShutdown = 1213,
	xamExp_XamGetToken = 1214,
	xamExp_XamFreeToken = 1215,
	xamExp_XamGetAppliesTo = 1216,
	xamExp_XampKioskGetInfo = 1217,
	xamExp_XamFitnessGetCurrentBodyProfileRecord = 1218,
	xamExp_XamFitnessGetAllBodyProfileRecords = 1219,
	xamExp_XamFitnessGetAllTitleSummaries = 1220,
	xamExp_XamFitnessGetOverallSummary = 1221,
	xamExp_XamFitnessAddFitnessEvent = 1222,
	xamExp_XamLrcGetInput = 1223,
	xamExp_XamLrcGetInputWithSeek = 1224,
	xamExp_XamLrcSetMediaState = 1225,
	xamExp_XamPixSetDirtyCounters = 1226,
	xamExp_XamFitnessCreateFitnessEventEnumerator = 1227,
	xamExp_XamFitnessInitialize = 1228,
	xamExp_XamRequestToken = 1229,
	xamExp_XamResolveURI = 1230,
	xamExp_XamContentGetOnlineCreator = 1231,
	xamExp_XamShowBrandedKeyboardUI = 1232,
	xamExp_XamBackgroundDownloadNetworkStorageEnable = 1233,
	xamExp_XamBackgroundDownloadNetworkStorageIsEnabled = 1234,
	xamExp_XamShowNuiJoinSessionInProgressUI = 1235,
	xamExp_XamBase64Decode = 1236,
	xamExp_XamCertDecode = 1237,
	xamExp_XamCertDecodeRsaPublicKey = 1238,
	xamExp_XamCertValidateStruct = 1239,
	xamExp_XamFitnessConvertByteMetToFloatMet = 1240,
	xamExp_XamXgiBlobTrackerSetMockInfo = 1241,
	xamExp_XamFitnessMsgTimeToSystemTime = 1242,
	xamExp_XamFitnessSystemTimeToMsgTime = 1243,
	xamExp_XamShowFitnessWarnAboutPrivacyUI = 1244,
	xamExp_XamShowFitnessWarnAboutTimeUI = 1245,
	xamExp_XamFitnessUnInitialize = 1246,
	xamExp_XamBackgroundDownloadNetworkStorageOnContentChange = 1247,
	xamExp_XamLiveBaseConfigureInMemoryMockResponse = 1248,
	xamExp_InjectConnectionServerNotification = 1249,
	xamExp_XamFitnessConvertFloatMetToByteMet = 1250,
	xamExp_XamGetGamerTileKeyFromGamertag = 1251,
	xamExp_XamBackgroundDownloadNetworkStorageRegisterChangeCallback = 1252,
	xamExp_XamFindOrCreateInternalPassportAccount = 1253,
	xamExp_XOnlinepFriendsRequest = 1254,
	xamExp_XOnlinepFriendsAcceptRequest = 1255,
	xamExp_XOnlinepFriendsRejectRequest = 1256,
	xamExp_XOnlinepFriendsRemove = 1257,
	xamExp_XFriendsCreateEnumerator = 1258,
	xamExp_XamBackgroundDownloadNetworkStorageIsRunning = 1259,
	xamExp_XamCertGetSerialNumber = 1260,
	xamExp_XamShowOptionsUI = 1261,
	xamExp_XampXAuthGetTitleBuffer = 1262,
	xamExp_XamTaskReschedulePeriodicWork = 1263,
	xamExp_XamUserGetOnlineXUIDFromOfflineXUID = 1264,
	xamExp_XamIsUserUsingMetricSystem = 1265,
	xamExp_XamShowNuiVideoRichPresenceUI = 1266,
	xamExp_XamAppAllocateInterappWorkspaceEx = 1267,
	xamExp_XampKioskSetTestMock = 1268,
	xamExp_XamNetworkStatusGetInformation = 1269,
	xamExp_XamNetworkStatusAddAddress = 1270,
	xamExp_XamUserReadUserPreference = 1271,
	xamExp_XamUserWriteUserPreference = 1272,
	xamExp_XamShowFitnessClearUI = 1273,
	xamExp_XamFitnessClearAll = 1274,
	xamExp_XamFitnessGetPrivacySettings = 1275,
	xamExp_XamWaitForNSAL = 1276,
	xamExp_XamMarkInternalAccountTrustedOnConsole = 1277,
	xamExp_XamBackgroundDownloadNetworkStorageGetProgress = 1278,
	xamExp_XamCopyFile = 1279,
	xamExp_XamMoveFile = 1280,
	xamExp_XamDeleteFile = 1281,
	xamExp_XamUserOverrideGlobalState = 1282,
	xamExp_XamGetAdaptersCollection = 1283,
	xamExp_XampKioskIsSimulationMode = 1284,
	xamExp_XamIsUIThread = 1285,
	xamExp_XamInputSendXenonButtonPress = 1286,
	xamExp_XamDebugGetURISchemeCount = 1287,
	xamExp_XamDebugGetURISchemeInfo = 1288,
	xamExp_XamGetOnlineCountryFromLocale = 1289,
	xamExp_XTestOnlineIsConnectedToLive = 1290,
	xamExp_XamGetConsoleFriendlyName = 1291,
	xamExp_XamSetConsoleFriendlyName = 1292,
	xamExp_XamGetCountry = 1293,
	xamExp_XamPackageManagerGetFilePathW = 1294,
	xamExp_XamGetCurrentDemand = 1295,
	xamExp_XamCompleteDemand = 1296,
	xamExp_XamDemand = 1297,
	xamExp_XamFormatSystemDateString = 1298,
	xamExp_XamDebugGetBackURI = 1299,
	xamExp_XamIsCurrentTitleIptv = 1300,
	xamExp_XamIsIptvEnabled = 1301,
	xamExp_XamIsDvrRecording = 1302,
	xamExp_XamIptvUninstall = 1303,
	xamExp_XamGetDvrStorage = 1304,
	xamExp_XamSetDvrStorage = 1305,
	xamExp_XamIptvGetServiceName = 1306,
	xamExp_XamNuiHudGetEngagedEnrollmentIndex = 1307,
	xamExp_XamProfileSetCachedWindowsLiveEmail = 1308,
	xamExp_XamProfileGetCachedWindowsLiveEmail = 1309,
	xamExp_XamUserResetSubscriptionType = 1310,
	xamExp_XamLrcSetTitlePort = 1311,
	xamExp_XamLrcVerifyClientId = 1312,
	xamExp_XamLrcEncryptDecryptTitleMessage = 1313,
	xamExp_XamFitnessGetSyncStatus = 1314,
	xamExp_XamFitnessInitializeForOneUser = 1315,
	xamExp_XamFitnessGetSuggestedPrivacySettings = 1316,
	xamExp_XampFitnessLetFireAndForgetsCatchUpInternal = 1317,
	xamExp_XamInputGetFailedConnectionOrBind = 1318,
	xamExp_XuiSceneIsInTransition = 1319,
	xamExp_XamIsOnPrivateNetwork = 1320,
	xamExp_XamInputSetMinMaxAuthDelay = 1321,
	xamExp_XamInputNonControllerGetRawEx = 1322,
	xamExp_XamInputNonControllerSetRawEx = 1323,
	xamExp_XamMarketplaceAcquireFreeContent = 1324, // XMarketplaceAcquireFreeContent
	xamExp_XamGetClosedCaptioningState = 1325,
	xamExp_XamGetClosedCaptioningSettings = 1326,
	xamExp_XamSetClosedCaptioningState = 1327,
	xamExp_XamLoaderGetLogonTitle = 1328,
	xamExp_XamShowAndWaitForMessageBoxEx = 1337,
	xamExp_XamGetCurrencyFormat = 1339,
	xamExp_XamFormatCurrency = 1340,
	xamExp_XamGetUserBalance = 1343,
	xamExp_XamIsGuideDisabled = 1344,
	xamExp_XampCallXAccountTransitionStoredValuePointsToCurrency = 1345,
	xamExp_XampSetMockCallXAccountTransitionStoredValuePointsToCurrency = 1346,
	xamExp_XamShowCsvTransitionUI = 1347,
	xamExp_XamAskUserForCSVDrainagePermission = 1348,
	xamExp_XamIsCSVDrainageSupported = 1349,
	xamExp_XamGetServiceEndpoint = 1399,
	xamExp_XamSetMockAdapterState = 1404,
	xamExp_XamSetMockAdapterResponse = 1405,
	xamExp_XamClearMockAdapters = 1406,
	xamExp_XamLrcKeyboardGetInput = 1407,
	xamExp_XamLrcKeyboardGetRequiredBufferSize = 1408,
	xamExp_XamLrcKeyboardRegister = 1409,
	xamExp_XamLrcKeyboardUnregister = 1410,
	xamExp_XamLrcKeyboardUpdateText = 1411,
	xamExp_XamValidateCountry = 1412,
	xamExp_XamGetOnlineCountryString = 1413,
	xamExp_XamGetCountryString = 1414,
	xamExp_XamGetLanguageString = 1415,
	xamExp_XamGetLanguageLocaleString = 1416,
	xamExp_XamGetOnlineLanguageAndCountryString = 1417,
	xamExp_XamGetLanguageLocaleFallbackString = 1418,
	xamExp_XamGetOnlineLanguageAndCountry = 1419,
	xamExp_XamGetLanguageTypeface = 1420,
	xamExp_XamGetLanguageTypefacePatch = 1421,
	xamExp_XamGetLocaleString = 1422,
	xamExp_XamGetLocaleFromOnlineCountry = 1423,
	xamExp_XamOfflineTimerSetData = 1424,
	xamExp_XamOfflineTimerResume = 1425,
	xamExp_XamOfflineTimerSuspend = 1426,
	xamExp_XamOfflineTimerIsRunning = 1427,
	xamExp_XamOfflineTimerIsEnabled = 1428,
	xamExp_XamOfflineTimerGetTimeRemaining = 1429,
	xamExp_XamOfflineTimerGetContractData = 1430,
	xamExp_XamOfflineTimerInitialize = 1431,
	xamExp_XamOfflineTimerGetData = 1432,
	xamExp_XamPlayToRegister = 1433,
	xamExp_XamPlayToReportPlaybackState = 1434,
	xamExp_XamPlayToUnregister = 1435,
	xamExp_XamShowTFAUI = 1436,
	xamExp_XamGetOnlineCountryFeatures = 1438,
	xamExp_XamLogLocalizationEtx = 1439,
	xamExp_XampXAuthIsLocalSocketAllowed = 1440,
	xamExp_XamPlayToGetRequest = 1441,
	xamExp_XamPlayToCancelGetRequest = 1442,
	xamExp_XamPlayToCompleteRequest = 1443,
	xamExp_XamFitnessGetTitleSummaries = 1444,
	xamExp_XamFitnessGetTitleSummary = 1445,
	xamExp_XamOfflineTimerShutdown = 1446,
	xamExp_XamFitnessContainsFitnessData = 1447,
	xamExp_XamGetLanguageFromOnlineLanguage = 1448,
	xamExp_XamGetOnlineLanguageString = 1449,
	xamExp_XamGetCountryFromOnlineCountry = 1450,
	xamExp_XamGetLocaleEx = 1495,
	xamExp_XamOfflineTimerForceQuery = 1496,
	xamExp_XamShowCreateProfileUIEx = 1497,
	xamExp_XTLGetLanguageV2 = 1498,
	xamExp_XTLGetLocaleV1 = 1499,
	xamExp_XamAvatarInitialize = 1500,
	xamExp_XamAvatarShutdown = 1501,
	xamExp_XamAvatarGetMetadataLocalUser = 1502,
	xamExp_XamAvatarGetMetadataByXuid = 1503,
	xamExp_XamAvatarGetAssetsResultSize = 1504,
	xamExp_XamAvatarGetAssets = 1505,
	xamExp_XamAvatarGenerateMipMaps = 1506,
	xamExp_XamAvatarSetCustomAsset = 1507,
	xamExp_XamAvatarSetMetadata = 1508,
	xamExp_XamAvatarLoadAnimation = 1511,
	xamExp_XamAvatarBeginEnumAssets = 1512,
	xamExp_XamAvatarEndEnumAssets = 1513,
	xamExp_XamAvatarEnumAssets = 1514,
	xamExp_XamAvatarGetMetadataRandom = 1515,
	xamExp_XamAvatarGetMetadataSignedOutProfileCount = 1518,
	xamExp_XamAvatarGetMetadataSignedOutProfile = 1519,
	xamExp_XamAvatarMetadataGetBodyType = 1521,
	xamExp_XamAvatarGetInstrumentation = 1522,
	xamExp_XamAvatarGetAssetIcon = 1523,
	xamExp_XamAvatarWearNow = 1524,
	xamExp_XamAvatarGetAssetBinary = 1525,
	xamExp_XamLoaderGetSuspendedTitleInfo = 1526,
	xamExp_XamAvatarGetInstalledAssetPackageDescription = 1527,
	xamExp_XamAvatarSetAdapters = 1528,
	xamExp_XamLrcKeyboardValidateTextChange = 1529,
	xamExp_XamLrcKeyboardApplyTextChange = 1530,
	xamExp_XamLrcLogSessionSummary = 1531,
	xamExp_XamLrcLogError = 1532,
	xamExp_XamContentMountInstalledGame = 1550,
	xamExp_XamContentIsGameInstalledToHDD = 1551,
	xamExp_XamContentQueryLicenseInternal = 1552,
	xamExp_XamContentGetDeviceVolumePath = 1553,
	xamExp_XamContentDeviceCheckUpdates = 1554,
	xamExp_XamContentGetHeaderInternal = 1555,
	xamExp_XamNetworkStorageGetNetworkDevice = 1556,
	xamExp_XamNetworkStorageDeviceHasCacheFile = 1557,
	xamExp_XamNetworkStorageCreateCacheOnDevice = 1558,
	xamExp_XamNetworkStorageDeleteCacheOnDevice = 1559,
	xamExp_XamNetworkStorageGetStatus = 1560,
	xamExp_XamNetworkStorageIsSupportedContentType = 1561,
	xamExp_XamNetworkStorageSetTestMock = 1562,
	xamExp_XamNetworkStorageGetLastSyncTime = 1563,
	xamExp_XamShowNetworkStorageSyncUI = 1564,
	xamExp_XamUserIsLogonPreviewModeEnabled = 1565,
	xamExp_XamUserLockLogonPreviewMode = 1566,
	xamExp_XamUserUnlockLogonPreviewMode = 1567,
	xamExp_XamNetworkStorageIsUserInSync = 1568,
	xamExp_XamNetworkStorageSetUserInSync = 1569,
	xamExp_XamNetworkStorageOnSigninChanged = 1570,
	xamExp_XamNetworkStorageSignInTestMock = 1571,
	xamExp_XamShowFofUI = 1572,
	xamExp_CompareFileTime = 1573,
	xamExp_SetFileTime = 1574,
	xamExp_XamNetworkStorageGetTitleProperties = 1575,
	xamExp_XamNetworkStorageLockFile = 1576,
	xamExp_XamNetworkStorageUserHasPrivilege = 1577,
	xamExp_XamNetworkStorageIsTitleExempt = 1578,
	xamExp_XamContentExistsOnDeviceInternal = 1579,
	xamExp_XamNetworkStorageGetBackingDevice = 1580,
	xamExp_XamNetworkStorageIsEnabledInLiveHive = 1581,
	xamExp_XamNetworkStorageIsCheckingSyncStates = 1582,
	xamExp_XamNetworkStorageUserNeedsToSync = 1583,
	xamExp_XamNetworkStorageGetUserNetworkSyncTime = 1584,
	xamExp_XamNetworkStorageGetUserProperties = 1585,
	xamExp_XamNetworkStorageAppLauncherLaunchIfRunning = 1586,
	xamExp_XamNetworkStorageSetTitleProperties = 1587,
	xamExp_XamNetworkStorageGetUserLastError = 1588,
	xamExp_XamNetworkStorageCheckOutTitle = 1589,
	xamExp_XamNetworkStorageShouldHideFromTitle = 1590,
	xamExp_XamNetworkStorageOnUserSyncChange = 1591,
	xamExp_XamNetworkStorageHasUserEnabledStorage = 1592,
	xamExp_XamContentGetLocalizedDeviceData = 1593,
	xamExp_XamPackageManagerFindPackageContainingIndexedXEX = 1600,
	xamExp_XamPackageManagerReinitialize = 1601,
	xamExp_XamPackageManagerGetAuthoritativeManifestRevision = 1602,
	xamExp_XamGetCurrentSystemOnlineManifestRevision = 1603,
	xamExp_XamPackageManagerDeleteExtendedPartition = 1604,
	xamExp_XamPackageManagerHasExtendedPartition = 1605,
	xamExp_XamPackageManagerGetExperienceMode = 1606,
	xamExp_XamPackageManagerGetFeatureRequiresUpdateStrings = 1607,
	xamExp_XamPackageManagerGetFileSize = 1608,
	xamExp_XampDemandUpdateGetAttributes = 1609,
	xamExp_XampDemandUpdateGetExtendedAttributes = 1610,
	xamExp_XampDemandUpdateGetInstance = 1611,
	xamExp_XampDemandUpdateSetRefreshTestFlags = 1612,
	xamExp_XampDemandUpdateIsRefreshTestFlagSet = 1613,
	xamExp_XampDemandUpdateGetManifestLocalPath = 1614,
	xamExp_XampDemandUpdateRefreshManifest = 1615,
	xamExp_XdfInitialize = 1616,
	xamExp_XdfShutdown = 1617,
	xamExp_XdfGetExpectedDownloadSize = 1618,
	xamExp_XdfGetItem = 1619,
	xamExp_XdfCacheItem = 1620,
	xamExp_XdfLoadXexFromCache = 1621,
	xamExp_XdfLoadXex = 1622,
	xamExp_XdfCancelRequest = 1623,
	xamExp_XdfResumeDelayedItem = 1624,
	xamExp_XdfLaunchNewImageFromCache = 1625,
	xamExp_XampDemandUpdateRefreshManifestDuringLogon = 1626,
	xamExp_XampDemandUpdateCheckOnlineManifestChanged = 1627,
	xamExp_XampDemandUpdateRunCacheCleaner = 1628,
	xamExp_XamUpdateGetTitleUpdateSizeThreshold = 1669,
	xamExp_XamXStudioRequest = 1670,
	xamExp_XamNotifyDelayUIInternal = 1671,
	xamExp_XamShowAvatarMiniCreatorUI = 1700,
	xamExp_XamShowGoldUpgradeUI = 1701,
	xamExp_XamResumeUpdaterUI = 1702,
	xamExp_XamShowDirectAcquireUI = 1703,
	xamExp_XamShowPaymentOptionsUI = 1704,
	xamExp_XamShowMultiplayerUpgradeUI = 1705,
	xamExp_XamGetLiveHiveValueA = 1800,
	xamExp_XamGetLiveHiveValueW = 1801,
	xamExp_XamGetLiveHiveValueDuringLogonAttemptA = 1802,
	xamExp_XamSetUserPresetWindowsLiveCreds = 1803,
	xamExp_XamQueryLiveHiveA = 1804,
	xamExp_XamQueryLiveHiveW = 1805,
	xamExp_XamGetLiveHiveValueDuringLogonAttemptExA = 1806,
	xamExp_XamGetUserPresetWindowsLiveCreds = 1807,
	xamExp_XamGetUserNeedTFA = 1808,
	xamExp_XamSetUserNeedTFA = 1809,
	xamExp_XamGetUserInMemoryWindowsLiveCreds = 1810,
	xamExp_XamSetStagingMode = 1902,
	xamExp_XamGetStagingMode = 1903,
	xamExp_XamAppGetSessionId = 1904,
	xamExp_XamAccountRecoveryRecoverAllProfileData = 1905,
	xamExp_XamAccountRecoveryGetProgress = 1906,
	xamExp_XamDoesOmniNeedConfiguration = 2000,
	xamExp_GetProcessHeap = 2002,
	xamExp_UnhandledExceptionFilter = 2003,
	xamExp_SetUnhandledExceptionFilter = 2004,
	xamExp_XamIsOptionalMediaUpdateInstalled = 2005,
	xamExp_XamShowOptionalMediaUpdateRequiredUI = 2006,
	xamExp_XamShowOptionalMediaUpdateRequiredUIEx = 2007,
	xamExp_XamTaskCreateQueueEx = 2009,
	xamExp_XamSetTextureLoaderHook = 2010,
	xamExp_XamLaunchAvatarEditor = 2011,
	xamExp_XamLoadExtraAVCodecs = 2012,
	xamExp_XamUnloadExtraAVCodecs = 2013,
	xamExp_XamSetLastActiveUserData = 2014,
	xamExp_XamGetLastActiveUserData = 2015,
	xamExp_XamSetActiveDashAppInfo = 2016,
	xamExp_XamGetActiveDashAppInfo = 2017,
	xamExp_XamLoaderRegisterLaunchRequestCallback = 2018,
	xamExp_XamLoadExtraAVCodecs2 = 2019,
	xamExp_XamUnloadExtraAVCodecs2 = 2020,
	xamExp_XamUserCreateAvatarAssetEnumerator = 2050,
	xamExp_XamInitializeGameTileCache = 2051,
	xamExp_XamDestroyGameTileCache = 2052,
	xamExp_XamReadGameTileImage = 2053,
	xamExp_XamShouldThrottleAccountInfoCall = 2054,
	xamExp_XuiClassDerivesFrom = 2055,
	xamExp_XuiFreeVisuals = 2056,
	xamExp_XuiGetBaseClass = 2057,
	xamExp_XuiLoadVisualFromBinary = 2058,
	xamExp_XuiResourceGetBuffer = 2059,
	xamExp_XuiResourceGetTotalSize = 2060,
	xamExp_XuiElementGetUserData = 2061,
	xamExp_XuiElementSetUserData = 2062,
	xamExp_XuiTabSceneGetCount = 2063,
	xamExp_XuiSliderGetStep = 2064,
	xamExp_XuiSliderSetStep = 2065,
	xamExp_XuiProgressBarGetRange = 2066,
	xamExp_XuiElementSetHittable = 2067,
	xamExp_XuiElementPlayNamedFrames = 2068,
	xamExp_XuiElementGetPivot = 2069,
	xamExp_XuiElementGetPrev = 2070,
	xamExp_XuiElementGetScale = 2071,
	xamExp_XuiElementSetPivot = 2072,
	xamExp_XuiElementSetRotation = 2073,
	xamExp_XuiElementSetScale = 2074,
	xamExp_XuiControlWantsUnfocusedInput = 2075,
	xamExp_XuiResourceOpenNoLoc = 2076,
	xamExp_XuiResourceReleasePackage = 2077,
	xamExp_XuiResourceGetPackageEntryInfo = 2078,
	xamExp_XuiResourceGetPackageEntryCount = 2079,
	xamExp_XuiResourceOpenPackage = 2080,
	xamExp_XamCodeCoverageFileOpen = 2081,
	xamExp_XamCodeCoverageFileClose = 2082,
	xamExp_XamCodeCoverageFileLseek = 2083,
	xamExp_XamCodeCoverageFileRead = 2084,
	xamExp_XamCodeCoverageFileWrite = 2085,
	xamExp_XampHeapGetInfo = 2087,
	xamExp_XampHeapGetCount = 2088,
	xamExp_XampKioskSetTestMockValues = 2089,
	xamExp_XuiElementLayoutTree = 2090,
	xamExp_XamInactivityResetAllState = 2091,
	xamExp_XUIElementPropVal_SetInt = 2092,
	xamExp_XUIElementPropVal_SetFloat = 2093,
	xamExp_XuiObjectGetPropertyDef = 2094,
	xamExp_XuiRenderGetDevice = 2095,
	xamExp_XuiRenderRestoreState = 2096,
	xamExp_XuiElementGetFullXForm = 2097,
	xamExp_XuiRenderGetViewTransform = 2098,
	xamExp_XuiRenderGetColorSpace = 2099,
	xamExp_XamPngEncode = 2100,
	xamExp_XamPngDecode = 2101,
	xamExp_XamPngEncodeEx = 2102,
	xamExp_XuiTextElementMeasureText = 2103,
	xamExp_XamLoaderShouldConfirmReboot = 2104,
	xamExp_XamLoaderRebootToDash = 2105,
	xamExp_XamNuiHudGetEngagedTrackingID = 2106,
	xamExp_XamLoaderLaunchTitleForReason = 2107,
	xamExp_XamNuiHudSetEngagedTrackingID = 2108,
	xamExp_XuiBrushGetTexture = 2109,
	xamExp_XuiBrushGetDims = 2110,
	xamExp_XuiElementGetDescendantById = 2111,
	xamExp_XamLoaderIsKinectUIPreferredForLogonTitle = 2112,
	xamExp_XamAccountRecoveryGetSetTitleSyncTime = 2120,
	xamExp_XamReadBiometricData = 2121,
	xamExp_XamWriteBiometricData = 2122,
	xamExp_XamD3DResourceDescriptorCreate = 2123,
	xamExp_XamD3DResourceDescriptorAddRef = 2124,
	xamExp_XamD3DResourceDescriptorRelease = 2125,
	xamExp_XamD3DResourceAddRef = 2126,
	xamExp_XamD3DResourceSet = 2127,
	xamExp_XamD3DResourceIsBusy = 2128,
	xamExp_XamD3DResourceRelease = 2129,
	xamExp_ControlPackGetCursorPosition = 2130,
	xamExp_ControlPackShouldShowCursor = 2131,
	xamExp_XamFlushAgraTemperatureReport = 2136,
	xamExp_XamNatalDeviceAudioCalibrate = 2137,
	xamExp_XamNuiIdentityGetEnrollmentInfo = 2138,
	xamExp_XamNuiIdentityUnenroll = 2139,
	xamExp_XamNuiIdentityGetColorTexture = 2140,
	xamExp_XamReportKinectSettingsChangedEvent = 2141,
	xamExp_XamNuiEnableChatMic = 2142,
	xamExp_XamNuiIsChatMicEnabled = 2143,
	xamExp_XamNuiGetDepthCalibration = 2144,
	xamExp_XamNuiStoreDepthCalibration = 2145,
	xamExp_XamUserNuiIsBiometricEnabled = 2146,
	xamExp_XamUserNuiEnableBiometric = 2147,
	xamExp_XamNuiCameraSetFlags = 2148,
	xamExp_XamNuiCameraRememberFloor = 2149,
	xamExp_XamUserNuiGetUserIndexForBind = 2150,
	xamExp_XamUserNuiGetUserIndexForSignin = 2151,
	xamExp_XamUserNuiBind = 2152,
	xamExp_XamUserNuiGetUserIndex = 2153,
	xamExp_XamUserNuiGetEnrollmentIndex = 2154,
	xamExp_XamUserNuiUnbind = 2155,
	xamExp_XamNuiUseTemporaryDepthCalibration = 2156,
	xamExp_XamNuiCameraTiltSetCallback = 2157,
	xamExp_XamNuiHudIsEnabled = 2158,
	xamExp_XamNuiCameraGetTiltControllerType = 2159,
	xamExp_XamNuiCameraTiltGetStatus = 2160,
	xamExp_XamNuiIdentityGetQualityFlags = 2161,
	xamExp_XamNuiIdentityEnrollForSignIn = 2162,
	xamExp_XamNuiIdentityGetSessionId = 2163,
	xamExp_XamNuiIdentityIdentifyWithBiometric = 2164,
	xamExp_ControlPackGetHandleManager = 2165,
	xamExp_XamEnableNuiAutomation = 2166,
	xamExp_XamNuiGetSystemGestureControl = 2167,
	xamExp_XamGetPasscodeKeyFromVirtualKey = 2168,
	xamExp_XamEnableNatalPlayback = 2169,
	xamExp_XamIsNuiAutomationEnabled = 2170,
	xamExp_XamIsNatalPlaybackEnabled = 2171,
	xamExp_XamNuiHudInterpretFrame = 2172,
	xamExp_XamNuiHudEnableInputFilter = 2173,
	xamExp_XamUserNuiIsBiometricAugmentRecommended = 2174,
	xamExp_XamNuiHudGetInitializeFlags = 2175,
	xamExp_XamNuiCameraElevationSetAngle = 2176,
	xamExp_XamNuiCameraElevationGetAngle = 2177,
	xamExp_XamNuiCameraElevationAutoTilt = 2178,
	xamExp_XamNuiCameraElevationStopMovement = 2179,
	xamExp_XamNuiCameraElevationSetCallback = 2180,
	xamExp_XamNuiGetDeviceStatus = 2181,
	xamExp_XamNuiNatalCameraUpdateStarting = 2182,
	xamExp_XamNuiNatalCameraUpdateComplete = 2183,
	xamExp_XamNuiHudGetVersions = 2184,
	xamExp_XamGetHUDElementByPath = 2185,
	xamExp_XamGetHUDElementByAutoId = 2186,
	xamExp_XuiElementGetScreenPositionCenter = 2187,
	xamExp_XamNuiCameraElevationReverseAutoTilt = 2188,
	xamExp_ControlPackSimpleCursorGetRayFromScreenPosition = 2189,
	xamExp_ControlPackSideNavControlGetNuiHandle = 2190,
	xamExp_XamFindHUDElementByXuiId = 2191,
	xamExp_XamNuiIsDeviceReady = 2192,
	xamExp_XamNuiSetForceDeviceOff = 2193,
	xamExp_XamNuiPlayerEngagementUpdate = 2194,
	xamExp_XamNuiSkeletonGetBestSkeletonIndex = 2195,
	xamExp_XamNuiSkeletonScoreUpdate = 2196,
	xamExp_XamNuiCameraTiltReportStatus = 2197,
	xamExp_XamNuiCameraAdjustTilt = 2198,
	xamExp_XamNuiIdentityAbort = 2199,
	xamExp_D3DDevice_CreateVertexShader = 2200,
	xamExp_D3DDevice_CreatePixelShader = 2201,
	xamExp_D3DDevice_CreateTexture = 2202,
	xamExp_D3DDevice_CreateVertexBuffer = 2203,
	xamExp_D3DDevice_CreateIndexBuffer = 2204,
	xamExp_D3DDevice_CreateVertexDeclaration = 2205,
	xamExp_D3DVertexBuffer_Unlock = 2206,
	xamExp_D3DVertexBuffer_Lock = 2207,
	xamExp_D3DIndexBuffer_Unlock = 2208,
	xamExp_D3DIndexBuffer_Lock = 2209,
	xamExp_D3DTexture_UnlockRect = 2210,
	xamExp_D3DTexture_LockRect = 2211,
	xamExp_D3DDevice_Clear = 2212,
	xamExp_D3DDevice_SetViewport = 2213,
	xamExp_D3DDevice_GetViewport = 2214,
	xamExp_D3DDevice_SetRenderState_SrcBlend = 2215,
	xamExp_D3DDevice_SetRenderState_DestBlend = 2216,
	xamExp_D3DResource_Release = 2218,
	xamExp_D3DDevice_Release = 2219,
	xamExp_D3DDevice_SetVertexShader = 2220,
	xamExp_D3DDevice_SetPixelShader = 2221,
	xamExp_D3DDevice_SetTexture = 2222,
	xamExp_D3DDevice_SetVertexDeclaration = 2223,
	xamExp_D3DDevice_SetIndices = 2224,
	xamExp_D3DDevice_SetStreamSource = 2225,
	xamExp_D3DDevice_DrawVertices = 2226,
	xamExp_D3DDevice_DrawVerticesUP = 2227,
	xamExp_D3DDevice_DrawIndexedVertices = 2228,
	xamExp_D3DDevice_DrawIndexedVerticesUP = 2229,
	xamExp_D3DDevice_SetVertexShaderConstantF_ParameterCheck = 2230,
	xamExp_D3DDevice_SetPixelShaderConstantF_ParameterCheck = 2231,
	xamExp_D3DDevice_SetSamplerState_ParameterCheck = 2232,
	xamExp_D3DDevice_SetRenderState_ParameterCheck = 2233,
	xamExp_D3DDevice_GetRenderState_ParameterCheck = 2234,
	xamExp_D3DDevice_SetVertexShaderConstantFN = 2235,
	xamExp_D3DDevice_SetPixelShaderConstantFN = 2236,
	xamExp_D3DDevice_GetRenderState_ZEnable = 2237,
	xamExp_D3DDevice_GetRenderState_CullMode = 2238,
	xamExp_D3DDevice_GetRenderState_AlphaBlendEnable = 2239,
	xamExp_D3DDevice_GetRenderState_SrcBlendAlpha = 2240,
	xamExp_D3DDevice_GetRenderState_DestBlendAlpha = 2241,
	xamExp_D3DDevice_GetRenderState_BlendOp = 2242,
	xamExp_D3DDevice_GetRenderState_ViewportEnable = 2243,
	xamExp_D3DDevice_SetRenderState_ZEnable = 2244,
	xamExp_D3DDevice_SetRenderState_CullMode = 2245,
	xamExp_D3DDevice_SetRenderState_AlphaBlendEnable = 2246,
	xamExp_D3DDevice_SetRenderState_SrcBlendAlpha = 2247,
	xamExp_D3DDevice_SetRenderState_DestBlendAlpha = 2248,
	xamExp_D3DDevice_SetRenderState_BlendOp = 2249,
	xamExp_D3DDevice_SetRenderState_ViewportEnable = 2250,
	xamExp_D3DDevice_SetSamplerState_MagFilter = 2251,
	xamExp_D3DDevice_SetSamplerState_MinFilter = 2252,
	xamExp_D3DDevice_SetSamplerState_AddressU = 2253,
	xamExp_D3DDevice_SetSamplerState_AddressV = 2254,
	xamExp_XGSetTextureHeader = 2255,
	xamExp_XGGetTextureDesc = 2256,
	xamExp_XGOffsetResourceAddress = 2257,
	xamExp_D3DResource_AddRef = 2258,
	xamExp_XGSetTextureHeaderEx = 2262,
	xamExp_D3DDevice_GetRenderTarget = 2263,
	xamExp_D3DDevice_SetRenderTarget = 2264,
	xamExp_D3DDevice_GetDepthStencilSurface = 2265,
	xamExp_D3DDevice_SetDepthStencilSurface = 2266,
	xamExp_D3DDevice_Resolve = 2267,
	xamExp_D3DDevice_SetPixelShaderConstantB = 2268,
	xamExp_XamNuiGetDeviceSerialNumber = 2269,
	xamExp_XamNuiGetLoadedDepthCalibration = 2270,
	xamExp_XamNuiGetTrueColorInfo = 2271,
	xamExp_XamNuiGetCameraIntrinsics = 2272,
	xamExp_XamNuiGetFanRate = 2273,
	xamExp_XamNuiGetSupportString = 2274,
	xamExp_XamKinectGetHardwareType = 2275,
	xamExp_XamMediaVerificationCreate = 2491,
	xamExp_XamMediaVerificationClose = 2492,
	xamExp_XamMediaVerificationVerify = 2493,
	xamExp_XamMediaVerificationFailedBlocks = 2494,
	xamExp_XamMediaVerificationInject = 2495,
	xamExp_XamShowBadDiscErrorUI = 2496,
	xamExp_XamBackgroundDownloadSetMode = 2500,
	xamExp_XamBackgroundDownloadIsEnabled = 2501,
	xamExp_XamBackgroundDownloadGetActiveItem = 2502,
	xamExp_XamBackgroundDownloadGetItems = 2503,
	xamExp_XamBackgroundDownloadClearItems = 2504,
	xamExp_XamBackgroundDownloadItemAdd = 2505,
	xamExp_XamBackgroundDownloadItemRemove = 2506,
	xamExp_XamBackgroundDownloadItemMakeFirst = 2507,
	xamExp_XamBackgroundDownloadSetForegroundPriority = 2508,
	xamExp_XamBackgroundDownloadGetForegroundPriority = 2509,
	xamExp_XamBackgroundDownloadItemToContentData = 2510,
	xamExp_XamBackgroundDownloadItemGetStatus = 2511,
	xamExp_XamBackgroundDownloadHistoryGetItem = 2512,
	xamExp_XamBackgroundDownloadItemGetHistoryStatus = 2513,
	xamExp_XamBackgroundDownloadItemSetHistoryStatus = 2514,
	xamExp_XamBackgroundDownloadItemGetStatusAsync = 2515,
	xamExp_XamBackgroundDownloadItemGetStatusEx = 2516,
	xamExp_XamBackgroundDownloadItemGetHistoryStatusEx = 2517,
	xamExp_XamBackgroundDownloadBindItems = 2518,
	xamExp_XamBackgroundDownloadSetPollingActive = 2519,
	xamExp_XamBackgroundDownloadGetPollingActive = 2520,
	xamExp_XamBackgroundDownloadGetMode = 2521,
	xamExp_XamBackgroundDownloadGetUnexpectedChangeCount = 2522,
	xamExp_XamBackgroundDownloadIsItemForThisConsole = 2523,
	xamExp_XamBackgroundDownloadSelectDevice = 2524,
	xamExp_XamBackgroundDownloadItemModify = 2525,
	xamExp_XamBackgroundDownloadCacheLegacyMappingInfo = 2526,
	xamExp_XamBackgroundDownloadGetLegacyMappingInfo = 2527,
	xamExp_XamBackgroundDownloadGetLegacyId = 2528,
	xamExp_XamBackgroundDownloadDoFail = 2529,
	xamExp_XamSwapDisc = 2600,
	xamExp_XamSwapDiscPatchAddress = 2601,
	xamExp_XamSwapCancel = 2602,
	xamExp_XamContentSetAttributes = 2603,
	xamExp_XamRamDriveCreate = 2610,
	xamExp_XamRamDriveDestroy = 2611,
	xamExp_XamPlayTimerGetData = 2650,
	xamExp_XamPlayTimerSetData = 2651,
	xamExp_XamPlayTimerResume = 2652,
	xamExp_XamPlayTimerSuspend = 2653,
	xamExp_XamPlayTimerIsRunning = 2654,
	xamExp_XamPlayTimerIsEnabled = 2655,
	xamExp_XamPlayTimerGetNextResetDate = 2656,
	xamExp_XamPlayTimerFormatDurationString = 2657,
	xamExp_XamPlayTimerGetTimeRemaining = 2658,
	xamExp_XamPlayTimerUpdateTimeRemaining = 2659,
	xamExp_XamPlayTimerForceNotification = 2660,
	xamExp_XamPlayTimerRefreshResetDate = 2661,
	xamExp_XuiResourceOpenAndVerifyNoLoc = 2662,
	xamExp_UpnpAVServerSearchInitialize = 2670,
	xamExp_UpnpAVServerSearchDestroy = 2671,
	xamExp_UpnpAVServerSearchStart = 2672,
	xamExp_UpnpAVServerSearchDoWork = 2674,
	xamExp_UpnpAVServerSearchGetNextServer = 2675,
	xamExp_XCustomBroadcastGamercardEvent = 2700,
	xamExp_XamCustomGetCurrentActions = 2701,
	xamExp_XamInstrumentationLogEvent = 2720,
	xamExp_XamRegisterSMCNotification = 2721,
	xamExp_XamIsScreenSaverActive = 2728,
	xamExp_XamInstrumentationLogEventEx = 2730,
	xamExp_XamInstrumentationGetSourceConfig = 2731,
	xamExp_XamInstrumentationDebugConfig = 2732,
	xamExp_CurlCreateCacheEntry = 2780,
	xamExp_CurlOpenCacheEntry = 2781,
	xamExp_CurlSetCacheEntryExpireTime = 2782,
	xamExp_CurlReadCacheEntryHeaders = 2783,
	xamExp_CurlReadCacheEntryContent = 2784,
	xamExp_CurlWriteCacheEntryContent = 2785,
	xamExp_CurlCloseCacheEntry = 2786,
	xamExp_CurlEnumerateCacheEntry = 2787,
	xamExp_CurlWipeBackingFiles = 2789,
	xamExp_CurlOpenTitleBackingFile = 2791,
	xamExp_XamUserIsPartialProfile = 2794,
	xamExp_XamLocateTitle = 2795,
	xamExp_XamProfileGetLocalTitleCount = 2796,
	xamExp_XamContentRemoveCacheDevice = 2797,
	xamExp_XamContentAddCacheDevice = 2798,
	xamExp_XamSetSecurityViolationDetected = 2800,
	xamExp_XamIsSecurityViolationDetected = 2801,
	xamExp_XamIsAnySecurityViolationDetected = 2802,
	xamExp_XamGetSecurityViolationsDetected = 2803,
	xamExp_XamActivateCounterMeasure = 2804,
	xamExp_XamDeactivateCounterMeasure = 2805,
	xamExp_XamIsCounterMeasureActivated = 2806,
	xamExp_XamGetActiveCounterMeasures = 2807,
	xamExp_XamPmdIdentify = 2808,
	xamExp_XamPmdSendCommand = 2809,
	xamExp_XamPmdReadReport = 2810,
	xamExp_XamPartyCreate = 2812,
	xamExp_XamPartyLeave = 2813,
	xamExp_XamPartySendInviteDeprecated = 2814,
	xamExp_XamPartyGetUserList = 2815,
	xamExp_XamPartySendGameInvites = 2816,
	xamExp_XamPartyJoin = 2817,
	xamExp_XamPartyKickUser = 2818,
	xamExp_XamPartyAddLocalUsers = 2819,
	xamExp_XamGetLocaleTimeFormat = 2821,
	xamExp_XamPartyRemoveLocalUsers = 2822,
	xamExp_XamPartyGetUserListInternal = 2823,
	xamExp_XamPartySetJoinable = 2824,
	xamExp_XamPartyGetJoinable = 2825,
	xamExp_XamPartyGetInfo = 2826,
	xamExp_XamPartySetCustomData = 2827,
	xamExp_XamPartySetConnectivityGraph = 2828,
	xamExp_XamPartyGetRoutingTable = 2829,
	xamExp_XamPartyAutomationInprocCall = 2830,
	xamExp_XamPartyGetState = 2831,
	xamExp_XamPartyGetBandwidth = 2832,
	xamExp_XamPartyGetNetworkCounters = 2833,
	xamExp_XamShowQuickLaunchUI = 2834,
	xamExp_XamPartyIsCoordinator = 2835,
	xamExp_XamPartyGetFormation = 2836,
	xamExp_XamPartySendInvite = 2837,
	xamExp_XamPartySetTestDelay = 2838,
	xamExp_XamPartyOverrideNatType = 2839,
	xamExp_XamPartyGetAccessLevel = 2840,
	xamExp_XamPartySetTestFlags = 2841,
	xamExp_XamIsSystemExperienceTitleId = 2842,
	xamExp_XamPartyJoinEx = 2843,
	xamExp_XamPartyGetInfoEx = 2844,
	xamExp_XamIsCurrentTitleDatacenterClient = 2848,
	xamExp_XamTaskSetCancelSubTasks = 2850,
	xamExp_XamTaskGetCompletionStatus = 2851,
	xamExp_XamTaskCancelWaitAndCloseWaitTask = 2852,
	xamExp_XamDataCenterLog = 2855,
	xamExp_XamDataCenterGetDhcpOptionResponseHostnameAndPort = 2856,
	xamExp_XamDataCenterLogEvent = 2857,
	xamExp_XamDataCenterShowForceSignInMessage = 2858,
	xamExp_XamWebInstrumentationCreateReport = 2860,
	xamExp_XamWebInstrumentationSetUserVar = 2861,
	xamExp_XamWebInstrumentationSetUserVarNoEscape = 2862,
	xamExp_XamWebInstrumentationGetURL = 2863,
	xamExp_XamWebInstrumentationSendReport = 2864,
	xamExp_XamWebInstrumentationDestroyReport = 2865,
	xamExp_XamWebInstrumentationCreateSampledReport = 2866,
	xamExp_XampSetSamplingRandomValue = 2867,
	xamExp_XampWebInstrumentationSetProfileCounts = 2868,
	xamExp_XamWebInstrumentationGetURLEx = 2869,
	xamExp_XampSetOmnitureCallbackFunction = 2870,
	xamExp_XamShowQuickChatUIp = 2871,
	xamExp_XamShowSocialPostUI = 2872,
	xamExp_XamShowBeaconsUI = 2873,
	xamExp_XamShowMarketplacePurchaseOrderUI = 2874,
	xamExp_XamShowMarketplaceGetOrderReceipts = 2875,
	xamExp_XamShowGenericOnlineAppUI = 2876,
	xamExp_XamUserAllowedToPostToSocialNetwork = 2877,
	xamExp_XamShowMarketplacePurchaseOrderUIEx = 2878,
	xamExp_DebugXamShowMessageBoxUI_Wait = 2879,
	xamExp_XamSetCountry = 2883,
	xamExp_XamIsCurrentTitleDatacenterDash = 2884,
	xamExp_XamLoaderRebootToServerDash = 2885,
	xamExp_XamIsDataCenterMode = 2886,
	xamExp_XamUserGetXUIDForTFA = 2888,
	xamExp_XamVerifyXSignerSignature = 2890,
} xamExp_Enum;


```

`XenonDumper/libs/xkelib/xam/xamNet.h`:

```h
#ifndef __XAMNET_DEFINES_H
#define __XAMNET_DEFINES_H

// 0x0001
// #define SO_ACCEPTCONN	0x0002		// in SDK - socket has had listen()
// #define SO_REUSEADDR		0x0004		// in SDK - allow local address reuse
#define SO_MCASTMEMBER		0x0005 // dword (0xEFFFFFFA)
#define SO_MCASTMEMBER_DEL	0x0006 // dword (0xEFFFFFFA)
// #define SO_BROADCAST    	0x0020      // in SDK - permit sending of broadcast msgs
// #define SO_LINGER       	0x0080      // in SDK - linger on close if data present
// #define SO_SNDBUF		0x1001		// in SDK - send buffer size
// #define SO_RCVBUF		0x1002		// in SDK - receive buffer size
// #define SO_SNDLOWAT		0x1003		// send low-water mark
// #define SO_RCVLOWAT		0x1004		// receive low-water mark
// #define SO_SNDTIMEO		0x1005		// in SDK - send timeout
// #define SO_RCVTIMEO		0x1006		// in SDK - receive timeout
// #define	SO_ERROR		0x1007		// get error status and clear
// #define	SO_TYPE			0x1008		// in SDK -  get socket type
#define SO_MARKINSECURE		0x5801 // bool TRUE for insecure
#define SO_PRIVATE			0x5802 // bool TRUE for private
#define SO_GRANTINSECURE	0x5803 // bool TRUE for insecure
#define SO_NOT_SURE1		0x5804 // dword 4 or 0x58 to 0x5B4 ?set SACK errorlevel?
#define SO_EN_SACKERRL		0x5805 // dword ?4? enable SACK
// 0xFFFB or -0x5, SO_EXCLUSIVEADDRUSE  in SDK
// 0xFF7F or -0x81, SO_DONTLINGER in SDK
// dash uses set 20 0x4, 1001 0x4, 4 0x4, FFFB 0x4, 1002 0x4, 
// dash uses get 1001 0x4, 

// these are in the sdk
// #define XNET_OPTID_STARTUP_PARAMS				1
// #define XNET_OPTID_NIC_XMIT_BYTES				2
// #define XNET_OPTID_NIC_XMIT_FRAMES				3
// #define XNET_OPTID_NIC_RECV_BYTES				4
// #define XNET_OPTID_NIC_RECV_FRAMES				5
// #define XNET_OPTID_CALLER_XMIT_BYTES				6
// #define XNET_OPTID_CALLER_XMIT_FRAMES			7
// #define XNET_OPTID_CALLER_RECV_BYTES				8
// #define XNET_OPTID_CALLER_RECV_FRAMES			9
#define XNET_OPTID_XPLAT_CROSS_SUBNET		0xa // min 0x4, possibly BOOL
#define XNET_OPTID_TCP_COALESCE_MODE		0xb // BOOL* min 0x4

#define XNET_OPTID_NEUTERED					0x1389 // min 0x4
#define XNET_OPTID_UNK_138A					0x138a // min 0x10
#define XNET_OPTID_UNK_138B					0x138b // min 0x18
#define XNET_OPTID_XNKID_SECURITY			0x138c // IpGetXnkidSecurity XNPXNKIDSECURITY * min 0x14
#define XNET_OPTID_SOCK_SECURITY			0x138d // SockGetSocketSecurity XNPSOCKETSECURITY * min 0x10
#define XNET_OPTID_ONLINE_PRIVS				0x138e // min 0x4
#define XNET_OPTID_MIN_FLASH_FALL06			0x138f // BOOL* min 0x4
#define XNET_OPTID_PROMISCUOUS_MODE			0x1390 // min 0x4
#define XNET_OPTID_ARP_ENTRY				0x1391 // EnetGetArpEntry XNPARPENTRY * min 0x10
#define XNET_OPTID_ROUTE_ENTRY				0x1392 // RouteGetEntryOrTable XNPROUTEENTRY * min 0x18  CXnIp::RouteSetEntry
#define XNET_OPTID_DOMAIN_NAME				0x1393 // IpGetDomainName char * min none
#define XNET_OPTID_GREYLIST					0x1394 // IpSetGreyListAddrs XNPGREYLISTADDRESSENTRY * min 0x8
#define XNET_OPTID_LINK_STATUS_OVERRIDE		0x1395 // BaseGetLinkStatusOverride XNPLINKSTATUSOVERRIDE * min 0x8
#define XNET_OPTID_UNK_1396					0x1396 // min 0x2
#define XNET_OPTID_WIRELESS_FLAGS			0x1397 // IpGetWirelessStatusSummaryFlags DWORD * min 0x4
#define XNET_OPTID_PRIMARY_SG_NONCE			0x1398 // IpLogonGetPrimarySgNonce QWORD * min 0x8
#define XNET_OPTID_SEC_ASSOC_INFO			0x1399 // IpGetSecAssocInfo XnSecAssocInfo * min 0x78
// 0x2710-272f, 0x2AF8-0x2B5C, 2730, 2732, 2733, (optid&0xD0303FF)=0xD0303FF -> BaseNicGetOpt -> kernel NicGetOpt
#define XNET_OPTID_BOUND_NIC				0x2734 // BaseModifyBoundNicDevices DWORD* min 4
#define XNET_OPTID_DSCP_VALUE				0x2f01 // PBYTE min/max 1 
// 		dash uses get:
// 2AFC 	0x28	XUSER_SIGNING_INFO XNDNS
// 2AF9 	0x4		
// D010102 	0x24	XNADDR
// D010108 	0x4		
// 2B02 	0x4		
// 2AFA 	0x48	
// D010203 	0x30	
// 2AFD 	0x30	
// 2AF9 	0x4		
// D010101 	0x6		
// D01021A 	0x0		
// D010211 	0x20	
// D010217 	0x4480	
// D01021A 	0x0		
// D010206 	0x4		
// 2B04 	0x4		
// 1391 	0x10	
// 		dash uses set:
// D010108 	4		
// D010204 	0x4		
// 2AFA 	0x48	
// D010102	0x24	

typedef enum {
	XNCALLER_INVALID = 0x0,
	XNCALLER_TITLE = 0x1,
	XNCALLER_SYSAPP = 0x2,
	XNCALLER_XBDM = 0x3,
	XNCALLER_TEST = 0x4,
	NUM_XNCALLER_TYPES = 0x4,
} XNCALLER_TYPE;

typedef enum  {
	UPNP_VALUE_TYPE_NONE = 0x0,
	UPNP_VALUE_TYPE_I4 = 0x1,
	UPNP_VALUE_TYPE_STRING = 0x2,
} UPNP_VALUE_TYPE;


#pragma pack(push, 1)
typedef struct _XNetConfigParams
{ 
	BYTE abHash[0x14]; // 0x0 sz:0x14
	BYTE abConfounder[0x8]; // 0x14 sz:0x8
	WORD wszName[0x18]; // 0x1C sz:0x30
	WORD wFlags; // 0x4C sz:0x2
	BYTE abEnet[0x6]; // 0x4E sz:0x6
	DWORD ina; // 0x54 sz:0x4
	DWORD inaMask; // 0x58 sz:0x4
	DWORD inaGateway; // 0x5C sz:0x4
	DWORD ainaDnsServers[0x2]; // 0x60 sz:0x8
	char achDhcpHostName[0x28]; // 0x68 sz:0x28
	char achPppoeUserName[0x40]; // 0x90 sz:0x40
	char achPppoePassword[0x40]; // 0xD0 sz:0x40
	char achPppoeServer[0x28]; // 0x110 sz:0x28
	char achPppoeService[0x28]; // 0x138 sz:0x28
	LARGE_INTEGER liTimeOfLease; // 0x160 sz:0x8
	DWORD dwSecsInLease; // 0x168 sz:0x4
	DWORD inaLease; // 0x16C sz:0x4
	DWORD inaMaskLease; // 0x170 sz:0x4
	DWORD inaServerLease; // 0x174 sz:0x4
	DWORD ainaGatewaysLease[0x4]; // 0x178 sz:0x10
	DWORD ainaDnsServersLease[0x4]; // 0x188 sz:0x10
	BYTE abEnetUPnP[0x6]; // 0x198 sz:0x6
	WORD wPortUPnP; // 0x19E sz:0x2
	BYTE abEnetPppoeServer[0x6]; // 0x1A0 sz:0x6
	WORD wPppoeSessionId; // 0x1A6 sz:0x2
	BYTE abReserved[0x44]; // 0x1A8 sz:0x44
} XNetConfigParams, *PXNetConfigParams; // size 492
C_ASSERT(sizeof(XNetConfigParams) == 0x1EC);

typedef struct _XNetConfigPppoe { 
	char achServer[0x28]; // 0x0 sz:0x28
	DWORD cpchService; // 0x28 sz:0x4
	char * apchService[8]; // 0x2C sz:0x20
	char achBuffer[0x140]; // 0x4C sz:0x140
} XNetConfigPppoe, *PXNetConfigPppoe; // size 396
C_ASSERT(sizeof(XNetConfigPppoe) == 0x18C);

typedef struct _XNetConfigStatus { 
	DWORD dwFlags; // 0x0 sz:0x4
	struct in_addr ina; // 0x4 sz:0x4
	struct in_addr inaMask; // 0x8 sz:0x4
	struct in_addr ainaGateways[4]; // 0xC sz:0x10
	struct in_addr ainaDnsServers[4]; // 0x1C sz:0x10
	DWORD cConfigPppoe; // 0x2C sz:0x4
	XNetConfigPppoe * pConfigPppoe; // 0x30 sz:0x4
	int fConfigUPnP; // 0x34 sz:0x4
	WORD wPortUPnP; // 0x38 sz:0x2
} XNetConfigStatus, *PXNetConfigStatus; // size 58
C_ASSERT(sizeof(XNetConfigStatus) == 0x3A);
#pragma pack(pop)


// these are found in the status bytes on a successful (return 0) XNetGetOpt(XNET_OPTID_ARP_ENTRY)
#define XNPARP_LOOKUP_ENTRY_SUCCESS			1
#define XNPARP_LOOKUP_ENTRY_NOT_FOUND 		2

#pragma pack(push, 1)
typedef struct _XNPARPENTRY {
	DWORD status; // 0x0 sz 4
	IN_ADDR inIp; // 0x4 sz 4
	BYTE macAddr[6]; // 0x8 sz 6
	BYTE pad[2]; // 0xC sz 2
} XNPARPENTRY, *PXNPARPENTRY; // 0x10
#pragma pack(pop)
C_ASSERT(sizeof(XNPARPENTRY) == 0x10);

typedef struct _XNPROUTEENTRY {
	DWORD dwFlags; // 0x0 sz 4
	DWORD dwType; // 0x4 sz 4 - when setting use -1 for broadcast
	IN_ADDR iaDestAddr; // 0x8 sz 4
	IN_ADDR iaGateway; // 0xC sz 4
	IN_ADDR iaInterface; // 0x10 sz 4
	IN_ADDR iaUnk; // 0x14 sz 4
} XNPROUTEENTRY, *PXNPROUTEENTRY; // 0x18
C_ASSERT(sizeof(XNPROUTEENTRY) == 0x18);

typedef struct _XnSecAssocInfo {
   IN_ADDR inaddrSec; // 0x00-0x04
   XNCALLER_TYPE CallerType; // 0x04-0x08
   DWORD dwInfoFlags; // 0x08-0x0C
   DWORD dwReserved1; // 0x0C-0x10
   XNKID xnkid; // 0x10-0x18
   XNADDR xnaddr; // 0x18-0x3C
   DWORD dwServiceId; // 0x3C-0x40
   IN_ADDR inaddrRemote; // 0x40-0x44
   WORD wRemotePort; // 0x44-0x46
   BYTE bState; // 0x46-0x47
   BYTE bReserved2; // 0x47-0x48
   IN_ADDR inaddrNat; // 0x48-0x4C
   WORD wNatPort; // 0x4C-0x4E
   BYTE abReserved3[0x2A]; // 0x4E-0x78
} XnSecAssocInfo, *PXnSecAssocInfo; // 0x78
C_ASSERT(sizeof(XnSecAssocInfo) == 0x78);

typedef struct XNetCapBuffer { 
	DWORD cbCap; // 0x0 sz:0x4
	PBYTE pbCapHead; // 0x4 sz:0x4
	PBYTE pbCapTail; // 0x8 sz:0x4
	DWORD cbCapFree; // 0xC sz:0x4
} XNetCapBuffer, *PXNetCapBuffer; // size 16
C_ASSERT(sizeof(XNetCapBuffer) == 0x10);

typedef union _UPNP_VALUE {
	int   iValue; // 0x00-0x04
	CHAR* pszValue; // 0x00-0x04
} UPNP_VALUE, *PUPNP_VALUE;  // 0x04

typedef struct _UPNP_ACTION_OUTPUT_PARAMETER {
	CHAR* pszName; // 0x00-0x04
	enum  UPNP_VALUE_TYPE ValueType; // 0x04-0x08
	DWORD dwValueSize; // 0x08-0x0C
	UPNP_VALUE Value; // 0x0C-0x10
} UPNP_ACTION_OUTPUT_PARAMETER, *PUPNP_ACTION_OUTPUT_PARAMETER; // 0x10

typedef struct _UPNP_DEVICE {
	CHAR		szDeviceUuid[0x80];
	struct sockaddr_in saddrinHost;
	CHAR		szRelativePath[0x100];
	DWORD		dwLastUpdateTime;
} UPNP_DEVICE, *PUPNP_DEVICE;

typedef struct _UPNP_SERVICE_DESCRIPTION {
   CHAR szType[0x80];
   CHAR szId[0x81];
   WORD wDescriptionPort;
   CHAR szDescriptionURL[0x100];
   WORD wControlPort;
   CHAR szControlURL[0x100];
   WORD wEventPort;
   CHAR szEventURL[0x100];
   struct _UPNP_DEVICE_DESCRIPTION *  pOwningDevice;
   struct _UPNP_SERVICE_DESCRIPTION * pNextService;
} UPNP_SERVICE_DESCRIPTION, *PUPNP_SERVICE_DESCRIPTION;

typedef struct _UPNP_DEVICE_DESCRIPTION {
   CHAR szUuid[0x80];
   CHAR szType[0x80];
   CHAR szFriendlyName[0x41];
   CHAR szManufacturer[0x41];
   CHAR szManufacturerURL[0x100];
   CHAR szModelName[0x21];
   CHAR szModelDescription[0x81];
   CHAR szModelNumber[0x21];
   CHAR szModelURL[0x100];
   CHAR szSerialNumber[0x41];
   CHAR szUPC[0xD];
   struct _UPNP_DEVICE_DESCRIPTION * pParent;
   struct _UPNP_DEVICE_DESCRIPTION * pNextSibling;
   struct _UPNP_DEVICE_DESCRIPTION * pFirstChild;
   struct _UPNP_SERVICE_DESCRIPTION * pFirstService;
} UPNP_DEVICE_DESCRIPTION, *PUPNP_DEVICE_DESCRIPTION;

typedef int (*LP_INTERCEPT_XMIT_FUNC)(PVOID pvCallbackUserData, const BYTE * pbXmitData, DWORD dwCbData); // return 0 on success
typedef int (*LP_INTERCEPT_RECV_FUNC)(PVOID pvCallbackUserData, const BYTE * pbRecvData, DWORD dwCbData); // return 0 on success

#ifdef __cplusplus
extern "C" {
#endif
	// **WARNING** this is never called directly UNLESS dash version is < 2610
	// NTSYSAPI
	// EXPORTNUM(1)
	// int
	// NTAPI
	// NetDll_WSAStartup(
	// 	IN		XNCALLER_TYPE xnc
	// 	IN		WORD wVersionRequested,
	// 	OUT		LPWSADATA lpWSAData
	// );

	NTSYSAPI
	EXPORTNUM(2)
	int
	NTAPI
	NetDll_WSACleanup(
		IN		XNCALLER_TYPE xnc
	);

	NTSYSAPI
	EXPORTNUM(3)
	SOCKET
	NTAPI
	NetDll_socket(
		IN		XNCALLER_TYPE xnc,
		IN		int af,
		IN		int type,
		IN		int protocol
	);

	NTSYSAPI
	EXPORTNUM(4)
	int
	NTAPI
	NetDll_closesocket(
		IN		XNCALLER_TYPE xnc,
		IN		SOCKET s
	);
	
	NTSYSAPI
	EXPORTNUM(5)
	int
	NTAPI
	NetDll_shutdown(
		IN		XNCALLER_TYPE xnc,
		IN		SOCKET s,
		IN		int how
	);
	
	NTSYSAPI
	EXPORTNUM(6)
	int
	NTAPI
	NetDll_ioctlsocket(
		IN		XNCALLER_TYPE xnc,
		IN		SOCKET s,
		IN		long cmd,
		IN		u_long FAR * argp
	);

	NTSYSAPI
	EXPORTNUM(7)
	int
	NTAPI
	NetDll_setsockopt(
		IN		XNCALLER_TYPE xnc,
		IN		SOCKET s,
		IN		int level,
		IN		int optname,
		IN		const char FAR * optval,
		IN		int optlen
	);

	NTSYSAPI
	EXPORTNUM(8)
	int
	NTAPI
	NetDll_getsockopt(
		IN		XNCALLER_TYPE xnc,
		IN		SOCKET s,
		IN		int level,
		IN		int optname,
		IN		const char FAR * optval,
		IN		int* optlen
	);

	NTSYSAPI
	EXPORTNUM(9)
	int
	NTAPI
	NetDll_getsockname(
		IN		XNCALLER_TYPE xnc,
		IN		SOCKET s,
		IN OUT	struct sockaddr FAR * name,
		IN		int FAR * namelen
	);

	NTSYSAPI
	EXPORTNUM(10)
	int
	NTAPI
	NetDll_getpeername(
		IN		XNCALLER_TYPE xnc,
		IN		SOCKET s,
		IN OUT	struct sockaddr FAR * name,
		IN		int FAR * namelen
	);

	NTSYSAPI
	EXPORTNUM(11)
	int
	NTAPI
	NetDll_bind(
		IN		XNCALLER_TYPE xnc,
		IN		SOCKET s,
		IN		const struct sockaddr FAR * name,
		IN		int namelen
	);
	
	NTSYSAPI
	EXPORTNUM(12)
	int
	NTAPI
	NetDll_connect(
		IN		XNCALLER_TYPE xnc,
		IN		SOCKET s,
		IN		const struct sockaddr FAR * name,
		IN		int namelen
	);

	NTSYSAPI
	EXPORTNUM(13)
	int
	NTAPI
	NetDll_listen(
		IN		XNCALLER_TYPE xnc,
		IN		SOCKET s,
		IN		int backlog
	);

	NTSYSAPI
	EXPORTNUM(14)
	SOCKET
	NTAPI
	NetDll_accept(
		IN		XNCALLER_TYPE xnc,
		IN		SOCKET s,
		IN		struct sockaddr FAR * addr,
		IN		int FAR * addrlen
	);

	NTSYSAPI
	EXPORTNUM(15)
	int
	NTAPI
	NetDll_select(
		IN		XNCALLER_TYPE xnc,
		IN		int nfds,
		IN		fd_set FAR * readfds,
		IN		fd_set FAR * writefds,
		IN		fd_set FAR *exceptfds,
		IN		const struct timeval FAR * timeout
	);

	NTSYSAPI
	EXPORTNUM(16)
	BOOL
	NTAPI
	NetDll_WSAGetOverlappedResult(
		IN		XNCALLER_TYPE xnc,
		IN		SOCKET s,
		IN		LPOVERLAPPED lpOverlapped,
		OUT		LPDWORD lpcbTransfer,
		IN		BOOL fWait,
		OUT		LPDWORD lpdwFlags
	);

	NTSYSAPI
	EXPORTNUM(17)
	int
	NTAPI
	NetDll_WSACancelOverlappedIO(
		IN		XNCALLER_TYPE xnc,
		IN		SOCKET s
	);

	NTSYSAPI
	EXPORTNUM(18)
	int
	NTAPI
	NetDll_recv(
		IN		XNCALLER_TYPE xnc,
		IN		SOCKET s,
		IN OUT	const char FAR * buf,
		IN		int len,
		IN		int flags
	);

	NTSYSAPI
	EXPORTNUM(19)
	int
	NTAPI
	NetDll_WSARecv(
		IN		XNCALLER_TYPE xnc,
		IN		SOCKET s,
		IN		LPWSABUF lpBuffers,
		IN		DWORD dwBufferCount,
		OUT 	LPDWORD lpNumberOfBytesRecvd OPTIONAL,
		IN OUT 	LPDWORD lpFlags,
		IN		LPOVERLAPPED lpOverlapped OPTIONAL,
		IN		LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine OPTIONAL
	);

	NTSYSAPI
	EXPORTNUM(20)
	int
	NTAPI
	NetDll_recvfrom(
		IN		XNCALLER_TYPE xnc,
		IN		SOCKET s,
		IN		const char* buf,
		IN		int len,
		IN		int flags,
		IN OUT	void* from,
		IN		int fromlen
	);

	NTSYSAPI
	EXPORTNUM(21)
	int
	NTAPI
	NetDll_WSARecvFrom(
		IN		XNCALLER_TYPE xnc,
		IN		SOCKET s,
		IN		LPWSABUF lpBuffers,
		IN		DWORD dwBufferCount,
		OUT 	LPDWORD lpNumberOfBytesRecvd OPTIONAL,
		IN OUT 	LPDWORD lpFlags,
		OUT		struct sockaddr FAR * lpFrom  OPTIONAL,
		IN OUT	LPINT lpFromlen  OPTIONAL,
		IN		LPOVERLAPPED lpOverlapped OPTIONAL,
		IN		LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine OPTIONAL
	);

	NTSYSAPI
	EXPORTNUM(22)
	int
	NTAPI
	NetDll_send(
		IN		XNCALLER_TYPE xnc,
		IN		SOCKET s,
		IN		const char FAR * buf,
		IN		int len,
		IN		int flags
	);
	
	NTSYSAPI
	EXPORTNUM(23)
	int
	NTAPI
	NetDll_WSASend(
		IN		XNCALLER_TYPE xnc,
		IN		SOCKET s,
		IN		LPWSABUF lpBuffers,
		IN		DWORD dwBufferCount,
		OUT 	LPDWORD lpNumberOfBytesSent OPTIONAL,
		IN		DWORD dwFlags,
		IN		LPOVERLAPPED lpOverlapped OPTIONAL,
		IN		LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine OPTIONAL
	);

	NTSYSAPI
	EXPORTNUM(24)
	int
	NTAPI
	NetDll_sendto(
		IN		XNCALLER_TYPE xnc,
		IN		SOCKET s,
		IN		const VOID* buf,
		IN		int len,
		IN		int flags,
		IN		VOID* to,
		IN		int tolen
	);

	NTSYSAPI
	EXPORTNUM(25)
	int
	NTAPI
	NetDll_WSASendTo(
		IN		XNCALLER_TYPE xnc,
		IN		SOCKET s,
		IN		LPWSABUF lpBuffers,
		IN		DWORD dwBufferCount,
		OUT 	LPDWORD lpNumberOfBytesSent OPTIONAL,
		IN		DWORD dwFlags,
		IN		const struct sockaddr FAR * lpTo,
		IN		int iTolen,
		IN		LPOVERLAPPED lpOverlapped OPTIONAL,
		IN		LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine OPTIONAL
	);

	NTSYSAPI
	EXPORTNUM(26)
	DWORD
	NTAPI
	NetDll_inet_addr(
		IN		const char *cp
	);
	
	NTSYSAPI
	EXPORTNUM(27)
	int
	NTAPI
	NetDll_WSAGetLastError(
		VOID
	);

	NTSYSAPI
	EXPORTNUM(28)
	void
	NTAPI
	NetDll_WSASetLastError(
		IN		int iError
	);

	NTSYSAPI
	EXPORTNUM(29)
	WSAEVENT
	NTAPI
	NetDll_WSACreateEvent(
		void
	);

	NTSYSAPI
	EXPORTNUM(30)
	BOOL
	NTAPI
	NetDll_WSACloseEvent(
		IN		WSAEVENT hEvent
	);

	NTSYSAPI
	EXPORTNUM(31)
	BOOL
	NTAPI
	NetDll_WSASetEvent(
		IN		WSAEVENT hEvent
	);
	
	NTSYSAPI
	EXPORTNUM(32)
	BOOL
	NTAPI
	NetDll_WSAResetEvent(
		IN		WSAEVENT hEvent
	);

	NTSYSAPI
	EXPORTNUM(33)
	DWORD
	NTAPI
	NetDll_WSAWaitForMultipleEvents(
		IN		DWORD cEvents,
		IN		const WSAEVENT FAR * lphEvents,
		IN		BOOL fWaitAll,
		IN		DWORD dwTimeout,
		IN		BOOL fAlertable
	);

	NTSYSAPI
	EXPORTNUM(34)
	int
	NTAPI
	NetDll___WSAFDIsSet(
		IN		SOCKET s,
		OUT		fd_set* fds
	);

	NTSYSAPI
	EXPORTNUM(35)
	int
	NTAPI
	NetDll_WSAEventSelect(
		IN		XNCALLER_TYPE xnc,
		IN		SOCKET s,
		IN		WSAEVENT hEventObject,
		IN		long lNetworkEvents
	);

	NTSYSAPI
	EXPORTNUM(36)
	int
	NTAPI
	NetDll_WSAStartupEx(
		IN		XNCALLER_TYPE xnc,
		IN		WORD wVersionRequested,
		IN		LPWSADATA wsad,
		IN		DWORD versionReq
	);

	NTSYSAPI
	EXPORTNUM(51)
	int
	NTAPI
	NetDll_XNetStartup(
		IN		XNCALLER_TYPE xnc,
		IN		XNetStartupParams* xnsp
	);

	NTSYSAPI
	EXPORTNUM(52)
	int
	NTAPI
	NetDll_XNetCleanup(
		IN		XNCALLER_TYPE xnc
	);

	NTSYSAPI
	EXPORTNUM(53)
	int
	NTAPI
	NetDll_XNetRandom(
		IN		XNCALLER_TYPE xnc,
		OUT		BYTE * pb,
		IN		DWORD cb
	);


	NTSYSAPI
	EXPORTNUM(54)
	int
	NTAPI
	NetDll_XNetCreateKey(
		IN		XNCALLER_TYPE xnc,
		OUT		XNKID *pxnkid,
		OUT		XNKEY *pxnkey
	);

	NTSYSAPI
	EXPORTNUM(55)
	int
	NTAPI
	NetDll_XNetRegisterKey(
		IN		XNCALLER_TYPE xnc,
		IN		const XNKID * pxnkid,
		IN		const XNKEY * pxnkey
	);

	NTSYSAPI
	EXPORTNUM(56)
	int
	NTAPI
	NetDll_XNetUnregisterKey(
		IN		XNCALLER_TYPE xnc,
		IN		const XNKID * pxnkid
	);

	NTSYSAPI
	EXPORTNUM(57)
	int
	NTAPI
	NetDll_XNetXnAddrToInAddr(
		IN		XNCALLER_TYPE xnc,
		IN		XNADDR * pxna,
		IN		XNKID * pxnkid,
		OUT		PIN_ADDR pina
	);

	NTSYSAPI
	EXPORTNUM(58)
	int
	NTAPI
	NetDll_XNetServerToInAddr(
		IN		XNCALLER_TYPE xnc,
		IN		const IN_ADDR ina,
		IN		DWORD dwServiceId,
		OUT		PIN_ADDR pina
	);

	NTSYSAPI
	EXPORTNUM(59)
	int
	NTAPI
	NetDll_XNetTsAddrToInAddr(
		IN		XNCALLER_TYPE xnc,
		IN		const TSADDR * ptsa,
		IN		DWORD dwServiceId,
		IN		const XNKID * pxnkid,
		OUT		PIN_ADDR pina
	);

	NTSYSAPI
	EXPORTNUM(60)
	int
	NTAPI
	NetDll_XNetInAddrToXnAddr(
		IN		XNCALLER_TYPE xnc,
		IN		IN_ADDR ina,
		OUT		XNADDR * pxna,
		IN		XNKID * pxnkid
	);

	NTSYSAPI
	EXPORTNUM(61)
	int
	NTAPI
	NetDll_XNetInAddrToServer(
		IN		XNCALLER_TYPE xnc,
		IN		const IN_ADDR ina,
		OUT		PIN_ADDR pina
	);

	NTSYSAPI
	EXPORTNUM(62)
	int
	NTAPI
	NetDll_XNetInAddrToString(
		IN		XNCALLER_TYPE xnc,
		IN		const IN_ADDR ina,
		OUT		char * pchBuf,
		IN		int cchBuf
	);

	NTSYSAPI
	EXPORTNUM(63)
	int
	NTAPI
	NetDll_XNetUnregisterInAddr(
		IN		XNCALLER_TYPE xnc,
		IN		const IN_ADDR ina
	);

	NTSYSAPI
	EXPORTNUM(64)
	int
	NTAPI
	NetDll_XNetXnAddrToMachineId(
		IN		XNCALLER_TYPE xnc,
		IN		const XNADDR * pxnaddr,
		OUT		ULONGLONG * pqwMachineId
	);

	NTSYSAPI
	EXPORTNUM(65)
	int
	NTAPI
	NetDll_XNetConnect(
		IN		XNCALLER_TYPE xnc,
		IN		const IN_ADDR ina
	);

	NTSYSAPI
	EXPORTNUM(66)
	DWORD
	NTAPI
	NetDll_XNetGetConnectStatus(
		IN		XNCALLER_TYPE xnc,
		IN		const IN_ADDR ina
	);

	NTSYSAPI
	EXPORTNUM(67)
	int
	NTAPI
	NetDll_XNetDnsLookup(
		IN		XNCALLER_TYPE xnc,
		IN		LPCSTR pszHost,
		IN		WSAEVENT hEvent,
		IN		XNDNS ** ppXNDns
	);

	NTSYSAPI
	EXPORTNUM(68)
	int
	NTAPI
	NetDll_XNetDnsRelease(
		IN		XNCALLER_TYPE xnc,
		IN		XNDNS * pxndns
	);

	NTSYSAPI
	EXPORTNUM(69)
	int
	NTAPI
	NetDll_XNetQosListen(
		IN		XNCALLER_TYPE xnc,
		IN		const XNKID * pxnkid,
		IN		const BYTE * pb,
		IN		DWORD cb,
		IN		DWORD dwBitsPerSec,
		IN		DWORD dwFlags	
	);

	NTSYSAPI
	EXPORTNUM(70)
	int
	NTAPI
	NetDll_XNetQosLookup(
		IN		XNCALLER_TYPE xnc,
		IN		DWORD cxna,
		IN		const XNADDR * apxna[] OPTIONAL,
		IN		const XNKID * apxnkid[] OPTIONAL,
		IN		const XNKEY * apxnkey[] OPTIONAL,
		IN		UINT cina,
		IN		const IN_ADDR aina[] OPTIONAL,
		IN		const DWORD adwServiceId[] OPTIONAL,
		IN		DWORD dwBitsPerSec,
		IN		DWORD dwFlags,
		IN		WSAEVENT hEvent OPTIONAL,
		OUT		XNQOS ** ppxnqos
	);

	NTSYSAPI
	EXPORTNUM(71)
	int
	NTAPI
	NetDll_XNetQosServiceLookup(
		IN		XNCALLER_TYPE xnc,
		IN		DWORD dwFlags,
		IN		WSAEVENT hEvent OPTIONAL,
		OUT		XNQOS ** ppxnqos
	);

	NTSYSAPI
	EXPORTNUM(72)
	int
	NTAPI
	NetDll_XNetQosRelease(
		IN		XNCALLER_TYPE xnc,
		IN		XNQOS * pxnqos
	);

	NTSYSAPI
	EXPORTNUM(73)
	DWORD
	NTAPI
	NetDll_XNetGetTitleXnAddr(
		IN		XNCALLER_TYPE xnc,
		OUT		XNADDR * pxna
	);

	NTSYSAPI
	EXPORTNUM(74)
	DWORD
	NTAPI
	NetDll_XNetGetDebugXnAddr(
		IN		XNCALLER_TYPE xnc,
		OUT		XNADDR * pxna
	);

	NTSYSAPI
	EXPORTNUM(75)
	DWORD
	NTAPI
	NetDll_XNetGetEthernetLinkStatus(
		IN		XNCALLER_TYPE xnc
	);

	NTSYSAPI
	EXPORTNUM(76)
	DWORD
	NTAPI
	NetDll_XNetGetBroadcastVersionStatus(
		IN		XNCALLER_TYPE xnc,
		IN		BOOL fReset
	);

	NTSYSAPI
	EXPORTNUM(77)
	int
	NTAPI
	NetDll_XNetQosGetListenStats(
		IN		XNCALLER_TYPE xnc,
		IN		const XNKID * pxnkid,
		IN OUT	XNQOSLISTENSTATS * pQosListenStats
	);

	NTSYSAPI
	EXPORTNUM(78)
	int
	NTAPI
	NetDll_XNetGetOpt(
		IN		XNCALLER_TYPE xnc,
		IN		DWORD dwOptId,
		OUT		BYTE * pbValue,
		IN OUT	DWORD * pdwValueSize
	);

	NTSYSAPI
	EXPORTNUM(79)
	int
	NTAPI
	NetDll_XNetSetOpt(
		IN		XNCALLER_TYPE xnc,
		IN		DWORD dwOptId,
		IN		BYTE * pbValue,
		IN		DWORD pdwValueSize
	);

	NTSYSAPI
	EXPORTNUM(80)
	int
	NTAPI
	NetDll_XNetStartupEx(
		IN		XNCALLER_TYPE xnc,
		IN		XNetStartupParams * xnsp,
		IN		DWORD versionReq
	);

	NTSYSAPI
	EXPORTNUM(83)
	int
	NTAPI
	NetDll_XNetGetSystemLinkPort(
		IN		XNCALLER_TYPE xnc,
		OUT		WORD * pwSystemLinkPort
	);

	NTSYSAPI
	EXPORTNUM(84)
	int
	NTAPI
	NetDll_XNetSetSystemLinkPort(
		IN		XNCALLER_TYPE xnc,
		IN		WORD wSystemLinkPort
	);

	NTSYSAPI
	EXPORTNUM(104)
	int
	NTAPI
	NetDll_XnpConfig(
		IN		XNCALLER_TYPE xnc,
		IN		PXNetConfigParams pnetconfigparm,
		IN		DWORD ovl
	);

	NTSYSAPI
	EXPORTNUM(105)
	int
	NTAPI
	NetDll_XnpGetConfigStatus(
		IN		XNCALLER_TYPE xnc,
		IN OUT	PXNetConfigStatus pxnConfigStatus
	);
	
	NTSYSAPI
	EXPORTNUM(108)
	int
	NTAPI
	NetDll_XnpCapture(
		IN		XNCALLER_TYPE xnc,
		IN		PXNetCapBuffer pXncb
	);

	NTSYSAPI
	EXPORTNUM(110)
	int
	NTAPI
	NetDll_XnpEthernetInterceptXmit(
		IN		XNCALLER_TYPE xnc,
		IN		PBYTE pb,
		IN		DWORD cb
	);

	NTSYSAPI
	EXPORTNUM(109)
	int
	NTAPI
	NetDll_XnpEthernetInterceptSetCallbacks(
		IN		XNCALLER_TYPE xnc,
		IN		LP_INTERCEPT_XMIT_FUNC pfnEnetInterceptXmitCallback,
		IN		LP_INTERCEPT_RECV_FUNC pfnEnetInterceptRecvCallback,
		IN		PVOID pvCallbackUserData,
		IN		DWORD dwFlags
	);

	NTSYSAPI
	EXPORTNUM(111)
	VOID
	NTAPI
	NetDll_XnpEthernetInterceptRecv(
		IN		XNCALLER_TYPE xnc,
		IN		PBYTE pb,
		IN		DWORD cb
	);

	NTSYSAPI
	EXPORTNUM(129)
	DWORD
	NTAPI
	NetDll_XnpGetSecAssocList(
		IN		XNCALLER_TYPE xnc,
		IN		PXnSecAssocInfo pSecAssocList,
		IN		PDWORD dwLength
	);

	NTSYSAPI
	EXPORTNUM(134)
	int
	NTAPI
	NetDll_XnpEthernetInterceptSetExtendedReceiveCallback(
		IN		XNCALLER_TYPE xnc,
		IN		LP_INTERCEPT_RECV_FUNC pfnEnetInterceptExtRecvCallback,
		IN		PVOID pvCallbackUserData,
		IN		DWORD dwFlags
	);
	
	NTSYSAPI
	EXPORTNUM(142)
	int
	NTAPI
	NetDll_XnpEthernetInterceptXmitAsIp(
		IN		XNCALLER_TYPE xnc,
		IN		const BYTE * pbData,
		IN		DWORD dwCb,
		IN		DWORD dwFlags
	);
	// *** THESE NEED TO BE CHECKED!!! ***
	NTSYSAPI
	EXPORTNUM(106)
	VOID
	NTAPI
	NetDll_XnpLoadMachineAccount(
		IN		DWORD dwUnk,
		IN		char* abUnk
	);

	NTSYSAPI
	EXPORTNUM(251)
	DWORD 
	NTAPI
	NetDll_UpnpStartup(
		IN	XNCALLER_TYPE CallerType
	);

	
	NTSYSAPI
	EXPORTNUM(252)
	DWORD 
	NTAPI
	NetDll_UpnpCleanup(
		IN	XNCALLER_TYPE CallerType
	);

	NTSYSAPI
	EXPORTNUM(253)
	DWORD 
	NTAPI
	NetDll_UpnpSearchCreate(
		IN		XNCALLER_TYPE CallerType, 
		IN		CHAR* szSearchTarget, 
		IN		DWORD dwMaxCachedDevices, 
		IN		DWORD dwSendTryCount, 
		IN		DWORD dwSendInterval, 
		IN		HANDLE hWorkEvent, 
		IN		DWORD dwFlags, 
		OUT		HANDLE* phUpnpSearch
	);

	NTSYSAPI
	EXPORTNUM(254)
	DWORD 
	NTAPI
	NetDll_UpnpSearchGetDevices(
		IN		XNCALLER_TYPE CallerType, 
		IN		HANDLE hUpnpSearch, 
		OUT		struct _UPNP_DEVICE* paUpnpDevices, 
		OUT		DWORD* pdwNumUpnpDevices
	);

	NTSYSAPI
	EXPORTNUM(255)
	DWORD 
	NTAPI
	NetDll_UpnpDescribeCreate(
		IN		XNCALLER_TYPE CallerType, 
		IN OUT  struct _UPNP_DEVICE* pUpnpDevice, 
		IN		DWORD dwMaxNUmDevices, 
		IN		DWORD dwMaxNumServices, 
		IN		HANDLE hWorkEvent, 
		OUT		HANDLE* phUpnpDescribe
	);

	NTSYSAPI
	EXPORTNUM(256)
	DWORD 
	NTAPI
	NetDll_UpnpDescribeGetResults(
		IN		XNCALLER_TYPE CallerType, 
		IN		HANDLE hUpnpDescibe, 
		IN OUT	struct _UPNP_DEVICE_DESCRIPTION** ppaUpnpDeviceDescriptions, 
		IN OUT	DWORD* pdwNumUpnpDeviceDescriptions,
		IN OUT	struct _UPNP_SERVICE_DESCRIPTION** ppaUpnpServiceDescriptions, 
		IN OUT	DWORD* pdwNumUpnpServicesDescriptions
	);

	NTSYSAPI
	EXPORTNUM(258)
	DWORD 
	NTAPI
	NetDll_UpnpActionCreate(
		IN		XNCALLER_TYPE CallerType, 
		IN		struct sockaddr_in* psaddrinHost, 
		IN		CHAR* szControlURL, 
		IN		CHAR* szServiceType, 
		IN		CHAR* szAction, 
		IN		CHAR* pcInputParameters, 
		IN		DWORD dwInputParametersLength,
		IN OUT	struct _UPNP_ACTION_OUTPUT_PARAMETER* aOutputParameters, 
		IN OUT	DWORD dwNumOutputParameters, 
		IN OUT	BYTE* pbyWorkBuffer, 
		IN OUT	DWORD dwWOrkBufferSize, 
		IN		HANDLE hWorkEvent, 
		IN OUT	HANDLE* phUpnpAction
	);

	NTSYSAPI
	EXPORTNUM(259)
	DWORD 
	NTAPI
	NetDll_UpnpActionGetResults(
		IN		XNCALLER_TYPE CallerType, 
		IN		HANDLE hUpnpAction, 
		OUT		struct _UPNP_ACTION_OUTPUT_PARAMETER** ppaOutputParameters, 
		OUT		DWORD* pdwNumOutputParameters
	);

	NTSYSAPI
	EXPORTNUM(263)
	DWORD 
	NTAPI
	NetDll_UpnpDoWork(
		IN	XNCALLER_TYPE CallerType, 
		IN	HANDLE hHandle, 
		IN	DWORD dwNumMs
	);

	NTSYSAPI
	EXPORTNUM(264)
	DWORD 
	NTAPI
	NetDll_UpnpCloseHandle(
		IN	XNCALLER_TYPE CallerType, 
		IN	HANDLE hHandle
	);

	NTSYSAPI
	EXPORTNUM(308)
	VOID
	NTAPI
	XNetLogonSetConsoleCertificate(
		IN		const char* szCertificate,
		IN		DWORD dwcchCertificate
	);

	NTSYSAPI
	EXPORTNUM(314)
	VOID
	NTAPI
	XNetLogonSetTitleID(
		IN		DWORD dwTitleId
	);


#ifdef __cplusplus
}
#endif

#endif // __XAMNET_DEFINES_H

```

`XenonDumper/libs/xkelib/xam/xamTask.h`:

```h
#ifndef __XAMTASK_H
#define __XAMTASK_H

typedef HRESULT (WINAPI *PXAMTASKPROC)(IN PVOID pvParam);

typedef PVOID                           HXAMTASK, *PHXAMTASK;
typedef PVOID                           HXAMTASKQUEUE, *PHXAMTASKQUEUE;
typedef PVOID                           HXAMTASKOBJ, *PHXAMTASKOBJ; // Generic handle, either XAMTASK or XAMTASKQUEUE

// Type of task
#define XAMPROPERTY_TYPE_WAIT           0x00000001      // waits on a kernel handle and calls taskproc when signaled
#define XAMPROPERTY_TYPE_DEDICATED      0x00000002      // dedicated thread, will do work and exit
#define XAMPROPERTY_TYPE_POOLED         0x00000004      // reuse some kind of thread pool
#define XAMPROPERTY_TYPE_PERIODIC       0x00000008      // reuse some kind of thread pool, run at regular intervals
#define XAMPROPERTY_TYPE_UI             0x00000010
#define _XAMPROPERTY_TYPE_MASK_         0x0000001F

// When this task wakes up and does processing
#define XAMPROPERTY_WAKEUP_IO           0x00000100      // burst of CPU usage but mostly waiting on I/O
#define XAMPROPERTY_WAKEUP_NETWORK      0x00000200      // burst of CPU usage but mostly waiting on N/W
#define XAMPROPERTY_WAKEUP_OFTENWAIT    0x00000400      // calling WaitFor*Object* often
#define _XAMPROPERTY_WAKEUP_MASK_       0x00000700

// Task CPU usage
#define XAMPROPERTY_CPUUSAGE_LO         0x00001000      // e.g.: waiting and processing notifications
#define XAMPROPERTY_CPUUSAGE_HI         0x00002000      // e.g.: CODEC, encrypting, animations?
#define _XAMPROPERTY_CPUUSAGE_MASK_     0x00003000

// Duration
#define XAMPROPERTY_DURATION_VERYSHORT  0x00010000
#define XAMPROPERTY_DURATION_SHORT      0x00020000
#define XAMPROPERTY_DURATION_LONG       0x00040000
//                                      0x00080000      // Taken below
#define _XAMPROPERTY_DURATION_MASK_     0x00070000

// Priority
#define XAMPROPERTY_PRI_LO              0x00100000
#define XAMPROPERTY_PRI_NORMAL          0x00200000
#define XAMPROPERTY_PRI_HI              0x00400000
#define XAMPROPERTY_PRI_BACKGROUND      0x00800000
#define XAMPROPERTY_PRI_FOREGROUND      0x00080000
#define _XAMPROPERTY_PRI_LOHIMASK_      0x00700000
#define _XAMPROPERTY_PRI_XGROUNDMASK_   0x00880000
#define _XAMPROPERTY_PRI_MASK_          0x00F80000

// Misc
#define XAMPROPERTY_MISC_FIREONCE       0x01000000
#define XAMPROPERTY_MISC_ONTITLEBEHALF  0x02000000
#define XAMPROPERTY_MISC_ONSYSTEMBEHALF 0x04000000
#define XAMPROPERTY_MISC_WAITONHANDLE   0x08000000      // By default, we expect a waitable kernel object (e.g. KEVENT)
#define XAMPROPERTY_MISC_SERIALQUEUE    0x10000000      // hxamtaskqueue needs to be set
#define XAMPROPERTY_MISC_FORCE_GROUND   0x20000000      // forces _XAMPROPERTY_PRI_XGROUNDMASK_ to be followed.  Do not use this except in extreme cases!

#define _XAMPROPERTY_MISC_BEHALFMASK_   0x06000000
#define _XAMPROPERTY_MISC_MASK_         0x1F000000

#define XAMTASKMODIFY_NONE              0x00000000
#define XAMTASKMODIFY_TASKPROC          0x00000001
#define XAMTASKMODIFY_PVPARAM           0x00000002
#define XAMTASKMODIFY_ATTRIBUTES        0x00000004

typedef struct _XAMTASKPROPERTIES { 
	DWORD MiscAffinity : 1; // 0x0 bfo:0x31
	DWORD MiscSysBackground : 1; // 0x0 bfo:0x30
	DWORD MiscForceGround : 1; // 0x0 bfo:0x29
	DWORD MiscSerialQueue : 1; // 0x0 bfo:0x28
	DWORD MiscWaitOnHandle : 1; // 0x0 bfo:0x27
	DWORD MiscOnSystemBehalf : 1; // 0x0 bfo:0x26
	DWORD MiscOnTitleBehalf : 1; // 0x0 bfo:0x25
	DWORD MiscFireOnce : 1; // 0x0 bfo:0x24
	DWORD PriorityBackground : 1; // 0x0 bfo:0x23
	DWORD PriorityHigh : 1; // 0x0 bfo:0x22
	DWORD PriorityNormal : 1; // 0x0 bfo:0x21
	DWORD PriorityLow : 1; // 0x0 bfo:0x20
	DWORD PriorityForeground : 1; // 0x0 bfo:0x19
	DWORD Reserved1 : 2; // 0x0 bfo:0x17
	DWORD DurationVeryShort : 1; // 0x0 bfo:0x16
	DWORD MiscCancelSubTasks : 1; // 0x0 bfo:0x15
	DWORD MiscInprocSubTask : 1; // 0x0 bfo:0x14
	DWORD Reserved0 : 9; // 0x0 bfo:0x5
	DWORD TypeUI : 1; // 0x0 bfo:0x4
	DWORD TypePeriodic : 1; // 0x0 bfo:0x3
	DWORD TypePooled : 1; // 0x0 bfo:0x2
	DWORD TypeDedicated : 1; // 0x0 bfo:0x1
	DWORD TypeWait : 1; // 0x0 bfo:0x0
} XAMTASKPROPERTIES, *PXAMTASKPROPERTIES; // size 4
C_ASSERT(sizeof(XAMTASKPROPERTIES) == 0x4);

typedef struct _XAMTASKATTRIBUTES
{
	DWORD                               dwProperties;
	union
	{
		DWORD                           dwPeriod;
		PVOID                           pvWaitable;
		HANDLE                          hWaitable;
		HXAMTASKQUEUE                   hxamtaskqueue;
	}typ;
} XAMTASKATTRIBUTES, *PXAMTASKATTRIBUTES;

#endif // __XAMTASK_H

```

`XenonDumper/libs/xkelib/xam/xamXContent.h`:

```h
#ifndef __XAMEXT_XCONTENT_H
#define __XAMEXT_XCONTENT_H

#define XCONTENT_FILE_SYSTEM_ALIGNMENT              (4 * 1024)
#define XCONTENT_ROUND_UP_TO_ALIGNMENT(size)        (((size) + (XCONTENT_FILE_SYSTEM_ALIGNMENT - 1)) & (~(XCONTENT_FILE_SYSTEM_ALIGNMENT - 1)))
#define XCONTENT_ALIGNMENT_PADDING_NEEDED(size)     (XCONTENT_ROUND_UP_TO_ALIGNMENT(size) - (size))

#define XCONTENT_UNRESTRICTED_LICENSEE          ((QWORD) 0xFFFFFFFFFFFFFFFFULL)
#define XCONTENT_LICENSE_FLAG_REQUIRE_ONLINE    0x00000001

// some flags for mounting CON/LIVE/PIRS using mountCon/XamContentOpenFile
#define XCONTENT_ANY_USER								0xFF
#define XCONTENT_PKGFLAG_KEEP_OPEN_ON_TITLE_TERMINATE 	0x00000001
#define XCONTENT_PKGFLAG_DONT_UPDATE_DIGESTS_ON_CLOSE 	0x00000002
#define XCONTENT_FLAG_ATTRIBUTE_DEVICE					FILE_ATTRIBUTE_DEVICE
#define XCONTENT_OPENPKG_DONT_VERIFY_SIGNATURE 			0x00010000
#define XCONTENT_OPENPKG_COPY_EXISTING_HANDLE 			0x00020000
#define XCONTENT_FLAG_EXECUTE 							0x04000000

// some combined flags for often used operations
#define XCONTENT_MOUNT_FOR_READ_ONLY					(XCONTENT_FLAG_ATTRIBUTE_DEVICE|XCONTENT_PKGFLAG_DONT_UPDATE_DIGESTS_ON_CLOSE)
#define XCONTENT_MOUNT_FOR_EXEC							(XCONTENT_FLAG_EXECUTE|XCONTENT_FLAG_ATTRIBUTE_DEVICE| \
														XCONTENT_PKGFLAG_DONT_UPDATE_DIGESTS_ON_CLOSE| \
														XCONTENT_PKGFLAG_KEEP_OPEN_ON_TITLE_TERMINATE)

#pragma warning(push)
#pragma warning(disable:4005) // Get rid of the redefinition warning
#define XCONTENTTYPE_SAVEDGAME					0x00000001
#define XCONTENTTYPE_MARKETPLACE				0x00000002
#define XCONTENTTYPE_PUBLISHER					0x00000003
#define XCONTENTTYPE_IPTV_DVR					0x00001000
#define XCONTENTTYPE_INSTALLED_XBOX360TITLE		0x00004000
#define XCONTENTTYPE_XBOXTITLE					0x00005000
#define XCONTENTTYPE_SOCIALTITLE				0x00006000
#define XCONTENTTYPE_XBOX360TITLE				0x00007000
#define XCONTENTTYPE_SU_STORAGEPACK				0x00008000
#define XCONTENTTYPE_AVATAR_ASSET				0x00009000
#define XCONTENTTYPE_PROFILE					0x00010000
#define XCONTENTTYPE_ADDON						0x00020000
#define XCONTENTTYPE_THEMATICSKIN				0x00030000
#define XCONTENTTYPE_CACHE						0x00040000
#define XCONTENTTYPE_STORAGEDOWNLOAD			0x00050000
#define XCONTENTTYPE_XBOXSAVEDGAME				0x00060000
#define XCONTENTTYPE_XBOXDOWNLOAD				0x00070000
#define XCONTENTTYPE_GAMEDEMO					0x00080000
#define XCONTENTTYPE_VIDEO						0x00090000
#define XCONTENTTYPE_GAMETITLE					0x000A0000
#define XCONTENTTYPE_INSTALLER					0x000B0000
#define XCONTENTTYPE_GAMETRAILER				0x000C0000
#define XCONTENTTYPE_ARCADE						0x000D0000
#define XCONTENTTYPE_XNA						0x000E0000
#define XCONTENTTYPE_LICENSESTORE				0x000F0000
#define XCONTENTTYPE_MOVIE						0x00100000
#define XCONTENTTYPE_TV							0x00200000
#define XCONTENTTYPE_MUSICVIDEO					0x00300000
#define XCONTENTTYPE_PROMOTIONAL				0x00400000
#define XCONTENTTYPE_PODCASTVIDEO				0x00500000
#define XCONTENTTYPE_VIRALVIDEO					0x00600000

// languages for the DisplayName and Description fields
#define XCONTENT_METADATA_LANG_ENGLISH		0
#define XCONTENT_METADATA_LANG_JAPANESE		1
#define XCONTENT_METADATA_LANG_GERMAN		2
#define XCONTENT_METADATA_LANG_FRENCH		3
#define XCONTENT_METADATA_LANG_SPANISH		4
#define XCONTENT_METADATA_LANG_ITALIAN		5
#define XCONTENT_METADATA_LANG_KOREAN		6
#define XCONTENT_METADATA_LANG_CHINESE_TR	7 // chinese traditional
#define XCONTENT_METADATA_LANG_PORTUGESE	8
#define XCONTENT_METADATA_LANG_MAX			9

// languages for the DisplayNameEx and DescriptionEx fields
#define XCONTENT_METADATA_LANG_EX_RUSSIAN	0
#define XCONTENT_METADATA_LANG_EX_POLISH	1
#define XCONTENT_METADATA_LANG_EX_UNKNOWN	2
#define XCONTENT_METADATA_LANG_EX_MAX		3


#define XCONTENTDEVICETYPE_NONE         ((XCONTENTDEVICETYPE)0x0)
#define XCONTENTDEVICETYPE_HDD          ((XCONTENTDEVICETYPE)0x1) // in the sdk
#define XCONTENTDEVICETYPE_MU           ((XCONTENTDEVICETYPE)0x2) // in the sdk
#define XCONTENTDEVICETYPE_SYSTEMMU     ((XCONTENTDEVICETYPE)0x3)
#define XCONTENTDEVICETYPE_ODD          ((XCONTENTDEVICETYPE)0x4) // in the sdk
#define XCONTENTDEVICETYPE_XFERCABLE	((XCONTENTDEVICETYPE)0x8)
#define XCONTENTDEVICETYPE_USBMASS      ((XCONTENTDEVICETYPE)0x10)

// This flag is OR'd into a device type if the device is unformatted
#define XCONTENTDEVICEFLAG_UNFORMATTED  ((XCONTENTDEVICETYPE)0x80000000)
// This flag can be supplied to XContentCreateDeviceEnumerator to enumerate
// USB mass storage devices
#define XCONTENTDEVICEFLAG_USBMASS      (0x40000000)
#define XCONTENTDEVICE_ALL				(0xFFFFFFFF)

#define SU_PACKAGE	  					"su20076000_00000000"
#define MAGIC_XSYM 						((u32)0x7873796D) // 'xsym'
#define MAGIC_XONM 						((u32)0x786F6E6D) // 'xonm'
#define MAGIC_XMNP 						((u32)0x584D4E50) // 'XMNP'

#pragma warning(pop)

typedef enum { // LICENSEE_TYPE 
	LICENSEE_TYPE_WINDOWS_ID = 0x3, // not sure on this one (velocity)
	LICENSEE_TYPE_XUID = 0x9,
	LICENSEE_TYPE_USER_PRIVILEGES = 0xB000,
	LICENSEE_TYPE_HV_FLAGS = 0xC000,
	LICENSEE_TYPE_KEY_VAULT_PRIVILEGES = 0xD000,
	LICENSEE_TYPE_MEDIA_FLAGS = 0xE000,
	LICENSEE_TYPE_CONSOLE_ID = 0xF000,
};

typedef enum XCONTENT_VOLUME_TYPE {
	STFS_VOLUME = 0x0,
	SVOD_VOLUME = 0x1,
};

typedef enum _XCONTENT_SIGNATURE_TYPE {
	CONSOLE_SIGNED = 0x434F4E20,
	LIVE_SIGNED    = 0x4C495645,
	PIRS_SIGNED    = 0x50495253,
} XCONTENT_SIGNATURE_TYPE;

typedef enum _INSTALLER_METADATA_TYPE {
	INSTALLER_METADATA_UNDEFINED = 0,
	INSTALLER_METADATA_TYPE_PROGRESS_CACHE_PACKAGE_DOWNLOAD = 0x50245044,
	INSTALLER_METADATA_TYPE_PROGRESS_CACHE_SYSTEM_UPDATE = 0x50245355,
	INSTALLER_METADATA_TYPE_PROGRESS_CACHE_TITLE_CONTENT = 0x50245443,
	INSTALLER_METADATA_TYPE_PROGRESS_CACHE_TITLE_UPDATE = 0x50245455,
	INSTALLER_METADATA_TYPE_SYSTEM_UPDATE = 0x53555044,
	INSTALLER_METADATA_TYPE_TITLE_UPDATE = 0x54555044,
} INSTALLER_METADATA_TYPE;

typedef enum _XONLINECONTENT_RESUME_STATE {
	XONLINECONTENT_RESUME_STATE_FILE_HEADERS_NOT_READY = 0x46494C48,
	XONLINECONTENT_RESUME_STATE_LEGACY_NEW_FOLDER = 0x464F4C44,
	XONLINECONTENT_RESUME_STATE_LEGACY_NEW_FOLDER_ATTEMPT_2 = 0x464F4C32,
	XONLINECONTENT_RESUME_STATE_LEGACY_NEW_FOLDER_ATTEMPT_3 = 0x464F4C33,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER = 0x666F6C64,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_2 = 0x666F6C32,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_3 = 0x666F6C33,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_4 = 0x666F6C34,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_5 = 0x666F6C35,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_6 = 0x666F6C36,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_7 = 0x666F6C37,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_8 = 0x666F6C38,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_9 = 0x666F6C39,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_10 = 0x666F6C3A,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_11 = 0x666F6C3B,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_12 = 0x666F6C3C,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_13 = 0x666F6C3D,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_14 = 0x666F6C3E,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_15 = 0x666F6C3F,
	XONLINECONTENT_RESUME_STATE_NEW_FOLDER_RESUME_ATTEMPT_16 = 0x666F6C40,
}XONLINECONTENT_RESUME_STATE;

typedef enum _XMARKETPLACE_MEDIA_TYPE {
	XMARKETPLACE_MEDIA_TYPE_UNKNOWN = 0x0,
	XMARKETPLACE_MEDIA_TYPE_360_GAME = 0x1,
	XMARKETPLACE_MEDIA_TYPE_MOVIE = 0x2,
	XMARKETPLACE_MEDIA_TYPE_TVSHOW = 0x3,
	XMARKETPLACE_MEDIA_TYPE_MUSIC_VIDEO = 0x4,
	XMARKETPLACE_MEDIA_TYPE_ARCADE_DEMO = 0x5,
	XMARKETPLACE_MEDIA_TYPE_VIRAL_VIDEO = 0x7,
	XMARKETPLACE_MEDIA_TYPE_TV_EPISODE = 0x8,
	XMARKETPLACE_MEDIA_TYPE_TV_SEASON = 0x9,
	XMARKETPLACE_MEDIA_TYPE_TV_SERIES = 0xA,
	XMARKETPLACE_MEDIA_TYPE_IN_GAME_CONTENT = 0x12,
	XMARKETPLACE_MEDIA_TYPE_GAME_DEMO = 0x13,
	XMARKETPLACE_MEDIA_TYPE_360_THEME = 0x14,
	XMARKETPLACE_MEDIA_TYPE_XBOX1_GAME = 0x15,
	XMARKETPLACE_MEDIA_TYPE_GAMER_PICTURE = 0x16,
	XMARKETPLACE_MEDIA_TYPE_ARCADE_GAME = 0x17,
	XMARKETPLACE_MEDIA_TYPE_IN_GAME_CONSUMABLE = 0x18,
	XMARKETPLACE_MEDIA_TYPE_GAME_VIDEO = 0x1E,
	XMARKETPLACE_MEDIA_TYPE_GAME_TRAILER = 0x22,
	XMARKETPLACE_MEDIA_TYPE_MARKETPLACE_BUNDLE = 0x24,
	XMARKETPLACE_MEDIA_TYPE_COMMUNITY_GAME = 0x25,
	XMARKETPLACE_MEDIA_TYPE_PROMOTIONAL_VIDEO = 0x27,
	XMARKETPLACE_MEDIA_TYPE_MOVIE_TRAILER = 0x28,
	XMARKETPLACE_MEDIA_TYPE_MARKETPLACE_CONTENT = 0x2E,
	XMARKETPLACE_MEDIA_TYPE_AVATAR_ITEM = 0x2F,
	XMARKETPLACE_MEDIA_TYPE_APP = 0x3D,
}XMARKETPLACE_MEDIA_TYPE;

// *********** PACKING STARTS HERE **************//
#pragma pack(push, 1)
// *********** PACKING STARTS HERE **************//
typedef struct _SU_MAINIFEST_HEADER {
	DWORD dwMagic; // 0 'XMNP'
	BYTE baUnk1[0x20]; // 0x4
	BYTE baDataSha[0x14]; // 0x24
	BYTE baSignature[0x100]; // 0x38
}SU_MAINIFEST_HEADER, *PSU_MAINIFEST_HEADER; // sz 0x138
C_ASSERT(sizeof(SU_MAINIFEST_HEADER) == 0x138);

typedef struct _SU_CONTENT_HEADER {
	DWORD dwMagic; // 0x0 'xsym' or 'xonm'
	DWORD size; // 0x4
	DWORD unk1; // 0x8 must be 1?
	DWORD unk2; // 0xC
	DWORD dwSchemaVer; // 0x10
	DWORD dwFlashVer; // 0x14
	QWORD qwTimeStamp; // 0x18
	BYTE pad[8]; // 0x20
} SU_CONTENT_HEADER, *PSU_CONTENT_HEADER; // sz 0x28
C_ASSERT(sizeof(SU_CONTENT_HEADER) == 0x28);

typedef struct _SU_ITEM_ENTRY {
	DWORD dwSrcNameOff; // 0 source name
	DWORD dwPad1; // 0x4
	DWORD dwFileSize; // 0x8
	DWORD dwVersionOff; // 0xC pointer to version, used for folder on non-containers
	DWORD dwFlags; // 0x10 flags?
	DWORD dwPad2; // 0x14
	DWORD dwEntryType; // 0x18
	DWORD dwIntNameOff; // 0x1C internal name?
	DWORD dwDestNameOff; // 0x20 destination name
	BYTE contHash[0x14]; // 0x24
	BYTE dataHash[0x14]; // 0x38
	DWORD dwContentType; // 0x4C ie 0x00008000
	DWORD dwContentTitleId; // 0x50 ie 0xFFFE07DF
	DWORD dwPad3; // 0x54
	DWORD dwPad4; // 0x58
	DWORD dwXContItemListOff; // 0x5C num items in container, followed by entry offsets for each item
} SU_ITEM_ENTRY, *PSU_ITEM_ENTRY; // sz 0x60
C_ASSERT(sizeof(SU_ITEM_ENTRY) == 0x60);

typedef struct _SU_ITEM_LIST {
	DWORD dwSizeOfStruct;
	DWORD dwNumEntries;
	SU_ITEM_ENTRY ents[1];
} SU_ITEM_LIST, *PSU_ITEM_LIST; // sz 0x68
C_ASSERT(sizeof(SU_ITEM_LIST) == 0x68);

typedef struct _SU_MANIFEST_BODY {
	SU_CONTENT_HEADER cont;
	SU_ITEM_LIST items;
} SU_MANIFEST_BODY, *PSU_MANIFEST_BODY;

typedef struct _SU_MANIFEST {
	SU_MAINIFEST_HEADER header;
	SU_MANIFEST_BODY body;
} SU_MANIFEST, *PSU_MANIFEST;

typedef struct _XCONTENT_SIGNATURE { 
	BYTE Signature[0x100]; // 0x0 sz:0x100
	BYTE Reserved[0x128]; // 0x100 sz:0x128
} XCONTENT_SIGNATURE, *PXCONTENT_SIGNATURE; // size 552
C_ASSERT(sizeof(XCONTENT_SIGNATURE) == 0x228);

typedef struct _LICENSEE_BITS {
	WORD Type;
	WORD DataHi;
	DWORD DataLo;
	//UINT64 Type : 16; // 0x0 bfo:0x48
	//UINT64 Data : 48; // 0x0 bfo:0x0
} LICENSEE_BITS, *PLICENSEE_BITS; // size 8
C_ASSERT(sizeof(LICENSEE_BITS) == 0x8);

typedef union _LICENSEE { 
	LICENSEE_BITS Bits; // 0x0 sz:0x8
	QWORD AsULONGLONG; // 0x0 sz:0x8
} LICENSEE, *PLICENSEE; // size 8
C_ASSERT(sizeof(LICENSEE) == 0x8);

typedef struct _XCONTENT_LICENSE { 
	LICENSEE LicenseeId; // 0 16bits type, 48bits data
	DWORD LicenseBits; // 8
	DWORD LicenseFlags; // 12
} XCONTENT_LICENSE, *PXCONTENT_LICENSE; // 16
C_ASSERT(sizeof(XCONTENT_LICENSE) == 16);

#define XCONTENT_HEADER_LICENSES	0x10
typedef struct _XCONTENT_HEADER { 
	XCONTENT_SIGNATURE_TYPE SignatureType; // 0
	union { // 4 sz: 0x228
		XE_CONSOLE_SIGNATURE ConsoleSignature;
		XCONTENT_SIGNATURE   ContentSignature;
	} Signature;
	XCONTENT_LICENSE LicenseDescriptors[XCONTENT_HEADER_LICENSES]; // 556
	BYTE ContentId[20]; // 812
	DWORD SizeOfHeaders; // 832
} XCONTENT_HEADER, *PXCONTENT_HEADER; // 836
C_ASSERT(sizeof(XCONTENT_HEADER) == 836); // XCONTENT_METADATA normally follows directly after

typedef struct _STF_VOLUME_DESCRIPTOR { 
	BYTE DescriptorLength; // 0x0 sz:0x1
	BYTE Version; // 0x1 sz:0x1
	BYTE ReadOnlyFormat : 1; // 0x2 bfo:0x0
	BYTE RootActiveIndex : 1; // 0x2 bfo:0x1
	BYTE DirectoryOverallocated : 1; // 0x2 bfo:0x2
	BYTE DirectoryIndexBoundsValid : 1; // 0x2 bfo:0x3
	BYTE DirectoryAllocationBlocks0; // 0x3 sz:0x1
	BYTE DirectoryAllocationBlocks1; // 0x4 sz:0x1
	BYTE DirectoryFirstBlockNumber0; // 0x5 sz:0x1
	BYTE DirectoryFirstBlockNumber1; // 0x6 sz:0x1
	BYTE DirectoryFirstBlockNumber2; // 0x7 sz:0x1
	BYTE RootHash[0x14]; // 0x8 sz:0x14
	DWORD NumberOfTotalBlocks; // 0x1C sz:0x4
	DWORD NumberOfFreeBlocks; // 0x20 sz:0x4
} STF_VOLUME_DESCRIPTOR, *PSTF_VOLUME_DESCRIPTOR; // size 36
C_ASSERT(sizeof(STF_VOLUME_DESCRIPTOR) == 0x24);

typedef struct _SVOD_HASH_ENTRY { 
	BYTE Hash[0x14]; // 0x0 sz:0x14
} SVOD_HASH_ENTRY, *PSVOD_HASH_ENTRY; // size 20
C_ASSERT(sizeof(SVOD_HASH_ENTRY) == 0x14);

typedef struct _SVOD_DEVICE_FEATURES { 
	BYTE ShouldBeZeroForDownlevelClients : 1; // 0x0 bfo:0x7
	BYTE HasEnhancedGDFLayout : 1; // 0x0 bfo:0x6
	BYTE MustBeZeroForFutureUsage : 6; // 0x0 bfo:0x0
} SVOD_DEVICE_FEATURES, *PSVOD_DEVICE_FEATURES; // size 1
C_ASSERT(sizeof(SVOD_DEVICE_FEATURES) == 0x1);

typedef struct _SVOD_DEVICE_DESCRIPTOR { 
	BYTE DescriptorLength; // 0x0 sz:0x1
	BYTE BlockCacheElementCount; // 0x1 sz:0x1
	BYTE WorkerThreadProcessor; // 0x2 sz:0x1
	BYTE WorkerThreadPriority; // 0x3 sz:0x1
	SVOD_HASH_ENTRY FirstFragmentHashEntry; // 0x4 sz:0x14
	SVOD_DEVICE_FEATURES Features; // 0x18 sz:0x1
	BYTE NumberOfDataBlocks2; // 0x19 sz:0x1
	BYTE NumberOfDataBlocks1; // 0x1A sz:0x1
	BYTE NumberOfDataBlocks0; // 0x1B sz:0x1
	BYTE StartingDataBlock0; // 0x1C sz:0x1
	BYTE StartingDataBlock1; // 0x1D sz:0x1
	BYTE StartingDataBlock2; // 0x1E sz:0x1
	BYTE Reserved[0x5]; // 0x1F sz:0x5
} SVOD_DEVICE_DESCRIPTOR, *PSVOD_DEVICE_DESCRIPTOR; // size 36
C_ASSERT(sizeof(SVOD_DEVICE_DESCRIPTOR) == 0x24);

typedef struct _XCONTENT_METADATA_MEDIA_DATA { 
	BYTE SeriesId[0x10]; // 0x0 sz:0x10
	BYTE SeasonId[0x10]; // 0x10 sz:0x10
	WORD SeasonNumber; // 0x20 sz:0x2
	WORD EpisodeNumber; // 0x22 sz:0x2
} XCONTENT_METADATA_MEDIA_DATA, *PXCONTENT_METADATA_MEDIA_DATA; // size 36
C_ASSERT(sizeof(XCONTENT_METADATA_MEDIA_DATA) == 0x24);

typedef struct _XCONTENT_METADATA_AVATAR_ASSET_DATA { 
	DWORD SubCategory; // 0x0 sz:0x4
	DWORD Colorizable; // 0x4 sz:0x4
	BYTE AssetId[0x10]; // 0x8 sz:0x10
	BYTE SkeletonVersionMask; // 0x18 sz:0x1
	BYTE Reserved[0xB]; // 0x19 sz:0xB
} XCONTENT_METADATA_AVATAR_ASSET_DATA, *PXCONTENT_METADATA_AVATAR_ASSET_DATA; // size 36
C_ASSERT(sizeof(XCONTENT_METADATA_AVATAR_ASSET_DATA) == 0x24);

typedef struct _XCONTENT_ATTRIBUTES { 
	BYTE Reserved : 2; // 0x0 bfo:0x0
	BYTE DeepLinkSupported : 1; // 0x0 bfo:0x2
	BYTE DisableNetworkStorage : 1; // 0x0 bfo:0x3
	BYTE KinectEnabled : 1; // 0x0 bfo:0x4
	BYTE MoveOnlyTransfer : 1; // 0x0 bfo:0x5
	BYTE DeviceTransfer : 1; // 0x0 bfo:0x6
	BYTE ProfileTransfer : 1; // 0x0 bfo:0x7
} XCONTENT_ATTRIBUTES, *PXCONTENT_ATTRIBUTES; // size 1
C_ASSERT(sizeof(XCONTENT_ATTRIBUTES) == 0x1);

typedef union _XCONTENT_METADATA_FLAGS { 
	XCONTENT_ATTRIBUTES Bits; // 0x0 sz:0x1
	BYTE FlagsAsBYTE; // 0x0 sz:0x1
} XCONTENT_METADATA_FLAGS, *PXCONTENT_METADATA_FLAGS; // size 1
C_ASSERT(sizeof(XCONTENT_METADATA_FLAGS) == 0x1);

typedef struct _XCONTENT_METADATA { 
	DWORD ContentType; // 0x0 sz:0x4
	DWORD ContentMetadataVersion; // 0x4 sz:0x4
	LARGE_INTEGER ContentSize; // 0x8 sz:0x8
	XEX_EXECUTION_ID ExecutionId; // 0x10 sz:0x18
	BYTE ConsoleId[0x5]; // 0x28 sz:0x5
	QWORD Creator; // 0x2D sz:0x8
	union {
		STF_VOLUME_DESCRIPTOR StfsVolumeDescriptor; // 0x35 sz:0x24
		SVOD_DEVICE_DESCRIPTOR SvodVolumeDescriptor; // 0x35 sz:0x24
	} Volume;
	DWORD DataFiles; // 0x59 sz:0x4
	QWORD DataFilesSize; // 0x5D sz:0x8
	enum XCONTENT_VOLUME_TYPE VolumeType; // 0x65 sz:0x4
	QWORD OnlineCreator; // 0x69 sz:0x8
	DWORD Category; // 0x71 sz:0x4
	BYTE Reserved2[0x20]; // 0x75 sz:0x20
	union {
		XCONTENT_METADATA_MEDIA_DATA MediaData; // 0x95 sz:0x24
		XCONTENT_METADATA_AVATAR_ASSET_DATA AvatarAssetData; // 0x95 sz:0x24
	} Data;
	BYTE DeviceId[0x14]; // 0xB9 sz:0x14
	WCHAR DisplayName[0x9][0x80]; // 0xCD sz:0x900
	WCHAR Description[0x9][0x80]; // 0x9CD sz:0x900
	WCHAR Publisher[0x40]; // 0x12CD sz:0x80
	WCHAR TitleName[0x40]; // 0x134D sz:0x80
	XCONTENT_METADATA_FLAGS Flags; // 0x13CD sz:0x1
	DWORD ThumbnailSize; // 0x13CE sz:0x4
	DWORD TitleThumbnailSize; // 0x13D2 sz:0x4
	BYTE Thumbnail[0x3D00]; // 0x13D6 sz:0x3D00
	WCHAR DisplayNameEx[3][0x80]; // 0x50D6 sz:0x300
	BYTE TitleThumbnail[0x3D00]; // 0x53D6 sz:0x3D00
	WCHAR DescriptionEx[3][0x80]; // 0x90D6 sz:0x300
} XCONTENT_METADATA, *PXCONTENT_METADATA; // size 37846
C_ASSERT(sizeof(XCONTENT_METADATA) == 0x93D6);

typedef struct _XCONTENT_METADATA_INSTALLER_TITLE_UPDATE { 
	DWORD CurrentVersion; // 0x0 sz:0x4
	DWORD NewVersion; // 0x4 sz:0x4
	BYTE Reserved[0x15E8]; // 0x8 sz:0x15E8
} XCONTENT_METADATA_INSTALLER_TITLE_UPDATE, *PXCONTENT_METADATA_INSTALLER_TITLE_UPDATE; // size 5616
C_ASSERT(sizeof(XCONTENT_METADATA_INSTALLER_TITLE_UPDATE) == 0x15F0);

typedef struct _XCONTENT_METADATA_INSTALLER_SYSTEM_UPDATE { 
	DWORD SystemVersion; // 0x0 sz:0x4
	DWORD NewVersion; // 0x4 sz:0x4
	BYTE Reserved[0x15E8]; // 0x8 sz:0x15E8
} XCONTENT_METADATA_INSTALLER_SYSTEM_UPDATE, *PXCONTENT_METADATA_INSTALLER_SYSTEM_UPDATE; // size 5616
C_ASSERT(sizeof(XCONTENT_METADATA_INSTALLER_SYSTEM_UPDATE) == 0x15F0);

typedef struct _XONLINECONTENT_RESUME_HEADER { 
	XONLINECONTENT_RESUME_STATE ResumeState; // 0x0 sz:0x4
	DWORD dwCurrentFileIndex; // 0x4 sz:0x4
	LARGE_INTEGER liCurrentFileOffset; // 0x8 sz:0x8
	LARGE_INTEGER liBytesProcessed; // 0x10 sz:0x8
	LARGE_INTEGER liLastModified; // 0x18 sz:0x8
} XONLINECONTENT_RESUME_HEADER, *PXONLINECONTENT_RESUME_HEADER; // size 32
C_ASSERT(sizeof(XONLINECONTENT_RESUME_HEADER) == 0x20);

typedef struct _XCONTENT_METADATA_INSTALLER_PROGRESS_CACHE { 
	struct _XONLINECONTENT_RESUME_HEADER ResumeHeader; // 0x0 sz:0x20
	BYTE CabResumeData[0x15D0]; // 0x20 sz:0x15D0
} XCONTENT_METADATA_INSTALLER_PROGRESS_CACHE, *PXCONTENT_METADATA_INSTALLER_PROGRESS_CACHE; // size 5616
C_ASSERT(sizeof(XCONTENT_METADATA_INSTALLER_PROGRESS_CACHE) == 0x15F0);

typedef struct _XCONTENT_METADATA_INSTALLER { 
	INSTALLER_METADATA_TYPE MetaDataType; // 0x0 sz:0x4
	union {
		XCONTENT_METADATA_INSTALLER_TITLE_UPDATE TitleUpdate;
		XCONTENT_METADATA_INSTALLER_SYSTEM_UPDATE SystemUpdate;
		XONLINECONTENT_RESUME_HEADER ResumeHeader;
	}MetaData; // 0x4 sz:0x15F0
} XCONTENT_METADATA_INSTALLER, *PXCONTENT_METADATA_INSTALLER; // size 5620
C_ASSERT(sizeof(XCONTENT_METADATA_INSTALLER) == 0x15F4);

typedef struct _XCONTENT_METADATA_TITLE_CONTENT { 
	BYTE Reserved[0x15F4]; // 0x0 sz:0x15F4
} XCONTENT_METADATA_TITLE_CONTENT, *PXCONTENT_METADATA_TITLE_CONTENT; // size 5620
C_ASSERT(sizeof(XCONTENT_METADATA_TITLE_CONTENT) == 0x15F4);

/* a typedef for all the header parts ONLY if they come one after the other!!! */
typedef struct _XCONTENT_FULL_HEADER {
	XCONTENT_HEADER Header; // 0x0 sz:0x344
	XCONTENT_METADATA Meta; // 0x344 sz:0x93D6
	union { // 0x971A sz:0x15F4
		XCONTENT_METADATA_INSTALLER Installer;
		XCONTENT_METADATA_TITLE_CONTENT Title;
	} Content;
} XCONTENT_FULL_HEADER, *PXCONTENT_FULL_HEADER; // size 44302
C_ASSERT(sizeof(XCONTENT_FULL_HEADER) == 0xAD0E);

// HASH STUFF
typedef struct _STF_HASH_ENTRY { 
	BYTE Hash[0x14]; // 0x0 sz:0x14
	//struct <unnamed-tag> Level0; // 0x14 sz:0x4 3 way union!!!
	//struct <unnamed-tag> LevelN; // 0x14 sz:0x4
	DWORD LevelAsULONG; // 0x14 sz:0x4
} STF_HASH_ENTRY, *PSTF_HASH_ENTRY; // size 24
C_ASSERT(sizeof(STF_HASH_ENTRY) == 0x18);

typedef struct _STF_HASH_BLOCK { 
	STF_HASH_ENTRY Entries[0xAA]; // 0x0 sz:0xFF0
	DWORD NumberOfCommittedBlocks; // 0xFF0 sz:0x4
	BYTE Padding[0xC]; // 0xFF4 sz:0xC
} STF_HASH_BLOCK, *PSTF_HASH_BLOCK; // size 4096
C_ASSERT(sizeof(STF_HASH_BLOCK) == 0x1000);

typedef struct _SVOD_LEVEL0_HASH_BLOCK { 
	SVOD_HASH_ENTRY Entries[0xCC]; // 0x0 sz:0xFF0
	BYTE Reserved[0x10]; // 0xFF0 sz:0x10
} SVOD_LEVEL0_HASH_BLOCK, *PSVOD_LEVEL0_HASH_BLOCK; // size 4096
C_ASSERT(sizeof(SVOD_LEVEL0_HASH_BLOCK) == 0x1000);

typedef struct _SVOD_LEVEL1_HASH_BLOCK { 
	SVOD_HASH_ENTRY Entries[0xCB]; // 0x0 sz:0xFDC
	SVOD_HASH_ENTRY NextFragmentHashEntry; // 0xFDC sz:0x14
	BYTE Reserved[0x10]; // 0xFF0 sz:0x10
} SVOD_LEVEL1_HASH_BLOCK, *PSVOD_LEVEL1_HASH_BLOCK; // size 4096
C_ASSERT(sizeof(SVOD_LEVEL1_HASH_BLOCK) == 0x1000);

typedef struct _SVOD_LEVEL0_BACKING_BLOCKS { 
	SVOD_LEVEL0_HASH_BLOCK Level0HashBlock; // 0x0 sz:0x1000
	BYTE DataBlocks[0xCC000]; // 0x1000 sz:0xCC000
} SVOD_LEVEL0_BACKING_BLOCKS, *PSVOD_LEVEL0_BACKING_BLOCKS; // size 839680
C_ASSERT(sizeof(SVOD_LEVEL0_BACKING_BLOCKS) == 0xCD000);

typedef union _STF_FILE_BOUNDS { 
	DWORD FileSize; // 0x0 sz:0x4
	struct{
		WORD FirstChildDirectoryIndex; // 0x0 sz:0x2
		WORD LastChildDirectoryIndex; // 0x2 sz:0x2
	} child;
} STF_FILE_BOUNDS, *PSTF_FILE_BOUNDS; // size 4
C_ASSERT(sizeof(STF_FILE_BOUNDS) == 0x4);

typedef union _STF_TIME_STAMP {
	struct {
		DWORD DoubleSeconds : 5; // 0x0 bfo:0x0
		DWORD Minute : 6; // 0x0 bfo:0x5
		DWORD Hour : 5; // 0x0 bfo:0x11
		DWORD Day : 5; // 0x0 bfo:0x16
		DWORD Month : 4; // 0x0 bfo:0x21
		DWORD Year : 7; // 0x0 bfo:0x25
	} bf;
	DWORD AsULONG; // 0x0 sz:0x4
} STF_TIME_STAMP, *PSTF_TIME_STAMP; // size 4
C_ASSERT(sizeof(STF_TIME_STAMP) == 0x4);

typedef struct _STF_DIRECTORY_ENTRY { 
	BYTE FileName[0x28]; // 0x0 sz:0x28
	BYTE FileNameLength : 6; // 0x28 bfo:0x0
	BYTE Contiguous : 1; // 0x28 bfo:0x6
	BYTE Directory : 1; // 0x28 bfo:0x7
	BYTE ValidDataBlocks0; // 0x29 sz:0x1
	BYTE ValidDataBlocks1; // 0x2A sz:0x1
	BYTE ValidDataBlocks2; // 0x2B sz:0x1
	BYTE AllocationBlocks0; // 0x2C sz:0x1
	BYTE AllocationBlocks1; // 0x2D sz:0x1
	BYTE AllocationBlocks2; // 0x2E sz:0x1
	BYTE FirstBlockNumber0; // 0x2F sz:0x1
	BYTE FirstBlockNumber1; // 0x30 sz:0x1
	BYTE FirstBlockNumber2; // 0x31 sz:0x1
	WORD DirectoryIndex; // 0x32 sz:0x2
	union _STF_FILE_BOUNDS FileBounds; // 0x34 sz:0x4
	union _STF_TIME_STAMP CreationTimeStamp; // 0x38 sz:0x4
	union _STF_TIME_STAMP LastWriteTimeStamp; // 0x3C sz:0x4
} STF_DIRECTORY_ENTRY, *PSTF_DIRECTORY_ENTRY; // size 64
C_ASSERT(sizeof(STF_DIRECTORY_ENTRY) == 0x40);

// *********** PACKING ENDS HERE **************//
#pragma pack(pop)
// *********** PACKING ENDS HERE **************//

typedef struct _XCONTENT_MOUNTED_PACKAGE { 
	PVOID pvFsDeviceObject; // 0x0 sz:0x4
	PVOID pvFsBlockCache; // 0x4 sz:0x4
	LIST_ENTRY leMountedPackages; // 0x8 sz:0x8
	DWORD dwFlags; // 0x10 sz:0x4
	HANDLE hPackageFile; // 0x14 sz:0x4
	DWORD dwOpenRefCount; // 0x18 sz:0x4
	RTL_CRITICAL_SECTION csHeaderLock; // 0x1C sz:0x1C
	XCONTENT_HEADER ContentHeader; // 0x38 sz:0x344
	XCONTENT_METADATA ContentMetaData; // 0x37C sz:0x93D6
	PBYTE pbOtherMetaData; // 0x9754 sz:0x4
	DWORD dwOtherMetaDataSize; // 0x9758 sz:0x4
	DWORD DeviceIDLocked; // 0x975C sz:0x4
	char szFsDeviceName[0x40]; // 0x9760 sz:0x40
	char szPackageFilePath[MAX_PATH]; // 0x97A0 sz:0x104
	DWORD dwLicenseMaskLast; // 0x98A4 sz:0x4
	DWORD dwModifiedMetadataOffset; // 0x98A8 sz:0x4
} XCONTENT_MOUNTED_PACKAGE, *PXCONTENT_MOUNTED_PACKAGE; // size 39084
C_ASSERT(sizeof(XCONTENT_MOUNTED_PACKAGE) == 0x98AC);


typedef struct _XCONTENT_DATA_MEDIA { 
	BYTE rgSeriesId[0x10]; // 0x0 sz:0x10
	BYTE rgSeasonId[0x10]; // 0x10 sz:0x10
	WORD wSeasonNumber; // 0x20 sz:0x2
	WORD wEpisodeNumber; // 0x22 sz:0x2
} XCONTENT_DATA_MEDIA, *PXCONTENT_DATA_MEDIA; // size 36
C_ASSERT(sizeof(XCONTENT_DATA_MEDIA) == 0x24);

typedef struct _XCONTENT_DATA_AVATAR_ASSET { 
	DWORD dwSubCategory; // 0x0 sz:0x4
	int fColorizable; // 0x4 sz:0x4
	BYTE rgAssetId[0x10]; // 0x8 sz:0x10
	BYTE SkeletonVersionMask; // 0x18 sz:0x1
} XCONTENT_DATA_AVATAR_ASSET, *PXCONTENT_DATA_AVATAR_ASSET; // size 28
C_ASSERT(sizeof(XCONTENT_DATA_AVATAR_ASSET) == 0x1C);

typedef struct _TYPED_MEDIA_URL { 
	DWORD dwMediaUrlType; // 0x0 sz:0x4
	DWORD dwUrlSize; // 0x4 sz:0x4
	char * pszUrl; // 0x8 sz:0x4
} TYPED_MEDIA_URL, *PTYPED_MEDIA_URL; // size 12
C_ASSERT(sizeof(TYPED_MEDIA_URL) == 0xC);

typedef struct _MEDIA_INSTANCE_URLS { 
	GUID MediaID; // 0x0 sz:0x10
	GUID MediaInstanceID; // 0x10 sz:0x10
	QWORD qwPackageSize; // 0x20 sz:0x8
	QWORD qwInstallSize; // 0x28 sz:0x8
	BYTE rgbSymKey[0x10]; // 0x30 sz:0x10
	BYTE rgbPubKey[0x11C]; // 0x40 sz:0x11C
	DWORD dwPackageType; // 0x15C sz:0x4
	DWORD dwUrlCount; // 0x160 sz:0x4
	PTYPED_MEDIA_URL pUrls; // 0x164 sz:0x4
} MEDIA_INSTANCE_URLS, *PMEDIA_INSTANCE_URLS; // size 360
C_ASSERT(sizeof(MEDIA_INSTANCE_URLS) == 0x168);

typedef struct _FIND_MEDIA_INSTANCE_URLS_RESPONSE { 
	DWORD dwMediaInstanceIdsCount; // 0x0 sz:0x4
	PMEDIA_INSTANCE_URLS pMediaInstanceIds; // 0x4 sz:0x4
} FIND_MEDIA_INSTANCE_URLS_RESPONSE, *PFIND_MEDIA_INSTANCE_URLS_RESPONSE; // size 8
C_ASSERT(sizeof(FIND_MEDIA_INSTANCE_URLS_RESPONSE) == 0x8);

//typedef struct _XCONTENT_DATA { // this is in the sdk already
//	DWORD DeviceID; // 0x0 sz:0x4
//	DWORD dwContentType; // 0x4 sz:0x4
//	wchar_t szDisplayName[0x80]; // 0x8 sz:0x100
//	char szFileName[0x2A]; // 0x108 sz:0x2A
//} XCONTENT_DATA, *PXCONTENT_DATA; // size 308
//C_ASSERT(sizeof(XCONTENT_DATA) == 0x134);

typedef struct _XCONTENT_DATA_INTERNAL {
	XCONTENT_DATA xcData;
	DWORD dwCategory; // 0x134 sz:0x4
	XUID xuid; // 0x138 sz:0x8
	DWORD dwTitleId; // 0x140 sz:0x4
	DWORD dwLicenseMask; // 0x144 sz:0x4
	QWORD ullContentSize; // 0x148 sz:0x8
	FILETIME ftCreationTime; // 0x150 sz:0x8
	wchar_t szTitleName[0x40]; // 0x158 sz:0x80
	union{
		XCONTENT_DATA_MEDIA MediaContentData; // 0x1D8 sz:0x24
		XCONTENT_DATA_AVATAR_ASSET AvatarContentData; // 0x1D8 sz:0x1C
	};
	DWORD fPartial : 1; // 0x1FC bfo:0x0
	DWORD fCorrupt : 1; // 0x1FC bfo:0x1
	DWORD fKinectEnabled : 1; // 0x1FC bfo:0x2
	DWORD fDeepLinkSupported : 1; // 0x1FC bfo:0x3
	DWORD fDisableNetworkStorage : 1; // 0x1FC bfo:0x4
	DWORD fMoveOnlyTransfer : 1; // 0x1FC bfo:0x5
	DWORD fDeviceTransfer : 1; // 0x1FC bfo:0x6
	DWORD fProfileTransfer : 1; // 0x1FC bfo:0x7
	DWORD dwReserved : 24; // 0x1FC bfo:0x8
} XCONTENT_DATA_INTERNAL, *PXCONTENT_DATA_INTERNAL; // size 512
C_ASSERT(sizeof(XCONTENT_DATA_INTERNAL) == 0x200);

typedef struct _BACKGROUND_DOWNLOAD_ITEM { 
	XMARKETPLACE_MEDIA_TYPE MediaType; // 0x0 sz:0x4
	DWORD dwEffectiveTitleId; // 0x4 sz:0x4
	XUID xuid; // 0x8 sz:0x8
	BYTE consoleId[0x5]; // 0x10 sz:0x5
	BYTE contentId[0x14]; // 0x15 sz:0x14
	DWORD dwState; // 0x2C sz:0x4
	DWORD dwRatingId; // 0x30 sz:0x4
	GUID mediaId; // 0x34 sz:0x10
	GUID mediaInstanceId; // 0x44 sz:0x10
	GUID offerId; // 0x54 sz:0x10
	wchar_t wszOfferName[0x80]; // 0x64 sz:0x100
	char szPath[0x104]; // 0x164 sz:0x104
	LARGE_INTEGER liInstallSize; // 0x268 sz:0x8
	DWORD dwPercentCompleted; // 0x270 sz:0x4
	int bRepeatDownload; // 0x274 sz:0x4
	char szUrl[0x100]; // 0x278 sz:0x100
	LARGE_INTEGER liDownloadSize; // 0x378 sz:0x8
} BACKGROUND_DOWNLOAD_ITEM, *PBACKGROUND_DOWNLOAD_ITEM; // size 896
C_ASSERT(sizeof(BACKGROUND_DOWNLOAD_ITEM) == 0x380);

/* seems to be for .xcp data with a magic/sig of 4D534346 aka 'MSCF' */
typedef struct _RC4_SHA_HEADER { 
	BYTE Checksum[0x14]; // 0x0 sz:0x14
	BYTE Confounder[0x8]; // 0x14 sz:0x8
} RC4_SHA_HEADER, *PRC4_SHA_HEADER; // size 28
C_ASSERT(sizeof(RC4_SHA_HEADER) == 0x1C);

typedef struct _CFFILE { 
	int cbFile; // 0x0 sz:0x4
	DWORD uoffFolderStart; // 0x4 sz:0x4
	WORD iFolder; // 0x8 sz:0x2
	WORD date; // 0xA sz:0x2
	WORD time; // 0xC sz:0x2
	WORD attribs; // 0xE sz:0x2
} CFFILE, *PCFFILE; // size 16
C_ASSERT(sizeof(CFFILE) == 0x10);

typedef struct _CFFOLDER { 
	DWORD coffCabStart; // 0x0 sz:0x4
	WORD cCFData; // 0x4 sz:0x2
	SHORT typeCompress; // 0x6 sz:0x2
} CFFOLDER, *PCFFOLDER; // size 8
C_ASSERT(sizeof(CFFOLDER) == 0x8);

typedef struct _CFFOLDER_HMAC { 
	CFFOLDER cffolder; // 0x0 sz:0x8
	RC4_SHA_HEADER hmac; // 0x8 sz:0x1C
} CFFOLDER_HMAC, *PCFFOLDER_HMAC; // size 36
C_ASSERT(sizeof(CFFOLDER_HMAC) == 0x24);

typedef struct _CFRESERVE { 
	WORD cbCFHeader; // 0x0 sz:0x2
	BYTE cbCFFolder; // 0x2 sz:0x1
	BYTE cbCFData; // 0x3 sz:0x1
} CFRESERVE, *PFRESERVE; // size 4
C_ASSERT(sizeof(CFRESERVE) == 0x4);

typedef struct _CFHEADER { 
	int sig; // 0x0 sz:0x4
	DWORD csumHeader; // 0x4 sz:0x4
	int cbCabinet; // 0x8 sz:0x4
	DWORD csumFolders; // 0xC sz:0x4
	DWORD coffFiles; // 0x10 sz:0x4
	DWORD csumFiles; // 0x14 sz:0x4
	WORD version; // 0x18 sz:0x2
	WORD cFolders; // 0x1A sz:0x2
	WORD cFiles; // 0x1C sz:0x2
	WORD flags; // 0x1E sz:0x2
	WORD setID; // 0x20 sz:0x2
	WORD iCabinet; // 0x22 sz:0x2
} CFHEADER, *PCFHEADER; // size 36
C_ASSERT(sizeof(CFHEADER) == 0x24);

typedef struct _XONLINECONTENT_HEADER { 
	CFHEADER cfheader; // 0x0 sz:0x24
	CFRESERVE cfreserve; // 0x24 sz:0x4
	RC4_SHA_HEADER digestFolders; // 0x28 sz:0x1C
	RC4_SHA_HEADER digestFiles; // 0x44 sz:0x1C
} XONLINECONTENT_HEADER, *PXONLINECONTENT_HEADER; // size 96
C_ASSERT(sizeof(XONLINECONTENT_HEADER) == 0x60);

#endif // __XAMEXT_XCONTENT_H

```

`XenonDumper/libs/xkelib/xam/xamext20871.0.def`:

```def
LIBRARY xam.xex@20871.0+1861.0
EXPORTS
	NetDll_WSAStartup @1
	NetDll_WSACleanup @2
	NetDll_socket @3
	NetDll_closesocket @4
	NetDll_shutdown @5
	NetDll_ioctlsocket @6
	NetDll_setsockopt @7
	NetDll_getsockopt @8
	NetDll_getsockname @9
	NetDll_getpeername @10
	NetDll_bind @11
	NetDll_connect @12
	NetDll_listen @13
	NetDll_accept @14
	NetDll_select @15
	NetDll_WSAGetOverlappedResult @16
	NetDll_WSACancelOverlappedIO @17
	NetDll_recv @18
	NetDll_WSARecv @19
	NetDll_recvfrom @20
	NetDll_WSARecvFrom @21
	NetDll_send @22
	NetDll_WSASend @23
	NetDll_sendto @24
	NetDll_WSASendTo @25
	NetDll_inet_addr @26
	NetDll_WSAGetLastError @27
	NetDll_WSASetLastError @28
	NetDll_WSACreateEvent @29
	NetDll_WSACloseEvent @30
	NetDll_WSASetEvent @31
	NetDll_WSAResetEvent @32
	NetDll_WSAWaitForMultipleEvents @33
	NetDll___WSAFDIsSet @34
	NetDll_WSAEventSelect @35
	NetDll_WSAStartupEx @36
	NetDll_XNetStartup @51
	NetDll_XNetCleanup @52
	NetDll_XNetRandom @53
	NetDll_XNetCreateKey @54
	NetDll_XNetRegisterKey @55
	NetDll_XNetUnregisterKey @56
	NetDll_XNetXnAddrToInAddr @57
	NetDll_XNetServerToInAddr @58
	NetDll_XNetTsAddrToInAddr @59
	NetDll_XNetInAddrToXnAddr @60
	NetDll_XNetInAddrToServer @61
	NetDll_XNetInAddrToString @62
	NetDll_XNetUnregisterInAddr @63
	NetDll_XNetXnAddrToMachineId @64
	NetDll_XNetConnect @65
	NetDll_XNetGetConnectStatus @66
	NetDll_XNetDnsLookup @67
	NetDll_XNetDnsRelease @68
	NetDll_XNetQosListen @69
	NetDll_XNetQosLookup @70
	NetDll_XNetQosServiceLookup @71
	NetDll_XNetQosRelease @72
	NetDll_XNetGetTitleXnAddr @73
	NetDll_XNetGetDebugXnAddr @74
	NetDll_XNetGetEthernetLinkStatus @75
	NetDll_XNetGetBroadcastVersionStatus @76
	NetDll_XNetQosGetListenStats @77
	NetDll_XNetGetOpt @78
	NetDll_XNetSetOpt @79
	NetDll_XNetStartupEx @80
	NetDll_XNetReplaceKey @81
	NetDll_XNetGetXnAddrPlatform @82
	NetDll_XNetGetSystemLinkPort @83
	NetDll_XNetSetSystemLinkPort @84
	NetDll_XNetDnsReverseLookup @85
	NetDll_XNetDnsReverseRelease @86
	NetDll_XnpLoadConfigParams @101
	NetDll_XnpSaveConfigParams @102
	NetDll_XnpConfigUPnP @103
	NetDll_XnpConfig @104
	NetDll_XnpGetConfigStatus @105
	NetDll_XnpLoadMachineAccount @106
	NetDll_XnpSaveMachineAccount @107
	NetDll_XnpCapture @108
	NetDll_XnpEthernetInterceptSetCallbacks @109
	NetDll_XnpEthernetInterceptXmit @110
	NetDll_XnpEthernetInterceptRecv @111
	NetDll_XnpLogonGetStatus @112
	NetDll_XnpLogonGetQFlags @113
	NetDll_XnpLogonSetQFlags @114
	NetDll_XnpLogonSetQEvent @115
	NetDll_XnpLogonClearQEvent @116
	NetDll_XnpLogonGetQVals @117
	NetDll_XnpLogonSetQVals @118
	NetDll_XnpLogonSetPState @119
	NetDll_XnpGetVlanXboxName @120
	NetDll_XnpSetVlanXboxName @121
	NetDll_XnpGetActiveSocketList @122
	NetDll_XnpNoteSystemTime @123
	NetDll_XnpRegisterKeyForCallerType @124
	NetDll_XnpUnregisterKeyForCallerType @125
	NetDll_XnpLogonGetChallenge @126
	NetDll_XnpLogonClearChallenge @127
	NetDll_XnpLogonSetChallengeResponse @128
	NetDll_XnpGetSecAssocList @129
	NetDll_XnpGetKeyList @130
	NetDll_XnpGetQosLookupList @131
	NetDll_XnpPersistTitleState @132
	NetDll_XnpReplaceKeyForCallerType @133
	NetDll_XnpEthernetInterceptSetExtendedReceiveCallback @134
	NetDll_XnpQosHistoryLoad @135
	NetDll_XnpQosHistorySaveMeasurements @136
	NetDll_XnpQosHistoryGetEntries @137
	NetDll_XnpQosHistoryGetAggregateMeasurement @138
	NetDll_XnpToolSetCallbacks @139
	NetDll_XnpToolIpProxyInject @140
	NetDll_XnpUpdateConfigParams @141
	NetDll_XnpEthernetInterceptXmitAsIp @142
	NetDll_XnpConfigUPnPPortAndExternalAddr @143
	NetDll_XmlDownloadStart @151
	NetDll_XmlDownloadContinue @152
	NetDll_XmlDownloadStop @153
	NetDll_XmlDownloadGetParseTime @154
	NetDll_XmlDownloadGetReceivedDataSize @155
	XnpGetXwppMemoryLogSnapshot @198
	XnpGetXwppRuntimeFilter @199
	NetDll_XHttpStartup @201
	NetDll_XHttpShutdown @202
	NetDll_XHttpOpen @203
	NetDll_XHttpCloseHandle @204
	NetDll_XHttpConnect @205
	NetDll_XHttpSetStatusCallback @206
	NetDll_XHttpOpenRequest @207
	NetDll_XHttpOpenRequestUsingMemory @208
	NetDll_XHttpSendRequest @209
	NetDll_XHttpReceiveResponse @210
	NetDll_XHttpQueryHeaders @211
	NetDll_XHttpReadData @212
	NetDll_XHttpWriteData @213
	NetDll_XHttpQueryOption @214
	NetDll_XHttpSetOption @215
	NetDll_XHttpDoWork @216
	NetDll_XHttpSetCredentials @217
	NetDll_XHttpQueryAuthSchemes @218
	NetDll_XHttpCrackUrlW @219
	NetDll_XHttpCrackUrl @220
	NetDll_XHttpCreateUrl @221
	NetDll_XHttpCreateUrlW @222
	NetDll_UpnpStartup @251
	NetDll_UpnpCleanup @252
	NetDll_UpnpSearchCreate @253
	NetDll_UpnpSearchGetDevices @254
	NetDll_UpnpDescribeCreate @255
	NetDll_UpnpDescribeGetResults @256
	NetDll_UpnpActionCalculateWorkBufferSize @257
	NetDll_UpnpActionCreate @258
	NetDll_UpnpActionGetResults @259
	NetDll_UpnpEventCreate @260
	NetDll_UpnpEventGetCurrentState @261
	NetDll_UpnpEventUnsubscribe @262
	NetDll_UpnpDoWork @263
	NetDll_UpnpCloseHandle @264
	XNetLogonGetLoggedOnUsers @301
	XNetLogonGetNatType @302
	XNetLogonTaskStart @303
	XNetLogonTaskClose @304
	XNetLogonTaskContinue @305
	XNetLogonGetServiceInfo @306
	XNetLogonGetUserPrivileges @307
	XNetLogonSetConsoleCertificate @308
	XNetLogonGetMachineID @309
	XNetLogonGetTitleID @310
	XNetLogonGetTitleVersion @311
	XNetLogonGetServiceNetworkID @312
	XNetLogonGetDnsString @313
	XNetLogonSetTitleID @314
	XNetLogonGetExtendedStatus @315
	XNetLogonClearTicketCaches @316
	XNetLogonInitOverrideInfo @317
	XNetLogonGetLastUPnPStatus @318
	XNetLogonGetFlowToken @319
	XNetLogonGetTicketOpt @320
	XNetLogonSetTicketOpt @321
	XNetLogonGetState @322
	XamInputGetCapabilities @400
	XamInputGetState @401
	XamInputSetState @402
	XamInputGetKeystroke @403
	XamInputEnableAutobind @404
	XamInputRawState @405
	XamEnableSystemAppInput @406
	XamInputGetDeviceStats @407
	XamInputGetKeystrokeEx @408
	XamInputGetKeystrokeHud @409
	XamInputSetLayoutKeyboard @410
	XamInputToggleKeyLocks @411
	XamInputResetLayoutKeyboard @412
	XamInputGetKeystrokeHudEx @413
	XamInputSetKeyboardTranslationHud @414
	XamSetInactivityTime @415
	XamEnableInactivityProcessing @416
	XamResetInactivity @417
	XamSetInactivityTimeFromConfig @418
	XamLoaderGetMediaInfo @419
	XamLoaderLaunchTitle @420
	XamLoaderLaunchTitleEx @421
	XamLoaderSetLaunchData @422
	XamLoaderGetLaunchDataSize @423
	XamLoaderGetLaunchData @424
	XamLoaderTerminateTitle @425
	XamLoaderGetDvdTrayState @426
	XamLoaderGetGameInfo @427
	XamLoaderLaunchTitleOnDvd @428
	XamLoaderSetSpindleSpeed @429
	XamTaskCreateQueue @430
	XamTaskSchedule @431
	XamTaskReschedule @432
	XamTaskCloseHandle @433
	XamTaskCancel @434
	XamTaskShouldExit @435
	XamTaskWaitOnCompletion @436
	XamTaskModify @437
	XamTaskGetCurrentTask @438
	XamTaskGetAttributes @439
	XamExecutingOnBehalfOfTitle @440
	XamInputSendStayAliveRequest @441
	XamInputGetUserVibrationLevel @442
	XamIsSystemTitleId @443
	XamLoaderIsTitleTerminatePending @444
	XamInputSetTextMessengerIndicator @445
	XamLoaderGetPriorTitleId @446
	XamIsXbox1TitleId @447
	XamInputSetKeyLocks @448
	XamInputGetKeyLocks @449
	XamTaskGetStatus @450
	XamGetRootObj @451
	XamDevAuthSetFault @452
	XamGetDefaultSystemImage @453
	XamGetWCNConfigFile @454
	XamSetPowerMode @455
	XamExecuteChallenge @456
	XamGetDefaultImage @457
	XamMuteSound @458
	XamGetOnlineSchema @459
	XamSetDashContext @460
	XamGetDashContext @461
	XamIsCurrentTitleDash @462
	XamGetCurrentTitleId @463
	XamSetCurrentTitleDash @464
	XamAllocHeapFreeSpace @465
	XamSetDashContextEx @466
	XamGetDashContextEx @467
	XamSetHudContext @468
	XamGetHudContext @469
	XCustomSetAction @472
	XCustomGetLastActionPress @473
	XCustomSetDynamicActions @474
	XCustomBroadcastActionEvent @475
	XCustomGetLastActionPressEx @476
	XCustomRegisterDynamicActions @477
	XCustomUnregisterDynamicActions @478
	XCustomGetCurrentGamercard @479
	XamDbgPrint @480
	XamDbgSetOutputLevel @481
	XamDbgSetBreakLevel @482
	XamLoaderGetMediaInfoEx @483
	XamLoaderSetGameInfo @484
	XamFormatMessage @485
	XamUniSortCmpString @486
	XamFormatTimeString @487
	XamFormatDateString @488
	XamGetLocaleDateFormat @489
	XamAlloc @490
	XamAllocEx @491
	XamFree @492
	XamAllocSize @493
	XamAllocFreeIPTVHeap @496
	XamDeviceRemap @497
	XamLoaderGetClearCache @498
	XamLoaderSetClearCache @499
;	XMsgInProcessCall @500
;	XMsgCompleteIORequest @501
;	XMsgSystemProcessCall @502
;	XMsgStartIORequest @503
;	XMsgCancelIORequest @504
	XMsgAcquireAsyncMessageFromOverlapped @505
	XMsgReleaseAsyncMessageToOverlapped @506
	XamGetOverlappedResult @507
	XMsgStartIORequestEx @508
	XamAppAllocateInterappWorkspace @509
	XamAppGetInterappWorkspace @510
	XamAppFreeInterappWorkspace @511
	XamFeatureEnabled @512
	XamFeatureEnforceImageBudget @513
	XamFeatureSetMask @514
	XamFeatureEnableDisable @515
	XuiControlSetItemAssociation @516
	XamGetTitleGlobalStorageValue @517
	XamSetTitleGlobalStorageValue @518
	XamUserValidateAvatarMetadata @519
	XamUserGetDeviceContext @520
	XamUserLookupDevice @521
	XamUserGetXUID @522
	XamUserLogon @523
	XamUserGetGamerTag @524
	XamUserGetUserIndexMask @525
;	XamUserGetName @526
	XamLookupCommonStringByIndex @527
;	XamUserGetSigninState @528
	XamUserGetIndexFromXUID @529
	XamUserCheckPrivilege @530
	XamUserAreUsersFriends @531
	XamSetUserPresetPresenceState @532
	XamGetUserPresetPresenceState @533
	XamUserGetUserFlagsFromXUID @534
	XamUserGetMembershipTypeFromXUID @535
	XamUserGetOnlineCountryFromXUID @536
	XamUserReadProfileSettings @537
	XamUserWriteProfileSettings @538
	XamUserGetMembershipType @539
	XamUserGetUserFlags @540
	XamUserGetRequestedUserIndexMask @541
	XamUserIsGuest @542
	XamUserProfileSync @543
	XamUserFlushLogonQueue @544
	XamUserIsOnlineEnabled @545
	XamUserGetCachedUserFlags @546
	XamAreMixedAccountsSignedIn @547
	XamUserLogonEx @548
	XamSetUserShowMessengerFriends @549
	XamGetUserShowMessengerFriends @550
	XamUserGetSigninInfo @551
	XamUserIsPartial @552
	XamUserGetOnlineLanguageFromXUID @553
	XamUserReadProfileSettingsEx @554
	XamSystemUpdaterLogon @555
;	XamUserGetUsersMissingAvatars @556
	XamIsChildAccountSignedIn @557
	XamUserPrefetchProfileSettings @558
	XamUserInvalidateProfileSetting @559
	XamProfileCreate @560
	XamProfileCreateEnumerator @561
	XamProfileEnumerate @562
	XamProfileDelete @563
	XamProfileGetCreationStatus @564
	XamProfileFindAccount @565
	XamProfileRenameAccount @566
	XamProfileOpen @567
	XamProfileClose @568
	XamProfileSaveAccountInfo @569
	XamProfileLoadAccountInfo @570
	XamProfileRecoverTitle @571
	XamProfileSaveWindowsLiveCredentials @572
	XamProfileLoadWindowsLiveCredentials @573
	XamProfileIsSaveWindowsLiveCredsEnabled @574
	XamProfileSetSaveWindowsLiveCredsEnabled @575
	XamSetProfileReadTestHook @576
	XamProfileGetLastSync @577
	XamAccountRecoveryRecoverTitle @578
	XamProfileControlXgi @579
	XamAppLoad @580
	XamAppUnloadSelf @581
	XamAppUnloadStack @582
	XamSendMessageToLoadedApps @583
	XamAppRequestLoad @584
	XamAppUnrequestLoad @585
	XamNavigate @586
	XamRegisterSysApp @587
	XamUnregisterSysApp @588
;	XamCreateEnumeratorHandle @590
;	XamGetPrivateEnumStructureFromHandle @591
	XamEnumerate @592
	XamLoadSysApp @593
	XamUnloadSysApp @594
	XamReloadSysApp @595
	XamAppLoadPass2SysApps @596
	XamProfileGetLiveLegalLocale @597
	XamUserIsParentalControlled @598
	XamContentLaunchImageFromFileInternal @599
	XamContentCreate @600
	XamContentCreateEx @601
	XamContentClose @602
	XamContentDelete @603
	XamContentCreateEnumerator @604
	XamContentCreateDeviceEnumerator @605
	XamContentGetDeviceData @606
	XamContentGetDeviceName @607
	XamContentSetThumbnail @608
	XamContentGetThumbnail @609
	XamContentGetCreator @610
	XamContentLaunchImage @611
	XamContentGetAttributes @612
	XamContentGetDeviceState @613
	XamContentGetLicenseMask @614
	XamContentFlush @615
	XamContentResolve @616
	XamContentOpenFile @617
	XamContentInstall @618
	XamContentLockUnlockPackageHeaders @619
	XamContentCopyInternal @620
	XamContentMoveInternal @621
	XamContentGetMetaDataInternal @622
	XamContentCreateEnumeratorInternal @623
	XamContentDeleteInternal @624
	XamContentCreateInternal @625
	XamContentSetThumbnailInternal @626
	XamContentLaunchImageInternal @627
	XamContentWritePackageHeader @628
	XamContentDismountAndClosePackage @629
	XamContentResolveInternal @630
	XamContentGetAttributesInternal @631
	XamContentOpenFileInternal @632
	XamContentAggregateCreateEnumerator @633
	XamContentCreateAndMountPackage @634
	XamContentOpenPackageFile @635
	XamContentMountPackage @636
	XamContentFlushPackage @637
	XamContentClosePackageFile @638
	XamContentDuplicateFileHandle @639
	XamGetExecutionId @640
	XamGetGameRatings @641
	XamGetSystemVersion @642
	XamContentGetLocalizedString @643
	XamContentGetDefaultDevice @644
	XamContentInstallInternal @645
	XamContentSetMediaMetaDataInternal @646
	XamContentGetDeviceSerialNumber @647
	XamContentGetMountedPackageByRootName @648
	XamContentRegisterChangeCallback @649
	XamNotifyCreateListener @650
;	XNotifyGetNext @651
;	XNotifyPositionUI @652
;	XNotifyDelayUI @653
	XNotifyBroadcast @654
	XNotifyRegisterArea @655
	XNotifyQueueUI @656
	XamNotifyCreateListenerInternal @657
	XNotifyUISetOptions @658
	XNotifyUIGetOptions @659
	XamContentLaunchImageInternalEx @660
	XamShutdown @661
	XamAllocDevkitHeapAvailable @662
	XamNotifyCreateListenerRangeInternal @663
	XNotifyQueueUIEx @664
	XamAppRequestLoadEx @665
	XuiPNGTextureLoader @666
	XuiRenderGetXuiDevice @667
	XuiDefault_False @668
	XamUserGetReportingInfo @669
	XamUpdateStart @670
	XamUpdateGetProgress @671
	XamUpdateFinish @673
	XamUpdateAttachExtenderInstance @674
	XamUpdateGetBaseSystemVersion @678
	XamUpdateGetCurrentSystemVersion @679
	XamUpdateChainPass3FromPass2 @683
	XamInputGetCapabilitiesEx @685
	XamUserIsUnsafeProgrammingAllowed @686
	XamDevAuthSetFaultEx @687
	XamUpdateGetData @688
	XamCacheIntegrityCheck @689
	XamCacheStoreFile @690
	XamCacheFetchFile @691
	XamCacheOpenFile @692
	XamCacheCloseFile @693
	XamGetCachedTitleName @694
	XamCacheReset @695
	XamGetCachedGamerTag @696
	XamGetCachedGamerTagW @697
	XamCacheDeleteFile @698
	XamCacheRenameFile @699
	XamShowSigninUI @700
	XamShowSigninUIEx @701
	XamShowSigninUIp @702
	XamShowFriendsUI @703
	XamShowMessagesUI @704
	XamShowKeyboardUI @705
	XamShowQuickChatUI @706
	XamShowVoiceMailUI @707
	XamShowGamerCardUI @708
	XamShowAchievementsUI @709
	XamShowPlayerReviewUI @710
	XamShowMarketplaceUI @711
	XamShowPlayersUI @712
	XamShowUpdaterUI @713
	XamShowMessageBoxUI @714
	XamShowDeviceSelectorUI @715
	XamShowMessageComposeUI @716
	XamShowGameInviteUI @717
	XamShowFriendRequestUI @718
	XamShowCreateProfileUI @719
	XamShowGamesUI @720
	XamShowLiveSignupUI @721
	XamShowFriendsUIp @722
	XamShowComplaintUI @723
	XamShowReputationUI @724
	XamShowGamerCardUIForXUID @725
	XamShowForcedNameChangeUI @726
	XamShowLiveUpsellUI @727
	XamShowPasscodeVerifyUI @728
	XamShowDirtyDiscErrorUI @729
	XamShowSignupCreditCardUI @730
	XamShowPrivateChatInviteUI @731
	XamShowMessageBoxUIEx @732
	XamShowRecentMessageUI @733
	XamShowRecentMessageUIEx @734
	XamShowMessagesUIEx @735
	XamShowAchievementDetailsUI @736
	XamShowPersonalizationUI @737
	XamShowChangeGamerTileUI @738
	XamShowVoiceSettingsUI @739
	XamShowVideoChatInviteUI @740
	XamShowCustomMessageComposeUI @741
	XamShowCustomPlayerListUI @742
	XamShowMarketplaceDownloadItemsUI @743
	XamShowMarketplaceUIEx @744
	XamShowMessageBox @745
	XamIsSysUiInvokedByXenonButton @746
	XamIsSysUiInvokedByTitle @747
	XamIsUIActive @748
	XamSysUiDisableAutoClose @749
	XamUserCreateAchievementEnumerator @750
	XamReadTile @751
	XamWriteGamerTile @752
	XamWriteTile @753
	XamReadImage @754
	XamUserCreateTitlesPlayedEnumerator @755
	XamDecompressPNGToTexture @756
	XamReadTileToTexture @757
	XamReadString @758
	XamUserCreateStatsEnumerator @759
	XamPrepareGamerTiles @760
	XamClearTitle @761
	XamReadStrings @762
	XamWriteGamerTileEx @763
	XamReadTileEx @764
	XamReadTileToTextureEx @765
	XamShowMessengerUI @766
	XamShowKeyboardUIMessenger @767
	XamShowLiveUpsellUIEx @768
	XamShowJoinSessionInProgressUI @769
	XamShowGraduateUserUI @770
	XamShowGamerCardUIForXUIDp @771
	XamShowGuideUI @772
	XamShowPartyUI @773
	XamShowPartyInviteUI @774
	XamUserAddRecentPlayer @775
	XamUserUpdateRecentPlayer @776
	XamUserCreatePlayerEnumerator @777
	XamParseGamerTileKey @778
	XamShowCommunitySessionsUI @779
	XamVoiceCreate @780
	XamVoiceHeadsetPresent @781
	XamVoiceSubmitPacket @782
	XamVoiceClose @783
	XamVoiceGetBatteryStatus @784
	XamShowJoinSessionByIdInProgressUI @787
	XamShowPartyJoinInProgressUI @788
	XamBuildSharedSystemResourceLocator @789
	XamSessionCreateHandle @790
	XamSessionRefObjByHandle @791
	XamVoiceGetMicArrayStatus @792
	XamVoiceSetAudioCaptureRoutine @793
	XamVoiceGetDirectionalData @794
	XamBuildResourceLocator @795
	XamBuildLegacySystemResourceLocator @796
	XamBuildGamercardResourceLocator @797
	XamBuildDynamicResourceLocator @798
	XamBuildXamResourceLocator @799
	XuiAnimRun @800
	XuiApplyLocale @801
	XuiBubbleMessage @802
	XuiControlIsBackButton @803
	XuiControlIsNavButton @804
	XuiCreateObject @805
	XuiDestroyObject @806
	XuiDynamicCast @807
	XuiElementAddChild @808
	XuiElementFindNamedFrame @809
	XuiElementGetChildById @810
	XuiElementGetFirstChild @811
	XuiElementGetFocus @812
	XuiElementGetFocusUser @813
	XuiElementGetId @814
	XuiElementGetLastChild @815
	XuiElementGetNext @816
	XuiElementGetParent @817
	XuiElementGetUserFocus @818
	XuiElementInitFocus @819
	XuiElementInitUserFocus @820
	XuiElementPlayTimeline @821
	XuiElementSetBounds @822
	XuiElementSetFocus @823
	XuiElementSetUserFocus @824
	XuiElementTreeGetFocus @825
	XuiFindClass @826
	XuiFreeStringTable @827
	XuiGetBaseObject @828
	XuiGetClass @829
	XuiGetObjectClass @830
	XuiGetOuter @831
	XuiInit @832
	XuiLoadFromBinary @833
	XuiLoadStringTableFromFile @834
	XuiVisualGetBasePath @835
	XuiLookupStringTable @836
	XuiNavButtonGetPressPath @837
	XuiObjectFromHandle @838
	XuiObjectGetProperty @839
	XuiObjectGetPropertyId @840
	XuiProcessInput @841
	XuiRegisterClass @842
	XuiRenderBegin @843
	XuiRenderCreateDC @844
	XuiRenderDCDeviceChanged @845
	XuiRenderDestroyDC @846
	XuiRenderEnd @847
	XuiRenderGetBackBufferSize @848
	XuiRenderInit @849
	XuiRenderInitShared @850
	XuiRenderPresent @851
	XuiRenderSetViewTransform @852
	XuiRenderUninit @853
	XamShowNuiGuideUI @854
	XuiSceneCreate @855
	XuiSceneNavigateBack @856
	XuiSceneNavigateFirst @857
	XuiSceneNavigateForward @858
	XuiScenePlayBackFromTransition @859
	XuiScenePlayBackToTransition @860
	XuiScenePlayFromTransition @861
	XuiScenePlayToTransition @862
	XuiSendMessage @863
	XuiSetLocale @864
	XuiUninit @865
	XuiUnregisterClass @866
	XuiTextElementSetText @867
	XuiSetTimer @868
	XuiTimersRun @869
	XuiTextElementGetText @870
	XuiVisualSetBasePath @871
	XuiHandleIsValid @872
	XuiAlloc @873
	XuiFree @874
	XuiDefault_True @875
	XuiDefault_EmptyString @876
	XuiDefault_IntegerZero @877
	XuiCopyString @878
	XuiRealloc @879
	XuiControlPlayOptionalVisual @880
	XuiKillTimer @881
	XuiElementEnableInput @882
	XuiElementInputEnabled @883
	XuiIsInstanceOf @884
	XuiResourceComposeLocator @885
	XuiResourceLocatorIsAbsolute @886
	XuiBroadcastMessage @887
	XuiElementDisallowRecursiveTimelineControl @888
	XUIElementPropVal_Construct @889
	XUIElementPropVal_Destruct @890
	XUIElementPropVal_SetString @891
	XuiObjectSetProperty @892
	XuiElementGetOpacity @893
	XuiElementSetOpacity @894
	XuiEditSetTextLimit @895
	XuiEditGetTextLimit @896
	XuiSliderSetValue @897
	XuiSliderGetValue @898
	XuiSliderSetRange @899
	XuiElementUnlink @900
	XuiElementInsertChild @901
	XuiSceneNavigateBackToFirst @902
	XuiProgressBarSetRange @903
	XuiProgressBarSetValue @904
	XuiProgressBarGetValue @905
	XuiControlAttachVisual @906
	XuiCreateTextureBrush @907
	XuiDestroyBrush @908
	XUIElementPropVal_SetColorFromUint @909
	XuiFigureSetFill @910
	XuiSliderGetRange @911
	XuiFigureSetTexture @912
	XuiControlGetItemAssociation @913
	XuiResourceLoadAll @914
	XuiImageElementSetImagePath @915
	XuiImageElementGetImagePath @916
	XuiControlGetVisual @917
	XuiControlGetNavigation @918
	XuiLookupStringTableByIndex @919
	XUIElementPropVal_SetBool @920
	XuiElementHasFocus @921
	XUIElementPropVal_SetUint @922
	XUIElementPropVal_Clear @923
	XuiEditSetTextFormatInfo @924
	XuiCreateSolidBrush @925
	XuiSceneInterruptTransitions @926
	XuiResourceOpen @927
	XuiResourceRead @928
	XuiResourceClose @929
	XuiVisualCreateInstance @930
	XuiElementGetTimeline @931
	XuiElementIsDescendant @933
	XuiSetMessageFilter @934
	XuiAttachTextureBrush @935
	XuiElementBeginRender @936
	XuiElementEndRender @937
	XuiDrawShape @938
	XuiSelectBrushEx @939
	XuiFigureGetShape @940
	XuiFillRect @941
	XuiVec2TransformCoord @942
	XuiMatrixMultiply @943
	XuiElementGetXForm @944
	XuiElementSetPosition @945
	XuiSelectBrush @946
	XuiElementRenderChildren @947
	XuiFreeUnusedTextures @948
	XuiListEnableItemOverride @949
	XuiListGetDefaultItemSize @950
	XuiResourceSeek @951
	XuiElementDiscardResources @952
	XuiTabSceneGoto @953
	XuiTabSceneGetCurrentTab @954
	XamShowWhatsOnUI @955
	XamShowEditProfileUI @956
	XamShowStorePickerUI @957
	XamShowTermsOfUseUI @958
	XamShowJoinPartyUI @959
	XamShowWordRegisterUI @960
	XamOverrideHudOpenType @961
	XamShowAchievementsUIEx @962
	XamUserGetUserTenure @963
	XamUserGetSubscriptionType @964
	XamShowGameVoiceChannelUI @965
	XamShowAvatarAwardsUI @966
	XamShowAvatarAwardGamesUI @967
	XamShowVideoRichPresenceUI @968
	XamHudGetUserIndex @969
	XGetAudioFlags @970
	XGetAVPack @971
	XGetGameRegion @972
	XGetLanguage @973
	XapipGetLocale @974
	XGetVideoFlags @975
	XGetVideoStandard @976
	XGetVideoMode @977
	XamGetLanguage @978
	XUITimeline_Run @979
	XamSetAutomation @980
	XAutomationpBindController @981
	XAutomationpUnbindController @982
	XAutomationpInputXenonButton @983
	XAutomationpInputPress @984
	XAutomationpInputSetState @985
	XamEnableOverdraw @986
	g_XuiAutomation @987
	XamVoiceGetMicArrayAudio @988
	XampSystemInput @989
	XamInputControl @990
	XuiElementGetPosition @991
	XamIsMessageBoxActive @992
	XamIsBackgroundSceneInTransition @993
	XuiElementTreeHasFocus @994
	XuiFigureClose @995
	GamerCardStartup @996
	GamerCardCleanup @997
	GamerCardRegisterControls @998
	GamerCardUnregisterControls @999
	RtlFindFirstFile @1000
	RtlFindNextFile @1001
	RtlGetModuleFileName @1002
;	RtlOutputDebugString @1003
	RtlRemoveDirectory @1004
	RtlSleep @1005
	RtlGetLastError @1006
	RtlSetLastError @1007
	RtlSetLastNTError @1008
	RtlDebugPrint @1009
	RtlDebugError @1010
	RtlDebugTrace @1012
	RtlDebugEntry @1013
	RtlDebugExit @1014
	RtlGetAttributesOnHeapAlloc @1015
	RtlSetAttributesOnHeapAlloc @1016
	XuiFigureSetShape @1017
	RtlCreateHeap @1018
	RtlDestroyHeap @1019
;	RtlAllocateHeap @1020
	RtlAllocateHeapSlowly @1021
;	RtlReAllocateHeap @1022
;	RtlFreeHeap @1023
	RtlFreeHeapSlowly @1024
;	RtlSizeHeap @1025
	RtlZeroHeap @1026
	RtlDebugWalkHeap @1027
	RtlWalkHeap @1028
	RtlLockHeap @1029
	RtlUnlockHeap @1030
;	RtlValidateHeap @1031
	RtlDebugCompactHeap @1032
	RtlCompactHeap @1033
	XamAppSetTestOption @1034
	XamAppReportError @1035
	XamIsNuiUIActive @1036
	XamVerifyPasscode @1037
	OutputDebugStringA @1038
	DebugBreak @1039
	GetCurrentThreadId @1040
	XDebugError @1041
	RtlDebugSetLevel @1043
	CloseHandle @1044
	GetTickCount @1045
	GetLastError @1046
	SetFilePointer @1047
	SetFilePointerEx @1048
	SetLastError @1049
	MultiByteToWideChar @1050
	WideCharToMultiByte @1051
	ReadFile @1052
	FlushFileBuffers @1053
	WriteFile @1054
	OutputDebugStringW @1055
	SetEvent @1056
	XapiFormatTimeOut @1057
	CreateMutexA @1058
	OpenMutexA @1059
	ReleaseMutex @1060
	WaitForSingleObject @1061
	WaitForSingleObjectEx @1062
	GetFileSize @1063
	GetFileSizeEx @1064
	XapiDirectoryInformationToFindData @1065
	XapiFormatObjectAttributes @1066
	ResetEvent @1067
	wsprintfA @1068
	wsprintfW @1069
	GetOverlappedResult @1070
	QueryPerformanceCounter @1071
	QueryPerformanceFrequency @1072
	LocalAlloc @1073
	LocalFree @1074
	RaiseException @1075
	RtlUniform @1076
	RtlRandom @1077
	Sleep @1078
	SleepEx @1079
	XMemSet @1080
	XRegisterThreadNotifyRoutine @1081
	XGetOverlappedExtendedError @1082
	XGetOverlappedResult @1083
	CreateThread @1084
	ResumeThread @1085
	ExitThread @1086
	GetTimeZoneInformation @1087
	GetSystemTimeAsFileTime @1088
	SystemTimeToFileTime @1089
	FileTimeToSystemTime @1090
	GetSystemTime @1091
	GetLocalTime @1092
	CreateDirectoryA @1093
	CreateEventA @1094
	CreateFileA @1095
	DeleteFileA @1096
	FindFirstFileA @1097
	FindNextFileA @1098
	GetFileAttributesA @1099
	XamLoaderGetCurrentTitleD3DVersion @1100
	GetFileAttributesExA @1101
	GetModuleHandleA @1102
	GetDiskFreeSpaceExA @1103
	CopyFileA @1104
	SetEndOfFile @1105
	XamFamilyAddParentalExemptionToList @1106
	XamFamilyIsParentalValidationRequired @1107
;	PIXAddCounter @1110
	SetWaitableTimer @1112
	CancelWaitableTimer @1113
	CreateWaitableTimerA @1114
	DuplicateHandle @1115
	XapipCreateThread @1116
	lstrcpyA @1117
	lstrcpyW @1118
	lstrcpynA @1119
	lstrcpynW @1120
	lstrcatA @1121
	lstrcatW @1122
	lstrlenA @1123
	lstrlenW @1124
	IsBadReadPtr @1125
	IsBadWritePtr @1126
	FileTimeToLocalFileTime @1127
	XMemCpy @1128
	XMemCpyStreaming @1129
	XamHudSetUserIndex @1130
	XamShowNuiTroubleshooterUI @1131
	XamTestShowNuiTroubleshooterUI @1132
	XamShowPasscodeVerifyUIEx @1133
	XamShowNuiAchievementsUI @1134
	XamShowNuiCommunitySessionsUI @1135
	XamShowNuiDeviceSelectorUI @1136
	XamShowNuiDirtyDiscErrorUI @1137
	XamShowNuiFriendsUI @1138
	XamShowNuiGameInviteUI @1139
	XamShowNuiGamerCardUIForXUID @1140
	XamShowNuiMarketplaceDownloadItemsUI @1141
	XamShowNuiMarketplaceUI @1142
	XamShowNuiMessageBoxUI @1143
	XamShowNuiPartyUI @1144
	XamShowNuiFriendRequestUI @1145
	XamShowNuiSigninUI @1146
	XamShowNuiControllerRequiredUI @1147
	XamShowNuiGamesUI @1148
	XamShowNuiHardwareRequiredUI @1149
	XamCacheStoreFileByString @1150
	XamCacheFetchFileByString @1151
	XamCacheDeleteFileByString @1152
	XamGetCachedTitleNameEx @1153
	XamXlfsInitializeUploadQueue @1154
	XamXlfsUninitializeUploadQueue @1155
	XamXlfsMountUploadQueueInstance @1156
	XamXlfsUnmountUploadQueueInstance @1157
	XamVoiceRecordUserPrivileges @1158
	XamXlfsInitializeUploadQueueWithTestHooks @1159
	XamXlfsNotifyContentDeletion @1160
;	XMemAlloc @1161
;	XMemFree @1162
;	XMemSize @1163
	XamVoiceSetMicArrayIdleUsers @1164
	XamVoiceMuteMicArray @1165
	XamVoiceGetMicArrayUnderrunStatus @1166
	XuiSceneEnableTransitionDependency @1167
	XamVoiceGetMicArrayAudioEx @1168
	XamShowLeaveFamilyUI @1169
	XamUserGetDeviceId @1170
	XamUpdateEtxLogUpdateTaskStart @1171
	XamUpdateEtxLogUpdateTaskSuccess @1172
	XamUpdateEtxLogUpdateTaskFailure @1173
	XamEtxFlushLogs @1174
	XamVoiceIsActiveProcess @1175
	XamInactivityGetInactivityInterruptTime @1176
	XamInactivitySetInactivityInterruptTime @1177
	XamInactivityGetLastActivityTime @1178
	XamInactivitySetDetectionTaskPeriod @1179
	XamInactivityEnablePowerDown @1180
	XamUpdateGetChainMarker @1181
	XGetVideoCapabilities @1182
;	XMsgProcessRequest @1183
	XGetDisplaySize @1184
	XamInputNonControllerGetRaw @1185
	XamInputNonControllerSetRaw @1186
	XamVoiceSetMicArrayBeamAngle @1187
	XamUserGetAge @1188
	XamUserGetAgeGroup @1189
	XamVoiceGetMicArrayFilenameDesc @1190
	XamLoaderGetState @1191
	XamTaskQueryProperty @1192
	XamGetLocale @1193
	XamQueryTimeZoneInformation @1194
	XamSetTimeZoneInformation @1195
	XamLaunchURI @1196
	XamShowNuiMessagesUI @1199
	XMPRegisterCodec @1200
	XamNavigateBack @1201
	XamPushBackURI @1202
	XamUserOverrideDeviceBindings @1203
	XamUserOverrideBindingCallbacks @1204
	XamUserOverrideUserInfo @1205
	XamUserContentRestrictionGetFlags @1206
	XamUserContentRestrictionGetRating @1207
	XamUserContentRestrictionCheckAccess @1208
	XamFamilyGetMembers @1211
	XampXAuthStartup @1212
	XampXAuthShutdown @1213
	XamGetToken @1214
	XamFreeToken @1215
	XamGetAppliesTo @1216
	XamLrcGetInput @1223
	XamLrcGetInputWithSeek @1224
	XamLrcSetMediaState @1225
	XamPixSetDirtyCounters @1226
	XamRequestToken @1229
	XamResolveURI @1230
	XamContentGetOnlineCreator @1231
	XamShowBrandedKeyboardUI @1232
	XamBackgroundDownloadNetworkStorageEnable @1233
	XamBackgroundDownloadNetworkStorageIsEnabled @1234
	XamShowNuiJoinSessionInProgressUI @1235
	XamBase64Decode @1236
	XamCertDecode @1237
	XamCertDecodeRsaPublicKey @1238
	XamCertValidateStruct @1239
	XamBackgroundDownloadNetworkStorageOnContentChange @1247
	InjectConnectionServerNotification @1249
	XamGetGamerTileKeyFromGamertag @1251
	XamBackgroundDownloadNetworkStorageRegisterChangeCallback @1252
	XamFindOrCreateInternalPassportAccount @1253
	XOnlinepFriendsRequest @1254
	XOnlinepFriendsAcceptRequest @1255
	XOnlinepFriendsRejectRequest @1256
	XOnlinepFriendsRemove @1257
	XFriendsCreateEnumerator @1258
	XamBackgroundDownloadNetworkStorageIsRunning @1259
	XamCertGetSerialNumber @1260
	XamShowOptionsUI @1261
	XampXAuthGetTitleBuffer @1262
	XamGetSTSTokenCache @1263
	XamUserGetOnlineXUIDFromOfflineXUID @1264
	XamShowNuiVideoRichPresenceUI @1266
	XamAppAllocateInterappWorkspaceEx @1267
	XamNetworkStatusGetInformation @1269
	XamNetworkStatusAddAddress @1270
	XamUserReadUserPreference @1271
	XamUserWriteUserPreference @1272
	XamWaitForNSAL @1276
	XamMarkInternalAccountTrustedOnConsole @1277
	XamBackgroundDownloadNetworkStorageGetProgress @1278
	XamCopyFile @1279
	XamMoveFile @1280
	XamDeleteFile @1281
	XamIsCurrentTitleIptv @1300
	XamIsIptvEnabled @1301
	XamIsDvrRecording @1302
	XamIptvUninstall @1303
	XamGetDvrStorage @1304
	XamSetDvrStorage @1305
	XamIptvGetServiceName @1306
	XamNuiHudGetEngagedEnrollmentIndex @1307
	XamProfileSetCachedWindowsLiveEmail @1308
	XamProfileGetCachedWindowsLiveEmail @1309
	XamUserResetSubscriptionType @1310
	XamReminderGetItems @1400
	XamReminderClearItems @1401
	XamReminderItemAdd @1402
	XamReminderItemRemove @1403
	XamReminderGetNextItem @1404
	XamReminderGetModifiedTime @1405
	XamReminderClearCache @1406
	XamAvatarInitialize @1500
	XamAvatarShutdown @1501
	XamAvatarGetMetadataLocalUser @1502
	XamAvatarGetMetadataByXuid @1503
	XamAvatarGetAssetsResultSize @1504
	XamAvatarGetAssets @1505
	XamAvatarGenerateMipMaps @1506
	XamAvatarSetCustomAsset @1507
	XamAvatarSetMetadata @1508
	XamAvatarLoadAnimation @1511
	XamAvatarBeginEnumAssets @1512
	XamAvatarEndEnumAssets @1513
	XamAvatarEnumAssets @1514
	XamAvatarGetMetadataRandom @1515
	XamAvatarGetMetadataSignedOutProfileCount @1518
	XamAvatarGetMetadataSignedOutProfile @1519
	XamAvatarMetadataGetBodyType @1521
	XamAvatarGetInstrumentation @1522
	XamAvatarGetAssetIcon @1523
	XamAvatarWearNow @1524
	XamAvatarGetAssetBinary @1525
	XamLoaderGetSuspendedTitleInfo @1526
	XamAvatarGetInstalledAssetPackageDescription @1527
	XamAvatarSetAdapters @1528
	XamContentMountInstalledGame @1550
	XamContentIsGameInstalledToHDD @1551
	XamContentQueryLicenseInternal @1552
	XamContentGetDeviceVolumePath @1553
	XamContentDeviceCheckUpdates @1554
	XamContentGetHeaderInternal @1555
	XamNetworkStorageGetNetworkDevice @1556
	XamNetworkStorageDeviceHasCacheFile @1557
	XamNetworkStorageCreateCacheOnDevice @1558
	XamNetworkStorageDeleteCacheOnDevice @1559
	XamNetworkStorageGetStatus @1560
	XamNetworkStorageIsSupportedContentType @1561
	XamNetworkStorageSetTestMock @1562
	XamNetworkStorageGetLastSyncTime @1563
	XamShowNetworkStorageSyncUI @1564
	XamUserIsLogonPreviewModeEnabled @1565
	XamUserLockLogonPreviewMode @1566
	XamUserUnlockLogonPreviewMode @1567
	XamNetworkStorageIsUserInSync @1568
	XamNetworkStorageSetUserInSync @1569
	XamNetworkStorageOnSigninChanged @1570
	XamNetworkStorageSignInTestMock @1571
	XamShowFofUI @1572
	CompareFileTime @1573
	SetFileTime @1574
	XamNetworkStorageGetTitleProperties @1575
	XamNetworkStorageLockFile @1576
	XamNetworkStorageUserHasPrivilege @1577
	XamNetworkStorageIsTitleExempt @1578
	XamContentExistsOnDeviceInternal @1579
	XamNetworkStorageGetBackingDevice @1580
	XamNetworkStorageIsEnabledInLiveHive @1581
	XamNetworkStorageIsCheckingSyncStates @1582
	XamNetworkStorageUserNeedsToSync @1583
	XamNetworkStorageGetUserNetworkSyncTime @1584
	XamNetworkStorageGetUserProperties @1585
	XamNetworkStorageAppLauncherLaunchIfRunning @1586
	XamNetworkStorageSetTitleProperties @1587
	XamNetworkStorageGetUserLastError @1588
	XamNetworkStorageCheckOutTitle @1589
	XamNetworkStorageShouldHideFromTitle @1590
	XamNetworkStorageOnUserSyncChange @1591
	XamNetworkStorageHasUserEnabledStorage @1592
	XamContentGetLocalizedDeviceData @1593
	XamPackageManagerFindPackageContainingIndexedXEX @1600
	XamPackageManagerReinitialize @1601
	XamPackageManagerGetAuthoritativeManifestRevision @1602
	XamGetCurrentSystemOnlineManifestRevision @1603
	XamPackageManagerDeleteExtendedPartition @1604
	XamPackageManagerHasExtendedPartition @1605
	XamPackageManagerGetExperienceMode @1606
	XamPackageManagerGetFeatureRequiresUpdateStrings @1607
	XamPackageManagerGetFileSize @1608
	XampDemandUpdateGetAttributes @1609
	XampDemandUpdateGetExtendedAttributes @1610
	XampDemandUpdateGetInstance @1611
	XampDemandUpdateSetRefreshTestFlags @1612
	XampDemandUpdateIsRefreshTestFlagSet @1613
	XampDemandUpdateGetManifestLocalPath @1614
	XampDemandUpdateRefreshManifest @1615
	XdfInitialize @1616
	XdfShutdown @1617
	XdfGetExpectedDownloadSize @1618
	XdfGetItem @1619
	XdfCacheItem @1620
	XdfLoadXexFromCache @1621
	XdfLoadXex @1622
	XdfCancelRequest @1623
	XdfResumeDelayedItem @1624
	XdfLaunchNewImageFromCache @1625
	XampDemandUpdateRefreshManifestDuringLogon @1626
	XampDemandUpdateCheckOnlineManifestChanged @1627
	XampDemandUpdateRunCacheCleaner @1628
	XamXStudioRequest @1670
	XamNotifyDelayUIInternal @1671
	XamShowAvatarMiniCreatorUI @1700
	XamShowGoldUpgradeUI @1701
	XamResumeUpdaterUI @1702
	XamShowDirectAcquireUI @1703
	XamShowPaymentOptionsUI @1704
	XamGetLiveHiveValueA @1800
	XamGetLiveHiveValueW @1801
	XamGetLiveHiveValueDuringLogonAttemptA @1802
	XamSetUserPresetWindowsLiveCreds @1803
	XamQueryLiveHiveA @1804
	XamQueryLiveHiveW @1805
	XamSetStagingMode @1902
	XamGetStagingMode @1903
	XamAppGetSessionId @1904
	XamAccountRecoveryRecoverAllProfileData @1905
	XamAccountRecoveryGetProgress @1906
	XamDoesOmniNeedConfiguration @2000
	GetProcessHeap @2002
	UnhandledExceptionFilter @2003
	SetUnhandledExceptionFilter @2004
	XamIsOptionalMediaUpdateInstalled @2005
	XamShowOptionalMediaUpdateRequiredUI @2006
	XamShowOptionalMediaUpdateRequiredUIEx @2007
	XamTaskCreateQueueEx @2009
	XamSetTextureLoaderHook @2010
	XamLaunchAvatarEditor @2011
	XamLoadExtraAVCodecs @2012
	XamUnloadExtraAVCodecs @2013
	XamSetLastActiveUserData @2014
	XamGetLastActiveUserData @2015
	XamSetActiveDashAppInfo @2016
	XamGetActiveDashAppInfo @2017
	XamUserCreateAvatarAssetEnumerator @2050
	XamInitializeGameTileCache @2051
	XamDestroyGameTileCache @2052
	XamReadGameTileImage @2053
	XamShouldThrottleAccountInfoCall @2054
	XuiClassDerivesFrom @2055
	XuiFreeVisuals @2056
	XuiGetBaseClass @2057
	XuiLoadVisualFromBinary @2058
	XuiResourceGetBuffer @2059
	XuiResourceGetTotalSize @2060
	XuiElementGetUserData @2061
	XuiElementSetUserData @2062
	XuiTabSceneGetCount @2063
	XuiSliderGetStep @2064
	XuiSliderSetStep @2065
	XuiProgressBarGetRange @2066
	XuiElementSetHittable @2067
	XuiElementPlayNamedFrames @2068
	XuiElementGetPivot @2069
	XuiElementGetPrev @2070
	XuiElementGetScale @2071
	XuiElementSetPivot @2072
	XuiElementSetRotation @2073
	XuiElementSetScale @2074
	XuiControlWantsUnfocusedInput @2075
	XuiResourceOpenNoLoc @2076
	XuiResourceReleasePackage @2077
	XuiResourceGetPackageEntryInfo @2078
	XuiResourceGetPackageEntryCount @2079
	XuiResourceOpenPackage @2080
	XamCodeCoverageFileOpen @2081
	XamCodeCoverageFileClose @2082
	XamCodeCoverageFileLseek @2083
	XamCodeCoverageFileRead @2084
	XamCodeCoverageFileWrite @2085
	XampHeapGetInfo @2087
	XampHeapGetCount @2088
	XuiElementLayoutTree @2090
	XamInactivityResetAllState @2091
	XUIElementPropVal_SetInt @2092
	XUIElementPropVal_SetFloat @2093
	XuiObjectGetPropertyDef @2094
	XuiRenderGetDevice @2095
	XuiRenderRestoreState @2096
	XuiElementGetFullXForm @2097
	XuiRenderGetViewTransform @2098
	XuiRenderGetColorSpace @2099
	XamPngEncode @2100
	XamPngDecode @2101
	XamPngEncodeEx @2102
	XuiTextElementMeasureText @2103
	XamLoaderShouldConfirmReboot @2104
	XamLoaderRebootToDash @2105
	XamNuiHudGetEngagedTrackingID @2106
	XamLoaderLaunchTitleForReason @2107
	XamNuiHudSetEngagedTrackingID @2108
	XuiBrushGetTexture @2109
	XuiBrushGetDims @2110
	XuiElementGetDescendantById @2111
	XamLoaderIsKinectUIPreferredForLogonTitle @2112
	XamAccountRecoveryGetSetTitleSyncTime @2120
	XamReadBiometricData @2121
	XamWriteBiometricData @2122
	XamD3DResourceDescriptorCreate @2123
	XamD3DResourceDescriptorAddRef @2124
	XamD3DResourceDescriptorRelease @2125
	XamD3DResourceAddRef @2126
	XamD3DResourceSet @2127
	XamD3DResourceIsBusy @2128
	XamD3DResourceRelease @2129
	ControlPackGetCursorPosition @2130
	ControlPackShouldShowCursor @2131
	XamFlushAgraTemperatureReport @2136
	XamNatalDeviceAudioCalibrate @2137
	XamNuiIdentityGetEnrollmentInfo @2138
	XamNuiIdentityUnenroll @2139
	XamNuiIdentityGetColorTexture @2140
	XamReportKinectSettingsChangedEvent @2141
	XamNuiEnableChatMic @2142
	XamNuiIsChatMicEnabled @2143
	XamNuiGetDepthCalibration @2144
	XamNuiStoreDepthCalibration @2145
	XamUserNuiIsBiometricEnabled @2146
	XamUserNuiEnableBiometric @2147
	XamNuiCameraSetFlags @2148
	XamNuiCameraRememberFloor @2149
	XamUserNuiGetUserIndexForBind @2150
	XamUserNuiGetUserIndexForSignin @2151
	XamUserNuiBind @2152
	XamUserNuiGetUserIndex @2153
	XamUserNuiGetEnrollmentIndex @2154
	XamUserNuiUnbind @2155
	XamNuiUseTemporaryDepthCalibration @2156
	XamNuiCameraTiltSetCallback @2157
	XamNuiHudIsEnabled @2158
	XamNuiCameraGetTiltControllerType @2159
	XamNuiCameraTiltGetStatus @2160
	XamNuiIdentityGetQualityFlags @2161
	XamNuiIdentityEnrollForSignIn @2162
	XamNuiIdentityGetSessionId @2163
	XamNuiIdentityIdentifyWithBiometric @2164
	ControlPackGetHandleManager @2165
	XamEnableNuiAutomation @2166
	XamNuiGetSystemGestureControl @2167
	XamGetPasscodeKeyFromVirtualKey @2168
	XamEnableNatalPlayback @2169
	XamIsNuiAutomationEnabled @2170
	XamIsNatalPlaybackEnabled @2171
	XamNuiHudInterpretFrame @2172
	XamNuiHudEnableInputFilter @2173
	XamUserNuiIsBiometricAugmentRecommended @2174
	XamNuiHudGetInitializeFlags @2175
	XamNuiCameraElevationSetAngle @2176
	XamNuiCameraElevationGetAngle @2177
	XamNuiCameraElevationAutoTilt @2178
	XamNuiCameraElevationStopMovement @2179
	XamNuiCameraElevationSetCallback @2180
	XamNuiGetDeviceStatus @2181
	XamNuiNatalCameraUpdateStarting @2182
	XamNuiNatalCameraUpdateComplete @2183
	XamNuiHudGetVersions @2184
	XamGetHUDElementByPath @2185
	XamGetHUDElementByAutoId @2186
	XuiElementGetScreenPositionCenter @2187
	XamNuiCameraElevationReverseAutoTilt @2188
	ControlPackSimpleCursorGetRayFromScreenPosition @2189
	ControlPackSideNavControlGetNuiHandle @2190
	XamFindHUDElementByXuiId @2191
	XamNuiIsDeviceReady @2192
	XamNuiSetForceDeviceOff @2193
	XamNuiPlayerEngagementUpdate @2194
	XamNuiSkeletonGetBestSkeletonIndex @2195
	XamNuiSkeletonScoreUpdate @2196
	XamNuiCameraTiltReportStatus @2197
	XamNuiCameraAdjustTilt @2198
	XamNuiIdentityAbort @2199
;	D3DDevice_CreateVertexShader @2200
;	D3DDevice_CreatePixelShader @2201
;	D3DDevice_CreateTexture @2202
	D3DDevice_CreateVertexBuffer @2203
	D3DDevice_CreateIndexBuffer @2204
;	D3DDevice_CreateVertexDeclaration @2205
	D3DVertexBuffer_Unlock @2206
	D3DVertexBuffer_Lock @2207
	D3DIndexBuffer_Unlock @2208
	D3DIndexBuffer_Lock @2209
	D3DTexture_UnlockRect @2210
	D3DTexture_LockRect @2211
;	D3DDevice_Clear @2212
	D3DDevice_SetViewport @2213
	D3DDevice_GetViewport @2214
;	D3DDevice_SetRenderState_SrcBlend @2215
;	D3DDevice_SetRenderState_DestBlend @2216
;	D3DResource_Release @2218
;	D3DDevice_Release @2219
;	D3DDevice_SetVertexShader @2220
;	D3DDevice_SetPixelShader @2221
;	D3DDevice_SetTexture @2222
;	D3DDevice_SetVertexDeclaration @2223
	D3DDevice_SetIndices @2224
	D3DDevice_SetStreamSource @2225
	D3DDevice_DrawVertices @2226
;	D3DDevice_DrawVerticesUP @2227
	D3DDevice_DrawIndexedVertices @2228
	D3DDevice_DrawIndexedVerticesUP @2229
;	D3DDevice_SetVertexShaderConstantF_ParameterCheck @2230
	D3DDevice_SetPixelShaderConstantF_ParameterCheck @2231
;	D3DDevice_SetSamplerState_ParameterCheck @2232
;	D3DDevice_SetRenderState_ParameterCheck @2233
;	D3DDevice_GetRenderState_ParameterCheck @2234
;	D3DDevice_SetVertexShaderConstantFN @2235
	D3DDevice_SetPixelShaderConstantFN @2236
;	D3DDevice_GetRenderState_ZEnable @2237
;	D3DDevice_GetRenderState_CullMode @2238
;	D3DDevice_GetRenderState_AlphaBlendEnable @2239
;	D3DDevice_GetRenderState_SrcBlendAlpha @2240
;	D3DDevice_GetRenderState_DestBlendAlpha @2241
;	D3DDevice_GetRenderState_BlendOp @2242
;	D3DDevice_GetRenderState_ViewportEnable @2243
;	D3DDevice_SetRenderState_ZEnable @2244
;	D3DDevice_SetRenderState_CullMode @2245
;	D3DDevice_SetRenderState_AlphaBlendEnable @2246
;	D3DDevice_SetRenderState_SrcBlendAlpha @2247
;	D3DDevice_SetRenderState_DestBlendAlpha @2248
;	D3DDevice_SetRenderState_BlendOp @2249
;	D3DDevice_SetRenderState_ViewportEnable @2250
;	D3DDevice_SetSamplerState_MagFilter @2251
;	D3DDevice_SetSamplerState_MinFilter @2252
	D3DDevice_SetSamplerState_AddressU @2253
	D3DDevice_SetSamplerState_AddressV @2254
;	XGSetTextureHeader @2255
;	XGGetTextureDesc @2256
	XGOffsetResourceAddress @2257
;	D3DResource_AddRef @2258
	XGSetTextureHeaderEx @2262
;	D3DDevice_GetRenderTarget @2263
	D3DDevice_SetRenderTarget @2264
	D3DDevice_GetDepthStencilSurface @2265
	D3DDevice_SetDepthStencilSurface @2266
;	D3DDevice_Resolve @2267
	D3DDevice_SetPixelShaderConstantB @2268
	XamNuiGetDeviceSerialNumber @2269
	XamNuiGetLoadedDepthCalibration @2270
	XamNuiGetTrueColorInfo @2271
	XamNuiGetCameraIntrinsics @2272
	XamNuiGetFanRate @2273
	XamNuiGetSupportString @2274
	XamKinectGetHardwareType @2275
	XamXtwManagerGetVariableCount @2300
	XamXtwManagerGetId @2301
	XamXtwManagerGetValue @2302
	XamXtwManagerSetValue @2303
	XamXtwManagerIncrement @2304
	XamXtwManagerDecrement @2305
	XamXtwManagerResetValue @2306
	XamXtwManagerResetAll @2307
	XamXtwManagerGetDataFilePath @2308
	XamXtwManagerDeleteDataFile @2309
	XamXtwManagerSave @2310
	XamXtwManagerLoad @2311
	XamGetXTweakManager @2312
	XamMediaVerificationCreate @2491
	XamMediaVerificationClose @2492
	XamMediaVerificationVerify @2493
	XamMediaVerificationFailedBlocks @2494
	XamMediaVerificationInject @2495
	XamShowBadDiscErrorUI @2496
	XamBackgroundDownloadSetMode @2500
	XamBackgroundDownloadIsEnabled @2501
	XamBackgroundDownloadGetActiveItem @2502
	XamBackgroundDownloadGetItems @2503
	XamBackgroundDownloadClearItems @2504
	XamBackgroundDownloadItemAdd @2505
	XamBackgroundDownloadItemRemove @2506
	XamBackgroundDownloadItemMakeFirst @2507
	XamBackgroundDownloadSetForegroundPriority @2508
	XamBackgroundDownloadGetForegroundPriority @2509
	XamBackgroundDownloadItemToContentData @2510
	XamBackgroundDownloadItemGetStatus @2511
	XamBackgroundDownloadHistoryGetItem @2512
	XamBackgroundDownloadItemGetHistoryStatus @2513
	XamBackgroundDownloadItemSetHistoryStatus @2514
	XamBackgroundDownloadItemGetStatusAsync @2515
	XamBackgroundDownloadItemGetStatusEx @2516
	XamBackgroundDownloadItemGetHistoryStatusEx @2517
	XamBackgroundDownloadBindItems @2518
	XamBackgroundDownloadSetPollingActive @2519
	XamBackgroundDownloadGetPollingActive @2520
	XamBackgroundDownloadGetMode @2521
	XamBackgroundDownloadGetUnexpectedChangeCount @2522
	XamBackgroundDownloadIsItemForThisConsole @2523
	XamBackgroundDownloadSelectDevice @2524
	XamBackgroundDownloadItemModify @2525
	XamBackgroundDownloadCacheLegacyMappingInfo @2526
	XamBackgroundDownloadGetLegacyMappingInfo @2527
	XamBackgroundDownloadGetLegacyId @2528
	XamBackgroundDownloadDoFail @2529
	XamSwapDisc @2600
	XamSwapDiscPatchAddress @2601
	XamSwapCancel @2602
	XamRamDriveCreate @2610
	XamRamDriveDestroy @2611
	XamPlayTimerGetData @2650
	XamPlayTimerSetData @2651
	XamPlayTimerResume @2652
	XamPlayTimerSuspend @2653
	XamPlayTimerIsRunning @2654
	XamPlayTimerIsEnabled @2655
	XamPlayTimerGetNextResetDate @2656
	XamPlayTimerFormatDurationString @2657
	XamPlayTimerGetTimeRemaining @2658
	XamPlayTimerUpdateTimeRemaining @2659
	XamPlayTimerForceNotification @2660
	XamPlayTimerRefreshResetDate @2661
	UpnpAVServerSearchInitialize @2670
	UpnpAVServerSearchDestroy @2671
	UpnpAVServerSearchStart @2672
	Destroy_CUpnpAVServerSearch @2673
	UpnpAVServerSearchDoWork @2674
	UpnpAVServerSearchGetNextServer @2675
	XCustomBroadcastGamercardEvent @2700
	XamCustomGetCurrentActions @2701
	XamInstrumentationLogEvent @2720
	XamRegisterSMCNotification @2721
	XamInstrumentationLogEventEx @2730
	XamInstrumentationGetSourceConfig @2731
	XamInstrumentationDebugConfig @2732
	CurlCreateCacheEntry @2780
	CurlOpenCacheEntry @2781
	CurlSetCacheEntryExpireTime @2782
	CurlReadCacheEntryHeaders @2783
	CurlReadCacheEntryContent @2784
	CurlWriteCacheEntryContent @2785
	CurlCloseCacheEntry @2786
	CurlEnumerateCacheEntry @2787
	CurlWipeBackingFiles @2789
	CurlOpenTitleBackingFile @2791
	XamSetSecurityViolationDetected @2800
	XamIsSecurityViolationDetected @2801
	XamIsAnySecurityViolationDetected @2802
	XamGetSecurityViolationsDetected @2803
	XamActivateCounterMeasure @2804
	XamDeactivateCounterMeasure @2805
	XamIsCounterMeasureActivated @2806
	XamGetActiveCounterMeasures @2807
	XamPmdIdentify @2808
	XamPmdSendCommand @2809
	XamPmdReadReport @2810
	XamPartyCreate @2812
	XamPartyLeave @2813
	XamPartySendInviteDeprecated @2814
	XamPartyGetUserList @2815
	XamPartySendGameInvites @2816
	XamPartyJoin @2817
	XamPartyKickUser @2818
	XamPartyAddLocalUsers @2819
	XamConvertEmoticons @2820
	XamGetLocaleTimeFormat @2821
	XamPartyRemoveLocalUsers @2822
	XamPartyGetUserListInternal @2823
	XamPartySetJoinable @2824
	XamPartyGetJoinable @2825
	XamPartyGetInfo @2826
	XamPartySetCustomData @2827
	XamPartySetConnectivityGraph @2828
	XamPartyGetRoutingTable @2829
	XamPartyAutomationInprocCall @2830
	XamPartyGetState @2831
	XamPartyGetBandwidth @2832
	XamPartyGetNetworkCounters @2833
	XamShowQuickLaunchUI @2834
	XamPartyIsCoordinator @2835
	XamPartyGetFormation @2836
	XamPartySendInvite @2837
	XamPartySetTestDelay @2838
	XamPartyOverrideNatType @2839
	XamPartyGetAccessLevel @2840
	XamPartySetTestFlags @2841
	XamIsSystemExperienceTitleId @2842
	XamPartyJoinEx @2843
	XamPartyGetInfoEx @2844
	XamTaskSetCancelSubTasks @2850
	XamTaskGetCompletionStatus @2851
	XamTaskCancelWaitAndCloseWaitTask @2852
	XamWebInstrumentationCreateReport @2860
	XamWebInstrumentationSetUserVar @2861
	XamWebInstrumentationSetUserVarNoEscape @2862
	XamWebInstrumentationGetURL @2863
	XamWebInstrumentationSendReport @2864
	XamWebInstrumentationDestroyReport @2865
	XamWebInstrumentationCreateSampledReport @2866
	XampSetSamplingRandomValue @2867
	XampWebInstrumentationSetProfileCounts @2868
	XamWebInstrumentationGetURLEx @2869
	XampSetOmnitureCallbackFunction @2870
	XamShowQuickChatUIp @2871
	XamShowSocialPostUI @2872
	XamShowBeaconsUI @2873
	XamShowMarketplacePurchaseOrderUI @2874
	XamShowMarketplaceGetOrderReceipts @2875
	XamShowGenericOnlineAppUI @2876
	XamUserAllowedToPostToSocialNetwork @2877
	XamShowMarketplacePurchaseOrderUIEx @2878
	XamVerifyXSignerSignature @2890


```

`XenonDumper/libs/xkelib/xam/xamext21119.0.def`:

```def
LIBRARY xam.xex@21119.0+1861.0
EXPORTS
	NetDll_WSAStartup @1
	NetDll_WSACleanup @2
	NetDll_socket @3
	NetDll_closesocket @4
	NetDll_shutdown @5
	NetDll_ioctlsocket @6
	NetDll_setsockopt @7
	NetDll_getsockopt @8
	NetDll_getsockname @9
	NetDll_getpeername @10
	NetDll_bind @11
	NetDll_connect @12
	NetDll_listen @13
	NetDll_accept @14
	NetDll_select @15
	NetDll_WSAGetOverlappedResult @16
	NetDll_WSACancelOverlappedIO @17
	NetDll_recv @18
	NetDll_WSARecv @19
	NetDll_recvfrom @20
	NetDll_WSARecvFrom @21
	NetDll_send @22
	NetDll_WSASend @23
	NetDll_sendto @24
	NetDll_WSASendTo @25
	NetDll_inet_addr @26
	NetDll_WSAGetLastError @27
	NetDll_WSASetLastError @28
	NetDll_WSACreateEvent @29
	NetDll_WSACloseEvent @30
	NetDll_WSASetEvent @31
	NetDll_WSAResetEvent @32
	NetDll_WSAWaitForMultipleEvents @33
	NetDll___WSAFDIsSet @34
	NetDll_WSAEventSelect @35
	NetDll_WSAStartupEx @36
	NetDll_XNetStartup @51
	NetDll_XNetCleanup @52
	NetDll_XNetRandom @53
	NetDll_XNetCreateKey @54
	NetDll_XNetRegisterKey @55
	NetDll_XNetUnregisterKey @56
	NetDll_XNetXnAddrToInAddr @57
	NetDll_XNetServerToInAddr @58
	NetDll_XNetTsAddrToInAddr @59
	NetDll_XNetInAddrToXnAddr @60
	NetDll_XNetInAddrToServer @61
	NetDll_XNetInAddrToString @62
	NetDll_XNetUnregisterInAddr @63
	NetDll_XNetXnAddrToMachineId @64
	NetDll_XNetConnect @65
	NetDll_XNetGetConnectStatus @66
	NetDll_XNetDnsLookup @67
	NetDll_XNetDnsRelease @68
	NetDll_XNetQosListen @69
	NetDll_XNetQosLookup @70
	NetDll_XNetQosServiceLookup @71
	NetDll_XNetQosRelease @72
	NetDll_XNetGetTitleXnAddr @73
	NetDll_XNetGetDebugXnAddr @74
	NetDll_XNetGetEthernetLinkStatus @75
	NetDll_XNetGetBroadcastVersionStatus @76
	NetDll_XNetQosGetListenStats @77
	NetDll_XNetGetOpt @78
	NetDll_XNetSetOpt @79
	NetDll_XNetStartupEx @80
	NetDll_XNetReplaceKey @81
	NetDll_XNetGetXnAddrPlatform @82
	NetDll_XNetGetSystemLinkPort @83
	NetDll_XNetSetSystemLinkPort @84
	NetDll_XNetDnsReverseLookup @85
	NetDll_XNetDnsReverseRelease @86
	NetDll_XnpLoadConfigParams @101
	NetDll_XnpSaveConfigParams @102
	NetDll_XnpConfigUPnP @103
	NetDll_XnpConfig @104
	NetDll_XnpGetConfigStatus @105
	NetDll_XnpLoadMachineAccount @106
	NetDll_XnpSaveMachineAccount @107
	NetDll_XnpCapture @108
	NetDll_XnpEthernetInterceptSetCallbacks @109
	NetDll_XnpEthernetInterceptXmit @110
	NetDll_XnpEthernetInterceptRecv @111
	NetDll_XnpLogonGetStatus @112
	NetDll_XnpLogonGetQFlags @113
	NetDll_XnpLogonSetQFlags @114
	NetDll_XnpLogonSetQEvent @115
	NetDll_XnpLogonClearQEvent @116
	NetDll_XnpLogonGetQVals @117
	NetDll_XnpLogonSetQVals @118
	NetDll_XnpLogonSetPState @119
	NetDll_XnpGetVlanXboxName @120
	NetDll_XnpSetVlanXboxName @121
	NetDll_XnpGetActiveSocketList @122
	NetDll_XnpNoteSystemTime @123
	NetDll_XnpRegisterKeyForCallerType @124
	NetDll_XnpUnregisterKeyForCallerType @125
	NetDll_XnpLogonGetChallenge @126
	NetDll_XnpLogonClearChallenge @127
	NetDll_XnpLogonSetChallengeResponse @128
	NetDll_XnpGetSecAssocList @129
	NetDll_XnpGetKeyList @130
	NetDll_XnpGetQosLookupList @131
	NetDll_XnpPersistTitleState @132
	NetDll_XnpReplaceKeyForCallerType @133
	NetDll_XnpEthernetInterceptSetExtendedReceiveCallback @134
	NetDll_XnpQosHistoryLoad @135
	NetDll_XnpQosHistorySaveMeasurements @136
	NetDll_XnpQosHistoryGetEntries @137
	NetDll_XnpQosHistoryGetAggregateMeasurement @138
	NetDll_XnpToolSetCallbacks @139
	NetDll_XnpToolIpProxyInject @140
	NetDll_XnpUpdateConfigParams @141
	NetDll_XnpEthernetInterceptXmitAsIp @142
	NetDll_XnpConfigUPnPPortAndExternalAddr @143
	NetDll_XmlDownloadStart @151
	NetDll_XmlDownloadContinue @152
	NetDll_XmlDownloadStop @153
	NetDll_XmlDownloadGetParseTime @154
	NetDll_XmlDownloadGetReceivedDataSize @155
	XnpGetXwppMemoryLogSnapshot @198
	XnpGetXwppRuntimeFilter @199
	NetDll_XHttpStartup @201
	NetDll_XHttpShutdown @202
	NetDll_XHttpOpen @203
	NetDll_XHttpCloseHandle @204
	NetDll_XHttpConnect @205
	NetDll_XHttpSetStatusCallback @206
	NetDll_XHttpOpenRequest @207
	NetDll_XHttpOpenRequestUsingMemory @208
	NetDll_XHttpSendRequest @209
	NetDll_XHttpReceiveResponse @210
	NetDll_XHttpQueryHeaders @211
	NetDll_XHttpReadData @212
	NetDll_XHttpWriteData @213
	NetDll_XHttpQueryOption @214
	NetDll_XHttpSetOption @215
	NetDll_XHttpDoWork @216
	NetDll_XHttpSetCredentials @217
	NetDll_XHttpQueryAuthSchemes @218
	NetDll_XHttpCrackUrlW @219
	NetDll_XHttpCrackUrl @220
	NetDll_XHttpCreateUrl @221
	NetDll_XHttpCreateUrlW @222
	NetDll_UpnpStartup @251
	NetDll_UpnpCleanup @252
	NetDll_UpnpSearchCreate @253
	NetDll_UpnpSearchGetDevices @254
	NetDll_UpnpDescribeCreate @255
	NetDll_UpnpDescribeGetResults @256
	NetDll_UpnpActionCalculateWorkBufferSize @257
	NetDll_UpnpActionCreate @258
	NetDll_UpnpActionGetResults @259
	NetDll_UpnpEventCreate @260
	NetDll_UpnpEventGetCurrentState @261
	NetDll_UpnpEventUnsubscribe @262
	NetDll_UpnpDoWork @263
	NetDll_UpnpCloseHandle @264
	XNetLogonGetLoggedOnUsers @301
	XNetLogonGetNatType @302
	XNetLogonTaskStart @303
	XNetLogonTaskClose @304
	XNetLogonTaskContinue @305
	XNetLogonGetServiceInfo @306
	XNetLogonGetUserPrivileges @307
	XNetLogonSetConsoleCertificate @308
	XNetLogonGetMachineID @309
	XNetLogonGetTitleID @310
	XNetLogonGetTitleVersion @311
	XNetLogonGetServiceNetworkID @312
	XNetLogonGetDnsString @313
	XNetLogonSetTitleID @314
	XNetLogonGetExtendedStatus @315
	XNetLogonClearTicketCaches @316
	XNetLogonInitOverrideInfo @317
	XNetLogonGetLastUPnPStatus @318
	XNetLogonGetFlowToken @319
	XNetLogonGetTicketOpt @320
	XNetLogonSetTicketOpt @321
	XNetLogonGetState @322
	XamInputGetCapabilities @400
	XamInputGetState @401
	XamInputSetState @402
	XamInputGetKeystroke @403
	XamInputEnableAutobind @404
	XamInputRawState @405
	XamEnableSystemAppInput @406
	XamInputGetDeviceStats @407
	XamInputGetKeystrokeEx @408
	XamInputGetKeystrokeHud @409
	XamInputSetLayoutKeyboard @410
	XamInputToggleKeyLocks @411
	XamInputResetLayoutKeyboard @412
	XamInputGetKeystrokeHudEx @413
	XamInputSetKeyboardTranslationHud @414
	XamSetInactivityTime @415
	XamEnableInactivityProcessing @416
	XamResetInactivity @417
	XamSetInactivityTimeFromConfig @418
	XamLoaderGetMediaInfo @419
	XamLoaderLaunchTitle @420
	XamLoaderLaunchTitleEx @421
	XamLoaderSetLaunchData @422
	XamLoaderGetLaunchDataSize @423
	XamLoaderGetLaunchData @424
	XamLoaderTerminateTitle @425
	XamLoaderGetDvdTrayState @426
	XamLoaderGetGameInfo @427
	XamLoaderLaunchTitleOnDvd @428
	XamLoaderSetSpindleSpeed @429
	XamTaskCreateQueue @430
	XamTaskSchedule @431
	XamTaskReschedule @432
	XamTaskCloseHandle @433
	XamTaskCancel @434
	XamTaskShouldExit @435
	XamTaskWaitOnCompletion @436
	XamTaskModify @437
	XamTaskGetCurrentTask @438
	XamTaskGetAttributes @439
	XamExecutingOnBehalfOfTitle @440
	XamInputSendStayAliveRequest @441
	XamInputGetUserVibrationLevel @442
	XamIsSystemTitleId @443
	XamLoaderIsTitleTerminatePending @444
	XamInputSetTextMessengerIndicator @445
	XamLoaderGetPriorTitleId @446
	XamIsXbox1TitleId @447
	XamInputSetKeyLocks @448
	XamInputGetKeyLocks @449
	XamTaskGetStatus @450
	XamGetRootObj @451
	XamDevAuthSetFault @452
	XamGetDefaultSystemImage @453
	XamGetWCNConfigFile @454
	XamSetPowerMode @455
	XamExecuteChallenge @456
	XamGetDefaultImage @457
	XamMuteSound @458
	XamGetOnlineSchema @459
	XamSetDashContext @460
	XamGetDashContext @461
	XamIsCurrentTitleDash @462
	XamGetCurrentTitleId @463
	XamSetCurrentTitleDash @464
	XamAllocHeapFreeSpace @465
	XamSetDashContextEx @466
	XamGetDashContextEx @467
	XamSetHudContext @468
	XamGetHudContext @469
	XCustomSetAction @472
	XCustomGetLastActionPress @473
	XCustomSetDynamicActions @474
	XCustomBroadcastActionEvent @475
	XCustomGetLastActionPressEx @476
	XCustomRegisterDynamicActions @477
	XCustomUnregisterDynamicActions @478
	XCustomGetCurrentGamercard @479
	XamDbgPrint @480
	XamDbgSetOutputLevel @481
	XamDbgSetBreakLevel @482
	XamLoaderGetMediaInfoEx @483
	XamLoaderSetGameInfo @484
	XamFormatMessage @485
	XamUniSortCmpString @486
	XamFormatTimeString @487
	XamFormatDateString @488
	XamGetLocaleDateFormat @489
	XamAlloc @490
	XamAllocEx @491
	XamFree @492
	XamAllocSize @493
	XamAllocFreeIPTVHeap @496
	XamDeviceRemap @497
	XamLoaderGetClearCache @498
	XamLoaderSetClearCache @499
;	XMsgInProcessCall @500
;	XMsgCompleteIORequest @501
;	XMsgSystemProcessCall @502
;	XMsgStartIORequest @503
;	XMsgCancelIORequest @504
	XMsgAcquireAsyncMessageFromOverlapped @505
	XMsgReleaseAsyncMessageToOverlapped @506
	XamGetOverlappedResult @507
	XMsgStartIORequestEx @508
	XamAppAllocateInterappWorkspace @509
	XamAppGetInterappWorkspace @510
	XamAppFreeInterappWorkspace @511
	XamFeatureEnabled @512
	XamFeatureEnforceImageBudget @513
	XamFeatureSetMask @514
	XamFeatureEnableDisable @515
	XuiControlSetItemAssociation @516
	XamGetTitleGlobalStorageValue @517
	XamSetTitleGlobalStorageValue @518
	XamUserValidateAvatarMetadata @519
	XamUserGetDeviceContext @520
	XamUserLookupDevice @521
	XamUserGetXUID @522
	XamUserLogon @523
	XamUserGetGamerTag @524
	XamUserGetUserIndexMask @525
;	XamUserGetName @526
	XamLookupCommonStringByIndex @527
;	XamUserGetSigninState @528
	XamUserGetIndexFromXUID @529
	XamUserCheckPrivilege @530
	XamUserAreUsersFriends @531
	XamSetUserPresetPresenceState @532
	XamGetUserPresetPresenceState @533
	XamUserGetUserFlagsFromXUID @534
	XamUserGetMembershipTypeFromXUID @535
	XamUserGetOnlineCountryFromXUID @536
	XamUserReadProfileSettings @537
	XamUserWriteProfileSettings @538
	XamUserGetMembershipType @539
	XamUserGetUserFlags @540
	XamUserGetRequestedUserIndexMask @541
	XamUserIsGuest @542
	XamUserProfileSync @543
	XamUserFlushLogonQueue @544
	XamUserIsOnlineEnabled @545
	XamUserGetCachedUserFlags @546
	XamAreMixedAccountsSignedIn @547
	XamUserLogonEx @548
	XamSetUserShowMessengerFriends @549
	XamGetUserShowMessengerFriends @550
	XamUserGetSigninInfo @551
	XamUserIsPartial @552
	XamUserGetOnlineLanguageFromXUID @553
	XamUserReadProfileSettingsEx @554
	XamSystemUpdaterLogon @555
;	XamUserGetUsersMissingAvatars @556
	XamIsChildAccountSignedIn @557
	XamUserPrefetchProfileSettings @558
	XamUserInvalidateProfileSetting @559
	XamProfileCreate @560
	XamProfileCreateEnumerator @561
	XamProfileEnumerate @562
	XamProfileDelete @563
	XamProfileGetCreationStatus @564
	XamProfileFindAccount @565
	XamProfileRenameAccount @566
	XamProfileOpen @567
	XamProfileClose @568
	XamProfileSaveAccountInfo @569
	XamProfileLoadAccountInfo @570
	XamProfileRecoverTitle @571
	XamProfileSaveWindowsLiveCredentials @572
	XamProfileLoadWindowsLiveCredentials @573
	XamProfileIsSaveWindowsLiveCredsEnabled @574
	XamProfileSetSaveWindowsLiveCredsEnabled @575
	XamSetProfileReadTestHook @576
	XamProfileGetLastSync @577
	XamAccountRecoveryRecoverTitle @578
	XamProfileControlXgi @579
	XamAppLoad @580
	XamAppUnloadSelf @581
	XamAppUnloadStack @582
	XamSendMessageToLoadedApps @583
	XamAppRequestLoad @584
	XamAppUnrequestLoad @585
	XamNavigate @586
	XamRegisterSysApp @587
	XamUnregisterSysApp @588
;	XamCreateEnumeratorHandle @590
;	XamGetPrivateEnumStructureFromHandle @591
	XamEnumerate @592
	XamLoadSysApp @593
	XamUnloadSysApp @594
	XamReloadSysApp @595
	XamAppLoadPass2SysApps @596
	XamProfileGetLiveLegalLocale @597
	XamUserIsParentalControlled @598
	XamContentLaunchImageFromFileInternal @599
	XamContentCreate @600
	XamContentCreateEx @601
	XamContentClose @602
	XamContentDelete @603
	XamContentCreateEnumerator @604
	XamContentCreateDeviceEnumerator @605
	XamContentGetDeviceData @606
	XamContentGetDeviceName @607
	XamContentSetThumbnail @608
	XamContentGetThumbnail @609
	XamContentGetCreator @610
	XamContentLaunchImage @611
	XamContentGetAttributes @612
	XamContentGetDeviceState @613
	XamContentGetLicenseMask @614
	XamContentFlush @615
	XamContentResolve @616
	XamContentOpenFile @617
	XamContentInstall @618
	XamContentLockUnlockPackageHeaders @619
	XamContentCopyInternal @620
	XamContentMoveInternal @621
	XamContentGetMetaDataInternal @622
	XamContentCreateEnumeratorInternal @623
	XamContentDeleteInternal @624
	XamContentCreateInternal @625
	XamContentSetThumbnailInternal @626
	XamContentLaunchImageInternal @627
	XamContentWritePackageHeader @628
	XamContentDismountAndClosePackage @629
	XamContentResolveInternal @630
	XamContentGetAttributesInternal @631
	XamContentOpenFileInternal @632
	XamContentAggregateCreateEnumerator @633
	XamContentCreateAndMountPackage @634
	XamContentOpenPackageFile @635
	XamContentMountPackage @636
	XamContentFlushPackage @637
	XamContentClosePackageFile @638
	XamContentDuplicateFileHandle @639
	XamGetExecutionId @640
	XamGetGameRatings @641
	XamGetSystemVersion @642
	XamContentGetLocalizedString @643
	XamContentGetDefaultDevice @644
	XamContentInstallInternal @645
	XamContentSetMediaMetaDataInternal @646
	XamContentGetDeviceSerialNumber @647
	XamContentGetMountedPackageByRootName @648
	XamContentRegisterChangeCallback @649
	XamNotifyCreateListener @650
;	XNotifyGetNext @651
;	XNotifyPositionUI @652
;	XNotifyDelayUI @653
	XNotifyBroadcast @654
	XNotifyRegisterArea @655
	XNotifyQueueUI @656
	XamNotifyCreateListenerInternal @657
	XNotifyUISetOptions @658
	XNotifyUIGetOptions @659
	XamContentLaunchImageInternalEx @660
	XamShutdown @661
	XamAllocDevkitHeapAvailable @662
	XamNotifyCreateListenerRangeInternal @663
	XNotifyQueueUIEx @664
	XamAppRequestLoadEx @665
	XuiPNGTextureLoader @666
	XuiRenderGetXuiDevice @667
	XuiDefault_False @668
	XamUserGetReportingInfo @669
	XamUpdateStart @670
	XamUpdateGetProgress @671
	XamUpdateFinish @673
	XamUpdateAttachExtenderInstance @674
	XamUpdateGetBaseSystemVersion @678
	XamUpdateGetCurrentSystemVersion @679
	XamUpdateChainPass3FromPass2 @683
	XamInputGetCapabilitiesEx @685
	XamUserIsUnsafeProgrammingAllowed @686
	XamDevAuthSetFaultEx @687
	XamUpdateGetData @688
	XamCacheIntegrityCheck @689
	XamCacheStoreFile @690
	XamCacheFetchFile @691
	XamCacheOpenFile @692
	XamCacheCloseFile @693
	XamGetCachedTitleName @694
	XamCacheReset @695
	XamGetCachedGamerTag @696
	XamGetCachedGamerTagW @697
	XamCacheDeleteFile @698
	XamCacheRenameFile @699
	XamShowSigninUI @700
	XamShowSigninUIEx @701
	XamShowSigninUIp @702
	XamShowFriendsUI @703
	XamShowMessagesUI @704
	XamShowKeyboardUI @705
	XamShowQuickChatUI @706
	XamShowVoiceMailUI @707
	XamShowGamerCardUI @708
	XamShowAchievementsUI @709
	XamShowPlayerReviewUI @710
	XamShowMarketplaceUI @711
	XamShowPlayersUI @712
	XamShowUpdaterUI @713
	XamShowMessageBoxUI @714
	XamShowDeviceSelectorUI @715
	XamShowMessageComposeUI @716
	XamShowGameInviteUI @717
	XamShowFriendRequestUI @718
	XamShowCreateProfileUI @719
	XamShowGamesUI @720
	XamShowLiveSignupUI @721
	XamShowFriendsUIp @722
	XamShowComplaintUI @723
	XamShowReputationUI @724
	XamShowGamerCardUIForXUID @725
	XamShowForcedNameChangeUI @726
	XamShowLiveUpsellUI @727
	XamShowPasscodeVerifyUI @728
	XamShowDirtyDiscErrorUI @729
	XamShowSignupCreditCardUI @730
	XamShowPrivateChatInviteUI @731
	XamShowMessageBoxUIEx @732
	XamShowRecentMessageUI @733
	XamShowRecentMessageUIEx @734
	XamShowMessagesUIEx @735
	XamShowAchievementDetailsUI @736
	XamShowPersonalizationUI @737
	XamShowChangeGamerTileUI @738
	XamShowVoiceSettingsUI @739
	XamShowVideoChatInviteUI @740
	XamShowCustomMessageComposeUI @741
	XamShowCustomPlayerListUI @742
	XamShowMarketplaceDownloadItemsUI @743
	XamShowMarketplaceUIEx @744
	XamShowMessageBox @745
	XamIsSysUiInvokedByXenonButton @746
	XamIsSysUiInvokedByTitle @747
	XamIsUIActive @748
	XamSysUiDisableAutoClose @749
	XamUserCreateAchievementEnumerator @750
	XamReadTile @751
	XamWriteGamerTile @752
	XamWriteTile @753
	XamReadImage @754
	XamUserCreateTitlesPlayedEnumerator @755
	XamDecompressPNGToTexture @756
	XamReadTileToTexture @757
	XamReadString @758
	XamUserCreateStatsEnumerator @759
	XamPrepareGamerTiles @760
	XamClearTitle @761
	XamReadStrings @762
	XamWriteGamerTileEx @763
	XamReadTileEx @764
	XamReadTileToTextureEx @765
	XamShowMessengerUI @766
	XamShowKeyboardUIMessenger @767
	XamShowLiveUpsellUIEx @768
	XamShowJoinSessionInProgressUI @769
	XamShowGraduateUserUI @770
	XamShowGamerCardUIForXUIDp @771
	XamShowGuideUI @772
	XamShowPartyUI @773
	XamShowPartyInviteUI @774
	XamUserAddRecentPlayer @775
	XamUserUpdateRecentPlayer @776
	XamUserCreatePlayerEnumerator @777
	XamParseGamerTileKey @778
	XamShowCommunitySessionsUI @779
	XamVoiceCreate @780
	XamVoiceHeadsetPresent @781
	XamVoiceSubmitPacket @782
	XamVoiceClose @783
	XamVoiceGetBatteryStatus @784
	XamShowJoinSessionByIdInProgressUI @787
	XamShowPartyJoinInProgressUI @788
	XamBuildSharedSystemResourceLocator @789
	XamSessionCreateHandle @790
	XamSessionRefObjByHandle @791
	XamVoiceGetMicArrayStatus @792
	XamVoiceSetAudioCaptureRoutine @793
	XamVoiceGetDirectionalData @794
	XamBuildResourceLocator @795
	XamBuildLegacySystemResourceLocator @796
	XamBuildGamercardResourceLocator @797
	XamBuildDynamicResourceLocator @798
	XamBuildXamResourceLocator @799
	XuiAnimRun @800
	XuiApplyLocale @801
	XuiBubbleMessage @802
	XuiControlIsBackButton @803
	XuiControlIsNavButton @804
	XuiCreateObject @805
	XuiDestroyObject @806
	XuiDynamicCast @807
	XuiElementAddChild @808
	XuiElementFindNamedFrame @809
	XuiElementGetChildById @810
	XuiElementGetFirstChild @811
	XuiElementGetFocus @812
	XuiElementGetFocusUser @813
	XuiElementGetId @814
	XuiElementGetLastChild @815
	XuiElementGetNext @816
	XuiElementGetParent @817
	XuiElementGetUserFocus @818
	XuiElementInitFocus @819
	XuiElementInitUserFocus @820
	XuiElementPlayTimeline @821
	XuiElementSetBounds @822
	XuiElementSetFocus @823
	XuiElementSetUserFocus @824
	XuiElementTreeGetFocus @825
	XuiFindClass @826
	XuiFreeStringTable @827
	XuiGetBaseObject @828
	XuiGetClass @829
	XuiGetObjectClass @830
	XuiGetOuter @831
	XuiInit @832
	XuiLoadFromBinary @833
	XuiLoadStringTableFromFile @834
	XuiVisualGetBasePath @835
	XuiLookupStringTable @836
	XuiNavButtonGetPressPath @837
	XuiObjectFromHandle @838
	XuiObjectGetProperty @839
	XuiObjectGetPropertyId @840
	XuiProcessInput @841
	XuiRegisterClass @842
	XuiRenderBegin @843
	XuiRenderCreateDC @844
	XuiRenderDCDeviceChanged @845
	XuiRenderDestroyDC @846
	XuiRenderEnd @847
	XuiRenderGetBackBufferSize @848
	XuiRenderInit @849
	XuiRenderInitShared @850
	XuiRenderPresent @851
	XuiRenderSetViewTransform @852
	XuiRenderUninit @853
	XamShowNuiGuideUI @854
	XuiSceneCreate @855
	XuiSceneNavigateBack @856
	XuiSceneNavigateFirst @857
	XuiSceneNavigateForward @858
	XuiScenePlayBackFromTransition @859
	XuiScenePlayBackToTransition @860
	XuiScenePlayFromTransition @861
	XuiScenePlayToTransition @862
	XuiSendMessage @863
	XuiSetLocale @864
	XuiUninit @865
	XuiUnregisterClass @866
	XuiTextElementSetText @867
	XuiSetTimer @868
	XuiTimersRun @869
	XuiTextElementGetText @870
	XuiVisualSetBasePath @871
	XuiHandleIsValid @872
	XuiAlloc @873
	XuiFree @874
	XuiDefault_True @875
	XuiDefault_EmptyString @876
	XuiDefault_IntegerZero @877
	XuiCopyString @878
	XuiRealloc @879
	XuiControlPlayOptionalVisual @880
	XuiKillTimer @881
	XuiElementEnableInput @882
	XuiElementInputEnabled @883
	XuiIsInstanceOf @884
	XuiResourceComposeLocator @885
	XuiResourceLocatorIsAbsolute @886
	XuiBroadcastMessage @887
	XuiElementDisallowRecursiveTimelineControl @888
	XUIElementPropVal_Construct @889
	XUIElementPropVal_Destruct @890
	XUIElementPropVal_SetString @891
	XuiObjectSetProperty @892
	XuiElementGetOpacity @893
	XuiElementSetOpacity @894
	XuiEditSetTextLimit @895
	XuiEditGetTextLimit @896
	XuiSliderSetValue @897
	XuiSliderGetValue @898
	XuiSliderSetRange @899
	XuiElementUnlink @900
	XuiElementInsertChild @901
	XuiSceneNavigateBackToFirst @902
	XuiProgressBarSetRange @903
	XuiProgressBarSetValue @904
	XuiProgressBarGetValue @905
	XuiControlAttachVisual @906
	XuiCreateTextureBrush @907
	XuiDestroyBrush @908
	XUIElementPropVal_SetColorFromUint @909
	XuiFigureSetFill @910
	XuiSliderGetRange @911
	XuiFigureSetTexture @912
	XuiControlGetItemAssociation @913
	XuiResourceLoadAll @914
	XuiImageElementSetImagePath @915
	XuiImageElementGetImagePath @916
	XuiControlGetVisual @917
	XuiControlGetNavigation @918
	XuiLookupStringTableByIndex @919
	XUIElementPropVal_SetBool @920
	XuiElementHasFocus @921
	XUIElementPropVal_SetUint @922
	XUIElementPropVal_Clear @923
	XuiEditSetTextFormatInfo @924
	XuiCreateSolidBrush @925
	XuiSceneInterruptTransitions @926
	XuiResourceOpen @927
	XuiResourceRead @928
	XuiResourceClose @929
	XuiVisualCreateInstance @930
	XuiElementGetTimeline @931
	XuiElementIsDescendant @933
	XuiSetMessageFilter @934
	XuiAttachTextureBrush @935
	XuiElementBeginRender @936
	XuiElementEndRender @937
	XuiDrawShape @938
	XuiSelectBrushEx @939
	XuiFigureGetShape @940
	XuiFillRect @941
	XuiVec2TransformCoord @942
	XuiMatrixMultiply @943
	XuiElementGetXForm @944
	XuiElementSetPosition @945
	XuiSelectBrush @946
	XuiElementRenderChildren @947
	XuiFreeUnusedTextures @948
	XuiListEnableItemOverride @949
	XuiListGetDefaultItemSize @950
	XuiResourceSeek @951
	XuiElementDiscardResources @952
	XuiTabSceneGoto @953
	XuiTabSceneGetCurrentTab @954
	XamShowWhatsOnUI @955
	XamShowEditProfileUI @956
	XamShowStorePickerUI @957
	XamShowTermsOfUseUI @958
	XamShowJoinPartyUI @959
	XamShowWordRegisterUI @960
	XamOverrideHudOpenType @961
	XamShowAchievementsUIEx @962
	XamUserGetUserTenure @963
	XamUserGetSubscriptionType @964
	XamShowGameVoiceChannelUI @965
	XamShowAvatarAwardsUI @966
	XamShowAvatarAwardGamesUI @967
	XamShowVideoRichPresenceUI @968
	XamHudGetUserIndex @969
	XGetAudioFlags @970
	XGetAVPack @971
	XGetGameRegion @972
	XGetLanguage @973
	XapipGetLocale @974
	XGetVideoFlags @975
	XGetVideoStandard @976
	XGetVideoMode @977
	XamGetLanguage @978
	XUITimeline_Run @979
	XamSetAutomation @980
	XAutomationpBindController @981
	XAutomationpUnbindController @982
	XAutomationpInputXenonButton @983
	XAutomationpInputPress @984
	XAutomationpInputSetState @985
	XamEnableOverdraw @986
	g_XuiAutomation @987
	XamVoiceGetMicArrayAudio @988
	XampSystemInput @989
	XamInputControl @990
	XuiElementGetPosition @991
	XamIsMessageBoxActive @992
	XamIsBackgroundSceneInTransition @993
	XuiElementTreeHasFocus @994
	XuiFigureClose @995
	GamerCardStartup @996
	GamerCardCleanup @997
	GamerCardRegisterControls @998
	GamerCardUnregisterControls @999
	RtlFindFirstFile @1000
	RtlFindNextFile @1001
	RtlGetModuleFileName @1002
;	RtlOutputDebugString @1003
	RtlRemoveDirectory @1004
	RtlSleep @1005
	RtlGetLastError @1006
	RtlSetLastError @1007
	RtlSetLastNTError @1008
	RtlDebugPrint @1009
	RtlDebugError @1010
	RtlDebugTrace @1012
	RtlDebugEntry @1013
	RtlDebugExit @1014
	RtlGetAttributesOnHeapAlloc @1015
	RtlSetAttributesOnHeapAlloc @1016
	XuiFigureSetShape @1017
	RtlCreateHeap @1018
	RtlDestroyHeap @1019
;	RtlAllocateHeap @1020
	RtlAllocateHeapSlowly @1021
;	RtlReAllocateHeap @1022
;	RtlFreeHeap @1023
	RtlFreeHeapSlowly @1024
;	RtlSizeHeap @1025
	RtlZeroHeap @1026
	RtlDebugWalkHeap @1027
	RtlWalkHeap @1028
	RtlLockHeap @1029
	RtlUnlockHeap @1030
;	RtlValidateHeap @1031
	RtlDebugCompactHeap @1032
	RtlCompactHeap @1033
	XamAppSetTestOption @1034
	XamAppReportError @1035
	XamIsNuiUIActive @1036
	XamVerifyPasscode @1037
	OutputDebugStringA @1038
	DebugBreak @1039
	GetCurrentThreadId @1040
	XDebugError @1041
	RtlDebugSetLevel @1043
	CloseHandle @1044
	GetTickCount @1045
	GetLastError @1046
	SetFilePointer @1047
	SetFilePointerEx @1048
	SetLastError @1049
	MultiByteToWideChar @1050
	WideCharToMultiByte @1051
	ReadFile @1052
	FlushFileBuffers @1053
	WriteFile @1054
	OutputDebugStringW @1055
	SetEvent @1056
	XapiFormatTimeOut @1057
	CreateMutexA @1058
	OpenMutexA @1059
	ReleaseMutex @1060
	WaitForSingleObject @1061
	WaitForSingleObjectEx @1062
	GetFileSize @1063
	GetFileSizeEx @1064
	XapiDirectoryInformationToFindData @1065
	XapiFormatObjectAttributes @1066
	ResetEvent @1067
	wsprintfA @1068
	wsprintfW @1069
	GetOverlappedResult @1070
	QueryPerformanceCounter @1071
	QueryPerformanceFrequency @1072
	LocalAlloc @1073
	LocalFree @1074
	RaiseException @1075
	RtlUniform @1076
	RtlRandom @1077
	Sleep @1078
	SleepEx @1079
	XMemSet @1080
	XRegisterThreadNotifyRoutine @1081
	XGetOverlappedExtendedError @1082
	XGetOverlappedResult @1083
	CreateThread @1084
	ResumeThread @1085
	ExitThread @1086
	GetTimeZoneInformation @1087
	GetSystemTimeAsFileTime @1088
	SystemTimeToFileTime @1089
	FileTimeToSystemTime @1090
	GetSystemTime @1091
	GetLocalTime @1092
	CreateDirectoryA @1093
	CreateEventA @1094
	CreateFileA @1095
	DeleteFileA @1096
	FindFirstFileA @1097
	FindNextFileA @1098
	GetFileAttributesA @1099
	XamLoaderGetCurrentTitleD3DVersion @1100
	GetFileAttributesExA @1101
	GetModuleHandleA @1102
	GetDiskFreeSpaceExA @1103
	CopyFileA @1104
	SetEndOfFile @1105
	XamFamilyAddParentalExemptionToList @1106
	XamFamilyIsParentalValidationRequired @1107
;	PIXAddCounter @1110
	SetWaitableTimer @1112
	CancelWaitableTimer @1113
	CreateWaitableTimerA @1114
	DuplicateHandle @1115
	XapipCreateThread @1116
	lstrcpyA @1117
	lstrcpyW @1118
	lstrcpynA @1119
	lstrcpynW @1120
	lstrcatA @1121
	lstrcatW @1122
	lstrlenA @1123
	lstrlenW @1124
	IsBadReadPtr @1125
	IsBadWritePtr @1126
	FileTimeToLocalFileTime @1127
	XMemCpy @1128
	XMemCpyStreaming @1129
	XamHudSetUserIndex @1130
	XamShowNuiTroubleshooterUI @1131
	XamTestShowNuiTroubleshooterUI @1132
	XamShowPasscodeVerifyUIEx @1133
	XamShowNuiAchievementsUI @1134
	XamShowNuiCommunitySessionsUI @1135
	XamShowNuiDeviceSelectorUI @1136
	XamShowNuiDirtyDiscErrorUI @1137
	XamShowNuiFriendsUI @1138
	XamShowNuiGameInviteUI @1139
	XamShowNuiGamerCardUIForXUID @1140
	XamShowNuiMarketplaceDownloadItemsUI @1141
	XamShowNuiMarketplaceUI @1142
	XamShowNuiMessageBoxUI @1143
	XamShowNuiPartyUI @1144
	XamShowNuiFriendRequestUI @1145
	XamShowNuiSigninUI @1146
	XamShowNuiControllerRequiredUI @1147
	XamShowNuiGamesUI @1148
	XamShowNuiHardwareRequiredUI @1149
	XamCacheStoreFileByString @1150
	XamCacheFetchFileByString @1151
	XamCacheDeleteFileByString @1152
	XamGetCachedTitleNameEx @1153
	XamXlfsInitializeUploadQueue @1154
	XamXlfsUninitializeUploadQueue @1155
	XamXlfsMountUploadQueueInstance @1156
	XamXlfsUnmountUploadQueueInstance @1157
	XamVoiceRecordUserPrivileges @1158
	XamXlfsInitializeUploadQueueWithTestHooks @1159
	XamXlfsNotifyContentDeletion @1160
;	XMemAlloc @1161
;	XMemFree @1162
;	XMemSize @1163
	XamVoiceSetMicArrayIdleUsers @1164
	XamVoiceMuteMicArray @1165
	XamVoiceGetMicArrayUnderrunStatus @1166
	XuiSceneEnableTransitionDependency @1167
	XamVoiceGetMicArrayAudioEx @1168
	XamShowLeaveFamilyUI @1169
	XamUserGetDeviceId @1170
	XamUpdateEtxLogUpdateTaskStart @1171
	XamUpdateEtxLogUpdateTaskSuccess @1172
	XamUpdateEtxLogUpdateTaskFailure @1173
	XamEtxFlushLogs @1174
	XamVoiceIsActiveProcess @1175
	XamInactivityGetInactivityInterruptTime @1176
	XamInactivitySetInactivityInterruptTime @1177
	XamInactivityGetLastActivityTime @1178
	XamInactivitySetDetectionTaskPeriod @1179
	XamInactivityEnablePowerDown @1180
	XamUpdateGetChainMarker @1181
	XGetVideoCapabilities @1182
;	XMsgProcessRequest @1183
	XGetDisplaySize @1184
	XamInputNonControllerGetRaw @1185
	XamInputNonControllerSetRaw @1186
	XamVoiceSetMicArrayBeamAngle @1187
	XamUserGetAge @1188
	XamUserGetAgeGroup @1189
	XamVoiceGetMicArrayFilenameDesc @1190
	XamLoaderGetState @1191
	XamTaskQueryProperty @1192
	XamGetLocale @1193
	XamQueryTimeZoneInformation @1194
	XamSetTimeZoneInformation @1195
	XamLaunchURI @1196
	XamShowNuiMessagesUI @1199
	XMPRegisterCodec @1200
	XamNavigateBack @1201
	XamPushBackURI @1202
	XamUserOverrideDeviceBindings @1203
	XamUserOverrideBindingCallbacks @1204
	XamUserOverrideUserInfo @1205
	XamUserContentRestrictionGetFlags @1206
	XamUserContentRestrictionGetRating @1207
	XamUserContentRestrictionCheckAccess @1208
	XamFamilyGetMembers @1211
	XampXAuthStartup @1212
	XampXAuthShutdown @1213
	XamGetToken @1214
	XamFreeToken @1215
	XamGetAppliesTo @1216
	XamLrcGetInput @1223
	XamLrcGetInputWithSeek @1224
	XamLrcSetMediaState @1225
	XamPixSetDirtyCounters @1226
	XamRequestToken @1229
	XamResolveURI @1230
	XamContentGetOnlineCreator @1231
	XamShowBrandedKeyboardUI @1232
	XamBackgroundDownloadNetworkStorageEnable @1233
	XamBackgroundDownloadNetworkStorageIsEnabled @1234
	XamShowNuiJoinSessionInProgressUI @1235
	XamBase64Decode @1236
	XamCertDecode @1237
	XamCertDecodeRsaPublicKey @1238
	XamCertValidateStruct @1239
	XamBackgroundDownloadNetworkStorageOnContentChange @1247
	InjectConnectionServerNotification @1249
	XamGetGamerTileKeyFromGamertag @1251
	XamBackgroundDownloadNetworkStorageRegisterChangeCallback @1252
	XamFindOrCreateInternalPassportAccount @1253
	XOnlinepFriendsRequest @1254
	XOnlinepFriendsAcceptRequest @1255
	XOnlinepFriendsRejectRequest @1256
	XOnlinepFriendsRemove @1257
	XFriendsCreateEnumerator @1258
	XamBackgroundDownloadNetworkStorageIsRunning @1259
	XamCertGetSerialNumber @1260
	XamShowOptionsUI @1261
	XampXAuthGetTitleBuffer @1262
	XamGetSTSTokenCache @1263
	XamUserGetOnlineXUIDFromOfflineXUID @1264
	XamShowNuiVideoRichPresenceUI @1266
	XamAppAllocateInterappWorkspaceEx @1267
	XamNetworkStatusGetInformation @1269
	XamNetworkStatusAddAddress @1270
	XamUserReadUserPreference @1271
	XamUserWriteUserPreference @1272
	XamWaitForNSAL @1276
	XamMarkInternalAccountTrustedOnConsole @1277
	XamBackgroundDownloadNetworkStorageGetProgress @1278
	XamCopyFile @1279
	XamMoveFile @1280
	XamDeleteFile @1281
	XamIsCurrentTitleIptv @1300
	XamIsIptvEnabled @1301
	XamIsDvrRecording @1302
	XamIptvUninstall @1303
	XamGetDvrStorage @1304
	XamSetDvrStorage @1305
	XamIptvGetServiceName @1306
	XamNuiHudGetEngagedEnrollmentIndex @1307
	XamProfileSetCachedWindowsLiveEmail @1308
	XamProfileGetCachedWindowsLiveEmail @1309
	XamUserResetSubscriptionType @1310
	XamReminderGetItems @1400
	XamReminderClearItems @1401
	XamReminderItemAdd @1402
	XamReminderItemRemove @1403
	XamReminderGetNextItem @1404
	XamReminderGetModifiedTime @1405
	XamReminderClearCache @1406
	XamAvatarInitialize @1500
	XamAvatarShutdown @1501
	XamAvatarGetMetadataLocalUser @1502
	XamAvatarGetMetadataByXuid @1503
	XamAvatarGetAssetsResultSize @1504
	XamAvatarGetAssets @1505
	XamAvatarGenerateMipMaps @1506
	XamAvatarSetCustomAsset @1507
	XamAvatarSetMetadata @1508
	XamAvatarLoadAnimation @1511
	XamAvatarBeginEnumAssets @1512
	XamAvatarEndEnumAssets @1513
	XamAvatarEnumAssets @1514
	XamAvatarGetMetadataRandom @1515
	XamAvatarGetMetadataSignedOutProfileCount @1518
	XamAvatarGetMetadataSignedOutProfile @1519
	XamAvatarMetadataGetBodyType @1521
	XamAvatarGetInstrumentation @1522
	XamAvatarGetAssetIcon @1523
	XamAvatarWearNow @1524
	XamAvatarGetAssetBinary @1525
	XamLoaderGetSuspendedTitleInfo @1526
	XamAvatarGetInstalledAssetPackageDescription @1527
	XamAvatarSetAdapters @1528
	XamContentMountInstalledGame @1550
	XamContentIsGameInstalledToHDD @1551
	XamContentQueryLicenseInternal @1552
	XamContentGetDeviceVolumePath @1553
	XamContentDeviceCheckUpdates @1554
	XamContentGetHeaderInternal @1555
	XamNetworkStorageGetNetworkDevice @1556
	XamNetworkStorageDeviceHasCacheFile @1557
	XamNetworkStorageCreateCacheOnDevice @1558
	XamNetworkStorageDeleteCacheOnDevice @1559
	XamNetworkStorageGetStatus @1560
	XamNetworkStorageIsSupportedContentType @1561
	XamNetworkStorageSetTestMock @1562
	XamNetworkStorageGetLastSyncTime @1563
	XamShowNetworkStorageSyncUI @1564
	XamUserIsLogonPreviewModeEnabled @1565
	XamUserLockLogonPreviewMode @1566
	XamUserUnlockLogonPreviewMode @1567
	XamNetworkStorageIsUserInSync @1568
	XamNetworkStorageSetUserInSync @1569
	XamNetworkStorageOnSigninChanged @1570
	XamNetworkStorageSignInTestMock @1571
	XamShowFofUI @1572
	CompareFileTime @1573
	SetFileTime @1574
	XamNetworkStorageGetTitleProperties @1575
	XamNetworkStorageLockFile @1576
	XamNetworkStorageUserHasPrivilege @1577
	XamNetworkStorageIsTitleExempt @1578
	XamContentExistsOnDeviceInternal @1579
	XamNetworkStorageGetBackingDevice @1580
	XamNetworkStorageIsEnabledInLiveHive @1581
	XamNetworkStorageIsCheckingSyncStates @1582
	XamNetworkStorageUserNeedsToSync @1583
	XamNetworkStorageGetUserNetworkSyncTime @1584
	XamNetworkStorageGetUserProperties @1585
	XamNetworkStorageAppLauncherLaunchIfRunning @1586
	XamNetworkStorageSetTitleProperties @1587
	XamNetworkStorageGetUserLastError @1588
	XamNetworkStorageCheckOutTitle @1589
	XamNetworkStorageShouldHideFromTitle @1590
	XamNetworkStorageOnUserSyncChange @1591
	XamNetworkStorageHasUserEnabledStorage @1592
	XamContentGetLocalizedDeviceData @1593
	XamPackageManagerFindPackageContainingIndexedXEX @1600
	XamPackageManagerReinitialize @1601
	XamPackageManagerGetAuthoritativeManifestRevision @1602
	XamGetCurrentSystemOnlineManifestRevision @1603
	XamPackageManagerDeleteExtendedPartition @1604
	XamPackageManagerHasExtendedPartition @1605
	XamPackageManagerGetExperienceMode @1606
	XamPackageManagerGetFeatureRequiresUpdateStrings @1607
	XamPackageManagerGetFileSize @1608
	XampDemandUpdateGetAttributes @1609
	XampDemandUpdateGetExtendedAttributes @1610
	XampDemandUpdateGetInstance @1611
	XampDemandUpdateSetRefreshTestFlags @1612
	XampDemandUpdateIsRefreshTestFlagSet @1613
	XampDemandUpdateGetManifestLocalPath @1614
	XampDemandUpdateRefreshManifest @1615
	XdfInitialize @1616
	XdfShutdown @1617
	XdfGetExpectedDownloadSize @1618
	XdfGetItem @1619
	XdfCacheItem @1620
	XdfLoadXexFromCache @1621
	XdfLoadXex @1622
	XdfCancelRequest @1623
	XdfResumeDelayedItem @1624
	XdfLaunchNewImageFromCache @1625
	XampDemandUpdateRefreshManifestDuringLogon @1626
	XampDemandUpdateCheckOnlineManifestChanged @1627
	XampDemandUpdateRunCacheCleaner @1628
	XamXStudioRequest @1670
	XamNotifyDelayUIInternal @1671
	XamShowAvatarMiniCreatorUI @1700
	XamShowGoldUpgradeUI @1701
	XamResumeUpdaterUI @1702
	XamShowDirectAcquireUI @1703
	XamShowPaymentOptionsUI @1704
	XamGetLiveHiveValueA @1800
	XamGetLiveHiveValueW @1801
	XamGetLiveHiveValueDuringLogonAttemptA @1802
	XamSetUserPresetWindowsLiveCreds @1803
	XamQueryLiveHiveA @1804
	XamQueryLiveHiveW @1805
	XamSetStagingMode @1902
	XamGetStagingMode @1903
	XamAppGetSessionId @1904
	XamAccountRecoveryRecoverAllProfileData @1905
	XamAccountRecoveryGetProgress @1906
	XamDoesOmniNeedConfiguration @2000
	GetProcessHeap @2002
	UnhandledExceptionFilter @2003
	SetUnhandledExceptionFilter @2004
	XamIsOptionalMediaUpdateInstalled @2005
	XamShowOptionalMediaUpdateRequiredUI @2006
	XamShowOptionalMediaUpdateRequiredUIEx @2007
	XamTaskCreateQueueEx @2009
	XamSetTextureLoaderHook @2010
	XamLaunchAvatarEditor @2011
	XamLoadExtraAVCodecs @2012
	XamUnloadExtraAVCodecs @2013
	XamSetLastActiveUserData @2014
	XamGetLastActiveUserData @2015
	XamSetActiveDashAppInfo @2016
	XamGetActiveDashAppInfo @2017
	XamUserCreateAvatarAssetEnumerator @2050
	XamInitializeGameTileCache @2051
	XamDestroyGameTileCache @2052
	XamReadGameTileImage @2053
	XamShouldThrottleAccountInfoCall @2054
	XuiClassDerivesFrom @2055
	XuiFreeVisuals @2056
	XuiGetBaseClass @2057
	XuiLoadVisualFromBinary @2058
	XuiResourceGetBuffer @2059
	XuiResourceGetTotalSize @2060
	XuiElementGetUserData @2061
	XuiElementSetUserData @2062
	XuiTabSceneGetCount @2063
	XuiSliderGetStep @2064
	XuiSliderSetStep @2065
	XuiProgressBarGetRange @2066
	XuiElementSetHittable @2067
	XuiElementPlayNamedFrames @2068
	XuiElementGetPivot @2069
	XuiElementGetPrev @2070
	XuiElementGetScale @2071
	XuiElementSetPivot @2072
	XuiElementSetRotation @2073
	XuiElementSetScale @2074
	XuiControlWantsUnfocusedInput @2075
	XuiResourceOpenNoLoc @2076
	XuiResourceReleasePackage @2077
	XuiResourceGetPackageEntryInfo @2078
	XuiResourceGetPackageEntryCount @2079
	XuiResourceOpenPackage @2080
	XamCodeCoverageFileOpen @2081
	XamCodeCoverageFileClose @2082
	XamCodeCoverageFileLseek @2083
	XamCodeCoverageFileRead @2084
	XamCodeCoverageFileWrite @2085
	XampHeapGetInfo @2087
	XampHeapGetCount @2088
	XuiElementLayoutTree @2090
	XamInactivityResetAllState @2091
	XUIElementPropVal_SetInt @2092
	XUIElementPropVal_SetFloat @2093
	XuiObjectGetPropertyDef @2094
	XuiRenderGetDevice @2095
	XuiRenderRestoreState @2096
	XuiElementGetFullXForm @2097
	XuiRenderGetViewTransform @2098
	XuiRenderGetColorSpace @2099
	XamPngEncode @2100
	XamPngDecode @2101
	XamPngEncodeEx @2102
	XuiTextElementMeasureText @2103
	XamLoaderShouldConfirmReboot @2104
	XamLoaderRebootToDash @2105
	XamNuiHudGetEngagedTrackingID @2106
	XamLoaderLaunchTitleForReason @2107
	XamNuiHudSetEngagedTrackingID @2108
	XuiBrushGetTexture @2109
	XuiBrushGetDims @2110
	XuiElementGetDescendantById @2111
	XamLoaderIsKinectUIPreferredForLogonTitle @2112
	XamAccountRecoveryGetSetTitleSyncTime @2120
	XamReadBiometricData @2121
	XamWriteBiometricData @2122
	XamD3DResourceDescriptorCreate @2123
	XamD3DResourceDescriptorAddRef @2124
	XamD3DResourceDescriptorRelease @2125
	XamD3DResourceAddRef @2126
	XamD3DResourceSet @2127
	XamD3DResourceIsBusy @2128
	XamD3DResourceRelease @2129
	ControlPackGetCursorPosition @2130
	ControlPackShouldShowCursor @2131
	XamFlushAgraTemperatureReport @2136
	XamNatalDeviceAudioCalibrate @2137
	XamNuiIdentityGetEnrollmentInfo @2138
	XamNuiIdentityUnenroll @2139
	XamNuiIdentityGetColorTexture @2140
	XamReportKinectSettingsChangedEvent @2141
	XamNuiEnableChatMic @2142
	XamNuiIsChatMicEnabled @2143
	XamNuiGetDepthCalibration @2144
	XamNuiStoreDepthCalibration @2145
	XamUserNuiIsBiometricEnabled @2146
	XamUserNuiEnableBiometric @2147
	XamNuiCameraSetFlags @2148
	XamNuiCameraRememberFloor @2149
	XamUserNuiGetUserIndexForBind @2150
	XamUserNuiGetUserIndexForSignin @2151
	XamUserNuiBind @2152
	XamUserNuiGetUserIndex @2153
	XamUserNuiGetEnrollmentIndex @2154
	XamUserNuiUnbind @2155
	XamNuiUseTemporaryDepthCalibration @2156
	XamNuiCameraTiltSetCallback @2157
	XamNuiHudIsEnabled @2158
	XamNuiCameraGetTiltControllerType @2159
	XamNuiCameraTiltGetStatus @2160
	XamNuiIdentityGetQualityFlags @2161
	XamNuiIdentityEnrollForSignIn @2162
	XamNuiIdentityGetSessionId @2163
	XamNuiIdentityIdentifyWithBiometric @2164
	ControlPackGetHandleManager @2165
	XamEnableNuiAutomation @2166
	XamNuiGetSystemGestureControl @2167
	XamGetPasscodeKeyFromVirtualKey @2168
	XamEnableNatalPlayback @2169
	XamIsNuiAutomationEnabled @2170
	XamIsNatalPlaybackEnabled @2171
	XamNuiHudInterpretFrame @2172
	XamNuiHudEnableInputFilter @2173
	XamUserNuiIsBiometricAugmentRecommended @2174
	XamNuiHudGetInitializeFlags @2175
	XamNuiCameraElevationSetAngle @2176
	XamNuiCameraElevationGetAngle @2177
	XamNuiCameraElevationAutoTilt @2178
	XamNuiCameraElevationStopMovement @2179
	XamNuiCameraElevationSetCallback @2180
	XamNuiGetDeviceStatus @2181
	XamNuiNatalCameraUpdateStarting @2182
	XamNuiNatalCameraUpdateComplete @2183
	XamNuiHudGetVersions @2184
	XamGetHUDElementByPath @2185
	XamGetHUDElementByAutoId @2186
	XuiElementGetScreenPositionCenter @2187
	XamNuiCameraElevationReverseAutoTilt @2188
	ControlPackSimpleCursorGetRayFromScreenPosition @2189
	ControlPackSideNavControlGetNuiHandle @2190
	XamFindHUDElementByXuiId @2191
	XamNuiIsDeviceReady @2192
	XamNuiSetForceDeviceOff @2193
	XamNuiPlayerEngagementUpdate @2194
	XamNuiSkeletonGetBestSkeletonIndex @2195
	XamNuiSkeletonScoreUpdate @2196
	XamNuiCameraTiltReportStatus @2197
	XamNuiCameraAdjustTilt @2198
	XamNuiIdentityAbort @2199
;	D3DDevice_CreateVertexShader @2200
;	D3DDevice_CreatePixelShader @2201
;	D3DDevice_CreateTexture @2202
	D3DDevice_CreateVertexBuffer @2203
	D3DDevice_CreateIndexBuffer @2204
;	D3DDevice_CreateVertexDeclaration @2205
	D3DVertexBuffer_Unlock @2206
	D3DVertexBuffer_Lock @2207
	D3DIndexBuffer_Unlock @2208
	D3DIndexBuffer_Lock @2209
	D3DTexture_UnlockRect @2210
	D3DTexture_LockRect @2211
;	D3DDevice_Clear @2212
	D3DDevice_SetViewport @2213
	D3DDevice_GetViewport @2214
;	D3DDevice_SetRenderState_SrcBlend @2215
;	D3DDevice_SetRenderState_DestBlend @2216
;	D3DResource_Release @2218
;	D3DDevice_Release @2219
;	D3DDevice_SetVertexShader @2220
;	D3DDevice_SetPixelShader @2221
;	D3DDevice_SetTexture @2222
;	D3DDevice_SetVertexDeclaration @2223
	D3DDevice_SetIndices @2224
	D3DDevice_SetStreamSource @2225
	D3DDevice_DrawVertices @2226
;	D3DDevice_DrawVerticesUP @2227
	D3DDevice_DrawIndexedVertices @2228
	D3DDevice_DrawIndexedVerticesUP @2229
;	D3DDevice_SetVertexShaderConstantF_ParameterCheck @2230
	D3DDevice_SetPixelShaderConstantF_ParameterCheck @2231
;	D3DDevice_SetSamplerState_ParameterCheck @2232
;	D3DDevice_SetRenderState_ParameterCheck @2233
;	D3DDevice_GetRenderState_ParameterCheck @2234
;	D3DDevice_SetVertexShaderConstantFN @2235
	D3DDevice_SetPixelShaderConstantFN @2236
;	D3DDevice_GetRenderState_ZEnable @2237
;	D3DDevice_GetRenderState_CullMode @2238
;	D3DDevice_GetRenderState_AlphaBlendEnable @2239
;	D3DDevice_GetRenderState_SrcBlendAlpha @2240
;	D3DDevice_GetRenderState_DestBlendAlpha @2241
;	D3DDevice_GetRenderState_BlendOp @2242
;	D3DDevice_GetRenderState_ViewportEnable @2243
;	D3DDevice_SetRenderState_ZEnable @2244
;	D3DDevice_SetRenderState_CullMode @2245
;	D3DDevice_SetRenderState_AlphaBlendEnable @2246
;	D3DDevice_SetRenderState_SrcBlendAlpha @2247
;	D3DDevice_SetRenderState_DestBlendAlpha @2248
;	D3DDevice_SetRenderState_BlendOp @2249
;	D3DDevice_SetRenderState_ViewportEnable @2250
;	D3DDevice_SetSamplerState_MagFilter @2251
;	D3DDevice_SetSamplerState_MinFilter @2252
	D3DDevice_SetSamplerState_AddressU @2253
	D3DDevice_SetSamplerState_AddressV @2254
;	XGSetTextureHeader @2255
;	XGGetTextureDesc @2256
	XGOffsetResourceAddress @2257
;	D3DResource_AddRef @2258
	XGSetTextureHeaderEx @2262
;	D3DDevice_GetRenderTarget @2263
	D3DDevice_SetRenderTarget @2264
	D3DDevice_GetDepthStencilSurface @2265
	D3DDevice_SetDepthStencilSurface @2266
;	D3DDevice_Resolve @2267
	D3DDevice_SetPixelShaderConstantB @2268
	XamNuiGetDeviceSerialNumber @2269
	XamNuiGetLoadedDepthCalibration @2270
	XamNuiGetTrueColorInfo @2271
	XamNuiGetCameraIntrinsics @2272
	XamNuiGetFanRate @2273
	XamNuiGetSupportString @2274
	XamKinectGetHardwareType @2275
	XamXtwManagerGetVariableCount @2300
	XamXtwManagerGetId @2301
	XamXtwManagerGetValue @2302
	XamXtwManagerSetValue @2303
	XamXtwManagerIncrement @2304
	XamXtwManagerDecrement @2305
	XamXtwManagerResetValue @2306
	XamXtwManagerResetAll @2307
	XamXtwManagerGetDataFilePath @2308
	XamXtwManagerDeleteDataFile @2309
	XamXtwManagerSave @2310
	XamXtwManagerLoad @2311
	XamGetXTweakManager @2312
	XamMediaVerificationCreate @2491
	XamMediaVerificationClose @2492
	XamMediaVerificationVerify @2493
	XamMediaVerificationFailedBlocks @2494
	XamMediaVerificationInject @2495
	XamShowBadDiscErrorUI @2496
	XamBackgroundDownloadSetMode @2500
	XamBackgroundDownloadIsEnabled @2501
	XamBackgroundDownloadGetActiveItem @2502
	XamBackgroundDownloadGetItems @2503
	XamBackgroundDownloadClearItems @2504
	XamBackgroundDownloadItemAdd @2505
	XamBackgroundDownloadItemRemove @2506
	XamBackgroundDownloadItemMakeFirst @2507
	XamBackgroundDownloadSetForegroundPriority @2508
	XamBackgroundDownloadGetForegroundPriority @2509
	XamBackgroundDownloadItemToContentData @2510
	XamBackgroundDownloadItemGetStatus @2511
	XamBackgroundDownloadHistoryGetItem @2512
	XamBackgroundDownloadItemGetHistoryStatus @2513
	XamBackgroundDownloadItemSetHistoryStatus @2514
	XamBackgroundDownloadItemGetStatusAsync @2515
	XamBackgroundDownloadItemGetStatusEx @2516
	XamBackgroundDownloadItemGetHistoryStatusEx @2517
	XamBackgroundDownloadBindItems @2518
	XamBackgroundDownloadSetPollingActive @2519
	XamBackgroundDownloadGetPollingActive @2520
	XamBackgroundDownloadGetMode @2521
	XamBackgroundDownloadGetUnexpectedChangeCount @2522
	XamBackgroundDownloadIsItemForThisConsole @2523
	XamBackgroundDownloadSelectDevice @2524
	XamBackgroundDownloadItemModify @2525
	XamBackgroundDownloadCacheLegacyMappingInfo @2526
	XamBackgroundDownloadGetLegacyMappingInfo @2527
	XamBackgroundDownloadGetLegacyId @2528
	XamBackgroundDownloadDoFail @2529
	XamSwapDisc @2600
	XamSwapDiscPatchAddress @2601
	XamSwapCancel @2602
	XamRamDriveCreate @2610
	XamRamDriveDestroy @2611
	XamPlayTimerGetData @2650
	XamPlayTimerSetData @2651
	XamPlayTimerResume @2652
	XamPlayTimerSuspend @2653
	XamPlayTimerIsRunning @2654
	XamPlayTimerIsEnabled @2655
	XamPlayTimerGetNextResetDate @2656
	XamPlayTimerFormatDurationString @2657
	XamPlayTimerGetTimeRemaining @2658
	XamPlayTimerUpdateTimeRemaining @2659
	XamPlayTimerForceNotification @2660
	XamPlayTimerRefreshResetDate @2661
	UpnpAVServerSearchInitialize @2670
	UpnpAVServerSearchDestroy @2671
	UpnpAVServerSearchStart @2672
	Destroy_CUpnpAVServerSearch @2673
	UpnpAVServerSearchDoWork @2674
	UpnpAVServerSearchGetNextServer @2675
	XCustomBroadcastGamercardEvent @2700
	XamCustomGetCurrentActions @2701
	XamInstrumentationLogEvent @2720
	XamRegisterSMCNotification @2721
	XamInstrumentationLogEventEx @2730
	XamInstrumentationGetSourceConfig @2731
	XamInstrumentationDebugConfig @2732
	CurlCreateCacheEntry @2780
	CurlOpenCacheEntry @2781
	CurlSetCacheEntryExpireTime @2782
	CurlReadCacheEntryHeaders @2783
	CurlReadCacheEntryContent @2784
	CurlWriteCacheEntryContent @2785
	CurlCloseCacheEntry @2786
	CurlEnumerateCacheEntry @2787
	CurlWipeBackingFiles @2789
	CurlOpenTitleBackingFile @2791
	XamSetSecurityViolationDetected @2800
	XamIsSecurityViolationDetected @2801
	XamIsAnySecurityViolationDetected @2802
	XamGetSecurityViolationsDetected @2803
	XamActivateCounterMeasure @2804
	XamDeactivateCounterMeasure @2805
	XamIsCounterMeasureActivated @2806
	XamGetActiveCounterMeasures @2807
	XamPmdIdentify @2808
	XamPmdSendCommand @2809
	XamPmdReadReport @2810
	XamPartyCreate @2812
	XamPartyLeave @2813
	XamPartySendInviteDeprecated @2814
	XamPartyGetUserList @2815
	XamPartySendGameInvites @2816
	XamPartyJoin @2817
	XamPartyKickUser @2818
	XamPartyAddLocalUsers @2819
	XamConvertEmoticons @2820
	XamGetLocaleTimeFormat @2821
	XamPartyRemoveLocalUsers @2822
	XamPartyGetUserListInternal @2823
	XamPartySetJoinable @2824
	XamPartyGetJoinable @2825
	XamPartyGetInfo @2826
	XamPartySetCustomData @2827
	XamPartySetConnectivityGraph @2828
	XamPartyGetRoutingTable @2829
	XamPartyAutomationInprocCall @2830
	XamPartyGetState @2831
	XamPartyGetBandwidth @2832
	XamPartyGetNetworkCounters @2833
	XamShowQuickLaunchUI @2834
	XamPartyIsCoordinator @2835
	XamPartyGetFormation @2836
	XamPartySendInvite @2837
	XamPartySetTestDelay @2838
	XamPartyOverrideNatType @2839
	XamPartyGetAccessLevel @2840
	XamPartySetTestFlags @2841
	XamIsSystemExperienceTitleId @2842
	XamPartyJoinEx @2843
	XamPartyGetInfoEx @2844
	XamTaskSetCancelSubTasks @2850
	XamTaskGetCompletionStatus @2851
	XamTaskCancelWaitAndCloseWaitTask @2852
	XamWebInstrumentationCreateReport @2860
	XamWebInstrumentationSetUserVar @2861
	XamWebInstrumentationSetUserVarNoEscape @2862
	XamWebInstrumentationGetURL @2863
	XamWebInstrumentationSendReport @2864
	XamWebInstrumentationDestroyReport @2865
	XamWebInstrumentationCreateSampledReport @2866
	XampSetSamplingRandomValue @2867
	XampWebInstrumentationSetProfileCounts @2868
	XamWebInstrumentationGetURLEx @2869
	XampSetOmnitureCallbackFunction @2870
	XamShowQuickChatUIp @2871
	XamShowSocialPostUI @2872
	XamShowBeaconsUI @2873
	XamShowMarketplacePurchaseOrderUI @2874
	XamShowMarketplaceGetOrderReceipts @2875
	XamShowGenericOnlineAppUI @2876
	XamUserAllowedToPostToSocialNetwork @2877
	XamShowMarketplacePurchaseOrderUIEx @2878
	XamVerifyXSignerSignature @2890


```

`XenonDumper/libs/xkelib/xam/xamext21173.0.def`:

```def
LIBRARY xam.xex@21173.0+1861.0
EXPORTS
;	NetDll_WSAStartup @1
;	NetDll_WSACleanup @2
;	NetDll_socket @3
;	NetDll_closesocket @4
;	NetDll_shutdown @5
;	NetDll_ioctlsocket @6
;	NetDll_setsockopt @7
;	NetDll_getsockopt @8
;	NetDll_getsockname @9
;	NetDll_getpeername @10
;	NetDll_bind @11
;	NetDll_connect @12
;	NetDll_listen @13
;	NetDll_accept @14
;	NetDll_select @15
;	NetDll_WSAGetOverlappedResult @16
;	NetDll_WSACancelOverlappedIO @17
;	NetDll_recv @18
;	NetDll_WSARecv @19
;	NetDll_recvfrom @20
;	NetDll_WSARecvFrom @21
;	NetDll_send @22
;	NetDll_WSASend @23
;	NetDll_sendto @24
;	NetDll_WSASendTo @25
;	NetDll_inet_addr @26
;	NetDll_WSAGetLastError @27
;	NetDll_WSASetLastError @28
;	NetDll_WSACreateEvent @29
;	NetDll_WSACloseEvent @30
;	NetDll_WSASetEvent @31
;	NetDll_WSAResetEvent @32
;	NetDll_WSAWaitForMultipleEvents @33
;	NetDll___WSAFDIsSet @34
;	NetDll_WSAEventSelect @35
;	NetDll_WSAStartupEx @36
;	NetDll_XNetStartup @51
;	NetDll_XNetCleanup @52
;	NetDll_XNetRandom @53
;	NetDll_XNetCreateKey @54
;	NetDll_XNetRegisterKey @55
;	NetDll_XNetUnregisterKey @56
;	NetDll_XNetXnAddrToInAddr @57
;	NetDll_XNetServerToInAddr @58
;	NetDll_XNetTsAddrToInAddr @59
;	NetDll_XNetInAddrToXnAddr @60
;	NetDll_XNetInAddrToServer @61
;	NetDll_XNetInAddrToString @62
;	NetDll_XNetUnregisterInAddr @63
;	NetDll_XNetXnAddrToMachineId @64
;	NetDll_XNetConnect @65
;	NetDll_XNetGetConnectStatus @66
;	NetDll_XNetDnsLookup @67
;	NetDll_XNetDnsRelease @68
;	NetDll_XNetQosListen @69
;	NetDll_XNetQosLookup @70
;	NetDll_XNetQosServiceLookup @71
;	NetDll_XNetQosRelease @72
;	NetDll_XNetGetTitleXnAddr @73
;	NetDll_XNetGetDebugXnAddr @74
;	NetDll_XNetGetEthernetLinkStatus @75
;	NetDll_XNetGetBroadcastVersionStatus @76
;	NetDll_XNetQosGetListenStats @77
;	NetDll_XNetGetOpt @78
;	NetDll_XNetSetOpt @79
;	NetDll_XNetStartupEx @80
;	NetDll_XNetReplaceKey @81
;	NetDll_XNetGetXnAddrPlatform @82
	NetDll_XNetGetSystemLinkPort @83
	NetDll_XNetSetSystemLinkPort @84
;	NetDll_XNetDnsReverseLookup @85
;	NetDll_XNetDnsReverseRelease @86
;	NetDll_XnpLoadConfigParams @101
;	NetDll_XnpSaveConfigParams @102
;	NetDll_XnpConfigUPnP @103
;	NetDll_XnpConfig @104
;	NetDll_XnpGetConfigStatus @105
;	NetDll_XnpLoadMachineAccount @106
;	NetDll_XnpSaveMachineAccount @107
;	NetDll_XnpCapture @108
;	NetDll_XnpEthernetInterceptSetCallbacks @109
;	NetDll_XnpEthernetInterceptXmit @110
;	NetDll_XnpEthernetInterceptRecv @111
;	NetDll_XnpLogonGetStatus @112
;	NetDll_XnpLogonGetQFlags @113
;	NetDll_XnpLogonSetQFlags @114
;	NetDll_XnpLogonSetQEvent @115
;	NetDll_XnpLogonClearQEvent @116
;	NetDll_XnpLogonGetQVals @117
;	NetDll_XnpLogonSetQVals @118
;	NetDll_XnpLogonSetPState @119
;	NetDll_XnpGetVlanXboxName @120
;	NetDll_XnpSetVlanXboxName @121
;	NetDll_XnpGetActiveSocketList @122
;	NetDll_XnpNoteSystemTime @123
;	NetDll_XnpRegisterKeyForCallerType @124
;	NetDll_XnpUnregisterKeyForCallerType @125
;	NetDll_XnpLogonGetChallenge @126
;	NetDll_XnpLogonClearChallenge @127
;	NetDll_XnpLogonSetChallengeResponse @128
;	NetDll_XnpGetSecAssocList @129
;	NetDll_XnpGetKeyList @130
;	NetDll_XnpGetQosLookupList @131
;	NetDll_XnpPersistTitleState @132
;	NetDll_XnpReplaceKeyForCallerType @133
;	NetDll_XnpEthernetInterceptSetExtendedReceiveCallback @134
;	NetDll_XnpQosHistoryLoad @135
;	NetDll_XnpQosHistorySaveMeasurements @136
;	NetDll_XnpQosHistoryGetEntries @137
;	NetDll_XnpQosHistoryGetAggregateMeasurement @138
;	NetDll_XnpToolSetCallbacks @139
;	NetDll_XnpToolIpProxyInject @140
;	NetDll_XnpUpdateConfigParams @141
;	NetDll_XnpEthernetInterceptXmitAsIp @142
;	NetDll_XnpConfigUPnPPortAndExternalAddr @143
;	NetDll_XmlDownloadStart @151
;	NetDll_XmlDownloadContinue @152
;	NetDll_XmlDownloadStop @153
;	NetDll_XmlDownloadGetParseTime @154
;	NetDll_XmlDownloadGetReceivedDataSize @155
;	XnpGetXwppMemoryLogSnapshot @198
;	XnpGetXwppRuntimeFilter @199
;	NetDll_XHttpStartup @201
;	NetDll_XHttpShutdown @202
;	NetDll_XHttpOpen @203
;	NetDll_XHttpCloseHandle @204
;	NetDll_XHttpConnect @205
;	NetDll_XHttpSetStatusCallback @206
;	NetDll_XHttpOpenRequest @207
;	NetDll_XHttpOpenRequestUsingMemory @208
;	NetDll_XHttpSendRequest @209
;	NetDll_XHttpReceiveResponse @210
;	NetDll_XHttpQueryHeaders @211
;	NetDll_XHttpReadData @212
;	NetDll_XHttpWriteData @213
;	NetDll_XHttpQueryOption @214
;	NetDll_XHttpSetOption @215
;	NetDll_XHttpDoWork @216
;	NetDll_XHttpSetCredentials @217
;	NetDll_XHttpQueryAuthSchemes @218
;	NetDll_XHttpCrackUrlW @219
;	NetDll_XHttpCrackUrl @220
;	NetDll_XHttpCreateUrl @221
;	NetDll_XHttpCreateUrlW @222
;	NetDll_UpnpStartup @251
;	NetDll_UpnpCleanup @252
;	NetDll_UpnpSearchCreate @253
;	NetDll_UpnpSearchGetDevices @254
;	NetDll_UpnpDescribeCreate @255
;	NetDll_UpnpDescribeGetResults @256
;	NetDll_UpnpActionCalculateWorkBufferSize @257
;	NetDll_UpnpActionCreate @258
;	NetDll_UpnpActionGetResults @259
;	NetDll_UpnpEventCreate @260
;	NetDll_UpnpEventGetCurrentState @261
;	NetDll_UpnpEventUnsubscribe @262
;	NetDll_UpnpDoWork @263
;	NetDll_UpnpCloseHandle @264
;	XNetLogonGetLoggedOnUsers @301
;	XNetLogonGetNatType @302
;	XNetLogonTaskStart @303
;	XNetLogonTaskClose @304
;	XNetLogonTaskContinue @305
;	XNetLogonGetServiceInfo @306
;	XNetLogonGetUserPrivileges @307
;	XNetLogonSetConsoleCertificate @308
;	XNetLogonGetMachineID @309
;	XNetLogonGetTitleID @310
;	XNetLogonGetTitleVersion @311
;	XNetLogonGetServiceNetworkID @312
;	XNetLogonGetDnsString @313
;	XNetLogonSetTitleID @314
;	XNetLogonGetExtendedStatus @315
;	XNetLogonClearTicketCaches @316
;	XNetLogonInitOverrideInfo @317
;	XNetLogonGetLastUPnPStatus @318
;	XNetLogonGetFlowToken @319
;	XNetLogonGetTicketOpt @320
;	XNetLogonSetTicketOpt @321
;	XNetLogonGetState @322
;	XamInputGetCapabilities @400
;	XamInputGetState @401
;	XamInputSetState @402
;	XamInputGetKeystroke @403
;	XamInputEnableAutobind @404
;	XamInputRawState @405
;	XamEnableSystemAppInput @406
	XamInputGetDeviceStats @407
;	XamInputGetKeystrokeEx @408
;	XamInputGetKeystrokeHud @409
;	XamInputSetLayoutKeyboard @410
;	XamInputToggleKeyLocks @411
;	XamInputResetLayoutKeyboard @412
;	XamInputGetKeystrokeHudEx @413
;	XamInputSetKeyboardTranslationHud @414
;	XamSetInactivityTime @415
;	XamEnableInactivityProcessing @416
;	XamResetInactivity @417
;	XamSetInactivityTimeFromConfig @418
	XamLoaderGetMediaInfo @419
	XamLoaderLaunchTitle @420
	XamLoaderLaunchTitleEx @421
	XamLoaderSetLaunchData @422
	XamLoaderGetLaunchDataSize @423
	XamLoaderGetLaunchData @424
	XamLoaderTerminateTitle @425
	XamLoaderGetDvdTrayState @426
	XamLoaderGetGameInfo @427
	XamLoaderLaunchTitleOnDvd @428
	XamLoaderSetSpindleSpeed @429
;	XamTaskCreateQueue @430
;	XamTaskSchedule @431
;	XamTaskReschedule @432
;	XamTaskCloseHandle @433
;	XamTaskCancel @434
;	XamTaskShouldExit @435
;	XamTaskWaitOnCompletion @436
;	XamTaskModify @437
;	XamTaskGetCurrentTask @438
;	XamTaskGetAttributes @439
;	XamExecutingOnBehalfOfTitle @440
;	XamInputSendStayAliveRequest @441
;	XamInputGetUserVibrationLevel @442
;	XamIsSystemTitleId @443
	XamLoaderIsTitleTerminatePending @444
;	XamInputSetTextMessengerIndicator @445
	XamLoaderGetPriorTitleId @446
;	XamIsXbox1TitleId @447
;	XamInputSetKeyLocks @448
;	XamInputGetKeyLocks @449
;	XamTaskGetStatus @450
;	XamGetRootObj @451
	XamDevAuthSetFault @452
;	XamGetDefaultSystemImage @453
;	XamGetWCNConfigFile @454
;	XamSetPowerMode @455
;	XamExecuteChallenge @456
;	XamGetDefaultImage @457
;	XamMuteSound @458
;	XamGetOnlineSchema @459
;	XamSetDashContext @460
	XamGetDashContext @461
;	XamIsCurrentTitleDash @462
;	XamGetCurrentTitleId @463
	XamSetCurrentTitleDash @464
	XamAllocHeapFreeSpace @465
;	XamSetDashContextEx @466
;	XamGetDashContextEx @467
;	XamSetHudContext @468
;	XamGetHudContext @469
;	Refresh@CGamerCardWorker @471
;	XCustomSetAction @472
;	XCustomGetLastActionPress @473
;	XCustomSetDynamicActions @474
;	XCustomBroadcastActionEvent @475
;	XCustomGetLastActionPressEx @476
;	XCustomRegisterDynamicActions @477
;	XCustomUnregisterDynamicActions @478
;	XCustomGetCurrentGamercard @479
;	XamDbgPrint @480
	XamDbgSetOutputLevel @481
	XamDbgSetBreakLevel @482
	XamLoaderGetMediaInfoEx @483
;	XamLoaderSetGameInfo @484
;	XamFormatMessage @485
;	XamUniSortCmpString @486
;	XamFormatTimeString @487
;	XamFormatDateString @488
;	XamGetLocaleDateFormat @489
;	XamAlloc @490
;	XamAllocEx @491
;	XamFree @492
;	XamAllocSize @493
;	ProcessRemoteInput@XAMAuditionHost @494
;	ProcessRemoteInput@XAMAuditionHost @495
;	XamAllocFreeIPTVHeap @496
;	XamDeviceRemap @497
;	XamLoaderGetClearCache @498
;	XamLoaderSetClearCache @499
;	XMsgInProcessCall @500
;	XMsgCompleteIORequest @501
;	XMsgSystemProcessCall @502
;	XMsgStartIORequest @503
;	XMsgCancelIORequest @504
;	XMsgAcquireAsyncMessageFromOverlapped @505
;	XMsgReleaseAsyncMessageToOverlapped @506
;	XamGetOverlappedResult @507
;	XMsgStartIORequestEx @508
;	XamAppAllocateInterappWorkspace @509
;	XamAppGetInterappWorkspace @510
;	XamAppFreeInterappWorkspace @511
;	XamFeatureEnabled @512
;	XamFeatureEnforceImageBudget @513
;	XamFeatureSetMask @514
;	XamFeatureEnableDisable @515
	XuiControlSetItemAssociation @516
;	XamGetTitleGlobalStorageValue @517
;	XamSetTitleGlobalStorageValue @518
;	XamUserValidateAvatarMetadata @519
;	XamUserGetDeviceContext @520
	XamUserLookupDevice @521
;	XamUserGetXUID @522
;	XamUserLogon @523
;	XamUserGetGamerTag @524
;	XamUserGetUserIndexMask @525
;	XamUserGetName @526
	XamLookupCommonStringByIndex @527
;	XamUserGetSigninState @528
;	XamUserGetIndexFromXUID @529
;	XamUserCheckPrivilege @530
;	XamUserAreUsersFriends @531
;	XamSetUserPresetPresenceState @532
;	XamGetUserPresetPresenceState @533
;	XamUserGetUserFlagsFromXUID @534
;	XamUserGetMembershipTypeFromXUID @535
;	XamUserGetOnlineCountryFromXUID @536
;	XamUserReadProfileSettings @537
;	XamUserWriteProfileSettings @538
;	XamUserGetMembershipType @539
;	XamUserGetUserFlags @540
;	XamUserGetRequestedUserIndexMask @541
;	XamUserIsGuest @542
;	XamUserProfileSync @543
;	XamUserFlushLogonQueue @544
;	XamUserIsOnlineEnabled @545
;	XamUserGetCachedUserFlags @546
;	XamAreMixedAccountsSignedIn @547
;	XamUserLogonEx @548
;	XamSetUserShowMessengerFriends @549
;	XamGetUserShowMessengerFriends @550
;	XamUserGetSigninInfo @551
;	XamUserIsPartial @552
;	XamUserGetOnlineLanguageFromXUID @553
;	XamUserReadProfileSettingsEx @554
;	XamSystemUpdaterLogon @555
;	XamUserGetUsersMissingAvatars @556
;	XamIsChildAccountSignedIn @557
;	XamUserPrefetchProfileSettings @558
;	XamUserInvalidateProfileSetting @559
;	XamProfileCreate @560
;	XamProfileCreateEnumerator @561
;	XamProfileEnumerate @562
;	XamProfileDelete @563
;	XamProfileGetCreationStatus @564
;	XamProfileFindAccount @565
;	XamProfileRenameAccount @566
;	XamProfileOpen @567
;	XamProfileClose @568
;	XamProfileSaveAccountInfo @569
;	XamProfileLoadAccountInfo @570
;	XamProfileRecoverTitle @571
;	XamProfileSaveWindowsLiveCredentials @572
;	XamProfileLoadWindowsLiveCredentials @573
;	XamProfileIsSaveWindowsLiveCredsEnabled @574
;	XamProfileSetSaveWindowsLiveCredsEnabled @575
	XamSetProfileReadTestHook @576
;	XamProfileGetLastSync @577
;	XamAccountRecoveryRecoverTitle @578
	XamProfileControlXgi @579
;	XamAppLoad @580
;	XamAppUnloadSelf @581
;	XamAppUnloadStack @582
;	XamSendMessageToLoadedApps @583
;	XamAppRequestLoad @584
;	XamAppUnrequestLoad @585
;	XamNavigate @586
;	XamRegisterSysApp @587
;	XamUnregisterSysApp @588
;	XamCreateEnumeratorHandle @590
;	XamGetPrivateEnumStructureFromHandle @591
;	XamEnumerate @592
;	XamLoadSysApp @593
;	XamUnloadSysApp @594
;	XamReloadSysApp @595
;	XamAppLoadPass2SysApps @596
;	XamProfileGetLiveLegalLocale @597
;	XamUserIsParentalControlled @598
	XamContentLaunchImageFromFileInternal @599
;	XamContentCreate @600
;	XamContentCreateEx @601
;	XamContentClose @602
;	XamContentDelete @603
;	XamContentCreateEnumerator @604
;	XamContentCreateDeviceEnumerator @605
;	XamContentGetDeviceData @606
;	XamContentGetDeviceName @607
;	XamContentSetThumbnail @608
;	XamContentGetThumbnail @609
;	XamContentGetCreator @610
;	XamContentLaunchImage @611
;	XamContentGetAttributes @612
;	XamContentGetDeviceState @613
;	XamContentGetLicenseMask @614
;	XamContentFlush @615
;	XamContentResolve @616
;	XamContentOpenFile @617
;	XamContentInstall @618
;	XamContentLockUnlockPackageHeaders @619
;	XamContentCopyInternal @620
;	XamContentMoveInternal @621
;	XamContentGetMetaDataInternal @622
;	XamContentCreateEnumeratorInternal @623
;	XamContentDeleteInternal @624
;	XamContentCreateInternal @625
;	XamContentSetThumbnailInternal @626
;	XamContentLaunchImageInternal @627
;	XamContentWritePackageHeader @628
;	XamContentDismountAndClosePackage @629
;	XamContentResolveInternal @630
;	XamContentGetAttributesInternal @631
;	XamContentOpenFileInternal @632
;	XamContentAggregateCreateEnumerator @633
;	XamContentCreateAndMountPackage @634
;	XamContentOpenPackageFile @635
;	XamContentMountPackage @636
;	XamContentFlushPackage @637
;	XamContentClosePackageFile @638
;	XamContentDuplicateFileHandle @639
;	XamGetExecutionId @640
;	XamGetGameRatings @641
;	XamGetSystemVersion @642
;	XamContentGetLocalizedString @643
;	XamContentGetDefaultDevice @644
;	XamContentInstallInternal @645
;	XamContentSetMediaMetaDataInternal @646
;	XamContentGetDeviceSerialNumber @647
;	XamContentGetMountedPackageByRootName @648
;	XamContentRegisterChangeCallback @649
;	XamNotifyCreateListener @650
;	XNotifyGetNext @651
;	XNotifyPositionUI @652
;	XNotifyDelayUI @653
;	XNotifyBroadcast @654
;	XNotifyRegisterArea @655
	XNotifyQueueUI @656
;	XamNotifyCreateListenerInternal @657
;	XNotifyUISetOptions @658
;	XNotifyUIGetOptions @659
;	XamContentLaunchImageInternalEx @660
;	XamShutdown @661
;	XamAllocDevkitHeapAvailable @662
;	XamNotifyCreateListenerRangeInternal @663
;	XNotifyQueueUIEx @664
;	XamAppRequestLoadEx @665
	XuiPNGTextureLoader @666
	XuiRenderGetXuiDevice @667
	XuiDefault_False @668
;	XamUserGetReportingInfo @669
;	XamUpdateStart @670
;	XamUpdateGetProgress @671
;	XamUpdateFinish @673
;	XamUpdateAttachExtenderInstance @674
;	XamUpdateGetBaseSystemVersion @678
;	XamUpdateGetCurrentSystemVersion @679
;	XamUpdateChainPass3FromPass2 @683
;	XamInputGetCapabilitiesEx @685
;	XamUserIsUnsafeProgrammingAllowed @686
	XamDevAuthSetFaultEx @687
;	XamUpdateGetData @688
	XamCacheIntegrityCheck @689
;	XamCacheStoreFile @690
;	XamCacheFetchFile @691
;	XamCacheOpenFile @692
;	XamCacheCloseFile @693
;	XamGetCachedTitleName @694
;	XamCacheReset @695
;	XamGetCachedGamerTag @696
;	XamGetCachedGamerTagW @697
;	XamCacheDeleteFile @698
	XamCacheRenameFile @699
;	XamShowSigninUI @700
;	XamShowSigninUIEx @701
;	XamShowSigninUIp @702
;	XamShowFriendsUI @703
;	XamShowMessagesUI @704
;	XamShowKeyboardUI @705
;	XamShowQuickChatUI @706
;	XamShowVoiceMailUI @707
;	XamShowGamerCardUI @708
;	XamShowAchievementsUI @709
;	XamShowPlayerReviewUI @710
;	XamShowMarketplaceUI @711
;	XamShowPlayersUI @712
;	XamShowUpdaterUI @713
;	XamShowMessageBoxUI @714
;	XamShowDeviceSelectorUI @715
;	XamShowMessageComposeUI @716
;	XamShowGameInviteUI @717
;	XamShowFriendRequestUI @718
;	XamShowCreateProfileUI @719
;	XamShowGamesUI @720
;	XamShowLiveSignupUI @721
;	XamShowFriendsUIp @722
;	XamShowComplaintUI @723
;	XamShowReputationUI @724
;	XamShowGamerCardUIForXUID @725
;	XamShowForcedNameChangeUI @726
;	XamShowLiveUpsellUI @727
;	XamShowPasscodeVerifyUI @728
;	XamShowDirtyDiscErrorUI @729
;	XamShowSignupCreditCardUI @730
;	XamShowPrivateChatInviteUI @731
;	XamShowMessageBoxUIEx @732
;	XamShowRecentMessageUI @733
;	XamShowRecentMessageUIEx @734
;	XamShowMessagesUIEx @735
;	XamShowAchievementDetailsUI @736
;	XamShowPersonalizationUI @737
;	XamShowChangeGamerTileUI @738
;	XamShowVoiceSettingsUI @739
;	XamShowVideoChatInviteUI @740
;	XamShowCustomMessageComposeUI @741
;	XamShowCustomPlayerListUI @742
;	XamShowMarketplaceDownloadItemsUI @743
;	XamShowMarketplaceUIEx @744
	XamShowMessageBox @745
;	XamIsSysUiInvokedByXenonButton @746
;	XamIsSysUiInvokedByTitle @747
;	XamIsUIActive @748
;	XamSysUiDisableAutoClose @749
;	XamUserCreateAchievementEnumerator @750
;	XamReadTile @751
;	XamWriteGamerTile @752
;	XamWriteTile @753
;	XamReadImage @754
;	XamUserCreateTitlesPlayedEnumerator @755
;	XamDecompressPNGToTexture @756
;	XamReadTileToTexture @757
;	XamReadString @758
;	XamUserCreateStatsEnumerator @759
;	XamPrepareGamerTiles @760
;	XamClearTitle @761
;	XamReadStrings @762
;	XamWriteGamerTileEx @763
;	XamReadTileEx @764
;	XamReadTileToTextureEx @765
;	XamShowMessengerUI @766
;	XamShowKeyboardUIMessenger @767
;	XamShowLiveUpsellUIEx @768
;	XamShowJoinSessionInProgressUI @769
;	XamShowGraduateUserUI @770
;	XamShowGamerCardUIForXUIDp @771
;	XamShowGuideUI @772
;	XamShowPartyUI @773
;	XamShowPartyInviteUI @774
;	XamUserAddRecentPlayer @775
;	XamUserUpdateRecentPlayer @776
;	XamUserCreatePlayerEnumerator @777
;	XamParseGamerTileKey @778
;	XamShowCommunitySessionsUI @779
;	XamVoiceCreate @780
;	XamVoiceHeadsetPresent @781
;	XamVoiceSubmitPacket @782
;	XamVoiceClose @783
;	XamVoiceGetBatteryStatus @784
;	Refresh@CGamerCardWorker @785
;	Refresh@CGamerCardWorker @786
;	XamShowJoinSessionByIdInProgressUI @787
;	XamShowPartyJoinInProgressUI @788
;	XamBuildSharedSystemResourceLocator @789
;	XamSessionCreateHandle @790
;	XamSessionRefObjByHandle @791
;	XamVoiceGetMicArrayStatus @792
;	XamVoiceSetAudioCaptureRoutine @793
;	XamVoiceGetDirectionalData @794
;	XamBuildResourceLocator @795
;	XamBuildLegacySystemResourceLocator @796
;	XamBuildGamercardResourceLocator @797
;	XamBuildDynamicResourceLocator @798
;	XamBuildXamResourceLocator @799
	XuiAnimRun @800
	XuiApplyLocale @801
	XuiBubbleMessage @802
	XuiControlIsBackButton @803
	XuiControlIsNavButton @804
	XuiCreateObject @805
	XuiDestroyObject @806
	XuiDynamicCast @807
	XuiElementAddChild @808
	XuiElementFindNamedFrame @809
	XuiElementGetChildById @810
	XuiElementGetFirstChild @811
	XuiElementGetFocus @812
	XuiElementGetFocusUser @813
	XuiElementGetId @814
	XuiElementGetLastChild @815
	XuiElementGetNext @816
	XuiElementGetParent @817
	XuiElementGetUserFocus @818
	XuiElementInitFocus @819
	XuiElementInitUserFocus @820
	XuiElementPlayTimeline @821
	XuiElementSetBounds @822
	XuiElementSetFocus @823
	XuiElementSetUserFocus @824
	XuiElementTreeGetFocus @825
	XuiFindClass @826
	XuiFreeStringTable @827
	XuiGetBaseObject @828
	XuiGetClass @829
	XuiGetObjectClass @830
	XuiGetOuter @831
	XuiInit @832
	XuiLoadFromBinary @833
	XuiLoadStringTableFromFile @834
	XuiVisualGetBasePath @835
	XuiLookupStringTable @836
	XuiNavButtonGetPressPath @837
	XuiObjectFromHandle @838
	XuiObjectGetProperty @839
	XuiObjectGetPropertyId @840
	XuiProcessInput @841
	XuiRegisterClass @842
	XuiRenderBegin @843
	XuiRenderCreateDC @844
	XuiRenderDCDeviceChanged @845
	XuiRenderDestroyDC @846
	XuiRenderEnd @847
	XuiRenderGetBackBufferSize @848
	XuiRenderInit @849
	XuiRenderInitShared @850
	XuiRenderPresent @851
	XuiRenderSetViewTransform @852
	XuiRenderUninit @853
;	XamShowNuiGuideUI @854
	XuiSceneCreate @855
	XuiSceneNavigateBack @856
	XuiSceneNavigateFirst @857
	XuiSceneNavigateForward @858
	XuiScenePlayBackFromTransition @859
	XuiScenePlayBackToTransition @860
	XuiScenePlayFromTransition @861
	XuiScenePlayToTransition @862
	XuiSendMessage @863
	XuiSetLocale @864
	XuiUninit @865
	XuiUnregisterClass @866
	XuiTextElementSetText @867
	XuiSetTimer @868
	XuiTimersRun @869
	XuiTextElementGetText @870
	XuiVisualSetBasePath @871
	XuiHandleIsValid @872
	XuiAlloc @873
	XuiFree @874
	XuiDefault_True @875
	XuiDefault_EmptyString @876
	XuiDefault_IntegerZero @877
	XuiCopyString @878
	XuiRealloc @879
	XuiControlPlayOptionalVisual @880
	XuiKillTimer @881
	XuiElementEnableInput @882
	XuiElementInputEnabled @883
	XuiIsInstanceOf @884
	XuiResourceComposeLocator @885
	XuiResourceLocatorIsAbsolute @886
	XuiBroadcastMessage @887
	XuiElementDisallowRecursiveTimelineControl @888
	XUIElementPropVal_Construct @889
	XUIElementPropVal_Destruct @890
	XUIElementPropVal_SetString @891
	XuiObjectSetProperty @892
	XuiElementGetOpacity @893
	XuiElementSetOpacity @894
	XuiEditSetTextLimit @895
	XuiEditGetTextLimit @896
	XuiSliderSetValue @897
	XuiSliderGetValue @898
	XuiSliderSetRange @899
	XuiElementUnlink @900
	XuiElementInsertChild @901
	XuiSceneNavigateBackToFirst @902
	XuiProgressBarSetRange @903
	XuiProgressBarSetValue @904
	XuiProgressBarGetValue @905
	XuiControlAttachVisual @906
	XuiCreateTextureBrush @907
	XuiDestroyBrush @908
	XUIElementPropVal_SetColorFromUint @909
	XuiFigureSetFill @910
	XuiSliderGetRange @911
	XuiFigureSetTexture @912
	XuiControlGetItemAssociation @913
	XuiResourceLoadAll @914
	XuiImageElementSetImagePath @915
	XuiImageElementGetImagePath @916
	XuiControlGetVisual @917
	XuiControlGetNavigation @918
	XuiLookupStringTableByIndex @919
	XUIElementPropVal_SetBool @920
	XuiElementHasFocus @921
	XUIElementPropVal_SetUint @922
	XUIElementPropVal_Clear @923
	XuiEditSetTextFormatInfo @924
	XuiCreateSolidBrush @925
	XuiSceneInterruptTransitions @926
	XuiResourceOpen @927
	XuiResourceRead @928
	XuiResourceClose @929
	XuiVisualCreateInstance @930
	XuiElementGetTimeline @931
;	GetCodecVersion@CCalMediaInfo @932
	XuiElementIsDescendant @933
	XuiSetMessageFilter @934
	XuiAttachTextureBrush @935
	XuiElementBeginRender @936
	XuiElementEndRender @937
	XuiDrawShape @938
	XuiSelectBrushEx @939
	XuiFigureGetShape @940
	XuiFillRect @941
	XuiVec2TransformCoord @942
	XuiMatrixMultiply @943
	XuiElementGetXForm @944
	XuiElementSetPosition @945
	XuiSelectBrush @946
	XuiElementRenderChildren @947
	XuiFreeUnusedTextures @948
	XuiListEnableItemOverride @949
	XuiListGetDefaultItemSize @950
	XuiResourceSeek @951
	XuiElementDiscardResources @952
	XuiTabSceneGoto @953
	XuiTabSceneGetCurrentTab @954
;	XamShowWhatsOnUI @955
;	XamShowEditProfileUI @956
;	XamShowStorePickerUI @957
;	XamShowTermsOfUseUI @958
;	XamShowJoinPartyUI @959
;	XamShowWordRegisterUI @960
;	XamOverrideHudOpenType @961
;	XamShowAchievementsUIEx @962
;	XamUserGetUserTenure @963
;	XamUserGetSubscriptionType @964
;	XamShowGameVoiceChannelUI @965
;	XamShowAvatarAwardsUI @966
;	XamShowAvatarAwardGamesUI @967
;	XamShowVideoRichPresenceUI @968
	XamHudGetUserIndex @969
;	XGetAudioFlags @970
;	XGetAVPack @971
;	XGetGameRegion @972
;	XGetLanguage @973
;	XapipGetLocale @974
;	XGetVideoFlags @975
;	XGetVideoStandard @976
;	XGetVideoMode @977
;	XamGetLanguage @978
	XUITimeline_Run @979
;	XamSetAutomation @980
;	XAutomationpBindController @981
;	XAutomationpUnbindController @982
;	XAutomationpInputXenonButton @983
;	XAutomationpInputPress @984
;	XAutomationpInputSetState @985
;	XamEnableOverdraw @986
;	g_XuiAutomation @987
;	XamVoiceGetMicArrayAudio @988
;	XampSystemInput @989
;	XamInputControl @990
	XuiElementGetPosition @991
;	XamIsMessageBoxActive @992
;	XamIsBackgroundSceneInTransition @993
	XuiElementTreeHasFocus @994
	XuiFigureClose @995
;	GamerCardStartup @996
;	GamerCardCleanup @997
;	GamerCardRegisterControls @998
;	GamerCardUnregisterControls @999
	RtlFindFirstFile @1000
	RtlFindNextFile @1001
	RtlGetModuleFileName @1002
;	RtlOutputDebugString @1003
	RtlRemoveDirectory @1004
	RtlSleep @1005
	RtlGetLastError @1006
	RtlSetLastError @1007
	RtlSetLastNTError @1008
	RtlDebugPrint @1009
;	RtlDebugError @1010
;	XDebugWarning @1011
	RtlDebugTrace @1012
	RtlDebugEntry @1013
	RtlDebugExit @1014
	RtlGetAttributesOnHeapAlloc @1015
	RtlSetAttributesOnHeapAlloc @1016
	XuiFigureSetShape @1017
	RtlCreateHeap @1018
	RtlDestroyHeap @1019
;	RtlAllocateHeap @1020
	RtlAllocateHeapSlowly @1021
;	RtlReAllocateHeap @1022
;	RtlFreeHeap @1023
	RtlFreeHeapSlowly @1024
;	RtlSizeHeap @1025
	RtlZeroHeap @1026
	RtlDebugWalkHeap @1027
	RtlWalkHeap @1028
	RtlLockHeap @1029
	RtlUnlockHeap @1030
;	RtlValidateHeap @1031
	RtlDebugCompactHeap @1032
	RtlCompactHeap @1033
	XamAppSetTestOption @1034
;	XamAppReportError @1035
;	XamIsNuiUIActive @1036
;	XamVerifyPasscode @1037
	OutputDebugStringA @1038
	DebugBreak @1039
	GetCurrentThreadId @1040
	XDebugError @1041
;	XDebugWarning @1042
	RtlDebugSetLevel @1043
	CloseHandle @1044
	GetTickCount @1045
	GetLastError @1046
	SetFilePointer @1047
	SetFilePointerEx @1048
	SetLastError @1049
	MultiByteToWideChar @1050
	WideCharToMultiByte @1051
	ReadFile @1052
	FlushFileBuffers @1053
	WriteFile @1054
	OutputDebugStringW @1055
	SetEvent @1056
	XapiFormatTimeOut @1057
	CreateMutexA @1058
	OpenMutexA @1059
	ReleaseMutex @1060
	WaitForSingleObject @1061
	WaitForSingleObjectEx @1062
	GetFileSize @1063
	GetFileSizeEx @1064
	XapiDirectoryInformationToFindData @1065
	XapiFormatObjectAttributes @1066
	ResetEvent @1067
	wsprintfA @1068
	wsprintfW @1069
	GetOverlappedResult @1070
	QueryPerformanceCounter @1071
	QueryPerformanceFrequency @1072
	LocalAlloc @1073
	LocalFree @1074
	RaiseException @1075
	RtlUniform @1076
	RtlRandom @1077
	Sleep @1078
	SleepEx @1079
	XMemSet @1080
	XRegisterThreadNotifyRoutine @1081
	XGetOverlappedExtendedError @1082
	XGetOverlappedResult @1083
	CreateThread @1084
	ResumeThread @1085
	ExitThread @1086
	GetTimeZoneInformation @1087
	GetSystemTimeAsFileTime @1088
	SystemTimeToFileTime @1089
	FileTimeToSystemTime @1090
	GetSystemTime @1091
	GetLocalTime @1092
	CreateDirectoryA @1093
	CreateEventA @1094
	CreateFileA @1095
	DeleteFileA @1096
	FindFirstFileA @1097
	FindNextFileA @1098
	GetFileAttributesA @1099
;	XamLoaderGetCurrentTitleD3DVersion @1100
	GetFileAttributesExA @1101
	GetModuleHandleA @1102
	GetDiskFreeSpaceExA @1103
	CopyFileA @1104
	SetEndOfFile @1105
;	XamFamilyAddParentalExemptionToList @1106
;	XamFamilyIsParentalValidationRequired @1107
;	Refresh@CGamerCardWorker @1108
;	Refresh@CGamerCardWorker @1109
;	PIXAddCounter @1110
;	Refresh@CGamerCardWorker @1111
	SetWaitableTimer @1112
	CancelWaitableTimer @1113
	CreateWaitableTimerA @1114
	DuplicateHandle @1115
	XapipCreateThread @1116
	lstrcpyA @1117
	lstrcpyW @1118
	lstrcpynA @1119
	lstrcpynW @1120
	lstrcatA @1121
	lstrcatW @1122
	lstrlenA @1123
	lstrlenW @1124
	IsBadReadPtr @1125
	IsBadWritePtr @1126
	FileTimeToLocalFileTime @1127
	XMemCpy @1128
	XMemCpyStreaming @1129
;	XamHudSetUserIndex @1130
;	XamShowNuiTroubleshooterUI @1131
	XamTestShowNuiTroubleshooterUI @1132
;	XamShowPasscodeVerifyUIEx @1133
;	XamShowNuiAchievementsUI @1134
;	XamShowNuiCommunitySessionsUI @1135
;	XamShowNuiDeviceSelectorUI @1136
;	XamShowNuiDirtyDiscErrorUI @1137
;	XamShowNuiFriendsUI @1138
;	XamShowNuiGameInviteUI @1139
;	XamShowNuiGamerCardUIForXUID @1140
;	XamShowNuiMarketplaceDownloadItemsUI @1141
;	XamShowNuiMarketplaceUI @1142
;	XamShowNuiMessageBoxUI @1143
;	XamShowNuiPartyUI @1144
;	XamShowNuiFriendRequestUI @1145
;	XamShowNuiSigninUI @1146
;	XamShowNuiControllerRequiredUI @1147
;	XamShowNuiGamesUI @1148
;	XamShowNuiHardwareRequiredUI @1149
;	XamCacheStoreFileByString @1150
;	XamCacheFetchFileByString @1151
;	XamCacheDeleteFileByString @1152
;	XamGetCachedTitleNameEx @1153
;	XamXlfsInitializeUploadQueue @1154
;	XamXlfsUninitializeUploadQueue @1155
;	XamXlfsMountUploadQueueInstance @1156
;	XamXlfsUnmountUploadQueueInstance @1157
;	XamVoiceRecordUserPrivileges @1158
	XamXlfsInitializeUploadQueueWithTestHooks @1159
;	XamXlfsNotifyContentDeletion @1160
;	XMemAlloc @1161
;	XMemFree @1162
;	XMemSize @1163
;	XamVoiceSetMicArrayIdleUsers @1164
;	XamVoiceMuteMicArray @1165
;	XamVoiceGetMicArrayUnderrunStatus @1166
	XuiSceneEnableTransitionDependency @1167
;	XamVoiceGetMicArrayAudioEx @1168
;	XamShowLeaveFamilyUI @1169
;	XamUserGetDeviceId @1170
;	XamUpdateEtxLogUpdateTaskStart @1171
;	XamUpdateEtxLogUpdateTaskSuccess @1172
;	XamUpdateEtxLogUpdateTaskFailure @1173
;	XamEtxFlushLogs @1174
;	XamVoiceIsActiveProcess @1175
	XamInactivityGetInactivityInterruptTime @1176
	XamInactivitySetInactivityInterruptTime @1177
	XamInactivityGetLastActivityTime @1178
	XamInactivitySetDetectionTaskPeriod @1179
	XamInactivityEnablePowerDown @1180
;	XamUpdateGetChainMarker @1181
;	XGetVideoCapabilities @1182
;	XMsgProcessRequest @1183
;	XGetDisplaySize @1184
;	XamInputNonControllerGetRaw @1185
;	XamInputNonControllerSetRaw @1186
;	XamVoiceSetMicArrayBeamAngle @1187
;	XamUserGetAge @1188
;	XamUserGetAgeGroup @1189
;	XamVoiceGetMicArrayFilenameDesc @1190
;	XamLoaderGetState @1191
;	XamTaskQueryProperty @1192
;	XamGetLocale @1193
;	XamQueryTimeZoneInformation @1194
;	XamSetTimeZoneInformation @1195
;	XamLaunchURI @1196
;	XamShowNuiMessagesUI @1199
	XMPRegisterCodec @1200
;	XamNavigateBack @1201
;	XamPushBackURI @1202
;	XamUserOverrideDeviceBindings @1203
;	XamUserOverrideBindingCallbacks @1204
;	XamUserOverrideUserInfo @1205
;	XamUserContentRestrictionGetFlags @1206
;	XamUserContentRestrictionGetRating @1207
;	XamUserContentRestrictionCheckAccess @1208
;	XamShowFitnessBodyProfileUI @1209
;	XamFitnessAddBodyProfileRecord @1210
;	XamFamilyGetMembers @1211
;	XampXAuthStartup @1212
;	XampXAuthShutdown @1213
;	XamGetToken @1214
;	XamFreeToken @1215
;	XamGetAppliesTo @1216
;	XampKioskGetInfo @1217
;	XamFitnessGetCurrentBodyProfileRecord @1218
;	XamFitnessGetAllBodyProfileRecords @1219
;	XamFitnessGetAllTitleSummaries @1220
;	XamFitnessGetOverallSummary @1221
;	XamFitnessAddFitnessEvent @1222
;	XamLrcGetInput @1223
;	XamLrcGetInputWithSeek @1224
;	XamLrcSetMediaState @1225
;	XamPixSetDirtyCounters @1226
;	XamFitnessCreateFitnessEventEnumerator @1227
;	XamFitnessInitialize @1228
;	XamRequestToken @1229
;	XamResolveURI @1230
;	XamContentGetOnlineCreator @1231
;	XamShowBrandedKeyboardUI @1232
;	XamBackgroundDownloadNetworkStorageEnable @1233
;	XamBackgroundDownloadNetworkStorageIsEnabled @1234
;	XamShowNuiJoinSessionInProgressUI @1235
;	XamBase64Decode @1236
;	XamCertDecode @1237
;	XamCertDecodeRsaPublicKey @1238
;	XamCertValidateStruct @1239
;	XamFitnessConvertByteMetToFloatMet @1240
	XamXgiBlobTrackerSetMockInfo @1241
;	XamFitnessMsgTimeToSystemTime @1242
;	XamFitnessSystemTimeToMsgTime @1243
;	XamShowFitnessWarnAboutPrivacyUI @1244
;	XamShowFitnessWarnAboutTimeUI @1245
;	XamFitnessUnInitialize @1246
;	XamBackgroundDownloadNetworkStorageOnContentChange @1247
	XamLiveBaseConfigureInMemoryMockResponse @1248
	InjectConnectionServerNotification @1249
;	XamFitnessConvertFloatMetToByteMet @1250
;	XamGetGamerTileKeyFromGamertag @1251
;	XamBackgroundDownloadNetworkStorageRegisterChangeCallback @1252
	XamFindOrCreateInternalPassportAccount @1253
	XOnlinepFriendsRequest @1254
	XOnlinepFriendsAcceptRequest @1255
	XOnlinepFriendsRejectRequest @1256
	XOnlinepFriendsRemove @1257
	XFriendsCreateEnumerator @1258
;	XamBackgroundDownloadNetworkStorageIsRunning @1259
;	XamCertGetSerialNumber @1260
;	XamShowOptionsUI @1261
;	XampXAuthGetTitleBuffer @1262
	XamGetSTSTokenCache @1263
;	XamUserGetOnlineXUIDFromOfflineXUID @1264
;	XamIsUserUsingMetricSystem @1265
;	XamShowNuiVideoRichPresenceUI @1266
;	XamAppAllocateInterappWorkspaceEx @1267
	XampKioskSetTestMock @1268
;	XamNetworkStatusGetInformation @1269
	XamNetworkStatusAddAddress @1270
;	XamUserReadUserPreference @1271
;	XamUserWriteUserPreference @1272
;	XamShowFitnessClearUI @1273
;	XamFitnessClearAll @1274
;	XamFitnessGetPrivacySettings @1275
;	XamWaitForNSAL @1276
;	XamMarkInternalAccountTrustedOnConsole @1277
;	XamBackgroundDownloadNetworkStorageGetProgress @1278
;	XamCopyFile @1279
;	XamMoveFile @1280
;	XamDeleteFile @1281
;	XamUserOverrideGlobalState @1282
;	XamGetAdaptersCollection @1283
	XampKioskIsSimulationMode @1284
	XamIsUIThread @1285
;	XamInputSendXenonButtonPress @1286
;	XamIsCurrentTitleIptv @1300
;	XamIsIptvEnabled @1301
;	XamIsDvrRecording @1302
;	XamIptvUninstall @1303
;	XamGetDvrStorage @1304
;	XamSetDvrStorage @1305
;	XamIptvGetServiceName @1306
;	XamNuiHudGetEngagedEnrollmentIndex @1307
;	XamProfileSetCachedWindowsLiveEmail @1308
;	XamProfileGetCachedWindowsLiveEmail @1309
;	XamUserResetSubscriptionType @1310
;	XamLrcSetTitlePort @1311
;	XamLrcVerifyClientId @1312
;	XamLrcEncryptDecryptTitleMessage @1313
;	XamFitnessGetSyncStatus @1314
;	XamFitnessInitializeForOneUser @1315
;	XamFitnessGetSuggestedPrivacySettings @1316
;	XampFitnessLetFireAndForgetsCatchUpInternal @1317
;	XamInputGetFailedConnectionOrBind @1318
;	XamGetServiceEndpoint @1399
;	XamReminderGetItems @1400
;	XamReminderClearItems @1401
;	XamReminderItemAdd @1402
;	XamReminderItemRemove @1403
;	XamReminderGetNextItem @1404
;	XamReminderGetModifiedTime @1405
;	XamReminderClearCache @1406
;	XamAvatarInitialize @1500
;	XamAvatarShutdown @1501
;	XamAvatarGetMetadataLocalUser @1502
;	XamAvatarGetMetadataByXuid @1503
;	XamAvatarGetAssetsResultSize @1504
;	XamAvatarGetAssets @1505
;	XamAvatarGenerateMipMaps @1506
;	XamAvatarSetCustomAsset @1507
;	XamAvatarSetMetadata @1508
;	EnumerateMediaObjects@CFsMediaSource @1509
;	EnumerateMediaObjects@CFsMediaSource @1510
;	XamAvatarLoadAnimation @1511
;	XamAvatarBeginEnumAssets @1512
;	XamAvatarEndEnumAssets @1513
;	XamAvatarEnumAssets @1514
;	XamAvatarGetMetadataRandom @1515
;	EnumerateMediaObjects@CFsMediaSource @1516
;	EnumerateMediaObjects@CFsMediaSource @1517
;	XamAvatarGetMetadataSignedOutProfileCount @1518
;	XamAvatarGetMetadataSignedOutProfile @1519
;	EnumerateMediaObjects@CFsMediaSource @1520
;	XamAvatarMetadataGetBodyType @1521
;	XamAvatarGetInstrumentation @1522
;	XamAvatarGetAssetIcon @1523
;	XamAvatarWearNow @1524
;	XamAvatarGetAssetBinary @1525
;	XamLoaderGetSuspendedTitleInfo @1526
;	XamAvatarGetInstalledAssetPackageDescription @1527
;	XamAvatarSetAdapters @1528
;	XamContentMountInstalledGame @1550
;	XamContentIsGameInstalledToHDD @1551
;	XamContentQueryLicenseInternal @1552
;	XamContentGetDeviceVolumePath @1553
;	XamContentDeviceCheckUpdates @1554
;	XamContentGetHeaderInternal @1555
;	XamNetworkStorageGetNetworkDevice @1556
;	XamNetworkStorageDeviceHasCacheFile @1557
;	XamNetworkStorageCreateCacheOnDevice @1558
;	XamNetworkStorageDeleteCacheOnDevice @1559
;	XamNetworkStorageGetStatus @1560
;	XamNetworkStorageIsSupportedContentType @1561
;	XamNetworkStorageSetTestMock @1562
;	XamNetworkStorageGetLastSyncTime @1563
;	XamShowNetworkStorageSyncUI @1564
;	XamUserIsLogonPreviewModeEnabled @1565
;	XamUserLockLogonPreviewMode @1566
;	XamUserUnlockLogonPreviewMode @1567
;	XamNetworkStorageIsUserInSync @1568
;	XamNetworkStorageSetUserInSync @1569
;	XamNetworkStorageOnSigninChanged @1570
;	XamNetworkStorageSignInTestMock @1571
;	XamShowFofUI @1572
	CompareFileTime @1573
	SetFileTime @1574
;	XamNetworkStorageGetTitleProperties @1575
;	XamNetworkStorageLockFile @1576
;	XamNetworkStorageUserHasPrivilege @1577
;	XamNetworkStorageIsTitleExempt @1578
;	XamContentExistsOnDeviceInternal @1579
;	XamNetworkStorageGetBackingDevice @1580
;	XamNetworkStorageIsEnabledInLiveHive @1581
;	XamNetworkStorageIsCheckingSyncStates @1582
;	XamNetworkStorageUserNeedsToSync @1583
;	XamNetworkStorageGetUserNetworkSyncTime @1584
;	XamNetworkStorageGetUserProperties @1585
;	XamNetworkStorageAppLauncherLaunchIfRunning @1586
;	XamNetworkStorageSetTitleProperties @1587
;	XamNetworkStorageGetUserLastError @1588
;	XamNetworkStorageCheckOutTitle @1589
;	XamNetworkStorageShouldHideFromTitle @1590
;	XamNetworkStorageOnUserSyncChange @1591
;	XamNetworkStorageHasUserEnabledStorage @1592
;	XamContentGetLocalizedDeviceData @1593
;	XamPackageManagerFindPackageContainingIndexedXEX @1600
;	XamPackageManagerReinitialize @1601
;	XamPackageManagerGetAuthoritativeManifestRevision @1602
;	XamGetCurrentSystemOnlineManifestRevision @1603
;	XamPackageManagerDeleteExtendedPartition @1604
;	XamPackageManagerHasExtendedPartition @1605
;	XamPackageManagerGetExperienceMode @1606
;	XamPackageManagerGetFeatureRequiresUpdateStrings @1607
;	XamPackageManagerGetFileSize @1608
	XampDemandUpdateGetAttributes @1609
	XampDemandUpdateGetExtendedAttributes @1610
	XampDemandUpdateGetInstance @1611
	XampDemandUpdateSetRefreshTestFlags @1612
	XampDemandUpdateIsRefreshTestFlagSet @1613
	XampDemandUpdateGetManifestLocalPath @1614
	XampDemandUpdateRefreshManifest @1615
;	XdfInitialize @1616
;	XdfShutdown @1617
;	XdfGetExpectedDownloadSize @1618
;	XdfGetItem @1619
;	XdfCacheItem @1620
;	XdfLoadXexFromCache @1621
;	XdfLoadXex @1622
;	XdfCancelRequest @1623
	XdfResumeDelayedItem @1624
;	XdfLaunchNewImageFromCache @1625
;	XampDemandUpdateRefreshManifestDuringLogon @1626
;	XampDemandUpdateCheckOnlineManifestChanged @1627
	XampDemandUpdateRunCacheCleaner @1628
;	XamXStudioRequest @1670
;	XamNotifyDelayUIInternal @1671
;	XamShowAvatarMiniCreatorUI @1700
;	XamShowGoldUpgradeUI @1701
;	XamResumeUpdaterUI @1702
;	XamShowDirectAcquireUI @1703
;	XamShowPaymentOptionsUI @1704
;	XamGetLiveHiveValueA @1800
;	XamGetLiveHiveValueW @1801
;	XamGetLiveHiveValueDuringLogonAttemptA @1802
;	XamSetUserPresetWindowsLiveCreds @1803
;	XamQueryLiveHiveA @1804
;	XamQueryLiveHiveW @1805
;	XamSetStagingMode @1902
;	XamGetStagingMode @1903
;	XamAppGetSessionId @1904
;	XamAccountRecoveryRecoverAllProfileData @1905
;	XamAccountRecoveryGetProgress @1906
;	XamDoesOmniNeedConfiguration @2000
	GetProcessHeap @2002
	UnhandledExceptionFilter @2003
	SetUnhandledExceptionFilter @2004
;	XamIsOptionalMediaUpdateInstalled @2005
;	XamShowOptionalMediaUpdateRequiredUI @2006
;	XamShowOptionalMediaUpdateRequiredUIEx @2007
;	XamTaskCreateQueueEx @2009
;	XamSetTextureLoaderHook @2010
;	XamLaunchAvatarEditor @2011
;	XamLoadExtraAVCodecs @2012
;	XamUnloadExtraAVCodecs @2013
	XamSetLastActiveUserData @2014
	XamGetLastActiveUserData @2015
;	XamSetActiveDashAppInfo @2016
;	XamGetActiveDashAppInfo @2017
;	XamUserCreateAvatarAssetEnumerator @2050
;	XamInitializeGameTileCache @2051
;	XamDestroyGameTileCache @2052
;	XamReadGameTileImage @2053
;	XamShouldThrottleAccountInfoCall @2054
	XuiClassDerivesFrom @2055
	XuiFreeVisuals @2056
	XuiGetBaseClass @2057
	XuiLoadVisualFromBinary @2058
	XuiResourceGetBuffer @2059
	XuiResourceGetTotalSize @2060
	XuiElementGetUserData @2061
	XuiElementSetUserData @2062
	XuiTabSceneGetCount @2063
	XuiSliderGetStep @2064
	XuiSliderSetStep @2065
	XuiProgressBarGetRange @2066
	XuiElementSetHittable @2067
	XuiElementPlayNamedFrames @2068
	XuiElementGetPivot @2069
	XuiElementGetPrev @2070
	XuiElementGetScale @2071
	XuiElementSetPivot @2072
	XuiElementSetRotation @2073
	XuiElementSetScale @2074
	XuiControlWantsUnfocusedInput @2075
	XuiResourceOpenNoLoc @2076
	XuiResourceReleasePackage @2077
	XuiResourceGetPackageEntryInfo @2078
	XuiResourceGetPackageEntryCount @2079
	XuiResourceOpenPackage @2080
;	XamCodeCoverageFileOpen @2081
;	XamCodeCoverageFileClose @2082
;	XamCodeCoverageFileLseek @2083
;	XamCodeCoverageFileRead @2084
;	XamCodeCoverageFileWrite @2085
;	Refresh@CGamerCardWorker @2086
;	XampHeapGetInfo @2087
;	XampHeapGetCount @2088
	XampKioskSetTestMockValues @2089
	XuiElementLayoutTree @2090
	XamInactivityResetAllState @2091
	XUIElementPropVal_SetInt @2092
	XUIElementPropVal_SetFloat @2093
	XuiObjectGetPropertyDef @2094
	XuiRenderGetDevice @2095
	XuiRenderRestoreState @2096
	XuiElementGetFullXForm @2097
	XuiRenderGetViewTransform @2098
	XuiRenderGetColorSpace @2099
;	XamPngEncode @2100
;	XamPngDecode @2101
;	XamPngEncodeEx @2102
	XuiTextElementMeasureText @2103
;	XamLoaderShouldConfirmReboot @2104
;	XamLoaderRebootToDash @2105
;	XamNuiHudGetEngagedTrackingID @2106
;	XamLoaderLaunchTitleForReason @2107
;	XamNuiHudSetEngagedTrackingID @2108
	XuiBrushGetTexture @2109
	XuiBrushGetDims @2110
	XuiElementGetDescendantById @2111
;	XamLoaderIsKinectUIPreferredForLogonTitle @2112
;	XamAccountRecoveryGetSetTitleSyncTime @2120
;	XamReadBiometricData @2121
;	XamWriteBiometricData @2122
;	XamD3DResourceDescriptorCreate @2123
;	XamD3DResourceDescriptorAddRef @2124
;	XamD3DResourceDescriptorRelease @2125
;	XamD3DResourceAddRef @2126
;	XamD3DResourceSet @2127
;	XamD3DResourceIsBusy @2128
;	XamD3DResourceRelease @2129
	ControlPackGetCursorPosition @2130
	ControlPackShouldShowCursor @2131
;	XamFlushAgraTemperatureReport @2136
;	XamNatalDeviceAudioCalibrate @2137
;	XamNuiIdentityGetEnrollmentInfo @2138
;	XamNuiIdentityUnenroll @2139
;	XamNuiIdentityGetColorTexture @2140
;	XamReportKinectSettingsChangedEvent @2141
;	XamNuiEnableChatMic @2142
;	XamNuiIsChatMicEnabled @2143
;	XamNuiGetDepthCalibration @2144
;	XamNuiStoreDepthCalibration @2145
;	XamUserNuiIsBiometricEnabled @2146
;	XamUserNuiEnableBiometric @2147
;	XamNuiCameraSetFlags @2148
;	XamNuiCameraRememberFloor @2149
;	XamUserNuiGetUserIndexForBind @2150
;	XamUserNuiGetUserIndexForSignin @2151
;	XamUserNuiBind @2152
;	XamUserNuiGetUserIndex @2153
;	XamUserNuiGetEnrollmentIndex @2154
;	XamUserNuiUnbind @2155
;	XamNuiUseTemporaryDepthCalibration @2156
;	XamNuiCameraTiltSetCallback @2157
;	XamNuiHudIsEnabled @2158
;	XamNuiCameraGetTiltControllerType @2159
;	XamNuiCameraTiltGetStatus @2160
;	XamNuiIdentityGetQualityFlags @2161
;	XamNuiIdentityEnrollForSignIn @2162
;	XamNuiIdentityGetSessionId @2163
;	XamNuiIdentityIdentifyWithBiometric @2164
	ControlPackGetHandleManager @2165
	XamEnableNuiAutomation @2166
	XamNuiGetSystemGestureControl @2167
;	XamGetPasscodeKeyFromVirtualKey @2168
	XamEnableNatalPlayback @2169
;	XamIsNuiAutomationEnabled @2170
;	XamIsNatalPlaybackEnabled @2171
;	XamNuiHudInterpretFrame @2172
;	XamNuiHudEnableInputFilter @2173
;	XamUserNuiIsBiometricAugmentRecommended @2174
;	XamNuiHudGetInitializeFlags @2175
;	XamNuiCameraElevationSetAngle @2176
;	XamNuiCameraElevationGetAngle @2177
;	XamNuiCameraElevationAutoTilt @2178
;	XamNuiCameraElevationStopMovement @2179
;	XamNuiCameraElevationSetCallback @2180
;	XamNuiGetDeviceStatus @2181
;	XamNuiNatalCameraUpdateStarting @2182
;	XamNuiNatalCameraUpdateComplete @2183
;	XamNuiHudGetVersions @2184
	XamGetHUDElementByPath @2185
	XamGetHUDElementByAutoId @2186
	XuiElementGetScreenPositionCenter @2187
;	XamNuiCameraElevationReverseAutoTilt @2188
	ControlPackSimpleCursorGetRayFromScreenPosition @2189
	ControlPackSideNavControlGetNuiHandle @2190
	XamFindHUDElementByXuiId @2191
;	XamNuiIsDeviceReady @2192
;	XamNuiSetForceDeviceOff @2193
;	XamNuiPlayerEngagementUpdate @2194
;	XamNuiSkeletonGetBestSkeletonIndex @2195
;	XamNuiSkeletonScoreUpdate @2196
;	XamNuiCameraTiltReportStatus @2197
;	XamNuiCameraAdjustTilt @2198
;	XamNuiIdentityAbort @2199
;	D3DDevice_CreateVertexShader @2200
;	D3DDevice_CreatePixelShader @2201
;	D3DDevice_CreateTexture @2202
	D3DDevice_CreateVertexBuffer @2203
	D3DDevice_CreateIndexBuffer @2204
;	D3DDevice_CreateVertexDeclaration @2205
	D3DVertexBuffer_Unlock @2206
	D3DVertexBuffer_Lock @2207
	D3DIndexBuffer_Unlock @2208
	D3DIndexBuffer_Lock @2209
	D3DTexture_UnlockRect @2210
	D3DTexture_LockRect @2211
;	D3DDevice_Clear @2212
	D3DDevice_SetViewport @2213
	D3DDevice_GetViewport @2214
;	D3DDevice_SetRenderState_SrcBlend @2215
;	D3DDevice_SetRenderState_DestBlend @2216
;	D3DResource_Release @2218
;	D3DDevice_Release @2219
;	D3DDevice_SetVertexShader @2220
;	D3DDevice_SetPixelShader @2221
;	D3DDevice_SetTexture @2222
;	D3DDevice_SetVertexDeclaration @2223
	D3DDevice_SetIndices @2224
	D3DDevice_SetStreamSource @2225
	D3DDevice_DrawVertices @2226
;	D3DDevice_DrawVerticesUP @2227
	D3DDevice_DrawIndexedVertices @2228
	D3DDevice_DrawIndexedVerticesUP @2229
;	D3DDevice_SetVertexShaderConstantF_ParameterCheck @2230
	D3DDevice_SetPixelShaderConstantF_ParameterCheck @2231
;	D3DDevice_SetSamplerState_ParameterCheck @2232
;	D3DDevice_SetRenderState_ParameterCheck @2233
;	D3DDevice_GetRenderState_ParameterCheck @2234
;	D3DDevice_SetVertexShaderConstantFN @2235
	D3DDevice_SetPixelShaderConstantFN @2236
;	D3DDevice_GetRenderState_ZEnable @2237
;	D3DDevice_GetRenderState_CullMode @2238
;	D3DDevice_GetRenderState_AlphaBlendEnable @2239
;	D3DDevice_GetRenderState_SrcBlendAlpha @2240
;	D3DDevice_GetRenderState_DestBlendAlpha @2241
;	D3DDevice_GetRenderState_BlendOp @2242
;	D3DDevice_GetRenderState_ViewportEnable @2243
;	D3DDevice_SetRenderState_ZEnable @2244
;	D3DDevice_SetRenderState_CullMode @2245
;	D3DDevice_SetRenderState_AlphaBlendEnable @2246
;	D3DDevice_SetRenderState_SrcBlendAlpha @2247
;	D3DDevice_SetRenderState_DestBlendAlpha @2248
;	D3DDevice_SetRenderState_BlendOp @2249
;	D3DDevice_SetRenderState_ViewportEnable @2250
;	D3DDevice_SetSamplerState_MagFilter @2251
;	D3DDevice_SetSamplerState_MinFilter @2252
	D3DDevice_SetSamplerState_AddressU @2253
	D3DDevice_SetSamplerState_AddressV @2254
;	XGSetTextureHeader @2255
;	XGGetTextureDesc @2256
	XGOffsetResourceAddress @2257
;	D3DResource_AddRef @2258
	XGSetTextureHeaderEx @2262
;	D3DDevice_GetRenderTarget @2263
	D3DDevice_SetRenderTarget @2264
	D3DDevice_GetDepthStencilSurface @2265
	D3DDevice_SetDepthStencilSurface @2266
	D3DDevice_Resolve @2267
	D3DDevice_SetPixelShaderConstantB @2268
;	XamNuiGetDeviceSerialNumber @2269
;	XamNuiGetLoadedDepthCalibration @2270
;	XamNuiGetTrueColorInfo @2271
;	XamNuiGetCameraIntrinsics @2272
;	XamNuiGetFanRate @2273
;	XamNuiGetSupportString @2274
;	XamKinectGetHardwareType @2275
;	XamXtwManagerGetVariableCount @2300
;	XamXtwManagerGetId @2301
;	XamXtwManagerGetValue @2302
;	XamXtwManagerSetValue @2303
;	XamXtwManagerIncrement @2304
;	XamXtwManagerDecrement @2305
;	XamXtwManagerResetValue @2306
;	XamXtwManagerResetAll @2307
;	XamXtwManagerGetDataFilePath @2308
;	XamXtwManagerDeleteDataFile @2309
;	XamXtwManagerSave @2310
;	XamXtwManagerLoad @2311
;	XamGetXTweakManager @2312
;	XamMediaVerificationCreate @2491
;	XamMediaVerificationClose @2492
;	XamMediaVerificationVerify @2493
;	XamMediaVerificationFailedBlocks @2494
;	XamMediaVerificationInject @2495
;	XamShowBadDiscErrorUI @2496
;	XamBackgroundDownloadSetMode @2500
;	XamBackgroundDownloadIsEnabled @2501
;	XamBackgroundDownloadGetActiveItem @2502
;	XamBackgroundDownloadGetItems @2503
;	XamBackgroundDownloadClearItems @2504
;	XamBackgroundDownloadItemAdd @2505
;	XamBackgroundDownloadItemRemove @2506
;	XamBackgroundDownloadItemMakeFirst @2507
;	XamBackgroundDownloadSetForegroundPriority @2508
;	XamBackgroundDownloadGetForegroundPriority @2509
;	XamBackgroundDownloadItemToContentData @2510
;	XamBackgroundDownloadItemGetStatus @2511
;	XamBackgroundDownloadHistoryGetItem @2512
;	XamBackgroundDownloadItemGetHistoryStatus @2513
;	XamBackgroundDownloadItemSetHistoryStatus @2514
;	XamBackgroundDownloadItemGetStatusAsync @2515
;	XamBackgroundDownloadItemGetStatusEx @2516
;	XamBackgroundDownloadItemGetHistoryStatusEx @2517
;	XamBackgroundDownloadBindItems @2518
;	XamBackgroundDownloadSetPollingActive @2519
;	XamBackgroundDownloadGetPollingActive @2520
;	XamBackgroundDownloadGetMode @2521
;	XamBackgroundDownloadGetUnexpectedChangeCount @2522
;	XamBackgroundDownloadIsItemForThisConsole @2523
;	XamBackgroundDownloadSelectDevice @2524
;	XamBackgroundDownloadItemModify @2525
;	XamBackgroundDownloadCacheLegacyMappingInfo @2526
;	XamBackgroundDownloadGetLegacyMappingInfo @2527
;	XamBackgroundDownloadGetLegacyId @2528
	XamBackgroundDownloadDoFail @2529
;	XamSwapDisc @2600
;	XamSwapDiscPatchAddress @2601
;	XamSwapCancel @2602
;	XamRamDriveCreate @2610
;	XamRamDriveDestroy @2611
;	XamPlayTimerGetData @2650
;	XamPlayTimerSetData @2651
;	XamPlayTimerResume @2652
;	XamPlayTimerSuspend @2653
;	XamPlayTimerIsRunning @2654
;	XamPlayTimerIsEnabled @2655
;	XamPlayTimerGetNextResetDate @2656
;	XamPlayTimerFormatDurationString @2657
;	XamPlayTimerGetTimeRemaining @2658
;	XamPlayTimerUpdateTimeRemaining @2659
;	XamPlayTimerForceNotification @2660
;	XamPlayTimerRefreshResetDate @2661
	UpnpAVServerSearchInitialize @2670
	UpnpAVServerSearchDestroy @2671
	UpnpAVServerSearchStart @2672
	Destroy_CUpnpAVServerSearch @2673
	UpnpAVServerSearchDoWork @2674
	UpnpAVServerSearchGetNextServer @2675
;	XCustomBroadcastGamercardEvent @2700
;	XamCustomGetCurrentActions @2701
;	XamInstrumentationLogEvent @2720
;	XamRegisterSMCNotification @2721
;	XamInstrumentationLogEventEx @2730
;	XamInstrumentationGetSourceConfig @2731
	XamInstrumentationDebugConfig @2732
;	CurlCreateCacheEntry @2780
;	CurlOpenCacheEntry @2781
;	CurlSetCacheEntryExpireTime @2782
;	CurlReadCacheEntryHeaders @2783
;	CurlReadCacheEntryContent @2784
;	CurlWriteCacheEntryContent @2785
;	CurlCloseCacheEntry @2786
;	CurlEnumerateCacheEntry @2787
;	CurlWipeBackingFiles @2789
;	CurlOpenTitleBackingFile @2791
;	XamSetSecurityViolationDetected @2800
;	XamIsSecurityViolationDetected @2801
;	XamIsAnySecurityViolationDetected @2802
;	XamGetSecurityViolationsDetected @2803
;	XamActivateCounterMeasure @2804
;	XamDeactivateCounterMeasure @2805
;	XamIsCounterMeasureActivated @2806
;	XamGetActiveCounterMeasures @2807
;	XamPmdIdentify @2808
;	XamPmdSendCommand @2809
;	XamPmdReadReport @2810
;	XamPartyCreate @2812
;	XamPartyLeave @2813
;	XamPartySendInviteDeprecated @2814
;	XamPartyGetUserList @2815
;	XamPartySendGameInvites @2816
;	XamPartyJoin @2817
;	XamPartyKickUser @2818
;	XamPartyAddLocalUsers @2819
;	XamConvertEmoticons @2820
;	XamGetLocaleTimeFormat @2821
;	XamPartyRemoveLocalUsers @2822
;	XamPartyGetUserListInternal @2823
;	XamPartySetJoinable @2824
;	XamPartyGetJoinable @2825
;	XamPartyGetInfo @2826
;	XamPartySetCustomData @2827
	XamPartySetConnectivityGraph @2828
	XamPartyGetRoutingTable @2829
;	XamPartyAutomationInprocCall @2830
;	XamPartyGetState @2831
;	XamPartyGetBandwidth @2832
;	XamPartyGetNetworkCounters @2833
;	XamShowQuickLaunchUI @2834
;	XamPartyIsCoordinator @2835
;	XamPartyGetFormation @2836
;	XamPartySendInvite @2837
	XamPartySetTestDelay @2838
	XamPartyOverrideNatType @2839
;	XamPartyGetAccessLevel @2840
	XamPartySetTestFlags @2841
;	XamIsSystemExperienceTitleId @2842
;	XamPartyJoinEx @2843
;	XamPartyGetInfoEx @2844
;	XamTaskSetCancelSubTasks @2850
;	XamTaskGetCompletionStatus @2851
;	XamTaskCancelWaitAndCloseWaitTask @2852
;	XamWebInstrumentationCreateReport @2860
;	XamWebInstrumentationSetUserVar @2861
;	XamWebInstrumentationSetUserVarNoEscape @2862
;	XamWebInstrumentationGetURL @2863
;	XamWebInstrumentationSendReport @2864
;	XamWebInstrumentationDestroyReport @2865
;	XamWebInstrumentationCreateSampledReport @2866
;	XampSetSamplingRandomValue @2867
;	XampWebInstrumentationSetProfileCounts @2868
;	XamWebInstrumentationGetURLEx @2869
	XampSetOmnitureCallbackFunction @2870
;	XamShowQuickChatUIp @2871
;	XamShowSocialPostUI @2872
;	XamShowBeaconsUI @2873
;	XamShowMarketplacePurchaseOrderUI @2874
;	XamShowMarketplaceGetOrderReceipts @2875
;	XamShowGenericOnlineAppUI @2876
;	XamUserAllowedToPostToSocialNetwork @2877
;	XamShowMarketplacePurchaseOrderUIEx @2878
;	XamVerifyXSignerSignature @2890

```

`XenonDumper/libs/xkelib/xam/xamext21250.0.def`:

```def
LIBRARY xam.xex@21250.0+1861.0
EXPORTS
;	NetDll_WSAStartup @1
;	NetDll_WSACleanup @2
;	NetDll_socket @3
;	NetDll_closesocket @4
;	NetDll_shutdown @5
;	NetDll_ioctlsocket @6
;	NetDll_setsockopt @7
;	NetDll_getsockopt @8
;	NetDll_getsockname @9
;	NetDll_getpeername @10
;	NetDll_bind @11
;	NetDll_connect @12
;	NetDll_listen @13
;	NetDll_accept @14
;	NetDll_select @15
;	NetDll_WSAGetOverlappedResult @16
;	NetDll_WSACancelOverlappedIO @17
;	NetDll_recv @18
;	NetDll_WSARecv @19
;	NetDll_recvfrom @20
;	NetDll_WSARecvFrom @21
;	NetDll_send @22
;	NetDll_WSASend @23
;	NetDll_sendto @24
;	NetDll_WSASendTo @25
;	NetDll_inet_addr @26
;	NetDll_WSAGetLastError @27
;	NetDll_WSASetLastError @28
;	NetDll_WSACreateEvent @29
;	NetDll_WSACloseEvent @30
;	NetDll_WSASetEvent @31
;	NetDll_WSAResetEvent @32
;	NetDll_WSAWaitForMultipleEvents @33
;	NetDll___WSAFDIsSet @34
;	NetDll_WSAEventSelect @35
;	NetDll_WSAStartupEx @36
;	NetDll_XNetStartup @51
;	NetDll_XNetCleanup @52
;	NetDll_XNetRandom @53
;	NetDll_XNetCreateKey @54
;	NetDll_XNetRegisterKey @55
;	NetDll_XNetUnregisterKey @56
;	NetDll_XNetXnAddrToInAddr @57
;	NetDll_XNetServerToInAddr @58
;	NetDll_XNetTsAddrToInAddr @59
;	NetDll_XNetInAddrToXnAddr @60
;	NetDll_XNetInAddrToServer @61
;	NetDll_XNetInAddrToString @62
;	NetDll_XNetUnregisterInAddr @63
;	NetDll_XNetXnAddrToMachineId @64
;	NetDll_XNetConnect @65
;	NetDll_XNetGetConnectStatus @66
;	NetDll_XNetDnsLookup @67
;	NetDll_XNetDnsRelease @68
;	NetDll_XNetQosListen @69
;	NetDll_XNetQosLookup @70
;	NetDll_XNetQosServiceLookup @71
;	NetDll_XNetQosRelease @72
;	NetDll_XNetGetTitleXnAddr @73
;	NetDll_XNetGetDebugXnAddr @74
;	NetDll_XNetGetEthernetLinkStatus @75
;	NetDll_XNetGetBroadcastVersionStatus @76
;	NetDll_XNetQosGetListenStats @77
;	NetDll_XNetGetOpt @78
;	NetDll_XNetSetOpt @79
;	NetDll_XNetStartupEx @80
;	NetDll_XNetReplaceKey @81
;	NetDll_XNetGetXnAddrPlatform @82
	NetDll_XNetGetSystemLinkPort @83
	NetDll_XNetSetSystemLinkPort @84
;	NetDll_XNetDnsReverseLookup @85
;	NetDll_XNetDnsReverseRelease @86
;	NetDll_XnpLoadConfigParams @101
;	NetDll_XnpSaveConfigParams @102
;	NetDll_XnpConfigUPnP @103
;	NetDll_XnpConfig @104
;	NetDll_XnpGetConfigStatus @105
;	NetDll_XnpLoadMachineAccount @106
;	NetDll_XnpSaveMachineAccount @107
;	NetDll_XnpCapture @108
;	NetDll_XnpEthernetInterceptSetCallbacks @109
;	NetDll_XnpEthernetInterceptXmit @110
;	NetDll_XnpEthernetInterceptRecv @111
;	NetDll_XnpLogonGetStatus @112
;	NetDll_XnpLogonGetQFlags @113
;	NetDll_XnpLogonSetQFlags @114
;	NetDll_XnpLogonSetQEvent @115
;	NetDll_XnpLogonClearQEvent @116
;	NetDll_XnpLogonGetQVals @117
;	NetDll_XnpLogonSetQVals @118
;	NetDll_XnpLogonSetPState @119
;	NetDll_XnpGetVlanXboxName @120
;	NetDll_XnpSetVlanXboxName @121
;	NetDll_XnpGetActiveSocketList @122
;	NetDll_XnpNoteSystemTime @123
;	NetDll_XnpRegisterKeyForCallerType @124
;	NetDll_XnpUnregisterKeyForCallerType @125
;	NetDll_XnpLogonGetChallenge @126
;	NetDll_XnpLogonClearChallenge @127
;	NetDll_XnpLogonSetChallengeResponse @128
;	NetDll_XnpGetSecAssocList @129
;	NetDll_XnpGetKeyList @130
;	NetDll_XnpGetQosLookupList @131
;	NetDll_XnpPersistTitleState @132
;	NetDll_XnpReplaceKeyForCallerType @133
;	NetDll_XnpEthernetInterceptSetExtendedReceiveCallback @134
;	NetDll_XnpQosHistoryLoad @135
;	NetDll_XnpQosHistorySaveMeasurements @136
;	NetDll_XnpQosHistoryGetEntries @137
;	NetDll_XnpQosHistoryGetAggregateMeasurement @138
;	NetDll_XnpToolSetCallbacks @139
;	NetDll_XnpToolIpProxyInject @140
;	NetDll_XnpUpdateConfigParams @141
;	NetDll_XnpEthernetInterceptXmitAsIp @142
;	NetDll_XnpConfigUPnPPortAndExternalAddr @143
;	NetDll_XmlDownloadStart @151
;	NetDll_XmlDownloadContinue @152
;	NetDll_XmlDownloadStop @153
;	NetDll_XmlDownloadGetParseTime @154
;	NetDll_XmlDownloadGetReceivedDataSize @155
;	XnpGetXwppMemoryLogSnapshot @198
;	XnpGetXwppRuntimeFilter @199
;	NetDll_XHttpStartup @201
;	NetDll_XHttpShutdown @202
;	NetDll_XHttpOpen @203
;	NetDll_XHttpCloseHandle @204
;	NetDll_XHttpConnect @205
;	NetDll_XHttpSetStatusCallback @206
;	NetDll_XHttpOpenRequest @207
;	NetDll_XHttpOpenRequestUsingMemory @208
;	NetDll_XHttpSendRequest @209
;	NetDll_XHttpReceiveResponse @210
;	NetDll_XHttpQueryHeaders @211
;	NetDll_XHttpReadData @212
;	NetDll_XHttpWriteData @213
;	NetDll_XHttpQueryOption @214
;	NetDll_XHttpSetOption @215
;	NetDll_XHttpDoWork @216
;	NetDll_XHttpSetCredentials @217
;	NetDll_XHttpQueryAuthSchemes @218
;	NetDll_XHttpCrackUrlW @219
;	NetDll_XHttpCrackUrl @220
;	NetDll_XHttpCreateUrl @221
;	NetDll_XHttpCreateUrlW @222
;	NetDll_XHttpResetPerfCounters @223
;	NetDll_XHttpGetPerfCounters @224
;	NetDll_UpnpStartup @251
;	NetDll_UpnpCleanup @252
;	NetDll_UpnpSearchCreate @253
;	NetDll_UpnpSearchGetDevices @254
;	NetDll_UpnpDescribeCreate @255
;	NetDll_UpnpDescribeGetResults @256
;	NetDll_UpnpActionCalculateWorkBufferSize @257
;	NetDll_UpnpActionCreate @258
;	NetDll_UpnpActionGetResults @259
;	NetDll_UpnpEventCreate @260
;	NetDll_UpnpEventGetCurrentState @261
;	NetDll_UpnpEventUnsubscribe @262
;	NetDll_UpnpDoWork @263
;	NetDll_UpnpCloseHandle @264
;	XNetLogonGetLoggedOnUsers @301
;	XNetLogonGetNatType @302
;	XNetLogonTaskStart @303
;	XNetLogonTaskClose @304
;	XNetLogonTaskContinue @305
;	XNetLogonGetServiceInfo @306
;	XNetLogonGetUserPrivileges @307
;	XNetLogonSetConsoleCertificate @308
;	XNetLogonGetMachineID @309
;	XNetLogonGetTitleID @310
;	XNetLogonGetTitleVersion @311
;	XNetLogonGetServiceNetworkID @312
;	XNetLogonGetDnsString @313
;	XNetLogonSetTitleID @314
;	XNetLogonGetExtendedStatus @315
;	XNetLogonClearTicketCaches @316
;	XNetLogonInitOverrideInfo @317
;	XNetLogonGetLastUPnPStatus @318
;	XNetLogonGetFlowToken @319
;	XNetLogonGetTicketOpt @320
;	XNetLogonSetTicketOpt @321
;	XNetLogonGetState @322
;	XamInputGetCapabilities @400
;	XamInputGetState @401
;	XamInputSetState @402
;	XamInputGetKeystroke @403
;	XamInputEnableAutobind @404
;	XamInputRawState @405
;	XamEnableSystemAppInput @406
	XamInputGetDeviceStats @407
;	XamInputGetKeystrokeEx @408
;	XamInputGetKeystrokeHud @409
;	XamInputSetLayoutKeyboard @410
;	XamInputToggleKeyLocks @411
;	XamInputResetLayoutKeyboard @412
;	XamInputGetKeystrokeHudEx @413
;	XamInputSetKeyboardTranslationHud @414
;	XamSetInactivityTime @415
;	XamEnableInactivityProcessing @416
;	XamResetInactivity @417
;	XamSetInactivityTimeFromConfig @418
	XamLoaderGetMediaInfo @419
	XamLoaderLaunchTitle @420
	XamLoaderLaunchTitleEx @421
	XamLoaderSetLaunchData @422
	XamLoaderGetLaunchDataSize @423
	XamLoaderGetLaunchData @424
	XamLoaderTerminateTitle @425
	XamLoaderGetDvdTrayState @426
	XamLoaderGetGameInfo @427
	XamLoaderLaunchTitleOnDvd @428
	XamLoaderSetSpindleSpeed @429
;	XamTaskCreateQueue @430
;	XamTaskSchedule @431
;	XamTaskReschedule @432
;	XamTaskCloseHandle @433
;	XamTaskCancel @434
;	XamTaskShouldExit @435
;	XamTaskWaitOnCompletion @436
;	XamTaskModify @437
;	XamTaskGetCurrentTask @438
;	XamTaskGetAttributes @439
;	XamExecutingOnBehalfOfTitle @440
;	XamInputSendStayAliveRequest @441
;	XamInputGetUserVibrationLevel @442
;	XamIsSystemTitleId @443
	XamLoaderIsTitleTerminatePending @444
;	XamInputSetTextMessengerIndicator @445
	XamLoaderGetPriorTitleId @446
;	XamIsXbox1TitleId @447
;	XamInputSetKeyLocks @448
;	XamInputGetKeyLocks @449
;	XamTaskGetStatus @450
;	XamGetRootObj @451
	XamDevAuthSetFault @452
;	XamGetDefaultSystemImage @453
;	XamGetWCNConfigFile @454
;	XamSetPowerMode @455
;	XamExecuteChallenge @456
;	XamGetDefaultImage @457
;	XamMuteSound @458
;	XamGetOnlineSchema @459
;	XamSetDashContext @460
	XamGetDashContext @461
;	XamIsCurrentTitleDash @462
;	XamGetCurrentTitleId @463
	XamSetCurrentTitleDash @464
	XamAllocHeapFreeSpace @465
;	XamSetDashContextEx @466
;	XamGetDashContextEx @467
;	XamSetHudContext @468
;	XamGetHudContext @469
;	XCustomSetAction @472
;	XCustomGetLastActionPress @473
;	XCustomSetDynamicActions @474
;	XCustomBroadcastActionEvent @475
;	XCustomGetLastActionPressEx @476
;	XCustomRegisterDynamicActions @477
;	XCustomUnregisterDynamicActions @478
;	XCustomGetCurrentGamercard @479
;	XamDbgPrint @480
	XamDbgSetOutputLevel @481
	XamDbgSetBreakLevel @482
	XamLoaderGetMediaInfoEx @483
;	XamLoaderSetGameInfo @484
;	XamFormatMessage @485
;	XamUniSortCmpString @486
;	XamFormatTimeString @487
;	XamFormatDateString @488
;	XamGetLocaleDateFormat @489
;	XamAlloc @490
;	XamAllocEx @491
;	XamFree @492
;	XamAllocSize @493
;	XamAllocFreeIPTVHeap @496
;	XamDeviceRemap @497
;	XamLoaderGetClearCache @498
;	XamLoaderSetClearCache @499
;	XMsgInProcessCall @500
;	XMsgCompleteIORequest @501
;	XMsgSystemProcessCall @502
;	XMsgStartIORequest @503
;	XMsgCancelIORequest @504
;	XMsgAcquireAsyncMessageFromOverlapped @505
;	XMsgReleaseAsyncMessageToOverlapped @506
;	XamGetOverlappedResult @507
;	XMsgStartIORequestEx @508
;	XamAppAllocateInterappWorkspace @509
;	XamAppGetInterappWorkspace @510
;	XamAppFreeInterappWorkspace @511
;	XamFeatureEnabled @512
;	XamFeatureEnforceImageBudget @513
;	XamFeatureSetMask @514
;	XamFeatureEnableDisable @515
	XuiControlSetItemAssociation @516
;	XamGetTitleGlobalStorageValue @517
;	XamSetTitleGlobalStorageValue @518
;	XamUserValidateAvatarMetadata @519
;	XamUserGetDeviceContext @520
	XamUserLookupDevice @521
;	XamUserGetXUID @522
;	XamUserLogon @523
;	XamUserGetGamerTag @524
;	XamUserGetUserIndexMask @525
;	XamUserGetName @526
	XamLookupCommonStringByIndex @527
;	XamUserGetSigninState @528
;	XamUserGetIndexFromXUID @529
;	XamUserCheckPrivilege @530
;	XamUserAreUsersFriends @531
;	XamSetUserPresetPresenceState @532
;	XamGetUserPresetPresenceState @533
;	XamUserGetUserFlagsFromXUID @534
;	XamUserGetMembershipTypeFromXUID @535
;	XamUserGetOnlineCountryFromXUID @536
;	XamUserReadProfileSettings @537
;	XamUserWriteProfileSettings @538
;	XamUserGetMembershipType @539
;	XamUserGetUserFlags @540
;	XamUserGetRequestedUserIndexMask @541
;	XamUserIsGuest @542
;	XamUserProfileSync @543
;	XamUserFlushLogonQueue @544
;	XamUserIsOnlineEnabled @545
;	XamUserGetCachedUserFlags @546
;	XamAreMixedAccountsSignedIn @547
;	XamUserLogonEx @548
;	XamSetUserShowMessengerFriends @549
;	XamGetUserShowMessengerFriends @550
;	XamUserGetSigninInfo @551
;	XamUserIsPartial @552
;	XamUserGetOnlineLanguageFromXUID @553
;	XamUserReadProfileSettingsEx @554
;	XamSystemUpdaterLogon @555
;	XamUserGetUsersMissingAvatars @556
;	XamIsChildAccountSignedIn @557
;	XamUserPrefetchProfileSettings @558
;	XamUserInvalidateProfileSetting @559
;	XamProfileCreate @560
;	XamProfileCreateEnumerator @561
;	XamProfileEnumerate @562
;	XamProfileDelete @563
;	XamProfileGetCreationStatus @564
;	XamProfileFindAccount @565
;	XamProfileRenameAccount @566
;	XamProfileOpen @567
;	XamProfileClose @568
;	XamProfileSaveAccountInfo @569
;	XamProfileLoadAccountInfo @570
;	XamProfileRecoverTitle @571
;	XamProfileSaveWindowsLiveCredentials @572
;	XamProfileLoadWindowsLiveCredentials @573
;	XamProfileIsSaveWindowsLiveCredsEnabled @574
;	XamProfileSetSaveWindowsLiveCredsEnabled @575
	XamSetProfileReadTestHook @576
;	XamProfileGetLastSync @577
;	XamAccountRecoveryRecoverTitle @578
	XamProfileControlXgi @579
;	XamAppLoad @580
;	XamAppUnloadSelf @581
;	XamAppUnloadStack @582
;	XamSendMessageToLoadedApps @583
;	XamAppRequestLoad @584
;	XamAppUnrequestLoad @585
;	XamNavigate @586
;	XamRegisterSysApp @587
;	XamUnregisterSysApp @588
;	XamCreateEnumeratorHandle @590
;	XamGetPrivateEnumStructureFromHandle @591
;	XamEnumerate @592
;	XamLoadSysApp @593
;	XamUnloadSysApp @594
;	XamReloadSysApp @595
;	XamAppLoadPass2SysApps @596
;	XamProfileGetLiveLegalLocale @597
;	XamUserIsParentalControlled @598
	XamContentLaunchImageFromFileInternal @599
;	XamContentCreate @600
;	XamContentCreateEx @601
;	XamContentClose @602
;	XamContentDelete @603
;	XamContentCreateEnumerator @604
;	XamContentCreateDeviceEnumerator @605
;	XamContentGetDeviceData @606
;	XamContentGetDeviceName @607
;	XamContentSetThumbnail @608
;	XamContentGetThumbnail @609
;	XamContentGetCreator @610
;	XamContentLaunchImage @611
;	XamContentGetAttributes @612
;	XamContentGetDeviceState @613
;	XamContentGetLicenseMask @614
;	XamContentFlush @615
;	XamContentResolve @616
;	XamContentOpenFile @617
;	XamContentInstall @618
;	XamContentLockUnlockPackageHeaders @619
;	XamContentCopyInternal @620
;	XamContentMoveInternal @621
;	XamContentGetMetaDataInternal @622
;	XamContentCreateEnumeratorInternal @623
;	XamContentDeleteInternal @624
;	XamContentCreateInternal @625
;	XamContentSetThumbnailInternal @626
;	XamContentLaunchImageInternal @627
;	XamContentWritePackageHeader @628
;	XamContentDismountAndClosePackage @629
;	XamContentResolveInternal @630
;	XamContentGetAttributesInternal @631
;	XamContentOpenFileInternal @632
;	XamContentAggregateCreateEnumerator @633
;	XamContentCreateAndMountPackage @634
;	XamContentOpenPackageFile @635
;	XamContentMountPackage @636
;	XamContentFlushPackage @637
;	XamContentClosePackageFile @638
;	XamContentDuplicateFileHandle @639
;	XamGetExecutionId @640
;	XamGetGameRatings @641
;	XamGetSystemVersion @642
;	XamContentGetLocalizedString @643
;	XamContentGetDefaultDevice @644
;	XamContentInstallInternal @645
;	XamContentGetDeviceSerialNumber @647
;	XamContentGetMountedPackageByRootName @648
;	XamContentRegisterChangeCallback @649
;	XamNotifyCreateListener @650
;	XNotifyGetNext @651
;	XNotifyPositionUI @652
;	XNotifyDelayUI @653
;	XNotifyBroadcast @654
;	XNotifyRegisterArea @655
	XNotifyQueueUI @656
;	XamNotifyCreateListenerInternal @657
;	XNotifyUISetOptions @658
;	XNotifyUIGetOptions @659
;	XamContentLaunchImageInternalEx @660
;	XamShutdown @661
;	XamAllocDevkitHeapAvailable @662
;	XamNotifyCreateListenerRangeInternal @663
;	XNotifyQueueUIEx @664
;	XamAppRequestLoadEx @665
	XuiPNGTextureLoader @666
	XuiRenderGetXuiDevice @667
	XuiDefault_False @668
;	XamUserGetReportingInfo @669
;	XamUpdateStart @670
;	XamUpdateGetProgress @671
;	XamUpdateFinish @673
;	XamUpdateAttachExtenderInstance @674
;	XamUpdateGetBaseSystemVersion @678
;	XamUpdateGetCurrentSystemVersion @679
;	XamUpdateChainPass3FromPass2 @683
;	XamInputGetCapabilitiesEx @685
;	XamUserIsUnsafeProgrammingAllowed @686
	XamDevAuthSetFaultEx @687
;	XamUpdateGetData @688
	XamCacheIntegrityCheck @689
;	XamCacheStoreFile @690
;	XamCacheFetchFile @691
;	XamCacheOpenFile @692
;	XamCacheCloseFile @693
;	XamGetCachedTitleName @694
;	XamCacheReset @695
;	XamGetCachedGamerTag @696
;	XamGetCachedGamerTagW @697
;	XamCacheDeleteFile @698
	XamCacheRenameFile @699
;	XamShowSigninUI @700
;	XamShowSigninUIEx @701
;	XamShowSigninUIp @702
;	XamShowFriendsUI @703
;	XamShowMessagesUI @704
;	XamShowKeyboardUI @705
;	XamShowQuickChatUI @706
;	XamShowVoiceMailUI @707
;	XamShowGamerCardUI @708
;	XamShowAchievementsUI @709
;	XamShowPlayerReviewUI @710
;	XamShowMarketplaceUI @711
;	XamShowPlayersUI @712
;	XamShowUpdaterUI @713
;	XamShowMessageBoxUI @714
;	XamShowDeviceSelectorUI @715
;	XamShowMessageComposeUI @716
;	XamShowGameInviteUI @717
;	XamShowFriendRequestUI @718
;	XamShowCreateProfileUI @719
;	XamShowGamesUI @720
;	XamShowLiveSignupUI @721
;	XamShowFriendsUIp @722
;	XamShowComplaintUI @723
;	XamShowReputationUI @724
;	XamShowGamerCardUIForXUID @725
;	XamShowForcedNameChangeUI @726
;	XamShowLiveUpsellUI @727
;	XamShowPasscodeVerifyUI @728
;	XamShowDirtyDiscErrorUI @729
;	XamShowSignupCreditCardUI @730
;	XamShowPrivateChatInviteUI @731
;	XamShowMessageBoxUIEx @732
;	XamShowRecentMessageUI @733
;	XamShowRecentMessageUIEx @734
;	XamShowMessagesUIEx @735
;	XamShowAchievementDetailsUI @736
;	XamShowPersonalizationUI @737
;	XamShowChangeGamerTileUI @738
;	XamShowVoiceSettingsUI @739
;	XamShowVideoChatInviteUI @740
;	XamShowCustomMessageComposeUI @741
;	XamShowCustomPlayerListUI @742
;	XamShowMarketplaceDownloadItemsUI @743
;	XamShowMarketplaceUIEx @744
	XamShowMessageBox @745
;	XamIsSysUiInvokedByXenonButton @746
;	XamIsSysUiInvokedByTitle @747
;	XamIsUIActive @748
;	XamSysUiDisableAutoClose @749
;	XamUserCreateAchievementEnumerator @750
;	XamReadTile @751
;	XamWriteGamerTile @752
;	XamWriteTile @753
;	XamReadImage @754
;	XamUserCreateTitlesPlayedEnumerator @755
;	XamDecompressPNGToTexture @756
;	XamReadTileToTexture @757
;	XamReadString @758
;	XamUserCreateStatsEnumerator @759
;	XamPrepareGamerTiles @760
;	XamClearTitle @761
;	XamReadStrings @762
;	XamWriteGamerTileEx @763
;	XamReadTileEx @764
;	XamReadTileToTextureEx @765
;	XamShowMessengerUI @766
;	XamShowKeyboardUIMessenger @767
;	XamShowLiveUpsellUIEx @768
;	XamShowJoinSessionInProgressUI @769
;	XamShowGraduateUserUI @770
;	XamShowGamerCardUIForXUIDp @771
;	XamShowGuideUI @772
;	XamShowPartyUI @773
;	XamShowPartyInviteUI @774
;	XamUserAddRecentPlayer @775
;	XamUserUpdateRecentPlayer @776
;	XamUserCreatePlayerEnumerator @777
;	XamParseGamerTileKey @778
;	XamShowCommunitySessionsUI @779
;	XamVoiceCreate @780
;	XamVoiceHeadsetPresent @781
;	XamVoiceSubmitPacket @782
;	XamVoiceClose @783
;	XamVoiceGetBatteryStatus @784
;	XamShowJoinSessionByIdInProgressUI @787
;	XamShowPartyJoinInProgressUI @788
;	XamBuildSharedSystemResourceLocator @789
;	XamSessionCreateHandle @790
;	XamSessionRefObjByHandle @791
;	XamVoiceGetMicArrayStatus @792
;	XamVoiceSetAudioCaptureRoutine @793
;	XamVoiceGetDirectionalData @794
;	XamBuildResourceLocator @795
;	XamBuildLegacySystemResourceLocator @796
;	XamBuildGamercardResourceLocator @797
;	XamBuildDynamicResourceLocator @798
;	XamBuildXamResourceLocator @799
	XuiAnimRun @800
	XuiApplyLocale @801
	XuiBubbleMessage @802
	XuiControlIsBackButton @803
	XuiControlIsNavButton @804
	XuiCreateObject @805
	XuiDestroyObject @806
	XuiDynamicCast @807
	XuiElementAddChild @808
	XuiElementFindNamedFrame @809
	XuiElementGetChildById @810
	XuiElementGetFirstChild @811
	XuiElementGetFocus @812
	XuiElementGetFocusUser @813
	XuiElementGetId @814
	XuiElementGetLastChild @815
	XuiElementGetNext @816
	XuiElementGetParent @817
	XuiElementGetUserFocus @818
	XuiElementInitFocus @819
	XuiElementInitUserFocus @820
	XuiElementPlayTimeline @821
	XuiElementSetBounds @822
	XuiElementSetFocus @823
	XuiElementSetUserFocus @824
	XuiElementTreeGetFocus @825
	XuiFindClass @826
	XuiFreeStringTable @827
	XuiGetBaseObject @828
	XuiGetClass @829
	XuiGetObjectClass @830
	XuiGetOuter @831
	XuiInit @832
	XuiLoadFromBinary @833
	XuiLoadStringTableFromFile @834
	XuiVisualGetBasePath @835
	XuiLookupStringTable @836
	XuiNavButtonGetPressPath @837
	XuiObjectFromHandle @838
	XuiObjectGetProperty @839
	XuiObjectGetPropertyId @840
	XuiProcessInput @841
	XuiRegisterClass @842
	XuiRenderBegin @843
	XuiRenderCreateDC @844
	XuiRenderDCDeviceChanged @845
	XuiRenderDestroyDC @846
	XuiRenderEnd @847
	XuiRenderGetBackBufferSize @848
	XuiRenderInit @849
	XuiRenderInitShared @850
	XuiRenderPresent @851
	XuiRenderSetViewTransform @852
	XuiRenderUninit @853
;	XamShowNuiGuideUI @854
	XuiSceneCreate @855
	XuiSceneNavigateBack @856
	XuiSceneNavigateFirst @857
	XuiSceneNavigateForward @858
	XuiScenePlayBackFromTransition @859
	XuiScenePlayBackToTransition @860
	XuiScenePlayFromTransition @861
	XuiScenePlayToTransition @862
	XuiSendMessage @863
	XuiSetLocale @864
	XuiUninit @865
	XuiUnregisterClass @866
	XuiTextElementSetText @867
	XuiSetTimer @868
	XuiTimersRun @869
	XuiTextElementGetText @870
	XuiVisualSetBasePath @871
	XuiHandleIsValid @872
	XuiAlloc @873
	XuiFree @874
	XuiDefault_True @875
	XuiDefault_EmptyString @876
	XuiDefault_IntegerZero @877
	XuiCopyString @878
	XuiRealloc @879
	XuiControlPlayOptionalVisual @880
	XuiKillTimer @881
	XuiElementEnableInput @882
	XuiElementInputEnabled @883
	XuiIsInstanceOf @884
	XuiResourceComposeLocator @885
	XuiResourceLocatorIsAbsolute @886
	XuiBroadcastMessage @887
	XuiElementDisallowRecursiveTimelineControl @888
	XUIElementPropVal_Construct @889
	XUIElementPropVal_Destruct @890
	XUIElementPropVal_SetString @891
	XuiObjectSetProperty @892
	XuiElementGetOpacity @893
	XuiElementSetOpacity @894
	XuiEditSetTextLimit @895
	XuiEditGetTextLimit @896
	XuiSliderSetValue @897
	XuiSliderGetValue @898
	XuiSliderSetRange @899
	XuiElementUnlink @900
	XuiElementInsertChild @901
	XuiSceneNavigateBackToFirst @902
	XuiProgressBarSetRange @903
	XuiProgressBarSetValue @904
	XuiProgressBarGetValue @905
	XuiControlAttachVisual @906
	XuiCreateTextureBrush @907
	XuiDestroyBrush @908
	XUIElementPropVal_SetColorFromUint @909
	XuiFigureSetFill @910
	XuiSliderGetRange @911
	XuiFigureSetTexture @912
	XuiControlGetItemAssociation @913
	XuiResourceLoadAll @914
	XuiImageElementSetImagePath @915
	XuiImageElementGetImagePath @916
	XuiControlGetVisual @917
	XuiControlGetNavigation @918
	XuiLookupStringTableByIndex @919
	XUIElementPropVal_SetBool @920
	XuiElementHasFocus @921
	XUIElementPropVal_SetUint @922
	XUIElementPropVal_Clear @923
	XuiEditSetTextFormatInfo @924
	XuiCreateSolidBrush @925
	XuiSceneInterruptTransitions @926
	XuiResourceOpen @927
	XuiResourceRead @928
	XuiResourceClose @929
	XuiVisualCreateInstance @930
	XuiElementGetTimeline @931
;	GetCodecVersion@CCalMediaInfo @932
	XuiElementIsDescendant @933
	XuiSetMessageFilter @934
	XuiAttachTextureBrush @935
	XuiElementBeginRender @936
	XuiElementEndRender @937
	XuiDrawShape @938
	XuiSelectBrushEx @939
	XuiFigureGetShape @940
	XuiFillRect @941
	XuiVec2TransformCoord @942
	XuiMatrixMultiply @943
	XuiElementGetXForm @944
	XuiElementSetPosition @945
	XuiSelectBrush @946
	XuiElementRenderChildren @947
	XuiFreeUnusedTextures @948
	XuiListEnableItemOverride @949
	XuiListGetDefaultItemSize @950
	XuiResourceSeek @951
	XuiElementDiscardResources @952
	XuiTabSceneGoto @953
	XuiTabSceneGetCurrentTab @954
;	XamShowEditProfileUI @956
;	XamShowTermsOfUseUI @958
;	XamShowJoinPartyUI @959
;	XamShowWordRegisterUI @960
;	XamOverrideHudOpenType @961
;	XamShowAchievementsUIEx @962
;	XamUserGetUserTenure @963
;	XamUserGetSubscriptionType @964
;	XamShowGameVoiceChannelUI @965
;	XamShowAvatarAwardsUI @966
;	XamShowAvatarAwardGamesUI @967
;	XamShowVideoRichPresenceUI @968
	XamHudGetUserIndex @969
;	XGetAudioFlags @970
;	XGetAVPack @971
;	XGetGameRegion @972
;	XGetLanguage @973
;	XapipGetLocale @974
;	XGetVideoFlags @975
;	XGetVideoStandard @976
;	XGetVideoMode @977
;	XamGetLanguage @978
	XUITimeline_Run @979
;	XamSetAutomation @980
;	XAutomationpBindController @981
;	XAutomationpUnbindController @982
;	XAutomationpInputXenonButton @983
;	XAutomationpInputPress @984
;	XAutomationpInputSetState @985
;	XamEnableOverdraw @986
;	g_XuiAutomation @987
;	XamVoiceGetMicArrayAudio @988
;	XampSystemInput @989
;	XamInputControl @990
	XuiElementGetPosition @991
;	XamIsMessageBoxActive @992
;	XamIsBackgroundSceneInTransition @993
	XuiElementTreeHasFocus @994
	XuiFigureClose @995
;	GamerCardStartup @996
;	GamerCardCleanup @997
;	GamerCardRegisterControls @998
;	GamerCardUnregisterControls @999
	RtlFindFirstFile @1000
	RtlFindNextFile @1001
	RtlGetModuleFileName @1002
;	RtlOutputDebugString @1003
	RtlRemoveDirectory @1004
	RtlSleep @1005
	RtlGetLastError @1006
	RtlSetLastError @1007
	RtlSetLastNTError @1008
	RtlDebugPrint @1009
;	RtlDebugError @1010
;	XDebugWarning @1011
	RtlDebugTrace @1012
	RtlDebugEntry @1013
	RtlDebugExit @1014
	RtlGetAttributesOnHeapAlloc @1015
	RtlSetAttributesOnHeapAlloc @1016
	XuiFigureSetShape @1017
	RtlCreateHeap @1018
	RtlDestroyHeap @1019
;	RtlAllocateHeap @1020
	RtlAllocateHeapSlowly @1021
;	RtlReAllocateHeap @1022
;	RtlFreeHeap @1023
	RtlFreeHeapSlowly @1024
;	RtlSizeHeap @1025
	RtlZeroHeap @1026
	RtlDebugWalkHeap @1027
	RtlWalkHeap @1028
	RtlLockHeap @1029
	RtlUnlockHeap @1030
;	RtlValidateHeap @1031
	RtlDebugCompactHeap @1032
	RtlCompactHeap @1033
	XamAppSetTestOption @1034
;	XamAppReportError @1035
;	XamIsNuiUIActive @1036
;	XamVerifyPasscode @1037
	OutputDebugStringA @1038
	DebugBreak @1039
	GetCurrentThreadId @1040
	XDebugError @1041
;	XDebugWarning @1042
	RtlDebugSetLevel @1043
	CloseHandle @1044
	GetTickCount @1045
	GetLastError @1046
	SetFilePointer @1047
	SetFilePointerEx @1048
	SetLastError @1049
	MultiByteToWideChar @1050
	WideCharToMultiByte @1051
	ReadFile @1052
	FlushFileBuffers @1053
	WriteFile @1054
	OutputDebugStringW @1055
	SetEvent @1056
	XapiFormatTimeOut @1057
	CreateMutexA @1058
	OpenMutexA @1059
	ReleaseMutex @1060
	WaitForSingleObject @1061
	WaitForSingleObjectEx @1062
	GetFileSize @1063
	GetFileSizeEx @1064
	XapiDirectoryInformationToFindData @1065
	XapiFormatObjectAttributes @1066
	ResetEvent @1067
	wsprintfA @1068
	wsprintfW @1069
	GetOverlappedResult @1070
	QueryPerformanceCounter @1071
	QueryPerformanceFrequency @1072
	LocalAlloc @1073
	LocalFree @1074
	RaiseException @1075
	RtlUniform @1076
	RtlRandom @1077
	Sleep @1078
	SleepEx @1079
	XMemSet @1080
	XRegisterThreadNotifyRoutine @1081
	XGetOverlappedExtendedError @1082
	XGetOverlappedResult @1083
	CreateThread @1084
	ResumeThread @1085
	ExitThread @1086
	GetTimeZoneInformation @1087
	GetSystemTimeAsFileTime @1088
	SystemTimeToFileTime @1089
	FileTimeToSystemTime @1090
	GetSystemTime @1091
	GetLocalTime @1092
	CreateDirectoryA @1093
	CreateEventA @1094
	CreateFileA @1095
	DeleteFileA @1096
	FindFirstFileA @1097
	FindNextFileA @1098
	GetFileAttributesA @1099
;	XamLoaderGetCurrentTitleD3DVersion @1100
	GetFileAttributesExA @1101
	GetModuleHandleA @1102
	GetDiskFreeSpaceExA @1103
	CopyFileA @1104
	SetEndOfFile @1105
;	XamFamilyAddParentalExemptionToList @1106
;	XamFamilyIsParentalValidationRequired @1107
;	PIXAddCounter @1110
	SetWaitableTimer @1112
	CancelWaitableTimer @1113
	CreateWaitableTimerA @1114
	DuplicateHandle @1115
	XapipCreateThread @1116
	lstrcpyA @1117
	lstrcpyW @1118
	lstrcpynA @1119
	lstrcpynW @1120
	lstrcatA @1121
	lstrcatW @1122
	lstrlenA @1123
	lstrlenW @1124
	IsBadReadPtr @1125
	IsBadWritePtr @1126
	FileTimeToLocalFileTime @1127
	XMemCpy @1128
	XMemCpyStreaming @1129
;	XamHudSetUserIndex @1130
;	XamShowNuiTroubleshooterUI @1131
	XamTestShowNuiTroubleshooterUI @1132
;	XamShowPasscodeVerifyUIEx @1133
;	XamShowNuiAchievementsUI @1134
;	XamShowNuiCommunitySessionsUI @1135
;	XamShowNuiDeviceSelectorUI @1136
;	XamShowNuiDirtyDiscErrorUI @1137
;	XamShowNuiFriendsUI @1138
;	XamShowNuiGameInviteUI @1139
;	XamShowNuiGamerCardUIForXUID @1140
;	XamShowNuiMarketplaceDownloadItemsUI @1141
;	XamShowNuiMarketplaceUI @1142
;	XamShowNuiMessageBoxUI @1143
;	XamShowNuiPartyUI @1144
;	XamShowNuiFriendRequestUI @1145
;	XamShowNuiSigninUI @1146
;	XamShowNuiControllerRequiredUI @1147
;	XamShowNuiGamesUI @1148
;	XamShowNuiHardwareRequiredUI @1149
;	XamCacheStoreFileByString @1150
;	XamCacheFetchFileByString @1151
;	XamCacheDeleteFileByString @1152
;	XamGetCachedTitleNameEx @1153
;	XamXlfsInitializeUploadQueue @1154
;	XamXlfsUninitializeUploadQueue @1155
;	XamXlfsMountUploadQueueInstance @1156
;	XamXlfsUnmountUploadQueueInstance @1157
;	XamVoiceRecordUserPrivileges @1158
	XamXlfsInitializeUploadQueueWithTestHooks @1159
;	XamXlfsNotifyContentDeletion @1160
;	XMemAlloc @1161
;	XMemFree @1162
;	XMemSize @1163
;	XamVoiceSetMicArrayIdleUsers @1164
;	XamVoiceMuteMicArray @1165
;	XamVoiceGetMicArrayUnderrunStatus @1166
	XuiSceneEnableTransitionDependency @1167
;	XamVoiceGetMicArrayAudioEx @1168
;	XamShowLeaveFamilyUI @1169
;	XamUserGetDeviceId @1170
;	XamUpdateEtxLogUpdateTaskStart @1171
;	XamUpdateEtxLogUpdateTaskSuccess @1172
;	XamUpdateEtxLogUpdateTaskFailure @1173
;	XamEtxFlushLogs @1174
;	XamVoiceIsActiveProcess @1175
	XamInactivityGetInactivityInterruptTime @1176
	XamInactivitySetInactivityInterruptTime @1177
	XamInactivityGetLastActivityTime @1178
	XamInactivitySetDetectionTaskPeriod @1179
	XamInactivityEnablePowerDown @1180
;	XamUpdateGetChainMarker @1181
;	XGetVideoCapabilities @1182
;	XMsgProcessRequest @1183
;	XGetDisplaySize @1184
;	XamInputNonControllerGetRaw @1185
;	XamInputNonControllerSetRaw @1186
;	XamVoiceSetMicArrayBeamAngle @1187
;	XamUserGetAge @1188
;	XamUserGetAgeGroup @1189
;	XamVoiceGetMicArrayFilenameDesc @1190
;	XamLoaderGetState @1191
;	XamTaskQueryProperty @1192
;	XamGetLocale @1193
;	XamQueryTimeZoneInformation @1194
;	XamSetTimeZoneInformation @1195
;	XamLaunchURI @1196
;	XamShowNuiMessagesUI @1199
	XMPRegisterCodec @1200
;	XamNavigateBack @1201
;	XamPushBackURI @1202
;	XamUserOverrideDeviceBindings @1203
;	XamUserOverrideBindingCallbacks @1204
;	XamUserOverrideUserInfo @1205
;	XamUserContentRestrictionGetFlags @1206
;	XamUserContentRestrictionGetRating @1207
;	XamUserContentRestrictionCheckAccess @1208
;	XamShowFitnessBodyProfileUI @1209
;	XamFitnessAddBodyProfileRecord @1210
;	XamFamilyGetMembers @1211
;	XampXAuthStartup @1212
;	XampXAuthShutdown @1213
;	XamGetToken @1214
;	XamFreeToken @1215
;	XamGetAppliesTo @1216
;	XampKioskGetInfo @1217
;	XamFitnessGetCurrentBodyProfileRecord @1218
;	XamFitnessGetAllBodyProfileRecords @1219
;	XamFitnessGetAllTitleSummaries @1220
;	XamFitnessGetOverallSummary @1221
;	XamFitnessAddFitnessEvent @1222
;	XamLrcGetInput @1223
;	XamLrcGetInputWithSeek @1224
;	XamLrcSetMediaState @1225
;	XamPixSetDirtyCounters @1226
;	XamFitnessCreateFitnessEventEnumerator @1227
;	XamFitnessInitialize @1228
;	XamRequestToken @1229
;	XamResolveURI @1230
;	XamContentGetOnlineCreator @1231
;	XamShowBrandedKeyboardUI @1232
;	XamBackgroundDownloadNetworkStorageEnable @1233
;	XamBackgroundDownloadNetworkStorageIsEnabled @1234
;	XamShowNuiJoinSessionInProgressUI @1235
;	XamBase64Decode @1236
;	XamCertDecode @1237
;	XamCertDecodeRsaPublicKey @1238
;	XamCertValidateStruct @1239
;	XamFitnessConvertByteMetToFloatMet @1240
	XamXgiBlobTrackerSetMockInfo @1241
;	XamFitnessMsgTimeToSystemTime @1242
;	XamFitnessSystemTimeToMsgTime @1243
;	XamShowFitnessWarnAboutPrivacyUI @1244
;	XamShowFitnessWarnAboutTimeUI @1245
;	XamFitnessUnInitialize @1246
;	XamBackgroundDownloadNetworkStorageOnContentChange @1247
	XamLiveBaseConfigureInMemoryMockResponse @1248
	InjectConnectionServerNotification @1249
;	XamFitnessConvertFloatMetToByteMet @1250
;	XamGetGamerTileKeyFromGamertag @1251
;	XamBackgroundDownloadNetworkStorageRegisterChangeCallback @1252
	XamFindOrCreateInternalPassportAccount @1253
	XOnlinepFriendsRequest @1254
	XOnlinepFriendsAcceptRequest @1255
	XOnlinepFriendsRejectRequest @1256
	XOnlinepFriendsRemove @1257
	XFriendsCreateEnumerator @1258
;	XamBackgroundDownloadNetworkStorageIsRunning @1259
;	XamCertGetSerialNumber @1260
;	XamShowOptionsUI @1261
;	XampXAuthGetTitleBuffer @1262
;	XamTaskReschedulePeriodicWork @1263
;	XamUserGetOnlineXUIDFromOfflineXUID @1264
;	XamIsUserUsingMetricSystem @1265
;	XamShowNuiVideoRichPresenceUI @1266
;	XamAppAllocateInterappWorkspaceEx @1267
	XampKioskSetTestMock @1268
;	XamNetworkStatusGetInformation @1269
	XamNetworkStatusAddAddress @1270
;	XamUserReadUserPreference @1271
;	XamUserWriteUserPreference @1272
;	XamShowFitnessClearUI @1273
;	XamFitnessClearAll @1274
;	XamFitnessGetPrivacySettings @1275
;	XamWaitForNSAL @1276
;	XamMarkInternalAccountTrustedOnConsole @1277
;	XamBackgroundDownloadNetworkStorageGetProgress @1278
;	XamCopyFile @1279
;	XamMoveFile @1280
;	XamDeleteFile @1281
;	XamUserOverrideGlobalState @1282
;	XamGetAdaptersCollection @1283
	XampKioskIsSimulationMode @1284
	XamIsUIThread @1285
;	XamInputSendXenonButtonPress @1286
	XamDebugGetURISchemeCount @1287
	XamDebugGetURISchemeInfo @1288
;	XamGetOnlineCountryFromLocale @1289
	XTestOnlineIsConnectedToLive @1290
;	XamGetConsoleFriendlyName @1291
;	XamSetConsoleFriendlyName @1292
;	XamGetCountry @1293
;	XamPackageManagerGetFilePathW @1294
;	XamGetCurrentDemand @1295
;	XamCompleteDemand @1296
;	XamDemand @1297
;	XamFormatSystemDateString @1298
	XamDebugGetBackURI @1299
;	XamIsCurrentTitleIptv @1300
;	XamIsIptvEnabled @1301
;	XamIsDvrRecording @1302
;	XamIptvUninstall @1303
;	XamGetDvrStorage @1304
;	XamSetDvrStorage @1305
;	XamIptvGetServiceName @1306
;	XamNuiHudGetEngagedEnrollmentIndex @1307
;	XamProfileSetCachedWindowsLiveEmail @1308
;	XamProfileGetCachedWindowsLiveEmail @1309
;	XamUserResetSubscriptionType @1310
;	XamLrcSetTitlePort @1311
;	XamLrcVerifyClientId @1312
;	XamLrcEncryptDecryptTitleMessage @1313
;	XamFitnessGetSyncStatus @1314
;	XamFitnessInitializeForOneUser @1315
;	XamFitnessGetSuggestedPrivacySettings @1316
;	XampFitnessLetFireAndForgetsCatchUpInternal @1317
;	XamInputGetFailedConnectionOrBind @1318
	XuiSceneIsInTransition @1319
;	XamIsOnPrivateNetwork @1320
;	XamInputSetMinMaxAuthDelay @1321
;	XamInputNonControllerGetRawEx @1322
;	XamInputNonControllerSetRawEx @1323
	XamMarketplaceAcquireFreeContent @1324
;	XamGetClosedCaptioningState @1325
;	XamGetClosedCaptioningSettings @1326
;	XamSetClosedCaptioningState @1327
;	XamLoaderGetLogonTitle @1328
;	XamGetServiceEndpoint @1399
;	XamLrcKeyboardGetInput @1407
;	XamLrcKeyboardGetRequiredBufferSize @1408
;	XamLrcKeyboardRegister @1409
;	XamLrcKeyboardUnregister @1410
;	XamLrcKeyboardUpdateText @1411
;	XamValidateCountry @1412
;	XamGetOnlineCountryString @1413
;	XamGetCountryString @1414
;	XamGetLanguageString @1415
;	XamGetLanguageLocaleString @1416
;	XamGetOnlineLanguageAndCountryString @1417
;	XamGetLanguageLocaleFallbackString @1418
;	XamGetOnlineLanguageAndCountry @1419
;	XamGetLanguageTypeface @1420
;	XamGetLanguageTypefacePatch @1421
;	XamGetLocaleString @1422
;	XamGetLocaleFromOnlineCountry @1423
;	XamOfflineTimerSetData @1424
;	XamOfflineTimerResume @1425
;	XamOfflineTimerSuspend @1426
;	XamOfflineTimerIsRunning @1427
;	XamOfflineTimerIsEnabled @1428
;	XamOfflineTimerGetTimeRemaining @1429
;	XamOfflineTimerGetContractData @1430
	XamOfflineTimerInitialize @1431
;	XamOfflineTimerGetData @1432
;	XamPlayToRegister @1433
;	XamPlayToReportPlaybackState @1434
;	XamPlayToUnregister @1435
;	XamShowTFAUI @1436
;	OnReconnect@CsInProcNotificationHandler @1437
;	XamGetOnlineCountryFeatures @1438
;	XamLogLocalizationEtx @1439
;	XampXAuthIsLocalSocketAllowed @1440
;	XamPlayToGetRequest @1441
;	XamPlayToCancelGetRequest @1442
;	XamPlayToCompleteRequest @1443
;	XamFitnessGetTitleSummaries @1444
;	XamFitnessGetTitleSummary @1445
	XamOfflineTimerShutdown @1446
;	XamFitnessContainsFitnessData @1447
;	XamGetLanguageFromOnlineLanguage @1448
;	XamGetOnlineLanguageString @1449
;	XamGetCountryFromOnlineCountry @1450
;	XamOfflineTimerForceQuery @1496
;	XamShowCreateProfileUIEx @1497
;	XTLGetLanguageV2 @1498
;	XTLGetLocaleV1 @1499
;	XamAvatarInitialize @1500
;	XamAvatarShutdown @1501
;	XamAvatarGetMetadataLocalUser @1502
;	XamAvatarGetMetadataByXuid @1503
;	XamAvatarGetAssetsResultSize @1504
;	XamAvatarGetAssets @1505
;	XamAvatarGenerateMipMaps @1506
;	XamAvatarSetCustomAsset @1507
;	XamAvatarSetMetadata @1508
;	EnumerateMediaObjects@CFsMediaSource @1509
;	EnumerateMediaObjects@CFsMediaSource @1510
;	XamAvatarLoadAnimation @1511
;	XamAvatarBeginEnumAssets @1512
;	XamAvatarEndEnumAssets @1513
;	XamAvatarEnumAssets @1514
;	XamAvatarGetMetadataRandom @1515
;	EnumerateMediaObjects@CFsMediaSource @1516
;	EnumerateMediaObjects@CFsMediaSource @1517
;	XamAvatarGetMetadataSignedOutProfileCount @1518
;	XamAvatarGetMetadataSignedOutProfile @1519
;	EnumerateMediaObjects@CFsMediaSource @1520
;	XamAvatarMetadataGetBodyType @1521
;	XamAvatarGetInstrumentation @1522
;	XamAvatarGetAssetIcon @1523
;	XamAvatarWearNow @1524
;	XamAvatarGetAssetBinary @1525
;	XamLoaderGetSuspendedTitleInfo @1526
;	XamAvatarGetInstalledAssetPackageDescription @1527
;	XamAvatarSetAdapters @1528
;	XamLrcKeyboardValidateTextChange @1529
;	XamLrcKeyboardApplyTextChange @1530
;	XamLrcLogSessionSummary @1531
;	XamLrcLogError @1532
;	XamContentMountInstalledGame @1550
;	XamContentIsGameInstalledToHDD @1551
;	XamContentQueryLicenseInternal @1552
;	XamContentGetDeviceVolumePath @1553
;	XamContentDeviceCheckUpdates @1554
;	XamContentGetHeaderInternal @1555
;	XamNetworkStorageGetNetworkDevice @1556
;	XamNetworkStorageDeviceHasCacheFile @1557
;	XamNetworkStorageCreateCacheOnDevice @1558
;	XamNetworkStorageDeleteCacheOnDevice @1559
;	XamNetworkStorageGetStatus @1560
;	XamNetworkStorageIsSupportedContentType @1561
;	XamNetworkStorageSetTestMock @1562
;	XamNetworkStorageGetLastSyncTime @1563
;	XamShowNetworkStorageSyncUI @1564
;	XamUserIsLogonPreviewModeEnabled @1565
;	XamUserLockLogonPreviewMode @1566
;	XamUserUnlockLogonPreviewMode @1567
;	XamNetworkStorageIsUserInSync @1568
;	XamNetworkStorageSetUserInSync @1569
;	XamNetworkStorageOnSigninChanged @1570
;	XamNetworkStorageSignInTestMock @1571
;	XamShowFofUI @1572
	CompareFileTime @1573
	SetFileTime @1574
;	XamNetworkStorageGetTitleProperties @1575
;	XamNetworkStorageLockFile @1576
;	XamNetworkStorageUserHasPrivilege @1577
;	XamNetworkStorageIsTitleExempt @1578
;	XamContentExistsOnDeviceInternal @1579
;	XamNetworkStorageGetBackingDevice @1580
;	XamNetworkStorageIsEnabledInLiveHive @1581
;	XamNetworkStorageIsCheckingSyncStates @1582
;	XamNetworkStorageUserNeedsToSync @1583
;	XamNetworkStorageGetUserNetworkSyncTime @1584
;	XamNetworkStorageGetUserProperties @1585
;	XamNetworkStorageAppLauncherLaunchIfRunning @1586
;	XamNetworkStorageSetTitleProperties @1587
;	XamNetworkStorageGetUserLastError @1588
;	XamNetworkStorageCheckOutTitle @1589
;	XamNetworkStorageShouldHideFromTitle @1590
;	XamNetworkStorageOnUserSyncChange @1591
;	XamNetworkStorageHasUserEnabledStorage @1592
;	XamContentGetLocalizedDeviceData @1593
;	XamPackageManagerFindPackageContainingIndexedXEX @1600
;	XamPackageManagerReinitialize @1601
;	XamPackageManagerGetAuthoritativeManifestRevision @1602
;	XamGetCurrentSystemOnlineManifestRevision @1603
;	XamPackageManagerDeleteExtendedPartition @1604
;	XamPackageManagerHasExtendedPartition @1605
;	XamPackageManagerGetExperienceMode @1606
;	XamPackageManagerGetFeatureRequiresUpdateStrings @1607
;	XamPackageManagerGetFileSize @1608
	XampDemandUpdateGetAttributes @1609
	XampDemandUpdateGetExtendedAttributes @1610
	XampDemandUpdateGetInstance @1611
	XampDemandUpdateSetRefreshTestFlags @1612
	XampDemandUpdateIsRefreshTestFlagSet @1613
	XampDemandUpdateGetManifestLocalPath @1614
	XampDemandUpdateRefreshManifest @1615
;	XdfInitialize @1616
;	XdfShutdown @1617
;	XdfGetExpectedDownloadSize @1618
;	XdfGetItem @1619
;	XdfCacheItem @1620
;	XdfLoadXexFromCache @1621
;	XdfLoadXex @1622
;	XdfCancelRequest @1623
	XdfResumeDelayedItem @1624
;	XdfLaunchNewImageFromCache @1625
;	XampDemandUpdateRefreshManifestDuringLogon @1626
;	XampDemandUpdateCheckOnlineManifestChanged @1627
	XampDemandUpdateRunCacheCleaner @1628
;	XamXStudioRequest @1670
;	XamNotifyDelayUIInternal @1671
;	XamShowAvatarMiniCreatorUI @1700
;	XamShowGoldUpgradeUI @1701
;	XamResumeUpdaterUI @1702
;	XamShowDirectAcquireUI @1703
;	XamShowPaymentOptionsUI @1704
;	XamGetLiveHiveValueA @1800
;	XamGetLiveHiveValueW @1801
;	XamGetLiveHiveValueDuringLogonAttemptA @1802
;	XamSetUserPresetWindowsLiveCreds @1803
;	XamQueryLiveHiveA @1804
;	XamQueryLiveHiveW @1805
;	XamGetLiveHiveValueDuringLogonAttemptExA @1806
;	XamGetUserPresetWindowsLiveCreds @1807
;	XamGetUserNeedTFA @1808
;	XamSetUserNeedTFA @1809
;	XamSetStagingMode @1902
;	XamGetStagingMode @1903
;	XamAppGetSessionId @1904
;	XamAccountRecoveryRecoverAllProfileData @1905
;	XamAccountRecoveryGetProgress @1906
;	XamDoesOmniNeedConfiguration @2000
	GetProcessHeap @2002
	UnhandledExceptionFilter @2003
	SetUnhandledExceptionFilter @2004
;	XamIsOptionalMediaUpdateInstalled @2005
;	XamShowOptionalMediaUpdateRequiredUI @2006
;	XamShowOptionalMediaUpdateRequiredUIEx @2007
;	XamTaskCreateQueueEx @2009
;	XamSetTextureLoaderHook @2010
;	XamLaunchAvatarEditor @2011
;	XamLoadExtraAVCodecs @2012
;	XamUnloadExtraAVCodecs @2013
	XamSetLastActiveUserData @2014
	XamGetLastActiveUserData @2015
;	XamSetActiveDashAppInfo @2016
;	XamGetActiveDashAppInfo @2017
;	XamLoaderRegisterLaunchRequestCallback @2018
;	XamLoadExtraAVCodecs2 @2019
;	XamUnloadExtraAVCodecs2 @2020
;	XamUserCreateAvatarAssetEnumerator @2050
;	XamInitializeGameTileCache @2051
;	XamDestroyGameTileCache @2052
;	XamReadGameTileImage @2053
;	XamShouldThrottleAccountInfoCall @2054
	XuiClassDerivesFrom @2055
	XuiFreeVisuals @2056
	XuiGetBaseClass @2057
	XuiLoadVisualFromBinary @2058
	XuiResourceGetBuffer @2059
	XuiResourceGetTotalSize @2060
	XuiElementGetUserData @2061
	XuiElementSetUserData @2062
	XuiTabSceneGetCount @2063
	XuiSliderGetStep @2064
	XuiSliderSetStep @2065
	XuiProgressBarGetRange @2066
	XuiElementSetHittable @2067
	XuiElementPlayNamedFrames @2068
	XuiElementGetPivot @2069
	XuiElementGetPrev @2070
	XuiElementGetScale @2071
	XuiElementSetPivot @2072
	XuiElementSetRotation @2073
	XuiElementSetScale @2074
	XuiControlWantsUnfocusedInput @2075
	XuiResourceOpenNoLoc @2076
	XuiResourceReleasePackage @2077
	XuiResourceGetPackageEntryInfo @2078
	XuiResourceGetPackageEntryCount @2079
	XuiResourceOpenPackage @2080
;	XamCodeCoverageFileOpen @2081
;	XamCodeCoverageFileClose @2082
;	XamCodeCoverageFileLseek @2083
;	XamCodeCoverageFileRead @2084
;	XamCodeCoverageFileWrite @2085
;	XampHeapGetInfo @2087
;	XampHeapGetCount @2088
	XampKioskSetTestMockValues @2089
	XuiElementLayoutTree @2090
	XamInactivityResetAllState @2091
	XUIElementPropVal_SetInt @2092
	XUIElementPropVal_SetFloat @2093
	XuiObjectGetPropertyDef @2094
	XuiRenderGetDevice @2095
	XuiRenderRestoreState @2096
	XuiElementGetFullXForm @2097
	XuiRenderGetViewTransform @2098
	XuiRenderGetColorSpace @2099
;	XamPngEncode @2100
;	XamPngDecode @2101
;	XamPngEncodeEx @2102
	XuiTextElementMeasureText @2103
;	XamLoaderShouldConfirmReboot @2104
;	XamLoaderRebootToDash @2105
;	XamNuiHudGetEngagedTrackingID @2106
;	XamLoaderLaunchTitleForReason @2107
;	XamNuiHudSetEngagedTrackingID @2108
	XuiBrushGetTexture @2109
	XuiBrushGetDims @2110
	XuiElementGetDescendantById @2111
;	XamLoaderIsKinectUIPreferredForLogonTitle @2112
;	XamAccountRecoveryGetSetTitleSyncTime @2120
;	XamReadBiometricData @2121
;	XamWriteBiometricData @2122
;	XamD3DResourceDescriptorCreate @2123
;	XamD3DResourceDescriptorAddRef @2124
;	XamD3DResourceDescriptorRelease @2125
;	XamD3DResourceAddRef @2126
;	XamD3DResourceSet @2127
;	XamD3DResourceIsBusy @2128
;	XamD3DResourceRelease @2129
	ControlPackGetCursorPosition @2130
	ControlPackShouldShowCursor @2131
;	XamFlushAgraTemperatureReport @2136
;	XamNatalDeviceAudioCalibrate @2137
;	XamNuiIdentityGetEnrollmentInfo @2138
;	XamNuiIdentityUnenroll @2139
;	XamNuiIdentityGetColorTexture @2140
;	XamReportKinectSettingsChangedEvent @2141
;	XamNuiEnableChatMic @2142
;	XamNuiIsChatMicEnabled @2143
;	XamNuiGetDepthCalibration @2144
;	XamNuiStoreDepthCalibration @2145
;	XamUserNuiIsBiometricEnabled @2146
;	XamUserNuiEnableBiometric @2147
;	XamNuiCameraSetFlags @2148
;	XamNuiCameraRememberFloor @2149
;	XamUserNuiGetUserIndexForBind @2150
;	XamUserNuiGetUserIndexForSignin @2151
;	XamUserNuiBind @2152
;	XamUserNuiGetUserIndex @2153
;	XamUserNuiGetEnrollmentIndex @2154
;	XamUserNuiUnbind @2155
;	XamNuiUseTemporaryDepthCalibration @2156
;	XamNuiCameraTiltSetCallback @2157
;	XamNuiHudIsEnabled @2158
;	XamNuiCameraGetTiltControllerType @2159
;	XamNuiCameraTiltGetStatus @2160
;	XamNuiIdentityGetQualityFlags @2161
;	XamNuiIdentityEnrollForSignIn @2162
;	XamNuiIdentityGetSessionId @2163
;	XamNuiIdentityIdentifyWithBiometric @2164
	ControlPackGetHandleManager @2165
	XamEnableNuiAutomation @2166
	XamNuiGetSystemGestureControl @2167
;	XamGetPasscodeKeyFromVirtualKey @2168
	XamEnableNatalPlayback @2169
;	XamIsNuiAutomationEnabled @2170
;	XamIsNatalPlaybackEnabled @2171
;	XamNuiHudInterpretFrame @2172
;	XamNuiHudEnableInputFilter @2173
;	XamUserNuiIsBiometricAugmentRecommended @2174
;	XamNuiHudGetInitializeFlags @2175
;	XamNuiCameraElevationSetAngle @2176
;	XamNuiCameraElevationGetAngle @2177
;	XamNuiCameraElevationAutoTilt @2178
;	XamNuiCameraElevationStopMovement @2179
;	XamNuiCameraElevationSetCallback @2180
;	XamNuiGetDeviceStatus @2181
;	XamNuiNatalCameraUpdateStarting @2182
;	XamNuiNatalCameraUpdateComplete @2183
;	XamNuiHudGetVersions @2184
	XamGetHUDElementByPath @2185
	XamGetHUDElementByAutoId @2186
	XuiElementGetScreenPositionCenter @2187
;	XamNuiCameraElevationReverseAutoTilt @2188
	ControlPackSimpleCursorGetRayFromScreenPosition @2189
	ControlPackSideNavControlGetNuiHandle @2190
	XamFindHUDElementByXuiId @2191
;	XamNuiIsDeviceReady @2192
;	XamNuiSetForceDeviceOff @2193
;	XamNuiPlayerEngagementUpdate @2194
;	XamNuiSkeletonGetBestSkeletonIndex @2195
;	XamNuiSkeletonScoreUpdate @2196
;	XamNuiCameraTiltReportStatus @2197
;	XamNuiCameraAdjustTilt @2198
;	XamNuiIdentityAbort @2199
;	D3DDevice_CreateVertexShader @2200
;	D3DDevice_CreatePixelShader @2201
;	D3DDevice_CreateTexture @2202
	D3DDevice_CreateVertexBuffer @2203
	D3DDevice_CreateIndexBuffer @2204
;	D3DDevice_CreateVertexDeclaration @2205
	D3DVertexBuffer_Unlock @2206
	D3DVertexBuffer_Lock @2207
	D3DIndexBuffer_Unlock @2208
	D3DIndexBuffer_Lock @2209
	D3DTexture_UnlockRect @2210
	D3DTexture_LockRect @2211
;	D3DDevice_Clear @2212
	D3DDevice_SetViewport @2213
	D3DDevice_GetViewport @2214
;	D3DDevice_SetRenderState_SrcBlend @2215
;	D3DDevice_SetRenderState_DestBlend @2216
;	D3DResource_Release @2218
;	D3DDevice_Release @2219
;	D3DDevice_SetVertexShader @2220
;	D3DDevice_SetPixelShader @2221
;	D3DDevice_SetTexture @2222
;	D3DDevice_SetVertexDeclaration @2223
	D3DDevice_SetIndices @2224
	D3DDevice_SetStreamSource @2225
	D3DDevice_DrawVertices @2226
;	D3DDevice_DrawVerticesUP @2227
	D3DDevice_DrawIndexedVertices @2228
	D3DDevice_DrawIndexedVerticesUP @2229
;	D3DDevice_SetVertexShaderConstantF_ParameterCheck @2230
	D3DDevice_SetPixelShaderConstantF_ParameterCheck @2231
;	D3DDevice_SetSamplerState_ParameterCheck @2232
;	D3DDevice_SetRenderState_ParameterCheck @2233
;	D3DDevice_GetRenderState_ParameterCheck @2234
;	D3DDevice_SetVertexShaderConstantFN @2235
	D3DDevice_SetPixelShaderConstantFN @2236
;	D3DDevice_GetRenderState_ZEnable @2237
;	D3DDevice_GetRenderState_CullMode @2238
;	D3DDevice_GetRenderState_AlphaBlendEnable @2239
;	D3DDevice_GetRenderState_SrcBlendAlpha @2240
;	D3DDevice_GetRenderState_DestBlendAlpha @2241
;	D3DDevice_GetRenderState_BlendOp @2242
;	D3DDevice_GetRenderState_ViewportEnable @2243
;	D3DDevice_SetRenderState_ZEnable @2244
;	D3DDevice_SetRenderState_CullMode @2245
;	D3DDevice_SetRenderState_AlphaBlendEnable @2246
;	D3DDevice_SetRenderState_SrcBlendAlpha @2247
;	D3DDevice_SetRenderState_DestBlendAlpha @2248
;	D3DDevice_SetRenderState_BlendOp @2249
;	D3DDevice_SetRenderState_ViewportEnable @2250
;	D3DDevice_SetSamplerState_MagFilter @2251
;	D3DDevice_SetSamplerState_MinFilter @2252
	D3DDevice_SetSamplerState_AddressU @2253
	D3DDevice_SetSamplerState_AddressV @2254
;	XGSetTextureHeader @2255
;	XGGetTextureDesc @2256
	XGOffsetResourceAddress @2257
;	D3DResource_AddRef @2258
	XGSetTextureHeaderEx @2262
;	D3DDevice_GetRenderTarget @2263
	D3DDevice_SetRenderTarget @2264
	D3DDevice_GetDepthStencilSurface @2265
	D3DDevice_SetDepthStencilSurface @2266
;	D3DDevice_Resolve @2267
	D3DDevice_SetPixelShaderConstantB @2268
;	XamNuiGetDeviceSerialNumber @2269
;	XamNuiGetLoadedDepthCalibration @2270
;	XamNuiGetTrueColorInfo @2271
;	XamNuiGetCameraIntrinsics @2272
;	XamNuiGetFanRate @2273
;	XamNuiGetSupportString @2274
;	XamKinectGetHardwareType @2275
;	XamMediaVerificationCreate @2491
;	XamMediaVerificationClose @2492
;	XamMediaVerificationVerify @2493
;	XamMediaVerificationFailedBlocks @2494
;	XamMediaVerificationInject @2495
;	XamShowBadDiscErrorUI @2496
;	XamBackgroundDownloadSetMode @2500
;	XamBackgroundDownloadIsEnabled @2501
;	XamBackgroundDownloadGetActiveItem @2502
;	XamBackgroundDownloadGetItems @2503
;	XamBackgroundDownloadClearItems @2504
;	XamBackgroundDownloadItemAdd @2505
;	XamBackgroundDownloadItemRemove @2506
;	XamBackgroundDownloadItemMakeFirst @2507
;	XamBackgroundDownloadSetForegroundPriority @2508
;	XamBackgroundDownloadGetForegroundPriority @2509
;	XamBackgroundDownloadItemToContentData @2510
;	XamBackgroundDownloadItemGetStatus @2511
;	XamBackgroundDownloadHistoryGetItem @2512
;	XamBackgroundDownloadItemGetHistoryStatus @2513
;	XamBackgroundDownloadItemSetHistoryStatus @2514
;	XamBackgroundDownloadItemGetStatusAsync @2515
;	XamBackgroundDownloadItemGetStatusEx @2516
;	XamBackgroundDownloadItemGetHistoryStatusEx @2517
;	XamBackgroundDownloadBindItems @2518
;	XamBackgroundDownloadSetPollingActive @2519
;	XamBackgroundDownloadGetPollingActive @2520
;	XamBackgroundDownloadGetMode @2521
;	XamBackgroundDownloadGetUnexpectedChangeCount @2522
;	XamBackgroundDownloadIsItemForThisConsole @2523
;	XamBackgroundDownloadSelectDevice @2524
;	XamBackgroundDownloadItemModify @2525
;	XamBackgroundDownloadCacheLegacyMappingInfo @2526
;	XamBackgroundDownloadGetLegacyMappingInfo @2527
;	XamBackgroundDownloadGetLegacyId @2528
	XamBackgroundDownloadDoFail @2529
;	XamSwapDisc @2600
;	XamSwapDiscPatchAddress @2601
;	XamSwapCancel @2602
;	XamRamDriveCreate @2610
;	XamRamDriveDestroy @2611
;	XamPlayTimerGetData @2650
;	XamPlayTimerSetData @2651
;	XamPlayTimerResume @2652
;	XamPlayTimerSuspend @2653
;	XamPlayTimerIsRunning @2654
;	XamPlayTimerIsEnabled @2655
;	XamPlayTimerGetNextResetDate @2656
;	XamPlayTimerFormatDurationString @2657
;	XamPlayTimerGetTimeRemaining @2658
;	XamPlayTimerUpdateTimeRemaining @2659
;	XamPlayTimerForceNotification @2660
;	XamPlayTimerRefreshResetDate @2661
	XuiResourceOpenAndVerifyNoLoc @2662
	UpnpAVServerSearchInitialize @2670
	UpnpAVServerSearchDestroy @2671
	UpnpAVServerSearchStart @2672
;	Destroy@CUpnpAVServerSearch @2673
	UpnpAVServerSearchDoWork @2674
	UpnpAVServerSearchGetNextServer @2675
;	XCustomBroadcastGamercardEvent @2700
;	XamCustomGetCurrentActions @2701
;	XamInstrumentationLogEvent @2720
;	XamRegisterSMCNotification @2721
;	XamInstrumentationLogEventEx @2730
;	XamInstrumentationGetSourceConfig @2731
	XamInstrumentationDebugConfig @2732
;	CurlCreateCacheEntry @2780
;	CurlOpenCacheEntry @2781
;	CurlSetCacheEntryExpireTime @2782
;	CurlReadCacheEntryHeaders @2783
;	CurlReadCacheEntryContent @2784
;	CurlWriteCacheEntryContent @2785
;	CurlCloseCacheEntry @2786
;	CurlEnumerateCacheEntry @2787
;	CurlWipeBackingFiles @2789
;	CurlOpenTitleBackingFile @2791
;	XamSetSecurityViolationDetected @2800
;	XamIsSecurityViolationDetected @2801
;	XamIsAnySecurityViolationDetected @2802
;	XamGetSecurityViolationsDetected @2803
;	XamActivateCounterMeasure @2804
;	XamDeactivateCounterMeasure @2805
;	XamIsCounterMeasureActivated @2806
;	XamGetActiveCounterMeasures @2807
;	XamPmdIdentify @2808
;	XamPmdSendCommand @2809
;	XamPmdReadReport @2810
;	XamPartyCreate @2812
;	XamPartyLeave @2813
;	XamPartySendInviteDeprecated @2814
;	XamPartyGetUserList @2815
;	XamPartySendGameInvites @2816
;	XamPartyJoin @2817
;	XamPartyKickUser @2818
;	XamPartyAddLocalUsers @2819
;	XamConvertEmoticons @2820
;	XamGetLocaleTimeFormat @2821
;	XamPartyRemoveLocalUsers @2822
;	XamPartyGetUserListInternal @2823
;	XamPartySetJoinable @2824
;	XamPartyGetJoinable @2825
;	XamPartyGetInfo @2826
;	XamPartySetCustomData @2827
	XamPartySetConnectivityGraph @2828
	XamPartyGetRoutingTable @2829
;	XamPartyAutomationInprocCall @2830
;	XamPartyGetState @2831
;	XamPartyGetBandwidth @2832
;	XamPartyGetNetworkCounters @2833
;	XamShowQuickLaunchUI @2834
;	XamPartyIsCoordinator @2835
;	XamPartyGetFormation @2836
;	XamPartySendInvite @2837
	XamPartySetTestDelay @2838
	XamPartyOverrideNatType @2839
;	XamPartyGetAccessLevel @2840
	XamPartySetTestFlags @2841
;	XamIsSystemExperienceTitleId @2842
;	XamPartyJoinEx @2843
;	XamPartyGetInfoEx @2844
;	XamTaskSetCancelSubTasks @2850
;	XamTaskGetCompletionStatus @2851
;	XamTaskCancelWaitAndCloseWaitTask @2852
;	XamWebInstrumentationCreateReport @2860
;	XamWebInstrumentationSetUserVar @2861
;	XamWebInstrumentationSetUserVarNoEscape @2862
;	XamWebInstrumentationGetURL @2863
;	XamWebInstrumentationSendReport @2864
;	XamWebInstrumentationDestroyReport @2865
;	XamWebInstrumentationCreateSampledReport @2866
;	XampSetSamplingRandomValue @2867
;	XampWebInstrumentationSetProfileCounts @2868
;	XamWebInstrumentationGetURLEx @2869
	XampSetOmnitureCallbackFunction @2870
;	XamShowQuickChatUIp @2871
;	XamShowSocialPostUI @2872
;	XamShowBeaconsUI @2873
;	XamShowMarketplacePurchaseOrderUI @2874
;	XamShowMarketplaceGetOrderReceipts @2875
;	XamShowGenericOnlineAppUI @2876
;	XamUserAllowedToPostToSocialNetwork @2877
;	XamShowMarketplacePurchaseOrderUIEx @2878
	DebugXamShowMessageBoxUI_Wait @2879
;	XamUserGetXUIDForTFA @2888
;	XamVerifyXSignerSignature @2890

```

`XenonDumper/libs/xkelib/xam/xamext21256.0.def`:

```def
LIBRARY xam.xex@21256.0+1861.0
EXPORTS
;	NetDll_WSAStartup @1
;	NetDll_WSACleanup @2
;	NetDll_socket @3
;	NetDll_closesocket @4
;	NetDll_shutdown @5
;	NetDll_ioctlsocket @6
;	NetDll_setsockopt @7
;	NetDll_getsockopt @8
;	NetDll_getsockname @9
;	NetDll_getpeername @10
;	NetDll_bind @11
;	NetDll_connect @12
;	NetDll_listen @13
;	NetDll_accept @14
;	NetDll_select @15
;	NetDll_WSAGetOverlappedResult @16
;	NetDll_WSACancelOverlappedIO @17
;	NetDll_recv @18
;	NetDll_WSARecv @19
;	NetDll_recvfrom @20
;	NetDll_WSARecvFrom @21
;	NetDll_send @22
;	NetDll_WSASend @23
;	NetDll_sendto @24
;	NetDll_WSASendTo @25
;	NetDll_inet_addr @26
;	NetDll_WSAGetLastError @27
;	NetDll_WSASetLastError @28
;	NetDll_WSACreateEvent @29
;	NetDll_WSACloseEvent @30
;	NetDll_WSASetEvent @31
;	NetDll_WSAResetEvent @32
;	NetDll_WSAWaitForMultipleEvents @33
;	NetDll___WSAFDIsSet @34
;	NetDll_WSAEventSelect @35
;	NetDll_WSAStartupEx @36
;	NetDll_XNetStartup @51
;	NetDll_XNetCleanup @52
;	NetDll_XNetRandom @53
;	NetDll_XNetCreateKey @54
;	NetDll_XNetRegisterKey @55
;	NetDll_XNetUnregisterKey @56
;	NetDll_XNetXnAddrToInAddr @57
;	NetDll_XNetServerToInAddr @58
;	NetDll_XNetTsAddrToInAddr @59
;	NetDll_XNetInAddrToXnAddr @60
;	NetDll_XNetInAddrToServer @61
;	NetDll_XNetInAddrToString @62
;	NetDll_XNetUnregisterInAddr @63
;	NetDll_XNetXnAddrToMachineId @64
;	NetDll_XNetConnect @65
;	NetDll_XNetGetConnectStatus @66
;	NetDll_XNetDnsLookup @67
;	NetDll_XNetDnsRelease @68
;	NetDll_XNetQosListen @69
;	NetDll_XNetQosLookup @70
;	NetDll_XNetQosServiceLookup @71
;	NetDll_XNetQosRelease @72
;	NetDll_XNetGetTitleXnAddr @73
;	NetDll_XNetGetDebugXnAddr @74
;	NetDll_XNetGetEthernetLinkStatus @75
;	NetDll_XNetGetBroadcastVersionStatus @76
;	NetDll_XNetQosGetListenStats @77
;	NetDll_XNetGetOpt @78
;	NetDll_XNetSetOpt @79
;	NetDll_XNetStartupEx @80
;	NetDll_XNetReplaceKey @81
;	NetDll_XNetGetXnAddrPlatform @82
	NetDll_XNetGetSystemLinkPort @83
	NetDll_XNetSetSystemLinkPort @84
;	NetDll_XNetDnsReverseLookup @85
;	NetDll_XNetDnsReverseRelease @86
;	NetDll_XnpLoadConfigParams @101
;	NetDll_XnpSaveConfigParams @102
;	NetDll_XnpConfigUPnP @103
;	NetDll_XnpConfig @104
;	NetDll_XnpGetConfigStatus @105
;	NetDll_XnpLoadMachineAccount @106
;	NetDll_XnpSaveMachineAccount @107
;	NetDll_XnpCapture @108
;	NetDll_XnpEthernetInterceptSetCallbacks @109
;	NetDll_XnpEthernetInterceptXmit @110
;	NetDll_XnpEthernetInterceptRecv @111
;	NetDll_XnpLogonGetStatus @112
;	NetDll_XnpLogonGetQFlags @113
;	NetDll_XnpLogonSetQFlags @114
;	NetDll_XnpLogonSetQEvent @115
;	NetDll_XnpLogonClearQEvent @116
;	NetDll_XnpLogonGetQVals @117
;	NetDll_XnpLogonSetQVals @118
;	NetDll_XnpLogonSetPState @119
;	NetDll_XnpGetVlanXboxName @120
;	NetDll_XnpSetVlanXboxName @121
;	NetDll_XnpGetActiveSocketList @122
;	NetDll_XnpNoteSystemTime @123
;	NetDll_XnpRegisterKeyForCallerType @124
;	NetDll_XnpUnregisterKeyForCallerType @125
;	NetDll_XnpLogonGetChallenge @126
;	NetDll_XnpLogonClearChallenge @127
;	NetDll_XnpLogonSetChallengeResponse @128
;	NetDll_XnpGetSecAssocList @129
;	NetDll_XnpGetKeyList @130
;	NetDll_XnpGetQosLookupList @131
;	NetDll_XnpPersistTitleState @132
;	NetDll_XnpReplaceKeyForCallerType @133
;	NetDll_XnpEthernetInterceptSetExtendedReceiveCallback @134
;	NetDll_XnpQosHistoryLoad @135
;	NetDll_XnpQosHistorySaveMeasurements @136
;	NetDll_XnpQosHistoryGetEntries @137
;	NetDll_XnpQosHistoryGetAggregateMeasurement @138
;	NetDll_XnpToolSetCallbacks @139
;	NetDll_XnpToolIpProxyInject @140
;	NetDll_XnpUpdateConfigParams @141
;	NetDll_XnpEthernetInterceptXmitAsIp @142
;	NetDll_XnpConfigUPnPPortAndExternalAddr @143
;	NetDll_XmlDownloadStart @151
;	NetDll_XmlDownloadContinue @152
;	NetDll_XmlDownloadStop @153
;	NetDll_XmlDownloadGetParseTime @154
;	NetDll_XmlDownloadGetReceivedDataSize @155
;	XnpGetXwppMemoryLogSnapshot @198
;	XnpGetXwppRuntimeFilter @199
;	NetDll_XHttpStartup @201
;	NetDll_XHttpShutdown @202
;	NetDll_XHttpOpen @203
;	NetDll_XHttpCloseHandle @204
;	NetDll_XHttpConnect @205
;	NetDll_XHttpSetStatusCallback @206
;	NetDll_XHttpOpenRequest @207
;	NetDll_XHttpOpenRequestUsingMemory @208
;	NetDll_XHttpSendRequest @209
;	NetDll_XHttpReceiveResponse @210
;	NetDll_XHttpQueryHeaders @211
;	NetDll_XHttpReadData @212
;	NetDll_XHttpWriteData @213
;	NetDll_XHttpQueryOption @214
;	NetDll_XHttpSetOption @215
;	NetDll_XHttpDoWork @216
;	NetDll_XHttpSetCredentials @217
;	NetDll_XHttpQueryAuthSchemes @218
;	NetDll_XHttpCrackUrlW @219
;	NetDll_XHttpCrackUrl @220
;	NetDll_XHttpCreateUrl @221
;	NetDll_XHttpCreateUrlW @222
;	NetDll_XHttpResetPerfCounters @223
;	NetDll_XHttpGetPerfCounters @224
;	NetDll_UpnpStartup @251
;	NetDll_UpnpCleanup @252
;	NetDll_UpnpSearchCreate @253
;	NetDll_UpnpSearchGetDevices @254
;	NetDll_UpnpDescribeCreate @255
;	NetDll_UpnpDescribeGetResults @256
;	NetDll_UpnpActionCalculateWorkBufferSize @257
;	NetDll_UpnpActionCreate @258
;	NetDll_UpnpActionGetResults @259
;	NetDll_UpnpEventCreate @260
;	NetDll_UpnpEventGetCurrentState @261
;	NetDll_UpnpEventUnsubscribe @262
;	NetDll_UpnpDoWork @263
;	NetDll_UpnpCloseHandle @264
;	XNetLogonGetLoggedOnUsers @301
;	XNetLogonGetNatType @302
;	XNetLogonTaskStart @303
;	XNetLogonTaskClose @304
;	XNetLogonTaskContinue @305
;	XNetLogonGetServiceInfo @306
;	XNetLogonGetUserPrivileges @307
;	XNetLogonSetConsoleCertificate @308
;	XNetLogonGetMachineID @309
;	XNetLogonGetTitleID @310
;	XNetLogonGetTitleVersion @311
;	XNetLogonGetServiceNetworkID @312
;	XNetLogonGetDnsString @313
;	XNetLogonSetTitleID @314
;	XNetLogonGetExtendedStatus @315
;	XNetLogonClearTicketCaches @316
;	XNetLogonInitOverrideInfo @317
;	XNetLogonGetLastUPnPStatus @318
;	XNetLogonGetFlowToken @319
;	XNetLogonGetTicketOpt @320
;	XNetLogonSetTicketOpt @321
;	XNetLogonGetState @322
;	XamInputGetCapabilities @400
;	XamInputGetState @401
;	XamInputSetState @402
;	XamInputGetKeystroke @403
;	XamInputEnableAutobind @404
;	XamInputRawState @405
;	XamEnableSystemAppInput @406
	XamInputGetDeviceStats @407
;	XamInputGetKeystrokeEx @408
;	XamInputGetKeystrokeHud @409
;	XamInputSetLayoutKeyboard @410
;	XamInputToggleKeyLocks @411
;	XamInputResetLayoutKeyboard @412
;	XamInputGetKeystrokeHudEx @413
;	XamInputSetKeyboardTranslationHud @414
;	XamSetInactivityTime @415
;	XamEnableInactivityProcessing @416
;	XamResetInactivity @417
;	XamSetInactivityTimeFromConfig @418
	XamLoaderGetMediaInfo @419
	XamLoaderLaunchTitle @420
	XamLoaderLaunchTitleEx @421
	XamLoaderSetLaunchData @422
	XamLoaderGetLaunchDataSize @423
	XamLoaderGetLaunchData @424
	XamLoaderTerminateTitle @425
	XamLoaderGetDvdTrayState @426
	XamLoaderGetGameInfo @427
	XamLoaderLaunchTitleOnDvd @428
	XamLoaderSetSpindleSpeed @429
;	XamTaskCreateQueue @430
;	XamTaskSchedule @431
;	XamTaskReschedule @432
;	XamTaskCloseHandle @433
;	XamTaskCancel @434
;	XamTaskShouldExit @435
;	XamTaskWaitOnCompletion @436
;	XamTaskModify @437
;	XamTaskGetCurrentTask @438
;	XamTaskGetAttributes @439
;	XamExecutingOnBehalfOfTitle @440
;	XamInputSendStayAliveRequest @441
;	XamInputGetUserVibrationLevel @442
;	XamIsSystemTitleId @443
	XamLoaderIsTitleTerminatePending @444
	XamLoaderGetPriorTitleId @446
;	XamIsXbox1TitleId @447
;	XamInputSetKeyLocks @448
;	XamInputGetKeyLocks @449
;	XamTaskGetStatus @450
;	XamGetRootObj @451
	XamDevAuthSetFault @452
;	XamGetDefaultSystemImage @453
;	XamGetWCNConfigFile @454
;	XamSetPowerMode @455
;	XamExecuteChallenge @456
;	XamGetDefaultImage @457
;	XamMuteSound @458
;	XamGetOnlineSchema @459
;	XamSetDashContext @460
	XamGetDashContext @461
;	XamIsCurrentTitleDash @462
;	XamGetCurrentTitleId @463
	XamSetCurrentTitleDash @464
	XamAllocHeapFreeSpace @465
;	XamSetHudContext @468
;	XamGetHudContext @469
;	XCustomSetAction @472
;	XCustomGetLastActionPress @473
;	XCustomSetDynamicActions @474
;	XCustomBroadcastActionEvent @475
;	XCustomGetLastActionPressEx @476
;	XCustomRegisterDynamicActions @477
;	XCustomUnregisterDynamicActions @478
;	XCustomGetCurrentGamercard @479
;	XamDbgPrint @480
	XamDbgSetOutputLevel @481
	XamDbgSetBreakLevel @482
	XamLoaderGetMediaInfoEx @483
;	XamLoaderSetGameInfo @484
;	XamFormatMessage @485
;	XamUniSortCmpString @486
;	XamFormatTimeString @487
;	XamFormatDateString @488
;	XamGetLocaleDateFormat @489
;	XamAlloc @490
;	XamAllocEx @491
;	XamFree @492
;	XamAllocSize @493
;	XamAllocFreeIPTVHeap @496
;	XamDeviceRemap @497
;	XamLoaderGetClearCache @498
;	XamLoaderSetClearCache @499
;	XMsgInProcessCall @500
;	XMsgCompleteIORequest @501
;	XMsgSystemProcessCall @502
;	XMsgStartIORequest @503
;	XMsgCancelIORequest @504
;	XMsgAcquireAsyncMessageFromOverlapped @505
;	XMsgReleaseAsyncMessageToOverlapped @506
;	XamGetOverlappedResult @507
;	XMsgStartIORequestEx @508
;	XamAppAllocateInterappWorkspace @509
;	XamAppGetInterappWorkspace @510
;	XamAppFreeInterappWorkspace @511
;	XamFeatureEnabled @512
;	XamFeatureEnforceImageBudget @513
;	XamFeatureSetMask @514
;	XamFeatureEnableDisable @515
	XuiControlSetItemAssociation @516
;	XamGetTitleGlobalStorageValue @517
;	XamSetTitleGlobalStorageValue @518
;	XamUserValidateAvatarMetadata @519
;	XamUserGetDeviceContext @520
	XamUserLookupDevice @521
;	XamUserGetXUID @522
;	XamUserLogon @523
;	XamUserGetGamerTag @524
;	XamUserGetUserIndexMask @525
;	XamUserGetName @526
	XamLookupCommonStringByIndex @527
;	XamUserGetSigninState @528
;	XamUserGetIndexFromXUID @529
;	XamUserCheckPrivilege @530
;	XamUserAreUsersFriends @531
;	XamSetUserPresetPresenceState @532
;	XamGetUserPresetPresenceState @533
;	XamUserGetUserFlagsFromXUID @534
;	XamUserGetMembershipTypeFromXUID @535
;	XamUserGetOnlineCountryFromXUID @536
;	XamUserReadProfileSettings @537
;	XamUserWriteProfileSettings @538
;	XamUserGetMembershipType @539
;	XamUserGetUserFlags @540
;	XamUserGetRequestedUserIndexMask @541
;	XamUserIsGuest @542
;	XamUserProfileSync @543
;	XamUserFlushLogonQueue @544
;	XamUserIsOnlineEnabled @545
;	XamUserGetCachedUserFlags @546
;	XamAreMixedAccountsSignedIn @547
;	XamUserLogonEx @548
;	XamUserGetSigninInfo @551
;	XamUserIsPartial @552
;	XamUserGetOnlineLanguageFromXUID @553
;	XamUserReadProfileSettingsEx @554
;	XamSystemUpdaterLogon @555
;	XamUserGetUsersMissingAvatars @556
;	XamIsChildAccountSignedIn @557
;	XamUserPrefetchProfileSettings @558
;	XamUserInvalidateProfileSetting @559
;	XamProfileCreate @560
;	XamProfileCreateEnumerator @561
;	XamProfileEnumerate @562
;	XamProfileDelete @563
;	XamProfileGetCreationStatus @564
;	XamProfileFindAccount @565
;	XamProfileRenameAccount @566
;	XamProfileOpen @567
;	XamProfileClose @568
;	XamProfileSaveAccountInfo @569
;	XamProfileLoadAccountInfo @570
;	XamProfileRecoverTitle @571
;	XamProfileSaveWindowsLiveCredentials @572
;	XamProfileLoadWindowsLiveCredentials @573
;	XamProfileIsSaveWindowsLiveCredsEnabled @574
;	XamProfileSetSaveWindowsLiveCredsEnabled @575
	XamSetProfileReadTestHook @576
;	XamProfileGetLastSync @577
;	XamAccountRecoveryRecoverTitle @578
	XamProfileControlXgi @579
;	XamAppLoad @580
;	XamAppUnloadSelf @581
;	XamAppUnloadStack @582
;	XamSendMessageToLoadedApps @583
;	XamAppRequestLoad @584
;	XamAppUnrequestLoad @585
;	XamNavigate @586
;	XamRegisterSysApp @587
;	XamUnregisterSysApp @588
;	XamCreateEnumeratorHandle @590
;	XamGetPrivateEnumStructureFromHandle @591
;	XamEnumerate @592
;	XamLoadSysApp @593
;	XamUnloadSysApp @594
;	XamReloadSysApp @595
;	XamAppLoadPass2SysApps @596
;	XamProfileGetLiveLegalLocale @597
;	XamUserIsParentalControlled @598
	XamContentLaunchImageFromFileInternal @599
;	XamContentCreate @600
;	XamContentCreateEx @601
;	XamContentClose @602
;	XamContentDelete @603
;	XamContentCreateEnumerator @604
;	XamContentCreateDeviceEnumerator @605
;	XamContentGetDeviceData @606
;	XamContentGetDeviceName @607
;	XamContentSetThumbnail @608
;	XamContentGetThumbnail @609
;	XamContentGetCreator @610
;	XamContentLaunchImage @611
;	XamContentGetAttributes @612
;	XamContentGetDeviceState @613
;	XamContentGetLicenseMask @614
;	XamContentFlush @615
;	XamContentResolve @616
;	XamContentOpenFile @617
;	XamContentInstall @618
;	XamContentLockUnlockPackageHeaders @619
;	XamContentCopyInternal @620
;	XamContentMoveInternal @621
;	XamContentGetMetaDataInternal @622
;	XamContentCreateEnumeratorInternal @623
;	XamContentDeleteInternal @624
;	XamContentCreateInternal @625
;	XamContentSetThumbnailInternal @626
;	XamContentLaunchImageInternal @627
;	XamContentWritePackageHeader @628
;	XamContentDismountAndClosePackage @629
;	XamContentResolveInternal @630
;	XamContentGetAttributesInternal @631
;	XamContentOpenFileInternal @632
;	XamContentAggregateCreateEnumerator @633
;	XamContentCreateAndMountPackage @634
;	XamContentOpenPackageFile @635
;	XamContentMountPackage @636
;	XamContentFlushPackage @637
;	XamContentClosePackageFile @638
;	XamContentDuplicateFileHandle @639
;	XamGetExecutionId @640
;	XamGetGameRatings @641
;	XamGetSystemVersion @642
;	XamContentGetLocalizedString @643
;	XamContentGetDefaultDevice @644
;	XamContentInstallInternal @645
;	XamContentGetDeviceSerialNumber @647
;	XamContentGetMountedPackageByRootName @648
;	XamContentRegisterChangeCallback @649
;	XamNotifyCreateListener @650
;	XNotifyGetNext @651
;	XNotifyPositionUI @652
;	XNotifyDelayUI @653
;	XNotifyBroadcast @654
;	XNotifyRegisterArea @655
	XNotifyQueueUI @656
;	XamNotifyCreateListenerInternal @657
;	XNotifyUISetOptions @658
;	XNotifyUIGetOptions @659
;	XamContentLaunchImageInternalEx @660
;	XamShutdown @661
;	XamAllocDevkitHeapAvailable @662
;	XamNotifyCreateListenerRangeInternal @663
;	XNotifyQueueUIEx @664
;	XamAppRequestLoadEx @665
	XuiPNGTextureLoader @666
	XuiRenderGetXuiDevice @667
	XuiDefault_False @668
;	XamUserGetReportingInfo @669
;	XamUpdateStart @670
;	XamUpdateGetProgress @671
;	XamUpdateFinish @673
;	XamUpdateAttachExtenderInstance @674
;	XamUpdateGetBaseSystemVersion @678
;	XamUpdateGetCurrentSystemVersion @679
;	XamUpdateChainPass3FromPass2 @683
;	XamInputGetCapabilitiesEx @685
;	XamUserIsUnsafeProgrammingAllowed @686
	XamDevAuthSetFaultEx @687
;	XamUpdateGetData @688
	XamCacheIntegrityCheck @689
;	XamCacheStoreFile @690
;	XamCacheFetchFile @691
;	XamCacheOpenFile @692
;	XamCacheCloseFile @693
;	XamGetCachedTitleName @694
;	XamCacheReset @695
;	XamGetCachedGamerTag @696
;	XamGetCachedGamerTagW @697
;	XamCacheDeleteFile @698
	XamCacheRenameFile @699
;	XamShowSigninUI @700
;	XamShowSigninUIEx @701
;	XamShowSigninUIp @702
;	XamShowFriendsUI @703
;	XamShowMessagesUI @704
;	XamShowKeyboardUI @705
;	XamShowQuickChatUI @706
;	XamShowVoiceMailUI @707
;	XamShowGamerCardUI @708
;	XamShowAchievementsUI @709
;	XamShowPlayerReviewUI @710
;	XamShowMarketplaceUI @711
;	XamShowPlayersUI @712
;	XamShowUpdaterUI @713
;	XamShowMessageBoxUI @714
;	XamShowDeviceSelectorUI @715
;	XamShowMessageComposeUI @716
;	XamShowGameInviteUI @717
;	XamShowFriendRequestUI @718
;	XamShowCreateProfileUI @719
;	XamShowGamesUI @720
;	XamShowLiveSignupUI @721
;	XamShowFriendsUIp @722
;	XamShowComplaintUI @723
;	XamShowReputationUI @724
;	XamShowGamerCardUIForXUID @725
;	XamShowForcedNameChangeUI @726
;	XamShowLiveUpsellUI @727
;	XamShowPasscodeVerifyUI @728
;	XamShowDirtyDiscErrorUI @729
;	XamShowSignupCreditCardUI @730
;	XamShowPrivateChatInviteUI @731
;	XamShowMessageBoxUIEx @732
;	XamShowRecentMessageUI @733
;	XamShowRecentMessageUIEx @734
;	XamShowMessagesUIEx @735
;	XamShowAchievementDetailsUI @736
;	XamShowPersonalizationUI @737
;	XamShowChangeGamerTileUI @738
;	XamShowVoiceSettingsUI @739
;	XamShowVideoChatInviteUI @740
;	XamShowCustomMessageComposeUI @741
;	XamShowCustomPlayerListUI @742
;	XamShowMarketplaceDownloadItemsUI @743
;	XamShowMarketplaceUIEx @744
	XamShowMessageBox @745
;	XamIsSysUiInvokedByXenonButton @746
;	XamIsSysUiInvokedByTitle @747
;	XamIsUIActive @748
;	XamSysUiDisableAutoClose @749
;	XamUserCreateAchievementEnumerator @750
;	XamReadTile @751
;	XamWriteGamerTile @752
;	XamWriteTile @753
;	XamReadImage @754
;	XamUserCreateTitlesPlayedEnumerator @755
;	XamDecompressPNGToTexture @756
;	XamReadTileToTexture @757
;	XamReadString @758
;	XamUserCreateStatsEnumerator @759
;	XamPrepareGamerTiles @760
;	XamClearTitle @761
;	XamReadStrings @762
;	XamWriteGamerTileEx @763
;	XamReadTileEx @764
;	XamReadTileToTextureEx @765
;	XamShowLiveUpsellUIEx @768
;	XamShowJoinSessionInProgressUI @769
;	XamShowGraduateUserUI @770
;	XamShowGamerCardUIForXUIDp @771
;	XamShowGuideUI @772
;	XamShowPartyUI @773
;	XamShowPartyInviteUI @774
;	XamUserAddRecentPlayer @775
;	XamUserUpdateRecentPlayer @776
;	XamUserCreatePlayerEnumerator @777
;	XamParseGamerTileKey @778
;	XamShowCommunitySessionsUI @779
;	XamVoiceCreate @780
;	XamVoiceHeadsetPresent @781
;	XamVoiceSubmitPacket @782
;	XamVoiceClose @783
;	XamVoiceGetBatteryStatus @784
;	XamShowJoinSessionByIdInProgressUI @787
;	XamShowPartyJoinInProgressUI @788
;	XamBuildSharedSystemResourceLocator @789
;	XamSessionCreateHandle @790
;	XamSessionRefObjByHandle @791
;	XamVoiceGetMicArrayStatus @792
;	XamVoiceSetAudioCaptureRoutine @793
;	XamVoiceGetDirectionalData @794
;	XamBuildResourceLocator @795
;	XamBuildLegacySystemResourceLocator @796
;	XamBuildGamercardResourceLocator @797
;	XamBuildDynamicResourceLocator @798
;	XamBuildXamResourceLocator @799
	XuiAnimRun @800
	XuiApplyLocale @801
	XuiBubbleMessage @802
	XuiControlIsBackButton @803
	XuiControlIsNavButton @804
	XuiCreateObject @805
	XuiDestroyObject @806
	XuiDynamicCast @807
	XuiElementAddChild @808
	XuiElementFindNamedFrame @809
	XuiElementGetChildById @810
	XuiElementGetFirstChild @811
	XuiElementGetFocus @812
	XuiElementGetFocusUser @813
	XuiElementGetId @814
	XuiElementGetLastChild @815
	XuiElementGetNext @816
	XuiElementGetParent @817
	XuiElementGetUserFocus @818
	XuiElementInitFocus @819
	XuiElementInitUserFocus @820
	XuiElementPlayTimeline @821
	XuiElementSetBounds @822
	XuiElementSetFocus @823
	XuiElementSetUserFocus @824
	XuiElementTreeGetFocus @825
	XuiFindClass @826
	XuiFreeStringTable @827
	XuiGetBaseObject @828
	XuiGetClass @829
	XuiGetObjectClass @830
	XuiGetOuter @831
	XuiInit @832
	XuiLoadFromBinary @833
	XuiLoadStringTableFromFile @834
	XuiVisualGetBasePath @835
	XuiLookupStringTable @836
	XuiNavButtonGetPressPath @837
	XuiObjectFromHandle @838
	XuiObjectGetProperty @839
	XuiObjectGetPropertyId @840
	XuiProcessInput @841
	XuiRegisterClass @842
	XuiRenderBegin @843
	XuiRenderCreateDC @844
	XuiRenderDCDeviceChanged @845
	XuiRenderDestroyDC @846
	XuiRenderEnd @847
	XuiRenderGetBackBufferSize @848
	XuiRenderInit @849
	XuiRenderInitShared @850
	XuiRenderPresent @851
	XuiRenderSetViewTransform @852
	XuiRenderUninit @853
;	XamShowNuiGuideUI @854
	XuiSceneCreate @855
	XuiSceneNavigateBack @856
	XuiSceneNavigateFirst @857
	XuiSceneNavigateForward @858
	XuiScenePlayBackFromTransition @859
	XuiScenePlayBackToTransition @860
	XuiScenePlayFromTransition @861
	XuiScenePlayToTransition @862
	XuiSendMessage @863
	XuiSetLocale @864
	XuiUninit @865
	XuiUnregisterClass @866
	XuiTextElementSetText @867
	XuiSetTimer @868
	XuiTimersRun @869
	XuiTextElementGetText @870
	XuiVisualSetBasePath @871
	XuiHandleIsValid @872
	XuiAlloc @873
	XuiFree @874
	XuiDefault_True @875
	XuiDefault_EmptyString @876
	XuiDefault_IntegerZero @877
	XuiCopyString @878
	XuiRealloc @879
	XuiControlPlayOptionalVisual @880
	XuiKillTimer @881
	XuiElementEnableInput @882
	XuiElementInputEnabled @883
	XuiIsInstanceOf @884
	XuiResourceComposeLocator @885
	XuiResourceLocatorIsAbsolute @886
	XuiBroadcastMessage @887
	XuiElementDisallowRecursiveTimelineControl @888
	XUIElementPropVal_Construct @889
	XUIElementPropVal_Destruct @890
	XUIElementPropVal_SetString @891
	XuiObjectSetProperty @892
	XuiElementGetOpacity @893
	XuiElementSetOpacity @894
	XuiEditSetTextLimit @895
	XuiEditGetTextLimit @896
	XuiSliderSetValue @897
	XuiSliderGetValue @898
	XuiSliderSetRange @899
	XuiElementUnlink @900
	XuiElementInsertChild @901
	XuiSceneNavigateBackToFirst @902
	XuiProgressBarSetRange @903
	XuiProgressBarSetValue @904
	XuiProgressBarGetValue @905
	XuiControlAttachVisual @906
	XuiCreateTextureBrush @907
	XuiDestroyBrush @908
	XUIElementPropVal_SetColorFromUint @909
	XuiFigureSetFill @910
	XuiSliderGetRange @911
	XuiFigureSetTexture @912
	XuiControlGetItemAssociation @913
	XuiResourceLoadAll @914
	XuiImageElementSetImagePath @915
	XuiImageElementGetImagePath @916
	XuiControlGetVisual @917
	XuiControlGetNavigation @918
	XuiLookupStringTableByIndex @919
	XUIElementPropVal_SetBool @920
	XuiElementHasFocus @921
	XUIElementPropVal_SetUint @922
	XUIElementPropVal_Clear @923
	XuiEditSetTextFormatInfo @924
	XuiCreateSolidBrush @925
	XuiSceneInterruptTransitions @926
	XuiResourceOpen @927
	XuiResourceRead @928
	XuiResourceClose @929
	XuiVisualCreateInstance @930
	XuiElementGetTimeline @931
;	GetCodecVersion@CCalMediaInfo @932
	XuiElementIsDescendant @933
	XuiSetMessageFilter @934
	XuiAttachTextureBrush @935
	XuiElementBeginRender @936
	XuiElementEndRender @937
	XuiDrawShape @938
	XuiSelectBrushEx @939
	XuiFigureGetShape @940
	XuiFillRect @941
	XuiVec2TransformCoord @942
	XuiMatrixMultiply @943
	XuiElementGetXForm @944
	XuiElementSetPosition @945
	XuiSelectBrush @946
	XuiElementRenderChildren @947
	XuiFreeUnusedTextures @948
	XuiListEnableItemOverride @949
	XuiListGetDefaultItemSize @950
	XuiResourceSeek @951
	XuiElementDiscardResources @952
	XuiTabSceneGoto @953
	XuiTabSceneGetCurrentTab @954
;	XamShowEditProfileUI @956
;	XamShowTermsOfUseUI @958
;	XamShowJoinPartyUI @959
;	XamShowWordRegisterUI @960
;	XamOverrideHudOpenType @961
;	XamShowAchievementsUIEx @962
;	XamUserGetUserTenure @963
;	XamUserGetSubscriptionType @964
;	XamShowGameVoiceChannelUI @965
;	XamShowAvatarAwardsUI @966
;	XamShowAvatarAwardGamesUI @967
;	XamShowVideoRichPresenceUI @968
	XamHudGetUserIndex @969
;	XGetAudioFlags @970
;	XGetAVPack @971
;	XGetGameRegion @972
;	XGetLanguage @973
;	XapipGetLocale @974
;	XGetVideoFlags @975
;	XGetVideoStandard @976
;	XGetVideoMode @977
;	XamGetLanguage @978
	XUITimeline_Run @979
;	XamSetAutomation @980
;	XAutomationpBindController @981
;	XAutomationpUnbindController @982
;	XAutomationpInputXenonButton @983
;	XAutomationpInputPress @984
;	XAutomationpInputSetState @985
;	XamEnableOverdraw @986
;	g_XuiAutomation @987
;	XamVoiceGetMicArrayAudio @988
;	XampSystemInput @989
;	XamInputControl @990
	XuiElementGetPosition @991
;	XamIsMessageBoxActive @992
;	XamIsBackgroundSceneInTransition @993
	XuiElementTreeHasFocus @994
	XuiFigureClose @995
;	GamerCardStartup @996
;	GamerCardCleanup @997
;	GamerCardRegisterControls @998
;	GamerCardUnregisterControls @999
	RtlFindFirstFile @1000
	RtlFindNextFile @1001
	RtlGetModuleFileName @1002
;	RtlOutputDebugString @1003
	RtlRemoveDirectory @1004
	RtlSleep @1005
	RtlGetLastError @1006
	RtlSetLastError @1007
	RtlSetLastNTError @1008
	RtlDebugPrint @1009
;	RtlDebugError @1010
;	XDebugWarning @1011
	RtlDebugTrace @1012
	RtlDebugEntry @1013
	RtlDebugExit @1014
	RtlGetAttributesOnHeapAlloc @1015
	RtlSetAttributesOnHeapAlloc @1016
	XuiFigureSetShape @1017
	RtlCreateHeap @1018
	RtlDestroyHeap @1019
;	RtlAllocateHeap @1020
	RtlAllocateHeapSlowly @1021
;	RtlReAllocateHeap @1022
;	RtlFreeHeap @1023
	RtlFreeHeapSlowly @1024
;	RtlSizeHeap @1025
	RtlZeroHeap @1026
	RtlDebugWalkHeap @1027
	RtlWalkHeap @1028
	RtlLockHeap @1029
	RtlUnlockHeap @1030
;	RtlValidateHeap @1031
	RtlDebugCompactHeap @1032
	RtlCompactHeap @1033
	XamAppSetTestOption @1034
;	XamAppReportError @1035
;	XamIsNuiUIActive @1036
;	XamVerifyPasscode @1037
	OutputDebugStringA @1038
	DebugBreak @1039
	GetCurrentThreadId @1040
	XDebugError @1041
;	XDebugWarning @1042
	RtlDebugSetLevel @1043
	CloseHandle @1044
	GetTickCount @1045
	GetLastError @1046
	SetFilePointer @1047
	SetFilePointerEx @1048
	SetLastError @1049
	MultiByteToWideChar @1050
	WideCharToMultiByte @1051
	ReadFile @1052
	FlushFileBuffers @1053
	WriteFile @1054
	OutputDebugStringW @1055
	SetEvent @1056
	XapiFormatTimeOut @1057
	CreateMutexA @1058
	OpenMutexA @1059
	ReleaseMutex @1060
	WaitForSingleObject @1061
	WaitForSingleObjectEx @1062
	GetFileSize @1063
	GetFileSizeEx @1064
	XapiDirectoryInformationToFindData @1065
	XapiFormatObjectAttributes @1066
	ResetEvent @1067
	wsprintfA @1068
	wsprintfW @1069
	GetOverlappedResult @1070
	QueryPerformanceCounter @1071
	QueryPerformanceFrequency @1072
	LocalAlloc @1073
	LocalFree @1074
	RaiseException @1075
	RtlUniform @1076
	RtlRandom @1077
	Sleep @1078
	SleepEx @1079
	XMemSet @1080
	XRegisterThreadNotifyRoutine @1081
	XGetOverlappedExtendedError @1082
	XGetOverlappedResult @1083
	CreateThread @1084
	ResumeThread @1085
	ExitThread @1086
	GetTimeZoneInformation @1087
	GetSystemTimeAsFileTime @1088
	SystemTimeToFileTime @1089
	FileTimeToSystemTime @1090
	GetSystemTime @1091
	GetLocalTime @1092
	CreateDirectoryA @1093
	CreateEventA @1094
	CreateFileA @1095
	DeleteFileA @1096
	FindFirstFileA @1097
	FindNextFileA @1098
	GetFileAttributesA @1099
;	XamLoaderGetCurrentTitleD3DVersion @1100
	GetFileAttributesExA @1101
	GetModuleHandleA @1102
	GetDiskFreeSpaceExA @1103
	CopyFileA @1104
	SetEndOfFile @1105
;	XamFamilyAddParentalExemptionToList @1106
;	XamFamilyIsParentalValidationRequired @1107
;	PIXAddCounter @1110
	SetWaitableTimer @1112
	CancelWaitableTimer @1113
	CreateWaitableTimerA @1114
	DuplicateHandle @1115
	XapipCreateThread @1116
	lstrcpyA @1117
	lstrcpyW @1118
	lstrcpynA @1119
	lstrcpynW @1120
	lstrcatA @1121
	lstrcatW @1122
	lstrlenA @1123
	lstrlenW @1124
	IsBadReadPtr @1125
	IsBadWritePtr @1126
	FileTimeToLocalFileTime @1127
	XMemCpy @1128
	XMemCpyStreaming @1129
;	XamHudSetUserIndex @1130
;	XamShowNuiTroubleshooterUI @1131
	XamTestShowNuiTroubleshooterUI @1132
;	XamShowPasscodeVerifyUIEx @1133
;	XamShowNuiAchievementsUI @1134
;	XamShowNuiCommunitySessionsUI @1135
;	XamShowNuiDeviceSelectorUI @1136
;	XamShowNuiDirtyDiscErrorUI @1137
;	XamShowNuiFriendsUI @1138
;	XamShowNuiGameInviteUI @1139
;	XamShowNuiGamerCardUIForXUID @1140
;	XamShowNuiMarketplaceDownloadItemsUI @1141
;	XamShowNuiMarketplaceUI @1142
;	XamShowNuiMessageBoxUI @1143
;	XamShowNuiPartyUI @1144
;	XamShowNuiFriendRequestUI @1145
;	XamShowNuiSigninUI @1146
;	XamShowNuiControllerRequiredUI @1147
;	XamShowNuiGamesUI @1148
;	XamShowNuiHardwareRequiredUI @1149
;	XamCacheStoreFileByString @1150
;	XamCacheFetchFileByString @1151
;	XamCacheDeleteFileByString @1152
;	XamGetCachedTitleNameEx @1153
;	XamXlfsInitializeUploadQueue @1154
;	XamXlfsUninitializeUploadQueue @1155
;	XamXlfsMountUploadQueueInstance @1156
;	XamXlfsUnmountUploadQueueInstance @1157
;	XamVoiceRecordUserPrivileges @1158
	XamXlfsInitializeUploadQueueWithTestHooks @1159
;	XamXlfsNotifyContentDeletion @1160
;	XMemAlloc @1161
;	XMemFree @1162
;	XMemSize @1163
;	XamVoiceSetMicArrayIdleUsers @1164
;	XamVoiceMuteMicArray @1165
;	XamVoiceGetMicArrayUnderrunStatus @1166
	XuiSceneEnableTransitionDependency @1167
;	XamVoiceGetMicArrayAudioEx @1168
;	XamShowLeaveFamilyUI @1169
;	XamUserGetDeviceId @1170
;	XamUpdateEtxLogUpdateTaskStart @1171
;	XamUpdateEtxLogUpdateTaskSuccess @1172
;	XamUpdateEtxLogUpdateTaskFailure @1173
;	XamEtxFlushLogs @1174
;	XamVoiceIsActiveProcess @1175
	XamInactivityGetInactivityInterruptTime @1176
	XamInactivitySetInactivityInterruptTime @1177
	XamInactivityGetLastActivityTime @1178
	XamInactivitySetDetectionTaskPeriod @1179
	XamInactivityEnablePowerDown @1180
;	XamUpdateGetChainMarker @1181
;	XGetVideoCapabilities @1182
;	XMsgProcessRequest @1183
;	XGetDisplaySize @1184
;	XamInputNonControllerGetRaw @1185
;	XamInputNonControllerSetRaw @1186
;	XamVoiceSetMicArrayBeamAngle @1187
;	XamUserGetAge @1188
;	XamUserGetAgeGroup @1189
;	XamVoiceGetMicArrayFilenameDesc @1190
;	XamLoaderGetState @1191
;	XamTaskQueryProperty @1192
;	XamGetLocale @1193
;	XamQueryTimeZoneInformation @1194
;	XamSetTimeZoneInformation @1195
;	XamLaunchURI @1196
;	XamShowNuiMessagesUI @1199
	XMPRegisterCodec @1200
;	XamNavigateBack @1201
;	XamPushBackURI @1202
;	XamUserOverrideDeviceBindings @1203
;	XamUserOverrideBindingCallbacks @1204
;	XamUserOverrideUserInfo @1205
;	XamUserContentRestrictionGetFlags @1206
;	XamUserContentRestrictionGetRating @1207
;	XamUserContentRestrictionCheckAccess @1208
;	XamShowFitnessBodyProfileUI @1209
;	XamFitnessAddBodyProfileRecord @1210
;	XamFamilyGetMembers @1211
;	XampXAuthStartup @1212
;	XampXAuthShutdown @1213
;	XamGetToken @1214
;	XamFreeToken @1215
;	XamGetAppliesTo @1216
;	XampKioskGetInfo @1217
;	XamFitnessGetCurrentBodyProfileRecord @1218
;	XamFitnessGetAllBodyProfileRecords @1219
;	XamFitnessGetAllTitleSummaries @1220
;	XamFitnessGetOverallSummary @1221
;	XamFitnessAddFitnessEvent @1222
;	XamLrcGetInput @1223
;	XamLrcGetInputWithSeek @1224
;	XamLrcSetMediaState @1225
;	XamPixSetDirtyCounters @1226
;	XamFitnessCreateFitnessEventEnumerator @1227
;	XamFitnessInitialize @1228
;	XamRequestToken @1229
;	XamResolveURI @1230
;	XamContentGetOnlineCreator @1231
;	XamShowBrandedKeyboardUI @1232
;	XamBackgroundDownloadNetworkStorageEnable @1233
;	XamBackgroundDownloadNetworkStorageIsEnabled @1234
;	XamShowNuiJoinSessionInProgressUI @1235
;	XamBase64Decode @1236
;	XamCertDecode @1237
;	XamCertDecodeRsaPublicKey @1238
;	XamCertValidateStruct @1239
;	XamFitnessConvertByteMetToFloatMet @1240
	XamXgiBlobTrackerSetMockInfo @1241
;	XamFitnessMsgTimeToSystemTime @1242
;	XamFitnessSystemTimeToMsgTime @1243
;	XamShowFitnessWarnAboutPrivacyUI @1244
;	XamShowFitnessWarnAboutTimeUI @1245
;	XamFitnessUnInitialize @1246
;	XamBackgroundDownloadNetworkStorageOnContentChange @1247
	XamLiveBaseConfigureInMemoryMockResponse @1248
	InjectConnectionServerNotification @1249
;	XamFitnessConvertFloatMetToByteMet @1250
;	XamGetGamerTileKeyFromGamertag @1251
;	XamBackgroundDownloadNetworkStorageRegisterChangeCallback @1252
	XamFindOrCreateInternalPassportAccount @1253
	XOnlinepFriendsRequest @1254
	XOnlinepFriendsAcceptRequest @1255
	XOnlinepFriendsRejectRequest @1256
	XOnlinepFriendsRemove @1257
	XFriendsCreateEnumerator @1258
;	XamBackgroundDownloadNetworkStorageIsRunning @1259
;	XamCertGetSerialNumber @1260
;	XamShowOptionsUI @1261
;	XampXAuthGetTitleBuffer @1262
;	XamTaskReschedulePeriodicWork @1263
;	XamUserGetOnlineXUIDFromOfflineXUID @1264
;	XamIsUserUsingMetricSystem @1265
;	XamShowNuiVideoRichPresenceUI @1266
;	XamAppAllocateInterappWorkspaceEx @1267
	XampKioskSetTestMock @1268
;	XamNetworkStatusGetInformation @1269
	XamNetworkStatusAddAddress @1270
;	XamUserReadUserPreference @1271
;	XamUserWriteUserPreference @1272
;	XamShowFitnessClearUI @1273
;	XamFitnessClearAll @1274
;	XamFitnessGetPrivacySettings @1275
;	XamWaitForNSAL @1276
;	XamMarkInternalAccountTrustedOnConsole @1277
;	XamBackgroundDownloadNetworkStorageGetProgress @1278
;	XamCopyFile @1279
;	XamMoveFile @1280
;	XamDeleteFile @1281
;	XamUserOverrideGlobalState @1282
;	XamGetAdaptersCollection @1283
	XampKioskIsSimulationMode @1284
	XamIsUIThread @1285
;	XamInputSendXenonButtonPress @1286
	XamDebugGetURISchemeCount @1287
	XamDebugGetURISchemeInfo @1288
;	XamGetOnlineCountryFromLocale @1289
	XTestOnlineIsConnectedToLive @1290
;	XamGetConsoleFriendlyName @1291
;	XamSetConsoleFriendlyName @1292
;	XamGetCountry @1293
;	XamPackageManagerGetFilePathW @1294
;	XamGetCurrentDemand @1295
;	XamCompleteDemand @1296
;	XamDemand @1297
;	XamFormatSystemDateString @1298
	XamDebugGetBackURI @1299
;	XamIsCurrentTitleIptv @1300
;	XamIsIptvEnabled @1301
;	XamIsDvrRecording @1302
;	XamIptvUninstall @1303
;	XamGetDvrStorage @1304
;	XamSetDvrStorage @1305
;	XamIptvGetServiceName @1306
;	XamNuiHudGetEngagedEnrollmentIndex @1307
;	XamProfileSetCachedWindowsLiveEmail @1308
;	XamProfileGetCachedWindowsLiveEmail @1309
;	XamUserResetSubscriptionType @1310
;	XamLrcSetTitlePort @1311
;	XamLrcVerifyClientId @1312
;	XamLrcEncryptDecryptTitleMessage @1313
;	XamFitnessGetSyncStatus @1314
;	XamFitnessInitializeForOneUser @1315
;	XamFitnessGetSuggestedPrivacySettings @1316
;	XampFitnessLetFireAndForgetsCatchUpInternal @1317
;	XamInputGetFailedConnectionOrBind @1318
	XuiSceneIsInTransition @1319
;	XamIsOnPrivateNetwork @1320
;	XamInputSetMinMaxAuthDelay @1321
;	XamInputNonControllerGetRawEx @1322
;	XamInputNonControllerSetRawEx @1323
	XamMarketplaceAcquireFreeContent @1324
;	XamGetClosedCaptioningState @1325
;	XamGetClosedCaptioningSettings @1326
;	XamSetClosedCaptioningState @1327
;	XamLoaderGetLogonTitle @1328
;	XamShowAndWaitForMessageBoxEx @1337
;	XamGetCurrencyFormat @1339
;	XamFormatCurrency @1340
;	XamGetUserBalance @1343
;	XamIsGuideDisabled @1344
;	XampCallXAccountTransitionStoredValuePointsToCurrency @1345
	XampSetMockCallXAccountTransitionStoredValuePointsToCurrency @1346
;	XamShowCsvTransitionUI @1347
;	XamAskUserForCSVDrainagePermission @1348
;	XamIsCSVDrainageSupported @1349
;	XamGetServiceEndpoint @1399
	XamSetMockAdapterState @1404
	XamSetMockAdapterResponse @1405
	XamClearMockAdapters @1406
;	XamLrcKeyboardGetInput @1407
;	XamLrcKeyboardGetRequiredBufferSize @1408
;	XamLrcKeyboardRegister @1409
;	XamLrcKeyboardUnregister @1410
;	XamLrcKeyboardUpdateText @1411
;	XamValidateCountry @1412
;	XamGetOnlineCountryString @1413
;	XamGetCountryString @1414
;	XamGetLanguageString @1415
;	XamGetLanguageLocaleString @1416
;	XamGetOnlineLanguageAndCountryString @1417
;	XamGetLanguageLocaleFallbackString @1418
;	XamGetOnlineLanguageAndCountry @1419
;	XamGetLanguageTypeface @1420
;	XamGetLanguageTypefacePatch @1421
;	XamGetLocaleString @1422
;	XamGetLocaleFromOnlineCountry @1423
;	XamOfflineTimerSetData @1424
;	XamOfflineTimerResume @1425
;	XamOfflineTimerSuspend @1426
;	XamOfflineTimerIsRunning @1427
;	XamOfflineTimerIsEnabled @1428
;	XamOfflineTimerGetTimeRemaining @1429
;	XamOfflineTimerGetContractData @1430
	XamOfflineTimerInitialize @1431
;	XamOfflineTimerGetData @1432
;	XamPlayToRegister @1433
;	XamPlayToReportPlaybackState @1434
;	XamPlayToUnregister @1435
;	XamShowTFAUI @1436
;	OnReconnect@CsInProcNotificationHandler @1437
;	XamGetOnlineCountryFeatures @1438
;	XamLogLocalizationEtx @1439
;	XampXAuthIsLocalSocketAllowed @1440
;	XamPlayToGetRequest @1441
;	XamPlayToCancelGetRequest @1442
;	XamPlayToCompleteRequest @1443
;	XamFitnessGetTitleSummaries @1444
;	XamFitnessGetTitleSummary @1445
	XamOfflineTimerShutdown @1446
;	XamFitnessContainsFitnessData @1447
;	XamGetLanguageFromOnlineLanguage @1448
;	XamGetOnlineLanguageString @1449
;	XamGetCountryFromOnlineCountry @1450
;	XamGetLocaleEx @1495
;	XamOfflineTimerForceQuery @1496
;	XamShowCreateProfileUIEx @1497
;	XTLGetLanguageV2 @1498
;	XTLGetLocaleV1 @1499
;	XamAvatarInitialize @1500
;	XamAvatarShutdown @1501
;	XamAvatarGetMetadataLocalUser @1502
;	XamAvatarGetMetadataByXuid @1503
;	XamAvatarGetAssetsResultSize @1504
;	XamAvatarGetAssets @1505
;	XamAvatarGenerateMipMaps @1506
;	XamAvatarSetCustomAsset @1507
;	XamAvatarSetMetadata @1508
;	EnumerateMediaObjects@CFsMediaSource @1509
;	EnumerateMediaObjects@CFsMediaSource @1510
;	XamAvatarLoadAnimation @1511
;	XamAvatarBeginEnumAssets @1512
;	XamAvatarEndEnumAssets @1513
;	XamAvatarEnumAssets @1514
;	XamAvatarGetMetadataRandom @1515
;	EnumerateMediaObjects@CFsMediaSource @1516
;	EnumerateMediaObjects@CFsMediaSource @1517
;	XamAvatarGetMetadataSignedOutProfileCount @1518
;	XamAvatarGetMetadataSignedOutProfile @1519
;	EnumerateMediaObjects@CFsMediaSource @1520
;	XamAvatarMetadataGetBodyType @1521
;	XamAvatarGetInstrumentation @1522
;	XamAvatarGetAssetIcon @1523
;	XamAvatarWearNow @1524
;	XamAvatarGetAssetBinary @1525
;	XamLoaderGetSuspendedTitleInfo @1526
;	XamAvatarGetInstalledAssetPackageDescription @1527
;	XamAvatarSetAdapters @1528
;	XamLrcKeyboardValidateTextChange @1529
;	XamLrcKeyboardApplyTextChange @1530
;	XamLrcLogSessionSummary @1531
;	XamLrcLogError @1532
;	XamContentMountInstalledGame @1550
;	XamContentIsGameInstalledToHDD @1551
;	XamContentQueryLicenseInternal @1552
;	XamContentGetDeviceVolumePath @1553
;	XamContentDeviceCheckUpdates @1554
;	XamContentGetHeaderInternal @1555
;	XamNetworkStorageGetNetworkDevice @1556
;	XamNetworkStorageDeviceHasCacheFile @1557
;	XamNetworkStorageCreateCacheOnDevice @1558
;	XamNetworkStorageDeleteCacheOnDevice @1559
;	XamNetworkStorageGetStatus @1560
;	XamNetworkStorageIsSupportedContentType @1561
;	XamNetworkStorageSetTestMock @1562
;	XamNetworkStorageGetLastSyncTime @1563
;	XamShowNetworkStorageSyncUI @1564
;	XamUserIsLogonPreviewModeEnabled @1565
;	XamUserLockLogonPreviewMode @1566
;	XamUserUnlockLogonPreviewMode @1567
;	XamNetworkStorageIsUserInSync @1568
;	XamNetworkStorageSetUserInSync @1569
;	XamNetworkStorageOnSigninChanged @1570
;	XamNetworkStorageSignInTestMock @1571
;	XamShowFofUI @1572
	CompareFileTime @1573
	SetFileTime @1574
;	XamNetworkStorageGetTitleProperties @1575
;	XamNetworkStorageLockFile @1576
;	XamNetworkStorageUserHasPrivilege @1577
;	XamNetworkStorageIsTitleExempt @1578
;	XamContentExistsOnDeviceInternal @1579
;	XamNetworkStorageGetBackingDevice @1580
;	XamNetworkStorageIsEnabledInLiveHive @1581
;	XamNetworkStorageIsCheckingSyncStates @1582
;	XamNetworkStorageUserNeedsToSync @1583
;	XamNetworkStorageGetUserNetworkSyncTime @1584
;	XamNetworkStorageGetUserProperties @1585
;	XamNetworkStorageAppLauncherLaunchIfRunning @1586
;	XamNetworkStorageSetTitleProperties @1587
;	XamNetworkStorageGetUserLastError @1588
;	XamNetworkStorageCheckOutTitle @1589
;	XamNetworkStorageShouldHideFromTitle @1590
;	XamNetworkStorageOnUserSyncChange @1591
;	XamNetworkStorageHasUserEnabledStorage @1592
;	XamContentGetLocalizedDeviceData @1593
;	XamPackageManagerFindPackageContainingIndexedXEX @1600
;	XamPackageManagerReinitialize @1601
;	XamPackageManagerGetAuthoritativeManifestRevision @1602
;	XamGetCurrentSystemOnlineManifestRevision @1603
;	XamPackageManagerDeleteExtendedPartition @1604
;	XamPackageManagerHasExtendedPartition @1605
;	XamPackageManagerGetExperienceMode @1606
;	XamPackageManagerGetFeatureRequiresUpdateStrings @1607
;	XamPackageManagerGetFileSize @1608
	XampDemandUpdateGetAttributes @1609
	XampDemandUpdateGetExtendedAttributes @1610
	XampDemandUpdateGetInstance @1611
	XampDemandUpdateSetRefreshTestFlags @1612
	XampDemandUpdateIsRefreshTestFlagSet @1613
	XampDemandUpdateGetManifestLocalPath @1614
	XampDemandUpdateRefreshManifest @1615
;	XdfInitialize @1616
;	XdfShutdown @1617
;	XdfGetExpectedDownloadSize @1618
;	XdfGetItem @1619
;	XdfCacheItem @1620
;	XdfLoadXexFromCache @1621
;	XdfLoadXex @1622
;	XdfCancelRequest @1623
	XdfResumeDelayedItem @1624
;	XdfLaunchNewImageFromCache @1625
;	XampDemandUpdateRefreshManifestDuringLogon @1626
;	XampDemandUpdateCheckOnlineManifestChanged @1627
	XampDemandUpdateRunCacheCleaner @1628
;	XamUpdateGetTitleUpdateSizeThreshold @1669
;	XamXStudioRequest @1670
;	XamNotifyDelayUIInternal @1671
;	XamShowAvatarMiniCreatorUI @1700
;	XamShowGoldUpgradeUI @1701
;	XamResumeUpdaterUI @1702
;	XamShowDirectAcquireUI @1703
;	XamShowPaymentOptionsUI @1704
;	XamShowMultiplayerUpgradeUI @1705
;	XamGetLiveHiveValueA @1800
;	XamGetLiveHiveValueW @1801
;	XamGetLiveHiveValueDuringLogonAttemptA @1802
;	XamSetUserPresetWindowsLiveCreds @1803
;	XamQueryLiveHiveA @1804
;	XamQueryLiveHiveW @1805
;	XamGetLiveHiveValueDuringLogonAttemptExA @1806
;	XamGetUserPresetWindowsLiveCreds @1807
;	XamGetUserNeedTFA @1808
;	XamSetUserNeedTFA @1809
;	XamGetUserInMemoryWindowsLiveCreds @1810
;	XamSetStagingMode @1902
;	XamGetStagingMode @1903
;	XamAppGetSessionId @1904
;	XamAccountRecoveryRecoverAllProfileData @1905
;	XamAccountRecoveryGetProgress @1906
;	XamDoesOmniNeedConfiguration @2000
	GetProcessHeap @2002
	UnhandledExceptionFilter @2003
	SetUnhandledExceptionFilter @2004
;	XamIsOptionalMediaUpdateInstalled @2005
;	XamShowOptionalMediaUpdateRequiredUI @2006
;	XamShowOptionalMediaUpdateRequiredUIEx @2007
;	XamTaskCreateQueueEx @2009
;	XamSetTextureLoaderHook @2010
;	XamLaunchAvatarEditor @2011
;	XamLoadExtraAVCodecs @2012
;	XamUnloadExtraAVCodecs @2013
	XamSetLastActiveUserData @2014
	XamGetLastActiveUserData @2015
;	XamSetActiveDashAppInfo @2016
;	XamGetActiveDashAppInfo @2017
;	XamLoaderRegisterLaunchRequestCallback @2018
;	XamLoadExtraAVCodecs2 @2019
;	XamUnloadExtraAVCodecs2 @2020
;	XamUserCreateAvatarAssetEnumerator @2050
;	XamInitializeGameTileCache @2051
;	XamDestroyGameTileCache @2052
;	XamReadGameTileImage @2053
;	XamShouldThrottleAccountInfoCall @2054
	XuiClassDerivesFrom @2055
	XuiFreeVisuals @2056
	XuiGetBaseClass @2057
	XuiLoadVisualFromBinary @2058
	XuiResourceGetBuffer @2059
	XuiResourceGetTotalSize @2060
	XuiElementGetUserData @2061
	XuiElementSetUserData @2062
	XuiTabSceneGetCount @2063
	XuiSliderGetStep @2064
	XuiSliderSetStep @2065
	XuiProgressBarGetRange @2066
	XuiElementSetHittable @2067
	XuiElementPlayNamedFrames @2068
	XuiElementGetPivot @2069
	XuiElementGetPrev @2070
	XuiElementGetScale @2071
	XuiElementSetPivot @2072
	XuiElementSetRotation @2073
	XuiElementSetScale @2074
	XuiControlWantsUnfocusedInput @2075
	XuiResourceOpenNoLoc @2076
	XuiResourceReleasePackage @2077
	XuiResourceGetPackageEntryInfo @2078
	XuiResourceGetPackageEntryCount @2079
	XuiResourceOpenPackage @2080
;	XamCodeCoverageFileOpen @2081
;	XamCodeCoverageFileClose @2082
;	XamCodeCoverageFileLseek @2083
;	XamCodeCoverageFileRead @2084
;	XamCodeCoverageFileWrite @2085
;	XampHeapGetInfo @2087
;	XampHeapGetCount @2088
	XampKioskSetTestMockValues @2089
	XuiElementLayoutTree @2090
	XamInactivityResetAllState @2091
	XUIElementPropVal_SetInt @2092
	XUIElementPropVal_SetFloat @2093
	XuiObjectGetPropertyDef @2094
	XuiRenderGetDevice @2095
	XuiRenderRestoreState @2096
	XuiElementGetFullXForm @2097
	XuiRenderGetViewTransform @2098
	XuiRenderGetColorSpace @2099
;	XamPngEncode @2100
;	XamPngDecode @2101
;	XamPngEncodeEx @2102
	XuiTextElementMeasureText @2103
;	XamLoaderShouldConfirmReboot @2104
;	XamLoaderRebootToDash @2105
;	XamNuiHudGetEngagedTrackingID @2106
;	XamLoaderLaunchTitleForReason @2107
;	XamNuiHudSetEngagedTrackingID @2108
	XuiBrushGetTexture @2109
	XuiBrushGetDims @2110
	XuiElementGetDescendantById @2111
;	XamLoaderIsKinectUIPreferredForLogonTitle @2112
;	XamAccountRecoveryGetSetTitleSyncTime @2120
;	XamReadBiometricData @2121
;	XamWriteBiometricData @2122
;	XamD3DResourceDescriptorCreate @2123
;	XamD3DResourceDescriptorAddRef @2124
;	XamD3DResourceDescriptorRelease @2125
;	XamD3DResourceAddRef @2126
;	XamD3DResourceSet @2127
;	XamD3DResourceIsBusy @2128
;	XamD3DResourceRelease @2129
	ControlPackGetCursorPosition @2130
	ControlPackShouldShowCursor @2131
;	XamFlushAgraTemperatureReport @2136
;	XamNatalDeviceAudioCalibrate @2137
;	XamNuiIdentityGetEnrollmentInfo @2138
;	XamNuiIdentityUnenroll @2139
;	XamNuiIdentityGetColorTexture @2140
;	XamReportKinectSettingsChangedEvent @2141
;	XamNuiEnableChatMic @2142
;	XamNuiIsChatMicEnabled @2143
;	XamNuiGetDepthCalibration @2144
;	XamNuiStoreDepthCalibration @2145
;	XamUserNuiIsBiometricEnabled @2146
;	XamUserNuiEnableBiometric @2147
;	XamNuiCameraSetFlags @2148
;	XamNuiCameraRememberFloor @2149
;	XamUserNuiGetUserIndexForBind @2150
;	XamUserNuiGetUserIndexForSignin @2151
;	XamUserNuiBind @2152
;	XamUserNuiGetUserIndex @2153
;	XamUserNuiGetEnrollmentIndex @2154
;	XamUserNuiUnbind @2155
;	XamNuiUseTemporaryDepthCalibration @2156
;	XamNuiCameraTiltSetCallback @2157
;	XamNuiHudIsEnabled @2158
;	XamNuiCameraGetTiltControllerType @2159
;	XamNuiCameraTiltGetStatus @2160
;	XamNuiIdentityGetQualityFlags @2161
;	XamNuiIdentityEnrollForSignIn @2162
;	XamNuiIdentityGetSessionId @2163
;	XamNuiIdentityIdentifyWithBiometric @2164
	ControlPackGetHandleManager @2165
	XamEnableNuiAutomation @2166
	XamNuiGetSystemGestureControl @2167
;	XamGetPasscodeKeyFromVirtualKey @2168
	XamEnableNatalPlayback @2169
;	XamIsNuiAutomationEnabled @2170
;	XamIsNatalPlaybackEnabled @2171
;	XamNuiHudInterpretFrame @2172
;	XamNuiHudEnableInputFilter @2173
;	XamUserNuiIsBiometricAugmentRecommended @2174
;	XamNuiHudGetInitializeFlags @2175
;	XamNuiCameraElevationSetAngle @2176
;	XamNuiCameraElevationGetAngle @2177
;	XamNuiCameraElevationAutoTilt @2178
;	XamNuiCameraElevationStopMovement @2179
;	XamNuiCameraElevationSetCallback @2180
;	XamNuiGetDeviceStatus @2181
;	XamNuiNatalCameraUpdateStarting @2182
;	XamNuiNatalCameraUpdateComplete @2183
;	XamNuiHudGetVersions @2184
	XamGetHUDElementByPath @2185
	XamGetHUDElementByAutoId @2186
	XuiElementGetScreenPositionCenter @2187
;	XamNuiCameraElevationReverseAutoTilt @2188
	ControlPackSimpleCursorGetRayFromScreenPosition @2189
	ControlPackSideNavControlGetNuiHandle @2190
	XamFindHUDElementByXuiId @2191
;	XamNuiIsDeviceReady @2192
;	XamNuiSetForceDeviceOff @2193
;	XamNuiPlayerEngagementUpdate @2194
;	XamNuiSkeletonGetBestSkeletonIndex @2195
;	XamNuiSkeletonScoreUpdate @2196
;	XamNuiCameraTiltReportStatus @2197
;	XamNuiCameraAdjustTilt @2198
;	XamNuiIdentityAbort @2199
;	D3DDevice_CreateVertexShader @2200
;	D3DDevice_CreatePixelShader @2201
;	D3DDevice_CreateTexture @2202
	D3DDevice_CreateVertexBuffer @2203
	D3DDevice_CreateIndexBuffer @2204
;	D3DDevice_CreateVertexDeclaration @2205
	D3DVertexBuffer_Unlock @2206
	D3DVertexBuffer_Lock @2207
	D3DIndexBuffer_Unlock @2208
	D3DIndexBuffer_Lock @2209
	D3DTexture_UnlockRect @2210
	D3DTexture_LockRect @2211
;	D3DDevice_Clear @2212
	D3DDevice_SetViewport @2213
	D3DDevice_GetViewport @2214
;	D3DDevice_SetRenderState_SrcBlend @2215
;	D3DDevice_SetRenderState_DestBlend @2216
;	D3DResource_Release @2218
;	D3DDevice_Release @2219
;	D3DDevice_SetVertexShader @2220
;	D3DDevice_SetPixelShader @2221
;	D3DDevice_SetTexture @2222
;	D3DDevice_SetVertexDeclaration @2223
	D3DDevice_SetIndices @2224
	D3DDevice_SetStreamSource @2225
	D3DDevice_DrawVertices @2226
;	D3DDevice_DrawVerticesUP @2227
	D3DDevice_DrawIndexedVertices @2228
	D3DDevice_DrawIndexedVerticesUP @2229
;	D3DDevice_SetVertexShaderConstantF_ParameterCheck @2230
	D3DDevice_SetPixelShaderConstantF_ParameterCheck @2231
;	D3DDevice_SetSamplerState_ParameterCheck @2232
;	D3DDevice_SetRenderState_ParameterCheck @2233
;	D3DDevice_GetRenderState_ParameterCheck @2234
;	D3DDevice_SetVertexShaderConstantFN @2235
	D3DDevice_SetPixelShaderConstantFN @2236
;	D3DDevice_GetRenderState_ZEnable @2237
;	D3DDevice_GetRenderState_CullMode @2238
;	D3DDevice_GetRenderState_AlphaBlendEnable @2239
;	D3DDevice_GetRenderState_SrcBlendAlpha @2240
;	D3DDevice_GetRenderState_DestBlendAlpha @2241
;	D3DDevice_GetRenderState_BlendOp @2242
;	D3DDevice_GetRenderState_ViewportEnable @2243
;	D3DDevice_SetRenderState_ZEnable @2244
;	D3DDevice_SetRenderState_CullMode @2245
;	D3DDevice_SetRenderState_AlphaBlendEnable @2246
;	D3DDevice_SetRenderState_SrcBlendAlpha @2247
;	D3DDevice_SetRenderState_DestBlendAlpha @2248
;	D3DDevice_SetRenderState_BlendOp @2249
;	D3DDevice_SetRenderState_ViewportEnable @2250
;	D3DDevice_SetSamplerState_MagFilter @2251
;	D3DDevice_SetSamplerState_MinFilter @2252
	D3DDevice_SetSamplerState_AddressU @2253
	D3DDevice_SetSamplerState_AddressV @2254
;	XGSetTextureHeader @2255
;	XGGetTextureDesc @2256
	XGOffsetResourceAddress @2257
;	D3DResource_AddRef @2258
	XGSetTextureHeaderEx @2262
;	D3DDevice_GetRenderTarget @2263
	D3DDevice_SetRenderTarget @2264
	D3DDevice_GetDepthStencilSurface @2265
	D3DDevice_SetDepthStencilSurface @2266
;	D3DDevice_Resolve @2267
	D3DDevice_SetPixelShaderConstantB @2268
;	XamNuiGetDeviceSerialNumber @2269
;	XamNuiGetLoadedDepthCalibration @2270
;	XamNuiGetTrueColorInfo @2271
;	XamNuiGetCameraIntrinsics @2272
;	XamNuiGetFanRate @2273
;	XamNuiGetSupportString @2274
;	XamKinectGetHardwareType @2275
;	XamMediaVerificationCreate @2491
;	XamMediaVerificationClose @2492
;	XamMediaVerificationVerify @2493
;	XamMediaVerificationFailedBlocks @2494
;	XamMediaVerificationInject @2495
;	XamShowBadDiscErrorUI @2496
;	XamBackgroundDownloadSetMode @2500
;	XamBackgroundDownloadIsEnabled @2501
;	XamBackgroundDownloadGetActiveItem @2502
;	XamBackgroundDownloadGetItems @2503
;	XamBackgroundDownloadClearItems @2504
;	XamBackgroundDownloadItemAdd @2505
;	XamBackgroundDownloadItemRemove @2506
;	XamBackgroundDownloadItemMakeFirst @2507
;	XamBackgroundDownloadSetForegroundPriority @2508
;	XamBackgroundDownloadGetForegroundPriority @2509
;	XamBackgroundDownloadItemToContentData @2510
;	XamBackgroundDownloadItemGetStatus @2511
;	XamBackgroundDownloadHistoryGetItem @2512
;	XamBackgroundDownloadItemGetHistoryStatus @2513
;	XamBackgroundDownloadItemSetHistoryStatus @2514
;	XamBackgroundDownloadItemGetStatusAsync @2515
;	XamBackgroundDownloadItemGetStatusEx @2516
;	XamBackgroundDownloadItemGetHistoryStatusEx @2517
;	XamBackgroundDownloadBindItems @2518
;	XamBackgroundDownloadSetPollingActive @2519
;	XamBackgroundDownloadGetPollingActive @2520
;	XamBackgroundDownloadGetMode @2521
;	XamBackgroundDownloadGetUnexpectedChangeCount @2522
;	XamBackgroundDownloadIsItemForThisConsole @2523
;	XamBackgroundDownloadSelectDevice @2524
;	XamBackgroundDownloadItemModify @2525
;	XamBackgroundDownloadCacheLegacyMappingInfo @2526
;	XamBackgroundDownloadGetLegacyMappingInfo @2527
;	XamBackgroundDownloadGetLegacyId @2528
	XamBackgroundDownloadDoFail @2529
;	XamSwapDisc @2600
;	XamSwapDiscPatchAddress @2601
;	XamSwapCancel @2602
;	XamContentSetAttributes @2603
;	XamRamDriveCreate @2610
;	XamRamDriveDestroy @2611
;	XamPlayTimerGetData @2650
;	XamPlayTimerSetData @2651
;	XamPlayTimerResume @2652
;	XamPlayTimerSuspend @2653
;	XamPlayTimerIsRunning @2654
;	XamPlayTimerIsEnabled @2655
;	XamPlayTimerGetNextResetDate @2656
;	XamPlayTimerFormatDurationString @2657
;	XamPlayTimerGetTimeRemaining @2658
;	XamPlayTimerUpdateTimeRemaining @2659
;	XamPlayTimerForceNotification @2660
;	XamPlayTimerRefreshResetDate @2661
	XuiResourceOpenAndVerifyNoLoc @2662
	UpnpAVServerSearchInitialize @2670
	UpnpAVServerSearchDestroy @2671
	UpnpAVServerSearchStart @2672
;	Destroy@CUpnpAVServerSearch @2673
	UpnpAVServerSearchDoWork @2674
	UpnpAVServerSearchGetNextServer @2675
;	XCustomBroadcastGamercardEvent @2700
;	XamCustomGetCurrentActions @2701
;	XamInstrumentationLogEvent @2720
;	XamRegisterSMCNotification @2721
;	XamIsScreenSaverActive @2728
;	XamInstrumentationLogEventEx @2730
;	XamInstrumentationGetSourceConfig @2731
	XamInstrumentationDebugConfig @2732
;	CurlCreateCacheEntry @2780
;	CurlOpenCacheEntry @2781
;	CurlSetCacheEntryExpireTime @2782
;	CurlReadCacheEntryHeaders @2783
;	CurlReadCacheEntryContent @2784
;	CurlWriteCacheEntryContent @2785
;	CurlCloseCacheEntry @2786
;	CurlEnumerateCacheEntry @2787
;	CurlWipeBackingFiles @2789
;	CurlOpenTitleBackingFile @2791
;	XamUserIsPartialProfile @2794
;	XamLocateTitle @2795
;	XamProfileGetLocalTitleCount @2796
;	XamContentRemoveCacheDevice @2797
;	XamContentAddCacheDevice @2798
;	XamSetSecurityViolationDetected @2800
;	XamIsSecurityViolationDetected @2801
;	XamIsAnySecurityViolationDetected @2802
;	XamGetSecurityViolationsDetected @2803
;	XamActivateCounterMeasure @2804
;	XamDeactivateCounterMeasure @2805
;	XamIsCounterMeasureActivated @2806
;	XamGetActiveCounterMeasures @2807
;	XamPmdIdentify @2808
;	XamPmdSendCommand @2809
;	XamPmdReadReport @2810
;	XamPartyCreate @2812
;	XamPartyLeave @2813
;	XamPartySendInviteDeprecated @2814
;	XamPartyGetUserList @2815
;	XamPartySendGameInvites @2816
;	XamPartyJoin @2817
;	XamPartyKickUser @2818
;	XamPartyAddLocalUsers @2819
;	XamGetLocaleTimeFormat @2821
;	XamPartyRemoveLocalUsers @2822
;	XamPartyGetUserListInternal @2823
;	XamPartySetJoinable @2824
;	XamPartyGetJoinable @2825
;	XamPartyGetInfo @2826
;	XamPartySetCustomData @2827
	XamPartySetConnectivityGraph @2828
	XamPartyGetRoutingTable @2829
;	XamPartyAutomationInprocCall @2830
;	XamPartyGetState @2831
;	XamPartyGetBandwidth @2832
;	XamPartyGetNetworkCounters @2833
;	XamShowQuickLaunchUI @2834
;	XamPartyIsCoordinator @2835
;	XamPartyGetFormation @2836
;	XamPartySendInvite @2837
	XamPartySetTestDelay @2838
	XamPartyOverrideNatType @2839
;	XamPartyGetAccessLevel @2840
	XamPartySetTestFlags @2841
;	XamIsSystemExperienceTitleId @2842
;	XamPartyJoinEx @2843
;	XamPartyGetInfoEx @2844
;	XamIsCurrentTitleDatacenterClient @2848
;	XamTaskSetCancelSubTasks @2850
;	XamTaskGetCompletionStatus @2851
;	XamTaskCancelWaitAndCloseWaitTask @2852
;	XamDataCenterLog @2855
;	XamDataCenterGetDhcpOptionResponseHostnameAndPort @2856
;	XamDataCenterLogEvent @2857
;	XamDataCenterShowForceSignInMessage @2858
;	XamWebInstrumentationCreateReport @2860
;	XamWebInstrumentationSetUserVar @2861
;	XamWebInstrumentationSetUserVarNoEscape @2862
;	XamWebInstrumentationGetURL @2863
;	XamWebInstrumentationSendReport @2864
;	XamWebInstrumentationDestroyReport @2865
;	XamWebInstrumentationCreateSampledReport @2866
;	XampSetSamplingRandomValue @2867
;	XampWebInstrumentationSetProfileCounts @2868
;	XamWebInstrumentationGetURLEx @2869
	XampSetOmnitureCallbackFunction @2870
;	XamShowQuickChatUIp @2871
;	XamShowSocialPostUI @2872
;	XamShowBeaconsUI @2873
;	XamShowMarketplacePurchaseOrderUI @2874
;	XamShowMarketplaceGetOrderReceipts @2875
;	XamShowGenericOnlineAppUI @2876
;	XamUserAllowedToPostToSocialNetwork @2877
;	XamShowMarketplacePurchaseOrderUIEx @2878
	DebugXamShowMessageBoxUI_Wait @2879
;	XamSetCountry @2883
;	XamIsCurrentTitleDatacenterDash @2884
;	XamLoaderRebootToServerDash @2885
;	XamIsDataCenterMode @2886
;	XamUserGetXUIDForTFA @2888
;	XamVerifyXSignerSignature @2890

```

`XenonDumper/libs/xkelib/xapiext.h`:

```h
// general things found in the xapilib.lib from the sdk, but not in the sdk headers
#ifndef __XAPIEXT_DEFINES_H
#define __XAPIEXT_DEFINES_H


#ifdef __cplusplus
extern "C" {
#endif

	// SDK library function
	VOID XapiThreadStartup(
		IN		VOID (__cdecl *StartRoutine)(VOID *),
		IN		PVOID StartContext,
		IN		DWORD dwExitCode
	);
	
	// SDK library function
	HANDLE NTAPI XapipCreateThread(
		IN		LPSECURITY_ATTRIBUTES lpThreadAttributes,
		IN		DWORD dwStackSize,
		IN		LPTHREAD_START_ROUTINE lpStartAddress,
		IN		LPVOID lpParameter,
		IN		DWORD dwCreationFlags,
		IN		DWORD dwThreadProcessor,
		IN		LPDWORD lpThreadId,
		IN OUT	PHANDLE pHandle
	);

	// SDK library function? sdk links it directly to XamLoaderGetGameInfo @427
	// UNTESTED!!!
	HRESULT XamGetGameInfo(
		LPCWSTR wszTitleName,
		DWORD dwTitleId,
		PBYTE* ppbUnk,
		QWORD* pqwUnk
	);
	
	// SDK library function?
	DWORD XContentCreateDeviceEnumerator(
		DWORD dwContentTypes,
		DWORD dwFlags,
		DWORD cItem,
		PDWORD pcbBuffer,
		PHANDLE phEnum
	);

	// disc format function for fatx found in xapilib.lib
	// ie "\\Device\\SomeDevice", use RtlInitAnsiString and modify ??((Length+0x10000) - 1)??
	NTSTATUS XapiFormatFATVolume(
		PANSI_STRING deviceName
	);
	
	NTSTATUS XapiFormatFATVolumeEx(
		PANSI_STRING deviceName,
		DWORD sectorSize
	);
	
	// disc format functions for fat32 found in xapilib.lib
	NTSTATUS XapiFormatFATWVolume(
		LPCSTR devicename
	);
	
	NTSTATUS XapiFormatFATWVolumeByHandle(
		HANDLE deviceHandle
	);

	//NTSYSAPI
	//EXPORTNUM(xxx) // not exported, might be in sdk though
	//NTSTATUS
	//NTAPI
	//NtWaitForSingleObject(
	//	IN		HANDLE Handle,
	//	IN		BOOLEAN Alertable,
	//	IN		PLARGE_INTEGER Timeout
	//);	

#ifdef __cplusplus
}
#endif

#endif // __XAPIEXT_DEFINES_H

```

`XenonDumper/libs/xkelib/xkelib.h`:

```h
#ifndef __XKELIB_H
#define __XKELIB_H


#pragma warning(push)
// 4214 nonstandard extension used : bit field types other than int
// 4201 nonstandard extension used : nameless struct/union
// 2220 warning treated as error - no 'object' file generated
// note #pragma warning(disable:4005) is used in xamXContent.h XCONTENTTYPE_ defs
#pragma warning(disable:4200 4201 4214)

#include "exttypes.h"
#include "kernel\_kernelext.h"
#include "kernel\console_type.h" // this must come after kernel prototypes
#include "xam\_xamext.h"
#include "xapiext.h"

#pragma warning(pop)


#endif // __XKELIB_H

```

`XenonDumper/libs/xkelib/xkelib.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Release21119.0|Xbox 360">
      <Configuration>Release21119.0</Configuration>
      <Platform>Xbox 360</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release20871.0|Xbox 360">
      <Configuration>Release20871.0</Configuration>
      <Platform>Xbox 360</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release21173.0|Xbox 360">
      <Configuration>Release21173.0</Configuration>
      <Platform>Xbox 360</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release21250.0|Xbox 360">
      <Configuration>Release21250.0</Configuration>
      <Platform>Xbox 360</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release21256.0|Xbox 360">
      <Configuration>Release21256.0</Configuration>
      <Platform>Xbox 360</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="exttypes.h" />
    <ClInclude Include="kernel\console_type.h" />
    <ClInclude Include="kernel\keDriver.h" />
    <ClInclude Include="kernel\keFileInfo.h" />
    <ClInclude Include="kernel\keNand.h" />
    <ClInclude Include="kernel\kePrivateStructs.h" />
    <ClInclude Include="kernel\kernelExpEnum.h" />
    <ClInclude Include="kernel\keSmc.h" />
    <ClInclude Include="kernel\keXConfig.h" />
    <ClInclude Include="kernel\keXeCrypt.h" />
    <ClInclude Include="kernel\keXeKeys.h" />
    <ClInclude Include="kernel\keXexInfo.h" />
    <ClInclude Include="kernel\_kernelext.h" />
    <ClInclude Include="syssock.h" />
    <ClInclude Include="xam\xamExpEnum.h" />
    <ClInclude Include="xam\xamNet.h" />
    <ClInclude Include="xam\xamTask.h" />
    <ClInclude Include="xam\xamXContent.h" />
    <ClInclude Include="xam\_xamext.h" />
    <ClInclude Include="xapiext.h" />
    <ClInclude Include="xkelib.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="kernel\kernelext20871.0.def" />
    <None Include="kernel\kernelext21119.0.def" />
    <None Include="kernel\kernelext21173.0.def" />
    <None Include="kernel\kernelext21250.0.def" />
    <None Include="xam\xamext20871.0.def" />
    <None Include="xam\xamext21119.0.def" />
    <None Include="xam\xamext21173.0.def" />
    <None Include="xam\xamext21250.0.def" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{83FEF217-22EE-4768-80BF-9F48D5B4564C}</ProjectGuid>
    <Keyword>Xbox360Proj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release20871.0|Xbox 360'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release21119.0|Xbox 360'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release21173.0|Xbox 360'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>MultiByte</CharacterSet>
    <PlatformToolset>2010-01</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release21250.0|Xbox 360'" Label="Configuration">
    <ConfigurationType>Makefile</ConfigurationType>
    <CharacterSet>MultiByte</CharacterSet>
    <PlatformToolset>2010-01</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release21256.0|Xbox 360'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>MultiByte</CharacterSet>
    <PlatformToolset>2010-01</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release20871.0|Xbox 360'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release21119.0|Xbox 360'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release21173.0|Xbox 360'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release21250.0|Xbox 360'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release21256.0|Xbox 360'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release20871.0|Xbox 360'">
    <OutputFile>$(OutDir)$(ProjectName).lib</OutputFile>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release21119.0|Xbox 360'">
    <OutputFile>$(OutDir)$(ProjectName).lib</OutputFile>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release21173.0|Xbox 360'">
    <OutputFile>$(OutDir)$(ProjectName).lib</OutputFile>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release21250.0|Xbox 360'">
    <OutputFile>$(OutDir)$(ProjectName).lib</OutputFile>
    <CustomBuildAfterTargets>
    </CustomBuildAfterTargets>
    <CustomBuildBeforeTargets>
    </CustomBuildBeforeTargets>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release21256.0|Xbox 360'">
    <OutputFile>$(OutDir)$(ProjectName).lib</OutputFile>
    <CustomBuildAfterTargets />
    <CustomBuildBeforeTargets />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release20871.0|Xbox 360'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>Full</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <StringPooling>true</StringPooling>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <PrecompiledHeaderOutputFile>$(OutDir)$(ProjectName).pch</PrecompiledHeaderOutputFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PreprocessorDefinitions>NDEBUG;_XBOX;_LIB</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <PreBuildEvent>
      <Command>del $(ProjectDir)xamext.lib $(ProjectDir)xamext.exp $(ProjectDir)kernelext.lib $(ProjectDir)kernelext.exp
lib /def:xam\xamext20871.0.def /MACHINE:PPCBE /OUT:xamext.lib
lib /def:kernel\kernelext20871.0.def /MACHINE:PPCBE /OUT:kernelext.lib</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>creating import libs</Message>
    </PreBuildEvent>
    <Lib>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>
      </AdditionalLibraryDirectories>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release21119.0|Xbox 360'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>Full</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <StringPooling>true</StringPooling>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <PrecompiledHeaderOutputFile>$(OutDir)$(ProjectName).pch</PrecompiledHeaderOutputFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PreprocessorDefinitions>NDEBUG;_XBOX;_LIB</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <PreBuildEvent>
      <Command>del $(ProjectDir)xamext.lib $(ProjectDir)xamext.exp $(ProjectDir)kernelext.lib $(ProjectDir)kernelext.exp
lib /def:xam\xamext21119.0.def /MACHINE:PPCBE /OUT:xamext.lib
lib /def:kernel\kernelext21119.0.def /MACHINE:PPCBE /OUT:kernelext.lib
</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>creating import libs</Message>
    </PreBuildEvent>
    <Lib>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>
      </AdditionalLibraryDirectories>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release21173.0|Xbox 360'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>Full</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <StringPooling>true</StringPooling>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <PrecompiledHeaderOutputFile>$(OutDir)$(ProjectName).pch</PrecompiledHeaderOutputFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PreprocessorDefinitions>NDEBUG;_XBOX;_LIB</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <PreBuildEvent>
      <Command>del $(ProjectDir)xamext.lib $(ProjectDir)xamext.exp $(ProjectDir)kernelext.lib $(ProjectDir)kernelext.exp
lib /def:xam\xamext21173.0.def /MACHINE:PPCBE /OUT:xamext.lib
lib /def:kernel\kernelext21173.0.def /MACHINE:PPCBE /OUT:kernelext.lib
</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>creating import libs</Message>
    </PreBuildEvent>
    <Lib>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>
      </AdditionalLibraryDirectories>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release21250.0|Xbox 360'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>Full</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <StringPooling>true</StringPooling>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <PrecompiledHeaderOutputFile>$(OutDir)$(ProjectName).pch</PrecompiledHeaderOutputFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PreprocessorDefinitions>NDEBUG;_XBOX;_LIB</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <PreBuildEvent>
      <Command>del $(ProjectDir)xamext.lib $(ProjectDir)xamext.exp $(ProjectDir)kernelext.lib $(ProjectDir)kernelext.exp
lib /def:xam\xamext21250.0.def /MACHINE:PPCBE /OUT:xamext.lib
lib /def:kernel\kernelext21250.0.def /MACHINE:PPCBE /OUT:kernelext.lib
</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>creating import libs</Message>
    </PreBuildEvent>
    <Lib>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>
      </AdditionalLibraryDirectories>
    </Lib>
    <CustomBuildStep>
      <Command>
      </Command>
    </CustomBuildStep>
    <CustomBuildStep>
      <Message>
      </Message>
      <Inputs>
      </Inputs>
    </CustomBuildStep>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release21256.0|Xbox 360'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>Full</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <StringPooling>true</StringPooling>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <ExceptionHandling>false</ExceptionHandling>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <PrecompiledHeaderOutputFile>$(OutDir)$(ProjectName).pch</PrecompiledHeaderOutputFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PreprocessorDefinitions>NDEBUG;_XBOX;_LIB</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <PreBuildEvent>
      <Command>del $(ProjectDir)xamext.lib $(ProjectDir)xamext.exp $(ProjectDir)kernelext.lib $(ProjectDir)kernelext.exp
lib /def:xam\xamext21256.0.def /MACHINE:PPCBE /OUT:xamext.lib
lib /def:kernel\kernelext21256.0.def /MACHINE:PPCBE /OUT:kernelext.lib
</Command>
    </PreBuildEvent>
    <PreBuildEvent>
      <Message>creating import libs</Message>
    </PreBuildEvent>
    <Lib>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>
      </AdditionalLibraryDirectories>
    </Lib>
    <CustomBuildStep>
      <Command>
      </Command>
    </CustomBuildStep>
    <CustomBuildStep>
      <Message>
      </Message>
      <Inputs>
      </Inputs>
    </CustomBuildStep>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Xbox 360'">
    <PreBuildEvent>
      <Command>lib /def:xam\xamext20871.0.def /MACHINE:PPCBE /OUT:xamext.lib
lib /def:kernel\kernelext20871.0.def /MACHINE:PPCBE /OUT:kernelext.lib
</Command>
      <Message>creating import libs</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`XenonDumper/libs/xkelib/xkelib.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Header Files\kernel">
      <UniqueIdentifier>{5f100432-80b7-4133-bd6d-3aafbae1bb52}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\xam">
      <UniqueIdentifier>{1a442b04-bfa8-4c0f-a7f1-dc9b543dd136}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\kernel">
      <UniqueIdentifier>{379d1637-df45-454f-b481-89cbf67ddb8b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\xam">
      <UniqueIdentifier>{55a5f09b-8adc-4d3b-a582-f09de6545c7a}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="kernel\_kernelext.h">
      <Filter>Header Files\kernel</Filter>
    </ClInclude>
    <ClInclude Include="kernel\keFileInfo.h">
      <Filter>Header Files\kernel</Filter>
    </ClInclude>
    <ClInclude Include="kernel\kePrivateStructs.h">
      <Filter>Header Files\kernel</Filter>
    </ClInclude>
    <ClInclude Include="kernel\keXeCrypt.h">
      <Filter>Header Files\kernel</Filter>
    </ClInclude>
    <ClInclude Include="kernel\keXeKeys.h">
      <Filter>Header Files\kernel</Filter>
    </ClInclude>
    <ClInclude Include="kernel\keXexInfo.h">
      <Filter>Header Files\kernel</Filter>
    </ClInclude>
    <ClInclude Include="xam\_xamext.h">
      <Filter>Header Files\xam</Filter>
    </ClInclude>
    <ClInclude Include="xam\xamTask.h">
      <Filter>Header Files\xam</Filter>
    </ClInclude>
    <ClInclude Include="xam\xamXContent.h">
      <Filter>Header Files\xam</Filter>
    </ClInclude>
    <ClInclude Include="xkelib.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="kernel\keSmc.h">
      <Filter>Header Files\kernel</Filter>
    </ClInclude>
    <ClInclude Include="exttypes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="kernel\console_type.h">
      <Filter>Header Files\kernel</Filter>
    </ClInclude>
    <ClInclude Include="xam\xamNet.h">
      <Filter>Header Files\xam</Filter>
    </ClInclude>
    <ClInclude Include="kernel\keDriver.h">
      <Filter>Header Files\kernel</Filter>
    </ClInclude>
    <ClInclude Include="xapiext.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="syssock.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="kernel\keNand.h">
      <Filter>Header Files\kernel</Filter>
    </ClInclude>
    <ClInclude Include="kernel\keXConfig.h">
      <Filter>Header Files\kernel</Filter>
    </ClInclude>
    <ClInclude Include="kernel\kernelExpEnum.h">
      <Filter>Header Files\kernel</Filter>
    </ClInclude>
    <ClInclude Include="xam\xamExpEnum.h">
      <Filter>Header Files\xam</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <None Include="kernel\kernelext20871.0.def">
      <Filter>Source Files\kernel</Filter>
    </None>
    <None Include="kernel\kernelext21119.0.def">
      <Filter>Source Files\kernel</Filter>
    </None>
    <None Include="xam\xamext20871.0.def">
      <Filter>Source Files\xam</Filter>
    </None>
    <None Include="xam\xamext21119.0.def">
      <Filter>Source Files\xam</Filter>
    </None>
    <None Include="kernel\kernelext21173.0.def">
      <Filter>Source Files\kernel</Filter>
    </None>
    <None Include="xam\xamext21173.0.def">
      <Filter>Source Files\xam</Filter>
    </None>
    <None Include="kernel\kernelext21250.0.def">
      <Filter>Source Files\kernel</Filter>
    </None>
    <None Include="xam\xamext21250.0.def">
      <Filter>Source Files\xam</Filter>
    </None>
  </ItemGroup>
</Project>
```

`XenonDumper/stdafx.cpp`:

```cpp
#include "stdafx.h"

```

`XenonDumper/stdafx.h`:

```h
#ifndef __STDAFX_H__
#define __STDAFX_H__
#pragma once
using namespace std;
#include <xtl.h>
#include <xui.h>    // XUI Runtime
#include <xuiapp.h> // XUI Class Library
#include <stdio.h>
#include <iostream>
#include <fstream>

#include <xkelib.h>

#include "XuiClasses.h"
#include "Functions.h"
#include "HVFuncs.h"

#pragma warning(push)
#pragma warning(disable:4127)
#pragma warning(disable:4172)

#endif // __STDAFX_H__

```