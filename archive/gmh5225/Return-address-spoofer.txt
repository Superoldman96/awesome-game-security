Project Path: arc_gmh5225_Return-address-spoofer_v4oozs4g

Source Tree:

```txt
arc_gmh5225_Return-address-spoofer_v4oozs4g
├── README.md
├── ROP concept
│   ├── ROP example.c
│   └── rop_example.asm
├── Spoofer
│   ├── MemoryScanning.c
│   ├── MemoryScanning.h
│   ├── dllmain.c
│   └── spoofing.asm
└── Test program
    └── Source.c

```

`README.md`:

```md
# Return-address-spoofer
Illustrates the concept of return address spoofing, and how it is used.

Writeup on NTAurora.ml

```

`ROP concept/ROP example.c`:

```c
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <stdio.h>

/*
	Disable optimization for our example
*/

#pragma optimize("", off)

/*
	Link
*/

extern unique_function();
extern unique_function_two();
extern unique_function_three();
extern unique_jump(IN PVOID jmp_dst, IN PVOID dst);
extern unique_mov(IN PVOID dst, IN UINT64 value);


extern unique_mov_format(IN PVOID dst);

/*
	Empty function that displays when it is called
*/

VOID empty_function(VOID)
{
	printf("Called empty_function \n");

	return;
}

int main()
{
	/*
		Setup our variables where we want to jump too and the address of our
		unique jump instruction.
	*/

	PVOID jmp_dst = &empty_function;
	PVOID dst = (PVOID)((UINT64)unique_function + 1);

	/*
		Jump to it by returning
	*/

	unique_jump(jmp_dst, dst);

	/*
		Simulate a mov instruction using the rbx register.
	*/

	dst = (PVOID)((UINT64)unique_function_two + 0x10);

	unique_mov(dst, 0x500);

	/*
		Simulate a call to printf
	*/

	dst = (PVOID)((UINT64)unique_function_three + 0x10);

	unique_mov_format(dst);


	return 0;
}


```

`ROP concept/rop_example.asm`:

```asm
.data

format db "Our formatted String \n", 0

.code 

extern printf : proc


; This function seems like it does nothing when first viewed :
; but looking at the bytes of these two instructuions which are :
; 3B FF E0 00 
; we notice the middle two bytes is the machine code for a
; jmp rax instruction.

unique_function proc
	cmp edi, edi ; So if we jump to the start of this address + 1 byte
	loopne test_label ; we end up executing the instruction jmp rax
test_label:
	ret
unique_function endp

; This function does absolutely nothing besides allocate some space on the
; stack then moves 0x1000 into rbx (which shortly gets overwritten).
; but something unique about this function is that before it returns
; it pops the value at the top of the stack into rbx.
; We can use this to manipulate the value of rbx.
; We want to jump to this location (unique_function_two + 0x10 bytes)
; which is the instruction pop rbx.
; We can simulate a mov rbx, some_value by pushing a value onto the stack
; then jumping to this location.

unique_function_two proc
	push rbx
	sub rsp, 28h

	mov rbx, 1000h

	add rsp, 28h
	pop rbx ; We pop the value we pushed off the top of the stack into rbx
	ret ; return back to normal execution flow.
unique_function_two endp


unique_function_three proc
	push rcx
	sub rsp, 28h

	mov rbx, 1000h

	add rsp, 28h
	pop rcx ; We pop the value we pushed off the top of the stack into rcx
	ret ; return back to normal execution flow.
unique_function_three endp


unique_jump proc
	mov rax, rcx ; move our jump location into rax
	push rdx ; push our new return address onto the stack
	ret ; return to rdx
unique_jump endp


unique_mov proc
	push rdx ; push our value onto the stack that rbx will hold after the call
	push rcx ; push our return value onto the stack
	ret
unique_mov endp


unique_mov_format proc
	lea rdx, format ; Load our formated string onto the stack
	lea rax, printf
	push rax ; push the address of printf onto the stack (we will return here after unique_function_three)
	push rdx ; push format onto the stack to be popped into rcx
	push rcx ; push unique_function_three + 0x10 onto the stack then "jump" to it.
	ret

unique_mov_format endp


end
```

`Spoofer/MemoryScanning.c`:

```c
#include "MemoryScanning.h"

BOOLEAN Compare_bytes(IN PBYTE base, IN PBYTE pattern)
{
	for (; *pattern; pattern++, base++)
	{
		if (*pattern == 0xFF)
			continue;

		if (*base != *pattern)
		{
			return FALSE;
		}
	}

	return TRUE;
}

PBYTE Find_Pattern(IN PBYTE base, IN SIZE_T size, IN PBYTE pattern)
{
	PBYTE end_address = base + size;

	for (; base < end_address; base++)
	{
		if (*base != *pattern)
			continue;

		if (Compare_bytes(base, pattern))
		{
			return base;
		}
	}

	return NULL;
}
```

`Spoofer/MemoryScanning.h`:

```h
#pragma once

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>

BOOLEAN Compare_bytes(IN PBYTE base, IN PBYTE pattern);
PBYTE Find_Pattern(IN PBYTE base, IN SIZE_T size, IN PBYTE pattern);


```

`Spoofer/dllmain.c`:

```c
#define WIN32_LEAN_AND_MEAN
#define _CRT_SECURE_NO_WARNINGS 

#include <Windows.h>
#include "MemoryScanning.h"

#include <stdio.h>

/*
    Function pointers
*/

typedef VOID( * our_function)(VOID);

/*
    Link
*/

extern simple_jump(PVOID address);
extern spoof_return(PVOID spoof_location, PVOID spoof_destination);
extern spoof_return_params(PVOID spoof_location, PVOID spoof_destination, ...);

extern PVOID get_image_base(VOID);

/*
    Patterns:

    If using sig scans.
*/


DWORD Main_Routine(IN LPVOID lpThreadParameter)
{
    /*
        Get our image base and size of image from the PEB
    */

    PBYTE image_base = get_image_base();


    /*
        Acquire the address of the function we are going to call
        and the address of our gadget.

        NOTE:
            Our gadget is just the empty_call function which
            simply returns.
    */

    PVOID our_function_address = (PVOID)(image_base + 0x1070);

    PVOID our_gadget_address = (PVOID)(image_base + 0x10D0);

    /*
        CASE: We didn't find our function
    */

    if (our_function_address == NULL)
    {
        return 1;
    }

    /*
        Set our function pointer to point to our functions address
    */

    our_function p_our_function = (our_function)our_function_address;

    /*
        Simple forever loop
    */

    for (;;)
    {
        /*
            Call our function without spoofing.
        */

        if (GetAsyncKeyState(VK_CONTROL) & 1)
        {
            p_our_function();
        }

        /*
            Call our function with spoofing
        */

        if (GetAsyncKeyState(VK_SHIFT) & 1)
        {
            spoof_return(our_gadget_address, p_our_function);
        }
    }

    return 0;
}

BOOL APIENTRY DllMain(IN HMODULE hModule, IN DWORD ul_reason_for_call, IN LPVOID lpReserved)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        CreateThread(0, 0, Main_Routine, 0, 0, 0);
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}


```

`Spoofer/spoofing.asm`:

```asm
.data 

.code

simple_jump PROC

	jmp rcx ; Illustrates a simple jump to an address in memory, this works because 
			; our return address is pushed onto the stack from our call to simple_jump

simple_jump ENDP

;------------------------------------------------------

SPEC_SEG segment read write execute ; Declare are segment as writable aswell so we can modify it dynamically.

; RCX will hold the value of our gadget, while RDX holds our funtion.

spoof_return PROC
	
	mov dword ptr [jmp_label], 0e2ff51h ; The opcodes for our instruction
jmp_label:
	nop ; Allocate 3 bytes to overwrite with :
	nop ; Push rcx
	nop ; Jmp rdx

spoof_return ENDP

SPEC_SEG ends

;------------------------------------------------------

; 4 PARAMS MAX 
; This can be changed by addressing the last two parameters moved onto the stack.
; Example 5 arguments would move our stack up 8 bytes
; So our jump address is now at [rsp + 30h]

spoof_return_params PROC 
	pop rax ; pop our return address off the stack into rax
	mov r10, [rsp + 28h] ; jump address
	mov r11, [rsp + 20h] ; address of gadget
	push rax ; push our actual return address back onto the stack
	push r11 ; push our gadget onto the stack
	jmp r10 ; jump to the function we want to call

spoof_return_params ENDP


;------------------------------------------------------

get_image_base PROC

	mov rcx, gs:[60h] ; Obtain the PEB
	mov rax, [rcx + 10h] ; The image base address is at offset 0x10
	ret

get_image_base ENDP


END
```

`Test program/Source.c`:

```c
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <stdio.h>
#include <intrin.h>
#include <Psapi.h>

/*
	Disable optimization as this is a test program.
*/

#pragma optimize("", off)

MODULEINFO module_information;

/*
	Tests the return address of the caller to check if it's within the range of our module.
*/


VOID test_return_address()
{
	/*
		Return address.
	*/

	UINT64 return_address = _ReturnAddress();

	/*
		CASE: The caller is within our module.
	*/

	if (return_address >= module_information.lpBaseOfDll && return_address <= ((UINT64)module_information.lpBaseOfDll + module_information.SizeOfImage))
	{
		printf("Called from within module. \n");
	}
	else
	{
		printf("Called from outisde of module. \n");
	}

	return;
}

/*
	A simple function with no parameters and no body.
*/

VOID empty_call()
{
	return;
}

/*
	A simple function with four parameters and no body
*/

VOID empty_call_with_parameters(PVOID param_1, PVOID param_2, PVOID param_3, PVOID param_4)
{
	return;
}


INT main()
{
	/*
		CASE: Acquiring module information failed.
	*/

	if (!GetModuleInformation(GetCurrentProcess(), GetModuleHandle(NULL), &module_information, sizeof(MODULEINFO)))
	{
		return 0;
	}

	/*
		Empty call
	*/

	empty_call();

	for (;;)
	{
		/*
			Call our function
		*/

		test_return_address();

		/*
			Keep our program open
		*/

		getchar();
	}

	return 0;
}

```