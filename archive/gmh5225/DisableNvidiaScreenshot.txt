Project Path: arc_gmh5225_DisableNvidiaScreenshot_jw0lynft

Source Tree:

```txt
arc_gmh5225_DisableNvidiaScreenshot_jw0lynft
├── DisableNvidiaScreenshot
│   ├── DisableNvidiaScreenshot.cpp
│   ├── DisableNvidiaScreenshot.vcxproj
│   └── FuckACEScreenshot.vcxproj.filters
├── DisableNvidiaScreenshot.sln
├── LICENSE
└── README.md

```

`DisableNvidiaScreenshot.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.12.35527.113
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DisableNvidiaScreenshot", "DisableNvidiaScreenshot\DisableNvidiaScreenshot.vcxproj", "{C445356D-B0A3-430E-B0D9-B4ED8991B39F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C445356D-B0A3-430E-B0D9-B4ED8991B39F}.Debug|x64.ActiveCfg = Debug|x64
		{C445356D-B0A3-430E-B0D9-B4ED8991B39F}.Debug|x64.Build.0 = Debug|x64
		{C445356D-B0A3-430E-B0D9-B4ED8991B39F}.Debug|x86.ActiveCfg = Debug|Win32
		{C445356D-B0A3-430E-B0D9-B4ED8991B39F}.Debug|x86.Build.0 = Debug|Win32
		{C445356D-B0A3-430E-B0D9-B4ED8991B39F}.Release|x64.ActiveCfg = Release|x64
		{C445356D-B0A3-430E-B0D9-B4ED8991B39F}.Release|x64.Build.0 = Release|x64
		{C445356D-B0A3-430E-B0D9-B4ED8991B39F}.Release|x86.ActiveCfg = Release|Win32
		{C445356D-B0A3-430E-B0D9-B4ED8991B39F}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {C54DCFE3-B2BB-472C-86D5-39F2315F1B32}
	EndGlobalSection
EndGlobal

```

`DisableNvidiaScreenshot/DisableNvidiaScreenshot.cpp`:

```cpp
#include <windows.h>
#include <iostream>
#include <iomanip>
#include <tlhelp32.h>
#include <vector>
#include <string>

// 配置参数
const BYTE TARGET_PATTERN[] = { 0xFF, 0x50, 0xCC, 0x85, 0xC0, 0x0F, 0x85, 0xD0, 0x00, 0x00, 0x00 };
const char PATTERN_MASK[] = "xx?xxxxxxxx";  // 'x'表示精确匹配，'?'表示忽略该字节
const BYTE PATCH_DATA[] = { 0x90, 0x90, 0x90, 0x90, 0x90 }; // 5个NOP指令
const SIZE_T PATTERN_SIZE = sizeof(TARGET_PATTERN);
const SIZE_T PATCH_SIZE = sizeof(PATCH_DATA);
const wchar_t TARGET_MODULE[] = L"nvspcap64.dll";

// 启用调试特权
bool EnableDebugPrivilege() {
    HANDLE hToken;
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken))
        return false;

    TOKEN_PRIVILEGES tp;
    tp.PrivilegeCount = 1;
    if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &tp.Privileges[0].Luid)) {
        CloseHandle(hToken);
        return false;
    }

    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    bool success = AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tp), NULL, NULL);
    DWORD lastError = GetLastError();
    CloseHandle(hToken);

    return success && lastError == ERROR_SUCCESS;
}

// 自动获取dwm.exe进程ID
DWORD GetDwmProcessId() {
    PROCESSENTRY32 processInfo;
    processInfo.dwSize = sizeof(processInfo);

    HANDLE processesSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
    if (processesSnapshot == INVALID_HANDLE_VALUE)
        return 0;

    Process32First(processesSnapshot, &processInfo);
    if (!_wcsicmp(processInfo.szExeFile, L"dwm.exe")) {
        CloseHandle(processesSnapshot);
        return processInfo.th32ProcessID;
    }

    while (Process32Next(processesSnapshot, &processInfo)) {
        if (!_wcsicmp(processInfo.szExeFile, L"dwm.exe")) {
            CloseHandle(processesSnapshot);
            return processInfo.th32ProcessID;
        }
    }

    CloseHandle(processesSnapshot);
    return 0;
}

// 获取目标进程中指定模块的信息
bool GetModuleInfo(DWORD pid, const wchar_t* moduleName, MODULEENTRY32W& moduleInfo) {
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, pid);
    if (hSnapshot == INVALID_HANDLE_VALUE)
        return false;

    moduleInfo.dwSize = sizeof(MODULEENTRY32W);
    bool found = false;

    if (Module32FirstW(hSnapshot, &moduleInfo)) {
        do {
            if (_wcsicmp(moduleInfo.szModule, moduleName) == 0) {
                found = true;
                break;
            }
        } while (Module32NextW(hSnapshot, &moduleInfo));
    }

    CloseHandle(hSnapshot);
    return found;
}

// 带掩码的模式查找函数
LPVOID FindPatternWithMask(HANDLE hProcess, LPVOID startAddr, SIZE_T searchSize,
    const BYTE* pattern, const char* mask, SIZE_T patternSize) {
    if (!hProcess || !startAddr || !pattern || !mask || patternSize == 0 || searchSize < patternSize)
        return nullptr;

    std::vector<BYTE> buffer(searchSize);
    SIZE_T bytesRead;

    if (!ReadProcessMemory(hProcess, startAddr, buffer.data(), searchSize, &bytesRead) || bytesRead != searchSize)
        return nullptr;

    for (SIZE_T i = 0; i <= searchSize - patternSize; ++i) {
        bool match = true;
        for (SIZE_T j = 0; j < patternSize; ++j) {
            if (mask[j] == 'x' && buffer[i + j] != pattern[j]) {
                match = false;
                break;
            }
        }
        if (match) {
            return (LPVOID)((ULONG_PTR)startAddr + i);
        }
    }

    return nullptr;
}

// 应用补丁到找到的地址
bool ApplyPatch(HANDLE hProcess, LPVOID patchAddress) {
    if (!hProcess || !patchAddress)
        return false;

    DWORD oldProtect;
    if (!VirtualProtectEx(hProcess, patchAddress, PATCH_SIZE, PAGE_EXECUTE_READWRITE, &oldProtect)) {
        std::cerr << "修改内存保护失败. 错误代码: " << GetLastError() << "\n";
        return false;
    }

    SIZE_T bytesWritten;
    bool success = WriteProcessMemory(hProcess, patchAddress, PATCH_DATA, PATCH_SIZE, &bytesWritten) &&
        bytesWritten == PATCH_SIZE;

    if (!success) {
        std::cerr << "写入补丁数据失败. 错误代码: " << GetLastError() << "\n";
    }

    VirtualProtectEx(hProcess, patchAddress, PATCH_SIZE, oldProtect, &oldProtect);
    return success;
}

int main() {
    // 启用调试特权
    if (!EnableDebugPrivilege()) {
        std::cerr << "警告: 无法启用调试特权，可能导致操作失败\n";
    }

    // 自动获取dwm.exe进程ID
    DWORD pid = GetDwmProcessId();
    if (pid == 0) {
        std::cerr << "无法找到dwm.exe进程\n";
        return 1;
    }
    std::cout << "找到dwm.exe进程，PID: " << pid << "\n";

    // 打开目标进程
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (!hProcess) {
        std::cerr << "无法打开dwm.exe进程. 错误代码: " << GetLastError() << "\n";
        return 1;
    }

    // 查找目标模块
    MODULEENTRY32W moduleInfo;
    std::wcout << "正在查找模块 " << TARGET_MODULE << "...\n";
    if (!GetModuleInfo(pid, TARGET_MODULE, moduleInfo)) {
        std::cerr << "在dwm.exe进程中未找到 " << TARGET_MODULE << " 模块\n";
        CloseHandle(hProcess);
        return 1;
    }

    // 显示模块信息
    std::cout << "找到模块:\n";
    std::cout << "基地址: 0x" << std::hex << (ULONG_PTR)moduleInfo.modBaseAddr << "\n";
    std::cout << "模块大小: 0x" << std::hex << moduleInfo.modBaseSize << " 字节\n";

    // 显示查找的模式和掩码
    std::cout << "查找模式: ";
    for (SIZE_T i = 0; i < PATTERN_SIZE; ++i) {
        std::cout << std::hex << std::setw(2) << std::setfill('0')
            << static_cast<int>(TARGET_PATTERN[i]) << " ";
    }
    std::cout << "\n使用掩码: " << PATTERN_MASK << "\n";

    // 在模块范围内查找模式
    std::cout << "正在模块范围内查找模式...\n";
    LPVOID patternAddress = FindPatternWithMask(
        hProcess,
        moduleInfo.modBaseAddr,
        moduleInfo.modBaseSize,
        TARGET_PATTERN,
        PATTERN_MASK,
        PATTERN_SIZE
    );

    if (!patternAddress) {
        std::cerr << "未找到匹配的字节模式\n";
        CloseHandle(hProcess);
        return 1;
    }

    // 显示找到的模式地址
    std::cout << "找到匹配模式 at 0x" << std::hex << (ULONG_PTR)patternAddress << "\n";

    // 应用补丁
    std::cout << "尝试应用5个NOP补丁...\n";
    if (ApplyPatch(hProcess, patternAddress)) {
        std::cout << "5个NOP补丁已成功应用到 0x" << std::hex << (ULONG_PTR)patternAddress << "\n";
    }
    else {
        std::cerr << "补丁应用失败\n";
    }

    // 清理资源
    CloseHandle(hProcess);
    return 0;
}

```

`DisableNvidiaScreenshot/DisableNvidiaScreenshot.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{c445356d-b0a3-430e-b0d9-b4ed8991b39f}</ProjectGuid>
    <RootNamespace>FuckACEScreenshot</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="DisableNvidiaScreenshot.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DisableNvidiaScreenshot/FuckACEScreenshot.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="FuckACEScreenshot.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`LICENSE`:

```
MIT License

Copyright (c) 2025 oakboat

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# DisableNvidiaScreenshot

干掉N卡截图

```
char __fastcall sub_18003BB90(__int64 a1, __int64 a2, char a3)
{
  unsigned int v3; // edi
  __int64 v5; // rcx
  _BYTE *v7; // rdx
  int v8; // eax
  __int64 v9; // rax
  __int64 v10; // rax
  unsigned __int64 v11; // rcx
  __int64 v12; // rcx
  __int64 v13; // rax
  __int64 v14; // rdi
  __int64 v15; // rcx
  int v16; // eax
  __int64 v17; // rdx
  __int64 v18; // r8
  unsigned int v19; // ecx
  int v20; // eax
  _BYTE *v21; // rax
  __int64 v22; // rcx
  __int64 v24; // rcx
  _QWORD v25[3]; // [rsp+20h] [rbp-48h] BYREF
  int v26; // [rsp+38h] [rbp-30h]
  __int64 v27; // [rsp+3Ch] [rbp-2Ch]
  __int64 v28; // [rsp+44h] [rbp-24h]
  int v29; // [rsp+4Ch] [rbp-1Ch]
  __int64 v30; // [rsp+50h] [rbp-18h]
  __int64 v31; // [rsp+58h] [rbp-10h]

  v3 = 0;
  v25[0] = 131136LL;
  v27 = 0LL;
  v5 = *(_QWORD *)(a1 + 24);
  v28 = 0LL;
  v30 = 0LL;
  if ( !v5 || !*(_QWORD *)(a1 + 16) )
  {
    sub_180001C21(v5);
    sub_180008F6C(7LL, "CSPCaptureScreenShot::CaptureScreenShot: Invalid m_D3DResInfo");
    return 0;
  }
  v7 = *(_BYTE **)a1;
  v25[2] = *(_QWORD *)(a1 + 16);
  v8 = *(_DWORD *)(a1 + 36);
  v25[1] = v5;
  LOBYTE(v5) = 0;
  v26 = v8;
  v29 = *(_DWORD *)(a1 + 48);
  if ( *v7 )
  {
    v9 = *((_QWORD *)v7 + 2);
    if ( !v9 )
      goto LABEL_9;
  }
  else
  {
    v9 = *((_QWORD *)v7 + 1);
    if ( !v9 )
    {
LABEL_40:
      sub_180001C21(v5);
      sub_180008F6C(7LL, "CSPCaptureScreenShot::CaptureScreenShot: MMF GetSize() Failed %d", v3);
      return 0;
    }
  }
  v10 = *(_QWORD *)(v9 + 8);
  if ( v10 )
  {
    v3 = *(_DWORD *)(v10 + 16);
    LOBYTE(v5) = v3 != 0;
  }
LABEL_9:
  if ( !(_BYTE)v5 )
    goto LABEL_40;
  v11 = (unsigned int)(*(_DWORD *)(a1 + 60) * *(_DWORD *)(a1 + 64) * *(_DWORD *)(a1 + 68)) + 163LL;
  if ( v3 < v11 )
  {
    sub_180001C21(v11);
    sub_180008F6C(7LL, "CSPCaptureScreenShot::CaptureScreenShot: MMF Invalid MMF or MMF size ");
    return 0;
  }
  if ( *v7 )
  {
    v12 = *((_QWORD *)v7 + 2);
    if ( v12 )
    {
      v13 = sub_180005524(v12, 0LL, 0LL);
      goto LABEL_16;
    }
LABEL_38:
    sub_180001C21(v12);
    sub_180008F6C(7LL, "CSPCaptureScreenShot::CaptureScreenShot: Screenshot MMFLocked data pointer failed %d", 0);
    return 0;
  }
  v12 = *((_QWORD *)v7 + 1);
  if ( !v12 )
    goto LABEL_38;
  v13 = sub_180003E22(v12, 0LL, 0LL);
LABEL_16:
  v14 = v13;
  if ( !v13 )
    goto LABEL_38;
  v15 = *(_QWORD *)(a1 + 8);
  v31 = v13 + 160;
  v16 = (*(__int64 (__fastcall **)(__int64, _QWORD *))(*(_QWORD *)v15 + 8LL))(v15, v25);
  if ( v16 )
  {
    dword_1802BFF70 = 7;
    if ( dword_1802C00AC <= 7 )
      sub_18000A1D7(
        &off_1802BFF60,
        "CSPCaptureScreenShot::CaptureScreenShot: Screenshot Capture Frame Failed(0x%X)",
        v16);
    if ( *(_QWORD *)a1 )
    {
      sub_180009CC3(a1);
      return 0;
    }
    return 0;
  }
  v19 = *(_DWORD *)(a1 + 32);
  if ( v19 == 9 )
  {
    v20 = v30;
    if ( (_DWORD)v30 == 113 )
    {
      LODWORD(v30) = 10;
    }
    else
    {
      v17 = 87LL;
      if ( (_DWORD)v30 == 21 )
        v20 = 87;
      LODWORD(v30) = v20;
    }
  }
  *(_DWORD *)(v14 + 24) = v19;
  *(_DWORD *)(v14 + 20) = v29;
  *(_DWORD *)(v14 + 8) = HIDWORD(v27);
  *(_QWORD *)(v14 + 12) = v28;
  *(_DWORD *)(v14 + 28) = v30;
  if ( v19 >= 0xC0 && (((v19 & 0xFFFFFFF0) + 0x80000000) & 0xEFFFFFFF) != 0 )
  {
    if ( a3 )
    {
      v21 = *(_BYTE **)a1;
      if ( **(_BYTE **)a1 )
      {
        v22 = *((_QWORD *)v21 + 2);
        if ( v22 )
        {
          sub_180006280(v22, v17, v18);
          return 1;
        }
      }
      else
      {
        v24 = *((_QWORD *)v21 + 1);
        if ( v24 )
        {
          sub_18000B780(v24, v17, v18);
          return 1;
        }
      }
    }
  }
  else
  {
    sub_180009CC3(a1);
  }
  return 1;
}
```
关键
```
.text:000000018003BCA4                 call    qword ptr [rax+8]
```
当然也可以替换自己的截图 v13 v14为共享内存的buffer

```