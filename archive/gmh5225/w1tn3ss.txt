Project Path: arc_gmh5225_w1tn3ss_ytkdh81d

Source Tree:

```txt
arc_gmh5225_w1tn3ss_ytkdh81d
├── README.md
├── cmake
│   ├── CommonConfig.cmake
│   ├── LIEFConfig.cmake
│   ├── LuaConfig.cmake
│   ├── LuaJITBuild.cmake
│   ├── PlatformConfig.cmake
│   ├── README_Lua.md
│   ├── TracerConfig.cmake
│   └── WindowsSymbolConfig.cmake
├── frida
│   ├── call_tracer.py
│   └── stalk_drcov.py
├── scripts
│   ├── d0ct0r.py
│   ├── p1ll
│   │   └── string_patch.lua
│   └── w1script
│       ├── coverage_tracker.lua
│       ├── hook_demo_abi.lua
│       ├── hook_demo_sig.lua
│       ├── instruction_tracer.lua
│       ├── jsonl_tracer.lua
│       ├── macos_api_monitor_demo.lua
│       ├── memory_tracer.lua
│       ├── mnem_tracker.lua
│       ├── symbol_resolver.lua
│       ├── wip
│       │   ├── config_demo.lua
│       │   ├── memory_demo.lua
│       │   ├── module_demo.lua
│       │   └── vmstate_example.lua
│       └── xfer_tracker.lua
├── src
│   ├── p01s0n
│   │   ├── CMakeLists.txt
│   │   ├── p01s0n.cpp
│   │   ├── p01s0n.hpp
│   │   └── p01s0n_config.hpp
│   ├── p1ll
│   │   ├── CMakeLists.txt
│   │   ├── core
│   │   │   ├── context.cpp
│   │   │   ├── context.hpp
│   │   │   ├── platform.cpp
│   │   │   ├── platform.hpp
│   │   │   ├── signature.cpp
│   │   │   ├── signature.hpp
│   │   │   └── types.hpp
│   │   ├── engine
│   │   │   ├── auto_cure.cpp
│   │   │   ├── auto_cure.hpp
│   │   │   ├── memory_scanner.cpp
│   │   │   ├── memory_scanner.hpp
│   │   │   ├── pattern_matcher.cpp
│   │   │   └── pattern_matcher.hpp
│   │   ├── p1ll.cpp
│   │   ├── p1ll.hpp
│   │   ├── scripting
│   │   │   ├── lua_api.cpp
│   │   │   ├── lua_api.hpp
│   │   │   ├── lua_bindings.cpp
│   │   │   └── lua_bindings.hpp
│   │   └── utils
│   │       ├── file_utils.cpp
│   │       ├── file_utils.hpp
│   │       ├── hex_utils.cpp
│   │       ├── hex_utils.hpp
│   │       ├── pretty_hexdump.cpp
│   │       └── pretty_hexdump.hpp
│   ├── p1llx
│   │   ├── CMakeLists.txt
│   │   ├── commands
│   │   │   ├── cure.cpp
│   │   │   ├── cure.hpp
│   │   │   ├── patch.cpp
│   │   │   ├── patch.hpp
│   │   │   ├── poison.cpp
│   │   │   └── poison.hpp
│   │   └── main.cpp
│   ├── third_party
│   │   ├── lief
│   │   ├── luajit
│   │   ├── luajit_cmake
│   │   ├── qbdi
│   │   ├── redlog_cpp
│   │   └── sol2
│   ├── tracers
│   │   ├── CMakeLists.txt
│   │   ├── hooktest
│   │   │   ├── CMakeLists.txt
│   │   │   └── preload.cpp
│   │   ├── mintrace
│   │   │   ├── CMakeLists.txt
│   │   │   └── preload.cpp
│   │   ├── w1cov
│   │   │   ├── CMakeLists.txt
│   │   │   ├── coverage_collector.cpp
│   │   │   ├── coverage_collector.hpp
│   │   │   ├── coverage_config.hpp
│   │   │   ├── coverage_module_tracker.cpp
│   │   │   ├── coverage_module_tracker.hpp
│   │   │   ├── coverage_tracer.cpp
│   │   │   ├── coverage_tracer.hpp
│   │   │   ├── preload.cpp
│   │   │   └── session.hpp
│   │   ├── w1inst
│   │   │   ├── CMakeLists.txt
│   │   │   ├── instruction_collector.cpp
│   │   │   ├── instruction_collector.hpp
│   │   │   ├── instruction_config.hpp
│   │   │   ├── instruction_tracer.cpp
│   │   │   ├── instruction_tracer.hpp
│   │   │   ├── preload.cpp
│   │   │   └── session.hpp
│   │   ├── w1mem
│   │   │   ├── CMakeLists.txt
│   │   │   ├── memory_collector.cpp
│   │   │   ├── memory_collector.hpp
│   │   │   ├── memory_config.hpp
│   │   │   ├── memory_tracer.cpp
│   │   │   ├── memory_tracer.hpp
│   │   │   └── preload.cpp
│   │   ├── w1script
│   │   │   ├── CMakeLists.txt
│   │   │   ├── api_analysis_processor.cpp
│   │   │   ├── api_analysis_processor.hpp
│   │   │   ├── bindings
│   │   │   │   ├── api_analysis.cpp
│   │   │   │   ├── api_analysis.hpp
│   │   │   │   ├── callback_system.cpp
│   │   │   │   ├── callback_system.hpp
│   │   │   │   ├── calling_convention.cpp
│   │   │   │   ├── calling_convention.hpp
│   │   │   │   ├── core_types.cpp
│   │   │   │   ├── core_types.hpp
│   │   │   │   ├── hooking.cpp
│   │   │   │   ├── hooking.hpp
│   │   │   │   ├── memory_access.cpp
│   │   │   │   ├── memory_access.hpp
│   │   │   │   ├── memory_analysis.cpp
│   │   │   │   ├── memory_analysis.hpp
│   │   │   │   ├── module_analysis.cpp
│   │   │   │   ├── module_analysis.hpp
│   │   │   │   ├── output.cpp
│   │   │   │   ├── output.hpp
│   │   │   │   ├── register_access.cpp
│   │   │   │   ├── register_access.hpp
│   │   │   │   ├── signature_scanning.cpp
│   │   │   │   ├── signature_scanning.hpp
│   │   │   │   ├── symbol_resolution.cpp
│   │   │   │   ├── symbol_resolution.hpp
│   │   │   │   ├── utilities.cpp
│   │   │   │   ├── utilities.hpp
│   │   │   │   ├── vm_control.cpp
│   │   │   │   └── vm_control.hpp
│   │   │   ├── callback_manager.cpp
│   │   │   ├── callback_manager.hpp
│   │   │   ├── preload.cpp
│   │   │   ├── script_bindings.cpp
│   │   │   ├── script_bindings.hpp
│   │   │   ├── script_config.hpp
│   │   │   ├── script_loader.cpp
│   │   │   ├── script_loader.hpp
│   │   │   ├── script_tracer.cpp
│   │   │   ├── script_tracer.hpp
│   │   │   └── session.hpp
│   │   ├── w1trace
│   │   │   ├── CMakeLists.txt
│   │   │   ├── preload.cpp
│   │   │   ├── session.hpp
│   │   │   ├── trace_collector.cpp
│   │   │   ├── trace_collector.hpp
│   │   │   ├── trace_config.hpp
│   │   │   ├── trace_tracer.cpp
│   │   │   └── trace_tracer.hpp
│   │   └── w1xfer
│   │       ├── CMakeLists.txt
│   │       ├── preload.cpp
│   │       ├── session.hpp
│   │       ├── symbol_enricher.cpp
│   │       ├── symbol_enricher.hpp
│   │       ├── transfer_collector.cpp
│   │       ├── transfer_collector.hpp
│   │       ├── transfer_config.hpp
│   │       ├── transfer_tracer.cpp
│   │       └── transfer_tracer.hpp
│   ├── w1common
│   │   ├── CMakeLists.txt
│   │   ├── ext
│   │   │   ├── args.hpp
│   │   │   ├── jsonstruct.hpp
│   │   │   └── tinyformat.hpp
│   │   ├── platform_utils.hpp
│   │   ├── windows_clean.hpp
│   │   └── windows_console.hpp
│   ├── w1nj3ct
│   │   ├── CMakeLists.txt
│   │   ├── backend
│   │   │   ├── darwin
│   │   │   │   ├── exc_handler.c
│   │   │   │   ├── injector.c
│   │   │   │   ├── injector.h
│   │   │   │   ├── injector_internal.h
│   │   │   │   ├── mach.c
│   │   │   │   ├── mach_exc.h
│   │   │   │   ├── mach_excServer.c
│   │   │   │   ├── ptrace.c
│   │   │   │   ├── remote_call.c
│   │   │   │   └── util.c
│   │   │   ├── linux
│   │   │   │   ├── elf.c
│   │   │   │   ├── injector.c
│   │   │   │   ├── injector.h
│   │   │   │   ├── injector_internal.h
│   │   │   │   ├── ptrace.c
│   │   │   │   ├── remote_call.c
│   │   │   │   ├── shellcode.S
│   │   │   │   └── util.c
│   │   │   └── windows
│   │   │       ├── auxiliary.cpp
│   │   │       ├── auxiliary.hpp
│   │   │       ├── inject.hpp
│   │   │       ├── inject_createremotethread.cpp
│   │   │       ├── inject_launch.cpp
│   │   │       ├── inject_reflective.cpp
│   │   │       ├── inject_rtlcreateuserthread.cpp
│   │   │       ├── inject_setwindowshook.cpp
│   │   │       ├── util.hpp
│   │   │       └── winapis.h
│   │   ├── error.cpp
│   │   ├── error.hpp
│   │   ├── platform
│   │   │   ├── darwin
│   │   │   │   ├── darwin_injector.cpp
│   │   │   │   └── darwin_injector.hpp
│   │   │   ├── linux
│   │   │   │   ├── linux_injector.cpp
│   │   │   │   └── linux_injector.hpp
│   │   │   └── windows
│   │   │       ├── error_windows.cpp
│   │   │       ├── windows_injector.cpp
│   │   │       └── windows_injector.hpp
│   │   ├── w1nj3ct.cpp
│   │   └── w1nj3ct.hpp
│   ├── w1tn3ss
│   │   ├── CMakeLists.txt
│   │   ├── abi
│   │   │   ├── api_analyzer.cpp
│   │   │   ├── api_analyzer.hpp
│   │   │   ├── api_knowledge_db.cpp
│   │   │   ├── api_knowledge_db.hpp
│   │   │   ├── api_listener.cpp
│   │   │   ├── api_listener.hpp
│   │   │   ├── apis
│   │   │   │   ├── linux
│   │   │   │   │   └── system_apis.hpp
│   │   │   │   ├── macos
│   │   │   │   │   ├── libcxx_apis.hpp
│   │   │   │   │   ├── libdyld_apis.hpp
│   │   │   │   │   ├── libsystem_c_apis.hpp
│   │   │   │   │   ├── libsystem_kernel_apis.hpp
│   │   │   │   │   ├── libsystem_m_apis.hpp
│   │   │   │   │   ├── libsystem_malloc_apis.hpp
│   │   │   │   │   ├── libsystem_platform_apis.hpp
│   │   │   │   │   ├── libsystem_pthread_apis.hpp
│   │   │   │   │   └── system_apis.hpp
│   │   │   │   └── windows
│   │   │   │       ├── advapi32_apis.hpp
│   │   │   │       ├── kernel32_apis.hpp
│   │   │   │       ├── ntdll_apis.hpp
│   │   │   │       ├── psapi_apis.hpp
│   │   │   │       ├── system_apis.hpp
│   │   │   │       ├── ucrtbase_apis.hpp
│   │   │   │       ├── user32_apis.hpp
│   │   │   │       ├── winmm_apis.hpp
│   │   │   │       └── ws2_32_apis.hpp
│   │   │   ├── argument_extractor.cpp
│   │   │   ├── argument_extractor.hpp
│   │   │   ├── calling_convention_base.hpp
│   │   │   ├── calling_convention_detector.cpp
│   │   │   ├── calling_convention_detector.hpp
│   │   │   ├── calling_convention_factory.cpp
│   │   │   ├── calling_convention_factory.hpp
│   │   │   ├── conventions
│   │   │   │   ├── arm
│   │   │   │   │   ├── aarch64_aapcs.cpp
│   │   │   │   │   └── aarch64_aapcs.hpp
│   │   │   │   ├── x86
│   │   │   │   │   ├── cdecl.cpp
│   │   │   │   │   └── cdecl.hpp
│   │   │   │   └── x86_64
│   │   │   │       ├── microsoft.cpp
│   │   │   │       ├── microsoft.hpp
│   │   │   │       ├── system_v.cpp
│   │   │   │       └── system_v.hpp
│   │   │   └── fpr_utils.hpp
│   │   ├── engine
│   │   │   ├── session_base.hpp
│   │   │   ├── tracer_config_base.hpp
│   │   │   └── tracer_engine.hpp
│   │   ├── formats
│   │   │   ├── drcov.hpp
│   │   │   └── graphvizdot.hpp
│   │   ├── hooking
│   │   │   ├── hook_manager.cpp
│   │   │   └── hook_manager.hpp
│   │   ├── symbols
│   │   │   ├── lief_symbol_backend.cpp
│   │   │   ├── lief_symbol_backend.hpp
│   │   │   ├── macos_dyld_resolver.cpp
│   │   │   ├── macos_dyld_resolver.hpp
│   │   │   ├── path_resolver.hpp
│   │   │   ├── posix_symbol_backend.cpp
│   │   │   ├── posix_symbol_backend.hpp
│   │   │   ├── symbol_backend.hpp
│   │   │   ├── symbol_info.hpp
│   │   │   ├── symbol_resolver.cpp
│   │   │   ├── symbol_resolver.hpp
│   │   │   ├── windows_path_resolver.cpp
│   │   │   ├── windows_path_resolver.hpp
│   │   │   ├── windows_symbol_backend.cpp
│   │   │   └── windows_symbol_backend.hpp
│   │   └── util
│   │       ├── env_config.cpp
│   │       ├── env_config.hpp
│   │       ├── env_enumerator.cpp
│   │       ├── env_enumerator.hpp
│   │       ├── interval_tree.hpp
│   │       ├── jsonl_writer.cpp
│   │       ├── jsonl_writer.hpp
│   │       ├── memory_range_index.cpp
│   │       ├── memory_range_index.hpp
│   │       ├── module_info.hpp
│   │       ├── module_range_index.cpp
│   │       ├── module_range_index.hpp
│   │       ├── module_scanner.cpp
│   │       ├── module_scanner.hpp
│   │       ├── register_access.hpp
│   │       ├── register_capture.cpp
│   │       ├── register_capture.hpp
│   │       ├── safe_memory.cpp
│   │       ├── safe_memory.hpp
│   │       ├── signal_handler.cpp
│   │       ├── signal_handler.hpp
│   │       ├── stack_capture.cpp
│   │       ├── stack_capture.hpp
│   │       ├── stderr_write.hpp
│   │       ├── value_formatter.cpp
│   │       └── value_formatter.hpp
│   └── w1tool
│       ├── CMakeLists.txt
│       ├── commands
│       │   ├── cover.cpp
│       │   ├── cover.hpp
│       │   ├── inject.cpp
│       │   ├── inject.hpp
│       │   ├── inspect.cpp
│       │   ├── inspect.hpp
│       │   ├── read_drcov.cpp
│       │   ├── read_drcov.hpp
│       │   ├── tracer.cpp
│       │   └── tracer.hpp
│       ├── main.cpp
│       ├── tracer_discovery.cpp
│       └── tracer_discovery.hpp
├── tests
│   ├── CMakeLists.txt
│   ├── libraries
│   │   ├── CMakeLists.txt
│   │   ├── counter_lib.c
│   │   ├── linux_test_lib.c
│   │   ├── memory_lib.c
│   │   └── tracer_lib.c
│   └── programs
│       ├── CMakeLists.txt
│       ├── control_flow_1.cpp
│       ├── hook_test_target.c
│       ├── linux_daemon.c
│       ├── linux_target.c
│       ├── multi_threaded_target.c
│       ├── p1ll_test_target.c
│       ├── runtime_injection_target.c
│       ├── signature_helper.h
│       ├── simple_demo.c
│       ├── test_p1ll_pattern_matching.cpp
│       └── test_standalone_tracers.cpp
└── tools
    ├── README.md
    ├── macos_signing
    │   ├── entitlement.xml
    │   ├── genkey.sh
    │   └── sign.sh
    └── setup_macos.sh

```

`README.md`:

```md
# w1tn3ss

a cross-platform dynamic binary analysis and instrumentation framework powered by [qbdi](https://github.com/QBDI/QBDI) and [lief](https://github.com/lief-project/LIEF).

## features

+ framework for writing dynamic tracers (`w1tn3ss`)
+ built-in tracers: coverage (`w1cov`), call tracing (`w1xfer`), memory (`w1mem`), instructions (`w1inst`)
+ real-time library call interception with argument extraction (`api_analyzer`)
+ signature scanning and binary patching (`p1ll`/`p1llx`)
+ scriptable tracing and patching with with [luajit](https://luajit.org/)
+ cross-platform injection library with multiple techniques (`w1nj3ct`)
+ symbol resolution and calling convention modeling for intercepting arguments and return values

## build

build for any platform (with script and lief enabled):
```sh
cmake -G Ninja -B build-release -DCMAKE_BUILD_TYPE=Release -DWITNESS_SCRIPT=ON -DWITNESS_LIEF=ON
cmake --build build-release --parallel
```

to use a specific arch, configure `WITNESS_ARCH` (`x64`, `x86`, `arm64`)

## `w1tool` guide

this is a brief guide to using `w1tool`, a ready-to-use command line for running tracers

### coverage & tracing

code coverage helps us learn what code in a program gets run and how often. the `w1cov` tracer is purpose built to collect detailed code coverage information, with only modest performance overhead.

the drcov format is ideal for coverage tracing, as it includes metadata about loaded modules. `w1cov` also supports collecting data in a superset of the drcov format, which also records hit counts of coverage units. this can be useful to record the execution frequency of a block.

collect coverage in drcov format using `w1cov`:
```sh
# macos/linux
./build-release/w1tool cover -s ./build-release/tests/programs/simple_demo
# windows
.\build-release\w1tool.exe cover -s .\build-release\tests\programs\simple_demo.exe
```

output will resemble:
```
[w1cov.preload] [inf] coverage data export completed      output_file=simple_demo_coverage.drcov
[w1cov.tracer] [inf] coverage collection completed       coverage_units=59 modules=50 total_hits=71
```

the default block tracing mode is significantly more efficient than per-instruction tracing as it requires less frequent callback interuptions. however, qbdi detects basic blocks dynamically, so recorded block boundaries may differ from those detected by static analysis tools. this usually isn't an issue, as you can script your disassembler to fix any discrepancies when marking basic block coverage.

you can also trace coverage in the same drcov format by passing `--inst` to `cover`, which will use instruction callbacks.

for a more primitive form of tracing which simply records the instruction pointer, use `w1trace`:
```sh
# macos/linux
./build-release/w1tool tracer -n w1trace -c output=simple_demo_trace.txt -s ./build-release/tests/programs/simple_dem
# windows
.\build-release\w1tool.exe tracer -n w1trace -c output=simple_demo_trace.txt -s .\build-release\tests\programs\simple_demo.exe
```

### real-time api call analysis

often it is valuable to learn what system library apis a program is called. for example, we can learn a lot about the behavior of a program by observing its calls to `libc`. the `w1xfer` tracer, powered by qbdi's [`ExecBroker`](https://qbdi.readthedocs.io/en/stable/tutorial_ExecBrokerEvent.html) mechanism, can intercept and observe calls from and returns back to instrumented code.

in addition to detecting calls crossing the instrumentation boundary, `w1xfer` also contains an `api_analyzer` system, which resolves the symbols of these calls, and extracts function arguments based on platform-specific calling convention models. this allows for very rich interception and tracing of the arguments and return values of common library apis. this can be extended by adding to the `api_knowledge_db` component.

trace api calls in real time with `w1xfer`:
```sh
# macos/linux
./build-release/w1tool -v tracer -n w1xfer -c analyze_apis=true -c output=test_transfers.jsonl -s ./build-release/tests/programs/simple_demo
# windows
.\build-release\w1tool.exe -v tracer -n w1xfer -c analyze_apis=true -c output=test_transfers.jsonl -s .\build-release\tests\programs\simple_demo.exe
```

output will resemble:
```
[w1.calling_convention_factory] [inf] registered platform conventions     platform=aarch64 count=1
...
[w1.api_analyzer] [vrb] analyzed api call                   call=malloc(size=64) category=Heap module=libsystem_malloc.dylib
[w1.api_analyzer] [vrb] analyzed api return                 return=malloc() = 0x600003b982c0 raw_value=105553178755776 module=libsystem_malloc.dylib
...
[w1.api_analyzer] [vrb] analyzed api call                   call=puts(s="simple demo finished") category=I/O module=libsystem_c.dylib
simple demo finished
[w1.api_analyzer] [vrb] analyzed api return                 return=puts() = 10 raw_value=10 module=libsystem_c.dylib
[w1.api_analyzer] [vrb] analyzed api call                   call=intercept_exit(?) category= module=w1xfer_qbdipreload.dylib
[w1.preload] [inf] w1xfer preload exit                 status=0
```

as seen above, this can successfully intercept calls to many common `libc` apis!

### scripting

w1tn3ss supports writing custom tracers in luajit through the `w1script` tracer.
scripts can hook various callbacks and directly access vm state, registers, and memory.

here's a simple instruction tracer:
```lua
local instruction_count = 0

local tracer = {}
tracer.callbacks = { "instruction_postinst" }

function tracer.on_instruction_postinst(vm, gpr, fpr)
    instruction_count = instruction_count + 1
    
    -- get program counter and disassembly
    local pc = w1.get_reg_pc and w1.get_reg_pc(gpr) or 0
    local disasm = w1.get_disassembly(vm)
    
    -- log instruction with address and disassembly
    w1.log_info(w1.format_address(pc) .. ": " .. disasm)
    
    return w1.VMAction.CONTINUE
end

return tracer
```

run it:
```sh
# macos/linux
./build-release/w1tool tracer -n w1script -c script=./scripts/w1script/instruction_tracer.lua -s ./build-release/tests/programs/simple_demo
# windows
.\build-release\w1tool.exe tracer -n w1script -c script=./scripts/w1script/instruction_tracer.lua -s .\build-release\tests\programs\simple_demo.exe
```

this will produce a trace of disassembled instructions as they are executed.

see the [example scripts](./scripts/w1script/), which demonstrate memory tracing, function hooking, coverage collection, and api interception.

## `p1ll` guide

patching binaries is an essential part of a reversing or cracking workflow. `p1ll` is a portable signature scanning and patching library that can patch binaries statically on disk or dynamically in memory.
`p1llx` provides a nifty command line to run and inspect patches.

### static patching

patch a binary on disk:
```sh
./build-release/p1llx -vv cure -c ./patch_script.lua -i ./target_binary -o ./patched_binary
```

on macos, statically patched binaries require codesigning:
```sh
codesign -fs - ./patched_binary
```

the `d0ct0r.py` script provides intelligent patch development features; it automatically backs up the input file, and handles permissions and codesigning.

### dynamic patching

patch a running process in memory:
```sh
# spawn new process
./build-release/p1llx -vv poison -c ./patch_script.lua -s ./target_binary

# attach to existing process
./build-release/p1llx -vv poison -c ./patch_script.lua -n target_binary
```

### patch scripts

`p1ll` uses scripts to define signatures and patching. this is designed to be used through the declarative `auto_cure` api, which can define platform-specific signatures and patches.

example patch script:
```lua
-- validation signature
local SIG_DEMO_NAME = p1.sig(p1.str2hex("Demo Program"))
-- unique signature for this string
local SIG_ANGERY = p1.sig(p1.str2hex("Angery"), {single = true})

-- find a function by signature (optional module filter)
local SIG_CHECK_LICENSE_WIN_X64 = p1.sig([[
  4885c0          -- test rax, rax
  74??            -- je <offset>
  b001            -- mov al, 1
]], {filter = "demo_program"})

-- patch: fall through the check by nopping it
local FIX_CHECK_LICENSE_WIN_X64 = [[
  ??????
  9090            -- nop nop
  ????
]]

local meta = { -- declarative patch
  name = "demo_program",
  platforms = {"windows:x64"}, -- platforms supported by this patch
  sigs = {
    ["*"] = { -- wildcard signatures are checked on all platforms
      SIG_DEMO_NAME,
      SIG_ANGERY,
    }
  },
  patches = {
    ["windows:x64"] = { -- patch only on windows:x64
        p1.patch(sig_check_license, 0, fix_check_license)
    },
    ["*"] = { -- wildcard patches are used on all platforms
      p1.patch(SIG_ANGERY, 0, p1.str2hex("Happey"))
    }
  }
}

function cure()
  return p1.auto_cure(meta)
end
```

key concepts:
- `p1.sig()`: define byte patterns (with `??` for wildcards)
- `p1.patch()`: specify signature, offset, and replacement
- `meta` table: organize sigs and patches by platform

`p1ll` is an excellent and powerful tool for binary modification!

```

`cmake/CommonConfig.cmake`:

```cmake
# common configuration for all targets
include_guard()

# standard settings
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# default to release build
if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Release)
endif()

# critical windows safeseh hack for qbdi assembly compatibility
if(WIN32 AND CMAKE_SIZEOF_VOID_P EQUAL 4 AND MSVC)
    set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} /SAFESEH:NO")
    set(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} /SAFESEH:NO")
    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /SAFESEH:NO")
endif()

# common compiler flags
function(apply_common_compile_options target)
    target_compile_features(${target} PRIVATE cxx_std_20)
    target_compile_options(${target} PRIVATE
        $<$<CXX_COMPILER_ID:GNU,Clang>:-Wall -Wextra -O2>
        $<$<CXX_COMPILER_ID:MSVC>:/EHsc>
    )
endfunction()

# windows platform definitions
function(apply_windows_definitions target)
    if(WIN32)
        target_compile_definitions(${target} PRIVATE
            NOMINMAX
            WIN32_LEAN_AND_MEAN
            _CRT_SECURE_NO_WARNINGS
        )
    endif()
endfunction()

# platform-specific linking
function(apply_platform_linking target)
    if(WIN32)
        target_link_libraries(${target} PRIVATE psapi kernel32 user32)
    elseif(UNIX AND NOT APPLE)
        target_link_libraries(${target} PRIVATE dl)
    endif()
endfunction()

# standard output directories
function(set_standard_output_dirs target)
    set_target_properties(${target} PROPERTIES
        LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib
        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib
        ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib
    )
endfunction()
```

`cmake/LIEFConfig.cmake`:

```cmake
# liefconfig.cmake - lief configuration module
# provides functions for setting up lief dependencies

# global lief configuration
option(WITNESS_LIEF "enable lief binary analysis support" OFF)

# validate lief submodule availability
function(validate_lief_submodule)
    set(LIEF_DIR "${WITNESS_SOURCE_DIR}/src/third_party/lief")
    if(NOT EXISTS "${LIEF_DIR}/CMakeLists.txt")
        message(FATAL_ERROR "lief submodule not found at ${LIEF_DIR}. run: git submodule update --init --recursive")
    endif()
    
    set(LIEF_DIR ${LIEF_DIR} PARENT_SCOPE)
endfunction()

# configure a target with lief dependencies
function(configure_target_with_lief target_name)
    if(NOT WITNESS_LIEF)
        return()
    endif()
    
    if(TARGET ${target_name})
        target_link_libraries(${target_name} PRIVATE LIEF::LIEF)
        target_compile_definitions(${target_name} PRIVATE WITNESS_LIEF_ENABLED=1)
        
        # apply windows symbol resolution for potential conflicts
        if(WIN32 AND MSVC)
            configure_windows_symbol_resolution(${target_name})
        endif()
    endif()
endfunction()

# setup lief environment
function(setup_lief_environment)
    if(NOT WITNESS_LIEF)
        return()
    endif()
    
    validate_lief_submodule()
    
    # configure lief build options
    set(LIEF_EXAMPLES OFF CACHE BOOL "disable lief examples")
    set(LIEF_TESTS OFF CACHE BOOL "disable lief tests")
    set(LIEF_PYTHON_API OFF CACHE BOOL "disable lief python api")
    set(LIEF_C_API OFF CACHE BOOL "disable lief c api")
    set(LIEF_RUST_API OFF CACHE BOOL "disable lief rust api")
    set(LIEF_LOGGING OFF CACHE BOOL "disable lief logging")
    set(LIEF_ENABLE_JSON OFF CACHE BOOL "disable lief json support")
    
    # export variables for parent scope
    set(LIEF_DIR ${LIEF_DIR} PARENT_SCOPE)
endfunction()
```

`cmake/LuaConfig.cmake`:

```cmake
# luaconfig.cmake - lua/sol2 configuration module
# provides functions for setting up lua and sol2 dependencies

# global scripting configuration
option(WITNESS_SCRIPT "enable lua scripting support with sol2" OFF)

include(${WITNESS_SOURCE_DIR}/cmake/LuaJITBuild.cmake)

# validate sol2 submodule availability
function(validate_sol2_submodule)
    set(SOL2_DIR "${WITNESS_SOURCE_DIR}/src/third_party/sol2")
    if(NOT EXISTS "${SOL2_DIR}/include/sol/sol.hpp")
        message(FATAL_ERROR "sol2 submodule not found at ${SOL2_DIR}. run: git submodule update --init --recursive")
    endif()
    
    set(SOL2_DIR ${SOL2_DIR} PARENT_SCOPE)
endfunction()

# configure a target with lua/sol2 dependencies
function(configure_target_with_lua target_name)
    if(NOT WITNESS_SCRIPT)
        return()
    endif()
    
    if(TARGET ${target_name})
        target_include_directories(${target_name} PUBLIC ${SOL2_DIR}/include)
        target_link_libraries(${target_name} PRIVATE ${LUAJIT_LIBRARIES} luajit::header)
        target_compile_definitions(${target_name} PUBLIC WITNESS_SCRIPT_ENABLED=1)
    endif()
endfunction()

# setup lua environment (luajit + sol2)
function(setup_lua_environment)
    if(NOT WITNESS_SCRIPT)
        return()
    endif()
    
    validate_sol2_submodule()
    build_luajit_from_source()
    
    # export variables for parent scope
    set(SOL2_DIR ${SOL2_DIR} PARENT_SCOPE)
    set(LUAJIT_INCLUDE_DIRS ${LUAJIT_INCLUDE_DIRS} PARENT_SCOPE)
    set(LUAJIT_LIBRARIES ${LUAJIT_LIBRARIES} PARENT_SCOPE)
    set(LUAJIT_STATIC_TARGET ${LUAJIT_STATIC_TARGET} PARENT_SCOPE)
endfunction()
```

`cmake/LuaJITBuild.cmake`:

```cmake
# luajitbuild.cmake - builds luajit from source using luajit-cmake wrapper
# provides cross-platform luajit static library build

# configuration options
option(WITNESS_LUAJIT_DISABLE_FFI "disable luajit ffi support" OFF)
option(WITNESS_LUAJIT_DISABLE_JIT "disable jit compilation (interpreter only)" OFF)
option(WITNESS_LUAJIT_ENABLE_LUA52COMPAT "enable lua 5.2 compatibility features" OFF)

# main function to build luajit static library
function(build_luajit_from_source)
    if(NOT EXISTS "${WITNESS_SOURCE_DIR}/src/third_party/luajit_cmake/CMakeLists.txt")
        message(FATAL_ERROR "luajit-cmake submodule not found. run: git submodule update --init --recursive")
    endif()
    
    if(NOT EXISTS "${WITNESS_SOURCE_DIR}/src/third_party/luajit/src/lua.h")
        message(FATAL_ERROR "luajit submodule not found. run: git submodule update --init --recursive")
    endif()
    
    # set luajit source directory for luajit-cmake wrapper
    set(LUAJIT_DIR "${WITNESS_SOURCE_DIR}/src/third_party/luajit" CACHE PATH "path to luajit source")
    
    # configure luajit build options
    set(LUAJIT_DISABLE_FFI ${WITNESS_LUAJIT_DISABLE_FFI} CACHE BOOL "disable luajit ffi")
    set(LUAJIT_DISABLE_JIT ${WITNESS_LUAJIT_DISABLE_JIT} CACHE BOOL "disable jit compilation")
    set(LUAJIT_ENABLE_LUA52COMPAT ${WITNESS_LUAJIT_ENABLE_LUA52COMPAT} CACHE BOOL "enable lua 5.2 compatibility")
    set(LUAJIT_BUILD_EXE OFF CACHE BOOL "disable luajit executable build")
    set(LUAJIT_BUILD_ALAMG OFF CACHE BOOL "disable amalgamated build")
    
    # set architecture manually to avoid try_compile issues in cross-compilation
    if(CMAKE_SYSTEM_PROCESSOR MATCHES "aarch64|arm64")
        set(LJ_DETECTED_ARCH "AArch64" CACHE STRING "luajit target architecture")
    elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "x86_64|AMD64")
        set(LJ_DETECTED_ARCH "x86_64" CACHE STRING "luajit target architecture")
    elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "i[3-6]86|x86")
        set(LJ_DETECTED_ARCH "x86" CACHE STRING "luajit target architecture")
    elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "arm")
        set(LJ_DETECTED_ARCH "ARM" CACHE STRING "luajit target architecture")
    endif()
    
    # add luajit-cmake subdirectory with unique binary directory
    add_subdirectory(${WITNESS_SOURCE_DIR}/src/third_party/luajit_cmake ${CMAKE_BINARY_DIR}/witness_luajit)
    
    # ensure generated headers are available (luajit.h, etc.)
    if(TARGET luajit-header)
        target_include_directories(luajit-header INTERFACE ${CMAKE_BINARY_DIR}/witness_luajit)
    endif()
    
    # export targets and variables for parent scope
    set(LUAJIT_STATIC_TARGET luajit::lib PARENT_SCOPE)
    set(LUAJIT_INCLUDE_DIRS ${LUA_INCLUDE_DIR} PARENT_SCOPE)
    set(LUAJIT_LIBRARIES luajit::lib PARENT_SCOPE)
    
    message(STATUS "configured luajit static library build using luajit-cmake")
endfunction()
```

`cmake/PlatformConfig.cmake`:

```cmake
# platform and architecture detection
include_guard()

# detect platform for qbdi
function(detect_qbdi_platform)
    if(CMAKE_SYSTEM_NAME STREQUAL "Linux")
        set(QBDI_PLATFORM "linux" CACHE STRING "QBDI Platform" FORCE)
    elseif(CMAKE_SYSTEM_NAME STREQUAL "Darwin")
        set(QBDI_PLATFORM "osx" CACHE STRING "QBDI Platform" FORCE)
    elseif(CMAKE_SYSTEM_NAME STREQUAL "Windows")
        set(QBDI_PLATFORM "windows" CACHE STRING "QBDI Platform" FORCE)
    else()
        message(FATAL_ERROR "Unsupported platform: ${CMAKE_SYSTEM_NAME}")
    endif()
    
    message(STATUS "QBDI Platform: ${QBDI_PLATFORM}")
endfunction()

# detect and configure architecture
function(detect_architecture)
    if(NOT DEFINED WITNESS_ARCH OR WITNESS_ARCH STREQUAL "Auto")
        # auto-detect architecture
        if(CMAKE_SYSTEM_PROCESSOR MATCHES "^(x86_64|AMD64)$")
            set(QBDI_ARCH "X86_64" CACHE STRING "QBDI Architecture")
            set(WITNESS_ARCH "x64" CACHE STRING "Witness Architecture")
        elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "^(i386|i686)$")
            set(QBDI_ARCH "X86" CACHE STRING "QBDI Architecture")
            set(WITNESS_ARCH "x86" CACHE STRING "Witness Architecture")
        elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "^(aarch64|arm64)$")
            set(QBDI_ARCH "AARCH64" CACHE STRING "QBDI Architecture")
            set(WITNESS_ARCH "arm64" CACHE STRING "Witness Architecture")
        elseif(CMAKE_SYSTEM_PROCESSOR STREQUAL "arm")
            set(QBDI_ARCH "ARM" CACHE STRING "QBDI Architecture")
            set(WITNESS_ARCH "arm" CACHE STRING "Witness Architecture")
        else()
            message(FATAL_ERROR "Unsupported architecture: ${CMAKE_SYSTEM_PROCESSOR}")
        endif()
        message(STATUS "Auto-detected architecture: ${WITNESS_ARCH}")
    else()
        # user-specified architecture
        if(WITNESS_ARCH STREQUAL "x64")
            set(QBDI_ARCH "X86_64" CACHE STRING "QBDI Architecture")
        elseif(WITNESS_ARCH STREQUAL "x86")
            set(QBDI_ARCH "X86" CACHE STRING "QBDI Architecture")
        elseif(WITNESS_ARCH STREQUAL "arm64")
            set(QBDI_ARCH "AARCH64" CACHE STRING "QBDI Architecture")
        else()
            message(FATAL_ERROR "Invalid WITNESS_ARCH: ${WITNESS_ARCH}. Must be: x64, x86, arm64, Auto")
        endif()
        message(STATUS "User-specified architecture: ${WITNESS_ARCH}")
    endif()
    
    message(STATUS "WITNESS Architecture: ${WITNESS_ARCH}")
    message(STATUS "QBDI Architecture: ${QBDI_ARCH}")
endfunction()

# configure qbdi build options
function(configure_qbdi_options)
    set(QBDI_STATIC_LIBRARY ON PARENT_SCOPE)
    set(QBDI_SHARED_LIBRARY ON PARENT_SCOPE)
    set(QBDI_LOG_DEBUG OFF PARENT_SCOPE)
    set(QBDI_TOOLS_QBDIPRELOAD ON PARENT_SCOPE)
    set(QBDI_CCACHE ON PARENT_SCOPE)
    set(QBDI_DISABLE_AVX OFF PARENT_SCOPE)
    set(QBDI_ASAN OFF PARENT_SCOPE)

    if(WITNESS_QBDI_EXTRAS)
        set(QBDI_TOOLS_PYQBDI ON PARENT_SCOPE)
        set(QBDI_TOOLS_FRIDAQBDI ON PARENT_SCOPE)
        set(QBDI_TEST ON PARENT_SCOPE)
        set(QBDI_EXAMPLES ON PARENT_SCOPE)
        set(QBDI_BENCHMARK ON PARENT_SCOPE)
    else()
        set(QBDI_TOOLS_PYQBDI OFF PARENT_SCOPE)
        set(QBDI_TOOLS_FRIDAQBDI OFF PARENT_SCOPE)
        set(QBDI_TEST OFF PARENT_SCOPE)
        set(QBDI_EXAMPLES ON PARENT_SCOPE)
        set(QBDI_BENCHMARK OFF PARENT_SCOPE)
    endif()
endfunction()
```

`cmake/README_Lua.md`:

```md
# WITNESS Lua/Sol2 Integration

This directory contains a clean, cross-platform Lua/sol2 integration for WITNESS projects.

## Overview

- **LuaJIT**: Built from source using `luajit-cmake` wrapper for cross-platform compatibility
- **sol2**: Header-only C++ library for elegant Lua bindings
- **Static linking**: No runtime dependencies
- **Optional**: Easily enabled/disabled with `WITNESS_SCRIPT` option

## Files

- `LuaConfig.cmake` - Main configuration module with easy-to-use functions
- `LuaJITBuild.cmake` - LuaJIT build system using luajit-cmake wrapper

## Usage

### For new projects:

```cmake
include(${CMAKE_SOURCE_DIR}/cmake/LuaConfig.cmake)

# Setup the Lua environment (only if WITNESS_SCRIPT=ON)
setup_lua_environment()

# Configure your target with Lua dependencies
configure_target_with_lua(my_target)
```

### Configuration options:

```bash
# Enable Lua scripting support
cmake -DWITNESS_SCRIPT=ON ...

# Optional LuaJIT configuration
cmake -DWITNESS_SCRIPT=ON \
      -DWITNESS_LUAJIT_DISABLE_FFI=OFF \
      -DWITNESS_LUAJIT_DISABLE_JIT=OFF \
      -DWITNESS_LUAJIT_ENABLE_LUA52COMPAT=OFF \
      ...
```

## Dependencies

Required submodules (auto-checked):
- `src/third_party/luajit` - LuaJIT source code
- `src/third_party/luajit_cmake` - CMake wrapper for LuaJIT  
- `src/third_party/sol2` - sol2 header library

Initialize with: `git submodule update --init --recursive`

## Example Usage in Code

```cpp
#ifdef WITNESS_SCRIPT_ENABLED
#include <sol/sol.hpp>

void init_lua() {
    sol::state lua;
    lua.open_libraries(sol::lib::base, sol::lib::package);
    lua["hello"] = []() { return "Hello from Lua!"; };
}
#endif
```
```

`cmake/TracerConfig.cmake`:

```cmake
# tracer library configuration
include_guard()

include(${WITNESS_SOURCE_DIR}/cmake/CommonConfig.cmake)

# create tracer library targets (shared and static)
function(create_tracer_targets tracer_name source_files)
    if(WITNESS_BUILD_SHARED)
        add_library(${tracer_name}_qbdipreload SHARED ${source_files})
        configure_tracer_target(${tracer_name}_qbdipreload ${tracer_name})
    endif()

    if(WITNESS_BUILD_STATIC)
        add_library(${tracer_name}_static STATIC ${source_files})        
        configure_tracer_target(${tracer_name}_static ${tracer_name})
    endif()
endfunction()

# configure individual tracer target
function(configure_tracer_target target_name tracer_name)
    target_include_directories(${target_name} PRIVATE
        ${WITNESS_SOURCE_DIR}/src
        ${WITNESS_SOURCE_DIR}/src/third_party/qbdi/tools/QBDIPreload/include
    )

    target_link_libraries(${target_name} PRIVATE
        w1tn3ss
        QBDI_static
        redlog::redlog
    )
    
    # link qbdipreload for shared library version
    if(${target_name} MATCHES "_qbdipreload$")
        target_link_libraries(${target_name} PRIVATE QBDIPreload)
    endif()

    apply_common_compile_options(${target_name})
    apply_windows_definitions(${target_name})
    set_standard_output_dirs(${target_name})

    # remove lib prefix and set macos rpath
    set_target_properties(${target_name} PROPERTIES PREFIX "")
    if(APPLE)
        set_target_properties(${target_name} PROPERTIES MACOSX_RPATH TRUE)
    elseif(UNIX)
        target_link_libraries(${target_name} PRIVATE dl)
    endif()
endfunction()
```

`cmake/WindowsSymbolConfig.cmake`:

```cmake
# WindowsSymbolConfig.cmake - Windows-specific symbol conflict resolution
# handles duplicate symbol issues that occur on Windows MSVC but not on Unix platforms

include_guard()

# configure Windows-specific linker options to handle duplicate symbols
function(configure_windows_symbol_resolution target)
    if(WIN32 AND MSVC)
        # check if target links both QBDI and LIEF (potential conflict sources)
        get_target_property(target_libs ${target} LINK_LIBRARIES)
        set(has_qbdi FALSE)
        set(has_lief FALSE)
        
        if(target_libs)
            foreach(lib IN LISTS target_libs)
                if(lib MATCHES "QBDI")
                    set(has_qbdi TRUE)
                endif()
                if(lib MATCHES "LIEF")
                    set(has_lief TRUE)
                endif()
            endforeach()
        endif()
        
        # also check transitive dependencies from w1tn3ss which has both
        if(target_libs AND target_libs MATCHES "w1tn3ss")
            set(has_qbdi TRUE)
            set(has_lief TRUE)
        endif()
        
        # debug output to see what we found
        message(DEBUG "${target}: has_qbdi=${has_qbdi}, has_lief=${has_lief}, libs=${target_libs}")
        
        if(has_qbdi AND has_lief)
            message(STATUS "applying fmt conflict resolution for ${target}")
            # only handle specific fmt library conflicts between LIEF and QBDI
            target_link_options(${target} PRIVATE
                /FORCE:MULTIPLE    # allow first definition to win for duplicates
            )
        endif()
    endif()
endfunction()

# apply Windows symbol resolution to all project targets
function(apply_windows_symbol_resolution_to_all)
    # get all targets in the current directory and subdirectories
    get_property(targets DIRECTORY PROPERTY BUILDSYSTEM_TARGETS)
    
    foreach(target IN LISTS targets)
        # only apply to executable and library targets
        get_target_property(target_type ${target} TYPE)
        if(target_type MATCHES "EXECUTABLE|SHARED_LIBRARY|MODULE_LIBRARY|STATIC_LIBRARY")
            configure_windows_symbol_resolution(${target})
        endif()
    endforeach()
endfunction()
```

`frida/call_tracer.py`:

```py
#!/usr/bin/env python3

"""
call_tracer.py
A frida-based call tracer that monitors function calls within specified functions.

Example usage:

# install frida-tools via uv
uv tool install frida-tools

# run python with uv
uv tool run --from frida-tools python ...

# trace and show summary in terminal (no file output)
python call_tracer.py 1234 -F 0x401000

# trace with verbose output (-v for verbose, -vv for extra verbose)
python call_tracer.py 1234 -F 0x401000 -vv

# trace with custom buffer size
python call_tracer.py 1234 -F 0x401000 --buffer-size 2000

# trace specific functions and save to file
python call_tracer.py 1234 -F 0x401000 -F 0x402000 -o traces.json

# trace using module+offset format (handles ASLR)
python call_tracer.py 1234 -F myapp+0x1234 -F libcrypto+2048 -o traces.json

# trace by function name with symbols
python call_tracer.py myapp.exe -n malloc -n free -o calls.json

# monitor all functions in a module, excluding system modules
python call_tracer.py 1234 -m myapp --no-system -o trace.json

# monitor everything except system modules
python call_tracer.py -s ./target_binary -M --no-system -t 30

# spawn with arguments (use -- to separate)
python call_tracer.py -s ./target_binary -F 0x401000 -- --input file.txt --verbose
"""

from __future__ import print_function

import argparse
import json
import os
import signal
import sys
import time
import struct
import lzma
import threading
from dataclasses import dataclass, field
from typing import List, Tuple, Dict, Optional, Any, Set
from collections import defaultdict, Counter
from enum import Enum

import frida

# constants
VERSION = "1.0.0"
BINARY_MAGIC = b"CTRC"
BINARY_VERSION = 1
SHUTDOWN_TIMEOUT_SECONDS = 4  # max time to wait for graceful shutdown

# frida javascript agent code
js_agent_code = """
"use strict";

//=============================================================================
// CONFIGURATION AND GLOBALS
//=============================================================================

// configuration passed from python
const config = JSON.parse('CONFIG_JSON_PLACEHOLDER');
const monitoredFunctions = config.functions || [];
const targetModules = config.modules || [];
const monitorAll = config.monitorAll || false;
const excludeSystem = config.excludeSystem || false;
const verbose = config.verbose || false;
const extraVerbose = config.extraVerbose || false;

// state management
const threadState = new Map();           // per-thread state tracking
const functionContextStack = new Map(); // function call stack per thread
const activeStalkers = new Set();       // active stalker thread IDs

// data collection
let totalCalls = 0;
const functionStats = new Map();        // func_addr -> { calls: number, threads: Set }
const callBuffer = [];
const MAX_BUFFER_SIZE = config.bufferSize || 1;
const FLUSH_THRESHOLD = 25;             // flush when buffer reaches this size
const FLUSH_INTERVAL_MS = 1000;         // flush every N milliseconds

//=============================================================================
// UTILITY FUNCTIONS
//=============================================================================

// periodic buffer flush
function flushBuffer() {
    try {
        if (callBuffer.length > 0) {
            const dataToSend = callBuffer.splice(0);
            if (extraVerbose) console.log(`Flushing ${dataToSend.length} calls from buffer`);
            send({
                type: 'calls',
                data: dataToSend
            });
        }
    } catch (e) {
        console.error('Error flushing buffer:', e.message);
        // Clear buffer on error to prevent memory buildup
        callBuffer.length = 0;
    }
}

// force flush buffer if it's getting too large to prevent memory issues
function forceFlushIfNeeded() {
    if (callBuffer.length >= MAX_BUFFER_SIZE) {
        // console.warn(`Buffer full: flushing ${callBuffer.length} calls`);
        if (extraVerbose) console.log(`Buffer full: flushing ${callBuffer.length} calls`);
        try {
            const dataToSend = callBuffer.splice(0);
            send({
                type: 'calls',
                data: dataToSend
            });
        } catch (e) {
            console.error('Error in force flush:', e.message);
            callBuffer.length = 0; // Clear to prevent memory buildup
        }
    }
}

// flush buffer at regular intervals
setInterval(flushBuffer, FLUSH_INTERVAL_MS);

//=============================================================================
// THREAD AND STATE MANAGEMENT
//=============================================================================

// get or create thread state
function getThreadState(threadId) {
    if (!threadState.has(threadId)) {
        threadState.set(threadId, {
            depths: new Map(),
            stalking: false
        });
    }
    return threadState.get(threadId);
}

// get current function context for thread
function getCurrentFunctionContext(threadId) {
    const stack = functionContextStack.get(threadId);
    if (!stack || stack.length === 0) return null;
    return stack[stack.length - 1]; // top of stack
}

//=============================================================================
// EVENT PROCESSING
//=============================================================================

// process call event from stalker
function processCallEvent(sourceAddr, targetAddr, threadId, callType = 'call') {
    try {
        const funcContext = getCurrentFunctionContext(threadId);
        if (!funcContext) {
            // If no function context, this is a call happening outside our monitored functions
            // We can still record it with a generic context
            const callData = {
                timestamp: Date.now() / 1000.0,
                thread_id: threadId,
                source_addr: sourceAddr.toString(),
                target_addr: targetAddr.toString(),
                function_context: "0x0", // generic context for calls outside monitored functions
                call_type: callType
            };
            
            callBuffer.push(callData);
            totalCalls++;
            
            // check buffer size and flush if needed
            forceFlushIfNeeded();
            if (callBuffer.length >= FLUSH_THRESHOLD) {
                try {
                    const dataToSend = callBuffer.splice(0);
                    send({
                        type: 'calls',
                        data: dataToSend
                    });
                } catch (e) {
                    console.error('Error sending call data:', e.message);
                    callBuffer.length = 0;
                }
            }
            return;
        }
        
        // create call event
        const callData = {
            timestamp: Date.now() / 1000.0,
            thread_id: threadId,
            source_addr: sourceAddr.toString(),
            target_addr: targetAddr.toString(),
            function_context: funcContext,
            call_type: callType
        };
        
        // add to buffer
        callBuffer.push(callData);
        totalCalls++;
        
        // Log individual calls in extra verbose mode
        if (extraVerbose) {
            console.log(`[CALL] ${callData.call_type}: ${callData.source_addr} -> ${callData.target_addr} (ctx: ${callData.function_context}, tid: ${callData.thread_id})`);
        }
        
        // update function statistics
        const stats = functionStats.get(funcContext);
        if (stats) {
            stats.calls++;
            stats.threads.add(threadId);
        }
        
        // check buffer size and flush if needed
        forceFlushIfNeeded();
        if (callBuffer.length >= FLUSH_THRESHOLD) {
            try {
                const dataToSend = callBuffer.splice(0);
                send({
                    type: 'calls',
                    data: dataToSend
                });
            } catch (e) {
                console.error('Error sending call data:', e.message);
                callBuffer.length = 0;
            }
        }
    } catch (e) {
        console.error('Error processing call event:', e.message);
    }
}

// process return event from stalker
function processReturnEvent(sourceAddr, threadId) {
    try {
        const funcContext = getCurrentFunctionContext(threadId);
        if (!funcContext) {
            // If no function context, still record with generic context
            const returnData = {
                timestamp: Date.now() / 1000.0,
                thread_id: threadId,
                source_addr: sourceAddr.toString(),
                target_addr: "0x0",
                function_context: "0x0",
                call_type: 'return'
            };
            
            callBuffer.push(returnData);
            totalCalls++;
            
            forceFlushIfNeeded();
            if (callBuffer.length >= FLUSH_THRESHOLD) {
                try {
                    const dataToSend = callBuffer.splice(0);
                    send({
                        type: 'calls',
                        data: dataToSend
                    });
                } catch (e) {
                    console.error('Error sending return data:', e.message);
                    callBuffer.length = 0;
                }
            }
            return;
        }
        
        // create return event
        const returnData = {
            timestamp: Date.now() / 1000.0,
            thread_id: threadId,
            source_addr: sourceAddr.toString(),
            target_addr: "0x0", // return doesn't have a target
            function_context: funcContext,
            call_type: 'return'
        };
        
        // add to buffer
        callBuffer.push(returnData);
        totalCalls++;
        
        // Log individual returns in extra verbose mode
        if (extraVerbose) {
            console.log(`[RETURN] return from ${returnData.source_addr} (ctx: ${returnData.function_context}, tid: ${returnData.thread_id})`);
        }
        
        // check buffer size and flush if needed
        forceFlushIfNeeded();
        if (callBuffer.length >= FLUSH_THRESHOLD) {
            try {
                const dataToSend = callBuffer.splice(0);
                send({
                    type: 'calls',
                    data: dataToSend
                });
            } catch (e) {
                console.error('Error sending return data:', e.message);
                callBuffer.length = 0;
            }
        }
    } catch (e) {
        console.error('Error processing return event:', e.message);
    }
}

//=============================================================================
// FUNCTION INSTRUMENTATION
//=============================================================================

// function entry handler
function enterMonitoredFunction(funcAddr, threadId) {
    try {
        const state = getThreadState(threadId);
        const depth = state.depths.get(funcAddr) || 0;
        state.depths.set(funcAddr, depth + 1);
        
        // push to context stack
        if (!functionContextStack.has(threadId)) {
            functionContextStack.set(threadId, []);
        }
        functionContextStack.get(threadId).push(funcAddr);
        
        // create function entry event
        const entryEvent = {
            timestamp: Date.now() / 1000.0,
            thread_id: threadId,
            source_addr: "0x0",  // entry point
            target_addr: funcAddr,
            function_context: funcAddr,
            call_type: 'entry'
        };
        
        callBuffer.push(entryEvent);
        totalCalls++;
        
        // Log function entries in extra verbose mode
        if (extraVerbose) {
            console.log(`[ENTRY] Entering function ${funcAddr} on thread ${threadId} (depth: ${depth + 1})`);
        }
        
        // update function statistics
        const stats = functionStats.get(funcAddr);
        if (stats) {
            stats.calls++;
            stats.threads.add(threadId);
        }
        
        // send buffer if getting full or at regular intervals
        if (callBuffer.length >= MAX_BUFFER_SIZE || callBuffer.length >= FLUSH_THRESHOLD) {
            send({
                type: 'calls',
                data: callBuffer.splice(0)
            });
        }
        
        // start stalking if this is the first monitored function entry for this thread
        if (!state.stalking && !activeStalkers.has(threadId)) {
            if (extraVerbose) console.log(`Stalking thread ${threadId}`);
            
            try {
                // Convert thread ID to unsigned integer for Frida
                // On Linux, thread IDs can be negative, but Stalker.follow expects unsigned
                var unsignedThreadId = threadId >>> 0;
                
                Stalker.follow(unsignedThreadId, {
                    events: {
                        call: true,
                        ret: true,
                        exec: false,  // Too noisy for call tracing
                        block: false, // Too noisy for call tracing
                        compile: false // Not needed for call tracing
                    },
                    onReceive: function(events) {
                        try {
                            if (!events || events.byteLength === 0) {
                                return; // Skip empty events
                            }
                            
                            const parsed = Stalker.parse(events, {
                                stringify: false,
                                annotate: false
                            });
                            
                            if (!parsed || parsed.length === 0) {
                                return; // Skip if no parsed events
                            }
                            
                            // process each event - format is [source, target, depth]
                            for (const event of parsed) {
                                try {
                                    if (!event || event.length < 3) {
                                        continue; // Skip malformed events
                                    }
                                    
                                    const sourceAddr = ptr(event[0]);
                                    const targetAddr = ptr(event[1]);
                                    const depth = event[2];
                                    
                                    if (depth >= 0) {
                                        // Positive or zero depth indicates a call
                                        processCallEvent(sourceAddr, targetAddr, threadId, 'call');
                                    } else {
                                        // Negative depth indicates a return
                                        processReturnEvent(sourceAddr, threadId);
                                    }
                                } catch (eventError) {
                                    console.error(`Error processing individual event:`, eventError.message);
                                    // Continue processing other events
                                }
                            }
                        } catch (e) {
                            console.error(`Error in stalker onReceive for thread ${threadId}:`, e.message);
                            // Don't crash the stalker, just log and continue
                        }
                    },
                    onCallSummary: function(summary) {
                        // Optional call summary logging
                    }
                });
                
                state.stalking = true;
                activeStalkers.add(threadId);
            } catch (e) {
                console.error(`Error starting stalker for thread ${threadId}:`, e.message);
            }
        }
    } catch (e) {
        console.error('Error in enterMonitoredFunction:', e.message);
    }
}

// function exit handler
function exitMonitoredFunction(funcAddr, threadId) {
    try {
        const state = getThreadState(threadId);
        const depth = state.depths.get(funcAddr) || 0;
        
        if (depth > 0) {
            // create function exit event
            const exitEvent = {
                timestamp: Date.now() / 1000.0,
                thread_id: threadId,
                source_addr: funcAddr,
                target_addr: "0x0",  // exit point
                function_context: funcAddr,
                call_type: 'exit'
            };
            
            callBuffer.push(exitEvent);
            totalCalls++;
            
            // Log function exits in extra verbose mode
            if (extraVerbose) {
                console.log(`[EXIT] Exiting function ${funcAddr} on thread ${threadId} (depth: ${depth - 1})`);
            }
            
            state.depths.set(funcAddr, depth - 1);
            
            // pop from context stack
            const stack = functionContextStack.get(threadId);
            if (stack && stack.length > 0) {
                const idx = stack.lastIndexOf(funcAddr);
                if (idx !== -1) {
                    stack.splice(idx, 1);
                }
            }
            
            // check buffer size and flush if needed
            forceFlushIfNeeded();
            if (callBuffer.length >= FLUSH_THRESHOLD) {
                try {
                    const dataToSend = callBuffer.splice(0);
                    send({
                        type: 'calls',
                        data: dataToSend
                    });
                } catch (e) {
                    console.error('Error sending exit event data:', e.message);
                    callBuffer.length = 0;
                }
            }
            
            // check if we're exiting all monitored functions in this thread
            if (depth === 1) {
                let stillInMonitoredFunction = false;
                state.depths.forEach((d, addr) => {
                    if (d > 0 && addr !== funcAddr) {
                        stillInMonitoredFunction = true;
                    }
                });
                
                if (!stillInMonitoredFunction) {
                    if (extraVerbose) console.log(`Thread ${threadId} exited all monitored functions`);
                    
                    // Don't stop stalking immediately - let it continue for a bit
                    // to catch any remaining call/ret events
                    setTimeout(() => {
                        if (state.stalking) {
                            if (extraVerbose) console.log(`Stopping stalker for thread ${threadId} (delayed)`);
                            try {
                                // Convert thread ID to unsigned integer for Frida
                                var unsignedThreadId = threadId >>> 0;
                                Stalker.unfollow(unsignedThreadId);
                                state.stalking = false;
                                activeStalkers.delete(threadId);
                                
                                // Check if this was the last active thread
                                if (activeStalkers.size === 0) {
                                    if (extraVerbose) console.log('All threads completed, flushing final data...');
                                    flushBuffer();
                                    cleanup();
                                    
                                    // Signal final completion
                                    send({ type: 'process_complete' });
                                } else {
                                    if (extraVerbose) console.log(`Thread ${threadId} completed, ${activeStalkers.size} threads still active`);
                                }
                            } catch (e) {
                                console.error(`Error stopping stalker for thread ${threadId}:`, e.message);
                            }
                        }
                    }, 100); // Small delay to capture remaining events
                }
            }
        }
    } catch (e) {
        console.error('Error in exitMonitoredFunction:', e.message);
    }
}

//=============================================================================
// FUNCTION DISCOVERY AND HOOKING
//=============================================================================

// setup function hooks
function setupFunctionHooks() {
    const resolved = [];
    const failed = [];
    
    monitoredFunctions.forEach(func => {
        try {
            const addr = ptr(func.address);
            
            // verify the address is readable
            addr.readU8();
            
            Interceptor.attach(addr, {
                onEnter: function(args) {
                    const threadId = Process.getCurrentThreadId();
                    enterMonitoredFunction(func.address, threadId);
                },
                onLeave: function(retval) {
                    const threadId = Process.getCurrentThreadId();
                    exitMonitoredFunction(func.address, threadId);
                }
            });
            
            resolved.push(func);
            const moduleInfo = func.module ? ` in ${func.module}` : '';
            if (verbose) console.log(`Hooked ${func.address} (${func.name || 'unnamed'})${moduleInfo}`);
            
            // Log call details in extra verbose mode
            if (extraVerbose) {
                console.log(`Hook details: address=${func.address}, name=${func.name || 'unnamed'}, module=${func.module || 'unknown'}`);
            }
            
        } catch (e) {
            console.error(`Failed to hook ${func.address}: ${e.message}`);
            failed.push(func);
        }
    });
    
    send({
        type: 'hook_status',
        resolved: resolved,
        failed: failed
    });
}

// resolve module+offset to addresses
function resolveModuleOffsets(moduleOffsets) {
    const resolved = [];
    
    moduleOffsets.forEach(entry => {
        const moduleName = entry.module;
        const offset = parseInt(entry.offset, 16);
        let found = false;
        
        // find module by name
        Process.enumerateModules().forEach(module => {
            if (found) return;
            
            // Match by exact name or basename
            const moduleBaseName = module.name.split('/').pop().split('\\\\').pop();
            if (module.name === moduleName || moduleBaseName === moduleName) {
                const baseAddr = module.base;
                const targetAddr = baseAddr.add(offset);
                
                resolved.push({
                    address: targetAddr.toString(),
                    name: `${moduleName}+${entry.offset}`,
                    module: module.name,
                    offset: entry.offset
                });
                found = true;
                if (extraVerbose) console.log(`Resolved ${moduleName}+${entry.offset} to ${targetAddr} (base: ${baseAddr})`);
            }
        });
        
        if (!found) {
            console.warn(`Could not resolve module: ${moduleName}`);
        }
    });
    
    return resolved;
}

// resolve function names to addresses
function resolveFunctionNames(names) {
    const resolved = [];
    
    names.forEach(name => {
        let found = false;
        
        // try module exports
        Process.enumerateModules().forEach(module => {
            if (found) return;
            
            module.enumerateExports().forEach(exp => {
                if (exp.name === name) {
                    resolved.push({
                        address: exp.address.toString(),
                        name: exp.name,
                        module: module.name
                    });
                    found = true;
                }
            });
        });
        
        if (!found) {
            console.warn(`Could not resolve function: ${name}`);
        }
    });
    
    return resolved;
}

// expand address ranges
function expandAddressRanges(ranges) {
    const functions = [];
    
    ranges.forEach(range => {
        const [start, end] = range.split(':').map(a => parseInt(a, 16));
        
        // for now, just hook the start address
        functions.push({
            address: '0x' + start.toString(16),
            name: `range_${start.toString(16)}_${end.toString(16)}`
        });
    });
    
    return functions;
}

// check if a module is a system module
function isSystemModule(moduleName, modulePath) {
    const name = moduleName.toLowerCase();
    const path = modulePath ? modulePath.toLowerCase() : '';
    
    // Cross-platform system module patterns
    const systemPatterns = [
        // macOS system modules
        /^lib(system|c|objc|dispatch|foundation|corefoundation|security)/,
        /^(dyld|libdyld)/,
        /\\.framework\\//,
        /^\\/system\\//,
        /^\\/usr\\/lib\\//,
        
        // Linux system modules
        /^lib(c|pthread|dl|m|rt|resolv|nsl|util|crypt)\\.so/,
        /^ld-linux/,
        /^\\/lib\\//,
        /^\\/usr\\/lib\\//,
        /^linux-vdso/,
        
        // Windows system modules  
        /^(ntdll|kernel32|user32|advapi32|ole32|oleaut32|shell32|gdi32|winmm|ws2_32|crypt32|rpcrt4|comctl32|comdlg32|version|shlwapi)\\.dll$/,
        /^msvcrt/,
        /^ucrtbase/,
        /^vcruntime/,
        /^api-ms-/,
        /^ext-ms-/,
        
        // Common patterns
        /^libc\\+\\+/,
        /^libstdc\\+\\+/,
        /^libgcc/
    ];
    
    return systemPatterns.some(pattern => 
        pattern.test(name) || (path && pattern.test(path))
    );
}

// discover functions in specified modules
function discoverModuleFunctions(moduleNames) {
    const functions = [];
    
    Process.enumerateModules().forEach(module => {
        // Skip system modules if excludeSystem is enabled
        if (excludeSystem && isSystemModule(module.name, module.path)) {
            return;
        }
        
        if (moduleNames.length === 0 || moduleNames.includes(module.name)) {
            if (extraVerbose) console.log(`Discovering functions in module: ${module.name}`);
            
            // enumerate exports
            module.enumerateExports().forEach(exp => {
                if (exp.type === 'function') {
                    functions.push({
                        address: exp.address.toString(),
                        name: exp.name,
                        module: module.name
                    });
                }
            });
        }
    });
    
    const moduleDesc = moduleNames.length > 0 ? moduleNames.join(', ') : 'all modules';
    const systemDesc = excludeSystem ? ' (excluding system modules)' : '';
    if (verbose) console.log(`Discovered ${functions.length} functions in ${moduleDesc}${systemDesc}`);
    return functions;
}

// discover all functions in all modules (for monitor-all mode)
function discoverAllFunctions() {
    const functions = [];
    
    Process.enumerateModules().forEach(module => {
        // Skip system modules if excludeSystem is enabled
        if (excludeSystem && isSystemModule(module.name, module.path)) {
            if (extraVerbose) console.log(`Skipping system module: ${module.name}`);
            return;
        }
        
        if (extraVerbose) console.log(`Discovering all functions in module: ${module.name}`);
        
        // enumerate exports
        module.enumerateExports().forEach(exp => {
            if (exp.type === 'function') {
                functions.push({
                    address: exp.address.toString(),
                    name: exp.name,
                    module: module.name
                });
            }
        });
    });
    
    const systemDesc = excludeSystem ? ' (excluding system modules)' : '';
    if (verbose) console.log(`Discovered ${functions.length} total functions in all modules${systemDesc}`);
    return functions;
}

//=============================================================================
// CLEANUP AND SHUTDOWN
//=============================================================================

// send final data on cleanup
function cleanup() {
    if (extraVerbose) console.log(`Final cleanup: buffer has ${callBuffer.length} calls, total calls: ${totalCalls}`);
    
    // send any remaining calls
    if (callBuffer.length > 0) {
        send({
            type: 'calls',
            data: callBuffer.splice(0)  // clear the buffer
        });
    }
    
    // send final statistics
    const stats = {};
    functionStats.forEach((stat, addr) => {
        stats[addr] = {
            calls: stat.calls,
            threads: stat.threads.size
        };
    });
    
    send({
        type: 'statistics',
        total_calls: totalCalls,
        function_stats: stats
    });
    
    // ensure completion signal is sent
    if (extraVerbose) console.log('Sending process complete signal...');
    send({ type: 'process_complete' });
}

//=============================================================================
// INITIALIZATION AND SETUP
//=============================================================================

// handle different monitoring modes
if (monitorAll) {
    // monitor all functions in all modules
    const allFunctions = discoverAllFunctions();
    allFunctions.forEach(f => monitoredFunctions.push(f));
} else if (targetModules.length > 0) {
    // monitor functions in specific modules
    const moduleFunctions = discoverModuleFunctions(targetModules);
    moduleFunctions.forEach(f => monitoredFunctions.push(f));
}

// process address ranges if any
const ranges = monitoredFunctions.filter(f => f.range).map(f => f.range);
if (ranges.length > 0) {
    const rangeFunctions = expandAddressRanges(ranges);
    rangeFunctions.forEach(f => monitoredFunctions.push(f));
}

// process module+offset entries if any
const moduleOffsets = monitoredFunctions.filter(f => f.module && f.offset);
if (moduleOffsets.length > 0) {
    const resolved = resolveModuleOffsets(moduleOffsets);
    resolved.forEach(r => monitoredFunctions.push(r));
}

// process function names if any
const namesToResolve = monitoredFunctions.filter(f => f.name && !f.address && !f.module).map(f => f.name);
if (namesToResolve.length > 0) {
    const resolved = resolveFunctionNames(namesToResolve);
    resolved.forEach(r => monitoredFunctions.push(r));
}

// filter out functions without addresses
const validFunctions = monitoredFunctions.filter(f => f.address);

// update monitored functions list
monitoredFunctions.length = 0;
validFunctions.forEach(f => monitoredFunctions.push(f));

// initialize function statistics for all monitored functions
monitoredFunctions.forEach(func => {
    functionStats.set(func.address, { calls: 0, threads: new Set() });
});

// setup hooks
if (monitoredFunctions.length > 0) {
    setupFunctionHooks();
} else {
    send({
        type: 'error',
        message: 'No valid functions to monitor'
    });
}

//=============================================================================
// MESSAGE HANDLING AND LIFECYCLE
//=============================================================================

// register cleanup
Script.bindWeak(globalThis, cleanup);

// handle messages from python
recv(function(message) {
    if (message.type === 'shutdown') {
        if (extraVerbose) console.log('Received shutdown request, stopping all stalkers...');
        
        // Stop all active stalkers
        activeStalkers.forEach(threadId => {
            try {
                if (extraVerbose) console.log(`Force stopping stalker for thread ${threadId}`);
                var unsignedThreadId = threadId >>> 0;
                Stalker.unfollow(unsignedThreadId);
            } catch (e) {
                console.error(`Error stopping stalker for thread ${threadId}:`, e.message);
            }
        });
        activeStalkers.clear();
        
        // Flush all remaining data
        flushBuffer();
        cleanup();
        send({ type: 'shutdown_complete' });
    }
});

// collect module information early for RE analysis
const moduleInfo = [];
Process.enumerateModules().forEach(module => {
    moduleInfo.push({
        name: module.name,
        base: module.base.toString(),
        size: module.size,
        path: module.path
    });
});

// send module information 
send({
    type: 'modules',
    data: moduleInfo
});

// send ready signal
send({ type: 'ready' });
"""


# ==============================================================================
# DATA STRUCTURES
# ==============================================================================


@dataclass
class CallEvent:
    """Represents a single call/return event"""

    timestamp: float
    thread_id: int
    source_addr: int
    target_addr: int
    function_context: int
    call_type: str


@dataclass
class FunctionContext:
    """Tracks statistics for a monitored function"""

    address: int
    name: Optional[str]
    module: Optional[str] = None
    total_calls: int = 0
    unique_threads: Set[int] = field(default_factory=set)
    unique_targets: Set[int] = field(default_factory=set)


@dataclass
class CallSummary:
    """Summary statistics for a tracing session"""

    total_calls: int
    unique_threads: int
    duration: float
    calls_per_second: float
    functions: List[Dict[str, Any]]
    top_targets: List[Tuple[str, int]]
    thread_distribution: Dict[int, int]


# ==============================================================================
# MAIN TRACER CLASS
# ==============================================================================


class CallTracer:
    """Main call tracer implementation using Frida"""

    def __init__(self, args):
        self.args = args
        self.start_time = time.time()
        self.end_time = None
        self.running = False
        self.script = None
        self.session = None
        self.device = None
        self.pid = None

        # data storage
        self.call_events = []
        self.function_contexts = {}  # addr -> FunctionContext
        self.monitored_functions = []
        self.shutdown_complete = False
        self.modules = []  # module information for RE analysis

        # prepare monitored functions
        self._prepare_monitored_functions()

    # --------------------------------------------------------------------------
    # Setup and Configuration
    # --------------------------------------------------------------------------

    def _prepare_monitored_functions(self):
        """Prepare the list of functions to monitor"""
        functions = []

        # add functions by address or module+offset
        for addr in self.args.hook_func or []:
            try:
                # Check for module+offset format (e.g., "mymodule+1234" or "mymodule+0x1234")
                if "+" in addr:
                    module_name, offset_str = addr.split("+", 1)
                    # Parse offset as hex (strip 0x prefix if present)
                    offset_clean = (
                        offset_str[2:]
                        if offset_str.startswith(("0x", "0X"))
                        else offset_str
                    )
                    offset = int(offset_clean, 16)
                    functions.append(
                        {
                            "module": module_name.strip(),
                            "offset": hex(offset),
                            "name": f"{module_name}+{hex(offset)}",
                        }
                    )
                else:
                    # Handle regular address format - always treat as hex
                    if addr.startswith(("0x", "0X")):
                        addr_int = int(addr, 16)
                    else:
                        # Always treat as hex, even without 0x prefix
                        addr_int = int(addr, 16)
                    func_ctx = FunctionContext(address=addr_int, name=None)
                    self.function_contexts[addr] = func_ctx
                    functions.append({"address": addr, "name": None})
            except ValueError:
                print(
                    f"[-] Invalid address/module+offset format: {addr}. "
                    f"Use hex (0x1234 or 1234) or module+offset (mymodule+0x1234)."
                )
                sys.exit(1)

        # add functions by name
        for name in self.args.hook_name or []:
            functions.append({"address": None, "name": name})

        # add address ranges
        for range_str in self.args.hook_range or []:
            if ":" not in range_str:
                print(f"[-] Invalid range format: {range_str}. Use START:END format.")
                sys.exit(1)
            try:
                start_str, end_str = range_str.split(":", 1)
                # Validate that both parts are valid addresses
                start_addr = (
                    int(start_str, 16)
                    if start_str.startswith("0x")
                    else int(start_str, 16)
                )
                end_addr = (
                    int(end_str, 16) if end_str.startswith("0x") else int(end_str, 16)
                )
                if start_addr >= end_addr:
                    print(
                        f"[-] Invalid range: start address must be less than end address"
                    )
                    sys.exit(1)
                functions.append({"range": range_str})
            except ValueError:
                print(
                    f"[-] Invalid range format: {range_str}. Use hex addresses like 0x1000:0x2000"
                )
                sys.exit(1)

        self.monitored_functions = functions

    def _resolve_address_to_module_offset(self, address):
        """Resolve an address to module+offset format"""
        if not self.modules:
            # handle both int and string addresses
            if isinstance(address, str):
                return address if address.startswith("0x") else f"0x{address}"
            return hex(address)  # fallback to hex if no modules

        # handle different address formats
        if isinstance(address, str):
            if address.startswith("0x"):
                addr_int = int(address, 16)
            elif address.isdigit():
                addr_int = int(address)
            else:
                try:
                    addr_int = int(address, 16)
                except ValueError:
                    return address  # return as-is if can't parse
        else:
            addr_int = address

        # Find the module containing this address
        for module in self.modules:
            base_addr = int(module["base"], 16)
            module_size = module["size"]

            if base_addr <= addr_int < (base_addr + module_size):
                offset = addr_int - base_addr
                return f"{module['name']}+{hex(offset)}"

        # If no module found, return hex address
        return hex(addr_int)

    def start_tracing(self):
        """Start the tracing session"""
        try:
            # setup device
            self.device = self._get_device()

            # attach or spawn
            if self.args.spawn:
                if not os.path.exists(self.args.target):
                    raise FileNotFoundError(
                        f"Target binary not found: {self.args.target}"
                    )

                # prepare spawn options
                spawn_options = {}
                if self.args.disable_aslr:
                    # disable aslr using frida
                    spawn_options["aslr"] = "disable"
                    # on macos, try DYLD_DISABLE_ASLR
                    if sys.platform == "darwin":
                        spawn_options["env"] = {
                            "DYLD_DISABLE_ASLR": "1",
                        }
                    print("[*] Attempting to disable ASLR for the target process")

                # Build command line with target and arguments
                cmd_line = [self.args.target] + self.args.target_args
                if self.args.target_args:
                    print(f"[*] Spawning with arguments: {' '.join(cmd_line)}")
                self.pid = self.device.spawn(cmd_line, **spawn_options)
                self.session = self.device.attach(self.pid)
                print(f"[+] Spawned process with PID: {self.pid}")
            else:
                # attach to existing process
                target = self.args.target

                # try to parse as PID first
                try:
                    self.pid = int(target)
                    print(f"[*] Attaching to PID: {self.pid}")
                    self.session = self.device.attach(self.pid)
                    print(f"[+] Attached to PID: {self.pid}")
                except ValueError:
                    # treat as process name
                    print(f"[*] Looking for process: {target}")
                    try:
                        process = self.device.get_process(target)
                        self.pid = process.pid
                        print(f"[*] Found process '{target}' with PID: {self.pid}")
                        self.session = self.device.attach(self.pid)
                        print(f"[+] Attached to process")
                    except frida.ProcessNotFoundError:
                        # fallback to enumeration
                        print(
                            f"[*] Process '{target}' not found by direct lookup, searching..."
                        )
                        try:
                            processes = self.device.enumerate_processes()
                            matches = [
                                p
                                for p in processes
                                if target.lower() in p.name.lower()
                                or str(p.pid) == target
                            ]

                            if not matches:
                                available_processes = [
                                    f"{p.pid}: {p.name}" for p in processes[:10]
                                ]
                                available_str = "\n".join(available_processes)
                                if len(processes) > 10:
                                    available_str += f"\n... and {len(processes) - 10} more processes"

                                raise RuntimeError(
                                    f"Process '{target}' not found.\n"
                                    f"Available processes (showing first 10):\n{available_str}\n\n"
                                    f"Use a valid PID or process name."
                                )
                            elif len(matches) > 1:
                                print(f"[!] Multiple processes match '{target}':")
                                for p in matches:
                                    print(f"    PID: {p.pid}, Name: {p.name}")
                                self.pid = matches[0].pid
                                print(f"[*] Using first match: PID {self.pid}")
                            else:
                                self.pid = matches[0].pid
                                print(
                                    f"[*] Found process: PID {self.pid}, Name: {matches[0].name}"
                                )

                            self.session = self.device.attach(self.pid)
                            print(f"[+] Attached to process")

                        except Exception as e:
                            raise RuntimeError(
                                f"Failed to enumerate or attach to processes: {e}"
                            )
                except frida.ProcessNotFoundError:
                    raise RuntimeError(
                        f"Process with PID {self.pid} not found or access denied"
                    )
                except Exception as e:
                    raise RuntimeError(f"Failed to attach to process: {e}")

            # validate we have something to monitor
            if (
                not self.monitored_functions
                and not self.args.module
                and not self.args.monitor_all
            ):
                raise ValueError(
                    "No functions, modules, or monitor-all specified. "
                    "Use -F/--hook-func, -n/--hook-name, -m/--module, or -M/--monitor-all"
                )

            # prepare configuration for JS agent
            config = {
                "functions": self.monitored_functions,
                "modules": self.args.module or [],
                "monitorAll": self.args.monitor_all,
                "excludeSystem": self.args.no_system,
                "verbose": self.args.verbose >= 1,
                "extraVerbose": self.args.verbose >= 2,
                "bufferSize": self.args.buffer_size,
            }

            # inject script with properly escaped JSON
            try:
                # properly escape JSON for JavaScript string literal
                config_json = json.dumps(config)
                # escape single quotes and backslashes for JavaScript string literal
                config_json_escaped = config_json.replace("\\", "\\\\").replace(
                    "'", "\\'"
                )
                script_code = js_agent_code.replace(
                    "CONFIG_JSON_PLACEHOLDER", config_json_escaped
                )

                self.script = self.session.create_script(script_code)
                self.script.on("message", self._on_message)
                self.script.load()

            except frida.InvalidArgumentError as e:
                raise RuntimeError(f"Invalid JavaScript agent code: {e}")
            except Exception as e:
                raise RuntimeError(
                    f"Failed to inject JavaScript agent: {e}. Check target process compatibility."
                )

            # resume if spawned
            if self.args.spawn:
                self.device.resume(self.pid)
                print("[+] Process resumed")

            self.running = True

            # start timeout if specified
            if self.args.timeout:
                timer = threading.Timer(self.args.timeout, self._timeout_handler)
                timer.daemon = True
                timer.start()

        except Exception as e:
            # Cleanup on failure
            if hasattr(self, "session") and self.session:
                try:
                    self.session.detach()
                except:
                    pass
            raise e

    def _get_device(self):
        """Get the Frida device"""
        try:
            if self.args.host:
                manager = frida.get_device_manager()
                device = manager.add_remote_device(self.args.host)
                print(f"[*] Using remote device: {self.args.host}")
            else:
                device = frida.get_device(self.args.device)
                print(f"[*] Using device: {device.id}")
            return device
        except Exception as e:
            raise RuntimeError(f"Failed to get Frida device: {e}")

    # --------------------------------------------------------------------------
    # Message Handling
    # --------------------------------------------------------------------------

    def _on_message(self, message, data):
        """Handle messages from the JS agent"""
        try:
            if not message or not isinstance(message, dict):
                print(f"[!] Invalid message format: {message}")
                return

            if message["type"] == "error":
                print(f"[!] Script error: {message}")
                return

            if message["type"] == "send":
                payload = message.get("payload", {})
                if not isinstance(payload, dict):
                    print(f"[!] Invalid payload format: {payload}")
                    return

                msg_type = payload.get("type")

            if msg_type == "ready":
                print("[+] Agent ready and monitoring")

            elif msg_type == "modules":
                # store module information for RE analysis
                self.modules = payload.get("data", [])
                print(f"[*] Collected information for {len(self.modules)} modules")

            elif msg_type == "hook_status":
                resolved = payload.get("resolved", [])
                failed = payload.get("failed", [])

                # update function contexts
                for func in resolved:
                    addr = func["address"]
                    if addr not in self.function_contexts:
                        func_ctx = FunctionContext(
                            address=int(addr, 16) if isinstance(addr, str) else addr,
                            name=func.get("name"),
                            module=func.get("module"),
                        )
                        self.function_contexts[addr] = func_ctx

                        if self.args.verbose >= 2:
                            print(
                                f"[DEBUG] Registered function context: {addr} ({func.get('name', 'unnamed')})"
                            )

                if failed:
                    print(f"[!] Failed to hook {len(failed)} functions")
                    if self.args.verbose >= 2:
                        for func in failed:
                            print(
                                f"[DEBUG] Failed to hook: {func.get('address', 'unknown')} ({func.get('name', 'unnamed')})"
                            )

            elif msg_type == "calls":
                # process batch of calls
                calls = payload.get("data", [])
                if self.args.verbose >= 2:
                    print(f"[DEBUG] Processing {len(calls)} call events")
                for call_data in calls:
                    try:
                        event = CallEvent(
                            timestamp=call_data["timestamp"],
                            thread_id=call_data["thread_id"],
                            source_addr=int(call_data["source_addr"], 16),
                            target_addr=int(call_data["target_addr"], 16),
                            function_context=int(call_data["function_context"], 16),
                            call_type=call_data["call_type"],
                        )
                        self.call_events.append(event)

                        # update function stats
                        func_addr = call_data["function_context"]
                        if func_addr in self.function_contexts:
                            ctx = self.function_contexts[func_addr]
                            ctx.total_calls += 1
                            ctx.unique_threads.add(event.thread_id)
                            ctx.unique_targets.add(event.target_addr)

                            if self.args.verbose >= 3:
                                print(
                                    f"[TRACE] Call: {event.call_type} from {hex(event.source_addr)} to {hex(event.target_addr)} (ctx: {func_addr})"
                                )

                    except (KeyError, ValueError) as e:
                        if self.args.verbose >= 1:
                            print(f"[-] Error processing call: {e}")
                        if self.args.verbose >= 2:
                            print(f"[-] Call data: {call_data}")

            elif msg_type == "statistics":
                # final statistics
                self.final_stats = payload

            elif msg_type == "shutdown_complete":
                # script has finished cleanup, now we can safely unload
                print("[*] Received shutdown complete signal")
                self.shutdown_complete = True
                self._force_cleanup()

            elif msg_type == "process_complete":
                # target process has finished and data is flushed
                print("[*] Target process completed, all data collected")
                if self.args.verbose >= 2:
                    print(f"[DEBUG] Setting shutdown_complete=True, running=False")
                self.shutdown_complete = True
                self.running = False  # Stop the main loop

            elif msg_type == "error":
                print(f"[!] Error: {payload.get('message', 'Unknown error')}")

        except KeyError as e:
            print(f"[!] Missing required field in message: {e}")
        except Exception as e:
            print(f"[!] Error processing message: {e}")
            if self.args.verbose >= 1:
                import traceback

                traceback.print_exc()

    def _timeout_handler(self):
        """Handle timeout"""
        print(f"\n[!] Timeout reached ({self.args.timeout}s)")
        self.stop_tracing()

    def stop_tracing(self):
        """Stop tracing and cleanup"""
        if not self.running:
            return  # Already stopped

        print("[*] Stopping tracing...")
        self.running = False
        self.end_time = time.time()

        if self.script:
            try:
                # Send shutdown signal
                print("[*] Sending shutdown signal to script...")
                self.script.post({"type": "shutdown"})
            except Exception as e:
                print(f"[-] Warning: Error sending shutdown signal: {e}")
                self._force_cleanup()

    def _force_cleanup(self):
        """Force cleanup when normal shutdown fails"""
        if self.script:
            try:
                self.script.unload()
            except Exception as e:
                if self.args.verbose >= 1:
                    print(f"[-] Warning: Error unloading script: {e}")

        if self.session:
            try:
                self.session.detach()
            except Exception as e:
                if self.args.verbose >= 1:
                    print(f"[-] Warning: Error detaching session: {e}")

        print("[*] Tracing stopped.")

    # --------------------------------------------------------------------------
    # Data Analysis and Export
    # --------------------------------------------------------------------------

    def get_summary(self) -> CallSummary:
        """Generate a summary of the trace data"""
        duration = (self.end_time or time.time()) - self.start_time
        total_calls = len(self.call_events)

        # count unique threads
        unique_threads = set(e.thread_id for e in self.call_events)

        # count calls per target
        target_counts = Counter(hex(e.target_addr) for e in self.call_events)

        # count calls per thread
        thread_counts = Counter(e.thread_id for e in self.call_events)

        # prepare function summaries
        function_summaries = []
        for addr, ctx in self.function_contexts.items():
            function_summaries.append(
                {
                    "address": hex(ctx.address),
                    "name": ctx.name or "unnamed",
                    "calls": ctx.total_calls,
                    "threads": len(ctx.unique_threads),
                    "unique_targets": len(ctx.unique_targets),
                }
            )

        # sort functions by call count
        function_summaries.sort(key=lambda x: x["calls"], reverse=True)

        return CallSummary(
            total_calls=total_calls,
            unique_threads=len(unique_threads),
            duration=duration,
            calls_per_second=total_calls / duration if duration > 0 else 0,
            functions=function_summaries,
            top_targets=target_counts.most_common(10),
            thread_distribution=dict(thread_counts),
        )

    def print_summary(self):
        """Print a neat summary to stdout"""
        summary = self.get_summary()

        print("\n" + "=" * 60)
        print("                    CALL TRACE SUMMARY")
        print("=" * 60)

        print(f"\nTotal Calls:      {summary.total_calls:,}")
        print(f"Unique Threads:   {summary.unique_threads}")
        print(f"Duration:         {summary.duration:.2f}s")
        print(f"Calls/Second:     {summary.calls_per_second:.1f}")

        # Call type breakdown
        call_types = {}
        for event in self.call_events:
            call_types[event.call_type] = call_types.get(event.call_type, 0) + 1

        if call_types:
            print(f"\nCall Types:")
            print("-" * 70)
            for call_type, count in sorted(call_types.items()):
                print(f"{call_type:<12}: {count:>8,}")

        if summary.functions:
            print(f"\nMonitored Functions ({len(summary.functions)}):")
            print("-" * 70)
            print(
                f"{'Module+Offset':<36} {'Name':<36} {'Calls':>16} {'Threads':>8} {'Targets':>8}"
            )
            print("-" * 70)
            for func in summary.functions:
                name = func["name"][:20]
                # Convert address to module+offset for display
                module_offset = self._resolve_address_to_module_offset(func["address"])
                print(
                    f"{module_offset:<36} {name:<36} {func['calls']:>16,} "
                    f"{func['threads']:>8} {func['unique_targets']:>8}"
                )

        if summary.top_targets:
            print(f"\nTop Call Targets:")
            print("-" * 70)
            print(f"{'Module+Offset':<36} {'Count':>16}")
            print("-" * 70)
            for addr, count in summary.top_targets:
                # Convert hex address to module+offset for display
                module_offset = self._resolve_address_to_module_offset(addr)
                print(f"{module_offset:<36} {count:>16,}")

        if len(summary.thread_distribution) > 1:
            print(f"\nThread Distribution:")
            print("-" * 70)
            sorted_threads = sorted(
                summary.thread_distribution.items(), key=lambda x: x[1], reverse=True
            )
            for tid, count in sorted_threads[:5]:
                pct = (count / summary.total_calls) * 100
                print(f"Thread {tid:<8}: {count:>8,} calls ({pct:>5.1f}%)")
            if len(sorted_threads) > 5:
                print(f"... and {len(sorted_threads) - 5} more threads")

        print("\n" + "=" * 70)

    def export_results(self):
        """Export results to file"""
        try:
            output_file = self.args.output
            if not output_file:
                raise ValueError("No output file specified")

            # Validate output directory exists
            output_dir = os.path.dirname(os.path.abspath(output_file))
            if not os.path.exists(output_dir):
                os.makedirs(output_dir, exist_ok=True)
                print(f"[*] Created output directory: {output_dir}")

            # handle compression
            if self.args.compress:
                if not output_file.endswith(".xz"):
                    output_file += ".xz"

            # export based on format
            if self.args.format == "json":
                self._export_json(output_file)
            else:
                raise ValueError(f"Unsupported export format: {self.args.format}")

            if os.path.exists(output_file):
                file_size = os.path.getsize(output_file)
                print(f"[+] Results saved to: {output_file} ({file_size:,} bytes)")
            else:
                print(f"[!] Warning: Output file was not created: {output_file}")

        except Exception as e:
            print(f"[!] Error exporting results: {e}")
            if self.args.verbose >= 1:
                import traceback

                traceback.print_exc()
            raise

    def _export_json(self, filepath):
        """Export to JSON format"""
        try:
            summary = self.get_summary()

            data = {
                "metadata": {
                    "version": VERSION,
                    "target": self.args.target,
                    "start_time": self.start_time,
                    "end_time": self.end_time,
                    "duration": summary.duration,
                    "total_calls": summary.total_calls,
                    "unique_threads": summary.unique_threads,
                    "calls_per_second": summary.calls_per_second,
                    "functions": summary.functions,
                },
                "modules": self.modules,
                "calls": [
                    {
                        "timestamp": e.timestamp,
                        "thread_id": e.thread_id,
                        "source_addr": hex(e.source_addr) if e.source_addr else "0x0",
                        "source_module_offset": (
                            self._resolve_address_to_module_offset(e.source_addr)
                            if e.source_addr
                            else "0x0"
                        ),
                        "target_addr": hex(e.target_addr) if e.target_addr else "0x0",
                        "target_module_offset": (
                            self._resolve_address_to_module_offset(e.target_addr)
                            if e.target_addr
                            else "0x0"
                        ),
                        "function_context": (
                            hex(e.function_context) if e.function_context else "0x0"
                        ),
                        "function_context_module_offset": (
                            self._resolve_address_to_module_offset(e.function_context)
                            if e.function_context
                            else "0x0"
                        ),
                        "call_type": e.call_type or "unknown",
                    }
                    for e in self.call_events
                ],
            }

            if self.args.compress:
                with lzma.open(filepath, "wt", encoding="utf-8") as f:
                    json.dump(data, f, indent=2)
            else:
                with open(filepath, "w", encoding="utf-8") as f:
                    json.dump(data, f, indent=2)

        except (IOError, OSError) as e:
            raise RuntimeError(f"Failed to write JSON file: {e}")
        except Exception as e:
            raise RuntimeError(f"Error creating JSON data: {e}")


# ==============================================================================
# SIGNAL HANDLING AND MAIN FUNCTION
# ==============================================================================


def signal_handler(signum, frame):
    """Handle signals for graceful shutdown"""
    print(f"\n[!] Received signal {signum}, shutting down gracefully...")
    if hasattr(signal_handler, "tracer"):
        signal_handler.tracer.stop_tracing()
        # Don't exit here - let the main loop handle cleanup gracefully


def main():
    parser = argparse.ArgumentParser(
        description="Frida-based call tracer for monitoring function calls",
        formatter_class=argparse.RawTextHelpFormatter,
    )

    # target
    parser.add_argument("target", help="Process ID, process name, or executable path")

    # function selection
    parser.add_argument(
        "-F",
        "--hook-func",
        action="append",
        help="Function address or module+offset to monitor (can be repeated).\n"
        "Examples: 0x401000, 401000, mymodule+0x1234, mymodule+1234",
    )
    parser.add_argument(
        "-n",
        "--hook-name",
        action="append",
        help="Function name to monitor (can be repeated)",
    )
    parser.add_argument(
        "-r",
        "--hook-range",
        action="append",
        help="Address range to monitor (format: START:END)",
    )
    parser.add_argument(
        "-m",
        "--module",
        action="append",
        help="Module to monitor (can be repeated)",
    )
    parser.add_argument(
        "-M",
        "--monitor-all",
        action="store_true",
        help="Monitor all functions in all modules (explicit flag required)",
    )
    parser.add_argument(
        "--no-system",
        action="store_true",
        help="Exclude system modules from monitoring",
    )

    # output options
    parser.add_argument(
        "-o",
        "--output",
        help="Output file path (if not specified, prints summary to stdout)",
    )
    parser.add_argument(
        "-f",
        "--format",
        choices=["json"],
        default="json",
        help="Output format",
    )
    parser.add_argument(
        "--compress", action="store_true", help="Compress output file with XZ/LZMA"
    )

    # control options
    parser.add_argument(
        "-t", "--timeout", type=int, help="Maximum collection time in seconds"
    )
    parser.add_argument(
        "-s",
        "--spawn",
        action="store_true",
        help="Spawn new process instead of attaching",
    )
    parser.add_argument(
        "--disable-aslr",
        action="store_true",
        help="Disable ASLR for spawned process (macOS only, requires code signing)",
    )

    # device options
    parser.add_argument(
        "-D", "--device", default="local", help="Frida device (default: local)"
    )
    parser.add_argument("-H", "--host", help="Connect to remote frida-server")

    # debug options
    parser.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=0,
        help="Verbose output (-v for verbose, -vv for extra verbose)",
    )
    parser.add_argument(
        "--buffer-size",
        type=int,
        default=1000,
        help="JavaScript agent buffer size (default: 1000)",
    )

    # target arguments (after --)
    parser.add_argument(
        "target_args",
        nargs="*",
        help="Arguments to pass to spawned process (use after --)",
    )

    args = parser.parse_args()

    # validate arguments
    if not any(
        [args.hook_func, args.hook_name, args.hook_range, args.module, args.monitor_all]
    ):
        print("[-] Error: At least one function selection option required")
        parser.print_help()
        sys.exit(1)

    # threading is already imported at module level

    # create tracer
    tracer = CallTracer(args)

    # setup signal handlers
    signal_handler.tracer = tracer
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    # start tracing
    try:
        tracer.start_tracing()

        if args.output:
            print("[*] Tracing started. Press Ctrl+C to stop and save.")
        else:
            print("[*] Tracing started. Press Ctrl+C to stop and see summary.")

        # wait for completion
        if args.timeout:
            time.sleep(args.timeout + 0.5)
        else:
            # poll until interrupted or shutdown complete
            while tracer.running:
                try:
                    time.sleep(0.1)
                    if args.verbose >= 2:
                        print(
                            f"[DEBUG] Main loop: running={tracer.running}, shutdown_complete={tracer.shutdown_complete}"
                        )

                    # Check if spawned process has exited
                    if args.spawn and tracer.pid:
                        try:
                            processes = tracer.device.enumerate_processes()
                            process_exists = any(p.pid == tracer.pid for p in processes)
                            if not process_exists:
                                print("[*] Spawned process has exited")
                                tracer.running = False
                                break
                        except Exception as e:
                            if args.verbose >= 2:
                                print(f"[DEBUG] Error checking process existence: {e}")
                            # If we can't enumerate processes, assume it's still running
                            pass

                except KeyboardInterrupt:
                    print(f"\n[!] Interrupted by user")
                    tracer.stop_tracing()
                    break

            print(
                f"[*] Main loop exited: running={tracer.running}, shutdown_complete={tracer.shutdown_complete}"
            )

            # If shutdown was initiated, wait for it to complete
            if not tracer.running and not tracer.shutdown_complete:
                print("[*] Waiting for data collection to complete...")
                # Wait for shutdown to complete
                wait_start = time.time()
                while (
                    not tracer.shutdown_complete
                    and (time.time() - wait_start) < SHUTDOWN_TIMEOUT_SECONDS
                ):
                    time.sleep(0.01)

                if not tracer.shutdown_complete:
                    print("[-] Timeout waiting for shutdown, forcing cleanup...")
                    tracer._force_cleanup()

    except frida.ProcessNotFoundError:
        print(f"[-] Process not found: {args.target}")
        sys.exit(1)
    except frida.PermissionDeniedError:
        print(f"[-] Permission denied. Try with elevated privileges.")
        sys.exit(1)
    except RuntimeError as e:
        print(f"[-] Error: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"[-] Unexpected error: {e}")
        if args.verbose >= 1:
            import traceback

            traceback.print_exc()
        sys.exit(1)
    else:
        # only run this if no exceptions occurred (tracer is properly initialized)
        try:
            tracer.stop_tracing()

            # show results
            tracer.print_summary()

            # export results if requested
            if tracer.call_events:
                if args.output:
                    print(f"[*] Exporting results to {args.output}...")
                    tracer.export_results()
            else:
                print("[!] No calls collected.")
        except Exception as e:
            print(f"[-] Error during cleanup: {e}")
            if args.verbose >= 1:
                import traceback

                traceback.print_exc()


if __name__ == "__main__":
    main()

```

`frida/stalk_drcov.py`:

```py
#!/usr/bin/env python3

"""
stalk_drcov.py
A frida-based basic block tracer that outputs coverage data in the drcov format.

Example usage:

# install frida-tools via uv
uv tool install frida-tools

# run python with uv
uv tool run --from frida-tools python ...

# spawn and trace a binary
python stalk_drcov.py -s /path/to/binary -o coverage.drcov

# attach to existing process by PID
python stalk_drcov.py 1234 -o coverage.drcov

# attach to process by name
python stalk_drcov.py myapp -o coverage.drcov

# trace specific modules only
python stalk_drcov.py 1234 -w main.exe -w helper.dll -o coverage.drcov

# trace all modules excluding system modules
python stalk_drcov.py -s ./target --no-system -o coverage.drcov

# disable ASLR for spawned process (macOS only)
python stalk_drcov.py -s ./target --disable-aslr -o coverage.drcov

# spawn with arguments (use -- to separate)
python stalk_drcov.py -s ./target --no-system -- --input file.txt --verbose

# enable hit count tracking (uses block events)
python stalk_drcov.py -s ./target --hits -o coverage-with-hits.drcov
"""

from __future__ import print_function

import argparse
import json
import os
import signal
import struct
import sys
import time
from typing import List, Dict, Set, Optional

import frida

# constants
VERSION = "1.0.0"
DRCOV_BB_ENTRY_SIZE_BYTES = 8

# javascript agent code for basic block tracing
js_agent_code = """
"use strict";

// configuration passed from python
const config = JSON.parse('CONFIG_JSON_PLACEHOLDER');
const whitelistedModules = config.whitelistedModules || ['all'];
const threadIdList = config.threadIdList || ['all'];
const excludeSystem = config.excludeSystem || false;
const useHitCounting = config.useHitCounting || false;
const verbose = config.verbose || false;

// drcov basic block entries are 8 bytes:
//   uint32_t start_offset; (from module base)
//   uint16_t size;
//   uint16_t mod_id;
const DRCOV_BB_ENTRY_SIZE_BYTES = 8;

// system module detection
function isSystemModule(moduleName, modulePath) {
    const name = moduleName.toLowerCase();
    const path = modulePath ? modulePath.toLowerCase() : '';
    
    // Cross-platform system module patterns
    const systemPatterns = [
        // macOS system modules
        /^lib(system|c|objc|dispatch|foundation|corefoundation|security)/,
        /^(dyld|libdyld)/,
        /\\.framework\\//,
        /^\\/system\\//,
        /^\\/usr\\/lib\\//,
        
        // Linux system modules
        /^lib(c|pthread|dl|m|rt|resolv|nsl|util|crypt)\\.so/,
        /^ld-linux/,
        /^\\/lib\\//,
        /^\\/usr\\/lib\\//,
        /^linux-vdso/,
        
        // Windows system modules  
        /^(ntdll|kernel32|user32|advapi32|ole32|oleaut32|shell32|gdi32|winmm|ws2_32|crypt32|rpcrt4|comctl32|comdlg32|version|shlwapi)\\.dll$/,
        /^msvcrt/,
        /^ucrtbase/,
        /^vcruntime/,
        /^api-ms-/,
        /^ext-ms-/,
        
        // Common patterns
        /^libc\\+\\+/,
        /^libstdc\\+\\+/,
        /^libgcc/
    ];
    
    return systemPatterns.some(pattern => 
        pattern.test(name) || (path && pattern.test(path))
    );
}

// prepare module data
function prepareModuleData() {
    var rawModules = Process.enumerateModules();
    var internalUseModules = [];
    var pythonSendModules = [];

    for (var i = 0; i < rawModules.length; i++) {
        var mod = rawModules[i];
        
        // skip system modules if excludeSystem is enabled
        if (excludeSystem && isSystemModule(mod.name, mod.path)) {
            continue;
        }
        
        var moduleEndAddress = mod.base.add(mod.size);

        // version for internal js use
        internalUseModules.push({
            id: internalUseModules.length, // assign sequential id
            name: mod.name,
            base: mod.base,
            size: mod.size,
            path: mod.path,
            end: moduleEndAddress
        });

        // version for sending to python
        pythonSendModules.push({
            id: internalUseModules.length - 1,
            name: mod.name,
            base: mod.base.toString(),
            size: mod.size,
            path: mod.path,
            end: moduleEndAddress.toString()
        });
    }
    return { internal: internalUseModules, forPython: pythonSendModules };
}

// initial module processing
var moduleProcessingResult = prepareModuleData();
var modulesForJsLogic = moduleProcessingResult.internal;
var modulesForPythonHost = moduleProcessingResult.forPython;

// send the python-friendly module list to the host
send({'type': 'modules', 'data': modulesForPythonHost});

// create a lookup table: module_path -> {id: module_id, start: module_base_nativepointer}
var modulePathToIdMap = {};
modulesForJsLogic.forEach(function (moduleEntry) {
    modulePathToIdMap[moduleEntry.path] = {id: moduleEntry.id, start: moduleEntry.base};
});

// create filtered module map based on whitelist
var filteredModuleMap = new ModuleMap(function (m) {
    if (whitelistedModules.indexOf('all') >= 0) {
        return !excludeSystem || !isSystemModule(m.name, m.path);
    }
    // check if module name matches whitelist
    return whitelistedModules.some(item => m.name.toLowerCase().includes(item.toLowerCase()));
});

// convert basic blocks to drcov format
function convertBasicBlocksToDrcov(basicBlockEvents, activeModuleMap, pathToIdLookup) {
    var buffer = new ArrayBuffer(DRCOV_BB_ENTRY_SIZE_BYTES * basicBlockEvents.length);
    var numEntriesWritten = 0;

    for (var i = 0; i < basicBlockEvents.length; ++i) {
        var blockEvent = basicBlockEvents[i];
        var startAddress = blockEvent[0];
        var endAddress = blockEvent[1];

        var modulePath = activeModuleMap.findPath(startAddress);
        if (modulePath === null) {
            continue;
        }

        var moduleInfo = pathToIdLookup[modulePath];
        if (!moduleInfo || !(moduleInfo.start instanceof NativePointer)) {
            continue;
        }

        var offset = startAddress.sub(moduleInfo.start).toInt32();
        var size = endAddress.sub(startAddress).toInt32();
        var moduleId = moduleInfo.id;

        var currentOffsetBytes = numEntriesWritten * DRCOV_BB_ENTRY_SIZE_BYTES;

        // write offset (uint32_t)
        new Uint32Array(buffer, currentOffsetBytes, 1)[0] = offset;
        // write size (uint16_t) and mod_id (uint16_t)
        var uint16View = new Uint16Array(buffer, currentOffsetBytes + 4, 2);
        uint16View[0] = size;
        uint16View[1] = moduleId;

        ++numEntriesWritten;
    }

    if (numEntriesWritten === 0) {
        return null;
    }
    return new Uint8Array(buffer, 0, numEntriesWritten * DRCOV_BB_ENTRY_SIZE_BYTES);
}

// stalker configuration
Stalker.trustThreshold = 0;

// track active stalkers
var activeStalkers = new Set();

// start stalking thread if needed
function startStalkingThreadIfNeeded(threadId) {
    var shouldStalkThisThread = threadIdList.indexOf('all') >= 0 || threadIdList.indexOf(threadId) >= 0;

    if (!shouldStalkThisThread) {
        return;
    }

    if (activeStalkers.has(threadId)) {
        return; // already stalking
    }

    if (verbose) console.log('Stalking thread ' + threadId);
    activeStalkers.add(threadId);

    // Configure events based on hit counting mode
    var stalkerEvents = useHitCounting ? {
        block: true    // Use block events for hit counting
    } : {
        compile: true  // Use compile events for coverage only
    };
    
    // Convert thread ID to unsigned integer for Frida
    // On Linux, thread IDs can be negative, but Stalker.follow expects unsigned
    var unsignedThreadId = threadId >>> 0;
    
    Stalker.follow(unsignedThreadId, {
        events: stalkerEvents,
        onReceive: function (rawStalkerEvents) {
            try {
                var parsedBasicBlocks = Stalker.parse(rawStalkerEvents, {stringify: false, annotate: false});

                if (parsedBasicBlocks && parsedBasicBlocks.length > 0) {
                    var drcovFormattedBlocks = convertBasicBlocksToDrcov(parsedBasicBlocks, filteredModuleMap, modulePathToIdMap);
                    if (drcovFormattedBlocks && drcovFormattedBlocks.buffer.byteLength > 0) {
                        send({type: 'bbs'}, drcovFormattedBlocks);
                    }
                }
            } catch (e) {
                console.error('Error in stalker onReceive for thread ' + threadId + ':', e.message);
            }
        }
    });
}

// thread observer for handling both existing and new threads
var threadObserver = Process.attachThreadObserver({
    onAdded: function (thread) {
        startStalkingThreadIfNeeded(thread.id);
    },
    onRemoved: function (thread) {
        if (activeStalkers.has(thread.id)) {
            activeStalkers.delete(thread.id);
            if (verbose) console.log('Thread ' + thread.id + ' removed from stalker tracking');
        }
    }
});

if (verbose) console.log('Thread observer ready');

// handle shutdown
recv(function(message) {
    if (message.type === 'shutdown') {
        if (verbose) console.log('Received shutdown request');
        
        // stop all stalkers
        activeStalkers.forEach(function(threadId) {
            try {
                Stalker.unfollow(threadId);
            } catch (e) {
                console.error('Error stopping stalker for thread ' + threadId + ':', e.message);
            }
        });
        activeStalkers.clear();
        
        // detach thread observer
        if (threadObserver) {
            threadObserver.detach();
        }
        
        send({type: 'shutdown_complete'});
    }
});

// send ready signal
send({type: 'ready'});
"""


class StalkDrcovTracer:
    """Main tracer class for basic block coverage collection"""

    def __init__(self, args):
        self.args = args

        # Frida objects
        self.device = None
        self.session = None
        self.script = None
        self.pid = None

        # State tracking
        self.running = False
        self.shutdown_complete = False

        # Data storage - depends on hit counting mode
        self.modules = []
        self._initialize_storage()

    def _initialize_storage(self):
        """Initialize basic blocks storage based on mode"""
        if self.args.hits:
            # Dict for hit counting: bb_entry_bytes -> count
            self.basic_blocks = {}
            print("[*] Coverage mode: Hit counting (using block events)")
        else:
            # Set for coverage tracking (standard drcov behavior)
            self.basic_blocks = set()
            print("[*] Coverage mode: Basic (using compile events)")

    def start_tracing(self):
        """Start the tracing process"""
        try:
            # get device
            self.device = self._get_device()

            # attach or spawn
            if self.args.spawn:
                self._spawn_process()
            else:
                self._attach_process()

            # inject script
            self._inject_script()

            # resume if spawned
            if self.args.spawn:
                self.device.resume(self.pid)
                print("[+] Process resumed")

            self.running = True

        except Exception as e:
            # cleanup on failure
            if hasattr(self, "session") and self.session:
                try:
                    self.session.detach()
                except:
                    pass
            raise e

    def _get_device(self):
        """Get the Frida device"""
        try:
            if self.args.host:
                manager = frida.get_device_manager()
                device = manager.add_remote_device(self.args.host)
                print(f"[*] Using remote device: {self.args.host}")
            else:
                device = frida.get_device(self.args.device)
                print(f"[*] Using device: {device.id}")
            return device
        except Exception as e:
            raise RuntimeError(f"Failed to get Frida device: {e}")

    def _spawn_process(self):
        """Spawn a new process"""
        try:
            target_path = self.args.target
            print(f"[*] Spawning: {target_path}")

            spawn_options = {}
            if self.args.disable_aslr:
                spawn_options["aslr"] = "disable"
                print("[*] ASLR disabled for spawned process")

            # Build command line with target and arguments
            cmd_line = [target_path] + self.args.target_args
            if self.args.target_args:
                print(f"[*] Spawning with arguments: {' '.join(cmd_line)}")
            self.pid = self.device.spawn(cmd_line, **spawn_options)
            print(f"[+] Spawned process with PID: {self.pid}")

            self.session = self.device.attach(self.pid)
            print(f"[+] Attached to spawned process")

        except frida.ExecutableNotFoundError:
            raise RuntimeError(f"Executable not found: {target_path}")
        except Exception as e:
            raise RuntimeError(f"Failed to spawn process: {e}")

    def _attach_process(self):
        """Attach to existing process"""
        try:
            target = self.args.target

            # try to parse as PID first
            try:
                self.pid = int(target)
                print(f"[*] Attaching to PID: {self.pid}")
                self.session = self.device.attach(self.pid)
                print(f"[+] Attached to PID: {self.pid}")
            except ValueError:
                # treat as process name
                print(f"[*] Looking for process: {target}")
                try:
                    process = self.device.get_process(target)
                    self.pid = process.pid
                    print(f"[*] Found process '{target}' with PID: {self.pid}")
                    self.session = self.device.attach(self.pid)
                    print(f"[+] Attached to process")
                except frida.ProcessNotFoundError:
                    # fallback to enumeration
                    print(
                        f"[*] Process '{target}' not found by direct lookup, searching..."
                    )
                    try:
                        processes = self.device.enumerate_processes()
                        matches = [
                            p
                            for p in processes
                            if target.lower() in p.name.lower() or str(p.pid) == target
                        ]

                        if not matches:
                            available_processes = [
                                f"{p.pid}: {p.name}" for p in processes[:10]
                            ]
                            available_str = "\n".join(available_processes)
                            if len(processes) > 10:
                                available_str += (
                                    f"\n... and {len(processes) - 10} more processes"
                                )

                            raise RuntimeError(
                                f"Process '{target}' not found.\n"
                                f"Available processes (showing first 10):\n{available_str}\n\n"
                                f"Use a valid PID or process name."
                            )
                        elif len(matches) > 1:
                            print(f"[!] Multiple processes match '{target}':")
                            for p in matches:
                                print(f"    PID: {p.pid}, Name: {p.name}")
                            self.pid = matches[0].pid
                            print(f"[*] Using first match: PID {self.pid}")
                        else:
                            self.pid = matches[0].pid
                            print(
                                f"[*] Found process: PID {self.pid}, Name: {matches[0].name}"
                            )

                        self.session = self.device.attach(self.pid)
                        print(f"[+] Attached to process")

                    except Exception as e:
                        raise RuntimeError(
                            f"Failed to enumerate or attach to processes: {e}"
                        )
            except frida.ProcessNotFoundError:
                raise RuntimeError(
                    f"Process with PID {self.pid} not found or access denied"
                )
            except Exception as e:
                raise RuntimeError(f"Failed to attach to process: {e}")

        except Exception as e:
            raise RuntimeError(f"Failed to attach to process: {e}")

    def _inject_script(self):
        """Inject the JavaScript agent"""
        try:
            # prepare configuration
            config = {
                "whitelistedModules": self.args.whitelist_modules or ["all"],
                "threadIdList": self.args.thread_id or ["all"],
                "excludeSystem": self.args.no_system,
                "useHitCounting": self.args.hits,
                "verbose": self.args.verbose,
            }

            # inject script with properly escaped JSON
            config_json = json.dumps(config)
            config_json_escaped = config_json.replace("\\", "\\\\").replace("'", "\\'")
            script_code = js_agent_code.replace(
                "CONFIG_JSON_PLACEHOLDER", config_json_escaped
            )

            self.script = self.session.create_script(script_code)
            self.script.on("message", self._on_message)
            self.script.load()

        except Exception as e:
            raise RuntimeError(f"Failed to inject JavaScript agent: {e}")

    def _on_message(self, message, data):
        """Handle messages from the JS agent"""
        try:
            if message["type"] == "error":
                print(f"[!] Script error: {message}")
                return

            if message["type"] == "send":
                payload = message.get("payload", {})
                msg_type = payload.get("type")

                if msg_type == "ready":
                    print("[+] Agent ready")

                elif msg_type == "modules":
                    self.modules = payload.get("data", [])
                    print(f"[*] Modules: {len(self.modules)} loaded")

                elif msg_type == "bbs":
                    if data:
                        self._process_basic_blocks(data)

                elif msg_type == "shutdown_complete":
                    print("[*] Shutdown complete")
                    self.shutdown_complete = True

        except Exception as e:
            print(f"[!] Error processing message: {e}")

    def _process_basic_blocks(self, bb_data_buffer):
        """Process basic block data from JS agent"""
        if not bb_data_buffer or len(bb_data_buffer) == 0:
            return

        if len(bb_data_buffer) % DRCOV_BB_ENTRY_SIZE_BYTES != 0:
            print(f"[!] Invalid BB data length: {len(bb_data_buffer)}")
            return

        # process each basic block entry
        for i in range(0, len(bb_data_buffer), DRCOV_BB_ENTRY_SIZE_BYTES):
            bb_entry = bb_data_buffer[i : i + DRCOV_BB_ENTRY_SIZE_BYTES]

            if self.args.hits:
                # track hit counts in dict
                if bb_entry in self.basic_blocks:
                    self.basic_blocks[bb_entry] += 1
                else:
                    self.basic_blocks[bb_entry] = 1
            else:
                # just track coverage in set
                self.basic_blocks.add(bb_entry)

    def stop_tracing(self):
        """Stop tracing and cleanup"""
        if not self.running:
            return

        print("[*] Stopping tracing...")
        self.running = False

        if self.script:
            try:
                print("[*] Sending shutdown signal...")
                self.script.post({"type": "shutdown"})

                # wait for shutdown complete
                timeout = 5.0
                start_time = time.time()
                while (
                    not self.shutdown_complete and (time.time() - start_time) < timeout
                ):
                    time.sleep(0.1)

                if not self.shutdown_complete:
                    print("[!] Timeout waiting for shutdown")

            except Exception as e:
                print(f"[!] Error during shutdown: {e}")

        # cleanup session
        if self.session:
            try:
                self.session.detach()
                print("[+] Session detached")
            except Exception as e:
                print(f"[!] Error detaching session: {e}")

    def save_coverage(self):
        """Save coverage data to drcov file"""
        try:
            output_file = self.args.output
            if not output_file:
                output_file = "frida-cov.drcov"

            # Generate status message
            block_count = len(self.basic_blocks)
            if self.args.hits:
                total_hits = sum(self.basic_blocks.values())
                status_msg = f"[*] Saving {block_count:,} unique basic blocks ({total_hits:,} total hits) to '{output_file}'..."
            else:
                status_msg = f"[*] Saving {block_count:,} unique basic blocks to '{output_file}'..."
            print(status_msg)

            # create drcov header
            header = self._create_drcov_header()

            # create drcov body
            body = self._create_drcov_body()

            # write file
            with open(output_file, "wb") as f:
                f.write(header)
                f.write(body)

            print(f"[+] Coverage data saved to: {output_file}")

        except Exception as e:
            print(f"[!] Error saving coverage: {e}")

    def _create_drcov_header(self):
        """Create drcov file header"""
        lines = []
        lines.append("DRCOV VERSION: 2")
        # Set flavor based on hit counting mode
        if self.args.hits:
            lines.append("DRCOV FLAVOR: drcov-hits")
        else:
            lines.append("DRCOV FLAVOR: frida")

        if not self.modules:
            lines.append("Module Table: version 2, count 0")
        else:
            lines.append(f"Module Table: version 2, count {len(self.modules)}")

        lines.append("Columns: id, base, end, entry, checksum, timestamp, path")

        for module in self.modules:
            line = "%3d, %#016x, %#016x, %#016x, %#08x, %#08x, %s" % (
                module["id"],
                int(module["base"], 16),
                int(module["end"], 16),
                0,  # entry point
                0,  # checksum
                0,  # timestamp
                module["name"],  # Use basename instead of full path
            )
            lines.append(line)

        return ("\n".join(lines) + "\n").encode("utf-8")

    def _create_drcov_body(self):
        """Create drcov file body (standard or hit count format)"""
        if self.args.hits:
            return self._create_hit_count_body()
        else:
            return self._create_standard_body()

    def _create_standard_body(self):
        """Create standard drcov body (coverage only)"""
        sorted_bbs = sorted(list(self.basic_blocks))
        bb_header = f"BB Table: {len(sorted_bbs)} bbs\n".encode("utf-8")
        bb_data = b"".join(sorted_bbs)
        return bb_header + bb_data

    def _create_hit_count_body(self):
        """Create drcov body with hit count table"""
        # Sort basic blocks for deterministic output
        sorted_bb_items = sorted(self.basic_blocks.items())
        bb_entries = [bb_entry for bb_entry, count in sorted_bb_items]
        hit_counts = [count for bb_entry, count in sorted_bb_items]

        # Create BB Table
        bb_header = f"BB Table: {len(bb_entries)} bbs\n".encode("utf-8")
        bb_data = b"".join(bb_entries)

        # Create Hit Count Table (as per proposal specification)
        hit_header = f"Hit Count Table: version 1, count {len(hit_counts)}\n".encode(
            "utf-8"
        )
        hit_data = b"".join(struct.pack("<I", count) for count in hit_counts)

        return bb_header + bb_data + hit_header + hit_data


def signal_handler(signum, frame):
    """Handle signals for graceful shutdown"""
    print(f"\n[!] Received signal {signum}, shutting down...")
    if hasattr(signal_handler, "tracer"):
        signal_handler.tracer.stop_tracing()


def main():
    parser = argparse.ArgumentParser(
        description="Frida-based basic block tracer outputting drcov format",
        formatter_class=argparse.RawTextHelpFormatter,
    )

    # Target specification
    parser.add_argument("target", help="Process ID, process name, or executable path")
    parser.add_argument(
        "target_args",
        nargs="*",
        help="Arguments to pass to spawned process (use after --)",
    )

    # Execution mode
    parser.add_argument(
        "-s",
        "--spawn",
        action="store_true",
        help="Spawn new process instead of attaching",
    )
    parser.add_argument(
        "--disable-aslr",
        action="store_true",
        help="Disable ASLR for spawned process (macOS only)",
    )

    # Output options
    parser.add_argument(
        "-o",
        "--output",
        default="frida-cov.drcov",
        help="Output drcov file path (default: frida-cov.drcov)",
    )
    parser.add_argument(
        "--hits",
        action="store_true",
        help="Enable hit count tracking (uses block events, generates drcov-hits format)",
    )

    # Filtering options
    parser.add_argument(
        "-w",
        "--whitelist-modules",
        action="append",
        default=[],
        help="Module name to trace (can be repeated, default: all modules)",
    )
    parser.add_argument(
        "-t",
        "--thread-id",
        action="append",
        default=[],
        help="Thread ID to trace (can be repeated, default: all threads)",
    )
    parser.add_argument(
        "--no-system", action="store_true", help="Exclude system modules from tracing"
    )

    # Control options
    parser.add_argument(
        "--timeout", type=int, help="Maximum collection time in seconds"
    )

    # Device options
    parser.add_argument(
        "-D", "--device", default="local", help="Frida device (default: local)"
    )
    parser.add_argument("-H", "--host", help="Connect to remote frida-server")

    # Debug options
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")

    args = parser.parse_args()

    # create tracer
    tracer = StalkDrcovTracer(args)

    # setup signal handlers
    signal_handler.tracer = tracer
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    try:
        # start tracing
        tracer.start_tracing()
        print("[*] Tracing started. Press Ctrl+C to stop and save.")

        # wait for completion
        if args.timeout:
            time.sleep(args.timeout)
            tracer.stop_tracing()
        else:
            # wait for interrupt
            while tracer.running:
                try:
                    time.sleep(0.1)

                    # check if spawned process has exited
                    if args.spawn and tracer.pid:
                        try:
                            processes = tracer.device.enumerate_processes()
                            process_exists = any(p.pid == tracer.pid for p in processes)
                            if not process_exists:
                                print("[*] Spawned process has exited")
                                tracer.stop_tracing()
                                break
                        except:
                            pass  # ignore enumeration errors

                except KeyboardInterrupt:
                    print("\n[!] Interrupted by user")
                    tracer.stop_tracing()
                    break

    except frida.ProcessNotFoundError:
        print(f"[-] Process not found: {args.target}")
        sys.exit(1)
    except frida.PermissionDeniedError:
        print(f"[-] Permission denied. Try with elevated privileges.")
        sys.exit(1)
    except RuntimeError as e:
        print(f"[-] Error: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"[-] Unexpected error: {e}")
        if args.verbose:
            import traceback

            traceback.print_exc()
        sys.exit(1)
    else:
        # only run this if no exceptions occurred (tracer is properly initialized)
        try:
            # save results
            tracer.save_coverage()
        except Exception as e:
            print(f"[-] Error saving coverage: {e}")
            if args.verbose:
                import traceback

                traceback.print_exc()


if __name__ == "__main__":
    main()

```

`scripts/d0ct0r.py`:

```py
#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.9"
# dependencies = [
#   "typer>=0.15.0",
#   "rich>=13.0.0",
#   "sh>=2.2.0",
# ]
# ///

import os
import sys
import platform
import stat
import subprocess
import shutil
from pathlib import Path
from typing import Optional, Tuple, List, Dict, Any

import typer
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.panel import Panel
from rich.text import Text
from rich.table import Table
from rich.logging import RichHandler
import logging

CONTEXT_SETTINGS = dict(help_option_names=["-h", "--help"])

APP_NAME = "d0ct0r"
app = typer.Typer(
    name=APP_NAME,
    help=f"{APP_NAME}: intelligent p1llx wrapper with backup management and codesigning",
    no_args_is_help=True,
    context_settings=CONTEXT_SETTINGS,
    pretty_exceptions_short=True,
    pretty_exceptions_show_locals=False,
)

console = Console()

# global state for sudo and verbosity
global_sudo = False
global_verbose = 0


class BinaryFormat:
    """binary format detection utilities"""

    # magic numbers for different binary formats
    MACH_O_MAGIC = {
        0xFEEDFACE: "mach-o 32-bit",
        0xFEEDFACF: "mach-o 64-bit",
        0xCAFEBABE: "mach-o fat binary",
        0xCFFAEDFE: "mach-o 64-bit (reverse)",
        0xCEFAEDFE: "mach-o 32-bit (reverse)",
    }

    ELF_MAGIC = 0x7F454C46  # \x7fELF
    PE_MAGIC = 0x5A4D  # MZ

    @staticmethod
    def detect_format(file_path: Path) -> Tuple[str, bool]:
        """
        detect binary format from magic numbers
        returns (format_name, is_macho)
        """
        try:
            with open(file_path, "rb") as f:
                magic = f.read(4)
                if len(magic) < 4:
                    return "unknown", False

                magic_int = int.from_bytes(magic, byteorder="little")

                # check mach-o formats
                if magic_int in BinaryFormat.MACH_O_MAGIC:
                    return BinaryFormat.MACH_O_MAGIC[magic_int], True

                # check big-endian mach-o
                magic_int_be = int.from_bytes(magic, byteorder="big")
                if magic_int_be in BinaryFormat.MACH_O_MAGIC:
                    return BinaryFormat.MACH_O_MAGIC[magic_int_be], True

                # check elf
                if magic_int == BinaryFormat.ELF_MAGIC:
                    return "elf", False

                # check pe
                if magic_int & 0xFFFF == BinaryFormat.PE_MAGIC:
                    return "pe/coff", False

                return "unknown", False

        except Exception as e:
            console.print(f"[red]error detecting format: {e}[/red]")
            return "unknown", False


class FileOperations:
    """cross-platform file operations with elevation support"""

    @staticmethod
    def copy_file(src: Path, dst: Path, use_elevation: bool = False) -> bool:
        """cross-platform file copy with optional elevation"""
        console.print(f"[cyan]copying: {src} -> {dst}[/cyan]")

        # try normal copy first (unless explicitly told to use elevation)
        if not use_elevation:
            try:
                dst.parent.mkdir(parents=True, exist_ok=True)
                shutil.copy2(src, dst)
                console.print(f"[green]✓ copied successfully[/green]")
                return True
            except PermissionError:
                if platform.system() == "Windows":
                    console.print(
                        "[red]permission denied - please run as administrator[/red]"
                    )
                    return False
                else:
                    console.print(
                        "[yellow]permission denied - retrying with sudo[/yellow]"
                    )
                    # fall through to elevated copy below
            except Exception as e:
                console.print(f"[red]copy failed: {e}[/red]")
                return False

        # elevated copy (either requested explicitly or after permission error)
        if platform.system() == "Windows":
            console.print(
                "[red]windows elevation required - please run as administrator[/red]"
            )
            return False
        else:
            # unix-like: use sudo cp with preserve attributes
            # first ensure destination directory exists with sudo
            dst_dir = dst.parent
            if not dst_dir.exists():
                mkdir_cmd = ["sudo", "mkdir", "-p", str(dst_dir)]
                try:
                    mkdir_result = subprocess.run(
                        mkdir_cmd, capture_output=True, text=True
                    )
                    if mkdir_result.returncode != 0:
                        console.print(
                            f"[red]failed to create directory with sudo: {mkdir_result.stderr}[/red]"
                        )
                        return False
                except Exception as e:
                    console.print(f"[red]sudo mkdir error: {e}[/red]")
                    return False

            # now copy with sudo
            cmd = ["sudo", "cp", "-p", str(src), str(dst)]
            try:
                console.print(f"[dim]$ {' '.join(cmd)}[/dim]")
                result = subprocess.run(cmd, capture_output=True, text=True)
                if result.returncode == 0:
                    console.print(f"[green]✓ copied with sudo[/green]")
                    return True
                else:
                    console.print(f"[red]sudo copy failed: {result.stderr}[/red]")
                    return False
            except Exception as e:
                console.print(f"[red]sudo copy error: {e}[/red]")
                return False

    @staticmethod
    def set_permissions(
        file_path: Path, permissions: int, use_elevation: bool = False
    ) -> bool:
        """cross-platform permission setting with optional elevation"""
        # try normal chmod first (unless explicitly told to use elevation)
        if not use_elevation:
            try:
                file_path.chmod(permissions)
                console.print(
                    f"[green]✓ restored permissions: {oct(permissions)}[/green]"
                )
                return True
            except PermissionError:
                if platform.system() == "Windows":
                    console.print(
                        "[yellow]windows permission model differs - skipping[/yellow]"
                    )
                    return True  # windows permission model is different
                else:
                    console.print(
                        "[yellow]permission denied - retrying with sudo[/yellow]"
                    )
                    # fall through to elevated chmod below
            except Exception as e:
                console.print(f"[red]permission setting failed: {e}[/red]")
                return False

        # elevated chmod (either requested explicitly or after permission error)
        if platform.system() == "Windows":
            console.print(
                "[yellow]windows elevation for permissions not implemented[/yellow]"
            )
            return True  # windows permission model is different
        else:
            cmd = ["sudo", "chmod", oct(permissions)[2:], str(file_path)]
            try:
                console.print(f"[dim]$ {' '.join(cmd)}[/dim]")
                result = subprocess.run(cmd, capture_output=True, text=True)
                if result.returncode == 0:
                    console.print(
                        f"[green]✓ restored permissions with sudo: {oct(permissions)}[/green]"
                    )
                    return True
                else:
                    console.print(f"[red]sudo chmod failed: {result.stderr}[/red]")
                    return False
            except Exception as e:
                console.print(f"[red]sudo chmod error: {e}[/red]")
                return False


class BackupManager:
    """smart backup management for d0ct0r operations"""

    @staticmethod
    def get_backup_path(file_path: Path) -> Path:
        """get the backup path for a given file"""
        return file_path.with_suffix(file_path.suffix + ".d0ct0r.bak")

    @staticmethod
    def create_backup(
        file_path: Path, force: bool = False, use_elevation: bool = False
    ) -> Path:
        """
        create a backup of the file if it doesn't exist
        returns the backup path
        """
        backup_path = BackupManager.get_backup_path(file_path)

        if backup_path.exists() and not force:
            console.print(f"[yellow]using existing backup: {backup_path.name}[/yellow]")
            return backup_path

        if not file_path.exists():
            raise FileNotFoundError(f"source file not found: {file_path}")

        console.print(
            f"[blue]creating backup: {file_path.name} -> {backup_path.name}[/blue]"
        )

        if not FileOperations.copy_file(file_path, backup_path, use_elevation):
            raise RuntimeError(f"failed to create backup: {backup_path}")

        return backup_path

    @staticmethod
    def should_use_backup(input_path: Path, output_path: Optional[Path] = None) -> bool:
        """
        determine if we should use backup-based workflow
        """
        if output_path is None:
            # in-place modification, definitely use backup
            return True

        if input_path.resolve() == output_path.resolve():
            # same file, use backup
            return True

        return False


class PermissionManager:
    """permission preservation utilities"""

    @staticmethod
    def get_permissions(file_path: Path) -> int:
        """get file permissions"""
        return stat.S_IMODE(file_path.stat().st_mode)

    @staticmethod
    def set_permissions(
        file_path: Path, permissions: int, use_elevation: bool = False
    ) -> bool:
        """set file permissions using file operations"""
        return FileOperations.set_permissions(file_path, permissions, use_elevation)


class CodesignManager:
    """macos codesigning utilities"""

    @staticmethod
    def should_codesign(file_path: Path) -> bool:
        """
        determine if file should be codesigned based on platform and format
        """
        if platform.system() != "Darwin":
            return False

        format_name, is_macho = BinaryFormat.detect_format(file_path)
        return is_macho

    @staticmethod
    def codesign(file_path: Path, sudo: bool = False) -> bool:
        """
        codesign a file with ad-hoc signature
        """
        if not CodesignManager.should_codesign(file_path):
            return True

        cmd = ["codesign", "-fs", "-", str(file_path)]
        if sudo:
            cmd = ["sudo"] + cmd

        try:
            console.print(f"[blue]codesigning: {file_path.name}[/blue]")
            console.print(f"[dim]$ {' '.join(cmd)}[/dim]")
            result = subprocess.run(cmd, capture_output=True, text=True)

            if result.returncode == 0:
                console.print(f"[green]✓ codesigned successfully[/green]")
                return True
            else:
                console.print(f"[red]codesigning failed: {result.stderr}[/red]")
                return False

        except Exception as e:
            console.print(f"[red]codesigning error: {e}[/red]")
            return False


class P1llxRunner:
    """p1llx command execution utilities"""

    @staticmethod
    def find_p1llx() -> Path:
        """find the p1llx executable"""
        script_dir = Path(__file__).parent
        p1llx_path = script_dir.parent / "build-release" / "p1llx"

        if not p1llx_path.exists():
            raise FileNotFoundError(f"p1llx not found at {p1llx_path}")

        return p1llx_path

    @staticmethod
    def run_p1llx(cmd_args: List[str], sudo: bool = False) -> bool:
        """
        run p1llx with given arguments
        """
        p1llx_path = P1llxRunner.find_p1llx()
        cmd = [str(p1llx_path)] + cmd_args

        if sudo:
            cmd = ["sudo"] + cmd

        try:
            console.print(f"[dim]$ {' '.join(cmd)}[/dim]")
            result = subprocess.run(cmd, text=True)

            if result.returncode == 0:
                console.print(f"[green]✓ p1llx completed successfully[/green]")
                return True
            else:
                console.print(
                    f"[red]p1llx failed with exit code: {result.returncode}[/red]"
                )
                return False

        except Exception as e:
            console.print(f"[red]p1llx execution error: {e}[/red]")
            return False


def setup_logging(verbose: int = 0):
    """setup logging based on verbosity level"""
    levels = [logging.WARNING, logging.INFO, logging.DEBUG]
    level = levels[min(verbose, len(levels) - 1)]

    logging.basicConfig(
        level=level,
        format="%(message)s",
        handlers=[RichHandler(console=console, rich_tracebacks=True)],
    )


@app.callback()
def main_callback(
    sudo: bool = typer.Option(False, "--sudo", help="run p1llx commands with sudo"),
    verbose: int = typer.Option(
        0, "-v", "--verbose", count=True, help="increase verbosity"
    ),
):
    """global options for d0ct0r"""
    global global_sudo, global_verbose
    global_sudo = sudo
    global_verbose = verbose

    setup_logging(verbose)

    if verbose > 0:
        console.print(f"[dim]verbose level: {verbose}[/dim]")
    if sudo:
        console.print(f"[dim]sudo mode enabled[/dim]")


@app.command()
def auto_cure(
    cure_script: str = typer.Option(..., "-c", "--cure", help="lua cure script path"),
    input_file: str = typer.Option(..., "-i", "--input", help="input file path"),
    output_file: Optional[str] = typer.Option(
        None, "-o", "--output", help="output file path"
    ),
    platform_override: Optional[str] = typer.Option(
        None, "-p", "--platform", help="platform override (e.g., darwin:arm64)"
    ),
    no_backup: bool = typer.Option(
        False, "--no-backup", help="disable backup creation"
    ),
):
    """
    smart wrapper for p1llx cure with automatic backup management and codesigning
    """
    setup_logging(global_verbose)

    input_path = Path(input_file)
    output_path = Path(output_file) if output_file else None

    console.print(
        Panel(
            f"[bold]d0ct0r auto-cure[/bold]\n"
            f"input: {input_path.name}\n"
            f"output: {output_path.name if output_path else 'in-place'}\n"
            f"script: {Path(cure_script).name}"
        )
    )

    # validate input file exists
    if not input_path.exists():
        console.print(f"[red]input file not found: {input_path}[/red]")
        raise typer.Exit(1)

    # prevent same input/output
    if output_path and input_path.resolve() == output_path.resolve():
        console.print(f"[red]input and output cannot be the same file[/red]")
        raise typer.Exit(1)

    # detect binary format
    format_name, is_macho = BinaryFormat.detect_format(input_path)
    console.print(f"[cyan]detected format: {format_name}[/cyan]")

    # preserve original permissions
    original_permissions = PermissionManager.get_permissions(input_path)

    # handle backup workflow
    if not no_backup and BackupManager.should_use_backup(input_path, output_path):
        backup_path = BackupManager.create_backup(
            input_path, force=False, use_elevation=global_sudo
        )
        actual_input = backup_path
    else:
        actual_input = input_path

    # build p1llx command
    cmd_args = []
    if global_verbose > 0:
        cmd_args.append("-" + "v" * global_verbose)

    cmd_args.extend(["cure", "-c", cure_script, "-i", str(actual_input)])

    # determine target file and ensure we don't modify backup in-place
    # critical: p1llx modifies input file when no -o is specified!
    # we must always specify -o when using backup to preserve backup integrity
    if output_path:
        cmd_args.extend(["-o", str(output_path)])
        target_file = output_path
    else:
        # in-place modification: always specify output to avoid corrupting backup
        if actual_input != input_path:  # we're using a backup
            cmd_args.extend(
                ["-o", str(input_path)]
            )  # output to original file, preserve backup
            target_file = input_path
        else:
            # no backup workflow, p1llx can modify in-place safely
            target_file = input_path

    if platform_override:
        cmd_args.extend(["-p", platform_override])

    # run p1llx
    if not P1llxRunner.run_p1llx(cmd_args, global_sudo):
        raise typer.Exit(1)

    # codesign if needed
    if not CodesignManager.codesign(target_file, global_sudo):
        console.print(f"[yellow]warning: codesigning failed[/yellow]")

    # restore permissions
    if not PermissionManager.set_permissions(
        target_file, original_permissions, global_sudo
    ):
        console.print(f"[yellow]warning: could not restore permissions[/yellow]")

    console.print(f"[green]✓ auto-cure completed successfully[/green]")


@app.command()
def cure(
    cure_script: str = typer.Option(..., "-c", "--cure", help="lua cure script path"),
    input_file: str = typer.Option(..., "-i", "--input", help="input file path"),
    output_file: Optional[str] = typer.Option(
        None, "-o", "--output", help="output file path"
    ),
    platform_override: Optional[str] = typer.Option(
        None, "-p", "--platform", help="platform override"
    ),
):
    """
    pass-through to p1llx cure with optional enhancements
    """
    cmd_args = []
    if global_verbose > 0:
        cmd_args.append("-" + "v" * global_verbose)

    cmd_args.extend(["cure", "-c", cure_script, "-i", input_file])

    if output_file:
        cmd_args.extend(["-o", output_file])

    if platform_override:
        cmd_args.extend(["-p", platform_override])

    if not P1llxRunner.run_p1llx(cmd_args, global_sudo):
        raise typer.Exit(1)


@app.command()
def patch(
    address: str = typer.Option(..., "--address", help="address to patch (hex)"),
    replace: str = typer.Option(..., "--replace", help="replacement hex bytes"),
    input_file: str = typer.Option(..., "-i", "--input", help="input file path"),
    output_file: Optional[str] = typer.Option(
        None, "-o", "--output", help="output file path"
    ),
):
    """
    pass-through to p1llx patch
    """
    cmd_args = []
    if global_verbose > 0:
        cmd_args.append("-" + "v" * global_verbose)

    cmd_args.extend(
        [
            "patch",
            f"--address={address}",
            f"--replace={replace}",
            "-i",
            input_file,
        ]
    )

    if output_file:
        cmd_args.extend(["-o", output_file])

    if not P1llxRunner.run_p1llx(cmd_args, global_sudo):
        raise typer.Exit(1)


@app.command()
def poison(
    cure_script: str = typer.Option(..., "-c", "--cure", help="lua cure script path"),
    spawn: bool = typer.Option(False, "-s", "--spawn", help="spawn target binary"),
    pid: Optional[int] = typer.Option(None, "--pid", help="target process pid"),
    process_name: Optional[str] = typer.Option(
        None, "--process-name", help="target process name"
    ),
    suspended: bool = typer.Option(
        False, "--suspended", help="start in suspended mode"
    ),
    args: Optional[List[str]] = typer.Argument(
        None, help="target binary and arguments"
    ),
):
    """
    pass-through to p1llx poison for dynamic patching
    """
    cmd_args = []
    if global_verbose > 0:
        cmd_args.append("-" + "v" * global_verbose)

    cmd_args.extend(["poison", "-c", cure_script])

    # target specification
    if spawn:
        cmd_args.append("-s")
    elif pid:
        cmd_args.extend(["--pid", str(pid)])
    elif process_name:
        cmd_args.extend(["--process-name", process_name])
    else:
        console.print(
            "[red]must specify target: --spawn, --pid, or --process-name[/red]"
        )
        raise typer.Exit(1)

    if suspended:
        cmd_args.append("--suspended")

    if args:
        cmd_args.extend(args)

    if not P1llxRunner.run_p1llx(cmd_args, global_sudo):
        raise typer.Exit(1)


if __name__ == "__main__":
    app()

```

`scripts/p1ll/string_patch.lua`:

```lua
-- some sample signatures with region filters
local SIG_DEMO_VERSION = p1.sig(p1.str2hex("DEMO VERSION"), {filter = "p1ll_test_target"})
local SIG_TRIAL_VERSION = p1.sig(p1.str2hex("TRIAL VERSION"), {filter = "p1ll_test_target"})

local meta = {
    name = "string_patch",
    -- supported platforms
    platforms = {"darwin:arm64", "linux:x64", "windows:x64"},

    -- all matching sigs must match in order for cure to be applicable
    sigs = {
        -- wildcards match all platforms
        ["*"] = {SIG_DEMO_VERSION, SIG_TRIAL_VERSION}
    },

    -- patches to apply if all sigs match
    patches = {
        -- wildcard patches are used on all platforms
        ["*"] = { -- a patch declares a signature, an offset, a replacement, and optional parameters
        p1.patch(SIG_DEMO_VERSION, 0, p1.str2hex("OOPS VERSION")), 
        p1.patch(SIG_TRIAL_VERSION, 0, p1.str2hex("SILLY VER"))}
    }
}

-- the cure function is called by the p1ll framework
function cure()
    -- use the mostly declarative auto cure api
    return p1.auto_cure(meta)
end

```

`scripts/w1script/coverage_tracker.lua`:

```lua
-- coverage tracker
-- counts unique basic blocks and total block hits

local discovered_blocks = {}
local total_block_hits = 0
local unique_block_count = 0

local tracer = {}
tracer.callbacks = { "basic_block_entry" }

function tracer.on_basic_block_entry(vm, state, gpr, fpr)
    local pc = w1.get_reg_pc and w1.get_reg_pc(gpr) or 0
    local block_address = w1.format_address(pc)
    
    total_block_hits = total_block_hits + 1
    
    -- track newly discovered blocks
    if not discovered_blocks[block_address] then
        discovered_blocks[block_address] = true
        unique_block_count = unique_block_count + 1
    end
    
    return w1.VMAction.CONTINUE
end

function tracer.shutdown()
    local avg_hits = unique_block_count > 0 and (total_block_hits / unique_block_count) or 0
    
    w1.log_info("coverage summary:")
    w1.log_info("  unique blocks: " .. unique_block_count)
    w1.log_info("  total hits: " .. total_block_hits)
    w1.log_info("  average hits per block: " .. string.format("%.2f", avg_hits))
end

return tracer
```

`scripts/w1script/hook_demo_abi.lua`:

```lua
-- hook_demo_abi.lua
-- cross-platform hooking using calling convention apis
-- portable across architectures without hardcoding register names
--
-- run with:
-- ./build-release/w1tool tracer -n w1script \
--   -c script=./scripts/w1script/hook_demo_abi.lua \
--   -s ./build-release/tests/programs/hook_test_target

local tracer = {}

function tracer.init()
    w1.log_info("=== hook demonstration - calling convention apis ===")
    
    -- detect and log platform info
    local plat_info = w1.get_platform_info()
    w1.log_info("platform information:")
    w1.log_info(string.format("  os: %s", plat_info.os))
    w1.log_info(string.format("  architecture: %s", plat_info.arch))
    w1.log_info(string.format("  bits: %d", plat_info.bits))
    
    -- get calling convention details
    local cc_info = w1.get_calling_convention_info()
    if cc_info then
        w1.log_info("calling convention:")
        w1.log_info(string.format("  name: %s", cc_info.name))
        w1.log_info(string.format("  id: %s", cc_info.id))
        
        if cc_info.argument_registers then
            w1.log_info(string.format("  argument registers: %s", 
                                      table.concat(cc_info.argument_registers, ", ")))
        end
        
        w1.log_info(string.format("  return register: %s", cc_info.return_register))
        w1.log_info(string.format("  stack alignment: %d bytes", cc_info.stack_alignment))
        w1.log_info(string.format("  stack cleanup: %s", cc_info.stack_cleanup))
    end
    w1.log_info("")
    
    -- find target module
    local modules = w1.module_list_all()
    local target_module = nil
    
    for _, mod in pairs(modules) do
        if string.find(mod.path, "hook_test_target") then
            target_module = mod
            break
        end
    end
    
    if not target_module then
        w1.log_error("target module 'hook_test_target' not found")
        return
    end
    
    w1.log_info(string.format("target module: %s", target_module.path))
    w1.log_info(string.format("base address: 0x%x", target_module.base_address))
    w1.log_info("")
    
    -- hook calculate_secret with abi-aware argument extraction
    local calculate_secret_addr = target_module.base_address + 0x840
    local hook_id = w1.hook_addr(calculate_secret_addr, function(vm, gpr, fpr, address)
        -- extract arguments using calling convention
        local args = w1.get_args(vm, gpr, fpr, 2)
        
        if args then
            w1.log_info(string.format("[calculate_secret] a=%d, b=%d, result=%d", 
                                      args[1], args[2], 3 * args[1] + 2 * args[2]))
        end
        
        return w1.VMAction.CONTINUE
    end)
    
    if hook_id then
        w1.log_info(string.format("✓ hooked calculate_secret at 0x%x", calculate_secret_addr))
    end
    
    -- hook format_message with typed arguments
    local format_message_addr = target_module.base_address + 0x88c
    hook_id = w1.hook_addr(format_message_addr, function(vm, gpr, fpr, address)
        -- extract typed arguments: char*, const char*, int
        local typed_args = w1.get_typed_args(vm, gpr, fpr, {"pointer", "pointer", "integer"})
        
        if typed_args then
            -- read string from second pointer argument
            local name_str = w1.read_string(vm, typed_args[2].value, 256)
            
            if name_str then
                w1.log_info(string.format("[format_message] name='%s', value=%d", 
                                          name_str, typed_args[3].value))
            end
            
            -- log argument details for debugging (use -vvv to see)
            w1.log_debug("  argument details:")
            for i, arg in ipairs(typed_args) do
                w1.log_debug(string.format("    arg%d: type=%s, value=0x%x, from_stack=%s",
                                          i, arg.type, arg.value, tostring(arg.from_stack)))
            end
        end
        
        return w1.VMAction.CONTINUE
    end)
    
    if hook_id then
        w1.log_info(string.format("✓ hooked format_message at 0x%x", format_message_addr))
    end
    
    -- hook compare_strings
    local compare_strings_addr = target_module.base_address + 0x940
    hook_id = w1.hook_addr(compare_strings_addr, function(vm, gpr, fpr, address)
        -- use convenience function for individual args
        local str1_ptr = w1.get_arg(vm, gpr, fpr, 1)
        local str2_ptr = w1.get_arg(vm, gpr, fpr, 2)
        
        if str1_ptr and str2_ptr then
            -- read both strings
            local str1 = w1.read_string(vm, str1_ptr, 256)
            local str2 = w1.read_string(vm, str2_ptr, 256)
            
            if str1 and str2 then
                w1.log_info(string.format("[compare_strings] '%s' vs '%s'", str1, str2))
            end
        end
        
        return w1.VMAction.CONTINUE
    end)
    
    if hook_id then
        w1.log_info(string.format("✓ hooked compare_strings at 0x%x", compare_strings_addr))
    end
    
    -- hook allocate_buffer
    local allocate_buffer_addr = target_module.base_address + 0x8e4
    hook_id = w1.hook_addr(allocate_buffer_addr, function(vm, gpr, fpr, address)
        -- extract single argument
        local size = w1.get_arg(vm, gpr, fpr, 1)
        
        if size then
            w1.log_info(string.format("[allocate_buffer] size=%d bytes", size))
        end
        
        return w1.VMAction.CONTINUE
    end)
    
    if hook_id then
        w1.log_info(string.format("✓ hooked allocate_buffer at 0x%x", allocate_buffer_addr))
    end
    
    -- hook unsafe_copy using module+offset for security monitoring
    local unsafe_copy_hook = w1.hook_module("hook_test_target", 0x98c, function(vm, gpr, fpr, address)
        -- extract two pointer arguments portably
        local args = w1.get_args(vm, gpr, fpr, 2)
        
        if args then
            -- read source content to detect potentially dangerous operations
            local src_content = w1.read_string(vm, args[2], 256)
            
            if src_content then
                w1.log_warning(string.format("[unsafe_copy] security risk! copying '%s'", src_content))
            end
        end
        
        return w1.VMAction.CONTINUE
    end)
    
    if unsafe_copy_hook then
        w1.log_info("✓ hooked unsafe_copy for security monitoring")
    end
    
    w1.log_info("")
    w1.log_info("ready to trace")
end

tracer.callbacks = {}

return tracer
```

`scripts/w1script/hook_demo_sig.lua`:

```lua
-- hook_demo_sig.lua
-- cross-platform hooking demonstration using signature-based function discovery
-- automatically finds functions by their unique assembly signatures
-- supports x86_64 and aarch64 architectures
--
-- approach:
-- 1. use p1.search_signature() to find functions by their unique byte patterns
-- 2. filter results to specific modules to avoid false positives
-- 3. hook found addresses with w1.hook_addr()
--
-- signature format:
-- - lowercase hex bytes grouped by instruction (e.g., "202282d2 e0ddb7f2 a0d5dbf2")
-- - supports wildcards with ?? for flexible matching (e.g., "????82d2" matches any mov)
--
-- run with:
-- ./build-release/w1tool tracer -n w1script \
--   -c script=./scripts/w1script/hook_demo_sig.lua \
--   -s ./build-release/tests/programs/hook_test_target
local tracer = {}

-- ============================================================================
-- register mappings
-- ============================================================================

-- platform-specific register mappings for different architectures and calling conventions
local REGISTERS = {
    aarch64 = {
        args = {"x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7"},
        sp = "sp",
        ret = "x0"
    },
    x86_64 = {
        linux = {
            args = {"rdi", "rsi", "rdx", "rcx", "r8", "r9"},
            sp = "rsp",
            ret = "rax"
        },
        macos = {
            args = {"rdi", "rsi", "rdx", "rcx", "r8", "r9"},
            sp = "rsp",
            ret = "rax"
        },
        windows = {
            args = {"rcx", "rdx", "r8", "r9"},
            sp = "rsp",
            ret = "rax"
        }
    },
    x86 = {
        sp = "esp",
        ret = "eax" -- x86 typically uses stack for args
    },
    arm = {
        args = {"r0", "r1", "r2", "r3"},
        sp = "sp",
        ret = "r0"
    }
}

-- ============================================================================
-- utility functions
-- ============================================================================

-- get platform-specific registers based on architecture and OS
local function get_platform_regs(plat_info)
    local arch_regs = REGISTERS[plat_info.arch]
    if not arch_regs then
        return nil
    end

    -- aarch64 and arm use same regs across all OS
    if plat_info.arch == "aarch64" or plat_info.arch == "arm" then
        return arch_regs
    end

    -- x86_64 differs by OS
    if plat_info.arch == "x86_64" then
        return arch_regs[plat_info.os] or arch_regs.linux
    end

    return arch_regs
end

-- get argument register by index (1-based)
local function get_arg_reg(regs, n)
    if regs and regs.args and regs.args[n] then
        return regs.args[n]
    end
    return nil
end

-- helper to build wildcard patterns with specified gap size
local function wildcards(count)
    local pattern = ""
    for i = 1, count do
        pattern = pattern .. " ????????"
    end
    return pattern
end

-- ============================================================================
-- signature definitions
-- ============================================================================

-- define platform-specific signatures for each function
local function get_signatures(plat_info)
    local signatures = {}

    if plat_info.arch == "x86_64" then
        if plat_info.os == "windows" then
            -- windows msvc x64 pattern:
            -- all functions start with mov rax, 0xdeadbeefcafebabe
            -- followed by xor operations and function-specific code
            local msvc_base = "48b8 bebafecaefbeadde" -- mov rax, 0xdeadbeefcafebabe

            -- distinguish functions by their unique operations after the prologue
            signatures.calculate_secret = "48895c2408 57 4883ec20 48b8bebafecaefbeadde 8bfa 4889442440"
            signatures.format_message = "4053 4883ec40 48b8bebafecaefbeadde 488bd9 4889442468 48b8efbeaddebebafeca"
            signatures.allocate_buffer = "48895c2408 57 4883ec20 48b8bebafecaefbeadde 488bf9 4889442438"
            signatures.compare_strings = "48895c2408 57 4883ec20 48b8bebafecaefbeadde 488bda 4889442440"
            signatures.unsafe_copy = "4053 4883ec20 48b8bebafecaefbeadde 488bd9 4889442440"

            w1.log_info("using msvc x64 signatures")
        else
            -- gcc/clang use inline assembly with unique constants
            -- movabs $0xDEADBEEF0000XXXX, %rax
            signatures.calculate_secret = "48b8 11110000efbeadde" -- 0xDEADBEEF00001111
            signatures.format_message = "48b8 22220000efbeadde" -- 0xDEADBEEF00002222
            signatures.allocate_buffer = "48b8 33330000efbeadde" -- 0xDEADBEEF00003333
            signatures.compare_strings = "48b8 44440000efbeadde" -- 0xDEADBEEF00004444
            signatures.unsafe_copy = "48b8 55550000efbeadde" -- 0xDEADBEEF00005555

            w1.log_info("using gcc/clang x64 signatures")
        end
    elseif plat_info.arch == "aarch64" then
        -- aarch64: three instruction sequence to load 48-bit constant
        -- mov x0, #imm16; movk x0, #0xbeef, lsl #16; movk x0, #0xdead, lsl #32
        signatures.calculate_secret = "202282d2 e0ddb7f2 a0d5dbf2" -- 0x1111
        signatures.format_message = "404484d2 e0ddb7f2 a0d5dbf2" -- 0x2222
        signatures.allocate_buffer = "606686d2 e0ddb7f2 a0d5dbf2" -- 0x3333
        signatures.compare_strings = "808888d2 e0ddb7f2 a0d5dbf2" -- 0x4444
        signatures.unsafe_copy = "a0aa8ad2 e0ddb7f2 a0d5dbf2" -- 0x5555

        w1.log_info("using aarch64 signatures")
    end

    return signatures
end

-- ============================================================================
-- hooking functions
-- ============================================================================

-- search for a signature and hook the found address
local function hook_signature(name, pattern, filter, handler)
    w1.log_info(string.format("searching for %s signature...", name))

    local search_results = p1.search_signature(pattern, filter)
    if not search_results or #search_results == 0 then
        w1.log_error(string.format("failed to find %s signature", name))
        return false
    end

    w1.log_info(string.format("found %d matches for %s signature", #search_results, name))

    -- only hook if we found exactly one match
    if #search_results ~= 1 then
        w1.log_warning(string.format("found multiple matches (%d) for %s, expected 1", #search_results, name))
        for i, result in ipairs(search_results) do
            w1.log_info(string.format("  match %d: address=0x%x", i, result.address))
        end
        return false
    end

    local addr = search_results[1].address
    w1.log_info(string.format("  hooking %s at 0x%x", name, addr))

    local hook_id = w1.hook_addr(addr, handler)
    if hook_id then
        w1.log_info(string.format("✓ hooked %s using signature", name))
        return true
    else
        w1.log_error(string.format("failed to hook %s at 0x%x", name, addr))
        return false
    end
end

-- ============================================================================
-- hook handlers
-- ============================================================================

-- create hook handlers for each function
local function create_handlers(regs)
    local handlers = {}

    handlers.calculate_secret = function(vm, gpr, fpr, address)
        local a = w1.get_reg(gpr, get_arg_reg(regs, 1))
        local b = w1.get_reg(gpr, get_arg_reg(regs, 2))
        w1.log_info(string.format("[hook:calculate_secret] a=%d, b=%d, result=%d", a, b, 3 * a + 2 * b))
        return w1.VMAction.CONTINUE
    end

    handlers.format_message = function(vm, gpr, fpr, address)
        local buffer_ptr = w1.get_reg(gpr, get_arg_reg(regs, 1))
        local name_ptr = w1.get_reg(gpr, get_arg_reg(regs, 2))
        local value = w1.get_reg(gpr, get_arg_reg(regs, 3))
        local name_str = w1.read_string(vm, name_ptr, 256)
        if name_str then
            w1.log_info(string.format("[hook:format_message] name='%s', value=%d", name_str, value))
        end
        return w1.VMAction.CONTINUE
    end

    handlers.compare_strings = function(vm, gpr, fpr, address)
        local str1_ptr = w1.get_reg(gpr, get_arg_reg(regs, 1))
        local str2_ptr = w1.get_reg(gpr, get_arg_reg(regs, 2))
        local str1 = w1.read_string(vm, str1_ptr, 256)
        local str2 = w1.read_string(vm, str2_ptr, 256)
        if str1 and str2 then
            w1.log_info(string.format("[hook:compare_strings] '%s' vs '%s'", str1, str2))
        end
        return w1.VMAction.CONTINUE
    end

    handlers.allocate_buffer = function(vm, gpr, fpr, address)
        local size = w1.get_reg(gpr, get_arg_reg(regs, 1))
        w1.log_info(string.format("[hook:allocate_buffer] size=%d bytes", size))
        return w1.VMAction.CONTINUE
    end

    handlers.unsafe_copy = function(vm, gpr, fpr, address)
        local dst = w1.get_reg(gpr, get_arg_reg(regs, 1))
        local src = w1.get_reg(gpr, get_arg_reg(regs, 2))
        local src_content = w1.read_string(vm, src, 256)
        if src_content then
            w1.log_warning(string.format("[hook:unsafe_copy] security risk! copying '%s'", src_content))
        end
        return w1.VMAction.CONTINUE
    end

    return handlers
end

-- ============================================================================
-- main initialization
-- ============================================================================

function tracer.init()
    w1.log_info("=== hook demonstration - signature-based hooking ===")

    -- detect platform
    local plat_info = w1.get_platform_info()
    w1.log_info("platform information:")
    w1.log_info(string.format("  os: %s", plat_info.os))
    w1.log_info(string.format("  architecture: %s", plat_info.arch))
    w1.log_info(string.format("  bits: %d", plat_info.bits))

    -- get platform registers
    local regs = get_platform_regs(plat_info)
    if regs and regs.args then
        w1.log_info(string.format("  calling convention: %s", plat_info.arch == "x86_64" and plat_info.os or "standard"))
        w1.log_info(string.format("  argument registers: %s", table.concat(regs.args, ", ")))
        w1.log_info(string.format("  return register: %s", regs.ret))
    else
        w1.log_info("  calling convention: stack-based")
    end
    w1.log_info("")

    -- find target module
    local modules = w1.module_list_all()
    local target_module = nil

    for _, mod in pairs(modules) do
        if string.find(mod.path, "hook_test_target") then
            target_module = mod
            break
        end
    end

    if not target_module then
        w1.log_error("target module 'hook_test_target' not found")
        return
    end

    w1.log_info(string.format("target module: %s", target_module.path))
    w1.log_info(string.format("base address: 0x%x", target_module.base_address))
    w1.log_info("")

    -- check p1 module availability
    w1.log_info("checking p1 module availability...")
    if not p1 or not p1.search_signature then
        w1.log_error("p1 module or search_signature function not available!")
        return
    end
    w1.log_info("p1 module ready")

    -- get signatures for this platform
    local signatures = get_signatures(plat_info)
    if not signatures or not next(signatures) then
        w1.log_error("no signatures defined for this platform")
        return
    end

    -- create handlers
    local handlers = create_handlers(regs)

    -- hook all functions
    local functions = {"calculate_secret", "format_message", "compare_strings", "allocate_buffer", "unsafe_copy"}

    for _, func in ipairs(functions) do
        if signatures[func] and handlers[func] then
            hook_signature(func, signatures[func], "hook_test_target", handlers[func])
        end
    end

    w1.log_info("")
    w1.log_info("ready to trace")
end

tracer.callbacks = {}

return tracer

```

`scripts/w1script/instruction_tracer.lua`:

```lua
-- instruction tracer with disassembly
-- logs every instruction with address and assembly code

local instruction_count = 0

local tracer = {}
tracer.callbacks = { "instruction_postinst" }

function tracer.on_instruction_postinst(vm, gpr, fpr)
    instruction_count = instruction_count + 1
    
    -- get program counter and disassembly
    local pc = w1.get_reg_pc and w1.get_reg_pc(gpr) or 0
    local disasm = w1.get_disassembly(vm)
    
    -- log instruction with address and disassembly
    w1.log_info(w1.format_address(pc) .. ": " .. disasm)
    
    return w1.VMAction.CONTINUE
end

function tracer.shutdown()
    w1.log_info("traced " .. instruction_count .. " instructions")
end

return tracer
```

`scripts/w1script/jsonl_tracer.lua`:

```lua
-- jsonl tracer
-- demonstrates jsonl streaming output for execution tracing

local tracer = {}
tracer.callbacks = { "basic_block_entry", "exec_transfer_call", "exec_transfer_return" }

local stats = {
    blocks = 0,
    calls = 0,
    returns = 0
}

function tracer.init()
    w1.output.init(config.output or "trace.jsonl", {
        tracer = "jsonl_tracer",
        version = "1.0"
    })
end

function tracer.on_basic_block_entry(vm, state, gpr, fpr)
    stats.blocks = stats.blocks + 1
    
    -- write block events for new blocks only
    if stats.blocks <= 100 then
        w1.output.write_event({
            type = "block",
            address = w1.format_address(state.basicBlockStart),
            size = state.basicBlockEnd - state.basicBlockStart
        })
    end
    
    return w1.VMAction.CONTINUE
end

function tracer.on_exec_transfer_call(vm, state, gpr, fpr)
    stats.calls = stats.calls + 1
    
    w1.output.write_event({
        type = "call",
        from = w1.format_address(state.sequenceStart),
        to = w1.format_address(w1.get_reg_pc(gpr)),
        from_module = w1.module_get_name(state.sequenceStart),
        to_module = w1.module_get_name(w1.get_reg_pc(gpr))
    })
    
    return w1.VMAction.CONTINUE
end

function tracer.on_exec_transfer_return(vm, state, gpr, fpr)
    stats.returns = stats.returns + 1
    
    w1.output.write_event({
        type = "return",
        from = w1.format_address(state.sequenceStart),
        to = w1.format_address(w1.get_reg_pc(gpr)),
        from_module = w1.module_get_name(state.sequenceStart)
    })
    
    return w1.VMAction.CONTINUE
end

function tracer.shutdown()
    w1.output.write_event({
        type = "stats",
        total_blocks = stats.blocks,
        total_calls = stats.calls,
        total_returns = stats.returns
    })
    
    w1.log_info("trace complete: " .. stats.blocks .. " blocks, " .. stats.calls .. " calls, " .. stats.returns .. " returns")
end

-- setup shutdown handler in init
local original_init = tracer.init
tracer.init = function()
    original_init()
    w1.output.ensure_shutdown_handler(tracer)
end

return tracer
```

`scripts/w1script/macos_api_monitor_demo.lua`:

```lua
-- macos api monitoring demo
-- demonstrates real-time api tracing with semantic analysis on macos
-- requires: DYLD_SHARED_CACHE_DUMP_DIR=/tmp/libraries for symbol resolution

local tracer = {}

-- specify which QBDI callbacks we need
tracer.callbacks = { "exec_transfer_call", "exec_transfer_return" }

-- statistics tracking
local stats = {
    total_calls = 0,
    by_category = {},
    by_module = {}
}

-- initialize api monitoring callbacks
function tracer.init()
    w1.log_info("initializing macos api monitor")
    
    -- monitor printf with detailed argument analysis
    tracer.register_api_symbol_callback("libsystem_c.dylib", "_printf", function(event)
        if event.type == "call" then
            local msg = string.format("[printf] called from %s -> %s", 
                w1.format_address(event.source_address),
                w1.format_address(event.target_address))
            w1.log_info(msg)
            
            -- show arguments if available
            if #event.arguments > 0 then
                for i, arg in ipairs(event.arguments) do
                    local param_info = string.format("  arg[%d] %s: %s (%s)", 
                        i, arg.param_name or "param", 
                        arg.interpreted_value, 
                        arg.is_pointer and "ptr" or "val")
                    w1.log_info(param_info)
                end
            end
        elseif event.type == "return" then
            if event.return_value then
                w1.log_info(string.format("[printf] returned: %s", 
                    event.return_value.interpreted_value))
            end
        end
    end)
    
    tracer.register_api_symbol_callback("libsystem_c.dylib", "_puts", function(event)
        if event.type == "call" then
            w1.log_info("[stdio] " .. event.formatted_call)
        end
    end)
    
    -- monitor heap operations with allocation tracking
    local allocations = {}
    tracer.register_api_category_callback(w1.API_CATEGORY.HEAP_MANAGEMENT, function(event)
        if event.type == "call" then
            if event.symbol_name == "_malloc" then
                local size = event.arguments[1] and event.arguments[1].raw_value or 0
                w1.log_info(string.format("[heap] malloc(%d bytes)", size))
            elseif event.symbol_name == "_free" then
                local ptr = event.arguments[1] and event.arguments[1].interpreted_value or "null"
                w1.log_info("[heap] free(" .. ptr .. ")")
            elseif event.symbol_name == "_calloc" then
                local count = event.arguments[1] and event.arguments[1].raw_value or 0
                local size = event.arguments[2] and event.arguments[2].raw_value or 0
                w1.log_info(string.format("[heap] calloc(%d, %d) = %d bytes", count, size, count * size))
            end
        elseif event.type == "return" and event.symbol_name == "_malloc" then
            if event.return_value then
                local ptr = event.return_value.interpreted_value
                local size = event.arguments[1] and event.arguments[1].raw_value or 0
                allocations[ptr] = size
                w1.log_info("[heap] malloc returned " .. ptr)
            end
        end
    end)
    
    -- monitor file operations
    tracer.register_api_category_callback(w1.API_CATEGORY.FILE_IO, function(event)
        if event.type == "call" then
            w1.log_info("[file] " .. event.formatted_call)
        end
    end)
    
    -- monitor string operations (often security-relevant)
    tracer.register_api_symbol_callback("libsystem_c.dylib", "_strcpy", function(event)
        if event.type == "call" then
            w1.log_info("[string] " .. event.formatted_call .. " (unsafe)")
        end
    end)
    
    tracer.register_api_symbol_callback("libsystem_c.dylib", "_strncpy", function(event)
        if event.type == "call" then
            w1.log_info("[string] " .. event.formatted_call)
        end
    end)
    
    -- generic api tracking for statistics
    tracer.register_api_module_callback("libsystem_c.dylib", track_api_call)
    tracer.register_api_module_callback("libsystem_malloc.dylib", track_api_call)
    tracer.register_api_module_callback("libsystem_kernel.dylib", track_api_call)
end

-- track api calls for statistics
function track_api_call(event)
    if event.type == "call" then
        stats.total_calls = stats.total_calls + 1
        
        -- track by category using the built-in utility
        local cat_name = w1.api_category_name(event.category)
        stats.by_category[cat_name] = (stats.by_category[cat_name] or 0) + 1
        
        -- track by module
        stats.by_module[event.module_name] = (stats.by_module[event.module_name] or 0) + 1
    end
end

-- qbdi callbacks: api monitoring works by intercepting execution transfers
-- (calls and returns between functions). we must register these callbacks
-- for qbdi to instrument the code and detect when functions are called.
-- the api analysis happens automatically when these transfers occur.
tracer.callbacks = { "exec_transfer_call", "exec_transfer_return" }

function tracer.on_exec_transfer_call(vm, state, gpr, fpr)
    -- the actual api analysis happens automatically in the c++ layer
    -- when execution transfers are detected. we just need this callback
    -- to enable qbdi's transfer detection instrumentation.
    return w1.VMAction.CONTINUE
end

function tracer.on_exec_transfer_return(vm, state, gpr, fpr)
    -- same as above - enables detection of function returns
    return w1.VMAction.CONTINUE
end

-- summary on shutdown
function tracer.shutdown()
    w1.log_info("")
    w1.log_info("=== api monitoring summary ===")
    w1.log_info("total api calls: " .. stats.total_calls)
    
    if next(stats.by_category) then
        w1.log_info("")
        w1.log_info("calls by category:")
        for cat, count in pairs(stats.by_category) do
            w1.log_info(string.format("  %-12s: %d", cat, count))
        end
    end
    
    if next(stats.by_module) then
        w1.log_info("")
        w1.log_info("calls by module:")
        for mod, count in pairs(stats.by_module) do
            w1.log_info(string.format("  %-30s: %d", mod, count))
        end
    end
end

return tracer
```

`scripts/w1script/memory_tracer.lua`:

```lua
-- memory access tracer with values
-- monitors memory read and write operations with detailed logging

local read_count = 0
local write_count = 0

local tracer = {}
tracer.callbacks = { "instruction_postinst" }

local function log_memory_access(access_type, count, pc, address, size, value, instruction)
    local msg = string.format("%s #%d @ %s [%s] size=%d value=%s inst: %s",
        access_type,
        count,
        w1.format_address(pc),
        w1.format_address(address),
        size,
        value,
        instruction)
    w1.log_info(msg)
end

function tracer.on_instruction_postinst(vm, gpr, fpr)
    local memory_accesses = w1.get_memory_accesses(vm)
    
    if #memory_accesses > 0 then
        local pc = w1.get_reg_pc and w1.get_reg_pc(gpr) or 0
        local instruction = w1.get_disassembly(vm)
        
        for _, access in ipairs(memory_accesses) do
            local formatted_value = w1.format_memory_value(access.value, access.size)
            
            if access.is_read then
                read_count = read_count + 1
                log_memory_access("read", read_count, pc, access.address, 
                                access.size, formatted_value, instruction)
            end
            
            if access.is_write then
                write_count = write_count + 1
                log_memory_access("write", write_count, pc, access.address, 
                                access.size, formatted_value, instruction)
            end
        end
    end
    
    return w1.VMAction.CONTINUE
end

function tracer.shutdown()
    local total_operations = read_count + write_count
    
    w1.log_info("memory operations summary:")
    w1.log_info("  reads: " .. read_count)
    w1.log_info("  writes: " .. write_count)
    w1.log_info("  total: " .. total_operations)
end

return tracer
```

`scripts/w1script/mnem_tracker.lua`:

```lua
-- mnemonic tracker
-- tracks specific instruction mnemonics by architecture (calls, jumps, returns)

local mnemonic_counts = {}
local total_instructions = 0
local matched_instructions = 0
local arch_targets = {}

-- architecture-specific default mnemonics (actual LLVM opcodes)
local default_mnemonics = {
    aarch64 = {"B", "BL", "BR", "BLR", "RET", "BLRAA", "BLRAB", "RETAA", "RETAB"},
    x86_64 = {"CALL64pcrel32", "CALL64r", "CALL64m", "CALL64r_NT", "CALL64m_NT", "JMP64m", "JMP64r", "JMP64m_NT", "JMP64r_NT", "JMP64m_REX", "JMP64r_REX", "JMPABS64i", "JMP_1", "JMP_2", "JMP_4", "RET", "RET64", "LRET64", "IRET64", "SYSRET64", "TAILJMPd64", "TAILJMPr64", "TAILJMPm64", "TAILJMPd64_CC", "TAILJMPm64_REX", "TAILJMPr64_REX", "TCRETURNdi64", "TCRETURNmi64", "TCRETURNri64"},
    x86 = {"CALL32r", "CALL32m", "CALLpcrel32", "CALL32r_NT", "CALL32m_NT", "CALLpcrel16", "CALL16r", "CALL16m", "JMP32m", "JMP32r", "JMP32m_NT", "JMP32r_NT", "JMP16m", "JMP16r", "JMP_1", "JMP_2", "JMP_4", "RET", "RET32", "RET16", "LRET32", "LRET16", "IRET32", "IRET16", "SYSRET", "TAILJMPd", "TAILJMPr", "TAILJMPm", "TAILJMPd_CC", "TCRETURNdi", "TCRETURNmi", "TCRETURNri"}
}

local tracer = {}
tracer.callbacks = {"instruction_preinst"}

function tracer.initialize(custom_targets)
    local arch = w1.get_architecture()
    local targets = custom_targets or default_mnemonics[arch] or default_mnemonics.x86_64
    
    -- build target set for fast lookup
    for _, mnemonic in ipairs(targets) do
        arch_targets[mnemonic] = true
        mnemonic_counts[mnemonic] = 0
    end
    
    w1.log_info("mnemonic tracker initialized for " .. arch .. " with " .. #targets .. " targets")
end

function tracer.on_instruction_preinst(vm, state, gpr, fpr)
    total_instructions = total_instructions + 1
    
    local analysis = w1.get_inst_analysis and w1.get_inst_analysis(vm)
    if not analysis then return w1.VMAction.CONTINUE end
    
    local mnemonic = analysis.mnemonic or ""
    
    if arch_targets[mnemonic] then
        mnemonic_counts[mnemonic] = mnemonic_counts[mnemonic] + 1
        matched_instructions = matched_instructions + 1
    end
    
    return w1.VMAction.CONTINUE
end

function tracer.shutdown()
    local match_rate = total_instructions > 0 and (matched_instructions / total_instructions * 100) or 0
    
    w1.log_info("mnemonic summary:")
    w1.log_info("  total instructions: " .. total_instructions)
    w1.log_info("  matched instructions: " .. matched_instructions)
    w1.log_info("  match rate: " .. string.format("%.1f%%", match_rate))
    
    -- sort and display non-zero counts
    local sorted = {}
    for mnemonic, count in pairs(mnemonic_counts) do
        if count > 0 then
            table.insert(sorted, {mnemonic = mnemonic, count = count})
        end
    end
    table.sort(sorted, function(a, b) return a.count > b.count end)
    
    if #sorted > 0 then
        w1.log_info("  breakdown:")
        for _, entry in ipairs(sorted) do
            local pct = matched_instructions > 0 and (entry.count / matched_instructions * 100) or 0
            w1.log_info("    " .. entry.mnemonic .. ": " .. entry.count .. " (" .. string.format("%.1f%%", pct) .. ")")
        end
    end
end

tracer.initialize()
return tracer
```

`scripts/w1script/symbol_resolver.lua`:

```lua
-- symbol resolution demo
-- resolves and displays symbol information during execution
local first_run = true
local instruction_count = 0
local unique_symbols = {}

local tracer = {}
tracer.callbacks = {"instruction_postinst"}

function tracer.on_instruction_postinst(vm, gpr, fpr)
    instruction_count = instruction_count + 1

    -- get program counter
    local pc = w1.get_reg_pc and w1.get_reg_pc(gpr) or 0

    -- resolve current instruction location
    local sym = w1.symbol_resolve_address(pc)
    if sym then
        unique_symbols[sym.name] = true
        local disasm = w1.get_disassembly(vm)
        w1.log_info(string.format("%s: %s+0x%x: %s", w1.format_address(pc), sym.name, sym.offset, disasm))
    end

    -- on first run, demonstrate other capabilities
    if first_run then
        first_run = false

        -- show backend
        w1.log_info("symbol backend: " .. w1.symbol_get_backend())

        -- resolve common function
        local malloc_addr = w1.symbol_resolve_name("malloc")
        if malloc_addr then
            w1.log_info(string.format("malloc @ %s", w1.format_address(malloc_addr)))
        end
    end

    return w1.VMAction.CONTINUE
end

function tracer.shutdown()
    -- count unique symbols
    local symbol_count = 0
    for _ in pairs(unique_symbols) do
        symbol_count = symbol_count + 1
    end

    w1.log_info(string.format("traced %d instructions in %d unique functions", instruction_count, symbol_count))
end

return tracer

```

`scripts/w1script/wip/config_demo.lua`:

```lua
-- configuration demo
-- shows how to use w1tool tracer config parameters

local instruction_count = 0
local max_instructions = tonumber(config and config.max_instructions) or 100
local sample_rate = tonumber(config and config.sample_rate) or 1

local tracer = {}
tracer.callbacks = { "instruction_postinst" }

function tracer.on_instruction_postinst(vm, gpr, fpr)
    instruction_count = instruction_count + 1
    
    -- sample according to configured rate
    if instruction_count % sample_rate == 0 then
        local pc = w1.get_reg_pc and w1.get_reg_pc(gpr) or 0
        local disassembly = w1.get_disassembly(vm)
        local sample_number = instruction_count / sample_rate
        
        w1.log_info("sample " .. sample_number .. ": " .. 
                    w1.format_address(pc) .. " " .. disassembly)
    end
    
    -- stop at configured limit
    if instruction_count >= max_instructions then
        w1.log_info("reached instruction limit (" .. max_instructions .. "), stopping")
        return w1.VMAction.STOP
    end
    
    return w1.VMAction.CONTINUE
end

function tracer.shutdown()
    local samples_taken = math.floor(instruction_count / sample_rate)
    
    w1.log_info("configuration demo finished:")
    w1.log_info("  total instructions: " .. instruction_count)
    w1.log_info("  max_instructions: " .. max_instructions)  
    w1.log_info("  sample_rate: " .. sample_rate)
    w1.log_info("  samples taken: " .. samples_taken)
end

return tracer
```

`scripts/w1script/wip/memory_demo.lua`:

```lua
-- memory access demo
-- demonstrates safe memory read/write functions

local tracer = {}

function tracer.init()
    w1.log_info("memory demo initializing")
end

-- hook instruction execution to demonstrate memory access
tracer.callbacks = { "instruction_postinst" }

local instruction_count = 0

function tracer.on_instruction_postinst(vm, gpr, fpr)
    instruction_count = instruction_count + 1
    
    -- only check every 1000 instructions to reduce overhead
    if instruction_count % 1000 == 0 then
        -- example: read string from stack
        local sp = w1.get_sp(gpr)
        local str = w1.read_string(vm, sp, 64)
        if str then
            w1.log_info("String at stack pointer: " .. str)
        end
        
        -- example: read memory as hex
        local hex = w1.read_mem_hex(vm, sp, 16)
        if hex then
            w1.log_info("Stack data: " .. hex)
        end
        
        -- example: read typed values
        local ptr = w1.read_ptr(vm, sp)
        if ptr then
            w1.log_info(string.format("Pointer at SP: 0x%x", ptr))
        end
    end
    
    return w1.VMAction.CONTINUE
end

function tracer.shutdown()
    w1.log_info("traced " .. instruction_count .. " instructions")
end

return tracer
```

`scripts/w1script/wip/module_demo.lua`:

```lua
-- module analysis demo
-- demonstrates the new module api functionality

local tracer = {}
tracer.callbacks = { "basic_block_entry" }

local logged_modules = {}
local cache_misses = 0
local cache_hits = 0

function tracer.on_basic_block_entry(vm, state, gpr, fpr)
    local pc = w1.get_reg_pc and w1.get_reg_pc(gpr) or 0
    local module_name = w1.module_get_name(pc)
    
    -- check for cache miss (unknown module) and try one rescan
    -- this handles dynamic loading where modules appear after initial scan
    if module_name == "unknown" then
        cache_misses = cache_misses + 1
        
        -- try rescanning once to detect newly loaded modules
        w1.log_info("cache miss for " .. w1.format_address(pc) .. ", rescanning modules...")
        if w1.module_scan() then
            -- try lookup again after rescan
            module_name = w1.module_get_name(pc)
            if module_name ~= "unknown" then
                w1.log_info("rescan resolved: " .. w1.format_address(pc) .. " -> " .. module_name)
            else
                w1.log_info("rescan failed to resolve " .. w1.format_address(pc))
            end
        else
            w1.log_info("rescan failed")
        end
    else
        cache_hits = cache_hits + 1
    end
    
    -- log each unique module only once
    if not logged_modules[module_name] then
        logged_modules[module_name] = true
        
        -- get full module info for detailed logging
        local module_info = w1.module_get_info(pc)
        if module_info then
            w1.log_info("discovered module: " .. module_name)
            w1.log_info("  path: " .. module_info.path)
            w1.log_info("  base: " .. w1.format_address(module_info.base_address))
            w1.log_info("  size: " .. module_info.size .. " bytes")
            w1.log_info("  type: " .. module_info.type)
            w1.log_info("  system: " .. tostring(module_info.is_system))
        else
            w1.log_info("discovered module: " .. module_name .. " (no detailed info available)")
        end
    end
    
    return w1.VMAction.CONTINUE
end

function tracer.shutdown()
    local module_count = w1.module_count()
    local unique_discovered = 0
    for _ in pairs(logged_modules) do
        unique_discovered = unique_discovered + 1
    end
    
    w1.log_info("module discovery summary:")
    w1.log_info("  total modules discovered: " .. module_count)
    w1.log_info("  unique modules executed: " .. unique_discovered)
    w1.log_info("  cache hits: " .. cache_hits)
    w1.log_info("  cache misses: " .. cache_misses)
    
    -- demonstrate module listing API
    w1.log_info("listing all discovered modules:")
    local all_modules = w1.module_list_all()
    for i, module in ipairs(all_modules) do
        if i <= 5 then  -- only show first 5 to avoid spam
            w1.log_info("  " .. i .. ". " .. module.name .. " (" .. module.type .. ")")
        end
    end
    if #all_modules > 5 then
        w1.log_info("  ... and " .. (#all_modules - 5) .. " more modules")
    end
end

return tracer
```

`scripts/w1script/wip/vmstate_example.lua`:

```lua
-- example showing how to access vmstate fields
-- this demonstrates the fix for vmstate userdata access

local event_counts = {}

local tracer = {}
tracer.callbacks = { "basic_block_entry", "sequence_entry", "exec_transfer_call", "exec_transfer_return" }

function tracer.on_basic_block_entry(vm, state, gpr, fpr)
    -- access vmstate fields directly
    local event = state.event
    local bb_start = state.basicBlockStart
    local bb_end = state.basicBlockEnd
    
    -- count events
    event_counts[event] = (event_counts[event] or 0) + 1
    
    -- log first few basic block entries
    if event_counts[event] <= 5 then
        w1.log_info("bb entry: " .. w1.format_address(bb_start) .. " (event: " .. event .. ")")
    end
    
    return w1.VMAction.CONTINUE
end

function tracer.on_sequence_entry(vm, state, gpr, fpr)
    -- access vmstate fields
    local event = state.event
    local seq_start = state.sequenceStart
    local seq_end = state.sequenceEnd
    
    -- count events
    event_counts[event] = (event_counts[event] or 0) + 1
    
    -- log first few sequence entries
    if event_counts[event] <= 3 then
        w1.log_info("sequence entry: " .. w1.format_address(seq_start) .. " -> " .. w1.format_address(seq_end) .. " (event: " .. event .. ")")
    end
    
    return w1.VMAction.CONTINUE
end

function tracer.on_exec_transfer_call(vm, state, gpr, fpr)
    -- access vmstate fields for call transfers
    local event = state.event
    local bb_start = state.basicBlockStart
    
    event_counts[event] = (event_counts[event] or 0) + 1
    
    if event_counts[event] <= 3 then
        w1.log_info("call transfer at: " .. w1.format_address(bb_start) .. " (event: " .. event .. ")")
    end
    
    return w1.VMAction.CONTINUE
end

function tracer.on_exec_transfer_return(vm, state, gpr, fpr)
    -- access vmstate fields for return transfers
    local event = state.event
    local bb_start = state.basicBlockStart
    
    event_counts[event] = (event_counts[event] or 0) + 1
    
    if event_counts[event] <= 3 then
        w1.log_info("return transfer at: " .. w1.format_address(bb_start) .. " (event: " .. event .. ")")
    end
    
    return w1.VMAction.CONTINUE
end

function tracer.shutdown()
    w1.log_info("vmstate example completed:")
    for event, count in pairs(event_counts) do
        w1.log_info("  event " .. event .. ": " .. count .. " times")
    end
end

return tracer
```

`scripts/w1script/xfer_tracker.lua`:

```lua
-- execution transfer tracker
-- tracks function calls and returns with detailed logging and module info

local call_stack = {}
local total_calls = 0
local total_returns = 0
local unique_call_targets = {}
local unique_return_sources = {}
local max_call_depth = 0
local current_call_depth = 0
local module_call_stats = {}
local module_return_stats = {}

local tracer = {}
tracer.callbacks = { "exec_transfer_call", "exec_transfer_return" }

function tracer.on_exec_transfer_call(vm, state, gpr, fpr)
    local pc = w1.get_reg_pc and w1.get_reg_pc(gpr) or 0
    local source_addr = w1.format_address(state.sequenceStart)
    local target_addr = w1.format_address(pc)
    
    -- get module names for source and target addresses
    local source_module = w1.module_get_name(state.sequenceStart)
    local target_module = w1.module_get_name(pc)
    
    total_calls = total_calls + 1
    current_call_depth = current_call_depth + 1
    
    -- track unique call targets for statistics
    if not unique_call_targets[target_addr] then
        unique_call_targets[target_addr] = true
    end
    
    -- track module statistics for call analysis
    module_call_stats[target_module] = (module_call_stats[target_module] or 0) + 1
    
    -- update max call depth
    if current_call_depth > max_call_depth then
        max_call_depth = current_call_depth
    end
    
    -- push call info onto stack for return matching
    table.insert(call_stack, {
        source = source_addr,
        target = target_addr,
        source_module = source_module,
        target_module = target_module,
        depth = current_call_depth
    })
    
    -- log the call transfer with module info
    w1.log_info("call: " .. source_addr .. " (" .. source_module .. ") -> " .. target_addr .. " (" .. target_module .. ") (depth: " .. current_call_depth .. ")")
    
    return w1.VMAction.CONTINUE
end

function tracer.on_exec_transfer_return(vm, state, gpr, fpr)
    local pc = w1.get_reg_pc and w1.get_reg_pc(gpr) or 0
    local source_addr = w1.format_address(state.sequenceStart)
    local target_addr = w1.format_address(pc)
    
    -- get module names for source and target addresses
    local source_module = w1.module_get_name(state.sequenceStart)
    local target_module = w1.module_get_name(pc)
    
    total_returns = total_returns + 1
    current_call_depth = math.max(0, current_call_depth - 1)
    
    -- track unique return sources for statistics
    if not unique_return_sources[source_addr] then
        unique_return_sources[source_addr] = true
    end
    
    -- track module statistics for return analysis
    module_return_stats[source_module] = (module_return_stats[source_module] or 0) + 1
    
    -- pop from call stack if available for return matching
    local call_info = nil
    if #call_stack > 0 then
        call_info = table.remove(call_stack)
    end
    
    -- log the return transfer with module info
    if call_info then
        w1.log_info("return: " .. source_addr .. " (" .. source_module .. ") -> " .. target_addr .. " (" .. target_module .. ") (from call " .. call_info.source_module .. " -> " .. call_info.target_module .. " at depth " .. call_info.depth .. ")")
    else
        w1.log_info("return: " .. source_addr .. " (" .. source_module .. ") -> " .. target_addr .. " (" .. target_module .. ") (unmatched return)")
    end
    
    return w1.VMAction.CONTINUE
end

function tracer.shutdown()
    local unique_call_count = 0
    for _ in pairs(unique_call_targets) do
        unique_call_count = unique_call_count + 1
    end
    
    local unique_return_count = 0
    for _ in pairs(unique_return_sources) do
        unique_return_count = unique_return_count + 1
    end
    
    w1.log_info("execution transfer summary:")
    w1.log_info("  total calls: " .. total_calls)
    w1.log_info("  total returns: " .. total_returns)
    w1.log_info("  unique call targets: " .. unique_call_count)
    w1.log_info("  unique return sources: " .. unique_return_count)
    w1.log_info("  max call depth: " .. max_call_depth)
    w1.log_info("  final call depth: " .. current_call_depth)
    w1.log_info("  unmatched calls: " .. #call_stack)
    w1.log_info("  total modules discovered: " .. w1.module_count())
    
    -- log module call statistics
    w1.log_info("module call statistics:")
    for module, count in pairs(module_call_stats) do
        w1.log_info("  " .. module .. ": " .. count .. " calls")
    end
    
    -- log module return statistics  
    w1.log_info("module return statistics:")
    for module, count in pairs(module_return_stats) do
        w1.log_info("  " .. module .. ": " .. count .. " returns")
    end
end

return tracer
```

`src/p01s0n/CMakeLists.txt`:

```txt
# p01s0n - preload injection library for dynamic patching
# this library gets injected into target processes and applies patches at runtime

cmake_minimum_required(VERSION 3.18)

# check if lua scripting is enabled (required for p01s0n)
include(${WITNESS_SOURCE_DIR}/cmake/LuaConfig.cmake)

if(WITNESS_SCRIPT)
    include(${WITNESS_SOURCE_DIR}/cmake/CommonConfig.cmake)

    # build as shared library for injection
    add_library(p01s0n SHARED
        p01s0n.cpp
        p01s0n.hpp
    )

    # configure lua integration like p1ll
    configure_target_with_lua(p01s0n)

    # link p1ll as static library
    target_link_libraries(p01s0n PRIVATE
        p1ll
        redlog::redlog
    )

    # include directories
    target_include_directories(p01s0n PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}
        ${WITNESS_SOURCE_DIR}/src
    )

    # apply common configuration like other w1 libraries
    apply_common_compile_options(p01s0n)
    apply_windows_definitions(p01s0n)
    set_standard_output_dirs(p01s0n)

    # remove lib prefix and set platform-specific properties like tracers
    set_target_properties(p01s0n PROPERTIES 
        PREFIX ""  # no lib prefix
        POSITION_INDEPENDENT_CODE ON
    )

    if(APPLE)
        set_target_properties(p01s0n PROPERTIES MACOSX_RPATH TRUE)
    elseif(UNIX)
        target_link_libraries(p01s0n PRIVATE dl)
    endif()

    # export symbols for dynamic loading
    if(WIN32)
        target_compile_definitions(p01s0n PRIVATE
            P01S0N_EXPORTS
        )
    endif()

    # install target
    install(TARGETS p01s0n
        LIBRARY DESTINATION lib
        RUNTIME DESTINATION bin
    )
    
    message(STATUS "p01s0n dynamic injection library configured")
    
else()
    message(STATUS "p01s0n library skipped - lua scripting not enabled")
endif()
```

`src/p01s0n/p01s0n.cpp`:

```cpp
#include "p01s0n.hpp"
#include "p01s0n_config.hpp"

#include <cstdlib>
#include <iostream>
#include <filesystem>

#include <redlog.hpp>
#include "p1ll/p1ll.hpp"
#include "p1ll/core/context.hpp"

#include "p1ll/scripting/lua_api.hpp"

namespace p01s0n {

int p01s0n_run() {
  // get config from environment
  p01s0n_config config = p01s0n_config::from_environment();

  // set log level based on verbose setting
  if (config.verbose >= 4) {
    redlog::set_level(redlog::level::pedantic);
  } else if (config.verbose >= 3) {
    redlog::set_level(redlog::level::debug);
  } else if (config.verbose >= 2) {
    redlog::set_level(redlog::level::trace);
  } else if (config.verbose >= 1) {
    redlog::set_level(redlog::level::verbose);
  } else {
    redlog::set_level(redlog::level::info);
  }

  auto log = redlog::get_logger("p01s0n");

  log.inf("p01s0n dynamic patcher starting");

  // check for P1LL_CURE environment variable
  const char* cure_script_path = std::getenv("P1LL_CURE");
  if (!cure_script_path || strlen(cure_script_path) == 0) {
    log.warn("P1LL_CURE environment variable not set - no cure script to apply");
    return 0; // not an error, just nothing to do
  }

  std::string script_path(cure_script_path);
  log.inf("found cure script", redlog::field("path", script_path));

  // validate script file exists
  if (!std::filesystem::exists(script_path)) {
    log.err("cure script file does not exist", redlog::field("path", script_path));
    return 1;
  }

  try {
    // create dynamic context for in-memory patching
    auto context = p1ll::core::p1ll_context::create_dynamic();
    p1ll::core::set_current_context(std::move(context));

    log.inf("executing dynamic cure script", redlog::field("script", script_path));

    // execute the cure script in dynamic mode
    p1ll::scripting::lua_api lua_engine;
    auto result = lua_engine.execute_cure_script(script_path);

    // clean up context
    p1ll::core::clear_current_context();

    if (result.success) {
      log.inf(
          "dynamic cure completed successfully", redlog::field("patches_applied", result.patches_applied),
          redlog::field("patches_failed", result.patches_failed)
      );

      if (result.patches_applied > 0) {
        std::cout << "p01s0n: applied " << result.patches_applied << " patches successfully" << std::endl;
      }

      return 0;
    } else {
      log.err(
          "dynamic cure failed", redlog::field("patches_applied", result.patches_applied),
          redlog::field("patches_failed", result.patches_failed),
          redlog::field("error_count", result.error_messages.size())
      );

      for (const auto& error : result.error_messages) {
        log.err("cure error", redlog::field("message", error));
        std::cerr << "p01s0n error: " << error << std::endl;
      }

      return 1;
    }

  } catch (const std::exception& e) {
    log.err("exception during dynamic cure", redlog::field("what", e.what()));
    std::cerr << "p01s0n exception: " << e.what() << std::endl;
    return 1;
  }
}

} // namespace p01s0n

// platform-specific library initializers
#ifdef _WIN32
// windows dll entry point
#include <windows.h>

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
  switch (ul_reason_for_call) {
  case DLL_PROCESS_ATTACH:
    // run p01s0n when dll is loaded
    p01s0n::p01s0n_run();
    break;
  case DLL_THREAD_ATTACH:
  case DLL_THREAD_DETACH:
  case DLL_PROCESS_DETACH:
    break;
  }
  return TRUE;
}

#else
// unix (darwin/linux) constructor attribute
__attribute__((constructor)) static void p01s0n_init() {
  // run p01s0n when shared library is loaded
  p01s0n::p01s0n_run();
}

#endif
```

`src/p01s0n/p01s0n.hpp`:

```hpp
#pragma once

#include <string>

#ifdef _WIN32
#define P01S0N_API __declspec(dllexport)
#else
#define P01S0N_API __attribute__((visibility("default")))
#endif

namespace p01s0n {

/**
 * @brief Main entry point for p01s0n dynamic patching
 *
 * This function is called automatically when the library is loaded
 * via preload injection. It reads the P1LL_CURE environment variable
 * and applies the specified cure script to the current process.
 *
 * @return 0 on success, non-zero on failure
 */
P01S0N_API int p01s0n_run();

} // namespace p01s0n
```

`src/p01s0n/p01s0n_config.hpp`:

```hpp
#pragma once

#include <string>
#include <cstdlib>
#include <cstring>

namespace p01s0n {

struct p01s0n_config {
  int verbose = 0;
  std::string output_dir = "";
  bool log_api_calls = true;
  bool dump_on_signal = true;

  static p01s0n_config from_environment() {
    p01s0n_config config;

    // parse verbose level
    const char* verbose_env = std::getenv("POISON_VERBOSE");
    if (verbose_env && strlen(verbose_env) > 0) {
      config.verbose = std::atoi(verbose_env);
    }

    // parse output directory
    const char* output_dir_env = std::getenv("POISON_OUTPUT_DIR");
    if (output_dir_env && strlen(output_dir_env) > 0) {
      config.output_dir = std::string(output_dir_env);
    }

    // parse api call logging flag
    const char* log_api_env = std::getenv("POISON_LOG_API_CALLS");
    if (log_api_env && strlen(log_api_env) > 0) {
      config.log_api_calls =
          (std::strcmp(log_api_env, "0") != 0 && std::strcmp(log_api_env, "false") != 0 &&
           std::strcmp(log_api_env, "FALSE") != 0);
    }

    // parse signal dump flag
    const char* dump_signal_env = std::getenv("POISON_DUMP_ON_SIGNAL");
    if (dump_signal_env && strlen(dump_signal_env) > 0) {
      config.dump_on_signal =
          (std::strcmp(dump_signal_env, "0") != 0 && std::strcmp(dump_signal_env, "false") != 0 &&
           std::strcmp(dump_signal_env, "FALSE") != 0);
    }

    return config;
  }
};

} // namespace p01s0n
```

`src/p1ll/CMakeLists.txt`:

```txt
# p1ll binary patching library

# check if lua scripting is enabled
include(${WITNESS_SOURCE_DIR}/cmake/LuaConfig.cmake)

if(WITNESS_SCRIPT)
    
    # core p1ll library sources
    set(P1LL_SOURCES
        # core implementation
        core/platform.cpp
        core/signature.cpp
        core/context.cpp
        
        # engine implementation
        engine/pattern_matcher.cpp
        engine/memory_scanner.cpp
        engine/auto_cure.cpp
        
        # utility implementation
        utils/hex_utils.cpp
        utils/file_utils.cpp
        utils/pretty_hexdump.cpp
        
        # scripting implementation
        scripting/lua_bindings.cpp
        scripting/lua_api.cpp
        
        # main library interface
        p1ll.cpp
    )
    
    # create static library
    add_library(p1ll STATIC ${P1LL_SOURCES})
    
    # configure lua integration
    configure_target_with_lua(p1ll)
    
    # link dependencies
    target_link_libraries(p1ll PRIVATE redlog::redlog)
    
    # include directories
    target_include_directories(p1ll 
        PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}
        PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/..
    )
    
    # set output directory for static library
    set_target_properties(p1ll PROPERTIES 
        ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib
    )
    
    message(STATUS "p1ll library configured with lua scripting support")
    
else()
    message(STATUS "p1ll library skipped - lua scripting not enabled")
endif()
```

`src/p1ll/core/context.cpp`:

```cpp
#include "context.hpp"
#include "platform.hpp"
#include <stdexcept>
#include <thread>

namespace p1ll::core {

// thread-local storage for current context
thread_local std::unique_ptr<p1ll_context> current_context_;

std::unique_ptr<p1ll_context> p1ll_context::create_static(std::vector<uint8_t>& buffer) {
  // use detected platform when no override specified
  auto platform = get_detected_platform();
  return std::unique_ptr<p1ll_context>(new p1ll_context(mode::static_buffer, buffer, platform));
}

std::unique_ptr<p1ll_context> p1ll_context::create_static(std::vector<uint8_t>& buffer, const platform_key& platform) {
  // use provided platform override
  return std::unique_ptr<p1ll_context>(new p1ll_context(mode::static_buffer, buffer, platform));
}

std::unique_ptr<p1ll_context> p1ll_context::create_dynamic() {
  // dynamic contexts always use detected platform (no overrides)
  auto platform = get_detected_platform();
  return std::unique_ptr<p1ll_context>(new p1ll_context(mode::dynamic_memory, platform));
}

std::vector<uint8_t>& p1ll_context::get_buffer() const {
  if (operation_mode_ != mode::static_buffer) {
    throw std::logic_error("attempted to get buffer from non-static context");
  }

  if (!buffer_data_.has_value()) {
    throw std::logic_error("static context has no buffer reference");
  }

  return buffer_data_->get();
}

void set_current_context(std::unique_ptr<p1ll_context> context) { current_context_ = std::move(context); }

p1ll_context* get_current_context() { return current_context_.get(); }

void clear_current_context() { current_context_.reset(); }

} // namespace p1ll::core
```

`src/p1ll/core/context.hpp`:

```hpp
#pragma once

#include <vector>
#include <optional>
#include <functional>
#include <memory>
#include "platform.hpp"

namespace p1ll::core {

// p1ll execution context - manages static vs dynamic mode
class p1ll_context {
public:
  enum class mode {
    static_buffer, // patch data in memory buffer
    dynamic_memory // patch live process memory
  };

private:
  mode operation_mode_;
  std::optional<std::reference_wrapper<std::vector<uint8_t>>> buffer_data_;
  platform_key effective_platform_;

  // prevent copying to avoid reference issues
  p1ll_context(const p1ll_context&) = delete;
  p1ll_context& operator=(const p1ll_context&) = delete;

public:
  // create static context for buffer patching
  static std::unique_ptr<p1ll_context> create_static(std::vector<uint8_t>& buffer);
  static std::unique_ptr<p1ll_context> create_static(std::vector<uint8_t>& buffer, const platform_key& platform);

  // create dynamic context for live memory patching
  static std::unique_ptr<p1ll_context> create_dynamic();

  // query context mode
  mode get_mode() const noexcept { return operation_mode_; }
  bool is_static() const noexcept { return operation_mode_ == mode::static_buffer; }
  bool is_dynamic() const noexcept { return operation_mode_ == mode::dynamic_memory; }

  // get buffer for static mode (throws if dynamic mode)
  std::vector<uint8_t>& get_buffer() const;

  // get effective platform for this context
  const platform_key& get_effective_platform() const noexcept { return effective_platform_; }

private:
  explicit p1ll_context(mode op_mode, const platform_key& platform)
      : operation_mode_(op_mode), effective_platform_(platform) {}
  explicit p1ll_context(mode op_mode, std::vector<uint8_t>& buffer, const platform_key& platform)
      : operation_mode_(op_mode), buffer_data_(std::ref(buffer)), effective_platform_(platform) {}
};

// global context management for lua bindings
void set_current_context(std::unique_ptr<p1ll_context> context);
p1ll_context* get_current_context();
void clear_current_context();

} // namespace p1ll::core
```

`src/p1ll/core/platform.cpp`:

```cpp
#include "platform.hpp"
#include "context.hpp"
#include <redlog.hpp>
#include <algorithm>

namespace p1ll::core {

platform_key get_detected_platform() {
  auto log = redlog::get_logger("p1ll.platform");

  platform_key platform;

  // detect operating system
#ifdef __APPLE__
  platform.os = "darwin";
#elif __linux__
  platform.os = "linux";
#elif _WIN32
  platform.os = "windows";
#elif __FreeBSD__
  platform.os = "freebsd";
#elif __OpenBSD__
  platform.os = "openbsd";
#elif __NetBSD__
  platform.os = "netbsd";
#elif __DragonFly__
  platform.os = "dragonfly";
#elif __sun
  platform.os = "solaris";
#elif __CYGWIN__
  platform.os = "cygwin";
#elif __MINGW32__ || __MINGW64__
  platform.os = "mingw";
#else
  platform.os = "unknown";
  log.warn("unknown operating system detected - consider adding support");
#endif

  // detect architecture
#if defined(__x86_64__) || defined(_M_X64)
  platform.arch = "x64";
#elif defined(__aarch64__) || defined(_M_ARM64)
  platform.arch = "arm64";
#elif defined(__i386__) || defined(_M_IX86)
  platform.arch = "x86";
#elif defined(__arm__) || defined(_M_ARM)
  platform.arch = "arm";
#elif defined(__riscv) && (__riscv_xlen == 64)
  platform.arch = "riscv64";
#elif defined(__riscv) && (__riscv_xlen == 32)
  platform.arch = "riscv32";
#elif defined(__mips__) && defined(__mips64)
  platform.arch = "mips64";
#elif defined(__mips__)
  platform.arch = "mips";
#elif defined(__powerpc64__) || defined(__ppc64__)
  platform.arch = "ppc64";
#elif defined(__powerpc__) || defined(__ppc__)
  platform.arch = "ppc";
#elif defined(__s390x__)
  platform.arch = "s390x";
#elif defined(__s390__)
  platform.arch = "s390";
#else
  platform.arch = "unknown";
  log.warn("unknown architecture detected - consider adding support");
#endif

  log.dbg("detected platform", redlog::field("os", platform.os), redlog::field("arch", platform.arch));

  return platform;
}

platform_key get_effective_platform() {
  // check for current context first
  auto context = get_current_context();
  if (context) {
    return context->get_effective_platform();
  }

  // fallback to detected platform when no context exists
  return get_detected_platform();
}

platform_key parse_platform_key(const std::string& platform_str) {
  auto log = redlog::get_logger("p1ll.platform");

  platform_key platform;

  // input validation
  if (platform_str.empty()) {
    log.warn("empty platform string, using wildcard");
    platform.os = "*";
    platform.arch = "*";
    return platform;
  }

  // handle simple "*" wildcard as universal
  if (platform_str == "*") {
    platform.os = "*";
    platform.arch = "*";
  } else {
    size_t colon_pos = platform_str.find(':');
    if (colon_pos == std::string::npos) {
      // no colon found, treat as os with wildcard arch
      platform.os = platform_str;
      platform.arch = "*";
    } else if (colon_pos == 0) {
      // starts with colon, invalid format
      log.warn("invalid platform format (starts with colon), using wildcard", redlog::field("input", platform_str));
      platform.os = "*";
      platform.arch = "*";
    } else if (colon_pos >= platform_str.length() - 1) {
      // ends with colon, treat as os with wildcard arch
      platform.os = platform_str.substr(0, colon_pos);
      platform.arch = "*";
    } else {
      // normal "os:arch" format
      platform.os = platform_str.substr(0, colon_pos);
      platform.arch = platform_str.substr(colon_pos + 1);
    }
  }

  // trim whitespace from components
  if (!platform.os.empty() && platform.os != "*") {
    // simple whitespace trimming
    auto start = platform.os.find_first_not_of(" \t");
    auto end = platform.os.find_last_not_of(" \t");
    if (start != std::string::npos && end != std::string::npos) {
      platform.os = platform.os.substr(start, end - start + 1);
    }
  }

  if (!platform.arch.empty() && platform.arch != "*") {
    auto start = platform.arch.find_first_not_of(" \t");
    auto end = platform.arch.find_last_not_of(" \t");
    if (start != std::string::npos && end != std::string::npos) {
      platform.arch = platform.arch.substr(start, end - start + 1);
    }
  }

  log.dbg(
      "parsed platform key", redlog::field("input", platform_str), redlog::field("os", platform.os),
      redlog::field("arch", platform.arch)
  );

  return platform;
}

std::vector<std::string> get_platform_hierarchy(const platform_key& platform) {
  std::vector<std::string> hierarchy;

  // exact match first
  hierarchy.push_back(platform.to_string());

  // os wildcard if arch is not already wildcard
  if (platform.arch != "*") {
    hierarchy.push_back(platform.os + ":*");
  }

  // universal wildcards (both "*:*" and "*" are supported)
  if (platform.os != "*" || platform.arch != "*") {
    hierarchy.push_back("*:*");
    hierarchy.push_back("*"); // support simple "*" wildcard too
  }

  return hierarchy;
}

std::vector<std::string> get_current_platform_hierarchy() {
  // use effective platform which respects overrides
  return get_platform_hierarchy(get_effective_platform());
}

bool platform_key::matches(const platform_key& other) const { return platform_matches(*this, other); }

bool platform_matches(const platform_key& key, const platform_key& target) {
  // wildcard matching
  bool os_match = (key.os == "*" || target.os == "*" || key.os == target.os);
  bool arch_match = (key.arch == "*" || target.arch == "*" || key.arch == target.arch);

  return os_match && arch_match;
}

std::vector<std::string> get_supported_operating_systems() {
  return {"darwin",    "linux",   "windows", "freebsd", "openbsd", "netbsd",
          "dragonfly", "solaris", "cygwin",  "mingw",   "unknown", "*"};
}

std::vector<std::string> get_supported_architectures() {
  return {"x64",  "arm64", "x86", "arm",   "riscv64", "riscv32", "mips64",
          "mips", "ppc64", "ppc", "s390x", "s390",    "unknown", "*"};
}

bool is_valid_platform_key(const platform_key& platform) {
  auto supported_os = get_supported_operating_systems();
  auto supported_arch = get_supported_architectures();

  // check if os is supported
  bool os_valid = std::find(supported_os.begin(), supported_os.end(), platform.os) != supported_os.end();

  // check if arch is supported
  bool arch_valid = std::find(supported_arch.begin(), supported_arch.end(), platform.arch) != supported_arch.end();

  return os_valid && arch_valid;
}

} // namespace p1ll::core
```

`src/p1ll/core/platform.hpp`:

```hpp
#pragma once

#include "types.hpp"
#include <string>
#include <vector>

namespace p1ll::core {

// get detected platform information (use sparingly - prefer get_effective_platform)
platform_key get_detected_platform();

// get effective platform (respects context override if set, otherwise returns detected)
platform_key get_effective_platform();

// parse platform key from string like "linux:x64" or "darwin:*"
platform_key parse_platform_key(const std::string& platform_str);

// get platform hierarchy for matching: "linux:x64" -> ["linux:x64", "linux:*", "*:*"]
std::vector<std::string> get_platform_hierarchy(const platform_key& platform);

// get platform hierarchy for effective platform (respects override)
std::vector<std::string> get_current_platform_hierarchy();

// check if platform key matches another (with wildcard support)
bool platform_matches(const platform_key& key, const platform_key& target);

// validate platform key components are reasonable
bool is_valid_platform_key(const platform_key& platform);

// get list of known/supported operating systems
std::vector<std::string> get_supported_operating_systems();

// get list of known/supported architectures
std::vector<std::string> get_supported_architectures();

} // namespace p1ll::core
```

`src/p1ll/core/signature.cpp`:

```cpp
#include "signature.hpp"
#include "utils/hex_utils.hpp"
#include <redlog.hpp>
#include <sstream>
#include <algorithm>

namespace p1ll::core {

compiled_signature compile_signature(const signature_pattern& pattern) {
  auto log = redlog::get_logger("p1ll.signature");

  compiled_signature result;

  if (!validate_signature_pattern(pattern)) {
    log.err("invalid signature pattern", redlog::field("pattern", pattern));
    return result;
  }

  std::string normalized = utils::normalize_hex_pattern(pattern);

  // reserve space for efficiency
  size_t byte_count = normalized.length() / 2;
  result.pattern.reserve(byte_count);
  result.mask.reserve(byte_count);

  for (size_t i = 0; i < normalized.length(); i += 2) {
    char first = normalized[i];
    char second = normalized[i + 1];

    if (first == '?' && second == '?') {
      // wildcard byte
      result.pattern.push_back(0x00); // placeholder
      result.mask.push_back(false);   // wildcard
    } else {
      // exact byte
      char hex_byte[3] = {first, second, '\0'};
      uint8_t byte = static_cast<uint8_t>(std::stoul(hex_byte, nullptr, 16));
      result.pattern.push_back(byte);
      result.mask.push_back(true); // exact match
    }
  }

  auto wildcard_count = std::count(result.mask.begin(), result.mask.end(), false);
  std::string visual_pattern = utils::format_compiled_signature(result);

  log.trc("compiling signature pattern", redlog::field("input", pattern));
  log.dbg(
      "compiled signature", redlog::field("pattern", visual_pattern), redlog::field("bytes", result.pattern.size()),
      redlog::field("wildcards", wildcard_count)
  );

  return result;
}

compiled_patch compile_patch(const patch_pattern& pattern) {
  auto log = redlog::get_logger("p1ll.signature");

  compiled_patch result;

  if (!validate_patch_pattern(pattern)) {
    log.err("invalid patch pattern", redlog::field("pattern", pattern));
    return result;
  }

  std::string normalized = utils::normalize_hex_pattern(pattern);

  // reserve space for efficiency
  size_t byte_count = normalized.length() / 2;
  result.data.reserve(byte_count);
  result.mask.reserve(byte_count);

  for (size_t i = 0; i < normalized.length(); i += 2) {
    char first = normalized[i];
    char second = normalized[i + 1];

    if (first == '?' && second == '?') {
      // skip byte (don't patch)
      result.data.push_back(0x00);  // placeholder
      result.mask.push_back(false); // don't write
    } else {
      // patch byte
      char hex_byte[3] = {first, second, '\0'};
      uint8_t byte = static_cast<uint8_t>(std::stoul(hex_byte, nullptr, 16));
      result.data.push_back(byte);
      result.mask.push_back(true); // write this byte
    }
  }

  log.dbg(
      "compiled patch", redlog::field("pattern", pattern), redlog::field("bytes", result.data.size()),
      redlog::field("patches", std::count(result.mask.begin(), result.mask.end(), true))
  );

  return result;
}

bool validate_signature_pattern(const signature_pattern& pattern) { return utils::is_valid_hex_pattern(pattern); }

bool validate_patch_pattern(const patch_pattern& pattern) { return utils::is_valid_hex_pattern(pattern); }

signature_query create_signature_query(const signature_pattern& pattern, const signature_query_filter& filter) {
  signature_query query;
  query.signature = compile_signature(pattern);
  query.filter = filter;
  return query;
}

std::string patch_declaration::to_string() const {
  std::ostringstream oss;
  oss << "patch(" << signature.pattern << ", offset=" << offset << ", pattern=" << pattern
      << ", required=" << (required ? "true" : "false") << ")";
  return oss.str();
}

} // namespace p1ll::core
```

`src/p1ll/core/signature.hpp`:

```hpp
#pragma once

#include "types.hpp"
#include <string>

namespace p1ll::core {

// compile signature pattern from hex string with wildcards
compiled_signature compile_signature(const signature_pattern& pattern);

// compile patch pattern from hex string
compiled_patch compile_patch(const patch_pattern& pattern);

// validate signature pattern syntax
bool validate_signature_pattern(const signature_pattern& pattern);

// validate patch pattern syntax
bool validate_patch_pattern(const patch_pattern& pattern);

// utility to create signature queries
signature_query create_signature_query(const signature_pattern& pattern, const signature_query_filter& filter = {});

} // namespace p1ll::core
```

`src/p1ll/core/types.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>
#include <unordered_map>
#include <optional>
#include <cstdint>

namespace p1ll::core {

// platform abstraction
struct platform_key {
  std::string os;   // "windows", "linux", "darwin"
  std::string arch; // "x64", "arm64", "*" (wildcard)

  std::string to_string() const { return os + ":" + arch; }
  bool matches(const platform_key& other) const;
  bool operator==(const platform_key& other) const { return os == other.os && arch == other.arch; }
};

// signature types
using signature_pattern = std::string; // "ff d0 ?? 74"
using patch_pattern = std::string;     // "90 90 eb"

// compiled signature with mask for wildcards
struct compiled_signature {
  std::vector<uint8_t> pattern; // exact bytes
  std::vector<bool> mask;       // true = exact, false = wildcard
  size_t size() const { return pattern.size(); }
  bool empty() const { return pattern.empty(); }
};

// compiled patch data
struct compiled_patch {
  std::vector<uint8_t> data; // bytes to write
  std::vector<bool> mask;    // true = write byte, false = skip
  size_t size() const { return data.size(); }
  bool empty() const { return data.empty(); }
};

// signature query filtering configuration
struct signature_query_filter {
  std::string pattern; // regex pattern for region name filtering

  // helper to check if filter is empty (matches all)
  bool is_empty() const { return pattern.empty(); }
};

// signature query with filtering
struct signature_query {
  compiled_signature signature;
  signature_query_filter filter;
};

// signature object (for referencing in patches)
struct signature_object {
  signature_pattern pattern;
  std::optional<signature_query_filter> filter;
  bool single = false; // enforce exactly one match

  signature_object() = default;
  signature_object(const signature_pattern& p) : pattern(p) {}
  signature_object(const signature_pattern& p, const signature_query_filter& f) : pattern(p), filter(f) {}
  signature_object(const signature_pattern& p, const signature_query_filter& f, bool s)
      : pattern(p), filter(f), single(s) {}

  std::string to_string() const { return pattern; }
};

// patch declaration - references signature object
struct patch_declaration {
  signature_object signature; // signature object reference
  uint64_t offset;            // offset from signature match
  patch_pattern pattern;      // hex bytes to write
  bool required = true;       // fail if patch cannot be applied

  std::string to_string() const;
};

// auto-cure metadata
struct cure_metadata {
  std::string name;
  std::vector<std::string> platforms;
};

// platform signature mapping: "os:arch" -> [signature_objects]
using platform_signature_map = std::unordered_map<std::string, std::vector<signature_object>>;

// platform patch mapping: "os:arch" -> [patches]
using platform_patch_map = std::unordered_map<std::string, std::vector<patch_declaration>>;

// complete auto-cure configuration
struct cure_config {
  cure_metadata meta;
  platform_signature_map signatures;
  platform_patch_map patches;
};

// memory search result
struct search_result {
  uint64_t address;
  std::string region_name;
  std::string section_name;

  search_result() : address(0) {}
  search_result(uint64_t addr, const std::string& region = "", const std::string& sec = "")
      : address(addr), region_name(region), section_name(sec) {}
};

// module information
struct module_info {
  std::string name;
  std::string path;
  uint64_t base_address;
  uint64_t size;
  std::string permissions;
  bool is_system_module;

  module_info() : base_address(0), size(0), is_system_module(false) {}
};

// auto-cure execution result
struct cure_result {
  bool success = false;
  size_t patches_applied = 0;
  size_t patches_failed = 0;
  std::vector<std::string> error_messages;

  void add_error(const std::string& error) { error_messages.push_back(error); }

  bool has_errors() const { return !error_messages.empty(); }
};

} // namespace p1ll::core
```

`src/p1ll/engine/auto_cure.cpp`:

```cpp
#include "auto_cure.hpp"
#include "core/platform.hpp"
#include "core/context.hpp"
#include "core/signature.hpp"
#include "utils/hex_utils.hpp"
#include "utils/file_utils.hpp"
#include "utils/pretty_hexdump.hpp"
#include "pattern_matcher.hpp"
#include <redlog.hpp>
#include <algorithm>
#include <unordered_set>

namespace p1ll::engine {

auto_cure_engine::auto_cure_engine() : scanner_(std::make_unique<memory_scanner>()) {

  auto log = redlog::get_logger("p1ll.auto_cure");
  log.dbg("initialized auto-cure engine");
}

core::cure_result auto_cure_engine::execute(
    const core::cure_metadata& meta, const core::platform_signature_map& signatures,
    const core::platform_patch_map& patches
) {
  auto log = redlog::get_logger("p1ll.auto_cure");

  // validate and prepare patches
  auto validation_result = validate_and_prepare_patches(meta, signatures, patches);
  if (!validation_result.success) {
    return validation_result;
  }

  core::cure_result result;
  auto platform_patches = get_platform_patches(patches);

  // apply patches in order (each patch contains its own signature)
  for (const auto& patch : platform_patches) {
    auto compiled_signature_result = compile_and_validate_signature(patch);
    if (!compiled_signature_result.has_value()) {
      if (patch.required) {
        result.add_error("failed to compile signature: " + patch.signature.pattern);
        log.err("failed to compile signature", redlog::field("signature", patch.signature.pattern));
        return result;
      } else {
        log.warn("failed to compile optional signature", redlog::field("signature", patch.signature.pattern));
        result.patches_failed++;
        continue;
      }
    }

    bool patch_success = apply_patch_dynamic(patch, compiled_signature_result.value());

    if (patch_success) {
      result.patches_applied++;
      log.inf(
          "applied patch", redlog::field("signature", patch.signature.pattern), redlog::field("offset", patch.offset)
      );
    } else {
      result.patches_failed++;
      if (patch.required) {
        result.add_error("required patch failed: " + patch.signature.pattern);
        log.err("required patch failed", redlog::field("signature", patch.signature.pattern));
        return result;
      } else {
        log.warn("optional patch failed", redlog::field("signature", patch.signature.pattern));
      }
    }
  }

  result.success = (result.patches_failed == 0 || result.patches_applied > 0);

  log.inf(
      "auto-cure completed", redlog::field("success", result.success), redlog::field("applied", result.patches_applied),
      redlog::field("failed", result.patches_failed)
  );

  return result;
}

core::cure_result auto_cure_engine::execute(const core::cure_config& config) {
  return execute(config.meta, config.signatures, config.patches);
}

core::cure_result auto_cure_engine::execute_static(
    const std::string& file_path, const std::string& output_path, const core::cure_config& config
) {
  auto log = redlog::get_logger("p1ll.auto_cure");

  log.inf(
      "starting static auto-cure", redlog::field("name", config.meta.name), redlog::field("input", file_path),
      redlog::field("output", output_path)
  );

  // read input file
  auto file_data_result = p1ll::utils::read_file(file_path);
  if (!file_data_result.has_value()) {
    core::cure_result result;
    result.add_error("failed to read input file: " + file_path);
    return result;
  }
  auto file_data = file_data_result.value();

  // execute static patching on file data
  auto result = execute_static_buffer(file_data, config);
  if (!result.success) {
    return result;
  }

  // write output file
  auto write_result = p1ll::utils::write_file(output_path, file_data);
  if (!write_result) {
    result.add_error("failed to write output file: " + output_path);
    return result;
  }

  log.inf(
      "static auto-cure completed", redlog::field("applied", result.patches_applied),
      redlog::field("failed", result.patches_failed)
  );

  return result;
}

core::cure_result auto_cure_engine::execute_static_buffer(
    std::vector<uint8_t>& buffer_data, const core::cure_config& config
) {
  auto log = redlog::get_logger("p1ll.auto_cure");

  core::cure_result result;

  log.inf(
      "starting static buffer auto-cure", redlog::field("name", config.meta.name),
      redlog::field("buffer_size", buffer_data.size())
  );

  // first validate all platform signatures
  auto platform_signatures = get_platform_signatures(config.signatures);
  if (!platform_signatures.empty()) {
    log.inf(
        "validating platform signatures for static buffer cure", redlog::field("count", platform_signatures.size())
    );

    // for static cure, validate signatures exist in the buffer
    if (!validate_signatures(platform_signatures, buffer_data)) {
      result.add_error("signature validation failed - cure cannot apply");
      log.err("signature validation failed");
      return result;
    }

    log.inf("signature validation passed");
  } else {
    log.dbg("no platform signatures to validate");
  }

  // get patches for current platform
  auto platform_patches = get_platform_patches(config.patches);
  if (platform_patches.empty()) {
    result.add_error("no patches found for current platform");
    return result;
  }

  // apply patches to buffer data - each patch contains its own signature
  for (const auto& patch : platform_patches) {
    auto compiled_signature_result = compile_and_validate_signature(patch);
    if (!compiled_signature_result.has_value()) {
      if (patch.required) {
        result.add_error("failed to compile signature: " + patch.signature.pattern);
        return result;
      } else {
        result.patches_failed++;
        continue;
      }
    }

    bool patch_success = apply_patch_static(patch, compiled_signature_result.value(), buffer_data);

    if (patch_success) {
      result.patches_applied++;
    } else {
      result.patches_failed++;
      if (patch.required) {
        result.add_error("required patch failed: " + patch.signature.pattern);
        return result;
      }
    }
  }

  result.success = true;

  log.inf(
      "static buffer auto-cure completed", redlog::field("applied", result.patches_applied),
      redlog::field("failed", result.patches_failed)
  );

  return result;
}

std::vector<core::patch_declaration> auto_cure_engine::get_platform_patches(
    const core::platform_patch_map& patches
) const {

  auto log = redlog::get_logger("p1ll.auto_cure");

  // get platform hierarchy for matching
  auto platform_hierarchy = core::get_current_platform_hierarchy();

  log.dbg("checking platform hierarchy", redlog::field("platforms", platform_hierarchy.size()));

  // try each platform key in hierarchy order
  for (const auto& platform_key : platform_hierarchy) {
    auto it = patches.find(platform_key);
    if (it != patches.end() && !it->second.empty()) {
      log.dbg(
          "found patches for platform", redlog::field("platform", platform_key),
          redlog::field("count", it->second.size())
      );
      return it->second;
    }
  }

  log.warn("no patches found for any platform in hierarchy");
  return {};
}

std::vector<core::signature_object> auto_cure_engine::get_platform_signatures(
    const core::platform_signature_map& signatures
) const {
  auto log = redlog::get_logger("p1ll.auto_cure");

  // get effective platform (respects override if set)
  auto current_platform = core::get_effective_platform();

  // get platform hierarchy (exact -> os wildcard -> universal)
  auto platform_hierarchy = core::get_platform_hierarchy(current_platform);

  std::vector<core::signature_object> platform_signatures;

  // collect signatures from all matching platform keys
  for (const auto& platform_key : platform_hierarchy) {
    log.dbg("checking platform for signatures", redlog::field("platform", platform_key));

    auto it = signatures.find(platform_key);
    if (it != signatures.end() && !it->second.empty()) {
      log.dbg(
          "found signatures for platform", redlog::field("platform", platform_key),
          redlog::field("count", it->second.size())
      );

      // add all signatures from this platform
      for (const auto& sig : it->second) {
        platform_signatures.push_back(sig);
      }
    }
  }

  // deduplicate signatures by pattern to avoid redundant validation
  std::unordered_set<std::string> seen_patterns;
  std::vector<core::signature_object> deduplicated_signatures;

  for (const auto& sig : platform_signatures) {
    if (seen_patterns.find(sig.pattern) == seen_patterns.end()) {
      seen_patterns.insert(sig.pattern);
      deduplicated_signatures.push_back(sig);
    }
  }

  if (deduplicated_signatures.size() != platform_signatures.size()) {
    log.dbg(
        "deduplicated signatures", redlog::field("original", platform_signatures.size()),
        redlog::field("deduplicated", deduplicated_signatures.size())
    );
  }

  log.dbg("collected platform signatures", redlog::field("total", deduplicated_signatures.size()));
  return deduplicated_signatures;
}

bool auto_cure_engine::validate_signatures(const std::vector<core::signature_object>& signatures) {
  auto log = redlog::get_logger("p1ll.auto_cure");

  // validate all signature patterns are valid
  for (size_t i = 0; i < signatures.size(); ++i) {
    const auto& sig_obj = signatures[i];

    // validate signature pattern
    if (!core::validate_signature_pattern(sig_obj.pattern)) {
      log.err("invalid signature pattern", redlog::field("index", i), redlog::field("pattern", sig_obj.pattern));
      return false;
    }
  }

  // validate signatures exist in target memory/file
  for (size_t i = 0; i < signatures.size(); ++i) {
    const auto& sig_obj = signatures[i];

    // compile signature for validation
    auto compiled_sig = core::compile_signature(sig_obj.pattern);
    if (compiled_sig.empty()) {
      log.err(
          "failed to compile signature for validation", redlog::field("index", i),
          redlog::field("pattern", sig_obj.pattern)
      );
      return false;
    }

    // try to find signature in memory (for dynamic mode) or current context
    auto current_context = core::get_current_context();
    if (current_context && current_context->is_dynamic()) {
      // validate signature exists in memory using the signature's filter if available
      core::signature_query query;
      query.signature = compiled_sig;
      query.filter = sig_obj.filter.value_or(core::signature_query_filter{});

      auto search_results = scanner_->search(query);
      if (!search_results || search_results->empty()) {
        log.warn("signature not found in memory during validation", redlog::field("pattern", sig_obj.pattern));
        // note: don't fail validation since signature might be optional
      } else {
        // check single match constraint during validation
        if (sig_obj.single && search_results->size() > 1) {
          log.err(
              "signature validation failed: multiple matches found for single signature",
              redlog::field("pattern", sig_obj.pattern), redlog::field("matches", search_results->size())
          );

          // log all match locations for debugging
          for (size_t j = 0; j < search_results->size(); ++j) {
            log.dbg(
                "match location", redlog::field("index", j + 1), redlog::field("address", (*search_results)[j].address)
            );
          }

          log.err(
              "validation failed: signature marked as 'single' but found multiple matches - this indicates the "
              "signature pattern is not unique enough"
          );
          return false;
        }

        log.dbg(
            "signature validated in memory", redlog::field("pattern", sig_obj.pattern),
            redlog::field("matches", search_results->size())
        );
      }
    }
  }

  log.dbg("signature validation passed", redlog::field("count", signatures.size()));
  return true;
}

bool auto_cure_engine::validate_signatures(
    const std::vector<core::signature_object>& signatures, const std::vector<uint8_t>& buffer_data
) {
  auto log = redlog::get_logger("p1ll.auto_cure");

  // validate all signature patterns are valid
  for (size_t i = 0; i < signatures.size(); ++i) {
    const auto& sig_obj = signatures[i];

    // validate signature pattern
    if (!core::validate_signature_pattern(sig_obj.pattern)) {
      log.err("invalid signature pattern", redlog::field("index", i), redlog::field("pattern", sig_obj.pattern));
      return false;
    }
  }

  // validate signatures exist in static buffer
  for (size_t i = 0; i < signatures.size(); ++i) {
    const auto& sig_obj = signatures[i];

    // compile signature for validation
    auto compiled_sig = core::compile_signature(sig_obj.pattern);
    if (compiled_sig.empty()) {
      log.err(
          "failed to compile signature for validation", redlog::field("index", i),
          redlog::field("pattern", sig_obj.pattern)
      );
      return false;
    }

    // search for signature in buffer data
    pattern_matcher matcher(compiled_sig);
    auto offsets = matcher.search_file(buffer_data);

    if (offsets.empty()) {
      log.warn("signature not found in buffer during validation", redlog::field("pattern", sig_obj.pattern));
      // note: don't fail validation since signature might be optional
    } else {
      // check single match constraint during validation
      if (sig_obj.single && offsets.size() > 1) {
        log.err(
            "signature validation failed: multiple matches found for single signature",
            redlog::field("pattern", sig_obj.pattern), redlog::field("matches", offsets.size())
        );

        // log all match locations for debugging
        for (size_t j = 0; j < offsets.size(); ++j) {
          log.dbg(
              "match location", redlog::field("index", j + 1),
              redlog::field("offset", utils::format_address(offsets[j]))
          );
        }

        log.err(
            "validation failed: signature marked as 'single' but found multiple matches - this indicates the signature "
            "pattern is not unique enough"
        );
        return false;
      }

      log.dbg(
          "signature validated in buffer", redlog::field("pattern", sig_obj.pattern),
          redlog::field("matches", offsets.size())
      );
      // log first match for debugging
      if (!offsets.empty()) {
        log.dbg(
            "first signature match", redlog::field("pattern", sig_obj.pattern),
            redlog::field("offset", utils::format_address(offsets[0]))
        );
      }
    }
  }

  log.dbg("signature validation passed", redlog::field("count", signatures.size()));
  return true;
}

bool auto_cure_engine::apply_patch_dynamic(
    const core::patch_declaration& patch, const core::compiled_signature& signature
) {
  auto log = redlog::get_logger("p1ll.auto_cure");

  // search for signature across memory regions
  core::signature_query query;
  query.signature = signature;
  query.filter = patch.signature.filter.value_or(core::signature_query_filter{});

  auto search_results_result = scanner_->search(query);
  if (!search_results_result) {
    log.warn("search failed", redlog::field("signature", patch.signature));
    return false;
  }
  auto search_results = *search_results_result;
  if (search_results.empty()) {
    log.warn("signature not found", redlog::field("signature", patch.signature));
    return false;
  }

  // check single match enforcement
  if (patch.signature.single && search_results.size() > 1) {
    log.err(
        "multiple matches found for single signature", redlog::field("signature", patch.signature),
        redlog::field("matches", search_results.size())
    );

    // log all match locations for debugging
    for (size_t i = 0; i < search_results.size(); ++i) {
      log.dbg("match location", redlog::field("index", i + 1), redlog::field("address", search_results[i].address));
    }

    return false;
  }

  // apply patch based on signature behavior
  // single=true: we have exactly one match, patch it
  // single=false: patch all matches found (default behavior)
  std::vector<size_t> target_indices;

  if (patch.signature.single) {
    // single match mode - we already validated exactly one match exists
    target_indices.push_back(0);
    log.dbg("applying patch to single match");
  } else {
    // default behavior: patch all matches
    for (size_t i = 0; i < search_results.size(); ++i) {
      target_indices.push_back(i);
    }
    log.dbg("applying patch to all matches", redlog::field("count", search_results.size()));
  }

  // compile patch data once for all applications
  auto compiled_patch = core::compile_patch(patch.pattern);
  if (compiled_patch.empty()) {
    log.err("failed to compile patch pattern", redlog::field("pattern", patch.pattern));
    return false;
  }

  // extract bytes to write (only those marked in mask)
  auto patch_bytes = extract_patch_bytes(compiled_patch);

  bool any_success = false;
  for (size_t idx : target_indices) {
    auto& result = search_results[idx];
    uint64_t patch_address = result.address + patch.offset;

    log.dbg("applying patch to match", redlog::field("index", idx), redlog::field("address", patch_address));

    bool patch_success = apply_single_patch_to_address(patch, patch_bytes, patch_address);
    if (patch_success) {
      any_success = true;
    }
  }

  return any_success || !patch.required;
}

bool auto_cure_engine::apply_patch_static(
    const core::patch_declaration& patch, const core::compiled_signature& signature, std::vector<uint8_t>& file_data
) {
  auto log = redlog::get_logger("p1ll.auto_cure");

  // search for signature in file data
  pattern_matcher matcher(signature);
  size_t patch_offset;

  if (patch.signature.single) {
    // use single match enforcement
    try {
      auto single_offset = matcher.search_single(file_data.data(), file_data.size());
      patch_offset = single_offset + patch.offset;
      log.dbg(
          "single match found for signature", redlog::field("signature", patch.signature),
          redlog::field("offset", single_offset)
      );
    } catch (const std::runtime_error& e) {
      log.err(
          "single match enforcement failed", redlog::field("signature", patch.signature),
          redlog::field("error", e.what())
      );
      return false;
    }
  } else {
    // use normal search (first match)
    auto offsets = matcher.search_file(file_data);
    if (offsets.empty()) {
      log.warn("signature not found in file", redlog::field("signature", patch.signature));
      return false;
    }
    patch_offset = offsets[0] + patch.offset;
  }

  // compile patch data
  auto compiled_patch = core::compile_patch(patch.pattern);
  if (compiled_patch.empty()) {
    log.err("failed to compile patch pattern", redlog::field("pattern", patch.pattern));
    return false;
  }

  // check bounds
  if (patch_offset + compiled_patch.size() > file_data.size()) {
    log.err(
        "patch would exceed file bounds", redlog::field("offset", patch_offset),
        redlog::field("patch_size", compiled_patch.size()), redlog::field("file_size", file_data.size())
    );
    return false;
  }

  // calculate aligned boundaries for context
  size_t patch_size = compiled_patch.data.size();
  size_t aligned_start = patch_offset & ~0xF;
  size_t aligned_end = std::min(file_data.size(), ((patch_offset + patch_size + 15) & ~0xF));

  // backup original context (aligned)
  std::vector<uint8_t> original_context(file_data.begin() + aligned_start, file_data.begin() + aligned_end);

  // apply patch bytes (respecting mask)
  size_t bytes_patched = 0;
  for (size_t i = 0; i < compiled_patch.data.size(); ++i) {
    if (compiled_patch.mask[i]) { // only write bytes marked in mask
      file_data[patch_offset + i] = compiled_patch.data[i];
      bytes_patched++;
    }
  }

  // get modified context (aligned)
  std::vector<uint8_t> patched_context(file_data.begin() + aligned_start, file_data.begin() + aligned_end);

  log.trc(
      "applying static patch", redlog::field("signature", patch.signature),
      redlog::field("offset", utils::format_address(patch_offset))
  );

  // show beautiful patch hexdump at debug level
  if (redlog::get_level() <= redlog::level::debug) {
    // pass aligned context with the aligned start as base offset
    std::string patch_hexdump = utils::format_patch_hexdump(original_context, patched_context, aligned_start);
    log.dbg(
        "patch hexdump", redlog::field("offset", utils::format_address(patch_offset)),
        redlog::field("size", compiled_patch.data.size())
    );
    // output the hexdump directly to stderr to preserve formatting
    if (!patch_hexdump.empty()) {
      std::fprintf(stderr, "%s", patch_hexdump.c_str());
    }
  }

  log.dbg(
      "applied static patch", redlog::field("signature", patch.signature), redlog::field("offset", patch_offset),
      redlog::field("bytes", bytes_patched)
  );

  return true;
}

core::cure_result auto_cure_engine::validate_and_prepare_patches(
    const core::cure_metadata& meta, const core::platform_signature_map& signatures,
    const core::platform_patch_map& patches
) {

  auto log = redlog::get_logger("p1ll.auto_cure");
  core::cure_result result;

  log.inf("starting auto-cure", redlog::field("name", meta.name), redlog::field("platforms", meta.platforms.size()));

  // validate all platform signatures
  auto platform_signatures = get_platform_signatures(signatures);
  if (!platform_signatures.empty()) {
    log.inf("validating platform signatures", redlog::field("count", platform_signatures.size()));

    if (!validate_signatures(platform_signatures)) {
      result.add_error("signature validation failed - cure cannot apply to this platform");
      log.err("signature validation failed");
      return result;
    }

    log.inf("signature validation passed");
  } else {
    log.dbg("no platform signatures to validate");
  }

  // get patches for current platform
  auto platform_patches = get_platform_patches(patches);
  if (platform_patches.empty()) {
    result.add_error("no patches found for current platform");
    log.err("no patches for current platform");
    return result;
  }

  log.inf("found platform patches", redlog::field("count", platform_patches.size()));
  result.success = true; // validation passed
  return result;
}

std::optional<core::compiled_signature> auto_cure_engine::compile_and_validate_signature(
    const core::patch_declaration& patch
) {
  auto compiled_signature = core::compile_signature(patch.signature.pattern);
  if (compiled_signature.empty()) {
    return std::nullopt;
  }
  return compiled_signature;
}

memory_protection auto_cure_engine::calculate_write_protection(
    memory_protection current_protection, bool is_executable
) {
  if (is_executable) {
    // W^X compliance: remove execute, add write
    return static_cast<memory_protection>(
        (static_cast<int>(current_protection) & ~static_cast<int>(memory_protection::execute)) |
        static_cast<int>(memory_protection::write)
    );
  } else {
    // Just add write permission
    return current_protection | memory_protection::write;
  }
}

std::vector<uint8_t> auto_cure_engine::extract_patch_bytes(const core::compiled_patch& compiled_patch) {
  std::vector<uint8_t> patch_bytes;
  for (size_t i = 0; i < compiled_patch.data.size(); ++i) {
    if (compiled_patch.mask[i]) {
      patch_bytes.push_back(compiled_patch.data[i]);
    }
  }
  return patch_bytes;
}

bool auto_cure_engine::apply_single_patch_to_address(
    const core::patch_declaration& patch, const std::vector<uint8_t>& patch_bytes, uint64_t patch_address
) {

  auto log = redlog::get_logger("p1ll.auto_cure");

  // get current memory protection for target address
  auto current_region_result = scanner_->get_region_info(patch_address);
  if (!current_region_result) {
    if (patch.required) {
      log.err(
          "failed to get memory region info for required patch", redlog::field("signature", patch.signature.pattern),
          redlog::field("address", patch_address)
      );
      return false;
    } else {
      log.warn(
          "failed to get memory protection for optional patch - skipping",
          redlog::field("signature", patch.signature.pattern), redlog::field("address", patch_address)
      );
      return true; // optional patch failure is not fatal
    }
  }

  auto current_region = *current_region_result;
  auto current_protection = current_region.protection;

  // prepare memory for patching with w^x compliance
  memory_protection original_protection = current_protection;
  bool is_executable = has_protection(current_protection, memory_protection::execute);
  bool is_writable = has_protection(current_protection, memory_protection::write);
  bool needs_protection_change = !is_writable;

  // step 1: enable write access while respecting w^x policy
  if (needs_protection_change) {
    memory_protection write_protection = calculate_write_protection(current_protection, is_executable);

    log.dbg(
        "changing memory protection for patching", redlog::field("address", patch_address),
        redlog::field("original", static_cast<int>(original_protection)),
        redlog::field("temp", static_cast<int>(write_protection)), redlog::field("w_x_compliant", is_executable)
    );

    auto protect_result = scanner_->set_memory_protection(patch_address, patch_bytes.size(), write_protection);
    if (!protect_result) {
      log.err(
          "failed to change memory protection", redlog::field("signature", patch.signature.pattern),
          redlog::field("address", patch_address)
      );
      return patch.required ? false : true;
    }
  }

  // calculate aligned boundaries for context reading
  size_t patch_size = patch_bytes.size();
  uint64_t aligned_start = patch_address & ~0xF;
  uint64_t aligned_end = (patch_address + patch_size + 15) & ~0xF;
  size_t context_size = aligned_end - aligned_start;

  // step 2: try to backup aligned context for better hexdump display
  auto context_result = scanner_->read_memory(aligned_start, context_size);
  std::vector<uint8_t> original_context;
  bool has_context = false;

  if (context_result) {
    original_context = *context_result;
    has_context = true;
  }

  // backup original bytes and apply patch
  auto original_data_result = scanner_->read_memory(patch_address, patch_bytes.size());
  if (!original_data_result) {
    log.err("failed to read original bytes for backup", redlog::field("address", patch_address));
    if (needs_protection_change) {
      scanner_->set_memory_protection(patch_address, patch_bytes.size(), original_protection);
    }
    return patch.required ? false : true;
  }

  auto original_bytes = *original_data_result;
  auto write_result = scanner_->write_memory(patch_address, patch_bytes);
  bool patch_success = write_result;

  // step 3: verify patch was applied correctly
  if (patch_success) {
    auto verify_result = scanner_->read_memory(patch_address, patch_bytes.size());
    if (verify_result) {
      auto written_bytes = *verify_result;
      patch_success = std::equal(patch_bytes.begin(), patch_bytes.end(), written_bytes.begin());

      if (patch_success) {
        // show beautiful patch hexdump at debug level
        if (redlog::get_level() <= redlog::level::debug) {
          if (has_context) {
            // read the modified context
            auto modified_context_result = scanner_->read_memory(aligned_start, context_size);
            if (modified_context_result) {
              auto modified_context = *modified_context_result;
              std::string patch_hexdump =
                  utils::format_patch_hexdump(original_context, modified_context, aligned_start);
              log.dbg(
                  "dynamic patch hexdump", redlog::field("address", utils::format_address(patch_address)),
                  redlog::field("size", patch_bytes.size())
              );
              // output the hexdump directly to stderr to preserve formatting
              if (!patch_hexdump.empty()) {
                std::fprintf(stderr, "%s", patch_hexdump.c_str());
              }
            } else {
              // fallback to just patch bytes
              std::string patch_hexdump = utils::format_patch_hexdump(original_bytes, written_bytes, patch_address);
              log.dbg(
                  "dynamic patch hexdump", redlog::field("address", utils::format_address(patch_address)),
                  redlog::field("size", patch_bytes.size())
              );
              if (!patch_hexdump.empty()) {
                std::fprintf(stderr, "%s", patch_hexdump.c_str());
              }
            }
          } else {
            // fallback to just patch bytes
            std::string patch_hexdump = utils::format_patch_hexdump(original_bytes, written_bytes, patch_address);
            log.dbg(
                "dynamic patch hexdump", redlog::field("address", utils::format_address(patch_address)),
                redlog::field("size", patch_bytes.size())
            );
            if (!patch_hexdump.empty()) {
              std::fprintf(stderr, "%s", patch_hexdump.c_str());
            }
          }
        }
      } else {
        log.err("patch verification failed - restoring original bytes", redlog::field("address", patch_address));
        scanner_->write_memory(patch_address, original_bytes);
      }
    }
  } else {
    log.err("failed to write patch", redlog::field("address", patch_address));
    scanner_->write_memory(patch_address, original_bytes);
  }

  // step 4: restore original memory protection
  if (needs_protection_change) {
    auto restore_result = scanner_->set_memory_protection(patch_address, patch_bytes.size(), original_protection);
    if (!restore_result) {
      log.warn("failed to restore original memory protection", redlog::field("address", patch_address));
    }
  }

  if (patch_success) {
    log.inf(
        "successfully applied dynamic patch", redlog::field("signature", patch.signature.pattern),
        redlog::field("address", patch_address), redlog::field("bytes", patch_bytes.size())
    );
  }

  return patch_success;
}

} // namespace p1ll::engine
```

`src/p1ll/engine/auto_cure.hpp`:

```hpp
#pragma once

#include "core/types.hpp"
#include "memory_scanner.hpp"
#include <memory>

namespace p1ll::engine {

// declarative auto-cure orchestration engine
class auto_cure_engine {
public:
  auto_cure_engine();
  ~auto_cure_engine() = default;

  // execute auto-cure with separate components
  core::cure_result execute(
      const core::cure_metadata& meta, const core::platform_signature_map& signatures,
      const core::platform_patch_map& patches
  );

  // execute auto-cure with single config
  core::cure_result execute(const core::cure_config& config);

  // static file patching version
  core::cure_result execute_static(
      const std::string& file_path, const std::string& output_path, const core::cure_config& config
  );

  // static buffer patching version (modern api)
  core::cure_result execute_static_buffer(std::vector<uint8_t>& buffer_data, const core::cure_config& config);

private:
  std::unique_ptr<memory_scanner> scanner_;

  // get patches for current platform using hierarchy
  std::vector<core::patch_declaration> get_platform_patches(const core::platform_patch_map& patches) const;

  // get signatures for current platform using hierarchy
  std::vector<core::signature_object> get_platform_signatures(const core::platform_signature_map& signatures) const;

  // validate all required signatures exist before applying patches (dynamic mode)
  bool validate_signatures(const std::vector<core::signature_object>& signatures);

  // validate signatures exist in static buffer (static mode)
  bool validate_signatures(
      const std::vector<core::signature_object>& signatures, const std::vector<uint8_t>& buffer_data
  );

  // apply single patch in memory (dynamic mode)
  bool apply_patch_dynamic(const core::patch_declaration& patch, const core::compiled_signature& signature);

  // apply single patch to file data (static mode)
  bool apply_patch_static(
      const core::patch_declaration& patch, const core::compiled_signature& signature, std::vector<uint8_t>& file_data
  );

  // helper methods for reducing code duplication
  core::cure_result validate_and_prepare_patches(
      const core::cure_metadata& meta, const core::platform_signature_map& signatures,
      const core::platform_patch_map& patches
  );

  std::optional<core::compiled_signature> compile_and_validate_signature(const core::patch_declaration& patch);

  memory_protection calculate_write_protection(memory_protection current_protection, bool is_executable);

  bool apply_single_patch_to_address(
      const core::patch_declaration& patch, const std::vector<uint8_t>& patch_bytes, uint64_t patch_address
  );

  std::vector<uint8_t> extract_patch_bytes(const core::compiled_patch& compiled_patch);
};

} // namespace p1ll::engine
```

`src/p1ll/engine/memory_scanner.cpp`:

```cpp
#include "memory_scanner.hpp"
#include <fstream>
#include <sstream>
#include <filesystem>
#include <cstring>
#include <map>
#include <algorithm>
#include <regex>
#include <iomanip> // For std::hex

// --- Platform-specific includes ---
#ifdef __APPLE__
#include <mach/mach.h>
#include <mach/vm_map.h>
#include <mach/mach_vm.h>
#include <libproc.h>
#include <sys/sysctl.h>
#include <unistd.h>
#include <cerrno>
#elif __linux__
#include <sys/mman.h>
#include <unistd.h>
#include <link.h>
#include <elf.h>
#include <fcntl.h>
#include <cerrno>
#elif _WIN32
#define WIN32_LEAN_AND_MEAN
#define NOMINMAX
#include <windows.h>
#include <psapi.h>
#include <algorithm>
#endif

namespace p1ll::engine {

namespace { // Anonymous namespace for internal helpers
// Helper to format addresses as hex strings for logging.
std::string to_hex(uint64_t val) {
  std::stringstream ss;
  ss << "0x" << std::hex << val;
  return ss.str();
}
} // namespace

// --- Constructor ---
memory_scanner::memory_scanner() : log_(redlog::get_logger("p1ll.memory_scanner")) {
  log_.dbg("initialized memory scanner");
}

// --- High-Level Public API ---
std::optional<std::vector<core::search_result>> memory_scanner::search(const core::signature_query& query) const {
  log_.dbg("starting memory search...");
  if (query.signature.empty()) {
    log_.wrn("search called with an empty signature");
    return std::vector<core::search_result>{};
  }

  auto regions_result = get_memory_regions(query.filter);
  if (!regions_result) {
    log_.err("failed to get memory regions for search");
    return std::nullopt;
  }

  std::vector<core::search_result> all_results;
  pattern_matcher matcher(query.signature);

  for (const auto& region : *regions_result) {
    // Skip regions that are too small or not readable
    if (region.size < query.signature.size() || !has_protection(region.protection, memory_protection::read)) {
      continue;
    }

    log_.dbg(
        "searching region", redlog::field("name", region.name), redlog::field("base", to_hex(region.base_address)),
        redlog::field("size", region.size)
    );

    auto data_result = read_memory(region.base_address, region.size);
    if (!data_result) {
      // This is expected for some regions (e.g. guard pages), so log as debug.
      log_.dbg("could not read memory region to search", redlog::field("base", to_hex(region.base_address)));
      continue;
    }

    auto offsets = matcher.search(data_result->data(), data_result->size());
    for (uint64_t offset : offsets) {
      std::string region_name =
          region.name.empty() ? "[anonymous]" : std::filesystem::path(region.name).filename().string();
      all_results.emplace_back(region.base_address + offset, region_name, "");
    }
  }

  log_.dbg("search complete", redlog::field("total_found", all_results.size()));
  return all_results;
}

// --- Low-Level Public API ---
std::optional<size_t> memory_scanner::get_page_size() const {
#if defined(__APPLE__) || defined(__linux__)
  long page_size = sysconf(_SC_PAGESIZE);
  if (page_size == -1) {
    log_.err("sysconf(_SC_PAGESIZE) failed", redlog::field("errno", errno));
    return std::nullopt;
  }
  return static_cast<size_t>(page_size);
#elif _WIN32
  SYSTEM_INFO si;
  GetSystemInfo(&si);
  return static_cast<size_t>(si.dwPageSize);
#else
  log_.err("get_page_size not supported on this platform");
  return std::nullopt;
#endif
}

std::optional<std::vector<memory_region>> memory_scanner::get_memory_regions(
    const core::signature_query_filter& filter
) const {
  log_.dbg("enumerating memory regions", redlog::field("filter", filter.pattern));

  auto regions_result = enumerate_regions();
  if (!regions_result) {
    log_.err("failed to enumerate raw memory regions");
    return std::nullopt;
  }

  if (filter.is_empty()) {
    log_.dbg("region enumeration complete, no filter", redlog::field("total_regions", regions_result->size()));
    return regions_result;
  }

  std::vector<memory_region> filtered_regions;
  for (const auto& region : *regions_result) {
    if (matches_filter(region, filter)) {
      filtered_regions.push_back(region);
    }
  }

  log_.dbg(
      "region enumeration complete, filter applied", redlog::field("total_regions", regions_result->size()),
      redlog::field("filtered_regions", filtered_regions.size())
  );
  return filtered_regions;
}

std::optional<memory_region> memory_scanner::get_region_info(uint64_t address) const {
#ifdef __APPLE__
  vm_address_t target_address = address;
  vm_size_t size = 0;
  vm_region_basic_info_data_64_t info;
  mach_msg_type_number_t info_count = VM_REGION_BASIC_INFO_COUNT_64;
  mach_port_t object_name;

  kern_return_t kr = vm_region_64(
      mach_task_self(), &target_address, &size, VM_REGION_BASIC_INFO, (vm_region_info_t) &info, &info_count,
      &object_name
  );
  if (kr != KERN_SUCCESS) {
    log_.err("vm_region_64 failed", redlog::field("error", mach_error_string(kr)), redlog::field("kr", kr));
    return std::nullopt;
  }
  if (address < target_address || address >= target_address + size) {
    log_.err("address not found in a valid region", redlog::field("address", to_hex(address)));
    return std::nullopt;
  }

  memory_region region;
  region.base_address = target_address;
  region.size = size;
  auto prot_res = platform_to_protection(info.protection);
  region.protection = prot_res.value_or(memory_protection::none);
  region.is_executable = has_protection(region.protection, memory_protection::execute);
  if (proc_regionfilename(getpid(), target_address, region.name.data(), region.name.capacity()) > 0) {
    region.is_system = is_system_region(region);
  }
  return region;
#elif __linux__
  auto all_regions = enumerate_regions();
  if (!all_regions) {
    return std::nullopt;
  }
  for (const auto& region : *all_regions) {
    if (address >= region.base_address && address < (region.base_address + region.size)) {
      return region;
    }
  }
  log_.err("address not found in memory map", redlog::field("address", to_hex(address)));
  return std::nullopt;
#elif _WIN32
  MEMORY_BASIC_INFORMATION mbi;
  if (VirtualQuery(reinterpret_cast<LPCVOID>(address), &mbi, sizeof(mbi)) == 0) {
    log_.err("VirtualQuery failed", redlog::field("error", GetLastError()));
    return std::nullopt;
  }

  memory_region region;
  region.base_address = reinterpret_cast<uint64_t>(mbi.BaseAddress);
  region.size = mbi.RegionSize;
  auto prot_res = platform_to_protection(mbi.Protect);
  region.protection = prot_res.value_or(memory_protection::none);
  region.is_executable = has_protection(region.protection, memory_protection::execute);
  char filename[MAX_PATH];
  if (mbi.Type != MEM_PRIVATE &&
      GetMappedFileNameA(GetCurrentProcess(), mbi.BaseAddress, filename, sizeof(filename)) > 0) {
    region.name = filename;
    region.is_system = is_system_region(region);
  }
  return region;
#else
  log_.err("get_region_info not supported on this platform");
  return std::nullopt;
#endif
}

bool memory_scanner::set_memory_protection(uint64_t address, size_t size, memory_protection protection) const {
  if (size == 0) {
    log_.err("set_memory_protection: size cannot be zero");
    return false;
  }
  auto platform_prot_result = protection_to_platform(protection);
  if (!platform_prot_result) {
    return false;
  }
  int platform_protection = *platform_prot_result;

  log_.dbg("setting memory protection", redlog::field("address", to_hex(address)), redlog::field("size", size));
#ifdef __APPLE__
  kern_return_t kr = mach_vm_protect(mach_task_self(), address, size, FALSE, platform_protection);
  if (kr != KERN_SUCCESS) {
    log_.err("mach_vm_protect failed", redlog::field("error", mach_error_string(kr)), redlog::field("kr", kr));
    return false;
  }
#elif __linux__
  if (mprotect(reinterpret_cast<void*>(address), size, platform_protection) == -1) {
    log_.err("mprotect failed", redlog::field("errno", errno));
    return false;
  }
#elif _WIN32
  DWORD old_protect;
  if (!VirtualProtect(reinterpret_cast<LPVOID>(address), size, platform_protection, &old_protect)) {
    log_.err("VirtualProtect failed", redlog::field("error", GetLastError()));
    return false;
  }
#else
  log_.err("set_memory_protection not supported on this platform");
  return false;
#endif
  return true;
}

// ... (allocate_memory, free_memory, read_memory, write_memory are unchanged and correct) ...
std::optional<void*> memory_scanner::allocate_memory(size_t size, memory_protection protection) const {
  auto page_size_res = get_page_size();
  if (!page_size_res) {
    return std::nullopt;
  }
  if (size == 0 || size % *page_size_res != 0) {
    log_.err(
        "allocate_memory: size must be a non-zero multiple of page size", redlog::field("size", size),
        redlog::field("page_size", *page_size_res)
    );
    return std::nullopt;
  }
  auto platform_prot_result = protection_to_platform(protection);
  if (!platform_prot_result) {
    return std::nullopt;
  }
  int platform_protection = *platform_prot_result;
  log_.dbg("allocating memory", redlog::field("size", size));
#ifdef __APPLE__
  vm_address_t address = 0;
  kern_return_t kr = vm_allocate(mach_task_self(), &address, size, VM_FLAGS_ANYWHERE);
  if (kr != KERN_SUCCESS) {
    log_.err("vm_allocate failed", redlog::field("error", mach_error_string(kr)), redlog::field("kr", kr));
    return std::nullopt;
  }
  kr = vm_protect(mach_task_self(), address, size, FALSE, platform_protection);
  if (kr != KERN_SUCCESS) {
    vm_deallocate(mach_task_self(), address, size);
    log_.err(
        "vm_protect failed on new allocation", redlog::field("error", mach_error_string(kr)), redlog::field("kr", kr)
    );
    return std::nullopt;
  }
  return reinterpret_cast<void*>(address);
#elif __linux__
  void* address = mmap(NULL, size, platform_protection, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (address == MAP_FAILED) {
    log_.err("mmap failed", redlog::field("errno", errno));
    return std::nullopt;
  }
  return address;
#elif _WIN32
  void* address = VirtualAlloc(NULL, size, MEM_COMMIT | MEM_RESERVE, platform_protection);
  if (address == NULL) {
    log_.err("VirtualAlloc failed", redlog::field("error", GetLastError()));
    return std::nullopt;
  }
  return address;
#else
  log_.err("allocate_memory not supported on this platform");
  return std::nullopt;
#endif
}
bool memory_scanner::free_memory(void* address, size_t size) const {
  log_.dbg(
      "freeing memory", redlog::field("address", to_hex(reinterpret_cast<uint64_t>(address))),
      redlog::field("size", size)
  );
#ifdef __APPLE__
  if (vm_deallocate(mach_task_self(), reinterpret_cast<vm_address_t>(address), size) != KERN_SUCCESS) {
    log_.err("vm_deallocate failed", redlog::field("errno", errno));
    return false;
  }
#elif __linux__
  if (munmap(address, size) != 0) {
    log_.err("munmap failed", redlog::field("errno", errno));
    return false;
  }
#elif _WIN32
  if (!VirtualFree(address, 0, MEM_RELEASE)) {
    log_.err("VirtualFree failed", redlog::field("error", GetLastError()));
    return false;
  }
#else
  log_.err("free_memory not supported on this platform");
  return false;
#endif
  return true;
}
std::optional<std::vector<uint8_t>> memory_scanner::read_memory(uint64_t address, size_t size) const {
  if (size == 0) {
    return std::vector<uint8_t>{};
  }
  auto region_info = get_region_info(address);
  if (!region_info) {
    return std::nullopt;
  }
  if (!has_protection(region_info->protection, memory_protection::read)) {
    log_.err("memory not readable", redlog::field("address", to_hex(address)));
    return std::nullopt;
  }
  if (address + size > region_info->base_address + region_info->size) {
    log_.err(
        "read would cross memory region boundary", redlog::field("address", to_hex(address)),
        redlog::field("size", size)
    );
    return std::nullopt;
  }
  std::vector<uint8_t> buffer(size);
#ifdef _WIN32
  SIZE_T bytes_read = 0;
  if (!ReadProcessMemory(GetCurrentProcess(), reinterpret_cast<LPCVOID>(address), buffer.data(), size, &bytes_read) ||
      bytes_read != size) {
    log_.err("ReadProcessMemory failed", redlog::field("error", GetLastError()));
    return std::nullopt;
  }
#else
  std::memcpy(buffer.data(), reinterpret_cast<const void*>(address), size);
#endif
  return buffer;
}
bool memory_scanner::write_memory(uint64_t address, const std::vector<uint8_t>& data) const {
  if (data.empty()) {
    return true;
  }
  size_t size = data.size();
  auto region_info = get_region_info(address);
  if (!region_info) {
    return false;
  }
  if (!has_protection(region_info->protection, memory_protection::write)) {
    log_.err("memory not writable", redlog::field("address", to_hex(address)));
    return false;
  }
  if (address + size > region_info->base_address + region_info->size) {
    log_.err(
        "write would cross memory region boundary", redlog::field("address", to_hex(address)),
        redlog::field("size", size)
    );
    return false;
  }
#ifdef _WIN32
  SIZE_T bytes_written = 0;
  if (!WriteProcessMemory(GetCurrentProcess(), reinterpret_cast<LPVOID>(address), data.data(), size, &bytes_written) ||
      bytes_written != size) {
    log_.err("WriteProcessMemory failed", redlog::field("error", GetLastError()));
    return false;
  }
#else
  std::memcpy(reinterpret_cast<void*>(address), data.data(), size);
#endif
  return true;
}

// --- Private Platform-Specific Implementations ---
// ... (enumerate_regions, is_system_region, matches_filter, and protection helpers) ...
std::optional<std::vector<memory_region>> memory_scanner::enumerate_regions() const {
  std::vector<memory_region> regions;
#ifdef __APPLE__
  task_t task = mach_task_self();
  mach_vm_address_t address = 0;
  int pid = getpid();
  for (;;) {
    mach_vm_size_t size = 0;
    vm_region_submap_info_data_64_t info;
    mach_msg_type_number_t count = VM_REGION_SUBMAP_INFO_COUNT_64;
    uint32_t depth = 1;
    kern_return_t kr = mach_vm_region_recurse(task, &address, &size, &depth, (vm_region_recurse_info_t) &info, &count);
    if (kr != KERN_SUCCESS) {
      break;
    }
    memory_region region;
    region.base_address = address;
    region.size = size;
    auto prot_res = platform_to_protection(info.protection);
    region.protection = prot_res.value_or(memory_protection::none);
    region.is_executable = has_protection(region.protection, memory_protection::execute);
    char filename[PATH_MAX] = {0};
    if (proc_regionfilename(pid, address, filename, sizeof(filename)) > 0) {
      region.name = filename;
    }
    region.is_system = is_system_region(region);
    regions.push_back(region);
    address += size;
  }
#elif __linux__
  std::ifstream maps("/proc/self/maps");
  if (!maps) {
    log_.err("failed to open /proc/self/maps", redlog::field("errno", errno));
    return std::nullopt;
  }
  std::string line;
  while (std::getline(maps, line)) {
    std::stringstream ss(line);
    uint64_t start, end;
    std::string perms_str, offset_str, dev_str, inode_str, path_str;
    ss >> std::hex >> start;
    ss.ignore(1, '-');
    ss >> std::hex >> end >> perms_str >> offset_str >> dev_str >> inode_str;
    std::getline(ss, path_str);
    path_str.erase(0, path_str.find_first_not_of(" \t"));

    memory_region region;
    region.base_address = start;
    region.size = end - start;
    region.name = path_str;
    int perms = 0;
    if (perms_str.length() > 0 && perms_str[0] == 'r') {
      perms |= static_cast<int>(memory_protection::read);
    }
    if (perms_str.length() > 1 && perms_str[1] == 'w') {
      perms |= static_cast<int>(memory_protection::write);
    }
    if (perms_str.length() > 2 && perms_str[2] == 'x') {
      perms |= static_cast<int>(memory_protection::execute);
    }
    region.protection = static_cast<memory_protection>(perms);
    region.is_executable = has_protection(region.protection, memory_protection::execute);
    region.is_system = is_system_region(region);
    regions.push_back(region);
  }
#elif _WIN32
  HANDLE process = GetCurrentProcess();
  SYSTEM_INFO si;
  GetSystemInfo(&si);
  uint64_t current_address = (uint64_t) si.lpMinimumApplicationAddress;
  uint64_t max_address = (uint64_t) si.lpMaximumApplicationAddress;
  while (current_address < max_address) {
    MEMORY_BASIC_INFORMATION mbi;
    if (VirtualQueryEx(process, (LPCVOID) current_address, &mbi, sizeof(mbi)) == 0) {
      break;
    }
    if (mbi.State == MEM_COMMIT) {
      memory_region region;
      region.base_address = (uint64_t) mbi.BaseAddress;
      region.size = mbi.RegionSize;
      auto prot_res = platform_to_protection(mbi.Protect);
      region.protection = prot_res.value_or(memory_protection::none);
      region.is_executable = has_protection(region.protection, memory_protection::execute);
      char filename[MAX_PATH];
      if (mbi.Type != MEM_PRIVATE && GetMappedFileNameA(process, mbi.BaseAddress, filename, sizeof(filename)) > 0) {
        region.name = filename;
      }
      region.is_system = is_system_region(region);
      regions.push_back(region);
    }
    uint64_t next_address = (uint64_t) mbi.BaseAddress + mbi.RegionSize;
    if (next_address <= current_address) {
      break;
    }
    current_address = next_address;
  }
#endif

  // log all regions
  for (const auto& region : regions) {
    log_.dbg(
        "region", redlog::field("base", to_hex(region.base_address)), redlog::field("size", region.size),
        redlog::field("protection", static_cast<int>(region.protection)), redlog::field("name", region.name),
        redlog::field("is_executable", region.is_executable), redlog::field("is_system", region.is_system)
    );
  }

  return regions;
}

bool memory_scanner::is_system_region(const memory_region& region) const {
  if (region.name.empty()) {
    return false;
  }
#ifdef _WIN32
  char system_path_buf[MAX_PATH];
  if (GetSystemDirectoryA(system_path_buf, MAX_PATH) == 0) {
    return false;
  }
  std::string system_path_str(system_path_buf);
  std::string module_path_str = region.name;
  // Normalize paths for case-insensitive comparison
  std::transform(system_path_str.begin(), system_path_str.end(), system_path_str.begin(), ::tolower);
  std::transform(module_path_str.begin(), module_path_str.end(), module_path_str.begin(), ::tolower);
  return module_path_str.rfind(system_path_str, 0) == 0;
#elif defined(__APPLE__)
  return region.name.rfind("/System/", 0) == 0 || region.name.rfind("/usr/lib/", 0) == 0;
#elif defined(__linux__)
  return region.name.rfind("/lib/", 0) == 0 || region.name.rfind("/usr/lib/", 0) == 0 ||
         region.name.rfind("/lib64/", 0) == 0 || region.name.rfind("/usr/lib64/", 0) == 0;
#else
  return false;
#endif

  return false;
}

bool memory_scanner::matches_filter(const memory_region& region, const core::signature_query_filter& filter) const {
  // if filter is empty, match all regions
  if (filter.is_empty()) {
    return true;
  }

  // apply regex pattern filter to region name
  if (!filter.pattern.empty()) {
    try {
      std::string region_name =
          region.name.empty() ? "[anonymous]" : std::filesystem::path(region.name).filename().string();
      if (!std::regex_search(region_name, std::regex(filter.pattern))) {
        return false;
      }
    } catch (const std::regex_error& e) {
      log_.err("invalid regex in filter", redlog::field("pattern", filter.pattern), redlog::field("error", e.what()));
      return false;
    }
  }

  return true;
}

// ... (protection_to_platform and platform_to_protection are unchanged and correct)
std::optional<int> memory_scanner::protection_to_platform(memory_protection protection) const {
#ifdef __APPLE__
  int result = VM_PROT_NONE;
  if (has_protection(protection, memory_protection::read)) {
    result |= VM_PROT_READ;
  }
  if (has_protection(protection, memory_protection::write)) {
    result |= (VM_PROT_WRITE | VM_PROT_COPY);
  }
  if (has_protection(protection, memory_protection::execute)) {
    result |= VM_PROT_EXECUTE;
  }
  return result;
#elif __linux__
  int result = PROT_NONE;
  if (has_protection(protection, memory_protection::read)) {
    result |= PROT_READ;
  }
  if (has_protection(protection, memory_protection::write)) {
    result |= PROT_WRITE;
  }
  if (has_protection(protection, memory_protection::execute)) {
    result |= PROT_EXEC;
  }
  return result;
#elif _WIN32
  bool r = has_protection(protection, memory_protection::read);
  bool w = has_protection(protection, memory_protection::write);
  bool x = has_protection(protection, memory_protection::execute);
  if (x && r && w) {
    return PAGE_EXECUTE_READWRITE;
  }
  if (x && r) {
    return PAGE_EXECUTE_READ;
  }
  if (x) {
    return PAGE_EXECUTE;
  }
  if (r && w) {
    return PAGE_READWRITE;
  }
  if (r) {
    return PAGE_READONLY;
  }
  return PAGE_NOACCESS;
#else
  log_.err("protection_to_platform not supported on this platform");
  return std::nullopt;
#endif
}

std::optional<memory_protection> memory_scanner::platform_to_protection(int platform_protection) const {
#ifdef __APPLE__
  memory_protection result = memory_protection::none;
  if (platform_protection & VM_PROT_READ) {
    result = result | memory_protection::read;
  }
  if (platform_protection & VM_PROT_WRITE) {
    result = result | memory_protection::write;
  }
  if (platform_protection & VM_PROT_EXECUTE) {
    result = result | memory_protection::execute;
  }
  return result;
#elif __linux__
  memory_protection result = memory_protection::none;
  if (platform_protection & PROT_READ) {
    result = result | memory_protection::read;
  }
  if (platform_protection & PROT_WRITE) {
    result = result | memory_protection::write;
  }
  if (platform_protection & PROT_EXEC) {
    result = result | memory_protection::execute;
  }
  return result;
#elif _WIN32
  DWORD p = platform_protection & 0xFF;
  if (p == PAGE_EXECUTE_READWRITE || p == PAGE_EXECUTE_WRITECOPY) {
    return memory_protection::read_write_execute;
  }
  if (p == PAGE_EXECUTE_READ) {
    return memory_protection::read_execute;
  }
  if (p == PAGE_EXECUTE) {
    return memory_protection::execute;
  }
  if (p == PAGE_READWRITE) {
    return memory_protection::read_write;
  }
  if (p == PAGE_READONLY || p == PAGE_WRITECOPY) {
    return memory_protection::read;
  }
  return memory_protection::none;
#else
  log_.err("platform_to_protection not supported on this platform");
  return std::nullopt;
#endif
}

} // namespace p1ll::engine
```

`src/p1ll/engine/memory_scanner.hpp`:

```hpp
#pragma once

#include "core/types.hpp"
#include "pattern_matcher.hpp"
#include <vector>
#include <string>
#include <memory>
#include <optional>
#include <variant>
#include <redlog.hpp>

namespace p1ll::engine {

enum class memory_protection : int {
  none = 0x00,
  read = 0x01,
  write = 0x02,
  execute = 0x04,
  read_write = read | write,
  read_execute = read | execute,
  read_write_execute = read | write | execute
};
constexpr memory_protection operator|(memory_protection a, memory_protection b) {
  return static_cast<memory_protection>(static_cast<int>(a) | static_cast<int>(b));
}
constexpr memory_protection operator&(memory_protection a, memory_protection b) {
  return static_cast<memory_protection>(static_cast<int>(a) & static_cast<int>(b));
}
constexpr bool has_protection(memory_protection flags, memory_protection check) { return (flags & check) == check; }

struct memory_region {
  uint64_t base_address;
  size_t size;
  memory_protection protection;
  std::string name;
  bool is_executable; // Flag for regions that are part of a module's code
  bool is_system;     // Flag for regions belonging to system libraries
};

// Error type definitions removed - using std::optional<T> and bool returns with logging

class memory_scanner {
public:
  memory_scanner();
  ~memory_scanner() = default;

  // --- High-Level Signature Scanning ---
  /**
   * @brief Searches for a signature across all committed memory regions, respecting the filter.
   * @param query The signature and a filter to select which regions to search.
   * @return A list of all found matches.
   */
  std::optional<std::vector<core::search_result>> search(const core::signature_query& query) const;

  // --- Low-Level Memory Introspection & Manipulation ---
  std::optional<std::vector<memory_region>> get_memory_regions(const core::signature_query_filter& filter = {}) const;
  std::optional<memory_region> get_region_info(uint64_t address) const;
  bool set_memory_protection(uint64_t address, size_t size, memory_protection protection) const;
  std::optional<size_t> get_page_size() const;

  // --- Memory Allocation ---
  std::optional<void*> allocate_memory(size_t size, memory_protection protection) const;
  bool free_memory(void* address, size_t size) const;

  // --- Direct Memory Access ---
  std::optional<std::vector<uint8_t>> read_memory(uint64_t address, size_t size) const;
  bool write_memory(uint64_t address, const std::vector<uint8_t>& data) const;

private:
  mutable redlog::logger log_;

  // Platform-agnostic private helpers
  bool is_system_region(const memory_region& region) const;
  bool matches_filter(const memory_region& region, const core::signature_query_filter& filter) const;

  // Platform-specific implementations
  std::optional<std::vector<memory_region>> enumerate_regions() const;

  // Protection flag conversion helpers
  std::optional<memory_protection> platform_to_protection(int platform_protection) const;
  std::optional<int> protection_to_platform(memory_protection protection) const;
};

} // namespace p1ll::engine
```

`src/p1ll/engine/pattern_matcher.cpp`:

```cpp
#include "pattern_matcher.hpp"
#include "utils/pretty_hexdump.hpp"
#include <redlog.hpp>
#include <algorithm>

namespace p1ll::engine {

pattern_matcher::pattern_matcher(const core::compiled_signature& signature) : signature_(signature) {

  auto log = redlog::get_logger("p1ll.pattern_matcher");

  if (signature_.empty()) {
    log.err("cannot create pattern matcher with empty signature");
    return;
  }

  build_shift_table();

  log.dbg(
      "created pattern matcher", redlog::field("pattern_size", signature_.size()),
      redlog::field("wildcards", std::count(signature_.mask.begin(), signature_.mask.end(), false))
  );
}

void pattern_matcher::build_shift_table() {
  const size_t pattern_len = signature_.size();

  if (pattern_len == 0) {
    return;
  }

  // initialize all entries to pattern length (default skip)
  shift_table_.fill(pattern_len);

  // count exact bytes for performance optimization warning
  size_t exact_bytes = std::count(signature_.mask.begin(), signature_.mask.end(), true);

  // boyer-moore-horspool: process all characters except the last one
  // process exact bytes first
  for (size_t i = 0; i < pattern_len - 1; ++i) {
    if (signature_.mask[i]) { // exact byte only
      uint8_t byte = signature_.pattern[i];
      shift_table_[byte] = pattern_len - 1 - i;
    }
  }

  // handle wildcards: for each wildcard position, any byte can match there
  // we must use the minimum skip distance to ensure correctness
  for (size_t i = 0; i < pattern_len - 1; ++i) {
    if (!signature_.mask[i]) { // wildcard position
      size_t wildcard_skip = pattern_len - 1 - i;

      // for each possible byte value, take the minimum skip distance
      // this ensures we don't skip over potential matches
      for (size_t byte = 0; byte < 256; ++byte) {
        shift_table_[byte] = std::min(shift_table_[byte], wildcard_skip);
      }
    }
  }

  // log performance warning for wildcard-heavy patterns
  auto log = redlog::get_logger("p1ll.pattern_matcher");
  if (exact_bytes < pattern_len / 2) {
    log.warn(
        "pattern has many wildcards, performance may be suboptimal", redlog::field("exact_bytes", exact_bytes),
        redlog::field("total_bytes", pattern_len),
        redlog::field("wildcard_ratio", (pattern_len - exact_bytes) * 100 / pattern_len)
    );
  }

  // safety check: ensure minimum shift of 1 (should not be needed with correct algorithm)
  for (size_t i = 0; i < 256; ++i) {
    if (shift_table_[i] == 0) {
      shift_table_[i] = 1;
    }
  }
}

std::vector<uint64_t> pattern_matcher::search(const uint8_t* data, size_t size) const {
  auto log = redlog::get_logger("p1ll.pattern_matcher");

  std::vector<uint64_t> results;

  if (!is_valid() || !data || size < signature_.size()) {
    log.dbg(
        "search skipped - invalid input", redlog::field("valid", is_valid()),
        redlog::field("data_ptr", data != nullptr), redlog::field("size", size),
        redlog::field("pattern_size", signature_.size())
    );
    return results;
  }

  const size_t pattern_len = signature_.size();

  // boyer-moore-horspool search with proper bounds checking
  size_t i = 0;
  while (i + pattern_len <= size) {
    if (match_at_position(data, i)) {
      results.push_back(i);

      // show beautiful signature match hexdump at debug level
      if (redlog::get_level() <= redlog::level::debug) {
        std::string match_hexdump = utils::format_signature_match_hexdump(data, size, i, pattern_len, 0);
        log.dbg(
            "signature match found", redlog::field("match", results.size()), redlog::field("offset", i),
            redlog::field("pattern_size", pattern_len)
        );
        // output the hexdump directly to stderr to preserve formatting
        if (!match_hexdump.empty()) {
          std::fprintf(stderr, "%s", match_hexdump.c_str());
        }
      }

      i += 1; // move by 1 to find overlapping matches
    } else {
      // skip based on shift table using last character of current window
      size_t last_char_index = i + pattern_len - 1;
      size_t skip = shift_table_[data[last_char_index]];

      // ensure we make progress (prevent infinite loops)
      if (skip == 0) {
        skip = 1;
      }

      i += skip;
    }
  }

  log.dbg(
      "pattern search completed", redlog::field("search_size", size), redlog::field("pattern_size", pattern_len),
      redlog::field("results", results.size())
  );

  return results;
}

uint64_t pattern_matcher::search_one(const uint8_t* data, size_t size) const {
  auto results = search(data, size);
  return results.empty() ? static_cast<uint64_t>(-1) : results[0];
}

uint64_t pattern_matcher::search_single(const uint8_t* data, size_t size) const {
  auto log = redlog::get_logger("p1ll.pattern_matcher");
  auto results = search(data, size);

  if (results.empty()) {
    throw std::runtime_error("signature not found - expected exactly one match");
  }

  if (results.size() > 1) {
    log.err(
        "multiple matches found for single signature", redlog::field("matches", results.size()),
        redlog::field("pattern_size", pattern_size())
    );

    // log all match locations for debugging
    for (size_t i = 0; i < results.size(); ++i) {
      log.dbg("match location", redlog::field("index", i + 1), redlog::field("offset", results[i]));
    }

    throw std::runtime_error(
        "multiple matches found for single signature - expected exactly one match, found " +
        std::to_string(results.size())
    );
  }

  return results[0];
}

std::vector<size_t> pattern_matcher::search_file(const std::vector<uint8_t>& file_data) const {
  auto byte_results = search(file_data.data(), file_data.size());

  // convert uint64_t results to size_t for file offsets
  std::vector<size_t> results;
  results.reserve(byte_results.size());

  for (uint64_t addr : byte_results) {
    results.push_back(static_cast<size_t>(addr));
  }

  return results;
}

bool pattern_matcher::match_at_position(const uint8_t* data, size_t pos) const {
  const size_t pattern_len = signature_.size();

  // match from right to left for early mismatch detection
  for (int i = static_cast<int>(pattern_len) - 1; i >= 0; --i) {
    if (signature_.mask[i]) { // exact byte match required
      if (signature_.pattern[i] != data[pos + i]) {
        return false;
      }
    }
    // wildcards automatically match, skip check
  }

  return true;
}

} // namespace p1ll::engine
```

`src/p1ll/engine/pattern_matcher.hpp`:

```hpp
#pragma once

#include "core/types.hpp"
#include <vector>
#include <array>
#include <cstdint>

namespace p1ll::engine {

// high-performance pattern matching with Boyer-Moore-Horspool algorithm
class pattern_matcher {
public:
  explicit pattern_matcher(const core::compiled_signature& signature);

  // search in memory region
  std::vector<uint64_t> search(const uint8_t* data, size_t size) const;

  // search expecting exactly one result
  uint64_t search_one(const uint8_t* data, size_t size) const;

  // search with single match enforcement - throws exception if multiple matches
  uint64_t search_single(const uint8_t* data, size_t size) const;

  // search in file data
  std::vector<size_t> search_file(const std::vector<uint8_t>& file_data) const;

  // get pattern size
  size_t pattern_size() const { return signature_.size(); }

  // check if pattern is valid
  bool is_valid() const { return !signature_.empty(); }

private:
  core::compiled_signature signature_;
  std::array<size_t, 256> shift_table_; // Boyer-Moore-Horspool shift table

  void build_shift_table();
  bool match_at_position(const uint8_t* data, size_t pos) const;
};

} // namespace p1ll::engine
```

`src/p1ll/p1ll.cpp`:

```cpp
#include "p1ll.hpp"
#include "core/platform.hpp"
#include "core/signature.hpp"
#include "scripting/lua_api.hpp"
#include <redlog.hpp>
#include <memory>
#include <cstdlib>
#include <filesystem>

namespace p1ll {

namespace {
std::unique_ptr<engine::auto_cure_engine> g_cure_engine;
std::unique_ptr<engine::memory_scanner> g_scanner;
std::unique_ptr<scripting::lua_api> g_lua_api;
bool g_initialized = false;
} // namespace

void initialize() {
  if (g_initialized) {
    return;
  }

  auto log = redlog::get_logger("p1ll");

  // get effective platform (respects override if set)
  auto platform = core::get_effective_platform();
  log.inf("p1ll initializing", redlog::field("platform", platform.to_string()));

  // initialize engines
  g_cure_engine = std::make_unique<engine::auto_cure_engine>();
  g_scanner = std::make_unique<engine::memory_scanner>();

  g_lua_api = std::make_unique<scripting::lua_api>();
  log.inf("lua scripting support enabled");

  g_initialized = true;
  log.inf("p1ll initialized successfully");
}

void shutdown() {
  if (!g_initialized) {
    return;
  }

  auto log = redlog::get_logger("p1ll");
  log.inf("p1ll shutting down");

  g_cure_engine.reset();
  g_scanner.reset();

  g_lua_api.reset();

  g_initialized = false;
}

core::cure_result auto_cure(
    const core::cure_metadata& meta, const core::platform_signature_map& signatures,
    const core::platform_patch_map& patches
) {
  initialize();
  return g_cure_engine->execute(meta, signatures, patches);
}

core::cure_result auto_cure(const core::cure_config& config) {
  initialize();
  return g_cure_engine->execute(config);
}

core::cure_result patch_file(
    const std::string& input_path, const std::string& output_path, const core::cure_config& config
) {
  initialize();
  return g_cure_engine->execute_static(input_path, output_path, config);
}

core::cure_result execute_cure_script(const std::string& script_path) {
  initialize();
  return g_lua_api->execute_cure_script(script_path);
}

// modern buffer-based script execution
core::cure_result execute_static_cure(const std::string& script_content, std::vector<uint8_t>& buffer_data) {
  initialize();

  auto log = redlog::get_logger("p1ll");
  log.inf(
      "executing static cure with buffer", redlog::field("script_size", script_content.size()),
      redlog::field("buffer_size", buffer_data.size())
  );

  // create static context with buffer reference
  auto context = core::p1ll_context::create_static(buffer_data);
  core::set_current_context(std::move(context));

  // execute lua script
  auto result = g_lua_api->execute_script_content(script_content);

  // clear context
  core::clear_current_context();

  return result;
}

core::cure_result execute_static_cure_with_platform(
    const std::string& script_content, std::vector<uint8_t>& buffer_data, const core::platform_key& platform
) {
  initialize();

  auto log = redlog::get_logger("p1ll");
  log.inf(
      "executing static cure with buffer and platform override", redlog::field("script_size", script_content.size()),
      redlog::field("buffer_size", buffer_data.size()), redlog::field("platform", platform.to_string())
  );

  // create static context with buffer reference and platform override
  auto context = core::p1ll_context::create_static(buffer_data, platform);
  core::set_current_context(std::move(context));

  // execute lua script
  auto result = g_lua_api->execute_script_content(script_content);

  // clear context
  core::clear_current_context();

  return result;
}

core::cure_result execute_dynamic_cure(const std::string& script_content) {
  initialize();

  auto log = redlog::get_logger("p1ll");
  log.inf("executing dynamic cure", redlog::field("script_size", script_content.size()));

  // create dynamic context for live memory patching
  auto context = core::p1ll_context::create_dynamic();
  core::set_current_context(std::move(context));

  // execute lua script
  auto result = g_lua_api->execute_script_content(script_content);

  // clear context
  core::clear_current_context();

  return result;
}

// legacy file-based script execution (deprecated)
core::cure_result execute_static_cure(
    const std::string& script_path, const std::string& input_file, const std::string& output_file
) {
  initialize();
  return g_lua_api->execute_static_cure(script_path, input_file, output_file);
}

std::vector<core::module_info> get_modules(const core::signature_query_filter& filter) {
  initialize();
  auto regions_result = g_scanner->get_memory_regions(filter);
  if (!regions_result) {
    return {};
  }

  // convert regions to module_info format for compatibility
  std::vector<core::module_info> modules;
  for (const auto& region : *regions_result) {
    if (!region.name.empty() && region.is_executable) {
      core::module_info module;
      module.name = std::filesystem::path(region.name).filename().string();
      module.base_address = region.base_address;
      module.size = region.size;
      module.path = region.name;
      modules.push_back(module);
    }
  }
  return modules;
}

std::vector<core::search_result> search_signature(
    const std::string& signature_pattern, const core::signature_query_filter& filter
) {
  initialize();

  auto compiled_sig = core::compile_signature(signature_pattern);
  if (compiled_sig.empty()) {
    return {};
  }

  core::signature_query query;
  query.signature = compiled_sig;
  query.filter = filter;

  auto search_result = g_scanner->search(query);
  if (search_result) {
    return *search_result;
  }
  return {};
}

bool patch_memory(uint64_t address, const std::string& patch_pattern) {
  initialize();

  auto compiled_patch = core::compile_patch(patch_pattern);
  if (compiled_patch.empty()) {
    return false;
  }

  // extract bytes to write (only those marked in mask)
  std::vector<uint8_t> patch_bytes;
  for (size_t i = 0; i < compiled_patch.data.size(); ++i) {
    if (compiled_patch.mask[i]) {
      patch_bytes.push_back(compiled_patch.data[i]);
    }
  }

  return g_scanner->write_memory(address, patch_bytes);
}

std::string str2hex(const std::string& str) { return utils::str2hex(str); }

std::string hex2str(const std::string& hex) { return utils::hex2str(hex); }

std::string format_address(uint64_t address) { return utils::format_address(address); }

config config::from_environment() {
  config cfg;

  // read environment variables
  if (const char* cure_env = std::getenv("PILL_CURE")) {
    cfg.cure_script = cure_env;
  }

  if (const char* debug_env = std::getenv("PILL_DEBUG")) {
    cfg.debug_level = std::atoi(debug_env);
  }

  return cfg;
}

} // namespace p1ll

// dynamic entry point for injection
extern "C" void pill_entry() {
  auto log = redlog::get_logger("p1ll.entry");

  // read configuration from environment
  auto cfg = p1ll::config::from_environment();

  // set debug level if specified
  if (cfg.debug_level > 0) {
    // map debug levels: 1=info, 2=debug, 3=trace, 4=pedantic
    redlog::level log_level = redlog::level::info;
    switch (cfg.debug_level) {
    case 1:
      log_level = redlog::level::info;
      break;
    case 2:
      log_level = redlog::level::debug;
      break;
    case 3:
      log_level = redlog::level::trace;
      break;
    default:
      log_level = redlog::level::debug;
      break;
    }
    redlog::set_level(log_level);
  }

  log.inf(
      "p1ll entry point called", redlog::field("cure_script", cfg.cure_script),
      redlog::field("debug_level", cfg.debug_level)
  );

  if (!cfg.cure_script.empty()) {
    log.inf("executing cure script", redlog::field("script", cfg.cure_script));

    auto result = p1ll::execute_cure_script(cfg.cure_script);

    if (result.success) {
      log.inf(
          "cure script completed successfully", redlog::field("patches_applied", result.patches_applied),
          redlog::field("patches_failed", result.patches_failed)
      );
    } else {
      log.err("cure script failed", redlog::field("errors", result.error_messages.size()));
      for (const auto& error : result.error_messages) {
        log.err("cure error", redlog::field("message", error));
      }
    }
  } else {
    log.inf("no cure script specified, p1ll loaded but inactive");
  }
}
```

`src/p1ll/p1ll.hpp`:

```hpp
#pragma once

#include "core/types.hpp"
#include "core/context.hpp"
#include "engine/auto_cure.hpp"
#include "engine/memory_scanner.hpp"
#include "utils/hex_utils.hpp"
#include <string>
#include <memory>

// main p1ll library interface
namespace p1ll {

// library initialization and configuration
void initialize();
void shutdown();

// auto-cure functions (main API)
core::cure_result auto_cure(
    const core::cure_metadata& meta, const core::platform_signature_map& signatures,
    const core::platform_patch_map& patches
);

core::cure_result auto_cure(const core::cure_config& config);

// static file patching
core::cure_result patch_file(
    const std::string& input_path, const std::string& output_path, const core::cure_config& config
);

// modern buffer-based script execution
core::cure_result execute_static_cure(const std::string& script_content, std::vector<uint8_t>& buffer_data);

core::cure_result execute_static_cure_with_platform(
    const std::string& script_content, std::vector<uint8_t>& buffer_data, const core::platform_key& platform
);

core::cure_result execute_dynamic_cure(const std::string& script_content);

core::cure_result execute_static_cure(
    const std::string& script_path, const std::string& input_file, const std::string& output_file
);

// manual patching API (for complex cases)
std::vector<core::module_info> get_modules(const core::signature_query_filter& filter = {});

std::vector<core::search_result> search_signature(
    const std::string& signature_pattern, const core::signature_query_filter& filter = {}
);

bool patch_memory(uint64_t address, const std::string& patch_pattern);

// utility functions
std::string str2hex(const std::string& str);
std::string hex2str(const std::string& hex);
std::string format_address(uint64_t address);

// environment configuration for injection mode
struct config {
  std::string cure_script;
  int debug_level = 0;

  static config from_environment();
};

// dynamic entry point for injection
extern "C" void pill_entry();

} // namespace p1ll
```

`src/p1ll/scripting/lua_api.cpp`:

```cpp
#include "lua_api.hpp"
#include "lua_bindings.hpp"
#include "p1ll.hpp"
#include <redlog.hpp>
#include <fstream>
#include <sstream>

namespace p1ll::scripting {

lua_api::lua_api() {
  setup_lua_environment();
  setup_logging_integration();
}

void lua_api::setup_lua_environment() {
  auto log = redlog::get_logger("p1ll.lua_api");
  log.dbg("setting up lua environment");

  // open standard lua libraries
  lua_.open_libraries(sol::lib::base, sol::lib::string, sol::lib::math, sol::lib::table, sol::lib::io, sol::lib::os);

  // setup p1ll bindings
  setup_p1ll_bindings(lua_);

  log.dbg("lua environment ready");
}

void lua_api::setup_logging_integration() {
  auto log = redlog::get_logger("p1ll.lua_api");
  log.dbg("setting up logging integration");

  // override lua print function to use redlog
  lua_["print"] = [](sol::variadic_args args) {
    auto log = redlog::get_logger("p1ll.lua.print");
    std::ostringstream oss;

    for (const auto& arg : args) {
      if (oss.tellp() > 0) {
        oss << "\t";
      }
      oss << lua_tostring(args.lua_state(), arg.stack_index());
    }

    log.inf(oss.str());
  };

  log.dbg("logging integration complete");
}

core::cure_result lua_api::execute_cure_script(const std::string& script_path) {
  auto log = redlog::get_logger("p1ll.lua_api");

  core::cure_result result;

  log.inf("executing cure script", redlog::field("path", script_path));

  try {
    // load and execute script file
    auto script_result = lua_.script_file(script_path);

    if (!script_result.valid()) {
      sol::error error = script_result;
      result.add_error("lua script error: " + std::string(error.what()));
      log.err("lua script failed", redlog::field("error", error.what()));
      return result;
    }

    // call cure function
    return call_cure_function();

  } catch (const std::exception& e) {
    result.add_error("script execution failed: " + std::string(e.what()));
    log.err("script execution exception", redlog::field("error", e.what()));
    return result;
  }
}

core::cure_result lua_api::execute_script_content(const std::string& script_content) {
  auto log = redlog::get_logger("p1ll.lua_api");

  core::cure_result result;

  log.inf("executing cure script from string");

  try {
    // load and execute script content
    auto script_result = lua_.script(script_content);

    if (!script_result.valid()) {
      sol::error error = script_result;
      result.add_error("lua script error: " + std::string(error.what()));
      log.err("lua script failed", redlog::field("error", error.what()));
      return result;
    }

    // call cure function
    return call_cure_function();

  } catch (const std::exception& e) {
    result.add_error("script execution failed: " + std::string(e.what()));
    log.err("script execution exception", redlog::field("error", e.what()));
    return result;
  }
}

core::cure_result lua_api::execute_static_cure(
    const std::string& script_path, const std::string& input_file, const std::string& output_file
) {
  auto log = redlog::get_logger("p1ll.lua_api");

  log.inf(
      "executing static cure", redlog::field("script", script_path), redlog::field("input", input_file),
      redlog::field("output", output_file)
  );

  core::cure_result result;

  try {
    // set global variables for static mode
    lua_["__static_mode"] = true;
    lua_["__input_file"] = input_file;
    lua_["__output_file"] = output_file;

    // load script first
    auto script_result = lua_.script_file(script_path);

    if (!script_result.valid()) {
      sol::error error = script_result;
      result.add_error("lua script error: " + std::string(error.what()));
      return result;
    }

    // check if cure function exists
    sol::function cure_func = lua_["cure"];
    if (!cure_func.valid()) {
      result.add_error("cure function not found in script");
      return result;
    }

    // call cure function
    auto cure_result = cure_func();
    if (!cure_result.valid()) {
      sol::error error = cure_result;
      result.add_error("cure function failed: " + std::string(error.what()));
      return result;
    }

    // extract result
    if (cure_result.get_type() == sol::type::userdata) {
      return cure_result.get<core::cure_result>();
    } else {
      result.add_error("cure function must call p1.auto_cure() and return the result");
      return result;
    }

  } catch (const std::exception& e) {
    result.add_error("static cure failed: " + std::string(e.what()));
    log.err("static cure exception", redlog::field("error", e.what()));
    return result;
  }
}

core::cure_result lua_api::call_cure_function() {
  auto log = redlog::get_logger("p1ll.lua_api");

  core::cure_result result;

  try {
    // check if cure function exists
    sol::function cure_func = lua_["cure"];
    if (!cure_func.valid()) {
      result.add_error("cure function not found in script");
      log.err("cure function not found");
      return result;
    }

    log.dbg("calling cure function");

    // call cure function
    auto cure_result = cure_func();

    if (!cure_result.valid()) {
      sol::error error = cure_result;
      result.add_error("cure function failed: " + std::string(error.what()));
      log.err("cure function failed", redlog::field("error", error.what()));
      return result;
    }

    // extract result
    if (cure_result.get_type() == sol::type::userdata) {
      auto extracted_result = cure_result.get<core::cure_result>();
      log.inf(
          "cure function completed", redlog::field("success", extracted_result.success),
          redlog::field("applied", extracted_result.patches_applied),
          redlog::field("failed", extracted_result.patches_failed)
      );
      return extracted_result;
    } else {
      result.add_error("cure function returned unexpected type");
      return result;
    }

  } catch (const std::exception& e) {
    result.add_error("cure function call failed: " + std::string(e.what()));
    log.err("cure function exception", redlog::field("error", e.what()));
    return result;
  }
}

} // namespace p1ll::scripting
```

`src/p1ll/scripting/lua_api.hpp`:

```hpp
#pragma once

#include "core/types.hpp"
#include <sol/sol.hpp>
#include <string>
#include <memory>

namespace p1ll::scripting {

// lua script execution engine
class lua_api {
public:
  lua_api();
  ~lua_api() = default;

  // execute cure script from file
  core::cure_result execute_cure_script(const std::string& script_path);

  // execute cure script from string content
  core::cure_result execute_script_content(const std::string& script_content);

  // execute static cure on file
  core::cure_result execute_static_cure(
      const std::string& script_path, const std::string& input_file, const std::string& output_file
  );

  // get lua state for advanced usage
  sol::state& get_lua_state() { return lua_; }

private:
  sol::state lua_;

  void setup_lua_environment();
  void setup_logging_integration();

  // execute cure function from loaded script
  core::cure_result call_cure_function();
};

} // namespace p1ll::scripting
```

`src/p1ll/scripting/lua_bindings.cpp`:

```cpp
#include "lua_bindings.hpp"
#include "p1ll.hpp"
#include <redlog.hpp>

namespace p1ll::scripting {

void setup_p1ll_bindings(sol::state& lua) {
  auto log = redlog::get_logger("p1ll.bindings");
  log.inf("setting up modular p1ll bindings");

  // create the main p1 module (short and beautiful)
  sol::table p1_module = lua.create_table();

  // setup all binding modules in logical order
  log.dbg("setting up core types");
  bindings::setup_core_types(lua, p1_module);

  log.dbg("setting up signature api");
  bindings::setup_signature_api(lua, p1_module);

  log.dbg("setting up patch api");
  bindings::setup_patch_api(lua, p1_module);

  log.dbg("setting up auto-cure api");
  bindings::setup_auto_cure_api(lua, p1_module);

  log.dbg("setting up manual api");
  bindings::setup_manual_api(lua, p1_module);

  log.dbg("setting up utilities");
  bindings::setup_utilities(lua, p1_module);

  // register the p1 module with the lua state
  lua["p1"] = p1_module;

  log.inf("all p1ll bindings registered successfully");
  log.dbg("available in lua as: p1.sig(), p1.patch(), p1.auto_cure(), p1.str2hex(), etc.");
}

namespace bindings {

void setup_core_types(sol::state& lua, sol::table& p1_module) {
  auto log = redlog::get_logger("p1ll.bindings.core");
  log.dbg("setting up core types");

  // expose cure_result for return values
  lua.new_usertype<core::cure_result>(
      "cure_result", "success", &core::cure_result::success, "patches_applied", &core::cure_result::patches_applied,
      "patches_failed", &core::cure_result::patches_failed, "error_messages", &core::cure_result::error_messages,
      "has_errors", &core::cure_result::has_errors
  );

  // expose search_result for manual api
  lua.new_usertype<core::search_result>(
      "search_result", "address", &core::search_result::address, "region_name", &core::search_result::region_name,
      "section_name", &core::search_result::section_name
  );

  // expose module_info for manual api
  lua.new_usertype<core::module_info>(
      "module_info", "name", &core::module_info::name, "path", &core::module_info::path, "base_address",
      &core::module_info::base_address, "size", &core::module_info::size, "permissions",
      &core::module_info::permissions, "is_system_module", &core::module_info::is_system_module
  );

  log.dbg("core types registered");
}

void setup_signature_api(sol::state& lua, sol::table& p1_module) {
  auto log = redlog::get_logger("p1ll.bindings.signature");
  log.dbg("setting up signature api");

  // expose signature_object
  lua.new_usertype<core::signature_object>(
      "signature_object", "pattern", &core::signature_object::pattern, "to_string", &core::signature_object::to_string
  );

  // p1.sig(pattern, opts) - create signature object with optional options table
  p1_module.set_function(
      "sig", [](const std::string& pattern, sol::optional<sol::table> opts) -> core::signature_object {
        // validate pattern
        if (pattern.empty()) {
          throw std::invalid_argument("sig: pattern cannot be empty");
        }

        // basic hex pattern validation - should contain only hex chars, spaces, and wildcards
        for (char c : pattern) {
          if (!std::isxdigit(c) && c != ' ' && c != '?' && c != '\t' && c != '\n' && c != '\r') {
            if (c < 32 || c > 126) { // non-printable
              throw std::invalid_argument("sig: pattern contains invalid character (non-printable)");
            }
          }
        }

        if (opts) {
          sol::table options = *opts;

          // check for filter option
          auto filter_opt = options["filter"];
          // check for single option
          auto single_opt = options["single"];

          core::signature_query_filter filter;
          bool single = false;

          if (filter_opt.valid()) {
            sol::object filter_obj = filter_opt;
            if (filter_obj.is<std::string>()) {
              filter.pattern = filter_obj.as<std::string>();
            } else {
              throw std::invalid_argument("sig: filter option must be a string");
            }
          }

          if (single_opt.valid()) {
            sol::object single_obj = single_opt;
            if (single_obj.is<bool>()) {
              single = single_obj.as<bool>();
            } else {
              throw std::invalid_argument("sig: single option must be a boolean");
            }
          }

          // if we have either filter or single, create with those options
          if (filter_opt.valid() || single_opt.valid()) {
            return core::signature_object(pattern, filter, single);
          }
        }
        return core::signature_object(pattern);
      }
  );

  log.dbg("signature api registered");
}

void setup_patch_api(sol::state& lua, sol::table& p1_module) {
  auto log = redlog::get_logger("p1ll.bindings.patch");
  log.dbg("setting up patch api");

  // p1.patch(sig_obj_or_string, offset, replace, opts) - create patch declaration
  p1_module.set_function(
      "patch",
      [](sol::object sig_param, uint64_t offset, const std::string& replace,
         sol::optional<sol::table> opts) -> core::patch_declaration {
        core::patch_declaration patch;

        // validate and convert signature parameter
        if (sig_param.is<core::signature_object>()) {
          patch.signature = sig_param.as<core::signature_object>();
        } else if (sig_param.is<std::string>()) {
          // auto-convert string to signature_object with warning
          std::string sig_str = sig_param.as<std::string>();
          if (sig_str.empty()) {
            throw std::invalid_argument("patch: signature string cannot be empty");
          }

          // warn about direct string usage
          auto log = redlog::get_logger("p1ll.bindings.patch");
          log.warn(
              "patch: using raw string signature (recommend using p1.sig() instead)",
              redlog::field("signature", sig_str.length() > 50 ? sig_str.substr(0, 50) + "..." : sig_str)
          );

          patch.signature = core::signature_object(sig_str);
        } else {
          throw std::invalid_argument("patch: first argument must be a signature object or string");
        }

        // validate replace pattern
        if (replace.empty()) {
          throw std::invalid_argument("patch: replace pattern cannot be empty");
        }

        // validate hex pattern for replace
        for (char c : replace) {
          if (!std::isxdigit(c) && c != ' ' && c != '\t' && c != '\n' && c != '\r') {
            if (c < 32 || c > 126) { // non-printable
              throw std::invalid_argument("patch: replace pattern contains invalid character (non-printable)");
            }
          }
        }

        patch.offset = offset;
        patch.pattern = replace;
        patch.required = true; // default to required

        // parse options table if provided
        if (opts) {
          sol::table options = *opts;

          // required flag
          auto required = options["required"];
          if (required.valid() && required.is<bool>()) {
            patch.required = required;
          }
        }

        return patch;
      }
  );

  log.dbg("patch api registered");
}

void setup_auto_cure_api(sol::state& lua, sol::table& p1_module) {
  auto log = redlog::get_logger("p1ll.bindings.auto_cure");
  log.dbg("setting up auto-cure api");

  // p1.auto_cure(meta) - execute auto-cure
  p1_module.set_function("auto_cure", [&lua](sol::table meta_table) -> core::cure_result {
    auto log = redlog::get_logger("p1ll.lua.auto_cure");

    try {
      // parse metadata
      core::cure_metadata meta;
      auto name = meta_table["name"];
      if (name.valid() && name.is<std::string>()) {
        meta.name = name;
      }

      auto platforms = meta_table["platforms"];
      if (platforms.valid() && platforms.is<sol::table>()) {
        sol::table platforms_tbl = platforms;
        for (auto& pair : platforms_tbl) {
          sol::object value = pair.second;
          if (value.is<std::string>()) {
            std::string platform_str = value.as<std::string>();
            meta.platforms.push_back(platform_str);
          }
        }
      }

      // parse platform-specific signatures map
      core::platform_signature_map signatures;
      auto sigs_table = meta_table["sigs"];
      if (sigs_table.valid() && sigs_table.is<sol::table>()) {
        sol::table sigs_tbl = sigs_table;
        for (auto& pair : sigs_tbl) {
          sol::object platform_key = pair.first;
          sol::object sig_list = pair.second;
          if (platform_key.is<std::string>() && sig_list.is<sol::table>()) {
            std::vector<core::signature_object> platform_sigs;
            sol::table sig_tbl = sig_list.as<sol::table>();

            for (auto& sig_pair : sig_tbl) {
              sol::object sig_obj = sig_pair.second;
              if (sig_obj.is<core::signature_object>()) {
                core::signature_object sig = sig_obj.as<core::signature_object>();
                platform_sigs.push_back(sig);
              }
            }

            std::string platform_str = platform_key.as<std::string>();
            signatures[platform_str] = platform_sigs;
          }
        }
      }

      // parse platform-specific patches map
      core::platform_patch_map patches;
      auto patches_table = meta_table["patches"];
      if (patches_table.valid() && patches_table.is<sol::table>()) {
        sol::table patches_tbl = patches_table;
        for (auto& pair : patches_tbl) {
          sol::object platform_key = pair.first;
          sol::object patch_list = pair.second;
          if (platform_key.is<std::string>() && patch_list.is<sol::table>()) {
            std::vector<core::patch_declaration> platform_patches;
            sol::table patch_tbl = patch_list.as<sol::table>();

            for (auto& patch_pair : patch_tbl) {
              sol::object patch_obj = patch_pair.second;
              if (patch_obj.is<core::patch_declaration>()) {
                core::patch_declaration patch = patch_obj.as<core::patch_declaration>();
                platform_patches.push_back(patch);
              }
            }

            std::string platform_str = platform_key.as<std::string>();
            patches[platform_str] = platform_patches;
          }
        }
      }

      // get current context to determine mode
      auto current_context = core::get_current_context();
      if (!current_context) {
        log.err("no p1ll context available for auto-cure execution");
        core::cure_result result;
        result.add_error("no p1ll context available - ensure proper initialization");
        return result;
      }

      if (current_context->is_static()) {
        // static buffer patching mode
        log.inf(
            "executing static auto-cure from lua", redlog::field("name", meta.name),
            redlog::field("platforms", meta.platforms.size()), redlog::field("signatures", signatures.size()),
            redlog::field("patch_groups", patches.size())
        );

        // create cure config and execute static buffer patching
        core::cure_config config;
        config.meta = meta;
        config.signatures = signatures;
        config.patches = patches;

        // get buffer from context and patch in-place
        auto& buffer_data = current_context->get_buffer();

        engine::auto_cure_engine engine;
        return engine.execute_static_buffer(buffer_data, config);
      } else {
        // dynamic memory patching mode
        log.inf(
            "executing dynamic auto-cure from lua", redlog::field("name", meta.name),
            redlog::field("platforms", meta.platforms.size()), redlog::field("signatures", signatures.size()),
            redlog::field("patch_groups", patches.size())
        );

        // execute dynamic auto-cure
        return p1ll::auto_cure(meta, signatures, patches);
      }

    } catch (const std::exception& e) {
      log.err("auto-cure execution failed", redlog::field("error", e.what()));
      core::cure_result result;
      result.add_error("lua auto-cure failed: " + std::string(e.what()));
      return result;
    }
  });

  log.dbg("auto-cure api registered");
}

void setup_manual_api(sol::state& lua, sol::table& p1_module) {
  auto log = redlog::get_logger("p1ll.bindings.manual");
  log.dbg("setting up manual api");

  // p1.get_modules(filter) - get modules matching filter
  p1_module.set_function("get_modules", [](sol::optional<sol::object> filter_opt) -> std::vector<core::module_info> {
    core::signature_query_filter filter;

    if (filter_opt) {
      if (filter_opt->is<std::string>()) {
        // simple string filter
        filter.pattern = filter_opt->as<std::string>();
      } else if (filter_opt->is<sol::table>()) {
        // table filter for backward compatibility
        sol::table filter_table = filter_opt->as<sol::table>();
        auto pattern = filter_table["pattern"];
        if (pattern.valid() && pattern.is<std::string>()) {
          filter.pattern = pattern;
        }
      }
    }

    return p1ll::get_modules(filter);
  });

  // p1.search_signature(pattern, filter) - search for signature
  p1_module.set_function(
      "search_signature",
      [](const std::string& pattern, sol::optional<sol::object> filter_opt) -> std::vector<core::search_result> {
        core::signature_query_filter filter;

        if (filter_opt) {
          if (filter_opt->is<std::string>()) {
            // simple string filter
            filter.pattern = filter_opt->as<std::string>();
          } else if (filter_opt->is<sol::table>()) {
            // table filter for backward compatibility
            sol::table filter_table = filter_opt->as<sol::table>();
            auto region_pattern = filter_table["pattern"];
            if (region_pattern.valid() && region_pattern.is<std::string>()) {
              filter.pattern = region_pattern;
            }
          }
        }

        return p1ll::search_signature(pattern, filter);
      }
  );

  // p1.patch_memory(address, pattern) - patch memory directly
  p1_module.set_function("patch_memory", [](uint64_t address, const std::string& pattern) -> bool {
    return p1ll::patch_memory(address, pattern);
  });

  log.dbg("manual api registered");
}

void setup_utilities(sol::state& lua, sol::table& p1_module) {
  auto log = redlog::get_logger("p1ll.bindings.utilities");
  log.dbg("setting up utilities");

  // === hex utilities ===
  p1_module.set_function("str2hex", [](const std::string& str) -> std::string { return p1ll::str2hex(str); });

  p1_module.set_function("hex2str", [](const std::string& hex) -> std::string { return p1ll::hex2str(hex); });

  p1_module.set_function("format_address", [](uint64_t address) -> std::string {
    return p1ll::format_address(address);
  });

  // === logging functions ===
  p1_module.set_function("log_info", [](const std::string& msg) {
    auto log = redlog::get_logger("p1ll.lua");
    log.inf(msg);
  });

  p1_module.set_function("log_warn", [](const std::string& msg) {
    auto log = redlog::get_logger("p1ll.lua");
    log.wrn(msg);
  });

  p1_module.set_function("log_err", [](const std::string& msg) {
    auto log = redlog::get_logger("p1ll.lua");
    log.err(msg);
  });

  p1_module.set_function("log_dbg", [](const std::string& msg) {
    auto log = redlog::get_logger("p1ll.lua");
    log.dbg(msg);
  });

  log.dbg("utilities registered");
}

} // namespace bindings

} // namespace p1ll::scripting
```

`src/p1ll/scripting/lua_bindings.hpp`:

```hpp
#pragma once

#include <sol/sol.hpp>
#include "core/types.hpp"

namespace p1ll::scripting {

/**
 * @brief Setup comprehensive p1ll bindings for Lua scripting
 *
 * This function orchestrates the setup of all p1ll-related bindings
 * for the Lua scripting environment. It creates the main 'p1' module
 * and provides the beautiful declarative auto-cure API.
 *
 * Key features:
 * - Signature creation and compilation
 * - Patch declarations with module filtering
 * - Auto-cure orchestration
 * - Manual patching API for complex cases
 * - Utility functions (str2hex, hex2str, format_address)
 *
 * @param lua The Sol2 Lua state to register all bindings with
 */
void setup_p1ll_bindings(sol::state& lua);

namespace bindings {

/**
 * @brief Setup core p1ll types and enums
 * @param lua The Sol2 Lua state to register bindings with
 * @param p1_module The p1 module table to add bindings to
 */
void setup_core_types(sol::state& lua, sol::table& p1_module);

/**
 * @brief Setup signature API functions
 * @param lua The Sol2 Lua state to register bindings with
 * @param p1_module The p1 module table to add bindings to
 */
void setup_signature_api(sol::state& lua, sol::table& p1_module);

/**
 * @brief Setup patch API functions
 * @param lua The Sol2 Lua state to register bindings with
 * @param p1_module The p1 module table to add bindings to
 */
void setup_patch_api(sol::state& lua, sol::table& p1_module);

/**
 * @brief Setup auto-cure API functions
 * @param lua The Sol2 Lua state to register bindings with
 * @param p1_module The p1 module table to add bindings to
 */
void setup_auto_cure_api(sol::state& lua, sol::table& p1_module);

/**
 * @brief Setup manual patching API for complex cases
 * @param lua The Sol2 Lua state to register bindings with
 * @param p1_module The p1 module table to add bindings to
 */
void setup_manual_api(sol::state& lua, sol::table& p1_module);

/**
 * @brief Setup utility functions
 * @param lua The Sol2 Lua state to register bindings with
 * @param p1_module The p1 module table to add bindings to
 */
void setup_utilities(sol::state& lua, sol::table& p1_module);

} // namespace bindings

} // namespace p1ll::scripting

```

`src/p1ll/utils/file_utils.cpp`:

```cpp
#include "file_utils.hpp"
#include <fstream>
#include <filesystem>
#include <iterator>

namespace p1ll::utils {

std::optional<std::vector<uint8_t>> read_file(const std::string& file_path) {
  std::ifstream file(file_path, std::ios::binary);
  if (!file.is_open()) {
    return std::nullopt;
  }

  std::vector<uint8_t> data;
  data.assign(std::istreambuf_iterator<char>(file), std::istreambuf_iterator<char>());
  return data;
}

std::optional<std::string> read_file_string(const std::string& file_path) {
  std::ifstream file(file_path);
  if (!file.is_open()) {
    return std::nullopt;
  }

  std::string content;
  content.assign(std::istreambuf_iterator<char>(file), std::istreambuf_iterator<char>());
  return content;
}

bool write_file(const std::string& file_path, const std::vector<uint8_t>& data) {
  std::ofstream file(file_path, std::ios::binary);
  if (!file.is_open()) {
    return false;
  }

  file.write(reinterpret_cast<const char*>(data.data()), data.size());
  return file.good();
}

bool write_file(const std::string& file_path, const std::string& data) {
  std::ofstream file(file_path);
  if (!file.is_open()) {
    return false;
  }

  file << data;
  return file.good();
}

bool file_exists(const std::string& file_path) { return std::filesystem::exists(file_path); }

std::optional<size_t> get_file_size(const std::string& file_path) {
  std::error_code ec;
  auto size = std::filesystem::file_size(file_path, ec);
  if (ec) {
    return std::nullopt;
  }
  return size;
}

} // namespace p1ll::utils
```

`src/p1ll/utils/file_utils.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>
#include <optional>
#include <cstdint>

namespace p1ll::utils {

// file reading/writing utilities
std::optional<std::vector<uint8_t>> read_file(const std::string& file_path);
std::optional<std::string> read_file_string(const std::string& file_path);
bool write_file(const std::string& file_path, const std::vector<uint8_t>& data);
bool write_file(const std::string& file_path, const std::string& data);

// file system utilities
bool file_exists(const std::string& file_path);
std::optional<size_t> get_file_size(const std::string& file_path);

} // namespace p1ll::utils
```

`src/p1ll/utils/hex_utils.cpp`:

```cpp
#include "hex_utils.hpp"
#include "core/types.hpp"
#include <redlog.hpp>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <cctype>

namespace p1ll::utils {

std::string str2hex(const std::string& str) {
  std::ostringstream oss;
  for (unsigned char c : str) {
    oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(c);
  }
  return oss.str();
}

std::string hex2str(const std::string& hex) {
  auto log = redlog::get_logger("p1ll.hex_utils");

  std::string result;
  std::string clean_hex = normalize_hex_pattern(hex);

  if (clean_hex.length() % 2 != 0) {
    log.err("hex string has odd length", redlog::field("hex", hex));
    return "";
  }

  for (size_t i = 0; i < clean_hex.length(); i += 2) {
    char hex_byte[3] = {clean_hex[i], clean_hex[i + 1], '\0'};

    if (!is_hex_digit(hex_byte[0]) || !is_hex_digit(hex_byte[1])) {
      log.err("invalid hex digit", redlog::field("byte", hex_byte));
      return "";
    }

    uint8_t byte = static_cast<uint8_t>(std::stoul(hex_byte, nullptr, 16));
    result.push_back(static_cast<char>(byte));
  }

  return result;
}

bool is_valid_hex_pattern(const std::string& pattern) {
  std::string normalized = normalize_hex_pattern(pattern);

  // check if length is even (each byte needs 2 hex digits or ?? wildcard)
  if (normalized.length() % 2 != 0) {
    return false;
  }

  // validate each byte position
  for (size_t i = 0; i < normalized.length(); i += 2) {
    char first = normalized[i];
    char second = normalized[i + 1];

    // either both are hex digits or both are wildcards
    if ((first == '?' && second == '?') || (is_hex_digit(first) && is_hex_digit(second))) {
      continue;
    } else {
      return false;
    }
  }

  return true;
}

std::vector<uint8_t> parse_hex_bytes(const std::string& hex) {
  auto log = redlog::get_logger("p1ll.hex_utils");

  std::vector<uint8_t> bytes;
  std::string clean_hex = normalize_hex_pattern(hex);

  if (!is_valid_hex_pattern(clean_hex)) {
    log.err("invalid hex pattern", redlog::field("pattern", hex));
    return bytes;
  }

  for (size_t i = 0; i < clean_hex.length(); i += 2) {
    char hex_byte[3] = {clean_hex[i], clean_hex[i + 1], '\0'};

    if (hex_byte[0] == '?' && hex_byte[1] == '?') {
      // wildcard byte, use 0x00 as placeholder
      bytes.push_back(0x00);
    } else {
      uint8_t byte = static_cast<uint8_t>(std::stoul(hex_byte, nullptr, 16));
      bytes.push_back(byte);
    }
  }

  return bytes;
}

std::string strip_comments(const std::string& pattern) {
  std::string result;
  std::istringstream stream(pattern);
  std::string line;

  while (std::getline(stream, line)) {
    // find the first comment delimiter
    size_t comment_pos = std::string::npos;

    // check for -- comment
    size_t pos = line.find("--");
    if (pos != std::string::npos) {
      comment_pos = pos;
    }

    // check for // comment
    pos = line.find("//");
    if (pos != std::string::npos && pos < comment_pos) {
      comment_pos = pos;
    }

    // check for # comment
    pos = line.find('#');
    if (pos != std::string::npos && pos < comment_pos) {
      comment_pos = pos;
    }

    // check for ; comment
    pos = line.find(';');
    if (pos != std::string::npos && pos < comment_pos) {
      comment_pos = pos;
    }

    // extract the part before the comment
    if (comment_pos != std::string::npos) {
      line = line.substr(0, comment_pos);
    }

    // add the line to result (with a space separator if needed)
    if (!result.empty() && !line.empty()) {
      result += " ";
    }
    result += line;
  }

  return result;
}

std::string normalize_hex_pattern(const std::string& pattern) {
  // first strip comments
  std::string stripped = strip_comments(pattern);

  std::string result;
  result.reserve(stripped.length());

  for (char c : stripped) {
    if (std::isspace(c)) {
      // skip whitespace
      continue;
    } else if (std::isalpha(c)) {
      // convert to lowercase
      result.push_back(std::tolower(c));
    } else {
      // numbers, question marks, etc.
      result.push_back(c);
    }
  }

  return result;
}

std::string format_address(uint64_t address) {
  std::ostringstream oss;
  oss << "0x" << std::hex << std::setw(16) << std::setfill('0') << address;
  return oss.str();
}

std::string format_bytes(const std::vector<uint8_t>& bytes) {
  std::ostringstream oss;
  for (size_t i = 0; i < bytes.size(); ++i) {
    if (i > 0) {
      oss << " ";
    }
    oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(bytes[i]);
  }
  return oss.str();
}

bool is_hex_digit(char c) { return std::isdigit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'); }

uint8_t parse_hex_digit(char c) {
  if (std::isdigit(c)) {
    return static_cast<uint8_t>(c - '0');
  } else if (c >= 'a' && c <= 'f') {
    return static_cast<uint8_t>(c - 'a' + 10);
  } else if (c >= 'A' && c <= 'F') {
    return static_cast<uint8_t>(c - 'A' + 10);
  }
  return 0; // invalid
}

std::string to_hex_string(uint8_t byte) {
  std::ostringstream oss;
  oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte);
  return oss.str();
}

// pattern visualization
std::string format_compiled_signature(const core::compiled_signature& sig) {
  std::ostringstream result;
  for (size_t i = 0; i < sig.pattern.size(); i++) {
    if (sig.mask[i]) {
      // exact byte (lowercase hex)
      result << std::hex << std::setw(2) << std::setfill('0') << std::nouppercase << static_cast<int>(sig.pattern[i]);
    } else {
      // wildcard
      result << "??";
    }
    if (i < sig.pattern.size() - 1) {
      result << " ";
    }
  }
  return result.str();
}

std::string format_memory_range(uint64_t start_addr, uint64_t end_addr) {
  size_t range_size = static_cast<size_t>(end_addr - start_addr);
  std::ostringstream oss;
  oss << "range([$" << std::hex << std::setw(16) << std::setfill('0') << std::nouppercase << start_addr << "-$"
      << std::setw(16) << std::setfill('0') << end_addr << "], sz=" << std::dec << range_size << ")";
  return oss.str();
}

std::string format_memory_region(uint64_t start_addr, uint64_t size, const std::string& name) {
  uint64_t end_addr = start_addr + size;
  std::ostringstream oss;
  oss << "region([$" << std::hex << std::setw(16) << std::setfill('0') << std::nouppercase << start_addr << "-$"
      << std::setw(16) << std::setfill('0') << end_addr << "], sz=" << std::dec << size;
  if (!name.empty()) {
    oss << ", name=" << name;
  }
  oss << ")";
  return oss.str();
}

std::string format_hex_bytes(const uint8_t* data, size_t size, size_t max_bytes) {
  std::ostringstream oss;
  size_t display_size = std::min(size, max_bytes);

  for (size_t i = 0; i < display_size; i++) {
    oss << std::hex << std::setw(2) << std::setfill('0') << std::nouppercase << static_cast<int>(data[i]);
    if (i < display_size - 1) {
      oss << " ";
    }
  }

  if (size > max_bytes) {
    oss << " ... (+" << (size - max_bytes) << " bytes)";
  }

  return oss.str();
}

} // namespace p1ll::utils
```

`src/p1ll/utils/hex_utils.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>
#include <cstdint>

// forward declarations
namespace p1ll::core {
struct compiled_signature;
}

namespace p1ll::utils {

// string to hex conversion
std::string str2hex(const std::string& str);
std::string hex2str(const std::string& hex);

// pattern validation and parsing
bool is_valid_hex_pattern(const std::string& pattern);
std::vector<uint8_t> parse_hex_bytes(const std::string& hex);
std::string strip_comments(const std::string& pattern);
std::string normalize_hex_pattern(const std::string& pattern);

// address formatting
std::string format_address(uint64_t address);
std::string format_bytes(const std::vector<uint8_t>& bytes);

// hex digit utilities
bool is_hex_digit(char c);
uint8_t parse_hex_digit(char c);
std::string to_hex_string(uint8_t byte);

// pattern visualization
std::string format_compiled_signature(const core::compiled_signature& sig);
std::string format_memory_range(uint64_t start_addr, uint64_t end_addr);
std::string format_memory_region(uint64_t start_addr, uint64_t size, const std::string& name);
std::string format_hex_bytes(const uint8_t* data, size_t size, size_t max_bytes = 16);

} // namespace p1ll::utils
```

`src/p1ll/utils/pretty_hexdump.cpp`:

```cpp
#include "pretty_hexdump.hpp"
#include <redlog.hpp>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <vector>

namespace p1ll::utils {

namespace {

// color scheme for different element types
constexpr auto offset_color = redlog::color::bright_cyan;
constexpr auto unchanged_color = redlog::color::white;
constexpr auto before_change_color = redlog::color::cyan;
constexpr auto after_change_color = redlog::color::red;
constexpr auto signature_match_color = redlog::color::bright_green;
constexpr auto context_color = redlog::color::bright_black;
constexpr auto ascii_color = redlog::color::bright_black;

/**
 * format a single hex byte with optional color.
 */
std::string format_hex_byte(uint8_t byte, redlog::color color = redlog::color::none) {
  std::ostringstream oss;
  oss << std::hex << std::setw(2) << std::setfill('0') << std::nouppercase << static_cast<int>(byte);
  return redlog::detail::colorize(oss.str(), color);
}

/**
 * format a printable ascii character with optional color.
 */
std::string format_ascii_char(uint8_t byte, redlog::color color = redlog::color::none) {
  char c = (byte >= 32 && byte <= 126) ? static_cast<char>(byte) : '.';
  return redlog::detail::colorize(std::string(1, c), color);
}

/**
 * format an address offset with consistent width and color.
 */
std::string format_offset(uint64_t offset) {
  std::ostringstream oss;
  oss << std::hex << std::setw(8) << std::setfill('0') << std::nouppercase << offset << ":";
  return redlog::detail::colorize(oss.str(), offset_color);
}

/**
 * detect which bytes differ between two arrays.
 */
std::vector<bool> find_byte_differences(const uint8_t* a, const uint8_t* b, size_t size) {
  std::vector<bool> differences(size);
  for (size_t i = 0; i < size; ++i) {
    differences[i] = (a[i] != b[i]);
  }
  return differences;
}

/**
 * format a line of hex bytes with optional highlighting.
 */
std::string format_hex_line(
    const uint8_t* data, size_t line_size, size_t bytes_per_line, const std::vector<bool>& highlight_mask = {},
    redlog::color highlight_color = redlog::color::none
) {
  std::ostringstream oss;

  for (size_t i = 0; i < bytes_per_line; ++i) {
    if (i > 0) {
      oss << " ";
    }

    if (i < line_size) {
      redlog::color color = unchanged_color;
      if (!highlight_mask.empty() && i < highlight_mask.size() && highlight_mask[i]) {
        color = highlight_color;
      }
      oss << format_hex_byte(data[i], color);
    } else {
      // padding for incomplete lines
      oss << "  ";
    }

    // add extra space every 8 bytes for readability
    if (i == 7) {
      oss << " ";
    }
  }

  return oss.str();
}

/**
 * format ascii representation of a line with optional highlighting.
 */
std::string format_ascii_line(
    const uint8_t* data, size_t line_size, const std::vector<bool>& highlight_mask = {},
    redlog::color highlight_color = redlog::color::none
) {
  std::ostringstream oss;
  oss << "|";

  for (size_t i = 0; i < line_size; ++i) {
    redlog::color color = ascii_color;
    if (!highlight_mask.empty() && i < highlight_mask.size() && highlight_mask[i]) {
      color = highlight_color;
    }
    oss << format_ascii_char(data[i], color);
  }

  oss << "|";
  return oss.str();
}

} // anonymous namespace

std::string format_hexdump(const uint8_t* data, size_t size, uint64_t base_offset, const hexdump_options& opts) {
  if (!data || size == 0) {
    return "";
  }

  std::ostringstream result;
  size_t lines_shown = 0;

  // calculate 16-byte aligned boundaries
  uint64_t aligned_start = base_offset & ~0xF;
  uint64_t aligned_end = (base_offset + size + 15) & ~0xF;

  // calculate padding at start and end
  size_t start_padding = base_offset - aligned_start;
  size_t total_aligned_size = aligned_end - aligned_start;

  for (size_t aligned_offset = 0; aligned_offset < total_aligned_size; aligned_offset += opts.bytes_per_line) {
    if (lines_shown >= opts.max_lines) {
      result << "... (truncated, " << (total_aligned_size - aligned_offset) << " more bytes)\n";
      break;
    }

    uint64_t display_offset = aligned_start + aligned_offset;
    result << format_offset(display_offset) << "  ";

    // format hex bytes for this line
    for (size_t i = 0; i < opts.bytes_per_line; ++i) {
      if (i > 0) {
        result << " ";
      }
      if (i == 8) {
        result << " "; // extra space after 8 bytes
      }

      size_t data_pos = aligned_offset + i;
      if (data_pos < start_padding || data_pos >= start_padding + size) {
        // padding byte
        result << "  ";
      } else {
        // actual data byte
        size_t data_index = data_pos - start_padding;
        result << format_hex_byte(data[data_index], unchanged_color);
      }
    }

    if (opts.show_ascii) {
      result << "  |";
      for (size_t i = 0; i < opts.bytes_per_line; ++i) {
        size_t data_pos = aligned_offset + i;
        if (data_pos < start_padding || data_pos >= start_padding + size) {
          // padding byte
          result << " ";
        } else {
          // actual data byte
          size_t data_index = data_pos - start_padding;
          result << format_ascii_char(data[data_index], ascii_color);
        }
      }
      result << "|";
    }

    result << "\n";
    lines_shown++;
  }

  return result.str();
}

std::string format_patch_hexdump(
    const uint8_t* before_data, const uint8_t* after_data, size_t size, uint64_t base_offset,
    const hexdump_options& opts
) {
  if (!before_data || !after_data || size == 0) {
    return "";
  }

  std::ostringstream result;
  size_t lines_shown = 0;

  // find differences in the actual data
  auto differences = find_byte_differences(before_data, after_data, size);

  // iterate through data, showing full 16-byte aligned rows
  for (size_t offset = 0; offset < size; offset += opts.bytes_per_line) {
    if (lines_shown >= opts.max_lines) {
      result << "... (truncated)\n";
      break;
    }

    size_t line_size = std::min(opts.bytes_per_line, size - offset);
    uint64_t display_offset = base_offset + offset;

    // before line
    result << format_offset(display_offset) << "  ";

    // format hex bytes for this line
    for (size_t i = 0; i < opts.bytes_per_line; ++i) {
      if (i > 0) {
        result << " ";
      }
      if (i == 8) {
        result << " "; // extra space after 8 bytes
      }

      if (i < line_size) {
        // actual data byte
        bool is_different = differences[offset + i];
        redlog::color color = is_different ? before_change_color : unchanged_color;
        result << format_hex_byte(before_data[offset + i], color);
      } else {
        // padding for incomplete line
        result << "  ";
      }
    }

    if (opts.show_ascii) {
      result << "  |";
      for (size_t i = 0; i < opts.bytes_per_line; ++i) {
        if (i < line_size) {
          // actual data byte
          bool is_different = differences[offset + i];
          redlog::color color = is_different ? before_change_color : ascii_color;
          result << format_ascii_char(before_data[offset + i], color);
        } else {
          // padding for incomplete line
          result << " ";
        }
      }
      result << "|";
    }
    result << "\n";

    // after line - same offset, no label for clean alignment
    result << format_offset(display_offset) << "  ";

    // format hex bytes for this line
    for (size_t i = 0; i < opts.bytes_per_line; ++i) {
      if (i > 0) {
        result << " ";
      }
      if (i == 8) {
        result << " "; // extra space after 8 bytes
      }

      if (i < line_size) {
        // actual data byte
        bool is_different = differences[offset + i];
        redlog::color color = is_different ? after_change_color : unchanged_color;
        result << format_hex_byte(after_data[offset + i], color);
      } else {
        // padding for incomplete line
        result << "  ";
      }
    }

    if (opts.show_ascii) {
      result << "  |";
      for (size_t i = 0; i < opts.bytes_per_line; ++i) {
        if (i < line_size) {
          // actual data byte
          bool is_different = differences[offset + i];
          redlog::color color = is_different ? after_change_color : ascii_color;
          result << format_ascii_char(after_data[offset + i], color);
        } else {
          // padding for incomplete line
          result << " ";
        }
      }
      result << "|";
    }
    result << "\n";

    lines_shown++;
  }

  return result.str();
}

std::string format_signature_match_hexdump(
    const uint8_t* data, size_t data_size, size_t match_offset, size_t pattern_size, uint64_t base_offset,
    const hexdump_options& opts
) {
  if (!data || data_size == 0 || match_offset >= data_size) {
    return "";
  }

  // calculate context boundaries with alignment
  size_t context_start = (match_offset >= opts.context_bytes) ? match_offset - opts.context_bytes : 0;
  size_t context_end = std::min(data_size, match_offset + pattern_size + opts.context_bytes);

  // align context boundaries to 16-byte boundaries
  size_t aligned_start = context_start & ~0xF;
  size_t aligned_end = (context_end + 15) & ~0xF;

  // ensure we don't go past data boundaries
  if (aligned_end > data_size) {
    aligned_end = data_size;
  }

  std::ostringstream result;
  size_t lines_shown = 0;

  for (size_t offset = aligned_start; offset < aligned_end; offset += opts.bytes_per_line) {
    if (lines_shown >= opts.max_lines) {
      result << "... (truncated)\n";
      break;
    }

    uint64_t display_offset = base_offset + offset;
    result << format_offset(display_offset) << "  ";

    // format hex bytes for this line
    for (size_t i = 0; i < opts.bytes_per_line; ++i) {
      if (i > 0) {
        result << " ";
      }
      if (i == 8) {
        result << " "; // extra space after 8 bytes
      }

      size_t absolute_pos = offset + i;
      if (absolute_pos >= data_size) {
        // past end of data
        result << "  ";
      } else {
        // determine if this byte is part of the match
        bool is_match = absolute_pos >= match_offset && absolute_pos < match_offset + pattern_size;
        redlog::color color = is_match ? signature_match_color : unchanged_color;
        result << format_hex_byte(data[absolute_pos], color);
      }
    }

    if (opts.show_ascii) {
      result << "  |";
      for (size_t i = 0; i < opts.bytes_per_line; ++i) {
        size_t absolute_pos = offset + i;
        if (absolute_pos >= data_size) {
          // past end of data
          result << " ";
        } else {
          // determine if this byte is part of the match
          bool is_match = absolute_pos >= match_offset && absolute_pos < match_offset + pattern_size;
          redlog::color color = is_match ? signature_match_color : ascii_color;
          result << format_ascii_char(data[absolute_pos], color);
        }
      }
      result << "|";
    }

    result << "\n";
    lines_shown++;
  }

  return result.str();
}

std::string format_patch_hexdump(
    const std::vector<uint8_t>& before, const std::vector<uint8_t>& after, uint64_t base_offset,
    const hexdump_options& opts
) {
  if (before.size() != after.size()) {
    return "error: before and after vectors must be same size\n";
  }

  return format_patch_hexdump(before.data(), after.data(), before.size(), base_offset, opts);
}

std::string format_hexdump(const std::vector<uint8_t>& data, uint64_t base_offset, const hexdump_options& opts) {
  return format_hexdump(data.data(), data.size(), base_offset, opts);
}

} // namespace p1ll::utils
```

`src/p1ll/utils/pretty_hexdump.hpp`:

```hpp
#pragma once

#include <string>
#include <cstdint>
#include <vector>

namespace p1ll::utils {

/**
 * options for controlling hexdump formatting and appearance.
 */
struct hexdump_options {
  size_t bytes_per_line = 16; // number of bytes to display per line
  bool show_ascii = true;     // include ascii representation column
  bool show_offset = true;    // include offset column
  size_t context_bytes = 8;   // context bytes for signature matches
  size_t max_lines = 32;      // maximum lines to display (prevents spam)
};

/**
 * create a beautiful hexdump of memory data.
 * respects redlog color settings and produces clean, aligned output.
 *
 * @param data pointer to data to dump
 * @param size number of bytes to dump
 * @param base_offset base address offset for display
 * @param opts formatting options
 * @return formatted hexdump string
 */
std::string format_hexdump(
    const uint8_t* data, size_t size, uint64_t base_offset = 0, const hexdump_options& opts = {}
);

/**
 * create a side-by-side patch comparison hexdump showing before/after changes.
 * changed bytes are color-coded: before in cyan, after in red.
 * unchanged bytes remain in default color.
 *
 * @param before_data original data
 * @param after_data patched data
 * @param size number of bytes to compare
 * @param base_offset base address offset for display
 * @param opts formatting options
 * @return formatted side-by-side comparison string
 */
std::string format_patch_hexdump(
    const uint8_t* before_data, const uint8_t* after_data, size_t size, uint64_t base_offset = 0,
    const hexdump_options& opts = {}
);

/**
 * create a signature match hexdump highlighting the matched pattern.
 * matched bytes are highlighted in green with surrounding context in gray.
 *
 * @param data memory data containing the match
 * @param data_size total size of data buffer
 * @param match_offset offset where pattern was found
 * @param pattern_size size of matched pattern
 * @param base_offset base address offset for display
 * @param opts formatting options
 * @return formatted signature match visualization
 */
std::string format_signature_match_hexdump(
    const uint8_t* data, size_t data_size, size_t match_offset, size_t pattern_size, uint64_t base_offset = 0,
    const hexdump_options& opts = {}
);

/**
 * convenience function to create a patch comparison for vectors.
 */
std::string format_patch_hexdump(
    const std::vector<uint8_t>& before, const std::vector<uint8_t>& after, uint64_t base_offset = 0,
    const hexdump_options& opts = {}
);

/**
 * convenience function to create a hexdump for a vector.
 */
std::string format_hexdump(
    const std::vector<uint8_t>& data, uint64_t base_offset = 0, const hexdump_options& opts = {}
);

} // namespace p1ll::utils
```

`src/p1llx/CMakeLists.txt`:

```txt
# p1llx static binary patcher tool

# check if lua scripting is enabled (required for p1ll)
include(${WITNESS_SOURCE_DIR}/cmake/LuaConfig.cmake)

if(WITNESS_SCRIPT)
    # p1llx executable sources
    set(P1LLX_SOURCES
        main.cpp
        commands/cure.cpp
        commands/patch.cpp
        commands/poison.cpp
    )
    
    # create executable
    add_executable(p1llx ${P1LLX_SOURCES})
    
    # link with p1ll library and dependencies
    target_link_libraries(p1llx 
        PRIVATE 
        p1ll
        w1nj3ct
        redlog::redlog
    )
    
    # include directories
    target_include_directories(p1llx 
        PRIVATE 
        ${CMAKE_CURRENT_SOURCE_DIR}/..
        ${CMAKE_CURRENT_SOURCE_DIR}/../common
    )
    
    # set output directory to root like w1tool
    set_target_properties(p1llx PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})
    
    message(STATUS "p1llx static patcher tool configured")
    
else()
    message(STATUS "p1llx tool skipped - lua scripting not enabled")
endif()
```

`src/p1llx/commands/cure.cpp`:

```cpp
#include "cure.hpp"
#include <p1ll/p1ll.hpp>
#include <p1ll/core/platform.hpp>
#include <redlog.hpp>
#include <iostream>
#include <fstream>
#include <sstream>

namespace p1llx::commands {

int cure(
    const std::string& script_path, const std::string& input_file, const std::string& output_file,
    const std::string& platform_override
) {

  auto log = redlog::get_logger("p1llx.commands.cure");

  log.inf(
      "applying cure script to file", redlog::field("script", script_path), redlog::field("input", input_file),
      redlog::field("output", output_file), redlog::field("platform", platform_override)
  );

  try {
    // read script content
    std::ifstream script_stream(script_path);
    if (!script_stream) {
      std::cerr << "failed to open script file: " << script_path << std::endl;
      return 1;
    }

    std::ostringstream script_buffer;
    script_buffer << script_stream.rdbuf();
    std::string script_content = script_buffer.str();

    log.dbg("loaded script content", redlog::field("size", script_content.size()));

    // read input file to buffer
    std::ifstream input_stream(input_file, std::ios::binary);
    if (!input_stream) {
      std::cerr << "failed to open input file: " << input_file << std::endl;
      return 1;
    }

    std::vector<uint8_t> buffer_data((std::istreambuf_iterator<char>(input_stream)), std::istreambuf_iterator<char>());

    log.dbg("loaded input file", redlog::field("size", buffer_data.size()));

    // execute static cure with buffer
    p1ll::core::cure_result result;
    if (!platform_override.empty()) {
      // parse platform override
      try {
        auto platform_key = p1ll::core::parse_platform_key(platform_override);
        log.inf("using platform override", redlog::field("platform", platform_key.to_string()));
        result = p1ll::execute_static_cure_with_platform(script_content, buffer_data, platform_key);
      } catch (const std::exception& e) {
        log.err(
            "invalid platform override", redlog::field("platform", platform_override), redlog::field("error", e.what())
        );
        std::cerr << "invalid platform override '" << platform_override << "': " << e.what() << std::endl;
        return 1;
      }
    } else {
      result = p1ll::execute_static_cure(script_content, buffer_data);
    }

    if (result.success) {
      // write modified buffer to output file
      std::ofstream output_stream(output_file, std::ios::binary);
      if (!output_stream) {
        std::cerr << "failed to create output file: " << output_file << std::endl;
        return 1;
      }

      output_stream.write(reinterpret_cast<const char*>(buffer_data.data()), buffer_data.size());

      log.inf(
          "cure completed successfully", redlog::field("patches_applied", result.patches_applied),
          redlog::field("patches_failed", result.patches_failed)
      );

      // print summary to user
      std::cout << "cure completed successfully" << std::endl;
      std::cout << "patches applied: " << result.patches_applied << std::endl;
      if (result.patches_failed > 0) {
        std::cout << "patches failed: " << result.patches_failed << std::endl;
      }

      return 0;
    } else {
      log.err("cure failed", redlog::field("errors", result.error_messages.size()));

      std::cerr << "cure failed with " << result.error_messages.size() << " errors:" << std::endl;
      for (const auto& error : result.error_messages) {
        std::cerr << "  error: " << error << std::endl;
        log.err("cure error detail", redlog::field("message", error));
      }

      return 1;
    }

  } catch (const std::exception& e) {
    log.err("cure execution failed", redlog::field("error", e.what()));
    std::cerr << "cure execution failed: " << e.what() << std::endl;
    return 1;
  }
}

} // namespace p1llx::commands
```

`src/p1llx/commands/cure.hpp`:

```hpp
#pragma once

#include <string>

namespace p1llx::commands {

/**
 * @brief Apply auto-cure lua script to static file
 *
 * @param script_path Path to lua cure script
 * @param input_file Path to input binary file
 * @param output_file Path to output binary file
 * @param platform_override Optional platform override (e.g., "linux:x64", "darwin:arm64")
 * @return 0 for success, 1 for failure
 */
int cure(
    const std::string& script_path, const std::string& input_file, const std::string& output_file,
    const std::string& platform_override = ""
);

} // namespace p1llx::commands
```

`src/p1llx/commands/patch.cpp`:

```cpp
#include "patch.hpp"
#include <p1ll/p1ll.hpp>
#include <p1ll/core/signature.hpp>
#include <p1ll/utils/hex_utils.hpp>
#include <redlog.hpp>
#include <fstream>
#include <iostream>

namespace p1llx::commands {

int patch(
    const std::string& address_str, const std::string& replace_data, const std::string& input_file,
    const std::string& output_file
) {

  auto log = redlog::get_logger("p1llx.commands.patch");

  log.inf(
      "applying manual patch", redlog::field("address", address_str), redlog::field("replace", replace_data),
      redlog::field("input", input_file), redlog::field("output", output_file)
  );

  try {
    // parse address (support both 0x prefix and plain hex)
    uint64_t address;
    if (address_str.substr(0, 2) == "0x" || address_str.substr(0, 2) == "0X") {
      address = std::stoull(address_str, nullptr, 16);
    } else {
      address = std::stoull(address_str, nullptr, 16);
    }

    // validate hex pattern
    if (!p1ll::utils::is_valid_hex_pattern(replace_data)) {
      log.err("invalid replacement hex pattern", redlog::field("pattern", replace_data));
      std::cerr << "error: invalid hex pattern: " << replace_data << std::endl;
      return 1;
    }

    // read input file
    std::ifstream input(input_file, std::ios::binary | std::ios::ate);
    if (!input.is_open()) {
      log.err("failed to open input file", redlog::field("path", input_file));
      std::cerr << "error: could not open input file: " << input_file << std::endl;
      return 1;
    }

    auto file_size = input.tellg();
    input.seekg(0, std::ios::beg);

    std::vector<uint8_t> file_data(static_cast<size_t>(file_size));
    input.read(reinterpret_cast<char*>(file_data.data()), file_size);
    input.close();

    if (!input) {
      log.err("failed to read input file", redlog::field("path", input_file));
      std::cerr << "error: failed to read input file: " << input_file << std::endl;
      return 1;
    }

    // compile patch
    auto compiled_patch = p1ll::core::compile_patch(replace_data);
    if (compiled_patch.empty()) {
      log.err("failed to compile patch", redlog::field("pattern", replace_data));
      std::cerr << "error: failed to compile patch pattern: " << replace_data << std::endl;
      return 1;
    }

    // check bounds
    if (address + compiled_patch.size() > file_data.size()) {
      log.err(
          "patch would exceed file bounds", redlog::field("address", address),
          redlog::field("patch_size", compiled_patch.size()), redlog::field("file_size", file_data.size())
      );
      std::cerr << "error: patch would exceed file bounds" << std::endl;
      return 1;
    }

    // apply patch
    size_t bytes_patched = 0;
    for (size_t i = 0; i < compiled_patch.data.size(); ++i) {
      if (compiled_patch.mask[i]) {
        file_data[address + i] = compiled_patch.data[i];
        bytes_patched++;
      }
    }

    // write output file
    std::ofstream output(output_file, std::ios::binary);
    if (!output.is_open()) {
      log.err("failed to create output file", redlog::field("path", output_file));
      std::cerr << "error: could not create output file: " << output_file << std::endl;
      return 1;
    }

    output.write(reinterpret_cast<const char*>(file_data.data()), file_data.size());
    output.close();

    if (!output) {
      log.err("failed to write output file", redlog::field("path", output_file));
      std::cerr << "error: failed to write output file: " << output_file << std::endl;
      return 1;
    }

    log.inf(
        "patch applied successfully", redlog::field("bytes_patched", bytes_patched), redlog::field("address", address)
    );

    std::cout << "patch applied successfully" << std::endl;
    std::cout << "bytes patched: " << bytes_patched << " at address 0x" << std::hex << address << std::endl;

    return 0;

  } catch (const std::exception& e) {
    log.err("patch failed", redlog::field("error", e.what()));
    std::cerr << "error: " << e.what() << std::endl;
    return 1;
  }
}

} // namespace p1llx::commands
```

`src/p1llx/commands/patch.hpp`:

```hpp
#pragma once

#include <string>

namespace p1llx::commands {

/**
 * @brief Apply manual hex patch to file
 *
 * @param address_str Address to patch (hex string)
 * @param replace_data Replacement hex bytes
 * @param input_file Path to input binary file
 * @param output_file Path to output binary file
 * @return 0 for success, 1 for failure
 */
int patch(
    const std::string& address_str, const std::string& replace_data, const std::string& input_file,
    const std::string& output_file
);

} // namespace p1llx::commands
```

`src/p1llx/commands/poison.cpp`:

```cpp
#include "poison.hpp"

#include <iostream>
#include <filesystem>
#include <cstdlib>

#include <redlog.hpp>
#include "w1nj3ct.hpp"
#include <w1common/platform_utils.hpp>

namespace p1llx::commands {

// shared helper function to find p01s0n library
static std::string find_p01s0n_library(const std::string& executable_path) {
  auto log = redlog::get_logger("p1llx.poison");

  // find p01s0n library using same discovery pattern as tracers
  std::string p01s0n_lib_name = "p01s0n";
  std::string lib_ext = w1::common::platform_utils::get_library_extension();
  std::string p01s0n_filename = p01s0n_lib_name + lib_ext;

  // get executable directory for relative search (same as tracer discovery)
  std::filesystem::path exec_path;
  try {
    if (!executable_path.empty()) {
      exec_path = std::filesystem::canonical(executable_path);
    } else {
      exec_path = std::filesystem::current_path();
    }
  } catch (const std::exception& e) {
    log.dbg(
        "failed to canonicalize executable path, using as-is", redlog::field("path", executable_path),
        redlog::field("error", e.what())
    );
    exec_path = !executable_path.empty() ? std::filesystem::path(executable_path) : std::filesystem::path(".");
  }

  std::filesystem::path exec_dir = exec_path.parent_path();

  log.dbg(
      "searching for p01s0n library", redlog::field("filename", p01s0n_filename),
      redlog::field("exec_dir", exec_path.string())
  );

  // search paths relative to executable directory (same as tracer discovery)
  std::vector<std::filesystem::path> search_dirs = {
      exec_dir,                // same directory as executable
      exec_dir / "lib",        // lib/ subdirectory
      exec_dir / ".." / "lib", // ../lib/ (for installed layouts)
      exec_dir / "..",         // parent directory
  };

  for (const auto& search_dir : search_dirs) {
    if (!std::filesystem::exists(search_dir) || !std::filesystem::is_directory(search_dir)) {
      continue;
    }

    auto candidate_path = search_dir / p01s0n_filename;
    if (std::filesystem::exists(candidate_path)) {
      std::string found_lib_path = std::filesystem::canonical(candidate_path).string();
      log.dbg("found p01s0n library", redlog::field("path", found_lib_path));
      return found_lib_path;
    }
  }

  log.err("p01s0n library not found", redlog::field("filename", p01s0n_filename));
  std::cerr << "error: p01s0n library not found (" << p01s0n_filename << ")" << std::endl;
  std::cerr << "searched directories:" << std::endl;
  for (const auto& dir : search_dirs) {
    std::cerr << "  " << dir.string() << std::endl;
  }
  return "";
}

int poison_spawn(
    const std::string& script_path, const std::string& binary_path, const std::vector<std::string>& binary_args,
    bool suspended, const std::string& executable_path, int verbosity_level
) {

  auto log = redlog::get_logger("p1llx.poison");

  log.inf(
      "starting p01s0n injection", redlog::field("script", script_path), redlog::field("binary", binary_path),
      redlog::field("suspended", suspended ? "true" : "false")
  );

  // validate script file exists
  if (!std::filesystem::exists(script_path)) {
    log.err("cure script file does not exist", redlog::field("path", script_path));
    std::cerr << "error: cure script not found: " << script_path << std::endl;
    return 1;
  }

  // validate binary exists
  if (!std::filesystem::exists(binary_path)) {
    log.err("target binary does not exist", redlog::field("path", binary_path));
    std::cerr << "error: target binary not found: " << binary_path << std::endl;
    return 1;
  }

  // find p01s0n library
  std::string found_lib_path = find_p01s0n_library(executable_path);
  if (found_lib_path.empty()) {
    return 1;
  }

  log.inf("found p01s0n library", redlog::field("path", found_lib_path));

  // convert script path to absolute path for environment variable
  std::string abs_script_path = std::filesystem::absolute(script_path).string();

  // prepare injection configuration
  w1::inject::config cfg;
  cfg.library_path = found_lib_path;
  cfg.injection_method = w1::inject::method::preload; // preload injection
  cfg.binary_path = binary_path;
  cfg.args = binary_args;
  cfg.suspended = suspended;
  cfg.wait_for_completion = true;

  // set P1LL_CURE environment variable for p01s0n
  cfg.env_vars["P1LL_CURE"] = abs_script_path;

  // set POISON_VERBOSE environment variable for p01s0n verbosity
  if (verbosity_level > 0) {
    cfg.env_vars["POISON_VERBOSE"] = std::to_string(verbosity_level);
  }

  log.inf(
      "injection configuration", redlog::field("library", found_lib_path), redlog::field("binary", binary_path),
      redlog::field("args_count", binary_args.size()), redlog::field("cure_script", abs_script_path)
  );

  // check platform support
  const std::string platform = w1::common::platform_utils::get_platform_name();
  if (!w1::common::platform_utils::supports_runtime_injection()) {
    log.warn("runtime injection may not be supported", redlog::field("platform", platform));
  }

  // perform injection
  auto result = w1::inject::inject(cfg);

  if (result.success()) {
    log.inf("p01s0n injection completed successfully", redlog::field("target_pid", result.target_pid));

    std::cout << "p01s0n injection successful" << std::endl;
    if (result.target_pid > 0) {
      std::cout << "target process pid: " << result.target_pid << std::endl;
    }

    return 0;
  } else {
    log.err("p01s0n injection failed", redlog::field("error", result.error_message));
    std::cerr << "error: injection failed: " << result.error_message << std::endl;
    return 1;
  }
}

int poison_pid(
    const std::string& script_path, int target_pid, const std::string& executable_path, int verbosity_level
) {
  auto log = redlog::get_logger("p1llx.poison");

  log.inf(
      "starting p01s0n runtime injection by pid", redlog::field("script", script_path), redlog::field("pid", target_pid)
  );

  // validate script file exists
  if (!std::filesystem::exists(script_path)) {
    log.err("cure script file does not exist", redlog::field("path", script_path));
    std::cerr << "error: cure script not found: " << script_path << std::endl;
    return 1;
  }

  // find p01s0n library
  std::string found_lib_path = find_p01s0n_library(executable_path);
  if (found_lib_path.empty()) {
    return 1;
  }

  log.inf("found p01s0n library", redlog::field("path", found_lib_path));

  // convert script path to absolute path for environment variable
  std::string abs_script_path = std::filesystem::absolute(script_path).string();

  // prepare injection configuration
  w1::inject::config cfg;
  cfg.library_path = found_lib_path;
  cfg.injection_method = w1::inject::method::runtime; // runtime injection
  cfg.pid = target_pid;
  cfg.wait_for_completion = false; // don't wait for runtime injection

  // set P1LL_CURE environment variable for p01s0n
  cfg.env_vars["P1LL_CURE"] = abs_script_path;

  // set POISON_VERBOSE environment variable for p01s0n verbosity
  if (verbosity_level > 0) {
    cfg.env_vars["POISON_VERBOSE"] = std::to_string(verbosity_level);
  }

  log.inf(
      "runtime injection configuration", redlog::field("library", found_lib_path), redlog::field("pid", target_pid),
      redlog::field("cure_script", abs_script_path)
  );

  // check platform support
  const std::string platform = w1::common::platform_utils::get_platform_name();
  if (!w1::common::platform_utils::supports_runtime_injection()) {
    log.warn("runtime injection may not be supported", redlog::field("platform", platform));
  }

  // perform injection
  auto result = w1::inject::inject(cfg);

  if (result.success()) {
    log.inf("p01s0n runtime injection completed successfully", redlog::field("target_pid", result.target_pid));
    std::cout << "p01s0n runtime injection successful" << std::endl;
    if (result.target_pid > 0) {
      std::cout << "target process pid: " << result.target_pid << std::endl;
    }
    return 0;
  } else {
    log.err("p01s0n runtime injection failed", redlog::field("error", result.error_message));
    std::cerr << "error: injection failed: " << result.error_message << std::endl;
    return 1;
  }
}

int poison_process_name(
    const std::string& script_path, const std::string& process_name, const std::string& executable_path,
    int verbosity_level
) {
  auto log = redlog::get_logger("p1llx.poison");

  log.inf(
      "starting p01s0n runtime injection by process name", redlog::field("script", script_path),
      redlog::field("process_name", process_name)
  );

  // validate script file exists
  if (!std::filesystem::exists(script_path)) {
    log.err("cure script file does not exist", redlog::field("path", script_path));
    std::cerr << "error: cure script not found: " << script_path << std::endl;
    return 1;
  }

  // find p01s0n library
  std::string found_lib_path = find_p01s0n_library(executable_path);
  if (found_lib_path.empty()) {
    return 1;
  }

  log.inf("found p01s0n library", redlog::field("path", found_lib_path));

  // convert script path to absolute path for environment variable
  std::string abs_script_path = std::filesystem::absolute(script_path).string();

  // prepare injection configuration
  w1::inject::config cfg;
  cfg.library_path = found_lib_path;
  cfg.injection_method = w1::inject::method::runtime; // runtime injection
  cfg.process_name = process_name;
  cfg.wait_for_completion = false; // don't wait for runtime injection

  // set P1LL_CURE environment variable for p01s0n
  cfg.env_vars["P1LL_CURE"] = abs_script_path;

  // set POISON_VERBOSE environment variable for p01s0n verbosity
  if (verbosity_level > 0) {
    cfg.env_vars["POISON_VERBOSE"] = std::to_string(verbosity_level);
  }

  log.inf(
      "runtime injection configuration", redlog::field("library", found_lib_path),
      redlog::field("process_name", process_name), redlog::field("cure_script", abs_script_path)
  );

  // check platform support
  const std::string platform = w1::common::platform_utils::get_platform_name();
  if (!w1::common::platform_utils::supports_runtime_injection()) {
    log.warn("runtime injection may not be supported", redlog::field("platform", platform));
  }

  // perform injection
  auto result = w1::inject::inject(cfg);

  if (result.success()) {
    log.inf("p01s0n runtime injection completed successfully", redlog::field("target_pid", result.target_pid));
    std::cout << "p01s0n runtime injection successful" << std::endl;
    if (result.target_pid > 0) {
      std::cout << "target process pid: " << result.target_pid << std::endl;
    }
    return 0;
  } else {
    log.err("p01s0n runtime injection failed", redlog::field("error", result.error_message));
    std::cerr << "error: injection failed: " << result.error_message << std::endl;
    return 1;
  }
}

} // namespace p1llx::commands
```

`src/p1llx/commands/poison.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>

namespace p1llx::commands {

/**
 * @brief Inject p01s0n library into target process for dynamic patching (spawn method)
 *
 * Uses preload injection to load p01s0n.so/dylib/dll into the target process.
 * The P1LL_CURE environment variable specifies which cure script to apply.
 *
 * @param script_path Path to lua cure script (sets P1LL_CURE env var)
 * @param binary_path Path to target binary to launch and inject
 * @param binary_args Arguments to pass to target binary
 * @param suspended Whether to start target in suspended mode
 * @param executable_path Path to p1llx executable for library discovery
 * @param verbosity_level Verbosity level to pass to p01s0n (0-3)
 * @return 0 for success, 1 for failure
 */
int poison_spawn(
    const std::string& script_path, const std::string& binary_path, const std::vector<std::string>& binary_args = {},
    bool suspended = false, const std::string& executable_path = "", int verbosity_level = 0
);

/**
 * @brief Inject p01s0n library into existing process by PID (runtime method)
 *
 * Uses runtime injection to load p01s0n.so/dylib/dll into an existing process.
 * The P1LL_CURE environment variable specifies which cure script to apply.
 *
 * @param script_path Path to lua cure script (sets P1LL_CURE env var)
 * @param target_pid Process ID of target process
 * @param executable_path Path to p1llx executable for library discovery
 * @param verbosity_level Verbosity level to pass to p01s0n (0-3)
 * @return 0 for success, 1 for failure
 */
int poison_pid(
    const std::string& script_path, int target_pid, const std::string& executable_path = "", int verbosity_level = 0
);

/**
 * @brief Inject p01s0n library into existing process by name (runtime method)
 *
 * Uses runtime injection to load p01s0n.so/dylib/dll into an existing process.
 * The P1LL_CURE environment variable specifies which cure script to apply.
 *
 * @param script_path Path to lua cure script (sets P1LL_CURE env var)
 * @param process_name Name of target process
 * @param executable_path Path to p1llx executable for library discovery
 * @param verbosity_level Verbosity level to pass to p01s0n (0-3)
 * @return 0 for success, 1 for failure
 */
int poison_process_name(
    const std::string& script_path, const std::string& process_name, const std::string& executable_path = "",
    int verbosity_level = 0
);

} // namespace p1llx::commands
```

`src/p1llx/main.cpp`:

```cpp
#include "commands/cure.hpp"
#include "commands/patch.hpp"
#include "commands/poison.hpp"
#include <w1common/ext/args.hpp>
#include <redlog.hpp>
#include <string>

// global executable path for library discovery (like w1tool)
namespace {
std::string g_executable_path;
}

// following w1tool patterns exactly
namespace cli {
args::Group arguments("arguments");
args::HelpFlag help_flag(arguments, "help", "help", {'h', "help"});
args::CounterFlag verbosity_flag(arguments, "verbosity", "verbosity level", {'v'});

void apply_verbosity() {
  auto verbosity_count = args::get(verbosity_flag);

  // map verbosity levels like w1tool: info → verbose → trace → debug → pedantic
  redlog::level log_level = redlog::level::info; // default

  switch (verbosity_count) {
  case 0:
    log_level = redlog::level::info;
    break; // default
  case 1:
    log_level = redlog::level::info;
    break; // -v: verbose
  case 2:
    log_level = redlog::level::debug;
    break; // -vv: trace
  case 3:
    log_level = redlog::level::debug;
    break; // -vvv: debug
  default:
    log_level = redlog::level::debug;
    break; // -vvvv+: pedantic
  }

  redlog::set_level(log_level);
}
} // namespace cli

// command functions following w1tool pattern
int cmd_cure(
    args::ValueFlag<std::string>& script_flag, args::ValueFlag<std::string>& input_flag,
    args::ValueFlag<std::string>& output_flag, args::ValueFlag<std::string>& platform_flag
) {
  auto log = redlog::get_logger("p1llx.cure");
  cli::apply_verbosity();

  // validate required arguments
  if (!script_flag) {
    log.err("cure script required");
    std::cerr << "error: cure script (-c/--cure) is required" << std::endl;
    return 1;
  }

  if (!input_flag) {
    log.err("input file required");
    std::cerr << "error: input file (-i/--input) is required" << std::endl;
    return 1;
  }

  // default output to input if not specified
  std::string output_file = output_flag ? *output_flag : *input_flag;

  // get platform override if specified
  std::string platform_override = platform_flag ? *platform_flag : "";

  return p1llx::commands::cure(*script_flag, *input_flag, output_file, platform_override);
}

int cmd_patch(
    args::ValueFlag<std::string>& address_flag, args::ValueFlag<std::string>& replace_flag,
    args::ValueFlag<std::string>& input_flag, args::ValueFlag<std::string>& output_flag
) {
  auto log = redlog::get_logger("p1llx.patch");
  cli::apply_verbosity();

  // validate required arguments
  if (!address_flag || !replace_flag || !input_flag) {
    log.err("address, replace data, and input file required");
    std::cerr << "error: address (--address), replace data (--replace), and input file (-i/--input) are required"
              << std::endl;
    return 1;
  }

  // default output to input if not specified
  std::string output_file = output_flag ? *output_flag : *input_flag;

  return p1llx::commands::patch(*address_flag, *replace_flag, *input_flag, output_file);
}

int cmd_poison(
    args::ValueFlag<std::string>& script_flag, args::Flag& spawn_flag, args::ValueFlag<int>& pid_flag,
    args::ValueFlag<std::string>& process_name_flag, args::Flag& suspended_flag,
    args::PositionalList<std::string>& args_list
) {
  auto log = redlog::get_logger("p1llx.poison");
  cli::apply_verbosity();

  // validate required arguments
  if (!script_flag) {
    log.err("cure script required");
    std::cerr << "error: cure script (-c/--cure) is required" << std::endl;
    return 1;
  }

  // validate target specification
  int target_count = 0;
  if (spawn_flag) {
    target_count++;
  }
  if (pid_flag) {
    target_count++;
  }
  if (process_name_flag) {
    target_count++;
  }

  if (target_count != 1) {
    log.err("exactly one target required: specify -s/--spawn, --pid, or --process-name");
    std::cerr << "error: exactly one target required: specify -s/--spawn, --pid, or --process-name" << std::endl;
    return 1;
  }

  // validate suspended flag usage
  if (suspended_flag && !spawn_flag) {
    log.err("--suspended can only be used with -s/--spawn");
    std::cerr << "error: --suspended can only be used with -s/--spawn" << std::endl;
    return 1;
  }

  int verbosity_level = args::get(cli::verbosity_flag);

  // determine target method and call appropriate poison function
  if (spawn_flag) {
    // spawn injection with positional arguments
    if (args_list.Get().empty()) {
      log.err("binary path required when using -s/--spawn flag");
      std::cerr << "error: binary path required when using -s/--spawn flag" << std::endl;
      return 1;
    }

    std::vector<std::string> all_args = args::get(args_list);
    std::string binary_path = all_args[0];

    // extract arguments after the binary (everything after first arg)
    std::vector<std::string> binary_args;
    if (all_args.size() > 1) {
      binary_args.assign(all_args.begin() + 1, all_args.end());
    }

    return p1llx::commands::poison_spawn(
        *script_flag, binary_path, binary_args, suspended_flag, g_executable_path, verbosity_level
    );

  } else if (pid_flag) {
    // runtime injection by pid
    return p1llx::commands::poison_pid(*script_flag, args::get(pid_flag), g_executable_path, verbosity_level);

  } else if (process_name_flag) {
    // runtime injection by process name
    return p1llx::commands::poison_process_name(
        *script_flag, args::get(process_name_flag), g_executable_path, verbosity_level
    );

  } else {
    log.err("target required: specify -s/--spawn, --pid, or --process-name");
    std::cerr << "error: target required: specify -s/--spawn, --pid, or --process-name" << std::endl;
    return 1;
  }
}

int main(int argc, char* argv[]) {
  // store executable path for library auto-discovery (like w1tool)
  g_executable_path = argv[0];

  // argument parser following w1tool style
  args::ArgumentParser parser("p1llx - static binary patcher");
  parser.helpParams.showTerminator = false;

  // global flags
  parser.Add(cli::arguments);

  // cure command
  args::Command cure_cmd(parser, "cure", "apply auto-cure lua script to file");
  args::ValueFlag<std::string> cure_script_flag(cure_cmd, "script", "lua cure script path", {'c', "cure"});
  args::ValueFlag<std::string> cure_input_flag(cure_cmd, "input", "input file path", {'i', "input"});
  args::ValueFlag<std::string> cure_output_flag(
      cure_cmd, "output", "output file path (default: overwrite input)", {'o', "output"}
  );
  args::ValueFlag<std::string> cure_platform_flag(
      cure_cmd, "platform", "platform override (e.g., linux:x64, darwin:arm64)", {'p', "platform"}
  );

  // patch command
  args::Command patch_cmd(parser, "patch", "manual hex patching");
  args::ValueFlag<std::string> patch_address_flag(patch_cmd, "address", "address to patch (hex)", {"address"});
  args::ValueFlag<std::string> patch_replace_flag(patch_cmd, "replace", "replacement hex bytes", {"replace"});
  args::ValueFlag<std::string> patch_input_flag(patch_cmd, "input", "input file path", {'i', "input"});
  args::ValueFlag<std::string> patch_output_flag(
      patch_cmd, "output", "output file path (default: overwrite input)", {'o', "output"}
  );

  // poison command
  args::Command poison_cmd(parser, "poison", "inject p01s0n for dynamic patching");
  args::ValueFlag<std::string> poison_script_flag(poison_cmd, "script", "lua cure script path", {'c', "cure"});
  args::Flag poison_spawn_flag(poison_cmd, "spawn", "spawn target binary with p01s0n injection", {'s', "spawn"});
  args::ValueFlag<int> poison_pid_flag(poison_cmd, "pid", "inject into existing process by pid", {'p', "pid"});
  args::ValueFlag<std::string> poison_process_name_flag(
      poison_cmd, "process-name", "inject into existing process by name", {'n', "process-name"}
  );
  args::Flag poison_suspended_flag(poison_cmd, "suspended", "start target in suspended mode", {"suspended"});
  args::PositionalList<std::string> poison_args_list(
      poison_cmd, "args", "target binary and arguments (use -- to separate)"
  );

  try {
    parser.ParseCLI(argc, argv);

    if (cure_cmd) {
      return cmd_cure(cure_script_flag, cure_input_flag, cure_output_flag, cure_platform_flag);
    } else if (patch_cmd) {
      return cmd_patch(patch_address_flag, patch_replace_flag, patch_input_flag, patch_output_flag);
    } else if (poison_cmd) {
      return cmd_poison(
          poison_script_flag, poison_spawn_flag, poison_pid_flag, poison_process_name_flag, poison_suspended_flag,
          poison_args_list
      );
    } else {
      std::cerr << "error: no command specified" << std::endl;
      std::cerr << parser;
      return 1;
    }

  } catch (const args::Help&) {
    std::cout << parser;
    return 0;
  } catch (const args::ParseError& e) {
    std::cerr << e.what() << std::endl;
    std::cerr << parser;
    return 1;
  } catch (const args::ValidationError& e) {
    std::cerr << e.what() << std::endl;
    std::cerr << parser;
    return 1;
  }

  return 0;
}
```

`src/tracers/CMakeLists.txt`:

```txt
# Tracers - w1tn3ss Framework Tracers
cmake_minimum_required(VERSION 3.16)

# Add tracer subdirectories
add_subdirectory(w1cov)
add_subdirectory(w1mem)
add_subdirectory(w1trace)
add_subdirectory(w1inst)
add_subdirectory(w1xfer)
add_subdirectory(mintrace)
add_subdirectory(w1script)
add_subdirectory(hooktest)
```

`src/tracers/hooktest/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${WITNESS_SOURCE_DIR}/cmake/TracerConfig.cmake)

create_tracer_targets(hooktest "preload.cpp")
```

`src/tracers/hooktest/preload.cpp`:

```cpp
#include <cstdlib>
#include <cstring>
#include <memory>
#include <iomanip>
#include <sstream>

#include "QBDIPreload.h"
#include <redlog.hpp>

#include <w1tn3ss/engine/tracer_engine.hpp>
#include <w1tn3ss/hooking/hook_manager.hpp>
#include <w1tn3ss/util/env_config.hpp>
#include <w1tn3ss/util/module_range_index.hpp>
#include <w1tn3ss/util/module_scanner.hpp>
#include <w1tn3ss/util/signal_handler.hpp>
#include <w1tn3ss/util/stderr_write.hpp>
#include <w1tn3ss/util/safe_memory.hpp>
#include <w1tn3ss/abi/calling_convention_factory.hpp>

#if defined(_WIN32) || defined(WIN32)
#include <w1common/windows_console.hpp>
#endif

class hooktest_tracer {
public:
  explicit hooktest_tracer(bool use_abi = false) : use_abi_(use_abi) {
    log_.inf("hooktest tracer created", redlog::field("use_abi", use_abi_));
  }

  bool initialize(w1::tracer_engine<hooktest_tracer>& engine) {
    log_.inf("initializing hooktest tracer");
    log_.inf("argument extraction mode", redlog::field("use_abi", use_abi_ ? "calling convention" : "direct register"));

    // scan and index modules
    log_.inf("scanning modules");
    auto modules = scanner_.scan_executable_modules();
    index_.rebuild_from_modules(std::move(modules));

    log_.inf("module scan complete", redlog::field("modules", index_.size()));

    // create hook manager
    hook_manager_ = std::make_unique<w1::hooking::hook_manager>(engine.get_vm());

    // find our test target
    const w1::util::module_info* target_module = nullptr;
    index_.visit_all([&](const w1::util::module_info& mod) {
      if (mod.path.find("hook_test_target") != std::string::npos) {
        target_module = &mod;
      }
    });

    if (!target_module) {
      log_.err("could not find hook_test_target module");
      return false;
    }

    log_.inf(
        "found target module", redlog::field("base", "0x%lx", target_module->base_address),
        redlog::field("size", "0x%lx", target_module->size)
    );

    // hook the functions by offset
    setup_hooks(target_module->base_address);

    return true;
  }

  void shutdown() {
    log_.inf("shutting down hooktest tracer");
    if (hook_manager_) {
      hook_manager_->remove_all_hooks();
    }
  }

  const char* get_name() const { return "hooktest"; }

private:
  void setup_hooks(QBDI::rword base_addr) {
    // known offsets from nm output
    struct hook_target {
      const char* name;
      QBDI::rword offset;
    };

    hook_target targets[] = {
        {"calculate_secret", 0x840},
        {"format_message", 0x88c},
        {"allocate_buffer", 0x8e4},
        {"compare_strings", 0x940},
        {"unsafe_copy", 0x98c}
    };

    // hook each function by address
    for (const auto& target : targets) {
      QBDI::rword addr = base_addr + target.offset;

      std::string func_name = target.name;
      auto hook_id = hook_manager_->hook_addr(
          addr,
          [this, func_name](QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr, QBDI::rword address) {
            return on_function_hook(vm, gpr, fpr, address, func_name.c_str());
          }
      );

      if (hook_id > 0) {
        log_.inf(
            "hooked function", redlog::field("name", target.name), redlog::field("address", "0x%lx", addr),
            redlog::field("hook_id", hook_id)
        );
      } else {
        log_.err(
            "failed to hook function", redlog::field("name", target.name), redlog::field("address", "0x%lx", addr)
        );
      }
    }

    // demonstrate module+offset hooking
    auto module_hook_id = hook_manager_->hook_module(
        "hook_test_target", 0x840,
        [this](QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr, QBDI::rword address) {
          log_.dbg("module+offset hook triggered", redlog::field("address", "0x%lx", address));
          return QBDI::VMAction::CONTINUE;
        }
    );

    if (module_hook_id > 0) {
      log_.inf(
          "hooked via module+offset", redlog::field("module", "hook_test_target"), redlog::field("offset", "0x840"),
          redlog::field("hook_id", module_hook_id)
      );
    }

    // demonstrate range hooking
    QBDI::rword text_start = base_addr;
    QBDI::rword text_end = base_addr + 0x1000; // first 4kb

    auto range_hook_id = hook_manager_->hook_range(
        text_start, text_end,
        [this, text_start](QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr, QBDI::rword address) {
          // only log every 100th instruction to avoid spam
          static int count = 0;
          if (++count % 100 == 0) {
            log_.dbg(
                "range hook", redlog::field("address", "0x%lx", address),
                redlog::field("offset", "0x%lx", address - text_start), redlog::field("count", count)
            );
          }
          return QBDI::VMAction::CONTINUE;
        }
    );

    if (range_hook_id > 0) {
      log_.inf(
          "hooked range", redlog::field("start", "0x%lx", text_start), redlog::field("end", "0x%lx", text_end),
          redlog::field("hook_id", range_hook_id)
      );

      // store for later removal demo
      range_hook_id_ = range_hook_id;
    }
  }

  QBDI::VMAction on_function_hook(
      QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr, QBDI::rword address, const char* func_name
  ) {
    // get calling convention
    auto cc = w1::abi::create_default_calling_convention();
    // log the function call
    log_.inf("hook triggered", redlog::field("function", func_name), redlog::field("address", "0x%lx", address));

    // get instruction analysis
    try {
      const QBDI::InstAnalysis* inst = vm->getInstAnalysis();
      if (inst) {
        log_.dbg(
            "instruction info", redlog::field("disasm", inst->disassembly), redlog::field("mnemonic", inst->mnemonic),
            redlog::field("size", inst->instSize)
        );
      }
    } catch (...) {
      log_.dbg("exception getting instruction analysis");
    }

    // extract arguments using configured method
    if (use_abi_ && cc) {
      // use calling convention api
      w1::abi::calling_convention_base::extraction_context ctx;
      ctx.gpr = gpr;
      ctx.fpr = fpr;
      ctx.read_stack = [vm](uint64_t addr) -> uint64_t {
        uint64_t value = 0;
        // note: proper memory reading would need vm->readMemory() but simplified here
        // in real use, hook manager has the vm instance
        return value;
      };

      // extract first 4 arguments
      auto args = cc->extract_integer_args(ctx, 4);

      log_.inf(
          "arguments (calling convention)", redlog::field("platform", cc->get_name().c_str()),
          redlog::field("arg1", "0x%lx", args.size() > 0 ? args[0] : 0),
          redlog::field("arg2", "0x%lx", args.size() > 1 ? args[1] : 0),
          redlog::field("arg3", "0x%lx", args.size() > 2 ? args[2] : 0),
          redlog::field("arg4", "0x%lx", args.size() > 3 ? args[3] : 0)
      );

      // log calling convention details once
      if (!cc_logged_) {
        log_.inf(
            "calling convention details", redlog::field("name", cc->get_name().c_str()),
            redlog::field("stack_alignment", cc->get_stack_alignment()),
            redlog::field("red_zone_size", cc->get_red_zone_size())
        );
        cc_logged_ = true;
      }
    } else {
      // use direct register access
#if defined(__aarch64__)
      log_.inf(
          "arguments (direct arm64)", redlog::field("x0", "0x%lx", gpr->x0), redlog::field("x1", "0x%lx", gpr->x1),
          redlog::field("x2", "0x%lx", gpr->x2), redlog::field("x3", "0x%lx", gpr->x3)
      );
#elif defined(__x86_64__)
#if defined(_WIN32)
      log_.inf(
          "arguments (direct x64 windows)", redlog::field("rcx", "0x%lx", gpr->rcx),
          redlog::field("rdx", "0x%lx", gpr->rdx), redlog::field("r8", "0x%lx", gpr->r8),
          redlog::field("r9", "0x%lx", gpr->r9)
      );
#else
      log_.inf(
          "arguments (direct x64 sysv)", redlog::field("rdi", "0x%lx", gpr->rdi),
          redlog::field("rsi", "0x%lx", gpr->rsi), redlog::field("rdx", "0x%lx", gpr->rdx),
          redlog::field("rcx", "0x%lx", gpr->rcx)
      );
#endif
#endif
    }

    // print stack pointer and program counter
    QBDI::rword sp = QBDI_GPR_GET(gpr, QBDI::REG_SP);
    QBDI::rword pc = QBDI_GPR_GET(gpr, QBDI::REG_PC);
    log_.dbg("context", redlog::field("sp", "0x%lx", sp), redlog::field("pc", "0x%lx", pc));

    // demonstrate hook removal after a few calls
    hook_count_++;
    if (hook_count_ == 10 && range_hook_id_ > 0) {
      log_.inf("removing range hook after 10 function calls");
      if (hook_manager_->remove_hook(range_hook_id_)) {
        log_.inf("range hook removed successfully");
        range_hook_id_ = 0;
      }
    }

    // special handling for specific functions
    if (strcmp(func_name, "calculate_secret") == 0) {
      if (use_abi_ && cc) {
        // extract arguments using calling convention
        w1::abi::calling_convention_base::extraction_context ctx;
        ctx.gpr = gpr;
        ctx.fpr = fpr;
        ctx.read_stack = [vm](uint64_t addr) -> uint64_t {
          uint64_t value = 0;
          // note: proper memory reading would need vm->readMemory() but simplified here
          return value;
        };

        auto args = cc->extract_integer_args(ctx, 2);
        if (args.size() >= 2) {
          int a = static_cast<int>(args[0]);
          int b = static_cast<int>(args[1]);
          log_.inf(
              "calculate_secret params (abi)", redlog::field("a", a), redlog::field("b", b),
              redlog::field("expected_result", 3 * a + 2 * b)
          );
        }
      } else {
        // direct register access
        int a = 0;
        int b = 0;
#if defined(__aarch64__)
        a = static_cast<int>(gpr->x0);
        b = static_cast<int>(gpr->x1);
#elif defined(__x86_64__) && defined(_WIN32)
        a = static_cast<int>(gpr->rcx);
        b = static_cast<int>(gpr->rdx);
#elif defined(__x86_64__)
        a = static_cast<int>(gpr->rdi);
        b = static_cast<int>(gpr->rsi);
#endif
        log_.inf(
            "calculate_secret params (direct)", redlog::field("a", a), redlog::field("b", b),
            redlog::field("expected_result", 3 * a + 2 * b)
        );
      }
    } else if (strcmp(func_name, "format_message") == 0) {
      if (use_abi_ && cc) {
        // extract arguments using calling convention
        w1::abi::calling_convention_base::extraction_context ctx;
        ctx.gpr = gpr;
        ctx.fpr = fpr;
        ctx.read_stack = [vm](uint64_t addr) -> uint64_t {
          uint64_t value = 0;
          // note: proper memory reading would need vm->readMemory() but simplified here
          return value;
        };

        auto args = cc->extract_integer_args(ctx, 3);
        if (args.size() >= 3) {
          QBDI::rword buffer_ptr = args[0];
          QBDI::rword name_ptr = args[1];
          int value = static_cast<int>(args[2]);

          auto name_str = w1::util::safe_memory::read_string(vm, name_ptr, 256);
          log_.inf(
              "format_message params (abi)", redlog::field("buffer", "0x%lx", buffer_ptr),
              redlog::field("name_ptr", "0x%lx", name_ptr),
              redlog::field("name", name_str ? name_str->c_str() : "<read failed>"), redlog::field("value", value)
          );
        }
      } else {
        // direct register access
        QBDI::rword buffer_ptr = 0;
        QBDI::rword name_ptr = 0;
        int value = 0;
#if defined(__aarch64__)
        buffer_ptr = gpr->x0;
        name_ptr = gpr->x1;
        value = static_cast<int>(gpr->x2);
#elif defined(__x86_64__) && defined(_WIN32)
        buffer_ptr = gpr->rcx;
        name_ptr = gpr->rdx;
        value = static_cast<int>(gpr->r8);
#elif defined(__x86_64__)
        buffer_ptr = gpr->rdi;
        name_ptr = gpr->rsi;
        value = static_cast<int>(gpr->rdx);
#endif
        auto name_str = w1::util::safe_memory::read_string(vm, name_ptr, 256);
        log_.inf(
            "format_message params (direct)", redlog::field("buffer", "0x%lx", buffer_ptr),
            redlog::field("name_ptr", "0x%lx", name_ptr),
            redlog::field("name", name_str ? name_str->c_str() : "<read failed>"), redlog::field("value", value)
        );
      }
    } else if (strcmp(func_name, "allocate_buffer") == 0) {
      if (use_abi_ && cc) {
        w1::abi::calling_convention_base::extraction_context ctx;
        ctx.gpr = gpr;
        ctx.fpr = fpr;
        ctx.read_stack = [vm](uint64_t addr) -> uint64_t {
          uint64_t value = 0;
          // note: proper memory reading would need vm->readMemory() but simplified here
          return value;
        };

        auto args = cc->extract_integer_args(ctx, 1);
        if (!args.empty()) {
          size_t size = static_cast<size_t>(args[0]);
          log_.inf("allocate_buffer params (abi)", redlog::field("size", size));
        }
      } else {
        size_t size = 0;
#if defined(__aarch64__)
        size = static_cast<size_t>(gpr->x0);
#elif defined(__x86_64__) && defined(_WIN32)
        size = static_cast<size_t>(gpr->rcx);
#elif defined(__x86_64__)
        size = static_cast<size_t>(gpr->rdi);
#endif
        log_.inf("allocate_buffer params (direct)", redlog::field("size", size));
      }
    } else if (strcmp(func_name, "compare_strings") == 0) {
      if (use_abi_ && cc) {
        w1::abi::calling_convention_base::extraction_context ctx;
        ctx.gpr = gpr;
        ctx.fpr = fpr;
        ctx.read_stack = [vm](uint64_t addr) -> uint64_t {
          uint64_t value = 0;
          // note: proper memory reading would need vm->readMemory() but simplified here
          return value;
        };

        auto args = cc->extract_integer_args(ctx, 2);
        if (args.size() >= 2) {
          QBDI::rword str1_ptr = args[0];
          QBDI::rword str2_ptr = args[1];

          auto str1 = w1::util::safe_memory::read_string(vm, str1_ptr, 256);
          auto str2 = w1::util::safe_memory::read_string(vm, str2_ptr, 256);

          log_.inf(
              "compare_strings params (abi)", redlog::field("str1_ptr", "0x%lx", str1_ptr),
              redlog::field("str1", str1 ? str1->c_str() : "<read failed>"),
              redlog::field("str2_ptr", "0x%lx", str2_ptr),
              redlog::field("str2", str2 ? str2->c_str() : "<read failed>")
          );
        }
      } else {
        QBDI::rword str1_ptr = 0;
        QBDI::rword str2_ptr = 0;
#if defined(__aarch64__)
        str1_ptr = gpr->x0;
        str2_ptr = gpr->x1;
#elif defined(__x86_64__) && defined(_WIN32)
        str1_ptr = gpr->rcx;
        str2_ptr = gpr->rdx;
#elif defined(__x86_64__)
        str1_ptr = gpr->rdi;
        str2_ptr = gpr->rsi;
#endif
        auto str1 = w1::util::safe_memory::read_string(vm, str1_ptr, 256);
        auto str2 = w1::util::safe_memory::read_string(vm, str2_ptr, 256);

        log_.inf(
            "compare_strings params (direct)", redlog::field("str1_ptr", "0x%lx", str1_ptr),
            redlog::field("str1", str1 ? str1->c_str() : "<read failed>"), redlog::field("str2_ptr", "0x%lx", str2_ptr),
            redlog::field("str2", str2 ? str2->c_str() : "<read failed>")
        );
      }
    } else if (strcmp(func_name, "unsafe_copy") == 0) {
      if (use_abi_ && cc) {
        w1::abi::calling_convention_base::extraction_context ctx;
        ctx.gpr = gpr;
        ctx.fpr = fpr;
        ctx.read_stack = [vm](uint64_t addr) -> uint64_t {
          uint64_t value = 0;
          // note: proper memory reading would need vm->readMemory() but simplified here
          return value;
        };

        auto args = cc->extract_integer_args(ctx, 2);
        if (args.size() >= 2) {
          QBDI::rword dst_ptr = args[0];
          QBDI::rword src_ptr = args[1];

          auto src_str = w1::util::safe_memory::read_string(vm, src_ptr, 256);
          log_.wrn(
              "unsafe_copy detected - security risk (abi)", redlog::field("dst", "0x%lx", dst_ptr),
              redlog::field("src_ptr", "0x%lx", src_ptr),
              redlog::field("src_content", src_str ? src_str->c_str() : "<read failed>")
          );
        }
      } else {
        QBDI::rword dst_ptr = 0;
        QBDI::rword src_ptr = 0;
#if defined(__aarch64__)
        dst_ptr = gpr->x0;
        src_ptr = gpr->x1;
#elif defined(__x86_64__) && defined(_WIN32)
        dst_ptr = gpr->rcx;
        src_ptr = gpr->rdx;
#elif defined(__x86_64__)
        dst_ptr = gpr->rdi;
        src_ptr = gpr->rsi;
#endif
        auto src_str = w1::util::safe_memory::read_string(vm, src_ptr, 256);
        log_.wrn(
            "unsafe_copy detected - security risk (direct)", redlog::field("dst", "0x%lx", dst_ptr),
            redlog::field("src_ptr", "0x%lx", src_ptr),
            redlog::field("src_content", src_str ? src_str->c_str() : "<read failed>")
        );
      }
    }

    return QBDI::VMAction::CONTINUE;
  }

private:
  redlog::logger log_ = redlog::get_logger("hooktest.tracer");
  w1::util::module_scanner scanner_;
  w1::util::module_range_index index_;
  std::unique_ptr<w1::hooking::hook_manager> hook_manager_;
  uint32_t range_hook_id_ = 0;
  int hook_count_ = 0;
  bool use_abi_ = false;
  bool cc_logged_ = false;
};

// globals
static std::unique_ptr<hooktest_tracer> g_tracer;
static std::unique_ptr<w1::tracer_engine<hooktest_tracer>> g_engine;

namespace {

void shutdown_tracer() {
  if (!g_tracer) {
    return;
  }

  try {
    g_tracer->shutdown();
  } catch (...) {
    const char* error_msg = "hooktest: tracer shutdown failed\n";
    w1::util::stderr_write(error_msg);
  }
}

} // anonymous namespace

extern "C" {

QBDIPRELOAD_INIT;

QBDI_EXPORT int qbdipreload_on_run(QBDI::VMInstanceRef vm, QBDI::rword start, QBDI::rword stop) {
  auto log = redlog::get_logger("hooktest.preload");

  log.inf("qbdipreload_on_run called");

  // get config
  w1::util::env_config config_loader("HOOKTEST_");
  int verbose = config_loader.get<int>("VERBOSE", 0);
  bool use_abi = config_loader.get<bool>("USE_ABI", false);

  log.inf("hooktest configuration", redlog::field("verbose", verbose), redlog::field("use_abi", use_abi));

  // set log level based on verbosity
  if (verbose >= 4) {
    redlog::set_level(redlog::level::pedantic);
  } else if (verbose >= 3) {
    redlog::set_level(redlog::level::debug);
  } else if (verbose >= 2) {
    redlog::set_level(redlog::level::trace);
  } else if (verbose >= 1) {
    redlog::set_level(redlog::level::verbose);
  } else {
    redlog::set_level(redlog::level::info);
  }

  // initialize signal handling for emergency shutdown
  w1::tn3ss::signal_handler::config sig_config;
  sig_config.context_name = "hooktest";
  sig_config.log_signals = verbose;

  if (w1::tn3ss::signal_handler::initialize(sig_config)) {
    w1::tn3ss::signal_handler::register_cleanup(
        shutdown_tracer,
        200, // high priority
        "hooktest_shutdown"
    );
    log.inf("signal handling initialized for tracer shutdown");
  } else {
    log.wrn("failed to initialize signal handling - shutdown on signal unavailable");
  }

  // create tracer
  log.inf("creating hooktest tracer");
  g_tracer = std::make_unique<hooktest_tracer>(use_abi);

  // create engine
  log.inf("creating tracer engine");
  g_engine = std::make_unique<w1::tracer_engine<hooktest_tracer>>(vm, *g_tracer);

  // initialize tracer
  g_tracer->initialize(*g_engine);

  // instrument
  log.inf("instrumenting engine");
  if (!g_engine->instrument()) {
    log.error("engine instrumentation failed");
    return QBDIPRELOAD_ERR_STARTUP_FAILED;
  }

  log.inf("engine instrumentation successful");

  // run engine
  log.inf("running engine", redlog::field("start", "0x%08x", start), redlog::field("stop", "0x%08x", stop));
  if (!g_engine->run(start, stop)) {
    log.error("engine run failed");
    return QBDIPRELOAD_ERR_STARTUP_FAILED;
  }

  // execution doesn't reach here if it works (vm run jumps)
  log.inf("qbdipreload_on_run completed");

  return QBDIPRELOAD_NO_ERROR;
}

QBDI_EXPORT int qbdipreload_on_exit(int status) { return QBDIPRELOAD_NO_ERROR; }

QBDI_EXPORT int qbdipreload_on_start(void* main) {
#if defined(_WIN32) || defined(WIN32)
  // on windows, allow logging to show for gui targets
  w1::common::allocate_windows_console();
#endif
  return QBDIPRELOAD_NOT_HANDLED;
}

QBDI_EXPORT int qbdipreload_on_premain(void* gprCtx, void* fpuCtx) { return QBDIPRELOAD_NOT_HANDLED; }

QBDI_EXPORT int qbdipreload_on_main(int argc, char** argv) { return QBDIPRELOAD_NOT_HANDLED; }

} // extern "C"
```

`src/tracers/mintrace/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${WITNESS_SOURCE_DIR}/cmake/TracerConfig.cmake)

create_tracer_targets(mintrace "preload.cpp")
```

`src/tracers/mintrace/preload.cpp`:

```cpp
#include <cstdlib>
#include <cstring>
#include <memory>

#include "QBDIPreload.h"
#include <redlog.hpp>

#include <w1tn3ss/engine/tracer_engine.hpp>
#include <w1tn3ss/util/env_config.hpp>
#include <w1tn3ss/util/module_range_index.hpp>
#include <w1tn3ss/util/module_scanner.hpp>
#include <w1tn3ss/util/signal_handler.hpp>
#include <w1tn3ss/util/stderr_write.hpp>

#if defined(_WIN32) || defined(WIN32)
#include <w1common/windows_console.hpp>
#endif

class mintrace_tracer {
public:
  explicit mintrace_tracer() { log_.inf("tracer created"); }

  bool initialize(w1::tracer_engine<mintrace_tracer>& engine) {
    log_.inf("initialize called");

    // scan and index modules
    log_.inf("scanning modules");
    auto modules = scanner_.scan_executable_modules();
    index_.rebuild_from_modules(std::move(modules));

    log_.inf("module indexing complete", redlog::field("modules", index_.size()));

    return true;
  }

  void shutdown() { log_.inf("shutdown called"); }

  const char* get_name() const { return "mintrace"; }

  QBDI::VMAction on_instruction_preinst(QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr) {
    const QBDI::InstAnalysis* analysis = vm->getInstAnalysis();

    if (analysis) {
      log_.trc(
          "instruction", redlog::field("address", "0x%08x", analysis->address),
          redlog::field("disassembly", analysis->disassembly)
      );
    } else {
      log_.error("instruction analysis failed");
    }

    return QBDI::VMAction::CONTINUE;
  }

  QBDI::VMAction on_basic_block_entry(
      QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr
  ) {
    QBDI::rword block_start = state->basicBlockStart;
    QBDI::rword block_size = state->basicBlockEnd - state->basicBlockStart;

    log_.trc("basic block entry", redlog::field("start", "0x%08x", block_start), redlog::field("size", block_size));

    return QBDI::VMAction::CONTINUE;
  }

private:
  redlog::logger log_ = redlog::get_logger("mintrace.tracer");
  w1::util::module_scanner scanner_;
  w1::util::module_range_index index_;
};

// globals
static std::unique_ptr<mintrace_tracer> g_tracer;
static std::unique_ptr<w1::tracer_engine<mintrace_tracer>> g_engine;

namespace {

/**
 * @brief shutdown tracer with signal-safe error handling
 */
void shutdown_tracer() {
  if (!g_tracer) {
    return;
  }

  try {
    g_tracer->shutdown();
  } catch (...) {
    const char* error_msg = "mintrace: tracer shutdown failed\n";
    w1::util::stderr_write(error_msg);
  }
}

} // anonymous namespace

extern "C" {

QBDIPRELOAD_INIT;

QBDI_EXPORT int qbdipreload_on_run(QBDI::VMInstanceRef vm, QBDI::rword start, QBDI::rword stop) {
  auto log = redlog::get_logger("mintrace.preload");

  log.inf("qbdipreload_on_run called");

  // get config
  w1::util::env_config config_loader("MINTRACE_");
  int verbose = config_loader.get<int>("VERBOSE", 0);

  // set log level based on debug level
  if (verbose >= 4) {
    redlog::set_level(redlog::level::pedantic);
  } else if (verbose >= 3) {
    redlog::set_level(redlog::level::debug);
  } else if (verbose >= 2) {
    redlog::set_level(redlog::level::trace);
  } else if (verbose >= 1) {
    redlog::set_level(redlog::level::verbose);
  } else {
    redlog::set_level(redlog::level::info);
  }

  // initialize signal handling for emergency shutdown
  w1::tn3ss::signal_handler::config sig_config;
  sig_config.context_name = "mintrace";
  sig_config.log_signals = verbose;

  if (w1::tn3ss::signal_handler::initialize(sig_config)) {
    w1::tn3ss::signal_handler::register_cleanup(
        shutdown_tracer,
        200, // high priority
        "mintrace_shutdown"
    );
    log.inf("signal handling initialized for tracer shutdown");
  } else {
    log.wrn("failed to initialize signal handling - shutdown on signal unavailable");
  }

  // create tracer
  log.inf("creating tracer");
  g_tracer = std::make_unique<mintrace_tracer>();

  // create engine
  log.inf("creating tracer engine");
  g_engine = std::make_unique<w1::tracer_engine<mintrace_tracer>>(vm, *g_tracer);

  // initialize tracer
  g_tracer->initialize(*g_engine);

  // instrument
  log.inf("instrumenting engine");
  if (!g_engine->instrument()) {
    log.error("engine instrumentation failed");
    return QBDIPRELOAD_ERR_STARTUP_FAILED;
  }

  log.inf("engine instrumentation successful");

  // run engine
  log.inf("running engine", redlog::field("start", "0x%08x", start), redlog::field("stop", "0x%08x", stop));
  if (!g_engine->run(start, stop)) {
    log.error("engine run failed");
    return QBDIPRELOAD_ERR_STARTUP_FAILED;
  }

  // execution doesn't reach here if it works (vm run jumps)
  log.inf("qbdipreload_on_run completed");

  return QBDIPRELOAD_NO_ERROR;
}

QBDI_EXPORT int qbdipreload_on_exit(int status) { return QBDIPRELOAD_NO_ERROR; }

QBDI_EXPORT int qbdipreload_on_start(void* main) {
#if defined(_WIN32) || defined(WIN32)
  // on windows, allow logging to show for gui targets
  w1::common::allocate_windows_console();
#endif
  return QBDIPRELOAD_NOT_HANDLED;
}

QBDI_EXPORT int qbdipreload_on_premain(void* gprCtx, void* fpuCtx) { return QBDIPRELOAD_NOT_HANDLED; }

QBDI_EXPORT int qbdipreload_on_main(int argc, char** argv) { return QBDIPRELOAD_NOT_HANDLED; }

} // extern "C"
```

`src/tracers/w1cov/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${WITNESS_SOURCE_DIR}/cmake/TracerConfig.cmake)

create_tracer_targets(w1cov
    "preload.cpp;coverage_tracer.cpp;coverage_collector.cpp;coverage_module_tracker.cpp"
)
```

`src/tracers/w1cov/coverage_collector.cpp`:

```cpp
#include "coverage_collector.hpp"
#include <w1tn3ss/formats/drcov.hpp>
#include <redlog.hpp>
#include <algorithm>

namespace w1cov {

coverage_collector::coverage_collector() {}

uint16_t coverage_collector::add_module(const w1::util::module_info& mod) {
  auto it = std::find_if(modules_.begin(), modules_.end(), [&mod](const w1::util::module_info& existing) {
    return existing.base_address == mod.base_address;
  });

  if (it != modules_.end()) {
    return static_cast<uint16_t>(std::distance(modules_.begin(), it));
  }

  modules_.push_back(mod);
  return static_cast<uint16_t>(modules_.size() - 1);
}

void coverage_collector::record_coverage_unit(QBDI::rword address, uint16_t size, uint16_t module_id) {
  // increment hitcount for this address
  hitcounts_[address]++;

  // check if this is a new address
  auto it = address_to_bb_index_.find(address);
  if (it == address_to_bb_index_.end()) {
    // new basic block
    basic_block_info bb;
    bb.address = address;
    bb.size = size;
    bb.module_id = module_id;
    bb.hitcount = hitcounts_[address];

    size_t index = basic_blocks_.size();
    basic_blocks_.push_back(bb);
    address_to_bb_index_[address] = index;
  } else {
    // existing basic block - update hitcount
    basic_blocks_[it->second].hitcount = hitcounts_[address];
  }
}

drcov::coverage_data coverage_collector::build_drcov_data() const {
  auto log = redlog::get_logger("w1cov.collector");

  // ensure we have modules to export
  if (modules_.empty()) {
    log.wrn("no modules to export");
    return drcov::coverage_data{};
  }

  log.trc(
      "building drcov data", redlog::field("module_count", modules_.size()),
      redlog::field("coverage_unit_count", basic_blocks_.size()), redlog::field("total_hits", get_total_hits())
  );

  // create drcov builder with hitcount support enabled
  auto builder =
      drcov::builder().set_flavor("w1cov").enable_hitcounts().set_module_version(drcov::module_table_version::v2);

  // pass 1: add modules with validation
  size_t valid_modules = 0;
  size_t invalid_modules = 0;

  log.trc("adding modules to drcov data");

  for (size_t i = 0; i < modules_.size(); ++i) {
    const auto& mod = modules_[i];

    try {
      // validate module data before adding
      if (mod.base_address >= mod.base_address + mod.size) {
        log.wrn(
            "invalid module address range detected", redlog::field("id", i), redlog::field("name", mod.name),
            redlog::field("base", mod.base_address), redlog::field("end", mod.base_address + mod.size)
        );
        invalid_modules++;
        continue;
      }

      if (mod.path.empty() && mod.name.empty()) {
        log.wrn("module has empty path and name", redlog::field("id", i), redlog::field("base", mod.base_address));
        invalid_modules++;
        continue;
      }

      // use path if available, otherwise use name
      std::string module_path = !mod.path.empty() ? mod.path : mod.name;

      builder.add_module(module_path, mod.base_address, mod.base_address + mod.size, mod.base_address);
      valid_modules++;

      log.dbg(
          "added module to drcov", redlog::field("id", i), redlog::field("name", mod.name),
          redlog::field("base", "0x%08x", mod.base_address), redlog::field("size", mod.size)
      );

    } catch (const std::exception& e) {
      log.err(
          "failed to add module to drcov builder", redlog::field("id", i), redlog::field("name", mod.name),
          redlog::field("error", e.what())
      );
      invalid_modules++;
    }
  }

  log.dbg(
      "module processing completed", redlog::field("valid", valid_modules), redlog::field("invalid", invalid_modules)
  );

  // pass 2: add coverage units with hitcounts and validation
  size_t valid_units = 0;
  size_t invalid_units = 0;
  size_t orphaned_units = 0;

  log.trc("adding coverage units to drcov data");

  for (const auto& bb : basic_blocks_) {
    try {
      // validate module id
      if (bb.module_id >= modules_.size()) {
        log.wrn(
            "coverage unit references unknown module", redlog::field("module_id", bb.module_id),
            redlog::field("address", "0x%08x", bb.address)
        );
        orphaned_units++;
        continue;
      }

      const auto& module = modules_[bb.module_id];

      // validate unit is within module bounds
      if (bb.address < module.base_address || bb.address >= module.base_address + module.size) {
        log.wrn(
            "coverage unit address outside module bounds", redlog::field("module_id", bb.module_id),
            redlog::field("address", "0x%08x", bb.address), redlog::field("base", "0x%08x", module.base_address),
            redlog::field("end", "0x%08x", module.base_address + module.size)
        );
        invalid_units++;
        continue;
      }

      // calculate module-relative offset
      uint32_t offset = static_cast<uint32_t>(bb.address - module.base_address);

      // validate offset calculation
      if (offset >= module.size) {
        log.wrn(
            "calculated offset exceeds module size", redlog::field("module_id", bb.module_id),
            redlog::field("offset", offset), redlog::field("module_size", module.size)
        );
        invalid_units++;
        continue;
      }

      // get hitcount for this address
      uint32_t hitcount = bb.hitcount;
      if (hitcount == 0) {
        // fallback to hitcounts map
        auto hitcount_it = hitcounts_.find(bb.address);
        if (hitcount_it != hitcounts_.end()) {
          hitcount = hitcount_it->second;
        } else {
          hitcount = 1; // default fallback
        }
      }

      builder.add_coverage(bb.module_id, offset, bb.size, hitcount);
      valid_units++;

    } catch (const std::exception& e) {
      log.err(
          "failed to add coverage unit to drcov builder", redlog::field("module_id", bb.module_id),
          redlog::field("address", "0x%08x", bb.address), redlog::field("error", e.what())
      );
      invalid_units++;
    }
  }

  log.dbg(
      "coverage unit processing completed", redlog::field("valid", valid_units),
      redlog::field("invalid", invalid_units), redlog::field("orphaned", orphaned_units)
  );

  if (valid_units == 0 && !basic_blocks_.empty()) {
    log.wrn("no valid coverage units were exported despite having collected data");
  }

  try {
    auto result = builder.build();

    log.trc(
        "drcov data export completed successfully", redlog::field("modules", valid_modules),
        redlog::field("units", valid_units)
    );

    return result;

  } catch (const std::exception& e) {
    log.err("failed to build drcov data structure", redlog::field("error", e.what()));
    throw; // re-throw to be handled by caller
  }
}

size_t coverage_collector::get_coverage_unit_count() const { return basic_blocks_.size(); }

size_t coverage_collector::get_module_count() const { return modules_.size(); }

uint64_t coverage_collector::get_total_hits() const {
  uint64_t total = 0;
  for (const auto& [addr, count] : hitcounts_) {
    total += count;
  }
  return total;
}

uint32_t coverage_collector::get_hitcount(QBDI::rword address) const {
  auto it = hitcounts_.find(address);
  return (it != hitcounts_.end()) ? it->second : 0;
}

const w1::util::module_info* coverage_collector::find_module_by_id(uint16_t id) const {
  if (id >= modules_.size()) {
    return nullptr;
  }
  return &modules_[id];
}

} // namespace w1cov
```

`src/tracers/w1cov/coverage_collector.hpp`:

```hpp
#pragma once

#include <w1tn3ss/util/module_info.hpp>
#include <w1tn3ss/formats/drcov.hpp>
#include <vector>
#include <unordered_map>
#include <QBDI.h>

namespace w1cov {

struct basic_block_info {
  QBDI::rword address;
  uint16_t size;
  uint16_t module_id;
  uint32_t hitcount;
};

class coverage_collector {
public:
  coverage_collector();

  uint16_t add_module(const w1::util::module_info& mod);

  void record_coverage_unit(QBDI::rword address, uint16_t size, uint16_t module_id);

  drcov::coverage_data build_drcov_data() const;

  size_t get_coverage_unit_count() const;
  size_t get_module_count() const;
  uint64_t get_total_hits() const;
  uint32_t get_hitcount(QBDI::rword address) const;
  const w1::util::module_info* find_module_by_id(uint16_t id) const;

private:
  std::vector<w1::util::module_info> modules_;
  std::unordered_map<QBDI::rword, size_t> address_to_bb_index_;
  std::vector<basic_block_info> basic_blocks_;
  std::unordered_map<QBDI::rword, uint32_t> hitcounts_;
};

} // namespace w1cov
```

`src/tracers/w1cov/coverage_config.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>
#include <w1tn3ss/util/env_config.hpp>
#include <w1tn3ss/engine/tracer_config_base.hpp>

namespace w1cov {

struct coverage_config : public w1::tracer_config_base {
  int verbose = 0;
  std::string output_file = "coverage.drcov";
  bool inst_trace = false;

  static coverage_config from_environment() {
    w1::util::env_config loader("W1COV_");

    coverage_config config;
    config.verbose = loader.get<int>("VERBOSE", 0);
    config.output_file = loader.get<std::string>("OUTPUT", "coverage.drcov");
    config.include_system_modules = loader.get<bool>("INCLUDE_SYSTEM", false);
    config.inst_trace = loader.get<bool>("INST_TRACE", false);
    auto module_filter_env = loader.get_list("MODULE_FILTER");
    if (!module_filter_env.empty()) {
      config.module_filter = module_filter_env;
    }

    return config;
  }
};

} // namespace w1cov
```

`src/tracers/w1cov/coverage_module_tracker.cpp`:

```cpp
#include "coverage_module_tracker.hpp"
#include <algorithm>

namespace w1cov {

coverage_module_tracker::coverage_module_tracker(const coverage_config& config)
    : config_(config), collector_(nullptr) {}

void coverage_module_tracker::initialize(coverage_collector& collector) {
  log_.vrb("initializing coverage module tracker");

  collector_ = &collector;

  // scan all executable modules
  auto all_modules = scanner_.scan_executable_modules();

  // filter modules that should be traced
  std::vector<w1::util::module_info> traced_modules;
  traced_modules.reserve(all_modules.size() / 2); // estimate

  for (const auto& mod : all_modules) {
    if (should_trace_module(mod)) {
      traced_modules.push_back(mod);
    }
  }

  // register modules with collector and build mapping
  base_to_module_id_.clear();
  base_to_module_id_.reserve(traced_modules.size());

  for (const auto& mod : traced_modules) {
    uint16_t module_id = collector_->add_module(mod);
    base_to_module_id_[mod.base_address] = module_id;

    log_.dbg(
        "registered traced module", redlog::field("module_name", mod.name), redlog::field("module_id", module_id),
        redlog::field("base_address", "0x%08x", mod.base_address)
    );
  }

  // build fast lookup index with traced modules
  index_.rebuild_from_modules(std::move(traced_modules));

  log_.inf(
      "module tracker initialization complete", redlog::field("total_modules", all_modules.size()),
      redlog::field("traced_modules", traced_module_count())
  );
}

size_t coverage_module_tracker::traced_module_count() const { return index_.size(); }

bool coverage_module_tracker::should_trace_module(const w1::util::module_info& mod) const {
  // unknown modules are never traced
  if (mod.type == w1::util::module_type::UNKNOWN) {
    return false;
  }

  // apply module name filter if specified
  if (!config_.module_filter.empty()) {
    for (const auto& filter_name : config_.module_filter) {
      if (mod.name.find(filter_name) != std::string::npos) {
        return true;
      }
    }
    return false; // not in filter list
  }

  // include system modules only if configured
  if (mod.is_system_library && !config_.include_system_modules) {
    return false;
  }

  // default: trace all modules except system modules (unless include_system_modules is true)
  return true;
}

void coverage_module_tracker::rebuild_traced_modules() {
  // scan all current modules
  auto all_modules = scanner_.scan_executable_modules();

  // filter modules for tracing
  std::vector<w1::util::module_info> traced_modules;
  traced_modules.reserve(all_modules.size() / 2);

  std::copy_if(
      all_modules.begin(), all_modules.end(), std::back_inserter(traced_modules),
      [this](const w1::util::module_info& mod) { return should_trace_module(mod); }
  );

  // rebuild index with filtered modules
  index_.rebuild_from_modules(std::move(traced_modules));
}

} // namespace w1cov
```

`src/tracers/w1cov/coverage_module_tracker.hpp`:

```hpp
#pragma once

#include <w1tn3ss/util/module_scanner.hpp>
#include <w1tn3ss/util/module_range_index.hpp>
#include "coverage_config.hpp"
#include "coverage_collector.hpp"
#include <unordered_map>
#include <type_traits>
#include <QBDI.h>
#include <redlog.hpp>

namespace w1cov {

/**
 * @brief thin wrapper around module_range_index for coverage-specific functionality
 * @details provides coverage filtering and module id mapping on top of generic module tracking.
 * hot path is optimized for basic block entry with zero allocations.
 */
class coverage_module_tracker {
public:
  /**
   * @brief construct tracker with coverage configuration
   * @param config coverage configuration for module filtering
   */
  explicit coverage_module_tracker(const coverage_config& config);

  /**
   * @brief initialize tracker with collector, builds initial module index
   * @param collector coverage collector to register modules with
   * @details scans modules, applies filtering, and builds fast lookup index
   */
  void initialize(coverage_collector& collector);

  /**
   * @brief visit traced module at address using visitor pattern (hot path)
   * @param address memory address to query
   * @param visitor callable invoked with module_info and module_id if found
   * @return true if module found and visitor called, false otherwise
   * @note zero logging, zero allocations, optimized for basic block entry
   */
  template <typename Visitor> bool visit_traced_module(QBDI::rword address, Visitor&& visitor) const;

  /**
   * @brief attempt rescanning and visit module at address (rare path)
   * @param address memory address to query
   * @param visitor callable invoked with module_info and module_id if found
   * @return true if module found after rescanning, false otherwise
   * @note non-blocking, with logging and comprehensive error handling
   */
  template <typename Visitor> bool try_rescan_and_visit(QBDI::rword address, Visitor&& visitor);

  /**
   * @brief get count of currently traced modules
   * @return number of modules being traced
   */
  size_t traced_module_count() const;

private:
  const coverage_config& config_;
  w1::util::module_scanner scanner_;
  w1::util::module_range_index index_;
  coverage_collector* collector_;

  // module base address -> module id mapping for coverage collector
  std::unordered_map<QBDI::rword, uint16_t> base_to_module_id_;

  redlog::logger log_ = redlog::get_logger("w1cov.module_tracker");

  // coverage-specific filtering logic
  bool should_trace_module(const w1::util::module_info& mod) const;

  // rebuild traced modules with coverage filtering
  void rebuild_traced_modules();
};

template <typename Visitor>
bool coverage_module_tracker::visit_traced_module(QBDI::rword address, Visitor&& visitor) const {
  static_assert(
      std::is_invocable_v<Visitor, const w1::util::module_info&, uint16_t>,
      "visitor must be callable with (const module_info&, uint16_t)"
  );

  return index_.visit_containing(address, [&](const w1::util::module_info& mod) {
    // check if this module is being traced
    if (auto it = base_to_module_id_.find(mod.base_address); it != base_to_module_id_.end()) {
      visitor(mod, it->second);
      return true;
    }
    return false;
  });
}

template <typename Visitor> bool coverage_module_tracker::try_rescan_and_visit(QBDI::rword address, Visitor&& visitor) {
  static_assert(
      std::is_invocable_v<Visitor, const w1::util::module_info&, uint16_t>,
      "visitor must be callable with (const module_info&, uint16_t)"
  );

  // delegate to generic index rescanning
  bool found = index_.try_rescan_and_visit(address, scanner_, [&](const w1::util::module_info& mod) {
    // check if this module should be traced
    if (should_trace_module(mod)) {
      // add to collector if not already present
      if (base_to_module_id_.find(mod.base_address) == base_to_module_id_.end()) {
        uint16_t module_id = collector_->add_module(mod);
        base_to_module_id_[mod.base_address] = module_id;

        log_.dbg(
            "added new traced module", redlog::field("module_name", mod.name), redlog::field("module_id", module_id),
            redlog::field("base_address", "0x%08x", mod.base_address)
        );
      }

      // now visit with module id
      if (auto it = base_to_module_id_.find(mod.base_address); it != base_to_module_id_.end()) {
        visitor(mod, it->second);
        return true;
      }
    }
    return false;
  });

  return found;
}

} // namespace w1cov
```

`src/tracers/w1cov/coverage_tracer.cpp`:

```cpp
#include "coverage_tracer.hpp"
#include <w1tn3ss/formats/drcov.hpp>
#include <w1tn3ss/util/register_access.hpp>
#include <redlog.hpp>
#include <fstream>

namespace w1cov {

coverage_tracer::coverage_tracer(const coverage_config& config) : config_(config), module_tracker_(config) {}

bool coverage_tracer::initialize(w1::tracer_engine<coverage_tracer>& engine) {
  auto log = redlog::get_logger("w1cov.tracer");

  log.vrb("initializing coverage tracer");

  // initialize module tracker with collector
  module_tracker_.initialize(collector_);

  // manually register the appropriate callback based on mode
  QBDI::VM* vm = engine.get_vm();
  if (config_.inst_trace) {
    // register instruction-level tracing callback
    uint32_t id = vm->addCodeCB(
        QBDI::PREINST,
        [](QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr, void* data) -> QBDI::VMAction {
          auto* tracer = static_cast<coverage_tracer*>(data);
          return tracer->on_instruction_preinst_manual(vm, gpr, fpr);
        },
        this
    );
    log.info("registered instruction preinst callback", redlog::field("id", id));
  } else {
    // register basic block tracing callback
    uint32_t id = vm->addVMEventCB(
        QBDI::BASIC_BLOCK_ENTRY,
        [](QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr,
           void* data) -> QBDI::VMAction {
          auto* tracer = static_cast<coverage_tracer*>(data);
          return tracer->on_basic_block_entry_manual(vm, state, gpr, fpr);
        },
        this
    );
    log.info("registered basic block entry callback", redlog::field("id", id));
  }

  log.info(
      "tracer initialization completed", redlog::field("traced_modules", module_tracker_.traced_module_count()),
      redlog::field("inst_trace", config_.inst_trace)
  );

  return true;
}

void coverage_tracer::shutdown() {
  auto log = redlog::get_logger("w1cov.tracer");

  size_t unit_count = collector_.get_coverage_unit_count();
  size_t module_count = collector_.get_module_count();
  uint64_t total_hits = collector_.get_total_hits();

  log.info(
      "coverage collection completed", redlog::field("coverage_units", unit_count),
      redlog::field("modules", module_count), redlog::field("total_hits", total_hits)
  );
}

QBDI::VMAction coverage_tracer::on_basic_block_entry_manual(
    QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  // hot path: no logging, minimal validation
  if (!state) {
    return QBDI::VMAction::CONTINUE;
  }

  QBDI::rword block_addr = state->basicBlockStart;
  QBDI::rword block_size = state->basicBlockEnd - state->basicBlockStart;

  record_coverage_at_address(block_addr, static_cast<uint16_t>(block_size));

  return QBDI::VMAction::CONTINUE;
}

QBDI::VMAction coverage_tracer::on_instruction_preinst_manual(
    QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  // hot path: no logging, minimal validation
  if (!gpr) {
    return QBDI::VMAction::CONTINUE;
  }

  // get current instruction address
  QBDI::rword inst_addr = w1::registers::get_pc(gpr);

  // basic validation
  if (inst_addr == 0) {
    return QBDI::VMAction::CONTINUE;
  }

  // instruction size is typically small (1-15 bytes on x86)
  uint16_t inst_size = 1; // default to 1 byte, could be refined with analysis

  record_coverage_at_address(inst_addr, inst_size);

  return QBDI::VMAction::CONTINUE;
}

void coverage_tracer::record_coverage_at_address(QBDI::rword address, uint16_t size) {
  // basic validation without logging
  if (size == 0 || address == 0) {
    return;
  }

  // hot path: single visitor call, zero allocations, integrated filtering
  bool found = module_tracker_.visit_traced_module(address, [&](const w1::util::module_info& mod, uint16_t module_id) {
    collector_.record_coverage_unit(address, size, module_id);
  });

  // rare path: attempt rescanning if module not found
  if (!found) {
    module_tracker_.try_rescan_and_visit(address, [&](const w1::util::module_info& mod, uint16_t module_id) {
      collector_.record_coverage_unit(address, size, module_id);
    });
  }
}

size_t coverage_tracer::get_coverage_unit_count() const { return collector_.get_coverage_unit_count(); }

size_t coverage_tracer::get_module_count() const { return collector_.get_module_count(); }

uint64_t coverage_tracer::get_total_hits() const { return collector_.get_total_hits(); }

void coverage_tracer::print_statistics() const {
  auto log = redlog::get_logger("w1cov.tracer");

  size_t unit_count = collector_.get_coverage_unit_count();
  size_t module_count = collector_.get_module_count();
  uint64_t total_hits = collector_.get_total_hits();
  size_t traced_modules = module_tracker_.traced_module_count();

  log.inf("=== Coverage Statistics ===");
  log.inf("coverage units hit", redlog::field("count", unit_count));
  log.inf("modules instrumented", redlog::field("count", module_count));
  log.inf("traced modules", redlog::field("count", traced_modules));
  log.inf("total hits", redlog::field("count", total_hits));

  if (unit_count > 0 && total_hits > 0) {
    double avg_hits = static_cast<double>(total_hits) / unit_count;
    log.inf("average hits per unit", redlog::field("average", "%.2f", avg_hits));
  }
}

const coverage_collector& coverage_tracer::get_collector() const { return collector_; }

} // namespace w1cov
```

`src/tracers/w1cov/coverage_tracer.hpp`:

```hpp
#pragma once

#include <QBDI.h>
#include <w1tn3ss/engine/tracer_engine.hpp>

#include "coverage_collector.hpp"
#include "coverage_config.hpp"
#include "coverage_module_tracker.hpp"

namespace w1cov {

/**
 * @brief coverage tracer using optimized module tracking
 * @details simplified design using coverage_module_tracker for fast lookups
 * and integrated filtering. eliminates multiple data structures.
 */
class coverage_tracer {
public:
  explicit coverage_tracer(const coverage_config& config);

  bool initialize(w1::tracer_engine<coverage_tracer>& engine);
  void shutdown();
  const char* get_name() const { return "w1cov"; }

  QBDI::VMAction on_basic_block_entry_manual(
      QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );

  QBDI::VMAction on_instruction_preinst_manual(QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr);

  // statistics access for standalone API
  size_t get_coverage_unit_count() const;
  size_t get_module_count() const;
  uint64_t get_total_hits() const;
  void print_statistics() const;

  // collector access for standalone export
  const coverage_collector& get_collector() const;

private:
  void record_coverage_at_address(QBDI::rword address, uint16_t size);

private:
  coverage_config config_;
  coverage_collector collector_;
  coverage_module_tracker module_tracker_;
};

} // namespace w1cov
```

`src/tracers/w1cov/preload.cpp`:

```cpp
#include <cstdlib>
#include <cstring>
#include <memory>

#include "QBDIPreload.h"
#include <redlog.hpp>

#include <w1tn3ss/engine/tracer_engine.hpp>
#include <w1tn3ss/util/env_config.hpp>
#include <w1tn3ss/util/signal_handler.hpp>
#include <w1tn3ss/util/stderr_write.hpp>
#include <w1tn3ss/formats/drcov.hpp>

#if defined(_WIN32) || defined(WIN32)
#include <w1common/windows_console.hpp>
#endif

#include "coverage_config.hpp"
#include "coverage_tracer.hpp"

// globals
static std::unique_ptr<w1cov::coverage_tracer> g_tracer;
static std::unique_ptr<w1::tracer_engine<w1cov::coverage_tracer>> g_engine;
static w1cov::coverage_config g_config;

namespace {

/**
 * @brief export coverage data with signal-safe error handling
 */
void export_coverage() {
  if (!g_tracer) {
    return;
  }

  try {
    auto data = g_tracer->get_collector().build_drcov_data();
    if (!data.basic_blocks.empty()) {
      drcov::write(g_config.output_file, data);
    }
  } catch (...) {
    // signal-safe error reporting
    const char* error_msg = "w1cov: coverage export failed\n";
    w1::util::stderr_write(error_msg);
  }
}

} // anonymous namespace

extern "C" {

QBDIPRELOAD_INIT;

QBDI_EXPORT int qbdipreload_on_run(QBDI::VMInstanceRef vm, QBDI::rword start, QBDI::rword stop) {
  auto log = redlog::get_logger("w1cov.preload");

  log.inf("qbdipreload_on_run called");

  // get config
  g_config = w1cov::coverage_config::from_environment();

  // set log level based on debug level
  if (g_config.verbose >= 4) {
    redlog::set_level(redlog::level::pedantic);
  } else if (g_config.verbose >= 3) {
    redlog::set_level(redlog::level::debug);
  } else if (g_config.verbose >= 2) {
    redlog::set_level(redlog::level::trace);
  } else if (g_config.verbose >= 1) {
    redlog::set_level(redlog::level::verbose);
  } else {
    redlog::set_level(redlog::level::info);
  }

  // initialize signal handling for emergency coverage export
  w1::tn3ss::signal_handler::config sig_config;
  sig_config.context_name = "w1cov";
  sig_config.log_signals = (g_config.verbose >= 1);

  if (w1::tn3ss::signal_handler::initialize(sig_config)) {
    w1::tn3ss::signal_handler::register_cleanup(
        export_coverage,
        200, // high priority
        "w1cov_export"
    );
    log.inf("signal handling initialized for coverage export");
  } else {
    log.wrn("failed to initialize signal handling - coverage export on signal unavailable");
  }

  // create tracer
  log.inf("creating tracer");
  g_tracer = std::make_unique<w1cov::coverage_tracer>(g_config);

  // create engine
  log.inf("creating tracer engine");
  g_engine = std::make_unique<w1::tracer_engine<w1cov::coverage_tracer>>(vm, *g_tracer, g_config);

  // initialize tracer
  g_tracer->initialize(*g_engine);

  // instrument
  log.inf("instrumenting engine");
  if (!g_engine->instrument()) {
    log.err("engine instrumentation failed");
    return QBDIPRELOAD_ERR_STARTUP_FAILED;
  }

  log.inf("engine instrumentation successful");

  // run engine
  log.inf("running engine", redlog::field("start", "0x%08x", start), redlog::field("stop", "0x%08x", stop));
  if (!g_engine->run(start, stop)) {
    log.err("engine run failed");
    return QBDIPRELOAD_ERR_STARTUP_FAILED;
  }

  // execution doesn't reach here if it works (vm run jumps)
  log.inf("qbdipreload_on_run completed");

  return QBDIPRELOAD_NO_ERROR;
}

QBDI_EXPORT int qbdipreload_on_exit(int status) {
  auto log = redlog::get_logger("w1cov.preload");

  log.inf("qbdipreload_on_exit called", redlog::field("status", status));

  if (g_tracer) {
    log.inf("shutting down tracer and exporting coverage");

    export_coverage();
    auto data = g_tracer->get_collector().build_drcov_data();
    if (!data.basic_blocks.empty()) {
      log.inf("coverage data export completed", redlog::field("output_file", g_config.output_file));
    } else {
      log.wrn("no basic blocks collected, skipping export");
    }

    g_tracer->shutdown();
    g_tracer.reset();
  }

  if (g_engine) {
    g_engine.reset();
  }

  log.inf("qbdipreload_on_exit completed");
  return QBDIPRELOAD_NO_ERROR;
}

QBDI_EXPORT int qbdipreload_on_start(void* main) {
#if defined(_WIN32) || defined(WIN32)
  // on windows, allow logging to show for gui targets
  w1::common::allocate_windows_console();
#endif
  return QBDIPRELOAD_NOT_HANDLED;
}

QBDI_EXPORT int qbdipreload_on_premain(void* gprCtx, void* fpuCtx) { return QBDIPRELOAD_NOT_HANDLED; }

QBDI_EXPORT int qbdipreload_on_main(int argc, char** argv) { return QBDIPRELOAD_NOT_HANDLED; }

} // extern "C"
```

`src/tracers/w1cov/session.hpp`:

```hpp
#pragma once

#include "coverage_tracer.hpp"
#include "coverage_config.hpp"
#include <w1tn3ss/engine/session_base.hpp>
#include <w1tn3ss/formats/drcov.hpp>
#include <redlog.hpp>
#include <iostream>
#include <iomanip>

namespace w1cov {

class session : public w1::session_base<session, coverage_tracer, coverage_config> {
public:
  session() = default;
  explicit session(const coverage_config& config) : session_base(config) {}

  // coverage-specific metrics
  size_t get_coverage_unit_count() const { return get_tracer() ? get_tracer()->get_coverage_unit_count() : 0; }

  size_t get_module_count() const { return get_tracer() ? get_tracer()->get_module_count() : 0; }

  uint64_t get_total_hits() const { return get_tracer() ? get_tracer()->get_total_hits() : 0; }

  void print_statistics() const {
    if (!get_tracer()) {
      std::cout << "session not initialized\n";
      return;
    }

    size_t units = get_coverage_unit_count();
    size_t modules = get_module_count();
    uint64_t hits = get_total_hits();

    std::cout << "coverage statistics:\n";
    std::cout << "  coverage units: " << units << "\n";
    std::cout << "  modules: " << modules << "\n";
    std::cout << "  total hits: " << hits << "\n";

    if (units > 0 && hits > 0) {
      double avg = static_cast<double>(hits) / units;
      std::cout << "  avg hits/unit: " << std::fixed << std::setprecision(2) << avg << "\n";
    }
  }

  bool export_coverage(const std::string& output_path) const {
    if (!get_tracer()) {
      return false;
    }

    auto log = redlog::get_logger("w1cov.session");

    try {
      const auto& collector = get_tracer()->get_collector();
      auto data = collector.build_drcov_data();

      if (data.basic_blocks.empty()) {
        log.wrn("no coverage data to export");
        return false;
      }

      drcov::write(output_path, data);
      log.inf(
          "coverage exported", redlog::field("file", output_path), redlog::field("blocks", data.basic_blocks.size())
      );
      return true;

    } catch (const std::exception& e) {
      log.err("export failed", redlog::field("error", e.what()));
      return false;
    }
  }
};

} // namespace w1cov
```

`src/tracers/w1inst/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${WITNESS_SOURCE_DIR}/cmake/TracerConfig.cmake)

create_tracer_targets(w1inst
    "preload.cpp;instruction_tracer.cpp;instruction_collector.cpp"
)
```

`src/tracers/w1inst/instruction_collector.cpp`:

```cpp
#include "instruction_collector.hpp"
#include <chrono>
#include <sstream>

namespace w1inst {

mnemonic_collector::mnemonic_collector(const std::string& output_file, const std::vector<std::string>& target_mnemonics)
    : instruction_count_(0), matched_count_(0), metadata_written_(false), modules_initialized_(false) {

  // initialize output if file specified
  if (!output_file.empty()) {
    jsonl_writer_ = std::make_unique<w1::util::jsonl_writer>(output_file);
    if (!jsonl_writer_->is_open()) {
      log_.err("failed to open output file", redlog::field("path", output_file));
      jsonl_writer_.reset();
    }
  }

  // initialize stats
  stats_ = {};
  stats_.target_mnemonics = target_mnemonics;

  // convert vector to set for faster lookup
  for (const auto& mnemonic : target_mnemonics) {
    target_mnemonic_set_.insert(mnemonic);
  }
}

void mnemonic_collector::record_instruction() {
  instruction_count_++;
  stats_.total_instructions++;
}

void mnemonic_collector::record_mnemonic(
    uint64_t address, const std::string& mnemonic, const std::string& disassembly
) {
  // check if this mnemonic matches our targets
  bool matches = false;

  // special case: '*' means match all instructions
  if (target_mnemonic_set_.count("*")) {
    matches = true;
  } else {
    // exact string matching
    matches = (target_mnemonic_set_.find(mnemonic) != target_mnemonic_set_.end());
  }

  if (!matches) {
    return; // not a target mnemonic
  }

  matched_count_++;
  stats_.matched_instructions++;

  // create event
  mnemonic_entry entry;
  entry.address = address;
  entry.mnemonic = mnemonic;
  entry.disassembly = disassembly;
  entry.instruction_count = instruction_count_;
  entry.module_name = get_module_name(address);

  // write event if output configured
  if (jsonl_writer_) {
    ensure_metadata_written();
    write_event(entry);
  }
}

void mnemonic_collector::ensure_metadata_written() {
  if (!jsonl_writer_ || metadata_written_) {
    return;
  }

  // ensure modules are initialized
  if (!modules_initialized_) {
    initialize_module_tracking();
  }

  write_metadata();
  metadata_written_ = true;
}

void mnemonic_collector::initialize_module_tracking() {
  if (modules_initialized_) {
    return;
  }

  // scan all executable modules
  auto modules = scanner_.scan_executable_modules();

  // rebuild index with all modules for fast lookup
  index_.rebuild_from_modules(std::move(modules));

  modules_initialized_ = true;
}

std::string mnemonic_collector::get_module_name(uint64_t address) const {
  if (address == 0) {
    return "unknown";
  }

  // ensure modules are initialized before lookup
  if (!modules_initialized_) {
    // lazy initialization - cast away const for initialization
    const_cast<mnemonic_collector*>(this)->initialize_module_tracking();
  }

  // fast lookup using module range index
  auto module_info = index_.find_containing(address);
  if (module_info) {
    return module_info->name;
  }

  // fallback for addresses not in any known module
  return "unknown";
}

void mnemonic_collector::write_metadata() {
  if (!jsonl_writer_ || !jsonl_writer_->is_open()) {
    return;
  }

  // create metadata object
  std::stringstream json;
  json << "{\"type\":\"metadata\",\"version\":1,\"tracer\":\"w1inst\"";

  // add target mnemonics
  json << ",\"target_mnemonics\":[";
  bool first = true;
  for (const auto& mnemonic : stats_.target_mnemonics) {
    if (!first) {
      json << ",";
    }
    first = false;
    json << "\"" << mnemonic << "\"";
  }
  json << "]";

  // add module information
  json << ",\"modules\":[";

  first = true;
  size_t module_id = 0;
  index_.visit_all([&](const w1::util::module_info& mod) {
    if (!first) {
      json << ",";
    }
    first = false;

    json << "{\"id\":" << module_id++ << ",\"name\":\"" << mod.name << "\""
         << ",\"path\":\"" << mod.path << "\""
         << ",\"base\":" << mod.base_address << ",\"size\":" << mod.size << ",\"type\":\""
         << (mod.type == w1::util::module_type::MAIN_EXECUTABLE ? "main" : "library") << "\""
         << ",\"is_system\":" << (mod.is_system_library ? "true" : "false") << "}";
  });

  json << "]}";

  jsonl_writer_->write_line(json.str());
}

void mnemonic_collector::write_event(const mnemonic_entry& entry) {
  if (!jsonl_writer_ || !jsonl_writer_->is_open()) {
    return;
  }

  // serialize the entry to json with compact formatting
  std::string json = JS::serializeStruct(entry, JS::SerializerOptions(JS::SerializerOptions::Compact));

  // wrap in event envelope
  std::stringstream wrapped;
  wrapped << "{\"type\":\"event\",\"data\":" << json << "}";

  jsonl_writer_->write_line(wrapped.str());
}

} // namespace w1inst
```

`src/tracers/w1inst/instruction_collector.hpp`:

```hpp
#pragma once

#include <vector>
#include <unordered_set>
#include <cstdint>
#include <string>
#include <memory>
#include <w1common/ext/jsonstruct.hpp>
#include <w1tn3ss/util/jsonl_writer.hpp>
#include <w1tn3ss/util/module_scanner.hpp>
#include <w1tn3ss/util/module_range_index.hpp>
#include <redlog.hpp>

namespace w1inst {

struct mnemonic_entry {
  uint64_t address;
  std::string mnemonic;
  std::string disassembly;
  uint32_t instruction_count;
  std::string module_name;

  JS_OBJECT(
      JS_MEMBER(address), JS_MEMBER(mnemonic), JS_MEMBER(disassembly), JS_MEMBER(instruction_count),
      JS_MEMBER(module_name)
  );
};

struct mnemonic_stats {
  uint64_t total_instructions;
  uint64_t matched_instructions;
  std::vector<std::string> target_mnemonics;

  JS_OBJECT(JS_MEMBER(total_instructions), JS_MEMBER(matched_instructions), JS_MEMBER(target_mnemonics));
};

class mnemonic_collector {
public:
  explicit mnemonic_collector(const std::string& output_file, const std::vector<std::string>& target_mnemonics);

  void record_instruction();
  void record_mnemonic(uint64_t address, const std::string& mnemonic, const std::string& disassembly);

  const mnemonic_stats& get_stats() const { return stats_; }
  uint32_t get_instruction_count() const { return instruction_count_; }

private:
  mnemonic_stats stats_;
  std::unordered_set<std::string> target_mnemonic_set_;

  uint32_t instruction_count_;
  uint64_t matched_count_;

  // jsonl output
  std::unique_ptr<w1::util::jsonl_writer> jsonl_writer_;
  bool metadata_written_;

  // module tracking
  w1::util::module_scanner scanner_;
  w1::util::module_range_index index_;
  bool modules_initialized_;

  redlog::logger log_ = redlog::get_logger("w1.inst.collector");

  void ensure_metadata_written();
  void write_metadata();
  void write_event(const mnemonic_entry& entry);
  void initialize_module_tracking();
  std::string get_module_name(uint64_t address) const;
};

} // namespace w1inst
```

`src/tracers/w1inst/instruction_config.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>
#include <sstream>
#include <stdexcept>
#include <w1tn3ss/util/env_config.hpp>
#include <w1tn3ss/engine/tracer_config_base.hpp>

namespace w1inst {

struct instruction_config : public w1::tracer_config_base {
  std::string output_file = "";
  std::string target_mnemonics;           // comma-separated list
  std::vector<std::string> mnemonic_list; // parsed list
  int verbose = 0;

  static instruction_config from_environment() {
    w1::util::env_config loader("W1INST_");

    instruction_config config;
    config.include_system_modules = loader.get<bool>("INCLUDE_SYSTEM", false);
    config.output_file = loader.get<std::string>("OUTPUT", "");
    config.target_mnemonics = loader.get<std::string>("MNEMONICS", "");

    if (config.target_mnemonics.empty()) {
      throw std::runtime_error("w1inst_mnemonics environment variable is required (comma-separated list)");
    }
    config.verbose = loader.get<int>("VERBOSE", 0);

    // parse comma-separated mnemonics
    config.parse_mnemonics();

    return config;
  }

  void parse_mnemonics() {
    mnemonic_list.clear();
    std::string mnemonic;
    std::stringstream ss(target_mnemonics);

    while (std::getline(ss, mnemonic, ',')) {
      // trim whitespace
      mnemonic.erase(0, mnemonic.find_first_not_of(" \t"));
      mnemonic.erase(mnemonic.find_last_not_of(" \t") + 1);

      if (!mnemonic.empty()) {
        mnemonic_list.push_back(mnemonic);
      }
    }
  }
};

} // namespace w1inst
```

`src/tracers/w1inst/instruction_tracer.cpp`:

```cpp
#include "instruction_tracer.hpp"
#include <fstream>

namespace w1inst {

instruction_tracer::instruction_tracer(const instruction_config& config)
    : config_(config), collector_(config.output_file, config.mnemonic_list) {

  if (config_.verbose) {
    log_.inf(
        "mnemonic tracer created", redlog::field("output", config_.output_file),
        redlog::field("target_mnemonics", config_.target_mnemonics)
    );
  }
}

bool instruction_tracer::initialize(w1::tracer_engine<instruction_tracer>& engine) {
  log_.inf("initializing mnemonic tracer");

  QBDI::VM* vm = engine.get_vm();
  if (!vm) {
    log_.error("vm instance is null");
    return false;
  }

  if (config_.verbose) {
    log_.inf("mnemonic tracer initialized", redlog::field("target_count", config_.mnemonic_list.size()));

    for (const auto& mnemonic : config_.mnemonic_list) {
      log_.debug("targeting mnemonic", redlog::field("mnemonic", mnemonic));
    }
  }

  return true;
}

void instruction_tracer::shutdown() {
  const auto& stats = collector_.get_stats();
  log_.inf(
      "instruction collection completed", redlog::field("total", stats.total_instructions),
      redlog::field("matched", stats.matched_instructions), redlog::field("targets", stats.target_mnemonics.size())
  );
}

QBDI::VMAction instruction_tracer::on_instruction_preinst(
    QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  // count this instruction
  collector_.record_instruction();

  // get instruction analysis
  const QBDI::InstAnalysis* analysis = vm->getInstAnalysis();
  if (!analysis) {
    return QBDI::VMAction::CONTINUE;
  }

  // record if mnemonic matches our targets
  std::string mnemonic(analysis->mnemonic);
  collector_.record_mnemonic(analysis->address, mnemonic, analysis->disassembly);

  return QBDI::VMAction::CONTINUE;
}

const mnemonic_stats& instruction_tracer::get_stats() const { return collector_.get_stats(); }

void instruction_tracer::print_statistics() const {
  const auto& stats = collector_.get_stats();
  log_.inf(
      "instruction stats", redlog::field("total", stats.total_instructions),
      redlog::field("matched", stats.matched_instructions), redlog::field("targets", stats.target_mnemonics.size())
  );
}

} // namespace w1inst
```

`src/tracers/w1inst/instruction_tracer.hpp`:

```hpp
#pragma once

#include <QBDI.h>
#include <w1tn3ss/engine/tracer_engine.hpp>
#include <redlog.hpp>

#include "instruction_collector.hpp"
#include "instruction_config.hpp"

namespace w1inst {

class instruction_tracer {
public:
  explicit instruction_tracer(const instruction_config& config);

  bool initialize(w1::tracer_engine<instruction_tracer>& engine);
  void shutdown();
  const char* get_name() const { return "w1inst"; }

  // instruction callback for mnemonic filtering
  QBDI::VMAction on_instruction_preinst(QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr);

  // statistics access
  const mnemonic_stats& get_stats() const;
  void print_statistics() const;

private:
  instruction_config config_;
  mnemonic_collector collector_;
  redlog::logger log_ = redlog::get_logger("w1inst.tracer");
};

} // namespace w1inst
```

`src/tracers/w1inst/preload.cpp`:

```cpp
#include <cstring>
#include <memory>

#include "QBDIPreload.h"
#include <redlog.hpp>

#include <w1tn3ss/engine/tracer_engine.hpp>
#include <w1tn3ss/util/signal_handler.hpp>
#include <w1tn3ss/util/stderr_write.hpp>

#if defined(_WIN32) || defined(WIN32)
#include <w1common/windows_console.hpp>
#endif

#include "instruction_tracer.hpp"
#include "instruction_config.hpp"

// globals
static std::unique_ptr<w1inst::instruction_tracer> g_tracer;
static std::unique_ptr<w1::tracer_engine<w1inst::instruction_tracer>> g_engine;
static w1inst::instruction_config g_config;

namespace {

/**
 * @brief shutdown tracer with signal-safe error handling
 */
void shutdown_tracer() {
  if (!g_tracer) {
    return;
  }

  try {
    g_tracer->shutdown();
  } catch (...) {
    const char* error_msg = "w1inst: tracer shutdown failed\n";
    w1::util::stderr_write(error_msg);
  }
}

} // anonymous namespace

extern "C" {

QBDIPRELOAD_INIT;

QBDI_EXPORT int qbdipreload_on_run(QBDI::VMInstanceRef vm, QBDI::rword start, QBDI::rword stop) {
  auto log = redlog::get_logger("w1inst.preload");

  log.inf("w1inst preload starting");

  // get config from environment
  try {
    g_config = w1inst::instruction_config::from_environment();

    // set log level based on debug level
    if (g_config.verbose >= 4) {
      redlog::set_level(redlog::level::pedantic);
    } else if (g_config.verbose >= 3) {
      redlog::set_level(redlog::level::debug);
    } else if (g_config.verbose >= 2) {
      redlog::set_level(redlog::level::trace);
    } else if (g_config.verbose >= 1) {
      redlog::set_level(redlog::level::verbose);
    } else {
      redlog::set_level(redlog::level::info);
    }

    // initialize signal handling for emergency shutdown
    w1::tn3ss::signal_handler::config sig_config;
    sig_config.context_name = "w1inst";
    sig_config.log_signals = g_config.verbose;

    if (w1::tn3ss::signal_handler::initialize(sig_config)) {
      w1::tn3ss::signal_handler::register_cleanup(
          shutdown_tracer,
          200, // high priority
          "w1inst_shutdown"
      );
      log.inf("signal handling initialized for tracer shutdown");
    } else {
      log.wrn("failed to initialize signal handling - shutdown on signal unavailable");
    }

    // create tracer
    log.inf("creating instruction tracer");
    g_tracer = std::make_unique<w1inst::instruction_tracer>(g_config);

    // create engine
    log.inf("creating tracer engine");
    g_engine = std::make_unique<w1::tracer_engine<w1inst::instruction_tracer>>(vm, *g_tracer, g_config);

    // initialize tracer
    if (!g_tracer->initialize(*g_engine)) {
      log.error("tracer initialization failed");
      return QBDIPRELOAD_ERR_STARTUP_FAILED;
    }

    // instrument
    log.inf("instrumenting engine");
    if (!g_engine->instrument()) {
      log.error("engine instrumentation failed");
      return QBDIPRELOAD_ERR_STARTUP_FAILED;
    }

    log.inf("engine instrumentation successful");

    // run engine
    log.inf("running engine", redlog::field("start", "0x%08x", start), redlog::field("stop", "0x%08x", stop));
    if (!g_engine->run(start, stop)) {
      log.error("engine run failed");
      return QBDIPRELOAD_ERR_STARTUP_FAILED;
    }

    // execution doesn't reach here if it works (vm run jumps)
    log.inf("w1inst preload completed");

  } catch (const std::exception& e) {
    log.error("failed to initialize w1inst tracer", redlog::field("error", e.what()));
    return QBDIPRELOAD_ERR_STARTUP_FAILED;
  }

  return QBDIPRELOAD_NO_ERROR;
}

QBDI_EXPORT int qbdipreload_on_exit(int status) {
  auto log = redlog::get_logger("w1inst.preload");
  log.inf("w1inst preload exit", redlog::field("status", status));

  if (g_tracer) {
    g_tracer->shutdown();
  }

  return QBDIPRELOAD_NO_ERROR;
}

QBDI_EXPORT int qbdipreload_on_start(void* main) {
#if defined(_WIN32) || defined(WIN32)
  // on windows, allow logging to show for gui targets
  w1::common::allocate_windows_console();
#endif
  return QBDIPRELOAD_NOT_HANDLED;
}

QBDI_EXPORT int qbdipreload_on_premain(void* gprCtx, void* fpuCtx) { return QBDIPRELOAD_NOT_HANDLED; }

QBDI_EXPORT int qbdipreload_on_main(int argc, char** argv) { return QBDIPRELOAD_NOT_HANDLED; }

} // extern "C"
```

`src/tracers/w1inst/session.hpp`:

```hpp
#pragma once

#include "instruction_tracer.hpp"
#include "instruction_config.hpp"
#include <w1tn3ss/engine/session_base.hpp>

namespace w1inst {

class session : public w1::session_base<session, instruction_tracer, instruction_config> {
public:
  session() = default;
  explicit session(const instruction_config& config) : session_base(config) {}

  // instruction-specific metrics
  const mnemonic_stats& get_stats() const { return get_tracer()->get_stats(); }
};

} // namespace w1inst
```

`src/tracers/w1mem/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${WITNESS_SOURCE_DIR}/cmake/TracerConfig.cmake)

create_tracer_targets(w1mem
    "preload.cpp;memory_tracer.cpp;memory_collector.cpp"
)
```

`src/tracers/w1mem/memory_collector.cpp`:

```cpp
#include "memory_collector.hpp"
#include <chrono>
#include <sstream>

namespace w1mem {

memory_collector::memory_collector(const std::string& output_file)
    : instruction_count_(0), metadata_written_(false), modules_initialized_(false) {

  // initialize output if file specified
  if (!output_file.empty()) {
    jsonl_writer_ = std::make_unique<w1::util::jsonl_writer>(output_file);
    if (!jsonl_writer_->is_open()) {
      log_.err("failed to open output file", redlog::field("path", output_file));
      jsonl_writer_.reset();
    }
  }

  // initialize stats
  stats_ = {};
}

void memory_collector::record_instruction() {
  instruction_count_++;
  stats_.total_instructions++;
}

void memory_collector::record_memory_access(
    uint64_t instruction_addr, uint64_t memory_addr, uint32_t size, uint8_t access_type
) {
  // update statistics
  if (access_type == 1) { // read
    stats_.total_reads++;
    stats_.total_bytes_read += size;
    unique_read_addrs_.insert(memory_addr);
    stats_.unique_read_addresses = unique_read_addrs_.size();
  } else if (access_type == 2) { // write
    stats_.total_writes++;
    stats_.total_bytes_written += size;
    unique_write_addrs_.insert(memory_addr);
    stats_.unique_write_addresses = unique_write_addrs_.size();
  }

  // create event
  memory_access_entry entry;
  entry.instruction_addr = instruction_addr;
  entry.memory_addr = memory_addr;
  entry.size = size;
  entry.access_type = access_type;
  entry.instruction_count = instruction_count_;
  entry.instruction_module = get_module_name(instruction_addr);
  entry.memory_module = get_module_name(memory_addr);

  // write event if output configured
  if (jsonl_writer_) {
    ensure_metadata_written();
    write_event(entry);
  }
}

void memory_collector::ensure_metadata_written() {
  if (!jsonl_writer_ || metadata_written_) {
    return;
  }

  // ensure modules are initialized
  if (!modules_initialized_) {
    initialize_module_tracking();
  }

  write_metadata();
  metadata_written_ = true;
}

void memory_collector::initialize_module_tracking() {
  if (modules_initialized_) {
    return;
  }

  // scan all executable modules
  auto modules = scanner_.scan_executable_modules();

  // rebuild index with all modules for fast lookup
  index_.rebuild_from_modules(std::move(modules));

  modules_initialized_ = true;
}

std::string memory_collector::get_module_name(uint64_t address) const {
  if (address == 0) {
    return "null";
  }

  // ensure modules are initialized before lookup
  if (!modules_initialized_) {
    // lazy initialization - cast away const for initialization
    const_cast<memory_collector*>(this)->initialize_module_tracking();
  }

  // fast lookup using module range index
  auto module_info = index_.find_containing(address);
  if (module_info) {
    return module_info->name;
  }

  // fallback for addresses not in any known module
  return "unknown";
}

void memory_collector::write_metadata() {
  if (!jsonl_writer_ || !jsonl_writer_->is_open()) {
    return;
  }

  // create metadata object
  std::stringstream json;
  json << "{\"type\":\"metadata\",\"version\":1,\"tracer\":\"w1mem\"";

  // add module information
  json << ",\"modules\":[";

  bool first = true;
  size_t module_id = 0;
  index_.visit_all([&](const w1::util::module_info& mod) {
    if (!first) {
      json << ",";
    }
    first = false;

    json << "{\"id\":" << module_id++ << ",\"name\":\"" << mod.name << "\""
         << ",\"path\":\"" << mod.path << "\""
         << ",\"base\":" << mod.base_address << ",\"size\":" << mod.size << ",\"type\":\""
         << (mod.type == w1::util::module_type::MAIN_EXECUTABLE ? "main" : "library") << "\""
         << ",\"is_system\":" << (mod.is_system_library ? "true" : "false") << "}";
  });

  json << "]}";

  jsonl_writer_->write_line(json.str());
}

void memory_collector::write_event(const memory_access_entry& entry) {
  if (!jsonl_writer_ || !jsonl_writer_->is_open()) {
    return;
  }

  // serialize the entry to json with compact formatting
  std::string json = JS::serializeStruct(entry, JS::SerializerOptions(JS::SerializerOptions::Compact));

  // wrap in event envelope
  std::stringstream wrapped;
  wrapped << "{\"type\":\"event\",\"data\":" << json << "}";

  jsonl_writer_->write_line(wrapped.str());
}

} // namespace w1mem
```

`src/tracers/w1mem/memory_collector.hpp`:

```hpp
#pragma once

#include <unordered_set>
#include <cstdint>
#include <string>
#include <memory>
#include <w1common/ext/jsonstruct.hpp>
#include <w1tn3ss/util/jsonl_writer.hpp>
#include <w1tn3ss/util/module_scanner.hpp>
#include <w1tn3ss/util/module_range_index.hpp>
#include <redlog.hpp>

namespace w1mem {

struct memory_access_entry {
  uint64_t instruction_addr;
  uint64_t memory_addr;
  uint32_t size;
  uint8_t access_type; // 1=read, 2=write
  uint32_t instruction_count;
  std::string instruction_module;
  std::string memory_module;

  JS_OBJECT(
      JS_MEMBER(instruction_addr), JS_MEMBER(memory_addr), JS_MEMBER(size), JS_MEMBER(access_type),
      JS_MEMBER(instruction_count), JS_MEMBER(instruction_module), JS_MEMBER(memory_module)
  );
};

struct memory_stats {
  uint64_t total_reads;
  uint64_t total_writes;
  uint64_t total_bytes_read;
  uint64_t total_bytes_written;
  uint64_t unique_read_addresses;
  uint64_t unique_write_addresses;
  uint32_t total_instructions;

  JS_OBJECT(
      JS_MEMBER(total_reads), JS_MEMBER(total_writes), JS_MEMBER(total_bytes_read), JS_MEMBER(total_bytes_written),
      JS_MEMBER(unique_read_addresses), JS_MEMBER(unique_write_addresses), JS_MEMBER(total_instructions)
  );
};

class memory_collector {
public:
  explicit memory_collector(const std::string& output_file);

  void record_instruction();
  void record_memory_access(uint64_t instruction_addr, uint64_t memory_addr, uint32_t size, uint8_t access_type);

  const memory_stats& get_stats() const { return stats_; }
  uint32_t get_instruction_count() const { return instruction_count_; }

private:
  memory_stats stats_;
  std::unordered_set<uint64_t> unique_read_addrs_;
  std::unordered_set<uint64_t> unique_write_addrs_;

  uint32_t instruction_count_;

  // jsonl output
  std::unique_ptr<w1::util::jsonl_writer> jsonl_writer_;
  bool metadata_written_;

  // module tracking
  w1::util::module_scanner scanner_;
  w1::util::module_range_index index_;
  bool modules_initialized_;

  redlog::logger log_ = redlog::get_logger("w1.mem.collector");

  void ensure_metadata_written();
  void write_metadata();
  void write_event(const memory_access_entry& entry);
  void initialize_module_tracking();
  std::string get_module_name(uint64_t address) const;
};

} // namespace w1mem
```

`src/tracers/w1mem/memory_config.hpp`:

```hpp
#pragma once

#include <string>
#include <w1tn3ss/util/env_config.hpp>
#include <w1tn3ss/engine/tracer_config_base.hpp>

namespace w1mem {

struct memory_config : public w1::tracer_config_base {
  int verbose = 0;
  std::string output_path;

  static memory_config from_environment() {
    w1::util::env_config loader("W1MEM_");

    memory_config config;
    config.include_system_modules = loader.get<bool>("INCLUDE_SYSTEM", false);
    config.verbose = loader.get<int>("VERBOSE", 0);
    config.output_path = loader.get<std::string>("OUTPUT", "");

    return config;
  }
};

} // namespace w1mem
```

`src/tracers/w1mem/memory_tracer.cpp`:

```cpp
#include "memory_tracer.hpp"
#include <fstream>

namespace w1mem {

memory_tracer::memory_tracer(const memory_config& config)
    : config_(config), collector_(config.output_path), memory_recording_enabled_(false) {

  if (config_.verbose) {
    log_.inf("memory tracer created", redlog::field("output", config_.output_path));
  }
}

bool memory_tracer::initialize(w1::tracer_engine<memory_tracer>& engine) {
  log_.inf("initializing memory tracer");

  // enable qbdi memory recording for efficient collection
  QBDI::VM* vm = engine.get_vm();
  if (!vm) {
    log_.error("vm instance is null");
    return false;
  }

  // enable memory access recording
  memory_recording_enabled_ = vm->recordMemoryAccess(QBDI::MEMORY_READ_WRITE);
  if (!memory_recording_enabled_) {
    log_.warn("memory recording not supported on this platform, using callback fallback");
  }

  log_.inf("memory tracer initialized", redlog::field("memory_recording", memory_recording_enabled_));
  return true;
}

void memory_tracer::shutdown() {
  log_.inf("shutting down memory tracer");
  // no export needed - streaming output handles everything
}

QBDI::VMAction memory_tracer::on_instruction_postinst(
    QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {

  // count this instruction
  collector_.record_instruction();

  if (memory_recording_enabled_) {
    // get memory accesses for this instruction
    std::vector<QBDI::MemoryAccess> accesses = vm->getInstMemoryAccess();

    // get instruction analysis for context
    const QBDI::InstAnalysis* analysis = vm->getInstAnalysis();
    uint64_t instruction_addr = analysis ? analysis->address : 0;

    // record each memory access
    for (const auto& access : accesses) {
      uint8_t access_type = 0;
      if (access.type & QBDI::MEMORY_READ) {
        access_type = 1;
      } else if (access.type & QBDI::MEMORY_WRITE) {
        access_type = 2;
      }

      if (access_type > 0) {
        collector_.record_memory_access(instruction_addr, access.accessAddress, access.size, access_type);
      }
    }
  }

  return QBDI::VMAction::CONTINUE;
}

const memory_stats& memory_tracer::get_stats() const { return collector_.get_stats(); }

} // namespace w1mem
```

`src/tracers/w1mem/memory_tracer.hpp`:

```hpp
#pragma once

#include <QBDI.h>
#include <w1tn3ss/engine/tracer_engine.hpp>
#include <redlog.hpp>

#include "memory_collector.hpp"
#include "memory_config.hpp"

namespace w1mem {

class memory_tracer {
public:
  explicit memory_tracer(const memory_config& config);

  bool initialize(w1::tracer_engine<memory_tracer>& engine);
  void shutdown();
  const char* get_name() const { return "w1mem"; }

  // required callbacks for tracer_engine
  QBDI::VMAction on_instruction_postinst(QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr);

  // statistics access
  const memory_stats& get_stats() const;

private:
  memory_config config_;
  memory_collector collector_;
  redlog::logger log_ = redlog::get_logger("w1mem.tracer");
  bool memory_recording_enabled_;
};

} // namespace w1mem
```

`src/tracers/w1mem/preload.cpp`:

```cpp
#include <cstring>
#include <memory>

#include "QBDIPreload.h"
#include <redlog.hpp>

#include <w1tn3ss/engine/tracer_engine.hpp>
#include <w1tn3ss/util/signal_handler.hpp>
#include <w1tn3ss/util/stderr_write.hpp>

#if defined(_WIN32) || defined(WIN32)
#include <w1common/windows_console.hpp>
#endif

#include "memory_tracer.hpp"
#include "memory_config.hpp"

// globals
static std::unique_ptr<w1mem::memory_tracer> g_tracer;
static std::unique_ptr<w1::tracer_engine<w1mem::memory_tracer>> g_engine;
static w1mem::memory_config g_config;

namespace {

/**
 * @brief shutdown tracer with signal-safe error handling
 */
void shutdown_tracer() {
  if (!g_tracer) {
    return;
  }

  try {
    g_tracer->shutdown();
  } catch (...) {
    const char* error_msg = "w1mem: tracer shutdown failed\n";
    w1::util::stderr_write(error_msg);
  }
}

} // anonymous namespace

extern "C" {

QBDIPRELOAD_INIT;

QBDI_EXPORT int qbdipreload_on_run(QBDI::VMInstanceRef vm, QBDI::rword start, QBDI::rword stop) {
  auto log = redlog::get_logger("w1mem.preload");

  log.inf("w1mem preload starting");

  // get config from environment
  g_config = w1mem::memory_config::from_environment();

  // set log level based on debug level
  if (g_config.verbose >= 4) {
    redlog::set_level(redlog::level::pedantic);
  } else if (g_config.verbose >= 3) {
    redlog::set_level(redlog::level::debug);
  } else if (g_config.verbose >= 2) {
    redlog::set_level(redlog::level::trace);
  } else if (g_config.verbose >= 1) {
    redlog::set_level(redlog::level::verbose);
  } else {
    redlog::set_level(redlog::level::info);
  }

  // initialize signal handling for emergency shutdown
  w1::tn3ss::signal_handler::config siconfig;
  siconfig.context_name = "w1mem";
  siconfig.log_signals = g_config.verbose;

  if (w1::tn3ss::signal_handler::initialize(siconfig)) {
    w1::tn3ss::signal_handler::register_cleanup(
        shutdown_tracer,
        200, // high priority
        "w1mem_shutdown"
    );
    log.inf("signal handling initialized for tracer shutdown");
  } else {
    log.wrn("failed to initialize signal handling - shutdown on signal unavailable");
  }

  // create tracer
  log.inf("creating memory tracer");
  g_tracer = std::make_unique<w1mem::memory_tracer>(g_config);

  // create engine
  log.inf("creating tracer engine");
  g_engine = std::make_unique<w1::tracer_engine<w1mem::memory_tracer>>(vm, *g_tracer, g_config);

  // initialize tracer
  if (!g_tracer->initialize(*g_engine)) {
    log.error("tracer initialization failed");
    return QBDIPRELOAD_ERR_STARTUP_FAILED;
  }

  // instrument
  log.inf("instrumenting engine");
  if (!g_engine->instrument()) {
    log.error("engine instrumentation failed");
    return QBDIPRELOAD_ERR_STARTUP_FAILED;
  }

  log.inf("engine instrumentation successful");

  // run engine
  log.inf("running engine", redlog::field("start", "0x%08x", start), redlog::field("stop", "0x%08x", stop));
  if (!g_engine->run(start, stop)) {
    log.error("engine run failed");
    return QBDIPRELOAD_ERR_STARTUP_FAILED;
  }

  // execution doesn't reach here if it works (vm run jumps)
  log.inf("w1mem preload completed");

  return QBDIPRELOAD_NO_ERROR;
}

QBDI_EXPORT int qbdipreload_on_exit(int status) {
  auto log = redlog::get_logger("w1mem.preload");
  log.inf("w1mem preload exit", redlog::field("status", status));

  if (g_tracer) {
    g_tracer->shutdown();
  }

  return QBDIPRELOAD_NO_ERROR;
}

QBDI_EXPORT int qbdipreload_on_start(void* main) {
#if defined(_WIN32) || defined(WIN32)
  // on windows, allow logging to show for gui targets
  w1::common::allocate_windows_console();
#endif
  return QBDIPRELOAD_NOT_HANDLED;
}

QBDI_EXPORT int qbdipreload_on_premain(void* gprCtx, void* fpuCtx) { return QBDIPRELOAD_NOT_HANDLED; }

QBDI_EXPORT int qbdipreload_on_main(int argc, char** argv) { return QBDIPRELOAD_NOT_HANDLED; }

} // extern "C"
```

`src/tracers/w1script/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${WITNESS_SOURCE_DIR}/cmake/TracerConfig.cmake)
include(${WITNESS_SOURCE_DIR}/cmake/LuaConfig.cmake)
include(${WITNESS_SOURCE_DIR}/cmake/LIEFConfig.cmake)

if(WITNESS_SCRIPT)
    message(STATUS "building w1script tracer with lua support")
    
    create_tracer_targets(w1script
        "preload.cpp;script_tracer.cpp;script_bindings.cpp;script_loader.cpp;callback_manager.cpp;api_analysis_processor.cpp;bindings/core_types.cpp;bindings/register_access.cpp;bindings/vm_control.cpp;bindings/memory_access.cpp;bindings/memory_analysis.cpp;bindings/module_analysis.cpp;bindings/utilities.cpp;bindings/callback_system.cpp;bindings/api_analysis.cpp;bindings/hooking.cpp;bindings/signature_scanning.cpp;bindings/calling_convention.cpp;bindings/symbol_resolution.cpp;bindings/output.cpp"
    )
    
    configure_target_with_lua(w1script_qbdipreload)
    configure_target_with_lua(w1script_static)
    
    # Apply LIEF configuration for symbol resolution
    if(WITNESS_BUILD_SHARED)
        configure_target_with_lief(w1script_qbdipreload)
        target_link_libraries(w1script_qbdipreload PRIVATE p1ll)
    endif()
    
    if(WITNESS_BUILD_STATIC)
        configure_target_with_lief(w1script_static)
        target_link_libraries(w1script_static PRIVATE p1ll)
    endif()
    
else()
    message(STATUS "w1script tracer disabled (WITNESS_SCRIPT=OFF)")
endif()
```

`src/tracers/w1script/api_analysis_processor.cpp`:

```cpp
#include "api_analysis_processor.hpp"
#include "bindings/api_analysis.hpp"
#include <w1tn3ss/util/register_access.hpp>
#include <chrono>

namespace w1::tracers::script {

api_analysis_processor::api_analysis_processor() : logger_(redlog::get_logger("w1.api_processor")) {}

void api_analysis_processor::process_call(
    QBDI::VM* vm, const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr,
    bindings::api_analysis_manager* api_manager, util::module_range_index* module_index,
    symbols::symbol_resolver* symbol_resolver
) {
  if (!api_manager || !module_index) {
    return;
  }

  // build api context
  w1::abi::api_context ctx;
  ctx.vm = vm;
  ctx.vm_state = state;
  ctx.gpr_state = gpr;
  ctx.fpr_state = fpr;
  ctx.module_index = module_index;
  ctx.timestamp = std::chrono::steady_clock::now().time_since_epoch().count();

  // for calls: source is where we're calling from, target is what we're calling
  ctx.call_address = state->sequenceStart;
  ctx.target_address = w1::registers::get_pc(gpr);

  // get module and symbol names
  if (auto module_info = module_index->find_containing(ctx.target_address)) {
    ctx.module_name = module_info->name;

    // resolve symbol if we have a resolver
#ifdef WITNESS_LIEF_ENABLED
    if (symbol_resolver) {
      if (auto sym_info = symbol_resolver->resolve_address(ctx.target_address, *module_index)) {
        ctx.symbol_name = sym_info->name;
      }
    }
#endif
  }

  logger_.dbg(
      "processing api call", redlog::field("target", ctx.target_address), redlog::field("module", ctx.module_name),
      redlog::field("symbol", ctx.symbol_name)
  );

  api_manager->process_call(ctx);
}

void api_analysis_processor::process_return(
    QBDI::VM* vm, const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr,
    bindings::api_analysis_manager* api_manager, util::module_range_index* module_index,
    symbols::symbol_resolver* symbol_resolver
) {
  if (!api_manager || !module_index) {
    return;
  }

  // build api context
  w1::abi::api_context ctx;
  ctx.vm = vm;
  ctx.vm_state = state;
  ctx.gpr_state = gpr;
  ctx.fpr_state = fpr;
  ctx.module_index = module_index;
  ctx.timestamp = std::chrono::steady_clock::now().time_since_epoch().count();

  // for returns: source is what we're returning from, target is where we're returning to
  ctx.target_address = state->sequenceStart;
  ctx.call_address = w1::registers::get_pc(gpr);

  // get module and symbol names
  if (auto module_info = module_index->find_containing(ctx.target_address)) {
    ctx.module_name = module_info->name;

    // resolve symbol if we have a resolver
#ifdef WITNESS_LIEF_ENABLED
    if (symbol_resolver) {
      if (auto sym_info = symbol_resolver->resolve_address(ctx.target_address, *module_index)) {
        ctx.symbol_name = sym_info->name;
      }
    }
#endif
  }

  api_manager->process_return(ctx);
}

} // namespace w1::tracers::script
```

`src/tracers/w1script/api_analysis_processor.hpp`:

```hpp
#pragma once

#include <QBDI.h>
#include <memory>
#include <w1tn3ss/util/module_range_index.hpp>
#include <w1tn3ss/symbols/symbol_resolver.hpp>
#include <w1tn3ss/abi/api_listener.hpp>
#include <redlog.hpp>

namespace w1::tracers::script {

// forward declaration
namespace bindings {
class api_analysis_manager;
}

/**
 * handles api analysis processing for exec_transfer events
 * extracted from script_tracer to improve separation of concerns
 */
class api_analysis_processor {
private:
  redlog::logger logger_;

public:
  api_analysis_processor();

  /**
   * process exec_transfer_call event
   * @param vm QBDI VM instance
   * @param state VM state
   * @param gpr GPR state
   * @param fpr FPR state
   * @param api_manager API analysis manager
   * @param module_index Module index
   * @param symbol_resolver Symbol resolver (optional)
   */
  void process_call(
      QBDI::VM* vm, const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr,
      bindings::api_analysis_manager* api_manager, util::module_range_index* module_index,
      symbols::symbol_resolver* symbol_resolver = nullptr
  );

  /**
   * process exec_transfer_return event
   * @param vm QBDI VM instance
   * @param state VM state
   * @param gpr GPR state
   * @param fpr FPR state
   * @param api_manager API analysis manager
   * @param module_index Module index
   * @param symbol_resolver Symbol resolver (optional)
   */
  void process_return(
      QBDI::VM* vm, const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr,
      bindings::api_analysis_manager* api_manager, util::module_range_index* module_index,
      symbols::symbol_resolver* symbol_resolver = nullptr
  );
};

} // namespace w1::tracers::script
```

`src/tracers/w1script/bindings/api_analysis.cpp`:

```cpp
#include "api_analysis.hpp"
#include <redlog.hpp>

namespace w1::tracers::script::bindings {

namespace {

// convert C++ api_event to Lua table
sol::table convert_api_event_to_lua(sol::state_view lua, const abi::api_event& event) {
  auto result = lua.create_table();

  // basic event info
  result["type"] = (event.type == abi::api_event::event_type::CALL) ? "call" : "return";
  result["timestamp"] = event.timestamp;
  result["source_address"] = event.source_address;
  result["target_address"] = event.target_address;

  // api identification
  result["module_name"] = event.module_name;
  result["symbol_name"] = event.symbol_name;
  result["category"] = static_cast<int>(event.category);
  result["description"] = event.description;
  result["formatted_call"] = event.formatted_call;
  result["analysis_complete"] = event.analysis_complete;

  // convert arguments
  auto args_table = lua.create_table();
  for (size_t i = 0; i < event.arguments.size(); ++i) {
    const auto& arg = event.arguments[i];
    auto arg_table = lua.create_table();
    arg_table["raw_value"] = arg.raw_value;
    arg_table["param_name"] = arg.param_name;
    arg_table["param_type"] = static_cast<int>(arg.param_type);
    arg_table["interpreted_value"] = arg.interpreted_value;
    arg_table["is_pointer"] = arg.is_pointer;
    args_table[i + 1] = arg_table; // Lua arrays are 1-indexed
  }
  result["arguments"] = args_table;

  // convert return value if present
  if (event.return_value.has_value()) {
    const auto& ret = event.return_value.value();
    auto ret_table = lua.create_table();
    ret_table["raw_value"] = ret.raw_value;
    ret_table["param_type"] = static_cast<int>(ret.param_type);
    ret_table["interpreted_value"] = ret.interpreted_value;
    ret_table["is_pointer"] = ret.is_pointer;
    result["return_value"] = ret_table;
  }

  return result;
}

} // anonymous namespace

// api_analysis_manager implementation

api_analysis_manager::api_analysis_manager() = default;

api_analysis_manager::~api_analysis_manager() { shutdown(); }

void api_analysis_manager::initialize(const util::module_range_index& index) {
  module_index_ = &index;
  initialized_ = true;

  // initialize listener if it was already created
  if (listener_) {
    listener_->initialize(index);
  }
}

void api_analysis_manager::ensure_listener() {
  if (!listener_) {
    auto logger = redlog::get_logger("w1.script_api_analysis");
    logger.inf("creating api_listener on first use");

    // create with default config
    abi::analyzer_config cfg;
    cfg.extract_arguments = true;
    cfg.format_calls = true;
    cfg.max_string_length = 256;

    listener_ = std::make_unique<abi::api_listener>(cfg);

    // initialize if we already have module index
    if (initialized_ && module_index_) {
      logger.inf("initializing api_listener with module index");
      listener_->initialize(*module_index_);
    }
  }
}

void api_analysis_manager::process_call(const abi::api_context& ctx) {
  if (listener_) {
    listener_->process_call(ctx);
  }
}

void api_analysis_manager::process_return(const abi::api_context& ctx) {
  if (listener_) {
    listener_->process_return(ctx);
  }
}

void api_analysis_manager::shutdown() {
  if (listener_) {
    auto logger = redlog::get_logger("w1.script_api_analysis");
    logger.dbg("shutting down api_listener");
    listener_->clear_all_callbacks();
    listener_.reset();
  }
}

// setup function

void setup_api_analysis(
    sol::state& lua, sol::table& w1_module, sol::table& tracer_table, std::shared_ptr<api_analysis_manager>& manager
) {
  auto logger = redlog::get_logger("w1.script_bindings");
  logger.dbg("setting up api analysis bindings");

  // ensure manager exists
  if (!manager) {
    manager = std::make_shared<api_analysis_manager>();
  }

  // add API category enum to w1 module
  auto api_category = lua.new_enum<abi::api_info::category>(
      "ApiCategory", {{"UNKNOWN", abi::api_info::category::UNKNOWN},
                      {"FILE_IO", abi::api_info::category::FILE_IO},
                      {"FILE_MANAGEMENT", abi::api_info::category::FILE_MANAGEMENT},
                      {"STDIO", abi::api_info::category::STDIO},
                      {"DEVICE_IO", abi::api_info::category::DEVICE_IO},
                      {"PROCESS_CONTROL", abi::api_info::category::PROCESS_CONTROL},
                      {"THREAD_CONTROL", abi::api_info::category::THREAD_CONTROL},
                      {"THREADING", abi::api_info::category::THREADING},
                      {"MEMORY_MANAGEMENT", abi::api_info::category::MEMORY_MANAGEMENT},
                      {"HEAP_MANAGEMENT", abi::api_info::category::HEAP_MANAGEMENT},
                      {"SYNCHRONIZATION", abi::api_info::category::SYNCHRONIZATION},
                      {"MUTEX", abi::api_info::category::MUTEX},
                      {"EVENT", abi::api_info::category::EVENT},
                      {"SEMAPHORE", abi::api_info::category::SEMAPHORE},
                      {"NETWORK_SOCKET", abi::api_info::category::NETWORK_SOCKET},
                      {"NETWORK_DNS", abi::api_info::category::NETWORK_DNS},
                      {"NETWORK_HTTP", abi::api_info::category::NETWORK_HTTP},
                      {"REGISTRY", abi::api_info::category::REGISTRY},
                      {"SECURITY", abi::api_info::category::SECURITY},
                      {"CRYPTO", abi::api_info::category::CRYPTO},
                      {"SYSTEM_INFO", abi::api_info::category::SYSTEM_INFO},
                      {"TIME", abi::api_info::category::TIME},
                      {"ENVIRONMENT", abi::api_info::category::ENVIRONMENT},
                      {"STRING_MANIPULATION", abi::api_info::category::STRING_MANIPULATION},
                      {"LOCALE", abi::api_info::category::LOCALE},
                      {"LIBRARY_LOADING", abi::api_info::category::LIBRARY_LOADING},
                      {"MATH", abi::api_info::category::MATH},
                      {"SORTING", abi::api_info::category::SORTING},
                      {"IPC", abi::api_info::category::IPC},
                      {"PIPE", abi::api_info::category::PIPE},
                      {"SHARED_MEMORY", abi::api_info::category::SHARED_MEMORY},
                      {"UI", abi::api_info::category::UI},
                      {"WINDOW", abi::api_info::category::WINDOW},
                      {"SYSTEM_HOOK", abi::api_info::category::SYSTEM_HOOK},
                      {"MISC", abi::api_info::category::MISC}}
  );
  w1_module["ApiCategory"] = api_category;

  // also create a simple table for easier access
  sol::table api_category_table = lua.create_table();
  api_category_table["UNKNOWN"] = static_cast<int>(abi::api_info::category::UNKNOWN);
  api_category_table["FILE_IO"] = static_cast<int>(abi::api_info::category::FILE_IO);
  api_category_table["FILE_MANAGEMENT"] = static_cast<int>(abi::api_info::category::FILE_MANAGEMENT);
  api_category_table["STDIO"] = static_cast<int>(abi::api_info::category::STDIO);
  api_category_table["DEVICE_IO"] = static_cast<int>(abi::api_info::category::DEVICE_IO);
  api_category_table["PROCESS_CONTROL"] = static_cast<int>(abi::api_info::category::PROCESS_CONTROL);
  api_category_table["THREAD_CONTROL"] = static_cast<int>(abi::api_info::category::THREAD_CONTROL);
  api_category_table["THREADING"] = static_cast<int>(abi::api_info::category::THREADING);
  api_category_table["MEMORY_MANAGEMENT"] = static_cast<int>(abi::api_info::category::MEMORY_MANAGEMENT);
  api_category_table["HEAP_MANAGEMENT"] = static_cast<int>(abi::api_info::category::HEAP_MANAGEMENT);
  api_category_table["SYNCHRONIZATION"] = static_cast<int>(abi::api_info::category::SYNCHRONIZATION);
  api_category_table["MUTEX"] = static_cast<int>(abi::api_info::category::MUTEX);
  api_category_table["EVENT"] = static_cast<int>(abi::api_info::category::EVENT);
  api_category_table["SEMAPHORE"] = static_cast<int>(abi::api_info::category::SEMAPHORE);
  api_category_table["NETWORK_SOCKET"] = static_cast<int>(abi::api_info::category::NETWORK_SOCKET);
  api_category_table["NETWORK_DNS"] = static_cast<int>(abi::api_info::category::NETWORK_DNS);
  api_category_table["NETWORK_HTTP"] = static_cast<int>(abi::api_info::category::NETWORK_HTTP);
  api_category_table["REGISTRY"] = static_cast<int>(abi::api_info::category::REGISTRY);
  api_category_table["SECURITY"] = static_cast<int>(abi::api_info::category::SECURITY);
  api_category_table["CRYPTO"] = static_cast<int>(abi::api_info::category::CRYPTO);
  api_category_table["SYSTEM_INFO"] = static_cast<int>(abi::api_info::category::SYSTEM_INFO);
  api_category_table["TIME"] = static_cast<int>(abi::api_info::category::TIME);
  api_category_table["ENVIRONMENT"] = static_cast<int>(abi::api_info::category::ENVIRONMENT);
  api_category_table["STRING_MANIPULATION"] = static_cast<int>(abi::api_info::category::STRING_MANIPULATION);
  api_category_table["LOCALE"] = static_cast<int>(abi::api_info::category::LOCALE);
  api_category_table["LIBRARY_LOADING"] = static_cast<int>(abi::api_info::category::LIBRARY_LOADING);
  api_category_table["MATH"] = static_cast<int>(abi::api_info::category::MATH);
  api_category_table["SORTING"] = static_cast<int>(abi::api_info::category::SORTING);
  api_category_table["IPC"] = static_cast<int>(abi::api_info::category::IPC);
  api_category_table["PIPE"] = static_cast<int>(abi::api_info::category::PIPE);
  api_category_table["SHARED_MEMORY"] = static_cast<int>(abi::api_info::category::SHARED_MEMORY);
  api_category_table["UI"] = static_cast<int>(abi::api_info::category::UI);
  api_category_table["WINDOW"] = static_cast<int>(abi::api_info::category::WINDOW);
  api_category_table["SYSTEM_HOOK"] = static_cast<int>(abi::api_info::category::SYSTEM_HOOK);
  api_category_table["MISC"] = static_cast<int>(abi::api_info::category::MISC);
  w1_module["API_CATEGORY"] = api_category_table;

  // add utility function to get category name strings
  w1_module["api_category_name"] = [](abi::api_info::category category) -> std::string {
    switch (category) {
    case abi::api_info::category::UNKNOWN:
      return "unknown";
    case abi::api_info::category::FILE_IO:
      return "file_io";
    case abi::api_info::category::FILE_MANAGEMENT:
      return "file_mgmt";
    case abi::api_info::category::STDIO:
      return "stdio";
    case abi::api_info::category::DEVICE_IO:
      return "device_io";
    case abi::api_info::category::PROCESS_CONTROL:
      return "process";
    case abi::api_info::category::THREAD_CONTROL:
      return "thread";
    case abi::api_info::category::THREADING:
      return "threading";
    case abi::api_info::category::MEMORY_MANAGEMENT:
      return "memory";
    case abi::api_info::category::HEAP_MANAGEMENT:
      return "heap";
    case abi::api_info::category::SYNCHRONIZATION:
      return "sync";
    case abi::api_info::category::MUTEX:
      return "mutex";
    case abi::api_info::category::EVENT:
      return "event";
    case abi::api_info::category::SEMAPHORE:
      return "semaphore";
    case abi::api_info::category::NETWORK_SOCKET:
      return "network";
    case abi::api_info::category::NETWORK_DNS:
      return "dns";
    case abi::api_info::category::NETWORK_HTTP:
      return "http";
    case abi::api_info::category::REGISTRY:
      return "registry";
    case abi::api_info::category::SECURITY:
      return "security";
    case abi::api_info::category::CRYPTO:
      return "crypto";
    case abi::api_info::category::SYSTEM_INFO:
      return "system";
    case abi::api_info::category::TIME:
      return "time";
    case abi::api_info::category::ENVIRONMENT:
      return "environment";
    case abi::api_info::category::STRING_MANIPULATION:
      return "string";
    case abi::api_info::category::LOCALE:
      return "locale";
    case abi::api_info::category::LIBRARY_LOADING:
      return "library";
    case abi::api_info::category::MATH:
      return "math";
    case abi::api_info::category::SORTING:
      return "sorting";
    case abi::api_info::category::IPC:
      return "ipc";
    case abi::api_info::category::PIPE:
      return "pipe";
    case abi::api_info::category::SHARED_MEMORY:
      return "shared_memory";
    case abi::api_info::category::UI:
      return "ui";
    case abi::api_info::category::WINDOW:
      return "window";
    case abi::api_info::category::SYSTEM_HOOK:
      return "system_hook";
    case abi::api_info::category::MISC:
      return "misc";
    default:
      return "category_" + std::to_string(static_cast<int>(category));
    }
  };

  // capture manager by value (shared_ptr) to ensure it outlives callbacks
  // note: we rely on the script_tracer to keep the lua state alive

  // add registration functions to the tracer table
  tracer_table["register_api_symbol_callback"] = [manager](
                                                     sol::this_state ts, const std::string& module,
                                                     const std::string& symbol, sol::protected_function callback
                                                 ) {
    lua_State* L = ts;
    manager->ensure_listener();
    manager->get_listener()->register_symbol_callback(module, symbol, [L, callback](const abi::api_event& event) {
      sol::state_view lua(L);
      auto lua_event = convert_api_event_to_lua(lua, event);
      auto result = callback(lua_event);
      if (!result.valid()) {
        sol::error err = result;
        auto log = redlog::get_logger("w1.script_api_analysis");
        log.err("error in api symbol callback", redlog::field("error", err.what()));
      }
    });
  };

  tracer_table["register_api_module_callback"] =
      [manager](sol::this_state ts, const std::string& module, sol::protected_function callback) {
        lua_State* L = ts;
        manager->ensure_listener();
        manager->get_listener()->register_module_callback(module, [L, callback](const abi::api_event& event) {
          sol::state_view lua(L);
          auto lua_event = convert_api_event_to_lua(lua, event);
          auto result = callback(lua_event);
          if (!result.valid()) {
            sol::error err = result;
            auto log = redlog::get_logger("w1.script_api_analysis");
            log.err("error in api module callback", redlog::field("error", err.what()));
          }
        });
      };

  tracer_table["register_api_category_callback"] =
      [manager](sol::this_state ts, abi::api_info::category category, sol::protected_function callback) {
        lua_State* L = ts;
        manager->ensure_listener();
        manager->get_listener()->register_category_callback(category, [L, callback](const abi::api_event& event) {
          sol::state_view lua(L);
          auto lua_event = convert_api_event_to_lua(lua, event);
          auto result = callback(lua_event);
          if (!result.valid()) {
            sol::error err = result;
            auto log = redlog::get_logger("w1.script_api_analysis");
            log.err("error in api category callback", redlog::field("error", err.what()));
          }
        });
      };

  logger.dbg("api analysis bindings registered successfully");
}

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/api_analysis.hpp`:

```hpp
#pragma once

#include <sol/sol.hpp>
#include <w1tn3ss/abi/api_listener.hpp>
#include <memory>

namespace w1::tracers::script::bindings {

// forward declaration
class api_analysis_manager;

/**
 * @brief setup api analysis bindings for lua scripting
 *
 * This adds api monitoring capabilities to the w1script tracer:
 * - tracer:register_api_symbol_callback(module, symbol, callback)
 * - tracer:register_api_module_callback(module, callback)
 * - tracer:register_api_category_callback(category, callback)
 *
 * The callbacks receive rich api_event objects with:
 * - full api identification (module, symbol, category)
 * - extracted and interpreted arguments
 * - return values (for return events)
 * - formatted call strings
 *
 * @param lua the sol2 lua state
 * @param w1_module the w1 module table
 * @param tracer_table the tracer instance table
 * @param manager shared manager for API listener lifecycle
 */
void setup_api_analysis(
    sol::state& lua, sol::table& w1_module, sol::table& tracer_table, std::shared_ptr<api_analysis_manager>& manager
);

/**
 * @brief manages the lifecycle of api analysis for a script instance
 *
 * This class handles:
 * - lazy creation of api_listener
 * - registration of lua callbacks
 * - event conversion from c++ to lua
 * - cleanup on shutdown
 */
class api_analysis_manager : public std::enable_shared_from_this<api_analysis_manager> {
public:
  api_analysis_manager();
  ~api_analysis_manager();

  // initialize the api_listener with module index
  // note: the module index must outlive this manager instance
  void initialize(const util::module_range_index& index);

  // ensure api_listener exists (lazy creation)
  void ensure_listener();

  // get the listener (may be null if not created)
  abi::api_listener* get_listener() { return listener_.get(); }

  // process calls/returns through the listener
  void process_call(const abi::api_context& ctx);
  void process_return(const abi::api_context& ctx);

  // cleanup
  void shutdown();

private:
  std::unique_ptr<abi::api_listener> listener_;
  const util::module_range_index* module_index_ = nullptr;
  bool initialized_ = false;
};

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/callback_system.cpp`:

```cpp
#include "callback_system.hpp"
#include <redlog.hpp>
#include <stdexcept>

namespace w1::tracers::script::bindings {

// global callback manager instance
std::shared_ptr<LuaCallbackManager> g_callback_manager;

// helper function implementations

uint32_t getNextCallbackId(LuaCallbackManager* mgr) { return mgr->next_callback_id_++; }

QBDI::VM* get_vm_instance(void* vm_ptr) { return static_cast<QBDI::VM*>(vm_ptr); }

// LuaCallbackManager implementation

void LuaCallbackManager::registerInstCallback(uint32_t qbdi_id, uint32_t callback_id, sol::protected_function func) {
  inst_callbacks_[callback_id] = std::make_unique<LuaInstCallback>(std::move(func), shared_from_this(), callback_id);
  callback_id_to_qbdi_id_[callback_id] = qbdi_id;
}

void LuaCallbackManager::registerVMCallback(uint32_t qbdi_id, uint32_t callback_id, sol::protected_function func) {
  vm_callbacks_[callback_id] = std::make_unique<LuaVMCallback>(std::move(func), shared_from_this(), callback_id);
  callback_id_to_qbdi_id_[callback_id] = qbdi_id;
}

void LuaCallbackManager::registerInstrRuleCallback(
    uint32_t qbdi_id, uint32_t callback_id, sol::protected_function func
) {
  instr_rule_callbacks_[callback_id] =
      std::make_unique<LuaInstrRuleCallback>(std::move(func), shared_from_this(), callback_id);
  callback_id_to_qbdi_id_[callback_id] = qbdi_id;
}

void LuaCallbackManager::registerPersistentPtr(uint32_t callback_id, uint32_t* ptr) {
  callback_id_to_persistent_ptr_[callback_id] = ptr;
}

bool LuaCallbackManager::removeCallback(uint32_t callback_id) {
  bool found = false;

  auto inst_it = inst_callbacks_.find(callback_id);
  if (inst_it != inst_callbacks_.end()) {
    inst_callbacks_.erase(inst_it);
    found = true;
  }

  auto vm_it = vm_callbacks_.find(callback_id);
  if (vm_it != vm_callbacks_.end()) {
    vm_callbacks_.erase(vm_it);
    found = true;
  }

  auto rule_it = instr_rule_callbacks_.find(callback_id);
  if (rule_it != instr_rule_callbacks_.end()) {
    instr_rule_callbacks_.erase(rule_it);
    found = true;
  }

  auto id_it = callback_id_to_qbdi_id_.find(callback_id);
  if (id_it != callback_id_to_qbdi_id_.end()) {
    callback_id_to_qbdi_id_.erase(id_it);
  }

  // clean up persistent pointer
  auto ptr_it = callback_id_to_persistent_ptr_.find(callback_id);
  if (ptr_it != callback_id_to_persistent_ptr_.end()) {
    delete ptr_it->second;
    callback_id_to_persistent_ptr_.erase(ptr_it);
  }

  return found;
}

void LuaCallbackManager::removeAllCallbacks() {
  // clean up all persistent pointers
  for (auto& pair : callback_id_to_persistent_ptr_) {
    delete pair.second;
  }

  inst_callbacks_.clear();
  vm_callbacks_.clear();
  instr_rule_callbacks_.clear();
  callback_id_to_qbdi_id_.clear();
  callback_id_to_persistent_ptr_.clear();
}

LuaInstCallback* LuaCallbackManager::getInstCallback(uint32_t callback_id) {
  auto it = inst_callbacks_.find(callback_id);
  return (it != inst_callbacks_.end()) ? it->second.get() : nullptr;
}

LuaVMCallback* LuaCallbackManager::getVMCallback(uint32_t callback_id) {
  auto it = vm_callbacks_.find(callback_id);
  return (it != vm_callbacks_.end()) ? it->second.get() : nullptr;
}

LuaInstrRuleCallback* LuaCallbackManager::getInstrRuleCallback(uint32_t callback_id) {
  auto it = instr_rule_callbacks_.find(callback_id);
  return (it != instr_rule_callbacks_.end()) ? it->second.get() : nullptr;
}

// C++ callback wrappers that call into Lua

QBDI::VMAction luaInstCallbackWrapper(QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr, void* data) {
  auto log = redlog::get_logger("w1.script_callbacks");

  if (!data) {
    log.err("null callback data in luaInstCallbackWrapper");
    return QBDI::VMAction::CONTINUE;
  }

  uint32_t* callback_id_ptr = static_cast<uint32_t*>(data);
  uint32_t callback_id = *callback_id_ptr;

  if (!g_callback_manager) {
    log.err("callback manager not initialized");
    return QBDI::VMAction::CONTINUE;
  }

  LuaInstCallback* callback = g_callback_manager->getInstCallback(callback_id);
  if (!callback) {
    log.err("callback not found", redlog::field("callback_id", callback_id));
    return QBDI::VMAction::CONTINUE;
  }

  try {
    auto result = callback->func(vm, gpr, fpr);
    if (result.valid()) {
      sol::optional<QBDI::VMAction> action = result;
      return action.value_or(QBDI::VMAction::CONTINUE);
    } else {
      sol::error err = result;
      log.err("lua callback error", redlog::field("error", err.what()));
      return QBDI::VMAction::CONTINUE;
    }
  } catch (const std::exception& e) {
    log.err("exception in lua instruction callback", redlog::field("error", e.what()));
    return QBDI::VMAction::CONTINUE;
  }
}

QBDI::VMAction luaVMCallbackWrapper(
    QBDI::VMInstanceRef vm, const QBDI::VMState* vmState, QBDI::GPRState* gpr, QBDI::FPRState* fpr, void* data
) {
  auto log = redlog::get_logger("w1.script_callbacks");

  if (!data) {
    log.err("null callback data in luaVMCallbackWrapper");
    return QBDI::VMAction::CONTINUE;
  }

  uint32_t* callback_id_ptr = static_cast<uint32_t*>(data);
  uint32_t callback_id = *callback_id_ptr;

  if (!g_callback_manager) {
    log.err("callback manager not initialized");
    return QBDI::VMAction::CONTINUE;
  }

  LuaVMCallback* callback = g_callback_manager->getVMCallback(callback_id);
  if (!callback) {
    log.err("VM callback not found", redlog::field("callback_id", callback_id));
    return QBDI::VMAction::CONTINUE;
  }

  try {
    auto result = callback->func(vm, vmState, gpr, fpr);
    if (result.valid()) {
      sol::optional<QBDI::VMAction> action = result;
      return action.value_or(QBDI::VMAction::CONTINUE);
    } else {
      sol::error err = result;
      log.err("Lua VM callback error", redlog::field("error", err.what()));
      return QBDI::VMAction::CONTINUE;
    }
  } catch (const std::exception& e) {
    log.err("exception in Lua VM callback", redlog::field("error", e.what()));
    return QBDI::VMAction::CONTINUE;
  }
}

std::vector<QBDI::InstrRuleDataCBK> luaInstrRuleCallbackWrapper(
    QBDI::VMInstanceRef vm, const QBDI::InstAnalysis* analysis, void* data
) {
  auto log = redlog::get_logger("w1.script_callbacks");

  if (!data) {
    log.err("null callback data in luaInstrRuleCallbackWrapper");
    return {};
  }

  uint32_t* callback_id_ptr = static_cast<uint32_t*>(data);
  uint32_t callback_id = *callback_id_ptr;

  if (!g_callback_manager) {
    log.err("callback manager not initialized");
    return {};
  }

  LuaInstrRuleCallback* callback = g_callback_manager->getInstrRuleCallback(callback_id);
  if (!callback) {
    log.err("instrumentation rule callback not found", redlog::field("callback_id", callback_id));
    return {};
  }

  try {
    auto result = callback->func(vm, analysis);
    if (result.valid()) {
      // for now, return empty vector - instrumentation rules are complex
      // and would need proper handling of the returned data
      return {};
    } else {
      sol::error err = result;
      log.err("Lua instrumentation rule callback error", redlog::field("error", err.what()));
      return {};
    }
  } catch (const std::exception& e) {
    log.err("exception in Lua instrumentation rule callback", redlog::field("error", e.what()));
    return {};
  }
}

// main setup function for callback system

void setup_callback_system(sol::state& lua, sol::table& w1_module) {
  auto logger = redlog::get_logger("w1.script_bindings");
  logger.dbg("setting up comprehensive callback registration system");

  // Initialize the callback manager
  if (!g_callback_manager) {
    g_callback_manager = std::make_shared<LuaCallbackManager>();
    logger.inf("initialized Lua callback manager");
  }

  //------------- instruction callbacks -------------

  // addCodeCB - Universal instruction tracing
  w1_module.set_function(
      "addCodeCB",
      [](void* vm_ptr, int pos, sol::protected_function callback,
         sol::optional<int> priority_opt) -> sol::optional<uint32_t> {
        auto log = redlog::get_logger("w1.script_callbacks");
        QBDI::VM* vm = get_vm_instance(vm_ptr);
        if (!vm) {
          return sol::nullopt;
        }

        if (!g_callback_manager) {
          log.err("callback manager not initialized");
          return sol::nullopt;
        }

        QBDI::InstPosition position = static_cast<QBDI::InstPosition>(pos);
        int priority = priority_opt.value_or(QBDI::PRIORITY_DEFAULT);

        try {
          uint32_t callback_id = getNextCallbackId(g_callback_manager.get());

          // create a persistent copy of the callback ID for the C callback data
          uint32_t* persistent_callback_id = new uint32_t(callback_id);

          uint32_t qbdi_id = vm->addCodeCB(position, luaInstCallbackWrapper, persistent_callback_id, priority);
          if (qbdi_id == QBDI::VMError::INVALID_EVENTID) {
            delete persistent_callback_id;
            log.err("failed to register instruction callback with QBDI");
            return sol::nullopt;
          }

          g_callback_manager->registerInstCallback(qbdi_id, callback_id, std::move(callback));
          g_callback_manager->registerPersistentPtr(callback_id, persistent_callback_id);
          log.dbg("registered addCodeCB", redlog::field("callback_id", callback_id), redlog::field("qbdi_id", qbdi_id));

          return callback_id;
        } catch (const std::exception& e) {
          log.err("exception in addCodeCB", redlog::field("error", e.what()));
          return sol::nullopt;
        }
      }
  );

  // addCodeAddrCB - Address-specific breakpoints
  w1_module.set_function(
      "addCodeAddrCB",
      [](void* vm_ptr, QBDI::rword address, int pos, sol::protected_function callback,
         sol::optional<int> priority_opt) -> sol::optional<uint32_t> {
        auto log = redlog::get_logger("w1.script_callbacks");
        QBDI::VM* vm = get_vm_instance(vm_ptr);
        if (!vm) {
          return sol::nullopt;
        }

        if (!g_callback_manager) {
          log.err("callback manager not initialized");
          return sol::nullopt;
        }

        QBDI::InstPosition position = static_cast<QBDI::InstPosition>(pos);
        int priority = priority_opt.value_or(QBDI::PRIORITY_DEFAULT);

        try {
          uint32_t callback_id = getNextCallbackId(g_callback_manager.get());
          uint32_t* persistent_callback_id = new uint32_t(callback_id);

          uint32_t qbdi_id =
              vm->addCodeAddrCB(address, position, luaInstCallbackWrapper, persistent_callback_id, priority);
          if (qbdi_id == QBDI::VMError::INVALID_EVENTID) {
            delete persistent_callback_id;
            log.err("failed to register address-specific callback with QBDI");
            return sol::nullopt;
          }

          g_callback_manager->registerInstCallback(qbdi_id, callback_id, std::move(callback));
          g_callback_manager->registerPersistentPtr(callback_id, persistent_callback_id);
          log.dbg(
              "registered addCodeAddrCB", redlog::field("callback_id", callback_id), redlog::field("address", address)
          );

          return callback_id;
        } catch (const std::exception& e) {
          log.err("exception in addCodeAddrCB", redlog::field("error", e.what()));
          return sol::nullopt;
        }
      }
  );

  // addCodeRangeCB - Range-based callbacks
  w1_module.set_function(
      "addCodeRangeCB",
      [](void* vm_ptr, QBDI::rword start, QBDI::rword end, int pos, sol::protected_function callback,
         sol::optional<int> priority_opt) -> sol::optional<uint32_t> {
        auto log = redlog::get_logger("w1.script_callbacks");
        QBDI::VM* vm = get_vm_instance(vm_ptr);
        if (!vm) {
          return sol::nullopt;
        }

        if (!g_callback_manager) {
          log.err("callback manager not initialized");
          return sol::nullopt;
        }

        QBDI::InstPosition position = static_cast<QBDI::InstPosition>(pos);
        int priority = priority_opt.value_or(QBDI::PRIORITY_DEFAULT);

        try {
          uint32_t callback_id = getNextCallbackId(g_callback_manager.get());
          uint32_t* persistent_callback_id = new uint32_t(callback_id);

          uint32_t qbdi_id =
              vm->addCodeRangeCB(start, end, position, luaInstCallbackWrapper, persistent_callback_id, priority);
          if (qbdi_id == QBDI::VMError::INVALID_EVENTID) {
            delete persistent_callback_id;
            log.err("failed to register range callback with QBDI");
            return sol::nullopt;
          }

          g_callback_manager->registerInstCallback(qbdi_id, callback_id, std::move(callback));
          g_callback_manager->registerPersistentPtr(callback_id, persistent_callback_id);
          log.dbg(
              "registered addCodeRangeCB", redlog::field("callback_id", callback_id), redlog::field("start", start),
              redlog::field("end", end)
          );

          return callback_id;
        } catch (const std::exception& e) {
          log.err("exception in addCodeRangeCB", redlog::field("error", e.what()));
          return sol::nullopt;
        }
      }
  );

  // addMnemonicCB - Instruction type callbacks
  w1_module.set_function(
      "addMnemonicCB",
      [](void* vm_ptr, const std::string& mnemonic, int pos, sol::protected_function callback,
         sol::optional<int> priority_opt) -> sol::optional<uint32_t> {
        auto log = redlog::get_logger("w1.script_callbacks");
        QBDI::VM* vm = get_vm_instance(vm_ptr);
        if (!vm) {
          return sol::nullopt;
        }

        if (!g_callback_manager) {
          log.err("callback manager not initialized");
          return sol::nullopt;
        }

        QBDI::InstPosition position = static_cast<QBDI::InstPosition>(pos);
        int priority = priority_opt.value_or(QBDI::PRIORITY_DEFAULT);

        try {
          uint32_t callback_id = getNextCallbackId(g_callback_manager.get());
          uint32_t* persistent_callback_id = new uint32_t(callback_id);

          uint32_t qbdi_id =
              vm->addMnemonicCB(mnemonic.c_str(), position, luaInstCallbackWrapper, persistent_callback_id, priority);
          if (qbdi_id == QBDI::VMError::INVALID_EVENTID) {
            delete persistent_callback_id;
            log.err("failed to register mnemonic callback with QBDI", redlog::field("mnemonic", mnemonic));
            return sol::nullopt;
          }

          g_callback_manager->registerInstCallback(qbdi_id, callback_id, std::move(callback));
          g_callback_manager->registerPersistentPtr(callback_id, persistent_callback_id);
          log.dbg(
              "registered addMnemonicCB", redlog::field("callback_id", callback_id), redlog::field("mnemonic", mnemonic)
          );

          return callback_id;
        } catch (const std::exception& e) {
          log.err("exception in addMnemonicCB", redlog::field("error", e.what()));
          return sol::nullopt;
        }
      }
  );

  //------------- memory access callbacks -------------

  // addMemAccessCB - All memory access monitoring
  w1_module.set_function(
      "addMemAccessCB",
      [](void* vm_ptr, int type, sol::protected_function callback,
         sol::optional<int> priority_opt) -> sol::optional<uint32_t> {
        auto log = redlog::get_logger("w1.script_callbacks");
        QBDI::VM* vm = get_vm_instance(vm_ptr);
        if (!vm) {
          return sol::nullopt;
        }

        if (!g_callback_manager) {
          log.err("callback manager not initialized");
          return sol::nullopt;
        }

        QBDI::MemoryAccessType access_type = static_cast<QBDI::MemoryAccessType>(type);
        int priority = priority_opt.value_or(QBDI::PRIORITY_DEFAULT);

        try {
          uint32_t callback_id = getNextCallbackId(g_callback_manager.get());
          uint32_t* persistent_callback_id = new uint32_t(callback_id);

          uint32_t qbdi_id = vm->addMemAccessCB(access_type, luaInstCallbackWrapper, persistent_callback_id, priority);
          if (qbdi_id == QBDI::VMError::INVALID_EVENTID) {
            delete persistent_callback_id;
            log.err("failed to register memory access callback with QBDI");
            return sol::nullopt;
          }

          g_callback_manager->registerInstCallback(qbdi_id, callback_id, std::move(callback));
          g_callback_manager->registerPersistentPtr(callback_id, persistent_callback_id);
          log.dbg("registered addMemAccessCB", redlog::field("callback_id", callback_id), redlog::field("type", type));

          return callback_id;
        } catch (const std::exception& e) {
          log.err("exception in addMemAccessCB", redlog::field("error", e.what()));
          return sol::nullopt;
        }
      }
  );

  // addMemAddrCB - Specific address watchpoints
  w1_module.set_function(
      "addMemAddrCB",
      [](void* vm_ptr, QBDI::rword address, int type, sol::protected_function callback) -> sol::optional<uint32_t> {
        auto log = redlog::get_logger("w1.script_callbacks");
        QBDI::VM* vm = get_vm_instance(vm_ptr);
        if (!vm) {
          return sol::nullopt;
        }

        if (!g_callback_manager) {
          log.err("callback manager not initialized");
          return sol::nullopt;
        }

        QBDI::MemoryAccessType access_type = static_cast<QBDI::MemoryAccessType>(type);

        try {
          uint32_t callback_id = getNextCallbackId(g_callback_manager.get());
          uint32_t* persistent_callback_id = new uint32_t(callback_id);

          uint32_t qbdi_id = vm->addMemAddrCB(address, access_type, luaInstCallbackWrapper, persistent_callback_id);
          if (qbdi_id == QBDI::VMError::INVALID_EVENTID) {
            delete persistent_callback_id;
            log.err("failed to register memory address callback with QBDI");
            return sol::nullopt;
          }

          g_callback_manager->registerInstCallback(qbdi_id, callback_id, std::move(callback));
          g_callback_manager->registerPersistentPtr(callback_id, persistent_callback_id);
          log.dbg(
              "registered addMemAddrCB", redlog::field("callback_id", callback_id), redlog::field("address", address)
          );

          return callback_id;
        } catch (const std::exception& e) {
          log.err("exception in addMemAddrCB", redlog::field("error", e.what()));
          return sol::nullopt;
        }
      }
  );

  // addMemRangeCB - Memory range monitoring
  w1_module.set_function(
      "addMemRangeCB",
      [](void* vm_ptr, QBDI::rword start, QBDI::rword end, int type,
         sol::protected_function callback) -> sol::optional<uint32_t> {
        auto log = redlog::get_logger("w1.script_callbacks");
        QBDI::VM* vm = get_vm_instance(vm_ptr);
        if (!vm) {
          return sol::nullopt;
        }

        if (!g_callback_manager) {
          log.err("callback manager not initialized");
          return sol::nullopt;
        }

        QBDI::MemoryAccessType access_type = static_cast<QBDI::MemoryAccessType>(type);

        try {
          uint32_t callback_id = getNextCallbackId(g_callback_manager.get());
          uint32_t* persistent_callback_id = new uint32_t(callback_id);

          uint32_t qbdi_id = vm->addMemRangeCB(start, end, access_type, luaInstCallbackWrapper, persistent_callback_id);
          if (qbdi_id == QBDI::VMError::INVALID_EVENTID) {
            delete persistent_callback_id;
            log.err("failed to register memory range callback with QBDI");
            return sol::nullopt;
          }

          g_callback_manager->registerInstCallback(qbdi_id, callback_id, std::move(callback));
          g_callback_manager->registerPersistentPtr(callback_id, persistent_callback_id);
          log.dbg(
              "registered addMemRangeCB", redlog::field("callback_id", callback_id), redlog::field("start", start),
              redlog::field("end", end)
          );

          return callback_id;
        } catch (const std::exception& e) {
          log.err("exception in addMemRangeCB", redlog::field("error", e.what()));
          return sol::nullopt;
        }
      }
  );

  //------------- vm event callbacks -------------

  // addVMEventCB - Control flow events
  w1_module.set_function(
      "addVMEventCB", [](void* vm_ptr, int mask, sol::protected_function callback) -> sol::optional<uint32_t> {
        auto log = redlog::get_logger("w1.script_callbacks");
        QBDI::VM* vm = get_vm_instance(vm_ptr);
        if (!vm) {
          return sol::nullopt;
        }

        if (!g_callback_manager) {
          log.err("callback manager not initialized");
          return sol::nullopt;
        }

        QBDI::VMEvent event_mask = static_cast<QBDI::VMEvent>(mask);

        try {
          uint32_t callback_id = getNextCallbackId(g_callback_manager.get());
          uint32_t* persistent_callback_id = new uint32_t(callback_id);

          uint32_t qbdi_id = vm->addVMEventCB(event_mask, luaVMCallbackWrapper, persistent_callback_id);
          if (qbdi_id == QBDI::VMError::INVALID_EVENTID) {
            delete persistent_callback_id;
            log.err("failed to register VM event callback with QBDI");
            return sol::nullopt;
          }

          g_callback_manager->registerVMCallback(qbdi_id, callback_id, std::move(callback));
          g_callback_manager->registerPersistentPtr(callback_id, persistent_callback_id);
          log.dbg("registered addVMEventCB", redlog::field("callback_id", callback_id), redlog::field("mask", mask));

          return callback_id;
        } catch (const std::exception& e) {
          log.err("exception in addVMEventCB", redlog::field("error", e.what()));
          return sol::nullopt;
        }
      }
  );

  //------------- instrumentation rule callbacks -------------

  // addInstrRule - Custom instrumentation rules
  w1_module.set_function(
      "addInstrRule", [](void* vm_ptr, sol::protected_function callback, int analysis_type) -> sol::optional<uint32_t> {
        auto log = redlog::get_logger("w1.script_callbacks");
        QBDI::VM* vm = get_vm_instance(vm_ptr);
        if (!vm) {
          return sol::nullopt;
        }

        if (!g_callback_manager) {
          log.err("callback manager not initialized");
          return sol::nullopt;
        }

        QBDI::AnalysisType type = static_cast<QBDI::AnalysisType>(analysis_type);

        try {
          uint32_t callback_id = getNextCallbackId(g_callback_manager.get());
          uint32_t* persistent_callback_id = new uint32_t(callback_id);

          uint32_t qbdi_id = vm->addInstrRule(luaInstrRuleCallbackWrapper, type, persistent_callback_id);
          if (qbdi_id == QBDI::VMError::INVALID_EVENTID) {
            delete persistent_callback_id;
            log.err("failed to register instrumentation rule callback with QBDI");
            return sol::nullopt;
          }

          g_callback_manager->registerInstrRuleCallback(qbdi_id, callback_id, std::move(callback));
          g_callback_manager->registerPersistentPtr(callback_id, persistent_callback_id);
          log.dbg(
              "registered addInstrRule", redlog::field("callback_id", callback_id),
              redlog::field("analysis_type", analysis_type)
          );

          return callback_id;
        } catch (const std::exception& e) {
          log.err("exception in addInstrRule", redlog::field("error", e.what()));
          return sol::nullopt;
        }
      }
  );

  //------------- callback management -------------

  // deleteInstrumentation - Remove specific callback
  w1_module.set_function("deleteInstrumentation", [](void* vm_ptr, uint32_t callback_id) -> bool {
    auto log = redlog::get_logger("w1.script_callbacks");
    QBDI::VM* vm = get_vm_instance(vm_ptr);
    if (!vm) {
      return false;
    }

    if (!g_callback_manager) {
      log.err("callback manager not initialized");
      return false;
    }

    try {
      // find the QBDI ID for this callback
      auto it = g_callback_manager->callback_id_to_qbdi_id_.find(callback_id);
      if (it == g_callback_manager->callback_id_to_qbdi_id_.end()) {
        log.wrn("callback ID not found", redlog::field("callback_id", callback_id));
        return false;
      }

      uint32_t qbdi_id = it->second;
      bool success = vm->deleteInstrumentation(qbdi_id);

      if (success) {
        // memory cleanup is handled by removeCallback() which deletes the persistent pointer
        g_callback_manager->removeCallback(callback_id);
        log.dbg(
            "deleted instrumentation", redlog::field("callback_id", callback_id), redlog::field("qbdi_id", qbdi_id)
        );
      } else {
        log.err("failed to delete QBDI instrumentation", redlog::field("qbdi_id", qbdi_id));
      }

      return success;
    } catch (const std::exception& e) {
      log.err("exception in deleteInstrumentation", redlog::field("error", e.what()));
      return false;
    }
  });

  // deleteAllInstrumentations - Remove all callbacks
  w1_module.set_function("deleteAllInstrumentations", [](void* vm_ptr) -> bool {
    auto log = redlog::get_logger("w1.script_callbacks");
    QBDI::VM* vm = get_vm_instance(vm_ptr);
    if (!vm) {
      return false;
    }

    if (!g_callback_manager) {
      log.err("callback manager not initialized");
      return false;
    }

    try {
      vm->deleteAllInstrumentations();
      g_callback_manager->removeAllCallbacks();
      log.inf("deleted all instrumentations");
      return true;
    } catch (const std::exception& e) {
      log.err("exception in deleteAllInstrumentations", redlog::field("error", e.what()));
      return false;
    }
  });

  //------------- callback introspection -------------

  // getActiveCallbackCount - Get count of active callbacks
  w1_module.set_function("getActiveCallbackCount", []() -> int {
    if (!g_callback_manager) {
      return 0;
    }
    return g_callback_manager->inst_callbacks_.size() + g_callback_manager->vm_callbacks_.size() +
           g_callback_manager->instr_rule_callbacks_.size();
  });

  // getCallbackInfo - Get information about active callbacks
  w1_module.set_function("getCallbackInfo", [&w1_module]() -> sol::table {
    sol::state_view lua(w1_module.lua_state());
    sol::table info = lua.create_table();

    if (!g_callback_manager) {
      info["instruction_callbacks"] = 0;
      info["vm_callbacks"] = 0;
      info["instr_rule_callbacks"] = 0;
      info["total"] = 0;
      return info;
    }

    info["instruction_callbacks"] = g_callback_manager->inst_callbacks_.size();
    info["vm_callbacks"] = g_callback_manager->vm_callbacks_.size();
    info["instr_rule_callbacks"] = g_callback_manager->instr_rule_callbacks_.size();
    info["total"] = g_callback_manager->inst_callbacks_.size() + g_callback_manager->vm_callbacks_.size() +
                    g_callback_manager->instr_rule_callbacks_.size();
    return info;
  });

  //------------- memory access utilities -------------

  // recordMemoryAccess - Enable automatic memory logging
  w1_module.set_function("recordMemoryAccess", [](void* vm_ptr, int type) -> bool {
    auto log = redlog::get_logger("w1.script_callbacks");
    QBDI::VM* vm = get_vm_instance(vm_ptr);
    if (!vm) {
      return false;
    }

    QBDI::MemoryAccessType access_type = static_cast<QBDI::MemoryAccessType>(type);

    try {
      bool success = vm->recordMemoryAccess(access_type);
      if (success) {
        log.inf("memory recording enabled", redlog::field("type", type));
      } else {
        log.wrn("memory recording not supported or failed to enable");
      }
      return success;
    } catch (const std::exception& e) {
      log.err("exception in recordMemoryAccess", redlog::field("error", e.what()));
      return false;
    }
  });

  logger.dbg("callback system setup complete");
}

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/callback_system.hpp`:

```hpp
/**
 * @file callback_system.hpp
 * @brief Comprehensive callback system bindings for w1script
 *
 * This module implements the bridge between QBDI's C++ callback system and Lua
 * functions, enabling powerful instrumentation capabilities. Supports instruction,
 * memory access, and VM event callbacks with proper parameter conversion.
 *
 * @author w1tn3ss Development Team
 * @date 2025
 */

#pragma once

#include <sol/sol.hpp>
#include <QBDI.h>
#include <memory>
#include <unordered_map>

namespace w1::tracers::script::bindings {

// forward declarations
class LuaCallbackManager;

// lua callback wrapper types
struct LuaInstCallback {
  sol::protected_function func;
  std::shared_ptr<LuaCallbackManager> manager;
  uint32_t callback_id;

  LuaInstCallback(sol::protected_function f, std::shared_ptr<LuaCallbackManager> mgr, uint32_t id)
      : func(std::move(f)), manager(mgr), callback_id(id) {}
};

struct LuaVMCallback {
  sol::protected_function func;
  std::shared_ptr<LuaCallbackManager> manager;
  uint32_t callback_id;

  LuaVMCallback(sol::protected_function f, std::shared_ptr<LuaCallbackManager> mgr, uint32_t id)
      : func(std::move(f)), manager(mgr), callback_id(id) {}
};

struct LuaInstrRuleCallback {
  sol::protected_function func;
  std::shared_ptr<LuaCallbackManager> manager;
  uint32_t callback_id;

  LuaInstrRuleCallback(sol::protected_function f, std::shared_ptr<LuaCallbackManager> mgr, uint32_t id)
      : func(std::move(f)), manager(mgr), callback_id(id) {}
};

// callback manager class to handle Lua callback lifecycle
class LuaCallbackManager : public std::enable_shared_from_this<LuaCallbackManager> {
public:
  LuaCallbackManager() = default;
  ~LuaCallbackManager() {
    // ensure all persistent pointers are cleaned up
    removeAllCallbacks();
  }

  // store and manage callback references
  void registerInstCallback(uint32_t qbdi_id, uint32_t callback_id, sol::protected_function func);
  void registerVMCallback(uint32_t qbdi_id, uint32_t callback_id, sol::protected_function func);
  void registerInstrRuleCallback(uint32_t qbdi_id, uint32_t callback_id, sol::protected_function func);

  // track persistent pointer for memory management
  void registerPersistentPtr(uint32_t callback_id, uint32_t* ptr);

  // remove callbacks
  bool removeCallback(uint32_t callback_id);
  void removeAllCallbacks();

  // get callback data
  LuaInstCallback* getInstCallback(uint32_t callback_id);
  LuaVMCallback* getVMCallback(uint32_t callback_id);
  LuaInstrRuleCallback* getInstrRuleCallback(uint32_t callback_id);

  // public access to callback ID mapping for deletion operations
  std::unordered_map<uint32_t, uint32_t> callback_id_to_qbdi_id_; // our callback ID -> QBDI ID

  // public access for introspection (debugging)
  std::unordered_map<uint32_t, std::unique_ptr<LuaInstCallback>> inst_callbacks_;
  std::unordered_map<uint32_t, std::unique_ptr<LuaVMCallback>> vm_callbacks_;
  std::unordered_map<uint32_t, std::unique_ptr<LuaInstrRuleCallback>> instr_rule_callbacks_;

private:
  uint32_t next_callback_id_ = 1;

  // track persistent callback ID pointers for memory management
  std::unordered_map<uint32_t, uint32_t*> callback_id_to_persistent_ptr_;

  friend uint32_t getNextCallbackId(LuaCallbackManager* mgr);
};

// helper functions
uint32_t getNextCallbackId(LuaCallbackManager* mgr);
QBDI::VM* get_vm_instance(void* vm_ptr);

// C++ callback wrappers that call into Lua
QBDI::VMAction luaInstCallbackWrapper(QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr, void* data);
QBDI::VMAction luaVMCallbackWrapper(
    QBDI::VMInstanceRef vm, const QBDI::VMState* vmState, QBDI::GPRState* gpr, QBDI::FPRState* fpr, void* data
);
std::vector<QBDI::InstrRuleDataCBK> luaInstrRuleCallbackWrapper(
    QBDI::VMInstanceRef vm, const QBDI::InstAnalysis* analysis, void* data
);

// global callback manager instance
extern std::shared_ptr<LuaCallbackManager> g_callback_manager;

/**
 * @brief Setup callback system functions for Lua bindings
 *
 * This module provides the comprehensive callback registration system for QBDI,
 * including:
 * - Instruction callbacks (addCodeCB, addCodeAddrCB, addCodeRangeCB, addMnemonicCB)
 * - Memory access callbacks (addMemAccessCB, addMemAddrCB, addMemRangeCB)
 * - VM event callbacks (addVMEventCB)
 * - Instrumentation rule callbacks (addInstrRule)
 * - Callback management (deleteInstrumentation, deleteAllInstrumentations)
 * - Memory recording control (recordMemoryAccess)
 *
 * All callback functions return optional uint32_t callback IDs that can be used
 * for callback management and removal.
 *
 * @param lua The Sol2 Lua state to register bindings with
 * @param w1_module The w1 module table to add bindings to
 */
void setup_callback_system(sol::state& lua, sol::table& w1_module);

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/calling_convention.cpp`:

```cpp
#include "calling_convention.hpp"
#include <w1tn3ss/abi/calling_convention_factory.hpp>
#include <w1tn3ss/abi/calling_convention_base.hpp>
#include <redlog.hpp>
#include <QBDI.h>

namespace w1::tracers::script::bindings {

void setup_calling_convention(sol::state& lua, sol::table& w1_module) {
  auto logger = redlog::get_logger("w1.script_bindings");
  logger.dbg("setting up calling convention functions");

  // important note about calling conventions:
  // - the default convention returned by create_default_calling_convention() is the platform abi
  // - this is correct for system api calls (libc, windows api, etc.)
  // - internal functions may use different conventions:
  //   * static functions often use optimized/custom conventions
  //   * c++ member functions use thiscall on x86 windows
  //   * compiler optimizations may change conventions
  // - when hooking internal functions, you may need to use direct register access
  // - when hooking known system apis, the default convention should work

  // get function arguments using calling convention
  // this is the main function that extracts arguments based on platform abi
  w1_module.set_function(
      "get_args", [&lua](void* vm_ptr, QBDI::GPRState* gpr, QBDI::FPRState* fpr, size_t count) -> sol::table {
        auto log = redlog::get_logger("w1.script_bindings");
        QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);

        // get default calling convention for platform
        auto cc = w1::abi::create_default_calling_convention();
        if (!cc) {
          log.err("failed to create default calling convention");
          return sol::nil;
        }

        // create extraction context
        w1::abi::calling_convention_base::extraction_context ctx;
        ctx.gpr = gpr;
        ctx.fpr = fpr;

        // stack reading lambda
        ctx.read_stack = [vm, gpr, cc](uint64_t offset) -> uint64_t {
          uint64_t sp = cc->get_stack_pointer(gpr);
          uint64_t addr = sp + offset;
          uint64_t value = 0;

          // try to read from stack
          try {
            std::memcpy(&value, reinterpret_cast<const void*>(addr), sizeof(uint64_t));
          } catch (...) {
            // stack read failed
          }

          return value;
        };

        // extract integer arguments
        std::vector<uint64_t> args = cc->extract_integer_args(ctx, count);

        // convert to lua table
        sol::state_view lua_view = lua.lua_state();
        sol::table result = lua_view.create_table();

        for (size_t i = 0; i < args.size(); i++) {
          result[i + 1] = args[i]; // lua arrays start at 1
        }

        return result;
      }
  );

  // get function arguments with types
  w1_module.set_function(
      "get_typed_args",
      [&lua](void* vm_ptr, QBDI::GPRState* gpr, QBDI::FPRState* fpr, sol::table arg_types) -> sol::table {
        auto log = redlog::get_logger("w1.script_bindings");
        QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);

        // get default calling convention
        auto cc = w1::abi::create_default_calling_convention();
        if (!cc) {
          log.err("failed to create default calling convention");
          return sol::nil;
        }

        // convert lua arg types to c++ vector
        std::vector<w1::abi::calling_convention_base::arg_type> types;
        for (size_t i = 1; i <= arg_types.size(); i++) {
          sol::optional<std::string> type_str = arg_types[i];
          if (type_str) {
            w1::abi::calling_convention_base::arg_type arg_type = w1::abi::calling_convention_base::arg_type::INTEGER;

            if (*type_str == "int" || *type_str == "integer") {
              arg_type = w1::abi::calling_convention_base::arg_type::INTEGER;
            } else if (*type_str == "ptr" || *type_str == "pointer") {
              arg_type = w1::abi::calling_convention_base::arg_type::POINTER;
            } else if (*type_str == "float") {
              arg_type = w1::abi::calling_convention_base::arg_type::FLOAT;
            } else if (*type_str == "double") {
              arg_type = w1::abi::calling_convention_base::arg_type::DOUBLE;
            }

            types.push_back(arg_type);
          }
        }

        // create extraction context
        w1::abi::calling_convention_base::extraction_context ctx;
        ctx.gpr = gpr;
        ctx.fpr = fpr;
        ctx.read_stack = [vm, gpr, cc](uint64_t offset) -> uint64_t {
          uint64_t sp = cc->get_stack_pointer(gpr);
          uint64_t addr = sp + offset;
          uint64_t value = 0;

          try {
            std::memcpy(&value, reinterpret_cast<const void*>(addr), sizeof(uint64_t));
          } catch (...) {
            // stack read failed
          }

          return value;
        };

        // extract typed arguments
        std::vector<w1::abi::calling_convention_base::typed_arg> args = cc->extract_typed_args(ctx, types);

        // convert to lua table
        sol::state_view lua_view = lua.lua_state();
        sol::table result = lua_view.create_table();

        for (size_t i = 0; i < args.size(); i++) {
          sol::table arg_table = lua_view.create_table();

          // add type info
          switch (args[i].type) {
          case w1::abi::calling_convention_base::arg_type::INTEGER:
            arg_table["type"] = "integer";
            arg_table["value"] = args[i].value.integer;
            break;
          case w1::abi::calling_convention_base::arg_type::POINTER:
            arg_table["type"] = "pointer";
            arg_table["value"] = args[i].value.integer;
            break;
          case w1::abi::calling_convention_base::arg_type::FLOAT:
            arg_table["type"] = "float";
            arg_table["value"] = args[i].value.f32;
            break;
          case w1::abi::calling_convention_base::arg_type::DOUBLE:
            arg_table["type"] = "double";
            arg_table["value"] = args[i].value.f64;
            break;
          default:
            arg_table["type"] = "unknown";
            arg_table["value"] = args[i].value.integer;
            break;
          }

          arg_table["from_stack"] = args[i].from_stack;
          if (args[i].from_stack) {
            arg_table["stack_offset"] = args[i].stack_offset;
          }

          result[i + 1] = arg_table;
        }

        return result;
      }
  );

  // get return value
  w1_module.set_function("get_return_value", [](QBDI::GPRState* gpr) -> uint64_t {
    auto cc = w1::abi::create_default_calling_convention();
    if (!cc) {
      return 0;
    }

    return cc->get_integer_return(gpr);
  });

  // get float return value
  w1_module.set_function("get_float_return", [](QBDI::FPRState* fpr) -> double {
    auto cc = w1::abi::create_default_calling_convention();
    if (!cc) {
      return 0.0;
    }

    return cc->get_float_return(fpr);
  });

  // get calling convention info with optional convention name
  w1_module.set_function(
      "get_calling_convention_info", [&lua](sol::optional<std::string> convention_name) -> sol::table {
        w1::abi::calling_convention_ptr cc;

        if (convention_name) {
          // try to create specific convention
          try {
            cc = w1::abi::calling_convention_factory::instance().create_by_name(*convention_name);
          } catch (...) {
            // fall back to default
            cc = w1::abi::create_default_calling_convention();
          }
        } else {
          cc = w1::abi::create_default_calling_convention();
        }

        if (!cc) {
          return sol::nil;
        }

        sol::state_view lua_view = lua.lua_state();
        sol::table info = lua_view.create_table();

        info["id"] = w1::abi::to_string(cc->get_id());
        info["name"] = cc->get_name();
        info["description"] = cc->get_description();
        info["architecture"] = w1::abi::to_string(cc->get_architecture());
        info["is_native"] = cc->is_native_for_current_platform();

        // register info
        auto reg_info = cc->get_register_info();

        sol::table arg_regs = lua_view.create_table();
        for (size_t i = 0; i < reg_info.argument_registers.size(); i++) {
          arg_regs[i + 1] = reg_info.argument_registers[i];
        }
        info["argument_registers"] = arg_regs;

        info["return_register"] = reg_info.return_register;
        info["stack_alignment"] = cc->get_stack_alignment();

        // stack cleanup policy
        switch (cc->get_stack_cleanup()) {
        case w1::abi::calling_convention_base::stack_cleanup::CALLER:
          info["stack_cleanup"] = "caller";
          break;
        case w1::abi::calling_convention_base::stack_cleanup::CALLEE:
          info["stack_cleanup"] = "callee";
          break;
        case w1::abi::calling_convention_base::stack_cleanup::HYBRID:
          info["stack_cleanup"] = "hybrid";
          break;
        }

        return info;
      }
  );

  // convenience function for first few arguments
  w1_module.set_function(
      "get_arg", [](void* vm_ptr, QBDI::GPRState* gpr, QBDI::FPRState* fpr, size_t index) -> sol::optional<uint64_t> {
        auto cc = w1::abi::create_default_calling_convention();
        if (!cc) {
          return sol::nullopt;
        }

        // create extraction context
        w1::abi::calling_convention_base::extraction_context ctx;
        ctx.gpr = gpr;
        ctx.fpr = fpr;
        ctx.read_stack = [](uint64_t) { return 0ULL; }; // simplified for now

        // extract arguments up to requested index
        std::vector<uint64_t> args = cc->extract_integer_args(ctx, index);

        if (index > 0 && index <= args.size()) {
          return args[index - 1]; // convert to 0-based
        }

        return sol::nullopt;
      }
  );

  logger.dbg("calling convention functions registered");
}

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/calling_convention.hpp`:

```hpp
#pragma once

#include <sol/sol.hpp>

namespace w1::tracers::script::bindings {

void setup_calling_convention(sol::state& lua, sol::table& w1_module);

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/core_types.cpp`:

```cpp
#include "core_types.hpp"
#include <redlog.hpp>

namespace w1::tracers::script::bindings {

void setup_core_types(sol::state& lua, sol::table& w1_module) {
  auto logger = redlog::get_logger("w1.script_bindings");
  logger.dbg("setting up core qbdi types and enums");

  // vmAction enum - controls VM execution flow
  // used in callbacks to determine how the VM should proceed after instruction execution
  w1_module.new_enum(
      "VMAction", "CONTINUE", QBDI::VMAction::CONTINUE, // Continue normal execution
      "SKIP_INST", QBDI::VMAction::SKIP_INST,           // Skip current instruction
      "SKIP_PATCH", QBDI::VMAction::SKIP_PATCH,         // Skip current patch
      "BREAK_TO_VM", QBDI::VMAction::BREAK_TO_VM,       // Break back to VM
      "STOP", QBDI::VMAction::STOP                      // Stop VM execution
  );

  // InstAnalysis usertype - provides detailed instruction analysis information
  // this contains all the metadata about the currently executing instruction
  lua.new_usertype<QBDI::InstAnalysis>(
      "InstAnalysis",

      // basic instruction properties
      "address", &QBDI::InstAnalysis::address,         // Instruction address
      "instSize", &QBDI::InstAnalysis::instSize,       // Instruction size in bytes
      "mnemonic", &QBDI::InstAnalysis::mnemonic,       // Instruction mnemonic
      "disassembly", &QBDI::InstAnalysis::disassembly, // Full disassembly string

      // control flow analysis
      "affectControlFlow", &QBDI::InstAnalysis::affectControlFlow, // Does instruction affect control flow?
      "isBranch", &QBDI::InstAnalysis::isBranch,                   // Is it a branch instruction?
      "isCall", &QBDI::InstAnalysis::isCall,                       // Is it a function call?
      "isReturn", &QBDI::InstAnalysis::isReturn,                   // Is it a return instruction?
      "isCompare", &QBDI::InstAnalysis::isCompare,                 // Is it a comparison instruction?
      "isPredicable", &QBDI::InstAnalysis::isPredicable,           // Can it be predicated?

      // memory access properties
      "mayLoad", &QBDI::InstAnalysis::mayLoad,     // Might load from memory?
      "mayStore", &QBDI::InstAnalysis::mayStore,   // Might store to memory?
      "loadSize", &QBDI::InstAnalysis::loadSize,   // Size of memory load (if any)
      "storeSize", &QBDI::InstAnalysis::storeSize, // Size of memory store (if any)

      // conditional execution
      "condition", &QBDI::InstAnalysis::condition // Execution condition (if any)
  );

  // vmEvent enum - VM state change events
  // used to trigger callbacks at specific execution points
  w1_module.new_enum(
      "VMEvent", "NO_EVENT", QBDI::VMEvent::NO_EVENT,              // No event
      "BASIC_BLOCK_ENTRY", QBDI::VMEvent::BASIC_BLOCK_ENTRY,       // Basic block entry
      "BASIC_BLOCK_EXIT", QBDI::VMEvent::BASIC_BLOCK_EXIT,         // Basic block exit
      "BASIC_BLOCK_NEW", QBDI::VMEvent::BASIC_BLOCK_NEW,           // New basic block
      "SEQUENCE_ENTRY", QBDI::VMEvent::SEQUENCE_ENTRY,             // Sequence entry
      "SEQUENCE_EXIT", QBDI::VMEvent::SEQUENCE_EXIT,               // Sequence exit
      "EXEC_TRANSFER_CALL", QBDI::VMEvent::EXEC_TRANSFER_CALL,     // Execution transfer call
      "EXEC_TRANSFER_RETURN", QBDI::VMEvent::EXEC_TRANSFER_RETURN, // Execution transfer return
      "SYSCALL_ENTRY", QBDI::VMEvent::SYSCALL_ENTRY,               // System call entry
      "SYSCALL_EXIT", QBDI::VMEvent::SYSCALL_EXIT,                 // System call exit
      "SIGNAL", QBDI::VMEvent::SIGNAL                              // Signal event
  );

  // MemoryAccessType enum - types of memory access operations
  // used to filter memory access callbacks by operation type
  w1_module.new_enum(
      "MemoryAccessType", "MEMORY_READ", QBDI::MemoryAccessType::MEMORY_READ, // Memory read operation
      "MEMORY_WRITE", QBDI::MemoryAccessType::MEMORY_WRITE,                   // Memory write operation
      "MEMORY_READ_WRITE", QBDI::MemoryAccessType::MEMORY_READ_WRITE          // Memory read/write operation
  );

  // MemoryAccessFlags enum - flags describing memory access properties
  // provides additional information about memory access operations
  w1_module.new_enum(
      "MemoryAccessFlags", "MEMORY_NO_FLAGS", QBDI::MemoryAccessFlags::MEMORY_NO_FLAGS, // No special flags
      "MEMORY_UNKNOWN_SIZE", QBDI::MemoryAccessFlags::MEMORY_UNKNOWN_SIZE,              // Size is unknown
      "MEMORY_MINIMUM_SIZE", QBDI::MemoryAccessFlags::MEMORY_MINIMUM_SIZE,              // Given size is minimum
      "MEMORY_UNKNOWN_VALUE", QBDI::MemoryAccessFlags::MEMORY_UNKNOWN_VALUE             // Value is unknown
  );

  // InstPosition enum - position relative to instruction execution
  // used to specify when callbacks are triggered relative to instruction
  w1_module.new_enum(
      "InstPosition", "PREINST", QBDI::InstPosition::PREINST, // Before instruction execution
      "POSTINST", QBDI::InstPosition::POSTINST                // After instruction execution
  );

  // AnalysisType enum - types of instruction analysis available
  // used to specify what analysis information should be computed
  w1_module.new_enum(
      "AnalysisType", "ANALYSIS_INSTRUCTION", QBDI::AnalysisType::ANALYSIS_INSTRUCTION, // Basic instruction info
      "ANALYSIS_DISASSEMBLY", QBDI::AnalysisType::ANALYSIS_DISASSEMBLY,                 // Disassembly text
      "ANALYSIS_OPERANDS", QBDI::AnalysisType::ANALYSIS_OPERANDS,                       // Operand analysis
      "ANALYSIS_SYMBOL", QBDI::AnalysisType::ANALYSIS_SYMBOL,                           // Symbol information
      "ANALYSIS_JIT", QBDI::AnalysisType::ANALYSIS_JIT                                  // jit patch information
  );

  // ConditionType enum - instruction condition types
  // used to describe conditional execution properties of instructions
  w1_module.new_enum(
      "ConditionType", "CONDITION_NONE", QBDI::ConditionType::CONDITION_NONE, // Unconditional
      "CONDITION_ALWAYS", QBDI::ConditionType::CONDITION_ALWAYS,              // Always true
      "CONDITION_NEVER", QBDI::ConditionType::CONDITION_NEVER,                // Always false
      "CONDITION_EQUALS", QBDI::ConditionType::CONDITION_EQUALS,              // Equals (==)
      "CONDITION_NOT_EQUALS", QBDI::ConditionType::CONDITION_NOT_EQUALS,      // Not equals (!=)
      "CONDITION_ABOVE", QBDI::ConditionType::CONDITION_ABOVE,                // Above (> unsigned)
      "CONDITION_BELOW_EQUALS", QBDI::ConditionType::CONDITION_BELOW_EQUALS,  // Below/equals (<= unsigned)
      "CONDITION_ABOVE_EQUALS", QBDI::ConditionType::CONDITION_ABOVE_EQUALS,  // Above/equals (>= unsigned)
      "CONDITION_BELOW", QBDI::ConditionType::CONDITION_BELOW,                // Below (< unsigned)
      "CONDITION_GREAT", QBDI::ConditionType::CONDITION_GREAT,                // Greater (> signed)
      "CONDITION_LESS_EQUALS", QBDI::ConditionType::CONDITION_LESS_EQUALS,    // Less/equals (<= signed)
      "CONDITION_GREAT_EQUALS", QBDI::ConditionType::CONDITION_GREAT_EQUALS,  // Greater/equals (>= signed)
      "CONDITION_LESS", QBDI::ConditionType::CONDITION_LESS,                  // Less (< signed)
      "CONDITION_EVEN", QBDI::ConditionType::CONDITION_EVEN,                  // Even
      "CONDITION_ODD", QBDI::ConditionType::CONDITION_ODD,                    // Odd
      "CONDITION_OVERFLOW", QBDI::ConditionType::CONDITION_OVERFLOW,          // Overflow
      "CONDITION_NOT_OVERFLOW", QBDI::ConditionType::CONDITION_NOT_OVERFLOW,  // Not overflow
      "CONDITION_SIGN", QBDI::ConditionType::CONDITION_SIGN,                  // Sign
      "CONDITION_NOT_SIGN", QBDI::ConditionType::CONDITION_NOT_SIGN           // Not sign
  );

  // OperandType enum - types of instruction operands
  // used to categorize operands in instruction analysis
  w1_module.new_enum(
      "OperandType", "OPERAND_INVALID", QBDI::OperandType::OPERAND_INVALID, // Invalid operand
      "OPERAND_IMM", QBDI::OperandType::OPERAND_IMM,                        // Immediate operand
      "OPERAND_GPR", QBDI::OperandType::OPERAND_GPR,                        // General purpose register
      "OPERAND_PRED", QBDI::OperandType::OPERAND_PRED,                      // Predicate operand
      "OPERAND_FPR", QBDI::OperandType::OPERAND_FPR,                        // Floating point register
      "OPERAND_SEG", QBDI::OperandType::OPERAND_SEG                         // Segment/unsupported register
  );

  // OperandFlag enum - flags describing operand properties
  // provides additional metadata about operand usage
  w1_module.new_enum(
      "OperandFlag", "OPERANDFLAG_NONE", QBDI::OperandFlag::OPERANDFLAG_NONE,          // No flags
      "OPERANDFLAG_ADDR", QBDI::OperandFlag::OPERANDFLAG_ADDR,                         // Used for address computation
      "OPERANDFLAG_PCREL", QBDI::OperandFlag::OPERANDFLAG_PCREL,                       // pc-relative value
      "OPERANDFLAG_UNDEFINED_EFFECT", QBDI::OperandFlag::OPERANDFLAG_UNDEFINED_EFFECT, // Undefined role
      "OPERANDFLAG_IMPLICIT", QBDI::OperandFlag::OPERANDFLAG_IMPLICIT                  // Implicit operand
  );

  // RegisterAccessType enum - register access patterns
  // used to describe how registers are accessed in operands
  w1_module.new_enum(
      "RegisterAccessType", "REGISTER_UNUSED", QBDI::RegisterAccessType::REGISTER_UNUSED, // Register not used
      "REGISTER_READ", QBDI::RegisterAccessType::REGISTER_READ,                           // Register read access
      "REGISTER_WRITE", QBDI::RegisterAccessType::REGISTER_WRITE,                         // Register write access
      "REGISTER_READ_WRITE", QBDI::RegisterAccessType::REGISTER_READ_WRITE                // Register read/write access
  );

  // OperandAnalysis usertype - detailed analysis of instruction operands
  // provides comprehensive information about individual operands
  lua.new_usertype<QBDI::OperandAnalysis>(
      "OperandAnalysis",

      // core operand properties
      "type", &QBDI::OperandAnalysis::type,   // Operand type (immediate, register, etc.)
      "flag", &QBDI::OperandAnalysis::flag,   // Operand flags (address, PC-relative, etc.)
      "value", &QBDI::OperandAnalysis::value, // Operand value (immediate) or register ID
      "size", &QBDI::OperandAnalysis::size,   // Operand size in bytes

      // register-specific properties
      "regOff", &QBDI::OperandAnalysis::regOff,       // Sub-register offset in bits
      "regCtxIdx", &QBDI::OperandAnalysis::regCtxIdx, // Register index in VM state
      "regName", &QBDI::OperandAnalysis::regName,     // Register name string
      "regAccess", &QBDI::OperandAnalysis::regAccess  // Register access type (r/w/rw)
  );

  // MemoryAccess usertype - describes a memory access operation
  // contains complete information about memory reads and writes
  lua.new_usertype<QBDI::MemoryAccess>(
      "MemoryAccess",

      // memory access details
      "instAddress", &QBDI::MemoryAccess::instAddress,     // Address of instruction making access
      "accessAddress", &QBDI::MemoryAccess::accessAddress, // Address of accessed memory
      "value", &QBDI::MemoryAccess::value,                 // Value read from or written to memory
      "size", &QBDI::MemoryAccess::size,                   // Size of memory access in bytes
      "type", &QBDI::MemoryAccess::type,                   // Memory access type (read/write)
      "flags", &QBDI::MemoryAccess::flags                  // Memory access flags
  );

  // vmState usertype - describes current VM execution state
  // provides context about VM events and execution boundaries
  lua.new_usertype<QBDI::VMState>(
      "VMState",

      // vm event information
      "event", &QBDI::VMState::event,                     // Event type that triggered callback
      "basicBlockStart", &QBDI::VMState::basicBlockStart, // Current basic block start address
      "basicBlockEnd", &QBDI::VMState::basicBlockEnd,     // Current basic block end address
      "sequenceStart", &QBDI::VMState::sequenceStart,     // Current sequence start address
      "sequenceEnd", &QBDI::VMState::sequenceEnd,         // Current sequence end address
      "lastSignal", &QBDI::VMState::lastSignal            // Last signal (not implemented)
  );

  // Register GPRState as a usertype so Sol2 can properly handle pointers to it
  // This is critical for hooks to work correctly
  lua.new_usertype<QBDI::GPRState>(
      "GPRState"
      // GPRState is platform-specific and has different members on each architecture
      // We don't expose the members directly, instead using w1.get_reg() functions
  );

  // Register FPRState as well for completeness
  lua.new_usertype<QBDI::FPRState>(
      "FPRState"
      // FPRState is also platform-specific
      // Access through w1.get_fpr() functions if needed
  );

  logger.dbg("core types registered successfully");
}

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/core_types.hpp`:

```hpp
/**
 * @file core_types.hpp
 * @brief Core QBDI types and enums bindings for w1script
 *
 * This module exposes essential QBDI types, enums, and structures to Lua scripts,
 * providing the foundation for dynamic binary analysis. Includes VMAction enums,
 * memory access types, analysis types, and core QBDI structures.
 *
 * @author w1tn3ss Development Team
 * @date 2025
 */

#pragma once

#include <sol/sol.hpp>
#include <QBDI.h>

namespace w1::tracers::script::bindings {

/**
 * @brief Setup core QBDI types and enums for Lua bindings
 *
 * This module contains the fundamental QBDI types and enumerations
 * that are exposed to the Lua scripting environment, including:
 * - VMAction enum for controlling VM execution flow
 * - InstAnalysis usertype for instruction analysis data
 *
 * @param lua The Sol2 Lua state to register bindings with
 * @param w1_module The w1 module table to add bindings to
 */
void setup_core_types(sol::state& lua, sol::table& w1_module);

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/hooking.cpp`:

```cpp
#include "hooking.hpp"
#include <w1tn3ss/hooking/hook_manager.hpp>
#include <redlog.hpp>
#include <sol/protected_function.hpp>

namespace w1::tracers::script::bindings {

void setup_hooking(sol::state& lua, sol::table& w1_module, std::shared_ptr<w1::hooking::hook_manager> hook_mgr) {
  auto logger = redlog::get_logger("w1.script_bindings");
  logger.dbg("setting up hook registration functions");

  // hook specific address
  w1_module.set_function(
      "hook_addr",
      [hook_mgr, &logger](QBDI::rword address, sol::protected_function handler) -> sol::optional<uint32_t> {
        if (!handler.valid()) {
          logger.err("invalid handler function provided to hook_addr");
          return sol::nullopt;
        }

        // capture the lua function in the lambda
        auto cpp_handler = [handler](
                               QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr, QBDI::rword addr
                           ) -> QBDI::VMAction {
          auto logger = redlog::get_logger("w1.script_bindings");
          try {
            // call lua handler with raw QBDI objects
            auto result = handler(vm, gpr, fpr, addr);

            if (!result.valid()) {
              sol::error err = result;
              logger.err("lua hook handler error", redlog::field("error", err.what()));
              return QBDI::VMAction::CONTINUE;
            }

            // check if handler returned a VMAction
            sol::optional<QBDI::VMAction> action = result;
            if (action) {
              return *action;
            }

            // default to continue
            return QBDI::VMAction::CONTINUE;
          } catch (const std::exception& e) {
            logger.err("exception in hook handler", redlog::field("error", e.what()));
            return QBDI::VMAction::CONTINUE;
          }
        };

        uint32_t id = hook_mgr->hook_addr(address, cpp_handler);
        if (id == 0) {
          return sol::nullopt;
        }

        return id;
      }
  );

  // hook module+offset
  w1_module.set_function(
      "hook_module",
      [hook_mgr, &logger](const std::string& module_name, QBDI::rword offset, sol::protected_function handler)
          -> sol::optional<uint32_t> {
        if (!handler.valid()) {
          logger.err("invalid handler function provided to hook_module");
          return sol::nullopt;
        }

        // capture the lua function in the lambda
        auto cpp_handler = [handler](
                               QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr, QBDI::rword addr
                           ) -> QBDI::VMAction {
          auto logger = redlog::get_logger("w1.script_bindings");
          try {
            // call lua handler with raw QBDI objects
            auto result = handler(vm, gpr, fpr, addr);

            if (!result.valid()) {
              sol::error err = result;
              logger.err("lua hook handler error", redlog::field("error", err.what()));
              return QBDI::VMAction::CONTINUE;
            }

            // check if handler returned a VMAction
            sol::optional<QBDI::VMAction> action = result;
            if (action) {
              return *action;
            }

            // default to continue
            return QBDI::VMAction::CONTINUE;
          } catch (const std::exception& e) {
            logger.err("exception in hook handler", redlog::field("error", e.what()));
            return QBDI::VMAction::CONTINUE;
          }
        };

        uint32_t id = hook_mgr->hook_module(module_name, offset, cpp_handler);
        if (id == 0) {
          return sol::nullopt;
        }

        return id;
      }
  );

  // hook address range
  w1_module.set_function(
      "hook_range",
      [hook_mgr,
       &logger](QBDI::rword start, QBDI::rword end, sol::protected_function handler) -> sol::optional<uint32_t> {
        if (!handler.valid()) {
          logger.err("invalid handler function provided to hook_range");
          return sol::nullopt;
        }

        // capture the lua function in the lambda
        auto cpp_handler = [handler](
                               QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr, QBDI::rword addr
                           ) -> QBDI::VMAction {
          auto logger = redlog::get_logger("w1.script_bindings");
          try {
            // call lua handler with raw QBDI objects
            auto result = handler(vm, gpr, fpr, addr);

            if (!result.valid()) {
              sol::error err = result;
              logger.err("lua hook handler error", redlog::field("error", err.what()));
              return QBDI::VMAction::CONTINUE;
            }

            // check if handler returned a VMAction
            sol::optional<QBDI::VMAction> action = result;
            if (action) {
              return *action;
            }

            // default to continue
            return QBDI::VMAction::CONTINUE;
          } catch (const std::exception& e) {
            logger.err("exception in hook handler", redlog::field("error", e.what()));
            return QBDI::VMAction::CONTINUE;
          }
        };

        uint32_t id = hook_mgr->hook_range(start, end, cpp_handler);
        if (id == 0) {
          return sol::nullopt;
        }

        return id;
      }
  );

  // remove specific hook
  w1_module.set_function("remove_hook", [hook_mgr, &logger](uint32_t hook_id) -> bool {
    bool result = hook_mgr->remove_hook(hook_id);
    auto logger = redlog::get_logger("w1.script_bindings");
    if (result) {
      logger.dbg("removed hook", redlog::field("id", hook_id));
    } else {
      logger.wrn("failed to remove hook", redlog::field("id", hook_id));
    }
    return result;
  });

  // remove all hooks
  w1_module.set_function("remove_all_hooks", [hook_mgr, &logger]() {
    hook_mgr->remove_all_hooks();
    logger.dbg("removed all hooks");
  });

  logger.dbg("hook registration functions registered");
}

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/hooking.hpp`:

```hpp
/**
 * @file hooking.hpp
 * @brief Hook registration bindings for w1script
 *
 * This module provides hook registration functions for Lua scripts,
 * allowing dynamic instrumentation of arbitrary addresses, modules,
 * and address ranges using QBDI callbacks.
 *
 * @author w1tn3ss Development Team
 * @date 2025
 */

#pragma once

#include <sol/sol.hpp>
#include <QBDI.h>
#include <memory>

namespace w1::hooking {
class hook_manager;
}

namespace w1::tracers::script::bindings {

/**
 * @brief Setup hook registration functions for Lua bindings
 *
 * This module provides hook registration functions:
 * - hook_addr(address, handler) - Hook specific address
 * - hook_module(module, offset, handler) - Hook module+offset
 * - hook_range(start, end, handler) - Hook address range
 * - remove_hook(id) - Remove a specific hook
 * - remove_all_hooks() - Remove all hooks
 *
 * @param lua The Sol2 Lua state to register bindings with
 * @param w1_module The w1 module table to add bindings to
 * @param hook_mgr The hook manager instance to use
 */
void setup_hooking(sol::state& lua, sol::table& w1_module, std::shared_ptr<w1::hooking::hook_manager> hook_mgr);

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/memory_access.cpp`:

```cpp
#include "memory_access.hpp"
#include <w1tn3ss/util/safe_memory.hpp>
#include <redlog.hpp>
#include <cstring>

namespace w1::tracers::script::bindings {

void setup_memory_access(sol::state& lua, sol::table& w1_module) {
  auto logger = redlog::get_logger("w1.script_bindings");
  logger.dbg("setting up safe memory access functions");

  // safe memory read
  w1_module.set_function("read_mem", [&lua](void* vm_ptr, uint64_t address, size_t size) -> sol::optional<sol::table> {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);

    auto result = w1::util::safe_memory::read_buffer(vm, address, size, size);
    if (!result) {
      return sol::nullopt;
    }

    // convert to lua table
    sol::state_view lua_view = lua.lua_state();
    sol::table data_table = lua_view.create_table();

    for (size_t i = 0; i < result->data.size(); i++) {
      data_table[i + 1] = result->data[i]; // lua arrays start at 1
    }

    return data_table;
  });

  // safe memory write
  w1_module.set_function("write_mem", [](void* vm_ptr, uint64_t address, sol::table data) -> bool {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);

    // convert lua table to vector
    std::vector<uint8_t> bytes;
    for (size_t i = 1; i <= data.size(); i++) {
      sol::optional<uint8_t> byte = data[i];
      if (byte) {
        bytes.push_back(*byte);
      }
    }

    // check if memory is writable
    if (!w1::util::safe_memory::memory_validator().check_access(
            address, bytes.size(), w1::util::memory_range_index::WRITE
        )) {
      return false;
    }

    // perform write
    std::memcpy(reinterpret_cast<void*>(address), bytes.data(), bytes.size());
    return true;
  });

  // safe string read
  w1_module.set_function(
      "read_string",
      [](void* vm_ptr, uint64_t address, sol::optional<size_t> max_length) -> sol::optional<std::string> {
        QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
        size_t max_len = max_length.value_or(256);

        auto result = w1::util::safe_memory::read_string(vm, address, max_len);
        if (!result) {
          return sol::nullopt;
        }

        return *result;
      }
  );

  // safe wide string read
  w1_module.set_function(
      "read_wstring",
      [](void* vm_ptr, uint64_t address, sol::optional<size_t> max_length) -> sol::optional<std::string> {
        QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
        size_t max_len = max_length.value_or(256);

        auto result = w1::util::safe_memory::read_wstring(vm, address, max_len);
        if (!result) {
          return sol::nullopt;
        }

        // convert wstring to string for Lua
        std::string str;
        for (wchar_t wc : *result) {
          if (wc <= 0x7F) {
            str += static_cast<char>(wc);
          } else {
            str += '?'; // simple fallback for non-ASCII
          }
        }

        return str;
      }
  );

  // convenience function to read memory as hex string
  w1_module.set_function(
      "read_mem_hex", [&lua](void* vm_ptr, uint64_t address, size_t size) -> sol::optional<std::string> {
        QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);

        auto result = w1::util::safe_memory::read_buffer(vm, address, size, size);
        if (!result) {
          return sol::nullopt;
        }

        // convert to hex string
        std::string hex;
        hex.reserve(result->data.size() * 2);
        const char* hex_chars = "0123456789abcdef";

        for (uint8_t byte : result->data) {
          hex += hex_chars[byte >> 4];
          hex += hex_chars[byte & 0xF];
        }

        return hex;
      }
  );

  // convenience function to write memory from hex string
  w1_module.set_function("write_mem_hex", [](void* vm_ptr, uint64_t address, const std::string& hex_data) -> bool {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);

    if (hex_data.length() % 2 != 0) {
      return false;
    }

    // convert hex string to bytes
    std::vector<uint8_t> bytes;
    bytes.reserve(hex_data.length() / 2);

    for (size_t i = 0; i < hex_data.length(); i += 2) {
      std::string byte_str = hex_data.substr(i, 2);
      try {
        bytes.push_back(static_cast<uint8_t>(std::stoul(byte_str, nullptr, 16)));
      } catch (...) {
        return false;
      }
    }

    // check if memory is writable
    if (!w1::util::safe_memory::memory_validator().check_access(
            address, bytes.size(), w1::util::memory_range_index::WRITE
        )) {
      return false;
    }

    // perform write
    std::memcpy(reinterpret_cast<void*>(address), bytes.data(), bytes.size());
    return true;
  });

  // read typed values
  w1_module.set_function("read_u8", [](void* vm_ptr, uint64_t address) -> sol::optional<uint8_t> {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    auto result = w1::util::safe_memory::read<uint8_t>(vm, address);
    if (result) {
      return sol::optional<uint8_t>(*result);
    }
    return sol::nullopt;
  });

  w1_module.set_function("read_u16", [](void* vm_ptr, uint64_t address) -> sol::optional<uint16_t> {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    auto result = w1::util::safe_memory::read<uint16_t>(vm, address);
    if (result) {
      return sol::optional<uint16_t>(*result);
    }
    return sol::nullopt;
  });

  w1_module.set_function("read_u32", [](void* vm_ptr, uint64_t address) -> sol::optional<uint32_t> {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    auto result = w1::util::safe_memory::read<uint32_t>(vm, address);
    if (result) {
      return sol::optional<uint32_t>(*result);
    }
    return sol::nullopt;
  });

  w1_module.set_function("read_u64", [](void* vm_ptr, uint64_t address) -> sol::optional<uint64_t> {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    auto result = w1::util::safe_memory::read<uint64_t>(vm, address);
    if (result) {
      return sol::optional<uint64_t>(*result);
    }
    return sol::nullopt;
  });

  w1_module.set_function("read_ptr", [](void* vm_ptr, uint64_t address) -> sol::optional<QBDI::rword> {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    auto result = w1::util::safe_memory::read<QBDI::rword>(vm, address);
    if (result) {
      return sol::optional<QBDI::rword>(*result);
    }
    return sol::nullopt;
  });

  logger.dbg("safe memory access functions registered");
}

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/memory_access.hpp`:

```hpp
/**
 * @file memory_access.hpp
 * @brief Safe memory read/write bindings for w1script
 *
 * This module provides safe memory access functions using the
 * safe_memory.hpp infrastructure to prevent segfaults and crashes.
 *
 * @author w1tn3ss Development Team
 * @date 2025
 */

#pragma once

#include <sol/sol.hpp>
#include <QBDI.h>

namespace w1::tracers::script::bindings {

/**
 * @brief Setup safe memory access functions for Lua bindings
 *
 * This module provides functions for safe memory access:
 * - read_mem(vm, address, size) - Read memory safely
 * - write_mem(vm, address, data) - Write memory safely
 * - read_string(vm, address, max_length) - Read null-terminated string
 * - read_wstring(vm, address, max_length) - Read wide string
 *
 * All functions use safe_memory.hpp to validate memory access
 * before performing operations.
 *
 * @param lua The Sol2 Lua state to register bindings with
 * @param w1_module The w1 module table to add bindings to
 */
void setup_memory_access(sol::state& lua, sol::table& w1_module);

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/memory_analysis.cpp`:

```cpp
#include "memory_analysis.hpp"
#include <redlog.hpp>
#include <vector>
#include <cstdio>
#include <cstring>
#include <stdexcept>
#include <sstream>
#include <iomanip>

namespace w1::tracers::script::bindings {

void setup_memory_analysis(sol::state& lua, sol::table& w1_module) {
  auto logger = redlog::get_logger("w1.script_bindings");
  logger.dbg("setting up memory access and analysis functions");

  // get memory accesses for the current instruction
  // returns a Lua table containing detailed information about all memory accesses
  // performed by the current instruction
  w1_module.set_function("get_memory_accesses", [&lua](void* vm_ptr) -> sol::table {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    std::vector<QBDI::MemoryAccess> accesses = vm->getInstMemoryAccess();

    sol::state_view lua_view = lua.lua_state();
    sol::table result = lua_view.create_table();

    for (size_t i = 0; i < accesses.size(); i++) {
      const auto& access = accesses[i];
      sol::table access_table = lua_view.create_table();

      // memory access details
      access_table["address"] = access.accessAddress;    // Address being accessed
      access_table["value"] = access.value;              // Value read/written
      access_table["size"] = access.size;                // Size of access in bytes
      access_table["inst_address"] = access.instAddress; // Address of instruction performing access

      // access type flags
      access_table["is_read"] = (access.type & QBDI::MEMORY_READ) != 0;
      access_table["is_write"] = (access.type & QBDI::MEMORY_WRITE) != 0;

      // additional access information
      access_table["flags"] = access.flags; // Additional flags

      result[i + 1] = access_table; // Lua arrays start at 1
    }

    return result;
  });

  // format memory value as hex string with specified width
  // provides consistent formatting for memory values based on their size
  w1_module.set_function("format_memory_value", [](QBDI::rword value, int size) -> std::string {
    char buffer[32];
    switch (size) {
    case 1:
      snprintf(buffer, sizeof(buffer), "0x%02x", static_cast<uint8_t>(value));
      break;
    case 2:
      snprintf(buffer, sizeof(buffer), "0x%04x", static_cast<uint16_t>(value));
      break;
    case 4:
      snprintf(buffer, sizeof(buffer), "0x%08x", static_cast<uint32_t>(value));
      break;
    case 8:
      snprintf(buffer, sizeof(buffer), "0x%016lx", static_cast<unsigned long>(value));
      break;
    default:
      snprintf(buffer, sizeof(buffer), "0x%lx", static_cast<unsigned long>(value));
      break;
    }
    return std::string(buffer);
  });

  // memory access recording
  // enable automatic memory logging for specified access types
  w1_module.set_function("recordMemoryAccess", [](void* vm_ptr, QBDI::MemoryAccessType type) -> bool {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    return vm->recordMemoryAccess(type);
  });

  // get current instruction memory accesses (alias for existing function)
  w1_module.set_function("getInstMemoryAccess", [&lua](void* vm_ptr) -> sol::table {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    std::vector<QBDI::MemoryAccess> accesses = vm->getInstMemoryAccess();

    sol::state_view lua_view = lua.lua_state();
    sol::table result = lua_view.create_table();

    for (size_t i = 0; i < accesses.size(); i++) {
      const auto& access = accesses[i];
      sol::table access_table = lua_view.create_table();

      access_table["address"] = access.accessAddress;
      access_table["value"] = access.value;
      access_table["size"] = access.size;
      access_table["inst_address"] = access.instAddress;
      access_table["is_read"] = (access.type & QBDI::MEMORY_READ) != 0;
      access_table["is_write"] = (access.type & QBDI::MEMORY_WRITE) != 0;
      access_table["flags"] = access.flags;

      result[i + 1] = access_table;
    }

    return result;
  });

  // get basic block memory accesses
  w1_module.set_function("getBBMemoryAccess", [&lua](void* vm_ptr) -> sol::table {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    std::vector<QBDI::MemoryAccess> accesses = vm->getBBMemoryAccess();

    sol::state_view lua_view = lua.lua_state();
    sol::table result = lua_view.create_table();

    for (size_t i = 0; i < accesses.size(); i++) {
      const auto& access = accesses[i];
      sol::table access_table = lua_view.create_table();

      access_table["address"] = access.accessAddress;
      access_table["value"] = access.value;
      access_table["size"] = access.size;
      access_table["inst_address"] = access.instAddress;
      access_table["is_read"] = (access.type & QBDI::MEMORY_READ) != 0;
      access_table["is_write"] = (access.type & QBDI::MEMORY_WRITE) != 0;
      access_table["flags"] = access.flags;

      result[i + 1] = access_table;
    }

    return result;
  });

  // memory management
  // allocate managed virtual stack
  w1_module.set_function("allocateVirtualStack", [](void* vm_ptr, uint32_t stackSize) -> sol::optional<QBDI::rword> {
    auto log = redlog::get_logger("w1.script_bindings");
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);

    try {
      QBDI::GPRState* state = vm->getGPRState();
      uint8_t* stack = nullptr;

      if (QBDI::allocateVirtualStack(state, stackSize, &stack)) {
        log.dbg(
            "allocated virtual stack of size " + std::to_string(stackSize) + " at address 0x" +
            std::to_string(reinterpret_cast<QBDI::rword>(stack))
        );
        return reinterpret_cast<QBDI::rword>(stack);
      } else {
        log.warn("failed to allocate virtual stack of size " + std::to_string(stackSize));
        return sol::nullopt;
      }
    } catch (const std::exception& e) {
      log.err("exception in allocateVirtualStack: " + std::string(e.what()));
      return sol::nullopt;
    }
  });

  // simulate function call with arguments
  w1_module.set_function("simulateCall", [](void* vm_ptr, QBDI::rword returnAddress, sol::table args) -> bool {
    auto log = redlog::get_logger("w1.script_bindings");
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);

    try {
      QBDI::GPRState* state = vm->getGPRState();
      std::vector<QBDI::rword> argVector;

      // convert Lua table to vector
      for (size_t i = 1; i <= args.size(); i++) {
        sol::optional<QBDI::rword> arg = args[i];
        if (arg) {
          argVector.push_back(arg.value());
        }
      }

      QBDI::simulateCall(state, returnAddress, argVector);
      log.dbg(
          "simulated call with return address 0x" + std::to_string(returnAddress) + " and " +
          std::to_string(argVector.size()) + " arguments"
      );
      return true;
    } catch (const std::exception& e) {
      log.err("exception in simulateCall: " + std::string(e.what()));
      return false;
    }
  });

  // aligned memory allocation
  w1_module.set_function("alignedAlloc", [](size_t size, size_t alignment) -> sol::optional<QBDI::rword> {
    auto log = redlog::get_logger("w1.script_bindings");
    try {
      void* ptr = QBDI::alignedAlloc(size, alignment);
      if (ptr) {
        log.dbg(
            "allocated " + std::to_string(size) + " bytes with alignment " + std::to_string(alignment) +
            " at address 0x" + std::to_string(reinterpret_cast<QBDI::rword>(ptr))
        );
        return reinterpret_cast<QBDI::rword>(ptr);
      } else {
        log.warn("failed to allocate " + std::to_string(size) + " bytes with alignment " + std::to_string(alignment));
        return sol::nullopt;
      }
    } catch (const std::exception& e) {
      log.err("exception in alignedAlloc: " + std::string(e.what()));
      return sol::nullopt;
    }
  });

  // aligned memory free
  w1_module.set_function("alignedFree", [](QBDI::rword ptr) -> bool {
    auto log = redlog::get_logger("w1.script_bindings");
    try {
      if (ptr != 0) {
        QBDI::alignedFree(reinterpret_cast<void*>(ptr));
        log.dbg("freed aligned memory at address 0x" + std::to_string(ptr));
        return true;
      } else {
        log.warn("attempted to free null pointer");
        return false;
      }
    } catch (const std::exception& e) {
      log.err("exception in alignedFree: " + std::string(e.what()));
      return false;
    }
  });

  // memory inspection
  // safe memory reading with error handling
  w1_module.set_function(
      "readMemory", [](void* vm_ptr, QBDI::rword address, size_t size) -> sol::optional<std::string> {
        auto log = redlog::get_logger("w1.script_bindings");

        try {
          // validate parameters
          if (size == 0) {
            log.warn("attempted to read 0 bytes from address 0x" + std::to_string(address));
            return sol::nullopt;
          }

          if (size > 0x10000) { // Limit reads to 64KB for safety
            log.warn(
                "attempted to read " + std::to_string(size) + " bytes from address 0x" + std::to_string(address) +
                " - size too large"
            );
            return sol::nullopt;
          }

          // try to read memory with basic safety checks
          // note: this is still potentially dangerous and should be used carefully
          std::vector<uint8_t> buffer(size);

          // use memcpy for reading - this can still crash if address is invalid
          // but it's the most direct approach available in QBDI context
          std::memcpy(buffer.data(), reinterpret_cast<const void*>(address), size);

          // convert to hex string
          std::ostringstream hex_stream;
          hex_stream << std::hex << std::uppercase;
          for (size_t i = 0; i < size; i++) {
            hex_stream << std::setfill('0') << std::setw(2) << static_cast<int>(buffer[i]);
          }

          log.dbg("successfully read " + std::to_string(size) + " bytes from address 0x" + std::to_string(address));
          return hex_stream.str();

        } catch (const std::exception& e) {
          log.err("exception reading memory at address 0x" + std::to_string(address) + ": " + std::string(e.what()));
          return sol::nullopt;
        } catch (...) {
          log.err("unknown exception reading memory at address 0x" + std::to_string(address));
          return sol::nullopt;
        }
      }
  );

  // unsafe memory writing (deprecated - use write_mem instead)
  w1_module.set_function(
      "writeMemoryUnsafe", [](void* vm_ptr, QBDI::rword address, const std::string& hexData) -> bool {
        auto log = redlog::get_logger("w1.script_bindings");

        try {
          // validate hex string length
          if (hexData.length() % 2 != 0) {
            log.warn("invalid hex data length: " + std::to_string(hexData.length()) + " (must be even)");
            return false;
          }

          size_t size = hexData.length() / 2;
          if (size == 0) {
            log.warn("attempted to write 0 bytes to address 0x" + std::to_string(address));
            return false;
          }

          if (size > 0x10000) { // Limit writes to 64KB for safety
            log.warn(
                "attempted to write " + std::to_string(size) + " bytes to address 0x" + std::to_string(address) +
                " - size too large"
            );
            return false;
          }

          // convert hex string to bytes
          std::vector<uint8_t> buffer(size);
          for (size_t i = 0; i < size; i++) {
            std::string byteStr = hexData.substr(i * 2, 2);
            buffer[i] = static_cast<uint8_t>(std::stoul(byteStr, nullptr, 16));
          }

          // write memory using memcpy - this can still crash if address is invalid
          std::memcpy(reinterpret_cast<void*>(address), buffer.data(), size);

          log.dbg("successfully wrote " + std::to_string(size) + " bytes to address 0x" + std::to_string(address));
          return true;

        } catch (const std::exception& e) {
          log.err("exception writing memory at address 0x" + std::to_string(address) + ": " + std::string(e.what()));
          return false;
        } catch (...) {
          log.err("unknown exception writing memory at address 0x" + std::to_string(address));
          return false;
        }
      }
  );

  // basic address validity check (heuristic-based)
  w1_module.set_function("isAddressValid", [](void* vm_ptr, QBDI::rword address) -> bool {
    auto log = redlog::get_logger("w1.script_bindings");

    try {
      // basic heuristic checks for obviously invalid addresses
      if (address == 0) {
        return false; // null pointer
      }

      // check for obviously invalid addresses (platform-specific)
#if defined(__x86_64__) || defined(_M_X64)
      // on x86-64, user space addresses are typically below 0x00007FFFFFFFFFFF
      if (address > 0x00007FFFFFFFFFFUL) {
        return false;
      }
#elif defined(__i386__) || defined(_M_IX86)
      // on 32-bit, check for reasonable user space range
      if (address > 0xC0000000UL) {
        return false;
      }
#endif

      // try to read a single byte as a basic validity test
      // this is still not foolproof but provides some safety
      try {
        volatile uint8_t test_byte;
        std::memcpy(const_cast<uint8_t*>(&test_byte), reinterpret_cast<const void*>(address), 1);
        return true;
      } catch (...) {
        return false;
      }

    } catch (const std::exception& e) {
      log.err("exception in isAddressValid for address 0x" + std::to_string(address) + ": " + std::string(e.what()));
      return false;
    }
  });

  // memory mapping
  // get process memory layout
  w1_module.set_function("getMemoryMaps", [&lua](void* vm_ptr) -> sol::table {
    auto log = redlog::get_logger("w1.script_bindings");
    sol::state_view lua_view = lua.lua_state();
    sol::table result = lua_view.create_table();

    try {
      std::vector<QBDI::MemoryMap> maps = QBDI::getCurrentProcessMaps(true);

      for (size_t i = 0; i < maps.size(); i++) {
        const auto& map = maps[i];
        sol::table map_table = lua_view.create_table();

        map_table["start"] = map.range.start();
        map_table["end"] = map.range.end();
        map_table["size"] = map.range.size();
        map_table["name"] = map.name;
        map_table["readable"] = (map.permission & QBDI::PF_READ) != 0;
        map_table["writable"] = (map.permission & QBDI::PF_WRITE) != 0;
        map_table["executable"] = (map.permission & QBDI::PF_EXEC) != 0;
        map_table["permissions"] = static_cast<int>(map.permission);

        result[i + 1] = map_table;
      }

      log.dbg("retrieved " + std::to_string(maps.size()) + " memory maps");

    } catch (const std::exception& e) {
      log.err("exception in getMemoryMaps: " + std::string(e.what()));
    }

    return result;
  });

  // find memory map containing specific address
  w1_module.set_function("findMemoryMap", [&lua](void* vm_ptr, QBDI::rword address) -> sol::optional<sol::table> {
    auto log = redlog::get_logger("w1.script_bindings");

    try {
      std::vector<QBDI::MemoryMap> maps = QBDI::getCurrentProcessMaps(true);

      for (const auto& map : maps) {
        if (map.range.contains(address)) {
          sol::state_view lua_view = lua.lua_state();
          sol::table map_table = lua_view.create_table();

          map_table["start"] = map.range.start();
          map_table["end"] = map.range.end();
          map_table["size"] = map.range.size();
          map_table["name"] = map.name;
          map_table["readable"] = (map.permission & QBDI::PF_READ) != 0;
          map_table["writable"] = (map.permission & QBDI::PF_WRITE) != 0;
          map_table["executable"] = (map.permission & QBDI::PF_EXEC) != 0;
          map_table["permissions"] = static_cast<int>(map.permission);

          log.dbg(
              "found memory map for address 0x" + std::to_string(address) + ": " + map.name + " (0x" +
              std::to_string(map.range.start()) + "-0x" + std::to_string(map.range.end()) + ")"
          );
          return map_table;
        }
      }

      log.dbg("no memory map found for address 0x" + std::to_string(address));
      return sol::nullopt;

    } catch (const std::exception& e) {
      log.err("exception in findMemoryMap for address 0x" + std::to_string(address) + ": " + std::string(e.what()));
      return sol::nullopt;
    }
  });

  // check if address is in executable memory region
  w1_module.set_function("isExecutableAddress", [](void* vm_ptr, QBDI::rword address) -> bool {
    auto log = redlog::get_logger("w1.script_bindings");

    try {
      std::vector<QBDI::MemoryMap> maps = QBDI::getCurrentProcessMaps(false);

      for (const auto& map : maps) {
        if (map.range.contains(address)) {
          bool isExecutable = (map.permission & QBDI::PF_EXEC) != 0;
          log.dbg(
              "address 0x" + std::to_string(address) + " is " + (isExecutable ? "executable" : "not executable") +
              " in region " + map.name + " (0x" + std::to_string(map.range.start()) + "-0x" +
              std::to_string(map.range.end()) + ")"
          );
          return isExecutable;
        }
      }

      log.dbg("address 0x" + std::to_string(address) + " not found in any memory map");
      return false;

    } catch (const std::exception& e) {
      log.err(
          "exception in isExecutableAddress for address 0x" + std::to_string(address) + ": " + std::string(e.what())
      );
      return false;
    }
  });

  // legacy read_memory function (improved implementation)
  w1_module.set_function(
      "read_memory", [](void* vm_ptr, QBDI::rword address, size_t size) -> sol::optional<std::string> {
        auto log = redlog::get_logger("w1.script_bindings");

        try {
          // validate parameters
          if (size == 0) {
            log.warn("attempted to read 0 bytes from address 0x" + std::to_string(address));
            return sol::nullopt;
          }

          if (size > 0x1000) { // Limit to 4KB for legacy function
            log.warn(
                "attempted to read " + std::to_string(size) + " bytes from address 0x" + std::to_string(address) +
                " - size too large for legacy function"
            );
            return sol::nullopt;
          }

          // try to read memory with basic safety checks
          std::vector<uint8_t> buffer(size);
          std::memcpy(buffer.data(), reinterpret_cast<const void*>(address), size);

          // convert to string (assume printable characters)
          std::string result;
          result.reserve(size);
          for (uint8_t byte : buffer) {
            if (byte >= 32 && byte <= 126) { // printable ASCII
              result += static_cast<char>(byte);
            } else {
              result += '.';
            }
          }

          log.dbg(
              "successfully read " + std::to_string(size) + " bytes from address 0x" + std::to_string(address) +
              " (legacy function)"
          );
          return result;

        } catch (const std::exception& e) {
          log.err(
              "exception in legacy read_memory at address 0x" + std::to_string(address) + ": " + std::string(e.what())
          );
          return sol::nullopt;
        } catch (...) {
          log.err("unknown exception in legacy read_memory at address 0x" + std::to_string(address));
          return sol::nullopt;
        }
      }
  );

  // check if a memory access is a read operation
  w1_module.set_function("is_memory_read", [](QBDI::MemoryAccessType type) -> bool {
    return (type & QBDI::MEMORY_READ) != 0;
  });

  // check if a memory access is a write operation
  w1_module.set_function("is_memory_write", [](QBDI::MemoryAccessType type) -> bool {
    return (type & QBDI::MEMORY_WRITE) != 0;
  });

  // get the number of memory accesses for the current instruction
  w1_module.set_function("get_memory_access_count", [](void* vm_ptr) -> size_t {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    std::vector<QBDI::MemoryAccess> accesses = vm->getInstMemoryAccess();
    return accesses.size();
  });

  // check if the current instruction performs any memory accesses
  w1_module.set_function("has_memory_access", [](void* vm_ptr) -> bool {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    std::vector<QBDI::MemoryAccess> accesses = vm->getInstMemoryAccess();
    return !accesses.empty();
  });

  // get the total size of all memory accesses for the current instruction
  w1_module.set_function("get_total_memory_access_size", [](void* vm_ptr) -> size_t {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    std::vector<QBDI::MemoryAccess> accesses = vm->getInstMemoryAccess();

    size_t total_size = 0;
    for (const auto& access : accesses) {
      total_size += access.size;
    }
    return total_size;
  });

  logger.dbg("enhanced memory analysis functions setup complete with 16 functions");
}

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/memory_analysis.hpp`:

```hpp
/**
 * @file memory_analysis.hpp
 * @brief Memory access and analysis bindings for w1script
 *
 * This module provides comprehensive memory analysis capabilities including safe
 * memory read/write operations, memory mapping inspection, address validation,
 * and advanced memory management functions for dynamic analysis.
 *
 * @author w1tn3ss Development Team
 * @date 2025
 */

#pragma once

#include <sol/sol.hpp>
#include <QBDI.h>

namespace w1::tracers::script::bindings {

/**
 * @brief Setup memory access and analysis functions for Lua bindings
 *
 * This module provides functions for analyzing memory accesses performed
 * by the currently executing instruction, including:
 * - Memory access retrieval and analysis
 * - Memory value formatting utilities
 * - Memory read operations (when safe)
 *
 * The memory access functions return detailed information about each memory
 * operation (read/write) performed by the current instruction, including
 * addresses, values, sizes, and types.
 *
 * @param lua The Sol2 Lua state to register bindings with
 * @param w1_module The w1 module table to add bindings to
 */
void setup_memory_analysis(sol::state& lua, sol::table& w1_module);

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/module_analysis.cpp`:

```cpp
#include "module_analysis.hpp"
#include <w1tn3ss/util/module_scanner.hpp>
#include <w1tn3ss/util/module_range_index.hpp>
#include <redlog.hpp>
#include <memory>

namespace w1::tracers::script::bindings {

// singleton-style module scanner and index for lua access
static std::unique_ptr<w1::util::module_scanner> g_scanner;
static std::unique_ptr<w1::util::module_range_index> g_index;
static bool g_modules_initialized = false;

// ensure module system is initialized
static void ensure_modules_initialized() {
  if (g_modules_initialized) {
    return;
  }

  // create scanner and index
  g_scanner = std::make_unique<w1::util::module_scanner>();
  g_index = std::make_unique<w1::util::module_range_index>();

  // scan modules and build index
  auto modules = g_scanner->scan_executable_modules();
  g_index->rebuild_from_modules(std::move(modules));

  g_modules_initialized = true;

  auto log = redlog::get_logger("w1.script_lua");
  log.dbg("module analysis system initialized with " + std::to_string(g_index->size()) + " modules");
}

// convert module_type enum to string
static std::string module_type_to_string(w1::util::module_type type) {
  switch (type) {
  case w1::util::module_type::MAIN_EXECUTABLE:
    return "main_executable";
  case w1::util::module_type::SHARED_LIBRARY:
    return "shared_library";
  case w1::util::module_type::ANONYMOUS_EXECUTABLE:
    return "anonymous_executable";
  default:
    return "unknown";
  }
}

void setup_module_analysis(sol::state& lua, sol::table& w1_module) {
  auto logger = redlog::get_logger("w1.script_bindings");
  logger.dbg("setting up module analysis functions");

  // === simple module name lookup ===
  w1_module.set_function("module_get_name", [](uint64_t address) -> std::string {
    ensure_modules_initialized();

    if (address == 0) {
      return "unknown";
    }

    const auto* module = g_index->find_containing(address);
    return module ? module->name : "unknown";
  });

  // === full module info lookup ===
  w1_module.set_function("module_get_info", [&lua](uint64_t address) -> sol::object {
    ensure_modules_initialized();

    if (address == 0) {
      return sol::nil;
    }

    const auto* module = g_index->find_containing(address);
    if (!module) {
      return sol::nil;
    }

    // create lua table with module info
    sol::table info = lua.create_table();
    info["name"] = module->name;
    info["path"] = module->path;
    info["base_address"] = module->base_address;
    info["size"] = module->size;
    info["type"] = module_type_to_string(module->type);
    info["is_system"] = module->is_system_library;

    return info;
  });

  // === list all modules ===
  w1_module.set_function("module_list_all", [&lua]() -> sol::table {
    ensure_modules_initialized();

    sol::table modules = lua.create_table();

    int index = 1;
    g_index->visit_all([&](const w1::util::module_info& module) {
      sol::table info = lua.create_table();
      info["name"] = module.name;
      info["path"] = module.path;
      info["base_address"] = module.base_address;
      info["size"] = module.size;
      info["type"] = module_type_to_string(module.type);
      info["is_system"] = module.is_system_library;

      modules[index++] = info;
    });

    return modules;
  });

  // === trigger module rescan ===
  w1_module.set_function("module_scan", []() -> bool {
    try {
      if (!g_scanner) {
        g_scanner = std::make_unique<w1::util::module_scanner>();
      }
      if (!g_index) {
        g_index = std::make_unique<w1::util::module_range_index>();
      }

      // scan modules and rebuild index
      auto modules = g_scanner->scan_executable_modules();
      size_t module_count = modules.size();
      g_index->rebuild_from_modules(std::move(modules));
      g_modules_initialized = true;

      auto log = redlog::get_logger("w1.script_lua");
      log.inf("module rescan completed, found " + std::to_string(module_count) + " modules");

      return true;
    } catch (const std::exception& e) {
      auto log = redlog::get_logger("w1.script_lua");
      log.err("module scan failed: " + std::string(e.what()));
      return false;
    }
  });

  // === get module count ===
  w1_module.set_function("module_count", []() -> size_t {
    ensure_modules_initialized();
    return g_index->size();
  });

  logger.dbg("module analysis functions setup complete");
}

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/module_analysis.hpp`:

```hpp
#pragma once

#include <sol/sol.hpp>

namespace w1::tracers::script::bindings {

/**
 * @brief setup module analysis functions in lua environment
 * @details provides clean api for module discovery and address-to-module mapping
 */
void setup_module_analysis(sol::state& lua, sol::table& w1_module);

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/output.cpp`:

```cpp
#include "output.hpp"
#include <w1tn3ss/util/jsonl_writer.hpp>
#include <redlog.hpp>
#include <chrono>
#include <iomanip>
#include <sstream>

namespace w1::tracers::script::bindings {

// forward declaration from utilities.cpp
std::string lua_table_to_json(const sol::table& lua_table);

namespace {

std::string get_timestamp() {
  auto now = std::chrono::system_clock::now();
  auto time_t = std::chrono::system_clock::to_time_t(now);
  auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()) % 1000;

  std::stringstream ss;
  ss << std::put_time(std::gmtime(&time_t), "%Y-%m-%dT%H:%M:%S");
  ss << '.' << std::setfill('0') << std::setw(3) << ms.count() << 'Z';
  return ss.str();
}

} // anonymous namespace

output_module::~output_module() {
  if (initialized_) {
    close();
  }
}

bool output_module::init(sol::state_view lua, const std::string& filename, sol::optional<sol::table> metadata) {
  auto logger = redlog::get_logger("w1.script_output");

  // close any existing writer
  if (initialized_) {
    close();
  }

  try {
    // create new writer
    writer_ = std::make_shared<w1::util::jsonl_writer>(filename);

    if (!writer_->is_open()) {
      logger.err("failed to open output file", redlog::field("filename", filename));
      writer_.reset();
      return false;
    }

    // write metadata if provided
    sol::table meta_table;
    if (metadata) {
      meta_table = metadata.value();
    } else {
      // create default metadata table
      meta_table = lua.create_table();
    }

    // ensure required metadata fields
    meta_table["type"] = "metadata";
    if (!meta_table["version"].valid()) {
      meta_table["version"] = "1.0";
    }
    if (!meta_table["timestamp"].valid()) {
      meta_table["timestamp"] = get_timestamp();
    }
    if (!meta_table["tracer"].valid()) {
      meta_table["tracer"] = "w1script";
    }

    // write metadata line
    std::string json_metadata = lua_table_to_json(meta_table);
    if (!writer_->write_line(json_metadata)) {
      logger.err("failed to write metadata");
      writer_->close();
      writer_.reset();
      return false;
    }

    initialized_ = true;
    event_count_ = 0;
    logger.inf("output initialized", redlog::field("filename", filename));
    return true;

  } catch (const std::exception& e) {
    logger.err("exception initializing output", redlog::field("error", e.what()));
    writer_.reset();
    return false;
  }
}

bool output_module::write_event(sol::table event) {
  auto logger = redlog::get_logger("w1.script_output");

  if (!initialized_ || !writer_) {
    logger.err("output not initialized - call w1.output.init() first");
    return false;
  }

  try {
    // ensure event has a type
    if (!event["type"].valid()) {
      event["type"] = "event";
    }

    // convert to json and write
    std::string json_event = lua_table_to_json(event);
    bool success = writer_->write_line(json_event);

    if (success) {
      event_count_++;

      // periodic flush for performance
      if (event_count_ % 10000 == 0) {
        writer_->flush();
      }
    }

    return success;

  } catch (const std::exception& e) {
    logger.err("exception writing event", redlog::field("error", e.what()));
    return false;
  }
}

void output_module::close() {
  auto logger = redlog::get_logger("w1.script_output");

  if (!initialized_ || !writer_) {
    return;
  }

  try {
    // write summary if we have events
    if (event_count_ > 0) {
      // need lua state to create table
      // this is a bit awkward - we'll handle this in the binding setup
      std::stringstream summary;
      summary << "{\"type\":\"summary\","
              << "\"event_count\":" << event_count_ << ","
              << "\"end_timestamp\":\"" << get_timestamp() << "\"}";
      writer_->write_line(summary.str());
    }

    writer_->close();
    writer_.reset();
    initialized_ = false;

    logger.inf("output closed", redlog::field("events", event_count_));

  } catch (const std::exception& e) {
    logger.err("exception closing output", redlog::field("error", e.what()));
  }
}

void setup_output(sol::state& lua, sol::table& w1_module) {
  auto logger = redlog::get_logger("w1.script_bindings");
  logger.dbg("setting up output module");

  // create a shared output module instance
  auto output_instance = std::make_shared<output_module>();

  // create the w1.output table
  sol::table output_table = lua.create_table();

  // bind init function
  output_table["init"] = [output_instance,
                          &lua](const std::string& filename, sol::optional<sol::table> metadata) -> bool {
    return output_instance->init(lua, filename, metadata);
  };

  // bind write_event function
  output_table["write_event"] = [output_instance](sol::table event) -> bool {
    return output_instance->write_event(event);
  };

  // bind close function
  output_table["close"] = [output_instance]() { output_instance->close(); };

  // bind status functions
  output_table["is_initialized"] = [output_instance]() -> bool { return output_instance->is_initialized(); };

  output_table["get_event_count"] = [output_instance]() -> size_t { return output_instance->get_event_count(); };

  // helper to ensure shutdown handler
  output_table["ensure_shutdown_handler"] = [output_instance](sol::table tracer) {
    sol::function original_shutdown = tracer["shutdown"];

    tracer["shutdown"] = [output_instance, original_shutdown]() {
      if (original_shutdown.valid()) {
        original_shutdown();
      }
      output_instance->close();
    };
  };

  // attach to w1 module
  w1_module["output"] = output_table;

  logger.dbg("output module setup complete");
}

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/output.hpp`:

```hpp
#pragma once

#include <sol/sol.hpp>
#include <memory>
#include <string>

namespace w1::util {
class jsonl_writer;
}

namespace w1::tracers::script::bindings {

/**
 * native c++ implementation of the w1.output module
 * replaces the embedded lua code with a clean api
 */
class output_module {
private:
  std::shared_ptr<w1::util::jsonl_writer> writer_;
  bool initialized_ = false;
  size_t event_count_ = 0;

public:
  output_module() = default;
  ~output_module();

  // initialize output file with optional metadata
  bool init(sol::state_view lua, const std::string& filename, sol::optional<sol::table> metadata);

  // write an event to the output file
  bool write_event(sol::table event);

  // close the output file with summary
  void close();

  // check if output is initialized
  bool is_initialized() const { return initialized_; }

  // get event count
  size_t get_event_count() const { return event_count_; }
};

// setup output bindings for lua
void setup_output(sol::state& lua, sol::table& w1_module);

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/register_access.cpp`:

```cpp
#include "register_access.hpp"
#include <w1tn3ss/util/register_access.hpp>
#include <redlog.hpp>
#include <unordered_map>
#include <string>

namespace w1::tracers::script::bindings {

// helper to convert string register name to enum
static std::optional<w1::registers::reg> string_to_reg(const std::string& name) {
  static const std::unordered_map<std::string, w1::registers::reg> reg_map = {
      // common architectural names
      {"pc", w1::registers::reg::pc},   {"sp", w1::registers::reg::sp},

#if defined(QBDI_ARCH_X86_64)
      {"rax", w1::registers::reg::rax}, {"rbx", w1::registers::reg::rbx}, {"rcx", w1::registers::reg::rcx},
      {"rdx", w1::registers::reg::rdx}, {"rsi", w1::registers::reg::rsi}, {"rdi", w1::registers::reg::rdi},
      {"rbp", w1::registers::reg::rbp}, {"rsp", w1::registers::reg::rsp}, {"r8", w1::registers::reg::r8},
      {"r9", w1::registers::reg::r9},   {"r10", w1::registers::reg::r10}, {"r11", w1::registers::reg::r11},
      {"r12", w1::registers::reg::r12}, {"r13", w1::registers::reg::r13}, {"r14", w1::registers::reg::r14},
      {"r15", w1::registers::reg::r15}, {"rip", w1::registers::reg::rip},
#elif defined(QBDI_ARCH_AARCH64)
      {"x0", w1::registers::reg::x0},   {"x1", w1::registers::reg::x1},   {"x2", w1::registers::reg::x2},
      {"x3", w1::registers::reg::x3},   {"x4", w1::registers::reg::x4},   {"x5", w1::registers::reg::x5},
      {"x6", w1::registers::reg::x6},   {"x7", w1::registers::reg::x7},   {"x8", w1::registers::reg::x8},
      {"x9", w1::registers::reg::x9},   {"x10", w1::registers::reg::x10}, {"x11", w1::registers::reg::x11},
      {"x12", w1::registers::reg::x12}, {"x13", w1::registers::reg::x13}, {"x14", w1::registers::reg::x14},
      {"x15", w1::registers::reg::x15}, {"x16", w1::registers::reg::x16}, {"x17", w1::registers::reg::x17},
      {"x18", w1::registers::reg::x18}, {"x19", w1::registers::reg::x19}, {"x20", w1::registers::reg::x20},
      {"x21", w1::registers::reg::x21}, {"x22", w1::registers::reg::x22}, {"x23", w1::registers::reg::x23},
      {"x24", w1::registers::reg::x24}, {"x25", w1::registers::reg::x25}, {"x26", w1::registers::reg::x26},
      {"x27", w1::registers::reg::x27}, {"x28", w1::registers::reg::x28}, {"x29", w1::registers::reg::x29},
      {"lr", w1::registers::reg::lr},
#elif defined(QBDI_ARCH_ARM)
      {"r0", w1::registers::reg::r0},   {"r1", w1::registers::reg::r1},   {"r2", w1::registers::reg::r2},
      {"r3", w1::registers::reg::r3},   {"r4", w1::registers::reg::r4},   {"r5", w1::registers::reg::r5},
      {"r6", w1::registers::reg::r6},   {"r7", w1::registers::reg::r7},   {"r8", w1::registers::reg::r8},
      {"r9", w1::registers::reg::r9},   {"r10", w1::registers::reg::r10}, {"r11", w1::registers::reg::r11},
      {"r12", w1::registers::reg::r12}, {"r13", w1::registers::reg::r13}, {"r14", w1::registers::reg::r14},
      {"r15", w1::registers::reg::r15},
#elif defined(QBDI_ARCH_X86)
      {"eax", w1::registers::reg::eax}, {"ebx", w1::registers::reg::ebx}, {"ecx", w1::registers::reg::ecx},
      {"edx", w1::registers::reg::edx}, {"esi", w1::registers::reg::esi}, {"edi", w1::registers::reg::edi},
      {"ebp", w1::registers::reg::ebp}, {"esp", w1::registers::reg::esp}, {"eip", w1::registers::reg::eip},
#endif
  };

  auto it = reg_map.find(name);
  if (it != reg_map.end()) {
    return it->second;
  }
  return std::nullopt;
}

// helper to set register value
static bool set_register(QBDI::GPRState* gpr, w1::registers::reg r, QBDI::rword value) {
  switch (r) {
#if defined(QBDI_ARCH_X86_64)
  case w1::registers::reg::rax:
    gpr->rax = value;
    return true;
  case w1::registers::reg::rbx:
    gpr->rbx = value;
    return true;
  case w1::registers::reg::rcx:
    gpr->rcx = value;
    return true;
  case w1::registers::reg::rdx:
    gpr->rdx = value;
    return true;
  case w1::registers::reg::rsi:
    gpr->rsi = value;
    return true;
  case w1::registers::reg::rdi:
    gpr->rdi = value;
    return true;
  case w1::registers::reg::rbp:
    gpr->rbp = value;
    return true;
  case w1::registers::reg::rsp:
    gpr->rsp = value;
    return true;
  case w1::registers::reg::r8:
    gpr->r8 = value;
    return true;
  case w1::registers::reg::r9:
    gpr->r9 = value;
    return true;
  case w1::registers::reg::r10:
    gpr->r10 = value;
    return true;
  case w1::registers::reg::r11:
    gpr->r11 = value;
    return true;
  case w1::registers::reg::r12:
    gpr->r12 = value;
    return true;
  case w1::registers::reg::r13:
    gpr->r13 = value;
    return true;
  case w1::registers::reg::r14:
    gpr->r14 = value;
    return true;
  case w1::registers::reg::r15:
    gpr->r15 = value;
    return true;
  case w1::registers::reg::rip:
    gpr->rip = value;
    return true;
#elif defined(QBDI_ARCH_AARCH64)
  case w1::registers::reg::x0:
    gpr->x0 = value;
    return true;
  case w1::registers::reg::x1:
    gpr->x1 = value;
    return true;
  case w1::registers::reg::x2:
    gpr->x2 = value;
    return true;
  case w1::registers::reg::x3:
    gpr->x3 = value;
    return true;
  case w1::registers::reg::x4:
    gpr->x4 = value;
    return true;
  case w1::registers::reg::x5:
    gpr->x5 = value;
    return true;
  case w1::registers::reg::x6:
    gpr->x6 = value;
    return true;
  case w1::registers::reg::x7:
    gpr->x7 = value;
    return true;
  case w1::registers::reg::x8:
    gpr->x8 = value;
    return true;
  case w1::registers::reg::x9:
    gpr->x9 = value;
    return true;
  case w1::registers::reg::x10:
    gpr->x10 = value;
    return true;
  case w1::registers::reg::x11:
    gpr->x11 = value;
    return true;
  case w1::registers::reg::x12:
    gpr->x12 = value;
    return true;
  case w1::registers::reg::x13:
    gpr->x13 = value;
    return true;
  case w1::registers::reg::x14:
    gpr->x14 = value;
    return true;
  case w1::registers::reg::x15:
    gpr->x15 = value;
    return true;
  case w1::registers::reg::x16:
    gpr->x16 = value;
    return true;
  case w1::registers::reg::x17:
    gpr->x17 = value;
    return true;
  case w1::registers::reg::x18:
    gpr->x18 = value;
    return true;
  case w1::registers::reg::x19:
    gpr->x19 = value;
    return true;
  case w1::registers::reg::x20:
    gpr->x20 = value;
    return true;
  case w1::registers::reg::x21:
    gpr->x21 = value;
    return true;
  case w1::registers::reg::x22:
    gpr->x22 = value;
    return true;
  case w1::registers::reg::x23:
    gpr->x23 = value;
    return true;
  case w1::registers::reg::x24:
    gpr->x24 = value;
    return true;
  case w1::registers::reg::x25:
    gpr->x25 = value;
    return true;
  case w1::registers::reg::x26:
    gpr->x26 = value;
    return true;
  case w1::registers::reg::x27:
    gpr->x27 = value;
    return true;
  case w1::registers::reg::x28:
    gpr->x28 = value;
    return true;
  case w1::registers::reg::x29:
    gpr->x29 = value;
    return true;
  case w1::registers::reg::sp:
    gpr->sp = value;
    return true;
  case w1::registers::reg::lr:
    gpr->lr = value;
    return true;
  case w1::registers::reg::pc:
    gpr->pc = value;
    return true;
#elif defined(QBDI_ARCH_ARM)
  case w1::registers::reg::r0:
    gpr->r0 = value;
    return true;
  case w1::registers::reg::r1:
    gpr->r1 = value;
    return true;
  case w1::registers::reg::r2:
    gpr->r2 = value;
    return true;
  case w1::registers::reg::r3:
    gpr->r3 = value;
    return true;
  case w1::registers::reg::r4:
    gpr->r4 = value;
    return true;
  case w1::registers::reg::r5:
    gpr->r5 = value;
    return true;
  case w1::registers::reg::r6:
    gpr->r6 = value;
    return true;
  case w1::registers::reg::r7:
    gpr->r7 = value;
    return true;
  case w1::registers::reg::r8:
    gpr->r8 = value;
    return true;
  case w1::registers::reg::r9:
    gpr->r9 = value;
    return true;
  case w1::registers::reg::r10:
    gpr->r10 = value;
    return true;
  case w1::registers::reg::r11:
    gpr->r11 = value;
    return true;
  case w1::registers::reg::r12:
    gpr->r12 = value;
    return true;
  case w1::registers::reg::r13:
    gpr->r13 = value;
    return true;
  case w1::registers::reg::r14:
    gpr->r14 = value;
    return true;
  case w1::registers::reg::r15:
    gpr->r15 = value;
    return true;
  case w1::registers::reg::sp:
    gpr->sp = value;
    return true;
  case w1::registers::reg::pc:
    gpr->pc = value;
    return true;
#elif defined(QBDI_ARCH_X86)
  case w1::registers::reg::eax:
    gpr->eax = value;
    return true;
  case w1::registers::reg::ebx:
    gpr->ebx = value;
    return true;
  case w1::registers::reg::ecx:
    gpr->ecx = value;
    return true;
  case w1::registers::reg::edx:
    gpr->edx = value;
    return true;
  case w1::registers::reg::esi:
    gpr->esi = value;
    return true;
  case w1::registers::reg::edi:
    gpr->edi = value;
    return true;
  case w1::registers::reg::ebp:
    gpr->ebp = value;
    return true;
  case w1::registers::reg::esp:
    gpr->esp = value;
    return true;
  case w1::registers::reg::eip:
    gpr->eip = value;
    return true;
#endif
  default:
    return false;
  }
}

void setup_register_access(sol::state& lua, sol::table& w1_module) {
  auto logger = redlog::get_logger("w1.script_bindings");
  logger.dbg("setting up generic register access functions");

  // generic register getter
  w1_module.set_function("get_reg", [](QBDI::GPRState* gpr, const std::string& reg_name) -> sol::optional<QBDI::rword> {
    if (!gpr) {
      return sol::nullopt;
    }

    auto reg_opt = string_to_reg(reg_name);
    if (!reg_opt) {
      return sol::nullopt;
    }

    return w1::registers::get(gpr, *reg_opt);
  });

  // generic register setter
  w1_module.set_function("set_reg", [](QBDI::GPRState* gpr, const std::string& reg_name, QBDI::rword value) -> bool {
    if (!gpr) {
      return false;
    }

    auto reg_opt = string_to_reg(reg_name);
    if (!reg_opt) {
      return false;
    }

    return set_register(gpr, *reg_opt, value);
  });

  // convenience functions for common registers
  w1_module.set_function("get_pc", [](QBDI::GPRState* gpr) -> QBDI::rword {
    if (!gpr) {
      return 0;
    }
    return w1::registers::get_pc(gpr);
  });

  w1_module.set_function("get_sp", [](QBDI::GPRState* gpr) -> QBDI::rword {
    if (!gpr) {
      return 0;
    }
    return w1::registers::get_sp(gpr);
  });

  // legacy compatibility functions (deprecated)
  w1_module.set_function("get_reg_pc", [](QBDI::GPRState* gpr) -> QBDI::rword {
    if (!gpr) {
      return 0;
    }
    return w1::registers::get_pc(gpr);
  });

  logger.dbg("generic register access functions registered");
}

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/register_access.hpp`:

```hpp
/**
 * @file register_access.hpp
 * @brief CPU register access bindings for w1script
 *
 * This module provides comprehensive CPU register access functions for all supported
 * architectures (x86_64, ARM64, ARM32, x86). Includes both getter and setter functions
 * for all general-purpose registers, status registers, and special registers.
 *
 * @author w1tn3ss Development Team
 * @date 2025
 */

#pragma once

#include <sol/sol.hpp>
#include <QBDI.h>

namespace w1::tracers::script::bindings {

/**
 * @brief Setup platform-specific register access functions for Lua bindings
 *
 * This module provides architecture-specific register access functions
 * that allow Lua scripts to read CPU register values from the GPR state.
 * The functions are conditionally compiled based on the target architecture:
 *
 * - x86_64: RAX, RBX, RCX, RDX, RSP, RBP, RSI, RDI, RIP
 * - ARM64: X0, X1, SP, LR, PC (and additional X registers)
 * - ARM32: R0, R1, SP, LR, PC (and additional R registers)
 *
 * All functions take a void* pointer to GPRState (passed as lightuserdata)
 * and return the register value as QBDI::rword.
 *
 * @param lua The Sol2 Lua state to register bindings with
 * @param w1_module The w1 module table to add bindings to
 */
void setup_register_access(sol::state& lua, sol::table& w1_module);

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/signature_scanning.cpp`:

```cpp
#include "signature_scanning.hpp"
#include <p1ll/scripting/lua_bindings.hpp>
#include <redlog.hpp>

namespace w1::tracers::script::bindings {

void setup_signature_scanning(sol::state& lua, sol::table& w1_module) {
  auto logger = redlog::get_logger("w1.script_bindings");
  logger.dbg("setting up signature scanning functions");

  // setup p1ll bindings in the lua state
  logger.dbg("registering p1ll lua bindings");
  p1ll::scripting::setup_p1ll_bindings(lua);

  // note: we just directly use p1ll, so it's the script's responsibility
  // to compose the p1.search_signature() and w1.hook_addr() calls

  logger.dbg("signature scanning functions registered");
}

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/signature_scanning.hpp`:

```hpp
#pragma once

#include <sol/sol.hpp>

namespace w1::tracers::script::bindings {

void setup_signature_scanning(sol::state& lua, sol::table& w1_module);

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/symbol_resolution.cpp`:

```cpp
#include "symbol_resolution.hpp"
#include <w1tn3ss/symbols/symbol_resolver.hpp>
#include <w1tn3ss/util/module_range_index.hpp>
#include <w1tn3ss/util/module_scanner.hpp>
#include <redlog.hpp>
#include <memory>

namespace w1::tracers::script::bindings {

// singleton symbol resolver instance
static std::unique_ptr<w1::symbols::symbol_resolver> g_symbol_resolver;
static std::unique_ptr<w1::util::module_scanner> g_module_scanner;
static std::unique_ptr<w1::util::module_range_index> g_module_index;
static bool g_symbol_system_initialized = false;

// ensure symbol resolution system is initialized
static void ensure_symbol_system_initialized() {
  if (g_symbol_system_initialized) {
    return;
  }

  auto log = redlog::get_logger("w1.script_symbol");
  log.dbg("initializing symbol resolution system");

  // create symbol resolver with default config
  w1::symbols::symbol_resolver::config cfg;
  cfg.use_native_backend = true;
  cfg.use_lief_backend = true;
  cfg.max_cache_size = 100;
  g_symbol_resolver = std::make_unique<w1::symbols::symbol_resolver>(cfg);

  // create module scanner and index for address-to-module mapping
  g_module_scanner = std::make_unique<w1::util::module_scanner>();
  g_module_index = std::make_unique<w1::util::module_range_index>();

  // scan modules and build index
  auto modules = g_module_scanner->scan_executable_modules();
  g_module_index->rebuild_from_modules(std::move(modules));

  g_symbol_system_initialized = true;

  log.inf(
      "symbol resolution system initialized", redlog::field("backend", g_symbol_resolver->get_backend_name()),
      redlog::field("modules", g_module_index->size())
  );
}

// convert symbol_info to lua table
static sol::table symbol_info_to_lua(sol::state& lua, const w1::symbols::symbol_info& info) {
  sol::table result = lua.create_table();

  result["name"] = info.name;
  result["demangled_name"] = info.demangled_name;
  result["offset"] = info.offset_from_symbol;
  result["module_offset"] = info.module_offset;
  result["size"] = info.size;

  // convert symbol type
  switch (info.symbol_type) {
  case w1::symbols::symbol_info::FUNCTION:
    result["type"] = "function";
    break;
  case w1::symbols::symbol_info::OBJECT:
    result["type"] = "object";
    break;
  case w1::symbols::symbol_info::DEBUG:
    result["type"] = "debug";
    break;
  default:
    result["type"] = "unknown";
    break;
  }

  // convert symbol binding
  switch (info.symbol_binding) {
  case w1::symbols::symbol_info::LOCAL:
    result["binding"] = "local";
    break;
  case w1::symbols::symbol_info::GLOBAL:
    result["binding"] = "global";
    break;
  case w1::symbols::symbol_info::WEAK:
    result["binding"] = "weak";
    break;
  default:
    result["binding"] = "unknown";
    break;
  }

  result["is_exported"] = info.is_exported;
  result["is_imported"] = info.is_imported;

  return result;
}

void setup_symbol_resolution(sol::state& lua, sol::table& w1_module) {
  auto logger = redlog::get_logger("w1.script_bindings");
  logger.dbg("setting up symbol resolution functions");

  // === resolve address to symbol ===
  w1_module.set_function("symbol_resolve_address", [&lua](uint64_t address) -> sol::object {
    ensure_symbol_system_initialized();

    if (address == 0) {
      return sol::nil;
    }

    auto result = g_symbol_resolver->resolve_address(address, *g_module_index);
    if (!result) {
      return sol::nil;
    }

    return symbol_info_to_lua(lua, *result);
  });

  // === resolve symbol name to address ===
  w1_module.set_function(
      "symbol_resolve_name", [&lua](const std::string& name, sol::optional<std::string> module_hint) -> sol::object {
        ensure_symbol_system_initialized();

        std::string hint = module_hint.value_or("");
        auto result = g_symbol_resolver->resolve_name(name, hint);

        if (!result) {
          return sol::nil;
        }

        return sol::make_object(lua, *result);
      }
  );

  // === find symbols by pattern ===
  w1_module.set_function(
      "symbol_find_pattern", [&lua](const std::string& pattern, sol::optional<std::string> module_hint) -> sol::table {
        ensure_symbol_system_initialized();

        std::string hint = module_hint.value_or("");
        auto results = g_symbol_resolver->find_symbols(pattern, hint);

        sol::table symbol_table = lua.create_table();
        int index = 1;
        for (const auto& info : results) {
          symbol_table[index++] = symbol_info_to_lua(lua, info);
        }

        return symbol_table;
      }
  );

  // === get all symbols from a module ===
  w1_module.set_function("symbol_get_module_symbols", [&lua](const std::string& module_path) -> sol::table {
    ensure_symbol_system_initialized();

    auto results = g_symbol_resolver->get_module_symbols(module_path);

    sol::table symbol_table = lua.create_table();
    int index = 1;
    for (const auto& info : results) {
      symbol_table[index++] = symbol_info_to_lua(lua, info);
    }

    return symbol_table;
  });

  // === resolve symbol in specific module ===
  w1_module.set_function(
      "symbol_resolve_in_module", [&lua](const std::string& module_path, uint64_t offset) -> sol::object {
        ensure_symbol_system_initialized();

        auto result = g_symbol_resolver->resolve_in_module(module_path, offset);
        if (!result) {
          return sol::nil;
        }

        return symbol_info_to_lua(lua, *result);
      }
  );

  // === get active backend name ===
  w1_module.set_function("symbol_get_backend", []() -> std::string {
    ensure_symbol_system_initialized();
    return g_symbol_resolver->get_backend_name();
  });

  // === clear symbol cache ===
  w1_module.set_function("symbol_clear_cache", []() {
    ensure_symbol_system_initialized();
    g_symbol_resolver->clear_cache();

    auto log = redlog::get_logger("w1.script_symbol");
    log.dbg("symbol cache cleared");
  });

  // === get cache statistics ===
  w1_module.set_function("symbol_get_cache_stats", [&lua]() -> sol::table {
    ensure_symbol_system_initialized();

    auto stats = g_symbol_resolver->get_cache_stats();

    sol::table stats_table = lua.create_table();
    stats_table["size"] = stats.size;
    stats_table["hits"] = stats.hits;
    stats_table["misses"] = stats.misses;
    stats_table["hit_rate"] = stats.hit_rate;

    return stats_table;
  });

  // === rescan modules (useful after dynamic loading) ===
  w1_module.set_function("symbol_rescan_modules", []() -> bool {
    try {
      if (!g_module_scanner) {
        g_module_scanner = std::make_unique<w1::util::module_scanner>();
      }
      if (!g_module_index) {
        g_module_index = std::make_unique<w1::util::module_range_index>();
      }

      // scan modules and rebuild index
      auto modules = g_module_scanner->scan_executable_modules();
      size_t module_count = modules.size();
      g_module_index->rebuild_from_modules(std::move(modules));

      auto log = redlog::get_logger("w1.script_symbol");
      log.inf("module rescan for symbols completed", redlog::field("modules", module_count));

      return true;
    } catch (const std::exception& e) {
      auto log = redlog::get_logger("w1.script_symbol");
      log.err("module rescan failed", redlog::field("error", e.what()));
      return false;
    }
  });

  logger.dbg("symbol resolution functions setup complete");
}

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/symbol_resolution.hpp`:

```hpp
#pragma once

#include <sol/sol.hpp>

namespace w1::tracers::script::bindings {

/**
 * @brief setup symbol resolution functions in lua environment
 * @details provides api for symbol lookup by address or name, pattern matching,
 *          and module symbol enumeration
 *
 * exposed functions:
 * - symbol_resolve_address(address) -> table with symbol info or nil
 * - symbol_resolve_name(name, module_hint) -> address or nil
 * - symbol_find_pattern(pattern, module_hint) -> array of symbol info tables
 * - symbol_get_module_symbols(module_path) -> array of symbol info tables
 * - symbol_get_backend() -> string describing active backend
 * - symbol_clear_cache() -> clears symbol resolution cache
 */
void setup_symbol_resolution(sol::state& lua, sol::table& w1_module);

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/utilities.cpp`:

```cpp
#include "utilities.hpp"
#include <w1common/platform_utils.hpp>
#include <w1tn3ss/util/jsonl_writer.hpp>
#include <redlog.hpp>
#include <fstream>
#include <chrono>
#include <iomanip>
#include <sstream>
#include <vector>
#include <algorithm>
#include <cmath>

namespace w1::tracers::script::bindings {

// forward declarations for internal functions
static std::string serialize_lua_value(const sol::object& value, int depth = 0);
static std::string lua_table_to_json_internal(const sol::table& lua_table, int depth);

void setup_utilities(sol::state& lua, sol::table& w1_module) {
  auto logger = redlog::get_logger("w1.script_bindings");
  logger.dbg("setting up utility functions");

  // === Logging Functions ===
  // these provide integration with the redlog logging system

  w1_module.set_function("log_info", [](const std::string& msg) {
    auto log = redlog::get_logger("w1.script_lua");
    log.inf(msg);
  });

  w1_module.set_function("log_debug", [](const std::string& msg) {
    auto log = redlog::get_logger("w1.script_lua");
    log.dbg(msg);
  });

  w1_module.set_function("log_error", [](const std::string& msg) {
    auto log = redlog::get_logger("w1.script_lua");
    log.err(msg);
  });

  w1_module.set_function("log_warning", [](const std::string& msg) {
    auto log = redlog::get_logger("w1.script_lua");
    log.wrn(msg);
  });

  // === File I/O Functions ===
  // these provide safe file operations for data output

  w1_module.set_function("write_file", [](const std::string& filename, const std::string& content) -> bool {
    try {
      std::ofstream file(filename);
      if (file.is_open()) {
        file << content;
        file.close();
        return true;
      }
    } catch (...) {
      // log error but don't throw - return false instead
      auto log = redlog::get_logger("w1.script_lua");
      log.err("failed to write file: " + filename);
    }
    return false;
  });

  w1_module.set_function("append_file", [](const std::string& filename, const std::string& content) -> bool {
    try {
      std::ofstream file(filename, std::ios::app);
      if (file.is_open()) {
        file << content;
        file.close();
        return true;
      }
    } catch (...) {
      // log error but don't throw - return false instead
      auto log = redlog::get_logger("w1.script_lua");
      log.err("failed to append to file: " + filename);
    }
    return false;
  });

  // === JSON Serialization ===
  // convert Lua tables to JSON strings for structured output

  w1_module.set_function("to_json", [](const sol::table& lua_table) -> std::string {
    return lua_table_to_json(lua_table);
  });

  // === Timestamp Functions ===
  // generate timestamps for logging and data collection

  w1_module.set_function("get_timestamp", []() -> std::string {
    auto now = std::chrono::system_clock::now();
    auto time_t = std::chrono::system_clock::to_time_t(now);
    auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()) % 1000;

    std::stringstream ss;
    ss << std::put_time(std::gmtime(&time_t), "%Y-%m-%dT%H:%M:%S");
    ss << '.' << std::setfill('0') << std::setw(3) << ms.count() << 'Z';
    return ss.str();
  });

  w1_module.set_function("get_unix_timestamp", []() -> int64_t {
    auto now = std::chrono::system_clock::now();
    return std::chrono::duration_cast<std::chrono::seconds>(now.time_since_epoch()).count();
  });

  w1_module.set_function("get_millisecond_timestamp", []() -> int64_t {
    auto now = std::chrono::system_clock::now();
    return std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();
  });

  // === String Utilities ===
  // additional string manipulation functions

  w1_module.set_function("escape_string", [](const std::string& str) -> std::string {
    return escape_json_string(str);
  });

  w1_module.set_function("trim_string", [](const std::string& str) -> std::string {
    auto start = str.find_first_not_of(" \t\n\r");
    if (start == std::string::npos) {
      return "";
    }
    auto end = str.find_last_not_of(" \t\n\r");
    return str.substr(start, end - start + 1);
  });

  // === Platform Detection Functions ===
  // get platform and architecture information

  w1_module.set_function("get_platform", []() -> std::string {
    return w1::common::platform_utils::get_platform_name();
  });

  w1_module.set_function("get_architecture", []() -> std::string {
#if defined(__x86_64__) || defined(_M_X64)
    return "x86_64";
#elif defined(__i386__) || defined(_M_IX86)
    return "x86";
#elif defined(__arm__) || defined(_M_ARM)
    return "arm";
#elif defined(__aarch64__) || defined(_M_ARM64)
    return "aarch64";
#else
    return "unknown";
#endif
  });

  w1_module.set_function("get_platform_info", [&lua]() -> sol::table {
    sol::table info = lua.create_table();

    info["os"] = w1::common::platform_utils::get_platform_name();

#if defined(__x86_64__) || defined(_M_X64)
    info["arch"] = "x86_64";
    info["bits"] = 64;
#elif defined(__i386__) || defined(_M_IX86)
    info["arch"] = "x86";
    info["bits"] = 32;
#elif defined(__arm__) || defined(_M_ARM)
    info["arch"] = "arm";
    info["bits"] = 32;
#elif defined(__aarch64__) || defined(_M_ARM64)
    info["arch"] = "aarch64";
    info["bits"] = 64;
#else
    info["arch"] = "unknown";
    info["bits"] = 0;
#endif

    return info;
  });

  // === JSONL Writer Functions ===
  // low-level jsonl functions for compatibility
  // note: prefer using w1.output module for high-level api

  static std::shared_ptr<w1::util::jsonl_writer> jsonl_writer_instance;

  w1_module.set_function("jsonl_open", [](const std::string& filename) -> bool {
    try {
      // close any existing writer
      if (jsonl_writer_instance && jsonl_writer_instance->is_open()) {
        jsonl_writer_instance->close();
      }

      // create new writer instance
      jsonl_writer_instance = std::make_shared<w1::util::jsonl_writer>(filename);

      if (!jsonl_writer_instance->is_open()) {
        auto log = redlog::get_logger("w1.script_lua");
        log.err("failed to open jsonl file: " + filename);
        jsonl_writer_instance.reset();
        return false;
      }

      return true;
    } catch (const std::exception& e) {
      auto log = redlog::get_logger("w1.script_lua");
      log.err("jsonl_open error: " + std::string(e.what()));
      return false;
    }
  });

  w1_module.set_function("jsonl_write", [](const sol::object& data) -> bool {
    if (!jsonl_writer_instance || !jsonl_writer_instance->is_open()) {
      return false;
    }

    try {
      std::string json_line;

      // handle different input types
      if (data.is<sol::table>()) {
        json_line = lua_table_to_json(data.as<sol::table>());
      } else if (data.is<std::string>()) {
        // assume it's already json if it's a string
        json_line = data.as<std::string>();
      } else {
        // try to serialize as a simple value
        json_line = serialize_lua_value(data);
      }

      return jsonl_writer_instance->write_line(json_line);
    } catch (const std::exception& e) {
      auto log = redlog::get_logger("w1.script_lua");
      log.err("jsonl_write error: " + std::string(e.what()));
      return false;
    }
  });

  w1_module.set_function("jsonl_close", []() {
    if (jsonl_writer_instance && jsonl_writer_instance->is_open()) {
      jsonl_writer_instance->close();
    }
    jsonl_writer_instance.reset();
  });

  w1_module.set_function("jsonl_is_open", []() -> bool {
    return jsonl_writer_instance && jsonl_writer_instance->is_open();
  });

  w1_module.set_function("jsonl_flush", []() {
    if (jsonl_writer_instance && jsonl_writer_instance->is_open()) {
      jsonl_writer_instance->flush();
    }
  });

  logger.dbg("utility functions setup complete");
}

// === JSON Serialization Implementation ===

std::string escape_json_string(const std::string& str) {
  std::stringstream ss;
  ss << "\"";
  for (char c : str) {
    switch (c) {
    case '"':
      ss << "\\\"";
      break;
    case '\\':
      ss << "\\\\";
      break;
    case '\b':
      ss << "\\b";
      break;
    case '\f':
      ss << "\\f";
      break;
    case '\n':
      ss << "\\n";
      break;
    case '\r':
      ss << "\\r";
      break;
    case '\t':
      ss << "\\t";
      break;
    default:
      if (c < 0x20) {
        ss << "\\u" << std::hex << std::setw(4) << std::setfill('0') << static_cast<unsigned char>(c);
      } else {
        ss << c;
      }
      break;
    }
  }
  ss << "\"";
  return ss.str();
}

bool is_lua_array(const sol::table& table) {
  if (table.empty()) {
    return false;
  }

  std::vector<int> indices;
  bool has_non_int_keys = false;

  for (const auto& pair : table) {
    if (pair.first.is<int>()) {
      indices.push_back(pair.first.as<int>());
    } else {
      has_non_int_keys = true;
      break;
    }
  }

  if (has_non_int_keys || indices.empty()) {
    return false;
  }

  // sort indices and check if they're consecutive starting from 1
  std::sort(indices.begin(), indices.end());
  for (size_t i = 0; i < indices.size(); i++) {
    if (indices[i] != static_cast<int>(i + 1)) {
      return false;
    }
  }

  return true;
}

static std::string serialize_lua_value(const sol::object& value, int depth) {
  // prevent infinite recursion
  if (depth > 32) {
    return "\"[max_depth_exceeded]\"";
  }

  if (!value.valid()) {
    return "null";
  } else if (value.is<sol::nil_t>()) {
    return "null";
  } else if (value.is<bool>()) {
    return value.as<bool>() ? "true" : "false";
  } else if (value.is<int>()) {
    return std::to_string(value.as<int>());
  } else if (value.is<double>()) {
    double d = value.as<double>();
    if (std::isfinite(d)) {
      return std::to_string(d);
    } else {
      return "null"; // json doesn't support NaN/Infinity
    }
  } else if (value.is<float>()) {
    float f = value.as<float>();
    if (std::isfinite(f)) {
      return std::to_string(f);
    } else {
      return "null";
    }
  } else if (value.is<std::string>()) {
    return escape_json_string(value.as<std::string>());
  } else if (value.is<const char*>()) {
    return escape_json_string(std::string(value.as<const char*>()));
  } else if (value.is<sol::table>()) {
    return lua_table_to_json_internal(value.as<sol::table>(), depth + 1);
  } else {
    // fallback: try to convert to string
    try {
      std::string str_repr = value.as<std::string>();
      return escape_json_string(str_repr);
    } catch (...) {
      return "null";
    }
  }
}

static std::string lua_table_to_json_internal(const sol::table& lua_table, int depth) {
  try {
    // prevent infinite recursion
    if (depth > 32) {
      return "{\"error\":\"max_recursion_depth_exceeded\"}";
    }

    std::stringstream json_stream;

    if (is_lua_array(lua_table)) {
      // serialize as JSON array
      json_stream << "[";
      bool first = true;

      for (size_t i = 1; i <= lua_table.size(); i++) {
        if (!first) {
          json_stream << ",";
        }
        json_stream << serialize_lua_value(lua_table[i], depth);
        first = false;
      }

      json_stream << "]";
    } else {
      // serialize as JSON object
      json_stream << "{";
      bool first = true;

      for (const auto& pair : lua_table) {
        if (!first) {
          json_stream << ",";
        }

        // convert key to string
        std::string key;
        if (pair.first.is<std::string>()) {
          key = pair.first.as<std::string>();
        } else if (pair.first.is<int>()) {
          key = std::to_string(pair.first.as<int>());
        } else if (pair.first.is<double>()) {
          key = std::to_string(pair.first.as<double>());
        } else {
          // try to convert to string as fallback
          try {
            key = pair.first.as<std::string>();
          } catch (...) {
            continue; // Skip unsupported key types
          }
        }

        json_stream << escape_json_string(key) << ":" << serialize_lua_value(pair.second, depth);
        first = false;
      }

      json_stream << "}";
    }

    return json_stream.str();

  } catch (const std::exception& e) {
    return "{\"error\":\"json_serialization_failed\",\"details\":\"" + std::string(e.what()) + "\"}";
  } catch (...) {
    return "{\"error\":\"unknown_json_serialization_error\"}";
  }
}

std::string lua_table_to_json(const sol::table& lua_table) { return lua_table_to_json_internal(lua_table, 0); }

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/utilities.hpp`:

```hpp
#pragma once

#include <sol/sol.hpp>
#include <string>

namespace w1::tracers::script::bindings {

/**
 * @brief Setup utility functions for Lua bindings
 *
 * This module provides essential utility functions for Lua scripts, including:
 * - Logging functions (info, debug, error) integrated with the redlog system
 * - File I/O operations (write, append) for output generation
 * - JSON serialization for converting Lua tables to JSON strings
 * - Timestamp generation for logging and data collection
 *
 * These utilities enable Lua scripts to perform common operations like
 * logging messages, saving data to files, and generating structured output.
 *
 * @param lua The Sol2 Lua state to register bindings with
 * @param w1_module The w1 module table to add bindings to
 */
void setup_utilities(sol::state& lua, sol::table& w1_module);

// helper functions for JSON serialization
// these are exposed in the header for potential reuse by other modules

/**
 * @brief Convert a Lua table to JSON string
 * @param lua_table The Lua table to convert
 * @return JSON string representation
 */
std::string lua_table_to_json(const sol::table& lua_table);

/**
 * @brief Escape a string for JSON format
 * @param str The string to escape
 * @return JSON-escaped string with quotes
 */
std::string escape_json_string(const std::string& str);

/**
 * @brief Check if a Lua table should be serialized as JSON array
 * @param table The table to check
 * @return true if table has consecutive integer keys starting from 1
 */
bool is_lua_array(const sol::table& table);

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/vm_control.cpp`:

```cpp
#include "vm_control.hpp"
#include <redlog.hpp>
#include <cstdio>

namespace w1::tracers::script::bindings {

void setup_vm_control(sol::state& lua, sol::table& w1_module) {
  auto logger = redlog::get_logger("w1.script_bindings");
  logger.dbg("setting up vm control and instruction analysis functions");

  // address formatting utility
  // formats a QBDI::rword address as a hex string with consistent width
  w1_module.set_function("format_address", [](QBDI::rword addr) -> std::string {
    char buffer[32];
    snprintf(buffer, sizeof(buffer), "0x%016lx", static_cast<unsigned long>(addr));
    return std::string(buffer);
  });

  // get disassembly of the current instruction
  // returns the assembly language representation of the instruction being executed
  w1_module.set_function("get_disassembly", [](void* vm_ptr) -> std::string {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    const QBDI::InstAnalysis* analysis = vm->getInstAnalysis();
    if (analysis && analysis->disassembly) {
      return std::string(analysis->disassembly);
    }
    return "unknown";
  });

  // get the current instruction analysis
  // returns a pointer to the InstAnalysis structure for the current instruction
  // note: this returns lightuserdata that should be used with InstAnalysis usertype
  w1_module.set_function("get_inst_analysis", [](void* vm_ptr) -> const QBDI::InstAnalysis* {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    return vm->getInstAnalysis();
  });

  // get the current instruction address from analysis
  // alternative to reading from register state
  w1_module.set_function("get_inst_address", [](void* vm_ptr) -> QBDI::rword {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    const QBDI::InstAnalysis* analysis = vm->getInstAnalysis();
    if (analysis) {
      return analysis->address;
    }
    return 0;
  });

  // get the size of the current instruction
  w1_module.set_function("get_inst_size", [](void* vm_ptr) -> uint32_t {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    const QBDI::InstAnalysis* analysis = vm->getInstAnalysis();
    if (analysis) {
      return analysis->instSize;
    }
    return 0;
  });

  // check if current instruction affects control flow
  w1_module.set_function("inst_affects_control_flow", [](void* vm_ptr) -> bool {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    const QBDI::InstAnalysis* analysis = vm->getInstAnalysis();
    if (analysis) {
      return analysis->affectControlFlow;
    }
    return false;
  });

  // check if current instruction is a branch
  w1_module.set_function("inst_is_branch", [](void* vm_ptr) -> bool {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    const QBDI::InstAnalysis* analysis = vm->getInstAnalysis();
    if (analysis) {
      return analysis->isBranch;
    }
    return false;
  });

  // check if current instruction is a call
  w1_module.set_function("inst_is_call", [](void* vm_ptr) -> bool {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    const QBDI::InstAnalysis* analysis = vm->getInstAnalysis();
    if (analysis) {
      return analysis->isCall;
    }
    return false;
  });

  // check if current instruction is a return
  w1_module.set_function("inst_is_return", [](void* vm_ptr) -> bool {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    const QBDI::InstAnalysis* analysis = vm->getInstAnalysis();
    if (analysis) {
      return analysis->isReturn;
    }
    return false;
  });

  // check if current instruction may load from memory
  w1_module.set_function("inst_may_load", [](void* vm_ptr) -> bool {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    const QBDI::InstAnalysis* analysis = vm->getInstAnalysis();
    if (analysis) {
      return analysis->mayLoad;
    }
    return false;
  });

  // check if current instruction may store to memory
  w1_module.set_function("inst_may_store", [](void* vm_ptr) -> bool {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    const QBDI::InstAnalysis* analysis = vm->getInstAnalysis();
    if (analysis) {
      return analysis->mayStore;
    }
    return false;
  });

  // execution control methods

  // execute code from start to stop address
  // returns true if at least one block was executed
  w1_module.set_function("run", [](void* vm_ptr, QBDI::rword start, QBDI::rword stop) -> bool {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    try {
      return vm->run(start, stop);
    } catch (const std::exception& e) {
      auto log = redlog::get_logger("w1.script_bindings");
      log.err("error in run(): " + std::string(e.what()));
      return false;
    }
  });

  // call a function with DBI using current VM state
  // returns true if at least one block was executed
  w1_module.set_function(
      "call",
      [](void* vm_ptr, sol::optional<QBDI::rword*> retval_ptr, QBDI::rword function,
         sol::optional<sol::table> args_table) -> bool {
        QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
        try {
          std::vector<QBDI::rword> args;
          if (args_table) {
            // convert Lua table to vector of rword arguments
            for (auto& pair : *args_table) {
              if (pair.second.is<QBDI::rword>()) {
                args.push_back(pair.second.as<QBDI::rword>());
              }
            }
          }
          QBDI::rword* retval = retval_ptr ? *retval_ptr : nullptr;
          return vm->call(retval, function, args);
        } catch (const std::exception& e) {
          auto log = redlog::get_logger("w1.script_bindings");
          log.err("error in call(): " + std::string(e.what()));
          return false;
        }
      }
  );

  // get current VM options
  w1_module.set_function("getOptions", [](void* vm_ptr) -> QBDI::Options {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    return vm->getOptions();
  });

  // set VM options (clears cache if options change)
  w1_module.set_function("setOptions", [](void* vm_ptr, QBDI::Options options) -> void {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    try {
      vm->setOptions(options);
    } catch (const std::exception& e) {
      auto log = redlog::get_logger("w1.script_bindings");
      log.err("error in setOptions(): " + std::string(e.what()));
    }
  });

  // instrumentation range management

  // add an address range to instrumented ranges
  w1_module.set_function("addInstrumentedRange", [](void* vm_ptr, QBDI::rword start, QBDI::rword end) -> void {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    try {
      vm->addInstrumentedRange(start, end);
    } catch (const std::exception& e) {
      auto log = redlog::get_logger("w1.script_bindings");
      log.err("error in addInstrumentedRange(): " + std::string(e.what()));
    }
  });

  // add a module by name to instrumented ranges
  // returns true if at least one range was added
  w1_module.set_function("addInstrumentedModule", [](void* vm_ptr, const std::string& name) -> bool {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    try {
      return vm->addInstrumentedModule(name);
    } catch (const std::exception& e) {
      auto log = redlog::get_logger("w1.script_bindings");
      log.err("error in addInstrumentedModule(): " + std::string(e.what()));
      return false;
    }
  });

  // add a module containing the given address to instrumented ranges
  // returns true if at least one range was added
  w1_module.set_function("addInstrumentedModuleFromAddr", [](void* vm_ptr, QBDI::rword addr) -> bool {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    try {
      return vm->addInstrumentedModuleFromAddr(addr);
    } catch (const std::exception& e) {
      auto log = redlog::get_logger("w1.script_bindings");
      log.err("error in addInstrumentedModuleFromAddr(): " + std::string(e.what()));
      return false;
    }
  });

  // remove an address range from instrumented ranges
  w1_module.set_function("removeInstrumentedRange", [](void* vm_ptr, QBDI::rword start, QBDI::rword end) -> void {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    try {
      vm->removeInstrumentedRange(start, end);
    } catch (const std::exception& e) {
      auto log = redlog::get_logger("w1.script_bindings");
      log.err("error in removeInstrumentedRange(): " + std::string(e.what()));
    }
  });

  // remove all instrumented ranges
  w1_module.set_function("removeAllInstrumentedRanges", [](void* vm_ptr) -> void {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    try {
      vm->removeAllInstrumentedRanges();
    } catch (const std::exception& e) {
      auto log = redlog::get_logger("w1.script_bindings");
      log.err("error in removeAllInstrumentedRanges(): " + std::string(e.what()));
    }
  });

  // state management

  // get current GPR state
  // returns pointer to GPRState structure - handle with care in Lua
  w1_module.set_function("getGPRState", [](void* vm_ptr) -> QBDI::GPRState* {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    return vm->getGPRState();
  });

  // set GPR state from pointer
  w1_module.set_function("setGPRState", [](void* vm_ptr, const QBDI::GPRState* state) -> void {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    try {
      vm->setGPRState(state);
    } catch (const std::exception& e) {
      auto log = redlog::get_logger("w1.script_bindings");
      log.err("error in setGPRState(): " + std::string(e.what()));
    }
  });

  // get current FPR state
  // returns pointer to FPRState structure - handle with care in Lua
  w1_module.set_function("getFPRState", [](void* vm_ptr) -> QBDI::FPRState* {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    return vm->getFPRState();
  });

  // set FPR state from pointer
  w1_module.set_function("setFPRState", [](void* vm_ptr, const QBDI::FPRState* state) -> void {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    try {
      vm->setFPRState(state);
    } catch (const std::exception& e) {
      auto log = redlog::get_logger("w1.script_bindings");
      log.err("error in setFPRState(): " + std::string(e.what()));
    }
  });

  // cache control

  // clear cache for specific address range
  w1_module.set_function("clearCache", [](void* vm_ptr, QBDI::rword start, QBDI::rword end) -> void {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    try {
      vm->clearCache(start, end);
    } catch (const std::exception& e) {
      auto log = redlog::get_logger("w1.script_bindings");
      log.err("error in clearCache(): " + std::string(e.what()));
    }
  });

  // clear entire translation cache
  w1_module.set_function("clearAllCache", [](void* vm_ptr) -> void {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    try {
      vm->clearAllCache();
    } catch (const std::exception& e) {
      auto log = redlog::get_logger("w1.script_bindings");
      log.err("error in clearAllCache(): " + std::string(e.what()));
    }
  });

  // pre-cache a basic block for optimization
  // returns true if block was cached successfully
  w1_module.set_function("precacheBasicBlock", [](void* vm_ptr, QBDI::rword pc) -> bool {
    QBDI::VMInstanceRef vm = static_cast<QBDI::VMInstanceRef>(vm_ptr);
    try {
      return vm->precacheBasicBlock(pc);
    } catch (const std::exception& e) {
      auto log = redlog::get_logger("w1.script_bindings");
      log.err("error in precacheBasicBlock(): " + std::string(e.what()));
      return false;
    }
  });

  // memory layout functions

  // get current process memory maps
  // returns a Lua table with memory map information
  w1_module.set_function("getCurrentProcessMaps", [&lua]() -> sol::table {
    sol::state_view lua_view = lua.lua_state();
    sol::table result = lua_view.create_table();

    try {
      size_t size = 0;
      // note: using simplified implementation - full memory maps require platform-specific code
      sol::table result = lua_view.create_table();

      // simplified memory map - would need platform-specific implementation for full functionality
      auto log = redlog::get_logger("w1.script_bindings");
      log.wrn("getCurrentProcessMaps not fully implemented - returning empty table");
    } catch (const std::exception& e) {
      auto log = redlog::get_logger("w1.script_bindings");
      log.err("error in getCurrentProcessMaps(): " + std::string(e.what()));
    }

    return result;
  });

  // get list of loaded module names
  // returns a Lua table with module names
  w1_module.set_function("getModuleNames", [&lua]() -> sol::table {
    sol::state_view lua_view = lua.lua_state();
    sol::table result = lua_view.create_table();

    try {
      size_t size = 0;
      // note: using simplified implementation - full module enumeration requires platform-specific code
      sol::table result = lua_view.create_table();

      // simplified module names - would need platform-specific implementation for full functionality
      auto log = redlog::get_logger("w1.script_bindings");
      log.wrn("getModuleNames not fully implemented - returning empty table");
    } catch (const std::exception& e) {
      auto log = redlog::get_logger("w1.script_bindings");
      log.err("error in getModuleNames(): " + std::string(e.what()));
    }

    return result;
  });

  logger.dbg("vm control functions setup complete");
}

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/bindings/vm_control.hpp`:

```hpp
/**
 * @file vm_control.hpp
 * @brief VM control and instruction analysis bindings for w1script
 *
 * This module exposes QBDI VM control methods and instruction analysis capabilities
 * to Lua scripts. Includes execution control, instrumentation management, state
 * inspection, and advanced instruction analysis functions.
 *
 * @author w1tn3ss Development Team
 * @date 2025
 */

#pragma once

#include <sol/sol.hpp>
#include <QBDI.h>

namespace w1::tracers::script::bindings {

/**
 * @brief Setup VM control and instruction analysis functions for Lua bindings
 *
 * This module provides functions for controlling and analyzing the QBDI VM state,
 * including:
 * - Instruction disassembly retrieval
 * - Address formatting utilities
 * - VM state inspection functions
 *
 * These functions allow Lua scripts to examine the current instruction being
 * executed and make decisions about VM control flow.
 *
 * @param lua The Sol2 Lua state to register bindings with
 * @param w1_module The w1 module table to add bindings to
 */
void setup_vm_control(sol::state& lua, sol::table& w1_module);

} // namespace w1::tracers::script::bindings
```

`src/tracers/w1script/callback_manager.cpp`:

```cpp
#include "callback_manager.hpp"
#include "api_analysis_processor.hpp"
#include "bindings/api_analysis.hpp"
#include <w1tn3ss/util/module_range_index.hpp>
#include <w1tn3ss/symbols/symbol_resolver.hpp>
#include <algorithm>

namespace w1::tracers::script {

namespace {
// mapping of string names to callback types
const std::unordered_map<std::string, callback_manager::callback_type> callback_name_map = {
    {"instruction_preinst", callback_manager::callback_type::instruction_preinst},
    {"instruction_postinst", callback_manager::callback_type::instruction_postinst},
    {"sequence_entry", callback_manager::callback_type::sequence_entry},
    {"sequence_exit", callback_manager::callback_type::sequence_exit},
    {"basic_block_entry", callback_manager::callback_type::basic_block_entry},
    {"basic_block_exit", callback_manager::callback_type::basic_block_exit},
    {"basic_block_new", callback_manager::callback_type::basic_block_new},
    {"exec_transfer_call", callback_manager::callback_type::exec_transfer_call},
    {"exec_transfer_return", callback_manager::callback_type::exec_transfer_return},
    {"memory_read", callback_manager::callback_type::memory_read},
    {"memory_write", callback_manager::callback_type::memory_write},
    {"memory_read_write", callback_manager::callback_type::memory_read_write},
    {"code_addr", callback_manager::callback_type::code_addr},
    {"code_range", callback_manager::callback_type::code_range},
    {"mnemonic", callback_manager::callback_type::mnemonic},
    {"mem_addr", callback_manager::callback_type::mem_addr},
    {"mem_range", callback_manager::callback_type::mem_range},
    {"instr_rule", callback_manager::callback_type::instr_rule},
    {"instr_rule_range", callback_manager::callback_type::instr_rule_range},
    {"instr_rule_range_set", callback_manager::callback_type::instr_rule_range_set}
};

// mapping of callback types to lua function names
const std::unordered_map<callback_manager::callback_type, std::string> lua_function_names = {
    {callback_manager::callback_type::instruction_preinst, "on_instruction_preinst"},
    {callback_manager::callback_type::instruction_postinst, "on_instruction_postinst"},
    {callback_manager::callback_type::sequence_entry, "on_sequence_entry"},
    {callback_manager::callback_type::sequence_exit, "on_sequence_exit"},
    {callback_manager::callback_type::basic_block_entry, "on_basic_block_entry"},
    {callback_manager::callback_type::basic_block_exit, "on_basic_block_exit"},
    {callback_manager::callback_type::basic_block_new, "on_basic_block_new"},
    {callback_manager::callback_type::exec_transfer_call, "on_exec_transfer_call"},
    {callback_manager::callback_type::exec_transfer_return, "on_exec_transfer_return"},
    {callback_manager::callback_type::memory_read, "on_memory_read"},
    {callback_manager::callback_type::memory_write, "on_memory_write"},
    {callback_manager::callback_type::memory_read_write, "on_memory_read_write"},
    {callback_manager::callback_type::code_addr, "on_code_addr"},
    {callback_manager::callback_type::code_range, "on_code_range"},
    {callback_manager::callback_type::mnemonic, "on_mnemonic"},
    {callback_manager::callback_type::mem_addr, "on_mem_addr"},
    {callback_manager::callback_type::mem_range, "on_mem_range"},
    {callback_manager::callback_type::instr_rule, "on_instr_rule"},
    {callback_manager::callback_type::instr_rule_range, "on_instr_rule_range"},
    {callback_manager::callback_type::instr_rule_range_set, "on_instr_rule_range_set"}
};
} // namespace

callback_manager::callback_manager() : logger_(redlog::get_logger("w1.callback_manager")) {}

std::optional<callback_manager::callback_type> callback_manager::string_to_callback_type(const std::string& name) {
  auto it = callback_name_map.find(name);
  if (it != callback_name_map.end()) {
    return it->second;
  }
  return std::nullopt;
}

std::string callback_manager::get_lua_function_name(callback_type type) {
  auto it = lua_function_names.find(type);
  if (it != lua_function_names.end()) {
    return it->second;
  }
  return "";
}

void callback_manager::setup_callbacks(const sol::table& script_table) {
  if (!script_table.valid()) {
    return;
  }

  // get the callbacks list from the script
  sol::optional<sol::table> callbacks_table = script_table["callbacks"];
  if (callbacks_table) {
    for (const auto& pair : callbacks_table.value()) {
      if (pair.second.get_type() == sol::type::string) {
        std::string callback_name = pair.second.as<std::string>();
        auto callback_type = string_to_callback_type(callback_name);
        if (callback_type) {
          enabled_callbacks_.insert(callback_type.value());
          logger_.dbg("found callback", redlog::field("name", callback_name));
        } else {
          logger_.wrn("unknown callback name", redlog::field("name", callback_name));
        }
      }
    }
  }

  // get callback functions from the script
  for (const auto& [type, lua_name] : lua_function_names) {
    sol::function callback_fn = script_table[lua_name];
    if (callback_fn.valid()) {
      lua_callbacks_[type] = callback_fn;
    }
  }

  logger_.inf(
      "callbacks setup complete", redlog::field("enabled", enabled_callbacks_.size()),
      redlog::field("functions", lua_callbacks_.size())
  );
}

void callback_manager::register_callbacks(QBDI::VM* vm) {
  logger_.inf("registering callbacks dynamically based on script requirements");

  // instruction callbacks (addCodeCB)
  if (is_callback_enabled(callback_type::instruction_preinst)) {
    uint32_t id = vm->addCodeCB(
        QBDI::PREINST, [this](QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr) -> QBDI::VMAction {
          return this->dispatch_simple_callback(callback_type::instruction_preinst, vm, gpr, fpr);
        }
    );
    if (id != QBDI::INVALID_EVENTID) {
      registered_callback_ids_.push_back(id);
      logger_.inf("registered instruction_preinst callback", redlog::field("id", id));
    }
  }

  if (is_callback_enabled(callback_type::instruction_postinst)) {
    uint32_t id = vm->addCodeCB(
        QBDI::POSTINST, [this](QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr) -> QBDI::VMAction {
          return this->dispatch_simple_callback(callback_type::instruction_postinst, vm, gpr, fpr);
        }
    );
    if (id != QBDI::INVALID_EVENTID) {
      registered_callback_ids_.push_back(id);
      logger_.inf("registered instruction_postinst callback", redlog::field("id", id));
    }
  }

  // vm event callbacks (addVMEventCB)
  const std::vector<std::pair<callback_type, QBDI::VMEvent>> vm_events = {
      {callback_type::sequence_entry, QBDI::SEQUENCE_ENTRY},
      {callback_type::sequence_exit, QBDI::SEQUENCE_EXIT},
      {callback_type::basic_block_entry, QBDI::BASIC_BLOCK_ENTRY},
      {callback_type::basic_block_exit, QBDI::BASIC_BLOCK_EXIT},
      {callback_type::basic_block_new, QBDI::BASIC_BLOCK_NEW},
      {callback_type::exec_transfer_call, QBDI::EXEC_TRANSFER_CALL},
      {callback_type::exec_transfer_return, QBDI::EXEC_TRANSFER_RETURN}
  };

  for (const auto& [cb_type, event] : vm_events) {
    if (is_callback_enabled(cb_type)) {
      uint32_t id = vm->addVMEventCB(
          event,
          [this, cb_type](QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr)
              -> QBDI::VMAction { return this->dispatch_vm_event_callback(cb_type, vm, state, gpr, fpr); }
      );
      if (id != QBDI::INVALID_EVENTID) {
        registered_callback_ids_.push_back(id);
        logger_.inf(
            "registered vm event callback", redlog::field("type", static_cast<int>(cb_type)), redlog::field("id", id)
        );
      }
    }
  }

  // memory access callbacks (addMemAccessCB)
  const std::vector<std::pair<callback_type, QBDI::MemoryAccessType>> memory_accesses = {
      {callback_type::memory_read, QBDI::MEMORY_READ},
      {callback_type::memory_write, QBDI::MEMORY_WRITE},
      {callback_type::memory_read_write, QBDI::MEMORY_READ_WRITE}
  };

  for (const auto& [cb_type, access_type] : memory_accesses) {
    if (is_callback_enabled(cb_type)) {
      uint32_t id = vm->addMemAccessCB(
          access_type,
          [this, cb_type](QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr) -> QBDI::VMAction {
            return this->dispatch_simple_callback(cb_type, vm, gpr, fpr);
          }
      );
      if (id != QBDI::INVALID_EVENTID) {
        registered_callback_ids_.push_back(id);
        logger_.inf(
            "registered memory access callback", redlog::field("type", static_cast<int>(cb_type)),
            redlog::field("id", id)
        );
      }
    }
  }

  logger_.inf(
      "dynamic callback registration complete", redlog::field("total_callbacks", registered_callback_ids_.size())
  );
}

QBDI::VMAction callback_manager::dispatch_simple_callback(
    callback_type type, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  auto it = lua_callbacks_.find(type);
  if (it == lua_callbacks_.end() || !it->second.valid()) {
    return QBDI::VMAction::CONTINUE;
  }

  try {
    auto result = it->second(static_cast<void*>(vm), gpr, fpr);
    if (result.valid() && result.get_type() == sol::type::number) {
      return static_cast<QBDI::VMAction>(result.get<int>());
    }
  } catch (const sol::error& e) {
    logger_.err("error in callback", redlog::field("type", static_cast<int>(type)), redlog::field("error", e.what()));
  }
  return QBDI::VMAction::CONTINUE;
}

QBDI::VMAction callback_manager::dispatch_vm_event_callback(
    callback_type type, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  // handle api analysis for exec_transfer events before calling lua
  if (api_processor_ && api_manager_ && module_index_ &&
      (type == callback_type::exec_transfer_call || type == callback_type::exec_transfer_return)) {
    if (type == callback_type::exec_transfer_call) {
      api_processor_->process_call(vm, state, gpr, fpr, api_manager_, module_index_, symbol_resolver_);
    } else {
      api_processor_->process_return(vm, state, gpr, fpr, api_manager_, module_index_, symbol_resolver_);
    }
  }

  auto it = lua_callbacks_.find(type);
  if (it == lua_callbacks_.end() || !it->second.valid()) {
    return QBDI::VMAction::CONTINUE;
  }

  try {
    auto result = it->second(static_cast<void*>(vm), *state, gpr, fpr);
    if (result.valid() && result.get_type() == sol::type::number) {
      return static_cast<QBDI::VMAction>(result.get<int>());
    }
  } catch (const sol::error& e) {
    logger_.err(
        "error in vm event callback", redlog::field("type", static_cast<int>(type)), redlog::field("error", e.what())
    );
  }
  return QBDI::VMAction::CONTINUE;
}

std::vector<QBDI::InstrRuleDataCBK> callback_manager::dispatch_instr_rule_callback(
    callback_type type, QBDI::VMInstanceRef vm, const QBDI::InstAnalysis* analysis, void* data
) {
  auto it = lua_callbacks_.find(type);
  if (it == lua_callbacks_.end() || !it->second.valid()) {
    return {};
  }

  try {
    auto result = it->second(static_cast<void*>(vm), static_cast<const void*>(analysis), data);
    // for now, return empty vector - instruction rules require more complex handling
    return {};
  } catch (const sol::error& e) {
    logger_.err(
        "error in instr rule callback", redlog::field("type", static_cast<int>(type)), redlog::field("error", e.what())
    );
  }
  return {};
}

} // namespace w1::tracers::script
```

`src/tracers/w1script/callback_manager.hpp`:

```hpp
#pragma once

#include <sol/sol.hpp>
#include <QBDI.h>
#include <unordered_map>
#include <unordered_set>
#include <vector>
#include <string>
#include <redlog.hpp>

namespace w1 {
namespace util {
class module_range_index;
}
namespace symbols {
class symbol_resolver;
}
} // namespace w1

namespace w1::tracers::script {

// forward declarations
class api_analysis_processor;
namespace bindings {
class api_analysis_manager;
}

/**
 * manages callback registration and dispatch for script tracer
 * extracted from script_tracer to improve code organization
 */
class callback_manager {
public:
  // callback types enum to replace string-based lookup
  enum class callback_type {
    // instruction callbacks
    instruction_preinst,
    instruction_postinst,

    // vm event callbacks
    sequence_entry,
    sequence_exit,
    basic_block_entry,
    basic_block_exit,
    basic_block_new,
    exec_transfer_call,
    exec_transfer_return,

    // memory access callbacks
    memory_read,
    memory_write,
    memory_read_write,

    // additional callback types
    code_addr,
    code_range,
    mnemonic,
    mem_addr,
    mem_range,
    instr_rule,
    instr_rule_range,
    instr_rule_range_set
  };

private:
  redlog::logger logger_;

  // enabled callbacks from script
  std::unordered_set<callback_type> enabled_callbacks_;

  // lua callback functions
  std::unordered_map<callback_type, sol::function> lua_callbacks_;

  // registered callback IDs from QBDI
  std::vector<uint32_t> registered_callback_ids_;

  // api analysis components (non-owning pointers)
  api_analysis_processor* api_processor_ = nullptr;
  bindings::api_analysis_manager* api_manager_ = nullptr;
  w1::util::module_range_index* module_index_ = nullptr;
  w1::symbols::symbol_resolver* symbol_resolver_ = nullptr;

  // helper to convert string to callback type
  static std::optional<callback_type> string_to_callback_type(const std::string& name);

  // helper to get lua function name for callback type
  static std::string get_lua_function_name(callback_type type);

public:
  callback_manager();

  /**
   * setup callbacks from script table
   * @param script_table The loaded script table
   */
  void setup_callbacks(const sol::table& script_table);

  /**
   * register callbacks with QBDI VM based on script requirements
   * @param vm The QBDI VM instance
   */
  void register_callbacks(QBDI::VM* vm);

  /**
   * set api analysis components for exec_transfer callbacks
   * @param api_processor The API analysis processor
   * @param api_manager The API analysis manager
   * @param module_index The module range index
   * @param symbol_resolver The symbol resolver (may be null)
   */
  void set_api_analysis_components(
      api_analysis_processor* api_processor, bindings::api_analysis_manager* api_manager,
      w1::util::module_range_index* module_index, w1::symbols::symbol_resolver* symbol_resolver
  ) {
    api_processor_ = api_processor;
    api_manager_ = api_manager;
    module_index_ = module_index;
    symbol_resolver_ = symbol_resolver;
  }

  /**
   * check if a callback is enabled
   * @param type The callback type
   * @return True if enabled
   */
  bool is_callback_enabled(callback_type type) const {
    return enabled_callbacks_.find(type) != enabled_callbacks_.end();
  }

  /**
   * get registered callback IDs for cleanup
   * @return Vector of callback IDs
   */
  const std::vector<uint32_t>& get_registered_ids() const { return registered_callback_ids_; }

  // dispatch methods for different callback types
  QBDI::VMAction dispatch_simple_callback(
      callback_type type, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );

  QBDI::VMAction dispatch_vm_event_callback(
      callback_type type, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );

  std::vector<QBDI::InstrRuleDataCBK> dispatch_instr_rule_callback(
      callback_type type, QBDI::VMInstanceRef vm, const QBDI::InstAnalysis* analysis, void* data
  );
};

} // namespace w1::tracers::script
```

`src/tracers/w1script/preload.cpp`:

```cpp
#include <cstring>
#include <memory>

#include "QBDIPreload.h"
#include <redlog.hpp>

#include <w1tn3ss/engine/tracer_engine.hpp>
#include <w1tn3ss/util/env_config.hpp>
#include <w1tn3ss/util/signal_handler.hpp>
#include <w1tn3ss/util/stderr_write.hpp>

#if defined(_WIN32) || defined(WIN32)
#include <w1common/windows_console.hpp>
#endif

#include "script_config.hpp"
#include "script_tracer.hpp"

// globals
static std::unique_ptr<w1::tracers::script::script_tracer> g_tracer;
static std::unique_ptr<w1::tracer_engine<w1::tracers::script::script_tracer>> g_engine;
static w1::tracers::script::config g_config;

namespace {

/**
 * @brief shutdown script tracer with signal-safe error handling
 */
void shutdown_script() {
  if (!g_tracer) {
    return;
  }

  try {
    g_tracer->shutdown();
  } catch (...) {
    // signal-safe error reporting
    const char* error_msg = "w1script: shutdown failed\n";
    w1::util::stderr_write(error_msg);
  }
}

} // anonymous namespace

extern "C" {

QBDIPRELOAD_INIT;

QBDI_EXPORT int qbdipreload_on_run(QBDI::VMInstanceRef vm, QBDI::rword start, QBDI::rword stop) {
  auto logger = redlog::get_logger("w1.script_preload");

  logger.inf("qbdipreload_on_run called");

  // get config
  g_config = w1::tracers::script::config::from_environment();

  if (!g_config.is_valid()) {
    logger.err("invalid configuration - W1SCRIPT_SCRIPT must be specified");
    return QBDIPRELOAD_ERR_STARTUP_FAILED;
  }

  w1::util::env_config config_loader("W1SCRIPT_");
  int debug_level = config_loader.get<int>("VERBOSE", 0);

  // set log level based on debug level
  if (debug_level >= 4) {
    redlog::set_level(redlog::level::pedantic);
  } else if (debug_level >= 3) {
    redlog::set_level(redlog::level::debug);
  } else if (debug_level >= 2) {
    redlog::set_level(redlog::level::trace);
  } else if (debug_level >= 1) {
    redlog::set_level(redlog::level::verbose);
  } else {
    redlog::set_level(redlog::level::info);
  }

  // initialize signal handling for emergency shutdown
  w1::tn3ss::signal_handler::config sig_config;
  sig_config.context_name = "w1script";
  sig_config.log_signals = (debug_level >= 1);

  if (w1::tn3ss::signal_handler::initialize(sig_config)) {
    w1::tn3ss::signal_handler::register_cleanup(
        shutdown_script,
        200, // high priority
        "w1script_shutdown"
    );
    logger.inf("signal handling initialized for script shutdown");
  } else {
    logger.wrn("failed to initialize signal handling - script shutdown on signal unavailable");
  }

  // create tracer
  logger.inf("creating script tracer");
  g_tracer = std::make_unique<w1::tracers::script::script_tracer>();

  // create engine
  logger.inf("creating tracer engine");
  g_engine = std::make_unique<w1::tracer_engine<w1::tracers::script::script_tracer>>(vm, *g_tracer, g_config);

  // initialize tracer
  if (!g_tracer->initialize(*g_engine)) {
    logger.err("script tracer initialization failed");
    return QBDIPRELOAD_ERR_STARTUP_FAILED;
  }

  // instrument
  logger.inf("instrumenting engine");
  if (!g_engine->instrument()) {
    logger.err("engine instrumentation failed");
    return QBDIPRELOAD_ERR_STARTUP_FAILED;
  }

  logger.inf("engine instrumentation successful");

  // run engine
  logger.inf("running engine", redlog::field("start", "0x%08x", start), redlog::field("stop", "0x%08x", stop));
  if (!g_engine->run(start, stop)) {
    logger.err("engine run failed");
    return QBDIPRELOAD_ERR_STARTUP_FAILED;
  }

  // execution doesn't reach here if it works (vm run jumps)
  logger.inf("qbdipreload_on_run completed");

  return QBDIPRELOAD_NO_ERROR;
}

QBDI_EXPORT int qbdipreload_on_exit(int status) {
  auto logger = redlog::get_logger("w1.script_preload");

  logger.inf("qbdipreload_on_exit called", redlog::field("status", status));

  if (g_tracer) {
    logger.inf("shutting down script tracer");

    shutdown_script();

    logger.inf("script tracer shutdown completed");

    g_tracer.reset();
  }

  if (g_engine) {
    g_engine.reset();
  }

  logger.inf("qbdipreload_on_exit completed");
  return QBDIPRELOAD_NO_ERROR;
}

QBDI_EXPORT int qbdipreload_on_start(void* main) {
#if defined(_WIN32) || defined(WIN32)
  // on windows, allow logging to show for gui targets
  w1::common::allocate_windows_console();
#endif
  return QBDIPRELOAD_NOT_HANDLED;
}

QBDI_EXPORT int qbdipreload_on_premain(void* gprCtx, void* fpuCtx) { return QBDIPRELOAD_NOT_HANDLED; }

QBDI_EXPORT int qbdipreload_on_main(int argc, char** argv) { return QBDIPRELOAD_NOT_HANDLED; }

} // extern "C"
```

`src/tracers/w1script/script_bindings.cpp`:

```cpp
#include "script_bindings.hpp"
#include <redlog.hpp>
#include "bindings/output.hpp"

namespace w1::tracers::script {

void setup_qbdi_bindings(
    sol::state& lua, sol::table& tracer_table, std::shared_ptr<bindings::api_analysis_manager>& api_manager,
    std::shared_ptr<w1::hooking::hook_manager>& hook_manager
) {
  auto logger = redlog::get_logger("w1.script_bindings");
  logger.inf("setting up modular qbdi bindings");

  // create the main w1 module
  sol::table w1_module = lua.create_table();

  // setup all binding modules in logical order
  logger.dbg("setting up core types and enums");
  bindings::setup_core_types(lua, w1_module);

  logger.dbg("setting up register access functions");
  bindings::setup_register_access(lua, w1_module);

  logger.dbg("setting up vm control functions");
  bindings::setup_vm_control(lua, w1_module);

  logger.dbg("setting up memory analysis functions");
  bindings::setup_memory_analysis(lua, w1_module);

  logger.dbg("setting up module analysis functions");
  bindings::setup_module_analysis(lua, w1_module);

  logger.dbg("setting up utility functions");
  bindings::setup_utilities(lua, w1_module);

  logger.dbg("setting up callback system");
  bindings::setup_callback_system(lua, w1_module);

  // NOTE: api analysis setup is deferred until after script is loaded
  // because it needs to register methods on the script's tracer table

  logger.dbg("setting up memory access");
  bindings::setup_memory_access(lua, w1_module);

  logger.dbg("setting up hooking functions");
  bindings::setup_hooking(lua, w1_module, hook_manager);

  logger.dbg("setting up signature scanning");
  bindings::setup_signature_scanning(lua, w1_module);

  logger.dbg("setting up calling convention");
  bindings::setup_calling_convention(lua, w1_module);

  logger.dbg("setting up symbol resolution");
  bindings::setup_symbol_resolution(lua, w1_module);

  logger.dbg("setting up output module");
  bindings::setup_output(lua, w1_module);

  // register the w1 module with the lua state
  lua["w1"] = w1_module;

  logger.inf("all qbdi bindings registered successfully");
  logger.dbg(
      "available modules: core_types, register_access, vm_control, memory_access, memory_analysis, module_analysis, "
      "utilities, callback_system, api_analysis, hooking, signature_scanning, calling_convention, symbol_resolution"
  );
}

} // namespace w1::tracers::script

```

`src/tracers/w1script/script_bindings.hpp`:

```hpp
#pragma once

#include <sol/sol.hpp>
#include <QBDI.h>
#include <memory>

// include all binding modules
#include "bindings/core_types.hpp"
#include "bindings/register_access.hpp"
#include "bindings/vm_control.hpp"
#include "bindings/memory_access.hpp"
#include "bindings/memory_analysis.hpp"
#include "bindings/module_analysis.hpp"
#include "bindings/utilities.hpp"
#include "bindings/callback_system.hpp"
#include "bindings/api_analysis.hpp"
#include "bindings/hooking.hpp"
#include "bindings/signature_scanning.hpp"
#include "bindings/calling_convention.hpp"
#include "bindings/symbol_resolution.hpp"

namespace w1::hooking {
class hook_manager;
}

namespace w1::tracers::script {

/**
 * @brief setup comprehensive qbdi bindings for lua scripting
 *
 * this function orchestrates the setup of all qbdi-related bindings
 * for the lua scripting environment. it creates the main 'w1' module
 * and delegates to specialized binding modules for different categories
 * of functionality:
 *
 * - core types and enums (vmaction, instanalysis)
 * - platform-specific register access functions
 * - VM control and instruction analysis
 * - memory access and analysis
 * - utility functions (logging, file i/o, json, timestamps)
 * - callback system for comprehensive qbdi instrumentation
 * - api analysis for semantic API monitoring
 *
 * the bindings are organized into logical modules to improve maintainability
 * and make it easier to extend with additional qbdi functionality.
 *
 * @param lua the sol2 lua state to register all bindings with
 * @param tracer_table the tracer instance table (for api callbacks)
 * @param api_manager the api analysis manager (optional)
 */
void setup_qbdi_bindings(
    sol::state& lua, sol::table& tracer_table, std::shared_ptr<bindings::api_analysis_manager>& api_manager,
    std::shared_ptr<w1::hooking::hook_manager>& hook_manager
);

} // namespace w1::tracers::script

```

`src/tracers/w1script/script_config.hpp`:

```hpp
#pragma once

#include <w1tn3ss/util/env_config.hpp>
#include <w1tn3ss/util/env_enumerator.hpp>
#include <w1tn3ss/engine/tracer_config_base.hpp>
#include <string>
#include <unordered_map>

namespace w1::tracers::script {

struct config : public w1::tracer_config_base {
  std::string script_path;
  bool verbose = false;

  // raw config values that can be passed to the script
  std::unordered_map<std::string, std::string> script_config;

  static config from_environment() {
    w1::util::env_config loader("W1SCRIPT_");

    config cfg;
    cfg.include_system_modules = loader.get<bool>("INCLUDE_SYSTEM", false);
    cfg.script_path = loader.get<std::string>("SCRIPT", "");
    cfg.verbose = loader.get<bool>("VERBOSE", false);

    // collect all W1SCRIPT_* environment variables for the script
    auto env_vars = w1::util::env_enumerator::get_vars_with_prefix("W1SCRIPT_");
    for (const auto& [key, value] : env_vars) {
      // skip the built-in ones
      if (key != "SCRIPT" && key != "VERBOSE") {
        cfg.script_config[key] = value;
      }
    }

    return cfg;
  }

  bool is_valid() const { return !script_path.empty(); }
};

} // namespace w1::tracers::script
```

`src/tracers/w1script/script_loader.cpp`:

```cpp
#include "script_loader.hpp"
#include <fstream>
#include <sstream>

namespace w1::tracers::script {

script_loader::script_loader() : logger_(redlog::get_logger("w1.script_loader")) {}

script_loader::load_result script_loader::load_script(sol::state& lua, const config& cfg) {
  load_result result;

  try {
    // expose config to the script
    sol::table config_table = lua.create_table();
    for (const auto& pair : cfg.script_config) {
      config_table[pair.first] = pair.second;
    }
    lua["config"] = config_table;

    // load the script file
    logger_.dbg("loading script file", redlog::field("path", cfg.script_path));
    sol::load_result script = lua.load_file(cfg.script_path);

    if (!script.valid()) {
      sol::error err = script;
      result.error_message = err.what();
      logger_.err("failed to load script", redlog::field("error", result.error_message));
      return result;
    }

    // execute the script
    sol::protected_function_result exec_result = script();
    if (!exec_result.valid()) {
      sol::error err = exec_result;
      result.error_message = err.what();
      logger_.err("failed to execute script", redlog::field("error", result.error_message));
      return result;
    }

    // get the returned table
    if (!exec_result.return_count() || exec_result.get_type() != sol::type::table) {
      result.error_message = "script must return a table";
      logger_.err(result.error_message);
      return result;
    }

    result.script_table = exec_result;

    // validate the script structure
    if (!validate_script(result.script_table)) {
      result.error_message = "script validation failed";
      return result;
    }

    // NOTE: init function is NOT called here
    // it should be called after the tracer methods are injected

    result.success = true;
    logger_.inf("script loaded successfully", redlog::field("path", cfg.script_path));
    return result;

  } catch (const std::exception& e) {
    result.error_message = std::string("exception loading script: ") + e.what();
    logger_.err("exception loading script", redlog::field("error", e.what()));
    return result;
  }
}

bool script_loader::validate_script(const sol::table& script_table) {
  // currently we just check that it's a valid table
  // could add more validation here in the future
  if (!script_table.valid()) {
    logger_.err("invalid script table");
    return false;
  }

  // optionally check for required functions/callbacks
  // for now we keep it flexible
  return true;
}

bool script_loader::call_init_function(const sol::table& script_table) {
  sol::optional<sol::function> init_fn = script_table["init"];
  if (init_fn) {
    try {
      logger_.dbg("calling script init function");
      init_fn.value()();
      return true;
    } catch (const sol::error& e) {
      logger_.err("error in script init function", redlog::field("error", e.what()));
      return false;
    }
  }

  // no init function is fine
  return true;
}

} // namespace w1::tracers::script
```

`src/tracers/w1script/script_loader.hpp`:

```hpp
#pragma once

#include <sol/sol.hpp>
#include <string>
#include <memory>
#include <redlog.hpp>
#include "script_config.hpp"

namespace w1::tracers::script {

/**
 * handles loading and validation of lua scripts
 * extracted from script_tracer to improve separation of concerns
 */
class script_loader {
private:
  redlog::logger logger_;

public:
  script_loader();

  struct load_result {
    bool success = false;
    sol::table script_table;
    std::string error_message;
  };

  /**
   * load and validate a script file
   * @param lua The lua state to load into
   * @param config The script configuration
   * @return Load result with script table if successful
   */
  load_result load_script(sol::state& lua, const config& cfg);

  /**
   * validate that a loaded script has the required structure
   * @param script_table The loaded script table
   * @return True if valid, false otherwise
   */
  bool validate_script(const sol::table& script_table);

  /**
   * call the script's init function if it exists
   * @param script_table The loaded script table
   * @return True if successful or no init function, false on error
   */
  bool call_init_function(const sol::table& script_table);
};

} // namespace w1::tracers::script
```

`src/tracers/w1script/script_tracer.cpp`:

```cpp
#include "script_tracer.hpp"
#include <redlog.hpp>

#include "script_bindings.hpp"
#include "script_loader.hpp"
#include "callback_manager.hpp"
#include "bindings/api_analysis.hpp"
#include <w1tn3ss/util/module_scanner.hpp>
#include <w1tn3ss/util/module_range_index.hpp>
#include <w1tn3ss/util/register_access.hpp>
#include <w1tn3ss/symbols/symbol_resolver.hpp>
#include <w1tn3ss/hooking/hook_manager.hpp>
#include <fstream>
#include <stdexcept>

namespace w1::tracers::script {

script_tracer::script_tracer() : logger_(redlog::get_logger("w1.script_tracer")) {}

script_tracer::script_tracer(const config& cfg) : cfg_(cfg), logger_(redlog::get_logger("w1.script_tracer")) {}

script_tracer::~script_tracer() = default;

bool script_tracer::initialize(w1::tracer_engine<script_tracer>& engine) {
  // if cfg_ not already set, get from environment
  if (cfg_.script_path.empty()) {
    cfg_ = config::from_environment();
  }

  if (!cfg_.is_valid()) {
    logger_.err("invalid configuration. W1SCRIPT_SCRIPT must be specified.");
    return false;
  }
  logger_.inf("initializing with lua support");
  logger_.inf("script path", redlog::field("path", cfg_.script_path));

  // get VM and create hook manager early
  QBDI::VM* vm = engine.get_vm();
  if (!vm) {
    logger_.err("vm instance is null");
    return false;
  }

  // create hook manager before loading script
  hook_manager_ = std::make_shared<w1::hooking::hook_manager>(vm);
  logger_.inf("hook manager created");

  // create api analysis processor
  api_processor_ = std::make_unique<api_analysis_processor>();

  // create api analysis manager
  api_manager_ = std::make_shared<bindings::api_analysis_manager>();

  // initialize lua state
  lua_.open_libraries(sol::lib::base, sol::lib::table, sol::lib::string, sol::lib::math, sol::lib::io);

  // setup bindings before loading script (without API analysis yet)
  sol::table dummy_table = lua_.create_table();
  setup_qbdi_bindings(lua_, dummy_table, api_manager_, hook_manager_);

  // load script using the new loader
  script_loader loader;
  auto load_result = loader.load_script(lua_, cfg_);
  if (!load_result.success) {
    logger_.err("failed to load script", redlog::field("error", load_result.error_message));
    return false;
  }
  script_table_ = load_result.script_table;

  // inject API analysis methods into the script table
  logger_.inf("setting up api analysis methods on script table");
  if (api_manager_) {
    sol::table w1_module = lua_["w1"];
    bindings::setup_api_analysis(lua_, w1_module, script_table_, api_manager_);
    logger_.inf("api analysis methods setup complete");
  } else {
    logger_.wrn("api_manager_ is null, skipping api analysis setup");
  }

  // now call the script's init function
  sol::optional<sol::function> init_fn = script_table_["init"];
  if (init_fn) {
    try {
      logger_.dbg("calling script init function");
      init_fn.value()();
    } catch (const sol::error& e) {
      logger_.err("error in script init function", redlog::field("error", e.what()));
      return false;
    }
  }

  // scan modules and create index first
  w1::util::module_scanner scanner;
  auto modules = scanner.scan_executable_modules();
  module_index_ = std::make_unique<w1::util::module_range_index>();
  module_index_->rebuild_from_modules(std::move(modules));
  logger_.inf("module index built", redlog::field("module_count", module_index_->size()));

  // create symbol resolver if lief is enabled
#ifdef WITNESS_LIEF_ENABLED
  symbol_resolver_ = std::make_unique<w1::symbols::symbol_resolver>();
  logger_.inf("symbol resolver created");
#endif

  // initialize api manager if created
  if (api_manager_) {
    logger_.inf("initializing api manager");
    api_manager_->initialize(*module_index_);
  }

  // setup callbacks using the new manager
  callback_manager_ = std::make_unique<callback_manager>();
  callback_manager_->setup_callbacks(script_table_);

  // pass api analysis components to callback manager
  callback_manager_->set_api_analysis_components(
      api_processor_.get(), api_manager_.get(), module_index_.get(), symbol_resolver_.get()
  );

  callback_manager_->register_callbacks(vm);

  // enable memory recording if memory callbacks are used
  if (callback_manager_->is_callback_enabled(callback_manager::callback_type::memory_read) ||
      callback_manager_->is_callback_enabled(callback_manager::callback_type::memory_write) ||
      callback_manager_->is_callback_enabled(callback_manager::callback_type::memory_read_write)) {
    bool memory_recording_enabled = vm->recordMemoryAccess(QBDI::MEMORY_READ_WRITE);
    if (memory_recording_enabled) {
      logger_.inf("memory recording enabled for script");
    } else {
      logger_.wrn("memory recording not supported on this platform");
    }
  }

  logger_.inf("initialization complete");
  return true;
}

void script_tracer::shutdown() {
  if (cfg_.verbose) {
    logger_.inf("shutting down");
  }

  // call script shutdown function if it exists
  if (script_table_.valid()) {
    sol::optional<sol::function> shutdown_fn = script_table_["shutdown"];
    if (shutdown_fn) {
      try {
        shutdown_fn.value()();
      } catch (const sol::error& e) {
        logger_.err("error in script shutdown", redlog::field("error", e.what()));
      }
    }
  }

  // shutdown api manager if it exists
  if (api_manager_) {
    api_manager_->shutdown();
  }
}

// all callbacks are registered manually by callback_manager
// we don't define any on_* methods to prevent tracer_engine from registering callbacks

} // namespace w1::tracers::script
```

`src/tracers/w1script/script_tracer.hpp`:

```hpp
#pragma once

#include "script_config.hpp"
#include "callback_manager.hpp"
#include "api_analysis_processor.hpp"
#include <w1tn3ss/engine/tracer_engine.hpp>

#include <sol/sol.hpp>
#include <unordered_set>
#include <unordered_map>
#include <vector>
#include <string>
#include <memory>
#include <w1tn3ss/util/module_range_index.hpp>
#include <redlog.hpp>

namespace w1 {
namespace symbols {
class symbol_resolver;
}
namespace hooking {
class hook_manager;
}
} // namespace w1

namespace w1::tracers::script {

// forward declarations
namespace bindings {
class api_analysis_manager;
}

class script_tracer {
private:
  config cfg_;
  redlog::logger logger_;

  sol::state lua_;
  sol::table script_table_;

  // callback management
  std::unique_ptr<callback_manager> callback_manager_;

  // api analysis manager
  std::shared_ptr<bindings::api_analysis_manager> api_manager_;

  // module index for api analysis
  std::unique_ptr<w1::util::module_range_index> module_index_;

  // symbol resolver for api analysis
  std::unique_ptr<w1::symbols::symbol_resolver> symbol_resolver_;

  // hook manager for dynamic hooking
  std::shared_ptr<w1::hooking::hook_manager> hook_manager_;

  // api analysis processor
  std::unique_ptr<api_analysis_processor> api_processor_;

public:
  script_tracer();                           // defined in cpp due to unique_ptr of incomplete type
  explicit script_tracer(const config& cfg); // constructor with config
  ~script_tracer();                          // defined in cpp due to unique_ptr of incomplete type

  bool initialize(w1::tracer_engine<script_tracer>& engine);
  void shutdown();
  const char* get_name() const { return "w1script"; }

  // we intentionally don't define any on_* callback methods
  // to prevent tracer_engine from registering callbacks via SFINAE
  // all callbacks are registered manually by callback_manager

  // api manager access (for exec_transfer callbacks)
  std::shared_ptr<bindings::api_analysis_manager> get_api_manager() { return api_manager_; }
};

} // namespace w1::tracers::script
```

`src/tracers/w1script/session.hpp`:

```hpp
#pragma once

#include "script_tracer.hpp"
#include "script_config.hpp"
#include <w1tn3ss/engine/session_base.hpp>

namespace w1::tracers::script {

class session : public w1::session_base<session, script_tracer, config> {
public:
  session() = default;
  explicit session(const config& cfg) : session_base(cfg) {}

  // script-specific configuration
  void set_script_path(const std::string& path) { config_.script_path = path; }

  void set_script_config(const std::string& key, const std::string& value) { config_.script_config[key] = value; }
};

} // namespace w1::tracers::script
```

`src/tracers/w1trace/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${WITNESS_SOURCE_DIR}/cmake/TracerConfig.cmake)

create_tracer_targets(w1trace
    "preload.cpp;trace_tracer.cpp;trace_collector.cpp"
)
```

`src/tracers/w1trace/preload.cpp`:

```cpp
#include <cstring>
#include <memory>

#include "QBDIPreload.h"
#include <redlog.hpp>

#include <w1tn3ss/engine/tracer_engine.hpp>
#include <w1tn3ss/util/env_config.hpp>
#include <w1tn3ss/util/signal_handler.hpp>
#include <w1tn3ss/util/stderr_write.hpp>

#if defined(_WIN32) || defined(WIN32)
#include <w1common/windows_console.hpp>
#endif

#include "trace_config.hpp"
#include "trace_tracer.hpp"

// globals
static std::unique_ptr<w1trace::trace_tracer> g_tracer;
static std::unique_ptr<w1::tracer_engine<w1trace::trace_tracer>> g_engine;
static w1trace::trace_config g_config;

namespace {

/**
 * @brief export trace data with signal-safe error handling
 */
void export_trace() {
  if (!g_tracer) {
    return;
  }

  try {
    // Force flush of any remaining data
    g_tracer->get_collector().flush();
  } catch (...) {
    // signal-safe error reporting
    const char* error_msg = "w1trace: trace export failed\n";
    w1::util::stderr_write(error_msg);
  }
}

} // anonymous namespace

extern "C" {

QBDIPRELOAD_INIT;

QBDI_EXPORT int qbdipreload_on_run(QBDI::VMInstanceRef vm, QBDI::rword start, QBDI::rword stop) {
  auto log = redlog::get_logger("w1trace.preload");

  log.inf("qbdipreload_on_run called");

  // get config
  g_config = w1trace::trace_config::from_environment();

  w1::util::env_config config_loader("W1TRACE_");
  int debug_level = config_loader.get<int>("VERBOSE", 0);

  // set log level based on debug level
  if (debug_level >= 4) {
    redlog::set_level(redlog::level::pedantic);
  } else if (debug_level >= 3) {
    redlog::set_level(redlog::level::debug);
  } else if (debug_level >= 2) {
    redlog::set_level(redlog::level::trace);
  } else if (debug_level >= 1) {
    redlog::set_level(redlog::level::verbose);
  } else {
    redlog::set_level(redlog::level::info);
  }

  // initialize signal handling for emergency trace export
  w1::tn3ss::signal_handler::config sig_config;
  sig_config.context_name = "w1trace";
  sig_config.log_signals = (debug_level >= 1);

  if (w1::tn3ss::signal_handler::initialize(sig_config)) {
    w1::tn3ss::signal_handler::register_cleanup(
        export_trace,
        200, // high priority
        "w1trace_export"
    );
    log.inf("signal handling initialized for trace export");
  } else {
    log.wrn("failed to initialize signal handling - trace export on signal unavailable");
  }

  // create tracer
  log.inf("creating tracer");
  g_tracer = std::make_unique<w1trace::trace_tracer>(g_config);

  // create engine
  log.inf("creating tracer engine");
  g_engine = std::make_unique<w1::tracer_engine<w1trace::trace_tracer>>(vm, *g_tracer, g_config);

  // initialize tracer
  if (!g_tracer->initialize(*g_engine)) {
    log.err("tracer initialization failed");
    return QBDIPRELOAD_ERR_STARTUP_FAILED;
  }

  // instrument
  log.inf("instrumenting engine");
  if (!g_engine->instrument()) {
    log.err("engine instrumentation failed");
    return QBDIPRELOAD_ERR_STARTUP_FAILED;
  }

  log.inf("engine instrumentation successful");

  // run engine
  log.inf("running engine", redlog::field("start", "0x%08x", start), redlog::field("stop", "0x%08x", stop));
  if (!g_engine->run(start, stop)) {
    log.err("engine run failed");
    return QBDIPRELOAD_ERR_STARTUP_FAILED;
  }

  // execution doesn't reach here if it works (vm run jumps)
  log.inf("qbdipreload_on_run completed");

  return QBDIPRELOAD_NO_ERROR;
}

QBDI_EXPORT int qbdipreload_on_exit(int status) {
  auto log = redlog::get_logger("w1trace.preload");

  log.inf("qbdipreload_on_exit called", redlog::field("status", status));

  if (g_tracer) {
    log.inf("shutting down tracer and exporting trace");

    export_trace();

    log.inf("trace data export completed", redlog::field("output_file", g_config.output_file));

    g_tracer->shutdown();
    g_tracer.reset();
  }

  if (g_engine) {
    g_engine.reset();
  }

  log.inf("qbdipreload_on_exit completed");
  return QBDIPRELOAD_NO_ERROR;
}

QBDI_EXPORT int qbdipreload_on_start(void* main) {
#if defined(_WIN32) || defined(WIN32)
  // on windows, allow logging to show for gui targets
  w1::common::allocate_windows_console();
#endif
  return QBDIPRELOAD_NOT_HANDLED;
}

QBDI_EXPORT int qbdipreload_on_premain(void* gprCtx, void* fpuCtx) { return QBDIPRELOAD_NOT_HANDLED; }

QBDI_EXPORT int qbdipreload_on_main(int argc, char** argv) { return QBDIPRELOAD_NOT_HANDLED; }

} // extern "C"
```

`src/tracers/w1trace/session.hpp`:

```hpp
#pragma once

#include "trace_tracer.hpp"
#include "trace_config.hpp"
#include <w1tn3ss/engine/session_base.hpp>

namespace w1trace {

class session : public w1::session_base<session, trace_tracer, trace_config> {
public:
  session() = default;
  explicit session(const trace_config& config) : session_base(config) {}

  // trace-specific metrics
  size_t get_instruction_count() const { return get_tracer()->get_instruction_count(); }
  size_t get_flush_count() const { return get_tracer()->get_flush_count(); }
  size_t get_buffer_usage() const { return get_tracer()->get_buffer_usage(); }
};

} // namespace w1trace
```

`src/tracers/w1trace/trace_collector.cpp`:

```cpp
#include "trace_collector.hpp"
#include <cstdio>
#include <stdexcept>

namespace w1trace {

trace_collector::trace_collector(const std::string& output_file, size_t buffer_size)
    : output_file_(output_file), buffer_size_(buffer_size), buffer_(std::make_unique<char[]>(buffer_size)),
      buffer_pos_(0), instruction_count_(0), flush_count_(0), log_(redlog::get_logger("w1trace.collector")),
      shutdown_called_(false) {

  log_.inf(
      "trace collector initialized", redlog::field("output_file", output_file_),
      redlog::field("buffer_size", buffer_size_)
  );
}

trace_collector::~trace_collector() {
  if (!shutdown_called_) {
    shutdown();
  }
}

void trace_collector::add_instruction_address(uint64_t address) {
  // Format: hex address + newline (up to 17 chars: "ffffffffffffffff\n")
  constexpr size_t max_line_length = 17;

  // Check if we need to flush
  if (buffer_pos_ + max_line_length >= buffer_size_) {
    flush_buffer();
  }

  // Write address as hex string to buffer
  int written = snprintf(
      buffer_.get() + buffer_pos_, buffer_size_ - buffer_pos_, "%llx\n", static_cast<unsigned long long>(address)
  );

  if (written > 0 && written < static_cast<int>(buffer_size_ - buffer_pos_)) {
    buffer_pos_ += written;
    instruction_count_++;
  } else {
    log_.wrn("failed to write instruction address to buffer", redlog::field("address", "0x%llx", address));
  }
}

void trace_collector::flush() { flush_buffer(); }

void trace_collector::flush_buffer() {
  if (buffer_pos_ == 0) {
    return; // Nothing to flush
  }

  // Skip flush if no output file configured
  if (output_file_.empty()) {
    buffer_pos_ = 0; // Reset buffer position
    return;
  }

  ensure_output_file();

  if (output_stream_.is_open()) {
    output_stream_.write(buffer_.get(), buffer_pos_);
    output_stream_.flush();

    log_.vrb("flushed buffer", redlog::field("bytes", buffer_pos_), redlog::field("instructions", instruction_count_));

    buffer_pos_ = 0;
    flush_count_++;
  } else {
    log_.err("cannot flush - output file not open", redlog::field("output_file", output_file_));
  }
}

void trace_collector::ensure_output_file() {
  if (output_file_.empty()) {
    return; // skip file operations when output file is not set
  }

  if (!output_stream_.is_open()) {
    output_stream_.open(output_file_, std::ios::out | std::ios::trunc);
    if (!output_stream_.is_open()) {
      log_.err("failed to open output file", redlog::field("output_file", output_file_));
      throw std::runtime_error("Cannot open trace output file: " + output_file_);
    }
    log_.inf("opened output file", redlog::field("output_file", output_file_));
  }
}

void trace_collector::shutdown() {
  if (shutdown_called_) {
    return;
  }

  log_.inf("shutting down trace collector");

  // Flush any remaining data
  flush_buffer();

  // Close output file
  if (output_stream_.is_open()) {
    output_stream_.close();
  }

  log_.inf(
      "trace collector shutdown complete", redlog::field("total_instructions", instruction_count_),
      redlog::field("total_flushes", flush_count_)
  );

  shutdown_called_ = true;
}

} // namespace w1trace
```

`src/tracers/w1trace/trace_collector.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <string>
#include <vector>
#include <fstream>
#include <memory>
#include <redlog.hpp>

namespace w1trace {

class trace_collector {
public:
  explicit trace_collector(const std::string& output_file, size_t buffer_size);
  ~trace_collector();

  void add_instruction_address(uint64_t address);
  void flush();
  void shutdown();

  size_t get_instruction_count() const { return instruction_count_; }
  size_t get_flush_count() const { return flush_count_; }
  size_t get_buffer_usage() const { return buffer_pos_; }

private:
  void flush_buffer();
  void ensure_output_file();

  std::string output_file_;
  size_t buffer_size_;
  std::unique_ptr<char[]> buffer_;
  size_t buffer_pos_;
  size_t instruction_count_;
  size_t flush_count_;
  std::ofstream output_stream_;
  redlog::logger log_;
  bool shutdown_called_;
};

} // namespace w1trace
```

`src/tracers/w1trace/trace_config.hpp`:

```hpp
#pragma once

#include <string>
#include <w1tn3ss/util/env_config.hpp>
#include <w1tn3ss/engine/tracer_config_base.hpp>

namespace w1trace {

struct trace_config : public w1::tracer_config_base {
  std::string output_file = "";
  size_t buffer_size = 256 * 1024 * 1024; // 256MB default
  int verbose = 0;

  static trace_config from_environment() {
    w1::util::env_config loader("W1TRACE_");

    trace_config config;
    config.include_system_modules = loader.get<bool>("INCLUDE_SYSTEM", false);
    config.output_file = loader.get<std::string>("OUTPUT", "");
    config.buffer_size = static_cast<size_t>(loader.get<uint64_t>("BUFFER_SIZE", 256 * 1024 * 1024));
    config.verbose = loader.get<int>("VERBOSE", 0);

    return config;
  }
};

} // namespace w1trace
```

`src/tracers/w1trace/trace_tracer.cpp`:

```cpp
#include "trace_tracer.hpp"

namespace w1trace {

trace_tracer::trace_tracer(const trace_config& config)
    : config_(config), collector_(config.output_file, config.buffer_size), log_(redlog::get_logger("w1trace.tracer")) {

  log_.inf(
      "trace tracer initialized", redlog::field("output_file", config_.output_file),
      redlog::field("buffer_size", config_.buffer_size)
  );
}

bool trace_tracer::initialize(w1::tracer_engine<trace_tracer>& engine) {
  log_.inf("initializing trace tracer");

  // No additional initialization needed - the tracer_engine will automatically
  // register our on_instruction_postinst callback via SFINAE detection

  log_.inf("trace tracer initialization complete");
  return true;
}

void trace_tracer::shutdown() {
  print_statistics();
  collector_.shutdown();
  log_.inf("trace collection completed");
}

QBDI::VMAction trace_tracer::on_instruction_postinst(QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr) {
  // Get the current instruction address from analysis
  QBDI::VM* vm_ptr = static_cast<QBDI::VM*>(vm);
  const QBDI::InstAnalysis* analysis = vm_ptr->getInstAnalysis();
  uint64_t address = analysis ? analysis->address : 0;

  if (address != 0) {
    // Add to collector
    collector_.add_instruction_address(address);
  }

  // Continue execution
  return QBDI::VMAction::CONTINUE;
}

size_t trace_tracer::get_instruction_count() const { return collector_.get_instruction_count(); }

size_t trace_tracer::get_flush_count() const { return collector_.get_flush_count(); }

size_t trace_tracer::get_buffer_usage() const { return collector_.get_buffer_usage(); }

void trace_tracer::print_statistics() const {
  log_.inf(
      "trace stats", redlog::field("instructions", get_instruction_count()),
      redlog::field("flushes", get_flush_count()), redlog::field("buffer_usage", get_buffer_usage())
  );
}

const trace_collector& trace_tracer::get_collector() const { return collector_; }

trace_collector& trace_tracer::get_collector() { return collector_; }

} // namespace w1trace
```

`src/tracers/w1trace/trace_tracer.hpp`:

```hpp
#pragma once

#include <QBDI.h>
#include <w1tn3ss/engine/tracer_engine.hpp>
#include <redlog.hpp>

#include "trace_collector.hpp"
#include "trace_config.hpp"

namespace w1trace {

class trace_tracer {
public:
  explicit trace_tracer(const trace_config& config);

  bool initialize(w1::tracer_engine<trace_tracer>& engine);
  void shutdown();
  const char* get_name() const { return "w1trace"; }

  // Required callback for tracer_engine - captures every instruction address
  QBDI::VMAction on_instruction_postinst(QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr);

  // Statistics access
  size_t get_instruction_count() const;
  size_t get_flush_count() const;
  size_t get_buffer_usage() const;
  void print_statistics() const;

  // Collector access for manual flush
  const trace_collector& get_collector() const;
  trace_collector& get_collector();

private:
  trace_config config_;
  trace_collector collector_;
  redlog::logger log_;
};

} // namespace w1trace
```

`src/tracers/w1xfer/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${WITNESS_SOURCE_DIR}/cmake/TracerConfig.cmake)
include(${WITNESS_SOURCE_DIR}/cmake/LIEFConfig.cmake)

create_tracer_targets(w1xfer
    "preload.cpp;transfer_tracer.cpp;transfer_collector.cpp;symbol_enricher.cpp"
)

# Apply LIEF configuration to w1xfer targets
if(WITNESS_BUILD_SHARED)
    configure_target_with_lief(w1xfer_qbdipreload)
endif()

if(WITNESS_BUILD_STATIC)
    configure_target_with_lief(w1xfer_static)
endif()
```

`src/tracers/w1xfer/preload.cpp`:

```cpp
#include <cstring>
#include <memory>

#include "QBDIPreload.h"
#include <redlog.hpp>
#include <w1tn3ss/engine/tracer_engine.hpp>
#include <w1tn3ss/util/signal_handler.hpp>
#include <w1tn3ss/util/stderr_write.hpp>

#if defined(_WIN32) || defined(WIN32)
#include <w1common/windows_console.hpp>
#endif

#include "transfer_config.hpp"
#include "transfer_tracer.hpp"

// globals
static std::unique_ptr<w1xfer::transfer_tracer> g_tracer;
static std::unique_ptr<w1::tracer_engine<w1xfer::transfer_tracer>> g_engine;
static w1xfer::transfer_config g_config;

namespace {

/**
 * @brief shutdown tracer with signal-safe error handling
 */
void shutdown_tracer() {
  if (!g_tracer) {
    return;
  }

  try {
    g_tracer->shutdown();
  } catch (...) {
    const char* error_msg = "w1xfer: tracer shutdown failed\n";
    w1::util::stderr_write(error_msg);
  }
}

} // anonymous namespace

extern "C" {

QBDIPRELOAD_INIT;

static auto logger = redlog::get_logger("w1.preload");

QBDI_EXPORT int qbdipreload_on_run(QBDI::VMInstanceRef vm, QBDI::rword start, QBDI::rword stop) {

  logger.inf("w1xfer preload starting");

  // get config from environment
  try {
    g_config = w1xfer::transfer_config::from_environment();

    // set log level based on debug level
    if (g_config.verbose >= 4) {
      redlog::set_level(redlog::level::pedantic);
    } else if (g_config.verbose >= 3) {
      redlog::set_level(redlog::level::debug);
    } else if (g_config.verbose >= 2) {
      redlog::set_level(redlog::level::trace);
    } else if (g_config.verbose >= 1) {
      redlog::set_level(redlog::level::verbose);
    } else {
      redlog::set_level(redlog::level::info);
    }

    // initialize signal handling for emergency shutdown
    w1::tn3ss::signal_handler::config sig_config;
    sig_config.context_name = "w1xfer";
    sig_config.log_signals = g_config.verbose;

    if (w1::tn3ss::signal_handler::initialize(sig_config)) {
      w1::tn3ss::signal_handler::register_cleanup(
          shutdown_tracer,
          200, // high priority
          "w1xfer_shutdown"
      );
      logger.inf("signal handling initialized for tracer shutdown");
    } else {
      logger.wrn("failed to initialize signal handling - shutdown on signal unavailable");
    }

    // create tracer
    logger.inf("creating transfer tracer");
    g_tracer = std::make_unique<w1xfer::transfer_tracer>(g_config);

    // create engine
    logger.inf("creating tracer engine");
    g_engine = std::make_unique<w1::tracer_engine<w1xfer::transfer_tracer>>(vm, *g_tracer, g_config);

    // initialize tracer
    if (!g_tracer->initialize(*g_engine)) {
      logger.err("tracer initialization failed");
      return QBDIPRELOAD_ERR_STARTUP_FAILED;
    }

    // instrument
    logger.inf("instrumenting engine");
    if (!g_engine->instrument()) {
      logger.err("engine instrumentation failed");
      return QBDIPRELOAD_ERR_STARTUP_FAILED;
    }

    logger.inf("engine instrumentation successful");

    // run engine
    logger.inf("running engine", redlog::field("start", "0x%016llx", start), redlog::field("stop", "0x%016llx", stop));
    if (!g_engine->run(start, stop)) {
      logger.err("engine run failed");
      return QBDIPRELOAD_ERR_STARTUP_FAILED;
    }

    // execution doesn't reach here if it works (vm run jumps)
    logger.inf("w1xfer preload completed");

  } catch (const std::exception& e) {
    logger.err("failed to initialize w1xfer tracer", redlog::field("error", e.what()));
    return QBDIPRELOAD_ERR_STARTUP_FAILED;
  }

  return QBDIPRELOAD_NO_ERROR;
}

QBDI_EXPORT int qbdipreload_on_exit(int status) {
  logger.inf("w1xfer preload exit", redlog::field("status", status));

  if (g_tracer) {
    g_tracer->shutdown();
  }

  return QBDIPRELOAD_NO_ERROR;
}

QBDI_EXPORT int qbdipreload_on_start(void* main) {
#if defined(_WIN32) || defined(WIN32)
  // on windows, allow logging to show for gui targets
  w1::common::allocate_windows_console();
#endif
  return QBDIPRELOAD_NOT_HANDLED;
}

QBDI_EXPORT int qbdipreload_on_premain(void* gprCtx, void* fpuCtx) { return QBDIPRELOAD_NOT_HANDLED; }

QBDI_EXPORT int qbdipreload_on_main(int argc, char** argv) { return QBDIPRELOAD_NOT_HANDLED; }

} // extern "C"
```

`src/tracers/w1xfer/session.hpp`:

```hpp
#pragma once

#include "transfer_tracer.hpp"
#include "transfer_config.hpp"
#include <w1tn3ss/engine/session_base.hpp>

namespace w1xfer {

class session : public w1::session_base<session, transfer_tracer, transfer_config> {
public:
  session() = default;
  explicit session(const transfer_config& config) : session_base(config) {}

  // transfer-specific metrics
  const transfer_stats& get_stats() const { return get_tracer()->get_stats(); }
};

} // namespace w1xfer
```

`src/tracers/w1xfer/symbol_enricher.cpp`:

```cpp
#include "symbol_enricher.hpp"
#include <redlog.hpp>

namespace w1xfer {

symbol_enricher::symbol_enricher() {
#ifdef WITNESS_LIEF_ENABLED
  log_.inf("creating unified symbol resolver with enhanced config");

  w1::symbols::symbol_resolver::config cfg;
  cfg.max_cache_size = 100; // cache more binaries for transfer analysis
  cfg.prepopulate_exports = true;
  cfg.resolve_imports = true;

  resolver_ = std::make_unique<w1::symbols::symbol_resolver>(cfg);
#else
  log_.wrn("lief support not enabled, symbol resolution will be limited");
#endif
}

symbol_enricher::~symbol_enricher() = default;

void symbol_enricher::initialize(const w1::util::module_range_index& module_index) {
  log_.dbg("initializing symbol enricher with module index", redlog::field("module_count", module_index.size()));
  module_index_ = &module_index;
}

std::optional<symbol_enricher::symbol_context> symbol_enricher::enrich_address(uint64_t address) const {
#ifdef WITNESS_LIEF_ENABLED

  // check symbol cache first
  {
    std::lock_guard<std::mutex> lock(symbol_cache_mutex_);
    auto it = symbol_cache_.find(address);
    if (it != symbol_cache_.end()) {
      return it->second;
    }
  }

  if (!resolver_ || !module_index_) {
    log_.err("no resolver or module index available");
    return std::nullopt;
  }

  // find which module contains this address
  auto module = module_index_->find_containing(address);
  if (!module) {
    log_.dbg("no module found for address", redlog::field("address", "0x%016llx", address));
    return std::nullopt;
  }

  // calculate offset within module
  uint64_t module_offset = address - module->base_address;
  log_.trc(
      "resolving symbol", redlog::field("address", "0x%016llx", address), redlog::field("module_name", module->name),
      redlog::field("module_path", module->path), redlog::field("module_offset", "0x%016llx", module_offset)
  );

  log_.dbg(
      "calling unified symbol resolver", redlog::field("address", "0x%016llx", address),
      redlog::field("module", module->name)
  );

  auto symbol = resolver_->resolve_address(address, *module_index_);

  if (!symbol) {
    log_.dbg("no symbol found", redlog::field("address", "0x%016llx", address), redlog::field("module", module->name));

    // return basic context with module info
    symbol_context ctx;
    ctx.module_name = module->name;
    ctx.module_offset = module_offset;

    // cache the result
    {
      std::lock_guard<std::mutex> lock(symbol_cache_mutex_);
      if (symbol_cache_.size() >= MAX_SYMBOL_CACHE_SIZE) {
        symbol_cache_.clear();
      }
      symbol_cache_[address] = ctx;
    }

    return ctx;
  }

  log_.trc(
      "symbol resolved", redlog::field("address", "0x%016llx", address), redlog::field("symbol_name", symbol->name),
      redlog::field("demangled_name", symbol->demangled_name),
      redlog::field("offset_from_symbol", "0x%016llx", symbol->offset_from_symbol),
      redlog::field("is_exported", symbol->is_exported)
  );

  auto result = to_context(address, *module, *symbol);

  // cache the result
  {
    std::lock_guard<std::mutex> lock(symbol_cache_mutex_);
    // implement simple LRU by clearing cache when it gets too large
    // this is a simple but effective cache management strategy
    // when cache is full, we clear it entirely rather than tracking individual item ages
    if (symbol_cache_.size() >= MAX_SYMBOL_CACHE_SIZE) {
      symbol_cache_.clear();
    }
    symbol_cache_[address] = result;
  }

  return result;
#else
  // log_.dbg("lief not enabled, no symbol resolution available");
  return std::nullopt;
#endif
}

std::vector<std::optional<symbol_enricher::symbol_context>> symbol_enricher::enrich_addresses(
    const std::vector<uint64_t>& addresses
) const {
#ifdef WITNESS_LIEF_ENABLED
  if (!resolver_ || !module_index_) {
    return std::vector<std::optional<symbol_context>>(addresses.size());
  }

  // use batch resolution for efficiency
  auto symbols = resolver_->resolve_addresses(addresses, *module_index_);

  std::vector<std::optional<symbol_context>> results;
  results.reserve(addresses.size());

  for (size_t i = 0; i < addresses.size(); ++i) {
    if (!symbols[i]) {
      // try to at least get module info
      if (auto module = module_index_->find_containing(addresses[i])) {
        symbol_context ctx;
        ctx.module_name = module->name;
        ctx.module_offset = addresses[i] - module->base_address;
        results.push_back(ctx);
      } else {
        results.push_back(std::nullopt);
      }
    } else {
      // we have symbol info
      auto module = module_index_->find_containing(addresses[i]);
      if (module) {
        results.push_back(to_context(addresses[i], *module, *symbols[i]));
      } else {
        results.push_back(std::nullopt);
      }
    }
  }

  return results;
#else
  return std::vector<std::optional<symbol_context>>(addresses.size());
#endif
}

void symbol_enricher::clear_cache() {
#ifdef WITNESS_LIEF_ENABLED
  if (resolver_) {
    resolver_->clear_cache();
  }
  std::lock_guard<std::mutex> lock(symbol_cache_mutex_);
  symbol_cache_.clear();
#endif
}

symbol_enricher::cache_stats symbol_enricher::get_cache_stats() const {
  cache_stats stats{};

#ifdef WITNESS_LIEF_ENABLED
  if (resolver_) {
    auto resolver_stats = resolver_->get_cache_stats();
    stats.binary_cache_size = resolver_stats.size;
    stats.binary_cache_hits = resolver_stats.hits;
    stats.binary_cache_misses = resolver_stats.misses;
    stats.hit_rate = resolver_stats.hit_rate;
  }
#endif

  return stats;
}

symbol_enricher::symbol_context symbol_enricher::to_context(
    uint64_t address, const w1::util::module_info& module, const w1::symbols::symbol_info& symbol
) const {

  symbol_context ctx;
  ctx.module_name = module.name;
  ctx.symbol_name = symbol.name;
  ctx.demangled_name = symbol.demangled_name;
  // use module_offset from symbol if available, otherwise calculate it
  ctx.module_offset = symbol.module_offset ? symbol.module_offset : (address - module.base_address);
  // symbol_offset is the offset from the start of the symbol
  // offset_from_symbol already contains this value from the resolver
  ctx.symbol_offset = symbol.offset_from_symbol;
  ctx.is_exported = symbol.is_exported;
  ctx.is_imported = symbol.is_imported;

  return ctx;
}

} // namespace w1xfer
```

`src/tracers/w1xfer/symbol_enricher.hpp`:

```hpp
#pragma once

#include <memory>
#include <string>
#include <optional>
#include <vector>
#include <unordered_map>
#include <mutex>
#include <redlog.hpp>
#include <w1tn3ss/symbols/symbol_resolver.hpp>
#include <w1tn3ss/util/module_range_index.hpp>

namespace w1xfer {

// enriches transfer entries with symbol information
class symbol_enricher {
public:
  struct symbol_context {
    std::string module_name;
    std::string symbol_name;
    std::string demangled_name;
    uint64_t symbol_offset; // offset within the symbol
    uint64_t module_offset; // offset within the module
    bool is_exported = false;
    bool is_imported = false;
  };

  symbol_enricher();
  ~symbol_enricher();

  // initialize with module index
  void initialize(const w1::util::module_range_index& module_index);

  // get enriched symbol information for an address
  std::optional<symbol_context> enrich_address(uint64_t address) const;

  // batch enrichment for performance
  std::vector<std::optional<symbol_context>> enrich_addresses(const std::vector<uint64_t>& addresses) const;

  // clear symbol cache
  void clear_cache();

  // get cache statistics
  struct cache_stats {
    size_t binary_cache_size;
    size_t binary_cache_hits;
    size_t binary_cache_misses;
    double hit_rate;
  };

  cache_stats get_cache_stats() const;

private:
  std::unique_ptr<w1::symbols::symbol_resolver> resolver_;
  const w1::util::module_range_index* module_index_ = nullptr;
  redlog::logger log_ = redlog::get_logger("w1.symbol_enricher");

  // address-to-symbol cache to avoid repeated lookups
  mutable std::unordered_map<uint64_t, std::optional<symbol_context>> symbol_cache_;
  mutable std::mutex symbol_cache_mutex_;
  static constexpr size_t MAX_SYMBOL_CACHE_SIZE = 10000;

  // convert internal symbol info to enriched context
  symbol_context to_context(
      uint64_t address, const w1::util::module_info& module, const w1::symbols::symbol_info& symbol
  ) const;
};

} // namespace w1xfer
```

`src/tracers/w1xfer/transfer_collector.cpp`:

```cpp
#include "transfer_collector.hpp"

#include <algorithm>
#include <chrono>
#include <sstream>
#include <w1tn3ss/util/value_formatter.hpp>

namespace w1xfer {

transfer_collector::transfer_collector(
    const std::string& output_file, bool log_registers, bool log_stack_info, bool log_call_targets, bool analyze_apis
)
    : instruction_count_(0), log_registers_(log_registers), log_stack_info_(log_stack_info),
      log_call_targets_(log_call_targets), analyze_apis_(analyze_apis), modules_initialized_(false),
      metadata_written_(false) {

  // initialize output if file specified
  if (!output_file.empty()) {
    jsonl_writer_ = std::make_unique<w1::util::jsonl_writer>(output_file);
    if (!jsonl_writer_->is_open()) {
      log_.err("failed to open output file", redlog::field("path", output_file));
      jsonl_writer_.reset();
    }
  }

  // initialize stats
  stats_.total_calls = 0;
  stats_.total_returns = 0;
  stats_.unique_call_targets = 0;
  stats_.unique_return_sources = 0;
  stats_.max_call_depth = 0;
  stats_.current_call_depth = 0;

  // create symbol enricher if call targets are being logged
  if (log_call_targets_) {
    symbol_enricher_ = std::make_unique<symbol_enricher>();
  }

  // create API listener if API analysis is enabled
  if (analyze_apis_) {
    w1::abi::analyzer_config cfg;
    cfg.extract_arguments = true;
    cfg.format_calls = true;
    cfg.max_string_length = 256;
    api_listener_ = std::make_unique<w1::abi::api_listener>(cfg);
  }
}

void transfer_collector::record_call(
    uint64_t source_addr, uint64_t target_addr, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  stats_.total_calls++;
  update_call_depth(transfer_type::CALL);

  // track unique targets
  unique_call_targets_.insert(target_addr);
  stats_.unique_call_targets = unique_call_targets_.size();

  transfer_entry entry = create_base_entry(transfer_type::CALL, source_addr, target_addr);
  entry.instruction_count = instruction_count_++;

  populate_entry_details(entry, source_addr, target_addr, vm, gpr);

  // perform API analysis if enabled
  if (analyze_apis_ && api_listener_) {
    w1::abi::api_context ctx;
    ctx.call_address = source_addr;
    ctx.target_address = target_addr;
    ctx.module_name = entry.target_module;
    ctx.symbol_name = entry.target_symbol.symbol_name;
    ctx.vm = vm;
    ctx.vm_state = state;
    ctx.gpr_state = gpr;
    ctx.fpr_state = fpr;
    ctx.module_index = &index_;

    // directly analyze the call
    if (auto api_event = api_listener_->analyze_call(ctx)) {
      on_api_event(*api_event, entry);
    }
  }

  // write event if output configured
  if (jsonl_writer_) {
    ensure_metadata_written();
    write_event(entry);
  }
}

void transfer_collector::record_return(
    uint64_t source_addr, uint64_t target_addr, QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr,
    QBDI::FPRState* fpr
) {
  stats_.total_returns++;
  update_call_depth(transfer_type::RETURN);

  // track unique sources
  unique_return_sources_.insert(source_addr);
  stats_.unique_return_sources = unique_return_sources_.size();

  transfer_entry entry = create_base_entry(transfer_type::RETURN, source_addr, target_addr);
  entry.instruction_count = instruction_count_++;

  populate_entry_details(entry, source_addr, target_addr, vm, gpr);

  // perform return value analysis if enabled
  if (analyze_apis_ && api_listener_) {
    w1::abi::api_context ctx;
    ctx.call_address = target_addr;   // where we're returning to
    ctx.target_address = source_addr; // the function we're returning from
    ctx.module_name = entry.source_module;
    ctx.symbol_name = entry.source_symbol.symbol_name;
    ctx.vm = vm;
    ctx.vm_state = state;
    ctx.gpr_state = gpr;
    ctx.fpr_state = fpr;
    ctx.module_index = &index_;

    // directly analyze the return
    if (auto api_event = api_listener_->analyze_return(ctx)) {
      on_api_event(*api_event, entry);
    }
  }

  // write event if output configured
  if (jsonl_writer_) {
    ensure_metadata_written();
    write_event(entry);
  }
}

// removed build_report - we now stream directly

// helper function to convert our utility register_state to w1xfer register_state for JSON
static register_state convert_register_state(const w1::util::register_state& util_regs) {
  register_state regs;
  regs.registers = util_regs.get_all_registers();
  return regs;
}

// helper function to convert our utility stack_info to w1xfer stack_info for JSON
static stack_info convert_stack_info(const w1::util::stack_info& util_stack) {
  stack_info stack;
  stack.stack_pointer = util_stack.stack_pointer;
  stack.frame_pointer = util_stack.frame_pointer;
  stack.return_address = util_stack.return_address;

  // extract stack values from the captured entries
  stack.stack_values.reserve(util_stack.values.size());
  for (const auto& entry : util_stack.values) {
    if (entry.is_valid) {
      stack.stack_values.push_back(entry.value);
    }
  }

  return stack;
}

void transfer_collector::initialize_module_tracking() {
  if (modules_initialized_) {
    return;
  }

  // scan all executable modules
  auto modules = scanner_.scan_executable_modules();

  // rebuild index with all modules for fast lookup
  index_.rebuild_from_modules(std::move(modules));

  // initialize symbol enricher with the module index
  if (symbol_enricher_) {
    symbol_enricher_->initialize(index_);
  }

  // initialize API listener with the module index
  if (api_listener_) {
    api_listener_->initialize(index_);
  }

  modules_initialized_ = true;
}

std::string transfer_collector::get_module_name(uint64_t address) const {
  if (address == 0) {
    return "unknown";
  }

  // ensure modules are initialized before lookup
  if (!modules_initialized_) {
    // lazy initialization - cast away const for initialization
    const_cast<transfer_collector*>(this)->initialize_module_tracking();
  }

  // fast lookup using module range index
  auto module_info = index_.find_containing(address);
  if (module_info) {
    return module_info->name;
  }

  // fallback for addresses not in any known module
  return "unknown";
}

void transfer_collector::update_call_depth(transfer_type type) {
  if (type == transfer_type::CALL) {
    stats_.current_call_depth++;
    stats_.max_call_depth = std::max(stats_.max_call_depth, stats_.current_call_depth);
  } else if (type == transfer_type::RETURN && stats_.current_call_depth > 0) {
    stats_.current_call_depth--;
  }
}

symbol_info transfer_collector::enrich_symbol(uint64_t address) const {
  symbol_info info{};

  if (!symbol_enricher_) {
    return info;
  }

  auto enriched = symbol_enricher_->enrich_address(address);
  if (enriched) {
    info.symbol_name = enriched->symbol_name;
    info.demangled_name = enriched->demangled_name;
    info.symbol_offset = enriched->symbol_offset;
    info.module_offset = enriched->module_offset;
    info.is_exported = enriched->is_exported;
    info.is_imported = enriched->is_imported;
  }

  return info;
}

transfer_entry transfer_collector::create_base_entry(
    transfer_type type, uint64_t source_addr, uint64_t target_addr
) const {
  transfer_entry entry;
  entry.type = type;
  entry.source_address = source_addr;
  entry.target_address = target_addr;
  entry.instruction_count = instruction_count_;
  return entry;
}

void transfer_collector::populate_entry_details(
    transfer_entry& entry, uint64_t source_addr, uint64_t target_addr, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr
) const {
  if (log_registers_) {
    // use our register capture utility
    auto util_regs = w1::util::register_capturer::capture(gpr);
    entry.registers = convert_register_state(util_regs);
  }

  if (log_stack_info_) {
    // use our stack capture utility
    auto util_regs = w1::util::register_capturer::capture(gpr);
    auto util_stack = w1::util::stack_capturer::capture(vm, util_regs);
    entry.stack = convert_stack_info(util_stack);
  }

  if (log_call_targets_) {
    entry.source_module = get_module_name(source_addr);
    entry.target_module = get_module_name(target_addr);

    if (symbol_enricher_) {
      entry.source_symbol = enrich_symbol(source_addr);
      entry.target_symbol = enrich_symbol(target_addr);
    }
  }
}

void transfer_collector::on_api_event(const w1::abi::api_event& event, transfer_entry& entry) {
  // convert api_event data to transfer_entry api_analysis format
  entry.api_info.api_category =
      event.category == w1::abi::api_info::category::UNKNOWN ? "" : std::to_string(static_cast<int>(event.category));
  entry.api_info.description = event.description;
  entry.api_info.formatted_call = event.formatted_call;
  entry.api_info.analysis_complete = event.analysis_complete;

  // convert arguments
  entry.api_info.arguments.clear();
  for (const auto& arg : event.arguments) {
    api_argument api_arg;
    api_arg.raw_value = arg.raw_value;
    api_arg.param_name = arg.param_name;
    api_arg.param_type = std::to_string(static_cast<int>(arg.param_type));
    api_arg.is_pointer = arg.is_pointer;
    api_arg.interpreted_value = arg.interpreted_value;
    entry.api_info.arguments.push_back(api_arg);
  }

  // handle return value if present
  if (event.type == w1::abi::api_event::event_type::RETURN && event.return_value.has_value()) {
    const auto& ret_val = event.return_value.value();
    entry.api_info.has_return_value = true;
    entry.api_info.return_value.raw_value = ret_val.raw_value;
    entry.api_info.return_value.param_type = std::to_string(static_cast<int>(ret_val.param_type));
    entry.api_info.return_value.is_pointer = ret_val.is_pointer;
    entry.api_info.return_value.interpreted_value = ret_val.interpreted_value;
    entry.api_info.return_value.is_null = (ret_val.interpreted_value == "NULL");
  } else {
    entry.api_info.has_return_value = false;
  }
}

void transfer_collector::ensure_metadata_written() {
  if (!jsonl_writer_ || metadata_written_) {
    return;
  }

  // ensure modules are initialized
  if (!modules_initialized_) {
    initialize_module_tracking();
  }

  write_metadata();
  metadata_written_ = true;
}

void transfer_collector::write_metadata() {
  if (!jsonl_writer_ || !jsonl_writer_->is_open()) {
    return;
  }

  // create metadata object
  std::stringstream json;
  json << "{\"type\":\"metadata\",\"version\":1,\"tracer\":\"w1xfer\"";

  // add module information
  json << ",\"modules\":[";

  bool first = true;
  size_t module_id = 0;
  index_.visit_all([&](const w1::util::module_info& mod) {
    if (!first) {
      json << ",";
    }
    first = false;

    json << "{\"id\":" << module_id++ << ",\"name\":\"" << w1::util::value_formatter::escape_json_string(mod.name)
         << "\""
         << ",\"path\":\"" << w1::util::value_formatter::escape_json_string(mod.path) << "\""
         << ",\"base\":" << mod.base_address << ",\"size\":" << mod.size << ",\"type\":\""
         << (mod.type == w1::util::module_type::MAIN_EXECUTABLE ? "main" : "library") << "\""
         << ",\"is_system\":" << (mod.is_system_library ? "true" : "false") << "}";
  });

  json << "]}";

  jsonl_writer_->write_line(json.str());
}

void transfer_collector::write_event(const transfer_entry& entry) {
  if (!jsonl_writer_ || !jsonl_writer_->is_open()) {
    return;
  }

  // build compact json manually to exclude empty/disabled fields
  std::stringstream json;
  json << "{\"type\":\"event\",\"data\":{";

  // helper to append a field with proper comma handling
  bool first = true;
  auto append_field = [&json, &first](const std::string& field) {
    if (!first) {
      json << ",";
    }
    json << field;
    first = false;
  };

  // always include core fields
  append_field("\"type\":\"" + std::string(entry.type == transfer_type::CALL ? "call" : "return") + "\"");
  append_field("\"source_address\":" + std::to_string(entry.source_address));
  append_field("\"target_address\":" + std::to_string(entry.target_address));
  append_field("\"instruction_count\":" + std::to_string(entry.instruction_count));

  // conditionally include registers if enabled and present
  if (log_registers_ && !entry.registers.registers.empty()) {
    std::stringstream reg_json;
    reg_json << "{";
    bool first_reg = true;
    for (const auto& [name, value] : entry.registers.registers) {
      if (!first_reg) {
        reg_json << ",";
      }
      reg_json << "\"" << name << "\":" << value;
      first_reg = false;
    }
    reg_json << "}";
    append_field("\"registers\":" + reg_json.str());
  }

  // conditionally include stack info if enabled
  if (log_stack_info_) {
    append_field(
        "\"stack\":" + JS::serializeStruct(entry.stack, JS::SerializerOptions(JS::SerializerOptions::Compact))
    );
  }

  // conditionally include module names if enabled and non-empty
  if (log_call_targets_) {
    if (!entry.source_module.empty() && entry.source_module != "unknown") {
      append_field("\"source_module\":\"" + w1::util::value_formatter::escape_json_string(entry.source_module) + "\"");
    }
    if (!entry.target_module.empty() && entry.target_module != "unknown") {
      append_field("\"target_module\":\"" + w1::util::value_formatter::escape_json_string(entry.target_module) + "\"");
    }

    // include symbol info only if meaningful data exists
    if (!entry.source_symbol.symbol_name.empty()) {
      std::stringstream sym_json;
      sym_json << "{\"symbol_name\":\""
               << w1::util::value_formatter::escape_json_string(entry.source_symbol.symbol_name)
               << "\",\"symbol_offset\":" << entry.source_symbol.symbol_offset
               << ",\"module_offset\":" << entry.source_symbol.module_offset << "}";
      append_field("\"source_symbol\":" + sym_json.str());
    }
    if (!entry.target_symbol.symbol_name.empty()) {
      std::stringstream sym_json;
      sym_json << "{\"symbol_name\":\""
               << w1::util::value_formatter::escape_json_string(entry.target_symbol.symbol_name)
               << "\",\"symbol_offset\":" << entry.target_symbol.symbol_offset
               << ",\"module_offset\":" << entry.target_symbol.module_offset << "}";
      append_field("\"target_symbol\":" + sym_json.str());
    }
  }

  // conditionally include API analysis if enabled and has meaningful data
  if (analyze_apis_ && entry.api_info.analysis_complete && !entry.api_info.api_category.empty()) {
    std::stringstream api_json;
    api_json << "{\"api_category\":\"" << entry.api_info.api_category << "\"";

    // include arguments if present
    if (!entry.api_info.arguments.empty()) {
      api_json << ",\"arguments\":[";
      for (size_t i = 0; i < entry.api_info.arguments.size(); ++i) {
        if (i > 0) {
          api_json << ",";
        }
        const auto& arg = entry.api_info.arguments[i];
        api_json << "{\"raw_value\":" << arg.raw_value << ",\"param_name\":\""
                 << w1::util::value_formatter::escape_json_string(arg.param_name) << "\""
                 << ",\"param_type\":\"" << arg.param_type << "\""
                 << ",\"interpreted_value\":\"" << w1::util::value_formatter::escape_json_string(arg.interpreted_value)
                 << "\""
                 << ",\"is_pointer\":" << (arg.is_pointer ? "true" : "false") << "}";
      }
      api_json << "]";
    }

    // include return value if present
    if (entry.api_info.has_return_value) {
      api_json << ",\"return_value\":{\"raw_value\":" << entry.api_info.return_value.raw_value << ",\"param_type\":\""
               << entry.api_info.return_value.param_type << "\""
               << ",\"interpreted_value\":\""
               << w1::util::value_formatter::escape_json_string(entry.api_info.return_value.interpreted_value) << "\""
               << ",\"is_pointer\":" << (entry.api_info.return_value.is_pointer ? "true" : "false")
               << ",\"is_null\":" << (entry.api_info.return_value.is_null ? "true" : "false") << "}";
    }

    api_json << ",\"formatted_call\":\"" << w1::util::value_formatter::escape_json_string(entry.api_info.formatted_call)
             << "\""
             << ",\"analysis_complete\":" << (entry.api_info.analysis_complete ? "true" : "false")
             << ",\"has_return_value\":" << (entry.api_info.has_return_value ? "true" : "false") << "}";

    append_field("\"api_info\":" + api_json.str());
  }

  json << "}}";

  jsonl_writer_->write_line(json.str());
}

} // namespace w1xfer
```

`src/tracers/w1xfer/transfer_collector.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <memory>
#include <string>
#include <unordered_set>
#include <vector>

#include <QBDI.h>
#include <redlog.hpp>
#include <w1common/ext/jsonstruct.hpp>
#include <w1tn3ss/util/module_range_index.hpp>
#include <w1tn3ss/util/module_scanner.hpp>
#include <w1tn3ss/util/register_capture.hpp>
#include <w1tn3ss/util/stack_capture.hpp>
#include <w1tn3ss/util/value_formatter.hpp>
#include <w1tn3ss/util/jsonl_writer.hpp>
#include <w1tn3ss/abi/api_listener.hpp>
#include "symbol_enricher.hpp"

namespace w1xfer {

enum class transfer_type { CALL = 0, RETURN = 1 };

// register state is now a map of register names to values for JSON serialization
struct register_state {
  std::unordered_map<std::string, uint64_t> registers;

  JS_OBJECT(JS_MEMBER(registers));
};

struct stack_info {
  uint64_t stack_pointer;
  uint64_t frame_pointer;
  uint64_t return_address;
  std::vector<uint64_t> stack_values;

  JS_OBJECT(JS_MEMBER(stack_pointer), JS_MEMBER(frame_pointer), JS_MEMBER(return_address), JS_MEMBER(stack_values));
};

// rich symbol information for transfer endpoints
struct symbol_info {
  std::string symbol_name;
  std::string demangled_name;
  uint64_t symbol_offset; // offset within the symbol
  uint64_t module_offset; // offset within the module
  bool is_exported;
  bool is_imported;

  JS_OBJECT(
      JS_MEMBER(symbol_name), JS_MEMBER(demangled_name), JS_MEMBER(symbol_offset), JS_MEMBER(module_offset),
      JS_MEMBER(is_exported), JS_MEMBER(is_imported)
  );
};

// api argument information
struct api_argument {
  uint64_t raw_value;
  std::string param_name;
  std::string param_type;
  std::string interpreted_value; // string representation of interpreted value
  bool is_pointer;

  JS_OBJECT(
      JS_MEMBER(raw_value), JS_MEMBER(param_name), JS_MEMBER(param_type), JS_MEMBER(interpreted_value),
      JS_MEMBER(is_pointer)
  );
};

// return value information
struct api_return_value {
  uint64_t raw_value;
  std::string param_type;
  std::string interpreted_value;
  bool is_pointer;
  bool is_null;

  JS_OBJECT(
      JS_MEMBER(raw_value), JS_MEMBER(param_type), JS_MEMBER(interpreted_value), JS_MEMBER(is_pointer),
      JS_MEMBER(is_null)
  );
};

// api analysis information
struct api_analysis {
  std::string api_category;
  std::string description;
  std::vector<api_argument> arguments;
  api_return_value return_value;
  std::string formatted_call;
  bool analysis_complete;
  bool has_return_value;

  JS_OBJECT(
      JS_MEMBER(api_category), JS_MEMBER(description), JS_MEMBER(arguments), JS_MEMBER(return_value),
      JS_MEMBER(formatted_call), JS_MEMBER(analysis_complete), JS_MEMBER(has_return_value)
  );
};

struct transfer_entry {
  transfer_type type;
  uint64_t source_address;
  uint64_t target_address;
  uint64_t instruction_count;
  register_state registers;
  stack_info stack;
  std::string source_module;
  std::string target_module;
  // rich symbol information
  symbol_info source_symbol;
  symbol_info target_symbol;
  // api analysis information
  api_analysis api_info;

  JS_OBJECT(
      JS_MEMBER(type), JS_MEMBER(source_address), JS_MEMBER(target_address), JS_MEMBER(instruction_count),
      JS_MEMBER(registers), JS_MEMBER(stack), JS_MEMBER(source_module), JS_MEMBER(target_module),
      JS_MEMBER(source_symbol), JS_MEMBER(target_symbol), JS_MEMBER(api_info)
  );
};

struct transfer_stats {
  uint64_t total_calls;
  uint64_t total_returns;
  uint64_t unique_call_targets;
  uint64_t unique_return_sources;
  uint64_t max_call_depth;
  uint64_t current_call_depth;

  JS_OBJECT(
      JS_MEMBER(total_calls), JS_MEMBER(total_returns), JS_MEMBER(unique_call_targets),
      JS_MEMBER(unique_return_sources), JS_MEMBER(max_call_depth), JS_MEMBER(current_call_depth)
  );
};

// removed w1xfer_report - we now stream directly

class transfer_collector {
public:
  explicit transfer_collector(
      const std::string& output_file, bool log_registers, bool log_stack_info, bool log_call_targets,
      bool analyze_apis = false
  );

  void initialize_module_tracking();

  void record_call(
      uint64_t source_addr, uint64_t target_addr, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );
  void record_return(
      uint64_t source_addr, uint64_t target_addr, QBDI::VMInstanceRef vm, const QBDI::VMState* state,
      QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );

  const transfer_stats& get_stats() const { return stats_; }
  uint64_t get_instruction_count() const { return instruction_count_; }

  std::string get_module_name(uint64_t address) const;

private:
  transfer_stats stats_;
  uint64_t instruction_count_;
  bool log_registers_;
  bool log_stack_info_;
  bool log_call_targets_;
  bool analyze_apis_;
  w1::util::module_scanner scanner_;
  w1::util::module_range_index index_;
  bool modules_initialized_;
  std::unique_ptr<symbol_enricher> symbol_enricher_;
  std::unique_ptr<w1::abi::api_listener> api_listener_;
  redlog::logger log_ = redlog::get_logger("w1.transfer_collector");

  // output handling
  std::unique_ptr<w1::util::jsonl_writer> jsonl_writer_;
  bool metadata_written_ = false;

  // unique target tracking for stats
  std::unordered_set<uint64_t> unique_call_targets_;
  std::unordered_set<uint64_t> unique_return_sources_;

  void update_call_depth(transfer_type type);
  symbol_info enrich_symbol(uint64_t address) const;

  // helper methods to reduce code duplication
  transfer_entry create_base_entry(transfer_type type, uint64_t source_addr, uint64_t target_addr) const;
  void populate_entry_details(
      transfer_entry& entry, uint64_t source_addr, uint64_t target_addr, QBDI::VMInstanceRef vm, QBDI::GPRState* gpr
  ) const;

  // api event handlers
  void on_api_event(const w1::abi::api_event& event, transfer_entry& entry);

  // output helpers
  void ensure_metadata_written();
  void write_metadata();
  void write_event(const transfer_entry& entry);
};

} // namespace w1xfer

// custom serialization for transfer_type enum outside namespace
namespace JS {
template <> struct TypeHandler<w1xfer::transfer_type> {
  static inline void from(const w1xfer::transfer_type& from_type, Token& token, Serializer& serializer) {
    std::string type_str = (from_type == w1xfer::transfer_type::CALL) ? "call" : "return";
    TypeHandler<std::string>::from(type_str, token, serializer);
  }
  static inline void to(w1xfer::transfer_type& to_type, ParseContext& context) {
    std::string type_str;
    TypeHandler<std::string>::to(type_str, context);
    to_type = (type_str == "call") ? w1xfer::transfer_type::CALL : w1xfer::transfer_type::RETURN;
  }
};
} // namespace JS
```

`src/tracers/w1xfer/transfer_config.hpp`:

```hpp
#pragma once

#include <string>
#include <w1tn3ss/util/env_config.hpp>
#include <w1tn3ss/engine/tracer_config_base.hpp>

namespace w1xfer {

struct transfer_config : public w1::tracer_config_base {
  int verbose = 0;
  std::string output_file = "";
  bool log_registers = true;
  bool log_stack_info = true;
  bool log_call_targets = true;
  bool analyze_apis = false;

  static transfer_config from_environment() {
    w1::util::env_config loader("W1XFER_");

    transfer_config config;
    config.include_system_modules = loader.get<bool>("INCLUDE_SYSTEM", false);
    config.verbose = loader.get<int>("VERBOSE", 0);
    config.output_file = loader.get<std::string>("OUTPUT", "");
    config.log_registers = loader.get<bool>("LOG_REGISTERS", true);
    config.log_stack_info = loader.get<bool>("LOG_STACK_INFO", true);
    config.log_call_targets = loader.get<bool>("LOG_CALL_TARGETS", true);
    config.analyze_apis = loader.get<bool>("ANALYZE_APIS", false);

    return config;
  }
};

} // namespace w1xfer
```

`src/tracers/w1xfer/transfer_tracer.cpp`:

```cpp
#include "transfer_tracer.hpp"

#include <w1tn3ss/util/register_access.hpp>
#include <fstream>

namespace w1xfer {

transfer_tracer::transfer_tracer(const transfer_config& config)
    : config_(config),
      collector_(
          config.output_file, config.log_registers, config.log_stack_info, config.log_call_targets, config.analyze_apis
      ) {

  if (config_.verbose) {
    log_.inf(
        "transfer tracer created", redlog::field("output", config_.output_file),
        redlog::field("log_registers", config_.log_registers), redlog::field("log_stack_info", config_.log_stack_info),
        redlog::field("log_call_targets", config_.log_call_targets), redlog::field("analyze_apis", config_.analyze_apis)
    );
  }
}

bool transfer_tracer::initialize(w1::tracer_engine<transfer_tracer>& engine) {
  log_.inf("initializing transfer tracer");

  QBDI::VM* vm = engine.get_vm();
  if (!vm) {
    log_.err("vm instance is null");
    return false;
  }

  // initialize module tracking for fast module name lookup
  if (config_.log_call_targets) {
    log_.inf("initializing module tracking");
    collector_.initialize_module_tracking();
    log_.inf("module tracking initialized");
  }

  // output will stream automatically if output_file was provided

  if (config_.verbose) {
    log_.inf("transfer tracer initialized successfully");
  }

  return true;
}

void transfer_tracer::shutdown() {
  log_.inf("shutting down transfer tracer");

  // log summary stats
  const auto& stats = collector_.get_stats();
  log_.inf(
      "transfer collection completed", redlog::field("total_calls", stats.total_calls),
      redlog::field("total_returns", stats.total_returns), redlog::field("unique_targets", stats.unique_call_targets),
      redlog::field("max_depth", stats.max_call_depth)
  );
}

QBDI::VMAction transfer_tracer::on_exec_transfer_call(
    QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  // extract call information from vm state
  uint64_t source_addr = state->sequenceStart;

  // get target address from instruction pointer
  uint64_t target_addr = w1::registers::get_pc(gpr);

  if (config_.verbose) {
    std::string source_module = "unknown";
    std::string target_module = "unknown";

    if (config_.log_call_targets) {
      source_module = collector_.get_module_name(source_addr);
      target_module = collector_.get_module_name(target_addr);
    }

    log_.vrb(
        "call transfer detected", redlog::field("source", "0x%016llx", source_addr),
        redlog::field("target", "0x%016llx", target_addr), redlog::field("source_module", source_module),
        redlog::field("target_module", target_module)
    );
  }

  // record the call transfer
  collector_.record_call(source_addr, target_addr, vm, state, gpr, fpr);

  return QBDI::VMAction::CONTINUE;
}

QBDI::VMAction transfer_tracer::on_exec_transfer_return(
    QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr
) {
  // extract return information from vm state
  uint64_t source_addr = state->sequenceStart;

  // get target address from instruction pointer
  uint64_t target_addr = w1::registers::get_pc(gpr);

  if (config_.verbose) {
    std::string source_module = "unknown";
    std::string target_module = "unknown";

    if (config_.log_call_targets) {
      source_module = collector_.get_module_name(source_addr);
      target_module = collector_.get_module_name(target_addr);
    }

    log_.vrb(
        "return transfer detected", redlog::field("source", "0x%016llx", source_addr),
        redlog::field("target", "0x%016llx", target_addr), redlog::field("source_module", source_module),
        redlog::field("target_module", target_module)
    );
  }

  // record the return transfer
  collector_.record_return(source_addr, target_addr, vm, state, gpr, fpr);

  return QBDI::VMAction::CONTINUE;
}

const transfer_stats& transfer_tracer::get_stats() const { return collector_.get_stats(); }

// removed get_trace_size and export_report - data now streams directly

} // namespace w1xfer
```

`src/tracers/w1xfer/transfer_tracer.hpp`:

```hpp
#pragma once

#include <QBDI.h>
#include <redlog.hpp>
#include <w1tn3ss/engine/tracer_engine.hpp>

#include "transfer_collector.hpp"
#include "transfer_config.hpp"

namespace w1xfer {

class transfer_tracer {
public:
  explicit transfer_tracer(const transfer_config& config);

  bool initialize(w1::tracer_engine<transfer_tracer>& engine);
  void shutdown();
  const char* get_name() const { return "w1xfer"; }

  // exec transfer callbacks - these match the signatures expected by tracer_engine
  QBDI::VMAction on_exec_transfer_call(
      QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );
  QBDI::VMAction on_exec_transfer_return(
      QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr
  );

  // statistics access
  const transfer_stats& get_stats() const;

private:
  transfer_config config_;
  transfer_collector collector_;
  redlog::logger log_ = redlog::get_logger("w1.transfer_tracer");
};

} // namespace w1xfer
```

`src/w1common/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${WITNESS_SOURCE_DIR}/cmake/CommonConfig.cmake)

add_library(common INTERFACE)

target_include_directories(common INTERFACE
    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
    $<INSTALL_INTERFACE:include/w1common>
)

target_compile_features(common INTERFACE cxx_std_17)

install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/ext/
    DESTINATION include/w1common/ext
    FILES_MATCHING PATTERN "*.hpp" PATTERN "*.h"
)

file(GLOB COMMON_HEADERS ${CMAKE_CURRENT_SOURCE_DIR}/*.hpp)
install(FILES ${COMMON_HEADERS}
    DESTINATION include/w1common
)

install(TARGETS common EXPORT w1tn3ssTargets)
```

`src/w1common/ext/args.hpp`:

```hpp
/* A simple header-only C++ argument parser library.
 *
 * https://github.com/Taywee/args
 *
 * Copyright (c) 2016-2024 Taylor C. Richberger <taylor@axfive.net> and Pavel
 * Belikov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

/** \file args.hxx
 * \brief this single-header lets you use all of the args functionality
 *
 * The important stuff is done inside the args namespace
 */

#ifndef ARGS_HXX
#define ARGS_HXX

#define ARGS_VERSION "6.4.7"
#define ARGS_VERSION_MAJOR 6
#define ARGS_VERSION_MINOR 4
#define ARGS_VERSION_PATCH 7

#include <algorithm>
#include <cctype>
#include <cstddef>
#include <exception>
#include <functional>
#include <iostream>
#include <iterator>
#include <sstream>
#include <string>
#include <tuple>
#include <type_traits>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#if defined(_MSC_VER) && _MSC_VER <= 1800
#define noexcept
#endif

#ifdef ARGS_TESTNAMESPACE
namespace argstest {
#else

/** \namespace args
 * \brief contains all the functionality of the args library
 */
namespace args {
#endif
/** Getter to grab the value from the argument type.
 *
 * If the Get() function of the type returns a reference, so does this, and
 * the value will be modifiable.
 */
template <typename Option> auto get(Option& option_) -> decltype(option_.Get()) { return option_.Get(); }

/** (INTERNAL) Count UTF-8 glyphs
 *
 * This is not reliable, and will fail for combinatory glyphs, but it's
 * good enough here for now.
 *
 * \param string The string to count glyphs from
 * \return The UTF-8 glyphs in the string
 */
inline std::string::size_type Glyphs(const std::string& string_) {
  std::string::size_type length = 0;
  for (const char c : string_) {
    if ((c & 0xc0) != 0x80) {
      ++length;
    }
  }
  return length;
}

/** (INTERNAL) Wrap a vector of words into a vector of lines
 *
 * Empty words are skipped. Word "\n" forces wrapping.
 *
 * \param begin The begin iterator
 * \param end The end iterator
 * \param width The width of the body
 * \param firstlinewidth the width of the first line, defaults to the width of the body
 * \param firstlineindent the indent of the first line, defaults to 0
 * \return the vector of lines
 */
template <typename It>
inline std::vector<std::string> Wrap(
    It begin, It end, const std::string::size_type width, std::string::size_type firstlinewidth = 0,
    std::string::size_type firstlineindent = 0
) {
  std::vector<std::string> output;
  std::string line(firstlineindent, ' ');
  bool empty = true;

  if (firstlinewidth == 0) {
    firstlinewidth = width;
  }

  auto currentwidth = firstlinewidth;

  for (auto it = begin; it != end; ++it) {
    if (it->empty()) {
      continue;
    }

    if (*it == "\n") {
      if (!empty) {
        output.push_back(line);
        line.clear();
        empty = true;
        currentwidth = width;
      }

      continue;
    }

    auto itemsize = Glyphs(*it);
    if ((line.length() + 1 + itemsize) > currentwidth) {
      if (!empty) {
        output.push_back(line);
        line.clear();
        empty = true;
        currentwidth = width;
      }
    }

    if (itemsize > 0) {
      if (!empty) {
        line += ' ';
      }

      line += *it;
      empty = false;
    }
  }

  if (!empty) {
    output.push_back(line);
  }

  return output;
}

namespace detail {
template <typename T> std::string Join(const T& array, const std::string& delimiter) {
  std::string res;
  for (auto& element : array) {
    if (!res.empty()) {
      res += delimiter;
    }

    res += element;
  }

  return res;
}
} // namespace detail

/** (INTERNAL) Wrap a string into a vector of lines
 *
 * This is quick and hacky, but works well enough.  You can specify a
 * different width for the first line
 *
 * \param width The width of the body
 * \param firstlinewid the width of the first line, defaults to the width of the body
 * \return the vector of lines
 */
inline std::vector<std::string> Wrap(
    const std::string& in, const std::string::size_type width, std::string::size_type firstlinewidth = 0
) {
  // Preserve existing line breaks
  const auto newlineloc = in.find('\n');
  if (newlineloc != in.npos) {
    auto first = Wrap(std::string(in, 0, newlineloc), width);
    auto second = Wrap(std::string(in, newlineloc + 1), width);
    first.insert(
        std::end(first), std::make_move_iterator(std::begin(second)), std::make_move_iterator(std::end(second))
    );
    return first;
  }

  std::istringstream stream(in);
  std::string::size_type indent = 0;

  for (auto c : in) {
    if (!std::isspace(static_cast<unsigned char>(c))) {
      break;
    }
    ++indent;
  }

  return Wrap(
      std::istream_iterator<std::string>(stream), std::istream_iterator<std::string>(), width, firstlinewidth, indent
  );
}

#ifdef ARGS_NOEXCEPT
/// Error class, for when ARGS_NOEXCEPT is defined
enum class Error {
  None,
  Usage,
  Parse,
  Validation,
  Required,
  Map,
  Extra,
  Help,
  Subparser,
  Completion,
};
#else
/** Base error class
 */
class Error : public std::runtime_error {
public:
  Error(const std::string& problem) : std::runtime_error(problem) {}
  virtual ~Error() {}
};

/** Errors that occur during usage
 */
class UsageError : public Error {
public:
  UsageError(const std::string& problem) : Error(problem) {}
  virtual ~UsageError() {}
};

/** Errors that occur during regular parsing
 */
class ParseError : public Error {
public:
  ParseError(const std::string& problem) : Error(problem) {}
  virtual ~ParseError() {}
};

/** Errors that are detected from group validation after parsing finishes
 */
class ValidationError : public Error {
public:
  ValidationError(const std::string& problem) : Error(problem) {}
  virtual ~ValidationError() {}
};

/** Errors that when a required flag is omitted
 */
class RequiredError : public ValidationError {
public:
  RequiredError(const std::string& problem) : ValidationError(problem) {}
  virtual ~RequiredError() {}
};

/** Errors in map lookups
 */
class MapError : public ParseError {
public:
  MapError(const std::string& problem) : ParseError(problem) {}
  virtual ~MapError() {}
};

/** Error that occurs when a singular flag is specified multiple times
 */
class ExtraError : public ParseError {
public:
  ExtraError(const std::string& problem) : ParseError(problem) {}
  virtual ~ExtraError() {}
};

/** An exception that indicates that the user has requested help
 */
class Help : public Error {
public:
  Help(const std::string& flag) : Error(flag) {}
  virtual ~Help() {}
};

/** (INTERNAL) An exception that emulates coroutine-like control flow for subparsers.
 */
class SubparserError : public Error {
public:
  SubparserError() : Error("") {}
  virtual ~SubparserError() {}
};

/** An exception that contains autocompletion reply
 */
class Completion : public Error {
public:
  Completion(const std::string& flag) : Error(flag) {}
  virtual ~Completion() {}
};
#endif

/** A simple unified option type for unified initializer lists for the Matcher class.
 */
struct EitherFlag {
  const bool isShort;
  const char shortFlag;
  const std::string longFlag;
  EitherFlag(const std::string& flag) : isShort(false), shortFlag(), longFlag(flag) {}
  EitherFlag(const char* flag) : isShort(false), shortFlag(), longFlag(flag) {}
  EitherFlag(const char flag) : isShort(true), shortFlag(flag), longFlag() {}

  /** Get just the long flags from an initializer list of EitherFlags
   */
  static std::unordered_set<std::string> GetLong(std::initializer_list<EitherFlag> flags) {
    std::unordered_set<std::string> longFlags;
    for (const EitherFlag& flag : flags) {
      if (!flag.isShort) {
        longFlags.insert(flag.longFlag);
      }
    }
    return longFlags;
  }

  /** Get just the short flags from an initializer list of EitherFlags
   */
  static std::unordered_set<char> GetShort(std::initializer_list<EitherFlag> flags) {
    std::unordered_set<char> shortFlags;
    for (const EitherFlag& flag : flags) {
      if (flag.isShort) {
        shortFlags.insert(flag.shortFlag);
      }
    }
    return shortFlags;
  }

  std::string str() const { return isShort ? std::string(1, shortFlag) : longFlag; }

  std::string str(const std::string& shortPrefix, const std::string& longPrefix) const {
    return isShort ? shortPrefix + std::string(1, shortFlag) : longPrefix + longFlag;
  }
};

/** A class of "matchers", specifying short and flags that can possibly be
 * matched.
 *
 * This is supposed to be constructed and then passed in, not used directly
 * from user code.
 */
class Matcher {
private:
  const std::unordered_set<char> shortFlags;
  const std::unordered_set<std::string> longFlags;

public:
  /** Specify short and long flags separately as iterators
   *
   * ex: `args::Matcher(shortFlags.begin(), shortFlags.end(), longFlags.begin(), longFlags.end())`
   */
  template <typename ShortIt, typename LongIt>
  Matcher(ShortIt shortFlagsStart, ShortIt shortFlagsEnd, LongIt longFlagsStart, LongIt longFlagsEnd)
      : shortFlags(shortFlagsStart, shortFlagsEnd), longFlags(longFlagsStart, longFlagsEnd) {
    if (shortFlags.empty() && longFlags.empty()) {
#ifndef ARGS_NOEXCEPT
      throw UsageError("empty Matcher");
#endif
    }
  }

#ifdef ARGS_NOEXCEPT
  /// Only for ARGS_NOEXCEPT
  Error GetError() const noexcept { return shortFlags.empty() && longFlags.empty() ? Error::Usage : Error::None; }
#endif

  /** Specify short and long flags separately as iterables
   *
   * ex: `args::Matcher(shortFlags, longFlags)`
   */
  template <typename Short, typename Long>
  Matcher(Short&& shortIn, Long&& longIn)
      : Matcher(std::begin(shortIn), std::end(shortIn), std::begin(longIn), std::end(longIn)) {}

  /** Specify a mixed single initializer-list of both short and long flags
   *
   * This is the fancy one.  It takes a single initializer list of
   * any number of any mixed kinds of flags.  Chars are
   * automatically interpreted as short flags, and strings are
   * automatically interpreted as long flags:
   *
   *     args::Matcher{'a'}
   *     args::Matcher{"foo"}
   *     args::Matcher{'h', "help"}
   *     args::Matcher{"foo", 'f', 'F', "FoO"}
   */
  Matcher(std::initializer_list<EitherFlag> in) : Matcher(EitherFlag::GetShort(in), EitherFlag::GetLong(in)) {}

  Matcher(Matcher&& other) noexcept : shortFlags(std::move(other.shortFlags)), longFlags(std::move(other.longFlags)) {}

  ~Matcher() {}

  /** (INTERNAL) Check if there is a match of a short flag
   */
  bool Match(const char flag) const { return shortFlags.find(flag) != shortFlags.end(); }

  /** (INTERNAL) Check if there is a match of a long flag
   */
  bool Match(const std::string& flag) const { return longFlags.find(flag) != longFlags.end(); }

  /** (INTERNAL) Check if there is a match of a flag
   */
  bool Match(const EitherFlag& flag) const { return flag.isShort ? Match(flag.shortFlag) : Match(flag.longFlag); }

  /** (INTERNAL) Get all flag strings as a vector, with the prefixes embedded
   */
  std::vector<EitherFlag> GetFlagStrings() const {
    std::vector<EitherFlag> flagStrings;
    flagStrings.reserve(shortFlags.size() + longFlags.size());
    for (const char flag : shortFlags) {
      flagStrings.emplace_back(flag);
    }
    for (const std::string& flag : longFlags) {
      flagStrings.emplace_back(flag);
    }
    return flagStrings;
  }

  /** (INTERNAL) Get long flag if it exists or any short flag
   */
  EitherFlag GetLongOrAny() const {
    if (!longFlags.empty()) {
      return *longFlags.begin();
    }

    if (!shortFlags.empty()) {
      return *shortFlags.begin();
    }

    // should be unreachable
    return ' ';
  }

  /** (INTERNAL) Get short flag if it exists or any long flag
   */
  EitherFlag GetShortOrAny() const {
    if (!shortFlags.empty()) {
      return *shortFlags.begin();
    }

    if (!longFlags.empty()) {
      return *longFlags.begin();
    }

    // should be unreachable
    return ' ';
  }
};

/** Attributes for flags.
 */
enum class Options {
  /** Default options.
   */
  None = 0x0,

  /** Flag can't be passed multiple times.
   */
  Single = 0x01,

  /** Flag can't be omitted.
   */
  Required = 0x02,

  /** Flag is excluded from usage line.
   */
  HiddenFromUsage = 0x04,

  /** Flag is excluded from options help.
   */
  HiddenFromDescription = 0x08,

  /** Flag is global and can be used in any subcommand.
   */
  Global = 0x10,

  /** Flag stops a parser.
   */
  KickOut = 0x20,

  /** Flag is excluded from auto completion.
   */
  HiddenFromCompletion = 0x40,

  /** Flag is excluded from options help and usage line
   */
  Hidden = HiddenFromUsage | HiddenFromDescription | HiddenFromCompletion,
};

inline Options operator|(Options lhs, Options rhs) {
  return static_cast<Options>(static_cast<int>(lhs) | static_cast<int>(rhs));
}

inline Options operator&(Options lhs, Options rhs) {
  return static_cast<Options>(static_cast<int>(lhs) & static_cast<int>(rhs));
}

class FlagBase;
class PositionalBase;
class Command;
class ArgumentParser;

/** A simple structure of parameters for easy user-modifyable help menus
 */
struct HelpParams {
  /** The width of the help menu
   */
  unsigned int width = 80;
  /** The indent of the program line
   */
  unsigned int progindent = 2;
  /** The indent of the program trailing lines for long parameters
   */
  unsigned int progtailindent = 4;
  /** The indent of the description and epilogs
   */
  unsigned int descriptionindent = 4;
  /** The indent of the flags
   */
  unsigned int flagindent = 6;
  /** The indent of the flag descriptions
   */
  unsigned int helpindent = 40;
  /** The additional indent each group adds
   */
  unsigned int eachgroupindent = 2;

  /** The minimum gutter between each flag and its help
   */
  unsigned int gutter = 1;

  /** Show the terminator when both options and positional parameters are present
   */
  bool showTerminator = true;

  /** Show the {OPTIONS} on the prog line when this is true
   */
  bool showProglineOptions = true;

  /** Show the positionals on the prog line when this is true
   */
  bool showProglinePositionals = true;

  /** The prefix for short flags
   */
  std::string shortPrefix;

  /** The prefix for long flags
   */
  std::string longPrefix;

  /** The separator for short flags
   */
  std::string shortSeparator;

  /** The separator for long flags
   */
  std::string longSeparator;

  /** The program name for help generation
   */
  std::string programName;

  /** Show command's flags
   */
  bool showCommandChildren = false;

  /** Show command's descriptions and epilog
   */
  bool showCommandFullHelp = false;

  /** The postfix for progline when showProglineOptions is true and command has any flags
   */
  std::string proglineOptions = "{OPTIONS}";

  /** The prefix for progline when command has any subcommands
   */
  std::string proglineCommand = "COMMAND";

  /** The prefix for progline value
   */
  std::string proglineValueOpen = " <";

  /** The postfix for progline value
   */
  std::string proglineValueClose = ">";

  /** The prefix for progline required argument
   */
  std::string proglineRequiredOpen = "";

  /** The postfix for progline required argument
   */
  std::string proglineRequiredClose = "";

  /** The prefix for progline non-required argument
   */
  std::string proglineNonrequiredOpen = "[";

  /** The postfix for progline non-required argument
   */
  std::string proglineNonrequiredClose = "]";

  /** Show flags in program line
   */
  bool proglineShowFlags = false;

  /** Use short flags in program lines when possible
   */
  bool proglinePreferShortFlags = false;

  /** Program line prefix
   */
  std::string usageString;

  /** String shown in help before flags descriptions
   */
  std::string optionsString = "OPTIONS:";

  /** Display value name after all the long and short flags
   */
  bool useValueNameOnce = false;

  /** Show value name
   */
  bool showValueName = true;

  /** Add newline before flag description
   */
  bool addNewlineBeforeDescription = false;

  /** The prefix for option value
   */
  std::string valueOpen = "[";

  /** The postfix for option value
   */
  std::string valueClose = "]";

  /** Add choices to argument description
   */
  bool addChoices = false;

  /** The prefix for choices
   */
  std::string choiceString = "\nOne of: ";

  /** Add default values to argument description
   */
  bool addDefault = false;

  /** The prefix for default values
   */
  std::string defaultString = "\nDefault: ";
};

/** A number of arguments which can be consumed by an option.
 *
 * Represents a closed interval [min, max].
 */
struct Nargs {
  const size_t min;
  const size_t max;

  Nargs(size_t min_, size_t max_) : min{min_}, max{max_} {
#ifndef ARGS_NOEXCEPT
    if (max < min) {
      throw UsageError("Nargs: max > min");
    }
#endif
  }

  Nargs(size_t num_) : min{num_}, max{num_} {}

  friend bool operator==(const Nargs& lhs, const Nargs& rhs) { return lhs.min == rhs.min && lhs.max == rhs.max; }

  friend bool operator!=(const Nargs& lhs, const Nargs& rhs) { return !(lhs == rhs); }
};

/** Base class for all match types
 */
class Base {
private:
  Options options = {};

protected:
  bool matched = false;
  const std::string help;
#ifdef ARGS_NOEXCEPT
  /// Only for ARGS_NOEXCEPT
  mutable Error error = Error::None;
  mutable std::string errorMsg;
#endif

public:
  Base(const std::string& help_, Options options_ = {}) : options(options_), help(help_) {}
  virtual ~Base() {}

  Options GetOptions() const noexcept { return options; }

  bool IsRequired() const noexcept { return (GetOptions() & Options::Required) != Options::None; }

  virtual bool Matched() const noexcept { return matched; }

  virtual void Validate(const std::string&, const std::string&) const {}

  operator bool() const noexcept { return Matched(); }

  virtual std::vector<std::tuple<std::string, std::string, unsigned>> GetDescription(
      const HelpParams&, const unsigned indentLevel
  ) const {
    std::tuple<std::string, std::string, unsigned> description;
    std::get<1>(description) = help;
    std::get<2>(description) = indentLevel;
    return {std::move(description)};
  }

  virtual std::vector<Command*> GetCommands() { return {}; }

  virtual bool IsGroup() const { return false; }

  virtual FlagBase* Match(const EitherFlag&) { return nullptr; }

  virtual PositionalBase* GetNextPositional() { return nullptr; }

  virtual std::vector<FlagBase*> GetAllFlags() { return {}; }

  virtual bool HasFlag() const { return false; }

  virtual bool HasPositional() const { return false; }

  virtual bool HasCommand() const { return false; }

  virtual std::vector<std::string> GetProgramLine(const HelpParams&) const { return {}; }

  /// Sets a kick-out value for building subparsers
  void KickOut(bool kickout_) noexcept {
    if (kickout_) {
      options = options | Options::KickOut;
    } else {
      options = static_cast<Options>(static_cast<int>(options) & ~static_cast<int>(Options::KickOut));
    }
  }

  /// Gets the kick-out value for building subparsers
  bool KickOut() const noexcept { return (options & Options::KickOut) != Options::None; }

  virtual void Reset() noexcept {
    matched = false;
#ifdef ARGS_NOEXCEPT
    error = Error::None;
    errorMsg.clear();
#endif
  }

#ifdef ARGS_NOEXCEPT
  /// Only for ARGS_NOEXCEPT
  virtual Error GetError() const { return error; }

  /// Only for ARGS_NOEXCEPT
  virtual std::string GetErrorMsg() const { return errorMsg; }
#endif
};

/** Base class for all match types that have a name
 */
class NamedBase : public Base {
protected:
  const std::string name;
  bool kickout = false;
  std::string defaultString;
  bool defaultStringManual = false;
  std::vector<std::string> choicesStrings;
  bool choicesStringManual = false;

  virtual std::string GetDefaultString(const HelpParams&) const { return {}; }

  virtual std::vector<std::string> GetChoicesStrings(const HelpParams&) const { return {}; }

  virtual std::string GetNameString(const HelpParams&) const { return Name(); }

  void AddDescriptionPostfix(
      std::string& dest, const bool isManual, const std::string& manual, bool isGenerated, const std::string& generated,
      const std::string& str
  ) const {
    if (isManual && !manual.empty()) {
      dest += str;
      dest += manual;
    } else if (!isManual && isGenerated && !generated.empty()) {
      dest += str;
      dest += generated;
    }
  }

public:
  NamedBase(const std::string& name_, const std::string& help_, Options options_ = {})
      : Base(help_, options_), name(name_) {}
  virtual ~NamedBase() {}

  /** Sets default value string that will be added to argument description.
   *  Use empty string to disable it for this argument.
   */
  void HelpDefault(const std::string& str) {
    defaultStringManual = true;
    defaultString = str;
  }

  /** Gets default value string that will be added to argument description.
   */
  std::string HelpDefault(const HelpParams& params) const {
    return defaultStringManual ? defaultString : GetDefaultString(params);
  }

  /** Sets choices strings that will be added to argument description.
   *  Use empty vector to disable it for this argument.
   */
  void HelpChoices(const std::vector<std::string>& array) {
    choicesStringManual = true;
    choicesStrings = array;
  }

  /** Gets choices strings that will be added to argument description.
   */
  std::vector<std::string> HelpChoices(const HelpParams& params) const {
    return choicesStringManual ? choicesStrings : GetChoicesStrings(params);
  }

  virtual std::vector<std::tuple<std::string, std::string, unsigned>> GetDescription(
      const HelpParams& params, const unsigned indentLevel
  ) const override {
    std::tuple<std::string, std::string, unsigned> description;
    std::get<0>(description) = GetNameString(params);
    std::get<1>(description) = help;
    std::get<2>(description) = indentLevel;

    AddDescriptionPostfix(
        std::get<1>(description), choicesStringManual, detail::Join(choicesStrings, ", "), params.addChoices,
        detail::Join(GetChoicesStrings(params), ", "), params.choiceString
    );
    AddDescriptionPostfix(
        std::get<1>(description), defaultStringManual, defaultString, params.addDefault, GetDefaultString(params),
        params.defaultString
    );

    return {std::move(description)};
  }

  virtual std::string Name() const { return name; }
};

namespace detail {
template <typename T> using vector = std::vector<T, std::allocator<T>>;

template <typename K, typename T>
using unordered_map = std::unordered_map<K, T, std::hash<K>, std::equal_to<K>, std::allocator<std::pair<const K, T>>>;

template <typename S, typename T> class is_streamable {
  template <typename SS, typename TT>
  static auto test(int) -> decltype(std::declval<SS&>() << std::declval<TT>(), std::true_type());

  template <typename, typename> static auto test(...) -> std::false_type;

public:
  using type = decltype(test<S, T>(0));
};

template <typename T> using IsConvertableToString = typename is_streamable<std::ostringstream, T>::type;

template <typename T>
typename std::enable_if<IsConvertableToString<T>::value, std::string>::type ToString(const T& value) {
  std::ostringstream s;
  s << value;
  return s.str();
}

template <typename T> typename std::enable_if<!IsConvertableToString<T>::value, std::string>::type ToString(const T&) {
  return {};
}

template <typename T> std::vector<std::string> MapKeysToStrings(const T& map) {
  std::vector<std::string> res;
  using K = typename std::decay<decltype(std::begin(map)->first)>::type;
  if (IsConvertableToString<K>::value) {
    for (const auto& p : map) {
      res.push_back(detail::ToString(p.first));
    }

    std::sort(res.begin(), res.end());
  }
  return res;
}
} // namespace detail

/** Base class for all flag options
 */
class FlagBase : public NamedBase {
protected:
  const Matcher matcher;

  virtual std::string GetNameString(const HelpParams& params) const override {
    const std::string postfix = !params.showValueName || NumberOfArguments() == 0 ? std::string() : Name();
    std::string flags;
    const auto flagStrings = matcher.GetFlagStrings();
    const bool useValueNameOnce = flagStrings.size() == 1 ? false : params.useValueNameOnce;
    for (auto it = flagStrings.begin(); it != flagStrings.end(); ++it) {
      auto& flag = *it;
      if (it != flagStrings.begin()) {
        flags += ", ";
      }

      flags += flag.isShort ? params.shortPrefix : params.longPrefix;
      flags += flag.str();

      if (!postfix.empty() && (!useValueNameOnce || it + 1 == flagStrings.end())) {
        flags += flag.isShort ? params.shortSeparator : params.longSeparator;
        flags += params.valueOpen + postfix + params.valueClose;
      }
    }

    return flags;
  }

public:
  FlagBase(const std::string& name_, const std::string& help_, Matcher&& matcher_, const bool extraError_ = false)
      : NamedBase(name_, help_, extraError_ ? Options::Single : Options()), matcher(std::move(matcher_)) {}

  FlagBase(const std::string& name_, const std::string& help_, Matcher&& matcher_, Options options_)
      : NamedBase(name_, help_, options_), matcher(std::move(matcher_)) {}

  virtual ~FlagBase() {}

  virtual FlagBase* Match(const EitherFlag& flag) override {
    if (matcher.Match(flag)) {
      if ((GetOptions() & Options::Single) != Options::None && matched) {
        std::ostringstream problem;
        problem << "Flag '" << flag.str() << "' was passed multiple times, but is only allowed to be passed once";
#ifdef ARGS_NOEXCEPT
        error = Error::Extra;
        errorMsg = problem.str();
#else
        throw ExtraError(problem.str());
#endif
      }
      matched = true;
      return this;
    }
    return nullptr;
  }

  virtual std::vector<FlagBase*> GetAllFlags() override { return {this}; }

  const Matcher& GetMatcher() const { return matcher; }

  virtual void Validate(const std::string& shortPrefix, const std::string& longPrefix) const override {
    if (!Matched() && IsRequired()) {
      std::ostringstream problem;
      problem << "Flag '" << matcher.GetLongOrAny().str(shortPrefix, longPrefix) << "' is required";
#ifdef ARGS_NOEXCEPT
      error = Error::Required;
      errorMsg = problem.str();
#else
      throw RequiredError(problem.str());
#endif
    }
  }

  virtual std::vector<std::string> GetProgramLine(const HelpParams& params) const override {
    if (!params.proglineShowFlags) {
      return {};
    }

    const std::string postfix = NumberOfArguments() == 0 ? std::string() : Name();
    const EitherFlag flag = params.proglinePreferShortFlags ? matcher.GetShortOrAny() : matcher.GetLongOrAny();
    std::string res = flag.str(params.shortPrefix, params.longPrefix);
    if (!postfix.empty()) {
      res += params.proglineValueOpen + postfix + params.proglineValueClose;
    }

    return {
        IsRequired() ? params.proglineRequiredOpen + res + params.proglineRequiredClose
                     : params.proglineNonrequiredOpen + res + params.proglineNonrequiredClose
    };
  }

  virtual bool HasFlag() const override { return true; }

#ifdef ARGS_NOEXCEPT
  /// Only for ARGS_NOEXCEPT
  virtual Error GetError() const override {
    const auto nargs = NumberOfArguments();
    if (nargs.min > nargs.max) {
      return Error::Usage;
    }

    const auto matcherError = matcher.GetError();
    if (matcherError != Error::None) {
      return matcherError;
    }

    return error;
  }
#endif

  /** Defines how many values can be consumed by this option.
   *
   * \return closed interval [min, max]
   */
  virtual Nargs NumberOfArguments() const noexcept = 0;

  /** Parse values of this option.
   *
   * \param value Vector of values. It's size must be in NumberOfArguments() interval.
   */
  virtual void ParseValue(const std::vector<std::string>& value) = 0;
};

/** Base class for value-accepting flag options
 */
class ValueFlagBase : public FlagBase {
public:
  ValueFlagBase(const std::string& name_, const std::string& help_, Matcher&& matcher_, const bool extraError_ = false)
      : FlagBase(name_, help_, std::move(matcher_), extraError_) {}
  ValueFlagBase(const std::string& name_, const std::string& help_, Matcher&& matcher_, Options options_)
      : FlagBase(name_, help_, std::move(matcher_), options_) {}
  virtual ~ValueFlagBase() {}

  virtual Nargs NumberOfArguments() const noexcept override { return 1; }
};

class CompletionFlag : public ValueFlagBase {
public:
  std::vector<std::string> reply;
  size_t cword = 0;
  std::string syntax;

  template <typename GroupClass>
  CompletionFlag(GroupClass& group_, Matcher&& matcher_)
      : ValueFlagBase("completion", "completion flag", std::move(matcher_), Options::Hidden) {
    group_.AddCompletion(*this);
  }

  virtual ~CompletionFlag() {}

  virtual Nargs NumberOfArguments() const noexcept override { return 2; }

  virtual void ParseValue(const std::vector<std::string>& value_) override {
    syntax = value_.at(0);
    std::istringstream(value_.at(1)) >> cword;
  }

  /** Get the completion reply
   */
  std::string Get() noexcept { return detail::Join(reply, "\n"); }

  virtual void Reset() noexcept override {
    ValueFlagBase::Reset();
    cword = 0;
    syntax.clear();
    reply.clear();
  }
};

/** Base class for positional options
 */
class PositionalBase : public NamedBase {
protected:
  bool ready;

public:
  PositionalBase(const std::string& name_, const std::string& help_, Options options_ = {})
      : NamedBase(name_, help_, options_), ready(true) {}
  virtual ~PositionalBase() {}

  bool Ready() { return ready; }

  virtual void ParseValue(const std::string& value_) = 0;

  virtual void Reset() noexcept override {
    matched = false;
    ready = true;
#ifdef ARGS_NOEXCEPT
    error = Error::None;
    errorMsg.clear();
#endif
  }

  virtual PositionalBase* GetNextPositional() override { return Ready() ? this : nullptr; }

  virtual bool HasPositional() const override { return true; }

  virtual std::vector<std::string> GetProgramLine(const HelpParams& params) const override {
    return {
        IsRequired() ? params.proglineRequiredOpen + Name() + params.proglineRequiredClose
                     : params.proglineNonrequiredOpen + Name() + params.proglineNonrequiredClose
    };
  }

  virtual void Validate(const std::string&, const std::string&) const override {
    if (IsRequired() && !Matched()) {
      std::ostringstream problem;
      problem << "Option '" << Name() << "' is required";
#ifdef ARGS_NOEXCEPT
      error = Error::Required;
      errorMsg = problem.str();
#else
      throw RequiredError(problem.str());
#endif
    }
  }
};

/** Class for all kinds of validating groups, including ArgumentParser
 */
class Group : public Base {
private:
  std::vector<Base*> children;
  std::function<bool(const Group&)> validator;

public:
  /** Default validators
   */
  struct Validators {
    static bool Xor(const Group& group) { return group.MatchedChildren() == 1; }

    static bool AtLeastOne(const Group& group) { return group.MatchedChildren() >= 1; }

    static bool AtMostOne(const Group& group) { return group.MatchedChildren() <= 1; }

    static bool All(const Group& group) { return group.Children().size() == group.MatchedChildren(); }

    static bool AllOrNone(const Group& group) { return (All(group) || None(group)); }

    static bool AllChildGroups(const Group& group) {
      return std::none_of(std::begin(group.Children()), std::end(group.Children()), [](const Base* child) -> bool {
        return child->IsGroup() && !child->Matched();
      });
    }

    static bool DontCare(const Group&) { return true; }

    static bool CareTooMuch(const Group&) { return false; }

    static bool None(const Group& group) { return group.MatchedChildren() == 0; }
  };
  /// If help is empty, this group will not be printed in help output
  Group(
      const std::string& help_ = std::string(),
      const std::function<bool(const Group&)>& validator_ = Validators::DontCare, Options options_ = {}
  )
      : Base(help_, options_), validator(validator_) {}
  /// If help is empty, this group will not be printed in help output
  Group(
      Group& group_, const std::string& help_ = std::string(),
      const std::function<bool(const Group&)>& validator_ = Validators::DontCare, Options options_ = {}
  )
      : Base(help_, options_), validator(validator_) {
    group_.Add(*this);
  }
  virtual ~Group() {}

  /** Append a child to this Group.
   */
  void Add(Base& child) { children.emplace_back(&child); }

  /** Get all this group's children
   */
  const std::vector<Base*>& Children() const { return children; }

  /** Return the first FlagBase that matches flag, or nullptr
   *
   * \param flag The flag with prefixes stripped
   * \return the first matching FlagBase pointer, or nullptr if there is no match
   */
  virtual FlagBase* Match(const EitherFlag& flag) override {
    for (Base* child : Children()) {
      if (FlagBase* match = child->Match(flag)) {
        return match;
      }
    }
    return nullptr;
  }

  virtual std::vector<FlagBase*> GetAllFlags() override {
    std::vector<FlagBase*> res;
    for (Base* child : Children()) {
      auto childRes = child->GetAllFlags();
      res.insert(res.end(), childRes.begin(), childRes.end());
    }
    return res;
  }

  virtual void Validate(const std::string& shortPrefix, const std::string& longPrefix) const override {
    for (Base* child : Children()) {
      child->Validate(shortPrefix, longPrefix);
    }
  }

  /** Get the next ready positional, or nullptr if there is none
   *
   * \return the first ready PositionalBase pointer, or nullptr if there is no match
   */
  virtual PositionalBase* GetNextPositional() override {
    for (Base* child : Children()) {
      if (auto next = child->GetNextPositional()) {
        return next;
      }
    }
    return nullptr;
  }

  /** Get whether this has any FlagBase children
   *
   * \return Whether or not there are any FlagBase children
   */
  virtual bool HasFlag() const override {
    return std::any_of(Children().begin(), Children().end(), [](Base* child) { return child->HasFlag(); });
  }

  /** Get whether this has any PositionalBase children
   *
   * \return Whether or not there are any PositionalBase children
   */
  virtual bool HasPositional() const override {
    return std::any_of(Children().begin(), Children().end(), [](Base* child) { return child->HasPositional(); });
  }

  /** Get whether this has any Command children
   *
   * \return Whether or not there are any Command children
   */
  virtual bool HasCommand() const override {
    return std::any_of(Children().begin(), Children().end(), [](Base* child) { return child->HasCommand(); });
  }

  /** Count the number of matched children this group has
   */
  std::vector<Base*>::size_type MatchedChildren() const {
    // Cast to avoid warnings from -Wsign-conversion
    return static_cast<std::vector<Base*>::size_type>(
        std::count_if(std::begin(Children()), std::end(Children()), [](const Base* child) { return child->Matched(); })
    );
  }

  /** Whether or not this group matches validation
   */
  virtual bool Matched() const noexcept override { return validator(*this); }

  /** Get validation
   */
  bool Get() const { return Matched(); }

  /** Get all the child descriptions for help generation
   */
  virtual std::vector<std::tuple<std::string, std::string, unsigned>> GetDescription(
      const HelpParams& params, const unsigned int indent
  ) const override {
    std::vector<std::tuple<std::string, std::string, unsigned int>> descriptions;

    // Push that group description on the back if not empty
    unsigned addindent = 0;
    if (!help.empty()) {
      descriptions.emplace_back(help, "", indent);
      addindent = 1;
    }

    for (Base* child : Children()) {
      if ((child->GetOptions() & Options::HiddenFromDescription) != Options::None) {
        continue;
      }

      auto groupDescriptions = child->GetDescription(params, indent + addindent);
      descriptions.insert(
          std::end(descriptions), std::make_move_iterator(std::begin(groupDescriptions)),
          std::make_move_iterator(std::end(groupDescriptions))
      );
    }
    return descriptions;
  }

  /** Get the names of positional parameters
   */
  virtual std::vector<std::string> GetProgramLine(const HelpParams& params) const override {
    std::vector<std::string> names;
    for (Base* child : Children()) {
      if ((child->GetOptions() & Options::HiddenFromUsage) != Options::None) {
        continue;
      }

      auto groupNames = child->GetProgramLine(params);
      names.insert(
          std::end(names), std::make_move_iterator(std::begin(groupNames)),
          std::make_move_iterator(std::end(groupNames))
      );
    }
    return names;
  }

  virtual std::vector<Command*> GetCommands() override {
    std::vector<Command*> res;
    for (const auto& child : Children()) {
      auto subparsers = child->GetCommands();
      res.insert(std::end(res), std::begin(subparsers), std::end(subparsers));
    }
    return res;
  }

  virtual bool IsGroup() const override { return true; }

  virtual void Reset() noexcept override {
    Base::Reset();

    for (auto& child : Children()) {
      child->Reset();
    }
#ifdef ARGS_NOEXCEPT
    error = Error::None;
    errorMsg.clear();
#endif
  }

#ifdef ARGS_NOEXCEPT
  /// Only for ARGS_NOEXCEPT
  virtual Error GetError() const override {
    if (error != Error::None) {
      return error;
    }

    auto it = std::find_if(Children().begin(), Children().end(), [](const Base* child) {
      return child->GetError() != Error::None;
    });
    if (it == Children().end()) {
      return Error::None;
    } else {
      return (*it)->GetError();
    }
  }

  /// Only for ARGS_NOEXCEPT
  virtual std::string GetErrorMsg() const override {
    if (error != Error::None) {
      return errorMsg;
    }

    auto it = std::find_if(Children().begin(), Children().end(), [](const Base* child) {
      return child->GetError() != Error::None;
    });
    if (it == Children().end()) {
      return "";
    } else {
      return (*it)->GetErrorMsg();
    }
  }
#endif
};

/** Class for using global options in ArgumentParser.
 */
class GlobalOptions : public Group {
public:
  GlobalOptions(Group& base, Base& options_) : Group(base, {}, Group::Validators::DontCare, Options::Global) {
    Add(options_);
  }
};

/** Utility class for building subparsers with coroutines/callbacks.
 *
 * Brief example:
 * \code
 * Command command(argumentParser, "command", "my command", [](args::Subparser &s)
 * {
 *      // your command flags/positionals
 *      s.Parse(); //required
 *      //your command code
 * });
 * \endcode
 *
 * For ARGS_NOEXCEPT mode don't forget to check `s.GetError()` after `s.Parse()`
 * and return if it isn't equals to args::Error::None.
 *
 * \sa Command
 */
class Subparser : public Group {
private:
  std::vector<std::string> args;
  std::vector<std::string> kicked;
  ArgumentParser* parser = nullptr;
  const HelpParams& helpParams;
  const Command& command;
  bool isParsed = false;

public:
  Subparser(
      std::vector<std::string> args_, ArgumentParser& parser_, const Command& command_, const HelpParams& helpParams_
  )
      : Group({}, Validators::AllChildGroups), args(std::move(args_)), parser(&parser_), helpParams(helpParams_),
        command(command_) {}

  Subparser(const Command& command_, const HelpParams& helpParams_)
      : Group({}, Validators::AllChildGroups), helpParams(helpParams_), command(command_) {}

  Subparser(const Subparser&) = delete;
  Subparser(Subparser&&) = delete;
  Subparser& operator=(const Subparser&) = delete;
  Subparser& operator=(Subparser&&) = delete;

  const Command& GetCommand() { return command; }

  /** (INTERNAL) Determines whether Parse was called or not.
   */
  bool IsParsed() const { return isParsed; }

  /** Continue parsing arguments for new command.
   */
  void Parse();

  /** Returns a vector of kicked out arguments.
   *
   * \sa Base::KickOut
   */
  const std::vector<std::string>& KickedOut() const noexcept { return kicked; }
};

/** Main class for building subparsers.
 *
 * /sa Subparser
 */
class Command : public Group {
private:
  friend class Subparser;

  std::string name;
  std::string help;
  std::string description;
  std::string epilog;
  std::string proglinePostfix;

  std::function<void(Subparser&)> parserCoroutine;
  bool commandIsRequired = true;
  Command* selectedCommand = nullptr;

  mutable std::vector<std::tuple<std::string, std::string, unsigned>> subparserDescription;
  mutable std::vector<std::string> subparserProgramLine;
  mutable bool subparserHasFlag = false;
  mutable bool subparserHasPositional = false;
  mutable bool subparserHasCommand = false;
#ifdef ARGS_NOEXCEPT
  mutable Error subparserError = Error::None;
#endif
  mutable Subparser* subparser = nullptr;

protected:
  class RaiiSubparser {
  public:
    RaiiSubparser(ArgumentParser& parser_, std::vector<std::string> args_);
    RaiiSubparser(const Command& command_, const HelpParams& params_);

    ~RaiiSubparser() { command.subparser = oldSubparser; }

    Subparser& Parser() { return parser; }

  private:
    const Command& command;
    Subparser parser;
    Subparser* oldSubparser;
  };

  Command() = default;

  std::function<void(Subparser&)>& GetCoroutine() {
    return selectedCommand != nullptr ? selectedCommand->GetCoroutine() : parserCoroutine;
  }

  Command& SelectedCommand() {
    Command* res = this;
    while (res->selectedCommand != nullptr) {
      res = res->selectedCommand;
    }

    return *res;
  }

  const Command& SelectedCommand() const {
    const Command* res = this;
    while (res->selectedCommand != nullptr) {
      res = res->selectedCommand;
    }

    return *res;
  }

  void UpdateSubparserHelp(const HelpParams& params) const {
    if (parserCoroutine) {
      RaiiSubparser coro(*this, params);
#ifndef ARGS_NOEXCEPT
      try {
        parserCoroutine(coro.Parser());
      } catch (args::SubparserError&) {
      }
#else
      parserCoroutine(coro.Parser());
#endif
    }
  }

public:
  Command(Group& base_, std::string name_, std::string help_, std::function<void(Subparser&)> coroutine_ = {})
      : name(std::move(name_)), help(std::move(help_)), parserCoroutine(std::move(coroutine_)) {
    base_.Add(*this);
  }

  /** The description that appears on the prog line after options
   */
  const std::string& ProglinePostfix() const { return proglinePostfix; }

  /** The description that appears on the prog line after options
   */
  void ProglinePostfix(const std::string& proglinePostfix_) { this->proglinePostfix = proglinePostfix_; }

  /** The description that appears above options
   */
  const std::string& Description() const { return description; }
  /** The description that appears above options
   */

  void Description(const std::string& description_) { this->description = description_; }

  /** The description that appears below options
   */
  const std::string& Epilog() const { return epilog; }

  /** The description that appears below options
   */
  void Epilog(const std::string& epilog_) { this->epilog = epilog_; }

  /** The name of command
   */
  const std::string& Name() const { return name; }

  /** The description of command
   */
  const std::string& Help() const { return help; }

  /** If value is true, parser will fail if no command was parsed.
   *
   * Default: true.
   */
  void RequireCommand(bool value) { commandIsRequired = value; }

  virtual bool IsGroup() const override { return false; }

  virtual bool Matched() const noexcept override { return Base::Matched(); }

  operator bool() const noexcept { return Matched(); }

  void Match() noexcept { matched = true; }

  void SelectCommand(Command* c) noexcept {
    selectedCommand = c;

    if (c != nullptr) {
      c->Match();
    }
  }

  virtual FlagBase* Match(const EitherFlag& flag) override {
    if (selectedCommand != nullptr) {
      if (auto* res = selectedCommand->Match(flag)) {
        return res;
      }

      for (auto* child : Children()) {
        if ((child->GetOptions() & Options::Global) != Options::None) {
          if (auto* res = child->Match(flag)) {
            return res;
          }
        }
      }

      return nullptr;
    }

    if (subparser != nullptr) {
      return subparser->Match(flag);
    }

    return Matched() ? Group::Match(flag) : nullptr;
  }

  virtual std::vector<FlagBase*> GetAllFlags() override {
    std::vector<FlagBase*> res;

    if (!Matched()) {
      return res;
    }

    for (auto* child : Children()) {
      if (selectedCommand == nullptr || (child->GetOptions() & Options::Global) != Options::None) {
        auto childFlags = child->GetAllFlags();
        res.insert(res.end(), childFlags.begin(), childFlags.end());
      }
    }

    if (selectedCommand != nullptr) {
      auto childFlags = selectedCommand->GetAllFlags();
      res.insert(res.end(), childFlags.begin(), childFlags.end());
    }

    if (subparser != nullptr) {
      auto childFlags = subparser->GetAllFlags();
      res.insert(res.end(), childFlags.begin(), childFlags.end());
    }

    return res;
  }

  virtual PositionalBase* GetNextPositional() override {
    if (selectedCommand != nullptr) {
      if (auto* res = selectedCommand->GetNextPositional()) {
        return res;
      }

      for (auto* child : Children()) {
        if ((child->GetOptions() & Options::Global) != Options::None) {
          if (auto* res = child->GetNextPositional()) {
            return res;
          }
        }
      }

      return nullptr;
    }

    if (subparser != nullptr) {
      return subparser->GetNextPositional();
    }

    return Matched() ? Group::GetNextPositional() : nullptr;
  }

  virtual bool HasFlag() const override { return subparserHasFlag || Group::HasFlag(); }

  virtual bool HasPositional() const override { return subparserHasPositional || Group::HasPositional(); }

  virtual bool HasCommand() const override { return true; }

  std::vector<std::string> GetCommandProgramLine(const HelpParams& params) const {
    UpdateSubparserHelp(params);

    std::vector<std::string> res;

    if ((subparserHasFlag || Group::HasFlag()) && params.showProglineOptions && !params.proglineShowFlags) {
      res.push_back(params.proglineOptions);
    }

    auto group_res = Group::GetProgramLine(params);
    std::move(std::move(group_res).begin(), std::move(group_res).end(), std::back_inserter(res));

    res.insert(res.end(), subparserProgramLine.begin(), subparserProgramLine.end());

    if (!params.proglineCommand.empty() && (Group::HasCommand() || subparserHasCommand)) {
      res.insert(res.begin(), commandIsRequired ? params.proglineCommand : "[" + params.proglineCommand + "]");
    }

    if (!Name().empty()) {
      res.insert(res.begin(), Name());
    }

    if (!ProglinePostfix().empty()) {
      std::string line;
      for (auto c : ProglinePostfix()) {
        if (std::isspace(static_cast<unsigned char>(c))) {
          if (!line.empty()) {
            res.push_back(line);
            line.clear();
          }

          if (c == '\n') {
            res.push_back("\n");
          }
        } else {
          line += c;
        }
      }

      if (!line.empty()) {
        res.push_back(line);
      }
    }

    return res;
  }

  virtual std::vector<std::string> GetProgramLine(const HelpParams& params) const override {
    if (!Matched()) {
      return {};
    }

    return GetCommandProgramLine(params);
  }

  virtual std::vector<Command*> GetCommands() override {
    if (selectedCommand != nullptr) {
      return selectedCommand->GetCommands();
    }

    if (Matched()) {
      return Group::GetCommands();
    }

    return {this};
  }

  virtual std::vector<std::tuple<std::string, std::string, unsigned>> GetDescription(
      const HelpParams& params, const unsigned int indent
  ) const override {
    std::vector<std::tuple<std::string, std::string, unsigned>> descriptions;
    unsigned addindent = 0;

    UpdateSubparserHelp(params);

    if (!Matched()) {
      if (params.showCommandFullHelp) {
        std::ostringstream s;
        bool empty = true;
        for (const auto& progline : GetCommandProgramLine(params)) {
          if (!empty) {
            s << ' ';
          } else {
            empty = false;
          }

          s << progline;
        }

        descriptions.emplace_back(s.str(), "", indent);
      } else {
        descriptions.emplace_back(Name(), help, indent);
      }

      if (!params.showCommandChildren && !params.showCommandFullHelp) {
        return descriptions;
      }

      addindent = 1;
    }

    if (params.showCommandFullHelp && !Matched()) {
      descriptions.emplace_back("", "", indent + addindent);
      descriptions.emplace_back(Description().empty() ? Help() : Description(), "", indent + addindent);
      descriptions.emplace_back("", "", indent + addindent);
    }

    for (Base* child : Children()) {
      if ((child->GetOptions() & Options::HiddenFromDescription) != Options::None) {
        continue;
      }

      auto groupDescriptions = child->GetDescription(params, indent + addindent);
      descriptions.insert(
          std::end(descriptions), std::make_move_iterator(std::begin(groupDescriptions)),
          std::make_move_iterator(std::end(groupDescriptions))
      );
    }

    for (auto childDescription : subparserDescription) {
      std::get<2>(childDescription) += indent + addindent;
      descriptions.push_back(std::move(childDescription));
    }

    if (params.showCommandFullHelp && !Matched()) {
      descriptions.emplace_back("", "", indent + addindent);
      if (!Epilog().empty()) {
        descriptions.emplace_back(Epilog(), "", indent + addindent);
        descriptions.emplace_back("", "", indent + addindent);
      }
    }

    return descriptions;
  }

  virtual void Validate(const std::string& shortprefix, const std::string& longprefix) const override {
    if (!Matched()) {
      return;
    }

    auto onValidationError = [&] {
      std::ostringstream problem;
      problem << "Group validation failed somewhere!";
#ifdef ARGS_NOEXCEPT
      error = Error::Validation;
      errorMsg = problem.str();
#else
      throw ValidationError(problem.str());
#endif
    };

    for (Base* child : Children()) {
      if (child->IsGroup() && !child->Matched()) {
        onValidationError();
      }

      child->Validate(shortprefix, longprefix);
    }

    if (subparser != nullptr) {
      subparser->Validate(shortprefix, longprefix);
      if (!subparser->Matched()) {
        onValidationError();
      }
    }

    if (selectedCommand == nullptr && commandIsRequired && (Group::HasCommand() || subparserHasCommand)) {
      std::ostringstream problem;
      problem << "Command is required";
#ifdef ARGS_NOEXCEPT
      error = Error::Validation;
      errorMsg = problem.str();
#else
      throw ValidationError(problem.str());
#endif
    }
  }

  virtual void Reset() noexcept override {
    Group::Reset();
    selectedCommand = nullptr;
    subparserProgramLine.clear();
    subparserDescription.clear();
    subparserHasFlag = false;
    subparserHasPositional = false;
    subparserHasCommand = false;
#ifdef ARGS_NOEXCEPT
    subparserError = Error::None;
#endif
  }

#ifdef ARGS_NOEXCEPT
  /// Only for ARGS_NOEXCEPT
  virtual Error GetError() const override {
    if (!Matched()) {
      return Error::None;
    }

    if (error != Error::None) {
      return error;
    }

    if (subparserError != Error::None) {
      return subparserError;
    }

    return Group::GetError();
  }
#endif
};

/** The main user facing command line argument parser class
 */
class ArgumentParser : public Command {
  friend class Subparser;

private:
  std::string longprefix;
  std::string shortprefix;

  std::string longseparator;

  std::string terminator;

  bool allowJoinedShortValue = true;
  bool allowJoinedLongValue = true;
  bool allowSeparateShortValue = true;
  bool allowSeparateLongValue = true;

  CompletionFlag* completion = nullptr;
  bool readCompletion = false;

protected:
  enum class OptionType { LongFlag, ShortFlag, Positional };

  OptionType ParseOption(const std::string& s, bool allowEmpty = false) {
    if (s.find(longprefix) == 0 && (allowEmpty || s.length() > longprefix.length())) {
      return OptionType::LongFlag;
    }

    if (s.find(shortprefix) == 0 && (allowEmpty || s.length() > shortprefix.length())) {
      return OptionType::ShortFlag;
    }

    return OptionType::Positional;
  }

  template <typename It> bool Complete(FlagBase& flag, It it, It end) {
    auto nextIt = it;
    if (!readCompletion || (++nextIt != end)) {
      return false;
    }

    const auto& chunk = *it;
    for (auto& choice : flag.HelpChoices(helpParams)) {
      AddCompletionReply(chunk, choice);
    }

#ifndef ARGS_NOEXCEPT
    throw Completion(completion->Get());
#else
    return true;
#endif
  }

  /** (INTERNAL) Parse flag's values
   *
   * \param arg The string to display in error message as a flag name
   * \param[in, out] it The iterator to first value. It will point to the last value
   * \param end The end iterator
   * \param joinedArg Joined value (e.g. bar in --foo=bar)
   * \param canDiscardJoined If true joined value can be parsed as flag not as a value (as in -abcd)
   * \param[out] values The vector to store parsed arg's values
   */
  template <typename It>
  std::string ParseArgsValues(
      FlagBase& flag, const std::string& arg, It& it, It end, const bool allowSeparate, const bool allowJoined,
      const bool hasJoined, const std::string& joinedArg, const bool canDiscardJoined, std::vector<std::string>& values
  ) {
    values.clear();

    Nargs nargs = flag.NumberOfArguments();

    if (hasJoined && !allowJoined && nargs.min != 0) {
      return "Flag '" + arg + "' was passed a joined argument, but these are disallowed";
    }

    if (hasJoined) {
      if (!canDiscardJoined || nargs.max != 0) {
        values.push_back(joinedArg);
      }
    } else if (!allowSeparate) {
      if (nargs.min != 0) {
        return "Flag '" + arg + "' was passed a separate argument, but these are disallowed";
      }
    } else {
      auto valueIt = it;
      ++valueIt;

      while (valueIt != end && values.size() < nargs.max &&
             (values.size() < nargs.min || ParseOption(*valueIt) == OptionType::Positional)) {
        if (Complete(flag, valueIt, end)) {
          it = end;
          return "";
        }

        values.push_back(*valueIt);
        ++it;
        ++valueIt;
      }
    }

    if (values.size() > nargs.max) {
      return "Passed an argument into a non-argument flag: " + arg;
    } else if (values.size() < nargs.min) {
      if (nargs.min == 1 && nargs.max == 1) {
        return "Flag '" + arg + "' requires an argument but received none";
      } else if (nargs.min == 1) {
        return "Flag '" + arg + "' requires at least one argument but received none";
      } else if (nargs.min != nargs.max) {
        return "Flag '" + arg + "' requires at least " + std::to_string(nargs.min) + " arguments but received " +
               std::to_string(values.size());
      } else {
        return "Flag '" + arg + "' requires " + std::to_string(nargs.min) + " arguments but received " +
               std::to_string(values.size());
      }
    }

    return {};
  }

  template <typename It> bool ParseLong(It& it, It end) {
    const auto& chunk = *it;
    const auto argchunk = chunk.substr(longprefix.size());
    // Try to separate it, in case of a separator:
    const auto separator = longseparator.empty() ? argchunk.npos : argchunk.find(longseparator);
    // If the separator is in the argument, separate it.
    const auto arg = (separator != argchunk.npos ? std::string(argchunk, 0, separator) : argchunk);
    const auto joined =
        (separator != argchunk.npos ? argchunk.substr(separator + longseparator.size()) : std::string());

    if (auto flag = Match(arg)) {
      std::vector<std::string> values;
      const std::string errorMessage = ParseArgsValues(
          *flag, arg, it, end, allowSeparateLongValue, allowJoinedLongValue, separator != argchunk.npos, joined, false,
          values
      );
      if (!errorMessage.empty()) {
#ifndef ARGS_NOEXCEPT
        throw ParseError(errorMessage);
#else
        error = Error::Parse;
        errorMsg = errorMessage;
        return false;
#endif
      }

      if (!readCompletion) {
        flag->ParseValue(values);
      }

      if (flag->KickOut()) {
        ++it;
        return false;
      }
    } else {
      const std::string errorMessage("Flag could not be matched: " + arg);
#ifndef ARGS_NOEXCEPT
      throw ParseError(errorMessage);
#else
      error = Error::Parse;
      errorMsg = errorMessage;
      return false;
#endif
    }

    return true;
  }

  template <typename It> bool ParseShort(It& it, It end) {
    const auto& chunk = *it;
    const auto argchunk = chunk.substr(shortprefix.size());
    for (auto argit = std::begin(argchunk); argit != std::end(argchunk); ++argit) {
      const auto arg = *argit;

      if (auto flag = Match(arg)) {
        const std::string value(argit + 1, std::end(argchunk));
        std::vector<std::string> values;
        const std::string errorMessage = ParseArgsValues(
            *flag, std::string(1, arg), it, end, allowSeparateShortValue, allowJoinedShortValue, !value.empty(), value,
            !value.empty(), values
        );

        if (!errorMessage.empty()) {
#ifndef ARGS_NOEXCEPT
          throw ParseError(errorMessage);
#else
          error = Error::Parse;
          errorMsg = errorMessage;
          return false;
#endif
        }

        if (!readCompletion) {
          flag->ParseValue(values);
        }

        if (flag->KickOut()) {
          ++it;
          return false;
        }

        if (!values.empty()) {
          break;
        }
      } else {
        const std::string errorMessage("Flag could not be matched: '" + std::string(1, arg) + "'");
#ifndef ARGS_NOEXCEPT
        throw ParseError(errorMessage);
#else
        error = Error::Parse;
        errorMsg = errorMessage;
        return false;
#endif
      }
    }

    return true;
  }

  bool AddCompletionReply(const std::string& cur, const std::string& choice) {
    if (cur.empty() || choice.find(cur) == 0) {
      if (completion->syntax == "bash" && ParseOption(choice) == OptionType::LongFlag &&
          choice.find(longseparator) != std::string::npos) {
        completion->reply.push_back(choice.substr(choice.find(longseparator) + 1));
      } else {
        completion->reply.push_back(choice);
      }
      return true;
    }

    return false;
  }

  template <typename It> bool Complete(It it, It end) {
    auto nextIt = it;
    if (!readCompletion || (++nextIt != end)) {
      return false;
    }

    const auto& chunk = *it;
    auto pos = GetNextPositional();
    std::vector<Command*> commands = GetCommands();
    const auto optionType = ParseOption(chunk, true);

    if (!commands.empty() && (chunk.empty() || optionType == OptionType::Positional)) {
      for (auto& cmd : commands) {
        if ((cmd->GetOptions() & Options::HiddenFromCompletion) == Options::None) {
          AddCompletionReply(chunk, cmd->Name());
        }
      }
    } else {
      bool hasPositionalCompletion = true;

      if (!commands.empty()) {
        for (auto& cmd : commands) {
          if ((cmd->GetOptions() & Options::HiddenFromCompletion) == Options::None) {
            AddCompletionReply(chunk, cmd->Name());
          }
        }
      } else if (pos) {
        if ((pos->GetOptions() & Options::HiddenFromCompletion) == Options::None) {
          auto choices = pos->HelpChoices(helpParams);
          hasPositionalCompletion = !choices.empty() || optionType != OptionType::Positional;
          for (auto& choice : choices) {
            AddCompletionReply(chunk, choice);
          }
        }
      }

      if (hasPositionalCompletion) {
        auto flags = GetAllFlags();
        for (auto flag : flags) {
          if ((flag->GetOptions() & Options::HiddenFromCompletion) != Options::None) {
            continue;
          }

          auto& matcher = flag->GetMatcher();
          if (!AddCompletionReply(chunk, matcher.GetShortOrAny().str(shortprefix, longprefix))) {
            for (auto& flagName : matcher.GetFlagStrings()) {
              if (AddCompletionReply(chunk, flagName.str(shortprefix, longprefix))) {
                break;
              }
            }
          }
        }

        if (optionType == OptionType::LongFlag && allowJoinedLongValue) {
          const auto separator = longseparator.empty() ? chunk.npos : chunk.find(longseparator);
          if (separator != chunk.npos) {
            std::string arg(chunk, 0, separator);
            if (auto flag = this->Match(arg.substr(longprefix.size()))) {
              for (auto& choice : flag->HelpChoices(helpParams)) {
                AddCompletionReply(chunk, arg + longseparator + choice);
              }
            }
          }
        } else if (optionType == OptionType::ShortFlag && allowJoinedShortValue) {
          if (chunk.size() > shortprefix.size() + 1) {
            auto arg = chunk.at(shortprefix.size());
            // TODO: support -abcVALUE where a and b take no value
            if (auto flag = this->Match(arg)) {
              for (auto& choice : flag->HelpChoices(helpParams)) {
                AddCompletionReply(chunk, shortprefix + arg + choice);
              }
            }
          }
        }
      }
    }

#ifndef ARGS_NOEXCEPT
    throw Completion(completion->Get());
#else
    return true;
#endif
  }

  template <typename It> It Parse(It begin, It end) {
    bool terminated = false;
    std::vector<Command*> commands = GetCommands();

    // Check all arg chunks
    for (auto it = begin; it != end; ++it) {
      if (Complete(it, end)) {
        return end;
      }

      const auto& chunk = *it;

      if (!terminated && chunk == terminator) {
        terminated = true;
      } else if (!terminated && ParseOption(chunk) == OptionType::LongFlag) {
        if (!ParseLong(it, end)) {
          return it;
        }
      } else if (!terminated && ParseOption(chunk) == OptionType::ShortFlag) {
        if (!ParseShort(it, end)) {
          return it;
        }
      } else if (!terminated && !commands.empty()) {
        auto itCommand =
            std::find_if(commands.begin(), commands.end(), [&chunk](Command* c) { return c->Name() == chunk; });
        if (itCommand == commands.end()) {
          const std::string errorMessage("Unknown command: " + chunk);
#ifndef ARGS_NOEXCEPT
          throw ParseError(errorMessage);
#else
          error = Error::Parse;
          errorMsg = errorMessage;
          return it;
#endif
        }

        SelectCommand(*itCommand);

        if (const auto& coroutine = GetCoroutine()) {
          ++it;
          RaiiSubparser coro(*this, std::vector<std::string>(it, end));
          coroutine(coro.Parser());
#ifdef ARGS_NOEXCEPT
          error = GetError();
          if (error != Error::None) {
            return end;
          }

          if (!coro.Parser().IsParsed()) {
            error = Error::Usage;
            return end;
          }
#else
          if (!coro.Parser().IsParsed()) {
            throw UsageError("Subparser::Parse was not called");
          }
#endif

          break;
        }

        commands = GetCommands();
      } else {
        auto pos = GetNextPositional();
        if (pos) {
          pos->ParseValue(chunk);

          if (pos->KickOut()) {
            return ++it;
          }
        } else {
          const std::string errorMessage(
              "Passed in argument, but no positional arguments were ready to receive it: " + chunk
          );
#ifndef ARGS_NOEXCEPT
          throw ParseError(errorMessage);
#else
          error = Error::Parse;
          errorMsg = errorMessage;
          return it;
#endif
        }
      }

      if (!readCompletion && completion != nullptr && completion->Matched()) {
#ifdef ARGS_NOEXCEPT
        error = Error::Completion;
#endif
        readCompletion = true;
        ++it;
        const auto argsLeft = static_cast<size_t>(std::distance(it, end));
        if (completion->cword == 0 || argsLeft <= 1 || completion->cword >= argsLeft) {
#ifndef ARGS_NOEXCEPT
          throw Completion("");
#endif
        }

        std::vector<std::string> curArgs(++it, end);
        curArgs.resize(completion->cword);

        if (completion->syntax == "bash") {
          // bash tokenizes --flag=value as --flag=value
          for (size_t idx = 0; idx < curArgs.size();) {
            if (idx > 0 && curArgs[idx] == "=") {
              curArgs[idx - 1] += "=";
              // Avoid warnings from -Wsign-conversion
              const auto signedIdx = static_cast<std::ptrdiff_t>(idx);
              if (idx + 1 < curArgs.size()) {
                curArgs[idx - 1] += curArgs[idx + 1];
                curArgs.erase(curArgs.begin() + signedIdx, curArgs.begin() + signedIdx + 2);
              } else {
                curArgs.erase(curArgs.begin() + signedIdx);
              }
            } else {
              ++idx;
            }
          }
        }
#ifndef ARGS_NOEXCEPT
        try {
          Parse(curArgs.begin(), curArgs.end());
          throw Completion("");
        } catch (Completion&) {
          throw;
        } catch (args::Error&) {
          throw Completion("");
        }
#else
        return Parse(curArgs.begin(), curArgs.end());
#endif
      }
    }

    Validate(shortprefix, longprefix);
    return end;
  }

public:
  HelpParams helpParams;

  ArgumentParser(const std::string& description_, const std::string& epilog_ = std::string()) {
    Description(description_);
    Epilog(epilog_);
    LongPrefix("--");
    ShortPrefix("-");
    LongSeparator("=");
    Terminator("--");
    SetArgumentSeparations(true, true, true, true);
    matched = true;
  }

  void AddCompletion(CompletionFlag& completionFlag) {
    completion = &completionFlag;
    Add(completionFlag);
  }

  /** The program name for help generation
   */
  const std::string& Prog() const { return helpParams.programName; }
  /** The program name for help generation
   */
  void Prog(const std::string& prog_) { this->helpParams.programName = prog_; }

  /** The prefix for long flags
   */
  const std::string& LongPrefix() const { return longprefix; }
  /** The prefix for long flags
   */
  void LongPrefix(const std::string& longprefix_) {
    this->longprefix = longprefix_;
    this->helpParams.longPrefix = longprefix_;
  }

  /** The prefix for short flags
   */
  const std::string& ShortPrefix() const { return shortprefix; }
  /** The prefix for short flags
   */
  void ShortPrefix(const std::string& shortprefix_) {
    this->shortprefix = shortprefix_;
    this->helpParams.shortPrefix = shortprefix_;
  }

  /** The separator for long flags
   */
  const std::string& LongSeparator() const { return longseparator; }
  /** The separator for long flags
   */
  void LongSeparator(const std::string& longseparator_) {
    if (longseparator_.empty()) {
      const std::string errorMessage("longseparator can not be set to empty");
#ifdef ARGS_NOEXCEPT
      error = Error::Usage;
      errorMsg = errorMessage;
#else
      throw UsageError(errorMessage);
#endif
    } else {
      this->longseparator = longseparator_;
      this->helpParams.longSeparator = allowJoinedLongValue ? longseparator_ : " ";
    }
  }

  /** The terminator that forcibly separates flags from positionals
   */
  const std::string& Terminator() const { return terminator; }
  /** The terminator that forcibly separates flags from positionals
   */
  void Terminator(const std::string& terminator_) { this->terminator = terminator_; }

  /** Get the current argument separation parameters.
   *
   * See SetArgumentSeparations for details on what each one means.
   */
  void GetArgumentSeparations(
      bool& allowJoinedShortValue_, bool& allowJoinedLongValue_, bool& allowSeparateShortValue_,
      bool& allowSeparateLongValue_
  ) const {
    allowJoinedShortValue_ = this->allowJoinedShortValue;
    allowJoinedLongValue_ = this->allowJoinedLongValue;
    allowSeparateShortValue_ = this->allowSeparateShortValue;
    allowSeparateLongValue_ = this->allowSeparateLongValue;
  }

  /** Change allowed option separation.
   *
   * \param allowJoinedShortValue_ Allow a short flag that accepts an argument to be passed its argument immediately
   * next to it (ie. in the same argv field)
   * \param allowJoinedLongValue_ Allow a long flag that accepts an argument to be passed its argument separated by the
   * longseparator (ie. in the same argv field)
   * \param allowSeparateShortValue_ Allow a short flag that accepts an argument to be passed its argument separated by
   * whitespace (ie. in the next argv field)
   * \param allowSeparateLongValue_ Allow a long flag that accepts an argument to be passed its argument separated by
   * whitespace (ie. in the next argv field)
   */
  void SetArgumentSeparations(
      const bool allowJoinedShortValue_, const bool allowJoinedLongValue_, const bool allowSeparateShortValue_,
      const bool allowSeparateLongValue_
  ) {
    this->allowJoinedShortValue = allowJoinedShortValue_;
    this->allowJoinedLongValue = allowJoinedLongValue_;
    this->allowSeparateShortValue = allowSeparateShortValue_;
    this->allowSeparateLongValue = allowSeparateLongValue_;

    this->helpParams.longSeparator = allowJoinedLongValue ? longseparator : " ";
    this->helpParams.shortSeparator = allowJoinedShortValue ? "" : " ";
  }

  /** Pass the help menu into an ostream
   */
  void Help(std::ostream& help_) const {
    auto& command = SelectedCommand();
    const auto& commandDescription = command.Description().empty() ? command.Help() : command.Description();
    const auto description_text = Wrap(commandDescription, helpParams.width - helpParams.descriptionindent);
    const auto epilog_text = Wrap(command.Epilog(), helpParams.width - helpParams.descriptionindent);

    const bool hasoptions = command.HasFlag();
    const bool hasarguments = command.HasPositional();

    std::vector<std::string> prognameline;
    prognameline.push_back(helpParams.usageString);
    prognameline.push_back(Prog());
    auto commandProgLine = command.GetProgramLine(helpParams);
    prognameline.insert(prognameline.end(), commandProgLine.begin(), commandProgLine.end());

    const auto proglines = Wrap(
        prognameline.begin(), prognameline.end(),
        helpParams.width - (helpParams.progindent + helpParams.progtailindent), helpParams.width - helpParams.progindent
    );
    auto progit = std::begin(proglines);
    if (progit != std::end(proglines)) {
      help_ << std::string(helpParams.progindent, ' ') << *progit << '\n';
      ++progit;
    }
    for (; progit != std::end(proglines); ++progit) {
      help_ << std::string(helpParams.progtailindent, ' ') << *progit << '\n';
    }

    help_ << '\n';

    if (!description_text.empty()) {
      for (const auto& line : description_text) {
        help_ << std::string(helpParams.descriptionindent, ' ') << line << "\n";
      }
      help_ << "\n";
    }

    bool lastDescriptionIsNewline = false;

    if (!helpParams.optionsString.empty()) {
      help_ << std::string(helpParams.progindent, ' ') << helpParams.optionsString << "\n\n";
    }

    for (const auto& desc : command.GetDescription(helpParams, 0)) {
      lastDescriptionIsNewline = std::get<0>(desc).empty() && std::get<1>(desc).empty();
      const auto groupindent = std::get<2>(desc) * helpParams.eachgroupindent;
      const auto flags = Wrap(
          std::get<0>(desc), helpParams.width - (helpParams.flagindent + helpParams.helpindent + helpParams.gutter)
      );
      const auto info = Wrap(std::get<1>(desc), helpParams.width - (helpParams.helpindent + groupindent));

      std::string::size_type flagssize = 0;
      for (auto flagsit = std::begin(flags); flagsit != std::end(flags); ++flagsit) {
        if (flagsit != std::begin(flags)) {
          help_ << '\n';
        }
        help_ << std::string(groupindent + helpParams.flagindent, ' ') << *flagsit;
        flagssize = Glyphs(*flagsit);
      }

      auto infoit = std::begin(info);
      // groupindent is on both sides of this inequality, and therefore can be removed
      if ((helpParams.flagindent + flagssize + helpParams.gutter) > helpParams.helpindent || infoit == std::end(info) ||
          helpParams.addNewlineBeforeDescription) {
        help_ << '\n';
      } else {
        // groupindent is on both sides of the minus sign, and therefore doesn't actually need to be in here
        help_ << std::string(helpParams.helpindent - (helpParams.flagindent + flagssize), ' ') << *infoit << '\n';
        ++infoit;
      }
      for (; infoit != std::end(info); ++infoit) {
        help_ << std::string(groupindent + helpParams.helpindent, ' ') << *infoit << '\n';
      }
    }
    if (hasoptions && hasarguments && helpParams.showTerminator) {
      lastDescriptionIsNewline = false;
      for (const auto& item : Wrap(
               std::string("\"") + terminator +
                   "\" can be used to terminate flag options and force all following arguments to be treated as "
                   "positional options",
               helpParams.width - helpParams.flagindent
           )) {
        help_ << std::string(helpParams.flagindent, ' ') << item << '\n';
      }
    }

    if (!lastDescriptionIsNewline) {
      help_ << "\n";
    }

    for (const auto& line : epilog_text) {
      help_ << std::string(helpParams.descriptionindent, ' ') << line << "\n";
    }
  }

  /** Generate a help menu as a string.
   *
   * \return the help text as a single string
   */
  std::string Help() const {
    std::ostringstream help_;
    Help(help_);
    return help_.str();
  }

  virtual void Reset() noexcept override {
    Command::Reset();
    matched = true;
    readCompletion = false;
  }

  /** Parse all arguments.
   *
   * \param begin an iterator to the beginning of the argument list
   * \param end an iterator to the past-the-end element of the argument list
   * \return the iterator after the last parsed value.  Only useful for kick-out
   */
  template <typename It> It ParseArgs(It begin, It end) {
    // Reset all Matched statuses and errors
    Reset();
#ifdef ARGS_NOEXCEPT
    error = GetError();
    if (error != Error::None) {
      return end;
    }
#endif
    return Parse(begin, end);
  }

  /** Parse all arguments.
   *
   * \param args an iterable of the arguments
   * \return the iterator after the last parsed value.  Only useful for kick-out
   */
  template <typename T> auto ParseArgs(const T& args) -> decltype(std::begin(args)) {
    return ParseArgs(std::begin(args), std::end(args));
  }

  /** Convenience function to parse the CLI from argc and argv
   *
   * Just assigns the program name and vectorizes arguments for passing into ParseArgs()
   *
   * \return whether or not all arguments were parsed.  This works for detecting kick-out, but is generally useless as
   * it can't do anything with it.
   */
  bool ParseCLI(const int argc, const char* const* argv) {
    if (Prog().empty()) {
      Prog(argv[0]);
    }
    const std::vector<std::string> args(argv + 1, argv + argc);
    return ParseArgs(args) == std::end(args);
  }

  template <typename T> bool ParseCLI(const T& args) { return ParseArgs(args) == std::end(args); }
};

inline Command::RaiiSubparser::RaiiSubparser(ArgumentParser& parser_, std::vector<std::string> args_)
    : command(parser_.SelectedCommand()), parser(std::move(args_), parser_, command, parser_.helpParams),
      oldSubparser(command.subparser) {
  command.subparser = &parser;
}

inline Command::RaiiSubparser::RaiiSubparser(const Command& command_, const HelpParams& params_)
    : command(command_), parser(command, params_), oldSubparser(command.subparser) {
  command.subparser = &parser;
}

inline void Subparser::Parse() {
  isParsed = true;
  Reset();
  command.subparserDescription = GetDescription(helpParams, 0);
  command.subparserHasFlag = HasFlag();
  command.subparserHasPositional = HasPositional();
  command.subparserHasCommand = HasCommand();
  command.subparserProgramLine = GetProgramLine(helpParams);
  if (parser == nullptr) {
#ifndef ARGS_NOEXCEPT
    throw args::SubparserError();
#else
    error = Error::Subparser;
    return;
#endif
  }

  auto it = parser->Parse(args.begin(), args.end());
  command.Validate(parser->ShortPrefix(), parser->LongPrefix());
  kicked.assign(it, args.end());

#ifdef ARGS_NOEXCEPT
  command.subparserError = GetError();
#endif
}

inline std::ostream& operator<<(std::ostream& os, const ArgumentParser& parser) {
  parser.Help(os);
  return os;
}

/** Boolean argument matcher
 */
class Flag : public FlagBase {
public:
  Flag(Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, Options options_)
      : FlagBase(name_, help_, std::move(matcher_), options_) {
    group_.Add(*this);
  }

  Flag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_,
      const bool extraError_ = false
  )
      : Flag(group_, name_, help_, std::move(matcher_), extraError_ ? Options::Single : Options::None) {}

  virtual ~Flag() {}

  /** Get whether this was matched
   */
  bool Get() const { return Matched(); }

  virtual Nargs NumberOfArguments() const noexcept override { return 0; }

  virtual void ParseValue(const std::vector<std::string>&) override {}
};

/** Help flag class
 *
 * Works like a regular flag, but throws an instance of Help when it is matched
 */
class HelpFlag : public Flag {
public:
  HelpFlag(Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, Options options_ = {})
      : Flag(group_, name_, help_, std::move(matcher_), options_) {}

  virtual ~HelpFlag() {}

  virtual void ParseValue(const std::vector<std::string>&) {
#ifdef ARGS_NOEXCEPT
    error = Error::Help;
    errorMsg = Name();
#else
    throw Help(Name());
#endif
  }

  /** Get whether this was matched
   */
  bool Get() const noexcept { return Matched(); }
};

/** A flag class that simply counts the number of times it's matched
 */
class CounterFlag : public Flag {
private:
  const int startcount;
  int count;

public:
  CounterFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, const int startcount_ = 0,
      Options options_ = {}
  )
      : Flag(group_, name_, help_, std::move(matcher_), options_), startcount(startcount_), count(startcount_) {}

  virtual ~CounterFlag() {}

  virtual FlagBase* Match(const EitherFlag& arg) override {
    auto me = FlagBase::Match(arg);
    if (me) {
      ++count;
    }
    return me;
  }

  /** Get the count
   */
  int& Get() noexcept { return count; }

  int& operator*() noexcept { return count; }

  const int& operator*() const noexcept { return count; }

  virtual void Reset() noexcept override {
    FlagBase::Reset();
    count = startcount;
  }
};

/** A flag class that calls a function when it's matched
 */
class ActionFlag : public FlagBase {
private:
  std::function<void(const std::vector<std::string>&)> action;
  Nargs nargs;

public:
  ActionFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, Nargs nargs_,
      std::function<void(const std::vector<std::string>&)> action_, Options options_ = {}
  )
      : FlagBase(name_, help_, std::move(matcher_), options_), action(std::move(action_)), nargs(nargs_) {
    group_.Add(*this);
  }

  ActionFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_,
      std::function<void(const std::string&)> action_, Options options_ = {}
  )
      : FlagBase(name_, help_, std::move(matcher_), options_), nargs(1) {
    group_.Add(*this);
    action = [action_](const std::vector<std::string>& a) { return action_(a.at(0)); };
  }

  ActionFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_,
      std::function<void()> action_, Options options_ = {}
  )
      : FlagBase(name_, help_, std::move(matcher_), options_), nargs(0) {
    group_.Add(*this);
    action = [action_](const std::vector<std::string>&) { return action_(); };
  }

  virtual Nargs NumberOfArguments() const noexcept override { return nargs; }

  virtual void ParseValue(const std::vector<std::string>& value) override { action(value); }
};

/** A default Reader class for argument classes
 *
 * If destination type is assignable to std::string it uses an assignment to std::string.
 * Otherwise ValueReader simply uses a std::istringstream to read into the destination type, and
 * raises a ParseError if there are any characters left.
 */
struct ValueReader {
  template <typename T>
  typename std::enable_if<!std::is_assignable<T, std::string>::value, bool>::type operator()(
      const std::string& name, const std::string& value, T& destination
  ) {
    std::istringstream ss(value);
    bool failed = !(ss >> destination);

    if (!failed) {
      ss >> std::ws;
    }

    if (ss.rdbuf()->in_avail() > 0 || failed) {
#ifdef ARGS_NOEXCEPT
      (void) name;
      return false;
#else
      std::ostringstream problem;
      problem << "Argument '" << name << "' received invalid value type '" << value << "'";
      throw ParseError(problem.str());
#endif
    }
    return true;
  }

  template <typename T>
  typename std::enable_if<std::is_assignable<T, std::string>::value, bool>::type operator()(
      const std::string&, const std::string& value, T& destination
  ) {
    destination = value;
    return true;
  }
};

/** An argument-accepting flag class
 *
 * \tparam T the type to extract the argument as
 * \tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with
 * operator(), and returning a bool (if ARGS_NOEXCEPT is defined)
 */
template <typename T, typename Reader = ValueReader> class ValueFlag : public ValueFlagBase {
protected:
  T value;
  T defaultValue;

  virtual std::string GetDefaultString(const HelpParams&) const override { return detail::ToString(defaultValue); }

private:
  Reader reader;

public:
  ValueFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, const T& defaultValue_,
      Options options_
  )
      : ValueFlagBase(name_, help_, std::move(matcher_), options_), value(defaultValue_), defaultValue(defaultValue_) {
    group_.Add(*this);
  }

  ValueFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_,
      const T& defaultValue_ = T(), const bool extraError_ = false
  )
      : ValueFlag(
            group_, name_, help_, std::move(matcher_), defaultValue_, extraError_ ? Options::Single : Options::None
        ) {}

  ValueFlag(Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, Options options_)
      : ValueFlag(group_, name_, help_, std::move(matcher_), T(), options_) {}

  virtual ~ValueFlag() {}

  virtual void ParseValue(const std::vector<std::string>& values_) override {
    const std::string& value_ = values_.at(0);

#ifdef ARGS_NOEXCEPT
    if (!reader(name, value_, this->value)) {
      error = Error::Parse;
    }
#else
    reader(name, value_, this->value);
#endif
  }

  virtual void Reset() noexcept override {
    ValueFlagBase::Reset();
    value = defaultValue;
  }

  /** Get the value
   */
  T& Get() noexcept { return value; }

  /** Get the value
   */
  T& operator*() noexcept { return value; }

  /** Get the value
   */
  const T& operator*() const noexcept { return value; }

  /** Get the value
   */
  T* operator->() noexcept { return &value; }

  /** Get the value
   */
  const T* operator->() const noexcept { return &value; }

  /** Get the default value
   */
  const T& GetDefault() noexcept { return defaultValue; }
};

/** An optional argument-accepting flag class
 *
 * \tparam T the type to extract the argument as
 * \tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with
 * operator(), and returning a bool (if ARGS_NOEXCEPT is defined)
 */
template <typename T, typename Reader = ValueReader> class ImplicitValueFlag : public ValueFlag<T, Reader> {
protected:
  T implicitValue;

public:
  ImplicitValueFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, const T& implicitValue_,
      const T& defaultValue_ = T(), Options options_ = {}
  )
      : ValueFlag<T, Reader>(group_, name_, help_, std::move(matcher_), defaultValue_, options_),
        implicitValue(implicitValue_) {}

  ImplicitValueFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_,
      const T& defaultValue_ = T(), Options options_ = {}
  )
      : ValueFlag<T, Reader>(group_, name_, help_, std::move(matcher_), defaultValue_, options_),
        implicitValue(defaultValue_) {}

  ImplicitValueFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, Options options_
  )
      : ValueFlag<T, Reader>(group_, name_, help_, std::move(matcher_), {}, options_), implicitValue() {}

  virtual ~ImplicitValueFlag() {}

  virtual Nargs NumberOfArguments() const noexcept override { return {0, 1}; }

  virtual void ParseValue(const std::vector<std::string>& value_) override {
    if (value_.empty()) {
      this->value = implicitValue;
    } else {
      ValueFlag<T, Reader>::ParseValue(value_);
    }
  }
};

/** A variadic arguments accepting flag class
 *
 * \tparam T the type to extract the argument as
 * \tparam List the list type that houses the values
 * \tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with
 * operator(), and returning a bool (if ARGS_NOEXCEPT is defined)
 */
template <typename T, template <typename...> class List = detail::vector, typename Reader = ValueReader>
class NargsValueFlag : public FlagBase {
protected:
  List<T> values;
  const List<T> defaultValues;
  Nargs nargs;
  Reader reader;

public:
  typedef List<T> Container;
  typedef T value_type;
  typedef typename Container::allocator_type allocator_type;
  typedef typename Container::pointer pointer;
  typedef typename Container::const_pointer const_pointer;
  typedef T& reference;
  typedef const T& const_reference;
  typedef typename Container::size_type size_type;
  typedef typename Container::difference_type difference_type;
  typedef typename Container::iterator iterator;
  typedef typename Container::const_iterator const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

  NargsValueFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, Nargs nargs_,
      const List<T>& defaultValues_ = {}, Options options_ = {}
  )
      : FlagBase(name_, help_, std::move(matcher_), options_), values(defaultValues_), defaultValues(defaultValues_),
        nargs(nargs_) {
    group_.Add(*this);
  }

  virtual ~NargsValueFlag() {}

  virtual Nargs NumberOfArguments() const noexcept override { return nargs; }

  virtual void ParseValue(const std::vector<std::string>& values_) override {
    values.clear();

    for (const std::string& value : values_) {
      T v;
#ifdef ARGS_NOEXCEPT
      if (!reader(name, value, v)) {
        error = Error::Parse;
      }
#else
      reader(name, value, v);
#endif
      values.insert(std::end(values), v);
    }
  }

  List<T>& Get() noexcept { return values; }

  /** Get the value
   */
  List<T>& operator*() noexcept { return values; }

  /** Get the values
   */
  const List<T>& operator*() const noexcept { return values; }

  /** Get the values
   */
  List<T>* operator->() noexcept { return &values; }

  /** Get the values
   */
  const List<T>* operator->() const noexcept { return &values; }

  iterator begin() noexcept { return values.begin(); }

  const_iterator begin() const noexcept { return values.begin(); }

  const_iterator cbegin() const noexcept { return values.cbegin(); }

  iterator end() noexcept { return values.end(); }

  const_iterator end() const noexcept { return values.end(); }

  const_iterator cend() const noexcept { return values.cend(); }

  virtual void Reset() noexcept override {
    FlagBase::Reset();
    values = defaultValues;
  }

  virtual FlagBase* Match(const EitherFlag& arg) override {
    const bool wasMatched = Matched();
    auto me = FlagBase::Match(arg);
    if (me && !wasMatched) {
      values.clear();
    }
    return me;
  }
};

/** An argument-accepting flag class that pushes the found values into a list
 *
 * \tparam T the type to extract the argument as
 * \tparam List the list type that houses the values
 * \tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with
 * operator(), and returning a bool (if ARGS_NOEXCEPT is defined)
 */
template <typename T, template <typename...> class List = detail::vector, typename Reader = ValueReader>
class ValueFlagList : public ValueFlagBase {
private:
  using Container = List<T>;
  Container values;
  const Container defaultValues;
  Reader reader;

public:
  typedef T value_type;
  typedef typename Container::allocator_type allocator_type;
  typedef typename Container::pointer pointer;
  typedef typename Container::const_pointer const_pointer;
  typedef T& reference;
  typedef const T& const_reference;
  typedef typename Container::size_type size_type;
  typedef typename Container::difference_type difference_type;
  typedef typename Container::iterator iterator;
  typedef typename Container::const_iterator const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

  ValueFlagList(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_,
      const Container& defaultValues_ = Container(), Options options_ = {}
  )
      : ValueFlagBase(name_, help_, std::move(matcher_), options_), values(defaultValues_),
        defaultValues(defaultValues_) {
    group_.Add(*this);
  }

  virtual ~ValueFlagList() {}

  virtual void ParseValue(const std::vector<std::string>& values_) override {
    const std::string& value_ = values_.at(0);

    T v;
#ifdef ARGS_NOEXCEPT
    if (!reader(name, value_, v)) {
      error = Error::Parse;
    }
#else
    reader(name, value_, v);
#endif
    values.insert(std::end(values), v);
  }

  /** Get the values
   */
  Container& Get() noexcept { return values; }

  /** Get the value
   */
  Container& operator*() noexcept { return values; }

  /** Get the values
   */
  const Container& operator*() const noexcept { return values; }

  /** Get the values
   */
  Container* operator->() noexcept { return &values; }

  /** Get the values
   */
  const Container* operator->() const noexcept { return &values; }

  virtual std::string Name() const override { return name + std::string("..."); }

  virtual void Reset() noexcept override {
    ValueFlagBase::Reset();
    values = defaultValues;
  }

  virtual FlagBase* Match(const EitherFlag& arg) override {
    const bool wasMatched = Matched();
    auto me = FlagBase::Match(arg);
    if (me && !wasMatched) {
      values.clear();
    }
    return me;
  }

  iterator begin() noexcept { return values.begin(); }

  const_iterator begin() const noexcept { return values.begin(); }

  const_iterator cbegin() const noexcept { return values.cbegin(); }

  iterator end() noexcept { return values.end(); }

  const_iterator end() const noexcept { return values.end(); }

  const_iterator cend() const noexcept { return values.cend(); }
};

/** A mapping value flag class
 *
 * \tparam K the type to extract the argument as
 * \tparam T the type to store the result as
 * \tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with
 * operator(), and returning a bool (if ARGS_NOEXCEPT is defined)
 * \tparam Map The Map type.  Should operate like std::map or std::unordered_map
 */
template <
    typename K, typename T, typename Reader = ValueReader, template <typename...> class Map = detail::unordered_map>
class MapFlag : public ValueFlagBase {
private:
  const Map<K, T> map;
  T value;
  const T defaultValue;
  Reader reader;

protected:
  virtual std::vector<std::string> GetChoicesStrings(const HelpParams&) const override {
    return detail::MapKeysToStrings(map);
  }

public:
  MapFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, const Map<K, T>& map_,
      const T& defaultValue_, Options options_
  )
      : ValueFlagBase(name_, help_, std::move(matcher_), options_), map(map_), value(defaultValue_),
        defaultValue(defaultValue_) {
    group_.Add(*this);
  }

  MapFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, const Map<K, T>& map_,
      const T& defaultValue_ = T(), const bool extraError_ = false
  )
      : MapFlag(
            group_, name_, help_, std::move(matcher_), map_, defaultValue_,
            extraError_ ? Options::Single : Options::None
        ) {}

  MapFlag(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, const Map<K, T>& map_,
      Options options_
  )
      : MapFlag(group_, name_, help_, std::move(matcher_), map_, T(), options_) {}

  virtual ~MapFlag() {}

  virtual void ParseValue(const std::vector<std::string>& values_) override {
    const std::string& value_ = values_.at(0);

    K key;
#ifdef ARGS_NOEXCEPT
    if (!reader(name, value_, key)) {
      error = Error::Parse;
    }
#else
    reader(name, value_, key);
#endif
    auto it = map.find(key);
    if (it == std::end(map)) {
      std::ostringstream problem;
      problem << "Could not find key '" << key << "' in map for arg '" << name << "'";
#ifdef ARGS_NOEXCEPT
      error = Error::Map;
      errorMsg = problem.str();
#else
      throw MapError(problem.str());
#endif
    } else {
      this->value = it->second;
    }
  }

  /** Get the value
   */
  T& Get() noexcept { return value; }

  /** Get the value
   */
  T& operator*() noexcept { return value; }

  /** Get the value
   */
  const T& operator*() const noexcept { return value; }

  /** Get the value
   */
  T* operator->() noexcept { return &value; }

  /** Get the value
   */
  const T* operator->() const noexcept { return &value; }

  virtual void Reset() noexcept override {
    ValueFlagBase::Reset();
    value = defaultValue;
  }
};

/** A mapping value flag list class
 *
 * \tparam K the type to extract the argument as
 * \tparam T the type to store the result as
 * \tparam List the list type that houses the values
 * \tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with
 * operator(), and returning a bool (if ARGS_NOEXCEPT is defined)
 * \tparam Map The Map type.  Should operate like std::map or std::unordered_map
 */
template <
    typename K, typename T, template <typename...> class List = detail::vector, typename Reader = ValueReader,
    template <typename...> class Map = detail::unordered_map>
class MapFlagList : public ValueFlagBase {
private:
  using Container = List<T>;
  const Map<K, T> map;
  Container values;
  const Container defaultValues;
  Reader reader;

protected:
  virtual std::vector<std::string> GetChoicesStrings(const HelpParams&) const override {
    return detail::MapKeysToStrings(map);
  }

public:
  typedef T value_type;
  typedef typename Container::allocator_type allocator_type;
  typedef typename Container::pointer pointer;
  typedef typename Container::const_pointer const_pointer;
  typedef T& reference;
  typedef const T& const_reference;
  typedef typename Container::size_type size_type;
  typedef typename Container::difference_type difference_type;
  typedef typename Container::iterator iterator;
  typedef typename Container::const_iterator const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

  MapFlagList(
      Group& group_, const std::string& name_, const std::string& help_, Matcher&& matcher_, const Map<K, T>& map_,
      const Container& defaultValues_ = Container()
  )
      : ValueFlagBase(name_, help_, std::move(matcher_)), map(map_), values(defaultValues_),
        defaultValues(defaultValues_) {
    group_.Add(*this);
  }

  virtual ~MapFlagList() {}

  virtual void ParseValue(const std::vector<std::string>& values_) override {
    const std::string& value = values_.at(0);

    K key;
#ifdef ARGS_NOEXCEPT
    if (!reader(name, value, key)) {
      error = Error::Parse;
    }
#else
    reader(name, value, key);
#endif
    auto it = map.find(key);
    if (it == std::end(map)) {
      std::ostringstream problem;
      problem << "Could not find key '" << key << "' in map for arg '" << name << "'";
#ifdef ARGS_NOEXCEPT
      error = Error::Map;
      errorMsg = problem.str();
#else
      throw MapError(problem.str());
#endif
    } else {
      this->values.emplace_back(it->second);
    }
  }

  /** Get the value
   */
  Container& Get() noexcept { return values; }

  /** Get the value
   */
  Container& operator*() noexcept { return values; }

  /** Get the values
   */
  const Container& operator*() const noexcept { return values; }

  /** Get the values
   */
  Container* operator->() noexcept { return &values; }

  /** Get the values
   */
  const Container* operator->() const noexcept { return &values; }

  virtual std::string Name() const override { return name + std::string("..."); }

  virtual void Reset() noexcept override {
    ValueFlagBase::Reset();
    values = defaultValues;
  }

  virtual FlagBase* Match(const EitherFlag& arg) override {
    const bool wasMatched = Matched();
    auto me = FlagBase::Match(arg);
    if (me && !wasMatched) {
      values.clear();
    }
    return me;
  }

  iterator begin() noexcept { return values.begin(); }

  const_iterator begin() const noexcept { return values.begin(); }

  const_iterator cbegin() const noexcept { return values.cbegin(); }

  iterator end() noexcept { return values.end(); }

  const_iterator end() const noexcept { return values.end(); }

  const_iterator cend() const noexcept { return values.cend(); }
};

/** A positional argument class
 *
 * \tparam T the type to extract the argument as
 * \tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with
 * operator(), and returning a bool (if ARGS_NOEXCEPT is defined)
 */
template <typename T, typename Reader = ValueReader> class Positional : public PositionalBase {
private:
  T value;
  const T defaultValue;
  Reader reader;

public:
  Positional(
      Group& group_, const std::string& name_, const std::string& help_, const T& defaultValue_ = T(),
      Options options_ = {}
  )
      : PositionalBase(name_, help_, options_), value(defaultValue_), defaultValue(defaultValue_) {
    group_.Add(*this);
  }

  Positional(Group& group_, const std::string& name_, const std::string& help_, Options options_)
      : Positional(group_, name_, help_, T(), options_) {}

  virtual ~Positional() {}

  virtual void ParseValue(const std::string& value_) override {
#ifdef ARGS_NOEXCEPT
    if (!reader(name, value_, this->value)) {
      error = Error::Parse;
    }
#else
    reader(name, value_, this->value);
#endif
    ready = false;
    matched = true;
  }

  /** Get the value
   */
  T& Get() noexcept { return value; }

  /** Get the value
   */
  T& operator*() noexcept { return value; }

  /** Get the value
   */
  const T& operator*() const noexcept { return value; }

  /** Get the value
   */
  T* operator->() noexcept { return &value; }

  /** Get the value
   */
  const T* operator->() const noexcept { return &value; }

  virtual void Reset() noexcept override {
    PositionalBase::Reset();
    value = defaultValue;
  }
};

/** A positional argument class that pushes the found values into a list
 *
 * \tparam T the type to extract the argument as
 * \tparam List the list type that houses the values
 * \tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with
 * operator(), and returning a bool (if ARGS_NOEXCEPT is defined)
 */
template <typename T, template <typename...> class List = detail::vector, typename Reader = ValueReader>
class PositionalList : public PositionalBase {
private:
  using Container = List<T>;
  Container values;
  const Container defaultValues;
  Reader reader;

public:
  typedef T value_type;
  typedef typename Container::allocator_type allocator_type;
  typedef typename Container::pointer pointer;
  typedef typename Container::const_pointer const_pointer;
  typedef T& reference;
  typedef const T& const_reference;
  typedef typename Container::size_type size_type;
  typedef typename Container::difference_type difference_type;
  typedef typename Container::iterator iterator;
  typedef typename Container::const_iterator const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

  PositionalList(
      Group& group_, const std::string& name_, const std::string& help_, const Container& defaultValues_ = Container(),
      Options options_ = {}
  )
      : PositionalBase(name_, help_, options_), values(defaultValues_), defaultValues(defaultValues_) {
    group_.Add(*this);
  }

  PositionalList(Group& group_, const std::string& name_, const std::string& help_, Options options_)
      : PositionalList(group_, name_, help_, {}, options_) {}

  virtual ~PositionalList() {}

  virtual void ParseValue(const std::string& value_) override {
    T v;
#ifdef ARGS_NOEXCEPT
    if (!reader(name, value_, v)) {
      error = Error::Parse;
    }
#else
    reader(name, value_, v);
#endif
    values.insert(std::end(values), v);
    matched = true;
  }

  virtual std::string Name() const override { return name + std::string("..."); }

  /** Get the values
   */
  Container& Get() noexcept { return values; }

  /** Get the value
   */
  Container& operator*() noexcept { return values; }

  /** Get the values
   */
  const Container& operator*() const noexcept { return values; }

  /** Get the values
   */
  Container* operator->() noexcept { return &values; }

  /** Get the values
   */
  const Container* operator->() const noexcept { return &values; }

  virtual void Reset() noexcept override {
    PositionalBase::Reset();
    values = defaultValues;
  }

  virtual PositionalBase* GetNextPositional() override {
    const bool wasMatched = Matched();
    auto me = PositionalBase::GetNextPositional();
    if (me && !wasMatched) {
      values.clear();
    }
    return me;
  }

  iterator begin() noexcept { return values.begin(); }

  const_iterator begin() const noexcept { return values.begin(); }

  const_iterator cbegin() const noexcept { return values.cbegin(); }

  iterator end() noexcept { return values.end(); }

  const_iterator end() const noexcept { return values.end(); }

  const_iterator cend() const noexcept { return values.cend(); }
};

/** A positional argument mapping class
 *
 * \tparam K the type to extract the argument as
 * \tparam T the type to store the result as
 * \tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with
 * operator(), and returning a bool (if ARGS_NOEXCEPT is defined)
 * \tparam Map The Map type.  Should operate like std::map or std::unordered_map
 */
template <
    typename K, typename T, typename Reader = ValueReader, template <typename...> class Map = detail::unordered_map>
class MapPositional : public PositionalBase {
private:
  const Map<K, T> map;
  T value;
  const T defaultValue;
  Reader reader;

protected:
  virtual std::vector<std::string> GetChoicesStrings(const HelpParams&) const override {
    return detail::MapKeysToStrings(map);
  }

public:
  MapPositional(
      Group& group_, const std::string& name_, const std::string& help_, const Map<K, T>& map_,
      const T& defaultValue_ = T(), Options options_ = {}
  )
      : PositionalBase(name_, help_, options_), map(map_), value(defaultValue_), defaultValue(defaultValue_) {
    group_.Add(*this);
  }

  virtual ~MapPositional() {}

  virtual void ParseValue(const std::string& value_) override {
    K key;
#ifdef ARGS_NOEXCEPT
    if (!reader(name, value_, key)) {
      error = Error::Parse;
    }
#else
    reader(name, value_, key);
#endif
    auto it = map.find(key);
    if (it == std::end(map)) {
      std::ostringstream problem;
      problem << "Could not find key '" << key << "' in map for arg '" << name << "'";
#ifdef ARGS_NOEXCEPT
      error = Error::Map;
      errorMsg = problem.str();
#else
      throw MapError(problem.str());
#endif
    } else {
      this->value = it->second;
      ready = false;
      matched = true;
    }
  }

  /** Get the value
   */
  T& Get() noexcept { return value; }

  /** Get the value
   */
  T& operator*() noexcept { return value; }

  /** Get the value
   */
  const T& operator*() const noexcept { return value; }

  /** Get the value
   */
  T* operator->() noexcept { return &value; }

  /** Get the value
   */
  const T* operator->() const noexcept { return &value; }

  virtual void Reset() noexcept override {
    PositionalBase::Reset();
    value = defaultValue;
  }
};

/** A positional argument mapping list class
 *
 * \tparam K the type to extract the argument as
 * \tparam T the type to store the result as
 * \tparam List the list type that houses the values
 * \tparam Reader The functor type used to read the argument, taking the name, value, and destination reference with
 * operator(), and returning a bool (if ARGS_NOEXCEPT is defined)
 * \tparam Map The Map type.  Should operate like std::map or std::unordered_map
 */
template <
    typename K, typename T, template <typename...> class List = detail::vector, typename Reader = ValueReader,
    template <typename...> class Map = detail::unordered_map>
class MapPositionalList : public PositionalBase {
private:
  using Container = List<T>;

  const Map<K, T> map;
  Container values;
  const Container defaultValues;
  Reader reader;

protected:
  virtual std::vector<std::string> GetChoicesStrings(const HelpParams&) const override {
    return detail::MapKeysToStrings(map);
  }

public:
  typedef T value_type;
  typedef typename Container::allocator_type allocator_type;
  typedef typename Container::pointer pointer;
  typedef typename Container::const_pointer const_pointer;
  typedef T& reference;
  typedef const T& const_reference;
  typedef typename Container::size_type size_type;
  typedef typename Container::difference_type difference_type;
  typedef typename Container::iterator iterator;
  typedef typename Container::const_iterator const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

  MapPositionalList(
      Group& group_, const std::string& name_, const std::string& help_, const Map<K, T>& map_,
      const Container& defaultValues_ = Container(), Options options_ = {}
  )
      : PositionalBase(name_, help_, options_), map(map_), values(defaultValues_), defaultValues(defaultValues_) {
    group_.Add(*this);
  }

  virtual ~MapPositionalList() {}

  virtual void ParseValue(const std::string& value_) override {
    K key;
#ifdef ARGS_NOEXCEPT
    if (!reader(name, value_, key)) {
      error = Error::Parse;
    }
#else
    reader(name, value_, key);
#endif
    auto it = map.find(key);
    if (it == std::end(map)) {
      std::ostringstream problem;
      problem << "Could not find key '" << key << "' in map for arg '" << name << "'";
#ifdef ARGS_NOEXCEPT
      error = Error::Map;
      errorMsg = problem.str();
#else
      throw MapError(problem.str());
#endif
    } else {
      this->values.emplace_back(it->second);
      matched = true;
    }
  }

  /** Get the value
   */
  Container& Get() noexcept { return values; }

  /** Get the value
   */
  Container& operator*() noexcept { return values; }

  /** Get the values
   */
  const Container& operator*() const noexcept { return values; }

  /** Get the values
   */
  Container* operator->() noexcept { return &values; }

  /** Get the values
   */
  const Container* operator->() const noexcept { return &values; }

  virtual std::string Name() const override { return name + std::string("..."); }

  virtual void Reset() noexcept override {
    PositionalBase::Reset();
    values = defaultValues;
  }

  virtual PositionalBase* GetNextPositional() override {
    const bool wasMatched = Matched();
    auto me = PositionalBase::GetNextPositional();
    if (me && !wasMatched) {
      values.clear();
    }
    return me;
  }

  iterator begin() noexcept { return values.begin(); }

  const_iterator begin() const noexcept { return values.begin(); }

  const_iterator cbegin() const noexcept { return values.cbegin(); }

  iterator end() noexcept { return values.end(); }

  const_iterator end() const noexcept { return values.end(); }

  const_iterator cend() const noexcept { return values.cend(); }
};
}

#endif

```

`src/w1common/ext/jsonstruct.hpp`:

```hpp
/*
* Copyright © 2020 Jørgen Lind

* Permission to use, copy, modify, distribute, and sell this software and its
* documentation for any purpose is hereby granted without fee, provided that
* the above copyright notice appear in all copies and that both that copyright
* notice and this permission notice appear in supporting documentation, and
* that the name of the copyright holders not be used in advertising or
* publicity pertaining to distribution of the software without specific,
* written prior permission.  The copyright holders make no representations
* about the suitability of this software for any purpose.  It is provided "as
* is" without express or implied warranty.

* THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
* INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
* EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
* CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
* DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
* TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
* OF THIS SOFTWARE.
*/

/*
README:

json_struct is a single header only library that parses JSON to C++ structs/classes
and serializing structs/classes to JSON.

It is intended to be used by copying the json_struct.h file from the include
folder into the include path for the project. It is only the json_struct.h file
that is needed to serialize and deserialize json from structures.

It is dependent on some C++11 features and is tested on newer versions of gcc
and clang. It is also tested on VS 2015 and newer.

### Structs

json_struct can parse JSON and automatically populate structures with content
by adding some metadata to the C++ structs.

```json
{
    "One" : 1,
    "Two" : "two",
    "Three" : 3.333
}
```

can be parsed into a structure defined like this:

```c++
struct JsonObject
{
    int One;
    std::string Two;
    double Three;

    JS_OBJ(One, Two, Three);
};
```

or

```c++
struct JsonObject
{
    int One;
    std::string Two;
    double Three;
};
JS_OBJ_EXT(JsonObject, One, Two, Three);
```

Populating the struct would look like this:

```c++
JS::ParseContext context(json_data);
JsonObject obj;
context.parseTo(obj);
```

Serializing the struct to json could be done like this:

```c++
std::string pretty_json = JS::serializeStruct(obj);
// or
std::string compact_json = JS::serializeStruct(obj, JS::SerializerOptions(JS::SerializerOptions::Compact));

*/

/*! \file */

/*! \mainpage json_struct
 *
 * json_struct is a set of classes meant for simple and efficient parse,
 * tokenize and validate json.
 *
 * json_struct support parsing json into a stream of tokens using the \ref
 * tokenizer "JS::Tokenizer" api, or parsing json into c++ structures using the
 * \ref js_struct "JS_OBJECT" api.
 */

/*! \page tokenizer Parsing json using JS::Tokenizer
 *
 * Tokenizing json JS::Tokenizer can be used to extract tokens
 * from a json stream.  Tokens does not describe a full object, but only
 * key-value pairs. So a object would be: "some key" and object start. Then the
 * next token would be the first key value pair of that object. Then at some
 * point the object is finished, and an object end value with no key would be
 * the token.
 *
 * Arrays would be expressed in a similar fashion, but the tokens would have no
 * key, and each element in the array would be tokens with only a value
 * specified.
 *
 * The root object would be a token with no key data, but only object or array
 * start
 *
 * A crude example of this is viewed in \ref simple_tokenize.cpp here:
 * \include simple_tokenize.cpp
 *
 * Tokenizing json in this way allows you parse arbitrary large json data.
 * Also the tokenizer has mechanisms for asking for more data, making it easy
 * to stream json data. Using this interface to parse json is a bit verbose and
 * requires the application code to keep some extra state. json_struct also has
 * functionality for parsing json data directly into c++ structures. This is
 * done by adding some metadata to the structure, or by adding a template
 * specialisation of a class.  \ref js_struct "describes this" in more detail.
 */

/*! \example simple_tokenize.cpp
 *
 * This example show very basic usage of how JS::Tokenizer can be used
 */

/*! \example simple_struct.cpp
 *
 * This example shows basic usage of parsing Json directly into structs
 */

/*! \page js_struct Parsing json into C++ structs
 *
 * json_struct makes it very easy to put your json data into c++ structures or
 * take data from c++ structures and generate json.
 *
 * This is best shown with an example: \include simple_struct.cpp
 *
 * The two interesting sections here are the lines are the:
 * \code{.cpp}
 *    JS_OBJECT(JS_MEMBER(key),
 *              JS_MEMBER(number),
 *              JS_MEMBER(boolean));
 * \endcode
 *
 * and
 *
 * \code{.cpp}
 *    JS::ParseContext parseContext(json);
 *    JsonData dataStruct;
 *    parseContext.parseTo(dataStruct);
 * \endcode
 *
 * The JS_OBJECT call inside the JsonData struct will create a nested struct
 * declaration inside the JsonData struct. This nested struct will expose some
 * meta data about the struct, exposing the names of the members at runtime.
 * json_struct can then use this runtime information to populate the struct.
 *
 * Populating the struct is done by first creating a JS::ParseContext. The
 * JS::ParseContext contains a JS::Tokenizer. This tokenizer is what the actual
 * state holder for the parsing. If allowing using '\n' instead of ',' to
 * seperate object and array elements, then this should be set on the
 * JS::Tokenizer.
 *
 * Since types will dictate the schema of the input json, the JS::ParseContext
 * will expose a list containing what members where not populated by the input
 * json, and what member in the input json that did not have any member to
 * populate.
 */

#ifndef JSON_STRUCT_H
#define JSON_STRUCT_H

#include <algorithm>
#include <assert.h>
#include <atomic>
#include <cmath>
#include <cstring>
#include <functional>
#include <limits>
#include <memory>
#include <stddef.h>
#include <stdlib.h>
#include <string>
#include <vector>

#ifdef _MSC_VER
#include <intrin.h>
#endif

#if __cplusplus > 199711L || (defined(_MSC_VER) && _MSC_VER > 1800)
#define JS_STD_UNORDERED_MAP 1
#endif
#ifdef JS_STD_UNORDERED_MAP
#include <unordered_map>
#endif

#ifndef JS_STD_OPTIONAL
#if defined(__APPLE__)
#if __clang_major__ > 9 && __cplusplus >= 201703L
#define JS_STD_OPTIONAL 1
#endif
#elif defined(_MSC_VER) && _MSC_VER >= 1910 && _HAS_CXX17
#define JS_STD_OPTIONAL 1
#elif __cplusplus >= 201703L
#define JS_STD_OPTIONAL 1
#endif
#endif

#ifdef JS_STD_OPTIONAL
#include <optional>
#endif

#ifdef JS_STD_TIMEPOINT
#include <chrono>
#include <type_traits>
#endif

#ifndef JS_IF_CONSTEXPR
#if __cpp_if_constexpr
#define JS_IF_CONSTEXPR(exp) if constexpr (exp)
#elif defined(_MSC_VER)
#define JS_IF_CONSTEXPR(exp) __pragma(warning(push)) __pragma(warning(disable : 4127)) if (exp) __pragma(warning(pop))
#else
#define JS_IF_CONSTEXPR(exp) if (exp)
#endif
#endif

#if JS_NO_NODISCARD
#define JS_NODISCARD
#else
#if __cplusplus >= 201703L
#define JS_NODISCARD [[nodiscard]]
#else
#define JS_NODISCARD
#endif
#endif

#if defined(min) || defined(max)
#error min or max macro is defined. Make sure these are not defined before including json_struct.h.\
 Use "#define NOMINMAX 1" before including Windows.h
#endif

#define JS_UNUSED(x) (void) (x)

#ifndef JS
#define JS JS
#endif

namespace JS {
/*!
 *  \brief Pointer to data
 *
 *  DataRef is used to refere to some data inside a json string. It holds the
 *  start posisition of the data, and its size.
 */
struct DataRef {
  /*!
   * Constructs a null Dataref pointing to "" with size 0.
   */
  constexpr explicit DataRef() : data(""), size(0) {}

  /*!
   * Constructs a DataRef pointing to data and size.
   * \param data points to start of data.
   * \param size size of data.
   */
  constexpr explicit DataRef(const char* data, size_t size) : data(data), size(size) {}

  /*!  Cobstructs a DataRef pointing to an array. This will \b NOT look for
   * the null terminator, but just initialize the DataRef to the size of the
   * array - 1. This function is intended to be used with string literals.
   * \param data  start of the data.
   */
  template <size_t N> constexpr explicit DataRef(const char (&data)[N]) : data(data), size(N - 1) {}

  explicit DataRef(const std::string& str) : data(&str[0]), size(str.size()) {}

  explicit DataRef(const char* data) : data(data), size(strlen(data)) {}

  const char* data;
  size_t size;
};

enum class Type : unsigned char {
  Error,
  String,
  Ascii,
  Number,
  ObjectStart,
  ObjectEnd,
  ArrayStart,
  ArrayEnd,
  Bool,
  Null,
  Verbatim
};

struct Token {
  Token();

  DataRef name;
  DataRef value;
  Type name_type;
  Type value_type;
};

namespace Internal {
struct IntermediateToken {
  IntermediateToken() : active(false), name_type_set(false), data_type_set(false) {}

  void clear() {
    if (!active) {
      return;
    }
    active = false;
    name_type_set = false;
    data_type_set = false;
    name_type = Type::Error;
    data_type = Type::Error;
    name.clear();
    data.clear();
  }

  bool active : 1;
  bool name_type_set : 1;
  bool data_type_set : 1;
  Type name_type = Type::Error;
  Type data_type = Type::Error;
  std::string name;
  std::string data;
};
enum Lookup {
  StrEndOrBackSlash = 1,
  AsciiLetters = 2,
  WhiteSpaceOrNull = 4,
  PlusOrMinus = 8,
  Digits = 16,
  HatUnderscoreAprostoph = 32,
  NumberEnd = 64
};

static inline const unsigned char* lookup() {
  static const unsigned char tmp[] = {
      /*0*/ 4,        0,       0,       0,       0,       0,       0,       0,
      /*8*/ 0,        4,       4,       0,       0,       4,       0,       0,
      /*16*/ 0,       0,       0,       0,       0,       0,       0,       0,
      /*24*/ 0,       0,       0,       0,       0,       0,       0,       0,
      /*32*/ 4,       0,       1,       0,       0,       0,       0,       0,
      /*40*/ 0,       0,       0,       8 | 64,  0,       8 | 64,  64,      0,
      /*48*/ 16 | 64, 16 | 64, 16 | 64, 16 | 64, 16 | 64, 16 | 64, 16 | 64, 16 | 64,
      /*56*/ 16 | 64, 16 | 64, 0,       0,       0,       0,       0,       0,
      /*64*/ 0,       2,       2,       2,       2,       2 | 64,  2,       2,
      /*72*/ 2,       2,       2,       2,       2,       2,       2,       2,
      /*80*/ 2,       2,       2,       2,       2,       2,       2,       2,
      /*88*/ 2,       2,       2,       0,       1,       0,       32,      32,
      /*96*/ 32,      2,       2,       2,       2,       2 | 64,  2,       2,
      /*104*/ 2,      2,       2,       2,       2,       2,       2,       2,
      /*112*/ 2,      2,       2,       2,       2,       2,       2,       2,
      /*120*/ 2,      2,       2,       0,       0,       0,       0,       0,
      /*128*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*136*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*144*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*152*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*160*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*168*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*176*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*184*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*192*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*200*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*208*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*216*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*224*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*232*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*240*/ 0,      0,       0,       0,       0,       0,       0,       0,
      /*248*/ 0,      0,       0,       0,       0,       0,       0,       0
  };
  return tmp;
}
} // namespace Internal

enum class Error : unsigned char {
  NoError,
  NeedMoreData,
  InvalidToken,
  ExpectedPropertyName,
  ExpectedDelimiter,
  ExpectedDataToken,
  ExpectedObjectStart,
  ExpectedObjectEnd,
  ExpectedArrayStart,
  ExpectedArrayEnd,
  UnexpectedArrayEnd,
  UnexpectedObjectEnd,
  IllegalPropertyName,
  IllegalPropertyType,
  IllegalDataValue,
  EncounteredIllegalChar,
  NodeNotFound,
  MissingPropertyMember,
  MissingFunction,
  FailedToParseBoolean,
  FailedToParseDouble,
  FailedToParseFloat,
  FailedToParseInt,
  UnassignedRequiredMember,
  NonContigiousMemory,
  ScopeHasEnded,
  KeyNotFound,
  DuplicateInSet,
  UnknownError,
  UserDefinedErrors
};

namespace Internal {
class ErrorContext {
public:
  size_t line = 0;
  size_t character = 0;
  Error error = Error::NoError;
  std::string custom_message;
  std::vector<std::string> lines;

  void clear() {
    line = 0;
    character = 0;
    error = Error::NoError;
    lines.clear();
  }
};

} // namespace Internal

namespace Internal {
struct ScopeCounter {
  JS::Type type;
  uint16_t depth;
  inline void handleType(JS::Type in_type) {
    if (type == JS::Type::ArrayStart || type == JS::Type::ObjectStart) {
      if (in_type == type) {
        depth++;
      } else if (in_type == JS::Type(static_cast<int>(type) + 1)) {
        depth--;
      }
    } else {
      depth--;
    }
  }
};
} // namespace Internal

class Tokenizer {
public:
  Tokenizer();

  void allowAsciiType(bool allow);
  void allowNewLineAsTokenDelimiter(bool allow);
  void allowSuperfluousComma(bool allow);

  void addData(const char* data, size_t size);
  template <size_t N> void addData(const char (&data)[N]);
  void addData(const std::vector<Token>* parsedData);
  void resetData(const char* data, size_t size, size_t index);
  void resetData(const std::vector<Token>* parsedData, size_t index);
  size_t registeredBuffers() const;

  void setNeedMoreDataCallback(std::function<void(Tokenizer&)> callback);
  void setReleaseCallback(std::function<void(const char*)>& callback);
  Error nextToken(Token& next_token);
  const char* currentPosition() const;

  void copyFromValue(const Token& token, std::string& to_buffer);
  void copyIncludingValue(const Token& token, std::string& to_buffer);

  void pushScope(JS::Type type);
  void popScope();
  JS::Error goToEndOfScope(JS::Token& token);

  std::string makeErrorString() const;
  void setErrorContextConfig(size_t lineContext, size_t rangeContext);
  Error updateErrorContext(Error error, const std::string& custom_message = std::string());
  const Internal::ErrorContext& errorContext() const { return error_context; }

private:
  enum class InTokenState : unsigned char { FindingName, FindingDelimiter, FindingData, FindingTokenEnd };

  enum class InPropertyState : unsigned char { NoStartFound, FindingEnd, FoundEnd };

  void resetForNewToken();
  void resetForNewValue();
  Error findStringEnd(const DataRef& json_data, size_t* chars_ahead);
  Error findAsciiEnd(const DataRef& json_data, size_t* chars_ahead);
  Error findNumberEnd(const DataRef& json_data, size_t* chars_ahead);
  Error findStartOfNextValue(Type* type, const DataRef& json_data, size_t* chars_ahead);
  Error findDelimiter(const DataRef& json_data, size_t* chars_ahead);
  Error findTokenEnd(const DataRef& json_data, size_t* chars_ahead);
  void requestMoreData();
  void releaseFirstDataRef();
  Error populateFromDataRef(DataRef& data, Type& type, const DataRef& json_data);
  static void populate_annonymous_token(const DataRef& data, Type type, Token& token);
  Error populateNextTokenFromDataRef(Token& next_token, const DataRef& json_data);

  InTokenState token_state = InTokenState::FindingName;
  InPropertyState property_state = InPropertyState::NoStartFound;
  Type property_type = Type::Error;
  bool is_escaped : 1;
  bool allow_ascii_properties : 1;
  bool allow_new_lines : 1;
  bool allow_superfluous_comma : 1;
  bool expecting_prop_or_annonymous_data : 1;
  bool continue_after_need_more_data : 1;
  size_t cursor_index;
  size_t current_data_start;
  size_t line_context;
  size_t line_range_context;
  size_t range_context;
  Internal::IntermediateToken intermediate_token;
  std::vector<DataRef> data_list;
  std::vector<Internal::ScopeCounter> scope_counter;
  std::vector<Type> container_stack;
  std::function<void(const char*)> release_callback;
  std::function<void(Tokenizer&)> need_more_data_callback;
  std::vector<std::pair<size_t, std::string*>> copy_buffers;
  const std::vector<Token>* parsed_data_vector;
  Internal::ErrorContext error_context;
};

namespace Internal {
template <size_t SIZE> struct StringLiteral {
  const char* data;
  enum size_enum { size = SIZE };
};
template <size_t SIZE> constexpr StringLiteral<SIZE - 1> makeStringLiteral(const char (&literal)[SIZE]) {
  return {literal};
}
} // namespace Internal

class SerializerOptions {
public:
  enum Style : unsigned char { Pretty, Compact };

  SerializerOptions(Style style = Style::Pretty);

  int shiftSize() const;
  void setShiftSize(unsigned char set);

  Style style() const;
  void setStyle(Style style);

  bool convertAsciiToString() const;
  void setConvertAsciiToString(bool set);

  unsigned char depth() const;
  void setDepth(int depth);

  void skipDelimiter(bool skip);

  const std::string& prefix() const;
  const std::string& tokenDelimiter() const;
  const std::string& valueDelimiter() const;
  const std::string& postfix() const;

private:
  uint8_t m_shift_size;
  uint8_t m_depth;
  Style m_style;
  bool m_convert_ascii_to_string;

  std::string m_prefix;
  std::string m_token_delimiter;
  std::string m_value_delimiter;
  std::string m_postfix;
};

class SerializerBuffer {
public:
  SerializerBuffer() : buffer(nullptr), size(0), used(0) {}
  SerializerBuffer(char* buffer, size_t size) : buffer(buffer), size(size), used(0) {}
  size_t free() const { return size - used; }
  void append(const char* data, size_t size);
  template <size_t SIZE> void append(const char* data);
  char* buffer;
  size_t size;
  size_t used;
};

class Serializer {
public:
  Serializer();
  Serializer(char* buffer, size_t size);

  void setBuffer(char* buffer, size_t size);
  void setOptions(const SerializerOptions& option);
  SerializerOptions options() const { return m_option; }

  bool write(const Token& token);
  bool write(const char* data, size_t size);
  bool write(const std::string& str) { return write(str.c_str(), str.size()); }
  template <size_t SIZE> inline bool write(const Internal::StringLiteral<SIZE>& strLiteral);

  void setRequestBufferCallback(std::function<void(Serializer&)> callback);
  const SerializerBuffer& currentBuffer() const;

private:
  void askForMoreBuffers();
  void markCurrentSerializerBufferFull();
  bool writeAsString(const DataRef& data);
  bool write(Type type, const DataRef& data);

  std::function<void(Serializer&)> m_request_buffer_callback;
  SerializerBuffer m_current_buffer;

  bool m_first;
  bool m_token_start;
  SerializerOptions m_option;
};

// IMPLEMENTATION

inline Token::Token() : name(), value(), name_type(Type::String), value_type(Type::String) {}

inline Tokenizer::Tokenizer()
    : is_escaped(false), allow_ascii_properties(false), allow_new_lines(false), allow_superfluous_comma(false),
      expecting_prop_or_annonymous_data(false), continue_after_need_more_data(false), cursor_index(0),
      current_data_start(0), line_context(4), line_range_context(256), range_context(38), parsed_data_vector(nullptr) {
  container_stack.reserve(16);
}

inline void Tokenizer::allowAsciiType(bool allow) { allow_ascii_properties = allow; }

inline void Tokenizer::allowNewLineAsTokenDelimiter(bool allow) { allow_new_lines = allow; }

inline void Tokenizer::allowSuperfluousComma(bool allow) { allow_superfluous_comma = allow; }
inline void Tokenizer::addData(const char* data, size_t data_size) { data_list.push_back(DataRef(data, data_size)); }

template <size_t N> inline void Tokenizer::addData(const char (&data)[N]) { data_list.push_back(DataRef(data)); }

inline void Tokenizer::addData(const std::vector<Token>* parsedData) {
  assert(parsed_data_vector == 0);
  parsed_data_vector = parsedData;
  cursor_index = 0;
}

inline void Tokenizer::resetData(const char* data, size_t size, size_t index) {

  if (release_callback) {
    for (auto& data_buffer : data_list) {
      release_callback(data_buffer.data);
    }
  }
  data_list.clear();
  parsed_data_vector = nullptr;
  cursor_index = index;
  addData(data, size);
  resetForNewToken();
}

inline void Tokenizer::resetData(const std::vector<Token>* parsedData, size_t index) {
  if (release_callback) {
    for (auto& data_buffer : data_list) {
      release_callback(data_buffer.data);
    }
  }
  data_list.clear();
  parsed_data_vector = parsedData;
  cursor_index = index;
  resetForNewToken();
}

inline size_t Tokenizer::registeredBuffers() const { return data_list.size(); }

inline void Tokenizer::setNeedMoreDataCallback(std::function<void(Tokenizer&)> callback) {
  need_more_data_callback = callback;
}

inline void Tokenizer::setReleaseCallback(std::function<void(const char*)>& callback) { release_callback = callback; }

inline Error Tokenizer::nextToken(Token& next_token) {
  assert(
      !scope_counter.size() ||
      (scope_counter.back().type != JS::Type::ArrayEnd && scope_counter.back().type != JS::Type::ObjectEnd)
  );
  if (scope_counter.size() && scope_counter.back().depth == 0) {
    return Error::ScopeHasEnded;
  }
  if (parsed_data_vector) {
    next_token = (*parsed_data_vector)[cursor_index];
    cursor_index++;
    if (cursor_index == parsed_data_vector->size()) {
      cursor_index = 0;
      parsed_data_vector = nullptr;
    }
    if (scope_counter.size()) {
      scope_counter.back().handleType(next_token.value_type);
    }
    return Error::NoError;
  }
  if (data_list.empty()) {
    requestMoreData();
  }

  error_context.clear();

  if (data_list.empty()) {
    return Error::NeedMoreData;
  }

  if (!continue_after_need_more_data) {
    resetForNewToken();
  }

  Error error = Error::NeedMoreData;
  while (error == Error::NeedMoreData && data_list.size()) {
    const DataRef& json_data = data_list.front();
    error = populateNextTokenFromDataRef(next_token, json_data);

    if (error != Error::NoError && error != Error::NeedMoreData) {
      updateErrorContext(error);
    }

    if (error == Error::NeedMoreData) {
      releaseFirstDataRef();
      requestMoreData();
    }
  }

  continue_after_need_more_data = error == Error::NeedMoreData;
  if (error == JS::Error::NoError) {
    if (next_token.value_type == Type::ArrayStart || next_token.value_type == Type::ObjectStart) {
      container_stack.push_back(next_token.value_type);
    }
    if (next_token.value_type == Type::ArrayEnd) {
      if (!container_stack.size() || container_stack.back() != JS::Type::ArrayStart) {
        error = Error::UnexpectedArrayEnd;
        updateErrorContext(error);
        return error;
      }
      container_stack.pop_back();
    }
    if (next_token.value_type == Type::ObjectEnd) {
      if (!container_stack.size() || container_stack.back() != JS::Type::ObjectStart) {
        error = Error::UnexpectedObjectEnd;
        updateErrorContext(error);
        return error;
      }
      container_stack.pop_back();
    }
    if (scope_counter.size()) {
      scope_counter.back().handleType(next_token.value_type);
    }
  }
  return error;
}

inline const char* Tokenizer::currentPosition() const {
  if (parsed_data_vector) {
    return reinterpret_cast<const char*>(cursor_index);
  }

  if (data_list.empty()) {
    return nullptr;
  }

  return data_list.front().data + cursor_index;
}

static bool isValueInIntermediateToken(const Token& token, const Internal::IntermediateToken& intermediate) {
  if (intermediate.data.size()) {
    return token.value.data >= &intermediate.data[0] &&
           token.value.data < &intermediate.data[0] + intermediate.data.size();
  }
  return false;
}

inline void Tokenizer::copyFromValue(const Token& token, std::string& to_buffer) {
  if (isValueInIntermediateToken(token, intermediate_token)) {
    std::string data(token.value.data, token.value.size);
    to_buffer += data;
    auto pair = std::make_pair(cursor_index, &to_buffer);
    copy_buffers.push_back(pair);
  } else {
    assert(
        token.value.data >= data_list.front().data && token.value.data < data_list.front().data + data_list.front().size
    );
    ptrdiff_t index = token.value.data - data_list.front().data;
    auto pair = std::make_pair(index, &to_buffer);
    copy_buffers.push_back(pair);
  }
}

inline void Tokenizer::copyIncludingValue(const Token&, std::string& to_buffer) {
  auto it =
      std::find_if(copy_buffers.begin(), copy_buffers.end(), [&to_buffer](const std::pair<size_t, std::string*>& pair) {
        return &to_buffer == pair.second;
      });
  assert(it != copy_buffers.end());
  assert(it->first <= cursor_index);
  if (cursor_index - it->first != 0) {
    to_buffer.append(data_list.front().data + it->first, cursor_index - it->first);
  }
  copy_buffers.erase(it);
}

inline void Tokenizer::pushScope(JS::Type type) {
  scope_counter.push_back({type, 1});
  if (type != Type::ArrayStart && type != Type::ObjectStart) {
    scope_counter.back().depth--;
  }
}

inline void Tokenizer::popScope() {
  assert(scope_counter.size() && scope_counter.back().depth == 0);
  scope_counter.pop_back();
}

inline JS::Error Tokenizer::goToEndOfScope(JS::Token& token) {
  JS::Error error = JS::Error::NoError;
  while (scope_counter.back().depth && error == JS::Error::NoError) {
    error = nextToken(token);
  }
  return error;
}

namespace Internal {
static const char* error_strings[] = {
    "NoError",
    "NeedMoreData",
    "InvalidToken",
    "ExpectedPropertyName",
    "ExpectedDelimiter",
    "ExpectedDataToken",
    "ExpectedObjectStart",
    "ExpectedObjectEnd",
    "ExpectedArrayStart",
    "ExpectedArrayEnd",
    "UnexpectedArrayEnd",
    "UnexpectedObjectEnd",
    "IllegalPropertyName",
    "IllegalPropertyType",
    "IllegalDataValue",
    "EncounteredIllegalChar",
    "NodeNotFound",
    "MissingPropertyMember",
    "MissingFunction",
    "FailedToParseBoolean",
    "FailedToParseDouble",
    "FailedToParseFloat",
    "FailedToParseInt",
    "UnassignedRequiredMember",
    "NonContigiousMemory",
    "ScopeHasEnded",
    "KeyNotFound",
    "DuplicateInSet",
    "UnknownError",
    "UserDefinedErrors",
};
}

inline std::string Tokenizer::makeErrorString() const {
  static_assert(
      sizeof(Internal::error_strings) / sizeof *Internal::error_strings == size_t(Error::UserDefinedErrors) + 1,
      "Please add missing error message"
  );

  std::string retString("Error");
  if (error_context.error < Error::UserDefinedErrors) {
    retString += std::string(" ") + Internal::error_strings[int(error_context.error)];
  }
  if (error_context.custom_message.size()) {
    retString += " " + error_context.custom_message;
  }
  retString += std::string(":\n");
  for (size_t i = 0; i < error_context.lines.size(); i++) {
    retString += error_context.lines[i] + "\n";
    if (i == error_context.line) {
      std::string pointing(error_context.character + 2, ' ');
      pointing[error_context.character] = '^';
      pointing[error_context.character + 1] = '\n';
      retString += pointing;
    }
  }
  return retString;
}

inline void Tokenizer::setErrorContextConfig(size_t lineContext, size_t rangeContext) {
  line_context = lineContext;
  range_context = rangeContext;
}

inline void Tokenizer::resetForNewToken() {
  intermediate_token.clear();
  resetForNewValue();
}

inline void Tokenizer::resetForNewValue() {
  property_state = InPropertyState::NoStartFound;
  property_type = Type::Error;
  current_data_start = 0;
}

inline Error Tokenizer::findStringEnd(const DataRef& json_data, size_t* chars_ahead) {
  size_t end = cursor_index;
  while (end < json_data.size) {
    if (is_escaped) {
      is_escaped = false;
      end++;
      continue;
    }
    while (end + 4 < json_data.size) {
      unsigned char lc = Internal::lookup()[(unsigned char) json_data.data[end]];
      if (lc == Internal::StrEndOrBackSlash) {
        break;
      }
      lc = Internal::lookup()[(unsigned char) json_data.data[++end]];
      if (lc == Internal::StrEndOrBackSlash) {
        break;
      }
      lc = Internal::lookup()[(unsigned char) json_data.data[++end]];
      if (lc == Internal::StrEndOrBackSlash) {
        break;
      }
      lc = Internal::lookup()[(unsigned char) json_data.data[++end]];
      if (lc == Internal::StrEndOrBackSlash) {
        break;
      }
      end++;
    }
    if (end >= json_data.size) {
      break;
    }
    char c = json_data.data[end];
    if (c == '\\') {
      is_escaped = true;
    } else if (c == '"') {
      *chars_ahead = end + 1 - cursor_index;
      return Error::NoError;
    }
    end++;
  }
  return Error::NeedMoreData;
}

inline Error Tokenizer::findAsciiEnd(const DataRef& json_data, size_t* chars_ahead) {
  assert(property_type == Type::Ascii);
  size_t end = cursor_index;
  while (end < json_data.size) {
    while (end + 4 < json_data.size) {
      unsigned char lc = Internal::lookup()[(unsigned char) json_data.data[end]];
      if (!(lc & (Internal::AsciiLetters | Internal::Digits | Internal::HatUnderscoreAprostoph))) {
        break;
      }
      lc = Internal::lookup()[(unsigned char) json_data.data[++end]];
      if (!(lc & (Internal::AsciiLetters | Internal::Digits | Internal::HatUnderscoreAprostoph))) {
        break;
      }
      lc = Internal::lookup()[(unsigned char) json_data.data[++end]];
      if (!(lc & (Internal::AsciiLetters | Internal::Digits | Internal::HatUnderscoreAprostoph))) {
        break;
      }
      lc = Internal::lookup()[(unsigned char) json_data.data[++end]];
      if (!(lc & (Internal::AsciiLetters | Internal::Digits | Internal::HatUnderscoreAprostoph))) {
        break;
      }
      end++;
    }

    char ascii_code = json_data.data[end];
    if ((ascii_code >= 'A' && ascii_code <= 'Z') || (ascii_code >= '^' && ascii_code <= 'z') ||
        (ascii_code >= '0' && ascii_code <= '9')) {
      end++;
      continue;
    } else if (ascii_code == '\0') {
      *chars_ahead = end - cursor_index;
      return Error::NeedMoreData;
    } else {
      *chars_ahead = end - cursor_index;
      return Error::NoError;
    }
  }
  return Error::NeedMoreData;
}

inline Error Tokenizer::findNumberEnd(const DataRef& json_data, size_t* chars_ahead) {
  size_t end = cursor_index;
  while (end + 4 < json_data.size) {
    unsigned char lc = Internal::lookup()[(unsigned char) json_data.data[end]];
    if (!(lc & (Internal::NumberEnd))) {
      break;
    }
    lc = Internal::lookup()[(unsigned char) json_data.data[++end]];
    if (!(lc & (Internal::NumberEnd))) {
      break;
    }
    lc = Internal::lookup()[(unsigned char) json_data.data[++end]];
    if (!(lc & (Internal::NumberEnd))) {
      break;
    }
    lc = Internal::lookup()[(unsigned char) json_data.data[++end]];
    if (!(lc & (Internal::NumberEnd))) {
      break;
    }
    end++;
  }
  while (end < json_data.size) {
    unsigned char lc = Internal::lookup()[(unsigned char) json_data.data[end]];
    if (lc & (Internal::NumberEnd)) {
      end++;
    } else {
      *chars_ahead = end - cursor_index;
      return Error::NoError;
    }
  }
  return Error::NeedMoreData;
}

inline Error Tokenizer::findStartOfNextValue(Type* type, const DataRef& json_data, size_t* chars_ahead) {

  assert(property_state == InPropertyState::NoStartFound);

  for (size_t current_pos = cursor_index; current_pos < json_data.size; current_pos++) {
    const char c = json_data.data[current_pos];
    unsigned char lc = Internal::lookup()[(unsigned char) c];
    if (c == '"') {
      *type = Type::String;
      *chars_ahead = current_pos - cursor_index;
      return Error::NoError;
    } else if (c == '{') {
      *type = Type::ObjectStart;
      *chars_ahead = current_pos - cursor_index;
      return Error::NoError;
    } else if (c == '}') {
      *type = Type::ObjectEnd;
      *chars_ahead = current_pos - cursor_index;
      return Error::NoError;
    } else if (c == '[') {
      *type = Type::ArrayStart;
      *chars_ahead = current_pos - cursor_index;
      return Error::NoError;
    } else if (c == ']') {
      *type = Type::ArrayEnd;
      *chars_ahead = current_pos - cursor_index;
      return Error::NoError;
    } else if (lc & (Internal::PlusOrMinus | Internal::Digits)) {
      *type = Type::Number;
      *chars_ahead = current_pos - cursor_index;
      return Error::NoError;
    } else if (lc & Internal::AsciiLetters) {
      *type = Type::Ascii;
      *chars_ahead = current_pos - cursor_index;
      return Error::NoError;
    } else if (lc == 0) {
      *chars_ahead = current_pos - cursor_index;
      return Error::EncounteredIllegalChar;
    }
  }
  return Error::NeedMoreData;
}

inline Error Tokenizer::findDelimiter(const DataRef& json_data, size_t* chars_ahead) {
  if (container_stack.empty()) {
    return Error::IllegalPropertyType;
  }
  for (size_t end = cursor_index; end < json_data.size; end++) {
    const char c = json_data.data[end];
    if (c == ':') {
      if (container_stack.back() != Type::ObjectStart) {
        return Error::ExpectedDelimiter;
      }
      token_state = InTokenState::FindingData;
      *chars_ahead = end + 1 - cursor_index;
      return Error::NoError;
    } else if (c == ',') {
      if (container_stack.back() != Type::ArrayStart) {
        return Error::ExpectedDelimiter;
      }
      token_state = InTokenState::FindingName;
      *chars_ahead = end + 1 - cursor_index;
      return Error::NoError;
    } else if (c == ']') {
      if (container_stack.back() != Type::ArrayStart) {
        return Error::ExpectedDelimiter;
      }
      token_state = InTokenState::FindingName;
      *chars_ahead = end - cursor_index;
      return Error::NoError;
    } else if (!(Internal::lookup()[(unsigned char) c] & Internal::WhiteSpaceOrNull)) {
      return Error::ExpectedDelimiter;
    }
  }
  return Error::NeedMoreData;
}

inline Error Tokenizer::findTokenEnd(const DataRef& json_data, size_t* chars_ahead) {
  if (container_stack.empty()) {
    return Error::NoError;
  }
  for (size_t end = cursor_index; end < json_data.size; end++) {
    const char c = json_data.data[end];
    if (c == ',') {
      expecting_prop_or_annonymous_data = true;
      *chars_ahead = end + 1 - cursor_index;
      return Error::NoError;
    } else if (c == ']' || c == '}') {
      *chars_ahead = end - cursor_index;
      return Error::NoError;
    } else if (c == '\n') {
      if (allow_new_lines) {
        *chars_ahead = end + 1 - cursor_index;
        return Error::NoError;
      }
    } else if (Internal::lookup()[(unsigned char) c] & Internal::WhiteSpaceOrNull) {
      continue;
    } else {
      *chars_ahead = end + 1 - cursor_index;
      return Error::InvalidToken;
    }
  }
  return Error::NeedMoreData;
}

inline void Tokenizer::requestMoreData() {
  if (need_more_data_callback) {
    need_more_data_callback(*this);
  }
}

inline void Tokenizer::releaseFirstDataRef() {
  if (data_list.empty()) {
    return;
  }

  const DataRef& json_data = data_list.front();

  for (auto& copy_pair : copy_buffers) {
    std::string data(json_data.data + copy_pair.first, json_data.size - copy_pair.first);
    *copy_pair.second += data;
    copy_pair.first = 0;
  }

  cursor_index = 0;
  current_data_start = 0;

  const char* data_to_release = json_data.data;
  data_list.erase(data_list.begin());
  if (release_callback) {
    release_callback(data_to_release);
  }
}

inline Error Tokenizer::populateFromDataRef(DataRef& data, Type& type, const DataRef& json_data) {
  size_t diff = 0;
  Error error = Error::NoError;
  data.size = 0;
  data.data = json_data.data + cursor_index;
  if (property_state == InPropertyState::NoStartFound) {
    error = findStartOfNextValue(&type, json_data, &diff);
    if (error != Error::NoError) {
      type = Type::Error;
      return error;
    }

    data.data = json_data.data + cursor_index + diff;
    current_data_start = cursor_index + diff;
    if (type == Type::String) {
      data.data++;
      current_data_start++;
    }
    cursor_index += diff + 1;
    property_type = type;

    if (type == Type::ObjectStart || type == Type::ObjectEnd || type == Type::ArrayStart || type == Type::ArrayEnd) {
      data.size = 1;
      property_state = InPropertyState::FoundEnd;
    } else {
      property_state = InPropertyState::FindingEnd;
    }
  }

  size_t negative_size_adjustment = 0;
  if (property_state == InPropertyState::FindingEnd) {
    switch (type) {
    case Type::String:
      error = findStringEnd(json_data, &diff);
      negative_size_adjustment = 1;
      break;
    case Type::Ascii:
      error = findAsciiEnd(json_data, &diff);
      break;
    case Type::Number:
      error = findNumberEnd(json_data, &diff);
      break;
    default:
      return Error::InvalidToken;
    }

    if (error != Error::NoError) {
      return error;
    }

    cursor_index += diff;
    data.size = cursor_index - current_data_start - negative_size_adjustment;
    property_state = InPropertyState::FoundEnd;
  }

  return Error::NoError;
}

inline void Tokenizer::populate_annonymous_token(const DataRef& data, Type type, Token& token) {
  token.name = DataRef();
  token.name_type = Type::Ascii;
  token.value = data;
  token.value_type = type;
}

namespace Internal {
static Type getType(Type type, const char* data, size_t length) {
  static const char m_null[] = "null";
  static const char m_true[] = "true";
  static const char m_false[] = "false";
  if (type != Type::Ascii) {
    return type;
  }
  if (sizeof(m_null) - 1 == length) {
    if (memcmp(m_null, data, length) == 0) {
      return Type::Null;
    } else if (memcmp(m_true, data, length) == 0) {
      return Type::Bool;
    }
  }
  if (sizeof(m_false) - 1 == length) {
    if (memcmp(m_false, data, length) == 0) {
      return Type::Bool;
    }
  }
  return Type::Ascii;
}

inline size_t strnlen(const char* data, size_t size) {
  auto it = std::find(data, data + size, '\0');
  return it - data;
}

} // namespace Internal

inline Error Tokenizer::populateNextTokenFromDataRef(Token& next_token, const DataRef& json_data) {
  Token tmp_token;
  while (cursor_index < json_data.size) {
    size_t diff = 0;
    DataRef data;
    Type type;
    Error error;
    switch (token_state) {
    case InTokenState::FindingName:
      type = intermediate_token.name_type;
      error = populateFromDataRef(data, type, json_data);
      if (error == Error::NeedMoreData) {
        if (property_state > InPropertyState::NoStartFound) {
          intermediate_token.active = true;
          size_t to_null = Internal::strnlen(data.data, json_data.size - current_data_start);
          intermediate_token.name.append(data.data, to_null);
          if (!intermediate_token.name_type_set) {
            intermediate_token.name_type = type;
            intermediate_token.name_type_set = true;
          }
        }
        return error;
      } else if (error != Error::NoError) {
        return error;
      }

      if (intermediate_token.active) {
        intermediate_token.name.append(data.data, data.size);
        data = DataRef(intermediate_token.name);
        type = intermediate_token.name_type;
      }

      if (type == Type::ObjectEnd || type == Type::ArrayEnd || type == Type::ArrayStart || type == Type::ObjectStart) {
        switch (type) {
        case Type::ObjectEnd:
        case Type::ArrayEnd:
          if (expecting_prop_or_annonymous_data && !allow_superfluous_comma) {
            return Error::ExpectedDataToken;
          }
          populate_annonymous_token(data, type, next_token);
          token_state = InTokenState::FindingTokenEnd;
          return Error::NoError;

        case Type::ObjectStart:
        case Type::ArrayStart:
          populate_annonymous_token(data, type, next_token);
          expecting_prop_or_annonymous_data = false;
          token_state = InTokenState::FindingName;
          return Error::NoError;
        default:
          return Error::UnknownError;
        }
      } else {
        tmp_token.name = data;
      }

      tmp_token.name_type = Internal::getType(type, tmp_token.name.data, tmp_token.name.size);
      token_state = InTokenState::FindingDelimiter;
      resetForNewValue();
      break;

    case InTokenState::FindingDelimiter:
      error = findDelimiter(json_data, &diff);
      if (error != Error::NoError) {
        if (intermediate_token.active == false) {
          intermediate_token.name.append(tmp_token.name.data, tmp_token.name.size);
          intermediate_token.name_type = tmp_token.name_type;
          intermediate_token.active = true;
        }
        return error;
      }
      cursor_index += diff;
      resetForNewValue();
      expecting_prop_or_annonymous_data = false;
      if (token_state == InTokenState::FindingName) {
        populate_annonymous_token(tmp_token.name, tmp_token.name_type, next_token);
        return Error::NoError;
      } else {
        if (tmp_token.name_type != Type::String) {
          if (!allow_ascii_properties || tmp_token.name_type != Type::Ascii) {
            return Error::IllegalPropertyName;
          }
        }
      }
      break;

    case InTokenState::FindingData:
      type = intermediate_token.data_type;
      error = populateFromDataRef(data, type, json_data);
      if (error == Error::NeedMoreData) {
        if (intermediate_token.active == false) {
          intermediate_token.name.append(tmp_token.name.data, tmp_token.name.size);
          intermediate_token.name_type = tmp_token.name_type;
          intermediate_token.active = true;
        }
        if (property_state > InPropertyState::NoStartFound) {
          size_t data_length = Internal::strnlen(data.data, json_data.size - current_data_start);
          intermediate_token.data.append(data.data, data_length);
          if (!intermediate_token.data_type_set) {
            intermediate_token.data_type = type;
            intermediate_token.data_type_set = true;
          }
        }
        return error;
      } else if (error != Error::NoError) {
        return error;
      }

      if (intermediate_token.active) {
        intermediate_token.data.append(data.data, data.size);
        if (!intermediate_token.data_type_set) {
          intermediate_token.data_type = type;
          intermediate_token.data_type_set = true;
        }
        tmp_token.name = DataRef(intermediate_token.name);
        tmp_token.name_type = intermediate_token.name_type;
        data = DataRef(intermediate_token.data);
        type = intermediate_token.data_type;
      }

      tmp_token.value = data;
      tmp_token.value_type = Internal::getType(type, tmp_token.value.data, tmp_token.value.size);

      if (tmp_token.value_type == Type::Ascii && !allow_ascii_properties) {
        return Error::IllegalDataValue;
      }

      if (type == Type::ObjectStart || type == Type::ArrayStart) {
        token_state = InTokenState::FindingName;
      } else {
        token_state = InTokenState::FindingTokenEnd;
      }
      next_token = tmp_token;
      return Error::NoError;
    case InTokenState::FindingTokenEnd:
      error = findTokenEnd(json_data, &diff);
      if (error != Error::NoError) {
        return error;
      }
      cursor_index += diff;
      token_state = InTokenState::FindingName;
      break;
    }
  }
  return Error::NeedMoreData;
}

namespace Internal {
struct Lines {
  size_t start;
  size_t end;
};
} // namespace Internal

inline Error Tokenizer::updateErrorContext(Error error, const std::string& custom_message) {
  error_context.error = error;
  error_context.custom_message = custom_message;
  if ((!parsed_data_vector || parsed_data_vector->empty()) && data_list.empty()) {
    return error;
  }

  const DataRef json_data =
      parsed_data_vector && parsed_data_vector->size()
          ? DataRef(
                parsed_data_vector->front().value.data,
                size_t(parsed_data_vector->back().value.data - parsed_data_vector->front().value.data)
            )
          : data_list.front();
  int64_t real_cursor_index = parsed_data_vector && parsed_data_vector->size()
                                  ? int64_t(parsed_data_vector->at(cursor_index).value.data - json_data.data)
                                  : int64_t(cursor_index);
  const int64_t stop_back = real_cursor_index - std::min(int64_t(real_cursor_index), int64_t(line_range_context));
  const int64_t stop_forward = std::min(real_cursor_index + int64_t(line_range_context), int64_t(json_data.size));
  std::vector<Internal::Lines> lines;
  lines.push_back({0, size_t(real_cursor_index)});
  assert(real_cursor_index <= int64_t(json_data.size));
  int64_t lines_back = 0;
  int64_t lines_forward = 0;
  int64_t cursor_back;
  int64_t cursor_forward;
  for (cursor_back = real_cursor_index - 1; cursor_back > stop_back; cursor_back--) {
    if (*(json_data.data + cursor_back) == '\n') {
      lines.front().start = size_t(cursor_back + 1);
      lines_back++;
      if (lines_back == 1) {
        error_context.character = size_t(real_cursor_index - cursor_back);
      }
      if (lines_back == int64_t(line_context)) {
        lines_back--;
        break;
      }

      lines.insert(lines.begin(), {0, size_t(cursor_back)});
    }
  }
  if (lines.front().start == 0 && cursor_back > 0) {
    lines.front().start = size_t(cursor_back);
  }
  bool add_new_line = false;
  for (cursor_forward = real_cursor_index; cursor_forward < stop_forward; cursor_forward++) {
    if (add_new_line) {
      lines.push_back({size_t(cursor_forward), 0});
      add_new_line = false;
    }
    if (*(json_data.data + cursor_forward) == '\n') {
      lines.back().end = size_t(cursor_forward);
      lines_forward++;
      if (lines_forward == int64_t(line_context)) {
        break;
      }
      add_new_line = true;
    }
  }
  if (lines.back().end == 0) {
    lines.back().end = size_t(cursor_forward - 1);
  }

  if (lines.size() > 1) {
    error_context.lines.reserve(lines.size());
    for (auto& line : lines) {
      error_context.lines.push_back(std::string(json_data.data + line.start, line.end - line.start));
    }
    error_context.line = size_t(lines_back);
  } else {
    error_context.line = 0;

    int64_t left = real_cursor_index > int64_t(range_context) ? real_cursor_index - int64_t(range_context) : 0;
    int64_t right = real_cursor_index + int64_t(range_context) > int64_t(json_data.size)
                        ? int64_t(json_data.size)
                        : real_cursor_index + int64_t(range_context);
    error_context.character = size_t(real_cursor_index - left);
    error_context.lines.push_back(std::string(json_data.data + left, size_t(right - left)));
  }
  return error;
}

static inline JS::Error reformat(
    const char* data, size_t size, std::string& out, const SerializerOptions& options = SerializerOptions()
) {
  Token token;
  Tokenizer tokenizer;
  tokenizer.addData(data, size);
  Error error = Error::NoError;

  Serializer serializer;
  serializer.setOptions(options);
  size_t last_pos = 0;
  serializer.setRequestBufferCallback([&out, &last_pos](Serializer& serializer_p) {
    size_t end = out.size();
    out.resize(end * 2);
    serializer_p.setBuffer(&out[0] + end, end);
    last_pos = end;
  });
  if (out.empty()) {
    out.resize(4096);
  }
  serializer.setBuffer(&out[0], out.size());

  while (error == Error::NoError) {
    error = tokenizer.nextToken(token);
    if (error != Error::NoError) {
      break;
    }
    serializer.write(token);
  }
  out.resize(last_pos + serializer.currentBuffer().used);
  if (error == Error::NeedMoreData) {
    return Error::NoError;
  }

  return error;
}
static inline JS::Error reformat(
    const std::string& in, std::string& out, const SerializerOptions& options = SerializerOptions()
) {
  return reformat(in.c_str(), in.size(), out, options);
}

// Tuple start
namespace Internal {
template <size_t...> struct Sequence {
  using type = Sequence;
};

template <typename A, typename B> struct Merge;
template <size_t... Is1, size_t... Is2> struct Merge<Sequence<Is1...>, Sequence<Is2...>> {
  using type = Sequence<Is1..., (sizeof...(Is1) + Is2)...>;
};

template <size_t size> struct GenSequence;
template <> struct GenSequence<0> {
  using type = Sequence<>;
};
template <> struct GenSequence<1> {
  using type = Sequence<0>;
};
template <size_t size> struct GenSequence {
  using type = typename Merge<
      typename GenSequence<size / size_t(2)>::type, typename GenSequence<size - size / size_t(2)>::type>::type;
};

template <size_t index, typename T> struct Element {
  constexpr Element() : data() {}

  constexpr Element(const T& t) : data(t) {}
  using type = T;
  T data;
};

template <typename A, typename... Bs> struct TupleImpl;

template <size_t... indices, typename... Ts>
struct TupleImpl<Sequence<indices...>, Ts...> : public Element<indices, Ts>... {
  constexpr TupleImpl() : Element<indices, Ts>()... {}

  constexpr TupleImpl(Ts... args) : Element<indices, Ts>(args)... {}
};
} // namespace Internal

template <size_t I, typename... Ts> struct TypeAt {
  template <typename T> static Internal::Element<I, T> deduce(Internal::Element<I, T>);

  using tuple_impl = Internal::TupleImpl<typename Internal::GenSequence<sizeof...(Ts)>::type, Ts...>;
  using element = decltype(deduce(tuple_impl()));
  using type = typename element::type;
};

template <typename... Ts> struct Tuple {
  constexpr Tuple() : impl() {}

  constexpr Tuple(Ts... args) : impl(args...) {}

  using Seq = typename Internal::GenSequence<sizeof...(Ts)>::type;
  Internal::TupleImpl<Seq, Ts...> impl;
  static constexpr const size_t size = sizeof...(Ts);

  template <size_t Index> constexpr const typename TypeAt<Index, Ts...>::type& get() const {
    return static_cast<const typename TypeAt<Index, Ts...>::element&>(impl).data;
  }

  template <size_t Index> typename TypeAt<Index, Ts...>::type& get() {
    return static_cast<typename TypeAt<Index, Ts...>::element&>(impl).data;
  }
};

/// \private
template <size_t I, typename... Ts> struct TypeAt<I, const Tuple<Ts...>> {
  template <typename T> static Internal::Element<I, T> deduce(Internal::Element<I, T>);

  using tuple_impl = Internal::TupleImpl<typename Internal::GenSequence<sizeof...(Ts)>::type, Ts...>;
  using element = decltype(deduce(tuple_impl()));
  using type = typename element::type;
};

/// \private
template <size_t I, typename... Ts> struct TypeAt<I, Tuple<Ts...>> {
  template <typename T> static Internal::Element<I, T> deduce(Internal::Element<I, T>);

  using tuple_impl = Internal::TupleImpl<typename Internal::GenSequence<sizeof...(Ts)>::type, Ts...>;
  using element = decltype(deduce(tuple_impl()));
  using type = typename element::type;
};

/*!  \private
 */
template <> struct Tuple<> {
  static constexpr const size_t size = 0;
};

template <typename... Ts> constexpr Tuple<Ts...> makeTuple(Ts... args) { return Tuple<Ts...>(args...); }
// Tuple end

inline SerializerOptions::SerializerOptions(Style style)

    : m_shift_size(style == Compact ? 0 : 2), m_depth(0), m_style(style), m_convert_ascii_to_string(true),
      m_token_delimiter(","), m_value_delimiter(style == Pretty ? ": " : ":"), m_postfix(style == Pretty ? "\n" : "") {}

inline int SerializerOptions::shiftSize() const { return m_shift_size; }

inline void SerializerOptions::setShiftSize(unsigned char set) { m_shift_size = set; }

inline unsigned char SerializerOptions::depth() const { return m_depth; }

inline SerializerOptions::Style SerializerOptions::style() const { return m_style; }

inline bool SerializerOptions::convertAsciiToString() const { return m_convert_ascii_to_string; }

inline void SerializerOptions::setConvertAsciiToString(bool set) { m_convert_ascii_to_string = set; }

inline void SerializerOptions::setStyle(Style style) {
  m_style = style;
  m_postfix = m_style == Pretty ? std::string("\n") : std::string("");
  m_value_delimiter = m_style == Pretty ? std::string(" : ") : std::string(":");
  setDepth(m_depth);
}

inline void SerializerOptions::skipDelimiter(bool skip) {
  if (skip) {
    m_token_delimiter = "";
  } else {
    m_token_delimiter = ",";
  }
}

inline void SerializerOptions::setDepth(int depth) {
  m_depth = (unsigned char) depth;
  m_prefix = m_style == Pretty ? std::string(depth * size_t(m_shift_size), ' ') : std::string();
}

inline const std::string& SerializerOptions::prefix() const { return m_prefix; }
inline const std::string& SerializerOptions::tokenDelimiter() const { return m_token_delimiter; }
inline const std::string& SerializerOptions::valueDelimiter() const { return m_value_delimiter; }
inline const std::string& SerializerOptions::postfix() const { return m_postfix; }

inline void SerializerBuffer::append(const char* data, size_t data_size) {
  assert(used + data_size <= size);
  memcpy(buffer + used, data, data_size);
  used += data_size;
}

template <size_t SIZE> inline void SerializerBuffer::append(const char* data) {
  assert(used + SIZE <= size);
  memcpy(buffer + used, data, SIZE);
  used += SIZE;
}

inline Serializer::Serializer() : m_first(true), m_token_start(true) {}

inline Serializer::Serializer(char* buffer, size_t size)
    : m_current_buffer(buffer, size), m_first(true), m_token_start(true)

{}

inline void Serializer::setBuffer(char* buffer, size_t size) { m_current_buffer = SerializerBuffer(buffer, size); }

inline void Serializer::setOptions(const SerializerOptions& option) { m_option = option; }

inline bool Serializer::write(const Token& in_token) {
  auto begining_literals = makeTuple(
      JS::Internal::makeStringLiteral("\n  "), Internal::makeStringLiteral("\n    "),
      Internal::makeStringLiteral("\n      "), Internal::makeStringLiteral("\n        "),
      Internal::makeStringLiteral("\n          "), Internal::makeStringLiteral(",\n  "),
      Internal::makeStringLiteral(",\n    "), Internal::makeStringLiteral(",\n      "),
      Internal::makeStringLiteral(",\n        "), Internal::makeStringLiteral(",\n          ")
  );
  // auto begining_literals_compat = makeTuple( Internal::makeStringLiteral(",\""));
  const Token& token = in_token;

  bool isEnd = token.value_type == Type::ObjectEnd || token.value_type == Type::ArrayEnd;
  if (isEnd) {
    if (m_option.depth() <= 0) {
      return false;
    }
    m_option.setDepth(m_option.depth() - 1);
  }

  bool shortcut_front = false;
  if (m_option.shiftSize() == 2 && !m_first) {
    if (!m_token_start && !isEnd) {
      if (m_option.depth() == 1) {
        shortcut_front = write(begining_literals.get<5>());
      } else if (m_option.depth() == 2) {
        shortcut_front = write(begining_literals.get<6>());
      } else if (m_option.depth() == 3) {
        shortcut_front = write(begining_literals.get<7>());
      } else if (m_option.depth() == 4) {
        shortcut_front = write(begining_literals.get<8>());
      } else if (m_option.depth() == 5) {
        shortcut_front = write(begining_literals.get<9>());
      }
    } else {
      if (m_option.depth() == 1) {
        shortcut_front = write(begining_literals.get<0>());
      } else if (m_option.depth() == 2) {
        shortcut_front = write(begining_literals.get<1>());
      } else if (m_option.depth() == 3) {
        shortcut_front = write(begining_literals.get<2>());
      } else if (m_option.depth() == 4) {
        shortcut_front = write(begining_literals.get<3>());
      } else if (m_option.depth() == 5) {
        shortcut_front = write(begining_literals.get<4>());
      }
    }
  }

  if (!shortcut_front) {
    if (!m_token_start) {
      if (!isEnd) {
        if (!m_option.tokenDelimiter().empty()) {
          if (!write(Internal::makeStringLiteral(","))) {
            return false;
          }
        }
      }
    }

    if (m_first) {
      m_first = false;
    } else {
      if (!m_option.postfix().empty()) {
        if (!write(m_option.postfix())) {
          return false;
        }
      }
    }

    if (!m_option.prefix().empty()) {
      if (!write(m_option.prefix())) {
        return false;
      }
    }
  }
  if (token.name.size) {
    if (!write(token.name_type, token.name)) {
      return false;
    }

    if (m_option.style() == SerializerOptions::Pretty) {
      if (!write(Internal::makeStringLiteral(": "))) {
        return false;
      }
    } else {
      if (!write(Internal::makeStringLiteral(":"))) {
        return false;
      }
    }
  }

  if (!write(token.value_type, token.value)) {
    return false;
  }

  m_token_start = (token.value_type == Type::ObjectStart || token.value_type == Type::ArrayStart);
  if (m_token_start) {
    m_option.setDepth(m_option.depth() + 1);
  }
  return true;
}

inline void Serializer::setRequestBufferCallback(std::function<void(Serializer&)> callback) {
  m_request_buffer_callback = callback;
}

inline const SerializerBuffer& Serializer::currentBuffer() const { return m_current_buffer; }

inline void Serializer::askForMoreBuffers() {
  if (m_request_buffer_callback) {
    m_request_buffer_callback(*this);
  }
}

inline void Serializer::markCurrentSerializerBufferFull() {
  m_current_buffer = SerializerBuffer();
  askForMoreBuffers();
}

inline bool Serializer::writeAsString(const DataRef& data) {
  bool written;
  written = write(Internal::makeStringLiteral("\""));
  if (!written) {
    return false;
  }

  written = write(data.data, data.size);
  if (!written) {
    return false;
  }

  written = write(Internal::makeStringLiteral("\""));

  return written;
}

inline bool Serializer::write(Type type, const DataRef& data) {
  bool written;
  switch (type) {
  case Type::String:
    written = writeAsString(data);
    break;
  case Type::Ascii:
    if (m_option.convertAsciiToString()) {
      written = writeAsString(data);
    } else {
      written = write(data.data, data.size);
    }
    break;
  case Type::Null:
    written = write("null", 4);
    break;
  default:
    written = write(data.data, data.size);
    break;
  }
  return written;
}

inline bool Serializer::write(const char* data, size_t size) {
  if (!size) {
    return true;
  }
  size_t written = 0;
  while (written < size) {
    size_t free = m_current_buffer.free();
    if (free == 0) {
      markCurrentSerializerBufferFull();
      if (!m_current_buffer.free()) {
        return false;
      }
      continue;
    }
    size_t to_write = std::min(size - written, free);
    m_current_buffer.append(data + written, to_write);
    written += to_write;
  }
  return written == size;
}

template <size_t SIZE> inline bool Serializer::write(const Internal::StringLiteral<SIZE>& strLiteral) {
  if (m_current_buffer.free() < SIZE) {
    return write(strLiteral.data, SIZE);
  }

  m_current_buffer.append<SIZE>(strLiteral.data);
  return true;
}

template <typename T> struct Nullable {
  Nullable() : data() {}
  Nullable(const T& t) : data(t) {}
  Nullable(T&& t) : data(std::move(t)) {}

  Nullable(Nullable<T>&& t) : data(std::move(t.data)) {}
  Nullable(const Nullable<T>& t) : data(t.data) {}

  Nullable<T>& operator=(const T& other) {
    data = other;
    return *this;
  }
  Nullable<T>& operator=(T&& other) {
    data = std::move(other);
    return *this;
  }

  Nullable<T>& operator=(const Nullable<T>& other) {
    data = other.data;
    return *this;
  }
  Nullable<T>& operator=(Nullable<T>&& other) {
    data = std::move(other.data);
    return *this;
  }

  T data;
  T& operator()() { return data; }
  const T& operator()() const { return data; }
};

template <typename T> struct NullableChecked {
  NullableChecked() : data(), null(true) {}
  NullableChecked(const T& t) : data(t), null(false) {}
  NullableChecked(T&& t) : data(std::move(t)), null(false) {}
  NullableChecked(const NullableChecked<T>& t) : data(t.data), null(t.null) {}
  NullableChecked(NullableChecked<T>&& t) : data(std::move(t.data)), null(t.null) {}
  NullableChecked<T>& operator=(const T& other) {
    data = other;
    null = false;
    return *this;
  }
  NullableChecked<T>& operator=(T&& other) {
    data = std::move(other);
    null = false;
    return *this;
  }

  NullableChecked<T>& operator=(const NullableChecked<T>& other) {
    data = other.data;
    null = other.null;
    return *this;
  }
  NullableChecked<T>& operator=(NullableChecked<T>&& other) {
    data = std::move(other.data);
    null = other.null;
    return *this;
  }

  T& operator()() { return data; }
  const T& operator()() const { return data; }
  T data;
  bool null;
};

template <typename T> struct Optional {
  Optional() : data() {}
  Optional(const T& t) : data(t) {}
  Optional(T&& t) : data(std::move(t)) {}

  Optional(const Optional<T>& t) : data(t.data) {}
  Optional(Optional<T>&& t) : data(std::move(t.data)) {}
  Optional<T>& operator=(const T& other) {
    data = other;
    return *this;
  }

  Optional<T>& operator=(T&& other) {
    data = std::move(other);
    return *this;
  }

  Optional<T>& operator=(const Optional<T>& other) {
    data = other.data;
    return *this;
  }

  Optional<T>& operator=(Optional<T>&& other) {
    data = std::move(other.data);
    return *this;
  }

  T data;
  T& operator()() { return data; }
  const T& operator()() const { return data; }
  typedef bool IsOptionalType;
};

template <typename T> struct OptionalChecked {
  OptionalChecked() : data(), assigned(false) {}
  OptionalChecked(const T& t) : data(t), assigned(true) {}
  OptionalChecked(T&& t) : data(std::move(t)), assigned(true) {}
  OptionalChecked(const OptionalChecked<T>& t) : data(t.data), assigned(t.assigned) {}
  OptionalChecked(OptionalChecked<T>&& t) : data(std::move(t.data)), assigned(t.assigned) {}
  OptionalChecked<T>& operator=(const T& other) {
    data = other;
    assigned = true;
    return *this;
  }
  OptionalChecked<T>& operator=(T&& other) {
    data = std::move(other);
    assigned = true;
    return *this;
  }
  OptionalChecked<T>& operator=(const OptionalChecked<T>& other) {
    data = other.data;
    assigned = other.assigned;
    return *this;
  }
  OptionalChecked<T>& operator=(OptionalChecked<T>&& other) {
    data = std::move(other.data);
    assigned = other.assigned;
    return *this;
  }

  T& operator()() { return data; }
  const T& operator()() const { return data; }
#ifdef JS_STD_OPTIONAL
  std::optional<T> opt() const { return assigned ? std::optional<T>(data) : std::nullopt; }
#endif
  T data;
  bool assigned;
  typedef bool IsOptionalType;
};

struct SilentString {
  std::string data;
  typedef bool IsOptionalType;
};

template <typename T, typename A = std::allocator<T>> struct SilentVector {
  std::vector<T, A> data;
  typedef bool IsOptionalType;
};

template <typename T, typename Deleter = std::default_delete<T>> struct SilentUniquePtr {
  std::unique_ptr<T, Deleter> data;
  typedef bool IsOptionalType;
};

struct JsonObjectRef {
  DataRef ref;
};

struct JsonObject {
  std::string data;
};

struct JsonArrayRef {
  DataRef ref;
};

struct JsonArray {
  std::string data;
};

struct JsonObjectOrArrayRef {
  DataRef ref;
};

struct JsonObjectOrArray {
  std::string data;
};

struct JsonTokens {
  std::vector<JS::Token> data;
};

struct JsonMeta {
  JsonMeta(size_t pos, bool is_array)
      : position(pos), size(1), skip(1), children(0), complex_children(0), is_array(is_array), has_data(false) {}

  size_t position;
  uint32_t size;
  uint32_t skip;
  uint32_t children;
  uint32_t complex_children;
  bool is_array : 1;
  bool has_data : 1;
};

static inline std::vector<JsonMeta> metaForTokens(const JsonTokens& tokens) {
  std::vector<JsonMeta> meta;
  meta.reserve(tokens.data.size() / 4);
  std::vector<size_t> parent;
  for (size_t i = 0; i < tokens.data.size(); i++) {
    for (size_t parent_index : parent) {
      meta[parent_index].size++;
    }
    const JS::Token& token = tokens.data.at(i);
    if (token.value_type == Type::ArrayEnd || token.value_type == Type::ObjectEnd) {
      assert(parent.size());
      assert(meta[parent.back()].is_array == (token.value_type == Type::ArrayEnd));
      parent.pop_back();
    } else {
      if (parent.size()) {
        meta[parent.back()].children++;
      }
    }

    if (token.value_type == Type::ArrayStart || token.value_type == Type::ObjectStart) {
      if (parent.size()) {
        meta[parent.back()].complex_children++;
      }
      for (size_t parent_index : parent) {
        meta[parent_index].skip++;
      }
      meta.push_back(JsonMeta(i, token.value_type == Type::ArrayStart));
      parent.push_back(meta.size() - 1);
    } else if (token.value_type != JS::Type::ArrayEnd && token.value_type != JS::Type::ObjectEnd) {
      for (size_t parent_index : parent) {
        meta[parent_index].has_data = true;
      }
    }
  }
  assert(!parent.size()); // This assert may be triggered when JSON is invalid (e.g. when creating a DiffContext).
  return meta;
}

namespace Internal {
static inline size_t findFirstChildWithData(const std::vector<JsonMeta>& meta_vec, size_t start_index) {
  const JsonMeta& meta = meta_vec[start_index];
  if (!meta.has_data) {
    return size_t(-1);
  }

  size_t skip_size = 0;
  for (uint32_t i = 0; i < meta.complex_children; i++) {
    auto& current_child = meta_vec[start_index + skip_size + 1];
    skip_size += current_child.skip;
    if (current_child.has_data) {
      return i;
    }
  }
  return size_t(-1);
}
} // namespace Internal

template <typename T> struct IsOptionalType {
  typedef char yes[1];
  typedef char no[2];

  template <typename C> static constexpr yes& test_in_optional(typename C::IsOptionalType*);

  template <typename> static constexpr no& test_in_optional(...);

  static constexpr const bool value = sizeof(test_in_optional<T>(0)) == sizeof(yes);
};

/// \private
template <typename T> struct IsOptionalType<std::unique_ptr<T>> {
  static constexpr const bool value = true;
};

#ifdef JS_STD_OPTIONAL
/// \private
template <typename T> struct IsOptionalType<std::optional<T>> {
  static constexpr const bool value = true;
};
#endif

struct ParseContext {
  ParseContext() {}
  explicit ParseContext(const char* data, size_t size) { tokenizer.addData(data, size); }

  explicit ParseContext(const char* data) {
    size_t size = strlen(data);
    tokenizer.addData(data, size);
  }

  explicit ParseContext(const std::string& data) { tokenizer.addData(&data[0], data.size()); }

  template <typename T> explicit ParseContext(const char* data, size_t size, T& to_type) {
    tokenizer.addData(data, size);
    auto this_error = parseTo(to_type);
    (void) this_error;
  }
  template <size_t SIZE> explicit ParseContext(const char (&data)[SIZE]) { tokenizer.addData(data); }

  template <typename T> Error parseTo(T& to_type);

  Error nextToken() {
    error = tokenizer.nextToken(token);
    return error;
  }

  std::string makeErrorString() const {
    if (error == Error::MissingPropertyMember) {
      if (missing_members.size() == 0) {
        return "";
      } else if (missing_members.size() == 1) {
        return std::string("JSON Object contained member not found in C++ struct/class. JSON Object member is: ") +
               missing_members.front();
      }
      std::string member_string = missing_members.front();
      for (int i = 1; i < int(missing_members.size()); i++) {
        member_string += std::string(", ") + missing_members[i];
      }
      return std::string("JSON Object contained members not found in C++ struct/class. JSON Object members are: ") +
             member_string;
    } else if (error == Error::UnassignedRequiredMember) {
      if (unassigned_required_members.size() == 0) {
        return "";
      } else if (unassigned_required_members.size() == 1) {
        return std::string(
                   "C++ struct/class has a required member that is not present in input JSON. The unassigned "
                   "C++ member is: "
               ) +
               unassigned_required_members.front();
      }
      std::string required_string = unassigned_required_members.front();
      for (int i = 1; i < int(unassigned_required_members.size()); i++) {
        required_string += std::string(", ") + unassigned_required_members[i];
      }
      return std::string(
                 "C++ struct/class has required members that are not present in the input JSON. The unassigned "
                 "C++ members are: "
             ) +
             required_string;
    }
    if (tokenizer.errorContext().error == Error::NoError && error != Error::NoError) {
      std::string retString("Error:");
      if (error <= Error::UserDefinedErrors) {
        retString += Internal::error_strings[int(error)];
      } else {
        retString += "Unknown error";
      }
      return retString;
    }
    return tokenizer.makeErrorString();
  }

  Tokenizer tokenizer;
  Token token;
  Error error = Error::NoError;
  std::vector<std::string> missing_members;
  std::vector<std::string> unassigned_required_members;
  bool allow_missing_members = true;
  bool allow_unasigned_required_members = true;
  bool track_member_assignement_state = true;
  void* user_data = nullptr;
};

/*! \def JS_MEMBER
 *
 * Create meta information of the member with the same name as
 * the member.
 */
/*! \def JS_MEMBER_ALIASES
 *
 * Create meta information where the primary name is the same as the member and
 * the subsequent names are aliases.
 */
/*! \def JS_MEMBER_WITH_NAME
 *
 * Create meta information where the primary name is argument name, and the subsequent
 * names are aliases.
 */
/*! \def JS_MEMBER_WITH_NAME_AND_ALIASES
 *
 * Creates meta information where the primary name is argument name, a
 * and subsequent names are aliases
 */

/*! \def JS_SUPER_CLASS
 *
 * Creates superclass meta data which is used inside the JS_SUPER_CLASSES macro
 */

/*! \def JS_SUPER_CLASSES
 *
 * Macro to contain the super class definitions
 */

namespace Internal {
template <typename T> struct HasJsonStructBase {
  typedef char yes[1];
  typedef char no[2];

  template <typename C> static constexpr yes& test_in_base(typename C::template JsonStructBase<C>*);

  template <typename> static constexpr no& test_in_base(...);
};

template <typename JS_BASE_STRUCT_T, typename JS_OBJECT_T> struct JsonStructBaseDummy {
  static_assert(
      sizeof(HasJsonStructBase<JS_OBJECT_T>::template test_in_base<JS_OBJECT_T>(nullptr)) ==
          sizeof(typename HasJsonStructBase<JS_OBJECT_T>::yes),
      "Missing JS_OBJECT JS_OBJECT_EXTERNAL or TypeHandler specialisation\n"
  );
  using TT = decltype(JS_OBJECT_T::template JsonStructBase<JS_OBJECT_T>::js_static_meta_data_info());
  using ST = decltype(JS_OBJECT_T::template JsonStructBase<JS_OBJECT_T>::js_static_meta_super_info());
  static inline constexpr const TT js_static_meta_data_info() {
    return JS_OBJECT_T::template JsonStructBase<JS_OBJECT_T>::js_static_meta_data_info();
  }

  static inline constexpr const ST js_static_meta_super_info() {
    return JS_OBJECT_T::template JsonStructBase<JS_OBJECT_T>::js_static_meta_super_info();
  }
};
} // namespace Internal

#define JS_INTERNAL_EXPAND(x) x
#define JS_INTERNAL_FIRST_(a, ...) a
#define JS_INTERNAL_SECOND_(a, b, ...) b
#define JS_INTERNAL_FIRST(...) JS_INTERNAL_EXPAND(JS_INTERNAL_FIRST_(__VA_ARGS__))
#define JS_INTERNAL_SECOND(...) JS_INTERNAL_EXPAND(JS_INTERNAL_SECOND_(__VA_ARGS__))
#define JS_INTERNAL_EMPTY()
#define JS_INTERNAL_EVAL(...) JS_INTERNAL_EVAL1024(__VA_ARGS__)
#define JS_INTERNAL_EVAL1024(...) JS_INTERNAL_EVAL512(JS_INTERNAL_EVAL512(__VA_ARGS__))
#define JS_INTERNAL_EVAL512(...) JS_INTERNAL_EVAL256(JS_INTERNAL_EVAL256(__VA_ARGS__))
#define JS_INTERNAL_EVAL256(...) JS_INTERNAL_EVAL128(JS_INTERNAL_EVAL128(__VA_ARGS__))
#define JS_INTERNAL_EVAL128(...) JS_INTERNAL_EVAL64(JS_INTERNAL_EVAL64(__VA_ARGS__))
#define JS_INTERNAL_EVAL64(...) JS_INTERNAL_EVAL32(JS_INTERNAL_EVAL32(__VA_ARGS__))
#define JS_INTERNAL_EVAL32(...) JS_INTERNAL_EVAL16(JS_INTERNAL_EVAL16(__VA_ARGS__))
#define JS_INTERNAL_EVAL16(...) JS_INTERNAL_EVAL8(JS_INTERNAL_EVAL8(__VA_ARGS__))
#define JS_INTERNAL_EVAL8(...) JS_INTERNAL_EVAL4(JS_INTERNAL_EVAL4(__VA_ARGS__))
#define JS_INTERNAL_EVAL4(...) JS_INTERNAL_EVAL2(JS_INTERNAL_EVAL2(__VA_ARGS__))
#define JS_INTERNAL_EVAL2(...) JS_INTERNAL_EVAL1(JS_INTERNAL_EVAL1(__VA_ARGS__))
#define JS_INTERNAL_EVAL1(...) __VA_ARGS__

#define JS_INTERNAL_DEFER1(m) m JS_INTERNAL_EMPTY()
#define JS_INTERNAL_DEFER2(m) m JS_INTERNAL_EMPTY JS_INTERNAL_EMPTY()()

#define JS_INTERNAL_IS_PROBE(...) JS_INTERNAL_SECOND(__VA_ARGS__, 0, 0)
#define JS_INTERNAL_PROBE() ~, 1

#define JS_INTERNAL_CAT(a, b) a##b

#define JS_INTERNAL_NOT(x) JS_INTERNAL_IS_PROBE(JS_INTERNAL_CAT(JS_INTERNAL__NOT_, x))
#define JS_INTERNAL__NOT_0 JS_INTERNAL_PROBE()

#define JS_INTERNAL_BOOL(x) JS_INTERNAL_NOT(JS_INTERNAL_NOT(x))

#define JS_INTERNAL_IF_ELSE(condition) JS_INTERNAL__IF_ELSE(JS_INTERNAL_BOOL(condition))
#define JS_INTERNAL__IF_ELSE(condition) JS_INTERNAL_CAT(JS_INTERNAL__IF_, condition)

#define JS_INTERNAL__IF_1(...) __VA_ARGS__ JS_INTERNAL__IF_1_ELSE
#define JS_INTERNAL__IF_0(...) JS_INTERNAL__IF_0_ELSE

#define JS_INTERNAL__IF_1_ELSE(...)
#define JS_INTERNAL__IF_0_ELSE(...) __VA_ARGS__

#define JS_INTERNAL_HAS_MORE_THAN_ONE_ARGS(...)                                                                        \
  JS_INTERNAL_BOOL(JS_INTERNAL_SECOND(JS_INTERNAL__END_OF_ARGUMENTS_ __VA_ARGS__, 0, 0)())
#define JS_INTERNAL__END_OF_ARGUMENTS_() 0

#define JS_MEMBER(member) JS::makeMemberInfo(#member, &JS_OBJECT_T::member)
#define JS_MEMBER_ALIASES(member, ...)                                                                                 \
  JS_INTERNAL_EXPAND(JS::makeMemberInfo(#member, &JS_OBJECT_T::member, __VA_ARGS__))
#define JS_MEMBER_WITH_NAME(member, name) JS::makeMemberInfo(name, &JS_OBJECT_T::member)
#define JS_MEMBER_WITH_NAME_AND_ALIASES(member, name, ...) JS::makeMemberInfo(name, &JS_OBJECT_T::member, __VA_ARGS__)

#define JS_SUPER_CLASS(super) JS::makeSuperInfo<super>(#super)

#define JS_SUPER_CLASSES(...) JS::makeTuple(__VA_ARGS__)
#define JS_INTERNAL__MAP_MEMBER() JS_INTERNAL_MAP_MEMBER

#define JS_INTERNAL_MAKE_MEMBERS(...)                                                                                  \
  JS_INTERNAL_IF_ELSE(JS_INTERNAL_HAS_MORE_THAN_ONE_ARGS(__VA_ARGS__))                                                 \
  (JS_INTERNAL_EXPAND(JS_INTERNAL_EVAL(JS_INTERNAL_MAP_MEMBER(JS::makeMemberInfo, __VA_ARGS__))))(                     \
      JS_INTERNAL_MAP_APPLY_MEMBER(JS::makeMemberInfo, __VA_ARGS__)                                                    \
  )

#define JS_INTERNAL_MAP_APPLY_MEMBER(m, first) m(#first, &JS_OBJECT_T::first)

#define JS_INTERNAL_MAP_MEMBER(m, first, ...)                                                                          \
  JS_INTERNAL_MAP_APPLY_MEMBER(m, first)                                                                               \
  JS_INTERNAL_IF_ELSE(JS_INTERNAL_HAS_MORE_THAN_ONE_ARGS(__VA_ARGS__))                                                 \
  (, JS_INTERNAL_DEFER2(JS_INTERNAL__MAP_MEMBER)()(m, __VA_ARGS__))(, JS_INTERNAL_MAP_APPLY_MEMBER(m, __VA_ARGS__))

#define JS_INTERNAL_MAP_APPLY_SUPER(m, first) m<first>(#first)

#define JS_INTERNAL_MAP_SUPER(m, first, ...)                                                                           \
  JS_INTERNAL_MAP_APPLY_SUPER(m, first)                                                                                \
  JS_INTERNAL_IF_ELSE(JS_INTERNAL_HAS_MORE_THAN_ONE_ARGS(__VA_ARGS__))                                                 \
  (, JS_INTERNAL_DEFER2(JS_INTERNAL__MAP_SUPER)()(m, __VA_ARGS__))(, JS_INTERNAL_MAP_APPLY_SUPER(m, __VA_ARGS__))

#define JS_INTERNAL__MAP_SUPER() JS_INTERNAL_MAP_SUPER

#define JS_INTERNAL_MAKE_SUPER_CLASSES(...)                                                                            \
  JS_INTERNAL_IF_ELSE(JS_INTERNAL_HAS_MORE_THAN_ONE_ARGS(__VA_ARGS__))                                                 \
  (JS_INTERNAL_EXPAND(JS_INTERNAL_EVAL(JS_INTERNAL_MAP_SUPER(JS::makeSuperInfo, __VA_ARGS__))))(                       \
      JS_INTERNAL_MAP_APPLY_SUPER(JS::makeSuperInfo, __VA_ARGS__)                                                      \
  )

#define JS_SUPER(...) JS::makeTuple(JS_INTERNAL_EXPAND(JS_INTERNAL_MAKE_SUPER_CLASSES(__VA_ARGS__)))

#define JS_OBJECT_INTERNAL_IMPL(super_list, member_list)                                                               \
  template <typename JS_OBJECT_T> struct JsonStructBase {                                                              \
    using TT = decltype(member_list);                                                                                  \
    static inline constexpr const TT js_static_meta_data_info() { return member_list; }                                \
    static inline constexpr const decltype(super_list) js_static_meta_super_info() { return super_list; }              \
  }

#define JS_OBJECT_EXTERNAL_INTERNAL_IMPL(Type, super_list, member_list)                                                \
  namespace JS {                                                                                                       \
  namespace Internal {                                                                                                 \
  template <typename JS_OBJECT_T> struct JsonStructBaseDummy<Type, JS_OBJECT_T> {                                      \
    using TT = decltype(member_list);                                                                                  \
    static constexpr const TT js_static_meta_data_info() { return member_list; }                                       \
    static constexpr const decltype(super_list) js_static_meta_super_info() { return super_list; }                     \
  };                                                                                                                   \
  }                                                                                                                    \
  }

#define JS_OBJECT(...) JS_OBJECT_INTERNAL_IMPL(JS::makeTuple(), JS::makeTuple(__VA_ARGS__))
#define JS_OBJECT_WITH_SUPER(super_list, ...) JS_OBJECT_INTERNAL_IMPL(super_list, JS::makeTuple(__VA_ARGS__))

#define JS_OBJECT_EXTERNAL(Type, ...)                                                                                  \
  JS_OBJECT_EXTERNAL_INTERNAL_IMPL(Type, JS::makeTuple(), JS::makeTuple(__VA_ARGS__))
#define JS_OBJECT_EXTERNAL_WITH_SUPER(Type, super_list, ...)                                                           \
  JS_OBJECT_EXTERNAL_INTERNAL_IMPL(Type, super_list, JS::makeTuple(__VA_ARGS__))

#define JS_OBJ(...) JS_OBJECT_INTERNAL_IMPL(JS::makeTuple(), JS::makeTuple(JS_INTERNAL_MAKE_MEMBERS(__VA_ARGS__)))
#define JS_OBJ_SUPER(super_list, ...)                                                                                  \
  JS_OBJECT_INTERNAL_IMPL(super_list, JS::makeTuple(JS_INTERNAL_MAKE_MEMBERS(__VA_ARGS__)))

#define JS_OBJ_EXT(Type, ...)                                                                                          \
  JS_OBJECT_EXTERNAL_INTERNAL_IMPL(Type, JS::makeTuple(), JS::makeTuple(JS_INTERNAL_MAKE_MEMBERS(__VA_ARGS__)))
#define JS_OBJ_EXT_SUPER(Type, super_list, ...)                                                                        \
  JS_OBJECT_EXTERNAL_INTERNAL_IMPL(Type, super_list, JS::makeTuple(JS_INTERNAL_MAKE_MEMBERS(__VA_ARGS__)))

/*!
 * \private
 */
template <typename T, typename U, typename NAMETUPLE> struct MI {
  NAMETUPLE names;
  T U::* member;
  typedef T type;
};

namespace Internal {
template <typename T, typename U, typename NAMETUPLE> using MemberInfo = MI<T, U, NAMETUPLE>;

template <typename T> struct SuperInfo {
  constexpr explicit SuperInfo() : name() {}
  constexpr explicit SuperInfo(const DataRef& name) : name(name) {}
  const DataRef name;
  typedef T type;
};
} // namespace Internal

template <typename T, typename U, size_t NAME_SIZE, typename... Aliases>
constexpr auto makeMemberInfo(
    const char (&name)[NAME_SIZE], T U::* member, Aliases&... aliases
) -> MI<T, U, decltype(makeTuple(JS::Internal::makeStringLiteral(name), JS::Internal::makeStringLiteral(aliases)...))> {
  return {makeTuple(JS::Internal::makeStringLiteral(name), JS::Internal::makeStringLiteral(aliases)...), member};
}

template <typename T, size_t NAME_SIZE>
constexpr const Internal::SuperInfo<T> makeSuperInfo(const char (&name)[NAME_SIZE]) {
  return Internal::SuperInfo<T>(DataRef(name));
}

template <typename T, typename Enable = void> struct TypeHandler {
  static inline Error to(T& to_type, ParseContext& context);
  static inline void from(const T& from_type, Token& token, Serializer& serializer);
};

namespace Internal {
template <size_t STRINGSIZE>
inline bool compareDataRefWithStringLiteral(const StringLiteral<STRINGSIZE>& memberName, const DataRef& jsonName) {
  return jsonName.size == STRINGSIZE && memcmp(memberName.data, jsonName.data, STRINGSIZE) == 0;
}

template <typename NameTuple, size_t index> struct NameChecker {
  static bool compare(const NameTuple& tuple, const DataRef& name) {

    JS_IF_CONSTEXPR(index != NameTuple::size) {
      auto& stringLiteral = tuple.template get<NameTuple::size - index>();
      if (compareDataRefWithStringLiteral(stringLiteral, name)) {
        return true;
      }
    }
    return NameChecker<NameTuple, index - 1>::compare(tuple, name);
  }
};
template <typename NameTuple> struct NameChecker<NameTuple, 0> {
  static bool compare(const NameTuple& tuple, const DataRef& name) {
    JS_UNUSED(tuple);
    JS_UNUSED(name);
    return false;
  }
};

template <typename T, typename MI_T, typename MI_M, typename MI_NC>
inline Error unpackMember(
    T& to_type, const MemberInfo<MI_T, MI_M, MI_NC>& memberInfo, ParseContext& context, size_t index, bool primary,
    bool* assigned_members
) {
  if (primary) {
    if (compareDataRefWithStringLiteral(memberInfo.names.template get<0>(), context.token.name)) {
      assigned_members[index] = true;
      return TypeHandler<MI_T>::to(to_type.*memberInfo.member, context);
    }
  } else {
    if (NameChecker<MI_NC, MI_NC::size>::compare(memberInfo.names, context.token.name)) {
      assigned_members[index] = true;
      return TypeHandler<MI_T>::to(to_type.*memberInfo.member, context);
    }
  }
  return Error::MissingPropertyMember;
}

template <typename MI_T, typename MI_M, typename MI_NC>
inline Error verifyMember(
    const MemberInfo<MI_T, MI_M, MI_NC>& memberInfo, size_t index, bool* assigned_members, bool track_missing_members,
    std::vector<std::string>& missing_members, const char* super_name
) {
  if (assigned_members[index]) {
    return Error::NoError;
  }
  if (IsOptionalType<MI_T>::value) {
    return Error::NoError;
  }

  if (track_missing_members) {
    std::string to_push = strlen(super_name) ? std::string(super_name) + "::" : std::string();
    to_push += std::string(memberInfo.names.template get<0>().data, memberInfo.names.template get<0>().size);
    missing_members.push_back(to_push);
  }
  return Error::UnassignedRequiredMember;
}

template <typename T, typename MI_T, typename MI_M, typename MI_NC>
inline void serializeMember(
    const T& from_type, const MemberInfo<MI_T, MI_M, MI_NC>& memberInfo, Token& token, Serializer& serializer,
    const char* super_name
) {
  JS_UNUSED(super_name);
  token.name.data = memberInfo.names.template get<0>().data;
  token.name.size = memberInfo.names.template get<0>().size;
  token.name_type = Type::Ascii;

  TypeHandler<MI_T>::from(from_type.*memberInfo.member, token, serializer);
}

template <typename T, size_t PAGE, size_t INDEX> struct SuperClassHandler {
  static Error handleSuperClasses(T& to_type, ParseContext& context, bool primary, bool* assigned_members);
  static Error verifyMembers(
      bool* assigned_members, bool track_missing_members, std::vector<std::string>& missing_members
  );
  static constexpr size_t membersInSuperClasses();
  static void serializeMembers(const T& from_type, Token& token, Serializer& serializer);
};

template <typename T, size_t PAGE, size_t SIZE> struct StartSuperRecursion {
  static Error start(T& to_type, ParseContext& context, bool primary, bool* assigned) {
    return SuperClassHandler<T, PAGE, SIZE - 1>::handleSuperClasses(to_type, context, primary, assigned);
  }

  static Error verifyMembers(
      bool* assigned_members, bool track_missing_members, std::vector<std::string>& missing_members
  ) {
    return SuperClassHandler<T, PAGE, SIZE - 1>::verifyMembers(
        assigned_members, track_missing_members, missing_members
    );
  }

  static constexpr size_t membersInSuperClasses() {
    return SuperClassHandler<T, PAGE, SIZE - 1>::membersInSuperClasses();
  }

  static void serializeMembers(const T& from_type, Token& token, Serializer& serializer) {
    return SuperClassHandler<T, PAGE, SIZE - 1>::serializeMembers(from_type, token, serializer);
  }
};

template <typename T, size_t PAGE> constexpr size_t memberCount() {
  using Members = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_data_info());
  using SuperMeta = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
  return Members::size + StartSuperRecursion<T, PAGE + Members::size, SuperMeta::size>::membersInSuperClasses();
}

template <typename T, size_t PAGE> struct StartSuperRecursion<T, PAGE, 0> {
  static Error start(T& to_type, ParseContext& context, bool primary, bool* assigned) {
    JS_UNUSED(to_type);
    JS_UNUSED(context);
    JS_UNUSED(primary);
    JS_UNUSED(assigned);
    return Error::MissingPropertyMember;
  }

  static Error verifyMembers(
      bool* assigned_members, bool track_missing_members, std::vector<std::string>& missing_members
  ) {
    JS_UNUSED(assigned_members);
    JS_UNUSED(track_missing_members);
    JS_UNUSED(missing_members);
    return Error::NoError;
  }

  static constexpr size_t membersInSuperClasses() { return 0; }

  static void serializeMembers(const T& from_type, Token& token, Serializer& serializer) {
    JS_UNUSED(from_type);
    JS_UNUSED(token);
    JS_UNUSED(serializer);
  }
};

template <typename T, typename Members, size_t PAGE, size_t INDEX> struct MemberChecker {
  inline static Error unpackMembers(
      T& to_type, const Members& members, ParseContext& context, bool primary, bool* assigned_members
  ) {
    Error error =
        unpackMember(to_type, members.template get<INDEX>(), context, PAGE + INDEX, primary, assigned_members);
    if (error != Error::MissingPropertyMember) {
      return error;
    }

    return MemberChecker<T, Members, PAGE, INDEX - 1>::unpackMembers(
        to_type, members, context, primary, assigned_members
    );
  }

  inline static Error verifyMembers(
      const Members& members, bool* assigned_members, bool track_missing_members,
      std::vector<std::string>& missing_members, const char* super_name
  ) {
    Error memberError = verifyMember(
        members.template get<INDEX>(), PAGE + INDEX, assigned_members, track_missing_members, missing_members,
        super_name
    );
    Error error = MemberChecker<T, Members, PAGE, INDEX - 1>::verifyMembers(
        members, assigned_members, track_missing_members, missing_members, super_name
    );
    if (memberError != Error::NoError) {
      return memberError;
    }
    return error;
  }
  inline static void serializeMembers(
      const T& from_type, const Members& members, Token& token, Serializer& serializer, const char* super_name
  ) {
    serializeMember(from_type, members.template get<Members::size - INDEX - 1>(), token, serializer, super_name);
    MemberChecker<T, Members, PAGE, INDEX - 1>::serializeMembers(from_type, members, token, serializer, super_name);
  }
};

template <typename T, typename Members, size_t PAGE> struct MemberChecker<T, Members, PAGE, 0> {
  inline static Error unpackMembers(
      T& to_type, const Members& members, ParseContext& context, bool primary, bool* assigned_members
  ) {
    Error error = unpackMember(to_type, members.template get<0>(), context, PAGE, primary, assigned_members);
    if (error != Error::MissingPropertyMember) {
      return error;
    }

    using Super = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
    return StartSuperRecursion<T, PAGE + Members::size, Super::size>::start(
        to_type, context, primary, assigned_members
    );
  }

  inline static Error verifyMembers(
      const Members& members, bool* assigned_members, bool track_missing_members,
      std::vector<std::string>& missing_members, const char* super_name
  ) {
    Error memberError = verifyMember(
        members.template get<0>(), PAGE, assigned_members, track_missing_members, missing_members, super_name
    );
    using Super = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
    Error superError = StartSuperRecursion<T, PAGE + Members::size, Super::size>::verifyMembers(
        assigned_members, track_missing_members, missing_members
    );
    if (memberError !=
        Error::NoError) { //-V1051 memberError is correct, but we have to allways call supers verifyMembers first
      return memberError;
    }
    return superError;
  }

  inline static void serializeMembers(
      const T& from_type, const Members& members, Token& token, Serializer& serializer, const char* super_name
  ) {
    serializeMember(from_type, members.template get<Members::size - 1>(), token, serializer, super_name);
    using Super = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
    StartSuperRecursion<T, PAGE + Members::size, Super::size>::serializeMembers(from_type, token, serializer);
  }
};

template <typename T, size_t PAGE, size_t INDEX>
Error SuperClassHandler<T, PAGE, INDEX>::handleSuperClasses(
    T& to_type, ParseContext& context, bool primary, bool* assigned_members
) {
  using SuperMeta = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
  using Super = typename JS::TypeAt<INDEX, SuperMeta>::type::type;
  using Members = decltype(Internal::template JsonStructBaseDummy<Super, Super>::js_static_meta_data_info());
  auto members = Internal::template JsonStructBaseDummy<Super, Super>::js_static_meta_data_info();
  Error error = MemberChecker<Super, Members, PAGE, Members::size - 1>::unpackMembers(
      static_cast<Super&>(to_type), members, context, primary, assigned_members
  );
  if (error != Error::MissingPropertyMember) {
    return error;
  }
  return SuperClassHandler<T, PAGE + memberCount<Super, 0>(), INDEX - 1>::handleSuperClasses(
      to_type, context, primary, assigned_members
  );
}

template <typename T, size_t PAGE, size_t INDEX>
Error SuperClassHandler<T, PAGE, INDEX>::verifyMembers(
    bool* assigned_members, bool track_missing_members, std::vector<std::string>& missing_members
) {
  using SuperMeta = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
  using Super = typename TypeAt<INDEX, SuperMeta>::type::type;
  using Members = decltype(Internal::template JsonStructBaseDummy<Super, Super>::js_static_meta_data_info());
  auto members = Internal::template JsonStructBaseDummy<Super, Super>::js_static_meta_data_info();
  const char* super_name =
      Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info().template get<INDEX>().name.data;
  Error error = MemberChecker<Super, Members, PAGE, Members::size - 1>::verifyMembers(
      members, assigned_members, track_missing_members, missing_members, super_name
  );
  Error superError = SuperClassHandler<T, PAGE + memberCount<Super, 0>(), INDEX - 1>::verifyMembers(
      assigned_members, track_missing_members, missing_members
  );
  if (error != Error::NoError) {
    return error;
  }
  return superError;
}

template <typename T, size_t PAGE, size_t INDEX>
size_t constexpr SuperClassHandler<T, PAGE, INDEX>::membersInSuperClasses() {
  using SuperMeta = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
  using Super = typename TypeAt<INDEX, SuperMeta>::type::type;
  return memberCount<Super, PAGE>() +
         SuperClassHandler<T, PAGE + memberCount<Super, PAGE>(), INDEX - 1>::membersInSuperClasses();
}

template <typename T, size_t PAGE, size_t INDEX>
void SuperClassHandler<T, PAGE, INDEX>::serializeMembers(const T& from_type, Token& token, Serializer& serializer) {
  using SuperMeta = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
  using Super = typename TypeAt<INDEX, SuperMeta>::type::type;
  using Members = decltype(Internal::template JsonStructBaseDummy<Super, Super>::js_static_meta_data_info());
  auto members = Internal::template JsonStructBaseDummy<Super, Super>::js_static_meta_data_info();
  MemberChecker<Super, Members, PAGE, Members::size - 1>::serializeMembers(from_type, members, token, serializer, "");
  SuperClassHandler<T, PAGE + memberCount<Super, 0>(), INDEX - 1>::serializeMembers(from_type, token, serializer);
}

template <typename T, size_t PAGE> struct SuperClassHandler<T, PAGE, 0> {
  static Error handleSuperClasses(T& to_type, ParseContext& context, bool primary, bool* assigned_members) {
    using Meta = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
    using Super = typename TypeAt<0, Meta>::type::type;
    using Members = decltype(Internal::template JsonStructBaseDummy<Super, Super>::js_static_meta_data_info());
    auto members = Internal::template JsonStructBaseDummy<Super, Super>::js_static_meta_data_info();
    return MemberChecker<Super, Members, PAGE, Members::size - 1>::unpackMembers(
        static_cast<Super&>(to_type), members, context, primary, assigned_members
    );
  }
  static Error verifyMembers(
      bool* assigned_members, bool track_missing_members, std::vector<std::string>& missing_members
  ) {
    using SuperMeta = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
    using Super = typename TypeAt<0, SuperMeta>::type::type;
    using Members = decltype(Internal::template JsonStructBaseDummy<Super, Super>::js_static_meta_data_info());
    auto members = Internal::template JsonStructBaseDummy<Super, Super>::js_static_meta_data_info();
    const char* super_name =
        Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info().template get<0>().name.data;
    return MemberChecker<Super, Members, PAGE, Members::size - 1>::verifyMembers(
        members, assigned_members, track_missing_members, missing_members, super_name
    );
  }
  constexpr static size_t membersInSuperClasses() {
    using SuperMeta = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
    using Super = typename TypeAt<0, SuperMeta>::type::type;
    return memberCount<Super, PAGE>();
  }
  static void serializeMembers(const T& from_type, Token& token, Serializer& serializer) {
    using SuperMeta = decltype(Internal::template JsonStructBaseDummy<T, T>::js_static_meta_super_info());
    using Super = typename TypeAt<0, SuperMeta>::type::type;
    using Members = decltype(Internal::template JsonStructBaseDummy<Super, Super>::js_static_meta_data_info());
    auto members = Internal::JsonStructBaseDummy<Super, Super>::js_static_meta_data_info();
    MemberChecker<Super, Members, PAGE, Members::size - 1>::serializeMembers(from_type, members, token, serializer, "");
  }
};

static bool skipArrayOrObject(ParseContext& context) {
  assert(context.error == Error::NoError);
  Type start_type = context.token.value_type;
  Type end_type;
  if (context.token.value_type == Type::ObjectStart) {
    end_type = Type::ObjectEnd;
  } else if (context.token.value_type == Type::ArrayStart) {
    end_type = Type::ArrayEnd;
  } else {
    return false;
  }

  int depth = 1;
  while (depth > 0) {
    context.nextToken();
    if (context.error != Error::NoError) {
      return false;
    }
    if (context.token.value_type == start_type) {
      depth++;
    } else if (context.token.value_type == end_type) {
      depth--;
    }
  }

  return context.token.value_type == end_type && context.error == Error::NoError;
}
} // namespace Internal

template <typename T> JS_NODISCARD inline Error ParseContext::parseTo(T& to_type) {
  missing_members.reserve(10);
  unassigned_required_members.reserve(10);
  error = tokenizer.nextToken(token);
  if (error != JS::Error::NoError) {
    return error;
  }
  error = TypeHandler<T>::to(to_type, *this);
  if (error != JS::Error::NoError && tokenizer.errorContext().error == JS::Error::NoError) {
    tokenizer.updateErrorContext(error);
  }
  return error;
}

struct SerializerContext {
  SerializerContext(std::string& json_out_p) : serializer(), json_out(json_out_p), last_pos(0) {
    if (json_out.empty()) {
      json_out.resize(4096);
    }
    serializer.setBuffer(&json_out[0], json_out.size());
    serializer.setRequestBufferCallback([this](Serializer& serializer_p) {
      size_t end = this->json_out.size();
      this->json_out.resize(end * 2);
      serializer_p.setBuffer(&(this->json_out[0]) + end, end);
      this->last_pos = end;
    });
  }

  ~SerializerContext() { flush(); }

  template <typename T> void serialize(const T& type) {
    JS::Token token;
    JS::TypeHandler<T>::from(type, token, serializer);
    flush();
  }

  void flush() { json_out.resize(last_pos + serializer.currentBuffer().used); }

  Serializer serializer;
  std::string& json_out;
  size_t last_pos;
};

template <typename T> JS_NODISCARD std::string serializeStruct(const T& from_type) {
  std::string ret_string;
  SerializerContext serializeContext(ret_string);
  Token token;
  TypeHandler<T>::from(from_type, token, serializeContext.serializer);
  serializeContext.flush();
  return ret_string;
}

template <typename T> JS_NODISCARD std::string serializeStruct(const T& from_type, const SerializerOptions& options) {
  std::string ret_string;
  SerializerContext serializeContext(ret_string);
  serializeContext.serializer.setOptions(options);
  Token token;
  TypeHandler<T>::from(from_type, token, serializeContext.serializer);
  serializeContext.flush();
  return ret_string;
}

template <> struct TypeHandler<Error> {
  static inline Error to(Error& to_type, ParseContext& context) {
    (void) to_type;
    (void) context;
    //		if (context.token.value_type == JS::Type::Number) {
    //			int x;
    //			Error error = TypeHandler<int>::to(x, context);
    //			for (int i = 0; i < )
    //		}

    //        size_t level = 1;
    //        Error error = Error::NoError;
    //        while (error == JS::Error::NoError && level) {
    //            error = context.nextToken();
    //            if (context.token.value_type == Type::ObjectStart)
    //                level++;
    //            else if (context.token.value_type == Type::ObjectEnd)
    //                level--;
    //        }

    //        context.tokenizer.copyIncludingValue(context.token, to_type.data);

    return Error::NoError;
  }

  static inline void from(const Error& from_type, Token& token, Serializer& serializer) {
    token.value_type = JS::Type::String;
    if (from_type < JS::Error::UserDefinedErrors) {
      token.value = DataRef(Internal::error_strings[(int) from_type]);
    } else {
      token.value = DataRef("UserDefinedError");
    }
    serializer.write(token);
  }
};

struct CallFunctionExecutionState {
  explicit CallFunctionExecutionState(const std::string& name) : name(name), error(Error::NoError) {}
  std::string name;
  SilentString context;
  Error error;
  SilentString error_string;
  SilentVector<std::string> missing_members;
  SilentVector<std::string> unassigned_required_members;
  SilentVector<CallFunctionExecutionState> child_states;
  JS_OBJECT(
      JS_MEMBER(name), JS_MEMBER(context), JS_MEMBER(error), JS_MEMBER(error_string), JS_MEMBER(missing_members),
      JS_MEMBER(unassigned_required_members), JS_MEMBER(child_states)
  );
};

struct CallFunctionContext;

struct CallFunctionErrorContext {
  CallFunctionErrorContext(CallFunctionContext& context) : context(context) {}

  Error setError(Error error, const std::string& error_string);
  Error setError(const std::string& error_string) { return setError(Error::UserDefinedErrors, error_string); }
  Error getLatestError() const;

private:
  CallFunctionContext& context;
};

struct CallFunctionContext {
  CallFunctionContext(ParseContext& parser_context, Serializer& return_serializer)
      : parse_context(parser_context), return_serializer(return_serializer), error_context(*this) {}

  virtual ~CallFunctionContext() {}
  template <typename T> Error callFunctions(T& container);

  ParseContext& parse_context;
  Serializer& return_serializer;
  CallFunctionErrorContext error_context;
  std::vector<CallFunctionExecutionState> execution_list;
  std::string user_context;
  bool allow_missing = false;
  bool stop_execute_on_fail = false;
  void* user_handle = nullptr;

protected:
  virtual void beforeCallFunctions() {}
  virtual void afterCallFunctions() {}
};

inline Error CallFunctionErrorContext::setError(Error error, const std::string& errorString) {
  context.parse_context.error = error;
  if (context.execution_list.size()) {
    context.execution_list.back().error = error;
    context.execution_list.back().error_string.data = context.parse_context.tokenizer.makeErrorString();
  }
  context.parse_context.tokenizer.updateErrorContext(error, errorString);
  return error;
}

inline Error CallFunctionErrorContext::getLatestError() const { return context.parse_context.error; }

template <typename T, typename Ret, typename Arg, size_t NAME_COUNT, size_t TAKES_CONTEXT> struct FunctionInfo {
  typedef Ret (T::*Function)(Arg);
  typedef Ret returnType;
  DataRef name[NAME_COUNT];
  Function function;
};

/// \private
template <typename T, typename Ret, typename Arg, size_t NAME_COUNT> struct FunctionInfo<T, Ret, Arg, NAME_COUNT, 1> {
  typedef Ret (T::*Function)(Arg, CallFunctionErrorContext&);
  typedef Ret returnType;
  DataRef name[NAME_COUNT];
  Function function;
};

/// \private
template <typename T, typename Ret, typename Arg, size_t NAME_COUNT> struct FunctionInfo<T, Ret, Arg, NAME_COUNT, 2> {
  typedef Ret (T::*Function)(Arg, CallFunctionContext&);
  typedef Ret returnType;
  DataRef name[NAME_COUNT];
  Function function;
};

/// \private
template <typename T, typename Ret, size_t NAME_COUNT, size_t TAKES_CONTEXT>
struct FunctionInfo<T, Ret, void, NAME_COUNT, TAKES_CONTEXT> {
  typedef Ret (T::*Function)(void);
  typedef Ret returnType;
  DataRef name[NAME_COUNT];
  Function function;
};

/// \private
template <typename T, typename Ret, size_t NAME_COUNT> struct FunctionInfo<T, Ret, void, NAME_COUNT, 1> {
  typedef Ret (T::*Function)(CallFunctionErrorContext&);
  typedef Ret returnType;
  DataRef name[NAME_COUNT];
  Function function;
};

/// \private
template <typename T, typename Ret, size_t NAME_COUNT> struct FunctionInfo<T, Ret, void, NAME_COUNT, 2> {
  typedef Ret (T::*Function)(CallFunctionContext&);
  typedef Ret returnType;
  DataRef name[NAME_COUNT];
  Function function;
};

/// \private
template <typename T, typename Ret, typename Arg, size_t NAME_SIZE, typename... Aliases>
constexpr FunctionInfo<T, Ret, Arg, sizeof...(Aliases) + 1, 0> makeFunctionInfo(
    const char (&name)[NAME_SIZE], Ret (T::*function)(Arg), Aliases... aliases
) {
  return {{DataRef(name), DataRef(aliases)...}, function};
}

/// \private
template <typename T, typename Ret, typename Arg, size_t NAME_SIZE, typename... Aliases>
constexpr FunctionInfo<T, Ret, Arg, sizeof...(Aliases) + 1, 1> makeFunctionInfo(
    const char (&name)[NAME_SIZE], Ret (T::*function)(Arg, CallFunctionErrorContext&), Aliases... aliases
) {
  return {{DataRef(name), DataRef(aliases)...}, function};
}

/// \private
template <typename T, typename Ret, typename Arg, size_t NAME_SIZE, typename... Aliases>
constexpr FunctionInfo<T, Ret, Arg, sizeof...(Aliases) + 1, 2> makeFunctionInfo(
    const char (&name)[NAME_SIZE], Ret (T::*function)(Arg, CallFunctionContext&), Aliases... aliases
) {
  return {{DataRef(name), DataRef(aliases)...}, function};
}

/// \private
template <typename T, typename Ret, size_t NAME_SIZE, typename... Aliases>
constexpr FunctionInfo<T, Ret, void, sizeof...(Aliases) + 1, 0> makeFunctionInfo(
    const char (&name)[NAME_SIZE], Ret (T::*function)(void), Aliases... aliases
) {
  return {{DataRef(name), DataRef(aliases)...}, function};
}

/// \private
template <typename T, typename Ret, size_t NAME_SIZE, typename... Aliases>
constexpr FunctionInfo<T, Ret, void, sizeof...(Aliases) + 1, 1> makeFunctionInfo(
    const char (&name)[NAME_SIZE], Ret (T::*function)(CallFunctionErrorContext&), Aliases... aliases
) {
  return {{DataRef(name), DataRef(aliases)...}, function};
}

/// \private
template <typename T, typename Ret, size_t NAME_SIZE, typename... Aliases>
constexpr FunctionInfo<T, Ret, void, sizeof...(Aliases) + 1, 2> makeFunctionInfo(
    const char (&name)[NAME_SIZE], Ret (T::*function)(CallFunctionContext&), Aliases... aliases
) {
  return {{DataRef(name), DataRef(aliases)...}, function};
}

namespace Internal {
template <typename T> struct HasJsonStructFunctionContainer {
  typedef char yes[1];
  typedef char no[2];

  template <typename C> static constexpr yes& test_in_base(typename C::template JsonStructFunctionContainer<C>*);

  template <typename> static constexpr no& test_in_base(...);
};

template <typename JS_BASE_CONTAINER_STRUCT_T, typename JS_CONTAINER_STRUCT_T> struct JsonStructFunctionContainerDummy {
  using TT = decltype(JS_CONTAINER_STRUCT_T::template JsonStructFunctionContainer<
                      JS_CONTAINER_STRUCT_T>::js_static_meta_functions_info());
  using ST = decltype(JS_CONTAINER_STRUCT_T::template JsonStructFunctionContainer<
                      JS_CONTAINER_STRUCT_T>::js_static_meta_super_info());
  static const TT& js_static_meta_functions_info() {
    return JS_CONTAINER_STRUCT_T::template JsonStructFunctionContainer<
        JS_CONTAINER_STRUCT_T>::js_static_meta_functions_info();
  }

  static const ST js_static_meta_super_info() {
    return JS_CONTAINER_STRUCT_T::template JsonStructFunctionContainer<
        JS_CONTAINER_STRUCT_T>::js_static_meta_super_info();
  }
};

} // namespace Internal

#define JS_FUNCTION(name) JS::makeFunctionInfo(#name, &JS_CONTAINER_STRUCT_T::name)
#define JS_FUNCTION_ALIASES(name, ...) JS::makeFunctionInfo(#name, &JS_CONTAINER_STRUCT_T::name, __VA_ARGS__)
#define JS_FUNCTION_WITH_NAME(member, name) JS::makeFunctionInfo(name, &JS_CONTAINER_STRUCT_T::member)
#define JS_FUNCTION_WITH_NAME_ALIASES(member, name, ...)                                                               \
  JS::makeFunctionInfo(name, &JS_CONTAINER_STRUCT_T::member, __VA_ARGS__)

#define JS_INTERNAL_MAP_APPLY_FUNCTION(m, first) m(#first, &JS_CONTAINER_STRUCT_T::first)

#define JS_INTERNAL_MAP_FUNCTION(m, first, ...)                                                                        \
  JS_INTERNAL_MAP_APPLY_FUNCTION(m, first)                                                                             \
  JS_INTERNAL_IF_ELSE(JS_INTERNAL_HAS_MORE_THAN_ONE_ARGS(__VA_ARGS__))                                                 \
  (, JS_INTERNAL_DEFER2(JS_INTERNAL__MAP_FUNCTION)()(m, __VA_ARGS__))(, JS_INTERNAL_MAP_APPLY_FUNCTION(m, __VA_ARGS__))

#define JS_INTERNAL__MAP_FUNCTION() JS_INTERNAL_MAP_FUNCTION

#define JS_INTERNAL_MAKE_FUNCTIONS(...)                                                                                \
  JS_INTERNAL_IF_ELSE(JS_INTERNAL_HAS_MORE_THAN_ONE_ARGS(__VA_ARGS__))                                                 \
  (JS_INTERNAL_EXPAND(JS_INTERNAL_EVAL(JS_INTERNAL_MAP_FUNCTION(JS::makeFunctionInfo, __VA_ARGS__))))(                 \
      JS_INTERNAL_MAP_APPLY_FUNCTION(JS::makeFunctionInfo, __VA_ARGS__)                                                \
  )

#define JS_FUNCTION_CONTAINER_INTERNAL_IMPL(super_list, function_list)                                                 \
  template <typename JS_CONTAINER_STRUCT_T> struct JsonStructFunctionContainer {                                       \
    using TT = decltype(function_list);                                                                                \
    static const TT& js_static_meta_functions_info() {                                                                 \
      static auto ret = function_list;                                                                                 \
      return ret;                                                                                                      \
    }                                                                                                                  \
    static const decltype(super_list) js_static_meta_super_info() { return super_list; }                               \
  }

#define JS_FUNCTION_CONTAINER_EXTERNAL_INTERNAL_IMPL(Type, super_list, function_list)                                  \
  namespace JS {                                                                                                       \
  namespace Internal {                                                                                                 \
  template <typename JS_CONTAINER_STRUCT_T> struct JsonStructFunctionContainerDummy<Type, JS_CONTAINER_STRUCT_T> {     \
    using TT = decltype(function_list);                                                                                \
    static const TT& js_static_meta_functions_info() {                                                                 \
      static auto ret = function_list;                                                                                 \
      return ret;                                                                                                      \
    }                                                                                                                  \
    static const decltype(super_list) js_static_meta_super_info() { return super_list; }                               \
  };                                                                                                                   \
  }                                                                                                                    \
  }

#define JS_FUNC_OBJ(...)                                                                                               \
  JS_FUNCTION_CONTAINER_INTERNAL_IMPL(JS::makeTuple(), JS::makeTuple(JS_INTERNAL_MAKE_FUNCTIONS(__VA_ARGS__)))
#define JS_FUNCTION_CONTAINER(...) JS_FUNCTION_CONTAINER_INTERNAL_IMPL(JS::makeTuple(), JS::makeTuple(__VA_ARGS__))
#define JS_FUNC_OBJ_SUPER(super_list, ...)                                                                             \
  JS_FUNCTION_CONTAINER_INTERNAL_IMPL(super_list, JS::makeTuple(JS_INTERNAL_MAKE_FUNCTIONS(__VA_ARGS__)))
#define JS_FUNCTION_CONTAINER_WITH_SUPER(super_list, ...)                                                              \
  JS_FUNCTION_CONTAINER_INTERNAL_IMPL(super_list, JS::makeTuple(__VA_ARGS__))
#define JS_FUNCTION_CONTAINER_WITH_SUPER_WITHOUT_MEMBERS(super_list)                                                   \
  JS_FUNCTION_CONTAINER_INTERNAL_IMPL(super_list, JS::makeTuple())

#define JS_FUNC_OBJ_EXTERNAL(Type, ...)                                                                                \
  JS_FUNCTION_CONTAINER_EXTERNAL_INTERNAL_IMPL(                                                                        \
      Type, JS::makeTuple(), JS::makeTuple(JS_INTERNAL_MAKE_FUNCTIONS(__VA_ARGS__))                                    \
  )
#define JS_FUNCTION_CONTAINER_EXTERNAL(Type, ...)                                                                      \
  JS_FUNCTION_CONTAINER_EXTERNAL_INTERNAL_IMPL(Type, JS::makeTuple(), JS::makeTuple(__VA_ARGS__))
#define JS_FUNC_OBJ_EXTERNAL_SUPER(Type, super_list, ...)                                                              \
  JS_FUNCTION_CONTAINER_EXTERNAL_INTERNAL_IMPL(Type, super_list, JS::makeTuple(JS_INTERNAL_MAKE_FUNCTIONS(__VA_ARGS__)))
#define JS_FUNCTION_CONTAINER_EXTERNAL_WITH_SUPER(Type, super_list, ...)                                               \
  JS_FUNCTION_CONTAINER_EXTERNAL_INTERNAL_IMPL(Type, super_list, JS::makeTuple(__VA_ARGS__))

#define JS_FUNCTION_CONTAINER_EXTERNAL_WITH_SUPER_WITHOUT_MEMBERS(Type, super_list)                                    \
  JS_FUNCTION_CONTAINER_EXTERNAL_INTERNAL_IMPL(Type, super_list, JS::makeTuple())

#if !defined(__clang__) && defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Warray-bounds"
#pragma GCC diagnostic ignored "-Wstringop-overflow"
#endif

namespace Internal {
template <typename T, typename U, typename Ret, typename Arg, size_t NAME_COUNT, size_t TAKES_CONTEXT>
struct FunctionCaller {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, Ret, Arg, NAME_COUNT, TAKES_CONTEXT>& functionInfo, CallFunctionContext& context
  ) {
    typedef typename std::remove_reference<Arg>::type NonRefArg;
    typedef typename std::remove_cv<NonRefArg>::type PureArg;
    PureArg arg;
    context.parse_context.error = TypeHandler<PureArg>::to(arg, context.parse_context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }

    Token token;
    TypeHandler<Ret>::from((container.*functionInfo.function)(arg), token, context.return_serializer);
    return Error::NoError;
  }
};

template <typename T, typename U, typename Ret, typename Arg, size_t NAME_COUNT>
struct FunctionCaller<T, U, Ret, Arg, NAME_COUNT, 1> {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, Ret, Arg, NAME_COUNT, 1>& functionInfo, CallFunctionContext& context
  ) {
    typedef typename std::remove_reference<Arg>::type NonRefArg;
    typedef typename std::remove_cv<NonRefArg>::type PureArg;
    PureArg arg;
    context.parse_context.error = TypeHandler<PureArg>::to(arg, context.parse_context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }

    Token token;
    Ret ret = (container.*functionInfo.function)(arg, context.error_context);
    if (context.execution_list.back().error == Error::NoError) {
      TypeHandler<Ret>::from(ret, token, context.return_serializer);
    }
    return context.execution_list.back().error;
  }
};

template <typename T, typename U, typename Ret, typename Arg, size_t NAME_COUNT>
struct FunctionCaller<T, U, Ret, Arg, NAME_COUNT, 2> {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, Ret, Arg, NAME_COUNT, 2>& functionInfo, CallFunctionContext& context
  ) {
    typedef typename std::remove_reference<Arg>::type NonRefArg;
    typedef typename std::remove_cv<NonRefArg>::type PureArg;
    PureArg arg;
    context.parse_context.error = TypeHandler<PureArg>::to(arg, context.parse_context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }

    Token token;
    Ret ret = (container.*functionInfo.function)(arg, context);
    if (context.execution_list.back().error == Error::NoError) {
      TypeHandler<Ret>::from(ret, token, context.return_serializer);
    }
    return context.execution_list.back().error;
  }
};

template <typename T, typename U, typename Arg, size_t NAME_COUNT, size_t TAKES_CONTEXT>
struct FunctionCaller<T, U, void, Arg, NAME_COUNT, TAKES_CONTEXT> {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, void, Arg, NAME_COUNT, TAKES_CONTEXT>& functionInfo, CallFunctionContext& context
  ) {
    typedef typename std::remove_reference<Arg>::type NonRefArg;
    typedef typename std::remove_cv<NonRefArg>::type PureArg;
    PureArg arg;
    context.parse_context.error = TypeHandler<PureArg>::to(arg, context.parse_context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }

    (container.*functionInfo.function)(arg);
    return Error::NoError;
  }
};

template <typename T, typename U, typename Arg, size_t NAME_COUNT>
struct FunctionCaller<T, U, void, Arg, NAME_COUNT, 1> {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, void, Arg, NAME_COUNT, 1>& functionInfo, CallFunctionContext& context
  ) {
    typedef typename std::remove_reference<Arg>::type NonRefArg;
    typedef typename std::remove_cv<NonRefArg>::type PureArg;
    PureArg arg;
    context.parse_context.error = TypeHandler<PureArg>::to(arg, context.parse_context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }

    (container.*functionInfo.function)(arg, context.error_context);
    return context.execution_list.back().error;
  }
};

template <typename T, typename U, typename Arg, size_t NAME_COUNT>
struct FunctionCaller<T, U, void, Arg, NAME_COUNT, 2> {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, void, Arg, NAME_COUNT, 2>& functionInfo, CallFunctionContext& context
  ) {
    typedef typename std::remove_reference<Arg>::type NonRefArg;
    typedef typename std::remove_cv<NonRefArg>::type PureArg;
    PureArg arg;
    context.parse_context.error = TypeHandler<PureArg>::to(arg, context.parse_context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }

    (container.*functionInfo.function)(arg, context);
    return context.execution_list.back().error;
  }
};

static inline void checkValidVoidParameter(CallFunctionContext& context) {
  if (context.parse_context.token.value_type != Type::Null &&
      context.parse_context.token.value_type != Type::ArrayStart &&
      context.parse_context.token.value_type != Type::ObjectStart &&
      context.parse_context.token.value_type != Type::Bool) {
    // what to do
    fprintf(stderr, "Passing data arguments to a void function\n");
  }
  skipArrayOrObject(context.parse_context);
}

template <typename T, typename U, typename Ret, size_t NAME_COUNT, size_t TAKES_CONTEXT>
struct FunctionCaller<T, U, Ret, void, NAME_COUNT, TAKES_CONTEXT> {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, Ret, void, NAME_COUNT, TAKES_CONTEXT>& functionInfo, CallFunctionContext& context
  ) {
    checkValidVoidParameter(context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }
    Token token;
    TypeHandler<Ret>::from((container.*functionInfo.function)(), token, context.return_serializer);
    return Error::NoError;
  }
};

template <typename T, typename U, typename Ret, size_t NAME_COUNT>
struct FunctionCaller<T, U, Ret, void, NAME_COUNT, 1> {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, Ret, void, NAME_COUNT, 1>& functionInfo, CallFunctionContext& context
  ) {
    checkValidVoidParameter(context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }

    Token token;
    Ret ret = (container.*functionInfo.function)(context.error_context);
    if (context.execution_list.back().error == Error::NoError) {
      TypeHandler<Ret>::from(ret, token, context.return_serializer);
    }
    return context.execution_list.back().error;
  }
};

template <typename T, typename U, typename Ret, size_t NAME_COUNT>
struct FunctionCaller<T, U, Ret, void, NAME_COUNT, 2> {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, Ret, void, NAME_COUNT, 2>& functionInfo, CallFunctionContext& context
  ) {
    checkValidVoidParameter(context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }

    Token token;
    Ret ret = (container.*functionInfo.function)(context);
    if (context.execution_list.back().error == Error::NoError) {
      TypeHandler<Ret>::from(ret, token, context.return_serializer);
    }
    return context.execution_list.back().error;
  }
};

template <typename T, typename U, size_t NAME_COUNT, size_t TAKES_CONTEXT>
struct FunctionCaller<T, U, void, void, NAME_COUNT, TAKES_CONTEXT> {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, void, void, NAME_COUNT, TAKES_CONTEXT>& functionInfo, CallFunctionContext& context
  ) {
    checkValidVoidParameter(context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }

    (container.*functionInfo.function)();
    return Error::NoError;
  }
};

template <typename T, typename U, size_t NAME_COUNT> struct FunctionCaller<T, U, void, void, NAME_COUNT, 1> {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, void, void, NAME_COUNT, 1>& functionInfo, CallFunctionContext& context
  ) {
    checkValidVoidParameter(context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }

    (container.*functionInfo.function)(context.error_context);
    return context.execution_list.back().error;
  }
};

template <typename T, typename U, size_t NAME_COUNT> struct FunctionCaller<T, U, void, void, NAME_COUNT, 2> {
  static Error callFunctionAndSerializeReturn(
      T& container, FunctionInfo<U, void, void, NAME_COUNT, 2>& functionInfo, CallFunctionContext& context
  ) {
    checkValidVoidParameter(context);
    if (context.parse_context.error != Error::NoError) {
      return context.parse_context.error;
    }

    (container.*functionInfo.function)(context);
    return context.execution_list.back().error;
  }
};
} // namespace Internal

#if !defined(__clang__) && defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

template <typename T, typename U, typename Ret, typename Arg, size_t NAME_COUNT, size_t TAKES_CONTEXT>
Error matchAndCallFunction(
    T& container, CallFunctionContext& context, FunctionInfo<U, Ret, Arg, NAME_COUNT, TAKES_CONTEXT>& functionInfo,
    bool primary
) {
  if (primary && context.parse_context.token.name.size == functionInfo.name[0].size &&
      memcmp(functionInfo.name[0].data, context.parse_context.token.name.data, functionInfo.name[0].size) == 0) {
    return Internal::FunctionCaller<T, U, Ret, Arg, NAME_COUNT, TAKES_CONTEXT>::callFunctionAndSerializeReturn(
        container, functionInfo, context
    );
  } else if (!primary) {
    for (size_t i = 1; i < NAME_COUNT; i++) {
      if (context.parse_context.token.name.size == functionInfo.name[i].size &&
          memcmp(functionInfo.name[i].data, context.parse_context.token.name.data, functionInfo.name[i].size) == 0) {
        return Internal::FunctionCaller<T, U, Ret, Arg, NAME_COUNT, TAKES_CONTEXT>::callFunctionAndSerializeReturn(
            container, functionInfo, context
        );
      }
    }
  }
  return Error::MissingFunction;
}

namespace Internal {
template <typename T, size_t INDEX> struct FunctionalSuperRecursion {
  static Error callFunction(T& container, CallFunctionContext& context, bool primary);
};

template <typename T, size_t SIZE> struct StartFunctionalSuperRecursion {
  static Error callFunction(T& container, CallFunctionContext& context, bool primary) {
    return FunctionalSuperRecursion<T, SIZE - 1>::callFunction(container, context, primary);
  }
};
template <typename T> struct StartFunctionalSuperRecursion<T, 0> {
  static Error callFunction(T& container, CallFunctionContext& context, bool primary) {
    JS_UNUSED(container);
    JS_UNUSED(context);
    JS_UNUSED(primary);
    return Error::MissingFunction;
  }
};

template <typename T, typename Functions, size_t INDEX> struct FunctionObjectTraverser {
  static Error call(T& container, CallFunctionContext& context, Functions& functions, bool primary) {
    auto function = functions.template get<INDEX>();
    Error error = matchAndCallFunction(container, context, function, primary);
    if (error == Error::NoError) {
      return Error::NoError;
    }
    if (error != Error::MissingFunction) {
      return context.parse_context.error;
    }
    return FunctionObjectTraverser<T, Functions, INDEX - 1>::call(container, context, functions, primary);
  }
};

template <typename T, typename Functions> struct FunctionObjectTraverser<T, Functions, 0> {
  static Error call(T& container, CallFunctionContext& context, Functions& functions, bool primary) {
    auto function = functions.template get<0>();
    Error error = matchAndCallFunction(container, context, function, primary);
    if (error == Error::NoError) {
      return Error::NoError;
    }
    if (error != Error::MissingFunction) {
      return error;
    }
    using SuperMeta = decltype(Internal::template JsonStructFunctionContainerDummy<T, T>::js_static_meta_super_info());
    return StartFunctionalSuperRecursion<T, SuperMeta::size>::callFunction(container, context, primary);
  }
};

template <typename T, typename Functions> struct FunctionObjectTraverser<T, Functions, size_t(-1)> {
  static Error call(T& container, CallFunctionContext& context, Functions&, bool primary) {
    using SuperMeta = decltype(Internal::template JsonStructFunctionContainerDummy<T, T>::js_static_meta_super_info());
    return StartFunctionalSuperRecursion<T, SuperMeta::size>::callFunction(container, context, primary);
  }
};

static inline void add_error(CallFunctionExecutionState& executionState, ParseContext& context) {
  executionState.error = context.error;
  if (context.error != Error::NoError) {
    if (context.tokenizer.errorContext().custom_message.empty()) {
      context.tokenizer.updateErrorContext(context.error);
    }
    executionState.error_string.data = context.tokenizer.makeErrorString();
  }
  if (context.missing_members.size()) {
    std::swap(executionState.missing_members.data, context.missing_members);
  }
  if (context.unassigned_required_members.size()) {
    std::swap(executionState.unassigned_required_members.data, context.unassigned_required_members);
  }
}
} // namespace Internal

namespace Internal {
typedef void (CallFunctionContext::*AfterCallFunction)();

struct RAICallFunctionOnExit {
  RAICallFunctionOnExit(CallFunctionContext& context, AfterCallFunction after) : context(context), after(after) {}
  ~RAICallFunctionOnExit() { (context.*after)(); }
  CallFunctionContext& context;
  AfterCallFunction after;
};
} // namespace Internal

namespace Internal {
struct ArrayEndWriter {
  ArrayEndWriter(Serializer& serializer, Token& token) : serializer(serializer), token(token) {}

  ~ArrayEndWriter() {
    token.value_type = Type::ArrayEnd;
    token.value = DataRef("]");
    serializer.write(token);
  }

  Serializer& serializer;
  Token& token;
};
} // namespace Internal

template <typename T> inline Error CallFunctionContext::callFunctions(T& container) {
  beforeCallFunctions();
  Internal::RAICallFunctionOnExit callOnExit(*this, &CallFunctionContext::afterCallFunctions);
  JS::Error error = parse_context.nextToken();
  if (error != JS::Error::NoError) {
    return error;
  }
  if (parse_context.token.value_type != JS::Type::ObjectStart) {
    return error_context.setError(Error::ExpectedObjectStart, "Can only call functions on objects with members");
  }
  error = parse_context.nextToken();
  if (error != JS::Error::NoError) {
    return error;
  }
  Token token;
  token.value_type = Type::ArrayStart;
  token.value = DataRef("[");
  Internal::ArrayEndWriter endWriter(return_serializer, token);
  return_serializer.write(token);
  auto& functions = Internal::JsonStructFunctionContainerDummy<T, T>::js_static_meta_functions_info();
  using FunctionsType = typename std::remove_reference<decltype(functions)>::type;
  while (parse_context.token.value_type != JS::Type::ObjectEnd) {
    parse_context.tokenizer.pushScope(parse_context.token.value_type);
    execution_list.push_back(
        CallFunctionExecutionState(std::string(parse_context.token.name.data, parse_context.token.name.size))
    );
    execution_list.back().context.data = user_context;
    error = Internal::FunctionObjectTraverser<T, FunctionsType, FunctionsType::size - 1>::call(
        container, *this, functions, true
    );
    if (error == Error::MissingFunction) {
      error = Internal::FunctionObjectTraverser<T, FunctionsType, FunctionsType::size - 1>::call(
          container, *this, functions, false
      );
    }
    if (error != Error::NoError) {
      assert(error == parse_context.error || parse_context.error == Error::NoError);
      parse_context.error = error;
    }
    Internal::add_error(execution_list.back(), parse_context);
    parse_context.tokenizer.goToEndOfScope(parse_context.token);
    parse_context.tokenizer.popScope();
    if (error == Error::MissingFunction && allow_missing) {
      error = Error::NoError;
    }
    if (stop_execute_on_fail && error != Error::NoError) {
      return error;
    }

    error = parse_context.nextToken();
    if (error != JS::Error::NoError) {
      return error;
    }
  }

  return Error::NoError;
}

struct DefaultCallFunctionContext : public CallFunctionContext {
  DefaultCallFunctionContext(std::string& json_out)
      : CallFunctionContext(
            p_context, s_context.serializer
        ) //-V1050 The super class only store the reference so we don't mind its not initialized
        ,
        s_context(json_out) {}

  DefaultCallFunctionContext(const char* data, size_t size, std::string& json_out)
      : CallFunctionContext(
            p_context, s_context.serializer
        ) //-V1050 The super class only store the reference so we don't mind its not initialized
        ,
        p_context(data, size), s_context(json_out) {}

  template <size_t SIZE>
  DefaultCallFunctionContext(const char (&data)[SIZE], std::string& json_out)
      : CallFunctionContext(p_context, s_context.serializer), p_context(data), s_context(json_out) {}

  ParseContext p_context;
  SerializerContext s_context;

protected:
  void afterCallFunctions() { s_context.flush(); }
};
namespace Internal {
template <typename T, size_t INDEX>
Error FunctionalSuperRecursion<T, INDEX>::callFunction(T& container, CallFunctionContext& context, bool primary) {
  using SuperMeta = decltype(Internal::template JsonStructFunctionContainerDummy<T, T>::js_static_meta_super_info());
  using Super = typename TypeAt<INDEX, SuperMeta>::type::type;
  auto& functions = Internal::template JsonStructFunctionContainerDummy<Super, Super>::js_static_meta_functions_info();
  using FunctionsType = typename std::remove_reference<decltype(functions)>::type;
  Error error = FunctionObjectTraverser<Super, FunctionsType, FunctionsType::size - 1>::call(
      container, context, functions, primary
  );
  if (error != Error::MissingFunction) {
    return error;
  }

  return FunctionalSuperRecursion<T, INDEX - 1>::callFunction(container, context, primary);
}

template <typename T> struct FunctionalSuperRecursion<T, 0> {
  static Error callFunction(T& container, CallFunctionContext& context, bool primary) {
    using SuperMeta = decltype(Internal::template JsonStructFunctionContainerDummy<T, T>::js_static_meta_super_info());
    using Super = typename TypeAt<0, SuperMeta>::type::type;
    auto& functions =
        Internal::template JsonStructFunctionContainerDummy<Super, Super>::js_static_meta_functions_info();
    using FunctionsType = typename std::remove_reference<decltype(functions)>::type;
    return FunctionObjectTraverser<Super, FunctionsType, FunctionsType::size - 1>::call(
        container, context, functions, primary
    );
  }
};
} // namespace Internal
namespace Internal {
enum class ParseEnumStringState { FindingNameStart, FindingNameEnd, FindingSeperator };
template <size_t N> void populateEnumNames(std::vector<DataRef>& names, const char (&data)[N]) {
  size_t name_starts_at = 0;
  ParseEnumStringState state = ParseEnumStringState::FindingNameStart;
  for (size_t i = 0; i < N; i++) {
    char c = data[i];
    assert(c != '=');
    switch (state) {
    case ParseEnumStringState::FindingNameStart:
      if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
        name_starts_at = i;
        state = ParseEnumStringState::FindingNameEnd;
      }
      break;
    case ParseEnumStringState::FindingNameEnd:
      if (c == '\0' || c == '\t' || c == '\n' || c == '\r' || c == ' ' || c == ',') {
        names.push_back(DataRef(data + name_starts_at, i - name_starts_at));
        state = c == ',' ? ParseEnumStringState::FindingNameStart : ParseEnumStringState::FindingSeperator;
      }
      break;
    case ParseEnumStringState::FindingSeperator:
      if (c == ',') {
        state = ParseEnumStringState::FindingNameStart;
      }
      break;
    }
  }
}
} // namespace Internal
} // namespace JS

#define JS_ENUM(name, ...)                                                                                             \
  enum class name { __VA_ARGS__ };                                                                                     \
  struct js_##name##_string_struct {                                                                                   \
    template <size_t N> explicit js_##name##_string_struct(const char (&data)[N]) {                                    \
      JS::Internal::populateEnumNames(_strings, data);                                                                 \
    }                                                                                                                  \
    std::vector<JS::DataRef> _strings;                                                                                 \
                                                                                                                       \
    static const std::vector<JS::DataRef>& strings() {                                                                 \
      static js_##name##_string_struct ret(#__VA_ARGS__);                                                              \
      return ret._strings;                                                                                             \
    }                                                                                                                  \
  };

#define JS_ENUM_DECLARE_STRING_PARSER(name)                                                                            \
  namespace JS {                                                                                                       \
  template <> struct TypeHandler<name> {                                                                               \
    static inline Error to(name& to_type, ParseContext& context) {                                                     \
      return Internal::EnumHandler<name, js_##name##_string_struct>::to(to_type, context);                             \
    }                                                                                                                  \
    static inline void from(const name& from_type, Token& token, Serializer& serializer) {                             \
      return Internal::EnumHandler<name, js_##name##_string_struct>::from(from_type, token, serializer);               \
    }                                                                                                                  \
  };                                                                                                                   \
  }

#define JS_ENUM_NAMESPACE_DECLARE_STRING_PARSER(ns, name)                                                              \
  namespace JS {                                                                                                       \
  template <> struct TypeHandler<ns::name> {                                                                           \
    static inline Error to(ns::name& to_type, ParseContext& context) {                                                 \
      return Internal::EnumHandler<ns::name, ns::js_##name##_string_struct>::to(to_type, context);                     \
    }                                                                                                                  \
    static inline void from(const ns::name& from_type, Token& token, Serializer& serializer) {                         \
      return Internal::EnumHandler<ns::name, ns::js_##name##_string_struct>::from(from_type, token, serializer);       \
    }                                                                                                                  \
  };                                                                                                                   \
  }

#define JS_ENUM_DECLARE_VALUE_PARSER(name)                                                                             \
  namespace JS {                                                                                                       \
  template <> struct TypeHandler<name> {                                                                               \
    typedef std::underlying_type<name>::type utype;                                                                    \
    static inline Error to(name& to_type, ParseContext& context) {                                                     \
      utype to_value;                                                                                                  \
      JS::Error result = TypeHandler<utype>::to(to_value, context);                                                    \
      if (result == JS::Error::NoError)                                                                                \
        to_type = static_cast<name>(to_value);                                                                         \
      return result;                                                                                                   \
    }                                                                                                                  \
    static inline void from(const name& from_type, Token& token, Serializer& serializer) {                             \
      const utype from_value = static_cast<utype>(from_type);                                                          \
      TypeHandler<utype>::from(from_value, token, serializer);                                                         \
    }                                                                                                                  \
  };                                                                                                                   \
  }

#define JS_ENUM_NAMESPACE_DECLARE_VALUE_PARSER(ns, name)                                                               \
  namespace JS {                                                                                                       \
  template <> struct TypeHandler<ns::name> {                                                                           \
    typedef std::underlying_type<ns::name>::type utype;                                                                \
    static inline Error to(ns::name& to_type, ParseContext& context) {                                                 \
      utype to_value;                                                                                                  \
      JS::Error result = TypeHandler<utype>::to(to_value, context);                                                    \
      if (result == JS::Error::NoError)                                                                                \
        to_type = static_cast<ns::name>(to_value);                                                                     \
      return result;                                                                                                   \
    }                                                                                                                  \
    static inline void from(const ns::name& from_type, Token& token, Serializer& serializer) {                         \
      const utype from_value = static_cast<utype>(from_type);                                                          \
      TypeHandler<utype>::from(from_value, token, serializer);                                                         \
    }                                                                                                                  \
  };                                                                                                                   \
  }

namespace JS {
template <typename T, typename Enable> inline Error TypeHandler<T, Enable>::to(T& to_type, ParseContext& context) {
  if (context.token.value_type != JS::Type::ObjectStart) {
    return Error::ExpectedObjectStart;
  }
  Error error = context.tokenizer.nextToken(context.token);
  if (error != JS::Error::NoError) {
    return error;
  }
  auto members = Internal::JsonStructBaseDummy<T, T>::js_static_meta_data_info();
  using MembersType = decltype(members);
  bool assigned_members[Internal::memberCount<T, 0>()];
  memset(assigned_members, 0, sizeof(assigned_members));
  while (context.token.value_type != JS::Type::ObjectEnd)

  {
    DataRef token_name = context.token.name;
    error = Internal::MemberChecker<T, MembersType, 0, MembersType::size - 1>::unpackMembers(
        to_type, members, context, true, assigned_members
    );
    if (error == Error::MissingPropertyMember) {
      error = Internal::MemberChecker<T, MembersType, 0, MembersType::size - 1>::unpackMembers(
          to_type, members, context, false, assigned_members
      );
    }
    if (error == Error::MissingPropertyMember) {

      if (context.track_member_assignement_state) {
        context.missing_members.emplace_back(token_name.data, token_name.data + token_name.size);
      }
      if (context.allow_missing_members) {
        Internal::skipArrayOrObject(context);
        if (context.error != Error::NoError) {
          return context.error;
        }
      } else {
        return error;
      }
    } else if (error != Error::NoError) {
      return error;
    }
    context.nextToken();
    if (context.error != Error::NoError) {
      return context.error;
    }
  }
  std::vector<std::string> unassigned_required_members;
  error = Internal::MemberChecker<T, MembersType, 0, MembersType::size - 1>::verifyMembers(
      members, assigned_members, context.track_member_assignement_state, unassigned_required_members, ""
  );
  if (error == Error::UnassignedRequiredMember) {
    if (context.track_member_assignement_state) {
      context.unassigned_required_members.insert(
          context.unassigned_required_members.end(), unassigned_required_members.begin(),
          unassigned_required_members.end()
      );
    }
    if (context.allow_unasigned_required_members) {
      error = Error::NoError;
    }
  }
  return error;
}

template <typename T, typename Enable>
void TypeHandler<T, Enable>::from(const T& from_type, Token& token, Serializer& serializer) {
  static const char objectStart[] = "{";
  static const char objectEnd[] = "}";
  token.value_type = Type::ObjectStart;
  token.value = DataRef(objectStart);
  serializer.write(token);
  auto members = Internal::JsonStructBaseDummy<T, T>::js_static_meta_data_info();
  using MembersType = decltype(members);
  Internal::MemberChecker<T, MembersType, 0, MembersType::size - 1>::serializeMembers(
      from_type, members, token, serializer, ""
  );
  token.name.size = 0;
  token.name.data = "";
  token.name_type = Type::String;
  token.value_type = Type::ObjectEnd;
  token.value = DataRef(objectEnd);
  serializer.write(token);
}

namespace Internal {
template <typename T, typename F> struct EnumHandler {
  static inline Error to(T& to_type, ParseContext& context) {
    if (context.token.value_type == Type::String) {
      auto& strings = F::strings();
      for (size_t i = 0; i < strings.size(); i++) {
        const DataRef& ref = strings[i];
        if (ref.size == context.token.value.size) {
          if (memcmp(ref.data, context.token.value.data, ref.size) == 0) {
            to_type = static_cast<T>(i);
            return Error::NoError;
          }
        }
      }
    } else if (context.token.value_type == Type::Number) {
      using enum_int_t = typename std::underlying_type<T>::type;
      enum_int_t tmp;
      auto err = TypeHandler<enum_int_t>::to(tmp, context);
      if (err != Error::NoError) {
        return err;
      }
      to_type = static_cast<T>(tmp);
      return Error::NoError;
    }

    return Error::IllegalDataValue;
  }

  static inline void from(const T& from_type, Token& token, Serializer& serializer) {
    size_t i = static_cast<size_t>(from_type);
    token.value = F::strings()[i];
    token.value_type = Type::String;
    serializer.write(token);
  }
};
} // namespace Internal

namespace Internal {
static void push_back_escape(char current_char, std::string& to_type) {
  static const char escaped_table[] = {'b', 'f', 'n', 'r', 't', '\"', '\\', '/'};
  static const char replace_table[] = {'\b', '\f', '\n', '\r', '\t', '\"', '\\', '/'};
  static_assert(sizeof(escaped_table) == sizeof(replace_table), "Static tables have to be the same.");
  const char* it = static_cast<const char*>(memchr(escaped_table, current_char, sizeof(escaped_table)));
  if (it) {
    to_type.push_back(replace_table[(it - escaped_table)]);
  } else {
    to_type.push_back('\\');
    to_type.push_back(current_char);
  }
}

static void handle_json_escapes_in(const DataRef& ref, std::string& to_type) {
  to_type.reserve(ref.size);
  const char* it = ref.data;
  size_t size = ref.size;
  while (size) {
    const char* next_it = static_cast<const char*>(memchr(it, '\\', size));
    if (!next_it) {
      to_type.insert(to_type.end(), it, it + size);
      break;
    }
    to_type.insert(to_type.end(), it, next_it);
    size -= next_it - it;
    if (!size) {
      break;
    }
    size -= 2;
    const char current_char = *(next_it + 1);
    // we assume utf-8 encoding when this notation is used and parsing into std::string
    if (current_char == 'u') // hexadecimal escaped unicode character
    {
      // first convert hex ascii digits to values between 0 and 15, then create
      // UTF-8 bit patterns according to https://en.wikipedia.org/wiki/UTF-8
      bool ok = (size >= 4);
      unsigned char hex[4];
      for (int k = 0; ok && k < 4; k++) {
        const char d = *(next_it + k + 2);
        if (d >= '0' && d <= '9') {
          hex[k] = (d - '0');
        } else if (d >= 'A' && d <= 'F') {
          hex[k] = (d - 'A') + 10;
        } else if (d >= 'a' && d <= 'f') {
          hex[k] = (d - 'a') + 10;
        } else {
          ok = false; // stop parsing and revert to fallback
        }
      }
      if (ok) {
        if (hex[0] || hex[1] & 0x08) {
          // code points: 0x0800 .. 0xffff
          to_type.push_back(0xd0 | hex[0]);
          to_type.push_back(0x80 | (hex[1] << 2) | ((hex[2] & 0x0c) >> 2));
          to_type.push_back(0x80 | ((hex[2] & 0x03) << 4) | hex[3]);
        } else if (hex[1] || hex[2] & 0x08) {
          // code points: 0x0080 .. 0x07ff
          to_type.push_back(0xc0 | (hex[1] << 2) | ((hex[2] & 0x0c) >> 2));
          to_type.push_back(0x80 | ((hex[2] & 0x03) << 4) | hex[3]);
        } else {
          // code points: 0x0000 .. 0x007f
          to_type.push_back((hex[2] << 4) | hex[3]);
        }
        it = next_it + 6; // advance past hex digits
        size -= 4;
      } else {
        // fallback is to simply push characters as is
        to_type.push_back('\\');
        to_type.push_back(current_char);
        it = next_it + 2;
      }
    } else {
      push_back_escape(current_char, to_type);
      it = next_it + 2;
    }
    if (!size) {
      break;
    }
  }
}

static DataRef handle_json_escapes_out(const std::string& data, std::string& buffer) {
  int start_index = 0;
  for (size_t i = 0; i < data.size(); i++) {
    const char cur = data[i];
    if (static_cast<uint8_t>(cur) <= uint8_t('\r') || cur == '\"' || cur == '\\') {
      if (buffer.empty()) {
        buffer.reserve(data.size() + 10);
      }
      size_t diff = i - start_index;
      if (diff > 0) {
        buffer.insert(buffer.end(), data.data() + start_index, data.data() + start_index + diff);
      }
      start_index = int(i) + 1;

      switch (cur) {
      case '\b':
        buffer += std::string("\\b");
        break;
      case '\t':
        buffer += std::string("\\t");
        break;
      case '\n':
        buffer += std::string("\\n");
        break;
      case '\f':
        buffer += std::string("\\f");
        break;
      case '\r':
        buffer += std::string("\\r");
        break;
      case '\"':
        buffer += std::string("\\\"");
        break;
      case '\\':
        buffer += std::string("\\\\");
        break;
      default:
        buffer.push_back(cur);
        break;
      }
    }
  }
  if (buffer.size()) {
    size_t diff = data.size() - start_index;
    if (diff > 0) {
      buffer.insert(buffer.end(), data.data() + start_index, data.data() + start_index + diff);
    }
    return DataRef(buffer.data(), buffer.size());
  }
  return DataRef(data.data(), data.size());
}
} // namespace Internal
/// \private
template <> struct TypeHandler<std::string> {
  static inline Error to(std::string& to_type, ParseContext& context) {
    to_type.clear();
    Internal::handle_json_escapes_in(context.token.value, to_type);
    return Error::NoError;
  }

  static inline void from(const std::string& str, Token& token, Serializer& serializer) {
    std::string buffer;
    DataRef ref = Internal::handle_json_escapes_out(str, buffer);
    token.value_type = Type::String;
    token.value.data = ref.data;
    token.value.size = ref.size;
    serializer.write(token);
  }
};

namespace Internal {
// This code is taken from https://github.com/jorgen/float_tools
namespace ft {
template <typename T> struct float_base10 {
  uint8_t negative;
  uint8_t inf;
  uint8_t nan;
  uint8_t significand_digit_count;
  int exp;
  T significand;
};

template <typename T> struct parsed_string : float_base10<T> {
  const char* endptr;
};

enum class parse_string_error { ok, invalid_format, multiple_commas, empty_string, illegal_exponent_value };

constexpr static inline uint64_t high(uint64_t x) { return x >> 32; }
constexpr static inline uint64_t low(uint64_t x) { return x & ~uint32_t(0); }

template <int shift = 1> inline void left_shift(uint64_t (&a)[2]) {
  static_assert(
      shift < sizeof(*a) * 8, "This functions does only support shifting by sizes smaller than sizeof(*a) * 8"
  );
  a[1] = a[1] << shift | (a[0] >> (int(sizeof(uint64_t) * 8) - shift));
  a[0] = a[0] << shift;
}

template <int shift = 1> inline void left_shift(uint64_t& a) {
  static_assert(
      shift < sizeof(a) * 8, "This functions does only support shifting by sizes smaller than sizeof(*a) * 8"
  );
  a = a << shift;
}

inline void left_shift(uint64_t (&a)[2], int shift) {
  if (shift > int(sizeof(*a)) * 8) {
    auto shift_0 = (int(sizeof(uint64_t) * 8) - shift);
    a[1] = a[0] << -shift_0;

    a[0] = 0;
  } else {
    a[1] = a[1] << shift | (a[0] >> (int(sizeof(uint64_t) * 8) - shift));
    a[0] = a[0] << shift;
  }
}

inline void left_shift(uint64_t& a, int shift) { a = a << shift; }

inline void right_shift(uint64_t (&a)[2]) {
  a[0] = a[0] >> 1 | (a[1] << ((sizeof(uint64_t) * 8) - 1));
  a[1] = a[1] >> 1;
}

inline void right_shift(uint64_t& a) { a = a >> 1; }

inline uint64_t mask32(uint64_t a) { return a & ((uint64_t(1) << 32) - 1); }

inline void add(const uint64_t (&a)[2], uint64_t (&b)[2]) {
  uint64_t tmplow[2];
  uint64_t tmphigh[2];
  tmplow[0] = low(a[0]) + low(b[0]);
  tmplow[1] = low(a[1]) + low(b[1]);
  tmphigh[0] = high(a[0]) + high(b[0]);
  tmphigh[1] = high(a[1]) + high(b[1]);

  tmphigh[0] += tmplow[0] >> 32;
  tmplow[1] += tmphigh[0] >> 32;
  tmphigh[1] += tmplow[1] >> 32;

  b[0] = mask32(tmplow[0]) | (tmphigh[0] << 32);
  b[1] = mask32(tmplow[1]) | (tmphigh[1] << 32);
}

inline void add(const uint64_t& a, uint64_t& b) { b += a; }

inline void divide_by_10(uint64_t (&a)[2]) {
  uint64_t remainder = a[1] % 10;
  a[1] /= 10;
  uint64_t high_pluss_reminder = high(a[0]) + (remainder << 32);
  uint64_t high_d = high_pluss_reminder / 10;
  uint64_t high_r = high_pluss_reminder % 10;
  uint64_t low_d = (low(a[0]) + (high_r << 32)) / 10;
  a[0] = high_d << 32 | low_d;
}

inline void divide_by_10(uint64_t& a) { a /= 10; }

template <typename T> struct float_info {};

static inline int bit_scan_reverse(uint64_t a) {
  assert(a);
#ifdef _MSC_VER
  unsigned long index;
#ifdef _WIN64
  _BitScanReverse64(&index, a);
#else
  if (_BitScanReverse(&index, a >> 32)) {
    index += 32;
  } else {
    _BitScanReverse(&index, a & (~uint32_t(0)));
  }
#endif
  return int(index);
#else
  static_assert(sizeof(unsigned long long) == sizeof(uint64_t), "Wrong size for builtin_clzll");
  return 63 - __builtin_clzll(a);
#endif
}

template <> struct float_info<double> {
  static inline constexpr int mentissa_width() noexcept { return 52; }
  static inline constexpr int exponent_width() noexcept { return 11; }
  static inline constexpr int bias() noexcept { return (1 << (exponent_width() - 1)) - 1; }
  static inline constexpr int max_base10_exponent() noexcept { return 308; }
  static inline constexpr int min_base10_exponent() noexcept { return -324; }
  static inline constexpr int max_double_5_pow_q() noexcept { return 23; } // floor(log_5(1 << (mentissawidth + 2)))
  static inline constexpr int max_double_2_pow_q() noexcept { return 54; } // floor(log_2(1 << (mentissawidth + 2)))

  using str_to_float_conversion_type = uint64_t[2];
  using uint_alias = uint64_t;
  static inline constexpr int str_to_float_binary_exponent_init() noexcept { return 64 + 60; }
  static inline constexpr uint64_t str_to_float_mask() noexcept { return ~((uint64_t(1) << 60) - 1); }
  static inline constexpr uint64_t str_to_float_top_bit_in_mask() noexcept { return uint64_t(1) << 63; }
  static inline constexpr int str_to_float_expanded_length() noexcept { return 19; }
  static inline constexpr bool conversion_type_has_mask(const str_to_float_conversion_type& a) noexcept {
    return a[1] & str_to_float_mask();
  }
  static inline constexpr bool conversion_type_has_top_bit_in_mask(const str_to_float_conversion_type& a) noexcept {
    return a[1] & str_to_float_top_bit_in_mask();
  }
  static inline constexpr bool conversion_type_is_null(const str_to_float_conversion_type& a) noexcept {
    return !a[0] && !a[1];
  }
  static inline int shift_left_msb_to_index(str_to_float_conversion_type& a, int index) {
    if (a[1]) {
      int msb = bit_scan_reverse(a[1]);
      int shift_count = index - (msb + 64);
      if (shift_count < 0) {
        return 0;
      }
      left_shift(a, shift_count);
      return shift_count;
    } else if (a[0]) {
      int msb = bit_scan_reverse(a[0]);
      int shift_count = index - msb;
      if (shift_count < 0) {
        return 0;
      }
      left_shift(a, shift_count);
      return shift_count;
    }
    return 0;
  }
  static inline void copy_denormal_to_type(
      const str_to_float_conversion_type& a, int binary_exponent, bool negative, double& to_digit
  ) {
    uint64_t q = a[1];
    int expo_shift = -binary_exponent + 9;
    if (expo_shift) {
      q += uint64_t(1) << (expo_shift - 1);
      q >>= expo_shift;
    }
    if (negative) {
      q |= uint64_t(1) << 63;
    }
    memcpy(&to_digit, &q, sizeof(q));
  }

  static inline void copy_normal_to_type(
      const str_to_float_conversion_type& a, int binary_exponent, bool negative, double& to_digit
  ) {
    uint64_t q = a[1] & ~str_to_float_mask();
    uint64_t to_round_off = (q & ((uint64_t(1) << 8) - 1));
    bool bigger = to_round_off > (uint64_t(1) << (8 - 1)) || (to_round_off == (uint64_t(1) << (8 - 1)) && a[0]);
    bool tie_odd = (!(q & ((uint64_t(1) << 7) - 1))) && (q & (uint64_t(1) << 8)) && !a[0];
    if (bigger || tie_odd) {
      q += uint64_t(1) << (8 - 1);
    }
    q >>= 8;
    q += uint64_t(binary_exponent) << mentissa_width();
    if (negative) {
      q |= uint64_t(1) << 63;
    }
    memcpy(&to_digit, &q, sizeof(q));
  }
};

template <typename T> inline void get_parts(T f, bool& negative, int& exp, uint64_t& mentissa) {
  uint64_t bits = 0;
  static_assert(sizeof(bits) >= sizeof(f), "Incompatible size");
  memcpy(&bits, &f, sizeof(f));
  exp = int((bits >> float_info<T>::mentissa_width()) & (((uint64_t(1) << float_info<T>::exponent_width()) - 1)));
  mentissa = bits & ((uint64_t(1) << float_info<T>::mentissa_width()) - 1);
  negative = bits >> ((sizeof(f) * 8) - 1);
}

template <typename T>
inline void assign_significand_to_float_conversion_type(const float_base10<T>& significand, uint64_t (&a)[2]) {
  a[0] = significand.significand;
  a[1] = 0;
}

inline void copy_conversion_type(const uint64_t (&a)[2], uint64_t (&b)[2]) { memcpy(&b, &a, sizeof(b)); }

template <> struct float_info<float> {
  static inline constexpr int mentissa_width() noexcept { return 23; }
  static inline constexpr int exponent_width() noexcept { return 8; }
  static inline constexpr int bias() noexcept { return (1 << (exponent_width() - 1)) - 1; }
  static inline constexpr int max_base10_exponent() noexcept { return 38; }
  static inline constexpr int min_base10_exponent() noexcept { return -45; }
  static inline constexpr int max_double_5_pow_q() noexcept { return 10; } // floor(log_5(1 << (mentissawidth + 2)))
  static inline constexpr int max_double_2_pow_q() noexcept { return 25; } // floor(log_2(1 << (mentissawidth + 2)))

  using str_to_float_conversion_type = uint64_t;
  using uint_alias = uint32_t;
  static inline constexpr int str_to_float_binary_exponent_init() noexcept { return 60; }
  static inline constexpr uint64_t str_to_float_mask() noexcept { return ~((uint64_t(1) << 60) - 1); }
  static inline constexpr uint64_t str_to_float_top_bit_in_mask() noexcept { return uint64_t(1) << 63; }
  static inline constexpr int str_to_float_expanded_length() noexcept { return 10; }
  static inline constexpr bool conversion_type_has_mask(const str_to_float_conversion_type& a) noexcept {
    return a & str_to_float_mask();
  }
  static inline constexpr bool conversion_type_has_top_bit_in_mask(const str_to_float_conversion_type& a) noexcept {
    return a & str_to_float_top_bit_in_mask();
  }
  static inline constexpr bool conversion_type_is_null(const str_to_float_conversion_type& a) noexcept { return !a; }
  static inline int shift_left_msb_to_index(str_to_float_conversion_type& a, int index) {
    if (a) {
      int msb = bit_scan_reverse(a);
      int shift_count = index - msb;
      if (shift_count < 0) {
        return 0;
      }
      left_shift(a, shift_count);
      return shift_count;
    }
    return 0;
  }
  static inline void copy_denormal_to_type(
      const str_to_float_conversion_type& a, int binary_exponent, bool negative, float& to_digit
  ) {
    uint64_t q = a;
    int expo_shift = -binary_exponent + 38;
    if (expo_shift) {
      q += uint64_t(1) << (expo_shift - 1);
      q >>= expo_shift;
    }
    if (negative) {
      q |= uint64_t(1) << 31;
    }
    uint32_t to_copy = uint32_t(q);
    memcpy(&to_digit, &to_copy, sizeof(to_copy));
  }
  static inline void copy_normal_to_type(
      const str_to_float_conversion_type& a, int binary_exponent, bool negative, float& to_digit
  ) {
    uint64_t q = a & ~str_to_float_mask();
    bool bigger = (q & ((uint64_t(1) << 37) - 1)) > (uint64_t(1) << (37 - 1));
    bool tie_odd = (!(q & ((uint64_t(1) << 36) - 1))) && (q & (uint64_t(1) << 37));
    if (bigger || tie_odd) {
      q += (uint64_t(1) << (37 - 1));
    }
    q >>= 37;
    q += uint64_t(binary_exponent) << mentissa_width();
    if (negative) {
      q |= uint64_t(1) << 31;
    }
    uint32_t to_copy = uint32_t(q);
    memcpy(&to_digit, &to_copy, sizeof(to_digit));
  }
};

template <typename T> inline T make_zero(bool negative) {
  using uint_ft = typename float_info<T>::uint_alias;
  uint_ft tmp = 0;
  tmp = uint_ft(negative) << ((sizeof(T) * 8) - 1);
  T ret;
  memcpy(&ret, &tmp, sizeof(ret));
  return ret;
}

template <typename T> inline T make_inf(bool negative) {
  using uint_ft = typename float_info<T>::uint_alias;
  uint_ft tmp = (uint_ft(1) << float_info<T>::exponent_width()) - 1;
  tmp <<= float_info<T>::mentissa_width();
  tmp += uint_ft(negative) << ((sizeof(T) * 8) - 1);
  T ret;
  memcpy(&ret, &tmp, sizeof(ret));
  return ret;
}

template <typename T> inline T make_nan(bool positive, uint64_t pos = 1) {
  if (pos == 0) {
    pos++;
  }
  using uint_ft = typename float_info<T>::uint_alias;
  uint_ft tmp = (uint_ft(1) << float_info<T>::exponent_width()) - 1;
  tmp <<= float_info<T>::mentissa_width();
  tmp |= pos;
  tmp |= uint_ft(!positive) << ((sizeof(T) * 8) - 1);
  T ret;
  memcpy(&ret, &tmp, sizeof(ret));
  return ret;
}

template <typename T> inline bool is_nan(T t) {
  bool negative;
  int exp;
  uint64_t mentissa;
  get_parts(t, negative, exp, mentissa);
  return exp == ((int(1) << float_info<T>::exponent_width()) - 1) && mentissa > 0;
}

template <typename T> inline bool is_inf(T t) {
  bool negative;
  int exp;
  uint64_t mentissa;
  get_parts(t, negative, exp, mentissa);
  return exp == ((int(1) << float_info<T>::exponent_width()) - 1) && mentissa == 0;
}

template <typename T> const T& max(const T& a, const T& b) { return (a < b) ? b : a; }

template <typename T> const T& min(const T& a, const T& b) { return (b < a) ? b : a; }

template <typename I, typename P> I find_if(I first, I last, P p) {
  for (; first != last; ++first) {
    if (p(*first)) {
      return first;
    }
  }
  return last;
}

template <typename T>
inline void assign_significand_to_float_conversion_type(const float_base10<T>& significand, uint64_t& a) {
  a = significand.significand;
}

inline void copy_conversion_type(const uint64_t& a, uint64_t& b) { b = a; }

template <typename T, int COUNT, T SUM> struct Pow10 {
  static inline T get() noexcept { return Pow10<T, COUNT - 1, SUM * T(10)>::get(); }
};
template <typename T, T SUM> struct Pow10<T, 1, SUM> {
  static inline T get() noexcept { return SUM; }
};
template <typename T, T SUM> struct Pow10<T, 0, SUM> {
  static inline T get() noexcept { return 1; }
};

template <typename T, T VALUE, int SUM, T ABORT_VALUE, bool CONTINUE> struct StaticLog10 {
  constexpr static int get() noexcept {
    return StaticLog10 < T, VALUE / 10, SUM + 1, ABORT_VALUE, VALUE / 10 != ABORT_VALUE > ::get();
  }
};

template <typename T, T VALUE, T ABORT_VALUE, int SUM> struct StaticLog10<T, VALUE, SUM, ABORT_VALUE, false> {
  constexpr static int get() noexcept { return SUM; }
};

template <typename T, int WIDTH, int CURRENT> struct CharsInDigit {
  static int lower_bounds(T t) noexcept {
    if (Pow10<T, CURRENT + WIDTH / 2, 1>::get() - 1 < t) {
      return CharsInDigit<T, WIDTH - (WIDTH / 2 + 1), CURRENT + WIDTH / 2 + 1>::lower_bounds(t);
    }
    return CharsInDigit<T, WIDTH / 2, CURRENT>::lower_bounds(t);
  }
};
template <typename T, int CURRENT> struct CharsInDigit<T, 0, CURRENT> {
  static int lower_bounds(T) noexcept { return CURRENT; }
};
template <typename T, int CURRENT> struct CharsInDigit<T, -1, CURRENT> {
  static int lower_bounds(T) noexcept { return CURRENT; }
};

template <typename T> T iabs(typename std::enable_if<std::is_unsigned<T>::value, T>::type a) { return a; }

template <typename T> T iabs(typename std::enable_if<std::is_signed<T>::value, T>::type a) {
  // this
  if (a > 0) {
    return a;
  }
  if (a == std::numeric_limits<T>::min()) {
    a++;
  }
  return -a;
}

template <typename T> int count_chars(T t) noexcept {
  if (iabs<T>(t) < T(10)) {
    return 1;
  }
  constexpr int maxChars = StaticLog10<T, std::numeric_limits<T>::max(), 0, 0, true>::get() + 1;
  return CharsInDigit<T, maxChars, 0>::lower_bounds(iabs<T>(t)) - 1;
}

namespace ryu {
template <typename T> struct cache_values {};

template <> struct cache_values<double> {
  constexpr static const int b0 = 124;
  constexpr static const int b1 = 124;

  static const uint64_t* less_than(int index) {
    static const uint64_t data[326][2] = {
        {/*  0*/ UINT64_C(0), UINT64_C(1152921504606846976)},
        {/*  1*/ UINT64_C(0), UINT64_C(720575940379279360)},
        {/*  2*/ UINT64_C(0), UINT64_C(900719925474099200)},
        {/*  3*/ UINT64_C(0), UINT64_C(1125899906842624000)},
        {/*  4*/ UINT64_C(0), UINT64_C(703687441776640000)},
        {/*  5*/ UINT64_C(0), UINT64_C(879609302220800000)},
        {/*  6*/ UINT64_C(0), UINT64_C(1099511627776000000)},
        {/*  7*/ UINT64_C(0), UINT64_C(687194767360000000)},
        {/*  8*/ UINT64_C(0), UINT64_C(858993459200000000)},
        {/*  9*/ UINT64_C(0), UINT64_C(1073741824000000000)},
        {/* 10*/ UINT64_C(0), UINT64_C(671088640000000000)},
        {/* 11*/ UINT64_C(0), UINT64_C(838860800000000000)},
        {/* 12*/ UINT64_C(0), UINT64_C(1048576000000000000)},
        {/* 13*/ UINT64_C(0), UINT64_C(655360000000000000)},
        {/* 14*/ UINT64_C(0), UINT64_C(819200000000000000)},
        {/* 15*/ UINT64_C(0), UINT64_C(1024000000000000000)},
        {/* 16*/ UINT64_C(0), UINT64_C(640000000000000000)},
        {/* 17*/ UINT64_C(0), UINT64_C(800000000000000000)},
        {/* 18*/ UINT64_C(0), UINT64_C(1000000000000000000)},
        {/* 19*/ UINT64_C(0), UINT64_C(625000000000000000)},
        {/* 20*/ UINT64_C(0), UINT64_C(781250000000000000)},
        {/* 21*/ UINT64_C(0), UINT64_C(976562500000000000)},
        {/* 22*/ UINT64_C(0), UINT64_C(610351562500000000)},
        {/* 23*/ UINT64_C(0), UINT64_C(762939453125000000)},
        {/* 24*/ UINT64_C(0), UINT64_C(953674316406250000)},
        {/* 25*/ UINT64_C(0), UINT64_C(596046447753906250)},
        {/* 26*/ UINT64_C(9223372036854775808), UINT64_C(745058059692382812)},
        {/* 27*/ UINT64_C(11529215046068469760), UINT64_C(931322574615478515)},
        {/* 28*/ UINT64_C(4899916394579099648), UINT64_C(582076609134674072)},
        {/* 29*/ UINT64_C(6124895493223874560), UINT64_C(727595761418342590)},
        {/* 30*/ UINT64_C(16879491403384619008), UINT64_C(909494701772928237)},
        {/* 31*/ UINT64_C(7264306198948610048), UINT64_C(1136868377216160297)},
        {/* 32*/ UINT64_C(16069406420411351040), UINT64_C(710542735760100185)},
        {/* 33*/ UINT64_C(6251699970232025088), UINT64_C(888178419700125232)},
        {/* 34*/ UINT64_C(7814624962790031360), UINT64_C(1110223024625156540)},
        {/* 35*/ UINT64_C(14107512638598545408), UINT64_C(693889390390722837)},
        {/* 36*/ UINT64_C(3799332742966018048), UINT64_C(867361737988403547)},
        {/* 37*/ UINT64_C(137479910280134656), UINT64_C(1084202172485504434)},
        {/* 38*/ UINT64_C(4697610962352472064), UINT64_C(677626357803440271)},
        {/* 39*/ UINT64_C(1260327684513202176), UINT64_C(847032947254300339)},
        {/* 40*/ UINT64_C(15410467660923666432), UINT64_C(1058791184067875423)},
        {/* 41*/ UINT64_C(16549071315718373376), UINT64_C(661744490042422139)},
        {/* 42*/ UINT64_C(16074653126220578816), UINT64_C(827180612553027674)},
        {/* 43*/ UINT64_C(10869944370920947712), UINT64_C(1033975765691284593)},
        {/* 44*/ UINT64_C(18322930277894062080), UINT64_C(646234853557052870)},
        {/* 45*/ UINT64_C(13680290810512801792), UINT64_C(807793566946316088)},
        {/* 46*/ UINT64_C(17100363513141002240), UINT64_C(1009741958682895110)},
        {/* 47*/ UINT64_C(6076041177285738496), UINT64_C(631088724176809444)},
        {/* 48*/ UINT64_C(7595051471607173120), UINT64_C(788860905221011805)},
        {/* 49*/ UINT64_C(14105500357936354304), UINT64_C(986076131526264756)},
        {/* 50*/ UINT64_C(18039309760564997248), UINT64_C(616297582203915472)},
        {/* 51*/ UINT64_C(4102393126996694944), UINT64_C(770371977754894341)},
        {/* 52*/ UINT64_C(9739677427173256584), UINT64_C(962964972193617926)},
        {/* 53*/ UINT64_C(1475612373555897461), UINT64_C(601853107621011204)},
        {/* 54*/ UINT64_C(1844515466944871826), UINT64_C(752316384526264005)},
        {/* 55*/ UINT64_C(6917330352108477686), UINT64_C(940395480657830006)},
        {/* 56*/ UINT64_C(18158389525349962266), UINT64_C(587747175411143753)},
        {/* 57*/ UINT64_C(8862928851405289120), UINT64_C(734683969263929692)},
        {/* 58*/ UINT64_C(11078661064256611401), UINT64_C(918354961579912115)},
        {/* 59*/ UINT64_C(9236640311893376347), UINT64_C(1147943701974890144)},
        {/* 60*/ UINT64_C(5772900194933360217), UINT64_C(717464813734306340)},
        {/* 61*/ UINT64_C(7216125243666700271), UINT64_C(896831017167882925)},
        {/* 62*/ UINT64_C(13631842573010763243), UINT64_C(1121038771459853656)},
        {/* 63*/ UINT64_C(8519901608131727026), UINT64_C(700649232162408535)},
        {/* 64*/ UINT64_C(6038190991737270879), UINT64_C(875811540203010669)},
        {/* 65*/ UINT64_C(12159424758098976503), UINT64_C(1094764425253763336)},
        {/* 66*/ UINT64_C(7599640473811860314), UINT64_C(684227765783602085)},
        {/* 67*/ UINT64_C(14111236610692213297), UINT64_C(855284707229502606)},
        {/* 68*/ UINT64_C(8415673726510490813), UINT64_C(1069105884036878258)},
        {/* 69*/ UINT64_C(9871482097496444662), UINT64_C(668191177523048911)},
        {/* 70*/ UINT64_C(7727666603443167924), UINT64_C(835238971903811139)},
        {/* 71*/ UINT64_C(5047897235876572001), UINT64_C(1044048714879763924)},
        {/* 72*/ UINT64_C(12378307809277633308), UINT64_C(652530446799852452)},
        {/* 73*/ UINT64_C(15472884761597041636), UINT64_C(815663058499815565)},
        {/* 74*/ UINT64_C(5506047896714138333), UINT64_C(1019578823124769457)},
        {/* 75*/ UINT64_C(14970494981514806218), UINT64_C(637236764452980910)},
        {/* 76*/ UINT64_C(9489746690038731964), UINT64_C(796545955566226138)},
        {/* 77*/ UINT64_C(2638811325693639147), UINT64_C(995682444457782673)},
        {/* 78*/ UINT64_C(13178472124626994227), UINT64_C(622301527786114170)},
        {/* 79*/ UINT64_C(7249718118928966976), UINT64_C(777876909732642713)},
        {/* 80*/ UINT64_C(13673833667088596624), UINT64_C(972346137165803391)},
        {/* 81*/ UINT64_C(15463675069571454746), UINT64_C(607716335728627119)},
        {/* 82*/ UINT64_C(14717907818536930528), UINT64_C(759645419660783899)},
        {/* 83*/ UINT64_C(13785698754743775257), UINT64_C(949556774575979874)},
        {/* 84*/ UINT64_C(13227747740142247439), UINT64_C(593472984109987421)},
        {/* 85*/ UINT64_C(2699626619895645587), UINT64_C(741841230137484277)},
        {/* 86*/ UINT64_C(7986219293296944888), UINT64_C(927301537671855346)},
        {/* 87*/ UINT64_C(9603073076737978459), UINT64_C(579563461044909591)},
        {/* 88*/ UINT64_C(7392155327495085170), UINT64_C(724454326306136989)},
        {/* 89*/ UINT64_C(13851880177796244366), UINT64_C(905567907882671236)},
        {/* 90*/ UINT64_C(17314850222245305458), UINT64_C(1131959884853339045)},
        {/* 91*/ UINT64_C(13127624398117009863), UINT64_C(707474928033336903)},
        {/* 92*/ UINT64_C(11797844479218874425), UINT64_C(884343660041671129)},
        {/* 93*/ UINT64_C(912247543741429319), UINT64_C(1105429575052088912)},
        {/* 94*/ UINT64_C(570154714838393324), UINT64_C(690893484407555570)},
        {/* 95*/ UINT64_C(9936065430402767463), UINT64_C(863616855509444462)},
        {/* 96*/ UINT64_C(3196709751148683521), UINT64_C(1079521069386805578)},
        {/* 97*/ UINT64_C(6609629612895315105), UINT64_C(674700668366753486)},
        {/* 98*/ UINT64_C(17485409052973919689), UINT64_C(843375835458441857)},
        {/* 99*/ UINT64_C(8021703260935235899), UINT64_C(1054219794323052322)},
        {/*100*/ UINT64_C(9625250556511910341), UINT64_C(658887371451907701)},
        {/*101*/ UINT64_C(16643249214067275830), UINT64_C(823609214314884626)},
        {/*102*/ UINT64_C(11580689480729318980), UINT64_C(1029511517893605783)},
        {/*103*/ UINT64_C(14155459953096906218), UINT64_C(643444698683503614)},
        {/*104*/ UINT64_C(8470952904516356965), UINT64_C(804305873354379518)},
        {/*105*/ UINT64_C(1365319093790670398), UINT64_C(1005382341692974398)},
        {/*106*/ UINT64_C(14688382488901332711), UINT64_C(628363963558108998)},
        {/*107*/ UINT64_C(9137106074271890081), UINT64_C(785454954447636248)},
        {/*108*/ UINT64_C(11421382592839862601), UINT64_C(981818693059545310)},
        {/*109*/ UINT64_C(2526678102097526221), UINT64_C(613636683162215819)},
        {/*110*/ UINT64_C(16993405682904071489), UINT64_C(767045853952769773)},
        {/*111*/ UINT64_C(7406699048347925649), UINT64_C(958807317440962217)},
        {/*112*/ UINT64_C(16158401951285923291), UINT64_C(599254573400601385)},
        {/*113*/ UINT64_C(6362944383825240401), UINT64_C(749068216750751732)},
        {/*114*/ UINT64_C(7953680479781550502), UINT64_C(936335270938439665)},
        {/*115*/ UINT64_C(16500265345931938823), UINT64_C(585209544336524790)},
        {/*116*/ UINT64_C(11401959645560147721), UINT64_C(731511930420655988)},
        {/*117*/ UINT64_C(14252449556950184652), UINT64_C(914389913025819985)},
        {/*118*/ UINT64_C(3980503890905567103), UINT64_C(1142987391282274982)},
        {/*119*/ UINT64_C(16322872987098143151), UINT64_C(714367119551421863)},
        {/*120*/ UINT64_C(15791905215445291035), UINT64_C(892958899439277329)},
        {/*121*/ UINT64_C(5904823464024450082), UINT64_C(1116198624299096662)},
        {/*122*/ UINT64_C(17525572720297445013), UINT64_C(697624140186935413)},
        {/*123*/ UINT64_C(8071907845089642554), UINT64_C(872030175233669267)},
        {/*124*/ UINT64_C(5478198787934665289), UINT64_C(1090037719042086584)},
        {/*125*/ UINT64_C(3423874242459165806), UINT64_C(681273574401304115)},
        {/*126*/ UINT64_C(18114900858356120969), UINT64_C(851591968001630143)},
        {/*127*/ UINT64_C(18031940054517763307), UINT64_C(1064489960002037679)},
        {/*128*/ UINT64_C(18187491561714683923), UINT64_C(665306225001273549)},
        {/*129*/ UINT64_C(8899306396861191192), UINT64_C(831632781251591937)},
        {/*130*/ UINT64_C(15735819014503876894), UINT64_C(1039540976564489921)},
        {/*131*/ UINT64_C(2917357856423841202), UINT64_C(649713110352806201)},
        {/*132*/ UINT64_C(8258383338957189407), UINT64_C(812141387941007751)},
        {/*133*/ UINT64_C(5711293155269098855), UINT64_C(1015176734926259689)},
        {/*134*/ UINT64_C(15098773268111656544), UINT64_C(634485459328912305)},
        {/*135*/ UINT64_C(5038408529857406968), UINT64_C(793106824161140382)},
        {/*136*/ UINT64_C(15521382699176534519), UINT64_C(991383530201425477)},
        {/*137*/ UINT64_C(12006707196199028026), UINT64_C(619614706375890923)},
        {/*138*/ UINT64_C(10396697976821397129), UINT64_C(774518382969863654)},
        {/*139*/ UINT64_C(3772500434171970603), UINT64_C(968147978712329568)},
        {/*140*/ UINT64_C(2357812771357481627), UINT64_C(605092486695205980)},
        {/*141*/ UINT64_C(2947265964196852033), UINT64_C(756365608369007475)},
        {/*142*/ UINT64_C(17519140510528228754), UINT64_C(945457010461259343)},
        {/*143*/ UINT64_C(17866991846721224827), UINT64_C(590910631538287089)},
        {/*144*/ UINT64_C(8498681753119367322), UINT64_C(738638289422858862)},
        {/*145*/ UINT64_C(1399980154544433344), UINT64_C(923297861778573578)},
        {/*146*/ UINT64_C(5486673615017658744), UINT64_C(577061163611608486)},
        {/*147*/ UINT64_C(16081714055626849238), UINT64_C(721326454514510607)},
        {/*148*/ UINT64_C(15490456551106173644), UINT64_C(901658068143138259)},
        {/*149*/ UINT64_C(14751384670455329151), UINT64_C(1127072585178922824)},
        {/*150*/ UINT64_C(9219615419034580719), UINT64_C(704420365736826765)},
        {/*151*/ UINT64_C(16136205292220613803), UINT64_C(880525457171033456)},
        {/*152*/ UINT64_C(1723512541566215638), UINT64_C(1100656821463791821)},
        {/*153*/ UINT64_C(3383038347692578726), UINT64_C(687910513414869888)},
        {/*154*/ UINT64_C(4228797934615723407), UINT64_C(859888141768587360)},
        {/*155*/ UINT64_C(5285997418269654259), UINT64_C(1074860177210734200)},
        {/*156*/ UINT64_C(3303748386418533912), UINT64_C(671787610756708875)},
        {/*157*/ UINT64_C(17964743538305331102), UINT64_C(839734513445886093)},
        {/*158*/ UINT64_C(8620871367599500165), UINT64_C(1049668141807357617)},
        {/*159*/ UINT64_C(16917259650818157363), UINT64_C(656042588629598510)},
        {/*160*/ UINT64_C(11923202526667920896), UINT64_C(820053235786998138)},
        {/*161*/ UINT64_C(5680631121480125312), UINT64_C(1025066544733747673)},
        {/*162*/ UINT64_C(15079609496993548080), UINT64_C(640666590458592295)},
        {/*163*/ UINT64_C(14237825852814547196), UINT64_C(800833238073240369)},
        {/*164*/ UINT64_C(3962224260736020283), UINT64_C(1001041547591550462)},
        {/*165*/ UINT64_C(16311448218242176389), UINT64_C(625650967244719038)},
        {/*166*/ UINT64_C(11165938235947944678), UINT64_C(782063709055898798)},
        {/*167*/ UINT64_C(4734050758080155040), UINT64_C(977579636319873498)},
        {/*168*/ UINT64_C(7570467742227484804), UINT64_C(610987272699920936)},
        {/*169*/ UINT64_C(9463084677784356005), UINT64_C(763734090874901170)},
        {/*170*/ UINT64_C(2605483810375669198), UINT64_C(954667613593626463)},
        {/*171*/ UINT64_C(8545956409125875105), UINT64_C(596667258496016539)},
        {/*172*/ UINT64_C(6070759492979955977), UINT64_C(745834073120020674)},
        {/*173*/ UINT64_C(16811821403079720779), UINT64_C(932292591400025842)},
        {/*174*/ UINT64_C(15119074395352213391), UINT64_C(582682869625016151)},
        {/*175*/ UINT64_C(14287156975762878835), UINT64_C(728353587031270189)},
        {/*176*/ UINT64_C(4023888164421434831), UINT64_C(910441983789087737)},
        {/*177*/ UINT64_C(9641546223954181443), UINT64_C(1138052479736359671)},
        {/*178*/ UINT64_C(12943495417612445258), UINT64_C(711282799835224794)},
        {/*179*/ UINT64_C(6955997235160780765), UINT64_C(889103499794030993)},
        {/*180*/ UINT64_C(13306682562378363860), UINT64_C(1111379374742538741)},
        {/*181*/ UINT64_C(10622519610700171364), UINT64_C(694612109214086713)},
        {/*182*/ UINT64_C(17889835531802602109), UINT64_C(868265136517608391)},
        {/*183*/ UINT64_C(17750608396325864733), UINT64_C(1085331420647010489)},
        {/*184*/ UINT64_C(4176601220062583602), UINT64_C(678332137904381556)},
        {/*185*/ UINT64_C(5220751525078229502), UINT64_C(847915172380476945)},
        {/*186*/ UINT64_C(11137625424775174782), UINT64_C(1059893965475596181)},
        {/*187*/ UINT64_C(9266858899698178191), UINT64_C(662433728422247613)},
        {/*188*/ UINT64_C(16195259643050110642), UINT64_C(828042160527809516)},
        {/*189*/ UINT64_C(1797330480103086687), UINT64_C(1035052700659761896)},
        {/*190*/ UINT64_C(1123331550064429179), UINT64_C(646907937912351185)},
        {/*191*/ UINT64_C(6015850456007924378), UINT64_C(808634922390438981)},
        {/*192*/ UINT64_C(12131499088437293377), UINT64_C(1010793652988048726)},
        {/*193*/ UINT64_C(2970500911845920456), UINT64_C(631746033117530454)},
        {/*194*/ UINT64_C(12936498176662176379), UINT64_C(789682541396913067)},
        {/*195*/ UINT64_C(11558936702400332569), UINT64_C(987103176746141334)},
        {/*196*/ UINT64_C(2612649420572819952), UINT64_C(616939485466338334)},
        {/*197*/ UINT64_C(12489183812570800748), UINT64_C(771174356832922917)},
        {/*198*/ UINT64_C(1776421710431337223), UINT64_C(963967946041153647)},
        {/*199*/ UINT64_C(8027792596660667620), UINT64_C(602479966275721029)},
        {/*200*/ UINT64_C(14646426764253222429), UINT64_C(753099957844651286)},
        {/*201*/ UINT64_C(9084661418461752229), UINT64_C(941374947305814108)},
        {/*202*/ UINT64_C(14901285423393370951), UINT64_C(588359342066133817)},
        {/*203*/ UINT64_C(4791548723959549977), UINT64_C(735449177582667272)},
        {/*204*/ UINT64_C(5989435904949437471), UINT64_C(919311471978334090)},
        {/*205*/ UINT64_C(16710166918041572647), UINT64_C(1149139339972917612)},
        {/*206*/ UINT64_C(1220482286921207096), UINT64_C(718212087483073508)},
        {/*207*/ UINT64_C(1525602858651508870), UINT64_C(897765109353841885)},
        {/*208*/ UINT64_C(6518689591741773992), UINT64_C(1122206386692302356)},
        {/*209*/ UINT64_C(13297553031693384553), UINT64_C(701378991682688972)},
        {/*210*/ UINT64_C(16621941289616730691), UINT64_C(876723739603361215)},
        {/*211*/ UINT64_C(16165740593593525460), UINT64_C(1095904674504201519)},
        {/*212*/ UINT64_C(17021116898637035268), UINT64_C(684940421565125949)},
        {/*213*/ UINT64_C(7441338068014130373), UINT64_C(856175526956407437)},
        {/*214*/ UINT64_C(13913358603445050871), UINT64_C(1070219408695509296)},
        {/*215*/ UINT64_C(8695849127153156794), UINT64_C(668887130434693310)},
        {/*216*/ UINT64_C(1646439372086670185), UINT64_C(836108913043366638)},
        {/*217*/ UINT64_C(11281421251963113539), UINT64_C(1045136141304208297)},
        {/*218*/ UINT64_C(133359254835864106), UINT64_C(653210088315130186)},
        {/*219*/ UINT64_C(9390071105399605940), UINT64_C(816512610393912732)},
        {/*220*/ UINT64_C(11737588881749507425), UINT64_C(1020640762992390915)},
        {/*221*/ UINT64_C(5030150041879748189), UINT64_C(637900476870244322)},
        {/*222*/ UINT64_C(15511059589204461044), UINT64_C(797375596087805402)},
        {/*223*/ UINT64_C(10165452449650800497), UINT64_C(996719495109756753)},
        {/*224*/ UINT64_C(17882622827100220070), UINT64_C(622949684443597970)},
        {/*225*/ UINT64_C(13129906497020499280), UINT64_C(778687105554497463)},
        {/*226*/ UINT64_C(11800697102848236196), UINT64_C(973358881943121829)},
        {/*227*/ UINT64_C(9681278698493841575), UINT64_C(608349301214451143)},
        {/*228*/ UINT64_C(7489912354689914064), UINT64_C(760436626518063929)},
        {/*229*/ UINT64_C(13974076461789780485), UINT64_C(950545783147579911)},
        {/*230*/ UINT64_C(15651326816259694659), UINT64_C(594091114467237444)},
        {/*231*/ UINT64_C(1117414446615066707), UINT64_C(742613893084046806)},
        {/*232*/ UINT64_C(10620140095123609192), UINT64_C(928267366355058507)},
        {/*233*/ UINT64_C(4331744550238561793), UINT64_C(580167103971911567)},
        {/*234*/ UINT64_C(802994669370814337), UINT64_C(725208879964889459)},
        {/*235*/ UINT64_C(14838801391995681634), UINT64_C(906511099956111823)},
        {/*236*/ UINT64_C(13936815721567214139), UINT64_C(1133138874945139779)},
        {/*237*/ UINT64_C(6404666816765814884), UINT64_C(708211796840712362)},
        {/*238*/ UINT64_C(17229205557812044414), UINT64_C(885264746050890452)},
        {/*239*/ UINT64_C(3089762873555503901), UINT64_C(1106580932563613066)},
        {/*240*/ UINT64_C(6542787814399577842), UINT64_C(691613082852258166)},
        {/*241*/ UINT64_C(17401856804854248111), UINT64_C(864516353565322707)},
        {/*242*/ UINT64_C(17140634987640422235), UINT64_C(1080645441956653384)},
        {/*243*/ UINT64_C(10712896867275263896), UINT64_C(675403401222908365)},
        {/*244*/ UINT64_C(18002807102521467775), UINT64_C(844254251528635456)},
        {/*245*/ UINT64_C(4056764804442283102), UINT64_C(1055317814410794321)},
        {/*246*/ UINT64_C(14064693048844896699), UINT64_C(659573634006746450)},
        {/*247*/ UINT64_C(8357494274201345066), UINT64_C(824467042508433063)},
        {/*248*/ UINT64_C(5835181824324293428), UINT64_C(1030583803135541329)},
        {/*249*/ UINT64_C(15176203686271153152), UINT64_C(644114876959713330)},
        {/*250*/ UINT64_C(9746882570984165633), UINT64_C(805143596199641663)},
        {/*251*/ UINT64_C(7571917195302819137), UINT64_C(1006429495249552079)},
        {/*252*/ UINT64_C(11649977274705343816), UINT64_C(629018434530970049)},
        {/*253*/ UINT64_C(727413538099516059), UINT64_C(786273043163712562)},
        {/*254*/ UINT64_C(10132638959479170881), UINT64_C(982841303954640702)},
        {/*255*/ UINT64_C(1721213331247093897), UINT64_C(614275814971650439)},
        {/*256*/ UINT64_C(15986574719341031083), UINT64_C(767844768714563048)},
        {/*257*/ UINT64_C(1536474325466737238), UINT64_C(959805960893203811)},
        {/*258*/ UINT64_C(17101197517912568437), UINT64_C(599878725558252381)},
        {/*259*/ UINT64_C(7541438842108546835), UINT64_C(749848406947815477)},
        {/*260*/ UINT64_C(14038484571063071448), UINT64_C(937310508684769346)},
        {/*261*/ UINT64_C(13385738875341807559), UINT64_C(585819067927980841)},
        {/*262*/ UINT64_C(2897115538895095736), UINT64_C(732273834909976052)},
        {/*263*/ UINT64_C(3621394423618869671), UINT64_C(915342293637470065)},
        {/*264*/ UINT64_C(9138429047950974993), UINT64_C(1144177867046837581)},
        {/*265*/ UINT64_C(8017361164183053322), UINT64_C(715111166904273488)},
        {/*266*/ UINT64_C(10021701455228816653), UINT64_C(893888958630341860)},
        {/*267*/ UINT64_C(12527126819036020816), UINT64_C(1117361198287927325)},
        {/*268*/ UINT64_C(10135297271111206962), UINT64_C(698350748929954578)},
        {/*269*/ UINT64_C(3445749552034232895), UINT64_C(872938436162443223)},
        {/*270*/ UINT64_C(18142244995324954830), UINT64_C(1091173045203054028)},
        {/*271*/ UINT64_C(2115531085223320961), UINT64_C(681983153251908768)},
        {/*272*/ UINT64_C(2644413856529151201), UINT64_C(852478941564885960)},
        {/*273*/ UINT64_C(3305517320661439001), UINT64_C(1065598676956107450)},
        {/*274*/ UINT64_C(6677634343840787280), UINT64_C(665999173097567156)},
        {/*275*/ UINT64_C(8347042929800984100), UINT64_C(832498966371958945)},
        {/*276*/ UINT64_C(15045489680678618029), UINT64_C(1040623707964948681)},
        {/*277*/ UINT64_C(2485902022783054412), UINT64_C(650389817478092926)},
        {/*278*/ UINT64_C(12330749565333593823), UINT64_C(812987271847616157)},
        {/*279*/ UINT64_C(1578378901384828567), UINT64_C(1016234089809520197)},
        {/*280*/ UINT64_C(3292329822579211806), UINT64_C(635146306130950123)},
        {/*281*/ UINT64_C(17950470333506178470), UINT64_C(793932882663687653)},
        {/*282*/ UINT64_C(8603029861600559375), UINT64_C(992416103329609567)},
        {/*283*/ UINT64_C(12294422691141431465), UINT64_C(620260064581005979)},
        {/*284*/ UINT64_C(10756342345499401428), UINT64_C(775325080726257474)},
        {/*285*/ UINT64_C(4222055895019475977), UINT64_C(969156350907821843)},
        {/*286*/ UINT64_C(332941925173478533), UINT64_C(605722719317388652)},
        {/*287*/ UINT64_C(416177406466848167), UINT64_C(757153399146735815)},
        {/*288*/ UINT64_C(14355279813365723921), UINT64_C(946441748933419768)},
        {/*289*/ UINT64_C(8972049883353577450), UINT64_C(591526093083387355)},
        {/*290*/ UINT64_C(6603376335764583909), UINT64_C(739407616354234194)},
        {/*291*/ UINT64_C(17477592456560505694), UINT64_C(924259520442792742)},
        {/*292*/ UINT64_C(6311809266922928155), UINT64_C(577662200276745464)},
        {/*293*/ UINT64_C(7889761583653660193), UINT64_C(722077750345931830)},
        {/*294*/ UINT64_C(638829942712299434), UINT64_C(902597187932414788)},
        {/*295*/ UINT64_C(798537428390374293), UINT64_C(1128246484915518485)},
        {/*296*/ UINT64_C(2804928901957677885), UINT64_C(705154053072199053)},
        {/*297*/ UINT64_C(8117847145874485260), UINT64_C(881442566340248816)},
        {/*298*/ UINT64_C(10147308932343106575), UINT64_C(1101803207925311020)},
        {/*299*/ UINT64_C(15565440119569217417), UINT64_C(688627004953319387)},
        {/*300*/ UINT64_C(14845114131034133868), UINT64_C(860783756191649234)},
        {/*301*/ UINT64_C(9333020626937891527), UINT64_C(1075979695239561543)},
        {/*302*/ UINT64_C(12750666919477264060), UINT64_C(672487309524725964)},
        {/*303*/ UINT64_C(15938333649346580075), UINT64_C(840609136905907455)},
        {/*304*/ UINT64_C(15311231043255837190), UINT64_C(1050761421132384319)},
        {/*305*/ UINT64_C(16487048429675980100), UINT64_C(656725888207740199)},
        {/*306*/ UINT64_C(15997124518667587221), UINT64_C(820907360259675249)},
        {/*307*/ UINT64_C(6161347593052320314), UINT64_C(1026134200324594062)},
        {/*308*/ UINT64_C(17685900300939863908), UINT64_C(641333875202871288)},
        {/*309*/ UINT64_C(3660631302465278269), UINT64_C(801667344003589111)},
        {/*310*/ UINT64_C(18410847183363761549), UINT64_C(1002084180004486388)},
        {/*311*/ UINT64_C(2283407452747575160), UINT64_C(626302612502803993)},
        {/*312*/ UINT64_C(7465945334361856854), UINT64_C(782878265628504991)},
        {/*313*/ UINT64_C(4720745649524933163), UINT64_C(978597832035631239)},
        {/*314*/ UINT64_C(9867995058594165083), UINT64_C(611623645022269524)},
        {/*315*/ UINT64_C(12334993823242706354), UINT64_C(764529556277836905)},
        {/*316*/ UINT64_C(1583684223771219230), UINT64_C(955661945347296132)},
        {/*317*/ UINT64_C(10213174676711787827), UINT64_C(597288715842060082)},
        {/*318*/ UINT64_C(3543096309034958976), UINT64_C(746610894802575103)},
        {/*319*/ UINT64_C(18263928441575862432), UINT64_C(933263618503218878)},
        {/*320*/ UINT64_C(6803269257557526116), UINT64_C(583289761564511799)},
        {/*321*/ UINT64_C(3892400553519519741), UINT64_C(729112201955639749)},
        {/*322*/ UINT64_C(9477186710326787580), UINT64_C(911390252444549686)},
        {/*323*/ UINT64_C(2623111351053708667), UINT64_C(1139237815555687108)},
        {/*324*/ UINT64_C(10862816631263343725), UINT64_C(712023634722304442)},
        {/*325*/ UINT64_C(4355148752224403848), UINT64_C(890029543402880553)}
    };
    return &data[index][0];
  }

  static const uint64_t* greater_than_equals(int index) {
    static const uint64_t data[291][2] = {
        {/*  0*/ UINT64_C(0), UINT64_C(1152921504606846976)},
        {/*  1*/ UINT64_C(14757395258967641292), UINT64_C(922337203685477580)},
        {/*  2*/ UINT64_C(11805916207174113034), UINT64_C(737869762948382064)},
        {/*  3*/ UINT64_C(13134081780481200750), UINT64_C(590295810358705651)},
        {/*  4*/ UINT64_C(13635833219286100554), UINT64_C(944473296573929042)},
        {/*  5*/ UINT64_C(3529968945945059797), UINT64_C(755578637259143234)},
        {/*  6*/ UINT64_C(6513323971497958160), UINT64_C(604462909807314587)},
        {/*  7*/ UINT64_C(14110667169138643380), UINT64_C(967140655691703339)},
        {/*  8*/ UINT64_C(14977882550052825027), UINT64_C(773712524553362671)},
        {/*  9*/ UINT64_C(8292957225300349699), UINT64_C(618970019642690137)},
        {/* 10*/ UINT64_C(16958080375222469841), UINT64_C(990352031428304219)},
        {/* 11*/ UINT64_C(17255813114919886196), UINT64_C(792281625142643375)},
        {/* 12*/ UINT64_C(13804650491935908957), UINT64_C(633825300114114700)},
        {/* 13*/ UINT64_C(3640696713387902715), UINT64_C(1014120480182583521)},
        {/* 14*/ UINT64_C(17669952629677963465), UINT64_C(811296384146066816)},
        {/* 15*/ UINT64_C(10446613289000460449), UINT64_C(649037107316853453)},
        {/* 16*/ UINT64_C(13025232447658826395), UINT64_C(1038459371706965525)},
        {/* 17*/ UINT64_C(10420185958127061116), UINT64_C(830767497365572420)},
        {/* 18*/ UINT64_C(8336148766501648892), UINT64_C(664613997892457936)},
        {/* 19*/ UINT64_C(5959140396918817582), UINT64_C(1063382396627932698)},
        {/* 20*/ UINT64_C(12146009947018874712), UINT64_C(850705917302346158)},
        {/* 21*/ UINT64_C(17095505587098920416), UINT64_C(680564733841876926)},
        {/* 22*/ UINT64_C(1527367236164900403), UINT64_C(1088903574147003083)},
        {/* 23*/ UINT64_C(8600591418415740969), UINT64_C(871122859317602466)},
        {/* 24*/ UINT64_C(3191124319990682452), UINT64_C(696898287454081973)},
        {/* 25*/ UINT64_C(1416450097243181600), UINT64_C(1115037259926531157)},
        {/* 26*/ UINT64_C(12201206522020276249), UINT64_C(892029807941224925)},
        {/* 27*/ UINT64_C(9760965217616220999), UINT64_C(713623846352979940)},
        {/* 28*/ UINT64_C(15617544348185953599), UINT64_C(1141798154164767904)},
        {/* 29*/ UINT64_C(16183384293290673203), UINT64_C(913438523331814323)},
        {/* 30*/ UINT64_C(1878660990406807592), UINT64_C(730750818665451459)},
        {/* 31*/ UINT64_C(5192277607067356397), UINT64_C(584600654932361167)},
        {/* 32*/ UINT64_C(11996992986049680559), UINT64_C(935361047891777867)},
        {/* 33*/ UINT64_C(2218896759355923800), UINT64_C(748288838313422294)},
        {/* 34*/ UINT64_C(5464466222226649363), UINT64_C(598631070650737835)},
        {/* 35*/ UINT64_C(8743145955562638982), UINT64_C(957809713041180536)},
        {/* 36*/ UINT64_C(3305167949708200862), UINT64_C(766247770432944429)},
        {/* 37*/ UINT64_C(6333483174508471013), UINT64_C(612998216346355543)},
        {/* 38*/ UINT64_C(6444224264471643298), UINT64_C(980797146154168869)},
        {/* 39*/ UINT64_C(8844728226319224961), UINT64_C(784637716923335095)},
        {/* 40*/ UINT64_C(7075782581055379969), UINT64_C(627710173538668076)},
        {/* 41*/ UINT64_C(3942554500204787304), UINT64_C(1004336277661868922)},
        {/* 42*/ UINT64_C(14222090044389560813), UINT64_C(803469022129495137)},
        {/* 43*/ UINT64_C(3998974406027828004), UINT64_C(642775217703596110)},
        {/* 44*/ UINT64_C(6398359049644524806), UINT64_C(1028440348325753776)},
        {/* 45*/ UINT64_C(1429338424973709522), UINT64_C(822752278660603021)},
        {/* 46*/ UINT64_C(15900865998946608910), UINT64_C(658201822928482416)},
        {/* 47*/ UINT64_C(18062687968830753610), UINT64_C(1053122916685571866)},
        {/* 48*/ UINT64_C(10760801560322692565), UINT64_C(842498333348457493)},
        {/* 49*/ UINT64_C(15987338877741974698), UINT64_C(673998666678765994)},
        {/* 50*/ UINT64_C(14511695760161428548), UINT64_C(1078397866686025591)},
        {/* 51*/ UINT64_C(7920007793387232515), UINT64_C(862718293348820473)},
        {/* 52*/ UINT64_C(13714703864193606658), UINT64_C(690174634679056378)},
        {/* 53*/ UINT64_C(18254177367967860330), UINT64_C(1104279415486490205)},
        {/* 54*/ UINT64_C(14603341894374288264), UINT64_C(883423532389192164)},
        {/* 55*/ UINT64_C(15372022330241340934), UINT64_C(706738825911353731)},
        {/* 56*/ UINT64_C(17216538098902324849), UINT64_C(1130782121458165970)},
        {/* 57*/ UINT64_C(13773230479121859879), UINT64_C(904625697166532776)},
        {/* 58*/ UINT64_C(7329235568555577580), UINT64_C(723700557733226221)},
        {/* 59*/ UINT64_C(2174039640102551741), UINT64_C(578960446186580977)},
        {/* 60*/ UINT64_C(7167812238905993108), UINT64_C(926336713898529563)},
        {/* 61*/ UINT64_C(13112947420608615133), UINT64_C(741069371118823650)},
        {/* 62*/ UINT64_C(10490357936486892106), UINT64_C(592855496895058920)},
        {/* 63*/ UINT64_C(16784572698379027370), UINT64_C(948568795032094272)},
        {/* 64*/ UINT64_C(6048960529219401250), UINT64_C(758855036025675418)},
        {/* 65*/ UINT64_C(12217866052859341646), UINT64_C(607084028820540334)},
        {/* 66*/ UINT64_C(8480539240349215664), UINT64_C(971334446112864535)},
        {/* 67*/ UINT64_C(6784431392279372531), UINT64_C(777067556890291628)},
        {/* 68*/ UINT64_C(12806242743307318671), UINT64_C(621654045512233302)},
        {/* 69*/ UINT64_C(5732593130324068582), UINT64_C(994646472819573284)},
        {/* 70*/ UINT64_C(8275423319001165189), UINT64_C(795717178255658627)},
        {/* 71*/ UINT64_C(17688385099426663120), UINT64_C(636573742604526901)},
        {/* 72*/ UINT64_C(2475974455889288731), UINT64_C(1018517988167243043)},
        {/* 73*/ UINT64_C(9359477194195251631), UINT64_C(814814390533794434)},
        {/* 74*/ UINT64_C(11176930570098111628), UINT64_C(651851512427035547)},
        {/* 75*/ UINT64_C(3125693653189337312), UINT64_C(1042962419883256876)},
        {/* 76*/ UINT64_C(17257950181519111142), UINT64_C(834369935906605500)},
        {/* 77*/ UINT64_C(13806360145215288914), UINT64_C(667495948725284400)},
        {/* 78*/ UINT64_C(3643432158634910646), UINT64_C(1067993517960455041)},
        {/* 79*/ UINT64_C(17672140985875569810), UINT64_C(854394814368364032)},
        {/* 80*/ UINT64_C(6759015159216635201), UINT64_C(683515851494691226)},
        {/* 81*/ UINT64_C(3435726625262795676), UINT64_C(1093625362391505962)},
        {/* 82*/ UINT64_C(13816627744435967510), UINT64_C(874900289913204769)},
        {/* 83*/ UINT64_C(14742651010290684331), UINT64_C(699920231930563815)},
        {/* 84*/ UINT64_C(5141497542755543314), UINT64_C(1119872371088902105)},
        {/* 85*/ UINT64_C(4113198034204434651), UINT64_C(895897896871121684)},
        {/* 86*/ UINT64_C(6979907242105458044), UINT64_C(716718317496897347)},
        {/* 87*/ UINT64_C(14857200402110643194), UINT64_C(1146749307995035755)},
        {/* 88*/ UINT64_C(11885760321688514555), UINT64_C(917399446396028604)},
        {/* 89*/ UINT64_C(13197957072092721967), UINT64_C(733919557116822883)},
        {/* 90*/ UINT64_C(17937063287157998220), UINT64_C(587135645693458306)},
        {/* 91*/ UINT64_C(2873859556259424890), UINT64_C(939417033109533291)},
        {/* 92*/ UINT64_C(17056482903975181205), UINT64_C(751533626487626632)},
        {/* 93*/ UINT64_C(6266488693696324317), UINT64_C(601226901190101306)},
        {/* 94*/ UINT64_C(2647684280430298261), UINT64_C(961963041904162090)},
        {/* 95*/ UINT64_C(2118147424344238609), UINT64_C(769570433523329672)},
        {/* 96*/ UINT64_C(12762564383701121857), UINT64_C(615656346818663737)},
        {/* 97*/ UINT64_C(5662707754954153678), UINT64_C(985050154909861980)},
        {/* 98*/ UINT64_C(4530166203963322943), UINT64_C(788040123927889584)},
        {/* 99*/ UINT64_C(7313481777912568677), UINT64_C(630432099142311667)},
        {/*100*/ UINT64_C(15390919659402020207), UINT64_C(1008691358627698667)},
        {/*101*/ UINT64_C(4934038098037795519), UINT64_C(806953086902158934)},
        {/*102*/ UINT64_C(7636579293172146738), UINT64_C(645562469521727147)},
        {/*103*/ UINT64_C(15907875683817345105), UINT64_C(1032899951234763435)},
        {/*104*/ UINT64_C(12726300547053876084), UINT64_C(826319960987810748)},
        {/*105*/ UINT64_C(17559738067126921513), UINT64_C(661055968790248598)},
        {/*106*/ UINT64_C(5959488018951612482), UINT64_C(1057689550064397758)},
        {/*107*/ UINT64_C(12146288044645110632), UINT64_C(846151640051518206)},
        {/*108*/ UINT64_C(6027681620974178182), UINT64_C(676921312041214565)},
        {/*109*/ UINT64_C(9644290593558685092), UINT64_C(1083074099265943304)},
        {/*110*/ UINT64_C(11404781289588858397), UINT64_C(866459279412754643)},
        {/*111*/ UINT64_C(16502522661154907364), UINT64_C(693167423530203714)},
        {/*112*/ UINT64_C(15335989813622120813), UINT64_C(1109067877648325943)},
        {/*113*/ UINT64_C(1200745406671965681), UINT64_C(887254302118660755)},
        {/*114*/ UINT64_C(960596325337572544), UINT64_C(709803441694928604)},
        {/*115*/ UINT64_C(8915651750023936718), UINT64_C(1135685506711885766)},
        {/*116*/ UINT64_C(3443172585277239051), UINT64_C(908548405369508613)},
        {/*117*/ UINT64_C(10133235697705611887), UINT64_C(726838724295606890)},
        {/*118*/ UINT64_C(8106588558164489509), UINT64_C(581470979436485512)},
        {/*119*/ UINT64_C(16659890507805093539), UINT64_C(930353567098376819)},
        {/*120*/ UINT64_C(17017261220985985154), UINT64_C(744282853678701455)},
        {/*121*/ UINT64_C(13613808976788788123), UINT64_C(595426282942961164)},
        {/*122*/ UINT64_C(10714047918636330028), UINT64_C(952682052708737863)},
        {/*123*/ UINT64_C(15949935964392884668), UINT64_C(762145642166990290)},
        {/*124*/ UINT64_C(12759948771514307735), UINT64_C(609716513733592232)},
        {/*125*/ UINT64_C(5658522775455251083), UINT64_C(975546421973747572)},
        {/*126*/ UINT64_C(15594864664589931836), UINT64_C(780437137578998057)},
        {/*127*/ UINT64_C(5097194102188124822), UINT64_C(624349710063198446)},
        {/*128*/ UINT64_C(776812934017179069), UINT64_C(998959536101117514)},
        {/*129*/ UINT64_C(4310799161955653579), UINT64_C(799167628880894011)},
        {/*130*/ UINT64_C(18206034588532164156), UINT64_C(639334103104715208)},
        {/*131*/ UINT64_C(6993562453200000710), UINT64_C(1022934564967544334)},
        {/*132*/ UINT64_C(9284198777301910891), UINT64_C(818347651974035467)},
        {/*133*/ UINT64_C(48661392357708066), UINT64_C(654678121579228374)},
        {/*134*/ UINT64_C(7456555857256153553), UINT64_C(1047484994526765398)},
        {/*135*/ UINT64_C(13343942315288743489), UINT64_C(837987995621412318)},
        {/*136*/ UINT64_C(18053851481714815437), UINT64_C(670390396497129854)},
        {/*137*/ UINT64_C(17818115926517973730), UINT64_C(1072624634395407767)},
        {/*138*/ UINT64_C(6875795111730558338), UINT64_C(858099707516326214)},
        {/*139*/ UINT64_C(9189984904126356993), UINT64_C(686479766013060971)},
        {/*140*/ UINT64_C(7325278217118350543), UINT64_C(1098367625620897554)},
        {/*141*/ UINT64_C(9549571388436590758), UINT64_C(878694100496718043)},
        {/*142*/ UINT64_C(15018354740233093252), UINT64_C(702955280397374434)},
        {/*143*/ UINT64_C(12961321140147218235), UINT64_C(1124728448635799095)},
        {/*144*/ UINT64_C(10369056912117774588), UINT64_C(899782758908639276)},
        {/*145*/ UINT64_C(4605896714952309347), UINT64_C(719826207126911421)},
        {/*146*/ UINT64_C(18437481188149425925), UINT64_C(1151721931403058273)},
        {/*147*/ UINT64_C(3681938506293809770), UINT64_C(921377545122446619)},
        {/*148*/ UINT64_C(6634899619776958139), UINT64_C(737102036097957295)},
        {/*149*/ UINT64_C(5307919695821566511), UINT64_C(589681628878365836)},
        {/*150*/ UINT64_C(1113973883830685772), UINT64_C(943490606205385338)},
        {/*151*/ UINT64_C(8269876736548369264), UINT64_C(754792484964308270)},
        {/*152*/ UINT64_C(6615901389238695411), UINT64_C(603833987971446616)},
        {/*153*/ UINT64_C(3206744593298092011), UINT64_C(966134380754314586)},
        {/*154*/ UINT64_C(17322790933606114902), UINT64_C(772907504603451668)},
        {/*155*/ UINT64_C(2790186302659160952), UINT64_C(618326003682761335)},
        {/*156*/ UINT64_C(4464298084254657523), UINT64_C(989321605892418136)},
        {/*157*/ UINT64_C(18328833726371367311), UINT64_C(791457284713934508)},
        {/*158*/ UINT64_C(3595020536871362879), UINT64_C(633165827771147607)},
        {/*159*/ UINT64_C(9441381673736090930), UINT64_C(1013065324433836171)},
        {/*160*/ UINT64_C(3863756524246962421), UINT64_C(810452259547068937)},
        {/*161*/ UINT64_C(14159051663623300906), UINT64_C(648361807637655149)},
        {/*162*/ UINT64_C(11586436217571550481), UINT64_C(1037378892220248239)},
        {/*163*/ UINT64_C(12958497788799150708), UINT64_C(829903113776198591)},
        {/*164*/ UINT64_C(6677449416297410243), UINT64_C(663922491020958873)},
        {/*165*/ UINT64_C(6994570251333946066), UINT64_C(1062275985633534197)},
        {/*166*/ UINT64_C(16663702645292887822), UINT64_C(849820788506827357)},
        {/*167*/ UINT64_C(5952264486750489611), UINT64_C(679856630805461886)},
        {/*168*/ UINT64_C(2144925549316962732), UINT64_C(1087770609288739018)},
        {/*169*/ UINT64_C(9094638068937390832), UINT64_C(870216487430991214)},
        {/*170*/ UINT64_C(10965059269891822988), UINT64_C(696173189944792971)},
        {/*171*/ UINT64_C(10165397202343096135), UINT64_C(1113877103911668754)},
        {/*172*/ UINT64_C(11821666576616387231), UINT64_C(891101683129335003)},
        {/*173*/ UINT64_C(16836030890776930431), UINT64_C(712881346503468002)},
        {/*174*/ UINT64_C(12180254166275447398), UINT64_C(1140610154405548804)},
        {/*175*/ UINT64_C(13433552147762268241), UINT64_C(912488123524439043)},
        {/*176*/ UINT64_C(18125539347693635239), UINT64_C(729990498819551234)},
        {/*177*/ UINT64_C(18189780292896818515), UINT64_C(583992399055640987)},
        {/*178*/ UINT64_C(14346253209667268331), UINT64_C(934387838489025580)},
        {/*179*/ UINT64_C(11477002567733814665), UINT64_C(747510270791220464)},
        {/*180*/ UINT64_C(12870950868928962055), UINT64_C(598008216632976371)},
        {/*181*/ UINT64_C(13214823760802518641), UINT64_C(956813146612762194)},
        {/*182*/ UINT64_C(14261207823383925236), UINT64_C(765450517290209755)},
        {/*183*/ UINT64_C(11408966258707140189), UINT64_C(612360413832167804)},
        {/*184*/ UINT64_C(7186299569705693333), UINT64_C(979776662131468487)},
        {/*185*/ UINT64_C(16817086099990285636), UINT64_C(783821329705174789)},
        {/*186*/ UINT64_C(17143017694734138832), UINT64_C(627057063764139831)},
        {/*187*/ UINT64_C(1603386608381249869), UINT64_C(1003291302022623731)},
        {/*188*/ UINT64_C(16040104545672641188), UINT64_C(802633041618098984)},
        {/*189*/ UINT64_C(16521432451280023273), UINT64_C(642106433294479187)},
        {/*190*/ UINT64_C(11676896663080395945), UINT64_C(1027370293271166700)},
        {/*191*/ UINT64_C(9341517330464316756), UINT64_C(821896234616933360)},
        {/*192*/ UINT64_C(7473213864371453404), UINT64_C(657516987693546688)},
        {/*193*/ UINT64_C(8267793368252415124), UINT64_C(1052027180309674701)},
        {/*194*/ UINT64_C(2924885879860021776), UINT64_C(841621744247739761)},
        {/*195*/ UINT64_C(17097303962855658714), UINT64_C(673297395398191808)},
        {/*196*/ UINT64_C(5219593452117592003), UINT64_C(1077275832637106894)},
        {/*197*/ UINT64_C(7865023576435983925), UINT64_C(861820666109685515)},
        {/*198*/ UINT64_C(6292018861148787140), UINT64_C(689456532887748412)},
        {/*199*/ UINT64_C(13756578992579969748), UINT64_C(1103130452620397459)},
        {/*200*/ UINT64_C(14694612008805886121), UINT64_C(882504362096317967)},
        {/*201*/ UINT64_C(4376991977560888251), UINT64_C(706003489677054374)},
        {/*202*/ UINT64_C(14381884793581241848), UINT64_C(1129605583483286998)},
        {/*203*/ UINT64_C(437461390639262508), UINT64_C(903684466786629599)},
        {/*204*/ UINT64_C(4039317927253320330), UINT64_C(722947573429303679)},
        {/*205*/ UINT64_C(6920803156544566587), UINT64_C(578358058743442943)},
        {/*206*/ UINT64_C(7383936235729396216), UINT64_C(925372893989508709)},
        {/*207*/ UINT64_C(9596497803325427296), UINT64_C(740298315191606967)},
        {/*208*/ UINT64_C(298500613176521190), UINT64_C(592238652153285574)},
        {/*209*/ UINT64_C(7856298610566254551), UINT64_C(947581843445256918)},
        {/*210*/ UINT64_C(13663736517936824287), UINT64_C(758065474756205534)},
        {/*211*/ UINT64_C(14620338029091369753), UINT64_C(606452379804964427)},
        {/*212*/ UINT64_C(8635145587578550312), UINT64_C(970323807687943084)},
        {/*213*/ UINT64_C(10597465284804750573), UINT64_C(776259046150354467)},
        {/*214*/ UINT64_C(1099274598359979812), UINT64_C(621007236920283574)},
        {/*215*/ UINT64_C(9137536986859788346), UINT64_C(993611579072453718)},
        {/*216*/ UINT64_C(14688727218971651323), UINT64_C(794889263257962974)},
        {/*217*/ UINT64_C(15440330589919231381), UINT64_C(635911410606370379)},
        {/*218*/ UINT64_C(13636482499645039241), UINT64_C(1017458256970192607)},
        {/*219*/ UINT64_C(3530488370232210746), UINT64_C(813966605576154086)},
        {/*220*/ UINT64_C(17581785955153409890), UINT64_C(651173284460923268)},
        {/*221*/ UINT64_C(5994764639793993884), UINT64_C(1041877255137477230)},
        {/*222*/ UINT64_C(4795811711835195107), UINT64_C(833501804109981784)},
        {/*223*/ UINT64_C(7525998184210066409), UINT64_C(666801443287985427)},
        {/*224*/ UINT64_C(15730945909478016578), UINT64_C(1066882309260776683)},
        {/*225*/ UINT64_C(1516710283356682293), UINT64_C(853505847408621347)},
        {/*226*/ UINT64_C(12281414670911076804), UINT64_C(682804677926897077)},
        {/*227*/ UINT64_C(4892868214490081593), UINT64_C(1092487484683035324)},
        {/*228*/ UINT64_C(7603643386333975598), UINT64_C(873989987746428259)},
        {/*229*/ UINT64_C(9772263523809090801), UINT64_C(699191990197142607)},
        {/*230*/ UINT64_C(878226379126903990), UINT64_C(1118707184315428172)},
        {/*231*/ UINT64_C(11770627547527254161), UINT64_C(894965747452342537)},
        {/*232*/ UINT64_C(2037804408537982682), UINT64_C(715972597961874030)},
        {/*233*/ UINT64_C(3260487053660772292), UINT64_C(1145556156738998448)},
        {/*234*/ UINT64_C(9987087272412438480), UINT64_C(916444925391198758)},
        {/*235*/ UINT64_C(15368367447413771430), UINT64_C(733155940312959006)},
        {/*236*/ UINT64_C(8605345143189106821), UINT64_C(586524752250367205)},
        {/*237*/ UINT64_C(13768552229102570914), UINT64_C(938439603600587528)},
        {/*238*/ UINT64_C(18393539412765877377), UINT64_C(750751682880470022)},
        {/*239*/ UINT64_C(7336133900728881255), UINT64_C(600601346304376018)},
        {/*240*/ UINT64_C(8048465426424299686), UINT64_C(960962154087001629)},
        {/*241*/ UINT64_C(10128121155881350072), UINT64_C(768769723269601303)},
        {/*242*/ UINT64_C(15481194554188900704), UINT64_C(615015778615681042)},
        {/*243*/ UINT64_C(10012516027734599833), UINT64_C(984025245785089668)},
        {/*244*/ UINT64_C(15388710451671500513), UINT64_C(787220196628071734)},
        {/*245*/ UINT64_C(16000317176079110734), UINT64_C(629776157302457387)},
        {/*246*/ UINT64_C(10843112222758935881), UINT64_C(1007641851683931820)},
        {/*247*/ UINT64_C(8674489778207148705), UINT64_C(806113481347145456)},
        {/*248*/ UINT64_C(3250243007823808641), UINT64_C(644890785077716365)},
        {/*249*/ UINT64_C(5200388812518093825), UINT64_C(1031825256124346184)},
        {/*250*/ UINT64_C(7849659864756385383), UINT64_C(825460204899476947)},
        {/*251*/ UINT64_C(17347774336030839276), UINT64_C(660368163919581557)},
        {/*252*/ UINT64_C(12999043678681701549), UINT64_C(1056589062271330492)},
        {/*253*/ UINT64_C(3020537313461540593), UINT64_C(845271249817064394)},
        {/*254*/ UINT64_C(6105778665511142797), UINT64_C(676216999853651515)},
        {/*255*/ UINT64_C(9769245864817828476), UINT64_C(1081947199765842424)},
        {/*256*/ UINT64_C(11504745506596173104), UINT64_C(865557759812673939)},
        {/*257*/ UINT64_C(12893145220018848806), UINT64_C(692446207850139151)},
        {/*258*/ UINT64_C(13250334722546337444), UINT64_C(1107913932560222642)},
        {/*259*/ UINT64_C(3221570148553249309), UINT64_C(886331146048178114)},
        {/*260*/ UINT64_C(6266604933584509770), UINT64_C(709064916838542491)},
        {/*261*/ UINT64_C(2647870264251394986), UINT64_C(1134503866941667986)},
        {/*262*/ UINT64_C(16875691470368757282), UINT64_C(907603093553334388)},
        {/*263*/ UINT64_C(2432506732069274856), UINT64_C(726082474842667511)},
        {/*264*/ UINT64_C(16703400644623061177), UINT64_C(580865979874134008)},
        {/*265*/ UINT64_C(4589348142945435944), UINT64_C(929385567798614414)},
        {/*266*/ UINT64_C(7360827329098259079), UINT64_C(743508454238891531)},
        {/*267*/ UINT64_C(2199313048536696940), UINT64_C(594806763391113225)},
        {/*268*/ UINT64_C(3518900877658715104), UINT64_C(951690821425781160)},
        {/*269*/ UINT64_C(2815120702126972083), UINT64_C(761352657140624928)},
        {/*270*/ UINT64_C(9630794191185398313), UINT64_C(609082125712499942)},
        {/*271*/ UINT64_C(651875446928996008), UINT64_C(974531401139999908)},
        {/*272*/ UINT64_C(7900197987027017452), UINT64_C(779625120911999926)},
        {/*273*/ UINT64_C(2630809574879703639), UINT64_C(623700096729599941)},
        {/*274*/ UINT64_C(15277341764033256792), UINT64_C(997920154767359905)},
        {/*275*/ UINT64_C(12221873411226605433), UINT64_C(798336123813887924)},
        {/*276*/ UINT64_C(13466847543723194670), UINT64_C(638668899051110339)},
        {/*277*/ UINT64_C(10478909625731380502), UINT64_C(1021870238481776543)},
        {/*278*/ UINT64_C(15761825330068925048), UINT64_C(817496190785421234)},
        {/*279*/ UINT64_C(16298809078797050362), UINT64_C(653996952628336987)},
        {/*280*/ UINT64_C(11320699267107639286), UINT64_C(1046395124205339180)},
        {/*281*/ UINT64_C(9056559413686111429), UINT64_C(837116099364271344)},
        {/*282*/ UINT64_C(10934596345690799466), UINT64_C(669692879491417075)},
        {/*283*/ UINT64_C(17495354153105279146), UINT64_C(1071508607186267320)},
        {/*284*/ UINT64_C(13996283322484223317), UINT64_C(857206885749013856)},
        {/*285*/ UINT64_C(7507677843245468330), UINT64_C(685765508599211085)},
        {/*286*/ UINT64_C(12012284549192749328), UINT64_C(1097224813758737736)},
        {/*287*/ UINT64_C(5920478824612289139), UINT64_C(877779851006990189)},
        {/*288*/ UINT64_C(8425731874431741635), UINT64_C(702223880805592151)},
        {/*289*/ UINT64_C(6102473369606965969), UINT64_C(1123558209288947442)},
        {/*290*/ UINT64_C(15950025139911303745), UINT64_C(898846567431157953)}
    };
    return &data[index][0];
  }
};

template <> struct cache_values<float> {
  constexpr static const int b0 = 59;
  constexpr static const int b1 = 61;

  static const uint64_t* less_than(int index) {
    static const uint64_t data[48] = {
        /*  0*/ UINT64_C(2305843009213693952), /*  1*/ UINT64_C(1441151880758558720),
        /*  2*/ UINT64_C(1801439850948198400), /*  3*/ UINT64_C(2251799813685248000),
        /*  4*/ UINT64_C(1407374883553280000), /*  5*/ UINT64_C(1759218604441600000),
        /*  6*/ UINT64_C(2199023255552000000), /*  7*/ UINT64_C(1374389534720000000),
        /*  8*/ UINT64_C(1717986918400000000), /*  9*/ UINT64_C(2147483648000000000),
        /* 10*/ UINT64_C(1342177280000000000), /* 11*/ UINT64_C(1677721600000000000),
        /* 12*/ UINT64_C(2097152000000000000), /* 13*/ UINT64_C(1310720000000000000),
        /* 14*/ UINT64_C(1638400000000000000), /* 15*/ UINT64_C(2048000000000000000),
        /* 16*/ UINT64_C(1280000000000000000), /* 17*/ UINT64_C(1600000000000000000),
        /* 18*/ UINT64_C(2000000000000000000), /* 19*/ UINT64_C(1250000000000000000),
        /* 20*/ UINT64_C(1562500000000000000), /* 21*/ UINT64_C(1953125000000000000),
        /* 22*/ UINT64_C(1220703125000000000), /* 23*/ UINT64_C(1525878906250000000),
        /* 24*/ UINT64_C(1907348632812500000), /* 25*/ UINT64_C(1192092895507812500),
        /* 26*/ UINT64_C(1490116119384765625), /* 27*/ UINT64_C(1862645149230957031),
        /* 28*/ UINT64_C(1164153218269348144), /* 29*/ UINT64_C(1455191522836685180),
        /* 30*/ UINT64_C(1818989403545856475), /* 31*/ UINT64_C(2273736754432320594),
        /* 32*/ UINT64_C(1421085471520200371), /* 33*/ UINT64_C(1776356839400250464),
        /* 34*/ UINT64_C(2220446049250313080), /* 35*/ UINT64_C(1387778780781445675),
        /* 36*/ UINT64_C(1734723475976807094), /* 37*/ UINT64_C(2168404344971008868),
        /* 38*/ UINT64_C(1355252715606880542), /* 39*/ UINT64_C(1694065894508600678),
        /* 40*/ UINT64_C(2117582368135750847), /* 41*/ UINT64_C(1323488980084844279),
        /* 42*/ UINT64_C(1654361225106055349), /* 43*/ UINT64_C(2067951531382569187),
        /* 44*/ UINT64_C(1292469707114105741), /* 45*/ UINT64_C(1615587133892632177),
        /* 46*/ UINT64_C(2019483917365790221), /* 47*/ UINT64_C(1262177448353618888)
    };
    return &data[index];
  }

  static const uint64_t* greater_than_equals(int index) {
    static const uint64_t data[30] = {
        /*  0*/ UINT64_C(576460752303423488), /*  1*/ UINT64_C(461168601842738790),
        /*  2*/ UINT64_C(368934881474191032), /*  3*/ UINT64_C(295147905179352825),
        /*  4*/ UINT64_C(472236648286964521), /*  5*/ UINT64_C(377789318629571617),
        /*  6*/ UINT64_C(302231454903657293), /*  7*/ UINT64_C(483570327845851669),
        /*  8*/ UINT64_C(386856262276681335), /*  9*/ UINT64_C(309485009821345068),
        /* 10*/ UINT64_C(495176015714152109), /* 11*/ UINT64_C(396140812571321687),
        /* 12*/ UINT64_C(316912650057057350), /* 13*/ UINT64_C(507060240091291760),
        /* 14*/ UINT64_C(405648192073033408), /* 15*/ UINT64_C(324518553658426726),
        /* 16*/ UINT64_C(519229685853482762), /* 17*/ UINT64_C(415383748682786210),
        /* 18*/ UINT64_C(332306998946228968), /* 19*/ UINT64_C(531691198313966349),
        /* 20*/ UINT64_C(425352958651173079), /* 21*/ UINT64_C(340282366920938463),
        /* 22*/ UINT64_C(544451787073501541), /* 23*/ UINT64_C(435561429658801233),
        /* 24*/ UINT64_C(348449143727040986), /* 25*/ UINT64_C(557518629963265578),
        /* 26*/ UINT64_C(446014903970612462), /* 27*/ UINT64_C(356811923176489970),
        /* 28*/ UINT64_C(570899077082383952), /* 29*/ UINT64_C(456719261665907161)
    };
    return &data[index];
  }
};

constexpr static const double log_10_2 = 0.30102999566398114;
constexpr static const double log_10_5 = 0.6989700043360189;
constexpr static const double log_2_5 = 2.321928094887362;

template <typename T> inline void normalize(int& exp, uint64_t& mentissa) {
  if (exp) {
    mentissa += uint64_t(1) << float_info<T>::mentissa_width();
    exp = exp - float_info<T>::bias() - float_info<T>::mentissa_width();
  } else {
    exp = 1 - float_info<T>::bias() - float_info<T>::mentissa_width();
  }
}

inline void compute_shortest(
    uint64_t a, uint64_t b, uint64_t c, bool accept_smaller, bool accept_larger, bool break_tie_down,
    int& exponent_adjuster, uint64_t& shortest_base10
) {
  int i = 0;
  if (!accept_larger) {
    c -= 1;
  }

  bool all_a_zero = true;
  bool all_b_zero = true;
  uint64_t a_next = a / 10;
  uint32_t a_remainder = a % 10;
  uint64_t b_next = b / 10;
  uint32_t b_remainder = b % 10;
  uint64_t c_next = c / 10;
  while (a_next < c_next) {
    a_remainder = a % 10;
    b_remainder = b % 10;

    all_b_zero &= bool(!b_remainder);
    all_a_zero &= bool(!a_remainder);

    a = a_next;
    b = b_next;
    c = c_next;
    a_next = a / 10;
    b_next = b / 10;
    c_next = c / 10;
    i++;
  }
  if (accept_smaller && all_a_zero && a % 10 == 0) {
    while (!(a_next % 10)) {
      b_remainder = b % 10;

      all_b_zero &= bool(!b_remainder);

      a = a_next;
      b = b_next;
      c = c_next;
      a_next = a / 10;
      b_next = b / 10;
      c_next = c / 10;
      i++;
    }
  }
  exponent_adjuster = i;

  bool is_tie = b_remainder == 5 && all_b_zero;
  bool want_to_round_down = b_remainder < 5 || (is_tie && break_tie_down);
  bool round_down = (want_to_round_down && (a != b || all_a_zero)) || (b + 1 > c);
  if (round_down) {
    shortest_base10 = b;
  } else {
    shortest_base10 = b + 1;
  }
}

template <typename T>
inline uint64_t multiply_and_shift(uint64_t a, const uint64_t* b, int shift_right, bool round_up) {
  (void) a;
  (void) b;
  (void) shift_right;
  (void) round_up;
  return 0;
}
template <> inline uint64_t multiply_and_shift<double>(uint64_t a, const uint64_t* b, int shift_right, bool round_up) {
  uint64_t a0, a1, b0, b1, b2, b3, a0b0, a0b1, a0b2, a0b3, a1b0, a1b1, a1b2, a1b3;
  a0 = low(a);
  a1 = high(a);
  b0 = low(b[0]);
  b1 = high(b[0]);
  b2 = low(b[1]);
  b3 = high(b[1]);

  a0b0 = a0 * b0;
  a0b1 = a0 * b1;
  a0b2 = a0 * b2;
  a0b3 = a0 * b3;
  a1b0 = a1 * b0;
  a1b1 = a1 * b1;
  a1b2 = a1 * b2;
  a1b3 = a1 * b3;

  uint64_t result[6];
  result[0] = low(a0b0);
  result[1] = low(a0b1) + low(a1b0) + high(a0b0);
  result[2] = low(a0b2) + low(a1b1) + high(a0b1) + high(a1b0);
  result[3] = low(a0b3) + low(a1b2) + high(a0b2) + high(a1b1);
  result[4] = a1b3 + high(a0b3) + high(a1b2);

  result[1] += high(result[0]);
  result[2] += high(result[1]);
  result[3] += high(result[2]);
  result[4] += high(result[3]);
  result[5] = high(result[4]);

  uint64_t ret[4];
  ret[0] = low(result[0]) | ((low(result[1]) << 32) + high(result[0]));
  ret[1] = low(result[2]) | (low(result[3]) << 32);
  ret[2] = low(result[4]) | (low(result[5]) << 32);

  int index = shift_right / 64;
  int shift_right_in_index = shift_right - (index * 64);
  if (round_up) {
    if (shift_right_in_index) {
      if (!(ret[index] & (uint64_t(1) << (shift_right_in_index - 1)))) {
        round_up = false;
      }
    } else {
      if (!(index > 0 && ret[index] & uint64_t(1) << 63)) {
        round_up = false;
      }
    }
  }
  ret[index] >>= shift_right_in_index;
  ret[index] |= (ret[index + 1] & ((uint64_t(1) << shift_right_in_index) - 1)) << (64 - shift_right_in_index);
  ret[index] += round_up;
  return ret[index];
}

template <> inline uint64_t multiply_and_shift<float>(uint64_t a, const uint64_t* b, int shift_right, bool round_up) {
  uint64_t a0, a1, b0, b1, a0b0, a0b1, a1b0, a1b1;
  a0 = low(a);
  a1 = high(a);
  b0 = low(*b);
  b1 = high(*b);

  a0b0 = a0 * b0;
  a0b1 = a0 * b1;
  a1b0 = a1 * b0;
  a1b1 = a1 * b1;

  uint64_t result[4] = {};
  result[0] = low(a0b0);
  result[1] = low(a0b1) + low(a1b0) + high(a0b0);
  result[2] = low(a1b1) + high(a0b1) + high(a1b0);
  result[3] = high(a1b1);

  result[1] += high(result[0]);
  result[2] += high(result[1]);
  result[3] += high(result[2]);

  uint64_t ret[4];
  ret[0] = low(result[0]) | ((low(result[1]) << 32) + high(result[0]));
  ret[1] = low(result[2]) | (low(result[3]) << 32);

  int index = shift_right / 64;
  int shift_right_in_index = shift_right - (index * 64);
  if (round_up) {
    if (shift_right_in_index) {
      if (!(ret[index] & (uint64_t(1) << (shift_right_in_index - 1)))) {
        round_up = false;
      }
    } else {
      if (!(index > 0 && ret[index] & uint64_t(1) << 63)) {
        round_up = false;
      }
    }
  }
  ret[index] >>= shift_right_in_index;
  ret[index] |= (ret[index + 1] & ((uint64_t(1) << shift_right_in_index) - 1)) << (64 - shift_right_in_index);
  ret[index] += round_up;
  return ret[index];
}

inline uint64_t pow_int(int n, int exp) {
  if (!exp) {
    return 1;
  }
  uint64_t ret = uint64_t(n);
  for (int i = 0; i < exp; i++) {
    ret *= ret;
  }
  return ret;
}

template <typename T, typename SignificandType> static float_base10<SignificandType> decode(T f) {
  bool negative;
  int exp;
  uint64_t mentissa;
  get_parts(f, negative, exp, mentissa);
  bool shift_u_with_one = mentissa == 0 && exp > 1;

  if (is_nan(f)) {
    return {negative, false, true, 0, 0, 0};
  }
  if (is_inf(f)) {
    return {negative, true, false, 0, 0, 0};
  }
  if (!exp && !mentissa) {
    return {negative, false, false, 1, 0, 0};
  }

  bool accept_larger = (mentissa % 2 == 0);
  bool accept_smaller = accept_larger;

  normalize<T>(exp, mentissa);

  exp -= 2;
  mentissa *= 4;

  uint64_t u = mentissa;
  if (shift_u_with_one) {
    u -= 1;
  } else {
    u -= 2;
  }

  uint64_t w = mentissa + 2;

  int e10 = exp < 0 ? exp : 0;

  int q;
  int shift_right;
  bool zero[3] = {};
  if (exp >= 0) {
    q = max(0, int(exp * log_10_2) - 1);
    int k = cache_values<T>::b0 + int(q * log_2_5);
    shift_right = -exp + q + k;
    if (q - 1 <= float_info<T>::max_double_5_pow_q()) {
      uint64_t mod = pow_int(5, q - 1);
      if (mod) {
        zero[1] = (mentissa % mod) == 0;
      }
      if (q <= float_info<T>::max_double_5_pow_q()) {
        mod = pow_int(5, q);
        zero[0] = (u % mod) == 0;
        zero[2] = (w % mod) == 0;
      }
    }
  } else {
    q = max(0, int(-exp * log_10_5) - 1);
    int k = int(std::ceil((double(-exp) - double(q)) * log_2_5)) - cache_values<T>::b1;
    shift_right = q - k;
    if (q && q - 1 <= float_info<T>::max_double_2_pow_q()) {
      uint64_t mod = uint64_t(1) << int(q - 1);
      zero[1] = (mentissa % mod) == 0;

      if (q <= float_info<T>::max_double_2_pow_q()) {
        mod <<= 1;
        if (mod) {
          zero[0] = (u % mod) == 0;
          zero[2] = (w % mod) == 0;
        }
      }
    }
  }
  auto cache_value = exp >= 0 ? cache_values<T>::greater_than_equals(q) : cache_values<T>::less_than(-exp - q);
  uint64_t a = multiply_and_shift<T>(u, cache_value, shift_right, true);
  uint64_t b = multiply_and_shift<T>(mentissa, cache_value, shift_right, false);
  uint64_t c = multiply_and_shift<T>(w, cache_value, shift_right, false);

  int exponent_adjust;
  uint64_t shortest_base10;
  compute_shortest(
      a, b, c, accept_smaller && zero[0], accept_larger || !zero[2], zero[1], exponent_adjust, shortest_base10
  );
  int significand_digit_count = count_chars(shortest_base10);
  int e = exponent_adjust + e10 + q;
  return {negative, false, false, uint8_t(significand_digit_count), e, shortest_base10};
}

template <typename T>
inline int convert_parsed_to_buffer(
    const float_base10<T>& result, char* buffer, int buffer_size, int max_expanded_length,
    int* digits_truncated = nullptr
) {
  if (buffer_size < 1) {
    return 0;
  }
  int offset = 0;
  if (result.nan) {
    if (buffer_size >= 3) {
      buffer[offset++] = 'n';
      buffer[offset++] = 'a';
      buffer[offset++] = 'n';
    }
    return offset;
  }

  if (result.negative) {
    buffer[offset++] = '-';
    buffer_size--;
  }

  if (result.inf) {
    if (buffer_size >= 3) {
      buffer[offset++] = 'i';
      buffer[offset++] = 'n';
      buffer[offset++] = 'f';
    }
    return offset;
  }

  char significan_buffer[17] = {};
  assert(result.significand_digit_count <= uint8_t(17));
  int digits_before_decimals = result.significand_digit_count + result.exp;
  int digits_after_decimals = result.exp < 0 ? -result.exp : 0;
  int complete_digits = max(1, digits_before_decimals) + max(1, digits_after_decimals) + 1;
  if (complete_digits < max_expanded_length) {
    char* target_buffer = buffer + offset;
    uint64_t significand = result.significand;
    bool print_desimal_seperator = true;
    if (buffer_size < complete_digits) {
      int to_remove = complete_digits - buffer_size;
      if (digits_truncated) {
        *digits_truncated = to_remove;
      }

      int to_remove_after_decimals = std::min(to_remove, digits_after_decimals);
      for (int i = 0; i < to_remove_after_decimals; i++) {
        complete_digits--;
        digits_after_decimals--;
        significand /= 10;
      }
      to_remove -= to_remove_after_decimals;
      if (to_remove > 0) {
        print_desimal_seperator = false;
        if (!digits_after_decimals) {
          complete_digits--;
          to_remove--;
        }
        complete_digits--;
        to_remove--;
        if (to_remove > 0) {
          int to_remove_before_decimals = std::min(to_remove, digits_before_decimals);
          for (int i = 0; i < to_remove_before_decimals; i++) {
            complete_digits--;
            digits_before_decimals--;
            significand /= 10;
          }
        }
      } else if (to_remove == 0 && digits_after_decimals == 0) {
        print_desimal_seperator = false;
        complete_digits--;
      }
    }
    int index_pos = std::max(complete_digits - 1, 0);
    for (int i = 0; i < digits_after_decimals; i++, index_pos--) {
      char remainder = char(significand % 10);
      significand /= 10;
      target_buffer[index_pos] = '0' + remainder;
    }
    if (print_desimal_seperator) {
      if (digits_after_decimals == 0) {
        target_buffer[index_pos--] = '0';
      }
      target_buffer[index_pos--] = '.';
    }
    int add_zeros_before_decimal = std::max(result.exp, 0);
    for (int i = 0; i < add_zeros_before_decimal; i++, index_pos--) {
      target_buffer[index_pos] = '0';
      digits_before_decimals--;
    }
    for (int i = 0; i < digits_before_decimals; i++, index_pos--) {
      char remainder = char(significand % 10);
      significand /= 10;
      target_buffer[index_pos] = '0' + remainder;
    }
    if (digits_before_decimals <= 0) {
      target_buffer[index_pos] = '0';
    }
    return complete_digits + offset;
  } else {
    uint64_t significand = result.significand;
    int exp = result.exp;
    for (int i = 0; i < result.significand_digit_count; i++) {
      significan_buffer[result.significand_digit_count - i - 1] = '0' + significand % 10;
      significand /= 10;
    }

    exp += result.significand_digit_count;
    exp--;
    char exponent_buffer[4] = {};
    int exponent_digit_count = count_chars(exp);
    if (exp < 0) {
      exponent_buffer[0] = '-';
    }
    int abs_exp = std::abs(exp);
    for (int i = 0; i < exponent_digit_count; i++) {
      exponent_buffer[exponent_digit_count + (exp < 0) - i - 1] = '0' + abs_exp % 10;
      abs_exp /= 10;
    }
    exponent_digit_count += exp < 0;

    if (offset < buffer_size) {
      buffer[offset++] = significan_buffer[0];
    } else {
      return offset;
    }

    if (result.significand_digit_count > 1) {
      if (offset < buffer_size) {
        buffer[offset++] = '.';
      } else {
        return offset;
      }
    }
    int to_copy = min(buffer_size - offset, int(result.significand_digit_count) - 1);
    for (int i = 0; i < to_copy; i++) {
      buffer[offset++] = significan_buffer[1 + i];
    }

    if (offset >= buffer_size) {
      return offset;
    }

    buffer[offset++] = 'e';

    to_copy = min(buffer_size - offset, exponent_digit_count);
    for (int i = 0; i < to_copy; i++) {
      buffer[offset++] = exponent_buffer[i];
    }
  }

  return offset;
}

} // namespace ryu

template <typename T> struct set_end_ptr {
  set_end_ptr(parsed_string<T>& parsedString, const char*& current) : parsedString(parsedString), current(current) {}
  ~set_end_ptr() { parsedString.endptr = current; }
  parsed_string<T>& parsedString;
  const char*& current;
};

inline bool is_space(char a) {
  if (a == 0x20 || a == 0x09 || a == 0x0a || a == 0x0b || a == 0x0c || a == 0x0d) {
    return true;
  }
  return false;
}

template <typename T, bool NoDigitCount>
inline parse_string_error parseNumber(const char* number, size_t size, parsed_string<T>& parsedString) {
  const char* current;
  set_end_ptr<T> setendptr(parsedString, current);
  int desimal_position = -1;
  bool increase_significand = true;

  parsedString.negative = 0;
  parsedString.inf = 0;
  parsedString.nan = 0;
  parsedString.significand_digit_count = 0;
  parsedString.significand = 0;
  parsedString.exp = 0;

  const char* number_end = number + size;
  current = find_if(number, number_end, [](const char a) { return !is_space(a); });
  if (number_end == current) {
    return parse_string_error::empty_string;
  }
  if (*current == '-') {
    parsedString.negative = 1;
    current++;
  }
  while (current < number_end) {
    if ((*current < '0' || *current > '9') && *current != '.') {
      break;
    }

    if (*current == '.') {
      if (desimal_position >= 0) {
        return parse_string_error::multiple_commas;
      }
      desimal_position = parsedString.significand_digit_count;
    } else {
#ifdef _MSC_VER
      bool localDigitCount = NoDigitCount;
      if (localDigitCount || parsedString.significand_digit_count < 19)
#else
      if (NoDigitCount || parsedString.significand_digit_count < 19)
#endif
      {
        parsedString.significand = parsedString.significand * T(10) + T(int(*current) - '0');
        parsedString.significand_digit_count++;
      } else if (increase_significand && parsedString.significand_digit_count < 20) {
        increase_significand = false;
        uint64_t digit = uint64_t(*current) - '0';
        static_assert(
            NoDigitCount || std::is_same<T, uint64_t>::value,
            "When NoDigitCount is used the significand type has to be uint64_t"
        );
        auto biggest_multiplier = (std::numeric_limits<uint64_t>::max() - digit) / parsedString.significand;

        if (biggest_multiplier >= 10) {
          parsedString.significand = parsedString.significand * T(10) + T(digit);
          parsedString.significand_digit_count++;
        }
      }
    }
    current++;
  }
  if (*current != 'e' && *current != 'E') {
    if (desimal_position >= 0) {
      parsedString.exp = desimal_position - parsedString.significand_digit_count;
    }
    return parse_string_error::ok;
  }
  current++;
  if (current == number_end) {
    return parse_string_error::illegal_exponent_value;
  }
  bool exponent_nagative = false;
  if (*current == '-') {
    exponent_nagative = true;
    current++;
  } else if (*current == '+') {
    current++;
  }
  if (current == number_end) {
    return parse_string_error::illegal_exponent_value;
  }
  int exponent = 0;
  bool exponent_assigned = false;
  while (current < number_end) {
    if ((*current < '0' || *current > '9')) {
      break;
    }
    exponent_assigned = true;
    exponent = exponent * 10 + (*current - '0');
    current++;
  }
  if (!exponent_assigned) {
    return parse_string_error::illegal_exponent_value;
  }

  if (exponent_nagative) {
    exponent = -exponent;
  }

  if (desimal_position >= 0) {
    parsedString.exp = desimal_position - parsedString.significand_digit_count + exponent;
  } else {
    parsedString.exp = exponent;
  }
  return parse_string_error::ok;
}

inline uint64_t getPow10(uint32_t pow) {
  static uint64_t data[] = {
      UINT64_C(1),
      UINT64_C(10),
      UINT64_C(100),
      UINT64_C(1000),
      UINT64_C(10000),
      UINT64_C(100000),
      UINT64_C(1000000),
      UINT64_C(10000000),
      UINT64_C(100000000),
      UINT64_C(1000000000),
      UINT64_C(10000000000),
      UINT64_C(100000000000),
      UINT64_C(1000000000000),
      UINT64_C(10000000000000),
      UINT64_C(100000000000000),
      UINT64_C(1000000000000000),
      UINT64_C(10000000000000000),
      UINT64_C(100000000000000000),
      UINT64_C(1000000000000000000),
      UINT64_C(10000000000000000000)
  };
  return data[pow];
}

template <typename T, typename SignificandType> inline T convertToNumber(const parsed_string<SignificandType>& parsed) {
  int base10exponent = parsed.exp + parsed.significand_digit_count - 1;
  if (base10exponent > float_info<T>::max_base10_exponent()) {
    return make_inf<T>(parsed.negative);
  } else if (base10exponent < float_info<T>::min_base10_exponent()) {
    return make_zero<T>(parsed.negative);
  }
  if (parsed.significand == 0) {
    return make_zero<T>(parsed.negative);
  }

#if 1
  if (parsed.significand < ((uint64_t(1) << 53)) && iabs<int>(parsed.exp) < count_chars((uint64_t(1) << 53))) {
    double ds(double(parsed.significand));
    double de(double(getPow10(iabs<int>(parsed.exp))));
    if (parsed.negative) {
      ds = -ds;
    }
    return parsed.exp < 0 ? T(ds / de) : T(ds * de);
  }
#endif

  using uint_conversion_type = typename float_info<T>::str_to_float_conversion_type;
  uint_conversion_type a;
  uint_conversion_type b;
  assign_significand_to_float_conversion_type(parsed, a);
  int desimal_exponent = parsed.exp;
  auto binary_exponent = float_info<T>::str_to_float_binary_exponent_init();
  for (; desimal_exponent > 0; desimal_exponent--) {
    left_shift(a);
    copy_conversion_type(a, b);
    left_shift<2>(b);
    add(b, a);

    while (float_info<T>::conversion_type_has_mask(a)) {
      right_shift(a);
      binary_exponent++;
    }
  }

  for (; desimal_exponent < 0; desimal_exponent++) {
    binary_exponent -= float_info<T>::shift_left_msb_to_index(a, float_info<T>::str_to_float_binary_exponent_init());

    divide_by_10(a);
  }

  binary_exponent -= float_info<T>::shift_left_msb_to_index(a, float_info<T>::str_to_float_binary_exponent_init());

  binary_exponent += float_info<T>::bias();
  T to_digit;
  if (binary_exponent <= 0) {
    float_info<T>::copy_denormal_to_type(a, binary_exponent, parsed.negative, to_digit);
  } else if (binary_exponent < (int(1) << float_info<T>::exponent_width()) - 1) {
    float_info<T>::copy_normal_to_type(a, binary_exponent, parsed.negative, to_digit);
  } else {
    to_digit = make_inf<T>(parsed.negative);
  }
  return to_digit;
}

namespace ryu {
template <typename T> int to_buffer(T d, char* buffer, int buffer_size, int* digits_truncated = nullptr) {
  auto decoded = decode<T, uint64_t>(d);
  return convert_parsed_to_buffer(
      decoded, buffer, buffer_size, float_info<T>::str_to_float_expanded_length(), digits_truncated
  );
}

template <typename T> inline std::string to_string(T f) {
  auto decoded = decode<T, uint64_t>(f);
  std::string ret;
  ret.resize(25);
  ret.resize(
      size_t(convert_parsed_to_buffer(decoded, &ret[0], int(ret.size()), float_info<T>::str_to_float_expanded_length()))
  );
  return ret;
}
} // namespace ryu

namespace integer {
template <typename T> inline int to_buffer(T integer, char* buffer, int buffer_size, int* digits_truncated = nullptr) {
  static_assert(std::is_integral<T>::value, "Tryint to convert non int to string");
  int chars_to_write = ft::count_chars(integer);
  char* target_buffer = buffer;
  bool negative = false;
  if (std::is_signed<T>::value) {
    if (integer < 0) {
      target_buffer[0] = '-';
      target_buffer++;
      buffer_size--;
      negative = true;
    }
  }
  int to_remove = chars_to_write - buffer_size;
  if (to_remove > 0) {
    for (int i = 0; i < to_remove; i++) {
      integer /= 10;
    }
    if (digits_truncated) {
      *digits_truncated = to_remove;
    }
    chars_to_write -= to_remove;
  } else if (digits_truncated) {
    *digits_truncated = 0;
  }

  for (int i = 0; i < chars_to_write; i++) {
    int remainder = integer % 10;
    if (std::is_signed<T>::value) {
      if (negative) {
        remainder = -remainder;
      }
    }
    integer /= 10;
    target_buffer[chars_to_write - 1 - i] = '0' + char(remainder);
  }

  return chars_to_write + negative;
}

template <typename T, typename SignificandType>
inline typename std::enable_if<std::is_signed<T>::value, T>::type make_integer_return_value(
    SignificandType significand, bool negative
) {
  return negative ? -T(significand) : T(significand);
}

template <typename T, typename SignificandType>
inline typename std::enable_if<std::is_unsigned<T>::value, T>::type make_integer_return_value(
    SignificandType significand, bool
) {
  return T(significand);
}

template <typename T, typename SignificandType>
inline T convert_to_integer(const parsed_string<SignificandType>& parsed) {
  if (parsed.inf) {
    return parsed.negative ? std::numeric_limits<T>::min() : std::numeric_limits<T>::max();
  }
  if (parsed.nan) {
    return T(0);
  }

  int exp = parsed.exp;
  auto significand = parsed.significand;
  if (exp < 0) {
    int chars_in_sig = count_chars(significand);
    if (-exp >= chars_in_sig) {
      return T(0);
    }
    while (exp < 0) {
      significand /= 10;
      exp++;
    }
  } else if (exp > 0) {
    int chars_in_sig = count_chars(significand);
    if (exp > ft::StaticLog10<T, std::numeric_limits<T>::max(), 0, 0, true>::get() - chars_in_sig) {
      return parsed.negative ? std::numeric_limits<T>::min() : std::numeric_limits<T>::max();
    }
    while (exp > 0) {
      significand *= 10;
      exp--;
    }
  }
  return make_integer_return_value<T>(significand, bool(parsed.negative));
}

template <typename T>
inline parse_string_error to_integer(const char* str, size_t size, T& target, const char*(&endptr)) {
  using SignificandType = typename std::make_unsigned<T>::type;
  parsed_string<SignificandType> ps;
  auto parseResult = parseNumber<SignificandType, true>(str, size, ps);
  endptr = ps.endptr;
  if (parseResult != parse_string_error::ok) {
    target = 0;
  } else {
    target = convert_to_integer<T>(ps);
  }
  return parseResult;
}

template <typename T> inline parse_string_error to_integer(const std::string& str, T& target, const char*(&endptr)) {
  return to_integer(str.c_str(), str.size(), target, endptr);
}
} // namespace integer

template <typename T>
inline parse_string_error to_ieee_t(const char* str, size_t size, T& target, const char*(&endptr)) {
  parsed_string<uint64_t> ps;
  auto parseResult = parseNumber<uint64_t, false>(str, size, ps);
  endptr = ps.endptr;
  if (parseResult != parse_string_error::ok) {
    target = make_nan<T>(true, 1);
  } else {
    target = convertToNumber<T>(ps);
  }
  return parseResult;
}

inline parse_string_error to_float(const char* str, size_t size, float& target, const char*(&endptr)) {
  return to_ieee_t(str, size, target, endptr);
}

inline parse_string_error to_double(const char* str, size_t size, double& target, const char*(&endptr)) {
  return to_ieee_t(str, size, target, endptr);
}

} // namespace ft
} // namespace Internal
/// \private
template <> struct TypeHandler<double> {
  static inline Error to(double& to_type, ParseContext& context) {
    const char* pointer;
    auto result = Internal::ft::to_double(context.token.value.data, context.token.value.size, to_type, pointer);
    if (result != Internal::ft::parse_string_error::ok ||
        context.token.value.data + context.token.value.size != pointer) {
      return Error::FailedToParseDouble;
    }
    return Error::NoError;
  }

  static inline void from(const double& d, Token& token, Serializer& serializer) {
    // char buf[1/*'-'*/ + (DBL_MAX_10_EXP+1)/*308+1 digits*/ + 1/*'.'*/ + 6/*Default? precision*/ + 1/*\0*/];
    char buf[32];
    int size;
    size = Internal::ft::ryu::to_buffer(d, buf, sizeof(buf));

    if (size <= 0) {
      return;
    }

    token.value_type = Type::Number;
    token.value.data = buf;
    token.value.size = size_t(size);
    serializer.write(token);
  }
};

/// \private
template <> struct TypeHandler<float> {
  static inline Error to(float& to_type, ParseContext& context) {
    const char* pointer;
    auto result = Internal::ft::to_float(context.token.value.data, context.token.value.size, to_type, pointer);
    if (result != Internal::ft::parse_string_error::ok ||
        context.token.value.data + context.token.value.size != pointer) {
      return Error::FailedToParseFloat;
    }
    return Error::NoError;
  }

  static inline void from(const float& f, Token& token, Serializer& serializer) {
    char buf[16];
    int size;
    size = Internal::ft::ryu::to_buffer(f, buf, sizeof(buf));
    if (size < 0) {
      return;
    }

    token.value_type = Type::Number;
    token.value.data = buf;
    token.value.size = size_t(size);
    serializer.write(token);
  }
};

/// \private
template <typename T> struct TypeHandlerIntType {
  static inline Error to(T& to_type, ParseContext& context) {
    const char* pointer;
    auto parse_error =
        Internal::ft::integer::to_integer(context.token.value.data, context.token.value.size, to_type, pointer);
    if (parse_error != Internal::ft::parse_string_error::ok || context.token.value.data == pointer) {
      return Error::FailedToParseInt;
    }
    return Error::NoError;
  }

  static inline void from(const T& from_type, Token& token, Serializer& serializer) {
    char buf[40];
    int digits_truncated;
    int size = Internal::ft::integer::to_buffer(from_type, buf, sizeof(buf), &digits_truncated);
    if (size <= 0 || digits_truncated) {
      fprintf(stderr, "error serializing int token\n");
      return;
    }

    token.value_type = Type::Number;
    token.value.data = buf;
    token.value.size = size_t(size);
    serializer.write(token);
  }
};

/// \private
template <> struct TypeHandler<short int> : TypeHandlerIntType<short int> {};

/// \private
template <> struct TypeHandler<unsigned short int> : TypeHandlerIntType<unsigned short int> {};

/// \private
template <> struct TypeHandler<int> : TypeHandlerIntType<int> {};

/// \private
template <> struct TypeHandler<unsigned int> : TypeHandlerIntType<unsigned int> {};

/// \private
template <> struct TypeHandler<long int> : TypeHandlerIntType<long int> {};

/// \private
template <> struct TypeHandler<unsigned long int> : TypeHandlerIntType<unsigned long int> {};

/// \private
template <> struct TypeHandler<long long int> : TypeHandlerIntType<long long int> {};

/// \private
template <> struct TypeHandler<unsigned long long int> : TypeHandlerIntType<unsigned long long int> {};

template <> struct TypeHandler<uint8_t> : TypeHandlerIntType<uint8_t> {};

template <> struct TypeHandler<int8_t> : TypeHandlerIntType<int8_t> {};

template <> struct TypeHandler<char> : TypeHandlerIntType<char> {};

/// \private
template <typename T> struct TypeHandler<Nullable<T>> {
public:
  static inline Error to(Nullable<T>& to_type, ParseContext& context) {
    if (context.token.value_type == Type::Null) {
      return Error::NoError;
    }
    return TypeHandler<T>::to(to_type.data, context);
  }

  static inline void from(const Nullable<T>& opt, Token& token, Serializer& serializer) {
    TypeHandler<T>::from(opt(), token, serializer);
  }
};

/// \private
template <typename T> struct TypeHandler<NullableChecked<T>> {
public:
  static inline Error to(NullableChecked<T>& to_type, ParseContext& context) {
    if (context.token.value_type == Type::Null) {
      to_type.null = true;
      return Error::NoError;
    }
    to_type.null = false;
    return TypeHandler<T>::to(to_type.data, context);
  }

  static inline void from(const NullableChecked<T>& opt, Token& token, Serializer& serializer) {
    if (opt.null) {
      const char nullChar[] = "null";
      token.value_type = Type::Null;
      token.value = DataRef(nullChar);
      serializer.write(token);
    } else {
      TypeHandler<T>::from(opt(), token, serializer);
    }
  }
};

/// \private
template <typename T> struct TypeHandler<Optional<T>> {
public:
  static inline Error to(Optional<T>& to_type, ParseContext& context) {
    return TypeHandler<T>::to(to_type.data, context);
  }

  static inline void from(const Optional<T>& opt, Token& token, Serializer& serializer) {
    TypeHandler<T>::from(opt(), token, serializer);
  }
};

/// \private
template <typename T> struct TypeHandler<OptionalChecked<T>> {
public:
  static inline Error to(OptionalChecked<T>& to_type, ParseContext& context) {
    to_type.assigned = true;
    return TypeHandler<T>::to(to_type.data, context);
  }

  static inline void from(const OptionalChecked<T>& opt, Token& token, Serializer& serializer) {
    if (opt.assigned) {
      TypeHandler<T>::from(opt(), token, serializer);
    }
  }
};

#ifdef JS_STD_OPTIONAL
/// \private
template <typename T> struct TypeHandler<std::optional<T>> {
public:
  static inline Error to(std::optional<T>& to_type, ParseContext& context) {
    to_type.emplace();
    return TypeHandler<T>::to(to_type.value(), context);
  }

  static inline void from(const std::optional<T>& opt, Token& token, Serializer& serializer) {
    if (opt.has_value()) {
      TypeHandler<T>::from(opt.value(), token, serializer);
    }
  }
};
#endif

/// \private
template <typename T> struct TypeHandler<std::shared_ptr<T>> {
public:
  static inline Error to(std::shared_ptr<T>& to_type, ParseContext& context) {
    if (context.token.value_type != Type::Null) {
      if (!to_type) {
        to_type = std::make_shared<T>();
      }
      return TypeHandler<T>::to(*to_type.get(), context);
    }
    to_type.reset();
    return Error::NoError;
  }

  static inline void from(const std::shared_ptr<T>& unique, Token& token, Serializer& serializer) {
    if (unique) {
      TypeHandler<T>::from(*unique.get(), token, serializer);
    } else {
      const char nullChar[] = "null";
      token.value_type = Type::Null;
      token.value = DataRef(nullChar);
      serializer.write(token);
    }
  }
};

/// \private
template <typename T> struct TypeHandler<std::unique_ptr<T>> {
public:
  static inline Error to(std::unique_ptr<T>& to_type, ParseContext& context) {
    if (context.token.value_type != Type::Null) {
      if (!to_type) {
        to_type.reset(new T());
      }
      return TypeHandler<T>::to(*to_type.get(), context);
    }
    to_type.reset(nullptr);
    return Error::NoError;
  }

  static inline void from(const std::unique_ptr<T>& unique, Token& token, Serializer& serializer) {
    if (unique) {
      TypeHandler<T>::from(*unique.get(), token, serializer);
    } else {
      const char nullChar[] = "null";
      token.value_type = Type::Null;
      token.value = DataRef(nullChar);
      serializer.write(token);
    }
  }
};

/// \private
template <> struct TypeHandler<bool> {
  static inline Error to(bool& to_type, ParseContext& context) {
    if (context.token.value.size == sizeof("true") - 1 &&
        memcmp("true", context.token.value.data, sizeof("true") - 1) == 0) {
      to_type = true;
    } else if (context.token.value.size == sizeof("false") - 1 &&
               memcmp("false", context.token.value.data, sizeof("false") - 1) == 0) {
      to_type = false;
    } else {
      return Error::FailedToParseBoolean;
    }

    return Error::NoError;
  }

  static inline void from(const bool& b, Token& token, Serializer& serializer) {
    const char trueChar[] = "true";
    const char falseChar[] = "false";
    token.value_type = Type::Bool;
    if (b) {
      token.value = DataRef(trueChar);
    } else {
      token.value = DataRef(falseChar);
    }
    serializer.write(token);
  }
};

#ifdef JS_STD_TIMEPOINT
/// \private
namespace Internal {
template <class T, template <class...> class Template> struct is_specialization : std::false_type {};

template <template <class...> class Template, class... Args>
struct is_specialization<Template<Args...>, Template> : std::true_type {};
} // namespace Internal

/// \private
template <class T>
struct TypeHandler<T, typename std::enable_if_t<Internal::is_specialization<T, std::chrono::time_point>::value>> {
  static inline Error to(T& to_type, ParseContext& context) {
    uint64_t t;
    Error err = TypeHandler<uint64_t>::to(t, context);
    if (err != Error::NoError) {
      return err;
    }

    if (t <= 1e11) { // Seconds => 10 digits, normally
      to_type = T{std::chrono::seconds{t}};
    } else if (t <= 1e14) { // Milliseconds => 13 digits, normally
      to_type = T{std::chrono::milliseconds{t}};
    } else if (t <= 1e17) { // Microseconds
      to_type = T{std::chrono::microseconds{t}};
    } else if (t <= 1e20) { // Nanoseconds
      if constexpr (std::is_same_v<std::chrono::high_resolution_clock::time_point, T>) {
        to_type = T{std::chrono::nanoseconds{t}};
      } else {
        return JS::Error::IllegalDataValue;
      }
    } else {
      return JS::Error::IllegalDataValue;
    }

    return JS::Error::NoError;
  }

  static inline void from(const T& val, Token& token, Serializer& serializer) {
    uint64_t t;
    if constexpr (std::is_same_v<std::chrono::high_resolution_clock::time_point, T>) {
      t = std::chrono::duration_cast<std::chrono::nanoseconds>(val.time_since_epoch()).count();
    } else {
      t = std::chrono::duration_cast<std::chrono::microseconds>(val.time_since_epoch()).count();
    }
    while (t % 1000 == 0 && t > (uint64_t) 1e10) {
      t /= 1000;
    }
    TypeHandler<uint64_t>::from(t, token, serializer);
  }
};
#endif

/// \private
template <typename T, typename A> struct TypeHandler<std::vector<T, A>> {
  static inline Error to(std::vector<T, A>& to_type, ParseContext& context) {
    if (context.token.value_type != JS::Type::ArrayStart) {
      return Error::ExpectedArrayStart;
    }
    Error error = context.nextToken();
    if (error != JS::Error::NoError) {
      return error;
    }
    to_type.clear();
    to_type.reserve(10);
    while (context.token.value_type != JS::Type::ArrayEnd) {
      to_type.push_back(T());
      error = TypeHandler<T>::to(to_type.back(), context);
      if (error != JS::Error::NoError) {
        break;
      }
      error = context.nextToken();
      if (error != JS::Error::NoError) {
        break;
      }
    }

    return error;
  }

  static inline void from(const std::vector<T, A>& vec, Token& token, Serializer& serializer) {
    token.value_type = Type::ArrayStart;
    token.value = DataRef("[");
    serializer.write(token);

    token.name = DataRef("");

    for (auto& index : vec) {
      TypeHandler<T>::from(index, token, serializer);
    }

    token.name = DataRef("");

    token.value_type = Type::ArrayEnd;
    token.value = DataRef("]");
    serializer.write(token);
  }
};

/// \private
template <typename A> struct TypeHandler<std::vector<bool, A>> {
public:
  static inline Error to(std::vector<bool, A>& to_type, ParseContext& context) {
    if (context.token.value_type != JS::Type::ArrayStart) {
      return Error::ExpectedArrayStart;
    }
    Error error = context.nextToken();
    if (error != JS::Error::NoError) {
      return error;
    }
    to_type.clear();
    to_type.reserve(10);
    while (context.token.value_type != JS::Type::ArrayEnd) {

      bool toBool;
      error = TypeHandler<bool>::to(toBool, context);
      to_type.push_back(toBool);
      if (error != JS::Error::NoError) {
        break;
      }
      error = context.nextToken();
      if (error != JS::Error::NoError) {
        break;
      }
    }

    return error;
  }

  static inline void from(const std::vector<bool, A>& vec, Token& token, Serializer& serializer) {
    token.value_type = Type::ArrayStart;
    token.value = DataRef("[");
    serializer.write(token);

    token.name = DataRef("");

    for (bool index : vec) {
      TypeHandler<bool>::from(index, token, serializer);
    }

    token.name = DataRef("");

    token.value_type = Type::ArrayEnd;
    token.value = DataRef("]");
    serializer.write(token);
  }
};

/// \private
template <> struct TypeHandler<SilentString> {
  static inline Error to(SilentString& to_type, ParseContext& context) {
    return TypeHandler<std::string>::to(to_type.data, context);
  }
  static inline void from(const SilentString& str, Token& token, Serializer& serializer) {
    if (str.data.size()) {
      TypeHandler<std::string>::from(str.data, token, serializer);
    }
  }
};

/// \private
template <typename T, typename A> struct TypeHandler<SilentVector<T, A>> {
public:
  static inline Error to(SilentVector<T, A>& to_type, ParseContext& context) {
    return TypeHandler<std::vector<T, A>>::to(to_type.data, context);
  }

  static inline void from(const SilentVector<T, A>& vec, Token& token, Serializer& serializer) {
    if (vec.data.size()) {
      TypeHandler<std::vector<T, A>>::from(vec.data, token, serializer);
    }
  }
};

/// \private
template <typename T> struct TypeHandler<SilentUniquePtr<T>> {
public:
  static inline Error to(SilentUniquePtr<T>& to_type, ParseContext& context) {
    return TypeHandler<std::unique_ptr<T>>::to(to_type.data, context);
  }

  static inline void from(const SilentUniquePtr<T>& ptr, Token& token, Serializer& serializer) {
    if (ptr.data) {
      TypeHandler<std::unique_ptr<T>>::from(ptr.data, token, serializer);
    }
  }
};

/// \private
template <typename A> struct TypeHandler<std::vector<Token, A>> {
public:
  static inline Error to(std::vector<Token, A>& to_type, ParseContext& context) {
    if (context.token.value_type != JS::Type::ArrayStart && context.token.value_type != JS::Type::ObjectStart) {
      to_type.push_back(context.token);
      return context.error;
    }
    to_type.clear();
    to_type.push_back(context.token);

    size_t level = 1;
    Error error = Error::NoError;
    while (error == JS::Error::NoError && level) {
      error = context.nextToken();
      to_type.push_back(context.token);
      if (context.token.value_type == Type::ArrayStart || context.token.value_type == Type::ObjectStart) {
        level++;
      } else if (context.token.value_type == Type::ArrayEnd || context.token.value_type == Type::ObjectEnd) {
        level--;
      }
    }

    return error;
  }

  static inline void from(const std::vector<Token, A>& from_type, Token& token, Serializer& serializer) {
    for (auto& t : from_type) {
      token = t;
      serializer.write(token);
    }
  }
};

/// \private
template <> struct TypeHandler<JsonTokens> {
public:
  static inline Error to(JsonTokens& to_type, ParseContext& context) {
    return TypeHandler<std::vector<Token>>::to(to_type.data, context);
  }
  static inline void from(const JsonTokens& from, Token& token, Serializer& serializer) {
    return TypeHandler<std::vector<Token>>::from(from.data, token, serializer);
  }
};

/// \private
template <> struct TypeHandler<JsonArrayRef> {
  static inline Error to(JsonArrayRef& to_type, ParseContext& context) {
    if (context.token.value_type != JS::Type::ArrayStart) {
      return Error::ExpectedArrayStart;
    }

    to_type.ref.data = context.token.value.data;

    size_t level = 1;
    Error error = Error::NoError;
    while (error == JS::Error::NoError && level) {
      error = context.nextToken();
      if (context.token.value_type == Type::ArrayStart) {
        level++;
      } else if (context.token.value_type == Type::ArrayEnd) {
        level--;
      }
    }

    to_type.ref.size = size_t(context.token.value.data + context.token.value.size - to_type.ref.data);

    return error;
  }

  static inline void from(const JsonArrayRef& from_type, Token& token, Serializer& serializer) {
    token.value = from_type.ref;
    token.value_type = Type::Verbatim;
    serializer.write(token);
  }
};

/// \private
template <> struct TypeHandler<JsonArray> {
  static inline Error to(JsonArray& to_type, ParseContext& context) {
    if (context.token.value_type != JS::Type::ArrayStart) {
      return Error::ExpectedArrayStart;
    }

    context.tokenizer.copyFromValue(context.token, to_type.data);

    size_t level = 1;
    Error error = Error::NoError;
    while (error == JS::Error::NoError && level) {
      error = context.nextToken();
      if (context.token.value_type == Type::ArrayStart) {
        level++;
      } else if (context.token.value_type == Type::ArrayEnd) {
        level--;
      }
    }

    if (error == JS::Error::NoError) {
      context.tokenizer.copyIncludingValue(context.token, to_type.data);
    }

    return error;
  }

  static inline void from(const JsonArray& from_type, Token& token, Serializer& serializer) {
    token.value_type = JS::Type::Verbatim; // Need to fool the serializer to just write value as verbatim

    if (from_type.data.empty()) {
      std::string emptyArray("[]");
      token.value = DataRef(emptyArray);
      serializer.write(token);
    } else {
      token.value = DataRef(from_type.data);
      serializer.write(token);
    }
  }
};

/// \private
template <> struct TypeHandler<JsonObjectRef> {
  static inline Error to(JsonObjectRef& to_type, ParseContext& context) {
    if (context.token.value_type != JS::Type::ObjectStart) {
      return Error::ExpectedObjectStart;
    }

    to_type.ref.data = context.token.value.data;
    size_t level = 1;
    Error error = Error::NoError;
    while (error == JS::Error::NoError && level) {
      error = context.nextToken();
      if (context.token.value_type == Type::ObjectStart) {
        level++;
      } else if (context.token.value_type == Type::ObjectEnd) {
        level--;
      }
    }

    to_type.ref.size = size_t(context.token.value.data + context.token.value.size - to_type.ref.data);
    return error;
  }

  static inline void from(const JsonObjectRef& from_type, Token& token, Serializer& serializer) {
    token.value = from_type.ref;
    token.value_type = Type::Verbatim;
    serializer.write(token);
  }
};

/// \private
template <> struct TypeHandler<JsonObject> {
  static inline Error to(JsonObject& to_type, ParseContext& context) {
    if (context.token.value_type != JS::Type::ObjectStart) {
      return Error::ExpectedObjectStart;
    }

    context.tokenizer.copyFromValue(context.token, to_type.data);

    size_t level = 1;
    Error error = Error::NoError;
    while (error == JS::Error::NoError && level) {
      error = context.nextToken();
      if (context.token.value_type == Type::ObjectStart) {
        level++;
      } else if (context.token.value_type == Type::ObjectEnd) {
        level--;
      }
    }

    context.tokenizer.copyIncludingValue(context.token, to_type.data);

    return error;
  }

  static inline void from(const JsonObject& from_type, Token& token, Serializer& serializer) {
    token.value_type = JS::Type::Verbatim; // Need to fool the serializer to just write value as verbatim

    if (from_type.data.empty()) {
      std::string emptyObject("{}");
      token.value = DataRef(emptyObject);
      serializer.write(token);
    } else {
      token.value = DataRef(from_type.data);
      serializer.write(token);
    }
  }
};

/// \private
template <> struct TypeHandler<JsonObjectOrArrayRef> {
  static inline Error to(JsonObjectOrArrayRef& to_type, ParseContext& context) {
    JS::Type openType;
    JS::Type closeType;
    if (context.token.value_type == JS::Type::ObjectStart) {
      openType = JS::Type::ObjectStart;
      closeType = JS::Type::ObjectEnd;
    } else if (context.token.value_type == JS::Type::ArrayStart) {
      openType = JS::Type::ArrayStart;
      closeType = JS::Type::ArrayEnd;
    } else {
      return Error::ExpectedObjectStart;
    }

    to_type.ref.data = context.token.value.data;
    size_t level = 1;
    Error error = Error::NoError;
    while (error == JS::Error::NoError && level) {
      error = context.nextToken();
      if (context.token.value_type == openType) {
        level++;
      } else if (context.token.value_type == closeType) {
        level--;
      }
    }

    to_type.ref.size = size_t(context.token.value.data + context.token.value.size - to_type.ref.data);
    return error;
  }

  static inline void from(const JsonObjectOrArrayRef& from_type, Token& token, Serializer& serializer) {
    token.value = from_type.ref;
    token.value_type = Type::Verbatim;
    serializer.write(token);
  }
};

/// \private
template <> struct TypeHandler<JsonObjectOrArray> {
  static inline Error to(JsonObjectOrArray& to_type, ParseContext& context) {
    JS::Type openType;
    JS::Type closeType;
    if (context.token.value_type == JS::Type::ObjectStart) {
      openType = JS::Type::ObjectStart;
      closeType = JS::Type::ObjectEnd;
    } else if (context.token.value_type == JS::Type::ArrayStart) {
      openType = JS::Type::ArrayStart;
      closeType = JS::Type::ArrayEnd;
    } else {
      return Error::ExpectedObjectStart;
    }

    context.tokenizer.copyFromValue(context.token, to_type.data);

    size_t level = 1;
    Error error = Error::NoError;
    while (error == JS::Error::NoError && level) {
      error = context.nextToken();
      if (context.token.value_type == openType) {
        level++;
      } else if (context.token.value_type == closeType) {
        level--;
      }
    }

    context.tokenizer.copyIncludingValue(context.token, to_type.data);

    return error;
  }

  static inline void from(const JsonObjectOrArray& from_type, Token& token, Serializer& serializer) {
    token.value_type = JS::Type::Verbatim; // Need to fool the serializer to just write value as verbatim

    if (from_type.data.empty()) {
      std::string emptyObjectOrArray("{}"); // Use object as default
      token.value = DataRef(emptyObjectOrArray);
      serializer.write(token);
    } else {
      token.value = DataRef(from_type.data);
      serializer.write(token);
    }
  }
};

namespace Internal {
template <size_t INDEX, typename... Ts> struct TupleTypeHandler {
  static inline Error to(JS::Tuple<Ts...>& to_type, ParseContext& context) {
    using Type = typename JS::TypeAt<sizeof...(Ts) - INDEX, Ts...>::type;
    Error error = TypeHandler<Type>::to(to_type.template get<sizeof...(Ts) - INDEX>(), context);
    if (error != JS::Error::NoError) {
      return error;
    }
    error = context.nextToken();
    if (error != JS::Error::NoError) {
      return error;
    }
    return TupleTypeHandler<INDEX - 1, Ts...>::to(to_type, context);
  }

  static inline void from(const JS::Tuple<Ts...>& from_type, Token& token, Serializer& serializer) {
    using Type = typename JS::TypeAt<sizeof...(Ts) - INDEX, Ts...>::type;
    TypeHandler<Type>::from(from_type.template get<sizeof...(Ts) - INDEX>(), token, serializer);
    TupleTypeHandler<INDEX - 1, Ts...>::from(from_type, token, serializer);
  }
};

/// \private
template <typename... Ts> struct TupleTypeHandler<0, Ts...> {
  static inline Error to(JS::Tuple<Ts...>, ParseContext& context) {
    JS_UNUSED(context);
    return Error::NoError;
  }

  static inline void from(const JS::Tuple<Ts...>& from_type, Token& token, Serializer& serializer) {
    JS_UNUSED(from_type);
    JS_UNUSED(token);
    JS_UNUSED(serializer);
  }
};
} // namespace Internal

/// \private
template <typename... Ts> struct TypeHandler<JS::Tuple<Ts...>> {
  static inline Error to(JS::Tuple<Ts...>& to_type, ParseContext& context) {
    if (context.token.value_type != JS::Type::ArrayStart) {
      return Error::ExpectedArrayStart;
    }
    Error error = context.nextToken();
    if (error != JS::Error::NoError) {
      return error;
    }
    error = JS::Internal::TupleTypeHandler<sizeof...(Ts), Ts...>::to(to_type, context);
    if (error != JS::Error::NoError) {
      return error;
    }
    if (context.token.value_type != JS::Type::ArrayEnd) {
      return Error::ExpectedArrayEnd;
    }
    return Error::NoError;
  }

  static inline void from(const JS::Tuple<Ts...>& from_type, Token& token, Serializer& serializer) {
    token.value_type = Type::ArrayStart;
    token.value = DataRef("[");
    serializer.write(token);

    token.name = DataRef("");

    JS::Internal::TupleTypeHandler<sizeof...(Ts), Ts...>::from(from_type, token, serializer);
    token.name = DataRef("");

    token.value_type = Type::ArrayEnd;
    token.value = DataRef("]");
    serializer.write(token);
  }
};

namespace Internal {
template <size_t INDEX, typename... Ts> struct StdTupleTypeHandler {
  static inline Error to(std::tuple<Ts...>& to_type, ParseContext& context) {
    using Type = typename std::tuple_element<sizeof...(Ts) - INDEX, std::tuple<Ts...>>::type;
    Error error = TypeHandler<Type>::to(std::get<sizeof...(Ts) - INDEX>(to_type), context);
    if (error != JS::Error::NoError) {
      return error;
    }
    error = context.nextToken();
    if (error != JS::Error::NoError) {
      return error;
    }
    return StdTupleTypeHandler<INDEX - 1, Ts...>::to(to_type, context);
  }

  static inline void from(const std::tuple<Ts...>& from_type, Token& token, Serializer& serializer) {
    using Type = typename std::tuple_element<sizeof...(Ts) - INDEX, std::tuple<Ts...>>::type;
    TypeHandler<Type>::from(std::get<sizeof...(Ts) - INDEX>(from_type), token, serializer);
    StdTupleTypeHandler<INDEX - 1, Ts...>::from(from_type, token, serializer);
  }
};

/// \private
template <typename... Ts> struct StdTupleTypeHandler<0, Ts...> {
  static inline Error to(std::tuple<Ts...>&, ParseContext& context) {
    JS_UNUSED(context);
    return Error::NoError;
  }

  static inline void from(const std::tuple<Ts...>& from_type, Token& token, Serializer& serializer) {
    JS_UNUSED(from_type);
    JS_UNUSED(token);
    JS_UNUSED(serializer);
  }
};
} // namespace Internal
/// \private
template <typename... Ts> struct TypeHandler<std::tuple<Ts...>> {
  static inline Error to(std::tuple<Ts...>& to_type, ParseContext& context) {
    if (context.token.value_type != JS::Type::ArrayStart) {
      return Error::ExpectedArrayStart;
    }
    Error error = context.nextToken();
    if (error != JS::Error::NoError) {
      return error;
    }
    error = JS::Internal::StdTupleTypeHandler<sizeof...(Ts), Ts...>::to(to_type, context);
    if (error != JS::Error::NoError) {
      return error;
    }
    if (context.token.value_type != JS::Type::ArrayEnd) {
      return Error::ExpectedArrayEnd;
    }
    return Error::NoError;
  }

  static inline void from(const std::tuple<Ts...>& from_type, Token& token, Serializer& serializer) {
    token.value_type = Type::ArrayStart;
    token.value = DataRef("[");
    serializer.write(token);

    token.name = DataRef("");

    JS::Internal::StdTupleTypeHandler<sizeof...(Ts), Ts...>::from(from_type, token, serializer);
    token.name = DataRef("");

    token.value_type = Type::ArrayEnd;
    token.value = DataRef("]");
    serializer.write(token);
  }
};

template <typename T> struct OneOrMany {
  std::vector<T> data;
};

template <typename T> struct TypeHandler<OneOrMany<T>> {
public:
  static inline Error to(OneOrMany<T>& to_type, ParseContext& context) {
    if (context.token.value_type == Type::ArrayStart) {
      context.error = TypeHandler<std::vector<T>>::to(to_type.data, context);
    } else {
      to_type.data.push_back(T());
      context.error = TypeHandler<T>::to(to_type.data.back(), context);
    }
    return context.error;
  }
  static void from(const OneOrMany<T>& from, Token& token, Serializer& serializer) {
    if (from.data.empty()) {
      return;
    }
    if (from.data.size() > 1) {
      TypeHandler<std::vector<T>>::from(from.data, token, serializer);
    } else {
      TypeHandler<T>::from(from.data.front(), token, serializer);
    }
  }
};

template <typename T, size_t N> struct TypeHandler<T[N]> {
public:
  static inline Error to(T (&to_type)[N], ParseContext& context) {
    if (context.token.value_type != Type::ArrayStart) {
      return JS::Error::ExpectedArrayStart;
    }

    context.nextToken();
    for (size_t i = 0; i < N; i++) {
      if (context.error != JS::Error::NoError) {
        return context.error;
      }
      context.error = TypeHandler<T>::to(to_type[i], context);
      if (context.error != JS::Error::NoError) {
        return context.error;
      }

      context.nextToken();
    }

    if (context.token.value_type != Type::ArrayEnd) {
      return JS::Error::ExpectedArrayEnd;
    }
    return context.error;
  }
  static void from(const T (&from)[N], Token& token, Serializer& serializer) {
    token.value_type = Type::ArrayStart;
    token.value = DataRef("[");
    serializer.write(token);

    token.name = DataRef("");
    for (size_t i = 0; i < N; i++) {
      TypeHandler<T>::from(from[i], token, serializer);
    }

    token.name = DataRef("");
    token.value_type = Type::ArrayEnd;
    token.value = DataRef("]");
    serializer.write(token);
  }
};

template <typename Key, typename Value, typename Map> struct TypeHandlerMap {
  static inline Error to(Map& to_type, ParseContext& context) {
    if (context.token.value_type != Type::ObjectStart) {
      return JS::Error::ExpectedObjectStart;
    }

    Error error = context.nextToken();
    if (error != JS::Error::NoError) {
      return error;
    }
    while (context.token.value_type != Type::ObjectEnd) {
      std::string str;
      Internal::handle_json_escapes_in(context.token.name, str);
      Key key(str.data(), str.size());
      Value v;
      error = TypeHandler<Value>::to(v, context);
      to_type[std::move(key)] = std::move(v);
      if (error != JS::Error::NoError) {
        return error;
      }
      error = context.nextToken();
    }

    return error;
  }

  static void from(const Map& from, Token& token, Serializer& serializer) {
    token.value_type = Type::ObjectStart;
    token.value = DataRef("{");
    serializer.write(token);
    for (auto it = from.begin(); it != from.end(); ++it) {
      token.name = DataRef(it->first);
      token.name_type = Type::String;
      TypeHandler<Value>::from(it->second, token, serializer);
    }
    token.name.size = 0;
    token.name.data = "";
    token.name_type = Type::String;
    token.value_type = Type::ObjectEnd;
    token.value = DataRef("}");
    serializer.write(token);
  }
};

#ifdef JS_STD_UNORDERED_MAP
template <typename Key, typename Value>
struct TypeHandler<std::unordered_map<Key, Value>> : TypeHandlerMap<Key, Value, std::unordered_map<Key, Value>> {};

#endif

namespace Internal {
inline bool compareDataRefWithString(const DataRef& a, const std::string& b) {
  return a.size == b.size() && memcmp(a.data, b.data(), a.size) == 0;
}
} // namespace Internal
struct Map {
  struct It {
    using iterator_category = std::forward_iterator_tag;
    using difference_type = int;
    using value_type = Token;
    using pointer = Token*;
    using reference = Token&;
    const Map& map;
    uint32_t index = 0;
    uint32_t next_meta = 0;
    uint32_t next_complex = 0;

    It(const Map& map) : map(map) {}
    It(const It& other)
        : map(other.map), index(other.index), next_meta(other.next_meta), next_complex(other.next_complex) {}
    inline const Token& operator*() { return map.tokens.data[index]; }

    inline const Token* operator->() { return &map.tokens.data[index]; }

    inline It& operator++() {
      if (index == next_complex) {
        index += map.meta[next_meta].size;
        next_meta += map.meta[next_meta].skip;
        next_complex = next_meta < uint32_t(map.meta.size()) ? uint32_t(map.meta[next_meta].position)
                                                             : uint32_t(map.tokens.data.size());
      } else {
        index++;
      }
      return *this;
    }
    inline bool operator==(const It& other) const { return index == other.index; }
    inline bool operator!=(const It& other) const { return index != other.index; }

    inline void operator=(const It& other) {
      assert(&map == &other.map);
      index = other.index;
      next_meta = other.next_meta;
      next_complex = other.next_complex;
    }
  };

  JS::JsonTokens tokens;
  std::vector<JsonMeta> meta;
  std::vector<std::pair<int, std::string>> json_data;

  inline It begin() const {
    It b(*this);
    b.index = 1;
    b.next_meta = 1;
    b.next_complex =
        b.next_meta < uint32_t(meta.size()) ? uint32_t(meta[b.next_meta].position) : uint32_t(tokens.data.size());
    return b;
  }

  inline It end() const {
    It e(*this);
    e.index = uint32_t(tokens.data.size());
    e.next_meta = 0;
    e.next_complex = 0;
    return e;
  }

  inline It find(const std::string& name) const {
    return std::find_if(begin(), end(), [&name](const Token& token) {
      return Internal::compareDataRefWithString(token.name, name);
    });
  }

  template <typename T> JS::Error castToType(JS::ParseContext& parseContext, T& to) const {
    parseContext.tokenizer.resetData(&tokens.data, 0);
    parseContext.nextToken();
    return JS::TypeHandler<T>::to(to, parseContext);
  }

  template <typename T> JS::Error castToType(const It& iterator, JS::ParseContext& parseContext, T& to) const {
    assert(iterator.index < tokens.data.size());
    parseContext.tokenizer.resetData(&tokens.data, iterator.index);
    parseContext.nextToken();
    return JS::TypeHandler<T>::to(to, parseContext);
  }

  template <typename T> JS::Error castToType(const std::string& name, JS::ParseContext& parseContext, T& to) const {
    if (tokens.data.empty() || tokens.data.front().value_type != JS::Type::ObjectStart) {
      parseContext.error = JS::Error::ExpectedObjectStart;
      return parseContext.error;
    }

    It it = find(name);
    if (it != end()) {
      return castToType(it, parseContext, to);
    }
    parseContext.error = JS::Error::KeyNotFound;
    return parseContext.error;
  }

  template <typename T> T castTo(JS::ParseContext& parseContext) const {
    T t = {};
    castToType<T>(parseContext, t);
    return t;
  }

  template <typename T> T castTo(const std::string& name, JS::ParseContext& parseContext) const {
    T t = {};
    castToType<T>(name, parseContext, t);
    return t;
  }

  template <typename T> JS::Error setValue(JS::ParseContext& parseContext, const T& value) {
    static_assert(
        sizeof(JS::Internal::HasJsonStructBase<T>::template test_in_base<T>(nullptr)) ==
            sizeof(typename JS::Internal::HasJsonStructBase<T>::yes),
        "Not a Json Object type\n"
    );
    std::string obj = JS::serializeStruct(value);
    parseContext.tokenizer.resetData(obj.data(), obj.size(), 0);
    tokens.data.clear();
    meta.clear();
    json_data.clear();
    auto error = parseContext.parseTo(tokens);
    if (error == JS::Error::NoError) {
      assert(tokens.data.size() && tokens.data[0].value_type == JS::Type::ObjectStart);
    }

    meta = metaForTokens(tokens);
    json_data.emplace_back(0, std::move(obj));
    return parseContext.error;
  }

  template <typename T> JS::Error setValue(const std::string& name, JS::ParseContext& parseContext, const T& value) {
    (void) parseContext;
    if (tokens.data.empty()) {
      tokens.data.reserve(10);
      meta.reserve(10);
      JS::Token token;
      token.value_type = JS::Type::ObjectStart;
      token.value = JS::DataRef("{");
      tokens.data.push_back(token);
      token.value_type = JS::Type::ObjectEnd;
      token.value = JS::DataRef("}");
      tokens.data.push_back(token);
      meta = JS::metaForTokens(tokens);
    }

    auto it = find(name);
    if (it != end()) {
      meta[0].children--;
      int tokens_removed = 0;
      if (it.index == it.next_complex) {
        auto theMeta = meta[it.next_meta];
        tokens_removed = theMeta.size;
        meta[0].complex_children--;
        meta[0].size -= theMeta.size;
        meta[0].skip -= theMeta.skip;
        auto start_token = tokens.data.begin() + it.index;
        tokens.data.erase(start_token, start_token + theMeta.size);
        int to_adjust_index = it.next_meta;
        auto start_meta = meta.begin() + it.next_meta;
        meta.erase(start_meta, start_meta + theMeta.skip);
        for (int i = to_adjust_index; i < int(meta.size()); i++) {
          meta[i].position -= theMeta.size;
        }
      } else {
        meta[0].size--;
        tokens.data.erase(tokens.data.begin() + it.index);
        tokens_removed = 1;
      }
      {
        int index_to_remove = -1;
        for (int i = 0; i < int(json_data.size()); i++) {
          if (uint32_t(json_data[i].first) == it.index) {
            index_to_remove = i;
          } else if (uint32_t(json_data[i].first) > it.index) {
            json_data[i].first -= tokens_removed;
          }
        }
        if (index_to_remove >= 0) {
          json_data.erase(json_data.begin() + index_to_remove);
        }
      }
    }
    static const char objectStart[] = "{";
    static const char objectEnd[] = "}";
    std::string out;
    JS::SerializerContext serializeContext(out);
    serializeContext.serializer.setOptions(SerializerOptions(JS::SerializerOptions::Compact));
    JS::Token token;
    token.value_type = Type::ObjectStart;
    token.value = DataRef(objectStart);
    serializeContext.serializer.write(token);

    token.name = DataRef(name);
    token.name_type = Type::String;
    JS::TypeHandler<T>::from(value, token, serializeContext.serializer);

    token.name = DataRef();
    token.value_type = Type::ObjectEnd;
    token.value = DataRef(objectEnd);
    serializeContext.serializer.write(token);

    serializeContext.flush();
    JS::JsonTokens new_tokens;
    JS::ParseContext pc(out.c_str(), out.size(), new_tokens);
    auto new_meta = metaForTokens(new_tokens);

    json_data.emplace_back(int(tokens.data.size() - 1), std::move(out));
    int old_tokens_size = int(tokens.data.size());
    tokens.data.insert(tokens.data.end() - 1, new_tokens.data.begin() + 1, new_tokens.data.end() - 1);
    meta[0].children++;
    if (new_meta[0].complex_children) {
      meta[0].complex_children++;
      meta[0].size += new_meta[1].size;
      meta[0].skip += new_meta[1].skip;
      int old_meta_size = int(meta.size());
      meta.insert(meta.end(), new_meta.begin() + 1, new_meta.end());
      for (int new_meta_i = old_meta_size; new_meta_i < int(meta.size()); new_meta_i++) {
        meta[new_meta_i].position +=
            old_tokens_size - 1 - 1; // position contains an extra and old_tokens_size has another extra
      }
    } else {
      meta[0].size++;
    }

    return JS::Error::NoError;
  }
};

template <> struct TypeHandler<Map> {
  static inline Error to(Map& to_type, ParseContext& context) {
    Error error = TypeHandler<JS::JsonTokens>::to(to_type.tokens, context);
    if (error == Error::NoError) {
      to_type.meta = metaForTokens(to_type.tokens);
    }

    return error;
  }

  static inline void from(const Map& from_type, Token& token, Serializer& serializer) {
    if (from_type.tokens.data.empty()) {
      token.value_type = Type::ObjectStart;
      token.value = DataRef("{");
      serializer.write(token);
      token.name = DataRef("");
      token.value_type = Type::ObjectEnd;
      token.value = DataRef("}");
      serializer.write(token);
      return;
    }

    Token first_token = from_type.tokens.data.front();
    first_token.name = token.name;
    serializer.write(first_token);
    for (int i = 1; i < int(from_type.tokens.data.size()); i++) {
      serializer.write(from_type.tokens.data[i]);
    }
  }
};

template <typename T, size_t COUNT>
struct ArrayVariableContent //-V730
{
  T data[COUNT];
  size_t size = 0;
};

template <typename T, size_t COUNT> struct TypeHandler<ArrayVariableContent<T, COUNT>> {
  static inline Error to(ArrayVariableContent<T, COUNT>& to_type, ParseContext& context) {
    if (context.token.value_type != Type::ArrayStart) {
      return JS::Error::ExpectedArrayStart;
    }

    context.nextToken();
    for (size_t i = 0; i < COUNT; i++) {
      if (context.error != JS::Error::NoError) {
        return context.error;
      }
      if (context.token.value_type == Type::ArrayEnd) {
        to_type.size = i;
        break;
      }
      context.error = TypeHandler<T>::to(to_type.data[i], context);
      if (context.error != JS::Error::NoError) {
        return context.error;
      }

      context.nextToken();
    }

    if (context.token.value_type != Type::ArrayEnd) {
      return JS::Error::ExpectedArrayEnd;
    }
    return context.error;
  }

  static inline void from(const ArrayVariableContent<T, COUNT>& from_type, Token& token, Serializer& serializer) {
    token.value_type = Type::ArrayStart;
    token.value = DataRef("[");
    serializer.write(token);

    token.name = DataRef("");
    for (size_t i = 0; i < from_type.size; i++) {
      TypeHandler<T>::from(from_type.data[i], token, serializer);
    }

    token.name = DataRef("");
    token.value_type = Type::ArrayEnd;
    token.value = DataRef("]");
    serializer.write(token);
  }
};

template <typename T, typename Set> struct TypeHandlerSet {
  static inline Error to(Set& to_type, ParseContext& context) {
    if (context.token.value_type != JS::Type::ArrayStart) {
      return Error::ExpectedArrayStart;
    }
    Error error = context.nextToken();
    if (error != JS::Error::NoError) {
      return error;
    }
    to_type.clear();
    while (context.token.value_type != JS::Type::ArrayEnd) {
      T t;
      error = TypeHandler<T>::to(t, context);
      if (error != JS::Error::NoError) {
        break;
      }
      auto insert_ret = to_type.insert(std::move(t));
      if (!insert_ret.second) {
        return JS::Error::DuplicateInSet;
      }

      error = context.nextToken();
      if (error != JS::Error::NoError) {
        break;
      }
    }

    return error;
  }

  static inline void from(const Set& set, Token& token, Serializer& serializer) {
    token.value_type = Type::ArrayStart;
    token.value = DataRef("[");
    serializer.write(token);

    token.name = DataRef("");

    for (auto& index : set) {
      TypeHandler<T>::from(index, token, serializer);
    }

    token.name = DataRef("");

    token.value_type = Type::ArrayEnd;
    token.value = DataRef("]");
    serializer.write(token);
  }
};
} // namespace JS
#endif // JSON_STRUCT_H

#if defined(JS_STL_MAP) && !defined(JS_STL_MAP_INCLUDE)
#define JS_STL_MAP_INCLUDE
#include <map>
namespace JS {
template <typename Key, typename Value>
struct TypeHandler<std::map<Key, Value>> : TypeHandlerMap<Key, Value, std::map<Key, Value>> {};
} // namespace JS
#endif

#if defined(JS_STL_SET) && !defined(JS_STL_SET_INCLUDE)
#define JS_STL_SET_INCLUDE
#include <set>
namespace JS {
template <typename Key> struct TypeHandler<std::set<Key>> : TypeHandlerSet<Key, std::set<Key>> {};
} // namespace JS
#endif

#if defined(JS_STL_UNORDERED_SET) && !defined(JS_STL_UNORDERED_SET_INCLUDE)
#define JS_STL_UNORDERED_SET_INCLUDE
#include <unordered_set>
namespace JS {
template <typename Key> struct TypeHandler<std::unordered_set<Key>> : TypeHandlerSet<Key, std::unordered_set<Key>> {};
} // namespace JS
#endif

#if defined(JS_STL_ARRAY) && !defined(JS_STL_ARRAY_INCLUDE)
#define JS_STL_ARRAY_INCLUDE
#include <array>
namespace JS {
template <typename T, size_t N> struct TypeHandler<std::array<T, N>> {
public:
  static inline Error to(std::array<T, N>& to_type, ParseContext& context) {
    if (context.token.value_type != Type::ArrayStart) {
      return JS::Error::ExpectedArrayStart;
    }

    context.nextToken();
    for (size_t i = 0; i < N; i++) {
      if (context.error != JS::Error::NoError) {
        return context.error;
      }
      context.error = TypeHandler<T>::to(to_type[i], context);
      if (context.error != JS::Error::NoError) {
        return context.error;
      }

      context.nextToken();
    }

    if (context.token.value_type != Type::ArrayEnd) {
      return JS::Error::ExpectedArrayEnd;
    }
    return context.error;
  }
  static void from(const std::array<T, N>& from, Token& token, Serializer& serializer) {
    token.value_type = Type::ArrayStart;
    token.value = DataRef("[");
    serializer.write(token);

    token.name = DataRef("");
    for (size_t i = 0; i < N; i++) {
      TypeHandler<T>::from(from[i], token, serializer);
    }

    token.name = DataRef("");
    token.value_type = Type::ArrayEnd;
    token.value = DataRef("]");
    serializer.write(token);
  }
};
} // namespace JS
#endif

#if defined(JS_INT_128) && !defined(JS_INT_128_INCLUDE)
#define JS_INT_128_INCLUDE 1
// Compiler support check
#if defined(__SIZEOF_INT128__) && !defined(JS_NO_INT128_TYPEDEF)
namespace JS {
__extension__ using js_int128_t = __int128;
__extension__ using js_uint128_t = unsigned __int128;
} // namespace JS
#endif

namespace JS {
/// \private
template <> struct TypeHandler<js_int128_t> : TypeHandlerIntType<js_int128_t> {};

/// \private
template <> struct TypeHandler<js_uint128_t> : TypeHandlerIntType<js_uint128_t> {};
} // namespace JS
#endif

```

`src/w1common/ext/tinyformat.hpp`:

```hpp
// tinyformat.h
// Copyright (C) 2011, Chris Foster [chris42f (at) gmail (d0t) com]
//
// Boost Software License - Version 1.0
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

//------------------------------------------------------------------------------
// Tinyformat: A minimal type safe printf replacement
//
// tinyformat.h is a type safe printf replacement library in a single C++
// header file.  Design goals include:
//
// * Type safety and extensibility for user defined types.
// * C99 printf() compatibility, to the extent possible using std::ostream
// * POSIX extension for positional arguments
// * Simplicity and minimalism.  A single header file to include and distribute
//   with your projects.
// * Augment rather than replace the standard stream formatting mechanism
// * C++98 support, with optional C++11 niceties
//
//
// Main interface example usage
// ----------------------------
//
// To print a date to std::cout for American usage:
//
//   std::string weekday = "Wednesday";
//   const char* month = "July";
//   size_t day = 27;
//   long hour = 14;
//   int min = 44;
//
//   tfm::printf("%s, %s %d, %.2d:%.2d\n", weekday, month, day, hour, min);
//
// POSIX extension for positional arguments is available.
// The ability to rearrange formatting arguments is an important feature
// for localization because the word order may vary in different languages.
//
// Previous example for German usage. Arguments are reordered:
//
//   tfm::printf("%1$s, %3$d. %2$s, %4$d:%5$.2d\n", weekday, month, day, hour, min);
//
// The strange types here emphasize the type safety of the interface; it is
// possible to print a std::string using the "%s" conversion, and a
// size_t using the "%d" conversion.  A similar result could be achieved
// using either of the tfm::format() functions.  One prints on a user provided
// stream:
//
//   tfm::format(std::cerr, "%s, %s %d, %.2d:%.2d\n",
//               weekday, month, day, hour, min);
//
// The other returns a std::string:
//
//   std::string date = tfm::format("%s, %s %d, %.2d:%.2d\n",
//                                  weekday, month, day, hour, min);
//   std::cout << date;
//
// These are the three primary interface functions.  There is also a
// convenience function printfln() which appends a newline to the usual result
// of printf() for super simple logging.
//
//
// User defined format functions
// -----------------------------
//
// Simulating variadic templates in C++98 is pretty painful since it requires
// writing out the same function for each desired number of arguments.  To make
// this bearable tinyformat comes with a set of macros which are used
// internally to generate the API, but which may also be used in user code.
//
// The three macros TINYFORMAT_ARGTYPES(n), TINYFORMAT_VARARGS(n) and
// TINYFORMAT_PASSARGS(n) will generate a list of n argument types,
// type/name pairs and argument names respectively when called with an integer
// n between 1 and 16.  We can use these to define a macro which generates the
// desired user defined function with n arguments.  To generate all 16 user
// defined function bodies, use the macro TINYFORMAT_FOREACH_ARGNUM.  For an
// example, see the implementation of printf() at the end of the source file.
//
// Sometimes it's useful to be able to pass a list of format arguments through
// to a non-template function.  The FormatList class is provided as a way to do
// this by storing the argument list in a type-opaque way.  Continuing the
// example from above, we construct a FormatList using makeFormatList():
//
//   FormatListRef formatList = tfm::makeFormatList(weekday, month, day, hour, min);
//
// The format list can now be passed into any non-template function and used
// via a call to the vformat() function:
//
//   tfm::vformat(std::cout, "%s, %s %d, %.2d:%.2d\n", formatList);
//
//
// Additional API information
// --------------------------
//
// Error handling: Define TINYFORMAT_ERROR to customize the error handling for
// format strings which are unsupported or have the wrong number of format
// specifiers (calls assert() by default).
//
// User defined types: Uses operator<< for user defined types by default.
// Overload formatValue() for more control.

#ifndef TINYFORMAT_H_INCLUDED
#define TINYFORMAT_H_INCLUDED

namespace tinyformat {}
//------------------------------------------------------------------------------
// Config section.  Customize to your liking!

// Namespace alias to encourage brevity
namespace tfm = tinyformat;

// Error handling; calls assert() by default.
// #define TINYFORMAT_ERROR(reasonString) your_error_handler(reasonString)

// Define for C++11 variadic templates which make the code shorter & more
// general.  If you don't define this, C++11 support is autodetected below.
// #define TINYFORMAT_USE_VARIADIC_TEMPLATES

//------------------------------------------------------------------------------
// Implementation details.
#include <algorithm>
#include <cmath>
#include <iostream>
#include <sstream>

#ifndef TINYFORMAT_ASSERT
#include <cassert>
#define TINYFORMAT_ASSERT(cond) assert(cond)
#endif

#ifndef TINYFORMAT_ERROR
#include <cassert>
#define TINYFORMAT_ERROR(reason) assert(0 && reason)
#endif

#if !defined(TINYFORMAT_USE_VARIADIC_TEMPLATES) && !defined(TINYFORMAT_NO_VARIADIC_TEMPLATES)
#ifdef __GXX_EXPERIMENTAL_CXX0X__
#define TINYFORMAT_USE_VARIADIC_TEMPLATES
#endif
#endif

#if defined(__GLIBCXX__) && __GLIBCXX__ < 20080201
//  std::showpos is broken on old libstdc++ as provided with macOS.  See
//  http://gcc.gnu.org/ml/libstdc++/2007-11/msg00075.html
#define TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND
#endif

#ifdef __APPLE__
// Workaround macOS linker warning: Xcode uses different default symbol
// visibilities for static libs vs executables (see issue #25)
#define TINYFORMAT_HIDDEN __attribute__((visibility("hidden")))
#else
#define TINYFORMAT_HIDDEN
#endif

namespace tinyformat {

//------------------------------------------------------------------------------
namespace detail {

// Test whether type T1 is convertible to type T2
template <typename T1, typename T2> struct is_convertible {
private:
  // two types of different size
  struct fail {
    char dummy[2];
  };
  struct succeed {
    char dummy;
  };
  // Try to convert a T1 to a T2 by plugging into tryConvert
  static fail tryConvert(...);
  static succeed tryConvert(const T2&);
  static const T1& makeT1();

public:
#ifdef _MSC_VER
  // Disable spurious loss of precision warnings in tryConvert(makeT1())
#pragma warning(push)
#pragma warning(disable : 4244)
#pragma warning(disable : 4267)
#endif
  // Standard trick: the (...) version of tryConvert will be chosen from
  // the overload set only if the version taking a T2 doesn't match.
  // Then we compare the sizes of the return types to check which
  // function matched.  Very neat, in a disgusting kind of way :)
  static const bool value = sizeof(tryConvert(makeT1())) == sizeof(succeed);
#ifdef _MSC_VER
#pragma warning(pop)
#endif
};

// Detect when a type is not a wchar_t string
template <typename T> struct is_wchar {
  typedef int tinyformat_wchar_is_not_supported;
};
template <> struct is_wchar<wchar_t*> {};
template <> struct is_wchar<const wchar_t*> {};
template <int n> struct is_wchar<const wchar_t[n]> {};
template <int n> struct is_wchar<wchar_t[n]> {};

// Format the value by casting to type fmtT.  This default implementation
// should never be called.
template <typename T, typename fmtT, bool convertible = is_convertible<T, fmtT>::value> struct formatValueAsType {
  static void invoke(std::ostream& /*out*/, const T& /*value*/) { TINYFORMAT_ASSERT(0); }
};
// Specialized version for types that can actually be converted to fmtT, as
// indicated by the "convertible" template parameter.
template <typename T, typename fmtT> struct formatValueAsType<T, fmtT, true> {
  static void invoke(std::ostream& out, const T& value) { out << static_cast<fmtT>(value); }
};

#ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND
template <typename T, bool convertible = is_convertible<T, int>::value> struct formatZeroIntegerWorkaround {
  static bool invoke(std::ostream& /**/, const T& /**/) { return false; }
};
template <typename T> struct formatZeroIntegerWorkaround<T, true> {
  static bool invoke(std::ostream& out, const T& value) {
    if (static_cast<int>(value) == 0 && out.flags() & std::ios::showpos) {
      out << "+0";
      return true;
    }
    return false;
  }
};
#endif // TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND

// Convert an arbitrary type to integer.  The version with convertible=false
// throws an error.
template <typename T, bool convertible = is_convertible<T, int>::value> struct convertToInt {
  static int invoke(const T& /*value*/) {
    TINYFORMAT_ERROR(
        "tinyformat: Cannot convert from argument type to "
        "integer for use as variable width or precision"
    );
    return 0;
  }
};
// Specialization for convertToInt when conversion is possible
template <typename T> struct convertToInt<T, true> {
  static int invoke(const T& value) { return static_cast<int>(value); }
};

// Format at most ntrunc characters to the given stream.
template <typename T> inline void formatTruncated(std::ostream& out, const T& value, int ntrunc) {
  std::ostringstream tmp;
  tmp << value;
  std::string result = tmp.str();
  out.write(result.c_str(), (std::min) (ntrunc, static_cast<int>(result.size())));
}
#define TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(type)                                                                  \
  inline void formatTruncated(std::ostream& out, type* value, int ntrunc) {                                            \
    std::streamsize len = 0;                                                                                           \
    while (len < ntrunc && value[len] != 0)                                                                            \
      ++len;                                                                                                           \
    out.write(value, len);                                                                                             \
  }
// Overload for const char* and char*.  Could overload for signed & unsigned
// char too, but these are technically unneeded for printf compatibility.
TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(const char)
TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR(char)
#undef TINYFORMAT_DEFINE_FORMAT_TRUNCATED_CSTR

template <typename T> void spaceFillIfNotFinite(std::ostream& out, const T& value) {}
// TODO: type_traits would clearly be better here. Should consider moving all
// these workarounds into a big pre-C++11 section.
#define TINYFORMAT_SETFILL_NOT_FINITE_FLOATING(type)                                                                   \
  inline void spaceFillIfNotFinite(std::ostream& out, type value) {                                                    \
    if (out.fill() == '0' && !std::isfinite(value))                                                                    \
      out.fill(' ');                                                                                                   \
  }
TINYFORMAT_SETFILL_NOT_FINITE_FLOATING(float)
TINYFORMAT_SETFILL_NOT_FINITE_FLOATING(double)
TINYFORMAT_SETFILL_NOT_FINITE_FLOATING(long double)
#undef TINYFORMAT_SETFILL_NOT_FINITE_FLOATING

} // namespace detail

//------------------------------------------------------------------------------
// Variable formatting functions.  May be overridden for user-defined types if
// desired.

/// Format a value into a stream, delegating to operator<< by default.
///
/// Users may override this for their own types.  When this function is called,
/// the stream flags will have been modified according to the format string.
/// The format specification is provided in the range [fmtBegin, fmtEnd).  For
/// truncating conversions, ntrunc is set to the desired maximum number of
/// characters, for example "%.7s" calls formatValue with ntrunc = 7.
///
/// By default, formatValue() uses the usual stream insertion operator
/// operator<< to format the type T, with special cases for the %c and %p
/// conversions.
template <typename T>
inline void formatValue(std::ostream& out, const char* /*fmtBegin*/, const char* fmtEnd, int ntrunc, const T& value) {
#ifndef TINYFORMAT_ALLOW_WCHAR_STRINGS
  // Since we don't support printing of wchar_t using "%ls", make it fail at
  // compile time in preference to printing as a void* at runtime.
  typedef typename detail::is_wchar<T>::tinyformat_wchar_is_not_supported DummyType;
  (void) DummyType(); // avoid unused type warning with gcc-4.8
#endif
  // The mess here is to support the %c and %p conversions: if these
  // conversions are active we try to convert the type to a char or const
  // void* respectively and format that instead of the value itself.  For the
  // %p conversion it's important to avoid dereferencing the pointer, which
  // could otherwise lead to a crash when printing a dangling (const char*).
  const bool canConvertToChar = detail::is_convertible<T, char>::value;
  const bool canConvertToVoidPtr = detail::is_convertible<T, const void*>::value;
  detail::spaceFillIfNotFinite(out, value);
  if (canConvertToChar && *(fmtEnd - 1) == 'c') {
    detail::formatValueAsType<T, char>::invoke(out, value);
  } else if (canConvertToVoidPtr && *(fmtEnd - 1) == 'p') {
    detail::formatValueAsType<T, const void*>::invoke(out, value);
  }
#ifdef TINYFORMAT_OLD_LIBSTDCPLUSPLUS_WORKAROUND
  else if (detail::formatZeroIntegerWorkaround<T>::invoke(out, value)) /**/
    ;
#endif
  else if (ntrunc >= 0) {
    // Take care not to overread C strings in truncating conversions like
    // "%.4s" where at most 4 characters may be read.
    detail::formatTruncated(out, value, ntrunc);
  } else {
    out << value;
  }
}

// Overloaded version for char types to support printing as an integer
#define TINYFORMAT_DEFINE_FORMATVALUE_CHAR(charType)                                                                   \
  inline void formatValue(std::ostream& out, const char* /*fmtBegin*/, const char* fmtEnd, int /**/, charType value) { \
    switch (*(fmtEnd - 1)) {                                                                                           \
    case 'u':                                                                                                          \
    case 'd':                                                                                                          \
    case 'i':                                                                                                          \
    case 'o':                                                                                                          \
    case 'X':                                                                                                          \
    case 'x':                                                                                                          \
      out << static_cast<int>(value);                                                                                  \
      break;                                                                                                           \
    default:                                                                                                           \
      out << value;                                                                                                    \
      break;                                                                                                           \
    }                                                                                                                  \
  }
// per 3.9.1: char, signed char and unsigned char are all distinct types
TINYFORMAT_DEFINE_FORMATVALUE_CHAR(char)
TINYFORMAT_DEFINE_FORMATVALUE_CHAR(signed char)
TINYFORMAT_DEFINE_FORMATVALUE_CHAR(unsigned char)
#undef TINYFORMAT_DEFINE_FORMATVALUE_CHAR

//------------------------------------------------------------------------------
// Tools for emulating variadic templates in C++98.  The basic idea here is
// stolen from the boost preprocessor metaprogramming library and cut down to
// be just general enough for what we need.

#define TINYFORMAT_ARGTYPES(n) TINYFORMAT_ARGTYPES_##n
#define TINYFORMAT_VARARGS(n) TINYFORMAT_VARARGS_##n
#define TINYFORMAT_PASSARGS(n) TINYFORMAT_PASSARGS_##n
#define TINYFORMAT_PASSARGS_TAIL(n) TINYFORMAT_PASSARGS_TAIL_##n

// To keep it as transparent as possible, the macros below have been generated
// using python via the excellent cog code generation script.  This avoids
// the need for a bunch of complex (but more general) preprocessor tricks as
// used in boost.preprocessor.
//
// To rerun the code generation in place, use `cog -r tinyformat.h`
// (see http://nedbatchelder.com/code/cog).  Alternatively you can just create
// extra versions by hand.

/*[[[cog
maxParams = 16

def makeCommaSepLists(lineTemplate, elemTemplate, startInd=1):
    for j in range(startInd,maxParams+1):
        list = ', '.join([elemTemplate % {'i':i} for i in range(startInd,j+1)])
        cog.outl(lineTemplate % {'j':j, 'list':list})

makeCommaSepLists('#define TINYFORMAT_ARGTYPES_%(j)d %(list)s',
                  'class T%(i)d')

cog.outl()
makeCommaSepLists('#define TINYFORMAT_VARARGS_%(j)d %(list)s',
                  'const T%(i)d& v%(i)d')

cog.outl()
makeCommaSepLists('#define TINYFORMAT_PASSARGS_%(j)d %(list)s', 'v%(i)d')

cog.outl()
cog.outl('#define TINYFORMAT_PASSARGS_TAIL_1')
makeCommaSepLists('#define TINYFORMAT_PASSARGS_TAIL_%(j)d , %(list)s',
                  'v%(i)d', startInd = 2)

cog.outl()
cog.outl('#define TINYFORMAT_FOREACH_ARGNUM(m) \\\n    ' +
         ' '.join(['m(%d)' % (j,) for j in range(1,maxParams+1)]))
]]]*/
#define TINYFORMAT_ARGTYPES_1 class T1
#define TINYFORMAT_ARGTYPES_2 class T1, class T2
#define TINYFORMAT_ARGTYPES_3 class T1, class T2, class T3
#define TINYFORMAT_ARGTYPES_4 class T1, class T2, class T3, class T4
#define TINYFORMAT_ARGTYPES_5 class T1, class T2, class T3, class T4, class T5
#define TINYFORMAT_ARGTYPES_6 class T1, class T2, class T3, class T4, class T5, class T6
#define TINYFORMAT_ARGTYPES_7 class T1, class T2, class T3, class T4, class T5, class T6, class T7
#define TINYFORMAT_ARGTYPES_8 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8
#define TINYFORMAT_ARGTYPES_9 class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9
#define TINYFORMAT_ARGTYPES_10                                                                                         \
  class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10
#define TINYFORMAT_ARGTYPES_11                                                                                         \
  class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11
#define TINYFORMAT_ARGTYPES_12                                                                                         \
  class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11,      \
      class T12
#define TINYFORMAT_ARGTYPES_13                                                                                         \
  class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11,      \
      class T12, class T13
#define TINYFORMAT_ARGTYPES_14                                                                                         \
  class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11,      \
      class T12, class T13, class T14
#define TINYFORMAT_ARGTYPES_15                                                                                         \
  class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11,      \
      class T12, class T13, class T14, class T15
#define TINYFORMAT_ARGTYPES_16                                                                                         \
  class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11,      \
      class T12, class T13, class T14, class T15, class T16

#define TINYFORMAT_VARARGS_1 const T1& v1
#define TINYFORMAT_VARARGS_2 const T1 &v1, const T2 &v2
#define TINYFORMAT_VARARGS_3 const T1 &v1, const T2 &v2, const T3 &v3
#define TINYFORMAT_VARARGS_4 const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4
#define TINYFORMAT_VARARGS_5 const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5
#define TINYFORMAT_VARARGS_6 const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6
#define TINYFORMAT_VARARGS_7                                                                                           \
  const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7
#define TINYFORMAT_VARARGS_8                                                                                           \
  const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7, const T8 &v8
#define TINYFORMAT_VARARGS_9                                                                                           \
  const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7, const T8 &v8,      \
      const T9 &v9
#define TINYFORMAT_VARARGS_10                                                                                          \
  const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7, const T8 &v8,      \
      const T9 &v9, const T10 &v10
#define TINYFORMAT_VARARGS_11                                                                                          \
  const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7, const T8 &v8,      \
      const T9 &v9, const T10 &v10, const T11 &v11
#define TINYFORMAT_VARARGS_12                                                                                          \
  const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7, const T8 &v8,      \
      const T9 &v9, const T10 &v10, const T11 &v11, const T12 &v12
#define TINYFORMAT_VARARGS_13                                                                                          \
  const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7, const T8 &v8,      \
      const T9 &v9, const T10 &v10, const T11 &v11, const T12 &v12, const T13 &v13
#define TINYFORMAT_VARARGS_14                                                                                          \
  const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7, const T8 &v8,      \
      const T9 &v9, const T10 &v10, const T11 &v11, const T12 &v12, const T13 &v13, const T14 &v14
#define TINYFORMAT_VARARGS_15                                                                                          \
  const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7, const T8 &v8,      \
      const T9 &v9, const T10 &v10, const T11 &v11, const T12 &v12, const T13 &v13, const T14 &v14, const T15 &v15
#define TINYFORMAT_VARARGS_16                                                                                          \
  const T1 &v1, const T2 &v2, const T3 &v3, const T4 &v4, const T5 &v5, const T6 &v6, const T7 &v7, const T8 &v8,      \
      const T9 &v9, const T10 &v10, const T11 &v11, const T12 &v12, const T13 &v13, const T14 &v14, const T15 &v15,    \
      const T16 &v16

#define TINYFORMAT_PASSARGS_1 v1
#define TINYFORMAT_PASSARGS_2 v1, v2
#define TINYFORMAT_PASSARGS_3 v1, v2, v3
#define TINYFORMAT_PASSARGS_4 v1, v2, v3, v4
#define TINYFORMAT_PASSARGS_5 v1, v2, v3, v4, v5
#define TINYFORMAT_PASSARGS_6 v1, v2, v3, v4, v5, v6
#define TINYFORMAT_PASSARGS_7 v1, v2, v3, v4, v5, v6, v7
#define TINYFORMAT_PASSARGS_8 v1, v2, v3, v4, v5, v6, v7, v8
#define TINYFORMAT_PASSARGS_9 v1, v2, v3, v4, v5, v6, v7, v8, v9
#define TINYFORMAT_PASSARGS_10 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10
#define TINYFORMAT_PASSARGS_11 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11
#define TINYFORMAT_PASSARGS_12 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12
#define TINYFORMAT_PASSARGS_13 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13
#define TINYFORMAT_PASSARGS_14 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14
#define TINYFORMAT_PASSARGS_15 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15
#define TINYFORMAT_PASSARGS_16 v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16

#define TINYFORMAT_PASSARGS_TAIL_1
#define TINYFORMAT_PASSARGS_TAIL_2 , v2
#define TINYFORMAT_PASSARGS_TAIL_3 , v2, v3
#define TINYFORMAT_PASSARGS_TAIL_4 , v2, v3, v4
#define TINYFORMAT_PASSARGS_TAIL_5 , v2, v3, v4, v5
#define TINYFORMAT_PASSARGS_TAIL_6 , v2, v3, v4, v5, v6
#define TINYFORMAT_PASSARGS_TAIL_7 , v2, v3, v4, v5, v6, v7
#define TINYFORMAT_PASSARGS_TAIL_8 , v2, v3, v4, v5, v6, v7, v8
#define TINYFORMAT_PASSARGS_TAIL_9 , v2, v3, v4, v5, v6, v7, v8, v9
#define TINYFORMAT_PASSARGS_TAIL_10 , v2, v3, v4, v5, v6, v7, v8, v9, v10
#define TINYFORMAT_PASSARGS_TAIL_11 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11
#define TINYFORMAT_PASSARGS_TAIL_12 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12
#define TINYFORMAT_PASSARGS_TAIL_13 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13
#define TINYFORMAT_PASSARGS_TAIL_14 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14
#define TINYFORMAT_PASSARGS_TAIL_15 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15
#define TINYFORMAT_PASSARGS_TAIL_16 , v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16

#define TINYFORMAT_FOREACH_ARGNUM(m)                                                                                   \
  m(1) m(2) m(3) m(4) m(5) m(6) m(7) m(8) m(9) m(10) m(11) m(12) m(13) m(14) m(15) m(16)
//[[[end]]]

namespace detail {

// Type-opaque holder for an argument to format(), with associated actions on
// the type held as explicit function pointers.  This allows FormatArg's for
// each argument to be allocated as a homogeneous array inside FormatList
// whereas a naive implementation based on inheritance does not.
class FormatArg {
public:
  FormatArg() : m_value(NULL), m_formatImpl(NULL), m_toIntImpl(NULL) {}

  template <typename T>
  FormatArg(const T& value)
      // C-style cast here allows us to also remove volatile; we put it
      // back in the *Impl functions before dereferencing to avoid UB.
      : m_value((const void*) (&value)), m_formatImpl(&formatImpl<T>), m_toIntImpl(&toIntImpl<T>) {}

  void format(std::ostream& out, const char* fmtBegin, const char* fmtEnd, int ntrunc) const {
    TINYFORMAT_ASSERT(m_value);
    TINYFORMAT_ASSERT(m_formatImpl);
    m_formatImpl(out, fmtBegin, fmtEnd, ntrunc, m_value);
  }

  int toInt() const {
    TINYFORMAT_ASSERT(m_value);
    TINYFORMAT_ASSERT(m_toIntImpl);
    return m_toIntImpl(m_value);
  }

private:
  template <typename T>
  TINYFORMAT_HIDDEN static void formatImpl(
      std::ostream& out, const char* fmtBegin, const char* fmtEnd, int ntrunc, const void* value
  ) {
    formatValue(out, fmtBegin, fmtEnd, ntrunc, *static_cast<const T*>(value));
  }

  template <typename T> TINYFORMAT_HIDDEN static int toIntImpl(const void* value) {
    return convertToInt<T>::invoke(*static_cast<const T*>(value));
  }

  const void* m_value;
  void (*m_formatImpl)(std::ostream& out, const char* fmtBegin, const char* fmtEnd, int ntrunc, const void* value);
  int (*m_toIntImpl)(const void* value);
};

// Parse and return an integer from the string c, as atoi()
// On return, c is set to one past the end of the integer.
inline int parseIntAndAdvance(const char*& c) {
  int i = 0;
  for (; *c >= '0' && *c <= '9'; ++c) {
    i = 10 * i + (*c - '0');
  }
  return i;
}

// Parse width or precision `n` from format string pointer `c`, and advance it
// to the next character. If an indirection is requested with `*`, the argument
// is read from `args[argIndex]` and `argIndex` is incremented (or read
// from `args[n]` in positional mode). Returns true if one or more
// characters were read.
inline bool parseWidthOrPrecision(
    int& n, const char*& c, bool positionalMode, const detail::FormatArg* args, int& argIndex, int numArgs
) {
  if (*c >= '0' && *c <= '9') {
    n = parseIntAndAdvance(c);
  } else if (*c == '*') {
    ++c;
    n = 0;
    if (positionalMode) {
      int pos = parseIntAndAdvance(c) - 1;
      if (*c != '$') {
        TINYFORMAT_ERROR("tinyformat: Non-positional argument used after a positional one");
      }
      if (pos >= 0 && pos < numArgs) {
        n = args[pos].toInt();
      } else {
        TINYFORMAT_ERROR("tinyformat: Positional argument out of range");
      }
      ++c;
    } else {
      if (argIndex < numArgs) {
        n = args[argIndex++].toInt();
      } else {
        TINYFORMAT_ERROR("tinyformat: Not enough arguments to read variable width or precision");
      }
    }
  } else {
    return false;
  }
  return true;
}

// Print literal part of format string and return next format spec position.
//
// Skips over any occurrences of '%%', printing a literal '%' to the output.
// The position of the first % character of the next nontrivial format spec is
// returned, or the end of string.
inline const char* printFormatStringLiteral(std::ostream& out, const char* fmt) {
  const char* c = fmt;
  for (;; ++c) {
    if (*c == '\0') {
      out.write(fmt, c - fmt);
      return c;
    } else if (*c == '%') {
      out.write(fmt, c - fmt);
      if (*(c + 1) != '%') {
        return c;
      }
      // for "%%", tack trailing % onto next literal section.
      fmt = ++c;
    }
  }
}

// Parse a format string and set the stream state accordingly.
//
// The format mini-language recognized here is meant to be the one from C99,
// with the form "%[flags][width][.precision][length]type" with POSIX
// positional arguments extension.
//
// POSIX positional arguments extension:
// Conversions can be applied to the nth argument after the format in
// the argument list, rather than to the next unused argument. In this case,
// the conversion specifier character % (see below) is replaced by the sequence
// "%n$", where n is a decimal integer in the range [1,{NL_ARGMAX}],
// giving the position of the argument in the argument list. This feature
// provides for the definition of format strings that select arguments
// in an order appropriate to specific languages.
//
// The format can contain either numbered argument conversion specifications
// (that is, "%n$" and "*m$"), or unnumbered argument conversion specifications
// (that is, % and * ), but not both. The only exception to this is that %%
// can be mixed with the "%n$" form. The results of mixing numbered and
// unnumbered argument specifications in a format string are undefined.
// When numbered argument specifications are used, specifying the Nth argument
// requires that all the leading arguments, from the first to the (N-1)th,
// are specified in the format string.
//
// In format strings containing the "%n$" form of conversion specification,
// numbered arguments in the argument list can be referenced from the format
// string as many times as required.
//
// Formatting options which can't be natively represented using the ostream
// state are returned in spacePadPositive (for space padded positive numbers)
// and ntrunc (for truncating conversions).  argIndex is incremented if
// necessary to pull out variable width and precision.  The function returns a
// pointer to the character after the end of the current format spec.
inline const char* streamStateFromFormat(
    std::ostream& out, bool& positionalMode, bool& spacePadPositive, int& ntrunc, const char* fmtStart,
    const detail::FormatArg* args, int& argIndex, int numArgs
) {
  TINYFORMAT_ASSERT(*fmtStart == '%');
  // Reset stream state to defaults.
  out.width(0);
  out.precision(6);
  out.fill(' ');
  // Reset most flags; ignore irrelevant unitbuf & skipws.
  out.unsetf(
      std::ios::adjustfield | std::ios::basefield | std::ios::floatfield | std::ios::showbase | std::ios::boolalpha |
      std::ios::showpoint | std::ios::showpos | std::ios::uppercase
  );
  bool precisionSet = false;
  bool widthSet = false;
  int widthExtra = 0;
  const char* c = fmtStart + 1;

  // 1) Parse an argument index (if followed by '$') or a width possibly
  // preceded with '0' flag.
  if (*c >= '0' && *c <= '9') {
    const char tmpc = *c;
    int value = parseIntAndAdvance(c);
    if (*c == '$') {
      // value is an argument index
      if (value > 0 && value <= numArgs) {
        argIndex = value - 1;
      } else {
        TINYFORMAT_ERROR("tinyformat: Positional argument out of range");
      }
      ++c;
      positionalMode = true;
    } else if (positionalMode) {
      TINYFORMAT_ERROR("tinyformat: Non-positional argument used after a positional one");
    } else {
      if (tmpc == '0') {
        // Use internal padding so that numeric values are
        // formatted correctly, eg -00010 rather than 000-10
        out.fill('0');
        out.setf(std::ios::internal, std::ios::adjustfield);
      }
      if (value != 0) {
        // Nonzero value means that we parsed width.
        widthSet = true;
        out.width(value);
      }
    }
  } else if (positionalMode) {
    TINYFORMAT_ERROR("tinyformat: Non-positional argument used after a positional one");
  }
  // 2) Parse flags and width if we did not do it in previous step.
  if (!widthSet) {
    // Parse flags
    for (;; ++c) {
      switch (*c) {
      case '#':
        out.setf(std::ios::showpoint | std::ios::showbase);
        continue;
      case '0':
        // overridden by left alignment ('-' flag)
        if (!(out.flags() & std::ios::left)) {
          // Use internal padding so that numeric values are
          // formatted correctly, eg -00010 rather than 000-10
          out.fill('0');
          out.setf(std::ios::internal, std::ios::adjustfield);
        }
        continue;
      case '-':
        out.fill(' ');
        out.setf(std::ios::left, std::ios::adjustfield);
        continue;
      case ' ':
        // overridden by show positive sign, '+' flag.
        if (!(out.flags() & std::ios::showpos)) {
          spacePadPositive = true;
        }
        continue;
      case '+':
        out.setf(std::ios::showpos);
        spacePadPositive = false;
        widthExtra = 1;
        continue;
      default:
        break;
      }
      break;
    }
    // Parse width
    int width = 0;
    widthSet = parseWidthOrPrecision(width, c, positionalMode, args, argIndex, numArgs);
    if (widthSet) {
      if (width < 0) {
        // negative widths correspond to '-' flag set
        out.fill(' ');
        out.setf(std::ios::left, std::ios::adjustfield);
        width = -width;
      }
      out.width(width);
    }
  }
  // 3) Parse precision
  if (*c == '.') {
    ++c;
    int precision = 0;
    parseWidthOrPrecision(precision, c, positionalMode, args, argIndex, numArgs);
    // Presence of `.` indicates precision set, unless the inferred value
    // was negative in which case the default is used.
    precisionSet = precision >= 0;
    if (precisionSet) {
      out.precision(precision);
    }
  }
  // 4) Ignore any C99 length modifier
  while (*c == 'l' || *c == 'h' || *c == 'L' || *c == 'j' || *c == 'z' || *c == 't') {
    ++c;
  }
  // 5) We're up to the conversion specifier character.
  // Set stream flags based on conversion specifier (thanks to the
  // boost::format class for forging the way here).
  bool intConversion = false;
  switch (*c) {
  case 'u':
  case 'd':
  case 'i':
    out.setf(std::ios::dec, std::ios::basefield);
    intConversion = true;
    break;
  case 'o':
    out.setf(std::ios::oct, std::ios::basefield);
    intConversion = true;
    break;
  case 'X':
    out.setf(std::ios::uppercase);
    // Falls through
  case 'x':
  case 'p':
    out.setf(std::ios::hex, std::ios::basefield);
    intConversion = true;
    break;
  case 'E':
    out.setf(std::ios::uppercase);
    // Falls through
  case 'e':
    out.setf(std::ios::scientific, std::ios::floatfield);
    out.setf(std::ios::dec, std::ios::basefield);
    break;
  case 'F':
    out.setf(std::ios::uppercase);
    // Falls through
  case 'f':
    out.setf(std::ios::fixed, std::ios::floatfield);
    break;
  case 'A':
    out.setf(std::ios::uppercase);
    // Falls through
  case 'a':
#ifdef _MSC_VER
    // Workaround
    // https://developercommunity.visualstudio.com/content/problem/520472/hexfloat-stream-output-does-not-ignore-precision-a.html
    // by always setting maximum precision on MSVC to avoid precision
    // loss for doubles.
    out.precision(13);
#endif
    out.setf(std::ios::fixed | std::ios::scientific, std::ios::floatfield);
    break;
  case 'G':
    out.setf(std::ios::uppercase);
    // Falls through
  case 'g':
    out.setf(std::ios::dec, std::ios::basefield);
    // As in boost::format, let stream decide float format.
    out.flags(out.flags() & ~std::ios::floatfield);
    break;
  case 'c':
    // Handled as special case inside formatValue()
    break;
  case 's':
    if (precisionSet) {
      ntrunc = static_cast<int>(out.precision());
    }
    // Make %s print Booleans as "true" and "false"
    out.setf(std::ios::boolalpha);
    break;
  case 'n':
    // Not supported - will cause problems!
    TINYFORMAT_ERROR("tinyformat: %n conversion spec not supported");
    break;
  case '\0':
    TINYFORMAT_ERROR(
        "tinyformat: Conversion spec incorrectly "
        "terminated by end of string"
    );
    return c;
  default:
    break;
  }
  if (intConversion && precisionSet && !widthSet) {
    // "precision" for integers gives the minimum number of digits (to be
    // padded with zeros on the left).  This isn't really supported by the
    // iostreams, but we can approximately simulate it with the width if
    // the width isn't otherwise used.
    out.width(out.precision() + widthExtra);
    out.setf(std::ios::internal, std::ios::adjustfield);
    out.fill('0');
  }
  return c + 1;
}

//------------------------------------------------------------------------------
inline void formatImpl(std::ostream& out, const char* fmt, const detail::FormatArg* args, int numArgs) {
  // Saved stream state
  std::streamsize origWidth = out.width();
  std::streamsize origPrecision = out.precision();
  std::ios::fmtflags origFlags = out.flags();
  char origFill = out.fill();

  // "Positional mode" means all format specs should be of the form "%n$..."
  // with `n` an integer. We detect this in `streamStateFromFormat`.
  bool positionalMode = false;
  int argIndex = 0;
  while (true) {
    fmt = printFormatStringLiteral(out, fmt);
    if (*fmt == '\0') {
      if (!positionalMode && argIndex < numArgs) {
        TINYFORMAT_ERROR("tinyformat: Not enough conversion specifiers in format string");
      }
      break;
    }
    bool spacePadPositive = false;
    int ntrunc = -1;
    const char* fmtEnd =
        streamStateFromFormat(out, positionalMode, spacePadPositive, ntrunc, fmt, args, argIndex, numArgs);
    // NB: argIndex may be incremented by reading variable width/precision
    // in `streamStateFromFormat`, so do the bounds check here.
    if (argIndex >= numArgs) {
      TINYFORMAT_ERROR("tinyformat: Too many conversion specifiers in format string");
      return;
    }
    const FormatArg& arg = args[argIndex];
    // Format the arg into the stream.
    if (!spacePadPositive) {
      arg.format(out, fmt, fmtEnd, ntrunc);
    } else {
      // The following is a special case with no direct correspondence
      // between stream formatting and the printf() behaviour.  Simulate
      // it crudely by formatting into a temporary string stream and
      // munging the resulting string.
      std::ostringstream tmpStream;
      tmpStream.copyfmt(out);
      tmpStream.setf(std::ios::showpos);
      arg.format(tmpStream, fmt, fmtEnd, ntrunc);
      std::string result = tmpStream.str(); // allocates... yuck.
      for (size_t i = 0, iend = result.size(); i < iend; ++i) {
        if (result[i] == '+') {
          result[i] = ' ';
        }
      }
      out << result;
    }
    if (!positionalMode) {
      ++argIndex;
    }
    fmt = fmtEnd;
  }

  // Restore stream state
  out.width(origWidth);
  out.precision(origPrecision);
  out.flags(origFlags);
  out.fill(origFill);
}

} // namespace detail

/// List of template arguments format(), held in a type-opaque way.
///
/// A const reference to FormatList (typedef'd as FormatListRef) may be
/// conveniently used to pass arguments to non-template functions: All type
/// information has been stripped from the arguments, leaving just enough of a
/// common interface to perform formatting as required.
class FormatList {
public:
  FormatList(detail::FormatArg* args, int N) : m_args(args), m_N(N) {}

  friend void vformat(std::ostream& out, const char* fmt, const FormatList& list);

private:
  const detail::FormatArg* m_args;
  int m_N;
};

/// Reference to type-opaque format list for passing to vformat()
typedef const FormatList& FormatListRef;

namespace detail {

// Format list subclass with fixed storage to avoid dynamic allocation
template <std::size_t N> class FormatListN : public FormatList {
public:
#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES
  template <typename... Args>
  FormatListN(const Args&... args) : FormatList(&m_formatterStore[0], N), m_formatterStore{FormatArg(args)...} {
    static_assert(sizeof...(args) == N, "Number of args must be N");
  }
#else // C++98 version
  void init(int) {}
#define TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR(n)                                                                      \
                                                                                                                       \
  template <TINYFORMAT_ARGTYPES(n)> FormatListN(TINYFORMAT_VARARGS(n)) : FormatList(&m_formatterStore[0], n) {         \
    TINYFORMAT_ASSERT(n == N);                                                                                         \
    init(0, TINYFORMAT_PASSARGS(n));                                                                                   \
  }                                                                                                                    \
                                                                                                                       \
  template <TINYFORMAT_ARGTYPES(n)> void init(int i, TINYFORMAT_VARARGS(n)) {                                          \
    m_formatterStore[i] = FormatArg(v1);                                                                               \
    init(i + 1 TINYFORMAT_PASSARGS_TAIL(n));                                                                           \
  }

  TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR)
#undef TINYFORMAT_MAKE_FORMATLIST_CONSTRUCTOR
#endif
  FormatListN(const FormatListN& other) : FormatList(&m_formatterStore[0], N) {
    std::copy(&other.m_formatterStore[0], &other.m_formatterStore[N], &m_formatterStore[0]);
  }

private:
  FormatArg m_formatterStore[N];
};

// Special 0-arg version - MSVC says zero-sized C array in struct is nonstandard
template <> class FormatListN<0> : public FormatList {
public:
  FormatListN() : FormatList(0, 0) {}
};

} // namespace detail

//------------------------------------------------------------------------------
// Primary API functions

#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES

/// Make type-agnostic format list from list of template arguments.
///
/// The exact return type of this function is an implementation detail and
/// shouldn't be relied upon.  Instead it should be stored as a FormatListRef:
///
///   FormatListRef formatList = makeFormatList( /*...*/ );
template <typename... Args> detail::FormatListN<sizeof...(Args)> makeFormatList(const Args&... args) {
  return detail::FormatListN<sizeof...(args)>(args...);
}

#else // C++98 version

inline detail::FormatListN<0> makeFormatList() { return detail::FormatListN<0>(); }
#define TINYFORMAT_MAKE_MAKEFORMATLIST(n)                                                                              \
  template <TINYFORMAT_ARGTYPES(n)> detail::FormatListN<n> makeFormatList(TINYFORMAT_VARARGS(n)) {                     \
    return detail::FormatListN<n>(TINYFORMAT_PASSARGS(n));                                                             \
  }
TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_MAKEFORMATLIST)
#undef TINYFORMAT_MAKE_MAKEFORMATLIST

#endif

/// Format list of arguments to the stream according to the given format string.
///
/// The name vformat() is chosen for the semantic similarity to vprintf(): the
/// list of format arguments is held in a single function argument.
inline void vformat(std::ostream& out, const char* fmt, FormatListRef list) {
  detail::formatImpl(out, fmt, list.m_args, list.m_N);
}

#ifdef TINYFORMAT_USE_VARIADIC_TEMPLATES

/// Format list of arguments to the stream according to given format string.
template <typename... Args> void format(std::ostream& out, const char* fmt, const Args&... args) {
  vformat(out, fmt, makeFormatList(args...));
}

/// Format list of arguments according to the given format string and return
/// the result as a string.
template <typename... Args> std::string format(const char* fmt, const Args&... args) {
  std::ostringstream oss;
  format(oss, fmt, args...);
  return oss.str();
}

/// Format list of arguments to std::cout, according to the given format string
template <typename... Args> void printf(const char* fmt, const Args&... args) { format(std::cout, fmt, args...); }

template <typename... Args> void printfln(const char* fmt, const Args&... args) {
  format(std::cout, fmt, args...);
  std::cout << '\n';
}

#else // C++98 version

inline void format(std::ostream& out, const char* fmt) { vformat(out, fmt, makeFormatList()); }

inline std::string format(const char* fmt) {
  std::ostringstream oss;
  format(oss, fmt);
  return oss.str();
}

inline void printf(const char* fmt) { format(std::cout, fmt); }

inline void printfln(const char* fmt) {
  format(std::cout, fmt);
  std::cout << '\n';
}

#define TINYFORMAT_MAKE_FORMAT_FUNCS(n)                                                                                \
                                                                                                                       \
  template <TINYFORMAT_ARGTYPES(n)> void format(std::ostream& out, const char* fmt, TINYFORMAT_VARARGS(n)) {           \
    vformat(out, fmt, makeFormatList(TINYFORMAT_PASSARGS(n)));                                                         \
  }                                                                                                                    \
                                                                                                                       \
  template <TINYFORMAT_ARGTYPES(n)> std::string format(const char* fmt, TINYFORMAT_VARARGS(n)) {                       \
    std::ostringstream oss;                                                                                            \
    format(oss, fmt, TINYFORMAT_PASSARGS(n));                                                                          \
    return oss.str();                                                                                                  \
  }                                                                                                                    \
                                                                                                                       \
  template <TINYFORMAT_ARGTYPES(n)> void printf(const char* fmt, TINYFORMAT_VARARGS(n)) {                              \
    format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                                                                    \
  }                                                                                                                    \
                                                                                                                       \
  template <TINYFORMAT_ARGTYPES(n)> void printfln(const char* fmt, TINYFORMAT_VARARGS(n)) {                            \
    format(std::cout, fmt, TINYFORMAT_PASSARGS(n));                                                                    \
    std::cout << '\n';                                                                                                 \
  }

TINYFORMAT_FOREACH_ARGNUM(TINYFORMAT_MAKE_FORMAT_FUNCS)
#undef TINYFORMAT_MAKE_FORMAT_FUNCS

#endif

} // namespace tinyformat

#endif // TINYFORMAT_H_INCLUDED

```

`src/w1common/platform_utils.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>

#ifdef _WIN32
#define NEED_PSAPI
#define NEED_TLHELP32
#include <w1common/windows_clean.hpp>
#endif

namespace w1::common {

/**
 * @brief Cross-platform utility functions for platform detection and path handling
 */
namespace platform_utils {

/**
 * @brief Get the current platform name as a string
 * @return Platform name ("macos", "linux", "windows", or "unknown")
 */
inline std::string get_platform_name() {
#ifdef __APPLE__
  return "macos";
#elif defined(__linux__)
  return "linux";
#elif defined(_WIN32)
  return "windows";
#else
  return "unknown";
#endif
}

/**
 * @brief Get the appropriate dynamic library file extension for the current platform
 * @return Library extension including the dot (e.g., ".dylib", ".so", ".dll")
 */
inline std::string get_library_extension() {
#ifdef __APPLE__
  return ".dylib";
#elif defined(__linux__)
  return ".so";
#elif defined(_WIN32)
  return ".dll";
#else
#error "Unsupported platform for dynamic library loading"
#endif
}

/**
 * @brief Get standard system library paths for the current platform
 * @return Vector of system library directory paths
 */
inline std::vector<std::string> get_system_library_paths() {
  std::vector<std::string> paths;

#ifdef __APPLE__
  paths = {"/System/Library/", "/usr/lib/", "/usr/local/lib/", "/Library/Frameworks/"};
#elif defined(__linux__)
  paths = {
      "/lib/",
      "/lib64/",
      "/usr/lib/",
      "/usr/lib64/",
      "/usr/local/lib/",
      "/usr/lib/x86_64-linux-gnu/",
      "/lib/x86_64-linux-gnu/"
  };
#elif defined(_WIN32)
  paths = {"C:\\Windows\\System32\\", "C:\\Windows\\SysWOW64\\", "C:\\Program Files\\", "C:\\Program Files (x86)\\"};
#endif

  return paths;
}

/**
 * @brief Check if a given path represents a system library/module
 * @param path The path to check
 * @return True if the path appears to be a system library
 */
inline bool is_system_library_path(const std::string& path) {
  if (path.empty() || path == "[anonymous]" || path.find("[") == 0) {
    return true; // anonymous mappings are usually system
  }

  auto system_paths = get_system_library_paths();
  for (const auto& sys_path : system_paths) {
    if (path.find(sys_path) != std::string::npos) {
      return true;
    }
  }

  // check for common system library name patterns
#ifdef __APPLE__
  return path.find("libsystem_") != std::string::npos || path.find("libc++") != std::string::npos ||
         path.find("libdyld") != std::string::npos || path.find(".framework/") != std::string::npos;
#elif defined(__linux__)
  return path.find("ld-linux") != std::string::npos || path.find("libc.so") != std::string::npos ||
         path.find("libstdc++") != std::string::npos || path.find("libgcc") != std::string::npos;
#elif defined(_WIN32)
  return path.find("ntdll.dll") != std::string::npos || path.find("kernel32.dll") != std::string::npos ||
         path.find("msvcrt.dll") != std::string::npos || path.find("vcruntime") != std::string::npos;
#else
  return false;
#endif
}

/**
 * @brief Get the platform-specific process ID type size
 * @return Size of process ID in bytes
 */
inline size_t get_pid_size() {
#ifdef _WIN32
  return sizeof(DWORD);
#else
  return sizeof(pid_t);
#endif
}

/**
 * @brief Check if the current platform supports runtime library injection
 * @return True if runtime injection is supported
 */
inline bool supports_runtime_injection() {
#ifdef __APPLE__
  return true; // DYLD_INSERT_LIBRARIES
#elif defined(__linux__)
  return true; // LD_PRELOAD
#elif defined(_WIN32)
  return true; // DLL injection via CreateRemoteThread/SetWindowsHookEx
#else
  return false;
#endif
}

/**
 * @brief Get the environment variable name for library preloading
 * @return Environment variable name for the current platform
 */
inline std::string get_preload_env_var() {
#ifdef __APPLE__
  return "DYLD_INSERT_LIBRARIES";
#elif defined(__linux__)
  return "LD_PRELOAD";
#elif defined(_WIN32)
  return ""; // windows doesn't use environment variables for DLL injection
#else
  return "";
#endif
}

} // namespace platform_utils
} // namespace w1::common
```

`src/w1common/windows_clean.hpp`:

```hpp
#pragma once

/**
 * @brief Clean Windows headers without macro pollution
 *
 * This header provides access to Windows APIs while preventing
 * the numerous macro definitions that pollute the global namespace
 * and conflict with modern C++ code.
 *
 * Usage: Include this instead of <windows.h> directly.
 */

#ifdef _WIN32

// Prevent Windows from defining min/max macros and other pollution
#ifndef NOMINMAX
#define NOMINMAX
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

// Prevent common macro conflicts
#ifndef VC_EXTRALEAN
#define VC_EXTRALEAN
#endif

// Include Windows headers
#include <windows.h>

// Additional Windows headers that might be needed
#ifdef NEED_PSAPI
#include <psapi.h>
#endif

#ifdef NEED_TLHELP32
#include <tlhelp32.h>
#endif

// Undefine the most problematic macros that conflict with modern C++
#ifdef IN
#undef IN
#endif

#ifdef OUT
#undef OUT
#endif

#ifdef VOID
#undef VOID
#endif

#ifdef ERROR
#undef ERROR
#endif

#ifdef DELETE
#undef DELETE
#endif

#ifdef OPTIONAL
#undef OPTIONAL
#endif

#ifdef CONST
#undef CONST
#endif

#ifdef CALLBACK
#undef CALLBACK
#endif

#ifdef STRICT
#undef STRICT
#endif

// Common function name conflicts
#ifdef CreateWindow
#undef CreateWindow
#endif

#ifdef CreateFile
#undef CreateFile
#endif

#ifdef LoadLibrary
#undef LoadLibrary
#endif

#ifdef GetMessage
#undef GetMessage
#endif

#ifdef SendMessage
#undef SendMessage
#endif

#ifdef MessageBox
#undef MessageBox
#endif

#ifdef CreateProcess
#undef CreateProcess
#endif

#ifdef CreateMutex
#undef CreateMutex
#endif

#ifdef min
#undef min
#endif

#ifdef max
#undef max
#endif

// If specific Windows types or functions are needed, they should be
// explicitly declared here with proper C++ naming conventions

#endif // _WIN32
```

`src/w1common/windows_console.hpp`:

```hpp
#pragma once

#if defined(_WIN32) || defined(WIN32)

#include <windows.h>
#include <io.h>
#include <fcntl.h>
#include <cstdio>

namespace w1::common {

/**
 * @brief allocate and configure a windows console for gui applications
 *
 * this function:
 * - allocates a new console window
 * - redirects stdout/stderr to the console
 * - enables ansi escape code support for colors
 * - sets streams to unbuffered for immediate output
 *
 * @return true if console was successfully allocated and configured
 */
inline bool allocate_windows_console() {
  if (!AllocConsole()) {
    return false;
  }

  // redirect stdout and stderr to console
  FILE* pCout;
  FILE* pCerr;
  freopen_s(&pCout, "CONOUT$", "w", stdout);
  freopen_s(&pCerr, "CONOUT$", "w", stderr);

  // ensure streams are unbuffered for immediate output
  setvbuf(stdout, NULL, _IONBF, 0);
  setvbuf(stderr, NULL, _IONBF, 0);

  // enable ansi escape codes for color output
  HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
  HANDLE hErr = GetStdHandle(STD_ERROR_HANDLE);

  if (hOut != INVALID_HANDLE_VALUE) {
    DWORD dwMode = 0;
    if (GetConsoleMode(hOut, &dwMode)) {
      dwMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
      SetConsoleMode(hOut, dwMode);
    }
  }

  if (hErr != INVALID_HANDLE_VALUE) {
    DWORD dwMode = 0;
    if (GetConsoleMode(hErr, &dwMode)) {
      dwMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
      SetConsoleMode(hErr, dwMode);
    }
  }

  return true;
}

} // namespace w1::common

#endif // _WIN32 || WIN32
```

`src/w1nj3ct/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${WITNESS_SOURCE_DIR}/cmake/CommonConfig.cmake)

# platform-specific source files
set(COMMON_SOURCES w1nj3ct.cpp error.cpp)
set(PLATFORM_SOURCES "")

if(CMAKE_SYSTEM_NAME STREQUAL "Darwin")
    list(APPEND PLATFORM_SOURCES
        platform/darwin/darwin_injector.cpp
        backend/darwin/injector.c backend/darwin/mach.c backend/darwin/ptrace.c
        backend/darwin/remote_call.c backend/darwin/util.c backend/darwin/exc_handler.c
        backend/darwin/mach_excServer.c
    )
elseif(CMAKE_SYSTEM_NAME STREQUAL "Linux")
    list(APPEND PLATFORM_SOURCES
        platform/linux/linux_injector.cpp
        backend/linux/injector.c backend/linux/elf.c backend/linux/ptrace.c
        backend/linux/remote_call.c backend/linux/util.c backend/linux/shellcode.S
    )
elseif(CMAKE_SYSTEM_NAME STREQUAL "Windows")
    list(APPEND PLATFORM_SOURCES
        platform/windows/windows_injector.cpp platform/windows/error_windows.cpp
        backend/windows/inject_createremotethread.cpp backend/windows/inject_setwindowshook.cpp
        backend/windows/inject_rtlcreateuserthread.cpp backend/windows/inject_reflective.cpp
        backend/windows/inject_launch.cpp backend/windows/auxiliary.cpp
    )
endif()

add_library(w1nj3ct STATIC ${COMMON_SOURCES} ${PLATFORM_SOURCES})

target_include_directories(w1nj3ct
    PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}> $<INSTALL_INTERFACE:include>
    PRIVATE ${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_CURRENT_SOURCE_DIR}/backend
            ${WITNESS_SOURCE_DIR}/src
)

target_link_libraries(w1nj3ct PUBLIC common redlog::redlog)

# platform-specific libraries
if(WIN32)
    target_link_libraries(w1nj3ct PRIVATE psapi kernel32 user32 advapi32 ntdll)
elseif(UNIX AND NOT APPLE)
    target_link_libraries(w1nj3ct PRIVATE dl pthread)
endif()

apply_common_compile_options(w1nj3ct)
apply_windows_definitions(w1nj3ct)
set_standard_output_dirs(w1nj3ct)

install(TARGETS w1nj3ct
    EXPORT w1nj3ctTargets
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
    RUNTIME DESTINATION bin
)

install(FILES w1nj3ct.hpp error.hpp DESTINATION include/w1nj3ct)
```

`src/w1nj3ct/backend/darwin/exc_handler.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2022 TheOiseth
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include "injector_internal.h"
#include <mach/exception_types.h>
#include <sys/types.h>
#include <sys/ptrace.h>
#include <signal.h>
#include <stdbool.h>
#define HANDLE_EXC EXC_MASK_BAD_ACCESS | EXC_MASK_BAD_INSTRUCTION | EXC_MASK_SOFTWARE | EXC_MASK_BREAKPOINT | EXC_MASK_CRASH | EXC_MASK_CORPSE_NOTIFY
boolean_t mach_exc_server(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);
int injector__create_exc_handler(injector_t *injector) {
	mach_port_name_t 		exc_port = 0;
	mach_msg_type_number_t	exception_types_count;
	int rv;
	injector->exc_port = 0;
	injector->saved_exception_types_count = 0;
	rv = task_get_exception_ports(injector->remote_task,
                        EXC_MASK_ALL,
                        injector->saved_masks,
                        &exception_types_count,
                        injector->saved_ports,
                        injector->saved_behaviors,
                        injector->saved_flavors);
						
	injector->saved_exception_types_count = exception_types_count;
	if(rv != 0){
		injector__set_errmsg("%s error : %s", "EXC_GET_PORTS", mach_error_string(rv));
		return INJERR_OTHER;
	}
 
	rv = mach_port_allocate(mach_task_self(),
                   MACH_PORT_RIGHT_RECEIVE,
                   &exc_port);
 	injector->exc_port = exc_port;	
 	if(rv != 0){
		injector__set_errmsg("%s error : %s", "EXC_PORT_ALLOCATE", mach_error_string(rv));
		rv = INJERR_OTHER;
		goto cleanup;
	}
	rv = mach_port_insert_right(mach_task_self(),
                       exc_port,
						exc_port,
                       MACH_MSG_TYPE_MAKE_SEND);
	if(rv != 0){
		injector__set_errmsg("%s error : %s", "EXC_INSERT_RIGHTS", mach_error_string(rv));
		rv = INJERR_OTHER;
		goto cleanup;
	}
	
	rv = task_set_exception_ports(injector->remote_task,
                         HANDLE_EXC,
                         exc_port,
                         EXCEPTION_DEFAULT | MACH_EXCEPTION_CODES,
                         THREAD_STATE_NONE);
	if(rv != 0){
		injector__set_errmsg("%s error : %s", "EXC_SET_PORTS", mach_error_string(rv));
		rv = INJERR_OTHER;
		goto cleanup;
	}

	return 0;
cleanup:
	injector__release_exc_handler(injector);
return rv;	
}
int injector__handle_exc(injector_t *injector) {
	char req[128], rpl[128];
	mach_msg_header_with_injector *mmhwi;
	int rv;

	mmhwi = (mach_msg_header_with_injector*)req;
	mmhwi->injector = injector;
	rv = mach_msg((mach_msg_header_t *)req, MACH_RCV_MSG, 0, sizeof(req), injector->exc_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL); 
	if (rv != KERN_SUCCESS) {
		injector__set_errmsg("%s error : %s", "EXC_RECV_MACH_MSG", mach_error_string(rv));
		return INJERR_OTHER;
	}
/* suspend all threads in the process after an exception was received */
 
	task_suspend(injector->remote_task);

	boolean_t message_parsed_correctly = mach_exc_server((mach_msg_header_t *)req, (mach_msg_header_t *)rpl);
	if (! message_parsed_correctly) {
		 
		size_t parse_exc = ((mig_reply_error_t *)rpl)->RetCode;
		if(parse_exc != 0 ){
			injector__set_errmsg("%s error : %s", "mach_exc_server", mach_error_string(parse_exc));
		}
	}
	task_resume(injector->remote_task);
	mach_msg_size_t send_sz = ((mach_msg_header_t *)rpl)->msgh_size;
 
	rv = mach_msg((mach_msg_header_t *)rpl, MACH_SEND_MSG, send_sz, 0, MACH_PORT_NULL, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	if (rv != KERN_SUCCESS) {
		injector__set_errmsg("%s error : %s", "EXC_SEND_MACH_MSG", mach_error_string(rv));
		return INJERR_OTHER;
	}
	return 0;
}

__attribute__((no_sanitize("alignment")))
static bool isSIGSTOP(exception_type_t exception_type, mach_exception_data_t codes){
	return exception_type == EXC_SOFTWARE && codes[0] == EXC_SOFT_SIGNAL && codes[1] == SIGSTOP;
}

kern_return_t catch_mach_exception_raise(
    mach_port_t exception_port, 
    mach_port_t thread_port,
    mach_port_t task_port,
    exception_type_t exception_type,
    mach_exception_data_t codes,
    mach_msg_type_number_t num_codes,
	injector_t *injector)
{
	injector->handle_err = 0;	
	bool bad_exc = true;
	int rv;
	switch (injector->handle_action)
	{
		case STOP_CONTINUE:
			if(isSIGSTOP(exception_type, codes)){
				bad_exc = false;
				injector__ptrace_update(injector, thread_port);
			}
			break;
		case STOP_DETACH:
			if(isSIGSTOP(exception_type, codes)){
				bad_exc = false;
				injector__ptrace_detach(injector);
			}
			break;
		case TRAP_GETREGS:
			if(exception_type == EXC_BREAKPOINT){
				bad_exc = false;
#if defined(__arm64__) || defined(__aarch64__)
				mach_msg_type_number_t thread_state_count = ARM_THREAD_STATE64_COUNT;
				arm_thread_state64_t state;
				rv = thread_get_state(thread_port, ARM_THREAD_STATE64, (thread_state_t)&state, &thread_state_count);
				if (rv == KERN_SUCCESS) {
					injector->retval = state.__x[0];
				} else {
					injector__set_errmsg("%s error : %s", "GET_THREAD_STATE", mach_error_string(rv));
					injector->handle_err = INJERR_ERROR_IN_TARGET;
				}
#else
				mach_msg_type_number_t thread_state_count = x86_THREAD_STATE64_COUNT;
				x86_thread_state64_t state;
				rv = thread_get_state(thread_port, x86_THREAD_STATE64, (thread_state_t)&state, &thread_state_count);
				if (rv == KERN_SUCCESS) {
					injector->retval = state.__rax;
				} else {
					injector__set_errmsg("%s error : %s", "GET_THREAD_STATE", mach_error_string(rv));
					injector->handle_err = INJERR_ERROR_IN_TARGET;
				}
#endif
				if (injector->mach_thread != 0){
					rv = thread_terminate(injector->mach_thread);
					injector->mach_thread = 0;
				}
				rv = thread_suspend(thread_port);
				if(rv != KERN_SUCCESS){
					injector__set_errmsg("%s error : %s", "THREAD_SUSPEND", mach_error_string(rv));
					injector->handle_err = INJERR_ERROR_IN_TARGET;
				}
				//we don't need to continue since we already called task_resume and mach_msg later
				//rv = injector__ptrace_continue(injector);
				
			}
			break;
		case TRAP_SETREGS:
			if(exception_type == EXC_BREAKPOINT){
				bad_exc = false;
				bool thread_init = false;
				if(thread_port != injector->mach_thread){
					thread_init = injector->remote_thread == 0;
					injector->remote_thread = thread_port;
				}
#if defined(__arm64__) || defined(__aarch64__)
				mach_msg_type_number_t thread_state_count = ARM_THREAD_STATE64_COUNT;
				arm_thread_state64_t state;
				rv = thread_get_state(thread_port, ARM_THREAD_STATE64, (thread_state_t)&state, &thread_state_count);
				if (rv != KERN_SUCCESS) {
					injector__set_errmsg("%s error : %s", "GET_THREAD_STATE", mach_error_string(rv));
					injector->handle_err = INJERR_ERROR_IN_TARGET;
					goto exit;
				}
				if(thread_init){
					memcpy(&injector->remote_thread_saved_state, &state, sizeof(state));
					injector->state_saved = 1;
				}
				state.__x[0] = injector->arg1;
				state.__x[1] = injector->arg2;
				state.__x[2] = injector->arg3;
				state.__x[3] = injector->arg4;
				state.__x[4] = injector->arg5;
				state.__x[5] = injector->arg6;
				state.__x[8] = injector->func_addr;
				state.__sp = injector->stack;
				state.__pc = injector->code2_addr + 4;
				rv = thread_set_state(thread_port, ARM_THREAD_STATE64, (thread_state_t)&state, ARM_THREAD_STATE64_COUNT);
				if (rv != KERN_SUCCESS) {
					injector__set_errmsg("%s error : %s", "SET_THREAD_STATE", mach_error_string(rv));
					injector->handle_err = INJERR_ERROR_IN_TARGET;
				}
#else			
				mach_msg_type_number_t thread_state_count = x86_THREAD_STATE64_COUNT;
				x86_thread_state64_t state;

				rv = thread_get_state(thread_port, x86_THREAD_STATE64, (thread_state_t)&state, &thread_state_count);
				if (rv != KERN_SUCCESS) {
					injector__set_errmsg("%s error : %s", "GET_THREAD_STATE", mach_error_string(rv));
					injector->handle_err = INJERR_ERROR_IN_TARGET;
					goto exit;
				}
				if(thread_init){
					memcpy(&injector->remote_thread_saved_state, &state, sizeof(state));
					injector->state_saved = 1;
				}
				state.__rax = injector->func_addr;
				state.__rdi = injector->arg1;
				state.__rsi = injector->arg2;
				state.__rdx = injector->arg3;
				state.__rcx = injector->arg4;
				state.__r8 = injector->arg5;
				state.__r9 = injector->arg6;
				state.__rsp = injector->stack;
				state.__rbp = injector->stack;	
				rv = thread_set_state(thread_port, x86_THREAD_STATE64, (thread_state_t)&state, x86_THREAD_STATE64_COUNT);
				if (rv != KERN_SUCCESS) {
					injector__set_errmsg("%s error : %s", "SET_THREAD_STATE", mach_error_string(rv));
					injector->handle_err = INJERR_ERROR_IN_TARGET;
				}
#endif
				//we don't need to continue since we already called task_resume and mach_msg later
				//rv = injector__ptrace_continue(injector);

			}
			break;
	}

	if(bad_exc){
		if(exception_type == EXC_SOFTWARE){
			injector__set_errmsg("The target process got an unexpected signal %i.", codes[1]);			
		} else {
			injector__set_errmsg("Got unhandled exception %i.", exception_type);
		}	
		injector->handle_err = INJERR_OTHER;
	}
exit:
    return KERN_SUCCESS;
}
 
kern_return_t catch_mach_exception_raise_state(
    mach_port_t exception_port, 
    exception_type_t exception,
    const mach_exception_data_t code, 
    mach_msg_type_number_t codeCnt,
    int *flavor, 
    const thread_state_t old_state,
    mach_msg_type_number_t old_stateCnt, 
    thread_state_t new_state,
    mach_msg_type_number_t *new_stateCnt)
{
    return MACH_RCV_INVALID_TYPE;
}
 
kern_return_t catch_mach_exception_raise_state_identity(
    mach_port_t exception_port, 
    mach_port_t thread, 
    mach_port_t task,
    exception_type_t exception, 
    mach_exception_data_t code,
    mach_msg_type_number_t codeCnt, 
    int *flavor, 
    thread_state_t old_state,
    mach_msg_type_number_t old_stateCnt, 
    thread_state_t new_state,
    mach_msg_type_number_t *new_stateCnt)
{
    return MACH_RCV_INVALID_TYPE;
}

int injector__release_exc_handler(injector_t *injector) {
	for (int i = 0; i < injector->saved_exception_types_count; i++) {
		task_set_exception_ports(injector->remote_task, injector->saved_masks[i], injector->saved_ports[i], injector->saved_behaviors[i], injector->saved_flavors[i]);
	}	
	injector->saved_exception_types_count = 0;
	if (injector->exc_port != 0){
		mach_port_deallocate(mach_task_self(), injector->exc_port);
		injector->exc_port = 0;
	}
	return 0;
}
```

`src/w1nj3ct/backend/darwin/injector.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2022 TheOiseth
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include "injector_internal.h"
#include <stdlib.h>
#include <unistd.h>
#include <dlfcn.h>
#include <sys/syslimits.h>
#include <signal.h>

#define STACK_SIZE 2 * 1024 * 1024
#define CODE_SIZE 512
int injector_attach(injector_t **injector_out, pid_t pid)
{
    injector_t *injector;
    arch_t self_arch, target_arch;
    int rv = 0;

    injector__errmsg_is_set = 0;

    injector = calloc(1, sizeof(injector_t));
    if (injector == NULL) {
        injector__set_errmsg("malloc error: %s", strerror(errno));
        return INJERR_NO_MEMORY;
    }
    injector->pid = pid;
	rv = injector__get_process_arch(getpid(), &self_arch);
	if (rv != 0) {
	    goto error_exit;
	}
	rv = injector__get_process_arch(pid, &target_arch);
	if (rv != 0) {
	    goto error_exit;
	}
	arch_t sys_arch = injector__get_system_arch();

	if(self_arch != ARCH_UNKNOWN && target_arch != ARCH_UNKNOWN){
		if(self_arch != target_arch){
			injector__set_errmsg("%s target process isn't supported by %s process.", injector__arch2name(target_arch), injector__arch2name(self_arch));
			rv = INJERR_UNSUPPORTED_TARGET;
			goto error_exit;
		}
		if(sys_arch == ARCH_ARM64 && self_arch != ARCH_ARM64){
			injector__set_errmsg("%s target process isn't supported by %s process on ARM64 machine.", injector__arch2name(target_arch), injector__arch2name(self_arch));
			rv = INJERR_UNSUPPORTED_TARGET;
			goto error_exit;
		}
	}

	rv = injector__task_pid(injector);
	if (rv != 0) {
		goto error_exit;
    }
	injector->attached = 1;

	rv = injector__create_exc_handler(injector);
	
	if (rv != 0) {
		goto error_exit;
    }
	rv = injector__ptrace_attach(injector);
	if(rv != 0){
		return rv;
	}
	injector->handle_action = STOP_CONTINUE;
	injector->handle_err = 0;
	do{
		injector__handle_exc(injector);
	} while(injector->handle_err != 0);
	
	injector->ptrace_attached = 1;
		
	injector->text_size = sysconf(_SC_PAGESIZE);
	injector->stack_size = STACK_SIZE;
	injector->code_size = CODE_SIZE;
	
	size_t alloc_size = injector->text_size + injector->stack_size;
	
	mach_vm_address_t addr = (vm_address_t)NULL;
	rv = injector__allocate(injector, &addr, alloc_size, VM_FLAGS_ANYWHERE);
	if (rv != 0) {
		goto error_exit;
    }
	
	mach_vm_address_t code_addr = (vm_address_t)NULL;
	rv = injector__allocate(injector, &code_addr, CODE_SIZE, VM_FLAGS_ANYWHERE);
	if (rv != 0) {
		goto error_exit;
    }
	
	injector->allocated = 1;
    injector->text = (size_t)addr;
	injector->stack = injector->text + injector->text_size + injector->stack_size / 2;	
	injector->stack &= 0xFFFFFFFFFFFFFFF0; //alignment
	injector->code_addr = (size_t)code_addr;
	
	rv = injector__protect(injector, addr, alloc_size, FALSE, VM_PROT_READ | VM_PROT_WRITE);
	if (rv != 0) {
		goto error_exit;
    }
	
	rv = injector__protect(injector, code_addr, CODE_SIZE, FALSE, VM_PROT_READ | VM_PROT_WRITE);
	if (rv != 0) {
		goto error_exit;
    }
	*injector_out = injector;
	return 0;
error_exit:
    injector_detach(injector);
    return rv;
}

int injector_inject(injector_t *injector, const char *path, void **handle)
{
    char abspath[PATH_MAX];
    int dlflags = RTLD_LAZY;
    size_t len;
    int rv;
	long retval;
	injector__errmsg_is_set = 0;
	if (realpath(path, abspath) == NULL) {
        injector__set_errmsg("failed to get the full path of '%s': %s",
                           path, strerror(errno));
        return INJERR_FILE_NOT_FOUND;
    }
	len = strlen(abspath) + 1;
	 if (len > injector->text_size) {
        injector__set_errmsg("too long file path: %s", path);
        return INJERR_FILE_NOT_FOUND;
    }

    rv = injector__write(injector, injector->text, abspath, len);
    if (rv != 0) {
        return rv;
    }
	
	rv = injector__call_function(injector, &retval, (long)dlopen, injector->text, dlflags);
    if (rv != 0) {
        return rv;
    }
	if (retval == 0) {
        char buf[256 + 1] = {0,};
        rv = injector__call_function(injector, &retval, (long)dlerror);
        if (rv == 0 && retval != 0) {
            injector__read(injector, retval, buf, sizeof(buf) - 1);
        }
		
        if (buf[0] != '\0') {
            injector__set_errmsg("dlopen failed: %s", buf);
        } else {
            injector__set_errmsg("dlopen failed");
        }

        return INJERR_ERROR_IN_TARGET;
    }
	if (handle != NULL) {
        *handle = (void*)retval;
    }
	return 0;
}

int injector_call(injector_t *injector, void *handle, const char* name)
{
    int rv;
    long retval;
    size_t len = strlen(name) + 1;

    injector__errmsg_is_set = 0;

    if (len > injector->text_size) {
        injector__set_errmsg("too long function name: %s", name);
        return INJERR_FUNCTION_MISSING;
    }
    rv = injector__write(injector, injector->text, name, len);
    if (rv != 0) {
        return rv;
    }
    rv = injector__call_function(injector, &retval, (long)dlsym, handle, injector->text);
    if (retval == 0) {
        injector__set_errmsg("function not found: %s", name);
        return INJERR_FUNCTION_MISSING;
    }
    return injector__call_function(injector, &retval, retval);
}

int injector_uninject(injector_t *injector, void *handle)
{
    int rv;
    long retval;

    injector__errmsg_is_set = 0;

    rv = injector__call_function(injector, &retval, (long)dlclose, handle);
    if (rv != 0) {
        return rv;
    }
    if (retval != 0) {
        injector__set_errmsg("dlclose failed");
        return INJERR_ERROR_IN_TARGET;
    }
    return 0;
}

int injector_detach(injector_t *injector)
{
	int rv = 0;
    injector__errmsg_is_set = 0;
	if (injector->remote_thread != 0) {
		//For some reasons on MacOS ARM64 (tested on 12.0.1) thread_terminate() returns unknown error, so let it end by itslef
		if(injector->state_saved){
#if defined(__arm64__) || defined(__aarch64__)
			injector->remote_thread_saved_state.__pc = injector->code2_addr + 12;
			rv = thread_set_state(injector->remote_thread, ARM_THREAD_STATE64, (thread_state_t)&injector->remote_thread_saved_state, ARM_THREAD_STATE64_COUNT);
			if (rv != KERN_SUCCESS) {
				injector__set_errmsg("%s error : %s", "GET_THREAD_STATE", mach_error_string(rv));
				rv = INJERR_ERROR_IN_TARGET;
			}
#else
			injector->remote_thread_saved_state.__rip = injector->code2_addr + 4;
			rv = thread_set_state(injector->remote_thread, x86_THREAD_STATE64, (thread_state_t)&injector->remote_thread_saved_state, x86_THREAD_STATE64_COUNT);
			if (rv != KERN_SUCCESS) {
				injector__set_errmsg("%s error : %s", "GET_THREAD_STATE", mach_error_string(rv));
				rv = INJERR_ERROR_IN_TARGET;
			}
#endif
			rv = thread_resume(injector->remote_thread);
			if(rv != 0){
				injector__set_errmsg("Remote thread resume error: %s\n", mach_error_string(rv));
				rv = INJERR_ERROR_IN_TARGET;
			}
			
			//wait thread for end
#if defined(__arm64__) || defined(__aarch64__)
			thread_state_flavor_t flavor = ARM_THREAD_STATE64;
#else
			thread_state_flavor_t flavor = x86_THREAD_STATE64;
#endif
			mach_msg_type_number_t state_count;
			int counter = 0;
			while(thread_get_state(injector->remote_thread, flavor, (thread_state_t)&injector->remote_thread_saved_state, &state_count) == 0){
				counter++;
				usleep(10);
				if(counter > 1000){
					break;
				}
			}
		}	
	}
	
	if (injector->ptrace_attached) {
		injector->handle_action = STOP_DETACH;
		kill(injector->pid, SIGSTOP);		
		injector->handle_err = 0;
		do{
			injector__handle_exc(injector);
		} while(injector->handle_err != 0);
		injector__release_exc_handler(injector);
	}
	
    if (injector->allocated) {
		injector__deallocate(injector, injector->text, injector->text_size + injector->stack_size);
		injector__deallocate(injector, injector->code_addr, injector->code_size);
    }
    if (injector->attached) {
		mach_port_deallocate(mach_task_self(), injector->remote_task);
    }

    free(injector);
    return rv;
}
const char *injector_error(void)
{
    return injector__errmsg;
}
```

`src/w1nj3ct/backend/darwin/injector.h`:

```h
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2018-2023 Kubo Takehiro <kubo@jiubao.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

/*!
 * \file injector.h
 * \brief Library for injecting a shared library into a Linux, Windows and macOS process
 */
#ifndef INJECTOR_H
#define INJECTOR_H

#if defined(_WIN32)
#include <windows.h>
typedef DWORD injector_pid_t;
#else
#include <sys/types.h>

/*!
 * \brief Platform-dependent process id type (\c pid_t on Unix. \c DWORD on Windows)
 */
typedef pid_t injector_pid_t;
#endif

#ifdef __cplusplus
extern "C" {
#endif
#if 0
}
#endif

#define INJERR_SUCCESS 0               /* linux, windows, macos */
#define INJERR_OTHER -1                /* linux, windows, macos */
#define INJERR_NO_MEMORY -2            /* linux, windows, macos */
#define INJERR_NO_PROCESS -3           /* linux, windows, macos */
#define INJERR_NO_LIBRARY -4           /* linux */
#define INJERR_NO_FUNCTION -4          /* linux */
#define INJERR_ERROR_IN_TARGET -5      /* linux, windows, macos */
#define INJERR_FILE_NOT_FOUND -6       /* linux, windows, macos */
#define INJERR_INVALID_MEMORY_AREA -7  /* linux, macos */
#define INJERR_PERMISSION -8           /* linux, windows, macos */
#define INJERR_UNSUPPORTED_TARGET -9   /* linux, windows, macos */
#define INJERR_INVALID_ELF_FORMAT -10  /* linux */
#define INJERR_WAIT_TRACEE -11         /* linux */
#define INJERR_FUNCTION_MISSING -12    /* linux, windows, macos */

typedef struct injector injector_t;

/*!
 * \brief Attach to the specified process.
 * \param[out]  injector the address where the newly created injector handle will be stored
 * \param[in]   pid      the process id to be attached
 * \return               zero on success. Otherwise, error code
 */
int injector_attach(injector_t **injector, injector_pid_t pid);

/*!
 * \brief Detach from the attached process and destroy the specified handle.
 * \param[in]   injector the injector handle to destroy
 * \return               zero on success. Otherwise, error code
 */
int injector_detach(injector_t *injector);

/*!
 * \brief Inject the specified shared library into the target process.
 * \param[in]   injector the injector handle specifying the target process
 * \param[in]   path     the path name of the shared library
 * \param[out]  handle   the address where the newly created module handle will be stored
 * \return               zero on success. Otherwise, error code
 *
 * Note on Linux:
 * This calls functions inside of the target process interrupted by \c ptrace().
 * If the target process is interrupted while holding a non-reentrant lock and
 * injector calls a function requiring the same lock, the process stops forever.
 * If the lock type is reentrant, the status guarded by the lock may become inconsistent.
 * As far as I checked, \c dlopen() internally calls \c malloc() requiring non-reentrant
 * locks. \c dlopen() also uses a reentrant lock to guard information about loaded files.
 */
int injector_inject(injector_t *injector, const char *path, void **handle);

/*!
 * \brief Uninject the shared library specified by \c handle.
 * \param[in]   injector the injector handle specifying the target process
 * \param[in]   handle   the module handle created by \c injector_inject
 * \return               zero on success. Otherwise, error code
 * \remarks This fearute isn't supported for musl-libc processes.
 *     See [Functional differences from glibc](https://wiki.musl-libc.org/functional-differences-from-glibc.html#Unloading_libraries).
 */
int injector_uninject(injector_t *injector, void *handle);

#if defined(INJECTOR_DOC) || defined(__linux__) || defined(__APPLE__)
/*!
 * \brief Call the specified function taking no arguments in the target process (Linux and macOS only)
 * \param[in]   injector the injector handle specifying the target process
 * \param[in]   handle   the module handle created by \c injector_inject or special-handles such as \c RTLD_DEFAULT
 * \param[in]   name     the function name
 *
 * The \c handle and \c name arguments are passed to \c dlsym ([Linux](https://man7.org/linux/man-pages/man3/dlvsym.3.html), [macOS](https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dlsym.3.html)) and then the return value of \c dlsym is called without arguments in the target process.
 *
 * This is same with the combination of injector_remote_func_addr() and injector_remote_call() without extra arguments.
 *
 * \note
 *   (Linux only)
 *   If the function in the target process internally calls non-[async-signal-safe]((https://man7.org/linux/man-pages/man7/signal-safety.7.html))
 *   functions, it may stop the target process or cause unexpected behaviour.
 * \sa injector_remote_func_addr(), injector_remote_call(), injector_remote_vcall()
 */
int injector_call(injector_t *injector, void *handle, const char* name);
#endif

/*!
 * \brief Get the message of the last error.
 * \remarks The message is updated only when \c injector functions return non-zero.
 */
const char *injector_error(void);

#if defined(INJECTOR_DOC) || defined(__linux__) || defined(_WIN32)
#define INJECTOR_HAS_REMOTE_CALL_FUNCS 1
#include <stdarg.h>
#include <stdint.h>

/*!
 * \brief Get the function address in the target process (Linux and Windows only)
 * \param[in]   injector      the injector handle specifying the target process
 * \param[in]   handle        the module handle created by \c injector_inject or special-handles such as \c RTLD_DEFAULT
 * \param[in]   name          the function name
 * \param[out]  func_addr_out the address where the function address in the target process will be stored
 * \return                    zero on success. Otherwise, error code
 *
 * \b Example
 *
 * Inject libfoo.so and then call foo_func(1, 2, 3) in it.
 * \code
 * void *handle;
 * // inject libfoo.so and get the handle
 * if (injector_inject(injector, "libfoo.so", &handle) != 0) {
 *    return;
 * }
 * size_t func_addr;
 * // get the address of foo_func in the handle
 * if (injector_remote_func_addr(injector, handle, "foo_func", &func_addr) != 0) {
 *    return;
 * }
 * intptr_t retval;
 * // call foo_func
 * if (injector_remote_call(injector, &retval, func_addr, 1, 2, 3) != 0) {
 *    return;
 * }
 * printf("The return value of foo_func(1, 2, 3) is %ld.\n", retval);
 * \endcode
 */
int injector_remote_func_addr(injector_t *injector, void *handle, const char* name, size_t *func_addr_out);

/*!
 * \brief Call the function in the target process (Linux and Windows only)
 * \param[in]   injector  the injector handle specifying the target process
 * \param[out]  retval    \c NULL or the address where the return value of the function call will be stored
 * \param[in]   func_addr the function address in the target process
 * \param[in]   ...       arguments passed to the function
 * \return                zero on success. Otherwise, error code
 * \remarks
 *   The types of the arguments must be integer or pointer.
 *   If it is a pointer, it must point to a valid address in the target process.
 *   The number of arguments must be less than or equal to six.
 * \note
 *   If the function in the target process internally calls non-[async-signal-safe]((https://man7.org/linux/man-pages/man7/signal-safety.7.html))
 *   functions, it may stop the target process or cause unexpected behaviour.
 * \sa injector_remote_func_addr(), injector_remote_vcall()
 */
int injector_remote_call(injector_t *injector, intptr_t *retval, size_t func_addr, ...);

/*!
 * \brief Call the function in the target process (Linux and Windows only)
 * \param[in]   injector  the injector handle specifying the target process
 * \param[out]  retval    \c NULL or the address where the return value of the function call will be stored
 * \param[in]   func_addr the function address in the target process
 * \param[in]   ap        arguments passed to the function
 * \return                zero on success. Otherwise, error code
 * \remarks
 *   The types of the arguments must be integer or pointer.
 *   If it is a pointer, it must point to a valid address in the target process.
 *   The number of arguments must be less than or equal to six.
 * \note
 *   If the function in the target process internally calls non-[async-signal-safe]((https://man7.org/linux/man-pages/man7/signal-safety.7.html))
 *   functions, it may stop the target process or cause unexpected behaviour.
 * \sa injector_remote_func_addr(), injector_remote_call()
 */
int injector_remote_vcall(injector_t *injector, intptr_t *retval, size_t func_addr, va_list ap);
#endif

#if defined(INJECTOR_DOC) || defined(_WIN32)
/*!
 * \brief Same with \c injector_inject except the type of the \c path argument. (Windows only)
 * \param[in]   injector the injector handle specifying the target process
 * \param[in]   path     the path name of the shared library
 * \param[out]  handle   the address where the newly created module handle will be stored
 * \return               zero on success. Otherwise, error code
 */
int injector_inject_w(injector_t *injector, const wchar_t *path, void **handle);
#endif

#if defined(INJECTOR_DOC) || (defined(__linux__) && defined(__x86_64__))
#define INJECTOR_HAS_INJECT_IN_CLONED_THREAD 1 // feature test macro
/*!
 * \brief Inject the specified shared library into the target process by the \c clone system call. (Linux x86_64 only)
 * \param[in]   injector the injector handle specifying the target process
 * \param[in]   path     the path name of the shared library
 * \param[out]  handle   the address where the newly created module handle will be stored
 * \return               zero on success. Otherwise, error code
 *
 * This calls `dlopen()` in a thread created by \c [clone()](https://man7.org/linux/man-pages/man2/clone.2.html). Note that no wonder there are unexpected
 * pitfalls because some resources allocated in \c [pthread_create()](https://man7.org/linux/man-pages/man3/pthread_create.3.html) lack in the \c clone()-ed thread.
 * Use it at your own risk.
 */
int injector_inject_in_cloned_thread(injector_t *injector, const char *path, void **handle);
#endif

#if 0
{
#endif
#ifdef __cplusplus
}; /* extern "C" */
#endif

#endif

```

`src/w1nj3ct/backend/darwin/injector_internal.h`:

```h
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2022 TheOiseth
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include "injector.h"
#include <stdint.h>
#include <stdbool.h>
#include <mach/mach_vm.h>
#include <mach/mach.h>
#include <errno.h>

typedef enum {
    STOP_CONTINUE,
	STOP_DETACH,
    TRAP_SETREGS,  
    TRAP_GETREGS
} handle_action_t;

struct injector {
    pid_t pid;
	uint8_t attached;
	uint8_t allocated;
	uint8_t ptrace_attached;
	uint8_t shellcode_writed;
	task_t remote_task;
    size_t code_addr;
	size_t code2_addr;
	size_t code_size;
    size_t text;
    size_t text_size;
    size_t stack;
    size_t stack_size;
	
	thread_act_t mach_thread;
	thread_act_t remote_thread;
#if defined(__arm64__) || defined(__aarch64__)
	arm_thread_state64_t remote_thread_saved_state;
#else
	x86_thread_state64_t remote_thread_saved_state;
#endif
	uint8_t state_saved;
	long func_addr;
	long arg1;
	long arg2;
	long arg3;
	long arg4;
	long arg5;
	long arg6;
	mach_port_name_t 		exc_port;
	exception_mask_t		saved_masks[EXC_TYPES_COUNT];
	mach_port_t				saved_ports[EXC_TYPES_COUNT];
	exception_behavior_t	saved_behaviors[EXC_TYPES_COUNT];
	thread_state_flavor_t	saved_flavors[EXC_TYPES_COUNT];
	mach_msg_type_number_t	saved_exception_types_count;
	handle_action_t handle_action;
	long retval;
	int handle_err;
	
};

typedef struct{
	char stub[120];
	injector_t *injector;
} mach_msg_header_with_injector;

typedef enum {
    ARCH_X86_64,
    ARCH_I386,
    ARCH_ARM64,  
    ARCH_POWERPC_64,
    ARCH_POWERPC,
	ARCH_UNKNOWN
} arch_t;



typedef int (*pcfmt_t)(pthread_t* ,pthread_attr_t* ,void *, void*);

int injector__task_pid(injector_t *injector);
int injector__allocate(const injector_t *injector, mach_vm_address_t *address, mach_vm_size_t size, int flags);
int injector__deallocate(const injector_t *injector, mach_vm_address_t address, mach_vm_size_t size);
int injector__protect(const injector_t *injector, mach_vm_address_t address, mach_vm_size_t size, boolean_t set_maximum, vm_prot_t new_protection);
int injector__write(const injector_t *injector, size_t addr, const void *buf, size_t len);
int injector__read(const injector_t *injector, size_t addr, void *buf, size_t len);
int injector__ptrace_attach(const injector_t *injector);
int injector__ptrace_detach(const injector_t *injector);
int injector__ptrace_continue(const injector_t *injector);
int injector__ptrace_update(const injector_t *injector, long thread_port);

int injector__create_exc_handler(injector_t *injector);
int injector__release_exc_handler(injector_t *injector);
int injector__handle_exc(injector_t *injector);

int injector__call_function(injector_t *injector, long *retval, long function_addr, ...);
/* util.c */
extern char injector__errmsg[];
extern char injector__errmsg_is_set;
void injector__set_errmsg(const char *format, ...);
const char *injector__arch2name(arch_t arch);
int injector__get_process_arch(pid_t pid, arch_t *arch);
arch_t injector__get_system_arch();
```

`src/w1nj3ct/backend/darwin/mach.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2022 TheOiseth
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include "injector_internal.h"
#include <libproc.h>
#include <signal.h>
static int set_mach_error(const char *request_name, int err)
{
    injector__set_errmsg("%s error : %s", request_name, mach_error_string(err));
    switch (err) {
    case KERN_INVALID_ADDRESS:
        return INJERR_INVALID_MEMORY_AREA;
    case KERN_NO_ACCESS:
        return INJERR_PERMISSION;
    }
    return INJERR_OTHER;
}

static int set_error(const char *request_name)
{
    int err = errno;
    injector__set_errmsg("%s error : %s", request_name, strerror(errno));
    switch (err) {
    case EFAULT:
        return INJERR_INVALID_MEMORY_AREA;
    case EPERM:
        return INJERR_PERMISSION;
    case ESRCH:
        return INJERR_NO_PROCESS;
    }
    return INJERR_OTHER;
}

int injector__task_pid(injector_t *injector)
{
	int rv = kill(injector->pid, 0);
	if(rv != 0){
		return set_error("TASK_FOR_PID");
	}
	task_t remote_task;
    rv = task_for_pid(mach_task_self(), injector->pid, &remote_task);
	
	if (rv != KERN_SUCCESS) {
		return set_mach_error("TASK_FOR_PID", rv);
	}
	injector->remote_task = remote_task;
    return 0;
}

int injector__allocate(const injector_t *injector, mach_vm_address_t *address, mach_vm_size_t size, int flags)
{
	int rv = mach_vm_allocate(injector->remote_task, address, size, flags);
    if (rv != KERN_SUCCESS) {
        return set_mach_error("ALLOCATE", rv);
    }
	return 0;
}

int injector__deallocate(const injector_t *injector, mach_vm_address_t address, mach_vm_size_t size){
	int rv = mach_vm_deallocate(injector->remote_task, address, size);
    if (rv != KERN_SUCCESS) {
        return set_mach_error("DEALLOCATE", rv);
    }
	return 0;
}

int injector__protect(const injector_t *injector, mach_vm_address_t address, mach_vm_size_t size, boolean_t set_maximum, vm_prot_t new_protection)
{
	int rv = mach_vm_protect(injector->remote_task, address, size, set_maximum, new_protection);
    if (rv != KERN_SUCCESS) {
        return set_mach_error("PROTECT", rv);
    }
	return 0;
}

int injector__write(const injector_t *injector, size_t addr, const void *buf, size_t len) {
	int rv = mach_vm_write(injector->remote_task, addr, (vm_offset_t)buf, len);
	if (rv != KERN_SUCCESS) {
         return set_mach_error("WRITE", rv);
    }
	return 0;
}
int injector__read(const injector_t *injector, size_t addr, void *buf, size_t len){
	mach_vm_size_t readed;
	int rv = mach_vm_read_overwrite(injector->remote_task, addr, len, (mach_vm_address_t)buf, &readed);
	if (rv != KERN_SUCCESS) {
         return set_mach_error("READ", rv);
    }
	return 0;
}


```

`src/w1nj3ct/backend/darwin/mach_exc.h`:

```h
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * this code is generated automatically by mig
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#ifndef	_mach_exc_user_
#define	_mach_exc_user_

/* Module mach_exc */

#include <string.h>
#include <mach/ndr.h>
#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <mach/notify.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <mach/mig_errors.h>
#include <mach/port.h>
	
/* BEGIN VOUCHER CODE */

#ifndef KERNEL
#if defined(__has_include)
#if __has_include(<mach/mig_voucher_support.h>)
#ifndef USING_VOUCHERS
#define USING_VOUCHERS
#endif
#ifndef __VOUCHER_FORWARD_TYPE_DECLS__
#define __VOUCHER_FORWARD_TYPE_DECLS__
#ifdef __cplusplus
extern "C" {
#endif
	extern boolean_t voucher_mach_msg_set(mach_msg_header_t *msg) __attribute__((weak_import));
#ifdef __cplusplus
}
#endif
#endif // __VOUCHER_FORWARD_TYPE_DECLS__
#endif // __has_include(<mach/mach_voucher_types.h>)
#endif // __has_include
#endif // !KERNEL
	
/* END VOUCHER CODE */

	
/* BEGIN MIG_STRNCPY_ZEROFILL CODE */

#if defined(__has_include)
#if __has_include(<mach/mig_strncpy_zerofill_support.h>)
#ifndef USING_MIG_STRNCPY_ZEROFILL
#define USING_MIG_STRNCPY_ZEROFILL
#endif
#ifndef __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__
#define __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__
#ifdef __cplusplus
extern "C" {
#endif
	extern int mig_strncpy_zerofill(char *dest, const char *src, int len) __attribute__((weak_import));
#ifdef __cplusplus
}
#endif
#endif /* __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__ */
#endif /* __has_include(<mach/mig_strncpy_zerofill_support.h>) */
#endif /* __has_include */
	
/* END MIG_STRNCPY_ZEROFILL CODE */


#ifdef AUTOTEST
#ifndef FUNCTION_PTR_T
#define FUNCTION_PTR_T
typedef void (*function_ptr_t)(mach_port_t, char *, mach_msg_type_number_t);
typedef struct {
        char            *name;
        function_ptr_t  function;
} function_table_entry;
typedef function_table_entry   *function_table_t;
#endif /* FUNCTION_PTR_T */
#endif /* AUTOTEST */

#ifndef	mach_exc_MSG_COUNT
#define	mach_exc_MSG_COUNT	3
#endif	/* mach_exc_MSG_COUNT */

#include <mach/std_types.h>
#include <mach/mig.h>
#include <mach/mig.h>
#include <mach/mach_types.h>

#ifdef __BeforeMigUserHeader
__BeforeMigUserHeader
#endif /* __BeforeMigUserHeader */

#include <sys/cdefs.h>
__BEGIN_DECLS


/* Routine mach_exception_raise */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t mach_exception_raise
(
	mach_port_t exception_port,
	mach_port_t thread,
	mach_port_t task,
	exception_type_t exception,
	mach_exception_data_t code,
	mach_msg_type_number_t codeCnt
);

/* Routine mach_exception_raise_state */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t mach_exception_raise_state
(
	mach_port_t exception_port,
	exception_type_t exception,
	const mach_exception_data_t code,
	mach_msg_type_number_t codeCnt,
	int *flavor,
	const thread_state_t old_state,
	mach_msg_type_number_t old_stateCnt,
	thread_state_t new_state,
	mach_msg_type_number_t *new_stateCnt
);

/* Routine mach_exception_raise_state_identity */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t mach_exception_raise_state_identity
(
	mach_port_t exception_port,
	mach_port_t thread,
	mach_port_t task,
	exception_type_t exception,
	mach_exception_data_t code,
	mach_msg_type_number_t codeCnt,
	int *flavor,
	thread_state_t old_state,
	mach_msg_type_number_t old_stateCnt,
	thread_state_t new_state,
	mach_msg_type_number_t *new_stateCnt
);

__END_DECLS

/********************** Caution **************************/
/* The following data types should be used to calculate  */
/* maximum message sizes only. The actual message may be */
/* smaller, and the position of the arguments within the */
/* message layout may vary from what is presented here.  */
/* For example, if any of the arguments are variable-    */
/* sized, and less than the maximum is sent, the data    */
/* will be packed tight in the actual message to reduce  */
/* the presence of holes.                                */
/********************** Caution **************************/

/* typedefs for all requests */

#ifndef __Request__mach_exc_subsystem__defined
#define __Request__mach_exc_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t thread;
		mach_msg_port_descriptor_t task;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		exception_type_t exception;
		mach_msg_type_number_t codeCnt;
		int64_t code[2];
	} __Request__mach_exception_raise_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		exception_type_t exception;
		mach_msg_type_number_t codeCnt;
		int64_t code[2];
		int flavor;
		mach_msg_type_number_t old_stateCnt;
		natural_t old_state[614];
	} __Request__mach_exception_raise_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t thread;
		mach_msg_port_descriptor_t task;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		exception_type_t exception;
		mach_msg_type_number_t codeCnt;
		int64_t code[2];
		int flavor;
		mach_msg_type_number_t old_stateCnt;
		natural_t old_state[614];
	} __Request__mach_exception_raise_state_identity_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
#endif /* !__Request__mach_exc_subsystem__defined */

/* union of all requests */

#ifndef __RequestUnion__mach_exc_subsystem__defined
#define __RequestUnion__mach_exc_subsystem__defined
union __RequestUnion__mach_exc_subsystem {
	__Request__mach_exception_raise_t Request_mach_exception_raise;
	__Request__mach_exception_raise_state_t Request_mach_exception_raise_state;
	__Request__mach_exception_raise_state_identity_t Request_mach_exception_raise_state_identity;
};
#endif /* !__RequestUnion__mach_exc_subsystem__defined */
/* typedefs for all replies */

#ifndef __Reply__mach_exc_subsystem__defined
#define __Reply__mach_exc_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__mach_exception_raise_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		int flavor;
		mach_msg_type_number_t new_stateCnt;
		natural_t new_state[614];
	} __Reply__mach_exception_raise_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		int flavor;
		mach_msg_type_number_t new_stateCnt;
		natural_t new_state[614];
	} __Reply__mach_exception_raise_state_identity_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
#endif /* !__Reply__mach_exc_subsystem__defined */

/* union of all replies */

#ifndef __ReplyUnion__mach_exc_subsystem__defined
#define __ReplyUnion__mach_exc_subsystem__defined
union __ReplyUnion__mach_exc_subsystem {
	__Reply__mach_exception_raise_t Reply_mach_exception_raise;
	__Reply__mach_exception_raise_state_t Reply_mach_exception_raise_state;
	__Reply__mach_exception_raise_state_identity_t Reply_mach_exception_raise_state_identity;
};
#endif /* !__RequestUnion__mach_exc_subsystem__defined */

#ifndef subsystem_to_name_map_mach_exc
#define subsystem_to_name_map_mach_exc \
    { "mach_exception_raise", 2405 },\
    { "mach_exception_raise_state", 2406 },\
    { "mach_exception_raise_state_identity", 2407 }
#endif

#ifdef __AfterMigUserHeader
__AfterMigUserHeader
#endif /* __AfterMigUserHeader */

#endif	 /* _mach_exc_user_ */

```

`src/w1nj3ct/backend/darwin/mach_excServer.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * this code is generated automatically by mig
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
/*
 * IDENTIFICATION:
 * stub generated Mon Nov  7 09:48:39 2022
 * with a MiG generated by bootstrap_cmds-117
 * OPTIONS: 
 */

/* Module mach_exc */

#define	__MIG_check__Request__mach_exc_subsystem__ 1
#include <string.h>
#include <mach/ndr.h>
#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <mach/notify.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <mach/mig_errors.h>
#include <mach/port.h>
#include "injector_internal.h"
/* BEGIN VOUCHER CODE */

#ifndef KERNEL
#if defined(__has_include)
#if __has_include(<mach/mig_voucher_support.h>)
#ifndef USING_VOUCHERS
#define USING_VOUCHERS
#endif
#ifndef __VOUCHER_FORWARD_TYPE_DECLS__
#define __VOUCHER_FORWARD_TYPE_DECLS__
#ifdef __cplusplus
extern "C" {
#endif
	extern boolean_t voucher_mach_msg_set(mach_msg_header_t *msg) __attribute__((weak_import));
#ifdef __cplusplus
}
#endif
#endif // __VOUCHER_FORWARD_TYPE_DECLS__
#endif // __has_include(<mach/mach_voucher_types.h>)
#endif // __has_include
#endif // !KERNEL
	
/* END VOUCHER CODE */

	
/* BEGIN MIG_STRNCPY_ZEROFILL CODE */

#if defined(__has_include)
#if __has_include(<mach/mig_strncpy_zerofill_support.h>)
#ifndef USING_MIG_STRNCPY_ZEROFILL
#define USING_MIG_STRNCPY_ZEROFILL
#endif
#ifndef __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__
#define __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__
#ifdef __cplusplus
extern "C" {
#endif
	extern int mig_strncpy_zerofill(char *dest, const char *src, int len) __attribute__((weak_import));
#ifdef __cplusplus
}
#endif
#endif /* __MIG_STRNCPY_ZEROFILL_FORWARD_TYPE_DECLS__ */
#endif /* __has_include(<mach/mig_strncpy_zerofill_support.h>) */
#endif /* __has_include */
	
/* END MIG_STRNCPY_ZEROFILL CODE */


#include <mach/std_types.h>
#include <mach/mig.h>
#include <mach/mig.h>
#include <mach/mach_types.h>

#ifndef	mig_internal
#define	mig_internal	static __inline__
#endif	/* mig_internal */

#ifndef	mig_external
#define mig_external
#endif	/* mig_external */

#if	!defined(__MigTypeCheck) && defined(TypeCheck)
#define	__MigTypeCheck		TypeCheck	/* Legacy setting */
#endif	/* !defined(__MigTypeCheck) */

#if	!defined(__MigKernelSpecificCode) && defined(_MIG_KERNEL_SPECIFIC_CODE_)
#define	__MigKernelSpecificCode	_MIG_KERNEL_SPECIFIC_CODE_	/* Legacy setting */
#endif	/* !defined(__MigKernelSpecificCode) */

#ifndef	LimitCheck
#define	LimitCheck 0
#endif	/* LimitCheck */

#ifndef	min
#define	min(a,b)  ( ((a) < (b))? (a): (b) )
#endif	/* min */

#if !defined(_WALIGN_)
#define _WALIGN_(x) (((x) + 3) & ~3)
#endif /* !defined(_WALIGN_) */

#if !defined(_WALIGNSZ_)
#define _WALIGNSZ_(x) _WALIGN_(sizeof(x))
#endif /* !defined(_WALIGNSZ_) */

#ifndef	UseStaticTemplates
#define	UseStaticTemplates	0
#endif	/* UseStaticTemplates */

#ifndef MIG_SERVER_ROUTINE
#define MIG_SERVER_ROUTINE
#endif

#ifndef	__DeclareRcvRpc
#define	__DeclareRcvRpc(_NUM_, _NAME_)
#endif	/* __DeclareRcvRpc */

#ifndef	__BeforeRcvRpc
#define	__BeforeRcvRpc(_NUM_, _NAME_)
#endif	/* __BeforeRcvRpc */

#ifndef	__AfterRcvRpc
#define	__AfterRcvRpc(_NUM_, _NAME_)
#endif	/* __AfterRcvRpc */

#ifndef	__DeclareRcvSimple
#define	__DeclareRcvSimple(_NUM_, _NAME_)
#endif	/* __DeclareRcvSimple */

#ifndef	__BeforeRcvSimple
#define	__BeforeRcvSimple(_NUM_, _NAME_)
#endif	/* __BeforeRcvSimple */

#ifndef	__AfterRcvSimple
#define	__AfterRcvSimple(_NUM_, _NAME_)
#endif	/* __AfterRcvSimple */

#define novalue void

#define msgh_request_port	msgh_local_port
#define MACH_MSGH_BITS_REQUEST(bits)	MACH_MSGH_BITS_LOCAL(bits)
#define msgh_reply_port		msgh_remote_port
#define MACH_MSGH_BITS_REPLY(bits)	MACH_MSGH_BITS_REMOTE(bits)

#define MIG_RETURN_ERROR(X, code)	{\
				((mig_reply_error_t *)X)->RetCode = code;\
				((mig_reply_error_t *)X)->NDR = NDR_record;\
				return;\
				}

/* typedefs for all requests */

#ifndef __Request__mach_exc_subsystem__defined
#define __Request__mach_exc_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t thread;
		mach_msg_port_descriptor_t task;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		exception_type_t exception;
		mach_msg_type_number_t codeCnt;
		int64_t code[2];
	} __Request__mach_exception_raise_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		exception_type_t exception;
		mach_msg_type_number_t codeCnt;
		int64_t code[2];
		int flavor;
		mach_msg_type_number_t old_stateCnt;
		natural_t old_state[614];
	} __Request__mach_exception_raise_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t thread;
		mach_msg_port_descriptor_t task;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		exception_type_t exception;
		mach_msg_type_number_t codeCnt;
		int64_t code[2];
		int flavor;
		mach_msg_type_number_t old_stateCnt;
		natural_t old_state[614];
	} __Request__mach_exception_raise_state_identity_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
#endif /* !__Request__mach_exc_subsystem__defined */

/* typedefs for all replies */

#ifndef __Reply__mach_exc_subsystem__defined
#define __Reply__mach_exc_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__mach_exception_raise_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		int flavor;
		mach_msg_type_number_t new_stateCnt;
		natural_t new_state[614];
	} __Reply__mach_exception_raise_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		int flavor;
		mach_msg_type_number_t new_stateCnt;
		natural_t new_state[614];
	} __Reply__mach_exception_raise_state_identity_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
#endif /* !__Reply__mach_exc_subsystem__defined */


/* union of all replies */

#ifndef __ReplyUnion__catch_mach_exc_subsystem__defined
#define __ReplyUnion__catch_mach_exc_subsystem__defined
union __ReplyUnion__catch_mach_exc_subsystem {
	__Reply__mach_exception_raise_t Reply_mach_exception_raise;
	__Reply__mach_exception_raise_state_t Reply_mach_exception_raise_state;
	__Reply__mach_exception_raise_state_identity_t Reply_mach_exception_raise_state_identity;
};
#endif /* __ReplyUnion__catch_mach_exc_subsystem__defined */
/* Forward Declarations */


mig_internal novalue _Xmach_exception_raise
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _Xmach_exception_raise_state
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);

mig_internal novalue _Xmach_exception_raise_state_identity
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP);


#if ( __MigTypeCheck )
#if __MIG_check__Request__mach_exc_subsystem__
#if !defined(__MIG_check__Request__mach_exception_raise_t__defined)
#define __MIG_check__Request__mach_exception_raise_t__defined

mig_internal kern_return_t __MIG_check__Request__mach_exception_raise_t(__attribute__((__unused__)) __Request__mach_exception_raise_t *In0P)
{

	typedef __Request__mach_exception_raise_t __Request;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	msgh_size = In0P->Head.msgh_size;
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 2) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Request) - 16)) ||  (msgh_size > (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->thread.type != MACH_MSG_PORT_DESCRIPTOR ||
	    In0P->thread.disposition != 17)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->task.type != MACH_MSG_PORT_DESCRIPTOR ||
	    In0P->task.disposition != 17)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if defined(__NDR_convert__int_rep__Request__mach_exception_raise_t__codeCnt__defined)
	if (In0P->NDR.int_rep != NDR_record.int_rep)
		__NDR_convert__int_rep__Request__mach_exception_raise_t__codeCnt(&In0P->codeCnt, In0P->NDR.int_rep);
#endif	/* __NDR_convert__int_rep__Request__mach_exception_raise_t__codeCnt__defined */
#if	__MigTypeCheck
	if ( In0P->codeCnt > 2 )
		return MIG_BAD_ARGUMENTS;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Request) - 16)) / 8 < In0P->codeCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Request) - 16) + (8 * In0P->codeCnt)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__mach_exception_raise_t__defined) */
#endif /* __MIG_check__Request__mach_exc_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine mach_exception_raise */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
MIG_SERVER_ROUTINE
kern_return_t catch_mach_exception_raise
(
	mach_port_t exception_port,
	mach_port_t thread,
	mach_port_t task,
	exception_type_t exception,
	mach_exception_data_t code,
	mach_msg_type_number_t codeCnt,
	injector_t *injector
);

/* Routine mach_exception_raise */
mig_internal novalue _Xmach_exception_raise
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t thread;
		mach_msg_port_descriptor_t task;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		exception_type_t exception;
		mach_msg_type_number_t codeCnt;
		int64_t code[2];
		mach_msg_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	typedef __Request__mach_exception_raise_t __Request;
	typedef __Reply__mach_exception_raise_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */
	Request *In0P = (Request *) InHeadP;
	Reply *OutP = (Reply *) OutHeadP;
#ifdef	__MIG_check__Request__mach_exception_raise_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__mach_exception_raise_t__defined */

	__DeclareRcvRpc(2405, "mach_exception_raise")
	__BeforeRcvRpc(2405, "mach_exception_raise")

#if	defined(__MIG_check__Request__mach_exception_raise_t__defined)
	check_result = __MIG_check__Request__mach_exception_raise_t((__Request *)In0P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__mach_exception_raise_t__defined) */
	mach_msg_header_with_injector *mmhwi = (mach_msg_header_with_injector*)In0P;
	OutP->RetCode = catch_mach_exception_raise(In0P->Head.msgh_request_port, In0P->thread.name, In0P->task.name, In0P->exception, In0P->code, In0P->codeCnt, mmhwi->injector);

	OutP->NDR = NDR_record;


	__AfterRcvRpc(2405, "mach_exception_raise")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__mach_exc_subsystem__
#if !defined(__MIG_check__Request__mach_exception_raise_state_t__defined)
#define __MIG_check__Request__mach_exception_raise_state_t__defined

mig_internal kern_return_t __MIG_check__Request__mach_exception_raise_state_t(__attribute__((__unused__)) __Request__mach_exception_raise_state_t *In0P, __attribute__((__unused__)) __Request__mach_exception_raise_state_t **In1PP)
{

	typedef __Request__mach_exception_raise_state_t __Request;
	__Request *In1P;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	unsigned int msgh_size_delta;

#if	__MigTypeCheck
	msgh_size = In0P->Head.msgh_size;
	if ((In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Request) - 2472)) ||  (msgh_size > (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if defined(__NDR_convert__int_rep__Request__mach_exception_raise_state_t__codeCnt__defined)
	if (In0P->NDR.int_rep != NDR_record.int_rep)
		__NDR_convert__int_rep__Request__mach_exception_raise_state_t__codeCnt(&In0P->codeCnt, In0P->NDR.int_rep);
#endif	/* __NDR_convert__int_rep__Request__mach_exception_raise_state_t__codeCnt__defined */
	msgh_size_delta = (8 * In0P->codeCnt);
#if	__MigTypeCheck
	if ( In0P->codeCnt > 2 )
		return MIG_BAD_ARGUMENTS;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Request) - 2472)) / 8 < In0P->codeCnt) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Request) - 2472) + (8 * In0P->codeCnt)))
		return MIG_BAD_ARGUMENTS;
	msgh_size -= msgh_size_delta;
#endif	/* __MigTypeCheck */

	*In1PP = In1P = (__Request *) ((pointer_t) In0P + msgh_size_delta - 16);

#if defined(__NDR_convert__int_rep__Request__mach_exception_raise_state_t__old_stateCnt__defined)
	if (In0P->NDR.int_rep != NDR_record.int_rep)
		__NDR_convert__int_rep__Request__mach_exception_raise_state_t__old_stateCnt(&In1P->old_stateCnt, In1P->NDR.int_rep);
#endif	/* __NDR_convert__int_rep__Request__mach_exception_raise_state_t__old_stateCnt__defined */
#if	__MigTypeCheck
	if ( In1P->old_stateCnt > 614 )
		return MIG_BAD_ARGUMENTS;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Request) - 2472)) / 4 < In1P->old_stateCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Request) - 2472) + (4 * In1P->old_stateCnt)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__mach_exception_raise_state_t__defined) */
#endif /* __MIG_check__Request__mach_exc_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine mach_exception_raise_state */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
MIG_SERVER_ROUTINE
kern_return_t catch_mach_exception_raise_state
(
	mach_port_t exception_port,
	exception_type_t exception,
	const mach_exception_data_t code,
	mach_msg_type_number_t codeCnt,
	int *flavor,
	const thread_state_t old_state,
	mach_msg_type_number_t old_stateCnt,
	thread_state_t new_state,
	mach_msg_type_number_t *new_stateCnt
);

/* Routine mach_exception_raise_state */
mig_internal novalue _Xmach_exception_raise_state
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		exception_type_t exception;
		mach_msg_type_number_t codeCnt;
		int64_t code[2];
		int flavor;
		mach_msg_type_number_t old_stateCnt;
		natural_t old_state[614];
		mach_msg_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	typedef __Request__mach_exception_raise_state_t __Request;
	typedef __Reply__mach_exception_raise_state_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Request *In1P;
	Reply *OutP = (Reply *) OutHeadP;
#ifdef	__MIG_check__Request__mach_exception_raise_state_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__mach_exception_raise_state_t__defined */

	__DeclareRcvRpc(2406, "mach_exception_raise_state")
	__BeforeRcvRpc(2406, "mach_exception_raise_state")

#if	defined(__MIG_check__Request__mach_exception_raise_state_t__defined)
	check_result = __MIG_check__Request__mach_exception_raise_state_t((__Request *)In0P, (__Request **)&In1P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__mach_exception_raise_state_t__defined) */

	OutP->new_stateCnt = 614;

	OutP->RetCode = catch_mach_exception_raise_state(In0P->Head.msgh_request_port, In0P->exception, In0P->code, In0P->codeCnt, &In1P->flavor, In1P->old_state, In1P->old_stateCnt, OutP->new_state, &OutP->new_stateCnt);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->flavor = In1P->flavor;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply) - 2456) + (((4 * OutP->new_stateCnt)));

	__AfterRcvRpc(2406, "mach_exception_raise_state")
}

#if ( __MigTypeCheck )
#if __MIG_check__Request__mach_exc_subsystem__
#if !defined(__MIG_check__Request__mach_exception_raise_state_identity_t__defined)
#define __MIG_check__Request__mach_exception_raise_state_identity_t__defined

mig_internal kern_return_t __MIG_check__Request__mach_exception_raise_state_identity_t(__attribute__((__unused__)) __Request__mach_exception_raise_state_identity_t *In0P, __attribute__((__unused__)) __Request__mach_exception_raise_state_identity_t **In1PP)
{

	typedef __Request__mach_exception_raise_state_identity_t __Request;
	__Request *In1P;
#if	__MigTypeCheck
	unsigned int msgh_size;
#endif	/* __MigTypeCheck */
	unsigned int msgh_size_delta;

#if	__MigTypeCheck
	msgh_size = In0P->Head.msgh_size;
	if (!(In0P->Head.msgh_bits & MACH_MSGH_BITS_COMPLEX) ||
	    (In0P->msgh_body.msgh_descriptor_count != 2) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Request) - 2472)) ||  (msgh_size > (mach_msg_size_t)sizeof(__Request)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->thread.type != MACH_MSG_PORT_DESCRIPTOR ||
	    In0P->thread.disposition != 17)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if	__MigTypeCheck
	if (In0P->task.type != MACH_MSG_PORT_DESCRIPTOR ||
	    In0P->task.disposition != 17)
		return MIG_TYPE_ERROR;
#endif	/* __MigTypeCheck */

#if defined(__NDR_convert__int_rep__Request__mach_exception_raise_state_identity_t__codeCnt__defined)
	if (In0P->NDR.int_rep != NDR_record.int_rep)
		__NDR_convert__int_rep__Request__mach_exception_raise_state_identity_t__codeCnt(&In0P->codeCnt, In0P->NDR.int_rep);
#endif	/* __NDR_convert__int_rep__Request__mach_exception_raise_state_identity_t__codeCnt__defined */
	msgh_size_delta = (8 * In0P->codeCnt);
#if	__MigTypeCheck
	if ( In0P->codeCnt > 2 )
		return MIG_BAD_ARGUMENTS;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Request) - 2472)) / 8 < In0P->codeCnt) ||
	    (msgh_size < (mach_msg_size_t)(sizeof(__Request) - 2472) + (8 * In0P->codeCnt)))
		return MIG_BAD_ARGUMENTS;
	msgh_size -= msgh_size_delta;
#endif	/* __MigTypeCheck */

	*In1PP = In1P = (__Request *) ((pointer_t) In0P + msgh_size_delta - 16);

#if defined(__NDR_convert__int_rep__Request__mach_exception_raise_state_identity_t__old_stateCnt__defined)
	if (In0P->NDR.int_rep != NDR_record.int_rep)
		__NDR_convert__int_rep__Request__mach_exception_raise_state_identity_t__old_stateCnt(&In1P->old_stateCnt, In1P->NDR.int_rep);
#endif	/* __NDR_convert__int_rep__Request__mach_exception_raise_state_identity_t__old_stateCnt__defined */
#if	__MigTypeCheck
	if ( In1P->old_stateCnt > 614 )
		return MIG_BAD_ARGUMENTS;
	if (((msgh_size - (mach_msg_size_t)(sizeof(__Request) - 2472)) / 4 < In1P->old_stateCnt) ||
	    (msgh_size != (mach_msg_size_t)(sizeof(__Request) - 2472) + (4 * In1P->old_stateCnt)))
		return MIG_BAD_ARGUMENTS;
#endif	/* __MigTypeCheck */

	return MACH_MSG_SUCCESS;
}
#endif /* !defined(__MIG_check__Request__mach_exception_raise_state_identity_t__defined) */
#endif /* __MIG_check__Request__mach_exc_subsystem__ */
#endif /* ( __MigTypeCheck ) */


/* Routine mach_exception_raise_state_identity */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
MIG_SERVER_ROUTINE
kern_return_t catch_mach_exception_raise_state_identity
(
	mach_port_t exception_port,
	mach_port_t thread,
	mach_port_t task,
	exception_type_t exception,
	mach_exception_data_t code,
	mach_msg_type_number_t codeCnt,
	int *flavor,
	thread_state_t old_state,
	mach_msg_type_number_t old_stateCnt,
	thread_state_t new_state,
	mach_msg_type_number_t *new_stateCnt
);

/* Routine mach_exception_raise_state_identity */
mig_internal novalue _Xmach_exception_raise_state_identity
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{

#ifdef  __MigPackStructs
#pragma pack(push, 4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t thread;
		mach_msg_port_descriptor_t task;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		exception_type_t exception;
		mach_msg_type_number_t codeCnt;
		int64_t code[2];
		int flavor;
		mach_msg_type_number_t old_stateCnt;
		natural_t old_state[614];
		mach_msg_trailer_t trailer;
	} Request __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack(pop)
#endif
	typedef __Request__mach_exception_raise_state_identity_t __Request;
	typedef __Reply__mach_exception_raise_state_identity_t Reply __attribute__((unused));

	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	Request *In0P = (Request *) InHeadP;
	Request *In1P;
	Reply *OutP = (Reply *) OutHeadP;
#ifdef	__MIG_check__Request__mach_exception_raise_state_identity_t__defined
	kern_return_t check_result;
#endif	/* __MIG_check__Request__mach_exception_raise_state_identity_t__defined */

	__DeclareRcvRpc(2407, "mach_exception_raise_state_identity")
	__BeforeRcvRpc(2407, "mach_exception_raise_state_identity")

#if	defined(__MIG_check__Request__mach_exception_raise_state_identity_t__defined)
	check_result = __MIG_check__Request__mach_exception_raise_state_identity_t((__Request *)In0P, (__Request **)&In1P);
	if (check_result != MACH_MSG_SUCCESS)
		{ MIG_RETURN_ERROR(OutP, check_result); }
#endif	/* defined(__MIG_check__Request__mach_exception_raise_state_identity_t__defined) */

	OutP->new_stateCnt = 614;

	OutP->RetCode = catch_mach_exception_raise_state_identity(In0P->Head.msgh_request_port, In0P->thread.name, In0P->task.name, In0P->exception, In0P->code, In0P->codeCnt, &In1P->flavor, In1P->old_state, In1P->old_stateCnt, OutP->new_state, &OutP->new_stateCnt);
	if (OutP->RetCode != KERN_SUCCESS) {
		MIG_RETURN_ERROR(OutP, OutP->RetCode);
	}

	OutP->NDR = NDR_record;


	OutP->flavor = In1P->flavor;
	OutP->Head.msgh_size = (mach_msg_size_t)(sizeof(Reply) - 2456) + (((4 * OutP->new_stateCnt)));

	__AfterRcvRpc(2407, "mach_exception_raise_state_identity")
}


#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
boolean_t mach_exc_server(
		mach_msg_header_t *InHeadP,
		mach_msg_header_t *OutHeadP);

#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
mig_routine_t mach_exc_server_routine(
		mach_msg_header_t *InHeadP);


/* Description of this subsystem, for use in direct RPC */
const struct catch_mach_exc_subsystem {
	mig_server_routine_t 	server;	/* Server routine */
	mach_msg_id_t	start;	/* Min routine number */
	mach_msg_id_t	end;	/* Max routine number + 1 */
	unsigned int	maxsize;	/* Max msg size */
	vm_address_t	reserved;	/* Reserved */
	struct routine_descriptor	/*Array of routine descriptors */
		routine[3];
} catch_mach_exc_subsystem = {
	mach_exc_server_routine,
	2405,
	2408,
	(mach_msg_size_t)sizeof(union __ReplyUnion__catch_mach_exc_subsystem),
	(vm_address_t)0,
	{
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _Xmach_exception_raise, 6, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__mach_exception_raise_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _Xmach_exception_raise_state, 9, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__mach_exception_raise_state_t)},
          { (mig_impl_routine_t) 0,
          (mig_stub_routine_t) _Xmach_exception_raise_state_identity, 11, 0, (routine_arg_descriptor_t)0, (mach_msg_size_t)sizeof(__Reply__mach_exception_raise_state_identity_t)},
	}
};

mig_external boolean_t mach_exc_server
	(mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP)
{
	/*
	 * typedef struct {
	 * 	mach_msg_header_t Head;
	 * 	NDR_record_t NDR;
	 * 	kern_return_t RetCode;
	 * } mig_reply_error_t;
	 */

	mig_routine_t routine;

	OutHeadP->msgh_bits = MACH_MSGH_BITS(MACH_MSGH_BITS_REPLY(InHeadP->msgh_bits), 0);
	OutHeadP->msgh_remote_port = InHeadP->msgh_reply_port;
	/* Minimal size: routine() will update it if different */
	OutHeadP->msgh_size = (mach_msg_size_t)sizeof(mig_reply_error_t);
	OutHeadP->msgh_local_port = MACH_PORT_NULL;
	OutHeadP->msgh_id = InHeadP->msgh_id + 100;
	OutHeadP->msgh_reserved = 0;

	if ((InHeadP->msgh_id > 2407) || (InHeadP->msgh_id < 2405) ||
	    ((routine = catch_mach_exc_subsystem.routine[InHeadP->msgh_id - 2405].stub_routine) == 0)) {
		((mig_reply_error_t *)OutHeadP)->NDR = NDR_record;
		((mig_reply_error_t *)OutHeadP)->RetCode = MIG_BAD_ID;
		return FALSE;
	}
	(*routine) (InHeadP, OutHeadP);
	return TRUE;
}

mig_external mig_routine_t mach_exc_server_routine
	(mach_msg_header_t *InHeadP)
{
	int msgh_id;

	msgh_id = InHeadP->msgh_id - 2405;

	if ((msgh_id > 2) || (msgh_id < 0))
		return 0;

	return catch_mach_exc_subsystem.routine[msgh_id].stub_routine;
}

```

`src/w1nj3ct/backend/darwin/ptrace.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2022 TheOiseth
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include "injector_internal.h"
#include <libproc.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/ptrace.h>
#define PTRACE_OR_RETURN(request, injector, addr, data) do { \
    int rv = injector__ptrace(request, injector->pid, addr, data, #request); \
    if (rv != 0) { \
        return rv; \
    } \
} while (0)
static int set_ptrace_error(const char *request_name)
{
    int err = errno;
    injector__set_errmsg("%s error : %s", request_name, strerror(errno));
    switch (err) {
    case EFAULT:
        return INJERR_INVALID_MEMORY_AREA;
    case EPERM:
        return INJERR_PERMISSION;
    case ESRCH:
        return INJERR_NO_PROCESS;
    }
    return INJERR_OTHER;
}

int injector__ptrace(int request, pid_t pid, long addr, long data, const char *request_name)
{
    if (ptrace(request, pid, (caddr_t)addr, data) != 0) {
        return set_ptrace_error(request_name);
    }
    return 0;
}

int injector__ptrace_attach(const injector_t *injector)
{
    PTRACE_OR_RETURN(PT_ATTACHEXC, injector, 0, 0);
    return 0;
}

int injector__ptrace_detach(const injector_t *injector)
{
    PTRACE_OR_RETURN(PT_DETACH, injector, 0, 0);
    return 0;
}

int injector__ptrace_continue(const injector_t *injector)
{
    PTRACE_OR_RETURN(PT_CONTINUE, injector, 1, 0);
    return 0;
}

int injector__ptrace_update(const injector_t *injector, long thread_port)
{
    PTRACE_OR_RETURN(PT_THUPDATE, injector, thread_port, 0);
    return 0;
}
```

`src/w1nj3ct/backend/darwin/remote_call.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2022 TheOiseth
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include "injector_internal.h"
#include "mach_exc.h"
#include <stdlib.h>
#include <dlfcn.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/ptrace.h>
#include <signal.h>

//Before change shellcode, see:
//injector.c -> injector_detach
//exc_handler.c -> catch_mach_exception_raise
#if defined(__arm64__) || defined(__aarch64__)
char* shellcode = 
	"\x00\x01\x3f\xd6"		//blr x8
	"\x00\x00\x00\x14"		//b	   //infinity loop, we will terminate this thread later
	
	//second thread
	"\x00\x00\x20\xd4"		//brk 0
	"\x00\x01\x3f\xd6"		//blr x8
	"\x00\x00\x20\xd4"		//brk 0
	"\xc0\x03\x5f\xd6"		//ret
;
int shellcode1_len = 8;
int shellcode_length = 24;
#else

char* shellcode = 
	//"\x55"				//push   rbp
	//"\x48\x89\xE5"		//mov    rbp, rsp
	//"\x48\x83\xEC\x10"	//sub    rsp, 0x10
	//"\x48\x8D\x7D\xF8"	//lea    rdi, [rbp - 8]
	"\x90"					//nop
	"\x90"					//nop
	"\x90"					//nop
	"\xFF\xD0"				//call   rax
	//"\x48\x83\xC4\x10"	//add    rsp, 0x10
	//"\x5D"				//pop    rbp
	"\xeb\xfe"				//jmp 0	   //infinity loop, we will terminate this thread later
	
	//second thread
	"\xcc"				//int3
	//"\x55"				//push   rbp
	//"\x48\x89\xe5"		//mov  rbp, rsp
	"\xff\xd0" 			//call rax
	//"\x5D" 				//pop    rbp
	"\xcc"				//int3
	"\xc3"				//ret
;
int shellcode1_len = 7;
int shellcode_length = 12;
#endif
int injector__call_function(injector_t *injector, long *retval, long function_addr, ...)
{	
	va_list ap;
	va_start(ap, function_addr);
	long arg1, arg2, arg3, arg4, arg5, arg6;
    arg1 = va_arg(ap, long);
    arg2 = va_arg(ap, long);
    arg3 = va_arg(ap, long);
    arg4 = va_arg(ap, long);
    arg5 = va_arg(ap, long);
    arg6 = va_arg(ap, long);
	va_end(ap);
	int rv;

	if(injector->shellcode_writed == 0){
		pcfmt_t pcfmt = (pcfmt_t)dlsym(RTLD_DEFAULT, "pthread_create_from_mach_thread");

		
		rv = injector__write(injector, injector->code_addr, shellcode, shellcode_length);
		if(rv != 0){
			return rv;
		}
		if(pcfmt == 0){
			//char* legacy_append = 
			//"\xFF\xD0"		//call rax
			//"\xcc"			//int3
			//;
			//rv = injector__write(injector, injector->code_addr, legacy_append, 3);
			
			//It turns out that we can call pthread_create in mach thread without _pthread_set_self on MacOS < 10.12
			pcfmt = (pcfmt_t)dlsym(RTLD_DEFAULT, "pthread_create");
		}
		rv = injector__protect(injector, injector->code_addr, injector->code_size, FALSE, VM_PROT_READ | VM_PROT_EXECUTE);
		if (rv != 0) {
			return rv;
		}
		injector->shellcode_writed = 1;
		injector->code2_addr = injector->code_addr + shellcode1_len;
		
		thread_act_t mach_thread;
#if defined(__arm64__) || defined(__aarch64__)
		arm_thread_state64_t state;
		memset(&state, '\0', sizeof(state));
		state.__pc = injector->code_addr;
		state.__sp = injector->stack;
		state.__x[8] = (uint64_t)pcfmt;
		state.__x[0] = injector->stack - 32;		
		
		state.__x[1] = 0;
		state.__x[2] = injector->code2_addr;
		state.__x[3] = 0;
		rv = thread_create_running(injector->remote_task, ARM_THREAD_STATE64, (thread_state_t)&state, ARM_THREAD_STATE64_COUNT , &mach_thread);
#else
		x86_thread_state64_t state;
		memset(&state, '\0', sizeof(state));
		state.__rip = injector->code_addr;
		state.__rsp = injector->stack - 0x10;
		state.__rbp = injector->stack;	
		if(pcfmt == NULL){
			state.__rax = (uint64_t)dlsym(RTLD_DEFAULT, "_pthread_set_self");
			state.__rdi = 0;
			injector->func_addr = (uint64_t)dlsym(RTLD_DEFAULT, "pthread_create");
			injector->arg1 = injector->stack - 0x8;
			injector->arg2 = 0;
			injector->arg3 = injector->code2_addr;
			injector->arg4 = 0;
		} else {
			state.__rax = (uint64_t)pcfmt;
			state.__rdi = injector->stack - 0x8;//&thread
		}
		
		state.__rsi = 0;
		state.__rdx = injector->code2_addr;
		state.__rcx = 0;		

		rv = thread_create_running(injector->remote_task, x86_THREAD_STATE64, (thread_state_t)&state, x86_THREAD_STATE64_COUNT, &mach_thread);
#endif
		if(rv != 0){
			injector__set_errmsg("%s error : %s", "CREATE_THREAD", mach_error_string(rv));
			return INJERR_ERROR_IN_TARGET;
		}
		injector->mach_thread = mach_thread;
		if(pcfmt == NULL){
			injector->handle_action = TRAP_SETREGS;
			injector__handle_exc(injector);
		}
		injector->func_addr = function_addr;
		injector->arg1 = arg1;
		injector->arg2 = arg2;
		injector->arg3 = arg3;
		injector->arg4 = arg4;
		injector->arg5 = arg5;
		injector->arg6 = arg6;
	
		injector->handle_action = TRAP_SETREGS;
		injector__handle_exc(injector);
	} else {
#if defined(__arm64__) || defined(__aarch64__)

		mach_msg_type_number_t state_count = ARM_THREAD_STATE64_COUNT;
		arm_thread_state64_t state;
		rv = thread_get_state(injector->remote_thread, ARM_THREAD_STATE64, (thread_state_t)&state, &state_count);
		if(rv != 0){
			injector__set_errmsg("%s error : %s", "THREAD_GET_STATE", mach_error_string(rv));
			return INJERR_ERROR_IN_TARGET;
		}
		state.__pc = injector->code2_addr + 4;
		state.__x[0] = arg1;
		state.__x[1] = arg2;
		state.__x[2] = arg3;
		state.__x[3] = arg4;
		state.__x[4] = arg5;
		state.__x[5] = arg6;
		state.__x[8] = function_addr;
		rv = thread_set_state(injector->remote_thread, ARM_THREAD_STATE64, (thread_state_t)&state, ARM_THREAD_STATE64_COUNT);
#else
		mach_msg_type_number_t state_count = x86_THREAD_STATE64_COUNT;
		x86_thread_state64_t state;
		rv = thread_get_state(injector->remote_thread, x86_THREAD_STATE64, (thread_state_t)&state, &state_count);
		if(rv != 0){
			injector__set_errmsg("%s error : %s", "THREAD_GET_STATE", mach_error_string(rv));
			return INJERR_ERROR_IN_TARGET;
		}
		state.__rip = injector->code2_addr + 1;
		state.__rax = function_addr;
		state.__rdi = arg1;
		state.__rsi = arg2;
		state.__rdx = arg3;
		state.__rcx = arg4;
		state.__r8 = arg5;
		state.__r9 = arg6;
		rv = thread_set_state(injector->remote_thread, x86_THREAD_STATE64, (thread_state_t)&state, x86_THREAD_STATE64_COUNT);
#endif
		if(rv != 0){
			injector__set_errmsg("%s error : %s", "THREAD_SET_STATE", mach_error_string(rv));
			return INJERR_ERROR_IN_TARGET;
		}
		rv = thread_resume(injector->remote_thread);
		if(rv != 0){
			injector__set_errmsg("%s error : %s", "THREAD_RESUME", mach_error_string(rv));
			return INJERR_ERROR_IN_TARGET;
		}
	}	

	injector->handle_action = TRAP_GETREGS;
	injector__handle_exc(injector);
	if(injector->handle_err != 0){
		return injector->handle_err;
	}
	*retval = injector->retval;
	return 0;
}

```

`src/w1nj3ct/backend/darwin/util.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2022 TheOiseth
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include "injector_internal.h"
#include <stdarg.h>
#include <libproc.h>
#include <bsm/libbsm.h>
#include <sys/sysctl.h>
#include <sys/types.h>
#include <unistd.h>


char injector__errmsg[512];
char injector__errmsg_is_set;

void injector__set_errmsg(const char *format, ...)
{
    va_list ap;
    int rv;

    /* prevent the error message from being overwritten. */
    if (injector__errmsg_is_set) {
        return;
    }
    injector__errmsg_is_set = 1;

    va_start(ap, format);
    rv = vsnprintf(injector__errmsg, sizeof(injector__errmsg), format, ap);
    va_end(ap);
    if (rv == -1 || rv >= sizeof(injector__errmsg)) {
        injector__errmsg[sizeof(injector__errmsg) - 1] = '\0';
    }
}
#ifndef P_TRANSLATED
#define P_TRANSLATED    0x00020000
#endif
int injector__get_process_arch(pid_t pid, arch_t *arch){
    int mib[CTL_MAXNAME] = {0};
    mib[0] = CTL_KERN;
    mib[1] = KERN_PROC;
    mib[2] = KERN_PROC_PID;
    mib[3] = pid;
    size_t length = 4;
    struct kinfo_proc proc_info = {0};
    size_t size = sizeof(proc_info);

    if(sysctl(mib, (u_int)length, &proc_info, &size, NULL, 0) != 0) {
        *arch = ARCH_UNKNOWN;
        return INJERR_SUCCESS;
    }
    if (size == 0) {
        injector__set_errmsg("Process %d not found", pid);
        return INJERR_NO_PROCESS;
    }

    if(P_TRANSLATED == (P_TRANSLATED & proc_info.kp_proc.p_flag)){
        if(P_LP64 == (P_LP64 & proc_info.kp_proc.p_flag)){
            *arch = ARCH_X86_64;
            return INJERR_SUCCESS;
        } else {
            *arch = ARCH_I386;
            return INJERR_SUCCESS;
        }
    } else {
        arch_t sys_arch = injector__get_system_arch();
        if(sys_arch == ARCH_ARM64){
            *arch = ARCH_ARM64;
            return INJERR_SUCCESS;
        }
#if defined(__arm64__) || defined(__aarch64__)
        if(sys_arch == ARCH_UNKNOWN){
            *arch = ARCH_ARM64;
            return INJERR_SUCCESS;
        }
#endif
    }

    if(P_LP64 == (P_LP64 & proc_info.kp_proc.p_flag)){
        *arch = ARCH_X86_64;
        return INJERR_SUCCESS;
    }
    *arch = ARCH_I386;
    return INJERR_SUCCESS;
}

#ifndef CPU_TYPE_ARM64
#define CPU_TYPE_ARM            ((cpu_type_t) 12)
#define CPU_ARCH_ABI64          0x01000000
#define CPU_TYPE_ARM64          (CPU_TYPE_ARM | CPU_ARCH_ABI64)
#endif
arch_t injector__get_system_arch(){
	size_t size;
	cpu_type_t type = -1;
	int mib[CTL_MAXNAME] = {0};
	size_t length = CTL_MAXNAME;

	if (sysctlnametomib("sysctl.proc_cputype", mib, &length) != 0){
		return ARCH_UNKNOWN;
	}

	mib[length] = getpid();
	length++;
	size = sizeof(cpu_type_t);

	if (sysctl(mib, (u_int)length, &type, &size, 0, 0) != 0){
		return ARCH_UNKNOWN;
	}
	if (CPU_TYPE_X86_64 == type) {
		return ARCH_X86_64;
	}

	if (CPU_TYPE_ARM64 == type) {
		return ARCH_ARM64;
	}
	return ARCH_UNKNOWN;
}
const char *injector__arch2name(arch_t arch)
{
    switch (arch) {
    case ARCH_X86_64:
        return "x86_64";
    case ARCH_I386:
        return "i386";
    case ARCH_ARM64:
        return "ARM64";
    case ARCH_POWERPC_64:
        return "PowerPC 64-bit";
    case ARCH_POWERPC:
        return "PowerPC";
	case ARCH_UNKNOWN:
        return "Unknown";
    }
    return "?";
}
```

`src/w1nj3ct/backend/linux/elf.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2018 Kubo Takehiro <kubo@jiubao.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <regex.h>
#include <elf.h>
#include <glob.h>
#include <sys/sysmacros.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/statfs.h>
#include <limits.h>
#include <unistd.h>
#include "injector_internal.h"

#ifdef __LP64__
#define Elf_Ehdr Elf64_Ehdr
#define Elf_Shdr Elf64_Shdr
#define Elf_Sym Elf64_Sym
#else
#define Elf_Ehdr Elf32_Ehdr
#define Elf_Shdr Elf32_Shdr
#define Elf_Sym Elf32_Sym
#endif

// #define INJECTOR_DEBUG_ELF_C 1

#ifdef INJECTOR_DEBUG_ELF_C
#undef DEBUG
#define DEBUG(...) fprintf(stderr, __VA_ARGS__)
#else
#undef DEBUG
#define DEBUG(...) do {} while(0)
#endif

typedef struct {
    int dlfunc_type; /* -1, DLFUNC_POSIX or DLFUNC_INTERNAL */
    FILE *fp;
    size_t libc_addr;
    size_t str_offset;
    size_t str_size;
    size_t sym_offset;
    size_t sym_num;
    size_t sym_entsize;
} param_t;

static int search_and_open_libc(FILE **fp_out, pid_t pid, size_t *addr, libc_type_t *libc_type);
static int open_libc(FILE **fp_out, const char *path, pid_t pid, dev_t dev, ino_t ino);
static FILE *fopen_with_ino(const char *path, dev_t dev, ino_t ino);
static int read_elf_ehdr(FILE *fp, Elf_Ehdr *ehdr);
static int read_elf_shdr(FILE *fp, Elf_Shdr *shdr, size_t shdr_size);
static int read_elf_sym(FILE *fp, Elf_Sym *sym, size_t sym_size);
static int find_symbol_addr(size_t *addr, param_t *prm, const char *posix_name, const char *internal_name);
static size_t find_strtab_offset(const param_t *prm, const char *name);

int injector__collect_libc_information(injector_t *injector)
{
    pid_t pid = injector->pid;
    FILE *fp;
    Elf_Ehdr ehdr;
    Elf_Shdr shdr;
    param_t prm = {-1, };
    size_t shstrtab_offset;
    int idx;
    int rv;

    rv = search_and_open_libc(&fp, pid, &prm.libc_addr, &injector->libc_type);
    if (rv != 0) {
        return rv;
    }
    rv = read_elf_ehdr(fp, &ehdr);
    if (rv != 0) {
        goto cleanup;
    }
    fseek(fp, ehdr.e_shoff + ehdr.e_shstrndx * ehdr.e_shentsize, SEEK_SET);
    rv = read_elf_shdr(fp, &shdr, ehdr.e_shentsize);
    if (rv != 0) {
        goto cleanup;
    }
    shstrtab_offset = shdr.sh_offset;

    fseek(fp, ehdr.e_shoff, SEEK_SET);
    for (idx = 0; idx < ehdr.e_shnum; idx++) {
        fpos_t pos;
        char buf[8];

        rv = read_elf_shdr(fp, &shdr, ehdr.e_shentsize);
        if (rv != 0) {
            goto cleanup;
        }
        switch (shdr.sh_type) {
        case SHT_STRTAB:
            fgetpos(fp, &pos);
            fseek(fp, shstrtab_offset + shdr.sh_name, SEEK_SET);
            fgets(buf, sizeof(buf), fp);
            fsetpos(fp, &pos);
            if (strcmp(buf, ".dynstr") == 0) {
                prm.str_offset = shdr.sh_offset;
                prm.str_size = shdr.sh_size;
            }
            break;
        case SHT_DYNSYM:
            fgetpos(fp, &pos);
            fseek(fp, shstrtab_offset + shdr.sh_name, SEEK_SET);
            fgets(buf, sizeof(buf), fp);
            fsetpos(fp, &pos);
            if (strcmp(buf, ".dynsym") == 0) {
                prm.sym_offset = shdr.sh_offset;
                prm.sym_entsize = shdr.sh_entsize;
                prm.sym_num = shdr.sh_size / shdr.sh_entsize;
            }
            break;
        }
        if (prm.sym_offset != 0 && prm.str_offset != 0) {
            break;
        }
    }
    if (idx == ehdr.e_shnum) {
        injector__set_errmsg("failed to find the .dynstr and .dynsym sections.");
        rv = INJERR_INVALID_ELF_FORMAT;
        goto cleanup;
    }

    prm.fp = fp;

    rv = find_symbol_addr(&injector->dlopen_addr, &prm, "dlopen", "__libc_dlopen_mode");
    if (rv != 0) {
        goto cleanup;
    }

    rv = find_symbol_addr(&injector->dlclose_addr, &prm, "dlclose", "__libc_dlclose");
    if (rv != 0) {
        goto cleanup;
    }

    rv = find_symbol_addr(&injector->dlsym_addr, &prm, "dlsym", "__libc_dlsym");
    if (rv != 0) {
        goto cleanup;
    }

    if (prm.dlfunc_type != DLFUNC_INTERNAL) {
        rv = find_symbol_addr(&injector->dlerror_addr, &prm, "dlerror", NULL);
        if (rv != 0) {
            goto cleanup;
        }
    } else {
        injector->dlerror_addr = 0;
    }

#ifdef INJECTOR_HAS_INJECT_IN_CLONED_THREAD
    rv = find_symbol_addr(&injector->clone_addr, &prm, "clone", "clone");
    if (rv != 0) {
        goto cleanup;
    }
#endif

    rv = find_symbol_addr(NULL, &prm, "gnu_get_libc_release", "gnu_get_libc_release");
    if (rv == 0) {
        /* GNU libc */
        injector->libc_type = LIBC_TYPE_GNU;
    }

    injector->dlfunc_type = prm.dlfunc_type;
    injector->code_addr = prm.libc_addr + ehdr.e_entry;

    switch (ehdr.e_machine) {
    case EM_X86_64:
        if (ehdr.e_ident[EI_CLASS] == ELFCLASS64) {
            /* LP64 */
            injector->arch = ARCH_X86_64;
            injector->sys_mmap = 9;
            injector->sys_mprotect = 10;
            injector->sys_munmap = 11;
        } else {
            /* ILP32 */
            injector->arch = ARCH_X86_64_X32;
            injector->sys_mmap = 0x40000000 + 9;
            injector->sys_mprotect = 0x40000000 + 10;
            injector->sys_munmap = 0x40000000 + 11;
        }
        break;
    case EM_386:
        injector->arch = ARCH_I386;
        injector->sys_mmap = 192;
        injector->sys_mprotect = 125;
        injector->sys_munmap = 91;
        break;
    case EM_AARCH64:
        injector->arch = ARCH_ARM64;
        injector->sys_mmap = 222;
        injector->sys_mprotect = 226;
        injector->sys_munmap = 215;
        break;
    case EM_ARM:
        if (EF_ARM_EABI_VERSION(ehdr.e_flags) == 0) {
            injector__set_errmsg("ARM OABI target process isn't supported.");
            rv = INJERR_UNSUPPORTED_TARGET;
            goto cleanup;
        }
        if (injector->code_addr & 1u) {
            injector->code_addr &= ~1u;
            injector->arch = ARCH_ARM_EABI_THUMB;
        } else {
            injector->arch = ARCH_ARM_EABI;
        }
        injector->sys_mmap = 192;
        injector->sys_mprotect = 125;
        injector->sys_munmap = 91;
        break;
    case EM_MIPS:
        if (ehdr.e_ident[EI_CLASS] == ELFCLASS64) {
            /* MIPS 64 */
            injector->arch = ARCH_MIPS_64;
            injector->sys_mmap = 5000 + 9;
            injector->sys_mprotect = 5000 + 10;
            injector->sys_munmap = 5000 + 11;
        } else if (ehdr.e_flags & EF_MIPS_ABI2) {
            /* MIPS N32 */
            injector->arch = ARCH_MIPS_N32;
            injector->sys_mmap = 6000 + 9;
            injector->sys_mprotect = 6000 + 10;
            injector->sys_munmap = 6000 + 11;
        } else {
            /* MIPS O32 */
            injector->arch = ARCH_MIPS_O32;
            injector->sys_mmap = 4000 + 90;
            injector->sys_mprotect = 4000 + 125;
            injector->sys_munmap = 4000 + 91;
        }
        break;
    case EM_PPC64:
        injector->arch = ARCH_POWERPC_64;
        injector->sys_mmap = 90;
        injector->sys_mprotect = 125;
        injector->sys_munmap = 91;
        break;
    case EM_PPC:
        injector->arch = ARCH_POWERPC;
        injector->sys_mmap = 90;
        injector->sys_mprotect = 125;
        injector->sys_munmap = 91;
        break;
#ifdef EM_RISCV
    case EM_RISCV:
        if (ehdr.e_ident[EI_CLASS] == ELFCLASS64) {
            injector->arch = ARCH_RISCV_64;
        } else {
            injector->arch = ARCH_RISCV_32;
        }
        injector->sys_mmap = 222;
        injector->sys_mprotect = 226;
        injector->sys_munmap = 215;
        break;
#endif
    default:
        injector__set_errmsg("Unknown target process architecture: 0x%04x", ehdr.e_machine);
        rv = INJERR_UNSUPPORTED_TARGET;
        goto cleanup;
    }
    rv = 0;
cleanup:
    fclose(fp);
    return rv;
}

static int search_and_open_libc(FILE **fp_out, pid_t pid, size_t *addr, libc_type_t *libc_type)
{
    char buf[512];
    FILE *fp = NULL;
    regex_t reg;
    regmatch_t match;

    sprintf(buf, "/proc/%d/maps", pid);
    fp = fopen(buf, "r");
    if (fp == NULL) {
        injector__set_errmsg("failed to open %s. (error: %s)", buf, strerror(errno));
        return INJERR_OTHER;
    }
    DEBUG("Open %s\n", buf);
    /* /libc.so.6 or /libc-2.{DIGITS}.so or /ld-musl-{arch}.so.1 */
    if (regcomp(&reg, "/libc(\\.so\\.6|-2\\.[0-9]+\\.so)|/ld-musl-.+?\\.so\\.1", REG_EXTENDED) != 0) {
        injector__set_errmsg("regcomp failed!");
        return INJERR_OTHER;
    }
    while (fgets(buf, sizeof(buf), fp) != NULL) {
        unsigned long saddr, eaddr;
        unsigned long long offset, inode;
        unsigned int dev_major, dev_minor;
        DEBUG("   %s", buf);
        if (sscanf(buf, "%lx-%lx %*s %llx %x:%x %llu", &saddr, &eaddr, &offset, &dev_major, &dev_minor, &inode) != 6) {
            continue;
        }
        if (offset != 0) {
            continue;
        }
        if (regexec(&reg, buf, 1, &match, 0) != 0) {
            continue;
        }
        char *p = buf + match.rm_eo;
        if (strcmp(p, " (deleted)\n") == 0) {
            injector__set_errmsg("The C library when the process started was removed");
            fclose(fp);
            regfree(&reg);
            return INJERR_NO_LIBRARY;
        }
        if (strcmp(p, "\n") != 0) {
            continue;
        }
        fclose(fp);
        *addr = saddr;
        if (strstr(buf, "/ld-musl-") != NULL) {
            *libc_type = LIBC_TYPE_MUSL;
        } else {
            *libc_type = LIBC_TYPE_GNU;
        }
        regfree(&reg);
        *p = '\0';
        p = strchr(buf, '/');
        DEBUG(" libc in /proc/PID/maps: '%s'\n", p);
        return open_libc(fp_out, p, pid, makedev(dev_major, dev_minor), inode);
    }
    fclose(fp);
    injector__set_errmsg("Could not find libc");
    regfree(&reg);
    return INJERR_NO_LIBRARY;
}

static int open_libc(FILE **fp_out, const char *path, pid_t pid, dev_t dev, ino_t ino)
{
    FILE *fp = fopen_with_ino(path, dev, ino);

    if (fp != NULL) {
        goto found;
    }

    /* workaround for LXD */
    const char *p = strstr(path, "/rootfs/"); 
    if (p != NULL) {
        fp = fopen_with_ino(p + 7, dev, ino);
        if (fp != NULL) {
           goto found;
        }
    }

    // workaround for Flatpak (https://flatpak.org/)
    //
    // libc is under /proc/<PID>/root.
    // The idea came from https://github.com/kubo/injector/pull/36.
    char buf[PATH_MAX];
    snprintf(buf, sizeof(buf), "/proc/%d/root%s", pid, path);
    buf[sizeof(buf) - 1] = '\0';
    fp = fopen_with_ino(buf, dev, ino);
    if (fp != NULL) {
        goto found;
    }

    // workaround for Snap
    //
    // libc is in a base snap (https://snapcraft.io/docs/base-snaps),
    glob_t globbuf;
    if (glob("/snap/core*/*", GLOB_NOSORT, NULL, &globbuf) == 0) {
        size_t idx;
        for (idx = 0; idx < globbuf.gl_pathc; idx++) {
            char buf[512];
            snprintf(buf, sizeof(buf), "%s%s", globbuf.gl_pathv[idx], path);
            buf[sizeof(buf) - 1] = '\0';
            fp = fopen_with_ino(buf, dev, ino);
            if (fp != NULL) {
                globfree(&globbuf);
                goto found;
            }
        }
        globfree(&globbuf);
    }
    injector__set_errmsg("failed to open %s. (dev:0x%" PRIx64 ", ino:%lu)", path, dev, ino);
    return INJERR_NO_LIBRARY;
found:
    *fp_out = fp;
    return 0;
}

static inline int is_on_overlay_fs(int fd)
{
    struct statfs sbuf;
    if (fstatfs(fd, &sbuf) != 0) {
        DEBUG(" fstatfs() error %s\n", strerror(errno));
        return -1;
    }
#ifndef OVERLAYFS_SUPER_MAGIC
#define OVERLAYFS_SUPER_MAGIC 0x794c7630
#endif
    return (sbuf.f_type == OVERLAYFS_SUPER_MAGIC) ? 1 : 0;
}

static FILE *fopen_with_ino(const char *path, dev_t dev, ino_t ino)
{
    DEBUG("   checking: '%s' ...", path);
    struct stat sbuf;
    FILE *fp = fopen(path, "r");

    if (fp == NULL) {
        DEBUG(" fopen() error %s\n", strerror(errno));
        return NULL;
    }

    if (fstat(fileno(fp), &sbuf) != 0) {
        DEBUG(" fstat() error %s\n", strerror(errno));
        goto cleanup;
    }
    if (sbuf.st_ino != ino) {
        DEBUG(" unexpected inode number: expected %llu but %llu\n",
              (unsigned long long)ino, (unsigned long long)sbuf.st_ino);
        goto cleanup;
    }
    if (sbuf.st_dev != dev) {
        int rv = is_on_overlay_fs(fileno(fp));
        if (rv < 0) {
            goto cleanup;
        }
        if (rv != 1) {
            DEBUG(" unexpected device number: expected %llu but %llu\n",
                  (unsigned long long)dev, (unsigned long long)sbuf.st_dev);
            goto cleanup;
        }
        DEBUG(" ignore device number mismatch (expected %llu but %llu) on overlay file system  ... ",
              (unsigned long long)dev, (unsigned long long)sbuf.st_dev);
    }

    DEBUG(" OK\n");
    return fp;
cleanup:
    fclose(fp);
    return NULL;
}

static int read_elf_ehdr(FILE *fp, Elf_Ehdr *ehdr)
{
    if (fread(ehdr, sizeof(*ehdr), 1, fp) != 1) {
        injector__set_errmsg("failed to read ELF header. (error: %s)", strerror(errno));
        return INJERR_INVALID_ELF_FORMAT;
    }
    if (memcmp(ehdr->e_ident, ELFMAG, SELFMAG) != 0) {
        injector__set_errmsg("Invalid ELF header: 0x%02x,0x%02x,0x%02x,0x%02x",
                           ehdr->e_ident[0], ehdr->e_ident[1], ehdr->e_ident[2], ehdr->e_ident[3]);
        return INJERR_INVALID_ELF_FORMAT;
    }
    switch (ehdr->e_ident[EI_CLASS]) {
    case ELFCLASS32:
#ifdef __LP64__
        {
            Elf32_Ehdr *ehdr32 = (Elf32_Ehdr *)ehdr;
            /* copy from last */
            ehdr->e_shstrndx = ehdr32->e_shstrndx;
            ehdr->e_shnum = ehdr32->e_shnum;
            ehdr->e_shentsize = ehdr32->e_shentsize;
            ehdr->e_phnum = ehdr32->e_phnum;
            ehdr->e_phentsize = ehdr32->e_phentsize;
            ehdr->e_ehsize = ehdr32->e_ehsize;
            ehdr->e_flags = ehdr32->e_flags;
            ehdr->e_shoff = ehdr32->e_shoff;
            ehdr->e_phoff = ehdr32->e_phoff;
            ehdr->e_entry = ehdr32->e_entry;
            ehdr->e_version = ehdr32->e_version;
            ehdr->e_machine = ehdr32->e_machine;
            ehdr->e_type = ehdr32->e_type;
        }
#endif
        break;
    case ELFCLASS64:
#ifndef __LP64__
        injector__set_errmsg("64-bit target process isn't supported by 32-bit process.");
        return INJERR_UNSUPPORTED_TARGET;
#endif
        break;
    default:
        injector__set_errmsg("Invalid ELF class: 0x%x", ehdr->e_ident[EI_CLASS]);
        return INJERR_UNSUPPORTED_TARGET;
    }
    return 0;
}

static int read_elf_shdr(FILE *fp, Elf_Shdr *shdr, size_t shdr_size)
{
    if (fread(shdr, shdr_size, 1, fp) != 1) {
        injector__set_errmsg("failed to read a section header. (error: %s)", strerror(errno));
        return INJERR_INVALID_ELF_FORMAT;
    }
#ifdef __LP64__
    if (shdr_size == sizeof(Elf32_Shdr)) {
        Elf32_Shdr shdr32 = *(Elf32_Shdr *)shdr;
        shdr->sh_name = shdr32.sh_name;
        shdr->sh_type = shdr32.sh_type;
        shdr->sh_flags = shdr32.sh_flags;
        shdr->sh_addr = shdr32.sh_addr;
        shdr->sh_offset = shdr32.sh_offset;
        shdr->sh_size = shdr32.sh_size;
        shdr->sh_link = shdr32.sh_link;
        shdr->sh_info = shdr32.sh_info;
        shdr->sh_addralign = shdr32.sh_addralign;
        shdr->sh_entsize = shdr32.sh_entsize;
    }
#endif
    return 0;
}

static int read_elf_sym(FILE *fp, Elf_Sym *sym, size_t sym_size)
{
    if (fread(sym, sym_size, 1, fp) != 1) {
        injector__set_errmsg("failed to read a symbol table entry. (error: %s)", strerror(errno));
        return INJERR_INVALID_ELF_FORMAT;
    }
#ifdef __LP64__
    if (sym_size == sizeof(Elf32_Sym)) {
        Elf32_Sym sym32 = *(Elf32_Sym *)sym;
        sym->st_name = sym32.st_name;
        sym->st_value = sym32.st_value;
        sym->st_size = sym32.st_size;
        sym->st_info = sym32.st_info;
        sym->st_other = sym32.st_other;
        sym->st_shndx = sym32.st_shndx;
    }
#endif
    return 0;
}

static int find_symbol_addr(size_t *addr, param_t *prm, const char *posix_name, const char *internal_name)
{
    size_t st_name;

    switch (prm->dlfunc_type) {
    case -1:
        st_name = find_strtab_offset(prm, posix_name);
        if (st_name != 0) {
            prm->dlfunc_type = DLFUNC_POSIX;
        } else {
            prm->dlfunc_type = DLFUNC_INTERNAL;
            st_name = find_strtab_offset(prm, internal_name);
        }
        break;
    case DLFUNC_POSIX:
        st_name = find_strtab_offset(prm, posix_name);
        break;
    case DLFUNC_INTERNAL:
        st_name = find_strtab_offset(prm, internal_name);
        break;
    }

    if (addr == NULL) {
        return st_name != 0 ? 0 : INJERR_NO_FUNCTION;
    }

    if (st_name != 0) {
        Elf_Sym sym;
        int idx;
        int rv;

        fseek(prm->fp, prm->sym_offset, SEEK_SET);
        for (idx = 0; idx < prm->sym_num; idx++) {
            rv = read_elf_sym(prm->fp, &sym, prm->sym_entsize);
            if (rv != 0) {
                return rv;
            }
            if (sym.st_name == st_name) {
                *addr = prm->libc_addr + sym.st_value;
                return 0;
            }
        }
    }
    injector__set_errmsg("failed to find %s%s%s in the .dynstr section.",
                         posix_name, internal_name ? "/" : "",
                         internal_name ? internal_name : "");
    return INJERR_NO_FUNCTION;
}

static size_t find_strtab_offset(const param_t *prm, const char *name)
{
    size_t off;
    size_t idx = 0;

    fseek(prm->fp, prm->str_offset, SEEK_SET);
    for (off = 0; off < prm->str_size; off++) {
        int c = fgetc(prm->fp);
        if (c == EOF) {
            return 0;
        }
        if (c == name[idx]) {
            if (c == 0) {
                return off - idx;
            }
            idx++;
        } else {
            idx = 0;
        }
    }
    return 0;
}

```

`src/w1nj3ct/backend/linux/injector.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2018-2023 Kubo Takehiro <kubo@jiubao.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif
#include <alloca.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <errno.h>
#include <dlfcn.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <time.h>
#include <unistd.h>
#include <limits.h>
#include "injector_internal.h"

static inline size_t remote_mem_size(injector_t *injector) {
    return 2 * injector->data_size + injector->stack_size;
}

int injector_attach(injector_t **injector_out, pid_t pid)
{
    injector_t *injector;
    int status;
    intptr_t retval;
    int prot;
    int rv = 0;

    injector__errmsg_is_set = 0;

    injector = calloc(1, sizeof(injector_t));
    if (injector == NULL) {
        injector__set_errmsg("malloc error: %s", strerror(errno));
        return INJERR_NO_MEMORY;
    }
    injector->pid = pid;
    rv = injector__attach_process(injector);
    if (rv != 0) {
        goto error_exit;
    }
    injector->attached = 1;

    do {
        rv = waitpid(pid, &status, 0);
    } while (rv == -1 && errno == EINTR);
    if (rv == -1) {
        injector__set_errmsg("waitpid error while attaching: %s", strerror(errno));
        rv = INJERR_WAIT_TRACEE;
        goto error_exit;
    }

    rv = injector__collect_libc_information(injector);
    if (rv != 0) {
        goto error_exit;
    }
    rv = injector__get_regs(injector, &injector->regs);
    if (rv != 0) {
        goto error_exit;
    }
    rv = injector__read(injector, injector->code_addr, &injector->backup_code, sizeof(injector->backup_code));
    if (rv != 0) {
        goto error_exit;
    }

    injector->data_size = sysconf(_SC_PAGESIZE);
    injector->stack_size = 2 * 1024 * 1024;

    rv = injector__call_syscall(injector, &retval, injector->sys_mmap, 0,
                                remote_mem_size(injector), PROT_READ | PROT_WRITE,
                                MAP_PRIVATE | MAP_ANONYMOUS | MAP_GROWSDOWN, -1, 0);
    if (rv != 0) {
        goto error_exit;
    }
    if (retval == -1) {
        injector__set_errmsg("mmap error: %s", strerror(errno));
        rv = INJERR_ERROR_IN_TARGET;
        goto error_exit;
    }
    injector->mmapped = 1;
    injector->data = (size_t)retval;
    injector->stack = (size_t)retval + 2 * injector->data_size;
#ifdef INJECTOR_HAS_INJECT_IN_CLONED_THREAD
    injector->shellcode = (size_t)retval + 1 * injector->data_size;
    prot = PROT_READ | PROT_EXEC;
#else
    prot = PROT_NONE;
#endif
    rv = injector__call_syscall(injector, &retval, injector->sys_mprotect,
                                injector->data + injector->data_size, injector->data_size,
                                prot);
    if (rv != 0) {
        goto error_exit;
    }
    if (retval != 0) {
        injector__set_errmsg("mprotect error: %s", strerror(errno));
        rv = INJERR_ERROR_IN_TARGET;
        goto error_exit;
    }
#ifdef INJECTOR_HAS_INJECT_IN_CLONED_THREAD
    rv = injector__write(injector, injector->shellcode, &injector_shellcode, injector_shellcode_size);
    if (rv != 0) {
        return rv;
    }
#endif

    *injector_out = injector;
    return 0;
error_exit:
    injector_detach(injector);
    return rv;
}

int injector_inject(injector_t *injector, const char *path, void **handle)
{
    char abspath[PATH_MAX];
    int dlflags = RTLD_LAZY;
    size_t len;
    int rv;
    intptr_t retval;

    injector__errmsg_is_set = 0;

    if (path[0] == '/') {
        len = strlen(path) + 1;
    } else if (realpath(path, abspath) != NULL) {
        path = abspath;
        len = strlen(abspath) + 1;
    } else {
        injector__set_errmsg("failed to get the full path of '%s': %s",
                           path, strerror(errno));
        return INJERR_FILE_NOT_FOUND;
    }

    if (len > injector->data_size) {
        injector__set_errmsg("too long file path: %s", path);
        return INJERR_FILE_NOT_FOUND;
    }

    rv = injector__write(injector, injector->data, path, len);
    if (rv != 0) {
        return rv;
    }
    if (injector->dlfunc_type == DLFUNC_INTERNAL) {
#define __RTLD_DLOPEN	0x80000000 // glibc internal flag
        dlflags |= __RTLD_DLOPEN;
    }
    rv = injector__call_function(injector, &retval, injector->dlopen_addr, injector->data, dlflags);
    if (rv != 0) {
        return rv;
    }
    if (retval == 0) {
        char buf[256 + 1] = {0,};
        if (injector->dlerror_addr != 0) {
            rv = injector__call_function(injector, &retval, injector->dlerror_addr);
            if (rv == 0 && retval != 0) {
                injector__read(injector, retval, buf, sizeof(buf) - 1);
            }
        }
        if (buf[0] != '\0') {
            injector__set_errmsg("dlopen failed: %s", buf);
        } else {
            injector__set_errmsg("dlopen failed");
        }
        return INJERR_ERROR_IN_TARGET;
    }
    if (handle != NULL) {
        *handle = (void*)retval;
    }
    return 0;
}

#ifdef INJECTOR_HAS_INJECT_IN_CLONED_THREAD
int injector_inject_in_cloned_thread(injector_t *injector, const char *path, void **handle_out)
{
    void *data;
    injector_shellcode_arg_t *arg;
    const size_t file_path_offset = offsetof(injector_shellcode_arg_t, file_path);
    void * const invalid_handle = (void*)-3;
    char abspath[PATH_MAX];
    size_t pathlen;
    int rv;
    intptr_t retval;

    injector__errmsg_is_set = 0;

    if (injector->arch != ARCH_X86_64) {
        injector__set_errmsg("injector_inject_in_cloned_thread doesn't support %s.",
                             injector__arch2name(injector->arch));
        return INJERR_UNSUPPORTED_TARGET;
    }

    if (realpath(path, abspath) == NULL) {
        injector__set_errmsg("failed to get the full path of '%s': %s",
                           path, strerror(errno));
        return INJERR_FILE_NOT_FOUND;
    }
    pathlen = strlen(abspath) + 1;

    if (file_path_offset + pathlen > injector->data_size) {
        injector__set_errmsg("too long path name: %s", path);
        return INJERR_FILE_NOT_FOUND;
    }

    data = alloca(injector->data_size);
    memset(data, 0, injector->data_size);
    arg = (injector_shellcode_arg_t *)data;

    arg->handle = invalid_handle;
    arg->dlopen_addr = injector->dlopen_addr;
    arg->dlerror_addr = injector->dlerror_addr;
    arg->dlflags = RTLD_LAZY;
    if (injector->dlfunc_type == DLFUNC_INTERNAL) {
        arg->dlflags |= __RTLD_DLOPEN;
    }
    memcpy(arg->file_path, abspath, pathlen);

    rv = injector__write(injector, injector->data, data, injector->data_size);
    if (rv != 0) {
        return rv;
    }
    rv = injector__call_function(injector, &retval, injector->clone_addr,
                                 injector->shellcode, injector->stack + injector->stack_size - 4096,
                                 //CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID,
                                 CLONE_VM,
                                 injector->data);
    if (rv != 0) {
        return rv;
    }
    if (retval == -1) {
        injector__set_errmsg("clone error: %s", strerror(errno));
        return INJERR_ERROR_IN_TARGET;
    }
    const struct timespec ts = {0, 100000000}; /* 0.1 second */
    void *handle;
    int cnt = 0;

retry:
    nanosleep(&ts, NULL);
    rv = injector__read(injector, injector->data, &handle, sizeof(handle));
    if (rv != 0) {
        return rv;
    }
    if (handle == invalid_handle) {
        int max_retyr_cnt = 50;
        if (++cnt <= max_retyr_cnt) {
            goto retry;
        }
        injector__set_errmsg("dlopen doesn't return in %d seconds.", max_retyr_cnt / 10);
        return INJERR_ERROR_IN_TARGET;
    }
    if (handle_out != NULL) {
        *handle_out = handle;
    }
    if (handle == NULL) {
        arg->file_path[0] = '\0';
        injector__read(injector, injector->data, data, injector->data_size);
        if (arg->file_path[0] != '\0') {
            injector__set_errmsg("%s", arg->file_path);
        } else {
            injector__set_errmsg("dlopen error");
        }
        return INJERR_ERROR_IN_TARGET;
    }
    return 0;
}
#endif

int injector_remote_func_addr(injector_t *injector, void *handle, const char* name, size_t *func_addr_out)
{
    int rv;
    intptr_t retval;
    size_t len = strlen(name) + 1;

    injector__errmsg_is_set = 0;

    if (len > injector->data_size) {
        injector__set_errmsg("too long function name: %s", name);
        return INJERR_FUNCTION_MISSING;
    }
    rv = injector__write(injector, injector->data, name, len);
    if (rv != 0) {
        return rv;
    }
    rv = injector__call_function(injector, &retval, injector->dlsym_addr, handle, injector->data);
    if (rv != 0) {
        return rv;
    }
    if (retval == 0) {
        injector__set_errmsg("function not found: %s", name);
        return INJERR_FUNCTION_MISSING;
    }
    *func_addr_out = (size_t)retval;
    return 0;
}

int injector_remote_call(injector_t *injector, intptr_t *retval, size_t func_addr, ...)
{
    va_list ap;
    int rv;
    injector__errmsg_is_set = 0;
    va_start(ap, func_addr);
    rv = injector__call_function_va_list(injector, retval, func_addr, ap);
    va_end(ap);
    return rv;
}

int injector_remote_vcall(injector_t *injector, intptr_t *retval, size_t func_addr, va_list ap)
{
    injector__errmsg_is_set = 0;
    return injector__call_function_va_list(injector, retval, func_addr, ap);
}

int injector_call(injector_t *injector, void *handle, const char* name)
{
    size_t func_addr;
    int rv = injector_remote_func_addr(injector, handle, name, &func_addr);
    if (rv != 0) {
        return rv;
    }
    return injector__call_function(injector, NULL, func_addr);
}

int injector_uninject(injector_t *injector, void *handle)
{
    int rv;
    intptr_t retval;

    injector__errmsg_is_set = 0;
    if (injector->libc_type == LIBC_TYPE_MUSL) {
        /* Assume that libc is musl. */
        injector__set_errmsg("Cannot uninject libraries under musl libc. See: https://wiki.musl-libc.org/functional-differences-from-glibc.html#Unloading_libraries");
        return INJERR_UNSUPPORTED_TARGET;
    }

    rv = injector__call_function(injector, &retval, injector->dlclose_addr, handle);
    if (rv != 0) {
        return rv;
    }
    if (retval != 0) {
        injector__set_errmsg("dlclose failed");
        return INJERR_ERROR_IN_TARGET;
    }
    return 0;
}

int injector_detach(injector_t *injector)
{
    injector__errmsg_is_set = 0;

    if (injector->mmapped) {
        injector__call_syscall(injector, NULL, injector->sys_munmap, injector->data, remote_mem_size(injector));
    }
    if (injector->attached) {
        injector__detach_process(injector);
    }
    free(injector);
    return 0;
}

const char *injector_error(void)
{
    return injector__errmsg;
}

```

`src/w1nj3ct/backend/linux/injector.h`:

```h
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2018-2023 Kubo Takehiro <kubo@jiubao.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

/*!
 * \file injector.h
 * \brief Library for injecting a shared library into a Linux, Windows and macOS process
 */
#ifndef INJECTOR_H
#define INJECTOR_H

#if defined(_WIN32)
#include <windows.h>
typedef DWORD injector_pid_t;
#else
#include <sys/types.h>

/*!
 * \brief Platform-dependent process id type (\c pid_t on Unix. \c DWORD on Windows)
 */
typedef pid_t injector_pid_t;
#endif

#ifdef __cplusplus
extern "C" {
#endif
#if 0
}
#endif

#define INJERR_SUCCESS 0               /* linux, windows, macos */
#define INJERR_OTHER -1                /* linux, windows, macos */
#define INJERR_NO_MEMORY -2            /* linux, windows, macos */
#define INJERR_NO_PROCESS -3           /* linux, windows, macos */
#define INJERR_NO_LIBRARY -4           /* linux */
#define INJERR_NO_FUNCTION -4          /* linux */
#define INJERR_ERROR_IN_TARGET -5      /* linux, windows, macos */
#define INJERR_FILE_NOT_FOUND -6       /* linux, windows, macos */
#define INJERR_INVALID_MEMORY_AREA -7  /* linux, macos */
#define INJERR_PERMISSION -8           /* linux, windows, macos */
#define INJERR_UNSUPPORTED_TARGET -9   /* linux, windows, macos */
#define INJERR_INVALID_ELF_FORMAT -10  /* linux */
#define INJERR_WAIT_TRACEE -11         /* linux */
#define INJERR_FUNCTION_MISSING -12    /* linux, windows, macos */

typedef struct injector injector_t;

/*!
 * \brief Attach to the specified process.
 * \param[out]  injector the address where the newly created injector handle will be stored
 * \param[in]   pid      the process id to be attached
 * \return               zero on success. Otherwise, error code
 */
int injector_attach(injector_t **injector, injector_pid_t pid);

/*!
 * \brief Detach from the attached process and destroy the specified handle.
 * \param[in]   injector the injector handle to destroy
 * \return               zero on success. Otherwise, error code
 */
int injector_detach(injector_t *injector);

/*!
 * \brief Inject the specified shared library into the target process.
 * \param[in]   injector the injector handle specifying the target process
 * \param[in]   path     the path name of the shared library
 * \param[out]  handle   the address where the newly created module handle will be stored
 * \return               zero on success. Otherwise, error code
 *
 * Note on Linux:
 * This calls functions inside of the target process interrupted by \c ptrace().
 * If the target process is interrupted while holding a non-reentrant lock and
 * injector calls a function requiring the same lock, the process stops forever.
 * If the lock type is reentrant, the status guarded by the lock may become inconsistent.
 * As far as I checked, \c dlopen() internally calls \c malloc() requiring non-reentrant
 * locks. \c dlopen() also uses a reentrant lock to guard information about loaded files.
 */
int injector_inject(injector_t *injector, const char *path, void **handle);

/*!
 * \brief Uninject the shared library specified by \c handle.
 * \param[in]   injector the injector handle specifying the target process
 * \param[in]   handle   the module handle created by \c injector_inject
 * \return               zero on success. Otherwise, error code
 * \remarks This fearute isn't supported for musl-libc processes.
 *     See [Functional differences from glibc](https://wiki.musl-libc.org/functional-differences-from-glibc.html#Unloading_libraries).
 */
int injector_uninject(injector_t *injector, void *handle);

#if defined(INJECTOR_DOC) || defined(__linux__) || defined(__APPLE__)
/*!
 * \brief Call the specified function taking no arguments in the target process (Linux and macOS only)
 * \param[in]   injector the injector handle specifying the target process
 * \param[in]   handle   the module handle created by \c injector_inject or special-handles such as \c RTLD_DEFAULT
 * \param[in]   name     the function name
 *
 * The \c handle and \c name arguments are passed to \c dlsym ([Linux](https://man7.org/linux/man-pages/man3/dlvsym.3.html), [macOS](https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dlsym.3.html)) and then the return value of \c dlsym is called without arguments in the target process.
 *
 * This is same with the combination of injector_remote_func_addr() and injector_remote_call() without extra arguments.
 *
 * \note
 *   (Linux only)
 *   If the function in the target process internally calls non-[async-signal-safe]((https://man7.org/linux/man-pages/man7/signal-safety.7.html))
 *   functions, it may stop the target process or cause unexpected behaviour.
 * \sa injector_remote_func_addr(), injector_remote_call(), injector_remote_vcall()
 */
int injector_call(injector_t *injector, void *handle, const char* name);
#endif

/*!
 * \brief Get the message of the last error.
 * \remarks The message is updated only when \c injector functions return non-zero.
 */
const char *injector_error(void);

#if defined(INJECTOR_DOC) || defined(__linux__) || defined(_WIN32)
#define INJECTOR_HAS_REMOTE_CALL_FUNCS 1
#include <stdarg.h>
#include <stdint.h>

/*!
 * \brief Get the function address in the target process (Linux and Windows only)
 * \param[in]   injector      the injector handle specifying the target process
 * \param[in]   handle        the module handle created by \c injector_inject or special-handles such as \c RTLD_DEFAULT
 * \param[in]   name          the function name
 * \param[out]  func_addr_out the address where the function address in the target process will be stored
 * \return                    zero on success. Otherwise, error code
 *
 * \b Example
 *
 * Inject libfoo.so and then call foo_func(1, 2, 3) in it.
 * \code
 * void *handle;
 * // inject libfoo.so and get the handle
 * if (injector_inject(injector, "libfoo.so", &handle) != 0) {
 *    return;
 * }
 * size_t func_addr;
 * // get the address of foo_func in the handle
 * if (injector_remote_func_addr(injector, handle, "foo_func", &func_addr) != 0) {
 *    return;
 * }
 * intptr_t retval;
 * // call foo_func
 * if (injector_remote_call(injector, &retval, func_addr, 1, 2, 3) != 0) {
 *    return;
 * }
 * printf("The return value of foo_func(1, 2, 3) is %ld.\n", retval);
 * \endcode
 */
int injector_remote_func_addr(injector_t *injector, void *handle, const char* name, size_t *func_addr_out);

/*!
 * \brief Call the function in the target process (Linux and Windows only)
 * \param[in]   injector  the injector handle specifying the target process
 * \param[out]  retval    \c NULL or the address where the return value of the function call will be stored
 * \param[in]   func_addr the function address in the target process
 * \param[in]   ...       arguments passed to the function
 * \return                zero on success. Otherwise, error code
 * \remarks
 *   The types of the arguments must be integer or pointer.
 *   If it is a pointer, it must point to a valid address in the target process.
 *   The number of arguments must be less than or equal to six.
 * \note
 *   If the function in the target process internally calls non-[async-signal-safe]((https://man7.org/linux/man-pages/man7/signal-safety.7.html))
 *   functions, it may stop the target process or cause unexpected behaviour.
 * \sa injector_remote_func_addr(), injector_remote_vcall()
 */
int injector_remote_call(injector_t *injector, intptr_t *retval, size_t func_addr, ...);

/*!
 * \brief Call the function in the target process (Linux and Windows only)
 * \param[in]   injector  the injector handle specifying the target process
 * \param[out]  retval    \c NULL or the address where the return value of the function call will be stored
 * \param[in]   func_addr the function address in the target process
 * \param[in]   ap        arguments passed to the function
 * \return                zero on success. Otherwise, error code
 * \remarks
 *   The types of the arguments must be integer or pointer.
 *   If it is a pointer, it must point to a valid address in the target process.
 *   The number of arguments must be less than or equal to six.
 * \note
 *   If the function in the target process internally calls non-[async-signal-safe]((https://man7.org/linux/man-pages/man7/signal-safety.7.html))
 *   functions, it may stop the target process or cause unexpected behaviour.
 * \sa injector_remote_func_addr(), injector_remote_call()
 */
int injector_remote_vcall(injector_t *injector, intptr_t *retval, size_t func_addr, va_list ap);
#endif

#if defined(INJECTOR_DOC) || defined(_WIN32)
/*!
 * \brief Same with \c injector_inject except the type of the \c path argument. (Windows only)
 * \param[in]   injector the injector handle specifying the target process
 * \param[in]   path     the path name of the shared library
 * \param[out]  handle   the address where the newly created module handle will be stored
 * \return               zero on success. Otherwise, error code
 */
int injector_inject_w(injector_t *injector, const wchar_t *path, void **handle);
#endif

#if defined(INJECTOR_DOC) || (defined(__linux__) && defined(__x86_64__))
#define INJECTOR_HAS_INJECT_IN_CLONED_THREAD 1 // feature test macro
/*!
 * \brief Inject the specified shared library into the target process by the \c clone system call. (Linux x86_64 only)
 * \param[in]   injector the injector handle specifying the target process
 * \param[in]   path     the path name of the shared library
 * \param[out]  handle   the address where the newly created module handle will be stored
 * \return               zero on success. Otherwise, error code
 *
 * This calls `dlopen()` in a thread created by \c [clone()](https://man7.org/linux/man-pages/man2/clone.2.html). Note that no wonder there are unexpected
 * pitfalls because some resources allocated in \c [pthread_create()](https://man7.org/linux/man-pages/man3/pthread_create.3.html) lack in the \c clone()-ed thread.
 * Use it at your own risk.
 */
int injector_inject_in_cloned_thread(injector_t *injector, const char *path, void **handle);
#endif

#if 0
{
#endif
#ifdef __cplusplus
}; /* extern "C" */
#endif

#endif

```

`src/w1nj3ct/backend/linux/injector_internal.h`:

```h
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2018-2023 Kubo Takehiro <kubo@jiubao.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#ifndef INJECTOR_INTERNAL_H
#define INJECTOR_INTERNAL_H 1
#include <stdarg.h>
#include <stdint.h>
#include <string.h>
#include <sys/types.h>
#include <sys/user.h>
#include <sys/ptrace.h>
#include <errno.h>
#include "injector.h"

#ifdef __LP64__
#define SIZE_T_FMT "l"
#else
#define SIZE_T_FMT ""
#endif

#ifdef __arm__
#define user_regs_struct user_regs
#endif

#ifdef __mips__
#include <asm/ptrace.h>
#define user_regs_struct pt_regs
#endif

#ifdef __powerpc__
#include <asm/ptrace.h>
#define user_regs_struct pt_regs
#endif

#ifdef __riscv
#include <asm/ptrace.h>
#endif

#define PTRACE_OR_RETURN(request, injector, addr, data) do { \
    int rv = injector__ptrace(request, injector->pid, addr, data, #request); \
    if (rv != 0) { \
        return rv; \
    } \
} while (0)

typedef enum {
    /* use dlopen/dlsym/dlclose (glibc 2.34 or later) */
    DLFUNC_POSIX,
    /* use __libc_dlopen_mode/__libc_dlsym/__libc_dlclose" (glibc 2.33 or earlier) */
    DLFUNC_INTERNAL,
} dlfunc_type_t;

typedef enum {
    LIBC_TYPE_UNKNOWN = 0,
    LIBC_TYPE_GNU,
    LIBC_TYPE_MUSL,
} libc_type_t;

typedef enum {
    ARCH_X86_64,
    ARCH_X86_64_X32,
    ARCH_I386,
    ARCH_ARM64,
    ARCH_ARM_EABI_THUMB,
    ARCH_ARM_EABI,
    ARCH_MIPS_64,
    ARCH_MIPS_N32,
    ARCH_MIPS_O32,
    ARCH_POWERPC_64,
    ARCH_POWERPC,
    ARCH_RISCV_64,
    ARCH_RISCV_32,
} arch_t;

typedef union {
#if defined(__x86_64__) || defined(__i386__)
    uint8_t u8[sizeof(long)];
#elif defined(__aarch64__) || defined(__arm__)
    uint16_t u16[4];
    uint32_t u32[2];
#elif defined(__mips__)
    uint32_t u32[4];
#elif defined(__powerpc__)
    uint32_t u32[2];
#elif defined(__riscv)
    uint32_t u32[2];
#endif
    long dummy;
} code_t;

struct injector {
    pid_t pid;
    uint8_t attached;
    uint8_t mmapped;
    arch_t arch;
    libc_type_t libc_type;
    struct user_regs_struct regs;
    dlfunc_type_t dlfunc_type;
    size_t dlopen_addr;
    size_t dlclose_addr;
    size_t dlsym_addr;
    size_t dlerror_addr;
#ifdef INJECTOR_HAS_INJECT_IN_CLONED_THREAD
    size_t clone_addr;
#endif
    size_t code_addr; /* address where instructions are written */
    code_t backup_code;
    long sys_mmap;
    long sys_mprotect;
    long sys_munmap;

    /* memory layout allocated in the target process
     *
     *  high +----------------------+
     *       |     stack area       |
     *       |      size: 2MB       |
     *       |----------------------|
     *       |  inaccessible area   |
     *       |      size: 4096      |
     *       |----------------------|
     *       |      data area       |
     *       |      size: 4096      |
     *  low  +----------------------+
     */
    size_t data; /* read-write region */
    size_t data_size; /* page size */
    size_t stack; /* stack area */
    size_t stack_size; /* 2MB */
#ifdef INJECTOR_HAS_INJECT_IN_CLONED_THREAD
    size_t shellcode;
#endif
};

/* elf.c */
int injector__collect_libc_information(injector_t *injector);

/* ptrace.c */
int injector__ptrace(int request, pid_t pid, long addr, long data, const char *request_name);
int injector__attach_process(const injector_t *injector);
int injector__detach_process(const injector_t *injector);
int injector__get_regs(const injector_t *injector, struct user_regs_struct *regs);
int injector__set_regs(const injector_t *injector, const struct user_regs_struct *regs);
int injector__read(const injector_t *injector, size_t addr, void *buf, size_t len);
int injector__write(const injector_t *injector, size_t addr, const void *buf, size_t len);
int injector__continue(const injector_t *injector);

/* remote_call.c - call functions and syscalls in the target process */
int injector__call_syscall(const injector_t *injector, intptr_t *retval, long syscall_number, ...);
int injector__call_function(const injector_t *injector, intptr_t *retval, long function_addr, ...);
int injector__call_function_va_list(const injector_t *injector, intptr_t *retval, long function_addr, va_list ap);

/* util.c */
extern char injector__errmsg[];
extern char injector__errmsg_is_set;
void injector__set_errmsg(const char *format, ...) __attribute__((format (printf, 1, 2)));
const char *injector__arch2name(arch_t arch);

/* shellcode.S */
#ifdef INJECTOR_HAS_INJECT_IN_CLONED_THREAD
typedef struct {
    void *handle;
    size_t dlopen_addr;
    size_t dlerror_addr;
    int dlflags;
    char file_path[0]; // dummy size.
} injector_shellcode_arg_t;

void *injector_shellcode(injector_shellcode_arg_t *arg);
extern int injector_shellcode_size;
#endif

#endif

```

`src/w1nj3ct/backend/linux/ptrace.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2018 Kubo Takehiro <kubo@jiubao.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include "injector_internal.h"

#if defined(__aarch64__) || defined(__riscv)
#define USE_REGSET
#include <elf.h> /* for NT_PRSTATUS */
#include <sys/uio.h> /* for struct iovec */
#endif

static int set_ptrace_error(const char *request_name)
{
    int err = errno;
    injector__set_errmsg("%s error : %s", request_name, strerror(errno));
    switch (err) {
    case EFAULT:
        return INJERR_INVALID_MEMORY_AREA;
    case EPERM:
        return INJERR_PERMISSION;
    case ESRCH:
        return INJERR_NO_PROCESS;
    }
    return INJERR_OTHER;
}

int injector__ptrace(int request, pid_t pid, long addr, long data, const char *request_name)
{
    if (ptrace(request, pid, addr, data) != 0) {
        return set_ptrace_error(request_name);
    }
    return 0;
}

int injector__attach_process(const injector_t *injector)
{
    PTRACE_OR_RETURN(PTRACE_ATTACH, injector, 0, 0);
    return 0;
}

int injector__detach_process(const injector_t *injector)
{
    PTRACE_OR_RETURN(PTRACE_DETACH, injector, 0, 0);
    return 0;
}

int injector__get_regs(const injector_t *injector, struct user_regs_struct *regs)
{
#ifdef USE_REGSET
    struct iovec iovec = { regs, sizeof(*regs) };
    PTRACE_OR_RETURN(PTRACE_GETREGSET, injector, NT_PRSTATUS, (long)&iovec);
#else
    PTRACE_OR_RETURN(PTRACE_GETREGS, injector, 0, (long)regs);
#endif
    return 0;
}

int injector__set_regs(const injector_t *injector, const struct user_regs_struct *regs)
{
#ifdef USE_REGSET
    struct iovec iovec = { (void*)regs, sizeof(*regs) };
    PTRACE_OR_RETURN(PTRACE_SETREGSET, injector, NT_PRSTATUS, (long)&iovec);
#else
    PTRACE_OR_RETURN(PTRACE_SETREGS, injector, 0, (long)regs);
#endif
    return 0;
}

int injector__read(const injector_t *injector, size_t addr, void *buf, size_t len)
{
    pid_t pid = injector->pid;
    long word;
    char *dest = (char *)buf;

    errno = 0;
    while (len >= sizeof(long)) {
        word = ptrace(PTRACE_PEEKTEXT, pid, addr, 0);
        if (word == -1 && errno != 0) {
            return set_ptrace_error("PTRACE_PEEKTEXT");
        }
        *(long*)dest = word;
        addr += sizeof(long);
        dest += sizeof(long);
        len -= sizeof(long);
    }
    if (len != 0) {
        char *src = (char *)&word;
        word = ptrace(PTRACE_PEEKTEXT, pid, addr, 0);
        if (word == -1 && errno != 0) {
            return set_ptrace_error("PTRACE_PEEKTEXT");
        }
        while (len--) {
            *(dest++) = *(src++);
        }
    }
    return 0;
}

int injector__write(const injector_t *injector, size_t addr, const void *buf, size_t len)
{
    pid_t pid = injector->pid;
    const char *src = (const char *)buf;

    while (len >= sizeof(long)) {
        PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, addr, *(long*)src);
        addr += sizeof(long);
        src += sizeof(long);
        len -= sizeof(long);
    }
    if (len != 0) {
        long word = ptrace(PTRACE_PEEKTEXT, pid, addr, 0);
        char *dest = (char*)&word;
        if (word == -1 && errno != 0) {
            return set_ptrace_error("PTRACE_PEEKTEXT");
        }
        while (len--) {
            *(dest++) = *(src++);
        }
        PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, addr, word);
    }
    return 0;
}

int injector__continue(const injector_t *injector)
{
    PTRACE_OR_RETURN(PTRACE_CONT, injector, 0, 0);
    return 0;
}

```

`src/w1nj3ct/backend/linux/remote_call.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2018-2023 Kubo Takehiro <kubo@jiubao.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#if defined __linux__
/* Detect musl libc. See https://stackoverflow.com/a/70211227/985524  */
#define _GNU_SOURCE
#include <features.h>
#ifndef __USE_GNU
#define MUSL_LIBC
#endif // __USE_GNU
#endif // __linux__

#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <inttypes.h>
#include "injector_internal.h"

// #define INJECTOR_DEBUG_REMOTE_CALL 1

#ifdef INJECTOR_DEBUG_REMOTE_CALL
#undef DEBUG
#define DEBUG(...) fprintf(stderr, __VA_ARGS__)
#else
#undef DEBUG
#define DEBUG(...) do {} while(0)
#endif

#ifdef __x86_64__
#define eip rip
#define ebp rbp
#define esp rsp
#define eax rax
#define ebx rbx
#define ecx rcx
#define edx rdx
#define esi rsi
#define edi rdi
#define ebp rbp
#endif

#if defined(__arm__)
#define reg32_return reg_return
#define uregs regs.uregs
#endif

#define THUMB_MODE_BIT (1u << 5)
#define BREAKINST_THUMB 0xde01 /* in linux-source-tree/arch/arm/kernel/ptrace.c */
#define BREAKINST_ARM 0xe7f001f0 /* in linux-source-tree/arch/arm/kernel/ptrace.c */
#define BREAKINST_ARM64 0xd4200000 /* asm("brk #0") */

#ifdef __mips__
#define REG_V0 2
#define REG_A0 4
#define REG_A1 5
#define REG_A2 6
#define REG_A3 7
#define REG_A4 8
#define REG_A5 9
#define REG_T4 12
#define REG_T9 25
#define REG_SP 29
#define REG_FP 30
#define REG_RA 31

static void print_regs(const injector_t *injector, const struct pt_regs *regs)
{
    DEBUG("  Registers:\n");
    DEBUG("    -- at v0 v1: %016"PRIx64" %016"PRIx64" %016"PRIx64" %016"PRIx64"\n",
          regs->regs[0], regs->regs[1], regs->regs[2], regs->regs[3]);
    DEBUG("    a0 a1 a2 a3: %016"PRIx64" %016"PRIx64" %016"PRIx64" %016"PRIx64"\n",
          regs->regs[4], regs->regs[5], regs->regs[6], regs->regs[7]);
    DEBUG("    %s: %016"PRIx64" %016"PRIx64" %016"PRIx64" %016"PRIx64"\n",
          (injector->arch != ARCH_MIPS_O32) ? "a4 a5 a6 a7" : "t0 t1 t2 t3",
          regs->regs[8], regs->regs[9], regs->regs[10], regs->regs[11]);
    DEBUG("    t4 t5 t6 t7: %016"PRIx64" %016"PRIx64" %016"PRIx64" %016"PRIx64"\n",
          regs->regs[12], regs->regs[13], regs->regs[14], regs->regs[15]);
    DEBUG("    s0 s1 s2 s3: %016"PRIx64" %016"PRIx64" %016"PRIx64" %016"PRIx64"\n",
          regs->regs[16], regs->regs[17], regs->regs[18], regs->regs[19]);
    DEBUG("    s4 s5 s6 s7: %016"PRIx64" %016"PRIx64" %016"PRIx64" %016"PRIx64"\n",
          regs->regs[20], regs->regs[21], regs->regs[22], regs->regs[23]);
    DEBUG("    t8 t9 k0 k1: %016"PRIx64" %016"PRIx64" %016"PRIx64" %016"PRIx64"\n",
          regs->regs[24], regs->regs[25], regs->regs[26], regs->regs[27]);
    DEBUG("    gp sp s8 ra: %016"PRIx64" %016"PRIx64" %016"PRIx64" %016"PRIx64"\n",
          regs->regs[28], regs->regs[29], regs->regs[30], regs->regs[31]);
    DEBUG("    lo hi epc:                    %016"PRIx64" %016"PRIx64" %016"PRIx64"\n",
          regs->lo, regs->hi, regs->cp0_epc);
    DEBUG("    badvaddr status cause:        %016"PRIx64" %016"PRIx64" %016"PRIx64"\n",
          regs->cp0_badvaddr, regs->cp0_status, regs->cp0_cause);
}
#define PRINT_REGS(injector, regs) print_regs((injector), (regs))
#endif /* __mips__ */


#ifdef __powerpc__
static void print_regs(const injector_t *injector, const struct pt_regs *regs)
{
#undef WIDTH
#ifdef __LP64__
#define WIDTH "016"
#define softe_or_mq_str "softe"
#define softe_or_mq softe
#else
#define WIDTH "08"
#define softe_or_mq_str "mq   "
#define softe_or_mq mq
#endif
    DEBUG("  Registers:\n");
    DEBUG("    gpr0  gpr1  gpr2   gpr3   : %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx\n",
          regs->gpr[0], regs->gpr[1], regs->gpr[2], regs->gpr[3]);
    DEBUG("    gpr4  gpr5  gpr6   gpr7   : %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx\n",
          regs->gpr[4], regs->gpr[5], regs->gpr[6], regs->gpr[7]);
    DEBUG("    gpr8  gpr9  gpr10  gpr11  : %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx\n",
          regs->gpr[8], regs->gpr[9], regs->gpr[10], regs->gpr[11]);
    DEBUG("    gpr12 gpr13 gpr14  gpr15  : %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx\n",
          regs->gpr[12], regs->gpr[13], regs->gpr[14], regs->gpr[15]);
    DEBUG("    gpr16 gpr17 gpr18  gpr19  : %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx\n",
          regs->gpr[16], regs->gpr[17], regs->gpr[18], regs->gpr[19]);
    DEBUG("    gpr20 gpr21 gpr22  gpr23  : %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx\n",
          regs->gpr[20], regs->gpr[21], regs->gpr[22], regs->gpr[23]);
    DEBUG("    gpr24 gpr25 gpr26  gpr27  : %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx\n",
          regs->gpr[24], regs->gpr[25], regs->gpr[26], regs->gpr[27]);
    DEBUG("    gpr28 gpr29 gpr30  gpr31  : %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx\n",
          regs->gpr[28], regs->gpr[29], regs->gpr[30], regs->gpr[31]);
    DEBUG("    nip   msr   orig_gpr3 ctr : %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx\n",
          regs->nip, regs->msr, regs->orig_gpr3, regs->ctr);
    DEBUG("    link  xer   ccr    "softe_or_mq_str"  : %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx\n",
          regs->link, regs->xer, regs->ccr, regs->softe_or_mq);
    DEBUG("    trap  dar   dsisr  result : %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx\n",
          regs->trap, regs->dar, regs->dsisr, regs->result);
#undef WIDTH
}
#define PRINT_REGS(injector, regs) print_regs((injector), (regs))
#endif

#ifdef __riscv
#define REG_RA 1
#define REG_T1 6
#ifdef __LP64__
#define WIDTH "016"
#else
#define WIDTH "08"
#endif
static void print_regs(const injector_t *injector, const struct user_regs_struct *regs)
{
    DEBUG("  Registers:\n");
    DEBUG("    pc  ra  sp  gp  : %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx\n",
          regs->pc, regs->ra, regs->sp, regs->gp);
    DEBUG("    tp  t0  t1  t2  : %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx\n",
          regs->tp, regs->t0, regs->t1, regs->t2);
    DEBUG("    s0  s1  a0  a1  : %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx\n",
          regs->s0, regs->s1, regs->a0, regs->a1);
    DEBUG("    a2  a3  a4  a5  : %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx\n",
          regs->a2, regs->a3, regs->a4, regs->a5);
    DEBUG("    a6  a7  s2  s3  : %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx\n",
          regs->a6, regs->a7, regs->s2, regs->s3);
    DEBUG("    s4  s5  s6  s7  : %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx\n",
          regs->s4, regs->s5, regs->s6, regs->s7);
    DEBUG("    s8  s9  s10 s11 : %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx\n",
          regs->s8, regs->s9, regs->s10, regs->s11);
    DEBUG("    t3  t4  t5  t6  : %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx %"WIDTH"lx\n",
          regs->t3, regs->t4, regs->t5, regs->t6);
}
#define PRINT_REGS(injector, regs) print_regs((injector), (regs))
#endif

/* register type used in struct user_regs_struct */
#if defined(__mips__)
typedef uint64_t user_reg_t;
#elif defined(__riscv)
typedef unsigned long user_reg_t;
#elif defined(__LP64__) && !defined(MUSL_LIBC)
typedef unsigned long long user_reg_t;
#elif defined(__i386__)
typedef long user_reg_t;
#else
typedef unsigned long user_reg_t;
#endif

static int kick_then_wait_sigtrap(const injector_t *injector, struct user_regs_struct *regs, code_t *code, size_t code_size);

#ifndef PRINT_REGS
#define PRINT_REGS(injector, regs) do {} while (0)
#endif

/*
 * Call the specified system call in the target process.
 *
 * The arguments after syscall_number must be integer types and
 * the size must not be greater than the size of long.
 */
int injector__call_syscall(const injector_t *injector, intptr_t *retval, long syscall_number, ...)
{
    struct user_regs_struct regs = injector->regs;
    code_t code;
    size_t code_size;
    long arg1, arg2, arg3, arg4, arg5, arg6;
    va_list ap;
    int rv;
#if !defined(__mips__) && !defined(__powerpc__)
    user_reg_t *reg_return = NULL;
#if defined(__aarch64__)
    uint32_t *reg32_return = NULL;
    uint32_t *uregs = (uint32_t *)&regs;
#endif
#endif

    va_start(ap, syscall_number);
    arg1 = va_arg(ap, long);
    arg2 = va_arg(ap, long);
    arg3 = va_arg(ap, long);
    arg4 = va_arg(ap, long);
    arg5 = va_arg(ap, long);
    arg6 = va_arg(ap, long);
    va_end(ap);

    DEBUG("injector__call_syscall:\n");
    DEBUG("  args: %ld, %lx, %lx, %lx, %lx, %lx, %lx\n", syscall_number, arg1, arg2, arg3, arg4, arg5, arg6);

#if !(defined(__x86_64__) && defined(__LP64__))
    if (injector->arch == ARCH_X86_64_X32) {
        injector__set_errmsg("x32-ABI target process is supported only by x86_64.");
        return INJERR_UNSUPPORTED_TARGET;
    }
#endif

    switch (injector->arch) {
#if defined(__x86_64__) && defined(__LP64__)
    case ARCH_X86_64:
    case ARCH_X86_64_X32:
        /* setup instructions */
        code.u8[0] = 0x0f;
        code.u8[1] = 0x05; /* 0f 05 : syscall */
        code.u8[2] = 0xcc; /* cc    : int3    */
        memset(&code.u8[3], 0x90, sizeof(long) - 3); /* fill the rests with `nop` */
        code_size = sizeof(long);
        /* setup registers */
        regs.rip = injector->code_addr;
        regs.rax = syscall_number;
        regs.rdi = arg1;
        regs.rsi = arg2;
        regs.rdx = arg3;
        regs.r10 = arg4;
        regs.r8 = arg5;
        regs.r9 = arg6;
        reg_return = &regs.rax;
        break;
#endif
#if defined(__x86_64__) || defined(__i386__)
    case ARCH_I386:
        /* setup instructions */
        code.u8[0] = 0xcd;
        code.u8[1] = 0x80; /* cd 80 : int $80 */
        code.u8[2] = 0xcc; /* cc    : int3    */
        memset(&code.u8[3], 0x90, sizeof(long) - 3); /* fill the rests with `nop` */
        code_size = sizeof(long);
        /* setup registers */
        regs.eip = injector->code_addr;
        regs.eax = syscall_number;
        regs.ebx = arg1;
        regs.ecx = arg2;
        regs.edx = arg3;
        regs.esi = arg4;
        regs.edi = arg5;
        regs.ebp = arg6;
        reg_return = &regs.eax;
        break;
#endif
#if defined(__aarch64__)
    case ARCH_ARM64:
        /* setup instructions */
        code.u32[0] = 0xd4000001; /* svc #0 */
        code.u32[1] = BREAKINST_ARM64;
        code_size = 2 * 4;
        /* setup registers */
        regs.pc = injector->code_addr;
        regs.regs[8] = syscall_number;
        regs.regs[0] = arg1;
        regs.regs[1] = arg2;
        regs.regs[2] = arg3;
        regs.regs[3] = arg4;
        regs.regs[4] = arg5;
        regs.regs[5] = arg6;
        reg_return = &regs.regs[0];
        break;
#endif
#if defined(__aarch64__) || defined(__arm__)
    case ARCH_ARM_EABI_THUMB:
        /* setup instructions */
        code.u16[0] = 0xdf00; /* svc #0 */
        code.u16[1] = BREAKINST_THUMB;
#ifdef __LP64__
        code.u16[2] = 0x46c0; /* nop (mov r8, r8) */
        code.u16[3] = 0x46c0; /* nop (mov r8, r8) */
#endif
        code_size = sizeof(long);
        /* setup registers */
        uregs[16] |= THUMB_MODE_BIT;
        uregs[15] = injector->code_addr;
        uregs[7] = syscall_number;
        uregs[0] = arg1;
        uregs[1] = arg2;
        uregs[2] = arg3;
        uregs[3] = arg4;
        uregs[4] = arg5;
        uregs[5] = arg6;
        reg32_return = &uregs[0];
        break;
    case ARCH_ARM_EABI:
        /* setup instructions */
        code.u32[0] = 0xef000000; /* svc #0 */
        code.u32[1] = BREAKINST_ARM;
        code_size = 2 * 4;
        /* setup registers */
        uregs[16] &= ~THUMB_MODE_BIT;
        uregs[15] = injector->code_addr;
        uregs[7] = syscall_number;
        uregs[0] = arg1;
        uregs[1] = arg2;
        uregs[2] = arg3;
        uregs[3] = arg4;
        uregs[4] = arg5;
        uregs[5] = arg6;
        reg32_return = &uregs[0];
        break;
#endif
#if defined(__mips__)
    case ARCH_MIPS_64:
    case ARCH_MIPS_N32:
    case ARCH_MIPS_O32:
        /* setup instructions */
        if (syscall_number > 0xffff) {
            injector__set_errmsg("too large system call number: %d", syscall_number);
            return INJERR_OTHER;
        }
        code.u32[0] = 0x00000025 | (REG_A3 << 11) | (REG_T4 << 21); /* or $a3, $t4, $zero; move $a3, $t4 */
        code.u32[1] = 0x24000000 | (REG_V0 << 16) | syscall_number; /* addiu $v0, $zero, syscall_number */
        code.u32[2] = 0x0000000c; /* syscall */
        code.u32[3] = 0x0000000d; /* break */
        code_size = 4 * 4;
        DEBUG("  Code: %08"PRIx32" %08"PRIx32" %08"PRIx32" %08"PRIx32"\n",
              code.u32[0], code.u32[1], code.u32[2], code.u32[3]);
        /* setup registers */
        regs.cp0_epc  = injector->code_addr;
        regs.regs[REG_A0] = arg1;
        regs.regs[REG_A1] = arg2;
        regs.regs[REG_A2] = arg3;
        // Use the combination of "regs.regs[REG_T4] = arg4" and "move $a3, $t4"
        // instead of "regs.regs[REG_A3] = arg4". I don't know why the latter
        // doesn't work.
        regs.regs[REG_T4] = arg4;
        if (injector->arch != ARCH_MIPS_O32) {
            /* ARCH_MIPS_64 or ARCH_MIPS_N32 */
            regs.regs[REG_A4] = arg5;
            regs.regs[REG_A5] = arg6;
        } else {
            /* ARCH_MIPS_O32 */
            regs.regs[REG_SP] -= 32;
            PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, regs.regs[REG_SP] + 16, arg5);
            PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, regs.regs[REG_SP] + 20, arg6);
        }
        break;
#endif
#if defined(__powerpc__)
#ifdef __LP64__
    case ARCH_POWERPC_64:
#endif
    case ARCH_POWERPC:
        /* setup instructions */
        code.u32[0] = 0x44000002; /* sc */
        code.u32[1] = 0x7fe00008; /* trap */
        code_size = 2 * 4;
        /* setup registers */
        regs.nip = injector->code_addr;
        regs.gpr[PT_R0] = syscall_number;
        regs.gpr[PT_R3] = arg1;
        regs.gpr[PT_R4] = arg2;
        regs.gpr[PT_R5] = arg3;
        regs.gpr[PT_R6] = arg4;
        regs.gpr[PT_R7] = arg5;
        regs.gpr[PT_R8] = arg6;
        break;
#endif
#if defined(__riscv)
#ifdef __LP64__
    case ARCH_RISCV_64:
#endif
    case ARCH_RISCV_32:
        /* setup instructions */
        code.u32[0] = 0x00000073; /* ecall */
        code.u32[1] = 0x00100073; /* ebreak */
        code_size = 2 * 4;
        DEBUG("  Code: %08"PRIx32" %08"PRIx32"\n",
              code.u32[0], code.u32[1]);
        /* setup registers */
        regs.pc  = injector->code_addr;
        regs.a0 = arg1;
        regs.a1 = arg2;
        regs.a2 = arg3;
        regs.a3 = arg4;
        regs.a4 = arg5;
        regs.a5 = arg6;
        regs.a7 = syscall_number;
        reg_return = &regs.a0;
        break;
#endif
    default:
        injector__set_errmsg("Unexpected architecture: %s", injector__arch2name(injector->arch));
        return INJERR_UNSUPPORTED_TARGET;
    }

    PRINT_REGS(injector, &regs);
    rv = kick_then_wait_sigtrap(injector, &regs, &code, code_size);
    if (rv != 0) {
        return rv;
    }
    PRINT_REGS(injector, &regs);

    if (retval != NULL) {
#if defined(__mips__)
        if (regs.regs[REG_A3] == 0) {
            *retval = (intptr_t)regs.regs[REG_V0];
        } else {
            errno = (int)regs.regs[REG_V0];
            *retval = -1;
        }
#elif defined(__powerpc__)
        /* https://github.com/strace/strace/blob/v5.19/src/linux/powerpc/get_error.c#L21-L26 */
        if (regs.ccr & 0x10000000) {
            errno = (int)regs.gpr[PT_R3];
            *retval = -1;
        } else {
            *retval = (intptr_t)regs.gpr[PT_R3];
        }
#else
#if defined(__aarch64__)
        if (reg32_return != NULL) {
            if (*reg32_return <= -4096u) {
                *retval = (intptr_t)*reg32_return;
            } else {
                errno = -((int)*reg32_return);
                *retval = -1;
            }
        } else {
#endif
            if ((unsigned long)*reg_return <= -4096ul) {
                *retval = (intptr_t)*reg_return;
            } else {
                errno = -((int)*reg_return);
                *retval = -1;
            }
#if defined(__aarch64__)
        }
#endif
#endif /* defined(__mips__) */
    }
    return 0;
}

/*
 * Call the function at the specified address in the target process.
 *
 * The arguments after function_addr must be integer types and
 * the size must not be greater than the size of long.
 */
int injector__call_function(const injector_t *injector, intptr_t *retval, long function_addr, ...)
{
    va_list ap;
    int rv;
    va_start(ap, function_addr);
    rv = injector__call_function_va_list(injector, retval, function_addr, ap);
    va_end(ap);
    return rv;
}

/*
 * Call the function at the specified address in the target process.
 *
 * The arguments after function_addr must be integer types and
 * the size must not be greater than the size of long.
 */
int injector__call_function_va_list(const injector_t *injector, intptr_t *retval, long function_addr, va_list ap)
{
    struct user_regs_struct regs = injector->regs;
    code_t code;
    size_t code_size;
    long arg1, arg2, arg3, arg4, arg5, arg6;
    int rv;
    user_reg_t *reg_return = NULL;
#if defined(__aarch64__)
    uint32_t *reg32_return = NULL;
    uint32_t *uregs = (uint32_t *)&regs;
#endif

    arg1 = va_arg(ap, long);
    arg2 = va_arg(ap, long);
    arg3 = va_arg(ap, long);
    arg4 = va_arg(ap, long);
    arg5 = va_arg(ap, long);
    arg6 = va_arg(ap, long);

    DEBUG("injector__call_function:\n");
    DEBUG("  args: %lx, %lx, %lx, %lx, %lx, %lx, %lx\n", function_addr, arg1, arg2, arg3, arg4, arg5, arg6);

    switch (injector->arch) {
#if defined(__x86_64__) && defined(__LP64__)
    case ARCH_X86_64:
    case ARCH_X86_64_X32:
        /* setup instructions */
        code.u8[0] = 0xff;
        code.u8[1] = 0xd0; /* ff d0 : callq *%rax */
        code.u8[2] = 0xcc; /* cc    : int3        */
        memset(&code.u8[3], 0x90, sizeof(long) - 3); /* fill the rests with `nop` */
        code_size = sizeof(long);
        /* setup registers */
        regs.rip = injector->code_addr;
        regs.rbp = injector->stack + injector->stack_size - 16;
        /* rsp must be aligned to a 16-byte boundary. */
        regs.rsp = injector->stack + injector->stack_size - (2 * 16);
        regs.rax = function_addr;
        regs.rdi = arg1;
        regs.rsi = arg2;
        regs.rdx = arg3;
        regs.rcx = arg4;
        regs.r8 = arg5;
        regs.r9 = arg6;
        reg_return = &regs.rax;
        break;
#endif
#if defined(__x86_64__) || defined(__i386__)
    case ARCH_I386:
        /* setup instructions */
        code.u8[0] = 0xff;
        code.u8[1] = 0xd0; /* ff d0 : call *%eax */
        code.u8[2] = 0xcc; /* cc    : int3       */
        memset(&code.u8[3], 0x90, sizeof(long) - 3); /* fill the rests with `nop` */
        code_size = sizeof(long);
        /* setup registers */
        regs.eip = injector->code_addr;
        regs.ebp = injector->stack + injector->stack_size - 16;
        /* esp should be at 16-byte boundary after call instruction.*/
        regs.esp = injector->stack + injector->stack_size - (3 * 16) + 4;
        regs.eax = function_addr;
        PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, regs.esp + 0, arg1);
        PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, regs.esp + 4, arg2);
        PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, regs.esp + 8, arg3);
        PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, regs.esp + 12, arg4);
        PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, regs.esp + 16, arg5);
        PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, regs.esp + 20, arg6);
        reg_return = &regs.eax;
        break;
#endif
#if defined(__aarch64__)
    case ARCH_ARM64:
        /* setup instructions */
        code.u32[0] = 0xd63f00c0; /* blr x6 */
        code.u32[1] = BREAKINST_ARM64;
        code_size = 2 * 4;
        /* setup registers */
        regs.pc = injector->code_addr;
        regs.sp = injector->stack + injector->stack_size - 16;
        regs.regs[6] = function_addr;
        regs.regs[0] = arg1;
        regs.regs[1] = arg2;
        regs.regs[2] = arg3;
        regs.regs[3] = arg4;
        regs.regs[4] = arg5;
        regs.regs[5] = arg6;
        reg_return = &regs.regs[0];
        break;
#endif
#if defined(__aarch64__) || defined(__arm__)
    case ARCH_ARM_EABI_THUMB:
        /* setup instructions */
        code.u16[0] = 0x47a0; /* blx r4 */
        code.u16[1] = BREAKINST_THUMB;
#ifdef __LP64__
        code.u16[2] = 0x46c0; /* nop (mov r8, r8) */
        code.u16[3] = 0x46c0; /* nop (mov r8, r8) */
#endif
        code_size = sizeof(long);
        /* setup registers */
        uregs[16] |= THUMB_MODE_BIT;
        uregs[15] = injector->code_addr;
        uregs[13] = injector->stack + injector->stack_size - 16;
        uregs[4] = function_addr;
        uregs[0] = arg1;
        uregs[1] = arg2;
        uregs[2] = arg3;
        uregs[3] = arg4;
        PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, uregs[13] + 0, arg5);
        PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, uregs[13] + 4, arg6);
        reg32_return = &uregs[0];
        break;
    case ARCH_ARM_EABI:
        /* setup instructions */
        code.u32[0] = 0xe12fff34; /* blx r4 */
        code.u32[1] = BREAKINST_ARM;
        code_size = 2 * 4;
        /* setup registers */
        uregs[16] &= ~THUMB_MODE_BIT;
        uregs[15] = injector->code_addr;
        uregs[13] = injector->stack + injector->stack_size - 16;
        uregs[4] = function_addr;
        uregs[0] = arg1;
        uregs[1] = arg2;
        uregs[2] = arg3;
        uregs[3] = arg4;
        PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, uregs[13] + 0, arg5);
        PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, uregs[13] + 4, arg6);
        reg32_return = &uregs[0];
        break;
#endif
#if defined(__mips__)
    case ARCH_MIPS_64:
    case ARCH_MIPS_N32:
    case ARCH_MIPS_O32:
        /* setup instructions */
        code.u32[0] = 0x00000009 | (REG_RA << 11) | (REG_T9 << 21); /* jalr $t9;  */
        code.u32[1] = 0x00000025 | (REG_A3 << 11) | (REG_T4 << 21); /* or $a3, $t4, $zero; in a delay slot */
        code.u32[2] = 0x0000000d; /* break */
        code.u32[3] = 0x00000000; /* nop */
        code_size = 4 * 4;
        DEBUG("  Code: %08"PRIx32" %08"PRIx32" %08"PRIx32" %08"PRIx32"\n",
              code.u32[0], code.u32[1], code.u32[2], code.u32[3]);
        /* setup registers */
        regs.cp0_epc  = injector->code_addr;
        regs.regs[REG_FP] = injector->stack + injector->stack_size - 32;
        regs.regs[REG_SP] = injector->stack + injector->stack_size - 64;
        regs.regs[REG_T9] = function_addr;
        regs.regs[REG_A0] = arg1;
        regs.regs[REG_A1] = arg2;
        regs.regs[REG_A2] = arg3;
        regs.regs[REG_T4] = arg4;
        if (injector->arch != ARCH_MIPS_O32) {
            /* ARCH_MIPS_64 or ARCH_MIPS_N32 */
            regs.regs[REG_A4] = arg5;
            regs.regs[REG_A5] = arg6;
        } else {
            /* ARCH_MIPS_O32 */
            PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, regs.regs[REG_SP] + 16, arg5);
            PTRACE_OR_RETURN(PTRACE_POKETEXT, injector, regs.regs[REG_SP] + 20, arg6);
        }
        reg_return = &regs.regs[REG_V0];
        break;
#endif
#if defined(__powerpc__)
#ifdef __LP64__
    case ARCH_POWERPC_64:
#endif
    case ARCH_POWERPC:
        /* setup instructions */
        code.u32[0] = 0x4e800421; /* bctrl */
        code.u32[1] = 0x7fe00008; /* trap */
        code_size = 2 * 4;
        /* setup registers */
        regs.nip = injector->code_addr;
        regs.gpr[PT_R1] = injector->stack + injector->stack_size - 256;
        regs.ctr = function_addr;
        regs.gpr[PT_R3] = arg1;
        regs.gpr[PT_R4] = arg2;
        regs.gpr[PT_R5] = arg3;
        regs.gpr[PT_R6] = arg4;
        regs.gpr[PT_R7] = arg5;
        regs.gpr[PT_R8] = arg6;
        regs.gpr[PT_R12] = function_addr;
        reg_return = &regs.gpr[PT_R3];
        break;
#endif
#if defined(__riscv)
#ifdef __LP64__
    case ARCH_RISCV_64:
#endif
    case ARCH_RISCV_32:
        /* setup instructions */
        code.u32[0] = 0x00000067 | (REG_RA << 7) | (REG_T1 << 15) ; /* jalr t1 */
        code.u32[1] = 0x00100073; /* ebreak */
        code_size = 2 * 4;
        DEBUG("  Code: %08"PRIx32" %08"PRIx32"\n",
              code.u32[0], code.u32[1]);
        /* setup registers */
        regs.pc = injector->code_addr;
        regs.sp = injector->stack + injector->stack_size - 16;
        regs.t1 = function_addr;
        regs.a0 = arg1;
        regs.a1 = arg2;
        regs.a2 = arg3;
        regs.a3 = arg4;
        regs.a4 = arg5;
        regs.a5 = arg6;
        reg_return = &regs.a0;
        break;
#endif
    default:
        injector__set_errmsg("Unexpected architecture: %s", injector__arch2name(injector->arch));
        return -1;
    }

    PRINT_REGS(injector, &regs);
    rv = kick_then_wait_sigtrap(injector, &regs, &code, code_size);
    if (rv != 0) {
        return rv;
    }
    PRINT_REGS(injector, &regs);

    if (retval != NULL) {
#if defined(__aarch64__)
        if (reg32_return != NULL) {
            *retval = (long)*reg32_return;
        } else {
            *retval = (long)*reg_return;
        }
#else
        *retval = (long)*reg_return;
#endif
    }
    return 0;
}

static int kick_then_wait_sigtrap(const injector_t *injector, struct user_regs_struct *regs, code_t *code, size_t code_size)
{
    int status;
    int rv;

    rv = injector__set_regs(injector, regs);
    if (rv != 0) {
        return rv;
    }
    rv = injector__write(injector, injector->code_addr, code, code_size);
    if (rv != 0) {
        injector__set_regs(injector, &injector->regs);
        return rv;
    }

    rv = injector__continue(injector);
    if (rv != 0) {
        goto cleanup;
    }
    while (1) {
        pid_t pid = waitpid(injector->pid, &status, 0);
        if (pid == -1) {
            if (errno == EINTR) {
                continue;
            }
            injector__set_errmsg("waitpid error: %s", strerror(errno));
            rv = INJERR_WAIT_TRACEE;
            goto cleanup;
        }
        if (WIFSTOPPED(status)) {
#if defined(PT_GETSIGINFO)
            siginfo_t si = {0,};
#endif
            switch (WSTOPSIG(status)) {
            case SIGTRAP:
                goto got_sigtrap;
            case SIGSTOP:
                rv = injector__continue(injector);
                if (rv != 0) {
                    goto cleanup;
                }
                break;
#if defined(PT_GETSIGINFO)
            case SIGSYS:
              PTRACE_OR_RETURN(PT_GETSIGINFO, injector, 0, (long)&si);
              if (si.si_signo == SIGSYS && si.si_code == 1) {
                  injector__set_errmsg("Got SIGSYS. System call %d at address %p might be blocked by seccomp.",
                                       si.si_syscall, (void*)si.si_call_addr);
                  rv = INJERR_OTHER;
                  goto cleanup;
              }
              // FALL THROUGH */
#endif
            default:
                injector__set_errmsg("The target process unexpectedly stopped by signal %d.", WSTOPSIG(status));
                rv = INJERR_OTHER;
                goto cleanup;
            }
        } else if (WIFEXITED(status)) {
            injector__set_errmsg("The target process unexpectedly terminated with exit code %d.", WEXITSTATUS(status));
            rv = INJERR_OTHER;
            goto cleanup;
        } else if (WIFSIGNALED(status)) {
            injector__set_errmsg("The target process unexpectedly terminated by signal %d.", WTERMSIG(status));
            rv = INJERR_OTHER;
            goto cleanup;
        } else {
            /* never reach here */
            injector__set_errmsg("Unexpected waitpid status: 0x%x", status);
            rv = INJERR_OTHER;
            goto cleanup;
        }
    }
got_sigtrap:
    /* success */
    rv = injector__get_regs(injector, regs);
cleanup:
    injector__set_regs(injector, &injector->regs);
    injector__write(injector, injector->code_addr, &injector->backup_code, code_size);
    return rv;
}

```

`src/w1nj3ct/backend/linux/shellcode.S`:

```S
#if defined(__x86_64__)
#define handle_offset 0
#define dlopen_addr_offset 8
#define dlerror_addr_offset 16
#define dlflags_offset 24
#define file_path_offset 28
#define page_size 4096
	.text
	.global	injector_shellcode
	.hidden	injector_shellcode
	.type	injector_shellcode, @function
	// void *injector_shellcode(injector_shellcode_arg_t *arg) {
injector_shellcode:
	//   // prolog
	pushq	%rbx
	movq	%rdi, %rbx
	//   int dlflags = arg->dlflags;
	movl	dlflags_offset(%rbx), %esi
	//   const char *file_path = arg->file_path;
	leaq	file_path_offset(%rbx), %rdi
	//   void *handle = dlopen(file_path, dlflags);
	call	*dlopen_addr_offset(%rbx)
	//   arg->handle = handle;
	movq	%rax, handle_offset(%rbx)
	//   arg->file_path[0] = '\0';
	movb	$0, file_path_offset(%rbx)
	//   if (handle != NULL) return;
	test	%rax, %rax
	jnz	.exit
	//   if (arg->dlerror_addr == 0) return;
	cmpq	$0, dlerror_addr_offset(%rbx)
	je	.exit
	//   char *errmsg = dlerror();
	call	*dlerror_addr_offset(%rbx)
	//   if (errmsg == NULL) return;
	test	%rax, %rax
	jz	.exit
	//   char *dest = arg->file_path
	leaq	file_path_offset(%rbx), %rdi
	//   char *end = (char*)arg + page_size;
	leaq	page_size(%rbx), %rcx
.loop:
	//   char c = *(errmsg++);
	movb	(%rax), %dl
	addq	$1, %rax
	//   *(dest++) = c;
	movb	%dl, (%rdi)
	addq	$1, %rdi
	//   if (c == 0) return;
	testb	%dl, %dl
	jz	.exit
	//   if (dest < end) goto loop;
	cmpq	%rdi, %rcx
	ja	.loop
.exit:
	//   // epilog
	popq	%rbx
	ret
	// }
	.size	injector_shellcode, . - injector_shellcode

	.balign  4
	.global	injector_shellcode_size
	.hidden	injector_shellcode_size
	.type	injector_shellcode_size, @object
	.size	injector_shellcode_size, 4
injector_shellcode_size:
	// distance from injector_shellcode to current.
	.int	. - injector_shellcode
#endif

```

`src/w1nj3ct/backend/linux/util.c`:

```c
/* -*- indent-tabs-mode: nil -*-
 *
 * injector - Library for injecting a shared library into a Linux process
 *
 * URL: https://github.com/kubo/injector
 *
 * ------------------------------------------------------
 *
 * Copyright (C) 2018 Kubo Takehiro <kubo@jiubao.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
#include <stdio.h>
#include <stdarg.h>
#include "injector_internal.h"

char injector__errmsg[512];
char injector__errmsg_is_set;

void injector__set_errmsg(const char *format, ...)
{
    va_list ap;
    int rv;

    /* prevent the error message from being overwritten. */
    if (injector__errmsg_is_set) {
        return;
    }
    injector__errmsg_is_set = 1;

    va_start(ap, format);
    rv = vsnprintf(injector__errmsg, sizeof(injector__errmsg), format, ap);
    va_end(ap);
    if (rv == -1 || rv >= sizeof(injector__errmsg)) {
        injector__errmsg[sizeof(injector__errmsg) - 1] = '\0';
    }
}

const char *injector__arch2name(arch_t arch)
{
    switch (arch) {
    case ARCH_X86_64:
        return "x86_64";
    case ARCH_X86_64_X32:
        return "x86_64 x32-ABI";
    case ARCH_I386:
        return "i386";
    case ARCH_ARM64:
        return "ARM64";
    case ARCH_ARM_EABI_THUMB:
        return "ARM EABI thumb";
    case ARCH_ARM_EABI:
        return "ARM EABI";
    case ARCH_MIPS_64:
        return "MIPS 64";
    case ARCH_MIPS_N32:
        return "MIPS N32 ABI";
    case ARCH_MIPS_O32:
        return "MIPS O32 ABI";
    case ARCH_POWERPC_64:
        return "PowerPC 64-bit";
    case ARCH_POWERPC:
        return "PowerPC";
    case ARCH_RISCV_64:
        return "RISC-V 64";
    case ARCH_RISCV_32:
        return "RISC-V 32";
    }
    return "?";
}

```

`src/w1nj3ct/backend/windows/auxiliary.cpp`:

```cpp
#include <windows.h>
#include <TlHelp32.h>
#include <sstream>
#include "inject.hpp"
#include "util.hpp"

DWORD find_pid_by_name(const std::wstring& process_name) {
  log_msg("searching for process ID by name");

  HANDLE h_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  if (h_snapshot == INVALID_HANDLE_VALUE) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to create process snapshot. Error code: " << error;
    log_msg(ss.str());
    return 0;
  }

  PROCESSENTRY32 pe32;
  pe32.dwSize = sizeof(PROCESSENTRY32);

  if (!Process32First(h_snapshot, &pe32)) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to get first process. Error code: " << error;
    log_msg(ss.str());
    CloseHandle(h_snapshot);
    return 0;
  }

  DWORD pid = 0;
  do {
    if (_wcsicmp((wchar_t*) pe32.szExeFile, process_name.c_str()) == 0) {
      pid = pe32.th32ProcessID;
      break;
    }
  } while (Process32Next(h_snapshot, &pe32));

  CloseHandle(h_snapshot);

  if (pid != 0) {
    std::stringstream ss;
    ss << "process ID found: " << pid;
    log_msg(ss.str());
  } else {
    log_msg("process not found");
  }

  return pid;
}

DWORD get_thread_id(DWORD pid) {
  log_msg("searching for thread ID");

  HANDLE h_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
  if (h_snapshot == INVALID_HANDLE_VALUE) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to create thread snapshot. Error code: " << error;
    log_msg(ss.str());
    return 0;
  }

  THREADENTRY32 te32;
  te32.dwSize = sizeof(THREADENTRY32);

  if (!Thread32First(h_snapshot, &te32)) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to get first thread. Error code: " << error;
    log_msg(ss.str());
    CloseHandle(h_snapshot);
    return 0;
  }

  DWORD thread_id = 0;
  do {
    if (te32.th32OwnerProcessID == pid) {
      HANDLE h_thread = OpenThread(READ_CONTROL, FALSE, te32.th32ThreadID);
      if (h_thread == NULL) {
        DWORD error = GetLastError();
        std::stringstream ss;
        ss << "Failed to open thread. Error code: " << error;
        log_msg(ss.str());
      } else {
        thread_id = te32.th32ThreadID;
        CloseHandle(h_thread);
        break;
      }
    }
  } while (Thread32Next(h_snapshot, &te32));

  CloseHandle(h_snapshot);

  if (thread_id != 0) {
    std::stringstream ss;
    ss << "thread ID found: " << thread_id;
    log_msg(ss.str());
  } else {
    log_msg("thread not found");
  }

  return thread_id;
}

BOOL set_se_debug_privilege() {
  log_msg("attempting to set SeDebugPrivilege");

  HANDLE h_token = NULL;
  TOKEN_PRIVILEGES tp;
  LUID luid;

  if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &h_token)) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to open process token. Error code: " << error;
    log_msg(ss.str());
    return FALSE;
  }

  if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &luid)) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to lookup privilege value. Error code: " << error;
    log_msg(ss.str());
    CloseHandle(h_token);
    return FALSE;
  }

  tp.PrivilegeCount = 1;
  tp.Privileges[0].Luid = luid;
  tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

  if (!AdjustTokenPrivileges(h_token, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to adjust token privileges. Error code: " << error;
    log_msg(ss.str());
    CloseHandle(h_token);
    return FALSE;
  }

  if (GetLastError() == ERROR_NOT_ALL_ASSIGNED) {
    log_msg("warning: the token does not have the specified privilege");
    CloseHandle(h_token);
    return FALSE;
  }

  log_msg("SeDebugPrivilege enabled successfully");
  CloseHandle(h_token);
  return TRUE;
}

```

`src/w1nj3ct/backend/windows/auxiliary.hpp`:

```hpp
#pragma once

#include <string>
#include <w1common/windows_clean.hpp>

// find the process ID of a given process name
// returns 0 if the process is not found
DWORD find_pid_by_name(const std::wstring& process_name);

// get the thread ID of the first thread in a given process
// returns 0 if no thread is found
DWORD get_thread_id(DWORD pid);

// set the SeDebugPrivilege for the current process
// returns TRUE if successful, FALSE otherwise
BOOL set_se_debug_privilege();
```

`src/w1nj3ct/backend/windows/inject.hpp`:

```hpp
#pragma once

#include <map>
#include <string>
#include <vector>

// completely clean interface, no windows dependencies
namespace w1::inject::windows {

// opaque types for clean interface
using process_handle = void*;
using process_id = unsigned long;

// injection methods
bool inject_dll_create_remote_thread(process_handle h_process, const std::wstring& dll_path);
bool inject_dll_set_windows_hook_ex(process_handle h_process, process_id pid, const std::wstring& dll_path);
bool inject_dll_rtl_create_user_thread(process_handle h_process, const std::wstring& dll_path);
bool inject_dll_reflective_loader(process_handle h_process, const std::wstring& dll_path);
bool inject_dll_launch_suspended(
    const std::wstring& binary_path, const std::wstring& dll_path, const std::vector<std::string>& args,
    const std::map<std::string, std::string>& env_vars, process_id* out_pid, bool interactive_resume,
    bool wait_for_completion
);

} // namespace w1::inject::windows

```

`src/w1nj3ct/backend/windows/inject_createremotethread.cpp`:

```cpp
#include <sstream>

#ifndef NOMINMAX
#define NOMINMAX
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "winapis.h"
#include "inject.hpp"
#include "util.hpp"

// internal windows implementation
static BOOL inject_dll_create_remote_thread_impl(HANDLE h_process, const std::wstring& dll_path) {
  // this function injects a dll into a target process using the createremotethread method
  log_msg("starting CreateRemoteThread injection method");

  // allocate memory in the target process for the dll path
  log_msg("allocating memory in the target process");
  LPVOID remote_memory = VirtualAllocEx(h_process, NULL, dll_path.size() * sizeof(wchar_t), MEM_COMMIT, PAGE_READWRITE);
  if (!remote_memory) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to allocate memory in the target process. Error code: " << error;
    log_msg(ss.str());
    return FALSE;
  }
  log_msg("memory allocated successfully");

  // write the dll path to the allocated memory in the target process
  log_msg("writing DLL path to the allocated memory");
  SIZE_T bytes_written;
  if (!WriteProcessMemory(
          h_process, remote_memory, dll_path.c_str(), dll_path.size() * sizeof(wchar_t), &bytes_written
      )) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to write to process memory. Error code: " << error;
    log_msg(ss.str());
    VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE);
    return FALSE;
  }
  if (bytes_written != dll_path.size() * sizeof(wchar_t)) {
    log_msg("incomplete write to process memory");
    VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE);
    return FALSE;
  }
  log_msg("DLL path written successfully");

  // get the address of LoadLibraryW function, which we'll use to load our dll in the target process
  log_msg("getting address of LoadLibraryW");
  LPTHREAD_START_ROUTINE load_library_addr =
      (LPTHREAD_START_ROUTINE) GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "LoadLibraryW");
  if (!load_library_addr) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to get address of LoadLibraryW. Error code: " << error;
    log_msg(ss.str());
    VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE);
    return FALSE;
  }
  // log_msg("LoadLibraryW address obtained");
  {
    std::stringstream ss;
    ss << "loadLibraryW address obtained: " << std::hex << load_library_addr;
    log_msg(ss.str());
  }

  // create a remote thread in the target process that calls LoadLibraryW with our dll path
  log_msg("creating remote thread");
  HANDLE h_thread = CreateRemoteThread(h_process, NULL, 0, load_library_addr, remote_memory, 0, NULL);
  if (!h_thread) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to create remote thread. Error code: " << error;
    log_msg(ss.str());
    VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE);
    return FALSE;
  }
  log_msg("remote thread created successfully");

  // wait for the remote thread to finish executing
  log_msg("waiting for remote thread to finish");
  DWORD wait_result = WaitForSingleObject(h_thread, INFINITE);
  if (wait_result != WAIT_OBJECT_0) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "WaitForSingleObject failed. Error code: " << error;
    log_msg(ss.str());
    CloseHandle(h_thread);
    VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE);
    return FALSE;
  }
  log_msg("remote thread finished execution");

  // get the exit code of the remote thread to check if dll injection was successful
  DWORD exit_code;
  if (GetExitCodeThread(h_thread, &exit_code)) {
    std::stringstream ss;
    ss << "remote thread exit code: " << exit_code;
    log_msg(ss.str());
    if (exit_code == 0) {
      log_msg("DLL injection may have failed (exit code is 0)");
    }
  } else {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to get remote thread exit code. Error code: " << error;
    log_msg(ss.str());
  }

  // clean up resources
  log_msg("cleaning up");
  if (!VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE)) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to free memory in target process. Error code: " << error;
    log_msg(ss.str());
  }
  CloseHandle(h_thread);

  log_msg("CreateRemoteThread injection completed");
  return TRUE;
}

// clean wrapper for the public api
bool w1::inject::windows::inject_dll_create_remote_thread(process_handle h_process, const std::wstring& dll_path) {
  HANDLE win_handle = static_cast<HANDLE>(h_process);
  BOOL result = inject_dll_create_remote_thread_impl(win_handle, dll_path);
  return result != FALSE;
}

```

`src/w1nj3ct/backend/windows/inject_launch.cpp`:

```cpp
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <map>
#include <sstream>
#include <string>

#ifndef NOMINMAX
#define NOMINMAX
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "winapis.h"
#include "inject.hpp"
#include "util.hpp"

// convert std::string to std::wstring
std::wstring string_to_wstring(const std::string& str) {
  if (str.empty()) {
    return std::wstring();
  }
  int size = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, nullptr, 0);
  std::wstring result(size - 1, 0);
  MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, &result[0], size);
  return result;
}

// build command line string from binary path and arguments
std::wstring build_command_line(const std::wstring& binary_path, const std::vector<std::string>& args) {
  std::wstring cmd_line = L"\"" + binary_path + L"\"";

  for (const auto& arg : args) {
    cmd_line += L" \"" + string_to_wstring(arg) + L"\"";
  }

  return cmd_line;
}

// internal windows implementation
static BOOL inject_dll_launch_suspended_impl(
    const std::wstring& binary_path, const std::wstring& dll_path, const std::vector<std::string>& args,
    const std::map<std::string, std::string>& env_vars, DWORD* out_pid, bool interactive_resume,
    bool wait_for_completion
) {
  log_msg("starting Windows launch injection with suspended process");

  // validate library exists
  if (GetFileAttributesW(dll_path.c_str()) == INVALID_FILE_ATTRIBUTES) {
    std::stringstream ss;
    ss << "Library not found at path: " << std::string(dll_path.begin(), dll_path.end());
    log_msg(ss.str());
    return FALSE;
  }

  // validate binary exists
  if (GetFileAttributesW(binary_path.c_str()) == INVALID_FILE_ATTRIBUTES) {
    std::stringstream ss;
    ss << "Binary not found at path: " << std::string(binary_path.begin(), binary_path.end());
    log_msg(ss.str());
    return FALSE;
  }

  // build command line
  std::wstring command_line = build_command_line(binary_path, args);

  {
    std::stringstream ss;
    ss << "Target binary: " << std::string(binary_path.begin(), binary_path.end());
    log_msg(ss.str());
  }

  // build environment block
  LPVOID environment_block = nullptr;
  if (!env_vars.empty()) {
    log_msg("building environment block");

    // Get current environment
    LPWCH current_env = GetEnvironmentStringsW();
    if (!current_env) {
      log_msg("failed to get current environment");
      return FALSE;
    }

    // parse current environment into a map
    std::map<std::wstring, std::wstring> env_map;
    LPWCH env_ptr = current_env;
    while (*env_ptr) {
      std::wstring env_entry(env_ptr);
      size_t eq_pos = env_entry.find(L'=');
      if (eq_pos != std::wstring::npos) {
        std::wstring key = env_entry.substr(0, eq_pos);
        std::wstring value = env_entry.substr(eq_pos + 1);
        env_map[key] = value;
      }
      env_ptr += env_entry.length() + 1;
    }
    FreeEnvironmentStringsW(current_env);

    // add/override with custom environment variables
    for (const auto& [key, value] : env_vars) {
      std::wstring wkey = string_to_wstring(key);
      std::wstring wvalue = string_to_wstring(value);
      env_map[wkey] = wvalue;

      std::stringstream ss;
      ss << "setting environment variable: " << key << "=" << value;
      log_msg(ss.str());
    }

    // build environment block
    std::wstring env_block;
    for (const auto& [key, value] : env_map) {
      env_block += key + L"=" + value + L'\0';
    }
    env_block += L'\0'; // Double null terminator

    // Allocate memory for environment block
    size_t env_size = env_block.size() * sizeof(wchar_t);
    environment_block = malloc(env_size);
    if (!environment_block) {
      log_msg("failed to allocate memory for environment block");
      return FALSE;
    }
    memcpy(environment_block, env_block.c_str(), env_size);

    std::stringstream ss;
    ss << "environment block created with " << env_map.size() << " variables";
    log_msg(ss.str());
  }

  {
    std::stringstream ss;
    ss << "command line: " << std::string(command_line.begin(), command_line.end());
    log_msg(ss.str());
  }

  {
    std::stringstream ss;
    ss << "library to inject: " << std::string(dll_path.begin(), dll_path.end());
    log_msg(ss.str());
  }

  // create process in suspended state
  STARTUPINFOW si = {0};
  PROCESS_INFORMATION pi = {0};
  si.cb = sizeof(si);

  log_msg("creating suspended process");

  // createProcessW modifies the command line, so we need a mutable copy
  std::vector<wchar_t> cmd_line_buffer(command_line.begin(), command_line.end());
  cmd_line_buffer.push_back(L'\0');

  DWORD creation_flags = CREATE_SUSPENDED;
  if (environment_block) {
    creation_flags |= CREATE_UNICODE_ENVIRONMENT;
  }

  BOOL create_result = CreateProcessW(
      binary_path.c_str(),    // lpApplicationName
      cmd_line_buffer.data(), // lpCommandLine (must be mutable)
      NULL,                   // lpProcessAttributes
      NULL,                   // lpThreadAttributes
      TRUE,                   // bInheritHandles
      creation_flags,         // dwCreationFlags
      environment_block,      // lpEnvironment
      NULL,                   // lpCurrentDirectory
      &si,                    // lpStartupInfo
      &pi                     // lpProcessInformation
  );

  if (!create_result) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to create suspended process. Error code: " << error;
    log_msg(ss.str());
    if (environment_block) {
      free(environment_block);
    }
    return FALSE;
  }

  {
    std::stringstream ss;
    ss << "process created successfully with PID: " << pi.dwProcessId;
    log_msg(ss.str());
  }

  // get address of LoadLibraryW function
  log_msg("getting address of LoadLibraryW");
  LPTHREAD_START_ROUTINE load_library_addr =
      (LPTHREAD_START_ROUTINE) GetProcAddress(GetModuleHandleW(L"kernel32.dll"), "LoadLibraryW");

  if (!load_library_addr) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to get address of LoadLibraryW. Error code: " << error;
    log_msg(ss.str());
    TerminateProcess(pi.hProcess, -1);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    if (environment_block) {
      free(environment_block);
    }
    return FALSE;
  }

  {
    std::stringstream ss;
    ss << "loadLibraryW address obtained: " << std::hex << load_library_addr;
    log_msg(ss.str());
  }

  // allocate memory in the target process for the DLL path
  log_msg("allocating memory in suspended process");
  SIZE_T dll_path_size = (dll_path.length() + 1) * sizeof(wchar_t);
  LPVOID remote_memory = VirtualAllocEx(pi.hProcess, NULL, dll_path_size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

  if (!remote_memory) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to allocate memory in suspended process. Error code: " << error;
    log_msg(ss.str());
    TerminateProcess(pi.hProcess, -1);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    if (environment_block) {
      free(environment_block);
    }
    return FALSE;
  }

  log_msg("memory allocated successfully");

  // write the DLL path to the allocated memory
  log_msg("writing DLL path to process memory");
  SIZE_T bytes_written;
  if (!WriteProcessMemory(pi.hProcess, remote_memory, dll_path.c_str(), dll_path_size, &bytes_written)) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to write DLL path to process memory. Error code: " << error;
    log_msg(ss.str());
    VirtualFreeEx(pi.hProcess, remote_memory, 0, MEM_RELEASE);
    TerminateProcess(pi.hProcess, -1);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    if (environment_block) {
      free(environment_block);
    }
    return FALSE;
  }

  if (bytes_written != dll_path_size) {
    log_msg("incomplete write to process memory");
    VirtualFreeEx(pi.hProcess, remote_memory, 0, MEM_RELEASE);
    TerminateProcess(pi.hProcess, -1);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    if (environment_block) {
      free(environment_block);
    }
    return FALSE;
  }

  log_msg("DLL path written successfully");

  // create remote thread to load the library
  log_msg("creating remote thread to load library");
  HANDLE remote_thread = CreateRemoteThread(pi.hProcess, NULL, 0, load_library_addr, remote_memory, 0, NULL);

  if (!remote_thread) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to create remote thread. Error code: " << error;
    log_msg(ss.str());
    VirtualFreeEx(pi.hProcess, remote_memory, 0, MEM_RELEASE);
    TerminateProcess(pi.hProcess, -1);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    if (environment_block) {
      free(environment_block);
    }
    return FALSE;
  }

  log_msg("remote thread created successfully");

  // wait for the remote thread to complete (library loading)
  log_msg("waiting for library loading to complete");
  DWORD wait_result = WaitForSingleObject(remote_thread, INFINITE);
  if (wait_result != WAIT_OBJECT_0) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Wait for remote thread failed. Error code: " << error;
    log_msg(ss.str());
    CloseHandle(remote_thread);
    VirtualFreeEx(pi.hProcess, remote_memory, 0, MEM_RELEASE);
    TerminateProcess(pi.hProcess, -1);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    if (environment_block) {
      free(environment_block);
    }
    return FALSE;
  }

  // check if library loading was successful
  DWORD exit_code;
  if (GetExitCodeThread(remote_thread, &exit_code)) {
    std::stringstream ss;
    ss << "library loading thread exit code: " << exit_code;
    log_msg(ss.str());
    if (exit_code == 0) {
      log_msg("warning: library loading may have failed (exit code is 0)");
    }
  }

  CloseHandle(remote_thread);
  VirtualFreeEx(pi.hProcess, remote_memory, 0, MEM_RELEASE);

  log_msg("library loading completed");

  if (interactive_resume) {
    std::stringstream ss;
    ss << "process created and suspended (PID: " << pi.dwProcessId << ")";
    log_msg(ss.str());

    // output to console for user interaction
    std::cout << "process created and suspended (PID: " << pi.dwProcessId << ")" << std::endl;
    std::cout << "binary: " << std::string(binary_path.begin(), binary_path.end()) << std::endl;
    std::cout << "DLL injected successfully. Press Enter to resume process..." << std::endl;

    // wait for user input
    std::cin.get();

    log_msg("user resumed process, continuing execution");
  }

  // resume the main thread
  ResumeThread(pi.hThread);

  log_msg("process resumed successfully");

  // set output PID if requested
  if (out_pid) {
    *out_pid = pi.dwProcessId;
  }

  // conditionally wait for process completion based on configuration
  if (wait_for_completion) {
    log_msg("waiting for target process to complete");
    DWORD wait_result = WaitForSingleObject(pi.hProcess, INFINITE);

    if (wait_result != WAIT_OBJECT_0) {
      DWORD error = GetLastError();
      std::stringstream ss;
      ss << "Wait for process completion failed. Error code: " << error;
      log_msg(ss.str());
      // continue with cleanup, but note the error
    }

    // get process exit code
    DWORD process_exit_code = 0;
    if (GetExitCodeProcess(pi.hProcess, &process_exit_code)) {
      std::stringstream ss;
      ss << "target process completed with exit code: " << process_exit_code;
      log_msg(ss.str());
    } else {
      log_msg("failed to get process exit code");
    }
  } else {
    log_msg("process launched successfully - not waiting for completion");
  }

  // clean up handles
  CloseHandle(pi.hThread);
  CloseHandle(pi.hProcess);

  // clean up environment block
  if (environment_block) {
    free(environment_block);
  }

  {
    std::stringstream ss;
    ss << "launch injection completed successfully for PID: " << pi.dwProcessId;
    log_msg(ss.str());
  }

  return TRUE;
}

// clean wrapper for the public api
bool w1::inject::windows::inject_dll_launch_suspended(
    const std::wstring& binary_path, const std::wstring& dll_path, const std::vector<std::string>& args,
    const std::map<std::string, std::string>& env_vars, process_id* out_pid, bool interactive_resume,
    bool wait_for_completion
) {
  DWORD win_pid;
  BOOL result = inject_dll_launch_suspended_impl(
      binary_path, dll_path, args, env_vars, &win_pid, interactive_resume, wait_for_completion
  );
  if (out_pid) {
    *out_pid = static_cast<process_id>(win_pid);
  }
  return result != FALSE;
}
```

`src/w1nj3ct/backend/windows/inject_reflective.cpp`:

```cpp
#include <fstream>
#include <iostream>
#include <string>
#include <vector>

#ifndef NOMINMAX
#define NOMINMAX
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "winapis.h"
#include "inject.hpp"
#include "util.hpp"

/**
 * reflective loader implementation:
 * based on https://github.com/Allevon412/ReflectiveDLLInjector
 */

// declare windows API prototypes that will be passed to our loaderstub.
typedef HINSTANCE(WINAPI* f_LoadLibraryA)(const char* lpLibFileName);
typedef UINT_PTR(WINAPI* f_GetProcAddress)(HINSTANCE hModule, const char* lpProcName);
using f_DLL_ENTRY_POINT = BOOL(WINAPI*)(void* hDll, DWORD dwReason, void* pReserved);
using f_OpenProcess = HANDLE(WINAPI*)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
using f_VirtualALlocEx =
    LPVOID(WINAPI*)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);

// declare structure that will be passed to our loader stub that contains necessary information for loading.
struct MANUAL_MAPPING_DATA {
  f_LoadLibraryA pLoadLibraryA;
  f_GetProcAddress pGetProcAddress;
  HINSTANCE hMod;
};

// declare functions.
// perform memory mapping manually in remote process.
BOOL ManualMap(HANDLE hProc, const char* szDllFile);

// performs relocations and loading of dll into process from within the process itself.
void __stdcall LoaderStub(BYTE* imageBase);

// internal windows implementation
static BOOL inject_dll_reflective_loader_impl(HANDLE h_process, const std::wstring& dll_path) {
  // call manual map injection
  // (we need to convert the dll path to a narrow string)
  std::string narrow_dll_path(dll_path.begin(), dll_path.end());
  return ManualMap(h_process, narrow_dll_path.c_str());
}

// function declaration.
BOOL ManualMap(HANDLE hProc, const char* szDllFile) {
  // declare necessary variables.
  BYTE* pSrcData = nullptr;
  IMAGE_NT_HEADERS* pOldNtHeader = nullptr;
  IMAGE_OPTIONAL_HEADER* pOldOptHeader = nullptr;
  IMAGE_FILE_HEADER* pOldFileHeader = nullptr;
  BYTE* pTargetBase = nullptr;

  // ensure that our file exists on disc.
  if (GetFileAttributesA(szDllFile) == INVALID_FILE_ATTRIBUTES) {
    printf("[!] File doesn't exist\n");
    return false;
  }
  printf("[*] Attempting to open file handle\n");
  std::ifstream File(szDllFile, std::ios::binary | std::ios::ate);

  // ensure that we are able to open a file handle.
  if (File.fail()) {
    printf("[!] Opening the file failed: [%X]\n", (DWORD) File.rdstate());
    File.close();
    return false;
  }

  // ensure that our file has a valid size.
  auto FileSize = File.tellg();
  if (FileSize < 0x1000) {
    printf("[!] Filesize is invalid.\n");
    File.close();
    return false;
  }

  // allocate memory for our file using the size as a measure.
  printf("[*] Allocating memory for the dll.\n");
  pSrcData = new BYTE[static_cast<UINT_PTR>(FileSize)];
  if (!pSrcData) {
    printf("[!] Memory Allocation Failed\n");
    File.close();
    return false;
  }

  // read the file into our allocated buffer.
  printf("[*] Memory allocated at location: [0x%p], attempting to read file contents into memory\n", pSrcData);
  File.seekg(0, std::ios::beg);
  File.read(reinterpret_cast<char*>(pSrcData), FileSize);
  File.close();

  // ensure that our file is in the pe format.
  if (reinterpret_cast<IMAGE_DOS_HEADER*>(pSrcData)->e_magic != 0x5A4D) {
    printf("[!] File is not a valid PE file Magic Bytes do not equal \"MZ\"\n");
    delete[] pSrcData;
    return false;
  }

  // create pointers to the PE Optional Header, NtHeaders, and FileHeaders for mapping usage.
  pOldNtHeader =
      reinterpret_cast<IMAGE_NT_HEADERS*>(pSrcData + reinterpret_cast<IMAGE_DOS_HEADER*>(pSrcData)->e_lfanew);
  pOldOptHeader = &pOldNtHeader->OptionalHeader;
  pOldFileHeader = &pOldNtHeader->FileHeader;

#ifdef _WIN64
  if (pOldFileHeader->Machine != IMAGE_FILE_MACHINE_AMD64) {
    printf("[!] Invalid Platform in target DLL: [%x]\n", pOldFileHeader->Machine);
    delete[] pSrcData;
    return false;
  }
#else
  if (pOldFileHeader->Machine != IMAGE_FILE_MACHINE_I386) {
    printf("[!] Invalid Platform in target DLL: [%x]\n", pOldFileHeader->Machine);
    delete[] pSrcData;
    return false;
  }

#endif
  // create a map data structure that will be passed to our LoaderStub.
  MANUAL_MAPPING_DATA mData{0};
  mData.pLoadLibraryA = LoadLibraryA;
  mData.pGetProcAddress = reinterpret_cast<f_GetProcAddress>(GetProcAddress);

  // allocate memory in the target process the size of the image plus the size of the mapping data which will be passed
  // to our loader stub.
  printf(
      "[*] Allocating memory in the size of: [0x%zx] in remote process.\n", pOldOptHeader->SizeOfImage + sizeof(mData)
  );
  pTargetBase = reinterpret_cast<BYTE*>(VirtualAllocEx(
      hProc, nullptr, pOldOptHeader->SizeOfImage + sizeof(mData), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE
  ));

  // if the memory allocation failed.
  if (!pTargetBase) {
    printf("[!] Memory Allocation Failed [0x%X]\n", GetLastError());
    delete[] pSrcData;
    return false;
  }
  printf("[*] Memory Allocation successful. Memory located at: [0x%p]\n", pTargetBase);

  // next we write the headers of our dll into the remote process.
  printf("[*] Writing the Headers of our DLL into target process\n");
  if (!WriteProcessMemory(hProc, pTargetBase, pSrcData, pOldOptHeader->SizeOfHeaders, nullptr)) {
    printf("[!] Error Mapping the Headers into memory please read error code: [0x%X]\n", GetLastError());
    return false;
  }

  // write our sections into the remote process.
  auto* pSectionHeader = IMAGE_FIRST_SECTION(pOldNtHeader);

  // for each section write it into the virtual address of our allocated memory in the remote process using the raw data
  // from our dll file.
  printf("[*] Attempting to write our sections into the remote process\n");
  for (UINT i = 0; i != pOldFileHeader->NumberOfSections; i++, pSectionHeader++) {
    if (pSectionHeader->SizeOfRawData) {
      printf(
          "%5s%s%s%p%s", "[*] Attempting to write section: [", pSectionHeader->Name, "] at location: [0x",
          pTargetBase + pSectionHeader->VirtualAddress, "]\n"
      );
      if (!WriteProcessMemory(
              hProc, pTargetBase + pSectionHeader->VirtualAddress, pSrcData + pSectionHeader->PointerToRawData,
              pSectionHeader->SizeOfRawData, nullptr
          )) {
        printf("[!] Error Mapping the sections error code [0x%X]\n", GetLastError());
        delete[] pSrcData;
        VirtualFreeEx(hProc, pTargetBase, 0, MEM_RELEASE);
        return false;
      }
    }
  }

  printf(
      "[*] Sections written into memory.\n[*]Attempting to write our mapping data at end of image location: [0x%p]\n",
      pTargetBase + pOldOptHeader->SizeOfImage
  );
  WriteProcessMemory(hProc, pTargetBase + pOldOptHeader->SizeOfImage, &mData, sizeof(mData), nullptr);

  DWORD ImageSize = pOldOptHeader->SizeOfImage;
  delete[] pSrcData;

  // allocate memory in our remote process for our loader stub.
  printf("[*] Attemtping to allocate memory in the remote process for our Loader Stub.\n");
  void* pLoaderStub = VirtualAllocEx(hProc, nullptr, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
  if (!pLoaderStub) {
    printf("[!] Loader Memory Allocation Failed [0x%X]\n", GetLastError());
    free(pLoaderStub);
    return false;
  }

  printf(
      "[*] Allocation successful. Loaderstub memory location: [0x%p]\n[*] Attempting to Write LoaderStub\n", pLoaderStub
  );
  // write our loader stub into remote process' memory.
  WriteProcessMemory(hProc, pLoaderStub, LoaderStub, 0x1000, nullptr);

  // create thread in remote process that will start the loader using our DLL and the map data structure as an argument.
  printf("[*] Creating Thread in remote process that will start the loading routine\n");
  HANDLE hThread = CreateRemoteThread(
      hProc, nullptr, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(pLoaderStub), pTargetBase, 0, NULL
  );
  if (!hThread) {
    printf("[!] Thread Creation failed exiting: [0x%x]", GetLastError());
    VirtualFreeEx(hProc, pLoaderStub, 0, MEM_RELEASE);
    VirtualFreeEx(hProc, pTargetBase, 0, MEM_RELEASE);
    return false;
  }
  printf("%5s", "[*] Checking for completion of the loading routine\n");
  HINSTANCE hCheck = NULL;
  while (!hCheck) {
    MANUAL_MAPPING_DATA mapData = {0};
    ReadProcessMemory(hProc, pTargetBase + ImageSize, &mapData, sizeof(mapData), nullptr);
    hCheck = mapData.hMod;
    Sleep(10);
  }

  printf("[*] Loading routine successfully completed. Cleaning up!\n");
  CloseHandle(hThread);

  return true;
}

// clean wrapper for the public api
bool w1::inject::windows::inject_dll_reflective_loader(process_handle h_process, const std::wstring& dll_path) {
  HANDLE win_handle = static_cast<HANDLE>(h_process);
  BOOL result = inject_dll_reflective_loader_impl(win_handle, dll_path);
  return result != FALSE;
}

#define RELOC_FLAG32(relInfo) ((relInfo >> 0xC) == IMAGE_REL_BASED_HIGHLOW)
#define RELOC_FLAG64(relInfo) ((relInfo >> 0xC) == IMAGE_REL_BASED_DIR64)

#ifdef _WIN64
#define RELOC_FLAG RELOC_FLAG64
#else
#define RELOC_FLAG RELOC_FLAG32
#endif

void __stdcall LoaderStub(BYTE* imageBase) {
  if (!imageBase) {
    return;
  }

  // obtain pointers to the base address, optional header, and DLLMain function using the library mapped in memory as
  // our argument.
  BYTE* pBase = imageBase;
  auto* pOpt = &reinterpret_cast<IMAGE_NT_HEADERS*>(pBase + reinterpret_cast<IMAGE_DOS_HEADER*>(imageBase)->e_lfanew)
                    ->OptionalHeader;
  auto _DllMain = reinterpret_cast<f_DLL_ENTRY_POINT>(pBase + pOpt->AddressOfEntryPoint);

  // create a pointer to our mapping data by offsetting the size of the image.
  MANUAL_MAPPING_DATA* pMapData = reinterpret_cast<MANUAL_MAPPING_DATA*>(imageBase + pOpt->SizeOfImage);

  // obtain pointers to tthe LoadLibrary and GetProcAddress functions.
  auto _LoadLibraryA = pMapData->pLoadLibraryA;
  auto _GetProcAddress = pMapData->pGetProcAddress;

  // obtain Relocation Delta.
  BYTE* LocationDelta = pBase - pOpt->ImageBase;
  if (LocationDelta) {
    // ensure there is entries in the relocation table. If not just continue.
    if (!pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size) {
      return;
    }

    // obtain a pointer to the relocation data. Using our mapped image + offset of relocation table's virtual address.
    auto* pRelocData = reinterpret_cast<IMAGE_BASE_RELOCATION*>(
        pBase + pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress
    );

    // while there are entires in the relocation table:
    while (pRelocData->VirtualAddress) {
      // obtain amount of entries for this part of the table.
      UINT AmountOfEntries = (pRelocData->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
      WORD* pRelativeInfo = reinterpret_cast<WORD*>(pRelocData + 1); // obtain the relocation type.
      for (UINT i = 0; i != AmountOfEntries; i++, pRelativeInfo++) {
        if (RELOC_FLAG(*pRelativeInfo)) {
          // obtain the virtual address for our relocation entry.
          UINT_PTR* pPatch =
              reinterpret_cast<UINT_PTR*>(pBase + pRelocData->VirtualAddress + ((*pRelativeInfo) & 0xFFF));
          // add the delta to relocate it to the correct location of the module mapped in the current memory space.
          *pPatch += reinterpret_cast<UINT_PTR>(LocationDelta);
        }
      }
      // obtain next entry in the table.
      pRelocData =
          reinterpret_cast<IMAGE_BASE_RELOCATION*>(reinterpret_cast<BYTE*>(pRelocData) + pRelocData->SizeOfBlock);
    }
  }

  // obtain entries from the import table/
  if (pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size) {
    // obtain the virtual address of the importDescriptor table.
    auto* pImportDescriptor = reinterpret_cast<IMAGE_IMPORT_DESCRIPTOR*>(
        pBase + pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress
    );
    while (pImportDescriptor->Name) {
      // setup pointers to the imported library / function name.
      char* szMod = reinterpret_cast<char*>(pBase + pImportDescriptor->Name);
      HINSTANCE hDLL = _LoadLibraryA(szMod);
      ULONG_PTR* pThunkRef = reinterpret_cast<ULONG_PTR*>(pBase + pImportDescriptor->OriginalFirstThunk);
      ULONG_PTR* pFuncRef = reinterpret_cast<ULONG_PTR*>(pBase + pImportDescriptor->FirstThunk);

      // if the First thunk is null use the next one.
      if (!pThunkRef) {
        pThunkRef = pFuncRef;
      }

      // loop through each function.
      for (; *pThunkRef; ++pThunkRef, ++pFuncRef) {
        // GetProceAddress(lib, "ReadProcessMemory"); name
        // GetProcAddress(lib, (char*)42); ordinal

        // import the functions by ordinal or name.
        if (IMAGE_SNAP_BY_ORDINAL(*pThunkRef)) {
          *pFuncRef = _GetProcAddress(hDLL, reinterpret_cast<char*>(*pThunkRef & 0xFFFF));
        } else {
          auto pImport = reinterpret_cast<IMAGE_IMPORT_BY_NAME*>(pBase + (*pThunkRef));
          *pFuncRef = _GetProcAddress(hDLL, pImport->Name);
        }
      }
      // obtain the next descriptor entry.
      ++pImportDescriptor;
    }
  }

  // find the callback routines and attach them.
  if (pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size) {
    auto* pTLS =
        reinterpret_cast<IMAGE_TLS_DIRECTORY*>(pBase + pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);
    auto* pCallBack = reinterpret_cast<PIMAGE_TLS_CALLBACK*>(pTLS->AddressOfCallBacks);
    for (; pCallBack && *pCallBack; ++pCallBack) {
      (*pCallBack)(pBase, DLL_PROCESS_ATTACH, nullptr);
    }
  }

  // execute our DLL by calling the entrypoint address with the argument of DLL_PROCESS_ATTACH.

  // TODO: Write Code that will accept arguments and pass them to the DLLMain function.
  _DllMain(pBase, DLL_PROCESS_ATTACH, nullptr);

  // set our hMod value in our map data so that we can read it from our original process and determine that DLL has been
  // executed properly.
  pMapData->hMod = reinterpret_cast<HINSTANCE>(pBase);
}

```

`src/w1nj3ct/backend/windows/inject_rtlcreateuserthread.cpp`:

```cpp
#include <sstream>

#ifndef NOMINMAX
#define NOMINMAX
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "winapis.h"
#include "inject.hpp"
#include "util.hpp"

// internal windows implementation
static BOOL inject_dll_rtl_create_user_thread_impl(HANDLE h_process, const std::wstring& dll_path) {
  log_msg("starting RtlCreateUserThread injection method");

  // allocate memory in the target process for the dll path
  log_msg("allocating memory in the target process");
  LPVOID remote_memory = VirtualAllocEx(h_process, NULL, dll_path.size() * sizeof(wchar_t), MEM_COMMIT, PAGE_READWRITE);
  if (!remote_memory) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to allocate memory in the target process. Error code: " << error;
    log_msg(ss.str());
    return FALSE;
  }
  log_msg("memory allocated successfully");

  // write the dll path to the allocated memory in the target process
  log_msg("writing DLL path to the allocated memory");
  SIZE_T bytes_written;
  if (!WriteProcessMemory(
          h_process, remote_memory, dll_path.c_str(), dll_path.size() * sizeof(wchar_t), &bytes_written
      )) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to write to process memory. Error code: " << error;
    log_msg(ss.str());
    VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE);
    return FALSE;
  }
  if (bytes_written != dll_path.size() * sizeof(wchar_t)) {
    log_msg("incomplete write to process memory");
    VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE);
    return FALSE;
  }
  log_msg("DLL path written successfully");

  // get the address of LoadLibraryW function
  log_msg("getting address of LoadLibraryW");
  LPTHREAD_START_ROUTINE load_library_addr =
      (LPTHREAD_START_ROUTINE) GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "LoadLibraryW");
  if (!load_library_addr) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to get address of LoadLibraryW. Error code: " << error;
    log_msg(ss.str());
    VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE);
    return FALSE;
  }
  {
    std::stringstream ss;
    ss << "loadLibraryW address obtained: " << std::hex << load_library_addr;
    log_msg(ss.str());
  }

  // get the address of RtlCreateUserThread function
  log_msg("getting address of RtlCreateUserThread");
  pRtlCreateUserThread RtlCreateUserThread =
      (pRtlCreateUserThread) GetProcAddress(GetModuleHandle(TEXT("ntdll.dll")), "RtlCreateUserThread");
  if (!RtlCreateUserThread) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to get address of RtlCreateUserThread. Error code: " << error;
    log_msg(ss.str());
    VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE);
    return FALSE;
  }
  {
    std::stringstream ss;
    ss << "rtlCreateUserThread address obtained: " << std::hex << (void*) RtlCreateUserThread;
    log_msg(ss.str());
  }

  // create a remote thread using RtlCreateUserThread
  log_msg("creating remote thread using RtlCreateUserThread");
  HANDLE h_thread = NULL;
  DWORD status =
      RtlCreateUserThread(h_process, NULL, FALSE, 0, NULL, NULL, load_library_addr, remote_memory, &h_thread, NULL);

  if (status != 0) {
    std::stringstream ss;
    ss << "Failed to create remote thread. Status: " << std::hex << status;
    log_msg(ss.str());
    VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE);
    return FALSE;
  }
  log_msg("remote thread created successfully");

  // wait for the remote thread to finish executing
  log_msg("waiting for remote thread to finish");
  DWORD wait_result = WaitForSingleObject(h_thread, INFINITE);
  if (wait_result != WAIT_OBJECT_0) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "WaitForSingleObject failed. Error code: " << error;
    log_msg(ss.str());
    CloseHandle(h_thread);
    VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE);
    return FALSE;
  }
  log_msg("remote thread finished execution");

  // get the exit code of the remote thread to check if dll injection was successful
  DWORD exit_code;
  if (GetExitCodeThread(h_thread, &exit_code)) {
    std::stringstream ss;
    ss << "remote thread exit code: " << exit_code;
    log_msg(ss.str());
    if (exit_code == 0) {
      log_msg("DLL injection may have failed (exit code is 0)");
    }
  } else {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to get remote thread exit code. Error code: " << error;
    log_msg(ss.str());
  }

  // clean up resources
  log_msg("cleaning up");
  if (!VirtualFreeEx(h_process, remote_memory, 0, MEM_RELEASE)) {
    DWORD error = GetLastError();
    std::stringstream ss;
    ss << "Failed to free memory in target process. Error code: " << error;
    log_msg(ss.str());
  }
  CloseHandle(h_thread);

  log_msg("RtlCreateUserThread injection completed");
  return TRUE;
}

// clean wrapper for the public api
bool w1::inject::windows::inject_dll_rtl_create_user_thread(process_handle h_process, const std::wstring& dll_path) {
  HANDLE win_handle = static_cast<HANDLE>(h_process);
  BOOL result = inject_dll_rtl_create_user_thread_impl(win_handle, dll_path);
  return result != FALSE;
}

```

`src/w1nj3ct/backend/windows/inject_setwindowshook.cpp`:

```cpp
#ifndef NOMINMAX
#define NOMINMAX
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <tlhelp32.h>
#include <sstream>
#include "util.hpp"
#include "inject.hpp"

// hook procedure that will be called by the windows hook
LRESULT CALLBACK hook_proc(int n_code, WPARAM w_param, LPARAM l_param) {
  log_msg("hook_proc called");
  return CallNextHookEx(NULL, n_code, w_param, l_param);
}

// internal windows implementation
static BOOL inject_dll_set_windows_hook_ex_impl(HANDLE h_process, DWORD process_id, const std::wstring& dll_path) {
  // this function injects a dll into a target process using the setwindowshookex method
  log_msg("starting setwindowshookex injection method");

  // load the dll into the current process
  log_msg("loading dll into current process");
  HMODULE h_module = LoadLibraryW(dll_path.c_str());
  if (!h_module) {
    log_msg("failed to load dll");
    return FALSE;
  }
  log_msg("dll loaded successfully");

  // get the address of the hook procedure from the loaded dll
  log_msg("getting address of hook_proc");
  HOOKPROC hook_proc = (HOOKPROC) GetProcAddress(h_module, "hook_proc");
  if (!hook_proc) {
    log_msg("failed to get address of hook_proc");
    FreeLibrary(h_module);
    return FALSE;
  }
  log_msg("hook_proc address obtained");

  // resume the main thread of the target process
  log_msg("resuming main thread of target process");
  if (ResumeThread(h_process) == -1) {
    log_msg("failed to resume thread");
    FreeLibrary(h_module);
    return FALSE;
  }

  // wait a bit to ensure the process has started
  Sleep(1000);

  // find a thread id for the target process
  log_msg("finding a thread id for the target process");
  DWORD thread_id = 0;
  HANDLE h_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
  if (h_snapshot == INVALID_HANDLE_VALUE) {
    log_msg("failed to create thread snapshot");
    FreeLibrary(h_module);
    return FALSE;
  }

  THREADENTRY32 te;
  te.dwSize = sizeof(THREADENTRY32);
  if (Thread32First(h_snapshot, &te)) {
    do {
      if (te.th32OwnerProcessID == process_id) {
        thread_id = te.th32ThreadID;
        break;
      }
    } while (Thread32Next(h_snapshot, &te));
  }
  CloseHandle(h_snapshot);

  if (thread_id == 0) {
    log_msg("failed to find a thread for the target process");
    FreeLibrary(h_module);
    return FALSE;
  }
  log_msg("found thread id: " + std::to_string(thread_id));

  // set the windows hook
  log_msg("setting windows hook");
  HHOOK hook = SetWindowsHookEx(WH_GETMESSAGE, hook_proc, h_module, thread_id);
  if (!hook) {
    log_msg("failed to set windows hook");
    FreeLibrary(h_module);
    return FALSE;
  }
  log_msg("windows hook set successfully");

  // post a message to the thread to trigger the hook
  log_msg("posting message to trigger hook");
  if (!PostThreadMessage(thread_id, WM_NULL, 0, 0)) {
    log_msg("failed to post thread message");
    // continue anyway, as the hook might still work
  }

  // wait a bit to ensure the hook has been triggered
  Sleep(1000);

  // unhook and clean up
  log_msg("unhooking and cleaning up");
  UnhookWindowsHookEx(hook);
  FreeLibrary(h_module);

  log_msg("setwindowshookex injection completed successfully");
  return TRUE;
}

// clean wrapper for the public api
bool w1::inject::windows::inject_dll_set_windows_hook_ex(
    process_handle h_process, process_id pid, const std::wstring& dll_path
) {
  HANDLE win_handle = static_cast<HANDLE>(h_process);
  DWORD win_pid = static_cast<DWORD>(pid);
  BOOL result = inject_dll_set_windows_hook_ex_impl(win_handle, win_pid, dll_path);
  return result != FALSE;
}

```

`src/w1nj3ct/backend/windows/util.hpp`:

```hpp
#pragma once

#include <iostream>
#include <string>

// log helpers
static inline void log_msg(const std::string& msg) { std::cout << msg << std::endl; }
static inline void log_path(const std::string& msg, const std::string& path) { log_msg(msg + " [" + path + "]"); }

```

`src/w1nj3ct/backend/windows/winapis.h`:

```h
#pragma once

// This file needs raw Windows headers for API definitions
// It should only be included by inject.hpp which isolates the pollution
#ifndef NOMINMAX
#define NOMINMAX
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

// define NTSTATUS if not already defined
#ifndef NTSTATUS
typedef LONG NTSTATUS;
#endif

/**
 * some windows api function pointers for "less documented" functions
 */

struct NtCreateThreadExBuffer {
  ULONG Size;
  ULONG Unknown1;
  ULONG Unknown2;
  PULONG Unknown3;
  ULONG Unknown4;
  ULONG Unknown5;
  ULONG Unknown6;
  PULONG Unknown7;
  ULONG Unknown8;
};

typedef NTSTATUS (WINAPI* LPFUN_NtCreateThreadEx)(
    PHANDLE hThread, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle,
    LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, ULONG StackZeroBits,
    ULONG SizeOfStackCommit, ULONG SizeOfStackReserve, LPVOID lpBytesBuffer
);
// function Pointer Typedef for RtlCreateUserThread
typedef DWORD (WINAPI* pRtlCreateUserThread)(
    HANDLE ProcessHandle, PSECURITY_DESCRIPTOR SecurityDescriptor, BOOL CreateSuspended,
    ULONG StackZeroBits, PULONG StackReserved, PULONG StackCommit, LPVOID StartAddress,
    LPVOID StartParameter, HANDLE ThreadHandle, LPVOID ClientID
);

```

`src/w1nj3ct/error.cpp`:

```cpp
#include "error.hpp"

#ifdef _WIN32
#include <w1common/windows_clean.hpp>
#elif defined(__APPLE__)
#include <errno.h>
#include <mach/mach.h>
#elif defined(__linux__)
#include <errno.h>
#endif

namespace w1::inject {

std::string error_code_to_string(error_code code) {
  switch (code) {
  case error_code::success:
    return "success";
  case error_code::target_not_found:
    return "target process not found";
  case error_code::multiple_targets_found:
    return "multiple target processes found";
  case error_code::target_access_denied:
    return "access denied to target process";
  case error_code::target_invalid_architecture:
    return "target process has incompatible architecture";
  case error_code::library_not_found:
    return "library file not found";
  case error_code::library_invalid:
    return "library file is invalid";
  case error_code::library_incompatible:
    return "library is incompatible with target process";
  case error_code::injection_failed:
    return "injection operation failed";
  case error_code::injection_timeout:
    return "injection operation timed out";
  case error_code::injection_already_loaded:
    return "library is already loaded in target process";
  case error_code::platform_not_supported:
    return "platform not supported";
  case error_code::technique_not_supported:
    return "injection technique not supported";
  case error_code::insufficient_privileges:
    return "insufficient privileges for injection";
  case error_code::out_of_memory:
    return "out of memory";
  case error_code::system_error:
    return "system error";
  case error_code::configuration_invalid:
    return "invalid configuration";
  case error_code::launch_failed:
    return "failed to launch process";
  case error_code::launch_timeout:
    return "process launch timed out";
  case error_code::unknown_error:
  default:
    return "unknown error";
  }
}

error_code translate_platform_error(int platform_error) {
#ifdef _WIN32
  switch (platform_error) {
  case ERROR_ACCESS_DENIED:
    return error_code::target_access_denied;
  case ERROR_FILE_NOT_FOUND:
  case ERROR_PATH_NOT_FOUND:
    return error_code::library_not_found;
  case ERROR_INVALID_HANDLE:
    return error_code::target_not_found;
  case ERROR_NOT_ENOUGH_MEMORY:
  case ERROR_OUTOFMEMORY:
    return error_code::out_of_memory;
  case ERROR_INVALID_PARAMETER:
    return error_code::configuration_invalid;
  case ERROR_TIMEOUT:
    return error_code::injection_timeout;
  default:
    return error_code::system_error;
  }
#elif defined(__APPLE__)
  switch (platform_error) {
  case KERN_PROTECTION_FAILURE:
    return error_code::target_access_denied;
  case KERN_INVALID_ARGUMENT:
    return error_code::configuration_invalid;
  case KERN_NO_SPACE:
  case KERN_RESOURCE_SHORTAGE:
    return error_code::out_of_memory;
  case KERN_FAILURE:
    return error_code::injection_failed;
  default:
    // also check errno for posix errors
    switch (errno) {
    case EACCES:
    case EPERM:
      return error_code::target_access_denied;
    case ENOENT:
      return error_code::library_not_found;
    case ESRCH:
      return error_code::target_not_found;
    case ENOMEM:
      return error_code::out_of_memory;
    case ETIMEDOUT:
      return error_code::injection_timeout;
    default:
      return error_code::system_error;
    }
  }
#elif defined(__linux__)
  switch (platform_error) {
  case EACCES:
  case EPERM:
    return error_code::target_access_denied;
  case ENOENT:
    return error_code::library_not_found;
  case ESRCH:
    return error_code::target_not_found;
  case ENOMEM:
    return error_code::out_of_memory;
  case EINVAL:
    return error_code::configuration_invalid;
  case ETIMEDOUT:
    return error_code::injection_timeout;
  default:
    return error_code::system_error;
  }
#endif
  return error_code::system_error;
}

bool is_recoverable_error(error_code code) {
  switch (code) {
  case error_code::injection_timeout:
  case error_code::target_not_found:
  case error_code::multiple_targets_found:
  case error_code::library_not_found:
  case error_code::injection_already_loaded:
    return true;
  default:
    return false;
  }
}

std::string format_error_message(error_code code, const std::string& context) {
  std::string base_message = error_code_to_string(code);

  switch (code) {
  case error_code::insufficient_privileges:
#ifdef _WIN32
    return base_message + ". try running as administrator";
#else
    return base_message + ". try running as root or with appropriate capabilities";
#endif
  case error_code::multiple_targets_found:
    return base_message + ". use find_processes() to list all matches and select specific pid";
  case error_code::target_access_denied:
#ifdef __APPLE__
    return base_message + ". check code signing entitlements and sip status";
#else
    return base_message + ". check process permissions and ptrace scope";
#endif
  case error_code::platform_not_supported:
    return base_message + ". this platform is not yet supported by w1nj3ct";
  case error_code::technique_not_supported:
#ifdef _WIN32
    return base_message + ". try a different windows_technique";
#else
    return base_message + ". preload injection not supported on this platform";
#endif
  default:
    break;
  }

  return base_message + (context.empty() ? "" : " (" + context + ")");
}

result make_error_result(error_code code, const std::string& context, int platform_error) {
  result res;
  res.code = code;
  res.error_message = format_error_message(code, context);
  if (platform_error != 0) {
    res.system_error_code = platform_error;
  }
  return res;
}

result make_success_result(int target_pid) {
  result res;
  res.code = error_code::success;
  res.target_pid = target_pid;
  return res;
}

} // namespace w1::inject
```

`src/w1nj3ct/error.hpp`:

```hpp
#pragma once

#include "w1nj3ct.hpp"
#include <string>

#ifdef _WIN32
#include <w1common/windows_clean.hpp>
#endif

namespace w1::inject {
// error code to string conversion
std::string error_code_to_string(error_code code);

// platform-specific error translation
error_code translate_platform_error(int platform_error);

#ifdef _WIN32
std::string translate_platform_error(DWORD error_code);
#endif

// recoverable vs non-recoverable error classification
bool is_recoverable_error(error_code code);

// detailed error message formatting with context
std::string format_error_message(error_code code, const std::string& context = "");

// create result with platform error translation
result make_error_result(error_code code, const std::string& context = "", int platform_error = 0);

// helper for creating success result
result make_success_result(int target_pid = -1);
} // namespace w1::inject
```

`src/w1nj3ct/platform/darwin/darwin_injector.cpp`:

```cpp
#include "darwin_injector.hpp"
#include "error.hpp"
#include <chrono>
#include <redlog.hpp>

// include the darwin injection backend
extern "C" {
#include "darwin/injector.h"
}

#include <crt_externs.h>
#include <cstdlib>
#include <libproc.h>
#include <sys/sysctl.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

namespace w1::inject::darwin {

result inject_runtime(const config& cfg) {
  auto log = redlog::get_logger("w1nj3ct.darwin");

  log.info("darwin runtime injection starting", redlog::field("library_path", cfg.library_path));

  // validate we have a target
  if (!cfg.pid && !cfg.process_name) {
    log.error("no target specified for runtime injection");
    return make_error_result(error_code::configuration_invalid, "no target specified");
  }

  int target_pid = -1;

  // resolve process name to pid if needed
  if (cfg.process_name) {
    log.debug("resolving process name to pid", redlog::field("name", *cfg.process_name));

    auto processes = find_processes_by_name(*cfg.process_name);
    if (processes.empty()) {
      log.error("no processes found with specified name", redlog::field("name", *cfg.process_name));
      return make_error_result(error_code::target_not_found, *cfg.process_name);
    }
    if (processes.size() > 1) {
      log.error(
          "multiple processes found with specified name", redlog::field("name", *cfg.process_name),
          redlog::field("count", processes.size())
      );
      for (const auto& proc : processes) {
        log.verbose(
            "found process", redlog::field("pid", proc.pid), redlog::field("name", proc.name),
            redlog::field("path", proc.full_path)
        );
      }
      return make_error_result(error_code::multiple_targets_found, *cfg.process_name);
    }
    target_pid = processes[0].pid;
    log.info(
        "resolved process name to pid", redlog::field("name", *cfg.process_name), redlog::field("pid", target_pid),
        redlog::field("path", processes[0].full_path)
    );
  } else {
    target_pid = *cfg.pid;
    log.debug("using specified pid", redlog::field("pid", target_pid));

    // validate target process exists
    auto proc_info = get_process_info(target_pid);
    if (proc_info) {
      log.verbose(
          "target process validated", redlog::field("pid", target_pid), redlog::field("name", proc_info->name),
          redlog::field("path", proc_info->full_path)
      );
    } else {
      log.warn("target process info not available", redlog::field("pid", target_pid));
    }
  }

  // use existing injector backend
  auto attach_start = std::chrono::steady_clock::now();
  log.debug("attaching to target process", redlog::field("pid", target_pid));

  injector_t* injector = nullptr;
  int err = injector_attach(&injector, target_pid);
  if (err != INJERR_SUCCESS) {
    error_code mapped_error;
    std::string error_detail = injector_error();

    switch (err) {
    case INJERR_NO_PROCESS:
      mapped_error = error_code::target_not_found;
      log.error(
          "target process not found during attach", redlog::field("pid", target_pid),
          redlog::field("injector_error", error_detail), redlog::field("error_code", err)
      );
      break;
    case INJERR_PERMISSION:
      mapped_error = error_code::target_access_denied;
      log.error(
          "permission denied attaching to target process", redlog::field("pid", target_pid),
          redlog::field("injector_error", error_detail), redlog::field("error_code", err),
          redlog::field("uid", getuid()), redlog::field("euid", geteuid())
      );
      break;
    case INJERR_NO_MEMORY:
      mapped_error = error_code::out_of_memory;
      log.error(
          "out of memory during process attach", redlog::field("pid", target_pid),
          redlog::field("injector_error", error_detail), redlog::field("error_code", err)
      );
      break;
    default:
      mapped_error = error_code::injection_failed;
      log.error(
          "unknown error during process attach", redlog::field("pid", target_pid),
          redlog::field("injector_error", error_detail), redlog::field("error_code", err)
      );
      break;
    }
    return make_error_result(mapped_error, error_detail, err);
  }

  auto attach_duration = std::chrono::steady_clock::now() - attach_start;
  auto attach_ms = std::chrono::duration_cast<std::chrono::milliseconds>(attach_duration).count();

  log.info(
      "successfully attached to target process", redlog::field("pid", target_pid),
      redlog::field("attach_time_ms", attach_ms)
  );

  // inject the library
  auto inject_start = std::chrono::steady_clock::now();
  log.debug(
      "injecting library into target process", redlog::field("pid", target_pid),
      redlog::field("library_path", cfg.library_path)
  );

  void* handle = nullptr;
  err = injector_inject(injector, cfg.library_path.c_str(), &handle);

  // cleanup injector regardless of result
  injector_detach(injector);
  log.trace("detached from target process", redlog::field("pid", target_pid));

  if (err != INJERR_SUCCESS) {
    error_code mapped_error;
    std::string error_detail = injector_error();

    switch (err) {
    case INJERR_FILE_NOT_FOUND:
      mapped_error = error_code::library_not_found;
      log.error(
          "library file not found during injection", redlog::field("pid", target_pid),
          redlog::field("library_path", cfg.library_path), redlog::field("injector_error", error_detail),
          redlog::field("error_code", err)
      );
      break;
    case INJERR_NO_MEMORY:
      mapped_error = error_code::out_of_memory;
      log.error(
          "out of memory during library injection", redlog::field("pid", target_pid),
          redlog::field("library_path", cfg.library_path), redlog::field("injector_error", error_detail),
          redlog::field("error_code", err)
      );
      break;
    case INJERR_ERROR_IN_TARGET:
      mapped_error = error_code::injection_failed;
      log.error(
          "error in target process during injection", redlog::field("pid", target_pid),
          redlog::field("library_path", cfg.library_path), redlog::field("injector_error", error_detail),
          redlog::field("error_code", err)
      );
      break;
    case INJERR_PERMISSION:
      mapped_error = error_code::target_access_denied;
      log.error(
          "permission denied during library injection", redlog::field("pid", target_pid),
          redlog::field("library_path", cfg.library_path), redlog::field("injector_error", error_detail),
          redlog::field("error_code", err)
      );
      break;
    case INJERR_UNSUPPORTED_TARGET:
      mapped_error = error_code::target_invalid_architecture;
      log.error(
          "unsupported target architecture", redlog::field("pid", target_pid),
          redlog::field("library_path", cfg.library_path), redlog::field("injector_error", error_detail),
          redlog::field("error_code", err)
      );
      break;
    default:
      mapped_error = error_code::injection_failed;
      log.error(
          "unknown error during library injection", redlog::field("pid", target_pid),
          redlog::field("library_path", cfg.library_path), redlog::field("injector_error", error_detail),
          redlog::field("error_code", err)
      );
      break;
    }
    return make_error_result(mapped_error, error_detail, err);
  }

  auto inject_duration = std::chrono::steady_clock::now() - inject_start;
  auto inject_ms = std::chrono::duration_cast<std::chrono::milliseconds>(inject_duration).count();
  auto total_ms =
      std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - attach_start).count();

  log.info(
      "runtime injection completed successfully", redlog::field("pid", target_pid),
      redlog::field("library_path", cfg.library_path), redlog::field("handle", handle),
      redlog::field("inject_time_ms", inject_ms), redlog::field("total_time_ms", total_ms)
  );

  return make_success_result(target_pid);
}

result inject_preload(const config& cfg) {
  auto log = redlog::get_logger("w1nj3ct.darwin");

  log.info(
      "darwin preload injection starting", redlog::field("binary_path", cfg.binary_path ? *cfg.binary_path : "null"),
      redlog::field("library_path", cfg.library_path)
  );

  if (!cfg.binary_path) {
    log.error("binary_path required for preload injection");
    return make_error_result(error_code::configuration_invalid, "binary_path required for preload injection");
  }

  // validate binary exists and is executable
  if (access(cfg.binary_path->c_str(), F_OK) != 0) {
    log.error("target binary not found", redlog::field("binary_path", *cfg.binary_path), redlog::field("errno", errno));
    return make_error_result(error_code::target_not_found, "binary not found: " + *cfg.binary_path);
  }

  if (access(cfg.binary_path->c_str(), X_OK) != 0) {
    log.error(
        "target binary not executable", redlog::field("binary_path", *cfg.binary_path), redlog::field("errno", errno)
    );
    return make_error_result(error_code::target_access_denied, "binary not executable: " + *cfg.binary_path);
  }

  log.debug("target binary validated", redlog::field("binary_path", *cfg.binary_path));

  // set up environment with DYLD_INSERT_LIBRARIES
  log.debug("setting up injection environment");

  // start with current environment
  std::map<std::string, std::string> env;
  char*** environ_ptr = _NSGetEnviron();
  size_t base_env_count = 0;

  if (environ_ptr && *environ_ptr) {
    for (char** ep = *environ_ptr; *ep; ep++) {
      std::string env_var(*ep);
      size_t eq_pos = env_var.find('=');
      if (eq_pos != std::string::npos) {
        std::string key = env_var.substr(0, eq_pos);
        std::string value = env_var.substr(eq_pos + 1);
        env[key] = value;
        base_env_count++;
      }
    }
  }

  log.trace("inherited environment variables", redlog::field("count", base_env_count));

  // add/override with cfg.env_vars
  for (const auto& [key, value] : cfg.env_vars) {
    env[key] = value;
    log.verbose("adding environment variable", redlog::field("key", key), redlog::field("value", value));
  }

  // add DYLD_INSERT_LIBRARIES
  env["DYLD_INSERT_LIBRARIES"] = cfg.library_path;
  log.info("configured DYLD_INSERT_LIBRARIES", redlog::field("library_path", cfg.library_path));

  // warn about potential SIP issues
  if (cfg.binary_path->find("/System/") == 0 || cfg.binary_path->find("/usr/bin/") == 0 ||
      cfg.binary_path->find("/bin/") == 0) {
    log.warn("injecting into system binary may fail due to SIP", redlog::field("binary_path", *cfg.binary_path));
  }

  // build command line
  std::vector<const char*> argv;
  argv.push_back(cfg.binary_path->c_str());
  for (const auto& arg : cfg.args) {
    argv.push_back(arg.c_str());
    log.trace("adding command argument", redlog::field("arg", arg));
  }
  argv.push_back(nullptr);

  log.debug("command line prepared", redlog::field("argc", argv.size() - 1));

  // build environment
  std::vector<std::string> env_strings;
  std::vector<const char*> envp;

  // first pass: populate all strings to avoid reallocation
  env_strings.reserve(env.size());
  for (const auto& [key, value] : env) {
    env_strings.push_back(key + "=" + value);
  }

  // second pass: collect pointers after all strings are in place
  envp.reserve(env.size() + 1);
  for (const auto& env_str : env_strings) {
    envp.push_back(env_str.c_str());
  }
  envp.push_back(nullptr);

  log.debug("environment prepared", redlog::field("vars", env.size()), redlog::field("total_vars", envp.size() - 1));

  // fork and exec with modified environment
  log.debug("forking child process for preload injection");

  pid_t child_pid = fork();
  if (child_pid == 0) {
    // child process
    log.trace("child process executing target binary", redlog::field("binary_path", *cfg.binary_path));

    execve(cfg.binary_path->c_str(), const_cast<char**>(argv.data()), const_cast<char**>(envp.data()));

    // execve only returns on error
    int exec_errno = errno;
    fprintf(stderr, "[w1nj3ct.darwin] execve failed: %s (errno=%d)\n", strerror(exec_errno), exec_errno);
    _exit(1);
  } else if (child_pid > 0) {
    // parent process: wait for child to complete
    log.info(
        "preload injection started successfully", redlog::field("pid", child_pid),
        redlog::field("binary_path", *cfg.binary_path), redlog::field("library_path", cfg.library_path)
    );

    if (cfg.wait_for_completion) {
      log.debug("waiting for child process to complete", redlog::field("pid", child_pid));

      int status;
      pid_t wait_result = waitpid(child_pid, &status, 0);

      if (wait_result == -1) {
        int wait_errno = errno;
        log.error(
            "failed to wait for child process", redlog::field("pid", child_pid), redlog::field("errno", wait_errno),
            redlog::field("error", strerror(wait_errno))
        );
        return make_error_result(error_code::launch_failed, "waitpid failed", wait_errno);
      }

      if (WIFEXITED(status)) {
        int exit_code = WEXITSTATUS(status);
        if (exit_code == 0) {
          log.info(
              "preload injection completed successfully", redlog::field("pid", child_pid),
              redlog::field("exit_code", exit_code)
          );
          return make_success_result(child_pid);
        } else {
          log.error(
              "child process exited with non-zero status", redlog::field("pid", child_pid),
              redlog::field("exit_code", exit_code)
          );
          return make_error_result(
              error_code::launch_failed, "child process failed with exit code " + std::to_string(exit_code)
          );
        }
      } else if (WIFSIGNALED(status)) {
        int signal = WTERMSIG(status);
        log.error(
            "child process terminated by signal", redlog::field("pid", child_pid), redlog::field("signal", signal),
            redlog::field("signal_name", strsignal(signal))
        );
        return make_error_result(
            error_code::launch_failed, "child process terminated by signal " + std::to_string(signal)
        );
      } else {
        log.error(
            "child process exited with unknown status", redlog::field("pid", child_pid), redlog::field("status", status)
        );
        return make_error_result(error_code::launch_failed, "child process exited with unknown status");
      }
    } else {
      log.info("preload injection started successfully - not waiting for completion", redlog::field("pid", child_pid));
      return make_success_result(child_pid);
    }
  } else {
    // fork failed
    int fork_errno = errno;
    log.error(
        "fork failed during preload injection", redlog::field("binary_path", *cfg.binary_path),
        redlog::field("errno", fork_errno), redlog::field("error", strerror(fork_errno))
    );

    return make_error_result(error_code::launch_failed, "fork failed", fork_errno);
  }
}

std::vector<process_info> list_processes() {
  auto log = redlog::get_logger("w1nj3ct.darwin");
  std::vector<process_info> processes;

  log.trace("listing all processes");

  // get process count
  int mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_ALL, 0};
  size_t size = 0;
  if (sysctl(mib, 4, nullptr, &size, nullptr, 0) != 0) {
    log.error("failed to get process list size", redlog::field("errno", errno));
    return processes;
  }

  // get process list
  size_t count = size / sizeof(struct kinfo_proc);
  log.debug("retrieving process list", redlog::field("estimated", count));

  std::vector<struct kinfo_proc> procs(count);
  if (sysctl(mib, 4, procs.data(), &size, nullptr, 0) != 0) {
    log.error("failed to retrieve process list", redlog::field("errno", errno));
    return processes;
  }

  // convert to our format
  size_t path_failures = 0;
  for (const auto& proc : procs) {
    process_info info;
    info.pid = proc.kp_proc.p_pid;
    info.name = proc.kp_proc.p_comm;

    // get full path using libproc
    char pathbuf[PROC_PIDPATHINFO_MAXSIZE];
    if (proc_pidpath(info.pid, pathbuf, sizeof(pathbuf)) > 0) {
      info.full_path = pathbuf;
    } else {
      path_failures++;
    }

    processes.push_back(info);
  }

  log.debug(
      "process list retrieved", redlog::field("total_processes", processes.size()),
      redlog::field("path_lookup_failures", path_failures)
  );

  return processes;
}

std::vector<process_info> find_processes_by_name(const std::string& name) {
  auto log = redlog::get_logger("w1nj3ct.darwin");

  log.debug("searching for processes by name", redlog::field("target_name", name));

  std::vector<process_info> matches;
  auto all_processes = list_processes();

  for (const auto& proc : all_processes) {
    if (proc.name == name) {
      matches.push_back(proc);
      log.verbose(
          "found matching process", redlog::field("pid", proc.pid), redlog::field("name", proc.name),
          redlog::field("path", proc.full_path)
      );
    }
  }

  log.debug(
      "process search completed", redlog::field("target_name", name), redlog::field("matches_found", matches.size()),
      redlog::field("total_searched", all_processes.size())
  );

  return matches;
}

std::optional<process_info> get_process_info(int pid) {
  auto log = redlog::get_logger("w1nj3ct.darwin");

  log.trace("looking up process info", redlog::field("pid", pid));

  auto all_processes = list_processes();

  for (const auto& proc : all_processes) {
    if (proc.pid == pid) {
      log.trace(
          "found process info", redlog::field("pid", proc.pid), redlog::field("name", proc.name),
          redlog::field("path", proc.full_path)
      );
      return proc;
    }
  }

  log.debug("process not found", redlog::field("pid", pid), redlog::field("searched", all_processes.size()));

  return std::nullopt;
}

bool check_injection_capabilities() {
  auto log = redlog::get_logger("w1nj3ct.darwin");

  log.debug("checking darwin injection capabilities");

  // try to create a test injector to check permissions
  injector_t* injector = nullptr;
  int current_pid = getpid();

  log.trace("attempting self-injection test", redlog::field("pid", current_pid));

  int err = injector_attach(&injector, current_pid);

  if (err == INJERR_SUCCESS) {
    injector_detach(injector);
    log.debug("injection capabilities verified - self-attach successful");
    return true;
  } else {
    log.warn(
        "injection capabilities limited - self-attach failed", redlog::field("error_code", err),
        redlog::field("injector_error", injector_error()), redlog::field("uid", getuid()),
        redlog::field("euid", geteuid())
    );
    return false;
  }
}

} // namespace w1::inject::darwin
```

`src/w1nj3ct/platform/darwin/darwin_injector.hpp`:

```hpp
#pragma once

#include "w1nj3ct.hpp"

namespace w1::inject::darwin {
// wrapper around the existing darwin_inject backend
result inject_runtime(const config& cfg);
result inject_preload(const config& cfg);

// process discovery using existing backend
std::vector<process_info> list_processes();
std::vector<process_info> find_processes_by_name(const std::string& name);
std::optional<process_info> get_process_info(int pid);

// capabilities check
bool check_injection_capabilities();
} // namespace w1::inject::darwin
```

`src/w1nj3ct/platform/linux/linux_injector.cpp`:

```cpp
#include "linux_injector.hpp"
#include "error.hpp"
#include <chrono>
#include <redlog.hpp>

// include the kubo injector backend
extern "C" {
#include "backend/linux/injector.h"
}

#include <cstdlib>
#include <cstring>
#include <dirent.h>
#include <fstream>
#include <sstream>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

namespace w1::inject::linux_impl {

result inject_runtime(const config& cfg) {
  auto log = redlog::get_logger("w1nj3ct.linux");

  log.info("linux runtime injection starting", redlog::field("library_path", cfg.library_path));

  // validate we have a target
  if (!cfg.pid && !cfg.process_name) {
    log.error("no target specified for runtime injection");
    return make_error_result(error_code::configuration_invalid, "no target specified");
  }

  int target_pid = -1;

  // resolve process name to pid if needed
  if (cfg.process_name) {
    log.debug("resolving process name to pid", redlog::field("name", *cfg.process_name));

    auto processes = find_processes_by_name(*cfg.process_name);
    if (processes.empty()) {
      log.error("no processes found with specified name", redlog::field("name", *cfg.process_name));
      return make_error_result(error_code::target_not_found, *cfg.process_name);
    }
    if (processes.size() > 1) {
      log.error(
          "multiple processes found with specified name", redlog::field("name", *cfg.process_name),
          redlog::field("count", processes.size())
      );
      return make_error_result(error_code::multiple_targets_found, *cfg.process_name);
    }
    target_pid = processes[0].pid;
  } else {
    target_pid = *cfg.pid;
  }

  log.info("targeting process for injection", redlog::field("pid", target_pid));

  // validate library exists
  if (access(cfg.library_path.c_str(), F_OK) != 0) {
    log.error("library file not found", redlog::field("library_path", cfg.library_path), redlog::field("errno", errno));
    return make_error_result(error_code::library_not_found, "library not found: " + cfg.library_path);
  }

  log.debug("library file validated", redlog::field("library_path", cfg.library_path));

  // attach to process using kubo injector
  auto attach_start = std::chrono::steady_clock::now();
  injector_t* injector = nullptr;
  int attach_result = injector_attach(&injector, target_pid);

  if (attach_result != INJERR_SUCCESS) {
    const char* error_msg = injector_error();
    log.error(
        "failed to attach to target process", redlog::field("pid", target_pid),
        redlog::field("error_code", attach_result), redlog::field("error_msg", error_msg ? error_msg : "unknown")
    );

    // map injector error codes to our error codes
    error_code mapped_error;
    switch (attach_result) {
    case INJERR_NO_PROCESS:
      mapped_error = error_code::target_not_found;
      break;
    case INJERR_PERMISSION:
      mapped_error = error_code::target_access_denied;
      break;
    case INJERR_NO_MEMORY:
      mapped_error = error_code::out_of_memory;
      break;
    case INJERR_UNSUPPORTED_TARGET:
      mapped_error = error_code::target_invalid_architecture;
      break;
    default:
      mapped_error = error_code::injection_failed;
      break;
    }

    return make_error_result(mapped_error, error_msg ? error_msg : "attach failed", attach_result);
  }

  auto attach_duration = std::chrono::steady_clock::now() - attach_start;
  auto attach_ms = std::chrono::duration_cast<std::chrono::milliseconds>(attach_duration).count();
  log.debug(
      "successfully attached to target process", redlog::field("pid", target_pid),
      redlog::field("attach_time_ms", attach_ms)
  );

  // inject library
  auto inject_start = std::chrono::steady_clock::now();
  void* handle = nullptr;
  int inject_result = injector_inject(injector, cfg.library_path.c_str(), &handle);

  if (inject_result != INJERR_SUCCESS) {
    const char* error_msg = injector_error();
    log.error(
        "library injection failed", redlog::field("pid", target_pid), redlog::field("library_path", cfg.library_path),
        redlog::field("error_code", inject_result), redlog::field("error_msg", error_msg ? error_msg : "unknown")
    );

    // detach before returning error
    injector_detach(injector);

    // map injector error codes to our error codes
    error_code mapped_error;
    switch (inject_result) {
    case INJERR_FILE_NOT_FOUND:
      mapped_error = error_code::library_not_found;
      break;
    case INJERR_NO_MEMORY:
      mapped_error = error_code::out_of_memory;
      break;
    case INJERR_ERROR_IN_TARGET:
      mapped_error = error_code::injection_failed;
      break;
    case INJERR_PERMISSION:
      mapped_error = error_code::target_access_denied;
      break;
    case INJERR_UNSUPPORTED_TARGET:
      mapped_error = error_code::target_invalid_architecture;
      break;
    default:
      mapped_error = error_code::injection_failed;
      break;
    }

    return make_error_result(mapped_error, error_msg ? error_msg : "injection failed", inject_result);
  }

  // detach from process
  int detach_result = injector_detach(injector);
  if (detach_result != INJERR_SUCCESS) {
    const char* error_msg = injector_error();
    log.warn(
        "failed to detach from target process", redlog::field("pid", target_pid),
        redlog::field("error_code", detach_result), redlog::field("error_msg", error_msg ? error_msg : "unknown")
    );
    // continue anyway since injection succeeded
  }

  auto inject_duration = std::chrono::steady_clock::now() - inject_start;
  auto inject_ms = std::chrono::duration_cast<std::chrono::milliseconds>(inject_duration).count();
  auto total_ms =
      std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - attach_start).count();

  log.info(
      "runtime injection completed successfully", redlog::field("pid", target_pid),
      redlog::field("library_path", cfg.library_path), redlog::field("handle", handle),
      redlog::field("inject_time_ms", inject_ms), redlog::field("total_time_ms", total_ms)
  );

  return make_success_result(target_pid);
}

result inject_preload(const config& cfg) {
  auto log = redlog::get_logger("w1nj3ct.linux");

  log.info(
      "linux preload injection starting", redlog::field("binary_path", cfg.binary_path ? *cfg.binary_path : "null"),
      redlog::field("library_path", cfg.library_path)
  );

  if (!cfg.binary_path) {
    log.error("binary_path required for preload injection");
    return make_error_result(error_code::configuration_invalid, "binary_path required for preload injection");
  }

  // validate binary exists and is executable
  if (access(cfg.binary_path->c_str(), F_OK) != 0) {
    log.error("target binary not found", redlog::field("binary_path", *cfg.binary_path), redlog::field("errno", errno));
    return make_error_result(error_code::target_not_found, "binary not found: " + *cfg.binary_path);
  }

  if (access(cfg.binary_path->c_str(), X_OK) != 0) {
    log.error(
        "target binary not executable", redlog::field("binary_path", *cfg.binary_path), redlog::field("errno", errno)
    );
    return make_error_result(error_code::target_access_denied, "binary not executable: " + *cfg.binary_path);
  }

  log.debug("target binary validated", redlog::field("binary_path", *cfg.binary_path));

  // set up environment with LD_PRELOAD
  log.debug("setting up injection environment");

  // start with current environment - use same approach as Darwin version
  std::map<std::string, std::string> env;
  size_t base_env_count = 0;

  for (char** env_var = environ; *env_var != nullptr; env_var++) {
    std::string env_str(*env_var);
    std::string::size_type eq_pos = env_str.find('=');
    if (eq_pos != std::string::npos) {
      std::string key = env_str.substr(0, eq_pos);
      std::string value = env_str.substr(eq_pos + 1);
      env[key] = value;
      base_env_count++;
    }
  }

  log.trace("inherited environment variables", redlog::field("count", base_env_count));

  // add/override with cfg.env_vars
  for (const auto& [key, value] : cfg.env_vars) {
    env[key] = value;
    log.verbose("adding environment variable", redlog::field("key", key), redlog::field("value", value));
  }

  // add LD_PRELOAD
  env["LD_PRELOAD"] = cfg.library_path;
  log.info("configured LD_PRELOAD", redlog::field("library_path", cfg.library_path));

  // build command line
  std::vector<const char*> argv;
  argv.push_back(cfg.binary_path->c_str());
  for (const auto& arg : cfg.args) {
    argv.push_back(arg.c_str());
    log.trace("adding command argument", redlog::field("arg", arg));
  }
  argv.push_back(nullptr);

  log.debug("command line prepared", redlog::field("argc", argv.size() - 1));

  // build environment
  std::vector<std::string> env_strings;
  std::vector<const char*> envp;
  for (const auto& [key, value] : env) {
    env_strings.push_back(key + "=" + value);
    envp.push_back(env_strings.back().c_str());
  }
  envp.push_back(nullptr);

  log.debug("environment prepared", redlog::field("env_count", env.size()));

  // fork and exec with modified environment
  log.debug("launching target process");
  auto launch_start = std::chrono::steady_clock::now();

  pid_t child_pid = fork();
  if (child_pid == 0) {
    // child process
    log.trace("child process starting execve", redlog::field("binary_path", *cfg.binary_path));
    execve(cfg.binary_path->c_str(), const_cast<char**>(argv.data()), const_cast<char**>(envp.data()));
    // execve only returns on error
    _exit(1);
  } else if (child_pid > 0) {
    // parent process - conditionally wait for child to complete
    if (cfg.wait_for_completion) {
      log.debug("waiting for child process", redlog::field("child_pid", child_pid));

      int status;
      pid_t wait_result = waitpid(child_pid, &status, 0);

      auto launch_duration = std::chrono::steady_clock::now() - launch_start;
      auto launch_ms = std::chrono::duration_cast<std::chrono::milliseconds>(launch_duration).count();

      if (wait_result == -1) {
        log.error("waitpid failed", redlog::field("child_pid", child_pid), redlog::field("errno", errno));
        return make_error_result(error_code::launch_failed, "waitpid failed", errno);
      }

      if (WIFEXITED(status)) {
        int exit_code = WEXITSTATUS(status);
        log.info(
            "child process exited", redlog::field("child_pid", child_pid), redlog::field("exit_code", exit_code),
            redlog::field("execution_time_ms", launch_ms)
        );

        if (exit_code == 0) {
          return make_success_result(child_pid);
        } else {
          return make_error_result(
              error_code::launch_failed, "child process failed with exit code " + std::to_string(exit_code)
          );
        }
      } else if (WIFSIGNALED(status)) {
        int signal = WTERMSIG(status);
        log.error(
            "child process terminated by signal", redlog::field("child_pid", child_pid),
            redlog::field("signal", signal), redlog::field("execution_time_ms", launch_ms)
        );
        return make_error_result(
            error_code::launch_failed, "child process terminated by signal " + std::to_string(signal)
        );
      } else {
        log.error(
            "child process exited with unknown status", redlog::field("child_pid", child_pid),
            redlog::field("status", status)
        );
        return make_error_result(error_code::launch_failed, "child process exited with unknown status");
      }
    } else {
      log.info(
          "preload injection started successfully - not waiting for completion", redlog::field("child_pid", child_pid)
      );
      return make_success_result(child_pid);
    }
  } else {
    // fork failed
    log.error("fork failed", redlog::field("errno", errno));
    return make_error_result(error_code::launch_failed, "fork failed", errno);
  }
}

std::vector<process_info> list_processes() {
  std::vector<process_info> processes;

  DIR* proc_dir = opendir("/proc");
  if (!proc_dir) {
    return processes;
  }

  struct dirent* entry;
  while ((entry = readdir(proc_dir)) != nullptr) {
    // check if directory name is a number (pid)
    char* endptr;
    int pid = strtol(entry->d_name, &endptr, 10);
    if (*endptr != '\0' || pid <= 0) {
      continue;
    }

    process_info info;
    info.pid = pid;

    // read process name from /proc/pid/comm
    std::string comm_path = "/proc/" + std::string(entry->d_name) + "/comm";
    std::ifstream comm_file(comm_path);
    if (comm_file.is_open()) {
      std::getline(comm_file, info.name);
      // remove trailing newline if present
      if (!info.name.empty() && info.name.back() == '\n') {
        info.name.pop_back();
      }
    }

    // read command line from /proc/pid/cmdline
    std::string cmdline_path = "/proc/" + std::string(entry->d_name) + "/cmdline";
    std::ifstream cmdline_file(cmdline_path, std::ios::binary);
    if (cmdline_file.is_open()) {
      std::string cmdline;
      std::getline(cmdline_file, cmdline, '\0'); // first argument is the executable
      if (!cmdline.empty()) {
        info.full_path = cmdline;

        // rebuild full command line with spaces
        std::string full_cmdline;
        cmdline_file.seekg(0);
        char c;
        while (cmdline_file.get(c)) {
          if (c == '\0') {
            full_cmdline += ' ';
          } else {
            full_cmdline += c;
          }
        }
        if (!full_cmdline.empty() && full_cmdline.back() == ' ') {
          full_cmdline.pop_back();
        }
        info.command_line = full_cmdline;
      }
    }

    processes.push_back(info);
  }

  closedir(proc_dir);
  return processes;
}

std::vector<process_info> find_processes_by_name(const std::string& name) {
  std::vector<process_info> matches;
  auto all_processes = list_processes();

  for (const auto& proc : all_processes) {
    // match by process name (comm)
    if (proc.name == name) {
      matches.push_back(proc);
      continue;
    }

    // also try matching by executable path basename
    if (!proc.full_path.empty()) {
      size_t last_slash = proc.full_path.find_last_of('/');
      std::string basename = (last_slash != std::string::npos) ? proc.full_path.substr(last_slash + 1) : proc.full_path;
      if (basename == name) {
        matches.push_back(proc);
      }
    }
  }

  return matches;
}

std::optional<process_info> get_process_info(int pid) {
  auto all_processes = list_processes();

  for (const auto& proc : all_processes) {
    if (proc.pid == pid) {
      return proc;
    }
  }

  return std::nullopt;
}

bool check_injection_capabilities() {
  // use the kubo injector's capability check if available
  // for now, do a basic ptrace capability test
  pid_t child_pid = fork();
  if (child_pid == 0) {
    // child process - sleep briefly then exit
    usleep(100000); // 100ms
    _exit(0);
  } else if (child_pid > 0) {
    // parent process - try to attach to child using kubo injector
    usleep(10000); // 10ms - give child time to start

    injector_t* injector = nullptr;
    int attach_result = injector_attach(&injector, child_pid);
    if (attach_result == INJERR_SUCCESS) {
      injector_detach(injector);

      // wait for child to exit
      int status;
      waitpid(child_pid, &status, 0);
      return true;
    }

    // wait for child to exit even if attach failed
    int status;
    waitpid(child_pid, &status, 0);
    return false;
  } else {
    // fork failed
    return false;
  }
}

} // namespace w1::inject::linux_impl
```

`src/w1nj3ct/platform/linux/linux_injector.hpp`:

```hpp
#pragma once

#include "w1nj3ct.hpp"

namespace w1::inject::linux_impl {
// wrapper for linux injection (using kubo/injector backend when available)
result inject_runtime(const config& cfg);
result inject_preload(const config& cfg);

// process discovery
std::vector<process_info> list_processes();
std::vector<process_info> find_processes_by_name(const std::string& name);
std::optional<process_info> get_process_info(int pid);

// capabilities check
bool check_injection_capabilities();
} // namespace w1::inject::linux_impl
```

`src/w1nj3ct/platform/windows/error_windows.cpp`:

```cpp
#include "error.hpp"
#include <string>
#include <windows.h>

std::string translate_platform_error(DWORD error_code) {
  LPSTR messageBuffer = nullptr;
  size_t size = FormatMessageA(
      FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, error_code,
      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR) &messageBuffer, 0, NULL
  );

  std::string message(messageBuffer, size);
  LocalFree(messageBuffer);
  return message;
}
```

`src/w1nj3ct/platform/windows/windows_injector.cpp`:

```cpp
#include "windows_injector.hpp"
#include "error.hpp"

// include windows injection backend
#include "backend/windows/auxiliary.hpp"
#include "backend/windows/inject.hpp"

#include <string>

#ifndef NOMINMAX
#define NOMINMAX
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <psapi.h>
#include <tlhelp32.h>

namespace w1::inject::windows {

// helper to convert string to wstring
std::wstring string_to_wstring(const std::string& str) {
  if (str.empty()) {
    return std::wstring();
  }
  int size = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, nullptr, 0);
  std::wstring result(size - 1, 0);
  MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, &result[0], size);
  return result;
}

// helper to convert wstring to string
std::string wstring_to_string(const std::wstring& wstr) {
  if (wstr.empty()) {
    return std::string();
  }
  int size = WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, nullptr, 0, nullptr, nullptr);
  std::string result(size - 1, 0);
  WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, &result[0], size, nullptr, nullptr);
  return result;
}

result inject_runtime(const config& cfg) {
  // validate we have a target
  if (!cfg.pid && !cfg.process_name) {
    return make_error_result(error_code::configuration_invalid, "no target specified");
  }

  DWORD target_pid = 0;

  // resolve process name to pid if needed
  if (cfg.process_name) {
    auto processes = find_processes_by_name(*cfg.process_name);
    if (processes.empty()) {
      return make_error_result(error_code::target_not_found, *cfg.process_name);
    }
    if (processes.size() > 1) {
      return make_error_result(error_code::multiple_targets_found, *cfg.process_name);
    }
    target_pid = processes[0].pid;
  } else {
    target_pid = *cfg.pid;
  }

  // open process handle
  HANDLE h_process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, target_pid);
  if (h_process == NULL) {
    DWORD err = GetLastError();
    return make_error_result(translate_platform_error(static_cast<int>(err)), "failed to open process", err);
  }

  // convert library path to wide string
  std::wstring dll_path = string_to_wstring(cfg.library_path);

  // choose injection technique and inject
  bool success = false;
  switch (cfg.windows_technique) {
  case windows_technique::create_remote_thread:
    success = w1::inject::windows::inject_dll_create_remote_thread(h_process, dll_path);
    break;
  case windows_technique::set_windows_hook:
    success = w1::inject::windows::inject_dll_set_windows_hook_ex(h_process, target_pid, dll_path);
    break;
  case windows_technique::rtl_create_user_thread:
    success = w1::inject::windows::inject_dll_rtl_create_user_thread(h_process, dll_path);
    break;
  case windows_technique::reflective_loader:
    success = w1::inject::windows::inject_dll_reflective_loader(h_process, dll_path);
    break;
  default:
    CloseHandle(h_process);
    return make_error_result(error_code::technique_not_supported, "unknown windows technique");
  }

  CloseHandle(h_process);

  if (!success) {
    DWORD err = GetLastError();
    return make_error_result(translate_platform_error(static_cast<int>(err)), "injection failed", err);
  }

  return make_success_result(target_pid);
}

result inject_preload(const config& cfg) {
  // windows launch injection using suspended process approach

  // validate we have a binary path for launch injection
  if (!cfg.binary_path) {
    return make_error_result(error_code::configuration_invalid, "binary_path required for launch injection");
  }

  // convert paths to wide strings
  std::wstring binary_path = string_to_wstring(*cfg.binary_path);
  std::wstring dll_path = string_to_wstring(cfg.library_path);

  // perform launch injection
  w1::inject::windows::process_id target_pid = 0;
  bool success = w1::inject::windows::inject_dll_launch_suspended(
      binary_path, dll_path, cfg.args, cfg.env_vars, &target_pid, cfg.suspended, cfg.wait_for_completion
  );

  if (!success) {
    DWORD err = GetLastError();
    return make_error_result(translate_platform_error(static_cast<int>(err)), "launch injection failed", err);
  }

  return make_success_result(target_pid);
}

std::vector<process_info> list_processes() {
  std::vector<process_info> processes;

  HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  if (snapshot == INVALID_HANDLE_VALUE) {
    return processes;
  }

  PROCESSENTRY32W pe32;
  pe32.dwSize = sizeof(PROCESSENTRY32W);

  if (Process32FirstW(snapshot, &pe32)) {
    do {
      process_info info;
      info.pid = pe32.th32ProcessID;
      info.name = wstring_to_string(pe32.szExeFile);

      // get full path
      HANDLE h_process = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, pe32.th32ProcessID);
      if (h_process != NULL) {
        wchar_t path[MAX_PATH];
        DWORD path_len = MAX_PATH;
        if (QueryFullProcessImageNameW(h_process, 0, path, &path_len)) {
          info.full_path = wstring_to_string(path);
        }
        CloseHandle(h_process);
      }

      processes.push_back(info);
    } while (Process32NextW(snapshot, &pe32));
  }

  CloseHandle(snapshot);
  return processes;
}

std::vector<process_info> find_processes_by_name(const std::string& name) {
  std::vector<process_info> matches;
  auto all_processes = list_processes();

  for (const auto& proc : all_processes) {
    if (proc.name == name) {
      matches.push_back(proc);
    }
  }

  return matches;
}

std::optional<process_info> get_process_info(int pid) {
  auto all_processes = list_processes();

  for (const auto& proc : all_processes) {
    if (proc.pid == pid) {
      return proc;
    }
  }

  return std::nullopt;
}

bool check_injection_capabilities() {
  // check if we can open a process with required permissions
  HANDLE h_process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetCurrentProcessId());
  if (h_process != NULL) {
    CloseHandle(h_process);
    return true;
  }

  return false;
}

} // namespace w1::inject::windows
```

`src/w1nj3ct/platform/windows/windows_injector.hpp`:

```hpp
#pragma once

#include "w1nj3ct.hpp"

namespace w1::inject::windows {
// wrapper around the existing win_inject backend
result inject_runtime(const config& cfg);
result inject_preload(const config& cfg); // not supported, returns error

// process discovery using existing backend
std::vector<process_info> list_processes();
std::vector<process_info> find_processes_by_name(const std::string& name);
std::optional<process_info> get_process_info(int pid);

// capabilities check
bool check_injection_capabilities();
} // namespace w1::inject::windows
```

`src/w1nj3ct/w1nj3ct.cpp`:

```cpp
#include "w1nj3ct.hpp"
#include "error.hpp"
#include <redlog.hpp>

// platform-specific includes
#ifdef __APPLE__
#include "platform/darwin/darwin_injector.hpp"
#elif defined(__linux__)
#include "platform/linux/linux_injector.hpp"
#elif defined(_WIN32)
#include "platform/windows/windows_injector.hpp"
#endif

#include <filesystem>

namespace w1::inject {

// validate configuration before injection
error_code validate_config(const config& cfg) {
  auto log = redlog::get_logger("w1nj3ct.validation");

  log.debug("validating injection configuration");

  // check exactly one target specified
  int target_count = 0;
  if (cfg.pid) {
    target_count++;
  }
  if (cfg.process_name) {
    target_count++;
  }
  if (cfg.binary_path) {
    target_count++;
  }

  log.trace(
      "target specification check", redlog::field("targets", target_count),
      redlog::field("has_pid", static_cast<bool>(cfg.pid)),
      redlog::field("has_process_name", static_cast<bool>(cfg.process_name)),
      redlog::field("has_binary_path", static_cast<bool>(cfg.binary_path))
  );

  if (target_count != 1) {
    log.error("invalid target specification - exactly one target required", redlog::field("targets", target_count));
    return error_code::configuration_invalid;
  }

  // validate library path exists and is accessible
  log.debug("validating library path", redlog::field("library_path", cfg.library_path));

  if (!std::filesystem::exists(cfg.library_path)) {
    log.error("injection library not found", redlog::field("library_path", cfg.library_path));
    return error_code::library_not_found;
  }

  // check library permissions
  std::error_code fs_error;
  auto file_status = std::filesystem::status(cfg.library_path, fs_error);
  if (fs_error) {
    log.error(
        "failed to get library file status", redlog::field("library_path", cfg.library_path),
        redlog::field("error", fs_error.message())
    );
    return error_code::library_not_found;
  }

  if (!std::filesystem::is_regular_file(file_status)) {
    log.error("library path is not a regular file", redlog::field("library_path", cfg.library_path));
    return error_code::library_not_found;
  }

  log.verbose(
      "library validation passed", redlog::field("library_path", cfg.library_path),
      redlog::field("bytes", std::filesystem::file_size(cfg.library_path, fs_error))
  );

  // check method compatibility with target type
  const char* method_str = (cfg.injection_method == method::runtime) ? "runtime" : "preload";
  log.debug("validating method compatibility", redlog::field("method", method_str));

  if (cfg.injection_method == method::preload && !cfg.binary_path) {
    log.error("launch injection method requires binary_path", redlog::field("method", method_str));
    return error_code::configuration_invalid;
  }

  if (cfg.injection_method == method::runtime && cfg.binary_path) {
    log.error("runtime injection method incompatible with binary_path", redlog::field("method", method_str));
    return error_code::configuration_invalid;
  }

  if (cfg.injection_method == method::runtime && cfg.wait_for_completion) {
    log.error("wait_for_completion only supported with launch injection method", redlog::field("method", method_str));
    return error_code::configuration_invalid;
  }

  // platform-specific validation
  const char* platform_str =
#ifdef __APPLE__
      "darwin";
#elif defined(__linux__)
      "linux";
#elif defined(_WIN32)
      "windows";
#else
      "unknown";
#endif

  log.debug(
      "performing platform-specific validation", redlog::field("platform", platform_str),
      redlog::field("method", method_str)
  );

  log.debug("configuration validation completed successfully");
  return error_code::success;
}

result inject(const config& cfg) {
  auto log = redlog::get_logger("w1nj3ct");

  const char* method_str = (cfg.injection_method == method::runtime) ? "runtime" : "preload";
  const char* platform_str =
#ifdef __APPLE__
      "darwin";
#elif defined(__linux__)
      "linux";
#elif defined(_WIN32)
      "windows";
#else
      "unknown";
#endif

  log.info(
      "injection request received", redlog::field("method", method_str), redlog::field("platform", platform_str),
      redlog::field("library_path", cfg.library_path)
  );

  // log target information
  if (cfg.pid) {
    log.debug("target specified by pid", redlog::field("pid", *cfg.pid));
  } else if (cfg.process_name) {
    log.debug("target specified by process name", redlog::field("name", *cfg.process_name));
  } else if (cfg.binary_path) {
    log.debug("target specified by binary path", redlog::field("path", *cfg.binary_path));
  }

  // log environment configuration if present
  if (!cfg.env_vars.empty()) {
    log.verbose("environment variables configured", redlog::field("vars", cfg.env_vars.size()));
    for (const auto& [key, value] : cfg.env_vars) {
      log.trace("environment variable", redlog::field("key", key), redlog::field("value", value));
    }
  }

  // 1. validate configuration
  log.debug("validating injection configuration");
  error_code validation_result = validate_config(cfg);
  if (validation_result != error_code::success) {
    std::string error_detail = error_code_to_string(validation_result);
    log.error(
        "configuration validation failed", redlog::field("error_code", static_cast<int>(validation_result)),
        redlog::field("detail", error_detail), redlog::field("method", method_str),
        redlog::field("library_path", cfg.library_path)
    );
    return make_error_result(validation_result, "configuration validation failed: " + error_detail);
  }

  log.debug("configuration validated successfully");

  // 2. check platform capabilities (only for runtime injection)
  if (cfg.injection_method == method::runtime) {
    log.debug("checking injection capabilities for platform", redlog::field("platform", platform_str));

    bool capabilities_ok = check_injection_capabilities();
    if (!capabilities_ok) {
      log.warn(
          "injection capabilities limited on this platform", redlog::field("platform", platform_str),
          redlog::field("method", method_str)
      );
    }
  }

  // 3. platform detection and dispatch
  log.debug(
      "dispatching to platform-specific injection implementation", redlog::field("platform", platform_str),
      redlog::field("method", method_str)
  );

  result injection_result;

#ifdef __APPLE__
  if (cfg.injection_method == method::runtime) {
    injection_result = darwin::inject_runtime(cfg);
  } else {
    injection_result = darwin::inject_preload(cfg);
  }
#elif defined(__linux__)
  if (cfg.injection_method == method::runtime) {
    injection_result = linux_impl::inject_runtime(cfg);
  } else {
    injection_result = linux_impl::inject_preload(cfg);
  }
#elif defined(_WIN32)
  if (cfg.injection_method == method::runtime) {
    injection_result = windows::inject_runtime(cfg);
  } else {
    injection_result = windows::inject_preload(cfg);
  }
#else
  log.error("platform not supported for injection", redlog::field("platform", platform_str));
  injection_result = make_error_result(
      error_code::platform_not_supported, "injection not supported on platform: " + std::string(platform_str)
  );
#endif

  // 4. log final result
  if (injection_result.success()) {
    log.info(
        "injection completed successfully", redlog::field("method", method_str),
        redlog::field("platform", platform_str), redlog::field("pid", injection_result.target_pid),
        redlog::field("library_path", cfg.library_path)
    );
  } else {
    log.error(
        "injection failed", redlog::field("method", method_str), redlog::field("platform", platform_str),
        redlog::field("error_code", static_cast<int>(injection_result.code)),
        redlog::field("error_msg", injection_result.error_message),
        redlog::field("system_error", injection_result.system_error_code),
        redlog::field("library_path", cfg.library_path)
    );
  }

  return injection_result;
}

std::vector<process_info> list_processes() {
#ifdef __APPLE__
  return darwin::list_processes();
#elif defined(__linux__)
  return linux_impl::list_processes();
#elif defined(_WIN32)
  return windows::list_processes();
#else
  return {};
#endif
}

std::vector<process_info> find_processes(const std::string& name) {
#ifdef __APPLE__
  return darwin::find_processes_by_name(name);
#elif defined(__linux__)
  return linux_impl::find_processes_by_name(name);
#elif defined(_WIN32)
  return windows::find_processes_by_name(name);
#else
  return {};
#endif
}

std::optional<process_info> get_process_info(int pid) {
#ifdef __APPLE__
  return darwin::get_process_info(pid);
#elif defined(__linux__)
  return linux_impl::get_process_info(pid);
#elif defined(_WIN32)
  return windows::get_process_info(pid);
#else
  return std::nullopt;
#endif
}

bool check_injection_capabilities() {
#ifdef __APPLE__
  return darwin::check_injection_capabilities();
#elif defined(__linux__)
  return linux_impl::check_injection_capabilities();
#elif defined(_WIN32)
  return windows::check_injection_capabilities();
#else
  return false;
#endif
}

std::vector<std::string> get_supported_platforms() {
  std::vector<std::string> platforms;
#ifdef __APPLE__
  platforms.push_back("macOS");
#endif
#ifdef __linux__
  platforms.push_back("Linux");
#endif
#ifdef _WIN32
  platforms.push_back("Windows");
#endif
  return platforms;
}

bool is_library_compatible(const std::string& library_path, int pid) {
  // basic check - library exists
  if (!std::filesystem::exists(library_path)) {
    return false;
  }

  // TODO: implement architecture compatibility checking
  // for now, assume compatible
  return true;
}

} // namespace w1::inject
```

`src/w1nj3ct/w1nj3ct.hpp`:

```hpp
#pragma once

#include <chrono>
#include <map>
#include <optional>
#include <string>
#include <vector>

namespace w1::inject {
// injection methods
enum class method {
  runtime, // inject into running process
  preload  // launch new process with library preloaded
};

// platform-specific technique enums
#ifdef _WIN32
enum class windows_technique {
  create_remote_thread,
  set_windows_hook,
  rtl_create_user_thread,
  reflective_loader,
  launch_suspended
};
#endif

// comprehensive cross-platform error codes
enum class error_code {
  success,

  // target errors
  target_not_found,
  multiple_targets_found,
  target_access_denied,
  target_invalid_architecture,

  // library errors
  library_not_found,
  library_invalid,
  library_incompatible,

  // injection errors
  injection_failed,
  injection_timeout,
  injection_already_loaded,

  // platform errors
  platform_not_supported,
  technique_not_supported,
  insufficient_privileges,

  // system errors
  out_of_memory,
  system_error,
  configuration_invalid,

  // launch errors
  launch_failed,
  launch_timeout,

  unknown_error
};

// process info for discovery
struct process_info {
  int pid;
  std::string name;
  std::string full_path;
  std::string command_line;

  bool operator==(const process_info& other) const { return pid == other.pid; }
};

// configuration
struct config {
  // REQUIRED
  std::string library_path;
  method injection_method; // user must explicitly choose

  // TARGET (exactly one required)
  std::optional<int> pid;
  std::optional<std::string> process_name;
  std::optional<std::string> binary_path;

  // BEHAVIOR
  std::chrono::milliseconds timeout{5000};
  bool suspended = false;           // start process in suspended state (launch method only)
  bool wait_for_completion = false; // wait for process completion (launch method only)

  // LAUNCH OPTIONS (when using binary_path)
  std::vector<std::string> args;
  std::map<std::string, std::string> env_vars;

  // PLATFORM-SPECIFIC
#ifdef _WIN32
  windows_technique windows_technique = windows_technique::create_remote_thread;
  bool windows_elevate = false;
#endif

#ifdef __linux__
  std::string linux_namespace;
#endif

  // DEBUGGING
  bool verbose = false;
};

// result
struct result {
  error_code code;
  int target_pid = -1;
  std::string error_message;
  std::optional<int> system_error_code;

  // convenience
  bool success() const { return code == error_code::success; }
  operator bool() const { return success(); }
};

// MAIN INJECTION FUNCTION
result inject(const config& cfg);

// CONVENIENCE FUNCTIONS
inline result inject_library_runtime(const std::string& library_path, int pid);
inline result inject_library_runtime(const std::string& library_path, const std::string& process_name);
inline result inject_library_launch(
    const std::string& binary_path, const std::string& library_path, const std::vector<std::string>& args = {}
);

// PROCESS DISCOVERY
std::vector<process_info> list_processes();
std::vector<process_info> find_processes(const std::string& name);
std::optional<process_info> get_process_info(int pid);

// UTILITIES
bool check_injection_capabilities();
std::vector<std::string> get_supported_platforms();
bool is_library_compatible(const std::string& library_path, int pid);
std::string error_code_to_string(error_code code);
bool is_recoverable_error(error_code code);

// CONVENIENCE FUNCTION IMPLEMENTATIONS
inline result inject_library_runtime(const std::string& library_path, int pid) {
  config cfg;
  cfg.library_path = library_path;
  cfg.injection_method = method::runtime;
  cfg.pid = pid;
  return inject(cfg);
}

inline result inject_library_runtime(const std::string& library_path, const std::string& process_name) {
  config cfg;
  cfg.library_path = library_path;
  cfg.injection_method = method::runtime;
  cfg.process_name = process_name;
  return inject(cfg);
}

inline result inject_library_launch(
    const std::string& binary_path, const std::string& library_path, const std::vector<std::string>& args
) {
  config cfg;
  cfg.library_path = library_path;
  cfg.injection_method = method::preload;
  cfg.binary_path = binary_path;
  cfg.args = args;
  return inject(cfg);
}
} // namespace w1::inject
```

`src/w1tn3ss/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${WITNESS_SOURCE_DIR}/cmake/CommonConfig.cmake)

add_library(w1tn3ss STATIC
    util/env_config.cpp
    util/env_enumerator.cpp
    util/module_scanner.cpp
    util/module_range_index.cpp
    util/memory_range_index.cpp
    util/signal_handler.cpp
    util/safe_memory.cpp
    util/register_capture.cpp
    util/stack_capture.cpp
    util/value_formatter.cpp
    util/jsonl_writer.cpp
    # new calling convention system
    abi/calling_convention_factory.cpp
    abi/calling_convention_detector.cpp
    # existing abi components
    abi/api_knowledge_db.cpp
    abi/argument_extractor.cpp
    abi/api_analyzer.cpp
    abi/api_listener.cpp
    # hooking system
    hooking/hook_manager.cpp
)

# Add platform-specific calling convention implementations
# Use QBDI_ARCH which is properly set based on target architecture
if(QBDI_ARCH STREQUAL "X86_64")
    target_sources(w1tn3ss PRIVATE
        abi/conventions/x86_64/system_v.cpp
        abi/conventions/x86_64/microsoft.cpp
    )
elseif(QBDI_ARCH STREQUAL "X86")
    target_sources(w1tn3ss PRIVATE
        abi/conventions/x86/cdecl.cpp
        # abi/conventions/x86/stdcall.cpp
        # abi/conventions/x86/fastcall.cpp
        # abi/conventions/x86/thiscall.cpp
    )
elseif(QBDI_ARCH STREQUAL "AARCH64")
    target_sources(w1tn3ss PRIVATE
        abi/conventions/arm/aarch64_aapcs.cpp
    )
elseif(QBDI_ARCH STREQUAL "ARM")
    # TODO: add ARM32 conventions when implemented
    # target_sources(w1tn3ss PRIVATE
    #     abi/conventions/arm/arm32_aapcs.cpp
    # )
endif()

# Symbol resolution system
target_sources(w1tn3ss PRIVATE
    symbols/symbol_resolver.cpp
)

# Platform-specific symbol backends
if(WIN32)
    target_sources(w1tn3ss PRIVATE
        symbols/windows_symbol_backend.cpp
        symbols/windows_path_resolver.cpp
    )
else()
    target_sources(w1tn3ss PRIVATE
        symbols/posix_symbol_backend.cpp
    )
    
    if(APPLE)
        target_sources(w1tn3ss PRIVATE
            symbols/macos_dyld_resolver.cpp
        )
    endif()
endif()

# LIEF symbol backend when enabled
if(WITNESS_LIEF)
    target_sources(w1tn3ss PRIVATE
        symbols/lief_symbol_backend.cpp
    )
endif()

target_include_directories(w1tn3ss PUBLIC 
    ${CMAKE_CURRENT_SOURCE_DIR}
    ${WITNESS_SOURCE_DIR}/src
)

target_link_libraries(w1tn3ss PUBLIC
    QBDI_static
    redlog::redlog
)

apply_common_compile_options(w1tn3ss)
set_standard_output_dirs(w1tn3ss)
apply_platform_linking(w1tn3ss)
configure_target_with_lief(w1tn3ss)

```

`src/w1tn3ss/abi/api_analyzer.cpp`:

```cpp
#include "api_analyzer.hpp"
#include <redlog.hpp>
#include <sstream>
#include <iomanip>
#include <w1tn3ss/util/value_formatter.hpp>

namespace w1::abi {

class api_analyzer::impl {
public:
  impl(const analyzer_config& config)
      : config_(config), log_("w1.api_analyzer"), api_db_(std::make_shared<api_knowledge_db>()),
        detector_(std::make_shared<calling_convention_detector>()), argument_extractor_(api_db_, detector_) {

#ifdef WITNESS_LIEF_ENABLED
    if (config_.resolve_symbols) {
      symbols::symbol_resolver::config sym_cfg;
      sym_cfg.max_cache_size = 50;
      sym_cfg.prepopulate_exports = true;
      symbol_resolver_ = std::make_unique<symbols::symbol_resolver>(sym_cfg);
    }
#endif
  }

  void initialize(const util::module_range_index& module_index) {
    module_index_ = &module_index;
    log_.dbg("initialized with module index", redlog::field("module_count", module_index.size()));
  }

  api_analysis_result analyze_call(const api_context& ctx) {
    api_analysis_result result;
    stats_.calls_analyzed++;

    try {
      // step 1: identify module containing the target address
      auto module = module_index_->find_containing(ctx.target_address);
      if (!module) {
        result.error_message = "no module found for target address";
        log_.dbg(
            "module not found for target address", redlog::field("address", ctx.target_address),
            redlog::field("context", ctx.call_address)
        );
        return result;
      }

      result.module_name = module->name;
      result.module_offset = ctx.target_address - module->base_address;

      // step 2: use symbol from context if available, otherwise resolve
      if (!ctx.symbol_name.empty()) {
        result.symbol_name = ctx.symbol_name;
        // note: demangled_name would need to be passed in context if needed
        log_.dbg("using symbol from context", redlog::field("symbol", result.symbol_name));
      } else if (config_.resolve_symbols) {
        resolve_symbol(result, ctx.target_address, *module);
      }

      // step 3: api identification and knowledge lookup
      if (!result.symbol_name.empty()) {
        log_.dbg("looking up api in knowledge db", redlog::field("symbol", result.symbol_name));

        if (auto api_info = api_db_->lookup(result.symbol_name)) {
          result.category = api_info->api_category;
          result.behavior_flags = api_info->flags;
          result.description = api_info->description;
          result.found_in_knowledge_db = true;
          stats_.apis_identified++;

          log_.dbg(
              "found api in knowledge db", redlog::field("symbol", result.symbol_name),
              redlog::field("category", static_cast<int>(api_info->api_category)),
              redlog::field("param_count", api_info->parameters.size()),
              redlog::field("extract_args", config_.extract_arguments)
          );

          // step 4: argument extraction
          if (config_.extract_arguments && !api_info->parameters.empty()) {
            log_.ped(
                "extracting arguments", redlog::field("symbol", result.symbol_name),
                redlog::field("param_count", api_info->parameters.size())
            );
            extract_arguments(result, ctx, *api_info);
          } else if (config_.extract_arguments && api_info->parameters.empty()) {
            log_.dbg("no parameters defined for api", redlog::field("symbol", result.symbol_name));
          }
        } else {
          log_.dbg("api not found in knowledge db", redlog::field("symbol", result.symbol_name));
          result.found_in_knowledge_db = false;
        }
      }

      // step 5: format the call
      if (config_.format_calls) {
        format_call(result);
      }

      result.analysis_complete = true;

      // log completed api analysis with formatted call details
      if (!result.symbol_name.empty() && config_.format_calls) {
        // build a concise argument summary with truncation for display
        std::stringstream arg_summary;
        for (size_t i = 0; i < result.arguments.size(); ++i) {
          if (i > 0) {
            arg_summary << ", ";
          }
          const auto& arg = result.arguments[i];

          // add parameter name if known
          if (!arg.param_name.empty()) {
            arg_summary << arg.param_name << "=";
          }

          // format value based on type with truncation
          if ((arg.param_type == param_info::type::STRING || arg.param_type == param_info::type::PATH) &&
              !arg.string_preview.empty()) {
            // truncate long strings for display
            std::string preview = arg.string_preview;
            if (preview.length() > 50) {
              preview = preview.substr(0, 47) + "...";
            }
            // use format_string which handles escaping internally
            util::value_formatter::format_options opts;
            opts.quote_strings = false; // we add quotes manually
            opts.max_string_length = 50;
            arg_summary << "\"" << util::value_formatter::format_string(preview, opts) << "\"";
          } else if (arg.is_null_pointer) {
            arg_summary << "NULL";
          } else if (arg.param_type == param_info::type::POINTER) {
            arg_summary << "0x" << std::hex << arg.raw_value;
          } else if (arg.param_type == param_info::type::BOOLEAN) {
            arg_summary << (arg.raw_value ? "true" : "false");
          } else {
            arg_summary << arg.raw_value;
          }

          // limit total length to prevent excessive output
          if (arg_summary.str().length() > 200) {
            arg_summary << ", ...";
            break;
          }
        }

        // format category name for display
        std::string category_name;
        if (result.category != api_info::category::UNKNOWN) {
          switch (result.category) {
          case api_info::category::FILE_IO:
          case api_info::category::FILE_MANAGEMENT:
            category_name = "File";
            break;
          case api_info::category::STDIO:
            category_name = "I/O";
            break;
          case api_info::category::DEVICE_IO:
            category_name = "Device";
            break;
          case api_info::category::PROCESS_CONTROL:
            category_name = "Process";
            break;
          case api_info::category::THREAD_CONTROL:
          case api_info::category::THREADING:
            category_name = "Threading";
            break;
          case api_info::category::MEMORY_MANAGEMENT:
            category_name = "Memory";
            break;
          case api_info::category::HEAP_MANAGEMENT:
            category_name = "Heap";
            break;
          case api_info::category::SYNCHRONIZATION:
          case api_info::category::MUTEX:
          case api_info::category::EVENT:
          case api_info::category::SEMAPHORE:
            category_name = "Sync";
            break;
          case api_info::category::NETWORK_SOCKET:
          case api_info::category::NETWORK_DNS:
          case api_info::category::NETWORK_HTTP:
            category_name = "Network";
            break;
          case api_info::category::REGISTRY:
            category_name = "Registry";
            break;
          case api_info::category::SECURITY:
            category_name = "Security";
            break;
          case api_info::category::CRYPTO:
            category_name = "Crypto";
            break;
          case api_info::category::SYSTEM_INFO:
            category_name = "System";
            break;
          case api_info::category::TIME:
            category_name = "Time";
            break;
          case api_info::category::ENVIRONMENT:
            category_name = "Environment";
            break;
          case api_info::category::STRING_MANIPULATION:
            category_name = "String";
            break;
          case api_info::category::LOCALE:
            category_name = "Locale";
            break;
          case api_info::category::LIBRARY_LOADING:
            category_name = "Library";
            break;
          case api_info::category::MATH:
            category_name = "Math";
            break;
          case api_info::category::SORTING:
            category_name = "Sorting";
            break;
          case api_info::category::IPC:
          case api_info::category::PIPE:
          case api_info::category::SHARED_MEMORY:
            category_name = "IPC";
            break;
          case api_info::category::UI:
          case api_info::category::WINDOW:
            category_name = "UI";
            break;
          case api_info::category::SYSTEM_HOOK:
            category_name = "Hook";
            break;
          case api_info::category::MISC:
          default:
            category_name = "Other";
            break;
          }
        }

        log_.vrb(
            "analyzed api call", redlog::field("call", result.formatted_call), redlog::field("category", category_name),
            redlog::field("module", result.module_name)
        );
      }

    } catch (const std::exception& e) {
      log_.err("analysis failed", redlog::field("error", e.what()));
      result.error_message = e.what();
      stats_.errors++;
    }

    return result;
  }

  void analyze_return(api_analysis_result& result, const api_context& ctx) {
    if (!result.analysis_complete) {
      return;
    }

    try {
      // extract return value based on api info
      if (auto api_info = api_db_->lookup(result.symbol_name)) {
        // detect calling convention for return value extraction
        auto convention = detector_->detect(result.module_name, result.symbol_name);
        uint64_t ret_val = convention->get_integer_return(ctx.gpr_state);

        // create safe memory reader for return value extraction
        util::safe_memory::memory_validator().refresh();

        result.return_value =
            argument_extractor_.extract_argument(api_info->return_value, ret_val, util::safe_memory_reader{ctx.vm});

        // log return value analysis with formatted output
        if (api_info->return_value.param_type != param_info::type::VOID) {
          std::string return_str;

          // format return value based on type for display
          if (!result.return_value.string_preview.empty()) {
            util::value_formatter::format_options opts;
            opts.quote_strings = false; // we add quotes manually
            return_str = "\"" + util::value_formatter::format_string(result.return_value.string_preview, opts) + "\"";
          } else if (result.return_value.is_null_pointer) {
            return_str = "NULL";
          } else if (result.return_value.param_type == param_info::type::BOOLEAN) {
            return_str = result.return_value.raw_value ? "true" : "false";
          } else if (result.return_value.param_type == param_info::type::ERROR_CODE) {
            std::stringstream ss;
            ss << "0x" << std::hex << result.return_value.raw_value << " ("
               << static_cast<int64_t>(result.return_value.raw_value) << ")";
            return_str = ss.str();
          } else if (result.return_value.param_type == param_info::type::POINTER) {
            std::stringstream ss;
            ss << "0x" << std::hex << result.return_value.raw_value;
            return_str = ss.str();
          } else {
            return_str = std::to_string(static_cast<int64_t>(result.return_value.raw_value));
          }

          // build formatted return string and log it
          std::string formatted_return = result.symbol_name + "() = " + return_str;

          log_.vrb(
              "analyzed api return", redlog::field("return", formatted_return),
              redlog::field("raw_value", result.return_value.raw_value), redlog::field("module", result.module_name)
          );
        }
      }
    } catch (const std::exception& e) {
      log_.err("return analysis failed", redlog::field("error", e.what()));
    }
  }

  const api_knowledge_db& get_api_db() const { return *api_db_; }

  stats get_stats() const { return stats_; }

  void clear_caches() {
#ifdef WITNESS_LIEF_ENABLED
    if (symbol_resolver_) {
      symbol_resolver_->clear_cache();
    }
#endif
  }

private:
  void resolve_symbol(api_analysis_result& result, uint64_t address, const util::module_info& module) {
#ifdef WITNESS_LIEF_ENABLED
    if (!symbol_resolver_) {
      return;
    }

    if (auto symbol = symbol_resolver_->resolve_in_module(module.path, result.module_offset)) {
      result.symbol_name = symbol->name;
      result.demangled_name = symbol->demangled_name;
      stats_.symbols_resolved++;

      log_.dbg(
          "resolved symbol", redlog::field("address", address), redlog::field("symbol", symbol->name),
          redlog::field("demangled", symbol->demangled_name)
      );
    }
#else
    // fallback: use module name + offset when lief is not available
    std::stringstream ss;
    ss << module.name << "+0x" << std::hex << result.module_offset;
    result.symbol_name = ss.str();
#endif
  }

  void extract_arguments(api_analysis_result& result, const api_context& ctx, const api_info& api) {
    // extract raw argument values from registers/stack
    size_t arg_count = std::min(api.parameters.size(), config_.max_arguments);
    log_.ped("extracting raw argument values", redlog::field("count", arg_count));

    // detect calling convention and extract args
    auto convention = detector_->detect(result.module_name, result.symbol_name);
    calling_convention_base::extraction_context extract_ctx{
        ctx.gpr_state, ctx.fpr_state, [&ctx](uint64_t addr) -> uint64_t {
          // use safe_memory for validated reads
          auto value = util::safe_memory::read<uint64_t>(ctx.vm, addr);
          return value.value_or(0);
        }
    };
    auto raw_args = convention->extract_integer_args(extract_ctx, arg_count);

    log_.ped("extracted raw args", redlog::field("count", raw_args.size()));

    // create safe memory reader for argument extraction
    util::safe_memory::memory_validator().refresh();
    util::safe_memory_reader memory{ctx.vm};

    // extract and interpret each argument with semantic meaning
    for (size_t i = 0; i < raw_args.size() && i < api.parameters.size(); ++i) {
      log_.ped(
          "extracting argument", redlog::field("index", i), redlog::field("param_name", api.parameters[i].name),
          redlog::field("raw_value", raw_args[i]), redlog::field("type", static_cast<int>(api.parameters[i].param_type))
      );

      auto arg = argument_extractor_.extract_argument(api.parameters[i], raw_args[i], memory);

      log_.ped(
          "extracted argument", redlog::field("index", i), redlog::field("param_name", arg.param_name),
          redlog::field("raw_value", arg.raw_value), redlog::field("string_preview", arg.string_preview),
          redlog::field("is_pointer", arg.is_valid_pointer)
      );

      result.arguments.push_back(arg);
      stats_.arguments_extracted++;
    }

    log_.ped("argument extraction complete", redlog::field("extracted_count", result.arguments.size()));
  }

  void format_call(api_analysis_result& result) {
    std::stringstream ss;

    // use demangled name if available, otherwise symbol name
    std::string name = !result.demangled_name.empty() ? result.demangled_name : result.symbol_name;
    if (name.empty()) {
      ss << result.module_name << "+0x" << std::hex << result.module_offset;
    } else {
      ss << name;
    }

    ss << "(";

    // distinguish between:
    // 1. api not found in knowledge db (unknown args) -> show "?"
    // 2. api found with no parameters -> show "()"
    // 3. api found with parameters -> show formatted args
    if (!result.found_in_knowledge_db && !result.symbol_name.empty()) {
      // api not in knowledge db - arguments unknown
      ss << "?";
    } else if (result.arguments.empty()) {
      // either api has no parameters or we're not extracting args
      // empty parentheses is correct here
    } else {
      // format arguments with semantic information
      for (size_t i = 0; i < result.arguments.size(); ++i) {
        if (i > 0) {
          ss << ", ";
        }

        const auto& arg = result.arguments[i];

        // add parameter name if known
        if (!arg.param_name.empty()) {
          ss << arg.param_name << "=";
        }

        // format value based on type
        switch (arg.param_type) {
        case param_info::type::STRING:
          if (!arg.string_preview.empty()) {
            util::value_formatter::format_options opts;
            opts.quote_strings = false; // we add quotes manually
            ss << "\"" << util::value_formatter::format_string(arg.string_preview, opts) << "\"";
          } else if (arg.is_null_pointer) {
            ss << "NULL";
          } else {
            ss << "0x" << std::hex << arg.raw_value;
          }
          break;

        case param_info::type::PATH:
          if (!arg.string_preview.empty()) {
            util::value_formatter::format_options opts;
            opts.quote_strings = false; // we add quotes manually
            ss << "\"" << util::value_formatter::format_string(arg.string_preview, opts) << "\"";
          } else if (arg.is_null_pointer) {
            ss << "NULL";
          } else {
            ss << "0x" << std::hex << arg.raw_value;
          }
          break;

        case param_info::type::POINTER:
          if (arg.is_null_pointer) {
            ss << "NULL";
          } else {
            ss << "0x" << std::hex << arg.raw_value;
          }
          break;

        case param_info::type::BOOLEAN:
          ss << (arg.raw_value ? "true" : "false");
          break;

        case param_info::type::FLAGS:
          ss << "0x" << std::hex << arg.raw_value;
          if (!arg.flag_names.empty()) {
            ss << " [";
            for (size_t j = 0; j < arg.flag_names.size(); ++j) {
              if (j > 0) {
                ss << "|";
              }
              ss << arg.flag_names[j];
            }
            ss << "]";
          }
          break;

        case param_info::type::SIZE:
        case param_info::type::COUNT:
          ss << std::dec << arg.raw_value;
          break;

        default:
          if (arg.param_type == param_info::type::INTEGER || arg.raw_value < 1000) {
            ss << std::dec << static_cast<int64_t>(arg.raw_value);
          } else {
            ss << "0x" << std::hex << arg.raw_value;
          }
          break;
        }
      }
    }

    ss << ")";

    result.formatted_call = ss.str();
  }

private:
  analyzer_config config_;
  redlog::logger log_;

  const util::module_range_index* module_index_ = nullptr;
  std::shared_ptr<api_knowledge_db> api_db_;
  std::shared_ptr<calling_convention_detector> detector_;
  argument_extractor argument_extractor_;

#ifdef WITNESS_LIEF_ENABLED
  std::unique_ptr<symbols::symbol_resolver> symbol_resolver_;
#endif

  mutable stats stats_;
};

// public interface implementation

api_analyzer::api_analyzer(const analyzer_config& config) : pimpl(std::make_unique<impl>(config)) {}

api_analyzer::~api_analyzer() = default;

void api_analyzer::initialize(const util::module_range_index& module_index) { pimpl->initialize(module_index); }

api_analysis_result api_analyzer::analyze_call(const api_context& ctx) { return pimpl->analyze_call(ctx); }

void api_analyzer::analyze_return(api_analysis_result& result, const api_context& ctx) {
  pimpl->analyze_return(result, ctx);
}

const api_knowledge_db& api_analyzer::get_api_db() const { return pimpl->get_api_db(); }

api_analyzer::stats api_analyzer::get_stats() const { return pimpl->get_stats(); }

void api_analyzer::clear_caches() { pimpl->clear_caches(); }

// helper functions implementation

namespace analysis_utils {

bool is_api_call(uint64_t address, const util::module_range_index& modules) {
  auto module = modules.find_containing(address);
  if (!module) {
    return false;
  }

  // check if it's a system library
  return module->is_system_library;
}

std::string format_api_call(const std::string& api_name, const std::vector<extracted_argument>& args) {
  std::stringstream ss;
  ss << api_name << "(";

  for (size_t i = 0; i < args.size(); ++i) {
    if (i > 0) {
      ss << ", ";
    }
    ss << "0x" << std::hex << args[i].raw_value;
  }

  ss << ")";
  return ss.str();
}

std::string describe_api_behavior(const api_info& info) {
  std::vector<std::string> behaviors;

  if (has_flag(info, api_info::behavior_flags::ALLOCATES_MEMORY)) {
    behaviors.push_back("allocates memory");
  }
  if (has_flag(info, api_info::behavior_flags::OPENS_HANDLE)) {
    behaviors.push_back("opens handle");
  }
  if (has_flag(info, api_info::behavior_flags::NETWORK_IO)) {
    behaviors.push_back("network I/O");
  }
  if (has_flag(info, api_info::behavior_flags::FILE_IO)) {
    behaviors.push_back("file I/O");
  }
  if (has_flag(info, api_info::behavior_flags::SECURITY_SENSITIVE)) {
    behaviors.push_back("security-sensitive");
  }

  if (behaviors.empty()) {
    return info.description;
  }

  std::stringstream ss;
  for (size_t i = 0; i < behaviors.size(); ++i) {
    if (i > 0) {
      ss << ", ";
    }
    ss << behaviors[i];
  }

  return ss.str();
}

} // namespace analysis_utils

} // namespace w1::abi
```

`src/w1tn3ss/abi/api_analyzer.hpp`:

```hpp
#pragma once

#include "argument_extractor.hpp"
#include "api_knowledge_db.hpp"
#include "calling_convention_detector.hpp"
#include "symbols/symbol_resolver.hpp"
#include "util/safe_memory.hpp"
#include "util/module_range_index.hpp"
#include <QBDI.h>
#include <memory>
#include <optional>
#include <string>

namespace w1::abi {

// context for api analysis
struct api_context {
  // basic call information
  uint64_t call_address;
  uint64_t target_address;
  std::string module_name;
  std::string symbol_name;

  // qbdi context
  QBDI::VMInstanceRef vm;
  const QBDI::VMState* vm_state;
  QBDI::GPRState* gpr_state;
  QBDI::FPRState* fpr_state;

  // module information
  const util::module_range_index* module_index;

  // timing
  uint64_t timestamp;
};

// result of api analysis
struct api_analysis_result {
  // symbol information
  std::string symbol_name;
  std::string demangled_name;
  std::string module_name;
  uint64_t module_offset;

  // api semantics
  api_info::category category = api_info::category::UNKNOWN;
  uint32_t behavior_flags = 0;
  std::string description;

  // extracted arguments
  std::vector<extracted_argument> arguments;

  // for return analysis
  extracted_argument return_value;

  // formatted call string
  std::string formatted_call;

  // tracking
  bool found_in_knowledge_db = false;

  // error information
  bool analysis_complete = false;
  std::string error_message;
};

// configuration for api analyzer
struct analyzer_config {
  // feature toggles
  bool resolve_symbols = true;
  bool extract_arguments = true;
  bool format_calls = true;
  bool safe_memory_only = true;

  // limits
  size_t max_string_length = 256;
  size_t max_buffer_preview = 64;
  size_t max_arguments = 16;

  // logging
  bool verbose = false;
};

// main api analyzer class
class api_analyzer {
public:
  api_analyzer(const analyzer_config& config = {});
  ~api_analyzer();

  // initialize with module information
  void initialize(const util::module_range_index& module_index);

  // analyze an api call
  api_analysis_result analyze_call(const api_context& ctx);

  // analyze return from api call
  void analyze_return(api_analysis_result& result, const api_context& ctx);

  // get api database for queries
  const api_knowledge_db& get_api_db() const;

  // get statistics
  struct stats {
    uint64_t calls_analyzed = 0;
    uint64_t symbols_resolved = 0;
    uint64_t arguments_extracted = 0;
    uint64_t apis_identified = 0;
    uint64_t errors = 0;
  };
  stats get_stats() const;

  // clear caches
  void clear_caches();

private:
  class impl;
  std::unique_ptr<impl> pimpl;
};

// helper functions
namespace analysis_utils {
// check if an address is likely an api call
bool is_api_call(uint64_t address, const util::module_range_index& modules);

// format an api call with arguments for display
std::string format_api_call(const std::string& api_name, const std::vector<extracted_argument>& args);

// get a short description of api behavior
std::string describe_api_behavior(const api_info& info);
} // namespace analysis_utils

} // namespace w1::abi
```

`src/w1tn3ss/abi/api_knowledge_db.cpp`:

```cpp
#include "api_knowledge_db.hpp"
#include <redlog.hpp>
#include <unordered_set>
#include <algorithm>
#include <fstream>
#include <w1common/ext/jsonstruct.hpp>

// platform-specific api definitions
#ifdef __APPLE__
#include "apis/macos/system_apis.hpp"
#elif defined(__linux__)
#include "apis/linux/system_apis.hpp"
#elif defined(_WIN32)
#include "apis/windows/system_apis.hpp"
#endif

namespace w1::abi {

// implementation class
class api_knowledge_db::impl {
public:
  impl() : log_("w1.api_knowledge_db") {
    log_.dbg("initializing api knowledge database");
    load_builtin_apis();
    log_.info("loaded builtin apis", redlog::field("count", apis_.size()));
  }

  std::optional<api_info> lookup(const std::string& api_name) const {
    log_.dbg("looking up api", redlog::field("name", api_name));

    // try exact match first
    auto it = apis_.find(api_name);
    if (it != apis_.end()) {
      log_.trace(
          "found api info", redlog::field("name", api_name), redlog::field("module", it->second.module),
          redlog::field("category", static_cast<int>(it->second.api_category)),
          redlog::field("param_count", it->second.parameters.size())
      );
      return it->second;
    }

    // try without underscore prefix (for macos symbols)
    if (!api_name.empty() && api_name[0] == '_') {
      std::string without_underscore = api_name.substr(1);
      it = apis_.find(without_underscore);
      if (it != apis_.end()) {
        log_.dbg(
            "found api info without underscore", redlog::field("original", api_name),
            redlog::field("matched", without_underscore), redlog::field("module", it->second.module),
            redlog::field("param_count", it->second.parameters.size())
        );
        return it->second;
      }
    }

    // try with underscore prefix (for macos symbols)
    std::string with_underscore = "_" + api_name;
    it = apis_.find(with_underscore);
    if (it != apis_.end()) {
      log_.dbg(
          "found api info with underscore", redlog::field("original", api_name),
          redlog::field("matched", with_underscore), redlog::field("module", it->second.module),
          redlog::field("param_count", it->second.parameters.size())
      );
      return it->second;
    }

    log_.dbg("api not found", redlog::field("name", api_name));
    return std::nullopt;
  }

  std::optional<api_info> lookup(const std::string& module, const std::string& api_name) const {
    log_.dbg("looking up api with module", redlog::field("module", module), redlog::field("name", api_name));

    // try exact match first
    auto it = apis_.find(api_name);
    if (it != apis_.end() && it->second.module == module) {
      log_.dbg("found exact match", redlog::field("name", api_name));
      return it->second;
    }

    // try module prefix match (e.g., "libc.so.6" matches "libc.so")
    if (it != apis_.end()) {
      if (it->second.module.find(module) != std::string::npos || module.find(it->second.module) != std::string::npos) {
        log_.dbg(
            "found partial module match", redlog::field("name", api_name),
            redlog::field("actual_module", it->second.module)
        );
        return it->second;
      }
    }

    log_.dbg("api not found for module", redlog::field("module", module), redlog::field("name", api_name));
    return std::nullopt;
  }

  std::vector<std::string> get_apis_by_category(api_info::category category) const {
    log_.dbg("getting apis by category", redlog::field("category", static_cast<int>(category)));

    std::vector<std::string> result;
    for (const auto& [name, info] : apis_) {
      if (info.api_category == category) {
        result.push_back(name);
      }
    }

    log_.dbg(
        "found apis in category", redlog::field("category", static_cast<int>(category)),
        redlog::field("count", result.size())
    );
    return result;
  }

  std::vector<std::string> get_apis_with_flags(uint32_t flags) const {
    log_.dbg("getting apis with flags", redlog::field("flags", flags));

    std::vector<std::string> result;
    for (const auto& [name, info] : apis_) {
      if ((info.flags & flags) == flags) {
        result.push_back(name);
      }
    }

    log_.dbg("found apis with flags", redlog::field("flags", flags), redlog::field("count", result.size()));
    return result;
  }

  bool is_known_api(const std::string& api_name) const {
    bool known = apis_.find(api_name) != apis_.end();
    log_.dbg("checking if api is known", redlog::field("name", api_name), redlog::field("known", known));
    return known;
  }

  std::vector<std::string> get_module_apis(const std::string& module) const {
    log_.dbg("getting apis for module", redlog::field("module", module));

    std::vector<std::string> result;
    for (const auto& [name, info] : apis_) {
      if (info.module == module) {
        result.push_back(name);
      }
    }

    log_.dbg("found module apis", redlog::field("module", module), redlog::field("count", result.size()));
    return result;
  }

  void add_api(const api_info& info) {
    log_.dbg(
        "adding api to knowledge database", redlog::field("name", info.name), redlog::field("module", info.module),
        redlog::field("category", static_cast<int>(info.api_category))
    );

    apis_[info.name] = info;
    modules_.insert(info.module);
  }

  bool load_from_file(const std::string& path) {
    log_.info("loading api definitions from file", redlog::field("path", path));

    try {
      std::ifstream file(path);
      if (!file.is_open()) {
        log_.err("failed to open file", redlog::field("path", path));
        return false;
      }

      // read entire file into string
      std::string json_content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());

      // todo: parse using jsonstruct - need to define proper structs with js_object macros
      // for now, just log that we need to implement this
      log_.warn("JSON parsing using jsonstruct not yet implemented - need to define JS_OBJECT structs");
      return false;

    } catch (const std::exception& e) {
      log_.err("failed to read api definitions file", redlog::field("path", path), redlog::field("error", e.what()));
      return false;
    }
  }

  size_t get_api_count() const { return apis_.size(); }
  size_t get_module_count() const { return modules_.size(); }

private:
  redlog::logger log_;
  std::unordered_map<std::string, api_info> apis_;
  std::unordered_set<std::string> modules_;

  void load_builtin_apis() {
    log_.dbg("loading builtin apis for platform");

    // load platform-specific apis
#ifdef __APPLE__
    load_api_set(apis::macos::macos_system_apis, "macos system apis");
#elif defined(__linux__)
    load_api_set(apis::linux::linux_system_apis, "linux system apis");
#elif defined(_WIN32)
    auto windows_apis = apis::windows::get_all_windows_apis();
    load_api_set(windows_apis, "windows system apis");
#endif
  }

  void load_api_set(const std::vector<api_info>& api_set, const std::string& set_name) {
    log_.trc("loading api set", redlog::field("name", set_name));

    for (const auto& api : api_set) {
      add_api(api);
    }

    log_.trc("loaded api set", redlog::field("name", set_name), redlog::field("count", api_set.size()));
  }

  // string conversion helpers
  api_info::category string_to_category(const std::string& s) {
    static const std::unordered_map<std::string, api_info::category> map = {
        {"FILE_IO", api_info::category::FILE_IO},
        {"FILE_MANAGEMENT", api_info::category::FILE_MANAGEMENT},
        {"PROCESS_CONTROL", api_info::category::PROCESS_CONTROL},
        {"MEMORY_MANAGEMENT", api_info::category::MEMORY_MANAGEMENT},
        {"HEAP_MANAGEMENT", api_info::category::HEAP_MANAGEMENT},
        {"NETWORK_SOCKET", api_info::category::NETWORK_SOCKET}
        // add more as needed
    };

    auto it = map.find(s);
    return it != map.end() ? it->second : api_info::category::UNKNOWN;
  }

  uint32_t string_to_flag(const std::string& s) {
    static const std::unordered_map<std::string, api_info::behavior_flags> map = {
        {"ALLOCATES_MEMORY", api_info::behavior_flags::ALLOCATES_MEMORY},
        {"FREES_MEMORY", api_info::behavior_flags::FREES_MEMORY},
        {"OPENS_HANDLE", api_info::behavior_flags::OPENS_HANDLE},
        {"CLOSES_HANDLE", api_info::behavior_flags::CLOSES_HANDLE},
        {"BLOCKING", api_info::behavior_flags::BLOCKING},
        {"FILE_IO", api_info::behavior_flags::FILE_IO}
        // add more as needed
    };

    auto it = map.find(s);
    return it != map.end() ? static_cast<uint32_t>(it->second) : 0;
  }

  param_info::type string_to_param_type(const std::string& s) {
    static const std::unordered_map<std::string, param_info::type> map = {
        {"INTEGER", param_info::type::INTEGER}, {"POINTER", param_info::type::POINTER},
        {"SIZE", param_info::type::SIZE},       {"FLAGS", param_info::type::FLAGS},
        {"HANDLE", param_info::type::HANDLE},   {"FILE_DESCRIPTOR", param_info::type::FILE_DESCRIPTOR},
        {"STRING", param_info::type::STRING},   {"BUFFER", param_info::type::BUFFER},
        {"PATH", param_info::type::PATH}
        // add more as needed
    };

    auto it = map.find(s);
    return it != map.end() ? it->second : param_info::type::UNKNOWN;
  }

  param_info::direction string_to_direction(const std::string& s) {
    if (s == "OUT") {
      return param_info::direction::OUT;
    }
    if (s == "IN_OUT") {
      return param_info::direction::IN_OUT;
    }
    return param_info::direction::IN;
  }
};

// api_knowledge_db implementation
api_knowledge_db::api_knowledge_db() : pimpl(std::make_unique<impl>()) {}
api_knowledge_db::~api_knowledge_db() = default;

std::optional<api_info> api_knowledge_db::lookup(const std::string& api_name) const { return pimpl->lookup(api_name); }

std::optional<api_info> api_knowledge_db::lookup(const std::string& module, const std::string& api_name) const {
  return pimpl->lookup(module, api_name);
}

std::vector<std::string> api_knowledge_db::get_apis_by_category(api_info::category category) const {
  return pimpl->get_apis_by_category(category);
}

std::vector<std::string> api_knowledge_db::get_apis_with_flags(uint32_t flags) const {
  return pimpl->get_apis_with_flags(flags);
}

bool api_knowledge_db::is_known_api(const std::string& api_name) const { return pimpl->is_known_api(api_name); }

std::vector<std::string> api_knowledge_db::get_module_apis(const std::string& module) const {
  return pimpl->get_module_apis(module);
}

void api_knowledge_db::add_api(const api_info& info) { pimpl->add_api(info); }

bool api_knowledge_db::load_from_file(const std::string& path) { return pimpl->load_from_file(path); }

size_t api_knowledge_db::get_api_count() const { return pimpl->get_api_count(); }

size_t api_knowledge_db::get_module_count() const { return pimpl->get_module_count(); }

// helper functions
param_info::type infer_param_type(const std::string& param_name, const std::string& type_name) {
  // infer based on common naming patterns
  std::string lower_name = param_name;
  std::transform(lower_name.begin(), lower_name.end(), lower_name.begin(), ::tolower);

  if (lower_name.find("path") != std::string::npos || lower_name.find("file") != std::string::npos) {
    return param_info::type::PATH;
  }

  if (lower_name.find("size") != std::string::npos || lower_name.find("len") != std::string::npos ||
      lower_name.find("count") != std::string::npos) {
    return param_info::type::SIZE;
  }

  if (lower_name.find("flags") != std::string::npos || lower_name.find("mode") != std::string::npos) {
    return param_info::type::FLAGS;
  }

  if (lower_name.find("handle") != std::string::npos || lower_name == "h" ||
      lower_name.find("hwnd") != std::string::npos) {
    return param_info::type::HANDLE;
  }

  if (lower_name == "fd" || lower_name.find("descriptor") != std::string::npos) {
    return param_info::type::FILE_DESCRIPTOR;
  }

  if (lower_name.find("buffer") != std::string::npos || lower_name.find("buf") != std::string::npos ||
      lower_name.find("data") != std::string::npos) {
    return param_info::type::BUFFER;
  }

  if (lower_name.find("str") != std::string::npos || lower_name.find("name") != std::string::npos ||
      lower_name.find("text") != std::string::npos) {
    return param_info::type::STRING;
  }

  // check type name hints
  std::string lower_type = type_name;
  std::transform(lower_type.begin(), lower_type.end(), lower_type.begin(), ::tolower);

  if (lower_type.find("char*") != std::string::npos || lower_type.find("wchar*") != std::string::npos) {
    return param_info::type::STRING;
  }

  if (lower_type.find("void*") != std::string::npos || lower_type.find("ptr") != std::string::npos) {
    return param_info::type::POINTER;
  }

  if (lower_type.find("int") != std::string::npos || lower_type.find("long") != std::string::npos ||
      lower_type.find("dword") != std::string::npos) {
    return param_info::type::INTEGER;
  }

  return param_info::type::UNKNOWN;
}

std::string format_api_signature(const api_info& info) {
  std::string sig = info.return_value.name + " " + info.name + "(";

  for (size_t i = 0; i < info.parameters.size(); ++i) {
    if (i > 0) {
      sig += ", ";
    }

    const auto& param = info.parameters[i];
    sig += param.name;

    if (param.param_direction == param_info::direction::OUT) {
      sig += " [out]";
    } else if (param.param_direction == param_info::direction::IN_OUT) {
      sig += " [in,out]";
    }

    if (param.is_optional) {
      sig += " [opt]";
    }
  }

  sig += ")";
  return sig;
}

} // namespace w1::abi

```

`src/w1tn3ss/abi/api_knowledge_db.hpp`:

```hpp
#pragma once

#include "calling_convention_base.hpp"
#include <string>
#include <vector>
#include <optional>
#include <unordered_map>
#include <memory>

namespace w1::abi {

// represents semantic information about an api parameter
struct param_info {
  enum class type {
    UNKNOWN,
    // numeric types
    INTEGER,
    UNSIGNED,
    POINTER,
    SIZE,
    COUNT,
    FLAGS,
    BOOLEAN,
    FLOAT,
    DOUBLE,
    FLOATING_POINT, // generic floating point (float or double)
    // special types
    HANDLE,
    FILE_DESCRIPTOR,
    STRING,
    WSTRING, // wide string (windows)
    BUFFER,
    STRUCT,
    CALLBACK,
    VOID, // for return values
    // semantic types
    PATH,
    URL,
    REGISTRY_KEY,
    PROCESS_ID,
    THREAD_ID,
    ERROR_CODE
  };

  enum class direction {
    IN,    // input parameter
    OUT,   // output parameter
    IN_OUT // both input and output
  };

  std::string name;
  type param_type = type::UNKNOWN;
  direction param_direction = direction::IN;
  size_t size_hint = 0; // for buffers/structs
  bool is_optional = false;
  std::string description;
  std::string type_description; // human-readable type description

  // relationships to other parameters
  int size_param_index = -1;  // if this is a buffer, which param contains its size
  int count_param_index = -1; // if this is an array, which param contains count
  size_t buffer_size = 0;     // known buffer size

  // for flags parameters
  std::unordered_map<uint32_t, std::string> flag_values; // flag -> name mapping
};

// represents semantic information about an api function
struct api_info {
  enum class category {
    UNKNOWN,
    // file operations
    FILE_IO,
    FILE_MANAGEMENT,
    STDIO,     // standard i/o (printf, puts, etc)
    DEVICE_IO, // device control operations (ioctl, etc)
    // process/thread
    PROCESS_CONTROL,
    THREAD_CONTROL,
    THREADING, // thread creation and management
    // memory
    MEMORY_MANAGEMENT,
    HEAP_MANAGEMENT,
    // synchronization
    SYNCHRONIZATION,
    MUTEX,
    EVENT,
    SEMAPHORE,
    // network
    NETWORK_SOCKET,
    NETWORK_DNS,
    NETWORK_HTTP,
    // registry (windows)
    REGISTRY,
    // security
    SECURITY,
    CRYPTO,
    // system
    SYSTEM_INFO,
    TIME,
    ENVIRONMENT, // environment variables
    // string/locale
    STRING_MANIPULATION,
    LOCALE,
    // dll/library
    LIBRARY_LOADING,
    // ipc
    IPC,
    PIPE,
    SHARED_MEMORY,
    // ui (if needed)
    UI,
    WINDOW,
    // system hooks and monitoring
    SYSTEM_HOOK,
    // math and utilities
    MATH,    // mathematical operations
    SORTING, // sorting and searching algorithms
    // other
    MISC
  };

  enum class behavior_flags : uint32_t {
    NONE = 0,
    ALLOCATES_MEMORY = 1 << 0,      // function allocates memory
    FREES_MEMORY = 1 << 1,          // function frees memory
    OPENS_HANDLE = 1 << 2,          // creates a handle/fd
    CLOSES_HANDLE = 1 << 3,         // closes a handle/fd
    BLOCKING = 1 << 4,              // may block
    ASYNC = 1 << 5,                 // asynchronous operation
    MODIFIES_GLOBAL_STATE = 1 << 6, // changes process-wide state
    THREAD_SAFE = 1 << 7,           // documented as thread-safe
    DEPRECATED = 1 << 8,            // deprecated api
    SECURITY_SENSITIVE = 1 << 9,    // security-relevant
    NETWORK_IO = 1 << 10,           // performs network i/o
    FILE_IO = 1 << 11,              // performs file i/o
    REGISTRY_ACCESS = 1 << 12,      // accesses registry (windows)
    PRIVILEGED = 1 << 13            // requires elevated privileges
  };

  std::string name;
  std::string module; // e.g., "kernel32.dll", "libc.so.6"
  category api_category = category::UNKNOWN;
  uint32_t flags = 0;

  // calling convention
  calling_convention_id convention = calling_convention_id::UNKNOWN;
  // platform-specific overrides (e.g., "win32" -> x86_stdcall)
  std::unordered_map<std::string, calling_convention_id> platform_conventions;

  // parameters
  std::vector<param_info> parameters;
  param_info return_value;

  // semantic information
  std::string description;
  std::vector<std::string> common_errors;  // common error conditions
  std::vector<std::string> security_notes; // security considerations

  // relationships
  std::vector<std::string> related_apis; // similar or companion apis
  std::string cleanup_api;               // api to call for cleanup (e.g., free for malloc)

  // platform info
  std::string min_version;          // minimum os version
  std::vector<std::string> headers; // header files that declare this
};

// knowledge database for api semantics
class api_knowledge_db {
public:
  api_knowledge_db();
  ~api_knowledge_db();

  // lookup api information
  std::optional<api_info> lookup(const std::string& api_name) const;
  std::optional<api_info> lookup(const std::string& module, const std::string& api_name) const;

  // query apis by category
  std::vector<std::string> get_apis_by_category(api_info::category category) const;

  // query apis by behavior
  std::vector<std::string> get_apis_with_flags(uint32_t flags) const;

  // check if api is known
  bool is_known_api(const std::string& api_name) const;

  // get all apis in a module
  std::vector<std::string> get_module_apis(const std::string& module) const;

  // add custom api info (for extending the database)
  void add_api(const api_info& info);

  // load additional definitions from file
  bool load_from_file(const std::string& path);

  // get statistics
  size_t get_api_count() const;
  size_t get_module_count() const;

private:
  class impl;
  std::unique_ptr<impl> pimpl;
};

// helper functions for working with api info
inline bool has_flag(const api_info& info, api_info::behavior_flags flag) {
  return (info.flags & static_cast<uint32_t>(flag)) != 0;
}

inline void set_flag(api_info& info, api_info::behavior_flags flag) { info.flags |= static_cast<uint32_t>(flag); }

// common parameter type detection
param_info::type infer_param_type(const std::string& param_name, const std::string& type_name);

// format api signature for display
std::string format_api_signature(const api_info& info);

} // namespace w1::abi

```

`src/w1tn3ss/abi/api_listener.cpp`:

```cpp
#include "api_listener.hpp"
#include "api_analyzer.hpp"
#include "util/module_range_index.hpp"
#include "util/value_formatter.hpp"
#include <redlog.hpp>
#include <algorithm>
#include <chrono>

namespace w1::abi {

// pending call info for return matching
struct pending_call {
  uint64_t call_target_address;
  std::string target_symbol_name;
  std::string target_module;
  api_info api_info;
  uint64_t timestamp;
};

class api_listener::impl {
public:
  explicit impl(const analyzer_config& config);

  // constants
  static constexpr size_t MAX_PENDING_CALLS = 10000;

  // callbacks
  std::unordered_map<std::string, std::vector<api_callback_fn>> symbol_callbacks_; // "module|symbol" -> callbacks
  std::unordered_map<std::string, std::vector<api_callback_fn>> module_callbacks_;
  std::unordered_map<api_info::category, std::vector<api_callback_fn>> category_callbacks_;

  // api analyzer
  std::unique_ptr<api_analyzer> analyzer_;

  // pending calls for return matching
  std::vector<pending_call> call_stack_;

  // statistics
  stats stats_;

  // logger
  redlog::logger log_;

  // helper methods
  bool has_callbacks_for(const std::string& module, const std::string& symbol, api_info::category category) const;
  api_event create_event_from_analysis(
      const api_analysis_result& analysis, const api_context& ctx, api_event::event_type type
  );
  void dispatch_event(const api_event& event);
  std::string make_filter_key(const std::string& module, const std::string& symbol) const;
  std::optional<pending_call> find_and_remove_matching_call(uint64_t return_from_address);
};

api_listener::impl::impl(const analyzer_config& config)
    : analyzer_(std::make_unique<api_analyzer>(config)), stats_{}, log_("w1.api_listener") {}

bool api_listener::impl::has_callbacks_for(
    const std::string& module, const std::string& symbol, api_info::category category
) const {
  // check if any callbacks are registered for this API
  auto key = make_filter_key(module, symbol);
  bool has_symbol_cb = symbol_callbacks_.count(key) > 0;
  bool has_module_cb = module_callbacks_.count(module) > 0;
  bool has_category_cb = category != api_info::category::UNKNOWN && category_callbacks_.count(category) > 0;

  log_.dbg(
      "checking callbacks", redlog::field("module", module), redlog::field("symbol", symbol), redlog::field("key", key),
      redlog::field("category", static_cast<int>(category)), redlog::field("has_symbol_cb", has_symbol_cb),
      redlog::field("has_module_cb", has_module_cb), redlog::field("has_category_cb", has_category_cb)
  );

  return has_symbol_cb || has_module_cb || has_category_cb;
}

api_event api_listener::impl::create_event_from_analysis(
    const api_analysis_result& analysis, const api_context& ctx, api_event::event_type type
) {
  api_event event;
  event.type = type;
  event.timestamp = ctx.timestamp;
  event.source_address = ctx.call_address;
  event.target_address = ctx.target_address;
  event.module_name = ctx.module_name;
  event.symbol_name = ctx.symbol_name;
  event.category = analysis.category;
  event.description = analysis.description;
  event.formatted_call = analysis.formatted_call;
  event.analysis_complete = analysis.analysis_complete;

  // convert arguments
  w1::util::value_formatter::format_options fmt_opts;
  fmt_opts.max_string_length = 256;

  for (const auto& arg : analysis.arguments) {
    api_event::argument evt_arg;
    evt_arg.raw_value = arg.raw_value;
    evt_arg.param_name = arg.param_name;
    evt_arg.param_type = arg.param_type;
    evt_arg.is_pointer = arg.is_valid_pointer;

    // format interpreted value
    if (!arg.string_preview.empty()) {
      evt_arg.interpreted_value = w1::util::value_formatter::format_string(arg.string_preview, fmt_opts);
    } else if (arg.is_null_pointer) {
      evt_arg.interpreted_value = "NULL";
    } else if (std::holds_alternative<std::string>(arg.interpreted_value)) {
      evt_arg.interpreted_value =
          w1::util::value_formatter::format_string(std::get<std::string>(arg.interpreted_value), fmt_opts);
    } else if (std::holds_alternative<bool>(arg.interpreted_value)) {
      evt_arg.interpreted_value = w1::util::value_formatter::format_bool(std::get<bool>(arg.interpreted_value));
    } else if (std::holds_alternative<std::vector<uint8_t>>(arg.interpreted_value)) {
      evt_arg.interpreted_value =
          w1::util::value_formatter::format_buffer(std::get<std::vector<uint8_t>>(arg.interpreted_value), fmt_opts);
    } else {
      // fallback to type-based formatting
      auto value_type = w1::util::value_formatter::value_type::UNKNOWN;
      if (arg.param_type == param_info::type::BOOLEAN) {
        value_type = w1::util::value_formatter::value_type::BOOLEAN;
      } else if (arg.param_type == param_info::type::ERROR_CODE) {
        value_type = w1::util::value_formatter::value_type::ERROR_CODE;
      } else if (arg.is_valid_pointer) {
        value_type = w1::util::value_formatter::value_type::POINTER;
      }
      evt_arg.interpreted_value = w1::util::value_formatter::format_typed_value(arg.raw_value, value_type, fmt_opts);
    }

    event.arguments.push_back(evt_arg);
  }

  // handle return value if present
  if (type == api_event::event_type::RETURN && analysis.return_value.param_type != param_info::type::VOID) {
    const auto& ret_val = analysis.return_value;
    api_event::argument evt_ret;
    evt_ret.raw_value = ret_val.raw_value;
    evt_ret.param_type = ret_val.param_type;
    evt_ret.is_pointer = ret_val.is_valid_pointer;

    // format return value
    if (!ret_val.string_preview.empty()) {
      evt_ret.interpreted_value = w1::util::value_formatter::format_string(ret_val.string_preview, fmt_opts);
    } else if (ret_val.is_null_pointer) {
      evt_ret.interpreted_value = "NULL";
    } else if (std::holds_alternative<std::string>(ret_val.interpreted_value)) {
      evt_ret.interpreted_value =
          w1::util::value_formatter::format_string(std::get<std::string>(ret_val.interpreted_value), fmt_opts);
    } else if (std::holds_alternative<bool>(ret_val.interpreted_value)) {
      evt_ret.interpreted_value = w1::util::value_formatter::format_bool(std::get<bool>(ret_val.interpreted_value));
    } else {
      // fallback to type-based formatting
      auto value_type = w1::util::value_formatter::value_type::UNKNOWN;
      if (ret_val.param_type == param_info::type::BOOLEAN) {
        value_type = w1::util::value_formatter::value_type::BOOLEAN;
      } else if (ret_val.param_type == param_info::type::ERROR_CODE) {
        value_type = w1::util::value_formatter::value_type::ERROR_CODE;
      } else if (ret_val.is_valid_pointer) {
        value_type = w1::util::value_formatter::value_type::POINTER;
      }
      evt_ret.interpreted_value =
          w1::util::value_formatter::format_typed_value(ret_val.raw_value, value_type, fmt_opts);
    }

    event.return_value = evt_ret;
  }

  return event;
}

void api_listener::impl::dispatch_event(const api_event& event) {
  // dispatch to specific callbacks
  auto key = make_filter_key(event.module_name, event.symbol_name);

  // symbol callbacks
  auto sym_it = symbol_callbacks_.find(key);
  if (sym_it != symbol_callbacks_.end()) {
    for (const auto& cb : sym_it->second) {
      cb(event);
    }
  }

  // module callbacks
  auto mod_it = module_callbacks_.find(event.module_name);
  if (mod_it != module_callbacks_.end()) {
    for (const auto& cb : mod_it->second) {
      cb(event);
    }
  }

  // category callbacks
  if (event.category != api_info::category::UNKNOWN) {
    auto cat_it = category_callbacks_.find(event.category);
    if (cat_it != category_callbacks_.end()) {
      for (const auto& cb : cat_it->second) {
        cb(event);
      }
    }
  }
}

std::optional<pending_call> api_listener::impl::find_and_remove_matching_call(uint64_t return_from_address) {
  // search in reverse order for most recent call
  auto call_it =
      std::find_if(call_stack_.rbegin(), call_stack_.rend(), [return_from_address](const pending_call& call) {
        return call.call_target_address == return_from_address;
      });

  if (call_it != call_stack_.rend()) {
    pending_call result = *call_it;
    // remove from stack (convert reverse iterator to forward iterator for erase)
    call_stack_.erase(std::next(call_it).base());
    return result;
  }
  return std::nullopt;
}

std::string api_listener::impl::make_filter_key(const std::string& module, const std::string& symbol) const {
  return module + "|" + symbol;
}

// api_listener public interface implementation

api_listener::api_listener(const analyzer_config& config) : pimpl_(std::make_unique<impl>(config)) {}

api_listener::~api_listener() = default;

void api_listener::initialize(const util::module_range_index& index) { pimpl_->analyzer_->initialize(index); }

// direct analysis methods for w1xfer
std::optional<api_event> api_listener::analyze_call(const api_context& ctx) {
  pimpl_->stats_.total_calls_processed++;

  // perform analysis
  auto analysis = pimpl_->analyzer_->analyze_call(ctx);

  // if analysis failed completely, return empty
  if (!analysis.analysis_complete) {
    return std::nullopt;
  }

  // for unknown apis (not in knowledge db), still return event if we have a symbol name
  if (analysis.category == api_info::category::UNKNOWN && analysis.symbol_name.empty()) {
    return std::nullopt;
  }

  pimpl_->stats_.calls_analyzed++;

  // track for return matching if has return value
  if (auto api_info = pimpl_->analyzer_->get_api_db().lookup(analysis.symbol_name)) {
    if (api_info->return_value.param_type != param_info::type::VOID) {
      pending_call pending;
      pending.call_target_address = ctx.target_address;
      pending.target_symbol_name = ctx.symbol_name;
      pending.target_module = ctx.module_name;
      pending.api_info = *api_info;
      pending.timestamp = ctx.timestamp;

      // limit call stack size to prevent unbounded growth
      if (pimpl_->call_stack_.size() >= impl::MAX_PENDING_CALLS) {
        pimpl_->log_.wrn("pending call stack limit reached, removing oldest entry");
        pimpl_->call_stack_.erase(pimpl_->call_stack_.begin());
      }

      pimpl_->call_stack_.push_back(pending);
    }
  }

  // create and return event
  return pimpl_->create_event_from_analysis(analysis, ctx, api_event::event_type::CALL);
}

std::optional<api_event> api_listener::analyze_return(const api_context& ctx) {
  pimpl_->stats_.total_returns_processed++;

  // find and remove matching call
  auto source_addr = ctx.target_address; // function we're returning from
  auto matching_call = pimpl_->find_and_remove_matching_call(source_addr);

  if (!matching_call) {
    return std::nullopt;
  }

  // create analysis result from matching call
  api_analysis_result return_analysis;
  return_analysis.symbol_name = matching_call->target_symbol_name;
  return_analysis.module_name = matching_call->target_module;
  return_analysis.category = matching_call->api_info.api_category;
  return_analysis.description = matching_call->api_info.description;
  return_analysis.analysis_complete = true;

  // analyze return value
  pimpl_->analyzer_->analyze_return(return_analysis, ctx);
  pimpl_->stats_.returns_analyzed++;

  // create and return event
  return pimpl_->create_event_from_analysis(return_analysis, ctx, api_event::event_type::RETURN);
}

void api_listener::register_symbol_callback(
    const std::string& module, const std::string& symbol, api_callback_fn callback
) {
  auto key = pimpl_->make_filter_key(module, symbol);
  pimpl_->symbol_callbacks_[key].push_back(callback);

  pimpl_->log_.inf(
      "registered symbol callback", redlog::field("module", module), redlog::field("symbol", symbol),
      redlog::field("key", key), redlog::field("total_callbacks", pimpl_->symbol_callbacks_[key].size())
  );
}

void api_listener::register_module_callback(const std::string& module, api_callback_fn callback) {
  pimpl_->module_callbacks_[module].push_back(callback);
}

void api_listener::register_category_callback(api_info::category category, api_callback_fn callback) {
  pimpl_->category_callbacks_[category].push_back(callback);
}

void api_listener::unregister_symbol_callback(const std::string& module, const std::string& symbol) {
  auto key = pimpl_->make_filter_key(module, symbol);
  pimpl_->symbol_callbacks_.erase(key);
}

void api_listener::unregister_module_callback(const std::string& module) { pimpl_->module_callbacks_.erase(module); }

void api_listener::unregister_category_callback(api_info::category category) {
  pimpl_->category_callbacks_.erase(category);
}

void api_listener::clear_all_callbacks() {
  pimpl_->symbol_callbacks_.clear();
  pimpl_->module_callbacks_.clear();
  pimpl_->category_callbacks_.clear();
}

// callback-based processing for scripts
void api_listener::process_call(const api_context& ctx) {
  pimpl_->stats_.total_calls_processed++;

  // check if we have any callbacks for this API
  auto initial_category = api_info::category::UNKNOWN;
  if (auto api_info = pimpl_->analyzer_->get_api_db().lookup(ctx.symbol_name)) {
    initial_category = api_info->api_category;
  }

  if (!pimpl_->has_callbacks_for(ctx.module_name, ctx.symbol_name, initial_category)) {
    pimpl_->stats_.calls_filtered_out++;
    return;
  }

  // analyze if we have callbacks
  if (auto event = analyze_call(ctx)) {
    pimpl_->dispatch_event(*event);
  }
}

void api_listener::process_return(const api_context& ctx) {
  pimpl_->stats_.total_returns_processed++;

  // peek at the matching call to check if we have callbacks
  auto source_addr = ctx.target_address; // function we're returning from
  auto call_it =
      std::find_if(pimpl_->call_stack_.rbegin(), pimpl_->call_stack_.rend(), [source_addr](const pending_call& call) {
        return call.call_target_address == source_addr;
      });

  if (call_it == pimpl_->call_stack_.rend()) {
    return; // no matching call
  }

  // check if we have callbacks for this return
  if (!pimpl_->has_callbacks_for(call_it->target_module, call_it->target_symbol_name, call_it->api_info.api_category)) {
    pimpl_->stats_.calls_filtered_out++;
    return;
  }

  // analyze if we have callbacks
  if (auto event = analyze_return(ctx)) {
    pimpl_->dispatch_event(*event);
  }
}

api_analyzer& api_listener::get_analyzer() { return *pimpl_->analyzer_; }

const api_knowledge_db& api_listener::get_api_db() const { return pimpl_->analyzer_->get_api_db(); }

api_listener::stats api_listener::get_stats() const { return pimpl_->stats_; }

} // namespace w1::abi
```

`src/w1tn3ss/abi/api_listener.hpp`:

```hpp
#pragma once

#include "api_analyzer.hpp"
#include "api_knowledge_db.hpp"
#include <functional>
#include <memory>
#include <optional>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>

namespace w1::util {
class module_range_index;
}

namespace w1::abi {

// forward declarations
struct api_context;

// unified event structure for both calls and returns
struct api_event {
  enum class event_type { CALL, RETURN };

  event_type type;
  uint64_t timestamp;
  uint64_t source_address;
  uint64_t target_address;

  // api identification
  std::string module_name;
  std::string symbol_name;

  // analysis results
  api_info::category category;
  std::string description;
  std::string formatted_call;
  bool analysis_complete;

  // extracted arguments (for calls)
  struct argument {
    uint64_t raw_value;
    std::string param_name;
    param_info::type param_type;
    bool is_pointer;
    std::string interpreted_value;
  };
  std::vector<argument> arguments;

  // return value (for returns)
  std::optional<argument> return_value;
};

// callback function type
using api_callback_fn = std::function<void(const api_event&)>;

// api listener for monitoring and analyzing API calls
//
// THREAD SAFETY: This class is NOT thread-safe. All methods must be called
// from the same thread, or external synchronization must be provided.
// This includes:
// - Registration/unregistration of callbacks
// - Processing of call/return events
// - Initialization and shutdown
//
// Note: Callbacks are invoked synchronously in the context of process_call/return
class api_listener {
public:
  // constructor with optional custom analyzer config
  explicit api_listener(const analyzer_config& config = analyzer_config{});
  ~api_listener();

  // initialization (must be called before processing)
  void initialize(const util::module_range_index& index);

  // direct analysis - analyze and return event (for w1xfer)
  // returns nullopt if the call/return is not an API
  std::optional<api_event> analyze_call(const api_context& ctx);
  std::optional<api_event> analyze_return(const api_context& ctx);

  // callback-based processing - analyze and dispatch to callbacks (for scripts)
  // only analyzes if there are matching callbacks registered
  void process_call(const api_context& ctx);
  void process_return(const api_context& ctx);

  // callback registration (for callback-based processing)
  void register_symbol_callback(const std::string& module, const std::string& symbol, api_callback_fn callback);
  void register_module_callback(const std::string& module, api_callback_fn callback);
  void register_category_callback(api_info::category category, api_callback_fn callback);

  // remove callbacks
  void unregister_symbol_callback(const std::string& module, const std::string& symbol);
  void unregister_module_callback(const std::string& module);
  void unregister_category_callback(api_info::category category);
  void clear_all_callbacks();

  // access to underlying components
  api_analyzer& get_analyzer();
  const api_knowledge_db& get_api_db() const;

  // statistics
  struct stats {
    uint64_t total_calls_processed;
    uint64_t total_returns_processed;
    uint64_t calls_analyzed;
    uint64_t returns_analyzed;
    uint64_t calls_filtered_out;
  };
  stats get_stats() const;

private:
  class impl;
  std::unique_ptr<impl> pimpl_;
};

} // namespace w1::abi
```

`src/w1tn3ss/abi/apis/linux/system_apis.hpp`:

```hpp
#pragma once

#include "abi/api_knowledge_db.hpp"
#include <vector>

namespace w1::abi::apis::linux {

// determine Linux calling convention based on architecture
#if defined(__x86_64__)
#define LINUX_API_CONVENTION calling_convention_id::X86_64_SYSTEM_V
#elif defined(__aarch64__)
#define LINUX_API_CONVENTION calling_convention_id::AARCH64_AAPCS
#elif defined(__arm__)
#define LINUX_API_CONVENTION calling_convention_id::ARM32_AAPCS
#elif defined(__i386__)
#define LINUX_API_CONVENTION calling_convention_id::X86_CDECL
#else
#warning "Unknown Linux architecture, using UNKNOWN calling convention"
#define LINUX_API_CONVENTION calling_convention_id::UNKNOWN
#endif

// Linux system library APIs
static const std::vector<api_info> linux_system_apis = {
    // stdio APIs from libc
    {.name = "puts",
     .module = "libc.so.6",
     .api_category = api_info::category::STDIO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = LINUX_API_CONVENTION,
     .parameters =
         {{.name = "s", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "write string to stdout",
     .headers = {"stdio.h"}},
    {.name = "printf",
     .module = "libc.so.6",
     .api_category = api_info::category::STDIO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = LINUX_API_CONVENTION,
     .parameters =
         {
             {.name = "format", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}
             // Note: variadic args not handled yet
         },
     .return_value = {.name = "chars_written", .param_type = param_info::type::INTEGER},
     .description = "formatted output to stdout",
     .headers = {"stdio.h"}},
    {.name = "fprintf",
     .module = "libc.so.6",
     .api_category = api_info::category::STDIO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = LINUX_API_CONVENTION,
     .parameters =
         {{.name = "stream", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "format", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "chars_written", .param_type = param_info::type::INTEGER},
     .description = "formatted output to stream",
     .headers = {"stdio.h"}},

    // malloc APIs from libc
    {.name = "malloc",
     .module = "libc.so.6",
     .api_category = api_info::category::HEAP_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = LINUX_API_CONVENTION,
     .parameters =
         {{.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "ptr", .param_type = param_info::type::POINTER},
     .description = "allocate memory",
     .cleanup_api = "free",
     .headers = {"stdlib.h"}},
    {.name = "free",
     .module = "libc.so.6",
     .api_category = api_info::category::HEAP_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FREES_MEMORY),
     .convention = LINUX_API_CONVENTION,
     .parameters =
         {{.name = "ptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "free allocated memory",
     .headers = {"stdlib.h"}},
    {.name = "calloc",
     .module = "libc.so.6",
     .api_category = api_info::category::HEAP_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = LINUX_API_CONVENTION,
     .parameters =
         {{.name = "nmemb", .param_type = param_info::type::COUNT, .param_direction = param_info::direction::IN},
          {.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "ptr", .param_type = param_info::type::POINTER},
     .description = "allocate and zero memory",
     .cleanup_api = "free",
     .headers = {"stdlib.h"}},
    {.name = "realloc",
     .module = "libc.so.6",
     .api_category = api_info::category::HEAP_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY) |
              static_cast<uint32_t>(api_info::behavior_flags::FREES_MEMORY),
     .convention = LINUX_API_CONVENTION,
     .parameters =
         {{.name = "ptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "new_ptr", .param_type = param_info::type::POINTER},
     .description = "resize allocated memory",
     .headers = {"stdlib.h"}},

    // file I/O
    {.name = "open",
     .module = "libc.so.6",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
              static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = LINUX_API_CONVENTION,
     .parameters =
         {{.name = "path", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN},
          {.name = "flags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
          {.name = "mode",
           .param_type = param_info::type::FLAGS,
           .param_direction = param_info::direction::IN,
           .is_optional = true}},
     .return_value = {.name = "fd", .param_type = param_info::type::FILE_DESCRIPTOR},
     .description = "open file",
     .cleanup_api = "close",
     .headers = {"fcntl.h"}},
    {.name = "close",
     .module = "libc.so.6",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::CLOSES_HANDLE),
     .convention = LINUX_API_CONVENTION,
     .parameters =
         {{.name = "fd",
           .param_type = param_info::type::FILE_DESCRIPTOR,
           .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "close file descriptor",
     .headers = {"unistd.h"}},
    {.name = "read",
     .module = "libc.so.6",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
              static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
     .convention = LINUX_API_CONVENTION,
     .parameters =
         {{.name = "fd", .param_type = param_info::type::FILE_DESCRIPTOR, .param_direction = param_info::direction::IN},
          {.name = "buf",
           .param_type = param_info::type::BUFFER,
           .param_direction = param_info::direction::OUT,
           .size_param_index = 2},
          {.name = "count", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "bytes_read", .param_type = param_info::type::SIZE},
     .description = "read from file descriptor",
     .headers = {"unistd.h"}},
    {.name = "write",
     .module = "libc.so.6",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
              static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
     .convention = LINUX_API_CONVENTION,
     .parameters =
         {{.name = "fd", .param_type = param_info::type::FILE_DESCRIPTOR, .param_direction = param_info::direction::IN},
          {.name = "buf",
           .param_type = param_info::type::BUFFER,
           .param_direction = param_info::direction::IN,
           .size_param_index = 2},
          {.name = "count", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "bytes_written", .param_type = param_info::type::SIZE},
     .description = "write to file descriptor",
     .headers = {"unistd.h"}},

    // memory management
    {.name = "mmap",
     .module = "libc.so.6",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY) |
              static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = LINUX_API_CONVENTION,
     .parameters =
         {{.name = "addr",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN,
           .is_optional = true},
          {.name = "length", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
          {.name = "prot", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
          {.name = "flags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
          {.name = "fd", .param_type = param_info::type::FILE_DESCRIPTOR, .param_direction = param_info::direction::IN},
          {.name = "offset", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "addr", .param_type = param_info::type::POINTER},
     .description = "map files or devices into memory",
     .cleanup_api = "munmap",
     .headers = {"sys/mman.h"}},
    {.name = "munmap",
     .module = "libc.so.6",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FREES_MEMORY),
     .convention = LINUX_API_CONVENTION,
     .parameters =
         {{.name = "addr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "length", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "unmap memory region",
     .headers = {"sys/mman.h"}},

    // pthread APIs
    {.name = "pthread_create",
     .module = "libpthread.so.0",
     .api_category = api_info::category::THREADING,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = LINUX_API_CONVENTION,
     .parameters =
         {{.name = "thread", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "attr",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN,
           .is_optional = true},
          {.name = "start_routine",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN},
          {.name = "arg", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "create new thread",
     .headers = {"pthread.h"}},

    // network APIs
    {.name = "socket",
     .module = "libc.so.6",
     .api_category = api_info::category::NETWORK_SOCKET,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
              static_cast<uint32_t>(api_info::behavior_flags::NETWORK_IO),
     .convention = LINUX_API_CONVENTION,
     .parameters =
         {{.name = "domain", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
          {.name = "type", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
          {.name = "protocol", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "sockfd", .param_type = param_info::type::FILE_DESCRIPTOR},
     .description = "create network socket",
     .cleanup_api = "close",
     .headers = {"sys/socket.h"}}
};

} // namespace w1::abi::apis::linux
```

`src/w1tn3ss/abi/apis/macos/libcxx_apis.hpp`:

```hpp
#pragma once

#include "abi/api_knowledge_db.hpp"
#include <vector>

namespace w1::abi::apis::macos {

// determine macOS calling convention based on architecture
#if defined(__x86_64__)
#define MACOS_API_CONVENTION calling_convention_id::X86_64_SYSTEM_V
#elif defined(__aarch64__)
#define MACOS_API_CONVENTION calling_convention_id::AARCH64_AAPCS
#elif defined(__arm__)
#define MACOS_API_CONVENTION calling_convention_id::ARM32_AAPCS
#elif defined(__i386__)
#define MACOS_API_CONVENTION calling_convention_id::X86_CDECL
#else
#warning "Unknown macOS architecture, using UNKNOWN calling convention"
#define MACOS_API_CONVENTION calling_convention_id::UNKNOWN
#endif

/**
 * @brief libc++abi.dylib and libc++.1.dylib api definitions
 *
 * covers c++ runtime and standard library apis:
 * - exception handling (__cxa_throw, __cxa_begin_catch, etc.)
 * - memory management (operator new/delete variants)
 * - rtti support (__dynamic_cast, __cxa_demangle)
 * - guard variables for static initialization
 * - personality functions for stack unwinding
 * - standard library exception functions
 */

static const std::vector<api_info> macos_libcxx_apis = {
    // ===== EXCEPTION HANDLING APIs =====
    {.name = "___cxa_throw",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MISC,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "thrown_object",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN},
          {.name = "tinfo", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "dest", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "throw c++ exception",
     .headers = {"cxxabi.h"}},

    {.name = "___cxa_begin_catch",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MISC,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "exc_obj", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "object", .param_type = param_info::type::POINTER},
     .description = "begin exception catch block",
     .headers = {"cxxabi.h"}},

    {.name = "___cxa_end_catch",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MISC,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "end exception catch block",
     .headers = {"cxxabi.h"}},

    {.name = "___cxa_rethrow",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MISC,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "rethrow current exception",
     .headers = {"cxxabi.h"}},

    {.name = "___cxa_allocate_exception",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MISC,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "thrown_size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "exception_ptr", .param_type = param_info::type::POINTER},
     .description = "allocate memory for exception object",
     .headers = {"cxxabi.h"}},

    {.name = "___cxa_free_exception",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MISC,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "thrown_object",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "free exception memory",
     .headers = {"cxxabi.h"}},

    {.name = "___cxa_current_exception_type",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MISC,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "type_info", .param_type = param_info::type::POINTER},
     .description = "get current exception type info",
     .headers = {"cxxabi.h"}},

    {.name = "___cxa_bad_cast",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MISC,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "throw bad_cast exception",
     .headers = {"cxxabi.h"}},

    {.name = "___cxa_bad_typeid",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MISC,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "throw bad_typeid exception",
     .headers = {"cxxabi.h"}},

    {.name = "___cxa_throw_bad_array_new_length",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MISC,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "throw bad_array_new_length exception",
     .headers = {"cxxabi.h"}},

    {.name = "___cxa_pure_virtual",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MISC,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "pure virtual function called",
     .headers = {"cxxabi.h"}},

    {.name = "___cxa_deleted_virtual",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MISC,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "deleted virtual function called",
     .headers = {"cxxabi.h"}},

    // ===== STATIC INITIALIZATION GUARDS =====
    {.name = "___cxa_guard_acquire",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "guard_object",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "acquired", .param_type = param_info::type::INTEGER},
     .description = "acquire guard for static initialization",
     .headers = {"cxxabi.h"}},

    {.name = "___cxa_guard_release",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "guard_object",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "release guard after static initialization",
     .headers = {"cxxabi.h"}},

    {.name = "___cxa_guard_abort",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "guard_object",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "abort static initialization",
     .headers = {"cxxabi.h"}},

    // ===== RTTI AND TYPE SUPPORT =====
    {.name = "___dynamic_cast",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "src_ptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "src_type", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "dst_type", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "src2dst_offset",
           .param_type = param_info::type::INTEGER,
           .param_direction = param_info::direction::IN}},
     .return_value = {.name = "casted_ptr", .param_type = param_info::type::POINTER},
     .description = "perform dynamic_cast operation",
     .headers = {"cxxabi.h"}},

    {.name = "___cxa_demangle",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "mangled_name",
           .param_type = param_info::type::STRING,
           .param_direction = param_info::direction::IN},
          {.name = "output_buffer",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN_OUT},
          {.name = "length", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT},
          {.name = "status", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT}},
     .return_value = {.name = "demangled", .param_type = param_info::type::POINTER},
     .description = "demangle c++ symbol name",
     .headers = {"cxxabi.h"}},

    // ===== PERSONALITY AND UNWINDING =====
    {.name = "___gxx_personality_v0",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MISC,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "version", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "actions", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "exception_class",
           .param_type = param_info::type::INTEGER,
           .param_direction = param_info::direction::IN},
          {.name = "exception_object",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN},
          {.name = "context", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "c++ exception personality function",
     .headers = {"unwind.h"}},

    // ===== MEMORY MANAGEMENT - OPERATOR NEW =====
    {.name = "__Znwm",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "ptr", .param_type = param_info::type::POINTER},
     .description = "operator new(size_t)",
     .headers = {"new"}},

    {.name = "__Znam",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "ptr", .param_type = param_info::type::POINTER},
     .description = "operator new[](size_t)",
     .headers = {"new"}},

    {.name = "__ZnwmRKSt9nothrow_t",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
          {.name = "nothrow", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "ptr", .param_type = param_info::type::POINTER},
     .description = "operator new(size_t, nothrow)",
     .headers = {"new"}},

    {.name = "__ZnamRKSt9nothrow_t",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
          {.name = "nothrow", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "ptr", .param_type = param_info::type::POINTER},
     .description = "operator new[](size_t, nothrow)",
     .headers = {"new"}},

    {.name = "__ZnwmSt11align_val_t",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
          {.name = "alignment", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "ptr", .param_type = param_info::type::POINTER},
     .description = "operator new(size_t, align_val_t)",
     .headers = {"new"}},

    {.name = "__ZnamSt11align_val_t",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
          {.name = "alignment", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "ptr", .param_type = param_info::type::POINTER},
     .description = "operator new[](size_t, align_val_t)",
     .headers = {"new"}},

    // ===== MEMORY MANAGEMENT - OPERATOR DELETE =====
    {.name = "__ZdlPv",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "ptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "operator delete(void*)",
     .headers = {"new"}},

    {.name = "__ZdaPv",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "ptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "operator delete[](void*)",
     .headers = {"new"}},

    {.name = "__ZdlPvm",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "ptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "operator delete(void*, size_t)",
     .headers = {"new"}},

    {.name = "__ZdaPvm",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "ptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "operator delete[](void*, size_t)",
     .headers = {"new"}},

    {.name = "__ZdlPvRKSt9nothrow_t",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "ptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "nothrow", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "operator delete(void*, nothrow)",
     .headers = {"new"}},

    {.name = "__ZdaPvRKSt9nothrow_t",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "ptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "nothrow", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "operator delete[](void*, nothrow)",
     .headers = {"new"}},

    {.name = "__ZdlPvSt11align_val_t",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "ptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "alignment", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "operator delete(void*, align_val_t)",
     .headers = {"new"}},

    {.name = "__ZdaPvSt11align_val_t",
     .module = "libc++abi.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "ptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "alignment", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "operator delete[](void*, align_val_t)",
     .headers = {"new"}},

    // ===== STANDARD LIBRARY EXCEPTION FUNCTIONS =====
    {.name = "__ZSt17__throw_bad_allocv",
     .module = "libc++.1.dylib",
     .api_category = api_info::category::MISC,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "throw std::bad_alloc",
     .headers = {"new"}},

    {.name = "__ZSt9terminatev",
     .module = "libc++.1.dylib",
     .api_category = api_info::category::MISC,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "std::terminate()",
     .headers = {"exception"}},

    {.name = "__ZSt14set_terminatePFvvE",
     .module = "libc++.1.dylib",
     .api_category = api_info::category::MISC,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "handler", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "old_handler", .param_type = param_info::type::POINTER},
     .description = "std::set_terminate(handler)",
     .headers = {"exception"}},

    {.name = "__ZSt13get_terminatev",
     .module = "libc++.1.dylib",
     .api_category = api_info::category::MISC,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "handler", .param_type = param_info::type::POINTER},
     .description = "std::get_terminate()",
     .headers = {"exception"}},

    {.name = "__ZSt10unexpectedv",
     .module = "libc++.1.dylib",
     .api_category = api_info::category::MISC,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "std::unexpected()",
     .headers = {"exception"}},

    {.name = "__ZSt14set_unexpectedPFvvE",
     .module = "libc++.1.dylib",
     .api_category = api_info::category::MISC,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "handler", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "old_handler", .param_type = param_info::type::POINTER},
     .description = "std::set_unexpected(handler)",
     .headers = {"exception"}},

    {.name = "__ZSt13get_unexpectedv",
     .module = "libc++.1.dylib",
     .api_category = api_info::category::MISC,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "handler", .param_type = param_info::type::POINTER},
     .description = "std::get_unexpected()",
     .headers = {"exception"}},

    {.name = "__ZSt18uncaught_exceptionv",
     .module = "libc++.1.dylib",
     .api_category = api_info::category::MISC,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "uncaught", .param_type = param_info::type::BOOLEAN},
     .description = "std::uncaught_exception()",
     .headers = {"exception"}},

    {.name = "__ZSt19uncaught_exceptionsv",
     .module = "libc++.1.dylib",
     .api_category = api_info::category::MISC,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "count", .param_type = param_info::type::INTEGER},
     .description = "std::uncaught_exceptions()",
     .headers = {"exception"}},

    {.name = "__ZSt17current_exceptionv",
     .module = "libc++.1.dylib",
     .api_category = api_info::category::MISC,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "exception_ptr", .param_type = param_info::type::POINTER},
     .description = "std::current_exception()",
     .headers = {"exception"}},

    {.name = "__ZSt17rethrow_exceptionSt13exception_ptr",
     .module = "libc++.1.dylib",
     .api_category = api_info::category::MISC,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "ptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "std::rethrow_exception(exception_ptr)",
     .headers = {"exception"}},

    // ===== MEMORY HANDLER FUNCTIONS =====
    {.name = "__ZSt15get_new_handlerv",
     .module = "libc++.1.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "handler", .param_type = param_info::type::POINTER},
     .description = "std::get_new_handler()",
     .headers = {"new"}},

    {.name = "__ZSt15set_new_handlerPFvvE",
     .module = "libc++.1.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "handler", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "old_handler", .param_type = param_info::type::POINTER},
     .description = "std::set_new_handler(handler)",
     .headers = {"new"}},
};

} // namespace w1::abi::apis::macos
```

`src/w1tn3ss/abi/apis/macos/libdyld_apis.hpp`:

```hpp
#pragma once

#include "abi/api_knowledge_db.hpp"
#include <vector>

namespace w1::abi::apis::macos {

// determine macOS calling convention based on architecture
#if defined(__x86_64__)
#define MACOS_API_CONVENTION calling_convention_id::X86_64_SYSTEM_V
#elif defined(__aarch64__)
#define MACOS_API_CONVENTION calling_convention_id::AARCH64_AAPCS
#elif defined(__arm__)
#define MACOS_API_CONVENTION calling_convention_id::ARM32_AAPCS
#elif defined(__i386__)
#define MACOS_API_CONVENTION calling_convention_id::X86_CDECL
#else
#warning "Unknown macOS architecture, using UNKNOWN calling convention"
#define MACOS_API_CONVENTION calling_convention_id::UNKNOWN
#endif

/**
 * @brief libdyld.dylib api definitions
 *
 * covers dynamic library loading apis:
 * - library loading/unloading (dlopen, dlclose)
 * - symbol resolution (dlsym, dladdr)
 * - error handling (dlerror)
 */

static const std::vector<api_info> macos_libdyld_apis = {
    // ===== DYNAMIC LOADING APIs =====
    {.name = "_dlopen",
     .module = "libdyld.dylib",
     .api_category = api_info::category::LIBRARY_LOADING,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
              static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "filename", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN},
          {.name = "flags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "handle", .param_type = param_info::type::HANDLE},
     .description = "open dynamic library",
     .cleanup_api = "_dlclose",
     .headers = {"dlfcn.h"}},
    {.name = "_dlclose",
     .module = "libdyld.dylib",
     .api_category = api_info::category::LIBRARY_LOADING,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::CLOSES_HANDLE) |
              static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "handle", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "close dynamic library",
     .headers = {"dlfcn.h"}},
    {.name = "_dlsym",
     .module = "libdyld.dylib",
     .api_category = api_info::category::LIBRARY_LOADING,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "handle", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
          {.name = "symbol", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "address", .param_type = param_info::type::POINTER},
     .description = "get symbol from library",
     .headers = {"dlfcn.h"}},
    {.name = "_dladdr",
     .module = "libdyld.dylib",
     .api_category = api_info::category::LIBRARY_LOADING,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "addr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "info", .param_type = param_info::type::STRUCT, .param_direction = param_info::direction::OUT}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "get info about address",
     .headers = {"dlfcn.h"}},
    {.name = "_dlerror",
     .module = "libdyld.dylib",
     .api_category = api_info::category::LIBRARY_LOADING,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "error_msg", .param_type = param_info::type::STRING},
     .description = "get last dl error message",
     .headers = {"dlfcn.h"}},
    {.name = "_dlopen_preflight",
     .module = "libdyld.dylib",
     .api_category = api_info::category::LIBRARY_LOADING,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "path", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::BOOLEAN},
     .description = "check if library can be loaded",
     .headers = {"dlfcn.h"}},
    {.name = "_dlopen_from",
     .module = "libdyld.dylib",
     .api_category = api_info::category::LIBRARY_LOADING,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
              static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "path", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN},
          {.name = "mode", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
          {.name = "addressInImageWhereSymbolIsBeingLookedUp",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN}},
     .return_value = {.name = "handle", .param_type = param_info::type::HANDLE},
     .description = "open library from specific context",
     .cleanup_api = "_dlclose",
     .headers = {"dlfcn.h"}},
    {.name = "_dlopen_audited",
     .module = "libdyld.dylib",
     .api_category = api_info::category::LIBRARY_LOADING,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
              static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "filename", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN},
          {.name = "flags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "handle", .param_type = param_info::type::HANDLE},
     .description = "open library with auditing",
     .cleanup_api = "_dlclose",
     .headers = {"dlfcn.h"}}
};

} // namespace w1::abi::apis::macos
```

`src/w1tn3ss/abi/apis/macos/libsystem_c_apis.hpp`:

```hpp
#pragma once

#include "abi/api_knowledge_db.hpp"
#include <vector>

namespace w1::abi::apis::macos {

// determine macOS calling convention based on architecture
#if defined(__x86_64__)
#define MACOS_API_CONVENTION calling_convention_id::X86_64_SYSTEM_V
#elif defined(__aarch64__)
#define MACOS_API_CONVENTION calling_convention_id::AARCH64_AAPCS
#elif defined(__arm__)
#define MACOS_API_CONVENTION calling_convention_id::ARM32_AAPCS
#elif defined(__i386__)
#define MACOS_API_CONVENTION calling_convention_id::X86_CDECL
#else
#warning "Unknown macOS architecture, using UNKNOWN calling convention"
#define MACOS_API_CONVENTION calling_convention_id::UNKNOWN
#endif

/**
 * @brief libsystem_c.dylib api definitions
 *
 * covers standard c library apis:
 * - stdio functions (printf family, file operations)
 * - string manipulation functions
 * - stdlib functions (conversion, utilities)
 * - environment variables
 * - time functions
 * - directory operations
 */

static const std::vector<api_info> macos_libsystem_c_apis = {
    // ===== STDIO APIs =====
    {.name = "_puts",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STDIO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "write string to stdout",
     .headers = {"stdio.h"}},
    {.name = "_printf",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STDIO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {
             {.name = "format", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}
             // note: variadic args not handled yet
         },
     .return_value = {.name = "chars_written", .param_type = param_info::type::INTEGER},
     .description = "formatted output to stdout",
     .headers = {"stdio.h"}},
    {.name = "_fprintf",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STDIO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "stream", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "format", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "chars_written", .param_type = param_info::type::INTEGER},
     .description = "formatted output to stream",
     .headers = {"stdio.h"}},
    {.name = "_sprintf",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STDIO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "str", .param_type = param_info::type::STRING, .param_direction = param_info::direction::OUT},
          {.name = "format", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "chars_written", .param_type = param_info::type::INTEGER},
     .description = "formatted output to string",
     .security_notes = {"buffer overflow risk", "use snprintf instead"},
     .headers = {"stdio.h"}},
    {.name = "_snprintf",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STDIO,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "str", .param_type = param_info::type::STRING, .param_direction = param_info::direction::OUT},
          {.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
          {.name = "format", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "chars_written", .param_type = param_info::type::INTEGER},
     .description = "formatted output to string with size limit",
     .headers = {"stdio.h"}},
    {.name = "_vprintf",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STDIO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "format", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "ap", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "chars_written", .param_type = param_info::type::INTEGER},
     .description = "formatted output using va_list",
     .headers = {"stdio.h"}},
    {.name = "_vsprintf",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STDIO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "str", .param_type = param_info::type::STRING, .param_direction = param_info::direction::OUT},
          {.name = "format", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "ap", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "chars_written", .param_type = param_info::type::INTEGER},
     .description = "formatted output to string using va_list",
     .security_notes = {"buffer overflow risk", "use vsnprintf instead"},
     .headers = {"stdio.h"}},
    {.name = "_vsnprintf",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STDIO,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "str", .param_type = param_info::type::STRING, .param_direction = param_info::direction::OUT},
          {.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
          {.name = "format", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "ap", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "chars_written", .param_type = param_info::type::INTEGER},
     .description = "formatted output to string with size limit using va_list",
     .headers = {"stdio.h"}},

    // file operations
    {.name = "_fopen",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
              static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "path", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN},
          {.name = "mode", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "stream", .param_type = param_info::type::POINTER},
     .description = "open file stream",
     .cleanup_api = "_fclose",
     .headers = {"stdio.h"}},
    {.name = "_fclose",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
              static_cast<uint32_t>(api_info::behavior_flags::CLOSES_HANDLE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "stream", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "close file stream",
     .headers = {"stdio.h"}},
    {.name = "_fread",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
              static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "ptr", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::OUT},
          {.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
          {.name = "nmemb", .param_type = param_info::type::COUNT, .param_direction = param_info::direction::IN},
          {.name = "stream", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "items_read", .param_type = param_info::type::COUNT},
     .description = "read from file stream",
     .headers = {"stdio.h"}},
    {.name = "_fwrite",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
              static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "ptr", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::IN},
          {.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
          {.name = "nmemb", .param_type = param_info::type::COUNT, .param_direction = param_info::direction::IN},
          {.name = "stream", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "items_written", .param_type = param_info::type::COUNT},
     .description = "write to file stream",
     .headers = {"stdio.h"}},
    {.name = "_fseek",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "stream", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "offset", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "whence", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "seek in file stream",
     .headers = {"stdio.h"}},
    {.name = "_ftell",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "stream", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "position", .param_type = param_info::type::INTEGER},
     .description = "get file stream position",
     .headers = {"stdio.h"}},
    {.name = "_fflush",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
              static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "stream", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "flush file stream",
     .headers = {"stdio.h"}},
    {.name = "_feof",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "stream", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "eof", .param_type = param_info::type::BOOLEAN},
     .description = "test end-of-file indicator",
     .headers = {"stdio.h"}},
    {.name = "_ferror",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "stream", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::BOOLEAN},
     .description = "test error indicator",
     .headers = {"stdio.h"}},
    {.name = "_rewind",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "stream", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "rewind file stream to beginning",
     .headers = {"stdio.h"}},

    // input functions
    {.name = "_scanf",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STDIO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "format", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "items_assigned", .param_type = param_info::type::INTEGER},
     .description = "formatted input from stdin",
     .headers = {"stdio.h"}},
    {.name = "_sscanf",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STDIO,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "str", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "format", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "items_assigned", .param_type = param_info::type::INTEGER},
     .description = "formatted input from string",
     .headers = {"stdio.h"}},
    {.name = "_fscanf",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STDIO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "stream", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "format", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "items_assigned", .param_type = param_info::type::INTEGER},
     .description = "formatted input from stream",
     .headers = {"stdio.h"}},

    // character i/o
    {.name = "_fgetc",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STDIO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "stream", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "character", .param_type = param_info::type::INTEGER},
     .description = "get character from stream",
     .headers = {"stdio.h"}},
    {.name = "_fputc",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STDIO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "c", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "stream", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "character", .param_type = param_info::type::INTEGER},
     .description = "write character to stream",
     .headers = {"stdio.h"}},
    {.name = "_fgets",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STDIO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s", .param_type = param_info::type::STRING, .param_direction = param_info::direction::OUT},
          {.name = "size", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "stream", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "string", .param_type = param_info::type::STRING},
     .description = "get string from stream",
     .headers = {"stdio.h"}},
    {.name = "_fputs",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STDIO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "stream", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "write string to stream",
     .headers = {"stdio.h"}},
    {.name = "_getc",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STDIO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "stream", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "character", .param_type = param_info::type::INTEGER},
     .description = "get character from stream (macro version)",
     .headers = {"stdio.h"}},
    {.name = "_putc",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STDIO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "c", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "stream", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "character", .param_type = param_info::type::INTEGER},
     .description = "write character to stream (macro version)",
     .headers = {"stdio.h"}},
    {.name = "_getchar",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STDIO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "character", .param_type = param_info::type::INTEGER},
     .description = "get character from stdin",
     .headers = {"stdio.h"}},
    {.name = "_putchar",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STDIO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "c", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "character", .param_type = param_info::type::INTEGER},
     .description = "write character to stdout",
     .headers = {"stdio.h"}},

    // error handling
    {.name = "_perror",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STDIO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "print error message",
     .headers = {"stdio.h"}},

    // file management
    {.name = "_remove",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::FILE_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
              static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "path", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "remove file",
     .headers = {"stdio.h"}},
    {.name = "_rename",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::FILE_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
              static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "old", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN},
          {.name = "new", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "rename file",
     .headers = {"stdio.h"}},
    {.name = "_tmpfile",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
              static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "stream", .param_type = param_info::type::POINTER},
     .description = "create temporary file",
     .cleanup_api = "_fclose",
     .headers = {"stdio.h"}},
    {.name = "_tmpnam",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s", .param_type = param_info::type::STRING, .param_direction = param_info::direction::OUT}},
     .return_value = {.name = "filename", .param_type = param_info::type::STRING},
     .description = "generate temporary filename",
     .security_notes = {"race condition risk", "use mkstemp instead"},
     .headers = {"stdio.h"}},

    // ===== STRING MANIPULATION APIs =====
    {.name = "_strcpy",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "dest", .param_type = param_info::type::STRING, .param_direction = param_info::direction::OUT},
          {.name = "src", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "dest", .param_type = param_info::type::STRING},
     .description = "copy string (unsafe - no bounds check)",
     .security_notes = {"buffer overflow risk", "use strncpy or strlcpy instead"},
     .headers = {"string.h"}},
    {.name = "_strncpy",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "dest", .param_type = param_info::type::STRING, .param_direction = param_info::direction::OUT},
          {.name = "src", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "n", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "dest", .param_type = param_info::type::STRING},
     .description = "copy string with length limit",
     .headers = {"string.h"}},
    {.name = "_strcat",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "dest", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN_OUT},
          {.name = "src", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "dest", .param_type = param_info::type::STRING},
     .description = "concatenate strings (unsafe - no bounds check)",
     .security_notes = {"buffer overflow risk", "use strncat or strlcat instead"},
     .headers = {"string.h"}},
    {.name = "_strncat",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "dest", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN_OUT},
          {.name = "src", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "n", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "dest", .param_type = param_info::type::STRING},
     .description = "concatenate strings with length limit",
     .headers = {"string.h"}},
    {.name = "_strlen",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "length", .param_type = param_info::type::SIZE},
     .description = "get string length",
     .headers = {"string.h"}},
    {.name = "_strcmp",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s1", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "s2", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "compare strings",
     .headers = {"string.h"}},
    {.name = "_strncmp",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s1", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "s2", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "n", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "compare strings with length limit",
     .headers = {"string.h"}},
    {.name = "_strchr",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "c", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "ptr", .param_type = param_info::type::POINTER},
     .description = "find character in string",
     .headers = {"string.h"}},
    {.name = "_strrchr",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "c", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "ptr", .param_type = param_info::type::POINTER},
     .description = "find last occurrence of character",
     .headers = {"string.h"}},
    {.name = "_strstr",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "haystack", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "needle", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "ptr", .param_type = param_info::type::POINTER},
     .description = "find substring",
     .headers = {"string.h"}},
    {.name = "_strdup",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "duplicate", .param_type = param_info::type::STRING},
     .description = "duplicate string by allocating memory",
     .cleanup_api = "_free",
     .headers = {"string.h"}},
    {.name = "_strndup",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "n", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "duplicate", .param_type = param_info::type::STRING},
     .description = "duplicate string with length limit",
     .cleanup_api = "_free",
     .headers = {"string.h"}},
    {.name = "_strtok",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "str", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN_OUT},
          {.name = "delim", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "token", .param_type = param_info::type::STRING},
     .description = "extract tokens from string",
     .headers = {"string.h"}},
    {.name = "_strpbrk",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "accept", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "ptr", .param_type = param_info::type::POINTER},
     .description = "find first occurrence of any character in set",
     .headers = {"string.h"}},
    {.name = "_strspn",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "accept", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "length", .param_type = param_info::type::SIZE},
     .description = "get length of prefix substring",
     .headers = {"string.h"}},
    {.name = "_strcspn",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "reject", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "length", .param_type = param_info::type::SIZE},
     .description = "get length of complementary substring",
     .headers = {"string.h"}},
    {.name = "_strerror",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "errnum", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "message", .param_type = param_info::type::STRING},
     .description = "get error message string",
     .headers = {"string.h"}},
    {.name = "_strcasecmp",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s1", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "s2", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "case-insensitive string comparison",
     .headers = {"strings.h"}},
    {.name = "_strncasecmp",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s1", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "s2", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "n", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "case-insensitive string comparison with length limit",
     .headers = {"strings.h"}},

    // memory functions
    {.name = "_memcpy",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "dest",
           .param_type = param_info::type::BUFFER,
           .param_direction = param_info::direction::OUT,
           .size_param_index = 2},
          {.name = "src",
           .param_type = param_info::type::BUFFER,
           .param_direction = param_info::direction::IN,
           .size_param_index = 2},
          {.name = "n", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "dest", .param_type = param_info::type::POINTER},
     .description = "copy memory block",
     .security_notes = {"buffer overflow risk if dest too small"},
     .headers = {"string.h"}},
    {.name = "_memset",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s",
           .param_type = param_info::type::BUFFER,
           .param_direction = param_info::direction::OUT,
           .size_param_index = 2},
          {.name = "c", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "n", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "s", .param_type = param_info::type::POINTER},
     .description = "fill memory with byte value",
     .headers = {"string.h"}},
    {.name = "_memcmp",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s1",
           .param_type = param_info::type::BUFFER,
           .param_direction = param_info::direction::IN,
           .size_param_index = 2},
          {.name = "s2",
           .param_type = param_info::type::BUFFER,
           .param_direction = param_info::direction::IN,
           .size_param_index = 2},
          {.name = "n", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "compare memory blocks",
     .headers = {"string.h"}},

    // ===== STDLIB CONVERSION APIs =====
    {.name = "_atoi",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "nptr", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "value", .param_type = param_info::type::INTEGER},
     .description = "convert string to integer",
     .headers = {"stdlib.h"}},
    {.name = "_atol",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "nptr", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "value", .param_type = param_info::type::INTEGER},
     .description = "convert string to long",
     .headers = {"stdlib.h"}},
    {.name = "_atof",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "nptr", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "value", .param_type = param_info::type::FLOATING_POINT},
     .description = "convert string to double",
     .headers = {"stdlib.h"}},
    {.name = "_strtol",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "nptr", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "endptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "base", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "value", .param_type = param_info::type::INTEGER},
     .description = "convert string to long with base",
     .headers = {"stdlib.h"}},
    {.name = "_strtoul",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "nptr", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "endptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "base", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "value", .param_type = param_info::type::INTEGER},
     .description = "convert string to unsigned long",
     .headers = {"stdlib.h"}},
    {.name = "_strtod",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "nptr", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "endptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT}},
     .return_value = {.name = "value", .param_type = param_info::type::FLOATING_POINT},
     .description = "convert string to double",
     .headers = {"stdlib.h"}},
    {.name = "_strtoll",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "nptr", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "endptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "base", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "value", .param_type = param_info::type::INTEGER},
     .description = "convert string to long long",
     .headers = {"stdlib.h"}},
    {.name = "_strtoull",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "nptr", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "endptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "base", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "value", .param_type = param_info::type::INTEGER},
     .description = "convert string to unsigned long long",
     .headers = {"stdlib.h"}},

    // ===== STDLIB UTILITY APIs =====
    {.name = "_rand",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::MATH,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "random", .param_type = param_info::type::INTEGER},
     .description = "generate pseudo-random number",
     .headers = {"stdlib.h"}},
    {.name = "_srand",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::MATH,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "seed", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "seed random number generator",
     .headers = {"stdlib.h"}},
    {.name = "_qsort",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::SORTING,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "base", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT},
          {.name = "nmemb", .param_type = param_info::type::COUNT, .param_direction = param_info::direction::IN},
          {.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
          {.name = "compar", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "sort array using quicksort",
     .headers = {"stdlib.h"}},
    {.name = "_bsearch",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::SORTING,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "key", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "base", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "nmemb", .param_type = param_info::type::COUNT, .param_direction = param_info::direction::IN},
          {.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
          {.name = "compar", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "found", .param_type = param_info::type::POINTER},
     .description = "binary search in sorted array",
     .headers = {"stdlib.h"}},
    {.name = "_abs",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "j", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "absolute", .param_type = param_info::type::INTEGER},
     .description = "compute absolute value",
     .headers = {"stdlib.h"}},
    {.name = "_labs",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "j", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "absolute", .param_type = param_info::type::INTEGER},
     .description = "compute absolute value of long",
     .headers = {"stdlib.h"}},
    {.name = "_div",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "numer", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "denom", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::STRUCT},
     .description = "compute quotient and remainder",
     .headers = {"stdlib.h"}},
    {.name = "_ldiv",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "numer", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "denom", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::STRUCT},
     .description = "compute quotient and remainder of long",
     .headers = {"stdlib.h"}},

    // ===== ENVIRONMENT APIs =====
    {.name = "_getenv",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::ENVIRONMENT,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "name", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "value", .param_type = param_info::type::STRING},
     .description = "get environment variable",
     .headers = {"stdlib.h"}},
    {.name = "_setenv",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::ENVIRONMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "name", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "value", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "overwrite", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "set environment variable",
     .headers = {"stdlib.h"}},
    {.name = "_unsetenv",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::ENVIRONMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "name", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "unset environment variable",
     .headers = {"stdlib.h"}},
    {.name = "_putenv",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::ENVIRONMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "string", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "change or add environment variable",
     .headers = {"stdlib.h"}},

    // ===== PROGRAM CONTROL APIs =====
    {.name = "_system",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::PROCESS_CONTROL,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE) |
              static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "command", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
     .description = "execute shell command",
     .security_notes = {"command injection risk", "avoid passing user input"},
     .headers = {"stdlib.h"}},
    {.name = "_abort",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::PROCESS_CONTROL,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "abnormal program termination",
     .headers = {"stdlib.h"}},
    {.name = "_atexit",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::PROCESS_CONTROL,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "func", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "register function to call at exit",
     .headers = {"stdlib.h"}},
    {.name = "_getopt",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::PROCESS_CONTROL,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "argc", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "argv", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "optstring", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "option", .param_type = param_info::type::INTEGER},
     .description = "parse command-line options",
     .headers = {"unistd.h"}},

    // ===== TIME/SLEEP APIs =====
    {.name = "_sleep",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::TIME,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "seconds", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "remaining", .param_type = param_info::type::INTEGER},
     .description = "sleep for specified seconds",
     .headers = {"unistd.h"}},
    {.name = "_usleep",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::TIME,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "usec", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "sleep for specified microseconds",
     .headers = {"unistd.h"}},
    {.name = "_nanosleep",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::TIME,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "req", .param_type = param_info::type::STRUCT, .param_direction = param_info::direction::IN},
          {.name = "rem",
           .param_type = param_info::type::STRUCT,
           .param_direction = param_info::direction::OUT,
           .is_optional = true}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "sleep for specified nanoseconds",
     .headers = {"time.h"}},
    {.name = "_time",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::TIME,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "tloc",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::OUT,
           .is_optional = true}},
     .return_value = {.name = "seconds", .param_type = param_info::type::INTEGER},
     .description = "get current time in seconds since epoch",
     .headers = {"time.h"}},

    // ===== DIRECTORY OPERATIONS =====
    {.name = "_getcwd",
     .module = "libsystem_c.dylib",
     .api_category = api_info::category::FILE_MANAGEMENT,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "buf", .param_type = param_info::type::STRING, .param_direction = param_info::direction::OUT},
          {.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "path", .param_type = param_info::type::STRING},
     .description = "get current working directory",
     .headers = {"unistd.h"}}
};

} // namespace w1::abi::apis::macos
```

`src/w1tn3ss/abi/apis/macos/libsystem_kernel_apis.hpp`:

```hpp
#pragma once

#include "abi/api_knowledge_db.hpp"
#include <vector>

namespace w1::abi::apis::macos {

// determine macOS calling convention based on architecture
#if defined(__x86_64__)
#define MACOS_API_CONVENTION calling_convention_id::X86_64_SYSTEM_V
#elif defined(__aarch64__)
#define MACOS_API_CONVENTION calling_convention_id::AARCH64_AAPCS
#elif defined(__arm__)
#define MACOS_API_CONVENTION calling_convention_id::ARM32_AAPCS
#elif defined(__i386__)
#define MACOS_API_CONVENTION calling_convention_id::X86_CDECL
#else
#warning "Unknown macOS architecture, using UNKNOWN calling convention"
#define MACOS_API_CONVENTION calling_convention_id::UNKNOWN
#endif

/**
 * @brief libsystem_kernel.dylib api definitions
 *
 * covers kernel system call apis:
 * - file i/o (open, close, read, write)
 * - process control (fork, exec, exit, wait)
 * - memory management (mmap, munmap, mprotect)
 * - network operations (socket, connect, bind)
 * - file system operations (stat, chmod, mkdir)
 * - device i/o (ioctl)
 * - synchronization (select, poll)
 */

static const std::vector<api_info> macos_libsystem_kernel_apis = {
    // ===== FILE I/O APIs =====
    {.name = "_open",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
              static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "path", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN},
          {.name = "flags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
          {.name = "mode",
           .param_type = param_info::type::FLAGS,
           .param_direction = param_info::direction::IN,
           .is_optional = true}},
     .return_value = {.name = "fd", .param_type = param_info::type::FILE_DESCRIPTOR},
     .description = "open file",
     .cleanup_api = "_close",
     .headers = {"fcntl.h"}},
    {.name = "_close",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::CLOSES_HANDLE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "fd",
           .param_type = param_info::type::FILE_DESCRIPTOR,
           .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "close file descriptor",
     .headers = {"unistd.h"}},
    {.name = "_read",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
              static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "fd", .param_type = param_info::type::FILE_DESCRIPTOR, .param_direction = param_info::direction::IN},
          {.name = "buf",
           .param_type = param_info::type::BUFFER,
           .param_direction = param_info::direction::OUT,
           .size_param_index = 2},
          {.name = "count", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "bytes_read", .param_type = param_info::type::SIZE},
     .description = "read from file descriptor",
     .headers = {"unistd.h"}},
    {.name = "_write",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
              static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "fd", .param_type = param_info::type::FILE_DESCRIPTOR, .param_direction = param_info::direction::IN},
          {.name = "buf",
           .param_type = param_info::type::BUFFER,
           .param_direction = param_info::direction::IN,
           .size_param_index = 2},
          {.name = "count", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "bytes_written", .param_type = param_info::type::SIZE},
     .description = "write to file descriptor",
     .headers = {"unistd.h"}},
    {.name = "_lseek",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "fd", .param_type = param_info::type::FILE_DESCRIPTOR, .param_direction = param_info::direction::IN},
          {.name = "offset", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "whence", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "position", .param_type = param_info::type::INTEGER},
     .description = "reposition file descriptor offset",
     .headers = {"unistd.h"}},
    {.name = "_dup",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "oldfd",
           .param_type = param_info::type::FILE_DESCRIPTOR,
           .param_direction = param_info::direction::IN}},
     .return_value = {.name = "newfd", .param_type = param_info::type::FILE_DESCRIPTOR},
     .description = "duplicate file descriptor",
     .cleanup_api = "_close",
     .headers = {"unistd.h"}},
    {.name = "_dup2",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
              static_cast<uint32_t>(api_info::behavior_flags::CLOSES_HANDLE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "oldfd",
           .param_type = param_info::type::FILE_DESCRIPTOR,
           .param_direction = param_info::direction::IN},
          {.name = "newfd",
           .param_type = param_info::type::FILE_DESCRIPTOR,
           .param_direction = param_info::direction::IN}},
     .return_value = {.name = "fd", .param_type = param_info::type::FILE_DESCRIPTOR},
     .description = "duplicate file descriptor to specific fd",
     .headers = {"unistd.h"}},
    {.name = "_pipe",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "pipefd", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "create pipe",
     .headers = {"unistd.h"}},
    {.name = "_fcntl",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::FILE_IO,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "fd", .param_type = param_info::type::FILE_DESCRIPTOR, .param_direction = param_info::direction::IN},
          {.name = "cmd", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "manipulate file descriptor",
     .headers = {"fcntl.h"}},
    {.name = "_ioctl",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::DEVICE_IO,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "fd", .param_type = param_info::type::FILE_DESCRIPTOR, .param_direction = param_info::direction::IN},
          {.name = "request", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "control device",
     .headers = {"sys/ioctl.h"}},
    {.name = "_select",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "nfds", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "readfds",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN_OUT},
          {.name = "writefds",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN_OUT},
          {.name = "exceptfds",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN_OUT},
          {.name = "timeout", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "ready", .param_type = param_info::type::INTEGER},
     .description = "synchronous i/o multiplexing",
     .headers = {"sys/select.h"}},
    {.name = "_poll",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::FILE_IO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "fds", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT},
          {.name = "nfds", .param_type = param_info::type::COUNT, .param_direction = param_info::direction::IN},
          {.name = "timeout", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "ready", .param_type = param_info::type::INTEGER},
     .description = "wait for events on file descriptors",
     .headers = {"poll.h"}},

    // ===== PROCESS CONTROL APIs =====
    {.name = "_fork",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::PROCESS_CONTROL,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "pid", .param_type = param_info::type::PROCESS_ID},
     .description = "create child process",
     .headers = {"unistd.h"}},
    {.name = "_execve",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::PROCESS_CONTROL,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "path", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN},
          {.name = "argv", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "envp", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "execute program",
     .headers = {"unistd.h"}},
    {.name = "_exit",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::PROCESS_CONTROL,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "status", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "terminate process",
     .headers = {"unistd.h"}},
    {.name = "_waitpid",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::PROCESS_CONTROL,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "pid", .param_type = param_info::type::PROCESS_ID, .param_direction = param_info::direction::IN},
          {.name = "status", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "options", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "pid", .param_type = param_info::type::PROCESS_ID},
     .description = "wait for process state changes",
     .headers = {"sys/wait.h"}},
    {.name = "_kill",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::PROCESS_CONTROL,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "pid", .param_type = param_info::type::PROCESS_ID, .param_direction = param_info::direction::IN},
          {.name = "sig", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "send signal to process",
     .headers = {"signal.h"}},
    {.name = "_getpid",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::PROCESS_CONTROL,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "pid", .param_type = param_info::type::PROCESS_ID},
     .description = "get process id",
     .headers = {"unistd.h"}},
    {.name = "_getppid",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::PROCESS_CONTROL,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "ppid", .param_type = param_info::type::PROCESS_ID},
     .description = "get parent process id",
     .headers = {"unistd.h"}},

    // ===== MEMORY MANAGEMENT APIs =====
    {.name = "_mmap",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY) |
              static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "addr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "length", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
          {.name = "prot", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
          {.name = "flags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
          {.name = "fd", .param_type = param_info::type::FILE_DESCRIPTOR, .param_direction = param_info::direction::IN},
          {.name = "offset", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "address", .param_type = param_info::type::POINTER},
     .description = "map memory",
     .cleanup_api = "_munmap",
     .headers = {"sys/mman.h"}},
    {.name = "_munmap",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FREES_MEMORY) |
              static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "addr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "length", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "unmap memory",
     .headers = {"sys/mman.h"}},
    {.name = "_mprotect",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "addr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "length", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
          {.name = "prot", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "set memory protection",
     .headers = {"sys/mman.h"}},

    // mach vm apis
    {.name = "_mach_vm_allocate",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY) |
              static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "target", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
          {.name = "address",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN_OUT},
          {.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
          {.name = "flags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "kern_return", .param_type = param_info::type::ERROR_CODE},
     .description = "allocate virtual memory",
     .cleanup_api = "_mach_vm_deallocate",
     .headers = {"mach/mach_vm.h"}},

    // ===== FILE SYSTEM APIs =====
    {.name = "_stat",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::FILE_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "path", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN},
          {.name = "statbuf", .param_type = param_info::type::STRUCT, .param_direction = param_info::direction::OUT}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "get file status",
     .headers = {"sys/stat.h"}},
    {.name = "_unlink",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::FILE_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
              static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "path", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "delete file",
     .headers = {"unistd.h"}},
    {.name = "_chmod",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::FILE_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
              static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "path", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN},
          {.name = "mode", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "change file permissions",
     .headers = {"sys/stat.h"}},
    {.name = "_access",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::FILE_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "path", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN},
          {.name = "mode", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "check file accessibility",
     .headers = {"unistd.h"}},
    {.name = "_mkdir",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::FILE_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
              static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "path", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN},
          {.name = "mode", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "create directory",
     .headers = {"sys/stat.h"}},
    {.name = "_rmdir",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::FILE_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
              static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "path", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "remove empty directory",
     .headers = {"unistd.h"}},
    {.name = "_chdir",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::FILE_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "path", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "change working directory",
     .headers = {"unistd.h"}},
    {.name = "_link",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::FILE_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
              static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "oldpath", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN},
          {.name = "newpath", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "create hard link",
     .headers = {"unistd.h"}},
    {.name = "_symlink",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::FILE_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
              static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "target", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN},
          {.name = "linkpath", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "create symbolic link",
     .headers = {"unistd.h"}},
    {.name = "_readlink",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::FILE_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "path", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN},
          {.name = "buf", .param_type = param_info::type::STRING, .param_direction = param_info::direction::OUT},
          {.name = "bufsiz", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "bytes", .param_type = param_info::type::SIZE},
     .description = "read value of symbolic link",
     .headers = {"unistd.h"}},
    {.name = "_umask",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::FILE_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "mask", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "oldmask", .param_type = param_info::type::FLAGS},
     .description = "set file mode creation mask",
     .headers = {"sys/stat.h"}},

    // ===== NETWORK APIs =====
    {.name = "_socket",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::NETWORK_SOCKET,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "domain", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "type", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "protocol", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "sockfd", .param_type = param_info::type::FILE_DESCRIPTOR},
     .description = "create socket",
     .cleanup_api = "_close",
     .headers = {"sys/socket.h"}},
    {.name = "_connect",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::NETWORK_SOCKET,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::NETWORK_IO) |
              static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "sockfd",
           .param_type = param_info::type::FILE_DESCRIPTOR,
           .param_direction = param_info::direction::IN},
          {.name = "addr", .param_type = param_info::type::STRUCT, .param_direction = param_info::direction::IN},
          {.name = "addrlen", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "connect socket",
     .headers = {"sys/socket.h"}},
    {.name = "_bind",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::NETWORK_SOCKET,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::NETWORK_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "sockfd",
           .param_type = param_info::type::FILE_DESCRIPTOR,
           .param_direction = param_info::direction::IN},
          {.name = "addr", .param_type = param_info::type::STRUCT, .param_direction = param_info::direction::IN},
          {.name = "addrlen", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "bind socket to address",
     .headers = {"sys/socket.h"}},
    {.name = "_listen",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::NETWORK_SOCKET,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::NETWORK_IO),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "sockfd",
           .param_type = param_info::type::FILE_DESCRIPTOR,
           .param_direction = param_info::direction::IN},
          {.name = "backlog", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "listen for connections on socket",
     .headers = {"sys/socket.h"}},
    {.name = "_accept",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::NETWORK_SOCKET,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::NETWORK_IO) |
              static_cast<uint32_t>(api_info::behavior_flags::BLOCKING) |
              static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "sockfd",
           .param_type = param_info::type::FILE_DESCRIPTOR,
           .param_direction = param_info::direction::IN},
          {.name = "addr", .param_type = param_info::type::STRUCT, .param_direction = param_info::direction::OUT},
          {.name = "addrlen",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "newsockfd", .param_type = param_info::type::FILE_DESCRIPTOR},
     .description = "accept connection on socket",
     .cleanup_api = "_close",
     .headers = {"sys/socket.h"}},
    {.name = "_send",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::NETWORK_SOCKET,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::NETWORK_IO) |
              static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "sockfd",
           .param_type = param_info::type::FILE_DESCRIPTOR,
           .param_direction = param_info::direction::IN},
          {.name = "buf",
           .param_type = param_info::type::BUFFER,
           .param_direction = param_info::direction::IN,
           .size_param_index = 2},
          {.name = "len", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
          {.name = "flags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "bytes_sent", .param_type = param_info::type::SIZE},
     .description = "send data on socket",
     .headers = {"sys/socket.h"}},
    {.name = "_recv",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::NETWORK_SOCKET,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::NETWORK_IO) |
              static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "sockfd",
           .param_type = param_info::type::FILE_DESCRIPTOR,
           .param_direction = param_info::direction::IN},
          {.name = "buf",
           .param_type = param_info::type::BUFFER,
           .param_direction = param_info::direction::OUT,
           .size_param_index = 2},
          {.name = "len", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
          {.name = "flags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "bytes_received", .param_type = param_info::type::SIZE},
     .description = "receive data from socket",
     .headers = {"sys/socket.h"}},

    // ===== SYSTEM INFO APIs =====
    {.name = "_getuid",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::SYSTEM_INFO,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "uid", .param_type = param_info::type::INTEGER},
     .description = "get user id",
     .headers = {"unistd.h"}},
    {.name = "_geteuid",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::SYSTEM_INFO,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "euid", .param_type = param_info::type::INTEGER},
     .description = "get effective user id",
     .headers = {"unistd.h"}},
    {.name = "_getgid",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::SYSTEM_INFO,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "gid", .param_type = param_info::type::INTEGER},
     .description = "get group id",
     .headers = {"unistd.h"}},
    {.name = "_getegid",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::SYSTEM_INFO,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "egid", .param_type = param_info::type::INTEGER},
     .description = "get effective group id",
     .headers = {"unistd.h"}},
    {.name = "_sysctl",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::SYSTEM_INFO,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "name", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "namelen", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "oldp", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "oldlenp",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN_OUT},
          {.name = "newp", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "newlen", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "get/set system information",
     .headers = {"sys/sysctl.h"}},
    {.name = "_gettimeofday",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::TIME,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "tv", .param_type = param_info::type::STRUCT, .param_direction = param_info::direction::OUT},
          {.name = "tz",
           .param_type = param_info::type::STRUCT,
           .param_direction = param_info::direction::OUT,
           .is_optional = true}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "get time of day",
     .headers = {"sys/time.h"}},
    {.name = "_gethostname",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::SYSTEM_INFO,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "name", .param_type = param_info::type::STRING, .param_direction = param_info::direction::OUT},
          {.name = "len", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "get hostname",
     .headers = {"unistd.h"}},
    {.name = "_sethostname",
     .module = "libsystem_kernel.dylib",
     .api_category = api_info::category::SYSTEM_INFO,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "name", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "len", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "set hostname",
     .headers = {"unistd.h"}}
};

} // namespace w1::abi::apis::macos
```

`src/w1tn3ss/abi/apis/macos/libsystem_m_apis.hpp`:

```hpp
#pragma once

#include "abi/api_knowledge_db.hpp"
#include <vector>

namespace w1::abi::apis::macos {

// determine macOS calling convention based on architecture
#if defined(__x86_64__)
#define MACOS_API_CONVENTION calling_convention_id::X86_64_SYSTEM_V
#elif defined(__aarch64__)
#define MACOS_API_CONVENTION calling_convention_id::AARCH64_AAPCS
#elif defined(__arm__)
#define MACOS_API_CONVENTION calling_convention_id::ARM32_AAPCS
#elif defined(__i386__)
#define MACOS_API_CONVENTION calling_convention_id::X86_CDECL
#else
#warning "Unknown macOS architecture, using UNKNOWN calling convention"
#define MACOS_API_CONVENTION calling_convention_id::UNKNOWN
#endif

/**
 * @brief libsystem_m.dylib api definitions
 *
 * covers mathematical functions:
 * - trigonometric functions (sin, cos, tan)
 * - exponential and logarithmic functions
 * - power and root functions
 * - rounding and absolute value functions
 * - floating point manipulation
 */

static const std::vector<api_info> macos_libsystem_m_apis = {
    // ===== TRIGONOMETRIC FUNCTIONS =====
    {.name = "_sin",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute sine",
     .headers = {"math.h"}},
    {.name = "_sinf",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {{.name = "x", .param_type = param_info::type::FLOAT, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::FLOAT},
     .description = "compute sine (float)",
     .headers = {"math.h"}},
    {.name = "_cos",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute cosine",
     .headers = {"math.h"}},
    {.name = "_cosf",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {{.name = "x", .param_type = param_info::type::FLOAT, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::FLOAT},
     .description = "compute cosine (float)",
     .headers = {"math.h"}},
    {.name = "_tan",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute tangent",
     .headers = {"math.h"}},
    {.name = "_tanf",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {{.name = "x", .param_type = param_info::type::FLOAT, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::FLOAT},
     .description = "compute tangent (float)",
     .headers = {"math.h"}},
    {.name = "_asin",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute arc sine",
     .headers = {"math.h"}},
    {.name = "_acos",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute arc cosine",
     .headers = {"math.h"}},
    {.name = "_atan",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute arc tangent",
     .headers = {"math.h"}},
    {.name = "_atan2",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "y", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN},
          {.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute arc tangent of y/x",
     .headers = {"math.h"}},

    // ===== HYPERBOLIC FUNCTIONS =====
    {.name = "_sinh",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute hyperbolic sine",
     .headers = {"math.h"}},
    {.name = "_cosh",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute hyperbolic cosine",
     .headers = {"math.h"}},
    {.name = "_tanh",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute hyperbolic tangent",
     .headers = {"math.h"}},

    // ===== EXPONENTIAL AND LOGARITHMIC FUNCTIONS =====
    {.name = "_exp",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute exponential function",
     .headers = {"math.h"}},
    {.name = "_expf",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {{.name = "x", .param_type = param_info::type::FLOAT, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::FLOAT},
     .description = "compute exponential function (float)",
     .headers = {"math.h"}},
    {.name = "_exp2",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute 2^x",
     .headers = {"math.h"}},
    {.name = "_expm1",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute e^x - 1",
     .headers = {"math.h"}},
    {.name = "_log",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute natural logarithm",
     .headers = {"math.h"}},
    {.name = "_logf",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {{.name = "x", .param_type = param_info::type::FLOAT, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::FLOAT},
     .description = "compute natural logarithm (float)",
     .headers = {"math.h"}},
    {.name = "_log10",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute base-10 logarithm",
     .headers = {"math.h"}},
    {.name = "_log2",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute base-2 logarithm",
     .headers = {"math.h"}},
    {.name = "_log1p",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute log(1 + x)",
     .headers = {"math.h"}},

    // ===== POWER AND ROOT FUNCTIONS =====
    {.name = "_pow",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN},
          {.name = "y", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute x raised to power y",
     .headers = {"math.h"}},
    {.name = "_powf",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::FLOAT, .param_direction = param_info::direction::IN},
          {.name = "y", .param_type = param_info::type::FLOAT, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::FLOAT},
     .description = "compute x raised to power y (float)",
     .headers = {"math.h"}},
    {.name = "_sqrt",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute square root",
     .headers = {"math.h"}},
    {.name = "_sqrtf",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {{.name = "x", .param_type = param_info::type::FLOAT, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::FLOAT},
     .description = "compute square root (float)",
     .headers = {"math.h"}},
    {.name = "_cbrt",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute cube root",
     .headers = {"math.h"}},
    {.name = "_hypot",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN},
          {.name = "y", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute euclidean distance",
     .headers = {"math.h"}},

    // ===== ROUNDING AND ABSOLUTE VALUE FUNCTIONS =====
    {.name = "_fabs",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute absolute value",
     .headers = {"math.h"}},
    {.name = "_fabsf",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {{.name = "x", .param_type = param_info::type::FLOAT, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::FLOAT},
     .description = "compute absolute value (float)",
     .headers = {"math.h"}},
    {.name = "_ceil",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "round up to nearest integer",
     .headers = {"math.h"}},
    {.name = "_ceilf",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {{.name = "x", .param_type = param_info::type::FLOAT, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::FLOAT},
     .description = "round up to nearest integer (float)",
     .headers = {"math.h"}},
    {.name = "_floor",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "round down to nearest integer",
     .headers = {"math.h"}},
    {.name = "_floorf",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {{.name = "x", .param_type = param_info::type::FLOAT, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::FLOAT},
     .description = "round down to nearest integer (float)",
     .headers = {"math.h"}},
    {.name = "_round",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "round to nearest integer",
     .headers = {"math.h"}},
    {.name = "_trunc",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "truncate to integer value",
     .headers = {"math.h"}},

    // ===== FLOATING POINT MANIPULATION =====
    {.name = "_fmod",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN},
          {.name = "y", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute floating-point remainder",
     .headers = {"math.h"}},
    {.name = "_remainder",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN},
          {.name = "y", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "compute remainder of x/y",
     .headers = {"math.h"}},
    {.name = "_copysign",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN},
          {.name = "y", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "copy sign of y to x",
     .headers = {"math.h"}},
    {.name = "_nan",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "tagp", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "return quiet NaN",
     .headers = {"math.h"}},
    {.name = "_isnan",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::BOOLEAN},
     .description = "check if value is NaN",
     .headers = {"math.h"}},
    {.name = "_isinf",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::BOOLEAN},
     .description = "check if value is infinite",
     .headers = {"math.h"}},
    {.name = "_isfinite",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::BOOLEAN},
     .description = "check if value is finite",
     .headers = {"math.h"}},

    // ===== MISC MATH FUNCTIONS =====
    {.name = "_fmax",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN},
          {.name = "y", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "determine maximum of two values",
     .headers = {"math.h"}},
    {.name = "_fmin",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN},
          {.name = "y", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "determine minimum of two values",
     .headers = {"math.h"}},
    {.name = "_fdim",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN},
          {.name = "y", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "positive difference",
     .headers = {"math.h"}},
    {.name = "_fma",
     .module = "libsystem_m.dylib",
     .api_category = api_info::category::MATH,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN},
          {.name = "y", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN},
          {.name = "z", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
     .description = "fused multiply-add",
     .headers = {"math.h"}}
};

} // namespace w1::abi::apis::macos
```

`src/w1tn3ss/abi/apis/macos/libsystem_malloc_apis.hpp`:

```hpp
#pragma once

#include "abi/api_knowledge_db.hpp"
#include <vector>

namespace w1::abi::apis::macos {

// determine macOS calling convention based on architecture
#if defined(__x86_64__)
#define MACOS_API_CONVENTION calling_convention_id::X86_64_SYSTEM_V
#elif defined(__aarch64__)
#define MACOS_API_CONVENTION calling_convention_id::AARCH64_AAPCS
#elif defined(__arm__)
#define MACOS_API_CONVENTION calling_convention_id::ARM32_AAPCS
#elif defined(__i386__)
#define MACOS_API_CONVENTION calling_convention_id::X86_CDECL
#else
#warning "Unknown macOS architecture, using UNKNOWN calling convention"
#define MACOS_API_CONVENTION calling_convention_id::UNKNOWN
#endif

/**
 * @brief libsystem_malloc.dylib api definitions
 *
 * covers heap management apis:
 * - memory allocation (malloc, calloc, realloc)
 * - memory deallocation (free)
 * - memory zone management
 */

static const std::vector<api_info> macos_libsystem_malloc_apis = {
    // ===== HEAP MANAGEMENT APIs =====
    {.name = "_malloc",
     .module = "libsystem_malloc.dylib",
     .api_category = api_info::category::HEAP_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "ptr", .param_type = param_info::type::POINTER},
     .description = "allocate memory",
     .cleanup_api = "_free",
     .headers = {"stdlib.h"}},
    {.name = "_free",
     .module = "libsystem_malloc.dylib",
     .api_category = api_info::category::HEAP_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FREES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "ptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "free allocated memory",
     .headers = {"stdlib.h"}},
    {.name = "_calloc",
     .module = "libsystem_malloc.dylib",
     .api_category = api_info::category::HEAP_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "nmemb", .param_type = param_info::type::COUNT, .param_direction = param_info::direction::IN},
          {.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "ptr", .param_type = param_info::type::POINTER},
     .description = "allocate and zero memory",
     .cleanup_api = "_free",
     .headers = {"stdlib.h"}},
    {.name = "_realloc",
     .module = "libsystem_malloc.dylib",
     .api_category = api_info::category::HEAP_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY) |
              static_cast<uint32_t>(api_info::behavior_flags::FREES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "ptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "new_ptr", .param_type = param_info::type::POINTER},
     .description = "resize allocated memory",
     .headers = {"stdlib.h"}},
    {.name = "_reallocf",
     .module = "libsystem_malloc.dylib",
     .api_category = api_info::category::HEAP_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY) |
              static_cast<uint32_t>(api_info::behavior_flags::FREES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "ptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "new_ptr", .param_type = param_info::type::POINTER},
     .description = "resize allocated memory (frees on failure)",
     .headers = {"stdlib.h"}},
    {.name = "_valloc",
     .module = "libsystem_malloc.dylib",
     .api_category = api_info::category::HEAP_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "ptr", .param_type = param_info::type::POINTER},
     .description = "allocate page-aligned memory",
     .cleanup_api = "_free",
     .headers = {"stdlib.h"}},
    {.name = "_posix_memalign",
     .module = "libsystem_malloc.dylib",
     .api_category = api_info::category::HEAP_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "memptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "alignment", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
          {.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "allocate aligned memory",
     .headers = {"stdlib.h"}},
    {.name = "_malloc_size",
     .module = "libsystem_malloc.dylib",
     .api_category = api_info::category::HEAP_MANAGEMENT,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "ptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "size", .param_type = param_info::type::SIZE},
     .description = "get size of allocated memory block",
     .headers = {"malloc/malloc.h"}},
    {.name = "_malloc_good_size",
     .module = "libsystem_malloc.dylib",
     .api_category = api_info::category::HEAP_MANAGEMENT,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "good_size", .param_type = param_info::type::SIZE},
     .description = "round up to efficient allocation size",
     .headers = {"malloc/malloc.h"}},

    // memory zone management
    {.name = "_malloc_zone_malloc",
     .module = "libsystem_malloc.dylib",
     .api_category = api_info::category::HEAP_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "zone", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "ptr", .param_type = param_info::type::POINTER},
     .description = "allocate memory from specific zone",
     .cleanup_api = "_malloc_zone_free",
     .headers = {"malloc/malloc.h"}},
    {.name = "_malloc_zone_free",
     .module = "libsystem_malloc.dylib",
     .api_category = api_info::category::HEAP_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FREES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "zone", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "ptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "free memory in specific zone",
     .headers = {"malloc/malloc.h"}},
    {.name = "_malloc_zone_calloc",
     .module = "libsystem_malloc.dylib",
     .api_category = api_info::category::HEAP_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "zone", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "num_items", .param_type = param_info::type::COUNT, .param_direction = param_info::direction::IN},
          {.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "ptr", .param_type = param_info::type::POINTER},
     .description = "allocate and zero memory from specific zone",
     .cleanup_api = "_malloc_zone_free",
     .headers = {"malloc/malloc.h"}},
    {.name = "_malloc_zone_realloc",
     .module = "libsystem_malloc.dylib",
     .api_category = api_info::category::HEAP_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY) |
              static_cast<uint32_t>(api_info::behavior_flags::FREES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "zone", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "ptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "new_ptr", .param_type = param_info::type::POINTER},
     .description = "resize memory in specific zone",
     .headers = {"malloc/malloc.h"}},
    {.name = "_malloc_default_zone",
     .module = "libsystem_malloc.dylib",
     .api_category = api_info::category::HEAP_MANAGEMENT,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "zone", .param_type = param_info::type::POINTER},
     .description = "get default malloc zone",
     .headers = {"malloc/malloc.h"}},
    {.name = "_malloc_create_zone",
     .module = "libsystem_malloc.dylib",
     .api_category = api_info::category::HEAP_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "start_size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
          {.name = "flags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "zone", .param_type = param_info::type::POINTER},
     .description = "create new malloc zone",
     .cleanup_api = "_malloc_destroy_zone",
     .headers = {"malloc/malloc.h"}},
    {.name = "_malloc_destroy_zone",
     .module = "libsystem_malloc.dylib",
     .api_category = api_info::category::HEAP_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::FREES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "zone", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "destroy malloc zone",
     .headers = {"malloc/malloc.h"}}
};

} // namespace w1::abi::apis::macos
```

`src/w1tn3ss/abi/apis/macos/libsystem_platform_apis.hpp`:

```hpp
#pragma once

#include "abi/api_knowledge_db.hpp"
#include <vector>

namespace w1::abi::apis::macos {

// determine macOS calling convention based on architecture
#if defined(__x86_64__)
#define MACOS_API_CONVENTION calling_convention_id::X86_64_SYSTEM_V
#elif defined(__aarch64__)
#define MACOS_API_CONVENTION calling_convention_id::AARCH64_AAPCS
#elif defined(__arm__)
#define MACOS_API_CONVENTION calling_convention_id::ARM32_AAPCS
#elif defined(__i386__)
#define MACOS_API_CONVENTION calling_convention_id::X86_CDECL
#else
#warning "Unknown macOS architecture, using UNKNOWN calling convention"
#define MACOS_API_CONVENTION calling_convention_id::UNKNOWN
#endif

/**
 * @brief libsystem_platform.dylib api definitions
 *
 * covers platform-optimized apis:
 * - optimized string functions (__platform_strlen, __platform_strcmp, etc.)
 * - optimized memory functions (__platform_memcpy, __platform_memmove, etc.)
 * - atomic operations (OSAtomicAdd32, OSAtomicCompareAndSwap64, etc.)
 * - synchronization primitives (os_unfair_lock, OSSpinLock, etc.)
 * - low-level platform utilities
 */

static const std::vector<api_info> macos_libsystem_platform_apis = {
    // ===== OPTIMIZED STRING FUNCTIONS =====
    {.name = "__platform_strlen",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "length", .param_type = param_info::type::SIZE},
     .description = "optimized string length calculation",
     .headers = {"string.h"}},

    {.name = "__platform_strnlen",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "maxlen", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "length", .param_type = param_info::type::SIZE},
     .description = "optimized string length with maximum",
     .headers = {"string.h"}},

    {.name = "__platform_strcmp",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s1", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "s2", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "optimized string comparison",
     .headers = {"string.h"}},

    {.name = "__platform_strncmp",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s1", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "s2", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "n", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "optimized string comparison with length",
     .headers = {"string.h"}},

    {.name = "__platform_strcpy",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "dest", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "src", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "dest", .param_type = param_info::type::POINTER},
     .description = "optimized string copy (unsafe - no bounds checking)",
     .headers = {"string.h"},
     .security_notes = {"no bounds checking, can cause buffer overflow"}},

    {.name = "__platform_strncpy",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "dest", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "src", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "n", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "dest", .param_type = param_info::type::POINTER},
     .description = "optimized string copy with length limit",
     .headers = {"string.h"}},

    {.name = "__platform_strlcpy",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "dest", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "src", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "copied", .param_type = param_info::type::SIZE},
     .description = "optimized safe string copy",
     .headers = {"string.h"}},

    {.name = "__platform_strlcat",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "dest", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT},
          {.name = "src", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "total_length", .param_type = param_info::type::SIZE},
     .description = "optimized safe string concatenation",
     .headers = {"string.h"}},

    {.name = "__platform_strchr",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "c", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "found", .param_type = param_info::type::POINTER},
     .description = "optimized character search in string",
     .headers = {"string.h"}},

    {.name = "__platform_strstr",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::STRING_MANIPULATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "haystack", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
          {.name = "needle", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "found", .param_type = param_info::type::POINTER},
     .description = "optimized substring search",
     .headers = {"string.h"}},

    // ===== OPTIMIZED MEMORY FUNCTIONS =====
    {.name = "__platform_memcpy",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "dest", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "src", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "n", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "dest", .param_type = param_info::type::POINTER},
     .description = "optimized memory copy (non-overlapping)",
     .headers = {"string.h"},
     .security_notes = {"undefined behavior if memory regions overlap"}},

    {.name = "__platform_memmove",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "dest", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "src", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "n", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "dest", .param_type = param_info::type::POINTER},
     .description = "optimized memory move (handles overlapping)",
     .headers = {"string.h"}},

    {.name = "__platform_memset",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "c", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "n", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "s", .param_type = param_info::type::POINTER},
     .description = "optimized memory fill",
     .headers = {"string.h"}},

    {.name = "__platform_bzero",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "n", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "optimized memory zero",
     .headers = {"strings.h"}},

    {.name = "__platform_memcmp",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s1", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "s2", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "n", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "optimized memory comparison",
     .headers = {"string.h"}},

    {.name = "__platform_memchr",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "s", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "c", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "n", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "found", .param_type = param_info::type::POINTER},
     .description = "optimized byte search in memory",
     .headers = {"string.h"}},

    {.name = "__platform_memccpy",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "dest", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "src", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "c", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "n", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "after_c", .param_type = param_info::type::POINTER},
     .description = "copy memory until character found",
     .headers = {"string.h"}},

    {.name = "__platform_memset_pattern4",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "b", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "pattern", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "len", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "optimized memory fill with 4-byte pattern",
     .headers = {"string.h"}},

    {.name = "__platform_memset_pattern8",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "b", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "pattern", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "len", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "optimized memory fill with 8-byte pattern",
     .headers = {"string.h"}},

    {.name = "__platform_memset_pattern16",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "b", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "pattern", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "len", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "optimized memory fill with 16-byte pattern",
     .headers = {"string.h"}},

    // ===== ATOMIC OPERATIONS =====
    {.name = "_OSAtomicAdd32",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "amount", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "new_value", .param_type = param_info::type::INTEGER},
     .description = "atomic 32-bit addition",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSAtomicAdd32Barrier",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "amount", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "new_value", .param_type = param_info::type::INTEGER},
     .description = "atomic 32-bit addition with memory barrier",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSAtomicAdd64",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "amount", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "new_value", .param_type = param_info::type::INTEGER},
     .description = "atomic 64-bit addition",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSAtomicAdd64Barrier",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "amount", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "new_value", .param_type = param_info::type::INTEGER},
     .description = "atomic 64-bit addition with memory barrier",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSAtomicIncrement32",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "new_value", .param_type = param_info::type::INTEGER},
     .description = "atomic 32-bit increment",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSAtomicIncrement32Barrier",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "new_value", .param_type = param_info::type::INTEGER},
     .description = "atomic 32-bit increment with memory barrier",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSAtomicIncrement64",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "new_value", .param_type = param_info::type::INTEGER},
     .description = "atomic 64-bit increment",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSAtomicIncrement64Barrier",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "new_value", .param_type = param_info::type::INTEGER},
     .description = "atomic 64-bit increment with memory barrier",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSAtomicDecrement32",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "new_value", .param_type = param_info::type::INTEGER},
     .description = "atomic 32-bit decrement",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSAtomicDecrement32Barrier",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "new_value", .param_type = param_info::type::INTEGER},
     .description = "atomic 32-bit decrement with memory barrier",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSAtomicDecrement64",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "new_value", .param_type = param_info::type::INTEGER},
     .description = "atomic 64-bit decrement",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSAtomicDecrement64Barrier",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "new_value", .param_type = param_info::type::INTEGER},
     .description = "atomic 64-bit decrement with memory barrier",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSAtomicCompareAndSwap32",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "old_value", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "new_value", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
     .description = "atomic 32-bit compare and swap",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSAtomicCompareAndSwap32Barrier",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "old_value", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "new_value", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
     .description = "atomic 32-bit compare and swap with memory barrier",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSAtomicCompareAndSwap64",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "old_value", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "new_value", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
     .description = "atomic 64-bit compare and swap",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSAtomicCompareAndSwap64Barrier",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "old_value", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "new_value", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
     .description = "atomic 64-bit compare and swap with memory barrier",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSAtomicCompareAndSwapPtr",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "old_value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "new_value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
     .description = "atomic pointer compare and swap",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSAtomicCompareAndSwapPtrBarrier",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "old_value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "new_value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
     .description = "atomic pointer compare and swap with memory barrier",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSAtomicAnd32",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "mask", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "old_value", .param_type = param_info::type::INTEGER},
     .description = "atomic 32-bit AND operation",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSAtomicAnd32Barrier",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "mask", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "old_value", .param_type = param_info::type::INTEGER},
     .description = "atomic 32-bit AND operation with memory barrier",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSAtomicOr32",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "mask", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "old_value", .param_type = param_info::type::INTEGER},
     .description = "atomic 32-bit OR operation",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSAtomicOr32Barrier",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "mask", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "old_value", .param_type = param_info::type::INTEGER},
     .description = "atomic 32-bit OR operation with memory barrier",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSAtomicXor32",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "mask", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "old_value", .param_type = param_info::type::INTEGER},
     .description = "atomic 32-bit XOR operation",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSAtomicXor32Barrier",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "mask", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "old_value", .param_type = param_info::type::INTEGER},
     .description = "atomic 32-bit XOR operation with memory barrier",
     .headers = {"libkern/OSAtomic.h"}},

    {.name = "_OSMemoryBarrier",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "full memory barrier",
     .headers = {"libkern/OSAtomic.h"}},

    // ===== LOCK OPERATIONS =====
    {.name = "_os_unfair_lock_lock",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "lock", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "acquire unfair lock (modern macOS lock)",
     .headers = {"os/lock.h"}},

    {.name = "_os_unfair_lock_unlock",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "lock", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "release unfair lock",
     .headers = {"os/lock.h"}},

    {.name = "_os_unfair_lock_trylock",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "lock", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "acquired", .param_type = param_info::type::BOOLEAN},
     .description = "try to acquire unfair lock",
     .headers = {"os/lock.h"}},

    {.name = "_os_unfair_lock_assert_owner",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "lock", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "assert current thread owns lock",
     .headers = {"os/lock.h"}},

    {.name = "_os_unfair_lock_assert_not_owner",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "lock", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "assert current thread does not own lock",
     .headers = {"os/lock.h"}},

    {.name = "_OSSpinLockLock",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "lock", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "acquire spin lock (deprecated)",
     .headers = {"libkern/OSAtomic.h"},
     .security_notes = {"deprecated: use os_unfair_lock instead"}},

    {.name = "_OSSpinLockUnlock",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "lock", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "release spin lock (deprecated)",
     .headers = {"libkern/OSAtomic.h"},
     .security_notes = {"deprecated: use os_unfair_lock instead"}},

    {.name = "_OSSpinLockTry",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::THREAD_SAFE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "lock", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT}},
     .return_value = {.name = "acquired", .param_type = param_info::type::BOOLEAN},
     .description = "try to acquire spin lock (deprecated)",
     .headers = {"libkern/OSAtomic.h"},
     .security_notes = {"deprecated: use os_unfair_lock instead"}},

    // ===== MISCELLANEOUS PLATFORM FUNCTIONS =====
    {.name = "_setjmp",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::PROCESS_CONTROL,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "env", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "save program state for longjmp",
     .headers = {"setjmp.h"}},

    {.name = "_longjmp",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::PROCESS_CONTROL,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "env", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "val", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "restore program state from setjmp",
     .headers = {"setjmp.h"}},

    {.name = "__setjmp",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::PROCESS_CONTROL,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "env", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "save program state (internal)",
     .headers = {"setjmp.h"}},

    {.name = "__longjmp",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::PROCESS_CONTROL,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "env", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "val", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "restore program state (internal)",
     .headers = {"setjmp.h"}},

    {.name = "_sigsetjmp",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::PROCESS_CONTROL,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "env", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "savemask", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "save program state with signal mask",
     .headers = {"setjmp.h"}},

    {.name = "_siglongjmp",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::PROCESS_CONTROL,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "env", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "val", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "restore program state with signal mask",
     .headers = {"setjmp.h"}},

    {.name = "_sys_icache_invalidate",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "start", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "len", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "invalidate instruction cache",
     .headers = {"libkern/OSCacheControl.h"}},

    {.name = "_sys_dcache_flush",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "start", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "len", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "flush data cache",
     .headers = {"libkern/OSCacheControl.h"}},

    {.name = "_sys_cache_control",
     .module = "libsystem_platform.dylib",
     .api_category = api_info::category::MEMORY_MANAGEMENT,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "func", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "start", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "len", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
     .description = "generic cache control",
     .headers = {"libkern/OSCacheControl.h"}},
};

} // namespace w1::abi::apis::macos
```

`src/w1tn3ss/abi/apis/macos/libsystem_pthread_apis.hpp`:

```hpp
#pragma once

#include "abi/api_knowledge_db.hpp"
#include <vector>

namespace w1::abi::apis::macos {

// determine macOS calling convention based on architecture
#if defined(__x86_64__)
#define MACOS_API_CONVENTION calling_convention_id::X86_64_SYSTEM_V
#elif defined(__aarch64__)
#define MACOS_API_CONVENTION calling_convention_id::AARCH64_AAPCS
#elif defined(__arm__)
#define MACOS_API_CONVENTION calling_convention_id::ARM32_AAPCS
#elif defined(__i386__)
#define MACOS_API_CONVENTION calling_convention_id::X86_CDECL
#else
#warning "Unknown macOS architecture, using UNKNOWN calling convention"
#define MACOS_API_CONVENTION calling_convention_id::UNKNOWN
#endif

/**
 * @brief libsystem_pthread.dylib api definitions
 *
 * covers pthread threading apis:
 * - thread creation and management
 * - thread synchronization (mutexes, conditions)
 * - thread-local storage
 * - thread attributes
 */

static const std::vector<api_info> macos_libsystem_pthread_apis = {
    // ===== THREAD MANAGEMENT APIs =====
    {.name = "_pthread_create",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::THREADING,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "thread", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "attr",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN,
           .is_optional = true},
          {.name = "start_routine",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN},
          {.name = "arg", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "create new thread",
     .headers = {"pthread.h"}},
    {.name = "_pthread_join",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::THREADING,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "thread", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
          {.name = "value_ptr",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::OUT}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "wait for thread termination",
     .headers = {"pthread.h"}},
    {.name = "_pthread_detach",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::THREADING,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "thread", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "detach thread",
     .headers = {"pthread.h"}},
    {.name = "_pthread_exit",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::THREADING,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "value_ptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "terminate calling thread",
     .headers = {"pthread.h"}},
    {.name = "_pthread_self",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::THREADING,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "thread", .param_type = param_info::type::HANDLE},
     .description = "get current thread id",
     .headers = {"pthread.h"}},
    {.name = "_pthread_equal",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::THREADING,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "t1", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
          {.name = "t2", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "equal", .param_type = param_info::type::BOOLEAN},
     .description = "compare thread ids",
     .headers = {"pthread.h"}},
    {.name = "_pthread_cancel",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::THREADING,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "thread", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "cancel thread execution",
     .headers = {"pthread.h"}},
    {.name = "_pthread_kill",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::THREADING,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "thread", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
          {.name = "sig", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "send signal to thread",
     .headers = {"signal.h", "pthread.h"}},

    // ===== MUTEX APIs =====
    {.name = "_pthread_mutex_init",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::MUTEX,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "mutex", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "attr",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN,
           .is_optional = true}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "initialize mutex",
     .cleanup_api = "_pthread_mutex_destroy",
     .headers = {"pthread.h"}},
    {.name = "_pthread_mutex_destroy",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::MUTEX,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "mutex", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "destroy mutex",
     .headers = {"pthread.h"}},
    {.name = "_pthread_mutex_lock",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::MUTEX,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "mutex", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "lock mutex",
     .headers = {"pthread.h"}},
    {.name = "_pthread_mutex_unlock",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::MUTEX,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "mutex", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "unlock mutex",
     .headers = {"pthread.h"}},
    {.name = "_pthread_mutex_trylock",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::MUTEX,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "mutex", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "try to lock mutex without blocking",
     .headers = {"pthread.h"}},

    // ===== CONDITION VARIABLE APIs =====
    {.name = "_pthread_cond_init",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "cond", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "attr",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN,
           .is_optional = true}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "initialize condition variable",
     .cleanup_api = "_pthread_cond_destroy",
     .headers = {"pthread.h"}},
    {.name = "_pthread_cond_destroy",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "cond", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "destroy condition variable",
     .headers = {"pthread.h"}},
    {.name = "_pthread_cond_wait",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "cond", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "mutex", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "wait on condition variable",
     .headers = {"pthread.h"}},
    {.name = "_pthread_cond_timedwait",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "cond", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "mutex", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "abstime", .param_type = param_info::type::STRUCT, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "wait on condition variable with timeout",
     .headers = {"pthread.h"}},
    {.name = "_pthread_cond_signal",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "cond", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "signal condition variable",
     .headers = {"pthread.h"}},
    {.name = "_pthread_cond_broadcast",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "cond", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "broadcast condition variable",
     .headers = {"pthread.h"}},

    // ===== THREAD-LOCAL STORAGE APIs =====
    {.name = "_pthread_key_create",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::THREADING,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "key", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "destructor",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN,
           .is_optional = true}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "create thread-local storage key",
     .cleanup_api = "_pthread_key_delete",
     .headers = {"pthread.h"}},
    {.name = "_pthread_key_delete",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::THREADING,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "key", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "delete thread-local storage key",
     .headers = {"pthread.h"}},
    {.name = "_pthread_getspecific",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::THREADING,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "key", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "value", .param_type = param_info::type::POINTER},
     .description = "get thread-local storage value",
     .headers = {"pthread.h"}},
    {.name = "_pthread_setspecific",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::THREADING,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "key", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "value", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "set thread-local storage value",
     .headers = {"pthread.h"}},

    // ===== THREAD ATTRIBUTE APIs =====
    {.name = "_pthread_attr_init",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::THREADING,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "attr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "initialize thread attributes",
     .cleanup_api = "_pthread_attr_destroy",
     .headers = {"pthread.h"}},
    {.name = "_pthread_attr_destroy",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::THREADING,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "attr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "destroy thread attributes",
     .headers = {"pthread.h"}},
    {.name = "_pthread_attr_setdetachstate",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::THREADING,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "attr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "detachstate",
           .param_type = param_info::type::INTEGER,
           .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "set thread detach state",
     .headers = {"pthread.h"}},
    {.name = "_pthread_attr_setstacksize",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::THREADING,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "attr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
          {.name = "stacksize", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "set thread stack size",
     .headers = {"pthread.h"}},

    // ===== READ-WRITE LOCK APIs =====
    {.name = "_pthread_rwlock_init",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "rwlock", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "attr",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN,
           .is_optional = true}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "initialize read-write lock",
     .cleanup_api = "_pthread_rwlock_destroy",
     .headers = {"pthread.h"}},
    {.name = "_pthread_rwlock_destroy",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "rwlock", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "destroy read-write lock",
     .headers = {"pthread.h"}},
    {.name = "_pthread_rwlock_rdlock",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "rwlock", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "acquire read lock",
     .headers = {"pthread.h"}},
    {.name = "_pthread_rwlock_wrlock",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "rwlock", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "acquire write lock",
     .headers = {"pthread.h"}},
    {.name = "_pthread_rwlock_unlock",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::SYNCHRONIZATION,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "rwlock", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "release read-write lock",
     .headers = {"pthread.h"}},

    // ===== THREAD SCHEDULING =====
    {.name = "_pthread_setschedparam",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::THREADING,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "thread", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
          {.name = "policy", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
          {.name = "param", .param_type = param_info::type::STRUCT, .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "set thread scheduling parameters",
     .headers = {"pthread.h"}},
    {.name = "_pthread_getschedparam",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::THREADING,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "thread", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
          {.name = "policy", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
          {.name = "param", .param_type = param_info::type::STRUCT, .param_direction = param_info::direction::OUT}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "get thread scheduling parameters",
     .headers = {"pthread.h"}},

    // ===== MISC THREAD APIs =====
    {.name = "_pthread_once",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::THREADING,
     .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
     .convention = MACOS_API_CONVENTION,
     .parameters =
         {{.name = "once_control",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN_OUT},
          {.name = "init_routine",
           .param_type = param_info::type::POINTER,
           .param_direction = param_info::direction::IN}},
     .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
     .description = "execute function once",
     .headers = {"pthread.h"}},
    {.name = "_pthread_yield_np",
     .module = "libsystem_pthread.dylib",
     .api_category = api_info::category::THREADING,
     .flags = 0,
     .convention = MACOS_API_CONVENTION,
     .parameters = {},
     .return_value = {.name = "void", .param_type = param_info::type::VOID},
     .description = "yield processor to other threads",
     .headers = {"pthread.h"}}
};

} // namespace w1::abi::apis::macos
```

`src/w1tn3ss/abi/apis/macos/system_apis.hpp`:

```hpp
#pragma once

#include "libsystem_c_apis.hpp"
#include "libsystem_kernel_apis.hpp"
#include "libsystem_malloc_apis.hpp"
#include "libsystem_pthread_apis.hpp"
#include "libsystem_m_apis.hpp"
#include "libsystem_platform_apis.hpp"
#include "libdyld_apis.hpp"
#include "libcxx_apis.hpp"

namespace w1::abi::apis::macos {

/**
 * @brief aggregated macOS system apis from all libraries
 *
 * this combines apis from:
 * - libsystem_c.dylib (standard c library)
 * - libsystem_kernel.dylib (system calls)
 * - libsystem_malloc.dylib (heap management)
 * - libsystem_pthread.dylib (threading)
 * - libsystem_m.dylib (math functions)
 * - libsystem_platform.dylib (optimized platform functions)
 * - libdyld.dylib (dynamic linking)
 * - libc++abi.dylib and libc++.1.dylib (c++ runtime and standard library)
 *
 * discover apis using (for example):
 * nm -gU /path/to/dyld_dmp/usr/lib/system/libsystem_c.dylib | grep printf
 *
 */
static std::vector<api_info> get_all_macos_system_apis() {
  std::vector<api_info> all_apis;

  // aggregate all apis from different libraries
  all_apis.insert(all_apis.end(), macos_libsystem_c_apis.begin(), macos_libsystem_c_apis.end());
  all_apis.insert(all_apis.end(), macos_libsystem_kernel_apis.begin(), macos_libsystem_kernel_apis.end());
  all_apis.insert(all_apis.end(), macos_libsystem_malloc_apis.begin(), macos_libsystem_malloc_apis.end());
  all_apis.insert(all_apis.end(), macos_libsystem_pthread_apis.begin(), macos_libsystem_pthread_apis.end());
  all_apis.insert(all_apis.end(), macos_libsystem_m_apis.begin(), macos_libsystem_m_apis.end());
  all_apis.insert(all_apis.end(), macos_libsystem_platform_apis.begin(), macos_libsystem_platform_apis.end());
  all_apis.insert(all_apis.end(), macos_libdyld_apis.begin(), macos_libdyld_apis.end());
  all_apis.insert(all_apis.end(), macos_libcxx_apis.begin(), macos_libcxx_apis.end());

  return all_apis;
}

// for backward compatibility, provide the old name
static const auto macos_system_apis = get_all_macos_system_apis();

} // namespace w1::abi::apis::macos
```

`src/w1tn3ss/abi/apis/windows/advapi32_apis.hpp`:

```hpp
#pragma once

#include "abi/api_knowledge_db.hpp"
#include <vector>

namespace w1::abi::apis::windows {

// determine windows calling convention based on architecture
#if defined(_M_X64) || defined(__x86_64__)
#define WINDOWS_API_CONVENTION calling_convention_id::X86_64_MICROSOFT
#elif defined(_M_IX86) || defined(__i386__)
#define WINDOWS_API_CONVENTION calling_convention_id::X86_STDCALL
#else
#define WINDOWS_API_CONVENTION calling_convention_id::UNKNOWN
#endif

/**
 * @brief advapi32.dll api definitions
 *
 * covers windows security and administration apis:
 * - token and privilege manipulation
 * - access control and security descriptors
 * - service control and management
 * - registry security and operations
 * - cryptographic providers
 * - event logging and auditing
 * - local security authority (lsa) functions
 */

static const std::vector<api_info> windows_advapi32_apis = {
    // === TOKEN AND PRIVILEGE MANIPULATION ===

    api_info{
        .name = "OpenProcessToken",
        .module = "advapi32.dll",
        .api_category = api_info::category::SECURITY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
                 static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "ProcessHandle",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "DesiredAccess",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "TokenHandle",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "open access token associated with process",
        .security_notes = {"privilege escalation vector", "token manipulation capability"},
        .related_apis = {"OpenThreadToken", "AdjustTokenPrivileges", "GetTokenInformation"},
        .cleanup_api = "CloseHandle",
        .headers = {"windows.h", "processthreadsapi.h", "securitybaseapi.h"}
    },

    api_info{
        .name = "OpenThreadToken",
        .module = "advapi32.dll",
        .api_category = api_info::category::SECURITY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
                 static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "ThreadHandle",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "DesiredAccess",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "OpenAsSelf",
              .param_type = param_info::type::BOOLEAN,
              .param_direction = param_info::direction::IN},
             {.name = "TokenHandle",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "open access token associated with thread",
        .related_apis = {"OpenProcessToken", "SetThreadToken", "ImpersonateLoggedOnUser"},
        .cleanup_api = "CloseHandle",
        .headers = {"windows.h", "processthreadsapi.h", "securitybaseapi.h"}
    },

    api_info{
        .name = "AdjustTokenPrivileges",
        .module = "advapi32.dll",
        .api_category = api_info::category::SECURITY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "TokenHandle",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "DisableAllPrivileges",
              .param_type = param_info::type::BOOLEAN,
              .param_direction = param_info::direction::IN},
             {.name = "NewState",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "BufferLength",
              .param_type = param_info::type::SIZE,
              .param_direction = param_info::direction::IN},
             {.name = "PreviousState",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "ReturnLength",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "enable or disable privileges in access token",
        .security_notes = {"privilege escalation mechanism", "requires se_privilege to adjust"},
        .related_apis = {"LookupPrivilegeValue", "GetTokenInformation", "OpenProcessToken"},
        .headers = {"windows.h", "securitybaseapi.h"}
    },

    api_info{
        .name = "LookupPrivilegeValueW",
        .module = "advapi32.dll",
        .api_category = api_info::category::SECURITY,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpSystemName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "lpName", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
             {.name = "lpLuid",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve luid for privilege name",
        .related_apis = {"AdjustTokenPrivileges", "LookupPrivilegeName"},
        .headers = {"windows.h", "winbase.h"}
    },

    api_info{
        .name = "GetTokenInformation",
        .module = "advapi32.dll",
        .api_category = api_info::category::SECURITY,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "TokenHandle",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "TokenInformationClass",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "TokenInformation",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "TokenInformationLength",
              .param_type = param_info::type::SIZE,
              .param_direction = param_info::direction::IN},
             {.name = "ReturnLength",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve information about access token",
        .related_apis = {"OpenProcessToken", "SetTokenInformation"},
        .headers = {"windows.h", "securitybaseapi.h"}
    },

    api_info{
        .name = "DuplicateTokenEx",
        .module = "advapi32.dll",
        .api_category = api_info::category::SECURITY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
                 static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hExistingToken",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "dwDesiredAccess",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "lpTokenAttributes",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "ImpersonationLevel",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "TokenType",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "phNewToken",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "create new access token that duplicates existing token",
        .security_notes = {"token duplication for impersonation", "privilege escalation vector"},
        .related_apis = {"OpenProcessToken", "ImpersonateLoggedOnUser"},
        .cleanup_api = "CloseHandle",
        .headers = {"windows.h", "securitybaseapi.h"}
    },

    // === IMPERSONATION ===

    api_info{
        .name = "ImpersonateLoggedOnUser",
        .module = "advapi32.dll",
        .api_category = api_info::category::SECURITY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hToken", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "impersonate security context of logged-on user",
        .security_notes = {"impersonation capability", "privilege escalation vector"},
        .related_apis = {"RevertToSelf", "DuplicateTokenEx", "LogonUser"},
        .headers = {"windows.h", "securitybaseapi.h"}
    },

    api_info{
        .name = "RevertToSelf",
        .module = "advapi32.dll",
        .api_category = api_info::category::SECURITY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters = {},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "terminate impersonation of client",
        .related_apis = {"ImpersonateLoggedOnUser", "ImpersonateNamedPipeClient"},
        .headers = {"windows.h", "securitybaseapi.h"}
    },

    api_info{
        .name = "ImpersonateNamedPipeClient",
        .module = "advapi32.dll",
        .api_category = api_info::category::SECURITY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hNamedPipe",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "impersonate security context of named pipe client",
        .security_notes = {"named pipe impersonation", "privilege escalation via ipc"},
        .related_apis = {"RevertToSelf", "CreateNamedPipeW", "ConnectNamedPipe"},
        .headers = {"windows.h", "namedpipeapi.h"}
    },

    // === SERVICE CONTROL ===

    api_info{
        .name = "OpenSCManagerW",
        .module = "advapi32.dll",
        .api_category = api_info::category::SECURITY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
                 static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpMachineName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "lpDatabaseName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "dwDesiredAccess",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "scHandle", .param_type = param_info::type::HANDLE},
        .description = "establish connection to service control manager",
        .security_notes = {"service manipulation capability", "persistence mechanism"},
        .related_apis = {"CreateServiceW", "OpenServiceW", "CloseServiceHandle"},
        .cleanup_api = "CloseServiceHandle",
        .headers = {"windows.h", "winsvc.h"}
    },

    api_info{
        .name = "CreateServiceW",
        .module = "advapi32.dll",
        .api_category = api_info::category::SECURITY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
                 static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hSCManager",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "lpServiceName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "lpDisplayName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "dwDesiredAccess",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "dwServiceType",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "dwStartType",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "dwErrorControl",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "lpBinaryPathName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "lpLoadOrderGroup",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "lpdwTagId",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "lpDependencies",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "lpServiceStartName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "lpPassword",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "serviceHandle", .param_type = param_info::type::HANDLE},
        .description = "create service object and add to scm database",
        .security_notes = {"service creation for persistence", "requires administrative privileges"},
        .related_apis = {"OpenSCManagerW", "StartServiceW", "DeleteService"},
        .cleanup_api = "CloseServiceHandle",
        .headers = {"windows.h", "winsvc.h"}
    },

    api_info{
        .name = "OpenServiceW",
        .module = "advapi32.dll",
        .api_category = api_info::category::SECURITY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hSCManager",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "lpServiceName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "dwDesiredAccess",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "serviceHandle", .param_type = param_info::type::HANDLE},
        .description = "open existing service for specified access",
        .related_apis = {"OpenSCManagerW", "QueryServiceStatus", "ControlService"},
        .cleanup_api = "CloseServiceHandle",
        .headers = {"windows.h", "winsvc.h"}
    },

    api_info{
        .name = "StartServiceW",
        .module = "advapi32.dll",
        .api_category = api_info::category::SECURITY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hService", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "dwNumServiceArgs",
              .param_type = param_info::type::COUNT,
              .param_direction = param_info::direction::IN},
             {.name = "lpServiceArgVectors",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "start service",
        .security_notes = {"service execution capability", "potential privilege escalation"},
        .related_apis = {"OpenServiceW", "ControlService", "CreateServiceW"},
        .headers = {"windows.h", "winsvc.h"}
    },

    api_info{
        .name = "ControlService",
        .module = "advapi32.dll",
        .api_category = api_info::category::SECURITY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hService", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "dwControl", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
             {.name = "lpServiceStatus",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "send control code to service",
        .security_notes = {"service control capability", "can stop/pause/continue services"},
        .related_apis = {"StartServiceW", "QueryServiceStatus", "OpenServiceW"},
        .headers = {"windows.h", "winsvc.h"}
    },

    api_info{
        .name = "DeleteService",
        .module = "advapi32.dll",
        .api_category = api_info::category::SECURITY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hService",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "mark service for deletion",
        .security_notes = {"service deletion capability", "anti-forensics technique"},
        .related_apis = {"CreateServiceW", "OpenServiceW"},
        .headers = {"windows.h", "winsvc.h"}
    },

    api_info{
        .name = "CloseServiceHandle",
        .module = "advapi32.dll",
        .api_category = api_info::category::SECURITY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::CLOSES_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hSCObject",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "close handle to service control manager or service",
        .related_apis = {"OpenSCManagerW", "OpenServiceW", "CreateServiceW"},
        .headers = {"windows.h", "winsvc.h"}
    },

    // === REGISTRY OPERATIONS ===

    api_info{
        .name = "RegOpenKeyExW",
        .module = "advapi32.dll",
        .api_category = api_info::category::REGISTRY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
                 static_cast<uint32_t>(api_info::behavior_flags::REGISTRY_ACCESS),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hKey", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpSubKey", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
             {.name = "ulOptions", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
             {.name = "samDesired",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "phkResult",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
        .description = "open specified registry key",
        .security_notes = {"registry access for persistence", "configuration modification"},
        .related_apis = {"RegCreateKeyExW", "RegSetValueExW", "RegQueryValueExW"},
        .cleanup_api = "RegCloseKey",
        .headers = {"windows.h", "winreg.h"}
    },

    api_info{
        .name = "RegCreateKeyExW",
        .module = "advapi32.dll",
        .api_category = api_info::category::REGISTRY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
                 static_cast<uint32_t>(api_info::behavior_flags::REGISTRY_ACCESS) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hKey", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpSubKey", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
             {.name = "Reserved",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "lpClass", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
             {.name = "dwOptions", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
             {.name = "samDesired",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "lpSecurityAttributes",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "phkResult",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "lpdwDisposition",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
        .description = "create registry key or open existing one",
        .security_notes = {"registry key creation for persistence", "system configuration modification"},
        .related_apis = {"RegOpenKeyExW", "RegSetValueExW", "RegDeleteKeyW"},
        .cleanup_api = "RegCloseKey",
        .headers = {"windows.h", "winreg.h"}
    },

    api_info{
        .name = "RegSetValueExW",
        .module = "advapi32.dll",
        .api_category = api_info::category::REGISTRY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::REGISTRY_ACCESS) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hKey", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpValueName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "Reserved",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "dwType", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "lpData", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::IN},
             {.name = "cbData", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
        .description = "set data for specified registry value",
        .security_notes = {"registry modification for persistence", "configuration tampering"},
        .related_apis = {"RegQueryValueExW", "RegDeleteValueW", "RegCreateKeyExW"},
        .headers = {"windows.h", "winreg.h"}
    },

    api_info{
        .name = "RegQueryValueExW",
        .module = "advapi32.dll",
        .api_category = api_info::category::REGISTRY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::REGISTRY_ACCESS),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hKey", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpValueName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "lpReserved",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "lpType", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
             {.name = "lpData", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::OUT},
             {.name = "lpcbData",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT}},
        .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
        .description = "retrieve data for specified registry value",
        .related_apis = {"RegSetValueExW", "RegEnumValueW", "RegOpenKeyExW"},
        .headers = {"windows.h", "winreg.h"}
    },

    api_info{
        .name = "RegDeleteValueW",
        .module = "advapi32.dll",
        .api_category = api_info::category::REGISTRY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::REGISTRY_ACCESS) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hKey", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpValueName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
        .description = "delete named value from specified registry key",
        .security_notes = {"registry cleanup", "anti-forensics technique"},
        .related_apis = {"RegSetValueExW", "RegDeleteKeyW", "RegQueryValueExW"},
        .headers = {"windows.h", "winreg.h"}
    },

    api_info{
        .name = "RegDeleteKeyW",
        .module = "advapi32.dll",
        .api_category = api_info::category::REGISTRY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::REGISTRY_ACCESS) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hKey", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpSubKey",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
        .description = "delete subkey and all its values",
        .security_notes = {"registry key deletion", "anti-forensics technique"},
        .related_apis = {"RegCreateKeyExW", "RegDeleteValueW", "RegDeleteTreeW"},
        .headers = {"windows.h", "winreg.h"}
    },

    api_info{
        .name = "RegCloseKey",
        .module = "advapi32.dll",
        .api_category = api_info::category::REGISTRY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::CLOSES_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hKey", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
        .description = "close handle to specified registry key",
        .related_apis = {"RegOpenKeyExW", "RegCreateKeyExW"},
        .headers = {"windows.h", "winreg.h"}
    },

    // === CRYPTOGRAPHIC PROVIDERS ===

    api_info{
        .name = "CryptAcquireContextW",
        .module = "advapi32.dll",
        .api_category = api_info::category::CRYPTO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "phProv", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
             {.name = "szContainer",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "szProvider",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "dwProvType",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "dwFlags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "acquire handle to cryptographic service provider",
        .related_apis = {"CryptGenRandom", "CryptCreateHash", "CryptReleaseContext"},
        .cleanup_api = "CryptReleaseContext",
        .headers = {"windows.h", "wincrypt.h"}
    },

    api_info{
        .name = "CryptGenRandom",
        .module = "advapi32.dll",
        .api_category = api_info::category::CRYPTO,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProv", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "dwLen", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
             {.name = "pbBuffer",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "generate cryptographically random data",
        .related_apis = {"CryptAcquireContextW", "CryptCreateHash"},
        .headers = {"windows.h", "wincrypt.h"}
    },

    api_info{
        .name = "CryptCreateHash",
        .module = "advapi32.dll",
        .api_category = api_info::category::CRYPTO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProv", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "Algid", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "hKey", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "dwFlags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
             {.name = "phHash",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "create empty hash object",
        .related_apis = {"CryptHashData", "CryptGetHashParam", "CryptDestroyHash"},
        .cleanup_api = "CryptDestroyHash",
        .headers = {"windows.h", "wincrypt.h"}
    },

    api_info{
        .name = "CryptHashData",
        .module = "advapi32.dll",
        .api_category = api_info::category::CRYPTO,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hHash", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "pbData", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::IN},
             {.name = "dwDataLen", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
             {.name = "dwFlags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "add data to specified hash object",
        .related_apis = {"CryptCreateHash", "CryptGetHashParam"},
        .headers = {"windows.h", "wincrypt.h"}
    },

    // === EVENT LOGGING ===

    api_info{
        .name = "OpenEventLogW",
        .module = "advapi32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpUNCServerName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "lpSourceName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "eventLogHandle", .param_type = param_info::type::HANDLE},
        .description = "open handle to event log",
        .related_apis = {"ReadEventLogW", "WriteEventLogW", "CloseEventLog"},
        .cleanup_api = "CloseEventLog",
        .headers = {"windows.h", "winbase.h"}
    },

    api_info{
        .name = "ReadEventLogW",
        .module = "advapi32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hEventLog",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "dwReadFlags",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "dwRecordOffset",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "lpBuffer",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "nNumberOfBytesToRead",
              .param_type = param_info::type::SIZE,
              .param_direction = param_info::direction::IN},
             {.name = "pnBytesRead",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "pnMinNumberOfBytesNeeded",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "read entries from event log",
        .related_apis = {"OpenEventLogW", "GetOldestEventLogRecord"},
        .headers = {"windows.h", "winbase.h"}
    },

    api_info{
        .name = "ClearEventLogW",
        .module = "advapi32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE) |
                 static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hEventLog",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "lpBackupFileName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "clear event log",
        .security_notes = {"log clearing for anti-forensics", "evidence destruction"},
        .related_apis = {"OpenEventLogW", "ReadEventLogW"},
        .headers = {"windows.h", "winbase.h"}
    }
};

#undef WINDOWS_API_CONVENTION

} // namespace w1::abi::apis::windows
```

`src/w1tn3ss/abi/apis/windows/kernel32_apis.hpp`:

```hpp
#pragma once

#include "abi/api_knowledge_db.hpp"
#include <vector>

namespace w1::abi::apis::windows {

// determine windows calling convention based on architecture
#if defined(_M_X64) || defined(__x86_64__)
#define WINDOWS_API_CONVENTION calling_convention_id::X86_64_MICROSOFT
#elif defined(_M_IX86) || defined(__i386__)
#define WINDOWS_API_CONVENTION calling_convention_id::X86_STDCALL
#else
#warning "Unknown Windows architecture, using UNKNOWN calling convention"
#define WINDOWS_API_CONVENTION calling_convention_id::UNKNOWN
#endif

/**
 * @brief kernel32.dll api definitions
 *
 * covers windows kernel32.dll apis for:
 * - process and thread management
 * - memory allocation and management
 * - file and i/o operations
 * - i/o completion ports
 * - synchronization primitives
 * - library/module loading
 * - error handling and system information
 * - string conversion utilities
 */

static const std::vector<api_info> windows_kernel32_apis = {
    // process management
    api_info{
        .name = "CreateProcessW",
        .module = "kernel32.dll",
        .api_category = api_info::category::PROCESS_CONTROL,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpApplicationName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "lpCommandLine",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN_OUT},
             {.name = "lpProcessAttributes",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "lpThreadAttributes",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "bInheritHandles",
              .param_type = param_info::type::BOOLEAN,
              .param_direction = param_info::direction::IN},
             {.name = "dwCreationFlags",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "lpEnvironment",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "lpCurrentDirectory",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "lpStartupInfo",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "lpProcessInformation",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "create new process and primary thread",
        .headers = {"windows.h", "processthreadsapi.h"}
    },

    api_info{
        .name = "OpenProcess",
        .module = "kernel32.dll",
        .api_category = api_info::category::PROCESS_CONTROL,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
                 static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "dwDesiredAccess",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "bInheritHandle",
              .param_type = param_info::type::BOOLEAN,
              .param_direction = param_info::direction::IN},
             {.name = "dwProcessId",
              .param_type = param_info::type::PROCESS_ID,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "handle", .param_type = param_info::type::HANDLE},
        .description = "open existing process object",
        .related_apis = {"GetCurrentProcess", "CreateProcess"},
        .cleanup_api = "CloseHandle",
        .headers = {"windows.h", "processthreadsapi.h"}
    },

    api_info{
        .name = "GetCurrentProcess",
        .module = "kernel32.dll",
        .api_category = api_info::category::PROCESS_CONTROL,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters = {},
        .return_value = {.name = "handle", .param_type = param_info::type::HANDLE},
        .description = "get pseudo handle to current process",
        .related_apis = {"GetCurrentThread", "OpenProcess"},
        .headers = {"windows.h", "processthreadsapi.h"}
    },

    api_info{
        .name = "GetCurrentThread",
        .module = "kernel32.dll",
        .api_category = api_info::category::THREAD_CONTROL,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters = {},
        .return_value = {.name = "handle", .param_type = param_info::type::HANDLE},
        .description = "get pseudo handle to current thread",
        .related_apis = {"GetCurrentProcess", "OpenThread"},
        .headers = {"windows.h", "processthreadsapi.h"}
    },

    api_info{
        .name = "ExitProcess",
        .module = "kernel32.dll",
        .api_category = api_info::category::PROCESS_CONTROL,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "uExitCode",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "void", .param_type = param_info::type::VOID},
        .description = "terminate current process and all its threads",
        .related_apis = {"TerminateProcess", "exit"},
        .headers = {"windows.h", "processthreadsapi.h"}
    },

    api_info{
        .name = "TerminateProcess",
        .module = "kernel32.dll",
        .api_category = api_info::category::PROCESS_CONTROL,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE) |
                 static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProcess", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "uExitCode",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "terminate specified process forcefully",
        .security_notes = {"dangerous - can corrupt data", "use ExitProcess for self-termination"},
        .related_apis = {"ExitProcess", "OpenProcess"},
        .headers = {"windows.h", "processthreadsapi.h"}
    },

    api_info{
        .name = "GetExitCodeProcess",
        .module = "kernel32.dll",
        .api_category = api_info::category::PROCESS_CONTROL,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProcess", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpExitCode",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve exit code of specified process",
        .related_apis = {"ExitProcess", "WaitForSingleObject"},
        .headers = {"windows.h", "processthreadsapi.h"}
    },

    // memory management
    api_info{
        .name = "VirtualAlloc",
        .module = "kernel32.dll",
        .api_category = api_info::category::HEAP_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpAddress",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "dwSize", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
             {.name = "flAllocationType",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "flProtect",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "baseAddress", .param_type = param_info::type::POINTER},
        .description = "allocate virtual memory",
        .cleanup_api = "VirtualFree",
        .headers = {"windows.h", "memoryapi.h"}
    },

    api_info{
        .name = "VirtualFree",
        .module = "kernel32.dll",
        .api_category = api_info::category::HEAP_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FREES_MEMORY),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpAddress",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "dwSize", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
             {.name = "dwFreeType",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "free virtual memory",
        .headers = {"windows.h", "memoryapi.h"}
    },

    api_info{
        .name = "HeapAlloc",
        .module = "kernel32.dll",
        .api_category = api_info::category::HEAP_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hHeap", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "dwFlags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
             {.name = "dwBytes", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "pointer", .param_type = param_info::type::POINTER},
        .description = "allocate memory from heap",
        .related_apis = {"GetProcessHeap", "HeapCreate"},
        .cleanup_api = "HeapFree",
        .headers = {"windows.h", "heapapi.h"}
    },

    api_info{
        .name = "HeapFree",
        .module = "kernel32.dll",
        .api_category = api_info::category::HEAP_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FREES_MEMORY),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hHeap", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "dwFlags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
             {.name = "lpMem", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "free memory allocated from heap",
        .related_apis = {"HeapAlloc", "GetProcessHeap"},
        .headers = {"windows.h", "heapapi.h"}
    },

    api_info{
        .name = "GetProcessHeap",
        .module = "kernel32.dll",
        .api_category = api_info::category::HEAP_MANAGEMENT,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters = {},
        .return_value = {.name = "heap", .param_type = param_info::type::HANDLE},
        .description = "get handle to default heap of calling process",
        .related_apis = {"HeapAlloc", "HeapFree", "HeapCreate"},
        .headers = {"windows.h", "heapapi.h"}
    },

    // i/o completion ports
    api_info{
        .name = "GetQueuedCompletionStatus",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYNCHRONIZATION,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING) |
                 static_cast<uint32_t>(api_info::behavior_flags::ASYNC),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "CompletionPort",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "lpNumberOfBytesTransferred",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "lpCompletionKey",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "lpOverlapped",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "dwMilliseconds",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "dequeue completion packet from i/o completion port",
        .related_apis = {"CreateIoCompletionPort", "PostQueuedCompletionStatus"},
        .headers = {"windows.h", "ioapiset.h"}
    },

    api_info{
        .name = "CreateIoCompletionPort",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYNCHRONIZATION,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
                 static_cast<uint32_t>(api_info::behavior_flags::ASYNC),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "FileHandle",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "ExistingCompletionPort",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "CompletionKey",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "NumberOfConcurrentThreads",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "port", .param_type = param_info::type::HANDLE},
        .description = "create or associate file with i/o completion port",
        .related_apis = {"GetQueuedCompletionStatus", "PostQueuedCompletionStatus"},
        .cleanup_api = "CloseHandle",
        .headers = {"windows.h", "ioapiset.h"}
    },

    api_info{
        .name = "PostQueuedCompletionStatus",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYNCHRONIZATION,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::ASYNC),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "CompletionPort",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "dwNumberOfBytesTransferred",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "dwCompletionKey",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "lpOverlapped",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "post completion packet to i/o completion port",
        .related_apis = {"CreateIoCompletionPort", "GetQueuedCompletionStatus"},
        .headers = {"windows.h", "ioapiset.h"}
    },

    // file operations
    api_info{
        .name = "CreateFileW",
        .module = "kernel32.dll",
        .api_category = api_info::category::FILE_IO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpFileName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "dwDesiredAccess",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "dwShareMode",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "lpSecurityAttributes",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "dwCreationDisposition",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "dwFlagsAndAttributes",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "hTemplateFile",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "handle", .param_type = param_info::type::HANDLE},
        .description = "open or create file",
        .cleanup_api = "CloseHandle",
        .headers = {"windows.h", "fileapi.h"}
    },

    api_info{
        .name = "ReadFile",
        .module = "kernel32.dll",
        .api_category = api_info::category::FILE_IO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hFile", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpBuffer",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "nNumberOfBytesToRead",
              .param_type = param_info::type::SIZE,
              .param_direction = param_info::direction::IN},
             {.name = "lpNumberOfBytesRead",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "lpOverlapped",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "read from file",
        .headers = {"windows.h", "fileapi.h"}
    },

    api_info{
        .name = "WriteFile",
        .module = "kernel32.dll",
        .api_category = api_info::category::FILE_IO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hFile", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpBuffer", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::IN},
             {.name = "nNumberOfBytesToWrite",
              .param_type = param_info::type::SIZE,
              .param_direction = param_info::direction::IN},
             {.name = "lpNumberOfBytesWritten",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "lpOverlapped",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "write to file",
        .headers = {"windows.h", "fileapi.h"}
    },

    // thread management
    api_info{
        .name = "CreateThread",
        .module = "kernel32.dll",
        .api_category = api_info::category::THREAD_CONTROL,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpThreadAttributes",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "dwStackSize",
              .param_type = param_info::type::SIZE,
              .param_direction = param_info::direction::IN},
             {.name = "lpStartAddress",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "lpParameter",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "dwCreationFlags",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "lpThreadId",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "handle", .param_type = param_info::type::HANDLE},
        .description = "create new thread",
        .cleanup_api = "CloseHandle",
        .headers = {"windows.h", "processthreadsapi.h"}
    },

    // synchronization
    api_info{
        .name = "WaitForSingleObject",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYNCHRONIZATION,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hHandle", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "dwMilliseconds",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
        .description = "wait for object state",
        .headers = {"windows.h", "synchapi.h"}
    },

    api_info{
        .name = "CreateMutexW",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYNCHRONIZATION,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpMutexAttributes",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "bInitialOwner",
              .param_type = param_info::type::BOOLEAN,
              .param_direction = param_info::direction::IN},
             {.name = "lpName", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "handle", .param_type = param_info::type::HANDLE},
        .description = "create mutex object",
        .cleanup_api = "CloseHandle",
        .headers = {"windows.h", "synchapi.h"}
    },

    // handle management
    api_info{
        .name = "CloseHandle",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::CLOSES_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hObject", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "close object handle",
        .security_notes = {"double-close can cause issues", "invalid handle causes undefined behavior"},
        .headers = {"windows.h", "handleapi.h"}
    },

    api_info{
        .name = "DuplicateHandle",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hSourceProcessHandle",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "hSourceHandle",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "hTargetProcessHandle",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "lpTargetHandle",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "dwDesiredAccess",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "bInheritHandle",
              .param_type = param_info::type::BOOLEAN,
              .param_direction = param_info::direction::IN},
             {.name = "dwOptions",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "duplicate object handle",
        .cleanup_api = "CloseHandle",
        .headers = {"windows.h", "handleapi.h"}
    },

    // error handling
    api_info{
        .name = "GetLastError",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters = {},
        .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
        .description = "retrieve calling thread's last error code",
        .related_apis = {"SetLastError", "FormatMessage"},
        .headers = {"windows.h", "errhandlingapi.h"}
    },

    api_info{
        .name = "SetLastError",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "dwErrCode",
              .param_type = param_info::type::ERROR_CODE,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "void", .param_type = param_info::type::VOID},
        .description = "set calling thread's last error code",
        .related_apis = {"GetLastError", "FormatMessage"},
        .headers = {"windows.h", "errhandlingapi.h"}
    },

    api_info{
        .name = "FormatMessageW",
        .module = "kernel32.dll",
        .api_category = api_info::category::STRING_MANIPULATION,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "dwFlags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
             {.name = "lpSource",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "dwMessageId",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "dwLanguageId",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "lpBuffer",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "nSize", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
             {.name = "Arguments",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "length", .param_type = param_info::type::SIZE},
        .description = "format message string from system error code",
        .related_apis = {"GetLastError", "SetLastError"},
        .headers = {"windows.h", "winbase.h"}
    },

    // system information
    api_info{
        .name = "GetSystemInfo",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpSystemInfo",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "void", .param_type = param_info::type::VOID},
        .description = "retrieve system configuration information",
        .headers = {"windows.h", "sysinfoapi.h"}
    },

    api_info{
        .name = "GetComputerNameW",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpBuffer",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "nSize",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve netbios name of local computer",
        .headers = {"windows.h", "winbase.h"}
    },

    // library/module loading
    api_info{
        .name = "LoadLibraryW",
        .module = "kernel32.dll",
        .api_category = api_info::category::LIBRARY_LOADING,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpLibFileName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "module", .param_type = param_info::type::POINTER},
        .description = "load dll into process",
        .cleanup_api = "FreeLibrary",
        .headers = {"windows.h", "libloaderapi.h"}
    },

    api_info{
        .name = "GetProcAddress",
        .module = "kernel32.dll",
        .api_category = api_info::category::LIBRARY_LOADING,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hModule", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
             {.name = "lpProcName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "address", .param_type = param_info::type::POINTER},
        .description = "get function address from dll",
        .headers = {"windows.h", "libloaderapi.h"}
    },

    api_info{
        .name = "GetModuleHandleW",
        .module = "kernel32.dll",
        .api_category = api_info::category::LIBRARY_LOADING,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpModuleName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "module", .param_type = param_info::type::POINTER},
        .description = "get handle to loaded module",
        .related_apis = {"LoadLibraryW", "GetModuleFileName"},
        .headers = {"windows.h", "libloaderapi.h"}
    },

    api_info{
        .name = "GetModuleFileNameW",
        .module = "kernel32.dll",
        .api_category = api_info::category::LIBRARY_LOADING,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hModule", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
             {.name = "lpFilename",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "nSize", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "length", .param_type = param_info::type::SIZE},
        .description = "get fully qualified path of loaded module",
        .related_apis = {"GetModuleHandle", "LoadLibraryW"},
        .headers = {"windows.h", "libloaderapi.h"}
    },

    api_info{
        .name = "FreeLibrary",
        .module = "kernel32.dll",
        .api_category = api_info::category::LIBRARY_LOADING,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hLibModule",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "unload dll from process",
        .related_apis = {"LoadLibraryW", "GetProcAddress"},
        .headers = {"windows.h", "libloaderapi.h"}
    },

    // string conversion utilities
    api_info{
        .name = "MultiByteToWideChar",
        .module = "kernel32.dll",
        .api_category = api_info::category::STRING_MANIPULATION,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "CodePage",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "dwFlags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
             {.name = "lpMultiByteStr",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "cbMultiByte",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "lpWideCharStr",
              .param_type = param_info::type::WSTRING,
              .param_direction = param_info::direction::OUT},
             {.name = "cchWideChar",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "chars_written", .param_type = param_info::type::INTEGER},
        .description = "convert multibyte string to wide character string",
        .related_apis = {"WideCharToMultiByte"},
        .headers = {"windows.h", "stringapiset.h"}
    },

    api_info{
        .name = "WideCharToMultiByte",
        .module = "kernel32.dll",
        .api_category = api_info::category::STRING_MANIPULATION,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "CodePage",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "dwFlags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
             {.name = "lpWideCharStr",
              .param_type = param_info::type::WSTRING,
              .param_direction = param_info::direction::IN},
             {.name = "cchWideChar",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "lpMultiByteStr",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::OUT},
             {.name = "cbMultiByte",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "lpDefaultChar",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "lpUsedDefaultChar",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "chars_written", .param_type = param_info::type::INTEGER},
        .description = "convert wide character string to multibyte string",
        .related_apis = {"MultiByteToWideChar"},
        .headers = {"windows.h", "stringapiset.h"}
    },

    // === PHASE 1: MEMORY MANIPULATION & PROCESS INJECTION ===

    // process memory manipulation
    api_info{
        .name = "WriteProcessMemory",
        .module = "kernel32.dll",
        .api_category = api_info::category::MEMORY_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProcess", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpBaseAddress",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "lpBuffer", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::IN},
             {.name = "nSize", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
             {.name = "lpNumberOfBytesWritten",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "write data to process memory",
        .security_notes = {"code injection vector", "requires process_vm_write access", "common malware technique"},
        .related_apis = {"ReadProcessMemory", "VirtualAllocEx", "CreateRemoteThread"},
        .headers = {"windows.h", "memoryapi.h"}
    },

    api_info{
        .name = "ReadProcessMemory",
        .module = "kernel32.dll",
        .api_category = api_info::category::MEMORY_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProcess", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpBaseAddress",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "lpBuffer",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "nSize", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
             {.name = "lpNumberOfBytesRead",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "read data from process memory",
        .security_notes = {"memory dumping capability", "requires process_vm_read access"},
        .related_apis = {"WriteProcessMemory", "VirtualQueryEx"},
        .headers = {"windows.h", "memoryapi.h"}
    },

    api_info{
        .name = "VirtualAllocEx",
        .module = "kernel32.dll",
        .api_category = api_info::category::HEAP_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY) |
                 static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProcess", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpAddress",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "dwSize", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
             {.name = "flAllocationType",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "flProtect",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "baseAddress", .param_type = param_info::type::POINTER},
        .description = "allocate memory in remote process",
        .security_notes = {"code injection preparation", "common dll injection technique"},
        .related_apis = {"WriteProcessMemory", "CreateRemoteThread", "VirtualFreeEx"},
        .cleanup_api = "VirtualFreeEx",
        .headers = {"windows.h", "memoryapi.h"}
    },

    api_info{
        .name = "VirtualFreeEx",
        .module = "kernel32.dll",
        .api_category = api_info::category::HEAP_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FREES_MEMORY),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProcess", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpAddress",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "dwSize", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
             {.name = "dwFreeType",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "free memory in remote process",
        .related_apis = {"VirtualAllocEx", "WriteProcessMemory"},
        .headers = {"windows.h", "memoryapi.h"}
    },

    api_info{
        .name = "VirtualProtectEx",
        .module = "kernel32.dll",
        .api_category = api_info::category::MEMORY_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProcess", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpAddress",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "dwSize", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
             {.name = "flNewProtect",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "lpflOldProtect",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "change protection of remote process memory",
        .security_notes = {"code execution preparation", "common shellcode injection technique"},
        .related_apis = {"VirtualProtect", "WriteProcessMemory", "VirtualAllocEx"},
        .headers = {"windows.h", "memoryapi.h"}
    },

    api_info{
        .name = "VirtualQueryEx",
        .module = "kernel32.dll",
        .api_category = api_info::category::MEMORY_MANAGEMENT,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProcess", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpAddress",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "lpBuffer",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "dwLength", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "bytesReturned", .param_type = param_info::type::SIZE},
        .description = "get information about remote process memory",
        .related_apis = {"VirtualQuery", "ReadProcessMemory"},
        .headers = {"windows.h", "memoryapi.h"}
    },

    // thread injection
    api_info{
        .name = "CreateRemoteThread",
        .module = "kernel32.dll",
        .api_category = api_info::category::THREAD_CONTROL,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
                 static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProcess", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpThreadAttributes",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "dwStackSize",
              .param_type = param_info::type::SIZE,
              .param_direction = param_info::direction::IN},
             {.name = "lpStartAddress",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "lpParameter",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "dwCreationFlags",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "lpThreadId",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "threadHandle", .param_type = param_info::type::HANDLE},
        .description = "create thread in remote process",
        .security_notes = {"primary dll injection method", "requires create_thread access", "common malware technique"},
        .related_apis = {"WriteProcessMemory", "VirtualAllocEx", "LoadLibraryW"},
        .cleanup_api = "CloseHandle",
        .headers = {"windows.h", "processthreadsapi.h"}
    },

    api_info{
        .name = "QueueUserAPC",
        .module = "kernel32.dll",
        .api_category = api_info::category::THREAD_CONTROL,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE) |
                 static_cast<uint32_t>(api_info::behavior_flags::ASYNC),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "pfnAPC", .param_type = param_info::type::CALLBACK, .param_direction = param_info::direction::IN},
             {.name = "hThread", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "dwData", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "queue asynchronous procedure call to thread",
        .security_notes = {"apc injection technique", "executed when thread enters alertable state"},
        .related_apis = {"OpenThread", "SleepEx", "WaitForSingleObjectEx"},
        .headers = {"windows.h", "processthreadsapi.h"}
    },

    // === SYNCHRONIZATION PRIMITIVES ===

    // mutexes
    api_info{
        .name = "CreateMutexW",
        .module = "kernel32.dll",
        .api_category = api_info::category::MUTEX,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpMutexAttributes",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "bInitialOwner",
              .param_type = param_info::type::BOOLEAN,
              .param_direction = param_info::direction::IN},
             {.name = "lpName", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "mutexHandle", .param_type = param_info::type::HANDLE},
        .description = "create named or unnamed mutex object",
        .related_apis = {"OpenMutexW", "ReleaseMutex", "WaitForSingleObject"},
        .cleanup_api = "CloseHandle",
        .headers = {"windows.h", "synchapi.h"}
    },

    api_info{
        .name = "OpenMutexW",
        .module = "kernel32.dll",
        .api_category = api_info::category::MUTEX,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "dwDesiredAccess",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "bInheritHandle",
              .param_type = param_info::type::BOOLEAN,
              .param_direction = param_info::direction::IN},
             {.name = "lpName", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "mutexHandle", .param_type = param_info::type::HANDLE},
        .description = "open existing named mutex",
        .related_apis = {"CreateMutexW", "ReleaseMutex"},
        .cleanup_api = "CloseHandle",
        .headers = {"windows.h", "synchapi.h"}
    },

    api_info{
        .name = "ReleaseMutex",
        .module = "kernel32.dll",
        .api_category = api_info::category::MUTEX,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hMutex", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "release ownership of mutex",
        .related_apis = {"CreateMutexW", "WaitForSingleObject"},
        .headers = {"windows.h", "synchapi.h"}
    },

    // events
    api_info{
        .name = "CreateEventW",
        .module = "kernel32.dll",
        .api_category = api_info::category::EVENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpEventAttributes",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "bManualReset",
              .param_type = param_info::type::BOOLEAN,
              .param_direction = param_info::direction::IN},
             {.name = "bInitialState",
              .param_type = param_info::type::BOOLEAN,
              .param_direction = param_info::direction::IN},
             {.name = "lpName", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "eventHandle", .param_type = param_info::type::HANDLE},
        .description = "create named or unnamed event object",
        .related_apis = {"OpenEventW", "SetEvent", "ResetEvent"},
        .cleanup_api = "CloseHandle",
        .headers = {"windows.h", "synchapi.h"}
    },

    api_info{
        .name = "OpenEventW",
        .module = "kernel32.dll",
        .api_category = api_info::category::EVENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "dwDesiredAccess",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "bInheritHandle",
              .param_type = param_info::type::BOOLEAN,
              .param_direction = param_info::direction::IN},
             {.name = "lpName", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "eventHandle", .param_type = param_info::type::HANDLE},
        .description = "open existing named event",
        .related_apis = {"CreateEventW", "SetEvent", "ResetEvent"},

        .cleanup_api = "CloseHandle",
        .headers = {"windows.h", "synchapi.h"}
    },

    api_info{
        .name = "SetEvent",
        .module = "kernel32.dll",
        .api_category = api_info::category::EVENT,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hEvent", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "set event object to signaled state",
        .related_apis = {"CreateEventW", "ResetEvent", "WaitForSingleObject"},
        .headers = {"windows.h", "synchapi.h"}
    },

    api_info{
        .name = "ResetEvent",
        .module = "kernel32.dll",
        .api_category = api_info::category::EVENT,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hEvent", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "reset event object to non-signaled state",
        .related_apis = {"CreateEventW", "SetEvent", "WaitForSingleObject"},
        .headers = {"windows.h", "synchapi.h"}
    },

    // semaphores
    api_info{
        .name = "CreateSemaphoreW",
        .module = "kernel32.dll",
        .api_category = api_info::category::SEMAPHORE,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpSemaphoreAttributes",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "lInitialCount",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "lMaximumCount",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "lpName", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "semaphoreHandle", .param_type = param_info::type::HANDLE},
        .description = "create named or unnamed semaphore object",
        .related_apis = {"OpenSemaphoreW", "ReleaseSemaphore", "WaitForSingleObject"},

        .cleanup_api = "CloseHandle",
        .headers = {"windows.h", "synchapi.h"}
    },

    api_info{
        .name = "OpenSemaphoreW",
        .module = "kernel32.dll",
        .api_category = api_info::category::SEMAPHORE,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "dwDesiredAccess",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "bInheritHandle",
              .param_type = param_info::type::BOOLEAN,
              .param_direction = param_info::direction::IN},
             {.name = "lpName", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "semaphoreHandle", .param_type = param_info::type::HANDLE},
        .description = "open existing named semaphore",
        .related_apis = {"CreateSemaphoreW", "ReleaseSemaphore"},

        .cleanup_api = "CloseHandle",
        .headers = {"windows.h", "synchapi.h"}
    },

    api_info{
        .name = "ReleaseSemaphore",
        .module = "kernel32.dll",
        .api_category = api_info::category::SEMAPHORE,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hSemaphore",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "lReleaseCount",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "lpPreviousCount",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "increase semaphore count",
        .related_apis = {"CreateSemaphoreW", "WaitForSingleObject"},
        .headers = {"windows.h", "synchapi.h"}
    },

    // wait functions
    api_info{
        .name = "WaitForSingleObject",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYNCHRONIZATION,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hHandle", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "dwMilliseconds",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "waitResult", .param_type = param_info::type::INTEGER},
        .description = "wait for object to become signaled",
        .related_apis = {"WaitForMultipleObjects", "WaitForSingleObjectEx"},
        .headers = {"windows.h", "synchapi.h"}
    },

    api_info{
        .name = "WaitForMultipleObjects",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYNCHRONIZATION,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "nCount", .param_type = param_info::type::COUNT, .param_direction = param_info::direction::IN},
             {.name = "lpHandles",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "bWaitAll",
              .param_type = param_info::type::BOOLEAN,
              .param_direction = param_info::direction::IN},
             {.name = "dwMilliseconds",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "waitResult", .param_type = param_info::type::INTEGER},
        .description = "wait for multiple objects to become signaled",
        .related_apis = {"WaitForSingleObject", "WaitForMultipleObjectsEx"},
        .headers = {"windows.h", "synchapi.h"}
    },

    // === IPC - NAMED PIPES ===

    api_info{
        .name = "CreateNamedPipeW",
        .module = "kernel32.dll",
        .api_category = api_info::category::PIPE,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpName", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
             {.name = "dwOpenMode",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "dwPipeMode",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "nMaxInstances",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "nOutBufferSize",
              .param_type = param_info::type::SIZE,
              .param_direction = param_info::direction::IN},
             {.name = "nInBufferSize",
              .param_type = param_info::type::SIZE,
              .param_direction = param_info::direction::IN},
             {.name = "nDefaultTimeOut",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "lpSecurityAttributes",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "pipeHandle", .param_type = param_info::type::HANDLE},
        .description = "create named pipe server",
        .security_notes = {"ipc communication vector", "can be used for privilege escalation"},
        .related_apis = {"ConnectNamedPipe", "CreateFileW", "ReadFile", "WriteFile"},
        .cleanup_api = "CloseHandle",
        .headers = {"windows.h", "namedpipeapi.h"}
    },

    api_info{
        .name = "ConnectNamedPipe",
        .module = "kernel32.dll",
        .api_category = api_info::category::PIPE,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hNamedPipe",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "lpOverlapped",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "wait for client to connect to named pipe",
        .related_apis = {"CreateNamedPipeW", "DisconnectNamedPipe", "PeekNamedPipe"},
        .headers = {"windows.h", "namedpipeapi.h"}
    },

    api_info{
        .name = "DisconnectNamedPipe",
        .module = "kernel32.dll",
        .api_category = api_info::category::PIPE,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hNamedPipe",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "disconnect client from named pipe",
        .related_apis = {"ConnectNamedPipe", "CreateNamedPipeW"},
        .headers = {"windows.h", "namedpipeapi.h"}
    },

    api_info{
        .name = "PeekNamedPipe",
        .module = "kernel32.dll",
        .api_category = api_info::category::PIPE,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hNamedPipe",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "lpBuffer",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "nBufferSize",
              .param_type = param_info::type::SIZE,
              .param_direction = param_info::direction::IN},
             {.name = "lpBytesRead",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "lpTotalBytesAvail",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "lpBytesLeftThisMessage",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "peek at data in named pipe without removing it",
        .related_apis = {"ReadFile", "WriteFile", "ConnectNamedPipe"},
        .headers = {"windows.h", "namedpipeapi.h"}
    },

    // === IPC - MAILSLOTS ===

    api_info{
        .name = "CreateMailslotW",
        .module = "kernel32.dll",
        .api_category = api_info::category::IPC,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpName", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
             {.name = "nMaxMessageSize",
              .param_type = param_info::type::SIZE,
              .param_direction = param_info::direction::IN},
             {.name = "lReadTimeout",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "lpSecurityAttributes",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "mailslotHandle", .param_type = param_info::type::HANDLE},
        .description = "create mailslot for one-way ipc",
        .related_apis = {"GetMailslotInfo", "ReadFile", "WriteFile"},

        .cleanup_api = "CloseHandle",
        .headers = {"windows.h", "winbase.h"}
    },

    api_info{
        .name = "GetMailslotInfo",
        .module = "kernel32.dll",
        .api_category = api_info::category::IPC,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hMailslot",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "lpMaxMessageSize",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "lpNextSize",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "lpMessageCount",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "lpReadTimeout",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "get mailslot information",
        .related_apis = {"CreateMailslotW", "SetMailslotInfo"},
        .headers = {"windows.h", "winbase.h"}
    },

    // === SHARED MEMORY ===

    api_info{
        .name = "OpenFileMappingW",
        .module = "kernel32.dll",
        .api_category = api_info::category::SHARED_MEMORY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "dwDesiredAccess",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "bInheritHandle",
              .param_type = param_info::type::BOOLEAN,
              .param_direction = param_info::direction::IN},
             {.name = "lpName", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "mappingHandle", .param_type = param_info::type::HANDLE},
        .description = "open existing named file mapping object",
        .related_apis = {"CreateFileMappingW", "MapViewOfFile", "UnmapViewOfFile"},

        .cleanup_api = "CloseHandle",
        .headers = {"windows.h", "memoryapi.h"}
    },

    // === PHASE 3: FILE SYSTEM & PROCESS ANALYSIS ===

    // file system operations
    api_info{
        .name = "GetFileAttributesW",
        .module = "kernel32.dll",
        .api_category = api_info::category::FILE_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpFileName",
              .param_type = param_info::type::PATH,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "attributes", .param_type = param_info::type::FLAGS},
        .description = "retrieve file system attributes of file or directory",
        .related_apis = {"SetFileAttributesW", "GetFileAttributesExW"},
        .headers = {"windows.h", "fileapi.h"}
    },

    api_info{
        .name = "SetFileAttributesW",
        .module = "kernel32.dll",
        .api_category = api_info::category::FILE_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpFileName", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN},
             {.name = "dwFileAttributes",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "set attributes for file or directory",
        .security_notes = {"file hiding capability", "timestamp manipulation preparation"},
        .related_apis = {"GetFileAttributesW", "SetFileTime"},
        .headers = {"windows.h", "fileapi.h"}
    },

    api_info{
        .name = "GetFileTime",
        .module = "kernel32.dll",
        .api_category = api_info::category::FILE_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hFile", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpCreationTime",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "lpLastAccessTime",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "lpLastWriteTime",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve file time stamps",
        .related_apis = {"SetFileTime", "GetFileAttributesExW"},
        .headers = {"windows.h", "fileapi.h"}
    },

    api_info{
        .name = "SetFileTime",
        .module = "kernel32.dll",
        .api_category = api_info::category::FILE_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE) |
                 static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hFile", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpCreationTime",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "lpLastAccessTime",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "lpLastWriteTime",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "set file time stamps",
        .security_notes = {"timestamp manipulation", "anti-forensics technique", "file timestomping"},
        .related_apis = {"GetFileTime", "SetFileAttributesW"},
        .headers = {"windows.h", "fileapi.h"}
    },

    api_info{
        .name = "FindFirstFileW",
        .module = "kernel32.dll",
        .api_category = api_info::category::FILE_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
                 static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpFileName", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN},
             {.name = "lpFindFileData",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "searchHandle", .param_type = param_info::type::HANDLE},
        .description = "search directory for file or subdirectory",
        .security_notes = {"directory enumeration capability", "file discovery"},
        .related_apis = {"FindNextFileW", "FindClose", "FindFirstFileExW"},
        .cleanup_api = "FindClose",
        .headers = {"windows.h", "fileapi.h"}
    },

    api_info{
        .name = "FindNextFileW",
        .module = "kernel32.dll",
        .api_category = api_info::category::FILE_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hFindFile",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "lpFindFileData",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "continue file search from previous call",
        .related_apis = {"FindFirstFileW", "FindClose"},
        .headers = {"windows.h", "fileapi.h"}
    },

    api_info{
        .name = "FindClose",
        .module = "kernel32.dll",
        .api_category = api_info::category::FILE_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::CLOSES_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hFindFile",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "close file search handle",
        .related_apis = {"FindFirstFileW", "FindNextFileW"},
        .headers = {"windows.h", "fileapi.h"}
    },

    api_info{
        .name = "CreateDirectoryW",
        .module = "kernel32.dll",
        .api_category = api_info::category::FILE_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpPathName", .param_type = param_info::type::PATH, .param_direction = param_info::direction::IN},
             {.name = "lpSecurityAttributes",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "create new directory",
        .security_notes = {"directory creation for persistence", "file system modification"},
        .related_apis = {"RemoveDirectoryW", "CreateDirectoryExW"},
        .headers = {"windows.h", "fileapi.h"}
    },

    api_info{
        .name = "RemoveDirectoryW",
        .module = "kernel32.dll",
        .api_category = api_info::category::FILE_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpPathName",
              .param_type = param_info::type::PATH,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "delete existing empty directory",
        .security_notes = {"directory cleanup", "anti-forensics technique"},
        .related_apis = {"CreateDirectoryW", "DeleteFileW"},
        .headers = {"windows.h", "fileapi.h"}
    },

    api_info{
        .name = "DeleteFileW",
        .module = "kernel32.dll",
        .api_category = api_info::category::FILE_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE) |
                 static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpFileName",
              .param_type = param_info::type::PATH,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "delete existing file",
        .security_notes = {"file deletion capability", "evidence destruction", "anti-forensics"},
        .related_apis = {"CreateFileW", "MoveFileW", "RemoveDirectoryW"},
        .headers = {"windows.h", "fileapi.h"}
    },

    api_info{
        .name = "MoveFileW",
        .module = "kernel32.dll",
        .api_category = api_info::category::FILE_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpExistingFileName",
              .param_type = param_info::type::PATH,
              .param_direction = param_info::direction::IN},
             {.name = "lpNewFileName",
              .param_type = param_info::type::PATH,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "move or rename file or directory",
        .related_apis = {"CopyFileW", "MoveFileExW", "DeleteFileW"},
        .headers = {"windows.h", "winbase.h"}
    },

    api_info{
        .name = "CopyFileW",
        .module = "kernel32.dll",
        .api_category = api_info::category::FILE_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpExistingFileName",
              .param_type = param_info::type::PATH,
              .param_direction = param_info::direction::IN},
             {.name = "lpNewFileName",
              .param_type = param_info::type::PATH,
              .param_direction = param_info::direction::IN},
             {.name = "bFailIfExists",
              .param_type = param_info::type::BOOLEAN,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "copy existing file to new file",
        .security_notes = {"file duplication capability", "backup creation"},
        .related_apis = {"MoveFileW", "CopyFileExW"},
        .headers = {"windows.h", "winbase.h"}
    },

    // volume and drive information
    api_info{
        .name = "GetVolumeInformationW",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpRootPathName",
              .param_type = param_info::type::PATH,
              .param_direction = param_info::direction::IN},
             {.name = "lpVolumeNameBuffer",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "nVolumeNameSize",
              .param_type = param_info::type::SIZE,
              .param_direction = param_info::direction::IN},
             {.name = "lpVolumeSerialNumber",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "lpMaximumComponentLength",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "lpFileSystemFlags",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "lpFileSystemNameBuffer",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "nFileSystemNameSize",
              .param_type = param_info::type::SIZE,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve volume information",
        .related_apis = {"GetDiskFreeSpaceW", "GetLogicalDrives"},
        .headers = {"windows.h", "fileapi.h"}
    },

    api_info{
        .name = "GetDiskFreeSpaceW",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpRootPathName",
              .param_type = param_info::type::PATH,
              .param_direction = param_info::direction::IN},
             {.name = "lpSectorsPerCluster",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "lpBytesPerSector",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "lpNumberOfFreeClusters",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "lpTotalNumberOfClusters",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve disk space information",
        .related_apis = {"GetVolumeInformationW", "GetDiskFreeSpaceExW"},
        .headers = {"windows.h", "fileapi.h"}
    },

    api_info{
        .name = "GetLogicalDrives",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters = {},
        .return_value = {.name = "drivesBitmask", .param_type = param_info::type::FLAGS},
        .description = "retrieve bitmask of logical drives",
        .related_apis = {"GetLogicalDriveStringsW", "GetDriveTypeW"},
        .headers = {"windows.h", "fileapi.h"}
    },

    api_info{
        .name = "GetDriveTypeW",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpRootPathName",
              .param_type = param_info::type::PATH,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "driveType", .param_type = param_info::type::INTEGER},
        .description = "determine drive type",
        .related_apis = {"GetLogicalDrives", "GetVolumeInformationW"},
        .headers = {"windows.h", "fileapi.h"}
    },

    // === TOOLHELP32 SNAPSHOTS ===

    api_info{
        .name = "CreateToolhelp32Snapshot",
        .module = "kernel32.dll",
        .api_category = api_info::category::PROCESS_CONTROL,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "dwFlags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
             {.name = "th32ProcessID",
              .param_type = param_info::type::PROCESS_ID,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "snapshotHandle", .param_type = param_info::type::HANDLE},
        .description = "take snapshot of processes, threads, modules, and heaps",
        .security_notes = {"system enumeration capability", "process discovery", "malware analysis tool"},
        .related_apis = {"Process32FirstW", "Thread32First", "Module32FirstW"},
        .cleanup_api = "CloseHandle",
        .headers = {"windows.h", "tlhelp32.h"}
    },

    api_info{
        .name = "Process32FirstW",
        .module = "kernel32.dll",
        .api_category = api_info::category::PROCESS_CONTROL,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hSnapshot",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "lppe", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve first process from snapshot",
        .security_notes = {"process enumeration", "system discovery"},
        .related_apis = {"CreateToolhelp32Snapshot", "Process32NextW"},
        .headers = {"windows.h", "tlhelp32.h"}
    },

    api_info{
        .name = "Process32NextW",
        .module = "kernel32.dll",
        .api_category = api_info::category::PROCESS_CONTROL,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hSnapshot",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "lppe", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve next process from snapshot",
        .related_apis = {"Process32FirstW", "CreateToolhelp32Snapshot"},
        .headers = {"windows.h", "tlhelp32.h"}
    },

    api_info{
        .name = "Thread32First",
        .module = "kernel32.dll",
        .api_category = api_info::category::THREAD_CONTROL,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hSnapshot",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "lpte", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve first thread from snapshot",
        .security_notes = {"thread enumeration", "injection target discovery"},
        .related_apis = {"CreateToolhelp32Snapshot", "Thread32Next", "OpenThread"},
        .headers = {"windows.h", "tlhelp32.h"}
    },

    api_info{
        .name = "Thread32Next",
        .module = "kernel32.dll",
        .api_category = api_info::category::THREAD_CONTROL,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hSnapshot",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "lpte", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve next thread from snapshot",
        .related_apis = {"Thread32First", "CreateToolhelp32Snapshot"},
        .headers = {"windows.h", "tlhelp32.h"}
    },

    api_info{
        .name = "Module32FirstW",
        .module = "kernel32.dll",
        .api_category = api_info::category::LIBRARY_LOADING,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hSnapshot",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "lpme", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve first module from snapshot",
        .security_notes = {"module enumeration", "dll discovery"},
        .related_apis = {"CreateToolhelp32Snapshot", "Module32NextW"},
        .headers = {"windows.h", "tlhelp32.h"}
    },

    api_info{
        .name = "Module32NextW",
        .module = "kernel32.dll",
        .api_category = api_info::category::LIBRARY_LOADING,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hSnapshot",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "lpme", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve next module from snapshot",
        .related_apis = {"Module32FirstW", "CreateToolhelp32Snapshot"},
        .headers = {"windows.h", "tlhelp32.h"}
    },

    // additional thread operations
    api_info{
        .name = "OpenThread",
        .module = "kernel32.dll",
        .api_category = api_info::category::THREAD_CONTROL,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
                 static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "dwDesiredAccess",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "bInheritHandle",
              .param_type = param_info::type::BOOLEAN,
              .param_direction = param_info::direction::IN},
             {.name = "dwThreadId",
              .param_type = param_info::type::THREAD_ID,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "threadHandle", .param_type = param_info::type::HANDLE},
        .description = "open existing thread object",
        .security_notes = {"thread access for injection", "apc injection preparation"},
        .related_apis = {"GetCurrentThread", "CreateThread", "QueueUserAPC"},
        .cleanup_api = "CloseHandle",
        .headers = {"windows.h", "processthreadsapi.h"}
    },

    api_info{
        .name = "SuspendThread",
        .module = "kernel32.dll",
        .api_category = api_info::category::THREAD_CONTROL,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hThread", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "previousSuspendCount", .param_type = param_info::type::INTEGER},
        .description = "suspend specified thread",
        .security_notes = {"thread suspension for analysis", "process hollowing technique"},
        .related_apis = {"ResumeThread", "OpenThread", "GetThreadContext"},
        .headers = {"windows.h", "processthreadsapi.h"}
    },

    api_info{
        .name = "ResumeThread",
        .module = "kernel32.dll",
        .api_category = api_info::category::THREAD_CONTROL,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hThread", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "previousSuspendCount", .param_type = param_info::type::INTEGER},
        .description = "resume suspended thread",
        .related_apis = {"SuspendThread", "CreateThread"},
        .headers = {"windows.h", "processthreadsapi.h"}
    },

    api_info{
        .name = "GetThreadContext",
        .module = "kernel32.dll",
        .api_category = api_info::category::THREAD_CONTROL,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hThread", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpContext",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve thread context (registers)",
        .security_notes = {"register inspection", "process hollowing analysis"},
        .related_apis = {"SetThreadContext", "SuspendThread", "OpenThread"},
        .headers = {"windows.h", "processthreadsapi.h"}
    },

    api_info{
        .name = "SetThreadContext",
        .module = "kernel32.dll",
        .api_category = api_info::category::THREAD_CONTROL,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hThread", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpContext",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "set thread context (registers)",
        .security_notes = {"execution redirection", "process hollowing technique", "injection method"},
        .related_apis = {"GetThreadContext", "SuspendThread", "ResumeThread"},
        .headers = {"windows.h", "processthreadsapi.h"}
    },

    // === PHASE 4: ANTI-ANALYSIS & EVASION DETECTION ===

    // timing and delay functions for sandbox detection
    api_info{
        .name = "GetTickCount",
        .module = "kernel32.dll",
        .api_category = api_info::category::TIME,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters = {},
        .return_value = {.name = "milliseconds", .param_type = param_info::type::INTEGER},
        .description = "retrieve milliseconds since system start",
        .security_notes = {"timing analysis for sandbox detection", "execution delay measurement"},
        .related_apis = {"GetTickCount64", "QueryPerformanceCounter", "timeGetTime"},
        .headers = {"windows.h", "sysinfoapi.h"}
    },

    api_info{
        .name = "GetTickCount64",
        .module = "kernel32.dll",
        .api_category = api_info::category::TIME,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters = {},
        .return_value = {.name = "milliseconds", .param_type = param_info::type::INTEGER},
        .description = "retrieve 64-bit milliseconds since system start",
        .security_notes = {"high-resolution timing for evasion", "sandbox detection technique"},
        .related_apis = {"GetTickCount", "QueryPerformanceCounter"},
        .headers = {"windows.h", "sysinfoapi.h"}
    },

    api_info{
        .name = "QueryPerformanceCounter",
        .module = "kernel32.dll",
        .api_category = api_info::category::TIME,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpPerformanceCount",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve high-resolution performance counter",
        .security_notes = {"precise timing for anti-debugging", "rdtsc alternative"},
        .related_apis = {"QueryPerformanceFrequency", "GetTickCount64"},
        .headers = {"windows.h", "profileapi.h"}
    },

    api_info{
        .name = "QueryPerformanceFrequency",
        .module = "kernel32.dll",
        .api_category = api_info::category::TIME,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpFrequency",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve performance counter frequency",
        .related_apis = {"QueryPerformanceCounter"},
        .headers = {"windows.h", "profileapi.h"}
    },

    api_info{
        .name = "Sleep",
        .module = "kernel32.dll",
        .api_category = api_info::category::TIME,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "dwMilliseconds",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "void", .param_type = param_info::type::VOID},
        .description = "suspend execution for specified interval",
        .security_notes = {"delay execution for analysis evasion", "sandbox timeout technique"},
        .related_apis = {"SleepEx", "WaitForSingleObject"},
        .headers = {"windows.h", "synchapi.h"}
    },

    api_info{
        .name = "SleepEx",
        .module = "kernel32.dll",
        .api_category = api_info::category::TIME,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "dwMilliseconds",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "bAlertable",
              .param_type = param_info::type::BOOLEAN,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
        .description = "suspend execution with alertable state",
        .security_notes = {"apc-aware sleep for evasion", "alertable delay technique"},
        .related_apis = {"Sleep", "QueueUserAPC", "WaitForSingleObjectEx"},
        .headers = {"windows.h", "synchapi.h"}
    },

    // debugging detection functions
    api_info{
        .name = "IsDebuggerPresent",
        .module = "kernel32.dll",
        .api_category = api_info::category::SECURITY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters = {},
        .return_value = {.name = "debuggerPresent", .param_type = param_info::type::BOOLEAN},
        .description = "determine if user-mode debugger is present",
        .security_notes = {"anti-debugging check", "malware evasion technique"},
        .related_apis = {"CheckRemoteDebuggerPresent", "OutputDebugStringW"},
        .headers = {"windows.h", "debugapi.h"}
    },

    api_info{
        .name = "CheckRemoteDebuggerPresent",
        .module = "kernel32.dll",
        .api_category = api_info::category::SECURITY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProcess", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "pbDebuggerPresent",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "determine if debugger is attached to process",
        .security_notes = {"remote debugging detection", "anti-analysis technique"},
        .related_apis = {"IsDebuggerPresent", "OpenProcess"},
        .headers = {"windows.h", "debugapi.h"}
    },

    api_info{
        .name = "OutputDebugStringW",
        .module = "kernel32.dll",
        .api_category = api_info::category::SECURITY,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpOutputString",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "void", .param_type = param_info::type::VOID},
        .description = "send string to debugger for display",
        .security_notes = {"debugger detection via exception", "anti-debugging technique"},
        .related_apis = {"IsDebuggerPresent", "SetLastError"},
        .headers = {"windows.h", "debugapi.h"}
    },

    // system information for vm/sandbox detection
    api_info{
        .name = "GetUserNameW",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpBuffer",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "pcbBuffer",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve current user name",
        .security_notes = {"user profiling for sandbox detection", "common sandbox usernames"},
        .related_apis = {"GetComputerNameW", "GetEnvironmentVariableW"},
        .headers = {"windows.h", "winbase.h"}
    },

    api_info{
        .name = "GetEnvironmentVariableW",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpName", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
             {.name = "lpBuffer",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "nSize", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "length", .param_type = param_info::type::SIZE},
        .description = "retrieve environment variable value",
        .security_notes = {"environment fingerprinting", "sandbox detection via env vars"},
        .related_apis = {"SetEnvironmentVariableW", "GetEnvironmentStringsW"},
        .headers = {"windows.h", "processenv.h"}
    },

    api_info{
        .name = "SetEnvironmentVariableW",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpName", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
             {.name = "lpValue", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "set environment variable value",
        .related_apis = {"GetEnvironmentVariableW"},
        .headers = {"windows.h", "processenv.h"}
    },

    api_info{
        .name = "GetCommandLineW",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters = {},
        .return_value = {.name = "commandLine", .param_type = param_info::type::STRING},
        .description = "retrieve command line string for current process",
        .security_notes = {"argument analysis for detection", "execution context fingerprinting"},
        .related_apis = {"GetEnvironmentVariableW", "GetModuleFileNameW"},
        .headers = {"windows.h", "processenv.h"}
    },

    api_info{
        .name = "GetVersionExW",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::DEPRECATED),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpVersionInformation",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve operating system version information",
        .security_notes = {"os fingerprinting for evasion", "version-specific exploits"},
        .related_apis = {"GetSystemInfo", "RtlGetVersion"},
        .headers = {"windows.h", "sysinfoapi.h"}
    },

    api_info{
        .name = "GetNativeSystemInfo",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpSystemInfo",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "void", .param_type = param_info::type::VOID},
        .description = "retrieve native system information",
        .security_notes = {"architecture detection", "wow64 environment analysis"},
        .related_apis = {"GetSystemInfo", "IsWow64Process"},
        .headers = {"windows.h", "sysinfoapi.h"}
    },

    api_info{
        .name = "IsWow64Process",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProcess", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "Wow64Process",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "determine if process is running under wow64",
        .security_notes = {"architecture detection", "32-bit on 64-bit detection"},
        .related_apis = {"GetNativeSystemInfo", "GetSystemInfo"},
        .headers = {"windows.h", "wow64apiset.h"}
    },

    // locale and region detection
    api_info{
        .name = "GetLocaleInfoW",
        .module = "kernel32.dll",
        .api_category = api_info::category::LOCALE,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "Locale", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "LCType", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "lpLCData",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "cchData",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "length", .param_type = param_info::type::INTEGER},
        .description = "retrieve locale-specific information",
        .security_notes = {"geographic targeting", "locale-based evasion"},
        .related_apis = {"GetSystemDefaultLCID", "GetUserDefaultLCID"},
        .headers = {"windows.h", "winnls.h"}
    },

    api_info{
        .name = "GetSystemDefaultLCID",
        .module = "kernel32.dll",
        .api_category = api_info::category::LOCALE,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters = {},
        .return_value = {.name = "lcid", .param_type = param_info::type::INTEGER},
        .description = "retrieve system default locale identifier",
        .security_notes = {"system locale fingerprinting", "regional targeting"},
        .related_apis = {"GetLocaleInfoW", "GetUserDefaultLCID"},
        .headers = {"windows.h", "winnls.h"}
    },

    api_info{
        .name = "GetTimeZoneInformation",
        .module = "kernel32.dll",
        .api_category = api_info::category::TIME,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpTimeZoneInformation",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
        .description = "retrieve current time zone settings",
        .security_notes = {"geographic location inference", "timezone-based targeting"},
        .related_apis = {"GetSystemTime", "GetLocalTime"},
        .headers = {"windows.h", "timezoneapi.h"}
    },

    // cpu information for vm detection
    api_info{
        .name = "GetLogicalProcessorInformation",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "Buffer", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::OUT},
             {.name = "ReturnedLength",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve logical processor and cache information",
        .security_notes = {"cpu core detection for vm analysis", "hardware fingerprinting"},
        .related_apis = {"GetSystemInfo", "GetLogicalProcessorInformationEx"},
        .headers = {"windows.h", "sysinfoapi.h"}
    },

    // memory status for vm detection
    api_info{
        .name = "GlobalMemoryStatusEx",
        .module = "kernel32.dll",
        .api_category = api_info::category::MEMORY_MANAGEMENT,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpBuffer",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve extended memory status",
        .security_notes = {"memory size detection for vm analysis", "low memory sandbox detection"},
        .related_apis = {"GetSystemInfo", "VirtualQuery"},
        .headers = {"windows.h", "sysinfoapi.h"}
    },

    // file system detection
    api_info{
        .name = "GetTempPathW",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "nBufferLength",
              .param_type = param_info::type::SIZE,
              .param_direction = param_info::direction::IN},
             {.name = "lpBuffer",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "length", .param_type = param_info::type::SIZE},
        .description = "retrieve temporary file path",
        .security_notes = {"temp directory analysis", "sandbox temp path detection"},
        .related_apis = {"GetWindowsDirectoryW", "GetSystemDirectoryW"},
        .headers = {"windows.h", "fileapi.h"}
    },

    api_info{
        .name = "GetWindowsDirectoryW",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpBuffer",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "uSize", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "length", .param_type = param_info::type::SIZE},
        .description = "retrieve windows directory path",
        .security_notes = {"system directory analysis", "installation path detection"},
        .related_apis = {"GetSystemDirectoryW", "GetTempPathW"},
        .headers = {"windows.h", "sysinfoapi.h"}
    },

    api_info{
        .name = "GetSystemDirectoryW",
        .module = "kernel32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpBuffer",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "uSize", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "length", .param_type = param_info::type::SIZE},
        .description = "retrieve system directory path",
        .related_apis = {"GetWindowsDirectoryW", "GetSystemWow64DirectoryW"},
        .headers = {"windows.h", "sysinfoapi.h"}
    },

    // === REGISTRY MANIPULATION APIs ===

    api_info{
        .name = "RegOpenKeyExW",
        .module = "kernel32.dll",
        .api_category = api_info::category::REGISTRY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
                 static_cast<uint32_t>(api_info::behavior_flags::REGISTRY_ACCESS),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hKey", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpSubKey", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
             {.name = "ulOptions", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
             {.name = "samDesired",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "phkResult",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "open registry key",
        .security_notes = {"registry access", "system configuration modification"},
        .related_apis = {"RegCreateKeyExW", "RegCloseKey", "RegQueryValueExW"},
        .cleanup_api = "RegCloseKey",
        .headers = {"windows.h", "winreg.h"}
    },

    api_info{
        .name = "RegCreateKeyExW",
        .module = "kernel32.dll",
        .api_category = api_info::category::REGISTRY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
                 static_cast<uint32_t>(api_info::behavior_flags::REGISTRY_ACCESS) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hKey", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpSubKey", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
             {.name = "Reserved",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "lpClass", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
             {.name = "dwOptions", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
             {.name = "samDesired",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "lpSecurityAttributes",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "phkResult",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "lpdwDisposition",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "create or open registry key",
        .security_notes = {"registry modification", "persistence mechanism", "system configuration change"},
        .related_apis = {"RegOpenKeyExW", "RegSetValueExW", "RegDeleteKeyW"},
        .cleanup_api = "RegCloseKey",
        .headers = {"windows.h", "winreg.h"}
    },

    api_info{
        .name = "RegSetValueExW",
        .module = "kernel32.dll",
        .api_category = api_info::category::REGISTRY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::REGISTRY_ACCESS) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hKey", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpValueName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "Reserved",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "dwType", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
             {.name = "lpData", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::IN},
             {.name = "cbData", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "set registry value",
        .security_notes = {"registry modification", "persistence mechanism", "autostart configuration"},
        .related_apis = {"RegQueryValueExW", "RegDeleteValueW", "RegCreateKeyExW"},
        .headers = {"windows.h", "winreg.h"}
    },

    api_info{
        .name = "RegQueryValueExW",
        .module = "kernel32.dll",
        .api_category = api_info::category::REGISTRY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::REGISTRY_ACCESS),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hKey", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpValueName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "lpReserved",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "lpType", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
             {.name = "lpData", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::OUT},
             {.name = "lpcbData",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "query registry value",
        .security_notes = {"registry inspection", "system configuration analysis"},
        .related_apis = {"RegSetValueExW", "RegEnumValueW", "RegOpenKeyExW"},
        .headers = {"windows.h", "winreg.h"}
    },

    api_info{
        .name = "RegDeleteKeyW",
        .module = "kernel32.dll",
        .api_category = api_info::category::REGISTRY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::REGISTRY_ACCESS) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hKey", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpSubKey",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "delete registry key",
        .security_notes = {"registry cleanup", "evidence removal", "system modification"},
        .related_apis = {"RegCreateKeyExW", "RegDeleteValueW", "RegDeleteTreeW"},
        .headers = {"windows.h", "winreg.h"}
    },

    api_info{
        .name = "RegDeleteValueW",
        .module = "kernel32.dll",
        .api_category = api_info::category::REGISTRY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::REGISTRY_ACCESS) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hKey", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpValueName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "delete registry value",
        .security_notes = {"registry cleanup", "configuration removal"},
        .related_apis = {"RegSetValueExW", "RegDeleteKeyW", "RegQueryValueExW"},
        .headers = {"windows.h", "winreg.h"}
    },

    api_info{
        .name = "RegCloseKey",
        .module = "kernel32.dll",
        .api_category = api_info::category::REGISTRY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::CLOSES_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hKey", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "close registry key handle",
        .related_apis = {"RegOpenKeyExW", "RegCreateKeyExW"},
        .headers = {"windows.h", "winreg.h"}
    },

    api_info{
        .name = "RegEnumKeyExW",
        .module = "kernel32.dll",
        .api_category = api_info::category::REGISTRY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::REGISTRY_ACCESS),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hKey", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "dwIndex", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "lpName", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::OUT},
             {.name = "lpcchName",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT},
             {.name = "lpReserved",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "lpClass", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::OUT},
             {.name = "lpcchClass",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT},
             {.name = "lpftLastWriteTime",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "enumerate registry subkeys",
        .security_notes = {"registry discovery", "system configuration enumeration"},
        .related_apis = {"RegEnumValueW", "RegOpenKeyExW", "RegQueryInfoKeyW"},
        .headers = {"windows.h", "winreg.h"}
    },

    api_info{
        .name = "RegEnumValueW",
        .module = "kernel32.dll",
        .api_category = api_info::category::REGISTRY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::REGISTRY_ACCESS),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hKey", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "dwIndex", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "lpValueName",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "lpcchValueName",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT},
             {.name = "lpReserved",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "lpType", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
             {.name = "lpData", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::OUT},
             {.name = "lpcbData",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "enumerate registry values",
        .security_notes = {"registry discovery", "value enumeration"},
        .related_apis = {"RegEnumKeyExW", "RegQueryValueExW", "RegOpenKeyExW"},
        .headers = {"windows.h", "winreg.h"}
    }
};

#undef WINDOWS_API_CONVENTION

} // namespace w1::abi::apis::windows
```

`src/w1tn3ss/abi/apis/windows/ntdll_apis.hpp`:

```hpp
#pragma once

#include "abi/api_knowledge_db.hpp"
#include <vector>

namespace w1::abi::apis::windows {

// determine windows calling convention based on architecture
#if defined(_M_X64) || defined(__x86_64__)
#define WINDOWS_API_CONVENTION calling_convention_id::X86_64_MICROSOFT
#elif defined(_M_IX86) || defined(__i386__)
#define WINDOWS_API_CONVENTION calling_convention_id::X86_STDCALL
#else
#define WINDOWS_API_CONVENTION calling_convention_id::UNKNOWN
#endif

/**
 * @brief ntdll.dll api definitions
 *
 * covers native nt api layer:
 * - native file operations
 * - native memory management
 * - native process/thread operations
 * - native registry operations
 * - low-level system services
 *
 * note: these are undocumented internal apis that may change between windows versions
 */

static const std::vector<api_info> windows_ntdll_apis = {
    // native file operations
    api_info{
        .name = "NtCreateFile",
        .module = "ntdll.dll",
        .api_category = api_info::category::FILE_IO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "FileHandle",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "DesiredAccess",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "ObjectAttributes",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "IoStatusBlock",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "AllocationSize",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "FileAttributes",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "ShareAccess",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "CreateDisposition",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "CreateOptions",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "EaBuffer",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "EaLength", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "native file creation",
        .headers = {"ntddk.h"}
    },

    api_info{
        .name = "NtReadFile",
        .module = "ntdll.dll",
        .api_category = api_info::category::FILE_IO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "FileHandle",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "Event", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "ApcRoutine",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "ApcContext",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "IoStatusBlock",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "Buffer", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::OUT},
             {.name = "Length", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
             {.name = "ByteOffset",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "Key", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "native file read operation",
        .headers = {"ntddk.h"}
    },

    api_info{
        .name = "NtWriteFile",
        .module = "ntdll.dll",
        .api_category = api_info::category::FILE_IO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "FileHandle",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "Event", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "ApcRoutine",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "ApcContext",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "IoStatusBlock",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "Buffer", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::IN},
             {.name = "Length", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
             {.name = "ByteOffset",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "Key", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "native file write operation",
        .headers = {"ntddk.h"}
    },

    // native memory management
    api_info{
        .name = "NtAllocateVirtualMemory",
        .module = "ntdll.dll",
        .api_category = api_info::category::HEAP_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "ProcessHandle",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "BaseAddress",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT},
             {.name = "ZeroBits",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "RegionSize",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT},
             {.name = "AllocationType",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "Protect", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "native memory allocation",
        .cleanup_api = "NtFreeVirtualMemory",
        .headers = {"ntddk.h"}
    },

    api_info{
        .name = "NtFreeVirtualMemory",
        .module = "ntdll.dll",
        .api_category = api_info::category::HEAP_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FREES_MEMORY),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "ProcessHandle",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "BaseAddress",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT},
             {.name = "RegionSize",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT},
             {.name = "FreeType", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "native memory deallocation",
        .headers = {"ntddk.h"}
    },

    // native process operations
    api_info{
        .name = "NtCreateProcess",
        .module = "ntdll.dll",
        .api_category = api_info::category::PROCESS_CONTROL,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE) |
                 static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "ProcessHandle",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "DesiredAccess",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "ObjectAttributes",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "ParentProcess",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "InheritObjectTable",
              .param_type = param_info::type::BOOLEAN,
              .param_direction = param_info::direction::IN},
             {.name = "SectionHandle",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "DebugPort",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "ExceptionPort",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "native process creation",
        .headers = {"ntddk.h"}
    },

    api_info{
        .name = "NtTerminateProcess",
        .module = "ntdll.dll",
        .api_category = api_info::category::PROCESS_CONTROL,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE) |
                 static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "ProcessHandle",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "ExitStatus",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "native process termination",
        .security_notes = {"forceful termination", "can corrupt application state"},
        .headers = {"ntddk.h"}
    },

    // native thread operations
    api_info{
        .name = "NtCreateThread",
        .module = "ntdll.dll",
        .api_category = api_info::category::THREAD_CONTROL,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE) |
                 static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "ThreadHandle",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "DesiredAccess",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "ObjectAttributes",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "ProcessHandle",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "ClientId",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "ThreadContext",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "InitialTeb",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "CreateSuspended",
              .param_type = param_info::type::BOOLEAN,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "native thread creation",
        .headers = {"ntddk.h"}
    },

    // native registry operations
    api_info{
        .name = "NtOpenKey",
        .module = "ntdll.dll",
        .api_category = api_info::category::REGISTRY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
                 static_cast<uint32_t>(api_info::behavior_flags::REGISTRY_ACCESS),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "KeyHandle",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "DesiredAccess",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "ObjectAttributes",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "native registry key open",
        .headers = {"ntddk.h"}
    },

    api_info{
        .name = "NtQueryValueKey",
        .module = "ntdll.dll",
        .api_category = api_info::category::REGISTRY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::REGISTRY_ACCESS),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "KeyHandle",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "ValueName",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "KeyValueInformationClass",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "KeyValueInformation",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "Length", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
             {.name = "ResultLength",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "native registry value query",
        .headers = {"ntddk.h"}
    },

    // low-level system services
    api_info{
        .name = "NtDelayExecution",
        .module = "ntdll.dll",
        .api_category = api_info::category::SYNCHRONIZATION,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "Alertable",
              .param_type = param_info::type::BOOLEAN,
              .param_direction = param_info::direction::IN},
             {.name = "DelayInterval",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "native thread delay/sleep",
        .related_apis = {"Sleep", "SleepEx"},
        .headers = {"ntddk.h"}
    },

    api_info{
        .name = "NtClose",
        .module = "ntdll.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::CLOSES_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "Handle", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "native handle close",
        .related_apis = {"CloseHandle"},
        .headers = {"ntddk.h"}
    },

    // === ANTI-ANALYSIS & EVASION DETECTION (NTDLL) ===

    // process information queries for debugging detection
    api_info{
        .name = "NtQueryInformationProcess",
        .module = "ntdll.dll",
        .api_category = api_info::category::SECURITY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "ProcessHandle",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "ProcessInformationClass",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "ProcessInformation",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "ProcessInformationLength",
              .param_type = param_info::type::SIZE,
              .param_direction = param_info::direction::IN},
             {.name = "ReturnLength",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "query process information including debug flags",
        .security_notes =
            {"debugging detection via process flags", "heap flags inspection", "critical anti-analysis api"},
        .related_apis = {"NtSetInformationProcess", "IsDebuggerPresent"},
        .headers = {"ntddk.h", "winternl.h"}
    },

    api_info{
        .name = "NtSetInformationProcess",
        .module = "ntdll.dll",
        .api_category = api_info::category::SECURITY,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "ProcessHandle",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "ProcessInformationClass",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "ProcessInformation",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::IN},
             {.name = "ProcessInformationLength",
              .param_type = param_info::type::SIZE,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "modify process information and debug flags",
        .security_notes = {"disable debugging", "process manipulation", "anti-analysis technique"},
        .related_apis = {"NtQueryInformationProcess"},
        .headers = {"ntddk.h", "winternl.h"}
    },

    api_info{
        .name = "NtQuerySystemInformation",
        .module = "ntdll.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "SystemInformationClass",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "SystemInformation",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "SystemInformationLength",
              .param_type = param_info::type::SIZE,
              .param_direction = param_info::direction::IN},
             {.name = "ReturnLength",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "query system information including debug state",
        .security_notes = {"kernel debugger detection", "system configuration analysis", "vm detection"},
        .related_apis = {"NtQueryInformationProcess", "GetSystemInfo"},
        .headers = {"ntddk.h", "winternl.h"}
    },

    api_info{
        .name = "NtQuerySystemTime",
        .module = "ntdll.dll",
        .api_category = api_info::category::TIME,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "SystemTime",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "retrieve current system time",
        .security_notes = {"timing analysis for evasion", "native time access"},
        .related_apis = {"NtDelayExecution", "GetSystemTime"},
        .headers = {"ntddk.h"}
    },

    api_info{
        .name = "NtSetSystemTime",
        .module = "ntdll.dll",
        .api_category = api_info::category::TIME,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE) |
                 static_cast<uint32_t>(api_info::behavior_flags::PRIVILEGED),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "SystemTime",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "PreviousTime",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "modify system time",
        .security_notes = {"timestamp manipulation", "forensic timestamp evasion", "requires privilege"},
        .related_apis = {"NtQuerySystemTime", "SetSystemTime"},
        .headers = {"ntddk.h"}
    },

    // advanced heap manipulation for anti-debugging
    api_info{
        .name = "RtlGetProcessHeaps",
        .module = "ntdll.dll",
        .api_category = api_info::category::HEAP_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "NumberOfHeaps",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "ProcessHeaps",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "heapCount", .param_type = param_info::type::INTEGER},
        .description = "retrieve handles to process heaps",
        .security_notes = {"heap flag analysis for debugging detection", "heap structure inspection"},
        .related_apis = {"RtlQueryHeapInformation", "GetProcessHeap"},
        .headers = {"ntddk.h"}
    },

    api_info{
        .name = "LdrGetDllHandle",
        .module = "ntdll.dll",
        .api_category = api_info::category::LIBRARY_LOADING,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "DllPath", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
             {.name = "DllCharacteristics",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "DllName", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
             {.name = "DllHandle",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "get handle to loaded dll",
        .security_notes = {"detect analysis tools by checking loaded dlls", "vm/debugger dll detection"},
        .related_apis = {"LdrLoadDll", "GetModuleHandle"},
        .headers = {"ntddk.h"}
    },

    api_info{
        .name = "LdrLoadDll",
        .module = "ntdll.dll",
        .api_category = api_info::category::LIBRARY_LOADING,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE) |
                 static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "DllPath", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
             {.name = "DllCharacteristics",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "DllName", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
             {.name = "DllHandle",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "load dll into process address space",
        .security_notes = {"manual dll loading", "evasion via native api"},
        .related_apis = {"LdrGetDllHandle", "LoadLibrary"},
        .headers = {"ntddk.h"}
    },

    // exception handling for anti-debugging
    api_info{
        .name = "NtSetInformationThread",
        .module = "ntdll.dll",
        .api_category = api_info::category::THREAD_CONTROL,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "ThreadHandle",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "ThreadInformationClass",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "ThreadInformation",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::IN},
             {.name = "ThreadInformationLength",
              .param_type = param_info::type::SIZE,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "modify thread information including hide from debugger",
        .security_notes = {"hide thread from debugger", "anti-debugging technique"},
        .related_apis = {"NtQueryInformationThread", "SetThreadInformation"},
        .headers = {"ntddk.h"}
    },

    api_info{
        .name = "NtQueryInformationThread",
        .module = "ntdll.dll",
        .api_category = api_info::category::THREAD_CONTROL,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "ThreadHandle",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "ThreadInformationClass",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "ThreadInformation",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "ThreadInformationLength",
              .param_type = param_info::type::SIZE,
              .param_direction = param_info::direction::IN},
             {.name = "ReturnLength",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "status", .param_type = param_info::type::INTEGER},
        .description = "query thread information including debug flags",
        .security_notes = {"thread state analysis", "debugging detection"},
        .related_apis = {"NtSetInformationThread", "GetThreadContext"},
        .headers = {"ntddk.h"}
    }
};

#undef WINDOWS_API_CONVENTION

} // namespace w1::abi::apis::windows
```

`src/w1tn3ss/abi/apis/windows/psapi_apis.hpp`:

```hpp
#pragma once

#include "abi/api_knowledge_db.hpp"
#include <vector>

namespace w1::abi::apis::windows {

// determine windows calling convention based on architecture
#if defined(_M_X64) || defined(__x86_64__)
#define WINDOWS_API_CONVENTION calling_convention_id::X86_64_MICROSOFT
#elif defined(_M_IX86) || defined(__i386__)
#define WINDOWS_API_CONVENTION calling_convention_id::X86_STDCALL
#else
#define WINDOWS_API_CONVENTION calling_convention_id::UNKNOWN
#endif

/**
 * @brief psapi.dll api definitions
 *
 * covers windows process status apis:
 * - process enumeration and information
 * - module enumeration and details
 * - memory usage statistics
 * - performance counters
 * - working set information
 * - device driver information
 */

static const std::vector<api_info> windows_psapi_apis = {
    // === PROCESS ENUMERATION ===

    api_info{
        .name = "EnumProcesses",
        .module = "psapi.dll",
        .api_category = api_info::category::PROCESS_CONTROL,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpidProcess",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "cb", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
             {.name = "lpcbNeeded",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve list of process identifiers",
        .security_notes = {"process discovery capability", "system reconnaissance"},
        .related_apis = {"OpenProcess", "EnumProcessModules", "GetProcessImageFileName"},
        .headers = {"windows.h", "psapi.h"}
    },

    api_info{
        .name = "GetProcessImageFileNameW",
        .module = "psapi.dll",
        .api_category = api_info::category::PROCESS_CONTROL,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProcess", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpImageFileName",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "nSize", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "length", .param_type = param_info::type::SIZE},
        .description = "retrieve device-form path of process executable",
        .related_apis = {"EnumProcesses", "GetModuleFileNameEx", "QueryFullProcessImageName"},
        .headers = {"windows.h", "psapi.h"}
    },

    api_info{
        .name = "GetProcessMemoryInfo",
        .module = "psapi.dll",
        .api_category = api_info::category::MEMORY_MANAGEMENT,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "Process", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "ppsmemCounters",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "cb", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve memory usage information for process",
        .related_apis = {"GetPerformanceInfo", "GetWsChanges"},
        .headers = {"windows.h", "psapi.h"}
    },

    // === MODULE ENUMERATION ===

    api_info{
        .name = "EnumProcessModules",
        .module = "psapi.dll",
        .api_category = api_info::category::LIBRARY_LOADING,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProcess", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lphModule",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "cb", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
             {.name = "lpcbNeeded",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve handles for modules in process",
        .security_notes = {"module discovery capability", "dll enumeration for analysis"},
        .related_apis = {"GetModuleInformation", "GetModuleFileNameEx", "GetModuleBaseName"},
        .headers = {"windows.h", "psapi.h"}
    },

    api_info{
        .name = "EnumProcessModulesEx",
        .module = "psapi.dll",
        .api_category = api_info::category::LIBRARY_LOADING,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProcess", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lphModule",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "cb", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
             {.name = "lpcbNeeded",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "dwFilterFlag",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve handles for modules in process with filtering",
        .security_notes = {"module discovery with wow64 filtering", "architecture-aware enumeration"},
        .related_apis = {"EnumProcessModules", "GetModuleInformation"},
        .headers = {"windows.h", "psapi.h"}
    },

    api_info{
        .name = "GetModuleInformation",
        .module = "psapi.dll",
        .api_category = api_info::category::LIBRARY_LOADING,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProcess", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "hModule", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpmodinfo",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "cb", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve information about module",
        .related_apis = {"EnumProcessModules", "GetModuleFileNameEx"},
        .headers = {"windows.h", "psapi.h"}
    },

    api_info{
        .name = "GetModuleFileNameExW",
        .module = "psapi.dll",
        .api_category = api_info::category::LIBRARY_LOADING,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProcess", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "hModule", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpFilename",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "nSize", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "length", .param_type = param_info::type::SIZE},
        .description = "retrieve full path of module file",
        .related_apis = {"GetModuleBaseName", "GetModuleInformation", "EnumProcessModules"},
        .headers = {"windows.h", "psapi.h"}
    },

    api_info{
        .name = "GetModuleBaseNameW",
        .module = "psapi.dll",
        .api_category = api_info::category::LIBRARY_LOADING,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProcess", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "hModule", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpBaseName",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "nSize", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "length", .param_type = param_info::type::SIZE},
        .description = "retrieve base name of module",
        .related_apis = {"GetModuleFileNameEx", "GetModuleInformation"},
        .headers = {"windows.h", "psapi.h"}
    },

    // === WORKING SET INFORMATION ===

    api_info{
        .name = "QueryWorkingSet",
        .module = "psapi.dll",
        .api_category = api_info::category::MEMORY_MANAGEMENT,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProcess", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "pv", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
             {.name = "cb", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve working set information for process",
        .related_apis = {"QueryWorkingSetEx", "GetProcessMemoryInfo"},
        .headers = {"windows.h", "psapi.h"}
    },

    api_info{
        .name = "QueryWorkingSetEx",
        .module = "psapi.dll",
        .api_category = api_info::category::MEMORY_MANAGEMENT,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProcess", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "pv", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN_OUT},
             {.name = "cb", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve extended working set information",
        .related_apis = {"QueryWorkingSet", "GetWsChanges"},
        .headers = {"windows.h", "psapi.h"}
    },

    api_info{
        .name = "GetWsChanges",
        .module = "psapi.dll",
        .api_category = api_info::category::MEMORY_MANAGEMENT,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProcess", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpWatchInfo",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "cb", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve working set changes since last call",
        .related_apis = {"InitializeProcessForWsWatch", "QueryWorkingSetEx"},
        .headers = {"windows.h", "psapi.h"}
    },

    api_info{
        .name = "InitializeProcessForWsWatch",
        .module = "psapi.dll",
        .api_category = api_info::category::MEMORY_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProcess",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "initialize process for working set monitoring",
        .related_apis = {"GetWsChanges", "QueryWorkingSetEx"},
        .headers = {"windows.h", "psapi.h"}
    },

    // === DEVICE DRIVER ENUMERATION ===

    api_info{
        .name = "EnumDeviceDrivers",
        .module = "psapi.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpImageBase",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "cb", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
             {.name = "lpcbNeeded",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve list of device driver load addresses",
        .security_notes = {"kernel driver enumeration", "rootkit detection capability"},
        .related_apis = {"GetDeviceDriverBaseName", "GetDeviceDriverFileName"},
        .headers = {"windows.h", "psapi.h"}
    },

    api_info{
        .name = "GetDeviceDriverBaseNameW",
        .module = "psapi.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "ImageBase",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "lpBaseName",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "nSize", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "length", .param_type = param_info::type::SIZE},
        .description = "retrieve base name of device driver",
        .related_apis = {"EnumDeviceDrivers", "GetDeviceDriverFileName"},
        .headers = {"windows.h", "psapi.h"}
    },

    api_info{
        .name = "GetDeviceDriverFileNameW",
        .module = "psapi.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "ImageBase",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "lpFileName",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "nSize", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "length", .param_type = param_info::type::SIZE},
        .description = "retrieve file name of device driver",
        .related_apis = {"EnumDeviceDrivers", "GetDeviceDriverBaseName"},
        .headers = {"windows.h", "psapi.h"}
    },

    // === PERFORMANCE INFORMATION ===

    api_info{
        .name = "GetPerformanceInfo",
        .module = "psapi.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "pPerformanceInformation",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "cb", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve system performance information",
        .related_apis = {"GetProcessMemoryInfo", "EnumProcesses"},
        .headers = {"windows.h", "psapi.h"}
    },

    // === MAPPED FILE INFORMATION ===

    api_info{
        .name = "GetMappedFileNameW",
        .module = "psapi.dll",
        .api_category = api_info::category::FILE_MANAGEMENT,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hProcess", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpv", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
             {.name = "lpFilename",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "nSize", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "length", .param_type = param_info::type::SIZE},
        .description = "retrieve name of file backing memory-mapped region",
        .security_notes = {"memory mapping analysis", "code injection detection"},
        .related_apis = {"VirtualQueryEx", "QueryWorkingSetEx"},
        .headers = {"windows.h", "psapi.h"}
    }
};

#undef WINDOWS_API_CONVENTION

} // namespace w1::abi::apis::windows
```

`src/w1tn3ss/abi/apis/windows/system_apis.hpp`:

```hpp
#pragma once

#include "abi/api_knowledge_db.hpp"
#include <vector>

// include dll-specific api definitions
#include "kernel32_apis.hpp"
#include "ucrtbase_apis.hpp"
#include "ntdll_apis.hpp"
#include "user32_apis.hpp"
#include "advapi32_apis.hpp"
#include "ws2_32_apis.hpp"
#include "psapi_apis.hpp"
#include "winmm_apis.hpp"

namespace w1::abi::apis::windows {

/**
 * @brief windows system api definitions aggregator
 *
 * aggregates api definitions from multiple windows dlls:
 * - kernel32.dll: process, thread, memory, file operations, i/o completion, ipc, synchronization
 * - ucrtbase.dll: universal c runtime (modern c library functions)
 * - ntdll.dll: native nt apis (low-level system services)
 * - user32.dll: window management, ui, message handling
 * - advapi32.dll: security, tokens, services, registry, crypto, event logging
 * - ws2_32.dll: winsock api, sockets, network communication, dns resolution
 * - psapi.dll: process status api, process/module enumeration, memory analysis
 * - winmm.dll: multimedia timing apis, audio/device detection for vm analysis
 *
 * note: windows apis typically use stdcall on x86 and microsoft convention on x64
 *       the calling convention detector will handle this automatically
 */

// legacy api definitions (now moved to individual dll files)
// kept here temporarily for backward compatibility

// aggregate all windows apis from dll-specific files
inline std::vector<api_info> get_all_windows_apis() {
  std::vector<api_info> apis;

  // kernel32.dll - process, thread, memory, file, i/o completion, ipc, synchronization, error handling
  apis.insert(apis.end(), windows_kernel32_apis.begin(), windows_kernel32_apis.end());

  // ucrtbase.dll - universal c runtime (string, memory, math, i/o functions)
  apis.insert(apis.end(), windows_ucrtbase_apis.begin(), windows_ucrtbase_apis.end());

  // ntdll.dll - native nt apis (low-level system services)
  apis.insert(apis.end(), windows_ntdll_apis.begin(), windows_ntdll_apis.end());

  // user32.dll - window management, ui, message handling
  apis.insert(apis.end(), windows_user32_apis.begin(), windows_user32_apis.end());

  // advapi32.dll - security, tokens, services, registry, crypto, event logging
  apis.insert(apis.end(), windows_advapi32_apis.begin(), windows_advapi32_apis.end());

  // ws2_32.dll - winsock api, sockets, network communication, dns resolution
  apis.insert(apis.end(), windows_ws2_32_apis.begin(), windows_ws2_32_apis.end());

  // psapi.dll - process status api, process/module enumeration, memory analysis
  apis.insert(apis.end(), windows_psapi_apis.begin(), windows_psapi_apis.end());

  // winmm.dll - multimedia timing apis, audio/device detection for vm analysis
  apis.insert(apis.end(), windows_winmm_apis.begin(), windows_winmm_apis.end());

  return apis;
}

} // namespace w1::abi::apis::windows
```

`src/w1tn3ss/abi/apis/windows/ucrtbase_apis.hpp`:

```hpp
#pragma once

#include "abi/api_knowledge_db.hpp"
#include <vector>

namespace w1::abi::apis::windows {

// determine windows calling convention based on architecture
#if defined(_M_X64) || defined(__x86_64__)
#define WINDOWS_API_CONVENTION calling_convention_id::X86_64_MICROSOFT
#elif defined(_M_IX86) || defined(__i386__)
#define WINDOWS_API_CONVENTION calling_convention_id::X86_STDCALL
#else
#define WINDOWS_API_CONVENTION calling_convention_id::UNKNOWN
#endif

/**
 * @brief universal c runtime (ucrtbase.dll) api definitions
 *
 * covers modern windows c runtime apis:
 * - string manipulation functions
 * - memory management functions
 * - i/o and formatting functions
 * - character classification and conversion
 * - mathematical functions
 * - program lifecycle functions
 */

static const std::vector<api_info> windows_ucrtbase_apis = {
    // string manipulation functions
    api_info{
        .name = "strdup",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::STRING_MANIPULATION,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "strSource",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "duplicate", .param_type = param_info::type::STRING},
        .description = "duplicate string by allocating memory copy",
        .security_notes = {"allocates memory that must be freed", "returns null on allocation failure"},
        .cleanup_api = "free",
        .headers = {"string.h"}
    },

    api_info{
        .name = "_strdup",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::STRING_MANIPULATION,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "strSource",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "duplicate", .param_type = param_info::type::STRING},
        .description = "microsoft-specific duplicate string function",
        .related_apis = {"strdup"},
        .cleanup_api = "free",
        .headers = {"string.h"}
    },

    api_info{
        .name = "strcpy",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::STRING_MANIPULATION,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "strDestination",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::OUT},
             {.name = "strSource",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "destination", .param_type = param_info::type::STRING},
        .description = "copy string to destination buffer",
        .security_notes = {"buffer overflow risk", "destination must be large enough", "use strcpy_s instead"},
        .related_apis = {"strcpy_s", "strncpy"},
        .headers = {"string.h"}
    },

    api_info{
        .name = "strlen",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::STRING_MANIPULATION,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "str", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "length", .param_type = param_info::type::SIZE},
        .description = "get length of null-terminated string",
        .headers = {"string.h"}
    },

    api_info{
        .name = "strcmp",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::STRING_MANIPULATION,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "string1", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
             {.name = "string2", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
        .description = "compare two strings lexicographically",
        .headers = {"string.h"}
    },

    // memory management functions
    api_info{
        .name = "malloc",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::HEAP_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "pointer", .param_type = param_info::type::POINTER},
        .description = "allocate memory block on heap",
        .related_apis = {"calloc", "realloc", "free"},
        .cleanup_api = "free",
        .headers = {"stdlib.h"}
    },

    api_info{
        .name = "free",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::HEAP_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FREES_MEMORY),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "ptr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "void", .param_type = param_info::type::VOID},
        .description = "free previously allocated memory block",
        .security_notes = {"double-free vulnerability", "use-after-free vulnerability"},
        .related_apis = {"malloc", "calloc", "realloc"},
        .headers = {"stdlib.h"}
    },

    api_info{
        .name = "calloc",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::HEAP_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::ALLOCATES_MEMORY),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "num", .param_type = param_info::type::COUNT, .param_direction = param_info::direction::IN},
             {.name = "size", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "pointer", .param_type = param_info::type::POINTER},
        .description = "allocate and zero-initialize array of elements",
        .related_apis = {"malloc", "realloc", "free"},
        .cleanup_api = "free",
        .headers = {"stdlib.h"}
    },

    api_info{
        .name = "memcpy",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::MEMORY_MANAGEMENT,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "dest", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::OUT},
             {.name = "src", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::IN},
             {.name = "count", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "dest", .param_type = param_info::type::POINTER},
        .description = "copy bytes between buffers",
        .security_notes = {"buffer overflow risk", "overlapping buffers undefined", "use memcpy_s instead"},
        .related_apis = {"memmove", "memset", "memcpy_s"},
        .headers = {"string.h"}
    },

    api_info{
        .name = "memset",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::MEMORY_MANAGEMENT,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "dest", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::OUT},
             {.name = "c", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "count", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "dest", .param_type = param_info::type::POINTER},
        .description = "set bytes in buffer to specified value",
        .headers = {"string.h"}
    },

    // i/o and formatting functions
    api_info{
        .name = "_stdio_common_vfprintf_s",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::STDIO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "options", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
             {.name = "stream", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
             {.name = "format", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
             {.name = "locale", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
             {.name = "arglist",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "chars_written", .param_type = param_info::type::INTEGER},
        .description = "secure formatted output to stream with locale",
        .related_apis = {"printf", "fprintf", "sprintf"},
        .headers = {"stdio.h"}
    },

    api_info{
        .name = "printf",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::STDIO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {
                {.name = "format", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}
                // note: variadic parameters not fully supported yet
            },
        .return_value = {.name = "chars_written", .param_type = param_info::type::INTEGER},
        .description = "formatted output to stdout",
        .related_apis = {"fprintf", "sprintf", "_stdio_common_vfprintf_s"},
        .headers = {"stdio.h"}
    },

    api_info{
        .name = "fprintf",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::STDIO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FILE_IO),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "stream", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
             {.name = "format", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "chars_written", .param_type = param_info::type::INTEGER},
        .description = "formatted output to stream",
        .related_apis = {"printf", "sprintf", "_stdio_common_vfprintf_s"},
        .headers = {"stdio.h"}
    },

    // character classification and conversion
    api_info{
        .name = "towlower",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::STRING_MANIPULATION,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "c", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "lowercase", .param_type = param_info::type::INTEGER},
        .description = "convert wide character to lowercase",
        .related_apis = {"towupper", "tolower"},
        .headers = {"wctype.h"}
    },

    api_info{
        .name = "towupper",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::STRING_MANIPULATION,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "c", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "uppercase", .param_type = param_info::type::INTEGER},
        .description = "convert wide character to uppercase",
        .related_apis = {"towlower", "toupper"},
        .headers = {"wctype.h"}
    },

    api_info{
        .name = "isalpha",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::STRING_MANIPULATION,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "c", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "result", .param_type = param_info::type::BOOLEAN},
        .description = "check if character is alphabetic",
        .related_apis = {"isdigit", "isalnum", "isspace"},
        .headers = {"ctype.h"}
    },

    api_info{
        .name = "isdigit",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::STRING_MANIPULATION,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "c", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "result", .param_type = param_info::type::BOOLEAN},
        .description = "check if character is decimal digit",
        .related_apis = {"isalpha", "isalnum", "isxdigit"},
        .headers = {"ctype.h"}
    },

    // mathematical functions
    api_info{
        .name = "fdexp",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::MISC, // we need to add MATH category
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN},
             {.name = "exp", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
        .description = "multiply floating-point number by power of 2",
        .related_apis = {"ldexp", "frexp", "modf"},
        .headers = {"math.h"}
    },

    api_info{
        .name = "sin",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::MISC, // MATH category needed
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
        .description = "calculate sine of angle in radians",
        .related_apis = {"cos", "tan", "asin"},
        .headers = {"math.h"}
    },

    api_info{
        .name = "cos",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::MISC,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
        .description = "calculate cosine of angle in radians",
        .related_apis = {"sin", "tan", "acos"},
        .headers = {"math.h"}
    },

    api_info{
        .name = "sqrt",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::MISC,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "x", .param_type = param_info::type::DOUBLE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "result", .param_type = param_info::type::DOUBLE},
        .description = "calculate square root",
        .related_apis = {"pow", "cbrt"},
        .headers = {"math.h"}
    },

    // program lifecycle functions
    api_info{
        .name = "register_onexit_function",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::PROCESS_CONTROL, // could be RUNTIME_CONTROL
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "table",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT},
             {.name = "function",
              .param_type = param_info::type::CALLBACK,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
        .description = "register function to be called at program termination",
        .related_apis = {"atexit", "_onexit", "exit"},
        .headers = {"stdlib.h"}
    },

    api_info{
        .name = "atexit",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::PROCESS_CONTROL,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "function",
              .param_type = param_info::type::CALLBACK,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
        .description = "register function to be called at normal program termination",
        .related_apis = {"_onexit", "register_onexit_function", "exit"},
        .headers = {"stdlib.h"}
    },

    api_info{
        .name = "exit",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::PROCESS_CONTROL,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "status", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "void", .param_type = param_info::type::VOID},
        .description = "terminate program normally with cleanup",
        .related_apis = {"abort", "_exit", "atexit"},
        .headers = {"stdlib.h"}
    },

    api_info{
        .name = "abort",
        .module = "ucrtbase.dll",
        .api_category = api_info::category::PROCESS_CONTROL,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters = {},
        .return_value = {.name = "void", .param_type = param_info::type::VOID},
        .description = "terminate program abnormally without cleanup",
        .related_apis = {"exit", "_exit", "terminate"},
        .headers = {"stdlib.h"}
    }
};

#undef WINDOWS_API_CONVENTION

} // namespace w1::abi::apis::windows
```

`src/w1tn3ss/abi/apis/windows/user32_apis.hpp`:

```hpp
#pragma once

#include "abi/api_knowledge_db.hpp"
#include <vector>

namespace w1::abi::apis::windows {

// determine windows calling convention based on architecture
#if defined(_M_X64) || defined(__x86_64__)
#define WINDOWS_API_CONVENTION calling_convention_id::X86_64_MICROSOFT
#elif defined(_M_IX86) || defined(__i386__)
#define WINDOWS_API_CONVENTION calling_convention_id::X86_STDCALL
#else
#define WINDOWS_API_CONVENTION calling_convention_id::UNKNOWN
#endif

/**
 * @brief user32.dll api definitions
 *
 * covers windows ui and windowing apis:
 * - window creation and management
 * - message handling and processing
 * - input handling (keyboard, mouse)
 * - drawing and painting
 * - dialog and menu management
 * - system metrics and configuration
 */

static const std::vector<api_info> windows_user32_apis = {
    // window creation and management
    api_info{
        .name = "CreateWindowExW",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "dwExStyle", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
             {.name = "lpClassName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "lpWindowName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "dwStyle", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
             {.name = "X", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "Y", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "nWidth", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "nHeight", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "hWndParent",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "hMenu", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "hInstance",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "lpParam",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "hwnd", .param_type = param_info::type::HANDLE},
        .description = "create window with extended styles",
        .cleanup_api = "DestroyWindow",
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "DestroyWindow",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::CLOSES_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hWnd", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "destroy specified window",
        .related_apis = {"CreateWindowExW", "CloseWindow"},
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "FindWindowW",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpClassName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "lpWindowName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "hwnd", .param_type = param_info::type::HANDLE},
        .description = "find window by class name and/or window name",
        .related_apis = {"FindWindowExW", "EnumWindows"},
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "ShowWindow",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hWnd", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "nCmdShow",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "was_visible", .param_type = param_info::type::BOOLEAN},
        .description = "set window show state",
        .related_apis = {"SetWindowPos", "IsWindowVisible"},
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "GetWindowTextW",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hWnd", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpString",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT},
             {.name = "nMaxCount",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "length", .param_type = param_info::type::INTEGER},
        .description = "copy window title to buffer",
        .related_apis = {"SetWindowTextW", "GetWindowTextLengthW"},
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "SetWindowTextW",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hWnd", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpString",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "change window title",
        .related_apis = {"GetWindowTextW", "GetWindowTextLengthW"},
        .headers = {"windows.h", "winuser.h"}
    },

    // message handling
    api_info{
        .name = "GetMessageW",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpMsg", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
             {.name = "hWnd", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "wMsgFilterMin",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "wMsgFilterMax",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
        .description = "retrieve message from calling thread's message queue",
        .related_apis = {"PeekMessage", "PostMessage", "DispatchMessage"},
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "PeekMessageW",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpMsg", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
             {.name = "hWnd", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "wMsgFilterMin",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "wMsgFilterMax",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "wRemoveMsg",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "message_available", .param_type = param_info::type::BOOLEAN},
        .description = "check for message without blocking",
        .related_apis = {"GetMessage", "PostMessage", "DispatchMessage"},
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "DispatchMessageW",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpMsg", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
        .description = "dispatch message to window procedure",
        .related_apis = {"GetMessage", "PeekMessage", "TranslateMessage"},
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "SendMessageW",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hWnd", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "Msg", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "wParam", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
             {.name = "lParam", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
        .description = "send message to window (synchronous)",
        .related_apis = {"PostMessage", "SendMessageTimeout"},
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "PostMessageW",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hWnd", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "Msg", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "wParam", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
             {.name = "lParam", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "post message to window (asynchronous)",
        .related_apis = {"SendMessage", "PostThreadMessage"},
        .headers = {"windows.h", "winuser.h"}
    },

    // message boxes and dialogs
    api_info{
        .name = "MessageBoxW",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hWnd", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpText", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN},
             {.name = "lpCaption",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "uType", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
        .description = "display message box",
        .headers = {"windows.h", "winuser.h"}
    },

    // input handling
    api_info{
        .name = "GetKeyState",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "nVirtKey",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "state", .param_type = param_info::type::INTEGER},
        .description = "retrieve state of virtual key",
        .related_apis = {"GetAsyncKeyState", "GetKeyboardState"},
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "GetCursorPos",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpPoint",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve cursor position in screen coordinates",
        .related_apis = {"SetCursorPos", "ClientToScreen"},
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "SetCursorPos",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "X", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "Y", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "move cursor to specified screen coordinates",
        .related_apis = {"GetCursorPos", "ScreenToClient"},
        .headers = {"windows.h", "winuser.h"}
    },

    // drawing and device context
    api_info{
        .name = "GetDC",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hWnd", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "hdc", .param_type = param_info::type::HANDLE},
        .description = "retrieve device context for window",
        .cleanup_api = "ReleaseDC",
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "ReleaseDC",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::CLOSES_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hWnd", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "hDC", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::INTEGER},
        .description = "release device context",
        .related_apis = {"GetDC", "GetWindowDC"},
        .headers = {"windows.h", "winuser.h"}
    },

    // system metrics and information
    api_info{
        .name = "GetSystemMetrics",
        .module = "user32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "nIndex", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "value", .param_type = param_info::type::INTEGER},
        .description = "retrieve system metrics and configuration",
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "GetDesktopWindow",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters = {},
        .return_value = {.name = "hwnd", .param_type = param_info::type::HANDLE},
        .description = "retrieve handle to desktop window",
        .related_apis = {"GetForegroundWindow", "GetActiveWindow"},
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "GetForegroundWindow",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters = {},
        .return_value = {.name = "hwnd", .param_type = param_info::type::HANDLE},
        .description = "retrieve handle to foreground window",
        .related_apis = {"SetForegroundWindow", "GetActiveWindow"},
        .headers = {"windows.h", "winuser.h"}
    },

    // window enumeration
    api_info{
        .name = "EnumWindows",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpEnumFunc",
              .param_type = param_info::type::CALLBACK,
              .param_direction = param_info::direction::IN},
             {.name = "lParam", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "enumerate all top-level windows",
        .related_apis = {"EnumChildWindows", "FindWindow"},
        .headers = {"windows.h", "winuser.h"}
    },

    // === VM/SANDBOX DETECTION VIA USER32 ===

    api_info{
        .name = "GetSystemMetrics",
        .module = "user32.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "nIndex", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "value", .param_type = param_info::type::INTEGER},
        .description = "retrieve system metrics for vm detection",
        .security_notes = {"screen resolution analysis", "vm detection via display metrics", "mouse detection"},
        .related_apis = {"GetDeviceCaps", "EnumDisplayDevices"},
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "GetCursorInfo",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "pci", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve cursor information",
        .security_notes = {"mouse interaction detection", "user activity analysis for vm detection"},
        .related_apis = {"GetCursorPos", "SetCursorPos"},
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "GetKeyboardState",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "lpKeyState",
              .param_type = param_info::type::BUFFER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "retrieve state of all virtual keys",
        .security_notes = {"keyboard activity analysis", "user interaction detection"},
        .related_apis = {"GetKeyState", "GetAsyncKeyState"},
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "BlockInput",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "fBlockIt",
              .param_type = param_info::type::BOOLEAN,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "block or unblock keyboard and mouse input",
        .security_notes = {"input blocking for evasion", "user interaction prevention"},
        .related_apis = {"SetWindowsHookEx", "CallNextHookEx"},
        .headers = {"windows.h", "winuser.h"}
    },

    // === WINDOWS HOOKING APIs ===

    api_info{
        .name = "SetWindowsHookExW",
        .module = "user32.dll",
        .api_category = api_info::category::SYSTEM_HOOK,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE) |
                 static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE) |
                 static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "idHook", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "lpfn", .param_type = param_info::type::CALLBACK, .param_direction = param_info::direction::IN},
             {.name = "hMod", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "dwThreadId",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "hookHandle", .param_type = param_info::type::HANDLE},
        .description = "install hook procedure to monitor system events",
        .security_notes = {"system-wide hooking", "keylogger capability", "input monitoring", "dll injection vector"},
        .related_apis = {"UnhookWindowsHookEx", "CallNextHookEx", "GetModuleHandle"},
        .cleanup_api = "UnhookWindowsHookEx",
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "UnhookWindowsHookEx",
        .module = "user32.dll",
        .api_category = api_info::category::SYSTEM_HOOK,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::CLOSES_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hhk", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "remove hook procedure from hook chain",
        .related_apis = {"SetWindowsHookExW", "CallNextHookEx"},
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "CallNextHookEx",
        .module = "user32.dll",
        .api_category = api_info::category::SYSTEM_HOOK,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hhk", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "nCode", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "wParam", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
             {.name = "lParam", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
        .description = "pass hook information to next hook procedure",
        .related_apis = {"SetWindowsHookExW", "UnhookWindowsHookEx"},
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "GetKeyboardLayout",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "idThread",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "layout", .param_type = param_info::type::HANDLE},
        .description = "retrieve active keyboard layout",
        .security_notes = {"keyboard layout detection", "locale fingerprinting"},
        .related_apis = {"GetKeyboardLayoutList", "LoadKeyboardLayout"},
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "RegisterHotKey",
        .module = "user32.dll",
        .api_category = api_info::category::SYSTEM_HOOK,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hWnd", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "id", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "fsModifiers",
              .param_type = param_info::type::FLAGS,
              .param_direction = param_info::direction::IN},
             {.name = "vk", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "register system-wide hotkey",
        .security_notes = {"global hotkey registration", "system-wide input capture"},
        .related_apis = {"UnregisterHotKey", "GetMessage"},
        .cleanup_api = "UnregisterHotKey",
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "UnregisterHotKey",
        .module = "user32.dll",
        .api_category = api_info::category::SYSTEM_HOOK,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hWnd", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "id", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "unregister system-wide hotkey",
        .related_apis = {"RegisterHotKey"},
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "GetAsyncKeyState",
        .module = "user32.dll",
        .api_category = api_info::category::UI,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "vKey", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "state", .param_type = param_info::type::INTEGER},
        .description = "retrieve asynchronous key state",
        .security_notes = {"keylogger functionality", "async key monitoring"},
        .related_apis = {"GetKeyState", "GetKeyboardState"},
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "SetWinEventHook",
        .module = "user32.dll",
        .api_category = api_info::category::SYSTEM_HOOK,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE) |
                 static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "eventMin",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "eventMax",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "hmodWinEventProc",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN},
             {.name = "pfnWinEventProc",
              .param_type = param_info::type::CALLBACK,
              .param_direction = param_info::direction::IN},
             {.name = "idProcess",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "idThread",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "dwFlags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "hookHandle", .param_type = param_info::type::HANDLE},
        .description = "set event hook for accessibility events",
        .security_notes = {"accessibility event monitoring", "window event tracking"},
        .related_apis = {"UnhookWinEvent", "SetWindowsHookExW"},
        .cleanup_api = "UnhookWinEvent",
        .headers = {"windows.h", "winuser.h"}
    },

    api_info{
        .name = "UnhookWinEvent",
        .module = "user32.dll",
        .api_category = api_info::category::SYSTEM_HOOK,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::CLOSES_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "hWinEventHook",
              .param_type = param_info::type::HANDLE,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "success", .param_type = param_info::type::BOOLEAN},
        .description = "remove event hook",
        .related_apis = {"SetWinEventHook"},
        .headers = {"windows.h", "winuser.h"}
    }
};

#undef WINDOWS_API_CONVENTION

} // namespace w1::abi::apis::windows
```

`src/w1tn3ss/abi/apis/windows/winmm_apis.hpp`:

```hpp
#pragma once

#include "abi/api_knowledge_db.hpp"
#include <vector>

namespace w1::abi::apis::windows {

// determine windows calling convention based on architecture
#if defined(_M_X64) || defined(__x86_64__)
#define WINDOWS_API_CONVENTION calling_convention_id::X86_64_MICROSOFT
#elif defined(_M_IX86) || defined(__i386__)
#define WINDOWS_API_CONVENTION calling_convention_id::X86_STDCALL
#else
#define WINDOWS_API_CONVENTION calling_convention_id::UNKNOWN
#endif

/**
 * @brief winmm.dll api definitions
 *
 * covers windows multimedia apis commonly used for anti-analysis:
 * - high-precision timing functions
 * - multimedia timer services
 * - audio system detection
 * - system capability detection
 */

static const std::vector<api_info> windows_winmm_apis = {
    // === TIMING FUNCTIONS FOR EVASION ===

    api_info{
        .name = "timeGetTime",
        .module = "winmm.dll",
        .api_category = api_info::category::TIME,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters = {},
        .return_value = {.name = "milliseconds", .param_type = param_info::type::INTEGER},
        .description = "retrieve system time in milliseconds",
        .security_notes = {"high-resolution timing for sandbox detection", "alternative to gettickcount"},
        .related_apis = {"GetTickCount", "QueryPerformanceCounter", "timeBeginPeriod"},
        .headers = {"windows.h", "timeapi.h", "mmsystem.h"}
    },

    api_info{
        .name = "timeBeginPeriod",
        .module = "winmm.dll",
        .api_category = api_info::category::TIME,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "uPeriod",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
        .description = "request minimum timer resolution",
        .security_notes = {"improve timing precision for evasion", "system-wide timer modification"},
        .related_apis = {"timeEndPeriod", "timeGetTime", "timeGetDevCaps"},
        .headers = {"windows.h", "timeapi.h", "mmsystem.h"}
    },

    api_info{
        .name = "timeEndPeriod",
        .module = "winmm.dll",
        .api_category = api_info::category::TIME,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "uPeriod",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
        .description = "clear timer resolution request",
        .related_apis = {"timeBeginPeriod", "timeGetTime"},
        .headers = {"windows.h", "timeapi.h", "mmsystem.h"}
    },

    api_info{
        .name = "timeGetDevCaps",
        .module = "winmm.dll",
        .api_category = api_info::category::TIME,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "ptc", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
             {.name = "cbtc", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "result", .param_type = param_info::type::INTEGER},
        .description = "query timer device capabilities",
        .security_notes = {"timer hardware analysis", "system capability fingerprinting"},
        .related_apis = {"timeGetTime", "timeBeginPeriod"},
        .headers = {"windows.h", "timeapi.h", "mmsystem.h"}
    },

    // multimedia system detection for vm analysis
    api_info{
        .name = "waveOutGetNumDevs",
        .module = "winmm.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters = {},
        .return_value = {.name = "deviceCount", .param_type = param_info::type::INTEGER},
        .description = "retrieve number of audio output devices",
        .security_notes = {"audio device enumeration for vm detection", "hardware fingerprinting"},
        .related_apis = {"waveInGetNumDevs", "waveOutGetDevCaps", "midiOutGetNumDevs"},
        .headers = {"windows.h", "mmsystem.h"}
    },

    api_info{
        .name = "waveInGetNumDevs",
        .module = "winmm.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters = {},
        .return_value = {.name = "deviceCount", .param_type = param_info::type::INTEGER},
        .description = "retrieve number of audio input devices",
        .security_notes = {"microphone detection for vm analysis", "audio hardware enumeration"},
        .related_apis = {"waveOutGetNumDevs", "waveInGetDevCaps"},
        .headers = {"windows.h", "mmsystem.h"}
    },

    api_info{
        .name = "midiOutGetNumDevs",
        .module = "winmm.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters = {},
        .return_value = {.name = "deviceCount", .param_type = param_info::type::INTEGER},
        .description = "retrieve number of midi output devices",
        .security_notes = {"midi device detection for vm analysis", "multimedia hardware fingerprinting"},
        .related_apis = {"midiInGetNumDevs", "midiOutGetDevCaps"},
        .headers = {"windows.h", "mmsystem.h"}
    },

    api_info{
        .name = "joyGetNumDevs",
        .module = "winmm.dll",
        .api_category = api_info::category::SYSTEM_INFO,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::SECURITY_SENSITIVE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters = {},
        .return_value = {.name = "deviceCount", .param_type = param_info::type::INTEGER},
        .description = "retrieve number of joystick devices",
        .security_notes = {"gaming device detection for vm analysis", "peripheral enumeration"},
        .related_apis = {"joyGetDevCaps", "joyGetPos"},
        .headers = {"windows.h", "mmsystem.h"}
    }
};

#undef WINDOWS_API_CONVENTION

} // namespace w1::abi::apis::windows
```

`src/w1tn3ss/abi/apis/windows/ws2_32_apis.hpp`:

```hpp
#pragma once

#include "abi/api_knowledge_db.hpp"
#include <vector>

namespace w1::abi::apis::windows {

// determine windows calling convention based on architecture
#if defined(_M_X64) || defined(__x86_64__)
#define WINDOWS_API_CONVENTION calling_convention_id::X86_64_MICROSOFT
#elif defined(_M_IX86) || defined(__i386__)
#define WINDOWS_API_CONVENTION calling_convention_id::X86_STDCALL
#else
#define WINDOWS_API_CONVENTION calling_convention_id::UNKNOWN
#endif

/**
 * @brief ws2_32.dll api definitions
 *
 * covers windows socket api 2.0 functions:
 * - socket creation and management
 * - network connection establishment
 * - data transmission and reception
 * - address resolution and dns
 * - async socket operations
 * - socket options and configuration
 * - raw socket support
 */

static const std::vector<api_info> windows_ws2_32_apis = {
    // === SOCKET INITIALIZATION ===

    api_info{
        .name = "WSAStartup",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_SOCKET,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "wVersionRequested",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "lpWSAData",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
        .description = "initialize winsock dll usage",
        .related_apis = {"WSACleanup", "socket", "WSAGetLastError"},
        .cleanup_api = "WSACleanup",
        .headers = {"winsock2.h", "ws2tcpip.h"}
    },

    api_info{
        .name = "WSACleanup",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_SOCKET,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::MODIFIES_GLOBAL_STATE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters = {},
        .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
        .description = "terminate use of winsock dll",
        .related_apis = {"WSAStartup"},
        .headers = {"winsock2.h"}
    },

    // === SOCKET CREATION AND MANAGEMENT ===

    api_info{
        .name = "socket",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_SOCKET,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
                 static_cast<uint32_t>(api_info::behavior_flags::NETWORK_IO),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "af", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "type", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "protocol",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "socketHandle", .param_type = param_info::type::HANDLE},
        .description = "create socket for network communication",
        .security_notes = {"network communication capability", "c2 communication vector"},
        .related_apis = {"bind", "connect", "listen", "closesocket"},
        .cleanup_api = "closesocket",
        .headers = {"winsock2.h"}
    },

    api_info{
        .name = "WSASocket",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_SOCKET,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
                 static_cast<uint32_t>(api_info::behavior_flags::NETWORK_IO),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "af", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "type", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "protocol",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN},
             {.name = "lpProtocolInfo",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "g", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "dwFlags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "socketHandle", .param_type = param_info::type::HANDLE},
        .description = "create socket with extended attributes",
        .security_notes = {"raw socket capability", "advanced network operations"},
        .related_apis = {"socket", "WSADuplicateSocket", "closesocket"},
        .cleanup_api = "closesocket",
        .headers = {"winsock2.h"}
    },

    api_info{
        .name = "closesocket",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_SOCKET,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::CLOSES_HANDLE),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "s", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
        .description = "close existing socket",
        .related_apis = {"socket", "shutdown"},
        .headers = {"winsock2.h"}
    },

    // === CONNECTION ESTABLISHMENT ===

    api_info{
        .name = "bind",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_SOCKET,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::NETWORK_IO),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "s", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "name", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
             {.name = "namelen",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
        .description = "associate local address with socket",
        .related_apis = {"socket", "listen", "accept"},
        .headers = {"winsock2.h"}
    },

    api_info{
        .name = "connect",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_SOCKET,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::NETWORK_IO) |
                 static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "s", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "name", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
             {.name = "namelen",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
        .description = "establish connection to remote socket",
        .security_notes = {"outbound connection capability", "c2 server communication"},
        .related_apis = {"socket", "send", "recv", "WSAConnect"},
        .headers = {"winsock2.h"}
    },

    api_info{
        .name = "listen",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_SOCKET,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::NETWORK_IO),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "s", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "backlog",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
        .description = "place socket in listening state",
        .security_notes = {"server socket capability", "backdoor listener"},
        .related_apis = {"bind", "accept", "socket"},
        .headers = {"winsock2.h"}
    },

    api_info{
        .name = "accept",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_SOCKET,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::OPENS_HANDLE) |
                 static_cast<uint32_t>(api_info::behavior_flags::NETWORK_IO) |
                 static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "s", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "addr", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
             {.name = "addrlen",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT}},
        .return_value = {.name = "clientSocket", .param_type = param_info::type::HANDLE},
        .description = "accept incoming connection request",
        .security_notes = {"accept inbound connections", "backdoor communication"},
        .related_apis = {"listen", "send", "recv", "WSAAccept"},
        .cleanup_api = "closesocket",
        .headers = {"winsock2.h"}
    },

    // === DATA TRANSMISSION ===

    api_info{
        .name = "send",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_SOCKET,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::NETWORK_IO),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "s", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "buf", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::IN},
             {.name = "len", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
             {.name = "flags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "bytesSent", .param_type = param_info::type::INTEGER},
        .description = "send data on connected socket",
        .security_notes = {"data exfiltration capability", "c2 communication"},
        .related_apis = {"recv", "sendto", "WSASend"},
        .headers = {"winsock2.h"}
    },

    api_info{
        .name = "recv",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_SOCKET,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::NETWORK_IO) |
                 static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "s", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "buf", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::OUT},
             {.name = "len", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
             {.name = "flags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "bytesReceived", .param_type = param_info::type::INTEGER},
        .description = "receive data from connected socket",
        .security_notes = {"command reception capability", "c2 communication"},
        .related_apis = {"send", "recvfrom", "WSARecv"},
        .headers = {"winsock2.h"}
    },

    api_info{
        .name = "sendto",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_SOCKET,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::NETWORK_IO),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "s", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "buf", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::IN},
             {.name = "len", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
             {.name = "flags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
             {.name = "to", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
             {.name = "tolen", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "bytesSent", .param_type = param_info::type::INTEGER},
        .description = "send data to specific destination",
        .security_notes = {"udp communication", "broadcasting capability"},
        .related_apis = {"recvfrom", "send", "socket"},
        .headers = {"winsock2.h"}
    },

    api_info{
        .name = "recvfrom",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_SOCKET,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::NETWORK_IO) |
                 static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "s", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "buf", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::OUT},
             {.name = "len", .param_type = param_info::type::SIZE, .param_direction = param_info::direction::IN},
             {.name = "flags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
             {.name = "from", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::OUT},
             {.name = "fromlen",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT}},
        .return_value = {.name = "bytesReceived", .param_type = param_info::type::INTEGER},
        .description = "receive data and source address",
        .related_apis = {"sendto", "recv", "socket"},
        .headers = {"winsock2.h"}
    },

    // === ASYNC OPERATIONS ===

    api_info{
        .name = "WSASend",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_SOCKET,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::NETWORK_IO) |
                 static_cast<uint32_t>(api_info::behavior_flags::ASYNC),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "s", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpBuffers",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN},
             {.name = "dwBufferCount",
              .param_type = param_info::type::COUNT,
              .param_direction = param_info::direction::IN},
             {.name = "lpNumberOfBytesSent",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "dwFlags", .param_type = param_info::type::FLAGS, .param_direction = param_info::direction::IN},
             {.name = "lpOverlapped",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT},
             {.name = "lpCompletionRoutine",
              .param_type = param_info::type::CALLBACK,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
        .description = "send data with scatter-gather and overlapped i/o",
        .related_apis = {"WSARecv", "send", "WSASendTo"},
        .headers = {"winsock2.h"}
    },

    api_info{
        .name = "WSARecv",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_SOCKET,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::NETWORK_IO) |
                 static_cast<uint32_t>(api_info::behavior_flags::ASYNC),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "s", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "lpBuffers",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT},
             {.name = "dwBufferCount",
              .param_type = param_info::type::COUNT,
              .param_direction = param_info::direction::IN},
             {.name = "lpNumberOfBytesRecvd",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT},
             {.name = "lpFlags",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT},
             {.name = "lpOverlapped",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT},
             {.name = "lpCompletionRoutine",
              .param_type = param_info::type::CALLBACK,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
        .description = "receive data with scatter-gather and overlapped i/o",
        .related_apis = {"WSASend", "recv", "WSARecvFrom"},
        .headers = {"winsock2.h"}
    },

    // === ADDRESS RESOLUTION ===

    api_info{
        .name = "getaddrinfo",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_DNS,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::NETWORK_IO) |
                 static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "pNodeName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "pServiceName",
              .param_type = param_info::type::STRING,
              .param_direction = param_info::direction::IN},
             {.name = "pHints", .param_type = param_info::type::POINTER, .param_direction = param_info::direction::IN},
             {.name = "ppResult",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::OUT}},
        .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
        .description = "resolve hostname to network addresses",
        .security_notes = {"dns resolution capability", "c2 domain resolution"},
        .related_apis = {"freeaddrinfo", "getnameinfo", "gethostbyname"},
        .cleanup_api = "freeaddrinfo",
        .headers = {"winsock2.h", "ws2tcpip.h"}
    },

    api_info{
        .name = "freeaddrinfo",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_DNS,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::FREES_MEMORY),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "pAddrInfo",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "void", .param_type = param_info::type::VOID},
        .description = "free address information structure",
        .related_apis = {"getaddrinfo", "getnameinfo"},
        .headers = {"winsock2.h", "ws2tcpip.h"}
    },

    api_info{
        .name = "gethostbyname",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_DNS,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::NETWORK_IO) |
                 static_cast<uint32_t>(api_info::behavior_flags::BLOCKING) |
                 static_cast<uint32_t>(api_info::behavior_flags::DEPRECATED),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "name", .param_type = param_info::type::STRING, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "hostent", .param_type = param_info::type::POINTER},
        .description = "resolve hostname to ip address (deprecated)",
        .security_notes = {"legacy dns resolution", "c2 domain resolution"},
        .related_apis = {"getaddrinfo", "gethostbyaddr", "inet_addr"},
        .headers = {"winsock2.h"}
    },

    api_info{
        .name = "gethostname",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_DNS,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "name", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::OUT},
             {.name = "namelen",
              .param_type = param_info::type::INTEGER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
        .description = "retrieve local hostname",
        .related_apis = {"getaddrinfo", "gethostbyname"},
        .headers = {"winsock2.h"}
    },

    // === SOCKET OPTIONS ===

    api_info{
        .name = "setsockopt",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_SOCKET,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "s", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "level", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "optname", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "optval", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::IN},
             {.name = "optlen", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN}},
        .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
        .description = "set socket option",
        .related_apis = {"getsockopt", "socket", "ioctlsocket"},
        .headers = {"winsock2.h"}
    },

    api_info{
        .name = "getsockopt",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_SOCKET,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "s", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "level", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "optname", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "optval", .param_type = param_info::type::BUFFER, .param_direction = param_info::direction::OUT},
             {.name = "optlen",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT}},
        .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
        .description = "retrieve socket option",
        .related_apis = {"setsockopt", "socket"},
        .headers = {"winsock2.h"}
    },

    api_info{
        .name = "ioctlsocket",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_SOCKET,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "s", .param_type = param_info::type::HANDLE, .param_direction = param_info::direction::IN},
             {.name = "cmd", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "argp",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT}},
        .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
        .description = "control i/o mode of socket",
        .related_apis = {"setsockopt", "select", "WSAEventSelect"},
        .headers = {"winsock2.h"}
    },

    // === SOCKET SELECTION ===

    api_info{
        .name = "select",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_SOCKET,
        .flags = static_cast<uint32_t>(api_info::behavior_flags::BLOCKING),
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "nfds", .param_type = param_info::type::INTEGER, .param_direction = param_info::direction::IN},
             {.name = "readfds",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT},
             {.name = "writefds",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT},
             {.name = "exceptfds",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN_OUT},
             {.name = "timeout",
              .param_type = param_info::type::POINTER,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "readySockets", .param_type = param_info::type::INTEGER},
        .description = "determine status of one or more sockets",
        .related_apis = {"WSAEventSelect", "WSAWaitForMultipleEvents", "ioctlsocket"},
        .headers = {"winsock2.h"}
    },

    // === ERROR HANDLING ===

    api_info{
        .name = "WSAGetLastError",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_SOCKET,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters = {},
        .return_value = {.name = "error", .param_type = param_info::type::ERROR_CODE},
        .description = "retrieve error code for last winsock operation",
        .related_apis = {"WSASetLastError", "GetLastError"},
        .headers = {"winsock2.h"}
    },

    api_info{
        .name = "WSASetLastError",
        .module = "ws2_32.dll",
        .api_category = api_info::category::NETWORK_SOCKET,
        .flags = 0,
        .convention = WINDOWS_API_CONVENTION,
        .parameters =
            {{.name = "iError",
              .param_type = param_info::type::ERROR_CODE,
              .param_direction = param_info::direction::IN}},
        .return_value = {.name = "void", .param_type = param_info::type::VOID},
        .description = "set error code for winsock operations",
        .related_apis = {"WSAGetLastError", "SetLastError"},
        .headers = {"winsock2.h"}
    }
};

#undef WINDOWS_API_CONVENTION

} // namespace w1::abi::apis::windows
```

`src/w1tn3ss/abi/argument_extractor.cpp`:

```cpp
#include "argument_extractor.hpp"
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <cstring>
#include <unordered_map>

namespace w1::abi {

class argument_extractor::impl {
public:
  impl(
      std::shared_ptr<api_knowledge_db> api_db, std::shared_ptr<calling_convention_detector> detector,
      const extractor_config& config
  )
      : api_db_(api_db), detector_(detector), config_(config), log_("w1.argument_extractor") {

    if (!detector_) {
      detector_ = std::make_shared<calling_convention_detector>();
    }
    log_.dbg("initialized argument extractor with detector");
  }

  impl(
      std::shared_ptr<calling_convention_base> convention, std::shared_ptr<api_knowledge_db> api_db,
      const extractor_config& config
  )
      : default_convention_(convention), api_db_(api_db), config_(config), log_("w1.argument_extractor") {
    log_.dbg("initialized argument extractor with fixed convention");
  }

  extracted_call_info extract_call(
      const std::string& api_name, const std::string& module_name, const util::safe_memory_reader& memory,
      const call_context& ctx
  ) const {
    // determine calling convention
    calling_convention_ptr convention;

    if (default_convention_) {
      convention = default_convention_;
    } else {
      // try to get from cache first
      std::string cache_key = module_name + "::" + api_name;
      auto it = convention_cache_.find(cache_key);
      if (it != convention_cache_.end()) {
        convention = it->second;
      } else {
        // detect convention
        convention = detector_->detect(module_name, api_name, api_db_.get());
        convention_cache_[cache_key] = convention;
      }
    }

    return extract_call_with_convention(api_name, module_name, convention, memory, ctx);
  }

  extracted_call_info extract_call_with_convention(
      const std::string& api_name, const std::string& module_name, calling_convention_ptr convention,
      const util::safe_memory_reader& memory, const call_context& ctx
  ) const {
    log_.dbg(
        "extracting call arguments", redlog::field("api", api_name), redlog::field("module", module_name),
        redlog::field("convention", convention->get_name())
    );

    extracted_call_info info;
    info.api_name = api_name;
    info.module_name = module_name;
    info.timestamp = 0; // todo: add timestamp to context
    info.call_address = ctx.call_address;
    info.return_address = 0; // todo: calculate return address

    // create extraction context
    calling_convention_base::extraction_context extract_ctx{ctx.gpr, ctx.fpr, [&memory](uint64_t addr) -> uint64_t {
                                                              auto val = memory.read<uint64_t>(addr);
                                                              return val.value_or(0);
                                                            }};

    // look up api info
    auto api_info = api_db_->lookup(module_name, api_name);
    if (!api_info) {
      // try without module
      api_info = api_db_->lookup(api_name);
    }

    if (api_info) {
      log_.dbg(
          "found api info", redlog::field("api", api_name), redlog::field("params", api_info->parameters.size()),
          redlog::field("category", static_cast<int>(api_info->api_category))
      );

      info.category = api_info->api_category;
      info.behavior_flags = api_info->flags;
      info.description = api_info->description;

      // extract raw arguments
      auto raw_args = convention->extract_integer_args(extract_ctx, api_info->parameters.size());

      // extract each parameter
      for (size_t i = 0; i < api_info->parameters.size(); ++i) {
        const auto& param = api_info->parameters[i];
        uint64_t raw_value = i < raw_args.size() ? raw_args[i] : 0;

        log_.dbg(
            "extracting parameter", redlog::field("index", i), redlog::field("name", param.name),
            redlog::field("type", static_cast<int>(param.param_type)), redlog::field("raw_value", raw_value)
        );

        auto arg = extract_argument(param, raw_value, memory);
        info.arguments.push_back(std::move(arg));
      }
    } else {
      log_.dbg("no api info found, extracting raw arguments", redlog::field("api", api_name));

      // extract raw arguments without semantic info
      size_t max_args = 6; // reasonable default
      auto raw_args = convention->extract_integer_args(extract_ctx, max_args);

      for (size_t i = 0; i < raw_args.size(); ++i) {
        if (raw_args[i] == 0 && i > 2) {
          break; // heuristic
        }

        param_info generic_param;
        generic_param.name = "arg" + std::to_string(i);
        generic_param.param_type = param_info::type::UNKNOWN;

        auto arg = extract_argument(generic_param, raw_args[i], memory);
        info.arguments.push_back(std::move(arg));
      }
    }

    return info;
  }

  void extract_return_value(
      extracted_call_info& call_info, const util::safe_memory_reader& memory, const call_context& ctx
  ) const {
    log_.dbg("extracting return value", redlog::field("api", call_info.api_name));

    // determine convention
    calling_convention_ptr convention;
    if (default_convention_) {
      convention = default_convention_;
    } else {
      std::string cache_key = call_info.module_name + "::" + call_info.api_name;
      auto it = convention_cache_.find(cache_key);
      if (it != convention_cache_.end()) {
        convention = it->second;
      } else {
        convention = detector_->detect(call_info.module_name, call_info.api_name);
      }
    }

    uint64_t ret_val = convention->get_integer_return(ctx.gpr);

    // look up api info for return type
    auto api_info = api_db_->lookup(call_info.module_name, call_info.api_name);
    if (!api_info) {
      api_info = api_db_->lookup(call_info.api_name);
    }

    if (api_info && api_info->return_value.param_type != param_info::type::VOID) {
      call_info.return_value = extract_argument(api_info->return_value, ret_val, memory);
    } else {
      // generic return value
      param_info generic_ret;
      generic_ret.name = "return";
      generic_ret.param_type = param_info::type::UNKNOWN;
      call_info.return_value = extract_argument(generic_ret, ret_val, memory);
    }
  }

  extracted_argument extract_argument(
      const param_info& param, uint64_t raw_value, const util::safe_memory_reader& memory
  ) const {
    extracted_argument arg;
    arg.raw_value = raw_value;
    arg.param_name = param.name;
    arg.param_type = param.param_type;
    arg.type_description = param.type_description;

    // check for null pointer
    if (param.param_type == param_info::type::POINTER || param.param_type == param_info::type::STRING ||
        param.param_type == param_info::type::PATH || param.param_type == param_info::type::BUFFER) {
      arg.is_null_pointer = (raw_value == 0);
      arg.is_valid_pointer = arg_utils::is_valid_pointer(raw_value, memory);
    }

    // interpret based on type
    switch (param.param_type) {
    case param_info::type::INTEGER:
      arg.interpreted_value = static_cast<int64_t>(raw_value);
      break;

    case param_info::type::UNSIGNED:
      arg.interpreted_value = raw_value;
      break;

    case param_info::type::BOOLEAN:
      arg.interpreted_value = (raw_value != 0);
      break;

    case param_info::type::SIZE:
      arg.interpreted_value = raw_value;
      break;

    case param_info::type::POINTER:
      if (!arg.is_null_pointer && config_.follow_pointers) {
        // try to read string preview
        auto str = arg_utils::read_string(raw_value, memory, 64);
        if (str) {
          arg.string_preview = *str;
        }
      }
      break;

    case param_info::type::STRING:
      if (!arg.is_null_pointer && config_.follow_pointers) {
        auto str = arg_utils::read_string(raw_value, memory, config_.max_string_length);
        if (str) {
          arg.interpreted_value = *str;
          arg.string_preview = *str;
        }
      }
      break;

    case param_info::type::PATH:
      if (!arg.is_null_pointer && config_.follow_pointers) {
        auto str = arg_utils::read_string(raw_value, memory, config_.max_string_length);
        if (str) {
          arg.interpreted_value = *str;
          arg.string_preview = *str;
          // future: could add path validation/normalization here
        }
      }
      break;

    case param_info::type::WSTRING:
      if (!arg.is_null_pointer && config_.follow_pointers) {
        auto str = arg_utils::read_wide_string(raw_value, memory, config_.max_string_length);
        if (str) {
          arg.interpreted_value = *str;
          arg.string_preview = *str;
        }
      }
      break;

    case param_info::type::BUFFER:
      if (!arg.is_null_pointer && config_.follow_pointers) {
        // read buffer preview
        auto buffer_result = memory.read_buffer(raw_value, std::min(config_.max_buffer_preview, size_t(256)));
        if (buffer_result) {
          arg.buffer_preview = std::move(buffer_result->data);
          arg.buffer_size = param.buffer_size; // if known
        }
      }
      break;

    case param_info::type::FLAGS:
      arg.interpreted_value = raw_value;
      if (config_.decode_flags && !param.flag_values.empty()) {
        for (const auto& [flag_val, flag_name] : param.flag_values) {
          if (raw_value & flag_val) {
            arg.flag_names.push_back(flag_name);
          }
        }
      }
      break;

    case param_info::type::HANDLE:
    case param_info::type::FILE_DESCRIPTOR:
      arg.interpreted_value = raw_value;
      break;

    case param_info::type::FLOAT: {
      float f = *reinterpret_cast<float*>(&raw_value);
      arg.interpreted_value = static_cast<double>(f);
    } break;

    case param_info::type::DOUBLE:
      arg.interpreted_value = *reinterpret_cast<double*>(&raw_value);
      break;

    default:
      // keep as raw value
      break;
    }

    return arg;
  }

  std::string format_call(const extracted_call_info& call) const {
    std::ostringstream oss;

    // format: module!api(arg1, arg2, ...) = return_value
    if (!call.module_name.empty()) {
      oss << call.module_name << "!";
    }
    oss << call.api_name << "(";

    for (size_t i = 0; i < call.arguments.size(); ++i) {
      if (i > 0) {
        oss << ", ";
      }
      oss << format_argument(call.arguments[i]);
    }

    oss << ")";

    // add return value if available
    if (call.return_value.raw_value != 0 || call.return_value.param_type != param_info::type::UNKNOWN) {
      oss << " = " << format_argument(call.return_value);
    }

    return oss.str();
  }

  extractor_config config_;

private:
  std::shared_ptr<calling_convention_base> default_convention_;
  std::shared_ptr<calling_convention_detector> detector_;
  std::shared_ptr<api_knowledge_db> api_db_;
  mutable std::unordered_map<std::string, calling_convention_ptr> convention_cache_;
  redlog::logger log_;

  std::string format_argument(const extracted_argument& arg) const {
    std::ostringstream oss;

    // special formatting for different types
    if (arg.is_null_pointer) {
      oss << "NULL";
    } else if (std::holds_alternative<std::string>(arg.interpreted_value)) {
      oss << "\"" << std::get<std::string>(arg.interpreted_value) << "\"";
    } else if (std::holds_alternative<bool>(arg.interpreted_value)) {
      oss << (std::get<bool>(arg.interpreted_value) ? "true" : "false");
    } else if (std::holds_alternative<int64_t>(arg.interpreted_value)) {
      oss << std::get<int64_t>(arg.interpreted_value);
    } else if (std::holds_alternative<uint64_t>(arg.interpreted_value)) {
      oss << "0x" << std::hex << std::get<uint64_t>(arg.interpreted_value);
    } else if (std::holds_alternative<double>(arg.interpreted_value)) {
      oss << std::get<double>(arg.interpreted_value);
    } else {
      // raw value
      oss << "0x" << std::hex << arg.raw_value;
    }

    // add type hint if available
    if (!arg.param_name.empty()) {
      oss << " /* " << arg.param_name << " */";
    }

    return oss.str();
  }
};

// public interface implementation

argument_extractor::argument_extractor(
    std::shared_ptr<api_knowledge_db> api_db, std::shared_ptr<calling_convention_detector> detector,
    const extractor_config& config
)
    : pimpl(std::make_unique<impl>(api_db, detector, config)) {}

argument_extractor::argument_extractor(
    std::shared_ptr<calling_convention_base> convention, std::shared_ptr<api_knowledge_db> api_db,
    const extractor_config& config
)
    : pimpl(std::make_unique<impl>(convention, api_db, config)) {}

argument_extractor::~argument_extractor() = default;

extracted_call_info argument_extractor::extract_call(
    const std::string& api_name, const std::string& module_name, const util::safe_memory_reader& memory,
    const call_context& ctx
) const {
  return pimpl->extract_call(api_name, module_name, memory, ctx);
}

extracted_call_info argument_extractor::extract_call_with_convention(
    const std::string& api_name, const std::string& module_name, calling_convention_ptr convention,
    const util::safe_memory_reader& memory, const call_context& ctx
) const {
  return pimpl->extract_call_with_convention(api_name, module_name, convention, memory, ctx);
}

void argument_extractor::extract_return_value(
    extracted_call_info& call_info, const util::safe_memory_reader& memory, const call_context& ctx
) const {
  pimpl->extract_return_value(call_info, memory, ctx);
}

extracted_argument argument_extractor::extract_argument(
    const param_info& param, uint64_t raw_value, const util::safe_memory_reader& memory
) const {
  return pimpl->extract_argument(param, raw_value, memory);
}

std::string argument_extractor::format_call(const extracted_call_info& call) const { return pimpl->format_call(call); }

const extractor_config& argument_extractor::get_config() const { return pimpl->config_; }

void argument_extractor::set_config(const extractor_config& config) { pimpl->config_ = config; }

// utility functions implementation

namespace arg_utils {

bool is_valid_pointer(uint64_t addr, const util::safe_memory_reader& memory) {
  if (addr == 0) {
    return false;
  }

  // try to read one byte
  auto byte = memory.read<uint8_t>(addr);
  return byte.has_value();
}

std::optional<std::string> read_string(uint64_t addr, const util::safe_memory_reader& memory, size_t max_length) {

  if (addr == 0) {
    return std::nullopt;
  }

  std::string result;
  result.reserve(std::min(max_length, size_t(256)));

  for (size_t i = 0; i < max_length; ++i) {
    auto ch_opt = memory.read<char>(addr + i);
    if (!ch_opt) {
      break;
    }
    char ch = *ch_opt;
    if (ch == '\0') {
      return result;
    }
    result.push_back(ch);
  }

  // didn't find null terminator
  return result;
}

std::optional<std::string> read_wide_string(uint64_t addr, const util::safe_memory_reader& memory, size_t max_length) {

  if (addr == 0) {
    return std::nullopt;
  }

  std::string result;
  result.reserve(std::min(max_length, size_t(256)));

  for (size_t i = 0; i < max_length; ++i) {
    auto wch_opt = memory.read<uint16_t>(addr + i * 2);
    if (!wch_opt) {
      break;
    }
    uint16_t wch = *wch_opt;
    if (wch == 0) {
      return result;
    }
    // simple ascii conversion
    if (wch < 128) {
      result.push_back(static_cast<char>(wch));
    } else {
      result.push_back('?');
    }
  }

  return result;
}

std::string format_pointer(uint64_t addr) {
  std::ostringstream oss;
  oss << "0x" << std::hex << addr;
  return oss.str();
}

std::vector<std::string> decode_flags(uint32_t flags, const std::string& flag_type) {
  std::vector<std::string> result;

  // todo: implement common flag decoding based on flag_type
  // for now just return hex representation
  if (flags != 0) {
    std::ostringstream oss;
    oss << "0x" << std::hex << flags;
    result.push_back(oss.str());
  }

  return result;
}

} // namespace arg_utils

} // namespace w1::abi
```

`src/w1tn3ss/abi/argument_extractor.hpp`:

```hpp
#pragma once

#include "calling_convention_base.hpp"
#include "calling_convention_factory.hpp"
#include "calling_convention_detector.hpp"
#include "api_knowledge_db.hpp"
#include "util/safe_memory.hpp"
#include <redlog.hpp>
#include <vector>
#include <string>
#include <variant>
#include <optional>
#include <memory>

namespace w1::abi {

// represents an extracted argument value with semantic meaning
struct extracted_argument {
  // raw value from register/stack
  uint64_t raw_value = 0;

  // semantic interpretation of the value
  std::variant<
      std::monostate,       // no interpretation
      int64_t,              // signed integer
      uint64_t,             // unsigned integer
      std::string,          // string (null-terminated)
      std::vector<uint8_t>, // raw buffer
      bool,                 // boolean
      double                // floating point
      >
      interpreted_value;

  // metadata about the argument
  param_info::type param_type = param_info::type::UNKNOWN;
  std::string param_name;
  std::string string_preview; // for pointers to strings
  std::string type_description;
  bool is_null_pointer = false;
  bool is_valid_pointer = false;

  // for buffers
  size_t buffer_size = 0;
  std::vector<uint8_t> buffer_preview; // first n bytes

  // for flags
  std::vector<std::string> flag_names; // decoded flag names
};

// represents all extracted arguments for an api call
struct extracted_call_info {
  std::string api_name;
  std::string module_name;
  std::vector<extracted_argument> arguments;
  extracted_argument return_value; // for post-call analysis

  // api metadata
  api_info::category category = api_info::category::UNKNOWN;
  uint32_t behavior_flags = 0;
  std::string description;

  // timing
  uint64_t timestamp = 0;
  uint64_t call_address = 0;
  uint64_t return_address = 0;
};

// configuration for argument extraction
struct extractor_config {
  size_t max_string_length = 256; // max chars to read for strings
  size_t max_buffer_preview = 64; // max bytes to preview for buffers
  bool follow_pointers = true;    // dereference pointers
  bool decode_flags = true;       // decode flag values
  bool extract_structs = false;   // attempt to parse known structs
  bool safe_memory_only = true;   // only read from safe memory regions
};

// context for a function call
struct call_context {
  QBDI::VMInstanceRef vm;
  QBDI::GPRState* gpr;
  QBDI::FPRState* fpr;
  uint64_t call_address;
  uint64_t target_address;
};

// extracts and interprets function arguments
class argument_extractor {
public:
  // new constructor that supports dynamic convention selection
  argument_extractor(
      std::shared_ptr<api_knowledge_db> api_db, std::shared_ptr<calling_convention_detector> detector = nullptr,
      const extractor_config& config = {}
  );

  // legacy constructor for compatibility
  argument_extractor(
      std::shared_ptr<calling_convention_base> convention, std::shared_ptr<api_knowledge_db> api_db,
      const extractor_config& config = {}
  );

  ~argument_extractor();

  // extract arguments for a function call with automatic convention detection
  extracted_call_info extract_call(
      const std::string& api_name, const std::string& module_name, const util::safe_memory_reader& memory,
      const call_context& ctx
  ) const;

  // extract with explicit convention
  extracted_call_info extract_call_with_convention(
      const std::string& api_name, const std::string& module_name, calling_convention_ptr convention,
      const util::safe_memory_reader& memory, const call_context& ctx
  ) const;

  // extract return value after function returns
  void extract_return_value(
      extracted_call_info& call_info, const util::safe_memory_reader& memory, const call_context& ctx
  ) const;

  // extract a single argument
  extracted_argument extract_argument(
      const param_info& param, uint64_t raw_value, const util::safe_memory_reader& memory
  ) const;

  // format extracted call for display
  std::string format_call(const extracted_call_info& call) const;

  // get/set configuration
  const extractor_config& get_config() const;
  void set_config(const extractor_config& config);

private:
  class impl;
  std::unique_ptr<impl> pimpl;
};

// utility functions for argument interpretation
namespace arg_utils {
// check if pointer looks valid
bool is_valid_pointer(uint64_t addr, const util::safe_memory_reader& memory);

// read null-terminated string
std::optional<std::string> read_string(uint64_t addr, const util::safe_memory_reader& memory, size_t max_length = 256);

// read wide string (windows)
std::optional<std::string> read_wide_string(
    uint64_t addr, const util::safe_memory_reader& memory, size_t max_length = 256
);

// format pointer value
std::string format_pointer(uint64_t addr);

// decode common flag values
std::vector<std::string> decode_flags(uint32_t flags, const std::string& flag_type);
} // namespace arg_utils

} // namespace w1::abi
```

`src/w1tn3ss/abi/calling_convention_base.hpp`:

```hpp
#pragma once

#include <QBDI.h>
#include <memory>
#include <vector>
#include <optional>
#include <string>
#include <functional>
#include <cstdint>

namespace w1::abi {

// calling convention identifier
enum class calling_convention_id {
  UNKNOWN,
  // x86-64 conventions
  X86_64_SYSTEM_V,  // linux/macos x64
  X86_64_MICROSOFT, // windows x64
  // x86 conventions
  X86_CDECL,      // c calling convention
  X86_STDCALL,    // standard call (win32 api)
  X86_FASTCALL,   // fast call (register-based)
  X86_THISCALL,   // c++ member functions
  X86_VECTORCALL, // simd optimized
  // arm conventions
  AARCH64_AAPCS,   // arm 64-bit standard
  AARCH64_WINDOWS, // windows arm64
  ARM32_AAPCS,     // arm 32-bit
  // special
  CUSTOM // user-defined
};

// architecture type
enum class architecture { X86, X86_64, ARM32, AARCH64 };

// abstract base class for all calling conventions
class calling_convention_base {
public:
  virtual ~calling_convention_base() = default;

  // metadata
  virtual calling_convention_id get_id() const = 0;
  virtual std::string get_name() const = 0;
  virtual architecture get_architecture() const = 0;
  virtual std::string get_description() const = 0;

  // extraction context with all necessary data
  struct extraction_context {
    const QBDI::GPRState* gpr;
    const QBDI::FPRState* fpr;
    std::function<uint64_t(uint64_t addr)> read_stack; // safe stack reading function
  };

  // extract integer/pointer arguments
  virtual std::vector<uint64_t> extract_integer_args(const extraction_context& ctx, size_t count) const = 0;

  // argument type classification
  enum class arg_type { INTEGER, POINTER, FLOAT, DOUBLE, SIMD, STRUCT_BY_VALUE, STRUCT_BY_REF };

  // typed argument with value and metadata
  struct typed_arg {
    arg_type type;
    union {
      uint64_t integer;
      float f32;
      double f64;
      uint8_t simd[16];
      struct {
        uint64_t data[4]; // for small structs
        size_t size;
      } struct_data;
    } value;
    bool from_stack = false;
    size_t stack_offset = 0;
  };

  // extract typed arguments with type awareness
  virtual std::vector<typed_arg> extract_typed_args(
      const extraction_context& ctx, const std::vector<arg_type>& types
  ) const = 0;

  // return value extraction
  virtual uint64_t get_integer_return(const QBDI::GPRState* gpr) const = 0;
  virtual double get_float_return(const QBDI::FPRState* fpr) const = 0;
  virtual typed_arg get_typed_return(const QBDI::GPRState* gpr, const QBDI::FPRState* fpr, arg_type type) const = 0;

  // stack management
  virtual uint64_t get_stack_pointer(const QBDI::GPRState* gpr) const = 0;
  virtual uint64_t get_frame_pointer(const QBDI::GPRState* gpr) const = 0;
  virtual size_t get_stack_alignment() const = 0;
  virtual size_t get_red_zone_size() const { return 0; }

  // shadow space (windows x64 specific, but can be generalized)
  virtual size_t get_shadow_space_size() const { return 0; }

  // return address location
  virtual uint64_t get_return_address_location(const QBDI::GPRState* gpr) const = 0;

  // variadic function support
  struct variadic_info {
    size_t fixed_args;
    size_t gp_offset; // for system v
    size_t fp_offset;
    uint64_t overflow_arg_area;
    uint64_t reg_save_area;
  };

  virtual bool supports_varargs() const = 0;
  virtual std::optional<variadic_info> get_variadic_info(
      const extraction_context& ctx, size_t fixed_arg_count
  ) const = 0;

  // register preservation info
  struct register_info {
    std::vector<std::string> callee_saved_gpr;
    std::vector<std::string> caller_saved_gpr;
    std::vector<std::string> callee_saved_fpr;
    std::vector<std::string> caller_saved_fpr;
    std::string return_register;
    std::vector<std::string> argument_registers;
  };

  virtual register_info get_register_info() const = 0;

  // helper to check if convention matches current platform
  virtual bool is_native_for_current_platform() const = 0;

  // stack cleanup info
  enum class stack_cleanup {
    CALLER, // caller cleans up (cdecl)
    CALLEE, // callee cleans up (stdcall)
    HYBRID  // depends on function (fastcall with varargs)
  };

  virtual stack_cleanup get_stack_cleanup() const = 0;

  // helper for floating point arguments
  virtual std::vector<double> extract_float_args(const extraction_context& ctx, size_t count) const = 0;
};

// shared pointer type for convenience
using calling_convention_ptr = std::shared_ptr<calling_convention_base>;

// helper to convert enum to string
inline std::string to_string(calling_convention_id id) {
  switch (id) {
  case calling_convention_id::UNKNOWN:
    return "unknown";
  case calling_convention_id::X86_64_SYSTEM_V:
    return "x86_64_system_v";
  case calling_convention_id::X86_64_MICROSOFT:
    return "x86_64_microsoft";
  case calling_convention_id::X86_CDECL:
    return "x86_cdecl";
  case calling_convention_id::X86_STDCALL:
    return "x86_stdcall";
  case calling_convention_id::X86_FASTCALL:
    return "x86_fastcall";
  case calling_convention_id::X86_THISCALL:
    return "x86_thiscall";
  case calling_convention_id::X86_VECTORCALL:
    return "x86_vectorcall";
  case calling_convention_id::AARCH64_AAPCS:
    return "aarch64_aapcs";
  case calling_convention_id::AARCH64_WINDOWS:
    return "aarch64_windows";
  case calling_convention_id::ARM32_AAPCS:
    return "arm32_aapcs";
  case calling_convention_id::CUSTOM:
    return "custom";
  default:
    return "invalid";
  }
}

inline std::string to_string(architecture arch) {
  switch (arch) {
  case architecture::X86:
    return "x86";
  case architecture::X86_64:
    return "x86_64";
  case architecture::ARM32:
    return "arm32";
  case architecture::AARCH64:
    return "aarch64";
  default:
    return "unknown";
  }
}

} // namespace w1::abi
```

`src/w1tn3ss/abi/calling_convention_detector.cpp`:

```cpp
#include "calling_convention_detector.hpp"
#include "calling_convention_factory.hpp"
#include <redlog.hpp>
#include <algorithm>
#include <cctype>

namespace w1::abi {

calling_convention_detector::calling_convention_detector() { initialize_default_rules(); }

void calling_convention_detector::initialize_default_rules() {
#ifdef _WIN32
  // windows system dlls typically use stdcall on x86
  add_rule(
      {std::regex("(kernel32|user32|ntdll|advapi32|gdi32)\\.dll", std::regex_constants::icase), std::regex(".*"),
#ifdef _WIN64
       calling_convention_id::X86_64_MICROSOFT,
#else
       calling_convention_id::X86_STDCALL,
#endif
       100}
  );

  // msvcrt uses cdecl
  add_rule(
      {std::regex("msvcrt.*\\.dll", std::regex_constants::icase), std::regex(".*"),
#ifdef _WIN64
       calling_convention_id::X86_64_MICROSOFT,
#else
       calling_convention_id::X86_CDECL,
#endif
       90}
  );
#endif
}

calling_convention_ptr calling_convention_detector::detect(
    const std::string& binary_path, const std::string& symbol_name, const api_knowledge_db* api_db
) const {

  // extract module name from path
  size_t last_slash = binary_path.find_last_of("/\\");
  std::string module_name = (last_slash != std::string::npos) ? binary_path.substr(last_slash + 1) : binary_path;

  // check api database first if provided
  if (api_db) {
    auto api_convention = lookup_api_convention(module_name, symbol_name, api_db);
    if (api_convention && *api_convention != calling_convention_id::UNKNOWN) {
      return calling_convention_factory::instance().create(*api_convention);
    }
  }

  // check custom rules
  for (const auto& rule : rules_) {
    if (std::regex_match(module_name, rule.module_pattern) && std::regex_match(symbol_name, rule.symbol_pattern)) {
      return calling_convention_factory::instance().create(rule.convention);
    }
  }

  // try symbol-based detection
  return detect_from_symbol(symbol_name, api_db);
}

calling_convention_ptr calling_convention_detector::detect_from_module(
    const util::module_info& module, const std::string& symbol_name, const api_knowledge_db* api_db
) const {

  return detect(module.path, symbol_name, api_db);
}

calling_convention_ptr calling_convention_detector::detect_from_symbol(
    const std::string& symbol_name, const api_knowledge_db* api_db
) const {

  // if api database provided, try looking up by symbol name only
  if (api_db) {
    auto api_info = api_db->lookup(symbol_name);
    if (api_info && api_info->convention != calling_convention_id::UNKNOWN) {
      return calling_convention_factory::instance().create(api_info->convention);
    }
  }

#ifdef _WIN32
#ifdef _WIN64
  // windows x64 always uses microsoft convention
  return calling_convention_factory::instance().create(calling_convention_id::X86_64_MICROSOFT);
#else
  // windows x86 - parse decorated names
  auto decorated = parse_decorated_name(symbol_name);
  if (decorated) {
    return calling_convention_factory::instance().create(decorated->convention);
  }
  // default to cdecl if no decoration
  return calling_convention_factory::instance().create(calling_convention_id::X86_CDECL);
#endif
#else
  // unix platforms
  return get_platform_default();
#endif
}

calling_convention_ptr calling_convention_detector::get_platform_default() const {
  return calling_convention_factory::instance().create_default();
}

void calling_convention_detector::add_rule(const detection_rule& rule) {
  // insert sorted by priority (highest first)
  auto it = std::lower_bound(rules_.begin(), rules_.end(), rule, [](const detection_rule& a, const detection_rule& b) {
    return a.priority > b.priority;
  });
  rules_.insert(it, rule);
}

void calling_convention_detector::clear_rules() { rules_.clear(); }

std::optional<calling_convention_id> calling_convention_detector::lookup_api_convention(
    const std::string& module_name, const std::string& symbol_name, const api_knowledge_db* api_db
) const {
  if (!api_db) {
    return std::nullopt;
  }

  // try lookup by module and symbol name first
  auto api_info = api_db->lookup(module_name, symbol_name);
  if (api_info && api_info->convention != calling_convention_id::UNKNOWN) {
    return api_info->convention;
  }

  // fallback to symbol name only
  api_info = api_db->lookup(symbol_name);
  if (api_info && api_info->convention != calling_convention_id::UNKNOWN) {
    return api_info->convention;
  }

  return std::nullopt;
}

std::optional<calling_convention_detector::decorated_info> calling_convention_detector::parse_decorated_name(
    const std::string& decorated_name
) const {

  if (decorated_name.empty()) {
    return std::nullopt;
  }

  decorated_info info;

  // c++ member functions often start with ?
  if (decorated_name[0] == '?') {
    // simplified c++ name parsing
    info.convention = calling_convention_id::X86_THISCALL;
    info.has_this_pointer = true;
    info.undecorated_name = decorated_name; // would need full undecoration
    return info;
  }

  // stdcall: _func@12 (underscore prefix, @bytes suffix)
  if (decorated_name[0] == '_') {
    size_t at_pos = decorated_name.find('@');
    if (at_pos != std::string::npos && at_pos > 1) {
      // extract stack bytes
      std::string bytes_str = decorated_name.substr(at_pos + 1);
      if (std::all_of(bytes_str.begin(), bytes_str.end(), ::isdigit)) {
        info.convention = calling_convention_id::X86_STDCALL;
        info.stack_cleanup = std::stoul(bytes_str);
        info.undecorated_name = decorated_name.substr(1, at_pos - 1);
        return info;
      }
    }
  }

  // fastcall: @func@12 (@ prefix, @bytes suffix)
  if (decorated_name[0] == '@') {
    size_t at_pos = decorated_name.find('@', 1);
    if (at_pos != std::string::npos) {
      // extract stack bytes
      std::string bytes_str = decorated_name.substr(at_pos + 1);
      if (std::all_of(bytes_str.begin(), bytes_str.end(), ::isdigit)) {
        info.convention = calling_convention_id::X86_FASTCALL;
        info.stack_cleanup = std::stoul(bytes_str);
        info.undecorated_name = decorated_name.substr(1, at_pos - 1);
        return info;
      }
    }
  }

  // vectorcall: func@@12 (double @ before bytes)
  size_t double_at = decorated_name.find("@@");
  if (double_at != std::string::npos) {
    std::string bytes_str = decorated_name.substr(double_at + 2);
    if (!bytes_str.empty() && std::all_of(bytes_str.begin(), bytes_str.end(), ::isdigit)) {
      info.convention = calling_convention_id::X86_VECTORCALL;
      info.stack_cleanup = std::stoul(bytes_str);
      info.undecorated_name = decorated_name.substr(0, double_at);
      return info;
    }
  }

  // no decoration = cdecl
  info.convention = calling_convention_id::X86_CDECL;
  info.stack_cleanup = 0; // caller cleans stack
  info.undecorated_name = decorated_name;
  return info;
}

calling_convention_id calling_convention_detector::detect_windows_x86(const std::string& symbol_name) const {

  auto decorated = parse_decorated_name(symbol_name);
  if (decorated) {
    return decorated->convention;
  }
  return calling_convention_id::X86_CDECL;
}

calling_convention_id calling_convention_detector::detect_windows_x64(const std::string& module_name) const {

  // windows x64 only has one calling convention
  return calling_convention_id::X86_64_MICROSOFT;
}

calling_convention_id calling_convention_detector::detect_unix_convention() const {
#if defined(__x86_64__)
  return calling_convention_id::X86_64_SYSTEM_V;
#elif defined(__aarch64__)
  return calling_convention_id::AARCH64_AAPCS;
#elif defined(__arm__)
  return calling_convention_id::ARM32_AAPCS;
#elif defined(__i386__)
  return calling_convention_id::X86_CDECL;
#else
  return calling_convention_id::UNKNOWN;
#endif
}

calling_convention_id calling_convention_detector::detect_arm_convention() const {
#ifdef _WIN32
#ifdef __aarch64__
  return calling_convention_id::AARCH64_WINDOWS;
#else
  return calling_convention_id::ARM32_AAPCS; // simplified
#endif
#else
#ifdef __aarch64__
  return calling_convention_id::AARCH64_AAPCS;
#else
  return calling_convention_id::ARM32_AAPCS;
#endif
#endif
}

} // namespace w1::abi
```

`src/w1tn3ss/abi/calling_convention_detector.hpp`:

```hpp
#pragma once

#include "calling_convention_base.hpp"
#include "api_knowledge_db.hpp"
#include "util/module_info.hpp"
#include <regex>
#include <vector>
#include <optional>

namespace w1::abi {

/**
 * @brief detects calling conventions from symbols and module information
 *
 * supports:
 * - windows decorated names (_func@12, @func@8, etc.)
 * - module-based heuristics (kernel32.dll -> stdcall)
 * - platform defaults
 * - custom rules
 */
class calling_convention_detector {
public:
  calling_convention_detector();

  // detect convention from binary and symbol
  calling_convention_ptr detect(
      const std::string& binary_path, const std::string& symbol_name, const api_knowledge_db* api_db = nullptr
  ) const;

  // detect from module info
  calling_convention_ptr detect_from_module(
      const util::module_info& module, const std::string& symbol_name, const api_knowledge_db* api_db = nullptr
  ) const;

  // detect from symbol name alone
  calling_convention_ptr detect_from_symbol(
      const std::string& symbol_name, const api_knowledge_db* api_db = nullptr
  ) const;

  // platform-specific detection rules
  struct detection_rule {
    std::regex module_pattern;
    std::regex symbol_pattern;
    calling_convention_id convention;
    int priority = 0; // higher priority rules match first
  };

  // add custom detection rule
  void add_rule(const detection_rule& rule);

  // clear all custom rules
  void clear_rules();

  // get default convention for current platform
  calling_convention_ptr get_platform_default() const;

  // windows decorated name information
  struct decorated_info {
    calling_convention_id convention;
    size_t stack_cleanup = 0;      // bytes cleaned by callee
    bool has_this_pointer = false; // c++ member function
    std::string undecorated_name;
  };

  // parse windows decorated name
  std::optional<decorated_info> parse_decorated_name(const std::string& decorated_name) const;

private:
  std::vector<detection_rule> rules_;

  // initialize default rules
  void initialize_default_rules();

  // api database lookup
  std::optional<calling_convention_id> lookup_api_convention(
      const std::string& module_name, const std::string& symbol_name, const api_knowledge_db* api_db
  ) const;

  // windows-specific detection
  calling_convention_id detect_windows_x86(const std::string& symbol_name) const;

  calling_convention_id detect_windows_x64(const std::string& module_name) const;

  // unix-specific detection
  calling_convention_id detect_unix_convention() const;

  // arm-specific detection
  calling_convention_id detect_arm_convention() const;
};

} // namespace w1::abi
```

`src/w1tn3ss/abi/calling_convention_factory.cpp`:

```cpp
#include "calling_convention_factory.hpp"
#include <redlog.hpp>
#include <stdexcept>

// include platform-specific convention headers
#if defined(__x86_64__) || defined(_M_X64)
#include "conventions/x86_64/system_v.hpp"
#include "conventions/x86_64/microsoft.hpp"
#elif defined(__i386__) || defined(_M_IX86)
#include "conventions/x86/cdecl.hpp"
// todo: add when implemented
// #include "conventions/x86/stdcall.hpp"
// #include "conventions/x86/fastcall.hpp"
// #include "conventions/x86/thiscall.hpp"
#elif defined(__aarch64__) || defined(_M_ARM64)
#include "conventions/arm/aarch64_aapcs.hpp"
#elif defined(__arm__) || defined(_M_ARM)
// todo: add when implemented
// #include "conventions/arm/arm32_aapcs.hpp"
#endif

namespace w1::abi {

calling_convention_factory& calling_convention_factory::instance() {
  static calling_convention_factory instance;
  static std::once_flag init_flag;
  std::call_once(init_flag, [&]() { instance.register_platform_conventions(); });
  return instance;
}

void calling_convention_factory::register_convention(
    calling_convention_id id, std::function<calling_convention_ptr()> creator
) {

  std::lock_guard<std::mutex> lock(mutex_);

  if (creators_.find(id) != creators_.end()) {
    log_.wrn("overwriting existing convention registration", redlog::field("id", to_string(id)));
  }

  creators_[id] = creator;
  name_to_id_[to_string(id)] = id;

  log_.dbg(
      "registered calling convention", redlog::field("id", to_string(id)), redlog::field("total", creators_.size())
  );
}

calling_convention_ptr calling_convention_factory::create(calling_convention_id id) const {
  std::lock_guard<std::mutex> lock(mutex_);

  auto it = creators_.find(id);
  if (it == creators_.end()) {
    throw std::runtime_error("calling convention not registered: " + to_string(id));
  }

  return it->second();
}

calling_convention_ptr calling_convention_factory::create_by_name(const std::string& name) const {
  std::lock_guard<std::mutex> lock(mutex_);

  auto it = name_to_id_.find(name);
  if (it == name_to_id_.end()) {
    throw std::runtime_error("unknown calling convention name: " + name);
  }

  return create(it->second);
}

calling_convention_ptr calling_convention_factory::create_default() const { return create(get_platform_default()); }

std::vector<calling_convention_id> calling_convention_factory::list_conventions() const {
  std::lock_guard<std::mutex> lock(mutex_);

  std::vector<calling_convention_id> result;
  result.reserve(creators_.size());

  for (const auto& [id, creator] : creators_) {
    result.push_back(id);
  }

  return result;
}

calling_convention_ptr calling_convention_factory::create_for_symbol(
    const std::string& module_name, const std::string& symbol_name
) const {

// platform-specific heuristics
#ifdef _WIN32
  // windows x86 decorated names
  if (symbol_name.size() > 0) {
    if (symbol_name[0] == '_' && symbol_name.find('@') != std::string::npos) {
      // _func@12 -> stdcall
      return create(calling_convention_id::X86_STDCALL);
    } else if (symbol_name[0] == '@' && symbol_name.find('@') != std::string::npos) {
      // @func@8 -> fastcall
      return create(calling_convention_id::X86_FASTCALL);
    } else if (symbol_name.find("@@") != std::string::npos) {
      // ?func@@ -> thiscall (c++ member)
      return create(calling_convention_id::X86_THISCALL);
    }
  }

  // windows api dlls typically use stdcall on x86
  if (module_name.find("kernel32") != std::string::npos || module_name.find("user32") != std::string::npos ||
      module_name.find("ntdll") != std::string::npos) {
#ifdef _WIN64
    return create(calling_convention_id::X86_64_MICROSOFT);
#else
    return create(calling_convention_id::X86_STDCALL);
#endif
  }
#endif

  // default to platform convention
  return create_default();
}

bool calling_convention_factory::is_registered(calling_convention_id id) const {
  std::lock_guard<std::mutex> lock(mutex_);
  return creators_.find(id) != creators_.end();
}

void calling_convention_factory::register_platform_conventions() {

// Register conventions based on current platform
#if defined(__x86_64__) || defined(_M_X64)
  register_x86_64_conventions();
#elif defined(__i386__) || defined(_M_IX86)
  register_x86_conventions();
#elif defined(__aarch64__) || defined(_M_ARM64)
  register_arm64_conventions();
#elif defined(__arm__) || defined(_M_ARM)
  register_arm_conventions();
#else
#error "Unsupported platform for calling conventions"
#endif

  // Determine platform string for logging
  const char* platform_str =
#if defined(__x86_64__) || defined(_M_X64)
      "x86_64"
#elif defined(__i386__) || defined(_M_IX86)
      "x86"
#elif defined(__aarch64__) || defined(_M_ARM64)
      "aarch64"
#elif defined(__arm__) || defined(_M_ARM)
      "arm"
#else
      "unknown"
#endif
      ;

  log_.inf(
      "registered platform conventions", redlog::field("platform", platform_str),
      redlog::field("count", creators_.size())
  );
}

void calling_convention_factory::register_x86_conventions() {
#if defined(__i386__) || defined(_M_IX86)
  // x86 supports multiple calling conventions, especially on windows

  // cdecl is available on all platforms
  register_convention(calling_convention_id::X86_CDECL, []() { return std::make_shared<conventions::x86_cdecl>(); });

#ifdef _WIN32
// windows-specific calling conventions
// TODO: implement these conventions
/*
register_convention(
    calling_convention_id::X86_STDCALL,
    []() { return std::make_shared<conventions::x86_stdcall>(); }
);

register_convention(
    calling_convention_id::X86_FASTCALL,
    []() { return std::make_shared<conventions::x86_fastcall>(); }
);

register_convention(
    calling_convention_id::X86_THISCALL,
    []() { return std::make_shared<conventions::x86_thiscall>(); }
);

register_convention(
    calling_convention_id::X86_VECTORCALL,
    []() { return std::make_shared<conventions::x86_vectorcall>(); }
);
*/
#endif
#endif
}

void calling_convention_factory::register_x86_64_conventions() {
#if defined(__x86_64__) || defined(_M_X64)
  // x86-64 conventions depend on the operating system

#ifdef _WIN32
  // windows x64 uses microsoft convention
  register_convention(calling_convention_id::X86_64_MICROSOFT, []() {
    return std::make_shared<conventions::x86_64_microsoft>();
  });
// TODO: implement vectorcall for SIMD-heavy code
// register_convention(
//     calling_convention_id::X86_64_VECTORCALL,
//     []() { return std::make_shared<conventions::x86_64_vectorcall>(); }
// );
#else
  // unix platforms (linux, macos, bsd) use system v abi
  register_convention(calling_convention_id::X86_64_SYSTEM_V, []() {
    return std::make_shared<conventions::x86_64_system_v>();
  });
#endif
#endif
}

void calling_convention_factory::register_arm_conventions() {
#if defined(__arm__) || defined(_M_ARM)
// TODO: implement ARM32 conventions
/*
register_convention(
    calling_convention_id::ARM32_AAPCS,
    []() { return std::make_shared<conventions::arm32_aapcs>(); }
);
*/
#endif
}

void calling_convention_factory::register_arm64_conventions() {
#if defined(__aarch64__) || defined(_M_ARM64)
  // arm64 uses aapcs on both windows and unix
  register_convention(calling_convention_id::AARCH64_AAPCS, []() {
    return std::make_shared<conventions::aarch64_aapcs>();
  });

// windows arm64 has slight variations
#ifdef _WIN32
// TODO: implement windows arm64 specific convention if needed
#endif
#endif
}

calling_convention_id calling_convention_factory::get_platform_default() const {
#if defined(_WIN64)
  return calling_convention_id::X86_64_MICROSOFT;
#elif defined(__x86_64__)
  return calling_convention_id::X86_64_SYSTEM_V;
#elif defined(__aarch64__)
#ifdef _WIN32
  return calling_convention_id::AARCH64_WINDOWS;
#else
  return calling_convention_id::AARCH64_AAPCS;
#endif
#elif defined(__arm__)
  return calling_convention_id::ARM32_AAPCS;
#elif defined(_WIN32)
  // 32-bit windows defaults to stdcall for system apis
  return calling_convention_id::X86_STDCALL;
#elif defined(__i386__)
  return calling_convention_id::X86_CDECL;
#else
#error "unsupported platform for default calling convention"
#endif
}

} // namespace w1::abi
```

`src/w1tn3ss/abi/calling_convention_factory.hpp`:

```hpp
#pragma once

#include "calling_convention_base.hpp"
#include <unordered_map>
#include <mutex>
#include <functional>
#include <redlog.hpp>

namespace w1::abi {

// factory for creating calling convention instances
class calling_convention_factory {
public:
  // singleton instance
  static calling_convention_factory& instance();

  // prevent copying
  calling_convention_factory(const calling_convention_factory&) = delete;
  calling_convention_factory& operator=(const calling_convention_factory&) = delete;

  // register a convention creator
  void register_convention(calling_convention_id id, std::function<calling_convention_ptr()> creator);

  // create convention by id
  calling_convention_ptr create(calling_convention_id id) const;

  // create convention by name
  calling_convention_ptr create_by_name(const std::string& name) const;

  // get default convention for current platform
  calling_convention_ptr create_default() const;

  // list all registered conventions
  std::vector<calling_convention_id> list_conventions() const;

  // get convention for a specific module/function
  calling_convention_ptr create_for_symbol(const std::string& module_name, const std::string& symbol_name) const;

  // check if convention is registered
  bool is_registered(calling_convention_id id) const;

private:
  calling_convention_factory() : log_("w1.calling_convention_factory") {}

  mutable std::mutex mutex_;
  std::unordered_map<calling_convention_id, std::function<calling_convention_ptr()>> creators_;
  std::unordered_map<std::string, calling_convention_id> name_to_id_;
  redlog::logger log_;

  // platform-specific default selection
  calling_convention_id get_platform_default() const;

  // register all conventions for current platform
  void register_platform_conventions();

  // register specific platform conventions
  void register_x86_conventions();
  void register_x86_64_conventions();
  void register_arm_conventions();
  void register_arm64_conventions();
};

// convenience function
inline calling_convention_ptr create_calling_convention(calling_convention_id id) {
  return calling_convention_factory::instance().create(id);
}

// convenience function for default convention
inline calling_convention_ptr create_default_calling_convention() {
  return calling_convention_factory::instance().create_default();
}

} // namespace w1::abi
```

`src/w1tn3ss/abi/conventions/arm/aarch64_aapcs.cpp`:

```cpp
#include "aarch64_aapcs.hpp"
#include <redlog.hpp>

namespace w1::abi::conventions {

std::vector<uint64_t> aarch64_aapcs::extract_integer_args(const extraction_context& ctx, size_t count) const {

  std::vector<uint64_t> args;
  args.reserve(count);

  // extract register arguments (x0-x7)
  size_t reg_args = std::min(count, size_t(8));
  for (size_t i = 0; i < reg_args; i++) {
    switch (i) {
    case 0:
      args.push_back(ctx.gpr->x0);
      break;
    case 1:
      args.push_back(ctx.gpr->x1);
      break;
    case 2:
      args.push_back(ctx.gpr->x2);
      break;
    case 3:
      args.push_back(ctx.gpr->x3);
      break;
    case 4:
      args.push_back(ctx.gpr->x4);
      break;
    case 5:
      args.push_back(ctx.gpr->x5);
      break;
    case 6:
      args.push_back(ctx.gpr->x6);
      break;
    case 7:
      args.push_back(ctx.gpr->x7);
      break;
    }
  }

  // extract stack arguments if needed
  if (count > 8) {
    // stack arguments start immediately at sp (no return address on stack)
    const uint64_t stack_base = ctx.gpr->sp;

    for (size_t i = 8; i < count; i++) {
      // each argument takes 8 bytes on stack
      uint64_t stack_offset = (i - 8) * 8;
      args.push_back(ctx.read_stack(stack_base + stack_offset));
    }
  }

  return args;
}

std::vector<aarch64_aapcs::typed_arg> aarch64_aapcs::extract_typed_args(
    const extraction_context& ctx, const std::vector<arg_type>& types
) const {

  std::vector<typed_arg> args;
  args.reserve(types.size());

  size_t int_reg_idx = 0;
  size_t float_reg_idx = 0;
  size_t stack_offset = 0;

  for (size_t i = 0; i < types.size(); i++) {
    typed_arg arg;
    arg.type = types[i];

    switch (types[i]) {
    case arg_type::INTEGER:
    case arg_type::POINTER:
      if (int_reg_idx < 8) {
        // from register
        switch (int_reg_idx) {
        case 0:
          arg.value.integer = ctx.gpr->x0;
          break;
        case 1:
          arg.value.integer = ctx.gpr->x1;
          break;
        case 2:
          arg.value.integer = ctx.gpr->x2;
          break;
        case 3:
          arg.value.integer = ctx.gpr->x3;
          break;
        case 4:
          arg.value.integer = ctx.gpr->x4;
          break;
        case 5:
          arg.value.integer = ctx.gpr->x5;
          break;
        case 6:
          arg.value.integer = ctx.gpr->x6;
          break;
        case 7:
          arg.value.integer = ctx.gpr->x7;
          break;
        }
        arg.from_stack = false;
        int_reg_idx++;
      } else {
        // from stack
        arg.value.integer = ctx.read_stack(ctx.gpr->sp + stack_offset);
        arg.from_stack = true;
        arg.stack_offset = stack_offset;
        stack_offset += 8;
      }
      break;

    case arg_type::FLOAT:
      if (float_reg_idx < max_float_reg_args) {
        // from v register (s0-s7)
        // QBDI stores v registers as __uint128_t, we need to extract float
        const __uint128_t* v_regs = reinterpret_cast<const __uint128_t*>(ctx.fpr);
        uint32_t f32_val = static_cast<uint32_t>(v_regs[float_reg_idx]);
        arg.value.f32 = *reinterpret_cast<float*>(&f32_val);
        arg.from_stack = false;
        float_reg_idx++;
      } else {
        // from stack
        uint32_t val = static_cast<uint32_t>(ctx.read_stack(ctx.gpr->sp + stack_offset));
        arg.value.f32 = *reinterpret_cast<float*>(&val);
        arg.from_stack = true;
        arg.stack_offset = stack_offset;
        stack_offset += 8; // still takes 8 bytes on stack
      }
      break;

    case arg_type::DOUBLE:
      if (float_reg_idx < max_float_reg_args) {
        // from v register (d0-d7)
        // QBDI stores v registers as __uint128_t, we need to extract double
        const __uint128_t* v_regs = reinterpret_cast<const __uint128_t*>(ctx.fpr);
        uint64_t f64_val = static_cast<uint64_t>(v_regs[float_reg_idx]);
        arg.value.f64 = *reinterpret_cast<double*>(&f64_val);
        arg.from_stack = false;
        float_reg_idx++;
      } else {
        // from stack
        uint64_t val = ctx.read_stack(ctx.gpr->sp + stack_offset);
        arg.value.f64 = *reinterpret_cast<double*>(&val);
        arg.from_stack = true;
        arg.stack_offset = stack_offset;
        stack_offset += 8;
      }
      break;

    case arg_type::SIMD:
      if (float_reg_idx < max_float_reg_args) {
        // full v register (128-bit)
        const __uint128_t* v_regs = reinterpret_cast<const __uint128_t*>(ctx.fpr);
        memcpy(arg.value.simd, &v_regs[float_reg_idx], 16);
        arg.from_stack = false;
        float_reg_idx++;
      } else {
        // from stack (16 bytes)
        for (int j = 0; j < 16; j++) {
          arg.value.simd[j] = static_cast<uint8_t>(ctx.read_stack(ctx.gpr->sp + stack_offset + j) & 0xFF);
        }
        arg.from_stack = true;
        arg.stack_offset = stack_offset;
        stack_offset += 16;
      }
      break;

    case arg_type::STRUCT_BY_VALUE:
      // small structs may be passed in registers
      // larger structs are passed on stack
      // this is simplified - real implementation would need size info
      if (int_reg_idx < 8) {
        switch (int_reg_idx) {
        case 0:
          arg.value.struct_data.data[0] = ctx.gpr->x0;
          break;
        case 1:
          arg.value.struct_data.data[0] = ctx.gpr->x1;
          break;
        case 2:
          arg.value.struct_data.data[0] = ctx.gpr->x2;
          break;
        case 3:
          arg.value.struct_data.data[0] = ctx.gpr->x3;
          break;
        case 4:
          arg.value.struct_data.data[0] = ctx.gpr->x4;
          break;
        case 5:
          arg.value.struct_data.data[0] = ctx.gpr->x5;
          break;
        case 6:
          arg.value.struct_data.data[0] = ctx.gpr->x6;
          break;
        case 7:
          arg.value.struct_data.data[0] = ctx.gpr->x7;
          break;
        }
        arg.value.struct_data.size = 8;
        arg.from_stack = false;
        int_reg_idx++;
      } else {
        arg.value.struct_data.data[0] = ctx.read_stack(ctx.gpr->sp + stack_offset);
        arg.value.struct_data.size = 8;
        arg.from_stack = true;
        arg.stack_offset = stack_offset;
        stack_offset += 8;
      }
      break;

    case arg_type::STRUCT_BY_REF:
      // passed as pointer
      if (int_reg_idx < 8) {
        switch (int_reg_idx) {
        case 0:
          arg.value.integer = ctx.gpr->x0;
          break;
        case 1:
          arg.value.integer = ctx.gpr->x1;
          break;
        case 2:
          arg.value.integer = ctx.gpr->x2;
          break;
        case 3:
          arg.value.integer = ctx.gpr->x3;
          break;
        case 4:
          arg.value.integer = ctx.gpr->x4;
          break;
        case 5:
          arg.value.integer = ctx.gpr->x5;
          break;
        case 6:
          arg.value.integer = ctx.gpr->x6;
          break;
        case 7:
          arg.value.integer = ctx.gpr->x7;
          break;
        }
        arg.from_stack = false;
        int_reg_idx++;
      } else {
        arg.value.integer = ctx.read_stack(ctx.gpr->sp + stack_offset);
        arg.from_stack = true;
        arg.stack_offset = stack_offset;
        stack_offset += 8;
      }
      break;
    }

    args.push_back(arg);
  }

  return args;
}

aarch64_aapcs::typed_arg aarch64_aapcs::get_typed_return(
    const QBDI::GPRState* gpr, const QBDI::FPRState* fpr, arg_type type
) const {

  typed_arg ret;
  ret.type = type;
  ret.from_stack = false;

  switch (type) {
  case arg_type::INTEGER:
  case arg_type::POINTER:
  case arg_type::STRUCT_BY_REF:
    ret.value.integer = gpr->x0;
    break;

  case arg_type::FLOAT: {
    uint32_t f32_val = static_cast<uint32_t>(fpr->v0);
    ret.value.f32 = *reinterpret_cast<float*>(&f32_val);
  } break;

  case arg_type::DOUBLE: {
    uint64_t f64_val = static_cast<uint64_t>(fpr->v0);
    ret.value.f64 = *reinterpret_cast<double*>(&f64_val);
  } break;

  case arg_type::SIMD:
    memcpy(ret.value.simd, &fpr->v0, 16);
    break;

  case arg_type::STRUCT_BY_VALUE:
    // small structs returned in x0/x1
    ret.value.struct_data.data[0] = gpr->x0;
    ret.value.struct_data.data[1] = gpr->x1;
    ret.value.struct_data.size = 16;
    break;
  }

  return ret;
}

std::optional<aarch64_aapcs::variadic_info> aarch64_aapcs::get_variadic_info(
    const extraction_context& ctx, size_t fixed_arg_count
) const {

  // aarch64 uses a va_list structure similar to x86-64 system v
  variadic_info info;
  info.fixed_args = fixed_arg_count;
  info.gp_offset = fixed_arg_count * 8; // simplified
  info.fp_offset = 0;
  info.overflow_arg_area = ctx.gpr->sp; // stack args
  info.reg_save_area = 0;               // would need to be set up by caller

  return info;
}

aarch64_aapcs::register_info aarch64_aapcs::get_register_info() const {
  return {
      .callee_saved_gpr = {"x19", "x20", "x21", "x22", "x23", "x24", "x25", "x26", "x27", "x28", "x29", "sp"},
      .caller_saved_gpr = {"x0",  "x1",  "x2",  "x3",  "x4",  "x5",  "x6",  "x7",  "x8",  "x9",
                           "x10", "x11", "x12", "x13", "x14", "x15", "x16", "x17", "x18", "x30"},
      .callee_saved_fpr = {"v8", "v9", "v10", "v11", "v12", "v13", "v14", "v15"},
      .caller_saved_fpr = {"v0",  "v1",  "v2",  "v3",  "v4",  "v5",  "v6",  "v7",  "v16", "v17", "v18", "v19",
                           "v20", "v21", "v22", "v23", "v24", "v25", "v26", "v27", "v28", "v29", "v30", "v31"},
      .return_register = "x0",
      .argument_registers = {"x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7"}
  };
}

std::vector<double> aarch64_aapcs::extract_float_args(const extraction_context& ctx, size_t count) const {

  std::vector<double> args;
  args.reserve(count);

  // first 8 float/double args in v0-v7
  size_t reg_args = std::min(count, max_float_reg_args);
  const __uint128_t* v_regs = reinterpret_cast<const __uint128_t*>(ctx.fpr);
  for (size_t i = 0; i < reg_args; i++) {
    uint64_t f64_val = static_cast<uint64_t>(v_regs[i]);
    args.push_back(*reinterpret_cast<double*>(&f64_val));
  }

  // remaining args on stack
  if (count > max_float_reg_args) {
    const uint64_t stack_base = ctx.gpr->sp;

    for (size_t i = max_float_reg_args; i < count; i++) {
      uint64_t stack_offset = (i - max_float_reg_args) * 8;
      uint64_t val = ctx.read_stack(stack_base + stack_offset);
      args.push_back(*reinterpret_cast<double*>(&val));
    }
  }

  return args;
}

} // namespace w1::abi::conventions
```

`src/w1tn3ss/abi/conventions/arm/aarch64_aapcs.hpp`:

```hpp
#pragma once

#include "abi/calling_convention_base.hpp"
#include <array>

namespace w1::abi::conventions {

/**
 * @brief aarch64 aapcs (arm 64-bit application binary interface)
 *
 * used on linux arm64, macos arm64, and other unix-like systems
 *
 * register usage:
 * - integer/pointer arguments: x0-x7 (first 8), then stack
 * - floating-point arguments: v0-v7 (first 8), then stack
 * - return value: x0/x1 (integer), v0/v1 (float)
 * - callee saved: x19-x29, sp
 * - caller saved: x0-x18, x30 (lr)
 *
 * stack layout:
 * - no red zone (unlike x86-64 system v)
 * - stack aligned to 16 bytes at function entry
 * - parameters beyond 8th passed on stack
 *
 * special registers:
 * - x29: frame pointer (fp)
 * - x30: link register (lr) - return address
 * - sp: stack pointer
 */
class aarch64_aapcs : public calling_convention_base {
public:
  // metadata
  calling_convention_id get_id() const override { return calling_convention_id::AARCH64_AAPCS; }

  std::string get_name() const override { return "AArch64 AAPCS"; }

  architecture get_architecture() const override { return architecture::AARCH64; }

  std::string get_description() const override {
    return "ARM 64-bit Application Binary Interface used on Linux and macOS";
  }

  // argument extraction
  std::vector<uint64_t> extract_integer_args(const extraction_context& ctx, size_t count) const override;

  std::vector<typed_arg> extract_typed_args(
      const extraction_context& ctx, const std::vector<arg_type>& types
  ) const override;

  // return values
  uint64_t get_integer_return(const QBDI::GPRState* gpr) const override {
    // return value in x0
    return gpr->x0;
  }

  double get_float_return(const QBDI::FPRState* fpr) const override {
    // return value in v0 (d0)
    uint64_t f64_val = static_cast<uint64_t>(fpr->v0);
    return *reinterpret_cast<double*>(&f64_val);
  }

  typed_arg get_typed_return(const QBDI::GPRState* gpr, const QBDI::FPRState* fpr, arg_type type) const override;

  // stack management
  uint64_t get_stack_pointer(const QBDI::GPRState* gpr) const override { return gpr->sp; }

  uint64_t get_frame_pointer(const QBDI::GPRState* gpr) const override {
    return gpr->x29; // fp register
  }

  size_t get_stack_alignment() const override {
    return 16; // 16-byte alignment
  }

  size_t get_red_zone_size() const override {
    return 0; // no red zone on arm64
  }

  uint64_t get_return_address_location(const QBDI::GPRState* gpr) const override {
    // return address is in lr (x30), not on stack
    return gpr->lr;
  }

  // variadic support
  bool supports_varargs() const override { return true; }

  std::optional<variadic_info> get_variadic_info(const extraction_context& ctx, size_t fixed_arg_count) const override;

  // register info
  register_info get_register_info() const override;

  bool is_native_for_current_platform() const override {
#if defined(__aarch64__) && !defined(_WIN32)
    return true;
#else
    return false;
#endif
  }

  stack_cleanup get_stack_cleanup() const override { return stack_cleanup::CALLER; }

  std::vector<double> extract_float_args(const extraction_context& ctx, size_t count) const override;

private:
  // integer argument registers: x0-x7 (accessed directly)
  static constexpr size_t max_int_reg_args = 8;

  // floating point argument registers: v0-v7
  static constexpr size_t max_float_reg_args = 8;
};

} // namespace w1::abi::conventions
```

`src/w1tn3ss/abi/conventions/x86/cdecl.cpp`:

```cpp
#include "cdecl.hpp"

namespace w1::abi::conventions {

std::vector<uint64_t> x86_cdecl::extract_integer_args(const extraction_context& ctx, size_t count) const {

  std::vector<uint64_t> args;
  args.reserve(count);

  // all arguments on stack, right after return address
  uint32_t esp = static_cast<uint32_t>(ctx.gpr->esp);

  // skip return address (4 bytes)
  for (size_t i = 0; i < count; ++i) {
    uint64_t addr = (esp + 4 + i * 4) & 0xFFFFFFFF;
    uint64_t val = ctx.read_stack(addr);
    args.push_back(val & 0xFFFFFFFF); // 32-bit values
  }

  return args;
}

std::vector<x86_cdecl::typed_arg> x86_cdecl::extract_typed_args(
    const extraction_context& ctx, const std::vector<arg_type>& types
) const {

  std::vector<typed_arg> args;
  args.reserve(types.size());

  uint32_t esp = static_cast<uint32_t>(ctx.gpr->esp);
  size_t stack_offset = 4; // skip return address

  for (const auto& type : types) {
    typed_arg arg;
    arg.type = type;
    arg.from_stack = true;
    arg.stack_offset = stack_offset - 4; // relative to return address

    uint64_t addr = (esp + stack_offset) & 0xFFFFFFFF;

    switch (type) {
    case arg_type::INTEGER:
    case arg_type::POINTER:
      arg.value.integer = ctx.read_stack(addr) & 0xFFFFFFFF;
      stack_offset += 4;
      break;

    case arg_type::FLOAT: {
      uint32_t val = static_cast<uint32_t>(ctx.read_stack(addr));
      arg.value.f32 = *reinterpret_cast<float*>(&val);
      stack_offset += 4;
    } break;

    case arg_type::DOUBLE: {
      // double takes 8 bytes on stack
      uint64_t val = ctx.read_stack(addr);
      uint64_t high = ctx.read_stack((addr + 4) & 0xFFFFFFFF);
      val = (val & 0xFFFFFFFF) | ((high & 0xFFFFFFFF) << 32);
      arg.value.f64 = *reinterpret_cast<double*>(&val);
      stack_offset += 8;
    } break;

    case arg_type::STRUCT_BY_VALUE:
      // simplified - would need size info
      arg.value.struct_data.data[0] = ctx.read_stack(addr) & 0xFFFFFFFF;
      arg.value.struct_data.size = 4;
      stack_offset += 4;
      break;

    case arg_type::STRUCT_BY_REF:
      arg.value.integer = ctx.read_stack(addr) & 0xFFFFFFFF;
      stack_offset += 4;
      break;

    case arg_type::SIMD:
      // not typically used in cdecl
      stack_offset += 16;
      break;
    }

    args.push_back(arg);
  }

  return args;
}

x86_cdecl::typed_arg x86_cdecl::get_typed_return(
    const QBDI::GPRState* gpr, const QBDI::FPRState* fpr, arg_type type
) const {

  typed_arg ret;
  ret.type = type;
  ret.from_stack = false;

  switch (type) {
  case arg_type::INTEGER:
  case arg_type::POINTER:
  case arg_type::STRUCT_BY_REF:
    ret.value.integer = gpr->eax & 0xFFFFFFFF; // eax
    break;

  case arg_type::FLOAT:
  case arg_type::DOUBLE:
    // x87 st(0) - simplified
    ret.value.f64 = 0.0;
    break;

  case arg_type::STRUCT_BY_VALUE:
    // small structs in eax:edx
    ret.value.struct_data.data[0] = gpr->eax & 0xFFFFFFFF;
    ret.value.struct_data.data[1] = gpr->edx & 0xFFFFFFFF;
    ret.value.struct_data.size = 8;
    break;

  case arg_type::SIMD:
    // not typically used
    break;
  }

  return ret;
}

std::optional<x86_cdecl::variadic_info> x86_cdecl::get_variadic_info(
    const extraction_context& ctx, size_t fixed_arg_count
) const {

  // simple stack-based varargs
  variadic_info info;
  info.fixed_args = fixed_arg_count;
  info.gp_offset = 0;
  info.fp_offset = 0;
  info.overflow_arg_area = (ctx.gpr->esp & 0xFFFFFFFF) + 4 + fixed_arg_count * 4;
  info.reg_save_area = 0;

  return info;
}

x86_cdecl::register_info x86_cdecl::get_register_info() const {
  return {
      .callee_saved_gpr = {"ebx", "esi", "edi", "ebp"},
      .caller_saved_gpr = {"eax", "ecx", "edx"},
      .callee_saved_fpr = {}, // x87 stack based
      .caller_saved_fpr = {},
      .return_register = "eax",
      .argument_registers = {} // all on stack
  };
}

std::vector<double> x86_cdecl::extract_float_args(const extraction_context& ctx, size_t count) const {

  std::vector<double> args;
  args.reserve(count);

  uint32_t esp = static_cast<uint32_t>(ctx.gpr->esp);
  size_t stack_offset = 4; // skip return address

  for (size_t i = 0; i < count; ++i) {
    uint64_t addr = (esp + stack_offset) & 0xFFFFFFFF;

    // doubles take 8 bytes
    uint64_t val = ctx.read_stack(addr);
    uint64_t high = ctx.read_stack((addr + 4) & 0xFFFFFFFF);
    val = (val & 0xFFFFFFFF) | ((high & 0xFFFFFFFF) << 32);
    args.push_back(*reinterpret_cast<double*>(&val));

    stack_offset += 8;
  }

  return args;
}

} // namespace w1::abi::conventions
```

`src/w1tn3ss/abi/conventions/x86/cdecl.hpp`:

```hpp
#pragma once

#include "abi/calling_convention_base.hpp"

namespace w1::abi::conventions {

/**
 * @brief x86 cdecl calling convention
 *
 * the default c calling convention for x86
 *
 * characteristics:
 * - all arguments passed on stack (right to left)
 * - caller cleans up stack
 * - return value in eax (edx:eax for 64-bit values)
 * - callee saved: ebx, esi, edi, ebp
 * - caller saved: eax, ecx, edx
 */
class x86_cdecl : public calling_convention_base {
public:
  // metadata
  calling_convention_id get_id() const override { return calling_convention_id::X86_CDECL; }

  std::string get_name() const override { return "x86 cdecl"; }

  architecture get_architecture() const override { return architecture::X86; }

  std::string get_description() const override { return "C declaration calling convention for x86"; }

  // argument extraction
  std::vector<uint64_t> extract_integer_args(const extraction_context& ctx, size_t count) const override;

  std::vector<typed_arg> extract_typed_args(
      const extraction_context& ctx, const std::vector<arg_type>& types
  ) const override;

  // return values
  uint64_t get_integer_return(const QBDI::GPRState* gpr) const override {
    // return value in eax
    return gpr->eax & 0xFFFFFFFF;
  }

  double get_float_return(const QBDI::FPRState* fpr) const override {
    // x87 st(0) - simplified, would need proper x87 stack handling
    return 0.0;
  }

  typed_arg get_typed_return(const QBDI::GPRState* gpr, const QBDI::FPRState* fpr, arg_type type) const override;

  // stack management
  uint64_t get_stack_pointer(const QBDI::GPRState* gpr) const override {
    return gpr->esp & 0xFFFFFFFF; // esp
  }

  uint64_t get_frame_pointer(const QBDI::GPRState* gpr) const override {
    return gpr->ebp & 0xFFFFFFFF; // ebp
  }

  size_t get_stack_alignment() const override {
    return 4; // 4-byte alignment for x86
  }

  uint64_t get_return_address_location(const QBDI::GPRState* gpr) const override {
    // return address is at [esp]
    return gpr->esp & 0xFFFFFFFF;
  }

  // variadic support
  bool supports_varargs() const override { return true; }

  std::optional<variadic_info> get_variadic_info(const extraction_context& ctx, size_t fixed_arg_count) const override;

  // register info
  register_info get_register_info() const override;

  bool is_native_for_current_platform() const override {
#if defined(__i386__) && !defined(_WIN32)
    return true;
#else
    return false;
#endif
  }

  stack_cleanup get_stack_cleanup() const override {
    return stack_cleanup::CALLER; // caller cleans stack
  }

  std::vector<double> extract_float_args(const extraction_context& ctx, size_t count) const override;
};

} // namespace w1::abi::conventions
```

`src/w1tn3ss/abi/conventions/x86_64/microsoft.cpp`:

```cpp
#include "microsoft.hpp"
#include <redlog.hpp>

namespace w1::abi::conventions {

std::vector<uint64_t> x86_64_microsoft::extract_integer_args(const extraction_context& ctx, size_t count) const {

  std::vector<uint64_t> args;
  args.reserve(count);

  // extract register arguments (rcx, rdx, r8, r9)
  size_t reg_args = std::min(count, max_reg_args);
  for (size_t i = 0; i < reg_args; i++) {
    switch (i) {
    case 0:
      args.push_back(ctx.gpr->rcx);
      break;
    case 1:
      args.push_back(ctx.gpr->rdx);
      break;
    case 2:
      args.push_back(ctx.gpr->r8);
      break;
    case 3:
      args.push_back(ctx.gpr->r9);
      break;
    }
  }

  // extract stack arguments if needed
  if (count > max_reg_args) {
    // stack arguments start after shadow space (32 bytes) and return address (8 bytes)
    // so first stack arg is at rsp + 40
    const uint64_t stack_base = ctx.gpr->rsp + 40;

    for (size_t i = max_reg_args; i < count; i++) {
      // each argument takes 8 bytes on stack
      uint64_t stack_offset = (i - max_reg_args) * 8;
      args.push_back(ctx.read_stack(stack_base + stack_offset));
    }
  }

  return args;
}

std::vector<x86_64_microsoft::typed_arg> x86_64_microsoft::extract_typed_args(
    const extraction_context& ctx, const std::vector<arg_type>& types
) const {

  std::vector<typed_arg> args;
  args.reserve(types.size());

  size_t reg_idx = 0;
  size_t stack_offset = 0;

  for (size_t i = 0; i < types.size(); i++) {
    typed_arg arg;
    arg.type = types[i];

    if (reg_idx < max_reg_args) {
      // from register
      switch (types[i]) {
      case arg_type::INTEGER:
      case arg_type::POINTER:
      case arg_type::STRUCT_BY_REF:
        switch (reg_idx) {
        case 0:
          arg.value.integer = ctx.gpr->rcx;
          break;
        case 1:
          arg.value.integer = ctx.gpr->rdx;
          break;
        case 2:
          arg.value.integer = ctx.gpr->r8;
          break;
        case 3:
          arg.value.integer = ctx.gpr->r9;
          break;
        }
        arg.from_stack = false;
        break;

      case arg_type::FLOAT:
        // float passed in xmm register at same position
        arg.value.f32 = get_xmm_float(ctx.fpr, reg_idx);
        arg.from_stack = false;
        break;

      case arg_type::DOUBLE:
        // double passed in xmm register at same position
        arg.value.f64 = get_xmm_double(ctx.fpr, reg_idx);
        arg.from_stack = false;
        break;

      case arg_type::SIMD:
        // __m128 passed by reference in integer register
        switch (reg_idx) {
        case 0:
          arg.value.integer = ctx.gpr->rcx;
          break;
        case 1:
          arg.value.integer = ctx.gpr->rdx;
          break;
        case 2:
          arg.value.integer = ctx.gpr->r8;
          break;
        case 3:
          arg.value.integer = ctx.gpr->r9;
          break;
        }
        arg.from_stack = false;
        break;

      case arg_type::STRUCT_BY_VALUE:
        // structures > 8 bytes passed by reference
        switch (reg_idx) {
        case 0:
          arg.value.integer = ctx.gpr->rcx;
          break;
        case 1:
          arg.value.integer = ctx.gpr->rdx;
          break;
        case 2:
          arg.value.integer = ctx.gpr->r8;
          break;
        case 3:
          arg.value.integer = ctx.gpr->r9;
          break;
        }
        arg.from_stack = false;
        break;
      }
      reg_idx++;
    } else {
      // from stack (after shadow space)
      const uint64_t stack_base = ctx.gpr->rsp + 40; // 32 (shadow) + 8 (return addr)

      switch (types[i]) {
      case arg_type::INTEGER:
      case arg_type::POINTER:
      case arg_type::STRUCT_BY_REF:
      case arg_type::SIMD:            // passed by reference
      case arg_type::STRUCT_BY_VALUE: // passed by reference
        arg.value.integer = ctx.read_stack(stack_base + stack_offset);
        break;

      case arg_type::FLOAT: {
        uint32_t val = static_cast<uint32_t>(ctx.read_stack(stack_base + stack_offset));
        arg.value.f32 = *reinterpret_cast<float*>(&val);
      } break;

      case arg_type::DOUBLE: {
        uint64_t val = ctx.read_stack(stack_base + stack_offset);
        arg.value.f64 = *reinterpret_cast<double*>(&val);
      } break;
      }

      arg.from_stack = true;
      arg.stack_offset = stack_offset;
      stack_offset += 8; // all args take 8 bytes on stack
    }

    args.push_back(arg);
  }

  return args;
}

x86_64_microsoft::typed_arg x86_64_microsoft::get_typed_return(
    const QBDI::GPRState* gpr, const QBDI::FPRState* fpr, arg_type type
) const {

  typed_arg ret;
  ret.type = type;
  ret.from_stack = false;

  switch (type) {
  case arg_type::INTEGER:
  case arg_type::POINTER:
  case arg_type::STRUCT_BY_REF:
    ret.value.integer = gpr->rax;
    break;

  case arg_type::FLOAT:
    ret.value.f32 = get_xmm_float(fpr, 0);
    break;

  case arg_type::DOUBLE:
    ret.value.f64 = get_xmm_double(fpr, 0);
    break;

  case arg_type::SIMD:
    get_xmm_bytes(fpr, 0, ret.value.simd);
    break;

  case arg_type::STRUCT_BY_VALUE:
    // structures returned by hidden first parameter
    // rax contains address of returned structure
    ret.value.integer = gpr->rax;
    break;
  }

  return ret;
}

std::optional<x86_64_microsoft::variadic_info> x86_64_microsoft::get_variadic_info(
    const extraction_context& ctx, size_t fixed_arg_count
) const {

  // windows x64 varargs work differently than system v
  // all parameters are passed as if they were integers
  variadic_info info;
  info.fixed_args = fixed_arg_count;
  info.gp_offset = 0;
  info.fp_offset = 0;
  info.overflow_arg_area = ctx.gpr->rsp + 40; // after shadow space
  info.reg_save_area = ctx.gpr->rsp + 8;      // shadow space area

  return info;
}

x86_64_microsoft::register_info x86_64_microsoft::get_register_info() const {
  return {
      .callee_saved_gpr = {"rbx", "rbp", "rdi", "rsi", "rsp", "r12", "r13", "r14", "r15"},
      .caller_saved_gpr = {"rax", "rcx", "rdx", "r8", "r9", "r10", "r11"},
      .callee_saved_fpr = {"xmm6", "xmm7", "xmm8", "xmm9", "xmm10", "xmm11", "xmm12", "xmm13", "xmm14", "xmm15"},
      .caller_saved_fpr = {"xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5"},
      .return_register = "rax",
      .argument_registers = {"rcx", "rdx", "r8", "r9"}
  };
}

std::vector<double> x86_64_microsoft::extract_float_args(const extraction_context& ctx, size_t count) const {

  std::vector<double> args;
  args.reserve(count);

  // first 4 float/double args in xmm0-xmm3
  size_t reg_args = std::min(count, max_reg_args);
  for (size_t i = 0; i < reg_args; i++) {
    args.push_back(get_xmm_double(ctx.fpr, i));
  }

  // remaining args on stack
  if (count > max_reg_args) {
    const uint64_t stack_base = ctx.gpr->rsp + 40; // after shadow space

    for (size_t i = max_reg_args; i < count; i++) {
      uint64_t stack_offset = (i - max_reg_args) * 8;
      uint64_t val = ctx.read_stack(stack_base + stack_offset);
      args.push_back(*reinterpret_cast<double*>(&val));
    }
  }

  return args;
}

} // namespace w1::abi::conventions
```

`src/w1tn3ss/abi/conventions/x86_64/microsoft.hpp`:

```hpp
#pragma once

#include "abi/calling_convention_base.hpp"
#include "abi/fpr_utils.hpp"
#include <array>

namespace w1::abi::conventions {

/**
 * @brief microsoft x64 calling convention implementation
 *
 * used on windows x64 systems
 *
 * register usage:
 * - first 4 parameters: rcx, rdx, r8, r9 (integer or float)
 * - floating-point in same positions use xmm0, xmm1, xmm2, xmm3
 * - return value: rax (integer), xmm0 (float/double)
 * - caller saved: rax, rcx, rdx, r8-r11, xmm0-xmm5
 * - callee saved: rbx, rbp, rdi, rsi, rsp, r12-r15, xmm6-xmm15
 *
 * stack layout:
 * - 32-byte shadow space reserved by caller (for rcx, rdx, r8, r9)
 * - stack aligned to 16 bytes before call
 * - parameters beyond 4th passed on stack (right to left)
 *
 * special considerations:
 * - structures larger than 8 bytes passed by reference
 * - __m128 types passed by reference
 * - varargs use same convention but require different handling
 */
class x86_64_microsoft : public calling_convention_base {
public:
  // metadata
  calling_convention_id get_id() const override { return calling_convention_id::X86_64_MICROSOFT; }

  std::string get_name() const override { return "x86-64 Microsoft ABI"; }

  architecture get_architecture() const override { return architecture::X86_64; }

  std::string get_description() const override { return "Microsoft x64 calling convention used on Windows"; }

  // argument extraction
  std::vector<uint64_t> extract_integer_args(const extraction_context& ctx, size_t count) const override;

  std::vector<typed_arg> extract_typed_args(
      const extraction_context& ctx, const std::vector<arg_type>& types
  ) const override;

  // return values
  uint64_t get_integer_return(const QBDI::GPRState* gpr) const override { return gpr->rax; }

  double get_float_return(const QBDI::FPRState* fpr) const override {
    // return value in xmm0
    return get_xmm_double(fpr, 0);
  }

  typed_arg get_typed_return(const QBDI::GPRState* gpr, const QBDI::FPRState* fpr, arg_type type) const override;

  // stack management
  uint64_t get_stack_pointer(const QBDI::GPRState* gpr) const override { return gpr->rsp; }

  uint64_t get_frame_pointer(const QBDI::GPRState* gpr) const override { return gpr->rbp; }

  size_t get_stack_alignment() const override {
    return 16; // 16-byte alignment
  }

  size_t get_shadow_space_size() const override {
    return 32; // 4 * 8 bytes for rcx, rdx, r8, r9
  }

  uint64_t get_return_address_location(const QBDI::GPRState* gpr) const override {
    // return address is at [rsp]
    return gpr->rsp;
  }

  // variadic support
  bool supports_varargs() const override { return true; }

  std::optional<variadic_info> get_variadic_info(const extraction_context& ctx, size_t fixed_arg_count) const override;

  // register info
  register_info get_register_info() const override;

  bool is_native_for_current_platform() const override {
#ifdef _WIN64
    return true;
#else
    return false;
#endif
  }

  stack_cleanup get_stack_cleanup() const override { return stack_cleanup::CALLER; }

  std::vector<double> extract_float_args(const extraction_context& ctx, size_t count) const override;

private:
  // first 4 params use rcx, rdx, r8, r9 (accessed directly)
  static constexpr size_t max_reg_args = 4;
};

} // namespace w1::abi::conventions
```

`src/w1tn3ss/abi/conventions/x86_64/system_v.cpp`:

```cpp
#include "system_v.hpp"
#include <redlog.hpp>

namespace w1::abi::conventions {

std::vector<uint64_t> x86_64_system_v::extract_integer_args(const extraction_context& ctx, size_t count) const {

  std::vector<uint64_t> args;
  args.reserve(count);

  // extract register arguments (rdi, rsi, rdx, rcx, r8, r9)
  size_t reg_args = std::min(count, size_t(6));
  for (size_t i = 0; i < reg_args; i++) {
    switch (i) {
    case 0:
      args.push_back(ctx.gpr->rdi);
      break;
    case 1:
      args.push_back(ctx.gpr->rsi);
      break;
    case 2:
      args.push_back(ctx.gpr->rdx);
      break;
    case 3:
      args.push_back(ctx.gpr->rcx);
      break;
    case 4:
      args.push_back(ctx.gpr->r8);
      break;
    case 5:
      args.push_back(ctx.gpr->r9);
      break;
    }
  }

  // extract stack arguments if needed
  if (count > 6) {
    // stack arguments start after return address
    // each argument takes 8 bytes on stack
    const uint64_t stack_base = ctx.gpr->rsp + 8; // skip return address

    for (size_t i = 6; i < count; i++) {
      uint64_t stack_offset = (i - 6) * 8;
      args.push_back(ctx.read_stack(stack_base + stack_offset));
    }
  }

  return args;
}

std::vector<x86_64_system_v::typed_arg> x86_64_system_v::extract_typed_args(
    const extraction_context& ctx, const std::vector<arg_type>& types
) const {

  std::vector<typed_arg> args;
  args.reserve(types.size());

  size_t int_reg_idx = 0;
  size_t float_reg_idx = 0;
  size_t stack_offset = 0;

  for (size_t i = 0; i < types.size(); i++) {
    typed_arg arg;
    arg.type = types[i];

    switch (types[i]) {
    case arg_type::INTEGER:
    case arg_type::POINTER:
      if (int_reg_idx < 6) {
        // from register
        switch (int_reg_idx) {
        case 0:
          arg.value.integer = ctx.gpr->rdi;
          break;
        case 1:
          arg.value.integer = ctx.gpr->rsi;
          break;
        case 2:
          arg.value.integer = ctx.gpr->rdx;
          break;
        case 3:
          arg.value.integer = ctx.gpr->rcx;
          break;
        case 4:
          arg.value.integer = ctx.gpr->r8;
          break;
        case 5:
          arg.value.integer = ctx.gpr->r9;
          break;
        }
        arg.from_stack = false;
        int_reg_idx++;
      } else {
        // from stack
        arg.value.integer = ctx.read_stack(ctx.gpr->rsp + 8 + stack_offset);
        arg.from_stack = true;
        arg.stack_offset = stack_offset;
        stack_offset += 8;
      }
      break;

    case arg_type::FLOAT:
      if (float_reg_idx < max_float_reg_args) {
        // from xmm register
        arg.value.f32 = get_xmm_float(ctx.fpr, float_reg_idx);
        arg.from_stack = false;
        float_reg_idx++;
      } else {
        // from stack
        uint32_t val = static_cast<uint32_t>(ctx.read_stack(ctx.gpr->rsp + 8 + stack_offset));
        arg.value.f32 = *reinterpret_cast<float*>(&val);
        arg.from_stack = true;
        arg.stack_offset = stack_offset;
        stack_offset += 8; // still takes 8 bytes on stack
      }
      break;

    case arg_type::DOUBLE:
      if (float_reg_idx < max_float_reg_args) {
        // from xmm register
        arg.value.f64 = get_xmm_double(ctx.fpr, float_reg_idx);
        arg.from_stack = false;
        float_reg_idx++;
      } else {
        // from stack
        uint64_t val = ctx.read_stack(ctx.gpr->rsp + 8 + stack_offset);
        arg.value.f64 = *reinterpret_cast<double*>(&val);
        arg.from_stack = true;
        arg.stack_offset = stack_offset;
        stack_offset += 8;
      }
      break;

    case arg_type::SIMD:
      if (float_reg_idx < max_float_reg_args) {
        // full xmm register
        get_xmm_bytes(ctx.fpr, float_reg_idx, arg.value.simd);
        arg.from_stack = false;
        float_reg_idx++;
      } else {
        // from stack (16 bytes)
        for (int j = 0; j < 16; j++) {
          arg.value.simd[j] = static_cast<uint8_t>(ctx.read_stack(ctx.gpr->rsp + 8 + stack_offset + j) & 0xFF);
        }
        arg.from_stack = true;
        arg.stack_offset = stack_offset;
        stack_offset += 16;
      }
      break;

    case arg_type::STRUCT_BY_VALUE:
      // small structs may be passed in registers
      // larger structs are passed on stack
      // this is simplified - real implementation would need size info
      arg.value.struct_data.data[0] = ctx.read_stack(ctx.gpr->rsp + 8 + stack_offset);
      arg.value.struct_data.size = 8;
      arg.from_stack = true;
      arg.stack_offset = stack_offset;
      stack_offset += 8;
      break;

    case arg_type::STRUCT_BY_REF:
      // passed as pointer
      if (int_reg_idx < 6) {
        switch (int_reg_idx) {
        case 0:
          arg.value.integer = ctx.gpr->rdi;
          break;
        case 1:
          arg.value.integer = ctx.gpr->rsi;
          break;
        case 2:
          arg.value.integer = ctx.gpr->rdx;
          break;
        case 3:
          arg.value.integer = ctx.gpr->rcx;
          break;
        case 4:
          arg.value.integer = ctx.gpr->r8;
          break;
        case 5:
          arg.value.integer = ctx.gpr->r9;
          break;
        }
        arg.from_stack = false;
        int_reg_idx++;
      } else {
        arg.value.integer = ctx.read_stack(ctx.gpr->rsp + 8 + stack_offset);
        arg.from_stack = true;
        arg.stack_offset = stack_offset;
        stack_offset += 8;
      }
      break;
    }

    args.push_back(arg);
  }

  return args;
}

x86_64_system_v::typed_arg x86_64_system_v::get_typed_return(
    const QBDI::GPRState* gpr, const QBDI::FPRState* fpr, arg_type type
) const {

  typed_arg ret;
  ret.type = type;
  ret.from_stack = false;

  switch (type) {
  case arg_type::INTEGER:
  case arg_type::POINTER:
  case arg_type::STRUCT_BY_REF:
    ret.value.integer = gpr->rax;
    break;

  case arg_type::FLOAT:
    ret.value.f32 = get_xmm_float(fpr, 0);
    break;

  case arg_type::DOUBLE:
    ret.value.f64 = get_xmm_double(fpr, 0);
    break;

  case arg_type::SIMD:
    get_xmm_bytes(fpr, 0, ret.value.simd);
    break;

  case arg_type::STRUCT_BY_VALUE:
    // small structs returned in rax/rdx
    ret.value.struct_data.data[0] = gpr->rax;
    ret.value.struct_data.data[1] = gpr->rdx;
    ret.value.struct_data.size = 16;
    break;
  }

  return ret;
}

std::optional<x86_64_system_v::variadic_info> x86_64_system_v::get_variadic_info(
    const extraction_context& ctx, size_t fixed_arg_count
) const {

  // system v uses a complex va_list structure
  // this is a simplified implementation
  variadic_info info;
  info.fixed_args = fixed_arg_count;
  info.gp_offset = fixed_arg_count * 8; // simplified
  info.fp_offset = 0;
  info.overflow_arg_area = ctx.gpr->rsp + 8; // after return address
  info.reg_save_area = 0;                    // would need to be set up by caller

  return info;
}

x86_64_system_v::register_info x86_64_system_v::get_register_info() const {
  return {
      .callee_saved_gpr = {"rbx", "rsp", "rbp", "r12", "r13", "r14", "r15"},
      .caller_saved_gpr = {"rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"},
      .callee_saved_fpr = {}, // none
      .caller_saved_fpr =
          {"xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5", "xmm6", "xmm7", "xmm8", "xmm9", "xmm10", "xmm11", "xmm12",
           "xmm13", "xmm14", "xmm15"},
      .return_register = "rax",
      .argument_registers = {"rdi", "rsi", "rdx", "rcx", "r8", "r9"}
  };
}

std::vector<double> x86_64_system_v::extract_float_args(const extraction_context& ctx, size_t count) const {

  std::vector<double> args;
  args.reserve(count);

  // first 8 float/double args in xmm0-xmm7
  size_t reg_args = std::min(count, max_float_reg_args);
  for (size_t i = 0; i < reg_args; i++) {
    args.push_back(get_xmm_double(ctx.fpr, i));
  }

  // remaining args on stack
  if (count > max_float_reg_args) {
    const uint64_t stack_base = ctx.gpr->rsp + 8; // skip return address

    for (size_t i = max_float_reg_args; i < count; i++) {
      uint64_t stack_offset = (i - max_float_reg_args) * 8;
      uint64_t val = ctx.read_stack(stack_base + stack_offset);
      args.push_back(*reinterpret_cast<double*>(&val));
    }
  }

  return args;
}

} // namespace w1::abi::conventions
```

`src/w1tn3ss/abi/conventions/x86_64/system_v.hpp`:

```hpp
#pragma once

#include "abi/calling_convention_base.hpp"
#include "abi/fpr_utils.hpp"
#include <array>

namespace w1::abi::conventions {

/**
 * @brief system v amd64 abi implementation
 *
 * used on linux, macos, bsd, and other unix-like systems
 *
 * register usage:
 * - integer/pointer arguments: rdi, rsi, rdx, rcx, r8, r9 (first 6), then stack
 * - floating-point arguments: xmm0-xmm7 (first 8), then stack
 * - return value: rax/rdx (integer), xmm0/xmm1 (float)
 * - callee saved: rbx, rsp, rbp, r12-r15
 * - caller saved: rax, rcx, rdx, rsi, rdi, r8-r11, xmm0-xmm15
 *
 * stack layout:
 * - 128-byte red zone below rsp
 * - stack aligned to 16 bytes before call
 * - parameters beyond 6th passed on stack (right to left)
 */
class x86_64_system_v : public calling_convention_base {
public:
  // metadata
  calling_convention_id get_id() const override { return calling_convention_id::X86_64_SYSTEM_V; }

  std::string get_name() const override { return "x86-64 System V ABI"; }

  architecture get_architecture() const override { return architecture::X86_64; }

  std::string get_description() const override {
    return "System V AMD64 ABI used on Linux, macOS, and other Unix-like systems";
  }

  // argument extraction
  std::vector<uint64_t> extract_integer_args(const extraction_context& ctx, size_t count) const override;

  std::vector<typed_arg> extract_typed_args(
      const extraction_context& ctx, const std::vector<arg_type>& types
  ) const override;

  // return values
  uint64_t get_integer_return(const QBDI::GPRState* gpr) const override { return gpr->rax; }

  double get_float_return(const QBDI::FPRState* fpr) const override {
    // return value in xmm0
    return get_xmm_double(fpr, 0);
  }

  typed_arg get_typed_return(const QBDI::GPRState* gpr, const QBDI::FPRState* fpr, arg_type type) const override;

  // stack management
  uint64_t get_stack_pointer(const QBDI::GPRState* gpr) const override { return gpr->rsp; }

  uint64_t get_frame_pointer(const QBDI::GPRState* gpr) const override { return gpr->rbp; }

  size_t get_stack_alignment() const override {
    return 16; // 16-byte alignment
  }

  size_t get_red_zone_size() const override {
    return 128; // 128-byte red zone
  }

  uint64_t get_return_address_location(const QBDI::GPRState* gpr) const override {
    // return address is at [rsp]
    return gpr->rsp;
  }

  // variadic support
  bool supports_varargs() const override { return true; }

  std::optional<variadic_info> get_variadic_info(const extraction_context& ctx, size_t fixed_arg_count) const override;

  // register info
  register_info get_register_info() const override;

  bool is_native_for_current_platform() const override {
#if defined(__x86_64__) && !defined(_WIN64)
    return true;
#else
    return false;
#endif
  }

  stack_cleanup get_stack_cleanup() const override { return stack_cleanup::CALLER; }

  std::vector<double> extract_float_args(const extraction_context& ctx, size_t count) const override;

private:
  // integer argument registers: rdi, rsi, rdx, rcx, r8, r9 (accessed directly)
  static constexpr size_t max_int_reg_args = 6;

  // floating point argument registers: xmm0-xmm7
  static constexpr size_t max_float_reg_args = 8;
};

} // namespace w1::abi::conventions
```

`src/w1tn3ss/abi/fpr_utils.hpp`:

```hpp
#pragma once

#include <QBDI.h>
#include <cstring>

namespace w1::abi {

// platform-agnostic utilities for accessing FPR state
// qbdi has different FPRState structures on different platforms

#ifdef _WIN32
// on windows, qbdi defines xmm registers as individual char[16] arrays
// we need to cast them to access as float/double values

// helper to get xmm register pointer by index
inline const char* get_xmm_ptr(const QBDI::FPRState* fpr, size_t reg_idx) {
  switch (reg_idx) {
  case 0:
    return fpr->xmm0;
  case 1:
    return fpr->xmm1;
  case 2:
    return fpr->xmm2;
  case 3:
    return fpr->xmm3;
  case 4:
    return fpr->xmm4;
  case 5:
    return fpr->xmm5;
  case 6:
    return fpr->xmm6;
  case 7:
    return fpr->xmm7;
#if defined(_M_X64) || defined(__x86_64__)
  // x86_64 has additional xmm8-xmm15 registers
  case 8:
    return fpr->xmm8;
  case 9:
    return fpr->xmm9;
  case 10:
    return fpr->xmm10;
  case 11:
    return fpr->xmm11;
  case 12:
    return fpr->xmm12;
  case 13:
    return fpr->xmm13;
  case 14:
    return fpr->xmm14;
  case 15:
    return fpr->xmm15;
#endif
  default:
    return nullptr;
  }
}

inline float get_xmm_float(const QBDI::FPRState* fpr, size_t reg_idx) {
  const char* xmm_ptr = get_xmm_ptr(fpr, reg_idx);
  if (!xmm_ptr) {
    return 0.0f;
  }

  float result;
  std::memcpy(&result, xmm_ptr, sizeof(float));
  return result;
}

inline double get_xmm_double(const QBDI::FPRState* fpr, size_t reg_idx) {
  const char* xmm_ptr = get_xmm_ptr(fpr, reg_idx);
  if (!xmm_ptr) {
    return 0.0;
  }

  double result;
  std::memcpy(&result, xmm_ptr, sizeof(double));
  return result;
}

inline void get_xmm_bytes(const QBDI::FPRState* fpr, size_t reg_idx, void* dest) {
  const char* xmm_ptr = get_xmm_ptr(fpr, reg_idx);
  if (!xmm_ptr) {
    std::memset(dest, 0, 16);
    return;
  }

  std::memcpy(dest, xmm_ptr, 16);
}

#else
// On Unix platforms (Linux/macOS), QBDI typically defines XMM as an array of unions

inline float get_xmm_float(const QBDI::FPRState* fpr, size_t reg_idx) {
  if (reg_idx >= 16) {
    return 0.0f;
  }
  return fpr->xmm[reg_idx].reg32[0];
}

inline double get_xmm_double(const QBDI::FPRState* fpr, size_t reg_idx) {
  if (reg_idx >= 16) {
    return 0.0;
  }
  return fpr->xmm[reg_idx].reg64[0];
}

inline void get_xmm_bytes(const QBDI::FPRState* fpr, size_t reg_idx, void* dest) {
  if (reg_idx >= 16) {
    std::memset(dest, 0, 16);
    return;
  }
  std::memcpy(dest, &fpr->xmm[reg_idx], 16);
}

#endif

} // namespace w1::abi
```

`src/w1tn3ss/engine/session_base.hpp`:

```hpp
#pragma once

#include "tracer_engine.hpp"
#include <QBDI.h>
#include <memory>
#include <vector>
#include <redlog.hpp>

namespace w1 {

// simple crtp base that eliminates boilerplate for tracer sessions
template <typename Derived, typename TTracer, typename TConfig> class session_base {
public:
  using tracer_type = TTracer;
  using config_type = TConfig;

protected:
  config_type config_;
  std::unique_ptr<TTracer> tracer_;
  std::unique_ptr<tracer_engine<TTracer>> engine_;
  bool initialized_ = false;

public:
  session_base() = default;
  explicit session_base(const config_type& config) : config_(config) {}

  virtual ~session_base() {
    if (initialized_) {
      shutdown();
    }
  }

  // basic lifecycle - same as current w1cov::session
  bool initialize() {
    if (initialized_) {
      return true;
    }

    auto log = redlog::get_logger("w1.session_base");

    try {
      tracer_ = std::make_unique<TTracer>(config_);
      engine_ = std::make_unique<tracer_engine<TTracer>>(*tracer_);

      if (!tracer_->initialize(*engine_)) {
        log.err("tracer initialization failed");
        return false;
      }

      if (!engine_->instrument()) {
        log.err("engine instrumentation failed");
        return false;
      }

      initialized_ = true;
      return true;

    } catch (const std::exception& e) {
      log.err("initialization failed", redlog::field("error", e.what()));
      return false;
    }
  }

  void shutdown() {
    if (!initialized_) {
      return;
    }

    if (tracer_) {
      tracer_->shutdown();
      tracer_.reset();
    }

    if (engine_) {
      engine_.reset();
    }

    initialized_ = false;
  }

  bool is_initialized() const { return initialized_; }

  // configuration access
  config_type& get_config() { return config_; }
  const config_type& get_config() const { return config_; }

  // module pattern helpers
  void add_target_module_pattern(const std::string& pattern) { config_.module_filter.push_back(pattern); }

  // standard trace function - exactly like current implementation
  bool trace_function(void* func_ptr, const std::vector<uint64_t>& args = {}, uint64_t* result = nullptr) {
    if (!initialized_) {
      return false;
    }

    auto log = redlog::get_logger("w1.session_base");

    QBDI::VM* vm = engine_->get_vm();
    if (!vm) {
      return false;
    }

    QBDI::rword func_addr = reinterpret_cast<QBDI::rword>(func_ptr);

    // add instrumentation for the function
    if (!vm->addInstrumentedModuleFromAddr(func_addr)) {
      log.dbg("failed to add instrumented module for function address");
      return false;
    }

    // convert args
    std::vector<QBDI::rword> qbdi_args;
    for (uint64_t arg : args) {
      qbdi_args.push_back(static_cast<QBDI::rword>(arg));
    }

    log.dbg("calling function", redlog::field("function_addr", "0x%08x", func_addr));

    // call the function
    QBDI::rword retval;
    bool success = engine_->call_with_stack(&retval, func_addr, qbdi_args);

    if (!success) {
      log.dbg("function call failed");
      return false;
    }

    if (result) {
      *result = static_cast<uint64_t>(retval);
    }

    return true;
  }

  // direct vm access for power users
  QBDI::VM* get_vm() const { return engine_ ? engine_->get_vm() : nullptr; }

  tracer_engine<TTracer>* get_engine() const { return engine_.get(); }

  // instrumentation control
  bool add_instrumented_module_from_addr(void* module_addr) {
    if (!initialized_ || !engine_) {
      return false;
    }

    auto log = redlog::get_logger("w1.session_base");

    QBDI::VM* vm = engine_->get_vm();
    if (!vm) {
      log.err("failed to get VM for module instrumentation");
      return false;
    }

    QBDI::rword addr = reinterpret_cast<QBDI::rword>(module_addr);
    bool success = vm->addInstrumentedModuleFromAddr(addr);

    if (success) {
      log.dbg("added module to instrumentation", redlog::field("address", "0x%08x", addr));
    } else {
      log.wrn("failed to add module to instrumentation", redlog::field("address", "0x%08x", addr));
    }

    return success;
  }

  bool add_instrumented_range(void* start, void* end) {
    if (!initialized_ || !engine_) {
      return false;
    }

    auto log = redlog::get_logger("w1.session_base");

    QBDI::VM* vm = engine_->get_vm();
    if (!vm) {
      log.err("failed to get VM for range instrumentation");
      return false;
    }

    QBDI::rword start_addr = reinterpret_cast<QBDI::rword>(start);
    QBDI::rword end_addr = reinterpret_cast<QBDI::rword>(end);

    vm->addInstrumentedRange(start_addr, end_addr);

    log.dbg(
        "added range to instrumentation", redlog::field("start", "0x%08x", start_addr),
        redlog::field("end", "0x%08x", end_addr)
    );

    return true;
  }

  bool remove_all_instrumented_ranges() {
    if (!initialized_ || !engine_) {
      return false;
    }

    auto log = redlog::get_logger("w1.session_base");

    QBDI::VM* vm = engine_->get_vm();
    if (!vm) {
      log.err("failed to get VM for removing instrumentation");
      return false;
    }

    vm->removeAllInstrumentedRanges();
    log.dbg("removed all instrumented ranges");

    return true;
  }

protected:
  // protected accessors for derived classes
  TTracer* get_tracer() { return tracer_.get(); }
  const TTracer* get_tracer() const { return tracer_.get(); }
};

} // namespace w1
```

`src/w1tn3ss/engine/tracer_config_base.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>

namespace w1 {

/**
 * @brief base configuration for all tracers
 * @details provides common options that apply to most tracing scenarios
 */
struct tracer_config_base {
  // include system libraries in instrumentation
  bool include_system_modules = false;

  // optional module name filters for targeted instrumentation
  std::vector<std::string> module_filter;
};

} // namespace w1
```

`src/w1tn3ss/engine/tracer_engine.hpp`:

```hpp
#pragma once

#include <functional>
#include <iostream>
#include <type_traits>

#include <QBDI.h>
#include <redlog.hpp>

#include "tracer_config_base.hpp"
#include <w1tn3ss/util/module_scanner.hpp>

namespace w1 {

template <typename TTracer> class tracer_engine {
public:
  tracer_engine(QBDI::VMInstanceRef vm, TTracer& tracer)
      : vm_(static_cast<QBDI::VM*>(vm)), tracer_(tracer), owns_vm_(false) {
    log_.inf(
        "tracer engine created with existing QBDI::VM instance", redlog::field("tracer", tracer.get_name()),
        redlog::field("vm", static_cast<void*>(vm_))
    );
  }

  tracer_engine(QBDI::VMInstanceRef vm, TTracer& tracer, const tracer_config_base& config)
      : vm_(static_cast<QBDI::VM*>(vm)), tracer_(tracer), config_(config), owns_vm_(false) {
    log_.inf(
        "tracer engine created with config", redlog::field("tracer", tracer.get_name()),
        redlog::field("vm", static_cast<void*>(vm_)), redlog::field("include_system", config.include_system_modules)
    );
  }

  tracer_engine(TTracer& tracer) : tracer_(tracer), owns_vm_(true) {
    try {
      vm_ = new QBDI::VM();
      log_.inf("tracer engine created with new vm", redlog::field("tracer_name", tracer.get_name()));
    } catch (...) {
      vm_ = nullptr;
      owns_vm_ = false;
      log_.error("failed to create QBDI::VM instance, tracer engine will not function");
      // re-throw the exception to be handled by the caller
      throw;
    }
  }

public:
  ~tracer_engine() {
    if (owns_vm_ && vm_) {
      delete vm_;
    }
  }

  bool instrument() {
    if (!vm_) {
      log_.error("QBDI::VM instance is null, cannot instrument");
      return false;
    }

    apply_module_filtering();
    register_all_callbacks();
    return true;
  }

  bool run(QBDI::rword start, QBDI::rword stop) {
    if (!vm_) {
      log_.error("QBDI::VM instance is null, cannot run");
      return false;
    }

    log_.inf(
        "executing QBDI::VM::run", redlog::field("tracer", tracer_.get_name()), redlog::field("start", "0x%08x", start),
        redlog::field("stop", "0x%08x", stop)
    );
    return vm_->run(start, stop);
  }

  bool call(QBDI::rword* retval, QBDI::rword function_ptr, const std::vector<QBDI::rword>& args) {
    if (!vm_) {
      log_.error("QBDI::VM instance is null, cannot call function");
      return false;
    }

    log_.inf(
        "executing QBDI::VM::call", redlog::field("tracer", tracer_.get_name()),
        redlog::field("function_ptr", "0x%08x", function_ptr), redlog::field("args", args)
    );
    return vm_->call(retval, function_ptr, args);
  }

  bool call_with_stack(QBDI::rword* retval, QBDI::rword function_ptr, const std::vector<QBDI::rword>& args) {
    if (!vm_) {
      log_.error("QBDI::VM instance is null, cannot call function");
      return false;
    }

    log_.inf(
        "executing QBDI::VM::switchStackAndCall", redlog::field("tracer", tracer_.get_name()),
        redlog::field("function_ptr", "0x%08x", function_ptr), redlog::field("args", args)
    );
    return vm_->switchStackAndCall(retval, function_ptr, args);
  }

  QBDI::VM* get_vm() const { return vm_; }

  // parameterized callback registration methods (public interface)

  // address-specific instruction callbacks
  uint32_t add_code_addr_callback(QBDI::rword address, QBDI::InstPosition pos) {
    if constexpr (has_code_addr_callback_v<TTracer>) {
      log_.vrb(
          "registering code address callback", redlog::field("address", "0x%08x", address),
          redlog::field("position", pos == QBDI::PREINST ? "PREINST" : "POSTINST")
      );

      uint32_t id = vm_->addCodeAddrCB(
          address, pos,
          [](QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr, void* data) -> QBDI::VMAction {
            auto* engine = static_cast<tracer_engine<TTracer>*>(data);
            return engine->tracer_.on_code_addr(vm, gpr, fpr);
          },
          this
      );

      if (id != QBDI::INVALID_EVENTID) {
        log_.inf(
            "registered code address callback", redlog::field("address", "0x%08x", address), redlog::field("id", id)
        );
      } else {
        log_.error(
            "failed to register code address callback", redlog::field("address", "0x%08x", address),
            redlog::field("id", id)
        );
      }
      return id;
    } else {
      log_.trc("code address callback not supported by tracer");
      return QBDI::INVALID_EVENTID;
    }
  }

  // address range instruction callbacks
  uint32_t add_code_range_callback(QBDI::rword start, QBDI::rword end, QBDI::InstPosition pos) {
    if constexpr (has_code_range_callback_v<TTracer>) {
      log_.vrb(
          "registering code range callback", redlog::field("start", "0x%08x", start),
          redlog::field("end", "0x%08x", end), redlog::field("position", pos == QBDI::PREINST ? "PREINST" : "POSTINST")
      );

      uint32_t id = vm_->addCodeRangeCB(
          start, end, pos,
          [](QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr, void* data) -> QBDI::VMAction {
            auto* engine = static_cast<tracer_engine<TTracer>*>(data);
            return engine->tracer_.on_code_range(vm, gpr, fpr);
          },
          this
      );

      if (id != QBDI::INVALID_EVENTID) {
        log_.inf(
            "registered code range callback", redlog::field("start", "0x%08x", start),
            redlog::field("end", "0x%08x", end), redlog::field("id", id)
        );
      } else {
        log_.error(
            "failed to register code range callback", redlog::field("start", "0x%08x", start),
            redlog::field("end", "0x%08x", end), redlog::field("id", id)
        );
      }
      return id;
    } else {
      log_.trc("code range callback not supported by tracer");
      return QBDI::INVALID_EVENTID;
    }
  }

  // mnemonic-specific instruction callbacks
  uint32_t add_mnemonic_callback(const char* mnemonic, QBDI::InstPosition pos) {
    if constexpr (has_mnemonic_callback_v<TTracer>) {
      log_.vrb(
          "registering mnemonic callback", redlog::field("mnemonic", mnemonic),
          redlog::field("position", pos == QBDI::PREINST ? "PREINST" : "POSTINST")
      );

      uint32_t id = vm_->addMnemonicCB(
          mnemonic, pos,
          [](QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr, void* data) -> QBDI::VMAction {
            auto* engine = static_cast<tracer_engine<TTracer>*>(data);
            return engine->tracer_.on_mnemonic(vm, gpr, fpr);
          },
          this
      );

      if (id != QBDI::INVALID_EVENTID) {
        log_.inf("registered mnemonic callback", redlog::field("mnemonic", mnemonic), redlog::field("id", id));
      } else {
        log_.error(
            "failed to register mnemonic callback", redlog::field("mnemonic", mnemonic), redlog::field("id", id)
        );
      }
      return id;
    } else {
      log_.trc("mnemonic callback not supported by tracer");
      return QBDI::INVALID_EVENTID;
    }
  }

  // virtual memory address callbacks (high performance cost)
  uint32_t add_mem_addr_callback(QBDI::rword address, QBDI::MemoryAccessType type) {
    if constexpr (has_mem_addr_callback_v<TTracer>) {
      log_.vrb(
          "registering memory address callback", redlog::field("address", "0x%08x", address),
          redlog::field("type", type)
      );

      uint32_t id = vm_->addMemAddrCB(
          address, type,
          [](QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr, void* data) -> QBDI::VMAction {
            auto* engine = static_cast<tracer_engine<TTracer>*>(data);
            return engine->tracer_.on_mem_addr(vm, gpr, fpr);
          },
          this
      );

      if (id != QBDI::INVALID_EVENTID) {
        log_.inf(
            "registered memory address callback", redlog::field("address", "0x%08x", address), redlog::field("id", id)
        );
      } else {
        log_.error(
            "failed to register memory address callback", redlog::field("address", "0x%08x", address),
            redlog::field("id", id)
        );
      }
      return id;
    } else {
      log_.trc("memory address callback not supported by tracer");
      return QBDI::INVALID_EVENTID;
    }
  }

  // virtual memory range callbacks (high performance cost)
  uint32_t add_mem_range_callback(QBDI::rword start, QBDI::rword end, QBDI::MemoryAccessType type) {
    if constexpr (has_mem_range_callback_v<TTracer>) {
      log_.vrb(
          "registering memory range callback", redlog::field("start", "0x%08x", start),
          redlog::field("end", "0x%08x", end), redlog::field("type", type)
      );

      uint32_t id = vm_->addMemRangeCB(
          start, end, type,
          [](QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr, void* data) -> QBDI::VMAction {
            auto* engine = static_cast<tracer_engine<TTracer>*>(data);
            return engine->tracer_.on_mem_range(vm, gpr, fpr);
          },
          this
      );

      if (id != QBDI::INVALID_EVENTID) {
        log_.inf(
            "registered memory range callback", redlog::field("start", "0x%08x", start),
            redlog::field("end", "0x%08x", end), redlog::field("id", id)
        );
      } else {
        log_.error(
            "failed to register memory range callback", redlog::field("start", "0x%08x", start),
            redlog::field("end", "0x%08x", end), redlog::field("id", id)
        );
      }
      return id;
    } else {
      log_.trc("memory range callback not supported by tracer");
      return QBDI::INVALID_EVENTID;
    }
  }

  // instruction rule callbacks
  uint32_t add_instr_rule_callback(QBDI::AnalysisType type) {
    if constexpr (has_instr_rule_callback_v<TTracer>) {
      log_.vrb("registering instruction rule callback", redlog::field("type", type));

      uint32_t id = vm_->addInstrRule(
          [](QBDI::VMInstanceRef vm, const QBDI::InstAnalysis* analysis,
             void* data) -> std::vector<QBDI::InstrRuleDataCBK> {
            auto* engine = static_cast<tracer_engine<TTracer>*>(data);
            return engine->tracer_.on_instr_rule(vm, analysis, data);
          },
          type, this
      );

      if (id != QBDI::INVALID_EVENTID) {
        log_.inf("registered instruction rule callback", redlog::field("type", type), redlog::field("id", id));
      } else {
        log_.error(
            "failed to register instruction rule callback", redlog::field("type", type), redlog::field("id", id)
        );
      }
      return id;
    } else {
      log_.trc("instruction rule callback not supported by tracer");
      return QBDI::INVALID_EVENTID;
    }
  }

  // instruction rule range callbacks
  uint32_t add_instr_rule_range_callback(QBDI::rword start, QBDI::rword end, QBDI::AnalysisType type) {
    if constexpr (has_instr_rule_range_callback_v<TTracer>) {
      log_.vrb(
          "registering instruction rule range callback", redlog::field("start", "0x%08x", start),
          redlog::field("end", "0x%08x", end), redlog::field("type", type)
      );

      uint32_t id = vm_->addInstrRuleRange(
          start, end,
          [](QBDI::VMInstanceRef vm, const QBDI::InstAnalysis* analysis,
             void* data) -> std::vector<QBDI::InstrRuleDataCBK> {
            auto* engine = static_cast<tracer_engine<TTracer>*>(data);
            return engine->tracer_.on_instr_rule_range(vm, analysis, data);
          },
          type, this
      );

      if (id != QBDI::INVALID_EVENTID) {
        log_.inf(
            "registered instruction rule range callback", redlog::field("start", "0x%08x", start),
            redlog::field("end", "0x%08x", end), redlog::field("id", id)
        );
      } else {
        log_.error(
            "failed to register instruction rule range callback", redlog::field("start", "0x%08x", start),
            redlog::field("end", "0x%08x", end), redlog::field("id", id)
        );
      }
      return id;
    } else {
      log_.trc("instruction rule range callback not supported by tracer");
      return QBDI::INVALID_EVENTID;
    }
  }

  // instruction rule range set callbacks
  uint32_t add_instr_rule_range_set_callback(const QBDI::RangeSet<QBDI::rword>& range, QBDI::AnalysisType type) {
    if constexpr (has_instr_rule_range_set_callback_v<TTracer>) {
      log_.vrb("registering instruction rule range set callback", redlog::field("type", type));

      uint32_t id = vm_->addInstrRuleRangeSet(
          range,
          [](QBDI::VMInstanceRef vm, const QBDI::InstAnalysis* analysis,
             void* data) -> std::vector<QBDI::InstrRuleDataCBK> {
            auto* engine = static_cast<tracer_engine<TTracer>*>(data);
            return engine->tracer_.on_instr_rule_range_set(vm, analysis, data);
          },
          type, this
      );

      if (id != QBDI::INVALID_EVENTID) {
        log_.inf(
            "registered instruction rule range set callback", redlog::field("type", type), redlog::field("id", id)
        );
      } else {
        log_.error(
            "failed to register instruction rule range set callback", redlog::field("type", type),
            redlog::field("id", id)
        );
      }
      return id;
    } else {
      log_.trc("instruction rule range set callback not supported by tracer");
      return QBDI::INVALID_EVENTID;
    }
  }

private:
  QBDI::VM* vm_;
  TTracer& tracer_;
  bool owns_vm_;
  tracer_config_base config_;
  redlog::logger log_{"w1.tracer_engine"};

  /**
   * we should avoid filtering some critical system modules, because it could cause instability
   */
  bool is_critical_system_module(const std::string& module_name) const {
#ifdef __APPLE__
    static const std::vector<std::string> critical_modules = {"libdyld"};
#elif defined(__linux__)
    static const std::vector<std::string> critical_modules = {
        // add linux critical modules here when needed
    };
#elif defined(_WIN32)
    static const std::vector<std::string> critical_modules = {
        // add windows critical modules here when needed
    };
#else
    static const std::vector<std::string> critical_modules = {};
#endif

    for (const auto& critical : critical_modules) {
      if (module_name.find(critical) != std::string::npos) {
        return true;
      }
    }
    return false;
  }

  void apply_module_filtering() {
    if (config_.include_system_modules) {
      log_.dbg("including system modules in instrumentation");
      return;
    }

    log_.dbg("applying system module filtering");
    util::module_scanner scanner;
    auto modules = scanner.scan_executable_modules();

    // debug: list all modules first
    log_.dbg("listing all executable modules", redlog::field("count", modules.size()));
    for (const auto& mod : modules) {
      log_.dbg(
          "module", redlog::field("name", mod.name), redlog::field("is_system", mod.is_system_library),
          redlog::field("base", "0x%lx", mod.base_address)
      );
    }

    size_t excluded_count = 0;
    for (const auto& mod : modules) {
      if (mod.is_system_library) {
        // check if this is a critical system module
        if (is_critical_system_module(mod.name)) {
          log_.dbg("keeping critical system module", redlog::field("name", mod.name));
          continue;
        }

        // exclude system module
        log_.dbg(
            "excluding system module", redlog::field("module", mod.name),
            redlog::field("base", "0x%08x", mod.base_address)
        );
        vm_->removeInstrumentedModuleFromAddr(mod.base_address);
        excluded_count++;
      }
    }

    log_.dbg(
        "module filtering complete", redlog::field("total_modules", modules.size()),
        redlog::field("excluded", excluded_count), redlog::field("remaining", modules.size() - excluded_count)
    );
  }

  // - SFINAE detection for callback methods (C++17)

  // -- SFINAE queries

  // instruction callbacks (addCodeCB)
  template <typename T, typename = void> struct has_instruction_preinst_callback : std::false_type {};
  template <typename T>
  struct has_instruction_preinst_callback<
      T, std::void_t<decltype(std::declval<T>().on_instruction_preinst(
             std::declval<QBDI::VMInstanceRef>(), std::declval<QBDI::GPRState*>(), std::declval<QBDI::FPRState*>()
         ))>> : std::true_type {};

  template <typename T, typename = void> struct has_instruction_postinst_callback : std::false_type {};
  template <typename T>
  struct has_instruction_postinst_callback<
      T, std::void_t<decltype(std::declval<T>().on_instruction_postinst(
             std::declval<QBDI::VMInstanceRef>(), std::declval<QBDI::GPRState*>(), std::declval<QBDI::FPRState*>()
         ))>> : std::true_type {};

  // VM event callbacks (addVMEventCB)
  template <typename T, typename = void> struct has_sequence_entry_callback : std::false_type {};
  template <typename T>
  struct has_sequence_entry_callback<
      T, std::void_t<decltype(std::declval<T>().on_sequence_entry(
             std::declval<QBDI::VMInstanceRef>(), std::declval<const QBDI::VMState*>(), std::declval<QBDI::GPRState*>(),
             std::declval<QBDI::FPRState*>()
         ))>> : std::true_type {};

  template <typename T, typename = void> struct has_sequence_exit_callback : std::false_type {};
  template <typename T>
  struct has_sequence_exit_callback<
      T, std::void_t<decltype(std::declval<T>().on_sequence_exit(
             std::declval<QBDI::VMInstanceRef>(), std::declval<const QBDI::VMState*>(), std::declval<QBDI::GPRState*>(),
             std::declval<QBDI::FPRState*>()
         ))>> : std::true_type {};

  template <typename T, typename = void> struct has_basic_block_entry_callback : std::false_type {};
  template <typename T>
  struct has_basic_block_entry_callback<
      T, std::void_t<decltype(std::declval<T>().on_basic_block_entry(
             std::declval<QBDI::VMInstanceRef>(), std::declval<const QBDI::VMState*>(), std::declval<QBDI::GPRState*>(),
             std::declval<QBDI::FPRState*>()
         ))>> : std::true_type {};

  template <typename T, typename = void> struct has_basic_block_exit_callback : std::false_type {};
  template <typename T>
  struct has_basic_block_exit_callback<
      T, std::void_t<decltype(std::declval<T>().on_basic_block_exit(
             std::declval<QBDI::VMInstanceRef>(), std::declval<const QBDI::VMState*>(), std::declval<QBDI::GPRState*>(),
             std::declval<QBDI::FPRState*>()
         ))>> : std::true_type {};

  template <typename T, typename = void> struct has_basic_block_new_callback : std::false_type {};
  template <typename T>
  struct has_basic_block_new_callback<
      T, std::void_t<decltype(std::declval<T>().on_basic_block_new(
             std::declval<QBDI::VMInstanceRef>(), std::declval<const QBDI::VMState*>(), std::declval<QBDI::GPRState*>(),
             std::declval<QBDI::FPRState*>()
         ))>> : std::true_type {};

  template <typename T, typename = void> struct has_exec_transfer_call_callback : std::false_type {};
  template <typename T>
  struct has_exec_transfer_call_callback<
      T, std::void_t<decltype(std::declval<T>().on_exec_transfer_call(
             std::declval<QBDI::VMInstanceRef>(), std::declval<const QBDI::VMState*>(), std::declval<QBDI::GPRState*>(),
             std::declval<QBDI::FPRState*>()
         ))>> : std::true_type {};

  template <typename T, typename = void> struct has_exec_transfer_return_callback : std::false_type {};
  template <typename T>
  struct has_exec_transfer_return_callback<
      T, std::void_t<decltype(std::declval<T>().on_exec_transfer_return(
             std::declval<QBDI::VMInstanceRef>(), std::declval<const QBDI::VMState*>(), std::declval<QBDI::GPRState*>(),
             std::declval<QBDI::FPRState*>()
         ))>> : std::true_type {};

  // memory access callbacks (addMemAccessCB)
  template <typename T, typename = void> struct has_memory_read_callback : std::false_type {};
  template <typename T>
  struct has_memory_read_callback<
      T, std::void_t<decltype(std::declval<T>().on_memory_read(
             std::declval<QBDI::VMInstanceRef>(), std::declval<QBDI::GPRState*>(), std::declval<QBDI::FPRState*>()
         ))>> : std::true_type {};

  template <typename T, typename = void> struct has_memory_write_callback : std::false_type {};
  template <typename T>
  struct has_memory_write_callback<
      T, std::void_t<decltype(std::declval<T>().on_memory_write(
             std::declval<QBDI::VMInstanceRef>(), std::declval<QBDI::GPRState*>(), std::declval<QBDI::FPRState*>()
         ))>> : std::true_type {};

  template <typename T, typename = void> struct has_memory_read_write_callback : std::false_type {};
  template <typename T>
  struct has_memory_read_write_callback<
      T, std::void_t<decltype(std::declval<T>().on_memory_read_write(
             std::declval<QBDI::VMInstanceRef>(), std::declval<QBDI::GPRState*>(), std::declval<QBDI::FPRState*>()
         ))>> : std::true_type {};

  // -- SFINAE results

  // instruction callbacks
  template <typename T>
  static constexpr bool has_instruction_preinst_callback_v = has_instruction_preinst_callback<T>::value;
  template <typename T>
  static constexpr bool has_instruction_postinst_callback_v = has_instruction_postinst_callback<T>::value;

  // VM event callbacks
  template <typename T> static constexpr bool has_sequence_entry_callback_v = has_sequence_entry_callback<T>::value;
  template <typename T> static constexpr bool has_sequence_exit_callback_v = has_sequence_exit_callback<T>::value;
  template <typename T>
  static constexpr bool has_basic_block_entry_callback_v = has_basic_block_entry_callback<T>::value;
  template <typename T> static constexpr bool has_basic_block_exit_callback_v = has_basic_block_exit_callback<T>::value;
  template <typename T> static constexpr bool has_basic_block_new_callback_v = has_basic_block_new_callback<T>::value;
  template <typename T>
  static constexpr bool has_exec_transfer_call_callback_v = has_exec_transfer_call_callback<T>::value;
  template <typename T>
  static constexpr bool has_exec_transfer_return_callback_v = has_exec_transfer_return_callback<T>::value;

  // memory access callbacks
  template <typename T> static constexpr bool has_memory_read_callback_v = has_memory_read_callback<T>::value;
  template <typename T> static constexpr bool has_memory_write_callback_v = has_memory_write_callback<T>::value;
  template <typename T>
  static constexpr bool has_memory_read_write_callback_v = has_memory_read_write_callback<T>::value;

  // address-specific callbacks (addCodeAddrCB, addCodeRangeCB)
  template <typename T, typename = void> struct has_code_addr_callback : std::false_type {};
  template <typename T>
  struct has_code_addr_callback<
      T, std::void_t<decltype(std::declval<T>().on_code_addr(
             std::declval<QBDI::VMInstanceRef>(), std::declval<QBDI::GPRState*>(), std::declval<QBDI::FPRState*>()
         ))>> : std::true_type {};

  template <typename T, typename = void> struct has_code_range_callback : std::false_type {};
  template <typename T>
  struct has_code_range_callback<
      T, std::void_t<decltype(std::declval<T>().on_code_range(
             std::declval<QBDI::VMInstanceRef>(), std::declval<QBDI::GPRState*>(), std::declval<QBDI::FPRState*>()
         ))>> : std::true_type {};

  // mnemonic-specific callbacks (addMnemonicCB)
  template <typename T, typename = void> struct has_mnemonic_callback : std::false_type {};
  template <typename T>
  struct has_mnemonic_callback<
      T, std::void_t<decltype(std::declval<T>().on_mnemonic(
             std::declval<QBDI::VMInstanceRef>(), std::declval<QBDI::GPRState*>(), std::declval<QBDI::FPRState*>()
         ))>> : std::true_type {};

  template <typename T> static constexpr bool has_code_addr_callback_v = has_code_addr_callback<T>::value;
  template <typename T> static constexpr bool has_code_range_callback_v = has_code_range_callback<T>::value;
  template <typename T> static constexpr bool has_mnemonic_callback_v = has_mnemonic_callback<T>::value;

  // virtual memory address callbacks (addMemAddrCB, addMemRangeCB)
  template <typename T, typename = void> struct has_mem_addr_callback : std::false_type {};
  template <typename T>
  struct has_mem_addr_callback<
      T, std::void_t<decltype(std::declval<T>().on_mem_addr(
             std::declval<QBDI::VMInstanceRef>(), std::declval<QBDI::GPRState*>(), std::declval<QBDI::FPRState*>()
         ))>> : std::true_type {};

  template <typename T, typename = void> struct has_mem_range_callback : std::false_type {};
  template <typename T>
  struct has_mem_range_callback<
      T, std::void_t<decltype(std::declval<T>().on_mem_range(
             std::declval<QBDI::VMInstanceRef>(), std::declval<QBDI::GPRState*>(), std::declval<QBDI::FPRState*>()
         ))>> : std::true_type {};

  // instruction rule callbacks (addInstrRule, addInstrRuleRange, addInstrRuleRangeSet)
  template <typename T, typename = void> struct has_instr_rule_callback : std::false_type {};
  template <typename T>
  struct has_instr_rule_callback<
      T, std::void_t<decltype(std::declval<T>().on_instr_rule(
             std::declval<QBDI::VMInstanceRef>(), std::declval<const QBDI::InstAnalysis*>(), std::declval<void*>()
         ))>> : std::true_type {};

  template <typename T, typename = void> struct has_instr_rule_range_callback : std::false_type {};
  template <typename T>
  struct has_instr_rule_range_callback<
      T, std::void_t<decltype(std::declval<T>().on_instr_rule_range(
             std::declval<QBDI::VMInstanceRef>(), std::declval<const QBDI::InstAnalysis*>(), std::declval<void*>()
         ))>> : std::true_type {};

  template <typename T, typename = void> struct has_instr_rule_range_set_callback : std::false_type {};
  template <typename T>
  struct has_instr_rule_range_set_callback<
      T, std::void_t<decltype(std::declval<T>().on_instr_rule_range_set(
             std::declval<QBDI::VMInstanceRef>(), std::declval<const QBDI::InstAnalysis*>(), std::declval<void*>()
         ))>> : std::true_type {};

  template <typename T> static constexpr bool has_mem_addr_callback_v = has_mem_addr_callback<T>::value;
  template <typename T> static constexpr bool has_mem_range_callback_v = has_mem_range_callback<T>::value;
  template <typename T> static constexpr bool has_instr_rule_callback_v = has_instr_rule_callback<T>::value;
  template <typename T> static constexpr bool has_instr_rule_range_callback_v = has_instr_rule_range_callback<T>::value;
  template <typename T>
  static constexpr bool has_instr_rule_range_set_callback_v = has_instr_rule_range_set_callback<T>::value;

  // - Callback registration macros (to reduce code duplication)

#define W1_REGISTER_INST_CALLBACK(name, position, callback_name)                                                       \
  void register_##name##_callback() {                                                                                  \
    if constexpr (has_##name##_callback_v<TTracer>) {                                                                  \
      log_.vrb("registering callback", redlog::field("callback", #name));                                              \
                                                                                                                       \
      uint32_t id = vm_->addCodeCB(                                                                                    \
          position,                                                                                                    \
          [](QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr, void* data) -> QBDI::VMAction {         \
            auto* engine = static_cast<tracer_engine<TTracer>*>(data);                                                 \
            return engine->tracer_.callback_name(vm, gpr, fpr);                                                        \
          },                                                                                                           \
          this                                                                                                         \
      );                                                                                                               \
                                                                                                                       \
      if (id != QBDI::INVALID_EVENTID) {                                                                               \
        log_.inf("registered callback", redlog::field("callback", #name), redlog::field("id", id));                    \
      } else {                                                                                                         \
        log_.error("failed to register callback", redlog::field("callback", #name), redlog::field("id", id));          \
      }                                                                                                                \
    } else {                                                                                                           \
      log_.trc("not requested", redlog::field("callback", #name));                                                     \
    }                                                                                                                  \
  }

#define W1_REGISTER_VM_EVENT_CALLBACK(name, event, callback_name)                                                      \
  void register_##name##_callback() {                                                                                  \
    if constexpr (has_##name##_callback_v<TTracer>) {                                                                  \
      log_.vrb("registering callback", redlog::field("callback", #name));                                              \
                                                                                                                       \
      uint32_t id = vm_->addVMEventCB(                                                                                 \
          event,                                                                                                       \
          [](QBDI::VMInstanceRef vm, const QBDI::VMState* state, QBDI::GPRState* gpr, QBDI::FPRState* fpr,             \
             void* data) -> QBDI::VMAction {                                                                           \
            auto* engine = static_cast<tracer_engine<TTracer>*>(data);                                                 \
            return engine->tracer_.callback_name(vm, state, gpr, fpr);                                                 \
          },                                                                                                           \
          this                                                                                                         \
      );                                                                                                               \
                                                                                                                       \
      if (id != QBDI::INVALID_EVENTID) {                                                                               \
        log_.inf("registered callback", redlog::field("callback", #name), redlog::field("id", id));                    \
      } else {                                                                                                         \
        log_.error("failed to register callback", redlog::field("callback", #name), redlog::field("id", id));          \
      }                                                                                                                \
    } else {                                                                                                           \
      log_.trc("not requested", redlog::field("callback", #name));                                                     \
    }                                                                                                                  \
  }

#define W1_REGISTER_MEM_ACCESS_CALLBACK(name, access_type, callback_name)                                              \
  void register_##name##_callback() {                                                                                  \
    if constexpr (has_##name##_callback_v<TTracer>) {                                                                  \
      log_.vrb("registering callback", redlog::field("callback", #name));                                              \
                                                                                                                       \
      uint32_t id = vm_->addMemAccessCB(                                                                               \
          access_type,                                                                                                 \
          [](QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr, void* data) -> QBDI::VMAction {         \
            auto* engine = static_cast<tracer_engine<TTracer>*>(data);                                                 \
            return engine->tracer_.callback_name(vm, gpr, fpr);                                                        \
          },                                                                                                           \
          this                                                                                                         \
      );                                                                                                               \
                                                                                                                       \
      if (id != QBDI::INVALID_EVENTID) {                                                                               \
        log_.inf("registered callback", redlog::field("callback", #name), redlog::field("id", id));                    \
      } else {                                                                                                         \
        log_.error("failed to register callback", redlog::field("callback", #name), redlog::field("id", id));          \
      }                                                                                                                \
    } else {                                                                                                           \
      log_.trc("not requested", redlog::field("callback", #name));                                                     \
    }                                                                                                                  \
  }

  // - Callback registration methods

  // instruction callbacks (addCodeCB) - using macros
  W1_REGISTER_INST_CALLBACK(instruction_preinst, QBDI::PREINST, on_instruction_preinst)
  W1_REGISTER_INST_CALLBACK(instruction_postinst, QBDI::POSTINST, on_instruction_postinst)

  // VM event callbacks (addVMEventCB) - using macros
  W1_REGISTER_VM_EVENT_CALLBACK(sequence_entry, QBDI::SEQUENCE_ENTRY, on_sequence_entry)
  W1_REGISTER_VM_EVENT_CALLBACK(sequence_exit, QBDI::SEQUENCE_EXIT, on_sequence_exit)
  W1_REGISTER_VM_EVENT_CALLBACK(basic_block_entry, QBDI::BASIC_BLOCK_ENTRY, on_basic_block_entry)
  W1_REGISTER_VM_EVENT_CALLBACK(basic_block_exit, QBDI::BASIC_BLOCK_EXIT, on_basic_block_exit)
  W1_REGISTER_VM_EVENT_CALLBACK(basic_block_new, QBDI::BASIC_BLOCK_NEW, on_basic_block_new)
  W1_REGISTER_VM_EVENT_CALLBACK(exec_transfer_call, QBDI::EXEC_TRANSFER_CALL, on_exec_transfer_call)
  W1_REGISTER_VM_EVENT_CALLBACK(exec_transfer_return, QBDI::EXEC_TRANSFER_RETURN, on_exec_transfer_return)

  // memory access callbacks (addMemAccessCB) - using macros
  W1_REGISTER_MEM_ACCESS_CALLBACK(memory_read, QBDI::MEMORY_READ, on_memory_read)
  W1_REGISTER_MEM_ACCESS_CALLBACK(memory_write, QBDI::MEMORY_WRITE, on_memory_write)
  W1_REGISTER_MEM_ACCESS_CALLBACK(memory_read_write, QBDI::MEMORY_READ_WRITE, on_memory_read_write)

// clean up macros to avoid polluting global namespace
#undef W1_REGISTER_INST_CALLBACK
#undef W1_REGISTER_VM_EVENT_CALLBACK
#undef W1_REGISTER_MEM_ACCESS_CALLBACK

  void register_all_callbacks() {
    log_.inf("registering callbacks...");

    // instruction callbacks (addCodeCB)
    register_instruction_preinst_callback();
    register_instruction_postinst_callback();

    // VM event callbacks (addVMEventCB)
    register_sequence_entry_callback();
    register_sequence_exit_callback();
    register_basic_block_entry_callback();
    register_basic_block_exit_callback();
    register_basic_block_new_callback();
    register_exec_transfer_call_callback();
    register_exec_transfer_return_callback();

    // memory access callbacks (addMemAccessCB)
    register_memory_read_callback();
    register_memory_write_callback();
    register_memory_read_write_callback();

    // note: SYSCALL_ENTRY and SYSCALL_EXIT are not implemented in current QBDI version

    log_.inf("callback registration complete");
  }
};

} // namespace w1

```

`src/w1tn3ss/formats/drcov.hpp`:

```hpp
/**
 * @file drcov.hpp
 * @brief Header-only C++17 library for parsing and writing DrCov coverage files
 *
 * This library provides a complete implementation for reading and writing
 * DrCov coverage files, supporting format version 2 with module table versions 2-4
 * and legacy module tables. It is designed to be portable and robust.
 *
 * References:
 * - DrCov format analysis: https://www.ayrx.me/drcov-file-format/
 * - DynamoRIO drcov tool: https://dynamorio.org/
 * - Lighthouse plugin: https://github.com/gaasedelen/lighthouse
 *
 * Example usage:
 * @code
 * // Reading a file
 * auto coverage = drcov::read("coverage.drcov");
 * if (coverage.has_hitcounts()) {
 *   // Process hitcount data
 *   for (size_t i = 0; i < coverage.basic_blocks.size(); ++i) {
 *     auto& bb = coverage.basic_blocks[i];
 *     auto hitcount = coverage.hitcounts[i];
 *     // Process basic block with its hitcount
 *   }
 * }
 *
 * // Creating coverage data with hitcounts
 * auto builder = drcov::builder()
 *     .enable_hitcounts()  // Sets flavor to "drcov-hits"
 *     .set_module_version(drcov::module_table_version::v4)
 *     .add_module("/bin/program", 0x400000, 0x450000)
 *     .add_module("/lib/libc.so", 0x7fff00000000, 0x7fff00100000)
 *     .add_coverage(0, 0x1000, 32, 5)  // module 0, offset 0x1000, 32 bytes, hit 5 times
 *     .add_coverage(0, 0x1020, 16, 1000)  // Hot path hit 1000 times
 *     .build();
 *
 * // Writing to file
 * drcov::write("output.drcov", builder);
 * @endcode
 */

#ifndef DRCOV_HPP
#define DRCOV_HPP

#include <algorithm>
#include <cstdint>
#include <cstring>
#include <fstream>
#include <iomanip>
#include <memory>
#include <optional>
#include <sstream>
#include <stdexcept>
#include <string>
#include <string_view>
#include <unordered_map>
#include <variant>
#include <vector>

// endianness detection for portable binary I/O
#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
#define DRCOV_LITTLE_ENDIAN 1
#elif defined(_WIN32)
#define DRCOV_LITTLE_ENDIAN 1
#elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
#define DRCOV_LITTLE_ENDIAN 0
#else
#warning "Could not determine endianness. Assuming little-endian."
#define DRCOV_LITTLE_ENDIAN 1
#endif

namespace drcov {

// forward declarations
class parse_error;
struct module_entry;
struct basic_block;
struct file_header;
struct coverage_data;
class coverage_builder;

/**
 * @brief Constants used throughout the library
 */
namespace constants {
constexpr uint32_t supported_file_version = 2;
constexpr size_t bb_entry_size = 8;
constexpr std::string_view version_prefix = "DRCOV VERSION: ";
constexpr std::string_view flavor_prefix = "DRCOV FLAVOR: ";
constexpr std::string_view module_table_prefix = "Module Table: ";
constexpr std::string_view bb_table_prefix = "BB Table: ";
constexpr std::string_view columns_prefix = "Columns: ";
constexpr std::string_view hitcount_table_prefix = "Hit Count Table: ";
constexpr std::string_view drcov_hits_flavor = "drcov-hits";
} // namespace constants

/**
 * @brief Error codes for parse operations
 */
enum class error_code {
  success = 0,
  file_not_found,
  invalid_format,
  unsupported_version,
  invalid_module_table,
  invalid_bb_table,
  invalid_hitcount_table,
  io_error,
  memory_error,
  invalid_binary_data,
  validation_error
};

/**
 * @brief Exception thrown by parse/write operations
 */
class parse_error : public std::runtime_error {
public:
  explicit parse_error(error_code code, const std::string& message) : std::runtime_error(message), code_(code) {}

  error_code code() const noexcept { return code_; }

private:
  error_code code_;
};

// internal utility functions
namespace detail {
inline std::string trim(const std::string& str) {
  auto start = str.find_first_not_of(" \t\r\n");
  auto end = str.find_last_not_of(" \t\r\n");
  return (start == std::string::npos) ? "" : str.substr(start, end - start + 1);
}

inline std::vector<std::string> split(const std::string& str, char delimiter) {
  std::vector<std::string> tokens;
  std::stringstream ss(str);
  std::string token;
  while (std::getline(ss, token, delimiter)) {
    tokens.push_back(trim(token));
  }
  return tokens;
}

template <typename T> inline T read_le(const uint8_t* data) {
  T value{};
#if DRCOV_LITTLE_ENDIAN
  std::memcpy(&value, data, sizeof(T));
#else
  for (size_t i = 0; i < sizeof(T); ++i) {
    value |= static_cast<T>(data[i]) << (i * 8);
  }
#endif
  return value;
}

template <typename T> inline void write_le(uint8_t* data, T value) {
#if DRCOV_LITTLE_ENDIAN
  std::memcpy(data, &value, sizeof(T));
#else
  for (size_t i = 0; i < sizeof(T); ++i) {
    data[i] = static_cast<uint8_t>((value >> (i * 8)) & 0xFF);
  }
#endif
}
} // namespace detail

/**
 * @brief DrCov file header containing version and tool information
 */
struct file_header {
  uint32_t version{constants::supported_file_version};
  std::string flavor{"drcov"};

  std::string to_string() const {
    std::stringstream ss;
    ss << constants::version_prefix << version << "\n";
    ss << constants::flavor_prefix << flavor << "\n";
    return ss.str();
  }
};

/**
 * @brief Module table format versions
 */
enum class module_table_version : uint32_t { legacy = 1, v2 = 2, v3 = 3, v4 = 4 };

/**
 * @brief Represents a loaded module/library in the traced process
 */
struct module_entry {
  uint32_t id{0};
  uint64_t base{0};
  uint64_t end{0};
  uint64_t entry{0};
  std::string path;

  std::optional<int32_t> containing_id;
  std::optional<uint64_t> offset;
  std::optional<uint32_t> checksum;
  std::optional<uint32_t> timestamp;

  uint64_t size() const noexcept { return end - base; }

  bool contains_address(uint64_t addr) const noexcept { return addr >= base && addr < end; }

  module_entry() = default;

  module_entry(uint32_t id, const std::string& path, uint64_t base, uint64_t end, uint64_t entry = 0)
      : id(id), base(base), end(end), entry(entry), path(path) {}
};

/**
 * @brief Represents an executed basic block
 */
struct basic_block {
  uint32_t start{0};
  uint16_t size{0};
  uint16_t module_id{0};

  uint64_t absolute_address(const module_entry& module) const noexcept { return module.base + start; }

  basic_block() = default;

  basic_block(uint32_t start, uint16_t size, uint16_t module_id) : start(start), size(size), module_id(module_id) {}
};

/**
 * @brief Complete coverage data structure
 */
struct coverage_data {
  file_header header;
  module_table_version module_version{module_table_version::v2};
  std::vector<module_entry> modules;
  std::vector<basic_block> basic_blocks;
  std::vector<uint32_t> hitcounts; // Optional hitcount data, parallel to basic_blocks

  std::optional<std::reference_wrapper<const module_entry>> find_module(uint16_t id) const {
    if (id < modules.size() && modules[id].id == id) {
      return std::cref(modules[id]);
    }
    auto it = std::find_if(modules.begin(), modules.end(), [id](const auto& m) { return m.id == id; });
    return it != modules.end() ? std::optional<std::reference_wrapper<const module_entry>>(*it) : std::nullopt;
  }

  std::optional<std::reference_wrapper<const module_entry>> find_module_by_address(uint64_t addr) const {
    auto it = std::find_if(modules.begin(), modules.end(), [addr](const auto& m) { return m.contains_address(addr); });
    return it != modules.end() ? std::optional<std::reference_wrapper<const module_entry>>(*it) : std::nullopt;
  }

  std::unordered_map<uint16_t, size_t> get_coverage_stats() const {
    std::unordered_map<uint16_t, size_t> stats;
    for (const auto& bb : basic_blocks) {
      stats[bb.module_id]++;
    }
    return stats;
  }

  bool has_hitcounts() const noexcept { return !hitcounts.empty() && hitcounts.size() == basic_blocks.size(); }

  void validate() const {
    for (size_t i = 0; i < modules.size(); ++i) {
      if (modules[i].id != i) {
        throw parse_error(
            error_code::validation_error,
            "Non-sequential module ID " + std::to_string(modules[i].id) + " at index " + std::to_string(i)
        );
      }
    }

    for (const auto& bb : basic_blocks) {
      if (bb.module_id >= modules.size()) {
        throw parse_error(
            error_code::validation_error, "Basic block references invalid module ID: " + std::to_string(bb.module_id)
        );
      }
    }

    // validate hitcount data if present
    if (!hitcounts.empty() && hitcounts.size() != basic_blocks.size()) {
      throw parse_error(
          error_code::validation_error, "Hitcount array size (" + std::to_string(hitcounts.size()) +
                                            ") does not match basic blocks count (" +
                                            std::to_string(basic_blocks.size()) + ")"
      );
    }
  }
};

/**
 * @brief Builder pattern for creating coverage data
 */
class coverage_builder {
public:
  coverage_builder() {
    data_.header.version = constants::supported_file_version;
    data_.header.flavor = "drcov";
    data_.module_version = module_table_version::v2;
  }

  coverage_builder& set_flavor(const std::string& flavor) {
    data_.header.flavor = flavor;
    return *this;
  }

  coverage_builder& enable_hitcounts() {
    data_.header.flavor = std::string(constants::drcov_hits_flavor);
    return *this;
  }

  coverage_builder& set_module_version(module_table_version version) {
    data_.module_version = version;
    return *this;
  }

  coverage_builder& add_module(const std::string& path, uint64_t base, uint64_t end, uint64_t entry = 0) {
    uint32_t id = static_cast<uint32_t>(data_.modules.size());
    data_.modules.emplace_back(id, path, base, end, entry);
    return *this;
  }

  coverage_builder& add_module(module_entry module) {
    data_.modules.push_back(std::move(module));
    return *this;
  }

  coverage_builder& add_coverage(uint16_t module_id, uint32_t offset, uint16_t size, uint32_t hitcount = 1) {
    data_.basic_blocks.emplace_back(offset, size, module_id);
    if (data_.header.flavor == constants::drcov_hits_flavor) {
      data_.hitcounts.push_back(hitcount);
    }
    return *this;
  }

  coverage_builder& add_basic_block(basic_block block, uint32_t hitcount = 1) {
    data_.basic_blocks.push_back(std::move(block));
    if (data_.header.flavor == constants::drcov_hits_flavor) {
      data_.hitcounts.push_back(hitcount);
    }
    return *this;
  }

  coverage_builder& add_basic_blocks(const std::vector<basic_block>& blocks) {
    data_.basic_blocks.insert(data_.basic_blocks.end(), blocks.begin(), blocks.end());
    if (data_.header.flavor == constants::drcov_hits_flavor) {
      data_.hitcounts.resize(data_.basic_blocks.size(), 1); // Default hitcount of 1
    }
    return *this;
  }

  coverage_builder& add_basic_blocks_with_hitcounts(
      const std::vector<basic_block>& blocks, const std::vector<uint32_t>& hitcounts
  ) {
    if (blocks.size() != hitcounts.size()) {
      throw std::invalid_argument("Blocks and hitcounts arrays must have the same size");
    }
    data_.basic_blocks.insert(data_.basic_blocks.end(), blocks.begin(), blocks.end());
    data_.hitcounts.insert(data_.hitcounts.end(), hitcounts.begin(), hitcounts.end());
    if (data_.header.flavor != constants::drcov_hits_flavor) {
      data_.header.flavor = std::string(constants::drcov_hits_flavor);
    }
    return *this;
  }

  coverage_builder& clear_coverage() {
    data_.basic_blocks.clear();
    data_.hitcounts.clear();
    return *this;
  }

  coverage_data build() {
    data_.validate();
    return std::move(data_);
  }

  coverage_data& data() { return data_; }
  const coverage_data& data() const { return data_; }

private:
  coverage_data data_;
};

// parser implementation
class parser {
public:
  static coverage_data parse_file(const std::string& filepath) {
    std::ifstream file(filepath, std::ios::binary);
    if (!file) {
      throw parse_error(error_code::file_not_found, "Cannot open file: " + filepath);
    }
    return parse_stream(file);
  }

  static coverage_data parse_stream(std::istream& stream) {
    coverage_data data;
    data.header = parse_header(stream);
    std::tie(data.modules, data.module_version) = parse_module_table(stream);
    data.basic_blocks = parse_bb_table(stream);

    // try to parse hitcount table if the flavor indicates hits support
    if (data.header.flavor == constants::drcov_hits_flavor) {
      data.hitcounts = parse_hitcount_table(stream, data.basic_blocks.size());
    }

    data.validate();
    return data;
  }

private:
  static file_header parse_header(std::istream& stream) {
    file_header header;
    std::string line;

    if (!std::getline(stream, line)) {
      throw parse_error(error_code::invalid_format, "Missing version header");
    }
    if (line.rfind(constants::version_prefix, 0) != 0) {
      throw parse_error(error_code::invalid_format, "Invalid version header format");
    }
    try {
      header.version = std::stoul(line.substr(constants::version_prefix.length()));
    } catch (const std::exception& e) {
      throw parse_error(error_code::invalid_format, "Malformed version number: " + std::string(e.what()));
    }

    if (!std::getline(stream, line)) {
      throw parse_error(error_code::invalid_format, "Missing flavor header");
    }
    if (line.rfind(constants::flavor_prefix, 0) != 0) {
      throw parse_error(error_code::invalid_format, "Invalid flavor header format");
    }
    header.flavor = detail::trim(line.substr(constants::flavor_prefix.length()));

    return header;
  }

  static std::pair<std::vector<module_entry>, module_table_version> parse_module_table(std::istream& stream) {
    std::string line;

    if (!std::getline(stream, line)) {
      throw parse_error(error_code::invalid_format, "Missing module table header");
    }
    if (line.rfind(constants::module_table_prefix, 0) != 0) {
      throw parse_error(error_code::invalid_format, "Invalid module table header");
    }

    auto [version, count] = parse_module_header(line);

    std::vector<std::string> columns;
    if (version != module_table_version::legacy) {
      if (!std::getline(stream, line)) {
        throw parse_error(error_code::invalid_format, "Missing columns header");
      }
      columns = parse_columns_header(line);
    } else {
      columns = {"id", "base", "end", "entry", "path"};
    }

    std::vector<module_entry> modules;
    modules.reserve(count);
    size_t modules_read = 0;

    while (modules_read < count && std::getline(stream, line)) {
      auto trimmed_line = detail::trim(line);
      if (trimmed_line.empty()) {
        continue;
      }

      auto module = parse_module_entry(trimmed_line, columns);
      if (module.id != modules_read) {
        throw parse_error(
            error_code::invalid_module_table,
            "Non-sequential module ID. Expected " + std::to_string(modules_read) + ", got " + std::to_string(module.id)
        );
      }

      modules.push_back(std::move(module));
      modules_read++;
    }

    if (modules_read != count) {
      throw parse_error(
          error_code::invalid_module_table, "Module table entry count mismatch. Expected " + std::to_string(count) +
                                                ", but found " + std::to_string(modules_read)
      );
    }

    return {modules, version};
  }

  static std::pair<module_table_version, size_t> parse_module_header(const std::string& line) {
    auto content = line.substr(constants::module_table_prefix.length());
    try {
      if (content.find("version") == std::string::npos) {
        return {module_table_version::legacy, std::stoul(content)};
      }
      auto parts = detail::split(content, ',');
      if (parts.size() != 2) {
        throw parse_error(error_code::invalid_format, "Invalid module table header format");
      }
      auto version_str = parts[0].substr(parts[0].find("version") + 8);
      auto count_str = parts[1].substr(parts[1].find("count") + 6);
      return {static_cast<module_table_version>(std::stoul(version_str)), std::stoul(count_str)};
    } catch (const std::exception& e) {
      throw parse_error(error_code::invalid_format, "Failed to parse module table header: " + std::string(e.what()));
    }
  }

  static std::vector<std::string> parse_columns_header(const std::string& line) {
    if (line.rfind(constants::columns_prefix, 0) != 0) {
      throw parse_error(error_code::invalid_format, "Invalid columns header");
    }
    return detail::split(line.substr(constants::columns_prefix.length()), ',');
  }

  static std::vector<std::string> parse_module_line(const std::string& line, size_t num_columns) {
    std::vector<std::string> values;
    if (num_columns == 0) {
      return values;
    }
    values.reserve(num_columns);
    std::string::size_type current_pos = 0;
    for (size_t i = 0; i < num_columns - 1; ++i) {
      auto comma_pos = line.find(',', current_pos);
      if (comma_pos == std::string::npos) {
        throw parse_error(error_code::invalid_module_table, "Module entry has too few columns");
      }
      values.push_back(detail::trim(line.substr(current_pos, comma_pos - current_pos)));
      current_pos = comma_pos + 1;
    }
    values.push_back(detail::trim(line.substr(current_pos)));
    return values;
  }

  static module_entry parse_module_entry(const std::string& line, const std::vector<std::string>& columns) {
    auto values = parse_module_line(line, columns.size());
    if (values.size() != columns.size()) {
      throw parse_error(error_code::invalid_module_table, "Module entry column count mismatch");
    }

    module_entry entry;
    std::unordered_map<std::string, std::string> value_map;
    for (size_t i = 0; i < columns.size(); ++i) {
      value_map[columns[i]] = values[i];
    }

    auto get_val = [&](const std::string& key) -> std::optional<std::string> {
      auto it = value_map.find(key);
      return (it != value_map.end()) ? std::optional(it->second) : std::nullopt;
    };

    try {
      if (auto val = get_val("id")) {
        entry.id = std::stoul(*val);
      }
      if (auto val = get_val("base")) {
        entry.base = std::stoull(*val, nullptr, 16);
      }
      if (auto val = get_val("start")) {
        entry.base = std::stoull(*val, nullptr, 16);
      }
      if (auto val = get_val("end")) {
        entry.end = std::stoull(*val, nullptr, 16);
      }
      if (auto val = get_val("entry")) {
        entry.entry = std::stoull(*val, nullptr, 16);
      }
      if (auto val = get_val("path")) {
        entry.path = *val;
      }
      if (auto val = get_val("containing_id")) {
        entry.containing_id = std::stol(*val);
      }
      if (auto val = get_val("offset")) {
        entry.offset = std::stoull(*val, nullptr, 16);
      }
      if (auto val = get_val("checksum")) {
        entry.checksum = std::stoul(*val, nullptr, 16);
      }
      if (auto val = get_val("timestamp")) {
        entry.timestamp = std::stoul(*val, nullptr, 16);
      }
    } catch (const std::exception& e) {
      throw parse_error(
          error_code::invalid_module_table, "Malformed numeric value in module entry '" + line + "': " + e.what()
      );
    }
    return entry;
  }

  static std::vector<basic_block> parse_bb_table(std::istream& stream) {
    std::string line;

    if (!std::getline(stream, line)) {
      if (stream.eof() && stream.gcount() == 0) {
        return {};
      }
      throw parse_error(error_code::invalid_format, "Missing BB table header");
    }

    if (line.rfind(constants::bb_table_prefix, 0) != 0) {
      throw parse_error(error_code::invalid_format, "Invalid BB table header");
    }

    size_t count = 0;
    try {
      auto content = line.substr(constants::bb_table_prefix.length());
      count = std::stoul(content.substr(0, content.find(' ')));
    } catch (const std::exception& e) {
      throw parse_error(error_code::invalid_bb_table, "Malformed BB table count: " + std::string(e.what()));
    }

    if (count == 0) {
      return {};
    }

    std::vector<uint8_t> binary_data(count * constants::bb_entry_size);
    stream.read(reinterpret_cast<char*>(binary_data.data()), binary_data.size());
    if (static_cast<size_t>(stream.gcount()) != binary_data.size()) {
      throw parse_error(error_code::invalid_binary_data, "Failed to read complete BB table binary data");
    }

    std::vector<basic_block> blocks;
    blocks.reserve(count);
    for (size_t i = 0; i < count; ++i) {
      const uint8_t* entry_data = binary_data.data() + (i * constants::bb_entry_size);
      blocks.emplace_back(
          detail::read_le<uint32_t>(entry_data), detail::read_le<uint16_t>(entry_data + 4),
          detail::read_le<uint16_t>(entry_data + 6)
      );
    }
    return blocks;
  }

  static std::vector<uint32_t> parse_hitcount_table(std::istream& stream, size_t expected_count) {
    std::string line;

    // try to read hitcount table header
    if (!std::getline(stream, line)) {
      // no hitcount table found - this is OK for backward compatibility
      return {};
    }

    // check if this is actually a hitcount table header
    if (line.rfind(constants::hitcount_table_prefix, 0) != 0) {
      // not a hitcount table - put the line back and return empty
      // note: In practice this is difficult to do with ifstream, but we can return empty
      return {};
    }

    // parse hitcount table header: "Hit Count Table: version 1, count <N>"
    size_t version = 0;
    size_t count = 0;
    try {
      auto content = line.substr(constants::hitcount_table_prefix.length());
      auto parts = detail::split(content, ',');
      if (parts.size() != 2) {
        throw parse_error(error_code::invalid_hitcount_table, "Invalid hitcount table header format");
      }

      // parse version
      auto version_part = detail::trim(parts[0]);
      if (version_part.find("version") != 0) {
        throw parse_error(error_code::invalid_hitcount_table, "Missing version in hitcount table header");
      }
      version = std::stoul(version_part.substr(8)); // "version ".length()

      // parse count
      auto count_part = detail::trim(parts[1]);
      if (count_part.find("count") != 0) {
        throw parse_error(error_code::invalid_hitcount_table, "Missing count in hitcount table header");
      }
      count = std::stoul(count_part.substr(6)); // "count ".length()

    } catch (const std::exception& e) {
      throw parse_error(
          error_code::invalid_hitcount_table, "Failed to parse hitcount table header: " + std::string(e.what())
      );
    }

    // validate version
    if (version != 1) {
      throw parse_error(
          error_code::invalid_hitcount_table, "Unsupported hitcount table version: " + std::to_string(version)
      );
    }

    // validate count matches basic blocks
    if (count != expected_count) {
      throw parse_error(
          error_code::invalid_hitcount_table, "Hitcount table count (" + std::to_string(count) +
                                                  ") does not match basic blocks count (" +
                                                  std::to_string(expected_count) + ")"
      );
    }

    if (count == 0) {
      return {};
    }

    // read binary hitcount data
    std::vector<uint8_t> binary_data(count * sizeof(uint32_t));
    stream.read(reinterpret_cast<char*>(binary_data.data()), binary_data.size());
    if (static_cast<size_t>(stream.gcount()) != binary_data.size()) {
      throw parse_error(error_code::invalid_binary_data, "Failed to read complete hitcount table binary data");
    }

    // convert binary data to hitcounts
    std::vector<uint32_t> hitcounts;
    hitcounts.reserve(count);
    for (size_t i = 0; i < count; ++i) {
      const uint8_t* hitcount_data = binary_data.data() + (i * sizeof(uint32_t));
      hitcounts.push_back(detail::read_le<uint32_t>(hitcount_data));
    }

    return hitcounts;
  }
};

// writer implementation
class writer {
public:
  static void write_file(const coverage_data& data, const std::string& filepath) {
    std::ofstream file(filepath, std::ios::binary);
    if (!file) {
      throw parse_error(error_code::io_error, "Cannot create file: " + filepath);
    }
    write_stream(data, file);
  }

  static void write_stream(const coverage_data& data, std::ostream& stream) {
    data.validate();
    stream << data.header.to_string();
    write_module_table(data, stream);
    write_bb_table(data.basic_blocks, stream);

    // write hitcount table if present
    if (data.has_hitcounts()) {
      write_hitcount_table(data.hitcounts, stream);
    }

    if (!stream) {
      throw parse_error(error_code::io_error, "Error writing to stream");
    }
  }

private:
  static void write_module_table(const coverage_data& data, std::ostream& stream) {
    if (data.module_version == module_table_version::legacy) {
      stream << constants::module_table_prefix << data.modules.size() << "\n";
      for (const auto& module : data.modules) {
        write_module_entry(module, data.module_version, false, stream);
        stream << "\n";
      }
    } else {
      stream << constants::module_table_prefix << "version " << static_cast<uint32_t>(data.module_version) << ", count "
             << data.modules.size() << "\n";
      std::string columns_str = get_columns_string(data);
      stream << constants::columns_prefix << columns_str << "\n";
      bool has_windows_fields = columns_str.find("checksum") != std::string::npos;
      for (const auto& module : data.modules) {
        write_module_entry(module, data.module_version, has_windows_fields, stream);
        stream << "\n";
      }
    }
  }

  static std::string get_columns_string(const coverage_data& data) {
    const bool has_windows_fields = std::any_of(data.modules.begin(), data.modules.end(), [](const auto& m) {
      return m.checksum.has_value() || m.timestamp.has_value();
    });

    switch (data.module_version) {
    case module_table_version::legacy:
      return "id, base, end, entry, path"; // Enforce fixed legacy format
    case module_table_version::v2:
      return has_windows_fields ? "id, base, end, entry, checksum, timestamp, path" : "id, base, end, entry, path";
    case module_table_version::v3:
      return has_windows_fields ? "id, containing_id, start, end, entry, checksum, timestamp, path"
                                : "id, containing_id, start, end, entry, path";
    case module_table_version::v4:
      return has_windows_fields ? "id, containing_id, start, end, entry, offset, checksum, timestamp, path"
                                : "id, containing_id, start, end, entry, offset, path";
    default: // Should be unreachable
      return "id, base, end, entry, path";
    }
  }

  static void write_module_entry(
      const module_entry& module, module_table_version version, bool has_windows_fields, std::ostream& stream
  ) {
    auto original_flags = stream.flags();
    auto original_fill = stream.fill();
    stream << std::dec << module.id;

    if (version >= module_table_version::v3) {
      stream << ", " << module.containing_id.value_or(-1);
    }

    stream << ", 0x" << std::hex << std::setfill('0') << std::setw(16) << module.base;
    stream << ", 0x" << std::hex << std::setfill('0') << std::setw(16) << module.end;
    stream << ", 0x" << std::hex << std::setfill('0') << std::setw(16) << module.entry;

    if (version >= module_table_version::v4) {
      stream << ", ";
      if (module.offset) {
        stream << "0x" << std::hex << std::setfill('0') << std::setw(16) << *module.offset;
      } else {
        stream << "0x0";
      }
    }

    if (has_windows_fields) {
      stream << ", 0x" << std::hex << std::setfill('0') << std::setw(8) << module.checksum.value_or(0);
      stream << ", 0x" << std::hex << std::setfill('0') << std::setw(8) << module.timestamp.value_or(0);
    }

    stream << ", " << module.path;
    stream.flags(original_flags);
    stream.fill(original_fill);
  }

  static void write_bb_table(const std::vector<basic_block>& blocks, std::ostream& stream) {
    stream << constants::bb_table_prefix << blocks.size() << " bbs\n";
    if (blocks.empty()) {
      return;
    }
    std::vector<uint8_t> binary_data(blocks.size() * constants::bb_entry_size);
    for (size_t i = 0; i < blocks.size(); ++i) {
      uint8_t* entry_data = binary_data.data() + (i * constants::bb_entry_size);
      detail::write_le<uint32_t>(entry_data, blocks[i].start);
      detail::write_le<uint16_t>(entry_data + 4, blocks[i].size);
      detail::write_le<uint16_t>(entry_data + 6, blocks[i].module_id);
    }
    stream.write(reinterpret_cast<const char*>(binary_data.data()), binary_data.size());
  }

  static void write_hitcount_table(const std::vector<uint32_t>& hitcounts, std::ostream& stream) {
    if (hitcounts.empty()) {
      return;
    }

    // write hitcount table header
    stream << constants::hitcount_table_prefix << "version 1, count " << hitcounts.size() << "\n";

    // write binary hitcount data
    std::vector<uint8_t> binary_data(hitcounts.size() * sizeof(uint32_t));
    for (size_t i = 0; i < hitcounts.size(); ++i) {
      uint8_t* hitcount_data = binary_data.data() + (i * sizeof(uint32_t));
      detail::write_le<uint32_t>(hitcount_data, hitcounts[i]);
    }
    stream.write(reinterpret_cast<const char*>(binary_data.data()), binary_data.size());
  }
};

inline coverage_data read(const std::string& filepath) { return parser::parse_file(filepath); }
inline coverage_data read(std::istream& stream) { return parser::parse_stream(stream); }
inline void write(const std::string& filepath, const coverage_data& data) { writer::write_file(data, filepath); }
inline void write(std::ostream& stream, const coverage_data& data) { writer::write_stream(data, stream); }
inline coverage_builder builder() { return coverage_builder(); }

} // namespace drcov

#undef DRCOV_LITTLE_ENDIAN

#endif // DRCOV_HPP
```

`src/w1tn3ss/formats/graphvizdot.hpp`:

```hpp
/*
graphvizdot.hpp

A modern, header-only C++17 library for generating Graphviz DOT language files.

This library provides a fluent and expressive interface for programmatically creating
graph structures and serializing them to the DOT format. It handles object lifecycle
management and DOT syntax details, such as quoting, automatically. The design
prioritizes a clean API, ease of use, and deterministic output.

Usage Example:

// create a directed graph with a specified ID.
graphvizdot::graph my_graph("example_graph", graphvizdot::graph_type::directed);

// set a global graph attribute using a type-safe enum.
my_graph.set_rank_dir(graphvizdot::rank_dir::left_to_right);

// add nodes and chain attribute settings for a fluent configuration.
my_graph.add_node("Start").set("shape", "Mdiamond").set("color", "green");
my_graph.add_node("End").set("shape", "Msquare").set("color", "red");

// add an edge connecting two nodes and set its label.
my_graph.add_edge("Start", "End").set("label", "initial transition");

// generate and print the DOT file content to standard output.
std::cout << my_graph.to_string() << std::endl;

// alternatively, write the output directly to a file.
my_graph.write_to_file("example.dot");

*/

#ifndef GRAPHVIZDOT_HPP_
#define GRAPHVIZDOT_HPP_

#include <string>
#include <string_view>
#include <vector>
#include <map>
#include <set>
#include <optional>
#include <fstream>
#include <sstream>
#include <stdexcept>

// - main library namespace
namespace graphvizdot {

// - forward declarations
// forward declarations are necessary to resolve the circular dependencies
// between graph, subgraph, and writer within a single header file.
class attribute_set;
class node;
class edge;
class subgraph;
class graph;
class writer;

// - internal helper functions
namespace internal {

// checks if a string is a valid dot language id or if it requires quoting.
// a valid id is alphanumeric or a numeral, but cannot start with a numeral unless
// it is a number. this is a simplified, safer check that quotes anything that
// is not strictly alphanumeric (plus underscore). it also handles escaping
// quotes within the string.
inline std::string quote_if_needed(std::string_view str) {
  if (str.empty()) {
    return "\"\"";
  }

  bool needs_quoting = false;
  for (char c : str) {
    if (!std::isalnum(c) && c != '_') {
      needs_quoting = true;
      break;
    }
  }

  if (!needs_quoting) {
    // check for keywords
    if (str == "graph" || str == "digraph" || str == "subgraph" || str == "node" || str == "edge" || str == "strict") {
      needs_quoting = true;
    }
  }

  if (!needs_quoting) {
    return std::string(str);
  }

  std::string result = "\"";
  for (char c : str) {
    if (c == '"') {
      result += "\\\"";
    } else {
      result += c;
    }
  }
  result += '"';
  return result;
}

} // namespace internal

// - library enumerations
enum class graph_type { directed, undirected };

enum class rank_dir { top_to_bottom, bottom_to_top, left_to_right, right_to_left };

// - attribute management
// a class to manage a set of key-value string attributes.
// uses std::map to ensure deterministic, sorted output of attributes.
class attribute_set {
public:
  attribute_set() = default;

  // sets an attribute key-value pair. returns a reference to self for chaining.
  inline attribute_set& set(std::string_view key, std::string_view value);

  // gets an attribute value by its key, if it exists.
  inline std::optional<std::string> get(std::string_view key) const;

  // checks if a specific attribute key exists.
  inline bool has(std::string_view key) const;

  // checks if there are any attributes in the set.
  inline bool is_empty() const;

  // provides direct access to the underlying map for iteration.
  inline const std::map<std::string, std::string>& get_all() const;

private:
  std::map<std::string, std::string> _attributes;
};

// - graph components
// represents a single node in the graph.
class node {
public:
  // constructs a node with a given id. id is stored internally.
  node(std::string_view id) : _id(id) {}

  // sets an attribute for this node.
  inline node& set(std::string_view key, std::string_view value);

  inline const std::string& get_id() const { return _id; }
  inline const attribute_set& get_attributes() const { return _attributes; }

private:
  std::string _id;
  attribute_set _attributes;
};

// represents a single edge between two nodes.
class edge {
public:
  // constructs an edge between two nodes, identified by their ids.
  edge(std::string_view from_id, std::string_view to_id) : _from_id(from_id), _to_id(to_id) {}

  // sets an attribute for this edge.
  inline edge& set(std::string_view key, std::string_view value);

  inline const std::string& get_from_id() const { return _from_id; }
  inline const std::string& get_to_id() const { return _to_id; }
  inline const attribute_set& get_attributes() const { return _attributes; }

private:
  std::string _from_id;
  std::string _to_id;
  attribute_set _attributes;
};

// - graph containers
// forward-declared graph is required for subgraph's pointer.
class graph;

// represents a subgraph, which can contain nodes and other subgraphs.
// nodes are not owned by the subgraph, but by the root graph. the subgraph
// only stores the ids of the nodes it contains.
class subgraph {
public:
  // subgraphs must be constructed with a reference to the root graph and an id.
  subgraph(graph* root_graph, std::string_view id) : _root_graph(root_graph), _id(id) {
    if (!_root_graph) {
      throw std::invalid_argument("subgraph must have a valid root graph.");
    }
  }

  // sets an attribute for the subgraph itself (e.g., label, bgcolor).
  inline subgraph& set(std::string_view key, std::string_view value);

  // adds a node to this subgraph by its id.
  // if the node does not exist in the root graph, it will be created.
  inline node& add_node(std::string_view id);

  // adds a nested subgraph.
  inline subgraph& add_subgraph(std::string_view id);

  inline const std::string& get_id() const { return _id; }
  inline const attribute_set& get_attributes() const { return _attributes; }
  inline const std::vector<std::string>& get_node_ids() const { return _node_ids; }
  inline const std::map<std::string, subgraph>& get_subgraphs() const { return _subgraphs; }

private:
  graph* _root_graph; // non-owning pointer to the root graph.
  std::string _id;
  attribute_set _attributes;
  std::vector<std::string> _node_ids;
  std::map<std::string, subgraph> _subgraphs;
};

// represents the main graph document.
// this class is the central owner of all nodes, edges, and top-level subgraphs.
class graph {
public:
  // constructs a graph with a given id and type.
  graph(std::string_view id, graph_type type = graph_type::directed) : _id(id), _type(type) {}

  // - graph structure configuration

  // adds a node to the graph. if a node with this id already exists,
  // a reference to the existing node is returned.
  inline node& add_node(std::string_view id);

  // adds an edge to the graph.
  // if the `from` or `to` nodes do not exist, they are implicitly created.
  inline edge& add_edge(std::string_view from_id, std::string_view to_id);

  // adds a top-level subgraph to the graph.
  inline subgraph& add_subgraph(std::string_view id);

  // - attribute configuration

  // sets an attribute for the graph itself (e.g., rankdir, label).
  inline graph& set(std::string_view key, std::string_view value);

  // sets a type-safe rankdir attribute for the graph.
  inline graph& set_rank_dir(rank_dir dir);

  // sets a default attribute for all nodes in the graph.
  inline graph& set_default_node_attribute(std::string_view key, std::string_view value);

  // sets a default attribute for all edges in the graph.
  inline graph& set_default_edge_attribute(std::string_view key, std::string_view value);

  // - output generation

  // generates the full dot language string representation of the graph.
  inline std::string to_string() const;

  // writes the dot language representation of the graph to a file.
  inline void write_to_file(const std::string& filepath) const;

  // - accessors

  inline const std::string& get_id() const { return _id; }
  inline graph_type get_graph_type() const { return _type; }
  inline const attribute_set& get_attributes() const { return _attributes; }
  inline const attribute_set& get_default_node_attributes() const { return _default_node_attributes; }
  inline const attribute_set& get_default_edge_attributes() const { return _default_edge_attributes; }
  inline const std::map<std::string, node>& get_nodes() const { return _nodes; }
  inline const std::vector<edge>& get_edges() const { return _edges; }
  inline const std::map<std::string, subgraph>& get_subgraphs() const { return _subgraphs; }

private:
  friend class subgraph; // allows subgraph to call add_node on the root.

  std::string _id;
  graph_type _type;
  attribute_set _attributes;
  attribute_set _default_node_attributes;
  attribute_set _default_edge_attributes;

  // the graph maintains ownership of all nodes and edges.
  std::map<std::string, node> _nodes;
  std::vector<edge> _edges;
  std::map<std::string, subgraph> _subgraphs;
};

// - writer implementation
// class responsible for serializing the graph object model into a dot string.
class writer {
public:
  writer(const graph& g) : _graph(g) {}

  // generates and returns the dot string.
  inline std::string to_string() {
    write_graph_header();
    write_body();
    write_footer();
    return _ss.str();
  }

private:
  inline void write_graph_header() {
    _ss << (_graph.get_graph_type() == graph_type::directed ? "digraph " : "graph ")
        << internal::quote_if_needed(_graph.get_id()) << " {\n";
    _indent++;
  }

  inline void write_body() {
    write_attributes(_graph.get_attributes());
    write_default_attributes("node", _graph.get_default_node_attributes());
    write_default_attributes("edge", _graph.get_default_edge_attributes());

    for (const auto& [id, sg] : _graph.get_subgraphs()) {
      write_subgraph(sg);
    }

    // write nodes that are not part of any subgraph
    for (const auto& [id, n] : _graph.get_nodes()) {
      if (_written_node_ids.find(id) == _written_node_ids.end()) {
        write_node(n);
      }
    }

    for (const auto& e : _graph.get_edges()) {
      write_edge(e);
    }
  }

  inline void write_subgraph(const subgraph& sg) {
    do_indent();
    _ss << "subgraph " << internal::quote_if_needed(sg.get_id()) << " {\n";
    _indent++;

    write_attributes(sg.get_attributes());

    for (const auto& [id, nested_sg] : sg.get_subgraphs()) {
      write_subgraph(nested_sg);
    }

    for (const auto& node_id : sg.get_node_ids()) {
      auto it = _graph.get_nodes().find(node_id);
      if (it != _graph.get_nodes().end()) {
        write_node(it->second);
        _written_node_ids.insert(node_id);
      }
    }

    _indent--;
    do_indent();
    _ss << "}\n";
  }

  inline void write_attributes(const attribute_set& attrs) {
    if (attrs.is_empty()) {
      return;
    }

    for (const auto& [key, val] : attrs.get_all()) {
      do_indent();
      _ss << key << " = " << internal::quote_if_needed(val) << ";\n";
    }
  }

  inline void write_default_attributes(std::string_view target, const attribute_set& attrs) {
    if (attrs.is_empty()) {
      return;
    }
    do_indent();
    _ss << target << " ";
    write_attribute_list(attrs);
    _ss << ";\n";
  }

  inline void write_node(const node& n) {
    do_indent();
    _ss << internal::quote_if_needed(n.get_id());
    if (!n.get_attributes().is_empty()) {
      _ss << " ";
      write_attribute_list(n.get_attributes());
    }
    _ss << ";\n";
  }

  inline void write_edge(const edge& e) {
    do_indent();
    const char* edge_op = _graph.get_graph_type() == graph_type::directed ? " -> " : " -- ";
    _ss << internal::quote_if_needed(e.get_from_id()) << edge_op << internal::quote_if_needed(e.get_to_id());

    if (!e.get_attributes().is_empty()) {
      _ss << " ";
      write_attribute_list(e.get_attributes());
    }
    _ss << ";\n";
  }

  inline void write_attribute_list(const attribute_set& attrs) {
    _ss << "[";
    bool first = true;
    for (const auto& [key, val] : attrs.get_all()) {
      if (!first) {
        _ss << ", ";
      }
      _ss << key << "=" << internal::quote_if_needed(val);
      first = false;
    }
    _ss << "]";
  }

  inline void write_footer() {
    _indent--;
    _ss << "}\n";
  }

  inline void do_indent() {
    for (int i = 0; i < _indent; ++i) {
      _ss << "    ";
    }
  }

  const graph& _graph;
  std::stringstream _ss;
  int _indent = 0;
  std::set<std::string> _written_node_ids;
};

// - method implementations

// attribute_set
inline attribute_set& attribute_set::set(std::string_view key, std::string_view value) {
  _attributes[std::string(key)] = std::string(value);
  return *this;
}

inline std::optional<std::string> attribute_set::get(std::string_view key) const {
  auto it = _attributes.find(std::string(key));
  if (it != _attributes.end()) {
    return it->second;
  }
  return std::nullopt;
}

inline bool attribute_set::has(std::string_view key) const { return _attributes.count(std::string(key)); }

inline bool attribute_set::is_empty() const { return _attributes.empty(); }

inline const std::map<std::string, std::string>& attribute_set::get_all() const { return _attributes; }

// node
inline node& node::set(std::string_view key, std::string_view value) {
  _attributes.set(key, value);
  return *this;
}

// edge
inline edge& edge::set(std::string_view key, std::string_view value) {
  _attributes.set(key, value);
  return *this;
}

// subgraph
inline subgraph& subgraph::set(std::string_view key, std::string_view value) {
  _attributes.set(key, value);
  return *this;
}

inline node& subgraph::add_node(std::string_view id) {
  _node_ids.emplace_back(id);
  return _root_graph->add_node(id);
}

inline subgraph& subgraph::add_subgraph(std::string_view id) {
  auto it = _subgraphs.find(std::string(id));
  if (it == _subgraphs.end()) {
    it = _subgraphs.emplace(std::piecewise_construct, std::forward_as_tuple(id), std::forward_as_tuple(_root_graph, id))
             .first;
  }
  return it->second;
}

// graph
inline node& graph::add_node(std::string_view id) {
  auto it = _nodes.find(std::string(id));
  if (it == _nodes.end()) {
    // emplace returns a pair of <iterator, bool>, we want the iterator's second (the value)
    it = _nodes.emplace(std::piecewise_construct, std::forward_as_tuple(id), std::forward_as_tuple(id)).first;
  }
  return it->second;
}

inline edge& graph::add_edge(std::string_view from_id, std::string_view to_id) {
  add_node(from_id); // ensure nodes exist
  add_node(to_id);
  return _edges.emplace_back(from_id, to_id);
}

inline subgraph& graph::add_subgraph(std::string_view id) {
  auto it = _subgraphs.find(std::string(id));
  if (it == _subgraphs.end()) {
    it = _subgraphs.emplace(std::piecewise_construct, std::forward_as_tuple(id), std::forward_as_tuple(this, id)).first;
  }
  return it->second;
}

inline graph& graph::set(std::string_view key, std::string_view value) {
  _attributes.set(key, value);
  return *this;
}

inline graph& graph::set_rank_dir(rank_dir dir) {
  std::string_view val;
  switch (dir) {
  case rank_dir::top_to_bottom:
    val = "TB";
    break;
  case rank_dir::bottom_to_top:
    val = "BT";
    break;
  case rank_dir::left_to_right:
    val = "LR";
    break;
  case rank_dir::right_to_left:
    val = "RL";
    break;
  }
  _attributes.set("rankdir", val);
  return *this;
}

inline graph& graph::set_default_node_attribute(std::string_view key, std::string_view value) {
  _default_node_attributes.set(key, value);
  return *this;
}

inline graph& graph::set_default_edge_attribute(std::string_view key, std::string_view value) {
  _default_edge_attributes.set(key, value);
  return *this;
}

inline std::string graph::to_string() const {
  writer w(*this);
  return w.to_string();
}

inline void graph::write_to_file(const std::string& filepath) const {
  std::ofstream out_file(filepath);
  if (!out_file) {
    throw std::runtime_error("failed to open file for writing: " + filepath);
  }
  out_file << to_string();
}

} // namespace graphvizdot

#endif // GRAPHVIZDOT_HPP_
```

`src/w1tn3ss/hooking/hook_manager.cpp`:

```cpp
#include "hook_manager.hpp"
#include <w1tn3ss/util/module_range_index.hpp>
#include <w1tn3ss/util/module_scanner.hpp>
#include <stdexcept>

namespace w1::hooking {

hook_manager::~hook_manager() { remove_all_hooks(); }

uint32_t hook_manager::hook_addr(QBDI::rword address, hook_handler handler) {
  uint32_t hook_id = next_hook_id_++;

  hook_info info;
  info.id = hook_id;
  info.handler = std::move(handler);
  info.address = address;

  // register with QBDI
  info.qbdi_id = vm_->addCodeAddrCB(
      address, QBDI::PREINST, hook_callback_wrapper,
      &hooks_[hook_id] // pass hook_info as data
  );

  if (info.qbdi_id == QBDI::INVALID_EVENTID) {
    log_.err("failed to register hook", redlog::field("address", "0x%lx", address));
    return 0;
  }

  hooks_[hook_id] = std::move(info);
  log_.vrb("registered address hook", redlog::field("id", hook_id), redlog::field("address", "0x%lx", address));

  return hook_id;
}

uint32_t hook_manager::hook_module(const std::string& module_name, QBDI::rword offset, hook_handler handler) {
  // find module base address
  util::module_scanner scanner;
  auto modules = scanner.scan_executable_modules();
  util::module_range_index module_index(std::move(modules));

  auto module = find_module_with_extensions(module_index, module_name);
  if (!module) {
    log_.err("module not found", redlog::field("module", module_name));
    return 0;
  }

  QBDI::rword target_address = module->base_address + offset;

  // validate address is within module bounds
  if (offset >= module->size) {
    log_.err(
        "offset exceeds module bounds", redlog::field("module", module_name), redlog::field("offset", "0x%lx", offset),
        redlog::field("module_size", "0x%lx", module->size)
    );
    return 0;
  }

  log_.trc(
      "hooking module+offset", redlog::field("module", module_name), redlog::field("offset", "0x%lx", offset),
      redlog::field("address", "0x%lx", target_address)
  );

  return hook_addr(target_address, std::move(handler));
}

uint32_t hook_manager::hook_range(QBDI::rword start, QBDI::rword end, hook_handler handler) {
  if (start >= end) {
    log_.err("invalid range", redlog::field("start", "0x%lx", start), redlog::field("end", "0x%lx", end));
    return 0;
  }

  uint32_t hook_id = next_hook_id_++;

  hook_info info;
  info.id = hook_id;
  info.handler = std::move(handler);
  info.range = {start, end};

  // register with QBDI
  info.qbdi_id = vm_->addCodeRangeCB(
      start, end, QBDI::PREINST, hook_callback_wrapper,
      &hooks_[hook_id] // pass hook_info as data
  );

  if (info.qbdi_id == QBDI::INVALID_EVENTID) {
    log_.err(
        "failed to register range hook", redlog::field("start", "0x%lx", start), redlog::field("end", "0x%lx", end)
    );
    return 0;
  }

  hooks_[hook_id] = std::move(info);
  log_.vrb(
      "registered range hook", redlog::field("id", hook_id), redlog::field("start", "0x%lx", start),
      redlog::field("end", "0x%lx", end)
  );

  return hook_id;
}

bool hook_manager::remove_hook(uint32_t hook_id) {
  auto it = hooks_.find(hook_id);
  if (it == hooks_.end()) {
    return false;
  }

  if (it->second.qbdi_id != QBDI::INVALID_EVENTID) {
    vm_->deleteInstrumentation(it->second.qbdi_id);
  }

  hooks_.erase(it);
  log_.dbg("removed hook", redlog::field("id", hook_id));
  return true;
}

void hook_manager::remove_all_hooks() {
  for (auto& [id, info] : hooks_) {
    if (info.qbdi_id != QBDI::INVALID_EVENTID) {
      vm_->deleteInstrumentation(info.qbdi_id);
    }
  }
  hooks_.clear();
  log_.dbg("removed all hooks");
}

QBDI::VMAction hook_manager::hook_callback_wrapper(
    QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr, void* data
) {
  if (!data) {
    return QBDI::VMAction::CONTINUE;
  }

  hook_info* info = static_cast<hook_info*>(data);

  // determine current address
  QBDI::rword current_addr = QBDI_GPR_GET(gpr, QBDI::REG_PC);

  try {
    return info->handler(vm, gpr, fpr, current_addr);
  } catch (const std::exception& e) {
    auto log = redlog::get_logger("w1.hook_manager");
    log.err("exception in hook handler", redlog::field("error", e.what()));
    return QBDI::VMAction::CONTINUE;
  }
}

const w1::util::module_info* hook_manager::find_module_with_extensions(
    const w1::util::module_range_index& module_index, const std::string& module_name
) const {
  // first try exact match
  auto module = module_index.find_by_name(module_name);
  if (module) {
    return module;
  }

  // if name already contains a dot, don't try extensions
  if (module_name.find('.') != std::string::npos) {
    return nullptr;
  }

  log_.dbg(
      "module not found with exact name, trying platform-specific extensions", redlog::field("module", module_name)
  );

  // try platform-specific extensions
  std::vector<std::string> extensions;

#ifdef _WIN32
  extensions = {".exe", ".dll"};
#elif defined(__linux__)
  extensions = {".so"};
#elif defined(__APPLE__)
  extensions = {".dylib"};
#endif

  // try base extensions first
  for (const auto& ext : extensions) {
    module = module_index.find_by_name(module_name + ext);
    if (module) {
      log_.dbg(
          "module found with extension", redlog::field("requested", module_name), redlog::field("found", module->name)
      );
      return module;
    }
  }

  // for shared libraries, try to find versioned extensions by enumerating all modules
  if (!extensions.empty()) {
    std::string base_ext = extensions[0]; // .so or .dylib

    // enumerate all modules and find ones that start with our name + base extension
    module_index.visit_all([&](const w1::util::module_info& mod) {
      if (module) {
        return; // already found
      }

      std::string prefix = module_name + base_ext;
      if (mod.name.size() > prefix.size() && mod.name.substr(0, prefix.size()) == prefix) {

        // check if the remaining part looks like a version (starts with . followed by digits)
        std::string suffix = mod.name.substr(prefix.size());
        if (suffix.size() >= 2 && suffix[0] == '.' && std::isdigit(suffix[1])) {
          log_.dbg(
              "module found with versioned extension", redlog::field("requested", module_name),
              redlog::field("found", mod.name)
          );
          module = &mod;
        }
      }
    });
  }

  return module;
}

} // namespace w1::hooking
```

`src/w1tn3ss/hooking/hook_manager.hpp`:

```hpp
#pragma once

#include <QBDI.h>
#include <functional>
#include <memory>
#include <unordered_map>
#include <vector>
#include <string>
#include <redlog.hpp>

namespace w1::util {
class module_range_index;
struct module_info;
} // namespace w1::util

namespace w1::hooking {

// hook handler type - receives raw QBDI objects
using hook_handler = std::function<QBDI::VMAction(QBDI::VMInstanceRef, QBDI::GPRState*, QBDI::FPRState*, QBDI::rword)>;

class hook_manager {
public:
  explicit hook_manager(QBDI::VM* vm) : vm_(vm) {}
  ~hook_manager();

  // hook registration
  uint32_t hook_addr(QBDI::rword address, hook_handler handler);
  uint32_t hook_module(const std::string& module_name, QBDI::rword offset, hook_handler handler);
  uint32_t hook_range(QBDI::rword start, QBDI::rword end, hook_handler handler);

  // hook management
  bool remove_hook(uint32_t hook_id);
  void remove_all_hooks();

private:
  struct hook_info {
    uint32_t id;
    hook_handler handler;
    uint32_t qbdi_id = QBDI::INVALID_EVENTID;
    QBDI::rword address = 0;                            // for single address hooks
    std::pair<QBDI::rword, QBDI::rword> range = {0, 0}; // for range hooks
  };

  QBDI::VM* vm_;
  uint32_t next_hook_id_ = 1;
  std::unordered_map<uint32_t, hook_info> hooks_;
  redlog::logger log_{"w1.hook_manager"};

  // helper methods
  const w1::util::module_info* find_module_with_extensions(
      const w1::util::module_range_index& module_index, const std::string& module_name
  ) const;

  // QBDI callback wrapper
  static QBDI::VMAction hook_callback_wrapper(
      QBDI::VMInstanceRef vm, QBDI::GPRState* gpr, QBDI::FPRState* fpr, void* data
  );
};

} // namespace w1::hooking
```

`src/w1tn3ss/symbols/lief_symbol_backend.cpp`:

```cpp
#include "lief_symbol_backend.hpp"
#include "path_resolver.hpp"
#include <algorithm>
#include <cctype>
#include <sstream>
#include <iomanip>

#ifdef __APPLE__
// MachO constants from mach-o/nlist.h
#define N_STAB 0xe0 /* if any of these bits set, a symbolic debugging entry */
#define N_TYPE 0x0e /* mask for the type bits */
#define N_EXT 0x01  /* external symbol bit, set for external symbols */
#endif

namespace w1::symbols {

#ifdef WITNESS_LIEF_ENABLED

// lief_binary_cache implementation
lief_binary_cache::lief_binary_cache(size_t max_size)
    : max_size_(max_size), hits_(0), misses_(0), negative_hits_(0), log_("w1.lief_binary_cache") {}

lief_binary_cache::~lief_binary_cache() = default;

LIEF::Binary* lief_binary_cache::get_or_load(const std::string& path) const {
  std::shared_lock read_lock(mutex_);

  // check negative cache first (failed paths)
  if (failed_paths_.find(path) != failed_paths_.end()) {
    negative_hits_.fetch_add(1, std::memory_order_relaxed);
    log_.dbg("negative cache hit - path previously failed", redlog::field("path", path));
    return nullptr;
  }

  // check cache
  auto it = cache_.find(path);
  if (it != cache_.end()) {
    // found in cache - need write lock to update lru
    read_lock.unlock();
    std::unique_lock write_lock(mutex_);

    // double-check after acquiring write lock
    it = cache_.find(path);
    if (it != cache_.end()) {
      // move to front (most recently used)
      lru_list_.splice(lru_list_.begin(), lru_list_, it->second.first);
      hits_.fetch_add(1, std::memory_order_relaxed);
      log_.dbg("binary cache hit", redlog::field("path", path));
      return it->second.second.get();
    }
    // if not found after write lock, continue to load
    write_lock.unlock();
    read_lock.lock();
  }

  read_lock.unlock();
  std::unique_lock write_lock(mutex_);

  // double-check
  it = cache_.find(path);
  if (it != cache_.end()) {
    lru_list_.splice(lru_list_.begin(), lru_list_, it->second.first);
    hits_.fetch_add(1, std::memory_order_relaxed);
    log_.dbg("binary cache hit after write lock", redlog::field("path", path));
    return it->second.second.get();
  }

  misses_.fetch_add(1, std::memory_order_relaxed);
  log_.dbg(
      "binary cache miss - loading binary", redlog::field("path", path), redlog::field("cache_size", cache_.size())
  );

  // load binary
  try {
    log_.trc("attempting to load binary", redlog::field("path", path));

    log_.ped("calling LIEF::Parser::parse", redlog::field("path", path));
    auto binary = LIEF::Parser::parse(path);
    if (!binary) {
      log_.ped("LIEF::Parser::parse returned null", redlog::field("path", path));
      log_.trc("binary load failed", redlog::field("path", path));
      // add to negative cache
      failed_paths_.insert(path);
      return nullptr;
    } else {
      log_.trc("loaded binary from path", redlog::field("path", path));
    }

    // evict if needed
    if (cache_.size() >= max_size_) {
      auto last = lru_list_.back();
      cache_.erase(last);
      lru_list_.pop_back();
    }

    // add to cache
    lru_list_.push_front(path);
    auto* ptr = binary.get();
    cache_[path] = {lru_list_.begin(), std::move(binary)};

    log_.dbg("binary cached successfully", redlog::field("path", path), redlog::field("cache_size", cache_.size()));
    return ptr;

  } catch (const std::exception& e) {
    log_.err("failed to parse binary", redlog::field("path", path), redlog::field("error", e.what()));
    // add to negative cache
    failed_paths_.insert(path);
    return nullptr;
  }
}

void lief_binary_cache::clear() {
  std::unique_lock lock(mutex_);
  cache_.clear();
  lru_list_.clear();
  failed_paths_.clear();
  hits_ = 0;
  misses_ = 0;
  negative_hits_ = 0;
}

lief_binary_cache::cache_stats lief_binary_cache::get_stats() const {
  std::shared_lock lock(mutex_);
  size_t h = hits_.load();
  size_t m = misses_.load();
  size_t nh = negative_hits_.load();
  size_t total = h + m;

  return {cache_.size(), h + nh, m - nh, total > 0 ? double(h + nh) / double(total) : 0.0};
}

// lief_symbol_backend implementation
lief_symbol_backend::lief_symbol_backend(const config& cfg)
    : config_(cfg), binary_cache_(std::make_unique<lief_binary_cache>(cfg.max_cache_size)),
      log_("w1.lief_symbol_backend") {}

lief_symbol_backend::~lief_symbol_backend() = default;

bool lief_symbol_backend::is_available() const {
  return true; // lief is available if compiled with WITNESS_LIEF_ENABLED
}

lief_symbol_backend::capabilities lief_symbol_backend::get_capabilities() const {
  return {
      .supports_runtime_resolution = false, // file-based only
      .supports_file_resolution = true,
      .supports_pattern_matching = true,
      .supports_demangling = true
  };
}

void lief_symbol_backend::set_path_resolver(std::shared_ptr<path_resolver> resolver) { path_resolver_ = resolver; }

std::optional<symbol_info> lief_symbol_backend::resolve_address(uint64_t address) const {
  // lief backend requires module context, cannot resolve raw addresses
  log_.trc(
      "lief backend cannot resolve raw addresses without module context", redlog::field("address", "0x%016llx", address)
  );
  return std::nullopt;
}

std::optional<uint64_t> lief_symbol_backend::resolve_name(
    const std::string& name, const std::string& module_hint
) const {
  if (module_hint.empty()) {
    log_.trc("lief backend requires module hint for name resolution", redlog::field("name", name));
    return std::nullopt;
  }

  // resolve module path if needed
  std::string module_path = module_hint;
  if (path_resolver_) {
    if (auto resolved = path_resolver_->resolve_library_path(module_hint)) {
      module_path = *resolved;
    }
  }

  auto* binary = binary_cache_->get_or_load(module_path);
  if (!binary) {
    log_.trc("failed to load binary", redlog::field("module", module_path));
    return std::nullopt;
  }

  // platform-specific symbol lookup
  if (auto elf = dynamic_cast<LIEF::ELF::Binary*>(binary)) {
    return find_symbol_in_elf(elf, name);
  } else if (auto pe = dynamic_cast<LIEF::PE::Binary*>(binary)) {
    return find_symbol_in_pe(pe, name);
  } else if (auto macho = dynamic_cast<LIEF::MachO::Binary*>(binary)) {
    return find_symbol_in_macho(macho, name);
  } else if (auto fat = dynamic_cast<LIEF::MachO::FatBinary*>(binary)) {
    // handle fat binaries by using first architecture
    if (fat->size() > 0) {
      return find_symbol_in_macho(fat->at(0), name);
    }
  }

  return std::nullopt;
}

std::optional<symbol_info> lief_symbol_backend::resolve_in_module(
    const std::string& module_path, uint64_t offset
) const {
  log_.trc("resolve_in_module", redlog::field("module", module_path), redlog::field("offset", "0x%016llx", offset));

  auto* binary = binary_cache_->get_or_load(module_path);
  if (!binary) {
    log_.trc("failed to load binary", redlog::field("module", module_path));
    return std::nullopt;
  }

  log_.dbg("loaded binary, checking type", redlog::field("module", module_path));

  // platform-specific resolution
  if (auto elf = dynamic_cast<LIEF::ELF::Binary*>(binary)) {
    log_.trc("resolving ELF symbol", redlog::field("module", module_path));
    return resolve_elf_symbol(elf, offset);
  } else if (auto pe = dynamic_cast<LIEF::PE::Binary*>(binary)) {
    log_.trc("resolving PE symbol", redlog::field("module", module_path));
    return resolve_pe_symbol(pe, offset);
  } else if (auto macho = dynamic_cast<LIEF::MachO::Binary*>(binary)) {
    log_.dbg("resolving MachO symbol", redlog::field("module", module_path));
    return resolve_macho_symbol(macho, offset);
  } else if (auto fat = dynamic_cast<LIEF::MachO::FatBinary*>(binary)) {
    log_.trc("handling fat binary", redlog::field("module", module_path));
    // handle fat binaries by selecting the appropriate architecture
    // for now, just use the first one
    if (fat->size() > 0) {
      auto* binary = fat->at(0);
      return resolve_macho_symbol(binary, offset);
    }
  }

  return std::nullopt;
}

std::vector<symbol_info> lief_symbol_backend::find_symbols(
    const std::string& pattern, const std::string& module_hint
) const {
  if (module_hint.empty()) {
    log_.trc("lief backend requires module hint for symbol search", redlog::field("pattern", pattern));
    return {};
  }

  // resolve module path if needed
  std::string module_path = module_hint;
  if (path_resolver_) {
    if (auto resolved = path_resolver_->resolve_library_path(module_hint)) {
      module_path = *resolved;
    }
  }

  auto* binary = binary_cache_->get_or_load(module_path);
  if (!binary) {
    return {};
  }

  // platform-specific pattern search
  if (auto elf = dynamic_cast<LIEF::ELF::Binary*>(binary)) {
    return find_symbols_in_elf(elf, pattern);
  } else if (auto pe = dynamic_cast<LIEF::PE::Binary*>(binary)) {
    return find_symbols_in_pe(pe, pattern);
  } else if (auto macho = dynamic_cast<LIEF::MachO::Binary*>(binary)) {
    return find_symbols_in_macho(macho, pattern);
  } else if (auto fat = dynamic_cast<LIEF::MachO::FatBinary*>(binary)) {
    if (fat->size() > 0) {
      return find_symbols_in_macho(fat->at(0), pattern);
    }
  }

  return {};
}

std::vector<symbol_info> lief_symbol_backend::get_module_symbols(const std::string& module_path) const {
  auto* binary = binary_cache_->get_or_load(module_path);
  if (!binary) {
    return {};
  }

  std::vector<symbol_info> symbols;

  if (auto elf = dynamic_cast<LIEF::ELF::Binary*>(binary)) {
    // process dynamic symbols (most important for API calls)
    for (const auto& sym : elf->dynamic_symbols()) {
      if (!sym.name().empty()) {
        symbols.push_back(elf_symbol_to_info(sym));
      }
    }
    // also process static symbols if needed
    if (config_.resolve_imports) {
      for (const auto& sym : elf->symbols()) {
        if (!sym.name().empty()) {
          symbols.push_back(elf_symbol_to_info(sym));
        }
      }
    }
  } else if (auto pe = dynamic_cast<LIEF::PE::Binary*>(binary)) {
    // process exports
    if (pe->has_exports()) {
      for (const auto& exp : pe->get_export()->entries()) {
        symbols.push_back(pe_export_to_info(exp));
      }
    }
  } else if (auto macho = dynamic_cast<LIEF::MachO::Binary*>(binary)) {
    for (const auto& sym : macho->symbols()) {
      if (!sym.name().empty()) {
        symbols.push_back(macho_symbol_to_info(sym));
      }
    }
  }

  return symbols;
}

void lief_symbol_backend::clear_cache() { binary_cache_->clear(); }

// platform-specific symbol resolution
std::optional<symbol_info> lief_symbol_backend::resolve_elf_symbol(LIEF::ELF::Binary* elf, uint64_t offset) const {
  // try dynamic symbols first (more likely for API calls)
  for (const auto& sym : elf->dynamic_symbols()) {
    if (sym.value() <= offset && offset < sym.value() + sym.size() && !sym.name().empty()) {
      auto info = elf_symbol_to_info(sym);
      info.module_offset = offset;
      return info;
    }
  }

  // try static symbols
  for (const auto& sym : elf->symbols()) {
    if (sym.value() <= offset && offset < sym.value() + sym.size() && !sym.name().empty()) {
      auto info = elf_symbol_to_info(sym);
      info.module_offset = offset;
      return info;
    }
  }

  return std::nullopt;
}

std::optional<symbol_info> lief_symbol_backend::resolve_pe_symbol(LIEF::PE::Binary* pe, uint64_t offset) const {
  log_.ped("entering PE symbol resolution", redlog::field("offset", "0x%016llx", offset));

  // check exports for exact matches only
  if (pe->has_exports()) {
    log_.ped(
        "PE has exports, searching for exact symbol match at offset", redlog::field("offset", "0x%016llx", offset),
        redlog::field("export_count", pe->get_export()->entries().size())
    );

    for (const auto& exp : pe->get_export()->entries()) {
      // exact RVA match
      if (exp.address() == offset) {
        log_.ped(
            "found exact PE export match", redlog::field("name", exp.name()),
            redlog::field("rva", "0x%016llx", exp.address())
        );
        auto info = pe_export_to_info(exp);
        info.module_offset = offset;
        return info;
      }
    }
  }

  return std::nullopt;
}

std::optional<symbol_info> lief_symbol_backend::resolve_macho_symbol(
    LIEF::MachO::Binary* macho, uint64_t offset
) const {
  log_.dbg(
      "resolve_macho_symbol", redlog::field("offset", "0x%016llx", offset),
      redlog::field("symbol_count", macho->symbols().size())
  );

  // macho symbols don't have size information, so we can't do range checks
  // we need to find the closest symbol that starts before our offset
  const LIEF::MachO::Symbol* best_match = nullptr;
  uint64_t best_distance = UINT64_MAX;

  for (const auto& sym : macho->symbols()) {
    // skip undefined symbols
    if (sym.type() == LIEF::MachO::Symbol::TYPE::UNDEFINED) {
      continue;
    }

    uint64_t sym_addr = sym.value();

    if (sym_addr <= offset) {
      uint64_t distance = offset - sym_addr;
      if (distance < best_distance && !sym.name().empty()) {
        best_match = &sym;
        best_distance = distance;
      }
    }
  }

  if (best_match) {
    log_.dbg(
        "found closest MachO symbol", redlog::field("name", best_match->name()),
        redlog::field("offset_from_symbol", best_distance)
    );

    auto info = macho_symbol_to_info(*best_match);
    info.offset_from_symbol = best_distance; // store displacement from symbol start
    info.module_offset = offset;
    return info;
  }

  return std::nullopt;
}

// symbol name resolution
std::optional<uint64_t> lief_symbol_backend::find_symbol_in_elf(LIEF::ELF::Binary* elf, const std::string& name) const {
  // check dynamic symbols first
  for (const auto& sym : elf->dynamic_symbols()) {
    if (sym.name() == name) {
      return sym.value();
    }
  }

  // check static symbols
  for (const auto& sym : elf->symbols()) {
    if (sym.name() == name) {
      return sym.value();
    }
  }

  return std::nullopt;
}

std::optional<uint64_t> lief_symbol_backend::find_symbol_in_pe(LIEF::PE::Binary* pe, const std::string& name) const {
  if (pe->has_exports()) {
    for (const auto& exp : pe->get_export()->entries()) {
      if (exp.name() == name) {
        return exp.address(); // RVA
      }
    }
  }

  return std::nullopt;
}

std::optional<uint64_t> lief_symbol_backend::find_symbol_in_macho(
    LIEF::MachO::Binary* macho, const std::string& name
) const {
  for (const auto& sym : macho->symbols()) {
    if (sym.name() == name && sym.type() != LIEF::MachO::Symbol::TYPE::UNDEFINED) {
      return sym.value();
    }
  }

  return std::nullopt;
}

// pattern matching
bool lief_symbol_backend::matches_pattern(const std::string& name, const std::string& pattern) const {
  if (pattern.empty()) {
    return true; // empty pattern matches all
  }

  // simple wildcard matching
  std::string name_lower = name;
  std::string pattern_lower = pattern;
  std::transform(name_lower.begin(), name_lower.end(), name_lower.begin(), ::tolower);
  std::transform(pattern_lower.begin(), pattern_lower.end(), pattern_lower.begin(), ::tolower);

  if (pattern_lower.front() == '*' && pattern_lower.back() == '*') {
    // *substring*
    return name_lower.find(pattern_lower.substr(1, pattern_lower.length() - 2)) != std::string::npos;
  } else if (pattern_lower.back() == '*') {
    // prefix*
    return name_lower.find(pattern_lower.substr(0, pattern_lower.length() - 1)) == 0;
  } else if (pattern_lower.front() == '*') {
    // *suffix
    std::string suffix = pattern_lower.substr(1);
    return name_lower.length() >= suffix.length() &&
           name_lower.compare(name_lower.length() - suffix.length(), suffix.length(), suffix) == 0;
  } else {
    // exact match
    return name_lower == pattern_lower;
  }
}

std::vector<symbol_info> lief_symbol_backend::find_symbols_in_elf(
    LIEF::ELF::Binary* elf, const std::string& pattern
) const {
  std::vector<symbol_info> results;

  // check dynamic symbols
  for (const auto& sym : elf->dynamic_symbols()) {
    if (!sym.name().empty() && matches_pattern(sym.name(), pattern)) {
      results.push_back(elf_symbol_to_info(sym));
    }
  }

  // check static symbols if configured
  if (config_.resolve_imports) {
    for (const auto& sym : elf->symbols()) {
      if (!sym.name().empty() && matches_pattern(sym.name(), pattern)) {
        results.push_back(elf_symbol_to_info(sym));
      }
    }
  }

  return results;
}

std::vector<symbol_info> lief_symbol_backend::find_symbols_in_pe(
    LIEF::PE::Binary* pe, const std::string& pattern
) const {
  std::vector<symbol_info> results;

  if (pe->has_exports()) {
    for (const auto& exp : pe->get_export()->entries()) {
      if (matches_pattern(exp.name(), pattern)) {
        results.push_back(pe_export_to_info(exp));
      }
    }
  }

  return results;
}

std::vector<symbol_info> lief_symbol_backend::find_symbols_in_macho(
    LIEF::MachO::Binary* macho, const std::string& pattern
) const {
  std::vector<symbol_info> results;

  for (const auto& sym : macho->symbols()) {
    if (!sym.name().empty() && sym.type() != LIEF::MachO::Symbol::TYPE::UNDEFINED &&
        matches_pattern(sym.name(), pattern)) {
      results.push_back(macho_symbol_to_info(sym));
    }
  }

  return results;
}

// conversion helpers
symbol_info lief_symbol_backend::elf_symbol_to_info(const LIEF::ELF::Symbol& sym) const {
  symbol_info info;
  info.name = sym.name();
  info.demangled_name = sym.demangled_name();
  info.offset_from_symbol = 0; // will be calculated if needed
  info.module_offset = 0;      // will be set in resolve_in_module if needed
  info.size = sym.size();

  // map symbol type
  switch (sym.type()) {
  case LIEF::ELF::Symbol::TYPE::FUNC:
    info.symbol_type = symbol_info::FUNCTION;
    break;
  case LIEF::ELF::Symbol::TYPE::OBJECT:
    info.symbol_type = symbol_info::OBJECT;
    break;
  default:
    info.symbol_type = symbol_info::UNKNOWN;
  }

  // map binding
  switch (sym.binding()) {
  case LIEF::ELF::Symbol::BINDING::LOCAL:
    info.symbol_binding = symbol_info::LOCAL;
    break;
  case LIEF::ELF::Symbol::BINDING::GLOBAL:
    info.symbol_binding = symbol_info::GLOBAL;
    break;
  case LIEF::ELF::Symbol::BINDING::WEAK:
    info.symbol_binding = symbol_info::WEAK;
    break;
  default:
    info.symbol_binding = symbol_info::UNKNOWN_BINDING;
  }

  info.is_exported = sym.is_exported();
  info.is_imported = sym.is_imported();

  return info;
}

symbol_info lief_symbol_backend::pe_export_to_info(const LIEF::PE::ExportEntry& exp) const {
  symbol_info info;
  info.name = exp.name();
  info.demangled_name = exp.name(); // PE doesn't have demangling in LIEF
  info.offset_from_symbol = 0;
  info.module_offset = 0;                   // will be set in resolve_in_module if needed
  info.size = 0;                            // PE exports don't have size
  info.symbol_type = symbol_info::FUNCTION; // assume function for exports
  info.symbol_binding = symbol_info::GLOBAL;
  info.is_exported = true;
  info.is_imported = false;

  return info;
}

symbol_info lief_symbol_backend::macho_symbol_to_info(const LIEF::MachO::Symbol& sym) const {
  symbol_info info;
  info.name = sym.name();
  info.demangled_name = sym.demangled_name();
  info.offset_from_symbol = 0;
  info.module_offset = 0; // will be set in resolve_in_module if needed
  info.size = 0;          // macho symbols don't have size

  // determine type from macho type flags
  // n_stab (0xe0) and n_ext (0x01) are macho-specific constants
  // only use these on non-windows platforms where they're defined
#ifndef _WIN32
  if (sym.raw_type() & N_STAB) {
    info.symbol_type = symbol_info::DEBUG;
  } else
#endif
      if (sym.type() == LIEF::MachO::Symbol::TYPE::SECTION) {
    // could be function or data, default to function
    info.symbol_type = symbol_info::FUNCTION;
  } else {
    info.symbol_type = symbol_info::UNKNOWN;
  }

  // determine binding from external flag
#ifndef _WIN32
  if (sym.raw_type() & N_EXT) {
    info.symbol_binding = symbol_info::GLOBAL;
  } else {
    info.symbol_binding = symbol_info::LOCAL;
  }
#else
  // on windows, assume global binding for macho symbols
  info.symbol_binding = symbol_info::GLOBAL;
#endif

#ifndef _WIN32
  info.is_exported = (sym.raw_type() & N_EXT) != 0;
#else
  info.is_exported = true; // assume exported on windows
#endif
  info.is_imported = sym.type() == LIEF::MachO::Symbol::TYPE::UNDEFINED;

  return info;
}

#else // !WITNESS_LIEF_ENABLED

// stub implementations when LIEF is disabled
lief_symbol_backend::lief_symbol_backend(const config&) : log_("w1.lief_symbol_backend") {
  log_.warn("lief symbol backend created but LIEF is disabled");
}

lief_symbol_backend::~lief_symbol_backend() = default;

bool lief_symbol_backend::is_available() const { return false; }

lief_symbol_backend::capabilities lief_symbol_backend::get_capabilities() const { return {false, false, false, false}; }

void lief_symbol_backend::set_path_resolver(std::shared_ptr<path_resolver>) {}
std::optional<symbol_info> lief_symbol_backend::resolve_address(uint64_t) const { return std::nullopt; }
std::optional<uint64_t> lief_symbol_backend::resolve_name(const std::string&, const std::string&) const {
  return std::nullopt;
}
std::optional<symbol_info> lief_symbol_backend::resolve_in_module(const std::string&, uint64_t) const {
  return std::nullopt;
}
std::vector<symbol_info> lief_symbol_backend::find_symbols(const std::string&, const std::string&) const { return {}; }
std::vector<symbol_info> lief_symbol_backend::get_module_symbols(const std::string&) const { return {}; }
void lief_symbol_backend::clear_cache() {}

lief_binary_cache::lief_binary_cache(size_t)
    : max_size_(0), hits_(0), misses_(0), negative_hits_(0), log_("w1.lief_binary_cache") {}
lief_binary_cache::~lief_binary_cache() = default;
void lief_binary_cache::clear() {}
lief_binary_cache::cache_stats lief_binary_cache::get_stats() const { return {0, 0, 0, 0.0}; }

#endif // WITNESS_LIEF_ENABLED

} // namespace w1::symbols
```

`src/w1tn3ss/symbols/lief_symbol_backend.hpp`:

```hpp
#pragma once

#include "symbol_backend.hpp"
#include "symbol_info.hpp"
#include <atomic>
#include <list>
#include <memory>
#include <mutex>
#include <shared_mutex>
#include <redlog.hpp>
#include <unordered_map>
#include <unordered_set>

#ifdef WITNESS_LIEF_ENABLED
#include <LIEF/LIEF.hpp>
#endif

namespace w1::symbols {

class lief_binary_cache;
class path_resolver;

/**
 * @brief lief-based symbol resolution backend
 *
 * uses LIEF library to parse binary formats and resolve symbols.
 * supports ELF, PE, and MachO formats.
 */
class lief_symbol_backend : public symbol_backend {
public:
  struct config {
    size_t max_cache_size;
    bool prepopulate_exports;
    bool resolve_imports;

    config() : max_cache_size(50), prepopulate_exports(true), resolve_imports(true) {}
  };

  explicit lief_symbol_backend(const config& cfg = {});
  ~lief_symbol_backend();

  // symbol_backend interface
  std::optional<symbol_info> resolve_address(uint64_t address) const override;
  std::optional<uint64_t> resolve_name(const std::string& name, const std::string& module_hint = "") const override;
  std::optional<symbol_info> resolve_in_module(const std::string& module_path, uint64_t offset) const override;
  std::vector<symbol_info> find_symbols(const std::string& pattern, const std::string& module_hint = "") const override;
  std::vector<symbol_info> get_module_symbols(const std::string& module_path) const override;

  std::string get_name() const override { return "lief"; }
  bool is_available() const override;
  capabilities get_capabilities() const override;
  void clear_cache() override;

  // set path resolver for finding binaries
  void set_path_resolver(std::shared_ptr<path_resolver> resolver);

#ifdef WITNESS_LIEF_ENABLED
private:
  // platform-specific resolution
  std::optional<symbol_info> resolve_elf_symbol(LIEF::ELF::Binary* elf, uint64_t offset) const;
  std::optional<symbol_info> resolve_pe_symbol(LIEF::PE::Binary* pe, uint64_t offset) const;
  std::optional<symbol_info> resolve_macho_symbol(LIEF::MachO::Binary* macho, uint64_t offset) const;

  // symbol name resolution
  std::optional<uint64_t> find_symbol_in_elf(LIEF::ELF::Binary* elf, const std::string& name) const;
  std::optional<uint64_t> find_symbol_in_pe(LIEF::PE::Binary* pe, const std::string& name) const;
  std::optional<uint64_t> find_symbol_in_macho(LIEF::MachO::Binary* macho, const std::string& name) const;

  // pattern matching
  std::vector<symbol_info> find_symbols_in_elf(LIEF::ELF::Binary* elf, const std::string& pattern) const;
  std::vector<symbol_info> find_symbols_in_pe(LIEF::PE::Binary* pe, const std::string& pattern) const;
  std::vector<symbol_info> find_symbols_in_macho(LIEF::MachO::Binary* macho, const std::string& pattern) const;

  // conversion helpers
  symbol_info elf_symbol_to_info(const LIEF::ELF::Symbol& sym) const;
  symbol_info pe_export_to_info(const LIEF::PE::ExportEntry& exp) const;
  symbol_info macho_symbol_to_info(const LIEF::MachO::Symbol& sym) const;

  // pattern matching helper
  bool matches_pattern(const std::string& name, const std::string& pattern) const;
#endif

private:
  config config_;
  std::unique_ptr<lief_binary_cache> binary_cache_;
  std::shared_ptr<path_resolver> path_resolver_;
  redlog::logger log_;
};

/**
 * @brief lru cache for lief binaries
 */
class lief_binary_cache {
public:
  explicit lief_binary_cache(size_t max_size = 50);
  ~lief_binary_cache();

#ifdef WITNESS_LIEF_ENABLED
  LIEF::Binary* get_or_load(const std::string& path) const;
#endif

  void clear();

  struct cache_stats {
    size_t size;
    size_t hits;
    size_t misses;
    double hit_rate;
  };

  cache_stats get_stats() const;

private:
#ifdef WITNESS_LIEF_ENABLED
  mutable std::list<std::string> lru_list_;
  mutable std::unordered_map<std::string, std::pair<std::list<std::string>::iterator, std::unique_ptr<LIEF::Binary>>>
      cache_;
#endif
  mutable std::unordered_set<std::string> failed_paths_;
  mutable std::shared_mutex mutex_;
  size_t max_size_;
  mutable std::atomic<size_t> hits_;
  mutable std::atomic<size_t> misses_;
  mutable std::atomic<size_t> negative_hits_;
  redlog::logger log_;
};

} // namespace w1::symbols
```

`src/w1tn3ss/symbols/macos_dyld_resolver.cpp`:

```cpp
#ifdef __APPLE__

#include "macos_dyld_resolver.hpp"
#include <cstdlib>
#include <filesystem>
#include <algorithm>

namespace w1::symbols {

namespace fs = std::filesystem;

macos_dyld_resolver::macos_dyld_resolver() : log_("w1.macos_dyld_resolver") {

  // check for dyld shared cache dump directory
  const char* dump_dir_env = std::getenv("DYLD_SHARED_CACHE_DUMP_DIR");

  if (dump_dir_env && *dump_dir_env) {
    dump_dir_ = dump_dir_env;

    // normalize path - remove trailing slash
    if (!dump_dir_.empty() && dump_dir_.back() == '/') {
      dump_dir_.pop_back();
    }

    // verify directory exists
    if (fs::exists(dump_dir_) && fs::is_directory(dump_dir_)) {
      log_.trc("dyld shared cache dump directory configured", redlog::field("path", dump_dir_));
      // Pre-populate the library cache
      populate_library_cache();
    } else {
      log_.warn("dyld shared cache dump directory not found", redlog::field("path", dump_dir_));
      dump_dir_.clear();
    }
  } else {
    log_.dbg("DYLD_SHARED_CACHE_DUMP_DIR not set");
  }
}

std::optional<std::string> macos_dyld_resolver::resolve_extracted_path(const std::string& original_path) const {

  if (!is_available()) {
    return std::nullopt;
  }

  log_.trc("attempting to resolve dyld cached library", redlog::field("original_path", original_path));

  // check if this is a system library that would be in dyld cache
  if (!is_dyld_cached_library(original_path)) {
    log_.trc("not a dyld cached library", redlog::field("path", original_path));
    return std::nullopt;
  }

  // Extract library name and check pre-computed cache first
  std::string library_name = extract_library_name(original_path);
  {
    std::lock_guard<std::mutex> lock(cache_mutex_);
    auto it = library_cache_.find(library_name);
    if (it != library_cache_.end()) {
      log_.trc(
          "found library in pre-computed cache", redlog::field("original", original_path),
          redlog::field("resolved", it->second)
      );
      return it->second;
    }
  }

  // strategy 1: direct path mapping
  // /usr/lib/system/libsystem_c.dylib -> $DUMP_DIR/usr/lib/system/libsystem_c.dylib
  std::string direct_path = dump_dir_ + original_path;

  log_.trc("trying direct path mapping", redlog::field("mapped_path", direct_path));

  if (fs::exists(direct_path)) {
    log_.trc(
        "found library in dyld dump (direct mapping)", redlog::field("original", original_path),
        redlog::field("resolved", direct_path)
    );
    return direct_path;
  }

  // strategy 2: search for library name in dump
  log_.trc("direct mapping failed, searching for library", redlog::field("library_name", library_name));

  if (auto found_path = find_library_in_dump(library_name)) {
    log_.trc(
        "found library in dyld dump (recursive search)", redlog::field("original", original_path),
        redlog::field("resolved", *found_path), redlog::field("library_name", library_name)
    );
    // Cache the result
    {
      std::lock_guard<std::mutex> lock(cache_mutex_);
      library_cache_[library_name] = *found_path;
    }
    return found_path;
  }

  log_.trc(
      "library not found in dyld dump", redlog::field("original_path", original_path),
      redlog::field("library_name", library_name)
  );

  return std::nullopt;
}

bool macos_dyld_resolver::is_dyld_cached_library(const std::string& path) const {
  log_.trc("checking if path is dyld cached library", redlog::field("path", path));

  // common system library paths that are in dyld shared cache
  static const std::vector<std::string> cached_prefixes = {
      "/usr/lib/", "/System/Library/Frameworks/", "/System/Library/PrivateFrameworks/", "/System/iOSSupport/",
      "/Library/Apple/"
  };

  // also check common library names without full paths
  static const std::vector<std::string> cached_lib_patterns = {"libsystem_",  "libc++",         "libobjc",
                                                               "libdispatch", "libdyld",        "libxpc",
                                                               "Foundation",  "CoreFoundation", "CoreServices"};

  // normalize the path
  std::string norm_path = normalize_path(path);

  // extract just the filename if it's a full path
  std::string filename = extract_library_name(path);

  log_.trc(
      "normalized path and extracted filename", redlog::field("norm_path", norm_path),
      redlog::field("filename", filename)
  );

  // check if path starts with any cached prefix
  for (const auto& prefix : cached_prefixes) {
    if (norm_path.find(prefix) == 0) {
      log_.trc("matched cached prefix", redlog::field("prefix", prefix), redlog::field("path", path));
      return true;
    }
  }

  // check if filename matches common cached library patterns
  for (const auto& pattern : cached_lib_patterns) {
    if (filename.find(pattern) == 0) {
      log_.trc(
          "matched cached library pattern", redlog::field("pattern", pattern), redlog::field("filename", filename)
      );
      return true;
    }
  }

  log_.trc("not a dyld cached library", redlog::field("path", path));
  return false;
}

std::optional<std::string> macos_dyld_resolver::find_library_in_dump(const std::string& library_name) const {

  log_.trc(
      "searching for library in dump", redlog::field("library_name", library_name), redlog::field("dump_dir", dump_dir_)
  );

  if (library_name.empty()) {
    log_.trc("library name is empty, returning nullopt");
    return std::nullopt;
  }

  try {
    // common subdirectories where libraries are typically found
    static const std::vector<std::string> search_subdirs = {
        "/usr/lib", "/usr/lib/system", "/System/Library/Frameworks", "/System/Library/PrivateFrameworks"
    };

    // first search in common locations
    for (const auto& subdir : search_subdirs) {
      std::string search_path = dump_dir_ + subdir;

      if (!fs::exists(search_path)) {
        log_.trc("search path does not exist", redlog::field("search_path", search_path));
        continue;
      }

      log_.trc("searching in directory", redlog::field("path", search_path), redlog::field("library", library_name));

      // look for exact match and versioned variants
      for (const auto& entry : fs::directory_iterator(search_path)) {
        if (!entry.is_regular_file() && !entry.is_symlink()) {
          continue;
        }

        std::string filename = entry.path().filename().string();

        // exact match
        if (filename == library_name) {
          log_.trc(
              "found exact library match", redlog::field("library", library_name),
              redlog::field("path", entry.path().string())
          );
          return entry.path().string();
        }

        // handle versioned libraries (e.g., libsystem_c.dylib vs libsystem_c.1.dylib)
        std::string base_name = library_name;
        size_t dot_pos = base_name.rfind(".dylib");
        if (dot_pos != std::string::npos) {
          base_name = base_name.substr(0, dot_pos);

          // check if filename starts with base_name and ends with .dylib
          if (filename.find(base_name) == 0 && filename.rfind(".dylib") == filename.length() - 6) {

            log_.trc(
                "found versioned match", redlog::field("requested", library_name), redlog::field("found", filename)
            );
            return entry.path().string();
          }
        }
      }
    }

    // if not found in common locations, do recursive search as last resort
    log_.trc("library not found in common locations, trying recursive search", redlog::field("library", library_name));

    // limit recursion depth to avoid excessive searching
    constexpr int max_depth = 5;

    std::function<std::optional<std::string>(const fs::path&, int)> search_recursive;
    search_recursive = [&](const fs::path& dir, int depth) -> std::optional<std::string> {
      if (depth > max_depth) {
        return std::nullopt;
      }

      for (const auto& entry : fs::directory_iterator(dir)) {
        if (entry.is_directory()) {
          if (auto result = search_recursive(entry.path(), depth + 1)) {
            return result;
          }
        } else if (entry.is_regular_file() || entry.is_symlink()) {
          std::string filename = entry.path().filename().string();
          if (filename == library_name) {
            return entry.path().string();
          }
        }
      }

      return std::nullopt;
    };

    return search_recursive(dump_dir_, 0);

  } catch (const fs::filesystem_error& e) {
    log_.err(
        "filesystem error while searching for library", redlog::field("library", library_name),
        redlog::field("error", e.what())
    );
    return std::nullopt;
  } catch (const std::exception& e) {
    log_.err(
        "unexpected error while searching for library", redlog::field("library", library_name),
        redlog::field("error", e.what())
    );
    return std::nullopt;
  }
}

std::string macos_dyld_resolver::extract_library_name(const std::string& path) const {
  // extract just the filename from the path
  size_t last_slash = path.rfind('/');
  if (last_slash != std::string::npos) {
    return path.substr(last_slash + 1);
  }
  return path;
}

std::string macos_dyld_resolver::normalize_path(const std::string& path) const {
  // remove any redundant slashes and resolve symlinks if needed
  try {
    // for now, just ensure single slashes
    std::string result;
    result.reserve(path.size());

    bool last_was_slash = false;
    for (char c : path) {
      if (c == '/') {
        if (!last_was_slash) {
          result += c;
        }
        last_was_slash = true;
      } else {
        result += c;
        last_was_slash = false;
      }
    }

    return result;
  } catch (...) {
    return path;
  }
}

void macos_dyld_resolver::populate_library_cache() {
  log_.trc("pre-populating dyld library cache", redlog::field("dump_dir", dump_dir_));

  std::lock_guard<std::mutex> lock(cache_mutex_);
  library_cache_.clear();

  // Common subdirectories where libraries are typically found
  static const std::vector<std::string> search_subdirs = {
      "/usr/lib", "/usr/lib/system", "/System/Library/Frameworks", "/System/Library/PrivateFrameworks"
  };

  size_t total_libraries = 0;

  try {
    for (const auto& subdir : search_subdirs) {
      std::string search_path = dump_dir_ + subdir;

      if (!fs::exists(search_path)) {
        continue;
      }

      for (const auto& entry : fs::directory_iterator(search_path)) {
        if (!entry.is_regular_file() && !entry.is_symlink()) {
          continue;
        }

        std::string filename = entry.path().filename().string();
        if (filename.find(".dylib") != std::string::npos || filename.find(".framework") != std::string::npos) {
          library_cache_[filename] = entry.path().string();
          total_libraries++;
        }
      }
    }
  } catch (const fs::filesystem_error& e) {
    log_.err("filesystem error while populating cache", redlog::field("error", e.what()));
  }

  log_.trc("dyld library cache populated", redlog::field("total_libraries", total_libraries));
}

std::optional<std::string> macos_dyld_resolver::resolve_library_path(const std::string& library_name) const {
  return resolve_extracted_path(library_name);
}

std::vector<std::string> macos_dyld_resolver::get_system_directories() const {
  std::vector<std::string> dirs;
  if (!dump_dir_.empty()) {
    dirs.push_back(dump_dir_);
  }
  return dirs;
}

bool macos_dyld_resolver::is_system_library(const std::string& path) const { return is_dyld_cached_library(path); }

} // namespace w1::symbols

#endif // __APPLE__
```

`src/w1tn3ss/symbols/macos_dyld_resolver.hpp`:

```hpp
#pragma once

#ifdef __APPLE__

#include "path_resolver.hpp"
#include <string>
#include <optional>
#include <vector>
#include <unordered_map>
#include <mutex>
#include <redlog.hpp>

namespace w1::symbols {

// resolves system library paths to extracted dyld shared cache dump paths
class macos_dyld_resolver : public path_resolver {
public:
  macos_dyld_resolver();

  // path_resolver interface
  std::optional<std::string> resolve_library_path(const std::string& library_name) const override;
  std::vector<std::string> get_system_directories() const override;
  bool is_system_library(const std::string& path) const override;
  std::string get_name() const override { return "macos_dyld"; }

  // resolve system library path to extracted dyld dump path
  // returns empty optional if resolution fails or not applicable
  std::optional<std::string> resolve_extracted_path(const std::string& original_path) const;

  // check if dyld dump is available
  bool is_available() const { return !dump_dir_.empty(); }

  // get the configured dump directory
  const std::string& get_dump_dir() const { return dump_dir_; }

private:
  std::string dump_dir_;
  mutable redlog::logger log_;

  // Pre-computed cache of library name to dump path mappings
  mutable std::unordered_map<std::string, std::string> library_cache_;
  mutable std::mutex cache_mutex_;

  // check if path is a system library that would be in dyld cache
  bool is_dyld_cached_library(const std::string& path) const;

  // helper to search for library in dump
  std::optional<std::string> find_library_in_dump(const std::string& library_name) const;

  // extract library name from full path
  std::string extract_library_name(const std::string& path) const;

  // normalize path for consistent matching
  std::string normalize_path(const std::string& path) const;

  // pre-populate library cache
  void populate_library_cache();
};

} // namespace w1::symbols

#endif // __APPLE__
```

`src/w1tn3ss/symbols/path_resolver.hpp`:

```hpp
#pragma once

#include <optional>
#include <string>
#include <vector>

namespace w1::symbols {

/**
 * @brief abstract interface for platform-specific path resolution
 *
 * resolves library names to full paths on the filesystem.
 * handles system libraries, dyld cache, and other platform quirks.
 */
class path_resolver {
public:
  virtual ~path_resolver() = default;

  /**
   * @brief resolve library name to full path
   * @param library_name name or partial path (e.g. "kernel32.dll", "libc.so.6")
   * @return full path if found
   */
  virtual std::optional<std::string> resolve_library_path(const std::string& library_name) const = 0;

  /**
   * @brief get system library directories
   * @return list of directories where system libraries are located
   */
  virtual std::vector<std::string> get_system_directories() const = 0;

  /**
   * @brief check if path is likely a system library
   * @param path library path or name
   * @return true if this appears to be a system library
   */
  virtual bool is_system_library(const std::string& path) const = 0;

  /**
   * @brief get resolver name for debugging
   * @return resolver identifier (e.g. "windows_path", "macos_dyld", "linux_ldso")
   */
  virtual std::string get_name() const = 0;
};

} // namespace w1::symbols
```

`src/w1tn3ss/symbols/posix_symbol_backend.cpp`:

```cpp
#if !defined(_WIN32)

#include "posix_symbol_backend.hpp"
#include <dlfcn.h>
#include <cstring>
#include <filesystem>

namespace w1::symbols {

namespace fs = std::filesystem;

posix_symbol_backend::posix_symbol_backend() : log_("w1.posix_symbol_backend") {
  log_.dbg("initialized posix symbol backend");
}

posix_symbol_backend::~posix_symbol_backend() {
  // close all cached handles
  std::lock_guard<std::mutex> lock(cache_mutex_);
  for (auto& [path, handle] : handle_cache_) {
    if (handle && handle != RTLD_DEFAULT && handle != RTLD_NEXT) {
      dlclose(handle);
    }
  }
}

posix_symbol_backend::capabilities posix_symbol_backend::get_capabilities() const {
  return {
      .supports_runtime_resolution = true,
      .supports_file_resolution = true,   // can dlopen files
      .supports_pattern_matching = false, // no native pattern support
      .supports_demangling = false        // dladdr doesn't demangle
  };
}

std::optional<symbol_info> posix_symbol_backend::resolve_address(uint64_t address) const {
  Dl_info info;
  memset(&info, 0, sizeof(info));

  if (dladdr(reinterpret_cast<void*>(address), &info) == 0) {
    log_.trc("dladdr failed for address", redlog::field("address", "0x%016llx", address));
    return std::nullopt;
  }

  log_.dbg(
      "dladdr success", redlog::field("address", "0x%016llx", address),
      redlog::field("symbol", info.dli_sname ? info.dli_sname : "<null>"),
      redlog::field("module", info.dli_fname ? info.dli_fname : "<null>")
  );

  return dladdr_to_symbol_info(&info, address);
}

std::optional<uint64_t> posix_symbol_backend::resolve_name(
    const std::string& name, const std::string& module_hint
) const {
  void* handle = RTLD_DEFAULT;

  if (!module_hint.empty()) {
    handle = open_module(module_hint);
    if (!handle) {
      log_.trc(
          "failed to open module for symbol lookup", redlog::field("module", module_hint), redlog::field("name", name)
      );
      return std::nullopt;
    }
  }

  // look up symbol
  void* sym_addr = dlsym(handle, name.c_str());
  if (!sym_addr) {
    const char* error = dlerror();
    log_.trc("dlsym failed", redlog::field("name", name), redlog::field("error", error ? error : "<null>"));
    return std::nullopt;
  }

  uint64_t address = reinterpret_cast<uint64_t>(sym_addr);
  log_.dbg("resolved symbol by name", redlog::field("name", name), redlog::field("address", "0x%016llx", address));

  return address;
}

std::optional<symbol_info> posix_symbol_backend::resolve_in_module(
    const std::string& module_path, uint64_t offset
) const {
  // for posix, we need the absolute address, not just offset
  // try to get module base address
  void* handle = open_module(module_path);
  if (!handle) {
    log_.trc("failed to open module", redlog::field("module", module_path));
    return std::nullopt;
  }

  // there's no portable way to get module base address from dlopen handle
  // so we use a workaround: look up a known symbol and use dladdr

  // try to find any exported symbol to get module info
  Dl_info module_info;
  memset(&module_info, 0, sizeof(module_info));

  // on linux, we can try to look up the module's init function
  void* init_addr = dlsym(handle, "_init");
  if (init_addr && dladdr(init_addr, &module_info) != 0) {
    // calculate absolute address
    uint64_t base = reinterpret_cast<uint64_t>(module_info.dli_fbase);
    uint64_t absolute_addr = base + offset;

    log_.trc(
        "calculated absolute address from module base", redlog::field("module", module_path),
        redlog::field("base", "0x%016llx", base), redlog::field("offset", "0x%016llx", offset),
        redlog::field("absolute", "0x%016llx", absolute_addr)
    );

    return resolve_address(absolute_addr);
  }

  log_.trc("could not determine module base address", redlog::field("module", module_path));
  return std::nullopt;
}

std::vector<symbol_info> posix_symbol_backend::find_symbols(
    const std::string& pattern, const std::string& module_hint
) const {
  // posix APIs don't support symbol enumeration or pattern matching
  log_.trc("posix backend does not support pattern-based symbol search", redlog::field("pattern", pattern));
  return {};
}

std::vector<symbol_info> posix_symbol_backend::get_module_symbols(const std::string& module_path) const {
  // posix APIs don't support symbol enumeration
  log_.trc("posix backend does not support module symbol enumeration", redlog::field("module", module_path));
  return {};
}

void posix_symbol_backend::clear_cache() {
  std::lock_guard<std::mutex> lock(cache_mutex_);

  // close all handles except special ones
  for (auto& [path, handle] : handle_cache_) {
    if (handle && handle != RTLD_DEFAULT && handle != RTLD_NEXT) {
      dlclose(handle);
    }
  }

  handle_cache_.clear();
  log_.dbg("posix symbol backend cache cleared");
}

void* posix_symbol_backend::open_module(const std::string& module_path) const {
  // check cache first
  {
    std::lock_guard<std::mutex> lock(cache_mutex_);
    auto it = handle_cache_.find(module_path);
    if (it != handle_cache_.end()) {
      return it->second;
    }
  }

  // try to open the module
  void* handle = nullptr;

  // if it's a full path, use it directly
  if (module_path.find('/') != std::string::npos) {
    handle = dlopen(module_path.c_str(), RTLD_LAZY | RTLD_LOCAL);
  } else {
    // it's just a name, let dlopen search for it
    handle = dlopen(module_path.c_str(), RTLD_LAZY | RTLD_LOCAL);
  }

  if (!handle) {
    const char* error = dlerror();
    log_.trc("dlopen failed", redlog::field("module", module_path), redlog::field("error", error ? error : "<null>"));
    return nullptr;
  }

  // cache the handle
  {
    std::lock_guard<std::mutex> lock(cache_mutex_);
    handle_cache_[module_path] = handle;
  }

  return handle;
}

symbol_info posix_symbol_backend::dladdr_to_symbol_info(const void* addr_info, uint64_t query_address) const {
  const Dl_info* info = static_cast<const Dl_info*>(addr_info);
  symbol_info sym;

  // symbol name
  if (info->dli_sname) {
    sym.name = info->dli_sname;
    sym.demangled_name = info->dli_sname; // dladdr doesn't demangle
  } else {
    // no symbol name, generate one
    sym.name = "sub_" + std::to_string(query_address);
    sym.demangled_name = sym.name;
  }

  // module name
  if (info->dli_fname) {
    // extract just the filename
    std::string full_path = info->dli_fname;
    size_t last_slash = full_path.find_last_of('/');
    if (last_slash != std::string::npos) {
      sym.section = full_path.substr(last_slash + 1);
    } else {
      sym.section = full_path;
    }
  }

  // calculate offset from symbol start
  if (info->dli_saddr) {
    uint64_t sym_addr = reinterpret_cast<uint64_t>(info->dli_saddr);
    sym.offset_from_symbol = query_address - sym_addr;
  } else {
    sym.offset_from_symbol = 0;
  }

  // posix backend doesn't have module offset info from dladdr
  sym.module_offset = 0;

  // dladdr doesn't provide size information
  sym.size = 0;

  // assume function type for resolved symbols
  sym.symbol_type = symbol_info::FUNCTION;
  sym.symbol_binding = symbol_info::GLOBAL;

  // dladdr only resolves exported symbols
  sym.is_exported = true;
  sym.is_imported = false;

  return sym;
}

} // namespace w1::symbols

#endif // !_WIN32
```

`src/w1tn3ss/symbols/posix_symbol_backend.hpp`:

```hpp
#pragma once

#if !defined(_WIN32)

#include "symbol_backend.hpp"
#include "symbol_info.hpp"
#include <redlog.hpp>
#include <mutex>
#include <unordered_map>

namespace w1::symbols {

/**
 * @brief posix native symbol resolution using dladdr/dlsym
 *
 * provides runtime symbol resolution for unix-like systems
 * (linux, macos, bsd, etc.) using standard posix APIs.
 */
class posix_symbol_backend : public symbol_backend {
public:
  posix_symbol_backend();
  ~posix_symbol_backend();

  // symbol_backend interface
  std::optional<symbol_info> resolve_address(uint64_t address) const override;
  std::optional<uint64_t> resolve_name(const std::string& name, const std::string& module_hint = "") const override;
  std::optional<symbol_info> resolve_in_module(const std::string& module_path, uint64_t offset) const override;
  std::vector<symbol_info> find_symbols(const std::string& pattern, const std::string& module_hint = "") const override;
  std::vector<symbol_info> get_module_symbols(const std::string& module_path) const override;

  std::string get_name() const override { return "posix_native"; }
  bool is_available() const override { return true; }
  capabilities get_capabilities() const override;
  void clear_cache() override;

private:
  // helper to open a module handle
  void* open_module(const std::string& module_path) const;

  // helper to convert dladdr info to symbol_info
  symbol_info dladdr_to_symbol_info(const void* addr_info, uint64_t query_address) const;

  // cache for module handles
  mutable std::mutex cache_mutex_;
  mutable std::unordered_map<std::string, void*> handle_cache_;

  // logging
  redlog::logger log_;
};

} // namespace w1::symbols

#endif // !_WIN32
```

`src/w1tn3ss/symbols/symbol_backend.hpp`:

```hpp
#pragma once

#include "symbol_info.hpp"
#include <optional>
#include <string>
#include <vector>
#include <cstdint>

namespace w1::symbols {

/**
 * @brief abstract interface for symbol resolution backends
 *
 * defines the contract that all symbol resolution implementations must follow.
 * backends can use native APIs, LIEF, or other methods to resolve symbols.
 */
class symbol_backend {
public:
  virtual ~symbol_backend() = default;

  // core resolution methods

  /**
   * @brief resolve symbol at absolute address
   * @param address absolute memory address
   * @return symbol information if found
   */
  virtual std::optional<symbol_info> resolve_address(uint64_t address) const = 0;

  /**
   * @brief resolve symbol address by name
   * @param name symbol name to look up
   * @param module_hint optional module to search in (empty = search all)
   * @return absolute address if found
   */
  virtual std::optional<uint64_t> resolve_name(const std::string& name, const std::string& module_hint = "") const = 0;

  /**
   * @brief resolve symbol in specific module at offset
   * @param module_path path to module
   * @param offset offset within module
   * @return symbol information if found
   */
  virtual std::optional<symbol_info> resolve_in_module(const std::string& module_path, uint64_t offset) const = 0;

  /**
   * @brief find symbols matching pattern
   * @param pattern wildcard pattern (e.g. "malloc*", "*printf")
   * @param module_hint optional module to search in
   * @return matching symbols
   */
  virtual std::vector<symbol_info> find_symbols(
      const std::string& pattern, const std::string& module_hint = ""
  ) const = 0;

  /**
   * @brief get all symbols from a module
   * @param module_path path to module
   * @return all symbols in module
   */
  virtual std::vector<symbol_info> get_module_symbols(const std::string& module_path) const = 0;

  // backend information

  /**
   * @brief get backend name for debugging
   * @return backend identifier (e.g. "windows_native", "lief", "posix_native")
   */
  virtual std::string get_name() const = 0;

  /**
   * @brief check if backend is available on current platform
   * @return true if backend can be used
   */
  virtual bool is_available() const = 0;

  /**
   * @brief get capabilities of this backend
   */
  struct capabilities {
    bool supports_runtime_resolution; // can resolve from running process
    bool supports_file_resolution;    // can resolve from file on disk
    bool supports_pattern_matching;   // supports wildcard patterns
    bool supports_demangling;         // can demangle C++ names
  };

  virtual capabilities get_capabilities() const = 0;

  // cache management

  /**
   * @brief clear any internal caches
   */
  virtual void clear_cache() = 0;
};

} // namespace w1::symbols
```

`src/w1tn3ss/symbols/symbol_info.hpp`:

```hpp
#pragma once

#include <string>
#include <cstdint>

namespace w1::symbols {

// cross-platform symbol information structure
struct symbol_info {
  std::string name;
  std::string demangled_name;
  uint64_t offset_from_symbol; // offset from symbol start (0 = at symbol start)
  uint64_t module_offset;      // offset within module (optional, 0 if not available)
  uint64_t size;               // symbol size

  enum type { FUNCTION, OBJECT, DEBUG, UNKNOWN } symbol_type = UNKNOWN;
  enum binding { LOCAL, GLOBAL, WEAK, UNKNOWN_BINDING } symbol_binding = UNKNOWN_BINDING;

  std::string version; // symbol version (Linux)
  std::string section; // section name

  bool is_exported;
  bool is_imported;
};

} // namespace w1::symbols
```

`src/w1tn3ss/symbols/symbol_resolver.cpp`:

```cpp
#include "symbol_resolver.hpp"
#include "lief_symbol_backend.hpp"
#include "path_resolver.hpp"
#include <redlog.hpp>
#include <memory>
#include <vector>

#ifdef _WIN32
#include "windows_symbol_backend.hpp"
#include "windows_path_resolver.hpp"
#else
#include "posix_symbol_backend.hpp"
#ifdef __APPLE__
#include "macos_dyld_resolver.hpp"
#endif
#endif

namespace w1::symbols {

// implementation class to hide backend details
class symbol_resolver::impl {
public:
  explicit impl(const config& cfg);

  // delegated methods
  std::optional<symbol_info> resolve_address(uint64_t address, const util::module_range_index& module_index) const;
  std::vector<std::optional<symbol_info>> resolve_addresses(
      const std::vector<uint64_t>& addresses, const util::module_range_index& module_index
  ) const;
  std::optional<uint64_t> resolve_name(const std::string& name, const std::string& module_hint) const;
  std::vector<symbol_info> find_symbols(const std::string& pattern, const std::string& module_hint) const;
  std::optional<symbol_info> resolve_in_module(const std::string& module_path, uint64_t offset) const;
  std::vector<symbol_info> get_module_symbols(const std::string& module_path) const;
  void clear_cache();
  symbol_resolver::cache_stats get_cache_stats() const;
  std::string get_backend_name() const;
  std::vector<std::string> get_available_backends() const;

private:
  config config_;
  std::shared_ptr<symbol_backend> primary_backend_;
  std::shared_ptr<symbol_backend> fallback_backend_;
  std::shared_ptr<path_resolver> path_resolver_;
  redlog::logger log_;

  // cache statistics
  mutable size_t cache_hits_ = 0;
  mutable size_t cache_misses_ = 0;

  // setup backends based on platform and config
  void setup_backends();
};

// public interface implementation
symbol_resolver::symbol_resolver(const config& cfg) : pimpl_(std::make_unique<impl>(cfg)) {}

symbol_resolver::~symbol_resolver() = default;

std::optional<symbol_info> symbol_resolver::resolve_address(
    uint64_t address, const util::module_range_index& module_index
) const {
  return pimpl_->resolve_address(address, module_index);
}

std::vector<std::optional<symbol_info>> symbol_resolver::resolve_addresses(
    const std::vector<uint64_t>& addresses, const util::module_range_index& module_index
) const {
  return pimpl_->resolve_addresses(addresses, module_index);
}

std::optional<uint64_t> symbol_resolver::resolve_name(const std::string& name, const std::string& module_hint) const {
  return pimpl_->resolve_name(name, module_hint);
}

std::vector<symbol_info> symbol_resolver::find_symbols(
    const std::string& pattern, const std::string& module_hint
) const {
  return pimpl_->find_symbols(pattern, module_hint);
}

std::optional<symbol_info> symbol_resolver::resolve_in_module(const std::string& module_path, uint64_t offset) const {
  return pimpl_->resolve_in_module(module_path, offset);
}

std::vector<symbol_info> symbol_resolver::get_module_symbols(const std::string& module_path) const {
  return pimpl_->get_module_symbols(module_path);
}

void symbol_resolver::clear_cache() { pimpl_->clear_cache(); }

symbol_resolver::cache_stats symbol_resolver::get_cache_stats() const { return pimpl_->get_cache_stats(); }

std::string symbol_resolver::get_backend_name() const { return pimpl_->get_backend_name(); }

std::vector<std::string> symbol_resolver::get_available_backends() const { return pimpl_->get_available_backends(); }

// implementation class methods
symbol_resolver::impl::impl(const config& cfg) : config_(cfg), log_("w1.symbol_resolver") {
  setup_backends();

  log_.inf(
      "initialized symbol resolver",
      redlog::field("primary_backend", primary_backend_ ? primary_backend_->get_name() : "none"),
      redlog::field("fallback_backend", fallback_backend_ ? fallback_backend_->get_name() : "none")
  );
}

void symbol_resolver::impl::setup_backends() {
  // create path resolver
#ifdef _WIN32
  path_resolver_ = std::make_shared<windows_path_resolver>();
#elif defined(__APPLE__)
  path_resolver_ = std::make_shared<macos_dyld_resolver>();
#endif

  // create primary backend based on platform
#ifdef _WIN32
  if (config_.use_native_backend) {
    primary_backend_ = std::make_shared<windows_symbol_backend>();
  }
#else
  if (config_.use_native_backend) {
    primary_backend_ = std::make_shared<posix_symbol_backend>();
  }
#endif

  // create lief backend as fallback if enabled
#ifdef WITNESS_LIEF_ENABLED
  if (config_.use_lief_backend) {
    lief_symbol_backend::config lief_cfg;
    lief_cfg.max_cache_size = config_.max_cache_size;
    lief_cfg.prepopulate_exports = config_.prepopulate_exports;
    lief_cfg.resolve_imports = config_.resolve_imports;
    auto lief_backend = std::make_shared<lief_symbol_backend>(lief_cfg);

    // set path resolver for lief backend
    if (path_resolver_) {
      lief_backend->set_path_resolver(path_resolver_);
    }

    if (!primary_backend_) {
      primary_backend_ = lief_backend;
    } else {
      fallback_backend_ = lief_backend;
    }
  }
#endif

  if (!primary_backend_) {
    log_.err("no symbol backend available");
  }
}

std::optional<symbol_info> symbol_resolver::impl::resolve_address(
    uint64_t address, const util::module_range_index& module_index
) const {

  if (!primary_backend_) {
    return std::nullopt;
  }

  // for native backends, try direct resolution first
  if (auto result = primary_backend_->resolve_address(address)) {
    cache_hits_++;
    return result;
  }

  // for file-based backends (like lief), we need module context
  if (auto module = module_index.find_containing(address)) {
    uint64_t offset = address - module->base_address;

    // resolve module path if needed
    std::string module_path = module->path;
    if (path_resolver_) {
      if (auto resolved = path_resolver_->resolve_library_path(module->path)) {
        module_path = *resolved;
      }
    }

    if (auto result = primary_backend_->resolve_in_module(module_path, offset)) {
      cache_hits_++;
      return result;
    }

    // try fallback backend
    if (fallback_backend_) {
      if (auto result = fallback_backend_->resolve_in_module(module_path, offset)) {
        cache_hits_++;
        return result;
      }
    }
  }

  cache_misses_++;
  return std::nullopt;
}

std::vector<std::optional<symbol_info>> symbol_resolver::impl::resolve_addresses(
    const std::vector<uint64_t>& addresses, const util::module_range_index& module_index
) const {

  std::vector<std::optional<symbol_info>> results;
  results.reserve(addresses.size());

  for (uint64_t addr : addresses) {
    results.push_back(resolve_address(addr, module_index));
  }

  return results;
}

std::optional<uint64_t> symbol_resolver::impl::resolve_name(
    const std::string& name, const std::string& module_hint
) const {
  if (!primary_backend_) {
    return std::nullopt;
  }

  // try primary backend
  if (auto result = primary_backend_->resolve_name(name, module_hint)) {
    return result;
  }

  // try fallback backend
  if (fallback_backend_) {
    return fallback_backend_->resolve_name(name, module_hint);
  }

  return std::nullopt;
}

std::vector<symbol_info> symbol_resolver::impl::find_symbols(
    const std::string& pattern, const std::string& module_hint
) const {
  std::vector<symbol_info> results;

  if (!primary_backend_) {
    return results;
  }

  // get results from primary backend
  auto primary_results = primary_backend_->find_symbols(pattern, module_hint);
  results.insert(results.end(), primary_results.begin(), primary_results.end());

  // add results from fallback backend if available
  if (fallback_backend_) {
    auto fallback_results = fallback_backend_->find_symbols(pattern, module_hint);

    // deduplicate based on symbol name
    for (const auto& sym : fallback_results) {
      bool found = false;
      for (const auto& existing : results) {
        if (existing.name == sym.name) {
          found = true;
          break;
        }
      }
      if (!found) {
        results.push_back(sym);
      }
    }
  }

  return results;
}

std::optional<symbol_info> symbol_resolver::impl::resolve_in_module(
    const std::string& module_path, uint64_t offset
) const {
  if (!primary_backend_) {
    return std::nullopt;
  }

  // resolve module path if needed
  std::string resolved_path = module_path;
  if (path_resolver_) {
    if (auto resolved = path_resolver_->resolve_library_path(module_path)) {
      resolved_path = *resolved;
    }
  }

  // try primary backend
  if (auto result = primary_backend_->resolve_in_module(resolved_path, offset)) {
    return result;
  }

  // try fallback backend
  if (fallback_backend_) {
    return fallback_backend_->resolve_in_module(resolved_path, offset);
  }

  return std::nullopt;
}

std::vector<symbol_info> symbol_resolver::impl::get_module_symbols(const std::string& module_path) const {
  if (!primary_backend_) {
    return {};
  }

  // resolve module path if needed
  std::string resolved_path = module_path;
  if (path_resolver_) {
    if (auto resolved = path_resolver_->resolve_library_path(module_path)) {
      resolved_path = *resolved;
    }
  }

  // prefer backend that supports file resolution for complete symbol list
  if (fallback_backend_ && fallback_backend_->get_capabilities().supports_file_resolution) {
    return fallback_backend_->get_module_symbols(resolved_path);
  }

  return primary_backend_->get_module_symbols(resolved_path);
}

void symbol_resolver::impl::clear_cache() {
  if (primary_backend_) {
    primary_backend_->clear_cache();
  }
  if (fallback_backend_) {
    fallback_backend_->clear_cache();
  }
  cache_hits_ = 0;
  cache_misses_ = 0;
}

symbol_resolver::cache_stats symbol_resolver::impl::get_cache_stats() const {
  size_t total = cache_hits_ + cache_misses_;
  return {
      .size = 0, // backends manage their own caches
      .hits = cache_hits_,
      .misses = cache_misses_,
      .hit_rate = total > 0 ? double(cache_hits_) / double(total) : 0.0
  };
}

std::string symbol_resolver::impl::get_backend_name() const {
  if (primary_backend_) {
    std::string name = primary_backend_->get_name();
    if (fallback_backend_) {
      name += "+" + fallback_backend_->get_name();
    }
    return name;
  }
  return "none";
}

std::vector<std::string> symbol_resolver::impl::get_available_backends() const {
  std::vector<std::string> backends;

  if (primary_backend_ && primary_backend_->is_available()) {
    backends.push_back(primary_backend_->get_name());
  }
  if (fallback_backend_ && fallback_backend_->is_available()) {
    backends.push_back(fallback_backend_->get_name());
  }

  return backends;
}

} // namespace w1::symbols
```

`src/w1tn3ss/symbols/symbol_resolver.hpp`:

```hpp
#pragma once

#include "symbol_info.hpp"
#include "symbol_backend.hpp"
#include "util/module_range_index.hpp"
#include <memory>
#include <optional>
#include <string>
#include <vector>

namespace w1::symbols {

/**
 * @brief main symbol resolution interface
 *
 * provides high-level symbol resolution functionality with automatic
 * backend selection based on platform and availability.
 */
class symbol_resolver {
public:
  /**
   * @brief configuration for symbol resolver
   */
  struct config {
    size_t max_cache_size;
    bool use_native_backend; // prefer native APIs when available
    bool use_lief_backend;   // use LIEF as fallback
    bool enable_caching;
    bool prepopulate_exports;
    bool resolve_imports;

    config()
        : max_cache_size(100), use_native_backend(true), use_lief_backend(true), enable_caching(true),
          prepopulate_exports(true), resolve_imports(true) {}
  };

  explicit symbol_resolver(const config& cfg = {});
  ~symbol_resolver();

  // address to symbol resolution

  /**
   * @brief resolve symbol at absolute address
   * @param address absolute memory address to resolve
   * @param module_index module range index for address lookup
   * @return symbol information if found
   */
  std::optional<symbol_info> resolve_address(uint64_t address, const util::module_range_index& module_index) const;

  /**
   * @brief batch symbol resolution for efficiency
   * @param addresses vector of absolute addresses to resolve
   * @param module_index module range index for address lookup
   * @return vector of symbol information (nullopt for unresolved addresses)
   */
  std::vector<std::optional<symbol_info>> resolve_addresses(
      const std::vector<uint64_t>& addresses, const util::module_range_index& module_index
  ) const;

  // symbol name to address resolution

  /**
   * @brief resolve symbol address by name
   * @param name symbol name to look up
   * @param module_hint optional module name to search in (empty = search all loaded modules)
   * @return absolute address if found
   */
  std::optional<uint64_t> resolve_name(const std::string& name, const std::string& module_hint = "") const;

  /**
   * @brief find symbols matching pattern
   * @param pattern wildcard pattern (e.g. "malloc*", "*printf")
   * @param module_hint optional module to search in
   * @return vector of matching symbols
   */
  std::vector<symbol_info> find_symbols(const std::string& pattern, const std::string& module_hint = "") const;

  // module-specific operations

  /**
   * @brief resolve symbol in specific module at offset
   * @param module_path path to module (may be basename on Windows)
   * @param offset offset within module
   * @return symbol information if found
   */
  std::optional<symbol_info> resolve_in_module(const std::string& module_path, uint64_t offset) const;

  /**
   * @brief get all symbols from a module
   * @param module_path path to module
   * @return vector of all symbols in module
   */
  std::vector<symbol_info> get_module_symbols(const std::string& module_path) const;

  // cache management

  /**
   * @brief clear all internal caches
   */
  void clear_cache();

  /**
   * @brief cache statistics
   */
  struct cache_stats {
    size_t size;
    size_t hits;
    size_t misses;
    double hit_rate;
  };

  /**
   * @brief get cache statistics
   * @return current cache performance metrics
   */
  cache_stats get_cache_stats() const;

  // backend information

  /**
   * @brief get active backend name
   * @return name of the backend being used
   */
  std::string get_backend_name() const;

  /**
   * @brief check which backends are available
   * @return list of available backend names
   */
  std::vector<std::string> get_available_backends() const;

private:
  class impl;
  std::unique_ptr<impl> pimpl_;
};

} // namespace w1::symbols
```

`src/w1tn3ss/symbols/windows_path_resolver.cpp`:

```cpp
#ifdef _WIN32

#include "windows_path_resolver.hpp"
#include <windows.h>
#include <filesystem>
#include <algorithm>
#include <cctype>

namespace w1::symbols {

namespace fs = std::filesystem;

windows_path_resolver::windows_path_resolver() : log_("w1.windows_path_resolver") {
  log_.dbg("initializing windows path resolver");

  system_directories_ = discover_system_directories();

  if (system_directories_.empty()) {
    log_.err("failed to discover any windows system directories");
  } else {
    log_.trc("windows path resolver initialized", redlog::field("system_directories", system_directories_.size()));

    for (const auto& dir : system_directories_) {
      log_.dbg("system directory", redlog::field("path", dir));
    }
  }
}

std::optional<std::string> windows_path_resolver::resolve_library_path(const std::string& library_name) const {
  if (library_name.empty()) {
    return std::nullopt;
  }

  // normalize basename for consistent caching
  std::string norm_basename = normalize_basename(library_name);

  log_.trc(
      "attempting to resolve library path", redlog::field("library", library_name),
      redlog::field("normalized", norm_basename)
  );

  // check cache first
  {
    std::lock_guard<std::mutex> lock(cache_mutex_);
    auto it = path_cache_.find(norm_basename);
    if (it != path_cache_.end()) {
      log_.dbg(
          "path resolver cache hit", redlog::field("library", norm_basename), redlog::field("cached_path", it->second),
          redlog::field("cache_size", path_cache_.size())
      );
      return it->second;
    }
    log_.dbg(
        "path resolver cache miss", redlog::field("library", norm_basename),
        redlog::field("cache_size", path_cache_.size())
    );
  }

  // if it's already a full path and exists, return it
  if (library_name.find('\\') != std::string::npos || library_name.find('/') != std::string::npos) {
    try {
      if (fs::exists(library_name) && fs::is_regular_file(library_name)) {
        // cache the result
        std::lock_guard<std::mutex> lock(cache_mutex_);
        path_cache_[norm_basename] = library_name;
        return library_name;
      }
    } catch (const fs::filesystem_error& e) {
      log_.warn(
          "filesystem error checking path", redlog::field("path", library_name), redlog::field("error", e.what())
      );
    }
  }

  // search in system directories
  auto resolved_path = find_in_system_directories(norm_basename);

  if (resolved_path) {
    log_.dbg(
        "resolved library path", redlog::field("library", library_name), redlog::field("resolved_path", *resolved_path)
    );

    // cache the result
    {
      std::lock_guard<std::mutex> lock(cache_mutex_);
      path_cache_[norm_basename] = *resolved_path;
    }

    return resolved_path;
  }

  log_.trc("library not found", redlog::field("library", library_name));
  return std::nullopt;
}

bool windows_path_resolver::is_system_library(const std::string& path) const {
  std::string basename = path;
  size_t last_slash = basename.find_last_of("\\/");
  if (last_slash != std::string::npos) {
    basename = basename.substr(last_slash + 1);
  }

  return is_likely_system_library(basename);
}

std::vector<std::string> windows_path_resolver::discover_system_directories() const {
  std::vector<std::string> directories;

  log_.dbg("discovering windows system directories");

  // get system32 directory
  wchar_t system32_path[MAX_PATH];
  UINT system32_len = GetSystemDirectoryW(system32_path, MAX_PATH);
  if (system32_len > 0 && system32_len < MAX_PATH) {
    // convert wide string to narrow string
    char narrow_path[MAX_PATH];
    int converted = WideCharToMultiByte(CP_UTF8, 0, system32_path, -1, narrow_path, MAX_PATH, nullptr, nullptr);
    if (converted > 0) {
      std::string system32_str(narrow_path);
      directories.push_back(system32_str);
      log_.dbg("found system32 directory", redlog::field("path", system32_str));
    }
  }

  // get windows directory
  wchar_t windows_path[MAX_PATH];
  UINT windows_len = GetWindowsDirectoryW(windows_path, MAX_PATH);
  if (windows_len > 0 && windows_len < MAX_PATH) {
    char narrow_path[MAX_PATH];
    int converted = WideCharToMultiByte(CP_UTF8, 0, windows_path, -1, narrow_path, MAX_PATH, nullptr, nullptr);
    if (converted > 0) {
      std::string windows_str(narrow_path);
      directories.push_back(windows_str);
      log_.dbg("found windows directory", redlog::field("path", windows_str));
    }
  }

  // add syswow64 directory (for 32-bit dlls on 64-bit systems)
  if (!directories.empty()) {
    // construct syswow64 path from windows directory
    wchar_t syswow64_path[MAX_PATH];
    if (windows_len > 0) {
      // replace "System32" with "SysWOW64" in windows path, or append it
      std::wstring windows_wide(windows_path);
      std::wstring syswow64_wide = windows_wide + L"\\SysWOW64";

      if (syswow64_wide.length() < MAX_PATH) {
        wcscpy_s(syswow64_path, MAX_PATH, syswow64_wide.c_str());

        char narrow_path[MAX_PATH];
        int converted = WideCharToMultiByte(CP_UTF8, 0, syswow64_path, -1, narrow_path, MAX_PATH, nullptr, nullptr);
        if (converted > 0) {
          std::string syswow64_str(narrow_path);
          // check if directory exists before adding
          if (fs::exists(syswow64_str) && fs::is_directory(syswow64_str)) {
            directories.push_back(syswow64_str);
            log_.dbg("found syswow64 directory", redlog::field("path", syswow64_str));
          }
        }
      }
    }
  }

  log_.trc("system directory discovery complete", redlog::field("directories_found", directories.size()));

  return directories;
}

std::optional<std::string> windows_path_resolver::find_in_system_directories(const std::string& basename) const {
  log_.trc(
      "searching for library in system directories", redlog::field("basename", basename),
      redlog::field("directories_to_search", system_directories_.size())
  );

  for (const auto& dir : system_directories_) {
    std::string full_path = dir + "\\" + basename;

    log_.trc("checking path", redlog::field("full_path", full_path));

    try {
      if (fs::exists(full_path) && fs::is_regular_file(full_path)) {
        log_.dbg("found library file", redlog::field("basename", basename), redlog::field("full_path", full_path));
        return full_path;
      }
    } catch (const fs::filesystem_error& e) {
      log_.warn(
          "filesystem error while checking path", redlog::field("path", full_path), redlog::field("error", e.what())
      );
      continue;
    }
  }

  log_.trc("library not found in any system directory", redlog::field("basename", basename));
  return std::nullopt;
}

std::string windows_path_resolver::normalize_basename(const std::string& basename) const {
  std::string normalized = basename;

  // convert to lowercase for case-insensitive matching
  std::transform(normalized.begin(), normalized.end(), normalized.begin(), [](char c) { return std::tolower(c); });

  return normalized;
}

bool windows_path_resolver::is_likely_system_library(const std::string& basename) const {
  if (basename.empty()) {
    return false;
  }

  // must be a dll
  if (basename.find(".dll") == std::string::npos) {
    return false;
  }

  // common windows system library patterns
  static const std::vector<std::string> system_patterns = {
      "kernel32.dll", "ntdll.dll", "user32.dll",   "gdi32.dll",      "advapi32.dll", "shell32.dll",
      "shlwapi.dll",  "ole32.dll", "oleaut32.dll", "rpcrt4.dll",     "ucrtbase.dll", "msvcrt.dll",
      "msvcp",        "vcruntime", "api-ms-win-",  "kernelbase.dll", "sechost.dll",  "comctl32.dll",
      "ws2_32.dll",   "winmm.dll", "version.dll",  "imm32.dll",      "setupapi.dll"
  };

  std::string lower_basename = normalize_basename(basename);

  for (const auto& pattern : system_patterns) {
    if (lower_basename.find(pattern) == 0 || lower_basename == pattern) {
      log_.trc(
          "matched system library pattern", redlog::field("basename", basename), redlog::field("pattern", pattern)
      );
      return true;
    }
  }

  log_.trc("no system library pattern match", redlog::field("basename", basename));
  return false;
}

} // namespace w1::symbols

#endif // _WIN32
```

`src/w1tn3ss/symbols/windows_path_resolver.hpp`:

```hpp
#pragma once

#ifdef _WIN32

#include "path_resolver.hpp"
#include <redlog.hpp>
#include <mutex>
#include <unordered_map>

namespace w1::symbols {

/**
 * @brief windows path resolver for system libraries
 *
 * resolves system library names to full paths using windows APIs
 * and knowledge of system directories.
 */
class windows_path_resolver : public path_resolver {
public:
  windows_path_resolver();
  ~windows_path_resolver() = default;

  // path_resolver interface
  std::optional<std::string> resolve_library_path(const std::string& library_name) const override;
  std::vector<std::string> get_system_directories() const override { return system_directories_; }
  bool is_system_library(const std::string& path) const override;
  std::string get_name() const override { return "windows_path"; }

private:
  // helper methods
  std::vector<std::string> discover_system_directories() const;
  std::optional<std::string> find_in_system_directories(const std::string& basename) const;
  std::string normalize_basename(const std::string& basename) const;
  bool is_likely_system_library(const std::string& basename) const;

  // system directories
  std::vector<std::string> system_directories_;

  // path cache
  mutable std::mutex cache_mutex_;
  mutable std::unordered_map<std::string, std::string> path_cache_;

  // logging
  redlog::logger log_;
};

} // namespace w1::symbols

#endif // _WIN32
```

`src/w1tn3ss/symbols/windows_symbol_backend.cpp`:

```cpp
#ifdef _WIN32

#include "windows_symbol_backend.hpp"
#include "windows_path_resolver.hpp"

#ifdef _WIN32
#ifndef NOMINMAX
#define NOMINMAX
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <dbghelp.h>
#include <psapi.h>
#endif
#include <algorithm>
#include <cctype>

// define SymTag constants since cvconst.h might not be available
#ifndef SymTagFunction
enum SymTagEnum {
  SymTagNull,
  SymTagExe,
  SymTagCompiland,
  SymTagCompilandDetails,
  SymTagCompilandEnv,
  SymTagFunction,
  SymTagBlock,
  SymTagData,
  SymTagAnnotation,
  SymTagLabel,
  SymTagPublicSymbol,
  SymTagUDT,
  SymTagEnum,
  SymTagFunctionType,
  SymTagPointerType,
  SymTagArrayType,
  SymTagBaseType,
  SymTagTypedef,
  SymTagBaseClass,
  SymTagFriend,
  SymTagFunctionArgType,
  SymTagFuncDebugStart,
  SymTagFuncDebugEnd,
  SymTagUsingNamespace,
  SymTagVTableShape,
  SymTagVTable,
  SymTagCustom,
  SymTagThunk,
  SymTagCustomType,
  SymTagManagedType,
  SymTagDimension,
  SymTagCallSite,
  SymTagInlineSite,
  SymTagBaseInterface,
  SymTagVectorType,
  SymTagMatrixType,
  SymTagHLSLType,
  SymTagCaller,
  SymTagCallee,
  SymTagExport,
  SymTagHeapAllocationSite,
  SymTagCoffGroup,
  SymTagMax
};
#endif

#pragma comment(lib, "dbghelp.lib")
#pragma comment(lib, "psapi.lib")

namespace w1::symbols {

// static members
std::once_flag windows_symbol_backend::init_flag_;
bool windows_symbol_backend::init_success_ = false;

windows_symbol_backend::windows_symbol_backend() : log_("w1.windows_symbol_backend") {
  // initialization happens on first use
}

windows_symbol_backend::~windows_symbol_backend() = default;

bool windows_symbol_backend::is_available() const {
  return true; // windows backend is always available on windows
}

windows_symbol_backend::capabilities windows_symbol_backend::get_capabilities() const {
  return {
      .supports_runtime_resolution = true,
      .supports_file_resolution = false, // dbghelp works with loaded modules
      .supports_pattern_matching = true,
      .supports_demangling = true
  };
}

std::optional<symbol_info> windows_symbol_backend::resolve_address(uint64_t address) const {
  auto win_info = resolve_symbol_info_native(address);
  if (!win_info) {
    return std::nullopt;
  }

  return convert_to_symbol_info(*win_info);
}

std::optional<uint64_t> windows_symbol_backend::resolve_name(
    const std::string& name, const std::string& module_hint
) const {
  static HANDLE process_handle = GetCurrentProcess();

  // ensure dbghelp is initialized
  std::call_once(init_flag_, [this]() {
    log_.dbg("initializing winapi symbol handler");

    DWORD options = SymGetOptions();
    options |= SYMOPT_DEFERRED_LOADS | SYMOPT_UNDNAME | SYMOPT_LOAD_LINES;
    options |= SYMOPT_INCLUDE_32BIT_MODULES;
    options |= SYMOPT_CASE_INSENSITIVE;
    SymSetOptions(options);

    if (!SymInitialize(process_handle, NULL, TRUE)) {
      DWORD error = GetLastError();
      log_.err("failed to initialize symbol handler", redlog::field("error", error));
      init_success_ = false;
      return;
    }

    log_.trc("winapi symbol handler initialized");
    init_success_ = true;
  });

  if (!init_success_) {
    return std::nullopt;
  }

  // if module hint provided, get specific module base
  DWORD64 module_base = 0;
  if (!module_hint.empty()) {
    ModuleHandle hmodule = get_module_handle_safe(module_hint);
    if (hmodule) {
      module_base = reinterpret_cast<DWORD64>(hmodule);
    }
  }

  // try to find symbol
  SYMBOL_INFO symbol_info = {};
  symbol_info.SizeOfStruct = sizeof(SYMBOL_INFO);

  if (SymFromName(process_handle, name.c_str(), &symbol_info)) {
    // if module hint was provided, verify the symbol is from that module
    if (module_base != 0) {
      IMAGEHLP_MODULE64 module_info = {};
      module_info.SizeOfStruct = sizeof(IMAGEHLP_MODULE64);
      if (SymGetModuleInfo64(process_handle, symbol_info.Address, &module_info)) {
        if (module_info.BaseOfImage != module_base) {
          // symbol found but in wrong module
          return std::nullopt;
        }
      }
    }

    log_.dbg(
        "resolved symbol by name", redlog::field("name", name),
        redlog::field("address", "0x%016llx", symbol_info.Address)
    );
    return symbol_info.Address;
  }

  return std::nullopt;
}

std::optional<symbol_info> windows_symbol_backend::resolve_in_module(
    const std::string& module_path, uint64_t offset
) const {
  log_.trc(
      "resolving symbol in module", redlog::field("module_path", module_path),
      redlog::field("offset", "0x%016llx", offset)
  );

  // get module handle
  ModuleHandle module_handle = get_module_handle_safe(module_path);
  if (!module_handle) {
    log_.trc("module not loaded", redlog::field("module_path", module_path));
    return std::nullopt;
  }

  // get module base address
  MODULEINFO module_info;
  if (!GetModuleInformation(
          GetCurrentProcess(), static_cast<HMODULE>(module_handle), &module_info, sizeof(module_info)
      )) {
    DWORD error = GetLastError();
    log_.trc(
        "failed to get module information", redlog::field("module_path", module_path), redlog::field("error", error)
    );
    return std::nullopt;
  }

  uint64_t module_base = reinterpret_cast<uint64_t>(module_info.lpBaseOfDll);
  uint64_t absolute_address = module_base + offset;

  log_.trc(
      "calculated absolute address", redlog::field("module_base", "0x%016llx", module_base),
      redlog::field("offset", "0x%016llx", offset), redlog::field("absolute_address", "0x%016llx", absolute_address)
  );

  // now resolve the symbol at the absolute address
  return resolve_address(absolute_address);
}

// callback context for symbol enumeration
struct enum_context {
  std::vector<symbol_info>* symbols;
  const std::string* pattern;
  windows_symbol_backend* backend;
};

BOOL CALLBACK
windows_symbol_backend::enum_symbols_callback(PSYMBOL_INFO symbol_info, ULONG symbol_size, PVOID user_context) {
  auto* ctx = static_cast<enum_context*>(user_context);

  // convert windows symbol info to our format
  windows_symbol_info win_info;
  win_info.name = symbol_info->Name;
  win_info.address = symbol_info->Address;
  win_info.size = symbol_info->Size;
  win_info.displacement = 0;
  win_info.is_function =
      (symbol_info->Tag == SymTagFunction || symbol_info->Tag == SymTagPublicSymbol ||
       (symbol_info->Flags & SYMFLAG_FUNCTION));
  win_info.is_exported = (symbol_info->Flags & SYMFLAG_EXPORT);

  // get module info
  IMAGEHLP_MODULE64 module_info = {};
  module_info.SizeOfStruct = sizeof(IMAGEHLP_MODULE64);
  if (SymGetModuleInfo64(GetCurrentProcess(), symbol_info->Address, &module_info)) {
    win_info.module_name = module_info.ModuleName;
  }

  // demangle if needed
  win_info.demangled_name = win_info.name;
  char demangled_buffer[MAX_SYM_NAME] = {};
  DWORD demangled_length = UnDecorateSymbolName(
      win_info.name.c_str(), demangled_buffer, MAX_SYM_NAME, UNDNAME_COMPLETE | UNDNAME_NO_LEADING_UNDERSCORES
  );
  if (demangled_length > 0 && demangled_buffer[0] != '\0') {
    win_info.demangled_name = std::string(demangled_buffer, demangled_length);
  }

  // check pattern match if provided
  if (ctx->pattern && !ctx->pattern->empty()) {
    // simple wildcard matching (TODO: could be improved)
    std::string pattern = *ctx->pattern;
    std::string name_lower = win_info.demangled_name;
    std::transform(name_lower.begin(), name_lower.end(), name_lower.begin(), ::tolower);
    std::transform(pattern.begin(), pattern.end(), pattern.begin(), ::tolower);

    bool matches = false;
    if (pattern.front() == '*' && pattern.back() == '*') {
      // *substring*
      matches = name_lower.find(pattern.substr(1, pattern.length() - 2)) != std::string::npos;
    } else if (pattern.back() == '*') {
      // prefix*
      matches = name_lower.find(pattern.substr(0, pattern.length() - 1)) == 0;
    } else if (pattern.front() == '*') {
      // *suffix
      std::string suffix = pattern.substr(1);
      matches = name_lower.length() >= suffix.length() &&
                name_lower.compare(name_lower.length() - suffix.length(), suffix.length(), suffix) == 0;
    } else {
      // exact match
      matches = name_lower == pattern;
    }

    if (!matches) {
      return TRUE; // continue enumeration
    }
  }

  ctx->symbols->push_back(ctx->backend->convert_to_symbol_info(win_info));

  return TRUE; // continue enumeration
}

std::vector<symbol_info> windows_symbol_backend::find_symbols(
    const std::string& pattern, const std::string& module_hint
) const {
  std::vector<symbol_info> results;

  static HANDLE process_handle = GetCurrentProcess();

  // ensure dbghelp is initialized
  std::call_once(init_flag_, [this]() {
    log_.dbg("initializing winapi symbol handler");

    DWORD options = SymGetOptions();
    options |= SYMOPT_DEFERRED_LOADS | SYMOPT_UNDNAME | SYMOPT_LOAD_LINES;
    options |= SYMOPT_INCLUDE_32BIT_MODULES;
    options |= SYMOPT_CASE_INSENSITIVE;
    SymSetOptions(options);

    if (!SymInitialize(process_handle, NULL, TRUE)) {
      DWORD error = GetLastError();
      log_.err("failed to initialize symbol handler", redlog::field("error", error));
      init_success_ = false;
      return;
    }

    log_.trc("winapi symbol handler initialized");
    init_success_ = true;
  });

  if (!init_success_) {
    return results;
  }

  enum_context ctx = {&results, &pattern, const_cast<windows_symbol_backend*>(this)};

  // if module hint provided, enumerate only that module
  if (!module_hint.empty()) {
    ModuleHandle hmodule = get_module_handle_safe(module_hint);
    if (hmodule) {
      DWORD64 base = reinterpret_cast<DWORD64>(hmodule);
      SymEnumSymbols(process_handle, base, nullptr, enum_symbols_callback, &ctx);
    }
  } else {
    // enumerate all modules
    SymEnumSymbols(process_handle, 0, nullptr, enum_symbols_callback, &ctx);
  }

  log_.dbg("found symbols matching pattern", redlog::field("pattern", pattern), redlog::field("count", results.size()));

  return results;
}

std::vector<symbol_info> windows_symbol_backend::get_module_symbols(const std::string& module_path) const {
  // use find_symbols with empty pattern to get all symbols
  return find_symbols("", module_path);
}

void windows_symbol_backend::clear_cache() {
  std::lock_guard<std::mutex> lock(cache_mutex_);
  module_cache_.clear();
  log_.dbg("windows symbol backend cache cleared");
}

std::optional<windows_symbol_backend::windows_symbol_info> windows_symbol_backend::resolve_symbol_info_native(
    uint64_t address
) const {
  static HANDLE process_handle = GetCurrentProcess();

  // thread-safe initialization using std::call_once
  std::call_once(init_flag_, [this]() {
    log_.dbg("initializing winapi symbol handler");

    DWORD options = SymGetOptions();
    options |= SYMOPT_DEFERRED_LOADS | SYMOPT_UNDNAME | SYMOPT_LOAD_LINES;
    options |= SYMOPT_INCLUDE_32BIT_MODULES;
    options |= SYMOPT_CASE_INSENSITIVE;
    SymSetOptions(options);

    if (!SymInitialize(process_handle, NULL, TRUE)) {
      DWORD error = GetLastError();
      log_.err("failed to initialize symbol handler", redlog::field("error", error));
      init_success_ = false;
      return;
    }

    log_.trc("winapi symbol handler initialized");
    init_success_ = true;
  });

  // check if initialization succeeded
  if (!init_success_) {
    log_.trc("symbol handler initialization failed, cannot resolve symbols");
    return std::nullopt;
  }

  // allocate buffer for symbol info
  const size_t buffer_size = sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(TCHAR);
  char buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(TCHAR)];
  PSYMBOL_INFO symbol_info = (PSYMBOL_INFO) buffer;

  symbol_info->SizeOfStruct = sizeof(SYMBOL_INFO);
  symbol_info->MaxNameLen = MAX_SYM_NAME;

  DWORD64 displacement = 0;

  log_.ped("calling SymFromAddr", redlog::field("address", "0x%016llx", address));

  if (SymFromAddr(process_handle, address, &displacement, symbol_info)) {
    windows_symbol_info result;

    // basic symbol information
    if (symbol_info->NameLen > 0 && symbol_info->Name) {
      result.name.assign(symbol_info->Name, symbol_info->NameLen);
    } else {
      result.name.clear();
    }
    result.address = symbol_info->Address;
    result.size = symbol_info->Size;
    result.displacement = displacement;

    // get module information
    IMAGEHLP_MODULE64 module_info = {};
    module_info.SizeOfStruct = sizeof(IMAGEHLP_MODULE64);
    if (SymGetModuleInfo64(process_handle, address, &module_info)) {
      result.module_name = std::string(module_info.ModuleName);
      log_.ped("retrieved module info", redlog::field("module", result.module_name));
    } else {
      result.module_name.clear();
    }

    // determine symbol type
    result.is_function =
        (symbol_info->Tag == SymTagFunction || symbol_info->Tag == SymTagPublicSymbol ||
         (symbol_info->Flags & SYMFLAG_FUNCTION));

    result.is_exported = (symbol_info->Flags & SYMFLAG_EXPORT);

    // try to get demangled name
    result.demangled_name = result.name; // fallback
    if (!result.name.empty()) {
      char demangled_buffer[MAX_SYM_NAME] = {};
      DWORD demangled_length = UnDecorateSymbolName(
          result.name.c_str(), demangled_buffer, MAX_SYM_NAME, UNDNAME_COMPLETE | UNDNAME_NO_LEADING_UNDERSCORES
      );
      if (demangled_length > 0 && demangled_buffer[0] != '\0') {
        result.demangled_name = std::string(demangled_buffer, demangled_length);
      }
    }

    log_.ped(
        "SymFromAddr success", redlog::field("address", "0x%016llx", address), redlog::field("symbol", result.name),
        redlog::field("demangled", result.demangled_name), redlog::field("displacement", displacement),
        redlog::field("size", result.size), redlog::field("module", result.module_name)
    );

    return result;
  } else {
    DWORD error = GetLastError();
    log_.ped("SymFromAddr failed", redlog::field("address", "0x%016llx", address), redlog::field("error", error));
    return std::nullopt;
  }
}

symbol_info windows_symbol_backend::convert_to_symbol_info(const windows_symbol_info& win_info) const {
  symbol_info info{};

  // copy string fields
  info.name = win_info.name;
  info.demangled_name = win_info.demangled_name;
  info.section = win_info.module_name;

  // ensure we have at least a name
  if (info.name.empty()) {
    info.name = "sub_" + std::to_string(win_info.address);
  }

  // handle numeric fields
  info.size = win_info.size;
  info.offset_from_symbol = win_info.displacement;
  info.module_offset = 0; // not available from Windows debug APIs

  // map symbol type
  info.symbol_type = win_info.is_function ? symbol_info::type::FUNCTION : symbol_info::type::OBJECT;

  // windows resolved symbols are typically global scope
  info.symbol_binding = symbol_info::binding::GLOBAL;

  // copy boolean flags
  info.is_exported = win_info.is_exported;
  info.is_imported = false; // SymFromAddr resolves actual symbols, not import stubs

  // version field is typically empty for windows symbols
  info.version.clear();

  return info;
}

ModuleHandle windows_symbol_backend::get_module_handle_safe(const std::string& module_name) const {
  // check cache first
  {
    std::lock_guard<std::mutex> lock(cache_mutex_);
    auto it = module_cache_.find(module_name);
    if (it != module_cache_.end()) {
      return it->second;
    }
  }

  // try to get module handle
  HMODULE handle = GetModuleHandleA(module_name.c_str());

  if (!handle) {
    // try with just basename if full path was provided
    std::string basename = module_name;
    size_t last_slash = basename.find_last_of("\\/");
    if (last_slash != std::string::npos) {
      basename = basename.substr(last_slash + 1);
      handle = GetModuleHandleA(basename.c_str());
    }
  }

  // cache the result if found
  ModuleHandle result = static_cast<ModuleHandle>(handle);
  if (result) {
    std::lock_guard<std::mutex> lock(cache_mutex_);
    module_cache_[module_name] = result;
  }

  return result;
}

} // namespace w1::symbols

#endif // _WIN32
```

`src/w1tn3ss/symbols/windows_symbol_backend.hpp`:

```hpp
#pragma once

#ifdef _WIN32

#include "symbol_backend.hpp"
#include "symbol_info.hpp"
#include <redlog.hpp>
#include <mutex>
#include <unordered_map>
// forward declarations to avoid including windows headers in header
#ifdef _WIN32
struct _SYMBOL_INFO;
typedef _SYMBOL_INFO* PSYMBOL_INFO;
typedef unsigned long ULONG;
typedef void* PVOID;
typedef int BOOL;
// use void* for HMODULE to avoid windows.h dependency, we'll cast it later'
typedef void* ModuleHandle;
#endif

namespace w1::symbols {

/**
 * @brief windows native symbol resolution using DbgHelp APIs
 */
class windows_symbol_backend : public symbol_backend {
public:
  windows_symbol_backend();
  ~windows_symbol_backend();

  // symbol_backend interface
  std::optional<symbol_info> resolve_address(uint64_t address) const override;
  std::optional<uint64_t> resolve_name(const std::string& name, const std::string& module_hint = "") const override;
  std::optional<symbol_info> resolve_in_module(const std::string& module_path, uint64_t offset) const override;
  std::vector<symbol_info> find_symbols(const std::string& pattern, const std::string& module_hint = "") const override;
  std::vector<symbol_info> get_module_symbols(const std::string& module_path) const override;

  std::string get_name() const override { return "windows_native"; }
  bool is_available() const override;
  capabilities get_capabilities() const override;
  void clear_cache() override;

private:
  // internal windows symbol info structure
  struct windows_symbol_info {
    std::string name;
    std::string demangled_name;
    std::string module_name;
    uint64_t address;
    uint64_t size;
    uint64_t displacement;
    bool is_function;
    bool is_exported;
  };

  // helper methods
  std::optional<windows_symbol_info> resolve_symbol_info_native(uint64_t address) const;
  symbol_info convert_to_symbol_info(const windows_symbol_info& win_info) const;
  ModuleHandle get_module_handle_safe(const std::string& module_name) const;

  // symbol enumeration callback (implementation in cpp)
  static BOOL __stdcall enum_symbols_callback(PSYMBOL_INFO symbol_info, ULONG symbol_size, PVOID user_context);

  // logging
  mutable redlog::logger log_;

  // initialization tracking
  static std::once_flag init_flag_;
  static bool init_success_;

  // cache for module handles
  mutable std::mutex cache_mutex_;
  mutable std::unordered_map<std::string, ModuleHandle> module_cache_;
};

} // namespace w1::symbols

#endif // _WIN32
```

`src/w1tn3ss/util/env_config.cpp`:

```cpp
#include "env_config.hpp"
#include <cstdlib>
#include <sstream>
#include <algorithm>
#include <cctype>
#include <iostream>

namespace w1 {
namespace util {

env_config::env_config(const std::string& prefix) : prefix_(prefix) {
  if (!prefix_.empty() && prefix_.back() != '_') {
    prefix_ += "_";
  }
}

std::string env_config::build_env_name(const std::string& name) const { return prefix_ + name; }

std::string env_config::get_env_value(const std::string& name) const {
  const char* value = std::getenv(build_env_name(name).c_str());
  return value ? std::string(value) : std::string();
}

std::string env_config::to_lower(const std::string& str) const {
  std::string result = str;
  std::transform(result.begin(), result.end(), result.begin(), ::tolower);
  return result;
}

std::string env_config::trim(const std::string& str) const {
  size_t first = str.find_first_not_of(' ');
  if (std::string::npos == first) {
    return str;
  }
  size_t last = str.find_last_not_of(' ');
  return str.substr(first, (last - first + 1));
}

template <> std::string env_config::get<std::string>(const std::string& name, std::string default_value) const {
  std::string value = get_env_value(name);
  return value.empty() ? default_value : value;
}

template <> bool env_config::get<bool>(const std::string& name, bool default_value) const {
  std::string value = get_env_value(name);
  if (value.empty()) {
    return default_value;
  }

  std::string lower_value = to_lower(value);
  return (lower_value == "1" || lower_value == "true" || lower_value == "yes" || lower_value == "on");
}

template <> int env_config::get<int>(const std::string& name, int default_value) const {
  std::string value = get_env_value(name);
  if (value.empty()) {
    return default_value;
  }

  try {
    return std::stoi(value);
  } catch (const std::exception& e) {
    std::cerr << "Warning: Failed to parse " << build_env_name(name) << " as int: " << e.what() << ", using default"
              << std::endl;
    return default_value;
  }
}

template <> long env_config::get<long>(const std::string& name, long default_value) const {
  std::string value = get_env_value(name);
  if (value.empty()) {
    return default_value;
  }

  try {
    return std::stol(value);
  } catch (const std::exception& e) {
    std::cerr << "Warning: Failed to parse " << build_env_name(name) << " as long: " << e.what() << ", using default"
              << std::endl;
    return default_value;
  }
}

template <> uint32_t env_config::get<uint32_t>(const std::string& name, uint32_t default_value) const {
  std::string value = get_env_value(name);
  if (value.empty()) {
    return default_value;
  }

  try {
    return static_cast<uint32_t>(std::stoul(value));
  } catch (const std::exception& e) {
    std::cerr << "Warning: Failed to parse " << build_env_name(name) << " as uint32_t: " << e.what()
              << ", using default" << std::endl;
    return default_value;
  }
}

template <> uint64_t env_config::get<uint64_t>(const std::string& name, uint64_t default_value) const {
  std::string value = get_env_value(name);
  if (value.empty()) {
    return default_value;
  }

  try {
    return std::stoull(value);
  } catch (const std::exception& e) {
    std::cerr << "Warning: Failed to parse " << build_env_name(name) << " as uint64_t: " << e.what()
              << ", using default" << std::endl;
    return default_value;
  }
}

template <> float env_config::get<float>(const std::string& name, float default_value) const {
  std::string value = get_env_value(name);
  if (value.empty()) {
    return default_value;
  }

  try {
    return std::stof(value);
  } catch (const std::exception& e) {
    std::cerr << "Warning: Failed to parse " << build_env_name(name) << " as float: " << e.what() << ", using default"
              << std::endl;
    return default_value;
  }
}

template <> double env_config::get<double>(const std::string& name, double default_value) const {
  std::string value = get_env_value(name);
  if (value.empty()) {
    return default_value;
  }

  try {
    return std::stod(value);
  } catch (const std::exception& e) {
    std::cerr << "Warning: Failed to parse " << build_env_name(name) << " as double: " << e.what() << ", using default"
              << std::endl;
    return default_value;
  }
}

std::vector<std::string> env_config::get_list(const std::string& name, char delimiter) const {
  std::string value = get_env_value(name);
  std::vector<std::string> result;

  if (value.empty()) {
    return result;
  }

  std::stringstream ss(value);
  std::string item;

  while (std::getline(ss, item, delimiter)) {
    result.push_back(trim(item));
  }

  return result;
}

template <typename EnumType>
EnumType env_config::get_enum(
    const std::initializer_list<std::pair<const char*, EnumType>>& mapping, const std::string& name,
    EnumType default_value
) const {
  std::string value = get_env_value(name);
  if (value.empty()) {
    return default_value;
  }

  std::string lower_value = to_lower(value);

  for (const auto& pair : mapping) {
    if (to_lower(pair.first) == lower_value) {
      return pair.second;
    }
  }

  std::cerr << "Warning: Unknown value '" << value << "' for " << build_env_name(name) << ", using default"
            << std::endl;
  return default_value;
}

} // namespace util
} // namespace w1
```

`src/w1tn3ss/util/env_config.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>
#include <initializer_list>
#include <utility>

namespace w1 {
namespace util {

class env_config {
public:
  explicit env_config(const std::string& prefix = "");

  template <typename T> T get(const std::string& name, T default_value) const;

  std::vector<std::string> get_list(const std::string& name, char delimiter = ',') const;

  template <typename EnumType>
  EnumType get_enum(
      const std::initializer_list<std::pair<const char*, EnumType>>& mapping, const std::string& name,
      EnumType default_value
  ) const;

private:
  std::string prefix_;
  std::string build_env_name(const std::string& name) const;
  std::string get_env_value(const std::string& name) const;
  std::string to_lower(const std::string& str) const;
  std::string trim(const std::string& str) const;
};

} // namespace util
} // namespace w1
```

`src/w1tn3ss/util/env_enumerator.cpp`:

```cpp
#include "env_enumerator.hpp"

#ifndef _WIN32
// On Unix systems, environ needs to be explicitly declared
// Some systems define it in unistd.h, others don't
extern "C" {
extern char** environ;
}
#endif

namespace w1::util {

std::unordered_map<std::string, std::string> env_enumerator::get_vars_with_prefix(const std::string& prefix) {
  std::unordered_map<std::string, std::string> result;

#ifdef _WIN32
  // windows: use GetEnvironmentStrings
  LPCH env_strings = GetEnvironmentStrings();
  if (env_strings) {
    LPCH current = env_strings;
    while (*current) {
      std::string env_var(current);
      if (env_var.find(prefix) == 0) {
        size_t eq_pos = env_var.find('=');
        if (eq_pos != std::string::npos) {
          std::string key = env_var.substr(prefix.length(), eq_pos - prefix.length());
          std::string value = env_var.substr(eq_pos + 1);
          result[key] = value;
        }
      }
      current += env_var.length() + 1;
    }
    FreeEnvironmentStrings(env_strings);
  }
#else
  // unix: use environ
  if (char** env_ptr = environ) {
    for (char** env = env_ptr; *env != nullptr; env++) {
      std::string env_var(*env);
      if (env_var.find(prefix) == 0) {
        size_t eq_pos = env_var.find('=');
        if (eq_pos != std::string::npos) {
          std::string key = env_var.substr(prefix.length(), eq_pos - prefix.length());
          std::string value = env_var.substr(eq_pos + 1);
          result[key] = value;
        }
      }
    }
  }
#endif

  return result;
}

} // namespace w1::util
```

`src/w1tn3ss/util/env_enumerator.hpp`:

```hpp
#pragma once

#include <string>
#include <unordered_map>

#ifdef _WIN32
#include <w1common/windows_clean.hpp>
#endif

namespace w1::util {

/**
 * @brief Portable environment variable enumeration
 *
 * This utility provides a clean, cross-platform way to enumerate
 * environment variables that match a given prefix.
 */
class env_enumerator {
public:
  /**
   * @brief Get all environment variables with the specified prefix
   * @param prefix The prefix to match (e.g., "W1SCRIPT_")
   * @return Map of environment variable names (without prefix) to values
   */
  static std::unordered_map<std::string, std::string> get_vars_with_prefix(const std::string& prefix);
};

} // namespace w1::util
```

`src/w1tn3ss/util/interval_tree.hpp`:

```hpp
#pragma once

/**
 * @file interval_tree.hpp
 * @brief A high-performance, header-only, immutable interval tree for C++17.
 *
 * @par Description
 * This file contains a modern C++17 implementation of an interval tree. The tree
 * is constructed from a collection of intervals and provides fast queries for
 * finding intervals that overlap a given point or another interval. The tree is
 * immutable; once constructed, it cannot be modified. This design simplifies
 * the data structure and makes it inherently thread-safe for concurrent reads.
 *
 * The implementation uses a center-point partitioning strategy, choosing the
 * median of all interval endpoints to ensure the tree is well-balanced.
 *
 * @par Time Complexity
 * - **Construction:** O(N log N)
 * - **Query:** O(log N + K), where N is the total number of intervals and K is
 *   the number of reported results.
 *
 * @par Interval Convention
 * All intervals are treated as half-open: `[start, stop)`. This means the
 * start point is inclusive, and the stop point is exclusive.
 *
 * @par API
 * The primary class is `interval_tree::interval_tree<Scalar, Value>`.
 * It can be constructed from any iterator pair or an `std::initializer_list`.
 *
 * Two types of query methods are provided:
 * 1.  `find_*` methods: Return a `std::vector` of matching intervals. Convenient
 *     but involves memory allocation.
 * 2.  `visit_*` methods: Take a callable (e.g., a lambda) and invoke it for
 *     each matching interval. This is a higher-performance alternative that
 *     avoids allocating a result vector.
 *
 * @par Example
 * @code
 * #include "interval_tree.hpp"
 * #include <iostream>
 * #include <string>
 * #include <vector>
 *
 * int main() {
 *     using tree_t = interval_tree::interval_tree<int, std::string>;
 *     using interval_t = tree_t::interval_type;
 *
 *     std::vector<interval_t> intervals = {{5, 10, "A"}, {12, 18, "B"}};
 *     tree_t tree(intervals.begin(), intervals.end());
 *
 *     // Find intervals overlapping the point 7.
 *     auto results = tree.find_overlapping(7);
 *     for (const auto& r : results) {
 *         std::cout << r << std::endl; // Prints "interval[5, 10): A"
 *     }
 *
 *     // Use a visitor to find intervals overlapping the range [9, 13).
 *     tree.visit_overlapping(9, 13, [](const interval_t& r) {
 *         std::cout << "Visitor found: " << r << std::endl;
 *     });
 *     // Prints "Visitor found: interval[5, 10): A"
 *     // Prints "Visitor found: interval[12, 18): B"
 * }
 * @endcode
 */

#include <algorithm>
#include <cassert>
#include <chrono>
#include <functional>
#include <iostream>
#include <iterator>
#include <memory>
#include <numeric>
#include <vector>

namespace interval_tree {

template <typename Scalar, typename Value> struct interval {
  using scalar_type = Scalar;
  using value_type = Value;

  scalar_type start;
  scalar_type stop;
  value_type value;

  interval(const scalar_type& s, const scalar_type& e, const value_type& v)
      : start(std::min(s, e)), stop(std::max(s, e)), value(std::move(v)) {}

  [[nodiscard]] scalar_type length() const noexcept { return stop - start; }

  [[nodiscard]] bool contains(const scalar_type& point) const noexcept { return point >= start && point < stop; }

  [[nodiscard]] bool overlaps(const interval& other) const noexcept { return start < other.stop && stop > other.start; }
};

template <typename Scalar, typename Value>
std::ostream& operator<<(std::ostream& os, const interval<Scalar, Value>& i) {
  os << "interval[" << i.start << ", " << i.stop << "): " << i.value;
  return os;
}

template <typename Scalar, typename Value> class interval_tree {
public:
  using interval_type = interval<Scalar, Value>;
  using scalar_type = Scalar;
  using value_type = Value;
  using size_type = std::size_t;

private:
  static constexpr size_type MAX_DEPTH = 32;
  static constexpr size_type LEAF_NODE_THRESHOLD = 64;

public:
  interval_tree() noexcept = default;

  template <typename FwdIt> interval_tree(FwdIt first, FwdIt last) {
    std::vector<interval_type> intervals(first, last);
    size_ = intervals.size();
    if (!intervals.empty()) {
      build_tree(std::move(intervals), 0);
    }
  }

  interval_tree(std::initializer_list<interval_type> ilist) : interval_tree(ilist.begin(), ilist.end()) {}

  interval_tree(const interval_tree& other)
      : center_(other.center_), size_(other.size_), intervals_by_start_(other.intervals_by_start_),
        intervals_by_stop_(other.intervals_by_stop_),
        left_(other.left_ ? std::make_unique<interval_tree>(*other.left_) : nullptr),
        right_(other.right_ ? std::make_unique<interval_tree>(*other.right_) : nullptr) {}

  interval_tree& operator=(const interval_tree& other) {
    if (this == &other) {
      return *this;
    }
    center_ = other.center_;
    size_ = other.size_;
    intervals_by_start_ = other.intervals_by_start_;
    intervals_by_stop_ = other.intervals_by_stop_;
    left_ = other.left_ ? std::make_unique<interval_tree>(*other.left_) : nullptr;
    right_ = other.right_ ? std::make_unique<interval_tree>(*other.right_) : nullptr;
    return *this;
  }

  interval_tree(interval_tree&& other) noexcept = default;
  interval_tree& operator=(interval_tree&& other) noexcept = default;
  ~interval_tree() = default;

  [[nodiscard]] std::vector<interval_type> find_overlapping(const scalar_type& point) const {
    std::vector<interval_type> result;
    visit_overlapping(point, [&](const interval_type& interval) { result.push_back(interval); });
    return result;
  }

  [[nodiscard]] std::vector<interval_type> find_overlapping(const scalar_type& start, const scalar_type& stop) const {
    std::vector<interval_type> result;
    if (start < stop) {
      visit_overlapping(start, stop, [&](const interval_type& interval) { result.push_back(interval); });
    }
    return result;
  }

  [[nodiscard]] std::vector<interval_type> find_contained(const scalar_type& start, const scalar_type& stop) const {
    std::vector<interval_type> result;
    if (start < stop) {
      visit_contained(start, stop, [&](const interval_type& interval) { result.push_back(interval); });
    }
    return result;
  }

  template <typename Visitor> void visit_overlapping(const scalar_type& point, Visitor visitor) const {
    if (empty()) {
      return;
    }
    visit_point_impl(point, visitor);
  }

  /**
   * @brief Visits all intervals that overlap a given query interval [start, stop).
   * @pre `start <= stop`.
   */
  template <typename Visitor>
  void visit_overlapping(const scalar_type& start, const scalar_type& stop, Visitor visitor) const {
    if (empty() || start >= stop) {
      return;
    }
    visit_overlapping_impl(start, stop, visitor);
  }

  /**
   * @brief Visits all intervals that are completely contained within a query interval.
   * @pre `start <= stop`.
   */
  template <typename Visitor>
  void visit_contained(const scalar_type& start, const scalar_type& stop, Visitor visitor) const {
    if (empty() || start >= stop) {
      return;
    }
    visit_contained_impl(start, stop, visitor);
  }

  template <typename Visitor> void visit_all(Visitor visitor) const {
    if (left_) {
      left_->visit_all(visitor);
    }
    for (const auto& interval : intervals_by_start_) {
      visitor(interval);
    }
    if (right_) {
      right_->visit_all(visitor);
    }
  }

  [[nodiscard]] bool empty() const noexcept { return size_ == 0; }

  [[nodiscard]] size_type size() const noexcept { return size_; }

private:
  scalar_type center_{};
  size_type size_ = 0;
  std::vector<interval_type> intervals_by_start_;
  std::vector<interval_type> intervals_by_stop_;
  std::unique_ptr<interval_tree> left_ = nullptr;
  std::unique_ptr<interval_tree> right_ = nullptr;

  interval_tree(std::vector<interval_type>&& intervals, size_type depth) {
    size_ = intervals.size();
    build_tree(std::move(intervals), depth);
  }

  void build_tree(std::vector<interval_type>&& intervals, size_type depth);

  template <typename Visitor> void visit_point_impl(const scalar_type& point, Visitor& visitor) const;

  template <typename Visitor>
  void visit_overlapping_impl(const scalar_type& query_start, const scalar_type& query_stop, Visitor& visitor) const;

  template <typename Visitor>
  void visit_contained_impl(const scalar_type& query_start, const scalar_type& query_stop, Visitor& visitor) const;
};

template <typename S, typename V>
void interval_tree<S, V>::build_tree(std::vector<interval_type>&& intervals, size_type depth) {
  if (depth >= MAX_DEPTH || intervals.size() <= LEAF_NODE_THRESHOLD) {
    intervals_by_start_ = std::move(intervals);
    std::sort(intervals_by_start_.begin(), intervals_by_start_.end(), [](const auto& a, const auto& b) {
      return a.start < b.start;
    });
    intervals_by_stop_ = intervals_by_start_;
    std::sort(intervals_by_stop_.begin(), intervals_by_stop_.end(), [](const auto& a, const auto& b) {
      return a.stop < b.stop;
    });
    return;
  }

  std::vector<scalar_type> coords;
  coords.reserve(intervals.size() * 2);
  for (const auto& i : intervals) {
    coords.push_back(i.start);
    coords.push_back(i.stop);
  }
  auto median_it = coords.begin() + coords.size() / 2;
  std::nth_element(coords.begin(), median_it, coords.end());
  center_ = *median_it;

  std::vector<interval_type> left_intervals;
  std::vector<interval_type> right_intervals;

  for (auto& interval : intervals) {
    if (interval.stop < center_) {
      left_intervals.push_back(std::move(interval));
    } else if (interval.start > center_) {
      right_intervals.push_back(std::move(interval));
    } else {
      intervals_by_start_.push_back(std::move(interval));
    }
  }
  intervals.clear();

  std::sort(intervals_by_start_.begin(), intervals_by_start_.end(), [](const auto& a, const auto& b) {
    return a.start < b.start;
  });
  intervals_by_stop_ = intervals_by_start_;
  std::sort(intervals_by_stop_.begin(), intervals_by_stop_.end(), [](const auto& a, const auto& b) {
    return a.stop < b.stop;
  });

  if (!left_intervals.empty()) {
    left_.reset(new interval_tree(std::move(left_intervals), depth + 1));
  }
  if (!right_intervals.empty()) {
    right_.reset(new interval_tree(std::move(right_intervals), depth + 1));
  }
}

template <typename S, typename V>
template <typename Visitor>
void interval_tree<S, V>::visit_point_impl(const scalar_type& point, Visitor& visitor) const {
  for (const auto& interval : intervals_by_start_) {
    if (interval.start > point) {
      break;
    }
    if (interval.stop > point) {
      visitor(interval);
    }
  }

  if (left_ && point < center_) {
    left_->visit_point_impl(point, visitor);
  }
  if (right_ && point >= center_) {
    right_->visit_point_impl(point, visitor);
  }
}

template <typename S, typename V>
template <typename Visitor>
void interval_tree<S, V>::visit_overlapping_impl(
    const scalar_type& query_start, const scalar_type& query_stop, Visitor& visitor
) const {
  for (const auto& interval : intervals_by_start_) {
    if (interval.start >= query_stop) {
      break;
    }
    // the interval must not be empty (start < stop) for it to overlap.
    if (interval.stop > query_start && interval.start < interval.stop) {
      visitor(interval);
    }
  }

  if (left_ && query_start < center_) {
    left_->visit_overlapping_impl(query_start, query_stop, visitor);
  }
  if (right_ && query_stop > center_) {
    right_->visit_overlapping_impl(query_start, query_stop, visitor);
  }
}

template <typename S, typename V>
template <typename Visitor>
void interval_tree<S, V>::visit_contained_impl(
    const scalar_type& query_start, const scalar_type& query_stop, Visitor& visitor
) const {
  for (const auto& interval : intervals_by_start_) {
    if (interval.start >= query_stop) {
      break;
    }
    if (interval.start >= query_start && interval.stop <= query_stop) {
      visitor(interval);
    }
  }

  if (left_ && query_start < center_) {
    left_->visit_contained_impl(query_start, query_stop, visitor);
  }
  if (right_ && query_stop > center_) {
    right_->visit_contained_impl(query_start, query_stop, visitor);
  }
}

} // namespace interval_tree
```

`src/w1tn3ss/util/jsonl_writer.cpp`:

```cpp
#include "jsonl_writer.hpp"

#include <algorithm>
#include <cstring>

namespace w1::util {

jsonl_writer::jsonl_writer(const std::string& path)
    : buffer_size_(DEFAULT_BUFFER_SIZE), flush_event_count_(DEFAULT_FLUSH_EVENT_COUNT) {
  buffer_.reserve(buffer_size_);

  if (!path.empty()) {
    open(path);
  }
}

jsonl_writer::~jsonl_writer() { close(); }

bool jsonl_writer::open(const std::string& path) {
  std::lock_guard<std::mutex> lock(write_mutex_);

  // close existing file if open
  if (file_.is_open()) {
    flush_internal();
    file_.close();
  }

  // reset state
  buffer_pos_ = 0;
  event_count_ = 0;
  flush_count_ = 0;
  bytes_written_ = 0;

  // open new file
  file_.open(path, std::ios::out | std::ios::binary);
  return file_.is_open();
}

bool jsonl_writer::write_line(const std::string& json) {
  // ensure json doesn't already have newline
  size_t len = json.length();
  bool needs_newline = (len == 0 || json[len - 1] != '\n');

  size_t required = len + (needs_newline ? 1 : 0);

  std::lock_guard<std::mutex> lock(write_mutex_);

  if (!file_.is_open()) {
    return false;
  }

  ensure_capacity(required);

  // copy json to buffer
  std::memcpy(buffer_.data() + buffer_pos_, json.data(), len);
  buffer_pos_ += len;

  // add newline if needed
  if (needs_newline) {
    buffer_[buffer_pos_++] = '\n';
  }

  event_count_++;

  // check if we should flush based on event count
  if (event_count_ % flush_event_count_ == 0) {
    flush_internal();
  }

  return true;
}

bool jsonl_writer::write_raw(const char* data, size_t len) {
  std::lock_guard<std::mutex> lock(write_mutex_);

  if (!file_.is_open() || !data || len == 0) {
    return false;
  }

  ensure_capacity(len);

  std::memcpy(buffer_.data() + buffer_pos_, data, len);
  buffer_pos_ += len;

  // count newlines as events
  size_t newline_count = std::count(data, data + len, '\n');
  event_count_ += newline_count;

  // check if we should flush
  if (newline_count > 0 && event_count_ % flush_event_count_ < newline_count) {
    flush_internal();
  }

  return true;
}

void jsonl_writer::flush() {
  std::lock_guard<std::mutex> lock(write_mutex_);
  flush_internal();
}

void jsonl_writer::close() {
  std::lock_guard<std::mutex> lock(write_mutex_);

  if (file_.is_open()) {
    flush_internal();
    file_.close();
  }
}

void jsonl_writer::ensure_capacity(size_t required) {
  // if adding required bytes would exceed buffer, flush first
  if (buffer_pos_ + required > buffer_size_) {
    flush_internal();
  }

  // if single item is larger than entire buffer, write directly
  if (required > buffer_size_) {
    if (buffer_pos_ > 0) {
      flush_internal();
    }
    // this item will be written directly in the next flush
  }
}

void jsonl_writer::flush_internal() {
  if (!file_.is_open() || buffer_pos_ == 0) {
    return;
  }

  file_.write(buffer_.data(), buffer_pos_);
  file_.flush();

  bytes_written_ += buffer_pos_;
  buffer_pos_ = 0;
  flush_count_++;
}

} // namespace w1::util
```

`src/w1tn3ss/util/jsonl_writer.hpp`:

```hpp
#pragma once

#include <atomic>
#include <fstream>
#include <memory>
#include <mutex>
#include <string>
#include <vector>

namespace w1::util {

// elegant jsonl writer with automatic event-based flushing
// designed for high-performance streaming of json lines format
class jsonl_writer {
public:
  // sensible defaults
  static constexpr size_t DEFAULT_BUFFER_SIZE = 64 * 1024 * 1024;
  static constexpr size_t DEFAULT_FLUSH_EVENT_COUNT = 1000000;

  // constructor opens file immediately if path is provided
  explicit jsonl_writer(const std::string& path = "");
  ~jsonl_writer();

  // open a file for writing (closes any existing file)
  bool open(const std::string& path);

  // check if writer is ready to accept data
  bool is_open() const { return file_.is_open(); }

  // write a json string as a complete line
  // returns false if write failed (e.g., file not open)
  bool write_line(const std::string& json);

  // write raw data (caller ensures it ends with newline)
  bool write_raw(const char* data, size_t len);

  // force flush of buffered data to disk
  void flush();

  // close file and flush any remaining data
  void close();

  // get current statistics
  size_t get_event_count() const { return event_count_; }
  size_t get_flush_count() const { return flush_count_; }
  size_t get_bytes_written() const { return bytes_written_; }

private:
  // internal buffer management
  void ensure_capacity(size_t required);
  void flush_internal();

  // file handle
  std::ofstream file_;
  std::mutex write_mutex_;

  // buffering
  std::vector<char> buffer_;
  size_t buffer_pos_ = 0;
  const size_t buffer_size_;
  const size_t flush_event_count_;

  // statistics
  std::atomic<size_t> event_count_{0};
  std::atomic<size_t> flush_count_{0};
  std::atomic<size_t> bytes_written_{0};
};

} // namespace w1::util
```

`src/w1tn3ss/util/memory_range_index.cpp`:

```cpp
#include "memory_range_index.hpp"
#include <QBDI/Memory.h>
#include <redlog.hpp>

namespace w1::util {

bool memory_range_index::check_access(QBDI::rword address, size_t size, access_type type) const {
  // Fast path: check against cached mappings
  {
    std::shared_lock lock(mutex_);
    if (initialized_ && check_access_internal(address, size, type)) {
      return true;
    }
  }

  // Slow path: refresh and try again (with rate limiting)
  auto now = std::chrono::steady_clock::now();
  if (now - last_refresh_ > min_refresh_interval) {
    refresh_internal();
  }

  std::shared_lock lock(mutex_);
  return check_access_internal(address, size, type);
}

bool memory_range_index::check_access_internal(QBDI::rword address, size_t size, uint32_t perms) const {
  if (size == 0) {
    return true;
  }

  QBDI::rword end = address + size - 1;

  // Check for overflow
  if (end < address) {
    return false;
  }

  // Check if entire range is covered by regions with required permissions
  QBDI::rword current = address;

  while (current <= end) {
    bool found = false;
    QBDI::rword next_check = current;

    tree_.visit_overlapping(current, [&](const memory_interval& interval) {
      if ((interval.value.permissions & perms) == perms) {
        found = true;
        // Move current to end of this region
        next_check = interval.value.end;
        return false; // Stop searching
      }
      return true; // Continue searching
    });

    if (!found) {
      return false;
    }

    // Move to next unchecked byte
    if (next_check >= end) {
      break;
    }
    current = next_check + 1;
  }

  return true;
}

const memory_region* memory_range_index::find_region(QBDI::rword address) const {
  std::shared_lock lock(mutex_);

  if (!initialized_) {
    lock.unlock();
    refresh_internal();
    lock.lock();
  }

  const memory_region* result = nullptr;
  tree_.visit_overlapping(address, [&](const memory_interval& interval) {
    result = &interval.value;
    return false; // Stop on first match
  });

  return result;
}

void memory_range_index::refresh() { refresh_internal(); }

bool memory_range_index::empty() const {
  std::shared_lock lock(mutex_);
  return tree_.empty();
}

void memory_range_index::refresh_internal() const {

  size_t map_count = 0;
  QBDI::qbdi_MemoryMap* maps = QBDI::qbdi_getCurrentProcessMaps(true, &map_count);

  if (!maps) {
    log_.err("failed to get process memory maps");
    return;
  }

  std::vector<memory_interval> intervals;
  intervals.reserve(map_count);

  for (size_t i = 0; i < map_count; ++i) {
    memory_region region{
        maps[i].start, maps[i].end, static_cast<uint32_t>(maps[i].permission), maps[i].name ? maps[i].name : ""
    };

    intervals.emplace_back(region.start, region.end, std::move(region));
  }

  QBDI::qbdi_freeMemoryMapArray(maps, map_count);

  // Build new tree (need write lock)
  std::unique_lock lock(mutex_);
  tree_ = interval_tree::interval_tree<QBDI::rword, memory_region>(
      std::make_move_iterator(intervals.begin()), std::make_move_iterator(intervals.end())
  );
  initialized_ = true;
  last_refresh_ = std::chrono::steady_clock::now();

  log_.dbg("refreshed memory maps", redlog::field("regions", map_count));
}

} // namespace w1::util
```

`src/w1tn3ss/util/memory_range_index.hpp`:

```hpp
#pragma once

#include <QBDI.h>
#include <QBDI/Memory.hpp>
#include "interval_tree.hpp"
#include <chrono>
#include <mutex>
#include <shared_mutex>
#include <vector>
#include <redlog.hpp>

namespace w1::util {

// Memory region information
struct memory_region {
  QBDI::rword start;
  QBDI::rword end;
  uint32_t permissions; // QBDI::PF_READ, QBDI::PF_WRITE, QBDI::PF_EXEC
  std::string name;     // Module name if applicable
};

// Fast memory range validation using interval tree
class memory_range_index {
public:
  using memory_interval = interval_tree::interval<QBDI::rword, memory_region>;

  enum access_type { READ = QBDI::PF_READ, WRITE = QBDI::PF_WRITE, EXEC = QBDI::PF_EXEC };

  memory_range_index() : log_("w1.memory_range_index") {}

  // Main API: Check if access would succeed
  // If check fails, automatically refreshes mappings and tries again
  bool check_access(QBDI::rword address, size_t size, access_type type) const;

  // Find region containing address
  const memory_region* find_region(QBDI::rword address) const;

  // Force refresh of memory mappings
  void refresh();

  // Check if we have any mappings loaded
  bool empty() const;

private:
  mutable std::shared_mutex mutex_;
  mutable interval_tree::interval_tree<QBDI::rword, memory_region> tree_;
  mutable bool initialized_ = false;
  mutable std::chrono::steady_clock::time_point last_refresh_;
  static constexpr auto min_refresh_interval = std::chrono::milliseconds(100);
  redlog::logger log_;

  // Check access without refresh
  bool check_access_internal(QBDI::rword address, size_t size, uint32_t perms) const;

  // Internal refresh
  void refresh_internal() const;
};

} // namespace w1::util
```

`src/w1tn3ss/util/module_info.hpp`:

```hpp
#pragma once

#include <string>
#include <QBDI.h>

namespace w1 {
namespace util {

enum class module_type { UNKNOWN, MAIN_EXECUTABLE, SHARED_LIBRARY, ANONYMOUS_EXECUTABLE };

struct module_info {
  std::string path; // path to the file on disk, if available
  std::string name; // module basename
  QBDI::rword base_address;
  size_t size;
  module_type type;
  bool is_system_library; // determined by platform-specific heuristics.
};

} // namespace util
} // namespace w1
```

`src/w1tn3ss/util/module_range_index.cpp`:

```cpp
#include "module_range_index.hpp"
#include <algorithm>
#include <iterator>

namespace w1 {
namespace util {

module_range_index::module_range_index(std::vector<module_info> modules) { rebuild_internal(std::move(modules)); }

const module_info* module_range_index::find_containing(QBDI::rword address) const noexcept {
  std::shared_lock<std::shared_mutex> lock(index_mutex_);

  const module_info* result = nullptr;
  tree_.visit_overlapping(address, [&](const module_interval& interval) {
    result = &interval.value;
    return false; // early termination
  });

  return result;
}

const module_info* module_range_index::find_by_name(const std::string& name) const noexcept {
  std::shared_lock<std::shared_mutex> lock(index_mutex_);

  auto it = name_index_.find(name);
  return (it != name_index_.end()) ? it->second : nullptr;
}

bool module_range_index::empty() const noexcept {
  std::shared_lock<std::shared_mutex> lock(index_mutex_);
  return tree_.empty();
}

size_t module_range_index::size() const noexcept {
  std::shared_lock<std::shared_mutex> lock(index_mutex_);
  return tree_.size();
}

void module_range_index::rebuild_from_modules(std::vector<module_info> modules) {
  std::unique_lock<std::shared_mutex> lock(index_mutex_);
  rebuild_internal(std::move(modules));
}

std::unordered_set<QBDI::rword> module_range_index::get_known_module_bases() const {
  std::shared_lock<std::shared_mutex> lock(index_mutex_);

  std::unordered_set<QBDI::rword> known_bases;
  known_bases.reserve(tree_.size());

  tree_.visit_all([&](const module_interval& interval) { known_bases.insert(interval.value.base_address); });

  return known_bases;
}

void module_range_index::build_name_index() {
  name_index_.clear();
  name_index_.reserve(tree_.size());

  tree_.visit_all([&](const module_interval& interval) {
    const module_info& mod = interval.value;
    if (!mod.name.empty()) {
      name_index_[mod.name] = &mod;
    }
  });
}

void module_range_index::rebuild_internal(std::vector<module_info> modules) {
  if (modules.empty()) {
    tree_ = interval_tree::interval_tree<QBDI::rword, module_info>();
    name_index_.clear();
    return;
  }

  // build intervals for tree construction
  std::vector<module_interval> intervals;
  intervals.reserve(modules.size());

  for (auto& mod : modules) {
    intervals.emplace_back(mod.base_address, mod.base_address + mod.size, std::move(mod));
  }

  // construct tree with move semantics
  tree_ = interval_tree::interval_tree<QBDI::rword, module_info>(
      std::make_move_iterator(intervals.begin()), std::make_move_iterator(intervals.end())
  );

  // build name index for fast name lookups
  build_name_index();
}

// template implementations are in the header file for proper linkage

} // namespace util
} // namespace w1
```

`src/w1tn3ss/util/module_range_index.hpp`:

```hpp
#pragma once

#include "module_info.hpp"
#include "module_scanner.hpp"
#include "interval_tree.hpp"
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <shared_mutex>
#include <mutex>
#include <type_traits>
#include <QBDI.h>
#include <redlog.hpp>

namespace w1 {
namespace util {

/**
 * @brief fast address-to-module lookup using interval tree with dynamic rescanning
 * @details thread-safe for concurrent reads, supports dynamic module updates.
 * optimized for point queries with o(log n + k) complexity where k is typically 1.
 * hot path (visit_containing) is zero-allocation with minimal locking.
 */
class module_range_index {
public:
  /**
   * @brief construct empty index
   */
  module_range_index() = default;

  /**
   * @brief construct index from vector of modules
   * @param modules vector of module_info objects to index
   * @details sorts modules and builds interval tree. construction is o(n log n).
   */
  explicit module_range_index(std::vector<module_info> modules);

  /**
   * @brief find module containing the given address (hot path)
   * @param address memory address to query
   * @return pointer to module_info if found, nullptr otherwise
   * @note this method is noexcept and thread-safe, no logging
   */
  const module_info* find_containing(QBDI::rword address) const noexcept;

  /**
   * @brief visit module containing the given address using visitor pattern (hot path)
   * @param address memory address to query
   * @param visitor callable invoked with const module_info& if found
   * @return true if module found and visitor called, false otherwise
   * @note zero-allocation hot path optimization, no logging
   */
  template <typename Visitor> bool visit_containing(QBDI::rword address, Visitor&& visitor) const;

  /**
   * @brief attempt rescanning and visit module at address (cold path)
   * @param address memory address to query
   * @param scanner module scanner to use for rescanning
   * @param visitor callable invoked with const module_info& if found
   * @return true if module found after rescanning, false otherwise
   * @note non-blocking, with logging and comprehensive error handling
   */
  template <typename Visitor>
  bool try_rescan_and_visit(QBDI::rword address, module_scanner& scanner, Visitor&& visitor);

  /**
   * @brief rebuild index from new module list
   * @param modules new vector of modules to index
   * @details thread-safe, atomically replaces current index
   */
  void rebuild_from_modules(std::vector<module_info> modules);

  /**
   * @brief get set of all known module base addresses
   * @return unordered_set of base addresses
   */
  std::unordered_set<QBDI::rword> get_known_module_bases() const;

  /**
   * @brief visit all modules in the index
   * @param visitor callable invoked with const module_info& for each module
   */
  template <typename Visitor> void visit_all(Visitor&& visitor) const;

  /**
   * @brief find module by name (exact match)
   * @param name module name to search for
   * @return pointer to module_info if found, nullptr otherwise
   */
  const module_info* find_by_name(const std::string& name) const noexcept;

  /**
   * @brief check if index is empty
   * @return true if no modules indexed
   */
  bool empty() const noexcept;

  /**
   * @brief get number of indexed modules
   * @return count of modules in index
   */
  size_t size() const noexcept;

private:
  using module_interval = interval_tree::interval<QBDI::rword, module_info>;
  interval_tree::interval_tree<QBDI::rword, module_info> tree_;

  // name-based lookup cache
  std::unordered_map<std::string, const module_info*> name_index_;

  // thread safety - shared for reads, exclusive for updates
  mutable std::shared_mutex index_mutex_;
  mutable std::mutex rescan_mutex_;

  redlog::logger log_{"w1.module_range_index"};

  void build_name_index();
  void rebuild_internal(std::vector<module_info> modules);
};

template <typename Visitor> bool module_range_index::visit_containing(QBDI::rword address, Visitor&& visitor) const {
  static_assert(std::is_invocable_v<Visitor, const module_info&>, "visitor must be callable with const module_info&");

  std::shared_lock<std::shared_mutex> lock(index_mutex_);

  bool found = false;
  tree_.visit_overlapping(address, [&](const module_interval& interval) {
    visitor(interval.value);
    found = true;
    return false; // early termination after first match
  });

  return found;
}

template <typename Visitor>
bool module_range_index::try_rescan_and_visit(QBDI::rword address, module_scanner& scanner, Visitor&& visitor) {
  static_assert(std::is_invocable_v<Visitor, const module_info&>, "visitor must be callable with const module_info&");

  // non-blocking attempt to acquire rescan lock
  std::unique_lock<std::mutex> rescan_lock(rescan_mutex_, std::try_to_lock);
  if (!rescan_lock.owns_lock()) {
    log_.dbg("rescan already in progress, skipping", redlog::field("address", "0x%08x", address));
    return false;
  }

  log_.vrb("attempting module rescan", redlog::field("address", "0x%08x", address));

  try {
    // scan for new modules only
    auto known_bases = get_known_module_bases();
    auto new_modules = scanner.scan_new_modules(known_bases);

    if (new_modules.empty()) {
      log_.dbg("no new modules discovered during rescan");
      return false;
    }

    // rebuild complete index with all current modules
    auto all_current_modules = scanner.scan_executable_modules();
    rebuild_from_modules(std::move(all_current_modules));

    log_.inf(
        "rescan completed successfully", redlog::field("new_modules", new_modules.size()),
        redlog::field("total_modules", size())
    );

    // try the lookup again with updated index
    return visit_containing(address, std::forward<Visitor>(visitor));

  } catch (const std::exception& e) {
    log_.err("exception during module rescan", redlog::field("error", e.what()));
    return false;
  }
}

template <typename Visitor> void module_range_index::visit_all(Visitor&& visitor) const {
  static_assert(std::is_invocable_v<Visitor, const module_info&>, "visitor must be callable with const module_info&");
  std::shared_lock<std::shared_mutex> lock(index_mutex_);
  tree_.visit_all([&](const module_interval& interval) { visitor(interval.value); });
}

} // namespace util
} // namespace w1
```

`src/w1tn3ss/util/module_scanner.cpp`:

```cpp
#include "module_scanner.hpp"
#include <algorithm>
#include <cstdio>

namespace w1 {
namespace util {

module_scanner::module_scanner() {}

std::vector<module_info> module_scanner::scan_executable_modules() {
  log_.vrb("scanning executable modules");

  std::vector<module_info> modules;

  try {
    auto maps = get_executable_maps();
    modules.reserve(maps.size());

    for (const auto& map : maps) {
      modules.push_back(build_module_info(map));
    }

    log_.inf("module scan complete", redlog::field("executable_modules", modules.size()));
  } catch (const std::exception& e) {
    log_.err("failed to scan executable modules", redlog::field("error", e.what()));
    return {};
  }

  return modules;
}

std::vector<module_info> module_scanner::scan_user_modules() const {
  // we need to bypass the const issue here - scan is read-only but log_ is mutable
  auto& mutable_log = const_cast<redlog::logger&>(log_);
  auto& mutable_scanner = const_cast<module_scanner&>(*this);

  auto all_modules = mutable_scanner.scan_executable_modules();

  std::vector<module_info> user_modules;
  user_modules.reserve(all_modules.size() / 2); // estimate

  std::copy_if(all_modules.begin(), all_modules.end(), std::back_inserter(user_modules), [](const module_info& mod) {
    return !mod.is_system_library;
  });

  mutable_log.dbg(
      "user module filter applied", redlog::field("total_modules", all_modules.size()),
      redlog::field("user_modules", user_modules.size())
  );

  return user_modules;
}

std::vector<module_info> module_scanner::scan_new_modules(const std::unordered_set<QBDI::rword>& known_bases) {
  log_.vrb("scanning for new modules", redlog::field("known_modules", known_bases.size()));

  auto all_modules = scan_executable_modules();

  std::vector<module_info> new_modules;
  new_modules.reserve(all_modules.size() / 4); // estimate fewer new modules

  std::copy_if(
      all_modules.begin(), all_modules.end(), std::back_inserter(new_modules),
      [&known_bases](const module_info& mod) { return known_bases.find(mod.base_address) == known_bases.end(); }
  );

  log_.dbg(
      "new module scan complete", redlog::field("total_modules", all_modules.size()),
      redlog::field("new_modules", new_modules.size())
  );

  return new_modules;
}

std::vector<QBDI::MemoryMap> module_scanner::get_executable_maps() {
  auto all_maps = QBDI::getCurrentProcessMaps(false);

  std::vector<QBDI::MemoryMap> exec_maps;
  exec_maps.reserve(all_maps.size() / 4); // estimate executable fraction

  std::copy_if(all_maps.begin(), all_maps.end(), std::back_inserter(exec_maps), [](const QBDI::MemoryMap& map) {
    return map.permission & QBDI::PF_EXEC;
  });

  log_.trc(
      "filtered executable maps", redlog::field("total_maps", all_maps.size()),
      redlog::field("executable_maps", exec_maps.size())
  );

  return exec_maps;
}

module_info module_scanner::build_module_info(const QBDI::MemoryMap& map) {
  module_info info;
  info.path = map.name;
  info.base_address = map.range.start();
  info.size = map.range.end() - map.range.start();
  info.type = classify_module(map);
  info.is_system_library = is_system_library(map.name);

  // generate meaningful name for unnamed modules
  if (map.name.empty()) {
    char unnamed_buf[32];
    snprintf(unnamed_buf, sizeof(unnamed_buf), "_unnamed_0x%08llx", static_cast<unsigned long long>(info.base_address));
    info.name = unnamed_buf;
    info.path = info.name;
  } else {
    info.name = extract_basename(map.name);
  }

  log_.ped(
      "built module info", redlog::field("name", info.name), redlog::field("path", info.path),
      redlog::field("base_address", "0x%08x", info.base_address), redlog::field("size", "0x%08x", info.size),
      redlog::field("type", static_cast<int>(info.type)), redlog::field("is_system", info.is_system_library)
  );

  return info;
}

module_type module_scanner::classify_module(const QBDI::MemoryMap& map) const {
  if (map.name.empty()) {
    return module_type::ANONYMOUS_EXECUTABLE;
  }

  const std::string& name = map.name;

  // check for shared libraries by extension
#ifdef __APPLE__
  if (name.find(".dylib") != std::string::npos) {
    return module_type::SHARED_LIBRARY;
  }
#elif defined(__linux__)
  if (name.find(".so") != std::string::npos) {
    return module_type::SHARED_LIBRARY;
  }
#elif defined(_WIN32)
  if (name.find(".dll") != std::string::npos) {
    return module_type::SHARED_LIBRARY;
  }
#endif

  // everything else with a name is likely a main executable
  return module_type::MAIN_EXECUTABLE;
}

bool module_scanner::is_system_library(const std::string& path) const {
  if (path.empty()) {
    return false;
  }

#ifdef __APPLE__
  // check for full paths
  if (path.find("/usr/lib/") == 0 || path.find("/System/Library/") == 0 || path.find("/Library/") == 0) {
    return true;
  }
  // check for system library names (when loaded from dyld shared cache)
  if (path.find("libsystem") == 0 || path.find("libc++") == 0 || path.find("libobjc") == 0 ||
      path.find("libdispatch") == 0 || path.find("libxpc") == 0 || path.find("libcorecrypto") == 0 ||
      path.find("libcompiler_rt") == 0 || path.find("libdyld") == 0 || path.find("dyld") == 0 ||
      path.find("libquarantine") == 0 || path.find("libmacho") == 0 || path.find("libcommonCrypto") == 0 ||
      path.find("libunwind") == 0 || path.find("libcopyfile") == 0 || path.find("libremovefile") == 0 ||
      path.find("libkeymgr") == 0 || path.find("libcache") == 0 || path.find("libSystem") == 0) {
    return true;
  }
  return false;
#elif defined(__linux__)
  return (
      path.find("/lib/") == 0 || path.find("/usr/lib/") == 0 || path.find("/lib64/") == 0 ||
      path.find("/usr/lib64/") == 0
  );
#elif defined(_WIN32)
  std::string lower_path = path;
  std::transform(lower_path.begin(), lower_path.end(), lower_path.begin(), ::tolower);
  return (
      lower_path.find("c:\\windows\\") == 0 || lower_path.find("c:\\program files\\") == 0 ||
      lower_path.find("c:\\program files (x86)\\") == 0
  );
#else
  return false;
#endif
}

std::string module_scanner::extract_basename(const std::string& path) const {
  if (path.empty()) {
    return path;
  }

  size_t pos = path.find_last_of("/\\");
  if (pos != std::string::npos) {
    return path.substr(pos + 1);
  }

  return path;
}

} // namespace util
} // namespace w1
```

`src/w1tn3ss/util/module_scanner.hpp`:

```hpp
#pragma once

#include "module_info.hpp"
#include <vector>
#include <unordered_set>
#include <functional>
#include <QBDI.h>
#include <redlog.hpp>

namespace w1 {
namespace util {

/**
 * @brief stateless utility for discovering modules from system memory maps
 * @details handles platform-specific qbdi interaction and module classification.
 * thread-safe for concurrent use. no internal state maintained.
 */
class module_scanner {
public:
  module_scanner();

  /**
   * @brief scan all executable modules from current process
   * @return vector of discovered executable modules
   */
  std::vector<module_info> scan_executable_modules();

  /**
   * @brief scan only user (non-system) executable modules
   * @return vector of user modules, filtered by platform-specific heuristics
   */
  std::vector<module_info> scan_user_modules() const;

  /**
   * @brief incremental scan for modules not in known set
   * @param known_bases set of already-known module base addresses
   * @return vector of newly discovered modules
   * @details useful for rescanning without full discovery overhead
   */
  std::vector<module_info> scan_new_modules(const std::unordered_set<QBDI::rword>& known_bases);

private:
  redlog::logger log_{"w1.module_scanner"};

  // platform-specific helpers
  std::vector<QBDI::MemoryMap> get_executable_maps();
  module_info build_module_info(const QBDI::MemoryMap& map);
  module_type classify_module(const QBDI::MemoryMap& map) const;
  bool is_system_library(const std::string& path) const;
  std::string extract_basename(const std::string& path) const;
};

} // namespace util
} // namespace w1
```

`src/w1tn3ss/util/register_access.hpp`:

```hpp
#pragma once

#include <QBDI.h>
#include <cstdint>
#include <optional>
#include <type_traits>

// architectural register access utilities
// this provides platform-aware access to cpu registers that exist
// at the hardware/architecture level, independent of any calling convention
//
// this file should only contain:
// - program counter (pc/rip/eip) - architectural control flow register
// - stack pointer (sp/rsp/esp) - architectural stack register
// - direct register access by architectural name (rax, x0, etc)
//
// this file must not contain:
// - return value registers (abi-specific)
// - argument registers (abi-specific)
// - frame pointer (usage is abi-specific)
// - any calling convention assumptions
//
// for abi-aware operations, use the calling convention layer

namespace w1::registers {

// zero-cost platform-aware accessors for common registers
inline QBDI::rword get_pc(const QBDI::GPRState* gpr) {
#if defined(QBDI_ARCH_X86_64)
  return gpr->rip;
#elif defined(QBDI_ARCH_AARCH64)
  return gpr->pc;
#elif defined(QBDI_ARCH_ARM)
  return gpr->pc;
#elif defined(QBDI_ARCH_X86)
  return gpr->eip;
#else
  static_assert(false, "unsupported architecture");
#endif
}

inline QBDI::rword get_sp(const QBDI::GPRState* gpr) {
#if defined(QBDI_ARCH_X86_64)
  return gpr->rsp;
#elif defined(QBDI_ARCH_AARCH64)
  return gpr->sp;
#elif defined(QBDI_ARCH_ARM)
  return gpr->sp;
#elif defined(QBDI_ARCH_X86)
  return gpr->esp;
#else
  static_assert(false, "unsupported architecture");
#endif
}

// type-safe register enumeration
enum class reg : uint8_t {
  // architectural registers only
  pc,
  sp,

// platform-specific names also available
#if defined(QBDI_ARCH_X86_64)
  rax,
  rbx,
  rcx,
  rdx,
  rsi,
  rdi,
  rbp,
  rsp,
  r8,
  r9,
  r10,
  r11,
  r12,
  r13,
  r14,
  r15,
  rip
#elif defined(QBDI_ARCH_AARCH64)
  x0,
  x1,
  x2,
  x3,
  x4,
  x5,
  x6,
  x7,
  x8,
  x9,
  x10,
  x11,
  x12,
  x13,
  x14,
  x15,
  x16,
  x17,
  x18,
  x19,
  x20,
  x21,
  x22,
  x23,
  x24,
  x25,
  x26,
  x27,
  x28,
  x29,
  lr
#elif defined(QBDI_ARCH_ARM)
  r0,
  r1,
  r2,
  r3,
  r4,
  r5,
  r6,
  r7,
  r8,
  r9,
  r10,
  r11,
  r12,
  r13,
  r14,
  r15
#elif defined(QBDI_ARCH_X86)
  eax,
  ebx,
  ecx,
  edx,
  esi,
  edi,
  ebp,
  esp,
  eip
#endif
};

// compile-time register access
template <reg R> inline QBDI::rword get(const QBDI::GPRState* gpr) {
  if constexpr (R == reg::pc) {
    return get_pc(gpr);
  } else if constexpr (R == reg::sp) {
    return get_sp(gpr);
  }
#if defined(QBDI_ARCH_X86_64)
  else if constexpr (R == reg::rax) {
    return gpr->rax;
  } else if constexpr (R == reg::rbx) {
    return gpr->rbx;
  } else if constexpr (R == reg::rcx) {
    return gpr->rcx;
  } else if constexpr (R == reg::rdx) {
    return gpr->rdx;
  } else if constexpr (R == reg::rsi) {
    return gpr->rsi;
  } else if constexpr (R == reg::rdi) {
    return gpr->rdi;
  } else if constexpr (R == reg::rbp) {
    return gpr->rbp;
  } else if constexpr (R == reg::rsp) {
    return gpr->rsp;
  } else if constexpr (R == reg::r8) {
    return gpr->r8;
  } else if constexpr (R == reg::r9) {
    return gpr->r9;
  } else if constexpr (R == reg::r10) {
    return gpr->r10;
  } else if constexpr (R == reg::r11) {
    return gpr->r11;
  } else if constexpr (R == reg::r12) {
    return gpr->r12;
  } else if constexpr (R == reg::r13) {
    return gpr->r13;
  } else if constexpr (R == reg::r14) {
    return gpr->r14;
  } else if constexpr (R == reg::r15) {
    return gpr->r15;
  } else if constexpr (R == reg::rip) {
    return gpr->rip;
  }
#elif defined(QBDI_ARCH_AARCH64)
  else if constexpr (R == reg::x0) {
    return gpr->x0;
  } else if constexpr (R == reg::x1) {
    return gpr->x1;
  } else if constexpr (R == reg::x2) {
    return gpr->x2;
  } else if constexpr (R == reg::x3) {
    return gpr->x3;
  } else if constexpr (R == reg::x4) {
    return gpr->x4;
  } else if constexpr (R == reg::x5) {
    return gpr->x5;
  } else if constexpr (R == reg::x6) {
    return gpr->x6;
  } else if constexpr (R == reg::x7) {
    return gpr->x7;
  } else if constexpr (R == reg::x8) {
    return gpr->x8;
  } else if constexpr (R == reg::x9) {
    return gpr->x9;
  } else if constexpr (R == reg::x10) {
    return gpr->x10;
  } else if constexpr (R == reg::x11) {
    return gpr->x11;
  } else if constexpr (R == reg::x12) {
    return gpr->x12;
  } else if constexpr (R == reg::x13) {
    return gpr->x13;
  } else if constexpr (R == reg::x14) {
    return gpr->x14;
  } else if constexpr (R == reg::x15) {
    return gpr->x15;
  } else if constexpr (R == reg::x16) {
    return gpr->x16;
  } else if constexpr (R == reg::x17) {
    return gpr->x17;
  } else if constexpr (R == reg::x18) {
    return gpr->x18;
  } else if constexpr (R == reg::x19) {
    return gpr->x19;
  } else if constexpr (R == reg::x20) {
    return gpr->x20;
  } else if constexpr (R == reg::x21) {
    return gpr->x21;
  } else if constexpr (R == reg::x22) {
    return gpr->x22;
  } else if constexpr (R == reg::x23) {
    return gpr->x23;
  } else if constexpr (R == reg::x24) {
    return gpr->x24;
  } else if constexpr (R == reg::x25) {
    return gpr->x25;
  } else if constexpr (R == reg::x26) {
    return gpr->x26;
  } else if constexpr (R == reg::x27) {
    return gpr->x27;
  } else if constexpr (R == reg::x28) {
    return gpr->x28;
  } else if constexpr (R == reg::x29) {
    return gpr->x29;
  } else if constexpr (R == reg::lr) {
    return gpr->lr;
  }
#elif defined(QBDI_ARCH_ARM)
  else if constexpr (R == reg::r0) {
    return gpr->r0;
  } else if constexpr (R == reg::r1) {
    return gpr->r1;
  } else if constexpr (R == reg::r2) {
    return gpr->r2;
  } else if constexpr (R == reg::r3) {
    return gpr->r3;
  } else if constexpr (R == reg::r4) {
    return gpr->r4;
  } else if constexpr (R == reg::r5) {
    return gpr->r5;
  } else if constexpr (R == reg::r6) {
    return gpr->r6;
  } else if constexpr (R == reg::r7) {
    return gpr->r7;
  } else if constexpr (R == reg::r8) {
    return gpr->r8;
  } else if constexpr (R == reg::r9) {
    return gpr->r9;
  } else if constexpr (R == reg::r10) {
    return gpr->r10;
  } else if constexpr (R == reg::r11) {
    return gpr->r11;
  } else if constexpr (R == reg::r12) {
    return gpr->r12;
  } else if constexpr (R == reg::r13) {
    return gpr->r13;
  } else if constexpr (R == reg::r14) {
    return gpr->r14;
  } else if constexpr (R == reg::r15) {
    return gpr->r15;
  }
#elif defined(QBDI_ARCH_X86)
  else if constexpr (R == reg::eax) {
    return gpr->eax;
  } else if constexpr (R == reg::ebx) {
    return gpr->ebx;
  } else if constexpr (R == reg::ecx) {
    return gpr->ecx;
  } else if constexpr (R == reg::edx) {
    return gpr->edx;
  } else if constexpr (R == reg::esi) {
    return gpr->esi;
  } else if constexpr (R == reg::edi) {
    return gpr->edi;
  } else if constexpr (R == reg::ebp) {
    return gpr->ebp;
  } else if constexpr (R == reg::esp) {
    return gpr->esp;
  } else if constexpr (R == reg::eip) {
    return gpr->eip;
  }
#endif
  else {
    static_assert(std::is_same_v<std::true_type, std::false_type>, "invalid register");
  }
}

// runtime register access when register is not known at compile time
inline QBDI::rword get(const QBDI::GPRState* gpr, reg r) {
  switch (r) {
  case reg::pc:
    return get_pc(gpr);
  case reg::sp:
    return get_sp(gpr);
#if defined(QBDI_ARCH_X86_64)
  case reg::rax:
    return gpr->rax;
  case reg::rbx:
    return gpr->rbx;
  case reg::rcx:
    return gpr->rcx;
  case reg::rdx:
    return gpr->rdx;
  case reg::rsi:
    return gpr->rsi;
  case reg::rdi:
    return gpr->rdi;
  case reg::rbp:
    return gpr->rbp;
  case reg::rsp:
    return gpr->rsp;
  case reg::r8:
    return gpr->r8;
  case reg::r9:
    return gpr->r9;
  case reg::r10:
    return gpr->r10;
  case reg::r11:
    return gpr->r11;
  case reg::r12:
    return gpr->r12;
  case reg::r13:
    return gpr->r13;
  case reg::r14:
    return gpr->r14;
  case reg::r15:
    return gpr->r15;
  case reg::rip:
    return gpr->rip;
#elif defined(QBDI_ARCH_AARCH64)
  case reg::x0:
    return gpr->x0;
  case reg::x1:
    return gpr->x1;
  case reg::x2:
    return gpr->x2;
  case reg::x3:
    return gpr->x3;
  case reg::x4:
    return gpr->x4;
  case reg::x5:
    return gpr->x5;
  case reg::x6:
    return gpr->x6;
  case reg::x7:
    return gpr->x7;
  case reg::x8:
    return gpr->x8;
  case reg::x9:
    return gpr->x9;
  case reg::x10:
    return gpr->x10;
  case reg::x11:
    return gpr->x11;
  case reg::x12:
    return gpr->x12;
  case reg::x13:
    return gpr->x13;
  case reg::x14:
    return gpr->x14;
  case reg::x15:
    return gpr->x15;
  case reg::x16:
    return gpr->x16;
  case reg::x17:
    return gpr->x17;
  case reg::x18:
    return gpr->x18;
  case reg::x19:
    return gpr->x19;
  case reg::x20:
    return gpr->x20;
  case reg::x21:
    return gpr->x21;
  case reg::x22:
    return gpr->x22;
  case reg::x23:
    return gpr->x23;
  case reg::x24:
    return gpr->x24;
  case reg::x25:
    return gpr->x25;
  case reg::x26:
    return gpr->x26;
  case reg::x27:
    return gpr->x27;
  case reg::x28:
    return gpr->x28;
  case reg::x29:
    return gpr->x29;
  case reg::lr:
    return gpr->lr;
#elif defined(QBDI_ARCH_ARM)
  case reg::r0:
    return gpr->r0;
  case reg::r1:
    return gpr->r1;
  case reg::r2:
    return gpr->r2;
  case reg::r3:
    return gpr->r3;
  case reg::r4:
    return gpr->r4;
  case reg::r5:
    return gpr->r5;
  case reg::r6:
    return gpr->r6;
  case reg::r7:
    return gpr->r7;
  case reg::r8:
    return gpr->r8;
  case reg::r9:
    return gpr->r9;
  case reg::r10:
    return gpr->r10;
  case reg::r11:
    return gpr->r11;
  case reg::r12:
    return gpr->r12;
  case reg::r13:
    return gpr->r13;
  case reg::r14:
    return gpr->r14;
  case reg::r15:
    return gpr->r15;
#elif defined(QBDI_ARCH_X86)
  case reg::eax:
    return gpr->eax;
  case reg::ebx:
    return gpr->ebx;
  case reg::ecx:
    return gpr->ecx;
  case reg::edx:
    return gpr->edx;
  case reg::esi:
    return gpr->esi;
  case reg::edi:
    return gpr->edi;
  case reg::ebp:
    return gpr->ebp;
  case reg::esp:
    return gpr->esp;
  case reg::eip:
    return gpr->eip;
#endif
  default:
    return 0;
  }
}

} // namespace w1::registers
```

`src/w1tn3ss/util/register_capture.cpp`:

```cpp
#include "register_capture.hpp"
#include "register_access.hpp"
#include <algorithm>

namespace w1::util {

bool register_state::get_register(const std::string& name, uint64_t& value) const {
  auto it = registers_.find(name);
  if (it != registers_.end()) {
    value = it->second;
    return true;
  }
  return false;
}

uint64_t register_state::get_stack_pointer() const {
  // use architectural names based on platform
#if defined(QBDI_ARCH_X86_64)
  return registers_.at("rsp");
#elif defined(QBDI_ARCH_AARCH64) || defined(QBDI_ARCH_ARM)
  return registers_.at("sp");
#elif defined(QBDI_ARCH_X86)
  return registers_.at("esp");
#else
  return 0;
#endif
}

uint64_t register_state::get_instruction_pointer() const {
  // use architectural names based on platform
#if defined(QBDI_ARCH_X86_64)
  return registers_.at("rip");
#elif defined(QBDI_ARCH_AARCH64) || defined(QBDI_ARCH_ARM)
  return registers_.at("pc");
#elif defined(QBDI_ARCH_X86)
  return registers_.at("eip");
#else
  return 0;
#endif
}

// returns the architectural register commonly used as frame pointer
// note: actual frame pointer usage and semantics are abi-specific
uint64_t register_state::get_frame_pointer() const {
#if defined(QBDI_ARCH_X86_64)
  return registers_.at("rbp");
#elif defined(QBDI_ARCH_AARCH64)
  return registers_.at("x29");
#elif defined(QBDI_ARCH_ARM)
  return registers_.at("r11"); // could also be r7 on some abis
#elif defined(QBDI_ARCH_X86)
  return registers_.at("ebp");
#else
  return 0;
#endif
}

std::vector<std::string> register_state::get_register_names() const {
  std::vector<std::string> names;
  names.reserve(registers_.size());

  for (const auto& [name, _] : registers_) {
    names.push_back(name);
  }

  std::sort(names.begin(), names.end());
  return names;
}

std::unordered_map<std::string, uint64_t> register_state::get_all_registers() const { return registers_; }

// implementation of register_capturer
register_state register_capturer::capture(const QBDI::GPRState* gpr) {
  register_state state;

  if (!gpr) {
    return state;
  }

#if defined(QBDI_ARCH_X86_64)
  capture_x86_64(state, gpr);
#elif defined(QBDI_ARCH_AARCH64)
  capture_aarch64(state, gpr);
#elif defined(QBDI_ARCH_ARM)
  capture_arm32(state, gpr);
#elif defined(QBDI_ARCH_X86)
  capture_x86(state, gpr);
#endif

  return state;
}

void register_capturer::capture_x86_64(register_state& state, const QBDI::GPRState* gpr) {
#if defined(QBDI_ARCH_X86_64)
  state.arch_ = register_state::architecture::X86_64;

  // general purpose registers
  state.registers_["rax"] = gpr->rax;
  state.registers_["rbx"] = gpr->rbx;
  state.registers_["rcx"] = gpr->rcx;
  state.registers_["rdx"] = gpr->rdx;
  state.registers_["rsi"] = gpr->rsi;
  state.registers_["rdi"] = gpr->rdi;
  state.registers_["r8"] = gpr->r8;
  state.registers_["r9"] = gpr->r9;
  state.registers_["r10"] = gpr->r10;
  state.registers_["r11"] = gpr->r11;
  state.registers_["r12"] = gpr->r12;
  state.registers_["r13"] = gpr->r13;
  state.registers_["r14"] = gpr->r14;
  state.registers_["r15"] = gpr->r15;

  // special purpose registers
  state.registers_["rbp"] = gpr->rbp;
  state.registers_["rsp"] = gpr->rsp;
  state.registers_["rip"] = gpr->rip;
  state.registers_["eflags"] = gpr->eflags;
  state.registers_["fs"] = gpr->fs;
  state.registers_["gs"] = gpr->gs;
#else
  // not x86_64 - this should not be called
  state.arch_ = register_state::architecture::UNKNOWN;
#endif
}

void register_capturer::capture_aarch64(register_state& state, const QBDI::GPRState* gpr) {
#if defined(QBDI_ARCH_AARCH64)
  state.arch_ = register_state::architecture::AARCH64;

  // general purpose registers x0-x28
  for (int i = 0; i < 29; ++i) {
    state.registers_["x" + std::to_string(i)] = (&gpr->x0)[i];
  }

  // special registers
  state.registers_["x29"] = gpr->x29; // frame pointer
  state.registers_["lr"] = gpr->lr;   // x30 - link register
  state.registers_["sp"] = gpr->sp;
  state.registers_["pc"] = gpr->pc;
  state.registers_["nzcv"] = gpr->nzcv;
#else
  // not aarch64 - this should not be called
  state.arch_ = register_state::architecture::UNKNOWN;
#endif
}

void register_capturer::capture_arm32(register_state& state, const QBDI::GPRState* gpr) {
#if defined(QBDI_ARCH_ARM)
  state.arch_ = register_state::architecture::ARM32;

  // general purpose registers r0-r12
  state.registers_["r0"] = gpr->r0;
  state.registers_["r1"] = gpr->r1;
  state.registers_["r2"] = gpr->r2;
  state.registers_["r3"] = gpr->r3;
  state.registers_["r4"] = gpr->r4;
  state.registers_["r5"] = gpr->r5;
  state.registers_["r6"] = gpr->r6;
  state.registers_["r7"] = gpr->r7;
  state.registers_["r8"] = gpr->r8;
  state.registers_["r9"] = gpr->r9;
  state.registers_["r10"] = gpr->r10;
  state.registers_["r11"] = gpr->r11; // frame pointer
  state.registers_["r12"] = gpr->r12;

  // special registers
  state.registers_["sp"] = gpr->sp; // r13
  state.registers_["lr"] = gpr->lr; // r14
  state.registers_["pc"] = gpr->pc; // r15
  state.registers_["cpsr"] = gpr->cpsr;
#else
  // not arm32 - this should not be called
  state.arch_ = register_state::architecture::UNKNOWN;
#endif
}

void register_capturer::capture_x86(register_state& state, const QBDI::GPRState* gpr) {
#if defined(QBDI_ARCH_X86)
  state.arch_ = register_state::architecture::X86;

  // general purpose registers
  state.registers_["eax"] = gpr->eax;
  state.registers_["ebx"] = gpr->ebx;
  state.registers_["ecx"] = gpr->ecx;
  state.registers_["edx"] = gpr->edx;
  state.registers_["esi"] = gpr->esi;
  state.registers_["edi"] = gpr->edi;

  // special purpose registers
  state.registers_["ebp"] = gpr->ebp;
  state.registers_["esp"] = gpr->esp;
  state.registers_["eip"] = gpr->eip;
  state.registers_["eflags"] = gpr->eflags;
#else
  // not x86 - this should not be called
  state.arch_ = register_state::architecture::UNKNOWN;
#endif
}

} // namespace w1::util
```

`src/w1tn3ss/util/register_capture.hpp`:

```hpp
#pragma once

#include <QBDI.h>
#include <cstdint>
#include <vector>
#include <string>
#include <unordered_map>

namespace w1::util {

/**
 * @brief full register state capture for debugging and tracing
 *
 * this class captures all cpu registers for debugging, tracing, and analysis.
 * it provides a complete snapshot of the register state at a point in time.
 *
 * note: this is for full state capture. for efficient access to specific
 * architectural registers (pc, sp), use register_access.hpp instead.
 * for abi-specific operations (arguments, return values), use the calling
 * convention layer.
 */
class register_state {
public:
  // architecture type for runtime queries
  enum class architecture { X86_64, AARCH64, ARM32, X86, UNKNOWN };

  // get current architecture
  architecture get_architecture() const { return arch_; }

  // generic register access by name
  bool get_register(const std::string& name, uint64_t& value) const;

  // architectural register accessors for convenience
  // note: for performance-critical code, use register_access.hpp directly
  uint64_t get_stack_pointer() const;
  uint64_t get_instruction_pointer() const;

  // returns the architectural register commonly used as frame pointer
  // note: this is just the register value - actual frame pointer
  // usage and semantics are abi-specific
  uint64_t get_frame_pointer() const;

  // get all register names for current architecture
  std::vector<std::string> get_register_names() const;

  // get all registers as name->value map
  std::unordered_map<std::string, uint64_t> get_all_registers() const;

  // internal: populated by register_capturer
  friend class register_capturer;

private:
  architecture arch_ = architecture::UNKNOWN;
  std::unordered_map<std::string, uint64_t> registers_;
};

/**
 * @brief captures register state from qbdi gprstate
 *
 * this class provides a clean abstraction for capturing register state
 * across different architectures, eliminating code duplication.
 */
class register_capturer {
public:
  // capture current register state
  static register_state capture(const QBDI::GPRState* gpr);

  // capture with floating point registers (future extension)
  // static register_state capture_full(const QBDI::GPRState* gpr, const QBDI::FPRState* fpr);

private:
  // architecture-specific capture implementations
  static void capture_x86_64(register_state& state, const QBDI::GPRState* gpr);
  static void capture_aarch64(register_state& state, const QBDI::GPRState* gpr);
  static void capture_arm32(register_state& state, const QBDI::GPRState* gpr);
  static void capture_x86(register_state& state, const QBDI::GPRState* gpr);
};

} // namespace w1::util
```

`src/w1tn3ss/util/safe_memory.cpp`:

```cpp
#include "safe_memory.hpp"
#include <algorithm>
#include <cstring>

namespace w1::util {

std::optional<std::string> safe_memory::read_string(QBDI::VMInstanceRef vm, uint64_t address, size_t max_length) {

  if (address == 0) {
    return std::nullopt;
  }

  std::string result;
  result.reserve(std::min(max_length, size_t(64)));

  // Read in chunks for efficiency
  constexpr size_t chunk_size = 16;

  for (size_t offset = 0; offset < max_length; offset += chunk_size) {
    size_t to_read = std::min(chunk_size, max_length - offset);

    // Check if this chunk is readable
    if (!memory_validator().check_access(address + offset, to_read, memory_range_index::READ)) {
      // Return what we got so far
      return result.empty() ? std::nullopt : std::optional(result);
    }

    const char* src = reinterpret_cast<const char*>(address + offset);

    for (size_t i = 0; i < to_read; ++i) {
      if (src[i] == 0) {
        return result;
      }
      result.push_back(src[i]);
    }
  }

  return result;
}

std::optional<std::wstring> safe_memory::read_wstring(QBDI::VMInstanceRef vm, uint64_t address, size_t max_length) {

  if (address == 0) {
    return std::nullopt;
  }

  std::wstring result;
  result.reserve(std::min(max_length, size_t(64)));

  // Check if we can read at least one wchar
  if (!memory_validator().check_access(address, sizeof(wchar_t), memory_range_index::READ)) {
    return std::nullopt;
  }

  const wchar_t* src = reinterpret_cast<const wchar_t*>(address);

  for (size_t i = 0; i < max_length; ++i) {
    // Check if next wchar is readable
    uint64_t wchar_addr = reinterpret_cast<uint64_t>(src + i);
    if (!memory_validator().check_access(wchar_addr, sizeof(wchar_t), memory_range_index::READ)) {
      return result.empty() ? std::nullopt : std::optional(result);
    }

    if (src[i] == 0) {
      return result;
    }
    result.push_back(src[i]);
  }

  return result;
}

std::optional<safe_memory::buffer_info> safe_memory::read_buffer(
    QBDI::VMInstanceRef vm, uint64_t address, size_t size, size_t max_size
) {

  if (address == 0 || size == 0) {
    return buffer_info{{}, true, 0};
  }

  size_t to_read = std::min(size, max_size);

  // Check if entire range is readable
  if (memory_validator().check_access(address, to_read, memory_range_index::READ)) {
    // Fast path: read entire buffer at once
    const uint8_t* src = reinterpret_cast<const uint8_t*>(address);
    std::vector<uint8_t> data(src, src + to_read);

    return buffer_info{std::move(data), to_read == size, to_read};
  }

  // Slow path: read page by page
  std::vector<uint8_t> data;
  data.reserve(to_read);

  const size_t page_size = 4096;
  size_t actually_read = 0;

  for (size_t offset = 0; offset < to_read; offset += page_size) {
    size_t chunk_size = std::min(page_size, to_read - offset);

    if (memory_validator().check_access(address + offset, chunk_size, memory_range_index::READ)) {
      const uint8_t* src = reinterpret_cast<const uint8_t*>(address + offset);
      data.insert(data.end(), src, src + chunk_size);
      actually_read += chunk_size;
    } else {
      // Stop at first unreadable chunk
      break;
    }
  }

  return buffer_info{std::move(data), to_read == size, actually_read};
}

std::vector<bool> safe_memory::read_batch(QBDI::VMInstanceRef vm, const std::vector<batch_read_request>& requests) {

  std::vector<bool> results(requests.size());

  for (size_t i = 0; i < requests.size(); ++i) {
    const auto& req = requests[i];

    if (memory_validator().check_access(req.address, req.size, memory_range_index::READ)) {
      const void* src = reinterpret_cast<const void*>(req.address);
      std::memcpy(req.buffer, src, req.size);
      results[i] = true;
    } else {
      results[i] = false;
    }
  }

  return results;
}

} // namespace w1::util
```

`src/w1tn3ss/util/safe_memory.hpp`:

```hpp
#pragma once

#include <QBDI.h>
#include "memory_range_index.hpp"
#include <array>
#include <cstring>
#include <memory>
#include <optional>
#include <string>
#include <vector>

namespace w1::util {

class safe_memory {
public:
  // Get thread-local memory validator
  static memory_range_index& memory_validator() {
    thread_local memory_range_index validator;
    return validator;
  }

  // Core read API - template for zero overhead
  template <typename T> static std::optional<T> read(QBDI::VMInstanceRef vm, uint64_t address) {
    static_assert(std::is_trivially_copyable_v<T>, "T must be trivially copyable");

    if (!memory_validator().check_access(address, sizeof(T), memory_range_index::READ)) {
      return std::nullopt;
    }

    const T* ptr = reinterpret_cast<const T*>(address);
    return *ptr;
  }

  // Read array of primitives
  template <typename T>
  static std::optional<std::vector<T>> read_array(QBDI::VMInstanceRef vm, uint64_t address, size_t count) {

    static_assert(std::is_trivially_copyable_v<T>);
    if (count == 0) {
      return std::vector<T>{};
    }

    size_t total_size = sizeof(T) * count;
    if (!memory_validator().check_access(address, total_size, memory_range_index::READ)) {
      return std::nullopt;
    }

    const T* ptr = reinterpret_cast<const T*>(address);
    return std::vector<T>(ptr, ptr + count);
  }

  // String reading with null termination detection
  static std::optional<std::string> read_string(QBDI::VMInstanceRef vm, uint64_t address, size_t max_length = 256);

  // Wide string reading (Windows)
  static std::optional<std::wstring> read_wstring(QBDI::VMInstanceRef vm, uint64_t address, size_t max_length = 256);

  // Buffer reading with metadata
  struct buffer_info {
    std::vector<uint8_t> data;
    bool complete; // false if truncated
    size_t bytes_read;
  };

  static std::optional<buffer_info> read_buffer(
      QBDI::VMInstanceRef vm, uint64_t address, size_t size, size_t max_size = 4096
  );

  // Structured read with automatic alignment
  template <typename T> static std::optional<T> read_struct(QBDI::VMInstanceRef vm, uint64_t address) {

    static_assert(std::is_standard_layout_v<T>, "T must have standard layout");

    if (!memory_validator().check_access(address, sizeof(T), memory_range_index::READ)) {
      return std::nullopt;
    }

    // Handle alignment requirements
    if (address % alignof(T) != 0) {
      // Read unaligned
      std::array<uint8_t, sizeof(T)> buffer;
      const uint8_t* src = reinterpret_cast<const uint8_t*>(address);
      std::memcpy(buffer.data(), src, sizeof(T));

      T result;
      std::memcpy(&result, buffer.data(), sizeof(T));
      return result;
    }

    return read<T>(vm, address);
  }

  // Batch read for performance
  struct batch_read_request {
    uint64_t address;
    size_t size;
    void* buffer; // Caller-provided buffer
  };

  static std::vector<bool> read_batch(QBDI::VMInstanceRef vm, const std::vector<batch_read_request>& requests);
};

// Wrapper class for safe memory reading with RAII
class safe_memory_reader {
public:
  explicit safe_memory_reader(QBDI::VMInstanceRef vm) : vm_(vm) {}

  template <typename T> std::optional<T> read(uint64_t address) const { return safe_memory::read<T>(vm_, address); }

  std::optional<std::string> read_string(uint64_t address, size_t max_length = 256) const {
    return safe_memory::read_string(vm_, address, max_length);
  }

  std::optional<safe_memory::buffer_info> read_buffer(uint64_t address, size_t size, size_t max_size = 4096) const {
    return safe_memory::read_buffer(vm_, address, size, max_size);
  }

private:
  QBDI::VMInstanceRef vm_;
};

} // namespace w1::util
```

`src/w1tn3ss/util/signal_handler.cpp`:

```cpp
#include "signal_handler.hpp"
#include "stderr_write.hpp"

#include <algorithm>
#include <atomic>
#include <chrono>
#include <cstring>
#include <mutex>
#include <vector>

#ifdef _WIN32
#include <w1common/windows_clean.hpp>
#else
#include <errno.h>
#include <sys/wait.h>
#include <unistd.h>
#endif

#include <redlog.hpp>

namespace w1::tn3ss::signal_handler {

namespace {

struct handler_entry {
  signal_callback callback;
  std::string context;
};

struct cleanup_entry {
  cleanup_callback callback;
  int priority;
  std::string context;
};

// global state
std::mutex g_mutex;
std::vector<handler_entry> g_handlers;
std::vector<cleanup_entry> g_cleanups;
std::vector<int> g_forwarding_pids;
config g_config;
std::atomic<bool> g_initialized{false};
redlog::logger g_log("w1.signal_handler");

void perform_cleanup() {
  // copy cleanup handlers and sort by priority (highest first)
  std::vector<cleanup_entry> cleanups;
  {
    std::lock_guard<std::mutex> lock(g_mutex);
    cleanups = g_cleanups;
  }

  std::sort(cleanups.begin(), cleanups.end(), [](const cleanup_entry& a, const cleanup_entry& b) {
    return a.priority > b.priority;
  });

  // execute cleanup handlers
  for (const auto& cleanup : cleanups) {
    try {
      cleanup.callback();
    } catch (...) {
      // can't safely log in signal context
    }
  }
}

#ifdef _WIN32
BOOL WINAPI console_handler(DWORD ctrl_type) {
  if (ctrl_type != CTRL_C_EVENT) {
    return FALSE;
  }

  if (g_config.log_signals) {
    const char* msg = "received ctrl+c signal\n";
    w1::util::stderr_write(msg);
  }

  // forward to child processes
  std::vector<int> pids;
  {
    std::lock_guard<std::mutex> lock(g_mutex);
    pids = g_forwarding_pids;
  }

  for (int pid : pids) {
    HANDLE process = OpenProcess(PROCESS_TERMINATE, FALSE, pid);
    if (process) {
      TerminateProcess(process, 1);
      CloseHandle(process);
    }
  }

  // call registered handlers
  std::vector<handler_entry> handlers;
  {
    std::lock_guard<std::mutex> lock(g_mutex);
    handlers = g_handlers;
  }

  for (const auto& handler : handlers) {
    try {
      handler.callback(handler.context);
    } catch (...) {
      // can't safely log
    }
  }

  perform_cleanup();
  ExitProcess(1);
  return TRUE;
}

#else
void unix_handler(int signum, siginfo_t* info, void* context) {
  if (signum != SIGINT) {
    return;
  }

  if (g_config.log_signals) {
    const char* msg = "received sigint signal\n";
    w1::util::stderr_write(msg);
  }

  // forward to child processes
  std::vector<int> pids;
  {
    std::lock_guard<std::mutex> lock(g_mutex);
    pids = g_forwarding_pids;
  }

  for (int pid : pids) {
    kill(pid, SIGINT);
  }

  // call registered handlers
  std::vector<handler_entry> handlers;
  {
    std::lock_guard<std::mutex> lock(g_mutex);
    handlers = g_handlers;
  }

  for (const auto& handler : handlers) {
    try {
      handler.callback(handler.context);
    } catch (...) {
      // can't safely log
    }
  }

  perform_cleanup();

  // restore default handler and re-raise to actually terminate
  signal(SIGINT, SIG_DFL);
  raise(SIGINT);
}
#endif

} // anonymous namespace

bool initialize(const config& cfg) {
  if (g_initialized.exchange(true)) {
    return true; // already initialized
  }

  {
    std::lock_guard<std::mutex> lock(g_mutex);
    g_config = cfg;
    g_log = redlog::logger("w1.signal_handler." + cfg.context_name);
  }

  g_log.info("initializing signal handler system", redlog::field("context", cfg.context_name));

#ifdef _WIN32
  if (!SetConsoleCtrlHandler(console_handler, TRUE)) {
    g_log.err("failed to install console control handler");
    g_initialized = false;
    return false;
  }
#else
  struct sigaction sa;
  sa.sa_sigaction = unix_handler;
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = SA_SIGINFO | SA_RESTART;

  if (sigaction(SIGINT, &sa, nullptr) != 0) {
    g_log.err("failed to install signal handler", redlog::field("error", strerror(errno)));
    g_initialized = false;
    return false;
  }
#endif

  return true;
}

bool register_handler(signal_callback callback, const std::string& context) {
  if (!g_initialized) {
    return false;
  }

  std::lock_guard<std::mutex> lock(g_mutex);
  g_handlers.push_back({callback, context});

  g_log.dbg("registered signal handler", redlog::field("context", context));
  return true;
}

bool register_cleanup(cleanup_callback callback, int priority, const std::string& context) {
  if (!g_initialized) {
    return false;
  }

  std::lock_guard<std::mutex> lock(g_mutex);
  g_cleanups.push_back({callback, priority, context});

  g_log.dbg("registered cleanup handler", redlog::field("context", context), redlog::field("priority", priority));
  return true;
}

bool setup_forwarding(int child_pid) {
  if (!g_initialized) {
    return false;
  }

  std::lock_guard<std::mutex> lock(g_mutex);

  auto it = std::find(g_forwarding_pids.begin(), g_forwarding_pids.end(), child_pid);
  if (it == g_forwarding_pids.end()) {
    g_forwarding_pids.push_back(child_pid);
    g_log.dbg("setup signal forwarding", redlog::field("child_pid", child_pid));
  }

  return true;
}

void remove_forwarding(int child_pid) {
  std::lock_guard<std::mutex> lock(g_mutex);

  auto it = std::find(g_forwarding_pids.begin(), g_forwarding_pids.end(), child_pid);
  if (it != g_forwarding_pids.end()) {
    g_forwarding_pids.erase(it);
    g_log.dbg("removed signal forwarding", redlog::field("child_pid", child_pid));
  }
}

void shutdown() {
  if (!g_initialized.exchange(false)) {
    return; // not initialized
  }

  g_log.info("shutting down signal handler system");

  {
    std::lock_guard<std::mutex> lock(g_mutex);
    g_handlers.clear();
    g_cleanups.clear();
    g_forwarding_pids.clear();
  }

#ifdef _WIN32
  SetConsoleCtrlHandler(console_handler, FALSE);
#else
  signal(SIGINT, SIG_DFL);
#endif
}

// raii guard implementation
guard::guard(const config& cfg) : initialized_(initialize(cfg)) {}

guard::~guard() {
  if (initialized_) {
    shutdown();
  }
}

bool guard::is_initialized() const { return initialized_; }

} // namespace w1::tn3ss::signal_handler
```

`src/w1tn3ss/util/signal_handler.hpp`:

```hpp
#pragma once

#include <functional>
#include <string>
#include <vector>

#ifdef _WIN32
#include <w1common/windows_clean.hpp>
#else
#include <signal.h>
#include <sys/types.h>
#endif

namespace w1::tn3ss::signal_handler {

/**
 * @brief callback function for signal handlers
 * @param context optional context string for debugging
 */
using signal_callback = std::function<void(const std::string& context)>;

/**
 * @brief cleanup function for graceful shutdown
 * should be signal-safe and fast
 */
using cleanup_callback = std::function<void()>;

/**
 * @brief configuration for signal handling behavior
 */
struct config {
  std::string context_name = "w1tool"; ///< context name for logging
  bool log_signals = false;            ///< log signal reception for debugging
};

/**
 * @brief initialize signal handling system
 * @param cfg configuration for signal handling behavior
 * @return true if initialization succeeded
 */
bool initialize(const config& cfg = {});

/**
 * @brief register a signal handler for SIGINT (ctrl+c)
 * @param callback function to call when signal is received
 * @param context context string for debugging/logging
 * @return true if registration succeeded
 */
bool register_handler(signal_callback callback, const std::string& context = "");

/**
 * @brief register a cleanup function to be called during graceful shutdown
 * @param callback cleanup function (should be signal-safe)
 * @param priority priority for cleanup order (higher = called first)
 * @param context context string for debugging/logging
 * @return true if registration succeeded
 */
bool register_cleanup(cleanup_callback callback, int priority = 0, const std::string& context = "");

/**
 * @brief set up signal forwarding from parent to child process
 * @param child_pid child process ID to forward signals to
 * @return true if forwarding was set up successfully
 */
bool setup_forwarding(int child_pid);

/**
 * @brief remove signal forwarding for a specific child process
 * @param child_pid child process ID to stop forwarding to
 */
void remove_forwarding(int child_pid);

/**
 * @brief cleanup and shutdown the signal handling system
 */
void shutdown();

/**
 * @brief raii helper for signal handling setup/cleanup
 */
class guard {
public:
  explicit guard(const config& cfg = {});
  ~guard();

  guard(const guard&) = delete;
  guard& operator=(const guard&) = delete;
  guard(guard&&) = delete;
  guard& operator=(guard&&) = delete;

  bool is_initialized() const;

private:
  bool initialized_;
};

} // namespace w1::tn3ss::signal_handler
```

`src/w1tn3ss/util/stack_capture.cpp`:

```cpp
#include "stack_capture.hpp"
#include "safe_memory.hpp"
#include <cstring>
#include <algorithm>

namespace w1::util {

stack_info stack_capturer::capture(QBDI::VMInstanceRef vm, const register_state& regs, const capture_options& options) {
  // create memory reader lambda that uses safe_memory
  memory_reader reader = [vm](uint64_t addr, void* buffer, size_t size) -> bool {
    try {
      // use safe_memory to read buffer
      auto result = safe_memory::read_buffer(vm, addr, size, size);
      if (result.has_value() && result->bytes_read == size) {
        std::memcpy(buffer, result->data.data(), size);
        return true;
      }
      return false;
    } catch (...) {
      return false;
    }
  };

  return capture_with_reader(regs, reader, options);
}

stack_info stack_capturer::capture_with_reader(
    const register_state& regs, memory_reader reader, const capture_options& options
) {
  stack_info info;

  // get basic register values
  info.stack_pointer = regs.get_stack_pointer();
  info.frame_pointer = regs.get_frame_pointer();

  if (info.stack_pointer == 0) {
    return info; // invalid stack pointer
  }

  // capture stack values around the stack pointer
  info.values.reserve(options.num_values);

  for (size_t i = 0; i < options.num_values; ++i) {
    stack_info::stack_entry entry;
    entry.offset = options.start_offset + (i * options.value_spacing);

    uint64_t addr = info.stack_pointer + entry.offset;
    entry.is_valid = read_stack_value(reader, addr, entry.value);

    info.values.push_back(entry);
  }

  // read return address (typically at [rsp] on x64 call)
  if (!info.values.empty() && info.values[0].offset == 0 && info.values[0].is_valid) {
    info.return_address = info.values[0].value;
  } else {
    // try to read at sp+0 if not already captured
    read_stack_value(reader, info.stack_pointer, info.return_address);
  }

  // perform architecture-specific frame analysis if requested
  if (options.analyze_frame) {
    switch (regs.get_architecture()) {
    case register_state::architecture::X86_64:
      analyze_x86_64_frame(info, regs, reader);
      break;
    case register_state::architecture::AARCH64:
      analyze_aarch64_frame(info, regs, reader);
      break;
    case register_state::architecture::ARM32:
      analyze_arm32_frame(info, regs, reader);
      break;
    case register_state::architecture::X86:
      analyze_x86_frame(info, regs, reader);
      break;
    default:
      break;
    }
  }

  return info;
}

void stack_capturer::analyze_x86_64_frame(stack_info& info, const register_state& regs, memory_reader& reader) {
  // x86_64 typically uses rbp as frame pointer in debug builds
  if (info.frame_pointer != 0 && info.frame_pointer > info.stack_pointer) {
    info.has_frame_pointer = true;
    info.estimated_frame_size = info.frame_pointer - info.stack_pointer;

    // read saved rbp and return address from frame
    uint64_t saved_rbp = 0;
    uint64_t saved_rip = 0;

    if (read_stack_value(reader, info.frame_pointer, saved_rbp) &&
        read_stack_value(reader, info.frame_pointer + 8, saved_rip)) {
      // we have a valid frame
      if (info.return_address == 0) {
        info.return_address = saved_rip;
      }
    }
  }

  // check for red zone usage (128 bytes below rsp on x64 system v)
  // this is just informational - we don't capture red zone by default
}

void stack_capturer::analyze_aarch64_frame(stack_info& info, const register_state& regs, memory_reader& reader) {
  // aarch64 uses x29 (fp) and x30 (lr) for frame management
  if (info.frame_pointer != 0 && info.frame_pointer >= info.stack_pointer) {
    info.has_frame_pointer = true;
    info.estimated_frame_size = info.frame_pointer - info.stack_pointer + 16; // fp/lr pair

    // on aarch64, fp and lr are typically stored as a pair at [fp-16]
    uint64_t saved_fp = 0;
    uint64_t saved_lr = 0;

    if (read_stack_value(reader, info.frame_pointer - 16, saved_fp) &&
        read_stack_value(reader, info.frame_pointer - 8, saved_lr)) {
      if (info.return_address == 0) {
        info.return_address = saved_lr;
      }
    }
  }

  // check if lr register has return address
  uint64_t lr_value = 0;
  if (info.return_address == 0 && regs.get_register("lr", lr_value)) {
    info.return_address = lr_value;
  }
}

void stack_capturer::analyze_arm32_frame(stack_info& info, const register_state& regs, memory_reader& reader) {
  // arm32 frame analysis similar to aarch64 but 32-bit
  if (info.frame_pointer != 0 && info.frame_pointer >= info.stack_pointer) {
    info.has_frame_pointer = true;
    info.estimated_frame_size = info.frame_pointer - info.stack_pointer + 8;

    // read saved registers from frame
    uint64_t saved_fp = 0;
    uint64_t saved_lr = 0;

    if (read_stack_value(reader, info.frame_pointer - 8, saved_fp) &&
        read_stack_value(reader, info.frame_pointer - 4, saved_lr)) {
      if (info.return_address == 0) {
        info.return_address = saved_lr & 0xFFFFFFFF; // 32-bit
      }
    }
  }

  // check lr register
  uint64_t lr_value = 0;
  if (info.return_address == 0 && regs.get_register("lr", lr_value)) {
    info.return_address = lr_value & 0xFFFFFFFF;
  }
}

void stack_capturer::analyze_x86_frame(stack_info& info, const register_state& regs, memory_reader& reader) {
  // x86 32-bit frame analysis
  if (info.frame_pointer != 0 && info.frame_pointer > info.stack_pointer) {
    info.has_frame_pointer = true;
    info.estimated_frame_size = info.frame_pointer - info.stack_pointer;

    // standard x86 frame: push ebp; mov ebp, esp
    uint64_t saved_ebp = 0;
    uint64_t saved_eip = 0;

    if (read_stack_value(reader, info.frame_pointer, saved_ebp) &&
        read_stack_value(reader, info.frame_pointer + 4, saved_eip)) {
      if (info.return_address == 0) {
        info.return_address = saved_eip & 0xFFFFFFFF;
      }
    }
  }
}

bool stack_capturer::read_stack_value(memory_reader& reader, uint64_t addr, uint64_t& value) {
  // determine size based on architecture (could be passed in, but 8 bytes is safe)
  constexpr size_t ptr_size = 8;
  uint8_t buffer[ptr_size] = {0};

  if (reader(addr, buffer, ptr_size)) {
    // little-endian assumption (true for all supported architectures)
    value = 0;
    for (size_t i = 0; i < ptr_size; ++i) {
      value |= static_cast<uint64_t>(buffer[i]) << (i * 8);
    }
    return true;
  }

  value = 0;
  return false;
}

// basic stack walker implementation
std::vector<stack_walker::frame> stack_walker::walk(
    QBDI::VMInstanceRef vm, const register_state& regs, size_t max_frames
) {
  std::vector<frame> frames;
  frames.reserve(max_frames);

  // create memory reader
  stack_capturer::memory_reader reader = [vm](uint64_t addr, void* buffer, size_t size) -> bool {
    try {
      // use safe_memory to read buffer
      auto result = safe_memory::read_buffer(vm, addr, size, size);
      if (result.has_value() && result->bytes_read == size) {
        std::memcpy(buffer, result->data.data(), size);
        return true;
      }
      return false;
    } catch (...) {
      return false;
    }
  };

  // start with current frame
  frame current;
  current.sp = regs.get_stack_pointer();
  current.fp = regs.get_frame_pointer();

  // architecture-specific unwinding would go here
  // for now, just return current frame
  if (current.sp != 0) {
    // read return address
    uint64_t ret_addr = 0;
    if (stack_capturer::read_stack_value(reader, current.sp, ret_addr)) {
      current.return_address = ret_addr;
    }

    current.frame_size = (current.fp > current.sp) ? (current.fp - current.sp) : 0;
    frames.push_back(current);
  }

  // full unwinding implementation would follow frame pointers
  // this is a placeholder for future enhancement

  return frames;
}

} // namespace w1::util
```

`src/w1tn3ss/util/stack_capture.hpp`:

```hpp
#pragma once

#include <QBDI.h>
#include <vector>
#include <cstdint>
#include <functional>
#include "register_capture.hpp"

namespace w1::util {

/**
 * @brief Captured stack information
 */
struct stack_info {
  uint64_t stack_pointer = 0;
  uint64_t frame_pointer = 0;
  uint64_t return_address = 0;

  // stack values at various offsets
  struct stack_entry {
    int64_t offset; // offset from stack pointer (can be negative)
    uint64_t value; // value at that location
    bool is_valid;  // whether read was successful
  };

  std::vector<stack_entry> values;

  // additional analysis results
  size_t estimated_frame_size = 0;
  bool has_frame_pointer = false;
};

/**
 * @brief Stack capture and analysis utility
 *
 * Provides safe stack reading and analysis across architectures
 */
class stack_capturer {
public:
  struct capture_options {
    size_t num_values = 8;     // number of stack values to capture
    int64_t start_offset = -8; // where to start capturing (relative to SP)
    size_t value_spacing = 8;  // spacing between captured values
    bool analyze_frame = true; // whether to analyze frame structure
    bool capture_args = true;  // capture potential arguments on stack

    capture_options() : num_values(8), start_offset(-8), value_spacing(8), analyze_frame(true), capture_args(true) {}
  };

  // memory reader function type
  using memory_reader = std::function<bool(uint64_t addr, void* buffer, size_t size)>;

  /**
   * capture stack information
   * @param vm QBDI VM instance for memory access
   * @param regs register state (from register_capturer)
   * @param options capture options
   */
  static stack_info capture(QBDI::VMInstanceRef vm, const register_state& regs, const capture_options& options = {});

  /**
   * capture with custom memory reader (for testing or special cases)
   */
  static stack_info capture_with_reader(
      const register_state& regs, memory_reader reader, const capture_options& options = {}
  );

  // helper to read stack values safely (public for stack_walker)
  static bool read_stack_value(memory_reader& reader, uint64_t addr, uint64_t& value);

private:
  // architecture-specific stack analysis
  static void analyze_x86_64_frame(stack_info& info, const register_state& regs, memory_reader& reader);
  static void analyze_aarch64_frame(stack_info& info, const register_state& regs, memory_reader& reader);
  static void analyze_arm32_frame(stack_info& info, const register_state& regs, memory_reader& reader);
  static void analyze_x86_frame(stack_info& info, const register_state& regs, memory_reader& reader);
};

/**
 * @brief Stack walker for unwinding call stacks
 *
 * More advanced stack walking functionality (future extension)
 */
class stack_walker {
public:
  struct frame {
    uint64_t sp;
    uint64_t fp;
    uint64_t return_address;
    size_t frame_size;
  };

  // walk stack frames up to max_frames
  static std::vector<frame> walk(QBDI::VMInstanceRef vm, const register_state& regs, size_t max_frames = 32);
};

} // namespace w1::util
```

`src/w1tn3ss/util/stderr_write.hpp`:

```hpp
#pragma once

#include <cstring>

#ifdef _WIN32
#include <w1common/windows_clean.hpp>
#else
#include <unistd.h>
#endif

namespace w1::util {

/**
 * @brief Platform-agnostic function to write to stderr
 *
 * This function is signal-safe and can be used in signal handlers
 * or exception catch blocks where regular I/O might not be safe.
 *
 * @param message The message to write to stderr
 */
inline void stderr_write(const char* message) {
  if (!message) {
    return;
  }

#ifdef _WIN32
  HANDLE hStderr = GetStdHandle(STD_ERROR_HANDLE);
  if (hStderr != INVALID_HANDLE_VALUE) {
    DWORD written;
    WriteFile(hStderr, message, static_cast<DWORD>(strlen(message)), &written, NULL);
  }
#else
  write(STDERR_FILENO, message, strlen(message));
#endif
}

/**
 * @brief Platform-agnostic function to write to stderr with size
 *
 * @param message The message to write to stderr
 * @param size The size of the message
 */
inline void stderr_write(const char* message, size_t size) {
  if (!message || size == 0) {
    return;
  }

#ifdef _WIN32
  HANDLE hStderr = GetStdHandle(STD_ERROR_HANDLE);
  if (hStderr != INVALID_HANDLE_VALUE) {
    DWORD written;
    WriteFile(hStderr, message, static_cast<DWORD>(size), &written, NULL);
  }
#else
  write(STDERR_FILENO, message, size);
#endif
}

} // namespace w1::util
```

`src/w1tn3ss/util/value_formatter.cpp`:

```cpp
#include "value_formatter.hpp"
#include <algorithm>
#include <cctype>
#include <cstring>
#include <w1common/ext/jsonstruct.hpp>

namespace w1::util {

std::string value_formatter::format_pointer(uint64_t value, const format_options& opts) {
  if (value == 0 && opts.null_as_string) {
    return "NULL";
  }

  std::stringstream ss;
  if (opts.show_hex_for_pointers) {
    ss << "0x" << std::hex << value;
  } else {
    ss << value;
  }
  return ss.str();
}

std::string value_formatter::format_string(const std::string& str, const format_options& opts) {
  std::string result = str;

  // truncate if needed
  if (result.length() > opts.max_string_length) {
    result = result.substr(0, opts.max_string_length) + "...";
  }

  // escape special characters
  result = escape_string(result);

  // add quotes if requested
  if (opts.quote_strings) {
    result = "\"" + result + "\"";
  }

  return result;
}

std::string value_formatter::format_string(const char* str, size_t max_len, const format_options& opts) {
  if (!str) {
    return opts.null_as_string ? "NULL" : "0x0";
  }

  // safely get string length
  size_t len = 0;
  while (len < max_len && str[len] != '\0') {
    len++;
  }

  return format_string(std::string(str, len), opts);
}

std::string value_formatter::format_buffer(const uint8_t* data, size_t size, const format_options& opts) {
  if (!data || size == 0) {
    return "buffer[0]";
  }

  std::stringstream ss;
  ss << "buffer[" << size << "]:";

  // check if it might be a string
  if (opts.show_buffer_ascii && is_printable_buffer(data, size)) {
    ss << "\""
       << escape_string(std::string(reinterpret_cast<const char*>(data), std::min(size, opts.max_string_length)))
       << "\"";
  } else {
    // hex dump
    ss << "{";
    size_t preview_size = std::min(size, opts.max_buffer_preview);

    for (size_t i = 0; i < preview_size; ++i) {
      if (i > 0) {
        ss << " ";
      }
      ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(data[i]);
    }

    if (size > preview_size) {
      ss << "...";
    }
    ss << "}";
  }

  return ss.str();
}

std::string value_formatter::format_buffer(const std::vector<uint8_t>& buffer, const format_options& opts) {
  return format_buffer(buffer.data(), buffer.size(), opts);
}

std::string value_formatter::format_bool(bool value) { return value ? "true" : "false"; }

std::string value_formatter::format_error_code(int64_t code, bool include_hex) {
  std::stringstream ss;

  if (code == 0) {
    return "0 (success)";
  }

  if (include_hex && code != 0) {
    ss << "0x" << std::hex << code << " (" << std::dec << code << ")";
  } else {
    ss << code;
  }

  // could add errno string lookup here
  if (code == -1) {
    ss << " (error)";
  }

  return ss.str();
}

std::string value_formatter::format_fd(int fd) {
  if (fd < 0) {
    return std::to_string(fd) + " (invalid)";
  }

  switch (fd) {
  case 0:
    return "0 (stdin)";
  case 1:
    return "1 (stdout)";
  case 2:
    return "2 (stderr)";
  default:
    return std::to_string(fd);
  }
}

std::string value_formatter::format_size(size_t size, bool human_readable) {
  if (!human_readable) {
    return std::to_string(size);
  }

  const char* units[] = {"B", "KB", "MB", "GB", "TB"};
  int unit_index = 0;
  double value = static_cast<double>(size);

  while (value >= 1024.0 && unit_index < 4) {
    value /= 1024.0;
    unit_index++;
  }

  std::stringstream ss;
  if (unit_index == 0) {
    ss << size << " " << units[0];
  } else {
    ss << std::fixed << std::setprecision(2) << value << " " << units[unit_index];
  }

  return ss.str();
}

std::string value_formatter::format_value(const value_variant& value, const format_options& opts) {
  return std::visit(
      [&opts](const auto& v) -> std::string {
        using T = std::decay_t<decltype(v)>;

        if constexpr (std::is_same_v<T, std::monostate>) {
          return "<no value>";
        } else if constexpr (std::is_same_v<T, bool>) {
          return format_bool(v);
        } else if constexpr (std::is_same_v<T, int64_t>) {
          return std::to_string(v);
        } else if constexpr (std::is_same_v<T, uint64_t>) {
          return std::to_string(v);
        } else if constexpr (std::is_same_v<T, double>) {
          return std::to_string(v);
        } else if constexpr (std::is_same_v<T, std::string>) {
          return format_string(v, opts);
        } else if constexpr (std::is_same_v<T, std::vector<uint8_t>>) {
          return format_buffer(v, opts);
        }
        return "<unknown>";
      },
      value
  );
}

std::string value_formatter::format_typed_value(uint64_t raw_value, value_type type, const format_options& opts) {
  switch (type) {
  case value_type::POINTER:
    return format_pointer(raw_value, opts);
  case value_type::BOOLEAN:
    return format_bool(raw_value != 0);
  case value_type::INTEGER:
    return std::to_string(static_cast<int64_t>(raw_value));
  case value_type::UNSIGNED:
    return std::to_string(raw_value);
  case value_type::ERROR_CODE:
    return format_error_code(static_cast<int64_t>(raw_value));
  case value_type::FILE_DESCRIPTOR:
    return format_fd(static_cast<int>(raw_value));
  case value_type::SIZE:
    return format_size(raw_value);
  default:
    // generic hex format
    std::stringstream ss;
    ss << "0x" << std::hex << raw_value;
    return ss.str();
  }
}

std::string value_formatter::escape_json_string(const std::string& str) {
  // leverage the existing jsonstruct escaping logic for consistency
  std::string buffer;
  JS::DataRef ref = JS::Internal::handle_json_escapes_out(str, buffer);
  return std::string(ref.data, ref.size);
}

std::string value_formatter::escape_string(const std::string& str) {
  std::string result;
  result.reserve(str.length() + 10); // reserve extra space for escapes

  for (char c : str) {
    switch (c) {
    case '\n':
      result += "\\n";
      break;
    case '\r':
      result += "\\r";
      break;
    case '\t':
      result += "\\t";
      break;
    case '\\':
      result += "\\\\";
      break;
    case '"':
      result += "\\\"";
      break;
    case '\0':
      result += "\\0";
      break;
    default:
      if (std::isprint(static_cast<unsigned char>(c))) {
        result += c;
      } else {
        // non-printable as hex
        result += "\\x";
        result += "0123456789abcdef"[(c >> 4) & 0xF];
        result += "0123456789abcdef"[c & 0xF];
      }
      break;
    }
  }

  return result;
}

bool value_formatter::is_printable_buffer(const uint8_t* data, size_t size) {
  if (size == 0) {
    return false;
  }

  // check if buffer looks like a string
  size_t printable_count = 0;
  bool has_null = false;

  for (size_t i = 0; i < size && i < 64; ++i) { // check first 64 bytes
    if (data[i] == 0) {
      has_null = true;
      break;
    }
    if (std::isprint(static_cast<unsigned char>(data[i])) || data[i] == '\n' || data[i] == '\r' || data[i] == '\t') {
      printable_count++;
    }
  }

  // if 80% printable and has null terminator, likely a string
  return has_null && (printable_count * 100 / size > 80);
}

// argument_formatter implementation
void argument_formatter::add(const std::string& name, const std::string& value) {
  arguments_.emplace_back(name, value);
}

void argument_formatter::add(const std::string& value) { arguments_.emplace_back("", value); }

void argument_formatter::add_pointer(const std::string& name, uint64_t value) {
  add(name, value_formatter::format_pointer(value));
}

void argument_formatter::add_string(const std::string& name, const std::string& value) {
  add(name, value_formatter::format_string(value));
}

void argument_formatter::add_integer(const std::string& name, int64_t value) { add(name, std::to_string(value)); }

void argument_formatter::add_unsigned(const std::string& name, uint64_t value) { add(name, std::to_string(value)); }

void argument_formatter::add_bool(const std::string& name, bool value) {
  add(name, value_formatter::format_bool(value));
}

std::string argument_formatter::build() const { return "(" + build_list() + ")"; }

std::string argument_formatter::build_list() const {
  std::string result;

  for (size_t i = 0; i < arguments_.size(); ++i) {
    if (i > 0) {
      result += ", ";
    }

    const auto& [name, value] = arguments_[i];
    if (!name.empty()) {
      result += name + "=";
    }
    result += value;
  }

  return result;
}

} // namespace w1::util
```

`src/w1tn3ss/util/value_formatter.hpp`:

```hpp
#pragma once

#include <string>
#include <vector>
#include <variant>
#include <cstdint>
#include <sstream>
#include <iomanip>

namespace w1::util {

/**
 * @brief Utility class for formatting various types of values for display
 *
 * Provides consistent formatting for different data types commonly encountered
 * in dynamic analysis: pointers, strings, buffers, numbers, etc.
 */
class value_formatter {
public:
  // formatting options
  struct format_options {
    size_t max_string_length = 256;
    size_t max_buffer_preview = 16;
    bool show_hex_for_pointers = true;
    bool null_as_string = true; // show NULL instead of 0x0
    bool quote_strings = true;
    bool show_buffer_ascii = false; // show ASCII preview for buffers

    format_options()
        : max_string_length(256), max_buffer_preview(16), show_hex_for_pointers(true), null_as_string(true),
          quote_strings(true), show_buffer_ascii(false) {}
  };

  // format a raw pointer value
  static std::string format_pointer(uint64_t value, const format_options& opts = {});

  // format a string with proper escaping and length limits
  static std::string format_string(const std::string& str, const format_options& opts = {});
  static std::string format_string(const char* str, size_t max_len, const format_options& opts = {});

  // format a buffer/byte array
  static std::string format_buffer(const uint8_t* data, size_t size, const format_options& opts = {});
  static std::string format_buffer(const std::vector<uint8_t>& buffer, const format_options& opts = {});

  // format boolean values
  static std::string format_bool(bool value);

  // format error codes with optional description
  static std::string format_error_code(int64_t code, bool include_hex = true);

  // format file descriptors
  static std::string format_fd(int fd);

  // format memory sizes
  static std::string format_size(size_t size, bool human_readable = false);

  // generic value formatting using variant
  using value_variant = std::variant<
      std::monostate, // no value
      bool, int64_t, uint64_t, double, std::string, std::vector<uint8_t>>;

  static std::string format_value(const value_variant& value, const format_options& opts = {});

  // format with type hint for better output
  enum class value_type {
    UNKNOWN,
    POINTER,
    STRING,
    BUFFER,
    BOOLEAN,
    INTEGER,
    UNSIGNED,
    FLOAT,
    ERROR_CODE,
    FILE_DESCRIPTOR,
    SIZE
  };

  static std::string format_typed_value(uint64_t raw_value, value_type type, const format_options& opts = {});

  // json-specific escaping for safe JSON string values
  static std::string escape_json_string(const std::string& str);

private:
  // helper to escape special characters in strings
  static std::string escape_string(const std::string& str);

  // helper to check if buffer contains printable ASCII
  static bool is_printable_buffer(const uint8_t* data, size_t size);
};

/**
 * @brief Helper class for building formatted argument lists
 *
 * Useful for creating function call representations
 */
class argument_formatter {
public:
  argument_formatter() = default;

  // add formatted argument
  void add(const std::string& name, const std::string& value);
  void add(const std::string& value); // unnamed argument

  // add with automatic formatting
  void add_pointer(const std::string& name, uint64_t value);
  void add_string(const std::string& name, const std::string& value);
  void add_integer(const std::string& name, int64_t value);
  void add_unsigned(const std::string& name, uint64_t value);
  void add_bool(const std::string& name, bool value);

  // build final formatted string
  std::string build() const;

  // get as comma-separated list without parentheses
  std::string build_list() const;

private:
  std::vector<std::pair<std::string, std::string>> arguments_;
};

} // namespace w1::util
```

`src/w1tool/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.16)

include(${WITNESS_SOURCE_DIR}/cmake/CommonConfig.cmake)

add_executable(w1tool
    main.cpp
    commands/inject.cpp
    commands/inspect.cpp
    commands/cover.cpp
    commands/read_drcov.cpp
    commands/tracer.cpp
    tracer_discovery.cpp
)

set_target_properties(w1tool PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})

target_include_directories(w1tool PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}
    ${WITNESS_SOURCE_DIR}/src
)

target_link_libraries(w1tool PRIVATE
    w1tn3ss
    w1nj3ct
    common
    redlog::redlog
)

apply_common_compile_options(w1tool)
apply_windows_definitions(w1tool)
configure_target_with_lief(w1tool)

install(TARGETS w1tool RUNTIME DESTINATION bin)
```

`src/w1tool/commands/cover.cpp`:

```cpp
#include "cover.hpp"
#include "tracer.hpp"
#include "ext/args.hpp"
#include <cstdlib>
#include <filesystem>
#include <iostream>
#include <redlog.hpp>

// forward declare CLI symbols from main.cpp
namespace cli {
extern args::CounterFlag verbosity_flag;
}

namespace w1tool::commands {

int cover(
    args::ValueFlag<std::string>& library_flag, args::Flag& spawn_flag, args::ValueFlag<int>& pid_flag,
    args::ValueFlag<std::string>& name_flag, args::ValueFlag<std::string>& output_flag, args::Flag& include_system_flag,
    args::Flag& inst_trace_flag, args::ValueFlag<std::string>& module_filter_flag,
    args::ValueFlag<int>& debug_level_flag, args::ValueFlag<std::string>& format_flag, args::Flag& suspended_flag,
    args::PositionalList<std::string>& args_list, const std::string& executable_path
) {
  auto log = redlog::get_logger("w1tool.cover");

  // validate target
  int target_count = 0;
  if (spawn_flag) {
    target_count++;
  }
  if (pid_flag) {
    target_count++;
  }
  if (name_flag) {
    target_count++;
  }

  if (target_count != 1) {
    log.err("exactly one target required: specify -s/--spawn, --pid, or --name");
    return 1;
  }

  // validate suspended flag
  if (suspended_flag && !spawn_flag) {
    log.err("--suspended can only be used with -s/--spawn (launch tracing)");
    return 1;
  }

  // validate output format
  std::string format = "drcov"; // default
  if (format_flag) {
    format = args::get(format_flag);
    if (format != "drcov" && format != "text") {
      log.err("invalid format, supported: drcov, text", redlog::field("format", format));
      return 1;
    }
    if (format == "text") {
      log.warn("text format not yet implemented, using drcov format");
      format = "drcov";
    }
  }

  // determine output file
  std::string output_file;
  if (output_flag) {
    output_file = args::get(output_flag);
  } else {
    // generate default filename
    if (spawn_flag && !args_list.Get().empty()) {
      std::vector<std::string> all_args = args::get(args_list);
      std::string binary_path = all_args[0];
      std::filesystem::path fs_path(binary_path);
      std::string binary_name = fs_path.filename().string();
      output_file = binary_name + "_coverage." + format;
    } else {
      output_file = "coverage." + format;
    }
  }

  // build execution parameters
  tracer_execution_params params;
  params.tracer_name = "w1cov";
  params.executable_path = executable_path;

  if (library_flag) {
    params.library_path = args::get(library_flag);
  }

  // set debug level
  if (debug_level_flag) {
    params.debug_level = args::get(debug_level_flag);
  } else {
    params.debug_level = args::get(cli::verbosity_flag);
  }

  // translate cover flags to w1cov config
  params.config_map["include_system"] = include_system_flag ? "true" : "false";
  params.config_map["inst_trace"] = inst_trace_flag ? "true" : "false";
  params.config_map["output"] = output_file;

  if (module_filter_flag) {
    params.config_map["module_filter"] = args::get(module_filter_flag);
  }

  // set target
  if (spawn_flag) {
    if (args_list.Get().empty()) {
      log.err("binary path required when using -s/--spawn flag");
      return 1;
    }

    std::vector<std::string> all_args = args::get(args_list);
    params.spawn_target = true;
    params.binary_path = all_args[0];
    params.suspended = suspended_flag;

    // extract binary arguments
    if (all_args.size() > 1) {
      params.binary_args.assign(all_args.begin() + 1, all_args.end());
    }

  } else if (pid_flag) {
    params.target_pid = args::get(pid_flag);

  } else if (name_flag) {
    params.process_name = args::get(name_flag);
  }

  log.info(
      "coverage tracing configuration", redlog::field("output_file", output_file), redlog::field("format", format),
      redlog::field("include_system", include_system_flag ? "true" : "false"),
      redlog::field("inst_trace", inst_trace_flag ? "true" : "false"), redlog::field("debug_level", params.debug_level)
  );

  // execute w1cov tracing
  int result = execute_tracer_impl(params);

  // handle cover post-processing
  if (result == 0) {
    // check output file created
    if (!std::filesystem::exists(output_file)) {
      log.err("output file not created", redlog::field("output_file", output_file));
      return 1;
    }

    std::cout << "coverage tracing completed successfully.\n";
    std::cout << "output file: " << output_file << "\n";
    if (format == "drcov") {
      std::cout << "use 'w1tool read-drcov --file " << output_file << "' to analyze results.\n";
    }
  }

  return result;
}

} // namespace w1tool::commands
```

`src/w1tool/commands/cover.hpp`:

```hpp
#pragma once

#include "ext/args.hpp"

namespace w1tool::commands {

/**
 * cover command - performs coverage tracing with configurable options
 *
 * @param library_flag path to w1cov library (auto-detected if not specified)
 * @param spawn_flag spawn new process for tracing
 * @param pid_flag process id to attach to for runtime tracing
 * @param name_flag process name to attach to for runtime tracing
 * @param output_flag output file path for coverage data (optional)
 * @param include_system_flag include system libraries in coverage (optional)
 * @param module_filter_flag comma-separated list of modules to filter (optional)
 * @param debug_level_flag debug level override - defaults to passthrough verbosity (optional)
 * @param format_flag output format (drcov, text) (optional)
 * @param suspended_flag start process in suspended state (optional)
 * @param args_list binary and arguments (use -- to separate w1tool args from target args)
 * @param executable_path path to the current executable (for auto-discovery)
 * @return exit code (0 for success, 1 for failure)
 */
int cover(
    args::ValueFlag<std::string>& library_flag, args::Flag& spawn_flag, args::ValueFlag<int>& pid_flag,
    args::ValueFlag<std::string>& name_flag, args::ValueFlag<std::string>& output_flag, args::Flag& include_system_flag,
    args::Flag& inst_trace_flag, args::ValueFlag<std::string>& module_filter_flag,
    args::ValueFlag<int>& debug_level_flag, args::ValueFlag<std::string>& format_flag, args::Flag& suspended_flag,
    args::PositionalList<std::string>& args_list, const std::string& executable_path
);

} // namespace w1tool::commands
```

`src/w1tool/commands/inject.cpp`:

```cpp
#include "inject.hpp"
#include "w1nj3ct.hpp"
#include <redlog.hpp>

namespace w1tool::commands {

int inject(
    args::ValueFlag<std::string>& library_flag, args::Flag& spawn_flag, args::ValueFlag<int>& pid_flag,
    args::ValueFlag<std::string>& process_name_flag, args::Flag& suspended_flag,
    args::PositionalList<std::string>& args_list
) {

  auto log = redlog::get_logger("w1tool.inject");

  // validate required arguments
  if (!library_flag) {
    log.err("library path required");
    return 1;
  }

  // validate target specification
  int target_count = 0;
  if (spawn_flag) {
    target_count++;
  }
  if (pid_flag) {
    target_count++;
  }
  if (process_name_flag) {
    target_count++;
  }

  if (target_count != 1) {
    log.err("exactly one target required: specify -s/--spawn, --pid, or --process-name");
    return 1;
  }

  // validate suspended flag usage
  if (suspended_flag && !spawn_flag) {
    log.err("--suspended can only be used with -s/--spawn (launch injection)");
    return 1;
  }

  std::string lib_path = args::get(library_flag);
  w1::inject::result result;

  // determine injection method based on arguments
  if (spawn_flag) {
    // launch injection with positional arguments
    if (args_list.Get().empty()) {
      log.err("binary path required when using -s/--spawn flag");
      return 1;
    }

    std::vector<std::string> all_args = args::get(args_list);
    std::string binary_path = all_args[0];

    // extract arguments after the binary (everything after first arg)
    std::vector<std::string> binary_args;
    if (all_args.size() > 1) {
      binary_args.assign(all_args.begin() + 1, all_args.end());
    }

    // spawn always uses preload injection
    w1::inject::method injection_method = w1::inject::method::preload;
    std::string method_name = "preload";

    log.info(
        "spawn injection starting", redlog::field("method", method_name), redlog::field("binary", binary_path),
        redlog::field("library", lib_path), redlog::field("args_count", binary_args.size()),
        redlog::field("suspended", suspended_flag ? "true" : "false")
    );

    // use full config for spawn injection to support arguments and suspended flag
    w1::inject::config cfg;
    cfg.library_path = lib_path;
    cfg.injection_method = injection_method;
    cfg.binary_path = binary_path;
    cfg.args = binary_args;
    cfg.suspended = suspended_flag;
    cfg.wait_for_completion = true; // inject command should wait for completion

    result = w1::inject::inject(cfg);

  } else if (pid_flag) {
    // runtime injection by pid
    int target_pid = args::get(pid_flag);
    log.info(
        "runtime injection starting", redlog::field("method", "pid"), redlog::field("target_pid", target_pid),
        redlog::field("library", lib_path)
    );

    w1::inject::config cfg;
    cfg.library_path = lib_path;
    cfg.injection_method = w1::inject::method::runtime;
    cfg.pid = target_pid;

    result = w1::inject::inject(cfg);

  } else if (process_name_flag) {
    // runtime injection by process name
    std::string process_name = args::get(process_name_flag);
    log.info(
        "runtime injection starting", redlog::field("method", "name"), redlog::field("process_name", process_name),
        redlog::field("library", lib_path)
    );

    w1::inject::config cfg;
    cfg.library_path = lib_path;
    cfg.injection_method = w1::inject::method::runtime;
    cfg.process_name = process_name;

    result = w1::inject::inject(cfg);

  } else {
    log.err("target required: specify -s/--spawn, --pid, or --process-name");
    return 1;
  }

  // handle result
  if (result.success()) {
    if (result.target_pid > 0) {
      log.info("injection completed successfully", redlog::field("target_pid", result.target_pid));
    } else {
      log.info("injection completed successfully");
    }
    return 0;
  } else {
    log.err("injection failed", redlog::field("error", result.error_message));
    return 1;
  }
}

} // namespace w1tool::commands
```

`src/w1tool/commands/inject.hpp`:

```hpp
#pragma once

#include "ext/args.hpp"

namespace w1tool::commands {

/**
 * inject command - injects libraries into target processes with modern CLI
 *
 * @param library_flag path to injection library
 * @param spawn_flag spawn new process for injection (uses preload)
 * @param pid_flag target process ID (uses runtime injection)
 * @param process_name_flag target process name (uses runtime injection)
 * @param suspended_flag start process in suspended state (only with spawn)
 * @param args_list binary and arguments (use -- to separate w1tool args from target args)
 * @return exit code (0 for success, 1 for failure)
 */
int inject(
    args::ValueFlag<std::string>& library_flag, args::Flag& spawn_flag, args::ValueFlag<int>& pid_flag,
    args::ValueFlag<std::string>& process_name_flag, args::Flag& suspended_flag,
    args::PositionalList<std::string>& args_list
);

} // namespace w1tool::commands
```

`src/w1tool/commands/inspect.cpp`:

```cpp
#include "inspect.hpp"
#include <redlog.hpp>

namespace w1tool::commands {

int inspect(args::ValueFlag<std::string>& binary_flag) {

  auto log = redlog::get_logger("w1tool.inspect");

  log.info("binary inspection starting");

  // get arguments
  if (binary_flag) {
    std::string binary_path = args::get(binary_flag);
    log.info("target binary specified", redlog::field("binary_path", binary_path));

    log.warn("binary analysis not yet implemented");
  } else {
    log.error("binary path required for inspection");
    return 1;
  }

  return 0;
}

} // namespace w1tool::commands
```

`src/w1tool/commands/inspect.hpp`:

```hpp
#pragma once

#include "ext/args.hpp"

namespace w1tool::commands {

/**
 * inspect command - analyzes binary files
 *
 * @param binary_flag path to binary file to inspect
 * @return exit code (0 for success, 1 for failure)
 */
int inspect(args::ValueFlag<std::string>& binary_flag);

} // namespace w1tool::commands
```

`src/w1tool/commands/read_drcov.cpp`:

```cpp
#include "read_drcov.hpp"
#include <w1tn3ss/formats/drcov.hpp>
#include <iomanip>
#include <iostream>
#include <locale>
#include <redlog.hpp>
#include <sstream>

namespace w1tool::commands {

// helper function to format hit counts with K/M/B suffixes
std::string format_hits(uint64_t hits) {
  if (hits >= 1000000000) {
    double b = static_cast<double>(hits) / 1000000000.0;
    std::stringstream ss;
    ss << std::fixed << std::setprecision(1) << b << "B";
    return ss.str();
  } else if (hits >= 1000000) {
    double m = static_cast<double>(hits) / 1000000.0;
    std::stringstream ss;
    ss << std::fixed << std::setprecision(1) << m << "M";
    return ss.str();
  } else if (hits >= 1000) {
    double k = static_cast<double>(hits) / 1000.0;
    std::stringstream ss;
    ss << std::fixed << std::setprecision(1) << k << "K";
    return ss.str();
  } else {
    return std::to_string(hits);
  }
}

// helper function to format byte sizes with KB/MB/GB suffixes
std::string format_bytes(uint64_t bytes) {
  if (bytes >= 1024ULL * 1024 * 1024) {
    double gb = static_cast<double>(bytes) / (1024.0 * 1024.0 * 1024.0);
    std::stringstream ss;
    ss << std::fixed << std::setprecision(1) << gb << " GB";
    return ss.str();
  } else if (bytes >= 1024 * 1024) {
    double mb = static_cast<double>(bytes) / (1024.0 * 1024.0);
    std::stringstream ss;
    ss << std::fixed << std::setprecision(1) << mb << " MB";
    return ss.str();
  } else if (bytes >= 1024) {
    double kb = static_cast<double>(bytes) / 1024.0;
    std::stringstream ss;
    ss << std::fixed << std::setprecision(1) << kb << " KB";
    return ss.str();
  } else {
    return std::to_string(bytes) + " B";
  }
}

// helper function to format plain numbers (for counts)
std::string format_number(uint64_t number) {
  try {
    std::stringstream ss;
    ss.imbue(std::locale(""));
    ss << number;
    return ss.str();
  } catch (...) {
    // fallback: manual formatting with commas
    std::string str = std::to_string(number);
    std::string result;
    int count = 0;
    for (auto it = str.rbegin(); it != str.rend(); ++it) {
      if (count > 0 && count % 3 == 0) {
        result = ',' + result;
      }
      result = *it + result;
      count++;
    }
    return result;
  }
}

int read_drcov(
    args::ValueFlag<std::string>& file_flag, args::Flag& summary_flag, args::Flag& detailed_flag,
    args::ValueFlag<std::string>& module_flag
) {

  auto log = redlog::get_logger("w1tool.read-drcov");

  if (!file_flag) {
    log.error("drCov file path required");
    return 1;
  }

  std::string file_path = args::get(file_flag);
  log.info("analyzing DrCov file", redlog::field("file", file_path));

  try {
    // read and parse the DrCov file
    auto coverage_data = drcov::read(file_path);

    // print header information
    std::cout << "=== DrCov File Analysis ===\n";
    std::cout << "file: " << file_path << "\n";
    std::cout << "version: " << coverage_data.header.version << "\n";
    std::cout << "flavor: " << coverage_data.header.flavor << "\n";
    std::cout << "module table version: " << static_cast<uint32_t>(coverage_data.module_version) << "\n";
    std::cout << "has hitcounts: " << (coverage_data.has_hitcounts() ? "yes" : "no") << "\n";
    std::cout << "\n";

    // print summary
    std::cout << "=== Summary ===\n";
    std::cout << "total modules: " << format_number(coverage_data.modules.size()) << "\n";
    std::cout << "total basic blocks: " << format_number(coverage_data.basic_blocks.size()) << "\n";

    // calculate coverage stats
    auto stats = coverage_data.get_coverage_stats();
    uint64_t total_coverage_bytes = 0;
    uint64_t total_hitcount = 0;

    for (size_t i = 0; i < coverage_data.basic_blocks.size(); ++i) {
      const auto& bb = coverage_data.basic_blocks[i];
      total_coverage_bytes += bb.size;

      if (coverage_data.has_hitcounts() && i < coverage_data.hitcounts.size()) {
        total_hitcount += coverage_data.hitcounts[i];
      }
    }

    std::cout << "total coverage: " << format_bytes(total_coverage_bytes) << "\n";
    if (coverage_data.has_hitcounts()) {
      std::cout << "total hits: " << format_hits(total_hitcount) << "\n";
      std::cout << "average hits per block: " << std::fixed << std::setprecision(2)
                << (coverage_data.basic_blocks.empty()
                        ? 0.0
                        : static_cast<double>(total_hitcount) / coverage_data.basic_blocks.size())
                << "\n";
    }
    std::cout << "\n";

    // module summary
    std::cout << "=== Module Coverage ===\n";
    if (coverage_data.has_hitcounts()) {
      std::cout << std::left << std::setw(4) << "ID" << std::setw(8) << "Blocks" << std::setw(12) << "Size"
                << std::setw(12) << "Total Hits" << std::setw(20) << "Base Address"
                << "Name\n";
      std::cout << std::string(72, '-') << "\n";
    } else {
      std::cout << std::left << std::setw(4) << "ID" << std::setw(8) << "Blocks" << std::setw(12) << "Size"
                << std::setw(20) << "Base Address"
                << "Name\n";
      std::cout << std::string(60, '-') << "\n";
    }

    for (const auto& module : coverage_data.modules) {
      auto it = stats.find(module.id);
      size_t block_count = (it != stats.end()) ? it->second : 0;

      // calculate total bytes and hits for this module
      uint64_t module_bytes = 0;
      uint64_t module_hits = 0;

      for (size_t i = 0; i < coverage_data.basic_blocks.size(); ++i) {
        const auto& bb = coverage_data.basic_blocks[i];
        if (bb.module_id == module.id) {
          module_bytes += bb.size;
          if (coverage_data.has_hitcounts() && i < coverage_data.hitcounts.size()) {
            module_hits += coverage_data.hitcounts[i];
          }
        }
      }

      if (coverage_data.has_hitcounts()) {
        std::cout << std::left << std::setw(4) << module.id << std::setw(8) << format_number(block_count)
                  << std::setw(12) << format_bytes(module_bytes) << std::setw(12) << format_hits(module_hits) << "0x"
                  << std::hex << std::setw(15) << module.base << std::dec << "         " << module.path << "\n";
      } else {
        std::cout << std::left << std::setw(4) << module.id << std::setw(8) << format_number(block_count)
                  << std::setw(12) << format_bytes(module_bytes) << "0x" << std::hex << std::setw(15) << module.base
                  << std::dec << "         " << module.path << "\n";
      }
    }
    std::cout << "\n";

    // detailed analysis if requested
    if (detailed_flag) {
      std::cout << "=== Detailed Basic Blocks ===\n";
      if (coverage_data.has_hitcounts()) {
        std::cout << std::left << std::setw(8) << "Module" << std::setw(14) << "Offset" << std::setw(8) << "Size"
                  << std::setw(10) << "Hitcount" << std::setw(18) << "Absolute Address"
                  << "Module Name\n";
        std::cout << std::string(90, '-') << "\n";
      } else {
        std::cout << std::left << std::setw(8) << "Module" << std::setw(14) << "Offset" << std::setw(8) << "Size"
                  << std::setw(18) << "Absolute Address"
                  << "Module Name\n";
        std::cout << std::string(80, '-') << "\n";
      }

      for (size_t i = 0; i < coverage_data.basic_blocks.size(); ++i) {
        const auto& bb = coverage_data.basic_blocks[i];
        if (bb.module_id < coverage_data.modules.size()) {
          const auto& module = coverage_data.modules[bb.module_id];
          uint64_t abs_addr = bb.absolute_address(module);

          if (coverage_data.has_hitcounts() && i < coverage_data.hitcounts.size()) {
            uint32_t hitcount = coverage_data.hitcounts[i];
            std::cout << std::left << std::setw(8) << bb.module_id << "0x" << std::hex << std::setw(11) << bb.start
                      << std::dec << std::setw(8) << bb.size << std::setw(10) << hitcount << "0x" << std::hex
                      << std::setw(15) << abs_addr << std::dec << "   " << module.path << "\n";
          } else {
            std::cout << std::left << std::setw(8) << bb.module_id << "0x" << std::hex << std::setw(11) << bb.start
                      << std::dec << std::setw(8) << bb.size << "0x" << std::hex << std::setw(15) << abs_addr
                      << std::dec << "   " << module.path << "\n";
          }
        }
      }
      std::cout << "\n";
    }

    // module-specific analysis if requested
    if (module_flag) {
      std::string module_filter = args::get(module_flag);
      std::cout << "=== Module-Specific Analysis: " << module_filter << " ===\n";

      // find matching modules (by name substring)
      bool found = false;
      for (const auto& module : coverage_data.modules) {
        if (module.path.find(module_filter) != std::string::npos) {
          found = true;

          std::cout << "module ID: " << module.id << "\n";
          std::cout << "name: " << module.path << "\n";
          std::cout << "base: 0x" << std::hex << module.base << std::dec << "\n";
          std::cout << "end: 0x" << std::hex << module.end << std::dec << "\n";
          std::cout << "size: " << (module.end - module.base) << " bytes\n";

          // count blocks for this module
          auto it = stats.find(module.id);
          size_t block_count = (it != stats.end()) ? it->second : 0;
          std::cout << "covered blocks: " << format_number(block_count) << "\n";

          uint64_t module_bytes = 0;
          uint64_t module_hits = 0;

          for (size_t i = 0; i < coverage_data.basic_blocks.size(); ++i) {
            const auto& bb = coverage_data.basic_blocks[i];
            if (bb.module_id == module.id) {
              module_bytes += bb.size;
              if (coverage_data.has_hitcounts() && i < coverage_data.hitcounts.size()) {
                module_hits += coverage_data.hitcounts[i];
              }
            }
          }

          std::cout << "covered bytes: " << format_bytes(module_bytes) << "\n";
          if (coverage_data.has_hitcounts()) {
            std::cout << "total hits: " << format_hits(module_hits) << "\n";
            std::cout << "average hits per block: " << std::fixed << std::setprecision(2)
                      << (block_count == 0 ? 0.0 : static_cast<double>(module_hits) / block_count) << "\n";
          }
          std::cout << "\n";
        }
      }

      if (!found) {
        std::cout << "no modules found matching: " << module_filter << "\n";
      }
    }

    return 0;

  } catch (const drcov::parse_error& e) {
    log.error(
        "failed to parse DrCov file", redlog::field("error", e.what()),
        redlog::field("code", static_cast<int>(e.code()))
    );
    return 1;
  } catch (const std::exception& e) {
    log.error("error analyzing DrCov file", redlog::field("error", e.what()));
    return 1;
  }
}

} // namespace w1tool::commands
```

`src/w1tool/commands/read_drcov.hpp`:

```hpp
#pragma once

#include "ext/args.hpp"

namespace w1tool::commands {

/**
 * read-DrCov command - analyzes DrCov coverage files
 *
 * @param file_flag path to DrCov file to analyze
 * @param summary_flag show summary only (optional)
 * @param detailed_flag show detailed basic block listing (optional)
 * @param module_flag filter by module name substring (optional)
 * @return exit code (0 for success, 1 for failure)
 */
int read_drcov(
    args::ValueFlag<std::string>& file_flag, args::Flag& summary_flag, args::Flag& detailed_flag,
    args::ValueFlag<std::string>& module_flag
);

} // namespace w1tool::commands
```

`src/w1tool/commands/tracer.cpp`:

```cpp
#include "tracer.hpp"

#include <algorithm>
#include <cstdlib>
#include <filesystem>
#include <iostream>

#include <redlog.hpp>

#include <w1common/platform_utils.hpp>
#include "tracer_discovery.hpp"
#include "w1nj3ct.hpp"
#include "w1tn3ss/util/signal_handler.hpp"

// forward declare CLI symbols from main.cpp
namespace cli {
extern args::CounterFlag verbosity_flag;
}

namespace w1tool::commands {

/**
 * convert tracer config key to environment variable name
 */
std::string make_env_var_name(const std::string& tracer_name, const std::string& config_key) {
  std::string env_name = tracer_name;

  // convert to uppercase
  std::transform(env_name.begin(), env_name.end(), env_name.begin(), ::toupper);

  // add config key in uppercase
  std::string upper_key = config_key;
  std::transform(upper_key.begin(), upper_key.end(), upper_key.begin(), ::toupper);

  return env_name + "_" + upper_key;
}

/**
 * parse config string in format "key=value"
 */
std::pair<std::string, std::string> parse_config_string(const std::string& config_str) {
  const size_t eq_pos = config_str.find('=');
  if (eq_pos == std::string::npos || eq_pos == 0 || eq_pos == config_str.length() - 1) {
    return {"", ""};
  }

  const std::string key = config_str.substr(0, eq_pos);
  const std::string value = config_str.substr(eq_pos + 1);

  return {key, value};
}

int tracer(
    args::ValueFlag<std::string>& library_flag, args::ValueFlag<std::string>& name_flag, args::Flag& spawn_flag,
    args::ValueFlag<int>& pid_flag, args::ValueFlag<std::string>& process_name_flag,
    args::ValueFlag<std::string>& output_flag, args::ValueFlagList<std::string>& config_flags,
    args::ValueFlag<int>& debug_level_flag, args::Flag& list_tracers_flag, args::Flag& suspended_flag,
    args::PositionalList<std::string>& args_list, const std::string& executable_path
) {
  auto log = redlog::get_logger("w1tool.tracer");

  // handle --list-tracers flag
  if (list_tracers_flag) {
    const auto available_tracers = w1tool::tracer_discovery::list_available_tracers(executable_path);

    if (available_tracers.empty()) {
      std::cout << "no tracer libraries found\n";
      std::cout << "searched paths relative to: " << executable_path << "\n";
      return 0;
    }

    std::cout << "available tracers:\n";
    for (const auto& tracer : available_tracers) {
      std::cout << "  " << tracer.name << " - " << tracer.library_path << "\n";
    }
    return 0;
  }

  // validate tracer name
  if (!name_flag) {
    log.err("tracer name required: specify -n/--name (use --list-tracers to see available options)");
    return 1;
  }

  const std::string tracer_name = args::get(name_flag);

  // validate target
  int target_count = 0;
  if (spawn_flag) {
    target_count++;
  }
  if (pid_flag) {
    target_count++;
  }
  if (process_name_flag) {
    target_count++;
  }

  if (target_count != 1) {
    log.err("exactly one target required: specify -s/--spawn, --pid, or --process-name");
    return 1;
  }

  // validate suspended flag
  if (suspended_flag && !spawn_flag) {
    log.err("--suspended can only be used with -s/--spawn (launch tracing)");
    return 1;
  }

  // build execution parameters
  tracer_execution_params params;
  params.tracer_name = tracer_name;
  params.executable_path = executable_path;

  if (library_flag) {
    params.library_path = args::get(library_flag);
  }

  // set debug level
  if (debug_level_flag) {
    params.debug_level = args::get(debug_level_flag);
  } else {
    params.debug_level = args::get(cli::verbosity_flag);
  }

  // process config
  if (config_flags) {
    for (const std::string& config_str : args::get(config_flags)) {
      auto [key, value] = parse_config_string(config_str);

      if (key.empty() || value.empty()) {
        log.err("invalid config format, expected key=value", redlog::field("config", config_str));
        return 1;
      }

      params.config_map[key] = value;
    }
  }

  // process output flag
  if (output_flag) {
    params.config_map["output"] = args::get(output_flag);
  }

  // set target
  if (spawn_flag) {
    if (args_list.Get().empty()) {
      log.err("binary path required when using -s/--spawn flag");
      return 1;
    }

    std::vector<std::string> all_args = args::get(args_list);
    params.spawn_target = true;
    params.binary_path = all_args[0];
    params.suspended = suspended_flag;

    // extract binary arguments
    if (all_args.size() > 1) {
      params.binary_args.assign(all_args.begin() + 1, all_args.end());
    }

  } else if (pid_flag) {
    params.target_pid = args::get(pid_flag);

  } else if (process_name_flag) {
    params.process_name = args::get(process_name_flag);
  }

  return execute_tracer_impl(params);
}

int execute_tracer_impl(const tracer_execution_params& params) {
  auto log = redlog::get_logger("w1tool.tracer");

  // log platform info
  const std::string platform = w1::common::platform_utils::get_platform_name();
  log.debug("platform detected", redlog::field("platform", platform));

  if (!w1::common::platform_utils::supports_runtime_injection()) {
    log.warn("runtime injection may not be supported on this platform", redlog::field("platform", platform));
  }

  // initialize signal handling
  w1::tn3ss::signal_handler::config sig_config;
  sig_config.context_name = "w1tool";
  sig_config.log_signals = (args::get(cli::verbosity_flag) >= 1);

  w1::tn3ss::signal_handler::guard signal_guard(sig_config);
  if (!signal_guard.is_initialized()) {
    log.warn("failed to initialize signal handling system");
  }

  // register signal handler
  w1::tn3ss::signal_handler::register_handler(
      [](const std::string& context) {
        auto signal_log = redlog::get_logger("w1tool.signal");
        signal_log.info("received shutdown signal", redlog::field("context", context));
      },
      "tracer"
  );

  // determine library path
  std::string lib_path = params.library_path;
  if (lib_path.empty()) {
    // auto-discover path
    log.debug("attempting to auto-discover tracer library", redlog::field("tracer_name", params.tracer_name));

    lib_path = w1tool::tracer_discovery::find_tracer_library(params.executable_path, params.tracer_name);

    if (lib_path.empty()) {
      log.err("tracer library not found", redlog::field("tracer_name", params.tracer_name));
      log.info("use --list-tracers to see available options, or specify path with -L/--library");
      return 1;
    }

    log.info(
        "auto-discovered library", redlog::field("tracer_name", params.tracer_name), redlog::field("path", lib_path)
    );
  } else {
    log.debug("using explicit tracer library", redlog::field("path", lib_path));
  }

  // validate library path exists
  if (!std::filesystem::exists(lib_path)) {
    log.err("tracer library does not exist", redlog::field("path", lib_path));
    return 1;
  }

  // prepare injection configuration
  w1::inject::config cfg;
  cfg.library_path = lib_path;

  // set debug level for tracer
  std::string debug_env_var = make_env_var_name(params.tracer_name, "verbose");
  cfg.env_vars[debug_env_var] = std::to_string(params.debug_level);

  // add config entries
  for (const auto& [key, value] : params.config_map) {
    std::string env_var = make_env_var_name(params.tracer_name, key);
    cfg.env_vars[env_var] = value;

    log.debug(
        "added config", redlog::field("key", key), redlog::field("value", value), redlog::field("env_var", env_var)
    );
  }

  log.info(
      "tracer configuration", redlog::field("tracer", params.tracer_name), redlog::field("library", lib_path),
      redlog::field("debug_level", params.debug_level), redlog::field("env_vars_count", cfg.env_vars.size())
  );

  w1::inject::result result;

  // execute tracing
  if (params.spawn_target) {
    // launch tracing
    log.info(
        "starting launch-time tracing", redlog::field("tracer", params.tracer_name),
        redlog::field("binary", params.binary_path), redlog::field("args_count", params.binary_args.size()),
        redlog::field("suspended", params.suspended ? "true" : "false")
    );

    cfg.injection_method = w1::inject::method::preload;
    cfg.binary_path = params.binary_path;
    cfg.args = params.binary_args;
    cfg.suspended = params.suspended;
    cfg.wait_for_completion = true;

    result = w1::inject::inject(cfg);

    // setup signal forwarding
    if (result.success() && result.target_pid > 0) {
      w1::tn3ss::signal_handler::setup_forwarding(result.target_pid);

      // register cleanup handler
      w1::tn3ss::signal_handler::register_cleanup(
          [target_pid = result.target_pid]() { w1::tn3ss::signal_handler::remove_forwarding(target_pid); },
          100, // high priority
          "tracer_cleanup_" + std::to_string(result.target_pid)
      );

      log.debug("signal forwarding established", redlog::field("target_pid", result.target_pid));
    }

  } else if (params.target_pid > 0) {
    // runtime tracing by pid
    log.info(
        "starting runtime tracing", redlog::field("tracer", params.tracer_name), redlog::field("method", "pid"),
        redlog::field("target_pid", params.target_pid)
    );

    cfg.injection_method = w1::inject::method::runtime;
    cfg.pid = params.target_pid;
    result = w1::inject::inject(cfg);

    // setup signal forwarding
    if (result.success() && result.target_pid > 0) {
      w1::tn3ss::signal_handler::setup_forwarding(result.target_pid);

      // register cleanup handler
      w1::tn3ss::signal_handler::register_cleanup(
          [target_pid = result.target_pid]() { w1::tn3ss::signal_handler::remove_forwarding(target_pid); },
          100, // high priority
          "tracer_cleanup_" + std::to_string(result.target_pid)
      );

      log.debug("signal forwarding established", redlog::field("target_pid", result.target_pid));
    }

  } else if (!params.process_name.empty()) {
    // runtime tracing by name
    log.info(
        "starting runtime tracing", redlog::field("tracer", params.tracer_name), redlog::field("method", "name"),
        redlog::field("process_name", params.process_name)
    );

    cfg.injection_method = w1::inject::method::runtime;
    cfg.process_name = params.process_name;
    result = w1::inject::inject(cfg);

    // setup signal forwarding
    if (result.success() && result.target_pid > 0) {
      w1::tn3ss::signal_handler::setup_forwarding(result.target_pid);

      // register cleanup handler
      w1::tn3ss::signal_handler::register_cleanup(
          [target_pid = result.target_pid]() { w1::tn3ss::signal_handler::remove_forwarding(target_pid); },
          100, // high priority
          "tracer_cleanup_" + std::to_string(result.target_pid)
      );

      log.debug("signal forwarding established", redlog::field("target_pid", result.target_pid));
    }
  } else {
    log.err("no valid target specified");
    return 1;
  }

  // handle result
  if (result.success()) {
    log.info("tracing completed successfully", redlog::field("tracer", params.tracer_name));
    if (result.target_pid > 0) {
      log.info("target process", redlog::field("pid", result.target_pid));
    }

    std::cout << "tracing with " << params.tracer_name << " completed successfully.\n";
    return 0;
  } else {
    log.err(
        "tracing failed", redlog::field("tracer", params.tracer_name), redlog::field("error", result.error_message)
    );
    return 1;
  }
}

} // namespace w1tool::commands
```

`src/w1tool/commands/tracer.hpp`:

```hpp
#pragma once

#include "ext/args.hpp"
#include <map>
#include <string>
#include <vector>

namespace w1tool::commands {

/**
 * tracer execution parameters
 */
struct tracer_execution_params {
  std::string tracer_name;
  std::string library_path; // optional, empty for auto-discovery
  std::map<std::string, std::string> config_map;
  int debug_level = 0;

  // target specification (exactly one should be set)
  bool spawn_target = false;
  std::string binary_path;
  std::vector<std::string> binary_args;
  bool suspended = false;

  int target_pid = -1;
  std::string process_name;

  std::string executable_path; // for auto-discovery
};

/**
 * execute tracer with given parameters (shared implementation)
 */
int execute_tracer_impl(const tracer_execution_params& params);

/**
 * tracer command - generic tracer launcher with flexible configuration
 */
int tracer(
    args::ValueFlag<std::string>& library_flag, args::ValueFlag<std::string>& name_flag, args::Flag& spawn_flag,
    args::ValueFlag<int>& pid_flag, args::ValueFlag<std::string>& process_name_flag,
    args::ValueFlag<std::string>& output_flag, args::ValueFlagList<std::string>& config_flags,
    args::ValueFlag<int>& debug_level_flag, args::Flag& list_tracers_flag, args::Flag& suspended_flag,
    args::PositionalList<std::string>& args_list, const std::string& executable_path
);

} // namespace w1tool::commands
```

`src/w1tool/main.cpp`:

```cpp
#include <cstdlib>
#include <iostream>
#include <string>

#include <redlog.hpp>
#include "ext/args.hpp"

#include "commands/cover.hpp"
#include "commands/inject.hpp"
#include "commands/inspect.hpp"
#include "commands/read_drcov.hpp"
#include "commands/tracer.hpp"

namespace cli {
args::Group arguments("arguments");
args::HelpFlag help_flag(arguments, "help", "help", {'h', "help"});
args::CounterFlag verbosity_flag(arguments, "verbosity", "verbosity level", {'v'});

void apply_verbosity() {
  // apply verbosity
  int verbosity = args::get(verbosity_flag);
  redlog::set_level(redlog::level::info);
  if (verbosity == 1) {
    redlog::set_level(redlog::level::verbose);
  } else if (verbosity == 2) {
    redlog::set_level(redlog::level::trace);
  } else if (verbosity == 3) {
    redlog::set_level(redlog::level::debug);
  } else if (verbosity >= 4) {
    redlog::set_level(redlog::level::pedantic);
  }
}
} // namespace cli

namespace {
auto log_main = redlog::get_logger("w1tool");
std::string g_executable_path;
} // namespace

void cmd_inject(args::Subparser& parser) {
  cli::apply_verbosity();

  args::ValueFlag<std::string> library(parser, "path", "path to injection library", {'L', "library"});
  args::Flag spawn(parser, "spawn", "spawn new process for injection (uses preload)", {'s', "spawn"});
  args::ValueFlag<int> pid(parser, "pid", "target process id (uses runtime injection)", {'p', "pid"});
  args::ValueFlag<std::string> process_name(
      parser, "process", "target process name (uses runtime injection)", {"process-name"}
  );
  args::Flag suspended(parser, "suspended", "start process in suspended state (only with --spawn)", {"suspended"});
  args::PositionalList<std::string> args(parser, "args", "binary -- arguments");
  parser.Parse();

  w1tool::commands::inject(library, spawn, pid, process_name, suspended, args);
}

void cmd_inspect(args::Subparser& parser) {
  cli::apply_verbosity();

  args::ValueFlag<std::string> binary(parser, "path", "path to binary file", {'b', "binary"});
  parser.Parse();

  w1tool::commands::inspect(binary);
}

void cmd_cover(args::Subparser& parser) {
  cli::apply_verbosity();

  args::ValueFlag<std::string> library(parser, "path", "path to w1cov library", {'L', "w1cov-library"});
  args::Flag spawn(parser, "spawn", "spawn new process for tracing", {'s', "spawn"});
  args::ValueFlag<int> pid(parser, "pid", "process ID to attach to", {'p', "pid"});
  args::ValueFlag<std::string> name(parser, "name", "process name to attach to", {'n', "name"});
  args::ValueFlag<std::string> output(parser, "path", "output file path", {'o', "output"});
  args::Flag include_system(parser, "include-system", "include system libraries", {"include-system"});
  args::Flag inst_trace(parser, "inst-trace", "enable instruction-level tracing (default: basic block)", {"inst"});
  args::ValueFlag<std::string> module_filter(
      parser, "modules", "comma-separated list of modules to filter", {'m', "module-filter"}
  );
  args::ValueFlag<int> debug_level(parser, "level", "debug level override", {"debug"});
  args::ValueFlag<std::string> format(parser, "format", "output format (drcov, text)", {"format"});
  args::Flag suspended(parser, "suspended", "start process in suspended state (only with --spawn)", {"suspended"});
  args::PositionalList<std::string> args(parser, "args", "binary -- arguments");
  parser.Parse();

  w1tool::commands::cover(
      library, spawn, pid, name, output, include_system, inst_trace, module_filter, debug_level, format, suspended,
      args, g_executable_path
  );
}

void cmd_read_drcov(args::Subparser& parser) {
  cli::apply_verbosity();

  args::ValueFlag<std::string> file(parser, "path", "path to DrCov file", {'f', "file"});
  args::Flag summary(parser, "summary", "show summary only", {'s', "summary"});
  args::Flag detailed(parser, "detailed", "show detailed basic block listing", {'d', "detailed"});
  args::ValueFlag<std::string> module(parser, "module", "filter by module name (substring match)", {'m', "module"});
  parser.Parse();

  w1tool::commands::read_drcov(file, summary, detailed, module);
}

void cmd_tracer(args::Subparser& parser) {
  cli::apply_verbosity();

  args::ValueFlag<std::string> library(parser, "path", "path to tracer library", {'L', "library"});
  args::ValueFlag<std::string> name(parser, "name", "tracer name (w1cov, w1mem, mintrace, etc.)", {'n', "name"});
  args::Flag spawn(parser, "spawn", "spawn new process for tracing", {'s', "spawn"});
  args::ValueFlag<int> pid(parser, "pid", "process ID to attach to", {'p', "pid"});
  args::ValueFlag<std::string> process_name(parser, "process", "process name to attach to", {"process-name"});
  args::ValueFlag<std::string> output(parser, "path", "output file path", {'o', "output"});
  args::ValueFlagList<std::string> config(parser, "config", "configuration key=value pairs", {'c', "config"});
  args::ValueFlag<int> debug_level(parser, "level", "debug level override", {"debug"});
  args::Flag list_tracers(parser, "list", "list available tracers", {"list-tracers"});
  args::Flag suspended(parser, "suspended", "start process in suspended state (only with --spawn)", {"suspended"});
  args::PositionalList<std::string> args(parser, "args", "binary -- arguments");
  parser.Parse();

  w1tool::commands::tracer(
      library, name, spawn, pid, process_name, output, config, debug_level, list_tracers, suspended, args,
      g_executable_path
  );
}

int main(int argc, char* argv[]) {
  // store executable path for library auto-discovery
  g_executable_path = argv[0];

  args::ArgumentParser parser(
      "w1tool - cross-platform dynamic binary analysis tool", "inject libraries, trace coverage, and analyze binaries"
  );
  parser.helpParams.showTerminator = false;

  args::GlobalOptions globals(parser, cli::arguments);
  args::Group commands(parser, "commands");

  args::Command inject_cmd(commands, "inject", "inject library into target process", &cmd_inject);
  args::Command inspect_cmd(commands, "inspect", "inspect binary file", &cmd_inspect);
  args::Command cover_cmd(commands, "cover", "perform coverage tracing with configurable options", &cmd_cover);
  args::Command read_drcov_cmd(commands, "read-drcov", "analyze DrCov coverage files", &cmd_read_drcov);
  args::Command tracer_cmd(commands, "tracer", "run arbitrary tracer with flexible configuration", &cmd_tracer);

  try {
    parser.ParseCLI(argc, argv);
  } catch (args::Help) {
    std::cout << parser;
  } catch (args::Error& e) {
    std::cerr << e.what() << std::endl << parser;
    return 1;
  }

  return 0;
}
```

`src/w1tool/tracer_discovery.cpp`:

```cpp
#include "tracer_discovery.hpp"

#include <algorithm>
#include <filesystem>

#include <redlog.hpp>

#include <w1common/platform_utils.hpp>

namespace w1tool::tracer_discovery {

std::string extract_tracer_name(const std::string& library_filename) {
  auto log = redlog::get_logger("w1tool.tracer_discovery");

  // expect format: {tracer_name}_qbdipreload.{ext}
  const std::string suffix = "_qbdipreload";

  // find the suffix in the filename
  size_t suffix_pos = library_filename.find(suffix);
  if (suffix_pos == std::string::npos) {
    log.dbg(
        "library filename does not match expected pattern", redlog::field("filename", library_filename),
        redlog::field("expected_pattern", "*_qbdipreload.*")
    );
    return "";
  }

  // extract tracer name (everything before the suffix)
  std::string tracer_name = library_filename.substr(0, suffix_pos);

  if (tracer_name.empty()) {
    log.dbg("extracted empty tracer name", redlog::field("filename", library_filename));
    return "";
  }

  log.dbg(
      "extracted tracer name", redlog::field("filename", library_filename), redlog::field("tracer_name", tracer_name)
  );

  return tracer_name;
}

std::map<std::string, std::string> find_tracer_libraries(const std::string& executable_path) {
  auto log = redlog::get_logger("w1tool.tracer_discovery");
  std::map<std::string, std::string> tracers;

  // convert executable path to absolute path
  std::filesystem::path exec_path;
  try {
    exec_path = std::filesystem::canonical(executable_path);
  } catch (const std::exception& e) {
    log.dbg(
        "failed to canonicalize executable path, using as-is", redlog::field("path", executable_path),
        redlog::field("error", e.what())
    );
    exec_path = std::filesystem::path(executable_path);
  }

  std::filesystem::path exec_dir = exec_path.parent_path();
  std::string lib_ext = w1::common::platform_utils::get_library_extension();

  log.dbg(
      "searching for tracer libraries", redlog::field("exec_dir", exec_dir.string()), redlog::field("lib_ext", lib_ext)
  );

  // search paths relative to executable directory
  std::vector<std::filesystem::path> search_dirs = {
      exec_dir,                // same directory as executable
      exec_dir / "lib",        // lib/ subdirectory
      exec_dir / ".." / "lib", // ../lib/ (for installed layouts)
      exec_dir / "..",         // parent directory
  };

  for (const auto& search_dir : search_dirs) {
    if (!std::filesystem::exists(search_dir) || !std::filesystem::is_directory(search_dir)) {
      continue;
    }

    log.dbg("scanning directory", redlog::field("dir", search_dir.string()));

    try {
      for (const auto& entry : std::filesystem::directory_iterator(search_dir)) {
        if (!entry.is_regular_file()) {
          continue;
        }

        std::string filename = entry.path().filename().string();

        // check if it matches the pattern *_qbdipreload{lib_ext}
        if (filename.find("_qbdipreload") == std::string::npos || !filename.ends_with(lib_ext)) {
          continue;
        }

        std::string tracer_name = extract_tracer_name(filename);
        if (tracer_name.empty()) {
          continue;
        }

        // if we haven't found this tracer yet, add it
        if (tracers.count(tracer_name) == 0) {
          std::string canonical_path = std::filesystem::canonical(entry.path()).string();
          tracers[tracer_name] = canonical_path;

          log.dbg("found tracer library", redlog::field("tracer", tracer_name), redlog::field("path", canonical_path));
        }
      }
    } catch (const std::exception& e) {
      log.dbg("error scanning directory", redlog::field("dir", search_dir.string()), redlog::field("error", e.what()));
    }
  }

  log.trc("tracer discovery complete", redlog::field("tracers_found", tracers.size()));

  return tracers;
}

std::string find_tracer_library(const std::string& executable_path, const std::string& tracer_name) {
  const auto tracers = find_tracer_libraries(executable_path);
  const auto it = tracers.find(tracer_name);
  return it != tracers.end() ? it->second : "";
}

std::vector<tracer_info> list_available_tracers(const std::string& executable_path) {
  const auto tracers = find_tracer_libraries(executable_path);
  std::vector<tracer_info> result;
  result.reserve(tracers.size());

  for (const auto& [name, path] : tracers) {
    result.push_back({name, path});
  }

  // sort by tracer name for consistent output
  std::sort(result.begin(), result.end(), [](const tracer_info& a, const tracer_info& b) -> bool {
    return a.name < b.name;
  });

  return result;
}

} // namespace w1tool::tracer_discovery
```

`src/w1tool/tracer_discovery.hpp`:

```hpp
#pragma once

#include <map>
#include <string>
#include <vector>

namespace w1tool::tracer_discovery {

/**
 * @brief Discovery result containing tracer name and library path
 */
struct tracer_info {
  std::string name;
  std::string library_path;
};

/**
 * @brief Find all available tracer libraries relative to the executable
 * @param executable_path path to the current executable
 * @return map of tracer names to their library paths
 */
std::map<std::string, std::string> find_tracer_libraries(const std::string& executable_path);

/**
 * @brief Find a specific tracer library by name
 * @param executable_path path to the current executable
 * @param tracer_name name of the tracer to find (e.g., "w1cov", "w1mem")
 * @return path to the library if found, empty string otherwise
 */
std::string find_tracer_library(const std::string& executable_path, const std::string& tracer_name);

/**
 * @brief Extract tracer name from library filename
 * @param library_filename filename of the library (e.g., "w1cov_qbdipreload.so")
 * @return tracer name (e.g., "w1cov") or empty string if invalid format
 */
std::string extract_tracer_name(const std::string& library_filename);

/**
 * @brief Get list of all available tracers
 * @param executable_path path to the current executable
 * @return vector of tracer information
 */
std::vector<tracer_info> list_available_tracers(const std::string& executable_path);

} // namespace w1tool::tracer_discovery
```

`tests/CMakeLists.txt`:

```txt
# w1nj3ct test suite

# build test programs and libraries
add_subdirectory(programs)
add_subdirectory(libraries)

# enable CMake testing framework
enable_testing()

# create test runner script
if(WIN32)
    set(TEST_SCRIPT_EXT ".bat")
    set(LIB_EXT ".dll")
else()
    set(TEST_SCRIPT_EXT ".sh")
    if(APPLE)
        set(LIB_EXT ".dylib")
    else()
        set(LIB_EXT ".so")
    endif()
endif()

# add p1ll pattern matching unit tests
if(WITNESS_SCRIPT)
    add_test(
        NAME p1ll_pattern_matching_tests
        COMMAND test_p1ll_pattern_matching
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/tests/programs
    )
    set_tests_properties(p1ll_pattern_matching_tests PROPERTIES
        LABELS "unit;p1ll;pattern_matching"
    )
endif()

```

`tests/libraries/CMakeLists.txt`:

```txt
# test injection libraries

# tracer library - basic injection verification
add_library(tracer_lib SHARED tracer_lib.c)
set_target_properties(tracer_lib PROPERTIES
    LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/tests/libraries
    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/tests/libraries
    PREFIX ""  # no lib prefix
)

# counter library - demonstrates exported functions
add_library(counter_lib SHARED counter_lib.c)
set_target_properties(counter_lib PROPERTIES
    LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/tests/libraries
    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/tests/libraries
    PREFIX ""  # no lib prefix
)

# memory tracking library - demonstrates system API usage
add_library(memory_lib SHARED memory_lib.c)
set_target_properties(memory_lib PROPERTIES
    LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/tests/libraries
    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/tests/libraries
    PREFIX ""  # no lib prefix
)

# linux-specific test library
if(UNIX AND NOT APPLE)
    add_library(linux_test_lib SHARED linux_test_lib.c)
    set_target_properties(linux_test_lib PROPERTIES
        LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/tests/libraries
        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/tests/libraries
        PREFIX ""  # no lib prefix
    )
    target_link_libraries(linux_test_lib PRIVATE ${CMAKE_DL_LIBS})
endif()

# injection libraries must not depend on sanitizers
# target processes may not have asan initialized
if(CMAKE_BUILD_TYPE STREQUAL "Debug" AND NOT WIN32)
    target_compile_options(tracer_lib PRIVATE -fno-sanitize=all)
    target_link_options(tracer_lib PRIVATE -fno-sanitize=all)
    
    target_compile_options(counter_lib PRIVATE -fno-sanitize=all)
    target_link_options(counter_lib PRIVATE -fno-sanitize=all)
    
    target_compile_options(memory_lib PRIVATE -fno-sanitize=all)
    target_link_options(memory_lib PRIVATE -fno-sanitize=all)
    
    # linux-specific library
    if(UNIX AND NOT APPLE)
        target_compile_options(linux_test_lib PRIVATE -fno-sanitize=all)
        target_link_options(linux_test_lib PRIVATE -fno-sanitize=all)
    endif()
endif()

# platform-specific linking
if(WIN32)
    target_link_libraries(memory_lib PRIVATE psapi)
    
    # set proper DLL extension
    set_target_properties(tracer_lib PROPERTIES SUFFIX ".dll")
    set_target_properties(counter_lib PROPERTIES SUFFIX ".dll")
    set_target_properties(memory_lib PROPERTIES SUFFIX ".dll")
elseif(APPLE)
    # set proper dylib extension
    set_target_properties(tracer_lib PROPERTIES SUFFIX ".dylib")
    set_target_properties(counter_lib PROPERTIES SUFFIX ".dylib")
    set_target_properties(memory_lib PROPERTIES SUFFIX ".dylib")
else()
    # linux - set proper so extension
    set_target_properties(tracer_lib PROPERTIES SUFFIX ".so")
    set_target_properties(counter_lib PROPERTIES SUFFIX ".so")
    set_target_properties(memory_lib PROPERTIES SUFFIX ".so")
    
    # linux-specific library
    if(TARGET linux_test_lib)
        set_target_properties(linux_test_lib PROPERTIES SUFFIX ".so")
    endif()
endif()

# install targets
set(LIBRARY_TARGETS tracer_lib counter_lib memory_lib)

# add linux-specific targets to install list
if(UNIX AND NOT APPLE)
    list(APPEND LIBRARY_TARGETS linux_test_lib)
endif()

install(TARGETS ${LIBRARY_TARGETS}
    LIBRARY DESTINATION tests/libraries
    RUNTIME DESTINATION tests/libraries
)
```

`tests/libraries/counter_lib.c`:

```c
#include <stdio.h>
#include <time.h>

#ifdef _WIN32
#include <windows.h>
#include <process.h>
#define getpid _getpid
static volatile LONG call_count = 0;

// Forward declarations
void counter_init();
void counter_cleanup();
void increment_counter();
int get_counter();

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    switch (fdwReason) {
        case DLL_PROCESS_ATTACH:
            counter_init();
            break;
        case DLL_PROCESS_DETACH:
            counter_cleanup();
            break;
    }
    return TRUE;
}

void counter_init() {
    printf("COUNTER: library loaded into PID %d\n", getpid());
    printf("COUNTER: call count initialized to 0\n");
}

void counter_cleanup() {
    printf("COUNTER: library unloaded, final call count: %ld\n", call_count);
}

void increment_counter() {
    LONG count = InterlockedIncrement(&call_count);
    printf("COUNTER: call count = %ld\n", count);
}

#else
#include <unistd.h>

#ifdef __GNUC__
#include <stdatomic.h>
static atomic_int call_count = 0;
#else
static volatile int call_count = 0;
#endif

__attribute__((constructor))
void counter_init() {
    printf("COUNTER: library loaded into PID %d\n", getpid());
    printf("COUNTER: call count initialized to 0\n");
}

__attribute__((destructor))
void counter_cleanup() {
    printf("COUNTER: library unloaded, final call count: %d\n", call_count);
}

void increment_counter() {
#ifdef __GNUC__
    int count = atomic_fetch_add(&call_count, 1) + 1;
#else
    int count = ++call_count; // not thread-safe fallback
#endif
    printf("COUNTER: call count = %d\n", count);
}

#endif

// get current count without incrementing
int get_counter() {
    return call_count;
}
```

`tests/libraries/linux_test_lib.c`:

```c
/*
 * Linux-specific test library for injection testing
 * Tests Linux-specific hooking and injection functionality
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <fcntl.h>
#include <string.h>
#include <time.h>
#include <syslog.h>
#include <errno.h>
#include <stdarg.h>

static int initialized = 0;
static FILE* log_file = NULL;

// Function pointers for original functions
static int (*orig_open)(const char *pathname, int flags, ...) = NULL;
static int (*orig_close)(int fd) = NULL;
static void* (*orig_malloc)(size_t size) = NULL;
static void (*orig_free)(void* ptr) = NULL;
static pid_t (*orig_getpid)(void) = NULL;

void log_message(const char* format, ...) {
    if (!log_file) return;
    
    va_list args;
    va_start(args, format);
    
    time_t now = time(NULL);
    struct tm* tm_info = localtime(&now);
    
    fprintf(log_file, "[%02d:%02d:%02d] ", tm_info->tm_hour, tm_info->tm_min, tm_info->tm_sec);
    vfprintf(log_file, format, args);
    fprintf(log_file, "\n");
    fflush(log_file);
    
    va_end(args);
}

void initialize_library() {
    if (initialized) return;
    
    // Open log file
    log_file = fopen("/tmp/linux_test_lib.log", "a");
    if (!log_file) {
        // Fallback to syslog
        openlog("linux_test_lib", LOG_PID, LOG_USER);
        syslog(LOG_INFO, "linux_test_lib: initialized (no log file)");
    } else {
        log_message("linux_test_lib: initialized (PID: %d)", getpid());
    }
    
    // Get original function pointers
    orig_open = dlsym(RTLD_NEXT, "open");
    orig_close = dlsym(RTLD_NEXT, "close");
    orig_malloc = dlsym(RTLD_NEXT, "malloc");
    orig_free = dlsym(RTLD_NEXT, "free");
    orig_getpid = dlsym(RTLD_NEXT, "getpid");
    
    initialized = 1;
    
    if (log_file) {
        log_message("linux_test_lib: function pointers resolved");
    }
}

void cleanup_library() {
    if (log_file) {
        log_message("linux_test_lib: cleaning up");
        fclose(log_file);
        log_file = NULL;
    }
    closelog();
}

// Constructor/destructor
__attribute__((constructor))
void library_init() {
    initialize_library();
}

__attribute__((destructor))
void library_cleanup() {
    cleanup_library();
}

// Hooked functions
int open(const char *pathname, int flags, ...) {
    initialize_library();
    
    if (!orig_open) {
        errno = ENOSYS;
        return -1;
    }
    
    mode_t mode = 0;
    if (flags & O_CREAT) {
        va_list args;
        va_start(args, flags);
        mode = va_arg(args, mode_t);
        va_end(args);
    }
    
    int result = orig_open(pathname, flags, mode);
    
    log_message("open(%s, %d) = %d", pathname, flags, result);
    
    return result;
}

int close(int fd) {
    initialize_library();
    
    if (!orig_close) {
        errno = ENOSYS;
        return -1;
    }
    
    int result = orig_close(fd);
    
    log_message("close(%d) = %d", fd, result);
    
    return result;
}

void* malloc(size_t size) {
    initialize_library();
    
    if (!orig_malloc) {
        return NULL;
    }
    
    void* result = orig_malloc(size);
    
    // Be careful with logging in malloc to avoid recursion
    if (log_file && size > 1024) {  // Only log large allocations
        log_message("malloc(%zu) = %p", size, result);
    }
    
    return result;
}

void free(void* ptr) {
    initialize_library();
    
    if (!orig_free) {
        return;
    }
    
    if (log_file && ptr) {
        log_message("free(%p)", ptr);
    }
    
    orig_free(ptr);
}

pid_t getpid(void) {
    initialize_library();
    
    if (!orig_getpid) {
        return syscall(SYS_getpid);
    }
    
    pid_t result = orig_getpid();
    
    // Log occasionally to avoid spam
    static int call_count = 0;
    if (++call_count % 10 == 1) {
        log_message("getpid() = %d (call #%d)", result, call_count);
    }
    
    return result;
}

// Test function that can be called from injected code
void linux_test_function() {
    initialize_library();
    log_message("linux_test_function called");
}

// Export symbol for testing
int linux_test_lib_version() {
    return 1;
}
```

`tests/libraries/memory_lib.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// forward declarations
void report_memory_usage();
void memory_init();
void memory_cleanup();

#ifdef _WIN32
#include <windows.h>

#include <process.h>
#include <psapi.h>
#define getpid _getpid

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    switch (fdwReason) {
        case DLL_PROCESS_ATTACH:
            memory_init();
            break;
        case DLL_PROCESS_DETACH:
            memory_cleanup();
            break;
    }
    return TRUE;
}

void memory_init() {
    printf("MEMORY: library loaded into PID %d\n", getpid());
    report_memory_usage();
}

void memory_cleanup() {
    printf("MEMORY: library unloaded\n");
    report_memory_usage();
}

void report_memory_usage() {
    PROCESS_MEMORY_COUNTERS pmc;
    if (GetProcessMemoryInfo(GetCurrentProcess(), &pmc, sizeof(pmc))) {
        printf("MEMORY: working set: %zu KB\n", pmc.WorkingSetSize / 1024);
        printf("MEMORY: page file usage: %zu KB\n", pmc.PagefileUsage / 1024);
        printf("MEMORY: peak working set: %zu KB\n", pmc.PeakWorkingSetSize / 1024);
    } else {
        printf("MEMORY: unable to get memory info\n");
    }
}

#else
#include <unistd.h>
#include <sys/resource.h>

#ifdef __APPLE__
#include <mach/mach.h>
#include <mach/task.h>
#endif

#ifdef __linux__
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#endif

__attribute__((constructor))
void memory_init() {
    printf("MEMORY: library loaded into PID %d\n", getpid());
    report_memory_usage();
}

__attribute__((destructor))
void memory_cleanup() {
    printf("MEMORY: library unloaded\n");
    report_memory_usage();
}

void report_memory_usage() {
    struct rusage usage;
    if (getrusage(RUSAGE_SELF, &usage) == 0) {
        printf("MEMORY: max resident set size: %ld KB\n", usage.ru_maxrss);
#ifdef __APPLE__
        // macOS reports in bytes
        printf("MEMORY: current RSS: %ld KB\n", usage.ru_maxrss / 1024);
#else
        // Linux reports in KB
        printf("MEMORY: current RSS: %ld KB\n", usage.ru_maxrss);
#endif
    }

#ifdef __APPLE__
    // get more detailed memory info on macOS
    struct task_basic_info info;
    mach_msg_type_number_t size = TASK_BASIC_INFO_COUNT;
    if (task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&info, &size) == KERN_SUCCESS) {
        printf("MEMORY: virtual size: %lu KB\n", (unsigned long)(info.virtual_size / 1024));
        printf("MEMORY: resident size: %lu KB\n", (unsigned long)(info.resident_size / 1024));
    }
#endif

#ifdef __linux__
    // read from /proc/self/status on Linux
    FILE* status = fopen("/proc/self/status", "r");
    if (status) {
        char line[256];
        while (fgets(line, sizeof(line), status)) {
            if (strncmp(line, "VmRSS:", 6) == 0) {
                printf("MEMORY: %s", line);
            } else if (strncmp(line, "VmSize:", 7) == 0) {
                printf("MEMORY: %s", line);
            }
        }
        fclose(status);
    }
#endif
}

#endif

// allocate some memory for testing
void* allocate_test_memory(size_t size) {
    void* ptr = malloc(size);
    if (ptr) {
        memset(ptr, 0xAA, size); // fill with pattern
        printf("MEMORY: allocated %zu bytes at %p\n", size, ptr);
        report_memory_usage();
    }
    return ptr;
}

void free_test_memory(void* ptr) {
    if (ptr) {
        printf("MEMORY: freeing memory at %p\n", ptr);
        free(ptr);
        report_memory_usage();
    }
}
```

`tests/libraries/tracer_lib.c`:

```c
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

// Forward declarations
void tracer_init();
void tracer_cleanup();

#ifdef _WIN32
#include <windows.h>
#include <process.h>
#define getpid _getpid

// DLL entry point for Windows
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    switch (fdwReason) {
        case DLL_PROCESS_ATTACH:
            tracer_init();
            break;
        case DLL_PROCESS_DETACH:
            tracer_cleanup();
            break;
    }
    return TRUE;
}

void tracer_init() {
    time_t now = time(NULL);
    char time_str[26];
    ctime_s(time_str, sizeof(time_str), &now);
    time_str[24] = '\0'; // remove newline
    
    printf("TRACER: *** INJECTION SUCCESSFUL ***\n");
    printf("TRACER: library loaded at %s\n", time_str);
    printf("TRACER: target process PID: %d\n", getpid());
    
    // get module name on Windows
    char module_name[MAX_PATH];
    if (GetModuleFileNameA(NULL, module_name, MAX_PATH)) {
        printf("TRACER: target process image: %s\n", module_name);
    }
    
    printf("TRACER: initialization complete\n");
}

void tracer_cleanup() {
    time_t now = time(NULL);
    char time_str[26];
    ctime_s(time_str, sizeof(time_str), &now);
    time_str[24] = '\0'; // remove newline
    
    printf("TRACER: library unloaded at %s\n", time_str);
    printf("TRACER: cleanup complete\n");
}

#else
#include <unistd.h>

#ifdef __APPLE__
#include <mach-o/dyld.h>
#endif

// constructor function - called when library is loaded
__attribute__((constructor))
void tracer_init() {
    time_t now = time(NULL);
    char* time_str = ctime(&now);
    time_str[24] = '\0'; // remove newline
    
    printf("TRACER: *** INJECTION SUCCESSFUL ***\n");
    printf("TRACER: library loaded at %s\n", time_str);
    printf("TRACER: target process PID: %d\n", getpid());
    
#ifdef __APPLE__
    // get image name on macOS
    const char* image_name = _dyld_get_image_name(0);
    if (image_name) {
        printf("TRACER: target process image: %s\n", image_name);
    }
#elif defined(__linux__)
    // get process name on Linux
    char proc_path[256];
    snprintf(proc_path, sizeof(proc_path), "/proc/%d/exe", getpid());
    char exe_path[1024];
    ssize_t len = readlink(proc_path, exe_path, sizeof(exe_path) - 1);
    if (len != -1) {
        exe_path[len] = '\0';
        printf("TRACER: target process image: %s\n", exe_path);
    }
#endif
    
    printf("TRACER: initialization complete\n");
}

// destructor function - called when library is unloaded
__attribute__((destructor))
void tracer_cleanup() {
    time_t now = time(NULL);
    char* time_str = ctime(&now);
    time_str[24] = '\0'; // remove newline
    
    printf("TRACER: library unloaded at %s\n", time_str);
    printf("TRACER: cleanup complete\n");
}

#endif

// exported function that can be called from the target process
void tracer_report() {
    static int call_count = 0;
    call_count++;
    
    printf("TRACER: tracer_report() called %d times\n", call_count);
}
```

`tests/programs/CMakeLists.txt`:

```txt
# test programs for injection testing


# multi-threaded target program
add_executable(multi_threaded_target multi_threaded_target.c)
apply_common_compile_options(multi_threaded_target)
apply_windows_definitions(multi_threaded_target)
set_target_properties(multi_threaded_target PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/tests/programs
)

# control flow crackme program
add_executable(control_flow_1 control_flow_1.cpp)
apply_common_compile_options(control_flow_1)
apply_windows_definitions(control_flow_1)
set_target_properties(control_flow_1 PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/tests/programs
)

# standalone tracers test program
add_executable(test_standalone_tracers test_standalone_tracers.cpp)
apply_common_compile_options(test_standalone_tracers)
apply_windows_definitions(test_standalone_tracers)
target_include_directories(test_standalone_tracers PRIVATE ${WITNESS_SOURCE_DIR}/src)
target_link_libraries(test_standalone_tracers PRIVATE w1cov_static w1xfer_static w1tn3ss redlog::redlog)

# conditionally link w1script if enabled
if(WITNESS_SCRIPT)
    include(${WITNESS_SOURCE_DIR}/cmake/LuaConfig.cmake)
    configure_target_with_lua(test_standalone_tracers)
    target_link_libraries(test_standalone_tracers PRIVATE w1script_static)
endif()

# apply windows symbol resolution after all libraries are linked
if(WIN32 AND MSVC)
    include(${WITNESS_SOURCE_DIR}/cmake/WindowsSymbolConfig.cmake)
    configure_windows_symbol_resolution(test_standalone_tracers)
endif()

set_target_properties(test_standalone_tracers PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/tests/programs
)

# runtime injection target program
add_executable(runtime_injection_target runtime_injection_target.c)
apply_common_compile_options(runtime_injection_target)
apply_windows_definitions(runtime_injection_target)
set_target_properties(runtime_injection_target PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/tests/programs
)

# simple demo program for script testing
add_executable(simple_demo simple_demo.c)
apply_common_compile_options(simple_demo)
apply_windows_definitions(simple_demo)
set_target_properties(simple_demo PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/tests/programs
)

# hook test target program for testing signature-based hooking
add_executable(hook_test_target hook_test_target.c)
apply_common_compile_options(hook_test_target)
apply_windows_definitions(hook_test_target)
set_target_properties(hook_test_target PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/tests/programs
)

# linux-specific target programs
if(UNIX AND NOT APPLE)
    # linux injection target with linux-specific features
    add_executable(linux_target linux_target.c)
    apply_common_compile_options(linux_target)
    apply_windows_definitions(linux_target)
    set_target_properties(linux_target PROPERTIES
        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/tests/programs
    )
    
    # linux daemon target for testing background process injection
    add_executable(linux_daemon linux_daemon.c)
    apply_common_compile_options(linux_daemon)
    apply_windows_definitions(linux_daemon)
    set_target_properties(linux_daemon PROPERTIES
        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/tests/programs
    )
endif()

# enable sanitizers for test programs in debug builds
if(CMAKE_BUILD_TYPE STREQUAL "Debug" AND NOT WIN32)
    target_compile_options(multi_threaded_target PRIVATE ${SANITIZER_FLAGS})
    target_link_options(multi_threaded_target PRIVATE ${SANITIZER_FLAGS})
    
    target_compile_options(control_flow_1 PRIVATE ${SANITIZER_FLAGS})
    target_link_options(control_flow_1 PRIVATE ${SANITIZER_FLAGS})
    
    target_compile_options(runtime_injection_target PRIVATE ${SANITIZER_FLAGS})
    target_link_options(runtime_injection_target PRIVATE ${SANITIZER_FLAGS})
    
    # p1ll test targets (when scripting is enabled)
    if(WITNESS_SCRIPT)
        target_compile_options(p1ll_test_target PRIVATE ${SANITIZER_FLAGS})
        target_link_options(p1ll_test_target PRIVATE ${SANITIZER_FLAGS})
        
        target_compile_options(test_p1ll_pattern_matching PRIVATE ${SANITIZER_FLAGS})
        target_link_options(test_p1ll_pattern_matching PRIVATE ${SANITIZER_FLAGS})
    endif()
    
    # linux-specific targets
    if(UNIX AND NOT APPLE)
        target_compile_options(linux_target PRIVATE ${SANITIZER_FLAGS})
        target_link_options(linux_target PRIVATE ${SANITIZER_FLAGS})
        
        target_compile_options(linux_daemon PRIVATE ${SANITIZER_FLAGS})
        target_link_options(linux_daemon PRIVATE ${SANITIZER_FLAGS})
    endif()
endif()

# platform-specific linking
if(WIN32)
    # no additional libraries needed for Windows
elseif(UNIX)
    # link pthread for unix systems
    target_link_libraries(multi_threaded_target PRIVATE pthread)
    target_link_libraries(runtime_injection_target PRIVATE pthread)
endif()

# p1ll test programs (only build when lua scripting is enabled)
if(WITNESS_SCRIPT)
    # p1ll binary patching test target
    add_executable(p1ll_test_target p1ll_test_target.c)
    apply_common_compile_options(p1ll_test_target)
    apply_windows_definitions(p1ll_test_target)
    set_target_properties(p1ll_test_target PROPERTIES
        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/tests/programs
    )
    
    # p1ll pattern matching unit tests
    add_executable(test_p1ll_pattern_matching test_p1ll_pattern_matching.cpp)
    apply_common_compile_options(test_p1ll_pattern_matching)
    apply_windows_definitions(test_p1ll_pattern_matching)
    target_include_directories(test_p1ll_pattern_matching PRIVATE ${WITNESS_SOURCE_DIR}/src)
    target_link_libraries(test_p1ll_pattern_matching PRIVATE p1ll redlog::redlog)
    set_target_properties(test_p1ll_pattern_matching PROPERTIES
        RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/tests/programs
    )
endif()

# install targets
set(PROGRAM_TARGETS multi_threaded_target control_flow_1 runtime_injection_target simple_demo)

# add p1ll targets to install list when scripting is enabled
if(WITNESS_SCRIPT)
    list(APPEND PROGRAM_TARGETS p1ll_test_target test_p1ll_pattern_matching)
endif()

# add linux-specific targets to install list
if(UNIX AND NOT APPLE)
    list(APPEND PROGRAM_TARGETS linux_target linux_daemon)
endif()

install(TARGETS ${PROGRAM_TARGETS}
    RUNTIME DESTINATION tests/programs
)
```

`tests/programs/control_flow_1.cpp`:

```cpp
#include <algorithm>
#include <chrono>
#include <cstring>
#include <iostream>
#include <string>
#include <thread>
#include <vector>

#ifdef _WIN32
#include <process.h>
#include <windows.h>
#define getpid _getpid
#else
#include <unistd.h>
#endif

class ValidationEngine {
private:
  static constexpr uint32_t MAGIC_CONSTANT = 0xDEADBEEF;
  static constexpr const char *SECRET_KEY = "w1tn3ss_cr4ckm3";

  bool anti_debug_check() {
    // simple timing-based anti-debug (cross-platform)
    auto start = std::chrono::high_resolution_clock::now();
    volatile int dummy = 0;
    for (int i = 0; i < 1000; i++) {
      dummy += i;
    }
    auto end = std::chrono::high_resolution_clock::now();
    auto duration =
        std::chrono::duration_cast<std::chrono::microseconds>(end - start);

    // if execution takes too long, might be debugged
    // more lenient timing for cross-platform compatibility
    return duration.count() < 10000;
  }

  uint32_t hash_string(const std::string &input) {
    uint32_t hash = 5381;
    for (char c : input) {
      hash = ((hash << 5) + hash) + static_cast<uint32_t>(c);
    }
    return hash ^ MAGIC_CONSTANT;
  }

  bool validate_length(const std::string &input) {
    return input.length() >= 8 && input.length() <= 32;
  }

  bool validate_charset(const std::string &input) {
    bool has_upper = false, has_lower = false, has_digit = false;

    for (char c : input) {
      if (c >= 'A' && c <= 'Z')
        has_upper = true;
      else if (c >= 'a' && c <= 'z')
        has_lower = true;
      else if (c >= '0' && c <= '9')
        has_digit = true;
      else if (c == '_' || c == '-')
        continue;
      else
        return false;
    }

    return has_upper && has_lower && has_digit;
  }

  bool validate_pattern(const std::string &input) {
    // must contain "w1" somewhere
    if (input.find("w1") == std::string::npos) {
      return false;
    }

    // must not start with digit
    if (!input.empty() && input[0] >= '0' && input[0] <= '9') {
      return false;
    }

    // must contain at least 2 uppercase letters
    int upper_count = 0;
    for (char c : input) {
      if (c >= 'A' && c <= 'Z') {
        upper_count++;
      }
    }

    return upper_count >= 2;
  }

  bool validate_checksum(const std::string &input) {
    // the correct password is "w1tn3ss_H4ckM3" but good luck finding it without
    // reversing
    uint32_t expected_hash = 0x1a7a9dde;
    uint32_t actual_hash = hash_string(input);

    // obfuscate the comparison
    uint32_t diff = expected_hash ^ actual_hash;
    return diff == 0;
  }

public:
  enum ValidationResult {
    SUCCESS = 0,
    ANTI_DEBUG_FAILED = 1,
    LENGTH_FAILED = 2,
    CHARSET_FAILED = 3,
    PATTERN_FAILED = 4,
    CHECKSUM_FAILED = 5
  };

  ValidationResult validate_input(const std::string &input) {
    // stage 1: anti-debug check
    if (!anti_debug_check()) {
      std::this_thread::sleep_for(std::chrono::milliseconds(100));
      return ANTI_DEBUG_FAILED;
    }

    // stage 2: length validation
    if (!validate_length(input)) {
      return LENGTH_FAILED;
    }

    // stage 3: charset validation
    if (!validate_charset(input)) {
      return CHARSET_FAILED;
    }

    // stage 4: pattern validation
    if (!validate_pattern(input)) {
      return PATTERN_FAILED;
    }

    // stage 5: final checksum
    if (!validate_checksum(input)) {
      return CHECKSUM_FAILED;
    }

    return SUCCESS;
  }

  void print_hint(ValidationResult result) {
    switch (result) {
    case ANTI_DEBUG_FAILED:
      std::cout << "hint: something's watching..." << std::endl;
      break;
    case LENGTH_FAILED:
      std::cout << "hint: length matters (8-32 chars)" << std::endl;
      break;
    case CHARSET_FAILED:
      std::cout << "hint: mix it up (upper, lower, digits, _/-)" << std::endl;
      break;
    case PATTERN_FAILED:
      std::cout << "hint: witness the pattern (w1 + 2 uppercase)" << std::endl;
      break;
    case CHECKSUM_FAILED:
      std::cout << "hint: close, but not quite..." << std::endl;
      break;
    case SUCCESS:
      break;
    }
  }
};

void print_banner() {
  std::cout << "╔══════════════════════════════════════════════╗" << std::endl;
  std::cout << "║           w1tn3ss control flow #1            ║" << std::endl;
  std::cout << "║              crackme challenge               ║" << std::endl;
  std::cout << "╚══════════════════════════════════════════════╝" << std::endl;
  std::cout << std::endl;
}

void success_message() {
  std::cout << std::endl;
  std::cout << "*** congratulations! you've cracked it! ***" << std::endl;
  std::cout << "the control flow analysis revealed the path..." << std::endl;
  std::cout << std::endl;
  std::cout << "flag: w1tn3ss{c0ntr0l_fl0w_m4st3r}" << std::endl;
}

void failure_message(int attempts) {
  std::cout << std::endl;
  if (attempts >= 5) {
    std::cout << "*** too many failed attempts. access denied. ***"
              << std::endl;
    std::cout << "hint: try analyzing the control flow..." << std::endl;
  } else {
    std::cout << "*** access denied. attempts remaining: " << (5 - attempts)
              << " ***" << std::endl;
  }
}

int main(int argc, char *argv[]) {
  print_banner();

  ValidationEngine engine;
  std::string input;
  int attempts = 0;
  const int max_attempts = 5;

  // check for command line argument
  if (argc > 1) {
    input = argv[1];
    std::cout << "validating provided key: " << input << std::endl;

    auto result = engine.validate_input(input);
    if (result == ValidationEngine::SUCCESS) {
      success_message();
      return 0;
    } else {
      engine.print_hint(result);
      failure_message(1);
      return 1;
    }
  }

  // interactive mode
  std::cout << "enter the access key: ";
  while (attempts < max_attempts && std::getline(std::cin, input)) {
    attempts++;

    if (input.empty()) {
      std::cout << "empty input. try again: ";
      continue;
    }

    auto result = engine.validate_input(input);

    if (result == ValidationEngine::SUCCESS) {
      success_message();
      return 0;
    }

    engine.print_hint(result);
    failure_message(attempts);

    if (attempts < max_attempts) {
      std::cout << "enter the access key: ";
    }
  }

  return 1;
}
```

`tests/programs/hook_test_target.c`:

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "signature_helper.h"

// create unique signatures using inline asm with different constants
#if defined(__x86_64__)
#define UNIQUE_SIGNATURE(id) \
    __asm__ volatile("movabs $0xDEADBEEF0000" #id ", %rax\n\t" : : : "rax")
#elif defined(__aarch64__)
#define UNIQUE_SIGNATURE(id) \
    __asm__ volatile( \
        "mov x0, #0x" #id "\n\t" \
        "movk x0, #0xBEEF, lsl #16\n\t" \
        "movk x0, #0xDEAD, lsl #32\n\t" \
        : : : "x0")
#else
#define UNIQUE_SIGNATURE(id) ASM_SIGNATURE_HELPER()
#endif

// test function 1: simple arithmetic with signature
NOINLINE int calculate_secret(int a, int b) {
    UNIQUE_SIGNATURE(1111);
    printf("[calculate_secret] computing %d * 3 + %d * 2\n", a, b);
    return 3 * a + 2 * b;
}

// test function 2: string operation with signature
#define MAX_BUFFER_SIZE 256
NOINLINE void format_message(char buffer[MAX_BUFFER_SIZE], const char* name, int value) {
    UNIQUE_SIGNATURE(2222);
    snprintf(buffer, MAX_BUFFER_SIZE, "hello %s, your magic number is %d", name, value);
    printf("[format_message] formatted: %s\n", buffer);
}

// test function 3: memory allocation with signature
NOINLINE void* allocate_buffer(size_t size) {
    UNIQUE_SIGNATURE(3333);
    printf("[allocate_buffer] allocating %zu bytes\n", size);
    void* ptr = malloc(size);
    if (ptr) {
        memset(ptr, 0, size);
    }
    return ptr;
}

// test function 4: comparison with signature
NOINLINE int compare_strings(const char* str1, const char* str2) {
    UNIQUE_SIGNATURE(4444);
    printf("[compare_strings] comparing \"%s\" with \"%s\"\n", str1, str2);
    return strcmp(str1, str2);
}

// test function 5: vulnerable function for security testing
NOINLINE void unsafe_copy(char* dst, const char* src) {
    UNIQUE_SIGNATURE(5555);
    // intentionally unsafe for testing security monitoring
    strcpy(dst, src);
    printf("[unsafe_copy] copied: %s\n", dst);
}

int main(int argc, char* argv[]) {
    printf("=== hook test target program ===\n");
    printf("this program contains functions with asm signatures for testing\n\n");

    // test 1: calculate secret
    int x = 10, y = 20;
    int result = calculate_secret(x, y);
    printf("result: %d\n\n", result);

    // test 2: format message
    char message[MAX_BUFFER_SIZE];
    format_message(message, "tester", 42);
    printf("message: %s\n\n", message);

    // test 3: allocate buffer
    void* buffer = allocate_buffer(128);
    if (buffer) {
        printf("buffer allocated at: %p\n", buffer);
        free(buffer);
    }
    printf("\n");

    // test 4: compare strings
    const char* str1 = "hello";
    const char* str2 = "world";
    int cmp_result = compare_strings(str1, str2);
    printf("comparison result: %d\n\n", cmp_result);

    // test 5: unsafe copy (if argument provided)
    if (argc > 1) {
        char dest[64];  // small buffer for testing
        printf("performing unsafe copy of argument: %s\n", argv[1]);
        unsafe_copy(dest, argv[1]);
    }

    printf("=== test complete ===\n");
    return 0;
}
```

`tests/programs/linux_daemon.c`:

```c
/*
 * Linux daemon-like target for testing injection into backgrounded processes
 * Tests injection into processes that have detached from terminal
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <time.h>
#include <syslog.h>

volatile int running = 1;
const char* pidfile_path = "/tmp/linux_daemon.pid";

void signal_handler(int sig) {
    syslog(LOG_INFO, "linux_daemon: received signal %d", sig);
    running = 0;
}

void cleanup() {
    unlink(pidfile_path);
    closelog();
}

int create_pidfile() {
    FILE* f = fopen(pidfile_path, "w");
    if (!f) {
        return -1;
    }
    fprintf(f, "%d\n", getpid());
    fclose(f);
    return 0;
}

void daemonize() {
    pid_t pid = fork();
    
    if (pid < 0) {
        exit(EXIT_FAILURE);
    }
    
    if (pid > 0) {
        // Parent process exits
        exit(EXIT_SUCCESS);
    }
    
    // Child continues as daemon
    if (setsid() < 0) {
        exit(EXIT_FAILURE);
    }
    
    // Change working directory to root
    if (chdir("/") < 0) {
        exit(EXIT_FAILURE);
    }
    
    // Close file descriptors
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);
    
    // Redirect standard file descriptors to /dev/null
    open("/dev/null", O_RDONLY);  // stdin
    open("/dev/null", O_WRONLY);  // stdout
    open("/dev/null", O_WRONLY);  // stderr
}

void daemon_work() {
    // Simulate daemon work
    int work_counter = 0;
    
    while (running) {
        syslog(LOG_INFO, "linux_daemon: work iteration %d", work_counter++);
        
        // Simulate some work
        void* ptr = malloc(1024);
        if (ptr) {
            memset(ptr, work_counter & 0xFF, 1024);
            free(ptr);
        }
        
        // Check if we should exit
        if (work_counter >= 15) {  // Run for limited time in testing
            syslog(LOG_INFO, "linux_daemon: work limit reached, exiting");
            break;
        }
        
        sleep(2);
    }
}

int main(int argc, char* argv[]) {
    int foreground = 0;
    
    // Simple argument parsing
    if (argc > 1 && strcmp(argv[1], "--foreground") == 0) {
        foreground = 1;
    }
    
    // Open syslog
    openlog("linux_daemon", LOG_PID | LOG_CONS, LOG_DAEMON);
    
    if (!foreground) {
        printf("linux_daemon: daemonizing (PID: %d)\n", getpid());
        daemonize();
    } else {
        printf("linux_daemon: running in foreground (PID: %d)\n", getpid());
    }
    
    syslog(LOG_INFO, "linux_daemon: started (PID: %d)", getpid());
    
    // Set up signal handlers
    signal(SIGTERM, signal_handler);
    signal(SIGINT, signal_handler);
    signal(SIGHUP, signal_handler);
    
    // Create PID file
    if (create_pidfile() < 0) {
        syslog(LOG_ERR, "linux_daemon: failed to create PID file");
    }
    
    // Set up cleanup
    atexit(cleanup);
    
    // Log injection indicators
    if (getenv("LD_PRELOAD")) {
        syslog(LOG_INFO, "linux_daemon: LD_PRELOAD detected: %s", getenv("LD_PRELOAD"));
    }
    
    // Do daemon work
    daemon_work();
    
    syslog(LOG_INFO, "linux_daemon: exiting");
    return 0;
}
```

`tests/programs/linux_target.c`:

```c
/*
 * Linux-specific target program for injection testing
 * Tests Linux-specific functionality like signals, ptrace detection, etc.
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <sys/ptrace.h>
#include <errno.h>
#include <string.h>
#include <time.h>
#include <sys/socket.h>
#include <netinet/in.h>

volatile int running = 1;
volatile int injection_detected = 0;

void signal_handler(int sig) {
    printf("linux_target: received signal %d (%s)\n", sig, strsignal(sig));
    if (sig == SIGTERM || sig == SIGINT) {
        running = 0;
    }
}

void check_ptrace_status() {
    // Check if we're being traced
    if (ptrace(PTRACE_TRACEME, 0, NULL, NULL) == -1) {
        if (errno == EPERM) {
            printf("linux_target: ptrace detected - we're being traced\n");
            injection_detected = 1;
        }
    } else {
        // Detach immediately if successful
        ptrace(PTRACE_DETACH, 0, NULL, NULL);
    }
}

void perform_linux_operations() {
    // Test various Linux-specific operations that might be hooked
    
    // File operations
    FILE* f = fopen("/proc/self/status", "r");
    if (f) {
        char line[256];
        while (fgets(line, sizeof(line), f)) {
            if (strncmp(line, "TracerPid:", 10) == 0) {
                int tracer_pid = atoi(line + 10);
                if (tracer_pid != 0) {
                    printf("linux_target: TracerPid detected: %d\n", tracer_pid);
                    injection_detected = 1;
                }
                break;
            }
        }
        fclose(f);
    }
    
    // Memory operations
    void* ptr = malloc(1024);
    if (ptr) {
        memset(ptr, 0xAA, 1024);
        free(ptr);
    }
    
    // System calls
    getpid();
    getppid();
    geteuid();
    getegid();
}

void test_library_hooks() {
    // Test common functions that injection libraries might hook
    printf("linux_target: testing library function hooks\n");
    
    // Test malloc/free
    void* test_ptr = malloc(64);
    if (test_ptr) {
        free(test_ptr);
    }
    
    // Test file operations
    FILE* f = fopen("/dev/null", "w");
    if (f) {
        fwrite("test", 1, 4, f);
        fclose(f);
    }
    
    // Test network-like operations (even if they fail)
    socket(AF_INET, SOCK_STREAM, 0);
}

int main(int argc, char* argv[]) {
    printf("linux_target: Linux injection test target starting (PID: %d)\n", getpid());
    printf("linux_target: PPID: %d, UID: %d, GID: %d\n", getppid(), getuid(), getgid());
    
    // Set up signal handlers
    signal(SIGTERM, signal_handler);
    signal(SIGINT, signal_handler);
    signal(SIGCHLD, signal_handler);
    signal(SIGUSR1, signal_handler);
    signal(SIGUSR2, signal_handler);
    
    // Set process name
    if (prctl(PR_SET_NAME, "linux_target", 0, 0, 0) == 0) {
        printf("linux_target: process name set\n");
    }
    
    // Check environment variables that might indicate injection
    if (getenv("LD_PRELOAD")) {
        printf("linux_target: LD_PRELOAD detected: %s\n", getenv("LD_PRELOAD"));
        injection_detected = 1;
    }
    
    int iteration = 0;
    time_t start_time = time(NULL);
    
    while (running && (time(NULL) - start_time) < 30) {  // Run for max 30 seconds
        printf("linux_target: iteration %d\n", iteration++);
        
        // Perform various operations
        perform_linux_operations();
        check_ptrace_status();
        test_library_hooks();
        
        // Print injection status
        if (injection_detected) {
            printf("linux_target: injection/debugging detected\n");
        }
        
        sleep(2);
        
        // Exit after reasonable time for testing
        if (iteration >= 10) {
            printf("linux_target: iteration limit reached\n");
            break;
        }
    }
    
    printf("linux_target: exiting after %d iterations\n", iteration);
    return injection_detected ? 42 : 0;  // Special exit code if injection detected
}
```

`tests/programs/multi_threaded_target.c`:

```c
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
#include <windows.h>
#include <process.h>
#define getpid _getpid
#define usleep(x) Sleep((x) / 1000)
typedef HANDLE pthread_t;
volatile BOOL running = TRUE;
BOOL WINAPI console_handler(DWORD signal) {
    if (signal == CTRL_C_EVENT || signal == CTRL_BREAK_EVENT) {
        printf("multi_threaded_target: received signal, shutting down...\n");
        running = FALSE;
        return TRUE;
    }
    return FALSE;
}
#else
#include <unistd.h>
#include <pthread.h>
volatile int running = 1;
void signal_handler(int sig) {
    printf("multi_threaded_target: received signal %d, shutting down...\n", sig);
    running = 0;
}
#endif

typedef struct {
    int thread_id;
    const char* task_type;
    int iterations;
} thread_data_t;

#ifdef _WIN32
DWORD WINAPI worker_thread(LPVOID arg) {
#else
void* worker_thread(void* arg) {
#endif
    thread_data_t* data = (thread_data_t*)arg;
    int completed = 0;
    
    printf("worker_thread %d (%s): started\n", data->thread_id, data->task_type);
    
    while (running && completed < data->iterations) {
        if (strcmp(data->task_type, "compute") == 0) {
            // computational work
            volatile long sum = 0;
            for (int i = 0; i < 500000; i++) {
                sum += i * data->thread_id;
            }
        } else if (strcmp(data->task_type, "memory") == 0) {
            // memory allocation/deallocation work
            char* buffer = malloc(1024 * data->thread_id);
            if (buffer) {
                memset(buffer, data->thread_id % 256, 1024 * data->thread_id);
                free(buffer);
            }
        } else if (strcmp(data->task_type, "io") == 0) {
            // simulate I/O work with longer sleeps
            usleep(100000); // 100ms
        }
        
        completed++;
        printf("worker_thread %d (%s): completed iteration %d/%d\n", 
               data->thread_id, data->task_type, completed, data->iterations);
        
        usleep(200000); // 200ms between iterations
    }
    
    printf("worker_thread %d (%s): finished after %d iterations\n", 
           data->thread_id, data->task_type, completed);
           
#ifdef _WIN32
    return 0;
#else
    return NULL;
#endif
}

int main() {
#ifdef _WIN32
    SetConsoleCtrlHandler(console_handler, TRUE);
#else
    signal(SIGTERM, signal_handler);
    signal(SIGINT, signal_handler);
#endif
    
    printf("multi_threaded_target: started (PID: %d)\n", getpid());
    printf("multi_threaded_target: main thread spawning workers...\n");
    
    // Define different types of work
    const char* task_types[] = {"compute", "memory", "io", "compute"};
    const int task_iterations[] = {6, 4, 8, 5};
    
#define NUM_THREADS 4
#ifdef _WIN32
    HANDLE threads[NUM_THREADS];
#else
    pthread_t threads[NUM_THREADS];
#endif
    thread_data_t thread_data[NUM_THREADS];
    
    // Main thread creates and manages worker threads
    for (int i = 0; i < NUM_THREADS; i++) {
        thread_data[i].thread_id = i + 1;
        thread_data[i].task_type = task_types[i];
        thread_data[i].iterations = task_iterations[i];
        
        printf("main_thread: creating worker %d with task '%s' (%d iterations)\n", 
               thread_data[i].thread_id, thread_data[i].task_type, thread_data[i].iterations);
        
#ifdef _WIN32
        threads[i] = CreateThread(NULL, 0, worker_thread, &thread_data[i], 0, NULL);
        if (threads[i] == NULL) {
#else
        if (pthread_create(&threads[i], NULL, worker_thread, &thread_data[i]) != 0) {
#endif
            printf("multi_threaded_target: failed to create thread %d\n", i + 1);
            exit(1);
        }
        
        // Main thread does some work between spawning threads
        printf("main_thread: performing coordination work...\n");
        volatile int main_work = 0;
        for (int j = 0; j < 100000; j++) {
            main_work += j;
        }
        usleep(50000); // 50ms delay between thread creation
    }
    
    printf("multi_threaded_target: main thread monitoring %d workers...\n", NUM_THREADS);
    
    // Main thread continues to do work while monitoring
    int monitor_cycles = 0;
    while (running && monitor_cycles < 20) {
        printf("main_thread: monitoring cycle %d\n", monitor_cycles + 1);
        
        // Do some monitoring work
        volatile int monitor_work = 0;
        for (int i = 0; i < 200000; i++) {
            monitor_work += i * monitor_cycles;
        }
        
        monitor_cycles++;
        usleep(300000); // 300ms between monitoring cycles
    }
    
    printf("main_thread: waiting for all workers to complete...\n");
    
    // Wait for all threads to complete
    for (int i = 0; i < NUM_THREADS; i++) {
#ifdef _WIN32
        WaitForSingleObject(threads[i], INFINITE);
        CloseHandle(threads[i]);
#else
        pthread_join(threads[i], NULL);
#endif
        printf("main_thread: worker %d joined\n", i + 1);
    }
    
    printf("multi_threaded_target: all workers completed, main thread exiting\n");
    return 0;
}
```

`tests/programs/p1ll_test_target.c`:

```c
#include <stdio.h>
#include <stdint.h>

// simple test target for p1ll binary patching validation
// contains predictable patterns that can be found and patched

void license_check() {
    // function with conditional jump that can be patched
    uint64_t license_status = 0;  // 0 = trial, 1 = licensed
    
    if (license_status == 0) {
        printf("TRIAL VERSION - Please purchase a license\n");
    } else {
        printf("Licensed version - Thank you!\n");
    }
}

void demo_message() {
    // function with string that can be patched
    printf("DEMO VERSION - Limited functionality\n");
}

void validation_routine() {
    // another function with patchable logic
    int validation_result = 0;  // 0 = fail, 1 = pass
    
    if (validation_result != 1) {
        printf("Validation failed - Access denied\n");
    } else {
        printf("Validation passed - Full access granted\n");
    }
}

int main() {
    printf("p1ll test target v1.0\n");
    printf("=====================\n\n");
    
    license_check();
    demo_message();
    validation_routine();
    
    printf("\ntest target completed.\n");
    return 0;
}
```

`tests/programs/runtime_injection_target.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifdef _WIN32
#include <windows.h>
#include <process.h>
#else
#include <unistd.h>
#include <pthread.h>
#include <sys/time.h>
#endif

// Global state for the application
static volatile int g_running = 1;
static volatile int g_counter = 0;
static volatile int g_operations_performed = 0;

// Different algorithms to create interesting code paths
int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}

void bubble_sort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

void string_operations() {
    char buffer[256];
    const char* words[] = {"hello", "world", "coverage", "testing", "runtime", "injection"};
    int word_count = sizeof(words) / sizeof(words[0]);
    
    strcpy(buffer, "Runtime injection test: ");
    
    for (int i = 0; i < 3; i++) {
        strcat(buffer, words[rand() % word_count]);
        if (i < 2) strcat(buffer, " ");
    }
    
    printf("[%d] %s (length: %zu)\n", g_counter, buffer, strlen(buffer));
}

void mathematical_operations() {
    int a = rand() % 10 + 1;
    int b = rand() % 10 + 1;
    
    int fib_result = fibonacci(a);
    int fact_result = factorial(b);
    
    printf("[%d] Math: fib(%d)=%d, fact(%d)=%d\n", g_counter, a, fib_result, b, fact_result);
}

void array_operations() {
    int size = rand() % 10 + 5;
    int* arr = malloc(size * sizeof(int));
    
    // Fill with random data
    for (int i = 0; i < size; i++) {
        arr[i] = rand() % 100;
    }
    
    printf("[%d] Sorting array of %d elements: ", g_counter, size);
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    
    bubble_sort(arr, size);
    
    printf("-> ");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    free(arr);
}

void* worker_thread(void* arg) {
    int thread_id = *(int*)arg;
    int local_counter = 0;
    
    while (g_running) {
        local_counter++;
        
        if (local_counter % 5 == 0) {
            printf("[Thread %d] Background work iteration %d\n", thread_id, local_counter);
        }
        
        // Do some work to create coverage
        int temp = fibonacci(5) + factorial(3);
        temp = temp % 100;  // Use the result
        
#ifdef _WIN32
        Sleep(500);  // 0.5 second
#else
        usleep(500000);  // 0.5 second
#endif
    }
    
    printf("[Thread %d] Exiting after %d iterations\n", thread_id, local_counter);
    return NULL;
}

void print_status() {
#ifdef _WIN32
    SYSTEMTIME st;
    GetLocalTime(&st);
    
    printf("\n=== Runtime Injection Target Status ===\n");
    printf("PID: %d\n", _getpid());
    printf("Operations performed: %d\n", g_operations_performed);
    printf("Current counter: %d\n", g_counter);
    printf("Timestamp: %02d:%02d:%02d.%03d\n", st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
    printf("Ready for runtime injection testing!\n");
    printf("=======================================\n\n");
#else
    struct timeval tv;
    gettimeofday(&tv, NULL);
    
    printf("\n=== Runtime Injection Target Status ===\n");
    printf("PID: %d\n", getpid());
    printf("Operations performed: %d\n", g_operations_performed);
    printf("Current counter: %d\n", g_counter);
    printf("Timestamp: %ld.%06ld\n", tv.tv_sec, tv.tv_usec);
    printf("Ready for runtime injection testing!\n");
    printf("=======================================\n\n");
#endif
}

int main() {
#ifdef _WIN32
    printf("Starting runtime injection target (PID: %d)\n", _getpid());
#else
    printf("Starting runtime injection target (PID: %d)\n", getpid());
#endif
    printf("This program will run continuously until interrupted.\n");
    printf("Use w1tool to inject coverage collection while it's running.\n\n");
    
    srand(time(NULL));
    
#ifndef _WIN32
    // Start background worker thread (Unix only)
    pthread_t worker;
    int thread_id = 1;
    pthread_create(&worker, NULL, worker_thread, &thread_id);
#endif
    
    print_status();
    
    // Main loop with different operation types
    while (g_running) {
        g_counter++;
        
        // Cycle through different types of operations
        switch (g_counter % 4) {
            case 0:
                string_operations();
                break;
            case 1:
                mathematical_operations();
                break;
            case 2:
                array_operations();
                break;
            case 3:
                printf("[%d] Simple operation: %d + %d = %d\n", 
                       g_counter, g_counter, g_counter * 2, g_counter + g_counter * 2);
                break;
        }
        
        g_operations_performed++;
        
        // Print status periodically
        if (g_counter % 10 == 0) {
            print_status();
        }
        
        // Stop after a reasonable number of operations for testing
        if (g_counter >= 50) {
            printf("\nReached operation limit, shutting down gracefully...\n");
            g_running = 0;
        }
        
#ifdef _WIN32
        Sleep(1000);  // 1 second between operations
#else
        sleep(1);  // 1 second between operations
#endif
    }
    
#ifndef _WIN32
    // Wait for worker thread to finish (Unix only)
    pthread_join(worker, NULL);
#endif
    
    printf("\nRuntime injection target completed.\n");
    printf("Total operations performed: %d\n", g_operations_performed);
    
    return 0;
}
```

`tests/programs/signature_helper.h`:

```h
#pragma once

#include <stdint.h>

// prevent inlining
#if defined(_MSC_VER)
#define NOINLINE __declspec(noinline)
#elif defined(__GNUC__) || defined(__clang__)
#define NOINLINE __attribute__((noinline))
#else
#define NOINLINE
#endif

/*
 * ASM_SIGNATURE_HELPER Macro (Thank you Claude 3.5 Sonnet)
 *
 * Purpose:
 * This macro inserts a unique, easily identifiable assembly code sequence
 * into a function. It's designed to assist in debugging, function detouring,
 * and memory analysis by providing a consistent, platform-specific signature
 * that can be used to locate functions in memory.
 *
 * Supported Platforms:
 * - MSVC x86
 * - MSVC x64
 * - MSVC ARM64
 * - Clang x64
 * - Clang ARM64
 * - GCC x64
 * - GCC ARM64
 *
 * Key Features:
 * 1. Platform-Specific Implementation: Uses conditional compilation to provide
 *    appropriate assembly for each supported platform and architecture.
 * 2. Unique Signature: Utilizes easily recognizable constants (0xDEADBEEFCAFEBABE
 *    and 0xCAFEBABEDEADBEEF) to create a distinct pattern in memory.
 * 3. Optimization Resistance: Employs various techniques to prevent compiler
 *    optimization from removing or altering the signature code.
 *
 * Optimization Prevention Techniques:
 * - Volatile Assembly: Marks assembly as volatile to indicate potential side effects.
 * - Memory Barriers: Prevents instruction reordering around the signature.
 * - Dummy Variables: Forces the compiler to consider the computation results.
 * - Output Constraints: Ensures the assembly results are used (for Clang and GCC).
 * - Memory Clobbering: Indicates potential memory access to the compiler.
 * - Stack Operations: Simulates memory side effects (especially for ARM).
 *
 * Usage:
 * Insert ASM_SIGNATURE_HELPER(); at the beginning of any function you want to mark.
 * Example:
 *     void my_function() {
 *         ASM_SIGNATURE_HELPER();
 *         // Rest of the function code...
 *     }
 *
 * Finding the Function Start:
 * 1. Locate the signature in memory.
 * 2. Scan backwards for the function prologue:
 *    - x64: Look for instructions like "push rbp; mov rbp, rsp"
 *    - ARM64: Look for instructions like "stp x29, x30, [sp, #-16]!"
 * 3. The first instruction of the prologue is likely the true function start.
 *
 * Note:
 * While this macro is designed to be optimization-resistant, it's not guaranteed
 * to work with all optimization levels or future compiler versions. Always test
 * thoroughly with your specific build configuration.
 */
#if defined(_MSC_VER) && defined(_M_IX86)
// MSVC for x86 (32-bit)
#define ASM_SIGNATURE_HELPER()                                 \
  do                                                           \
  {                                                            \
    volatile uint32_t dummy1_low = 0xCAFEBABE;                 \
    volatile uint32_t dummy1_high = 0xDEADBEEF;                \
    volatile uint32_t dummy2_low = 0xDEADBEEF;                 \
    volatile uint32_t dummy2_high = 0xCAFEBABE;                \
    volatile uint32_t result_low, result_high;                 \
    result_low = dummy1_low ^ dummy2_low;                      \
    result_high = dummy1_high ^ dummy2_high;                   \
    dummy1_low = result_low;                                   \
    dummy1_high = result_high;                                 \
    _ReadWriteBarrier();                                       \
    (void)dummy1_low; /* Prevent 'unused variable' warnings */ \
    (void)dummy1_high;                                         \
    (void)dummy2_low;                                          \
    (void)dummy2_high;                                         \
  } while (0)
#elif defined(_MSC_VER) && defined(_M_X64)
// MSVC for x64
#define ASM_SIGNATURE_HELPER()                             \
  do                                                       \
  {                                                        \
    volatile uint64_t dummy1 = 0xDEADBEEFCAFEBABE;         \
    volatile uint64_t dummy2 = 0xCAFEBABEDEADBEEF;         \
    volatile uint64_t result;                              \
    result = dummy1 ^ dummy2;                              \
    dummy1 = result;                                       \
    _ReadWriteBarrier();                                   \
    _mm_mfence();                                          \
    (void)dummy1; /* Prevent 'unused variable' warnings */ \
    (void)dummy2;                                          \
  } while (0)
#elif defined(_MSC_VER) && defined(_M_ARM64)
// MSVC for ARM64
#define ASM_SIGNATURE_HELPER()                                                  \
  do                                                                            \
  {                                                                             \
    volatile uint64_t dummy1 = 0xDEADBEEFCAFEBABE;                              \
    volatile uint64_t dummy2 = 0xCAFEBABEDEADBEEF;                              \
    volatile uint64_t result;                                                   \
    result = dummy1 ^ dummy2;                                                   \
    dummy1 = result;                                                            \
    __dmb(_ARM64_BARRIER_ISH);      /* Data Memory Barrier */                   \
    __iso_volatile_load64(&dummy1); /* Volatile read to prevent optimization */ \
    (void)dummy2;                                                               \
  } while (0)
#elif defined(__clang__)
#if defined(__x86_64__)
// Clang for x64
#define ASM_SIGNATURE_HELPER()                               \
  do                                                         \
  {                                                          \
    uint64_t dummy;                                          \
    __asm__ volatile("nop\n\t"                               \
                     "movabs $0xDEADBEEFCAFEBABE, %%rax\n\t" \
                     "movabs $0xCAFEBABEDEADBEEF, %%rbx\n\t" \
                     "xorq %%rbx, %%rax\n\t"                 \
                     "movq %%rax, %0\n\t"                    \
                     "nop\n\t"                               \
                     : "=r"(dummy)                           \
                     :                                       \
                     : "rax", "rbx", "memory");              \
    __asm__ volatile("" : : : "memory");                     \
    (void)dummy;                                             \
  } while (0)
#elif defined(__aarch64__)
// Clang for ARM64
#define ASM_SIGNATURE_HELPER()                       \
  do                                                 \
  {                                                  \
    uint64_t dummy;                                  \
    __asm__ volatile("nop\n\t"                       \
                     "mov x0, #0xDEAD\n\t"           \
                     "movk x0, #0xBEEF, lsl #16\n\t" \
                     "movk x0, #0xCAFE, lsl #32\n\t" \
                     "movk x0, #0xBABE, lsl #48\n\t" \
                     "mov x1, #0xCAFE\n\t"           \
                     "movk x1, #0xBABE, lsl #16\n\t" \
                     "movk x1, #0xDEAD, lsl #32\n\t" \
                     "movk x1, #0xBEEF, lsl #48\n\t" \
                     "eor x0, x0, x1\n\t"            \
                     "str x0, [sp, #-16]!\n\t"       \
                     "ldr x0, [sp], #16\n\t"         \
                     "mov %0, x0\n\t"                \
                     "nop\n\t"                       \
                     : "=r"(dummy)                   \
                     :                               \
                     : "x0", "x1", "memory");        \
    __asm__ volatile("" : : : "memory");             \
    (void)dummy;                                     \
  } while (0)
#else
#error "Unsupported architecture for ASM_SIGNATURE_HELPER"
#endif
#elif defined(__GNUC__)
#if defined(__x86_64__)
// GCC for x64
#define ASM_SIGNATURE_HELPER()                               \
  do                                                         \
  {                                                          \
    uint64_t dummy;                                          \
    __asm__ volatile("nop\n\t"                               \
                     "movabs $0xDEADBEEFCAFEBABE, %%rax\n\t" \
                     "movabs $0xCAFEBABEDEADBEEF, %%rbx\n\t" \
                     "xorq %%rbx, %%rax\n\t"                 \
                     "movq %%rax, %0\n\t"                    \
                     "nop\n\t"                               \
                     : "=r"(dummy)                           \
                     :                                       \
                     : "rax", "rbx", "memory");              \
    __asm__ volatile("" : : : "memory");                     \
    (void)dummy;                                             \
  } while (0)
#elif defined(__aarch64__)
// GCC for ARM64
#define ASM_SIGNATURE_HELPER()                       \
  do                                                 \
  {                                                  \
    uint64_t dummy;                                  \
    __asm__ volatile("nop\n\t"                       \
                     "mov x0, #0xDEAD\n\t"           \
                     "movk x0, #0xBEEF, lsl #16\n\t" \
                     "movk x0, #0xCAFE, lsl #32\n\t" \
                     "movk x0, #0xBABE, lsl #48\n\t" \
                     "mov x1, #0xCAFE\n\t"           \
                     "movk x1, #0xBABE, lsl #16\n\t" \
                     "movk x1, #0xDEAD, lsl #32\n\t" \
                     "movk x1, #0xBEEF, lsl #48\n\t" \
                     "eor x0, x0, x1\n\t"            \
                     "str x0, [sp, #-16]!\n\t"       \
                     "ldr x0, [sp], #16\n\t"         \
                     "mov %0, x0\n\t"                \
                     "nop\n\t"                       \
                     : "=r"(dummy)                   \
                     :                               \
                     : "x0", "x1", "memory");        \
    __asm__ volatile("" : : : "memory");             \
    (void)dummy;                                     \
  } while (0)
#else
#error "Unsupported architecture for ASM_SIGNATURE_HELPER"
#endif
#else
#error "Unsupported compiler for ASM_SIGNATURE_HELPER"
#endif

```

`tests/programs/simple_demo.c`:

```c
/*
 * simple demo program for w1script testing
 * performs basic operations with limited output
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// simple function to add two numbers
int add(int a, int b) {
    return a + b;
}

// simple function to multiply two numbers
int multiply(int a, int b) {
    return a * b;
}

// function that allocates and frees memory
void memory_test() {
    char* buffer = malloc(64);
    if (buffer) {
        strcpy(buffer, "hello world");
        printf("allocated buffer: %s\n", buffer);
        free(buffer);
    }
}

// function with a simple loop
void loop_test() {
    int sum = 0;
    for (int i = 1; i <= 5; i++) {
        sum += i;
    }
    printf("sum 1-5: %d\n", sum);
}

int main() {
    printf("simple demo starting\n");
    
    // basic arithmetic
    int result1 = add(10, 20);
    int result2 = multiply(5, 6);
    printf("add(10, 20) = %d\n", result1);
    printf("multiply(5, 6) = %d\n", result2);
    
    // memory operations
    memory_test();
    
    // loop operations
    loop_test();
    
    printf("simple demo finished\n");
    return 0;
}
```

`tests/programs/test_p1ll_pattern_matching.cpp`:

```cpp
#include "../../src/p1ll/core/signature.hpp"
#include "../../src/p1ll/engine/pattern_matcher.hpp"
#include "../../src/p1ll/utils/hex_utils.hpp"
#include <cassert>
#include <cstring>
#include <iomanip>
#include <iostream>
#include <vector>

using namespace p1ll::core;
using namespace p1ll::engine;
using namespace p1ll::utils;

// Test result tracking
struct TestResult {
  int passed = 0;
  int failed = 0;

  void pass(const std::string &test_name) {
    std::cout << "[PASS] " << test_name << std::endl;
    passed++;
  }

  void fail(const std::string &test_name, const std::string &reason) {
    std::cout << "[FAIL] " << test_name << " - " << reason << std::endl;
    failed++;
  }

  void summary() {
    std::cout << "\n=== TEST SUMMARY ===" << std::endl;
    std::cout << "Passed: " << passed << std::endl;
    std::cout << "Failed: " << failed << std::endl;
    std::cout << "Total:  " << (passed + failed) << std::endl;
    std::cout << "===================" << std::endl;
  }
};

TestResult results;

// Test data for wildcard pattern matching
void test_wildcard_pattern_matching() {
  std::cout << "\n=== Testing Wildcard Pattern Matching ===" << std::endl;

  // Test case 1: The specific failing pattern from the issue
  {
    std::string pattern = "488b5158 488d4c24?? ffd2 ?? 84db 74?? b001 eb??";

    // Create test data that matches this pattern
    uint8_t test_data[] = {
        0x48, 0x8b, 0x51, 0x58, // 488b5158
        0x48, 0x8d, 0x4c, 0x24, // 488d4c24
        0x28,                   // ?? (wildcard)
        0xff, 0xd2,             // ffd2
        0x90,                   // ?? (wildcard)
        0x84, 0xdb,             // 84db
        0x74, 0x04,             // 74?? (wildcard)
        0xb0, 0x01,             // b001
        0xeb, 0x1d              // eb?? (wildcard)
    };

    compiled_signature sig = compile_signature(pattern);
    pattern_matcher matcher(sig);

    auto matches = matcher.search(test_data, sizeof(test_data));
    if (matches.size() == 1 && matches[0] == 0) {
      results.pass("Wildcard pattern matching - basic case");
    } else {
      results.fail("Wildcard pattern matching - basic case",
                   "Expected 1 match at offset 0, got " +
                       std::to_string(matches.size()) + " matches");
    }
  }

  // Test case 2: Pattern with different wildcard values
  {
    std::string pattern = "488b5158 488d4c24?? ffd2 ?? 84db 74?? b001 eb??";

    uint8_t test_data[] = {
        0x48, 0x8b, 0x51, 0x58, // 488b5158
        0x48, 0x8d, 0x4c, 0x24, // 488d4c24
        0xFF,                   // ?? (different wildcard value)
        0xff, 0xd2,             // ffd2
        0x00,                   // ?? (different wildcard value)
        0x84, 0xdb,             // 84db
        0x74, 0x99,             // 74?? (different wildcard value)
        0xb0, 0x01,             // b001
        0xeb, 0xAB              // eb?? (different wildcard value)
    };

    compiled_signature sig = compile_signature(pattern);
    pattern_matcher matcher(sig);

    auto matches = matcher.search(test_data, sizeof(test_data));
    if (matches.size() == 1 && matches[0] == 0) {
      results.pass("Wildcard pattern matching - different wildcard values");
    } else {
      results.fail("Wildcard pattern matching - different wildcard values",
                   "Expected 1 match at offset 0, got " +
                       std::to_string(matches.size()) + " matches");
    }
  }

  // Test case 3: Pattern should NOT match when exact bytes are wrong
  {
    std::string pattern = "488b5158 488d4c24?? ffd2 ?? 84db 74?? b001 eb??";

    uint8_t test_data[] = {
        0x48, 0x8b, 0x51, 0x58, // 488b5158
        0x48, 0x8d, 0x4c, 0x24, // 488d4c24
        0x28,                   // ?? (wildcard)
        0xff, 0xd2,             // ffd2
        0x90,                   // ?? (wildcard)
        0x84, 0xdb,             // 84db
        0x75, 0x04,             // 75?? (WRONG: should be 74)
        0xb0, 0x01,             // b001
        0xeb, 0x1d              // eb?? (wildcard)
    };

    compiled_signature sig = compile_signature(pattern);
    pattern_matcher matcher(sig);

    auto matches = matcher.search(test_data, sizeof(test_data));
    if (matches.size() == 0) {
      results.pass("Wildcard pattern matching - negative case");
    } else {
      results.fail("Wildcard pattern matching - negative case",
                   "Expected 0 matches, got " + std::to_string(matches.size()) +
                       " matches");
    }
  }

  // Test case 4: Pattern at different offset
  {
    std::string pattern = "488b5158 488d4c24?? ffd2 ?? 84db 74?? b001 eb??";

    std::vector<uint8_t> buffer(100, 0x00);
    uint8_t test_data[] = {
        0x48, 0x8b, 0x51, 0x58, // 488b5158
        0x48, 0x8d, 0x4c, 0x24, // 488d4c24
        0x28,                   // ?? (wildcard)
        0xff, 0xd2,             // ffd2
        0x90,                   // ?? (wildcard)
        0x84, 0xdb,             // 84db
        0x74, 0x04,             // 74?? (wildcard)
        0xb0, 0x01,             // b001
        0xeb, 0x1d              // eb?? (wildcard)
    };

    std::memcpy(buffer.data() + 50, test_data, sizeof(test_data));

    compiled_signature sig = compile_signature(pattern);
    pattern_matcher matcher(sig);

    auto matches = matcher.search(buffer.data(), buffer.size());
    if (matches.size() == 1 && matches[0] == 50) {
      results.pass("Wildcard pattern matching - different offset");
    } else {
      results.fail("Wildcard pattern matching - different offset",
                   "Expected 1 match at offset 50, got " +
                       std::to_string(matches.size()) + " matches");
    }
  }
}

void test_exact_pattern_matching() {
  std::cout << "\n=== Testing Exact Pattern Matching ===" << std::endl;

  // Test case 1: Simple exact pattern
  {
    std::string pattern = "488b5158 488d4c24";
    uint8_t test_data[] = {0x48, 0x8b, 0x51, 0x58, 0x48, 0x8d, 0x4c, 0x24};

    compiled_signature sig = compile_signature(pattern);
    pattern_matcher matcher(sig);

    auto matches = matcher.search(test_data, sizeof(test_data));
    if (matches.size() == 1 && matches[0] == 0) {
      results.pass("Exact pattern matching - basic case");
    } else {
      results.fail("Exact pattern matching - basic case",
                   "Expected 1 match at offset 0, got " +
                       std::to_string(matches.size()) + " matches");
    }
  }

  // Test case 2: Pattern not found
  {
    std::string pattern = "488b5158 488d4c24";
    uint8_t test_data[] = {0x48, 0x8b, 0x51, 0x58,
                           0x48, 0x8d, 0x4c, 0x25}; // Last byte wrong

    compiled_signature sig = compile_signature(pattern);
    pattern_matcher matcher(sig);

    auto matches = matcher.search(test_data, sizeof(test_data));
    if (matches.size() == 0) {
      results.pass("Exact pattern matching - negative case");
    } else {
      results.fail("Exact pattern matching - negative case",
                   "Expected 0 matches, got " + std::to_string(matches.size()) +
                       " matches");
    }
  }
}

void test_edge_cases() {
  std::cout << "\n=== Testing Edge Cases ===" << std::endl;

  // Test case 1: Single byte pattern
  {
    std::string pattern = "48";
    uint8_t test_data[] = {0x48};

    compiled_signature sig = compile_signature(pattern);
    pattern_matcher matcher(sig);

    auto matches = matcher.search(test_data, sizeof(test_data));
    if (matches.size() == 1 && matches[0] == 0) {
      results.pass("Edge case - single byte pattern");
    } else {
      results.fail("Edge case - single byte pattern",
                   "Expected 1 match at offset 0, got " +
                       std::to_string(matches.size()) + " matches");
    }
  }

  // Test case 2: Single wildcard pattern
  {
    std::string pattern = "??";
    uint8_t test_data[] = {0x48};

    compiled_signature sig = compile_signature(pattern);
    pattern_matcher matcher(sig);

    auto matches = matcher.search(test_data, sizeof(test_data));
    if (matches.size() == 1 && matches[0] == 0) {
      results.pass("Edge case - single wildcard pattern");
    } else {
      results.fail("Edge case - single wildcard pattern",
                   "Expected 1 match at offset 0, got " +
                       std::to_string(matches.size()) + " matches");
    }
  }

  // Test case 3: All wildcards pattern
  {
    std::string pattern = "?? ?? ??";
    uint8_t test_data[] = {0x48, 0x8b, 0x51};

    compiled_signature sig = compile_signature(pattern);
    pattern_matcher matcher(sig);

    auto matches = matcher.search(test_data, sizeof(test_data));
    if (matches.size() == 1 && matches[0] == 0) {
      results.pass("Edge case - all wildcards pattern");
    } else {
      results.fail("Edge case - all wildcards pattern",
                   "Expected 1 match at offset 0, got " +
                       std::to_string(matches.size()) + " matches");
    }
  }

  // Test case 4: Empty data
  {
    std::string pattern = "48";
    uint8_t *test_data = nullptr;

    compiled_signature sig = compile_signature(pattern);
    pattern_matcher matcher(sig);

    auto matches = matcher.search(test_data, 0);
    if (matches.size() == 0) {
      results.pass("Edge case - empty data");
    } else {
      results.fail("Edge case - empty data",
                   "Expected 0 matches, got " + std::to_string(matches.size()) +
                       " matches");
    }
  }
}

void test_performance_patterns() {
  std::cout << "\n=== Testing Performance Patterns ===" << std::endl;

  // Test case 1: Pattern with many wildcards (should still work but be slow)
  {
    std::string pattern = "?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 48 8b";

    std::vector<uint8_t> test_data(1000, 0x00);
    // Place the pattern at offset 500
    test_data[500 + 10] = 0x48;
    test_data[500 + 11] = 0x8b;

    compiled_signature sig = compile_signature(pattern);
    pattern_matcher matcher(sig);

    auto matches = matcher.search(test_data.data(), test_data.size());
    if (matches.size() >= 1) {
      bool found_at_500 = false;
      for (auto match : matches) {
        if (match == 500) {
          found_at_500 = true;
          break;
        }
      }
      if (found_at_500) {
        results.pass("Performance pattern - many wildcards");
      } else {
        results.fail("Performance pattern - many wildcards",
                     "Expected match at offset 500, but not found");
      }
    } else {
      results.fail("Performance pattern - many wildcards",
                   "Expected at least 1 match, got " +
                       std::to_string(matches.size()) + " matches");
    }
  }
}

void test_hex_utils() {
  std::cout << "\n=== Testing Hex Utils ===" << std::endl;

  // Test case 1: Valid hex pattern
  {
    std::string pattern = "48 8b ?? ff d2";
    if (is_valid_hex_pattern(pattern)) {
      results.pass("Hex utils - valid pattern");
    } else {
      results.fail("Hex utils - valid pattern", "Pattern should be valid");
    }
  }

  // Test case 2: Invalid hex pattern
  {
    std::string pattern = "48 8b ? ff d2"; // Single ? instead of ??
    if (!is_valid_hex_pattern(pattern)) {
      results.pass("Hex utils - invalid pattern");
    } else {
      results.fail("Hex utils - invalid pattern", "Pattern should be invalid");
    }
  }

  // Test case 3: Normalize hex pattern
  {
    std::string pattern = "48 8B ?? FF d2";
    std::string normalized = normalize_hex_pattern(pattern);
    if (normalized == "488b??ffd2") {
      results.pass("Hex utils - normalize pattern");
    } else {
      results.fail("Hex utils - normalize pattern",
                   "Expected '488b??ffd2', got '" + normalized + "'");
    }
  }
}

int main() {
  std::cout << "=== P1LL Pattern Matching Unit Tests ===" << std::endl;

  test_hex_utils();
  test_exact_pattern_matching();
  test_wildcard_pattern_matching();
  test_edge_cases();
  test_performance_patterns();

  results.summary();

  return results.failed > 0 ? 1 : 0;
}
```

`tests/programs/test_standalone_tracers.cpp`:

```cpp
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <iostream>
#include <string>
#include <vector>
#ifdef _WIN32
#include <w1common/windows_clean.hpp>
#else
#include <unistd.h>
#endif

#include <redlog.hpp>

#include "../../src/tracers/w1cov/session.hpp"
#include "../../src/tracers/w1xfer/session.hpp"
#ifdef WITNESS_SCRIPT_ENABLED
#include "../../src/tracers/w1script/session.hpp"
#endif

// test function for w1cov - demonstrates control flow coverage
extern "C" uint64_t test_coverage_control_flow(uint64_t value) {
  uint64_t result = 0;

  // multiple branches
  if (value < 10) {
    result = value * 2;
  } else if (value < 20) {
    result = value * 3;
    if (value % 2 == 0) {
      result += 5;
    } else {
      result -= 3;
    }
  } else if (value < 50) {
    // loop with early exit
    for (int i = 0; i < 10; i++) {
      result += i;
      if (result > 100) {
        break;
      }
    }
  } else {
    // switch statement
    switch (value % 4) {
    case 0:
      result = value / 2;
      break;
    case 1:
      result = value * value;
      break;
    case 2:
      result = value + 100;
      break;
    default:
      result = value - 50;
      break;
    }
  }

  // nested conditions
  if (result > 0) {
    if (result % 2 == 0) {
      result = result / 2;
    } else {
      result = result * 3 + 1;
    }
  }

  return result;
}

// test function for w1xfer - demonstrates library calls and transfers
extern "C" void *test_xfer_library_calls(void *arg) {
  size_t size = reinterpret_cast<size_t>(arg);

  // allocate memory
  void *buffer = malloc(size);
  if (!buffer) {
    printf("malloc failed for size %zu\n", size);
    return nullptr;
  }

  // initialize memory
  memset(buffer, 0x42, size);

  // format a string
  char message[256];
  sprintf(message, "allocated and initialized %zu bytes at %p", size, buffer);

  // print the message
  printf("%s\n", message);

  // try to open a non-existent file (will fail gracefully)
  FILE *fp = fopen("/tmp/nonexistent_test_file_12345.txt", "r");
  if (fp) {
    printf("unexpectedly opened file\n");
    fclose(fp);
  } else {
    printf("expected file open failure\n");
  }

  // clean up
  free(buffer);

  return reinterpret_cast<void *>(size);
}

// test w1cov tracer
int test_w1cov(int verbose_level = 0) {
  std::cout << "\n=== testing w1cov tracer ===\n";

  w1cov::session session;
  session.add_target_module_pattern("test_standalone_tracers");

  if (!session.initialize()) {
    std::cout << "failed to initialize w1cov tracer\n";
    return 1;
  }

  // trace function multiple times with different paths to demonstrate coverage
  uint64_t result1, result2, result3, result4;

  // test different branches
  if (!session.trace_function((void *)test_coverage_control_flow, {5},
                              &result1)) {
    std::cout << "failed to trace function (value < 10)\n";
    return 1;
  }

  if (!session.trace_function((void *)test_coverage_control_flow, {15},
                              &result2)) {
    std::cout << "failed to trace function (10 <= value < 20)\n";
    return 1;
  }

  if (!session.trace_function((void *)test_coverage_control_flow, {30},
                              &result3)) {
    std::cout << "failed to trace function (20 <= value < 50)\n";
    return 1;
  }

  if (!session.trace_function((void *)test_coverage_control_flow, {100},
                              &result4)) {
    std::cout << "failed to trace function (value >= 50)\n";
    return 1;
  }

  std::cout << "function results: " << result1 << ", " << result2 << ", "
            << result3 << ", " << result4 << "\n";
  std::cout << "unique blocks: " << session.get_coverage_unit_count() << "\n";
  std::cout << "total hits: " << session.get_total_hits() << "\n";

  session.print_statistics();

  if (session.export_coverage("test_w1cov.drcov")) {
    std::cout << "coverage exported successfully\n";
  }

  std::cout << "w1cov test completed\n";
  return 0;
}

// test w1xfer tracer
int test_w1xfer(int verbose_level = 0) {
  std::cout << "\n=== testing w1xfer tracer ===\n";

  w1xfer::transfer_config config;
  config.output_file = "test_w1xfer.jsonl";

  // enable all features for comprehensive tracing
  config.log_registers = true;
  config.log_stack_info = true;
  config.log_call_targets = true;
  config.analyze_apis = true;
  config.verbose = verbose_level;

  w1xfer::session session(config);
  session.add_target_module_pattern("test_standalone_tracers");

  if (!session.initialize()) {
    std::cout << "failed to initialize w1xfer tracer\n";
    return 1;
  }

  // trace a function that makes library calls
  uint64_t result;
  if (!session.trace_function((void *)test_xfer_library_calls, {1024},
                              &result)) {
    std::cout << "failed to trace function\n";
    return 1;
  }

  const auto &stats = session.get_stats();
  std::cout << "transfer statistics:\n";
  std::cout << "  total calls: " << stats.total_calls << "\n";
  std::cout << "  total returns: " << stats.total_returns << "\n";
  std::cout << "  unique call targets: " << stats.unique_call_targets << "\n";
  std::cout << "  unique return sources: " << stats.unique_return_sources
            << "\n";
  std::cout << "  max call depth: " << stats.max_call_depth << "\n";

  std::cout << "w1xfer test completed (output in " << config.output_file
            << ")\n";
  return 0;
}

#ifdef WITNESS_SCRIPT_ENABLED
// minimal lua script embedded as string - instruction tracer
static const char *minimal_script = R"lua(
-- instruction tracer with disassembly
-- logs every instruction with address and assembly code

local instruction_count = 0
local max_instructions = 50  -- limit output for demo

local tracer = {}
tracer.callbacks = { "instruction_postinst" }

function tracer.on_instruction_postinst(vm, gpr, fpr)
    instruction_count = instruction_count + 1
    
    -- only log first N instructions to avoid spam
    if instruction_count <= max_instructions then
        -- get program counter and disassembly
        local pc = w1.get_reg_pc and w1.get_reg_pc(gpr) or 0
        local disasm = w1.get_disassembly(vm)
        
        -- log instruction with address and disassembly
        w1.log_info(w1.format_address(pc) .. ": " .. disasm)
    end

    -- at truncation point say we're truncating
    if instruction_count == max_instructions then
        w1.log_info("... silencing further instruction logs ...")
    end
    
    return w1.VMAction.CONTINUE
end

function tracer.shutdown()
    w1.log_info("traced " .. instruction_count .. " instructions total")
end

return tracer
)lua";

// test function for w1script - demonstrates scripted tracing
extern "C" int test_script_fibonacci(int n) {
  if (n <= 1)
    return n;
  return test_script_fibonacci(n - 1) + test_script_fibonacci(n - 2);
}

// test w1script tracer
int test_w1script(int verbose_level = 0) {
  std::cout << "\n=== testing w1script tracer ===\n";

  // write script to temporary file
  std::string script_path;
#ifdef _WIN32
  char temp_path[MAX_PATH];
  GetTempPathA(MAX_PATH, temp_path);
  script_path = std::string(temp_path) + "test_minimal_script.lua";
#else
  script_path = "/tmp/test_minimal_script.lua";
#endif
  std::ofstream script_file(script_path);
  script_file << minimal_script;
  script_file.close();

  w1::tracers::script::config config;
  config.script_path = script_path.c_str();
  config.verbose = (verbose_level > 0);

  w1::tracers::script::session session(config);
  session.add_target_module_pattern("test_standalone_tracers");

  if (!session.initialize()) {
    std::cout << "failed to initialize w1script tracer\n";
    return 1;
  }

  // trace a recursive function to generate some basic blocks
  uint64_t result;
  if (!session.trace_function((void *)test_script_fibonacci, {10}, &result)) {
    std::cout << "failed to trace function\n";
    return 1;
  }

  std::cout << "fibonacci(10) = " << result << "\n";

  // cleanup temp script
  std::remove(script_path.c_str());

  std::cout << "w1script test completed\n";
  return 0;
}
#endif // WITNESS_SCRIPT_ENABLED

void print_usage(const char *program_name) {
  std::cout << "usage: " << program_name << " [-v...] <tracer>\n";
  std::cout << "\navailable tracers:\n";
  std::cout << "  w1cov    - coverage tracer\n";
  std::cout << "  w1xfer   - transfer/call tracer\n";
#ifdef WITNESS_SCRIPT_ENABLED
  std::cout << "  w1script - scripted tracer\n";
#endif
  std::cout << "  all      - test all tracers\n";
  std::cout << "\noptions:\n";
  std::cout
      << "  -v      verbose output (can be repeated for more verbosity)\n";
}

int main(int argc, char *argv[]) {
  if (argc < 2) {
    print_usage(argv[0]);
    return 1;
  }

  // parse arguments
  int verbose = 0;
  std::string tracer_name;

  for (int i = 1; i < argc; i++) {
    if (argv[i][0] == '-') {
      // count verbose flags
      for (const char *p = argv[i]; *p; p++) {
        if (*p == 'v') {
          verbose++;
        }
      }
    } else {
      // first non-option argument is the tracer name
      if (tracer_name.empty()) {
        tracer_name = argv[i];
      }
    }
  }

  if (tracer_name.empty()) {
    print_usage(argv[0]);
    return 1;
  }

  // set log level based on verbose count
  if (verbose >= 4) {
    redlog::set_level(redlog::level::pedantic);
  } else if (verbose >= 3) {
    redlog::set_level(redlog::level::debug);
  } else if (verbose >= 2) {
    redlog::set_level(redlog::level::trace);
  } else if (verbose >= 1) {
    redlog::set_level(redlog::level::verbose);
  } else {
    redlog::set_level(redlog::level::info);
  }

  if (tracer_name == "w1cov") {
    return test_w1cov(verbose);
  } else if (tracer_name == "w1xfer") {
    return test_w1xfer(verbose);
#ifdef WITNESS_SCRIPT_ENABLED
  } else if (tracer_name == "w1script") {
    return test_w1script(verbose);
#endif
  } else if (tracer_name == "all") {
    int result = 0;
    result |= test_w1cov(verbose);
    result |= test_w1xfer(verbose);
#ifdef WITNESS_SCRIPT_ENABLED
    result |= test_w1script(verbose);
#endif
    return result;
  } else {
    std::cout << "unknown tracer: " << tracer_name << "\n";
    print_usage(argv[0]);
    return 1;
  }
}
```

`tools/README.md`:

```md
# tools

utility scripts for w1tn3ss development.

## macos-signing

code signing tools for injection on macos.

### files

- `genkey.sh` - generates code signing certificate
- `sign.sh` - signs executables with debugger entitlements  
- `entitlement.xml` - debugger privilege entitlements

### setup

generate certificate:
```sh
./tools/macos-signing/genkey.sh "w1tn3ss-dev"
```

sign w1tool:
```sh
./tools/macos-signing/sign.sh "w1tn3ss-dev" ./build-macos/w1tool
```

### notes

- certificate install requires sudo
- signing needed after each build
- required for injection on macos
- development only - not for distribution
```

`tools/macos_signing/entitlement.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>com.apple.security.cs.debugger</key>
    <true/>
</dict>
</plist>
</pre>
```

`tools/macos_signing/genkey.sh`:

```sh
#!/bin/bash

###
# this script generates a code signing certificate and installs it in the system keychain.
# based on: https://github.com/llvm/llvm-project/blob/main/lldb/scripts/macos-setup-codesign.sh
###

# require a certificate name
if [ -z "$1" ]; then
    echo "usage: $0 <certificate name>"
    exit 1
fi

CERT="$1"

function error() {
    echo error: "$@" 1>&2
    exit 1
}

function cleanup {
    # Remove generated files
    rm -f "$TMPDIR/$CERT.tmpl" "$TMPDIR/$CERT.cer" "$TMPDIR/$CERT.key" > /dev/null 2>&1
}

trap cleanup EXIT

# Check if the certificate is already present in the system keychain
security find-certificate -Z -p -c "$CERT" /Library/Keychains/System.keychain > /dev/null 2>&1
if [ $? -eq 0 ]; then
    printf "certificate [%s] has already been generated and installed\n" "$CERT"
    exit 0
fi

# Create the certificate template
cat <<EOF >$TMPDIR/$CERT.tmpl
[ req ]
default_bits       = 2048        # RSA key size
encrypt_key        = no          # Protect private key
default_md         = sha512      # MD to use
prompt             = no          # Prompt for DN
distinguished_name = codesign_dn # DN template
[ codesign_dn ]
commonName         = "$CERT"
[ codesign_reqext ]
keyUsage           = critical,digitalSignature
extendedKeyUsage   = critical,codeSigning
EOF

printf "generating and installing certificate [%s]\n" "$CERT"

# generate a new certificate
openssl req -new -newkey rsa:2048 -x509 -days 3650 -nodes -config "$TMPDIR/$CERT.tmpl" -extensions codesign_reqext -batch -out "$TMPDIR/$CERT.cer" -keyout "$TMPDIR/$CERT.key" > /dev/null 2>&1
# [ $? -eq 0 ] || error something went wrong when generating the certificate
[ $? -eq 0 ] || error openssl failed to generate the certificate

# Install the certificate in the system keychain
sudo security authorizationdb read com.apple.trust-settings.admin > "$TMPDIR/rights"
sudo security authorizationdb write com.apple.trust-settings.admin allow
sudo security add-trusted-cert -d -r trustRoot -p codeSign -k /Library/Keychains/System.keychain "$TMPDIR/$CERT.cer" > /dev/null 2>&1
result=$?
sudo security authorizationdb write com.apple.trust-settings.admin < "$TMPDIR/rights"
# [ $result -eq 0 ] || error something went wrong when installing the certificate
[ $result -eq 0 ] || error security authorizationdb failed to install the certificate

# Install the key for the certificate in the system keychain
sudo security import "$TMPDIR/$CERT.key" -A -k /Library/Keychains/System.keychain > /dev/null 2>&1
# [ $? -eq 0 ] || error something went wrong when installing the key
[ $? -eq 0 ] || error security import failed to install the key

# Kill task_for_pid access control daemon
sudo pkill -f /usr/libexec/taskgated > /dev/null 2>&1

# Exit indicating the certificate is now generated and installed
printf "certificate [%s] has been generated and installed\n" "$CERT"
exit 0
```

`tools/macos_signing/sign.sh`:

```sh
#!/bin/bash

###
# this script signs an executable with a code signing certificate and entitlements.
###

if [ -z "$1" ] || [ -z "$2" ]; then
    echo "usage: $0 <key> <executable> [<entitlements>]"
    exit 1
fi

key="$1"
executable="$2"

if [ -z "$3" ]; then
    # get entitlement.xml from the same directory as this script
    entitlements=$(dirname "$0")/entitlement.xml
else
    entitlements="$3"
fi

printf "signing [%s] with key [%s], entitlements [%s]\n" "$executable" "$key" "$entitlements"

/usr/bin/codesign --entitlements "$entitlements" --force --sign "$key" "$executable"

```

`tools/setup_macos.sh`:

```sh
#!/bin/bash
# setup script for macos development

set -e

CERT_NAME="w1tn3ss-dev"
BUILD_DIR="build-macos"

echo "setting up macos development environment..."

# check if certificate already exists
if security find-certificate -c "$CERT_NAME" >/dev/null 2>&1; then
    echo "certificate '$CERT_NAME' already exists"
else
    echo "generating certificate '$CERT_NAME'..."
    ./tools/macos-signing/genkey.sh "$CERT_NAME"
fi

# check if w1tool exists
if [ -f "$BUILD_DIR/w1tool" ]; then
    echo "signing w1tool..."
    ./tools/macos-signing/sign.sh "$CERT_NAME" "$BUILD_DIR/w1tool"
    echo "w1tool signed successfully"
else
    echo "w1tool not found - build project first with:"
    echo "  cmake -B $BUILD_DIR && cmake --build $BUILD_DIR"
fi

echo "macos setup complete"
```