Project Path: arc_gmh5225_GreyM_58a6tcer

Source Tree:

```txt
arc_gmh5225_GreyM_58a6tcer
├── GreyM
│   ├── GreyM.vcxproj
│   ├── GreyM.vcxproj.filters
│   ├── notes.txt
│   └── src
│       ├── disassembler
│       │   ├── pe_disassembly_engine.cpp
│       │   └── pe_disassembly_engine.h
│       ├── main.cpp
│       ├── pch
│       │   ├── pch.cpp
│       │   └── pch.h
│       ├── pe
│       │   ├── peutils.cpp
│       │   ├── peutils.h
│       │   ├── portable_executable.cpp
│       │   ├── portable_executable.h
│       │   ├── section.cpp
│       │   ├── section.h
│       │   ├── section_headers.cpp
│       │   └── section_headers.h
│       ├── protector.cpp
│       ├── protector.h
│       ├── rtti_obfuscator.cpp
│       ├── rtti_obfuscator.h
│       ├── utils
│       │   ├── console_log.h
│       │   ├── defer.h
│       │   ├── file_io.cpp
│       │   ├── file_io.h
│       │   ├── file_log.cpp
│       │   ├── file_log.h
│       │   ├── random.h
│       │   ├── shellcode.cpp
│       │   ├── shellcode.h
│       │   ├── stopwatch.h
│       │   └── string_utils.h
│       └── virtualizer
│           ├── virtualizer.cpp
│           └── virtualizer.h
├── GreyM.sln
├── Interpreter
│   ├── Exports.def
│   ├── Interpreter.vcxproj
│   ├── Interpreter.vcxproj.filters
│   └── src
│       ├── main.cpp
│       └── main.h
├── README.md
├── Test Executable
│   ├── Test Executable.vcxproj
│   ├── Test Executable.vcxproj.filters
│   └── src
│       └── main.cpp
├── _clang-format
└── capstone
    └── include
        └── capstone
            ├── arm.h
            ├── arm64.h
            ├── capstone.h
            ├── evm.h
            ├── m680x.h
            ├── m68k.h
            ├── mips.h
            ├── mos65xx.h
            ├── platform.h
            ├── ppc.h
            ├── sparc.h
            ├── systemz.h
            ├── tms320c64x.h
            ├── x86.h
            └── xcore.h

```

`GreyM.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.28803.452
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GreyM", "GreyM\GreyM.vcxproj", "{3110B0C4-7FCD-4DB9-A7A0-98304627C591}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Test Executable", "Test Executable\Test Executable.vcxproj", "{2DC5E383-859C-40EB-BA6C-A9D9B5753BDB}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Interpreter", "Interpreter\Interpreter.vcxproj", "{B2F54070-ABC0-400A-8FAC-A75098E7253F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3110B0C4-7FCD-4DB9-A7A0-98304627C591}.Debug|x64.ActiveCfg = Debug|x64
		{3110B0C4-7FCD-4DB9-A7A0-98304627C591}.Debug|x64.Build.0 = Debug|x64
		{3110B0C4-7FCD-4DB9-A7A0-98304627C591}.Debug|x86.ActiveCfg = Debug|Win32
		{3110B0C4-7FCD-4DB9-A7A0-98304627C591}.Debug|x86.Build.0 = Debug|Win32
		{3110B0C4-7FCD-4DB9-A7A0-98304627C591}.Release|x64.ActiveCfg = Release|x64
		{3110B0C4-7FCD-4DB9-A7A0-98304627C591}.Release|x64.Build.0 = Release|x64
		{3110B0C4-7FCD-4DB9-A7A0-98304627C591}.Release|x86.ActiveCfg = Release|Win32
		{3110B0C4-7FCD-4DB9-A7A0-98304627C591}.Release|x86.Build.0 = Release|Win32
		{2DC5E383-859C-40EB-BA6C-A9D9B5753BDB}.Debug|x64.ActiveCfg = Debug|x64
		{2DC5E383-859C-40EB-BA6C-A9D9B5753BDB}.Debug|x64.Build.0 = Debug|x64
		{2DC5E383-859C-40EB-BA6C-A9D9B5753BDB}.Debug|x86.ActiveCfg = Debug|Win32
		{2DC5E383-859C-40EB-BA6C-A9D9B5753BDB}.Debug|x86.Build.0 = Debug|Win32
		{2DC5E383-859C-40EB-BA6C-A9D9B5753BDB}.Release|x64.ActiveCfg = Release|x64
		{2DC5E383-859C-40EB-BA6C-A9D9B5753BDB}.Release|x64.Build.0 = Release|x64
		{2DC5E383-859C-40EB-BA6C-A9D9B5753BDB}.Release|x86.ActiveCfg = Release|Win32
		{2DC5E383-859C-40EB-BA6C-A9D9B5753BDB}.Release|x86.Build.0 = Release|Win32
		{B2F54070-ABC0-400A-8FAC-A75098E7253F}.Debug|x64.ActiveCfg = Debug|x64
		{B2F54070-ABC0-400A-8FAC-A75098E7253F}.Debug|x64.Build.0 = Debug|x64
		{B2F54070-ABC0-400A-8FAC-A75098E7253F}.Debug|x86.ActiveCfg = Debug|Win32
		{B2F54070-ABC0-400A-8FAC-A75098E7253F}.Debug|x86.Build.0 = Debug|Win32
		{B2F54070-ABC0-400A-8FAC-A75098E7253F}.Release|x64.ActiveCfg = Release|x64
		{B2F54070-ABC0-400A-8FAC-A75098E7253F}.Release|x64.Build.0 = Release|x64
		{B2F54070-ABC0-400A-8FAC-A75098E7253F}.Release|x86.ActiveCfg = Release|Win32
		{B2F54070-ABC0-400A-8FAC-A75098E7253F}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {FF6A1591-A016-4E06-A747-6DC1D4BB7126}
	EndGlobalSection
EndGlobal

```

`GreyM/GreyM.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\disassembler\pe_disassembly_engine.cpp" />
    <ClCompile Include="src\main.cpp" />
    <ClCompile Include="src\pch\pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="src\pe\peutils.cpp" />
    <ClCompile Include="src\pe\portable_executable.cpp" />
    <ClCompile Include="src\utils\file_log.cpp" />
    <ClCompile Include="src\pe\section.cpp" />
    <ClCompile Include="src\pe\section_headers.cpp" />
    <ClCompile Include="src\protector.cpp" />
    <ClCompile Include="src\rtti_obfuscator.cpp" />
    <ClCompile Include="src\utils\file_io.cpp" />
    <ClCompile Include="src\utils\shellcode.cpp" />
    <ClCompile Include="src\virtualizer\virtualizer.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\disassembler\pe_disassembly_engine.h" />
    <ClInclude Include="src\pch\pch.h" />
    <ClInclude Include="src\pe\portable_executable.h" />
    <ClInclude Include="src\pe\section.h" />
    <ClInclude Include="src\pe\peutils.h" />
    <ClInclude Include="src\pe\section_headers.h" />
    <ClInclude Include="src\protector.h" />
    <ClInclude Include="src\rtti_obfuscator.h" />
    <ClInclude Include="src\utils\console_log.h" />
    <ClInclude Include="src\utils\defer.h" />
    <ClInclude Include="src\utils\file_io.h" />
    <ClInclude Include="src\utils\file_log.h" />
    <ClInclude Include="src\utils\random.h" />
    <ClInclude Include="src\utils\shellcode.h" />
    <ClInclude Include="src\utils\stopwatch.h" />
    <ClInclude Include="src\utils\string_utils.h" />
    <ClInclude Include="src\virtualizer\virtualizer.h" />
  </ItemGroup>
  <ItemGroup>
    <Text Include="notes.txt" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{3110b0c4-7fcd-4db9-a7a0-98304627c591}</ProjectGuid>
    <RootNamespace>GreyM</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)$(ProjectName)\intermediates\$(Platform)\$(Configuration)\</IntDir>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>false</RunCodeAnalysis>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)$(ProjectName)\intermediates\$(Platform)\$(Configuration)\</IntDir>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>false</RunCodeAnalysis>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)$(ProjectName)\intermediates\$(Platform)\$(Configuration)\</IntDir>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>false</RunCodeAnalysis>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)$(ProjectName)\intermediates\$(Platform)\$(Configuration)\</IntDir>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>false</RunCodeAnalysis>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)src\pch;$(SolutionDir)capstone\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <EnablePREfast>false</EnablePREfast>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <AdditionalLibraryDirectories>$(SolutionDir)capstone\lib\x86\debug;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)src\pch;$(SolutionDir)capstone\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <EnablePREfast>false</EnablePREfast>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <AdditionalLibraryDirectories>$(SolutionDir)capstone\lib\x64\debug;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)src\pch;$(SolutionDir)capstone\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <EnablePREfast>false</EnablePREfast>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalLibraryDirectories>$(SolutionDir)capstone\lib\x86\release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(ProjectDir)src\pch;$(SolutionDir)capstone\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <EnablePREfast>false</EnablePREfast>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalLibraryDirectories>$(SolutionDir)capstone\lib\x64\release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`GreyM/GreyM.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\utils\file_io.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\pch\pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\pe\portable_executable.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\pe\section.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\pe\peutils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\protector.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\virtualizer\virtualizer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\utils\shellcode.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\rtti_obfuscator.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\disassembler\pe_disassembly_engine.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\pe\section_headers.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\utils\file_log.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\utils\file_io.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\pch\pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\pe\portable_executable.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\pe\section.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\pe\peutils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\protector.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\virtualizer\virtualizer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\utils\stopwatch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\utils\shellcode.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\rtti_obfuscator.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\disassembler\pe_disassembly_engine.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\utils\random.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\pe\section_headers.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\utils\string_utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\utils\file_log.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\utils\console_log.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\utils\defer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Text Include="notes.txt" />
  </ItemGroup>
</Project>
```

`GreyM/notes.txt`:

```txt
TODO: Virtualize branch redirection. E.g. JE, JNE
How? Keep information about where to jump, how big the instruction is, if not jump.

Add code that executes before entry point. Why?
In case for some reason, someone removed the TLS callbacks, we have to ensure that they were called
to prevent someone from fixing up imports themselves.
Add the integrity checks there as well.

Turn all VM instructions into universal instructions, meaning:
a struct that all instructions are, including the size, maybe?

https://github.com/corkami/docs/blob/master/PE/PE.md

IN TLS CALLBACKS:
Create new thread that checks for debugger, but make it ThreadHideFromDebugger
Ensure that it is hidden from debugger, otherwise, close program?

USE ANTI DEBUGGING METHOD FROM GWINMEM_TEST
VERY GOOD, ALSO AGAINST SCYLLA


IN THE LOADER SHELLCODE, INSTEAD OF ONLY CALL[RSP-8], RANDOMIZE IT BETWEEN A CALL AND A JUMP THAT SIMULATED A CALL BY PUSHING RET ADD TO STACK

TLS CALLBACK 1:
Fix the address in the tls callback 2
TLS CALLBACK 2:
Dynamically add a new TLS callback

OBJECTIVE

TODO:
	Make the TLS callback add dynamic callback that executes code against debugger and shit

TODO: Replace the pdb path with a link or something funny

TODO: Consider turning every instruction into several instructions
	Turn into garbage code?
	Turn into code that does one thing, than later on after more garbage is undoes that thing?

TODO: All the INT3 instructions between functions can be replaced with
BOGUS code to catch of disassemblers.

```

`GreyM/src/disassembler/pe_disassembly_engine.cpp`:

```cpp
#include "pch.h"
#include "pe_disassembly_engine.h"
#include "../utils/defer.h"

PeDisassemblyEngine::PeDisassemblyEngine( const PortableExecutable pe )
    : pe_( pe ),
      disassembler_handle_( 0 ),
      code_( 0 ),
      current_code_index_( 0 ),
      current_instruction_code_( nullptr ),
      code_buf_size_( 0 ),
      address_( 0 ),
      pe_section_headers_( pe_.GetSectionHeaders() ),
      pe_text_section_header_( pe_section_headers_.FromName( ".text" ) ),
      pe_image_base_( pe_.GetNtHeaders()->OptionalHeader.ImageBase ) {
#ifdef _WIN64
  const cs_mode mode = cs_mode::CS_MODE_64;
#else
  const cs_mode mode = cs_mode::CS_MODE_32;
#endif

  const cs_err cs_status = cs_open( CS_ARCH_X86, mode, &disassembler_handle_ );

  if ( cs_status != cs_err::CS_ERR_OK ) {
    throw std::runtime_error( "cs_open failed with error code " +
                              std::to_string( cs_status ) );
  }

  const cs_err detail_status =
      cs_option( disassembler_handle_, cs_opt_type::CS_OPT_DETAIL, CS_OPT_ON );

  if ( detail_status != cs_err::CS_ERR_OK ) {
    throw std::runtime_error( "cs_option failed with error code " +
                              std::to_string( cs_status ) );
  }
}

void PeDisassemblyEngine::DisassembleFromEntrypoint(
    const tDisassemblingCallback& disassembly_callback,
    const tDisassemblingInvalidInstructionCallback&
        invalid_instruction_callback,
    void* data ) {
  const auto entrypoint_rva =
      pe_.GetNtHeaders()->OptionalHeader.AddressOfEntryPoint;
  const auto entrypoint_offset =
      pe_section_headers_.RvaToFileOffset( entrypoint_rva );

  DisassemblyPoint disasm_point;
  disasm_point.code = pe_.GetPeImagePtr() + entrypoint_offset;
  disasm_point.rva = entrypoint_rva;

  SetDisassemblyPoint( disasm_point, pe_text_section_header_->SizeOfRawData );

  ParseRDataSection();

  ParseTlsCallbacks();

  BeginDisassembling( disassembly_callback, invalid_instruction_callback,
                      data );
}

void PeDisassemblyEngine::SetDisassemblyPoint(
    const DisassemblyPoint& disasm_point,
    const size_t disasm_buffer_size ) {
  code_ = disasm_point.code;
  address_ = disasm_point.rva;
  code_buf_size_ = disasm_buffer_size;
}

bool IsGuaranteedJump( const cs_insn& instruction ) {
  return instruction.id == x86_insn::X86_INS_JMP ||
         instruction.id == x86_insn::X86_INS_LJMP;
}

uintptr_t GetOperandRva( const cs_x86_op& operand,
                         const uintptr_t image_base ) {
  // in x64 pe, the disp is already the rva
  // x64: mov eax, dword ptr ds:[rcx+rax*4+0x10F2F4], (0x10F2F4 is the RVA)
  // x86: jmp dword ptr ds:[ecx*4+0x12EB9C8], (0x12EB9C8 is the rva + image
  // base)

  switch ( operand.type ) {
    case x86_op_type::X86_OP_IMM:
#ifdef _WIN64
      return static_cast<uintptr_t>( operand.imm );
#else
      return static_cast<uintptr_t>( operand.imm ) - image_base;
#endif
      break;
    case x86_op_type::X86_OP_MEM:
#ifdef _WIN64
      return static_cast<uintptr_t>( operand.mem.disp );
#else
      return static_cast<uintptr_t>( operand.mem.disp ) - image_base;
#endif
      break;
    default:
      break;
  }

  throw std::runtime_error( "should never occur" );
}

bool PeDisassemblyEngine::IsVTableOrFunction( const cs_x86_op& operand1,
                                              const cs_x86_op& operand2 ) {
  if ( operand1.type == x86_op_type::X86_OP_MEM &&
       operand2.type == x86_op_type::X86_OP_IMM ) {
    const auto dest_section = pe_section_headers_.FromRva(
        GetOperandRva( operand2, pe_image_base_ ) );
    // if the destination is in a section
    if ( dest_section != nullptr )
      return true;
  }

  return false;
}

bool PeDisassemblyEngine::IsJumpTable( const cs_insn& instruction,
                                       const uint8_t* code,
                                       const uint64_t rva ) {
  const auto& detail = instruction.detail->x86;
#ifdef _WIN64
  if ( detail.op_count == 2 ) {
    return IsJumpTableX64( instruction, detail.operands[ 0 ],
                           detail.operands[ 1 ], code, rva );
  }
#else
  if ( detail.op_count == 1 ) {
    return IsJumpTableX86( instruction, detail.operands[ 0 ] );
  }
#endif

  return false;
}

bool PeDisassemblyEngine::IsJumpTableX86( const cs_insn& instruction,
                                          const cs_x86_op& operand ) {
  // check if the jump is a jump table
  if ( IsGuaranteedJump( instruction ) ||
       instruction.id == x86_insn::X86_INS_MOV ) {
    if ( operand.type == x86_op_type::X86_OP_MEM &&
         operand.mem.scale == sizeof( uint32_t ) ) {
      const auto jump_table_rva = GetOperandRva( operand, pe_image_base_ );

      // is the jump table within the text section?
      if ( section::IsRvaWithinSection(
               *pe_text_section_header_,
               static_cast<uintptr_t>( jump_table_rva ) ) ) {
        return true;
      }
    }
  }

  return false;
}

bool PeDisassemblyEngine::IsJumpTableX64( const cs_insn& instruction,
                                          const cs_x86_op& operand1,
                                          const cs_x86_op& operand2,
                                          const uint8_t* code,
                                          const uint64_t rva ) {
  /*
    ja test executable.7FF6D311F222
    movsxd rax,dword ptr ss:[rbp+174]
    lea rcx,qword ptr ds:[7FF6D3010000]
    * mov eax,dword ptr ds:[rcx+rax*4+10F2F4]
    * add rax,rcx
    * jmp rax
  */

  // x64 jump table example: mov eax, dword ptr ds:[rcx+rax*4+0x10F2F4]
  if ( instruction.id == x86_insn::X86_INS_MOV ) {
    if ( operand1.type == x86_op_type::X86_OP_REG ) {
      if ( operand2.type == x86_op_type::X86_OP_MEM &&
           operand2.mem.scale == sizeof( uint32_t ) ) {
        // disassemble the next 2 instructions
        assert( ( code_buf_size_ - current_code_index_ ) > 0 );

        auto code_copy = code + instruction.size;
        auto code_size = code_buf_size_ - current_code_index_;
        uint64_t rva_copy = rva + static_cast<uint64_t>( instruction.size );

        cs_insn* instruction2 = cs_malloc( disassembler_handle_ );
        Defer( { cs_free( instruction2, 1 ); } );

        // disassemble first instruction
        auto disasm_status =
            cs_disasm_iter( disassembler_handle_, &code_copy, &code_size,
                            &rva_copy, instruction2 );

        if ( instruction2->id != x86_insn::X86_INS_ADD )
          return false;

        if ( instruction2->detail->x86.op_count != 2 )
          return false;

        if ( instruction2->detail->x86.operands[ 0 ].type !=
                 x86_op_type::X86_OP_REG ||
             instruction2->detail->x86.operands[ 1 ].type !=
                 x86_op_type::X86_OP_REG )
          return false;

        const auto saved_add_operand1 =
            instruction2->detail->x86.operands[ 0 ].reg;

        // disassemble second instruction
        disasm_status = cs_disasm_iter( disassembler_handle_, &code_copy,
                                        &code_size, &rva_copy, instruction2 );

        // check if we are jumping to the previously used register in MOV
        if ( IsGuaranteedJump( *instruction2 ) &&
             instruction2->detail->x86.operands[ 0 ].type ==
                 x86_op_type::X86_OP_REG &&
             instruction2->detail->x86.operands[ 0 ].reg == saved_add_operand1 )
          return true;
      }
    }
  }
  return false;
}

DisassemblyPoint
PeDisassemblyEngine::GetOperandDestinationValueDisassasemblyPoint(
    const cs_insn& instruction,
    const uint8_t* instruction_code_ptr,
    const uintptr_t rva ) {
  const auto operand_dest_rva = rva;

  const uint8_t* operand_dest_code = nullptr;

  // In the MOV instruction, the rva we are looking for is an absolute rva,
  // therefore we convert the value to a file offset manually
  if ( instruction.id == x86_insn::X86_INS_MOV ) {
    const auto pe_image_code_ptr = pe_.GetPeImagePtr();
    const auto file_offset =
        pe_section_headers_.RvaToFileOffset( operand_dest_rva );
    operand_dest_code = pe_image_code_ptr + file_offset;
  } else {
    // push or jmp
    const auto dest_delta = operand_dest_rva - instruction.address;
    operand_dest_code = instruction_code_ptr + dest_delta;
  }

  assert( operand_dest_code != nullptr );

  DisassemblyPoint disasm_point;
  disasm_point.rva = operand_dest_rva;
  disasm_point.code = operand_dest_code;

  return disasm_point;
}

void PeDisassemblyEngine::ParseJumpTable( const cs_insn& instruction,
                                          const cs_x86_op& operand ) {
  assert( operand.type == x86_op_type::X86_OP_MEM );

  const auto operand_rva = GetOperandRva( operand, pe_image_base_ );

  AddressRange jump_table_address_range;

  jump_table_address_range.begin_address = operand_rva;

  int i = 0;

  for ( ;; i += operand.mem.scale ) {
    // #ifndef _WIN64
    const auto jump_table_disasm_point =
        GetOperandDestinationValueDisassasemblyPoint(
            instruction, current_instruction_code_, operand_rva );
    //#else
    //    // in x64 mode, the jump tables are MOV's and not JMP's
    //    // meaning that the jump table address is not relative, but absolute
    //    const auto dest_delta = operand_rva - instruction.address;
    //
    //    auto operand_dest_code = current_instruction_code_ + dest_delta;
    //
    //    DisassemblyPoint jump_table_disasm_point;
    //    jump_table_disasm_point.rva = dest_delta;
    //    jump_table_disasm_point.code = const_cast<uint8_t*>( operand_dest_code
    //    );
    //#endif

    const auto jump_table_dest_section =
        pe_section_headers_.FromRva( jump_table_disasm_point.rva );

    // is the jump table located inside any section?
    if ( jump_table_dest_section == nullptr )
      break;

    // is the target function/address within the text section?
    // if ( !pe::IsRvaWithinSection( *pe_text_section_,
    // jump_table_disasm_point.rva) )
    //   break;

    const auto jump_table_code_dest = jump_table_disasm_point.code + i;

    // if the scale is different, then we line below this line won't work
    assert( operand.mem.scale == sizeof( uint32_t ) );

    const auto item_dest_va =
        *reinterpret_cast<const uint32_t*>( jump_table_code_dest );

    // did we reach the end?
    if ( item_dest_va == 0xCCCCCCCC || item_dest_va == 0 )
      break;

#ifdef _WIN64
    const auto item_dest_rva = item_dest_va;  // x64: item_dest_va is also rva,
        // need not subtract image base
#else
    const auto item_dest_rva =
        item_dest_va - pe_image_base_;  // x86: item_dest_va is rva + image base
#endif

    // is the target function/address within the text section?
    if ( !section::IsRvaWithinSection( *pe_text_section_header_,
                                       item_dest_rva ) )
      break;

    const auto item_dest_delta = item_dest_rva - instruction.address;
    const auto item_dest_code = current_instruction_code_ + item_dest_delta;

    DisassemblyPoint disasm_point;
    disasm_point.rva = item_dest_rva;
    disasm_point.code = reinterpret_cast<const uint8_t*>( item_dest_code );

    AddDisassemblyPoint( disasm_point );
  }

  jump_table_address_range.end_address = operand_rva + i;

  data_ranges_.push_back( jump_table_address_range );
}

// checks if the current address that is being disassembled is within a part
// of data within the code section, example a jump table
bool PeDisassemblyEngine::IsAddressWithinDataSectionOfCode(
    const uint64_t address ) {
  for ( const auto& range : data_ranges_ ) {
    // if the current address is within a data section of the .text
    // section example a jump table
    if ( address >= range.begin_address && address < range.end_address ) {
      return true;
    }
  }

  return false;
};

bool PeDisassemblyEngine::IsFunction( const DisassemblyPoint& disasm_point ) {
#ifdef _WIN64
  return IsFunctionX64( disasm_point );
#else
  return IsFunctionX86( disasm_point, 0 );
#endif
}

// Returns true whether or not the instructions are the pattern:
// push ebp
// mov ebp, esp
bool IsFunctionX86Prolog( cs_insn instructions[ 2 ] ) {
  // Ensure the instructions have the correct operand counts
  if ( instructions[ 0 ].detail->x86.op_count != 1 &&
       instructions[ 1 ].detail->x86.op_count != 2 ) {
    return false;
  }

  bool is_push_ebp =
      instructions[ 0 ].id == x86_insn::X86_INS_PUSH &&
      instructions[ 0 ].detail->x86.operands[ 0 ].reg == x86_reg::X86_REG_EBP;

  bool is_mov_ebp_esp =
      instructions[ 1 ].id == x86_insn::X86_INS_MOV &&
      instructions[ 1 ].detail->x86.operands[ 0 ].reg == x86_reg::X86_REG_EBP &&
      instructions[ 1 ].detail->x86.operands[ 1 ].reg == x86_reg::X86_REG_ESP;

  return is_push_ebp && is_mov_ebp_esp;
}

bool PeDisassemblyEngine::IsFunctionX86( const DisassemblyPoint& disasm_point,
                                         int recursion_counter ) {
  const auto rva = disasm_point.rva;
  const auto code = disasm_point.code;

  // we only try to follow jumps 10 times deep
  if ( recursion_counter > 10 )
    return false;

  // Added a temporary check to know whether or not we might even check if code is a function in a non-.text section
  // If this ever occurs, simply change it to an if statement and return false it not in .text section
  assert( section::IsRvaWithinSection( *pe_text_section_header_, rva ) );

  cs_insn* instructions = nullptr;

  assert( ( code_buf_size_ - current_code_index_ ) > 0 );

  const auto kDisassembleInstructionCount = 3;

  const auto disassembled_instruction_count = cs_disasm(
      disassembler_handle_, code, code_buf_size_ - current_code_index_, rva,
      kDisassembleInstructionCount, &instructions );

  Defer( { cs_free( instructions, disassembled_instruction_count ); } );

  if ( disassembled_instruction_count != kDisassembleInstructionCount ) {
    return false;
  }

  auto instruction1 = &instructions[ 0 ];
  auto instruction2 = &instructions[ 1 ];

  if ( IsGuaranteedJump( *instruction1 ) ) {
    const auto& operand = instruction1->detail->x86.operands[ 0 ];
    const auto jump_target_rva = operand.imm;
    const auto jump_dest_disasm_point =
        GetOperandDestinationValueDisassasemblyPoint(
            *instruction1, code, static_cast<uintptr_t>( jump_target_rva ) );
    if ( !section::IsRvaWithinSection( *pe_text_section_header_,
                                       jump_dest_disasm_point.rva ) )
      return false;

    return IsFunctionX86( jump_dest_disasm_point, ++recursion_counter );
  }

  bool is_function = false;

  // if the first instruction is mov edi, edi
  if ( instruction1->id == x86_insn::X86_INS_MOV &&
       instruction1->detail->x86.op_count == 2 &&
       instruction1->detail->x86.operands[ 0 ].reg == x86_reg::X86_REG_EDI &&
       instruction1->detail->x86.operands[ 1 ].reg == x86_reg::X86_REG_EDI ) {
    // Check the function prologue on the next instructions skipping the mov edi, edi
    is_function = IsFunctionX86Prolog( instructions + 1 );
  } else {
    is_function = IsFunctionX86Prolog( instructions );
  }

  // TODO: Check for the epilogue as well
  // mov esp, ebp         ; restore ESP
  // pop ebp              ; restore caller's EBP
  // ret                  ; pop the return address into EIP

  return is_function;
}

bool IsNonVolatileRegister( x86_reg reg ) {
  /*
    Nonvolatilve Registers that must be preseved by the callee:
      R12:R15
      RDI
      RSI
      RBX
      RBP
      RSP
  */

  switch ( reg ) {
    case x86_reg::X86_REG_R12:
    case x86_reg::X86_REG_R13:
    case x86_reg::X86_REG_R14:
    case x86_reg::X86_REG_R15:
    case x86_reg::X86_REG_RDI:
    case x86_reg::X86_REG_RSI:
    case x86_reg::X86_REG_RBX:
    case x86_reg::X86_REG_RBP:
    case x86_reg::X86_REG_RSP:
      return true;
      break;
    default:
      break;
  }

  return false;
};

bool PeDisassemblyEngine::IsFunctionX64(
    const DisassemblyPoint& disasm_point ) {
  assert( ( code_buf_size_ - current_code_index_ ) > 0 );
  bool is_function = false;

  // NOTE: Unsure whether or not this size is correctly calculated, feels off
  auto size = code_buf_size_ - current_code_index_;

  auto code = disasm_point.code;
  auto rva = static_cast<uint64_t>( disasm_point.rva );

  cs_insn* instruction = cs_malloc( disassembler_handle_ );
  Defer( { cs_free( instruction, 1 ); } );

  const auto disasm_status =
      cs_disasm_iter( disassembler_handle_, &code, &size, &rva, instruction );

  if ( !disasm_status ) {
    // If it failed to disassemble the first instruction, it is definitely not a function
    return false;
  }

  assert( instruction );

  // Is the first instruction a jump to the real function?
  if ( IsGuaranteedJump( *instruction ) ) {
    const auto& operand = instruction->detail->x86.operands[ 0 ];
    const auto jump_target_rva = operand.imm;
    const auto jump_dest_disasm_point =
        GetOperandDestinationValueDisassasemblyPoint(
            *instruction, disasm_point.code,
            static_cast<uintptr_t>( jump_target_rva ) );

    if ( !section::IsRvaWithinSection( *pe_text_section_header_,
                                       jump_dest_disasm_point.rva ) ) {
      return false;
    }

    is_function = IsFunctionX64Prolog( jump_dest_disasm_point );
  } else {
    is_function = IsFunctionX64Prolog( disasm_point );
  }

  return is_function;
}

bool PeDisassemblyEngine::IsFunctionX64Prolog(
    const DisassemblyPoint& disasm_point ) {
  /*
    NOTE: Epilog checking is no longer implemented, it was too inconsistent

    https://docs.microsoft.com/en-us/cpp/build/prolog-and-epilog?view=vs-2019
    https://docs.microsoft.com/en-us/cpp/build/x64-software-conventions?view=vs-2019

    Checks if valid x64 function prolog
    What's requirements of valid prolog?

    * First instruction of prolog must exist within 10/5/2 first instructions

    * Must contain at least one type of fixed-stack-alloc instruction
        sub rsp, stack-alloc-size
        or
        lea    R13, 128[RSP] ????

    * If it contains more prolog instructions, all of them must be valid prolog instructions
      The following are valid:
        mov [rsp + any-value % 8 == 0 ], reg (any reg?)
        push non-volatile-reg

        mov rax, rsp
        mov [rax + any-value % 8 == 0], reg (any reg?)


    What does this function do?
    It simply looks for the prolog in the beginning.

    Example x64 function:

    Prolog Description:
    1. MOV's
      Sets up the stack frame pointer for either RSP or RAX, possibly other registers as well. Unsure.
    2. PUSH's
      Preserves the non volatile registers
    3. SUB
      Allocated a fixed size of the stack

    Prolog:
    mov    [RSP + 8], RCX
    push   R15
    push   R14
    push   R13
    sub    RSP, 20

    Epilog Description:
    1. MOV's
      Tears up the frame pointer and gives back the values on the registers previously.
    2. ADD
      Free's the fixed allocated stack
    3. POP's
      Restores the non-volatile registers in the opposite order of the prolog
    4. RET

    Epilog:

    mov    RCX, [RSP + 8]
    add    RSP, 20
    pop    R13
    pop    R14
    pop    R15
    ret
  */

  const auto is_stack_frame_pointer_setup = []( cs_insn* instruction ) {
    // NOTE: In some functions, the instruction: mov rax, rsp
    //                                          mov r11, rsp
    // which sets up the stack frame pointer.
    // the registers are moved into [rax + ?] and not [rsp + ?]

    // mov r11, rsp          <--- This is the stack frame pointer setup
    // mov [r11 + 8], rbx
    // mov [r11 + 16], rsi
    // push rdi
    // sub rsp, 80

    const auto& detail = instruction->detail->x86;

    // is mov ?, ?
    if ( instruction->id == x86_insn::X86_INS_MOV && detail.op_count == 2 ) {
      const auto& operand1 = detail.operands[ 0 ];
      const auto& operand2 = detail.operands[ 1 ];

      // is mov reg, reg
      if ( operand1.type == x86_op_type::X86_OP_REG &&
           operand2.type == x86_op_type::X86_OP_REG ) {
        // is mov reg, rsp
        if ( operand2.reg == x86_reg::X86_REG_RSP ) {
          return true;
        }
      }
    }

    return false;
  };

  const auto is_valid_stack_frame_pointer_setup_instruction =
      []( cs_insn* instruction, x86_reg stack_frame_pointer_reg ) {
        // mov r11, rsp
        // mov [r11 + 8], rbx       <--- This is the stack frame pointer setup instruction
        // mov [r11 + 16], rsi      <--- This is the stack frame pointer setup instruction
        // push rdi
        // sub rsp, 80

        const auto& detail = instruction->detail->x86;

        // is mov ?, ?
        if ( instruction->id == x86_insn::X86_INS_MOV &&
             detail.op_count == 2 ) {
          const auto& operand1 = detail.operands[ 0 ];

          // is mov [stack_frame_pointer_reg + ?], ?
          if ( operand1.type == x86_op_type::X86_OP_MEM &&
               operand1.mem.base == stack_frame_pointer_reg ) {
            const bool is_on_a_x64_alignment =
                operand1.mem.disp % sizeof( uint64_t ) == 0;

            const auto& operand2 = detail.operands[ 1 ];

            // is mov [rsp + ?], reg
            if ( operand2.type == x86_op_type::X86_OP_REG &&
                 is_on_a_x64_alignment ) {
              return true;
            }
          }
        }

        return false;
      };

  const auto is_valid_preserve_reg_instruction = []( cs_insn* instruction,
                                                     x86_insn instruction_id ) {
    // mov r11, rsp
    // mov [r11 + 8], rbx
    // mov [r11 + 16], rsi
    // push rdi                 <--- This is the preserve register instruction
    // sub rsp, 80

    const auto& detail = instruction->detail->x86;

    // is push ?
    if ( instruction->id == instruction_id && detail.op_count == 1 ) {
      const auto& operand = detail.operands[ 0 ];

      // is push reg
      if ( operand.type == x86_op_type::X86_OP_REG ) {
        // is push non-volatile-reg
        if ( IsNonVolatileRegister( operand.reg ) ) {
          return true;
        }
      }
    }

    return false;
  };

  const auto is_valid_push = [&]( cs_insn* instruction ) {
    return is_valid_preserve_reg_instruction( instruction,
                                              x86_insn::X86_INS_PUSH );
  };

  const auto is_valid_fixed_stack_instruction = []( cs_insn* instruction,
                                                    x86_insn instruction_id ) {
    // mov r11, rsp
    // mov [r11 + 8], rbx
    // mov [r11 + 16], rsi
    // push rdi
    // sub rsp, 80            <--- This is the fixed stack alloc instruction

    const auto& detail = instruction->detail->x86;

    // is sub ?, ?
    if ( instruction->id == instruction_id && detail.op_count == 2 ) {
      const auto& operand1 = detail.operands[ 0 ];

      // is sub rsp, ?
      if ( operand1.type == x86_op_type::X86_OP_REG &&
           operand1.reg == x86_reg::X86_REG_RSP ) {
        const auto& operand2 = detail.operands[ 1 ];

        // Unique case if the stack allocated is larger than a page of
        // memory, handle when occurs to know if correct
        assert( operand2.imm < 0x1000 );

        // is sub rsp, imm
        if ( operand2.type == x86_op_type::X86_OP_IMM ) {
          return true;
        }
      }
    }

    return false;
  };

  const auto is_valid_sub = [&]( cs_insn* instruction ) {
    return is_valid_fixed_stack_instruction( instruction,
                                             x86_insn::X86_INS_SUB );
  };

  auto code = disasm_point.code;
  auto rva = static_cast<uint64_t>( disasm_point.rva );

  // NOTE: Unsure whether or not this size is correctly calculated, feels off
  auto size = code_buf_size_ - current_code_index_;

  cs_insn* instruction = cs_malloc( disassembler_handle_ );
  Defer( { cs_free( instruction, 1 ); } );

  uint32_t setup_stackframe_pointer_instructions_count = 0;
  uint32_t preserved_registers_count = 0;
  bool has_allocating_stack_instruction = false;

  enum class PrologSteps {
    FindStackFramePointerRegister,
    FindStackFramePointerSetup,
    FindPreserveNonVolatileRegisters,
    FindFixedStack,
  };

  PrologSteps current_prolog_step = PrologSteps::FindStackFramePointerRegister;

  bool is_function = false;

  bool next_instruction = true;

  bool finished = false;

  constexpr x86_reg kDefaultStackFramePointerReg = x86_reg::X86_REG_RSP;
  x86_reg stack_frame_pointer_reg = kDefaultStackFramePointerReg;

  cs_insn* first_instruction = cs_malloc( disassembler_handle_ );

  Defer( { cs_free( first_instruction, 1 ); } );

  auto code_copy = code;
  auto rva_copy = rva;
  auto size_copy = size;

  const auto disasm_status =
      cs_disasm_iter( disassembler_handle_, &code_copy, &size_copy, &rva_copy,
                      first_instruction );

  if ( !disasm_status ) {
    // Is no function
    return false;
  }

  const bool is_prolog_instruction =
      is_stack_frame_pointer_setup( first_instruction ) ||
      is_valid_stack_frame_pointer_setup_instruction(
          first_instruction, stack_frame_pointer_reg ) ||
      is_valid_push( first_instruction ) || is_valid_sub( first_instruction );

  // If the first instruction is not a instruction valid for the prolog
  if ( !is_prolog_instruction ) {
    // Is no function
    return false;
  }

  while ( !finished ) {
    if ( next_instruction ) {
      const auto disasm_status = cs_disasm_iter( disassembler_handle_, &code,
                                                 &size, &rva, instruction );

      // If it failed to disassemble the instruction, we cannot
      // only assume we have reached invalid executable code
      if ( !disasm_status ) {
        is_function = false;
        finished = true;
        break;
      }

      const bool is_interrupt = cs_insn_group(
          disassembler_handle_, instruction, cs_group_type::CS_GRP_INT );

      const bool is_ret = cs_insn_group( disassembler_handle_, instruction,
                                         cs_group_type::CS_GRP_RET );

      // If the instruction is an e.g INT3, then we have gone outside the bounds of the function
      if ( is_interrupt || is_ret ) {
        is_function = false;
        finished = true;
        break;
      }

      next_instruction = false;
    }

    switch ( current_prolog_step ) {
      case PrologSteps::FindStackFramePointerRegister: {
        if ( is_stack_frame_pointer_setup( instruction ) ) {
          // Save the stack frame pointer register for use in the next step
          stack_frame_pointer_reg = instruction->detail->x86.operands[ 0 ].reg;
          next_instruction = true;
        }

        // If the first instruction is not this, we assume it will never
        // go the next or next one again. Therefore we go immediately to the next step
        current_prolog_step = PrologSteps::FindStackFramePointerSetup;
      } break;

      case PrologSteps::FindStackFramePointerSetup: {
        if ( is_valid_stack_frame_pointer_setup_instruction(
                 instruction, stack_frame_pointer_reg ) ) {
          ++setup_stackframe_pointer_instructions_count;
          next_instruction = true;
        } else {
          // If there are no stack frame pointer setup instructions, BUT there is a stack frame pointer register setup
          // Then it is really fuckin' fishy bruh. Probably not a function.
          if ( stack_frame_pointer_reg != kDefaultStackFramePointerReg &&
               setup_stackframe_pointer_instructions_count <= 0 ) {
            is_function = false;
            finished = true;
            break;
          }

          current_prolog_step = PrologSteps::FindPreserveNonVolatileRegisters;
        }
      } break;

      case PrologSteps::FindPreserveNonVolatileRegisters: {
        if ( is_valid_push( instruction ) ) {
          ++preserved_registers_count;
          next_instruction = true;
        } else {
          current_prolog_step = PrologSteps::FindFixedStack;
        }
      } break;

      case PrologSteps::FindFixedStack: {
        if ( is_valid_sub( instruction ) ) {
          has_allocating_stack_instruction = true;
        } else {
          has_allocating_stack_instruction = false;
        }

        // Require that we have preserved registers and allocated a
        // stack in a prolog for to be a valid function
        const bool prolog_exists =
            preserved_registers_count > 0 && has_allocating_stack_instruction;

        // If no prolog exists, it is no valid function
        if ( !prolog_exists ) {
          is_function = false;
          finished = true;
          break;
        } else {
          is_function = true;
          finished = true;
          break;
        }
      } break;
      default:
        assert( false );
        break;
    }
  }

  return is_function;
}

DisassemblyAction PeDisassemblyEngine::ParseInstruction(
    const cs_insn& instruction ) {
  const bool is_ret = cs_insn_group( disassembler_handle_, &instruction,
                                     cs_group_type::CS_GRP_RET );
  const bool is_interrupt = cs_insn_group( disassembler_handle_, &instruction,
                                           cs_group_type::CS_GRP_INT );
  const bool is_jump = cs_insn_group( disassembler_handle_, &instruction,
                                      cs_group_type::CS_GRP_JUMP );
  const bool is_call = cs_insn_group( disassembler_handle_, &instruction,
                                      cs_group_type::CS_GRP_CALL );

  const auto& ins_detail = instruction.detail->x86;

  if ( is_ret ) {
    // if the instruction is a return
    return DisassemblyAction::NextDisassemblyPoint;
  } else if ( is_call || is_jump ) {
    if ( ins_detail.op_count == 1 ) {
      const auto& operand = ins_detail.operands[ 0 ];

      if ( operand.type == x86_op_type::X86_OP_IMM ) {
        const auto dest_delta = operand.imm - instruction.address;

        // since the capstone api automatically increases the code and address
        // after disassembling the instruction, we have to calulcate the
        // original code pointer outselves.
        const uint8_t* instruction_code_ptr = code_ - instruction.size;

        DisassemblyPoint disasm_point;
        disasm_point.rva =
            static_cast<uintptr_t>( instruction.address + dest_delta );
        disasm_point.code =
            const_cast<uint8_t*>( instruction_code_ptr ) + dest_delta;

        AddDisassemblyPoint( disasm_point );

        if ( IsGuaranteedJump( instruction ) ) {
          // go immediately parse the jump destination
          return DisassemblyAction::NextDisassemblyPoint;
        } else {
          // continue disassembling on the next instruction
          return DisassemblyAction::NextInstruction;
        }
      } else if ( IsJumpTable( instruction, current_instruction_code_,
                               instruction.address ) ) {
        ParseJumpTable( instruction, operand );
        return DisassemblyAction::NextDisassemblyPoint;
      }
    } else {
      // invalid instruction, return ti another disassembly point
      return DisassemblyAction::NextDisassemblyPoint;
      // assert( false );
    }

    if ( IsGuaranteedJump( instruction ) ) {
      // go immediately parse the jump destination
      return DisassemblyAction::NextDisassemblyPoint;
    } else {
      // continue on the next instruction
      return DisassemblyAction::NextInstruction;
    }
  } else if ( is_interrupt ) {
    return DisassemblyAction::NextDisassemblyPoint;
  } else {
    if ( instruction.address == 0x10F1A6 ) {
      int test = 0;
    }

    switch ( instruction.id ) {
      case x86_insn::X86_INS_MOV: {
        switch ( ins_detail.op_count ) {
          case 2: {
            const auto& operand1 = ins_detail.operands[ 0 ];
            const auto& operand2 = ins_detail.operands[ 1 ];

            if ( IsJumpTable( instruction, current_instruction_code_,
                              instruction.address ) ) {
#ifndef _WIN64
              assert( false &&
                      "did we reach this in x86, we're only supposed to be "
                      "here in x64 for jump tables." );
#endif
              ParseJumpTable( instruction, operand2 );
              return DisassemblyAction::NextDisassemblyPoint;
            } else if ( IsVTableOrFunction( operand1, operand2 ) ) {
              // mov mem_op, imm_op
              // if is function

              const auto dest_disasm_point =
                  GetOperandDestinationValueDisassasemblyPoint(
                      instruction, current_instruction_code_,
                      GetOperandRva( operand2, pe_image_base_ ) );

              // if we are not in the text section, then don't even bother
              // checking if it is a function it is most likely a pointer to the
              // .rdata section or something
              if ( section::IsRvaWithinSection( *pe_text_section_header_,
                                                dest_disasm_point.rva ) &&
                   IsFunction( dest_disasm_point ) ) {
                AddDisassemblyPoint( dest_disasm_point );
                return DisassemblyAction::NextInstruction;
              } else {
                // if not a function, the maybe a vtable

                // TODO: Fix the function when we even come to a function that
                // has a vtable
                /*
                for ( int i = 0;; i += 4 ) {
                  const auto jump_table_disasm_point =
                      GetOperandDestinationValueDisassasemblyPoint(
                          instruction, current_instruction_code_,
                          GetOperandRva( operand2, pe_image_base_ ) );

                  // if the jump table is not within the text section? really?
                  // what? if ( !pe::IsRvaWithinSection( *pe_text_section_,
                  //                               jump_table_disasm_point.rva )
                  //                               )
                  //   break;

                  if ( pe::GetSectionByRva( pe_sections_,
                                            jump_table_disasm_point.rva ) ==
                       nullptr )
                    break;

                  const auto jump_table_code_dest =
                      jump_table_disasm_point.code + i;

                  const auto item_dest_va = *reinterpret_cast<const uint32_t*>(
                      jump_table_code_dest );

                  // did we reach the end?
                  if ( item_dest_va == 0xCCCCCCCC )
                    break;

#ifdef _WIN64
                  const auto item_dest_rva =
                      item_dest_va;  // x64: item_dest_va is also rva,
                                     // need not subtract image base
#else
                  const auto item_dest_rva =
                      item_dest_va -
                      pe_image_base_;  // x86: item_dest_va is rva + image base
#endif

                  // is the target function/address within the text section?
                  if ( !pe::IsRvaWithinSection( *pe_text_section_,
                                                item_dest_rva ) )
                    break;

                  const auto item_dest_delta =
                      item_dest_rva - instruction.address;
                  const auto item_dest_code =
                      current_instruction_code_ + item_dest_delta;

                  // TODO: add it to the disassembly points array here
                  DisassemblyPoint disasm_point;
                  disasm_point.rva = item_dest_rva;
                  disasm_point.code = const_cast<uint8_t*>( item_dest_code );

                  if ( IsFunction( disasm_point.code, disasm_point.rva ) ) {
                    // it is a jump table with valid functions lol
                    int test = 0;
                  }
                }
                */
              }
            }
          } break;
          default:
            break;
        }
      } break;

      case x86_insn::X86_INS_PUSH: {
        const auto operand = ins_detail.operands[ 0 ];
        if ( operand.type == x86_op_type::X86_OP_IMM ) {
          const auto operand_rva = GetOperandRva( operand, pe_image_base_ );

          if ( section::IsRvaWithinSection( *pe_text_section_header_,
                                            operand_rva ) ) {
            const auto dest_disasm =
                GetOperandDestinationValueDisassasemblyPoint(
                    instruction, current_instruction_code_, operand_rva );

            if ( IsFunction( dest_disasm ) ) {
              AddDisassemblyPoint( dest_disasm );
            }
          }
        }
      } break;

      default:
        break;
    }
  }

  return DisassemblyAction::NextInstruction;
}

bool PeDisassemblyEngine::ContinueFromDisassemblyPoints() {
  if ( disassembly_points_.empty() ) {
    return false;
  }

  const auto next_disasm_point = disassembly_points_.back();

  code_ = next_disasm_point.code;
  address_ = next_disasm_point.rva;

  disassembly_points_.pop_back();

  return true;
}

void PeDisassemblyEngine::ParseRDataSection() {
  const auto rdata_section_header = pe_section_headers_.FromName( ".rdata" );

  if ( rdata_section_header == nullptr ) {
    throw std::runtime_error( ".rdata was not found" );
  }

  const auto pe_image_ptr = pe_.GetPeImagePtr();

  auto rdata_ptr = pe_image_ptr + rdata_section_header->PointerToRawData;

  const auto rdata_end = rdata_ptr + rdata_section_header->SizeOfRawData;

  for ( ; rdata_ptr < rdata_end; rdata_ptr += sizeof( uintptr_t ) ) {
    const auto value = *reinterpret_cast<const uintptr_t*>( rdata_ptr );

    if ( value == 0 ) {
      continue;
    }

    // We subtract the image base to check whether or not it is a valid RVA value
    const auto value_rva = value - pe_image_base_;

    // Is the rva valid and within the .text section?
    if ( section::IsRvaWithinSection( *pe_text_section_header_, value_rva ) ) {
      const auto value_file_offset =
          pe_section_headers_.RvaToFileOffset( value_rva );

      if ( value_file_offset == 0 ) {
        continue;
      }

      const auto value_destination_ptr = pe_image_ptr + value_file_offset;

      DisassemblyPoint disasm_point;
      {
        disasm_point.code = value_destination_ptr;
        disasm_point.rva = value_rva;
      }

      if ( IsFunction( disasm_point ) ) {
        AddDisassemblyPoint( disasm_point );
      }
    }
  }
}

void PeDisassemblyEngine::ParseTlsCallbacks() {
  const auto nt_headers = pe_.GetNtHeaders();
  const auto image_base = nt_headers->OptionalHeader.ImageBase;

  const auto sections = pe_.GetSectionHeaders();

  auto tls_callback_list = pe_.GetTlsCallbacklist();

  for ( const auto callback : tls_callback_list ) {
    DisassemblyPoint disasm_point;

    const auto rva = callback - image_base;

    const auto callback_code_offset = sections.RvaToFileOffset( rva );

    disasm_point.rva = rva;
    disasm_point.code = pe_.GetPeImagePtr() + callback_code_offset;

    AddDisassemblyPoint( disasm_point );
  }
}

void PeDisassemblyEngine::AddDisassemblyPoint(
    const DisassemblyPoint& disasm_point ) {
  const bool exists = disassembly_points_cache_.find( disasm_point.rva ) !=
                      disassembly_points_cache_.end();

  if ( !exists ) {
    disassembly_points_.push_back( disasm_point );
    disassembly_points_cache_.insert( disasm_point.rva );
  }
}

void PeDisassemblyEngine::BeginDisassembling(
    const tDisassemblingCallback& disassembly_callback,
    const tDisassemblingInvalidInstructionCallback&
        invalid_instruction_callback,
    void* data ) {
  bool finished = false;

  // allocate memory for one instruction and use this memory for all instruction
  // to increase performance
  cs_insn* instruction = cs_malloc( disassembler_handle_ );

  while ( !finished ) {
    // are we outside the buffer?
    if ( ( code_buf_size_ - current_code_index_ ) <= 0 ) {
      // try to continue from the saved disassembly points
      if ( !ContinueFromDisassemblyPoints() ) {
        finished = true;
        break;
      }
    }

    // save the code pointer because capstone modifies it to next instruction
    // when disassembling an instruction
    current_instruction_code_ = code_;

    // has the instruction already been disassembled?
    if ( ( disassembled_instructions_.find( static_cast<uintptr_t>(
               address_ ) ) != disassembled_instructions_.end() ) ||
         IsAddressWithinDataSectionOfCode( address_ ) ) {
      // continue disassembling instructions from the saved redirection
      // instructions
      if ( !ContinueFromDisassemblyPoints() ) {
        finished = true;
        break;
      }

      continue;
    }

    if ( !cs_disasm_iter( disassembler_handle_, &code_, &code_buf_size_,
                          &address_, instruction ) ) {
      // If the instruction is invalid, just continue like normal but continue
      // on an instruction from the disassembly points
      // At the end of the disassembling, we fix the invalid instructions

      if ( !ContinueFromDisassemblyPoints() ) {
        finished = true;
        break;
      }

      continue;
    }

    current_code_index_ += instruction->size;

    // try virtualize it
    // parse it to further see if should continue disassembly
    disassembly_callback( *instruction, current_instruction_code_, data );

    const auto next_disasm_action = ParseInstruction( *instruction );

    // returns the next instruction to disassemble
    switch ( next_disasm_action ) {
      case DisassemblyAction::NextInstruction: {
        // we do not need to change the code or address values because capstone
        // does it for us
      } break;

      case DisassemblyAction::NextDisassemblyPoint: {
        if ( !ContinueFromDisassemblyPoints() ) {
          finished = true;
          break;
        }
      } break;
      default:
        assert( false );
        break;
    }

    SmallInstructionData dick( instruction->size, current_instruction_code_ );

    disassembled_instructions_.insert( std::make_pair(
        static_cast<uintptr_t>( instruction->address ), dick ) );
  }

  // when finished
  // go through the each disassembled_instructions_ entry and check if the
  // address is inside the ranges of data
  // if true, replace the (jmp) bytes with the original_pe bytes to remove the
  // virtualization

  std::unordered_set<uint64_t> already_invalidated_instruction_addresses_;

  // we do this because switch tables can be read in wrong order, meaning
  // reaching and disassembling the data part of jump table before know it is
  // actually a jump table
  for ( const auto& ins : disassembled_instructions_ ) {
    const bool already_invalidated =
        already_invalidated_instruction_addresses_.find( ins.first ) !=
        already_invalidated_instruction_addresses_.end();

    // Go through each disassembled instruction and check if it is within a data
    // section of the code, such as a jump table
    if ( IsAddressWithinDataSectionOfCode( ins.first ) &&
         !already_invalidated ) {
      invalid_instruction_callback( ins.first, ins.second, data );
      already_invalidated_instruction_addresses_.insert( ins.first );

      DisassemblyPoint disasm_point;
      disasm_point.code = ins.second.code_ptr_;
      disasm_point.rva = ins.first;

      SetDisassemblyPoint( disasm_point,
                           pe_text_section_header_->SizeOfRawData );

      const auto InvalidInstructionCallback =
          [&]( const uint64_t address, const SmallInstructionData ins_data ) {
            // dont know what to do here
            assert( false );
          };

      const auto EachInstructionCallback = [&]( const cs_insn& instruction,
                                                const uint8_t* code ) {
        const bool already_invalidated2 =
            already_invalidated_instruction_addresses_.find( ins.first ) !=
            already_invalidated_instruction_addresses_.end();

        // if instruction has not already been invalidated
        if ( !already_invalidated2 ) {
          // Call original invalid instruction callback
          invalid_instruction_callback( ins.first, ins.second, data );
        }
      };

      // Clear the cache so the disassembler acts like its the first time
      // disassembling the code
      disassembly_points_cache_.clear();

      // Disassemble from the point of the invalid instruction to identify what
      // more wrong instructions the disassembler thought was real code
      // Then for all the so called "valid" instruction, turn invalid by calling
      // the original invalid callback for original caller
      BeginDisassemblingMinimal( EachInstructionCallback,
                                 InvalidInstructionCallback );

      already_invalidated_instruction_addresses_.insert( ins.first );
    }
  }

  cs_free( instruction, 1 );
}
```

`GreyM/src/disassembler/pe_disassembly_engine.h`:

```h
#pragma once

#include "../pe/portable_executable.h"

struct SmallInstructionData {
 public:
  SmallInstructionData( uint16_t instruction_size, const uint8_t* code )
      : instruction_size_( instruction_size ), code_ptr_( code ) {}

  uint16_t instruction_size_;
  const uint8_t* code_ptr_;
};

using tDisassemblingCallback = void ( * )( const cs_insn& instruction,
                                           const uint8_t* code,
                                           void* data );

using tDisassemblingInvalidInstructionCallback =
    void ( * )( const uint64_t address,
                const SmallInstructionData ins_data,
                void* data );

enum class DisassemblyAction {
  // Disassemble the next instruction
  NextInstruction,

  // Continue disassembling on a address from the saved stack
  NextDisassemblyPoint,
};

struct DisassemblyPoint {
  uintptr_t rva;
  const uint8_t* code;

  bool operator<( const DisassemblyPoint& rhs ) const {
    return rva < rhs.rva;
  }
};

struct AddressRange {
  uintptr_t begin_address;
  uintptr_t end_address;
};

class PeDisassemblyEngine {
 public:
  PeDisassemblyEngine( const PortableExecutable pe );

  void DisassembleFromEntrypoint(
      const tDisassemblingCallback& disassembly_callback,
      const tDisassemblingInvalidInstructionCallback&
          invalid_instruction_callback,
      void* data );

  void AddDisassemblyPoint( const DisassemblyPoint& disasm_point );

  void BeginDisassembling( const tDisassemblingCallback& disassembly_callback,
                           const tDisassemblingInvalidInstructionCallback&
                               invalid_instruction_callback,
                           void* data );

  void SetDisassemblyPoint( const DisassemblyPoint& disasm_point,
                            const size_t disasm_buffer_size );

 private:
  // Only used for internal use for the invalid instruction checking part
  template <typename TFunc = tDisassemblingCallback,
            typename TFunc2 = tDisassemblingInvalidInstructionCallback>
  void BeginDisassemblingMinimal( const TFunc& disassembly_callback,
                                  const TFunc2& invalid_instruction_callback );

  bool IsAddressWithinDataSectionOfCode( const uint64_t address );

  bool IsFunction( const DisassemblyPoint& disasm_point );
  bool IsFunctionX86( const DisassemblyPoint& disasm_point,
                      int recursion_counter );
  bool IsFunctionX64( const DisassemblyPoint& disasm_point );
  bool IsFunctionX64Prolog( const DisassemblyPoint& disasm_point );

  DisassemblyAction ParseInstruction( const cs_insn& instruction );

  bool IsVTableOrFunction( const cs_x86_op& operand1,
                           const cs_x86_op& operand2 );

  bool IsJumpTable( const cs_insn& instruction,
                    const uint8_t* code,
                    const uint64_t rva );
  bool IsJumpTableX86( const cs_insn& instruction, const cs_x86_op& operand );
  bool IsJumpTableX64( const cs_insn& instruction,
                       const cs_x86_op& operand1,
                       const cs_x86_op& operand2,
                       const uint8_t* code,
                       const uint64_t rva );

  DisassemblyPoint GetOperandDestinationValueDisassasemblyPoint(
      const cs_insn& instruction,
      const uint8_t* instruction_code_ptr,
      const uintptr_t rva );
  void ParseJumpTable( const cs_insn& instruction, const cs_x86_op& operand );

  // ContinueFromRedirectionInstructions returns false if no more instructions
  // are found
  bool ContinueFromDisassemblyPoints();

  // Finds all the virtual functions in the rdata section
  void ParseRDataSection();

  // Adds each of the TLS callback to the disassembly points
  void ParseTlsCallbacks();

 private:
  const PortableExecutable pe_;

  csh disassembler_handle_;

  const uint8_t* code_;
  uint32_t current_code_index_;

  // is the code of the current instruction because capstone modifies code_
  // itself
  const uint8_t* current_instruction_code_;

  size_t code_buf_size_;
  uint64_t address_;
  std::vector<DisassemblyPoint> disassembly_points_;

  // keeps track of each disassembly point that was added to avoid duplicates
  std::unordered_set<uint64_t> disassembly_points_cache_;

  // keeps track of all disassembled instructions to avoid disassembling them
  // again
  // first: address, second: instruction size
  std::unordered_map<uintptr_t, SmallInstructionData>
      disassembled_instructions_;

  // represents an area/range that is data and not code
  // example: jump table, that is data and not code
  std::vector<AddressRange> data_ranges_;

  const uintptr_t pe_image_base_;

  const SectionHeaders pe_section_headers_;
  const IMAGE_SECTION_HEADER* pe_text_section_header_;
};

template <typename TFunc, typename TFunc2>
void PeDisassemblyEngine::BeginDisassemblingMinimal(
    const TFunc& disassembly_callback,
    const TFunc2& invalid_instruction_callback ) {
  bool finished = false;

  // allocate memory for one instruction and use this memory for all instruction
  // to increate performance
  cs_insn* instruction = cs_malloc( disassembler_handle_ );

  while ( !finished ) {
    // are we outside the buffer?
    if ( ( code_buf_size_ - current_code_index_ ) <= 0 ) {
      // try to continue from the saved disassembly points
      if ( !ContinueFromDisassemblyPoints() ) {
        finished = true;
        break;
      }
    }

    // save the code pointer because capstone modifies it to next instruction
    // when disassembling an instruction
    current_instruction_code_ = code_;

    if ( !cs_disasm_iter( disassembler_handle_, &code_, &code_buf_size_,
                          &address_, instruction ) ) {
      // failed to disassemble instruction
      // stop disassembly and continue on another address on the stack / set
      // this usually means that we've reached an invalid instruction, meaning
      // parsing of the instruction flow has been incorrect
      // assert( false );
      // continue disassembling instructions from the saved redirection
      // instructions

      if ( !ContinueFromDisassemblyPoints() ) {
        finished = true;
        break;
      }

      continue;
    }

    current_code_index_ += instruction->size;

    // try virtualize it
    // parse it to further see if should continue disassembly
    disassembly_callback( *instruction, current_instruction_code_ );

    const auto next_disasm_action = ParseInstruction( *instruction );

    // returns the next instruction to disassemble
    switch ( next_disasm_action ) {
      case DisassemblyAction::NextInstruction: {
        // we do not need to change the code or address values because capstone
        // does it for us
      } break;

      case DisassemblyAction::NextDisassemblyPoint: {
        if ( !ContinueFromDisassemblyPoints() ) {
          finished = true;
          break;
        }
      } break;
      default:
        assert( false );
        break;
    }
  }
}
```

`GreyM/src/main.cpp`:

```cpp
#include "pch.h"

#include "pe/portable_executable.h"
#include "utils/file_io.h"
#include "protector.h"

#include "utils/console_log.h"

#pragma comment( lib, "capstone.lib" )

int main( int argc, char* argv[] ) {
  try {
    srand( static_cast<unsigned int>( time( 0 ) ) );

    const std::string current_dir = argv[ 0 ];

    const std::string parent_dir =
        current_dir.substr( 0, current_dir.find_last_of( '\\' ) + 1 );

    const std::wstring parent_dir_wide =
        std::wstring( parent_dir.begin(), parent_dir.end() );

    const auto target_file_data = fileio::ReadBinaryFile(
        parent_dir_wide + TEXT( "Test Executable.exe" ) );

    if ( target_file_data.empty() ) {
      console::Print( "Unable to open the target file." );
      std::cin.get();
      return -1;
    }

    auto target_pe = pe::Open( target_file_data );

    if ( target_pe.IsValid() ) {
      const auto new_protected_pe = protector::Protect( target_pe );
      if ( !fileio::WriteFileData(
               parent_dir_wide + TEXT( "Test Executable Out.exe" ),
               new_protected_pe.GetPeData() ) ) {
        console::Print( "Unable to write output file" );
      }
    } else {
      console::Print( "The PE is not valid." );
      std::cin.get();
      return -1;
    }

  } catch ( std::exception ex ) {
    console::Print( ex.what() );
  }

  std::cin.get();

  return 0;
}
```

`GreyM/src/pch/pch.cpp`:

```cpp
#include "pch.h"


```

`GreyM/src/pch/pch.h`:

```h
#pragma once

#define _CRT_SECURE_NO_WARNINGS

#include <vector>
#include <string>
#include <Windows.h>
#include <iostream>
#include <assert.h>
#include <unordered_set>
#include <set>
#include <unordered_map>
#include <initializer_list>
#include <algorithm>
#include <ctime>
#include <array>
#include <fstream>
#include <functional>

#include "capstone/capstone.h"
```

`GreyM/src/pe/peutils.cpp`:

```cpp
#include "pch.h"
#include "peutils.h"

namespace peutils {

uintptr_t AlignUp( const uintptr_t value, const uintptr_t alignment ) {
  // return ( ( ( value + alignment - 1 ) / alignment ) * alignment );
  const auto remainder = value % alignment;

  // is it already aligned?
  if ( remainder == 0 )
    return value;

  return value + ( alignment - remainder );
}

uintptr_t AlignDown( const uintptr_t value, const uintptr_t alignment ) {
  return value - ( value % alignment );
}

IMAGE_DOS_HEADER* GetDosHeader( uint8_t* data ) {
  return reinterpret_cast<IMAGE_DOS_HEADER*>( data );
}

IMAGE_NT_HEADERS* GetNtHeaders( uint8_t* data ) {
  auto dos_headers_ = GetDosHeader( data );
  auto nt_headers =
      reinterpret_cast<IMAGE_NT_HEADERS*>( data + dos_headers_->e_lfanew );

  return nt_headers;
}

}  // namespace peutils
```

`GreyM/src/pe/peutils.h`:

```h
#pragma once

namespace peutils {

uintptr_t AlignUp( const uintptr_t value, const uintptr_t alignment );
uintptr_t AlignDown( const uintptr_t value, const uintptr_t alignment );

IMAGE_DOS_HEADER* GetDosHeader( uint8_t* data );
IMAGE_NT_HEADERS* GetNtHeaders( uint8_t* data );

}  // namespace peutils
```

`GreyM/src/pe/portable_executable.cpp`:

```cpp
#include "pch.h"
#include "portable_executable.h"
#include "peutils.h"

PortableExecutable pe::Open( const std::vector<uint8_t>& pe_data ) {
  return PortableExecutable( pe_data );
}

PortableExecutable pe::Build( const std::vector<uint8_t>& header,
                              const std::vector<Section>& sections ) {
  std::vector<uint8_t> pe_data;

  uint32_t section_data_size = 0;

  for ( const auto& section : sections )
    section_data_size += section.data_.size();

  // Reserve all required memory to avoid memory performance footprint
  pe_data.reserve( header.size() + section_data_size );

  // Append the header
  pe_data.insert( pe_data.begin(), header.begin(), header.end() );

  const auto nt_headers = *peutils::GetNtHeaders( &pe_data[ 0 ] );

  auto sections_copy = sections;

  for ( size_t i = 0; i < sections_copy.size(); ++i ) {
    auto& section = sections_copy[ i ];

    // If there is no initial data specified by the section headers
    if ( !section.section_header_.PointerToRawData ) {
      // Check if the user has added data manually on the section
      if ( section.data_.size() > 0 ) {
        // Ensure that we do not go out of bounds
        assert( ( i - 1 ) > 0 );

        const auto raw_data_offset = peutils::AlignUp(
            pe_data.size(), nt_headers.OptionalHeader.FileAlignment );

        // Insert padding data before the real code
        pe_data.insert( pe_data.end(), raw_data_offset - pe_data.size(), 0xCC );

        // They must be equal to each other, if not, something very bad occured
        assert( pe_data.size() == raw_data_offset );

        // Set the PointerToRawData appropriately
        section.section_header_.PointerToRawData = raw_data_offset;

        // If it is the first section, there is no previous section to add on top
        if ( i == 0 ) {
          section.section_header_.VirtualAddress =
              peutils::AlignUp( nt_headers.OptionalHeader.SizeOfHeaders,
                                nt_headers.OptionalHeader.SectionAlignment );
        } else {
          const auto& previous_section = sections_copy[ i - 1 ];

          section.section_header_.VirtualAddress = peutils::AlignUp(
              previous_section.section_header_.VirtualAddress +
                  previous_section.section_header_.Misc.VirtualSize,
              nt_headers.OptionalHeader.SectionAlignment );
        }
      }
    }

    // Get an updated version of nt header, because when we insert data into
    // pe_data above, the buffer gets reallocated at another address
    const auto nt_headers2 = peutils::GetNtHeaders( pe_data.data() );

    // Update the section header in the pe header
    const auto current_section_header = IMAGE_FIRST_SECTION( nt_headers2 ) + i;

    const auto end_ptr_dest_that_will_be_overwritten =
        reinterpret_cast<uintptr_t>( current_section_header ) -
        reinterpret_cast<uintptr_t>( pe_data.data() ) +
        sizeof( IMAGE_SECTION_HEADER );

    // If the section headers are being written outside of the header size
    // That means it would overwrite data into the next section, usually .text section
    if ( end_ptr_dest_that_will_be_overwritten >
         nt_headers2->OptionalHeader.SizeOfHeaders ) {
      throw std::runtime_error( "The section header " + section.GetName() +
                                " does not fit inside of the header." );
    }

    memcpy( current_section_header, &section.section_header_,
            sizeof( section.section_header_ ) );

    // If there is data in section, add it to the PE
    if ( section.data_.size() > 0 ) {
      // Ensure that the section data is aligned with the pointer to raw data in the section header
      assert( pe_data.size() == section.section_header_.PointerToRawData );

      pe_data.insert( pe_data.end(), section.data_.begin(),
                      section.data_.end() );

      // Insert padding data at the end to fill the entire section due to
      // alignment
      pe_data.insert(
          pe_data.end(),
          section.section_header_.SizeOfRawData - section.data_.size(), 0xCC );
    }
  }

  const auto new_pe = PortableExecutable( pe_data );

  auto& last_section = sections_copy[ sections_copy.size() - 1 ];

  // Adjusts the nt header for the sections
  new_pe.nt_headers_->FileHeader.NumberOfSections =
      static_cast<WORD>( sections_copy.size() );

  new_pe.nt_headers_->OptionalHeader.SizeOfImage =
      last_section.section_header_.VirtualAddress +
      last_section.section_header_.Misc.VirtualSize;

  return new_pe;
}

PortableExecutable::PortableExecutable( const std::vector<uint8_t>& pe_data )
    : nt_headers_( nullptr ), dos_headers_( nullptr ) {
  pe_data_ = pe_data;

  const auto pe_data_ptr = &pe_data_[ 0 ];

  dos_headers_ = reinterpret_cast<IMAGE_DOS_HEADER*>( pe_data_ptr );

  nt_headers_ = peutils::GetNtHeaders( pe_data_ptr );
}

PortableExecutable::PortableExecutable( const PortableExecutable& rhs )
    : dos_headers_( nullptr ), nt_headers_( nullptr ) {
  *this = rhs;
  /*
  pe_data_ = rhs.pe_data_;

  const auto pe_data_ptr = &pe_data_[ 0 ];

  dos_headers_ = reinterpret_cast<IMAGE_DOS_HEADER*>( pe_data_ptr );

  nt_headers_ = peutils::GetNtHeaders( pe_data_ptr );
  */
}

PortableExecutable& PortableExecutable::operator=(
    const PortableExecutable& rhs ) {
  pe_data_ = rhs.pe_data_;

  const auto pe_data_ptr = &pe_data_[ 0 ];

  dos_headers_ = reinterpret_cast<IMAGE_DOS_HEADER*>( pe_data_ptr );

  nt_headers_ = peutils::GetNtHeaders( pe_data_ptr );

  return *this;
}

bool PortableExecutable::IsValid() const {
  if ( !dos_headers_ || !nt_headers_ )
    return false;

  if ( dos_headers_->e_magic != IMAGE_DOS_SIGNATURE )
    return false;

  if ( nt_headers_->Signature != IMAGE_NT_SIGNATURE )
    return false;

  return true;
}

std::vector<Section> PortableExecutable::CopySectionsDeep() const {
  const auto first_section = IMAGE_FIRST_SECTION( nt_headers_ );
  const auto section_count = nt_headers_->FileHeader.NumberOfSections;

  std::vector<Section> sections;

  sections.reserve( section_count );

  for ( int i = 0; i < section_count; ++i ) {
    const auto section_header = &first_section[ i ];
    sections.push_back( CopySectionDeep( section_header ) );
  }

  return sections;
}

Section PortableExecutable::CopySectionDeep(
    const IMAGE_SECTION_HEADER* section_header ) const {
  return Section( *section_header, pe_data_ );
}

SectionHeaders PortableExecutable::GetSectionHeaders() const {
  const auto first_section = IMAGE_FIRST_SECTION( nt_headers_ );
  const auto section_count = nt_headers_->FileHeader.NumberOfSections;

  std::vector<IMAGE_SECTION_HEADER*> section_headers;

  section_headers.reserve( section_count );

  for ( int i = 0; i < section_count; ++i ) {
    section_headers.push_back( &first_section[ i ] );
  }

  return SectionHeaders( section_headers );
}

std::vector<Import> PortableExecutable::GetImports() const {
  std::vector<Import> imports;

  const auto pe_data_ptr = const_cast<uint8_t*>( &pe_data_[ 0 ] );

  const auto& import_directory =
      nt_headers_->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_IMPORT ];

  // is there an import directory?
  if ( !import_directory.VirtualAddress )
    return {};

  auto sections = GetSectionHeaders();

  // For each import desc
  for ( auto import_descriptor = reinterpret_cast<IMAGE_IMPORT_DESCRIPTOR*>(
            pe_data_ptr +
            sections.RvaToFileOffset( import_directory.VirtualAddress ) );
        import_descriptor->Name; ++import_descriptor ) {
    // Read the function associated dll name
    const auto associated_dll_name = reinterpret_cast<const char*>(
        pe_data_ptr + sections.RvaToFileOffset( import_descriptor->Name ) );

    // Since we are only looking for a function from a specific DLL, check if
    // the DLL name is the one we want that contains the function we want to
    // hook to avoid going though every import desc.
    auto original_thunk = reinterpret_cast<IMAGE_THUNK_DATA*>(
        pe_data_ptr +
        sections.RvaToFileOffset( import_descriptor->OriginalFirstThunk ) );

    uint32_t function_address = import_descriptor->FirstThunk;

    // For each import thunk
    for ( ; original_thunk->u1.AddressOfData;
          ++original_thunk,
          function_address += sizeof( import_descriptor->FirstThunk ) ) {
      assert( original_thunk );

      const bool by_ordinal =
          IMAGE_SNAP_BY_ORDINAL( original_thunk->u1.Ordinal );

      if ( by_ordinal ) {
        const auto ordinal = IMAGE_ORDINAL( original_thunk->u1.Ordinal );

        assert( ordinal );

        /*
          NOTE: (TODO)
          Because we currently do not use the imports in any important way.
          We only care about how many there are.
          Do not care out handling the ordinal properly now.
          Fo that shi bruhh
        */

        Import import;
        import.associated_module = "";
        import.function_addr_rva = 0;
        import.function_name = "";
        import.ordinal = true;

        imports.push_back( import );
      } else {
        // Read the import info in that thunk
        const auto import_name = reinterpret_cast<IMAGE_IMPORT_BY_NAME*>(
            pe_data_ptr +
            sections.RvaToFileOffset( original_thunk->u1.AddressOfData ) );

        Import import;
        {
          import.associated_module = associated_dll_name;
          import.function_addr_rva = function_address;
          import.function_name = import_name->Name;
          import.ordinal = false;
        }

        imports.push_back( import );
      }
    }
  }

  return imports;
}

std::vector<uintptr_t> PortableExecutable::GetTlsCallbacklist() const {
  std::vector<uintptr_t> tls_callback_list;

  const auto& tls_data_directory =
      nt_headers_->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_TLS ];

  const bool has_tls_directory = tls_data_directory.Size != 0;

  auto sections = GetSectionHeaders();

  if ( has_tls_directory ) {
    assert( sizeof( IMAGE_TLS_DIRECTORY ) == tls_data_directory.Size );

    const auto image_base = nt_headers_->OptionalHeader.ImageBase;

    const auto tls_dir_file_offset =
        sections.RvaToFileOffset( tls_data_directory.VirtualAddress );

    auto tls_directory = reinterpret_cast<const IMAGE_TLS_DIRECTORY*>(
        pe_data_.data() + tls_dir_file_offset );

    if ( tls_directory->AddressOfCallBacks ) {
      auto callback_list_start_offset = sections.RvaToFileOffset(
          tls_directory->AddressOfCallBacks - image_base );

      auto callback_list_ptr = reinterpret_cast<const uintptr_t*>(
          pe_data_.data() + callback_list_start_offset );

      for ( ; *callback_list_ptr; callback_list_ptr++ ) {
        tls_callback_list.push_back( *callback_list_ptr );
      }
    }
  }

  return tls_callback_list;
}

std::vector<Export> PortableExecutable::GetExports() const {
  std::vector<Export> exports;

  const auto& export_directory =
      nt_headers_->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ];

  // Is there an export directory?
  if ( !export_directory.VirtualAddress )
    return {};

  auto sections = GetSectionHeaders();

  const auto pe_data_ptr = const_cast<uint8_t*>( &pe_data_[ 0 ] );

  const auto exports_dir = reinterpret_cast<IMAGE_EXPORT_DIRECTORY*>(
      pe_data_ptr +
      sections.RvaToFileOffset( export_directory.VirtualAddress ) );

  const auto names = reinterpret_cast<uint32_t*>(
      pe_data_ptr + sections.RvaToFileOffset( exports_dir->AddressOfNames ) );
  const auto ordinals = reinterpret_cast<uint16_t*>(
      pe_data_ptr +
      sections.RvaToFileOffset( exports_dir->AddressOfNameOrdinals ) );
  const auto addresses = reinterpret_cast<uint32_t*>(
      pe_data_ptr +
      sections.RvaToFileOffset( exports_dir->AddressOfFunctions ) );

  for ( uint32_t i = 0; i < exports_dir->NumberOfNames; ++i ) {
    const auto function_name = reinterpret_cast<const char*>(
        pe_data_ptr + sections.RvaToFileOffset( names[ i ] ) );

    const uint32_t function_addr = addresses[ ordinals[ i ] ];

    Export e;
    e.function_name = function_name;
    e.function_addr_rva = function_addr;

    exports.push_back( e );
  }

  return exports;
}

void PortableExecutable::DisableASLR() {
  if ( ( nt_headers_->OptionalHeader.DllCharacteristics &
         IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE ) ==
       IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE )
    nt_headers_->OptionalHeader.DllCharacteristics &=
        ~IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE;
}

void PortableExecutable::Relocate( const uintptr_t new_image_base_address ) {
  auto sections = GetSectionHeaders();

  auto image_ptr = GetPeImagePtr();

  EachRelocation( [&]( IMAGE_BASE_RELOCATION* reloc_block, uintptr_t rva,
                       Relocation* reloc ) {
    if ( reloc->type == IMAGE_REL_BASED_HIGHLOW ||
         reloc->type == IMAGE_REL_BASED_DIR64 ) {
      const auto file_offset = sections.RvaToFileOffset( rva );
      *( uint32_t* )( image_ptr + file_offset ) += new_image_base_address;
    }
  } );
}

std::vector<uint8_t> PortableExecutable::CopyHeaderData() const {
  return std::vector<uint8_t>(
      pe_data_.begin(),
      pe_data_.begin() + nt_headers_->OptionalHeader.SizeOfHeaders );
}

uint8_t* PortableExecutable::GetPeImagePtr() {
  return &pe_data_[ 0 ];
}

const uint8_t* PortableExecutable::GetPeImagePtr() const {
  return &pe_data_[ 0 ];
}

const std::vector<uint8_t>& PortableExecutable::GetPeData() const {
  return pe_data_;
}

std::vector<uint8_t>& PortableExecutable::GetPeData() {
  return pe_data_;
}

IMAGE_NT_HEADERS* PortableExecutable::GetNtHeaders() const {
  return nt_headers_;
}
```

`GreyM/src/pe/portable_executable.h`:

```h
#pragma once

#include "section.h"
#include "section_headers.h"

class PortableExecutable;

namespace pe {

PortableExecutable Open( const std::vector<uint8_t>& pe_data );
PortableExecutable Build( const std::vector<uint8_t>& header,
                          const std::vector<Section>& sections );

}  // namespace pe

struct Export {
  std::string function_name;
  uint32_t function_addr_rva;
};

struct Import {
  std::string associated_module;
  std::string function_name;
  DWORD function_addr_rva;
  bool ordinal;
};

struct Relocation {
  WORD offset : 12;
  WORD type : 4;
};

using EachRelocationCallback_t = void ( * )( IMAGE_BASE_RELOCATION* reloc_block,
                                             uintptr_t rva,
                                             Relocation* reloc );

using EachRelocationConstCallback_t =
    void ( * )( const IMAGE_BASE_RELOCATION* reloc_block,
                const uintptr_t rva,
                const Relocation* reloc );

class PortableExecutable {
 private:
  PortableExecutable( const std::vector<uint8_t>& pe_data );

 public:
  // Delete the constructor, force user to only be able to use the pe:: namespace
  PortableExecutable() = delete;

  // Copy constructor
  PortableExecutable( const PortableExecutable& rhs );

  // Assignment constructior
  PortableExecutable& operator=( const PortableExecutable& rhs );

  // Check whether or not the PE is valid throug the headers
  bool IsValid() const;

  // Copies all of the sections deeply, that includes the data assocated with the section
  std::vector<Section> CopySectionsDeep() const;

  // Copies all of the sections deeply, that includes the data assocated with the section
  Section CopySectionDeep( const IMAGE_SECTION_HEADER* section_header ) const;

  SectionHeaders GetSectionHeaders() const;

  std::vector<Import> GetImports() const;

  std::vector<uintptr_t> GetTlsCallbacklist() const;

  // I previously used a std::function for the callback, but using a templated
  // function supports capturing variable in the lambda as well and has
  // extremely good performance compared to std::function
  // TFunc: void callback(IMAGE_BASE_RELOCATION *reloc_block, uintptr_t rva, Relocation* reloc)
  template <typename TFunc = EachRelocationCallback_t>
  void EachRelocation( const TFunc& callback );

  // TFuncConst: void callback(const IMAGE_BASE_RELOCATION *reloc_block,
  //                      const uintptr_t rva, const Relocation* reloc)
  template <typename TFuncConst = EachRelocationConstCallback_t>
  void EachRelocationConst( const TFuncConst& callback ) const;

  std::vector<Export> GetExports() const;

  void DisableASLR();
  void Relocate( const uintptr_t new_image_base_address );

  std::vector<uint8_t> CopyHeaderData() const;

  uint8_t* GetPeImagePtr();
  const uint8_t* GetPeImagePtr() const;

  const std::vector<uint8_t>& GetPeData() const;
  std::vector<uint8_t>& GetPeData();

  IMAGE_NT_HEADERS* GetNtHeaders() const;

 private:
  std::vector<uint8_t> pe_data_;

  IMAGE_NT_HEADERS* nt_headers_;
  IMAGE_DOS_HEADER* dos_headers_;

  friend PortableExecutable pe::Open( const std::vector<uint8_t>& pe_data );

  friend PortableExecutable pe::Build( const std::vector<uint8_t>& header,
                                       const std::vector<Section>& sections );
};

template <typename TFunc>
void PortableExecutable::EachRelocation( const TFunc& callback ) {
  const auto pe_data_ptr = &pe_data_[ 0 ];

  const auto sections = GetSectionHeaders();

  const auto& reloc_directory =
      nt_headers_->OptionalHeader
          .DataDirectory[ IMAGE_DIRECTORY_ENTRY_BASERELOC ];

  auto reloc_block = reinterpret_cast<IMAGE_BASE_RELOCATION*>(
      pe_data_ptr +
      sections.RvaToFileOffset( reloc_directory.VirtualAddress ) );

  uint32_t relocation_size_read = 0;

  // Iterate each relocation block
  while ( relocation_size_read < reloc_directory.Size ) {
    const DWORD reloc_list_count =
        ( reloc_block->SizeOfBlock - sizeof( IMAGE_BASE_RELOCATION ) ) /
        sizeof( WORD );

    WORD* reloc_list =
        reinterpret_cast<WORD*>( reinterpret_cast<size_t>( reloc_block ) +
                                 sizeof( IMAGE_BASE_RELOCATION ) );

    for ( size_t i = 0; i < reloc_list_count; ++i ) {
      Relocation* reloc = reinterpret_cast<Relocation*>( &reloc_list[ i ] );

      const auto rva = reloc->offset + reloc_block->VirtualAddress;

      callback( reloc_block, rva, reloc );
    }

    relocation_size_read += reloc_block->SizeOfBlock;

    reloc_block = reinterpret_cast<IMAGE_BASE_RELOCATION*>(
        reinterpret_cast<size_t>( reloc_block ) + reloc_block->SizeOfBlock );
  }
}

template <typename TFuncConst>
void PortableExecutable::EachRelocationConst(
    const TFuncConst& callback ) const {
  // This callback wrapped enforces the const part in the arguments of the callback
  const auto callback_wrapper =
      [=]( const IMAGE_BASE_RELOCATION* reloc_block, const uintptr_t rva,
           const Relocation* reloc ) { callback( reloc_block, rva, reloc ); };

  // DISGUSTING, but recommended by Meyer according to stackoverflow lol
  const auto one = static_cast<const PortableExecutable&>( *this );
  auto two = const_cast<PortableExecutable&>( one );

  two.EachRelocation( callback_wrapper );
}
```

`GreyM/src/pe/section.cpp`:

```cpp
#include "pch.h"
#include "section.h"
#include "portable_executable.h"
#include "peutils.h"

Section::Section( const IMAGE_SECTION_HEADER& section_header,
                  const std::vector<uint8_t> pe_data )
    : section_header_( section_header ) {
  // We use SizeOfRawData because it has to be aligned in the executable (file)
  data_ =
      std::vector<uint8_t>( pe_data.cbegin() + section_header.PointerToRawData,
                            pe_data.cbegin() + section_header.PointerToRawData +
                                section_header_.SizeOfRawData );
}

uintptr_t Section::AppendCode( const std::vector<uint8_t>& code,
                               const uint32_t section_alignment,
                               const uint32_t file_alignment ) {
  return AppendCode( &code[ 0 ], code.size(), file_alignment );
}

uintptr_t Section::AppendCode( const uint8_t* buffer,
                               const uintptr_t size,
                               const uint32_t file_alignment ) {
  const auto current_offset = data_.size();

  data_.insert( data_.end(), buffer, buffer + size );

  section_header_.SizeOfRawData =
      peutils::AlignUp( data_.size(), file_alignment );

  // Is this alignment required? Probably not.
  //section_header_.Misc.VirtualSize =
  //    peutils::AlignUp( data_.size(), section_alignment );
  section_header_.Misc.VirtualSize = data_.size();

  return current_offset;
}

std::string Section::GetName() const {
  return std::string( reinterpret_cast<const char*>( section_header_.Name ) );
}

void Section::SetName( const std::string& name ) {
  assert( name.size() <= 8 );

  memcpy( section_header_.Name, name.c_str(), sizeof( section_header_.Name ) );
}

const IMAGE_SECTION_HEADER& Section::GetSectionHeader() const {
  return section_header_;
}

std::vector<uint8_t>* Section::GetData() {
  return &data_;
}

const std::vector<uint8_t>* Section::GetData() const {
  return &data_;
}

uint32_t Section::GetCurrentOffset() const {
  return data_.size();
}

Section section::CreateEmptySection( const std::string& name,
                                     const DWORD characteristics ) {
  Section section;

  section.section_header_.Characteristics = characteristics;

  section.SetName( name );

  return section;
}

const bool section::IsRvaWithinSection(
    const IMAGE_SECTION_HEADER& section_header,
    const uintptr_t rva ) {
  if ( rva >= section_header.VirtualAddress &&
       rva < section_header.VirtualAddress + section_header.Misc.VirtualSize ) {
    return true;
  }

  return false;
}

uintptr_t section::RvaToSectionOffset(
    const IMAGE_SECTION_HEADER& section_header,
    const uint64_t rva ) {
  return static_cast<uint32_t>( rva - section_header.VirtualAddress );
}

uintptr_t section::SectionOffsetToRva(
    const IMAGE_SECTION_HEADER& section_header,
    const uint32_t offset ) {
  return section_header.VirtualAddress + offset;
}
```

`GreyM/src/pe/section.h`:

```h
#pragma once

class PortableExecutable;
class Section;

namespace section {

Section CreateEmptySection( const std::string& name,
                            const DWORD characteristics );

const bool IsRvaWithinSection( const IMAGE_SECTION_HEADER& section_header,
                               const uintptr_t rva );

uintptr_t RvaToSectionOffset( const IMAGE_SECTION_HEADER& section_header,
                              const uint64_t rva );

uintptr_t SectionOffsetToRva( const IMAGE_SECTION_HEADER& section_header,
                              const uint32_t offset );

}  // namespace section

namespace pe {

PortableExecutable Build( const std::vector<uint8_t>& header,
                          const std::vector<Section>& sections );

}  // namespace pe

class Section {
 public:
  Section() : section_header_{ 0 }, data_{} {}

  Section( const IMAGE_SECTION_HEADER& section_header,
           const std::vector<uint8_t> pe_data );

  // AppendCode returns the new code offset relative to the section beginning
  // in other words, if offset is 0, it is on the beginning of the section
  uintptr_t AppendCode( const std::vector<uint8_t>& code,
                        const uint32_t section_alignment,
                        const uint32_t file_alignment );

  uintptr_t AppendCode( const uint8_t* buffer,
                        const uintptr_t size,
                        const uint32_t file_alignment );

  template <typename T>
  uintptr_t AppendValue( const T& variable, const uint32_t file_alignment );

  std::string GetName() const;
  void SetName( const std::string& name );

  const IMAGE_SECTION_HEADER& GetSectionHeader() const;

  std::vector<uint8_t>* GetData();
  const std::vector<uint8_t>* GetData() const;

  uint32_t GetCurrentOffset() const;

 private:
  IMAGE_SECTION_HEADER section_header_;
  std::vector<uint8_t> data_;

  friend Section section::CreateEmptySection( const std::string& name,
                                              const DWORD characteristics );

  friend PortableExecutable pe::Build( const std::vector<uint8_t>& header,
                                       const std::vector<Section>& sections );
};

template <typename T>
uintptr_t Section::AppendValue( const T& variable,
                               const uint32_t file_alignment ) {
  const auto buf = reinterpret_cast<const uint8_t*>( &variable );

  return AppendCode( buf, sizeof( T ), file_alignment );
}
```

`GreyM/src/pe/section_headers.cpp`:

```cpp
#include "pch.h"
#include "section_headers.h"
#include "section.h"

IMAGE_SECTION_HEADER* SectionHeaders::FromName(
    const std::string& name ) const {
  for ( auto& section_header : headers_ ) {
    if ( strcmp( reinterpret_cast<const char*>( section_header->Name ),
                 name.c_str() ) == 0 )
      return section_header;
  }

  return nullptr;
}

uintptr_t SectionHeaders::RvaToFileOffset( const uintptr_t rva ) const {
  const auto section_header = FromRva( rva );

  if ( !section_header )
    return 0;

  // if the section is empty
  if ( strcmp( reinterpret_cast<const char*>( section_header->Name ), "" ) ==
       0 )
    return 0;

  return section_header->PointerToRawData +
         ( rva - section_header->VirtualAddress );
}

IMAGE_SECTION_HEADER* SectionHeaders::FromRva( const uintptr_t rva ) const {
  for ( auto& section_header : headers_ ) {
    if ( section::IsRvaWithinSection( *section_header, rva ) ) {
      return section_header;
    }
  }

  return nullptr;
}

```

`GreyM/src/pe/section_headers.h`:

```h
#pragma once

class SectionHeaders {
 public:
  SectionHeaders( std::vector<IMAGE_SECTION_HEADER*>& headers )
      : headers_( headers ) {}

  IMAGE_SECTION_HEADER* FromName( const std::string& name ) const;

  uintptr_t RvaToFileOffset( const uintptr_t rva ) const;

  IMAGE_SECTION_HEADER* FromRva( const uintptr_t rva ) const;

 private:
  std::vector<IMAGE_SECTION_HEADER*> headers_;
};
```

`GreyM/src/protector.cpp`:

```cpp
#include "pch.h"
#include "protector.h"
#include "disassembler/pe_disassembly_engine.h"
#include "pe/portable_executable.h"
#include "utils/stopwatch.h"
#include "virtualizer/virtualizer.h"
#include "utils/shellcode.h"
#include "utils/file_io.h"
#include "rtti_obfuscator.h"
#include "utils/random.h"
#include "pe/peutils.h"
#include "utils/console_log.h"
#include "utils/file_log.h"

#include "../../Interpreter/src/main.h"

#include "../pe/peutils.h"

namespace protector {

enum class FixupOperation {
  AddVmLoaderSectionVirtualAddress,
  SubtractVmLoaderSectionVirtualAddress,
  AddVirtualizedCodeSectionVirtualAddress,
};

enum class OffsetRelativeTo {
  VmLoaderSection,
  TextSection,
  RelocSection,
  VirtualizedCodeSection,
  Beginning,

  Unknown
};

struct FixupDescriptor {
  OffsetRelativeTo offset_type;
  // The size of the value to update, 4 or 8 bytes?
  uint8_t size;
  FixupOperation operation;
};

struct Fixup {
  uintptr_t offset;
  FixupDescriptor desc;
};

struct FixupContext {
  std::vector<uintptr_t> relocation_rvas_to_remove;

  // A list containing offset relative to vm section
  // that will be added to the relocation table in the PE
  std::vector<uintptr_t> vm_section_offsets_to_add_to_relocation_table;
  std::vector<uintptr_t>
      virtualized_code_section_offsets_to_add_to_relocation_table;

  std::vector<Fixup> fixups;
};

enum class WhatToVirtualize { TextSection, VmLoaderSection };

struct VirtualizerContext {
  std::vector<uintptr_t> original_pe_relocation_rvas;
  IMAGE_NT_HEADERS* original_pe_nt_headers;
  uint32_t interpreter_function_offset;
  IMAGE_SECTION_HEADER original_text_section_header;
  uint32_t total_virtualized_instructions = 0;
  uint32_t total_disassembled_instructions = 0;
  WhatToVirtualize what_to_virtualize;
  IMAGE_SECTION_HEADER vm_loader_section_header;
  uintptr_t default_image_base;

  Section original_text_section_copy;
};

struct ProtectorContext {
  // The sections that will either be created or modified
  Section vm_loader_section;
  Section virtualized_code_section;
  Section new_text_section;

  FixupContext fixup_context;
  VirtualizerContext virtualizer_context;
};

std::vector<uintptr_t> GetRelocationsWithinInstruction(
    const cs_insn& instruction,
    const std::vector<uintptr_t>& relocations_to_search ) {
  std::vector<uintptr_t> reloc_rvas_result;

  auto it_found_result = relocations_to_search.cend();

  for ( int i = 0; i < instruction.size; ++i ) {
    const auto instruction_rva = instruction.address + i;
    auto it = std::lower_bound( relocations_to_search.cbegin(),
                                relocations_to_search.cend(), instruction_rva );

    // If we found that exact value
    if ( it != relocations_to_search.cend() && *it == instruction_rva ) {
      reloc_rvas_result.push_back( *it );
      it_found_result = it;

      // Break out and continue with the second loop to avoid binary searching the whole vector again
      break;
    }
  }

  if ( it_found_result != relocations_to_search.cend() ) {
    // If we found it, we don't need to binary search the whole vector again
    // continue iterating the found iterator above
    for ( auto it = it_found_result + 1; it != relocations_to_search.cend();
          ++it ) {
      const auto reloc_rva = *it;

      const bool is_reloc_within_instruction =
          ( reloc_rva >= instruction.address ) &&
          ( reloc_rva < ( instruction.address + instruction.size ) );

      // if the reloc rva was not within the current instructino, then we are
      // done because the relocations following this one are definitely not
      // within this instruction
      if ( !is_reloc_within_instruction )
        break;

      reloc_rvas_result.push_back( reloc_rva );
    }
  }

  return reloc_rvas_result;
}

PortableExecutable ReadInterpreterPe() {
  const std::wstring interpreter_filename = TEXT( "Interpreter.dll" );

  const auto interpreter_file_data =
      fileio::ReadBinaryFile( interpreter_filename );

  if ( interpreter_file_data.empty() )
    throw std::runtime_error( "Unable to read the content of Interpreter.dll" );

  return pe::Open( interpreter_file_data );
}

void AddInterpreterCodeToSection( const PortableExecutable& interpreter_pe,
                                  Section* section ) {
  auto section_headers = interpreter_pe.GetSectionHeaders();

  const auto interpreter_vm_section =
      section_headers.FromName( VM_FUNCTIONS_SECTION_NAME );

  auto temp_section_copy =
      interpreter_pe.CopySectionDeep( interpreter_vm_section );

  const auto nt_header = interpreter_pe.GetNtHeaders();

  section->AppendCode( *temp_section_copy.GetData(),
                       nt_header->OptionalHeader.SectionAlignment,
                       nt_header->OptionalHeader.FileAlignment );
}

uint32_t GetExportedFunctionOffsetRelativeToSection(
    const PortableExecutable& pe,
    const std::string& function_name ) {
  const auto exports = pe.GetExports();

  const auto export_found = std::find_if(
      exports.cbegin(), exports.cend(), [&]( const Export exprt ) {
        return exprt.function_name == function_name;
      } );

  if ( export_found == exports.end() ) {
    throw std::runtime_error( "Unable to find the" + function_name );
  }

  const auto section_headers = pe.GetSectionHeaders();

  const auto section_containing_interpreter =
      section_headers.FromRva( export_found->function_addr_rva );

  const auto interpreter_offset_relative_to_section =
      section::RvaToSectionOffset( *section_containing_interpreter,
                                   export_found->function_addr_rva );

  return interpreter_offset_relative_to_section;
}

void AddTlsCallbacks( const VmCodeSectionData& vm_code_section_data,
                      const PortableExecutable& interpreter_pe,
                      PortableExecutable* original_pe,
                      ProtectorContext* context ) {
  // Previously I completely re-created the TLS directory in every case.
  // Now I am only creating it if it did not exist previously.
  // The reason being that calling LdrpHandleTlsData from a DLL
  // caused it to fail with a error code of success.

  const auto original_pe_data = original_pe->GetPeImagePtr();
  const auto original_pe_headers = original_pe->GetNtHeaders();
  const auto original_sections = original_pe->GetSectionHeaders();

  auto original_tls_data_dir = &original_pe_headers->OptionalHeader
                                    .DataDirectory[ IMAGE_DIRECTORY_ENTRY_TLS ];

  const auto default_image_base =
      context->virtualizer_context.default_image_base;

  std::vector<uintptr_t> tls_callback_list;

  const bool has_tls_directory = original_tls_data_dir->Size != 0;

  if ( has_tls_directory ) {
    // If the target PE has a tls directory, use that one
    assert( sizeof( IMAGE_TLS_DIRECTORY ) == original_tls_data_dir->Size );

    const auto tls_dir_file_offset = original_sections.RvaToFileOffset(
        original_tls_data_dir->VirtualAddress );

    auto original_tls_dir = reinterpret_cast<IMAGE_TLS_DIRECTORY*>(
        original_pe_data + tls_dir_file_offset );

    tls_callback_list = original_pe->GetTlsCallbacklist();

    const auto interpreter_tls_callback_offset =
        GetExportedFunctionOffsetRelativeToSection( interpreter_pe,
                                                    "FirstTlsCallback" );

    // Store the index of my TLS callback to be used later when adding a fixup for it
    const auto my_tls_callback_index = tls_callback_list.size();

    /*
      NOTE: 
        If I change the order of MY TLS callbacks, I need to update 
        FixNextCorruptedTlsCallback() because they depend on the fact 
        that they are the 2 last TLS callbacks
    */

    // Add the address of my own TLS callback
    tls_callback_list.push_back( default_image_base +
                                 interpreter_tls_callback_offset );

    const auto interpreter_second_tls_callback_offset =
        GetExportedFunctionOffsetRelativeToSection( interpreter_pe,
                                                    "SecondTlsCallback" );

    // Store the index of my TLS callback to be used later when adding a fixup for it
    const auto my_second_tls_callback_index = tls_callback_list.size();

    // Add the address of my own 2nd TLS callback
    tls_callback_list.push_back(
        default_image_base + interpreter_second_tls_callback_offset +
        vm_code_section_data.second_tls_callback_modifier );

    // Some padding in case I want to add more TLS callbacks later on
    tls_callback_list.push_back( 0 );
    tls_callback_list.push_back( 0 );
    tls_callback_list.push_back( 0 );
    tls_callback_list.push_back( 0 );
    tls_callback_list.push_back( 0 );

    uint8_t* tls_callback_list_ptr =
        reinterpret_cast<uint8_t*>( tls_callback_list.data() );

    // Convert the callback to a byte vector
    std::vector<uint8_t> tls_callbacks_list_data;
    tls_callbacks_list_data.assign(
        &tls_callback_list_ptr[ 0 ],
        &tls_callback_list_ptr[ tls_callback_list.size() *
                                sizeof( uintptr_t ) ] );

    // Add the TLS callback list
    const auto tls_callback_list_offset =
        context->virtualized_code_section.AppendCode(
            tls_callbacks_list_data,
            original_pe_headers->OptionalHeader.SectionAlignment,
            original_pe_headers->OptionalHeader.FileAlignment );

    // Add each of the callbacks to the relocation table
    for ( int i = 0; i < tls_callback_list.size(); ++i ) {
      if ( tls_callback_list[ i ] != 0 ) {
        context->fixup_context
            .virtualized_code_section_offsets_to_add_to_relocation_table
            .push_back( tls_callback_list_offset + i * sizeof( uintptr_t ) );
      }
    }

    // Add the my first tls callback to the fixup
    {
      const auto my_tls_callback_offset =
          tls_callback_list_offset +
          ( my_tls_callback_index * sizeof( uintptr_t ) );

      // Add my TLS callback to fixup
      Fixup callback_addr_fixup;
      callback_addr_fixup.offset = my_tls_callback_offset;
      callback_addr_fixup.desc.offset_type =
          OffsetRelativeTo::VirtualizedCodeSection;
      callback_addr_fixup.desc.operation =
          FixupOperation::AddVmLoaderSectionVirtualAddress;
      callback_addr_fixup.desc.size = sizeof( uintptr_t );
      context->fixup_context.fixups.push_back( callback_addr_fixup );
    }

    // Add the my second tls callback to the fixup
    {
      const auto my_tls_callback_offset =
          tls_callback_list_offset +
          ( my_second_tls_callback_index * sizeof( uintptr_t ) );

      // Add my TLS callback to fixup
      Fixup callback_addr_fixup;
      callback_addr_fixup.offset = my_tls_callback_offset;
      callback_addr_fixup.desc.offset_type =
          OffsetRelativeTo::VirtualizedCodeSection;
      callback_addr_fixup.desc.operation =
          FixupOperation::AddVmLoaderSectionVirtualAddress;
      callback_addr_fixup.desc.size = sizeof( uintptr_t );
      context->fixup_context.fixups.push_back( callback_addr_fixup );
    }

    original_tls_dir->AddressOfCallBacks =
        default_image_base + tls_callback_list_offset;

    const auto addr_of_callbacks_offset =
        tls_dir_file_offset +
        offsetof( IMAGE_TLS_DIRECTORY, AddressOfCallBacks );

    FixupDescriptor fixup_desc;
    fixup_desc.offset_type = OffsetRelativeTo::Beginning;
    fixup_desc.operation =
        FixupOperation::AddVirtualizedCodeSectionVirtualAddress;
    fixup_desc.size = sizeof( uintptr_t );

    Fixup addr_of_callbacks_fixup;
    addr_of_callbacks_fixup.offset = addr_of_callbacks_offset;
    addr_of_callbacks_fixup.desc = fixup_desc;
    context->fixup_context.fixups.push_back( addr_of_callbacks_fixup );
  } else {
    // If the target PE does not have a TLS directory, create a new one

    // The data that the AddressOfIndex will point to, this will be a bunch zeroed data
    std::vector<uint8_t> index_data;

    // Fill address of index with some zeroed data
    index_data.insert( index_data.end(), sizeof( uintptr_t ), 0 );

    // Add the TLS index address data
    const auto index_data_offset = context->virtualized_code_section.AppendCode(
        index_data, original_pe_headers->OptionalHeader.SectionAlignment,
        original_pe_headers->OptionalHeader.FileAlignment );

    //////////////////////////////////////////////////////////////////////////

    const auto interpreter_tls_callback_offset =
        GetExportedFunctionOffsetRelativeToSection( interpreter_pe,
                                                    "FirstTlsCallback" );

    // Store the index of my TLS callback to be used later when adding a fixup for it
    const auto my_tls_callback_index = tls_callback_list.size();

    assert( my_tls_callback_index == 0 );

    // Add the address of my own TLS callback
    tls_callback_list.push_back( default_image_base +
                                 interpreter_tls_callback_offset );

    const auto interpreter_second_tls_callback_offset =
        GetExportedFunctionOffsetRelativeToSection( interpreter_pe,
                                                    "SecondTlsCallback" );

    // Store the index of my TLS callback to be used later when adding a fixup for it
    const auto my_second_tls_callback_index = tls_callback_list.size();

    assert( my_second_tls_callback_index == 1 );

    // Add the address of my own 2nd TLS callback
    tls_callback_list.push_back(
        default_image_base + interpreter_second_tls_callback_offset +
        vm_code_section_data.second_tls_callback_modifier );

    // Some padding in case I want to add more TLS callbacks later on
    tls_callback_list.push_back( 0 );
    tls_callback_list.push_back( 0 );
    tls_callback_list.push_back( 0 );
    tls_callback_list.push_back( 0 );
    tls_callback_list.push_back( 0 );

    uint8_t* tls_callback_list_ptr =
        reinterpret_cast<uint8_t*>( tls_callback_list.data() );

    // Convert the callback to a byte vector
    std::vector<uint8_t> tls_callbacks_list_data;
    tls_callbacks_list_data.assign(
        &tls_callback_list_ptr[ 0 ],
        &tls_callback_list_ptr[ tls_callback_list.size() *
                                sizeof( uintptr_t ) ] );

    // Add the TLS callback list
    const auto tls_callback_list_offset =
        context->virtualized_code_section.AppendCode(
            tls_callbacks_list_data,
            original_pe_headers->OptionalHeader.SectionAlignment,
            original_pe_headers->OptionalHeader.FileAlignment );

    // Add each of the callbacks to the relocation table
    for ( int i = 0; i < tls_callback_list.size(); ++i ) {
      if ( tls_callback_list[ i ] != 0 ) {
        context->fixup_context
            .virtualized_code_section_offsets_to_add_to_relocation_table
            .push_back( tls_callback_list_offset + i * sizeof( uintptr_t ) );
      }
    }

    // Add my first TLS callback to the fixup
    {
      const auto my_tls_callback_offset =
          tls_callback_list_offset +
          ( my_tls_callback_index * sizeof( uintptr_t ) );

      // Add my TLS callback to fixup
      Fixup callback_addr_fixup;
      callback_addr_fixup.offset = my_tls_callback_offset;
      callback_addr_fixup.desc.offset_type =
          OffsetRelativeTo::VirtualizedCodeSection;
      callback_addr_fixup.desc.operation =
          FixupOperation::AddVmLoaderSectionVirtualAddress;
      callback_addr_fixup.desc.size = sizeof( uintptr_t );
      context->fixup_context.fixups.push_back( callback_addr_fixup );
    }

    // Add my second TLS callback to the fixup
    {
      const auto my_tls_callback_offset =
          tls_callback_list_offset +
          ( my_second_tls_callback_index * sizeof( uintptr_t ) );

      // Add my TLS callback to fixup
      Fixup callback_addr_fixup;
      callback_addr_fixup.offset = my_tls_callback_offset;
      callback_addr_fixup.desc.offset_type =
          OffsetRelativeTo::VirtualizedCodeSection;
      callback_addr_fixup.desc.operation =
          FixupOperation::AddVmLoaderSectionVirtualAddress;
      callback_addr_fixup.desc.size = sizeof( uintptr_t );
      context->fixup_context.fixups.push_back( callback_addr_fixup );
    }

    IMAGE_TLS_DIRECTORY tls_directory = { 0 };

    tls_directory.AddressOfIndex = default_image_base + index_data_offset;

    tls_directory.AddressOfCallBacks =
        default_image_base + tls_callback_list_offset;

    tls_directory.Characteristics = IMAGE_SCN_ALIGN_1BYTES;

    uint8_t* tls_directory_ptr = reinterpret_cast<uint8_t*>( &tls_directory );

    std::vector<uint8_t> tls_directory_data;
    tls_directory_data.assign( &tls_directory_ptr[ 0 ],
                               &tls_directory_ptr[ sizeof( tls_directory ) ] );

    FixupDescriptor virtualized_code_desc;
    virtualized_code_desc.offset_type =
        OffsetRelativeTo::VirtualizedCodeSection;
    virtualized_code_desc.operation =
        FixupOperation::AddVirtualizedCodeSectionVirtualAddress;
    virtualized_code_desc.size = sizeof( uintptr_t );

    // Add the TLS data to last section before calculating the vm section
    // virtual address
    const auto tls_directory_data_offset =
        context->virtualized_code_section.AppendCode(
            tls_directory_data,
            original_pe_headers->OptionalHeader.SectionAlignment,
            original_pe_headers->OptionalHeader.FileAlignment );

    const auto addr_of_index_offset =
        tls_directory_data_offset +
        offsetof( IMAGE_TLS_DIRECTORY, AddressOfIndex );

    Fixup addr_of_index_fixup;
    addr_of_index_fixup.offset = addr_of_index_offset;
    addr_of_index_fixup.desc = virtualized_code_desc;

    context->fixup_context.fixups.push_back( addr_of_index_fixup );
    context->fixup_context
        .virtualized_code_section_offsets_to_add_to_relocation_table.push_back(
            addr_of_index_offset );

    const auto addr_of_callbacks_offset =
        tls_directory_data_offset +
        offsetof( IMAGE_TLS_DIRECTORY, AddressOfCallBacks );

    Fixup addr_of_callbacks_fixup;
    addr_of_callbacks_fixup.offset = addr_of_callbacks_offset;
    addr_of_callbacks_fixup.desc = virtualized_code_desc;
    context->fixup_context.fixups.push_back( addr_of_callbacks_fixup );
    context->fixup_context
        .virtualized_code_section_offsets_to_add_to_relocation_table.push_back(
            addr_of_callbacks_offset );

    original_tls_data_dir->Size = sizeof( IMAGE_TLS_DIRECTORY );
    original_tls_data_dir->VirtualAddress = tls_directory_data_offset;

    // Add the tls data directory VirtualAddress to the fixup
    FixupDescriptor tls_dir_va_fixup_desc;
    tls_dir_va_fixup_desc.offset_type = OffsetRelativeTo::Beginning;
    tls_dir_va_fixup_desc.operation =
        FixupOperation::AddVirtualizedCodeSectionVirtualAddress;
    tls_dir_va_fixup_desc.size = sizeof( uintptr_t );

    Fixup tls_data_directory_virtual_address_fixup;
    tls_data_directory_virtual_address_fixup.desc = tls_dir_va_fixup_desc;
    tls_data_directory_virtual_address_fixup.offset =
        reinterpret_cast<uintptr_t>( original_tls_data_dir ) -
        reinterpret_cast<uintptr_t>( original_pe_data ) +
        offsetof( IMAGE_DATA_DIRECTORY, VirtualAddress );

    context->fixup_context.fixups.push_back(
        tls_data_directory_virtual_address_fixup );
  }
}

void RelocateInterpreterPe( PortableExecutable* interpreter_pe,
                            const uintptr_t new_image_base ) {
  const auto interpreter_sections = interpreter_pe->GetSectionHeaders();

  const auto vm_fun_section =
      interpreter_sections.FromName( VM_FUNCTIONS_SECTION_NAME );

  // Why is this 0?
  // Because we do not have the section RVA at the moment, instead we relocate it
  // once again when the whole PE is finished because we then have the section rva
  const auto vm_section_virtual_address = 0;

  // In this case, we remove the section rva completely.
  // 0 - value = -value
  const auto section_delta =
      vm_section_virtual_address - vm_fun_section->VirtualAddress;

  // The interpreter PE is a DLL, dll's have different default image bases compared to EXE's.
  const auto base_address_delta =
      new_image_base - interpreter_pe->GetNtHeaders()->OptionalHeader.ImageBase;

  // We relocate the whole interpreter in order to partly fix the jump/switch tables
  // There is still more to relocate, because we do not yet know the section rva.
  interpreter_pe->Relocate( base_address_delta + section_delta );
}

std::vector<uint8_t> CreateRelocationBlockBuffer(
    const uint32_t virtual_address,
    const std::vector<Relocation>& relocations ) {
  std::vector<uint8_t> relocation_block_bytes;

  // Required to be size of a WORD due to the PE format
  assert( sizeof( Relocation ) == sizeof( WORD ) );

  IMAGE_BASE_RELOCATION reloc_block;
  {
    reloc_block.VirtualAddress = virtual_address;
    reloc_block.SizeOfBlock = sizeof( IMAGE_BASE_RELOCATION ) +
                              relocations.size() * sizeof( Relocation );
  }

  const uint8_t* reloc_block_buf = reinterpret_cast<uint8_t*>( &reloc_block );

  relocation_block_bytes.insert( relocation_block_bytes.begin(),
                                 reloc_block_buf,
                                 reloc_block_buf + sizeof( reloc_block ) );

  for ( const auto& reloc : relocations ) {
    const uint8_t* reloc_buf = reinterpret_cast<const uint8_t*>( &reloc );

    relocation_block_bytes.insert( relocation_block_bytes.end(), reloc_buf,
                                   reloc_buf + sizeof( reloc ) );
  }

  return relocation_block_bytes;
}

uint32_t DetermineFirstRelocationBlockVirtualAddress(
    const std::vector<uintptr_t>& vm_section_offsets_to_add_to_relocation_table,
    const int highest_reloc_offset ) {
  assert( vm_section_offsets_to_add_to_relocation_table.size() > 0 );
  return peutils::AlignDown( vm_section_offsets_to_add_to_relocation_table[ 0 ],
                             highest_reloc_offset );
}

void TrimRelocSectionPadding( const IMAGE_NT_HEADERS* nt_headers,
                              Section* reloc_section ) {
  auto reloc_section_data = reloc_section->GetData();

  const auto& reloc_directory =
      nt_headers->OptionalHeader
          .DataDirectory[ IMAGE_DIRECTORY_ENTRY_BASERELOC ];

  // TODO: Consider making this a section method

  // Trim the end of reloc section and remove the padding
  reloc_section_data->erase( reloc_section_data->begin() + reloc_directory.Size,
                             reloc_section_data->end() );
}

uintptr_t AppendRelocationBlock( const uintptr_t reloc_block_virtual_address,
                                 std::vector<Relocation>& relocations,
                                 IMAGE_NT_HEADERS* nt_headers,
                                 Section* reloc_section ) {
  // if the count of relocations are odd, we need to add one no-op with type
  // and type 0, offset 0 to align to 32 bit boundary
  if ( relocations.size() % 2 != 0 ) {
    relocations.push_back( Relocation{ 0 } );
  }

  std::vector<uint8_t> reloc_block_bytes =
      CreateRelocationBlockBuffer( reloc_block_virtual_address, relocations );

  const auto dest_offset = reloc_section->AppendCode(
      reloc_block_bytes, nt_headers->OptionalHeader.SectionAlignment,
      nt_headers->OptionalHeader.FileAlignment );

  auto reloc_directory = &nt_headers->OptionalHeader
                              .DataDirectory[ IMAGE_DIRECTORY_ENTRY_BASERELOC ];

  reloc_directory->Size += reloc_block_bytes.size();

  return dest_offset;
}

// Adds relocations upon the relocation table that relocates
// the image base in the loader shellcode, also add the offsets
// of the relocation blocks to fixup the virtual address
void AddRelocations(
    const FixupDescriptor& fixup_desc,
    std::vector<uintptr_t> section_offsets_to_add_to_relocation_table,
    IMAGE_NT_HEADERS* nt_headers,
    Section* reloc_section,
    std::vector<Fixup>* fixups ) {
  // We need to sort them before adding them to the relocations, small to big
  std::sort( section_offsets_to_add_to_relocation_table.begin(),
             section_offsets_to_add_to_relocation_table.end() );

  if ( section_offsets_to_add_to_relocation_table.empty() ) {
    return;
  }

  // Required to be the .reloc section
  assert( reloc_section->GetName() == ".reloc" );

  // 0x1000 or 4096
  constexpr auto k4kPage = 1 << 12;

  auto reloc_block_virtual_address =
      DetermineFirstRelocationBlockVirtualAddress(
          section_offsets_to_add_to_relocation_table, k4kPage );

  TrimRelocSectionPadding( nt_headers, reloc_section );

  Fixup fixup;
  fixup.desc = fixup_desc;

  std::vector<Relocation> new_relocations;

  for ( const auto vm_section_offset_to_relocate :
        section_offsets_to_add_to_relocation_table ) {
    const auto delta_offset_from_reloc_block_va =
        vm_section_offset_to_relocate - reloc_block_virtual_address;

    Relocation relocation;
#ifdef _WIN64
    relocation.type = IMAGE_REL_BASED_DIR64;
#else
    relocation.type = IMAGE_REL_BASED_HIGHLOW;
#endif
    relocation.offset = delta_offset_from_reloc_block_va;

    // If the next relocation offset is bigger than the allowed value
    if ( delta_offset_from_reloc_block_va >= k4kPage ) {
      fixup.offset =
          AppendRelocationBlock( reloc_block_virtual_address, new_relocations,
                                 nt_headers, reloc_section );
      fixups->push_back( fixup );

      new_relocations.clear();

      // Align the reloc block to a 4k page value (4096)
      reloc_block_virtual_address =
          peutils::AlignDown( vm_section_offset_to_relocate, k4kPage );

      assert( ( vm_section_offset_to_relocate - reloc_block_virtual_address ) <
              k4kPage );

      // refresh the offset for the new block
      relocation.offset =
          vm_section_offset_to_relocate - reloc_block_virtual_address;
    }

    new_relocations.push_back( relocation );
  }

  // If there are still relocations left to add
  if ( new_relocations.size() > 0 ) {
    fixup.offset =
        AppendRelocationBlock( reloc_block_virtual_address, new_relocations,
                               nt_headers, reloc_section );
    fixups->push_back( fixup );
  }
}

void AddVirtualizedCodeSectionRelocations( IMAGE_NT_HEADERS* nt_headers,
                                           Section* reloc_section,
                                           FixupContext* fixup_context ) {
  FixupDescriptor fixup_desc;
  fixup_desc.offset_type = OffsetRelativeTo::RelocSection;
  fixup_desc.operation =
      FixupOperation::AddVirtualizedCodeSectionVirtualAddress;
  fixup_desc.size = sizeof( uintptr_t );

  AddRelocations(
      fixup_desc,
      fixup_context
          ->virtualized_code_section_offsets_to_add_to_relocation_table,
      nt_headers, reloc_section, &fixup_context->fixups );
}

void AddVmSectionRelocations( IMAGE_NT_HEADERS* nt_headers,
                              Section* reloc_section,
                              FixupContext* fixup_context ) {
  FixupDescriptor fixup_desc;
  fixup_desc.offset_type = OffsetRelativeTo::RelocSection;
  fixup_desc.operation = FixupOperation::AddVmLoaderSectionVirtualAddress;
  fixup_desc.size = sizeof( uint32_t );

  AddRelocations( fixup_desc,
                  fixup_context->vm_section_offsets_to_add_to_relocation_table,
                  nt_headers, reloc_section, &fixup_context->fixups );
}

void RemoveRelocations( const std::vector<uintptr_t>& relocation_rvas_to_remove,
                        PortableExecutable* pe ) {
  // The relocations to be removed are old relocations of the instruction that we have virtualized.
  // We handle the relocation ourselves, therefore we remove them to not fuck up the jmp to the virtualized code.
  for ( const auto reloc_rva : relocation_rvas_to_remove ) {
    pe->EachRelocation( [&]( IMAGE_BASE_RELOCATION* reloc_block,
                             const uintptr_t rva, Relocation* reloc ) {
      // NOTE: We cannot compare the offsets because, a relocation may have
      // same offsets but different rva's due to adding the reloc block
      // virtual address. Therefore we compare with the RVA's.
      if ( reloc_rva == rva ) {
        // Turn it into padding
        reloc->type = IMAGE_REL_BASED_ABSOLUTE;

        // Reset the offset as well to prevent this from being
        // used to determine some stuff for the badboy
        reloc->offset = 0;

        // std::cout << "Remove relocation for offset: " << std::hex
        //           << reloc->offset << " rva: " << rva << std::endl;
      }
    } );
  }
}

Section CreateVmSection( const PortableExecutable& interpreter_pe ) {
  // TODO: Remove IMAGE_SCN_MEM_EXECUTE to prevent IDA from seeing the section,
  // then dynamically add the executable flag back or VirtualProtect()
  // executable

  // Create the section that will contain the interpreter PE code and all the loader shellcode
  Section vm_section = section::CreateEmptySection(
      VM_LOADER_SECTION_NAME,
      IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_DISCARDABLE );

  // initialize the vm section with the required functions
  AddInterpreterCodeToSection( interpreter_pe, &vm_section );

  return vm_section;
}

// Returns all offsets relative to given section that has a relocation in the pe relocation table
std::vector<uint32_t> GetRelocationsWithinSectionAsSectionOffsets(
    const PortableExecutable& pe,
    const IMAGE_SECTION_HEADER& section ) {
  std::vector<uint32_t> offsets_result;

  pe.EachRelocationConst( [&]( const IMAGE_BASE_RELOCATION* reloc_block,
                               const uintptr_t rva, const Relocation* reloc ) {
    // We should not add relocations that are padding, we do that ourselves
    if ( reloc->type == IMAGE_REL_BASED_ABSOLUTE ) {
      return;
    }

    if ( section::IsRvaWithinSection( section, rva ) ) {
      const auto relocation_section_offset =
          section::RvaToSectionOffset( section, rva );

      offsets_result.push_back( relocation_section_offset );
    }
  } );

  return offsets_result;
}

// Returns a list containing all the relocation RVA values for the specified PE
// sorted for quick binary search lookup
std::vector<uintptr_t> GetRelocationRvas( const PortableExecutable& pe ) {
  std::vector<uintptr_t> relocation_rvas;

  // Copy the relocations from the original pe into a vector
  pe.EachRelocationConst( [&]( const IMAGE_BASE_RELOCATION* reloc_block,
                               const uintptr_t rva, const Relocation* reloc ) {
    // From MSDN PE documentation:
    // reloc.type = IMAGE_REL_BASED_ABSOLUTE: The base relocation is
    // skipped. This type can be used to pad a block. Therefore we skip
    // relocating if the relocation is of that type to avoid issues
    if ( reloc->type != IMAGE_REL_BASED_ABSOLUTE ) {
      relocation_rvas.push_back( rva );
    }
  } );

  return relocation_rvas;
}

void ApplyFixups( PortableExecutable* pe,
                  const IMAGE_SECTION_HEADER& text_section,
                  const std::vector<Fixup>& fixups ) {
  // A lazy fix to avoid the fact that some instructions that we virtualize
  // have an entry in the relocation table
  // If we disable the dynamic base address, there is no need to relocate
  // anything in the PE :D
  //pe->DisableASLR();

  auto new_pe_section_headers = pe->GetSectionHeaders();

  const auto new_pe_vm_loader_section =
      new_pe_section_headers.FromName( VM_LOADER_SECTION_NAME );

  const auto new_pe_virtualized_code_section =
      new_pe_section_headers.FromName( VM_CODE_SECTION_NAME );

  const auto reloc_section = new_pe_section_headers.FromName( ".reloc" );

  for ( const auto fixup : fixups ) {
    uintptr_t file_offset = 0;

    switch ( fixup.desc.offset_type ) {
      case OffsetRelativeTo::VmLoaderSection: {
        const uintptr_t rva = section::SectionOffsetToRva(
            *new_pe_vm_loader_section, fixup.offset );
        file_offset = new_pe_section_headers.RvaToFileOffset( rva );
      } break;

      case OffsetRelativeTo::TextSection: {
        const uintptr_t rva =
            section::SectionOffsetToRva( text_section, fixup.offset );
        file_offset = new_pe_section_headers.RvaToFileOffset( rva );
      } break;

      case OffsetRelativeTo::RelocSection: {
        const uintptr_t rva =
            section::SectionOffsetToRva( *reloc_section, fixup.offset );
        file_offset = new_pe_section_headers.RvaToFileOffset( rva );
      } break;

      case OffsetRelativeTo::VirtualizedCodeSection: {
        const uintptr_t rva = section::SectionOffsetToRva(
            *new_pe_virtualized_code_section, fixup.offset );
        file_offset = new_pe_section_headers.RvaToFileOffset( rva );
      } break;

      case OffsetRelativeTo::Beginning: {
        file_offset = fixup.offset;
      } break;

      default:
        assert( false && "bruh" );
        break;
    }

    const auto image_ptr_to_update = pe->GetPeImagePtr() + file_offset;

    switch ( fixup.desc.size ) {
      case sizeof( uint32_t ): {
        const auto value = *reinterpret_cast<uint32_t*>( image_ptr_to_update );

        switch ( fixup.desc.operation ) {
          case FixupOperation::AddVmLoaderSectionVirtualAddress:
            *reinterpret_cast<uint32_t*>( image_ptr_to_update ) =
                value + new_pe_vm_loader_section->VirtualAddress;
            break;

          case FixupOperation::AddVirtualizedCodeSectionVirtualAddress:
            *reinterpret_cast<uint32_t*>( image_ptr_to_update ) =
                value + new_pe_virtualized_code_section->VirtualAddress;
            break;

          case FixupOperation::SubtractVmLoaderSectionVirtualAddress:
            *reinterpret_cast<uint32_t*>( image_ptr_to_update ) =
                value - new_pe_vm_loader_section->VirtualAddress;
            break;

          default:
            throw std::runtime_error( "unsupported fixup operation" );
            break;
        }
      } break;

      case sizeof( uint64_t ): {
        const auto value = *reinterpret_cast<uint64_t*>( image_ptr_to_update );

        switch ( fixup.desc.operation ) {
          case FixupOperation::AddVmLoaderSectionVirtualAddress:
            *reinterpret_cast<uint64_t*>( image_ptr_to_update ) =
                value + new_pe_vm_loader_section->VirtualAddress;
            break;

          case FixupOperation::AddVirtualizedCodeSectionVirtualAddress:
            *reinterpret_cast<uint64_t*>( image_ptr_to_update ) =
                value + new_pe_virtualized_code_section->VirtualAddress;
            break;

          case FixupOperation::SubtractVmLoaderSectionVirtualAddress:
            *reinterpret_cast<uint64_t*>( image_ptr_to_update ) =
                value - new_pe_vm_loader_section->VirtualAddress;
            break;

          default:
            throw std::runtime_error( "unsupported fixup operation" );
            break;
        }
      } break;

      default:
        throw std::runtime_error( "unsupported fixup size" );
        break;
    }
  }

  // NOTE: This is not fully tested, may cause issues
  // Why? If the software has a string that contains the following pattern: .?AV
  // It will randomize that string, NOT GOOD.
  //rtti_obfuscator::ObfuscateRTTI( pe );

  const auto nullify_pe_directory = []( PortableExecutable* pe,
                                        IMAGE_NT_HEADERS* nt_headers,
                                        SectionHeaders& section_headers,
                                        const uint32_t directory_index ) {
    const auto rva = nt_headers->OptionalHeader.DataDirectory[ directory_index ]
                         .VirtualAddress;
    const auto size =
        nt_headers->OptionalHeader.DataDirectory[ directory_index ].Size;
    const auto directory_offset = section_headers.RvaToFileOffset( rva );

    auto pe_data = pe->GetPeImagePtr();

    memset( pe_data + directory_offset, 0, size );

    nt_headers->OptionalHeader.DataDirectory[ directory_index ].Size = 0;
    nt_headers->OptionalHeader.DataDirectory[ directory_index ].VirtualAddress =
        0;
  };

  auto new_nt_headers = pe->GetNtHeaders();

  nullify_pe_directory( pe, new_nt_headers, new_pe_section_headers,
                        IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG );

  nullify_pe_directory( pe, new_nt_headers, new_pe_section_headers,
                        IMAGE_DIRECTORY_ENTRY_DEBUG );

  auto section = IMAGE_FIRST_SECTION( new_nt_headers );

  // NOTE: CANNOT DO IT HERE ANYMORE BECAUSE I ADDED VIRTUALIZATION FOR MY TLS CALLBACKS
// After everything is done, rename the sections.
// We cannot do earlier because all code are dependant on the section names
#if 0
  for ( int i = 0; i < new_nt_headers->FileHeader.NumberOfSections; ++i ) {
    strcpy( reinterpret_cast<char*>( section[ i ].Name ), "dicky" );
  }
#endif
}

void AddInterpreterRelocationsToFixup( PortableExecutable& interpreter_pe,
                                       ProtectorContext* context ) {
  const auto vm_fun_section_header =
      interpreter_pe.GetSectionHeaders().FromName( VM_FUNCTIONS_SECTION_NAME );

  // Get relocations in interpreter as section offsets
  const auto vm_fun_section_offsets_that_has_relocations =
      GetRelocationsWithinSectionAsSectionOffsets( interpreter_pe,
                                                   *vm_fun_section_header );

  Fixup fixup;
  fixup.desc.offset_type = OffsetRelativeTo::VmLoaderSection;
  fixup.desc.operation = FixupOperation::AddVmLoaderSectionVirtualAddress;
  fixup.desc.size = sizeof( uint32_t );

  for ( const auto& relocation_section_offset :
        vm_fun_section_offsets_that_has_relocations ) {
    // Add the section offset to vector to later add to the new PE relocation table
    context->fixup_context.vm_section_offsets_to_add_to_relocation_table
        .push_back( relocation_section_offset );

    // Add the offset to the fixups as well to ensure that we add the vm loader virtual address
    fixup.offset = relocation_section_offset;

    context->fixup_context.fixups.push_back( fixup );
  }
}

PortableExecutable AssembleNewPe( const PortableExecutable& original_pe,
                                  ProtectorContext* context ) {
  auto new_sections = original_pe.CopySectionsDeep();

  // Replace the original text section with our modified one
  std::transform( new_sections.begin(), new_sections.end(),
                  new_sections.begin(), [&]( Section& section ) {
                    if ( section.GetName() == ".text" ) {
                      return context->new_text_section;
                    }

                    return section;
                  } );

  auto& reloc_section = new_sections.back();

  // Provided that the .reloc section is the last section, we can add
  // unlimited of relocations to it
  assert( reloc_section.GetName() == ".reloc" );

  auto new_header_data = original_pe.CopyHeaderData();

  IMAGE_NT_HEADERS* new_header_nt_header =
      peutils::GetNtHeaders( new_header_data.data() );

  AddVmSectionRelocations( new_header_nt_header, &reloc_section,
                           &context->fixup_context );

#if ENABLE_TLS_CALLBACKS
  AddVirtualizedCodeSectionRelocations( new_header_nt_header, &reloc_section,
                                        &context->fixup_context );
#endif

  // add the new sections to the new pe
  new_sections.push_back( context->vm_loader_section );
  new_sections.push_back( context->virtualized_code_section );

  return pe::Build( new_header_data, new_sections );
}

void EachInstructionCallback( const cs_insn& instruction,
                              const uint8_t*,
                              void* data ) {
  auto context = reinterpret_cast<ProtectorContext*>( data );

  const auto& original_pe_nt_headers =
      context->virtualizer_context.original_pe_nt_headers;

  const auto vm_opcode = virtualizer::GetVmOpcode( instruction );

  if ( virtualizer::IsVirtualizeable( instruction, vm_opcode ) ) {
    if ( instruction.detail->x86.eflags != 0 ) {
      // NOTE: Consider using this eflags to describe what eflags
      // it changes when virtualizing the instructions for the interpreter
      throw std::runtime_error(
          "An instruction changing eflags was found, not supported at the "
          "moment" );
    }

    // Get the relocations within the instruction, if any exists
    const auto relocations_rva_within_instruction =
        GetRelocationsWithinInstruction(
            instruction,
            context->virtualizer_context.original_pe_relocation_rvas );

    const uint32_t vm_opcode_encyption_key = RandomU32( 1000, 10000000 );

    const auto virtualized_shellcode = virtualizer::CreateVirtualizedShellcode(
        instruction, vm_opcode, vm_opcode_encyption_key,
        relocations_rva_within_instruction,
        context->virtualizer_context.default_image_base );

    const bool created_vm_code = virtualized_shellcode.GetBuffer().size() > 0;

    if ( created_vm_code ) {
      const auto virtualized_code_offset =
          context->virtualized_code_section.AppendCode(
              virtualized_shellcode.GetBuffer(),
              original_pe_nt_headers->OptionalHeader.SectionAlignment,
              original_pe_nt_headers->OptionalHeader.FileAlignment );

      // generate loader shellcode for the virtualized shellcode
      auto vm_code_loader_shellcode =
          virtualizer::GetLoaderShellcodeForVirtualizedCode(
              instruction, vm_opcode,
              original_pe_nt_headers->OptionalHeader.ImageBase );

      vm_code_loader_shellcode.ModifyVariable( VmOpcodeEncryptionKeyVariable,
                                               vm_opcode_encyption_key );

      vm_code_loader_shellcode.ModifyVariable<uintptr_t>(
          VmCodeAddrVariable, virtualized_code_offset );

      const auto loader_shellcode_offset_before =
          context->vm_loader_section.GetCurrentOffset();

      const auto vm_core_function_shellcode_offset =
          vm_code_loader_shellcode.GetNamedValueOffset(
              VmCoreFunctionVariable );

      constexpr auto kCallInstructionSize = 5;

      // this value does not need to be fixed up as we did the others because
      // it it is a call to something in the SAME SECTION
      vm_code_loader_shellcode.ModifyVariable<uint32_t>(
          VmCoreFunctionVariable,
          context->virtualizer_context.interpreter_function_offset -
              loader_shellcode_offset_before - kCallInstructionSize -
              vm_core_function_shellcode_offset + 1 );

      constexpr uint32_t kJmpInstructionSize = 5;

      const auto orig_addr_value_offset =
          vm_code_loader_shellcode.GetNamedValueOffset( OrigAddrVariable );

      const auto destination =
          static_cast<uint32_t>( instruction.address + instruction.size );

      const auto origin = static_cast<uint32_t>(
          loader_shellcode_offset_before + orig_addr_value_offset );

      vm_code_loader_shellcode.ModifyVariable<uint32_t>(
          OrigAddrVariable, destination - origin - kJmpInstructionSize + 1 );

      // Append the vm loader shellcode to the vm loader section
      const auto loader_shellcode_offset =
          context->vm_loader_section.AppendCode(
              vm_code_loader_shellcode.GetBuffer(),
              original_pe_nt_headers->OptionalHeader.SectionAlignment,
              original_pe_nt_headers->OptionalHeader.FileAlignment );

      ////////////////////////////
      // AddJmpBackAddrToFixup
      Fixup jmp_back_addr_fixup;
      jmp_back_addr_fixup.offset =
          loader_shellcode_offset + orig_addr_value_offset;
      jmp_back_addr_fixup.desc.offset_type = OffsetRelativeTo::VmLoaderSection;
      jmp_back_addr_fixup.desc.operation =
          FixupOperation::SubtractVmLoaderSectionVirtualAddress;
      jmp_back_addr_fixup.desc.size = sizeof( uint32_t );
      context->fixup_context.fixups.push_back( jmp_back_addr_fixup );
      ////////////////////////////////

      ///////////////////
      // AddVmCodeAddressToFixup
      const auto vm_code_addr_offset =
          loader_shellcode_offset +
          vm_code_loader_shellcode.GetNamedValueOffset( VmCodeAddrVariable );

      Fixup virtualized_code_addr_fixup;
      virtualized_code_addr_fixup.offset = vm_code_addr_offset;
      virtualized_code_addr_fixup.desc.offset_type =
          OffsetRelativeTo::VmLoaderSection;
      virtualized_code_addr_fixup.desc.operation =
          FixupOperation::AddVirtualizedCodeSectionVirtualAddress;
      virtualized_code_addr_fixup.desc.size = sizeof( uint32_t );
      context->fixup_context.fixups.push_back( virtualized_code_addr_fixup );

      const auto vm_var_section_shellcode_offset =
          vm_code_loader_shellcode.GetNamedValueOffset( ImageBaseVariable );

      // add fixup for the image base argument for interpreter call
      context->fixup_context.vm_section_offsets_to_add_to_relocation_table
          .push_back( loader_shellcode_offset +
                      vm_var_section_shellcode_offset );
      ///////////////

      uintptr_t section_offset = 0;
      uint8_t* section_data = 0;
      OffsetRelativeTo jmp_fixup_relative_to = OffsetRelativeTo::Unknown;

      switch ( context->virtualizer_context.what_to_virtualize ) {
        case WhatToVirtualize::TextSection: {
          section_offset = section::RvaToSectionOffset(
              context->virtualizer_context.original_text_section_header,
              static_cast<uint32_t>( instruction.address ) );

          section_data = context->new_text_section.GetData()->data();

          jmp_fixup_relative_to = OffsetRelativeTo::TextSection;
        } break;
        case WhatToVirtualize::VmLoaderSection: {
          section_offset = section::RvaToSectionOffset(
              context->virtualizer_context.vm_loader_section_header,
              static_cast<uint32_t>( instruction.address ) );

          section_data = context->vm_loader_section.GetData()->data();

          jmp_fixup_relative_to = OffsetRelativeTo::VmLoaderSection;
        } break;
        default:
          assert( false );
          break;
      }

      const auto first = section_data + section_offset;

      const auto last = first + instruction.size;
      const auto dest = first;

      // Fill the whole instruction with random bytes
      std::transform( first, last, dest,
                      []( uint8_t b ) { return RandomU8(); } );

      constexpr uint8_t kJmpOpcode = 0xE9;

      // Write the jump
      *first = kJmpOpcode;

      const auto jmp_addr_offset = section_offset + 1;

      const uint32_t jmp_destination =
          static_cast<uint32_t>( loader_shellcode_offset -
                                 instruction.address ) -
          kJmpInstructionSize;

      // Cast the jump desination to a uint8_t array because the section data
      // is in uint8_t format
      const auto jmp_destination_as_uint8_array =
          reinterpret_cast<const uint8_t*>( &jmp_destination );

      // Write the jump destination
      std::copy( jmp_destination_as_uint8_array,
                 jmp_destination_as_uint8_array + sizeof( jmp_destination ),
                 section_data + jmp_addr_offset );

      Fixup jmp_to_vm_loader_fixup;
      jmp_to_vm_loader_fixup.offset = jmp_addr_offset;
      jmp_to_vm_loader_fixup.desc.offset_type = jmp_fixup_relative_to;
      jmp_to_vm_loader_fixup.desc.operation =
          FixupOperation::AddVmLoaderSectionVirtualAddress;
      jmp_to_vm_loader_fixup.desc.size = sizeof( uint32_t );
      context->fixup_context.fixups.push_back( jmp_to_vm_loader_fixup );

      // if it was relocated, add it to a list to remove the relocation later
      // on from PE because when we virtualize an instruction, we handle the relocation ourselve
      for ( const auto reloc_rva : relocations_rva_within_instruction ) {
        context->fixup_context.relocation_rvas_to_remove.push_back( reloc_rva );
      }

      ++context->virtualizer_context.total_virtualized_instructions;

      file_log::Info( "Virtualized 0x%08I64x, %s %s", instruction.address,
                      instruction.mnemonic, instruction.op_str );
    }
  }

  ++context->virtualizer_context.total_disassembled_instructions;
};

// Because the disassembler can get it wrong sometimes, we add a callback to reset
// the virtualized instruction if it notices that it disassembled invalid instructions
void InvalidInstructionCallback( const uint64_t address,
                                 const SmallInstructionData ins_data,
                                 void* data ) {
  auto context = reinterpret_cast<ProtectorContext*>( data );

  const auto text_section_offset = section::RvaToSectionOffset(
      context->virtualizer_context.original_text_section_header, address );

  // NOTE: THERE IS MORE WE NEED TO DO HERE I THINK
  //assert( false && "verify if the changes made here are correct" );

  //const auto text_section_data =
  //    original_pe.GetPeImagePtr() +
  //    original_text_section_header.PointerToRawData;
  const auto text_section_data = context->new_text_section.GetData()->data();

  auto original_pe_text_section_data =
      context->virtualizer_context.original_text_section_copy.GetData();

  // TODO: replace with std::copy
  // if the invalid instruction was virtualized, we reset it back here
  // below
  memcpy( text_section_data + text_section_offset,
          &( *original_pe_text_section_data )[ text_section_offset ],
          ins_data.instruction_size_ );

  // Do this disgusting hack for now, change later
  cs_insn temp_instruction;
  temp_instruction.size = ins_data.instruction_size_;
  temp_instruction.address = address;

  // Get the relocations within the instruction, if any exists
  const auto relocations_rva_within_instruction =
      GetRelocationsWithinInstruction(
          temp_instruction,
          context->virtualizer_context.original_pe_relocation_rvas );

  // Remove the relocations from the remove-list
  // In other words, restore the relocations that were previously removed
  for ( const auto& reloc_rva : relocations_rva_within_instruction ) {
    const auto it_result = std::find(
        context->fixup_context.relocation_rvas_to_remove.cbegin(),
        context->fixup_context.relocation_rvas_to_remove.cend(), reloc_rva );

    const bool found =
        it_result != context->fixup_context.relocation_rvas_to_remove.end();

    if ( found ) {
      context->fixup_context.relocation_rvas_to_remove.erase( it_result );
    }
  }

  char buf[ MAX_PATH ]{ 0 };
  sprintf_s( buf, "Resetting invalid instruction 0x%08I64x\n",
             static_cast<uint64_t>( address ) );
  printf( "%s\n", buf );
};

// Takes in the almost finished PE and virtualizes the TLS callbacks that we added in the beginning
PortableExecutable VirtualizeMyTlsCallbacksAndNewEntrypoint(
    PortableExecutable& new_pe,
    PortableExecutable& original_pe,
    const PortableExecutable& interpreter_pe,
    const IMAGE_NT_HEADERS& original_pe_nt_headers,
    const IMAGE_SECTION_HEADER& original_text_section_header,
    ProtectorContext* context ) {
  // Since we are going to create a new PE based on the previously
  // created PE, we can re-use the same protector context
  // We only need to update one value inside of it

  context->fixup_context.relocation_rvas_to_remove.clear();

  std::vector<uintptr_t> new_pe_relocation_rvas = GetRelocationRvas( new_pe );

  // Sort for quick binary search
  std::sort( new_pe_relocation_rvas.begin(), new_pe_relocation_rvas.end() );

  // Update the original relocations to the new PE relocations
  context->virtualizer_context.original_pe_relocation_rvas =
      new_pe_relocation_rvas;

  const auto vm_loader_section_header =
      new_pe.GetSectionHeaders().FromName( VM_LOADER_SECTION_NAME );

  context->virtualizer_context.vm_loader_section_header =
      *vm_loader_section_header;

  const auto OnInvalidInstructionCallback =
      []( const uint64_t address, const SmallInstructionData ins_data, void* ) {
        // We do not anticipate this will occur in such small code such as my TLS callbacks
        throw std::runtime_error(
            "An invalid instruction was disassembled while trying to "
            "virtualize our own code." );
      };

  PeDisassemblyEngine pe_disassembler( new_pe );

  const auto first_interpreter_tls_callback_offset =
      GetExportedFunctionOffsetRelativeToSection( interpreter_pe,
                                                  "FirstTlsCallback" );

  const auto second_interpreter_tls_callback_offset =
      GetExportedFunctionOffsetRelativeToSection( interpreter_pe,
                                                  "SecondTlsCallback" );

  const auto custom_entrypoint_interpreter_offset =
      GetExportedFunctionOffsetRelativeToSection( interpreter_pe,
                                                  "BeforeEntrypoint" );

  assert( first_interpreter_tls_callback_offset ||
          second_interpreter_tls_callback_offset ||
          custom_entrypoint_interpreter_offset );

#if 1
  // Add my TLS callbacks as disassembly points for the disassembly engine
  {
    const auto first_tls_callback_offset =
        vm_loader_section_header->PointerToRawData +
        first_interpreter_tls_callback_offset;

    const auto first_tls_callback_rva =
        vm_loader_section_header->VirtualAddress +
        first_interpreter_tls_callback_offset;

    DisassemblyPoint disasm_point;
    disasm_point.code = new_pe.GetPeImagePtr() + first_tls_callback_offset;
    disasm_point.rva = first_tls_callback_rva;
    pe_disassembler.AddDisassemblyPoint( disasm_point );
  }
  {
    const auto second_tls_callback_offset =
        vm_loader_section_header->PointerToRawData +
        second_interpreter_tls_callback_offset;

    const auto second_tls_callback_rva =
        vm_loader_section_header->VirtualAddress +
        second_interpreter_tls_callback_offset;

    DisassemblyPoint disasm_point;
    disasm_point.code = new_pe.GetPeImagePtr() + second_tls_callback_offset;
    disasm_point.rva = second_tls_callback_rva;
    pe_disassembler.AddDisassemblyPoint( disasm_point );
  }
#endif

  {
    // The new_pe has the newly added entrypoint, lets virtualize that as well
    const auto new_entrypoint_rva =
        new_pe.GetNtHeaders()->OptionalHeader.AddressOfEntryPoint;

    // custom_entrypoint_offset
    const auto new_entrypoint_offset =
        new_pe.GetSectionHeaders().RvaToFileOffset( new_entrypoint_rva );

    DisassemblyPoint disasm_point;
    disasm_point.code = new_pe.GetPeImagePtr() + new_entrypoint_offset;
    disasm_point.rva = new_entrypoint_rva;
    pe_disassembler.AddDisassemblyPoint( disasm_point );

    // Set the disassembly point to the first TLS callback
    pe_disassembler.SetDisassemblyPoint(
        disasm_point, vm_loader_section_header->SizeOfRawData );
  }

  pe_disassembler.BeginDisassembling( EachInstructionCallback,
                                      OnInvalidInstructionCallback, context );

  // Re-create the PE again with the virtualized TLS callbacks
  auto new_pe_result = AssembleNewPe( original_pe, context );

  ApplyFixups( &new_pe_result, original_text_section_header,
               context->fixup_context.fixups );

  // This time we remove it afterwards the whole PE is finished. Why?
  // Because LOW chance to remove something by mistake because I am
  // only virtualizing my own added stuff
  // Also, cannot remove it before because e.g. I add my own
  // relocation when I override my entrypoint.
  // Scuffed as fock.
  RemoveRelocations( context->fixup_context.relocation_rvas_to_remove,
                     &new_pe_result );

  return new_pe_result;
}

void RemoveImports( PortableExecutable* pe,
                    ProtectorContext* context,
                    uintptr_t vm_code_section_data_offset ) {
  // Make the import directory point to zeroed data
  // Why? Because removing it completely, for some reason, makes it so
  // when protecting a DLL, the TLS callback are never called.

  const auto nt_headers = pe->GetNtHeaders();
  const auto import_data_directory =
      &nt_headers->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_IMPORT ];

  import_data_directory->Size = 8;

  // Set to the offset of the vm code init data, we will later
  // fixup it to add the virtual address of the vm code section
  // It will point to the zeroed data in the beginning of VmCodeSectionData
  import_data_directory->VirtualAddress = vm_code_section_data_offset;

  // Fixup the VirtualAddress field in the import data directory
  // to add the the virtualized code section RVA. That is were the
  // struct VmCodeSectionData is located
  Fixup import_data_va_fixup;
  import_data_va_fixup.desc.offset_type = OffsetRelativeTo::Beginning;
  import_data_va_fixup.desc.operation =
      FixupOperation::AddVirtualizedCodeSectionVirtualAddress;
  import_data_va_fixup.desc.size =
      sizeof( import_data_directory->VirtualAddress );
  import_data_va_fixup.offset =
      reinterpret_cast<uintptr_t>( import_data_directory ) -
      reinterpret_cast<uintptr_t>( pe->GetPeImagePtr() ) +
      offsetof( IMAGE_DATA_DIRECTORY, VirtualAddress );

  context->fixup_context.fixups.push_back( import_data_va_fixup );

  const auto iat_data_directory =
      &nt_headers->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_IAT ];

  // IMAGE_DIRECTORY_ENTRY_IMPORT and IMAGE_DIRECTORY_ENTRY_IAT goes hand in
  // hand, we must remove both of them to avoid crash in ntdll PE loader
  iat_data_directory->Size = 0;
  iat_data_directory->VirtualAddress = 0;
}

const auto DefaultImageBaseVariable = TEXT( "DefaultImageBase" );
const auto BeforeEntrypointFunctionVariable =
    TEXT( "BeforeEntrypointFunction" );

Shellcode CreateEntrypointShellcodeX64( const uint64_t default_image_base ) {
  Shellcode shellcode;

  // push rax
  shellcode.AddByte( 0x50 );

  // push rcx
  shellcode.AddByte( 0x51 );

  // push rax
  shellcode.AddByte( 0x50 );

  // mov rcx, 64 bit value
  shellcode.AddBytes( { 0x48, 0xB9 } );
  shellcode.AddVariable<uint64_t>( default_image_base,
                                   DefaultImageBaseVariable );

  // call
  shellcode.AddByte( 0xE8 );
  shellcode.AddVariable<uint32_t>( 0, BeforeEntrypointFunctionVariable );

  // mov qword ptr ss:[rsp+0x10], rax
  shellcode.AddBytes( { 0x48, 0x89, 0x44, 0x24, 0x10 } );

  // pop rax
  shellcode.AddByte( 0x58 );

  // pop rcx
  shellcode.AddByte( 0x59 );

  // ret
  shellcode.AddByte( 0xC3 );

  return shellcode;
}

Shellcode CreateEntrypointShellcodeX86( const uint32_t default_image_base ) {
  Shellcode shellcode;

  // push eax
  shellcode.AddByte( 0x50 );

  // push eax
  shellcode.AddByte( 0x50 );

  // push image base
  shellcode.AddByte( 0x68 );
  shellcode.AddVariable<uint32_t>( default_image_base,
                                   DefaultImageBaseVariable );

  // call
  shellcode.AddByte( 0xE8 );
  shellcode.AddVariable<uint32_t>( 0, BeforeEntrypointFunctionVariable );

  // mov dword ptr ss:[esp+0x4], eax
  shellcode.AddBytes( { 0x89, 0x44, 0x24, 0x04 } );

  // pop eax
  shellcode.AddByte( 0x58 );

  // ret
  shellcode.AddByte( 0xC3 );

  return shellcode;
}

void OverrideOriginalEntrypoint( const PortableExecutable& original_pe,
                                 const PortableExecutable& interpreter_pe,
                                 ProtectorContext* context ) {
  /*
    NOTE: We usually should not use CALL in shellcode because it changes 
    E/RFLAGS in some cases when a task switch occurs, however, 
    in this case it won't because it is an immediate call

    x86 EP Assembly:
      push eax 				        <-- Allocate stack for real_ep, but why push eax? Because sub esp, 4 changes E/RFLAGS
      push eax				        <-- Save EAX
      push imagebase			    <-- Push imagebase
      call my_entrypoint		  <-- Call our entrypoint
      mov [esp + 0x4], eax	  <-- Save the return value (OEP) on the stack we allocated
      pop eax					        <-- Restore EAX
      ret 					          <-- Jump to OEP

    x64 EP Assembly:
      push rax                    <-- Allocate stack for real_ep, but why push rax? Because sub esp, 8 changes E/RFLAGS
      push rcx                    <-- Save RCX
      push rax                    <-- Save RAX
      mov rcx, imagebase          <-- Move imagebase into 1st argument
      call my_entrypoint          <-- Call our entrypoint
      mov [rsp + 0x10], rax       <-- Save the return value (OEP) on the stack we allocated
      pop rax                     <-- Restore RAX
      pop rcx                     <-- Restore RCX
      ret                         <-- Jump to OEP
  */

  const auto new_ep_func_offset = GetExportedFunctionOffsetRelativeToSection(
      interpreter_pe, "BeforeEntrypoint" );

  const auto default_image_base =
      context->virtualizer_context.original_pe_nt_headers->OptionalHeader
          .ImageBase;

#ifdef _WIN64
  auto new_entrypoint_shellcode =
      CreateEntrypointShellcodeX64( default_image_base );
#else
  auto new_entrypoint_shellcode =
      CreateEntrypointShellcodeX86( default_image_base );
#endif

  const auto file_aligment =
      context->virtualizer_context.original_pe_nt_headers->OptionalHeader
          .FileAlignment;

  // Call destination:
  // AbsoluteDestination = Origin + CallValue + 5
  // We want formula for CallValue (with some algebra rules YEET)
  // CallValue = AbsoluteDestination - Origin - 5

  const auto new_ep_vm_loader_offset =
      context->vm_loader_section.GetCurrentOffset();

  const auto before_ep_function_addr_shellcode_offset =
      new_entrypoint_shellcode.GetNamedValueOffset(
          BeforeEntrypointFunctionVariable );

  const auto kCallInstructionSize = 5;
  const auto absolute_destination = new_ep_func_offset;
  const auto origin = new_ep_vm_loader_offset +
                      ( before_ep_function_addr_shellcode_offset - 1 );

  const auto new_call_dest =
      absolute_destination - origin - kCallInstructionSize;

  new_entrypoint_shellcode.ModifyVariable<uint32_t>(
      BeforeEntrypointFunctionVariable, new_call_dest );

  context->vm_loader_section.AppendCode( new_entrypoint_shellcode.GetBuffer(),
                                         0, file_aligment );

  context->virtualizer_context.original_pe_nt_headers->OptionalHeader
      .AddressOfEntryPoint = new_ep_vm_loader_offset;

  // Add the AddressOfEntrypoint in the pe header to the fixup
  {
    Fixup fixup;
    fixup.desc.offset_type = OffsetRelativeTo::Beginning;
    fixup.desc.operation = FixupOperation::AddVmLoaderSectionVirtualAddress;
    fixup.desc.size =
        sizeof( context->virtualizer_context.original_pe_nt_headers
                    ->OptionalHeader.AddressOfEntryPoint );

    const auto pe_beginning_addr =
        reinterpret_cast<uintptr_t>( original_pe.GetPeImagePtr() );

    const auto address_of_ep_addr = reinterpret_cast<uintptr_t>(
        &context->virtualizer_context.original_pe_nt_headers->OptionalHeader
             .AddressOfEntryPoint );

    const auto address_of_ep_offset = address_of_ep_addr - pe_beginning_addr;

    fixup.offset = address_of_ep_offset;

    context->fixup_context.fixups.push_back( fixup );
  }

  const auto vm_loader_offset_ep_shellcode_imagebase_offset =
      new_ep_vm_loader_offset +
      new_entrypoint_shellcode.GetNamedValueOffset( DefaultImageBaseVariable );

  // Add the "PUSH ImageBase" in the entrypoint shellcode to the relocation table
  context->fixup_context.vm_section_offsets_to_add_to_relocation_table
      .push_back( vm_loader_offset_ep_shellcode_imagebase_offset );
}

PortableExecutable Protect( PortableExecutable original_pe ) {
  const auto original_pe_nt_headers = original_pe.GetNtHeaders();

#ifndef _WIN64
  if ( original_pe_nt_headers->OptionalHeader.Magic !=
       IMAGE_NT_OPTIONAL_HDR32_MAGIC ) {
    throw std::runtime_error(
        "Please use the x64 version of GreyM to protect this executable." );
  }
#else
  if ( original_pe_nt_headers->OptionalHeader.Magic !=
       IMAGE_NT_OPTIONAL_HDR64_MAGIC ) {
    throw std::runtime_error(
        "Please use the x86 version of GreyM to protect this executable." );
  }
#endif

  // Before the original_pe argument is touched, initialize the disassembly engine with it
  PeDisassemblyEngine pe_disassembler( original_pe );

  // todo make the section sizes aligned with the remap
  // be aware, that remap will not work if protected with vmprotect

  PortableExecutable interpreter_pe = ReadInterpreterPe();

  if ( !interpreter_pe.IsValid() ) {
    throw std::runtime_error( "Interpreter is not valid portable executable" );
  }

  ProtectorContext context;

  context.virtualizer_context.original_pe_nt_headers = original_pe_nt_headers;

  context.virtualizer_context.default_image_base =
      original_pe_nt_headers->OptionalHeader.ImageBase;

  context.virtualizer_context.interpreter_function_offset =
      GetExportedFunctionOffsetRelativeToSection( interpreter_pe,
                                                  "VmInterpreter" );

  // When having a jump table in the interpreter, it has a pointer to th jump table
  // that contains the address to locations. Those locatino are being relocated by default.
  // Therefore we need to relocate them as well in order to be able to use them.
  RelocateInterpreterPe( &interpreter_pe,
                         original_pe_nt_headers->OptionalHeader.ImageBase );

  context.vm_loader_section = CreateVmSection( interpreter_pe );

  // Add write access because we edit the callback list in the FirstTlsCallback()
  context.virtualized_code_section = section::CreateEmptySection(
      VM_CODE_SECTION_NAME, IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_DISCARDABLE |
                                IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_WRITE );

  VmCodeSectionData vm_code_section_data;

  vm_code_section_data.real_entrypoint =
      original_pe_nt_headers->OptionalHeader.AddressOfEntryPoint;

  // TODO: Add this as an option for the user
  // Why? It can cause issues for some software such as PE-bear with QTcore
  // and my flyff bot, failing to select monsters..?
  // I have not investigated further
  vm_code_section_data.redirect_imports = true;

  memset( vm_code_section_data.zeroed_data_for_import_directory, 0,
          sizeof( vm_code_section_data.zeroed_data_for_import_directory ) );

  vm_code_section_data.import_count =
      static_cast<uint32_t>( original_pe.GetImports().size() );

  // Fill with random data for fun
  for ( int i = 0;
        i < sizeof( vm_code_section_data.friendly_message ) / sizeof( char );
        ++i ) {
    vm_code_section_data.friendly_message[ i ] = RandomU8();
  }

  // Write the message for the reverse engineer'er
  strcpy( vm_code_section_data.friendly_message,
          "bruh, you're not supposed to be here! yo momma fat" );

  const auto import_data_directory =
      &original_pe_nt_headers->OptionalHeader
           .DataDirectory[ IMAGE_DIRECTORY_ENTRY_IMPORT ];

  // Copy the data directory for our own import fixer in the TLS callbacks
  vm_code_section_data.import_data_directory = *import_data_directory;

  // Add the init data for the vm code section
  const auto vm_code_section_data_offset =
      context.virtualized_code_section.AppendValue(
          vm_code_section_data,
          original_pe_nt_headers->OptionalHeader.FileAlignment );

  RemoveImports( &original_pe, &context, vm_code_section_data_offset );

#if ENABLE_TLS_CALLBACKS
  AddTlsCallbacks( vm_code_section_data, interpreter_pe, &original_pe,
                   &context );
#endif

  OverrideOriginalEntrypoint( original_pe, interpreter_pe, &context );

  const auto original_text_section_header =
      *original_pe.GetSectionHeaders().FromName( ".text" );

  // Save the text section before modifying it for use later
  // when an invalid instruction has been virtualized to reset the instruction
  context.virtualizer_context.original_text_section_copy =
      original_pe.CopySectionDeep( &original_text_section_header );

  // The text section that will be modified with jumps
  context.new_text_section =
      original_pe.CopySectionDeep( &original_text_section_header );

  context.virtualizer_context.original_text_section_header =
      original_text_section_header;

  Stopwatch stopwatch;
  stopwatch.Start();

  AddInterpreterRelocationsToFixup( interpreter_pe, &context );

  context.virtualizer_context.original_pe_relocation_rvas =
      GetRelocationRvas( original_pe );

  // Sort for quick binary search
  std::sort( context.virtualizer_context.original_pe_relocation_rvas.begin(),
             context.virtualizer_context.original_pe_relocation_rvas.end() );

  context.virtualizer_context.what_to_virtualize =
      WhatToVirtualize::TextSection;

  pe_disassembler.DisassembleFromEntrypoint(
      EachInstructionCallback, InvalidInstructionCallback, &context );

#if 0
  // IF WE ADD PADDING THIS LATE TO THE LAST SECTION the calculate
  // vm_section VA won't work, do it earlier

  SYSTEM_INFO si;
  GetSystemInfo( &si );

  // get last section
  auto& last_section = new_modified_sections.back();

  const auto last_section_size = last_section.GetSectionHeader().SizeOfRawData;

  std::vector<uint8_t> padding_data;

  if ( ( last_section_size % si.dwAllocationGranularity ) != 0 ) {
    const auto new_aligned_size =
        peutils::Align( last_section_size, si.dwAllocationGranularity );
    padding_data.resize( new_aligned_size - last_section_size );
  }

  for ( size_t i = 0; i < padding_data.size() - 1; ++i ) {
    padding_data[ i ] = rand() % 0xff;
  }

  last_section.AppendCode( padding_data,
                           nt_headers->OptionalHeader.SectionAlignment,
                           nt_headers->OptionalHeader.FileAlignment );
#endif

  // Require the text section size to be the same as the original, we
  // cannot change a section size that is in the middle between other sections
  assert( context.new_text_section.GetSectionHeader().SizeOfRawData ==
          original_text_section_header.SizeOfRawData );

  // We remove the relocations before assembling it. Otherwise it can by mistake
  // remove one of our own relocations because it us using RVA and they have not yet been fixed up.
  RemoveRelocations( context.fixup_context.relocation_rvas_to_remove,
                     &original_pe );

  // Save a copy of the context before we build the first PE. Why?
  // Because it modifes the context and adds fixup that we don't want
  // added when we build the absolutely last version of the PE
  // Ugly way to do it :(
  ProtectorContext context_saved = context;

  // Build and fix the almost finished PE
  auto new_pe = AssembleNewPe( original_pe, &context );

  // NOTE: We do not need to fixup this version of the PE because we
  // only use this version to virtualize my TLS callbacks
  ApplyFixups( &new_pe, original_text_section_header,
               context.fixup_context.fixups );

  context_saved.virtualizer_context.what_to_virtualize =
      WhatToVirtualize::VmLoaderSection;

  // Now virtualize the TLS callbacks that we added in the beginning and
  // create a new PE again with the virtualized TLS callbacks
  new_pe = VirtualizeMyTlsCallbacksAndNewEntrypoint(
      new_pe, original_pe, interpreter_pe, *original_pe_nt_headers,
      original_text_section_header, &context_saved );

// Randomize all section names except for the vm code
// section because we rely on it being that name in our tls callbacks
#if 1
  const auto nt = new_pe.GetNtHeaders();

  for ( int i = 0; i < nt->FileHeader.NumberOfSections; ++i ) {
    const auto section = &IMAGE_FIRST_SECTION( nt )[ i ];

    // Because the name in the section header may not be null terminated
    char buffer[ 8 + 1 ] = { 0 };

    memcpy( buffer, section->Name, 8 );

    bool is_vm_code_section = strcmp( buffer, VM_CODE_SECTION_NAME ) == 0;

    if ( !is_vm_code_section ) {
      strcpy( reinterpret_cast<char*>( section->Name ), "bruh" );
    }
  }
#endif

  stopwatch.Stop();

  printf( "Total Disassembled Instructions: %d\n",
          context.virtualizer_context.total_disassembled_instructions );

  printf( "Total Virtualized Instructions: %d\n",
          context.virtualizer_context.total_virtualized_instructions );

  printf( "Time spent: %f ms\n", stopwatch.GetElapsedMilliseconds() );

  return new_pe;
}
}  // namespace protector
```

`GreyM/src/protector.h`:

```h
#pragma once

class PortableExecutable;

namespace protector {

PortableExecutable Protect( const PortableExecutable pe );

}  // namespace protector

```

`GreyM/src/rtti_obfuscator.cpp`:

```cpp
#include "pch.h"
#include "rtti_obfuscator.h"
#include "pe/portable_executable.h"
#include "utils/random.h"

namespace rtti_obfuscator {

void ObfuscateRTTI( PortableExecutable* pe ) {
  constexpr int kMaxTypenameLength = 255;

  std::array<uint8_t, kMaxTypenameLength> buffer{ 0 };

  auto& pe_data = pe->GetPeData();

  std::vector<uint8_t> pattern = { '.', '?', 'A', 'V' };

  for ( size_t i = 0; i < pe_data.size() - pattern.size(); ++i ) {
    const auto current_it = pe_data.begin() + i;
    const auto current_it_end = current_it + pattern.size();
    // check if the iterator is equal to the pattern .?AV
    if ( std::equal( current_it, current_it_end, pattern.begin() ) ) {
      const auto max_chars_to_search_for_end_it =
          current_it_end + kMaxTypenameLength;
      // find the end of the string, if no found, the string is longer than 255
      // or not a string at all in that case, we do not want to do anything with
      // it
      const auto typename_end =
          std::find_if( current_it_end, max_chars_to_search_for_end_it,
                        []( uint8_t value ) { return value == '\0'; } );
      if ( typename_end != pe_data.end() ) {
        const auto typename_str_length =
            std::distance( current_it, typename_end );
        // replace the typename string with 3 random bytes
        GenerateRandomBytes( buffer, 3 );
        std::copy( buffer.begin(), buffer.begin() + typename_str_length,
                   current_it );
      }
    }
  }
}

}  // namespace rtti_obfuscator
```

`GreyM/src/rtti_obfuscator.h`:

```h
#pragma once

class PortableExecutable;

namespace rtti_obfuscator {

// Obfuscates the runtime type information information
void ObfuscateRTTI( PortableExecutable* pe );

}  // namespace rtti_obfuscator
```

`GreyM/src/utils/console_log.h`:

```h
#pragma once

#include <string>
#include <stdarg.h>
#include <windows.h>

namespace console {

inline void Print( const char* format, ... ) {
  va_list args;
  va_start( args, format );

  vprintf( format, args );
  printf( "\n" );

  va_end( args );
}

}  // namespace console
```

`GreyM/src/utils/defer.h`:

```h
#pragma once

namespace __privadad {

template <typename F>
struct Defer {
  Defer( F f ) : func_( f ) {}

  ~Defer() {
    func_();
  }

  F func_;
};

template <typename F>
Defer<F> __DeferFunc( F f ) {
  return Defer<F>( f );
}

// CHAOS
#define __Defer2( code, county ) \
  const auto __defer##county = __privadad::__DeferFunc( [&]() { code; } )

#define __Defer1( code, county ) __Defer2( code, county )

#define Defer( code ) __Defer1( code, __COUNTER__ )

}  // namespace __privadad

```

`GreyM/src/utils/file_io.cpp`:

```cpp
#include "pch.h"
#include "file_io.h"
#include "string_utils.h"

std::vector<uint8_t> fileio::ReadBinaryFile( const std::wstring& filename ) {
  std::ifstream file( filename, std::ifstream::in | std::ifstream::binary );

  if ( !file.is_open() ) {
    throw std::runtime_error( "Unable to open file " +
                              string_utils::WideToAnsi( filename ) );
  }

  file.seekg( 0, std::ifstream::end );
  const auto length = static_cast<size_t>( file.tellg() );
  file.seekg( 0, std::ifstream::beg );

  std::vector<uint8_t> output;
  output.resize( length );

  file.read( reinterpret_cast<char*>( output.data() ), length );

  if ( file.bad() || file.fail() ) {
    throw std::runtime_error( "Error occured while trying to read the file " +
                              string_utils::WideToAnsi( filename ) );
  }

  file.close();

  return output;
}

bool fileio::WriteFileData( const std::wstring& filename,
                            const std::vector<uint8_t>& buf ) {
  std::ofstream file( filename, std::ofstream::out | std::ofstream::binary );

  file.write( reinterpret_cast<const char*>( buf.data() ), buf.size() );

  file.close();

  return !file.bad() || !file.fail();
}

```

`GreyM/src/utils/file_io.h`:

```h
#pragma once

namespace fileio {

// ReadFileData returns an empty vector if failed
std::vector<uint8_t> ReadBinaryFile( const std::wstring& filename );

bool WriteFileData( const std::wstring& filename,
                    const std::vector<uint8_t>& buf );

}  // namespace fileio
```

`GreyM/src/utils/file_log.cpp`:

```cpp
#include "pch.h"
#include "file_log.h"

static std::ofstream file( "log.txt", std::ofstream::out );

// to avoid allocations each time, use the same buffer all the time
static char g_log_buffer[ 1024 + 1 ];

void LogFormat( const uintptr_t offset,
                          const char* format,
                          va_list args ) {
  const auto chars_written_count =
      vsprintf( g_log_buffer + offset, format, args );

  // add newline
  g_log_buffer[ offset + chars_written_count ] = '\n';
  // null terminate it
  g_log_buffer[ offset + chars_written_count + 1 ] = '\0';

  file << g_log_buffer;

  // Reset the log buffer
  g_log_buffer[ 0 ] = '\0';
}

void file_log::Info( const char* format, ... ) {
  strcat( g_log_buffer, "[INFO] \0" );

  va_list args;

  va_start( args, format );

  LogFormat( strlen( g_log_buffer ), format, args );

  va_end( args );
}

```

`GreyM/src/utils/file_log.h`:

```h
#pragma once

/*
  Not thread safe, tried to make as fast as possible, 
  hence the use of C api and not C++ shit
*/

#include <stdarg.h>

namespace file_log {

void Info( const char* format, ... );

}  // namespace file_log
```

`GreyM/src/utils/random.h`:

```h
#pragma once

inline uint8_t RandomU8() {
  return rand() % 0xff;
}

template <int N>
inline void GenerateRandomBytes( std::array<uint8_t, N>& buffer,
                                 const uint32_t length ) {
  for ( uint32_t i = 0; i < length; ++i ) {
    buffer[ i ] = RandomU8();
  }
}

inline uint32_t RandomU32( const int min, const int max ) {
  return rand() % max + min;
}
```

`GreyM/src/utils/shellcode.cpp`:

```cpp
#include "pch.h"
#include "shellcode.h"
#include "../utils/string_utils.h"

void Shellcode::AddByte( const uint8_t value ) {
  buffer_.push_back( value );
}

void Shellcode::AddBytes( const std::initializer_list<uint8_t> bytes ) {
  buffer_.insert( buffer_.end(), bytes );
}

int32_t Shellcode::GetNamedValueOffset( const std::wstring& value_name ) {
  for ( const auto& named_value : named_value_offsets_ ) {
    if ( named_value.first == value_name ) {
      return named_value.second;
    }
  }

  throw std::runtime_error( string_utils::WideToAnsi( value_name ) +
                            " was not found in the shellcode" );
}

void Shellcode::Reserve( const size_t capacity ) {
  buffer_.reserve( capacity );
}

const std::vector<uint8_t>& Shellcode::GetBuffer() const {
  return buffer_;
}

```

`GreyM/src/utils/shellcode.h`:

```h
#pragma once

#include <string>
#include <algorithm>

class Shellcode {
 public:
  void AddByte( const uint8_t value );
  void AddBytes( const std::initializer_list<uint8_t> bytes );

  template <typename T>
  void AddVariable( const T& value,
                    const std::wstring& value_name = TEXT( "" ) );

  template <typename T>
  void AddValue( const T& value );

  template <typename T>
  void ModifyVariable( const std::wstring& value_name, const T& value );

  int32_t GetNamedValueOffset( const std::wstring& value_name );

  void Reserve( const size_t capacity );

  const std::vector<uint8_t>& GetBuffer() const;

 private:
  std::vector<uint8_t> buffer_;
  std::unordered_map<std::wstring, uint32_t> named_value_offsets_;
};

template <typename T>
void Shellcode::AddVariable( const T& value, const std::wstring& value_name ) {
  if ( !value_name.empty() ) {
    const auto current_buffer_offset = buffer_.size();
    named_value_offsets_.insert(
        std::make_pair( value_name, current_buffer_offset ) );
  }

  AddValue( value );
}

template <typename T>
void Shellcode::AddValue( const T& value ) {
  const uint8_t* buf = reinterpret_cast<const uint8_t*>( &value );

  std::copy( &buf[ 0 ], &buf[ sizeof( value ) ],
             std::back_inserter( buffer_ ) );
}

template <typename T>
void Shellcode::ModifyVariable( const std::wstring& value_name,
                                const T& value ) {
  const auto buf_offset = GetNamedValueOffset( value_name );

  if ( buf_offset != -1 ) {
    const uint8_t* buf = reinterpret_cast<const uint8_t*>( &value );
    std::copy( &buf[ 0 ], &buf[ sizeof( value ) ],
               buffer_.begin() + buf_offset );
  }
}
```

`GreyM/src/utils/stopwatch.h`:

```h
#pragma once

#include <Windows.h>

class Stopwatch {
 public:
  Stopwatch() : m_timeBegin{ 0 }, m_timeEnd{ 0 }, m_isRunning( false ) {
    LARGE_INTEGER frequency;

    if ( !QueryPerformanceFrequency( &frequency ) ) {
      // log error
    }

    m_frequency = ( double )frequency.QuadPart;
  }

  void Start() {
    if ( !m_isRunning ) {
      QueryPerformanceCounter( &m_timeBegin );
      m_isRunning = true;
    }
  }

  void Stop() {
    if ( m_isRunning ) {
      QueryPerformanceCounter( &m_timeEnd );
      m_elapsedTime =
          ( m_timeEnd.QuadPart - m_timeBegin.QuadPart ) * 1000.0 / m_frequency;
      m_isRunning = false;
    }
  }

  void Restart() {
    Reset();
    Start();
  }

  void Reset() {
    m_isRunning = false;
    m_timeBegin.QuadPart = 0;
    m_timeEnd.QuadPart = 0;
    m_elapsedTime = 0;
  }

  double GetElapsedMilliseconds() {
    if ( m_isRunning ) {
      QueryPerformanceCounter( &m_timeEnd );
      return ( m_timeEnd.QuadPart - m_timeBegin.QuadPart ) * 1000.0 /
             m_frequency;
    }

    return m_elapsedTime;
  }

 private:
  LARGE_INTEGER m_timeBegin;
  LARGE_INTEGER m_timeEnd;
  double m_frequency;

  double m_elapsedTime;
  bool m_isRunning;
};
```

`GreyM/src/utils/string_utils.h`:

```h
#pragma once

#include <string>
#include <Windows.h>

namespace string_utils {

static std::string WideToAnsi( const std::wstring wide_string ) {
  std::string ansi_string;
  ansi_string.resize( wide_string.size() );

  char fail_convert_char_replacement = '?';

  WideCharToMultiByte( CP_ACP, 0, wide_string.c_str(), wide_string.size(),
                       ansi_string.data(),
                       ansi_string.size() * sizeof( std::string::value_type ),
                       &fail_convert_char_replacement, NULL );

  ansi_string.shrink_to_fit();

  return ansi_string;
}

}  // namespace string_utils
```

`GreyM/src/virtualizer/virtualizer.cpp`:

```cpp
#include "pch.h"
#include "virtualizer.h"
#include "../utils/shellcode.h"

namespace virtualizer {

/*
// Checks if operand is reg
bool IsOperandReg( const cs_x86_op& operand ) {
  return operand.type == x86_op_type::X86_OP_REG;
}
*/

// Checks if the operand is [immediate addr]
bool IsOperandMemoryImmediate( const cs_x86_op& operand ) {
  return operand.type == x86_op_type::X86_OP_MEM &&
         operand.mem.base == x86_reg::X86_REG_INVALID &&
         operand.mem.index == x86_reg::X86_REG_INVALID &&
         operand.mem.segment == x86_reg::X86_REG_INVALID &&
         operand.mem.disp != 0;
}

// Checks if the operand is [reg +- offset]
bool IsOperandMemoryRegOffset( const cs_x86_op& operand ) {
  return operand.type == x86_op_type::X86_OP_MEM &&
         operand.mem.segment == x86_reg::X86_REG_INVALID &&
         operand.mem.base != x86_reg::X86_REG_INVALID &&
         operand.mem.index == x86_reg::X86_REG_INVALID && operand.mem.disp != 0;
}

int GetVmRegisterOffsetFromX86Reg( const x86_reg reg ) {
  // The register variantes can be found on this link
  // https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/x64-architecture

  // Just checking to ensure there are not x64 registers when compiling in x86
#ifndef _WIN64
  switch ( reg ) {
    case x86_reg::X86_REG_RAX:
    case x86_reg::X86_REG_RBX:
    case x86_reg::X86_REG_RCX:
    case x86_reg::X86_REG_RDX:
    case x86_reg::X86_REG_RSI:
    case x86_reg::X86_REG_RDI:
    case x86_reg::X86_REG_RBP:
      assert( false );
    default:
      break;
  };
#endif

  switch ( reg ) {
    case x86_reg::X86_REG_RAX:
    case x86_reg::X86_REG_EAX:
    case x86_reg::X86_REG_AX:
    case x86_reg::X86_REG_AL:
      return offsetof( VmRegisters, eax );
    case x86_reg::X86_REG_RBX:
    case x86_reg::X86_REG_EBX:
    case x86_reg::X86_REG_BX:
    case x86_reg::X86_REG_BL:
      return offsetof( VmRegisters, ebx );
    case x86_reg::X86_REG_RCX:
    case x86_reg::X86_REG_ECX:
    case x86_reg::X86_REG_CX:
    case x86_reg::X86_REG_CL:
      return offsetof( VmRegisters, ecx );
    case x86_reg::X86_REG_RDX:
    case x86_reg::X86_REG_EDX:
    case x86_reg::X86_REG_DX:
    case x86_reg::X86_REG_DL:
      return offsetof( VmRegisters, edx );
    case x86_reg::X86_REG_RSI:
    case x86_reg::X86_REG_ESI:
    case x86_reg::X86_REG_SI:
    case x86_reg::X86_REG_SIL:
      return offsetof( VmRegisters, esi );
    case x86_reg::X86_REG_RDI:
    case x86_reg::X86_REG_EDI:
    case x86_reg::X86_REG_DI:
    case x86_reg::X86_REG_DIL:
      return offsetof( VmRegisters, edi );
    case x86_reg::X86_REG_RBP:
    case x86_reg::X86_REG_EBP:
    case x86_reg::X86_REG_BP:
    case x86_reg::X86_REG_BPL:
      return offsetof( VmRegisters, ebp );

#ifdef _WIN64
    case x86_reg::X86_REG_R15:
    case x86_reg::X86_REG_R15D:
    case x86_reg::X86_REG_R15W:
    case x86_reg::X86_REG_R15B:
      return offsetof( VmRegisters, r15 );
    case x86_reg::X86_REG_R14:
    case x86_reg::X86_REG_R14D:
    case x86_reg::X86_REG_R14W:
    case x86_reg::X86_REG_R14B:
      return offsetof( VmRegisters, r14 );
    case x86_reg::X86_REG_R13:
    case x86_reg::X86_REG_R13D:
    case x86_reg::X86_REG_R13W:
    case x86_reg::X86_REG_R13B:
      return offsetof( VmRegisters, r13 );
    case x86_reg::X86_REG_R12:
    case x86_reg::X86_REG_R12D:
    case x86_reg::X86_REG_R12W:
    case x86_reg::X86_REG_R12B:
      return offsetof( VmRegisters, r12 );
    case x86_reg::X86_REG_R11:
    case x86_reg::X86_REG_R11D:
    case x86_reg::X86_REG_R11W:
    case x86_reg::X86_REG_R11B:
      return offsetof( VmRegisters, r11 );
    case x86_reg::X86_REG_R10:
    case x86_reg::X86_REG_R10D:
    case x86_reg::X86_REG_R10W:
    case x86_reg::X86_REG_R10B:
      return offsetof( VmRegisters, r10 );
    case x86_reg::X86_REG_R9:
    case x86_reg::X86_REG_R9D:
    case x86_reg::X86_REG_R9W:
    case x86_reg::X86_REG_R9B:
      return offsetof( VmRegisters, r9 );
    case x86_reg::X86_REG_R8:
    case x86_reg::X86_REG_R8D:
    case x86_reg::X86_REG_R8W:
    case x86_reg::X86_REG_R8B:
      return offsetof( VmRegisters, r8 );
#endif
    default:
      break;
  }

  return -1;
}

VmRegister GetVmRegisterOffsetFromX86ImmediateReg( const cs_x86_op& operand ) {
  VmRegister vm_reg;
  vm_reg.register_offset = GetVmRegisterOffsetFromX86Reg( operand.reg );
  vm_reg.register_size = operand.size;
  return vm_reg;
}

VmRegister GetVmRegisterOffsetFromX86MemoryReg( const cs_x86_op& operand ) {
  VmRegister vm_reg;
  vm_reg.register_offset = GetVmRegisterOffsetFromX86Reg( operand.mem.base );
  vm_reg.register_size = operand.size;
  return vm_reg;
}

VmOpcodes GetVmOpcode( const cs_insn& instruction ) {
  const auto& operands = instruction.detail->x86.operands;

  VmOpcodes vm_opcode = VmOpcodes::NO_OPCODE;

  switch ( instruction.id ) {
    case x86_insn::X86_INS_MOV: {
      const auto& operand1 = operands[ 0 ];
      const auto& operand2 = operands[ 1 ];

      // If mov reg, x
      if ( operand1.type == x86_op_type::X86_OP_REG ) {
        // If mov reg, imm
        if ( operand2.type == x86_op_type::X86_OP_IMM ) {
          vm_opcode = VmOpcodes::MOV_REGISTER_IMMEDIATE;
        }
        // If mov reg, reg
        else if ( operand2.type == x86_op_type::X86_OP_REG ) {
          vm_opcode = VmOpcodes::MOV_REGISTER_REGISTER;
        }
        // If mov reg, [imm]
        else if ( IsOperandMemoryImmediate( operand2 ) ) {
          vm_opcode = VmOpcodes::MOV_REGISTER_MEMORY_IMMEDIATE;
        }
        // mov reg, [reg +- offset]
        else if ( IsOperandMemoryRegOffset( operand2 ) ) {
          vm_opcode = VmOpcodes::MOV_REGISTER_MEMORY_REG_OFFSET;
        }
      }
      // If mov x, reg
      else if ( operand2.type == x86_op_type::X86_OP_REG ) {
        // mov [reg +- offset], reg
        if ( IsOperandMemoryRegOffset( operand1 ) ) {
          vm_opcode = VmOpcodes::MOV_MEMORY_REG_OFFSET_REG;
        }
      }
      // mov x, imm
      else if ( operand2.type == x86_op_type::X86_OP_IMM ) {
        // mov [reg +- offset], imm
        if ( IsOperandMemoryRegOffset( operand1 ) ) {
          vm_opcode = VmOpcodes::MOV_MEMORY_REG_OFFSET_IMM;
        }
      }
    } break;

    case x86_insn::X86_INS_CALL: {
      const auto& operand1 = operands[ 0 ];

      // If call imm
      if ( operand1.type == X86_OP_IMM ) {
        vm_opcode = VmOpcodes::CALL_IMMEDIATE;
      }
      // if call [imm]
      else if ( IsOperandMemoryImmediate( operand1 ) ) {
        vm_opcode = VmOpcodes::CALL_MEMORY;
      }
      // if call [reg + imm]
      // this is the default for winapi calls on x64
      else if ( IsOperandMemoryRegOffset( operand1 ) ) {
        // Unique case for just the RIP relative calls, those are default on win32 api calls on x64
        if ( operand1.mem.base == x86_reg::X86_REG_RIP ) {
          vm_opcode = VmOpcodes::CALL_MEMORY_RIP_RELATIVE;
        }
      }
    } break;

      //// also changes eflags, read what they change and emulate them
      //// https://c9x.me/x86/html/file_module_x86_id_5.html
      // case x86_insn::X86_INS_ADD: {
      //} break;

      //// no flags are affected
      /// https://c9x.me/x86/html/file_module_x86_id_153.html
      // case x86_insn::X86_INS_LEA: {
      //} break;

    case x86_insn::X86_INS_PUSH: {
      const auto& operand1 = operands[ 0 ];

      if ( operand1.type == x86_op_type::X86_OP_IMM ) {
        vm_opcode = VmOpcodes::PUSH_IMM;
      } else if ( IsOperandMemoryRegOffset( operand1 ) ) {
        vm_opcode = VmOpcodes::PUSH_REGISTER_MEMORY_REG_OFFSET;
      }
    } break;

    case x86_insn::X86_INS_LEA: {
      const auto& operand1 = operands[ 0 ];
      const auto& operand2 = operands[ 1 ];

      if ( operand1.type == x86_op_type::X86_OP_REG &&
           IsOperandMemoryRegOffset( operand2 ) ) {
        if ( operand2.mem.base == x86_reg::X86_REG_RIP ) {
          vm_opcode = VmOpcodes::LEA_REG_MEMORY_IMMEDIATE_RIP_RELATIVE;
        }
      }
    } break;

      // NOTE: What type of jump is X86_INS_LJMP?
    case x86_insn::X86_INS_JMP: {
      const auto& operand1 = operands[ 0 ];

      // jmp imm
      if ( operand1.type == X86_OP_IMM ) {
        vm_opcode = VmOpcodes::JMP_IMM;
      }
    } break;

    default:
      break;
  }

  return vm_opcode;
}

bool IsVirtualizeable( const cs_insn& instruction, const VmOpcodes vm_opcode ) {
  // the instruction has to be bigger than a jmp
  if ( instruction.size < 5 ) {
    return false;
  }

  return vm_opcode != VmOpcodes::NO_OPCODE;
}

uintptr_t GetOperandMemoryValue( const cs_x86_op& operand,
                                 const bool relocated,
                                 const uintptr_t default_image_base ) {
  if ( relocated ) {
    return static_cast<uintptr_t>( operand.mem.disp ) - default_image_base;
  } else {
    return static_cast<uintptr_t>( operand.mem.disp );
  }
}

uintptr_t GetOperandImmediateValue( const cs_x86_op& operand,
                                    const bool relocated,
                                    const uintptr_t default_image_base ) {
  if ( relocated ) {
    return static_cast<uintptr_t>( operand.imm ) - default_image_base;
  } else {
    return static_cast<uintptr_t>( operand.imm );
  }
}

Shellcode CreateVirtualizedShellcode(
    const cs_insn& instruction,
    const VmOpcodes vm_opcode,
    const uint32_t vm_opcode_encyption_key,
    const std::vector<uintptr_t>& relocations_within_instruction,
    const uintptr_t default_image_base ) {
  Shellcode shellcode;

  assert( vm_opcode != VmOpcodes::NO_OPCODE );

  shellcode.AddValue<uint32_t>( static_cast<uint32_t>( vm_opcode ) ^
                                vm_opcode_encyption_key );

  const auto& operands = instruction.detail->x86.operands;

  int imm_count = 0;
  int mem_count = 0;

  for ( const auto& op : operands ) {
    if ( op.type == x86_op_type::X86_OP_IMM ) {
      imm_count++;
    } else if ( op.type == x86_op_type::X86_OP_MEM ) {
      mem_count++;
    }
  }

  // An instruction that has more than 1 type of the same operand is not
  // supported due to the relocation code I have added
  assert( imm_count < 2 );
  assert( mem_count < 2 );

  bool relocated_disp = false;
  bool relocated_imm = false;

  // The below code assumes that an instruction cannot have 2 immediate values
  // or 2 memory values
  for ( const auto relocation_rva : relocations_within_instruction ) {
    for ( const auto& op : operands ) {
      const auto& enc = instruction.detail->x86.encoding;

      const auto delta = relocation_rva - instruction.address;

      if ( delta == enc.disp_offset ) {
        // reg offset is being relocated
        relocated_disp = true;
      } else if ( delta == enc.imm_offset ) {
        // imm offset is being relocated
        relocated_imm = true;
      }
    }
  }

  // Add uint8_t RelocatedDisp 0/1
  shellcode.AddByte( static_cast<uint8_t>( relocated_disp ) );

  // Add uint8_t RelocatedImm 0/1
  shellcode.AddByte( static_cast<uint8_t>( relocated_imm ) );

  switch ( vm_opcode ) {
    case VmOpcodes::LEA_REG_MEMORY_IMMEDIATE_RIP_RELATIVE: {
      assert( operands[ 0 ].type == x86_op_type::X86_OP_REG &&
              operands[ 1 ].type == x86_op_type::X86_OP_MEM &&
              operands[ 1 ].mem.base == x86_reg::X86_REG_RIP );

#ifdef _WIN64
      // Ensure it is a qword on 64 bit, bcuz that is only what the interpreter can handle
      assert( operands[ 1 ].size == 8 );
#else
      // Ensure it is a dword on 32 bit, bcuz that is only what the interpreter can handle
      // call dword ptr ds:[0xF61008]
      assert( operands[ 1 ].size == 4 );
#endif

      // Ensure both of the operand sizes are the same
      assert( operands[ 0 ].size == operands[ 1 ].size );

      const auto vm_reg =
          GetVmRegisterOffsetFromX86ImmediateReg( operands[ 0 ] );

      if ( vm_reg.register_offset == -1 ) {
        return {};
      }

      // i do not handle relocations for this instruction yet
      assert( relocated_imm == false );
      assert( relocated_disp == false );

      shellcode.AddValue( vm_reg );

      const auto relative_data_addr = GetOperandMemoryValue(
          operands[ 1 ], relocated_disp, default_image_base );

      const auto rip = instruction.address;

      const auto abs_data_addr = relative_data_addr + instruction.size + rip;

      shellcode.AddValue<uintptr_t>( abs_data_addr );
    } break;

    case VmOpcodes::CALL_MEMORY_RIP_RELATIVE: {
      assert( operands[ 0 ].type == x86_op_type::X86_OP_MEM &&
              operands[ 0 ].mem.base == x86_reg::X86_REG_RIP );

#ifdef _WIN64
      // Ensure it is a qword on 64 bit, bcuz that is only what the interpreter can handle
      // call qword ptr ds:[0x00007FF648F61008]
      assert( operands[ 0 ].size == 8 );
#else
      // Ensure it is a dword on 32 bit, bcuz that is only what the interpreter can handle
      // call dword ptr ds:[0xF61008]
      assert( operands[ 0 ].size == 4 );
#endif

      /*
        The x64 rip relative addressing

        In x64 basic (win32) memory calls are rip relative. 
        Meaning that it is relative to the address the instrution lies on.
        Therefore I need to calculate the absolute call address relative to the image base

        I made the following equation with what values I had:
          abs_dest_call - rip = relative_call_addr + 6

        Turned into to get what I need:

          abs_dest_call = relative_call_addr + 6 + rip
      */

      const auto relative_call_addr = GetOperandMemoryValue(
          operands[ 0 ], relocated_disp, default_image_base );

      const auto rip = instruction.address;

      const auto abs_dest_call = relative_call_addr + instruction.size + rip;

      shellcode.AddValue<uintptr_t>( abs_dest_call );
    } break;

    case VmOpcodes::CALL_MEMORY: {
      assert( operands[ 0 ].type == x86_op_type::X86_OP_MEM );

#ifdef _WIN64
      // Ensure it is a qword on 64 bit, bcuz that is only what the interpreter can handle
      // call qword ptr ds:[0x00007FF648F61008]
      assert( operands[ 0 ].size == 8 );
#else
      // Ensure it is a dword on 32 bit, bcuz that is only what the interpreter can handle
      // call dword ptr ds:[0xF61008]
      assert( operands[ 0 ].size == 4 );
#endif

      const auto absolute_call_target_addr = GetOperandMemoryValue(
          operands[ 0 ], relocated_disp, default_image_base );

      shellcode.AddValue<uintptr_t>( absolute_call_target_addr );
    } break;

    case VmOpcodes::CALL_IMMEDIATE: {
      assert( operands[ 0 ].type == x86_op_type::X86_OP_IMM );

      const auto absolute_call_target_addr = GetOperandImmediateValue(
          operands[ 0 ], relocated_imm, default_image_base );

      shellcode.AddValue<uintptr_t>( absolute_call_target_addr );
    } break;

    case VmOpcodes::JMP_IMM: {
      assert( operands[ 0 ].type == x86_op_type::X86_OP_IMM );

      const auto absolute_jmp_target_addr = GetOperandImmediateValue(
          operands[ 0 ], relocated_imm, default_image_base );

      shellcode.AddValue<uintptr_t>( absolute_jmp_target_addr );
    } break;

    case VmOpcodes::MOV_REGISTER_MEMORY_IMMEDIATE: {
      assert( operands[ 0 ].type == x86_op_type::X86_OP_REG );
      assert( operands[ 1 ].type == x86_op_type::X86_OP_MEM );

      // Ensure both of the operand sizes are the same
      assert( operands[ 0 ].size == operands[ 1 ].size );

      auto vm_reg = GetVmRegisterOffsetFromX86ImmediateReg( operands[ 0 ] );

      // If the register is not supported, return empty
      if ( vm_reg.register_offset == -1 )
        return {};

      // Push the register index to the virtualized code
      shellcode.AddValue( vm_reg );

      shellcode.AddValue( GetOperandMemoryValue( operands[ 1 ], relocated_disp,
                                                 default_image_base ) );
    } break;

      // Example: mov ecx, dword ptr [eax + 0x43c140]
    case VmOpcodes::MOV_REGISTER_MEMORY_REG_OFFSET: {
      // reg value: mem.base
      // reg diff : mem.disp

      assert( operands[ 0 ].type == x86_op_type::X86_OP_REG );
      assert( operands[ 1 ].type == x86_op_type::X86_OP_MEM );

      // Ensure both of the operand sizes are the same
      assert( operands[ 0 ].size == operands[ 1 ].size );

      auto vm_reg_dest =
          GetVmRegisterOffsetFromX86ImmediateReg( operands[ 0 ] );

      // If the register is not supported, return empty
      if ( vm_reg_dest.register_offset == -1 )
        return {};

      const auto& operand2 = operands[ 1 ];

      const auto vm_reg_src = GetVmRegisterOffsetFromX86MemoryReg( operand2 );

      // If the register is not supported, return empty
      if ( vm_reg_src.register_offset == -1 )
        return {};

      auto reg_src_disp =
          GetOperandMemoryValue( operand2, relocated_disp, default_image_base );

      // Push the register offset to be changed to the virtualized code
      shellcode.AddValue( vm_reg_dest );

      // Push the reg offset
      shellcode.AddValue( vm_reg_src );

      // Push the reg disp offset
      shellcode.AddValue( reg_src_disp );
    } break;

    case VmOpcodes::MOV_REGISTER_REGISTER: {
      assert( operands[ 0 ].type == x86_op_type::X86_OP_REG );
      assert( operands[ 1 ].type == x86_op_type::X86_OP_REG );

      // Ensure both of the operand sizes are the same
      assert( operands[ 0 ].size == operands[ 1 ].size );

      const auto vm_reg_dest =
          GetVmRegisterOffsetFromX86ImmediateReg( operands[ 0 ] );
      const auto vm_reg_src =
          GetVmRegisterOffsetFromX86ImmediateReg( operands[ 1 ] );

      // If the register is not supported, return empty
      if ( vm_reg_dest.register_offset == -1 ||
           vm_reg_src.register_offset == -1 )
        return {};

      // Push the register index to the virtualized code
      shellcode.AddValue( vm_reg_dest );
      shellcode.AddValue( vm_reg_src );
    } break;

    case VmOpcodes::MOV_REGISTER_IMMEDIATE: {
      assert( operands[ 0 ].type == x86_op_type::X86_OP_REG );
      assert( operands[ 1 ].type == x86_op_type::X86_OP_IMM );

      // Ensure both of the operand sizes are the same
      assert( operands[ 0 ].size == operands[ 1 ].size );

      if ( operands[ 0 ].size == 1 || operands[ 0 ].size == 2 ||
           operands[ 0 ].size == 8 )
        return {};

      const auto vm_reg =
          GetVmRegisterOffsetFromX86ImmediateReg( operands[ 0 ] );

      // If the register is not supported, return empty
      if ( vm_reg.register_offset == -1 )
        return {};

      // Push the register index to the virtualized code
      shellcode.AddValue( vm_reg );
      shellcode.AddValue( GetOperandImmediateValue(
          operands[ 1 ], relocated_imm, default_image_base ) );
    } break;

      // Example: mov dword ptr [eax + 0x43c50c], ecx
    case VmOpcodes::MOV_MEMORY_REG_OFFSET_REG: {
      assert( operands[ 0 ].type == x86_op_type::X86_OP_MEM );
      assert( operands[ 1 ].type == x86_op_type::X86_OP_REG );

      // Ensure both of the operand sizes are the same
      assert( operands[ 0 ].size == operands[ 1 ].size );

      const auto& dest_operand1 = operands[ 0 ];
      const auto& src_operand2 = operands[ 1 ];

      const auto vm_reg_dest =
          GetVmRegisterOffsetFromX86MemoryReg( dest_operand1 );
      const auto vm_reg_src =
          GetVmRegisterOffsetFromX86ImmediateReg( src_operand2 );

      // If the register is not supported, return empty
      if ( vm_reg_dest.register_offset == -1 ||
           vm_reg_src.register_offset == -1 )
        return {};

      // Push the register offset to be changed to the virtualized code
      shellcode.AddValue( vm_reg_dest );

      // Push the source reg offset
      shellcode.AddValue( vm_reg_src );

      // Push the reg disp offset
      shellcode.AddValue( GetOperandMemoryValue( dest_operand1, relocated_disp,
                                                 default_image_base ) );
    } break;

    case VmOpcodes::MOV_MEMORY_REG_OFFSET_IMM: {
      assert( operands[ 0 ].type == x86_op_type::X86_OP_MEM );
      assert( operands[ 1 ].type == x86_op_type::X86_OP_IMM );

      // Ensure both of the operand sizes are the same
      assert( operands[ 0 ].size == operands[ 1 ].size );

      //assert( operands[ 0 ].size == 8 );

      const auto& dest_operand1 = operands[ 0 ];
      const auto& src_operand2 = operands[ 1 ];

      const auto vm_reg_dest =
          GetVmRegisterOffsetFromX86MemoryReg( dest_operand1 );

      // If the register is not supported, return empty
      if ( vm_reg_dest.register_offset == -1 )
        return {};

      // Both cannot be relocated at the same time, if so,
      // modify the interpreter simply call if for both instead of else if
      assert( !( relocated_imm && relocated_disp ) );

      shellcode.AddValue( vm_reg_dest );

      shellcode.AddValue( GetOperandImmediateValue( src_operand2, relocated_imm,
                                                    default_image_base ) );

      shellcode.AddValue( GetOperandMemoryValue( dest_operand1, relocated_disp,
                                                 default_image_base ) );

// On x86, we do not support operand sizes of 8
#ifndef _WIN64
      // NOTE: On mov instruction we support all sizes on both x86 and x64
      // REMOVE THIS ASSERT WHEN IN OCCURS TO DETERMINE IF ISSUES ARE FOUND

      // Currently only support these 3 sizes
      assert( dest_operand1.size == 1 || dest_operand1.size == 2 ||
              dest_operand1.size == 4 );

      // qword is currently not supported, if this assert sets off, consider supporting it
      assert( dest_operand1.size != 8 );
#endif
    } break;

    case VmOpcodes::PUSH_IMM: {
      assert( operands[ 0 ].type == x86_op_type::X86_OP_IMM );

#ifdef _WIN64
      // Ensure it is a qword on 64 bit, bcuz that is only what the interpreter can handle atm
      assert( operands[ 0 ].size == 8 );
#else
      // Ensure it is a dword on 32 bit, bcuz that is only what the interpreter can handle atm
      assert( operands[ 0 ].size == 4 );
#endif

      shellcode.AddValue( GetOperandImmediateValue(
          operands[ 0 ], relocated_imm, default_image_base ) );
    } break;

    case VmOpcodes::PUSH_REGISTER_MEMORY_REG_OFFSET: {
      assert( operands[ 0 ].type == x86_op_type::X86_OP_MEM );

#ifdef _WIN64
      // Ensure it is a qword on 64 bit, bcuz that is only what the interpreter can handle atm
      assert( operands[ 0 ].size == 8 );
#else
      // Ensure it is a dword on 32 bit, bcuz that is only what the interpreter can handle atm
      assert( operands[ 0 ].size == 4 );
#endif

      const auto& operand1 = operands[ 0 ];

      const auto vm_reg_dest = GetVmRegisterOffsetFromX86MemoryReg( operand1 );

      // If the register is not supported, return empty
      if ( vm_reg_dest.register_offset == -1 )
        return {};

      // Push the register offset to be changed to the virtualized code
      shellcode.AddValue( vm_reg_dest );

      // Push the reg disp offset
      shellcode.AddValue( GetOperandMemoryValue( operand1, relocated_disp,
                                                 default_image_base ) );
    } break;

    default:
      break;
  }

#ifndef _WIN64
  // On x86, the interpreter does not properly handle reading sizes larger than 4 due to using uintptr_t when reading
  for ( int i = 0; i < instruction.detail->x86.op_count; ++i ) {
    assert( instruction.detail->x86.operands[ i ].size <= 4 );
  }
#endif

  return shellcode;
}

Shellcode GetX86LoaderShellcodeForVirtualizedCode(
    const cs_insn& instruction,
    const VmOpcodes vm_opcode,
    const uintptr_t image_base ) {
  /*
      It is very important that we do not access data outside the actual stack, if an interrupt 
      occurs that the wrong moment, the data outside the stack can become corrupt.

      NOTE: The following code does not modify the E/RFLAGS as the previous iteration did

      Before Interpreter
        pushfd 
        push eax
        push ebx
        push ecx
        push edx
        push ebp
        push esi
        push edi
        sub esp,C8
        push esp
        add dword ptr ss:[esp],C8
        sub esp,100
        push test executable out.3F0000
        push 58B1
        push esp
        push C993A
        call test executable out.4394D0
        add esp,100
        pop esp
        pop edi
        pop esi
        pop ebp
        pop edx
        pop ecx
        pop ebx
        pop eax
        popfd 
        jmp test executable out.43937B

      Call:
        We are pushing the destination address 2 times from the interpreter
        
        push eax                <-- Save eax because we use it
        call 0                  <-- Push the current eip to the stack
        pop eax                 <-- Read the pushed eip into eax
        lea eax, [eax + 0xA]    <-- Same as add eax, 0xA
        mov [esp + 0x8], eax    <-- Move return address into proper space on stack
        pop eax               
        ret                     <-- Jump to destination call

      Jmp:
        Simply RET immediately because we push the destination to the real stack from the interpreter
  */

  Shellcode shellcode;

  //shellcode.Reserve( 100 );

  // pushfd
  shellcode.AddByte( 0x9C );
  // push eax
  shellcode.AddByte( 0x50 );
  // push ebx
  shellcode.AddByte( 0x53 );
  // push ecx
  shellcode.AddByte( 0x51 );
  // push edx
  shellcode.AddByte( 0x52 );
  // push ebp
  shellcode.AddByte( 0x55 );
  // push esi
  shellcode.AddByte( 0x56 );
  // push edi
  shellcode.AddByte( 0x57 );

  // sub esp, 200 (MAX_PUSHES * sizeof(uint32_t))
  shellcode.AddBytes( { 0x81, 0xEC, 0xC8, 0x00, 0x00, 0x00 } );

  // push esp
  shellcode.AddByte( 0x54 );

  // add dword ptr [esp], 0x200
  shellcode.AddBytes( { 0x81, 0x04, 0x24, 0xC8, 0x00, 0x00, 0x00 } );

  // sub rsp, 0x100
  shellcode.AddBytes( { 0x81, 0xEC, 0x00, 0x01, 0x00, 0x00 } );

  // push the address to .vmvar section
  // push
  shellcode.AddByte( 0x68 );
  shellcode.AddVariable<uint32_t>( image_base, ImageBaseVariable );

  // push current eip
  // push
  shellcode.AddByte( 0x68 );
  shellcode.AddVariable<uint32_t>( 0, VmOpcodeEncryptionKeyVariable );

  // push esp
  shellcode.AddByte( 0x54 );

  // push
  shellcode.AddByte( 0x68 );
  shellcode.AddVariable( 0, VmCodeAddrVariable );

  // call
  shellcode.AddByte( 0xE8 );
  shellcode.AddVariable( 0, VmCoreFunctionVariable );

  // add rsp, 0x100
  shellcode.AddBytes( { 0x81, 0xC4, 0x00, 0x01, 0x00, 0x00 } );

  // pop esp
  shellcode.AddByte( 0x5C );

  // pop edi
  shellcode.AddByte( 0x5F );
  // pop esi
  shellcode.AddByte( 0x5E );
  // pop ebp
  shellcode.AddByte( 0x5D );
  // pop edx
  shellcode.AddByte( 0x5A );
  // pop ecx
  shellcode.AddByte( 0x59 );
  // pop ebx
  shellcode.AddByte( 0x5B );
  // pop eax
  shellcode.AddByte( 0x58 );

  // popfd
  shellcode.AddByte( 0x9D );

  if ( vm_opcode == VmOpcodes::CALL_IMMEDIATE ) {
    // push eax
    shellcode.AddByte( 0x50 );

    // call 0
    shellcode.AddBytes( { 0xE8, 0x00, 0x00, 0x00, 0x00 } );

    // pop eax
    shellcode.AddByte( 0x58 );

    // lea eax, ds:[eax+0xA]
    shellcode.AddBytes( { 0x8D, 0x40, 0x0A } );

    // mov dword ptr ss:[esp+0x8], eax
    shellcode.AddBytes( { 0x89, 0x44, 0x24, 0x08 } );

    // pop eax
    shellcode.AddByte( 0x58 );

    // ret
    shellcode.AddByte( 0xC3 );
  } else if ( vm_opcode == VmOpcodes::CALL_MEMORY ) {
    // push eax
    shellcode.AddByte( 0x50 );

    // call 0
    shellcode.AddBytes( { 0xE8, 0x00, 0x00, 0x00, 0x00 } );

    // pop eax
    shellcode.AddByte( 0x58 );

    // lea eax, ds:[eax+0xA]
    shellcode.AddBytes( { 0x8D, 0x40, 0x0A } );

    // mov dword ptr ss:[esp+0x8], eax
    shellcode.AddBytes( { 0x89, 0x44, 0x24, 0x08 } );

    // pop eax
    shellcode.AddByte( 0x58 );

    // ret
    shellcode.AddByte( 0xC3 );
  } else if ( vm_opcode == VmOpcodes::JMP_IMM ) {
    // ret
    shellcode.AddByte( 0xC3 );
  }

  // jmp
  shellcode.AddByte( 0xE9 );
  shellcode.AddVariable( 0, OrigAddrVariable );

  return shellcode;
}

Shellcode GetX64LoaderShellcodeForVirtualizedCode( const cs_insn& instruction,
                                                   const VmOpcodes vm_opcode,
                                                   const uint64_t image_base ) {
  /*
      It is very important that we do not access data outside the actual stack, if an interrupt 
      occurs that the wrong moment, the data outside the stack can become corrupt.

      NOTE: The following code does not modify the E/RFLAGS as the previous iteration did

      Previous method to save XMM register (push xmm7):
        sub rsp, 0x10
        movdqu xmmword ptr ss:[rsp], xmm7

      Before Interpreter:
        pushfq 
        push rax
        push rbx
        push rcx
        push rdx
        push rbp
        push rsi
        push rdi
        sub rsp,80
        movdqu xmmword ptr ss:[rsp+70],xmm7
        movdqu xmmword ptr ss:[rsp+60],xmm6
        movdqu xmmword ptr ss:[rsp+50],xmm5
        movdqu xmmword ptr ss:[rsp+40],xmm4
        movdqu xmmword ptr ss:[rsp+30],xmm3
        movdqu xmmword ptr ss:[rsp+20],xmm2
        movdqu xmmword ptr ss:[rsp+10],xmm1
        movdqu xmmword ptr ss:[rsp],xmm0
        push r8
        push r9
        push r10
        push r11
        push r12
        push r13
        push r14
        push r15
        sub rsp,C8                                <-- Allocate extra stack incase we push values onto the stack
        push rsp
        add dword ptr ss:[rsp],C8
                                                      Allocate stack space for the function call, 
        sub rsp,100                               <-- the stack space depends on how many arguments 
                                                      the call has in this case it has 4, so i dont know
        mov r9, Imagebase                         <-- 4th Argument Image Base
        mov r8d,7A0F                              <-- 3rd Argument Xor Key
        mov rdx,rsp                               <-- 2nd Argument RSP
        mov rcx,437686A                           <-- 1st Argument VmCodeAddress
        call VmInterpreter
        add rsp,100                               <-- Free stack that was allocated before function call
        pop rsp
        pop r15
        pop r14
        pop r13
        pop r12
        pop r11
        pop r10
        pop r9
        pop r8
        movdqu xmm0,xmmword ptr ss:[rsp]
        movdqu xmm1,xmmword ptr ss:[rsp+10]
        movdqu xmm2,xmmword ptr ss:[rsp+20]
        movdqu xmm3,xmmword ptr ss:[rsp+30]
        movdqu xmm4,xmmword ptr ss:[rsp+40]
        movdqu xmm5,xmmword ptr ss:[rsp+50]
        movdqu xmm6,xmmword ptr ss:[rsp+60]
        movdqu xmm7,xmmword ptr ss:[rsp+70]
        add rsp,80
        pop rdi
        pop rsi
        pop rbp
        pop rdx
        pop rcx
        pop rbx
        pop rax
        popfq 
        jmp test executable out.7FF71E5386AD      <-- Jump back to the next instruction of the original code

      Call:
        We are pushing the destination address 2 times from the interpreter

        OLD WAY (UNOPTIMIZED):

        pushfq                    <-- Save RFLAGS because add ?, ? modifies them
        push rax                  <-- Save RAX because we use it
        call 0                    <-- Push RIP
        add qword [rsp], 0x15     <-- Add 0x15 to the RIP
        mov rax, qword [rsp]      <-- Save the return address in RAX
        mov qword[rsp+0x20], rax  <-- Move the return address into the second pushed stack values
        add rsp, 8                <-- Remove the RIP we pushed from call earlier
        pop rax
        popfq
        ret                       <-- Call the real function

        NEW WAY (OPTIMIZED):

        push rax
        lea rax, [rip + 0x7]      <-- Move the return address into rax
        mov [rsp + 0x10], rax   <-- Move return address into proper space on stack
        pop rax
        ret

      Jmp:
        Simply RET immediately because we push the destination to the real stack from the interpreter
  */

  Shellcode shellcode;

  // shellcode.Reserve( 100 );

  // pushfd
  shellcode.AddByte( 0x9C );
  // push rax
  shellcode.AddByte( 0x50 );
  // push rbx
  shellcode.AddByte( 0x53 );
  // push rcx
  shellcode.AddByte( 0x51 );
  // push rdx
  shellcode.AddByte( 0x52 );
  // push rbp
  shellcode.AddByte( 0x55 );
  // push rsi
  shellcode.AddByte( 0x56 );
  // push rdi
  shellcode.AddByte( 0x57 );

  // sub rsp, 0x80
  shellcode.AddBytes( { 0x48, 0x81, 0xEC, 0x80, 0x00, 0x00, 0x00 } );

  // movdqu xmmword ptr ss:[rsp+0x70], xmm7
  shellcode.AddBytes( { 0xF3, 0x0F, 0x7F, 0x7C, 0x24, 0x70 } );

  // movdqu xmmword ptr ss:[rsp+0x60], xmm6
  shellcode.AddBytes( { 0xF3, 0x0F, 0x7F, 0x74, 0x24, 0x60 } );

  // movdqu xmmword ptr ss:[rsp+0x50], xmm5
  shellcode.AddBytes( { 0xF3, 0x0F, 0x7F, 0x6C, 0x24, 0x50 } );

  // movdqu xmmword ptr ss:[rsp+0x40], xmm4
  shellcode.AddBytes( { 0xF3, 0x0F, 0x7F, 0x64, 0x24, 0x40 } );

  // movdqu xmmword ptr ss:[rsp+0x30], xmm3
  shellcode.AddBytes( { 0xF3, 0x0F, 0x7F, 0x5C, 0x24, 0x30 } );

  // movdqu xmmword ptr ss:[rsp+0x20], xmm2
  shellcode.AddBytes( { 0xF3, 0x0F, 0x7F, 0x54, 0x24, 0x20 } );

  // movdqu xmmword ptr ss:[rsp+0x10], xmm1
  shellcode.AddBytes( { 0xF3, 0x0F, 0x7F, 0x4C, 0x24, 0x10 } );

  // movdqu xmmword ptr ss:[rsp], xmm0
  shellcode.AddBytes( { 0xF3, 0x0F, 0x7F, 0x04, 0x24 } );

  // push r8
  shellcode.AddBytes( { 0x41, 0x50 } );
  // push r9
  shellcode.AddBytes( { 0x41, 0x51 } );
  // push r10
  shellcode.AddBytes( { 0x41, 0x52 } );
  // push r11
  shellcode.AddBytes( { 0x41, 0x53 } );
  // push r12
  shellcode.AddBytes( { 0x41, 0x54 } );
  // push r13
  shellcode.AddBytes( { 0x41, 0x55 } );
  // push r14
  shellcode.AddBytes( { 0x41, 0x56 } );
  // push r15
  shellcode.AddBytes( { 0x41, 0x57 } );

  // sub rsp, 200 (MAX_PUSHES * sizeof(uint32_t))
  shellcode.AddBytes( { 0x48, 0x81, 0xEC, 0xC8, 0x00, 0x00, 0x00 } );

  // push rsp
  shellcode.AddByte( 0x54 );

  // add dword ptr [rsp], 0xC8
  shellcode.AddBytes( { 0x81, 0x04, 0x24, 0xC8, 0x00, 0x00, 0x00 } );

  // sub rsp, 0x100
  shellcode.AddBytes( { 0x48, 0x81, 0xEC, 0x00, 0x01, 0x00, 0x00 } );

  // mov r9, Imagebase
  shellcode.AddBytes( { 0x49, 0xB9 } );
  shellcode.AddVariable<uint64_t>( image_base, ImageBaseVariable );

  // mov r8, 4 byte variabe (3rd argument)
  shellcode.AddBytes( { 0x41, 0xB8 } );
  shellcode.AddVariable<uint32_t>( 0, VmOpcodeEncryptionKeyVariable );

  // mov rdx, rsp (2nd argument)
  shellcode.AddBytes( { 0x48, 0x8B, 0xD4 } );

  // mov rcx, 8bytes
  shellcode.AddBytes( { 0x48, 0xB9 } );
  shellcode.AddVariable<uint64_t>( 0, VmCodeAddrVariable );

  // call
  shellcode.AddByte( 0xE8 );
  shellcode.AddVariable( 0, VmCoreFunctionVariable );

  // add rsp, 0x100
  shellcode.AddBytes( { 0x48, 0x81, 0xC4, 0x00, 0x01, 0x00, 0x00 } );

  // pop esp
  shellcode.AddByte( 0x5C );

  // pop r15
  shellcode.AddBytes( { 0x41, 0x5F } );
  // pop r14
  shellcode.AddBytes( { 0x41, 0x5E } );
  // pop r13
  shellcode.AddBytes( { 0x41, 0x5D } );
  // pop r12
  shellcode.AddBytes( { 0x41, 0x5C } );
  // pop r11
  shellcode.AddBytes( { 0x41, 0x5B } );
  // pop r10
  shellcode.AddBytes( { 0x41, 0x5A } );
  // pop r9
  shellcode.AddBytes( { 0x41, 0x59 } );
  // pop r8
  shellcode.AddBytes( { 0x41, 0x58 } );

  // movdqu xmm0, xmmword ptr ss:[rsp]
  shellcode.AddBytes( { 0xF3, 0x0F, 0x6F, 0x04, 0x24 } );

  // movdqu xmm1, xmmword ptr ss:[rsp+0x10]
  shellcode.AddBytes( { 0xF3, 0x0F, 0x6F, 0x4C, 0x24, 0x10 } );

  // movdqu xmm2, xmmword ptr ss:[rsp+0x20]
  shellcode.AddBytes( { 0xF3, 0x0F, 0x6F, 0x54, 0x24, 0x20 } );

  // movdqu xmm3, xmmword ptr ss:[rsp+0x30]
  shellcode.AddBytes( { 0xF3, 0x0F, 0x6F, 0x5C, 0x24, 0x30 } );

  // movdqu xmm4, xmmword ptr ss:[rsp+0x40]
  shellcode.AddBytes( { 0xF3, 0x0F, 0x6F, 0x64, 0x24, 0x40 } );

  // movdqu xmm5, xmmword ptr ss:[rsp+0x50]
  shellcode.AddBytes( { 0xF3, 0x0F, 0x6F, 0x6C, 0x24, 0x50 } );

  // movdqu xmm6, xmmword ptr ss:[rsp+0x60]
  shellcode.AddBytes( { 0xF3, 0x0F, 0x6F, 0x74, 0x24, 0x60 } );

  // movdqu xmm7, xmmword ptr ss:[rsp+0x70]
  shellcode.AddBytes( { 0xF3, 0x0F, 0x6F, 0x7C, 0x24, 0x70 } );

  // add rsp, 0x80
  shellcode.AddBytes( { 0x48, 0x81, 0xC4, 0x80, 0x00, 0x00, 0x00 } );

  // pop edi
  shellcode.AddByte( 0x5F );
  // pop esi
  shellcode.AddByte( 0x5E );
  // pop ebp
  shellcode.AddByte( 0x5D );
  // pop edx
  shellcode.AddByte( 0x5A );
  // pop ecx
  shellcode.AddByte( 0x59 );
  // pop ebx
  shellcode.AddByte( 0x5B );
  // pop eax
  shellcode.AddByte( 0x58 );
  // popfd
  shellcode.AddByte( 0x9D );

  if ( vm_opcode == VmOpcodes::CALL_IMMEDIATE ) {
    // push rax
    shellcode.AddByte( 0x50 );

    // lea rax, [rip + 0x7]
    shellcode.AddBytes( { 0x48, 0x8D, 0x05, 0x07, 0x00, 0x00, 0x00 } );

    // mov qword ptr ss:[rsp+0x10], rax
    shellcode.AddBytes( { 0x48, 0x89, 0x44, 0x24, 0x10 } );

    // pop rax
    shellcode.AddByte( 0x58 );

    // ret
    shellcode.AddByte( 0xC3 );

  } else if ( vm_opcode == VmOpcodes::CALL_MEMORY ) {
    // push rax
    shellcode.AddByte( 0x50 );

    // lea rax, [rip + 0x7]
    shellcode.AddBytes( { 0x48, 0x8D, 0x05, 0x07, 0x00, 0x00, 0x00 } );

    // mov qword ptr ss:[rsp+0x10], rax
    shellcode.AddBytes( { 0x48, 0x89, 0x44, 0x24, 0x10 } );

    // pop rax
    shellcode.AddByte( 0x58 );

    // ret
    shellcode.AddByte( 0xC3 );
  } else if ( vm_opcode == VmOpcodes::CALL_MEMORY_RIP_RELATIVE ) {
    // push rax
    shellcode.AddByte( 0x50 );

    // lea rax, [rip + 0x7]
    shellcode.AddBytes( { 0x48, 0x8D, 0x05, 0x07, 0x00, 0x00, 0x00 } );

    // mov qword ptr ss:[rsp+0x10], rax
    shellcode.AddBytes( { 0x48, 0x89, 0x44, 0x24, 0x10 } );

    // pop rax
    shellcode.AddByte( 0x58 );

    // ret
    shellcode.AddByte( 0xC3 );
  } else if ( vm_opcode == VmOpcodes::JMP_IMM ) {
    // The interpreter simply pushes the jump destination
    // to the stack and we simply ret to it

    // ret
    shellcode.AddByte( 0xC3 );
  }

  // jmp
  shellcode.AddByte( 0xE9 );
  shellcode.AddVariable( 0, OrigAddrVariable );

  return shellcode;
}

Shellcode GetLoaderShellcodeForVirtualizedCode( const cs_insn& instruction,
                                                const VmOpcodes vm_opcode,
                                                const uintptr_t image_base ) {
#ifdef _WIN64
  return GetX64LoaderShellcodeForVirtualizedCode( instruction, vm_opcode,
                                                  image_base );
#else
  return GetX86LoaderShellcodeForVirtualizedCode( instruction, vm_opcode,
                                                  image_base );
#endif
}

}  // namespace virtualizer
```

`GreyM/src/virtualizer/virtualizer.h`:

```h
#pragma once

#include "../../Interpreter/src/main.h"

class Shellcode;

const std::wstring VmOpcodeEncryptionKeyVariable =
    TEXT( "VmOpcodeEncryptionKey" );

const std::wstring VmCodeAddrVariable = TEXT( "VmCodeAddr" );

const std::wstring ImageBaseVariable = TEXT( "ImageBase" );

const std::wstring OrigAddrVariable = TEXT( "OrigAddr" );

const std::wstring VmCoreFunctionVariable = TEXT( "VmCoreFunction" );

namespace virtualizer {

bool IsVirtualizeable( const cs_insn& instruction, const VmOpcodes vm_opcode );
VmOpcodes GetVmOpcode( const cs_insn& instruction );

Shellcode CreateVirtualizedShellcode(
    const cs_insn& instruction,
    const VmOpcodes vm_opcode,
    const uint32_t vm_opcode_encyption_key,
    const std::vector<uintptr_t>& relocations_within_instruction, const uintptr_t default_image_base );

Shellcode GetLoaderShellcodeForVirtualizedCode( const cs_insn& instruction,
                                                const VmOpcodes vm_opcode,
                                                const uintptr_t image_base );

}  // namespace virtualizer
```

`Interpreter/Exports.def`:

```def
LIBRARY

EXPORTS
	
	VmInterpreter
	FirstTlsCallback
	SecondTlsCallback
	BeforeEntrypoint
```

`Interpreter/Interpreter.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\main.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{b2f54070-abc0-400a-8fac-a75098e7253f}</ProjectGuid>
    <RootNamespace>Interpreter</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)$(ProjectName)\intermediates\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)$(ProjectName)\intermediates\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)$(ProjectName)\intermediates\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)$(ProjectName)\intermediates\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <SupportJustMyCode>false</SupportJustMyCode>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
    </ClCompile>
    <Link>
      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <ModuleDefinitionFile>Exports.def</ModuleDefinitionFile>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <SupportJustMyCode>false</SupportJustMyCode>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
    </ClCompile>
    <Link>
      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <ModuleDefinitionFile>Exports.def</ModuleDefinitionFile>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <ModuleDefinitionFile>Exports.def</ModuleDefinitionFile>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
      <IntrinsicFunctions>true</IntrinsicFunctions>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <ModuleDefinitionFile>Exports.def</ModuleDefinitionFile>
      <ImageHasSafeExceptionHandlers>false</ImageHasSafeExceptionHandlers>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Interpreter/Interpreter.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\main.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Interpreter/src/main.cpp`:

```cpp
/*
  Visual Studio Project Settings

  JUST MY CODE: NO
  SECURITY CHECK: NO
  SAFE EXCEPTION HANDLER: NO
  BASIC RUNTIME CHECKS: DEFAULT
  ENABLED ENHANCED INSTRUCTION SET: IA32 (required to avoid interpreter from
                                          using SSE2, then we would need to save the XMM registers)

  Debug Version has limitations because it e.g. always initializes variables to zero.
  With arrays, it does so with a memcpy function located in the .text section.
  Meaning that when I virtualize my TLS callbacks, it tried to virtualize a call that 
  is not located in the section and crashes.

  Protect with SEC_NO_CHANGE, then look if CreateSection was hooked or somehow
  did not succeed by trying to manipulate the protected memory. If an error
  occured while trying to change memory protection, then we're good.
  // Look at this possible to thing detect protectino changes:
  https://stackoverflow.com/questions/8004945/how-to-catch-a-memory-write-and-call-function-with-address-of-write
*/

#include <Windows.h>
#include <cstdint>
#include <stdio.h>

#include "main.h"

#pragma code_seg( VM_FUNCTIONS_SECTION_NAME )

using LoadLibraryA_t = decltype( &LoadLibraryA );
using GetProcAddress_t = decltype( &GetProcAddress );
using VirtualProtect_t = decltype( &VirtualProtect );
using VirtualAlloc_t = decltype( &VirtualAlloc );
using DbgUiRemoteBreakin_t = VOID ( * )();
using DbgBreakPoint_t = VOID ( * )();
using CreateFileW_t = decltype( &CreateFileW );
using CloseHandle_t = decltype( &CloseHandle );
using CreateFileMappingA_t = decltype( &CreateFileMappingA );
using MapViewOfFile_t = decltype( &MapViewOfFile );
using UnmapViewOfFile_t = decltype( &UnmapViewOfFile );
using SetFilePointer_t = decltype( &SetFilePointer );

struct Modules {
  uintptr_t ntdll;
  uintptr_t kernel32;
};

struct ApiAddresses {
  LoadLibraryA_t LoadLibraryA;
  GetProcAddress_t GetProcAddress;
  VirtualProtect_t VirtualProtect;
  VirtualAlloc_t VirtualAlloc;
  DbgUiRemoteBreakin_t DbgUiRemoteBreakin;
  DbgBreakPoint_t DbgBreakPoint;
  CreateFileW_t CreateFileW;
  CloseHandle_t CloseHandle;
  CreateFileMappingA_t CreateFileMappingA;
  MapViewOfFile_t MapViewOfFile;
  UnmapViewOfFile_t UnmapViewOfFile;
  SetFilePointer_t SetFilePointer;
};

IMAGE_NT_HEADERS* GetNtHeaders( const PVOID base ) {
  auto dos_header = reinterpret_cast<IMAGE_DOS_HEADER*>( base );
  auto nt_header = reinterpret_cast<IMAGE_NT_HEADERS*>(
      reinterpret_cast<uint8_t*>( dos_header ) + dos_header->e_lfanew );
  return nt_header;
}

void FixNextCorruptedTlsCallback(
    PVOID dll_base,
    const VmCodeSectionData& vm_code_section_data ) {
  const auto base_addr = reinterpret_cast<uintptr_t>( dll_base );

  auto nt_headers = GetNtHeaders( dll_base );

  auto tls_data_directory =
      &nt_headers->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_TLS ];

  if ( tls_data_directory->Size != 0 ) {
    auto tls_directory = reinterpret_cast<IMAGE_TLS_DIRECTORY*>(
        base_addr + tls_data_directory->VirtualAddress );
    // In the function AddTlsCallbacks() I always add my TLS callbacks as the two last ones
    // The last TLS callback is the one we will "decrypt"
    auto callback_list =
        reinterpret_cast<uintptr_t*>( tls_directory->AddressOfCallBacks );

    uintptr_t* last_tls_callback = 0;

    for ( ; *callback_list; callback_list++ ) {
      last_tls_callback = callback_list;
    }

    // TODO: Consider using a better solution to fix the corrupted tls callback
    // E.g. XOR the value to decrypt it
    *last_tls_callback -= vm_code_section_data.second_tls_callback_modifier;
  }
}

// A basic hash function to bypass usage of string
constexpr uintptr_t HashString( const char* s ) {
  return *s ? static_cast<uintptr_t>( *s ) + 653119926 * HashString( s + 1 )
            : 75438945;
}

constexpr uintptr_t HashStringBuffer( const char* s, const int size ) {
  return size != 0 ? static_cast<uintptr_t>( *s ) +
                         653119926 * HashStringBuffer( s + 1, size - 1 )
                   : 75438945;
}

// A basic hash function to bypass usage of string
constexpr uintptr_t HashWideString( const wchar_t* s ) {
  return *s ? static_cast<uintptr_t>( *s ) + 653119926 * HashWideString( s + 1 )
            : 75438945;
}

constexpr wchar_t ToLowerConstexpr( wchar_t c ) {
  if ( c >= 'A' && c <= 'Z' ) {
    return 'a' + c - 'A';
  }

  return c;
}

/*
constexpr char ToLowerConstexpr( char c ) {
  if ( c >= 'A' && c <= 'Z' ) {
    return 'a' + c - 'A';
  }

  return c;
}
*/

constexpr uintptr_t HashWideStringLowercase( const wchar_t* s ) {
  return *s ? static_cast<uintptr_t>( ToLowerConstexpr( *s ) ) +
                  653119926 * HashWideStringLowercase( s + 1 )
            : 75438945;
}

constexpr uintptr_t HashWideStringLowercase( const wchar_t* s,
                                             const int size ) {
  return size != 0 ? static_cast<uintptr_t>( ToLowerConstexpr( *s ) ) +
                         653119926 * HashWideStringLowercase( s + 1, size - 1 )
                   : 75438945;
}

const PEB* GetCurrentPeb() {
#if defined( _WIN64 )
  uintptr_t peb_addr = __readgsqword( 0x60 );
#else
  uintptr_t peb_addr = __readfsdword( 0x30 );
#endif
  return reinterpret_cast<const PEB*>( peb_addr );
}

/*
wchar_t ToLower( wchar_t c ) {
  if ( c >= 'A' && c <= 'Z' ) {
    return 'a' + c - 'A';
  }

  return c;
}

void WideToLower( wchar_t* s, wchar_t* buf_out ) {
  for ( ; *s; ++s, ++buf_out ) {
    *buf_out = ToLower( *s );
  }
}

void MemorySet( uint8_t* src, int size, uint8_t value ) {
  for ( int i = 0; i < size; ++i ) {
    *src = value;
    ++src;
  }
}
*/

void MemoryCopy( uint8_t* src, uint8_t* dest, int size ) {
  for ( int i = 0; i < size; ++i ) {
    *dest = *src;

    ++src;
    ++dest;
  }
}

LDR_DATA_TABLE_ENTRY* GetMainModule() {
  const auto peb = GetCurrentPeb();

  const auto head = &peb->Ldr->InLoadOrderModuleList;

  const auto first_entry =
      reinterpret_cast<LDR_DATA_TABLE_ENTRY*>( head->Flink );

  return first_entry;
}

uintptr_t GetModule( const uintptr_t module_name_hash ) {
  const auto peb = GetCurrentPeb();

  const auto head = &peb->Ldr->InLoadOrderModuleList;

  // Set the first entry
  auto link = head->Flink;

  do {
    auto entry = reinterpret_cast<LDR_DATA_TABLE_ENTRY*>( link );

    const auto name_length = entry->BaseDllName.Length / sizeof( wchar_t );

    const auto current_module_hash = HashWideStringLowercase(
        reinterpret_cast<wchar_t*>( entry->BaseDllName.Buffer ), name_length );

    if ( current_module_hash == module_name_hash ) {
      return reinterpret_cast<uintptr_t>( entry->DllBase );
    }

    link = link->Flink;
  } while ( link != head );

  return 0;
}

uintptr_t GetExport( const uintptr_t module,
                     const uintptr_t ansi_export_name_hash ) {
  const auto nt_headers = GetNtHeaders( reinterpret_cast<PVOID>( module ) );

  const auto& export_data_directory =
      nt_headers->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXPORT ];

  const auto export_directory = reinterpret_cast<IMAGE_EXPORT_DIRECTORY*>(
      module + export_data_directory.VirtualAddress );

  const auto names =
      reinterpret_cast<uint32_t*>( module + export_directory->AddressOfNames );
  const auto ordinals = reinterpret_cast<uint16_t*>(
      module + export_directory->AddressOfNameOrdinals );
  const auto addresses = reinterpret_cast<uint32_t*>(
      module + export_directory->AddressOfFunctions );

  for ( int i = 0; i < export_directory->NumberOfNames; ++i ) {
    const auto name = ( const char* )( module + names[ i ] );

    if ( HashString( name ) == ansi_export_name_hash ) {
      const auto address = addresses[ ordinals[ i ] ];
      return module + address;
    }
  }

  return 0;
}

IMAGE_SECTION_HEADER* GetSectionHeaderByHash( const PVOID base,
                                              const uintptr_t name_hash ) {
  const auto nt_headers = GetNtHeaders( base );

  const auto sections = IMAGE_FIRST_SECTION( nt_headers );

  for ( int i = 0; i < nt_headers->FileHeader.NumberOfSections; ++i ) {
    const auto section = &sections[ i ];

    const auto section_name_hash =
        HashString( reinterpret_cast<const char*>( section->Name ) );

    if ( section_name_hash == name_hash ) {
      return &sections[ i ];
    }
  }

  return 0;
}

VmCodeSectionData* GetVmCodeSectionData( const PVOID base ) {
  constexpr auto vm_code_section_name_hash =
      HashWideString( TEXT( VM_CODE_SECTION_NAME ) );

  const auto sec_header =
      GetSectionHeaderByHash( base, vm_code_section_name_hash );

  auto vm_code_sec_data_addr =
      reinterpret_cast<uintptr_t>( base ) + sec_header->VirtualAddress;

  return reinterpret_cast<VmCodeSectionData*>( vm_code_sec_data_addr );
}

void FixImports( uint8_t* dll_base_addr,
                 VmCodeSectionData* vm_code_section_data,
                 const IMAGE_DATA_DIRECTORY& import_data_directory,
                 const ApiAddresses& apis ) {
  const auto import_redirections_alloc_size =
      vm_code_section_data->import_count *
      sizeof( vm_code_section_data->import_redirect_shellcode );

  int import_redirect_memory_offset = 0;

  // Allocate the memory where we'll write all of the import redirections
  const auto import_redirect_memory = reinterpret_cast<uintptr_t>(
      apis.VirtualAlloc( NULL, import_redirections_alloc_size,
                         MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE ) );

  auto import_desc = reinterpret_cast<IMAGE_IMPORT_DESCRIPTOR*>(
      dll_base_addr + import_data_directory.VirtualAddress );

  // For each import descriptor
  for ( ; import_desc->Name; ++import_desc ) {
    const auto dll_name =
        reinterpret_cast<const char*>( dll_base_addr + import_desc->Name );

    const HINSTANCE dll_instance = apis.LoadLibraryA( dll_name );

    // We read from the original thunk
    auto original_thunk = reinterpret_cast<IMAGE_THUNK_DATA*>(
        dll_base_addr + import_desc->OriginalFirstThunk );

    // We write to the first thunk
    auto first_thunk = reinterpret_cast<IMAGE_THUNK_DATA*>(
        dll_base_addr + import_desc->FirstThunk );

    // For each import thunk
    for ( ; original_thunk->u1.AddressOfData;
          ++original_thunk, ++first_thunk ) {
      uintptr_t import_function_address = 0;

      const bool by_ordinal =
          IMAGE_SNAP_BY_ORDINAL( original_thunk->u1.Ordinal );

      if ( by_ordinal ) {
        // TODO: Replace with my own get proc address, support ordinal tho
        const auto ordinal = IMAGE_ORDINAL( original_thunk->u1.Ordinal );

        import_function_address =
            reinterpret_cast<uintptr_t>( apis.GetProcAddress(
                dll_instance, reinterpret_cast<char*>( ordinal ) ) );
      } else {
        const auto import_by_name = reinterpret_cast<IMAGE_IMPORT_BY_NAME*>(
            dll_base_addr + original_thunk->u1.AddressOfData );

        import_function_address = reinterpret_cast<uintptr_t>(
            apis.GetProcAddress( dll_instance, import_by_name->Name ) );
      }

      if ( vm_code_section_data->redirect_imports ) {
        auto redirection_shellcode =
            vm_code_section_data->import_redirect_shellcode;

        // TODO: Consider randomly generating/modifying one line in the shellcode to not only have a simple XOR
        // TODO: Generate the xor key "randomly" using the import_redirect_memory_offset as a seed

        const uint32_t xor_key = 0x1337;

#ifdef _WIN64
        // Write the encrypted address
        *reinterpret_cast<uint64_t*>( redirection_shellcode + 5 ) =
            import_function_address ^ xor_key;

        // Write the xor key
        *reinterpret_cast<uint32_t*>( redirection_shellcode + 15 ) = xor_key;
#else
        // Write the encrypted address
        *reinterpret_cast<uint32_t*>( redirection_shellcode + 4 ) =
            import_function_address ^ xor_key;

        // Write the xor key
        *reinterpret_cast<uint32_t*>( redirection_shellcode + 9 ) = xor_key;
#endif

        const auto redirection_destination = reinterpret_cast<uint8_t*>(
            import_redirect_memory + import_redirect_memory_offset );

        // Write the redirection shellcode to the allocated location
        MemoryCopy( redirection_shellcode, redirection_destination,
                    sizeof( vm_code_section_data->import_redirect_shellcode ) );

        DWORD old_protection;
        apis.VirtualProtect( first_thunk, sizeof( IMAGE_THUNK_DATA ),
                             PAGE_EXECUTE_READWRITE, &old_protection );

        // Set the API call to the redirection shellcode
        *reinterpret_cast<uintptr_t*>( first_thunk ) =
            import_redirect_memory + import_redirect_memory_offset;

        apis.VirtualProtect( first_thunk, sizeof( IMAGE_THUNK_DATA ),
                             old_protection, &old_protection );

        import_redirect_memory_offset +=
            sizeof( vm_code_section_data->import_redirect_shellcode );
      } else {
        DWORD old_protection;
        apis.VirtualProtect( first_thunk, sizeof( IMAGE_THUNK_DATA ),
                             PAGE_EXECUTE_READWRITE, &old_protection );

        // Set the API call to the redirection shellcode
        *reinterpret_cast<uintptr_t*>( first_thunk ) = import_function_address;

        apis.VirtualProtect( first_thunk, sizeof( IMAGE_THUNK_DATA ),
                             old_protection, &old_protection );
      }
    }
  }
}

void AntiAttachDebugger( const Modules& module_addresses,
                         const ApiAddresses& apis ) {
  DWORD old_protection;
  apis.VirtualProtect( reinterpret_cast<LPVOID>( apis.DbgUiRemoteBreakin ), 1,
                       PAGE_READWRITE, &old_protection );

  // ret
  *reinterpret_cast<uint8_t*>( apis.DbgUiRemoteBreakin ) = 0xC3;

  apis.VirtualProtect( reinterpret_cast<LPVOID>( apis.DbgUiRemoteBreakin ), 1,
                       old_protection, &old_protection );

  apis.VirtualProtect( reinterpret_cast<LPVOID>( apis.DbgBreakPoint ), 1,
                       PAGE_READWRITE, &old_protection );

  // ret
  *reinterpret_cast<uint8_t*>( apis.DbgBreakPoint ) = 0xC3;

  apis.VirtualProtect( reinterpret_cast<LPVOID>( apis.DbgBreakPoint ), 1,
                       old_protection, &old_protection );
}

Modules GetModules() {
  constexpr auto ntdll_hash = HashWideString( TEXT( "ntdll.dll" ) );
  const auto ntdll = GetModule( ntdll_hash );

  constexpr auto kernel32_hash = HashWideString( TEXT( "kernel32.dll" ) );
  const auto kernel32 = GetModule( kernel32_hash );

  Modules module_addresses;

  module_addresses.kernel32 = kernel32;
  module_addresses.ntdll = ntdll;

  return module_addresses;
}

ApiAddresses InitializeApis( const Modules& modules ) {
  const auto kernel32 = modules.kernel32;
  const auto ntdll = modules.ntdll;

  constexpr auto load_library_a_hash = HashString( "LoadLibraryA" );
  const auto load_library_a = reinterpret_cast<decltype( &LoadLibraryA )>(
      GetExport( kernel32, load_library_a_hash ) );

  constexpr auto get_proc_address_hash = HashString( "GetProcAddress" );
  const auto get_proc_address = reinterpret_cast<decltype( &GetProcAddress )>(
      GetExport( kernel32, get_proc_address_hash ) );

  constexpr auto virtual_protect_hash = HashString( "VirtualProtect" );
  const auto virtual_protect = reinterpret_cast<decltype( &VirtualProtect )>(
      GetExport( kernel32, virtual_protect_hash ) );

  constexpr auto virtual_alloc_hash = HashString( "VirtualAlloc" );
  const auto virtual_alloc = reinterpret_cast<decltype( &VirtualAlloc )>(
      GetExport( kernel32, virtual_alloc_hash ) );

  constexpr auto dbg_ui_remote_breakin_hash =
      HashString( "DbgUiRemoteBreakin" );
  const auto dbg_ui_remote_breakin = reinterpret_cast<DbgUiRemoteBreakin_t>(
      GetExport( ntdll, dbg_ui_remote_breakin_hash ) );

  constexpr auto dbg_break_point_hash = HashString( "DbgBreakPoint" );
  const auto dbg_breakpoint = reinterpret_cast<DbgBreakPoint_t>(
      GetExport( ntdll, dbg_break_point_hash ) );

  constexpr auto create_file_hash = HashString( "CreateFileW" );
  const auto create_file_w = reinterpret_cast<CreateFileW_t>(
      GetExport( kernel32, create_file_hash ) );

  constexpr auto close_handle_hash = HashString( "CloseHandle" );
  const auto close_handle = reinterpret_cast<CloseHandle_t>(
      GetExport( kernel32, close_handle_hash ) );

  constexpr auto create_file_mapping_a_hash =
      HashString( "CreateFileMappingA" );
  const auto create_file_mapping_a = reinterpret_cast<CreateFileMappingA_t>(
      GetExport( kernel32, create_file_mapping_a_hash ) );

  constexpr auto map_view_of_file_hash = HashString( "MapViewOfFile" );
  const auto map_view_of_file = reinterpret_cast<MapViewOfFile_t>(
      GetExport( kernel32, map_view_of_file_hash ) );

  constexpr auto unmap_view_of_file_hash = HashString( "UnmapViewOfFile" );
  const auto unmap_view_of_file = reinterpret_cast<UnmapViewOfFile_t>(
      GetExport( kernel32, unmap_view_of_file_hash ) );

  constexpr auto set_file_pointer_hash = HashString( "SetFilePointer" );
  const auto set_file_pointer = reinterpret_cast<SetFilePointer_t>(
      GetExport( kernel32, set_file_pointer_hash ) );

  ApiAddresses apis;

  apis.GetProcAddress = get_proc_address;
  apis.LoadLibraryA = load_library_a;
  apis.VirtualProtect = virtual_protect;
  apis.VirtualAlloc = virtual_alloc;
  apis.DbgUiRemoteBreakin = dbg_ui_remote_breakin;
  apis.DbgBreakPoint = dbg_breakpoint;
  apis.CreateFileW = create_file_w;
  apis.CloseHandle = close_handle;
  apis.CreateFileMappingA = create_file_mapping_a;
  apis.MapViewOfFile = map_view_of_file;
  apis.UnmapViewOfFile = unmap_view_of_file;
  apis.SetFilePointer = set_file_pointer;

  return apis;
}

// Returns true if this file's integrity is okay, false otherwise
bool CheckFileIntegrity( const ApiAddresses& apis ) {
  return true;

  const auto main_module_ldr_entry = GetMainModule();

  // NOTE: This assumes the ldr entry FullDllName.Buffer is null-terminated
  const auto file_handle =
      apis.CreateFileW( ( wchar_t* )main_module_ldr_entry->FullDllName.Buffer,
                        GENERIC_READ, FILE_SHARE_WRITE | FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

  if ( file_handle == INVALID_HANDLE_VALUE ) {
    return false;
  }

  const auto file_size =
      apis.SetFilePointer( file_handle, NULL, NULL, FILE_END );

  if ( file_size == INVALID_SET_FILE_POINTER ) {
    CloseHandle( file_handle );
    return false;
  }

  const auto mapped_file_handle =
      apis.CreateFileMappingA( file_handle, NULL, PAGE_READONLY, 0, 0, NULL );

  if ( mapped_file_handle == NULL ) {
    CloseHandle( file_handle );
    return false;
  }

  const auto mapped_file_addr =
      apis.MapViewOfFile( mapped_file_handle, FILE_MAP_READ, 0, 0, 0 );

  if ( mapped_file_addr == NULL ) {
    CloseHandle( mapped_file_handle );
    CloseHandle( file_handle );
    return false;
  }

  // calulate the checksum here

  apis.UnmapViewOfFile( mapped_file_addr );

  CloseHandle( mapped_file_handle );
  CloseHandle( file_handle );

  return true;
}

__declspec( dllexport ) void NTAPI
    FirstTlsCallback( PVOID dll_base, DWORD reason, PVOID reserved ) {
  // TODO: use fiber to execute the all the code

  /*
    Remove the TLS callback immediately after they are called, in themselves
    That means, if we e.g. fix imports in the TLS callbacks, are they are removed once someone dumps them, means invalid PE?

    1. Check the integrity of the image
    2. 
  */

  /*
    Limitations:
      We cannot use direct winapi calls
      We cannot use strings because they are compiled into the .rdata section
      No direct exception handling
      Cannot use arrays due to VS Debug mode variable auto initialization, it calls a memcpy from another section..
  */

  switch ( reason ) {
    case DLL_PROCESS_ATTACH: {
      const auto modules = GetModules();
      const auto apis = InitializeApis( modules );

      AntiAttachDebugger( modules, apis );

      auto vm_code_section_data = GetVmCodeSectionData( dll_base );

#if ENABLE_TLS_CALLBACKS
      FixNextCorruptedTlsCallback( dll_base, *vm_code_section_data );
#endif

      const auto dll_base_ptr = reinterpret_cast<uint8_t*>( dll_base );

      const auto import_data_directory =
          vm_code_section_data->import_data_directory;

      if ( import_data_directory.Size > 0 ) {
        FixImports( dll_base_ptr, vm_code_section_data, import_data_directory,
                    apis );

        // Remove it info in case someone dumps the PE
        vm_code_section_data->import_data_directory.Size = 0;
        vm_code_section_data->import_data_directory.VirtualAddress = 0;
      }
    } break;
    default:
      break;
  }

  // Read here to ruin the imports: https://github.com/namreeb/dumpwow/blob/master/dll/dumper.cpp

  // 1. Decrypt all strings
  // 2. Fix all imports
  // 3. Remap

  // Integrity check ONLY sections that does NOT have the writeable flags

  // Flow:
  // 1. Decrypt the sections, extra layer to waste time
  // 2. Remap
  // 3. Check integrity that was written in a data section by the protector
  // 4. Try to modify the remapped memory to ensure that it was properly remapped and no disgusting things occur.
  //    Ensure that when we try to modify it, do not use an API call that can be hooked
}

__declspec( dllexport ) void NTAPI
    SecondTlsCallback( PVOID dll_base, DWORD reason, PVOID reserved ) {
  // TODO: Add a dynamic TLS callback here, ensure that when do so, we never directly
  // reference the new TLS callback by address to ensure someone cannot
  // simply find it by decompiling the code in IDA

  auto nt_headers = GetNtHeaders( dll_base );
}

#ifdef _WIN64
__declspec( dllexport ) uintptr_t
    __fastcall BeforeEntrypoint( uintptr_t dll_base )
#else
__declspec( dllexport ) uintptr_t
    __stdcall BeforeEntrypoint( uintptr_t dll_base )
#endif
{
  const auto vm_code_section_data =
      GetVmCodeSectionData( reinterpret_cast<PVOID>( dll_base ) );

  const auto modules = GetModules();
  const auto apis = InitializeApis( modules );

#if ENABLE_FILE_INTEGRITY_CHECKS
  if ( !CheckFileIntegrity( apis ) ) {
    // TODO: Think of something better to return to make
    // it obfuscated, or mayybe something even smarter?
    return 0;
  }
#endif

  // Return the real entrypoint address for the entrypoint shellcode to call
  return dll_base + vm_code_section_data->real_entrypoint;
}

void PushValueToRealStack( VmContext* vm_context, uintptr_t value ) {
  const auto current_registers_address =
      reinterpret_cast<uintptr_t>( vm_context->registers );

  auto current_register_last_value_address =
      current_registers_address + sizeof( VmRegisters ) - sizeof( uintptr_t );

  // Make a copy of the registers
  const auto registers_copy = *vm_context->registers;

  // Get the new registers address on the stack (subtracted by sizeof(ptr))
  auto new_registers = reinterpret_cast<VmRegisters*>(
      current_registers_address - sizeof( uintptr_t ) );

  // Copy the registers to the new location
  *new_registers = *vm_context->registers;

  // Modify the vm_context->registers variable to the new stack address
  vm_context->registers = new_registers;

  // Set the push value
  *reinterpret_cast<uintptr_t*>( current_register_last_value_address ) = value;

  // Modify esp appropriately in order to return to the correct esp so the
  // pushed arguments show on top of stack
  vm_context->esp -= sizeof( uintptr_t );
}

uintptr_t* GetPointerToRegister( const VmContext* vm_context,
                                 const uint32_t reg_offset ) {
  uint8_t* register_struct_bytes = ( uint8_t* )vm_context->registers;
  return ( uintptr_t* )( register_struct_bytes + reg_offset );
}

template <typename T>
T ReadValue( uint8_t** code ) {
  const T value = *reinterpret_cast<T*>( *code );

  *code += sizeof( T );

  return value;
}

void WriteSizedValue( const uint32_t size,
                      const uintptr_t* write_dest,
                      const uintptr_t value ) {
  switch ( size ) {
    case 1: {
      auto reg_dest_value_with_disp = ( uint8_t* )( write_dest );
      *reg_dest_value_with_disp = ( uint8_t )value;
    } break;
    case 2: {
      auto reg_dest_value_with_disp = ( uint16_t* )( write_dest );
      *reg_dest_value_with_disp = ( uint16_t )value;
    } break;
    case 4: {
      auto reg_dest_value_with_disp = ( uint32_t* )( write_dest );
      *reg_dest_value_with_disp = ( uint32_t )value;
    } break;
    case 8: {
      auto reg_dest_value_with_disp = ( uint64_t* )( write_dest );
      *reg_dest_value_with_disp = ( uint64_t )value;
    } break;
    default:
      break;
  }
}

void WriteSizedValueToRegister( const VmContext* vm_context,
                                const VmRegister& vm_reg,
                                const uintptr_t value ) {
  const auto write_dest_ptr =
      GetPointerToRegister( vm_context, vm_reg.register_offset );

  if ( vm_reg.register_size == 4 ) {
    // https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/x64-architecture
    // Operations that output to a 32-bit subregister are automatically zero-extended
    // to the entire 64-bit register. Operations that output to 8-bit or 16-bit
    // subregisters are not zero-extended (this is compatible x86 behavior).

    // If my understand of the statement above is correct, then the follwing line should
    // zero-extend the whole 64 register on x64 and the whole x86 register on x86, but on x86 it does not matter
    *( uintptr_t* )( write_dest_ptr ) = 0;
  }

  WriteSizedValue( vm_reg.register_size, write_dest_ptr, value );
}

/*
  Adding (__declspec(dllexport)) in order to export the function ensures that
  the parameters won't be incorrectly optimized due to the way I am calling
  this function inside of the code.

  Use __stdcall calling convention because I need the functionality to be able
  to push the parameters to the function. 
  
  When using __fastcall it uses the
  registers immedietly expecting that you have specific registers with proper
  values. On x64 the only calling convention is __fastcall, I hate it...fuck.
*/
#ifdef _WIN64
__declspec( dllexport ) int32_t
    __fastcall VmInterpreter( uint8_t* code,
                              size_t allocated_stack_addr,
                              uint32_t vm_opcode_encyption_key,
                              uintptr_t image_base_address ) {
#else
__declspec( dllexport ) int32_t
    __stdcall VmInterpreter( uint8_t* code,
                             size_t allocated_stack_addr,
                             uint32_t vm_opcode_encyption_key,
                             uintptr_t image_base_address ) {
#endif
  // The total bytes of the arguments that was pushed to this function call
  // before the esp was pushed
  uint32_t kTotalParametersBeforeEspPush = sizeof( uint32_t ) * 2;

#ifdef _WIN64
  kTotalParametersBeforeEspPush = 0;
#endif

  // A value that describes the amount of stack we allocate before we call this interpreter in the loader shellcode
  // It is based on the sub esp, 0x100
  //                    add esp, 0x100
  // This is not required for x86, but I am still doing it for consistency on both x86 and x64
  const auto interpreter_call_stack_allocation_space = 0x100;

  // Read whole struct from stack in one read
  VmContext* vm_context =
      ( VmContext* )( allocated_stack_addr + kTotalParametersBeforeEspPush +
                      interpreter_call_stack_allocation_space );

  // Initialize the pointer to the pushed registers
  vm_context->registers =
      ( VmRegisters* )( ( uintptr_t )( vm_context ) +
                        VM_INTERPRETER_STACK_ALLOCATION_SIZE_BYTES +
                        sizeof( vm_context->esp ) -
                        offsetof( VmContext, registers ) +
                        sizeof( vm_context->registers ) );

  code += image_base_address;

  const auto vm_opcode = ReadValue<uint32_t>( &code ) ^ vm_opcode_encyption_key;

  const auto relocated_disp = ReadValue<uint8_t>( &code );
  const auto relocated_imm = ReadValue<uint8_t>( &code );

  switch ( static_cast<VmOpcodes>( vm_opcode ) ) {
    case VmOpcodes::MOV_REGISTER_MEMORY_REG_OFFSET: {
      const auto vm_reg_dest = ReadValue<VmRegister>( &code );
      const auto vm_reg_src = ReadValue<VmRegister>( &code );

      auto reg_src_disp = ReadValue<uintptr_t>( &code );

      if ( relocated_disp ) {
        reg_src_disp = reg_src_disp + image_base_address;
      }

      const auto reg_src_value =
          *GetPointerToRegister( vm_context, vm_reg_src.register_offset );

      const auto reg_src_value_with_disp = reg_src_value + reg_src_disp;

      const auto mov_value = *( uintptr_t* )reg_src_value_with_disp;

      WriteSizedValueToRegister( vm_context, vm_reg_dest, mov_value );
    } break;

    case VmOpcodes::MOV_REGISTER_MEMORY_IMMEDIATE: {
      const auto vm_reg_dest = ReadValue<VmRegister>( &code );
      auto value_src_addr = ReadValue<uintptr_t>( &code );

      if ( relocated_disp ) {
        value_src_addr = value_src_addr + image_base_address;
      }

      const auto value = *( uintptr_t* )( value_src_addr );

      WriteSizedValueToRegister( vm_context, vm_reg_dest, value );
    } break;

    case VmOpcodes::MOV_REGISTER_REGISTER: {
      const auto vm_reg_dest = ReadValue<VmRegister>( &code );
      const auto vm_reg_src = ReadValue<VmRegister>( &code );

      const auto value =
          *GetPointerToRegister( vm_context, vm_reg_src.register_offset );

      WriteSizedValueToRegister( vm_context, vm_reg_dest, value );
    } break;

    case VmOpcodes::MOV_REGISTER_IMMEDIATE: {
      // Read the next 4 bytes as uint32_t
      const auto vm_reg_dest = ReadValue<VmRegister>( &code );

      auto value = ReadValue<uintptr_t>( &code );

      if ( relocated_imm ) {
        value = value + image_base_address;
      }

      WriteSizedValueToRegister( vm_context, vm_reg_dest, value );
    } break;

    case VmOpcodes::MOV_MEMORY_REG_OFFSET_REG: {
      const auto vm_reg_dest = ReadValue<VmRegister>( &code );
      const auto vm_reg_src = ReadValue<VmRegister>( &code );

      auto reg_dest_disp = ReadValue<uintptr_t>( &code );

      if ( relocated_disp ) {
        reg_dest_disp = reg_dest_disp + image_base_address;
      }

      // NOTE: Might be issues within this handling due to the different sizes of the read/writes of registers

      // Read the src register value
      const auto reg_src_value =
          *GetPointerToRegister( vm_context, vm_reg_src.register_offset );

      const auto reg_dest_value =
          *GetPointerToRegister( vm_context, vm_reg_dest.register_offset );

      auto reg_dest_value_with_disp =
          ( uintptr_t* )( reg_dest_value + reg_dest_disp );

      WriteSizedValue( vm_reg_dest.register_size, reg_dest_value_with_disp,
                       reg_src_value );
    } break;

    case VmOpcodes::MOV_MEMORY_REG_OFFSET_IMM: {
      // Example 1: mov dword ptr [eax + 0x7d765c], 2
      // Example 2: mov dword ptr [ebp - 0x20], 0x7d7268

      // mov [reg + 0x0], imm

      const auto vm_reg_dest = ReadValue<VmRegister>( &code );

      auto source_value = ReadValue<uintptr_t>( &code );
      auto reg_dest_disp = ReadValue<uintptr_t>( &code );

      if ( relocated_disp ) {
        reg_dest_disp = reg_dest_disp + image_base_address;
      } else if ( relocated_imm ) {
        source_value = source_value + image_base_address;
      }

      // NOTE: Might be issues within this handling due to the different sizes of the read/writes of registers

      const auto reg_dest_value =
          *GetPointerToRegister( vm_context, vm_reg_dest.register_offset );

      const auto dest_ptr = ( uintptr_t* )( reg_dest_value + reg_dest_disp );

      WriteSizedValue( vm_reg_dest.register_size, dest_ptr, source_value );
    } break;

    case VmOpcodes::LEA_REG_MEMORY_IMMEDIATE_RIP_RELATIVE: {
      const auto vm_reg_dest = ReadValue<VmRegister>( &code );

      const auto relative_data_addr = ReadValue<uintptr_t>( &code );

      const auto absolute_addr_to_data =
          relative_data_addr + image_base_address;

      WriteSizedValueToRegister( vm_context, vm_reg_dest,
                                 absolute_addr_to_data );
    } break;

    case VmOpcodes::CALL_MEMORY_RIP_RELATIVE: {
      const auto destination_addr = ReadValue<uintptr_t>( &code );

      const auto absolute_addr_to_call = *reinterpret_cast<uintptr_t*>(
          destination_addr + image_base_address );

      // Push a value that the loader prolog will use
      PushValueToRealStack( vm_context, 0 );

      PushValueToRealStack( vm_context, absolute_addr_to_call );
    } break;

    case VmOpcodes::CALL_MEMORY: {
      // push the call address to the stack

      // TODO: add size as with all other instructions

      auto absolute_call_target_addr_addr = ReadValue<uintptr_t>( &code );

      if ( relocated_disp ) {
        absolute_call_target_addr_addr =
            absolute_call_target_addr_addr + image_base_address;
      }

      uintptr_t absolute_call_target_addr =
          *( uintptr_t* )absolute_call_target_addr_addr;

      // Push a value that the loader prolog will use
      PushValueToRealStack( vm_context, 0 );

      PushValueToRealStack( vm_context, absolute_call_target_addr );

      // when exiting the vm (before jmp back), push return address
      // then jmp to
    } break;

    case VmOpcodes::CALL_IMMEDIATE: {
      // push the call address to the stack

      auto absolute_call_target_addr = ReadValue<uintptr_t>( &code );

      // add the image base
      absolute_call_target_addr += image_base_address;

      // Push a value that the loader prolog will use
      PushValueToRealStack( vm_context, 0 );

      PushValueToRealStack( vm_context, absolute_call_target_addr );

      // when exiting the vm (before jmp back), push return address
      // then jmp to
    } break;

    case VmOpcodes::PUSH_IMM: {
      auto pushed_addr = ReadValue<uintptr_t>( &code );

      if ( relocated_imm ) {
        pushed_addr = pushed_addr + image_base_address;
      }

      PushValueToRealStack( vm_context, pushed_addr );
    } break;

    case VmOpcodes::PUSH_REGISTER_MEMORY_REG_OFFSET: {
      // TODO: Consider handling different sizes of push, at the moment
      // I prevent it from handling any other sizes of push

      const auto vm_reg_src = ReadValue<VmRegister>( &code );
      auto reg_src_disp = ReadValue<uintptr_t>( &code );

      if ( relocated_disp ) {
        reg_src_disp = reg_src_disp + image_base_address;
      }

      // read the register value
      const auto reg_src_value =
          *GetPointerToRegister( vm_context, vm_reg_src.register_offset );

      // read the stack value at the register + disp offset
      const auto value_to_push =
          *( uintptr_t* )( reg_src_value + reg_src_disp );

      PushValueToRealStack( vm_context, value_to_push );
    } break;

    case VmOpcodes::JMP_IMM: {
      // NOTE: I do not think this can be relocated

      auto absolute_jmp_target_addr = ReadValue<uintptr_t>( &code );

      // add the image base
      absolute_jmp_target_addr += image_base_address;

      PushValueToRealStack( vm_context, absolute_jmp_target_addr );

      // when exiting the vm (before jmp back), push return address
      // then jmp to
    } break;

    default:
      break;
  }

  // TODO: When returning, push all the values on the vm_stack to the real stack

  // Return 0 indicating that we should exit the handler and everything is good.
  return 0;
}

// Reset the code_seg, add code to normal .text section again
#pragma code_seg()

BOOL WINAPI DllMain( HINSTANCE instance_handle,
                     DWORD reason,
                     LPVOID reserved ) {
  printf( "Fuck me 1" );

  VmInterpreter( ( uint8_t* )0x1, 0x2, 0x3, 0x4 );

  printf( "Fuck me 2" );

  return 1;
}
```

`Interpreter/src/main.h`:

```h
#pragma once
#include <cstdint>

#define VM_LOADER_SECTION_NAME ( ".dick" )
#define VM_CODE_SECTION_NAME ".dick2"

#define VM_FUNCTIONS_SECTION_NAME "vmfun"
#define VM_INTERPRETER_STACK_ALLOCATION_SIZE_BYTES 200

#define ENABLE_TLS_CALLBACKS TRUE
#define ENABLE_FILE_INTEGRITY_CHECKS TRUE

// The data at the beginning of the vm code section
struct VmCodeSectionData {
  // A bunch of zeroed data for the import data directory to point to
  uint8_t zeroed_data_for_import_directory[ sizeof( IMAGE_IMPORT_DESCRIPTOR ) ];

  char friendly_message[ 80 ];

  uint32_t real_entrypoint;

  // TODO: make this random each time...
  // The 2nd TLS callback we add has an invalid address, we fix
  // it up in the first TLS callback using this value
  uint32_t second_tls_callback_modifier = 1001;

  IMAGE_DATA_DIRECTORY import_data_directory;

  // How many imports does the PE have
  uint32_t import_count;
  bool redirect_imports;

#ifdef _WIN64
  uint8_t import_redirect_shellcode[ 27 ] = {
    // push rax
    0x50,

    // pushfq
    0x9C,

    // push rax
    0x50,

    // movabs rax, 64 bit value
    0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // xor rax, 0
    0x48, 0x35, 0x00, 0x00, 0x00, 0x00,

    // mov [rsp + 0x10], rax
    0x48, 0x89, 0x44, 0x24, 0x10,

    // pop rax
    0x58,

    // popfq
    0x9D,
    // ret
    0xC3
  };
#else
  /*
    // Allocate space for call destination
	  // Why push eax? Because we cannot use sub because it changes eflags before we saved them
	  push eax

	  // Save eflags because we change them due to usage of xor
	  pushfd

	  // Save eax to use it
	  push eax
	
	  mov eax, 0x1337 (encrypted addr)
	
	  xor eax, 0xDEAD (xor with key)
	
	  // Set the allocated stack to the call destination
	  mov [esp + (8 or 16)], eax
	
	  // Restore the saved eax
	  pop eax
	
	  // Restore the saved eflags
	  popfd
	
	  // Jump to call destination
	  ret
  */
  uint8_t import_redirect_shellcode[ 20 ] = {
    // push eax
    0x50,

    // pushfd
    0x9C,

    // push eax
    0x50,

    // mov eax, 0x1337
    0xB8, 0x37, 0x13, 0x00, 0x00,

    // xor eax, 0
    0x35, 0x00, 0x00, 0x00, 0x00,

    // mov [esp + 8], eax
    0x89, 0x44, 0x24, 0x08,

    // pop eax
    0x58,

    // popfd
    0x9D,
    // ret
    0xC3
  };
#endif
};

enum class VmOpcodes : uint32_t {
  // mov reg, 0x0
  MOV_REGISTER_IMMEDIATE = 0x74F91AA0,

  // mov reg, reg
  MOV_REGISTER_REGISTER = 0xB9C115AB,

  // mov eax, dword ptr [0x7d6610]
  MOV_REGISTER_MEMORY_IMMEDIATE = 0x19BFE12B,

  // mov ecx, dword ptr [eax + 0x84]
  MOV_REGISTER_MEMORY_REG_OFFSET = 0x4278BEA1,

  // mov [reg + 0x0], reg
  MOV_MEMORY_REG_OFFSET_REG = 0x1927BA1F,

  // mov [reg + 0x0], imm
  MOV_MEMORY_REG_OFFSET_IMM = 0x0F0B255A,

  CALL_IMMEDIATE = 0x437BDFA1,
  CALL_MEMORY = 0xB2988BE1,

  // call qword ptr [rip + 0x25bec] (default on x64 call for a winapi call)
  CALL_MEMORY_RIP_RELATIVE = 0xCBBB223A,

  // lea r8, ds:[0x00007FF757401AE8]
  LEA_REG_MEMORY_IMMEDIATE_RIP_RELATIVE = 0xAD5F1BB1,

  PUSH_IMM = 0x31CBE5B1,
  PUSH_REGISTER_MEMORY_REG_OFFSET = 0x0BBF011A,  // push dword ptr [eax + 0x9c]

  // jmp imm
  JMP_IMM = 0xCA38B49B,

  NO_OPCODE = 0x0
};

struct VmRegister {
  uint32_t register_offset;
  uint32_t register_size;
};

using XMM = uint64_t[ 2 ];

struct VmRegisters {
#if _WIN64
  uintptr_t r15;
  uintptr_t r14;
  uintptr_t r13;
  uintptr_t r12;
  uintptr_t r11;
  uintptr_t r10;
  uintptr_t r9;
  uintptr_t r8;

  XMM xmm0;
  XMM xmm1;
  XMM xmm2;
  XMM xmm3;
  XMM xmm4;
  XMM xmm5;
  XMM xmm6;
  XMM xmm7;
#endif

  uintptr_t edi;
  uintptr_t esi;
  uintptr_t ebp;
  uintptr_t edx;
  uintptr_t ecx;
  uintptr_t ebx;
  uintptr_t eax;

  uintptr_t pushfd;
};

struct VmContext {
  // esp is in here because it is added straight after the
  // pushes were allocated in loader code
  uintptr_t esp;

  // store registers after the virtual stack otherwise we'll
  // overwrite the pointer when we push on the virtual stack
  VmRegisters* registers;
};

typedef struct _UNICODE_STRING {
  WORD Length;
  WORD MaximumLength;
  WORD* Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef struct _LDR_DATA_TABLE_ENTRY {
  LIST_ENTRY InLoadOrderLinks;
  LIST_ENTRY InMemoryOrderLinks;
  LIST_ENTRY InInitializationOrderLinks;
  PVOID DllBase;
  PVOID EntryPoint;
  ULONG SizeOfImage;
  UNICODE_STRING FullDllName;
  UNICODE_STRING BaseDllName;
  ULONG Flags;
  WORD LoadCount;
  WORD TlsIndex;
  union {
    LIST_ENTRY HashLinks;
    struct {
      PVOID SectionPointer;
      ULONG CheckSum;
    };
  };
  union {
    ULONG TimeDateStamp;
    PVOID LoadedImports;
  };
  _ACTIVATION_CONTEXT* EntryPointActivationContext;
  PVOID PatchInformation;
  LIST_ENTRY ForwarderLinks;
  LIST_ENTRY ServiceTagLinks;
  LIST_ENTRY StaticLinks;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

typedef struct _PEB_LDR_DATA {
  ULONG Length;
  UCHAR Initialized;
  PVOID SsHandle;
  LIST_ENTRY InLoadOrderModuleList;
  LIST_ENTRY InMemoryOrderModuleList;
  LIST_ENTRY InInitializationOrderModuleList;
  PVOID EntryInProgress;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

struct PEB {
  BOOLEAN InheritedAddressSpace;
  BOOLEAN ReadImageFileExecOptions;
  BOOLEAN BeingDebugged;
  union {
    BOOLEAN BitField;
    struct {
      BOOLEAN ImageUsesLargePages : 1;
      BOOLEAN IsProtectedProcess : 1;
      BOOLEAN IsLegacyProcess : 1;
      BOOLEAN IsImageDynamicallyRelocated : 1;
      BOOLEAN SkipPatchingUser32Forwarders : 1;
      BOOLEAN IsPackagedProcess : 1;
      BOOLEAN IsAppContainer : 1;
      BOOLEAN SpareBits : 1;
    };
  };
  HANDLE Mutant;
  PVOID ImageBaseAddress;
  PPEB_LDR_DATA Ldr;
};
```

`README.md`:

```md
# GreyM
Me fockin' EXE protector (unfinished)

* Recursive disassembly
* Virtualizes instructions and interprets them in runtime
* Removes API imports
* Removes string references
* Anti debugging
* Anti dumping
* RTTI obfuscation

Entrypoint after running protector
![alt text](https://i.imgur.com/v8uozhN.png)

```

`Test Executable/Test Executable.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\main.cpp" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{2dc5e383-859c-40eb-ba6c-a9d9b5753bdb}</ProjectGuid>
    <RootNamespace>Test_Executable</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)$(ProjectName)\intermediates\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)$(ProjectName)\intermediates\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)$(ProjectName)\intermediates\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)bin\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)$(ProjectName)\intermediates\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
    </ClCompile>
    <Link>
      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
    </ClCompile>
    <Link>
      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Test Executable/Test Executable.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`Test Executable/src/main.cpp`:

```cpp
#include <iostream>
#include <thread>
#include <Windows.h>
#include <vector>

#define NOINLINE __declspec( noinline )

CRITICAL_SECTION crit_section;

NOINLINE int ReturnValue() {
  // EnterCriticalSection(&crit_section);
  // int test = 1337;
  // LeaveCriticalSection(&crit_section);
  return 1337;
}

NOINLINE int SumValues( int val1, int val2 ) {
  return val1 + val2;
}

NOINLINE void main3() {
  while ( true ) {
    // EnterCriticalSection(&crit_section);
    printf( "3: %d", ReturnValue() );
    // LeaveCriticalSection(&crit_section);
  }
}

NOINLINE void main2() {
  while ( true ) {
    // EnterCriticalSection(&crit_section);
    printf( "2: %d", ReturnValue() );
    // LeaveCriticalSection(&crit_section);
  }
}

class CPolygon {
 protected:
  int width, height;

 public:
  void set_values( int a, int b ) {
    width = a;
    height = b;
  }

  virtual void NewMain() {
    while ( true ) {
      printf( "1 (ReturnValueBase): %d", ReturnValue() );
      printf( "1 (SumValuesBase): %d", SumValues( 5, 15 ) );
    }
  }
};

class Circle : public CPolygon {
 public:
  int area() {
    return width * height;
  }

  virtual void NewMain() {
    int value;
    std::cin >> value;

    switch ( value ) {
      case 0:
        printf( "0" );
        break;
      case 1:
        printf( "1" );
        break;
      case 2:
        printf( "2" );
      case 3:
        printf( "3" );
      case 4:
        printf( "4" );
      case 5:
        printf( "5" );
      case 6:
        printf( "6" );
      case 7:
        printf( "7" );
      case 8:
        printf( "8" );
      default:
        break;
    }

    std::thread t( main2 );
    t.detach();

    for ( int i = 0; i < 100; ++i ) {
      std::thread t2( main3 );
      t2.detach();
    }

    while ( true ) {
      printf( "1 (ReturnValueCircle): %d", ReturnValue() );
      printf( "1 (SumValuesCircle): %d", SumValues( 5, 15 ) );
    }

    std::cin.get();
  }
};

class CRectangle : public CPolygon {
 public:
  int area() {
    return width * height;
  }

  virtual void NewMain() {
    int value;
    std::cin >> value;

    switch ( value ) {
      case 0:
        printf( "0" );
        break;
      case 1:
        printf( "1" );
        break;
      case 2:
        printf( "2" );
      case 3:
        printf( "3" );
      case 4:
        printf( "4" );
      case 5:
        printf( "5" );
      case 6:
        printf( "6" );
      case 7:
        printf( "7" );
      case 8:
        printf( "8" );
      default:
        break;
    }

    std::thread t( main2 );
    t.detach();

    for ( int i = 0; i < 100; ++i ) {
      std::thread t2( main3 );
      t2.detach();
    }

    while ( true ) {
      printf( "1 (ReturnValueRectangle): %d", ReturnValue() );
      printf( "1 (SumValuesRectangle): %d", SumValues( 5, 15 ) );
    }

    std::cin.get();
  }
};

class Triangle : public CPolygon {
 public:
  int area() {
    return width * height / 2;
  }

  virtual void NewMain() {
    int value;
    std::cin >> value;

    switch ( value ) {
      case 0:
        printf( "0" );
        break;
      case 1:
        printf( "1" );
        break;
      case 2:
        printf( "2" );
      case 3:
        printf( "3" );
      case 4:
        printf( "4" );
      case 5:
        printf( "5" );
      case 6:
        printf( "6" );
      case 7:
        printf( "7" );
      case 8:
        printf( "8" );
      default:
        break;
    }

    std::thread t( main2 );
    t.detach();

    for ( int i = 0; i < 100; ++i ) {
      std::thread t2( main3 );
      t2.detach();
    }

    while ( true ) {
      printf( "1 (ReturnValueG): %d", ReturnValue() );
      printf( "1 (SumValuesG): %d", SumValues( 5, 15 ) );
    }

    std::cin.get();
  }
};

class NeuzBase {
 public:
  NeuzBase() {}
  ~NeuzBase() {}

  virtual int Run() {
    int res = Render();
    return res;
  }

 protected:
  virtual HRESULT Render() {
    return S_OK;
  }
};

class Neuz : public NeuzBase {
 public:
  Neuz() {}
  ~Neuz() {}

 protected:
  HRESULT Render() {
    printf( "DICKDICKDICK" );
    return S_OK;
  }
};

Neuz g_neuz;

/*
__declspec( dllexport )
    IMAGE_NT_HEADERS* GetNtHeaders( uintptr_t region_base ) {
  auto dos_header = reinterpret_cast<IMAGE_DOS_HEADER*>( region_base );

  auto nt_headers =
      reinterpret_cast<IMAGE_NT_HEADERS*>( region_base + dos_header->e_lfanew );

  return nt_headers;
}
*/

int main() {
  static std::vector<int> test_static_tls_data_temp_var = {
    1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338,
    1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338,
    1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338, 1338,
  };

  // If the static tls initialization call above does not work properly, inform us about that shits
  //
  if ( test_static_tls_data_temp_var.size() == 0 ) {
    MessageBox( 0,
                TEXT( "Static tls data is not working properly, have you "
                      "initialized it?" ),
                TEXT( "ds" ), 0 );

    return -1;
  }

  static std::vector<int> test_static_tls_data_temp_var2 = {
    1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337,
    1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337,
    1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337,
    1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337
  };

  // If the static tls initialization call above does not work properly, inform us about that shits
  //
  if ( test_static_tls_data_temp_var2.size() == 0 ) {
    MessageBox( 0,
                TEXT( "Static tls data is not working properly, have you "
                      "initialized it?" ),
                TEXT( "ds" ), 0 );

    return -1;
  }

  static std::vector<int> test_static_tls_data_temp_var3 = {
    1339, 1339, 1339, 1339, 1339, 1339, 1339, 1339, 1339, 1339, 1339,
    1339, 1339, 1339, 1339, 1339, 1339, 1339, 1339, 1339, 1339, 1339,
    1339, 1339, 1339, 1339, 1339, 1339, 1339, 1339, 1339,
  };

  // If the static tls initialization call above does not work properly, inform us about that shits
  //
  if ( test_static_tls_data_temp_var3.size() == 0 ) {
    MessageBox( 0,
                TEXT( "Static tls data is not working properly, have you "
                      "initialized it?" ),
                TEXT( "ds" ), 0 );

    return -1;
  }

  for ( auto lol : test_static_tls_data_temp_var ) {
    std::cout << lol << std::endl;
  }

  for ( auto lol : test_static_tls_data_temp_var2 ) {
    std::cout << lol << std::endl;
  }

  for ( auto lol : test_static_tls_data_temp_var3 ) {
    std::cout << lol << std::endl;
  }

  /*
  auto lol = GetModuleHandle( 0 );
  const auto nt_headers = GetNtHeaders( reinterpret_cast<uintptr_t>( lol ) );

  DWORD old;
  VirtualProtect( lol, 1024, PAGE_READWRITE, &old );

  // NULLIFY THE IMPORT DIRECTORY WHEN A USER IS DUMPING TO REMOVE IMPORTS
  nt_headers->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_IMPORT ]
      .Size = 0;
  nt_headers->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_IMPORT ]
      .VirtualAddress = 0;
  */

  MessageBoxA( 0, "Test123123", "dasdas", 0 );

  printf( "Beginning!" );

  g_neuz.Run();

  std::vector<CPolygon*> polygons;
  polygons.push_back( new Triangle );
  polygons.push_back( new Circle );
  polygons.push_back( new CRectangle );

  for ( int i = 3; i < 10; ++i ) {
    polygons.push_back( new Circle );
  }

  for ( int i = 0; i < 10; ++i ) {
    polygons[ i ]->NewMain();
  }

  // CPolygon *base = new Triangle;
  // base->NewMain();

  MessageBoxA( 0, "Test", "dasdas", 0 );

  printf( "Ending!" );

  return 0;
}
```

`_clang-format`:

```
---
BasedOnStyle: Chromium
AlignAfterOpenBracket: Align
AlignConsecutiveAssignments: 'false'
AlignConsecutiveDeclarations: 'false'
AlignEscapedNewlines: Left
AlignTrailingComments: 'false'
AllowShortBlocksOnASingleLine: 'false'
AllowShortCaseLabelsOnASingleLine: 'false'
AllowShortFunctionsOnASingleLine: Empty
AllowShortIfStatementsOnASingleLine: 'false'
AllowShortLoopsOnASingleLine: 'false'
BinPackParameters: 'false'
BreakBeforeTernaryOperators: 'true'
BreakConstructorInitializers: BeforeColon
ColumnLimit: '80'
Cpp11BracedListStyle: 'false'
Language: Cpp
SortIncludes: 'false'
SpacesInCStyleCastParentheses: 'true'
SpacesInParentheses: 'true'
SpacesInSquareBrackets: 'true'
TabWidth: '2'
ReflowComments: 'false'

...

```

`capstone/include/capstone/arm.h`:

```h
#ifndef CAPSTONE_ARM_H
#define CAPSTONE_ARM_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

/// ARM shift type
typedef enum arm_shifter {
	ARM_SFT_INVALID = 0,
	ARM_SFT_ASR,	///< shift with immediate const
	ARM_SFT_LSL,	///< shift with immediate const
	ARM_SFT_LSR,	///< shift with immediate const
	ARM_SFT_ROR,	///< shift with immediate const
	ARM_SFT_RRX,	///< shift with immediate const
	ARM_SFT_ASR_REG,	///< shift with register
	ARM_SFT_LSL_REG,	///< shift with register
	ARM_SFT_LSR_REG,	///< shift with register
	ARM_SFT_ROR_REG,	///< shift with register
	ARM_SFT_RRX_REG,	///< shift with register
} arm_shifter;

/// ARM condition code
typedef enum arm_cc {
	ARM_CC_INVALID = 0,
	ARM_CC_EQ,            ///< Equal                      Equal
	ARM_CC_NE,            ///< Not equal                  Not equal, or unordered
	ARM_CC_HS,            ///< Carry set                  >, ==, or unordered
	ARM_CC_LO,            ///< Carry clear                Less than
	ARM_CC_MI,            ///< Minus, negative            Less than
	ARM_CC_PL,            ///< Plus, positive or zero     >, ==, or unordered
	ARM_CC_VS,            ///< Overflow                   Unordered
	ARM_CC_VC,            ///< No overflow                Not unordered
	ARM_CC_HI,            ///< Unsigned higher            Greater than, or unordered
	ARM_CC_LS,            ///< Unsigned lower or same     Less than or equal
	ARM_CC_GE,            ///< Greater than or equal      Greater than or equal
	ARM_CC_LT,            ///< Less than                  Less than, or unordered
	ARM_CC_GT,            ///< Greater than               Greater than
	ARM_CC_LE,            ///< Less than or equal         <, ==, or unordered
	ARM_CC_AL             ///< Always (unconditional)     Always (unconditional)
} arm_cc;

typedef enum arm_sysreg {
	/// Special registers for MSR
	ARM_SYSREG_INVALID = 0,

	// SPSR* registers can be OR combined
	ARM_SYSREG_SPSR_C = 1,
	ARM_SYSREG_SPSR_X = 2,
	ARM_SYSREG_SPSR_S = 4,
	ARM_SYSREG_SPSR_F = 8,

	// CPSR* registers can be OR combined
	ARM_SYSREG_CPSR_C = 16,
	ARM_SYSREG_CPSR_X = 32,
	ARM_SYSREG_CPSR_S = 64,
	ARM_SYSREG_CPSR_F = 128,

	// independent registers
	ARM_SYSREG_APSR = 256,
	ARM_SYSREG_APSR_G,
	ARM_SYSREG_APSR_NZCVQ,
	ARM_SYSREG_APSR_NZCVQG,

	ARM_SYSREG_IAPSR,
	ARM_SYSREG_IAPSR_G,
	ARM_SYSREG_IAPSR_NZCVQG,
	ARM_SYSREG_IAPSR_NZCVQ,

	ARM_SYSREG_EAPSR,
	ARM_SYSREG_EAPSR_G,
	ARM_SYSREG_EAPSR_NZCVQG,
	ARM_SYSREG_EAPSR_NZCVQ,

	ARM_SYSREG_XPSR,
	ARM_SYSREG_XPSR_G,
	ARM_SYSREG_XPSR_NZCVQG,
	ARM_SYSREG_XPSR_NZCVQ,

	ARM_SYSREG_IPSR,
	ARM_SYSREG_EPSR,
	ARM_SYSREG_IEPSR,

	ARM_SYSREG_MSP,
	ARM_SYSREG_PSP,
	ARM_SYSREG_PRIMASK,
	ARM_SYSREG_BASEPRI,
	ARM_SYSREG_BASEPRI_MAX,
	ARM_SYSREG_FAULTMASK,
	ARM_SYSREG_CONTROL,

	// Banked Registers
	ARM_SYSREG_R8_USR,
	ARM_SYSREG_R9_USR,
	ARM_SYSREG_R10_USR,
	ARM_SYSREG_R11_USR,
	ARM_SYSREG_R12_USR,
	ARM_SYSREG_SP_USR,
	ARM_SYSREG_LR_USR,
	ARM_SYSREG_R8_FIQ,
	ARM_SYSREG_R9_FIQ,
	ARM_SYSREG_R10_FIQ,
	ARM_SYSREG_R11_FIQ,
	ARM_SYSREG_R12_FIQ,
	ARM_SYSREG_SP_FIQ,
	ARM_SYSREG_LR_FIQ,
	ARM_SYSREG_LR_IRQ,
	ARM_SYSREG_SP_IRQ,
	ARM_SYSREG_LR_SVC,
	ARM_SYSREG_SP_SVC,
	ARM_SYSREG_LR_ABT,
	ARM_SYSREG_SP_ABT,
	ARM_SYSREG_LR_UND,
	ARM_SYSREG_SP_UND,
	ARM_SYSREG_LR_MON,
	ARM_SYSREG_SP_MON,
	ARM_SYSREG_ELR_HYP,
	ARM_SYSREG_SP_HYP,

	ARM_SYSREG_SPSR_FIQ,
	ARM_SYSREG_SPSR_IRQ,
	ARM_SYSREG_SPSR_SVC,
	ARM_SYSREG_SPSR_ABT,
	ARM_SYSREG_SPSR_UND,
	ARM_SYSREG_SPSR_MON,
	ARM_SYSREG_SPSR_HYP,
} arm_sysreg;

/// The memory barrier constants map directly to the 4-bit encoding of
/// the option field for Memory Barrier operations.
typedef enum arm_mem_barrier {
	ARM_MB_INVALID = 0,
	ARM_MB_RESERVED_0,
	ARM_MB_OSHLD,
	ARM_MB_OSHST,
	ARM_MB_OSH,
	ARM_MB_RESERVED_4,
	ARM_MB_NSHLD,
	ARM_MB_NSHST,
	ARM_MB_NSH,
	ARM_MB_RESERVED_8,
	ARM_MB_ISHLD,
	ARM_MB_ISHST,
	ARM_MB_ISH,
	ARM_MB_RESERVED_12,
	ARM_MB_LD,
	ARM_MB_ST,
	ARM_MB_SY,
} arm_mem_barrier;

/// Operand type for instruction's operands
typedef enum arm_op_type {
	ARM_OP_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	ARM_OP_REG, ///< = CS_OP_REG (Register operand).
	ARM_OP_IMM, ///< = CS_OP_IMM (Immediate operand).
	ARM_OP_MEM, ///< = CS_OP_MEM (Memory operand).
	ARM_OP_FP,  ///< = CS_OP_FP (Floating-Point operand).
	ARM_OP_CIMM = 64, ///< C-Immediate (coprocessor registers)
	ARM_OP_PIMM, ///< P-Immediate (coprocessor registers)
	ARM_OP_SETEND,	///< operand for SETEND instruction
	ARM_OP_SYSREG,	///< MSR/MRS special register operand
} arm_op_type;

/// Operand type for SETEND instruction
typedef enum arm_setend_type {
	ARM_SETEND_INVALID = 0,	///< Uninitialized.
	ARM_SETEND_BE,	///< BE operand.
	ARM_SETEND_LE, ///< LE operand
} arm_setend_type;

typedef enum arm_cpsmode_type {
	ARM_CPSMODE_INVALID = 0,
	ARM_CPSMODE_IE = 2,
	ARM_CPSMODE_ID = 3
} arm_cpsmode_type;

/// Operand type for SETEND instruction
typedef enum arm_cpsflag_type {
	ARM_CPSFLAG_INVALID = 0,
	ARM_CPSFLAG_F = 1,
	ARM_CPSFLAG_I = 2,
	ARM_CPSFLAG_A = 4,
	ARM_CPSFLAG_NONE = 16,	///< no flag
} arm_cpsflag_type;

/// Data type for elements of vector instructions.
typedef enum arm_vectordata_type {
	ARM_VECTORDATA_INVALID = 0,

	// Integer type
	ARM_VECTORDATA_I8,
	ARM_VECTORDATA_I16,
	ARM_VECTORDATA_I32,
	ARM_VECTORDATA_I64,

	// Signed integer type
	ARM_VECTORDATA_S8,
	ARM_VECTORDATA_S16,
	ARM_VECTORDATA_S32,
	ARM_VECTORDATA_S64,

	// Unsigned integer type
	ARM_VECTORDATA_U8,
	ARM_VECTORDATA_U16,
	ARM_VECTORDATA_U32,
	ARM_VECTORDATA_U64,

	// Data type for VMUL/VMULL
	ARM_VECTORDATA_P8,

	// Floating type
	ARM_VECTORDATA_F32,
	ARM_VECTORDATA_F64,

	// Convert float <-> float
	ARM_VECTORDATA_F16F64,	// f16.f64
	ARM_VECTORDATA_F64F16,	// f64.f16
	ARM_VECTORDATA_F32F16,	// f32.f16
	ARM_VECTORDATA_F16F32,	// f32.f16
	ARM_VECTORDATA_F64F32,	// f64.f32
	ARM_VECTORDATA_F32F64,	// f32.f64

	// Convert integer <-> float
	ARM_VECTORDATA_S32F32,	// s32.f32
	ARM_VECTORDATA_U32F32,	// u32.f32
	ARM_VECTORDATA_F32S32,	// f32.s32
	ARM_VECTORDATA_F32U32,	// f32.u32
	ARM_VECTORDATA_F64S16,	// f64.s16
	ARM_VECTORDATA_F32S16,	// f32.s16
	ARM_VECTORDATA_F64S32,	// f64.s32
	ARM_VECTORDATA_S16F64,	// s16.f64
	ARM_VECTORDATA_S16F32,	// s16.f64
	ARM_VECTORDATA_S32F64,	// s32.f64
	ARM_VECTORDATA_U16F64,	// u16.f64
	ARM_VECTORDATA_U16F32,	// u16.f32
	ARM_VECTORDATA_U32F64,	// u32.f64
	ARM_VECTORDATA_F64U16,	// f64.u16
	ARM_VECTORDATA_F32U16,	// f32.u16
	ARM_VECTORDATA_F64U32,	// f64.u32
} arm_vectordata_type;

/// ARM registers
typedef enum arm_reg {
	ARM_REG_INVALID = 0,
	ARM_REG_APSR,
	ARM_REG_APSR_NZCV,
	ARM_REG_CPSR,
	ARM_REG_FPEXC,
	ARM_REG_FPINST,
	ARM_REG_FPSCR,
	ARM_REG_FPSCR_NZCV,
	ARM_REG_FPSID,
	ARM_REG_ITSTATE,
	ARM_REG_LR,
	ARM_REG_PC,
	ARM_REG_SP,
	ARM_REG_SPSR,
	ARM_REG_D0,
	ARM_REG_D1,
	ARM_REG_D2,
	ARM_REG_D3,
	ARM_REG_D4,
	ARM_REG_D5,
	ARM_REG_D6,
	ARM_REG_D7,
	ARM_REG_D8,
	ARM_REG_D9,
	ARM_REG_D10,
	ARM_REG_D11,
	ARM_REG_D12,
	ARM_REG_D13,
	ARM_REG_D14,
	ARM_REG_D15,
	ARM_REG_D16,
	ARM_REG_D17,
	ARM_REG_D18,
	ARM_REG_D19,
	ARM_REG_D20,
	ARM_REG_D21,
	ARM_REG_D22,
	ARM_REG_D23,
	ARM_REG_D24,
	ARM_REG_D25,
	ARM_REG_D26,
	ARM_REG_D27,
	ARM_REG_D28,
	ARM_REG_D29,
	ARM_REG_D30,
	ARM_REG_D31,
	ARM_REG_FPINST2,
	ARM_REG_MVFR0,
	ARM_REG_MVFR1,
	ARM_REG_MVFR2,
	ARM_REG_Q0,
	ARM_REG_Q1,
	ARM_REG_Q2,
	ARM_REG_Q3,
	ARM_REG_Q4,
	ARM_REG_Q5,
	ARM_REG_Q6,
	ARM_REG_Q7,
	ARM_REG_Q8,
	ARM_REG_Q9,
	ARM_REG_Q10,
	ARM_REG_Q11,
	ARM_REG_Q12,
	ARM_REG_Q13,
	ARM_REG_Q14,
	ARM_REG_Q15,
	ARM_REG_R0,
	ARM_REG_R1,
	ARM_REG_R2,
	ARM_REG_R3,
	ARM_REG_R4,
	ARM_REG_R5,
	ARM_REG_R6,
	ARM_REG_R7,
	ARM_REG_R8,
	ARM_REG_R9,
	ARM_REG_R10,
	ARM_REG_R11,
	ARM_REG_R12,
	ARM_REG_S0,
	ARM_REG_S1,
	ARM_REG_S2,
	ARM_REG_S3,
	ARM_REG_S4,
	ARM_REG_S5,
	ARM_REG_S6,
	ARM_REG_S7,
	ARM_REG_S8,
	ARM_REG_S9,
	ARM_REG_S10,
	ARM_REG_S11,
	ARM_REG_S12,
	ARM_REG_S13,
	ARM_REG_S14,
	ARM_REG_S15,
	ARM_REG_S16,
	ARM_REG_S17,
	ARM_REG_S18,
	ARM_REG_S19,
	ARM_REG_S20,
	ARM_REG_S21,
	ARM_REG_S22,
	ARM_REG_S23,
	ARM_REG_S24,
	ARM_REG_S25,
	ARM_REG_S26,
	ARM_REG_S27,
	ARM_REG_S28,
	ARM_REG_S29,
	ARM_REG_S30,
	ARM_REG_S31,

	ARM_REG_ENDING,		// <-- mark the end of the list or registers

	// alias registers
	ARM_REG_R13 = ARM_REG_SP,
	ARM_REG_R14 = ARM_REG_LR,
	ARM_REG_R15 = ARM_REG_PC,

	ARM_REG_SB = ARM_REG_R9,
	ARM_REG_SL = ARM_REG_R10,
	ARM_REG_FP = ARM_REG_R11,
	ARM_REG_IP = ARM_REG_R12,
} arm_reg;

/// Instruction's operand referring to memory
/// This is associated with ARM_OP_MEM operand type above
typedef struct arm_op_mem {
	arm_reg base;	///< base register
	arm_reg index;	///< index register
	int scale;	///< scale for index register (can be 1, or -1)
	int disp;	///< displacement/offset value
	/// left-shift on index register, or 0 if irrelevant
	/// NOTE: this value can also be fetched via operand.shift.value
	int lshift;
} arm_op_mem;

/// Instruction operand
typedef struct cs_arm_op {
	int vector_index;	///< Vector Index for some vector operands (or -1 if irrelevant)

	struct {
		arm_shifter type;
		unsigned int value;
	} shift;

	arm_op_type type;	///< operand type

	union {
		int reg;	///< register value for REG/SYSREG operand
		int32_t imm;			///< immediate value for C-IMM, P-IMM or IMM operand
		double fp;			///< floating point value for FP operand
		arm_op_mem mem;		///< base/index/scale/disp value for MEM operand
		arm_setend_type setend; ///< SETEND instruction's operand type
	};

	/// in some instructions, an operand can be subtracted or added to
	/// the base register,
	/// if TRUE, this operand is subtracted. otherwise, it is added.
	bool subtracted;

	/// How is this operand accessed? (READ, WRITE or READ|WRITE)
	/// This field is combined of cs_ac_type.
	/// NOTE: this field is irrelevant if engine is compiled in DIET mode.
	uint8_t access;

	/// Neon lane index for NEON instructions (or -1 if irrelevant)
	int8_t neon_lane;
} cs_arm_op;

/// Instruction structure
typedef struct cs_arm {
	bool usermode;	///< User-mode registers to be loaded (for LDM/STM instructions)
	int vector_size; 	///< Scalar size for vector instructions
	arm_vectordata_type vector_data; ///< Data type for elements of vector instructions
	arm_cpsmode_type cps_mode;	///< CPS mode for CPS instruction
	arm_cpsflag_type cps_flag;	///< CPS mode for CPS instruction
	arm_cc cc;			///< conditional code for this insn
	bool update_flags;	///< does this insn update flags?
	bool writeback;		///< does this insn write-back?
	arm_mem_barrier mem_barrier;	///< Option for some memory barrier instructions

	/// Number of operands of this instruction,
	/// or 0 when instruction has no operand.
	uint8_t op_count;

	cs_arm_op operands[36];	///< operands for this instruction.
} cs_arm;

/// ARM instruction
typedef enum arm_insn {
	ARM_INS_INVALID = 0,

	ARM_INS_ADC,
	ARM_INS_ADD,
	ARM_INS_ADR,
	ARM_INS_AESD,
	ARM_INS_AESE,
	ARM_INS_AESIMC,
	ARM_INS_AESMC,
	ARM_INS_AND,
	ARM_INS_BFC,
	ARM_INS_BFI,
	ARM_INS_BIC,
	ARM_INS_BKPT,
	ARM_INS_BL,
	ARM_INS_BLX,
	ARM_INS_BX,
	ARM_INS_BXJ,
	ARM_INS_B,
	ARM_INS_CDP,
	ARM_INS_CDP2,
	ARM_INS_CLREX,
	ARM_INS_CLZ,
	ARM_INS_CMN,
	ARM_INS_CMP,
	ARM_INS_CPS,
	ARM_INS_CRC32B,
	ARM_INS_CRC32CB,
	ARM_INS_CRC32CH,
	ARM_INS_CRC32CW,
	ARM_INS_CRC32H,
	ARM_INS_CRC32W,
	ARM_INS_DBG,
	ARM_INS_DMB,
	ARM_INS_DSB,
	ARM_INS_EOR,
	ARM_INS_ERET,
	ARM_INS_VMOV,
	ARM_INS_FLDMDBX,
	ARM_INS_FLDMIAX,
	ARM_INS_VMRS,
	ARM_INS_FSTMDBX,
	ARM_INS_FSTMIAX,
	ARM_INS_HINT,
	ARM_INS_HLT,
	ARM_INS_HVC,
	ARM_INS_ISB,
	ARM_INS_LDA,
	ARM_INS_LDAB,
	ARM_INS_LDAEX,
	ARM_INS_LDAEXB,
	ARM_INS_LDAEXD,
	ARM_INS_LDAEXH,
	ARM_INS_LDAH,
	ARM_INS_LDC2L,
	ARM_INS_LDC2,
	ARM_INS_LDCL,
	ARM_INS_LDC,
	ARM_INS_LDMDA,
	ARM_INS_LDMDB,
	ARM_INS_LDM,
	ARM_INS_LDMIB,
	ARM_INS_LDRBT,
	ARM_INS_LDRB,
	ARM_INS_LDRD,
	ARM_INS_LDREX,
	ARM_INS_LDREXB,
	ARM_INS_LDREXD,
	ARM_INS_LDREXH,
	ARM_INS_LDRH,
	ARM_INS_LDRHT,
	ARM_INS_LDRSB,
	ARM_INS_LDRSBT,
	ARM_INS_LDRSH,
	ARM_INS_LDRSHT,
	ARM_INS_LDRT,
	ARM_INS_LDR,
	ARM_INS_MCR,
	ARM_INS_MCR2,
	ARM_INS_MCRR,
	ARM_INS_MCRR2,
	ARM_INS_MLA,
	ARM_INS_MLS,
	ARM_INS_MOV,
	ARM_INS_MOVT,
	ARM_INS_MOVW,
	ARM_INS_MRC,
	ARM_INS_MRC2,
	ARM_INS_MRRC,
	ARM_INS_MRRC2,
	ARM_INS_MRS,
	ARM_INS_MSR,
	ARM_INS_MUL,
	ARM_INS_MVN,
	ARM_INS_ORR,
	ARM_INS_PKHBT,
	ARM_INS_PKHTB,
	ARM_INS_PLDW,
	ARM_INS_PLD,
	ARM_INS_PLI,
	ARM_INS_QADD,
	ARM_INS_QADD16,
	ARM_INS_QADD8,
	ARM_INS_QASX,
	ARM_INS_QDADD,
	ARM_INS_QDSUB,
	ARM_INS_QSAX,
	ARM_INS_QSUB,
	ARM_INS_QSUB16,
	ARM_INS_QSUB8,
	ARM_INS_RBIT,
	ARM_INS_REV,
	ARM_INS_REV16,
	ARM_INS_REVSH,
	ARM_INS_RFEDA,
	ARM_INS_RFEDB,
	ARM_INS_RFEIA,
	ARM_INS_RFEIB,
	ARM_INS_RSB,
	ARM_INS_RSC,
	ARM_INS_SADD16,
	ARM_INS_SADD8,
	ARM_INS_SASX,
	ARM_INS_SBC,
	ARM_INS_SBFX,
	ARM_INS_SDIV,
	ARM_INS_SEL,
	ARM_INS_SETEND,
	ARM_INS_SHA1C,
	ARM_INS_SHA1H,
	ARM_INS_SHA1M,
	ARM_INS_SHA1P,
	ARM_INS_SHA1SU0,
	ARM_INS_SHA1SU1,
	ARM_INS_SHA256H,
	ARM_INS_SHA256H2,
	ARM_INS_SHA256SU0,
	ARM_INS_SHA256SU1,
	ARM_INS_SHADD16,
	ARM_INS_SHADD8,
	ARM_INS_SHASX,
	ARM_INS_SHSAX,
	ARM_INS_SHSUB16,
	ARM_INS_SHSUB8,
	ARM_INS_SMC,
	ARM_INS_SMLABB,
	ARM_INS_SMLABT,
	ARM_INS_SMLAD,
	ARM_INS_SMLADX,
	ARM_INS_SMLAL,
	ARM_INS_SMLALBB,
	ARM_INS_SMLALBT,
	ARM_INS_SMLALD,
	ARM_INS_SMLALDX,
	ARM_INS_SMLALTB,
	ARM_INS_SMLALTT,
	ARM_INS_SMLATB,
	ARM_INS_SMLATT,
	ARM_INS_SMLAWB,
	ARM_INS_SMLAWT,
	ARM_INS_SMLSD,
	ARM_INS_SMLSDX,
	ARM_INS_SMLSLD,
	ARM_INS_SMLSLDX,
	ARM_INS_SMMLA,
	ARM_INS_SMMLAR,
	ARM_INS_SMMLS,
	ARM_INS_SMMLSR,
	ARM_INS_SMMUL,
	ARM_INS_SMMULR,
	ARM_INS_SMUAD,
	ARM_INS_SMUADX,
	ARM_INS_SMULBB,
	ARM_INS_SMULBT,
	ARM_INS_SMULL,
	ARM_INS_SMULTB,
	ARM_INS_SMULTT,
	ARM_INS_SMULWB,
	ARM_INS_SMULWT,
	ARM_INS_SMUSD,
	ARM_INS_SMUSDX,
	ARM_INS_SRSDA,
	ARM_INS_SRSDB,
	ARM_INS_SRSIA,
	ARM_INS_SRSIB,
	ARM_INS_SSAT,
	ARM_INS_SSAT16,
	ARM_INS_SSAX,
	ARM_INS_SSUB16,
	ARM_INS_SSUB8,
	ARM_INS_STC2L,
	ARM_INS_STC2,
	ARM_INS_STCL,
	ARM_INS_STC,
	ARM_INS_STL,
	ARM_INS_STLB,
	ARM_INS_STLEX,
	ARM_INS_STLEXB,
	ARM_INS_STLEXD,
	ARM_INS_STLEXH,
	ARM_INS_STLH,
	ARM_INS_STMDA,
	ARM_INS_STMDB,
	ARM_INS_STM,
	ARM_INS_STMIB,
	ARM_INS_STRBT,
	ARM_INS_STRB,
	ARM_INS_STRD,
	ARM_INS_STREX,
	ARM_INS_STREXB,
	ARM_INS_STREXD,
	ARM_INS_STREXH,
	ARM_INS_STRH,
	ARM_INS_STRHT,
	ARM_INS_STRT,
	ARM_INS_STR,
	ARM_INS_SUB,
	ARM_INS_SVC,
	ARM_INS_SWP,
	ARM_INS_SWPB,
	ARM_INS_SXTAB,
	ARM_INS_SXTAB16,
	ARM_INS_SXTAH,
	ARM_INS_SXTB,
	ARM_INS_SXTB16,
	ARM_INS_SXTH,
	ARM_INS_TEQ,
	ARM_INS_TRAP,
	ARM_INS_TST,
	ARM_INS_UADD16,
	ARM_INS_UADD8,
	ARM_INS_UASX,
	ARM_INS_UBFX,
	ARM_INS_UDF,
	ARM_INS_UDIV,
	ARM_INS_UHADD16,
	ARM_INS_UHADD8,
	ARM_INS_UHASX,
	ARM_INS_UHSAX,
	ARM_INS_UHSUB16,
	ARM_INS_UHSUB8,
	ARM_INS_UMAAL,
	ARM_INS_UMLAL,
	ARM_INS_UMULL,
	ARM_INS_UQADD16,
	ARM_INS_UQADD8,
	ARM_INS_UQASX,
	ARM_INS_UQSAX,
	ARM_INS_UQSUB16,
	ARM_INS_UQSUB8,
	ARM_INS_USAD8,
	ARM_INS_USADA8,
	ARM_INS_USAT,
	ARM_INS_USAT16,
	ARM_INS_USAX,
	ARM_INS_USUB16,
	ARM_INS_USUB8,
	ARM_INS_UXTAB,
	ARM_INS_UXTAB16,
	ARM_INS_UXTAH,
	ARM_INS_UXTB,
	ARM_INS_UXTB16,
	ARM_INS_UXTH,
	ARM_INS_VABAL,
	ARM_INS_VABA,
	ARM_INS_VABDL,
	ARM_INS_VABD,
	ARM_INS_VABS,
	ARM_INS_VACGE,
	ARM_INS_VACGT,
	ARM_INS_VADD,
	ARM_INS_VADDHN,
	ARM_INS_VADDL,
	ARM_INS_VADDW,
	ARM_INS_VAND,
	ARM_INS_VBIC,
	ARM_INS_VBIF,
	ARM_INS_VBIT,
	ARM_INS_VBSL,
	ARM_INS_VCEQ,
	ARM_INS_VCGE,
	ARM_INS_VCGT,
	ARM_INS_VCLE,
	ARM_INS_VCLS,
	ARM_INS_VCLT,
	ARM_INS_VCLZ,
	ARM_INS_VCMP,
	ARM_INS_VCMPE,
	ARM_INS_VCNT,
	ARM_INS_VCVTA,
	ARM_INS_VCVTB,
	ARM_INS_VCVT,
	ARM_INS_VCVTM,
	ARM_INS_VCVTN,
	ARM_INS_VCVTP,
	ARM_INS_VCVTT,
	ARM_INS_VDIV,
	ARM_INS_VDUP,
	ARM_INS_VEOR,
	ARM_INS_VEXT,
	ARM_INS_VFMA,
	ARM_INS_VFMS,
	ARM_INS_VFNMA,
	ARM_INS_VFNMS,
	ARM_INS_VHADD,
	ARM_INS_VHSUB,
	ARM_INS_VLD1,
	ARM_INS_VLD2,
	ARM_INS_VLD3,
	ARM_INS_VLD4,
	ARM_INS_VLDMDB,
	ARM_INS_VLDMIA,
	ARM_INS_VLDR,
	ARM_INS_VMAXNM,
	ARM_INS_VMAX,
	ARM_INS_VMINNM,
	ARM_INS_VMIN,
	ARM_INS_VMLA,
	ARM_INS_VMLAL,
	ARM_INS_VMLS,
	ARM_INS_VMLSL,
	ARM_INS_VMOVL,
	ARM_INS_VMOVN,
	ARM_INS_VMSR,
	ARM_INS_VMUL,
	ARM_INS_VMULL,
	ARM_INS_VMVN,
	ARM_INS_VNEG,
	ARM_INS_VNMLA,
	ARM_INS_VNMLS,
	ARM_INS_VNMUL,
	ARM_INS_VORN,
	ARM_INS_VORR,
	ARM_INS_VPADAL,
	ARM_INS_VPADDL,
	ARM_INS_VPADD,
	ARM_INS_VPMAX,
	ARM_INS_VPMIN,
	ARM_INS_VQABS,
	ARM_INS_VQADD,
	ARM_INS_VQDMLAL,
	ARM_INS_VQDMLSL,
	ARM_INS_VQDMULH,
	ARM_INS_VQDMULL,
	ARM_INS_VQMOVUN,
	ARM_INS_VQMOVN,
	ARM_INS_VQNEG,
	ARM_INS_VQRDMULH,
	ARM_INS_VQRSHL,
	ARM_INS_VQRSHRN,
	ARM_INS_VQRSHRUN,
	ARM_INS_VQSHL,
	ARM_INS_VQSHLU,
	ARM_INS_VQSHRN,
	ARM_INS_VQSHRUN,
	ARM_INS_VQSUB,
	ARM_INS_VRADDHN,
	ARM_INS_VRECPE,
	ARM_INS_VRECPS,
	ARM_INS_VREV16,
	ARM_INS_VREV32,
	ARM_INS_VREV64,
	ARM_INS_VRHADD,
	ARM_INS_VRINTA,
	ARM_INS_VRINTM,
	ARM_INS_VRINTN,
	ARM_INS_VRINTP,
	ARM_INS_VRINTR,
	ARM_INS_VRINTX,
	ARM_INS_VRINTZ,
	ARM_INS_VRSHL,
	ARM_INS_VRSHRN,
	ARM_INS_VRSHR,
	ARM_INS_VRSQRTE,
	ARM_INS_VRSQRTS,
	ARM_INS_VRSRA,
	ARM_INS_VRSUBHN,
	ARM_INS_VSELEQ,
	ARM_INS_VSELGE,
	ARM_INS_VSELGT,
	ARM_INS_VSELVS,
	ARM_INS_VSHLL,
	ARM_INS_VSHL,
	ARM_INS_VSHRN,
	ARM_INS_VSHR,
	ARM_INS_VSLI,
	ARM_INS_VSQRT,
	ARM_INS_VSRA,
	ARM_INS_VSRI,
	ARM_INS_VST1,
	ARM_INS_VST2,
	ARM_INS_VST3,
	ARM_INS_VST4,
	ARM_INS_VSTMDB,
	ARM_INS_VSTMIA,
	ARM_INS_VSTR,
	ARM_INS_VSUB,
	ARM_INS_VSUBHN,
	ARM_INS_VSUBL,
	ARM_INS_VSUBW,
	ARM_INS_VSWP,
	ARM_INS_VTBL,
	ARM_INS_VTBX,
	ARM_INS_VCVTR,
	ARM_INS_VTRN,
	ARM_INS_VTST,
	ARM_INS_VUZP,
	ARM_INS_VZIP,
	ARM_INS_ADDW,
	ARM_INS_ASR,
	ARM_INS_DCPS1,
	ARM_INS_DCPS2,
	ARM_INS_DCPS3,
	ARM_INS_IT,
	ARM_INS_LSL,
	ARM_INS_LSR,
	ARM_INS_ORN,
	ARM_INS_ROR,
	ARM_INS_RRX,
	ARM_INS_SUBW,
	ARM_INS_TBB,
	ARM_INS_TBH,
	ARM_INS_CBNZ,
	ARM_INS_CBZ,
	ARM_INS_POP,
	ARM_INS_PUSH,

	// special instructions
	ARM_INS_NOP,
	ARM_INS_YIELD,
	ARM_INS_WFE,
	ARM_INS_WFI,
	ARM_INS_SEV,
	ARM_INS_SEVL,
	ARM_INS_VPUSH,
	ARM_INS_VPOP,

	ARM_INS_ENDING,	// <-- mark the end of the list of instructions
} arm_insn;

/// Group of ARM instructions
typedef enum arm_insn_group {
	ARM_GRP_INVALID = 0, ///< = CS_GRP_INVALID

	// Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	ARM_GRP_JUMP,	///< = CS_GRP_JUMP
	ARM_GRP_CALL,	///< = CS_GRP_CALL
	ARM_GRP_INT = 4, ///< = CS_GRP_INT
	ARM_GRP_PRIVILEGE = 6, ///< = CS_GRP_PRIVILEGE
	ARM_GRP_BRANCH_RELATIVE, ///< = CS_GRP_BRANCH_RELATIVE

	// Architecture-specific groups
	ARM_GRP_CRYPTO = 128,
	ARM_GRP_DATABARRIER,
	ARM_GRP_DIVIDE,
	ARM_GRP_FPARMV8,
	ARM_GRP_MULTPRO,
	ARM_GRP_NEON,
	ARM_GRP_T2EXTRACTPACK,
	ARM_GRP_THUMB2DSP,
	ARM_GRP_TRUSTZONE,
	ARM_GRP_V4T,
	ARM_GRP_V5T,
	ARM_GRP_V5TE,
	ARM_GRP_V6,
	ARM_GRP_V6T2,
	ARM_GRP_V7,
	ARM_GRP_V8,
	ARM_GRP_VFP2,
	ARM_GRP_VFP3,
	ARM_GRP_VFP4,
	ARM_GRP_ARM,
	ARM_GRP_MCLASS,
	ARM_GRP_NOTMCLASS,
	ARM_GRP_THUMB,
	ARM_GRP_THUMB1ONLY,
	ARM_GRP_THUMB2,
	ARM_GRP_PREV8,
	ARM_GRP_FPVMLX,
	ARM_GRP_MULOPS,
	ARM_GRP_CRC,
	ARM_GRP_DPVFP,
	ARM_GRP_V6M,
	ARM_GRP_VIRTUALIZATION,

	ARM_GRP_ENDING,
} arm_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`capstone/include/capstone/arm64.h`:

```h
#ifndef CAPSTONE_ARM64_H
#define CAPSTONE_ARM64_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

/// ARM64 shift type
typedef enum arm64_shifter {
	ARM64_SFT_INVALID = 0,
	ARM64_SFT_LSL = 1,
	ARM64_SFT_MSL = 2,
	ARM64_SFT_LSR = 3,
	ARM64_SFT_ASR = 4,
	ARM64_SFT_ROR = 5,
} arm64_shifter;

/// ARM64 extender type
typedef enum arm64_extender {
	ARM64_EXT_INVALID = 0,
	ARM64_EXT_UXTB = 1,
	ARM64_EXT_UXTH = 2,
	ARM64_EXT_UXTW = 3,
	ARM64_EXT_UXTX = 4,
	ARM64_EXT_SXTB = 5,
	ARM64_EXT_SXTH = 6,
	ARM64_EXT_SXTW = 7,
	ARM64_EXT_SXTX = 8,
} arm64_extender;

/// ARM64 condition code
typedef enum arm64_cc {
	ARM64_CC_INVALID = 0,
	ARM64_CC_EQ = 1,     ///< Equal
	ARM64_CC_NE = 2,     ///< Not equal:                 Not equal, or unordered
	ARM64_CC_HS = 3,     ///< Unsigned higher or same:   >, ==, or unordered
	ARM64_CC_LO = 4,     ///< Unsigned lower or same:    Less than
	ARM64_CC_MI = 5,     ///< Minus, negative:           Less than
	ARM64_CC_PL = 6,     ///< Plus, positive or zero:    >, ==, or unordered
	ARM64_CC_VS = 7,     ///< Overflow:                  Unordered
	ARM64_CC_VC = 8,     ///< No overflow:               Ordered
	ARM64_CC_HI = 9,     ///< Unsigned higher:           Greater than, or unordered
	ARM64_CC_LS = 10,     ///< Unsigned lower or same:    Less than or equal
	ARM64_CC_GE = 11,     ///< Greater than or equal:     Greater than or equal
	ARM64_CC_LT = 12,     ///< Less than:                 Less than, or unordered
	ARM64_CC_GT = 13,     ///< Signed greater than:       Greater than
	ARM64_CC_LE = 14,     ///< Signed less than or equal: <, ==, or unordered
	ARM64_CC_AL = 15,     ///< Always (unconditional):    Always (unconditional)
	ARM64_CC_NV = 16,     ///< Always (unconditional):   Always (unconditional)
	//< Note the NV exists purely to disassemble 0b1111. Execution
	//< is "always".
} arm64_cc;

/// System registers
typedef enum arm64_sysreg {
	// System registers for MRS
	ARM64_SYSREG_INVALID           = 0,
	ARM64_SYSREG_MDCCSR_EL0        = 0x9808, // 10  011  0000  0001  000
	ARM64_SYSREG_DBGDTRRX_EL0      = 0x9828, // 10  011  0000  0101  000
	ARM64_SYSREG_MDRAR_EL1         = 0x8080, // 10  000  0001  0000  000
	ARM64_SYSREG_OSLSR_EL1         = 0x808c, // 10  000  0001  0001  100
	ARM64_SYSREG_DBGAUTHSTATUS_EL1 = 0x83f6, // 10  000  0111  1110  110
	ARM64_SYSREG_PMCEID0_EL0       = 0xdce6, // 11  011  1001  1100  110
	ARM64_SYSREG_PMCEID1_EL0       = 0xdce7, // 11  011  1001  1100  111
	ARM64_SYSREG_MIDR_EL1          = 0xc000, // 11  000  0000  0000  000
	ARM64_SYSREG_CCSIDR_EL1        = 0xc800, // 11  001  0000  0000  000
	ARM64_SYSREG_CLIDR_EL1         = 0xc801, // 11  001  0000  0000  001
	ARM64_SYSREG_CTR_EL0           = 0xd801, // 11  011  0000  0000  001
	ARM64_SYSREG_MPIDR_EL1         = 0xc005, // 11  000  0000  0000  101
	ARM64_SYSREG_REVIDR_EL1        = 0xc006, // 11  000  0000  0000  110
	ARM64_SYSREG_AIDR_EL1          = 0xc807, // 11  001  0000  0000  111
	ARM64_SYSREG_DCZID_EL0         = 0xd807, // 11  011  0000  0000  111
	ARM64_SYSREG_ID_PFR0_EL1       = 0xc008, // 11  000  0000  0001  000
	ARM64_SYSREG_ID_PFR1_EL1       = 0xc009, // 11  000  0000  0001  001
	ARM64_SYSREG_ID_DFR0_EL1       = 0xc00a, // 11  000  0000  0001  010
	ARM64_SYSREG_ID_AFR0_EL1       = 0xc00b, // 11  000  0000  0001  011
	ARM64_SYSREG_ID_MMFR0_EL1      = 0xc00c, // 11  000  0000  0001  100
	ARM64_SYSREG_ID_MMFR1_EL1      = 0xc00d, // 11  000  0000  0001  101
	ARM64_SYSREG_ID_MMFR2_EL1      = 0xc00e, // 11  000  0000  0001  110
	ARM64_SYSREG_ID_MMFR3_EL1      = 0xc00f, // 11  000  0000  0001  111
	ARM64_SYSREG_ID_ISAR0_EL1      = 0xc010, // 11  000  0000  0010  000
	ARM64_SYSREG_ID_ISAR1_EL1      = 0xc011, // 11  000  0000  0010  001
	ARM64_SYSREG_ID_ISAR2_EL1      = 0xc012, // 11  000  0000  0010  010
	ARM64_SYSREG_ID_ISAR3_EL1      = 0xc013, // 11  000  0000  0010  011
	ARM64_SYSREG_ID_ISAR4_EL1      = 0xc014, // 11  000  0000  0010  100
	ARM64_SYSREG_ID_ISAR5_EL1      = 0xc015, // 11  000  0000  0010  101
	ARM64_SYSREG_ID_A64PFR0_EL1   = 0xc020, // 11  000  0000  0100  000
	ARM64_SYSREG_ID_A64PFR1_EL1   = 0xc021, // 11  000  0000  0100  001
	ARM64_SYSREG_ID_A64DFR0_EL1   = 0xc028, // 11  000  0000  0101  000
	ARM64_SYSREG_ID_A64DFR1_EL1   = 0xc029, // 11  000  0000  0101  001
	ARM64_SYSREG_ID_A64AFR0_EL1   = 0xc02c, // 11  000  0000  0101  100
	ARM64_SYSREG_ID_A64AFR1_EL1   = 0xc02d, // 11  000  0000  0101  101
	ARM64_SYSREG_ID_A64ISAR0_EL1  = 0xc030, // 11  000  0000  0110  000
	ARM64_SYSREG_ID_A64ISAR1_EL1  = 0xc031, // 11  000  0000  0110  001
	ARM64_SYSREG_ID_A64MMFR0_EL1  = 0xc038, // 11  000  0000  0111  000
	ARM64_SYSREG_ID_A64MMFR1_EL1  = 0xc039, // 11  000  0000  0111  001
	ARM64_SYSREG_MVFR0_EL1         = 0xc018, // 11  000  0000  0011  000
	ARM64_SYSREG_MVFR1_EL1         = 0xc019, // 11  000  0000  0011  001
	ARM64_SYSREG_MVFR2_EL1         = 0xc01a, // 11  000  0000  0011  010
	ARM64_SYSREG_RVBAR_EL1         = 0xc601, // 11  000  1100  0000  001
	ARM64_SYSREG_RVBAR_EL2         = 0xe601, // 11  100  1100  0000  001
	ARM64_SYSREG_RVBAR_EL3         = 0xf601, // 11  110  1100  0000  001
	ARM64_SYSREG_ISR_EL1           = 0xc608, // 11  000  1100  0001  000
	ARM64_SYSREG_CNTPCT_EL0        = 0xdf01, // 11  011  1110  0000  001
	ARM64_SYSREG_CNTVCT_EL0        = 0xdf02,  // 11  011  1110  0000  010

	// Trace registers
	ARM64_SYSREG_TRCSTATR          = 0x8818, // 10  001  0000  0011  000
	ARM64_SYSREG_TRCIDR8           = 0x8806, // 10  001  0000  0000  110
	ARM64_SYSREG_TRCIDR9           = 0x880e, // 10  001  0000  0001  110
	ARM64_SYSREG_TRCIDR10          = 0x8816, // 10  001  0000  0010  110
	ARM64_SYSREG_TRCIDR11          = 0x881e, // 10  001  0000  0011  110
	ARM64_SYSREG_TRCIDR12          = 0x8826, // 10  001  0000  0100  110
	ARM64_SYSREG_TRCIDR13          = 0x882e, // 10  001  0000  0101  110
	ARM64_SYSREG_TRCIDR0           = 0x8847, // 10  001  0000  1000  111
	ARM64_SYSREG_TRCIDR1           = 0x884f, // 10  001  0000  1001  111
	ARM64_SYSREG_TRCIDR2           = 0x8857, // 10  001  0000  1010  111
	ARM64_SYSREG_TRCIDR3           = 0x885f, // 10  001  0000  1011  111
	ARM64_SYSREG_TRCIDR4           = 0x8867, // 10  001  0000  1100  111
	ARM64_SYSREG_TRCIDR5           = 0x886f, // 10  001  0000  1101  111
	ARM64_SYSREG_TRCIDR6           = 0x8877, // 10  001  0000  1110  111
	ARM64_SYSREG_TRCIDR7           = 0x887f, // 10  001  0000  1111  111
	ARM64_SYSREG_TRCOSLSR          = 0x888c, // 10  001  0001  0001  100
	ARM64_SYSREG_TRCPDSR           = 0x88ac, // 10  001  0001  0101  100
	ARM64_SYSREG_TRCDEVAFF0        = 0x8bd6, // 10  001  0111  1010  110
	ARM64_SYSREG_TRCDEVAFF1        = 0x8bde, // 10  001  0111  1011  110
	ARM64_SYSREG_TRCLSR            = 0x8bee, // 10  001  0111  1101  110
	ARM64_SYSREG_TRCAUTHSTATUS     = 0x8bf6, // 10  001  0111  1110  110
	ARM64_SYSREG_TRCDEVARCH        = 0x8bfe, // 10  001  0111  1111  110
	ARM64_SYSREG_TRCDEVID          = 0x8b97, // 10  001  0111  0010  111
	ARM64_SYSREG_TRCDEVTYPE        = 0x8b9f, // 10  001  0111  0011  111
	ARM64_SYSREG_TRCPIDR4          = 0x8ba7, // 10  001  0111  0100  111
	ARM64_SYSREG_TRCPIDR5          = 0x8baf, // 10  001  0111  0101  111
	ARM64_SYSREG_TRCPIDR6          = 0x8bb7, // 10  001  0111  0110  111
	ARM64_SYSREG_TRCPIDR7          = 0x8bbf, // 10  001  0111  0111  111
	ARM64_SYSREG_TRCPIDR0          = 0x8bc7, // 10  001  0111  1000  111
	ARM64_SYSREG_TRCPIDR1          = 0x8bcf, // 10  001  0111  1001  111
	ARM64_SYSREG_TRCPIDR2          = 0x8bd7, // 10  001  0111  1010  111
	ARM64_SYSREG_TRCPIDR3          = 0x8bdf, // 10  001  0111  1011  111
	ARM64_SYSREG_TRCCIDR0          = 0x8be7, // 10  001  0111  1100  111
	ARM64_SYSREG_TRCCIDR1          = 0x8bef, // 10  001  0111  1101  111
	ARM64_SYSREG_TRCCIDR2          = 0x8bf7, // 10  001  0111  1110  111
	ARM64_SYSREG_TRCCIDR3          = 0x8bff, // 10  001  0111  1111  111

	// GICv3 registers
	ARM64_SYSREG_ICC_IAR1_EL1      = 0xc660, // 11  000  1100  1100  000
	ARM64_SYSREG_ICC_IAR0_EL1      = 0xc640, // 11  000  1100  1000  000
	ARM64_SYSREG_ICC_HPPIR1_EL1    = 0xc662, // 11  000  1100  1100  010
	ARM64_SYSREG_ICC_HPPIR0_EL1    = 0xc642, // 11  000  1100  1000  010
	ARM64_SYSREG_ICC_RPR_EL1       = 0xc65b, // 11  000  1100  1011  011
	ARM64_SYSREG_ICH_VTR_EL2       = 0xe659, // 11  100  1100  1011  001
	ARM64_SYSREG_ICH_EISR_EL2      = 0xe65b, // 11  100  1100  1011  011
	ARM64_SYSREG_ICH_ELSR_EL2      = 0xe65d, // 11  100  1100  1011  101
} arm64_sysreg;

typedef enum arm64_msr_reg {
	// System registers for MSR
	ARM64_SYSREG_DBGDTRTX_EL0      = 0x9828, // 10  011  0000  0101  000
	ARM64_SYSREG_OSLAR_EL1         = 0x8084, // 10  000  0001  0000  100
	ARM64_SYSREG_PMSWINC_EL0       = 0xdce4,  // 11  011  1001  1100  100

	// Trace Registers
	ARM64_SYSREG_TRCOSLAR          = 0x8884, // 10  001  0001  0000  100
	ARM64_SYSREG_TRCLAR            = 0x8be6, // 10  001  0111  1100  110

	// GICv3 registers
	ARM64_SYSREG_ICC_EOIR1_EL1     = 0xc661, // 11  000  1100  1100  001
	ARM64_SYSREG_ICC_EOIR0_EL1     = 0xc641, // 11  000  1100  1000  001
	ARM64_SYSREG_ICC_DIR_EL1       = 0xc659, // 11  000  1100  1011  001
	ARM64_SYSREG_ICC_SGI1R_EL1     = 0xc65d, // 11  000  1100  1011  101
	ARM64_SYSREG_ICC_ASGI1R_EL1    = 0xc65e, // 11  000  1100  1011  110
	ARM64_SYSREG_ICC_SGI0R_EL1     = 0xc65f, // 11  000  1100  1011  111
} arm64_msr_reg;

/// System PState Field (MSR instruction)
typedef enum arm64_pstate {
	ARM64_PSTATE_INVALID = 0,
	ARM64_PSTATE_SPSEL = 0x05,
	ARM64_PSTATE_DAIFSET = 0x1e,
	ARM64_PSTATE_DAIFCLR = 0x1f
} arm64_pstate;

/// Vector arrangement specifier (for FloatingPoint/Advanced SIMD insn)
typedef enum arm64_vas {
	ARM64_VAS_INVALID = 0,
	ARM64_VAS_8B,
	ARM64_VAS_16B,
	ARM64_VAS_4H,
	ARM64_VAS_8H,
	ARM64_VAS_2S,
	ARM64_VAS_4S,
	ARM64_VAS_1D,
	ARM64_VAS_2D,
	ARM64_VAS_1Q,
} arm64_vas;

/// Vector element size specifier
typedef enum arm64_vess {
	ARM64_VESS_INVALID = 0,
	ARM64_VESS_B,
	ARM64_VESS_H,
	ARM64_VESS_S,
	ARM64_VESS_D,
} arm64_vess;

/// Memory barrier operands
typedef enum arm64_barrier_op {
	ARM64_BARRIER_INVALID = 0,
	ARM64_BARRIER_OSHLD = 0x1,
	ARM64_BARRIER_OSHST = 0x2,
	ARM64_BARRIER_OSH =   0x3,
	ARM64_BARRIER_NSHLD = 0x5,
	ARM64_BARRIER_NSHST = 0x6,
	ARM64_BARRIER_NSH =   0x7,
	ARM64_BARRIER_ISHLD = 0x9,
	ARM64_BARRIER_ISHST = 0xa,
	ARM64_BARRIER_ISH =   0xb,
	ARM64_BARRIER_LD =    0xd,
	ARM64_BARRIER_ST =    0xe,
	ARM64_BARRIER_SY =    0xf
} arm64_barrier_op;

/// Operand type for instruction's operands
typedef enum arm64_op_type {
	ARM64_OP_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	ARM64_OP_REG, ///< = CS_OP_REG (Register operand).
	ARM64_OP_IMM, ///< = CS_OP_IMM (Immediate operand).
	ARM64_OP_MEM, ///< = CS_OP_MEM (Memory operand).
	ARM64_OP_FP,  ///< = CS_OP_FP (Floating-Point operand).
	ARM64_OP_CIMM = 64, ///< C-Immediate
	ARM64_OP_REG_MRS, ///< MRS register operand.
	ARM64_OP_REG_MSR, ///< MSR register operand.
	ARM64_OP_PSTATE, ///< PState operand.
	ARM64_OP_SYS, ///< SYS operand for IC/DC/AT/TLBI instructions.
	ARM64_OP_PREFETCH, ///< Prefetch operand (PRFM).
	ARM64_OP_BARRIER, ///< Memory barrier operand (ISB/DMB/DSB instructions).
} arm64_op_type;

/// TLBI operations
typedef enum arm64_tlbi_op {
	ARM64_TLBI_INVALID = 0,
	ARM64_TLBI_VMALLE1IS,
	ARM64_TLBI_VAE1IS,
	ARM64_TLBI_ASIDE1IS,
	ARM64_TLBI_VAAE1IS,
	ARM64_TLBI_VALE1IS,
	ARM64_TLBI_VAALE1IS,
	ARM64_TLBI_ALLE2IS,
	ARM64_TLBI_VAE2IS,
	ARM64_TLBI_ALLE1IS,
	ARM64_TLBI_VALE2IS,
	ARM64_TLBI_VMALLS12E1IS,
	ARM64_TLBI_ALLE3IS,
	ARM64_TLBI_VAE3IS,
	ARM64_TLBI_VALE3IS,
	ARM64_TLBI_IPAS2E1IS,
	ARM64_TLBI_IPAS2LE1IS,
	ARM64_TLBI_IPAS2E1,
	ARM64_TLBI_IPAS2LE1,
	ARM64_TLBI_VMALLE1,
	ARM64_TLBI_VAE1,
	ARM64_TLBI_ASIDE1,
	ARM64_TLBI_VAAE1,
	ARM64_TLBI_VALE1,
	ARM64_TLBI_VAALE1,
	ARM64_TLBI_ALLE2,
	ARM64_TLBI_VAE2,
	ARM64_TLBI_ALLE1,
	ARM64_TLBI_VALE2,
	ARM64_TLBI_VMALLS12E1,
	ARM64_TLBI_ALLE3,
	ARM64_TLBI_VAE3,
	ARM64_TLBI_VALE3,
} arm64_tlbi_op;

/// AT operations
typedef enum arm64_at_op {
	ARM64_AT_S1E1R,
	ARM64_AT_S1E1W,
	ARM64_AT_S1E0R,
	ARM64_AT_S1E0W,
	ARM64_AT_S1E2R,
	ARM64_AT_S1E2W,
	ARM64_AT_S12E1R,
	ARM64_AT_S12E1W,
	ARM64_AT_S12E0R,
	ARM64_AT_S12E0W,
	ARM64_AT_S1E3R,
	ARM64_AT_S1E3W,
} arm64_at_op;

/// DC operations
typedef enum arm64_dc_op {
	ARM64_DC_INVALID = 0,
	ARM64_DC_ZVA,
	ARM64_DC_IVAC,
	ARM64_DC_ISW,
	ARM64_DC_CVAC,
	ARM64_DC_CSW,
	ARM64_DC_CVAU,
	ARM64_DC_CIVAC,
	ARM64_DC_CISW,
} arm64_dc_op;

/// IC operations
typedef enum arm64_ic_op {
	ARM64_IC_INVALID = 0,
	ARM64_IC_IALLUIS,
	ARM64_IC_IALLU,
	ARM64_IC_IVAU,
} arm64_ic_op;

/// Prefetch operations (PRFM)
typedef enum arm64_prefetch_op {
	ARM64_PRFM_INVALID = 0,
	ARM64_PRFM_PLDL1KEEP = 0x00 + 1,
	ARM64_PRFM_PLDL1STRM = 0x01 + 1,
	ARM64_PRFM_PLDL2KEEP = 0x02 + 1,
	ARM64_PRFM_PLDL2STRM = 0x03 + 1,
	ARM64_PRFM_PLDL3KEEP = 0x04 + 1,
	ARM64_PRFM_PLDL3STRM = 0x05 + 1,
	ARM64_PRFM_PLIL1KEEP = 0x08 + 1,
	ARM64_PRFM_PLIL1STRM = 0x09 + 1,
	ARM64_PRFM_PLIL2KEEP = 0x0a + 1,
	ARM64_PRFM_PLIL2STRM = 0x0b + 1,
	ARM64_PRFM_PLIL3KEEP = 0x0c + 1,
	ARM64_PRFM_PLIL3STRM = 0x0d + 1,
	ARM64_PRFM_PSTL1KEEP = 0x10 + 1,
	ARM64_PRFM_PSTL1STRM = 0x11 + 1,
	ARM64_PRFM_PSTL2KEEP = 0x12 + 1,
	ARM64_PRFM_PSTL2STRM = 0x13 + 1,
	ARM64_PRFM_PSTL3KEEP = 0x14 + 1,
	ARM64_PRFM_PSTL3STRM = 0x15 + 1,
} arm64_prefetch_op;


/// ARM64 registers
typedef enum arm64_reg {
	ARM64_REG_INVALID = 0,

	ARM64_REG_X29,
	ARM64_REG_X30,
	ARM64_REG_NZCV,
	ARM64_REG_SP,
	ARM64_REG_WSP,
	ARM64_REG_WZR,
	ARM64_REG_XZR,
	ARM64_REG_B0,
	ARM64_REG_B1,
	ARM64_REG_B2,
	ARM64_REG_B3,
	ARM64_REG_B4,
	ARM64_REG_B5,
	ARM64_REG_B6,
	ARM64_REG_B7,
	ARM64_REG_B8,
	ARM64_REG_B9,
	ARM64_REG_B10,
	ARM64_REG_B11,
	ARM64_REG_B12,
	ARM64_REG_B13,
	ARM64_REG_B14,
	ARM64_REG_B15,
	ARM64_REG_B16,
	ARM64_REG_B17,
	ARM64_REG_B18,
	ARM64_REG_B19,
	ARM64_REG_B20,
	ARM64_REG_B21,
	ARM64_REG_B22,
	ARM64_REG_B23,
	ARM64_REG_B24,
	ARM64_REG_B25,
	ARM64_REG_B26,
	ARM64_REG_B27,
	ARM64_REG_B28,
	ARM64_REG_B29,
	ARM64_REG_B30,
	ARM64_REG_B31,
	ARM64_REG_D0,
	ARM64_REG_D1,
	ARM64_REG_D2,
	ARM64_REG_D3,
	ARM64_REG_D4,
	ARM64_REG_D5,
	ARM64_REG_D6,
	ARM64_REG_D7,
	ARM64_REG_D8,
	ARM64_REG_D9,
	ARM64_REG_D10,
	ARM64_REG_D11,
	ARM64_REG_D12,
	ARM64_REG_D13,
	ARM64_REG_D14,
	ARM64_REG_D15,
	ARM64_REG_D16,
	ARM64_REG_D17,
	ARM64_REG_D18,
	ARM64_REG_D19,
	ARM64_REG_D20,
	ARM64_REG_D21,
	ARM64_REG_D22,
	ARM64_REG_D23,
	ARM64_REG_D24,
	ARM64_REG_D25,
	ARM64_REG_D26,
	ARM64_REG_D27,
	ARM64_REG_D28,
	ARM64_REG_D29,
	ARM64_REG_D30,
	ARM64_REG_D31,
	ARM64_REG_H0,
	ARM64_REG_H1,
	ARM64_REG_H2,
	ARM64_REG_H3,
	ARM64_REG_H4,
	ARM64_REG_H5,
	ARM64_REG_H6,
	ARM64_REG_H7,
	ARM64_REG_H8,
	ARM64_REG_H9,
	ARM64_REG_H10,
	ARM64_REG_H11,
	ARM64_REG_H12,
	ARM64_REG_H13,
	ARM64_REG_H14,
	ARM64_REG_H15,
	ARM64_REG_H16,
	ARM64_REG_H17,
	ARM64_REG_H18,
	ARM64_REG_H19,
	ARM64_REG_H20,
	ARM64_REG_H21,
	ARM64_REG_H22,
	ARM64_REG_H23,
	ARM64_REG_H24,
	ARM64_REG_H25,
	ARM64_REG_H26,
	ARM64_REG_H27,
	ARM64_REG_H28,
	ARM64_REG_H29,
	ARM64_REG_H30,
	ARM64_REG_H31,
	ARM64_REG_Q0,
	ARM64_REG_Q1,
	ARM64_REG_Q2,
	ARM64_REG_Q3,
	ARM64_REG_Q4,
	ARM64_REG_Q5,
	ARM64_REG_Q6,
	ARM64_REG_Q7,
	ARM64_REG_Q8,
	ARM64_REG_Q9,
	ARM64_REG_Q10,
	ARM64_REG_Q11,
	ARM64_REG_Q12,
	ARM64_REG_Q13,
	ARM64_REG_Q14,
	ARM64_REG_Q15,
	ARM64_REG_Q16,
	ARM64_REG_Q17,
	ARM64_REG_Q18,
	ARM64_REG_Q19,
	ARM64_REG_Q20,
	ARM64_REG_Q21,
	ARM64_REG_Q22,
	ARM64_REG_Q23,
	ARM64_REG_Q24,
	ARM64_REG_Q25,
	ARM64_REG_Q26,
	ARM64_REG_Q27,
	ARM64_REG_Q28,
	ARM64_REG_Q29,
	ARM64_REG_Q30,
	ARM64_REG_Q31,
	ARM64_REG_S0,
	ARM64_REG_S1,
	ARM64_REG_S2,
	ARM64_REG_S3,
	ARM64_REG_S4,
	ARM64_REG_S5,
	ARM64_REG_S6,
	ARM64_REG_S7,
	ARM64_REG_S8,
	ARM64_REG_S9,
	ARM64_REG_S10,
	ARM64_REG_S11,
	ARM64_REG_S12,
	ARM64_REG_S13,
	ARM64_REG_S14,
	ARM64_REG_S15,
	ARM64_REG_S16,
	ARM64_REG_S17,
	ARM64_REG_S18,
	ARM64_REG_S19,
	ARM64_REG_S20,
	ARM64_REG_S21,
	ARM64_REG_S22,
	ARM64_REG_S23,
	ARM64_REG_S24,
	ARM64_REG_S25,
	ARM64_REG_S26,
	ARM64_REG_S27,
	ARM64_REG_S28,
	ARM64_REG_S29,
	ARM64_REG_S30,
	ARM64_REG_S31,
	ARM64_REG_W0,
	ARM64_REG_W1,
	ARM64_REG_W2,
	ARM64_REG_W3,
	ARM64_REG_W4,
	ARM64_REG_W5,
	ARM64_REG_W6,
	ARM64_REG_W7,
	ARM64_REG_W8,
	ARM64_REG_W9,
	ARM64_REG_W10,
	ARM64_REG_W11,
	ARM64_REG_W12,
	ARM64_REG_W13,
	ARM64_REG_W14,
	ARM64_REG_W15,
	ARM64_REG_W16,
	ARM64_REG_W17,
	ARM64_REG_W18,
	ARM64_REG_W19,
	ARM64_REG_W20,
	ARM64_REG_W21,
	ARM64_REG_W22,
	ARM64_REG_W23,
	ARM64_REG_W24,
	ARM64_REG_W25,
	ARM64_REG_W26,
	ARM64_REG_W27,
	ARM64_REG_W28,
	ARM64_REG_W29,
	ARM64_REG_W30,
	ARM64_REG_X0,
	ARM64_REG_X1,
	ARM64_REG_X2,
	ARM64_REG_X3,
	ARM64_REG_X4,
	ARM64_REG_X5,
	ARM64_REG_X6,
	ARM64_REG_X7,
	ARM64_REG_X8,
	ARM64_REG_X9,
	ARM64_REG_X10,
	ARM64_REG_X11,
	ARM64_REG_X12,
	ARM64_REG_X13,
	ARM64_REG_X14,
	ARM64_REG_X15,
	ARM64_REG_X16,
	ARM64_REG_X17,
	ARM64_REG_X18,
	ARM64_REG_X19,
	ARM64_REG_X20,
	ARM64_REG_X21,
	ARM64_REG_X22,
	ARM64_REG_X23,
	ARM64_REG_X24,
	ARM64_REG_X25,
	ARM64_REG_X26,
	ARM64_REG_X27,
	ARM64_REG_X28,

	ARM64_REG_V0,
	ARM64_REG_V1,
	ARM64_REG_V2,
	ARM64_REG_V3,
	ARM64_REG_V4,
	ARM64_REG_V5,
	ARM64_REG_V6,
	ARM64_REG_V7,
	ARM64_REG_V8,
	ARM64_REG_V9,
	ARM64_REG_V10,
	ARM64_REG_V11,
	ARM64_REG_V12,
	ARM64_REG_V13,
	ARM64_REG_V14,
	ARM64_REG_V15,
	ARM64_REG_V16,
	ARM64_REG_V17,
	ARM64_REG_V18,
	ARM64_REG_V19,
	ARM64_REG_V20,
	ARM64_REG_V21,
	ARM64_REG_V22,
	ARM64_REG_V23,
	ARM64_REG_V24,
	ARM64_REG_V25,
	ARM64_REG_V26,
	ARM64_REG_V27,
	ARM64_REG_V28,
	ARM64_REG_V29,
	ARM64_REG_V30,
	ARM64_REG_V31,

	ARM64_REG_ENDING,		// <-- mark the end of the list of registers

	// alias registers

	ARM64_REG_IP0 = ARM64_REG_X16,
	ARM64_REG_IP1 = ARM64_REG_X17,
	ARM64_REG_FP = ARM64_REG_X29,
	ARM64_REG_LR = ARM64_REG_X30,
} arm64_reg;

/// Instruction's operand referring to memory
/// This is associated with ARM64_OP_MEM operand type above
typedef struct arm64_op_mem {
	arm64_reg base;	///< base register
	arm64_reg index;	///< index register
	int32_t disp;	///< displacement/offset value
} arm64_op_mem;

/// Instruction operand
typedef struct cs_arm64_op {
	int vector_index;	///< Vector Index for some vector operands (or -1 if irrelevant)
	arm64_vas vas;		///< Vector Arrangement Specifier
	arm64_vess vess;	///< Vector Element Size Specifier
	struct {
		arm64_shifter type;	///< shifter type of this operand
		unsigned int value;	///< shifter value of this operand
	} shift;
	arm64_extender ext;		///< extender type of this operand
	arm64_op_type type;	///< operand type
	union {
		arm64_reg reg;	///< register value for REG operand
		int64_t imm;		///< immediate value, or index for C-IMM or IMM operand
		double fp;			///< floating point value for FP operand
		arm64_op_mem mem;		///< base/index/scale/disp value for MEM operand
		arm64_pstate pstate;		///< PState field of MSR instruction.
		unsigned int sys;  ///< IC/DC/AT/TLBI operation (see arm64_ic_op, arm64_dc_op, arm64_at_op, arm64_tlbi_op)
		arm64_prefetch_op prefetch;  ///< PRFM operation.
		arm64_barrier_op barrier;  ///< Memory barrier operation (ISB/DMB/DSB instructions).
	};

	/// How is this operand accessed? (READ, WRITE or READ|WRITE)
	/// This field is combined of cs_ac_type.
	/// NOTE: this field is irrelevant if engine is compiled in DIET mode.
	uint8_t access;
} cs_arm64_op;

/// Instruction structure
typedef struct cs_arm64 {
	arm64_cc cc;	///< conditional code for this insn
	bool update_flags;	///< does this insn update flags?
	bool writeback;	///< does this insn request writeback? 'True' means 'yes'

	/// Number of operands of this instruction,
	/// or 0 when instruction has no operand.
	uint8_t op_count;

	cs_arm64_op operands[8]; ///< operands for this instruction.
} cs_arm64;

/// ARM64 instruction
typedef enum arm64_insn {
	ARM64_INS_INVALID = 0,

	ARM64_INS_ABS,
	ARM64_INS_ADC,
	ARM64_INS_ADDHN,
	ARM64_INS_ADDHN2,
	ARM64_INS_ADDP,
	ARM64_INS_ADD,
	ARM64_INS_ADDV,
	ARM64_INS_ADR,
	ARM64_INS_ADRP,
	ARM64_INS_AESD,
	ARM64_INS_AESE,
	ARM64_INS_AESIMC,
	ARM64_INS_AESMC,
	ARM64_INS_AND,
	ARM64_INS_ASR,
	ARM64_INS_B,
	ARM64_INS_BFM,
	ARM64_INS_BIC,
	ARM64_INS_BIF,
	ARM64_INS_BIT,
	ARM64_INS_BL,
	ARM64_INS_BLR,
	ARM64_INS_BR,
	ARM64_INS_BRK,
	ARM64_INS_BSL,
	ARM64_INS_CBNZ,
	ARM64_INS_CBZ,
	ARM64_INS_CCMN,
	ARM64_INS_CCMP,
	ARM64_INS_CLREX,
	ARM64_INS_CLS,
	ARM64_INS_CLZ,
	ARM64_INS_CMEQ,
	ARM64_INS_CMGE,
	ARM64_INS_CMGT,
	ARM64_INS_CMHI,
	ARM64_INS_CMHS,
	ARM64_INS_CMLE,
	ARM64_INS_CMLT,
	ARM64_INS_CMTST,
	ARM64_INS_CNT,
	ARM64_INS_MOV,
	ARM64_INS_CRC32B,
	ARM64_INS_CRC32CB,
	ARM64_INS_CRC32CH,
	ARM64_INS_CRC32CW,
	ARM64_INS_CRC32CX,
	ARM64_INS_CRC32H,
	ARM64_INS_CRC32W,
	ARM64_INS_CRC32X,
	ARM64_INS_CSEL,
	ARM64_INS_CSINC,
	ARM64_INS_CSINV,
	ARM64_INS_CSNEG,
	ARM64_INS_DCPS1,
	ARM64_INS_DCPS2,
	ARM64_INS_DCPS3,
	ARM64_INS_DMB,
	ARM64_INS_DRPS,
	ARM64_INS_DSB,
	ARM64_INS_DUP,
	ARM64_INS_EON,
	ARM64_INS_EOR,
	ARM64_INS_ERET,
	ARM64_INS_EXTR,
	ARM64_INS_EXT,
	ARM64_INS_FABD,
	ARM64_INS_FABS,
	ARM64_INS_FACGE,
	ARM64_INS_FACGT,
	ARM64_INS_FADD,
	ARM64_INS_FADDP,
	ARM64_INS_FCCMP,
	ARM64_INS_FCCMPE,
	ARM64_INS_FCMEQ,
	ARM64_INS_FCMGE,
	ARM64_INS_FCMGT,
	ARM64_INS_FCMLE,
	ARM64_INS_FCMLT,
	ARM64_INS_FCMP,
	ARM64_INS_FCMPE,
	ARM64_INS_FCSEL,
	ARM64_INS_FCVTAS,
	ARM64_INS_FCVTAU,
	ARM64_INS_FCVT,
	ARM64_INS_FCVTL,
	ARM64_INS_FCVTL2,
	ARM64_INS_FCVTMS,
	ARM64_INS_FCVTMU,
	ARM64_INS_FCVTNS,
	ARM64_INS_FCVTNU,
	ARM64_INS_FCVTN,
	ARM64_INS_FCVTN2,
	ARM64_INS_FCVTPS,
	ARM64_INS_FCVTPU,
	ARM64_INS_FCVTXN,
	ARM64_INS_FCVTXN2,
	ARM64_INS_FCVTZS,
	ARM64_INS_FCVTZU,
	ARM64_INS_FDIV,
	ARM64_INS_FMADD,
	ARM64_INS_FMAX,
	ARM64_INS_FMAXNM,
	ARM64_INS_FMAXNMP,
	ARM64_INS_FMAXNMV,
	ARM64_INS_FMAXP,
	ARM64_INS_FMAXV,
	ARM64_INS_FMIN,
	ARM64_INS_FMINNM,
	ARM64_INS_FMINNMP,
	ARM64_INS_FMINNMV,
	ARM64_INS_FMINP,
	ARM64_INS_FMINV,
	ARM64_INS_FMLA,
	ARM64_INS_FMLS,
	ARM64_INS_FMOV,
	ARM64_INS_FMSUB,
	ARM64_INS_FMUL,
	ARM64_INS_FMULX,
	ARM64_INS_FNEG,
	ARM64_INS_FNMADD,
	ARM64_INS_FNMSUB,
	ARM64_INS_FNMUL,
	ARM64_INS_FRECPE,
	ARM64_INS_FRECPS,
	ARM64_INS_FRECPX,
	ARM64_INS_FRINTA,
	ARM64_INS_FRINTI,
	ARM64_INS_FRINTM,
	ARM64_INS_FRINTN,
	ARM64_INS_FRINTP,
	ARM64_INS_FRINTX,
	ARM64_INS_FRINTZ,
	ARM64_INS_FRSQRTE,
	ARM64_INS_FRSQRTS,
	ARM64_INS_FSQRT,
	ARM64_INS_FSUB,
	ARM64_INS_HINT,
	ARM64_INS_HLT,
	ARM64_INS_HVC,
	ARM64_INS_INS,

	ARM64_INS_ISB,
	ARM64_INS_LD1,
	ARM64_INS_LD1R,
	ARM64_INS_LD2R,
	ARM64_INS_LD2,
	ARM64_INS_LD3R,
	ARM64_INS_LD3,
	ARM64_INS_LD4,
	ARM64_INS_LD4R,

	ARM64_INS_LDARB,
	ARM64_INS_LDARH,
	ARM64_INS_LDAR,
	ARM64_INS_LDAXP,
	ARM64_INS_LDAXRB,
	ARM64_INS_LDAXRH,
	ARM64_INS_LDAXR,
	ARM64_INS_LDNP,
	ARM64_INS_LDP,
	ARM64_INS_LDPSW,
	ARM64_INS_LDRB,
	ARM64_INS_LDR,
	ARM64_INS_LDRH,
	ARM64_INS_LDRSB,
	ARM64_INS_LDRSH,
	ARM64_INS_LDRSW,
	ARM64_INS_LDTRB,
	ARM64_INS_LDTRH,
	ARM64_INS_LDTRSB,

	ARM64_INS_LDTRSH,
	ARM64_INS_LDTRSW,
	ARM64_INS_LDTR,
	ARM64_INS_LDURB,
	ARM64_INS_LDUR,
	ARM64_INS_LDURH,
	ARM64_INS_LDURSB,
	ARM64_INS_LDURSH,
	ARM64_INS_LDURSW,
	ARM64_INS_LDXP,
	ARM64_INS_LDXRB,
	ARM64_INS_LDXRH,
	ARM64_INS_LDXR,
	ARM64_INS_LSL,
	ARM64_INS_LSR,
	ARM64_INS_MADD,
	ARM64_INS_MLA,
	ARM64_INS_MLS,
	ARM64_INS_MOVI,
	ARM64_INS_MOVK,
	ARM64_INS_MOVN,
	ARM64_INS_MOVZ,
	ARM64_INS_MRS,
	ARM64_INS_MSR,
	ARM64_INS_MSUB,
	ARM64_INS_MUL,
	ARM64_INS_MVNI,
	ARM64_INS_NEG,
	ARM64_INS_NOT,
	ARM64_INS_ORN,
	ARM64_INS_ORR,
	ARM64_INS_PMULL2,
	ARM64_INS_PMULL,
	ARM64_INS_PMUL,
	ARM64_INS_PRFM,
	ARM64_INS_PRFUM,
	ARM64_INS_RADDHN,
	ARM64_INS_RADDHN2,
	ARM64_INS_RBIT,
	ARM64_INS_RET,
	ARM64_INS_REV16,
	ARM64_INS_REV32,
	ARM64_INS_REV64,
	ARM64_INS_REV,
	ARM64_INS_ROR,
	ARM64_INS_RSHRN2,
	ARM64_INS_RSHRN,
	ARM64_INS_RSUBHN,
	ARM64_INS_RSUBHN2,
	ARM64_INS_SABAL2,
	ARM64_INS_SABAL,

	ARM64_INS_SABA,
	ARM64_INS_SABDL2,
	ARM64_INS_SABDL,
	ARM64_INS_SABD,
	ARM64_INS_SADALP,
	ARM64_INS_SADDLP,
	ARM64_INS_SADDLV,
	ARM64_INS_SADDL2,
	ARM64_INS_SADDL,
	ARM64_INS_SADDW2,
	ARM64_INS_SADDW,
	ARM64_INS_SBC,
	ARM64_INS_SBFM,
	ARM64_INS_SCVTF,
	ARM64_INS_SDIV,
	ARM64_INS_SHA1C,
	ARM64_INS_SHA1H,
	ARM64_INS_SHA1M,
	ARM64_INS_SHA1P,
	ARM64_INS_SHA1SU0,
	ARM64_INS_SHA1SU1,
	ARM64_INS_SHA256H2,
	ARM64_INS_SHA256H,
	ARM64_INS_SHA256SU0,
	ARM64_INS_SHA256SU1,
	ARM64_INS_SHADD,
	ARM64_INS_SHLL2,
	ARM64_INS_SHLL,
	ARM64_INS_SHL,
	ARM64_INS_SHRN2,
	ARM64_INS_SHRN,
	ARM64_INS_SHSUB,
	ARM64_INS_SLI,
	ARM64_INS_SMADDL,
	ARM64_INS_SMAXP,
	ARM64_INS_SMAXV,
	ARM64_INS_SMAX,
	ARM64_INS_SMC,
	ARM64_INS_SMINP,
	ARM64_INS_SMINV,
	ARM64_INS_SMIN,
	ARM64_INS_SMLAL2,
	ARM64_INS_SMLAL,
	ARM64_INS_SMLSL2,
	ARM64_INS_SMLSL,
	ARM64_INS_SMOV,
	ARM64_INS_SMSUBL,
	ARM64_INS_SMULH,
	ARM64_INS_SMULL2,
	ARM64_INS_SMULL,
	ARM64_INS_SQABS,
	ARM64_INS_SQADD,
	ARM64_INS_SQDMLAL,
	ARM64_INS_SQDMLAL2,
	ARM64_INS_SQDMLSL,
	ARM64_INS_SQDMLSL2,
	ARM64_INS_SQDMULH,
	ARM64_INS_SQDMULL,
	ARM64_INS_SQDMULL2,
	ARM64_INS_SQNEG,
	ARM64_INS_SQRDMULH,
	ARM64_INS_SQRSHL,
	ARM64_INS_SQRSHRN,
	ARM64_INS_SQRSHRN2,
	ARM64_INS_SQRSHRUN,
	ARM64_INS_SQRSHRUN2,
	ARM64_INS_SQSHLU,
	ARM64_INS_SQSHL,
	ARM64_INS_SQSHRN,
	ARM64_INS_SQSHRN2,
	ARM64_INS_SQSHRUN,
	ARM64_INS_SQSHRUN2,
	ARM64_INS_SQSUB,
	ARM64_INS_SQXTN2,
	ARM64_INS_SQXTN,
	ARM64_INS_SQXTUN2,
	ARM64_INS_SQXTUN,
	ARM64_INS_SRHADD,
	ARM64_INS_SRI,
	ARM64_INS_SRSHL,
	ARM64_INS_SRSHR,
	ARM64_INS_SRSRA,
	ARM64_INS_SSHLL2,
	ARM64_INS_SSHLL,
	ARM64_INS_SSHL,
	ARM64_INS_SSHR,
	ARM64_INS_SSRA,
	ARM64_INS_SSUBL2,
	ARM64_INS_SSUBL,
	ARM64_INS_SSUBW2,
	ARM64_INS_SSUBW,
	ARM64_INS_ST1,
	ARM64_INS_ST2,
	ARM64_INS_ST3,
	ARM64_INS_ST4,
	ARM64_INS_STLRB,
	ARM64_INS_STLRH,
	ARM64_INS_STLR,
	ARM64_INS_STLXP,
	ARM64_INS_STLXRB,
	ARM64_INS_STLXRH,
	ARM64_INS_STLXR,
	ARM64_INS_STNP,
	ARM64_INS_STP,
	ARM64_INS_STRB,
	ARM64_INS_STR,
	ARM64_INS_STRH,
	ARM64_INS_STTRB,
	ARM64_INS_STTRH,
	ARM64_INS_STTR,
	ARM64_INS_STURB,
	ARM64_INS_STUR,
	ARM64_INS_STURH,
	ARM64_INS_STXP,
	ARM64_INS_STXRB,
	ARM64_INS_STXRH,
	ARM64_INS_STXR,
	ARM64_INS_SUBHN,
	ARM64_INS_SUBHN2,
	ARM64_INS_SUB,
	ARM64_INS_SUQADD,
	ARM64_INS_SVC,
	ARM64_INS_SYSL,
	ARM64_INS_SYS,
	ARM64_INS_TBL,
	ARM64_INS_TBNZ,
	ARM64_INS_TBX,
	ARM64_INS_TBZ,
	ARM64_INS_TRN1,
	ARM64_INS_TRN2,
	ARM64_INS_UABAL2,
	ARM64_INS_UABAL,
	ARM64_INS_UABA,
	ARM64_INS_UABDL2,
	ARM64_INS_UABDL,
	ARM64_INS_UABD,
	ARM64_INS_UADALP,
	ARM64_INS_UADDLP,
	ARM64_INS_UADDLV,
	ARM64_INS_UADDL2,
	ARM64_INS_UADDL,
	ARM64_INS_UADDW2,
	ARM64_INS_UADDW,
	ARM64_INS_UBFM,
	ARM64_INS_UCVTF,
	ARM64_INS_UDIV,
	ARM64_INS_UHADD,
	ARM64_INS_UHSUB,
	ARM64_INS_UMADDL,
	ARM64_INS_UMAXP,
	ARM64_INS_UMAXV,
	ARM64_INS_UMAX,
	ARM64_INS_UMINP,
	ARM64_INS_UMINV,
	ARM64_INS_UMIN,
	ARM64_INS_UMLAL2,
	ARM64_INS_UMLAL,
	ARM64_INS_UMLSL2,
	ARM64_INS_UMLSL,
	ARM64_INS_UMOV,
	ARM64_INS_UMSUBL,
	ARM64_INS_UMULH,
	ARM64_INS_UMULL2,
	ARM64_INS_UMULL,
	ARM64_INS_UQADD,
	ARM64_INS_UQRSHL,
	ARM64_INS_UQRSHRN,
	ARM64_INS_UQRSHRN2,
	ARM64_INS_UQSHL,
	ARM64_INS_UQSHRN,
	ARM64_INS_UQSHRN2,
	ARM64_INS_UQSUB,
	ARM64_INS_UQXTN2,
	ARM64_INS_UQXTN,
	ARM64_INS_URECPE,
	ARM64_INS_URHADD,
	ARM64_INS_URSHL,
	ARM64_INS_URSHR,
	ARM64_INS_URSQRTE,
	ARM64_INS_URSRA,
	ARM64_INS_USHLL2,
	ARM64_INS_USHLL,
	ARM64_INS_USHL,
	ARM64_INS_USHR,
	ARM64_INS_USQADD,
	ARM64_INS_USRA,
	ARM64_INS_USUBL2,
	ARM64_INS_USUBL,
	ARM64_INS_USUBW2,
	ARM64_INS_USUBW,
	ARM64_INS_UZP1,
	ARM64_INS_UZP2,
	ARM64_INS_XTN2,
	ARM64_INS_XTN,
	ARM64_INS_ZIP1,
	ARM64_INS_ZIP2,

	// alias insn
	ARM64_INS_MNEG,
	ARM64_INS_UMNEGL,
	ARM64_INS_SMNEGL,
	ARM64_INS_NOP,
	ARM64_INS_YIELD,
	ARM64_INS_WFE,
	ARM64_INS_WFI,
	ARM64_INS_SEV,
	ARM64_INS_SEVL,
	ARM64_INS_NGC,
	ARM64_INS_SBFIZ,
	ARM64_INS_UBFIZ,
	ARM64_INS_SBFX,
	ARM64_INS_UBFX,
	ARM64_INS_BFI,
	ARM64_INS_BFXIL,
	ARM64_INS_CMN,
	ARM64_INS_MVN,
	ARM64_INS_TST,
	ARM64_INS_CSET,
	ARM64_INS_CINC,
	ARM64_INS_CSETM,
	ARM64_INS_CINV,
	ARM64_INS_CNEG,
	ARM64_INS_SXTB,
	ARM64_INS_SXTH,
	ARM64_INS_SXTW,
	ARM64_INS_CMP,
	ARM64_INS_UXTB,
	ARM64_INS_UXTH,
	ARM64_INS_UXTW,
	ARM64_INS_IC,
	ARM64_INS_DC,
	ARM64_INS_AT,
	ARM64_INS_TLBI,

	ARM64_INS_NEGS,
	ARM64_INS_NGCS,

	ARM64_INS_ENDING,  // <-- mark the end of the list of insn
} arm64_insn;

/// Group of ARM64 instructions
typedef enum arm64_insn_group {
	ARM64_GRP_INVALID = 0, ///< = CS_GRP_INVALID

	// Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	ARM64_GRP_JUMP,	///< = CS_GRP_JUMP
	ARM64_GRP_CALL,
	ARM64_GRP_RET,
	ARM64_GRP_INT,
	ARM64_GRP_PRIVILEGE = 6, ///< = CS_GRP_PRIVILEGE
	ARM64_GRP_BRANCH_RELATIVE, ///< = CS_GRP_BRANCH_RELATIVE

	// Architecture-specific groups
	ARM64_GRP_CRYPTO = 128,
	ARM64_GRP_FPARMV8,
	ARM64_GRP_NEON,
	ARM64_GRP_CRC,

	ARM64_GRP_ENDING,  // <-- mark the end of the list of groups
} arm64_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`capstone/include/capstone/capstone.h`:

```h
#ifndef CAPSTONE_ENGINE_H
#define CAPSTONE_ENGINE_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2016 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdarg.h>

#if defined(CAPSTONE_HAS_OSXKERNEL)
#include <libkern/libkern.h>
#else
#include <stdlib.h>
#include <stdio.h>
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#pragma warning(disable:4100)
#define CAPSTONE_API __cdecl
#ifdef CAPSTONE_SHARED
#define CAPSTONE_EXPORT __declspec(dllexport)
#else    // defined(CAPSTONE_STATIC)
#define CAPSTONE_EXPORT
#endif
#else
#define CAPSTONE_API
#if defined(__GNUC__) && !defined(CAPSTONE_STATIC)
#define CAPSTONE_EXPORT __attribute__((visibility("default")))
#else    // defined(CAPSTONE_STATIC)
#define CAPSTONE_EXPORT
#endif
#endif

#ifdef __GNUC__
#define CAPSTONE_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
#define CAPSTONE_DEPRECATED __declspec(deprecated)
#else
#pragma message("WARNING: You need to implement CAPSTONE_DEPRECATED for this compiler")
#define CAPSTONE_DEPRECATED
#endif

// Capstone API version
#define CS_API_MAJOR 5
#define CS_API_MINOR 0

// Version for bleeding edge code of the Github's "next" branch.
// Use this if you want the absolutely latest development code.
// This version number will be bumped up whenever we have a new major change.
#define CS_NEXT_VERSION 5

// Capstone package version
#define CS_VERSION_MAJOR CS_API_MAJOR
#define CS_VERSION_MINOR CS_API_MINOR
#define CS_VERSION_EXTRA 0

/// Macro to create combined version which can be compared to
/// result of cs_version() API.
#define CS_MAKE_VERSION(major, minor) ((major << 8) + minor)

/// Maximum size of an instruction mnemonic string.
#define CS_MNEMONIC_SIZE 32

// Handle using with all API
typedef size_t csh;

/// Architecture type
typedef enum cs_arch {
	CS_ARCH_ARM = 0,	///< ARM architecture (including Thumb, Thumb-2)
	CS_ARCH_ARM64,		///< ARM-64, also called AArch64
	CS_ARCH_MIPS,		///< Mips architecture
	CS_ARCH_X86,		///< X86 architecture (including x86 & x86-64)
	CS_ARCH_PPC,		///< PowerPC architecture
	CS_ARCH_SPARC,		///< Sparc architecture
	CS_ARCH_SYSZ,		///< SystemZ architecture
	CS_ARCH_XCORE,		///< XCore architecture
	CS_ARCH_M68K,		///< 68K architecture
	CS_ARCH_TMS320C64X,	///< TMS320C64x architecture
	CS_ARCH_M680X,		///< 680X architecture
	CS_ARCH_EVM,		///< Ethereum architecture
	CS_ARCH_MOS65XX,	///< MOS65XX architecture (including MOS6502)
	CS_ARCH_MAX,
	CS_ARCH_ALL = 0xFFFF, // All architectures - for cs_support()
} cs_arch;

// Support value to verify diet mode of the engine.
// If cs_support(CS_SUPPORT_DIET) return True, the engine was compiled
// in diet mode.
#define CS_SUPPORT_DIET (CS_ARCH_ALL + 1)

// Support value to verify X86 reduce mode of the engine.
// If cs_support(CS_SUPPORT_X86_REDUCE) return True, the engine was compiled
// in X86 reduce mode.
#define CS_SUPPORT_X86_REDUCE (CS_ARCH_ALL + 2)

/// Mode type
typedef enum cs_mode {
	CS_MODE_LITTLE_ENDIAN = 0,	///< little-endian mode (default mode)
	CS_MODE_ARM = 0,	///< 32-bit ARM
	CS_MODE_16 = 1 << 1,	///< 16-bit mode (X86)
	CS_MODE_32 = 1 << 2,	///< 32-bit mode (X86)
	CS_MODE_64 = 1 << 3,	///< 64-bit mode (X86, PPC)
	CS_MODE_THUMB = 1 << 4,	///< ARM's Thumb mode, including Thumb-2
	CS_MODE_MCLASS = 1 << 5,	///< ARM's Cortex-M series
	CS_MODE_V8 = 1 << 6,	///< ARMv8 A32 encodings for ARM
	CS_MODE_MICRO = 1 << 4, ///< MicroMips mode (MIPS)
	CS_MODE_MIPS3 = 1 << 5, ///< Mips III ISA
	CS_MODE_MIPS32R6 = 1 << 6, ///< Mips32r6 ISA
	CS_MODE_MIPS2 = 1 << 7, ///< Mips II ISA
	CS_MODE_V9 = 1 << 4, ///< SparcV9 mode (Sparc)
	CS_MODE_QPX = 1 << 4, ///< Quad Processing eXtensions mode (PPC)
	CS_MODE_M68K_000 = 1 << 1, ///< M68K 68000 mode
	CS_MODE_M68K_010 = 1 << 2, ///< M68K 68010 mode
	CS_MODE_M68K_020 = 1 << 3, ///< M68K 68020 mode
	CS_MODE_M68K_030 = 1 << 4, ///< M68K 68030 mode
	CS_MODE_M68K_040 = 1 << 5, ///< M68K 68040 mode
	CS_MODE_M68K_060 = 1 << 6, ///< M68K 68060 mode
	CS_MODE_BIG_ENDIAN = 1 << 31,	///< big-endian mode
	CS_MODE_MIPS32 = CS_MODE_32,	///< Mips32 ISA (Mips)
	CS_MODE_MIPS64 = CS_MODE_64,	///< Mips64 ISA (Mips)
	CS_MODE_M680X_6301 = 1 << 1, ///< M680X Hitachi 6301,6303 mode
	CS_MODE_M680X_6309 = 1 << 2, ///< M680X Hitachi 6309 mode
	CS_MODE_M680X_6800 = 1 << 3, ///< M680X Motorola 6800,6802 mode
	CS_MODE_M680X_6801 = 1 << 4, ///< M680X Motorola 6801,6803 mode
	CS_MODE_M680X_6805 = 1 << 5, ///< M680X Motorola/Freescale 6805 mode
	CS_MODE_M680X_6808 = 1 << 6, ///< M680X Motorola/Freescale/NXP 68HC08 mode
	CS_MODE_M680X_6809 = 1 << 7, ///< M680X Motorola 6809 mode
	CS_MODE_M680X_6811 = 1 << 8, ///< M680X Motorola/Freescale/NXP 68HC11 mode
	CS_MODE_M680X_CPU12 = 1 << 9, ///< M680X Motorola/Freescale/NXP CPU12
					///< used on M68HC12/HCS12
	CS_MODE_M680X_HCS08 = 1 << 10, ///< M680X Freescale/NXP HCS08 mode
} cs_mode;

typedef void* (CAPSTONE_API *cs_malloc_t)(size_t size);
typedef void* (CAPSTONE_API *cs_calloc_t)(size_t nmemb, size_t size);
typedef void* (CAPSTONE_API *cs_realloc_t)(void *ptr, size_t size);
typedef void (CAPSTONE_API *cs_free_t)(void *ptr);
typedef int (CAPSTONE_API *cs_vsnprintf_t)(char *str, size_t size, const char *format, va_list ap);


/// User-defined dynamic memory related functions: malloc/calloc/realloc/free/vsnprintf()
/// By default, Capstone uses system's malloc(), calloc(), realloc(), free() & vsnprintf().
typedef struct cs_opt_mem {
	cs_malloc_t malloc;
	cs_calloc_t calloc;
	cs_realloc_t realloc;
	cs_free_t free;
	cs_vsnprintf_t vsnprintf;
} cs_opt_mem;

/// Customize mnemonic for instructions with alternative name.
/// To reset existing customized instruction to its default mnemonic,
/// call cs_option(CS_OPT_MNEMONIC) again with the same @id and NULL value
/// for @mnemonic.
typedef struct cs_opt_mnem {
	/// ID of instruction to be customized.
	unsigned int id;
	/// Customized instruction mnemonic.
	const char *mnemonic;
} cs_opt_mnem;

/// Runtime option for the disassembled engine
typedef enum cs_opt_type {
	CS_OPT_INVALID = 0,	///< No option specified
	CS_OPT_SYNTAX,	///< Assembly output syntax
	CS_OPT_DETAIL,	///< Break down instruction structure into details
	CS_OPT_MODE,	///< Change engine's mode at run-time
	CS_OPT_MEM,	///< User-defined dynamic memory related functions
	CS_OPT_SKIPDATA, ///< Skip data when disassembling. Then engine is in SKIPDATA mode.
	CS_OPT_SKIPDATA_SETUP, ///< Setup user-defined function for SKIPDATA option
	CS_OPT_MNEMONIC, ///< Customize instruction mnemonic
	CS_OPT_UNSIGNED, ///< print immediate operands in unsigned form
} cs_opt_type;

/// Runtime option value (associated with option type above)
typedef enum cs_opt_value {
	CS_OPT_OFF = 0,  ///< Turn OFF an option - default for CS_OPT_DETAIL, CS_OPT_SKIPDATA, CS_OPT_UNSIGNED.
	CS_OPT_ON = 3, ///< Turn ON an option (CS_OPT_DETAIL, CS_OPT_SKIPDATA).
	CS_OPT_SYNTAX_DEFAULT = 0, ///< Default asm syntax (CS_OPT_SYNTAX).
	CS_OPT_SYNTAX_INTEL, ///< X86 Intel asm syntax - default on X86 (CS_OPT_SYNTAX).
	CS_OPT_SYNTAX_ATT,   ///< X86 ATT asm syntax (CS_OPT_SYNTAX).
	CS_OPT_SYNTAX_NOREGNAME, ///< Prints register name with only number (CS_OPT_SYNTAX)
	CS_OPT_SYNTAX_MASM, ///< X86 Intel Masm syntax (CS_OPT_SYNTAX).
} cs_opt_value;

/// Common instruction operand types - to be consistent across all architectures.
typedef enum cs_op_type {
	CS_OP_INVALID = 0,  ///< uninitialized/invalid operand.
	CS_OP_REG,          ///< Register operand.
	CS_OP_IMM,          ///< Immediate operand.
	CS_OP_MEM,          ///< Memory operand.
	CS_OP_FP,           ///< Floating-Point operand.
} cs_op_type;

/// Common instruction operand access types - to be consistent across all architectures.
/// It is possible to combine access types, for example: CS_AC_READ | CS_AC_WRITE
typedef enum cs_ac_type {
	CS_AC_INVALID = 0,        ///< Uninitialized/invalid access type.
	CS_AC_READ    = 1 << 0,   ///< Operand read from memory or register.
	CS_AC_WRITE   = 1 << 1,   ///< Operand write to memory or register.
} cs_ac_type;

/// Common instruction groups - to be consistent across all architectures.
typedef enum cs_group_type {
	CS_GRP_INVALID = 0,  ///< uninitialized/invalid group.
	CS_GRP_JUMP,    ///< all jump instructions (conditional+direct+indirect jumps)
	CS_GRP_CALL,    ///< all call instructions
	CS_GRP_RET,     ///< all return instructions
	CS_GRP_INT,     ///< all interrupt instructions (int+syscall)
	CS_GRP_IRET,    ///< all interrupt return instructions
	CS_GRP_PRIVILEGE,    ///< all privileged instructions
	CS_GRP_BRANCH_RELATIVE, ///< all relative branching instructions
} cs_group_type;

/**
 User-defined callback function for SKIPDATA option.
 See tests/test_skipdata.c for sample code demonstrating this API.

 @code: the input buffer containing code to be disassembled.
        This is the same buffer passed to cs_disasm().
 @code_size: size (in bytes) of the above @code buffer.
 @offset: the position of the currently-examining byte in the input
      buffer @code mentioned above.
 @user_data: user-data passed to cs_option() via @user_data field in
      cs_opt_skipdata struct below.

 @return: return number of bytes to skip, or 0 to immediately stop disassembling.
*/
typedef size_t (CAPSTONE_API *cs_skipdata_cb_t)(const uint8_t *code, size_t code_size, size_t offset, void *user_data);

/// User-customized setup for SKIPDATA option
typedef struct cs_opt_skipdata {
	/// Capstone considers data to skip as special "instructions".
	/// User can specify the string for this instruction's "mnemonic" here.
	/// By default (if @mnemonic is NULL), Capstone use ".byte".
	const char *mnemonic;

	/// User-defined callback function to be called when Capstone hits data.
	/// If the returned value from this callback is positive (>0), Capstone
	/// will skip exactly that number of bytes & continue. Otherwise, if
	/// the callback returns 0, Capstone stops disassembling and returns
	/// immediately from cs_disasm()
	/// NOTE: if this callback pointer is NULL, Capstone would skip a number
	/// of bytes depending on architectures, as following:
	/// Arm:     2 bytes (Thumb mode) or 4 bytes.
	/// Arm64:   4 bytes.
	/// Mips:    4 bytes.
	/// M680x:   1 byte.
	/// PowerPC: 4 bytes.
	/// Sparc:   4 bytes.
	/// SystemZ: 2 bytes.
	/// X86:     1 bytes.
	/// XCore:   2 bytes.
	/// EVM:     1 bytes.
	/// MOS65XX: 1 bytes.
	cs_skipdata_cb_t callback; 	// default value is NULL

	/// User-defined data to be passed to @callback function pointer.
	void *user_data;
} cs_opt_skipdata;


#include "arm.h"
#include "arm64.h"
#include "m68k.h"
#include "mips.h"
#include "ppc.h"
#include "sparc.h"
#include "systemz.h"
#include "x86.h"
#include "xcore.h"
#include "tms320c64x.h"
#include "m680x.h"
#include "evm.h"
#include "mos65xx.h"

/// NOTE: All information in cs_detail is only available when CS_OPT_DETAIL = CS_OPT_ON
/// Initialized as memset(., 0, offsetof(cs_detail, ARCH)+sizeof(cs_ARCH))
/// by ARCH_getInstruction in arch/ARCH/ARCHDisassembler.c
/// if cs_detail changes, in particular if a field is added after the union,
/// then update arch/ARCH/ARCHDisassembler.c accordingly
typedef struct cs_detail {
	uint16_t regs_read[16]; ///< list of implicit registers read by this insn
	uint8_t regs_read_count; ///< number of implicit registers read by this insn

	uint16_t regs_write[20]; ///< list of implicit registers modified by this insn
	uint8_t regs_write_count; ///< number of implicit registers modified by this insn

	uint8_t groups[8]; ///< list of group this instruction belong to
	uint8_t groups_count; ///< number of groups this insn belongs to

	/// Architecture-specific instruction info
	union {
		cs_x86 x86;     ///< X86 architecture, including 16-bit, 32-bit & 64-bit mode
		cs_arm64 arm64; ///< ARM64 architecture (aka AArch64)
		cs_arm arm;     ///< ARM architecture (including Thumb/Thumb2)
		cs_m68k m68k;   ///< M68K architecture
		cs_mips mips;   ///< MIPS architecture
		cs_ppc ppc;	    ///< PowerPC architecture
		cs_sparc sparc; ///< Sparc architecture
		cs_sysz sysz;   ///< SystemZ architecture
		cs_xcore xcore; ///< XCore architecture
		cs_tms320c64x tms320c64x;  ///< TMS320C64x architecture
		cs_m680x m680x; ///< M680X architecture
		cs_evm evm;	    ///< Ethereum architecture
		cs_mos65xx mos65xx;	///< MOS65XX architecture (including MOS6502)
	};
} cs_detail;

/// Detail information of disassembled instruction
typedef struct cs_insn {
	/// Instruction ID (basically a numeric ID for the instruction mnemonic)
	/// Find the instruction id in the '[ARCH]_insn' enum in the header file
	/// of corresponding architecture, such as 'arm_insn' in arm.h for ARM,
	/// 'x86_insn' in x86.h for X86, etc...
	/// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	/// NOTE: in Skipdata mode, "data" instruction has 0 for this id field.
	unsigned int id;

	/// Address (EIP) of this instruction
	/// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	uint64_t address;

	/// Size of this instruction
	/// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	uint16_t size;

	/// Machine bytes of this instruction, with number of bytes indicated by @size above
	/// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	uint8_t bytes[24];

	/// Ascii text of instruction mnemonic
	/// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	char mnemonic[CS_MNEMONIC_SIZE];

	/// Ascii text of instruction operands
	/// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	char op_str[160];

	/// Pointer to cs_detail.
	/// NOTE: detail pointer is only valid when both requirements below are met:
	/// (1) CS_OP_DETAIL = CS_OPT_ON
	/// (2) Engine is not in Skipdata mode (CS_OP_SKIPDATA option set to CS_OPT_ON)
	///
	/// NOTE 2: when in Skipdata mode, or when detail mode is OFF, even if this pointer
	///     is not NULL, its content is still irrelevant.
	cs_detail *detail;
} cs_insn;


/// Calculate the offset of a disassembled instruction in its buffer, given its position
/// in its array of disassembled insn
/// NOTE: this macro works with position (>=1), not index
#define CS_INSN_OFFSET(insns, post) (insns[post - 1].address - insns[0].address)


/// All type of errors encountered by Capstone API.
/// These are values returned by cs_errno()
typedef enum cs_err {
	CS_ERR_OK = 0,   ///< No error: everything was fine
	CS_ERR_MEM,      ///< Out-Of-Memory error: cs_open(), cs_disasm(), cs_disasm_iter()
	CS_ERR_ARCH,     ///< Unsupported architecture: cs_open()
	CS_ERR_HANDLE,   ///< Invalid handle: cs_op_count(), cs_op_index()
	CS_ERR_CSH,      ///< Invalid csh argument: cs_close(), cs_errno(), cs_option()
	CS_ERR_MODE,     ///< Invalid/unsupported mode: cs_open()
	CS_ERR_OPTION,   ///< Invalid/unsupported option: cs_option()
	CS_ERR_DETAIL,   ///< Information is unavailable because detail option is OFF
	CS_ERR_MEMSETUP, ///< Dynamic memory management uninitialized (see CS_OPT_MEM)
	CS_ERR_VERSION,  ///< Unsupported version (bindings)
	CS_ERR_DIET,     ///< Access irrelevant data in "diet" engine
	CS_ERR_SKIPDATA, ///< Access irrelevant data for "data" instruction in SKIPDATA mode
	CS_ERR_X86_ATT,  ///< X86 AT&T syntax is unsupported (opt-out at compile time)
	CS_ERR_X86_INTEL, ///< X86 Intel syntax is unsupported (opt-out at compile time)
	CS_ERR_X86_MASM, ///< X86 Masm syntax is unsupported (opt-out at compile time)
} cs_err;

/**
 Return combined API version & major and minor version numbers.

 @major: major number of API version
 @minor: minor number of API version

 @return hexical number as (major << 8 | minor), which encodes both
	 major & minor versions.
	 NOTE: This returned value can be compared with version number made
	 with macro CS_MAKE_VERSION

 For example, second API version would return 1 in @major, and 1 in @minor
 The return value would be 0x0101

 NOTE: if you only care about returned value, but not major and minor values,
 set both @major & @minor arguments to NULL.
*/
CAPSTONE_EXPORT
unsigned int CAPSTONE_API cs_version(int *major, int *minor);


/**
 This API can be used to either ask for archs supported by this library,
 or check to see if the library was compile with 'diet' option (or called
 in 'diet' mode).

 To check if a particular arch is supported by this library, set @query to
 arch mode (CS_ARCH_* value).
 To verify if this library supports all the archs, use CS_ARCH_ALL.

 To check if this library is in 'diet' mode, set @query to CS_SUPPORT_DIET.

 @return True if this library supports the given arch, or in 'diet' mode.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_support(int query);

/**
 Initialize CS handle: this must be done before any usage of CS.

 @arch: architecture type (CS_ARCH_*)
 @mode: hardware mode. This is combined of CS_MODE_*
 @handle: pointer to handle, which will be updated at return time

 @return CS_ERR_OK on success, or other value on failure (refer to cs_err enum
 for detailed error).
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_open(cs_arch arch, cs_mode mode, csh *handle);

/**
 Close CS handle: MUST do to release the handle when it is not used anymore.
 NOTE: this must be only called when there is no longer usage of Capstone,
 not even access to cs_insn array. The reason is the this API releases some
 cached memory, thus access to any Capstone API after cs_close() might crash
 your application.

 In fact,this API invalidate @handle by ZERO out its value (i.e *handle = 0).

 @handle: pointer to a handle returned by cs_open()

 @return CS_ERR_OK on success, or other value on failure (refer to cs_err enum
 for detailed error).
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_close(csh *handle);

/**
 Set option for disassembling engine at runtime

 @handle: handle returned by cs_open()
 @type: type of option to be set
 @value: option value corresponding with @type

 @return: CS_ERR_OK on success, or other value on failure.
 Refer to cs_err enum for detailed error.

 NOTE: in the case of CS_OPT_MEM, handle's value can be anything,
 so that cs_option(handle, CS_OPT_MEM, value) can (i.e must) be called
 even before cs_open()
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_option(csh handle, cs_opt_type type, size_t value);

/**
 Report the last error number when some API function fail.
 Like glibc's errno, cs_errno might not retain its old value once accessed.

 @handle: handle returned by cs_open()

 @return: error code of cs_err enum type (CS_ERR_*, see above)
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_errno(csh handle);


/**
 Return a string describing given error code.

 @code: error code (see CS_ERR_* above)

 @return: returns a pointer to a string that describes the error code
	passed in the argument @code
*/
CAPSTONE_EXPORT
const char * CAPSTONE_API cs_strerror(cs_err code);

/**
 Disassemble binary code, given the code buffer, size, address and number
 of instructions to be decoded.
 This API dynamically allocate memory to contain disassembled instruction.
 Resulting instructions will be put into @*insn

 NOTE 1: this API will automatically determine memory needed to contain
 output disassembled instructions in @insn.

 NOTE 2: caller must free the allocated memory itself to avoid memory leaking.

 NOTE 3: for system with scarce memory to be dynamically allocated such as
 OS kernel or firmware, the API cs_disasm_iter() might be a better choice than
 cs_disasm(). The reason is that with cs_disasm(), based on limited available
 memory, we have to calculate in advance how many instructions to be disassembled,
 which complicates things. This is especially troublesome for the case @count=0,
 when cs_disasm() runs uncontrollably (until either end of input buffer, or
 when it encounters an invalid instruction).
 
 @handle: handle returned by cs_open()
 @code: buffer containing raw binary code to be disassembled.
 @code_size: size of the above code buffer.
 @address: address of the first instruction in given raw code buffer.
 @insn: array of instructions filled in by this API.
	   NOTE: @insn will be allocated by this function, and should be freed
	   with cs_free() API.
 @count: number of instructions to be disassembled, or 0 to get all of them

 @return: the number of successfully disassembled instructions,
 or 0 if this function failed to disassemble the given code

 On failure, call cs_errno() for error code.
*/
CAPSTONE_EXPORT
size_t CAPSTONE_API cs_disasm(csh handle,
		const uint8_t *code, size_t code_size,
		uint64_t address,
		size_t count,
		cs_insn **insn);

/**
  Deprecated function - to be retired in the next version!
  Use cs_disasm() instead of cs_disasm_ex()
*/
CAPSTONE_EXPORT
CAPSTONE_DEPRECATED
size_t CAPSTONE_API cs_disasm_ex(csh handle,
		const uint8_t *code, size_t code_size,
		uint64_t address,
		size_t count,
		cs_insn **insn);

/**
 Free memory allocated by cs_malloc() or cs_disasm() (argument @insn)

 @insn: pointer returned by @insn argument in cs_disasm() or cs_malloc()
 @count: number of cs_insn structures returned by cs_disasm(), or 1
     to free memory allocated by cs_malloc().
*/
CAPSTONE_EXPORT
void CAPSTONE_API cs_free(cs_insn *insn, size_t count);


/**
 Allocate memory for 1 instruction to be used by cs_disasm_iter().

 @handle: handle returned by cs_open()

 NOTE: when no longer in use, you can reclaim the memory allocated for
 this instruction with cs_free(insn, 1)
*/
CAPSTONE_EXPORT
cs_insn * CAPSTONE_API cs_malloc(csh handle);

/**
 Fast API to disassemble binary code, given the code buffer, size, address
 and number of instructions to be decoded.
 This API puts the resulting instruction into a given cache in @insn.
 See tests/test_iter.c for sample code demonstrating this API.

 NOTE 1: this API will update @code, @size & @address to point to the next
 instruction in the input buffer. Therefore, it is convenient to use
 cs_disasm_iter() inside a loop to quickly iterate all the instructions.
 While decoding one instruction at a time can also be achieved with
 cs_disasm(count=1), some benchmarks shown that cs_disasm_iter() can be 30%
 faster on random input.

 NOTE 2: the cache in @insn can be created with cs_malloc() API.

 NOTE 3: for system with scarce memory to be dynamically allocated such as
 OS kernel or firmware, this API is recommended over cs_disasm(), which
 allocates memory based on the number of instructions to be disassembled.
 The reason is that with cs_disasm(), based on limited available memory,
 we have to calculate in advance how many instructions to be disassembled,
 which complicates things. This is especially troublesome for the case
 @count=0, when cs_disasm() runs uncontrollably (until either end of input
 buffer, or when it encounters an invalid instruction).
 
 @handle: handle returned by cs_open()
 @code: buffer containing raw binary code to be disassembled
 @size: size of above code
 @address: address of the first insn in given raw code buffer
 @insn: pointer to instruction to be filled in by this API.

 @return: true if this API successfully decode 1 instruction,
 or false otherwise.

 On failure, call cs_errno() for error code.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_disasm_iter(csh handle,
	const uint8_t **code, size_t *size,
	uint64_t *address, cs_insn *insn);

/**
 Return friendly name of register in a string.
 Find the instruction id from header file of corresponding architecture (arm.h for ARM,
 x86.h for X86, ...)

 WARN: when in 'diet' mode, this API is irrelevant because engine does not
 store register name.

 @handle: handle returned by cs_open()
 @reg_id: register id

 @return: string name of the register, or NULL if @reg_id is invalid.
*/
CAPSTONE_EXPORT
const char * CAPSTONE_API cs_reg_name(csh handle, unsigned int reg_id);

/**
 Return friendly name of an instruction in a string.
 Find the instruction id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 store instruction name.

 @handle: handle returned by cs_open()
 @insn_id: instruction id

 @return: string name of the instruction, or NULL if @insn_id is invalid.
*/
CAPSTONE_EXPORT
const char * CAPSTONE_API cs_insn_name(csh handle, unsigned int insn_id);

/**
 Return friendly name of a group id (that an instruction can belong to)
 Find the group id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 store group name.

 @handle: handle returned by cs_open()
 @group_id: group id

 @return: string name of the group, or NULL if @group_id is invalid.
*/
CAPSTONE_EXPORT
const char * CAPSTONE_API cs_group_name(csh handle, unsigned int group_id);

/**
 Check if a disassembled instruction belong to a particular group.
 Find the group id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)
 Internally, this simply verifies if @group_id matches any member of insn->groups array.

 NOTE: this API is only valid when detail option is ON (which is OFF by default).

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 update @groups array.

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @group_id: group that you want to check if this instruction belong to.

 @return: true if this instruction indeed belongs to the given group, or false otherwise.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_insn_group(csh handle, const cs_insn *insn, unsigned int group_id);

/**
 Check if a disassembled instruction IMPLICITLY used a particular register.
 Find the register id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)
 Internally, this simply verifies if @reg_id matches any member of insn->regs_read array.

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 update @regs_read array.

 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @reg_id: register that you want to check if this instruction used it.

 @return: true if this instruction indeed implicitly used the given register, or false otherwise.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_reg_read(csh handle, const cs_insn *insn, unsigned int reg_id);

/**
 Check if a disassembled instruction IMPLICITLY modified a particular register.
 Find the register id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)
 Internally, this simply verifies if @reg_id matches any member of insn->regs_write array.

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 update @regs_write array.

 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @reg_id: register that you want to check if this instruction modified it.

 @return: true if this instruction indeed implicitly modified the given register, or false otherwise.
*/
CAPSTONE_EXPORT
bool CAPSTONE_API cs_reg_write(csh handle, const cs_insn *insn, unsigned int reg_id);

/**
 Count the number of operands of a given type.
 Find the operand type in header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @op_type: Operand type to be found.

 @return: number of operands of given type @op_type in instruction @insn,
 or -1 on failure.
*/
CAPSTONE_EXPORT
int CAPSTONE_API cs_op_count(csh handle, const cs_insn *insn, unsigned int op_type);

/**
 Retrieve the position of operand of given type in <arch>.operands[] array.
 Later, the operand can be accessed using the returned position.
 Find the operand type in header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @op_type: Operand type to be found.
 @position: position of the operand to be found. This must be in the range
			[1, cs_op_count(handle, insn, op_type)]

 @return: index of operand of given type @op_type in <arch>.operands[] array
 in instruction @insn, or -1 on failure.
*/
CAPSTONE_EXPORT
int CAPSTONE_API cs_op_index(csh handle, const cs_insn *insn, unsigned int op_type,
		unsigned int position);

/// Type of array to keep the list of registers
typedef uint16_t cs_regs[64];

/**
 Retrieve all the registers accessed by an instruction, either explicitly or
 implicitly.

 WARN: when in 'diet' mode, this API is irrelevant because engine does not
 store registers.

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure returned from cs_disasm() or cs_disasm_iter()
 @regs_read: on return, this array contains all registers read by instruction.
 @regs_read_count: number of registers kept inside @regs_read array.
 @regs_write: on return, this array contains all registers written by instruction.
 @regs_write_count: number of registers kept inside @regs_write array.

 @return CS_ERR_OK on success, or other value on failure (refer to cs_err enum
 for detailed error).
*/
CAPSTONE_EXPORT
cs_err CAPSTONE_API cs_regs_access(csh handle, const cs_insn *insn,
		cs_regs regs_read, uint8_t *regs_read_count,
		cs_regs regs_write, uint8_t *regs_write_count);

#ifdef __cplusplus
}
#endif

#endif

```

`capstone/include/capstone/evm.h`:

```h
#ifndef CAPSTONE_EVM_H
#define CAPSTONE_EVM_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2018 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

/// Instruction structure
typedef struct cs_evm {
    unsigned char pop;    ///< number of items popped from the stack
    unsigned char push;   ///< number of items pushed into the stack
    unsigned int  fee;    ///< gas fee for the instruction
} cs_evm;

/// EVM instruction
typedef enum evm_insn {
	EVM_INS_STOP = 0,
	EVM_INS_ADD = 1,
	EVM_INS_MUL = 2,
	EVM_INS_SUB = 3,
	EVM_INS_DIV = 4,
	EVM_INS_SDIV = 5,
	EVM_INS_MOD = 6,
	EVM_INS_SMOD = 7,
	EVM_INS_ADDMOD = 8,
	EVM_INS_MULMOD = 9,
	EVM_INS_EXP = 10,
	EVM_INS_SIGNEXTEND = 11,
	EVM_INS_LT = 16,
	EVM_INS_GT = 17,
	EVM_INS_SLT = 18,
	EVM_INS_SGT = 19,
	EVM_INS_EQ = 20,
	EVM_INS_ISZERO = 21,
	EVM_INS_AND = 22,
	EVM_INS_OR = 23,
	EVM_INS_XOR = 24,
	EVM_INS_NOT = 25,
	EVM_INS_BYTE = 26,
	EVM_INS_SHA3 = 32,
	EVM_INS_ADDRESS = 48,
	EVM_INS_BALANCE = 49,
	EVM_INS_ORIGIN = 50,
	EVM_INS_CALLER = 51,
	EVM_INS_CALLVALUE = 52,
	EVM_INS_CALLDATALOAD = 53,
	EVM_INS_CALLDATASIZE = 54,
	EVM_INS_CALLDATACOPY = 55,
	EVM_INS_CODESIZE = 56,
	EVM_INS_CODECOPY = 57,
	EVM_INS_GASPRICE = 58,
	EVM_INS_EXTCODESIZE = 59,
	EVM_INS_EXTCODECOPY = 60,
	EVM_INS_RETURNDATASIZE = 61,
	EVM_INS_RETURNDATACOPY = 62,
	EVM_INS_BLOCKHASH = 64,
	EVM_INS_COINBASE = 65,
	EVM_INS_TIMESTAMP = 66,
	EVM_INS_NUMBER = 67,
	EVM_INS_DIFFICULTY = 68,
	EVM_INS_GASLIMIT = 69,
	EVM_INS_POP = 80,
	EVM_INS_MLOAD = 81,
	EVM_INS_MSTORE = 82,
	EVM_INS_MSTORE8 = 83,
	EVM_INS_SLOAD = 84,
	EVM_INS_SSTORE = 85,
	EVM_INS_JUMP = 86,
	EVM_INS_JUMPI = 87,
	EVM_INS_PC = 88,
	EVM_INS_MSIZE = 89,
	EVM_INS_GAS = 90,
	EVM_INS_JUMPDEST = 91,
	EVM_INS_PUSH1 = 96,
	EVM_INS_PUSH2 = 97,
	EVM_INS_PUSH3 = 98,
	EVM_INS_PUSH4 = 99,
	EVM_INS_PUSH5 = 100,
	EVM_INS_PUSH6 = 101,
	EVM_INS_PUSH7 = 102,
	EVM_INS_PUSH8 = 103,
	EVM_INS_PUSH9 = 104,
	EVM_INS_PUSH10 = 105,
	EVM_INS_PUSH11 = 106,
	EVM_INS_PUSH12 = 107,
	EVM_INS_PUSH13 = 108,
	EVM_INS_PUSH14 = 109,
	EVM_INS_PUSH15 = 110,
	EVM_INS_PUSH16 = 111,
	EVM_INS_PUSH17 = 112,
	EVM_INS_PUSH18 = 113,
	EVM_INS_PUSH19 = 114,
	EVM_INS_PUSH20 = 115,
	EVM_INS_PUSH21 = 116,
	EVM_INS_PUSH22 = 117,
	EVM_INS_PUSH23 = 118,
	EVM_INS_PUSH24 = 119,
	EVM_INS_PUSH25 = 120,
	EVM_INS_PUSH26 = 121,
	EVM_INS_PUSH27 = 122,
	EVM_INS_PUSH28 = 123,
	EVM_INS_PUSH29 = 124,
	EVM_INS_PUSH30 = 125,
	EVM_INS_PUSH31 = 126,
	EVM_INS_PUSH32 = 127,
	EVM_INS_DUP1 = 128,
	EVM_INS_DUP2 = 129,
	EVM_INS_DUP3 = 130,
	EVM_INS_DUP4 = 131,
	EVM_INS_DUP5 = 132,
	EVM_INS_DUP6 = 133,
	EVM_INS_DUP7 = 134,
	EVM_INS_DUP8 = 135,
	EVM_INS_DUP9 = 136,
	EVM_INS_DUP10 = 137,
	EVM_INS_DUP11 = 138,
	EVM_INS_DUP12 = 139,
	EVM_INS_DUP13 = 140,
	EVM_INS_DUP14 = 141,
	EVM_INS_DUP15 = 142,
	EVM_INS_DUP16 = 143,
	EVM_INS_SWAP1 = 144,
	EVM_INS_SWAP2 = 145,
	EVM_INS_SWAP3 = 146,
	EVM_INS_SWAP4 = 147,
	EVM_INS_SWAP5 = 148,
	EVM_INS_SWAP6 = 149,
	EVM_INS_SWAP7 = 150,
	EVM_INS_SWAP8 = 151,
	EVM_INS_SWAP9 = 152,
	EVM_INS_SWAP10 = 153,
	EVM_INS_SWAP11 = 154,
	EVM_INS_SWAP12 = 155,
	EVM_INS_SWAP13 = 156,
	EVM_INS_SWAP14 = 157,
	EVM_INS_SWAP15 = 158,
	EVM_INS_SWAP16 = 159,
	EVM_INS_LOG0 = 160,
	EVM_INS_LOG1 = 161,
	EVM_INS_LOG2 = 162,
	EVM_INS_LOG3 = 163,
	EVM_INS_LOG4 = 164,
	EVM_INS_CREATE = 240,
	EVM_INS_CALL = 241,
	EVM_INS_CALLCODE = 242,
	EVM_INS_RETURN = 243,
	EVM_INS_DELEGATECALL = 244,
	EVM_INS_CALLBLACKBOX = 245,
	EVM_INS_STATICCALL = 250,
	EVM_INS_REVERT = 253,
	EVM_INS_SUICIDE = 255,

	EVM_INS_INVALID = 512,
	EVM_INS_ENDING,   // <-- mark the end of the list of instructions
} evm_insn;

/// Group of EVM instructions
typedef enum evm_insn_group {
	EVM_GRP_INVALID = 0, ///< = CS_GRP_INVALID

	EVM_GRP_JUMP,          ///< all jump instructions

	EVM_GRP_MATH = 8,      ///< math instructions
	EVM_GRP_STACK_WRITE,   ///< instructions write to stack
	EVM_GRP_STACK_READ,    ///< instructions read from stack
	EVM_GRP_MEM_WRITE,     ///< instructions write to memory
	EVM_GRP_MEM_READ,      ///< instructions read from memory
	EVM_GRP_STORE_WRITE,   ///< instructions write to storage
	EVM_GRP_STORE_READ,    ///< instructions read from storage
	EVM_GRP_HALT,    ///< instructions halt execution

	EVM_GRP_ENDING,   ///< <-- mark the end of the list of groups
} evm_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`capstone/include/capstone/m680x.h`:

```h
#ifndef CAPSTONE_M680X_H
#define CAPSTONE_M680X_H

/* Capstone Disassembly Engine */
/* M680X Backend by Wolfgang Schwotzer <wolfgang.schwotzer@gmx.net> 2017 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

#define M680X_OPERAND_COUNT 9

/// M680X registers and special registers
typedef enum m680x_reg {
	M680X_REG_INVALID = 0,

	M680X_REG_A, ///< M6800/1/2/3/9, HD6301/9
	M680X_REG_B, ///< M6800/1/2/3/9, HD6301/9
	M680X_REG_E, ///< HD6309
	M680X_REG_F, ///< HD6309
	M680X_REG_0, ///< HD6309

	M680X_REG_D, ///< M6801/3/9, HD6301/9
	M680X_REG_W, ///< HD6309

	M680X_REG_CC, ///< M6800/1/2/3/9, M6301/9
	M680X_REG_DP, ///< M6809/M6309
	M680X_REG_MD, ///< M6309

	M680X_REG_HX, ///< M6808
	M680X_REG_H, ///< M6808
	M680X_REG_X, ///< M6800/1/2/3/9, M6301/9
	M680X_REG_Y, ///< M6809/M6309
	M680X_REG_S, ///< M6809/M6309
	M680X_REG_U, ///< M6809/M6309
	M680X_REG_V, ///< M6309

	M680X_REG_Q, ///< M6309

	M680X_REG_PC, ///< M6800/1/2/3/9, M6301/9

	M680X_REG_TMP2, ///< CPU12
	M680X_REG_TMP3, ///< CPU12

	M680X_REG_ENDING,   ///< <-- mark the end of the list of registers
} m680x_reg;

/// Operand type for instruction's operands
typedef enum m680x_op_type {
	M680X_OP_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	M680X_OP_REGISTER,    ///< = Register operand.
	M680X_OP_IMMEDIATE,   ///< = Immediate operand.
	M680X_OP_INDEXED,     ///< = Indexed addressing operand.
	M680X_OP_EXTENDED,    ///< = Extended addressing operand.
	M680X_OP_DIRECT,      ///< = Direct addressing operand.
	M680X_OP_RELATIVE,    ///< = Relative addressing operand.
	M680X_OP_CONSTANT,    ///< = constant operand (Displayed as number only).
				///< Used e.g. for a bit index or page number.
} m680x_op_type;

// Supported bit values for mem.idx.offset_bits
#define M680X_OFFSET_NONE      0
#define M680X_OFFSET_BITS_5    5
#define M680X_OFFSET_BITS_8    8
#define M680X_OFFSET_BITS_9    9
#define M680X_OFFSET_BITS_16  16

// Supported bit flags for mem.idx.flags
// These flags can be combined
#define M680X_IDX_INDIRECT     1
#define M680X_IDX_NO_COMMA     2
#define M680X_IDX_POST_INC_DEC 4

/// Instruction's operand referring to indexed addressing
typedef struct m680x_op_idx {
	m680x_reg base_reg;	///< base register (or M680X_REG_INVALID if
				///< irrelevant)
	m680x_reg offset_reg;	///< offset register (or M680X_REG_INVALID if
				///< irrelevant)
	int16_t offset;		///< 5-,8- or 16-bit offset. See also offset_bits.
	uint16_t offset_addr;	///< = offset addr. if base_reg == M680X_REG_PC.
				///< calculated as offset + PC
	uint8_t offset_bits;	///< offset width in bits for indexed addressing
	int8_t inc_dec;		///< inc. or dec. value:
				///<    0: no inc-/decrement
				///<    1 .. 8: increment by 1 .. 8
				///<    -1 .. -8: decrement by 1 .. 8
				///< if flag M680X_IDX_POST_INC_DEC set it is post
				///< inc-/decrement otherwise pre inc-/decrement
	uint8_t flags;		///< 8-bit flags (see above)
} m680x_op_idx;

/// Instruction's memory operand referring to relative addressing (Bcc/LBcc)
typedef struct m680x_op_rel {
	uint16_t address;	///< The absolute address.
				///< calculated as PC + offset. PC is the first
				///< address after the instruction.
	int16_t offset;		///< the offset/displacement value
} m680x_op_rel;

/// Instruction's operand referring to extended addressing
typedef struct m680x_op_ext {
	uint16_t address;      ///< The absolute address
	bool indirect;         ///< true if extended indirect addressing
} m680x_op_ext;

/// Instruction operand
typedef struct cs_m680x_op {
	m680x_op_type type;
	union {
		int32_t imm;		///< immediate value for IMM operand
		m680x_reg reg;		///< register value for REG operand
		m680x_op_idx idx;	///< Indexed addressing operand
		m680x_op_rel rel;	///< Relative address. operand (Bcc/LBcc)
		m680x_op_ext ext;	///< Extended address
		uint8_t direct_addr;	///<</ Direct address (lower 8-bit)
		uint8_t const_val;	///< constant value (bit index, page nr.)
	};
	uint8_t size;			///< size of this operand (in bytes)
	/// How is this operand accessed? (READ, WRITE or READ|WRITE)
	/// This field is combined of cs_ac_type.
	/// NOTE: this field is irrelevant if engine is compiled in DIET 
	uint8_t access;
} cs_m680x_op;

/// Group of M680X instructions
typedef enum m680x_group_type {
	M680X_GRP_INVALID = 0,	/// = CS_GRP_INVALID
	// Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	M680X_GRP_JUMP,		///< = CS_GRP_JUMP
	// all call instructions
	M680X_GRP_CALL,		///< = CS_GRP_CALL
	// all return instructions
	M680X_GRP_RET,		///< = CS_GRP_RET
	// all interrupt instructions (int+syscall)
	M680X_GRP_INT,		///< = CS_GRP_INT
	// all interrupt return instructions
	M680X_GRP_IRET,		///< = CS_GRP_IRET
	// all privileged instructions
	M680X_GRP_PRIV,		///< = CS_GRP_PRIVILEDGE; not used
	// all relative branching instructions
	M680X_GRP_BRAREL,	///< = CS_GRP_BRANCH_RELATIVE

	// Architecture-specific groups
	M680X_GRP_ENDING,	// <-- mark the end of the list of groups
} m680x_group_type;

// M680X instruction flags:

/// The first (register) operand is part of the
/// instruction mnemonic
#define M680X_FIRST_OP_IN_MNEM    1
/// The second (register) operand is part of the
/// instruction mnemonic
#define M680X_SECOND_OP_IN_MNEM   2

/// The M680X instruction and it's operands
typedef struct cs_m680x {
	uint8_t flags;		///< See: M680X instruction flags
	uint8_t op_count;	///< number of operands for the instruction or 0
	cs_m680x_op operands[M680X_OPERAND_COUNT]; ///< operands for this insn.
} cs_m680x;

/// M680X instruction IDs
typedef enum m680x_insn {
	M680X_INS_INVLD = 0,
	M680X_INS_ABA, ///< M6800/1/2/3
	M680X_INS_ABX,
	M680X_INS_ABY,
	M680X_INS_ADC,
	M680X_INS_ADCA,
	M680X_INS_ADCB,
	M680X_INS_ADCD,
	M680X_INS_ADCR,
	M680X_INS_ADD,
	M680X_INS_ADDA,
	M680X_INS_ADDB,
	M680X_INS_ADDD,
	M680X_INS_ADDE,
	M680X_INS_ADDF,
	M680X_INS_ADDR,
	M680X_INS_ADDW,
	M680X_INS_AIM,
	M680X_INS_AIS,
	M680X_INS_AIX,
	M680X_INS_AND,
	M680X_INS_ANDA,
	M680X_INS_ANDB,
	M680X_INS_ANDCC,
	M680X_INS_ANDD,
	M680X_INS_ANDR,
	M680X_INS_ASL,
	M680X_INS_ASLA,
	M680X_INS_ASLB,
	M680X_INS_ASLD, ///< or LSLD
	M680X_INS_ASR,
	M680X_INS_ASRA,
	M680X_INS_ASRB,
	M680X_INS_ASRD,
	M680X_INS_ASRX,
	M680X_INS_BAND,
	M680X_INS_BCC, ///< or BHS
	M680X_INS_BCLR,
	M680X_INS_BCS, ///< or BLO
	M680X_INS_BEOR,
	M680X_INS_BEQ,
	M680X_INS_BGE,
	M680X_INS_BGND,
	M680X_INS_BGT,
	M680X_INS_BHCC,
	M680X_INS_BHCS,
	M680X_INS_BHI,
	M680X_INS_BIAND,
	M680X_INS_BIEOR,
	M680X_INS_BIH,
	M680X_INS_BIL,
	M680X_INS_BIOR,
	M680X_INS_BIT,
	M680X_INS_BITA,
	M680X_INS_BITB,
	M680X_INS_BITD,
	M680X_INS_BITMD,
	M680X_INS_BLE,
	M680X_INS_BLS,
	M680X_INS_BLT,
	M680X_INS_BMC,
	M680X_INS_BMI,
	M680X_INS_BMS,
	M680X_INS_BNE,
	M680X_INS_BOR,
	M680X_INS_BPL,
	M680X_INS_BRCLR,
	M680X_INS_BRSET,
	M680X_INS_BRA,
	M680X_INS_BRN,
	M680X_INS_BSET,
	M680X_INS_BSR,
	M680X_INS_BVC,
	M680X_INS_BVS,
	M680X_INS_CALL,
	M680X_INS_CBA, ///< M6800/1/2/3
	M680X_INS_CBEQ,
	M680X_INS_CBEQA,
	M680X_INS_CBEQX,
	M680X_INS_CLC, ///< M6800/1/2/3
	M680X_INS_CLI, ///< M6800/1/2/3
	M680X_INS_CLR,
	M680X_INS_CLRA,
	M680X_INS_CLRB,
	M680X_INS_CLRD,
	M680X_INS_CLRE,
	M680X_INS_CLRF,
	M680X_INS_CLRH,
	M680X_INS_CLRW,
	M680X_INS_CLRX,
	M680X_INS_CLV, ///< M6800/1/2/3
	M680X_INS_CMP,
	M680X_INS_CMPA,
	M680X_INS_CMPB,
	M680X_INS_CMPD,
	M680X_INS_CMPE,
	M680X_INS_CMPF,
	M680X_INS_CMPR,
	M680X_INS_CMPS,
	M680X_INS_CMPU,
	M680X_INS_CMPW,
	M680X_INS_CMPX,
	M680X_INS_CMPY,
	M680X_INS_COM,
	M680X_INS_COMA,
	M680X_INS_COMB,
	M680X_INS_COMD,
	M680X_INS_COME,
	M680X_INS_COMF,
	M680X_INS_COMW,
	M680X_INS_COMX,
	M680X_INS_CPD,
	M680X_INS_CPHX,
	M680X_INS_CPS,
	M680X_INS_CPX, ///< M6800/1/2/3
	M680X_INS_CPY,
	M680X_INS_CWAI,
	M680X_INS_DAA,
	M680X_INS_DBEQ,
	M680X_INS_DBNE,
	M680X_INS_DBNZ,
	M680X_INS_DBNZA,
	M680X_INS_DBNZX,
	M680X_INS_DEC,
	M680X_INS_DECA,
	M680X_INS_DECB,
	M680X_INS_DECD,
	M680X_INS_DECE,
	M680X_INS_DECF,
	M680X_INS_DECW,
	M680X_INS_DECX,
	M680X_INS_DES, ///< M6800/1/2/3
	M680X_INS_DEX, ///< M6800/1/2/3
	M680X_INS_DEY,
	M680X_INS_DIV,
	M680X_INS_DIVD,
	M680X_INS_DIVQ,
	M680X_INS_EDIV,
	M680X_INS_EDIVS,
	M680X_INS_EIM,
	M680X_INS_EMACS,
	M680X_INS_EMAXD,
	M680X_INS_EMAXM,
	M680X_INS_EMIND,
	M680X_INS_EMINM,
	M680X_INS_EMUL,
	M680X_INS_EMULS,
	M680X_INS_EOR,
	M680X_INS_EORA,
	M680X_INS_EORB,
	M680X_INS_EORD,
	M680X_INS_EORR,
	M680X_INS_ETBL,
	M680X_INS_EXG,
	M680X_INS_FDIV,
	M680X_INS_IBEQ,
	M680X_INS_IBNE,
	M680X_INS_IDIV,
	M680X_INS_IDIVS,
	M680X_INS_ILLGL,
	M680X_INS_INC,
	M680X_INS_INCA,
	M680X_INS_INCB,
	M680X_INS_INCD,
	M680X_INS_INCE,
	M680X_INS_INCF,
	M680X_INS_INCW,
	M680X_INS_INCX,
	M680X_INS_INS, ///< M6800/1/2/3
	M680X_INS_INX, ///< M6800/1/2/3
	M680X_INS_INY,
	M680X_INS_JMP,
	M680X_INS_JSR,
	M680X_INS_LBCC, ///< or LBHS
	M680X_INS_LBCS, ///< or LBLO
	M680X_INS_LBEQ,
	M680X_INS_LBGE,
	M680X_INS_LBGT,
	M680X_INS_LBHI,
	M680X_INS_LBLE,
	M680X_INS_LBLS,
	M680X_INS_LBLT,
	M680X_INS_LBMI,
	M680X_INS_LBNE,
	M680X_INS_LBPL,
	M680X_INS_LBRA,
	M680X_INS_LBRN,
	M680X_INS_LBSR,
	M680X_INS_LBVC,
	M680X_INS_LBVS,
	M680X_INS_LDA,
	M680X_INS_LDAA, ///< M6800/1/2/3
	M680X_INS_LDAB, ///< M6800/1/2/3
	M680X_INS_LDB,
	M680X_INS_LDBT,
	M680X_INS_LDD,
	M680X_INS_LDE,
	M680X_INS_LDF,
	M680X_INS_LDHX,
	M680X_INS_LDMD,
	M680X_INS_LDQ,
	M680X_INS_LDS,
	M680X_INS_LDU,
	M680X_INS_LDW,
	M680X_INS_LDX,
	M680X_INS_LDY,
	M680X_INS_LEAS,
	M680X_INS_LEAU,
	M680X_INS_LEAX,
	M680X_INS_LEAY,
	M680X_INS_LSL,
	M680X_INS_LSLA,
	M680X_INS_LSLB,
	M680X_INS_LSLD,
	M680X_INS_LSLX,
	M680X_INS_LSR,
	M680X_INS_LSRA,
	M680X_INS_LSRB,
	M680X_INS_LSRD, ///< or ASRD
	M680X_INS_LSRW,
	M680X_INS_LSRX,
	M680X_INS_MAXA,
	M680X_INS_MAXM,
	M680X_INS_MEM,
	M680X_INS_MINA,
	M680X_INS_MINM,
	M680X_INS_MOV,
	M680X_INS_MOVB,
	M680X_INS_MOVW,
	M680X_INS_MUL,
	M680X_INS_MULD,
	M680X_INS_NEG,
	M680X_INS_NEGA,
	M680X_INS_NEGB,
	M680X_INS_NEGD,
	M680X_INS_NEGX,
	M680X_INS_NOP,
	M680X_INS_NSA,
	M680X_INS_OIM,
	M680X_INS_ORA,
	M680X_INS_ORAA, ///< M6800/1/2/3
	M680X_INS_ORAB, ///< M6800/1/2/3
	M680X_INS_ORB,
	M680X_INS_ORCC,
	M680X_INS_ORD,
	M680X_INS_ORR,
	M680X_INS_PSHA, ///< M6800/1/2/3
	M680X_INS_PSHB, ///< M6800/1/2/3
	M680X_INS_PSHC,
	M680X_INS_PSHD,
	M680X_INS_PSHH,
	M680X_INS_PSHS,
	M680X_INS_PSHSW,
	M680X_INS_PSHU,
	M680X_INS_PSHUW,
	M680X_INS_PSHX, ///< M6800/1/2/3
	M680X_INS_PSHY,
	M680X_INS_PULA, ///< M6800/1/2/3
	M680X_INS_PULB, ///< M6800/1/2/3
	M680X_INS_PULC,
	M680X_INS_PULD,
	M680X_INS_PULH,
	M680X_INS_PULS,
	M680X_INS_PULSW,
	M680X_INS_PULU,
	M680X_INS_PULUW,
	M680X_INS_PULX, ///< M6800/1/2/3
	M680X_INS_PULY,
	M680X_INS_REV,
	M680X_INS_REVW,
	M680X_INS_ROL,
	M680X_INS_ROLA,
	M680X_INS_ROLB,
	M680X_INS_ROLD,
	M680X_INS_ROLW,
	M680X_INS_ROLX,
	M680X_INS_ROR,
	M680X_INS_RORA,
	M680X_INS_RORB,
	M680X_INS_RORD,
	M680X_INS_RORW,
	M680X_INS_RORX,
	M680X_INS_RSP,
	M680X_INS_RTC,
	M680X_INS_RTI,
	M680X_INS_RTS,
	M680X_INS_SBA, ///< M6800/1/2/3
	M680X_INS_SBC,
	M680X_INS_SBCA,
	M680X_INS_SBCB,
	M680X_INS_SBCD,
	M680X_INS_SBCR,
	M680X_INS_SEC,
	M680X_INS_SEI,
	M680X_INS_SEV,
	M680X_INS_SEX,
	M680X_INS_SEXW,
	M680X_INS_SLP,
	M680X_INS_STA,
	M680X_INS_STAA, ///< M6800/1/2/3
	M680X_INS_STAB, ///< M6800/1/2/3
	M680X_INS_STB,
	M680X_INS_STBT,
	M680X_INS_STD,
	M680X_INS_STE,
	M680X_INS_STF,
	M680X_INS_STOP,
	M680X_INS_STHX,
	M680X_INS_STQ,
	M680X_INS_STS,
	M680X_INS_STU,
	M680X_INS_STW,
	M680X_INS_STX,
	M680X_INS_STY,
	M680X_INS_SUB,
	M680X_INS_SUBA,
	M680X_INS_SUBB,
	M680X_INS_SUBD,
	M680X_INS_SUBE,
	M680X_INS_SUBF,
	M680X_INS_SUBR,
	M680X_INS_SUBW,
	M680X_INS_SWI,
	M680X_INS_SWI2,
	M680X_INS_SWI3,
	M680X_INS_SYNC,
	M680X_INS_TAB, ///< M6800/1/2/3
	M680X_INS_TAP, ///< M6800/1/2/3
	M680X_INS_TAX,
	M680X_INS_TBA, ///< M6800/1/2/3
	M680X_INS_TBEQ,
	M680X_INS_TBL,
	M680X_INS_TBNE,
	M680X_INS_TEST,
	M680X_INS_TFM,
	M680X_INS_TFR,
	M680X_INS_TIM,
	M680X_INS_TPA, ///< M6800/1/2/3
	M680X_INS_TST,
	M680X_INS_TSTA,
	M680X_INS_TSTB,
	M680X_INS_TSTD,
	M680X_INS_TSTE,
	M680X_INS_TSTF,
	M680X_INS_TSTW,
	M680X_INS_TSTX,
	M680X_INS_TSX, ///< M6800/1/2/3
	M680X_INS_TSY,
	M680X_INS_TXA,
	M680X_INS_TXS, ///< M6800/1/2/3
	M680X_INS_TYS,
	M680X_INS_WAI, ///< M6800/1/2/3
	M680X_INS_WAIT,
	M680X_INS_WAV,
	M680X_INS_WAVR,
	M680X_INS_XGDX, ///< HD6301
	M680X_INS_XGDY,
	M680X_INS_ENDING,   // <-- mark the end of the list of instructions
} m680x_insn;

#ifdef __cplusplus
}
#endif

#endif

```

`capstone/include/capstone/m68k.h`:

```h
#ifndef CAPSTONE_M68K_H
#define CAPSTONE_M68K_H

/* Capstone Disassembly Engine */
/* By Daniel Collin <daniel@collin.com>, 2015-2016 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

#define M68K_OPERAND_COUNT 4

/// M68K registers and special registers
typedef enum m68k_reg {
	M68K_REG_INVALID = 0,

	M68K_REG_D0,
	M68K_REG_D1,
	M68K_REG_D2,
	M68K_REG_D3,
	M68K_REG_D4,
	M68K_REG_D5,
	M68K_REG_D6,
	M68K_REG_D7,

	M68K_REG_A0,
	M68K_REG_A1,
	M68K_REG_A2,
	M68K_REG_A3,
	M68K_REG_A4,
	M68K_REG_A5,
	M68K_REG_A6,
	M68K_REG_A7,

	M68K_REG_FP0,
	M68K_REG_FP1,
	M68K_REG_FP2,
	M68K_REG_FP3,
	M68K_REG_FP4,
	M68K_REG_FP5,
	M68K_REG_FP6,
	M68K_REG_FP7,

	M68K_REG_PC,

	M68K_REG_SR,
	M68K_REG_CCR,
	M68K_REG_SFC,
	M68K_REG_DFC,
	M68K_REG_USP,
	M68K_REG_VBR,
	M68K_REG_CACR,
	M68K_REG_CAAR,
	M68K_REG_MSP,
	M68K_REG_ISP,
	M68K_REG_TC,
	M68K_REG_ITT0,
	M68K_REG_ITT1,
	M68K_REG_DTT0,
	M68K_REG_DTT1,
	M68K_REG_MMUSR,
	M68K_REG_URP,
	M68K_REG_SRP,

	M68K_REG_FPCR,
	M68K_REG_FPSR,
	M68K_REG_FPIAR,

	M68K_REG_ENDING,   // <-- mark the end of the list of registers
} m68k_reg;

/// M68K Addressing Modes
typedef enum m68k_address_mode {
	M68K_AM_NONE = 0,			///< No address mode.

	M68K_AM_REG_DIRECT_DATA,		///< Register Direct - Data
	M68K_AM_REG_DIRECT_ADDR,		///< Register Direct - Address

	M68K_AM_REGI_ADDR,				///< Register Indirect - Address
	M68K_AM_REGI_ADDR_POST_INC,		///< Register Indirect - Address with Postincrement
	M68K_AM_REGI_ADDR_PRE_DEC,		///< Register Indirect - Address with Predecrement
	M68K_AM_REGI_ADDR_DISP,			///< Register Indirect - Address with Displacement

	M68K_AM_AREGI_INDEX_8_BIT_DISP,	///< Address Register Indirect With Index- 8-bit displacement
	M68K_AM_AREGI_INDEX_BASE_DISP,	///< Address Register Indirect With Index- Base displacement

	M68K_AM_MEMI_POST_INDEX,		///< Memory indirect - Postindex
	M68K_AM_MEMI_PRE_INDEX,			///< Memory indirect - Preindex

	M68K_AM_PCI_DISP,				///< Program Counter Indirect - with Displacement

	M68K_AM_PCI_INDEX_8_BIT_DISP,	///< Program Counter Indirect with Index - with 8-Bit Displacement
	M68K_AM_PCI_INDEX_BASE_DISP,	///< Program Counter Indirect with Index - with Base Displacement

	M68K_AM_PC_MEMI_POST_INDEX,		///< Program Counter Memory Indirect - Postindexed
	M68K_AM_PC_MEMI_PRE_INDEX,		///< Program Counter Memory Indirect - Preindexed

	M68K_AM_ABSOLUTE_DATA_SHORT,	///< Absolute Data Addressing  - Short
	M68K_AM_ABSOLUTE_DATA_LONG,		///< Absolute Data Addressing  - Long
	M68K_AM_IMMEDIATE,              ///< Immediate value

	M68K_AM_BRANCH_DISPLACEMENT,    ///< Address as displacement from (PC+2) used by branches
} m68k_address_mode;

/// Operand type for instruction's operands
typedef enum m68k_op_type {
	M68K_OP_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	M68K_OP_REG,         ///< = CS_OP_REG (Register operand).
	M68K_OP_IMM,         ///< = CS_OP_IMM (Immediate operand).
	M68K_OP_MEM,         ///< = CS_OP_MEM (Memory operand).
	M68K_OP_FP_SINGLE,   ///< single precision Floating-Point operand
	M68K_OP_FP_DOUBLE,   ///< double precision Floating-Point operand
	M68K_OP_REG_BITS,    ///< Register bits move
	M68K_OP_REG_PAIR,    ///< Register pair in the same op (upper 4 bits for first reg, lower for second)
	M68K_OP_BR_DISP,     ///< Branch displacement
} m68k_op_type;

/// Instruction's operand referring to memory
/// This is associated with M68K_OP_MEM operand type above
typedef struct m68k_op_mem {
	m68k_reg base_reg;      ///< base register (or M68K_REG_INVALID if irrelevant)
	m68k_reg index_reg;     ///< index register (or M68K_REG_INVALID if irrelevant)
	m68k_reg in_base_reg;   ///< indirect base register (or M68K_REG_INVALID if irrelevant)
	uint32_t in_disp; 	    ///< indirect displacement
	uint32_t out_disp;      ///< other displacement
	int16_t disp;	        ///< displacement value
	uint8_t scale;	        ///< scale for index register
	uint8_t bitfield;       ///< set to true if the two values below should be used
	uint8_t width;	        ///< used for bf* instructions
	uint8_t offset;	        ///< used for bf* instructions
	uint8_t index_size;     ///< 0 = w, 1 = l
} m68k_op_mem;

/// Operand type for instruction's operands
typedef enum m68k_op_br_disp_size {
	M68K_OP_BR_DISP_SIZE_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	M68K_OP_BR_DISP_SIZE_BYTE = 1,    ///< signed 8-bit displacement
	M68K_OP_BR_DISP_SIZE_WORD = 2,    ///< signed 16-bit displacement
	M68K_OP_BR_DISP_SIZE_LONG = 4,    ///< signed 32-bit displacement
} m68k_op_br_disp_size;

typedef struct m68k_op_br_disp {
	int32_t disp;	        ///< displacement value
	uint8_t disp_size;		///< Size from m68k_op_br_disp_size type above
} m68k_op_br_disp;

/// Instruction operand
typedef struct cs_m68k_op {
	union {
		uint64_t imm;               ///< immediate value for IMM operand
		double dimm; 		    ///< double imm
		float simm; 		    ///< float imm
		m68k_reg reg;		    ///< register value for REG operand
		struct {		    ///< register pair in one operand
			m68k_reg reg_0;
			m68k_reg reg_1;
		} reg_pair;
	};

	m68k_op_mem mem; 	    ///< data when operand is targeting memory
	m68k_op_br_disp br_disp; ///< data when operand is a branch displacement
	uint32_t register_bits; ///< register bits for movem etc. (always in d0-d7, a0-a7, fp0 - fp7 order)
	m68k_op_type type;
	m68k_address_mode address_mode;	///< M68K addressing mode for this op
} cs_m68k_op;

/// Operation size of the CPU instructions
typedef enum m68k_cpu_size {
	M68K_CPU_SIZE_NONE = 0,		///< unsized or unspecified
	M68K_CPU_SIZE_BYTE = 1,		///< 1 byte in size
	M68K_CPU_SIZE_WORD = 2,		///< 2 bytes in size
	M68K_CPU_SIZE_LONG = 4,		///< 4 bytes in size
} m68k_cpu_size;

/// Operation size of the FPU instructions (Notice that FPU instruction can also use CPU sizes if needed)
typedef enum m68k_fpu_size {
	M68K_FPU_SIZE_NONE = 0,		///< unsized like fsave/frestore
	M68K_FPU_SIZE_SINGLE = 4,		///< 4 byte in size (single float)
	M68K_FPU_SIZE_DOUBLE = 8,		///< 8 byte in size (double)
	M68K_FPU_SIZE_EXTENDED = 12,	///< 12 byte in size (extended real format)
} m68k_fpu_size;

/// Type of size that is being used for the current instruction
typedef enum m68k_size_type {
	M68K_SIZE_TYPE_INVALID = 0,

	M68K_SIZE_TYPE_CPU,
	M68K_SIZE_TYPE_FPU,
} m68k_size_type;

/// Operation size of the current instruction (NOT the actually size of instruction)
typedef struct m68k_op_size {
	m68k_size_type type;
	union {
		m68k_cpu_size cpu_size;
		m68k_fpu_size fpu_size;
	};
} m68k_op_size;

/// The M68K instruction and it's operands
typedef struct cs_m68k {
	// Number of operands of this instruction or 0 when instruction has no operand.
	cs_m68k_op operands[M68K_OPERAND_COUNT]; ///< operands for this instruction.
	m68k_op_size op_size;	///< size of data operand works on in bytes (.b, .w, .l, etc)
	uint8_t op_count; ///< number of operands for the instruction
} cs_m68k;

/// M68K instruction
typedef enum m68k_insn {
	M68K_INS_INVALID = 0,

	M68K_INS_ABCD,
	M68K_INS_ADD,
	M68K_INS_ADDA,
	M68K_INS_ADDI,
	M68K_INS_ADDQ,
	M68K_INS_ADDX,
	M68K_INS_AND,
	M68K_INS_ANDI,
	M68K_INS_ASL,
	M68K_INS_ASR,
	M68K_INS_BHS,
	M68K_INS_BLO,
	M68K_INS_BHI,
	M68K_INS_BLS,
	M68K_INS_BCC,
	M68K_INS_BCS,
	M68K_INS_BNE,
	M68K_INS_BEQ,
	M68K_INS_BVC,
	M68K_INS_BVS,
	M68K_INS_BPL,
	M68K_INS_BMI,
	M68K_INS_BGE,
	M68K_INS_BLT,
	M68K_INS_BGT,
	M68K_INS_BLE,
	M68K_INS_BRA,
	M68K_INS_BSR,
	M68K_INS_BCHG,
	M68K_INS_BCLR,
	M68K_INS_BSET,
	M68K_INS_BTST,
	M68K_INS_BFCHG,
	M68K_INS_BFCLR,
	M68K_INS_BFEXTS,
	M68K_INS_BFEXTU,
	M68K_INS_BFFFO,
	M68K_INS_BFINS,
	M68K_INS_BFSET,
	M68K_INS_BFTST,
	M68K_INS_BKPT,
	M68K_INS_CALLM,
	M68K_INS_CAS,
	M68K_INS_CAS2,
	M68K_INS_CHK,
	M68K_INS_CHK2,
	M68K_INS_CLR,
	M68K_INS_CMP,
	M68K_INS_CMPA,
	M68K_INS_CMPI,
	M68K_INS_CMPM,
	M68K_INS_CMP2,
	M68K_INS_CINVL,
	M68K_INS_CINVP,
	M68K_INS_CINVA,
	M68K_INS_CPUSHL,
	M68K_INS_CPUSHP,
	M68K_INS_CPUSHA,
	M68K_INS_DBT,
	M68K_INS_DBF,
	M68K_INS_DBHI,
	M68K_INS_DBLS,
	M68K_INS_DBCC,
	M68K_INS_DBCS,
	M68K_INS_DBNE,
	M68K_INS_DBEQ,
	M68K_INS_DBVC,
	M68K_INS_DBVS,
	M68K_INS_DBPL,
	M68K_INS_DBMI,
	M68K_INS_DBGE,
	M68K_INS_DBLT,
	M68K_INS_DBGT,
	M68K_INS_DBLE,
	M68K_INS_DBRA,
	M68K_INS_DIVS,
	M68K_INS_DIVSL,
	M68K_INS_DIVU,
	M68K_INS_DIVUL,
	M68K_INS_EOR,
	M68K_INS_EORI,
	M68K_INS_EXG,
	M68K_INS_EXT,
	M68K_INS_EXTB,
	M68K_INS_FABS,
	M68K_INS_FSABS,
	M68K_INS_FDABS,
	M68K_INS_FACOS,
	M68K_INS_FADD,
	M68K_INS_FSADD,
	M68K_INS_FDADD,
	M68K_INS_FASIN,
	M68K_INS_FATAN,
	M68K_INS_FATANH,
	M68K_INS_FBF,
	M68K_INS_FBEQ,
	M68K_INS_FBOGT,
	M68K_INS_FBOGE,
	M68K_INS_FBOLT,
	M68K_INS_FBOLE,
	M68K_INS_FBOGL,
	M68K_INS_FBOR,
	M68K_INS_FBUN,
	M68K_INS_FBUEQ,
	M68K_INS_FBUGT,
	M68K_INS_FBUGE,
	M68K_INS_FBULT,
	M68K_INS_FBULE,
	M68K_INS_FBNE,
	M68K_INS_FBT,
	M68K_INS_FBSF,
	M68K_INS_FBSEQ,
	M68K_INS_FBGT,
	M68K_INS_FBGE,
	M68K_INS_FBLT,
	M68K_INS_FBLE,
	M68K_INS_FBGL,
	M68K_INS_FBGLE,
	M68K_INS_FBNGLE,
	M68K_INS_FBNGL,
	M68K_INS_FBNLE,
	M68K_INS_FBNLT,
	M68K_INS_FBNGE,
	M68K_INS_FBNGT,
	M68K_INS_FBSNE,
	M68K_INS_FBST,
	M68K_INS_FCMP,
	M68K_INS_FCOS,
	M68K_INS_FCOSH,
	M68K_INS_FDBF,
	M68K_INS_FDBEQ,
	M68K_INS_FDBOGT,
	M68K_INS_FDBOGE,
	M68K_INS_FDBOLT,
	M68K_INS_FDBOLE,
	M68K_INS_FDBOGL,
	M68K_INS_FDBOR,
	M68K_INS_FDBUN,
	M68K_INS_FDBUEQ,
	M68K_INS_FDBUGT,
	M68K_INS_FDBUGE,
	M68K_INS_FDBULT,
	M68K_INS_FDBULE,
	M68K_INS_FDBNE,
	M68K_INS_FDBT,
	M68K_INS_FDBSF,
	M68K_INS_FDBSEQ,
	M68K_INS_FDBGT,
	M68K_INS_FDBGE,
	M68K_INS_FDBLT,
	M68K_INS_FDBLE,
	M68K_INS_FDBGL,
	M68K_INS_FDBGLE,
	M68K_INS_FDBNGLE,
	M68K_INS_FDBNGL,
	M68K_INS_FDBNLE,
	M68K_INS_FDBNLT,
	M68K_INS_FDBNGE,
	M68K_INS_FDBNGT,
	M68K_INS_FDBSNE,
	M68K_INS_FDBST,
	M68K_INS_FDIV,
	M68K_INS_FSDIV,
	M68K_INS_FDDIV,
	M68K_INS_FETOX,
	M68K_INS_FETOXM1,
	M68K_INS_FGETEXP,
	M68K_INS_FGETMAN,
	M68K_INS_FINT,
	M68K_INS_FINTRZ,
	M68K_INS_FLOG10,
	M68K_INS_FLOG2,
	M68K_INS_FLOGN,
	M68K_INS_FLOGNP1,
	M68K_INS_FMOD,
	M68K_INS_FMOVE,
	M68K_INS_FSMOVE,
	M68K_INS_FDMOVE,
	M68K_INS_FMOVECR,
	M68K_INS_FMOVEM,
	M68K_INS_FMUL,
	M68K_INS_FSMUL,
	M68K_INS_FDMUL,
	M68K_INS_FNEG,
	M68K_INS_FSNEG,
	M68K_INS_FDNEG,
	M68K_INS_FNOP,
	M68K_INS_FREM,
	M68K_INS_FRESTORE,
	M68K_INS_FSAVE,
	M68K_INS_FSCALE,
	M68K_INS_FSGLDIV,
	M68K_INS_FSGLMUL,
	M68K_INS_FSIN,
	M68K_INS_FSINCOS,
	M68K_INS_FSINH,
	M68K_INS_FSQRT,
	M68K_INS_FSSQRT,
	M68K_INS_FDSQRT,
	M68K_INS_FSF,
	M68K_INS_FSBEQ,
	M68K_INS_FSOGT,
	M68K_INS_FSOGE,
	M68K_INS_FSOLT,
	M68K_INS_FSOLE,
	M68K_INS_FSOGL,
	M68K_INS_FSOR,
	M68K_INS_FSUN,
	M68K_INS_FSUEQ,
	M68K_INS_FSUGT,
	M68K_INS_FSUGE,
	M68K_INS_FSULT,
	M68K_INS_FSULE,
	M68K_INS_FSNE,
	M68K_INS_FST,
	M68K_INS_FSSF,
	M68K_INS_FSSEQ,
	M68K_INS_FSGT,
	M68K_INS_FSGE,
	M68K_INS_FSLT,
	M68K_INS_FSLE,
	M68K_INS_FSGL,
	M68K_INS_FSGLE,
	M68K_INS_FSNGLE,
	M68K_INS_FSNGL,
	M68K_INS_FSNLE,
	M68K_INS_FSNLT,
	M68K_INS_FSNGE,
	M68K_INS_FSNGT,
	M68K_INS_FSSNE,
	M68K_INS_FSST,
	M68K_INS_FSUB,
	M68K_INS_FSSUB,
	M68K_INS_FDSUB,
	M68K_INS_FTAN,
	M68K_INS_FTANH,
	M68K_INS_FTENTOX,
	M68K_INS_FTRAPF,
	M68K_INS_FTRAPEQ,
	M68K_INS_FTRAPOGT,
	M68K_INS_FTRAPOGE,
	M68K_INS_FTRAPOLT,
	M68K_INS_FTRAPOLE,
	M68K_INS_FTRAPOGL,
	M68K_INS_FTRAPOR,
	M68K_INS_FTRAPUN,
	M68K_INS_FTRAPUEQ,
	M68K_INS_FTRAPUGT,
	M68K_INS_FTRAPUGE,
	M68K_INS_FTRAPULT,
	M68K_INS_FTRAPULE,
	M68K_INS_FTRAPNE,
	M68K_INS_FTRAPT,
	M68K_INS_FTRAPSF,
	M68K_INS_FTRAPSEQ,
	M68K_INS_FTRAPGT,
	M68K_INS_FTRAPGE,
	M68K_INS_FTRAPLT,
	M68K_INS_FTRAPLE,
	M68K_INS_FTRAPGL,
	M68K_INS_FTRAPGLE,
	M68K_INS_FTRAPNGLE,
	M68K_INS_FTRAPNGL,
	M68K_INS_FTRAPNLE,
	M68K_INS_FTRAPNLT,
	M68K_INS_FTRAPNGE,
	M68K_INS_FTRAPNGT,
	M68K_INS_FTRAPSNE,
	M68K_INS_FTRAPST,
	M68K_INS_FTST,
	M68K_INS_FTWOTOX,
	M68K_INS_HALT,
	M68K_INS_ILLEGAL,
	M68K_INS_JMP,
	M68K_INS_JSR,
	M68K_INS_LEA,
	M68K_INS_LINK,
	M68K_INS_LPSTOP,
	M68K_INS_LSL,
	M68K_INS_LSR,
	M68K_INS_MOVE,
	M68K_INS_MOVEA,
	M68K_INS_MOVEC,
	M68K_INS_MOVEM,
	M68K_INS_MOVEP,
	M68K_INS_MOVEQ,
	M68K_INS_MOVES,
	M68K_INS_MOVE16,
	M68K_INS_MULS,
	M68K_INS_MULU,
	M68K_INS_NBCD,
	M68K_INS_NEG,
	M68K_INS_NEGX,
	M68K_INS_NOP,
	M68K_INS_NOT,
	M68K_INS_OR,
	M68K_INS_ORI,
	M68K_INS_PACK,
	M68K_INS_PEA,
	M68K_INS_PFLUSH,
	M68K_INS_PFLUSHA,
	M68K_INS_PFLUSHAN,
	M68K_INS_PFLUSHN,
	M68K_INS_PLOADR,
	M68K_INS_PLOADW,
	M68K_INS_PLPAR,
	M68K_INS_PLPAW,
	M68K_INS_PMOVE,
	M68K_INS_PMOVEFD,
	M68K_INS_PTESTR,
	M68K_INS_PTESTW,
	M68K_INS_PULSE,
	M68K_INS_REMS,
	M68K_INS_REMU,
	M68K_INS_RESET,
	M68K_INS_ROL,
	M68K_INS_ROR,
	M68K_INS_ROXL,
	M68K_INS_ROXR,
	M68K_INS_RTD,
	M68K_INS_RTE,
	M68K_INS_RTM,
	M68K_INS_RTR,
	M68K_INS_RTS,
	M68K_INS_SBCD,
	M68K_INS_ST,
	M68K_INS_SF,
	M68K_INS_SHI,
	M68K_INS_SLS,
	M68K_INS_SCC,
	M68K_INS_SHS,
	M68K_INS_SCS,
	M68K_INS_SLO,
	M68K_INS_SNE,
	M68K_INS_SEQ,
	M68K_INS_SVC,
	M68K_INS_SVS,
	M68K_INS_SPL,
	M68K_INS_SMI,
	M68K_INS_SGE,
	M68K_INS_SLT,
	M68K_INS_SGT,
	M68K_INS_SLE,
	M68K_INS_STOP,
	M68K_INS_SUB,
	M68K_INS_SUBA,
	M68K_INS_SUBI,
	M68K_INS_SUBQ,
	M68K_INS_SUBX,
	M68K_INS_SWAP,
	M68K_INS_TAS,
	M68K_INS_TRAP,
	M68K_INS_TRAPV,
	M68K_INS_TRAPT,
	M68K_INS_TRAPF,
	M68K_INS_TRAPHI,
	M68K_INS_TRAPLS,
	M68K_INS_TRAPCC,
	M68K_INS_TRAPHS,
	M68K_INS_TRAPCS,
	M68K_INS_TRAPLO,
	M68K_INS_TRAPNE,
	M68K_INS_TRAPEQ,
	M68K_INS_TRAPVC,
	M68K_INS_TRAPVS,
	M68K_INS_TRAPPL,
	M68K_INS_TRAPMI,
	M68K_INS_TRAPGE,
	M68K_INS_TRAPLT,
	M68K_INS_TRAPGT,
	M68K_INS_TRAPLE,
	M68K_INS_TST,
	M68K_INS_UNLK,
	M68K_INS_UNPK,
	M68K_INS_ENDING,   // <-- mark the end of the list of instructions
} m68k_insn;

/// Group of M68K instructions
typedef enum m68k_group_type {
	M68K_GRP_INVALID = 0,  ///< CS_GRUP_INVALID
	M68K_GRP_JUMP,  ///< = CS_GRP_JUMP
	M68K_GRP_RET = 3,  ///< = CS_GRP_RET
	M68K_GRP_IRET = 5, ///< = CS_GRP_IRET
	M68K_GRP_BRANCH_RELATIVE = 7, ///< = CS_GRP_BRANCH_RELATIVE

	M68K_GRP_ENDING,// <-- mark the end of the list of groups
} m68k_group_type;

#ifdef __cplusplus
}
#endif

#endif

```

`capstone/include/capstone/mips.h`:

```h
#ifndef CAPSTONE_MIPS_H
#define CAPSTONE_MIPS_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

// GCC MIPS toolchain has a default macro called "mips" which breaks
// compilation
#undef mips

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

/// Operand type for instruction's operands
typedef enum mips_op_type {
	MIPS_OP_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	MIPS_OP_REG, ///< = CS_OP_REG (Register operand).
	MIPS_OP_IMM, ///< = CS_OP_IMM (Immediate operand).
	MIPS_OP_MEM, ///< = CS_OP_MEM (Memory operand).
} mips_op_type;

/// MIPS registers
typedef enum mips_reg {
	MIPS_REG_INVALID = 0,
	// General purpose registers
	MIPS_REG_PC,

	MIPS_REG_0,
	MIPS_REG_1,
	MIPS_REG_2,
	MIPS_REG_3,
	MIPS_REG_4,
	MIPS_REG_5,
	MIPS_REG_6,
	MIPS_REG_7,
	MIPS_REG_8,
	MIPS_REG_9,
	MIPS_REG_10,
	MIPS_REG_11,
	MIPS_REG_12,
	MIPS_REG_13,
	MIPS_REG_14,
	MIPS_REG_15,
	MIPS_REG_16,
	MIPS_REG_17,
	MIPS_REG_18,
	MIPS_REG_19,
	MIPS_REG_20,
	MIPS_REG_21,
	MIPS_REG_22,
	MIPS_REG_23,
	MIPS_REG_24,
	MIPS_REG_25,
	MIPS_REG_26,
	MIPS_REG_27,
	MIPS_REG_28,
	MIPS_REG_29,
	MIPS_REG_30,
	MIPS_REG_31,

	// DSP registers
	MIPS_REG_DSPCCOND,
	MIPS_REG_DSPCARRY,
	MIPS_REG_DSPEFI,
	MIPS_REG_DSPOUTFLAG,
	MIPS_REG_DSPOUTFLAG16_19,
	MIPS_REG_DSPOUTFLAG20,
	MIPS_REG_DSPOUTFLAG21,
	MIPS_REG_DSPOUTFLAG22,
	MIPS_REG_DSPOUTFLAG23,
	MIPS_REG_DSPPOS,
	MIPS_REG_DSPSCOUNT,

	// ACC registers
	MIPS_REG_AC0,
	MIPS_REG_AC1,
	MIPS_REG_AC2,
	MIPS_REG_AC3,

	// COP registers
	MIPS_REG_CC0,
	MIPS_REG_CC1,
	MIPS_REG_CC2,
	MIPS_REG_CC3,
	MIPS_REG_CC4,
	MIPS_REG_CC5,
	MIPS_REG_CC6,
	MIPS_REG_CC7,

	// FPU registers
	MIPS_REG_F0,
	MIPS_REG_F1,
	MIPS_REG_F2,
	MIPS_REG_F3,
	MIPS_REG_F4,
	MIPS_REG_F5,
	MIPS_REG_F6,
	MIPS_REG_F7,
	MIPS_REG_F8,
	MIPS_REG_F9,
	MIPS_REG_F10,
	MIPS_REG_F11,
	MIPS_REG_F12,
	MIPS_REG_F13,
	MIPS_REG_F14,
	MIPS_REG_F15,
	MIPS_REG_F16,
	MIPS_REG_F17,
	MIPS_REG_F18,
	MIPS_REG_F19,
	MIPS_REG_F20,
	MIPS_REG_F21,
	MIPS_REG_F22,
	MIPS_REG_F23,
	MIPS_REG_F24,
	MIPS_REG_F25,
	MIPS_REG_F26,
	MIPS_REG_F27,
	MIPS_REG_F28,
	MIPS_REG_F29,
	MIPS_REG_F30,
	MIPS_REG_F31,

	MIPS_REG_FCC0,
	MIPS_REG_FCC1,
	MIPS_REG_FCC2,
	MIPS_REG_FCC3,
	MIPS_REG_FCC4,
	MIPS_REG_FCC5,
	MIPS_REG_FCC6,
	MIPS_REG_FCC7,

	// AFPR128
	MIPS_REG_W0,
	MIPS_REG_W1,
	MIPS_REG_W2,
	MIPS_REG_W3,
	MIPS_REG_W4,
	MIPS_REG_W5,
	MIPS_REG_W6,
	MIPS_REG_W7,
	MIPS_REG_W8,
	MIPS_REG_W9,
	MIPS_REG_W10,
	MIPS_REG_W11,
	MIPS_REG_W12,
	MIPS_REG_W13,
	MIPS_REG_W14,
	MIPS_REG_W15,
	MIPS_REG_W16,
	MIPS_REG_W17,
	MIPS_REG_W18,
	MIPS_REG_W19,
	MIPS_REG_W20,
	MIPS_REG_W21,
	MIPS_REG_W22,
	MIPS_REG_W23,
	MIPS_REG_W24,
	MIPS_REG_W25,
	MIPS_REG_W26,
	MIPS_REG_W27,
	MIPS_REG_W28,
	MIPS_REG_W29,
	MIPS_REG_W30,
	MIPS_REG_W31,

	MIPS_REG_HI,
	MIPS_REG_LO,

	MIPS_REG_P0,
	MIPS_REG_P1,
	MIPS_REG_P2,

	MIPS_REG_MPL0,
	MIPS_REG_MPL1,
	MIPS_REG_MPL2,

	MIPS_REG_ENDING,	// <-- mark the end of the list or registers

	// alias registers
	MIPS_REG_ZERO = MIPS_REG_0,
	MIPS_REG_AT = MIPS_REG_1,
	MIPS_REG_V0 = MIPS_REG_2,
	MIPS_REG_V1 = MIPS_REG_3,
	MIPS_REG_A0 = MIPS_REG_4,
	MIPS_REG_A1 = MIPS_REG_5,
	MIPS_REG_A2 = MIPS_REG_6,
	MIPS_REG_A3 = MIPS_REG_7,
	MIPS_REG_T0 = MIPS_REG_8,
	MIPS_REG_T1 = MIPS_REG_9,
	MIPS_REG_T2 = MIPS_REG_10,
	MIPS_REG_T3 = MIPS_REG_11,
	MIPS_REG_T4 = MIPS_REG_12,
	MIPS_REG_T5 = MIPS_REG_13,
	MIPS_REG_T6 = MIPS_REG_14,
	MIPS_REG_T7 = MIPS_REG_15,
	MIPS_REG_S0 = MIPS_REG_16,
	MIPS_REG_S1 = MIPS_REG_17,
	MIPS_REG_S2 = MIPS_REG_18,
	MIPS_REG_S3 = MIPS_REG_19,
	MIPS_REG_S4 = MIPS_REG_20,
	MIPS_REG_S5 = MIPS_REG_21,
	MIPS_REG_S6 = MIPS_REG_22,
	MIPS_REG_S7 = MIPS_REG_23,
	MIPS_REG_T8 = MIPS_REG_24,
	MIPS_REG_T9 = MIPS_REG_25,
	MIPS_REG_K0 = MIPS_REG_26,
	MIPS_REG_K1 = MIPS_REG_27,
	MIPS_REG_GP = MIPS_REG_28,
	MIPS_REG_SP = MIPS_REG_29,
	MIPS_REG_FP = MIPS_REG_30, MIPS_REG_S8 = MIPS_REG_30,
	MIPS_REG_RA = MIPS_REG_31,

	MIPS_REG_HI0 = MIPS_REG_AC0,
	MIPS_REG_HI1 = MIPS_REG_AC1,
	MIPS_REG_HI2 = MIPS_REG_AC2,
	MIPS_REG_HI3 = MIPS_REG_AC3,

	MIPS_REG_LO0 = MIPS_REG_HI0,
	MIPS_REG_LO1 = MIPS_REG_HI1,
	MIPS_REG_LO2 = MIPS_REG_HI2,
	MIPS_REG_LO3 = MIPS_REG_HI3,
} mips_reg;

/// Instruction's operand referring to memory
/// This is associated with MIPS_OP_MEM operand type above
typedef struct mips_op_mem {
	mips_reg base;	///< base register
	int64_t disp;	///< displacement/offset value
} mips_op_mem;

/// Instruction operand
typedef struct cs_mips_op {
	mips_op_type type;	///< operand type
	union {
		mips_reg reg;		///< register value for REG operand
		int64_t imm;		///< immediate value for IMM operand
		mips_op_mem mem;	///< base/index/scale/disp value for MEM operand
	};
} cs_mips_op;

/// Instruction structure
typedef struct cs_mips {
	/// Number of operands of this instruction,
	/// or 0 when instruction has no operand.
	uint8_t op_count;
	cs_mips_op operands[10]; ///< operands for this instruction.
} cs_mips;

/// MIPS instruction
typedef enum mips_insn {
	MIPS_INS_INVALID = 0,

	MIPS_INS_ABSQ_S,
	MIPS_INS_ADD,
	MIPS_INS_ADDIUPC,
	MIPS_INS_ADDIUR1SP,
	MIPS_INS_ADDIUR2,
	MIPS_INS_ADDIUS5,
	MIPS_INS_ADDIUSP,
	MIPS_INS_ADDQH,
	MIPS_INS_ADDQH_R,
	MIPS_INS_ADDQ,
	MIPS_INS_ADDQ_S,
	MIPS_INS_ADDSC,
	MIPS_INS_ADDS_A,
	MIPS_INS_ADDS_S,
	MIPS_INS_ADDS_U,
	MIPS_INS_ADDU16,
	MIPS_INS_ADDUH,
	MIPS_INS_ADDUH_R,
	MIPS_INS_ADDU,
	MIPS_INS_ADDU_S,
	MIPS_INS_ADDVI,
	MIPS_INS_ADDV,
	MIPS_INS_ADDWC,
	MIPS_INS_ADD_A,
	MIPS_INS_ADDI,
	MIPS_INS_ADDIU,
	MIPS_INS_ALIGN,
	MIPS_INS_ALUIPC,
	MIPS_INS_AND,
	MIPS_INS_AND16,
	MIPS_INS_ANDI16,
	MIPS_INS_ANDI,
	MIPS_INS_APPEND,
	MIPS_INS_ASUB_S,
	MIPS_INS_ASUB_U,
	MIPS_INS_AUI,
	MIPS_INS_AUIPC,
	MIPS_INS_AVER_S,
	MIPS_INS_AVER_U,
	MIPS_INS_AVE_S,
	MIPS_INS_AVE_U,
	MIPS_INS_B16,
	MIPS_INS_BADDU,
	MIPS_INS_BAL,
	MIPS_INS_BALC,
	MIPS_INS_BALIGN,
	MIPS_INS_BBIT0,
	MIPS_INS_BBIT032,
	MIPS_INS_BBIT1,
	MIPS_INS_BBIT132,
	MIPS_INS_BC,
	MIPS_INS_BC0F,
	MIPS_INS_BC0FL,
	MIPS_INS_BC0T,
	MIPS_INS_BC0TL,
	MIPS_INS_BC1EQZ,
	MIPS_INS_BC1F,
	MIPS_INS_BC1FL,
	MIPS_INS_BC1NEZ,
	MIPS_INS_BC1T,
	MIPS_INS_BC1TL,
	MIPS_INS_BC2EQZ,
	MIPS_INS_BC2F,
	MIPS_INS_BC2FL,
	MIPS_INS_BC2NEZ,
	MIPS_INS_BC2T,
	MIPS_INS_BC2TL,
	MIPS_INS_BC3F,
	MIPS_INS_BC3FL,
	MIPS_INS_BC3T,
	MIPS_INS_BC3TL,
	MIPS_INS_BCLRI,
	MIPS_INS_BCLR,
	MIPS_INS_BEQ,
	MIPS_INS_BEQC,
	MIPS_INS_BEQL,
	MIPS_INS_BEQZ16,
	MIPS_INS_BEQZALC,
	MIPS_INS_BEQZC,
	MIPS_INS_BGEC,
	MIPS_INS_BGEUC,
	MIPS_INS_BGEZ,
	MIPS_INS_BGEZAL,
	MIPS_INS_BGEZALC,
	MIPS_INS_BGEZALL,
	MIPS_INS_BGEZALS,
	MIPS_INS_BGEZC,
	MIPS_INS_BGEZL,
	MIPS_INS_BGTZ,
	MIPS_INS_BGTZALC,
	MIPS_INS_BGTZC,
	MIPS_INS_BGTZL,
	MIPS_INS_BINSLI,
	MIPS_INS_BINSL,
	MIPS_INS_BINSRI,
	MIPS_INS_BINSR,
	MIPS_INS_BITREV,
	MIPS_INS_BITSWAP,
	MIPS_INS_BLEZ,
	MIPS_INS_BLEZALC,
	MIPS_INS_BLEZC,
	MIPS_INS_BLEZL,
	MIPS_INS_BLTC,
	MIPS_INS_BLTUC,
	MIPS_INS_BLTZ,
	MIPS_INS_BLTZAL,
	MIPS_INS_BLTZALC,
	MIPS_INS_BLTZALL,
	MIPS_INS_BLTZALS,
	MIPS_INS_BLTZC,
	MIPS_INS_BLTZL,
	MIPS_INS_BMNZI,
	MIPS_INS_BMNZ,
	MIPS_INS_BMZI,
	MIPS_INS_BMZ,
	MIPS_INS_BNE,
	MIPS_INS_BNEC,
	MIPS_INS_BNEGI,
	MIPS_INS_BNEG,
	MIPS_INS_BNEL,
	MIPS_INS_BNEZ16,
	MIPS_INS_BNEZALC,
	MIPS_INS_BNEZC,
	MIPS_INS_BNVC,
	MIPS_INS_BNZ,
	MIPS_INS_BOVC,
	MIPS_INS_BPOSGE32,
	MIPS_INS_BREAK,
	MIPS_INS_BREAK16,
	MIPS_INS_BSELI,
	MIPS_INS_BSEL,
	MIPS_INS_BSETI,
	MIPS_INS_BSET,
	MIPS_INS_BZ,
	MIPS_INS_BEQZ,
	MIPS_INS_B,
	MIPS_INS_BNEZ,
	MIPS_INS_BTEQZ,
	MIPS_INS_BTNEZ,
	MIPS_INS_CACHE,
	MIPS_INS_CEIL,
	MIPS_INS_CEQI,
	MIPS_INS_CEQ,
	MIPS_INS_CFC1,
	MIPS_INS_CFCMSA,
	MIPS_INS_CINS,
	MIPS_INS_CINS32,
	MIPS_INS_CLASS,
	MIPS_INS_CLEI_S,
	MIPS_INS_CLEI_U,
	MIPS_INS_CLE_S,
	MIPS_INS_CLE_U,
	MIPS_INS_CLO,
	MIPS_INS_CLTI_S,
	MIPS_INS_CLTI_U,
	MIPS_INS_CLT_S,
	MIPS_INS_CLT_U,
	MIPS_INS_CLZ,
	MIPS_INS_CMPGDU,
	MIPS_INS_CMPGU,
	MIPS_INS_CMPU,
	MIPS_INS_CMP,
	MIPS_INS_COPY_S,
	MIPS_INS_COPY_U,
	MIPS_INS_CTC1,
	MIPS_INS_CTCMSA,
	MIPS_INS_CVT,
	MIPS_INS_C,
	MIPS_INS_CMPI,
	MIPS_INS_DADD,
	MIPS_INS_DADDI,
	MIPS_INS_DADDIU,
	MIPS_INS_DADDU,
	MIPS_INS_DAHI,
	MIPS_INS_DALIGN,
	MIPS_INS_DATI,
	MIPS_INS_DAUI,
	MIPS_INS_DBITSWAP,
	MIPS_INS_DCLO,
	MIPS_INS_DCLZ,
	MIPS_INS_DDIV,
	MIPS_INS_DDIVU,
	MIPS_INS_DERET,
	MIPS_INS_DEXT,
	MIPS_INS_DEXTM,
	MIPS_INS_DEXTU,
	MIPS_INS_DI,
	MIPS_INS_DINS,
	MIPS_INS_DINSM,
	MIPS_INS_DINSU,
	MIPS_INS_DIV,
	MIPS_INS_DIVU,
	MIPS_INS_DIV_S,
	MIPS_INS_DIV_U,
	MIPS_INS_DLSA,
	MIPS_INS_DMFC0,
	MIPS_INS_DMFC1,
	MIPS_INS_DMFC2,
	MIPS_INS_DMOD,
	MIPS_INS_DMODU,
	MIPS_INS_DMTC0,
	MIPS_INS_DMTC1,
	MIPS_INS_DMTC2,
	MIPS_INS_DMUH,
	MIPS_INS_DMUHU,
	MIPS_INS_DMUL,
	MIPS_INS_DMULT,
	MIPS_INS_DMULTU,
	MIPS_INS_DMULU,
	MIPS_INS_DOTP_S,
	MIPS_INS_DOTP_U,
	MIPS_INS_DPADD_S,
	MIPS_INS_DPADD_U,
	MIPS_INS_DPAQX_SA,
	MIPS_INS_DPAQX_S,
	MIPS_INS_DPAQ_SA,
	MIPS_INS_DPAQ_S,
	MIPS_INS_DPAU,
	MIPS_INS_DPAX,
	MIPS_INS_DPA,
	MIPS_INS_DPOP,
	MIPS_INS_DPSQX_SA,
	MIPS_INS_DPSQX_S,
	MIPS_INS_DPSQ_SA,
	MIPS_INS_DPSQ_S,
	MIPS_INS_DPSUB_S,
	MIPS_INS_DPSUB_U,
	MIPS_INS_DPSU,
	MIPS_INS_DPSX,
	MIPS_INS_DPS,
	MIPS_INS_DROTR,
	MIPS_INS_DROTR32,
	MIPS_INS_DROTRV,
	MIPS_INS_DSBH,
	MIPS_INS_DSHD,
	MIPS_INS_DSLL,
	MIPS_INS_DSLL32,
	MIPS_INS_DSLLV,
	MIPS_INS_DSRA,
	MIPS_INS_DSRA32,
	MIPS_INS_DSRAV,
	MIPS_INS_DSRL,
	MIPS_INS_DSRL32,
	MIPS_INS_DSRLV,
	MIPS_INS_DSUB,
	MIPS_INS_DSUBU,
	MIPS_INS_EHB,
	MIPS_INS_EI,
	MIPS_INS_ERET,
	MIPS_INS_EXT,
	MIPS_INS_EXTP,
	MIPS_INS_EXTPDP,
	MIPS_INS_EXTPDPV,
	MIPS_INS_EXTPV,
	MIPS_INS_EXTRV_RS,
	MIPS_INS_EXTRV_R,
	MIPS_INS_EXTRV_S,
	MIPS_INS_EXTRV,
	MIPS_INS_EXTR_RS,
	MIPS_INS_EXTR_R,
	MIPS_INS_EXTR_S,
	MIPS_INS_EXTR,
	MIPS_INS_EXTS,
	MIPS_INS_EXTS32,
	MIPS_INS_ABS,
	MIPS_INS_FADD,
	MIPS_INS_FCAF,
	MIPS_INS_FCEQ,
	MIPS_INS_FCLASS,
	MIPS_INS_FCLE,
	MIPS_INS_FCLT,
	MIPS_INS_FCNE,
	MIPS_INS_FCOR,
	MIPS_INS_FCUEQ,
	MIPS_INS_FCULE,
	MIPS_INS_FCULT,
	MIPS_INS_FCUNE,
	MIPS_INS_FCUN,
	MIPS_INS_FDIV,
	MIPS_INS_FEXDO,
	MIPS_INS_FEXP2,
	MIPS_INS_FEXUPL,
	MIPS_INS_FEXUPR,
	MIPS_INS_FFINT_S,
	MIPS_INS_FFINT_U,
	MIPS_INS_FFQL,
	MIPS_INS_FFQR,
	MIPS_INS_FILL,
	MIPS_INS_FLOG2,
	MIPS_INS_FLOOR,
	MIPS_INS_FMADD,
	MIPS_INS_FMAX_A,
	MIPS_INS_FMAX,
	MIPS_INS_FMIN_A,
	MIPS_INS_FMIN,
	MIPS_INS_MOV,
	MIPS_INS_FMSUB,
	MIPS_INS_FMUL,
	MIPS_INS_MUL,
	MIPS_INS_NEG,
	MIPS_INS_FRCP,
	MIPS_INS_FRINT,
	MIPS_INS_FRSQRT,
	MIPS_INS_FSAF,
	MIPS_INS_FSEQ,
	MIPS_INS_FSLE,
	MIPS_INS_FSLT,
	MIPS_INS_FSNE,
	MIPS_INS_FSOR,
	MIPS_INS_FSQRT,
	MIPS_INS_SQRT,
	MIPS_INS_FSUB,
	MIPS_INS_SUB,
	MIPS_INS_FSUEQ,
	MIPS_INS_FSULE,
	MIPS_INS_FSULT,
	MIPS_INS_FSUNE,
	MIPS_INS_FSUN,
	MIPS_INS_FTINT_S,
	MIPS_INS_FTINT_U,
	MIPS_INS_FTQ,
	MIPS_INS_FTRUNC_S,
	MIPS_INS_FTRUNC_U,
	MIPS_INS_HADD_S,
	MIPS_INS_HADD_U,
	MIPS_INS_HSUB_S,
	MIPS_INS_HSUB_U,
	MIPS_INS_ILVEV,
	MIPS_INS_ILVL,
	MIPS_INS_ILVOD,
	MIPS_INS_ILVR,
	MIPS_INS_INS,
	MIPS_INS_INSERT,
	MIPS_INS_INSV,
	MIPS_INS_INSVE,
	MIPS_INS_J,
	MIPS_INS_JAL,
	MIPS_INS_JALR,
	MIPS_INS_JALRS16,
	MIPS_INS_JALRS,
	MIPS_INS_JALS,
	MIPS_INS_JALX,
	MIPS_INS_JIALC,
	MIPS_INS_JIC,
	MIPS_INS_JR,
	MIPS_INS_JR16,
	MIPS_INS_JRADDIUSP,
	MIPS_INS_JRC,
	MIPS_INS_JALRC,
	MIPS_INS_LB,
	MIPS_INS_LBU16,
	MIPS_INS_LBUX,
	MIPS_INS_LBU,
	MIPS_INS_LD,
	MIPS_INS_LDC1,
	MIPS_INS_LDC2,
	MIPS_INS_LDC3,
	MIPS_INS_LDI,
	MIPS_INS_LDL,
	MIPS_INS_LDPC,
	MIPS_INS_LDR,
	MIPS_INS_LDXC1,
	MIPS_INS_LH,
	MIPS_INS_LHU16,
	MIPS_INS_LHX,
	MIPS_INS_LHU,
	MIPS_INS_LI16,
	MIPS_INS_LL,
	MIPS_INS_LLD,
	MIPS_INS_LSA,
	MIPS_INS_LUXC1,
	MIPS_INS_LUI,
	MIPS_INS_LW,
	MIPS_INS_LW16,
	MIPS_INS_LWC1,
	MIPS_INS_LWC2,
	MIPS_INS_LWC3,
	MIPS_INS_LWL,
	MIPS_INS_LWM16,
	MIPS_INS_LWM32,
	MIPS_INS_LWPC,
	MIPS_INS_LWP,
	MIPS_INS_LWR,
	MIPS_INS_LWUPC,
	MIPS_INS_LWU,
	MIPS_INS_LWX,
	MIPS_INS_LWXC1,
	MIPS_INS_LWXS,
	MIPS_INS_LI,
	MIPS_INS_MADD,
	MIPS_INS_MADDF,
	MIPS_INS_MADDR_Q,
	MIPS_INS_MADDU,
	MIPS_INS_MADDV,
	MIPS_INS_MADD_Q,
	MIPS_INS_MAQ_SA,
	MIPS_INS_MAQ_S,
	MIPS_INS_MAXA,
	MIPS_INS_MAXI_S,
	MIPS_INS_MAXI_U,
	MIPS_INS_MAX_A,
	MIPS_INS_MAX,
	MIPS_INS_MAX_S,
	MIPS_INS_MAX_U,
	MIPS_INS_MFC0,
	MIPS_INS_MFC1,
	MIPS_INS_MFC2,
	MIPS_INS_MFHC1,
	MIPS_INS_MFHI,
	MIPS_INS_MFLO,
	MIPS_INS_MINA,
	MIPS_INS_MINI_S,
	MIPS_INS_MINI_U,
	MIPS_INS_MIN_A,
	MIPS_INS_MIN,
	MIPS_INS_MIN_S,
	MIPS_INS_MIN_U,
	MIPS_INS_MOD,
	MIPS_INS_MODSUB,
	MIPS_INS_MODU,
	MIPS_INS_MOD_S,
	MIPS_INS_MOD_U,
	MIPS_INS_MOVE,
	MIPS_INS_MOVEP,
	MIPS_INS_MOVF,
	MIPS_INS_MOVN,
	MIPS_INS_MOVT,
	MIPS_INS_MOVZ,
	MIPS_INS_MSUB,
	MIPS_INS_MSUBF,
	MIPS_INS_MSUBR_Q,
	MIPS_INS_MSUBU,
	MIPS_INS_MSUBV,
	MIPS_INS_MSUB_Q,
	MIPS_INS_MTC0,
	MIPS_INS_MTC1,
	MIPS_INS_MTC2,
	MIPS_INS_MTHC1,
	MIPS_INS_MTHI,
	MIPS_INS_MTHLIP,
	MIPS_INS_MTLO,
	MIPS_INS_MTM0,
	MIPS_INS_MTM1,
	MIPS_INS_MTM2,
	MIPS_INS_MTP0,
	MIPS_INS_MTP1,
	MIPS_INS_MTP2,
	MIPS_INS_MUH,
	MIPS_INS_MUHU,
	MIPS_INS_MULEQ_S,
	MIPS_INS_MULEU_S,
	MIPS_INS_MULQ_RS,
	MIPS_INS_MULQ_S,
	MIPS_INS_MULR_Q,
	MIPS_INS_MULSAQ_S,
	MIPS_INS_MULSA,
	MIPS_INS_MULT,
	MIPS_INS_MULTU,
	MIPS_INS_MULU,
	MIPS_INS_MULV,
	MIPS_INS_MUL_Q,
	MIPS_INS_MUL_S,
	MIPS_INS_NLOC,
	MIPS_INS_NLZC,
	MIPS_INS_NMADD,
	MIPS_INS_NMSUB,
	MIPS_INS_NOR,
	MIPS_INS_NORI,
	MIPS_INS_NOT16,
	MIPS_INS_NOT,
	MIPS_INS_OR,
	MIPS_INS_OR16,
	MIPS_INS_ORI,
	MIPS_INS_PACKRL,
	MIPS_INS_PAUSE,
	MIPS_INS_PCKEV,
	MIPS_INS_PCKOD,
	MIPS_INS_PCNT,
	MIPS_INS_PICK,
	MIPS_INS_POP,
	MIPS_INS_PRECEQU,
	MIPS_INS_PRECEQ,
	MIPS_INS_PRECEU,
	MIPS_INS_PRECRQU_S,
	MIPS_INS_PRECRQ,
	MIPS_INS_PRECRQ_RS,
	MIPS_INS_PRECR,
	MIPS_INS_PRECR_SRA,
	MIPS_INS_PRECR_SRA_R,
	MIPS_INS_PREF,
	MIPS_INS_PREPEND,
	MIPS_INS_RADDU,
	MIPS_INS_RDDSP,
	MIPS_INS_RDHWR,
	MIPS_INS_REPLV,
	MIPS_INS_REPL,
	MIPS_INS_RINT,
	MIPS_INS_ROTR,
	MIPS_INS_ROTRV,
	MIPS_INS_ROUND,
	MIPS_INS_SAT_S,
	MIPS_INS_SAT_U,
	MIPS_INS_SB,
	MIPS_INS_SB16,
	MIPS_INS_SC,
	MIPS_INS_SCD,
	MIPS_INS_SD,
	MIPS_INS_SDBBP,
	MIPS_INS_SDBBP16,
	MIPS_INS_SDC1,
	MIPS_INS_SDC2,
	MIPS_INS_SDC3,
	MIPS_INS_SDL,
	MIPS_INS_SDR,
	MIPS_INS_SDXC1,
	MIPS_INS_SEB,
	MIPS_INS_SEH,
	MIPS_INS_SELEQZ,
	MIPS_INS_SELNEZ,
	MIPS_INS_SEL,
	MIPS_INS_SEQ,
	MIPS_INS_SEQI,
	MIPS_INS_SH,
	MIPS_INS_SH16,
	MIPS_INS_SHF,
	MIPS_INS_SHILO,
	MIPS_INS_SHILOV,
	MIPS_INS_SHLLV,
	MIPS_INS_SHLLV_S,
	MIPS_INS_SHLL,
	MIPS_INS_SHLL_S,
	MIPS_INS_SHRAV,
	MIPS_INS_SHRAV_R,
	MIPS_INS_SHRA,
	MIPS_INS_SHRA_R,
	MIPS_INS_SHRLV,
	MIPS_INS_SHRL,
	MIPS_INS_SLDI,
	MIPS_INS_SLD,
	MIPS_INS_SLL,
	MIPS_INS_SLL16,
	MIPS_INS_SLLI,
	MIPS_INS_SLLV,
	MIPS_INS_SLT,
	MIPS_INS_SLTI,
	MIPS_INS_SLTIU,
	MIPS_INS_SLTU,
	MIPS_INS_SNE,
	MIPS_INS_SNEI,
	MIPS_INS_SPLATI,
	MIPS_INS_SPLAT,
	MIPS_INS_SRA,
	MIPS_INS_SRAI,
	MIPS_INS_SRARI,
	MIPS_INS_SRAR,
	MIPS_INS_SRAV,
	MIPS_INS_SRL,
	MIPS_INS_SRL16,
	MIPS_INS_SRLI,
	MIPS_INS_SRLRI,
	MIPS_INS_SRLR,
	MIPS_INS_SRLV,
	MIPS_INS_SSNOP,
	MIPS_INS_ST,
	MIPS_INS_SUBQH,
	MIPS_INS_SUBQH_R,
	MIPS_INS_SUBQ,
	MIPS_INS_SUBQ_S,
	MIPS_INS_SUBSUS_U,
	MIPS_INS_SUBSUU_S,
	MIPS_INS_SUBS_S,
	MIPS_INS_SUBS_U,
	MIPS_INS_SUBU16,
	MIPS_INS_SUBUH,
	MIPS_INS_SUBUH_R,
	MIPS_INS_SUBU,
	MIPS_INS_SUBU_S,
	MIPS_INS_SUBVI,
	MIPS_INS_SUBV,
	MIPS_INS_SUXC1,
	MIPS_INS_SW,
	MIPS_INS_SW16,
	MIPS_INS_SWC1,
	MIPS_INS_SWC2,
	MIPS_INS_SWC3,
	MIPS_INS_SWL,
	MIPS_INS_SWM16,
	MIPS_INS_SWM32,
	MIPS_INS_SWP,
	MIPS_INS_SWR,
	MIPS_INS_SWXC1,
	MIPS_INS_SYNC,
	MIPS_INS_SYNCI,
	MIPS_INS_SYSCALL,
	MIPS_INS_TEQ,
	MIPS_INS_TEQI,
	MIPS_INS_TGE,
	MIPS_INS_TGEI,
	MIPS_INS_TGEIU,
	MIPS_INS_TGEU,
	MIPS_INS_TLBP,
	MIPS_INS_TLBR,
	MIPS_INS_TLBWI,
	MIPS_INS_TLBWR,
	MIPS_INS_TLT,
	MIPS_INS_TLTI,
	MIPS_INS_TLTIU,
	MIPS_INS_TLTU,
	MIPS_INS_TNE,
	MIPS_INS_TNEI,
	MIPS_INS_TRUNC,
	MIPS_INS_V3MULU,
	MIPS_INS_VMM0,
	MIPS_INS_VMULU,
	MIPS_INS_VSHF,
	MIPS_INS_WAIT,
	MIPS_INS_WRDSP,
	MIPS_INS_WSBH,
	MIPS_INS_XOR,
	MIPS_INS_XOR16,
	MIPS_INS_XORI,

	//> some alias instructions
	MIPS_INS_NOP,
	MIPS_INS_NEGU,

	//> special instructions
	MIPS_INS_JALR_HB,	// jump and link with Hazard Barrier
	MIPS_INS_JR_HB,		// jump register with Hazard Barrier

	MIPS_INS_ENDING,
} mips_insn;

/// Group of MIPS instructions
typedef enum mips_insn_group {
	MIPS_GRP_INVALID = 0, ///< = CS_GRP_INVALID

	// Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	MIPS_GRP_JUMP,	///< = CS_GRP_JUMP
	// all call instructions
	MIPS_GRP_CALL,	///< = CS_GRP_CALL
	// all return instructions
	MIPS_GRP_RET,	///< = CS_GRP_RET
	// all interrupt instructions (int+syscall)
	MIPS_GRP_INT,	///< = CS_GRP_INT
	// all interrupt return instructions
	MIPS_GRP_IRET,	///< = CS_GRP_IRET
	// all privileged instructions
	MIPS_GRP_PRIVILEGE,	///< = CS_GRP_PRIVILEGE
	// all relative branching instructions
	MIPS_GRP_BRANCH_RELATIVE, ///< = CS_GRP_BRANCH_RELATIVE

	// Architecture-specific groups
	MIPS_GRP_BITCOUNT = 128,
	MIPS_GRP_DSP,
	MIPS_GRP_DSPR2,
	MIPS_GRP_FPIDX,
	MIPS_GRP_MSA,
	MIPS_GRP_MIPS32R2,
	MIPS_GRP_MIPS64,
	MIPS_GRP_MIPS64R2,
	MIPS_GRP_SEINREG,
	MIPS_GRP_STDENC,
	MIPS_GRP_SWAP,
	MIPS_GRP_MICROMIPS,
	MIPS_GRP_MIPS16MODE,
	MIPS_GRP_FP64BIT,
	MIPS_GRP_NONANSFPMATH,
	MIPS_GRP_NOTFP64BIT,
	MIPS_GRP_NOTINMICROMIPS,
	MIPS_GRP_NOTNACL,
	MIPS_GRP_NOTMIPS32R6,
	MIPS_GRP_NOTMIPS64R6,
	MIPS_GRP_CNMIPS,
	MIPS_GRP_MIPS32,
	MIPS_GRP_MIPS32R6,
	MIPS_GRP_MIPS64R6,
	MIPS_GRP_MIPS2,
	MIPS_GRP_MIPS3,
	MIPS_GRP_MIPS3_32,
	MIPS_GRP_MIPS3_32R2,
	MIPS_GRP_MIPS4_32,
	MIPS_GRP_MIPS4_32R2,
	MIPS_GRP_MIPS5_32R2,
	MIPS_GRP_GP32BIT,
	MIPS_GRP_GP64BIT,

	MIPS_GRP_ENDING,
} mips_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`capstone/include/capstone/mos65xx.h`:

```h
#ifndef CAPSTONE_MOS65XX_H
#define CAPSTONE_MOS65XX_H

/* Capstone Disassembly Engine */
/* By Sebastian Macke <sebastian@macke.de, 2018 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

/// MOS65XX registers and special registers
typedef enum mos65xx_reg {
	MOS65XX_REG_INVALID = 0,
	MOS65XX_REG_ACC, ///< accumulator
	MOS65XX_REG_X, ///< X index register
	MOS65XX_REG_Y, ///< Y index register
	MOS65XX_REG_P, ///< status register
	MOS65XX_REG_SP, ///< stack pointer register
	MOS65XX_REG_ENDING,   // <-- mark the end of the list of registers
} mos65xx_reg;

/// MOS65XX Addressing Modes
typedef enum mos65xx_address_mode {
	MOS65XX_AM_NONE = 0, ///< No address mode.
	MOS65XX_AM_IMP, ///< implied addressing (no addressing mode)
	MOS65XX_AM_ACC, ///< accumulator addressing
	MOS65XX_AM_ABS, ///< absolute addressing
	MOS65XX_AM_ZP,  ///< zeropage addressing
	MOS65XX_AM_IMM, ///< 8 Bit immediate value
	MOS65XX_AM_ABSX, ///< indexed absolute addressing by the X index register
	MOS65XX_AM_ABSY, ///< indexed absolute addressing by the Y index register
	MOS65XX_AM_INDX, ///< indexed indirect addressing by the X index register
	MOS65XX_AM_INDY, ///< indirect indexed addressing by the Y index register
	MOS65XX_AM_ZPX, ///< indexed zeropage addressing by the X index register
	MOS65XX_AM_ZPY, ///< indexed zeropage addressing by the Y index register
	MOS65XX_AM_REL, ///< relative addressing used by branches
	MOS65XX_AM_IND, ///< absolute indirect addressing
} mos65xx_address_mode;

/// MOS65XX instruction
typedef enum mos65xx_insn {
	MOS65XX_INS_INVALID = 0,
	MOS65XX_INS_ADC,
	MOS65XX_INS_AND,
	MOS65XX_INS_ASL,
	MOS65XX_INS_BCC,
	MOS65XX_INS_BCS,
	MOS65XX_INS_BEQ,
	MOS65XX_INS_BIT,
	MOS65XX_INS_BMI,
	MOS65XX_INS_BNE,
	MOS65XX_INS_BPL,
	MOS65XX_INS_BRK,
	MOS65XX_INS_BVC,
	MOS65XX_INS_BVS,
	MOS65XX_INS_CLC,
	MOS65XX_INS_CLD,
	MOS65XX_INS_CLI,
	MOS65XX_INS_CLV,
	MOS65XX_INS_CMP,
	MOS65XX_INS_CPX,
	MOS65XX_INS_CPY,
	MOS65XX_INS_DEC,
	MOS65XX_INS_DEX,
	MOS65XX_INS_DEY,
	MOS65XX_INS_EOR,
	MOS65XX_INS_INC,
	MOS65XX_INS_INX,
	MOS65XX_INS_INY,
	MOS65XX_INS_JMP,
	MOS65XX_INS_JSR,
	MOS65XX_INS_LDA,
	MOS65XX_INS_LDX,
	MOS65XX_INS_LDY,
	MOS65XX_INS_LSR,
	MOS65XX_INS_NOP,
	MOS65XX_INS_ORA,
	MOS65XX_INS_PHA,
	MOS65XX_INS_PLA,
	MOS65XX_INS_PHP,
	MOS65XX_INS_PLP,
	MOS65XX_INS_ROL,
	MOS65XX_INS_ROR,
	MOS65XX_INS_RTI,
	MOS65XX_INS_RTS,
	MOS65XX_INS_SBC,
	MOS65XX_INS_SEC,
	MOS65XX_INS_SED,
	MOS65XX_INS_SEI,
	MOS65XX_INS_STA,
	MOS65XX_INS_STX,
	MOS65XX_INS_STY,
	MOS65XX_INS_TAX,
	MOS65XX_INS_TAY,
	MOS65XX_INS_TSX,
	MOS65XX_INS_TXA,
	MOS65XX_INS_TXS,
	MOS65XX_INS_TYA,
	MOS65XX_INS_ENDING,   // <-- mark the end of the list of instructions
} mos65xx_insn;

/// Group of MOS65XX instructions
typedef enum mos65xx_group_type {
	MOS65XX_GRP_INVALID = 0,  ///< CS_GRP_INVALID
	MOS65XX_GRP_JUMP,		 ///< = CS_GRP_JUMP
	MOS65XX_GRP_CALL,		 ///< = CS_GRP_RET
	MOS65XX_GRP_RET,		  ///< = CS_GRP_RET
	MOS65XX_GRP_IRET = 5,	 ///< = CS_GRP_IRET
	MOS65XX_GRP_BRANCH_RELATIVE = 6, ///< = CS_GRP_BRANCH_RELATIVE
	MOS65XX_GRP_ENDING,// <-- mark the end of the list of groups
} mos65xx_group_type;

/// Operand type for instruction's operands
typedef enum mos65xx_op_type {
	MOS65XX_OP_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	MOS65XX_OP_REG, ///< = CS_OP_REG (Register operand).
	MOS65XX_OP_IMM, ///< = CS_OP_IMM (Immediate operand).
	MOS65XX_OP_MEM, ///< = CS_OP_MEM (Memory operand).
} mos65xx_op_type;

/// Instruction operand
typedef struct cs_mos65xx_op {
	mos65xx_op_type type;	///< operand type
	union {
		mos65xx_reg reg;	///< register value for REG operand
		uint8_t imm;		///< immediate value for IMM operand
		uint16_t mem;		///< base/index/scale/disp value for MEM operand
	};
} cs_mos65xx_op;

/// The MOS65XX address mode and it's operands
typedef struct cs_mos65xx {
	mos65xx_address_mode am;
	bool modifies_flags;

	/// Number of operands of this instruction,
	/// or 0 when instruction has no operand.
	uint8_t op_count;
	cs_mos65xx_op operands[3]; ///< operands for this instruction.
} cs_mos65xx;

#ifdef __cplusplus
}
#endif

#endif //CAPSTONE_MOS65XX_H

```

`capstone/include/capstone/platform.h`:

```h
/* Capstone Disassembly Engine */
/* By Axel Souchet & Nguyen Anh Quynh, 2014 */

#ifndef CAPSTONE_PLATFORM_H
#define CAPSTONE_PLATFORM_H


// handle C99 issue (for pre-2013 VisualStudio)
#if !defined(__CYGWIN__) && !defined(__MINGW32__) && !defined(__MINGW64__) && (defined (WIN32) || defined (WIN64) || defined (_WIN32) || defined (_WIN64))
// MSVC

// stdbool.h
#if (_MSC_VER < 1800) || defined(_KERNEL_MODE)
// this system does not have stdbool.h
#ifndef __cplusplus
typedef unsigned char bool;
#define false 0
#define true 1
#endif  // __cplusplus

#else
// VisualStudio 2013+ -> C99 is supported
#include <stdbool.h>
#endif  // (_MSC_VER < 1800) || defined(_KERNEL_MODE)

#else
// not MSVC -> C99 is supported
#include <stdbool.h>
#endif  // !defined(__CYGWIN__) && !defined(__MINGW32__) && !defined(__MINGW64__) && (defined (WIN32) || defined (WIN64) || defined (_WIN32) || defined (_WIN64))


// handle inttypes.h / stdint.h compatibility
#if defined(_WIN32_WCE) && (_WIN32_WCE < 0x800)
#include "windowsce/stdint.h"
#endif  // defined(_WIN32_WCE) && (_WIN32_WCE < 0x800)

#if defined(CAPSTONE_HAS_OSXKERNEL) || (defined(_MSC_VER) && (_MSC_VER <= 1700 || defined(_KERNEL_MODE)))
// this system does not have inttypes.h

#if defined(_MSC_VER) && (_MSC_VER <= 1600 || defined(_KERNEL_MODE))
// this system does not have stdint.h
typedef signed char  int8_t;
typedef signed short int16_t;
typedef signed int   int32_t;
typedef unsigned char  uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int   uint32_t;
typedef signed long long   int64_t;
typedef unsigned long long uint64_t;
#endif  // defined(_MSC_VER) && (_MSC_VER <= 1600 || defined(_KERNEL_MODE))

#if defined(_MSC_VER) && (_MSC_VER < 1600 || defined(_KERNEL_MODE))
#define INT8_MIN         (-127i8 - 1)
#define INT16_MIN        (-32767i16 - 1)
#define INT32_MIN        (-2147483647i32 - 1)
#define INT64_MIN        (-9223372036854775807i64 - 1)
#define INT8_MAX         127i8
#define INT16_MAX        32767i16
#define INT32_MAX        2147483647i32
#define INT64_MAX        9223372036854775807i64
#define UINT8_MAX        0xffui8
#define UINT16_MAX       0xffffui16
#define UINT32_MAX       0xffffffffui32
#define UINT64_MAX       0xffffffffffffffffui64
#endif  // defined(_MSC_VER) && (_MSC_VER < 1600 || defined(_KERNEL_MODE))

#ifdef CAPSTONE_HAS_OSXKERNEL
// this system has stdint.h
#include <stdint.h>
#endif

#define __PRI_8_LENGTH_MODIFIER__ "hh"
#define __PRI_64_LENGTH_MODIFIER__ "ll"

#define PRId8         __PRI_8_LENGTH_MODIFIER__ "d"
#define PRIi8         __PRI_8_LENGTH_MODIFIER__ "i"
#define PRIo8         __PRI_8_LENGTH_MODIFIER__ "o"
#define PRIu8         __PRI_8_LENGTH_MODIFIER__ "u"
#define PRIx8         __PRI_8_LENGTH_MODIFIER__ "x"
#define PRIX8         __PRI_8_LENGTH_MODIFIER__ "X"

#define PRId16        "hd"
#define PRIi16        "hi"
#define PRIo16        "ho"
#define PRIu16        "hu"
#define PRIx16        "hx"
#define PRIX16        "hX"

#if defined(_MSC_VER) && _MSC_VER <= 1700
#define PRId32        "ld"
#define PRIi32        "li"
#define PRIo32        "lo"
#define PRIu32        "lu"
#define PRIx32        "lx"
#define PRIX32        "lX"
#else	// OSX
#define PRId32        "d"
#define PRIi32        "i"
#define PRIo32        "o"
#define PRIu32        "u"
#define PRIx32        "x"
#define PRIX32        "X"
#endif  // defined(_MSC_VER) && _MSC_VER <= 1700

#if defined(_MSC_VER) && _MSC_VER <= 1700
// redefine functions from inttypes.h used in cstool
#define strtoull _strtoui64
#endif

#define PRId64        __PRI_64_LENGTH_MODIFIER__ "d"
#define PRIi64        __PRI_64_LENGTH_MODIFIER__ "i"
#define PRIo64        __PRI_64_LENGTH_MODIFIER__ "o"
#define PRIu64        __PRI_64_LENGTH_MODIFIER__ "u"
#define PRIx64        __PRI_64_LENGTH_MODIFIER__ "x"
#define PRIX64        __PRI_64_LENGTH_MODIFIER__ "X"

#else
// this system has inttypes.h by default
#include <inttypes.h>
#endif  // defined(CAPSTONE_HAS_OSXKERNEL) || (defined(_MSC_VER) && (_MSC_VER <= 1700 || defined(_KERNEL_MODE)))

#endif

```

`capstone/include/capstone/ppc.h`:

```h
#ifndef CAPSTONE_PPC_H
#define CAPSTONE_PPC_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

/// PPC branch codes for some branch instructions
typedef enum ppc_bc {
	PPC_BC_INVALID  = 0,
	PPC_BC_LT       = (0 << 5) | 12,
	PPC_BC_LE       = (1 << 5) |  4,
	PPC_BC_EQ       = (2 << 5) | 12,
	PPC_BC_GE       = (0 << 5) |  4,
	PPC_BC_GT       = (1 << 5) | 12,
	PPC_BC_NE       = (2 << 5) |  4,
	PPC_BC_UN       = (3 << 5) | 12,
	PPC_BC_NU       = (3 << 5) |  4,

	// extra conditions
	PPC_BC_SO = (4 << 5) | 12,	///< summary overflow
	PPC_BC_NS = (4 << 5) | 4,	///< not summary overflow
} ppc_bc;

/// PPC branch hint for some branch instructions
typedef enum ppc_bh {
	PPC_BH_INVALID = 0,	///< no hint
	PPC_BH_PLUS,	///< PLUS hint
	PPC_BH_MINUS,	///< MINUS hint
} ppc_bh;

/// Operand type for instruction's operands
typedef enum ppc_op_type {
	PPC_OP_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	PPC_OP_REG, ///< = CS_OP_REG (Register operand).
	PPC_OP_IMM, ///< = CS_OP_IMM (Immediate operand).
	PPC_OP_MEM, ///< = CS_OP_MEM (Memory operand).
	PPC_OP_CRX = 64,	///< Condition Register field
} ppc_op_type;

/// PPC registers
typedef enum ppc_reg {
	PPC_REG_INVALID = 0,

	PPC_REG_CARRY,
	PPC_REG_CR0,
	PPC_REG_CR1,
	PPC_REG_CR2,
	PPC_REG_CR3,
	PPC_REG_CR4,
	PPC_REG_CR5,
	PPC_REG_CR6,
	PPC_REG_CR7,
	PPC_REG_CTR,
	PPC_REG_F0,
	PPC_REG_F1,
	PPC_REG_F2,
	PPC_REG_F3,
	PPC_REG_F4,
	PPC_REG_F5,
	PPC_REG_F6,
	PPC_REG_F7,
	PPC_REG_F8,
	PPC_REG_F9,
	PPC_REG_F10,
	PPC_REG_F11,
	PPC_REG_F12,
	PPC_REG_F13,
	PPC_REG_F14,
	PPC_REG_F15,
	PPC_REG_F16,
	PPC_REG_F17,
	PPC_REG_F18,
	PPC_REG_F19,
	PPC_REG_F20,
	PPC_REG_F21,
	PPC_REG_F22,
	PPC_REG_F23,
	PPC_REG_F24,
	PPC_REG_F25,
	PPC_REG_F26,
	PPC_REG_F27,
	PPC_REG_F28,
	PPC_REG_F29,
	PPC_REG_F30,
	PPC_REG_F31,
	PPC_REG_LR,
	PPC_REG_R0,
	PPC_REG_R1,
	PPC_REG_R2,
	PPC_REG_R3,
	PPC_REG_R4,
	PPC_REG_R5,
	PPC_REG_R6,
	PPC_REG_R7,
	PPC_REG_R8,
	PPC_REG_R9,
	PPC_REG_R10,
	PPC_REG_R11,
	PPC_REG_R12,
	PPC_REG_R13,
	PPC_REG_R14,
	PPC_REG_R15,
	PPC_REG_R16,
	PPC_REG_R17,
	PPC_REG_R18,
	PPC_REG_R19,
	PPC_REG_R20,
	PPC_REG_R21,
	PPC_REG_R22,
	PPC_REG_R23,
	PPC_REG_R24,
	PPC_REG_R25,
	PPC_REG_R26,
	PPC_REG_R27,
	PPC_REG_R28,
	PPC_REG_R29,
	PPC_REG_R30,
	PPC_REG_R31,
	PPC_REG_V0,
	PPC_REG_V1,
	PPC_REG_V2,
	PPC_REG_V3,
	PPC_REG_V4,
	PPC_REG_V5,
	PPC_REG_V6,
	PPC_REG_V7,
	PPC_REG_V8,
	PPC_REG_V9,
	PPC_REG_V10,
	PPC_REG_V11,
	PPC_REG_V12,
	PPC_REG_V13,
	PPC_REG_V14,
	PPC_REG_V15,
	PPC_REG_V16,
	PPC_REG_V17,
	PPC_REG_V18,
	PPC_REG_V19,
	PPC_REG_V20,
	PPC_REG_V21,
	PPC_REG_V22,
	PPC_REG_V23,
	PPC_REG_V24,
	PPC_REG_V25,
	PPC_REG_V26,
	PPC_REG_V27,
	PPC_REG_V28,
	PPC_REG_V29,
	PPC_REG_V30,
	PPC_REG_V31,
	PPC_REG_VRSAVE,
	PPC_REG_VS0,
	PPC_REG_VS1,
	PPC_REG_VS2,
	PPC_REG_VS3,
	PPC_REG_VS4,
	PPC_REG_VS5,
	PPC_REG_VS6,
	PPC_REG_VS7,
	PPC_REG_VS8,
	PPC_REG_VS9,
	PPC_REG_VS10,
	PPC_REG_VS11,
	PPC_REG_VS12,
	PPC_REG_VS13,
	PPC_REG_VS14,
	PPC_REG_VS15,
	PPC_REG_VS16,
	PPC_REG_VS17,
	PPC_REG_VS18,
	PPC_REG_VS19,
	PPC_REG_VS20,
	PPC_REG_VS21,
	PPC_REG_VS22,
	PPC_REG_VS23,
	PPC_REG_VS24,
	PPC_REG_VS25,
	PPC_REG_VS26,
	PPC_REG_VS27,
	PPC_REG_VS28,
	PPC_REG_VS29,
	PPC_REG_VS30,
	PPC_REG_VS31,
	PPC_REG_VS32,
	PPC_REG_VS33,
	PPC_REG_VS34,
	PPC_REG_VS35,
	PPC_REG_VS36,
	PPC_REG_VS37,
	PPC_REG_VS38,
	PPC_REG_VS39,
	PPC_REG_VS40,
	PPC_REG_VS41,
	PPC_REG_VS42,
	PPC_REG_VS43,
	PPC_REG_VS44,
	PPC_REG_VS45,
	PPC_REG_VS46,
	PPC_REG_VS47,
	PPC_REG_VS48,
	PPC_REG_VS49,
	PPC_REG_VS50,
	PPC_REG_VS51,
	PPC_REG_VS52,
	PPC_REG_VS53,
	PPC_REG_VS54,
	PPC_REG_VS55,
	PPC_REG_VS56,
	PPC_REG_VS57,
	PPC_REG_VS58,
	PPC_REG_VS59,
	PPC_REG_VS60,
	PPC_REG_VS61,
	PPC_REG_VS62,
	PPC_REG_VS63,
	PPC_REG_Q0,
	PPC_REG_Q1,
	PPC_REG_Q2,
	PPC_REG_Q3,
	PPC_REG_Q4,
	PPC_REG_Q5,
	PPC_REG_Q6,
	PPC_REG_Q7,
	PPC_REG_Q8,
	PPC_REG_Q9,
	PPC_REG_Q10,
	PPC_REG_Q11,
	PPC_REG_Q12,
	PPC_REG_Q13,
	PPC_REG_Q14,
	PPC_REG_Q15,
	PPC_REG_Q16,
	PPC_REG_Q17,
	PPC_REG_Q18,
	PPC_REG_Q19,
	PPC_REG_Q20,
	PPC_REG_Q21,
	PPC_REG_Q22,
	PPC_REG_Q23,
	PPC_REG_Q24,
	PPC_REG_Q25,
	PPC_REG_Q26,
	PPC_REG_Q27,
	PPC_REG_Q28,
	PPC_REG_Q29,
	PPC_REG_Q30,
	PPC_REG_Q31,

	// extra registers for PPCMapping.c
	PPC_REG_RM,
	PPC_REG_CTR8,
	PPC_REG_LR8,
	PPC_REG_CR1EQ,
	PPC_REG_X2,

	PPC_REG_ENDING,   // <-- mark the end of the list of registers
} ppc_reg;

/// Instruction's operand referring to memory
/// This is associated with PPC_OP_MEM operand type above
typedef struct ppc_op_mem {
	ppc_reg base;	///< base register
	int32_t disp;	///< displacement/offset value
} ppc_op_mem;

typedef struct ppc_op_crx {
	unsigned int scale;
	ppc_reg reg;
	ppc_bc cond;
} ppc_op_crx;

/// Instruction operand
typedef struct cs_ppc_op {
	ppc_op_type type;	///< operand type
	union {
		ppc_reg reg;	///< register value for REG operand
		int64_t imm;		///< immediate value for IMM operand
		ppc_op_mem mem;		///< base/disp value for MEM operand
		ppc_op_crx crx;		///< operand with condition register
	};
} cs_ppc_op;

/// Instruction structure
typedef struct cs_ppc {
	/// branch code for branch instructions
	ppc_bc bc;

	/// branch hint for branch instructions
	ppc_bh bh;

	/// if update_cr0 = True, then this 'dot' insn updates CR0
	bool update_cr0;

	/// Number of operands of this instruction,
	/// or 0 when instruction has no operand.
	uint8_t op_count;
	cs_ppc_op operands[8]; ///< operands for this instruction.
} cs_ppc;

/// PPC instruction
typedef enum ppc_insn {
	PPC_INS_INVALID = 0,

	PPC_INS_ADD,
	PPC_INS_ADDC,
	PPC_INS_ADDE,
	PPC_INS_ADDI,
	PPC_INS_ADDIC,
	PPC_INS_ADDIS,
	PPC_INS_ADDME,
	PPC_INS_ADDZE,
	PPC_INS_AND,
	PPC_INS_ANDC,
	PPC_INS_ANDIS,
	PPC_INS_ANDI,
	PPC_INS_ATTN,
	PPC_INS_B,
	PPC_INS_BA,
	PPC_INS_BC,
	PPC_INS_BCCTR,
	PPC_INS_BCCTRL,
	PPC_INS_BCL,
	PPC_INS_BCLR,
	PPC_INS_BCLRL,
	PPC_INS_BCTR,
	PPC_INS_BCTRL,
	PPC_INS_BCT,
	PPC_INS_BDNZ,
	PPC_INS_BDNZA,
	PPC_INS_BDNZL,
	PPC_INS_BDNZLA,
	PPC_INS_BDNZLR,
	PPC_INS_BDNZLRL,
	PPC_INS_BDZ,
	PPC_INS_BDZA,
	PPC_INS_BDZL,
	PPC_INS_BDZLA,
	PPC_INS_BDZLR,
	PPC_INS_BDZLRL,
	PPC_INS_BL,
	PPC_INS_BLA,
	PPC_INS_BLR,
	PPC_INS_BLRL,
	PPC_INS_BRINC,
	PPC_INS_CMPB,
	PPC_INS_CMPD,
	PPC_INS_CMPDI,
	PPC_INS_CMPLD,
	PPC_INS_CMPLDI,
	PPC_INS_CMPLW,
	PPC_INS_CMPLWI,
	PPC_INS_CMPW,
	PPC_INS_CMPWI,
	PPC_INS_CNTLZD,
	PPC_INS_CNTLZW,
	PPC_INS_CREQV,
	PPC_INS_CRXOR,
	PPC_INS_CRAND,
	PPC_INS_CRANDC,
	PPC_INS_CRNAND,
	PPC_INS_CRNOR,
	PPC_INS_CROR,
	PPC_INS_CRORC,
	PPC_INS_DCBA,
	PPC_INS_DCBF,
	PPC_INS_DCBI,
	PPC_INS_DCBST,
	PPC_INS_DCBT,
	PPC_INS_DCBTST,
	PPC_INS_DCBZ,
	PPC_INS_DCBZL,
	PPC_INS_DCCCI,
	PPC_INS_DIVD,
	PPC_INS_DIVDU,
	PPC_INS_DIVW,
	PPC_INS_DIVWU,
	PPC_INS_DSS,
	PPC_INS_DSSALL,
	PPC_INS_DST,
	PPC_INS_DSTST,
	PPC_INS_DSTSTT,
	PPC_INS_DSTT,
	PPC_INS_EQV,
	PPC_INS_EVABS,
	PPC_INS_EVADDIW,
	PPC_INS_EVADDSMIAAW,
	PPC_INS_EVADDSSIAAW,
	PPC_INS_EVADDUMIAAW,
	PPC_INS_EVADDUSIAAW,
	PPC_INS_EVADDW,
	PPC_INS_EVAND,
	PPC_INS_EVANDC,
	PPC_INS_EVCMPEQ,
	PPC_INS_EVCMPGTS,
	PPC_INS_EVCMPGTU,
	PPC_INS_EVCMPLTS,
	PPC_INS_EVCMPLTU,
	PPC_INS_EVCNTLSW,
	PPC_INS_EVCNTLZW,
	PPC_INS_EVDIVWS,
	PPC_INS_EVDIVWU,
	PPC_INS_EVEQV,
	PPC_INS_EVEXTSB,
	PPC_INS_EVEXTSH,
	PPC_INS_EVLDD,
	PPC_INS_EVLDDX,
	PPC_INS_EVLDH,
	PPC_INS_EVLDHX,
	PPC_INS_EVLDW,
	PPC_INS_EVLDWX,
	PPC_INS_EVLHHESPLAT,
	PPC_INS_EVLHHESPLATX,
	PPC_INS_EVLHHOSSPLAT,
	PPC_INS_EVLHHOSSPLATX,
	PPC_INS_EVLHHOUSPLAT,
	PPC_INS_EVLHHOUSPLATX,
	PPC_INS_EVLWHE,
	PPC_INS_EVLWHEX,
	PPC_INS_EVLWHOS,
	PPC_INS_EVLWHOSX,
	PPC_INS_EVLWHOU,
	PPC_INS_EVLWHOUX,
	PPC_INS_EVLWHSPLAT,
	PPC_INS_EVLWHSPLATX,
	PPC_INS_EVLWWSPLAT,
	PPC_INS_EVLWWSPLATX,
	PPC_INS_EVMERGEHI,
	PPC_INS_EVMERGEHILO,
	PPC_INS_EVMERGELO,
	PPC_INS_EVMERGELOHI,
	PPC_INS_EVMHEGSMFAA,
	PPC_INS_EVMHEGSMFAN,
	PPC_INS_EVMHEGSMIAA,
	PPC_INS_EVMHEGSMIAN,
	PPC_INS_EVMHEGUMIAA,
	PPC_INS_EVMHEGUMIAN,
	PPC_INS_EVMHESMF,
	PPC_INS_EVMHESMFA,
	PPC_INS_EVMHESMFAAW,
	PPC_INS_EVMHESMFANW,
	PPC_INS_EVMHESMI,
	PPC_INS_EVMHESMIA,
	PPC_INS_EVMHESMIAAW,
	PPC_INS_EVMHESMIANW,
	PPC_INS_EVMHESSF,
	PPC_INS_EVMHESSFA,
	PPC_INS_EVMHESSFAAW,
	PPC_INS_EVMHESSFANW,
	PPC_INS_EVMHESSIAAW,
	PPC_INS_EVMHESSIANW,
	PPC_INS_EVMHEUMI,
	PPC_INS_EVMHEUMIA,
	PPC_INS_EVMHEUMIAAW,
	PPC_INS_EVMHEUMIANW,
	PPC_INS_EVMHEUSIAAW,
	PPC_INS_EVMHEUSIANW,
	PPC_INS_EVMHOGSMFAA,
	PPC_INS_EVMHOGSMFAN,
	PPC_INS_EVMHOGSMIAA,
	PPC_INS_EVMHOGSMIAN,
	PPC_INS_EVMHOGUMIAA,
	PPC_INS_EVMHOGUMIAN,
	PPC_INS_EVMHOSMF,
	PPC_INS_EVMHOSMFA,
	PPC_INS_EVMHOSMFAAW,
	PPC_INS_EVMHOSMFANW,
	PPC_INS_EVMHOSMI,
	PPC_INS_EVMHOSMIA,
	PPC_INS_EVMHOSMIAAW,
	PPC_INS_EVMHOSMIANW,
	PPC_INS_EVMHOSSF,
	PPC_INS_EVMHOSSFA,
	PPC_INS_EVMHOSSFAAW,
	PPC_INS_EVMHOSSFANW,
	PPC_INS_EVMHOSSIAAW,
	PPC_INS_EVMHOSSIANW,
	PPC_INS_EVMHOUMI,
	PPC_INS_EVMHOUMIA,
	PPC_INS_EVMHOUMIAAW,
	PPC_INS_EVMHOUMIANW,
	PPC_INS_EVMHOUSIAAW,
	PPC_INS_EVMHOUSIANW,
	PPC_INS_EVMRA,
	PPC_INS_EVMWHSMF,
	PPC_INS_EVMWHSMFA,
	PPC_INS_EVMWHSMI,
	PPC_INS_EVMWHSMIA,
	PPC_INS_EVMWHSSF,
	PPC_INS_EVMWHSSFA,
	PPC_INS_EVMWHUMI,
	PPC_INS_EVMWHUMIA,
	PPC_INS_EVMWLSMIAAW,
	PPC_INS_EVMWLSMIANW,
	PPC_INS_EVMWLSSIAAW,
	PPC_INS_EVMWLSSIANW,
	PPC_INS_EVMWLUMI,
	PPC_INS_EVMWLUMIA,
	PPC_INS_EVMWLUMIAAW,
	PPC_INS_EVMWLUMIANW,
	PPC_INS_EVMWLUSIAAW,
	PPC_INS_EVMWLUSIANW,
	PPC_INS_EVMWSMF,
	PPC_INS_EVMWSMFA,
	PPC_INS_EVMWSMFAA,
	PPC_INS_EVMWSMFAN,
	PPC_INS_EVMWSMI,
	PPC_INS_EVMWSMIA,
	PPC_INS_EVMWSMIAA,
	PPC_INS_EVMWSMIAN,
	PPC_INS_EVMWSSF,
	PPC_INS_EVMWSSFA,
	PPC_INS_EVMWSSFAA,
	PPC_INS_EVMWSSFAN,
	PPC_INS_EVMWUMI,
	PPC_INS_EVMWUMIA,
	PPC_INS_EVMWUMIAA,
	PPC_INS_EVMWUMIAN,
	PPC_INS_EVNAND,
	PPC_INS_EVNEG,
	PPC_INS_EVNOR,
	PPC_INS_EVOR,
	PPC_INS_EVORC,
	PPC_INS_EVRLW,
	PPC_INS_EVRLWI,
	PPC_INS_EVRNDW,
	PPC_INS_EVSLW,
	PPC_INS_EVSLWI,
	PPC_INS_EVSPLATFI,
	PPC_INS_EVSPLATI,
	PPC_INS_EVSRWIS,
	PPC_INS_EVSRWIU,
	PPC_INS_EVSRWS,
	PPC_INS_EVSRWU,
	PPC_INS_EVSTDD,
	PPC_INS_EVSTDDX,
	PPC_INS_EVSTDH,
	PPC_INS_EVSTDHX,
	PPC_INS_EVSTDW,
	PPC_INS_EVSTDWX,
	PPC_INS_EVSTWHE,
	PPC_INS_EVSTWHEX,
	PPC_INS_EVSTWHO,
	PPC_INS_EVSTWHOX,
	PPC_INS_EVSTWWE,
	PPC_INS_EVSTWWEX,
	PPC_INS_EVSTWWO,
	PPC_INS_EVSTWWOX,
	PPC_INS_EVSUBFSMIAAW,
	PPC_INS_EVSUBFSSIAAW,
	PPC_INS_EVSUBFUMIAAW,
	PPC_INS_EVSUBFUSIAAW,
	PPC_INS_EVSUBFW,
	PPC_INS_EVSUBIFW,
	PPC_INS_EVXOR,
	PPC_INS_EXTSB,
	PPC_INS_EXTSH,
	PPC_INS_EXTSW,
	PPC_INS_EIEIO,
	PPC_INS_FABS,
	PPC_INS_FADD,
	PPC_INS_FADDS,
	PPC_INS_FCFID,
	PPC_INS_FCFIDS,
	PPC_INS_FCFIDU,
	PPC_INS_FCFIDUS,
	PPC_INS_FCMPU,
	PPC_INS_FCPSGN,
	PPC_INS_FCTID,
	PPC_INS_FCTIDUZ,
	PPC_INS_FCTIDZ,
	PPC_INS_FCTIW,
	PPC_INS_FCTIWUZ,
	PPC_INS_FCTIWZ,
	PPC_INS_FDIV,
	PPC_INS_FDIVS,
	PPC_INS_FMADD,
	PPC_INS_FMADDS,
	PPC_INS_FMR,
	PPC_INS_FMSUB,
	PPC_INS_FMSUBS,
	PPC_INS_FMUL,
	PPC_INS_FMULS,
	PPC_INS_FNABS,
	PPC_INS_FNEG,
	PPC_INS_FNMADD,
	PPC_INS_FNMADDS,
	PPC_INS_FNMSUB,
	PPC_INS_FNMSUBS,
	PPC_INS_FRE,
	PPC_INS_FRES,
	PPC_INS_FRIM,
	PPC_INS_FRIN,
	PPC_INS_FRIP,
	PPC_INS_FRIZ,
	PPC_INS_FRSP,
	PPC_INS_FRSQRTE,
	PPC_INS_FRSQRTES,
	PPC_INS_FSEL,
	PPC_INS_FSQRT,
	PPC_INS_FSQRTS,
	PPC_INS_FSUB,
	PPC_INS_FSUBS,
	PPC_INS_ICBI,
	PPC_INS_ICBT,
	PPC_INS_ICCCI,
	PPC_INS_ISEL,
	PPC_INS_ISYNC,
	PPC_INS_LA,
	PPC_INS_LBZ,
	PPC_INS_LBZCIX,
	PPC_INS_LBZU,
	PPC_INS_LBZUX,
	PPC_INS_LBZX,
	PPC_INS_LD,
	PPC_INS_LDARX,
	PPC_INS_LDBRX,
	PPC_INS_LDCIX,
	PPC_INS_LDU,
	PPC_INS_LDUX,
	PPC_INS_LDX,
	PPC_INS_LFD,
	PPC_INS_LFDU,
	PPC_INS_LFDUX,
	PPC_INS_LFDX,
	PPC_INS_LFIWAX,
	PPC_INS_LFIWZX,
	PPC_INS_LFS,
	PPC_INS_LFSU,
	PPC_INS_LFSUX,
	PPC_INS_LFSX,
	PPC_INS_LHA,
	PPC_INS_LHAU,
	PPC_INS_LHAUX,
	PPC_INS_LHAX,
	PPC_INS_LHBRX,
	PPC_INS_LHZ,
	PPC_INS_LHZCIX,
	PPC_INS_LHZU,
	PPC_INS_LHZUX,
	PPC_INS_LHZX,
	PPC_INS_LI,
	PPC_INS_LIS,
	PPC_INS_LMW,
	PPC_INS_LSWI,
	PPC_INS_LVEBX,
	PPC_INS_LVEHX,
	PPC_INS_LVEWX,
	PPC_INS_LVSL,
	PPC_INS_LVSR,
	PPC_INS_LVX,
	PPC_INS_LVXL,
	PPC_INS_LWA,
	PPC_INS_LWARX,
	PPC_INS_LWAUX,
	PPC_INS_LWAX,
	PPC_INS_LWBRX,
	PPC_INS_LWZ,
	PPC_INS_LWZCIX,
	PPC_INS_LWZU,
	PPC_INS_LWZUX,
	PPC_INS_LWZX,
	PPC_INS_LXSDX,
	PPC_INS_LXVD2X,
	PPC_INS_LXVDSX,
	PPC_INS_LXVW4X,
	PPC_INS_MBAR,
	PPC_INS_MCRF,
	PPC_INS_MCRFS,
	PPC_INS_MFCR,
	PPC_INS_MFCTR,
	PPC_INS_MFDCR,
	PPC_INS_MFFS,
	PPC_INS_MFLR,
	PPC_INS_MFMSR,
	PPC_INS_MFOCRF,
	PPC_INS_MFSPR,
	PPC_INS_MFSR,
	PPC_INS_MFSRIN,
	PPC_INS_MFTB,
	PPC_INS_MFVSCR,
	PPC_INS_MSYNC,
	PPC_INS_MTCRF,
	PPC_INS_MTCTR,
	PPC_INS_MTDCR,
	PPC_INS_MTFSB0,
	PPC_INS_MTFSB1,
	PPC_INS_MTFSF,
	PPC_INS_MTFSFI,
	PPC_INS_MTLR,
	PPC_INS_MTMSR,
	PPC_INS_MTMSRD,
	PPC_INS_MTOCRF,
	PPC_INS_MTSPR,
	PPC_INS_MTSR,
	PPC_INS_MTSRIN,
	PPC_INS_MTVSCR,
	PPC_INS_MULHD,
	PPC_INS_MULHDU,
	PPC_INS_MULHW,
	PPC_INS_MULHWU,
	PPC_INS_MULLD,
	PPC_INS_MULLI,
	PPC_INS_MULLW,
	PPC_INS_NAND,
	PPC_INS_NEG,
	PPC_INS_NOP,
	PPC_INS_ORI,
	PPC_INS_NOR,
	PPC_INS_OR,
	PPC_INS_ORC,
	PPC_INS_ORIS,
	PPC_INS_POPCNTD,
	PPC_INS_POPCNTW,
	PPC_INS_QVALIGNI,
	PPC_INS_QVESPLATI,
	PPC_INS_QVFABS,
	PPC_INS_QVFADD,
	PPC_INS_QVFADDS,
	PPC_INS_QVFCFID,
	PPC_INS_QVFCFIDS,
	PPC_INS_QVFCFIDU,
	PPC_INS_QVFCFIDUS,
	PPC_INS_QVFCMPEQ,
	PPC_INS_QVFCMPGT,
	PPC_INS_QVFCMPLT,
	PPC_INS_QVFCPSGN,
	PPC_INS_QVFCTID,
	PPC_INS_QVFCTIDU,
	PPC_INS_QVFCTIDUZ,
	PPC_INS_QVFCTIDZ,
	PPC_INS_QVFCTIW,
	PPC_INS_QVFCTIWU,
	PPC_INS_QVFCTIWUZ,
	PPC_INS_QVFCTIWZ,
	PPC_INS_QVFLOGICAL,
	PPC_INS_QVFMADD,
	PPC_INS_QVFMADDS,
	PPC_INS_QVFMR,
	PPC_INS_QVFMSUB,
	PPC_INS_QVFMSUBS,
	PPC_INS_QVFMUL,
	PPC_INS_QVFMULS,
	PPC_INS_QVFNABS,
	PPC_INS_QVFNEG,
	PPC_INS_QVFNMADD,
	PPC_INS_QVFNMADDS,
	PPC_INS_QVFNMSUB,
	PPC_INS_QVFNMSUBS,
	PPC_INS_QVFPERM,
	PPC_INS_QVFRE,
	PPC_INS_QVFRES,
	PPC_INS_QVFRIM,
	PPC_INS_QVFRIN,
	PPC_INS_QVFRIP,
	PPC_INS_QVFRIZ,
	PPC_INS_QVFRSP,
	PPC_INS_QVFRSQRTE,
	PPC_INS_QVFRSQRTES,
	PPC_INS_QVFSEL,
	PPC_INS_QVFSUB,
	PPC_INS_QVFSUBS,
	PPC_INS_QVFTSTNAN,
	PPC_INS_QVFXMADD,
	PPC_INS_QVFXMADDS,
	PPC_INS_QVFXMUL,
	PPC_INS_QVFXMULS,
	PPC_INS_QVFXXCPNMADD,
	PPC_INS_QVFXXCPNMADDS,
	PPC_INS_QVFXXMADD,
	PPC_INS_QVFXXMADDS,
	PPC_INS_QVFXXNPMADD,
	PPC_INS_QVFXXNPMADDS,
	PPC_INS_QVGPCI,
	PPC_INS_QVLFCDUX,
	PPC_INS_QVLFCDUXA,
	PPC_INS_QVLFCDX,
	PPC_INS_QVLFCDXA,
	PPC_INS_QVLFCSUX,
	PPC_INS_QVLFCSUXA,
	PPC_INS_QVLFCSX,
	PPC_INS_QVLFCSXA,
	PPC_INS_QVLFDUX,
	PPC_INS_QVLFDUXA,
	PPC_INS_QVLFDX,
	PPC_INS_QVLFDXA,
	PPC_INS_QVLFIWAX,
	PPC_INS_QVLFIWAXA,
	PPC_INS_QVLFIWZX,
	PPC_INS_QVLFIWZXA,
	PPC_INS_QVLFSUX,
	PPC_INS_QVLFSUXA,
	PPC_INS_QVLFSX,
	PPC_INS_QVLFSXA,
	PPC_INS_QVLPCLDX,
	PPC_INS_QVLPCLSX,
	PPC_INS_QVLPCRDX,
	PPC_INS_QVLPCRSX,
	PPC_INS_QVSTFCDUX,
	PPC_INS_QVSTFCDUXA,
	PPC_INS_QVSTFCDUXI,
	PPC_INS_QVSTFCDUXIA,
	PPC_INS_QVSTFCDX,
	PPC_INS_QVSTFCDXA,
	PPC_INS_QVSTFCDXI,
	PPC_INS_QVSTFCDXIA,
	PPC_INS_QVSTFCSUX,
	PPC_INS_QVSTFCSUXA,
	PPC_INS_QVSTFCSUXI,
	PPC_INS_QVSTFCSUXIA,
	PPC_INS_QVSTFCSX,
	PPC_INS_QVSTFCSXA,
	PPC_INS_QVSTFCSXI,
	PPC_INS_QVSTFCSXIA,
	PPC_INS_QVSTFDUX,
	PPC_INS_QVSTFDUXA,
	PPC_INS_QVSTFDUXI,
	PPC_INS_QVSTFDUXIA,
	PPC_INS_QVSTFDX,
	PPC_INS_QVSTFDXA,
	PPC_INS_QVSTFDXI,
	PPC_INS_QVSTFDXIA,
	PPC_INS_QVSTFIWX,
	PPC_INS_QVSTFIWXA,
	PPC_INS_QVSTFSUX,
	PPC_INS_QVSTFSUXA,
	PPC_INS_QVSTFSUXI,
	PPC_INS_QVSTFSUXIA,
	PPC_INS_QVSTFSX,
	PPC_INS_QVSTFSXA,
	PPC_INS_QVSTFSXI,
	PPC_INS_QVSTFSXIA,
	PPC_INS_RFCI,
	PPC_INS_RFDI,
	PPC_INS_RFI,
	PPC_INS_RFID,
	PPC_INS_RFMCI,
	PPC_INS_RLDCL,
	PPC_INS_RLDCR,
	PPC_INS_RLDIC,
	PPC_INS_RLDICL,
	PPC_INS_RLDICR,
	PPC_INS_RLDIMI,
	PPC_INS_RLWIMI,
	PPC_INS_RLWINM,
	PPC_INS_RLWNM,
	PPC_INS_SC,
	PPC_INS_SLBIA,
	PPC_INS_SLBIE,
	PPC_INS_SLBMFEE,
	PPC_INS_SLBMTE,
	PPC_INS_SLD,
	PPC_INS_SLW,
	PPC_INS_SRAD,
	PPC_INS_SRADI,
	PPC_INS_SRAW,
	PPC_INS_SRAWI,
	PPC_INS_SRD,
	PPC_INS_SRW,
	PPC_INS_STB,
	PPC_INS_STBCIX,
	PPC_INS_STBU,
	PPC_INS_STBUX,
	PPC_INS_STBX,
	PPC_INS_STD,
	PPC_INS_STDBRX,
	PPC_INS_STDCIX,
	PPC_INS_STDCX,
	PPC_INS_STDU,
	PPC_INS_STDUX,
	PPC_INS_STDX,
	PPC_INS_STFD,
	PPC_INS_STFDU,
	PPC_INS_STFDUX,
	PPC_INS_STFDX,
	PPC_INS_STFIWX,
	PPC_INS_STFS,
	PPC_INS_STFSU,
	PPC_INS_STFSUX,
	PPC_INS_STFSX,
	PPC_INS_STH,
	PPC_INS_STHBRX,
	PPC_INS_STHCIX,
	PPC_INS_STHU,
	PPC_INS_STHUX,
	PPC_INS_STHX,
	PPC_INS_STMW,
	PPC_INS_STSWI,
	PPC_INS_STVEBX,
	PPC_INS_STVEHX,
	PPC_INS_STVEWX,
	PPC_INS_STVX,
	PPC_INS_STVXL,
	PPC_INS_STW,
	PPC_INS_STWBRX,
	PPC_INS_STWCIX,
	PPC_INS_STWCX,
	PPC_INS_STWU,
	PPC_INS_STWUX,
	PPC_INS_STWX,
	PPC_INS_STXSDX,
	PPC_INS_STXVD2X,
	PPC_INS_STXVW4X,
	PPC_INS_SUBF,
	PPC_INS_SUBFC,
	PPC_INS_SUBFE,
	PPC_INS_SUBFIC,
	PPC_INS_SUBFME,
	PPC_INS_SUBFZE,
	PPC_INS_SYNC,
	PPC_INS_TD,
	PPC_INS_TDI,
	PPC_INS_TLBIA,
	PPC_INS_TLBIE,
	PPC_INS_TLBIEL,
	PPC_INS_TLBIVAX,
	PPC_INS_TLBLD,
	PPC_INS_TLBLI,
	PPC_INS_TLBRE,
	PPC_INS_TLBSX,
	PPC_INS_TLBSYNC,
	PPC_INS_TLBWE,
	PPC_INS_TRAP,
	PPC_INS_TW,
	PPC_INS_TWI,
	PPC_INS_VADDCUW,
	PPC_INS_VADDFP,
	PPC_INS_VADDSBS,
	PPC_INS_VADDSHS,
	PPC_INS_VADDSWS,
	PPC_INS_VADDUBM,
	PPC_INS_VADDUBS,
	PPC_INS_VADDUDM,
	PPC_INS_VADDUHM,
	PPC_INS_VADDUHS,
	PPC_INS_VADDUWM,
	PPC_INS_VADDUWS,
	PPC_INS_VAND,
	PPC_INS_VANDC,
	PPC_INS_VAVGSB,
	PPC_INS_VAVGSH,
	PPC_INS_VAVGSW,
	PPC_INS_VAVGUB,
	PPC_INS_VAVGUH,
	PPC_INS_VAVGUW,
	PPC_INS_VCFSX,
	PPC_INS_VCFUX,
	PPC_INS_VCLZB,
	PPC_INS_VCLZD,
	PPC_INS_VCLZH,
	PPC_INS_VCLZW,
	PPC_INS_VCMPBFP,
	PPC_INS_VCMPEQFP,
	PPC_INS_VCMPEQUB,
	PPC_INS_VCMPEQUD,
	PPC_INS_VCMPEQUH,
	PPC_INS_VCMPEQUW,
	PPC_INS_VCMPGEFP,
	PPC_INS_VCMPGTFP,
	PPC_INS_VCMPGTSB,
	PPC_INS_VCMPGTSD,
	PPC_INS_VCMPGTSH,
	PPC_INS_VCMPGTSW,
	PPC_INS_VCMPGTUB,
	PPC_INS_VCMPGTUD,
	PPC_INS_VCMPGTUH,
	PPC_INS_VCMPGTUW,
	PPC_INS_VCTSXS,
	PPC_INS_VCTUXS,
	PPC_INS_VEQV,
	PPC_INS_VEXPTEFP,
	PPC_INS_VLOGEFP,
	PPC_INS_VMADDFP,
	PPC_INS_VMAXFP,
	PPC_INS_VMAXSB,
	PPC_INS_VMAXSD,
	PPC_INS_VMAXSH,
	PPC_INS_VMAXSW,
	PPC_INS_VMAXUB,
	PPC_INS_VMAXUD,
	PPC_INS_VMAXUH,
	PPC_INS_VMAXUW,
	PPC_INS_VMHADDSHS,
	PPC_INS_VMHRADDSHS,
	PPC_INS_VMINUD,
	PPC_INS_VMINFP,
	PPC_INS_VMINSB,
	PPC_INS_VMINSD,
	PPC_INS_VMINSH,
	PPC_INS_VMINSW,
	PPC_INS_VMINUB,
	PPC_INS_VMINUH,
	PPC_INS_VMINUW,
	PPC_INS_VMLADDUHM,
	PPC_INS_VMRGHB,
	PPC_INS_VMRGHH,
	PPC_INS_VMRGHW,
	PPC_INS_VMRGLB,
	PPC_INS_VMRGLH,
	PPC_INS_VMRGLW,
	PPC_INS_VMSUMMBM,
	PPC_INS_VMSUMSHM,
	PPC_INS_VMSUMSHS,
	PPC_INS_VMSUMUBM,
	PPC_INS_VMSUMUHM,
	PPC_INS_VMSUMUHS,
	PPC_INS_VMULESB,
	PPC_INS_VMULESH,
	PPC_INS_VMULESW,
	PPC_INS_VMULEUB,
	PPC_INS_VMULEUH,
	PPC_INS_VMULEUW,
	PPC_INS_VMULOSB,
	PPC_INS_VMULOSH,
	PPC_INS_VMULOSW,
	PPC_INS_VMULOUB,
	PPC_INS_VMULOUH,
	PPC_INS_VMULOUW,
	PPC_INS_VMULUWM,
	PPC_INS_VNAND,
	PPC_INS_VNMSUBFP,
	PPC_INS_VNOR,
	PPC_INS_VOR,
	PPC_INS_VORC,
	PPC_INS_VPERM,
	PPC_INS_VPKPX,
	PPC_INS_VPKSHSS,
	PPC_INS_VPKSHUS,
	PPC_INS_VPKSWSS,
	PPC_INS_VPKSWUS,
	PPC_INS_VPKUHUM,
	PPC_INS_VPKUHUS,
	PPC_INS_VPKUWUM,
	PPC_INS_VPKUWUS,
	PPC_INS_VPOPCNTB,
	PPC_INS_VPOPCNTD,
	PPC_INS_VPOPCNTH,
	PPC_INS_VPOPCNTW,
	PPC_INS_VREFP,
	PPC_INS_VRFIM,
	PPC_INS_VRFIN,
	PPC_INS_VRFIP,
	PPC_INS_VRFIZ,
	PPC_INS_VRLB,
	PPC_INS_VRLD,
	PPC_INS_VRLH,
	PPC_INS_VRLW,
	PPC_INS_VRSQRTEFP,
	PPC_INS_VSEL,
	PPC_INS_VSL,
	PPC_INS_VSLB,
	PPC_INS_VSLD,
	PPC_INS_VSLDOI,
	PPC_INS_VSLH,
	PPC_INS_VSLO,
	PPC_INS_VSLW,
	PPC_INS_VSPLTB,
	PPC_INS_VSPLTH,
	PPC_INS_VSPLTISB,
	PPC_INS_VSPLTISH,
	PPC_INS_VSPLTISW,
	PPC_INS_VSPLTW,
	PPC_INS_VSR,
	PPC_INS_VSRAB,
	PPC_INS_VSRAD,
	PPC_INS_VSRAH,
	PPC_INS_VSRAW,
	PPC_INS_VSRB,
	PPC_INS_VSRD,
	PPC_INS_VSRH,
	PPC_INS_VSRO,
	PPC_INS_VSRW,
	PPC_INS_VSUBCUW,
	PPC_INS_VSUBFP,
	PPC_INS_VSUBSBS,
	PPC_INS_VSUBSHS,
	PPC_INS_VSUBSWS,
	PPC_INS_VSUBUBM,
	PPC_INS_VSUBUBS,
	PPC_INS_VSUBUDM,
	PPC_INS_VSUBUHM,
	PPC_INS_VSUBUHS,
	PPC_INS_VSUBUWM,
	PPC_INS_VSUBUWS,
	PPC_INS_VSUM2SWS,
	PPC_INS_VSUM4SBS,
	PPC_INS_VSUM4SHS,
	PPC_INS_VSUM4UBS,
	PPC_INS_VSUMSWS,
	PPC_INS_VUPKHPX,
	PPC_INS_VUPKHSB,
	PPC_INS_VUPKHSH,
	PPC_INS_VUPKLPX,
	PPC_INS_VUPKLSB,
	PPC_INS_VUPKLSH,
	PPC_INS_VXOR,
	PPC_INS_WAIT,
	PPC_INS_WRTEE,
	PPC_INS_WRTEEI,
	PPC_INS_XOR,
	PPC_INS_XORI,
	PPC_INS_XORIS,
	PPC_INS_XSABSDP,
	PPC_INS_XSADDDP,
	PPC_INS_XSCMPODP,
	PPC_INS_XSCMPUDP,
	PPC_INS_XSCPSGNDP,
	PPC_INS_XSCVDPSP,
	PPC_INS_XSCVDPSXDS,
	PPC_INS_XSCVDPSXWS,
	PPC_INS_XSCVDPUXDS,
	PPC_INS_XSCVDPUXWS,
	PPC_INS_XSCVSPDP,
	PPC_INS_XSCVSXDDP,
	PPC_INS_XSCVUXDDP,
	PPC_INS_XSDIVDP,
	PPC_INS_XSMADDADP,
	PPC_INS_XSMADDMDP,
	PPC_INS_XSMAXDP,
	PPC_INS_XSMINDP,
	PPC_INS_XSMSUBADP,
	PPC_INS_XSMSUBMDP,
	PPC_INS_XSMULDP,
	PPC_INS_XSNABSDP,
	PPC_INS_XSNEGDP,
	PPC_INS_XSNMADDADP,
	PPC_INS_XSNMADDMDP,
	PPC_INS_XSNMSUBADP,
	PPC_INS_XSNMSUBMDP,
	PPC_INS_XSRDPI,
	PPC_INS_XSRDPIC,
	PPC_INS_XSRDPIM,
	PPC_INS_XSRDPIP,
	PPC_INS_XSRDPIZ,
	PPC_INS_XSREDP,
	PPC_INS_XSRSQRTEDP,
	PPC_INS_XSSQRTDP,
	PPC_INS_XSSUBDP,
	PPC_INS_XSTDIVDP,
	PPC_INS_XSTSQRTDP,
	PPC_INS_XVABSDP,
	PPC_INS_XVABSSP,
	PPC_INS_XVADDDP,
	PPC_INS_XVADDSP,
	PPC_INS_XVCMPEQDP,
	PPC_INS_XVCMPEQSP,
	PPC_INS_XVCMPGEDP,
	PPC_INS_XVCMPGESP,
	PPC_INS_XVCMPGTDP,
	PPC_INS_XVCMPGTSP,
	PPC_INS_XVCPSGNDP,
	PPC_INS_XVCPSGNSP,
	PPC_INS_XVCVDPSP,
	PPC_INS_XVCVDPSXDS,
	PPC_INS_XVCVDPSXWS,
	PPC_INS_XVCVDPUXDS,
	PPC_INS_XVCVDPUXWS,
	PPC_INS_XVCVSPDP,
	PPC_INS_XVCVSPSXDS,
	PPC_INS_XVCVSPSXWS,
	PPC_INS_XVCVSPUXDS,
	PPC_INS_XVCVSPUXWS,
	PPC_INS_XVCVSXDDP,
	PPC_INS_XVCVSXDSP,
	PPC_INS_XVCVSXWDP,
	PPC_INS_XVCVSXWSP,
	PPC_INS_XVCVUXDDP,
	PPC_INS_XVCVUXDSP,
	PPC_INS_XVCVUXWDP,
	PPC_INS_XVCVUXWSP,
	PPC_INS_XVDIVDP,
	PPC_INS_XVDIVSP,
	PPC_INS_XVMADDADP,
	PPC_INS_XVMADDASP,
	PPC_INS_XVMADDMDP,
	PPC_INS_XVMADDMSP,
	PPC_INS_XVMAXDP,
	PPC_INS_XVMAXSP,
	PPC_INS_XVMINDP,
	PPC_INS_XVMINSP,
	PPC_INS_XVMSUBADP,
	PPC_INS_XVMSUBASP,
	PPC_INS_XVMSUBMDP,
	PPC_INS_XVMSUBMSP,
	PPC_INS_XVMULDP,
	PPC_INS_XVMULSP,
	PPC_INS_XVNABSDP,
	PPC_INS_XVNABSSP,
	PPC_INS_XVNEGDP,
	PPC_INS_XVNEGSP,
	PPC_INS_XVNMADDADP,
	PPC_INS_XVNMADDASP,
	PPC_INS_XVNMADDMDP,
	PPC_INS_XVNMADDMSP,
	PPC_INS_XVNMSUBADP,
	PPC_INS_XVNMSUBASP,
	PPC_INS_XVNMSUBMDP,
	PPC_INS_XVNMSUBMSP,
	PPC_INS_XVRDPI,
	PPC_INS_XVRDPIC,
	PPC_INS_XVRDPIM,
	PPC_INS_XVRDPIP,
	PPC_INS_XVRDPIZ,
	PPC_INS_XVREDP,
	PPC_INS_XVRESP,
	PPC_INS_XVRSPI,
	PPC_INS_XVRSPIC,
	PPC_INS_XVRSPIM,
	PPC_INS_XVRSPIP,
	PPC_INS_XVRSPIZ,
	PPC_INS_XVRSQRTEDP,
	PPC_INS_XVRSQRTESP,
	PPC_INS_XVSQRTDP,
	PPC_INS_XVSQRTSP,
	PPC_INS_XVSUBDP,
	PPC_INS_XVSUBSP,
	PPC_INS_XVTDIVDP,
	PPC_INS_XVTDIVSP,
	PPC_INS_XVTSQRTDP,
	PPC_INS_XVTSQRTSP,
	PPC_INS_XXLAND,
	PPC_INS_XXLANDC,
	PPC_INS_XXLEQV,
	PPC_INS_XXLNAND,
	PPC_INS_XXLNOR,
	PPC_INS_XXLOR,
	PPC_INS_XXLORC,
	PPC_INS_XXLXOR,
	PPC_INS_XXMRGHW,
	PPC_INS_XXMRGLW,
	PPC_INS_XXPERMDI,
	PPC_INS_XXSEL,
	PPC_INS_XXSLDWI,
	PPC_INS_XXSPLTW,
	PPC_INS_BCA,
	PPC_INS_BCLA,

	// extra & alias instructions
	PPC_INS_SLWI,
	PPC_INS_SRWI,
	PPC_INS_SLDI,

	PPC_INS_BTA,
	PPC_INS_CRSET,
	PPC_INS_CRNOT,
	PPC_INS_CRMOVE,
	PPC_INS_CRCLR,
	PPC_INS_MFBR0,
	PPC_INS_MFBR1,
	PPC_INS_MFBR2,
	PPC_INS_MFBR3,
	PPC_INS_MFBR4,
	PPC_INS_MFBR5,
	PPC_INS_MFBR6,
	PPC_INS_MFBR7,
	PPC_INS_MFXER,
	PPC_INS_MFRTCU,
	PPC_INS_MFRTCL,
	PPC_INS_MFDSCR,
	PPC_INS_MFDSISR,
	PPC_INS_MFDAR,
	PPC_INS_MFSRR2,
	PPC_INS_MFSRR3,
	PPC_INS_MFCFAR,
	PPC_INS_MFAMR,
	PPC_INS_MFPID,
	PPC_INS_MFTBLO,
	PPC_INS_MFTBHI,
	PPC_INS_MFDBATU,
	PPC_INS_MFDBATL,
	PPC_INS_MFIBATU,
	PPC_INS_MFIBATL,
	PPC_INS_MFDCCR,
	PPC_INS_MFICCR,
	PPC_INS_MFDEAR,
	PPC_INS_MFESR,
	PPC_INS_MFSPEFSCR,
	PPC_INS_MFTCR,
	PPC_INS_MFASR,
	PPC_INS_MFPVR,
	PPC_INS_MFTBU,
	PPC_INS_MTCR,
	PPC_INS_MTBR0,
	PPC_INS_MTBR1,
	PPC_INS_MTBR2,
	PPC_INS_MTBR3,
	PPC_INS_MTBR4,
	PPC_INS_MTBR5,
	PPC_INS_MTBR6,
	PPC_INS_MTBR7,
	PPC_INS_MTXER,
	PPC_INS_MTDSCR,
	PPC_INS_MTDSISR,
	PPC_INS_MTDAR,
	PPC_INS_MTSRR2,
	PPC_INS_MTSRR3,
	PPC_INS_MTCFAR,
	PPC_INS_MTAMR,
	PPC_INS_MTPID,
	PPC_INS_MTTBL,
	PPC_INS_MTTBU,
	PPC_INS_MTTBLO,
	PPC_INS_MTTBHI,
	PPC_INS_MTDBATU,
	PPC_INS_MTDBATL,
	PPC_INS_MTIBATU,
	PPC_INS_MTIBATL,
	PPC_INS_MTDCCR,
	PPC_INS_MTICCR,
	PPC_INS_MTDEAR,
	PPC_INS_MTESR,
	PPC_INS_MTSPEFSCR,
	PPC_INS_MTTCR,
	PPC_INS_NOT,
	PPC_INS_MR,
	PPC_INS_ROTLD,
	PPC_INS_ROTLDI,
	PPC_INS_CLRLDI,
	PPC_INS_ROTLWI,
	PPC_INS_CLRLWI,
	PPC_INS_ROTLW,
	PPC_INS_SUB,
	PPC_INS_SUBC,
	PPC_INS_LWSYNC,
	PPC_INS_PTESYNC,
	PPC_INS_TDLT,
	PPC_INS_TDEQ,
	PPC_INS_TDGT,
	PPC_INS_TDNE,
	PPC_INS_TDLLT,
	PPC_INS_TDLGT,
	PPC_INS_TDU,
	PPC_INS_TDLTI,
	PPC_INS_TDEQI,
	PPC_INS_TDGTI,
	PPC_INS_TDNEI,
	PPC_INS_TDLLTI,
	PPC_INS_TDLGTI,
	PPC_INS_TDUI,
	PPC_INS_TLBREHI,
	PPC_INS_TLBRELO,
	PPC_INS_TLBWEHI,
	PPC_INS_TLBWELO,
	PPC_INS_TWLT,
	PPC_INS_TWEQ,
	PPC_INS_TWGT,
	PPC_INS_TWNE,
	PPC_INS_TWLLT,
	PPC_INS_TWLGT,
	PPC_INS_TWU,
	PPC_INS_TWLTI,
	PPC_INS_TWEQI,
	PPC_INS_TWGTI,
	PPC_INS_TWNEI,
	PPC_INS_TWLLTI,
	PPC_INS_TWLGTI,
	PPC_INS_TWUI,
	PPC_INS_WAITRSV,
	PPC_INS_WAITIMPL,
	PPC_INS_XNOP,
	PPC_INS_XVMOVDP,
	PPC_INS_XVMOVSP,
	PPC_INS_XXSPLTD,
	PPC_INS_XXMRGHD,
	PPC_INS_XXMRGLD,
	PPC_INS_XXSWAPD,
	PPC_INS_BT,
	PPC_INS_BF,
	PPC_INS_BDNZT,
	PPC_INS_BDNZF,
	PPC_INS_BDZF,
	PPC_INS_BDZT,
	PPC_INS_BFA,
	PPC_INS_BDNZTA,
	PPC_INS_BDNZFA,
	PPC_INS_BDZTA,
	PPC_INS_BDZFA,
	PPC_INS_BTCTR,
	PPC_INS_BFCTR,
	PPC_INS_BTCTRL,
	PPC_INS_BFCTRL,
	PPC_INS_BTL,
	PPC_INS_BFL,
	PPC_INS_BDNZTL,
	PPC_INS_BDNZFL,
	PPC_INS_BDZTL,
	PPC_INS_BDZFL,
	PPC_INS_BTLA,
	PPC_INS_BFLA,
	PPC_INS_BDNZTLA,
	PPC_INS_BDNZFLA,
	PPC_INS_BDZTLA,
	PPC_INS_BDZFLA,
	PPC_INS_BTLR,
	PPC_INS_BFLR,
	PPC_INS_BDNZTLR,
	PPC_INS_BDZTLR,
	PPC_INS_BDZFLR,
	PPC_INS_BTLRL,
	PPC_INS_BFLRL,
	PPC_INS_BDNZTLRL,
	PPC_INS_BDNZFLRL,
	PPC_INS_BDZTLRL,
	PPC_INS_BDZFLRL,

	// QPX
	PPC_INS_QVFAND,
	PPC_INS_QVFCLR,
	PPC_INS_QVFANDC,
	PPC_INS_QVFCTFB,
	PPC_INS_QVFXOR,
	PPC_INS_QVFOR,
	PPC_INS_QVFNOR,
	PPC_INS_QVFEQU,
	PPC_INS_QVFNOT,
	PPC_INS_QVFORC,
	PPC_INS_QVFNAND,
	PPC_INS_QVFSET,

	PPC_INS_ENDING,   // <-- mark the end of the list of instructions
} ppc_insn;

/// Group of PPC instructions
typedef enum ppc_insn_group {
	PPC_GRP_INVALID = 0, ///< = CS_GRP_INVALID

	// Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	PPC_GRP_JUMP,	///< = CS_GRP_JUMP

	// Architecture-specific groups
	PPC_GRP_ALTIVEC = 128,
	PPC_GRP_MODE32,
	PPC_GRP_MODE64,
	PPC_GRP_BOOKE,
	PPC_GRP_NOTBOOKE,
	PPC_GRP_SPE,
	PPC_GRP_VSX,
	PPC_GRP_E500,
	PPC_GRP_PPC4XX,
	PPC_GRP_PPC6XX,
	PPC_GRP_ICBT,
	PPC_GRP_P8ALTIVEC,
	PPC_GRP_P8VECTOR,
	PPC_GRP_QPX,

	PPC_GRP_ENDING,   // <-- mark the end of the list of groups
} ppc_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`capstone/include/capstone/sparc.h`:

```h
#ifndef CAPSTONE_SPARC_H
#define CAPSTONE_SPARC_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

// GCC SPARC toolchain has a default macro called "sparc" which breaks
// compilation
#undef sparc

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

/// Enums corresponding to Sparc condition codes, both icc's and fcc's.
typedef enum sparc_cc {
	SPARC_CC_INVALID = 0,	///< invalid CC (default)
	// Integer condition codes
	SPARC_CC_ICC_A   =  8+256,  ///< Always
	SPARC_CC_ICC_N   =  0+256,  ///< Never
	SPARC_CC_ICC_NE  =  9+256,  ///< Not Equal
	SPARC_CC_ICC_E   =  1+256,  ///< Equal
	SPARC_CC_ICC_G   = 10+256,  ///< Greater
	SPARC_CC_ICC_LE  =  2+256,  ///< Less or Equal
	SPARC_CC_ICC_GE  = 11+256,  ///< Greater or Equal
	SPARC_CC_ICC_L   =  3+256,  ///< Less
	SPARC_CC_ICC_GU  = 12+256,  ///< Greater Unsigned
	SPARC_CC_ICC_LEU =  4+256,  ///< Less or Equal Unsigned
	SPARC_CC_ICC_CC  = 13+256,  ///< Carry Clear/Great or Equal Unsigned
	SPARC_CC_ICC_CS  =  5+256,  ///< Carry Set/Less Unsigned
	SPARC_CC_ICC_POS = 14+256,  ///< Positive
	SPARC_CC_ICC_NEG =  6+256,  ///< Negative
	SPARC_CC_ICC_VC  = 15+256,  ///< Overflow Clear
	SPARC_CC_ICC_VS  =  7+256,  ///< Overflow Set

	// Floating condition codes
	SPARC_CC_FCC_A   =  8+16+256,  ///< Always
	SPARC_CC_FCC_N   =  0+16+256,  ///< Never
	SPARC_CC_FCC_U   =  7+16+256,  ///< Unordered
	SPARC_CC_FCC_G   =  6+16+256,  ///< Greater
	SPARC_CC_FCC_UG  =  5+16+256,  ///< Unordered or Greater
	SPARC_CC_FCC_L   =  4+16+256,  ///< Less
	SPARC_CC_FCC_UL  =  3+16+256,  ///< Unordered or Less
	SPARC_CC_FCC_LG  =  2+16+256,  ///< Less or Greater
	SPARC_CC_FCC_NE  =  1+16+256,  ///< Not Equal
	SPARC_CC_FCC_E   =  9+16+256,  ///< Equal
	SPARC_CC_FCC_UE  = 10+16+256,  ///< Unordered or Equal
	SPARC_CC_FCC_GE  = 11+16+256,  ///< Greater or Equal
	SPARC_CC_FCC_UGE = 12+16+256,  ///< Unordered or Greater or Equal
	SPARC_CC_FCC_LE  = 13+16+256,  ///< Less or Equal
	SPARC_CC_FCC_ULE = 14+16+256,  ///< Unordered or Less or Equal
	SPARC_CC_FCC_O   = 15+16+256,  ///< Ordered
} sparc_cc;

/// Branch hint
typedef enum sparc_hint {
	SPARC_HINT_INVALID = 0,	///< no hint
	SPARC_HINT_A	= 1 << 0,	///< annul delay slot instruction
	SPARC_HINT_PT	= 1 << 1,	///< branch taken
	SPARC_HINT_PN	= 1 << 2,	///< branch NOT taken
} sparc_hint;

/// Operand type for instruction's operands
typedef enum sparc_op_type {
	SPARC_OP_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	SPARC_OP_REG, ///< = CS_OP_REG (Register operand).
	SPARC_OP_IMM, ///< = CS_OP_IMM (Immediate operand).
	SPARC_OP_MEM, ///< = CS_OP_MEM (Memory operand).
} sparc_op_type;

/// SPARC registers
typedef enum sparc_reg {
	SPARC_REG_INVALID = 0,

	SPARC_REG_F0,
	SPARC_REG_F1,
	SPARC_REG_F2,
	SPARC_REG_F3,
	SPARC_REG_F4,
	SPARC_REG_F5,
	SPARC_REG_F6,
	SPARC_REG_F7,
	SPARC_REG_F8,
	SPARC_REG_F9,
	SPARC_REG_F10,
	SPARC_REG_F11,
	SPARC_REG_F12,
	SPARC_REG_F13,
	SPARC_REG_F14,
	SPARC_REG_F15,
	SPARC_REG_F16,
	SPARC_REG_F17,
	SPARC_REG_F18,
	SPARC_REG_F19,
	SPARC_REG_F20,
	SPARC_REG_F21,
	SPARC_REG_F22,
	SPARC_REG_F23,
	SPARC_REG_F24,
	SPARC_REG_F25,
	SPARC_REG_F26,
	SPARC_REG_F27,
	SPARC_REG_F28,
	SPARC_REG_F29,
	SPARC_REG_F30,
	SPARC_REG_F31,
	SPARC_REG_F32,
	SPARC_REG_F34,
	SPARC_REG_F36,
	SPARC_REG_F38,
	SPARC_REG_F40,
	SPARC_REG_F42,
	SPARC_REG_F44,
	SPARC_REG_F46,
	SPARC_REG_F48,
	SPARC_REG_F50,
	SPARC_REG_F52,
	SPARC_REG_F54,
	SPARC_REG_F56,
	SPARC_REG_F58,
	SPARC_REG_F60,
	SPARC_REG_F62,
	SPARC_REG_FCC0,	// Floating condition codes
	SPARC_REG_FCC1,
	SPARC_REG_FCC2,
	SPARC_REG_FCC3,
	SPARC_REG_FP,
	SPARC_REG_G0,
	SPARC_REG_G1,
	SPARC_REG_G2,
	SPARC_REG_G3,
	SPARC_REG_G4,
	SPARC_REG_G5,
	SPARC_REG_G6,
	SPARC_REG_G7,
	SPARC_REG_I0,
	SPARC_REG_I1,
	SPARC_REG_I2,
	SPARC_REG_I3,
	SPARC_REG_I4,
	SPARC_REG_I5,
	SPARC_REG_I7,
	SPARC_REG_ICC,	// Integer condition codes
	SPARC_REG_L0,
	SPARC_REG_L1,
	SPARC_REG_L2,
	SPARC_REG_L3,
	SPARC_REG_L4,
	SPARC_REG_L5,
	SPARC_REG_L6,
	SPARC_REG_L7,
	SPARC_REG_O0,
	SPARC_REG_O1,
	SPARC_REG_O2,
	SPARC_REG_O3,
	SPARC_REG_O4,
	SPARC_REG_O5,
	SPARC_REG_O7,
	SPARC_REG_SP,
	SPARC_REG_Y,

	// special register
	SPARC_REG_XCC,

	SPARC_REG_ENDING,   // <-- mark the end of the list of registers

	// extras
	SPARC_REG_O6 = SPARC_REG_SP,
	SPARC_REG_I6 = SPARC_REG_FP,
} sparc_reg;

/// Instruction's operand referring to memory
/// This is associated with SPARC_OP_MEM operand type above
typedef struct sparc_op_mem {
	uint8_t base;		///< base register, can be safely interpreted as
				///< a value of type `sparc_reg`, but it is only
				///< one byte wide
	uint8_t index;		///< index register, same conditions apply here
	int32_t disp;		///< displacement/offset value
} sparc_op_mem;

/// Instruction operand
typedef struct cs_sparc_op {
	sparc_op_type type;	///< operand type
	union {
		sparc_reg reg;	///< register value for REG operand
		int64_t imm;		///< immediate value for IMM operand
		sparc_op_mem mem;		///< base/disp value for MEM operand
	};
} cs_sparc_op;

/// Instruction structure
typedef struct cs_sparc {
	sparc_cc cc;	///< code condition for this insn
	sparc_hint hint;	///< branch hint: encoding as bitwise OR of sparc_hint.
	/// Number of operands of this instruction,
	/// or 0 when instruction has no operand.
	uint8_t op_count;
	cs_sparc_op operands[4]; ///< operands for this instruction.
} cs_sparc;

/// SPARC instruction
typedef enum sparc_insn {
	SPARC_INS_INVALID = 0,

	SPARC_INS_ADDCC,
	SPARC_INS_ADDX,
	SPARC_INS_ADDXCC,
	SPARC_INS_ADDXC,
	SPARC_INS_ADDXCCC,
	SPARC_INS_ADD,
	SPARC_INS_ALIGNADDR,
	SPARC_INS_ALIGNADDRL,
	SPARC_INS_ANDCC,
	SPARC_INS_ANDNCC,
	SPARC_INS_ANDN,
	SPARC_INS_AND,
	SPARC_INS_ARRAY16,
	SPARC_INS_ARRAY32,
	SPARC_INS_ARRAY8,
	SPARC_INS_B,
	SPARC_INS_JMP,
	SPARC_INS_BMASK,
	SPARC_INS_FB,
	SPARC_INS_BRGEZ,
	SPARC_INS_BRGZ,
	SPARC_INS_BRLEZ,
	SPARC_INS_BRLZ,
	SPARC_INS_BRNZ,
	SPARC_INS_BRZ,
	SPARC_INS_BSHUFFLE,
	SPARC_INS_CALL,
	SPARC_INS_CASX,
	SPARC_INS_CAS,
	SPARC_INS_CMASK16,
	SPARC_INS_CMASK32,
	SPARC_INS_CMASK8,
	SPARC_INS_CMP,
	SPARC_INS_EDGE16,
	SPARC_INS_EDGE16L,
	SPARC_INS_EDGE16LN,
	SPARC_INS_EDGE16N,
	SPARC_INS_EDGE32,
	SPARC_INS_EDGE32L,
	SPARC_INS_EDGE32LN,
	SPARC_INS_EDGE32N,
	SPARC_INS_EDGE8,
	SPARC_INS_EDGE8L,
	SPARC_INS_EDGE8LN,
	SPARC_INS_EDGE8N,
	SPARC_INS_FABSD,
	SPARC_INS_FABSQ,
	SPARC_INS_FABSS,
	SPARC_INS_FADDD,
	SPARC_INS_FADDQ,
	SPARC_INS_FADDS,
	SPARC_INS_FALIGNDATA,
	SPARC_INS_FAND,
	SPARC_INS_FANDNOT1,
	SPARC_INS_FANDNOT1S,
	SPARC_INS_FANDNOT2,
	SPARC_INS_FANDNOT2S,
	SPARC_INS_FANDS,
	SPARC_INS_FCHKSM16,
	SPARC_INS_FCMPD,
	SPARC_INS_FCMPEQ16,
	SPARC_INS_FCMPEQ32,
	SPARC_INS_FCMPGT16,
	SPARC_INS_FCMPGT32,
	SPARC_INS_FCMPLE16,
	SPARC_INS_FCMPLE32,
	SPARC_INS_FCMPNE16,
	SPARC_INS_FCMPNE32,
	SPARC_INS_FCMPQ,
	SPARC_INS_FCMPS,
	SPARC_INS_FDIVD,
	SPARC_INS_FDIVQ,
	SPARC_INS_FDIVS,
	SPARC_INS_FDMULQ,
	SPARC_INS_FDTOI,
	SPARC_INS_FDTOQ,
	SPARC_INS_FDTOS,
	SPARC_INS_FDTOX,
	SPARC_INS_FEXPAND,
	SPARC_INS_FHADDD,
	SPARC_INS_FHADDS,
	SPARC_INS_FHSUBD,
	SPARC_INS_FHSUBS,
	SPARC_INS_FITOD,
	SPARC_INS_FITOQ,
	SPARC_INS_FITOS,
	SPARC_INS_FLCMPD,
	SPARC_INS_FLCMPS,
	SPARC_INS_FLUSHW,
	SPARC_INS_FMEAN16,
	SPARC_INS_FMOVD,
	SPARC_INS_FMOVQ,
	SPARC_INS_FMOVRDGEZ,
	SPARC_INS_FMOVRQGEZ,
	SPARC_INS_FMOVRSGEZ,
	SPARC_INS_FMOVRDGZ,
	SPARC_INS_FMOVRQGZ,
	SPARC_INS_FMOVRSGZ,
	SPARC_INS_FMOVRDLEZ,
	SPARC_INS_FMOVRQLEZ,
	SPARC_INS_FMOVRSLEZ,
	SPARC_INS_FMOVRDLZ,
	SPARC_INS_FMOVRQLZ,
	SPARC_INS_FMOVRSLZ,
	SPARC_INS_FMOVRDNZ,
	SPARC_INS_FMOVRQNZ,
	SPARC_INS_FMOVRSNZ,
	SPARC_INS_FMOVRDZ,
	SPARC_INS_FMOVRQZ,
	SPARC_INS_FMOVRSZ,
	SPARC_INS_FMOVS,
	SPARC_INS_FMUL8SUX16,
	SPARC_INS_FMUL8ULX16,
	SPARC_INS_FMUL8X16,
	SPARC_INS_FMUL8X16AL,
	SPARC_INS_FMUL8X16AU,
	SPARC_INS_FMULD,
	SPARC_INS_FMULD8SUX16,
	SPARC_INS_FMULD8ULX16,
	SPARC_INS_FMULQ,
	SPARC_INS_FMULS,
	SPARC_INS_FNADDD,
	SPARC_INS_FNADDS,
	SPARC_INS_FNAND,
	SPARC_INS_FNANDS,
	SPARC_INS_FNEGD,
	SPARC_INS_FNEGQ,
	SPARC_INS_FNEGS,
	SPARC_INS_FNHADDD,
	SPARC_INS_FNHADDS,
	SPARC_INS_FNOR,
	SPARC_INS_FNORS,
	SPARC_INS_FNOT1,
	SPARC_INS_FNOT1S,
	SPARC_INS_FNOT2,
	SPARC_INS_FNOT2S,
	SPARC_INS_FONE,
	SPARC_INS_FONES,
	SPARC_INS_FOR,
	SPARC_INS_FORNOT1,
	SPARC_INS_FORNOT1S,
	SPARC_INS_FORNOT2,
	SPARC_INS_FORNOT2S,
	SPARC_INS_FORS,
	SPARC_INS_FPACK16,
	SPARC_INS_FPACK32,
	SPARC_INS_FPACKFIX,
	SPARC_INS_FPADD16,
	SPARC_INS_FPADD16S,
	SPARC_INS_FPADD32,
	SPARC_INS_FPADD32S,
	SPARC_INS_FPADD64,
	SPARC_INS_FPMERGE,
	SPARC_INS_FPSUB16,
	SPARC_INS_FPSUB16S,
	SPARC_INS_FPSUB32,
	SPARC_INS_FPSUB32S,
	SPARC_INS_FQTOD,
	SPARC_INS_FQTOI,
	SPARC_INS_FQTOS,
	SPARC_INS_FQTOX,
	SPARC_INS_FSLAS16,
	SPARC_INS_FSLAS32,
	SPARC_INS_FSLL16,
	SPARC_INS_FSLL32,
	SPARC_INS_FSMULD,
	SPARC_INS_FSQRTD,
	SPARC_INS_FSQRTQ,
	SPARC_INS_FSQRTS,
	SPARC_INS_FSRA16,
	SPARC_INS_FSRA32,
	SPARC_INS_FSRC1,
	SPARC_INS_FSRC1S,
	SPARC_INS_FSRC2,
	SPARC_INS_FSRC2S,
	SPARC_INS_FSRL16,
	SPARC_INS_FSRL32,
	SPARC_INS_FSTOD,
	SPARC_INS_FSTOI,
	SPARC_INS_FSTOQ,
	SPARC_INS_FSTOX,
	SPARC_INS_FSUBD,
	SPARC_INS_FSUBQ,
	SPARC_INS_FSUBS,
	SPARC_INS_FXNOR,
	SPARC_INS_FXNORS,
	SPARC_INS_FXOR,
	SPARC_INS_FXORS,
	SPARC_INS_FXTOD,
	SPARC_INS_FXTOQ,
	SPARC_INS_FXTOS,
	SPARC_INS_FZERO,
	SPARC_INS_FZEROS,
	SPARC_INS_JMPL,
	SPARC_INS_LDD,
	SPARC_INS_LD,
	SPARC_INS_LDQ,
	SPARC_INS_LDSB,
	SPARC_INS_LDSH,
	SPARC_INS_LDSW,
	SPARC_INS_LDUB,
	SPARC_INS_LDUH,
	SPARC_INS_LDX,
	SPARC_INS_LZCNT,
	SPARC_INS_MEMBAR,
	SPARC_INS_MOVDTOX,
	SPARC_INS_MOV,
	SPARC_INS_MOVRGEZ,
	SPARC_INS_MOVRGZ,
	SPARC_INS_MOVRLEZ,
	SPARC_INS_MOVRLZ,
	SPARC_INS_MOVRNZ,
	SPARC_INS_MOVRZ,
	SPARC_INS_MOVSTOSW,
	SPARC_INS_MOVSTOUW,
	SPARC_INS_MULX,
	SPARC_INS_NOP,
	SPARC_INS_ORCC,
	SPARC_INS_ORNCC,
	SPARC_INS_ORN,
	SPARC_INS_OR,
	SPARC_INS_PDIST,
	SPARC_INS_PDISTN,
	SPARC_INS_POPC,
	SPARC_INS_RD,
	SPARC_INS_RESTORE,
	SPARC_INS_RETT,
	SPARC_INS_SAVE,
	SPARC_INS_SDIVCC,
	SPARC_INS_SDIVX,
	SPARC_INS_SDIV,
	SPARC_INS_SETHI,
	SPARC_INS_SHUTDOWN,
	SPARC_INS_SIAM,
	SPARC_INS_SLLX,
	SPARC_INS_SLL,
	SPARC_INS_SMULCC,
	SPARC_INS_SMUL,
	SPARC_INS_SRAX,
	SPARC_INS_SRA,
	SPARC_INS_SRLX,
	SPARC_INS_SRL,
	SPARC_INS_STBAR,
	SPARC_INS_STB,
	SPARC_INS_STD,
	SPARC_INS_ST,
	SPARC_INS_STH,
	SPARC_INS_STQ,
	SPARC_INS_STX,
	SPARC_INS_SUBCC,
	SPARC_INS_SUBX,
	SPARC_INS_SUBXCC,
	SPARC_INS_SUB,
	SPARC_INS_SWAP,
	SPARC_INS_TADDCCTV,
	SPARC_INS_TADDCC,
	SPARC_INS_T,
	SPARC_INS_TSUBCCTV,
	SPARC_INS_TSUBCC,
	SPARC_INS_UDIVCC,
	SPARC_INS_UDIVX,
	SPARC_INS_UDIV,
	SPARC_INS_UMULCC,
	SPARC_INS_UMULXHI,
	SPARC_INS_UMUL,
	SPARC_INS_UNIMP,
	SPARC_INS_FCMPED,
	SPARC_INS_FCMPEQ,
	SPARC_INS_FCMPES,
	SPARC_INS_WR,
	SPARC_INS_XMULX,
	SPARC_INS_XMULXHI,
	SPARC_INS_XNORCC,
	SPARC_INS_XNOR,
	SPARC_INS_XORCC,
	SPARC_INS_XOR,

	// alias instructions
	SPARC_INS_RET,
	SPARC_INS_RETL,

	SPARC_INS_ENDING,   // <-- mark the end of the list of instructions
} sparc_insn;

/// Group of SPARC instructions
typedef enum sparc_insn_group {
	SPARC_GRP_INVALID = 0, ///< = CS_GRP_INVALID

	// Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	SPARC_GRP_JUMP,	///< = CS_GRP_JUMP

	// Architecture-specific groups
	SPARC_GRP_HARDQUAD = 128,
	SPARC_GRP_V9,
	SPARC_GRP_VIS,
	SPARC_GRP_VIS2,
	SPARC_GRP_VIS3, 
	SPARC_GRP_32BIT,
	SPARC_GRP_64BIT,

	SPARC_GRP_ENDING,   // <-- mark the end of the list of groups
} sparc_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`capstone/include/capstone/systemz.h`:

```h
#ifndef CAPSTONE_SYSTEMZ_H
#define CAPSTONE_SYSTEMZ_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

/// Enums corresponding to SystemZ condition codes
typedef enum sysz_cc {
	SYSZ_CC_INVALID = 0,	///< invalid CC (default)

	SYSZ_CC_O,
	SYSZ_CC_H,
	SYSZ_CC_NLE,
	SYSZ_CC_L,
	SYSZ_CC_NHE,
	SYSZ_CC_LH,
	SYSZ_CC_NE,
	SYSZ_CC_E,
	SYSZ_CC_NLH,
	SYSZ_CC_HE,
	SYSZ_CC_NL,
	SYSZ_CC_LE,
	SYSZ_CC_NH,
	SYSZ_CC_NO,
} sysz_cc;

/// Operand type for instruction's operands
typedef enum sysz_op_type {
	SYSZ_OP_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	SYSZ_OP_REG, ///< = CS_OP_REG (Register operand).
	SYSZ_OP_IMM, ///< = CS_OP_IMM (Immediate operand).
	SYSZ_OP_MEM, ///< = CS_OP_MEM (Memory operand).
	SYSZ_OP_ACREG = 64,	///< Access register operand.
} sysz_op_type;

/// SystemZ registers
typedef enum sysz_reg {
	SYSZ_REG_INVALID = 0,

	SYSZ_REG_0,
	SYSZ_REG_1,
	SYSZ_REG_2,
	SYSZ_REG_3,
	SYSZ_REG_4,
	SYSZ_REG_5,
	SYSZ_REG_6,
	SYSZ_REG_7,
	SYSZ_REG_8,
	SYSZ_REG_9,
	SYSZ_REG_10,
	SYSZ_REG_11,
	SYSZ_REG_12,
	SYSZ_REG_13,
	SYSZ_REG_14,
	SYSZ_REG_15,
	SYSZ_REG_CC,
	SYSZ_REG_F0,
	SYSZ_REG_F1,
	SYSZ_REG_F2,
	SYSZ_REG_F3,
	SYSZ_REG_F4,
	SYSZ_REG_F5,
	SYSZ_REG_F6,
	SYSZ_REG_F7,
	SYSZ_REG_F8,
	SYSZ_REG_F9,
	SYSZ_REG_F10,
	SYSZ_REG_F11,
	SYSZ_REG_F12,
	SYSZ_REG_F13,
	SYSZ_REG_F14,
	SYSZ_REG_F15,

	SYSZ_REG_R0L,

	SYSZ_REG_A0,
	SYSZ_REG_A1,
	SYSZ_REG_A2,
	SYSZ_REG_A3,
	SYSZ_REG_A4,
	SYSZ_REG_A5,
	SYSZ_REG_A6,
	SYSZ_REG_A7,
	SYSZ_REG_A8,
	SYSZ_REG_A9,
	SYSZ_REG_A10,
	SYSZ_REG_A11,
	SYSZ_REG_A12,
	SYSZ_REG_A13,
	SYSZ_REG_A14,
	SYSZ_REG_A15,
	SYSZ_REG_C0,
	SYSZ_REG_C1,
	SYSZ_REG_C2,
	SYSZ_REG_C3,
	SYSZ_REG_C4,
	SYSZ_REG_C5,
	SYSZ_REG_C6,
	SYSZ_REG_C7,
	SYSZ_REG_C8,
	SYSZ_REG_C9,
	SYSZ_REG_C10,
	SYSZ_REG_C11,
	SYSZ_REG_C12,
	SYSZ_REG_C13,
	SYSZ_REG_C14,
	SYSZ_REG_C15,
	SYSZ_REG_V0,
	SYSZ_REG_V1,
	SYSZ_REG_V2,
	SYSZ_REG_V3,
	SYSZ_REG_V4,
	SYSZ_REG_V5,
	SYSZ_REG_V6,
	SYSZ_REG_V7,
	SYSZ_REG_V8,
	SYSZ_REG_V9,
	SYSZ_REG_V10,
	SYSZ_REG_V11,
	SYSZ_REG_V12,
	SYSZ_REG_V13,
	SYSZ_REG_V14,
	SYSZ_REG_V15,
	SYSZ_REG_V16,
	SYSZ_REG_V17,
	SYSZ_REG_V18,
	SYSZ_REG_V19,
	SYSZ_REG_V20,
	SYSZ_REG_V21,
	SYSZ_REG_V22,
	SYSZ_REG_V23,
	SYSZ_REG_V24,
	SYSZ_REG_V25,
	SYSZ_REG_V26,
	SYSZ_REG_V27,
	SYSZ_REG_V28,
	SYSZ_REG_V29,
	SYSZ_REG_V30,
	SYSZ_REG_V31,
	SYSZ_REG_F16,
	SYSZ_REG_F17,
	SYSZ_REG_F18,
	SYSZ_REG_F19,
	SYSZ_REG_F20,
	SYSZ_REG_F21,
	SYSZ_REG_F22,
	SYSZ_REG_F23,
	SYSZ_REG_F24,
	SYSZ_REG_F25,
	SYSZ_REG_F26,
	SYSZ_REG_F27,
	SYSZ_REG_F28,
	SYSZ_REG_F29,
	SYSZ_REG_F30,
	SYSZ_REG_F31,
	SYSZ_REG_F0Q,
	SYSZ_REG_F4Q,

	SYSZ_REG_ENDING,
} sysz_reg;

/// Instruction's operand referring to memory
/// This is associated with SYSZ_OP_MEM operand type above
typedef struct sysz_op_mem {
	uint8_t base;		///< base register, can be safely interpreted as
				///< a value of type `sysz_reg`, but it is only
				///< one byte wide
	uint8_t index;		///< index register, same conditions apply here
	uint64_t length;	///< BDLAddr operand
	int64_t disp;	///< displacement/offset value
} sysz_op_mem;

/// Instruction operand
typedef struct cs_sysz_op {
	sysz_op_type type;	///< operand type
	union {
		sysz_reg reg;		///< register value for REG operand
		int64_t imm;		///< immediate value for IMM operand
		sysz_op_mem mem;	///< base/disp value for MEM operand
	};
} cs_sysz_op;

// Instruction structure
typedef struct cs_sysz {
	sysz_cc cc;		///< Code condition
	/// Number of operands of this instruction,
	/// or 0 when instruction has no operand.
	uint8_t op_count;
	cs_sysz_op operands[6]; ///< operands for this instruction.
} cs_sysz;

/// SystemZ instruction
typedef enum sysz_insn {
	SYSZ_INS_INVALID = 0,

	SYSZ_INS_A,
	SYSZ_INS_ADB,
	SYSZ_INS_ADBR,
	SYSZ_INS_AEB,
	SYSZ_INS_AEBR,
	SYSZ_INS_AFI,
	SYSZ_INS_AG,
	SYSZ_INS_AGF,
	SYSZ_INS_AGFI,
	SYSZ_INS_AGFR,
	SYSZ_INS_AGHI,
	SYSZ_INS_AGHIK,
	SYSZ_INS_AGR,
	SYSZ_INS_AGRK,
	SYSZ_INS_AGSI,
	SYSZ_INS_AH,
	SYSZ_INS_AHI,
	SYSZ_INS_AHIK,
	SYSZ_INS_AHY,
	SYSZ_INS_AIH,
	SYSZ_INS_AL,
	SYSZ_INS_ALC,
	SYSZ_INS_ALCG,
	SYSZ_INS_ALCGR,
	SYSZ_INS_ALCR,
	SYSZ_INS_ALFI,
	SYSZ_INS_ALG,
	SYSZ_INS_ALGF,
	SYSZ_INS_ALGFI,
	SYSZ_INS_ALGFR,
	SYSZ_INS_ALGHSIK,
	SYSZ_INS_ALGR,
	SYSZ_INS_ALGRK,
	SYSZ_INS_ALHSIK,
	SYSZ_INS_ALR,
	SYSZ_INS_ALRK,
	SYSZ_INS_ALY,
	SYSZ_INS_AR,
	SYSZ_INS_ARK,
	SYSZ_INS_ASI,
	SYSZ_INS_AXBR,
	SYSZ_INS_AY,
	SYSZ_INS_BCR,
	SYSZ_INS_BRC,
	SYSZ_INS_BRCL,
	SYSZ_INS_CGIJ,
	SYSZ_INS_CGRJ,
	SYSZ_INS_CIJ,
	SYSZ_INS_CLGIJ,
	SYSZ_INS_CLGRJ,
	SYSZ_INS_CLIJ,
	SYSZ_INS_CLRJ,
	SYSZ_INS_CRJ,
	SYSZ_INS_BER,
	SYSZ_INS_JE,
	SYSZ_INS_JGE,
	SYSZ_INS_LOCE,
	SYSZ_INS_LOCGE,
	SYSZ_INS_LOCGRE,
	SYSZ_INS_LOCRE,
	SYSZ_INS_STOCE,
	SYSZ_INS_STOCGE,
	SYSZ_INS_BHR,
	SYSZ_INS_BHER,
	SYSZ_INS_JHE,
	SYSZ_INS_JGHE,
	SYSZ_INS_LOCHE,
	SYSZ_INS_LOCGHE,
	SYSZ_INS_LOCGRHE,
	SYSZ_INS_LOCRHE,
	SYSZ_INS_STOCHE,
	SYSZ_INS_STOCGHE,
	SYSZ_INS_JH,
	SYSZ_INS_JGH,
	SYSZ_INS_LOCH,
	SYSZ_INS_LOCGH,
	SYSZ_INS_LOCGRH,
	SYSZ_INS_LOCRH,
	SYSZ_INS_STOCH,
	SYSZ_INS_STOCGH,
	SYSZ_INS_CGIJNLH,
	SYSZ_INS_CGRJNLH,
	SYSZ_INS_CIJNLH,
	SYSZ_INS_CLGIJNLH,
	SYSZ_INS_CLGRJNLH,
	SYSZ_INS_CLIJNLH,
	SYSZ_INS_CLRJNLH,
	SYSZ_INS_CRJNLH,
	SYSZ_INS_CGIJE,
	SYSZ_INS_CGRJE,
	SYSZ_INS_CIJE,
	SYSZ_INS_CLGIJE,
	SYSZ_INS_CLGRJE,
	SYSZ_INS_CLIJE,
	SYSZ_INS_CLRJE,
	SYSZ_INS_CRJE,
	SYSZ_INS_CGIJNLE,
	SYSZ_INS_CGRJNLE,
	SYSZ_INS_CIJNLE,
	SYSZ_INS_CLGIJNLE,
	SYSZ_INS_CLGRJNLE,
	SYSZ_INS_CLIJNLE,
	SYSZ_INS_CLRJNLE,
	SYSZ_INS_CRJNLE,
	SYSZ_INS_CGIJH,
	SYSZ_INS_CGRJH,
	SYSZ_INS_CIJH,
	SYSZ_INS_CLGIJH,
	SYSZ_INS_CLGRJH,
	SYSZ_INS_CLIJH,
	SYSZ_INS_CLRJH,
	SYSZ_INS_CRJH,
	SYSZ_INS_CGIJNL,
	SYSZ_INS_CGRJNL,
	SYSZ_INS_CIJNL,
	SYSZ_INS_CLGIJNL,
	SYSZ_INS_CLGRJNL,
	SYSZ_INS_CLIJNL,
	SYSZ_INS_CLRJNL,
	SYSZ_INS_CRJNL,
	SYSZ_INS_CGIJHE,
	SYSZ_INS_CGRJHE,
	SYSZ_INS_CIJHE,
	SYSZ_INS_CLGIJHE,
	SYSZ_INS_CLGRJHE,
	SYSZ_INS_CLIJHE,
	SYSZ_INS_CLRJHE,
	SYSZ_INS_CRJHE,
	SYSZ_INS_CGIJNHE,
	SYSZ_INS_CGRJNHE,
	SYSZ_INS_CIJNHE,
	SYSZ_INS_CLGIJNHE,
	SYSZ_INS_CLGRJNHE,
	SYSZ_INS_CLIJNHE,
	SYSZ_INS_CLRJNHE,
	SYSZ_INS_CRJNHE,
	SYSZ_INS_CGIJL,
	SYSZ_INS_CGRJL,
	SYSZ_INS_CIJL,
	SYSZ_INS_CLGIJL,
	SYSZ_INS_CLGRJL,
	SYSZ_INS_CLIJL,
	SYSZ_INS_CLRJL,
	SYSZ_INS_CRJL,
	SYSZ_INS_CGIJNH,
	SYSZ_INS_CGRJNH,
	SYSZ_INS_CIJNH,
	SYSZ_INS_CLGIJNH,
	SYSZ_INS_CLGRJNH,
	SYSZ_INS_CLIJNH,
	SYSZ_INS_CLRJNH,
	SYSZ_INS_CRJNH,
	SYSZ_INS_CGIJLE,
	SYSZ_INS_CGRJLE,
	SYSZ_INS_CIJLE,
	SYSZ_INS_CLGIJLE,
	SYSZ_INS_CLGRJLE,
	SYSZ_INS_CLIJLE,
	SYSZ_INS_CLRJLE,
	SYSZ_INS_CRJLE,
	SYSZ_INS_CGIJNE,
	SYSZ_INS_CGRJNE,
	SYSZ_INS_CIJNE,
	SYSZ_INS_CLGIJNE,
	SYSZ_INS_CLGRJNE,
	SYSZ_INS_CLIJNE,
	SYSZ_INS_CLRJNE,
	SYSZ_INS_CRJNE,
	SYSZ_INS_CGIJLH,
	SYSZ_INS_CGRJLH,
	SYSZ_INS_CIJLH,
	SYSZ_INS_CLGIJLH,
	SYSZ_INS_CLGRJLH,
	SYSZ_INS_CLIJLH,
	SYSZ_INS_CLRJLH,
	SYSZ_INS_CRJLH,
	SYSZ_INS_BLR,
	SYSZ_INS_BLER,
	SYSZ_INS_JLE,
	SYSZ_INS_JGLE,
	SYSZ_INS_LOCLE,
	SYSZ_INS_LOCGLE,
	SYSZ_INS_LOCGRLE,
	SYSZ_INS_LOCRLE,
	SYSZ_INS_STOCLE,
	SYSZ_INS_STOCGLE,
	SYSZ_INS_BLHR,
	SYSZ_INS_JLH,
	SYSZ_INS_JGLH,
	SYSZ_INS_LOCLH,
	SYSZ_INS_LOCGLH,
	SYSZ_INS_LOCGRLH,
	SYSZ_INS_LOCRLH,
	SYSZ_INS_STOCLH,
	SYSZ_INS_STOCGLH,
	SYSZ_INS_JL,
	SYSZ_INS_JGL,
	SYSZ_INS_LOCL,
	SYSZ_INS_LOCGL,
	SYSZ_INS_LOCGRL,
	SYSZ_INS_LOCRL,
	SYSZ_INS_LOC,
	SYSZ_INS_LOCG,
	SYSZ_INS_LOCGR,
	SYSZ_INS_LOCR,
	SYSZ_INS_STOCL,
	SYSZ_INS_STOCGL,
	SYSZ_INS_BNER,
	SYSZ_INS_JNE,
	SYSZ_INS_JGNE,
	SYSZ_INS_LOCNE,
	SYSZ_INS_LOCGNE,
	SYSZ_INS_LOCGRNE,
	SYSZ_INS_LOCRNE,
	SYSZ_INS_STOCNE,
	SYSZ_INS_STOCGNE,
	SYSZ_INS_BNHR,
	SYSZ_INS_BNHER,
	SYSZ_INS_JNHE,
	SYSZ_INS_JGNHE,
	SYSZ_INS_LOCNHE,
	SYSZ_INS_LOCGNHE,
	SYSZ_INS_LOCGRNHE,
	SYSZ_INS_LOCRNHE,
	SYSZ_INS_STOCNHE,
	SYSZ_INS_STOCGNHE,
	SYSZ_INS_JNH,
	SYSZ_INS_JGNH,
	SYSZ_INS_LOCNH,
	SYSZ_INS_LOCGNH,
	SYSZ_INS_LOCGRNH,
	SYSZ_INS_LOCRNH,
	SYSZ_INS_STOCNH,
	SYSZ_INS_STOCGNH,
	SYSZ_INS_BNLR,
	SYSZ_INS_BNLER,
	SYSZ_INS_JNLE,
	SYSZ_INS_JGNLE,
	SYSZ_INS_LOCNLE,
	SYSZ_INS_LOCGNLE,
	SYSZ_INS_LOCGRNLE,
	SYSZ_INS_LOCRNLE,
	SYSZ_INS_STOCNLE,
	SYSZ_INS_STOCGNLE,
	SYSZ_INS_BNLHR,
	SYSZ_INS_JNLH,
	SYSZ_INS_JGNLH,
	SYSZ_INS_LOCNLH,
	SYSZ_INS_LOCGNLH,
	SYSZ_INS_LOCGRNLH,
	SYSZ_INS_LOCRNLH,
	SYSZ_INS_STOCNLH,
	SYSZ_INS_STOCGNLH,
	SYSZ_INS_JNL,
	SYSZ_INS_JGNL,
	SYSZ_INS_LOCNL,
	SYSZ_INS_LOCGNL,
	SYSZ_INS_LOCGRNL,
	SYSZ_INS_LOCRNL,
	SYSZ_INS_STOCNL,
	SYSZ_INS_STOCGNL,
	SYSZ_INS_BNOR,
	SYSZ_INS_JNO,
	SYSZ_INS_JGNO,
	SYSZ_INS_LOCNO,
	SYSZ_INS_LOCGNO,
	SYSZ_INS_LOCGRNO,
	SYSZ_INS_LOCRNO,
	SYSZ_INS_STOCNO,
	SYSZ_INS_STOCGNO,
	SYSZ_INS_BOR,
	SYSZ_INS_JO,
	SYSZ_INS_JGO,
	SYSZ_INS_LOCO,
	SYSZ_INS_LOCGO,
	SYSZ_INS_LOCGRO,
	SYSZ_INS_LOCRO,
	SYSZ_INS_STOCO,
	SYSZ_INS_STOCGO,
	SYSZ_INS_STOC,
	SYSZ_INS_STOCG,
	SYSZ_INS_BASR,
	SYSZ_INS_BR,
	SYSZ_INS_BRAS,
	SYSZ_INS_BRASL,
	SYSZ_INS_J,
	SYSZ_INS_JG,
	SYSZ_INS_BRCT,
	SYSZ_INS_BRCTG,
	SYSZ_INS_C,
	SYSZ_INS_CDB,
	SYSZ_INS_CDBR,
	SYSZ_INS_CDFBR,
	SYSZ_INS_CDGBR,
	SYSZ_INS_CDLFBR,
	SYSZ_INS_CDLGBR,
	SYSZ_INS_CEB,
	SYSZ_INS_CEBR,
	SYSZ_INS_CEFBR,
	SYSZ_INS_CEGBR,
	SYSZ_INS_CELFBR,
	SYSZ_INS_CELGBR,
	SYSZ_INS_CFDBR,
	SYSZ_INS_CFEBR,
	SYSZ_INS_CFI,
	SYSZ_INS_CFXBR,
	SYSZ_INS_CG,
	SYSZ_INS_CGDBR,
	SYSZ_INS_CGEBR,
	SYSZ_INS_CGF,
	SYSZ_INS_CGFI,
	SYSZ_INS_CGFR,
	SYSZ_INS_CGFRL,
	SYSZ_INS_CGH,
	SYSZ_INS_CGHI,
	SYSZ_INS_CGHRL,
	SYSZ_INS_CGHSI,
	SYSZ_INS_CGR,
	SYSZ_INS_CGRL,
	SYSZ_INS_CGXBR,
	SYSZ_INS_CH,
	SYSZ_INS_CHF,
	SYSZ_INS_CHHSI,
	SYSZ_INS_CHI,
	SYSZ_INS_CHRL,
	SYSZ_INS_CHSI,
	SYSZ_INS_CHY,
	SYSZ_INS_CIH,
	SYSZ_INS_CL,
	SYSZ_INS_CLC,
	SYSZ_INS_CLFDBR,
	SYSZ_INS_CLFEBR,
	SYSZ_INS_CLFHSI,
	SYSZ_INS_CLFI,
	SYSZ_INS_CLFXBR,
	SYSZ_INS_CLG,
	SYSZ_INS_CLGDBR,
	SYSZ_INS_CLGEBR,
	SYSZ_INS_CLGF,
	SYSZ_INS_CLGFI,
	SYSZ_INS_CLGFR,
	SYSZ_INS_CLGFRL,
	SYSZ_INS_CLGHRL,
	SYSZ_INS_CLGHSI,
	SYSZ_INS_CLGR,
	SYSZ_INS_CLGRL,
	SYSZ_INS_CLGXBR,
	SYSZ_INS_CLHF,
	SYSZ_INS_CLHHSI,
	SYSZ_INS_CLHRL,
	SYSZ_INS_CLI,
	SYSZ_INS_CLIH,
	SYSZ_INS_CLIY,
	SYSZ_INS_CLR,
	SYSZ_INS_CLRL,
	SYSZ_INS_CLST,
	SYSZ_INS_CLY,
	SYSZ_INS_CPSDR,
	SYSZ_INS_CR,
	SYSZ_INS_CRL,
	SYSZ_INS_CS,
	SYSZ_INS_CSG,
	SYSZ_INS_CSY,
	SYSZ_INS_CXBR,
	SYSZ_INS_CXFBR,
	SYSZ_INS_CXGBR,
	SYSZ_INS_CXLFBR,
	SYSZ_INS_CXLGBR,
	SYSZ_INS_CY,
	SYSZ_INS_DDB,
	SYSZ_INS_DDBR,
	SYSZ_INS_DEB,
	SYSZ_INS_DEBR,
	SYSZ_INS_DL,
	SYSZ_INS_DLG,
	SYSZ_INS_DLGR,
	SYSZ_INS_DLR,
	SYSZ_INS_DSG,
	SYSZ_INS_DSGF,
	SYSZ_INS_DSGFR,
	SYSZ_INS_DSGR,
	SYSZ_INS_DXBR,
	SYSZ_INS_EAR,
	SYSZ_INS_FIDBR,
	SYSZ_INS_FIDBRA,
	SYSZ_INS_FIEBR,
	SYSZ_INS_FIEBRA,
	SYSZ_INS_FIXBR,
	SYSZ_INS_FIXBRA,
	SYSZ_INS_FLOGR,
	SYSZ_INS_IC,
	SYSZ_INS_ICY,
	SYSZ_INS_IIHF,
	SYSZ_INS_IIHH,
	SYSZ_INS_IIHL,
	SYSZ_INS_IILF,
	SYSZ_INS_IILH,
	SYSZ_INS_IILL,
	SYSZ_INS_IPM,
	SYSZ_INS_L,
	SYSZ_INS_LA,
	SYSZ_INS_LAA,
	SYSZ_INS_LAAG,
	SYSZ_INS_LAAL,
	SYSZ_INS_LAALG,
	SYSZ_INS_LAN,
	SYSZ_INS_LANG,
	SYSZ_INS_LAO,
	SYSZ_INS_LAOG,
	SYSZ_INS_LARL,
	SYSZ_INS_LAX,
	SYSZ_INS_LAXG,
	SYSZ_INS_LAY,
	SYSZ_INS_LB,
	SYSZ_INS_LBH,
	SYSZ_INS_LBR,
	SYSZ_INS_LCDBR,
	SYSZ_INS_LCEBR,
	SYSZ_INS_LCGFR,
	SYSZ_INS_LCGR,
	SYSZ_INS_LCR,
	SYSZ_INS_LCXBR,
	SYSZ_INS_LD,
	SYSZ_INS_LDEB,
	SYSZ_INS_LDEBR,
	SYSZ_INS_LDGR,
	SYSZ_INS_LDR,
	SYSZ_INS_LDXBR,
	SYSZ_INS_LDXBRA,
	SYSZ_INS_LDY,
	SYSZ_INS_LE,
	SYSZ_INS_LEDBR,
	SYSZ_INS_LEDBRA,
	SYSZ_INS_LER,
	SYSZ_INS_LEXBR,
	SYSZ_INS_LEXBRA,
	SYSZ_INS_LEY,
	SYSZ_INS_LFH,
	SYSZ_INS_LG,
	SYSZ_INS_LGB,
	SYSZ_INS_LGBR,
	SYSZ_INS_LGDR,
	SYSZ_INS_LGF,
	SYSZ_INS_LGFI,
	SYSZ_INS_LGFR,
	SYSZ_INS_LGFRL,
	SYSZ_INS_LGH,
	SYSZ_INS_LGHI,
	SYSZ_INS_LGHR,
	SYSZ_INS_LGHRL,
	SYSZ_INS_LGR,
	SYSZ_INS_LGRL,
	SYSZ_INS_LH,
	SYSZ_INS_LHH,
	SYSZ_INS_LHI,
	SYSZ_INS_LHR,
	SYSZ_INS_LHRL,
	SYSZ_INS_LHY,
	SYSZ_INS_LLC,
	SYSZ_INS_LLCH,
	SYSZ_INS_LLCR,
	SYSZ_INS_LLGC,
	SYSZ_INS_LLGCR,
	SYSZ_INS_LLGF,
	SYSZ_INS_LLGFR,
	SYSZ_INS_LLGFRL,
	SYSZ_INS_LLGH,
	SYSZ_INS_LLGHR,
	SYSZ_INS_LLGHRL,
	SYSZ_INS_LLH,
	SYSZ_INS_LLHH,
	SYSZ_INS_LLHR,
	SYSZ_INS_LLHRL,
	SYSZ_INS_LLIHF,
	SYSZ_INS_LLIHH,
	SYSZ_INS_LLIHL,
	SYSZ_INS_LLILF,
	SYSZ_INS_LLILH,
	SYSZ_INS_LLILL,
	SYSZ_INS_LMG,
	SYSZ_INS_LNDBR,
	SYSZ_INS_LNEBR,
	SYSZ_INS_LNGFR,
	SYSZ_INS_LNGR,
	SYSZ_INS_LNR,
	SYSZ_INS_LNXBR,
	SYSZ_INS_LPDBR,
	SYSZ_INS_LPEBR,
	SYSZ_INS_LPGFR,
	SYSZ_INS_LPGR,
	SYSZ_INS_LPR,
	SYSZ_INS_LPXBR,
	SYSZ_INS_LR,
	SYSZ_INS_LRL,
	SYSZ_INS_LRV,
	SYSZ_INS_LRVG,
	SYSZ_INS_LRVGR,
	SYSZ_INS_LRVR,
	SYSZ_INS_LT,
	SYSZ_INS_LTDBR,
	SYSZ_INS_LTEBR,
	SYSZ_INS_LTG,
	SYSZ_INS_LTGF,
	SYSZ_INS_LTGFR,
	SYSZ_INS_LTGR,
	SYSZ_INS_LTR,
	SYSZ_INS_LTXBR,
	SYSZ_INS_LXDB,
	SYSZ_INS_LXDBR,
	SYSZ_INS_LXEB,
	SYSZ_INS_LXEBR,
	SYSZ_INS_LXR,
	SYSZ_INS_LY,
	SYSZ_INS_LZDR,
	SYSZ_INS_LZER,
	SYSZ_INS_LZXR,
	SYSZ_INS_MADB,
	SYSZ_INS_MADBR,
	SYSZ_INS_MAEB,
	SYSZ_INS_MAEBR,
	SYSZ_INS_MDB,
	SYSZ_INS_MDBR,
	SYSZ_INS_MDEB,
	SYSZ_INS_MDEBR,
	SYSZ_INS_MEEB,
	SYSZ_INS_MEEBR,
	SYSZ_INS_MGHI,
	SYSZ_INS_MH,
	SYSZ_INS_MHI,
	SYSZ_INS_MHY,
	SYSZ_INS_MLG,
	SYSZ_INS_MLGR,
	SYSZ_INS_MS,
	SYSZ_INS_MSDB,
	SYSZ_INS_MSDBR,
	SYSZ_INS_MSEB,
	SYSZ_INS_MSEBR,
	SYSZ_INS_MSFI,
	SYSZ_INS_MSG,
	SYSZ_INS_MSGF,
	SYSZ_INS_MSGFI,
	SYSZ_INS_MSGFR,
	SYSZ_INS_MSGR,
	SYSZ_INS_MSR,
	SYSZ_INS_MSY,
	SYSZ_INS_MVC,
	SYSZ_INS_MVGHI,
	SYSZ_INS_MVHHI,
	SYSZ_INS_MVHI,
	SYSZ_INS_MVI,
	SYSZ_INS_MVIY,
	SYSZ_INS_MVST,
	SYSZ_INS_MXBR,
	SYSZ_INS_MXDB,
	SYSZ_INS_MXDBR,
	SYSZ_INS_N,
	SYSZ_INS_NC,
	SYSZ_INS_NG,
	SYSZ_INS_NGR,
	SYSZ_INS_NGRK,
	SYSZ_INS_NI,
	SYSZ_INS_NIHF,
	SYSZ_INS_NIHH,
	SYSZ_INS_NIHL,
	SYSZ_INS_NILF,
	SYSZ_INS_NILH,
	SYSZ_INS_NILL,
	SYSZ_INS_NIY,
	SYSZ_INS_NR,
	SYSZ_INS_NRK,
	SYSZ_INS_NY,
	SYSZ_INS_O,
	SYSZ_INS_OC,
	SYSZ_INS_OG,
	SYSZ_INS_OGR,
	SYSZ_INS_OGRK,
	SYSZ_INS_OI,
	SYSZ_INS_OIHF,
	SYSZ_INS_OIHH,
	SYSZ_INS_OIHL,
	SYSZ_INS_OILF,
	SYSZ_INS_OILH,
	SYSZ_INS_OILL,
	SYSZ_INS_OIY,
	SYSZ_INS_OR,
	SYSZ_INS_ORK,
	SYSZ_INS_OY,
	SYSZ_INS_PFD,
	SYSZ_INS_PFDRL,
	SYSZ_INS_RISBG,
	SYSZ_INS_RISBHG,
	SYSZ_INS_RISBLG,
	SYSZ_INS_RLL,
	SYSZ_INS_RLLG,
	SYSZ_INS_RNSBG,
	SYSZ_INS_ROSBG,
	SYSZ_INS_RXSBG,
	SYSZ_INS_S,
	SYSZ_INS_SDB,
	SYSZ_INS_SDBR,
	SYSZ_INS_SEB,
	SYSZ_INS_SEBR,
	SYSZ_INS_SG,
	SYSZ_INS_SGF,
	SYSZ_INS_SGFR,
	SYSZ_INS_SGR,
	SYSZ_INS_SGRK,
	SYSZ_INS_SH,
	SYSZ_INS_SHY,
	SYSZ_INS_SL,
	SYSZ_INS_SLB,
	SYSZ_INS_SLBG,
	SYSZ_INS_SLBR,
	SYSZ_INS_SLFI,
	SYSZ_INS_SLG,
	SYSZ_INS_SLBGR,
	SYSZ_INS_SLGF,
	SYSZ_INS_SLGFI,
	SYSZ_INS_SLGFR,
	SYSZ_INS_SLGR,
	SYSZ_INS_SLGRK,
	SYSZ_INS_SLL,
	SYSZ_INS_SLLG,
	SYSZ_INS_SLLK,
	SYSZ_INS_SLR,
	SYSZ_INS_SLRK,
	SYSZ_INS_SLY,
	SYSZ_INS_SQDB,
	SYSZ_INS_SQDBR,
	SYSZ_INS_SQEB,
	SYSZ_INS_SQEBR,
	SYSZ_INS_SQXBR,
	SYSZ_INS_SR,
	SYSZ_INS_SRA,
	SYSZ_INS_SRAG,
	SYSZ_INS_SRAK,
	SYSZ_INS_SRK,
	SYSZ_INS_SRL,
	SYSZ_INS_SRLG,
	SYSZ_INS_SRLK,
	SYSZ_INS_SRST,
	SYSZ_INS_ST,
	SYSZ_INS_STC,
	SYSZ_INS_STCH,
	SYSZ_INS_STCY,
	SYSZ_INS_STD,
	SYSZ_INS_STDY,
	SYSZ_INS_STE,
	SYSZ_INS_STEY,
	SYSZ_INS_STFH,
	SYSZ_INS_STG,
	SYSZ_INS_STGRL,
	SYSZ_INS_STH,
	SYSZ_INS_STHH,
	SYSZ_INS_STHRL,
	SYSZ_INS_STHY,
	SYSZ_INS_STMG,
	SYSZ_INS_STRL,
	SYSZ_INS_STRV,
	SYSZ_INS_STRVG,
	SYSZ_INS_STY,
	SYSZ_INS_SXBR,
	SYSZ_INS_SY,
	SYSZ_INS_TM,
	SYSZ_INS_TMHH,
	SYSZ_INS_TMHL,
	SYSZ_INS_TMLH,
	SYSZ_INS_TMLL,
	SYSZ_INS_TMY,
	SYSZ_INS_X,
	SYSZ_INS_XC,
	SYSZ_INS_XG,
	SYSZ_INS_XGR,
	SYSZ_INS_XGRK,
	SYSZ_INS_XI,
	SYSZ_INS_XIHF,
	SYSZ_INS_XILF,
	SYSZ_INS_XIY,
	SYSZ_INS_XR,
	SYSZ_INS_XRK,
	SYSZ_INS_XY,
	SYSZ_INS_AD,
	SYSZ_INS_ADR,
	SYSZ_INS_ADTR,
	SYSZ_INS_ADTRA,
	SYSZ_INS_AE,
	SYSZ_INS_AER,
	SYSZ_INS_AGH,
	SYSZ_INS_AHHHR,
	SYSZ_INS_AHHLR,
	SYSZ_INS_ALGSI,
	SYSZ_INS_ALHHHR,
	SYSZ_INS_ALHHLR,
	SYSZ_INS_ALSI,
	SYSZ_INS_ALSIH,
	SYSZ_INS_ALSIHN,
	SYSZ_INS_AP,
	SYSZ_INS_AU,
	SYSZ_INS_AUR,
	SYSZ_INS_AW,
	SYSZ_INS_AWR,
	SYSZ_INS_AXR,
	SYSZ_INS_AXTR,
	SYSZ_INS_AXTRA,
	SYSZ_INS_B,
	SYSZ_INS_BAKR,
	SYSZ_INS_BAL,
	SYSZ_INS_BALR,
	SYSZ_INS_BAS,
	SYSZ_INS_BASSM,
	SYSZ_INS_BC,
	SYSZ_INS_BCT,
	SYSZ_INS_BCTG,
	SYSZ_INS_BCTGR,
	SYSZ_INS_BCTR,
	SYSZ_INS_BE,
	SYSZ_INS_BH,
	SYSZ_INS_BHE,
	SYSZ_INS_BI,
	SYSZ_INS_BIC,
	SYSZ_INS_BIE,
	SYSZ_INS_BIH,
	SYSZ_INS_BIHE,
	SYSZ_INS_BIL,
	SYSZ_INS_BILE,
	SYSZ_INS_BILH,
	SYSZ_INS_BIM,
	SYSZ_INS_BINE,
	SYSZ_INS_BINH,
	SYSZ_INS_BINHE,
	SYSZ_INS_BINL,
	SYSZ_INS_BINLE,
	SYSZ_INS_BINLH,
	SYSZ_INS_BINM,
	SYSZ_INS_BINO,
	SYSZ_INS_BINP,
	SYSZ_INS_BINZ,
	SYSZ_INS_BIO,
	SYSZ_INS_BIP,
	SYSZ_INS_BIZ,
	SYSZ_INS_BL,
	SYSZ_INS_BLE,
	SYSZ_INS_BLH,
	SYSZ_INS_BM,
	SYSZ_INS_BMR,
	SYSZ_INS_BNE,
	SYSZ_INS_BNH,
	SYSZ_INS_BNHE,
	SYSZ_INS_BNL,
	SYSZ_INS_BNLE,
	SYSZ_INS_BNLH,
	SYSZ_INS_BNM,
	SYSZ_INS_BNMR,
	SYSZ_INS_BNO,
	SYSZ_INS_BNP,
	SYSZ_INS_BNPR,
	SYSZ_INS_BNZ,
	SYSZ_INS_BNZR,
	SYSZ_INS_BO,
	SYSZ_INS_BP,
	SYSZ_INS_BPP,
	SYSZ_INS_BPR,
	SYSZ_INS_BPRP,
	SYSZ_INS_BRCTH,
	SYSZ_INS_BRXH,
	SYSZ_INS_BRXHG,
	SYSZ_INS_BRXLE,
	SYSZ_INS_BRXLG,
	SYSZ_INS_BSA,
	SYSZ_INS_BSG,
	SYSZ_INS_BSM,
	SYSZ_INS_BXH,
	SYSZ_INS_BXHG,
	SYSZ_INS_BXLE,
	SYSZ_INS_BXLEG,
	SYSZ_INS_BZ,
	SYSZ_INS_BZR,
	SYSZ_INS_CD,
	SYSZ_INS_CDFBRA,
	SYSZ_INS_CDFR,
	SYSZ_INS_CDFTR,
	SYSZ_INS_CDGBRA,
	SYSZ_INS_CDGR,
	SYSZ_INS_CDGTR,
	SYSZ_INS_CDGTRA,
	SYSZ_INS_CDLFTR,
	SYSZ_INS_CDLGTR,
	SYSZ_INS_CDPT,
	SYSZ_INS_CDR,
	SYSZ_INS_CDS,
	SYSZ_INS_CDSG,
	SYSZ_INS_CDSTR,
	SYSZ_INS_CDSY,
	SYSZ_INS_CDTR,
	SYSZ_INS_CDUTR,
	SYSZ_INS_CDZT,
	SYSZ_INS_CE,
	SYSZ_INS_CEDTR,
	SYSZ_INS_CEFBRA,
	SYSZ_INS_CEFR,
	SYSZ_INS_CEGBRA,
	SYSZ_INS_CEGR,
	SYSZ_INS_CER,
	SYSZ_INS_CEXTR,
	SYSZ_INS_CFC,
	SYSZ_INS_CFDBRA,
	SYSZ_INS_CFDR,
	SYSZ_INS_CFDTR,
	SYSZ_INS_CFEBRA,
	SYSZ_INS_CFER,
	SYSZ_INS_CFXBRA,
	SYSZ_INS_CFXR,
	SYSZ_INS_CFXTR,
	SYSZ_INS_CGDBRA,
	SYSZ_INS_CGDR,
	SYSZ_INS_CGDTR,
	SYSZ_INS_CGDTRA,
	SYSZ_INS_CGEBRA,
	SYSZ_INS_CGER,
	SYSZ_INS_CGIB,
	SYSZ_INS_CGIBE,
	SYSZ_INS_CGIBH,
	SYSZ_INS_CGIBHE,
	SYSZ_INS_CGIBL,
	SYSZ_INS_CGIBLE,
	SYSZ_INS_CGIBLH,
	SYSZ_INS_CGIBNE,
	SYSZ_INS_CGIBNH,
	SYSZ_INS_CGIBNHE,
	SYSZ_INS_CGIBNL,
	SYSZ_INS_CGIBNLE,
	SYSZ_INS_CGIBNLH,
	SYSZ_INS_CGIT,
	SYSZ_INS_CGITE,
	SYSZ_INS_CGITH,
	SYSZ_INS_CGITHE,
	SYSZ_INS_CGITL,
	SYSZ_INS_CGITLE,
	SYSZ_INS_CGITLH,
	SYSZ_INS_CGITNE,
	SYSZ_INS_CGITNH,
	SYSZ_INS_CGITNHE,
	SYSZ_INS_CGITNL,
	SYSZ_INS_CGITNLE,
	SYSZ_INS_CGITNLH,
	SYSZ_INS_CGRB,
	SYSZ_INS_CGRBE,
	SYSZ_INS_CGRBH,
	SYSZ_INS_CGRBHE,
	SYSZ_INS_CGRBL,
	SYSZ_INS_CGRBLE,
	SYSZ_INS_CGRBLH,
	SYSZ_INS_CGRBNE,
	SYSZ_INS_CGRBNH,
	SYSZ_INS_CGRBNHE,
	SYSZ_INS_CGRBNL,
	SYSZ_INS_CGRBNLE,
	SYSZ_INS_CGRBNLH,
	SYSZ_INS_CGRT,
	SYSZ_INS_CGRTE,
	SYSZ_INS_CGRTH,
	SYSZ_INS_CGRTHE,
	SYSZ_INS_CGRTL,
	SYSZ_INS_CGRTLE,
	SYSZ_INS_CGRTLH,
	SYSZ_INS_CGRTNE,
	SYSZ_INS_CGRTNH,
	SYSZ_INS_CGRTNHE,
	SYSZ_INS_CGRTNL,
	SYSZ_INS_CGRTNLE,
	SYSZ_INS_CGRTNLH,
	SYSZ_INS_CGXBRA,
	SYSZ_INS_CGXR,
	SYSZ_INS_CGXTR,
	SYSZ_INS_CGXTRA,
	SYSZ_INS_CHHR,
	SYSZ_INS_CHLR,
	SYSZ_INS_CIB,
	SYSZ_INS_CIBE,
	SYSZ_INS_CIBH,
	SYSZ_INS_CIBHE,
	SYSZ_INS_CIBL,
	SYSZ_INS_CIBLE,
	SYSZ_INS_CIBLH,
	SYSZ_INS_CIBNE,
	SYSZ_INS_CIBNH,
	SYSZ_INS_CIBNHE,
	SYSZ_INS_CIBNL,
	SYSZ_INS_CIBNLE,
	SYSZ_INS_CIBNLH,
	SYSZ_INS_CIT,
	SYSZ_INS_CITE,
	SYSZ_INS_CITH,
	SYSZ_INS_CITHE,
	SYSZ_INS_CITL,
	SYSZ_INS_CITLE,
	SYSZ_INS_CITLH,
	SYSZ_INS_CITNE,
	SYSZ_INS_CITNH,
	SYSZ_INS_CITNHE,
	SYSZ_INS_CITNL,
	SYSZ_INS_CITNLE,
	SYSZ_INS_CITNLH,
	SYSZ_INS_CKSM,
	SYSZ_INS_CLCL,
	SYSZ_INS_CLCLE,
	SYSZ_INS_CLCLU,
	SYSZ_INS_CLFDTR,
	SYSZ_INS_CLFIT,
	SYSZ_INS_CLFITE,
	SYSZ_INS_CLFITH,
	SYSZ_INS_CLFITHE,
	SYSZ_INS_CLFITL,
	SYSZ_INS_CLFITLE,
	SYSZ_INS_CLFITLH,
	SYSZ_INS_CLFITNE,
	SYSZ_INS_CLFITNH,
	SYSZ_INS_CLFITNHE,
	SYSZ_INS_CLFITNL,
	SYSZ_INS_CLFITNLE,
	SYSZ_INS_CLFITNLH,
	SYSZ_INS_CLFXTR,
	SYSZ_INS_CLGDTR,
	SYSZ_INS_CLGIB,
	SYSZ_INS_CLGIBE,
	SYSZ_INS_CLGIBH,
	SYSZ_INS_CLGIBHE,
	SYSZ_INS_CLGIBL,
	SYSZ_INS_CLGIBLE,
	SYSZ_INS_CLGIBLH,
	SYSZ_INS_CLGIBNE,
	SYSZ_INS_CLGIBNH,
	SYSZ_INS_CLGIBNHE,
	SYSZ_INS_CLGIBNL,
	SYSZ_INS_CLGIBNLE,
	SYSZ_INS_CLGIBNLH,
	SYSZ_INS_CLGIT,
	SYSZ_INS_CLGITE,
	SYSZ_INS_CLGITH,
	SYSZ_INS_CLGITHE,
	SYSZ_INS_CLGITL,
	SYSZ_INS_CLGITLE,
	SYSZ_INS_CLGITLH,
	SYSZ_INS_CLGITNE,
	SYSZ_INS_CLGITNH,
	SYSZ_INS_CLGITNHE,
	SYSZ_INS_CLGITNL,
	SYSZ_INS_CLGITNLE,
	SYSZ_INS_CLGITNLH,
	SYSZ_INS_CLGRB,
	SYSZ_INS_CLGRBE,
	SYSZ_INS_CLGRBH,
	SYSZ_INS_CLGRBHE,
	SYSZ_INS_CLGRBL,
	SYSZ_INS_CLGRBLE,
	SYSZ_INS_CLGRBLH,
	SYSZ_INS_CLGRBNE,
	SYSZ_INS_CLGRBNH,
	SYSZ_INS_CLGRBNHE,
	SYSZ_INS_CLGRBNL,
	SYSZ_INS_CLGRBNLE,
	SYSZ_INS_CLGRBNLH,
	SYSZ_INS_CLGRT,
	SYSZ_INS_CLGRTE,
	SYSZ_INS_CLGRTH,
	SYSZ_INS_CLGRTHE,
	SYSZ_INS_CLGRTL,
	SYSZ_INS_CLGRTLE,
	SYSZ_INS_CLGRTLH,
	SYSZ_INS_CLGRTNE,
	SYSZ_INS_CLGRTNH,
	SYSZ_INS_CLGRTNHE,
	SYSZ_INS_CLGRTNL,
	SYSZ_INS_CLGRTNLE,
	SYSZ_INS_CLGRTNLH,
	SYSZ_INS_CLGT,
	SYSZ_INS_CLGTE,
	SYSZ_INS_CLGTH,
	SYSZ_INS_CLGTHE,
	SYSZ_INS_CLGTL,
	SYSZ_INS_CLGTLE,
	SYSZ_INS_CLGTLH,
	SYSZ_INS_CLGTNE,
	SYSZ_INS_CLGTNH,
	SYSZ_INS_CLGTNHE,
	SYSZ_INS_CLGTNL,
	SYSZ_INS_CLGTNLE,
	SYSZ_INS_CLGTNLH,
	SYSZ_INS_CLGXTR,
	SYSZ_INS_CLHHR,
	SYSZ_INS_CLHLR,
	SYSZ_INS_CLIB,
	SYSZ_INS_CLIBE,
	SYSZ_INS_CLIBH,
	SYSZ_INS_CLIBHE,
	SYSZ_INS_CLIBL,
	SYSZ_INS_CLIBLE,
	SYSZ_INS_CLIBLH,
	SYSZ_INS_CLIBNE,
	SYSZ_INS_CLIBNH,
	SYSZ_INS_CLIBNHE,
	SYSZ_INS_CLIBNL,
	SYSZ_INS_CLIBNLE,
	SYSZ_INS_CLIBNLH,
	SYSZ_INS_CLM,
	SYSZ_INS_CLMH,
	SYSZ_INS_CLMY,
	SYSZ_INS_CLRB,
	SYSZ_INS_CLRBE,
	SYSZ_INS_CLRBH,
	SYSZ_INS_CLRBHE,
	SYSZ_INS_CLRBL,
	SYSZ_INS_CLRBLE,
	SYSZ_INS_CLRBLH,
	SYSZ_INS_CLRBNE,
	SYSZ_INS_CLRBNH,
	SYSZ_INS_CLRBNHE,
	SYSZ_INS_CLRBNL,
	SYSZ_INS_CLRBNLE,
	SYSZ_INS_CLRBNLH,
	SYSZ_INS_CLRT,
	SYSZ_INS_CLRTE,
	SYSZ_INS_CLRTH,
	SYSZ_INS_CLRTHE,
	SYSZ_INS_CLRTL,
	SYSZ_INS_CLRTLE,
	SYSZ_INS_CLRTLH,
	SYSZ_INS_CLRTNE,
	SYSZ_INS_CLRTNH,
	SYSZ_INS_CLRTNHE,
	SYSZ_INS_CLRTNL,
	SYSZ_INS_CLRTNLE,
	SYSZ_INS_CLRTNLH,
	SYSZ_INS_CLT,
	SYSZ_INS_CLTE,
	SYSZ_INS_CLTH,
	SYSZ_INS_CLTHE,
	SYSZ_INS_CLTL,
	SYSZ_INS_CLTLE,
	SYSZ_INS_CLTLH,
	SYSZ_INS_CLTNE,
	SYSZ_INS_CLTNH,
	SYSZ_INS_CLTNHE,
	SYSZ_INS_CLTNL,
	SYSZ_INS_CLTNLE,
	SYSZ_INS_CLTNLH,
	SYSZ_INS_CMPSC,
	SYSZ_INS_CP,
	SYSZ_INS_CPDT,
	SYSZ_INS_CPXT,
	SYSZ_INS_CPYA,
	SYSZ_INS_CRB,
	SYSZ_INS_CRBE,
	SYSZ_INS_CRBH,
	SYSZ_INS_CRBHE,
	SYSZ_INS_CRBL,
	SYSZ_INS_CRBLE,
	SYSZ_INS_CRBLH,
	SYSZ_INS_CRBNE,
	SYSZ_INS_CRBNH,
	SYSZ_INS_CRBNHE,
	SYSZ_INS_CRBNL,
	SYSZ_INS_CRBNLE,
	SYSZ_INS_CRBNLH,
	SYSZ_INS_CRDTE,
	SYSZ_INS_CRT,
	SYSZ_INS_CRTE,
	SYSZ_INS_CRTH,
	SYSZ_INS_CRTHE,
	SYSZ_INS_CRTL,
	SYSZ_INS_CRTLE,
	SYSZ_INS_CRTLH,
	SYSZ_INS_CRTNE,
	SYSZ_INS_CRTNH,
	SYSZ_INS_CRTNHE,
	SYSZ_INS_CRTNL,
	SYSZ_INS_CRTNLE,
	SYSZ_INS_CRTNLH,
	SYSZ_INS_CSCH,
	SYSZ_INS_CSDTR,
	SYSZ_INS_CSP,
	SYSZ_INS_CSPG,
	SYSZ_INS_CSST,
	SYSZ_INS_CSXTR,
	SYSZ_INS_CU12,
	SYSZ_INS_CU14,
	SYSZ_INS_CU21,
	SYSZ_INS_CU24,
	SYSZ_INS_CU41,
	SYSZ_INS_CU42,
	SYSZ_INS_CUDTR,
	SYSZ_INS_CUSE,
	SYSZ_INS_CUTFU,
	SYSZ_INS_CUUTF,
	SYSZ_INS_CUXTR,
	SYSZ_INS_CVB,
	SYSZ_INS_CVBG,
	SYSZ_INS_CVBY,
	SYSZ_INS_CVD,
	SYSZ_INS_CVDG,
	SYSZ_INS_CVDY,
	SYSZ_INS_CXFBRA,
	SYSZ_INS_CXFR,
	SYSZ_INS_CXFTR,
	SYSZ_INS_CXGBRA,
	SYSZ_INS_CXGR,
	SYSZ_INS_CXGTR,
	SYSZ_INS_CXGTRA,
	SYSZ_INS_CXLFTR,
	SYSZ_INS_CXLGTR,
	SYSZ_INS_CXPT,
	SYSZ_INS_CXR,
	SYSZ_INS_CXSTR,
	SYSZ_INS_CXTR,
	SYSZ_INS_CXUTR,
	SYSZ_INS_CXZT,
	SYSZ_INS_CZDT,
	SYSZ_INS_CZXT,
	SYSZ_INS_D,
	SYSZ_INS_DD,
	SYSZ_INS_DDR,
	SYSZ_INS_DDTR,
	SYSZ_INS_DDTRA,
	SYSZ_INS_DE,
	SYSZ_INS_DER,
	SYSZ_INS_DIAG,
	SYSZ_INS_DIDBR,
	SYSZ_INS_DIEBR,
	SYSZ_INS_DP,
	SYSZ_INS_DR,
	SYSZ_INS_DXR,
	SYSZ_INS_DXTR,
	SYSZ_INS_DXTRA,
	SYSZ_INS_ECAG,
	SYSZ_INS_ECCTR,
	SYSZ_INS_ECPGA,
	SYSZ_INS_ECTG,
	SYSZ_INS_ED,
	SYSZ_INS_EDMK,
	SYSZ_INS_EEDTR,
	SYSZ_INS_EEXTR,
	SYSZ_INS_EFPC,
	SYSZ_INS_EPAIR,
	SYSZ_INS_EPAR,
	SYSZ_INS_EPCTR,
	SYSZ_INS_EPSW,
	SYSZ_INS_EREG,
	SYSZ_INS_EREGG,
	SYSZ_INS_ESAIR,
	SYSZ_INS_ESAR,
	SYSZ_INS_ESDTR,
	SYSZ_INS_ESEA,
	SYSZ_INS_ESTA,
	SYSZ_INS_ESXTR,
	SYSZ_INS_ETND,
	SYSZ_INS_EX,
	SYSZ_INS_EXRL,
	SYSZ_INS_FIDR,
	SYSZ_INS_FIDTR,
	SYSZ_INS_FIER,
	SYSZ_INS_FIXR,
	SYSZ_INS_FIXTR,
	SYSZ_INS_HDR,
	SYSZ_INS_HER,
	SYSZ_INS_HSCH,
	SYSZ_INS_IAC,
	SYSZ_INS_ICM,
	SYSZ_INS_ICMH,
	SYSZ_INS_ICMY,
	SYSZ_INS_IDTE,
	SYSZ_INS_IEDTR,
	SYSZ_INS_IEXTR,
	SYSZ_INS_IPK,
	SYSZ_INS_IPTE,
	SYSZ_INS_IRBM,
	SYSZ_INS_ISKE,
	SYSZ_INS_IVSK,
	SYSZ_INS_JGM,
	SYSZ_INS_JGNM,
	SYSZ_INS_JGNP,
	SYSZ_INS_JGNZ,
	SYSZ_INS_JGP,
	SYSZ_INS_JGZ,
	SYSZ_INS_JM,
	SYSZ_INS_JNM,
	SYSZ_INS_JNP,
	SYSZ_INS_JNZ,
	SYSZ_INS_JP,
	SYSZ_INS_JZ,
	SYSZ_INS_KDB,
	SYSZ_INS_KDBR,
	SYSZ_INS_KDTR,
	SYSZ_INS_KEB,
	SYSZ_INS_KEBR,
	SYSZ_INS_KIMD,
	SYSZ_INS_KLMD,
	SYSZ_INS_KM,
	SYSZ_INS_KMA,
	SYSZ_INS_KMAC,
	SYSZ_INS_KMC,
	SYSZ_INS_KMCTR,
	SYSZ_INS_KMF,
	SYSZ_INS_KMO,
	SYSZ_INS_KXBR,
	SYSZ_INS_KXTR,
	SYSZ_INS_LAE,
	SYSZ_INS_LAEY,
	SYSZ_INS_LAM,
	SYSZ_INS_LAMY,
	SYSZ_INS_LASP,
	SYSZ_INS_LAT,
	SYSZ_INS_LCBB,
	SYSZ_INS_LCCTL,
	SYSZ_INS_LCDFR,
	SYSZ_INS_LCDR,
	SYSZ_INS_LCER,
	SYSZ_INS_LCTL,
	SYSZ_INS_LCTLG,
	SYSZ_INS_LCXR,
	SYSZ_INS_LDE,
	SYSZ_INS_LDER,
	SYSZ_INS_LDETR,
	SYSZ_INS_LDXR,
	SYSZ_INS_LDXTR,
	SYSZ_INS_LEDR,
	SYSZ_INS_LEDTR,
	SYSZ_INS_LEXR,
	SYSZ_INS_LFAS,
	SYSZ_INS_LFHAT,
	SYSZ_INS_LFPC,
	SYSZ_INS_LGAT,
	SYSZ_INS_LGG,
	SYSZ_INS_LGSC,
	SYSZ_INS_LLGFAT,
	SYSZ_INS_LLGFSG,
	SYSZ_INS_LLGT,
	SYSZ_INS_LLGTAT,
	SYSZ_INS_LLGTR,
	SYSZ_INS_LLZRGF,
	SYSZ_INS_LM,
	SYSZ_INS_LMD,
	SYSZ_INS_LMH,
	SYSZ_INS_LMY,
	SYSZ_INS_LNDFR,
	SYSZ_INS_LNDR,
	SYSZ_INS_LNER,
	SYSZ_INS_LNXR,
	SYSZ_INS_LOCFH,
	SYSZ_INS_LOCFHE,
	SYSZ_INS_LOCFHH,
	SYSZ_INS_LOCFHHE,
	SYSZ_INS_LOCFHL,
	SYSZ_INS_LOCFHLE,
	SYSZ_INS_LOCFHLH,
	SYSZ_INS_LOCFHM,
	SYSZ_INS_LOCFHNE,
	SYSZ_INS_LOCFHNH,
	SYSZ_INS_LOCFHNHE,
	SYSZ_INS_LOCFHNL,
	SYSZ_INS_LOCFHNLE,
	SYSZ_INS_LOCFHNLH,
	SYSZ_INS_LOCFHNM,
	SYSZ_INS_LOCFHNO,
	SYSZ_INS_LOCFHNP,
	SYSZ_INS_LOCFHNZ,
	SYSZ_INS_LOCFHO,
	SYSZ_INS_LOCFHP,
	SYSZ_INS_LOCFHR,
	SYSZ_INS_LOCFHRE,
	SYSZ_INS_LOCFHRH,
	SYSZ_INS_LOCFHRHE,
	SYSZ_INS_LOCFHRL,
	SYSZ_INS_LOCFHRLE,
	SYSZ_INS_LOCFHRLH,
	SYSZ_INS_LOCFHRM,
	SYSZ_INS_LOCFHRNE,
	SYSZ_INS_LOCFHRNH,
	SYSZ_INS_LOCFHRNHE,
	SYSZ_INS_LOCFHRNL,
	SYSZ_INS_LOCFHRNLE,
	SYSZ_INS_LOCFHRNLH,
	SYSZ_INS_LOCFHRNM,
	SYSZ_INS_LOCFHRNO,
	SYSZ_INS_LOCFHRNP,
	SYSZ_INS_LOCFHRNZ,
	SYSZ_INS_LOCFHRO,
	SYSZ_INS_LOCFHRP,
	SYSZ_INS_LOCFHRZ,
	SYSZ_INS_LOCFHZ,
	SYSZ_INS_LOCGHI,
	SYSZ_INS_LOCGHIE,
	SYSZ_INS_LOCGHIH,
	SYSZ_INS_LOCGHIHE,
	SYSZ_INS_LOCGHIL,
	SYSZ_INS_LOCGHILE,
	SYSZ_INS_LOCGHILH,
	SYSZ_INS_LOCGHIM,
	SYSZ_INS_LOCGHINE,
	SYSZ_INS_LOCGHINH,
	SYSZ_INS_LOCGHINHE,
	SYSZ_INS_LOCGHINL,
	SYSZ_INS_LOCGHINLE,
	SYSZ_INS_LOCGHINLH,
	SYSZ_INS_LOCGHINM,
	SYSZ_INS_LOCGHINO,
	SYSZ_INS_LOCGHINP,
	SYSZ_INS_LOCGHINZ,
	SYSZ_INS_LOCGHIO,
	SYSZ_INS_LOCGHIP,
	SYSZ_INS_LOCGHIZ,
	SYSZ_INS_LOCGM,
	SYSZ_INS_LOCGNM,
	SYSZ_INS_LOCGNP,
	SYSZ_INS_LOCGNZ,
	SYSZ_INS_LOCGP,
	SYSZ_INS_LOCGRM,
	SYSZ_INS_LOCGRNM,
	SYSZ_INS_LOCGRNP,
	SYSZ_INS_LOCGRNZ,
	SYSZ_INS_LOCGRP,
	SYSZ_INS_LOCGRZ,
	SYSZ_INS_LOCGZ,
	SYSZ_INS_LOCHHI,
	SYSZ_INS_LOCHHIE,
	SYSZ_INS_LOCHHIH,
	SYSZ_INS_LOCHHIHE,
	SYSZ_INS_LOCHHIL,
	SYSZ_INS_LOCHHILE,
	SYSZ_INS_LOCHHILH,
	SYSZ_INS_LOCHHIM,
	SYSZ_INS_LOCHHINE,
	SYSZ_INS_LOCHHINH,
	SYSZ_INS_LOCHHINHE,
	SYSZ_INS_LOCHHINL,
	SYSZ_INS_LOCHHINLE,
	SYSZ_INS_LOCHHINLH,
	SYSZ_INS_LOCHHINM,
	SYSZ_INS_LOCHHINO,
	SYSZ_INS_LOCHHINP,
	SYSZ_INS_LOCHHINZ,
	SYSZ_INS_LOCHHIO,
	SYSZ_INS_LOCHHIP,
	SYSZ_INS_LOCHHIZ,
	SYSZ_INS_LOCHI,
	SYSZ_INS_LOCHIE,
	SYSZ_INS_LOCHIH,
	SYSZ_INS_LOCHIHE,
	SYSZ_INS_LOCHIL,
	SYSZ_INS_LOCHILE,
	SYSZ_INS_LOCHILH,
	SYSZ_INS_LOCHIM,
	SYSZ_INS_LOCHINE,
	SYSZ_INS_LOCHINH,
	SYSZ_INS_LOCHINHE,
	SYSZ_INS_LOCHINL,
	SYSZ_INS_LOCHINLE,
	SYSZ_INS_LOCHINLH,
	SYSZ_INS_LOCHINM,
	SYSZ_INS_LOCHINO,
	SYSZ_INS_LOCHINP,
	SYSZ_INS_LOCHINZ,
	SYSZ_INS_LOCHIO,
	SYSZ_INS_LOCHIP,
	SYSZ_INS_LOCHIZ,
	SYSZ_INS_LOCM,
	SYSZ_INS_LOCNM,
	SYSZ_INS_LOCNP,
	SYSZ_INS_LOCNZ,
	SYSZ_INS_LOCP,
	SYSZ_INS_LOCRM,
	SYSZ_INS_LOCRNM,
	SYSZ_INS_LOCRNP,
	SYSZ_INS_LOCRNZ,
	SYSZ_INS_LOCRP,
	SYSZ_INS_LOCRZ,
	SYSZ_INS_LOCZ,
	SYSZ_INS_LPCTL,
	SYSZ_INS_LPD,
	SYSZ_INS_LPDFR,
	SYSZ_INS_LPDG,
	SYSZ_INS_LPDR,
	SYSZ_INS_LPER,
	SYSZ_INS_LPP,
	SYSZ_INS_LPQ,
	SYSZ_INS_LPSW,
	SYSZ_INS_LPSWE,
	SYSZ_INS_LPTEA,
	SYSZ_INS_LPXR,
	SYSZ_INS_LRA,
	SYSZ_INS_LRAG,
	SYSZ_INS_LRAY,
	SYSZ_INS_LRDR,
	SYSZ_INS_LRER,
	SYSZ_INS_LRVH,
	SYSZ_INS_LSCTL,
	SYSZ_INS_LTDR,
	SYSZ_INS_LTDTR,
	SYSZ_INS_LTER,
	SYSZ_INS_LTXR,
	SYSZ_INS_LTXTR,
	SYSZ_INS_LURA,
	SYSZ_INS_LURAG,
	SYSZ_INS_LXD,
	SYSZ_INS_LXDR,
	SYSZ_INS_LXDTR,
	SYSZ_INS_LXE,
	SYSZ_INS_LXER,
	SYSZ_INS_LZRF,
	SYSZ_INS_LZRG,
	SYSZ_INS_M,
	SYSZ_INS_MAD,
	SYSZ_INS_MADR,
	SYSZ_INS_MAE,
	SYSZ_INS_MAER,
	SYSZ_INS_MAY,
	SYSZ_INS_MAYH,
	SYSZ_INS_MAYHR,
	SYSZ_INS_MAYL,
	SYSZ_INS_MAYLR,
	SYSZ_INS_MAYR,
	SYSZ_INS_MC,
	SYSZ_INS_MD,
	SYSZ_INS_MDE,
	SYSZ_INS_MDER,
	SYSZ_INS_MDR,
	SYSZ_INS_MDTR,
	SYSZ_INS_MDTRA,
	SYSZ_INS_ME,
	SYSZ_INS_MEE,
	SYSZ_INS_MEER,
	SYSZ_INS_MER,
	SYSZ_INS_MFY,
	SYSZ_INS_MG,
	SYSZ_INS_MGH,
	SYSZ_INS_MGRK,
	SYSZ_INS_ML,
	SYSZ_INS_MLR,
	SYSZ_INS_MP,
	SYSZ_INS_MR,
	SYSZ_INS_MSC,
	SYSZ_INS_MSCH,
	SYSZ_INS_MSD,
	SYSZ_INS_MSDR,
	SYSZ_INS_MSE,
	SYSZ_INS_MSER,
	SYSZ_INS_MSGC,
	SYSZ_INS_MSGRKC,
	SYSZ_INS_MSRKC,
	SYSZ_INS_MSTA,
	SYSZ_INS_MVCDK,
	SYSZ_INS_MVCIN,
	SYSZ_INS_MVCK,
	SYSZ_INS_MVCL,
	SYSZ_INS_MVCLE,
	SYSZ_INS_MVCLU,
	SYSZ_INS_MVCOS,
	SYSZ_INS_MVCP,
	SYSZ_INS_MVCS,
	SYSZ_INS_MVCSK,
	SYSZ_INS_MVN,
	SYSZ_INS_MVO,
	SYSZ_INS_MVPG,
	SYSZ_INS_MVZ,
	SYSZ_INS_MXD,
	SYSZ_INS_MXDR,
	SYSZ_INS_MXR,
	SYSZ_INS_MXTR,
	SYSZ_INS_MXTRA,
	SYSZ_INS_MY,
	SYSZ_INS_MYH,
	SYSZ_INS_MYHR,
	SYSZ_INS_MYL,
	SYSZ_INS_MYLR,
	SYSZ_INS_MYR,
	SYSZ_INS_NIAI,
	SYSZ_INS_NTSTG,
	SYSZ_INS_PACK,
	SYSZ_INS_PALB,
	SYSZ_INS_PC,
	SYSZ_INS_PCC,
	SYSZ_INS_PCKMO,
	SYSZ_INS_PFMF,
	SYSZ_INS_PFPO,
	SYSZ_INS_PGIN,
	SYSZ_INS_PGOUT,
	SYSZ_INS_PKA,
	SYSZ_INS_PKU,
	SYSZ_INS_PLO,
	SYSZ_INS_POPCNT,
	SYSZ_INS_PPA,
	SYSZ_INS_PPNO,
	SYSZ_INS_PR,
	SYSZ_INS_PRNO,
	SYSZ_INS_PT,
	SYSZ_INS_PTF,
	SYSZ_INS_PTFF,
	SYSZ_INS_PTI,
	SYSZ_INS_PTLB,
	SYSZ_INS_QADTR,
	SYSZ_INS_QAXTR,
	SYSZ_INS_QCTRI,
	SYSZ_INS_QSI,
	SYSZ_INS_RCHP,
	SYSZ_INS_RISBGN,
	SYSZ_INS_RP,
	SYSZ_INS_RRBE,
	SYSZ_INS_RRBM,
	SYSZ_INS_RRDTR,
	SYSZ_INS_RRXTR,
	SYSZ_INS_RSCH,
	SYSZ_INS_SAC,
	SYSZ_INS_SACF,
	SYSZ_INS_SAL,
	SYSZ_INS_SAM24,
	SYSZ_INS_SAM31,
	SYSZ_INS_SAM64,
	SYSZ_INS_SAR,
	SYSZ_INS_SCCTR,
	SYSZ_INS_SCHM,
	SYSZ_INS_SCK,
	SYSZ_INS_SCKC,
	SYSZ_INS_SCKPF,
	SYSZ_INS_SD,
	SYSZ_INS_SDR,
	SYSZ_INS_SDTR,
	SYSZ_INS_SDTRA,
	SYSZ_INS_SE,
	SYSZ_INS_SER,
	SYSZ_INS_SFASR,
	SYSZ_INS_SFPC,
	SYSZ_INS_SGH,
	SYSZ_INS_SHHHR,
	SYSZ_INS_SHHLR,
	SYSZ_INS_SIE,
	SYSZ_INS_SIGA,
	SYSZ_INS_SIGP,
	SYSZ_INS_SLA,
	SYSZ_INS_SLAG,
	SYSZ_INS_SLAK,
	SYSZ_INS_SLDA,
	SYSZ_INS_SLDL,
	SYSZ_INS_SLDT,
	SYSZ_INS_SLHHHR,
	SYSZ_INS_SLHHLR,
	SYSZ_INS_SLXT,
	SYSZ_INS_SP,
	SYSZ_INS_SPCTR,
	SYSZ_INS_SPKA,
	SYSZ_INS_SPM,
	SYSZ_INS_SPT,
	SYSZ_INS_SPX,
	SYSZ_INS_SQD,
	SYSZ_INS_SQDR,
	SYSZ_INS_SQE,
	SYSZ_INS_SQER,
	SYSZ_INS_SQXR,
	SYSZ_INS_SRDA,
	SYSZ_INS_SRDL,
	SYSZ_INS_SRDT,
	SYSZ_INS_SRNM,
	SYSZ_INS_SRNMB,
	SYSZ_INS_SRNMT,
	SYSZ_INS_SRP,
	SYSZ_INS_SRSTU,
	SYSZ_INS_SRXT,
	SYSZ_INS_SSAIR,
	SYSZ_INS_SSAR,
	SYSZ_INS_SSCH,
	SYSZ_INS_SSKE,
	SYSZ_INS_SSM,
	SYSZ_INS_STAM,
	SYSZ_INS_STAMY,
	SYSZ_INS_STAP,
	SYSZ_INS_STCK,
	SYSZ_INS_STCKC,
	SYSZ_INS_STCKE,
	SYSZ_INS_STCKF,
	SYSZ_INS_STCM,
	SYSZ_INS_STCMH,
	SYSZ_INS_STCMY,
	SYSZ_INS_STCPS,
	SYSZ_INS_STCRW,
	SYSZ_INS_STCTG,
	SYSZ_INS_STCTL,
	SYSZ_INS_STFL,
	SYSZ_INS_STFLE,
	SYSZ_INS_STFPC,
	SYSZ_INS_STGSC,
	SYSZ_INS_STIDP,
	SYSZ_INS_STM,
	SYSZ_INS_STMH,
	SYSZ_INS_STMY,
	SYSZ_INS_STNSM,
	SYSZ_INS_STOCFH,
	SYSZ_INS_STOCFHE,
	SYSZ_INS_STOCFHH,
	SYSZ_INS_STOCFHHE,
	SYSZ_INS_STOCFHL,
	SYSZ_INS_STOCFHLE,
	SYSZ_INS_STOCFHLH,
	SYSZ_INS_STOCFHM,
	SYSZ_INS_STOCFHNE,
	SYSZ_INS_STOCFHNH,
	SYSZ_INS_STOCFHNHE,
	SYSZ_INS_STOCFHNL,
	SYSZ_INS_STOCFHNLE,
	SYSZ_INS_STOCFHNLH,
	SYSZ_INS_STOCFHNM,
	SYSZ_INS_STOCFHNO,
	SYSZ_INS_STOCFHNP,
	SYSZ_INS_STOCFHNZ,
	SYSZ_INS_STOCFHO,
	SYSZ_INS_STOCFHP,
	SYSZ_INS_STOCFHZ,
	SYSZ_INS_STOCGM,
	SYSZ_INS_STOCGNM,
	SYSZ_INS_STOCGNP,
	SYSZ_INS_STOCGNZ,
	SYSZ_INS_STOCGP,
	SYSZ_INS_STOCGZ,
	SYSZ_INS_STOCM,
	SYSZ_INS_STOCNM,
	SYSZ_INS_STOCNP,
	SYSZ_INS_STOCNZ,
	SYSZ_INS_STOCP,
	SYSZ_INS_STOCZ,
	SYSZ_INS_STOSM,
	SYSZ_INS_STPQ,
	SYSZ_INS_STPT,
	SYSZ_INS_STPX,
	SYSZ_INS_STRAG,
	SYSZ_INS_STRVH,
	SYSZ_INS_STSCH,
	SYSZ_INS_STSI,
	SYSZ_INS_STURA,
	SYSZ_INS_STURG,
	SYSZ_INS_SU,
	SYSZ_INS_SUR,
	SYSZ_INS_SVC,
	SYSZ_INS_SW,
	SYSZ_INS_SWR,
	SYSZ_INS_SXR,
	SYSZ_INS_SXTR,
	SYSZ_INS_SXTRA,
	SYSZ_INS_TABORT,
	SYSZ_INS_TAM,
	SYSZ_INS_TAR,
	SYSZ_INS_TB,
	SYSZ_INS_TBDR,
	SYSZ_INS_TBEDR,
	SYSZ_INS_TBEGIN,
	SYSZ_INS_TBEGINC,
	SYSZ_INS_TCDB,
	SYSZ_INS_TCEB,
	SYSZ_INS_TCXB,
	SYSZ_INS_TDCDT,
	SYSZ_INS_TDCET,
	SYSZ_INS_TDCXT,
	SYSZ_INS_TDGDT,
	SYSZ_INS_TDGET,
	SYSZ_INS_TDGXT,
	SYSZ_INS_TEND,
	SYSZ_INS_THDER,
	SYSZ_INS_THDR,
	SYSZ_INS_TP,
	SYSZ_INS_TPI,
	SYSZ_INS_TPROT,
	SYSZ_INS_TR,
	SYSZ_INS_TRACE,
	SYSZ_INS_TRACG,
	SYSZ_INS_TRAP2,
	SYSZ_INS_TRAP4,
	SYSZ_INS_TRE,
	SYSZ_INS_TROO,
	SYSZ_INS_TROT,
	SYSZ_INS_TRT,
	SYSZ_INS_TRTE,
	SYSZ_INS_TRTO,
	SYSZ_INS_TRTR,
	SYSZ_INS_TRTRE,
	SYSZ_INS_TRTT,
	SYSZ_INS_TS,
	SYSZ_INS_TSCH,
	SYSZ_INS_UNPK,
	SYSZ_INS_UNPKA,
	SYSZ_INS_UNPKU,
	SYSZ_INS_UPT,
	SYSZ_INS_VA,
	SYSZ_INS_VAB,
	SYSZ_INS_VAC,
	SYSZ_INS_VACC,
	SYSZ_INS_VACCB,
	SYSZ_INS_VACCC,
	SYSZ_INS_VACCCQ,
	SYSZ_INS_VACCF,
	SYSZ_INS_VACCG,
	SYSZ_INS_VACCH,
	SYSZ_INS_VACCQ,
	SYSZ_INS_VACQ,
	SYSZ_INS_VAF,
	SYSZ_INS_VAG,
	SYSZ_INS_VAH,
	SYSZ_INS_VAP,
	SYSZ_INS_VAQ,
	SYSZ_INS_VAVG,
	SYSZ_INS_VAVGB,
	SYSZ_INS_VAVGF,
	SYSZ_INS_VAVGG,
	SYSZ_INS_VAVGH,
	SYSZ_INS_VAVGL,
	SYSZ_INS_VAVGLB,
	SYSZ_INS_VAVGLF,
	SYSZ_INS_VAVGLG,
	SYSZ_INS_VAVGLH,
	SYSZ_INS_VBPERM,
	SYSZ_INS_VCDG,
	SYSZ_INS_VCDGB,
	SYSZ_INS_VCDLG,
	SYSZ_INS_VCDLGB,
	SYSZ_INS_VCEQ,
	SYSZ_INS_VCEQB,
	SYSZ_INS_VCEQBS,
	SYSZ_INS_VCEQF,
	SYSZ_INS_VCEQFS,
	SYSZ_INS_VCEQG,
	SYSZ_INS_VCEQGS,
	SYSZ_INS_VCEQH,
	SYSZ_INS_VCEQHS,
	SYSZ_INS_VCGD,
	SYSZ_INS_VCGDB,
	SYSZ_INS_VCH,
	SYSZ_INS_VCHB,
	SYSZ_INS_VCHBS,
	SYSZ_INS_VCHF,
	SYSZ_INS_VCHFS,
	SYSZ_INS_VCHG,
	SYSZ_INS_VCHGS,
	SYSZ_INS_VCHH,
	SYSZ_INS_VCHHS,
	SYSZ_INS_VCHL,
	SYSZ_INS_VCHLB,
	SYSZ_INS_VCHLBS,
	SYSZ_INS_VCHLF,
	SYSZ_INS_VCHLFS,
	SYSZ_INS_VCHLG,
	SYSZ_INS_VCHLGS,
	SYSZ_INS_VCHLH,
	SYSZ_INS_VCHLHS,
	SYSZ_INS_VCKSM,
	SYSZ_INS_VCLGD,
	SYSZ_INS_VCLGDB,
	SYSZ_INS_VCLZ,
	SYSZ_INS_VCLZB,
	SYSZ_INS_VCLZF,
	SYSZ_INS_VCLZG,
	SYSZ_INS_VCLZH,
	SYSZ_INS_VCP,
	SYSZ_INS_VCTZ,
	SYSZ_INS_VCTZB,
	SYSZ_INS_VCTZF,
	SYSZ_INS_VCTZG,
	SYSZ_INS_VCTZH,
	SYSZ_INS_VCVB,
	SYSZ_INS_VCVBG,
	SYSZ_INS_VCVD,
	SYSZ_INS_VCVDG,
	SYSZ_INS_VDP,
	SYSZ_INS_VEC,
	SYSZ_INS_VECB,
	SYSZ_INS_VECF,
	SYSZ_INS_VECG,
	SYSZ_INS_VECH,
	SYSZ_INS_VECL,
	SYSZ_INS_VECLB,
	SYSZ_INS_VECLF,
	SYSZ_INS_VECLG,
	SYSZ_INS_VECLH,
	SYSZ_INS_VERIM,
	SYSZ_INS_VERIMB,
	SYSZ_INS_VERIMF,
	SYSZ_INS_VERIMG,
	SYSZ_INS_VERIMH,
	SYSZ_INS_VERLL,
	SYSZ_INS_VERLLB,
	SYSZ_INS_VERLLF,
	SYSZ_INS_VERLLG,
	SYSZ_INS_VERLLH,
	SYSZ_INS_VERLLV,
	SYSZ_INS_VERLLVB,
	SYSZ_INS_VERLLVF,
	SYSZ_INS_VERLLVG,
	SYSZ_INS_VERLLVH,
	SYSZ_INS_VESL,
	SYSZ_INS_VESLB,
	SYSZ_INS_VESLF,
	SYSZ_INS_VESLG,
	SYSZ_INS_VESLH,
	SYSZ_INS_VESLV,
	SYSZ_INS_VESLVB,
	SYSZ_INS_VESLVF,
	SYSZ_INS_VESLVG,
	SYSZ_INS_VESLVH,
	SYSZ_INS_VESRA,
	SYSZ_INS_VESRAB,
	SYSZ_INS_VESRAF,
	SYSZ_INS_VESRAG,
	SYSZ_INS_VESRAH,
	SYSZ_INS_VESRAV,
	SYSZ_INS_VESRAVB,
	SYSZ_INS_VESRAVF,
	SYSZ_INS_VESRAVG,
	SYSZ_INS_VESRAVH,
	SYSZ_INS_VESRL,
	SYSZ_INS_VESRLB,
	SYSZ_INS_VESRLF,
	SYSZ_INS_VESRLG,
	SYSZ_INS_VESRLH,
	SYSZ_INS_VESRLV,
	SYSZ_INS_VESRLVB,
	SYSZ_INS_VESRLVF,
	SYSZ_INS_VESRLVG,
	SYSZ_INS_VESRLVH,
	SYSZ_INS_VFA,
	SYSZ_INS_VFADB,
	SYSZ_INS_VFAE,
	SYSZ_INS_VFAEB,
	SYSZ_INS_VFAEBS,
	SYSZ_INS_VFAEF,
	SYSZ_INS_VFAEFS,
	SYSZ_INS_VFAEH,
	SYSZ_INS_VFAEHS,
	SYSZ_INS_VFAEZB,
	SYSZ_INS_VFAEZBS,
	SYSZ_INS_VFAEZF,
	SYSZ_INS_VFAEZFS,
	SYSZ_INS_VFAEZH,
	SYSZ_INS_VFAEZHS,
	SYSZ_INS_VFASB,
	SYSZ_INS_VFCE,
	SYSZ_INS_VFCEDB,
	SYSZ_INS_VFCEDBS,
	SYSZ_INS_VFCESB,
	SYSZ_INS_VFCESBS,
	SYSZ_INS_VFCH,
	SYSZ_INS_VFCHDB,
	SYSZ_INS_VFCHDBS,
	SYSZ_INS_VFCHE,
	SYSZ_INS_VFCHEDB,
	SYSZ_INS_VFCHEDBS,
	SYSZ_INS_VFCHESB,
	SYSZ_INS_VFCHESBS,
	SYSZ_INS_VFCHSB,
	SYSZ_INS_VFCHSBS,
	SYSZ_INS_VFD,
	SYSZ_INS_VFDDB,
	SYSZ_INS_VFDSB,
	SYSZ_INS_VFEE,
	SYSZ_INS_VFEEB,
	SYSZ_INS_VFEEBS,
	SYSZ_INS_VFEEF,
	SYSZ_INS_VFEEFS,
	SYSZ_INS_VFEEH,
	SYSZ_INS_VFEEHS,
	SYSZ_INS_VFEEZB,
	SYSZ_INS_VFEEZBS,
	SYSZ_INS_VFEEZF,
	SYSZ_INS_VFEEZFS,
	SYSZ_INS_VFEEZH,
	SYSZ_INS_VFEEZHS,
	SYSZ_INS_VFENE,
	SYSZ_INS_VFENEB,
	SYSZ_INS_VFENEBS,
	SYSZ_INS_VFENEF,
	SYSZ_INS_VFENEFS,
	SYSZ_INS_VFENEH,
	SYSZ_INS_VFENEHS,
	SYSZ_INS_VFENEZB,
	SYSZ_INS_VFENEZBS,
	SYSZ_INS_VFENEZF,
	SYSZ_INS_VFENEZFS,
	SYSZ_INS_VFENEZH,
	SYSZ_INS_VFENEZHS,
	SYSZ_INS_VFI,
	SYSZ_INS_VFIDB,
	SYSZ_INS_VFISB,
	SYSZ_INS_VFKEDB,
	SYSZ_INS_VFKEDBS,
	SYSZ_INS_VFKESB,
	SYSZ_INS_VFKESBS,
	SYSZ_INS_VFKHDB,
	SYSZ_INS_VFKHDBS,
	SYSZ_INS_VFKHEDB,
	SYSZ_INS_VFKHEDBS,
	SYSZ_INS_VFKHESB,
	SYSZ_INS_VFKHESBS,
	SYSZ_INS_VFKHSB,
	SYSZ_INS_VFKHSBS,
	SYSZ_INS_VFLCDB,
	SYSZ_INS_VFLCSB,
	SYSZ_INS_VFLL,
	SYSZ_INS_VFLLS,
	SYSZ_INS_VFLNDB,
	SYSZ_INS_VFLNSB,
	SYSZ_INS_VFLPDB,
	SYSZ_INS_VFLPSB,
	SYSZ_INS_VFLR,
	SYSZ_INS_VFLRD,
	SYSZ_INS_VFM,
	SYSZ_INS_VFMA,
	SYSZ_INS_VFMADB,
	SYSZ_INS_VFMASB,
	SYSZ_INS_VFMAX,
	SYSZ_INS_VFMAXDB,
	SYSZ_INS_VFMAXSB,
	SYSZ_INS_VFMDB,
	SYSZ_INS_VFMIN,
	SYSZ_INS_VFMINDB,
	SYSZ_INS_VFMINSB,
	SYSZ_INS_VFMS,
	SYSZ_INS_VFMSB,
	SYSZ_INS_VFMSDB,
	SYSZ_INS_VFMSSB,
	SYSZ_INS_VFNMA,
	SYSZ_INS_VFNMADB,
	SYSZ_INS_VFNMASB,
	SYSZ_INS_VFNMS,
	SYSZ_INS_VFNMSDB,
	SYSZ_INS_VFNMSSB,
	SYSZ_INS_VFPSO,
	SYSZ_INS_VFPSODB,
	SYSZ_INS_VFPSOSB,
	SYSZ_INS_VFS,
	SYSZ_INS_VFSDB,
	SYSZ_INS_VFSQ,
	SYSZ_INS_VFSQDB,
	SYSZ_INS_VFSQSB,
	SYSZ_INS_VFSSB,
	SYSZ_INS_VFTCI,
	SYSZ_INS_VFTCIDB,
	SYSZ_INS_VFTCISB,
	SYSZ_INS_VGBM,
	SYSZ_INS_VGEF,
	SYSZ_INS_VGEG,
	SYSZ_INS_VGFM,
	SYSZ_INS_VGFMA,
	SYSZ_INS_VGFMAB,
	SYSZ_INS_VGFMAF,
	SYSZ_INS_VGFMAG,
	SYSZ_INS_VGFMAH,
	SYSZ_INS_VGFMB,
	SYSZ_INS_VGFMF,
	SYSZ_INS_VGFMG,
	SYSZ_INS_VGFMH,
	SYSZ_INS_VGM,
	SYSZ_INS_VGMB,
	SYSZ_INS_VGMF,
	SYSZ_INS_VGMG,
	SYSZ_INS_VGMH,
	SYSZ_INS_VISTR,
	SYSZ_INS_VISTRB,
	SYSZ_INS_VISTRBS,
	SYSZ_INS_VISTRF,
	SYSZ_INS_VISTRFS,
	SYSZ_INS_VISTRH,
	SYSZ_INS_VISTRHS,
	SYSZ_INS_VL,
	SYSZ_INS_VLBB,
	SYSZ_INS_VLC,
	SYSZ_INS_VLCB,
	SYSZ_INS_VLCF,
	SYSZ_INS_VLCG,
	SYSZ_INS_VLCH,
	SYSZ_INS_VLDE,
	SYSZ_INS_VLDEB,
	SYSZ_INS_VLEB,
	SYSZ_INS_VLED,
	SYSZ_INS_VLEDB,
	SYSZ_INS_VLEF,
	SYSZ_INS_VLEG,
	SYSZ_INS_VLEH,
	SYSZ_INS_VLEIB,
	SYSZ_INS_VLEIF,
	SYSZ_INS_VLEIG,
	SYSZ_INS_VLEIH,
	SYSZ_INS_VLGV,
	SYSZ_INS_VLGVB,
	SYSZ_INS_VLGVF,
	SYSZ_INS_VLGVG,
	SYSZ_INS_VLGVH,
	SYSZ_INS_VLIP,
	SYSZ_INS_VLL,
	SYSZ_INS_VLLEZ,
	SYSZ_INS_VLLEZB,
	SYSZ_INS_VLLEZF,
	SYSZ_INS_VLLEZG,
	SYSZ_INS_VLLEZH,
	SYSZ_INS_VLLEZLF,
	SYSZ_INS_VLM,
	SYSZ_INS_VLP,
	SYSZ_INS_VLPB,
	SYSZ_INS_VLPF,
	SYSZ_INS_VLPG,
	SYSZ_INS_VLPH,
	SYSZ_INS_VLR,
	SYSZ_INS_VLREP,
	SYSZ_INS_VLREPB,
	SYSZ_INS_VLREPF,
	SYSZ_INS_VLREPG,
	SYSZ_INS_VLREPH,
	SYSZ_INS_VLRL,
	SYSZ_INS_VLRLR,
	SYSZ_INS_VLVG,
	SYSZ_INS_VLVGB,
	SYSZ_INS_VLVGF,
	SYSZ_INS_VLVGG,
	SYSZ_INS_VLVGH,
	SYSZ_INS_VLVGP,
	SYSZ_INS_VMAE,
	SYSZ_INS_VMAEB,
	SYSZ_INS_VMAEF,
	SYSZ_INS_VMAEH,
	SYSZ_INS_VMAH,
	SYSZ_INS_VMAHB,
	SYSZ_INS_VMAHF,
	SYSZ_INS_VMAHH,
	SYSZ_INS_VMAL,
	SYSZ_INS_VMALB,
	SYSZ_INS_VMALE,
	SYSZ_INS_VMALEB,
	SYSZ_INS_VMALEF,
	SYSZ_INS_VMALEH,
	SYSZ_INS_VMALF,
	SYSZ_INS_VMALH,
	SYSZ_INS_VMALHB,
	SYSZ_INS_VMALHF,
	SYSZ_INS_VMALHH,
	SYSZ_INS_VMALHW,
	SYSZ_INS_VMALO,
	SYSZ_INS_VMALOB,
	SYSZ_INS_VMALOF,
	SYSZ_INS_VMALOH,
	SYSZ_INS_VMAO,
	SYSZ_INS_VMAOB,
	SYSZ_INS_VMAOF,
	SYSZ_INS_VMAOH,
	SYSZ_INS_VME,
	SYSZ_INS_VMEB,
	SYSZ_INS_VMEF,
	SYSZ_INS_VMEH,
	SYSZ_INS_VMH,
	SYSZ_INS_VMHB,
	SYSZ_INS_VMHF,
	SYSZ_INS_VMHH,
	SYSZ_INS_VML,
	SYSZ_INS_VMLB,
	SYSZ_INS_VMLE,
	SYSZ_INS_VMLEB,
	SYSZ_INS_VMLEF,
	SYSZ_INS_VMLEH,
	SYSZ_INS_VMLF,
	SYSZ_INS_VMLH,
	SYSZ_INS_VMLHB,
	SYSZ_INS_VMLHF,
	SYSZ_INS_VMLHH,
	SYSZ_INS_VMLHW,
	SYSZ_INS_VMLO,
	SYSZ_INS_VMLOB,
	SYSZ_INS_VMLOF,
	SYSZ_INS_VMLOH,
	SYSZ_INS_VMN,
	SYSZ_INS_VMNB,
	SYSZ_INS_VMNF,
	SYSZ_INS_VMNG,
	SYSZ_INS_VMNH,
	SYSZ_INS_VMNL,
	SYSZ_INS_VMNLB,
	SYSZ_INS_VMNLF,
	SYSZ_INS_VMNLG,
	SYSZ_INS_VMNLH,
	SYSZ_INS_VMO,
	SYSZ_INS_VMOB,
	SYSZ_INS_VMOF,
	SYSZ_INS_VMOH,
	SYSZ_INS_VMP,
	SYSZ_INS_VMRH,
	SYSZ_INS_VMRHB,
	SYSZ_INS_VMRHF,
	SYSZ_INS_VMRHG,
	SYSZ_INS_VMRHH,
	SYSZ_INS_VMRL,
	SYSZ_INS_VMRLB,
	SYSZ_INS_VMRLF,
	SYSZ_INS_VMRLG,
	SYSZ_INS_VMRLH,
	SYSZ_INS_VMSL,
	SYSZ_INS_VMSLG,
	SYSZ_INS_VMSP,
	SYSZ_INS_VMX,
	SYSZ_INS_VMXB,
	SYSZ_INS_VMXF,
	SYSZ_INS_VMXG,
	SYSZ_INS_VMXH,
	SYSZ_INS_VMXL,
	SYSZ_INS_VMXLB,
	SYSZ_INS_VMXLF,
	SYSZ_INS_VMXLG,
	SYSZ_INS_VMXLH,
	SYSZ_INS_VN,
	SYSZ_INS_VNC,
	SYSZ_INS_VNN,
	SYSZ_INS_VNO,
	SYSZ_INS_VNX,
	SYSZ_INS_VO,
	SYSZ_INS_VOC,
	SYSZ_INS_VONE,
	SYSZ_INS_VPDI,
	SYSZ_INS_VPERM,
	SYSZ_INS_VPK,
	SYSZ_INS_VPKF,
	SYSZ_INS_VPKG,
	SYSZ_INS_VPKH,
	SYSZ_INS_VPKLS,
	SYSZ_INS_VPKLSF,
	SYSZ_INS_VPKLSFS,
	SYSZ_INS_VPKLSG,
	SYSZ_INS_VPKLSGS,
	SYSZ_INS_VPKLSH,
	SYSZ_INS_VPKLSHS,
	SYSZ_INS_VPKS,
	SYSZ_INS_VPKSF,
	SYSZ_INS_VPKSFS,
	SYSZ_INS_VPKSG,
	SYSZ_INS_VPKSGS,
	SYSZ_INS_VPKSH,
	SYSZ_INS_VPKSHS,
	SYSZ_INS_VPKZ,
	SYSZ_INS_VPOPCT,
	SYSZ_INS_VPOPCTB,
	SYSZ_INS_VPOPCTF,
	SYSZ_INS_VPOPCTG,
	SYSZ_INS_VPOPCTH,
	SYSZ_INS_VPSOP,
	SYSZ_INS_VREP,
	SYSZ_INS_VREPB,
	SYSZ_INS_VREPF,
	SYSZ_INS_VREPG,
	SYSZ_INS_VREPH,
	SYSZ_INS_VREPI,
	SYSZ_INS_VREPIB,
	SYSZ_INS_VREPIF,
	SYSZ_INS_VREPIG,
	SYSZ_INS_VREPIH,
	SYSZ_INS_VRP,
	SYSZ_INS_VS,
	SYSZ_INS_VSB,
	SYSZ_INS_VSBCBI,
	SYSZ_INS_VSBCBIQ,
	SYSZ_INS_VSBI,
	SYSZ_INS_VSBIQ,
	SYSZ_INS_VSCBI,
	SYSZ_INS_VSCBIB,
	SYSZ_INS_VSCBIF,
	SYSZ_INS_VSCBIG,
	SYSZ_INS_VSCBIH,
	SYSZ_INS_VSCBIQ,
	SYSZ_INS_VSCEF,
	SYSZ_INS_VSCEG,
	SYSZ_INS_VSDP,
	SYSZ_INS_VSEG,
	SYSZ_INS_VSEGB,
	SYSZ_INS_VSEGF,
	SYSZ_INS_VSEGH,
	SYSZ_INS_VSEL,
	SYSZ_INS_VSF,
	SYSZ_INS_VSG,
	SYSZ_INS_VSH,
	SYSZ_INS_VSL,
	SYSZ_INS_VSLB,
	SYSZ_INS_VSLDB,
	SYSZ_INS_VSP,
	SYSZ_INS_VSQ,
	SYSZ_INS_VSRA,
	SYSZ_INS_VSRAB,
	SYSZ_INS_VSRL,
	SYSZ_INS_VSRLB,
	SYSZ_INS_VSRP,
	SYSZ_INS_VST,
	SYSZ_INS_VSTEB,
	SYSZ_INS_VSTEF,
	SYSZ_INS_VSTEG,
	SYSZ_INS_VSTEH,
	SYSZ_INS_VSTL,
	SYSZ_INS_VSTM,
	SYSZ_INS_VSTRC,
	SYSZ_INS_VSTRCB,
	SYSZ_INS_VSTRCBS,
	SYSZ_INS_VSTRCF,
	SYSZ_INS_VSTRCFS,
	SYSZ_INS_VSTRCH,
	SYSZ_INS_VSTRCHS,
	SYSZ_INS_VSTRCZB,
	SYSZ_INS_VSTRCZBS,
	SYSZ_INS_VSTRCZF,
	SYSZ_INS_VSTRCZFS,
	SYSZ_INS_VSTRCZH,
	SYSZ_INS_VSTRCZHS,
	SYSZ_INS_VSTRL,
	SYSZ_INS_VSTRLR,
	SYSZ_INS_VSUM,
	SYSZ_INS_VSUMB,
	SYSZ_INS_VSUMG,
	SYSZ_INS_VSUMGF,
	SYSZ_INS_VSUMGH,
	SYSZ_INS_VSUMH,
	SYSZ_INS_VSUMQ,
	SYSZ_INS_VSUMQF,
	SYSZ_INS_VSUMQG,
	SYSZ_INS_VTM,
	SYSZ_INS_VTP,
	SYSZ_INS_VUPH,
	SYSZ_INS_VUPHB,
	SYSZ_INS_VUPHF,
	SYSZ_INS_VUPHH,
	SYSZ_INS_VUPKZ,
	SYSZ_INS_VUPL,
	SYSZ_INS_VUPLB,
	SYSZ_INS_VUPLF,
	SYSZ_INS_VUPLH,
	SYSZ_INS_VUPLHB,
	SYSZ_INS_VUPLHF,
	SYSZ_INS_VUPLHH,
	SYSZ_INS_VUPLHW,
	SYSZ_INS_VUPLL,
	SYSZ_INS_VUPLLB,
	SYSZ_INS_VUPLLF,
	SYSZ_INS_VUPLLH,
	SYSZ_INS_VX,
	SYSZ_INS_VZERO,
	SYSZ_INS_WCDGB,
	SYSZ_INS_WCDLGB,
	SYSZ_INS_WCGDB,
	SYSZ_INS_WCLGDB,
	SYSZ_INS_WFADB,
	SYSZ_INS_WFASB,
	SYSZ_INS_WFAXB,
	SYSZ_INS_WFC,
	SYSZ_INS_WFCDB,
	SYSZ_INS_WFCEDB,
	SYSZ_INS_WFCEDBS,
	SYSZ_INS_WFCESB,
	SYSZ_INS_WFCESBS,
	SYSZ_INS_WFCEXB,
	SYSZ_INS_WFCEXBS,
	SYSZ_INS_WFCHDB,
	SYSZ_INS_WFCHDBS,
	SYSZ_INS_WFCHEDB,
	SYSZ_INS_WFCHEDBS,
	SYSZ_INS_WFCHESB,
	SYSZ_INS_WFCHESBS,
	SYSZ_INS_WFCHEXB,
	SYSZ_INS_WFCHEXBS,
	SYSZ_INS_WFCHSB,
	SYSZ_INS_WFCHSBS,
	SYSZ_INS_WFCHXB,
	SYSZ_INS_WFCHXBS,
	SYSZ_INS_WFCSB,
	SYSZ_INS_WFCXB,
	SYSZ_INS_WFDDB,
	SYSZ_INS_WFDSB,
	SYSZ_INS_WFDXB,
	SYSZ_INS_WFIDB,
	SYSZ_INS_WFISB,
	SYSZ_INS_WFIXB,
	SYSZ_INS_WFK,
	SYSZ_INS_WFKDB,
	SYSZ_INS_WFKEDB,
	SYSZ_INS_WFKEDBS,
	SYSZ_INS_WFKESB,
	SYSZ_INS_WFKESBS,
	SYSZ_INS_WFKEXB,
	SYSZ_INS_WFKEXBS,
	SYSZ_INS_WFKHDB,
	SYSZ_INS_WFKHDBS,
	SYSZ_INS_WFKHEDB,
	SYSZ_INS_WFKHEDBS,
	SYSZ_INS_WFKHESB,
	SYSZ_INS_WFKHESBS,
	SYSZ_INS_WFKHEXB,
	SYSZ_INS_WFKHEXBS,
	SYSZ_INS_WFKHSB,
	SYSZ_INS_WFKHSBS,
	SYSZ_INS_WFKHXB,
	SYSZ_INS_WFKHXBS,
	SYSZ_INS_WFKSB,
	SYSZ_INS_WFKXB,
	SYSZ_INS_WFLCDB,
	SYSZ_INS_WFLCSB,
	SYSZ_INS_WFLCXB,
	SYSZ_INS_WFLLD,
	SYSZ_INS_WFLLS,
	SYSZ_INS_WFLNDB,
	SYSZ_INS_WFLNSB,
	SYSZ_INS_WFLNXB,
	SYSZ_INS_WFLPDB,
	SYSZ_INS_WFLPSB,
	SYSZ_INS_WFLPXB,
	SYSZ_INS_WFLRD,
	SYSZ_INS_WFLRX,
	SYSZ_INS_WFMADB,
	SYSZ_INS_WFMASB,
	SYSZ_INS_WFMAXB,
	SYSZ_INS_WFMAXDB,
	SYSZ_INS_WFMAXSB,
	SYSZ_INS_WFMAXXB,
	SYSZ_INS_WFMDB,
	SYSZ_INS_WFMINDB,
	SYSZ_INS_WFMINSB,
	SYSZ_INS_WFMINXB,
	SYSZ_INS_WFMSB,
	SYSZ_INS_WFMSDB,
	SYSZ_INS_WFMSSB,
	SYSZ_INS_WFMSXB,
	SYSZ_INS_WFMXB,
	SYSZ_INS_WFNMADB,
	SYSZ_INS_WFNMASB,
	SYSZ_INS_WFNMAXB,
	SYSZ_INS_WFNMSDB,
	SYSZ_INS_WFNMSSB,
	SYSZ_INS_WFNMSXB,
	SYSZ_INS_WFPSODB,
	SYSZ_INS_WFPSOSB,
	SYSZ_INS_WFPSOXB,
	SYSZ_INS_WFSDB,
	SYSZ_INS_WFSQDB,
	SYSZ_INS_WFSQSB,
	SYSZ_INS_WFSQXB,
	SYSZ_INS_WFSSB,
	SYSZ_INS_WFSXB,
	SYSZ_INS_WFTCIDB,
	SYSZ_INS_WFTCISB,
	SYSZ_INS_WFTCIXB,
	SYSZ_INS_WLDEB,
	SYSZ_INS_WLEDB,
	SYSZ_INS_XSCH,
	SYSZ_INS_ZAP,

	SYSZ_INS_ENDING,   // <-- mark the end of the list of instructions
} sysz_insn;

/// Group of SystemZ instructions
typedef enum sysz_insn_group {
	SYSZ_GRP_INVALID = 0, ///< = CS_GRP_INVALID

	// Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	SYSZ_GRP_JUMP,	///< = CS_GRP_JUMP

	// Architecture-specific groups
	SYSZ_GRP_DISTINCTOPS = 128,
	SYSZ_GRP_FPEXTENSION,
	SYSZ_GRP_HIGHWORD,
	SYSZ_GRP_INTERLOCKEDACCESS1,
	SYSZ_GRP_LOADSTOREONCOND,
	SYSZ_GRP_DFPPACKEDCONVERSION,
	SYSZ_GRP_DFPZONEDCONVERSION,
	SYSZ_GRP_ENHANCEDDAT2,
	SYSZ_GRP_EXECUTIONHINT,
	SYSZ_GRP_GUARDEDSTORAGE,
	SYSZ_GRP_INSERTREFERENCEBITSMULTIPLE,
	SYSZ_GRP_LOADANDTRAP,
	SYSZ_GRP_LOADANDZERORIGHTMOSTBYTE,
	SYSZ_GRP_LOADSTOREONCOND2,
	SYSZ_GRP_MESSAGESECURITYASSIST3,
	SYSZ_GRP_MESSAGESECURITYASSIST4,
	SYSZ_GRP_MESSAGESECURITYASSIST5,
	SYSZ_GRP_MESSAGESECURITYASSIST7,
	SYSZ_GRP_MESSAGESECURITYASSIST8,
	SYSZ_GRP_MISCELLANEOUSEXTENSIONS,
	SYSZ_GRP_MISCELLANEOUSEXTENSIONS2,
	SYSZ_GRP_NOVECTOR,
	SYSZ_GRP_POPULATIONCOUNT,
	SYSZ_GRP_PROCESSORASSIST,
	SYSZ_GRP_RESETREFERENCEBITSMULTIPLE,
	SYSZ_GRP_TRANSACTIONALEXECUTION,
	SYSZ_GRP_VECTOR,
	SYSZ_GRP_VECTORENHANCEMENTS1,
	SYSZ_GRP_VECTORPACKEDDECIMAL,

	SYSZ_GRP_ENDING,   // <-- mark the end of the list of groups
} sysz_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`capstone/include/capstone/tms320c64x.h`:

```h
/* Capstone Disassembly Engine */
/* TMS320C64x Backend by Fotis Loukos <me@fotisl.com> 2016 */

#ifndef CAPSTONE_TMS320C64X_H
#define CAPSTONE_TMS320C64X_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

typedef enum tms320c64x_op_type {
	TMS320C64X_OP_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	TMS320C64X_OP_REG, ///< = CS_OP_REG (Register operand).
	TMS320C64X_OP_IMM, ///< = CS_OP_IMM (Immediate operand).
	TMS320C64X_OP_MEM, ///< = CS_OP_MEM (Memory operand).
	TMS320C64X_OP_REGPAIR = 64, ///< Register pair for double word ops
} tms320c64x_op_type;

typedef enum tms320c64x_mem_disp {
	TMS320C64X_MEM_DISP_INVALID = 0,
	TMS320C64X_MEM_DISP_CONSTANT,
	TMS320C64X_MEM_DISP_REGISTER,
} tms320c64x_mem_disp;

typedef enum tms320c64x_mem_dir {
	TMS320C64X_MEM_DIR_INVALID = 0,
	TMS320C64X_MEM_DIR_FW,
	TMS320C64X_MEM_DIR_BW,
} tms320c64x_mem_dir;

typedef enum tms320c64x_mem_mod {
	TMS320C64X_MEM_MOD_INVALID = 0,
	TMS320C64X_MEM_MOD_NO,
	TMS320C64X_MEM_MOD_PRE,
	TMS320C64X_MEM_MOD_POST,
} tms320c64x_mem_mod;

typedef struct tms320c64x_op_mem {
	unsigned int	base;	///< base register
	unsigned int	disp;	///< displacement/offset value
	unsigned int	unit;	///< unit of base and offset register
	unsigned int	scaled;	///< offset scaled
	unsigned int	disptype;	///< displacement type
	unsigned int	direction;	///< direction
	unsigned int	modify;	///< modification
} tms320c64x_op_mem;

typedef struct cs_tms320c64x_op {
	tms320c64x_op_type type;	///< operand type
	union {
		unsigned int reg;	///< register value for REG operand or first register for REGPAIR operand
		int32_t imm;		///< immediate value for IMM operand
		tms320c64x_op_mem mem;		///< base/disp value for MEM operand
	};
} cs_tms320c64x_op;

typedef struct cs_tms320c64x {
	uint8_t op_count;
	cs_tms320c64x_op operands[8]; ///< operands for this instruction.
	struct {
		unsigned int reg;
		unsigned int zero;
	} condition;
	struct {
		unsigned int unit;
		unsigned int side;
		unsigned int crosspath;
	} funit;
	unsigned int parallel;
} cs_tms320c64x;

typedef enum tms320c64x_reg {
	TMS320C64X_REG_INVALID = 0,

	TMS320C64X_REG_AMR,
	TMS320C64X_REG_CSR,
	TMS320C64X_REG_DIER,
	TMS320C64X_REG_DNUM,
	TMS320C64X_REG_ECR,
	TMS320C64X_REG_GFPGFR,
	TMS320C64X_REG_GPLYA,
	TMS320C64X_REG_GPLYB,
	TMS320C64X_REG_ICR,
	TMS320C64X_REG_IER,
	TMS320C64X_REG_IERR,
	TMS320C64X_REG_ILC,
	TMS320C64X_REG_IRP,
	TMS320C64X_REG_ISR,
	TMS320C64X_REG_ISTP,
	TMS320C64X_REG_ITSR,
	TMS320C64X_REG_NRP,
	TMS320C64X_REG_NTSR,
	TMS320C64X_REG_REP,
	TMS320C64X_REG_RILC,
	TMS320C64X_REG_SSR,
	TMS320C64X_REG_TSCH,
	TMS320C64X_REG_TSCL,
	TMS320C64X_REG_TSR,
	TMS320C64X_REG_A0,
	TMS320C64X_REG_A1,
	TMS320C64X_REG_A2,
	TMS320C64X_REG_A3,
	TMS320C64X_REG_A4,
	TMS320C64X_REG_A5,
	TMS320C64X_REG_A6,
	TMS320C64X_REG_A7,
	TMS320C64X_REG_A8,
	TMS320C64X_REG_A9,
	TMS320C64X_REG_A10,
	TMS320C64X_REG_A11,
	TMS320C64X_REG_A12,
	TMS320C64X_REG_A13,
	TMS320C64X_REG_A14,
	TMS320C64X_REG_A15,
	TMS320C64X_REG_A16,
	TMS320C64X_REG_A17,
	TMS320C64X_REG_A18,
	TMS320C64X_REG_A19,
	TMS320C64X_REG_A20,
	TMS320C64X_REG_A21,
	TMS320C64X_REG_A22,
	TMS320C64X_REG_A23,
	TMS320C64X_REG_A24,
	TMS320C64X_REG_A25,
	TMS320C64X_REG_A26,
	TMS320C64X_REG_A27,
	TMS320C64X_REG_A28,
	TMS320C64X_REG_A29,
	TMS320C64X_REG_A30,
	TMS320C64X_REG_A31,
	TMS320C64X_REG_B0,
	TMS320C64X_REG_B1,
	TMS320C64X_REG_B2,
	TMS320C64X_REG_B3,
	TMS320C64X_REG_B4,
	TMS320C64X_REG_B5,
	TMS320C64X_REG_B6,
	TMS320C64X_REG_B7,
	TMS320C64X_REG_B8,
	TMS320C64X_REG_B9,
	TMS320C64X_REG_B10,
	TMS320C64X_REG_B11,
	TMS320C64X_REG_B12,
	TMS320C64X_REG_B13,
	TMS320C64X_REG_B14,
	TMS320C64X_REG_B15,
	TMS320C64X_REG_B16,
	TMS320C64X_REG_B17,
	TMS320C64X_REG_B18,
	TMS320C64X_REG_B19,
	TMS320C64X_REG_B20,
	TMS320C64X_REG_B21,
	TMS320C64X_REG_B22,
	TMS320C64X_REG_B23,
	TMS320C64X_REG_B24,
	TMS320C64X_REG_B25,
	TMS320C64X_REG_B26,
	TMS320C64X_REG_B27,
	TMS320C64X_REG_B28,
	TMS320C64X_REG_B29,
	TMS320C64X_REG_B30,
	TMS320C64X_REG_B31,
	TMS320C64X_REG_PCE1,

	TMS320C64X_REG_ENDING,	// <-- mark the end of the list of registers

	// Alias registers
	TMS320C64X_REG_EFR = TMS320C64X_REG_ECR,
	TMS320C64X_REG_IFR = TMS320C64X_REG_ISR,
} tms320c64x_reg;

typedef enum tms320c64x_insn {
	TMS320C64X_INS_INVALID = 0,

	TMS320C64X_INS_ABS,
	TMS320C64X_INS_ABS2,
	TMS320C64X_INS_ADD,
	TMS320C64X_INS_ADD2,
	TMS320C64X_INS_ADD4,
	TMS320C64X_INS_ADDAB,
	TMS320C64X_INS_ADDAD,
	TMS320C64X_INS_ADDAH,
	TMS320C64X_INS_ADDAW,
	TMS320C64X_INS_ADDK,
	TMS320C64X_INS_ADDKPC,
	TMS320C64X_INS_ADDU,
	TMS320C64X_INS_AND,
	TMS320C64X_INS_ANDN,
	TMS320C64X_INS_AVG2,
	TMS320C64X_INS_AVGU4,
	TMS320C64X_INS_B,
	TMS320C64X_INS_BDEC,
	TMS320C64X_INS_BITC4,
	TMS320C64X_INS_BNOP,
	TMS320C64X_INS_BPOS,
	TMS320C64X_INS_CLR,
	TMS320C64X_INS_CMPEQ,
	TMS320C64X_INS_CMPEQ2,
	TMS320C64X_INS_CMPEQ4,
	TMS320C64X_INS_CMPGT,
	TMS320C64X_INS_CMPGT2,
	TMS320C64X_INS_CMPGTU4,
	TMS320C64X_INS_CMPLT,
	TMS320C64X_INS_CMPLTU,
	TMS320C64X_INS_DEAL,
	TMS320C64X_INS_DOTP2,
	TMS320C64X_INS_DOTPN2,
	TMS320C64X_INS_DOTPNRSU2,
	TMS320C64X_INS_DOTPRSU2,
	TMS320C64X_INS_DOTPSU4,
	TMS320C64X_INS_DOTPU4,
	TMS320C64X_INS_EXT,
	TMS320C64X_INS_EXTU,
	TMS320C64X_INS_GMPGTU,
	TMS320C64X_INS_GMPY4,
	TMS320C64X_INS_LDB,
	TMS320C64X_INS_LDBU,
	TMS320C64X_INS_LDDW,
	TMS320C64X_INS_LDH,
	TMS320C64X_INS_LDHU,
	TMS320C64X_INS_LDNDW,
	TMS320C64X_INS_LDNW,
	TMS320C64X_INS_LDW,
	TMS320C64X_INS_LMBD,
	TMS320C64X_INS_MAX2,
	TMS320C64X_INS_MAXU4,
	TMS320C64X_INS_MIN2,
	TMS320C64X_INS_MINU4,
	TMS320C64X_INS_MPY,
	TMS320C64X_INS_MPY2,
	TMS320C64X_INS_MPYH,
	TMS320C64X_INS_MPYHI,
	TMS320C64X_INS_MPYHIR,
	TMS320C64X_INS_MPYHL,
	TMS320C64X_INS_MPYHLU,
	TMS320C64X_INS_MPYHSLU,
	TMS320C64X_INS_MPYHSU,
	TMS320C64X_INS_MPYHU,
	TMS320C64X_INS_MPYHULS,
	TMS320C64X_INS_MPYHUS,
	TMS320C64X_INS_MPYLH,
	TMS320C64X_INS_MPYLHU,
	TMS320C64X_INS_MPYLI,
	TMS320C64X_INS_MPYLIR,
	TMS320C64X_INS_MPYLSHU,
	TMS320C64X_INS_MPYLUHS,
	TMS320C64X_INS_MPYSU,
	TMS320C64X_INS_MPYSU4,
	TMS320C64X_INS_MPYU,
	TMS320C64X_INS_MPYU4,
	TMS320C64X_INS_MPYUS,
	TMS320C64X_INS_MVC,
	TMS320C64X_INS_MVD,
	TMS320C64X_INS_MVK,
	TMS320C64X_INS_MVKL,
	TMS320C64X_INS_MVKLH,
	TMS320C64X_INS_NOP,
	TMS320C64X_INS_NORM,
	TMS320C64X_INS_OR,
	TMS320C64X_INS_PACK2,
	TMS320C64X_INS_PACKH2,
	TMS320C64X_INS_PACKH4,
	TMS320C64X_INS_PACKHL2,
	TMS320C64X_INS_PACKL4,
	TMS320C64X_INS_PACKLH2,
	TMS320C64X_INS_ROTL,
	TMS320C64X_INS_SADD,
	TMS320C64X_INS_SADD2,
	TMS320C64X_INS_SADDU4,
	TMS320C64X_INS_SADDUS2,
	TMS320C64X_INS_SAT,
	TMS320C64X_INS_SET,
	TMS320C64X_INS_SHFL,
	TMS320C64X_INS_SHL,
	TMS320C64X_INS_SHLMB,
	TMS320C64X_INS_SHR,
	TMS320C64X_INS_SHR2,
	TMS320C64X_INS_SHRMB,
	TMS320C64X_INS_SHRU,
	TMS320C64X_INS_SHRU2,
	TMS320C64X_INS_SMPY,
	TMS320C64X_INS_SMPY2,
	TMS320C64X_INS_SMPYH,
	TMS320C64X_INS_SMPYHL,
	TMS320C64X_INS_SMPYLH,
	TMS320C64X_INS_SPACK2,
	TMS320C64X_INS_SPACKU4,
	TMS320C64X_INS_SSHL,
	TMS320C64X_INS_SSHVL,
	TMS320C64X_INS_SSHVR,
	TMS320C64X_INS_SSUB,
	TMS320C64X_INS_STB,
	TMS320C64X_INS_STDW,
	TMS320C64X_INS_STH,
	TMS320C64X_INS_STNDW,
	TMS320C64X_INS_STNW,
	TMS320C64X_INS_STW,
	TMS320C64X_INS_SUB,
	TMS320C64X_INS_SUB2,
	TMS320C64X_INS_SUB4,
	TMS320C64X_INS_SUBAB,
	TMS320C64X_INS_SUBABS4,
	TMS320C64X_INS_SUBAH,
	TMS320C64X_INS_SUBAW,
	TMS320C64X_INS_SUBC,
	TMS320C64X_INS_SUBU,
	TMS320C64X_INS_SWAP4,
	TMS320C64X_INS_UNPKHU4,
	TMS320C64X_INS_UNPKLU4,
	TMS320C64X_INS_XOR,
	TMS320C64X_INS_XPND2,
	TMS320C64X_INS_XPND4,
	// Aliases
	TMS320C64X_INS_IDLE,
	TMS320C64X_INS_MV,
	TMS320C64X_INS_NEG,
	TMS320C64X_INS_NOT,
	TMS320C64X_INS_SWAP2,
	TMS320C64X_INS_ZERO,

	TMS320C64X_INS_ENDING,   // <-- mark the end of the list of instructions
} tms320c64x_insn;

typedef enum tms320c64x_insn_group {
	TMS320C64X_GRP_INVALID = 0, ///< = CS_GRP_INVALID

	TMS320C64X_GRP_JUMP,	///< = CS_GRP_JUMP

	TMS320C64X_GRP_FUNIT_D = 128,
	TMS320C64X_GRP_FUNIT_L,
	TMS320C64X_GRP_FUNIT_M,
	TMS320C64X_GRP_FUNIT_S,
	TMS320C64X_GRP_FUNIT_NO,

	TMS320C64X_GRP_ENDING,   // <-- mark the end of the list of groups
} tms320c64x_insn_group;

typedef enum tms320c64x_funit {
	TMS320C64X_FUNIT_INVALID = 0,
	TMS320C64X_FUNIT_D,
	TMS320C64X_FUNIT_L,
	TMS320C64X_FUNIT_M,
	TMS320C64X_FUNIT_S,
	TMS320C64X_FUNIT_NO
} tms320c64x_funit;

#ifdef __cplusplus
}
#endif

#endif


```

`capstone/include/capstone/x86.h`:

```h
#ifndef CAPSTONE_X86_H
#define CAPSTONE_X86_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

/// Calculate relative address for X86-64, given cs_insn structure
#define X86_REL_ADDR(insn) (((insn).detail->x86.operands[0].type == X86_OP_IMM) \
	? (uint64_t)((insn).detail->x86.operands[0].imm) \
	: (((insn).address + (insn).size) + (uint64_t)(insn).detail->x86.disp))

/// X86 registers
typedef enum x86_reg {
	X86_REG_INVALID = 0,
	X86_REG_AH, X86_REG_AL, X86_REG_AX, X86_REG_BH, X86_REG_BL,
	X86_REG_BP, X86_REG_BPL, X86_REG_BX, X86_REG_CH, X86_REG_CL,
	X86_REG_CS, X86_REG_CX, X86_REG_DH, X86_REG_DI, X86_REG_DIL,
	X86_REG_DL, X86_REG_DS, X86_REG_DX, X86_REG_EAX, X86_REG_EBP,
	X86_REG_EBX, X86_REG_ECX, X86_REG_EDI, X86_REG_EDX, X86_REG_EFLAGS,
	X86_REG_EIP, X86_REG_EIZ, X86_REG_ES, X86_REG_ESI, X86_REG_ESP,
	X86_REG_FPSW, X86_REG_FS, X86_REG_GS, X86_REG_IP, X86_REG_RAX,
	X86_REG_RBP, X86_REG_RBX, X86_REG_RCX, X86_REG_RDI, X86_REG_RDX,
	X86_REG_RIP, X86_REG_RIZ, X86_REG_RSI, X86_REG_RSP, X86_REG_SI,
	X86_REG_SIL, X86_REG_SP, X86_REG_SPL, X86_REG_SS, X86_REG_CR0,
	X86_REG_CR1, X86_REG_CR2, X86_REG_CR3, X86_REG_CR4, X86_REG_CR5,
	X86_REG_CR6, X86_REG_CR7, X86_REG_CR8, X86_REG_CR9, X86_REG_CR10,
	X86_REG_CR11, X86_REG_CR12, X86_REG_CR13, X86_REG_CR14, X86_REG_CR15,
	X86_REG_DR0, X86_REG_DR1, X86_REG_DR2, X86_REG_DR3, X86_REG_DR4,
	X86_REG_DR5, X86_REG_DR6, X86_REG_DR7, X86_REG_DR8, X86_REG_DR9,
	X86_REG_DR10, X86_REG_DR11, X86_REG_DR12, X86_REG_DR13, X86_REG_DR14,
	X86_REG_DR15, X86_REG_FP0, X86_REG_FP1, X86_REG_FP2, X86_REG_FP3,
	X86_REG_FP4, X86_REG_FP5, X86_REG_FP6, X86_REG_FP7,
	X86_REG_K0, X86_REG_K1, X86_REG_K2, X86_REG_K3, X86_REG_K4,
	X86_REG_K5, X86_REG_K6, X86_REG_K7, X86_REG_MM0, X86_REG_MM1,
	X86_REG_MM2, X86_REG_MM3, X86_REG_MM4, X86_REG_MM5, X86_REG_MM6,
	X86_REG_MM7, X86_REG_R8, X86_REG_R9, X86_REG_R10, X86_REG_R11,
	X86_REG_R12, X86_REG_R13, X86_REG_R14, X86_REG_R15,
	X86_REG_ST0, X86_REG_ST1, X86_REG_ST2, X86_REG_ST3,
	X86_REG_ST4, X86_REG_ST5, X86_REG_ST6, X86_REG_ST7,
	X86_REG_XMM0, X86_REG_XMM1, X86_REG_XMM2, X86_REG_XMM3, X86_REG_XMM4,
	X86_REG_XMM5, X86_REG_XMM6, X86_REG_XMM7, X86_REG_XMM8, X86_REG_XMM9,
	X86_REG_XMM10, X86_REG_XMM11, X86_REG_XMM12, X86_REG_XMM13, X86_REG_XMM14,
	X86_REG_XMM15, X86_REG_XMM16, X86_REG_XMM17, X86_REG_XMM18, X86_REG_XMM19,
	X86_REG_XMM20, X86_REG_XMM21, X86_REG_XMM22, X86_REG_XMM23, X86_REG_XMM24,
	X86_REG_XMM25, X86_REG_XMM26, X86_REG_XMM27, X86_REG_XMM28, X86_REG_XMM29,
	X86_REG_XMM30, X86_REG_XMM31, X86_REG_YMM0, X86_REG_YMM1, X86_REG_YMM2,
	X86_REG_YMM3, X86_REG_YMM4, X86_REG_YMM5, X86_REG_YMM6, X86_REG_YMM7,
	X86_REG_YMM8, X86_REG_YMM9, X86_REG_YMM10, X86_REG_YMM11, X86_REG_YMM12,
	X86_REG_YMM13, X86_REG_YMM14, X86_REG_YMM15, X86_REG_YMM16, X86_REG_YMM17,
	X86_REG_YMM18, X86_REG_YMM19, X86_REG_YMM20, X86_REG_YMM21, X86_REG_YMM22,
	X86_REG_YMM23, X86_REG_YMM24, X86_REG_YMM25, X86_REG_YMM26, X86_REG_YMM27,
	X86_REG_YMM28, X86_REG_YMM29, X86_REG_YMM30, X86_REG_YMM31, X86_REG_ZMM0,
	X86_REG_ZMM1, X86_REG_ZMM2, X86_REG_ZMM3, X86_REG_ZMM4, X86_REG_ZMM5,
	X86_REG_ZMM6, X86_REG_ZMM7, X86_REG_ZMM8, X86_REG_ZMM9, X86_REG_ZMM10,
	X86_REG_ZMM11, X86_REG_ZMM12, X86_REG_ZMM13, X86_REG_ZMM14, X86_REG_ZMM15,
	X86_REG_ZMM16, X86_REG_ZMM17, X86_REG_ZMM18, X86_REG_ZMM19, X86_REG_ZMM20,
	X86_REG_ZMM21, X86_REG_ZMM22, X86_REG_ZMM23, X86_REG_ZMM24, X86_REG_ZMM25,
	X86_REG_ZMM26, X86_REG_ZMM27, X86_REG_ZMM28, X86_REG_ZMM29, X86_REG_ZMM30,
	X86_REG_ZMM31, X86_REG_R8B, X86_REG_R9B, X86_REG_R10B, X86_REG_R11B,
	X86_REG_R12B, X86_REG_R13B, X86_REG_R14B, X86_REG_R15B, X86_REG_R8D,
	X86_REG_R9D, X86_REG_R10D, X86_REG_R11D, X86_REG_R12D, X86_REG_R13D,
	X86_REG_R14D, X86_REG_R15D, X86_REG_R8W, X86_REG_R9W, X86_REG_R10W,
	X86_REG_R11W, X86_REG_R12W, X86_REG_R13W, X86_REG_R14W, X86_REG_R15W,

	X86_REG_ENDING		// <-- mark the end of the list of registers
} x86_reg;

// Sub-flags of EFLAGS
#define X86_EFLAGS_MODIFY_AF (1ULL << 0)
#define X86_EFLAGS_MODIFY_CF (1ULL << 1)
#define X86_EFLAGS_MODIFY_SF (1ULL << 2)
#define X86_EFLAGS_MODIFY_ZF (1ULL << 3)
#define X86_EFLAGS_MODIFY_PF (1ULL << 4)
#define X86_EFLAGS_MODIFY_OF (1ULL << 5)
#define X86_EFLAGS_MODIFY_TF (1ULL << 6)
#define X86_EFLAGS_MODIFY_IF (1ULL << 7)
#define X86_EFLAGS_MODIFY_DF (1ULL << 8)
#define X86_EFLAGS_MODIFY_NT (1ULL << 9)
#define X86_EFLAGS_MODIFY_RF (1ULL << 10)
#define X86_EFLAGS_PRIOR_OF (1ULL << 11)
#define X86_EFLAGS_PRIOR_SF (1ULL << 12)
#define X86_EFLAGS_PRIOR_ZF (1ULL << 13)
#define X86_EFLAGS_PRIOR_AF (1ULL << 14)
#define X86_EFLAGS_PRIOR_PF (1ULL << 15)
#define X86_EFLAGS_PRIOR_CF (1ULL << 16)
#define X86_EFLAGS_PRIOR_TF (1ULL << 17)
#define X86_EFLAGS_PRIOR_IF (1ULL << 18)
#define X86_EFLAGS_PRIOR_DF (1ULL << 19)
#define X86_EFLAGS_PRIOR_NT (1ULL << 20)
#define X86_EFLAGS_RESET_OF (1ULL << 21)
#define X86_EFLAGS_RESET_CF (1ULL << 22)
#define X86_EFLAGS_RESET_DF (1ULL << 23)
#define X86_EFLAGS_RESET_IF (1ULL << 24)
#define X86_EFLAGS_RESET_SF (1ULL << 25)
#define X86_EFLAGS_RESET_AF (1ULL << 26)
#define X86_EFLAGS_RESET_TF (1ULL << 27)
#define X86_EFLAGS_RESET_NT (1ULL << 28)
#define X86_EFLAGS_RESET_PF (1ULL << 29)
#define X86_EFLAGS_SET_CF (1ULL << 30)
#define X86_EFLAGS_SET_DF (1ULL << 31)
#define X86_EFLAGS_SET_IF (1ULL << 32)
#define X86_EFLAGS_TEST_OF (1ULL << 33)
#define X86_EFLAGS_TEST_SF (1ULL << 34)
#define X86_EFLAGS_TEST_ZF (1ULL << 35)
#define X86_EFLAGS_TEST_PF (1ULL << 36)
#define X86_EFLAGS_TEST_CF (1ULL << 37)
#define X86_EFLAGS_TEST_NT (1ULL << 38)
#define X86_EFLAGS_TEST_DF (1ULL << 39)
#define X86_EFLAGS_UNDEFINED_OF (1ULL << 40)
#define X86_EFLAGS_UNDEFINED_SF (1ULL << 41)
#define X86_EFLAGS_UNDEFINED_ZF (1ULL << 42)
#define X86_EFLAGS_UNDEFINED_PF (1ULL << 43)
#define X86_EFLAGS_UNDEFINED_AF (1ULL << 44)
#define X86_EFLAGS_UNDEFINED_CF (1ULL << 45)
#define X86_EFLAGS_RESET_RF (1ULL << 46)
#define X86_EFLAGS_TEST_RF (1ULL << 47)
#define X86_EFLAGS_TEST_IF (1ULL << 48)
#define X86_EFLAGS_TEST_TF (1ULL << 49)
#define X86_EFLAGS_TEST_AF (1ULL << 50)
#define X86_EFLAGS_RESET_ZF (1ULL << 51)
#define X86_EFLAGS_SET_OF (1ULL << 52)
#define X86_EFLAGS_SET_SF (1ULL << 53)
#define X86_EFLAGS_SET_ZF (1ULL << 54)
#define X86_EFLAGS_SET_AF (1ULL << 55)
#define X86_EFLAGS_SET_PF (1ULL << 56)
#define X86_EFLAGS_RESET_0F (1ULL << 57)
#define X86_EFLAGS_RESET_AC (1ULL << 58)

#define X86_FPU_FLAGS_MODIFY_C0 (1ULL << 0)
#define X86_FPU_FLAGS_MODIFY_C1 (1ULL << 1)
#define X86_FPU_FLAGS_MODIFY_C2 (1ULL << 2)
#define X86_FPU_FLAGS_MODIFY_C3 (1ULL << 3)
#define X86_FPU_FLAGS_RESET_C0 (1ULL << 4)
#define X86_FPU_FLAGS_RESET_C1 (1ULL << 5)
#define X86_FPU_FLAGS_RESET_C2 (1ULL << 6)
#define X86_FPU_FLAGS_RESET_C3 (1ULL << 7)
#define X86_FPU_FLAGS_SET_C0 (1ULL << 8)
#define X86_FPU_FLAGS_SET_C1 (1ULL << 9)
#define X86_FPU_FLAGS_SET_C2 (1ULL << 10)
#define X86_FPU_FLAGS_SET_C3 (1ULL << 11)
#define X86_FPU_FLAGS_UNDEFINED_C0 (1ULL << 12)
#define X86_FPU_FLAGS_UNDEFINED_C1 (1ULL << 13)
#define X86_FPU_FLAGS_UNDEFINED_C2 (1ULL << 14)
#define X86_FPU_FLAGS_UNDEFINED_C3 (1ULL << 15)
#define X86_FPU_FLAGS_TEST_C0 (1ULL << 16)
#define X86_FPU_FLAGS_TEST_C1 (1ULL << 17)
#define X86_FPU_FLAGS_TEST_C2 (1ULL << 18)
#define X86_FPU_FLAGS_TEST_C3 (1ULL << 19)


/// Operand type for instruction's operands
typedef enum x86_op_type {
	X86_OP_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	X86_OP_REG, ///< = CS_OP_REG (Register operand).
	X86_OP_IMM, ///< = CS_OP_IMM (Immediate operand).
	X86_OP_MEM, ///< = CS_OP_MEM (Memory operand).
} x86_op_type;

/// XOP Code Condition type
typedef enum x86_xop_cc {
	X86_XOP_CC_INVALID = 0,	///< Uninitialized.
	X86_XOP_CC_LT,
	X86_XOP_CC_LE,
	X86_XOP_CC_GT,
	X86_XOP_CC_GE,
	X86_XOP_CC_EQ,
	X86_XOP_CC_NEQ,
	X86_XOP_CC_FALSE,
	X86_XOP_CC_TRUE,
} x86_xop_cc;

/// AVX broadcast type
typedef enum x86_avx_bcast {
	X86_AVX_BCAST_INVALID = 0,	///< Uninitialized.
	X86_AVX_BCAST_2,	///< AVX512 broadcast type {1to2}
	X86_AVX_BCAST_4,	///< AVX512 broadcast type {1to4}
	X86_AVX_BCAST_8,	///< AVX512 broadcast type {1to8}
	X86_AVX_BCAST_16,	///< AVX512 broadcast type {1to16}
} x86_avx_bcast;

/// SSE Code Condition type
typedef enum x86_sse_cc {
	X86_SSE_CC_INVALID = 0,	///< Uninitialized.
	X86_SSE_CC_EQ,
	X86_SSE_CC_LT,
	X86_SSE_CC_LE,
	X86_SSE_CC_UNORD,
	X86_SSE_CC_NEQ,
	X86_SSE_CC_NLT,
	X86_SSE_CC_NLE,
	X86_SSE_CC_ORD,
} x86_sse_cc;

/// AVX Code Condition type
typedef enum x86_avx_cc {
	X86_AVX_CC_INVALID = 0,	///< Uninitialized.
	X86_AVX_CC_EQ,
	X86_AVX_CC_LT,
	X86_AVX_CC_LE,
	X86_AVX_CC_UNORD,
	X86_AVX_CC_NEQ,
	X86_AVX_CC_NLT,
	X86_AVX_CC_NLE,
	X86_AVX_CC_ORD,
	X86_AVX_CC_EQ_UQ,
	X86_AVX_CC_NGE,
	X86_AVX_CC_NGT,
	X86_AVX_CC_FALSE,
	X86_AVX_CC_NEQ_OQ,
	X86_AVX_CC_GE,
	X86_AVX_CC_GT,
	X86_AVX_CC_TRUE,
	X86_AVX_CC_EQ_OS,
	X86_AVX_CC_LT_OQ,
	X86_AVX_CC_LE_OQ,
	X86_AVX_CC_UNORD_S,
	X86_AVX_CC_NEQ_US,
	X86_AVX_CC_NLT_UQ,
	X86_AVX_CC_NLE_UQ,
	X86_AVX_CC_ORD_S,
	X86_AVX_CC_EQ_US,
	X86_AVX_CC_NGE_UQ,
	X86_AVX_CC_NGT_UQ,
	X86_AVX_CC_FALSE_OS,
	X86_AVX_CC_NEQ_OS,
	X86_AVX_CC_GE_OQ,
	X86_AVX_CC_GT_OQ,
	X86_AVX_CC_TRUE_US,
} x86_avx_cc;

/// AVX static rounding mode type
typedef enum x86_avx_rm {
	X86_AVX_RM_INVALID = 0,	///< Uninitialized.
	X86_AVX_RM_RN,	///< Round to nearest
	X86_AVX_RM_RD,	///< Round down
	X86_AVX_RM_RU,	///< Round up
	X86_AVX_RM_RZ,	///< Round toward zero
} x86_avx_rm;

/// Instruction prefixes - to be used in cs_x86.prefix[]
typedef enum x86_prefix {
	X86_PREFIX_LOCK		= 	0xf0,	///< lock (cs_x86.prefix[0]
	X86_PREFIX_REP		= 	0xf3,	///< rep (cs_x86.prefix[0]
	X86_PREFIX_REPE		= 	0xf3,	///< repe/repz (cs_x86.prefix[0]
	X86_PREFIX_REPNE	= 	0xf2,	///< repne/repnz (cs_x86.prefix[0]

	X86_PREFIX_CS		= 	0x2e,	///< segment override CS (cs_x86.prefix[1]
	X86_PREFIX_SS		= 	0x36,	///< segment override SS (cs_x86.prefix[1]
	X86_PREFIX_DS		= 	0x3e,	///< segment override DS (cs_x86.prefix[1]
	X86_PREFIX_ES		= 	0x26,	///< segment override ES (cs_x86.prefix[1]
	X86_PREFIX_FS		= 	0x64,	///< segment override FS (cs_x86.prefix[1]
	X86_PREFIX_GS		= 	0x65,	///< segment override GS (cs_x86.prefix[1]

	X86_PREFIX_OPSIZE	=	0x66,	///< operand-size override (cs_x86.prefix[2]
	X86_PREFIX_ADDRSIZE	=	0x67,	///< address-size override (cs_x86.prefix[3]
} x86_prefix;

/// Instruction's operand referring to memory
/// This is associated with X86_OP_MEM operand type above
typedef struct x86_op_mem {
	x86_reg segment; ///< segment register (or X86_REG_INVALID if irrelevant)
	x86_reg base;	///< base register (or X86_REG_INVALID if irrelevant)
	x86_reg index;	///< index register (or X86_REG_INVALID if irrelevant)
	int scale;	///< scale for index register
	int64_t disp;	///< displacement value
} x86_op_mem;

/// Instruction operand
typedef struct cs_x86_op {
		x86_op_type type;	///< operand type
		union {
			x86_reg reg;	  ///< register value for REG operand
			int64_t imm;		///< immediate value for IMM operand
			x86_op_mem mem;		///< base/index/scale/disp value for MEM operand
		};

		/// size of this operand (in bytes).
		uint8_t size;

		/// How is this operand accessed? (READ, WRITE or READ|WRITE)
		/// This field is combined of cs_ac_type.
		/// NOTE: this field is irrelevant if engine is compiled in DIET mode.
		uint8_t access;

		/// AVX broadcast type, or 0 if irrelevant
		x86_avx_bcast avx_bcast;

		/// AVX zero opmask {z}
		bool avx_zero_opmask;
} cs_x86_op;

typedef struct cs_x86_encoding {
	/// ModR/M offset, or 0 when irrelevant
	uint8_t modrm_offset;

	/// Displacement offset, or 0 when irrelevant.
	uint8_t disp_offset;
	uint8_t disp_size;

	/// Immediate offset, or 0 when irrelevant.
	uint8_t imm_offset;
	uint8_t imm_size;
} cs_x86_encoding;

/// Instruction structure
typedef struct cs_x86 {
	/// Instruction prefix, which can be up to 4 bytes.
	/// A prefix byte gets value 0 when irrelevant.
	/// prefix[0] indicates REP/REPNE/LOCK prefix (See X86_PREFIX_REP/REPNE/LOCK above)
	/// prefix[1] indicates segment override (irrelevant for x86_64):
	/// See X86_PREFIX_CS/SS/DS/ES/FS/GS above.
	/// prefix[2] indicates operand-size override (X86_PREFIX_OPSIZE)
	/// prefix[3] indicates address-size override (X86_PREFIX_ADDRSIZE)
	uint8_t prefix[4];

	/// Instruction opcode, which can be from 1 to 4 bytes in size.
	/// This contains VEX opcode as well.
	/// An trailing opcode byte gets value 0 when irrelevant.
	uint8_t opcode[4];

	/// REX prefix: only a non-zero value is relevant for x86_64
	uint8_t rex;

	/// Address size, which can be overridden with above prefix[5].
	uint8_t addr_size;

	/// ModR/M byte
	uint8_t modrm;

	/// SIB value, or 0 when irrelevant.
	uint8_t sib;

	/// Displacement value, valid if encoding.disp_offset != 0
	int64_t disp;

	/// SIB index register, or X86_REG_INVALID when irrelevant.
	x86_reg sib_index;
	/// SIB scale, only applicable if sib_index is valid.
	int8_t sib_scale;
	/// SIB base register, or X86_REG_INVALID when irrelevant.
	x86_reg sib_base;

	/// XOP Code Condition
	x86_xop_cc xop_cc;

	/// SSE Code Condition
	x86_sse_cc sse_cc;

	/// AVX Code Condition
	x86_avx_cc avx_cc;

	/// AVX Suppress all Exception
	bool avx_sae;

	/// AVX static rounding mode
	x86_avx_rm avx_rm;

	
	union {
		/// EFLAGS updated by this instruction.
		/// This can be formed from OR combination of X86_EFLAGS_* symbols in x86.h
		uint64_t eflags;
		/// FPU_FLAGS updated by this instruction.
		/// This can be formed from OR combination of X86_FPU_FLAGS_* symbols in x86.h
		uint64_t fpu_flags;
	};

	/// Number of operands of this instruction,
	/// or 0 when instruction has no operand.
	uint8_t op_count;

	cs_x86_op operands[8];	///< operands for this instruction.

	cs_x86_encoding encoding;  ///< encoding information
} cs_x86;

/// X86 instructions
typedef enum x86_insn {
	X86_INS_INVALID = 0,

	X86_INS_AAA,
	X86_INS_AAD,
	X86_INS_AAM,
	X86_INS_AAS,
	X86_INS_FABS,
	X86_INS_ADC,
	X86_INS_ADCX,
	X86_INS_ADD,
	X86_INS_ADDPD,
	X86_INS_ADDPS,
	X86_INS_ADDSD,
	X86_INS_ADDSS,
	X86_INS_ADDSUBPD,
	X86_INS_ADDSUBPS,
	X86_INS_FADD,
	X86_INS_FIADD,
	X86_INS_FADDP,
	X86_INS_ADOX,
	X86_INS_AESDECLAST,
	X86_INS_AESDEC,
	X86_INS_AESENCLAST,
	X86_INS_AESENC,
	X86_INS_AESIMC,
	X86_INS_AESKEYGENASSIST,
	X86_INS_AND,
	X86_INS_ANDN,
	X86_INS_ANDNPD,
	X86_INS_ANDNPS,
	X86_INS_ANDPD,
	X86_INS_ANDPS,
	X86_INS_ARPL,
	X86_INS_BEXTR,
	X86_INS_BLCFILL,
	X86_INS_BLCI,
	X86_INS_BLCIC,
	X86_INS_BLCMSK,
	X86_INS_BLCS,
	X86_INS_BLENDPD,
	X86_INS_BLENDPS,
	X86_INS_BLENDVPD,
	X86_INS_BLENDVPS,
	X86_INS_BLSFILL,
	X86_INS_BLSI,
	X86_INS_BLSIC,
	X86_INS_BLSMSK,
	X86_INS_BLSR,
	X86_INS_BOUND,
	X86_INS_BSF,
	X86_INS_BSR,
	X86_INS_BSWAP,
	X86_INS_BT,
	X86_INS_BTC,
	X86_INS_BTR,
	X86_INS_BTS,
	X86_INS_BZHI,
	X86_INS_CALL,
	X86_INS_CBW,
	X86_INS_CDQ,
	X86_INS_CDQE,
	X86_INS_FCHS,
	X86_INS_CLAC,
	X86_INS_CLC,
	X86_INS_CLD,
	X86_INS_CLFLUSH,
	X86_INS_CLFLUSHOPT,
	X86_INS_CLGI,
	X86_INS_CLI,
	X86_INS_CLTS,
	X86_INS_CLWB,
	X86_INS_CMC,
	X86_INS_CMOVA,
	X86_INS_CMOVAE,
	X86_INS_CMOVB,
	X86_INS_CMOVBE,
	X86_INS_FCMOVBE,
	X86_INS_FCMOVB,
	X86_INS_CMOVE,
	X86_INS_FCMOVE,
	X86_INS_CMOVG,
	X86_INS_CMOVGE,
	X86_INS_CMOVL,
	X86_INS_CMOVLE,
	X86_INS_FCMOVNBE,
	X86_INS_FCMOVNB,
	X86_INS_CMOVNE,
	X86_INS_FCMOVNE,
	X86_INS_CMOVNO,
	X86_INS_CMOVNP,
	X86_INS_FCMOVNU,
	X86_INS_CMOVNS,
	X86_INS_CMOVO,
	X86_INS_CMOVP,
	X86_INS_FCMOVU,
	X86_INS_CMOVS,
	X86_INS_CMP,
	X86_INS_CMPSB,
	X86_INS_CMPSQ,
	X86_INS_CMPSW,
	X86_INS_CMPXCHG16B,
	X86_INS_CMPXCHG,
	X86_INS_CMPXCHG8B,
	X86_INS_COMISD,
	X86_INS_COMISS,
	X86_INS_FCOMP,
	X86_INS_FCOMIP,
	X86_INS_FCOMI,
	X86_INS_FCOM,
	X86_INS_FCOS,
	X86_INS_CPUID,
	X86_INS_CQO,
	X86_INS_CRC32,
	X86_INS_CVTDQ2PD,
	X86_INS_CVTDQ2PS,
	X86_INS_CVTPD2DQ,
	X86_INS_CVTPD2PS,
	X86_INS_CVTPS2DQ,
	X86_INS_CVTPS2PD,
	X86_INS_CVTSD2SI,
	X86_INS_CVTSD2SS,
	X86_INS_CVTSI2SD,
	X86_INS_CVTSI2SS,
	X86_INS_CVTSS2SD,
	X86_INS_CVTSS2SI,
	X86_INS_CVTTPD2DQ,
	X86_INS_CVTTPS2DQ,
	X86_INS_CVTTSD2SI,
	X86_INS_CVTTSS2SI,
	X86_INS_CWD,
	X86_INS_CWDE,
	X86_INS_DAA,
	X86_INS_DAS,
	X86_INS_DATA16,
	X86_INS_DEC,
	X86_INS_DIV,
	X86_INS_DIVPD,
	X86_INS_DIVPS,
	X86_INS_FDIVR,
	X86_INS_FIDIVR,
	X86_INS_FDIVRP,
	X86_INS_DIVSD,
	X86_INS_DIVSS,
	X86_INS_FDIV,
	X86_INS_FIDIV,
	X86_INS_FDIVP,
	X86_INS_DPPD,
	X86_INS_DPPS,
	X86_INS_RET,
	X86_INS_ENCLS,
	X86_INS_ENCLU,
	X86_INS_ENTER,
	X86_INS_EXTRACTPS,
	X86_INS_EXTRQ,
	X86_INS_F2XM1,
	X86_INS_LCALL,
	X86_INS_LJMP,
	X86_INS_FBLD,
	X86_INS_FBSTP,
	X86_INS_FCOMPP,
	X86_INS_FDECSTP,
	X86_INS_FEMMS,
	X86_INS_FFREE,
	X86_INS_FICOM,
	X86_INS_FICOMP,
	X86_INS_FINCSTP,
	X86_INS_FLDCW,
	X86_INS_FLDENV,
	X86_INS_FLDL2E,
	X86_INS_FLDL2T,
	X86_INS_FLDLG2,
	X86_INS_FLDLN2,
	X86_INS_FLDPI,
	X86_INS_FNCLEX,
	X86_INS_FNINIT,
	X86_INS_FNOP,
	X86_INS_FNSTCW,
	X86_INS_FNSTSW,
	X86_INS_FPATAN,
	X86_INS_FPREM,
	X86_INS_FPREM1,
	X86_INS_FPTAN,
	X86_INS_FFREEP,
	X86_INS_FRNDINT,
	X86_INS_FRSTOR,
	X86_INS_FNSAVE,
	X86_INS_FSCALE,
	X86_INS_FSETPM,
	X86_INS_FSINCOS,
	X86_INS_FNSTENV,
	X86_INS_FXAM,
	X86_INS_FXRSTOR,
	X86_INS_FXRSTOR64,
	X86_INS_FXSAVE,
	X86_INS_FXSAVE64,
	X86_INS_FXTRACT,
	X86_INS_FYL2X,
	X86_INS_FYL2XP1,
	X86_INS_MOVAPD,
	X86_INS_MOVAPS,
	X86_INS_ORPD,
	X86_INS_ORPS,
	X86_INS_VMOVAPD,
	X86_INS_VMOVAPS,
	X86_INS_XORPD,
	X86_INS_XORPS,
	X86_INS_GETSEC,
	X86_INS_HADDPD,
	X86_INS_HADDPS,
	X86_INS_HLT,
	X86_INS_HSUBPD,
	X86_INS_HSUBPS,
	X86_INS_IDIV,
	X86_INS_FILD,
	X86_INS_IMUL,
	X86_INS_IN,
	X86_INS_INC,
	X86_INS_INSB,
	X86_INS_INSERTPS,
	X86_INS_INSERTQ,
	X86_INS_INSD,
	X86_INS_INSW,
	X86_INS_INT,
	X86_INS_INT1,
	X86_INS_INT3,
	X86_INS_INTO,
	X86_INS_INVD,
	X86_INS_INVEPT,
	X86_INS_INVLPG,
	X86_INS_INVLPGA,
	X86_INS_INVPCID,
	X86_INS_INVVPID,
	X86_INS_IRET,
	X86_INS_IRETD,
	X86_INS_IRETQ,
	X86_INS_FISTTP,
	X86_INS_FIST,
	X86_INS_FISTP,
	X86_INS_UCOMISD,
	X86_INS_UCOMISS,
	X86_INS_VCOMISD,
	X86_INS_VCOMISS,
	X86_INS_VCVTSD2SS,
	X86_INS_VCVTSI2SD,
	X86_INS_VCVTSI2SS,
	X86_INS_VCVTSS2SD,
	X86_INS_VCVTTSD2SI,
	X86_INS_VCVTTSD2USI,
	X86_INS_VCVTTSS2SI,
	X86_INS_VCVTTSS2USI,
	X86_INS_VCVTUSI2SD,
	X86_INS_VCVTUSI2SS,
	X86_INS_VUCOMISD,
	X86_INS_VUCOMISS,
	X86_INS_JAE,
	X86_INS_JA,
	X86_INS_JBE,
	X86_INS_JB,
	X86_INS_JCXZ,
	X86_INS_JECXZ,
	X86_INS_JE,
	X86_INS_JGE,
	X86_INS_JG,
	X86_INS_JLE,
	X86_INS_JL,
	X86_INS_JMP,
	X86_INS_JNE,
	X86_INS_JNO,
	X86_INS_JNP,
	X86_INS_JNS,
	X86_INS_JO,
	X86_INS_JP,
	X86_INS_JRCXZ,
	X86_INS_JS,
	X86_INS_KANDB,
	X86_INS_KANDD,
	X86_INS_KANDNB,
	X86_INS_KANDND,
	X86_INS_KANDNQ,
	X86_INS_KANDNW,
	X86_INS_KANDQ,
	X86_INS_KANDW,
	X86_INS_KMOVB,
	X86_INS_KMOVD,
	X86_INS_KMOVQ,
	X86_INS_KMOVW,
	X86_INS_KNOTB,
	X86_INS_KNOTD,
	X86_INS_KNOTQ,
	X86_INS_KNOTW,
	X86_INS_KORB,
	X86_INS_KORD,
	X86_INS_KORQ,
	X86_INS_KORTESTB,
	X86_INS_KORTESTD,
	X86_INS_KORTESTQ,
	X86_INS_KORTESTW,
	X86_INS_KORW,
	X86_INS_KSHIFTLB,
	X86_INS_KSHIFTLD,
	X86_INS_KSHIFTLQ,
	X86_INS_KSHIFTLW,
	X86_INS_KSHIFTRB,
	X86_INS_KSHIFTRD,
	X86_INS_KSHIFTRQ,
	X86_INS_KSHIFTRW,
	X86_INS_KUNPCKBW,
	X86_INS_KXNORB,
	X86_INS_KXNORD,
	X86_INS_KXNORQ,
	X86_INS_KXNORW,
	X86_INS_KXORB,
	X86_INS_KXORD,
	X86_INS_KXORQ,
	X86_INS_KXORW,
	X86_INS_LAHF,
	X86_INS_LAR,
	X86_INS_LDDQU,
	X86_INS_LDMXCSR,
	X86_INS_LDS,
	X86_INS_FLDZ,
	X86_INS_FLD1,
	X86_INS_FLD,
	X86_INS_LEA,
	X86_INS_LEAVE,
	X86_INS_LES,
	X86_INS_LFENCE,
	X86_INS_LFS,
	X86_INS_LGDT,
	X86_INS_LGS,
	X86_INS_LIDT,
	X86_INS_LLDT,
	X86_INS_LMSW,
	X86_INS_OR,
	X86_INS_SUB,
	X86_INS_XOR,
	X86_INS_LODSB,
	X86_INS_LODSD,
	X86_INS_LODSQ,
	X86_INS_LODSW,
	X86_INS_LOOP,
	X86_INS_LOOPE,
	X86_INS_LOOPNE,
	X86_INS_RETF,
	X86_INS_RETFQ,
	X86_INS_LSL,
	X86_INS_LSS,
	X86_INS_LTR,
	X86_INS_XADD,
	X86_INS_LZCNT,
	X86_INS_MASKMOVDQU,
	X86_INS_MAXPD,
	X86_INS_MAXPS,
	X86_INS_MAXSD,
	X86_INS_MAXSS,
	X86_INS_MFENCE,
	X86_INS_MINPD,
	X86_INS_MINPS,
	X86_INS_MINSD,
	X86_INS_MINSS,
	X86_INS_CVTPD2PI,
	X86_INS_CVTPI2PD,
	X86_INS_CVTPI2PS,
	X86_INS_CVTPS2PI,
	X86_INS_CVTTPD2PI,
	X86_INS_CVTTPS2PI,
	X86_INS_EMMS,
	X86_INS_MASKMOVQ,
	X86_INS_MOVD,
	X86_INS_MOVDQ2Q,
	X86_INS_MOVNTQ,
	X86_INS_MOVQ2DQ,
	X86_INS_MOVQ,
	X86_INS_PABSB,
	X86_INS_PABSD,
	X86_INS_PABSW,
	X86_INS_PACKSSDW,
	X86_INS_PACKSSWB,
	X86_INS_PACKUSWB,
	X86_INS_PADDB,
	X86_INS_PADDD,
	X86_INS_PADDQ,
	X86_INS_PADDSB,
	X86_INS_PADDSW,
	X86_INS_PADDUSB,
	X86_INS_PADDUSW,
	X86_INS_PADDW,
	X86_INS_PALIGNR,
	X86_INS_PANDN,
	X86_INS_PAND,
	X86_INS_PAVGB,
	X86_INS_PAVGW,
	X86_INS_PCMPEQB,
	X86_INS_PCMPEQD,
	X86_INS_PCMPEQW,
	X86_INS_PCMPGTB,
	X86_INS_PCMPGTD,
	X86_INS_PCMPGTW,
	X86_INS_PEXTRW,
	X86_INS_PHADDSW,
	X86_INS_PHADDW,
	X86_INS_PHADDD,
	X86_INS_PHSUBD,
	X86_INS_PHSUBSW,
	X86_INS_PHSUBW,
	X86_INS_PINSRW,
	X86_INS_PMADDUBSW,
	X86_INS_PMADDWD,
	X86_INS_PMAXSW,
	X86_INS_PMAXUB,
	X86_INS_PMINSW,
	X86_INS_PMINUB,
	X86_INS_PMOVMSKB,
	X86_INS_PMULHRSW,
	X86_INS_PMULHUW,
	X86_INS_PMULHW,
	X86_INS_PMULLW,
	X86_INS_PMULUDQ,
	X86_INS_POR,
	X86_INS_PSADBW,
	X86_INS_PSHUFB,
	X86_INS_PSHUFW,
	X86_INS_PSIGNB,
	X86_INS_PSIGND,
	X86_INS_PSIGNW,
	X86_INS_PSLLD,
	X86_INS_PSLLQ,
	X86_INS_PSLLW,
	X86_INS_PSRAD,
	X86_INS_PSRAW,
	X86_INS_PSRLD,
	X86_INS_PSRLQ,
	X86_INS_PSRLW,
	X86_INS_PSUBB,
	X86_INS_PSUBD,
	X86_INS_PSUBQ,
	X86_INS_PSUBSB,
	X86_INS_PSUBSW,
	X86_INS_PSUBUSB,
	X86_INS_PSUBUSW,
	X86_INS_PSUBW,
	X86_INS_PUNPCKHBW,
	X86_INS_PUNPCKHDQ,
	X86_INS_PUNPCKHWD,
	X86_INS_PUNPCKLBW,
	X86_INS_PUNPCKLDQ,
	X86_INS_PUNPCKLWD,
	X86_INS_PXOR,
	X86_INS_MONITOR,
	X86_INS_MONTMUL,
	X86_INS_MOV,
	X86_INS_MOVABS,
	X86_INS_MOVBE,
	X86_INS_MOVDDUP,
	X86_INS_MOVDQA,
	X86_INS_MOVDQU,
	X86_INS_MOVHLPS,
	X86_INS_MOVHPD,
	X86_INS_MOVHPS,
	X86_INS_MOVLHPS,
	X86_INS_MOVLPD,
	X86_INS_MOVLPS,
	X86_INS_MOVMSKPD,
	X86_INS_MOVMSKPS,
	X86_INS_MOVNTDQA,
	X86_INS_MOVNTDQ,
	X86_INS_MOVNTI,
	X86_INS_MOVNTPD,
	X86_INS_MOVNTPS,
	X86_INS_MOVNTSD,
	X86_INS_MOVNTSS,
	X86_INS_MOVSB,
	X86_INS_MOVSD,
	X86_INS_MOVSHDUP,
	X86_INS_MOVSLDUP,
	X86_INS_MOVSQ,
	X86_INS_MOVSS,
	X86_INS_MOVSW,
	X86_INS_MOVSX,
	X86_INS_MOVSXD,
	X86_INS_MOVUPD,
	X86_INS_MOVUPS,
	X86_INS_MOVZX,
	X86_INS_MPSADBW,
	X86_INS_MUL,
	X86_INS_MULPD,
	X86_INS_MULPS,
	X86_INS_MULSD,
	X86_INS_MULSS,
	X86_INS_MULX,
	X86_INS_FMUL,
	X86_INS_FIMUL,
	X86_INS_FMULP,
	X86_INS_MWAIT,
	X86_INS_NEG,
	X86_INS_NOP,
	X86_INS_NOT,
	X86_INS_OUT,
	X86_INS_OUTSB,
	X86_INS_OUTSD,
	X86_INS_OUTSW,
	X86_INS_PACKUSDW,
	X86_INS_PAUSE,
	X86_INS_PAVGUSB,
	X86_INS_PBLENDVB,
	X86_INS_PBLENDW,
	X86_INS_PCLMULQDQ,
	X86_INS_PCMPEQQ,
	X86_INS_PCMPESTRI,
	X86_INS_PCMPESTRM,
	X86_INS_PCMPGTQ,
	X86_INS_PCMPISTRI,
	X86_INS_PCMPISTRM,
	X86_INS_PCOMMIT,
	X86_INS_PDEP,
	X86_INS_PEXT,
	X86_INS_PEXTRB,
	X86_INS_PEXTRD,
	X86_INS_PEXTRQ,
	X86_INS_PF2ID,
	X86_INS_PF2IW,
	X86_INS_PFACC,
	X86_INS_PFADD,
	X86_INS_PFCMPEQ,
	X86_INS_PFCMPGE,
	X86_INS_PFCMPGT,
	X86_INS_PFMAX,
	X86_INS_PFMIN,
	X86_INS_PFMUL,
	X86_INS_PFNACC,
	X86_INS_PFPNACC,
	X86_INS_PFRCPIT1,
	X86_INS_PFRCPIT2,
	X86_INS_PFRCP,
	X86_INS_PFRSQIT1,
	X86_INS_PFRSQRT,
	X86_INS_PFSUBR,
	X86_INS_PFSUB,
	X86_INS_PHMINPOSUW,
	X86_INS_PI2FD,
	X86_INS_PI2FW,
	X86_INS_PINSRB,
	X86_INS_PINSRD,
	X86_INS_PINSRQ,
	X86_INS_PMAXSB,
	X86_INS_PMAXSD,
	X86_INS_PMAXUD,
	X86_INS_PMAXUW,
	X86_INS_PMINSB,
	X86_INS_PMINSD,
	X86_INS_PMINUD,
	X86_INS_PMINUW,
	X86_INS_PMOVSXBD,
	X86_INS_PMOVSXBQ,
	X86_INS_PMOVSXBW,
	X86_INS_PMOVSXDQ,
	X86_INS_PMOVSXWD,
	X86_INS_PMOVSXWQ,
	X86_INS_PMOVZXBD,
	X86_INS_PMOVZXBQ,
	X86_INS_PMOVZXBW,
	X86_INS_PMOVZXDQ,
	X86_INS_PMOVZXWD,
	X86_INS_PMOVZXWQ,
	X86_INS_PMULDQ,
	X86_INS_PMULHRW,
	X86_INS_PMULLD,
	X86_INS_POP,
	X86_INS_POPAW,
	X86_INS_POPAL,
	X86_INS_POPCNT,
	X86_INS_POPF,
	X86_INS_POPFD,
	X86_INS_POPFQ,
	X86_INS_PREFETCH,
	X86_INS_PREFETCHNTA,
	X86_INS_PREFETCHT0,
	X86_INS_PREFETCHT1,
	X86_INS_PREFETCHT2,
	X86_INS_PREFETCHW,
	X86_INS_PSHUFD,
	X86_INS_PSHUFHW,
	X86_INS_PSHUFLW,
	X86_INS_PSLLDQ,
	X86_INS_PSRLDQ,
	X86_INS_PSWAPD,
	X86_INS_PTEST,
	X86_INS_PUNPCKHQDQ,
	X86_INS_PUNPCKLQDQ,
	X86_INS_PUSH,
	X86_INS_PUSHAW,
	X86_INS_PUSHAL,
	X86_INS_PUSHF,
	X86_INS_PUSHFD,
	X86_INS_PUSHFQ,
	X86_INS_RCL,
	X86_INS_RCPPS,
	X86_INS_RCPSS,
	X86_INS_RCR,
	X86_INS_RDFSBASE,
	X86_INS_RDGSBASE,
	X86_INS_RDMSR,
	X86_INS_RDPMC,
	X86_INS_RDRAND,
	X86_INS_RDSEED,
	X86_INS_RDTSC,
	X86_INS_RDTSCP,
	X86_INS_ROL,
	X86_INS_ROR,
	X86_INS_RORX,
	X86_INS_ROUNDPD,
	X86_INS_ROUNDPS,
	X86_INS_ROUNDSD,
	X86_INS_ROUNDSS,
	X86_INS_RSM,
	X86_INS_RSQRTPS,
	X86_INS_RSQRTSS,
	X86_INS_SAHF,
	X86_INS_SAL,
	X86_INS_SALC,
	X86_INS_SAR,
	X86_INS_SARX,
	X86_INS_SBB,
	X86_INS_SCASB,
	X86_INS_SCASD,
	X86_INS_SCASQ,
	X86_INS_SCASW,
	X86_INS_SETAE,
	X86_INS_SETA,
	X86_INS_SETBE,
	X86_INS_SETB,
	X86_INS_SETE,
	X86_INS_SETGE,
	X86_INS_SETG,
	X86_INS_SETLE,
	X86_INS_SETL,
	X86_INS_SETNE,
	X86_INS_SETNO,
	X86_INS_SETNP,
	X86_INS_SETNS,
	X86_INS_SETO,
	X86_INS_SETP,
	X86_INS_SETS,
	X86_INS_SFENCE,
	X86_INS_SGDT,
	X86_INS_SHA1MSG1,
	X86_INS_SHA1MSG2,
	X86_INS_SHA1NEXTE,
	X86_INS_SHA1RNDS4,
	X86_INS_SHA256MSG1,
	X86_INS_SHA256MSG2,
	X86_INS_SHA256RNDS2,
	X86_INS_SHL,
	X86_INS_SHLD,
	X86_INS_SHLX,
	X86_INS_SHR,
	X86_INS_SHRD,
	X86_INS_SHRX,
	X86_INS_SHUFPD,
	X86_INS_SHUFPS,
	X86_INS_SIDT,
	X86_INS_FSIN,
	X86_INS_SKINIT,
	X86_INS_SLDT,
	X86_INS_SMSW,
	X86_INS_SQRTPD,
	X86_INS_SQRTPS,
	X86_INS_SQRTSD,
	X86_INS_SQRTSS,
	X86_INS_FSQRT,
	X86_INS_STAC,
	X86_INS_STC,
	X86_INS_STD,
	X86_INS_STGI,
	X86_INS_STI,
	X86_INS_STMXCSR,
	X86_INS_STOSB,
	X86_INS_STOSD,
	X86_INS_STOSQ,
	X86_INS_STOSW,
	X86_INS_STR,
	X86_INS_FST,
	X86_INS_FSTP,
	X86_INS_FSTPNCE,
	X86_INS_FXCH,
	X86_INS_SUBPD,
	X86_INS_SUBPS,
	X86_INS_FSUBR,
	X86_INS_FISUBR,
	X86_INS_FSUBRP,
	X86_INS_SUBSD,
	X86_INS_SUBSS,
	X86_INS_FSUB,
	X86_INS_FISUB,
	X86_INS_FSUBP,
	X86_INS_SWAPGS,
	X86_INS_SYSCALL,
	X86_INS_SYSENTER,
	X86_INS_SYSEXIT,
	X86_INS_SYSRET,
	X86_INS_T1MSKC,
	X86_INS_TEST,
	X86_INS_UD2,
	X86_INS_FTST,
	X86_INS_TZCNT,
	X86_INS_TZMSK,
	X86_INS_FUCOMIP,
	X86_INS_FUCOMI,
	X86_INS_FUCOMPP,
	X86_INS_FUCOMP,
	X86_INS_FUCOM,
	X86_INS_UD2B,
	X86_INS_UNPCKHPD,
	X86_INS_UNPCKHPS,
	X86_INS_UNPCKLPD,
	X86_INS_UNPCKLPS,
	X86_INS_VADDPD,
	X86_INS_VADDPS,
	X86_INS_VADDSD,
	X86_INS_VADDSS,
	X86_INS_VADDSUBPD,
	X86_INS_VADDSUBPS,
	X86_INS_VAESDECLAST,
	X86_INS_VAESDEC,
	X86_INS_VAESENCLAST,
	X86_INS_VAESENC,
	X86_INS_VAESIMC,
	X86_INS_VAESKEYGENASSIST,
	X86_INS_VALIGND,
	X86_INS_VALIGNQ,
	X86_INS_VANDNPD,
	X86_INS_VANDNPS,
	X86_INS_VANDPD,
	X86_INS_VANDPS,
	X86_INS_VBLENDMPD,
	X86_INS_VBLENDMPS,
	X86_INS_VBLENDPD,
	X86_INS_VBLENDPS,
	X86_INS_VBLENDVPD,
	X86_INS_VBLENDVPS,
	X86_INS_VBROADCASTF128,
	X86_INS_VBROADCASTI32X4,
	X86_INS_VBROADCASTI64X4,
	X86_INS_VBROADCASTSD,
	X86_INS_VBROADCASTSS,
	X86_INS_VCOMPRESSPD,
	X86_INS_VCOMPRESSPS,
	X86_INS_VCVTDQ2PD,
	X86_INS_VCVTDQ2PS,
	X86_INS_VCVTPD2DQX,
	X86_INS_VCVTPD2DQ,
	X86_INS_VCVTPD2PSX,
	X86_INS_VCVTPD2PS,
	X86_INS_VCVTPD2UDQ,
	X86_INS_VCVTPH2PS,
	X86_INS_VCVTPS2DQ,
	X86_INS_VCVTPS2PD,
	X86_INS_VCVTPS2PH,
	X86_INS_VCVTPS2UDQ,
	X86_INS_VCVTSD2SI,
	X86_INS_VCVTSD2USI,
	X86_INS_VCVTSS2SI,
	X86_INS_VCVTSS2USI,
	X86_INS_VCVTTPD2DQX,
	X86_INS_VCVTTPD2DQ,
	X86_INS_VCVTTPD2UDQ,
	X86_INS_VCVTTPS2DQ,
	X86_INS_VCVTTPS2UDQ,
	X86_INS_VCVTUDQ2PD,
	X86_INS_VCVTUDQ2PS,
	X86_INS_VDIVPD,
	X86_INS_VDIVPS,
	X86_INS_VDIVSD,
	X86_INS_VDIVSS,
	X86_INS_VDPPD,
	X86_INS_VDPPS,
	X86_INS_VERR,
	X86_INS_VERW,
	X86_INS_VEXP2PD,
	X86_INS_VEXP2PS,
	X86_INS_VEXPANDPD,
	X86_INS_VEXPANDPS,
	X86_INS_VEXTRACTF128,
	X86_INS_VEXTRACTF32X4,
	X86_INS_VEXTRACTF64X4,
	X86_INS_VEXTRACTI128,
	X86_INS_VEXTRACTI32X4,
	X86_INS_VEXTRACTI64X4,
	X86_INS_VEXTRACTPS,
	X86_INS_VFMADD132PD,
	X86_INS_VFMADD132PS,
	X86_INS_VFMADDPD,
	X86_INS_VFMADD213PD,
	X86_INS_VFMADD231PD,
	X86_INS_VFMADDPS,
	X86_INS_VFMADD213PS,
	X86_INS_VFMADD231PS,
	X86_INS_VFMADDSD,
	X86_INS_VFMADD213SD,
	X86_INS_VFMADD132SD,
	X86_INS_VFMADD231SD,
	X86_INS_VFMADDSS,
	X86_INS_VFMADD213SS,
	X86_INS_VFMADD132SS,
	X86_INS_VFMADD231SS,
	X86_INS_VFMADDSUB132PD,
	X86_INS_VFMADDSUB132PS,
	X86_INS_VFMADDSUBPD,
	X86_INS_VFMADDSUB213PD,
	X86_INS_VFMADDSUB231PD,
	X86_INS_VFMADDSUBPS,
	X86_INS_VFMADDSUB213PS,
	X86_INS_VFMADDSUB231PS,
	X86_INS_VFMSUB132PD,
	X86_INS_VFMSUB132PS,
	X86_INS_VFMSUBADD132PD,
	X86_INS_VFMSUBADD132PS,
	X86_INS_VFMSUBADDPD,
	X86_INS_VFMSUBADD213PD,
	X86_INS_VFMSUBADD231PD,
	X86_INS_VFMSUBADDPS,
	X86_INS_VFMSUBADD213PS,
	X86_INS_VFMSUBADD231PS,
	X86_INS_VFMSUBPD,
	X86_INS_VFMSUB213PD,
	X86_INS_VFMSUB231PD,
	X86_INS_VFMSUBPS,
	X86_INS_VFMSUB213PS,
	X86_INS_VFMSUB231PS,
	X86_INS_VFMSUBSD,
	X86_INS_VFMSUB213SD,
	X86_INS_VFMSUB132SD,
	X86_INS_VFMSUB231SD,
	X86_INS_VFMSUBSS,
	X86_INS_VFMSUB213SS,
	X86_INS_VFMSUB132SS,
	X86_INS_VFMSUB231SS,
	X86_INS_VFNMADD132PD,
	X86_INS_VFNMADD132PS,
	X86_INS_VFNMADDPD,
	X86_INS_VFNMADD213PD,
	X86_INS_VFNMADD231PD,
	X86_INS_VFNMADDPS,
	X86_INS_VFNMADD213PS,
	X86_INS_VFNMADD231PS,
	X86_INS_VFNMADDSD,
	X86_INS_VFNMADD213SD,
	X86_INS_VFNMADD132SD,
	X86_INS_VFNMADD231SD,
	X86_INS_VFNMADDSS,
	X86_INS_VFNMADD213SS,
	X86_INS_VFNMADD132SS,
	X86_INS_VFNMADD231SS,
	X86_INS_VFNMSUB132PD,
	X86_INS_VFNMSUB132PS,
	X86_INS_VFNMSUBPD,
	X86_INS_VFNMSUB213PD,
	X86_INS_VFNMSUB231PD,
	X86_INS_VFNMSUBPS,
	X86_INS_VFNMSUB213PS,
	X86_INS_VFNMSUB231PS,
	X86_INS_VFNMSUBSD,
	X86_INS_VFNMSUB213SD,
	X86_INS_VFNMSUB132SD,
	X86_INS_VFNMSUB231SD,
	X86_INS_VFNMSUBSS,
	X86_INS_VFNMSUB213SS,
	X86_INS_VFNMSUB132SS,
	X86_INS_VFNMSUB231SS,
	X86_INS_VFRCZPD,
	X86_INS_VFRCZPS,
	X86_INS_VFRCZSD,
	X86_INS_VFRCZSS,
	X86_INS_VORPD,
	X86_INS_VORPS,
	X86_INS_VXORPD,
	X86_INS_VXORPS,
	X86_INS_VGATHERDPD,
	X86_INS_VGATHERDPS,
	X86_INS_VGATHERPF0DPD,
	X86_INS_VGATHERPF0DPS,
	X86_INS_VGATHERPF0QPD,
	X86_INS_VGATHERPF0QPS,
	X86_INS_VGATHERPF1DPD,
	X86_INS_VGATHERPF1DPS,
	X86_INS_VGATHERPF1QPD,
	X86_INS_VGATHERPF1QPS,
	X86_INS_VGATHERQPD,
	X86_INS_VGATHERQPS,
	X86_INS_VHADDPD,
	X86_INS_VHADDPS,
	X86_INS_VHSUBPD,
	X86_INS_VHSUBPS,
	X86_INS_VINSERTF128,
	X86_INS_VINSERTF32X4,
	X86_INS_VINSERTF32X8,
	X86_INS_VINSERTF64X2,
	X86_INS_VINSERTF64X4,
	X86_INS_VINSERTI128,
	X86_INS_VINSERTI32X4,
	X86_INS_VINSERTI32X8,
	X86_INS_VINSERTI64X2,
	X86_INS_VINSERTI64X4,
	X86_INS_VINSERTPS,
	X86_INS_VLDDQU,
	X86_INS_VLDMXCSR,
	X86_INS_VMASKMOVDQU,
	X86_INS_VMASKMOVPD,
	X86_INS_VMASKMOVPS,
	X86_INS_VMAXPD,
	X86_INS_VMAXPS,
	X86_INS_VMAXSD,
	X86_INS_VMAXSS,
	X86_INS_VMCALL,
	X86_INS_VMCLEAR,
	X86_INS_VMFUNC,
	X86_INS_VMINPD,
	X86_INS_VMINPS,
	X86_INS_VMINSD,
	X86_INS_VMINSS,
	X86_INS_VMLAUNCH,
	X86_INS_VMLOAD,
	X86_INS_VMMCALL,
	X86_INS_VMOVQ,
	X86_INS_VMOVDDUP,
	X86_INS_VMOVD,
	X86_INS_VMOVDQA32,
	X86_INS_VMOVDQA64,
	X86_INS_VMOVDQA,
	X86_INS_VMOVDQU16,
	X86_INS_VMOVDQU32,
	X86_INS_VMOVDQU64,
	X86_INS_VMOVDQU8,
	X86_INS_VMOVDQU,
	X86_INS_VMOVHLPS,
	X86_INS_VMOVHPD,
	X86_INS_VMOVHPS,
	X86_INS_VMOVLHPS,
	X86_INS_VMOVLPD,
	X86_INS_VMOVLPS,
	X86_INS_VMOVMSKPD,
	X86_INS_VMOVMSKPS,
	X86_INS_VMOVNTDQA,
	X86_INS_VMOVNTDQ,
	X86_INS_VMOVNTPD,
	X86_INS_VMOVNTPS,
	X86_INS_VMOVSD,
	X86_INS_VMOVSHDUP,
	X86_INS_VMOVSLDUP,
	X86_INS_VMOVSS,
	X86_INS_VMOVUPD,
	X86_INS_VMOVUPS,
	X86_INS_VMPSADBW,
	X86_INS_VMPTRLD,
	X86_INS_VMPTRST,
	X86_INS_VMREAD,
	X86_INS_VMRESUME,
	X86_INS_VMRUN,
	X86_INS_VMSAVE,
	X86_INS_VMULPD,
	X86_INS_VMULPS,
	X86_INS_VMULSD,
	X86_INS_VMULSS,
	X86_INS_VMWRITE,
	X86_INS_VMXOFF,
	X86_INS_VMXON,
	X86_INS_VPABSB,
	X86_INS_VPABSD,
	X86_INS_VPABSQ,
	X86_INS_VPABSW,
	X86_INS_VPACKSSDW,
	X86_INS_VPACKSSWB,
	X86_INS_VPACKUSDW,
	X86_INS_VPACKUSWB,
	X86_INS_VPADDB,
	X86_INS_VPADDD,
	X86_INS_VPADDQ,
	X86_INS_VPADDSB,
	X86_INS_VPADDSW,
	X86_INS_VPADDUSB,
	X86_INS_VPADDUSW,
	X86_INS_VPADDW,
	X86_INS_VPALIGNR,
	X86_INS_VPANDD,
	X86_INS_VPANDND,
	X86_INS_VPANDNQ,
	X86_INS_VPANDN,
	X86_INS_VPANDQ,
	X86_INS_VPAND,
	X86_INS_VPAVGB,
	X86_INS_VPAVGW,
	X86_INS_VPBLENDD,
	X86_INS_VPBLENDMB,
	X86_INS_VPBLENDMD,
	X86_INS_VPBLENDMQ,
	X86_INS_VPBLENDMW,
	X86_INS_VPBLENDVB,
	X86_INS_VPBLENDW,
	X86_INS_VPBROADCASTB,
	X86_INS_VPBROADCASTD,
	X86_INS_VPBROADCASTMB2Q,
	X86_INS_VPBROADCASTMW2D,
	X86_INS_VPBROADCASTQ,
	X86_INS_VPBROADCASTW,
	X86_INS_VPCLMULQDQ,
	X86_INS_VPCMOV,
	X86_INS_VPCMPB,
	X86_INS_VPCMPD,
	X86_INS_VPCMPEQB,
	X86_INS_VPCMPEQD,
	X86_INS_VPCMPEQQ,
	X86_INS_VPCMPEQW,
	X86_INS_VPCMPESTRI,
	X86_INS_VPCMPESTRM,
	X86_INS_VPCMPGTB,
	X86_INS_VPCMPGTD,
	X86_INS_VPCMPGTQ,
	X86_INS_VPCMPGTW,
	X86_INS_VPCMPISTRI,
	X86_INS_VPCMPISTRM,
	X86_INS_VPCMPQ,
	X86_INS_VPCMPUB,
	X86_INS_VPCMPUD,
	X86_INS_VPCMPUQ,
	X86_INS_VPCMPUW,
	X86_INS_VPCMPW,
	X86_INS_VPCOMB,
	X86_INS_VPCOMD,
	X86_INS_VPCOMPRESSD,
	X86_INS_VPCOMPRESSQ,
	X86_INS_VPCOMQ,
	X86_INS_VPCOMUB,
	X86_INS_VPCOMUD,
	X86_INS_VPCOMUQ,
	X86_INS_VPCOMUW,
	X86_INS_VPCOMW,
	X86_INS_VPCONFLICTD,
	X86_INS_VPCONFLICTQ,
	X86_INS_VPERM2F128,
	X86_INS_VPERM2I128,
	X86_INS_VPERMD,
	X86_INS_VPERMI2D,
	X86_INS_VPERMI2PD,
	X86_INS_VPERMI2PS,
	X86_INS_VPERMI2Q,
	X86_INS_VPERMIL2PD,
	X86_INS_VPERMIL2PS,
	X86_INS_VPERMILPD,
	X86_INS_VPERMILPS,
	X86_INS_VPERMPD,
	X86_INS_VPERMPS,
	X86_INS_VPERMQ,
	X86_INS_VPERMT2D,
	X86_INS_VPERMT2PD,
	X86_INS_VPERMT2PS,
	X86_INS_VPERMT2Q,
	X86_INS_VPEXPANDD,
	X86_INS_VPEXPANDQ,
	X86_INS_VPEXTRB,
	X86_INS_VPEXTRD,
	X86_INS_VPEXTRQ,
	X86_INS_VPEXTRW,
	X86_INS_VPGATHERDD,
	X86_INS_VPGATHERDQ,
	X86_INS_VPGATHERQD,
	X86_INS_VPGATHERQQ,
	X86_INS_VPHADDBD,
	X86_INS_VPHADDBQ,
	X86_INS_VPHADDBW,
	X86_INS_VPHADDDQ,
	X86_INS_VPHADDD,
	X86_INS_VPHADDSW,
	X86_INS_VPHADDUBD,
	X86_INS_VPHADDUBQ,
	X86_INS_VPHADDUBW,
	X86_INS_VPHADDUDQ,
	X86_INS_VPHADDUWD,
	X86_INS_VPHADDUWQ,
	X86_INS_VPHADDWD,
	X86_INS_VPHADDWQ,
	X86_INS_VPHADDW,
	X86_INS_VPHMINPOSUW,
	X86_INS_VPHSUBBW,
	X86_INS_VPHSUBDQ,
	X86_INS_VPHSUBD,
	X86_INS_VPHSUBSW,
	X86_INS_VPHSUBWD,
	X86_INS_VPHSUBW,
	X86_INS_VPINSRB,
	X86_INS_VPINSRD,
	X86_INS_VPINSRQ,
	X86_INS_VPINSRW,
	X86_INS_VPLZCNTD,
	X86_INS_VPLZCNTQ,
	X86_INS_VPMACSDD,
	X86_INS_VPMACSDQH,
	X86_INS_VPMACSDQL,
	X86_INS_VPMACSSDD,
	X86_INS_VPMACSSDQH,
	X86_INS_VPMACSSDQL,
	X86_INS_VPMACSSWD,
	X86_INS_VPMACSSWW,
	X86_INS_VPMACSWD,
	X86_INS_VPMACSWW,
	X86_INS_VPMADCSSWD,
	X86_INS_VPMADCSWD,
	X86_INS_VPMADDUBSW,
	X86_INS_VPMADDWD,
	X86_INS_VPMASKMOVD,
	X86_INS_VPMASKMOVQ,
	X86_INS_VPMAXSB,
	X86_INS_VPMAXSD,
	X86_INS_VPMAXSQ,
	X86_INS_VPMAXSW,
	X86_INS_VPMAXUB,
	X86_INS_VPMAXUD,
	X86_INS_VPMAXUQ,
	X86_INS_VPMAXUW,
	X86_INS_VPMINSB,
	X86_INS_VPMINSD,
	X86_INS_VPMINSQ,
	X86_INS_VPMINSW,
	X86_INS_VPMINUB,
	X86_INS_VPMINUD,
	X86_INS_VPMINUQ,
	X86_INS_VPMINUW,
	X86_INS_VPMOVDB,
	X86_INS_VPMOVDW,
	X86_INS_VPMOVM2B,
	X86_INS_VPMOVM2D,
	X86_INS_VPMOVM2Q,
	X86_INS_VPMOVM2W,
	X86_INS_VPMOVMSKB,
	X86_INS_VPMOVQB,
	X86_INS_VPMOVQD,
	X86_INS_VPMOVQW,
	X86_INS_VPMOVSDB,
	X86_INS_VPMOVSDW,
	X86_INS_VPMOVSQB,
	X86_INS_VPMOVSQD,
	X86_INS_VPMOVSQW,
	X86_INS_VPMOVSXBD,
	X86_INS_VPMOVSXBQ,
	X86_INS_VPMOVSXBW,
	X86_INS_VPMOVSXDQ,
	X86_INS_VPMOVSXWD,
	X86_INS_VPMOVSXWQ,
	X86_INS_VPMOVUSDB,
	X86_INS_VPMOVUSDW,
	X86_INS_VPMOVUSQB,
	X86_INS_VPMOVUSQD,
	X86_INS_VPMOVUSQW,
	X86_INS_VPMOVZXBD,
	X86_INS_VPMOVZXBQ,
	X86_INS_VPMOVZXBW,
	X86_INS_VPMOVZXDQ,
	X86_INS_VPMOVZXWD,
	X86_INS_VPMOVZXWQ,
	X86_INS_VPMULDQ,
	X86_INS_VPMULHRSW,
	X86_INS_VPMULHUW,
	X86_INS_VPMULHW,
	X86_INS_VPMULLD,
	X86_INS_VPMULLQ,
	X86_INS_VPMULLW,
	X86_INS_VPMULUDQ,
	X86_INS_VPORD,
	X86_INS_VPORQ,
	X86_INS_VPOR,
	X86_INS_VPPERM,
	X86_INS_VPROTB,
	X86_INS_VPROTD,
	X86_INS_VPROTQ,
	X86_INS_VPROTW,
	X86_INS_VPSADBW,
	X86_INS_VPSCATTERDD,
	X86_INS_VPSCATTERDQ,
	X86_INS_VPSCATTERQD,
	X86_INS_VPSCATTERQQ,
	X86_INS_VPSHAB,
	X86_INS_VPSHAD,
	X86_INS_VPSHAQ,
	X86_INS_VPSHAW,
	X86_INS_VPSHLB,
	X86_INS_VPSHLD,
	X86_INS_VPSHLQ,
	X86_INS_VPSHLW,
	X86_INS_VPSHUFB,
	X86_INS_VPSHUFD,
	X86_INS_VPSHUFHW,
	X86_INS_VPSHUFLW,
	X86_INS_VPSIGNB,
	X86_INS_VPSIGND,
	X86_INS_VPSIGNW,
	X86_INS_VPSLLDQ,
	X86_INS_VPSLLD,
	X86_INS_VPSLLQ,
	X86_INS_VPSLLVD,
	X86_INS_VPSLLVQ,
	X86_INS_VPSLLW,
	X86_INS_VPSRAD,
	X86_INS_VPSRAQ,
	X86_INS_VPSRAVD,
	X86_INS_VPSRAVQ,
	X86_INS_VPSRAW,
	X86_INS_VPSRLDQ,
	X86_INS_VPSRLD,
	X86_INS_VPSRLQ,
	X86_INS_VPSRLVD,
	X86_INS_VPSRLVQ,
	X86_INS_VPSRLW,
	X86_INS_VPSUBB,
	X86_INS_VPSUBD,
	X86_INS_VPSUBQ,
	X86_INS_VPSUBSB,
	X86_INS_VPSUBSW,
	X86_INS_VPSUBUSB,
	X86_INS_VPSUBUSW,
	X86_INS_VPSUBW,
	X86_INS_VPTESTMD,
	X86_INS_VPTESTMQ,
	X86_INS_VPTESTNMD,
	X86_INS_VPTESTNMQ,
	X86_INS_VPTEST,
	X86_INS_VPUNPCKHBW,
	X86_INS_VPUNPCKHDQ,
	X86_INS_VPUNPCKHQDQ,
	X86_INS_VPUNPCKHWD,
	X86_INS_VPUNPCKLBW,
	X86_INS_VPUNPCKLDQ,
	X86_INS_VPUNPCKLQDQ,
	X86_INS_VPUNPCKLWD,
	X86_INS_VPXORD,
	X86_INS_VPXORQ,
	X86_INS_VPXOR,
	X86_INS_VRCP14PD,
	X86_INS_VRCP14PS,
	X86_INS_VRCP14SD,
	X86_INS_VRCP14SS,
	X86_INS_VRCP28PD,
	X86_INS_VRCP28PS,
	X86_INS_VRCP28SD,
	X86_INS_VRCP28SS,
	X86_INS_VRCPPS,
	X86_INS_VRCPSS,
	X86_INS_VRNDSCALEPD,
	X86_INS_VRNDSCALEPS,
	X86_INS_VRNDSCALESD,
	X86_INS_VRNDSCALESS,
	X86_INS_VROUNDPD,
	X86_INS_VROUNDPS,
	X86_INS_VROUNDSD,
	X86_INS_VROUNDSS,
	X86_INS_VRSQRT14PD,
	X86_INS_VRSQRT14PS,
	X86_INS_VRSQRT14SD,
	X86_INS_VRSQRT14SS,
	X86_INS_VRSQRT28PD,
	X86_INS_VRSQRT28PS,
	X86_INS_VRSQRT28SD,
	X86_INS_VRSQRT28SS,
	X86_INS_VRSQRTPS,
	X86_INS_VRSQRTSS,
	X86_INS_VSCATTERDPD,
	X86_INS_VSCATTERDPS,
	X86_INS_VSCATTERPF0DPD,
	X86_INS_VSCATTERPF0DPS,
	X86_INS_VSCATTERPF0QPD,
	X86_INS_VSCATTERPF0QPS,
	X86_INS_VSCATTERPF1DPD,
	X86_INS_VSCATTERPF1DPS,
	X86_INS_VSCATTERPF1QPD,
	X86_INS_VSCATTERPF1QPS,
	X86_INS_VSCATTERQPD,
	X86_INS_VSCATTERQPS,
	X86_INS_VSHUFPD,
	X86_INS_VSHUFPS,
	X86_INS_VSQRTPD,
	X86_INS_VSQRTPS,
	X86_INS_VSQRTSD,
	X86_INS_VSQRTSS,
	X86_INS_VSTMXCSR,
	X86_INS_VSUBPD,
	X86_INS_VSUBPS,
	X86_INS_VSUBSD,
	X86_INS_VSUBSS,
	X86_INS_VTESTPD,
	X86_INS_VTESTPS,
	X86_INS_VUNPCKHPD,
	X86_INS_VUNPCKHPS,
	X86_INS_VUNPCKLPD,
	X86_INS_VUNPCKLPS,
	X86_INS_VZEROALL,
	X86_INS_VZEROUPPER,
	X86_INS_WAIT,
	X86_INS_WBINVD,
	X86_INS_WRFSBASE,
	X86_INS_WRGSBASE,
	X86_INS_WRMSR,
	X86_INS_XABORT,
	X86_INS_XACQUIRE,
	X86_INS_XBEGIN,
	X86_INS_XCHG,
	X86_INS_XCRYPTCBC,
	X86_INS_XCRYPTCFB,
	X86_INS_XCRYPTCTR,
	X86_INS_XCRYPTECB,
	X86_INS_XCRYPTOFB,
	X86_INS_XEND,
	X86_INS_XGETBV,
	X86_INS_XLATB,
	X86_INS_XRELEASE,
	X86_INS_XRSTOR,
	X86_INS_XRSTOR64,
	X86_INS_XRSTORS,
	X86_INS_XRSTORS64,
	X86_INS_XSAVE,
	X86_INS_XSAVE64,
	X86_INS_XSAVEC,
	X86_INS_XSAVEC64,
	X86_INS_XSAVEOPT,
	X86_INS_XSAVEOPT64,
	X86_INS_XSAVES,
	X86_INS_XSAVES64,
	X86_INS_XSETBV,
	X86_INS_XSHA1,
	X86_INS_XSHA256,
	X86_INS_XSTORE,
	X86_INS_XTEST,
	X86_INS_FDISI8087_NOP,
	X86_INS_FENI8087_NOP,

	// pseudo instructions
	X86_INS_CMPSS,
	X86_INS_CMPEQSS,
	X86_INS_CMPLTSS,
	X86_INS_CMPLESS,
	X86_INS_CMPUNORDSS,
	X86_INS_CMPNEQSS,
	X86_INS_CMPNLTSS,
	X86_INS_CMPNLESS,
	X86_INS_CMPORDSS,

	X86_INS_CMPSD,
	X86_INS_CMPEQSD,
	X86_INS_CMPLTSD,
	X86_INS_CMPLESD,
	X86_INS_CMPUNORDSD,
	X86_INS_CMPNEQSD,
	X86_INS_CMPNLTSD,
	X86_INS_CMPNLESD,
	X86_INS_CMPORDSD,

	X86_INS_CMPPS,
	X86_INS_CMPEQPS,
	X86_INS_CMPLTPS,
	X86_INS_CMPLEPS,
	X86_INS_CMPUNORDPS,
	X86_INS_CMPNEQPS,
	X86_INS_CMPNLTPS,
	X86_INS_CMPNLEPS,
	X86_INS_CMPORDPS,

	X86_INS_CMPPD,
	X86_INS_CMPEQPD,
	X86_INS_CMPLTPD,
	X86_INS_CMPLEPD,
	X86_INS_CMPUNORDPD,
	X86_INS_CMPNEQPD,
	X86_INS_CMPNLTPD,
	X86_INS_CMPNLEPD,
	X86_INS_CMPORDPD,

	X86_INS_VCMPSS,
	X86_INS_VCMPEQSS,
	X86_INS_VCMPLTSS,
	X86_INS_VCMPLESS,
	X86_INS_VCMPUNORDSS,
	X86_INS_VCMPNEQSS,
	X86_INS_VCMPNLTSS,
	X86_INS_VCMPNLESS,
	X86_INS_VCMPORDSS,
	X86_INS_VCMPEQ_UQSS,
	X86_INS_VCMPNGESS,
	X86_INS_VCMPNGTSS,
	X86_INS_VCMPFALSESS,
	X86_INS_VCMPNEQ_OQSS,
	X86_INS_VCMPGESS,
	X86_INS_VCMPGTSS,
	X86_INS_VCMPTRUESS,
	X86_INS_VCMPEQ_OSSS,
	X86_INS_VCMPLT_OQSS,
	X86_INS_VCMPLE_OQSS,
	X86_INS_VCMPUNORD_SSS,
	X86_INS_VCMPNEQ_USSS,
	X86_INS_VCMPNLT_UQSS,
	X86_INS_VCMPNLE_UQSS,
	X86_INS_VCMPORD_SSS,
	X86_INS_VCMPEQ_USSS,
	X86_INS_VCMPNGE_UQSS,
	X86_INS_VCMPNGT_UQSS,
	X86_INS_VCMPFALSE_OSSS,
	X86_INS_VCMPNEQ_OSSS,
	X86_INS_VCMPGE_OQSS,
	X86_INS_VCMPGT_OQSS,
	X86_INS_VCMPTRUE_USSS,

	X86_INS_VCMPSD,
	X86_INS_VCMPEQSD,
	X86_INS_VCMPLTSD,
	X86_INS_VCMPLESD,
	X86_INS_VCMPUNORDSD,
	X86_INS_VCMPNEQSD,
	X86_INS_VCMPNLTSD,
	X86_INS_VCMPNLESD,
	X86_INS_VCMPORDSD,
	X86_INS_VCMPEQ_UQSD,
	X86_INS_VCMPNGESD,
	X86_INS_VCMPNGTSD,
	X86_INS_VCMPFALSESD,
	X86_INS_VCMPNEQ_OQSD,
	X86_INS_VCMPGESD,
	X86_INS_VCMPGTSD,
	X86_INS_VCMPTRUESD,
	X86_INS_VCMPEQ_OSSD,
	X86_INS_VCMPLT_OQSD,
	X86_INS_VCMPLE_OQSD,
	X86_INS_VCMPUNORD_SSD,
	X86_INS_VCMPNEQ_USSD,
	X86_INS_VCMPNLT_UQSD,
	X86_INS_VCMPNLE_UQSD,
	X86_INS_VCMPORD_SSD,
	X86_INS_VCMPEQ_USSD,
	X86_INS_VCMPNGE_UQSD,
	X86_INS_VCMPNGT_UQSD,
	X86_INS_VCMPFALSE_OSSD,
	X86_INS_VCMPNEQ_OSSD,
	X86_INS_VCMPGE_OQSD,
	X86_INS_VCMPGT_OQSD,
	X86_INS_VCMPTRUE_USSD,

	X86_INS_VCMPPS,
	X86_INS_VCMPEQPS,
	X86_INS_VCMPLTPS,
	X86_INS_VCMPLEPS,
	X86_INS_VCMPUNORDPS,
	X86_INS_VCMPNEQPS,
	X86_INS_VCMPNLTPS,
	X86_INS_VCMPNLEPS,
	X86_INS_VCMPORDPS,
	X86_INS_VCMPEQ_UQPS,
	X86_INS_VCMPNGEPS,
	X86_INS_VCMPNGTPS,
	X86_INS_VCMPFALSEPS,
	X86_INS_VCMPNEQ_OQPS,
	X86_INS_VCMPGEPS,
	X86_INS_VCMPGTPS,
	X86_INS_VCMPTRUEPS,
	X86_INS_VCMPEQ_OSPS,
	X86_INS_VCMPLT_OQPS,
	X86_INS_VCMPLE_OQPS,
	X86_INS_VCMPUNORD_SPS,
	X86_INS_VCMPNEQ_USPS,
	X86_INS_VCMPNLT_UQPS,
	X86_INS_VCMPNLE_UQPS,
	X86_INS_VCMPORD_SPS,
	X86_INS_VCMPEQ_USPS,
	X86_INS_VCMPNGE_UQPS,
	X86_INS_VCMPNGT_UQPS,
	X86_INS_VCMPFALSE_OSPS,
	X86_INS_VCMPNEQ_OSPS,
	X86_INS_VCMPGE_OQPS,
	X86_INS_VCMPGT_OQPS,
	X86_INS_VCMPTRUE_USPS,

	X86_INS_VCMPPD,
	X86_INS_VCMPEQPD,
	X86_INS_VCMPLTPD,
	X86_INS_VCMPLEPD,
	X86_INS_VCMPUNORDPD,
	X86_INS_VCMPNEQPD,
	X86_INS_VCMPNLTPD,
	X86_INS_VCMPNLEPD,
	X86_INS_VCMPORDPD,
	X86_INS_VCMPEQ_UQPD,
	X86_INS_VCMPNGEPD,
	X86_INS_VCMPNGTPD,
	X86_INS_VCMPFALSEPD,
	X86_INS_VCMPNEQ_OQPD,
	X86_INS_VCMPGEPD,
	X86_INS_VCMPGTPD,
	X86_INS_VCMPTRUEPD,
	X86_INS_VCMPEQ_OSPD,
	X86_INS_VCMPLT_OQPD,
	X86_INS_VCMPLE_OQPD,
	X86_INS_VCMPUNORD_SPD,
	X86_INS_VCMPNEQ_USPD,
	X86_INS_VCMPNLT_UQPD,
	X86_INS_VCMPNLE_UQPD,
	X86_INS_VCMPORD_SPD,
	X86_INS_VCMPEQ_USPD,
	X86_INS_VCMPNGE_UQPD,
	X86_INS_VCMPNGT_UQPD,
	X86_INS_VCMPFALSE_OSPD,
	X86_INS_VCMPNEQ_OSPD,
	X86_INS_VCMPGE_OQPD,
	X86_INS_VCMPGT_OQPD,
	X86_INS_VCMPTRUE_USPD,

	X86_INS_UD0,
	X86_INS_ENDBR32,
	X86_INS_ENDBR64,

	X86_INS_ENDING, // mark the end of the list of insn
} x86_insn;

/// Group of X86 instructions
typedef enum  x86_insn_group {
	X86_GRP_INVALID = 0, ///< = CS_GRP_INVALID

	// Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	X86_GRP_JUMP,	///< = CS_GRP_JUMP
	// all call instructions
	X86_GRP_CALL,	///< = CS_GRP_CALL
	// all return instructions
	X86_GRP_RET,	///< = CS_GRP_RET
	// all interrupt instructions (int+syscall)
	X86_GRP_INT,	///< = CS_GRP_INT
	// all interrupt return instructions
	X86_GRP_IRET,	///< = CS_GRP_IRET
	// all privileged instructions
	X86_GRP_PRIVILEGE,	///< = CS_GRP_PRIVILEGE
	// all relative branching instructions
	X86_GRP_BRANCH_RELATIVE, ///< = CS_GRP_BRANCH_RELATIVE

	// Architecture-specific groups
	X86_GRP_VM = 128,	///< all virtualization instructions (VT-x + AMD-V)
	X86_GRP_3DNOW,
	X86_GRP_AES,
	X86_GRP_ADX,
	X86_GRP_AVX,
	X86_GRP_AVX2,
	X86_GRP_AVX512,
	X86_GRP_BMI,
	X86_GRP_BMI2,
	X86_GRP_CMOV,
	X86_GRP_F16C,
	X86_GRP_FMA,
	X86_GRP_FMA4,
	X86_GRP_FSGSBASE,
	X86_GRP_HLE,
	X86_GRP_MMX,
	X86_GRP_MODE32,
	X86_GRP_MODE64,
	X86_GRP_RTM,
	X86_GRP_SHA,
	X86_GRP_SSE1,
	X86_GRP_SSE2,
	X86_GRP_SSE3,
	X86_GRP_SSE41,
	X86_GRP_SSE42,
	X86_GRP_SSE4A,
	X86_GRP_SSSE3,
	X86_GRP_PCLMUL,
	X86_GRP_XOP,
	X86_GRP_CDI,
	X86_GRP_ERI,
	X86_GRP_TBM,
	X86_GRP_16BITMODE,
	X86_GRP_NOT64BITMODE,
	X86_GRP_SGX,
	X86_GRP_DQI,
	X86_GRP_BWI,
	X86_GRP_PFI,
	X86_GRP_VLX,
	X86_GRP_SMAP,
	X86_GRP_NOVLX,
	X86_GRP_FPU,

	X86_GRP_ENDING
} x86_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`capstone/include/capstone/xcore.h`:

```h
#ifndef CAPSTONE_XCORE_H
#define CAPSTONE_XCORE_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014-2015 */

#ifdef __cplusplus
extern "C" {
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

/// Operand type for instruction's operands
typedef enum xcore_op_type {
	XCORE_OP_INVALID = 0, ///< = CS_OP_INVALID (Uninitialized).
	XCORE_OP_REG, ///< = CS_OP_REG (Register operand).
	XCORE_OP_IMM, ///< = CS_OP_IMM (Immediate operand).
	XCORE_OP_MEM, ///< = CS_OP_MEM (Memory operand).
} xcore_op_type;

/// XCore registers
typedef enum xcore_reg {
	XCORE_REG_INVALID = 0,

	XCORE_REG_CP,
	XCORE_REG_DP,
	XCORE_REG_LR,
	XCORE_REG_SP,
	XCORE_REG_R0,
	XCORE_REG_R1,
	XCORE_REG_R2,
	XCORE_REG_R3,
	XCORE_REG_R4,
	XCORE_REG_R5,
	XCORE_REG_R6,
	XCORE_REG_R7,
	XCORE_REG_R8,
	XCORE_REG_R9,
	XCORE_REG_R10,
	XCORE_REG_R11,

	// pseudo registers
	XCORE_REG_PC,	///< pc

	// internal thread registers
	// see The-XMOS-XS1-Architecture(X7879A).pdf
	XCORE_REG_SCP,	///< save pc
	XCORE_REG_SSR,	//< save status
	XCORE_REG_ET,	//< exception type
	XCORE_REG_ED,	//< exception data
	XCORE_REG_SED,	//< save exception data
	XCORE_REG_KEP,	//< kernel entry pointer
	XCORE_REG_KSP,	//< kernel stack pointer
	XCORE_REG_ID,	//< thread ID

	XCORE_REG_ENDING,	// <-- mark the end of the list of registers
} xcore_reg;

/// Instruction's operand referring to memory
/// This is associated with XCORE_OP_MEM operand type above
typedef struct xcore_op_mem {
	uint8_t base;		///< base register, can be safely interpreted as
				///< a value of type `xcore_reg`, but it is only
				///< one byte wide
	uint8_t index;		///< index register, same conditions apply here
	int32_t disp;	///< displacement/offset value
	int     direct;	///< +1: forward, -1: backward
} xcore_op_mem;

/// Instruction operand
typedef struct cs_xcore_op {
	xcore_op_type type;	///< operand type
	union {
		xcore_reg reg;	///< register value for REG operand
		int32_t imm;		///< immediate value for IMM operand
		xcore_op_mem mem;		///< base/disp value for MEM operand
	};
} cs_xcore_op;

/// Instruction structure
typedef struct cs_xcore {
	/// Number of operands of this instruction,
	/// or 0 when instruction has no operand.
	uint8_t op_count;
	cs_xcore_op operands[8]; ///< operands for this instruction.
} cs_xcore;

/// XCore instruction
typedef enum xcore_insn {
	XCORE_INS_INVALID = 0,

	XCORE_INS_ADD,
	XCORE_INS_ANDNOT,
	XCORE_INS_AND,
	XCORE_INS_ASHR,
	XCORE_INS_BAU,
	XCORE_INS_BITREV,
	XCORE_INS_BLA,
	XCORE_INS_BLAT,
	XCORE_INS_BL,
	XCORE_INS_BF,
	XCORE_INS_BT,
	XCORE_INS_BU,
	XCORE_INS_BRU,
	XCORE_INS_BYTEREV,
	XCORE_INS_CHKCT,
	XCORE_INS_CLRE,
	XCORE_INS_CLRPT,
	XCORE_INS_CLRSR,
	XCORE_INS_CLZ,
	XCORE_INS_CRC8,
	XCORE_INS_CRC32,
	XCORE_INS_DCALL,
	XCORE_INS_DENTSP,
	XCORE_INS_DGETREG,
	XCORE_INS_DIVS,
	XCORE_INS_DIVU,
	XCORE_INS_DRESTSP,
	XCORE_INS_DRET,
	XCORE_INS_ECALLF,
	XCORE_INS_ECALLT,
	XCORE_INS_EDU,
	XCORE_INS_EEF,
	XCORE_INS_EET,
	XCORE_INS_EEU,
	XCORE_INS_ENDIN,
	XCORE_INS_ENTSP,
	XCORE_INS_EQ,
	XCORE_INS_EXTDP,
	XCORE_INS_EXTSP,
	XCORE_INS_FREER,
	XCORE_INS_FREET,
	XCORE_INS_GETD,
	XCORE_INS_GET,
	XCORE_INS_GETN,
	XCORE_INS_GETR,
	XCORE_INS_GETSR,
	XCORE_INS_GETST,
	XCORE_INS_GETTS,
	XCORE_INS_INCT,
	XCORE_INS_INIT,
	XCORE_INS_INPW,
	XCORE_INS_INSHR,
	XCORE_INS_INT,
	XCORE_INS_IN,
	XCORE_INS_KCALL,
	XCORE_INS_KENTSP,
	XCORE_INS_KRESTSP,
	XCORE_INS_KRET,
	XCORE_INS_LADD,
	XCORE_INS_LD16S,
	XCORE_INS_LD8U,
	XCORE_INS_LDA16,
	XCORE_INS_LDAP,
	XCORE_INS_LDAW,
	XCORE_INS_LDC,
	XCORE_INS_LDW,
	XCORE_INS_LDIVU,
	XCORE_INS_LMUL,
	XCORE_INS_LSS,
	XCORE_INS_LSUB,
	XCORE_INS_LSU,
	XCORE_INS_MACCS,
	XCORE_INS_MACCU,
	XCORE_INS_MJOIN,
	XCORE_INS_MKMSK,
	XCORE_INS_MSYNC,
	XCORE_INS_MUL,
	XCORE_INS_NEG,
	XCORE_INS_NOT,
	XCORE_INS_OR,
	XCORE_INS_OUTCT,
	XCORE_INS_OUTPW,
	XCORE_INS_OUTSHR,
	XCORE_INS_OUTT,
	XCORE_INS_OUT,
	XCORE_INS_PEEK,
	XCORE_INS_REMS,
	XCORE_INS_REMU,
	XCORE_INS_RETSP,
	XCORE_INS_SETCLK,
	XCORE_INS_SET,
	XCORE_INS_SETC,
	XCORE_INS_SETD,
	XCORE_INS_SETEV,
	XCORE_INS_SETN,
	XCORE_INS_SETPSC,
	XCORE_INS_SETPT,
	XCORE_INS_SETRDY,
	XCORE_INS_SETSR,
	XCORE_INS_SETTW,
	XCORE_INS_SETV,
	XCORE_INS_SEXT,
	XCORE_INS_SHL,
	XCORE_INS_SHR,
	XCORE_INS_SSYNC,
	XCORE_INS_ST16,
	XCORE_INS_ST8,
	XCORE_INS_STW,
	XCORE_INS_SUB,
	XCORE_INS_SYNCR,
	XCORE_INS_TESTCT,
	XCORE_INS_TESTLCL,
	XCORE_INS_TESTWCT,
	XCORE_INS_TSETMR,
	XCORE_INS_START,
	XCORE_INS_WAITEF,
	XCORE_INS_WAITET,
	XCORE_INS_WAITEU,
	XCORE_INS_XOR,
	XCORE_INS_ZEXT,

	XCORE_INS_ENDING,   // <-- mark the end of the list of instructions
} xcore_insn;

/// Group of XCore instructions
typedef enum xcore_insn_group {
	XCORE_GRP_INVALID = 0, ///< = CS_GRP_INVALID

	// Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	XCORE_GRP_JUMP,	///< = CS_GRP_JUMP

	XCORE_GRP_ENDING,   // <-- mark the end of the list of groups
} xcore_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```