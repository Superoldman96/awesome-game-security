Project Path: arc_gmh5225_valorant-internal-cheat_7lgu8efm

Source Tree:

```txt
arc_gmh5225_valorant-internal-cheat_7lgu8efm
├── Alignments.h
├── Canvas.h
├── DLLMain.cpp
├── Decryptor.h
├── Entry.cpp
├── FNamePool.h
├── README.md
├── StaffBesting.sln
├── Unreal.h
├── decryption.h
├── discord-rpc.lib
├── discord_rpc.h
├── hook.h
├── internal.vcxproj
├── internal.vcxproj.filters
├── internal.vcxproj.user
├── memory.h
├── offsets.h
├── sdk.h
├── unrealengine.h
└── valorant.h

```

`Alignments.h`:

```h
#pragma once

template <typename T>
FORCEINLINE constexpr T Align(T Val, uint64 Alignment)
{
	return (T)(((uint64)Val + Alignment - 1) & ~(Alignment - 1));
}
#pragma once


```

`Canvas.h`:

```h
#pragma once
#include "memory.h"
#include "unrealengine.h"
class UObject
{
public:
	char padding_01[0x18];
	int32_t ComparisonIndex;
	static UObject* StaticFindObject(UObject* Class, UObject* InOuter, const wchar_t* Name, bool ExactClass)
	{
		static uintptr_t StaticFindObjectAddress = VALORANT::Module + Offsets::StaticFindObject;

		auto StaticFindObjectFN = reinterpret_cast<UObject * (__fastcall*)(UObject*, UObject*, const wchar_t*, bool)>(StaticFindObjectAddress);

		return StaticFindObjectFN(Class, InOuter, Name, ExactClass);
	}
	static void ProcessEvent(void* class_, UObject* function, void* params)
	{
		reinterpret_cast<void (*)(void*, UObject*, void*)>(VALORANT::Module + Offsets::ProcessEvent)(class_, function, params);
	}
};

struct UWorld
{

};

struct UFont : UObject
{

};

UObject* DefaultMediumFont;
struct UEngine
{

};
bool bOutline = 0;
bool vischeck = 1;
bool spinvischeck = 0;
bool InGame = 0;
struct USkeletalMeshComponent
{

	void SetOutlineMode(EAresOutlineMode Mode)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.AresOutlineComponent.SetOutlineMode", false);
		if (!Function)
		{
			return;
		}
		struct
		{
			EAresOutlineMode Mode;
		}Parameters;
		Parameters.Mode = Mode;
		Function->ProcessEvent(this, Function, &Parameters);
	}
};
struct UCanvas
{
	void K2_DrawLine(struct FVector2D ScreenPositionA, struct FVector2D ScreenPositionB, float Thickness, struct FLinearColor RenderColor)
	{
		UObject* function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Canvas.K2_DrawLine", false);


		struct {
			FVector2D ScreenPositionA;
			FVector2D ScreenPositionB;
			float Thickness;
			FLinearColor RenderColor;
		}Args;
		Args.ScreenPositionA = ScreenPositionA;
		Args.ScreenPositionB = ScreenPositionB;
		Args.Thickness = Thickness;
		Args.RenderColor = RenderColor;
		function->ProcessEvent(this, function, &Args);
	}
	void K2_DrawLinex(FVector2D ScreenPositionA, FVector2D ScreenPositionB, float Thickness, FLinearColor RenderColor) // CRT af doe (ironic.)
	{
		Thickness = 0.75;
		if (bOutline)
		{
			K2_DrawLine({ ScreenPositionA.X + 1, ScreenPositionA.Y }, { ScreenPositionB.X, ScreenPositionB.Y }, Thickness, { 0.0f,0.0f,0.0f,1.0f });
			K2_DrawLine({ ScreenPositionA.X - 1, ScreenPositionA.Y }, { ScreenPositionB.X, ScreenPositionB.Y }, Thickness, { 0.0f,0.0f,0.0f,1.0f });
			K2_DrawLine({ ScreenPositionA.X, ScreenPositionA.Y + 1 }, { ScreenPositionB.X, ScreenPositionB.Y }, Thickness, { 0.0f,0.0f,0.0f,1.0f });
			K2_DrawLine({ ScreenPositionA.X, ScreenPositionA.Y - 1 }, { ScreenPositionB.X, ScreenPositionB.Y }, Thickness, { 0.0f,0.0f,0.0f,1.0f });
		}
		K2_DrawLine({ ScreenPositionA.X, ScreenPositionA.Y }, { ScreenPositionB.X, ScreenPositionB.Y }, Thickness, RenderColor);
	}

	void K2_DrawText(struct FString RenderText, struct FVector2D ScreenPosition, struct FVector2D Scale, struct FLinearColor RenderColor, float Kerning, struct FLinearColor ShadowColor, struct FVector2D ShadowOffset, bool bCentreX, bool bCentreY, bool bOutlined, struct FLinearColor OutlineColor)
	{
		UObject* function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Canvas.K2_DrawText", false);
		if (!DefaultMediumFont)
			DefaultMediumFont = UObject::StaticFindObject(nullptr, nullptr, L"/Engine/EngineFonts/Roboto.Roboto", false);
		struct {
			UObject* RenderFont;
			FString RenderText;
			FVector2D ScreenPosition;
			FVector2D Scale;
			FLinearColor RenderColor;
			float Kerning;
			FLinearColor ShadowColor;
			FVector2D ShadowOffset;
			bool bCentreX;
			bool bCentreY;
			bool bOutlined;
			FLinearColor OutlineColor;
		}Args;
		Args.RenderFont = DefaultMediumFont;
		Args.RenderText = RenderText;
		Args.ScreenPosition = ScreenPosition;
		Args.Scale = Scale;
		Args.RenderColor = RenderColor;
		Args.Kerning = Kerning;
		Args.ShadowColor = ShadowColor;
		Args.ShadowOffset = ShadowOffset;
		Args.bCentreX = bCentreX;
		Args.bCentreY = bCentreY;
		Args.bOutlined = bOutlined;
		Args.OutlineColor = OutlineColor;
		function->ProcessEvent(this, function, &Args);
	}
};

struct UGameInstance
{

};

struct ULocalPlayer
{

};

struct FBoxSphereBounds {
	FVector Origin;
	FVector BoxExtent;
	float SphereRadius;
};

struct FBox {
	FVector Min;
	FVector Max;

	FBox() {

		Min.X = NULL;
		Min.Y = NULL;
		Min.Z = NULL;

		Max.X = NULL;
		Max.Y = NULL;
		Max.Z = NULL;
	}
};

struct UStaticMeshComponent
{
	FBox GetBoundingBox()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.StaticMesh.GetBoundingBox", false);
		if (!Function)
		{
			return FBox();
		}
		struct
		{
			FBox ReturnValue;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.ReturnValue;
	}
};
namespace AresOutlineComponet
{
	UObject* Static_Class()
	{
		//ShooterGame.Default__AresOutlineComponent
		return UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.Default__AresOutlineComponent", false);
	}
	void SetOutlineMode(EAresOutlineMode OutlineMode)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.AresOutlineComponent.SetOutlineMode", false);
		if (!Function)
		{
			return;
		}
		struct
		{
			EAresOutlineMode OutlineMode;
		}Parameters;
		Parameters.OutlineMode = OutlineMode;
		Function->ProcessEvent(Static_Class(), Function, &Parameters);
		return;

	}
}
struct UAresOutlineComponent {

	UObject* Static_Class()
	{
		//ShooterGame.Default__AresOutlineComponent
		return UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.Default__AresOutlineComponent", false);
	}
	void SetOutlineMode(EAresOutlineMode OutlineMode)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.AresOutlineComponent.SetOutlineMode", false);
		if (!Function)
		{
			return;
		}
		struct
		{
			EAresOutlineMode OutlineMode;
		}Parameters;
		Parameters.OutlineMode = OutlineMode;
		Function->ProcessEvent(Static_Class(), Function, &Parameters);
		return;

	}
};

DWORD64 ProjectWorldToScreen;

struct APlayerState
{
	FString GetPlayerName()
	{
		UObject* function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.PlayerState.GetPlayerName", false);
		if (!function)
			return L"AAresPlayerCharacter_PC_C";

		struct {
			FString Return;
		}Args;
		function->ProcessEvent(this, function, &Args);
		return Args.Return;
	}
};


struct FQuat
{
public:

	float X, Y, Z, W;

	FQuat() : X(0.f), Y(0.f), Z(0.f), W(0.f) {};

	FQuat(float InX, float InY, float InZ, float InW) : X(InX), Y(InY), Z(InZ), W(InW) {}

	FQuat(struct FRotator& R);

	FVector RotateVector(const struct FVector& V) const;
};
struct FRotator
{
	float Pitch, Yaw, Roll;

	FRotator()
		: Pitch(0), Yaw(0), Roll(0)
	{ }

	FRotator(float pitch, float yaw, float roll) : Pitch(pitch), Yaw(yaw), Roll(roll) {}

	FRotator operator+ (const FRotator& other) const { return FRotator(Pitch + other.Pitch, Yaw + other.Yaw, Roll + other.Roll); }

	FRotator operator- (const FRotator& other) const { return FRotator(Pitch - other.Pitch, Yaw - other.Yaw, Roll - other.Roll); }

	FRotator operator* (float scalar) const { return FRotator(Pitch * scalar, Yaw * scalar, Roll * scalar); }

	FRotator& operator=  (const FRotator& other) { Pitch = other.Pitch; Yaw = other.Yaw; Roll = other.Roll; return *this; }

	FRotator& operator+= (const FRotator& other) { Pitch += other.Pitch; Yaw += other.Yaw; Roll += other.Roll; return *this; }

	FRotator& operator-= (const FRotator& other) { Pitch -= other.Pitch; Yaw -= other.Yaw; Roll -= other.Roll; return *this; }

	FRotator& operator*= (const float other) { Yaw *= other; Pitch *= other; Roll *= other; return *this; }

	struct FQuat Quaternion() const;
};

constexpr auto PI = 3.1415926535897932f;
constexpr auto FLOAT_NON_FRACTIONAL = 8388608.f /* All single-precision floating point numbers greater than or equal to this have no fractional value. */;
constexpr auto INV_PI = 0.31830988618f;
constexpr auto HALF_PI = 1.57079632679f;
constexpr auto DEG_TO_RAD = PI / 180.f;
constexpr auto RADS_DIVIDED_BY_2 = DEG_TO_RAD / 2.f;

namespace classes {
	namespace defines {
		static UObject* system = nullptr;
		static UObject* game_statics = nullptr;
		static UObject* blueprint = nullptr;
		static UObject* content_library = nullptr;
	}

	static inline void init() {
		defines::system = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Default__KismetSystemLibrary", false);
		defines::game_statics = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Default__GameplayStatics", false);
		defines::blueprint = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.Default__ShooterBlueprintLibrary", false);
		defines::content_library = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.Default__ContentLibrary", false);
	}
}

namespace kismentsystemlibrary
{
	UObject* static_class()
	{
		return UObject::StaticFindObject(nullptr, nullptr, L"Engine.Default__KismetSystemLibrary", false);
	}

	FString get_object_name(UObject* obj)
	{
		UObject* functions = UObject::StaticFindObject(nullptr, nullptr, L"Engine.KismetSystemLibrary.GetObjectName", false);
		if (!functions)

			return L"N/A";
		struct
		{
			UObject* obj;
			FString out;
		}
		Args;
		Args.obj = obj;
		functions->ProcessEvent(static_class(), functions, &Args);
		return Args.out;
	}
}
struct FMath {
	static __forceinline void SinCos(float* ScalarSin, float* ScalarCos, float  Value);
	static __forceinline float Fmod(float X, float Y);
	template<class T>
	static __forceinline T Clamp(const T X, const T Min, const T Max) { return X < Min ? Min : X < Max ? X : Max; }
};
void GetViewProjectionMatrix(struct FMinimalViewInfo DesiredView, struct FMatrix& ViewMatrix, struct FMatrix& ProjectionMatrix, struct FMatrix& ViewProjectionMatrix); // Function Engine.GameplayStatics.GetViewProjectionMatrix


struct FTransform
{
	FQuat Rotation;
	FVector Translation;
	char UnknownData00[0x4];
	FVector Scale3D;
	char UnknownData01[0x4];

	/** Default constructor. */
	FTransform() : Rotation(0.f, 0.f, 0.f, 1.f), Translation(0.f), Scale3D(FVector::OneVector) {};

	FVector TransformPosition(FVector& V) const;

	FTransform(const FRotator& InRotation) : Rotation(InRotation.Quaternion()), Translation(FVector::ZeroVector), Scale3D(FVector::OneVector) {};
};



struct AAresEquippable : UObject
{
	USkeletalMeshComponent* GetMesh1P()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.AresEquippable.GetMesh1P", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			USkeletalMeshComponent* Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
};

struct UAresInventory : UObject
{
	AAresEquippable* GetCurrentWeapon()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.AresInventory.GetCurrentEquippable", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			AAresEquippable* Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
};
struct AShooterCharacter : UObject
{
	UAresInventory* GetInventory()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetInventory", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			UAresInventory* Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	UObject* FindClass()
	{
		return UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.Default__ContentLibrary", false); // Just for information, you need only find the default class 1 time.
	}
	void Set3pMeshVisible(bool val)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.Set3PMeshVisible", false);
		if (!Function)
		{
			return;
		}
		struct
		{
			bool a1;
		}Parameters;
		Parameters.a1 = val;
		Function->ProcessEvent(this, Function, &Parameters);
		return;
	}
	bool ClearWeaponComponents(UObject* equippable)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ContentLibrary.ClearWeaponComponents", false);
		if (!Function) return false;

		struct
		{
			UObject* equippable;
			UObject* skindata;
			UObject* chromadata;
			int skinlevel;
			UObject* charmdata;
			int charm_level;
		} Parameters = { equippable };

		UObject::ProcessEvent(FindCall(), Function, &Parameters);

	}
	UObject* FindCall()
	{
		return UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.Default__ContentLibrary", false); // Just for information, you need only find the default class 1 time.
	}
	bool ApplySkin(UObject* equippable, UObject* skindata, UObject* chromadata, int skinlevel, UObject* charmdata, int charm_level)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ContentLibrary.ApplySkin", false);
		if (!Function) return false;

		struct
		{
			UObject* equippable;
			UObject* skindata;
			UObject* chromadata;
			int skinlevel;
			UObject* charmdata;
			int charm_level;
		} Parameters = { equippable, skindata, chromadata, skinlevel, charmdata, charm_level };

		UObject::ProcessEvent(FindClass(), Function, &Parameters);
	}
	void ClientFly()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.ClientFly", false);
		if (!Function)
		{
			return;
		}
		struct
		{
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return;
	}
	void SetControlRotation(FVector NewRot)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Controller.SetControlRotation", false);
		if (!Function)
		{
			return;
		}
		struct
		{
			FVector Rot;
		}Parameters;
		Parameters.Rot = NewRot;
		Function->ProcessEvent(this, Function, &Parameters);
		return;
	}

	APlayerState* GetPlayerState()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetPlayerState", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			APlayerState* Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}

	int32_t GetMaxHealth()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetMaxHealth", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			int32_t Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}


	float GetMaxShield()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetMaxShield", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			float Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	float GetHealth()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetHealth", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			float Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	float GetShield()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetShield", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			float Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	FVector K2_GetActorLocation()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Actor.K2_GetActorLocation", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			FVector Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	FRotator K2_GetActorRotation()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Actor.K2_GetActorRotation", false);
		if (!Function)
		{
			return { 0,0,0 };
		}
		struct
		{
			FRotator Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	UAresOutlineComponent* GetPawnMesh()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetPawnMesh", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			UAresOutlineComponent* Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}

	APlayerState* GetState()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetPlayerState", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			APlayerState* KekState;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.KekState;
	}
	bool IsAlive()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.IsAlive", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			bool Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
};

struct APlayerCameraManager
{
	FVector GetCameraLocation()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.PlayerCameraManager.GetCameraLocation", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			FVector Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
};
struct APlayerController : UObject
{
	bool LineOfSightTo(AShooterCharacter* Actor, FVector ViewPoint, bool bAlternateChecks)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Controller.LineOfSightTo", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			AShooterCharacter* Actor;
			FVector ViewPoint;
			bool bAlternateChecks;
			bool Out;
		}Parameters;
		Parameters.Actor = Actor;
		Parameters.ViewPoint = ViewPoint;
		Parameters.bAlternateChecks = bAlternateChecks;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}

	FVector GetControlRotation()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Controller.GetControlRotation", false);
		if (!Function)
		{
			return { 0,0,0 };
		}
		struct
		{
			FVector Rot;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Rot;
	}
	void K2_SetActorRelativeRotation(struct FRotator NewRelativeRotation, bool bSweep, bool bTeleport)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Actor.K2_SetActorRelativeRotation", false);
		if (!Function)
		{
			return;
		}
		struct
		{
			struct FRotator NewRelativeRotation;
			bool bSweep;
			bool bTeleport;
		}Parameters;
		Parameters.NewRelativeRotation = NewRelativeRotation;
		Parameters.bSweep = bSweep;
		Parameters.bTeleport = bTeleport;
		Function->ProcessEvent(this, Function, &Parameters);
		return;
	}
	void GetInputMouseDelta(float& DeltaX, float& DeltaY)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.PlayerController.GetInputMouseDelta", false);
		if (!Function)
		{
			return;
		}
		struct
		{
			float DeltaX;
			float DeltaY;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		DeltaX = Parameters.DeltaX;
		DeltaY = Parameters.DeltaY;
	}
	float GetMouseSensitivity()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.ShooterPlayerController.GetMouseSensitivity", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			float Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	void SetControlRotation(FVector NewRot)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Controller.SetControlRotation", false);
		if (!Function)
		{
			return;
		}
		struct
		{
			FVector Rot;
		}Parameters;
		Parameters.Rot = NewRot;
		Function->ProcessEvent(this, Function, &Parameters);
		return;
	}
	bool ProjectWorldLocationToScreen(struct FVector WorldLocation, struct FVector2D& ScreenLocation, bool bPlayerViewportRelative) {
		UObject* function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.PlayerController.ProjectWorldLocationToScreen", false);

		struct {
			FVector WorldLocationn;
			FVector2D ScreenLocationn;
			bool bPlayerViewportRelativee;
			bool return_value;
		}Args;

		Args.WorldLocationn = WorldLocation;
		Args.bPlayerViewportRelativee = bPlayerViewportRelative;

		function->ProcessEvent(this, function, &Args);

		ScreenLocation = Args.ScreenLocationn;

		return Args.return_value;
	}

	void GetActorBounds(AShooterCharacter* Actor, bool bOnlyCollidingComponents, FVector* Origin, FVector* BoxExtent, bool bIncludeFromChildActors)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Actor.GetActorBounds", false);
		if (!Function)
		{
			return;
		}
		struct
		{
			AShooterCharacter* Actorr;
			bool bOnlyCollidingComponentss;
			FVector* Originn;
			FVector* BoxExtentt;
			bool bIncludeFromChildActorss;
		}Parameters;
		Parameters.bOnlyCollidingComponentss = bOnlyCollidingComponents;
		Parameters.bIncludeFromChildActorss = bIncludeFromChildActors;
		Function->ProcessEvent(this, Function, &Parameters);
		Origin = Parameters.Originn;
		BoxExtent = Parameters.BoxExtentt;
		return;
	}
	
	void set_fov(float fov)
	{
		UObject* function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.AresPlayerController.SetFOV", false);


		struct {
			float fov;
		}Args;
		Args.fov = fov;
		function->ProcessEvent(this, function, &Args);
	}

	AShooterCharacter* GetShooterCharacter()
	{

		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.AresPlayerController.GetShooterCharacter", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			AShooterCharacter* Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	void DisconnectFromServer()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.AresPlayerController.DisconnectFromServer", false);
		if (!Function)
		{
			return;
		}
		struct {
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
	}
};

struct AController
{
};
namespace ShooterGameBlueprints
{
	UObject* Static_Class()
	{
		return UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.Default__ShooterBlueprintLibrary", false);
	}

	APlayerController* GetFirstLocalPlayerController(UWorld* WorldContextObject)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterBlueprintLibrary.GetFirstLocalPlayerController", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			UWorld* WorldContextObject;
			APlayerController* Out;
		}Parameters;
		Parameters.WorldContextObject = WorldContextObject;
		Function->ProcessEvent(Static_Class(), Function, &Parameters);
		return Parameters.Out;
	}
	TArray<AShooterCharacter*> FindAllShooterCharactersWithAlliance(UWorld* WorldContextObject, AShooterCharacter* LocalViewer, EAresAlliance Alliance, bool OnlyPlayerControlled, bool OnlyAlivePlayers)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterBlueprintLibrary.FindAllShooterCharactersWithAlliance", false);
		struct
		{
			UWorld* WorldContextObject;
			AShooterCharacter* LocalViewer;
			EAresAlliance Alliance;
			bool OnlyPlayerControlled;
			bool OnlyAlivePlayers;
			TArray<AShooterCharacter*> Out;
		}Parameters;
		Parameters.WorldContextObject = WorldContextObject;
		Parameters.LocalViewer = LocalViewer;
		Parameters.Alliance = Alliance;
		Parameters.OnlyPlayerControlled = OnlyPlayerControlled;
		Parameters.OnlyAlivePlayers = OnlyAlivePlayers;
		Function->ProcessEvent(Static_Class(), Function, &Parameters);
		return Parameters.Out;
	}
}

namespace AresOutlineRendering
{
	UObject* Static_Class()
	{
		return UObject::StaticFindObject(nullptr, nullptr, L"Renderer.Default__AresOutlineRendering", false);
	}

	void SetOutlineColorsForRender(UWorld* WorldContextObject, FLinearColor AllyColor, FLinearColor EnemyColor)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Renderer.AresOutlineRendering.SetOutlineColorsForRender", false);
		if (!Function)
		{
			return;
		}
		struct {
			UWorld* WorldContextObject;
			FLinearColor AllyColor;
			FLinearColor EnemyColor;
		}Parameters;
		Parameters.WorldContextObject = WorldContextObject;
		Parameters.AllyColor = AllyColor;
		Parameters.EnemyColor = EnemyColor;
		Function->ProcessEvent(Static_Class(), Function, &Parameters);
	}
}

namespace BaseTeamComponent
{
	UObject* Static_Class()
	{
		return UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.Default__BaseTeamComponent", false);
	}

	bool IsAlly(AShooterCharacter* Enemy, AShooterCharacter* Self)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.BaseTeamComponent.IsAlly", false);
		struct {
			AShooterCharacter* Enemy;
			AShooterCharacter* Self;
			bool ReturnValue;
		}Parameters;
		Parameters.Enemy = Enemy;
		Parameters.Self = Self;
		Function->ProcessEvent(Static_Class(), Function, &Parameters);
		return Parameters.ReturnValue;
	}
}

#pragma once
#include <Windows.h>

namespace CWINGui
{

	namespace Input
	{
		bool mouseDown[5];
		bool mouseDownAlready[256];

		bool keysDown[256];
		bool keysDownAlready[256];

		bool IsAnyMouseDown()
		{
			if (mouseDown[0]) return true;
			if (mouseDown[1]) return true;
			if (mouseDown[2]) return true;
			if (mouseDown[3]) return true;
			if (mouseDown[4]) return true;

			return false;
		}

		bool IsMouseClicked(int button, int element_id, bool repeat)
		{
			if (mouseDown[button])
			{
				if (!mouseDownAlready[element_id])
				{
					mouseDownAlready[element_id] = true;
					return true;
				}
				if (repeat)
					return true;
			}
			else
			{
				mouseDownAlready[element_id] = false;
			}
			return false;
		}
		bool IsKeyPressed(int key, bool repeat)
		{
			if (keysDown[key])
			{
				if (!keysDownAlready[key])
				{
					keysDownAlready[key] = true;
					return true;
				}
				if (repeat)
					return true;
			}
			else
			{
				keysDownAlready[key] = false;
			}
			return false;
		}

		void Handle()
		{
			if (GetAsyncKeyState(0x01))
				mouseDown[0] = true;
			else
				mouseDown[0] = false;
		}
	}
}

wchar_t* s2wc(const char* c)
{
	const size_t cSize = strlen(c) + 1;
	wchar_t* wc = new wchar_t[cSize];
	mbstowcs(wc, c, cSize);

	return wc;
}

namespace CWINGui
{
	namespace Colors
	{
		FLinearColor Text{ 255.0f, 255.0f, 255.0f, 255.0f };
		FLinearColor Text_Shadow{ 0.0f, 0.0f, 0.0f, 1.0f };
		FLinearColor Text_Outline{ 0.0f, 0.0f, 0.0f, 1.0f };

		FLinearColor Window_Background{ 0.009f, 0.009f, 0.009f, 0.3f };
		FLinearColor Window_Header{ 0.255f,0.0f, 0.0f, 1.f };

		FLinearColor Button_Idle{ 0.255f,0.0f, 0.0f, 1.f };
		FLinearColor Button_Hovered{ 0.50f,0.0f, 0.0f, 1.f };
		FLinearColor Button_Active{ 0.100f,0.0f, 0.0f, 1.f };

		FLinearColor Checkbox_Idle{ 0.17f, 0.16f, 0.23f, 1.0f };
		FLinearColor Checkbox_Hovered{ 0.22f, 0.30f, 0.72f, 1.0f };
		FLinearColor Checkbox_Enabled{ 0.255f,0.0f, 0.0f, 1.f };

		FLinearColor Combobox_Idle{ 0.17f, 0.16f, 0.23f, 0.5f };
		FLinearColor Combobox_Hovered{ 0.17f, 0.16f, 0.23f, 0.5f };
		FLinearColor Combobox_Elements{ 0.239f, 0.42f, 0.82f, 0.5f };

		FLinearColor Slider_Idle{ 0.255f, 0.f, 0.f, 0.f };
		FLinearColor Slider_Hovered{ 0.100f,0.0f, 0.0f, 1.f };
		FLinearColor Slider_Progress{ 0.50f, 0.20f, 0.20f, 1.f };
		FLinearColor Slider_Button{ 0.10f, 0.15f, 0.84f, 0.5f };

		FLinearColor ColorPicker_Background{ 0.006f, 0.006f, 0.006f, 0.4f };
	}

	namespace PostRenderer
	{
		struct DrawList
		{
			int type = -1; //1 = FilledRect, 2 = TextLeft, 3 = TextCenter, 4 = Draw_Line
			FVector2D pos;
			FVector2D size;
			FLinearColor color;
			const wchar_t* name;
			bool outline;

			FVector2D from;
			FVector2D to;
			int thickness;
		};
		DrawList drawlist[128];

		void drawFilledRect(FVector2D pos, float w, float h, FLinearColor color)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 1;
					drawlist[i].pos = pos;
					drawlist[i].size = FVector2D{ w, h };
					drawlist[i].color = color;
					return;
				}
			}
		}
		void TextLeft(const wchar_t* name, FVector2D pos, FLinearColor color, bool outline)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 2;
					drawlist[i].name = name;
					drawlist[i].pos = pos;
					drawlist[i].outline = outline;
					drawlist[i].color = color;
					return;
				}
			}
		}
		void TextCenter(const wchar_t* name, FVector2D pos, FLinearColor color, bool outline)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 3;
					drawlist[i].name = name;
					drawlist[i].pos = pos;
					drawlist[i].outline = outline;
					drawlist[i].color = color;
					return;
				}
			}
		}
		void Draw_Line(FVector2D from, FVector2D to, int thickness, FLinearColor color)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 4;
					drawlist[i].from = from;
					drawlist[i].to = to;
					drawlist[i].thickness = thickness;
					drawlist[i].color = color;
					return;
				}
			}
		}
	}

	UCanvas* canvas;


	bool hover_element = false;
	FVector2D menu_pos = FVector2D{ 0, 0 };
	float offset_x = 0.0f;
	float offset_y = 0.0f;

	FVector2D first_element_pos = FVector2D{ 0, 0 };

	FVector2D last_element_pos = FVector2D{ 0, 0 };
	FVector2D last_element_size = FVector2D{ 0, 0 };

	int current_element = -1;
	FVector2D current_element_pos = FVector2D{ 0, 0 };
	FVector2D current_element_size = FVector2D{ 0, 0 };
	int elements_count = 0;

	bool sameLine = false;

	bool pushY = false;
	float pushYvalue = 0.0f;

	void SetupCanvas(UCanvas* _canvas)
	{
		canvas = _canvas;
	}

	FVector2D CursorPos()
	{
		POINT cursorPos;
		GetCursorPos(&cursorPos);
		return FVector2D{ (float)cursorPos.x, (float)cursorPos.y };
	}
	bool MouseInZone(FVector2D pos, FVector2D size)
	{
		FVector2D cursor_pos = CursorPos();

		if (cursor_pos.X > pos.X && cursor_pos.Y > pos.Y)
			if (cursor_pos.X < pos.X + size.X && cursor_pos.Y < pos.Y + size.Y)
				return true;

		return false;
	}

	void Draw_Cursor(bool toogle)
	{
		if (toogle)
		{
			FVector2D cursorPos = CursorPos();
			canvas->K2_DrawLine(FVector2D{ cursorPos.X, cursorPos.Y }, FVector2D{ cursorPos.X + 30, cursorPos.Y + 5 }, 1, FLinearColor{ 255.0f, 0.0f, 0.0f, 1.0f });


			int x = 30;
			int y = 5;
			while (y != 30) //20 steps
			{
				x -= 1; if (x < 15) x = 15;
				y += 1; if (y > 30) y = 30;

				canvas->K2_DrawLine(FVector2D{ cursorPos.X, cursorPos.Y }, FVector2D{ cursorPos.X + x, cursorPos.Y + y }, 1, FLinearColor{ 255.0f, 0.0f, 0.0f, 1.0f });
			}

			canvas->K2_DrawLine(FVector2D{ cursorPos.X, cursorPos.Y }, FVector2D{ cursorPos.X + 15, cursorPos.Y + 30 }, 1, FLinearColor{ 255.0f, 0.0f, 0.0f, 1.0f });
			canvas->K2_DrawLine(FVector2D{ cursorPos.X + 30, cursorPos.Y + 5 }, FVector2D{ cursorPos.X + 15, cursorPos.Y + 30 }, 1, FLinearColor{ 255.0f, 0.0f, 0.0f, 1.0f });
		}
	}

	void SameLine()
	{
		sameLine = true;
	}
	void PushNextElementY(float y, bool from_last_element = true)
	{
		pushY = true;
		if (from_last_element)
			pushYvalue = last_element_pos.Y + last_element_size.Y + y;
		else
			pushYvalue = y;
	}
	void NextColumn(float x)
	{
		offset_x = x;
		PushNextElementY(first_element_pos.Y, false);
	}
	void ClearFirstPos()
	{
		first_element_pos = FVector2D{ 0, 0 };
	}

	void xDrawTextRGB(const wchar_t* text, float x, float y, FLinearColor color)
	{
		canvas->K2_DrawText(text, { x, y }, { 1.1, 1.1 }, { 1.f,1.f,1.f,1.0f }, 0.f, { 0, 0, 0, 1 }, { 0, 0 }, 0, 0, 0, { 0, 0, 0, 1 });
	}
	void yDrawTextRGB(const wchar_t* text, float x, float y, FLinearColor color)
	{
		canvas->K2_DrawText(text, { x, y }, { 1.1, 1.1 }, { 1.f,1.f,1.f,1.0f }, 0.f, { 0, 0, 0, 1 }, { 0, 0 }, 1, 0, 0, { 0, 0, 0, 1 });
	}
	void TextLeft(const wchar_t* name, FVector2D pos, FLinearColor color, bool outline)
	{
		xDrawTextRGB(name, pos.X, pos.Y, { 1,1,1,1 });
	}
	void TextCenter(const wchar_t* name, FVector2D pos, FLinearColor color, bool outline, bool kekw = 0)
	{
		if (kekw)
			yDrawTextRGB(name, pos.X, pos.Y - 10, color);
		else
			yDrawTextRGB(name, pos.X, pos.Y - 10, { 1.f,1.f,1.f,1.0f });
	}

	void GetColor(FLinearColor* color, float* r, float* g, float* b, float* a)
	{
		*r = color->R;
		*g = color->G;
		*b = color->B;
		*a = color->A;
	}
	UINT32 GetColorUINT(int r, int g, int b, int a)
	{
		UINT32 result = (BYTE(a) << 24) + (BYTE(r) << 16) + (BYTE(g) << 8) + BYTE(b);
		return result;
	}

	void Draw_Line(FVector2D from, FVector2D to, int thickness, FLinearColor color)
	{
		canvas->K2_DrawLine(FVector2D{ from.X, from.Y }, FVector2D{ to.X, to.Y }, thickness, color);
	}
	void drawFilledRect(FVector2D initial_pos, float w, float h, FLinearColor color)
	{
		for (float i = 0.0f; i < h; i += 1.0f)
			canvas->K2_DrawLine(FVector2D{ initial_pos.X, initial_pos.Y + i }, FVector2D{ initial_pos.X + w, initial_pos.Y + i }, 1.0f, color);
	}
	void DrawFilledCircle(FVector2D pos, float r, FLinearColor color)
	{
		float smooth = 0.07f;

		double PI = 3.14159265359;
		int size = (int)(2.0f * PI / smooth) + 1;

		float angle = 0.0f;
		int i = 0;

		for (; angle < 2 * PI; angle += smooth, i++)
		{
			Draw_Line(FVector2D{ pos.X, pos.Y }, FVector2D{ pos.X + cosf(angle) * r, pos.Y + sinf(angle) * r }, 1.0f, color);
		}
	}
	void DrawCircle(FVector2D pos, int radius, int numSides, FLinearColor Color)
	{
		float PI = 3.1415927f;

		float Step = PI * 2.0 / numSides;
		int Count = 0;
		FVector2D V[128];
		for (float a = 0; a < PI * 2.0; a += Step) {
			float X1 = radius * cos(a) + pos.X;
			float Y1 = radius * sin(a) + pos.Y;
			float X2 = radius * cos(a + Step) + pos.X;
			float Y2 = radius * sin(a + Step) + pos.Y;
			V[Count].X = X1;
			V[Count].Y = Y1;
			V[Count + 1].X = X2;
			V[Count + 1].Y = Y2;
			//Draw_Line(FVector2D{ pos.X, pos.Y }, FVector2D{ X2, Y2 }, 1.0f, Color); // Points from Centre to ends of circle
			Draw_Line(FVector2D{ V[Count].X, V[Count].Y }, FVector2D{ X2, Y2 }, 1.0f, Color);// Circle Around
		}
	}

	FVector2D dragPos;
	bool Window(const char* name, FVector2D* pos, FVector2D size, bool isOpen)
	{
		elements_count = 0;

		if (!isOpen)
			return false;

		bool isHovered = MouseInZone(FVector2D{ pos->X, pos->Y }, size);

		//Drop last element
		if (current_element != -1 && !GetAsyncKeyState(0x1))
		{
			current_element = -1;
		}

		//Drag
		if (hover_element && GetAsyncKeyState(0x1))
		{

		}
		else if ((isHovered || dragPos.X != 0) && !hover_element)
		{
			if (Input::IsMouseClicked(0, elements_count, true))
			{
				FVector2D cursorPos = CursorPos();

				cursorPos.X -= size.X;
				cursorPos.Y -= size.Y;

				if (dragPos.X == 0)
				{
					dragPos.X = (cursorPos.X - pos->X);
					dragPos.Y = (cursorPos.Y - pos->Y);
				}
				pos->X = cursorPos.X - dragPos.X;
				pos->Y = cursorPos.Y - dragPos.Y;
			}
			else
			{
				dragPos = FVector2D{ 0, 0 };
			}
		}
		else
		{
			hover_element = false;
		}


		offset_x = 0.0f; offset_y = 0.0f;
		menu_pos = FVector2D{ pos->X, pos->Y };
		first_element_pos = FVector2D{ 0, 0 };
		current_element_pos = FVector2D{ 0, 0 };
		current_element_size = FVector2D{ 0, 0 };

		//Bg
		drawFilledRect(FVector2D{ pos->X, pos->Y }, size.X, size.Y, Colors::Window_Background);
		//drawFilledRect(FVector2D{ pos->X, pos->Y }, 122, size.Y, FLinearColor{ 0.006f, 0.006f, 0.006f, 1.0f });//My tabs bg

		//Header
		drawFilledRect(FVector2D{ pos->X, pos->Y }, size.X, 25.0f, Colors::Window_Header);

		offset_y += 25.0f;

		//Title
		FVector2D titlePos = FVector2D{ pos->X + size.X / 2, pos->Y + 25 / 2 };
		TextCenter(s2wc(name), titlePos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);


		return true;
	}

	void Text(const wchar_t* text, bool center = false, bool outline = false)
	{
		elements_count++;

		float size = 24;
		FVector2D padding = FVector2D{ 1,3 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}

		if (!sameLine)
			offset_y += size + padding.Y;

		//Text
		FVector2D textPos = FVector2D{ pos.X + 5.0f, pos.Y };
		if (center)
			TextCenter(text, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, outline);
		else
			TextLeft(text, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, outline);

		sameLine = false;
		last_element_pos = pos;
		//last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;
	}
	bool ButtonTab(const wchar_t* name, FVector2D size, bool active)
	{
		elements_count++;

		FVector2D padding = FVector2D{ 6, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, size);

		//Bg
		if (active)
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Button_Active);
		}
		else if (isHovered)
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Button_Hovered);
			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Button_Idle);
		}

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		//Text
		FVector2D textPos = FVector2D{ pos.X + size.X / 2, pos.Y + size.Y / 2 };
		TextCenter(name, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
			return true;

		return false;
	}
	bool Button(const wchar_t* name, FVector2D size)
	{
		elements_count++;

		FVector2D padding = FVector2D{ 15, 6 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, size);

		//Bg
		if (isHovered)
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Button_Hovered);
			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Button_Idle);
		}

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		//Text
		FVector2D textPos = FVector2D{ pos.X + size.X / 2, pos.Y + size.Y / 2 };
		//if (!TextOverlapedFromActiveElement(textPos))
		TextCenter(name, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
			return true;

		return false;
	}
	void Checkbox(const wchar_t* name, bool* value)
	{
		elements_count++;

		float size = 18;
		float xsize = 5;
		FVector2D padding = FVector2D{ 15,7 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, FVector2D{ size, size });

		//Bg
		if (isHovered)
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size, size, Colors::Checkbox_Hovered);
			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size, size, Colors::Checkbox_Idle);
		}

		if (!sameLine)
			offset_y += size + padding.Y;

		if (*value)
		{
			drawFilledRect(FVector2D{ pos.X + 3, pos.Y + 3 }, size - 6, size - 6, Colors::Checkbox_Enabled);
			//drawFilledRect(FVector2D{ pos.X + 9, pos.Y + 9 }, size - 18, size - 18, Colors::Checkbox_Hovered);
		}



		//Text
		FVector2D textPos = FVector2D{ pos.X + size + 5.0f, pos.Y - xsize + 5.0f };
		//if (!TextOverlapedFromActiveElement(textPos))
		TextLeft(name, textPos, FLinearColor{ 255.0f, 255.0f, 255.0f, 255.0f }, false);

		sameLine = false;
		last_element_pos = pos;
		//last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
			*value = !*value;
	}
	void SliderInt(const wchar_t* name, int* value, int min, int max)
	{
		elements_count++;

		FVector2D size = FVector2D{ 185, 20 };
		FVector2D slider_size = FVector2D{ 200, 8 };
		FVector2D padding = FVector2D{ 10, 4 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, slider_size);

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		//Bg
		if (isHovered || current_element == elements_count)
		{
			//Drag
			if (Input::IsMouseClicked(0, elements_count, true))
			{
				current_element = elements_count;

				FVector2D cursorPos = CursorPos();
				*value = ((cursorPos.X - pos.X) * ((max - min) / slider_size.X)) + min;
				if (*value < min) *value = min;
				if (*value > max) *value = max;
			}

			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, slider_size.X, slider_size.Y, Colors::Slider_Hovered);
			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y + 5.0f }, 5.0f, 5.0f, Colors::Slider_Progress);

			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, slider_size.X, slider_size.Y, Colors::Slider_Idle);
			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y + 5.0f }, 5.0f, 5.0f, Colors::Slider_Progress);
		}


		//Value
		float oneP = slider_size.X / (max - min);
		drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, oneP * (*value - min), slider_size.Y, Colors::Slider_Progress);
		//drawFilledRect(FVector2D{ pos.X + oneP * (*value - min) - 10.0f, pos.Y + slider_size.Y - 5.0f + padding.Y }, 20.0f, 20.0f, Colors::Slider_Button);
		DrawFilledCircle(FVector2D{ pos.X + oneP * (*value - min), pos.Y + slider_size.Y + 3.3f + padding.Y }, 10.0f, Colors::Slider_Button);
		DrawFilledCircle(FVector2D{ pos.X + oneP * (*value - min), pos.Y + slider_size.Y + 3.3f + padding.Y }, 5.0f, Colors::Slider_Progress);


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;
	}
	void SliderFloat(const wchar_t* name, float* value, float min, float max, const char* format = "%.0f")
	{
		elements_count++;
		float xsize = 1;
		FVector2D size = FVector2D{ 220, 40 };
		FVector2D slider_size = FVector2D{ 170, 7 };
		FVector2D adjust_zone = FVector2D{ 0, 20 };
		FVector2D padding = FVector2D{ 15, 6 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y - adjust_zone.Y }, FVector2D{ slider_size.X, slider_size.Y + adjust_zone.Y * 1.5f });

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		//Bg
		if (isHovered || current_element == elements_count)
		{
			//Drag
			if (Input::IsMouseClicked(0, elements_count, true))
			{
				current_element = elements_count;

				FVector2D cursorPos = CursorPos();
				*value = ((cursorPos.X - pos.X) * ((max - min) / slider_size.X)) + min;
				if (*value < min) *value = min;
				if (*value > max) *value = max;
			}

			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, slider_size.X, slider_size.Y, Colors::Slider_Hovered);
			DrawFilledCircle(FVector2D{ pos.X, pos.Y + padding.Y + 9.3f }, 3.1f, Colors::Slider_Progress);
			DrawFilledCircle(FVector2D{ pos.X + slider_size.X, pos.Y + padding.Y + 9.3f }, 3.1f, Colors::Slider_Hovered);

			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, slider_size.X, slider_size.Y, Colors::Slider_Idle);
			DrawFilledCircle(FVector2D{ pos.X, pos.Y + padding.Y + 9.3f }, 3.1f, Colors::Slider_Progress);
			DrawFilledCircle(FVector2D{ pos.X + slider_size.X, pos.Y + padding.Y + 9.3f }, 3.1f, Colors::Slider_Idle);
		}


		//Text
		FVector2D textPos = FVector2D{ pos.X, pos.Y - xsize - 4.0f };
		TextLeft(name, textPos, Colors::Text, false);

		//Value
		float oneP = slider_size.X / (max - min);
		drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, oneP * (*value - min), slider_size.Y, Colors::Slider_Progress);
		DrawFilledCircle(FVector2D{ pos.X + oneP * (*value - min), pos.Y + slider_size.Y + 2.66f + padding.Y }, 8.0f, Colors::Slider_Button);
		DrawFilledCircle(FVector2D{ pos.X + oneP * (*value - min), pos.Y + slider_size.Y + 2.66f + padding.Y }, 4.0f, Colors::Slider_Progress);

		char buffer[32];
		sprintf_s(buffer, format, *value);
		FVector2D valuePos = FVector2D{ pos.X + oneP * (*value - min), pos.Y + slider_size.Y + 20 + padding.Y };
		TextCenter(s2wc(buffer), valuePos, Colors::Text, false);


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;
	}



	bool checkbox_enabled[256];
	void Combobox(const wchar_t* name, FVector2D size, int* value, const wchar_t* arg, ...)
	{
		elements_count++;

		FVector2D padding = FVector2D{ 14, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 20.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, size);

		//Bg
		if (isHovered || checkbox_enabled[elements_count])
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Combobox_Hovered);

			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Combobox_Idle);
		}

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		//Text
		FVector2D textPos = FVector2D{ pos.X + size.X + 5.0f, pos.Y + size.Y / 2 };
		TextLeft((name), textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);

		//Elements
		bool isHovered2 = false;
		FVector2D element_pos = pos;
		int num = 0;

		if (checkbox_enabled[elements_count])
		{
			current_element_size.X = element_pos.X - 5.0f;
			current_element_size.Y = element_pos.Y - 5.0f;
		}
		va_list arguments;
		for (va_start(arguments, arg); arg != NULL; arg = va_arg(arguments, const wchar_t*))
		{
			//Selected Element
			if (num == *value)
			{
				FVector2D _textPos = FVector2D{ pos.X + size.X / 2, pos.Y + size.Y / 2 };
				TextCenter(arg, _textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
			}

			if (checkbox_enabled[elements_count])
			{
				element_pos.Y += 25.0f;

				isHovered2 = MouseInZone(FVector2D{ element_pos.X, element_pos.Y }, FVector2D{ size.X, 25.0f });
				if (isHovered2)
				{
					hover_element = true;
					PostRenderer::drawFilledRect(FVector2D{ element_pos.X, element_pos.Y }, size.X, 25.0f, Colors::Combobox_Hovered);

					//Click
					if (Input::IsMouseClicked(0, elements_count, false))
					{
						*value = num;
						checkbox_enabled[elements_count] = false;
					}
				}
				else
				{
					PostRenderer::drawFilledRect(FVector2D{ element_pos.X, element_pos.Y }, size.X, 25.0f, Colors::Combobox_Idle);
				}

				PostRenderer::TextLeft(arg, FVector2D{ element_pos.X + 10.0f, element_pos.Y + 5.0f }, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
			}
			num++;
		}
		va_end(arguments);
		if (checkbox_enabled[elements_count])
		{
			current_element_size.X = element_pos.X + 5.0f;
			current_element_size.Y = element_pos.Y + 5.0f;
		}


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
		{
			checkbox_enabled[elements_count] = !checkbox_enabled[elements_count];
		}
		if (!isHovered && !isHovered2 && Input::IsMouseClicked(0, elements_count, false))
		{
			checkbox_enabled[elements_count] = false;
		}
	}

	int active_hotkey = -1;
	bool already_pressed = false;
	std::string VirtualKeyCodeToString(UCHAR virtualKey)
	{
		UINT scanCode = MapVirtualKey(virtualKey, MAPVK_VK_TO_VSC);
		if (virtualKey == VK_LBUTTON)
		{
			return ("MOUSE0");
		}
		if (virtualKey == VK_RBUTTON)
		{
			return ("MOUSE1");
		}
		if (virtualKey == VK_MBUTTON)
		{
			return ("MBUTTON");
		}
		if (virtualKey == VK_XBUTTON1)
		{
			return ("XBUTTON1");
		}
		if (virtualKey == VK_XBUTTON2)
		{
			return ("XBUTTON2");
		}


		CHAR szName[128];
		int result = 0;
		switch (virtualKey)
		{
		case VK_LEFT: case VK_UP: case VK_RIGHT: case VK_DOWN:
		case VK_RCONTROL: case VK_RMENU:
		case VK_LWIN: case VK_RWIN: case VK_APPS:
		case VK_PRIOR: case VK_NEXT:
		case VK_END: case VK_HOME:
		case VK_INSERT: case VK_DELETE:
		case VK_DIVIDE:
		case VK_NUMLOCK:
			scanCode |= KF_EXTENDED;
		default:
			result = GetKeyNameTextA(scanCode << 16, szName, 128);
		}

		return szName;
	}
	void Hotkey(const char* name, FVector2D size, int* key)
	{
		elements_count++;

		FVector2D padding = FVector2D{ 15, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y + (last_element_size.Y / 2) - size.Y / 2;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, size);

		//Bg
		if (isHovered)
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Button_Hovered);
			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Button_Idle);
		}

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		if (active_hotkey == elements_count)
		{
			//Text
			FVector2D textPos = FVector2D{ pos.X + size.X / 2, pos.Y + size.Y / 2 };
			TextCenter(L"PressKey", textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);

			if (!CWINGui::Input::IsAnyMouseDown())
			{
				already_pressed = false;
			}

			if (!already_pressed)
			{
				for (int code = 0; code < 255; code++)
				{
					if (GetAsyncKeyState(code))
					{
						*key = code;
						active_hotkey = -1;
					}
				}
			}
		}
		else
		{
			//Text
			FVector2D textPos = FVector2D{ pos.X + size.X / 2, pos.Y + size.Y / 2 };
			TextCenter(s2wc(VirtualKeyCodeToString(*key).c_str()), textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);

			if (isHovered)
			{
				if (Input::IsMouseClicked(0, elements_count, false))
				{
					already_pressed = true;
					active_hotkey = elements_count;

					//Queue Fix
					for (int code = 0; code < 255; code++)
						if (GetAsyncKeyState(code)) {}
				}
			}
			else
			{
				if (Input::IsMouseClicked(0, elements_count, false))
				{
					active_hotkey = -1;
				}
			}
		}


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;
	}

	int active_picker = -1;
	FLinearColor saved_color;
	bool ColorPixel(FVector2D pos, FVector2D size, FLinearColor* original, FLinearColor color)
	{
		PostRenderer::drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, color);

		//Выбранный цвет
		if (original->R == color.R && original->G == color.G && original->B == color.B)
		{
			PostRenderer::Draw_Line(FVector2D{ pos.X, pos.Y }, FVector2D{ pos.X + size.X - 1, pos.Y }, 1.0f, FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
			PostRenderer::Draw_Line(FVector2D{ pos.X, pos.Y + size.Y - 1 }, FVector2D{ pos.X + size.X - 1, pos.Y + size.Y - 1 }, 1.0f, FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
			PostRenderer::Draw_Line(FVector2D{ pos.X, pos.Y }, FVector2D{ pos.X, pos.Y + size.Y - 1 }, 1.0f, FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
			PostRenderer::Draw_Line(FVector2D{ pos.X + size.X - 1, pos.Y }, FVector2D{ pos.X + size.X - 1, pos.Y + size.Y - 1 }, 1.0f, FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
		}

		//Смена цвета
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, size);
		if (isHovered)
		{
			if (Input::IsMouseClicked(0, elements_count, false))
				*original = color;
		}

		return true;
	}
	void ColorPicker(const wchar_t* name, FLinearColor* color)
	{
		elements_count++;

		float size = 25;
		float xsize = 5;
		FVector2D padding = FVector2D{ 15, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, FVector2D{ size, size });

		if (!sameLine)
			offset_y += size + padding.Y;

		if (active_picker == elements_count)
		{
			hover_element = true;

			float sizePickerX = 250;
			float sizePickerY = 250;
			bool isHoveredPicker = MouseInZone(FVector2D{ pos.X, pos.Y }, FVector2D{ sizePickerX, sizePickerY - 60 });

			//Background
			PostRenderer::drawFilledRect(FVector2D{ pos.X, pos.Y }, sizePickerX, sizePickerY - 65, Colors::ColorPicker_Background);

			FVector2D pixelSize = FVector2D{ sizePickerX / 12, sizePickerY / 12 };

			//0
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 174 / 255.f, 235 / 255.f, 253 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 136 / 255.f, 225 / 255.f, 251 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 108 / 255.f, 213 / 255.f, 250 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 89 / 255.f, 175 / 255.f, 213 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 76 / 255.f, 151 / 255.f, 177 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 60 / 255.f, 118 / 255.f, 140 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 43 / 255.f, 85 / 255.f, 100 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 32 / 255.f, 62 / 255.f, 74 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 255 / 255.f, 255 / 255.f, 255 / 255.f, 1.0f });
			}
			//1
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 175 / 255.f, 205 / 255.f, 252 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 132 / 255.f, 179 / 255.f, 252 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 90 / 255.f, 152 / 255.f, 250 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 55 / 255.f, 120 / 255.f, 250 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 49 / 255.f, 105 / 255.f, 209 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 38 / 255.f, 83 / 255.f, 165 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 28 / 255.f, 61 / 255.f, 120 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 20 / 255.f, 43 / 255.f, 86 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 247 / 255.f, 247 / 255.f, 247 / 255.f, 1.0f });
			}
			//2
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 153 / 255.f, 139 / 255.f, 250 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 101 / 255.f, 79 / 255.f, 249 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 64 / 255.f, 50 / 255.f, 230 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 54 / 255.f, 38 / 255.f, 175 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 39 / 255.f, 31 / 255.f, 144 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 32 / 255.f, 25 / 255.f, 116 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 21 / 255.f, 18 / 255.f, 82 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 16 / 255.f, 13 / 255.f, 61 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 228 / 255.f, 228 / 255.f, 228 / 255.f, 1.0f });
			}
			//3
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 194 / 255.f, 144 / 255.f, 251 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 165 / 255.f, 87 / 255.f, 249 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 142 / 255.f, 57 / 255.f, 239 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 116 / 255.f, 45 / 255.f, 184 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 92 / 255.f, 37 / 255.f, 154 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 73 / 255.f, 29 / 255.f, 121 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 53 / 255.f, 21 / 255.f, 88 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 37 / 255.f, 15 / 255.f, 63 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 203 / 255.f, 203 / 255.f, 203 / 255.f, 1.0f });
			}
			//4
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 224 / 255.f, 162 / 255.f, 197 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 210 / 255.f, 112 / 255.f, 166 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 199 / 255.f, 62 / 255.f, 135 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 159 / 255.f, 49 / 255.f, 105 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 132 / 255.f, 41 / 255.f, 89 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 104 / 255.f, 32 / 255.f, 71 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 75 / 255.f, 24 / 255.f, 51 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 54 / 255.f, 14 / 255.f, 36 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 175 / 255.f, 175 / 255.f, 175 / 255.f, 1.0f });
			}
			//5
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 235 / 255.f, 175 / 255.f, 176 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 227 / 255.f, 133 / 255.f, 135 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 219 / 255.f, 87 / 255.f, 88 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 215 / 255.f, 50 / 255.f, 36 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 187 / 255.f, 25 / 255.f, 7 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 149 / 255.f, 20 / 255.f, 6 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 107 / 255.f, 14 / 255.f, 4 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 77 / 255.f, 9 / 255.f, 3 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 144 / 255.f, 144 / 255.f, 144 / 255.f, 1.0f });
			}
			//6
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 241 / 255.f, 187 / 255.f, 171 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 234 / 255.f, 151 / 255.f, 126 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 229 / 255.f, 115 / 255.f, 76 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 227 / 255.f, 82 / 255.f, 24 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 190 / 255.f, 61 / 255.f, 15 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 150 / 255.f, 48 / 255.f, 12 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 107 / 255.f, 34 / 255.f, 8 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 79 / 255.f, 25 / 255.f, 6 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 113 / 255.f, 113 / 255.f, 113 / 255.f, 1.0f });
			}
			//7
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 245 / 255.f, 207 / 255.f, 169 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 240 / 255.f, 183 / 255.f, 122 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 236 / 255.f, 159 / 255.f, 74 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 234 / 255.f, 146 / 255.f, 37 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 193 / 255.f, 111 / 255.f, 28 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 152 / 255.f, 89 / 255.f, 22 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 110 / 255.f, 64 / 255.f, 16 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 80 / 255.f, 47 / 255.f, 12 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 82 / 255.f, 82 / 255.f, 82 / 255.f, 1.0f });
			}
			//8
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 247 / 255.f, 218 / 255.f, 170 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 244 / 255.f, 200 / 255.f, 124 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 241 / 255.f, 182 / 255.f, 77 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 239 / 255.f, 174 / 255.f, 44 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 196 / 255.f, 137 / 255.f, 34 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 154 / 255.f, 108 / 255.f, 27 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 111 / 255.f, 77 / 255.f, 19 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 80 / 255.f, 56 / 255.f, 14 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 54 / 255.f, 54 / 255.f, 54 / 255.f, 1.0f });
			}
			//9
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 254 / 255.f, 243 / 255.f, 187 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 253 / 255.f, 237 / 255.f, 153 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 253 / 255.f, 231 / 255.f, 117 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 254 / 255.f, 232 / 255.f, 85 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 242 / 255.f, 212 / 255.f, 53 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 192 / 255.f, 169 / 255.f, 42 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 138 / 255.f, 120 / 255.f, 30 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 101 / 255.f, 87 / 255.f, 22 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 29 / 255.f, 29 / 255.f, 29 / 255.f, 1.0f });
			}
			//10
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 247 / 255.f, 243 / 255.f, 185 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 243 / 255.f, 239 / 255.f, 148 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 239 / 255.f, 232 / 255.f, 111 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 235 / 255.f, 229 / 255.f, 76 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 208 / 255.f, 200 / 255.f, 55 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 164 / 255.f, 157 / 255.f, 43 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 118 / 255.f, 114 / 255.f, 31 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 86 / 255.f, 82 / 255.f, 21 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 9 / 255.f, 9 / 255.f, 9 / 255.f, 1.0f });
			}
			//11
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 218 / 255.f, 232 / 255.f, 182 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 198 / 255.f, 221 / 255.f, 143 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 181 / 255.f, 210 / 255.f, 103 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 154 / 255.f, 186 / 255.f, 76 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 130 / 255.f, 155 / 255.f, 64 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 102 / 255.f, 121 / 255.f, 50 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 74 / 255.f, 88 / 255.f, 36 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 54 / 255.f, 64 / 255.f, 26 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 0 / 255.f, 0 / 255.f, 0 / 255.f, 1.0f });
			}



			if (isHoveredPicker)
			{
				if (Input::IsMouseClicked(0, elements_count, false))
				{

				}
			}
			else
			{
				if (Input::IsMouseClicked(0, elements_count, false))
				{
					active_picker = -1;
					//hover_element = false;
				}
			}
		}
		else
		{
			//Bg
			if (isHovered)
			{
				drawFilledRect(FVector2D{ pos.X, pos.Y }, size, size, Colors::Checkbox_Hovered);
				hover_element = true;
			}
			else
			{
				drawFilledRect(FVector2D{ pos.X, pos.Y }, size, size, Colors::Checkbox_Idle);
			}

			//Color
			drawFilledRect(FVector2D{ pos.X + 4, pos.Y + 4 }, size - 8, size - 8, *color);

			//Text
			FVector2D textPos = FVector2D{ pos.X + size + 5.0f, pos.Y - xsize + 6.0f };
			TextLeft(name, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);

			if (isHovered && Input::IsMouseClicked(0, elements_count, false))
			{
				saved_color = *color;
				active_picker = elements_count;
			}
		}


		sameLine = false;
		last_element_pos = pos;
		//last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;
	}


	void Render()
	{
		for (int i = 0; i < 128; i++)
		{
			if (PostRenderer::drawlist[i].type != -1)
			{
				//Filled Rect
				if (PostRenderer::drawlist[i].type == 1)
				{
					CWINGui::drawFilledRect(PostRenderer::drawlist[i].pos, PostRenderer::drawlist[i].size.X, PostRenderer::drawlist[i].size.Y, PostRenderer::drawlist[i].color);
				}
				//TextLeft
				else if (PostRenderer::drawlist[i].type == 2)
				{
					CWINGui::TextLeft((const wchar_t*)PostRenderer::drawlist[i].name, PostRenderer::drawlist[i].pos, PostRenderer::drawlist[i].color, PostRenderer::drawlist[i].outline);
				}
				//TextCenter
				else if (PostRenderer::drawlist[i].type == 3)
				{
					CWINGui::TextCenter((const wchar_t*)PostRenderer::drawlist[i].name, PostRenderer::drawlist[i].pos, PostRenderer::drawlist[i].color, PostRenderer::drawlist[i].outline);
				}
				//Draw_Line
				else if (PostRenderer::drawlist[i].type == 4)
				{
					Draw_Line(PostRenderer::drawlist[i].from, PostRenderer::drawlist[i].to, PostRenderer::drawlist[i].thickness, PostRenderer::drawlist[i].color);
				}

				PostRenderer::drawlist[i].type = -1;
			}
		}
	}
}
```

`DLLMain.cpp`:

```cpp
#include <Windows.h>
#include <cstdio>
#include "sdk.h"
#include "decryption.h"
#include "hook.h"
#include "Decryptor.h"
using PostRenderHook = void(*)(uintptr_t _this, UCanvas* canvas);
PostRenderHook pRender = 0;

uintptr_t UWorldXOR;
UWorld* UWorldClass;
UGameInstance* GameInstance;
ULocalPlayer* LocalPlayers;
ULocalPlayer* LocalPlayer;

void DrawTextRGB(UCanvas* canvas, const wchar_t* text, float x, float y, FLinearColor color, bool CenterX = 0)
{
	canvas->K2_DrawText(text, { x, y }, { 1.1, 1.1 }, color, 0.f, { 0, 0, 0, 1 }, { 0, 0 }, CenterX, 0, bOutline, { 0, 0, 0, 1 });
}
void DrawTextRGBWithFString(UCanvas* canvas, FString text, float x, float y, FLinearColor color, bool CenterX = 0)
{
	canvas->K2_DrawText(text, { x, y }, { 1.1, 1.1 }, color, 0.f, { 0, 0, 0, 1 }, { 0, 0 }, CenterX, 0, bOutline, { 0, 0, 0, 1 });
}

void xxDrawTextRGB(UCanvas* canvas, FString text, float x, float y, FLinearColor color)
{
	canvas->K2_DrawText(text, { x, y }, { 1.1, 1.1 }, color, 0.f, { 0, 0, 0, 1 }, { 0, 0 }, 0, 0, false, { 0, 0, 0, 1 });
}
FLinearColor RGBtoFLC(float R, float G, float B)
{
	return { R / 255, G / 255, B / 255, 1 };
}

bool kekIsOff = 0; // debugging purposes ONLY solely for THAT
bool chams = 0;

static FLinearColor test_color{ 2.093f, 0.019f, 20.0f, 5.9f };
static FLinearColor MainESPColor{ 2.093f, 0.019f, 20.0f, 5.9f };
static FLinearColor behind_wall_color = RGBtoFLC(255, 255, 255);
static FLinearColor visible_color = RGBtoFLC(0, 255, 0);
static FLinearColor circlecol = RGBtoFLC(0, 255, 0);
static bool menu_opened = false;
FVector2D pos = { 100,100 };

static bool ChamsESP = false;
static bool brightchammy = false;
static bool box2d = false;
static bool PlayerNames = false;
static bool chammyteam = false;
static bool fovchanger = false;
static bool thirdperson = false;
static bool flyhack = false;
static bool healthcol = false;
static bool enableaim = false;
static bool memory = false;
static bool silent = false;
static bool drawfov = false;
int KEKWNOKEY;
static float radius = 100.0f;
static float fovchangur = 80.0f;

float ESPThickness = 1.0f;
float Lineamount = 500.0f;


void DrawBox(UCanvas* can, FVector2D& topleft, FVector2D& downright, FLinearColor clr)
{
	auto h = downright.Y - topleft.Y;
	auto w = downright.X - topleft.X;

	auto downleft = FVector2D{ topleft.X, downright.Y };
	auto topright = FVector2D{ downright.X, topleft.Y };

	auto thicc = ESPThickness;

	FLinearColor xclr = RGBtoFLC(0, 0, 0);

	can->K2_DrawLinex(topleft, { topleft.X, topleft.Y + h * 1 }, thicc, clr);
	can->K2_DrawLinex(topleft, { topleft.X + w * 1, topleft.Y }, thicc, clr);

	can->K2_DrawLinex(downright, { downright.X, downright.Y - h * 1 }, thicc, clr);
	can->K2_DrawLinex(downright, { downright.X - w * 1, downright.Y }, thicc, clr);

	can->K2_DrawLinex(downleft, { downleft.X, downleft.Y - h * 1 }, thicc, clr);
	can->K2_DrawLinex(downleft, { downleft.X + w * 1, downright.Y }, thicc, clr);

	can->K2_DrawLinex(topright, { topright.X, topright.Y + h * 1 }, thicc, clr);
	can->K2_DrawLinex(topright, { topright.X - w * 1, topright.Y }, thicc, clr);

	/*
	* OLD (remove 3 first line integrity)
	can->K2_DrawLine({topleft.X, topleft.Y + 100}, {topleft.X, topleft.Y + h * 1}, thicc, clr);
	can->K2_DrawLine({ topleft.X, topleft.Y + 100 }, { topleft.X + w * 1, topleft.Y }, thicc, clr);

	can->K2_DrawLine({ downright.X, downright.Y - 100 }, { downright.X, downright.Y - h * 1 }, thicc, clr);
	can->K2_DrawLine(downright, { downright.X - w * 1, downright.Y }, thicc, clr);

	can->K2_DrawLine(downleft, { downleft.X, downleft.Y - h * 1 }, thicc, clr);
	can->K2_DrawLine(downleft, { downleft.X + w * 1, downright.Y }, thicc, clr);

	can->K2_DrawLine(topright, { topright.X, topright.Y + h * 1 }, thicc, clr);
	can->K2_DrawLine(topright, { topright.X - w * 1, topright.Y }, thicc, clr);*/
}
uintptr_t OffsetGetActorBounds;
void GetActorBounds(AShooterCharacter* Actor, bool bOnlyCollidingComponents, FVector* Origin, FVector* BoxExtent, bool bIncludeFromChildActors)
{
	reinterpret_cast<void(*)(AShooterCharacter*, bool, FVector * pos, FVector * screen, bool)> ((uintptr_t)GetModuleHandleA(0) + 0x498aaa0)(Actor, 0, Origin, BoxExtent, 0);
}
static FVector2D scr[8];

void FMath::SinCos(float* ScalarSin, float* ScalarCos, float Value)
{
	// Map Value to y in [-pi,pi], x = 2*pi*quotient + remainder.
	float quotient = (INV_PI * 0.5f) * Value;
	if (Value >= 0.0f)
	{
		quotient = (float)((int)(quotient + 0.5f));
	}
	else
	{
		quotient = (float)((int)(quotient - 0.5f));
	}
	float y = Value - (2.0f * PI) * quotient;

	// Map y to [-pi/2,pi/2] with sin(y) = sin(Value).
	float sign;
	if (y > HALF_PI)
	{
		y = PI - y;
		sign = -1.0f;
	}
	else if (y < -HALF_PI)
	{
		y = -PI - y;
		sign = -1.0f;
	}
	else
	{
		sign = +1.0f;
	}

	float y2 = y * y;

	// 11-degree minimax approximation
	*ScalarSin = (((((-2.3889859e-08f * y2 + 2.7525562e-06f) * y2 - 0.00019840874f) * y2 + 0.0083333310f) * y2 - 0.16666667f) * y2 + 1.0f) * y;

	// 10-degree minimax approximation
	float p = ((((-2.6051615e-07f * y2 + 2.4760495e-05f) * y2 - 0.0013888378f) * y2 + 0.041666638f) * y2 - 0.5f) * y2 + 1.0f;
	*ScalarCos = sign * p;
}

float FMath::Fmod(float X, float Y)
{
	const float AbsY = fabsf(Y);
	if (AbsY <= 1.e-8f) { return 0.f; }
	const float Div = (X / Y);
	// All floats where abs(f) >= 2^23 (8388608) are whole numbers so do not need truncation, and avoid overflow in TruncToFloat as they get even larger.
	const float Quotient = fabsf(Div) < FLOAT_NON_FRACTIONAL ? truncf(Div) : Div;
	float IntPortion = Y * Quotient;

	// Rounding and imprecision could cause IntPortion to exceed X and cause the result to be outside the expected range.
	// For example Fmod(55.8, 9.3) would result in a very small negative value!
	if (fabsf(IntPortion) > fabsf(X)) { IntPortion = X; }

	const float Result = X - IntPortion;
	// Clamp to [-AbsY, AbsY] because of possible failures for very large numbers (>1e10) due to precision loss.
	// We could instead fall back to stock fmodf() for large values, however this would diverge from the SIMD VectorMod() which has no similar fallback with reasonable performance.
	return FMath::Clamp(Result, -AbsY, AbsY);
}
FQuat FRotator::Quaternion() const
{
	float SP, SY, SR;
	float CP, CY, CR;
	const float PitchNoWinding = FMath::Fmod(Pitch, 360.0f);
	const float YawNoWinding = FMath::Fmod(Yaw, 360.0f);
	const float RollNoWinding = FMath::Fmod(Roll, 360.0f);
	FMath::SinCos(&SP, &CP, PitchNoWinding * RADS_DIVIDED_BY_2);
	FMath::SinCos(&SY, &CY, YawNoWinding * RADS_DIVIDED_BY_2);
	FMath::SinCos(&SR, &CR, RollNoWinding * RADS_DIVIDED_BY_2);
	FQuat RotationQuat;
	RotationQuat.X = CR * SP * SY - SR * CP * CY;
	RotationQuat.Y = -CR * SP * CY - SR * CP * SY;
	RotationQuat.Z = CR * CP * SY - SR * SP * CY;
	RotationQuat.W = CR * CP * CY + SR * SP * SY;
	return RotationQuat;
}

const FVector FVector::ZeroVector(0.0f, 0.0f, 0.0f);
const FVector FVector::OneVector(1.0f, 1.0f, 1.0f);
FVector FTransform::TransformPosition(FVector& V) const
{
	return Rotation.RotateVector(Scale3D * V) + Translation;
}

FVector FQuat::RotateVector(const FVector& V) const
{
	const FVector Q(X, Y, Z);
	const FVector T = (Q ^ V) * 2.f;
	const FVector Result = V + (T * W) + (Q ^ T);
	return Result;
}

bool a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18;
void  Draw3DBox(UCanvas* _this, APlayerController* plc, FVector origin, FVector extends, FLinearColor col)
{
	origin -= extends / 2.f;

	// bottom plane
	FVector one = origin;
	FVector two = origin; two.X += extends.X;
	FVector three = origin; three.X += extends.X; three.Y += extends.Y;
	FVector four = origin; four.Y += extends.Y;

	FVector five = one; five.Z += extends.Z;
	FVector six = two; six.Z += extends.Z;
	FVector seven = three; seven.Z += extends.Z;
	FVector eight = four; eight.Z += extends.Z;



	if (plc->ProjectWorldLocationToScreen(one, scr[0], 0) || plc->ProjectWorldLocationToScreen(two, scr[1], 0) || plc->ProjectWorldLocationToScreen(three, scr[2], 0) || plc->ProjectWorldLocationToScreen(four, scr[3], 0))
	{
		if (plc->ProjectWorldLocationToScreen(five, scr[4], 0) || plc->ProjectWorldLocationToScreen(six, scr[5], 0) || plc->ProjectWorldLocationToScreen(seven, scr[6], 0) || plc->ProjectWorldLocationToScreen(eight, scr[7], 0))
		{
			_this->K2_DrawLine(scr[0], scr[1], ESPThickness, col);
			_this->K2_DrawLine(scr[1], scr[2], ESPThickness, col);
			_this->K2_DrawLine(scr[2], scr[3], ESPThickness, col);
			_this->K2_DrawLine(scr[3], scr[0], ESPThickness, col);

			_this->K2_DrawLine(scr[4], scr[5], ESPThickness, col);
			_this->K2_DrawLine(scr[5], scr[6], ESPThickness, col);
			_this->K2_DrawLine(scr[6], scr[7], ESPThickness, col);
			_this->K2_DrawLine(scr[7], scr[4], ESPThickness, col);

			_this->K2_DrawLine(scr[0], scr[4], ESPThickness, col);
			_this->K2_DrawLine(scr[1], scr[5], ESPThickness, col);
			_this->K2_DrawLine(scr[2], scr[6], ESPThickness, col);
			_this->K2_DrawLine(scr[3], scr[7], ESPThickness, col);
		}
	}

	// 3 copies of each vertex? trash

}

bool Render3DBox(APlayerController* controller, UCanvas* Engine, const FVector& origin, const FVector& extent, const FRotator& rotation, const FLinearColor color)
{
	FVector vertex[2][4];
	vertex[0][0] = { -extent.X, -extent.Y,  -extent.Z };
	vertex[0][1] = { extent.X, -extent.Y,  -extent.Z };
	vertex[0][2] = { extent.X, extent.Y,  -extent.Z };
	vertex[0][3] = { -extent.X, extent.Y, -extent.Z };

	vertex[1][0] = { -extent.X, -extent.Y, extent.Z };
	vertex[1][1] = { extent.X, -extent.Y, extent.Z };
	vertex[1][2] = { extent.X, extent.Y, extent.Z };
	vertex[1][3] = { -extent.X, extent.Y, extent.Z };

	FVector2D screen[2][4];
	FTransform const Transform(rotation);
	for (auto k = 0; k < 2; k++)
	{
		for (auto i = 0; i < 4; i++)
		{
			auto& vec = vertex[k][i];
			vec = Transform.TransformPosition(vec) + origin;
			if (!controller->ProjectWorldLocationToScreen(vec, screen[k][i], false)) return false;
		}

	}

	auto SurfaceScreen = reinterpret_cast<FVector2D(&)[2][4]>(screen);

	for (auto i = 0; i < 4; i++)
	{
		Engine->K2_DrawLine(SurfaceScreen[0][i], SurfaceScreen[0][(i + 1) % 4], ESPThickness, color);
		Engine->K2_DrawLine(SurfaceScreen[1][i], SurfaceScreen[1][(i + 1) % 4], ESPThickness, color);
		Engine->K2_DrawLine(SurfaceScreen[0][i], SurfaceScreen[1][i], ESPThickness, color);
	}

	return true;
}
bool healthbar = 0;
bool aimbotvischeck = 1;
void PostRender(uintptr_t _this, UCanvas* canvas)
{
	if (!canvas)
		return PostRender(_this, canvas);

	if (kekIsOff)return PostRender(_this, canvas);
	CWINGui::SetupCanvas(canvas);
	UWorld* World = Memory::ReadStub<UWorld*>(_this + 0x80);
	APlayerController* MyController = ShooterGameBlueprints::GetFirstLocalPlayerController(World);
	AShooterCharacter* MyShooter = MyController->GetShooterCharacter();
	TArray<AShooterCharacter*> Actors = ShooterGameBlueprints::FindAllShooterCharactersWithAlliance(World, MyShooter, EAresAlliance::Alliance_Any, false, true); 
	CWINGui::Input::Handle();

	if (GetAsyncKeyState(VK_INSERT) & 1) menu_opened = !menu_opened; //Our menu key 
	if (enableaim && drawfov)
	{
		CWINGui::DrawCircle({ (float)GetSystemMetrics(SM_CXSCREEN) / 2, (float)GetSystemMetrics(SM_CYSCREEN) / 2 }, radius, Lineamount, circlecol);
	}
	if (CWINGui::Window(skCrypt(" gay"), &pos, FVector2D{ 500.0f, 400.0f }, menu_opened))
	{
		//Simple Tabs
		static int tab = 0;
		if (CWINGui::ButtonTab(L"> AIM", FVector2D{ 110, 50 }, tab == 0)) tab = 0; 
		if (CWINGui::ButtonTab(L"> ESP", FVector2D{ 110, 50 }, tab == 1)) tab = 1;
		if (CWINGui::ButtonTab(L"> MISC", FVector2D{ 110, 50 }, tab == 2)) tab = 2;
		CWINGui::NextColumn(140.0f);
		//Some Elements


		if (tab == 0)
		{
			CWINGui::Checkbox(L"Toggle", &enableaim); 
			CWINGui::Checkbox(L"Memory Mode", &memory); 
			CWINGui::Checkbox(L"Only aim when player is visible", &aimbotvischeck); 
			CWINGui::Checkbox(L"Draw FOV", &drawfov); 
			CWINGui::Hotkey("Keybind", {132,32}, &KEKWNOKEY); 
			CWINGui::SliderFloat(L"Radius", &radius, 1, 2000); 
			CWINGui::ColorPicker(L"Circle color", &circlecol); 
			CWINGui::SliderFloat(L"Amount of lines in circle", &Lineamount, 10, 1000);
		}

		if (tab == 1)
		{
			CWINGui::Checkbox(L"Chams", &ChamsESP); 
			CWINGui::Checkbox(L"Bounding Boxes", &box2d); 
			CWINGui::Checkbox(L"Player Names", &PlayerNames); 
			CWINGui::Checkbox(L"Health Bar", &healthbar); 
			CWINGui::Checkbox(L"Draw Allies", &chammyteam); 
			CWINGui::Checkbox(L"Outline", &bOutline); 
			CWINGui::Checkbox(L"Replace text by health", &healthcol); 
			CWINGui::ColorPicker(L"Chams Color", &MainESPColor); 
			CWINGui::ColorPicker(L"Behind Wall Color", &behind_wall_color); 
			CWINGui::ColorPicker(L"Visible Color", &visible_color); 
			CWINGui::SliderFloat(L"ESP Thickness", &ESPThickness, 1, 10);
		}

		if (tab == 2)
		{
			CWINGui::Checkbox(L"Fly (training range only)", &flyhack); 
			CWINGui::Checkbox(L"Third Person Viewmode", &thirdperson); 
			CWINGui::Checkbox(L"Camera Slider", &fovchanger); 
			CWINGui::SliderFloat(L"FOV", &fovchangur, 0, 300);
		}

		if (tab == 3)
		{
		}


		//Color Picker
	}
	CWINGui::Draw_Cursor(menu_opened);
	CWINGui::Render();//Custom Render. I use it for drawing Combobox and ColorPicker over the menu 
	if (fovchanger)
		MyController->set_fov(fovchangur);
	for (int Index = 0; Index < Actors.Num(); Index++)
	{
		if (!Actors.IsValidIndex(Index))
			continue;

		AShooterCharacter* Actor = Actors[Index];


		if (Actor->GetHealth() == 0)
			continue;

		if (!chammyteam)
		{
			if (BaseTeamComponent::IsAlly(Actor, MyShooter))
				continue;
		}

		USkeletalMeshComponent* Mesh = Actor->GetPawnMesh();
		bool IsAlive = Actor->IsAlive();


		if (Mesh && IsAlive)
		{
			CWINGui::TextCenter(skCrypt(L"ENEMY NEARBY"), { 1920,30 }, RGBtoFLC(255, 0, 0), 1, 1);
			FLinearColor MainColor;
			if (MyController->LineOfSightTo(Actor, { 0,0,0 }, false))
				MainColor = visible_color;
			else
				MainColor = behind_wall_color;

			if (flyhack)
				MyShooter->ClientFly();
			if (box2d)
			{
				FVector Origin, Extend;
				GetActorBounds(Actor, 1, &Origin, &Extend, 0);

				//Render3DBox(MyController, canvas, Origin, Extend, Actor->K2_GetActorRotation(), xtest_color);
				//Draw3DBox(canvas, MyController, Origin, Extend, xtest_color);
				auto location = Actor->K2_GetActorLocation(); FVector2D footPos;
				if (!MyController->ProjectWorldLocationToScreen({ location.X, location.Y, location.Z + (Extend.Z / 2) }, footPos, 0)) continue;

				FVector2D headPos;
				if (!MyController->ProjectWorldLocationToScreen({ location.X, location.Y, location.Z - (Extend.Z / 2) }, headPos, 0)) continue;


				const float height = abs(footPos.Y - headPos.Y);
				const float width = height * 0.4f;
				FVector2D top = { headPos.X - width * 0.5f, headPos.Y };
				FVector2D bottom = { headPos.X + width * 0.5f, footPos.Y };
				DrawBox(canvas, top, bottom, MainColor);
			}

			if (thirdperson)
			{
				MyShooter->Set3pMeshVisible(1);
			}
			else
			{
				MyShooter->Set3pMeshVisible(0);
			}

			if (enableaim)
			{
				if (memory)
				{
					static AShooterCharacter* closestEnemy = nullptr;
					static float closestDistance = 999999.9f;
					if (closestEnemy)
					{
						/* Obtain health and RelativeLocation */
						auto Health = Actor->GetHealth();
						auto RelativeLocation = Actor->K2_GetActorLocation();

						/* Define vectors */
						FVector Origin, Extend;
						GetActorBounds(Actor, 1, &Origin, &Extend, 0);

						/* W2S the vectors */
						auto location = Actor->K2_GetActorLocation(); FVector2D footPos;
						if (!MyController->ProjectWorldLocationToScreen({ location.X, location.Y, location.Z - (Extend.Z / 2) }, footPos, 0)) continue;

						FRotator LocRotator = { DEG(asinf(location.X / location.Magnitude())), DEG(atan2f(location.Y, location.X)), 0.0f };

						if (GetAsyncKeyState(KEKWNOKEY))
							MyController->ExecSetCameraRotator(LocRotator);
					}
					else if (Actor)
					{
						closestEnemy = Actor;
					}
				}
			}

			if (healthbar)
			{
				FVector Origin, Extend;
				GetActorBounds(Actor, 1, &Origin, &Extend, 0);

				auto location = Actor->K2_GetActorLocation(); FVector2D footPos;
				if (!MyController->ProjectWorldLocationToScreen({ location.X, location.Y, location.Z - (Extend.Z / 2) }, footPos, 0)) continue;

				FVector2D headPos;
				if (!MyController->ProjectWorldLocationToScreen({ location.X, location.Y, location.Z + (Extend.Z / 2) }, headPos, 0)) continue;

				auto maxhealth = Actor->GetMaxHealth();
				if (maxhealth >= 100)maxhealth = 100;
				const float hp = Actor->GetHealth() / maxhealth;

				const float height = abs(footPos.Y - headPos.Y);
				const float width = height * 0.4f;
				const float width2 = width * 0.5f;
				const float adjust = height * 0.025f;
				const float len = width * hp;

				FVector2D top = { headPos.X - width * 0.5f, headPos.Y };
				FVector2D bottom = { headPos.X + width * 0.5f, footPos.Y };
				auto downleft = FVector2D{ top.X, bottom.Y };
				auto topright = FVector2D{ bottom.X, top.Y };

				auto h = bottom.Y - top.Y;
				auto w = bottom.X - top.X;
				auto thicc = ESPThickness;

				canvas->K2_DrawLinex({ headPos.X - width2, footPos.Y + adjust }, { headPos.X - width2 + len, footPos.Y + adjust * 2.f }, 5, RGBtoFLC(0, 255, 0));

			}

			if (PlayerNames)
			{
				/* Define vectors */
				FVector Origin, Extend;
				FVector2D rel2d, footPos;

				/* Get bouuuuuuunds */
				GetActorBounds(Actor, 1, &Origin, &Extend, 0);

				/* Obtain health and RelativeLocation */
				auto Health = Actor->GetHealth();
				auto RelativeLocation = Actor->K2_GetActorLocation();

				/* W2S the vectors */
				if (MyController->ProjectWorldLocationToScreen({ RelativeLocation.X, RelativeLocation.Y, RelativeLocation.Z - (Extend.Z / 2) }, footPos, 0))
				{
					if (MyController->ProjectWorldLocationToScreen(Actor->K2_GetActorLocation(), rel2d, true))
					{
						/* And print the name out */
						//int Index = Memory::ReadStub<int>(reinterpret_cast<uintptr_t>(Actor) + 0x18);
						//FName NoneFName(0);

						//std::string None = NoneFName.GetName();

						//if (None != "None") std::cout << "Nah bro it failed" << std::endl;
						//if (Player.GetName() != "")
						//{
						//	std::wstring PlayerW(Player.GetName().begin(), Player.GetName().end());
						//	DrawTextRGBWithFString(canvas, PlayerW.c_str(), footPos.X, footPos.Y + 10, MainColor, 1);
						//}
					}
				}
			}

			if (ChamsESP)
			{
				Mesh->SetAresOutlineMode(EAresOutlineMode::Outline, true);
				AresOutlineRendering::SetOutlineColorsForRender(World, MainESPColor, MainESPColor);
			}
			else
			{
				Mesh->SetAresOutlineMode(EAresOutlineMode::None, true);
			}

		}
	}

	return pRender(_this, canvas);
}



void Init()
{
	//AllocConsole();
	//freopen("CONIN$", "r", stdin);
	//freopen("CONOUT$", "w", stdout);
	VALORANT::Module = (uintptr_t)GetModuleHandleA(0);
	uintptr_t WorldKey = *(uintptr_t*)(VALORANT::Module + Offsets::Key);
	State StateKey = *(State*)(VALORANT::Module + Offsets::State);
	UWorldXOR = Decryption::Decrypt_UWorld(WorldKey, (uintptr_t*)&StateKey);
	UWorldClass = Memory::ReadStub<UWorld*>(UWorldXOR);
	GameInstance = Memory::ReadStub<UGameInstance*>((uintptr_t)UWorldClass + 0x1A0);
	LocalPlayers = Memory::ReadStub<ULocalPlayer*>((uintptr_t)GameInstance + 0x40); //this is tarray but im paster lol
	LocalPlayer = Memory::ReadStub<ULocalPlayer*>((uintptr_t)LocalPlayers); //
	APlayerController* LocalController = Memory::ReadStub<APlayerController*>((uintptr_t)LocalPlayer + 0x38);
	uintptr_t ViewportClient = Memory::ReadStub<uintptr_t>((uintptr_t)LocalPlayer + 0x78);
	uintptr_t Engine = Memory::ReadStub<uintptr_t>((uintptr_t)GameInstance + 0x28);
	DefaultMediumFont = Memory::ReadStub<UObject*>(Engine + 0xd8);
	NamePoolData = reinterpret_cast<FNamePool*>(VALORANT::Module + NamePoolDataOffset);
	Hook::VMT((void*)ViewportClient, PostRender, 0x68, (void**)&pRender);
}
extern "C" __declspec(dllexport) int NextHook(int code, WPARAM wParam, LPARAM lParam) { return CallNextHookEx(NULL, code, wParam, lParam); }


BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
	switch (ul_reason_for_call) {
	case DLL_PROCESS_ATTACH:
		Init();
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}

```

`Decryptor.h`:

```h
#pragma once
#include "Alignments.h"
#include "decryption.h" 
#include <Windows.h> 
#include <string>


uint64 BaseAddress = (uint64)GetModuleHandleA(0);
class FNamePool* NamePoolData = nullptr;
#define DecryptWideOffset 0x32D05D0
#define DecryptNonWideOffset 0x32D0560
#define NamePoolDataOffset 0x9095380

static constexpr uint32 FNameMaxBlockBits = 13;
static constexpr uint32 FNameBlockOffsetBits = 16;
static constexpr uint32 FNameMaxBlocks = 1 << FNameMaxBlockBits;
static constexpr uint32 FNameBlockOffsets = 1 << FNameBlockOffsetBits;

struct FNameEntryId
{
	FNameEntryId() : Value(0) {}

	FNameEntryId(uint32 Id) : Value(Id) {}

	explicit operator bool() const { return Value != 0; }

	FORCEINLINE bool operator==(FNameEntryId Other) const
	{
		return Value == Other.Value;
	}

	FORCEINLINE static FNameEntryId FromUnstableInt(uint32 UnstableInt)
	{
		FNameEntryId Id;
		Id.Value = UnstableInt;
		return Id;
	}

	FORCEINLINE uint32 ToUnstableInt() const {
		return Value;
	}

	uint32 Value;
};

struct FNameEntryHandle
{
	uint32 Block = 0;
	uint32 Offset = 0;

	FNameEntryHandle(uint32 InBlock, uint32 InOffset)
		: Block(InBlock)
		, Offset(InOffset)
	{}

	FNameEntryHandle(FNameEntryId Id)
		: Block(Id.ToUnstableInt() >> FNameBlockOffsetBits)
		, Offset(Id.ToUnstableInt()& (FNameBlockOffsets - 1))
	{}

	operator FNameEntryId() const
	{
		return FNameEntryId::FromUnstableInt(Block << FNameBlockOffsetBits | Offset);
	}

	explicit operator bool() const { return Block | Offset; }
};

struct FNameEntryHeader
{
	uint16 bIsWide : 1;
	uint16 Len : 15;
};

struct FNameEntry {
	enum { NAME_SIZE = 1024 };
public:
	FORCEINLINE bool IsWide() const
	{
		return Header.bIsWide;
	}

	FORCEINLINE int32 GetNameLength() const
	{
		return Header.Len;
	}

	FORCEINLINE FNameEntryHeader GetEntryHeader() const
	{
		return Header;
	}

	static int32 GetSize(int32 Length, bool bIsPureAnsi);

	char* DecryptNonWide();

	wchar_t* DecryptWide();

	FORCEINLINE void CopyUnterminatedName(ANSICHAR* Out)
	{
		memcpy(Out, DecryptNonWide(), sizeof(ANSICHAR) * Header.Len);
	}

	FORCEINLINE void CopyUnterminatedName(WIDECHAR* Out)
	{
		memcpy(Out, DecryptWide(), sizeof(WIDECHAR) * Header.Len);
	}

	FORCEINLINE static int32 GetDataOffset()
	{
		return offsetof(FNameEntry, AnsiName);
	}

	void GetAnsiName(ANSICHAR(&Out)[NAME_SIZE]);

	void GetWideName(WIDECHAR(&Out)[NAME_SIZE]);

	WCHAR* Wchar();

	std::string String();

	FNameEntryId ComparisonId;

	FNameEntryHeader Header;

	union
	{
		ANSICHAR	AnsiName[NAME_SIZE];
		WIDECHAR	WideName[NAME_SIZE];
	};

};

void FNameEntry::GetAnsiName(ANSICHAR(&Out)[NAME_SIZE])
{
	if (!IsWide())
	{
		CopyUnterminatedName(Out);
		Out[Header.Len] = '\0';
	}
}

void FNameEntry::GetWideName(WIDECHAR(&Out)[NAME_SIZE])
{
	if (IsWide())
	{
		CopyUnterminatedName(Out);
		Out[Header.Len] = '\0';
	}
}

class FNameEntryAllocator
{
public:
	enum { Stride = alignof(FNameEntry) };
	enum { BlockSizeBytes = Stride * FNameBlockOffsets };

	void* FRWLock;
	uint32 CurrentBlock = 0;
	uint32 CurrentByteCursor = 0;
	uint8* Blocks[FNameMaxBlocks] = {};

	FORCEINLINE uint32 NumBlocks() const
	{
		return CurrentBlock + 1;
	}

	FORCEINLINE FNameEntry& Resolve(FNameEntryHandle Handle) const
	{
		if (Handle.Offset < 0 && Handle.Block > NumBlocks() && Handle.Offset * Stride < FNameBlockOffsets)
			return *reinterpret_cast<FNameEntry*>(Blocks[0] + Stride * 0);

		return *reinterpret_cast<FNameEntry*>(Blocks[Handle.Block] + Stride * Handle.Offset);
	}

};

wchar_t* FNameEntry::DecryptWide()
{

	auto _DecryptWideEntry = (__int64(__fastcall*)(FNameEntry * Entry, wchar_t* Buffer))(BaseAddress + DecryptWideOffset);

	wchar_t Buffer[1024];

	__int64 Result = _DecryptWideEntry(this, Buffer);

	return Buffer;
}

char* FNameEntry::DecryptNonWide()
{
	auto _DecryptNonWideEntry = (__int64(__fastcall*)(FNameEntry * Entry, char* Buffer))(BaseAddress + DecryptNonWideOffset);

	char Buffer[1024];

	__int64 Result = _DecryptNonWideEntry(this, Buffer);

	return Buffer;
}

std::string FNameEntry::String()
{
	if (IsWide()) {
		WCHAR* DecryptedName = DecryptWide();
		std::wstring Wide(DecryptedName, Header.Len);
		return std::string(Wide.begin(), Wide.end());
	}

	char* DecryptedName = DecryptNonWide();
	return std::string(DecryptedName, Header.Len);
}

WCHAR* FNameEntry::Wchar()
{
	if (IsWide())
		return DecryptWide();
	else
		return 0;
}

int32 FNameEntry::GetSize(int32 Length, bool bIsPureAnsi)
{
	int32 Bytes = GetDataOffset() + Length * (bIsPureAnsi ? sizeof(ANSICHAR) : sizeof(WIDECHAR));
	return Align(Bytes, alignof(FNameEntry));
}


class FNamePool
{
public:
	enum { MaxENames = 512 };
	FNameEntryAllocator Entries;
	/*
	* Not interested in other members.
	*/
};

struct FName {
	FNameEntryId	ComparisonIndex;

	FNameEntryId	DisplayIndex;

	uint32			Number;

	FORCEINLINE FNameEntryId GetComparisonIndex() const
	{
		return ComparisonIndex;
	}

	FORCEINLINE FNameEntryId GetDisplayIndex() const
	{
		return DisplayIndex;
	}

	FORCEINLINE bool operator==(FName Other) const
	{
		return (ComparisonIndex == Other.ComparisonIndex) && (GetNumber() == Other.GetNumber());
	}

	FORCEINLINE bool operator!=(FName Other) const
	{
		return !(*this == Other);
	}

	FORCEINLINE int32 GetNumber() const
	{
		return Number;
	}

	FName() :
		ComparisonIndex(FNameEntryId()),
		Number(0)
	{ }

	FName(int32 i, int32 n = 0) :
		ComparisonIndex(FNameEntryId(i)),
		Number(n)
	{ }

	const FNameEntry* GetDisplayNameEntry() const;

	std::string GetName();
};

const FNameEntry* FName::GetDisplayNameEntry() const
{
	return &NamePoolData->Entries.Resolve(GetDisplayIndex());
}

std::string FName::GetName()
{
	FNameEntry Entry = NamePoolData->Entries.Resolve(GetDisplayIndex());

	std::string Name = Entry.String();

	if (Number > 0) Name += '_' + std::to_string(Number);

	std::size_t Pos = Name.rfind('/');

	if (Pos != std::string::npos) Name = Name.substr(Pos + 1);

	return Name;
}
```

`Entry.cpp`:

```cpp
#include "windows.h"
#include <stdint.h>
#include <iostream>
#include <Winternl.h>
#include "Canvas.h"
#include "decryption.h"
#include "hook.h"
#include "Decryptor.h"
#include <stdlib.h>
#include <stdio.h>
#pragma comment(lib, "user32.lib")

using PostRenderHook = void(*)(uintptr_t _this, UCanvas* canvas);
PostRenderHook pRender = 0;

uintptr_t UWorldXOR;
AShooterCharacter* actor;
UWorld* UWorldClass;
UGameInstance* GameInstance;
ULocalPlayer* LocalPlayers;
ULocalPlayer* LocalPlayer;
APlayerController* MyControllers;

using namespace std;
float DegreeToRadian(float degrees) {
	return degrees * (PI / 180);
}

void DrawTextRGB(UCanvas* canvas, const wchar_t* text, float x, float y, FLinearColor color, bool CenterX = 0)
{
	canvas->K2_DrawText(text, { x, y }, { 1.1, 1.1 }, color, 0.f, { 0, 0, 0, 1 }, { 0, 0 }, CenterX, 0, bOutline, { 0, 0, 0, 1 });
}
void DrawTextRGBWithFString(UCanvas* canvas, FString text, float x, float y, FLinearColor color, bool CenterX = 0)
{
	canvas->K2_DrawText(text, { x, y }, { 1.1, 1.1 }, color, 0.f, { 0, 0, 0, 1 }, { 0, 0 }, CenterX, 0, bOutline, { 0, 0, 0, 1 });
}

void xxDrawTextRGB(UCanvas* canvas, FString text, float x, float y, FLinearColor color)
{
	canvas->K2_DrawText(text, { x, y }, { 1.1, 1.1 }, color, 0.f, { 0, 0, 0, 1 }, { 0, 0 }, 0, 0, false, { 0, 0, 0, 1 });
}
FLinearColor RGBtoFLC(float R, float G, float B)
{
	return { R / 255, G / 255, B / 255, 1 };
}

bool kekIsOff = 0; // debugging purposes ONLY solely for THAT

static FLinearColor Invisible{ 2.020f,0.050f,16.0f,5.9f };//Chams//Blue
static FLinearColor Visible{ 2.020f,0.050f,16.0f,5.9f };//Chams//Blue

static FLinearColor VisibleBox_ESPColor{ 0.0f,255.0f,0.0f,1.0f };//BoxVisible
static FLinearColor Invisible_ESPColor{ 255.0f,0.0f,0.0f,1.0f };//BoxInvisible

static FLinearColor VisibleSkeletonColor{ 0.0f,255.0f,0.0f,1.0f };//VisibleSkeletonColor
static FLinearColor InvisibleSkeletonColor{ 2.020f,0.050f,16.0f,5.9f };//VisibleSkeletonColor

static FLinearColor InvisibleSnapColor{ 2.020f,0.050f,16.0f,5.9f };
static FLinearColor VisibleSnapColor{ 0.0f,255.0f,0.0f,1.0f };

static FLinearColor Name_Color{ 2.020f,0.050f,16.0f,5.9f };
static FLinearColor healthcolors = RGBtoFLC(0, 255, 0);
static FLinearColor circlecol = { 255.0f, 255.0f, 255.0f, 1.0f };
static FLinearColor fovcolor = { 255.0f, 255.0f, 255.0f, 1.0f };
static FLinearColor crosscolor = { 255.0f, 255.0f, 255.0f, 1.0f };

static bool menu_opened = true;
static bool menu = true;

FVector2D pos = { ((float)GetSystemMetrics(SM_CXSCREEN) / 2) - 500, ((float)GetSystemMetrics(SM_CYSCREEN) / 2) - 475 };
FVector2D poss = { ((float)GetSystemMetrics(SM_CXSCREEN) / 2) - 200, ((float)GetSystemMetrics(SM_CYSCREEN) / 2) - 175 };

static bool autoaim = false;
static bool ChamsESP = false;
static bool skid_spinbot = false;
static bool Wireframe = false;
static bool WireframeGun = false;
static bool SpinBot = false;
static bool box2d = false;
static bool SpinBotBool = false;
static bool chammyteam = false;
static bool fovchanger = false;
static bool autoshoot = false;
static bool AutoFire = false;
static bool HeadCircleEsp = false;
static bool vischeckmenu = false;
static bool AgentName = false;

//WireFrame*
static bool WireFrameHand = false;


//Misc
static bool FlyHack = false;
static float PlayerDistange = 150;
static bool drawfov = false;
static bool HealthEsp = false;
static bool skiptutorial = false;

int SnapPositionint = 2;
int SnapPositionİnt = 0;
int SnapMesh = 0;

static bool Minimap = false;
static bool weaponesp = false;
static bool RageBot = false;
static bool Watermark = true;
static bool drawcross = false;
static bool ThirdPerson = false;
static bool Visible_Check_ESP = false;
static bool skeleton = false;
static bool snaplinenz = false;
static bool enableaim = false;
static bool Silent = false;

//Misc
static float radius = 4.0f;
static float radius2 = 7.0f;
static float fovchangur = 105.0f;

//+++++++++++++++++++
 
//Skins
static bool EnableKnife = false;
static bool EnableGhost = false;
static bool EnableVandal = false;
static bool EnableOperator = false;
static bool EnableClassic = false;
static bool EnableSpectre = false;
static bool EnablePhantom = false;
static bool EnableSheriff = false;

int skinvandal = 0;
int skinclassic = 0;
int skinsheriff = 0;
int skinphantom = 0;
int skinspectre = 0;
int skinknife = 0;
int skinghost = 0;
int skinoperator = 0;

//++++++++++++++++++++

int KEKWNOKEY;
int BhopKey = VK_SPACE;
int RageBotKeybind;
int spinbotkeybind;
int aimbotmode = 0;
int aimbone = 0;
bool healthbar = false;

int Width = GetSystemMetrics(SM_CXSCREEN);
int Height = GetSystemMetrics(SM_CYSCREEN);

float ScreenCenterX = Width / 2;
float ScreenCenterY = Height / 2;


float fovChanger = 30.0f;//Fov Changer
float LineamountCross = 35.0f;
float LineamountCircle = 25.0f;
float LineamountFov = 35.0f;
float chamsglowvalue = 1;
float ESPThickness = 1;

bool Mesh3PModifed = false;
bool Below = false;
bool Middle = false;
bool Bottom = false;


//Configs
bool LegitCFG = false;
bool RageCFG = false;

struct FMinimalViewInfo {
	FVector Location;
	FVector Rotation;
	float FOV;
};
struct Bone {
	BYTE thing[0xCC];
	float x;
	BYTE thing2[0xC];
	float y;
	BYTE thing3[0xC];
	float z;
};
boolean in_rect(double centerX, double centerY, double radius, double x, double y) {
	return x >= centerX - radius && x <= centerX + radius &&
		y >= centerY - radius && y <= centerY + radius;
}
uintptr_t OffsetGetActorBounds;
FVector GetBoneMatrix(void* Mesh, int Idx) {
	FMatrix Matrix;
	reinterpret_cast<FMatrix* (__fastcall*)(void*, FMatrix*, int)>((uintptr_t)VALORANT::Module + Offsets::bone_matrix)(Mesh, &Matrix, Idx); // E8 ?? ?? ?? ?? 48 8B 47 30 F3 0F 10 45 ??
	return  { Matrix.WPlane.X, Matrix.WPlane.Y, Matrix.WPlane.Z };
}
FVector FindSkeleton(APlayerController* controller, void* mesh, int i)
{
	FVector2D drawtextat;
	return controller->ProjectWorldLocationToScreen(GetBoneMatrix(mesh, i), drawtextat, 0);
}

FVector get_error_angle(uint64_t actor, uint64_t firing_state_component) {
	static auto get_spread_values_fn = (float* (__fastcall*)(uint64_t, float*))(BaseAddress + Offsets::get_spread_values_fn);
	static auto get_spread_angles_fn = (void(__fastcall*)(uint64_t, FVector*, float, float, int, int, uint64_t))(BaseAddress + Offsets::get_spread_angles_fn);
	static auto get_firing_location_and_direction_fn = (void(__fastcall*)(uint64_t, FVector*, FVector*))(BaseAddress + Offsets::get_firing_location_and_direction_fn);
	static auto to_vector_and_normalize_fn = (FVector * (__fastcall*)(FVector*, FVector*))(BaseAddress + Offsets::to_vector_and_normalize_fn);
	static auto to_angle_and_normalize_fn = (FVector * (__fastcall*)(FVector*, FVector*))(BaseAddress + Offsets::to_vector_and_normalize_fn);
	static uint8_t error_values[4096] = { 0 };
	static uint8_t seed_data_snapshot[4096] = { 0 };
	static uint8_t spread_angles[4096] = { 0 };
	static uint8_t out_spread_angles[4096] = { 0 };

	if (!actor || !firing_state_component)
		return FVector(0, 0, 0);

	memset(error_values, 0, sizeof(error_values));
	memset(seed_data_snapshot, 0, sizeof(seed_data_snapshot));
	memset(spread_angles, 0, sizeof(spread_angles));
	memset(out_spread_angles, 0, sizeof(out_spread_angles));

	*(uint64_t*)(&out_spread_angles[0]) = (uint64_t)&spread_angles[0];
	*(int*)(&out_spread_angles[0] + 8) = 1;
	*(int*)(&out_spread_angles[0] + 12) = 1;

	uint64_t seed_data = Memory::ReadStub<uint64_t>(firing_state_component + 0x1A0);
	memcpy((void*)seed_data_snapshot, (void*)seed_data, sizeof(seed_data_snapshot)); //Make our own copy since we don't want to desync our own seed component

	uint64_t stability_component = Memory::ReadStub<uint64_t>(firing_state_component + 0x418);
	if (stability_component)
		get_spread_values_fn(stability_component, (float*)&error_values[0]);

	FVector Temp1, Temp2 = FVector(0, 0, 0);
	FVector PreviousFiringDirection, firingdirection = FVector(0, 0, 0);
	get_firing_location_and_direction_fn(actor, &Temp1, &PreviousFiringDirection);
	to_vector_and_normalize_fn(&PreviousFiringDirection, &Temp2);
	to_angle_and_normalize_fn(&Temp2, &Temp1);
	PreviousFiringDirection = Temp1;
	Temp1.X += *(float*)(&error_values[0] + 12); //Your recoil angle
	Temp2.Y += *(float*)(&error_values[0] + 16);
	to_vector_and_normalize_fn(&Temp1, &firingdirection);
	float error_degrees = *(float*)(&error_values[0] + 8) + *(float*)(&error_values[0] + 4);
	float error_power = *(float*)(firing_state_component + 0x3F8);
	int error_retries = *(int*)(firing_state_component + 0x3FC);
	get_spread_angles_fn(((uint64_t)&seed_data_snapshot[0]) + 0xE8, &firingdirection, error_degrees, error_power, error_retries, 1, (uint64_t)&out_spread_angles[0]);

	FVector spread_vector = *(FVector*)(&spread_angles[0]);
	to_angle_and_normalize_fn(&spread_vector, &firingdirection);

	return firingdirection - PreviousFiringDirection; //Get the difference. Now subtract it against your aimbot!
}

void DrawSkeletonBot(APlayerController* controller, UCanvas* Canvas, void* mesh, FLinearColor cColor, float kalinlik = ESPThickness)
{

	FVector vHipOut = FindSkeleton(controller, mesh, 3);

	FVector vHeadBoneOut = FindSkeleton(controller, mesh, 8);
	FVector vNeckOut = FindSkeleton(controller, mesh, 7);

	FVector vUpperArmLeftOut = FindSkeleton(controller, mesh, 11);
	FVector vLeftHandOut = FindSkeleton(controller, mesh, 12);
	FVector vLeftHandOut1 = FindSkeleton(controller, mesh, 13);

	FVector vUpperArmRightOut = FindSkeleton(controller, mesh, 36);
	FVector vRightHandOut = FindSkeleton(controller, mesh, 37);
	FVector vRightHandOut1 = FindSkeleton(controller, mesh, 38);



	FVector vLeftThighOut = FindSkeleton(controller, mesh, 63);
	FVector vLeftCalfOut = FindSkeleton(controller, mesh, 65);
	FVector vLeftFootOut = FindSkeleton(controller, mesh, 69);

	FVector vRightThighOut = FindSkeleton(controller, mesh, 77);
	FVector vRightCalfOut = FindSkeleton(controller, mesh, 79);
	FVector vRightFootOut = FindSkeleton(controller, mesh, 83);
	{

		Canvas->K2_DrawLine({ vNeckOut.X, vNeckOut.Y }, { vHeadBoneOut.X, vHeadBoneOut.Y }, kalinlik, cColor);
		Canvas->K2_DrawLine({ vHipOut.X, vHipOut.Y }, { vNeckOut.X, vNeckOut.Y }, kalinlik, cColor);
		Canvas->K2_DrawLine({ vUpperArmLeftOut.X, vUpperArmLeftOut.Y }, { vNeckOut.X, vNeckOut.Y }, kalinlik, cColor);
		Canvas->K2_DrawLine({ vUpperArmRightOut.X, vUpperArmRightOut.Y }, { vNeckOut.X, vNeckOut.Y }, kalinlik, cColor);
		Canvas->K2_DrawLine({ vLeftHandOut.X, vLeftHandOut.Y }, { vUpperArmLeftOut.X, vUpperArmLeftOut.Y }, kalinlik, cColor);
		Canvas->K2_DrawLine({ vRightHandOut.X, vRightHandOut.Y }, { vUpperArmRightOut.X, vUpperArmRightOut.Y }, kalinlik, cColor);
		Canvas->K2_DrawLine({ vLeftHandOut.X, vLeftHandOut.Y }, { vLeftHandOut1.X, vLeftHandOut1.Y }, kalinlik, cColor);
		Canvas->K2_DrawLine({ vRightHandOut.X, vRightHandOut.Y }, { vRightHandOut1.X, vRightHandOut1.Y }, kalinlik, cColor);
		Canvas->K2_DrawLine({ vLeftThighOut.X, vLeftThighOut.Y }, { vHipOut.X, vHipOut.Y }, kalinlik, cColor);
		Canvas->K2_DrawLine({ vRightThighOut.X, vRightThighOut.Y }, { vHipOut.X, vHipOut.Y }, kalinlik, cColor);
		Canvas->K2_DrawLine({ vLeftCalfOut.X, vLeftCalfOut.Y }, { vLeftThighOut.X, vLeftThighOut.Y }, kalinlik, cColor);
		Canvas->K2_DrawLine({ vRightCalfOut.X, vRightCalfOut.Y }, { vRightThighOut.X, vRightThighOut.Y }, kalinlik, cColor);
		Canvas->K2_DrawLine({ vLeftFootOut.X, vLeftFootOut.Y }, { vLeftCalfOut.X, vLeftCalfOut.Y }, kalinlik, cColor);
		Canvas->K2_DrawLine({ vRightFootOut.X, vRightFootOut.Y }, { vRightCalfOut.X, vRightCalfOut.Y }, kalinlik, cColor);
	}

}
FString character_name(FString in)
{
	if (in.ToString().find("Training") != std::string::npos)
		return FString(L"NPC");
	if (in.ToString().find("BountyHunter_PC_C") != std::string::npos)
		return FString(L"Fade");
	if (in.ToString().find("Stealth_PC_C") != std::string::npos)
		return FString(L"Yoru");
	if (in.ToString().find("Pandemic_PC_C") != std::string::npos)
		return FString(L"Viper");
	if (in.ToString().find("Hunter_PC_C") != std::string::npos)
		return FString(L"Sova");
	if (in.ToString().find("Guide_PC_C") != std::string::npos)
		return FString(L"Skye");
	if (in.ToString().find("Thorne_PC_C") != std::string::npos)
		return FString(L"Sage");
	if (in.ToString().find("Vampire_PC_C") != std::string::npos)
		return FString(L"Reyna");
	if (in.ToString().find("Clay_PC_C") != std::string::npos)
		return FString(L"Raze");
	if (in.ToString().find("Phoenix_PC_C") != std::string::npos)
		return FString(L"Phoenix");
	if (in.ToString().find("Wraith_PC_C") != std::string::npos)
		return FString(L"Omen");
	if (in.ToString().find("Sprinter_PC_C") != std::string::npos)
		return FString(L"Neon");
	if (in.ToString().find("Killjoy_PC_C") != std::string::npos)
		return FString(L"Killjoy");
	if (in.ToString().find("Grenadier_PC_C") != std::string::npos)
		return FString(L"Kayo");
	if (in.ToString().find("Wushu_PC_C") != std::string::npos)
		return FString(L"Jett");
	if (in.ToString().find("Gumshoe_PC_C") != std::string::npos)
		return FString(L"Cypher");
	if (in.ToString().find("Deadeye_PC_C") != std::string::npos)
		return FString(L"Chamber");
	if (in.ToString().find("Sarge_PC_C") != std::string::npos)
		return FString(L"Brimstone");
	if (in.ToString().find("Breach_PC_C") != std::string::npos)
		return FString(L"Breach");
	if (in.ToString().find("Rift_TargetingForm_PC_C") != std::string::npos)
		return FString(L"Astra");
	if (in.ToString().find("Rift_PC_C") != std::string::npos)
		return FString(L"Astra");
	if (in.ToString().find("Mage_PC_C") != std::string::npos)
		return FString(L"Harbor");
	else
		return FString(L"N/A");
}
FString weapon_name(FString in)
{
	if (in.ToString().find("Ability_Melee_Base_C") != std::string::npos)
		return FString(L"Knife");
	if (in.ToString().find("BasePistol_C") != std::string::npos)
		return FString(L"Classic");
	if (in.ToString().find("TrainingBotBasePistol_C") != std::string::npos)
		return FString(L"Classic");
	if (in.ToString().find("SawedOffShotgun_C") != std::string::npos)
		return FString(L"Shorty");
	if (in.ToString().find("AutomaticPistol_C") != std::string::npos)
		return FString(L"Frenzy");
	if (in.ToString().find("LugerPistol_C") != std::string::npos)
		return FString(L"Ghost");
	if (in.ToString().find("RevolverPistol_C") != std::string::npos)
		return FString(L"Sheriff");
	if (in.ToString().find("Vector_C") != std::string::npos)
		return FString(L"Stinger");
	if (in.ToString().find("SubMachineGun_MP5_C") != std::string::npos)
		return FString(L"Spectre");
	if (in.ToString().find("PumpShotgun_C") != std::string::npos)
		return FString(L"Bucky");
	if (in.ToString().find("AssaultRifle_Burst_C") != std::string::npos)
		return FString(L"Bulldog");
	if (in.ToString().find("DMR_C") != std::string::npos)
		return FString(L"Guardian");
	if (in.ToString().find("AssaultRifle_ACR_C") != std::string::npos)
		return FString(L"Phantom");
	if (in.ToString().find("AssaultRifle_AK_C") != std::string::npos)
		return FString(L"Vandal");
	if (in.ToString().find("LeverSniperRifle_C") != std::string::npos)
		return FString(L"Marshall");
	if (in.ToString().find("BoltSniper_C") != std::string::npos)
		return FString(L"Operator");
	if (in.ToString().find("LightMachineGun_C") != std::string::npos)
		return FString(L"Ares");
	if (in.ToString().find("HeavyMachineGun_C") != std::string::npos)
		return FString(L"Odin");
	if (in.ToString().find("Bomb_C") != std::string::npos)
		return FString(L"Spike");
	if (in.ToString().find("Pawn_Gumshoe_Q_PossessableCamera_C") != std::string::npos)
		return FString(L"Cyper Camera");
	if (in.ToString().find("Pawn_Hunter_E_Drone_Prototype_Balance_C") != std::string::npos)
		return FString(L"Sova Drone");
	else
		return FString(L"N/A");
}

/*
PlantedSpike //TimedBomb_C
DroppedItems //EquippableGroundPickup_C
SageAllWall //GameObject_Thorne_E_Wall_Fortifying_C
SageWallSegments //GameObject_Thorne_E_Wall_Segment_Fortifying_C
OwlDrone //Pawn_Hunter_E_Drone_Prototype_Balance_C
Cypher Trap Start //GameObject_Gumshoe_E_TripWire_C
Cypher Trap End //GameObject_Gumshoe_E_TripWire_SecondWire_C
Cypher Camera //Pawn_Gumshoe_Q_PossessableCamera_C
*/


void DrawBox(UCanvas* can, FVector2D& topleft, FVector2D& downright, FLinearColor clr)
{
	auto h = downright.Y - topleft.Y;
	auto w = downright.X - topleft.X;

	auto downleft = FVector2D{ topleft.X , downright.Y };
	auto topright = FVector2D{ downright.X, topleft.Y };

	auto thicc = ESPThickness;

	FLinearColor xclr = RGBtoFLC(0, 0, 0);

	can->K2_DrawLinex(topleft, { downright.X, topleft.Y }, thicc, clr);
	can->K2_DrawLinex(topleft, { topleft.X , downright.Y }, thicc, clr);
	can->K2_DrawLinex(downright, { topleft.X , downright.Y }, thicc, clr);
	can->K2_DrawLine(downright, { downright.X, topleft.Y }, thicc, clr);
}

static FVector2D scr[8];
void FMath::SinCos(float* ScalarSin, float* ScalarCos, float Value)
{
	// Map Value to y in [-pi,pi], x = 2*pi*quotient + remainder.
	float quotient = (INV_PI * 0.5f) * Value;
	if (Value >= 0.0f)
	{
		quotient = (float)((int)(quotient + 0.5f));
	}
	else
	{
		quotient = (float)((int)(quotient - 0.5f));
	}
	float y = Value - (2.0f * PI) * quotient;

	// Map y to [-pi/2,pi/2] with sin(y) = sin(Value).
	float sign;
	if (y > HALF_PI)
	{
		y = PI - y;
		sign = -1.0f;
	}
	else if (y < -HALF_PI)
	{
		y = -PI - y;
		sign = -1.0f;
	}
	else
	{
		sign = +1.0f;
	}

	float y2 = y * y;

	// 11-degree minimax approximation
	*ScalarSin = (((((-2.3889859e-08f * y2 + 2.7525562e-06f) * y2 - 0.00019840874f) * y2 + 0.0083333310f) * y2 - 0.16666667f) * y2 + 1.0f) * y;

	// 10-degree minimax approximation
	float p = ((((-2.6051615e-07f * y2 + 2.4760495e-05f) * y2 - 0.0013888378f) * y2 + 0.041666638f) * y2 - 0.5f) * y2 + 1.0f;
	*ScalarCos = sign * p;
}
float FMath::Fmod(float X, float Y)
{
	const float AbsY = fabsf(Y);
	if (AbsY <= 1.e-8f) { return 0.f; }
	const float Div = (X / Y);
	// All floats where abs(f) >= 2^23 (8388608) are whole numbers so do not need truncation, and avoid overflow in TruncToFloat as they get even larger.
	const float Quotient = fabsf(Div) < FLOAT_NON_FRACTIONAL ? truncf(Div) : Div;
	float IntPortion = Y * Quotient;

	// Rounding and imprecision could cause IntPortion to exceed X and cause the result to be outside the expected range.
	// For example Fmod(55.8, 9.3) would result in a very small negative value!
	if (fabsf(IntPortion) > fabsf(X)) { IntPortion = X; }

	const float Result = X - IntPortion;
	// Clamp to [-AbsY, AbsY] because of possible failures for very large numbers (>1e10) due to precision loss.
	// We could instead fall back to stock fmodf() for large values, however this would diverge from the SIMD VectorMod() which has no similar fallback with reasonable performance.
	return FMath::Clamp(Result, -AbsY, AbsY);
}
static bool bLockedCameraRotation = false;
uintptr_t camMan;
FVector	LocalCameraLocation; //FVector	LocalCameraLocation = Memory::ReadStub<uintptr_t>(camMan + 0x1260);
float LocalCameraFOV; //float LocalCameraFOV = Memory::ReadStub<float>(camMan + 0x1278);
FVector	LocalCameraRotation; //FVector	LocalCameraRotation = Memory::ReadStub<uintptr_t>(camMan + 0x126C)
static bool bFlickSilent = true;
void(*SetCameraCachePOVOriginal)(uintptr_t, FMinimalViewInfo*) = nullptr;
UAresOutlineComponent* Mesh;
FVector2D head_scren;
auto SetCameraCachePOVHook(uintptr_t PlayerCameraManager, FMinimalViewInfo* ViewInfo)
{
	FVector CameraPos = *(FVector*)(PlayerCameraManager + 0x1260);
	FVector CameraRot = *(FVector*)(PlayerCameraManager + 0x126C);
	
	float deltaX, deltaY;
	MyControllers->GetInputMouseDelta(deltaX, deltaY);
	float sensitivity = MyControllers->GetMouseSensitivity(); // ShooterGame.ShooterPlayerController.GetMouseSensitivity
	LocalCameraRotation.X += deltaY * sensitivity;
	LocalCameraRotation.Y += deltaX * sensitivity;
	MyControllers->K2_SetActorRelativeRotation(FRotator{ 0, LocalCameraRotation.Y, 0 }, false, true); // Engine.Actor.K2_SetActorRelativeRotation

	
	//FovandKey

	if (Silent)
	{
		// Cache camera values for our own purposes, in this case we are simply using the left button to decide whether the person is shooting or not.
		if (!GetAsyncKeyState(KEKWNOKEY)) //menu is alt
		{

			if (!GetAsyncKeyState(VK_LBUTTON))
			{
				// Cache wanted camera values.
				LocalCameraLocation = ViewInfo->Location, LocalCameraRotation = ViewInfo->Rotation;
				LocalCameraFOV = ViewInfo->FOV;

				bLockedCameraRotation = false;
			}

		}
		else
		{
			if (GetAsyncKeyState(VK_LBUTTON)  &&in_rect(ScreenCenterX, ScreenCenterY, fovChanger, head_scren.X, head_scren.Y))
				bLockedCameraRotation = true;



			// Lock camera
			if (bFlickSilent && LocalCameraRotation != FVector())
				ViewInfo->Rotation = LocalCameraRotation;

		}

		SetCameraCachePOVOriginal(PlayerCameraManager, ViewInfo);

	

	}/**/

	if (!skid_spinbot) {
		LocalCameraRotation = ViewInfo->Rotation;
	}
	else {
		ViewInfo->Rotation = LocalCameraRotation;
	}

	if (ThirdPerson) {
		float TPDistance = PlayerDistange; // Third Person Distance
		float FixZAngle = (-TPDistance - (sin(DegreeToRadian(-CameraRot.X)) * (TPDistance - (TPDistance / 3.5))));

		if (CameraRot.X < 0.0f)
			FixZAngle = -(TPDistance - (sin(DegreeToRadian(-CameraRot.X)) * (TPDistance - (TPDistance / 3.5))));

		FVector CamOff = FVector{ cos(DegreeToRadian(CameraRot.Y)) * FixZAngle, sin(DegreeToRadian(CameraRot.Y)) * FixZAngle, sin(DegreeToRadian(-CameraRot.X)) * TPDistance };


		ViewInfo->Location = CameraPos + CamOff;
	}

	SetCameraCachePOVOriginal(PlayerCameraManager, ViewInfo);
}


FQuat FRotator::Quaternion() const
{
	float SP, SY, SR;
	float CP, CY, CR;
	const float PitchNoWinding = FMath::Fmod(Pitch, 360.0f);
	const float YawNoWinding = FMath::Fmod(Yaw, 360.0f);
	const float RollNoWinding = FMath::Fmod(Roll, 360.0f);
	FMath::SinCos(&SP, &CP, PitchNoWinding * RADS_DIVIDED_BY_2);
	FMath::SinCos(&SY, &CY, YawNoWinding * RADS_DIVIDED_BY_2);
	FMath::SinCos(&SR, &CR, RollNoWinding * RADS_DIVIDED_BY_2);
	FQuat RotationQuat;
	RotationQuat.X = CR * SP * SY - SR * CP * CY;
	RotationQuat.Y = -CR * SP * CY - SR * CP * SY;
	RotationQuat.Z = CR * CP * SY - SR * SP * CY;
	RotationQuat.W = CR * CP * CY + SR * SP * SY;
	return RotationQuat;
}
const FVector FVector::ZeroVector(0.0f, 0.0f, 0.0f);
const FVector FVector::OneVector(1.0f, 1.0f, 1.0f);
FVector FTransform::TransformPosition(FVector& V) const
{
	return Rotation.RotateVector(Scale3D * V) + Translation;
}
FVector FQuat::RotateVector(const FVector& V) const
{
	const FVector Q(X, Y, Z);
	const FVector T = (Q ^ V) * 2.f;
	const FVector Result = V + (T * W) + (Q ^ T);
	return Result;
}

bool a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18;
void  Draw3DBox(UCanvas* _this, APlayerController* plc, FVector origin, FVector extends, FLinearColor col)
{
	origin -= extends / 2.f;

	// bottom plane
	FVector one = origin;
	FVector two = origin; two.X += extends.X;
	FVector three = origin; three.X += extends.X; three.Y += extends.Y;
	FVector four = origin; four.Y += extends.Y;

	FVector five = one; five.Z += extends.Z;
	FVector six = two; six.Z += extends.Z;
	FVector seven = three; seven.Z += extends.Z;
	FVector eight = four; eight.Z += extends.Z;



	if (plc->ProjectWorldLocationToScreen(one, scr[0], 0) || plc->ProjectWorldLocationToScreen(two, scr[1], 0) || plc->ProjectWorldLocationToScreen(three, scr[2], 0) || plc->ProjectWorldLocationToScreen(four, scr[3], 0))
	{
		if (plc->ProjectWorldLocationToScreen(five, scr[4], 0) || plc->ProjectWorldLocationToScreen(six, scr[5], 0) || plc->ProjectWorldLocationToScreen(seven, scr[6], 0) || plc->ProjectWorldLocationToScreen(eight, scr[7], 0))
		{
			_this->K2_DrawLine(scr[0], scr[1], ESPThickness, col);
			_this->K2_DrawLine(scr[1], scr[2], ESPThickness, col);
			_this->K2_DrawLine(scr[2], scr[3], ESPThickness, col);
			_this->K2_DrawLine(scr[3], scr[0], ESPThickness, col);

			_this->K2_DrawLine(scr[4], scr[5], ESPThickness, col);
			_this->K2_DrawLine(scr[5], scr[6], ESPThickness, col);
			_this->K2_DrawLine(scr[6], scr[7], ESPThickness, col);
			_this->K2_DrawLine(scr[7], scr[4], ESPThickness, col);

			_this->K2_DrawLine(scr[0], scr[4], ESPThickness, col);
			_this->K2_DrawLine(scr[1], scr[5], ESPThickness, col);
			_this->K2_DrawLine(scr[2], scr[6], ESPThickness, col);
			_this->K2_DrawLine(scr[3], scr[7], ESPThickness, col);
		}
	}

}
bool Render3DBox(APlayerController* controller, UCanvas* Engine, const FVector& origin, const FVector& extent, const FRotator& rotation, const FLinearColor color)
{
	FVector vertex[2][4];
	vertex[0][0] = { -extent.X, -extent.Y,  -extent.Z };
	vertex[0][1] = { extent.X, -extent.Y,  -extent.Z };
	vertex[0][2] = { extent.X, extent.Y,  -extent.Z };
	vertex[0][3] = { -extent.X, extent.Y, -extent.Z };

	vertex[1][0] = { -extent.X, -extent.Y, extent.Z };
	vertex[1][1] = { extent.X, -extent.Y, extent.Z };
	vertex[1][2] = { extent.X, extent.Y, extent.Z };
	vertex[1][3] = { -extent.X, extent.Y, extent.Z };

	FVector2D screen[2][4];
	FTransform const Transform(rotation);
	for (auto k = 0; k < 2; k++)
	{
		for (auto i = 0; i < 4; i++)
		{
			auto& vec = vertex[k][i];
			vec = Transform.TransformPosition(vec) + origin;
			if (!controller->ProjectWorldLocationToScreen(vec, screen[k][i], false)) return false;
		}

	}

	auto SurfaceScreen = reinterpret_cast<FVector2D(&)[2][4]>(screen);

	for (auto i = 0; i < 4; i++)
	{
		Engine->K2_DrawLine(SurfaceScreen[1][i], SurfaceScreen[2][(i + 1) % 2], ESPThickness, color);
		Engine->K2_DrawLine(SurfaceScreen[3][i], SurfaceScreen[4][(i + 1) % 2], ESPThickness, color);
		Engine->K2_DrawLine(SurfaceScreen[5][i], SurfaceScreen[6][(i + 1) % 2], ESPThickness, color);
	}

	return true;
}


UObject* skinlist()
{

	UObject* skin_data = nullptr;

	if (EnableVandal) {
		switch ((int)skinvandal)
		{
		case 1:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_Ashen_v1_PrimaryAsset_C", false);//1
			break;
		case 2:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_Soulstealer_Black_PrimaryAsset_C", false);//2
			break;
		case 3:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_Afterglow_Blue_PrimaryAsset_C", false);//2
			break;
		case 4:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_Champions_PrimaryAsset_C", false);//2
			break;
		case 5:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_Dragon_Red_PrimaryAsset_C", false);//2
			break;
		case 6:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_Oblivion2_PrimaryAsset_C", false);//2
			break;
		case 7:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_Daedalus_v2_PrimaryAsset_C", false);//2
			break;
		case 8:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_Antares_v2_PrimaryAsset_C", false);//2
			break;
		case 9:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_Circle_PrimaryAsset_C", false);//2
			break;
		case 10:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_DemonStone_PrimaryAsset_C", false);//2
			break;
		case 11:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_SOL_PrimaryAsset_C", false);//2
			break;
		case 12:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_Cyberpunk2_PrimaryAsset_C", false);//2
			break;
		}
	}

	if (EnablePhantom) {
		switch ((int)skinphantom)
		{
		case 1:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Carbine_Atlas_PrimaryAsset_C", false);//2
			break;
		case 2:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Carbine_Soulstealer2_PrimaryAsset_C", false);//2
			break;
		case 3:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Carbine_Afterglow2_PrimaryAsset_C", false);//2
			break;
		case 4:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AssaultRifle_ACR_Edge_Blue_PrimaryAsset_C", false);//2
			break;
		case 5:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Carbine_King_PrimaryAsset_C", false);//2
			break;
		case 6:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Carbine_Cyberpunk2_PrimaryAsset_C", false);//2
			break;
		case 7:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Carbine_Daedalus_PrimaryAsset_C", false);//2
			break;
		case 8:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Carbine_SpecOps_PrimaryAsset_C", false);//2
			break;
		case 9:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Carbine_URF_PrimaryAsset_C", false);//2
			break;
		}
	}

	if (EnableSheriff) {
		switch ((int)skinsheriff)
		{
		case 1:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__RevolverPistol_Soulstealer_PrimaryAsset_C", false);//1
			break;
		case 2:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__RevolverPistol_Edge_PrimaryAsset_C", false);//2
			break;
		case 3:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Revolver_Protocol_PrimaryAsset_C", false);//2
			break;
		case 4:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Revolver_SOL_PrimaryAsset_C", false);//2
			break;
		case 5:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Revolver_Daedalus_PrimaryAsset_C", false);//2
			break;
		case 6:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Revolver_Magepunk2_PrimaryAsset_C", false);//2
			break;
		}
	}

	if (EnableKnife) {

		switch ((int)skinknife)
		{
		case 1:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Afterglow2_PrimaryAsset_C", false);//1
			break;
		case 2:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Cyberpunk2_PrimaryAsset_C", false);//2
			break;
		case 3:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Soulstealer2_PrimaryAsset_C", false);//2
			break;
		case 4:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Afterglow_PrimaryAsset_C", false);//2
			break;
		case 5:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Alien_PrimaryAsset_C", false);//2
			break;
		case 6:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Base_HypeBeast_PrimaryAsset_C", false);//2
			break;
		case 7:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Soulstealer_PrimaryAsset_C", false);//2
			break;
		case 8:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Champions_PrimaryAsset_C", false);//2
			break;
		case 9:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee__Dragon_PrimaryAsset_C", false);//2
			break;
		case 10:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Lunar_PrimaryAsset_C", false);//2
			break;
		case 11:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Antares_v2_PrimaryAsset_C", false);//2
			break;
		case 12:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Champions2_PrimaryAsset_C", false);//2
			break;
		case 13:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Haunted_PrimaryAsset_C", false);//2
			break;
		case 14:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Mythic_PrimaryAsset_C", false);//2
			break;
		case 15:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Oblivion2_PrimaryAsset_C", false);//2
			break;
		case 16:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Magepunk2_PrimaryAsset_C", false);//2
			break;

		}


	}

	if (EnableGhost) {

		switch ((int)skinghost)
		{
		case 1:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__LugerPistol_Sovereign_PrimaryAsset_C", false);//1
			break;
		case 2:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Luger_King_PrimaryAsset_C", false);//2
			break;
		case 3:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Luger_Magepunk_PrimaryAsset_C", false);//2
			break;
		case 4:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Luger_Soulstealer2_PrimaryAsset_C", false);//2
			break;
		case 5:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__LugerPistol_Ashen_PrimaryAsset_C", false);//2
			break;
		}


	}

	if (EnableOperator) {

		switch ((int)skinoperator)
		{
		case 1:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BoltSniper_Circle_PrimaryAsset_C", false);//1
			break;
		case 2:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BoltSniper_DemonStone_PrimaryAsset_C", false);//2
			break;
		case 3:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BoltSniper_Fallen_PrimaryAsset_C", false);//2
			break;
		case 4:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BoltSniper_Cyberpunk2_PrimaryAsset_C", false);//2
			break;
		case 5:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BoltSniper_Afterglow2_PrimaryAsset_C", false);//2
			break;
		case 6:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BoltSniper_Dragon_PrimaryAsset_C", false);//2
			break;
		case 7:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BoltSniper_SOL_PrimaryAsset_C", false);//2
			break;
		case 8:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BoltSniper_Soulstealer_PrimaryAsset_C", false);//2
			break;

		}


	}

	if (EnableClassic) {

		switch ((int)skinclassic)
		{
		case 1:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BasePistol_HypeBeast_PrimaryAsset_C", false);//1
			break;
		case 2:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BasePistol_Afterglow2_PrimaryAsset_C", false);//1
			break;
		case 3:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BasePistol_Atlas_v1_PrimaryAsset_C", false);//1
			break;
		case 4:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BasePistol_Cyberpunk2_PrimaryAsset_C", false);//1
			break;
		}
	}

	if (EnableSpectre) {

		switch ((int)skinspectre)
		{
		case 1:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__MP5_Afterglow2_PrimaryAsset_C", false);//1
			break;
		case 2:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__MP5_Soulstealer2_PrimaryAsset_C", false);//1
			break;
		case 3:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__MP5_Protocol_PrimaryAsset_C", false);//1
			break;
		case 4:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__MP5_King_PrimaryAsset_C", false);//1
			break;
		case 5:
			skin_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__MP5_Oblivion2_PrimaryAsset_C", false);//1
			break;
		}
	}


	return skin_data;
}
UObject* skinlistchroma()
{
	UObject* chroma_data = nullptr;

	if (EnableVandal) {
		switch ((int)skinvandal) {
		case 1:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_Ashen_Lv4_PrimaryAsset_C", false);//1
			break;
		case 2:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_Soulstealer_Lv4_PrimaryAsset_C", false);//2
			break;
		case 3:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_Afterglow_Lv4_PrimaryAsset_C", false);//2
			break;
		case 4:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_Champions_Lv4_PrimaryAsset_C", false);//2
			break;
		case 5:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_Dragon_Lv4_PrimaryAsset_C", false);//2
			break;
		case 6:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_Oblivion2_Lv4_PrimaryAsset_C", false);//2
			break;
		case 7:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_Daedalus_Lv4_PrimaryAsset_C", false);//2
			break;
		case 8:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_Antares_Lv4_PrimaryAsset_C", false);//2
			break;
		case 9:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_Circle_Lv4_PrimaryAsset_C", false);//2
			break;
		case 10:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_DemonStone_Lv4_PrimaryAsset_C", false);//2
			break;
		case 11:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_SOL_Lv4_PrimaryAsset_C", false);//2
			break;
		case 12:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AK_Cyberpunk2_Lv4_PrimaryAsset_C", false);//2
			break;
		}
	}

	if (EnablePhantom) {
		switch ((int)skinphantom) {
		case 1:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Carbine_Atlas_Lv4_PrimaryAsset_C", false);//1
			break;
		case 2:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Carbine_Soulstealer2_Lv4_PrimaryAsset_C", false);//2
			break;
		case 3:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Carbine_Afterglow2_Lv4_PrimaryAsset_C", false);//2
			break;
		case 4:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__AssaultRifle_ACR_Edge_Lv4_PrimaryAsset_C", false);//2
			break;
		case 5:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Carbine_King_Lv4_PrimaryAsset_C", false);//2
			break;
		case 6:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Carbine_Cyberpunk2_Lv4_PrimaryAsset_C", false);//2
			break;
		case 7:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Carbine_Daedalus_Lv4_PrimaryAsset_C", false);//2
			break;
		case 8:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Carbine_SpecOps_Lv4_PrimaryAsset_C", false);//2
			break;
		case 9:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Carbine_URF_Lv4_PrimaryAsset_C", false);//2
			break;
		}
	}

	if (EnableKnife) {
		switch ((int)skinknife) {
		case 1:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Afterglow2_Lv2_PrimaryAsset_C", false);//1
			break;
		case 2:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Cyberpunk2_Lv2_PrimaryAsset_C", false);//2
			break;
		case 3:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Soulstealer2_Lv2_PrimaryAsset_C", false);//2
			break;
		case 4:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Afterglow_Lv2_PrimaryAsset_C", false);//2
			break;
		case 5:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Alien_Lv2_PrimaryAsset_C", false);//2
			break;
		case 6:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_HypeBeast2_Lv2_PrimaryAsset_C", false);//2
			break;
		case 7:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Soulstealer_Lv2_PrimaryAsset_C", false);//2
			break;
		case 8:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Champions_Lv2_PrimaryAsset_C", false);//2
			break;
		case 9:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee__Dragon_Lv2_PrimaryAsset_C", false);//2
			break;
		case 10:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Lunar_Lv2_PrimaryAsset_C", false);//2
			break;
		case 11:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Antares_Lv2_PrimaryAsset_C", false);//2
			break;
		case 12:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Champions2_Lv2_PrimaryAsset_C", false);//2
			break;
		case 13:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Haunted_Lv2_PrimaryAsset_C", false);//2
			break;
		case 14:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Mythic_Lv2_PrimaryAsset_C", false);//2
			break;
		case 15:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Oblivion2_Lv2_PrimaryAsset_C", false);//2
			break;
		case 16:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Melee_Magepunk2_Lv2_PrimaryAsset_C", false);//2
			break;

		}

	}

	if (EnableSheriff) {
		switch ((int)skinsheriff)
		{
		case 1:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__RevolverPistol_Soulstealer_Lv4_PrimaryAsset_C", false);//1
			break;
		case 2:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__RevolverPistol_Edge_Lv4_PrimaryAsset_C", false);//2
			break;
		case 3:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Revolver_Protocol_Lv4_PrimaryAsset_C", false);//2
			break;
		case 4:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Revolver_SOL_Lv4_PrimaryAsset_C", false);//2
			break;
		case 5:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Revolver_Daedalus_Lv4_PrimaryAsset_C", false);//2
			break;
		case 6:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Revolver_Magepunk2_Lv4_PrimaryAsset_C", false);//2
			break;
		}
	}

	if (EnableOperator) {

		switch ((int)skinoperator)
		{
		case 1:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BoltSniper_Circle_Lv4_PrimaryAsset_C", false);//1
			break;
		case 2:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BoltSniper_DemonStone_Lv4_PrimaryAsset_C", false);//2
			break;
		case 3:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BoltSniper_Fallen_Lv4_PrimaryAsset_C", false);//2
			break;
		case 4:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BoltSniper_Cyberpunk2_Lv4_PrimaryAsset_C", false);//2
			break;
		case 5:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BoltSniper_Afterglow2_Lv4_PrimaryAsset_C", false);//2
			break;
		case 6:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BoltSniper_Dragon_Lv4_PrimaryAsset_C", false);//2
			break;
		case 7:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BoltSniper_SOL_Lv4_PrimaryAsset_C", false);//2
			break;
		case 8:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BoltSniper_Soulstealer_Lv4_PrimaryAsset_C", false);//2
			break;
		}


	}
	if (EnableGhost) {

		switch ((int)skinghost)
		{
		case 1:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__LugerPistol_Sovereign_Lv4_PrimaryAsset_C", false);//1
			break;
		case 2:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Luger_King_Lv4_PrimaryAsset_C", false);//2
			break;
		case 3:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Luger_Magepunk_Lv4_PrimaryAsset_C", false);//2
			break;
		case 4:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__Luger_Soulstealer2_Lv4_PrimaryAsset_C", false);//2
			break;
		case 5:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__LugerPistol_Ashen_Lv4_PrimaryAsset_C", false);//2
			break;
		}


	}

	if (EnableClassic) {

		switch ((int)skinclassic)
		{
		case 1:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BasePistol_HypeBeast_Lv4_PrimaryAsset_C", false);//1
			break;
		case 2:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BasePistol_Afterglow2_Lv4_PrimaryAsset_C", false);//1
			break;
		case 3:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BasePistol_Atlas_Lv4_PrimaryAsset_C", false);//1
			break;
		case 4:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__BasePistol_Cyberpunk2_Lv4_PrimaryAsset_C", false);//1
			break;
		}
	}

	if (EnableSpectre) {

		switch ((int)skinspectre)
		{
		case 1:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__MP5_Afterglow2_Lv4_PrimaryAsset_C", false);//1
			break;
		case 2:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__MP5_Soulstealer2_Lv4_PrimaryAsset_C", false);//1
			break;
		case 3:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__MP5_Protocol_Lv4_PrimaryAsset_C", false);//1
			break;
		case 4:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__MP5_King_Lv4_PrimaryAsset_C", false);//1
			break;
		case 5:
			chroma_data = UObject::StaticFindObject(nullptr, reinterpret_cast<UObject*>(-1), L"Default__MP5_Oblivion2_Lv4_PrimaryAsset_C", false);//1
			break;
		}
	}

	return chroma_data;
}


void PostRender(uintptr_t _this, UCanvas* canvas)

{

	if (!canvas)
		return PostRender(_this, canvas);

	if (kekIsOff)
		return PostRender(_this, canvas);

	CWINGui::SetupCanvas(canvas);
	UWorld* World = Memory::ReadStub<UWorld*>(_this + Offsets::Pointer);
	printf("World:%p\n", World);
	APlayerController* MyController = ShooterGameBlueprints::GetFirstLocalPlayerController(World);//crash 456 this was crashing because of pointer
	printf("MyController:%p\n", MyController);
	AShooterCharacter* MyShooter = MyController->GetShooterCharacter();
	printf("MyShooter:%p\n", MyShooter);
	TArray<AShooterCharacter*> Actors = ShooterGameBlueprints::FindAllShooterCharactersWithAlliance(World, MyShooter, EAresAlliance::Alliance_Any, false, true);
	printf("MyShooter:%p\n", Actors);
	CWINGui::Input::Handle();


	if (drawcross)
	{
		CWINGui::DrawCircle({ (float)GetSystemMetrics(SM_CXSCREEN) / 2, (float)GetSystemMetrics(SM_CYSCREEN) / 2 }, radius, LineamountCross, crosscolor);
	}
	if (  drawfov)
	{
		CWINGui::DrawCircle({ (float)GetSystemMetrics(SM_CXSCREEN) / 2, (float)GetSystemMetrics(SM_CYSCREEN) / 2 }, fovChanger, LineamountFov, fovcolor);
	}
	
	if (GetAsyncKeyState(VK_F1) & 1) menu_opened = !menu_opened; //Our menu key 
	if (Watermark) {
		canvas->K2_DrawText(L"StaffBesting Paid | Menu-F1", { 49,40 }, { 1.0f,1.0f/*Size*/ }, { 1.0f,1.0f,1.0f,2.0f/*RGBA*/ }, 0.f, { 0,0,0,1 }, { 0,0 }, 0, 0, 0, { 0,0,0,1 });
	}


	if (CWINGui::Window(skCrypt("StaffBesting Paid | Menu-F1"), &pos, FVector2D{ 564.0f, 385.0f }, menu_opened))
	{
		//Simple Tabs
		static int tab = 0;
		if (CWINGui::ButtonTab(L"Aimbot", FVector2D{ 110, 33 }, tab == 0)) tab = 0;
		CWINGui::SameLine();
		if (CWINGui::ButtonTab(L"ESP", FVector2D{ 110, 33 }, tab == 1)) tab = 1;
		CWINGui::SameLine();
		if (CWINGui::ButtonTab(L"Chams", FVector2D{ 110, 33 }, tab == 2)) tab = 2;
		CWINGui::SameLine();
		if (CWINGui::ButtonTab(L"Misc", FVector2D{ 110, 33 }, tab == 3)) tab = 3;
		CWINGui::SameLine();
		if (CWINGui::ButtonTab(L"Skins", FVector2D{ 110, 33 }, tab == 4)) tab = 4;
		CWINGui::PushNextElementY(10);
		//Some Elements


		if (tab == 0)
		{
			static int TABZ = 0;
			if (CWINGui::ButtonTab(L"Legit", FVector2D{ 275, 29 }, TABZ == 0)) TABZ = 0;
			CWINGui::SameLine();
			if (CWINGui::ButtonTab(L"Rage", FVector2D{ 275, 29 }, TABZ == 1)) TABZ = 1;

			if (TABZ == 0)
			{
				CWINGui::Checkbox(L"Enabled Aimbot", &enableaim);
				CWINGui::Checkbox(L"Draw FOV", &drawfov);
				CWINGui::SliderFloat(L"Value", &fovChanger, 5, 900);
				CWINGui::Hotkey("Keybind", { 90,32 }, &KEKWNOKEY);
				CWINGui::Combobox(L"", { 95,32 }, &aimbone, L"Head", L"Chest", L"Penis", NULL);
				CWINGui::ColorPicker(L"FOV Color", &fovcolor);
			}

			if (TABZ == 1)
			{
				/*CWINGui::Checkbox(L"Silent", &Silent);*/
				CWINGui::Checkbox(L"Triggerbot", &autoshoot);
			}
		}

		if (tab == 1) {

			static int TABZ = 0;
			if (CWINGui::ButtonTab(L"ESP", FVector2D{ 275, 29 }, TABZ == 0)) TABZ = 0;
			CWINGui::SameLine();
			if (CWINGui::ButtonTab(L"Colors", FVector2D{ 275, 29 }, TABZ == 1)) TABZ = 1;


			if (TABZ == 0)
			{
				CWINGui::Checkbox(L"2D Box", &box2d);
				//CWINGui::Checkbox(L"", &box3d);
				CWINGui::Checkbox(L"Visible Box", &Visible_Check_ESP);
				CWINGui::Checkbox(L"Skeleton", &skeleton);
				CWINGui::Text(L"");
				CWINGui::Checkbox(L"Head Circle", &HeadCircleEsp);
				CWINGui::Checkbox(L"Weapon Name", &weaponesp);
				CWINGui::Checkbox(L"Agent Name", &AgentName);
				CWINGui::Checkbox(L"Health Bar", &healthbar);
				CWINGui::Checkbox(L"Enemys on MiniMap", &Minimap);
				CWINGui::Checkbox(L"Snapline", &snaplinenz);
				if (snaplinenz) {
					CWINGui::Combobox(L"", { 95,32 }, &SnapPositionint, L"Bottom", L"Middle", L"Top", NULL);
				}
			}

			if (TABZ == 1)
			{
				CWINGui::ColorPicker(L"Crosshair Color", &crosscolor);
				CWINGui::ColorPicker(L"Name Color", &Name_Color);
				CWINGui::ColorPicker(L"Box Color[Invisible]", &Invisible_ESPColor);
				CWINGui::ColorPicker(L"Box Color[Visible]", &VisibleBox_ESPColor);
				CWINGui::ColorPicker(L"Snapline Color[Invisible]", &InvisibleSnapColor);//Clearly since ScriptsKit is retarted I will just do it
				CWINGui::ColorPicker(L"Snapline Color[Visible]", &VisibleSnapColor);// Here is a way to customize all the color for the cheat soon
				CWINGui::ColorPicker(L"Skeleton Color[Invisible]", &InvisibleSkeletonColor);//I will release rainbow menu
				CWINGui::ColorPicker(L"Skeleton Color[Visible]", &VisibleSkeletonColor);
			}
		}

		if (tab == 2) {
			static int TABZ = 0;
			if (CWINGui::ButtonTab(L"Chams", FVector2D{ 275, 29 }, TABZ == 0)) TABZ = 0;
			CWINGui::SameLine();
			if (CWINGui::ButtonTab(L"Wireframe", FVector2D{ 275, 29 }, TABZ == 1)) TABZ = 1;
			if (TABZ == 0)
			{
				CWINGui::Checkbox(L"Chams", &ChamsESP);
				CWINGui::SliderFloat(L"Glow", &chamsglowvalue, 1, 10);
				CWINGui::ColorPicker(L"RGB Visible", &Visible);
				CWINGui::ColorPicker(L"RGB Invisible", &Invisible);
			}

			if (TABZ == 1)
			{
				CWINGui::Checkbox(L"Wireframe", &Wireframe);
				CWINGui::Checkbox(L"Wireframe Gun", &WireframeGun);
			}
		}

		if (tab == 3) {
			static int TABZ = 0;

			if (CWINGui::ButtonTab(L"Misc", FVector2D{ 275, 29 }, TABZ == 0)) TABZ = 0;
			CWINGui::SameLine();
			if (CWINGui::ButtonTab(L"Other", FVector2D{ 275, 29 }, TABZ == 1)) TABZ = 1;

			if (TABZ == 0)
			{
				//CWINGui::Checkbox(L"Fast Crouch [Buggy]", &);
				CWINGui::Checkbox(L"Draw Crosshair", &drawcross);

				CWINGui::Checkbox(L"Watermark", &Watermark);
				if (CWINGui::Button(L"Skip Tutorial", FVector2D{ 110, 29 })) {
					skiptutorial = true;
				}

				CWINGui::Checkbox(L"FOV Changer", &fovchanger);
				if (fovchanger) {
					CWINGui::SliderFloat(L"Value", &fovchangur, 0, 170);
				}

				/*CWINGui::Checkbox(L"ThirdPerson", &ThirdPerson);*/
				if (ThirdPerson) {
					CWINGui::SliderFloat(L"Distange", &PlayerDistange, 100, 1000);
				}
			}

			if (TABZ == 1)
			{
				if (CWINGui::Button(L"DaddyKermit", FVector2D{ 110, 33 })) {
					system("start https://discord.com/users/1055003985540567050");
				}
				CWINGui::SameLine();
				if (CWINGui::Button(L"AngelCheats Forums", FVector2D{ 110, 33 })) {
					system("start https://angelcheats.cloud");
				}
			}
		}

		if (tab == 4) {
			static int TABZ = 0;

			if (CWINGui::ButtonTab(L"Skins", FVector2D{ 275, 29 }, TABZ == 0)) TABZ = 0;
			CWINGui::SameLine();
			if (CWINGui::ButtonTab(L"UnlockALL", FVector2D{ 275, 29 }, TABZ == 1)) TABZ = 1;

			if (TABZ == 0)
			{
				CWINGui::Checkbox(L"Vandal", &EnableVandal);
				CWINGui::Checkbox(L"Phantom", &EnablePhantom);
				CWINGui::Checkbox(L"Spectre", &EnableSpectre);
				CWINGui::Checkbox(L"Operator", &EnableOperator);
				CWINGui::Checkbox(L"Sheriff", &EnableSheriff);
				CWINGui::Checkbox(L"Ghost", &EnableGhost);
				CWINGui::Checkbox(L"Classic", &EnableClassic);
				CWINGui::Checkbox(L"Knife", &EnableKnife);
			}

			if (TABZ == 1)
			{
				//if (CWINGui::Button(L"UnlockAll", FVector2D{ 110, 33 })) {
				//	if (auto manager = (World))
				//	{
				//		inventory_manager* inventory;
				//		vector<UObject*>spray_models = inventory->get_all_spray_models();

				//		for (int i = 0; i < spray_models.size(); i++)
				//		{
				//			auto spray_model = spray_models[i];
				//			if (!spray_model) continue;

				//			*(bool*)(spray_model + 0xf2) = true; //UBaseInventoryModel::bIsOwned
				//		}
				//	}
				//}

				CWINGui::Text(L"Unlock all soon");

				//if (CWINGui::Button(L"UnlockAllWeapons", FVector2D{ 110, 33 })) {

				//}
			}
		}
	}
	CWINGui::Draw_Cursor(menu_opened);
	CWINGui::Render();

	if (fovchanger) {
		MyController->set_fov(fovchangur);
	}
	if (skiptutorial) {
		MyController->DisconnectFromServer();
		Beep(300, 300);
		skiptutorial = false;
	}
	

	bool hasTarget = false;
	for (int Index = 0; Index < Actors.Num(); Index++)
	{
		if (!Actors.IsValidIndex(Index))
			continue;

		//Skins
		if (EnableKnife) {
			skinknife += 1;
			if (skinknife == 17) {
				skinknife = 1;
			}
			if (MyShooter) {
				auto get_equippable_pointer = reinterpret_cast<std::uintptr_t(__fastcall*)(AAresEquippable*)>(VALORANT::Module + Offsets::SkinChanger); //https://github.com/10HEAD/ValorantOffsets/blob/main/valorantoffsets.hpp#L11
				std::uintptr_t result = get_equippable_pointer(MyShooter->GetInventory()->GetCurrentWeapon());

				if (result) {
					std::uintptr_t result = get_equippable_pointer(MyShooter->GetInventory()->GetCurrentWeapon());
					int64 var = Memory::ReadStub<uintptr_t>(result + 664);
					var = Memory::ReadStub<uintptr_t>(var + 160);

					int backup = Memory::ReadStub<int>(var + 128);
					Memory::WriteStub<int>(var + Offsets::Pointer, 2);

					UObject* skin_data_asset = skinlist();
					UObject* chroma_data_asset = skinlistchroma();
					if ((skin_data_asset) && (chroma_data_asset))
					{
						MyShooter->ClearWeaponComponents(MyShooter->GetInventory()->GetCurrentWeapon());
						MyShooter->ApplySkin(MyShooter->GetInventory()->GetCurrentWeapon(), skin_data_asset, chroma_data_asset, 2, nullptr, -1);
					}
					if (EnableKnife == true) {
						EnableKnife = false;
					}
					Memory::WriteStub(var + Offsets::Pointer, 6);

				}
			}
		}
		int skinLevel = 4;
		if (EnableVandal) {
			if (MyShooter) {
				skinvandal += 1;
				if (skinvandal == 13) {
					skinvandal = 1;
				}
				auto get_equippable_pointer = reinterpret_cast<std::uintptr_t(__fastcall*)(AAresEquippable*)>(VALORANT::Module + Offsets::SkinChanger); //https://github.com/10HEAD/ValorantOffsets/blob/main/valorantoffsets.hpp#L11
				std::uintptr_t result = get_equippable_pointer(MyShooter->GetInventory()->GetCurrentWeapon());

				if (result) {
					std::uintptr_t result = get_equippable_pointer(MyShooter->GetInventory()->GetCurrentWeapon());
					int64 var = Memory::ReadStub<uintptr_t>(result + 664);
					var = Memory::ReadStub<uintptr_t>(var + 160);

					int backup = Memory::ReadStub<int>(var + 128);
					Memory::WriteStub<int>(var + Offsets::Pointer, 2);

					UObject* skin_data_asset = skinlist();
					UObject* chroma_data_asset = skinlistchroma();
					if ((skin_data_asset) && (chroma_data_asset))
					{
						MyShooter->ClearWeaponComponents(MyShooter->GetInventory()->GetCurrentWeapon());
						MyShooter->ApplySkin(MyShooter->GetInventory()->GetCurrentWeapon(), skin_data_asset, chroma_data_asset, skinLevel, nullptr, -1);
					}
					Memory::WriteStub(var + Offsets::Pointer, 6);
					if (EnableVandal == true) {
						EnableVandal = false;
					}
				}
			}
		}
		if (EnableOperator) {
			skinoperator += 1;
			if (skinoperator == 9) {
				skinoperator = 1;
			}
			if (MyShooter) {
				auto get_equippable_pointer = reinterpret_cast<std::uintptr_t(__fastcall*)(AAresEquippable*)>(VALORANT::Module + Offsets::SkinChanger); //https://github.com/10HEAD/ValorantOffsets/blob/main/valorantoffsets.hpp#L11
				std::uintptr_t result = get_equippable_pointer(MyShooter->GetInventory()->GetCurrentWeapon());

				if (result) {
					std::uintptr_t result = get_equippable_pointer(MyShooter->GetInventory()->GetCurrentWeapon());
					int64 var = Memory::ReadStub<uintptr_t>(result + 664);
					var = Memory::ReadStub<uintptr_t>(var + 160);

					int backup = Memory::ReadStub<int>(var + 128);
					Memory::WriteStub<int>(var + Offsets::Pointer, 2);

					UObject* skin_data_asset = skinlist();
					UObject* chroma_data_asset = skinlistchroma();
					if ((skin_data_asset) && (chroma_data_asset))
					{
						MyShooter->ClearWeaponComponents(MyShooter->GetInventory()->GetCurrentWeapon());
						MyShooter->ApplySkin(MyShooter->GetInventory()->GetCurrentWeapon(), skin_data_asset, chroma_data_asset, skinLevel, nullptr, -1);
					}
					Memory::WriteStub(var + Offsets::Pointer, 6);
					if (EnableOperator == true) {
						EnableOperator = false;
					}
				}
			}
		}
		if (EnablePhantom) {

			skinphantom += 1;
			if (skinphantom == 10) {
				skinphantom = 1;
			}
			if (MyShooter) {
				auto get_equippable_pointer = reinterpret_cast<std::uintptr_t(__fastcall*)(AAresEquippable*)>(VALORANT::Module + Offsets::SkinChanger); //https://github.com/10HEAD/ValorantOffsets/blob/main/valorantoffsets.hpp#L11
				std::uintptr_t result = get_equippable_pointer(MyShooter->GetInventory()->GetCurrentWeapon());

				if (result) {
					std::uintptr_t result = get_equippable_pointer(MyShooter->GetInventory()->GetCurrentWeapon());
					int64 var = Memory::ReadStub<uintptr_t>(result + 664);
					var = Memory::ReadStub<uintptr_t>(var + 160);

					int backup = Memory::ReadStub<int>(var + 128);
					Memory::WriteStub<int>(var + Offsets::Pointer, 2);

					UObject* skin_data_asset = skinlist();
					UObject* chroma_data_asset = skinlistchroma();
					if ((skin_data_asset) && (chroma_data_asset))
					{
						MyShooter->ClearWeaponComponents(MyShooter->GetInventory()->GetCurrentWeapon());
						MyShooter->ApplySkin(MyShooter->GetInventory()->GetCurrentWeapon(), skin_data_asset, chroma_data_asset, skinLevel, nullptr, -1);
					}
					Memory::WriteStub(var + Offsets::Pointer, 6);
					if (EnablePhantom == true) {
						EnablePhantom = false;
					}
				}
			}
		}
		if (EnableSpectre) {
			skinspectre += 1;
			if (skinspectre == 6) {
				skinspectre = 1;
			}
			if (MyShooter) {
				auto get_equippable_pointer = reinterpret_cast<std::uintptr_t(__fastcall*)(AAresEquippable*)>(VALORANT::Module + Offsets::SkinChanger); //https://github.com/10HEAD/ValorantOffsets/blob/main/valorantoffsets.hpp#L11
				std::uintptr_t result = get_equippable_pointer(MyShooter->GetInventory()->GetCurrentWeapon());

				if (result) {
					std::uintptr_t result = get_equippable_pointer(MyShooter->GetInventory()->GetCurrentWeapon());
					int64 var = Memory::ReadStub<uintptr_t>(result + 664);
					var = Memory::ReadStub<uintptr_t>(var + 160);

					int backup = Memory::ReadStub<int>(var + 128);
					Memory::WriteStub<int>(var + Offsets::Pointer, 2);

					UObject* skin_data_asset = skinlist();
					UObject* chroma_data_asset = skinlistchroma();
					if ((skin_data_asset) && (chroma_data_asset))
					{
						MyShooter->ClearWeaponComponents(MyShooter->GetInventory()->GetCurrentWeapon());
						MyShooter->ApplySkin(MyShooter->GetInventory()->GetCurrentWeapon(), skin_data_asset, chroma_data_asset, skinLevel, nullptr, -1);
					}
					Memory::WriteStub(var + Offsets::Pointer, 6);
					if (EnableSpectre == true) {
						EnableSpectre = false;
					}
				}
			}
		}
		if (EnableSheriff) {
			skinsheriff += 1;
			if (skinsheriff == 8) {
				skinsheriff = 1;
			}
			if (MyShooter) {
				auto get_equippable_pointer = reinterpret_cast<std::uintptr_t(__fastcall*)(AAresEquippable*)>(VALORANT::Module + Offsets::SkinChanger); //https://github.com/10HEAD/ValorantOffsets/blob/main/valorantoffsets.hpp#L11
				std::uintptr_t result = get_equippable_pointer(MyShooter->GetInventory()->GetCurrentWeapon());

				if (result) {
					std::uintptr_t result = get_equippable_pointer(MyShooter->GetInventory()->GetCurrentWeapon());
					int64 var = Memory::ReadStub<uintptr_t>(result + 664);
					var = Memory::ReadStub<uintptr_t>(var + 160);

					int backup = Memory::ReadStub<int>(var + 128);
					Memory::WriteStub<int>(var + Offsets::Pointer, 2);

					UObject* skin_data_asset = skinlist();
					UObject* chroma_data_asset = skinlistchroma();
					if ((skin_data_asset) && (chroma_data_asset))
					{
						MyShooter->ClearWeaponComponents(MyShooter->GetInventory()->GetCurrentWeapon());
						MyShooter->ApplySkin(MyShooter->GetInventory()->GetCurrentWeapon(), skin_data_asset, chroma_data_asset, skinLevel, nullptr, -1);
					}
					Memory::WriteStub(var + Offsets::Pointer, 6);
					if (EnableSheriff == true) {
						EnableSheriff = false;
					}
				}
			}
		}
		if (EnableGhost) {
			skinghost += 1;
			if (skinghost == 6) {
				skinghost = 1;
			}
			if (MyShooter) {
				auto get_equippable_pointer = reinterpret_cast<std::uintptr_t(__fastcall*)(AAresEquippable*)>(VALORANT::Module + Offsets::SkinChanger); //https://github.com/10HEAD/ValorantOffsets/blob/main/valorantoffsets.hpp#L11
				std::uintptr_t result = get_equippable_pointer(MyShooter->GetInventory()->GetCurrentWeapon());

				if (result) {
					std::uintptr_t result = get_equippable_pointer(MyShooter->GetInventory()->GetCurrentWeapon());
					int64 var = Memory::ReadStub<uintptr_t>(result + 664);
					var = Memory::ReadStub<uintptr_t>(var + 160);

					int backup = Memory::ReadStub<int>(var + 128);
					Memory::WriteStub<int>(var + Offsets::Pointer, 2);

					UObject* skin_data_asset = skinlist();
					UObject* chroma_data_asset = skinlistchroma();
					if ((skin_data_asset) && (chroma_data_asset))
					{
						MyShooter->ClearWeaponComponents(MyShooter->GetInventory()->GetCurrentWeapon());
						MyShooter->ApplySkin(MyShooter->GetInventory()->GetCurrentWeapon(), skin_data_asset, chroma_data_asset, skinLevel, nullptr, -1);
					}
					Memory::WriteStub(var + Offsets::Pointer, 6);
					if (EnableGhost == true) {
						EnableGhost = false;
					}
				}
			}
		}
		if (EnableClassic) {
			skinclassic += 1;
			if (skinghost == 5) {
				skinghost = 1;
			}
			if (MyShooter) {
				auto get_equippable_pointer = reinterpret_cast<std::uintptr_t(__fastcall*)(AAresEquippable*)>(VALORANT::Module + Offsets::SkinChanger); //https://github.com/10HEAD/ValorantOffsets/blob/main/valorantoffsets.hpp#L11
				std::uintptr_t result = get_equippable_pointer(MyShooter->GetInventory()->GetCurrentWeapon());
				if (result) {
					std::uintptr_t result = get_equippable_pointer(MyShooter->GetInventory()->GetCurrentWeapon());
					int64 var = Memory::ReadStub<uintptr_t>(result + 664);
					var = Memory::ReadStub<uintptr_t>(var + 160);

					int backup = Memory::ReadStub<int>(var + 128);
					Memory::WriteStub<int>(var + Offsets::Pointer, 2);

					UObject* skin_data_asset = skinlist();
					UObject* chroma_data_asset = skinlistchroma();
					if ((skin_data_asset) && (chroma_data_asset))
					{
						MyShooter->ClearWeaponComponents(MyShooter->GetInventory()->GetCurrentWeapon());
						MyShooter->ApplySkin(MyShooter->GetInventory()->GetCurrentWeapon(), skin_data_asset, chroma_data_asset, skinLevel, nullptr, -1);
					}
					Memory::WriteStub(var + Offsets::Pointer, 6);
					if (EnableClassic == true) {
						EnableClassic = false;
					}
				}
			}
		}


		AShooterCharacter* Actor = Actors[Index];
		actor = Actor;
		UObject* Object;
		if (Actor->GetHealth() == 0)
			continue;

		if (!MyShooter) continue;

		if (kismentsystemlibrary::get_object_name(Actor).ToString().find("_PC") != std::string::npos) {
			InGame = 1;
		}
		else {
			InGame = 0;
		}
		Mesh = Actor->GetPawnMesh();
		if (ThirdPerson)
		{
			if (!Mesh3PModifed) MyShooter->Set3pMeshVisible(true);
			Mesh3PModifed = true;
		}
		else
		{
			if (Mesh3PModifed)
			{
				MyShooter->Set3pMeshVisible(false);
				Mesh3PModifed = false;
			}
		}

		if (SpinBot && GetAsyncKeyState(spinbotkeybind) && !GetAsyncKeyState(KEKWNOKEY) && (spinvischeck && MyController->LineOfSightTo(Actor, { 0, 0, 0 }, false) || !spinvischeck)) {

			static auto OldAimAngles = FVector();
			UAresOutlineComponent* Mesh = Actor->GetPawnMesh();
			uintptr_t cmanager = *(uintptr_t*)((uintptr_t)MyController + 0x478);
			FVector CameraRot = *(FVector*)(cmanager + 0x126C);
			FVector DeltaRotation;
			FVector ConvertRotation = { CameraRot.X < 0.f ? 360.f + CameraRot.X : CameraRot.X, CameraRot.Y < 0.f ? 360.f + CameraRot.Y : CameraRot.Y, 0 };
			FVector ControlRotation = MyController->GetControlRotation();

			FVector Delta = { CameraRot.X, CameraRot.Y, CameraRot.Z };
			float hyp = sqrtf(Delta.X * Delta.X + Delta.Y * Delta.Y + Delta.Z * Delta.Z);

			FVector Rotation = { acosf(Delta.Z / hyp) * (float)(180.0f / 3.1415926535897932384626433832795028841971693993751), atanf(Delta.Y / Delta.X) * (float)(180.0f / 3.1415926535897932384626433832795028841971693993751), 0 };

			Rotation.X += 270.f;

			if (Delta.X >= 0.0f) Rotation.Y += 180.0f;

			if (Rotation.Y < 0.f) Rotation.Y += 360.f;

			DeltaRotation.X = fmodf(ConvertRotation.X - ControlRotation.X, 360.f);
			DeltaRotation.Y = fmodf(ConvertRotation.Y - ControlRotation.Y, 360.f);

			ConvertRotation.X = fmodf(Rotation.X - DeltaRotation.X - DeltaRotation.X, 360.f);
			ConvertRotation.Y = fmodf(Rotation.Y - DeltaRotation.Y - DeltaRotation.Y, 360.f);

			if (ConvertRotation.X < 0.f) ConvertRotation.X = 360.f + ConvertRotation.X;

			if (ConvertRotation.Y < 0.f) ConvertRotation.Y = 360.f + ConvertRotation.Y;

			MyController->SetControlRotation(ConvertRotation);






		}
		if (FlyHack)
		{
			MyShooter->ClientFly();
		}

		if (BaseTeamComponent::IsAlly(Actor, MyShooter))
			continue;

		if (!InGame) continue;

		bool IsAlive = Actor->IsAlive();
		if (Mesh && Actor->IsAlive())
		{
			FLinearColor BoxColor;
			FLinearColor SnapColor;
			FLinearColor SkeletonColor;
			FLinearColor ChamsColor;

			if (true)
			{
				if (MyController->LineOfSightTo(Actor, { 0,0,0 }, false)) {

					SnapColor = VisibleSnapColor;
					BoxColor = VisibleBox_ESPColor;
					SkeletonColor = VisibleSkeletonColor;

					ChamsColor = Visible;

				}
				else {

					SnapColor = InvisibleSnapColor;
					BoxColor = Invisible_ESPColor;
					SkeletonColor = InvisibleSkeletonColor;
					ChamsColor = Invisible;
				}

			}
			if (HeadCircleEsp) {
				FVector2D vHeadBoneOut;
				if (MyController->ProjectWorldLocationToScreen(GetBoneMatrix(Mesh, 8), vHeadBoneOut, 0) && vHeadBoneOut.IsValid())
				{
					CWINGui::DrawCircle({ vHeadBoneOut.X, vHeadBoneOut.Y }, radius2, LineamountCircle, BoxColor);
				}

			}
			if (box2d)
			{
				FVector Origin, Extend;
				MyController->GetActorBounds(Actor, 1, &Origin, &Extend, 0);

				auto location = Actor->K2_GetActorLocation();
					
				FVector2D footPos;
				if (!MyController->ProjectWorldLocationToScreen({ location.X, location.Y, location.Z + (Extend.Z / 3) }, footPos, 0)) 
					continue;

				FVector2D headPos;
				if (!MyController->ProjectWorldLocationToScreen({ location.X, location.Y, location.Z - (Extend.Z / 3) }, headPos, 0)) 
					continue;


				const float height = abs(footPos.Y - headPos.Y);
				const float width = height * 0.4f;
				FVector2D top = { headPos.X - width * 0.5f, headPos.Y };
				FVector2D bottom = { headPos.X + width * 0.5f, footPos.Y };
				
				auto thicc = ESPThickness;
				FLinearColor xclr = RGBtoFLC(0, 0, 0);
				canvas->K2_DrawLinex(bottom, { bottom.X, top.Y }, thicc, BoxColor);
				canvas->K2_DrawLinex(top, { top.X , top.Y }, thicc, BoxColor);
				canvas->K2_DrawLinex(top, { top.X , bottom.Y }, thicc, BoxColor);
				canvas->K2_DrawLine(bottom, { bottom.X, bottom.Y }, thicc, BoxColor);
			}
			if (enableaim) {

				FVector Target;
				if (aimbone == 0) {//Head
					Target = GetBoneMatrix(Mesh, 8);
				}
				else if (aimbone == 1) {//Chets
					Target = GetBoneMatrix(Mesh, 6);
				}
				else if (aimbone == 2) {//Penis
					Target = GetBoneMatrix(Mesh, 3);
				}

				FVector2D head_screen;
				//FovandKey
				if (MyController->ProjectWorldLocationToScreen(Target, head_screen, 0) && head_screen.IsValid()) {

					if (enableaim && !Silent && !autoaim && !hasTarget && GetAsyncKeyState(KEKWNOKEY) && in_rect(ScreenCenterX, ScreenCenterY, fovChanger, head_screen.X, head_screen.Y) && (vischeck && MyController->LineOfSightTo(Actor, { 0, 0, 0 }, false) || !vischeck))
					{
						uintptr_t cmanager = *(uintptr_t*)((uintptr_t)MyController + 0x478);
						FVector CameraPos = *(FVector*)(cmanager + 0x1260);
						FVector CameraRot = *(FVector*)(cmanager + 0x126C);
						FVector DeltaRotation;
						FVector ConvertRotation = { CameraRot.X < 0.f ? 360.f + CameraRot.X : CameraRot.X, CameraRot.Y < 0.f ? 360.f + CameraRot.Y : CameraRot.Y, 0 };
						FVector ControlRotation = MyController->GetControlRotation();

						FVector Delta = { CameraPos.X - Target.X, CameraPos.Y - Target.Y, CameraPos.Z - Target.Z };
						float hyp = sqrtf(Delta.X * Delta.X + Delta.Y * Delta.Y + Delta.Z * Delta.Z);

						FVector Rotation = { acosf(Delta.Z / hyp) * (float)(180.0f / 3.1415926535897932384626433832795028841971693993751), atanf(Delta.Y / Delta.X) * (float)(180.0f / 3.1415926535897932384626433832795028841971693993751), 0 };

						Rotation.X += 270.f;

						if (Delta.X >= 0.0f) Rotation.Y += 180.0f;

						if (Rotation.Y < 0.f) Rotation.Y += 360.f;

						DeltaRotation.X = fmodf(ConvertRotation.X - ControlRotation.X, 360.f);
						DeltaRotation.Y = fmodf(ConvertRotation.Y - ControlRotation.Y, 360.f);

						ConvertRotation.X = fmodf(Rotation.X - DeltaRotation.X - DeltaRotation.X, 360.f);
						ConvertRotation.Y = fmodf(Rotation.Y - DeltaRotation.Y - DeltaRotation.Y, 360.f);

						if (ConvertRotation.X < 0.f) ConvertRotation.X = 360.f + ConvertRotation.X;

						if (ConvertRotation.Y < 0.f) ConvertRotation.Y = 360.f + ConvertRotation.Y;

						MyController->SetControlRotation(ConvertRotation);
						hasTarget = true;
					}

				}

				//AutoAim
				if (MyController->ProjectWorldLocationToScreen(Target, head_screen, 0) && head_screen.IsValid()) {

					if (enableaim && autoshoot && !Silent && !hasTarget && in_rect(ScreenCenterX, ScreenCenterY, fovChanger, head_screen.X, head_screen.Y) && (vischeck && MyController->LineOfSightTo(Actor, { 0, 0, 0 }, false) || !vischeck))
					{
						uintptr_t cmanager = *(uintptr_t*)((uintptr_t)MyController + 0x478);
						FVector CameraPos = *(FVector*)(cmanager + 0x1260);
						FVector CameraRot = *(FVector*)(cmanager + 0x126C);
						FVector DeltaRotation;
						FVector ConvertRotation = { CameraRot.X < 0.f ? 360.f + CameraRot.X : CameraRot.X, CameraRot.Y < 0.f ? 360.f + CameraRot.Y : CameraRot.Y, 0 };
						FVector ControlRotation = MyController->GetControlRotation();

						FVector Delta = { CameraPos.X - Target.X, CameraPos.Y - Target.Y, CameraPos.Z - Target.Z };
						float hyp = sqrtf(Delta.X * Delta.X + Delta.Y * Delta.Y + Delta.Z * Delta.Z);

						FVector Rotation = { acosf(Delta.Z / hyp) * (float)(180.0f / 3.1415926535897932384626433832795028841971693993751), atanf(Delta.Y / Delta.X) * (float)(180.0f / 3.1415926535897932384626433832795028841971693993751), 0 };

						Rotation.X += 270.f;

						if (Delta.X >= 0.0f) Rotation.Y += 180.0f;

						if (Rotation.Y < 0.f) Rotation.Y += 360.f;

						DeltaRotation.X = fmodf(ConvertRotation.X - ControlRotation.X, 360.f);
						DeltaRotation.Y = fmodf(ConvertRotation.Y - ControlRotation.Y, 360.f);

						ConvertRotation.X = fmodf(Rotation.X - DeltaRotation.X - DeltaRotation.X, 360.f);
						ConvertRotation.Y = fmodf(Rotation.Y - DeltaRotation.Y - DeltaRotation.Y, 360.f);
						if (ConvertRotation.X < 0.f) ConvertRotation.X = 360.f + ConvertRotation.X;

						if (ConvertRotation.Y < 0.f) ConvertRotation.Y = 360.f + ConvertRotation.Y;
						MyController->SetControlRotation(ConvertRotation);
						hasTarget = true;
						mouse_event(MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);

					}




				}

				//NoSpread
				if (enableaim && RageBot && GetAsyncKeyState(RageBotKeybind) && !hasTarget && (vischeck && MyController->LineOfSightTo(Actor, { 0, 0, 0 }, false) || !vischeck))
				{
					get_error_angle((uintptr_t)Actor, 0); //Current equippable + I think its 0x10f0 = firing state compenent

				}

				if (Silent)
				{

					FVector Target;
					if (aimbone == 0) {//Head
						Target = GetBoneMatrix(Mesh, 8);
					}
					else if (aimbone == 1) {//Chets
						Target = GetBoneMatrix(Mesh, 6);
					}
					else if (aimbone == 2) {//Penis
						Target = GetBoneMatrix(Mesh, 3);
					}


					//FovandKey
					if (MyController->ProjectWorldLocationToScreen(Target, head_scren, 0) && head_scren.IsValid()) {

						if (Silent && !RageBot && !autoaim && !hasTarget && GetAsyncKeyState(KEKWNOKEY) && in_rect(ScreenCenterX, ScreenCenterY, fovChanger, head_scren.X, head_scren.Y) && (vischeck && MyController->LineOfSightTo(Actor, { 0, 0, 0 }, false) || !vischeck))
						{
							uintptr_t cmanager = *(uintptr_t*)((uintptr_t)MyController + 0x478);
							FVector CameraPos = *(FVector*)(cmanager + 0x1260);
							FVector CameraRot = *(FVector*)(cmanager + 0x126C);
							FVector DeltaRotation;
							FVector ConvertRotation = { CameraRot.X < 0.f ? 360.f + CameraRot.X : CameraRot.X, CameraRot.Y < 0.f ? 360.f + CameraRot.Y : CameraRot.Y, 0 };
							FVector ControlRotation = MyController->GetControlRotation();

							FVector Delta = { CameraPos.X - Target.X, CameraPos.Y - Target.Y, CameraPos.Z - Target.Z };
							float hyp = sqrtf(Delta.X * Delta.X + Delta.Y * Delta.Y + Delta.Z * Delta.Z);

							FVector Rotation = { acosf(Delta.Z / hyp) * (float)(180.0f / 3.1415926535897932384626433832795028841971693993751), atanf(Delta.Y / Delta.X) * (float)(180.0f / 3.1415926535897932384626433832795028841971693993751), 0 };

							Rotation.X += 270.f;

							if (Delta.X >= 0.0f) Rotation.Y += 180.0f;

							if (Rotation.Y < 0.f) Rotation.Y += 360.f;

							DeltaRotation.X = fmodf(ConvertRotation.X - ControlRotation.X, 360.f);
							DeltaRotation.Y = fmodf(ConvertRotation.Y - ControlRotation.Y, 360.f);

							ConvertRotation.X = fmodf(Rotation.X - DeltaRotation.X - DeltaRotation.X, 360.f);
							ConvertRotation.Y = fmodf(Rotation.Y - DeltaRotation.Y - DeltaRotation.Y, 360.f);

							if (ConvertRotation.X < 0.f) ConvertRotation.X = 360.f + ConvertRotation.X;

							if (ConvertRotation.Y < 0.f) ConvertRotation.Y = 360.f + ConvertRotation.Y;

							MyController->SetControlRotation(ConvertRotation);
							hasTarget = true;
						}

					}

				}
			}
			if (snaplinenz)
			{
				FVector2D drawtextat;
				if (MyController->ProjectWorldLocationToScreen(GetBoneMatrix(Mesh, SnapMesh), drawtextat, 0) && drawtextat.IsValid());
				canvas->K2_DrawLine({ (float)GetSystemMetrics(SM_CXSCREEN) / 2, (float)GetSystemMetrics(SM_CYSCREEN) / SnapPositionİnt/*135*/ }, drawtextat, ESPThickness, SnapColor);

			}

			if (Wireframe)
			{
				*(char*)(Mesh + 0x716) = *(char*)(Mesh + 0x716) | (1 << 5);//For wireframe hand use Current local mesh use WireframeGun for a exmple
				*(char*)(Mesh + 0xc0) = 0xff;
			}
			
			if (WireframeGun)
			{
				if (auto get_inventory = MyShooter->GetInventory())
				{
					if (auto get_weapon = get_inventory->GetCurrentWeapon())
					{
						if (auto weapon_mesh_1p = get_weapon->GetMesh1P())
						{

							*(char*)(weapon_mesh_1p + 0x716) = *(char*)(weapon_mesh_1p + 0x716) | (1 << 5);
							*(char*)(weapon_mesh_1p + 0xc0) = 0xff; //now i try this
							/*	write<char>((uintptr_t)weapon_mesh_1p + 0xc0, 0xff);*/
						}
					}
				}
			}
			
			if (Minimap)
			{
				uintptr_t ShooterCharacterMinimapComponent = Memory::ReadStub<uintptr_t>((uintptr_t)Actor + Offsets::portrait_map);
				uintptr_t CharacterPortraitMinimapComponent = Memory::ReadStub<uintptr_t>((uintptr_t)Actor + Offsets::character_map);

				*(bool*)(ShooterCharacterMinimapComponent + 0x501) = true;
				*(bool*)(ShooterCharacterMinimapComponent + 0x530) = true;

				*(bool*)(CharacterPortraitMinimapComponent + 0x501) = true;
				*(bool*)(CharacterPortraitMinimapComponent + 0x530) = true;
			}
			if (weaponesp)
			{
				FVector Origin, Extend;
				FVector2D rel2d, footPos;

				MyController->GetActorBounds(Actor, 0, &Origin, &Extend, 0);

				auto RelativeLocation = Actor->K2_GetActorLocation();

				if (MyController->ProjectWorldLocationToScreen({ RelativeLocation.X, RelativeLocation.Y + 12, RelativeLocation.Z - (Extend.Z / 10) }, footPos, 0))
				{
					if (MyController->ProjectWorldLocationToScreen(Actor->K2_GetActorLocation(), rel2d, true))
					{
						DrawTextRGBWithFString(canvas, weapon_name(kismentsystemlibrary::get_object_name(Actor->GetInventory()->GetCurrentWeapon())), footPos.X, footPos.Y + 12, BoxColor, 1);
					}
				}
			}
			if (AgentName)
			{

				/* Define vectors */
				FVector Origin, Extend;
				FVector2D rel2d, footPos;

				/* Get bouuuuuuunds */
				MyController->GetActorBounds(Actor, 1, &Origin, &Extend, 0);

				/* Obtain health and RelativeLocation */
				auto RelativeLocation = Actor->K2_GetActorLocation();

				/* W2S the vectors */
				if (MyController->ProjectWorldLocationToScreen({ RelativeLocation.X, RelativeLocation.Y, RelativeLocation.Z + (Extend.Z / 10) }, footPos, 0))
				{
					if (MyController->ProjectWorldLocationToScreen(Actor->K2_GetActorLocation(), rel2d, true))
					{
						DrawTextRGBWithFString(canvas, character_name(kismentsystemlibrary::get_object_name(Actor)), footPos.X, footPos.Y - 34, RGBtoFLC(255, 255, 255), 1);
					}
				}
			}
			if (healthbar)
			{
				if (MyShooter->IsAlive())
				{
					FVector Origin, Extend;
					MyController->GetActorBounds(Actor, 1, &Origin, &Extend, 0);

					auto location = Actor->K2_GetActorLocation(); FVector2D footPos;
					if (!MyController->ProjectWorldLocationToScreen({ location.X, location.Y, location.Z - (Extend.Z / 2) }, footPos, 0)) continue;

					FVector2D headPos;
					if (!MyController->ProjectWorldLocationToScreen({ location.X, location.Y, location.Z + (Extend.Z / 2) }, headPos, 0)) continue;

					auto maxhealth = Actor->GetMaxHealth();
					if (maxhealth >= 100)maxhealth = 100;
					const float hp = Actor->GetHealth() / maxhealth;

					const float height = abs(footPos.Y - headPos.Y + 1);
					const float width = height * 0.4f;
					const float width2 = width * 0.8f;
					const float adjust = height * 0.15f;
					const float len = (width * 2.5) * hp;
					const float lennormalized = (width * 2.5); //normalize just like my penis      

					canvas->K2_DrawLinex({ headPos.X - width2 - 1, footPos.Y - adjust }, { headPos.X - width2 - 1 , footPos.Y + adjust - lennormalized }, 5, RGBtoFLC(0, 0, 0));
					canvas->K2_DrawLinex({ headPos.X - width2, footPos.Y - adjust }, { headPos.X - width2, footPos.Y + adjust - len }, 2, RGBtoFLC(60, 255, 0));
				}

			}
			if (skeleton)
			{
				FVector2D vHipOut;
				FVector2D vNeckOut;
				FVector2D vUpperArmLeftOut;
				FVector2D vLeftHandOut;
				FVector2D vLeftHandOut1;
				FVector2D vUpperArmRightOut;
				FVector2D vRightHandOut;
				FVector2D vRightHandOut1;
				FVector2D vLeftThighOut;
				FVector2D vLeftCalfOut;
				FVector2D vLeftFootOut;
				FVector2D vRightThighOut;
				FVector2D vRightCalfOut;
				FVector2D vRightFootOut;
				if (MyController->ProjectWorldLocationToScreen(GetBoneMatrix(Mesh, 3), vHipOut, 0) && vHipOut.IsValid())
					if (MyController->ProjectWorldLocationToScreen(GetBoneMatrix(Mesh, 7), vNeckOut, 0) && vNeckOut.IsValid())
						if (MyController->ProjectWorldLocationToScreen(GetBoneMatrix(Mesh, 11), vUpperArmLeftOut, 0) && vUpperArmLeftOut.IsValid())
							if (MyController->ProjectWorldLocationToScreen(GetBoneMatrix(Mesh, 12), vLeftHandOut, 0) && vLeftHandOut.IsValid())
								if (MyController->ProjectWorldLocationToScreen(GetBoneMatrix(Mesh, 13), vLeftHandOut1, 0) && vLeftHandOut1.IsValid())
									if (MyController->ProjectWorldLocationToScreen(GetBoneMatrix(Mesh, 36), vUpperArmRightOut, 0) && vUpperArmRightOut.IsValid())
										if (MyController->ProjectWorldLocationToScreen(GetBoneMatrix(Mesh, 37), vRightHandOut, 0) && vRightHandOut.IsValid())
											if (MyController->ProjectWorldLocationToScreen(GetBoneMatrix(Mesh, 38), vRightHandOut1, 0) && vRightHandOut1.IsValid())
												if (MyController->ProjectWorldLocationToScreen(GetBoneMatrix(Mesh, 63), vLeftThighOut, 0) && vLeftThighOut.IsValid())
													if (MyController->ProjectWorldLocationToScreen(GetBoneMatrix(Mesh, 65), vLeftCalfOut, 0) && vLeftCalfOut.IsValid())
														if (MyController->ProjectWorldLocationToScreen(GetBoneMatrix(Mesh, 69), vLeftFootOut, 0) && vLeftFootOut.IsValid())
															if (MyController->ProjectWorldLocationToScreen(GetBoneMatrix(Mesh, 77), vRightThighOut, 0) && vRightThighOut.IsValid())
																if (MyController->ProjectWorldLocationToScreen(GetBoneMatrix(Mesh, 79), vRightCalfOut, 0) && vRightCalfOut.IsValid())
																	if (MyController->ProjectWorldLocationToScreen(GetBoneMatrix(Mesh, 83), vRightFootOut, 0) && vRightFootOut.IsValid())

																		canvas->K2_DrawLine({ vHipOut.X, vHipOut.Y }, { vNeckOut.X, vNeckOut.Y }, 1, BoxColor);
				canvas->K2_DrawLine({ vUpperArmLeftOut.X, vUpperArmLeftOut.Y }, { vNeckOut.X, vNeckOut.Y }, 1, BoxColor);
				canvas->K2_DrawLine({ vUpperArmRightOut.X, vUpperArmRightOut.Y }, { vNeckOut.X, vNeckOut.Y }, 1, BoxColor);
				canvas->K2_DrawLine({ vLeftHandOut.X, vLeftHandOut.Y }, { vUpperArmLeftOut.X, vUpperArmLeftOut.Y }, 1, BoxColor);
				canvas->K2_DrawLine({ vRightHandOut.X, vRightHandOut.Y }, { vUpperArmRightOut.X, vUpperArmRightOut.Y }, 1, BoxColor);
				canvas->K2_DrawLine({ vLeftHandOut.X, vLeftHandOut.Y }, { vLeftHandOut1.X, vLeftHandOut1.Y }, 1, BoxColor);
				canvas->K2_DrawLine({ vRightHandOut.X, vRightHandOut.Y }, { vRightHandOut1.X, vRightHandOut1.Y }, 1, BoxColor);
				canvas->K2_DrawLine({ vLeftThighOut.X, vLeftThighOut.Y }, { vHipOut.X, vHipOut.Y }, 1, BoxColor);
				canvas->K2_DrawLine({ vRightThighOut.X, vRightThighOut.Y }, { vHipOut.X, vHipOut.Y }, 1, BoxColor);
				canvas->K2_DrawLine({ vLeftCalfOut.X, vLeftCalfOut.Y }, { vLeftThighOut.X, vLeftThighOut.Y }, 1, BoxColor);
				canvas->K2_DrawLine({ vRightCalfOut.X, vRightCalfOut.Y }, { vRightThighOut.X, vRightThighOut.Y }, 1, BoxColor);
				canvas->K2_DrawLine({ vLeftFootOut.X, vLeftFootOut.Y }, { vLeftCalfOut.X, vLeftCalfOut.Y }, 1, BoxColor);
				canvas->K2_DrawLine({ vRightFootOut.X, vRightFootOut.Y }, { vRightCalfOut.X, vRightCalfOut.Y }, 1, BoxColor);
			}

			if (skid_spinbot)
			{
				static int spinvalue = 3.5f;
				MyController->SetControlRotation(FVector(271, MyController->GetControlRotation().Y - spinvalue, 0)); // Engine.Controller.SetControlRotation
			}
			if (ChamsESP) {


				auto xd = Memory::ReadStub<USkeletalMeshComponent*>((uintptr_t)Actor + Offsets::ChamsOffset);
				if ((uintptr_t)xd > 0x100000)
					xd->SetOutlineMode(EAresOutlineMode::AlwaysOutline);
				AresOutlineRendering::SetOutlineColorsForRender(World, { ChamsColor.R * chamsglowvalue, ChamsColor.G * chamsglowvalue, ChamsColor.B * chamsglowvalue, ChamsColor.A * chamsglowvalue }, { ChamsColor.R * chamsglowvalue, ChamsColor.G * chamsglowvalue, ChamsColor.B * chamsglowvalue, ChamsColor.A * chamsglowvalue });


			}
			else
			{
				Mesh->SetOutlineMode(EAresOutlineMode::None);
			}
		
			if (SnapPositionint == 0) {
				SnapPositionİnt = 1;
				SnapMesh = 0;
				if (Below == true) {
					Below = false;
				}

			}
			else if (SnapPositionint == 1) {
				SnapPositionİnt = 2;
				SnapMesh = 8;

				if (Middle == true) {
					Middle = false;
				}
			}
			else if (SnapPositionint == 2) {
				SnapPositionİnt = 400;
				SnapMesh = 8;

				if (Bottom == true) {
					Bottom = false;
				}
			}
		}
	}
	return pRender(_this, canvas);
}


void Init()
{
	AllocConsole();
	freopen("CONIN$", "r", stdin);
	freopen("CONOUT$", "w", stdout);
	VALORANT::Module = (uintptr_t)GetModuleHandleA(0);
	printf("Module:%p\n", VALORANT::Module);
	uintptr_t WorldKey = *(uintptr_t*)(VALORANT::Module + Offsets::Key);
	printf("WorldKey:%p\n", WorldKey);
	State StateKey = *(State*)(VALORANT::Module + Offsets::State);
	printf("StateKey:%p\n", StateKey);
	UWorldXOR = Decryption::Decrypt_UWorld(WorldKey, (uintptr_t*)&StateKey);
	printf("UWorldXOR:%p\n", UWorldXOR);

	UWorldClass = Memory::ReadStub<UWorld*>(UWorldXOR);
	GameInstance = Memory::ReadStub<UGameInstance*>((uintptr_t)UWorldClass + 0x1A0);
	LocalPlayers = Memory::ReadStub<ULocalPlayer*>((uintptr_t)GameInstance + 0x40); //this is tarray but im paster lol
	LocalPlayer = Memory::ReadStub<ULocalPlayer*>((uintptr_t)LocalPlayers); //
	APlayerController* LocalController = Memory::ReadStub<APlayerController*>((uintptr_t)LocalPlayer + 0x38);
	uintptr_t ViewportClient = Memory::ReadStub<uintptr_t>((uintptr_t)LocalPlayer + 0x78);//struct UGameViewportClient* ViewportClient; 
	uintptr_t Engine = Memory::ReadStub<uintptr_t>((uintptr_t)GameInstance + 0x28);
	DefaultMediumFont = Memory::ReadStub<UObject*>(Engine + 0xd8);
	APlayerCameraManager* PlayerCameraManager = Memory::ReadStub<APlayerCameraManager*>((uintptr_t)LocalController + Offsets::PlayerCameraManager);// this may need to be swapped back if so dm me
	//camMan = Memory::ReadStub<uintptr_t>((uintptr_t)LocalController + 0x478);

	// try it out now wait want to check something out for skinchanger one second
	LocalCameraLocation = Memory::ReadStub<uintptr_t>((uintptr_t)PlayerCameraManager + 0x1260);
	LocalCameraFOV = Memory::ReadStub<float>((uintptr_t)PlayerCameraManager + 0x1278);
	LocalCameraRotation = Memory::ReadStub<uintptr_t>((uintptr_t)PlayerCameraManager + 0x126C);//this should work

	NamePoolData = reinterpret_cast<FNamePool*>(VALORANT::Module + NamePoolDataOffset);
	Hook::VMT((void*)ViewportClient, PostRender, 0x68, (void**)&pRender);
	Hook::VMT((void*)PlayerCameraManager, SetCameraCachePOVHook, 0xD4, (void**)&SetCameraCachePOVOriginal); //swap the method back to urs if this crash

}
extern "C" __declspec(dllexport) int NextHook(int code, WPARAM wParam, LPARAM lParam) { return CallNextHookEx(NULL, code, wParam, lParam); }


BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
	switch (ul_reason_for_call) {
	case DLL_PROCESS_ATTACH:
		Init();
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}
```

`README.md`:

```md
valorant internal cheat updated Enjoy

```

`StaffBesting.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.3.32922.545
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "internal", "internal.vcxproj", "{1998D631-50F0-4719-BA07-FEB48A9ED452}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Debug|x64.ActiveCfg = Debug|x64
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Debug|x64.Build.0 = Debug|x64
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Debug|x86.ActiveCfg = Debug|Win32
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Debug|x86.Build.0 = Debug|Win32
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Release|x64.ActiveCfg = Release|x64
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Release|x64.Build.0 = Release|x64
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Release|x86.ActiveCfg = Release|Win32
		{1998D631-50F0-4719-BA07-FEB48A9ED452}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {EFC4D86C-395B-4AC9-83D2-9D4A33E8820C}
	EndGlobalSection
EndGlobal

```

`decryption.h`:

```h
#ifndef DEFS_H
#define DEFS_H
#pragma once

/*____________________________________________________________________________________________________________

Original Author: skadro
Github: https://github.com/skadro-official
License: See end of file

skCrypter
		Compile-time, Usermode + Kernelmode, safe and lightweight string crypter library for C++11+

							*Not removing this part is appreciated*
____________________________________________________________________________________________________________*/

#ifdef _KERNEL_MODE
namespace std
{
	// STRUCT TEMPLATE remove_reference
	template <class _Ty>
	struct remove_reference {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&> {
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_reference<_Ty&&> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

	// STRUCT TEMPLATE remove_const
	template <class _Ty>
	struct remove_const { // remove top-level const qualifier
		using type = _Ty;
	};

	template <class _Ty>
	struct remove_const<const _Ty> {
		using type = _Ty;
	};

	template <class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;
}
#else
#include <type_traits>
#endif

namespace skc
{
	template<class _Ty>
	using clean_type = typename std::remove_const_t<std::remove_reference_t<_Ty>>;

	template <int _size, char _key1, char _key2, typename T>
	class skCrypter
	{
	public:
		__forceinline constexpr skCrypter(T* data)
		{
			crypt(data);
		}

		__forceinline T* get()
		{
			return _storage;
		}

		__forceinline int size() // (w)char count
		{
			return _size;
		}

		__forceinline  char key()
		{
			return _key1;
		}

		__forceinline  T* encrypt()
		{
			if (!isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline  T* decrypt()
		{
			if (isEncrypted())
				crypt(_storage);

			return _storage;
		}

		__forceinline bool isEncrypted()
		{
			return _storage[_size - 1] != 0;
		}

		__forceinline void clear() // set full storage to 0
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = 0;
			}
		}

		__forceinline operator T* ()
		{
			decrypt();

			return _storage;
		}

	private:
		__forceinline constexpr void crypt(T* data)
		{
			for (int i = 0; i < _size; i++)
			{
				_storage[i] = data[i] ^ (_key1 + i % (1 + _key2));
			}
		}

		T _storage[_size]{};
	};
}

#define skCrypt(str) skCrypt_key(str, __TIME__[4], __TIME__[7])
#define skCrypt_key(str, key1, key2) []() { \
			constexpr static auto crypted = skc::skCrypter \
				<sizeof(str) / sizeof(str[0]), key1, key2, skc::clean_type<decltype(str[0])>>((skc::clean_type<decltype(str[0])>*)str); \
					return crypted; }()

/*________________________________________________________________________________

MIT License

Copyright (c) 2020 skadro

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

________________________________________________________________________________*/
#if defined(__GNUC__)
typedef          long long ll;
typedef unsigned long long ull;
#define __int64 long long
#define __int32 int
#define __int16 short
#define __int8  char
#define MAKELL(num) num ## LL
#define FMT_64 "ll"
#elif defined(_MSC_VER)
typedef          __int64 ll;
typedef unsigned __int64 ull;
#define MAKELL(num) num ## i64
#define FMT_64 "I64"
#elif defined (__BORLANDC__)
typedef          __int64 ll;
typedef unsigned __int64 ull;
#define MAKELL(num) num ## i64
#define FMT_64 "L"
#else
#error "unknown compiler"
#endif

typedef unsigned int uint;
typedef unsigned char uchar;
typedef unsigned short ushort;
typedef unsigned long ulong;

typedef          char   int8;
typedef   signed char   sint8;
typedef unsigned char   uint8;
typedef          short  int16;
typedef   signed short  sint16;
typedef unsigned short  uint16;
typedef          int    int32;
typedef   signed int    sint32;
typedef unsigned int    uint32;
typedef ll              int64;
typedef ll              sint64;
typedef ull             uint64;

// Partially defined types. They are used when the decompiler does not know
// anything about the type except its size.
#define _BYTE  uint8
#define _WORD  uint16
#define _DWORD uint32
#define _QWORD uint64
#if !defined(_MSC_VER)
#define _LONGLONG __int128
#endif

// Non-standard boolean types. They are used when the decompiler can not use
// the standard "bool" type because of the size mistmatch but the possible
// values are only 0 and 1. See also 'BOOL' type below.
typedef int8 _BOOL1;
typedef int16 _BOOL2;
typedef int32 _BOOL4;

//#ifndef _WINDOWS_
//typedef int8 BYTE;
//typedef int16 WORD;
//typedef int32 DWORD;
//typedef int32 LONG;
//typedef int BOOL;       // uppercase BOOL is usually 4 bytes
//#endif
//typedef int64 QWORD;
#ifndef __cplusplus
typedef int bool;       // we want to use bool in our C programs
#endif

#define __pure          // pure function: always returns the same value, has no
// side effects

// Non-returning function
#if defined(__GNUC__)
#define __noreturn  __attribute__((noreturn))
#else
#define __noreturn  __declspec(noreturn)
#endif


#ifndef NULL
#define NULL 0
#endif

// An ANSI character. 8-bit fixed-width representation of 7-bit characters.
typedef char				ANSICHAR;

// A wide character. In-memory only. ?-bit fixed-width representation of the platform's natural wide character set. Could be different sizes on different platforms.
typedef wchar_t				WIDECHAR;

// An 8-bit character type. In-memory only. 8-bit representation. Should really be char8_t but making this the generic option is easier for compilers which don't fully support C++11 yet (i.e. MSVC).
typedef uint8				CHAR8;

// A 16-bit character type. In-memory only.  16-bit representation. Should really be char16_t but making this the generic option is easier for compilers which don't fully support C++11 yet (i.e. MSVC).
typedef uint16				CHAR16;

// A 32-bit character type. In-memory only. 32-bit representation. Should really be char32_t but making this the generic option is easier for compilers which don't fully support C++11 yet (i.e. MSVC).
typedef uint32				CHAR32;

// A switchable character. In-memory only. Either ANSICHAR or WIDECHAR, depending on a licensee's requirements.
typedef WIDECHAR			TCHAR;
// Some convenience macros to make partial accesses nicer
#define LAST_IND(x,part_type)    (sizeof(x)/sizeof(part_type) - 1)
#if defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN
#  define LOW_IND(x,part_type)   LAST_IND(x,part_type)
#  define HIGH_IND(x,part_type)  0
#else
#  define HIGH_IND(x,part_type)  LAST_IND(x,part_type)
#  define LOW_IND(x,part_type)   0
#endif
// first unsigned macros:
//#define LODWORD(x)  (*((DWORD*)&(x)))  // low dword
//#define HIDWORD(x)  (*((DWORD*)&(x)+1))

#define BYTEn(x, n)   (*((_BYTE*)&(x)+n))
#define WORDn(x, n)   (*((_WORD*)&(x)+n))
#define DWORDn(x, n)  (*((_DWORD*)&(x)+n))

#define LOBYTE(x)  BYTEn(x,LOW_IND(x,_BYTE))
#define LOWORD(x)  WORDn(x,LOW_IND(x,_WORD))
#define LODWORD(x) DWORDn(x,LOW_IND(x,_DWORD))
#define HIBYTE(x)  BYTEn(x,HIGH_IND(x,_BYTE))
#define HIWORD(x)  WORDn(x,HIGH_IND(x,_WORD))
#define HIDWORD(x) DWORDn(x,HIGH_IND(x,_DWORD))
#define BYTE1(x)   BYTEn(x,  1)         // byte 1 (counting from 0)
#define BYTE2(x)   BYTEn(x,  2)
#define BYTE3(x)   BYTEn(x,  3)
#define BYTE4(x)   BYTEn(x,  4)
#define BYTE5(x)   BYTEn(x,  5)
#define BYTE6(x)   BYTEn(x,  6)
#define BYTE7(x)   BYTEn(x,  7)
#define BYTE8(x)   BYTEn(x,  8)
#define BYTE9(x)   BYTEn(x,  9)
#define BYTE10(x)  BYTEn(x, 10)
#define BYTE11(x)  BYTEn(x, 11)
#define BYTE12(x)  BYTEn(x, 12)
#define BYTE13(x)  BYTEn(x, 13)
#define BYTE14(x)  BYTEn(x, 14)
#define BYTE15(x)  BYTEn(x, 15)
#define WORD1(x)   WORDn(x,  1)
#define WORD2(x)   WORDn(x,  2)         // third word of the object, unsigned
#define WORD3(x)   WORDn(x,  3)
#define WORD4(x)   WORDn(x,  4)
#define WORD5(x)   WORDn(x,  5)
#define WORD6(x)   WORDn(x,  6)
#define WORD7(x)   WORDn(x,  7)

// now signed macros (the same but with sign extension)
#define SBYTEn(x, n)   (*((int8*)&(x)+n))
#define SWORDn(x, n)   (*((int16*)&(x)+n))
#define SDWORDn(x, n)  (*((int32*)&(x)+n))

#define SLOBYTE(x)  SBYTEn(x,LOW_IND(x,int8))
#define SLOWORD(x)  SWORDn(x,LOW_IND(x,int16))
#define SLODWORD(x) SDWORDn(x,LOW_IND(x,int32))
#define SHIBYTE(x)  SBYTEn(x,HIGH_IND(x,int8))
#define SHIWORD(x)  SWORDn(x,HIGH_IND(x,int16))
#define SHIDWORD(x) SDWORDn(x,HIGH_IND(x,int32))
#define SBYTE1(x)   SBYTEn(x,  1)
#define SBYTE2(x)   SBYTEn(x,  2)
#define SBYTE3(x)   SBYTEn(x,  3)
#define SBYTE4(x)   SBYTEn(x,  4)
#define SBYTE5(x)   SBYTEn(x,  5)
#define SBYTE6(x)   SBYTEn(x,  6)
#define SBYTE7(x)   SBYTEn(x,  7)
#define SBYTE8(x)   SBYTEn(x,  8)
#define SBYTE9(x)   SBYTEn(x,  9)
#define SBYTE10(x)  SBYTEn(x, 10)
#define SBYTE11(x)  SBYTEn(x, 11)
#define SBYTE12(x)  SBYTEn(x, 12)
#define SBYTE13(x)  SBYTEn(x, 13)
#define SBYTE14(x)  SBYTEn(x, 14)
#define SBYTE15(x)  SBYTEn(x, 15)
#define SWORD1(x)   SWORDn(x,  1)
#define SWORD2(x)   SWORDn(x,  2)
#define SWORD3(x)   SWORDn(x,  3)
#define SWORD4(x)   SWORDn(x,  4)
#define SWORD5(x)   SWORDn(x,  5)
#define SWORD6(x)   SWORDn(x,  6)
#define SWORD7(x)   SWORDn(x,  7)


// Helper functions to represent some assembly instructions.

#ifdef __cplusplus

// compile time assertion
#define __CASSERT_N0__(l) COMPILE_TIME_ASSERT_ ## l
#define __CASSERT_N1__(l) __CASSERT_N0__(l)
#define CASSERT(cnd) typedef char __CASSERT_N1__(__LINE__) [(cnd) ? 1 : -1]

// check that unsigned multiplication does not overflow
template<class T> bool is_mul_ok(T count, T elsize)
{
	CASSERT((T)(-1) > 0); // make sure T is unsigned
	if (elsize == 0 || count == 0)
		return true;
	return count <= ((T)(-1)) / elsize;
}

// multiplication that saturates (yields the biggest value) instead of overflowing
// such a construct is useful in "operator new[]"
template<class T> bool saturated_mul(T count, T elsize)
{
	return is_mul_ok(count, elsize) ? count * elsize : T(-1);
}

#include <stddef.h> // for size_t
#include <cstdint>

// memcpy() with determined behavoir: it always copies
// from the start to the end of the buffer
// note: it copies byte by byte, so it is not equivalent to, for example, rep movsd
inline void* qmemcpy(void* dst, const void* src, size_t cnt)
{
	char* out = (char*)dst;
	const char* in = (const char*)src;
	while (cnt > 0)
	{
		*out++ = *in++;
		--cnt;
	}
	return dst;
}

// Generate a reference to pair of operands
template<class T>  int16 __PAIR__(int8  high, T low) { return (((int16)high) << sizeof(high) * 8) | uint8(low); }
template<class T>  int32 __PAIR__(int16 high, T low) { return (((int32)high) << sizeof(high) * 8) | uint16(low); }
template<class T>  int64 __PAIR__(int32 high, T low) { return (((int64)high) << sizeof(high) * 8) | uint32(low); }
template<class T> uint16 __PAIR__(uint8  high, T low) { return (((uint16)high) << sizeof(high) * 8) | uint8(low); }
template<class T> uint32 __PAIR__(uint16 high, T low) { return (((uint32)high) << sizeof(high) * 8) | uint16(low); }
template<class T> uint64 __PAIR__(uint32 high, T low) { return (((uint64)high) << sizeof(high) * 8) | uint32(low); }

// rotate left
template<class T> T __ROL__(T value, int count)
{
	const uint nbits = sizeof(T) * 8;

	if (count > 0)
	{
		count %= nbits;
		T high = value >> (nbits - count);
		if (T(-1) < 0)
			high &= ~((T(-1) << count));
		value <<= count;
		value |= high;
	}
	else
	{
		count = -count % nbits;
		T low = value << (nbits - count);
		value >>= count;
		value |= low;
	}
	return value;
}

inline uint8  __ROL1__(uint8  value, int count) { return __ROL__((uint8)value, count); }
inline uint16 __ROL2__(uint16 value, int count) { return __ROL__((uint16)value, count); }
inline uint32 __ROL4__(uint32 value, int count) { return __ROL__((uint32)value, count); }
inline uint64 __ROL8__(uint64 value, int count) { return __ROL__((uint64)value, count); }
inline uint8  __ROR1__(uint8  value, int count) { return __ROL__((uint8)value, -count); }
inline uint16 __ROR2__(uint16 value, int count) { return __ROL__((uint16)value, -count); }
inline uint32 __ROR4__(uint32 value, int count) { return __ROL__((uint32)value, -count); }
inline uint64 __ROR8__(uint64 value, int count) { return __ROL__((uint64)value, -count); }

// carry flag of left shift
template<class T> int8 __MKCSHL__(T value, uint count)
{
	const uint nbits = sizeof(T) * 8;
	count %= nbits;

	return (value >> (nbits - count)) & 1;
}

// carry flag of right shift
template<class T> int8 __MKCSHR__(T value, uint count)
{
	return (value >> (count - 1)) & 1;
}

// sign flag
template<class T> int8 __SETS__(T x)
{
	if (sizeof(T) == 1)
		return int8(x) < 0;
	if (sizeof(T) == 2)
		return int16(x) < 0;
	if (sizeof(T) == 4)
		return int32(x) < 0;
	return int64(x) < 0;
}

// overflow flag of subtraction (x-y)
template<class T, class U> int8 __OFSUB__(T x, U y)
{
	if (sizeof(T) < sizeof(U))
	{
		U x2 = x;
		int8 sx = __SETS__(x2);
		return (sx ^ __SETS__(y)) & (sx ^ __SETS__(x2 - y));
	}
	else
	{
		T y2 = y;
		int8 sx = __SETS__(x);
		return (sx ^ __SETS__(y2)) & (sx ^ __SETS__(x - y2));
	}
}

// overflow flag of addition (x+y)
template<class T, class U> int8 __OFADD__(T x, U y)
{
	if (sizeof(T) < sizeof(U))
	{
		U x2 = x;
		int8 sx = __SETS__(x2);
		return ((1 ^ sx) ^ __SETS__(y)) & (sx ^ __SETS__(x2 + y));
	}
	else
	{
		T y2 = y;
		int8 sx = __SETS__(x);
		return ((1 ^ sx) ^ __SETS__(y2)) & (sx ^ __SETS__(x + y2));
	}
}

// carry flag of subtraction (x-y)
template<class T, class U> int8 __CFSUB__(T x, U y)
{
	int size = sizeof(T) > sizeof(U) ? sizeof(T) : sizeof(U);
	if (size == 1)
		return uint8(x) < uint8(y);
	if (size == 2)
		return uint16(x) < uint16(y);
	if (size == 4)
		return uint32(x) < uint32(y);
	return uint64(x) < uint64(y);
}

// carry flag of addition (x+y)
template<class T, class U> int8 __CFADD__(T x, U y)
{
	int size = sizeof(T) > sizeof(U) ? sizeof(T) : sizeof(U);
	if (size == 1)
		return uint8(x) > uint8(x + y);
	if (size == 2)
		return uint16(x) > uint16(x + y);
	if (size == 4)
		return uint32(x) > uint32(x + y);
	return uint64(x) > uint64(x + y);
}



#else
// The following definition is not quite correct because it always returns
// uint64. The above C++ functions are good, though.
#define __PAIR__(high, low) (((uint64)(high)<<sizeof(high)*8) | low)
// For C, we just provide macros, they are not quite correct.
#define __ROL__(x, y) __rotl__(x, y)      // Rotate left
#define __ROR__(x, y) __rotr__(x, y)      // Rotate right
#define __CFSHL__(x, y) invalid_operation // Generate carry flag for (x<<y)
#define __CFSHR__(x, y) invalid_operation // Generate carry flag for (x>>y)
#define __CFADD__(x, y) invalid_operation // Generate carry flag for (x+y)
#define __CFSUB__(x, y) invalid_operation // Generate carry flag for (x-y)
#define __OFADD__(x, y) invalid_operation // Generate overflow flag for (x+y)
#define __OFSUB__(x, y) invalid_operation // Generate overflow flag for (x-y)
#endif

// No definition for rcl/rcr because the carry flag is unknown
#define __RCL__(x, y)    invalid_operation // Rotate left thru carry
#define __RCR__(x, y)    invalid_operation // Rotate right thru carry
#define __MKCRCL__(x, y) invalid_operation // Generate carry flag for a RCL
#define __MKCRCR__(x, y) invalid_operation // Generate carry flag for a RCR
#define __SETP__(x, y)   invalid_operation // Generate parity flag for (x-y)

// In the decompilation listing there are some objects declarared as _UNKNOWN
// because we could not determine their types. Since the C compiler does not
// accept void item declarations, we replace them by anything of our choice,
// for example a char:

#define _UNKNOWN char

//#ifdef _MSC_VER
//#define snprintf _snprintf
//#define vsnprintf _vsnprintf
//#endif
struct State {
	uintptr_t keys[7];
};
namespace Decryption
{

	__forceinline __int64 Decrypt_UWorld(const uint32_t key, const uintptr_t* state)
	{

		unsigned __int64 v19; // r11
		unsigned __int64 v20; // r8
		unsigned __int64 v21; // r9
		unsigned int v22; // er10
		unsigned __int64 v23; // rcx
		unsigned __int64 v24; // rdx
		unsigned __int64 v25; // rcx
		int v26; // ebx
		unsigned int v27; // ecx
		__int64 v28; // rax
		unsigned __int64 v29; // r8
		unsigned __int64 v30; // r8
		unsigned __int64 v31; // rcx
		unsigned __int64 v32; // rdx
		unsigned __int64 v33; // rcx

		v19 = 2685821657736338717i64
			* ((unsigned int)key ^ (unsigned int)(key << 25) ^ (((unsigned int)key ^ ((unsigned __int64)(unsigned int)key >> 15)) >> 12))
			% 7;
		v20 = state[v19];
		v21 = (2685821657736338717i64
			* ((unsigned int)key ^ (unsigned int)(key << 25) ^ (((unsigned int)key ^ ((unsigned __int64)(unsigned int)key >> 15)) >> 12))) >> 32;
		v22 = (unsigned int)v19 % 7;
		if (!((unsigned int)v19 % 7))
		{
			v23 = (2 * (v20 - (unsigned int)(v21 - 1))) ^ ((2 * (v20 - (unsigned int)(v21 - 1))) ^ ((v20
				- (unsigned int)(v21 - 1)) >> 1)) & 0x5555555555555555i64;
			v24 = (4 * v23) ^ ((4 * v23) ^ (v23 >> 2)) & 0x3333333333333333i64;
			v25 = (16 * v24) ^ ((16 * v24) ^ (v24 >> 4)) & 0xF0F0F0F0F0F0F0Fi64;
			v20 = __ROL8__((v25 << 8) ^ ((v25 << 8) ^ (v25 >> 8)) & 0xFF00FF00FF00FFi64, 32);
		LABEL_26:
			v26 = 2 * v19;
			goto LABEL_27;
		}
		if (v22 != 1)
			goto LABEL_26;
		v26 = 2 * v19;
		v20 = __ROL8__(v20 - (unsigned int)(2 * v19 + v21), (unsigned __int8)(((int)v21 + (int)v19) % 0x3Fu) + 1);
	LABEL_27:
		v27 = v26 + v21;
		if (v22 == 2)
			v20 = ~(v20 - v27);
		switch (v22)
		{
		case 3u:
			v28 = 2 * ((2 * v20) ^ ((2 * v20) ^ (v20 >> 1)) & 0x5555555555555555i64);
			v20 = v28 ^ (v28 ^ (((2 * v20) ^ ((2 * v20) ^ (v20 >> 1)) & 0x5555555555555555i64) >> 1)) & 0x5555555555555555i64;
			break;
		case 4u:
			v29 = __ROR8__(v20, (unsigned __int8)(v27 % 0x3F) + 1);
			v20 = (2 * v29) ^ ((2 * v29) ^ (v29 >> 1)) & 0x5555555555555555i64;
			break;
		case 5u:
			v30 = __ROR8__(v20, (unsigned __int8)(v27 % 0x3F) + 1);
			v31 = (2 * v30) ^ ((2 * v30) ^ (v30 >> 1)) & 0x5555555555555555i64;
			v32 = (4 * v31) ^ ((4 * v31) ^ (v31 >> 2)) & 0x3333333333333333i64;
			v33 = (16 * v32) ^ ((16 * v32) ^ (v32 >> 4)) & 0xF0F0F0F0F0F0F0Fi64;
			v20 = __ROL8__((v33 << 8) ^ ((v33 << 8) ^ (v33 >> 8)) & 0xFF00FF00FF00FFi64, 32);
			break;
		case 6u:
			v20 = ~v20 - (unsigned int)(v21 + v19);
			break;
		}
		return v20 ^ (unsigned int)key;
	}

}
#endif
```

`discord_rpc.h`:

```h
#pragma once
#include <stdint.h>

// clang-format off

#if defined(DISCORD_DYNAMIC_LIB)
#  if defined(_WIN32)
#    if defined(DISCORD_BUILDING_SDK)
#      define DISCORD_EXPORT __declspec(dllexport)
#    else
#      define DISCORD_EXPORT __declspec(dllimport)
#    endif
#  else
#    define DISCORD_EXPORT __attribute__((visibility("default")))
#  endif
#else
#  define DISCORD_EXPORT
#endif

// clang-format on

#ifdef __cplusplus
extern "C" {
#endif

    typedef struct DiscordRichPresence {
        const char* state;   /* max 128 bytes */
        const char* details; /* max 128 bytes */
        int64_t startTimestamp;
        int64_t endTimestamp;
        const char* largeImageKey;  /* max 32 bytes */
        const char* largeImageText; /* max 128 bytes */
        const char* smallImageKey;  /* max 32 bytes */
        const char* smallImageText; /* max 128 bytes */
        const char* partyId;        /* max 128 bytes */
        int partySize;
        int partyMax;
        const char* matchSecret;    /* max 128 bytes */
        const char* joinSecret;     /* max 128 bytes */
        const char* spectateSecret; /* max 128 bytes */
        int8_t instance;
    } DiscordRichPresence;

    typedef struct DiscordJoinRequest {
        const char* userId;
        const char* username;
        const char* discriminator;
        const char* avatar;
    } DiscordJoinRequest;

    typedef struct DiscordEventHandlers {
        void (*ready)(void);
        void (*disconnected)(int errorCode, const char* message);
        void (*errored)(int errorCode, const char* message);
        void (*joinGame)(const char* joinSecret);
        void (*spectateGame)(const char* spectateSecret);
        void (*joinRequest)(const DiscordJoinRequest* request);
    } DiscordEventHandlers;

#define DISCORD_REPLY_NO 0
#define DISCORD_REPLY_YES 1
#define DISCORD_REPLY_IGNORE 2

    DISCORD_EXPORT void Discord_Initialize(const char* applicationId,
        DiscordEventHandlers* handlers,
        int autoRegister,
        const char* optionalSteamId);
    DISCORD_EXPORT void Discord_Shutdown(void);

    /* checks for incoming messages, dispatches callbacks */
    DISCORD_EXPORT void Discord_RunCallbacks(void);

    /* If you disable the lib starting its own io thread, you'll need to call this from your own */
#ifdef DISCORD_DISABLE_IO_THREAD
    DISCORD_EXPORT void Discord_UpdateConnection(void);
#endif

    DISCORD_EXPORT void Discord_UpdatePresence(const DiscordRichPresence* presence);
    DISCORD_EXPORT void Discord_ClearPresence(void);

    DISCORD_EXPORT void Discord_Respond(const char* userid, /* DISCORD_REPLY_ */ int reply);

#ifdef __cplusplus
} /* extern "C" */
#endif

```

`hook.h`:

```h
#pragma once
#include <cstdint>
namespace Hook
{
	void VMT(void* addr, void* pDes, int index, void** ret)
	{
		auto vtable = *(uintptr_t**)addr;
		int methods = 0;
		do {
			++methods;
		} while (*(uintptr_t*)((uintptr_t)vtable + (methods * 0x8)));
		auto vtable_buf = new uint64_t[methods * 0x8];
		for (auto count = 0; count < methods; ++count) {
			vtable_buf[count] = *(uintptr_t*)((uintptr_t)vtable + (count * 0x8));

			*ret = (void*)vtable[index];

			vtable_buf[index] = (uintptr_t)(pDes);
			*(uint64_t**)addr = vtable_buf;
		}
	}

	void vhook(void* addr, void* pDes, int index, void** ret) {
		auto vtable = Memory::ReadStub<uintptr_t*>(std::uintptr_t(addr));
		int methods = 0;

		for (int i = 0; Memory::ReadStub<uintptr_t>((uintptr_t)vtable + (i * 0x8)); i++) methods++;

		auto vtable_buf = new uint64_t[methods * 0x8];
		for (int count = 0; count < methods; ++count) {
			vtable_buf[count] = Memory::ReadStub<uintptr_t>((uintptr_t)vtable + (count * 0x8));

			*ret = (void*)vtable[index];

			vtable_buf[index] = (uintptr_t)(pDes);
			*(uint64_t**)(std::uintptr_t(addr)) = vtable_buf;
			//memory::write<uint64_t*>(std::uintptr_t(addr), vtable_buf);
		}
	}
}
```

`internal.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Entry.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Yeni klasör\MyDll\HOKI.h" />
    <ClInclude Include="Alignments.h" />
    <ClInclude Include="decryption.h" />
    <ClInclude Include="Decryptor.h" />
    <ClInclude Include="discord_rpc.h" />
    <ClInclude Include="hook.h" />
    <ClInclude Include="memory.h" />
    <ClInclude Include="offsets.h" />
    <ClInclude Include="Canvas.h" />
    <ClInclude Include="unrealengine.h" />
    <ClInclude Include="valorant.h" />
  </ItemGroup>
  <ItemGroup>
    <Library Include="discord-rpc.lib" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{1998d631-50f0-4719-ba07-feb48a9ed452}</ProjectGuid>
    <RootNamespace>internalforuglypasters</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.22000.0</WindowsTargetPlatformVersion>
    <ProjectName>StaffBesting</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <TargetName>StaffBesting</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;INTERNALFORUGLYPASTERS_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;INTERNALFORUGLYPASTERS_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;INTERNALFORUGLYPASTERS_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;INTERNALFORUGLYPASTERS_EXPORTS;_WINDOWS;_USRDLL;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <PrecompiledHeaderFile />
      <PrecompiledHeaderOutputFile />
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`internal.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="Entry.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="decryption.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="hook.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="memory.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="offsets.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="Canvas.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="unrealengine.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="valorant.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="Alignments.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="Decryptor.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="..\Yeni klasör\MyDll\HOKI.h">
      <Filter>Headers</Filter>
    </ClInclude>
    <ClInclude Include="discord_rpc.h">
      <Filter>Headers</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Headers">
      <UniqueIdentifier>{0ff10ebb-01d8-4b4e-9e0a-b32145221c23}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Library Include="discord-rpc.lib">
      <Filter>Headers</Filter>
    </Library>
  </ItemGroup>
</Project>
```

`internal.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`memory.h`:

```h
#pragma once
#include <cstdint>
#include "offsets.h"
#include "valorant.h"
namespace Memory
{
	template <typename T>
	T ReadStub(std::uintptr_t Address)
	{
		return reinterpret_cast<T(*)(std::uintptr_t)>(VALORANT::Module + Offsets::TriggerVEH)(Address - 0x8);
	}
	template <typename T>
	void WriteStub(std::uintptr_t Address, T other)
	{
		*(T*)(Address) = other;
		//reinterpret_cast<T(*)(std::uintptr_t)>(VALORANT::Module + Offsets::TriggerVEH)(Address - 0x8 + other);
	}
}
```

`offsets.h`:

```h
#pragma once
namespace Offsets
{
	constexpr auto
        State = 0x8C38CC0, //uworld_state
        Key = State + 0x38,//stade + key
        relative_rotation = 0x170,
        ProcessEvent = 0x3366f10,
        StaticFindObject = 0x337b4d0,
        gobj_state = 0x8ABAA80,
		gobj_key = gobj_state + 0x38,
        Pointer = 0x80,
        SkinChanger = 0x23A1460,
        StaticLoadObject = 0x337bf80,
        TriggerVEH = 0x1a89ed0,//pakman offset
        bone_matrix = 0x4a70a70,
        PlayerCameraManager = 0x478,//aPlayerCameraManager 
        ChamsOffset = 0x1190,
        portrait_map = 0x1120, //UCharacterPortraitMinimapComponent_C
        character_map = portrait_map + 0x8, // UCharacterCharacterMinimapComponent_C
        Inventory = 0x950,  //struct UAresInventory* Inventory; 
        get_spread_values_fn = 0x237fb30,//Needs new offset
        get_spread_angles_fn = 0x2a4fed0,//Needs new offset
        get_firing_location_and_direction_fn = 0x288d9a0,//Needs new offset
        to_vector_and_normalize_fn = 0x309f290,//Needs new offset
        to_angle_and_normalize_fn = 0x3098ff0,//Needs new offset
		FiringStateComp = 0x1010,
		StabilityComponent = 0x418,
        CurrentEquippable = 0x238;  //struct AAresEquippable* CurrentEquippable;
}

```

`sdk.h`:

```h
#pragma once
#include "memory.h"
#include "unrealengine.h"
class UObject
{
public:
	char padding_01[0x18];
	int32_t ComparisonIndex;
	static UObject* StaticFindObject(UObject* Class, UObject* InOuter, const wchar_t* Name, bool ExactClass)
	{
		static uintptr_t StaticFindObjectAddress = VALORANT::Module + Offsets::StaticFindObject;

		auto StaticFindObjectFN = reinterpret_cast<UObject * (__fastcall*)(UObject*, UObject*, const wchar_t*, bool)>(StaticFindObjectAddress);

		return StaticFindObjectFN(Class, InOuter, Name, ExactClass);
	}
	static void ProcessEvent(void* class_, UObject* function, void* params)
	{
		reinterpret_cast<void (*)(void*, UObject*, void*)>(VALORANT::Module + Offsets::ProcessEvent)(class_, function, params);
	}
};

struct UWorld
{

};

struct UFont : UObject
{

};

UObject* DefaultMediumFont;
struct UEngine
{

};
bool bOutline = 1;
struct UCanvas
{
	void K2_DrawLine(struct FVector2D ScreenPositionA, struct FVector2D ScreenPositionB, float Thickness, struct FLinearColor RenderColor)
	{
		UObject* function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Canvas.K2_DrawLine", false);


		struct {
			FVector2D ScreenPositionA;
			FVector2D ScreenPositionB;
			float Thickness;
			FLinearColor RenderColor;
		}Args;
		Args.ScreenPositionA = ScreenPositionA;
		Args.ScreenPositionB = ScreenPositionB;
		Args.Thickness = Thickness;
		Args.RenderColor = RenderColor; 
		function->ProcessEvent(this, function, &Args);
	}
	void K2_DrawLinex(FVector2D ScreenPositionA, FVector2D ScreenPositionB, float Thickness, FLinearColor RenderColor) // CRT af doe (ironic.)
	{
		if(bOutline)
		{
			K2_DrawLine({ ScreenPositionA.X + 1, ScreenPositionA.Y }, { ScreenPositionB.X, ScreenPositionB.Y }, Thickness, { 0.0f,0.0f,0.0f,1.0f });
			K2_DrawLine({ ScreenPositionA.X - 1, ScreenPositionA.Y }, { ScreenPositionB.X, ScreenPositionB.Y }, Thickness, { 0.0f,0.0f,0.0f,1.0f });
			K2_DrawLine({ ScreenPositionA.X, ScreenPositionA.Y + 1 }, { ScreenPositionB.X, ScreenPositionB.Y }, Thickness, { 0.0f,0.0f,0.0f,1.0f });
			K2_DrawLine({ ScreenPositionA.X, ScreenPositionA.Y - 1 }, { ScreenPositionB.X, ScreenPositionB.Y }, Thickness, { 0.0f,0.0f,0.0f,1.0f });
		}
		K2_DrawLine({ ScreenPositionA.X, ScreenPositionA.Y }, { ScreenPositionB.X, ScreenPositionB.Y }, Thickness, RenderColor);
	}
	void K2_DrawText(struct FString RenderText, struct FVector2D ScreenPosition, struct FVector2D Scale, struct FLinearColor RenderColor, float Kerning, struct FLinearColor ShadowColor, struct FVector2D ShadowOffset, bool bCentreX, bool bCentreY, bool bOutlined, struct FLinearColor OutlineColor)
	{
		UObject* function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Canvas.K2_DrawText", false);
		if(!DefaultMediumFont) 
			DefaultMediumFont = UObject::StaticFindObject(nullptr, nullptr, L"/Engine/EngineFonts/Roboto.Roboto", false);
		struct {
			UObject* RenderFont;
			FString RenderText;
			FVector2D ScreenPosition;
			FVector2D Scale;
			FLinearColor RenderColor;
			float Kerning;
			FLinearColor ShadowColor;
			FVector2D ShadowOffset;
			bool bCentreX;
			bool bCentreY;
			bool bOutlined;
			FLinearColor OutlineColor;
		}Args;
		Args.RenderFont = DefaultMediumFont;
		Args.RenderText = RenderText;
		Args.ScreenPosition = ScreenPosition;
		Args.Scale = Scale;
		Args.RenderColor = RenderColor;
		Args.Kerning = Kerning;
		Args.ShadowColor = ShadowColor;
		Args.ShadowOffset = ShadowOffset;
		Args.bCentreX = bCentreX;
		Args.bCentreY = bCentreY;
		Args.bOutlined = bOutlined;
		Args.OutlineColor = OutlineColor; 
		function->ProcessEvent(this, function, &Args);
	}
};

struct UGameInstance
{

};

struct ULocalPlayer
{

};

struct FBoxSphereBounds {
	FVector Origin;
	FVector BoxExtent;
	float SphereRadius;
};

struct FBox {
	FVector Min;
	FVector Max;

	FBox() {

		Min.X = NULL;
		Min.Y = NULL;
		Min.Z = NULL;
		
		Max.X = NULL;
		Max.Y = NULL;
		Max.Z = NULL;
	}
};

struct UStaticMeshComponent
{
	FBox GetBoundingBox()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.StaticMesh.GetBoundingBox", false);
		if (!Function)
		{
			return FBox();
		}
		struct
		{
			FBox ReturnValue;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.ReturnValue;
	}
};

struct USkeletalMeshComponent
{

	void SetAresOutlineMode(EAresOutlineMode Mode, bool bPropagateToChildren)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.MeshComponent.SetAresOutlineMode", false);
		if (!Function)
		{
			return;
		}
		struct
		{
			EAresOutlineMode Mode;
			bool bPropagateToChildren;
		}Parameters;
		Parameters.Mode = Mode;
		Parameters.bPropagateToChildren = bPropagateToChildren;
		Function->ProcessEvent(this, Function, &Parameters);
	}
};

DWORD64 ProjectWorldToScreen;

struct APlayerState
{
	FString GetPlayerName()
	{
		UObject* function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.PlayerState.GetPlayerName", false);
		if (!function)
			return L"AAresPlayerCharacter_PC_C";

		struct {
			FString Return;
		}Args;
		function->ProcessEvent(this, function, &Args);
		return Args.Return;
	}
};


struct FQuat
{
public:

	float X, Y, Z, W;

	FQuat() : X(0.f), Y(0.f), Z(0.f), W(0.f) {};

	FQuat(float InX, float InY, float InZ, float InW) : X(InX), Y(InY), Z(InZ), W(InW) {}

	FQuat(struct FRotator& R);

	FVector RotateVector(const struct FVector& V) const;
};
struct FRotator
{
	float Pitch, Yaw, Roll;

	FRotator()
		: Pitch(0), Yaw(0), Roll(0)
	{ }

	FRotator(float pitch, float yaw, float roll) : Pitch(pitch), Yaw(yaw), Roll(roll) {}

	FRotator operator+ (const FRotator& other) const { return FRotator(Pitch + other.Pitch, Yaw + other.Yaw, Roll + other.Roll); }

	FRotator operator- (const FRotator& other) const { return FRotator(Pitch - other.Pitch, Yaw - other.Yaw, Roll - other.Roll); }

	FRotator operator* (float scalar) const { return FRotator(Pitch * scalar, Yaw * scalar, Roll * scalar); }

	FRotator& operator=  (const FRotator& other) { Pitch = other.Pitch; Yaw = other.Yaw; Roll = other.Roll; return *this; }

	FRotator& operator+= (const FRotator& other) { Pitch += other.Pitch; Yaw += other.Yaw; Roll += other.Roll; return *this; }

	FRotator& operator-= (const FRotator& other) { Pitch -= other.Pitch; Yaw -= other.Yaw; Roll -= other.Roll; return *this; }

	FRotator& operator*= (const float other) { Yaw *= other; Pitch *= other; Roll *= other; return *this; }

	struct FQuat Quaternion() const;
};

constexpr auto PI = 3.1415926535897932f;
constexpr auto FLOAT_NON_FRACTIONAL = 8388608.f /* All single-precision floating point numbers greater than or equal to this have no fractional value. */;
constexpr auto INV_PI = 0.31830988618f;
constexpr auto HALF_PI = 1.57079632679f;
constexpr auto DEG_TO_RAD = PI / 180.f;
constexpr auto RADS_DIVIDED_BY_2 = DEG_TO_RAD / 2.f;

namespace classes {
	namespace defines {
		static UObject* system = nullptr;
		static UObject* game_statics = nullptr;
		static UObject* blueprint = nullptr;
		static UObject* content_library = nullptr;
	}

	static inline void init() {
		defines::system = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Default__KismetSystemLibrary", false);
		defines::game_statics = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Default__GameplayStatics", false);
		defines::blueprint = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.Default__ShooterBlueprintLibrary", false);
		defines::content_library = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.Default__ContentLibrary", false);
	}
}

namespace kismentsystemlibrary
{
	UObject* static_class()
	{
		return UObject::StaticFindObject(nullptr, nullptr, L"Engine.Default__KismetSystemLibrary", false);
	}

	FString get_object_name(UObject* obj)
	{
		UObject* functions = UObject::StaticFindObject(nullptr, nullptr, L"Engine.KismentSystemLibrary.GetObjectName", false);
		if (!functions)
			return L"N/A";
		struct
		{
			UObject* obj;
			FString out;
		}Args;
		Args.obj = obj;
		functions->ProcessEvent(static_class(), functions, &Args);
		return Args.out;
	}
}
struct FMath {
	static __forceinline void SinCos(float* ScalarSin, float* ScalarCos, float  Value);
	static __forceinline float Fmod(float X, float Y);
	template<class T>
	static __forceinline T Clamp(const T X, const T Min, const T Max) { return X < Min ? Min : X < Max ? X : Max; }
};

struct FTransform
{
	FQuat Rotation;
	FVector Translation;
	char UnknownData00[0x4];
	FVector Scale3D;
	char UnknownData01[0x4];

	/** Default constructor. */
	FTransform() : Rotation(0.f, 0.f, 0.f, 1.f), Translation(0.f), Scale3D(FVector::OneVector) {};
	 
	FVector TransformPosition(FVector& V) const;

	FTransform(const FRotator& InRotation) : Rotation(InRotation.Quaternion()), Translation(FVector::ZeroVector), Scale3D(FVector::OneVector) {};
};


struct AShooterCharacter : UObject
{
	void ClientFly()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.ClientFly", false);
		if (!Function)
		{
			return;
		}
		struct
		{
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return;
	}
	void Set3pMeshVisible(bool val)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.Set3PMeshVisible", false);
		if (!Function)
		{
			return;
		}
		struct
		{
			bool a1;
		}Parameters;
		Parameters.a1 = val;
		Function->ProcessEvent(this, Function, &Parameters);
		return;
	}
	APlayerState* GetPlayerState()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetPlayerState", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			APlayerState* Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}

	int32_t GetMaxHealth()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetMaxHealth", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			int32_t Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	float GetHealth()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetHealth", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			float Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	FVector K2_GetActorLocation()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Actor.K2_GetActorLocation", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			FVector Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	FRotator K2_GetActorRotation()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Actor.K2_GetActorRotation", false);
		if (!Function)
		{
			return {0,0,0};
		}
		struct
		{
			FRotator Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	USkeletalMeshComponent* GetPawnMesh()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetPawnMesh", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			USkeletalMeshComponent* Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}

	APlayerState* GetState()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.GetPlayerState", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			APlayerState* KekState;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.KekState;
	}
	bool IsAlive()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterCharacter.IsAlive", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			bool Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
};

struct APlayerCameraManager
{
	FVector GetCameraLocation()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.PlayerCameraManager.GetCameraLocation", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			FVector Out;
		}Parameters; 
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
};
struct APlayerController : UObject
{
	bool LineOfSightTo(AShooterCharacter* Actor, FVector ViewPoint, bool bAlternateChecks)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Controller.LineOfSightTo", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			AShooterCharacter* Actor;
			FVector ViewPoint;
			bool bAlternateChecks;
			bool Out;
		}Parameters;
		Parameters.Actor = Actor;
		Parameters.ViewPoint = ViewPoint;
		Parameters.bAlternateChecks = bAlternateChecks;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
	void ExecSetCameraRotator(FRotator NewRot)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Engine.Controller.SetControlRotation", false);
		if (!Function)
		{
			return;
		}
		struct
		{
			FRotator Rot;
		}Parameters;
		Parameters.Rot = NewRot;
		Function->ProcessEvent(this, Function, &Parameters);
		return;
	}
	bool ProjectWorldLocationToScreen(struct FVector WorldLocation, struct FVector2D& ScreenLocation, bool bPlayerViewportRelative)
	{  
		if (!ProjectWorldToScreen)
			ProjectWorldToScreen = (uintptr_t)GetModuleHandleA(0) + 0x4fd7c60;
		auto WorldToScreen = reinterpret_cast<bool(__fastcall*)(uintptr_t pPlayerController, FVector vWorldPos, FVector2D * vScreenPosOut, char)>(ProjectWorldToScreen);

		WorldToScreen((uintptr_t)this, WorldLocation, &ScreenLocation, (char)0);
		 
		return WorldToScreen;
	}
	void set_fov(float fov)
	{
		UObject* function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.AresPlayerController.SetFOV", false);


		struct {
			float fov;
		}Args;
		Args.fov = fov;
		function->ProcessEvent(this, function, &Args);
	}

	AShooterCharacter* GetShooterCharacter()
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.AresPlayerController.GetShooterCharacter", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			AShooterCharacter* Out;
		}Parameters;
		Function->ProcessEvent(this, Function, &Parameters);
		return Parameters.Out;
	}
};

struct AController
{
};
namespace ShooterGameBlueprints
{
	UObject* Static_Class()
	{
		return UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.Default__ShooterBlueprintLibrary", false);
	}

	APlayerController* GetFirstLocalPlayerController(UWorld* WorldContextObject)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterBlueprintLibrary.GetFirstLocalPlayerController", false);
		if (!Function)
		{
			return 0;
		}
		struct
		{
			UWorld* WorldContextObject;
			APlayerController* Out;
		}Parameters;
		Parameters.WorldContextObject = WorldContextObject;
		Function->ProcessEvent(Static_Class(), Function, &Parameters);
		return Parameters.Out;
	}
	TArray<AShooterCharacter*> FindAllShooterCharactersWithAlliance(UWorld* WorldContextObject, AShooterCharacter* LocalViewer, EAresAlliance Alliance, bool OnlyPlayerControlled, bool OnlyAlivePlayers)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.ShooterBlueprintLibrary.FindAllShooterCharactersWithAlliance", false);
		struct
		{
			UWorld* WorldContextObject;
			AShooterCharacter* LocalViewer;
			EAresAlliance Alliance;
			bool OnlyPlayerControlled;
			bool OnlyAlivePlayers;
			TArray<AShooterCharacter*> Out;
		}Parameters;
		Parameters.WorldContextObject = WorldContextObject;
		Parameters.LocalViewer = LocalViewer;
		Parameters.Alliance = Alliance;
		Parameters.OnlyPlayerControlled = OnlyPlayerControlled;
		Parameters.OnlyAlivePlayers = OnlyAlivePlayers;
		Function->ProcessEvent(Static_Class(), Function, &Parameters);
		return Parameters.Out;
	}
}

namespace AresOutlineRendering
{
	UObject* Static_Class()
	{
		return UObject::StaticFindObject(nullptr, nullptr, L"Renderer.Default__AresOutlineRendering", false);
	}

	void SetOutlineColorsForRender(UWorld* WorldContextObject, FLinearColor AllyColor, FLinearColor EnemyColor)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"Renderer.AresOutlineRendering.SetOutlineColorsForRender", false);
		if (!Function)
		{
			return;
		}
		struct {
			UWorld* WorldContextObject;
			FLinearColor AllyColor;
			FLinearColor EnemyColor;
		}Parameters;
		Parameters.WorldContextObject = WorldContextObject;
		Parameters.AllyColor = AllyColor;
		Parameters.EnemyColor = EnemyColor;
		Function->ProcessEvent(Static_Class(), Function, &Parameters);
	}
}

namespace BaseTeamComponent
{
	UObject* Static_Class()
	{
		return UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.Default__BaseTeamComponent", false);
	}

	bool IsAlly(AShooterCharacter* Enemy, AShooterCharacter* Self)
	{
		UObject* Function = UObject::StaticFindObject(nullptr, nullptr, L"ShooterGame.BaseTeamComponent.IsAlly", false);
		struct {
			AShooterCharacter* Enemy;
			AShooterCharacter* Self;
			bool ReturnValue;
		}Parameters;
		Parameters.Enemy = Enemy;
		Parameters.Self = Self;
		Function->ProcessEvent(Static_Class(), Function, &Parameters);
		return Parameters.ReturnValue;
	}
}
#pragma once
#include <Windows.h>

namespace CWINGui
{
	namespace Input
	{
		bool mouseDown[5];
		bool mouseDownAlready[256];

		bool keysDown[256];
		bool keysDownAlready[256];

		bool IsAnyMouseDown()
		{
			if (mouseDown[0]) return true;
			if (mouseDown[1]) return true;
			if (mouseDown[2]) return true;
			if (mouseDown[3]) return true;
			if (mouseDown[4]) return true;

			return false;
		}

		bool IsMouseClicked(int button, int element_id, bool repeat)
		{
			if (mouseDown[button])
			{
				if (!mouseDownAlready[element_id])
				{
					mouseDownAlready[element_id] = true;
					return true;
				}
				if (repeat)
					return true;
			}
			else
			{
				mouseDownAlready[element_id] = false;
			}
			return false;
		}
		bool IsKeyPressed(int key, bool repeat)
		{
			if (keysDown[key])
			{
				if (!keysDownAlready[key])
				{
					keysDownAlready[key] = true;
					return true;
				}
				if (repeat)
					return true;
			}
			else
			{
				keysDownAlready[key] = false;
			}
			return false;
		}

		void Handle()
		{
			if (GetAsyncKeyState(0x01))
				mouseDown[0] = true;
			else
				mouseDown[0] = false;
		}
	}
}

wchar_t* s2wc(const char* c)
{
	const size_t cSize = strlen(c) + 1;
	wchar_t* wc = new wchar_t[cSize];
	mbstowcs(wc, c, cSize);

	return wc;
}

namespace CWINGui
{
	FLinearColor RGBtoFLC69(float R, float G, float B, float A = 255)
	{
		return { R / 255, G / 255, B / 255, A / 255 };
	}
	namespace Colors
	{
		FLinearColor Text{ 1.0f, 1.0f, 1.0f, 1.0f };
		FLinearColor Text_Shadow{ 0.0f, 0.0f, 0.0f, 0.0f };
		FLinearColor Text_Outline{ 0.0f, 0.0f, 0.0f, 0.30f };

		FLinearColor Window_Background{ 0.009f, 0.009f, 0.009f, 1.0f };
		FLinearColor Window_Header{ 0.10f, 0.15f, 0.84f, 1.0f };

		FLinearColor Button_Idle{ 0.10f, 0.15f, 0.84f, 1.0f };
		FLinearColor Button_Hovered{ 0.15f, 0.20f, 0.89f, 1.0f };
		FLinearColor Button_Active{ 0.20f, 0.25f, 0.94f, 1.0f };

		FLinearColor Checkbox_Idle{ 0.0f,0.0f,0.0f,1.0f };
		FLinearColor Checkbox_Hovered{ 1.0f,1.0f,1.0f,1.0f };
		FLinearColor Checkbox_Enabled{ 1.0f,1.0f,1.0f,1.0f };

		FLinearColor Combobox_Idle{ 0.17f, 0.16f, 0.23f, 1.0f };
		FLinearColor Combobox_Hovered{ 0.17f, 0.16f, 0.23f, 1.0f };
		FLinearColor Combobox_Elements{ 0.239f, 0.42f, 0.82f, 1.0f };

		FLinearColor Slider_Idle{ 1.0f,1.0f,1.0f,1.0f };
		FLinearColor Slider_Hovered{ 1.0f,1.0f,1.0f,1.0f };
		FLinearColor Slider_Progress{ 0.0f,0.0f,0.0f,1.0f };
		FLinearColor Slider_Button{ 0.0f,0.0f,0.0f,1.0f };

		FLinearColor ColorPicker_Background{ 0.0f,0.0f,0.0f,1.0f };
	}

	namespace PostRenderer
	{
		struct DrawList
		{
			int type = -1; //1 = FilledRect, 2 = TextLeft, 3 = TextCenter, 4 = Draw_Line
			FVector2D pos;
			FVector2D size;
			FLinearColor color;
			char* name;
			bool outline;

			FVector2D from;
			FVector2D to;
			int thickness;
		};
		DrawList drawlist[128];

		void drawFilledRect(FVector2D pos, float w, float h, FLinearColor color)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 1;
					drawlist[i].pos = pos;
					drawlist[i].size = FVector2D{ w, h };
					drawlist[i].color = color;
					return;
				}
			}
		}
		void TextLeft(char* name, FVector2D pos, FLinearColor color, bool outline)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 2;
					drawlist[i].name = name;
					drawlist[i].pos = pos;
					drawlist[i].outline = outline;
					drawlist[i].color = color;
					return;
				}
			}
		}
		void TextCenter(char* name, FVector2D pos, FLinearColor color, bool outline)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 3;
					drawlist[i].name = name;
					drawlist[i].pos = pos;
					drawlist[i].outline = outline;
					drawlist[i].color = color;
					return;
				}
			}
		}
		void Draw_Line(FVector2D from, FVector2D to, int thickness, FLinearColor color)
		{
			for (int i = 0; i < 128; i++)
			{
				if (drawlist[i].type == -1)
				{
					drawlist[i].type = 4;
					drawlist[i].from = from;
					drawlist[i].to = to;
					drawlist[i].thickness = thickness;
					drawlist[i].color = color;
					return;
				}
			}
		}
	}

	UCanvas* canvas;


	bool hover_element = false;
	FVector2D menu_pos = FVector2D{ 0, 0 };
	float offset_x = 0.0f;
	float offset_y = 0.0f;

	FVector2D first_element_pos = FVector2D{ 0, 0 };

	FVector2D last_element_pos = FVector2D{ 0, 0 };
	FVector2D last_element_size = FVector2D{ 0, 0 };

	int current_element = -1;
	FVector2D current_element_pos = FVector2D{ 0, 0 };
	FVector2D current_element_size = FVector2D{ 0, 0 };
	int elements_count = 0;

	bool sameLine = false;

	bool pushY = false;
	float pushYvalue = 0.0f;

	void SetupCanvas(UCanvas* _canvas)
	{
		canvas = _canvas;
	}

	FVector2D CursorPos()
	{
		POINT cursorPos;
		GetCursorPos(&cursorPos);
		return FVector2D{ (float)cursorPos.x, (float)cursorPos.y };
	}
	bool MouseInZone(FVector2D pos, FVector2D size)
	{
		FVector2D cursor_pos = CursorPos();

		if (cursor_pos.X > pos.X && cursor_pos.Y > pos.Y)
			if (cursor_pos.X < pos.X + size.X && cursor_pos.Y < pos.Y + size.Y)
				return true;

		return false;
	}

	void Draw_Cursor(bool toogle)
	{
		if (toogle)
		{
			FVector2D cursorPos = CursorPos();
			canvas->K2_DrawLine(FVector2D{ cursorPos.X, cursorPos.Y }, FVector2D{ cursorPos.X + 35, cursorPos.Y + 10 }, 1, FLinearColor{ 0.30f, 0.30f, 0.80f, 1.0f });


			int x = 35;
			int y = 10;
			while (y != 30) //20 steps
			{
				x -= 1; if (x < 15) x = 15;
				y += 1; if (y > 30) y = 30;

				canvas->K2_DrawLine(FVector2D{ cursorPos.X, cursorPos.Y }, FVector2D{ cursorPos.X + x, cursorPos.Y + y }, 1, FLinearColor{ 0.30f, 0.30f, 0.80f, 1.0f });
			}

			canvas->K2_DrawLine(FVector2D{ cursorPos.X, cursorPos.Y }, FVector2D{ cursorPos.X + 15, cursorPos.Y + 30 }, 1, FLinearColor{ 0.30f, 0.30f, 0.80f, 1.0f });
			canvas->K2_DrawLine(FVector2D{ cursorPos.X + 35, cursorPos.Y + 10 }, FVector2D{ cursorPos.X + 15, cursorPos.Y + 30 }, 1, FLinearColor{ 0.30f, 0.30f, 0.80f, 1.0f });
		}
	}

	void SameLine()
	{
		sameLine = true;
	}
	void PushNextElementY(float y, bool from_last_element = true)
	{
		pushY = true;
		if (from_last_element)
			pushYvalue = last_element_pos.Y + last_element_size.Y + y;
		else
			pushYvalue = y;
	}
	void NextColumn(float x)
	{
		offset_x = x;
		PushNextElementY(first_element_pos.Y, false);
	}
	void ClearFirstPos()
	{
		first_element_pos = FVector2D{ 0, 0 };
	}

	void xDrawTextRGB(const wchar_t* text, float x, float y, FLinearColor color)
	{
		canvas->K2_DrawText(text, { x, y }, { 1.1, 1.1 }, { 0.f,0.f,0.f,1.0f }, 0.f, { 0, 0, 0, 1 }, { 0, 0 }, 0, 0, 0, { 0, 0, 0, 1 });
	}
	void yDrawTextRGB(const wchar_t* text, float x, float y, FLinearColor color)
	{
		canvas->K2_DrawText(text, { x, y }, { 1.1, 1.1 }, {0.f,0.f,0.f,1.0f}, 0.f, {0, 0, 0, 1}, {0, 0}, 1, 0, 0, {0, 0, 0, 1});
	}
	void TextLeft(const wchar_t* name, FVector2D pos, FLinearColor color, bool outline)
	{ 
		xDrawTextRGB(name, pos.X, pos.Y, {1,1,1,1});
	}
	void TextCenter(const wchar_t* name, FVector2D pos, FLinearColor color, bool outline, bool kekw = 0)
	{
		if(kekw)
			yDrawTextRGB(name, pos.X, pos.Y - 10, color);
		else
			yDrawTextRGB(name, pos.X, pos.Y - 10, {0.f,0.f,0.f,1.0f});
	}

	void GetColor(FLinearColor* color, float* r, float* g, float* b, float* a)
	{
		*r = color->R;
		*g = color->G;
		*b = color->B;
		*a = color->A;
	}
	UINT32 GetColorUINT(int r, int g, int b, int a)
	{
		UINT32 result = (BYTE(a) << 24) + (BYTE(r) << 16) + (BYTE(g) << 8) + BYTE(b);
		return result;
	}

	void Draw_Line(FVector2D from, FVector2D to, int thickness, FLinearColor color)
	{
		canvas->K2_DrawLine(FVector2D{ from.X, from.Y }, FVector2D{ to.X, to.Y }, thickness, color);
	}
	void drawFilledRect(FVector2D initial_pos, float w, float h, FLinearColor color)
	{
		for (float i = 0.0f; i < h; i += 1.0f)
			canvas->K2_DrawLine(FVector2D{ initial_pos.X, initial_pos.Y + i }, FVector2D{ initial_pos.X + w, initial_pos.Y + i }, 1.0f, color);
	}
	void DrawFilledCircle(FVector2D pos, float r, FLinearColor color)
	{
		float smooth = 0.07f;

		double PI = 3.14159265359;
		int size = (int)(2.0f * PI / smooth) + 1;

		float angle = 0.0f;
		int i = 0;

		for (; angle < 2 * PI; angle += smooth, i++)
		{
			Draw_Line(FVector2D{ pos.X, pos.Y }, FVector2D{ pos.X + cosf(angle) * r, pos.Y + sinf(angle) * r }, 1.0f, color);
		}
	}
	void DrawCircle(FVector2D pos, int radius, int numSides, FLinearColor Color)
	{
		float PI = 3.1415927f;

		float Step = PI * 2.0 / numSides;
		int Count = 0;
		FVector2D V[128];
		for (float a = 0; a < PI * 2.0; a += Step) {
			float X1 = radius * cos(a) + pos.X;
			float Y1 = radius * sin(a) + pos.Y;
			float X2 = radius * cos(a + Step) + pos.X;
			float Y2 = radius * sin(a + Step) + pos.Y;
			V[Count].X = X1;
			V[Count].Y = Y1;
			V[Count + 1].X = X2;
			V[Count + 1].Y = Y2;
			//Draw_Line(FVector2D{ pos.X, pos.Y }, FVector2D{ X2, Y2 }, 1.0f, Color); // Points from Centre to ends of circle
			Draw_Line(FVector2D{ V[Count].X, V[Count].Y }, FVector2D{ X2, Y2 }, 1.0f, Color);// Circle Around
		}
	}

	FVector2D dragPos;
	bool Window(const char* name, FVector2D* pos, FVector2D size, bool isOpen)
	{
		elements_count = 0;

		if (!isOpen)
			return false;

		bool isHovered = MouseInZone(FVector2D{ pos->X, pos->Y }, size);

		//Drop last element
		if (current_element != -1 && !GetAsyncKeyState(0x1))
		{
			current_element = -1;
		}

		//Drag
		if (hover_element && GetAsyncKeyState(0x1))
		{

		}
		else if ((isHovered || dragPos.X != 0) && !hover_element)
		{
			if (Input::IsMouseClicked(0, elements_count, true))
			{
				FVector2D cursorPos = CursorPos();

				cursorPos.X -= size.X;
				cursorPos.Y -= size.Y;

				if (dragPos.X == 0)
				{
					dragPos.X = (cursorPos.X - pos->X);
					dragPos.Y = (cursorPos.Y - pos->Y);
				}
				pos->X = cursorPos.X - dragPos.X;
				pos->Y = cursorPos.Y - dragPos.Y;
			}
			else
			{
				dragPos = FVector2D{ 0, 0 };
			}
		}
		else
		{
			hover_element = false;
		}


		offset_x = 0.0f; offset_y = 0.0f;
		menu_pos = FVector2D{ pos->X, pos->Y };
		first_element_pos = FVector2D{ 0, 0 };
		current_element_pos = FVector2D{ 0, 0 };
		current_element_size = FVector2D{ 0, 0 };

		//Bg
		drawFilledRect(FVector2D{ pos->X, pos->Y }, size.X, size.Y, RGBtoFLC69(255,255,255));
		//drawFilledRect(FVector2D{ pos->X, pos->Y }, 122, size.Y, FLinearColor{ 0.006f, 0.006f, 0.006f, 1.0f });//My tabs bg

		//Header
		//drawFilledRect(FVector2D{ pos->X, pos->Y }, size.X, 25.0f, RGBtoFLC69(255,0,0));

		offset_y += 25.0f;

		//Title
		FVector2D titlePos = FVector2D{ pos->X + size.X / 2, pos->Y + 25 / 2 };
		TextLeft(s2wc(name), titlePos, FLinearColor{0.0f,0.0f,0.0f,0.0f}, false);

		return true;
	}

	void Text(const wchar_t* text, bool center = false, bool outline = false)
	{
		elements_count++;

		float size = 25;
		FVector2D padding = FVector2D{ 10, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}

		if (!sameLine)
			offset_y += size + padding.Y;

		//Text
		FVector2D textPos = FVector2D{ pos.X + 5.0f, pos.Y + size / 2 };
		if (center)
			TextCenter(text, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, outline);
		else
			TextLeft(text, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, outline);

		sameLine = false;
		last_element_pos = pos;
		//last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;
	}
	bool ButtonTab(const wchar_t* name, FVector2D size, bool active)
	{
		elements_count++;

		FVector2D padding = FVector2D{ 5, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X ;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, size);

		//Bg
		if (active)
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y,  RGBtoFLC69(255,0,0,160));
		}
		else if (isHovered)
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, RGBtoFLC69(255, 0, 0, 180));
			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, RGBtoFLC69(255, 0, 0, 255));
		}

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		//Text
		FVector2D textPos = FVector2D{ pos.X + size.X / 2, pos.Y + size.Y / 2 };
		if(active)
			TextCenter(name, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, 1);
		else
			TextCenter(name, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, 1);


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
			return true;

		return false;
	}
	bool Button(const wchar_t* name, FVector2D size)
	{
		elements_count++;

		FVector2D padding = FVector2D{ 5, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, size);

		//Bg
		if (isHovered)
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Button_Hovered);
			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Button_Idle);
		}

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		//Text
		FVector2D textPos = FVector2D{ pos.X + size.X / 2, pos.Y + size.Y / 2 };
		//if (!TextOverlapedFromActiveElement(textPos))
		TextCenter(name, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
			return true;

		return false;
	}
	void Checkbox(const wchar_t* name, bool* value)
	{
		elements_count++;

		float size = 18;
		FVector2D padding = FVector2D{ 10, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, FVector2D{ size, size });

		//Bg
		if (isHovered)
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size, size, Colors::Checkbox_Hovered);
			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X + 3, pos.Y + 3 }, size - 6, size - 6, Colors::Checkbox_Enabled);
		}

		if (!sameLine)
			offset_y += size + padding.Y;

		if (*value)
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size, size, Colors::Checkbox_Idle);
			//drawFilledRect(FVector2D{ pos.X + 9, pos.Y + 9 }, size - 18, size - 18, Colors::Checkbox_Hovered);
		}



		//Text
		FVector2D textPos = FVector2D{ pos.X + size + 5.0f, pos.Y  };
		//if (!TextOverlapedFromActiveElement(textPos))
		TextLeft(name, textPos, FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f }, false);


		sameLine = false;
		last_element_pos = pos;
		//last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
			*value = !*value;
	}
	void SliderInt(char* name, int* value, int min, int max)
	{
		elements_count++;

		FVector2D size = FVector2D{ 240, 50 };
		FVector2D slider_size = FVector2D{ 200, 10 };
		FVector2D padding = FVector2D{ 10, 15 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, slider_size);

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		//Bg
		if (isHovered || current_element == elements_count)
		{
			//Drag
			if (Input::IsMouseClicked(0, elements_count, true))
			{
				current_element = elements_count;

				FVector2D cursorPos = CursorPos();
				*value = ((cursorPos.X - pos.X) * ((max - min) / slider_size.X)) + min;
				if (*value < min) *value = min;
				if (*value > max) *value = max;
			}

			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, slider_size.X, slider_size.Y, Colors::Slider_Hovered);
			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y + 5.0f }, 5.0f, 5.0f, Colors::Slider_Progress);

			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, slider_size.X, slider_size.Y, Colors::Slider_Idle);
			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y + 5.0f }, 5.0f, 5.0f, Colors::Slider_Progress);
		}


		//Value
		float oneP = slider_size.X / (max - min);
		drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, oneP * (*value - min), slider_size.Y, Colors::Slider_Progress);
		//drawFilledRect(FVector2D{ pos.X + oneP * (*value - min) - 10.0f, pos.Y + slider_size.Y - 5.0f + padding.Y }, 20.0f, 20.0f, Colors::Slider_Button);
		DrawFilledCircle(FVector2D{ pos.X + oneP * (*value - min), pos.Y + slider_size.Y + 3.3f + padding.Y }, 10.0f, Colors::Slider_Button);
		DrawFilledCircle(FVector2D{ pos.X + oneP * (*value - min), pos.Y + slider_size.Y + 3.3f + padding.Y }, 5.0f, Colors::Slider_Progress);
		 

		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;
	}
	void SliderFloat(const wchar_t* name, float* value, float min, float max, const char* format = "%.0f")
	{
		elements_count++;

		FVector2D size = FVector2D{ 210, 40 };
		FVector2D slider_size = FVector2D{ 170, 7 };
		FVector2D adjust_zone = FVector2D{ 0, 20 };
		FVector2D padding = FVector2D{ 10, 15 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y - adjust_zone.Y }, FVector2D{ slider_size.X, slider_size.Y + adjust_zone.Y * 1.5f });

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		//Bg
		if (isHovered || current_element == elements_count)
		{
			//Drag
			if (Input::IsMouseClicked(0, elements_count, true))
			{
				current_element = elements_count;

				FVector2D cursorPos = CursorPos();
				*value = ((cursorPos.X - pos.X) * ((max - min) / slider_size.X)) + min;
				if (*value < min) *value = min;
				if (*value > max) *value = max;
			}

			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, slider_size.X, slider_size.Y, Colors::Slider_Hovered);
			DrawFilledCircle(FVector2D{ pos.X, pos.Y + padding.Y + 9.3f }, 3.1f, Colors::Slider_Progress);
			DrawFilledCircle(FVector2D{ pos.X + slider_size.X, pos.Y + padding.Y + 9.3f }, 3.1f, Colors::Slider_Hovered);

			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, slider_size.X, slider_size.Y, Colors::Slider_Idle);
			DrawFilledCircle(FVector2D{ pos.X, pos.Y + padding.Y + 9.3f }, 3.1f, Colors::Slider_Progress);
			DrawFilledCircle(FVector2D{ pos.X + slider_size.X, pos.Y + padding.Y + 9.3f }, 3.1f, Colors::Slider_Idle);
		}


		//Text
		FVector2D textPos = FVector2D{ pos.X, pos.Y + 5 };
		TextLeft(name, textPos, FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f }, false);

		//Value
		float oneP = slider_size.X / (max - min);
		drawFilledRect(FVector2D{ pos.X, pos.Y + slider_size.Y + padding.Y }, oneP * (*value - min), slider_size.Y, Colors::Slider_Progress);
		DrawFilledCircle(FVector2D{ pos.X + oneP * (*value - min), pos.Y + slider_size.Y + 2.66f + padding.Y }, 8.0f, Colors::Slider_Button);
		DrawFilledCircle(FVector2D{ pos.X + oneP * (*value - min), pos.Y + slider_size.Y + 2.66f + padding.Y }, 4.0f, Colors::Slider_Progress);
		 
		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;
	}



	bool checkbox_enabled[256];
	void Combobox(const wchar_t* name, FVector2D size, int* value, const char* arg, ...)
	{
		elements_count++;

		FVector2D padding = FVector2D{ 5, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, size);

		//Bg
		if (isHovered || checkbox_enabled[elements_count])
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Combobox_Hovered);

			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Combobox_Idle);
		}

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		//Text
		FVector2D textPos = FVector2D{ pos.X + size.X + 5.0f, pos.Y + size.Y / 2 };
		TextLeft(name, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);

		//Elements
		bool isHovered2 = false;
		FVector2D element_pos = pos;
		int num = 0;

		if (checkbox_enabled[elements_count])
		{
			current_element_size.X = element_pos.X - 5.0f;
			current_element_size.Y = element_pos.Y - 5.0f;
		}
		va_list arguments;
		for (va_start(arguments, arg); arg != NULL; arg = va_arg(arguments, const char*))
		{
			//Selected Element
			if (num == *value)
			{
				FVector2D _textPos = FVector2D{ pos.X + size.X / 2, pos.Y + size.Y / 2 };
				TextCenter((const wchar_t*)arg, _textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
			}

			if (checkbox_enabled[elements_count])
			{
				element_pos.Y += 25.0f;

				isHovered2 = MouseInZone(FVector2D{ element_pos.X, element_pos.Y }, FVector2D{ size.X, 25.0f });
				if (isHovered2)
				{
					hover_element = true;
					PostRenderer::drawFilledRect(FVector2D{ element_pos.X, element_pos.Y }, size.X, 25.0f, Colors::Combobox_Hovered);

					//Click
					if (Input::IsMouseClicked(0, elements_count, false))
					{
						*value = num;
						checkbox_enabled[elements_count] = false;
					}
				}
				else
				{
					PostRenderer::drawFilledRect(FVector2D{ element_pos.X, element_pos.Y }, size.X, 25.0f, Colors::Combobox_Idle);
				}

				PostRenderer::TextLeft((char*)arg, FVector2D{ element_pos.X + 5.0f, element_pos.Y + 15.0f }, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);
			}
			num++;
		}
		va_end(arguments);
		if (checkbox_enabled[elements_count])
		{
			current_element_size.X = element_pos.X + 5.0f;
			current_element_size.Y = element_pos.Y + 5.0f;
		}


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;

		if (isHovered && Input::IsMouseClicked(0, elements_count, false))
		{
			checkbox_enabled[elements_count] = !checkbox_enabled[elements_count];
		}
		if (!isHovered && !isHovered2 && Input::IsMouseClicked(0, elements_count, false))
		{
			checkbox_enabled[elements_count] = false;
		}
	}

	int active_hotkey = -1;
	bool already_pressed = false;
	std::string VirtualKeyCodeToString(UCHAR virtualKey)
	{
		UINT scanCode = MapVirtualKey(virtualKey, MAPVK_VK_TO_VSC);

		if (virtualKey == VK_LBUTTON)
		{
			return ("MOUSE0");
		}
		if (virtualKey == VK_RBUTTON)
		{
			return ("MOUSE1");
		}
		if (virtualKey == VK_MBUTTON)
		{
			return ("MBUTTON");
		}
		if (virtualKey == VK_XBUTTON1)
		{
			return ("XBUTTON1");
		}
		if (virtualKey == VK_XBUTTON2)
		{
			return ("XBUTTON2");
		}

		CHAR szName[128];
		int result = 0;
		switch (virtualKey)
		{
		case VK_LEFT: case VK_UP: case VK_RIGHT: case VK_DOWN:
		case VK_RCONTROL: case VK_RMENU:
		case VK_LWIN: case VK_RWIN: case VK_APPS:
		case VK_PRIOR: case VK_NEXT:
		case VK_END: case VK_HOME:
		case VK_INSERT: case VK_DELETE:
		case VK_DIVIDE:
		case VK_NUMLOCK:
			scanCode |= KF_EXTENDED;
		default:
			result = GetKeyNameTextA(scanCode << 16, szName, 128);
		}

		return szName;
	}
	void Hotkey(const char* name, FVector2D size, int* key)
	{
		elements_count++;

		FVector2D padding = FVector2D{ 5, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y + (last_element_size.Y / 2) - size.Y / 2;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, size);

		//Bg
		if (isHovered)
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Button_Hovered);
			hover_element = true;
		}
		else
		{
			drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, Colors::Button_Idle);
		}

		if (!sameLine)
			offset_y += size.Y + padding.Y;

		if (active_hotkey == elements_count)
		{
			//Text
			FVector2D textPos = FVector2D{ pos.X + size.X / 2, pos.Y + size.Y / 2 };
			TextCenter((const wchar_t*)("[Press Key]"), textPos, FLinearColor{1.0f, 1.0f, 1.0f, 1.0f}, false);

			if (!CWINGui::Input::IsAnyMouseDown())
			{
				already_pressed = false;
			}

			if (!already_pressed)
			{
				for (int code = 0; code < 255; code++)
				{
					if (GetAsyncKeyState(code))
					{
						*key = code;
						active_hotkey = -1;
					}
				}
			}
		}
		else
		{
			//Text
			FVector2D textPos = FVector2D{ pos.X + size.X / 2, pos.Y + size.Y / 2 };
			TextCenter((const wchar_t*)VirtualKeyCodeToString(*key).c_str(), textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);

			if (isHovered)
			{
				if (Input::IsMouseClicked(0, elements_count, false))
				{
					already_pressed = true;
					active_hotkey = elements_count;

					//Queue Fix
					for (int code = 0; code < 255; code++)
						if (GetAsyncKeyState(code)) {}
				}
			}
			else
			{
				if (Input::IsMouseClicked(0, elements_count, false))
				{
					active_hotkey = -1;
				}
			}
		}


		sameLine = false;
		last_element_pos = pos;
		last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;
	}

	int active_picker = -1;
	FLinearColor saved_color;
	bool ColorPixel(FVector2D pos, FVector2D size, FLinearColor* original, FLinearColor color)
	{
		PostRenderer::drawFilledRect(FVector2D{ pos.X, pos.Y }, size.X, size.Y, color);

		//Выбранный цвет
		if (original->R == color.R && original->G == color.G && original->B == color.B)
		{
			PostRenderer::Draw_Line(FVector2D{ pos.X, pos.Y }, FVector2D{ pos.X + size.X - 1, pos.Y }, 1.0f, FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
			PostRenderer::Draw_Line(FVector2D{ pos.X, pos.Y + size.Y - 1 }, FVector2D{ pos.X + size.X - 1, pos.Y + size.Y - 1 }, 1.0f, FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
			PostRenderer::Draw_Line(FVector2D{ pos.X, pos.Y }, FVector2D{ pos.X, pos.Y + size.Y - 1 }, 1.0f, FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
			PostRenderer::Draw_Line(FVector2D{ pos.X + size.X - 1, pos.Y }, FVector2D{ pos.X + size.X - 1, pos.Y + size.Y - 1 }, 1.0f, FLinearColor{ 0.0f, 0.0f, 0.0f, 1.0f });
		}

		//Смена цвета
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, size);
		if (isHovered)
		{
			if (Input::IsMouseClicked(0, elements_count, false))
				*original = color;
		}

		return true;
	}
	void ColorPicker(const wchar_t* name, FLinearColor* color)
	{
		elements_count++;

		float size = 25;
		FVector2D padding = FVector2D{ 10, 10 };
		FVector2D pos = FVector2D{ menu_pos.X + padding.X + offset_x, menu_pos.Y + padding.Y + offset_y };
		if (sameLine)
		{
			pos.X = last_element_pos.X + last_element_size.X + padding.X;
			pos.Y = last_element_pos.Y;
		}
		if (pushY)
		{
			pos.Y = pushYvalue;
			pushY = false;
			pushYvalue = 0.0f;
			offset_y = pos.Y - menu_pos.Y;
		}
		bool isHovered = MouseInZone(FVector2D{ pos.X, pos.Y }, FVector2D{ size, size });

		if (!sameLine)
			offset_y += size + padding.Y;

		if (active_picker == elements_count)
		{
			hover_element = true;

			float sizePickerX = 250;
			float sizePickerY = 250;
			bool isHoveredPicker = MouseInZone(FVector2D{ pos.X, pos.Y }, FVector2D{ sizePickerX, sizePickerY - 60 });

			//Background
			PostRenderer::drawFilledRect(FVector2D{ pos.X, pos.Y }, sizePickerX, sizePickerY - 65, Colors::ColorPicker_Background);

			//float pixedSize = sizePickerY / pixels;
			//FLinearColor temp_color{1.0f, 1.0f, 1.0f, 1.0f};
			//float iterator = 0.0f;
			//
			//for (int y = 0; y < pixels; y++)
			//{
			//	for (int x = 0; x < pixels; x++)
			//	{
			//		ColorPixel(FVector2D{ pos.X + pixedSize * x, pos.Y + pixedSize * y }, pixedSize, color, temp_color);
			//		temp_color.R -= (1.0f - saved_color.R) / pixels;
			//		temp_color.G -= (1.0f - saved_color.G) / pixels;
			//		temp_color.B -= (1.0f - saved_color.B) / pixels;
			//	}
			//	
			//	iterator += 1.0f / pixels;
			//	temp_color = FLinearColor{ 1.0f - iterator, 1.0f - iterator, 1.0f - iterator, 1.0f };
			//}

			FVector2D pixelSize = FVector2D{ sizePickerX / 12, sizePickerY / 12 };

			//0
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 174 / 255.f, 235 / 255.f, 253 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 136 / 255.f, 225 / 255.f, 251 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 108 / 255.f, 213 / 255.f, 250 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 89 / 255.f, 175 / 255.f, 213 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 76 / 255.f, 151 / 255.f, 177 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 60 / 255.f, 118 / 255.f, 140 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 43 / 255.f, 85 / 255.f, 100 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 32 / 255.f, 62 / 255.f, 74 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 0, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 255 / 255.f, 255 / 255.f, 255 / 255.f, 1.0f });
			}
			//1
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 175 / 255.f, 205 / 255.f, 252 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 132 / 255.f, 179 / 255.f, 252 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 90 / 255.f, 152 / 255.f, 250 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 55 / 255.f, 120 / 255.f, 250 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 49 / 255.f, 105 / 255.f, 209 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 38 / 255.f, 83 / 255.f, 165 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 28 / 255.f, 61 / 255.f, 120 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 20 / 255.f, 43 / 255.f, 86 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 1, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 247 / 255.f, 247 / 255.f, 247 / 255.f, 1.0f });
			}
			//2
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 153 / 255.f, 139 / 255.f, 250 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 101 / 255.f, 79 / 255.f, 249 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 64 / 255.f, 50 / 255.f, 230 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 54 / 255.f, 38 / 255.f, 175 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 39 / 255.f, 31 / 255.f, 144 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 32 / 255.f, 25 / 255.f, 116 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 21 / 255.f, 18 / 255.f, 82 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 16 / 255.f, 13 / 255.f, 61 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 2, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 228 / 255.f, 228 / 255.f, 228 / 255.f, 1.0f });
			}
			//3
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 194 / 255.f, 144 / 255.f, 251 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 165 / 255.f, 87 / 255.f, 249 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 142 / 255.f, 57 / 255.f, 239 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 116 / 255.f, 45 / 255.f, 184 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 92 / 255.f, 37 / 255.f, 154 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 73 / 255.f, 29 / 255.f, 121 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 53 / 255.f, 21 / 255.f, 88 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 37 / 255.f, 15 / 255.f, 63 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 3, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 203 / 255.f, 203 / 255.f, 203 / 255.f, 1.0f });
			}
			//4
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 224 / 255.f, 162 / 255.f, 197 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 210 / 255.f, 112 / 255.f, 166 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 199 / 255.f, 62 / 255.f, 135 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 159 / 255.f, 49 / 255.f, 105 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 132 / 255.f, 41 / 255.f, 89 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 104 / 255.f, 32 / 255.f, 71 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 75 / 255.f, 24 / 255.f, 51 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 54 / 255.f, 14 / 255.f, 36 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 4, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 175 / 255.f, 175 / 255.f, 175 / 255.f, 1.0f });
			}
			//5
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 235 / 255.f, 175 / 255.f, 176 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 227 / 255.f, 133 / 255.f, 135 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 219 / 255.f, 87 / 255.f, 88 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 215 / 255.f, 50 / 255.f, 36 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 187 / 255.f, 25 / 255.f, 7 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 149 / 255.f, 20 / 255.f, 6 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 107 / 255.f, 14 / 255.f, 4 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 77 / 255.f, 9 / 255.f, 3 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 5, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 144 / 255.f, 144 / 255.f, 144 / 255.f, 1.0f });
			}
			//6
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 241 / 255.f, 187 / 255.f, 171 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 234 / 255.f, 151 / 255.f, 126 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 229 / 255.f, 115 / 255.f, 76 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 227 / 255.f, 82 / 255.f, 24 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 190 / 255.f, 61 / 255.f, 15 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 150 / 255.f, 48 / 255.f, 12 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 107 / 255.f, 34 / 255.f, 8 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 79 / 255.f, 25 / 255.f, 6 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 6, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 113 / 255.f, 113 / 255.f, 113 / 255.f, 1.0f });
			}
			//7
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 245 / 255.f, 207 / 255.f, 169 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 240 / 255.f, 183 / 255.f, 122 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 236 / 255.f, 159 / 255.f, 74 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 234 / 255.f, 146 / 255.f, 37 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 193 / 255.f, 111 / 255.f, 28 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 152 / 255.f, 89 / 255.f, 22 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 110 / 255.f, 64 / 255.f, 16 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 80 / 255.f, 47 / 255.f, 12 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 7, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 82 / 255.f, 82 / 255.f, 82 / 255.f, 1.0f });
			}
			//8
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 247 / 255.f, 218 / 255.f, 170 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 244 / 255.f, 200 / 255.f, 124 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 241 / 255.f, 182 / 255.f, 77 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 239 / 255.f, 174 / 255.f, 44 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 196 / 255.f, 137 / 255.f, 34 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 154 / 255.f, 108 / 255.f, 27 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 111 / 255.f, 77 / 255.f, 19 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 80 / 255.f, 56 / 255.f, 14 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 8, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 54 / 255.f, 54 / 255.f, 54 / 255.f, 1.0f });
			}
			//9
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 254 / 255.f, 243 / 255.f, 187 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 253 / 255.f, 237 / 255.f, 153 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 253 / 255.f, 231 / 255.f, 117 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 254 / 255.f, 232 / 255.f, 85 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 242 / 255.f, 212 / 255.f, 53 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 192 / 255.f, 169 / 255.f, 42 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 138 / 255.f, 120 / 255.f, 30 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 101 / 255.f, 87 / 255.f, 22 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 9, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 29 / 255.f, 29 / 255.f, 29 / 255.f, 1.0f });
			}
			//10
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 247 / 255.f, 243 / 255.f, 185 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 243 / 255.f, 239 / 255.f, 148 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 239 / 255.f, 232 / 255.f, 111 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 235 / 255.f, 229 / 255.f, 76 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 208 / 255.f, 200 / 255.f, 55 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 164 / 255.f, 157 / 255.f, 43 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 118 / 255.f, 114 / 255.f, 31 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 86 / 255.f, 82 / 255.f, 21 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 10, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 9 / 255.f, 9 / 255.f, 9 / 255.f, 1.0f });
			}
			//11
			{
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 0 }, pixelSize, color, FLinearColor{ 218 / 255.f, 232 / 255.f, 182 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 1 }, pixelSize, color, FLinearColor{ 198 / 255.f, 221 / 255.f, 143 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 2 }, pixelSize, color, FLinearColor{ 181 / 255.f, 210 / 255.f, 103 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 3 }, pixelSize, color, FLinearColor{ 154 / 255.f, 186 / 255.f, 76 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 4 }, pixelSize, color, FLinearColor{ 130 / 255.f, 155 / 255.f, 64 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 5 }, pixelSize, color, FLinearColor{ 102 / 255.f, 121 / 255.f, 50 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 6 }, pixelSize, color, FLinearColor{ 74 / 255.f, 88 / 255.f, 36 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 7 }, pixelSize, color, FLinearColor{ 54 / 255.f, 64 / 255.f, 26 / 255.f, 1.0f });
				ColorPixel(FVector2D{ pos.X + pixelSize.X * 11, pos.Y + pixelSize.Y * 8 }, pixelSize, color, FLinearColor{ 0 / 255.f, 0 / 255.f, 0 / 255.f, 1.0f });
			}



			if (isHoveredPicker)
			{
				if (Input::IsMouseClicked(0, elements_count, false))
				{

				}
			}
			else
			{
				if (Input::IsMouseClicked(0, elements_count, false))
				{
					active_picker = -1;
					//hover_element = false;
				}
			}
		}
		else
		{
			//Bg
			if (isHovered)
			{
				drawFilledRect(FVector2D{ pos.X, pos.Y }, size, size, Colors::Checkbox_Hovered);
				hover_element = true;
			}
			else
			{
				drawFilledRect(FVector2D{ pos.X, pos.Y }, size, size, Colors::Checkbox_Idle);
			}

			//Color
			drawFilledRect(FVector2D{ pos.X + 4, pos.Y + 4 }, size - 8, size - 8, *color);

			//Text
			FVector2D textPos = FVector2D{ pos.X + size + 5.0f, pos.Y - 5 };
			TextLeft(name, textPos, FLinearColor{ 1.0f, 1.0f, 1.0f, 1.0f }, false);

			if (isHovered && Input::IsMouseClicked(0, elements_count, false))
			{
				saved_color = *color;
				active_picker = elements_count;
			}
		}


		sameLine = false;
		last_element_pos = pos;
		//last_element_size = size;
		if (first_element_pos.X == 0.0f)
			first_element_pos = pos;
	}


	void Render()
	{
		for (int i = 0; i < 128; i++)
		{
			if (PostRenderer::drawlist[i].type != -1)
			{
				//Filled Rect
				if (PostRenderer::drawlist[i].type == 1)
				{
					CWINGui::drawFilledRect(PostRenderer::drawlist[i].pos, PostRenderer::drawlist[i].size.X, PostRenderer::drawlist[i].size.Y, PostRenderer::drawlist[i].color);
				}
				//TextLeft
				else if (PostRenderer::drawlist[i].type == 2)
				{
					CWINGui::TextLeft((const wchar_t*)PostRenderer::drawlist[i].name, PostRenderer::drawlist[i].pos, PostRenderer::drawlist[i].color, PostRenderer::drawlist[i].outline);
				}
				//TextCenter
				else if (PostRenderer::drawlist[i].type == 3)
				{
					CWINGui::TextCenter((const wchar_t*)PostRenderer::drawlist[i].name, PostRenderer::drawlist[i].pos, PostRenderer::drawlist[i].color, PostRenderer::drawlist[i].outline);
				}
				//Draw_Line
				else if (PostRenderer::drawlist[i].type == 4)
				{
					Draw_Line(PostRenderer::drawlist[i].from, PostRenderer::drawlist[i].to, PostRenderer::drawlist[i].thickness, PostRenderer::drawlist[i].color);
				}

				PostRenderer::drawlist[i].type = -1;
			}
		}
	}
}
```

`unrealengine.h`:

```h
#pragma once
#include <math.h>
#include <corecrt_math_defines.h>
#include <cstdlib>
#include <cstdint>
#include <iostream>
#include <vector>
#include <stringapiset.h>
#define RAD(degs) float(degs) * PI / 180.0f
#define DEG(rads) float(rads) * 180.0f / PI
struct FVector
{
	float X, Y, Z;

	FVector() : X(0.f), Y(0.f), Z(0.f) {}

	FVector(float x, float y, float z) : X(x), Y(y), Z(z) {}

	FVector(float InF) : X(InF), Y(InF), Z(InF) { }


	inline float Dot(const FVector& b) const { return (X * b.X) + (Y * b.Y) + (Z * b.Z); }

	inline float MagnitudeSqr() const { return Dot(*this); }

	inline float Magnitude() const { return std::sqrtf(MagnitudeSqr()); }

	float Size() const { return sqrtf(X * X + Y * Y + Z * Z); }

	float Sum() const { return X + Y + Z; }

	float Size2D() const { return sqrtf(X * X + Y * Y); }

	float SizeSquared() const { return X * X + Y * Y + Z * Z; }

	float DistTo(const FVector& V) const { return (*this - V).Size(); }

	FVector operator+(const FVector& other) const { return FVector(X + other.X, Y + other.Y, Z + other.Z); }

	FVector operator-(const FVector& other) const { return FVector(X - other.X, Y - other.Y, Z - other.Z); }

	FVector operator*(const FVector& V) const { return FVector(X * V.X, Y * V.Y, Z * V.Z); }

	FVector operator/(const FVector& V) const { return FVector(X / V.X, Y / V.Y, Z / V.Z); }

	bool operator==(const FVector& V) const { return X == V.X && Y == V.Y && Z == V.Z; }

	bool operator!=(const FVector& V) const { return X != V.X || Y != V.Y || Z != V.Z; }

	FVector operator-() const { return FVector(-X, -Y, -Z); }

	FVector operator+(float Bias) const { return FVector(X + Bias, Y + Bias, Z + Bias); }

	FVector operator-(float Bias) const { return FVector(X - Bias, Y - Bias, Z - Bias); }

	FVector operator*(float Scale) const { return FVector(X * Scale, Y * Scale, Z * Scale); } const

		FVector operator/(float Scale) const { const float RScale = 1.f / Scale; return FVector(X * RScale, Y * RScale, Z * RScale); }

	FVector operator=(const FVector& V) { X = V.X; Y = V.Y; Z = V.Z; return *this; }

	FVector operator+=(const FVector& V) { X += V.X; Y += V.Y; Z += V.Z; return *this; }

	FVector operator-=(const FVector& V) { X -= V.X; Y -= V.Y; Z -= V.Z; return *this; }

	FVector operator*=(const FVector& V) { X *= V.X; Y *= V.Y; Z *= V.Z; return *this; }

	FVector operator/=(const FVector& V) { X /= V.X; Y /= V.Y; Z /= V.Z; return *this; }

	FVector operator*=(float Scale) { X *= Scale; Y *= Scale; Z *= Scale; return *this; }

	FVector operator/=(float V) { const float RV = 1.f / V; X *= RV; Y *= RV; Z *= RV; return *this; }

	float operator|(const FVector& V) const { return X * V.X + Y * V.Y + Z * V.Z; }

	FVector operator^(const FVector& V) const { return FVector(Y * V.Z - Z * V.Y, Z * V.X - X * V.Z, X * V.Y - Y * V.X); }
	inline float Distance(FVector v) {
		return float(sqrtf(powf(v.X - X, 2.0) + powf(v.Y - Y, 2.0) + powf(v.Z - Z, 2.0)));
	}
	bool IsValid()
	{
		if (X == 0 || Y == 0 || Z == 0)
			return false;
		else
			return true;
	}
	static const FVector ZeroVector;

	static const FVector OneVector;
};
class FLinearColor
{
public:
	float R, G, B, A;
};
struct FVector2D
{
	float X, Y;

	FVector2D() : X(0), Y(0) {}

	FVector2D(float x, float y) : X(x), Y(y) {}

	float Size() const;

	FVector2D operator + (const FVector2D& other) const { return FVector2D(X + other.X, Y + other.Y); }

	FVector2D operator- (const FVector2D& other) const { return FVector2D(X - other.X, Y - other.Y); }

	FVector2D operator* (float scalar) const { return FVector2D(X * scalar, Y * scalar); }

	FVector2D& operator=  (const FVector2D& other) { X = other.X; Y = other.Y; return *this; }

	FVector2D& operator+= (const FVector2D& other) { X += other.X; Y += other.Y; return *this; }

	FVector2D& operator-= (const FVector2D& other) { X -= other.X; Y -= other.Y; return *this; }

	FVector2D& operator*= (const float other) { X *= other; Y *= other; return *this; }

	friend bool operator==(const FVector2D& one, const FVector2D& two) { return one.X == two.X && one.Y == two.Y; }

	friend bool operator!=(const FVector2D& one, const FVector2D& two) { return !(one == two); }

	friend bool operator>(const FVector2D& one, const FVector2D& two) { return one.X > two.X && one.Y > two.Y; }

	friend bool operator<(const FVector2D& one, const FVector2D& two) { return one.X < two.X&& one.Y < two.Y; }
	bool IsValid()
	{
		if (X == 0 || Y == 0)
			return false;
		else
			return true;
	}
};
struct alignas(16) FPlane : public FVector {
	float W;
};
enum class EAresAlliance : uint8_t {
	Alliance_Ally = 0,
	Alliance_Enemy = 1,
	Alliance_Neutral = 2,
	Alliance_Any = 3,
	Alliance_Count = 4,
	Alliance_MAX = 5
};
enum class EAresOutlineMode : uint8_t {
	None = 0,
	Outline = 1,
	Block = 2,
	Enemy = 3,
	AlwaysOutline = 4,
	AlwaysEnemy = 5,
	EAresOutlineMode_MAX = 6
};
struct FMatrix {

	struct FPlane XPlane;
	struct FPlane YPlane;
	struct FPlane ZPlane;
	struct FPlane WPlane;

};

static FMatrix ToMatrix(FVector rot) {
	FVector origin = FVector{};
	float radPitch = (rot.X * float(M_PI) / 180.f);
	float radYaw = (rot.Y * float(M_PI) / 180.f);
	float radRoll = (rot.Z * float(M_PI) / 180.f);

	float SP = sinf(radPitch);
	float CP = cosf(radPitch);
	float SY = sinf(radYaw);
	float CY = cosf(radYaw);
	float SR = sinf(radRoll);
	float CR = cosf(radRoll);

	FMatrix matrix;
	matrix.XPlane.X = CP * CY;
	matrix.XPlane.Y = CP * SY;
	matrix.XPlane.Z = SP;
	matrix.XPlane.W = 0.f;

	matrix.YPlane.X = SR * SP * CY - CR * SY;
	matrix.YPlane.Y = SR * SP * SY + CR * CY;
	matrix.YPlane.Z = -SR * CP;
	matrix.YPlane.W = 0.f;

	matrix.ZPlane.X = -(CR * SP * CY + SR * SY);
	matrix.ZPlane.Y = CY * SR - CR * SP * SY;
	matrix.ZPlane.Z = CR * CP;
	matrix.ZPlane.W = 0.f;

	matrix.WPlane.X = origin.X;
	matrix.WPlane.Y = origin.Y;
	matrix.WPlane.Z = origin.Z;
	matrix.WPlane.W = 1.f;

	return matrix;
}
template<class T>
struct TArray
{
	friend class FString;

public:
	TArray()
	{
		Data = nullptr;
		Count = Max = 0;
	}

	TArray(T* data, int32_t count, int32_t max)
		: Data(data),
		Count(count),
		Max(max)
	{
	}

	int Num() const
	{
		return Count;
	}

	T& operator[](int i)
	{
		return Data[i];
	}

	const T& operator[](int i) const
	{
		return Data[i];
	}

	bool IsValidIndex(int i) const
	{
		return i < Num();
	}



private:
	T* Data;
	int32_t Count;
	int32_t Max;
};
class FString : public TArray<wchar_t>
{
public:
	inline FString()
	{
	};

	FString(const wchar_t* other)
	{
		Max = Count = *other ? static_cast<int>(std::wcslen(other)) + 1 : 0;

		if (Count)
		{
			Data = const_cast<wchar_t*>(other);
		}
	};
	FString(const wchar_t* other, int count)
	{
		Data = const_cast<wchar_t*>(other);;
		Max = Count = count;
	};

	inline bool IsValid() const
	{
		return Data != nullptr;
	}

	inline const wchar_t* wide() const
	{
		return Data;
	}

	int multi(char* name, int size) const
	{
		return WideCharToMultiByte(CP_UTF8, 0, Data, Count, name, size, nullptr, nullptr) - 1;
	}

	std::string ToString() const
	{
		auto length = std::wcslen(Data);

		std::string str(length, '\0');

		std::use_facet<std::ctype<wchar_t>>(std::locale()).narrow(Data, Data + length, '?', &str[0]);

		return str;
	}
};
```

`valorant.h`:

```h
#pragma once
#include <cstdint>
namespace VALORANT
{
	uintptr_t Module;
}
```