Project Path: arc_gmh5225_PCIBan_72pmy402

Source Tree:

```txt
arc_gmh5225_PCIBan_72pmy402
├── LICENSE
├── PCIBan
│   ├── Directory.Build.props
│   ├── Driver.cpp
│   ├── Driver.h
│   ├── PCIBan.filters
│   ├── PCIBan.inf
│   ├── PCIBan.vcxproj
│   └── Pci.h
├── PCIBan.sln
└── README.md

```

`LICENSE`:

```
MIT License

Copyright (c) 2021 KDIo3

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`PCIBan.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.572
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PCIBan", "PCIBan\PCIBan.vcxproj", "{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
		VM|ARM = VM|ARM
		VM|ARM64 = VM|ARM64
		VM|x64 = VM|x64
		VM|x86 = VM|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Debug|ARM.ActiveCfg = Debug|ARM
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Debug|ARM.Build.0 = Debug|ARM
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Debug|ARM.Deploy.0 = Debug|ARM
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Debug|ARM64.Build.0 = Debug|ARM64
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Debug|x64.ActiveCfg = Debug|x64
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Debug|x64.Build.0 = Debug|x64
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Debug|x64.Deploy.0 = Debug|x64
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Debug|x86.ActiveCfg = Debug|Win32
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Debug|x86.Build.0 = Debug|Win32
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Debug|x86.Deploy.0 = Debug|Win32
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Release|ARM.ActiveCfg = Release|ARM
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Release|ARM.Build.0 = Release|ARM
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Release|ARM.Deploy.0 = Release|ARM
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Release|ARM64.ActiveCfg = Release|ARM64
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Release|ARM64.Build.0 = Release|ARM64
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Release|ARM64.Deploy.0 = Release|ARM64
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Release|x64.ActiveCfg = Release|x64
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Release|x64.Build.0 = Release|x64
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Release|x64.Deploy.0 = Release|x64
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Release|x86.ActiveCfg = Release|Win32
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Release|x86.Build.0 = Release|Win32
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.Release|x86.Deploy.0 = Release|Win32
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.VM|ARM.ActiveCfg = VM|ARM
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.VM|ARM.Build.0 = VM|ARM
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.VM|ARM.Deploy.0 = VM|ARM
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.VM|ARM64.ActiveCfg = VM|ARM64
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.VM|ARM64.Build.0 = VM|ARM64
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.VM|ARM64.Deploy.0 = VM|ARM64
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.VM|x64.ActiveCfg = VM|x64
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.VM|x64.Build.0 = VM|x64
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.VM|x64.Deploy.0 = VM|x64
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.VM|x86.ActiveCfg = VM|Win32
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.VM|x86.Build.0 = VM|Win32
		{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}.VM|x86.Deploy.0 = VM|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {659F69D0-9B0A-4DCC-98C0-B22C313085EB}
	EndGlobalSection
EndGlobal

```

`PCIBan/Directory.Build.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project>
  <PropertyGroup Label="Configuration">
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
</Project>
```

`PCIBan/Driver.cpp`:

```cpp
#include "Driver.h"
#include "Pci.h"

#include <intrin.h>

#define AHCI_SEARCH_COUNT 64


//
// A found PCI device.
//
typedef struct _PCI_DEVICE
{
	PCI_HEADER_GENERIC Header;
	UINT8 Function;
	UINT8 Device;
	UINT8 Bus;
} PCI_DEVICE;

//
// Reads a block of data from a PCI config.
//
static
BOOLEAN
ReadPciConfig(
	_Out_ PVOID Out,
	_In_ SIZE_T Size,
	_In_ UINT8 Bus,
	_In_ UINT8 Device,
	_In_ UINT8 Function
)
{
	if (Size > 0xff)
	{
		return FALSE;
	}

	PCI_CONFIG_REQUEST request;
	request.Function = Function;
	request.Device = Device;
	request.Bus = Bus;
	request.MustBe1 = 1;

	PCHAR cout = (PCHAR)Out;
	SIZE_T offset = 0;
	while (Size)
	{
		SIZE_T bsize = min(Size, 4);
		request.Offset = (UINT32)offset;

		__outdword(PCI_CONFIG_ADDRESS, request.Flags);

		UINT32 read = __indword(PCI_CONFIG_DATA);
		memcpy(cout, &read, bsize);

		cout += bsize;
		offset += bsize;
		Size -= bsize;
	}

	return TRUE;
}

//
// Analyzes a PCI config.
//
static
BOOLEAN
AnalyzePciConfig(
	_Out_ PCI_DEVICE* Out,
	_In_ UINT8 Bus,
	_In_ UINT8 Device,
	_In_ UINT8 Function
)
{
	if (!ReadPciConfig(&Out->Header, sizeof(PCI_HEADER_GENERIC), Bus, Device, Function))
	{
		return FALSE;
	}

	return Out->Header.VendorId != 0xffff;
}

//
// Finds all PCI devices at a specific bus + device.
//
static
VOID
FindPciDevicesAt(
	_Out_ PCI_DEVICE* Out,
	_Inout_ SIZE_T* OutLen,
	_In_ SIZE_T Max,
	_In_ UINT8 Bus,
	_In_ UINT8 Device
)
{
	PCI_DEVICE generic;
	generic.Bus = Bus;
	generic.Device = Device;
	if (AnalyzePciConfig(&generic, Bus, Device, 0))
	{
		for (UINT8 function = 0; function < PCI_MAX_FUNCTION; function++)
		{
			generic.Function = function;
			if (AnalyzePciConfig(&generic, Bus, Device, function) && *OutLen < Max)
			{
				Out[(*OutLen)++] = generic;
			}
		}
	}
}

//
// Finds all PCI devices using bruteforce.
//
static
VOID
FindPciDevices(
	_Out_ PCI_DEVICE* Out,
	_Inout_ SIZE_T* OutLen
)
{
	SIZE_T max = *OutLen;
	*OutLen = 0;

	for (UINT8 bus = 0; bus < PCI_MAX_BUS; bus++)
	{
		for (UINT8 device = 0; device < PCI_MAX_DEVICE; device++)
		{
			FindPciDevicesAt(Out, OutLen, max, bus, device);
		}
	}
}

//
// Requests an AHCI serial from an ABAR.
//
static
VOID
RequestAhciSerialAbar(
	_Inout_ PCI_ABAR* Abar,
	_In_ UINT8 Port,
	_In_ PHYSICAL_ADDRESS IdentifyOutput
)
{
	PCI_ABAR_PORT* p = NULL;
	PHYSICAL_ADDRESS tmpAddr;
	PCI_ABAR_CMD_HEADER* cmdh = NULL;
	PCI_ABAR_CMD_TBL* cmdt = NULL;
	PCI_ABAR_FIS_REG_H2D* cmdfis = NULL;
	UINT32 slotMask;
	INT32 slot;

	p = &Abar->Ports[Port];
	slotMask = (p->Sact | p->Ci);
	slot = -1;
	for (INT32 i = 0; i < 8 && slot == -1; i++)
	{
		if (!(slotMask & (1 << i)))
		{
			slot = i;
		}
	}

	if (slot == -1)
	{
		goto _cleanup;
	}

	tmpAddr.QuadPart = (UINT64)p->Clb + (slot * sizeof(PCI_ABAR_CMD_HEADER));
	cmdh = (PCI_ABAR_CMD_HEADER*)MmMapIoSpace(tmpAddr, sizeof(PCI_ABAR_CMD_HEADER), MmNonCached);
	if (!cmdh)
	{
		goto _cleanup;
	}

	tmpAddr.QuadPart = cmdh->Ctba;
	cmdt = (PCI_ABAR_CMD_TBL*)MmMapIoSpace(tmpAddr, sizeof(PCI_ABAR_CMD_TBL), MmNonCached);
	if (!cmdt)
	{
		goto _cleanup;
	}

	cmdfis = (PCI_ABAR_FIS_REG_H2D*)cmdt->Cfis;

	p->Ie = 0xffffffff;
	p->Is = 0x0;
	p->Tfd = 0x0;

	cmdh->Cfl = sizeof(PCI_ABAR_FIS_REG_H2D) / sizeof(UINT32);
	cmdh->W = 0; 
	cmdh->Cfl = 5;
	cmdh->Prdtl = 1;

	cmdt->PrdtEntry[0].Dba = IdentifyOutput.LowPart;
	cmdt->PrdtEntry[0].Dbau = IdentifyOutput.HighPart;
	cmdt->PrdtEntry[0].Dbc = 512 - 1;
	cmdt->PrdtEntry[0].I = 1;

	memset(cmdfis, 0, sizeof(PCI_ABAR_FIS_REG_H2D));
	cmdfis->FisType = FIS_TYPE_REG_H2D;
	cmdfis->C = 1;
	cmdfis->Command = ATA_CMD_IDENTIFY;

	p->Ci |= (1 << slot);
	while (p->Ci & (1 << slot) && !(p->Is & HBA_PxIS_TFES))
	{
		_mm_pause();
	}

	if (p->Is & HBA_PxIS_TFES)
	{
		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "Disk error\n");
		goto _cleanup;
	}

_cleanup:
	if (cmdh)
	{
		MmUnmapIoSpace(cmdh, sizeof(PCI_ABAR_CMD_HEADER));
	}

	if (cmdt)
	{
		MmUnmapIoSpace(cmdt, sizeof(PCI_ABAR_CMD_TBL));
	}
}

//
// Requests an AHCI serial from a PCI device.
//
static
VOID
RequestAhciSerialDevice(
	_In_ PCI_HEADER_0* Header
)
{
	UINT64 abarAddrRaw = Header->Bar[5];
	if (abarAddrRaw)
	{
		PHYSICAL_ADDRESS abarAddr;
		abarAddr.QuadPart = (UINT64)abarAddrRaw;

		PCI_ABAR* abar = (PCI_ABAR*)MmMapIoSpace(abarAddr, sizeof(PCI_ABAR), MmNonCached);
		if (abar)
		{
			// TODO FIXME calculate num of ports
			IDENTIFY_DEVICE_DATA* buf = (IDENTIFY_DEVICE_DATA*)ExAllocatePool(NonPagedPool, PAGE_SIZE);
			memset(buf, 0, PAGE_SIZE);

			RequestAhciSerialAbar(abar, 0, MmGetPhysicalAddress(buf));
			DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "Serial= %s\n", buf->SerialNumber);

			ExFreePool(buf);
			MmUnmapIoSpace(abar, sizeof(PCI_ABAR));
		}
	}
}

//
// Collects all AHCI serials.
//
static
VOID
CollectAhciSerials(
)
{
	PCI_DEVICE devices[AHCI_SEARCH_COUNT];
	SIZE_T len = sizeof(PCI_HEADER_GENERIC) * AHCI_SEARCH_COUNT;
	FindPciDevices(devices, &len);

	for (SIZE_T i = 0; i < len; i++)
	{
		PCI_DEVICE device = devices[i];
		if (device.Header.ClassCode == PCI_CLASS_CODE_MASS_STORAGE_CONTROLLER &&
			device.Header.SubClass == PCI_SUBCLASS_SERIAL_ATA &&
			device.Header.ProgIf == PCI_PROGIF_AHCI)
		{
			PCI_HEADER_0 header;
			if (ReadPciConfig(&header, sizeof(header), device.Bus, device.Device, device.Function))
			{
				RequestAhciSerialDevice(&header);
			}
		}
	}
}

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) 
{
	CollectAhciSerials();
	return STATUS_SUCCESS;
}

```

`PCIBan/Driver.h`:

```h
#pragma once
#include <fltKernel.h>

```

`PCIBan/PCIBan.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="Spoofer.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Log.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Driver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Hook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Random.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Scan.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="SpoofDisk.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="SpoofGpu.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="SpoofNic.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="SpoofVolume.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="SpoofSmbios.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="TigressStub.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Sweep.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Util.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Inc.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Offsets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Random.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Spoof.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Hook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Sweep.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Scan.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Undocumented.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Log.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="DriverDefines.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="SpooferGen.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="SpoofDiskAsm.asm">
      <Filter>Source Files</Filter>
    </MASM>
    <MASM Include="ObfuscatedEntry.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`PCIBan/PCIBan.inf`:

```inf
[Version]
Signature="$WINDOWS NT$"
Class=Sample
ClassGuid={98A1C341-4739-11d3-B88D-00C03FAD5171}
Provider=%ManufacturerName%
CatalogFile=Spoofer.cat
DriverVer=01/01/2000

[Kernel_Device.NT.Wdf]
KmdfService =  Spoofer, Kernel_wdfsect

[Kernel_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
ManufacturerName="<Your manufacturer name>"
ClassName="Samples"
DiskName = "Spoofer Installation Disk"
Spoofer.DeviceDesc = "Spoofer Device"
Spoofer.SVCDESC = "Spoofer Service"

```

`PCIBan/PCIBan.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="VM|ARM">
      <Configuration>VM</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="VM|ARM64">
      <Configuration>VM</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="VM|Win32">
      <Configuration>VM</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="VM|x64">
      <Configuration>VM</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{ED726B72-C3C8-4092-8350-ADA43CA1CBE0}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>
    </TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>PCIBan</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
    <ProjectName>PCIBan</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='VM|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='VM|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <WholeProgramOptimization>true</WholeProgramOptimization>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='VM|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='VM|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='VM|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
    <IncludePath>$(IncludePath);$(KMDF_INC_PATH)$(KMDF_VER_PATH)</IncludePath>
    <LibraryPath>$(DDK_LibraryPath_DDKPlatform);$(LibraryPath)</LibraryPath>
    <TimeStampServer />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='VM|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
    <IncludePath>$(ProjectDir)Inc;$(IncludePath);$(KMDF_INC_PATH)$(KMDF_VER_PATH)</IncludePath>
    <LibraryPath>$(ProjectDir)Lib;$(DDK_LibraryPath_DDKPlatform);$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='VM|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='VM|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='VM|x64'">
    <VcpkgEnabled>false</VcpkgEnabled>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <VcpkgEnabled>false</VcpkgEnabled>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <VcpkgEnabled>false</VcpkgEnabled>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='VM|x64'">
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <TreatWarningAsError>false</TreatWarningAsError>
      <WarningLevel>Level1</WarningLevel>
      <PreprocessorDefinitions>VMP;_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Inf>
      <SpecifyArchitecture>false</SpecifyArchitecture>
    </Inf>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='VM|x64'">
    <ClCompile>
      <ControlFlowGuard>false</ControlFlowGuard>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <TreatWarningAsError>false</TreatWarningAsError>
      <WarningLevel>Level1</WarningLevel>
      <PreprocessorDefinitions>LOGGING;VIRTUALIZER;_WIN64;_AMD64_;AMD64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>false</SDLCheck>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
    </ClCompile>
    <Inf>
      <SpecifyArchitecture>false</SpecifyArchitecture>
    </Inf>
    <Link>
      <EntryPointSymbol>ObfuscatedEntry</EntryPointSymbol>
      <AdditionalDependencies>VirtualizerSDK64.lib;TigressCoreKm.lib;GhLib.lib;libudis86.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalOptions> /ignore:4099 %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="PCIBan.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Driver.h" />
    <ClInclude Include="Pci.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Directory.Build.props" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`PCIBan/Pci.h`:

```h
#pragma once
#include <fltKernel.h>

#define PCI_CONFIG_MAX_SIZE 0x40

#define PCI_MAX_BUS 0xff
#define PCI_MAX_DEVICE 32
#define PCI_MAX_FUNCTION 8

#define PCI_CONFIG_ADDRESS 0xCF8
#define PCI_CONFIG_DATA 0xCFC

#define PCI_CLASS_CODE_UNCLASSIFIED 0x0
#define PCI_CLASS_CODE_MASS_STORAGE_CONTROLLER 0x1
#define PCI_CLASS_CODE_NETWORK_CONTROLLER 0x2
#define PCI_CLASS_COD_DISPLAY_CONTROLLER 0x3

#define PCI_SUBCLASS_SERIAL_ATA 0x6

#define PCI_PROGIF_AHCI 0x1

#define HBA_PI_ACTIVE (1 << 0)
#define HBA_PI_PRESENT (3 << 8)

#define HBA_PxCMD_ST (1 << 0)
#define HBA_PxCMD_FRE (1 << 4)
#define HBA_PxCMD_FR (1 << 14)
#define HBA_PxCMD_CR (1 << 15)

#define ATA_DEV_BUSY (1 << 7)
#define ATA_DEV_DRQ (1 << 3)

#define HBA_PxIS_TFES (1 << 30)

#define ATA_CMD_READ_DMA_EX 0x25
#define ATA_CMD_WRITE_DMA_EX 0x35
#define ATA_CMD_IDENTIFY 0xEC

typedef enum
{
	FIS_TYPE_REG_H2D = 0x27,
	FIS_TYPE_REG_D2H = 0x34,
	FIS_TYPE_DMA_ACT = 0x39,
	FIS_TYPE_DMA_SETUP = 0x41,
	FIS_TYPE_DATA = 0x46,
	FIS_TYPE_BIST = 0x58,
	FIS_TYPE_PIO_SETUP = 0x5F,
	FIS_TYPE_DEV_BITS = 0xA1,
} FIS_TYPE;

#pragma pack(push, 1)
typedef struct _PCI_HEADER_GENERIC
{
	UINT16 VendorId;
	UINT16 DeviceId;

	UINT16 Command;
	UINT16 Status;

	UINT8 RevisionId;
	UINT8 ProgIf;
	UINT8 SubClass;
	UINT8 ClassCode;

	UINT8 CacheLineSize;
	UINT8 LatencyTimer;
	UINT8 HeaderType;
	UINT8 Bist;
} PCI_HEADER_GENERIC;

typedef struct _PCI_HEADER_0
{
	PCI_HEADER_GENERIC Generic;

	UINT32 Bar[6];
	UINT32 CardBusCisPointer;

	UINT16 SubSystemVendorId;
	UINT16 SubSystemId;

	UINT32 ExpansionRomBaseAddress;
	UINT32 Reserved1; // FIXME capabilities bits
	UINT32 Reserved2;

	UINT8 InterruptLine;
	UINT8 InterruptPin;
	UINT8 MinGrant;
	UINT8 MaxLatency;
} PCI_HEADER_0;

typedef struct _PCI_CONFIG_REQUEST
{
	union
	{
		struct
		{

			UINT32 Offset : 8; // first 2 bytes must be 0 (i.e. 4 byte alignment)
			UINT32 Function : 3;
			UINT32 Device : 5;
			UINT32 Bus : 15;
			UINT32 MustBe1 : 1;
		};
		UINT32 Flags;
	};
} PCI_CONFIG_REQUEST;

typedef volatile struct _PCI_ABAR_PORT
{
	UINT64 Clb;
	UINT32 Fb;
	UINT32 Fbu;
	UINT32 Is;
	UINT32 Ie;
	UINT32 Cmd;
	UINT32 Rsv0;
	UINT32 Tfd;
	UINT32 Sig;
	UINT32 Ssts;
	UINT32 Sctl;
	UINT32 Serr;
	UINT32 Sact;
	UINT32 Ci;
	UINT32 Sntf;
	UINT32 Fbs;
	UINT32 Rsv1[11];
	UINT32 Vendor[4];
} PCI_ABAR_PORT;

typedef struct _PCI_ABAR_CMD_HEADER
{
	UINT8 Cfl : 5;
	UINT8 A : 1;
	UINT8 W : 1;
	UINT8 P : 1;
	UINT8 R : 1;
	UINT8 B : 1;
	UINT8 C : 1;
	UINT8 Rsv0 : 1;
	UINT8 Pmp : 4;
	UINT16 Prdtl;
	volatile UINT32 Prdbc;
	UINT64 Ctba;
	UINT32 Rsv1[4];
} PCI_ABAR_CMD_HEADER;

typedef struct _PCI_ABAR_FIS_REG_H2D
{
	UINT8 FisType;
	UINT8 Pmport : 4;
	UINT8 Rsv0 : 3;
	UINT8 C : 1;
	UINT8 Command;
	UINT8 Featurel;
	UINT8 Lba0;
	UINT8 Lba1;
	UINT8 Lba2;
	UINT8 Device;
	UINT8 Lba3;
	UINT8 Lba4;
	UINT8 Lba5;
	UINT8 Featureh;
	UINT8 Countl;
	UINT8 Counth;
	UINT8 Icc;
	UINT8 Control;
	UINT8 Rsv1[4];
} PCI_ABAR_FIS_REG_H2D;

typedef struct _PCI_ABAR_PRDT_ENTRY
{
	UINT32 Dba;
	UINT32 Dbau;
	UINT32 Rsv0;
	UINT32 Dbc : 22;
	UINT32 Rsv1 : 9;
	UINT32 I : 1;
} PCI_ABAR_PRDT_ENTRY;


typedef struct _PCI_ABAR_CMD_TBL
{
	CHAR Cfis[64];
	UINT8 Acmd[16];
	UINT8 Rsv[48];
	PCI_ABAR_PRDT_ENTRY PrdtEntry[1];
} PCI_ABAR_CMD_TBL;

typedef struct _PCI_ABAR
{
	UINT32 Cap;
	UINT32 Ghc;
	UINT32 Is;
	UINT32 Pi;
	UINT32 Vs;
	UINT32 CccCtl;
	UINT32 CccPts;
	UINT32 EmLoc;
	UINT32 EmCtl;
	UINT32 Cap2;
	UINT32 Bohc;
	UINT8 Rsv[0xA0 - 0x2C];
	UINT8 Vendor[0x100 - 0xA0];
	PCI_ABAR_PORT Ports[32];
} PCI_ABAR;
static_assert(FIELD_OFFSET(PCI_ABAR, Ports) == 0x100, "Invalid offset");


typedef struct _IDENTIFY_DEVICE_DATA
{
	struct
	{
		USHORT Reserved1 : 1;
		USHORT Retired3 : 1;
		USHORT ResponseIncomplete : 1;
		USHORT Retired2 : 3;
		USHORT FixedDevice : 1;
		USHORT RemovableMedia : 1;
		USHORT Retired1 : 7;
		USHORT DeviceType : 1;
	} GeneralConfiguration;
	USHORT NumCylinders;
	USHORT SpecificConfiguration;
	USHORT NumHeads;
	USHORT Retired1[2];
	USHORT NumSectorsPerTrack;
	USHORT VendorUnique1[3];
	UCHAR  SerialNumber[20];
	USHORT Retired2[2];
	USHORT Obsolete1;
	UCHAR  FirmwareRevision[8];
	UCHAR  ModelNumber[40];
	UCHAR  MaximumBlockTransfer;
	UCHAR  VendorUnique2;
	struct
	{
		USHORT FeatureSupported : 1;
		USHORT Reserved : 15;
	} TrustedComputing;
	struct
	{
		UCHAR  CurrentLongPhysicalSectorAlignment : 2;
		UCHAR  ReservedByte49 : 6;
		UCHAR  DmaSupported : 1;
		UCHAR  LbaSupported : 1;
		UCHAR  IordyDisable : 1;
		UCHAR  IordySupported : 1;
		UCHAR  Reserved1 : 1;
		UCHAR  StandybyTimerSupport : 1;
		UCHAR  Reserved2 : 2;
		USHORT ReservedWord50;
	} Capabilities;
	USHORT ObsoleteWords51[2];
	USHORT TranslationFieldsValid : 3;
	USHORT Reserved3 : 5;
	USHORT FreeFallControlSensitivity : 8;
	USHORT NumberOfCurrentCylinders;
	USHORT NumberOfCurrentHeads;
	USHORT CurrentSectorsPerTrack;
	ULONG  CurrentSectorCapacity;
	UCHAR  CurrentMultiSectorSetting;
	UCHAR  MultiSectorSettingValid : 1;
	UCHAR  ReservedByte59 : 3;
	UCHAR  SanitizeFeatureSupported : 1;
	UCHAR  CryptoScrambleExtCommandSupported : 1;
	UCHAR  OverwriteExtCommandSupported : 1;
	UCHAR  BlockEraseExtCommandSupported : 1;
	ULONG  UserAddressableSectors;
	USHORT ObsoleteWord62;
	USHORT MultiWordDMASupport : 8;
	USHORT MultiWordDMAActive : 8;
	USHORT AdvancedPIOModes : 8;
	USHORT ReservedByte64 : 8;
	USHORT MinimumMWXferCycleTime;
	USHORT RecommendedMWXferCycleTime;
	USHORT MinimumPIOCycleTime;
	USHORT MinimumPIOCycleTimeIORDY;
	struct
	{
		USHORT ZonedCapabilities : 2;
		USHORT NonVolatileWriteCache : 1;
		USHORT ExtendedUserAddressableSectorsSupported : 1;
		USHORT DeviceEncryptsAllUserData : 1;
		USHORT ReadZeroAfterTrimSupported : 1;
		USHORT Optional28BitCommandsSupported : 1;
		USHORT IEEE1667 : 1;
		USHORT DownloadMicrocodeDmaSupported : 1;
		USHORT SetMaxSetPasswordUnlockDmaSupported : 1;
		USHORT WriteBufferDmaSupported : 1;
		USHORT ReadBufferDmaSupported : 1;
		USHORT DeviceConfigIdentifySetDmaSupported : 1;
		USHORT LPSAERCSupported : 1;
		USHORT DeterministicReadAfterTrimSupported : 1;
		USHORT CFastSpecSupported : 1;
	} AdditionalSupported;
	USHORT ReservedWords70[5];
	USHORT QueueDepth : 5;
	USHORT ReservedWord75 : 11;
	struct
	{
		USHORT Reserved0 : 1;
		USHORT SataGen1 : 1;
		USHORT SataGen2 : 1;
		USHORT SataGen3 : 1;
		USHORT Reserved1 : 4;
		USHORT NCQ : 1;
		USHORT HIPM : 1;
		USHORT PhyEvents : 1;
		USHORT NcqUnload : 1;
		USHORT NcqPriority : 1;
		USHORT HostAutoPS : 1;
		USHORT DeviceAutoPS : 1;
		USHORT ReadLogDMA : 1;
		USHORT Reserved2 : 1;
		USHORT CurrentSpeed : 3;
		USHORT NcqStreaming : 1;
		USHORT NcqQueueMgmt : 1;
		USHORT NcqReceiveSend : 1;
		USHORT DEVSLPtoReducedPwrState : 1;
		USHORT Reserved3 : 8;
	} SerialAtaCapabilities;
	struct
	{
		USHORT Reserved0 : 1;
		USHORT NonZeroOffsets : 1;
		USHORT DmaSetupAutoActivate : 1;
		USHORT DIPM : 1;
		USHORT InOrderData : 1;
		USHORT HardwareFeatureControl : 1;
		USHORT SoftwareSettingsPreservation : 1;
		USHORT NCQAutosense : 1;
		USHORT DEVSLP : 1;
		USHORT HybridInformation : 1;
		USHORT Reserved1 : 6;
	} SerialAtaFeaturesSupported;
	struct
	{
		USHORT Reserved0 : 1;
		USHORT NonZeroOffsets : 1;
		USHORT DmaSetupAutoActivate : 1;
		USHORT DIPM : 1;
		USHORT InOrderData : 1;
		USHORT HardwareFeatureControl : 1;
		USHORT SoftwareSettingsPreservation : 1;
		USHORT DeviceAutoPS : 1;
		USHORT DEVSLP : 1;
		USHORT HybridInformation : 1;
		USHORT Reserved1 : 6;
	} SerialAtaFeaturesEnabled;
	USHORT MajorRevision;
	USHORT MinorRevision;
	struct
	{
		USHORT SmartCommands : 1;
		USHORT SecurityMode : 1;
		USHORT RemovableMediaFeature : 1;
		USHORT PowerManagement : 1;
		USHORT Reserved1 : 1;
		USHORT WriteCache : 1;
		USHORT LookAhead : 1;
		USHORT ReleaseInterrupt : 1;
		USHORT ServiceInterrupt : 1;
		USHORT DeviceReset : 1;
		USHORT HostProtectedArea : 1;
		USHORT Obsolete1 : 1;
		USHORT WriteBuffer : 1;
		USHORT ReadBuffer : 1;
		USHORT Nop : 1;
		USHORT Obsolete2 : 1;
		USHORT DownloadMicrocode : 1;
		USHORT DmaQueued : 1;
		USHORT Cfa : 1;
		USHORT AdvancedPm : 1;
		USHORT Msn : 1;
		USHORT PowerUpInStandby : 1;
		USHORT ManualPowerUp : 1;
		USHORT Reserved2 : 1;
		USHORT SetMax : 1;
		USHORT Acoustics : 1;
		USHORT BigLba : 1;
		USHORT DeviceConfigOverlay : 1;
		USHORT FlushCache : 1;
		USHORT FlushCacheExt : 1;
		USHORT WordValid83 : 2;
		USHORT SmartErrorLog : 1;
		USHORT SmartSelfTest : 1;
		USHORT MediaSerialNumber : 1;
		USHORT MediaCardPassThrough : 1;
		USHORT StreamingFeature : 1;
		USHORT GpLogging : 1;
		USHORT WriteFua : 1;
		USHORT WriteQueuedFua : 1;
		USHORT WWN64Bit : 1;
		USHORT URGReadStream : 1;
		USHORT URGWriteStream : 1;
		USHORT ReservedForTechReport : 2;
		USHORT IdleWithUnloadFeature : 1;
		USHORT WordValid : 2;
	} CommandSetSupport;
	struct
	{
		USHORT SmartCommands : 1;
		USHORT SecurityMode : 1;
		USHORT RemovableMediaFeature : 1;
		USHORT PowerManagement : 1;
		USHORT Reserved1 : 1;
		USHORT WriteCache : 1;
		USHORT LookAhead : 1;
		USHORT ReleaseInterrupt : 1;
		USHORT ServiceInterrupt : 1;
		USHORT DeviceReset : 1;
		USHORT HostProtectedArea : 1;
		USHORT Obsolete1 : 1;
		USHORT WriteBuffer : 1;
		USHORT ReadBuffer : 1;
		USHORT Nop : 1;
		USHORT Obsolete2 : 1;
		USHORT DownloadMicrocode : 1;
		USHORT DmaQueued : 1;
		USHORT Cfa : 1;
		USHORT AdvancedPm : 1;
		USHORT Msn : 1;
		USHORT PowerUpInStandby : 1;
		USHORT ManualPowerUp : 1;
		USHORT Reserved2 : 1;
		USHORT SetMax : 1;
		USHORT Acoustics : 1;
		USHORT BigLba : 1;
		USHORT DeviceConfigOverlay : 1;
		USHORT FlushCache : 1;
		USHORT FlushCacheExt : 1;
		USHORT Resrved3 : 1;
		USHORT Words119_120Valid : 1;
		USHORT SmartErrorLog : 1;
		USHORT SmartSelfTest : 1;
		USHORT MediaSerialNumber : 1;
		USHORT MediaCardPassThrough : 1;
		USHORT StreamingFeature : 1;
		USHORT GpLogging : 1;
		USHORT WriteFua : 1;
		USHORT WriteQueuedFua : 1;
		USHORT WWN64Bit : 1;
		USHORT URGReadStream : 1;
		USHORT URGWriteStream : 1;
		USHORT ReservedForTechReport : 2;
		USHORT IdleWithUnloadFeature : 1;
		USHORT Reserved4 : 2;
	} CommandSetActive;
	USHORT UltraDMASupport : 8;
	USHORT UltraDMAActive : 8;
	struct
	{
		USHORT TimeRequired : 15;
		USHORT ExtendedTimeReported : 1;
	} NormalSecurityEraseUnit;
	struct
	{
		USHORT TimeRequired : 15;
		USHORT ExtendedTimeReported : 1;
	} EnhancedSecurityEraseUnit;
	USHORT CurrentAPMLevel : 8;
	USHORT ReservedWord91 : 8;
	USHORT MasterPasswordID;
	USHORT HardwareResetResult;
	USHORT CurrentAcousticValue : 8;
	USHORT RecommendedAcousticValue : 8;
	USHORT StreamMinRequestSize;
	USHORT StreamingTransferTimeDMA;
	USHORT StreamingAccessLatencyDMAPIO;
	ULONG  StreamingPerfGranularity;
	ULONG  Max48BitLBA[2];
	USHORT StreamingTransferTime;
	USHORT DsmCap;
	struct
	{
		USHORT LogicalSectorsPerPhysicalSector : 4;
		USHORT Reserved0 : 8;
		USHORT LogicalSectorLongerThan256Words : 1;
		USHORT MultipleLogicalSectorsPerPhysicalSector : 1;
		USHORT Reserved1 : 2;
	} PhysicalLogicalSectorSize;
	USHORT InterSeekDelay;
	USHORT WorldWideName[4];
	USHORT ReservedForWorldWideName128[4];
	USHORT ReservedForTlcTechnicalReport;
	USHORT WordsPerLogicalSector[2];
	struct
	{
		USHORT ReservedForDrqTechnicalReport : 1;
		USHORT WriteReadVerify : 1;
		USHORT WriteUncorrectableExt : 1;
		USHORT ReadWriteLogDmaExt : 1;
		USHORT DownloadMicrocodeMode3 : 1;
		USHORT FreefallControl : 1;
		USHORT SenseDataReporting : 1;
		USHORT ExtendedPowerConditions : 1;
		USHORT Reserved0 : 6;
		USHORT WordValid : 2;
	} CommandSetSupportExt;
	struct
	{
		USHORT ReservedForDrqTechnicalReport : 1;
		USHORT WriteReadVerify : 1;
		USHORT WriteUncorrectableExt : 1;
		USHORT ReadWriteLogDmaExt : 1;
		USHORT DownloadMicrocodeMode3 : 1;
		USHORT FreefallControl : 1;
		USHORT SenseDataReporting : 1;
		USHORT ExtendedPowerConditions : 1;
		USHORT Reserved0 : 6;
		USHORT Reserved1 : 2;
	} CommandSetActiveExt;
	USHORT ReservedForExpandedSupportandActive[6];
	USHORT MsnSupport : 2;
	USHORT ReservedWord127 : 14;
	struct
	{
		USHORT SecuritySupported : 1;
		USHORT SecurityEnabled : 1;
		USHORT SecurityLocked : 1;
		USHORT SecurityFrozen : 1;
		USHORT SecurityCountExpired : 1;
		USHORT EnhancedSecurityEraseSupported : 1;
		USHORT Reserved0 : 2;
		USHORT SecurityLevel : 1;
		USHORT Reserved1 : 7;
	} SecurityStatus;
	USHORT ReservedWord129[31];
	struct
	{
		USHORT MaximumCurrentInMA : 12;
		USHORT CfaPowerMode1Disabled : 1;
		USHORT CfaPowerMode1Required : 1;
		USHORT Reserved0 : 1;
		USHORT Word160Supported : 1;
	} CfaPowerMode1;
	USHORT ReservedForCfaWord161[7];
	USHORT NominalFormFactor : 4;
	USHORT ReservedWord168 : 12;
	struct
	{
		USHORT SupportsTrim : 1;
		USHORT Reserved0 : 15;
	} DataSetManagementFeature;
	USHORT AdditionalProductID[4];
	USHORT ReservedForCfaWord174[2];
	USHORT CurrentMediaSerialNumber[30];
	struct
	{
		USHORT Supported : 1;
		USHORT Reserved0 : 1;
		USHORT WriteSameSuported : 1;
		USHORT ErrorRecoveryControlSupported : 1;
		USHORT FeatureControlSuported : 1;
		USHORT DataTablesSuported : 1;
		USHORT Reserved1 : 6;
		USHORT VendorSpecific : 4;
	} SCTCommandTransport;
	USHORT ReservedWord207[2];
	struct
	{
		USHORT AlignmentOfLogicalWithinPhysical : 14;
		USHORT Word209Supported : 1;
		USHORT Reserved0 : 1;
	} BlockAlignment;
	USHORT WriteReadVerifySectorCountMode3Only[2];
	USHORT WriteReadVerifySectorCountMode2Only[2];
	struct
	{
		USHORT NVCachePowerModeEnabled : 1;
		USHORT Reserved0 : 3;
		USHORT NVCacheFeatureSetEnabled : 1;
		USHORT Reserved1 : 3;
		USHORT NVCachePowerModeVersion : 4;
		USHORT NVCacheFeatureSetVersion : 4;
	} NVCacheCapabilities;
	USHORT NVCacheSizeLSW;
	USHORT NVCacheSizeMSW;
	USHORT NominalMediaRotationRate;
	USHORT ReservedWord218;
	struct
	{
		UCHAR NVCacheEstimatedTimeToSpinUpInSeconds;
		UCHAR Reserved;
	} NVCacheOptions;
	USHORT WriteReadVerifySectorCountMode : 8;
	USHORT ReservedWord220 : 8;
	USHORT ReservedWord221;
	struct
	{
		USHORT MajorVersion : 12;
		USHORT TransportType : 4;
	} TransportMajorVersion;
	USHORT TransportMinorVersion;
	USHORT ReservedWord224[6];
	ULONG  ExtendedNumberOfUserAddressableSectors[2];
	USHORT MinBlocksPerDownloadMicrocodeMode03;
	USHORT MaxBlocksPerDownloadMicrocodeMode03;
	USHORT ReservedWord236[19];
	USHORT Signature : 8;
	USHORT CheckSum : 8;
} IDENTIFY_DEVICE_DATA, *PIDENTIFY_DEVICE_DATA;

#pragma pack(pop)
```

`README.md`:

```md
# PCIBan
A PoC for requesting HWIDs directly from hardware, skipping any potential hooks or OS support. This is probably very unsafe, not supporting edge cases, etc.

## Features
* Bruteforce PCI enumeration
* Identification of AHCI storage devices

## Media
![OS](https://i.imgur.com/mZysQuW.png)  
![Hardware](https://i.imgur.com/NGw5zRc.png)

## Credits
Special thanks to the osdev wiki for their nice explanations.
[PCI](https://wiki.osdev.org/PCI)
[AHCI](https://wiki.osdev.org/AHCI)

```