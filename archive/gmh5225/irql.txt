Project Path: arc_gmh5225_irql_q507umtj

Source Tree:

```txt
arc_gmh5225_irql_q507umtj
├── CONTRIBUTING.md
├── Cargo.lock
├── Cargo.toml
├── LICENSE-APACHE
├── LICENSE-MIT
├── Logo.png
├── README.md
├── crates
│   ├── irql
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── lib.rs
│   ├── irql_alloc
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── irql_box.rs
│   │       ├── irql_vec.rs
│   │       ├── lib.rs
│   │       └── pool.rs
│   ├── irql_core
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── drop_safety.rs
│   │       ├── function_traits.rs
│   │       ├── levels.rs
│   │       ├── lib.rs
│   │       └── private.rs
│   └── irql_macro
│       ├── Cargo.toml
│       └── src
│           ├── apply.rs
│           ├── call_irql.rs
│           ├── constraints.rs
│           └── lib.rs
├── examples
│   ├── alloc_example
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── main.rs
│   ├── basic
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── main.rs
│   ├── function_traits
│   │   ├── Cargo.toml
│   │   └── src
│   │       └── main.rs
│   └── struct_example
│       ├── Cargo.toml
│       └── src
│           └── main.rs
└── rust-toolchain.toml

```

`CONTRIBUTING.md`:

```md
# Contributing to IRQL

Thank you for your interest in contributing! Here's how to get started.

## Getting started

1. **Fork and clone** the repository
2. **Install Rust nightly** — the `alloc` feature requires it:
   ```sh
   rustup toolchain install nightly
   ```
   The repo includes a `rust-toolchain.toml` that selects nightly automatically.

## Building

```sh
# Build all crates (including alloc)
cargo build --workspace

# Build core crates only (works on stable)
cargo +stable build -p irql_core -p irql_macro -p irql
```

## Running examples

```sh
cargo run -p basic
cargo run -p struct_example
cargo run -p function_traits
cargo run -p alloc_example
```

## Checks before submitting a PR

```sh
# Format
cargo fmt --workspace

# Clippy (treat warnings as errors)
cargo clippy --workspace -- -D warnings

# Build everything
cargo build --workspace

# Run examples
cargo run -p basic
cargo run -p struct_example
cargo run -p function_traits
cargo run -p alloc_example

# Run tests (including doc tests)
cargo test --workspace
```

## Guidelines

- **Open an issue first** to discuss non-trivial changes before submitting a PR.
- **Keep commits focused** — one logical change per commit.
- **Add documentation** for new public items (`///` doc comments).
- **Add tests** where feasible — `trybuild` for macro compile-error tests,
  unit tests for logic, doc tests for examples.
- **Follow existing patterns** — match the style and structure of surrounding code.

## Architecture

```
irql              ← public facade crate (re-exports everything)
├── irql_core     ← IRQL level types, hierarchy traits, function traits,
│                   SafeToDropAt* auto traits
├── irql_macro    ← #[irql] proc macro + call_irql! rewriter
└── irql_alloc    ← IrqlBox, IrqlVec, pool allocator (optional, nightly)
```

See the [README](README.md) for a detailed architecture overview.

## License

By contributing, you agree that your contributions will be dual-licensed under
MIT and Apache 2.0, matching the project's existing license.

```

`Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "aho-corasick"
version = "1.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ddd31a130427c27518df266943a5308ed92d4b226cc639f5a8f1002816174301"
dependencies = [
 "memchr",
]

[[package]]
name = "alloc_example"
version = "0.1.6"
dependencies = [
 "irql",
]

[[package]]
name = "anstream"
version = "0.6.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "43d5b281e737544384e969a5ccad3f1cdd24b48086a0fc1b2a5262a26b8f4f4a"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "is_terminal_polyfill",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5192cca8006f1fd4f7237516f40fa183bb07f8fbdfedaa0036de5ea9b0b45e78"

[[package]]
name = "anstyle-parse"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4e7644824f0aa2c7b9384579234ef10eb7efb6a0deb83f9630a49594dd9c15c2"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40c48f72fd53cd289104fc64099abca73db4166ad86ea0b4341abe65af83dadc"
dependencies = [
 "windows-sys 0.61.2",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "291e6a250ff86cd4a820112fb8898808a366d8f9f58ce16d1f538353ad55747d"
dependencies = [
 "anstyle",
 "once_cell_polyfill",
 "windows-sys 0.61.2",
]

[[package]]
name = "anyhow"
version = "1.0.101"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f0e0fee31ef5ed1ba1316088939cea399010ed7731dba877ed44aeb407a75ea"

[[package]]
name = "basic"
version = "0.1.6"
dependencies = [
 "irql",
]

[[package]]
name = "bindgen"
version = "0.71.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f58bf3d7db68cfbac37cfc485a8d711e87e064c3d0fe0435b92f7a407f9d6b3"
dependencies = [
 "bitflags",
 "cexpr",
 "clang-sys",
 "itertools",
 "log",
 "prettyplease",
 "proc-macro2",
 "quote",
 "regex",
 "rustc-hash",
 "shlex",
 "syn",
]

[[package]]
name = "bitflags"
version = "2.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "843867be96c8daad0d758b57df9392b6d8d271134fce549de6ce169ff98a92af"

[[package]]
name = "camino"
version = "1.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e629a66d692cb9ff1a1c664e41771b3dcaf961985a9774c0eb0bd1b51cf60a48"
dependencies = [
 "serde_core",
]

[[package]]
name = "cargo-platform"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e35af189006b9c0f00a064685c727031e3ed2d8020f7ba284d78cc2671bd36ea"
dependencies = [
 "serde",
]

[[package]]
name = "cargo_metadata"
version = "0.19.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd5eb614ed4c27c5d706420e4320fbe3216ab31fa1c33cd8246ac36dae4479ba"
dependencies = [
 "camino",
 "cargo-platform",
 "semver",
 "serde",
 "serde_json",
 "thiserror",
]

[[package]]
name = "cc"
version = "1.2.56"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "aebf35691d1bfb0ac386a69bac2fde4dd276fb618cf8bf4f5318fe285e821bb2"
dependencies = [
 "find-msvc-tools",
 "shlex",
]

[[package]]
name = "cexpr"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6fac387a98bb7c37292057cffc56d62ecb629900026402633ae9160df93a8766"
dependencies = [
 "nom",
]

[[package]]
name = "cfg-if"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9330f8b2ff13f34540b44e946ef35111825727b38d33286ef986142615121801"

[[package]]
name = "clang-sys"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b023947811758c97c59bf9d1c188fd619ad4718dcaa767947df1cadb14f39f4"
dependencies = [
 "glob",
 "libc",
 "libloading",
]

[[package]]
name = "clap"
version = "4.5.58"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "63be97961acde393029492ce0be7a1af7e323e6bae9511ebfac33751be5e6806"
dependencies = [
 "clap_builder",
 "clap_derive",
]

[[package]]
name = "clap-cargo"
version = "0.15.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d546f0e84ff2bfa4da1ce9b54be42285767ba39c688572ca32412a09a73851e5"
dependencies = [
 "anstyle",
 "clap",
]

[[package]]
name = "clap_builder"
version = "4.5.58"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f13174bda5dfd69d7e947827e5af4b0f2f94a4a3ee92912fba07a66150f21e2"
dependencies = [
 "anstream",
 "anstyle",
 "clap_lex",
 "strsim",
]

[[package]]
name = "clap_derive"
version = "4.5.55"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a92793da1a46a5f2a02a6f4c46c6496b28c43638adea8306fcb0caa1634f24e5"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "clap_lex"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3a822ea5bc7590f9d40f1ba12c0dc3c2760f3482c6984db1573ad11031420831"

[[package]]
name = "colorchoice"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b05b61dc5112cbb17e4b6cd61790d9845d13888356391624cbe7e41efeac1e75"

[[package]]
name = "either"
version = "1.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"

[[package]]
name = "errno"
version = "0.3.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "39cab71617ae0d63f51a36d69f866391735b51691dbda63cf6f96d042b63efeb"
dependencies = [
 "libc",
 "windows-sys 0.61.2",
]

[[package]]
name = "find-msvc-tools"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5baebc0774151f905a1a2cc41989300b1e6fbb29aff0ceffa1064fdd3088d582"

[[package]]
name = "fs4"
version = "0.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8640e34b88f7652208ce9e88b1a37a2ae95227d84abec377ccd3c5cfeb141ed4"
dependencies = [
 "rustix",
 "windows-sys 0.59.0",
]

[[package]]
name = "function_traits"
version = "0.1.6"
dependencies = [
 "irql",
]

[[package]]
name = "glob"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0cc23270f6e1808e30a928bdc84dea0b9b4136a8bc82338574f23baf47bbd280"

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "irql"
version = "0.1.6"
dependencies = [
 "irql_alloc",
 "irql_core",
 "irql_macro",
]

[[package]]
name = "irql_alloc"
version = "0.1.6"
dependencies = [
 "irql_core",
 "wdk-sys",
]

[[package]]
name = "irql_core"
version = "0.1.6"

[[package]]
name = "irql_macro"
version = "0.1.6"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "is_terminal_polyfill"
version = "1.70.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a6cb138bb79a146c1bd460005623e142ef0181e3d0219cb493e02f7d08a35695"

[[package]]
name = "itertools"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "413ee7dfc52ee1a4949ceeb7dbc8a33f2d6c088194d9f922fb8318faf1f01186"
dependencies = [
 "either",
]

[[package]]
name = "itoa"
version = "1.0.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "92ecc6618181def0457392ccd0ee51198e065e016d1d527a7ac1b6dc7c1f09d2"

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
name = "libc"
version = "0.2.182"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6800badb6cb2082ffd7b6a67e6125bb39f18782f793520caee8cb8846be06112"

[[package]]
name = "libloading"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d7c4b02199fee7c5d21a5ae7d8cfa79a6ef5bb2fc834d6e9058e89c825efdc55"
dependencies = [
 "cfg-if",
 "windows-link",
]

[[package]]
name = "linux-raw-sys"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df1d3c3b53da64cf5760482273a98e575c651a67eec7f77df96b5b642de8f039"

[[package]]
name = "log"
version = "0.4.29"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e5032e24019045c762d3c0f28f5b6b8bbf38563a65908389bf7978758920897"

[[package]]
name = "matchers"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d1525a2a28c7f4fa0fc98bb91ae755d1e2d1505079e05539e35bc876b5d65ae9"
dependencies = [
 "regex-automata",
]

[[package]]
name = "memchr"
version = "2.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f8ca58f447f06ed17d5fc4043ce1b10dd205e060fb3ce5b979b8ed8e59ff3f79"

[[package]]
name = "minimal-lexical"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"

[[package]]
name = "nom"
version = "7.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
dependencies = [
 "memchr",
 "minimal-lexical",
]

[[package]]
name = "nu-ansi-term"
version = "0.50.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7957b9740744892f114936ab4a57b3f487491bbeafaf8083688b16841a4240e5"
dependencies = [
 "windows-sys 0.61.2",
]

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "once_cell_polyfill"
version = "1.70.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "384b8ab6d37215f3c5301a95a4accb5d64aa607f1fcb26a11b5303878451b4fe"

[[package]]
name = "paste"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57c0d7b74b563b49d38dae00a0c37d4d6de9b432382b2892f0574ddcae73fd0a"

[[package]]
name = "pin-project-lite"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"

[[package]]
name = "prettyplease"
version = "0.2.37"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "479ca8adacdd7ce8f1fb39ce9ecccbfe93a3f1344b3d0d97f20bc0196208f62b"
dependencies = [
 "proc-macro2",
 "syn",
]

[[package]]
name = "proc-macro2"
version = "1.0.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8fd00f0bb2e90d81d1044c2b32617f68fcb9fa3bb7640c23e9c748e53fb30934"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.44"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "21b2ebcf727b7760c461f091f9f0f539b77b8e87f2fd88131e7f1b433b3cece4"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "regex"
version = "1.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e10754a14b9137dd7b1e3e5b0493cc9171fdd105e0ab477f51b72e7f3ac0e276"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "regex-automata"
version = "0.4.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e1dd4122fc1595e8162618945476892eefca7b88c52820e74af6262213cae8f"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a96887878f22d7bad8a3b6dc5b7440e0ada9a245242924394987b21cf2210a4c"

[[package]]
name = "rustc-hash"
version = "2.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "357703d41365b4b27c590e3ed91eabb1b663f07c4c084095e60cbed4362dff0d"

[[package]]
name = "rustix"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "146c9e247ccc180c1f61615433868c99f3de3ae256a30a43b49f67c2d9171f34"
dependencies = [
 "bitflags",
 "errno",
 "libc",
 "linux-raw-sys",
 "windows-sys 0.61.2",
]

[[package]]
name = "rustversion"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"

[[package]]
name = "scratch"
version = "1.0.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d68f2ec51b097e4c1a75b681a8bec621909b5e91f15bb7b840c4f2f7b01148b2"

[[package]]
name = "semver"
version = "1.0.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d767eb0aabc880b29956c35734170f26ed551a859dbd361d140cdbeca61ab1e2"
dependencies = [
 "serde",
 "serde_core",
]

[[package]]
name = "serde"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a8e94ea7f378bd32cbbd37198a4a91436180c5bb472411e48b5ec2e2124ae9e"
dependencies = [
 "serde_core",
 "serde_derive",
]

[[package]]
name = "serde_core"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41d385c7d4ca58e59fc732af25c3983b67ac852c1a25000afe1175de458b67ad"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d540f220d3187173da220f885ab66608367b6574e925011a9353e4badda91d79"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "serde_json"
version = "1.0.149"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "83fc039473c5595ace860d8c4fafa220ff474b3fc6bfdb4293327f1a37e94d86"
dependencies = [
 "itoa",
 "memchr",
 "serde",
 "serde_core",
 "zmij",
]

[[package]]
name = "sharded-slab"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f40ca3c46823713e0d4209592e8d6e826aa57e928f09752619fc696c499637f6"
dependencies = [
 "lazy_static",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "smallvec"
version = "1.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03"

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "struct_example"
version = "0.1.6"
dependencies = [
 "irql",
]

[[package]]
name = "syn"
version = "2.0.115"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e614ed320ac28113fa64972c4262d5dbc89deacdfd00c34a3e4cea073243c12"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "thiserror"
version = "2.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4288b5bcbc7920c07a1149a35cf9590a2aa808e0bc1eafaade0b80947865fbc4"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "2.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ebc4ee7f67670e9b64d05fa4253e753e016c6c95ff35b89b7941d6b856dec1d5"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "thread_local"
version = "1.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f60246a4944f24f6e018aa17cdeffb7818b76356965d03b07d6a9886e8962185"
dependencies = [
 "cfg-if",
]

[[package]]
name = "tracing"
version = "0.1.44"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "63e71662fa4b2a2c3a26f570f037eb95bb1f85397f3cd8076caed2f026a6d100"
dependencies = [
 "pin-project-lite",
 "tracing-attributes",
 "tracing-core",
]

[[package]]
name = "tracing-attributes"
version = "0.1.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7490cfa5ec963746568740651ac6781f701c9c5ea257c58e057f3ba8cf69e8da"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tracing-core"
version = "0.1.36"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "db97caf9d906fbde555dd62fa95ddba9eecfd14cb388e4f491a66d74cd5fb79a"
dependencies = [
 "once_cell",
 "valuable",
]

[[package]]
name = "tracing-log"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee855f1f400bd0e5c02d150ae5de3840039a3f54b025156404e34c23c03f47c3"
dependencies = [
 "log",
 "once_cell",
 "tracing-core",
]

[[package]]
name = "tracing-subscriber"
version = "0.3.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f30143827ddab0d256fd843b7a66d164e9f271cfa0dde49142c5ca0ca291f1e"
dependencies = [
 "matchers",
 "nu-ansi-term",
 "once_cell",
 "regex-automata",
 "sharded-slab",
 "smallvec",
 "thread_local",
 "tracing",
 "tracing-core",
 "tracing-log",
]

[[package]]
name = "unicode-ident"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9312f7c4f6ff9069b165498234ce8be658059c6728633667c526e27dc2cf1df5"

[[package]]
name = "utf8parse"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"

[[package]]
name = "valuable"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba73ea9cf16a25df0c8caa16c51acb937d5712a8429db78a3ee29d5dcacd3a65"

[[package]]
name = "wdk-build"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c150122a579af759770b354064cd2994d29e97525d904f65ff1412ad5122766"
dependencies = [
 "anyhow",
 "bindgen",
 "camino",
 "cargo_metadata",
 "cfg-if",
 "clap",
 "clap-cargo",
 "paste",
 "regex",
 "rustversion",
 "semver",
 "serde",
 "serde_json",
 "thiserror",
 "tracing",
 "windows",
]

[[package]]
name = "wdk-macros"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b288d5ef6b276345d197fe0b82ef274dcb5a1f658a2294c67ff85b775f63ee26"
dependencies = [
 "cfg-if",
 "fs4",
 "itertools",
 "proc-macro2",
 "quote",
 "scratch",
 "serde",
 "serde_json",
 "syn",
]

[[package]]
name = "wdk-sys"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e13e19ed97609bc1d1236806019309ca2d47aaad6d3217ab374e73c9ff3b8a9"
dependencies = [
 "anyhow",
 "bindgen",
 "cargo_metadata",
 "cc",
 "cfg-if",
 "rustversion",
 "serde_json",
 "thiserror",
 "tracing",
 "tracing-subscriber",
 "wdk-build",
 "wdk-macros",
]

[[package]]
name = "windows"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dd04d41d93c4992d421894c18c8b43496aa748dd4c081bac0dc93eb0489272b6"
dependencies = [
 "windows-core",
 "windows-targets",
]

[[package]]
name = "windows-core"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6ba6d44ec8c2591c134257ce647b7ea6b20335bf6379a27dac5f1641fcf59f99"
dependencies = [
 "windows-implement",
 "windows-interface",
 "windows-result",
 "windows-strings",
 "windows-targets",
]

[[package]]
name = "windows-implement"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2bbd5b46c938e506ecbce286b6628a02171d56153ba733b6c741fc627ec9579b"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-interface"
version = "0.58.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "053c4c462dc91d3b1504c6fe5a726dd15e216ba718e84a0e46a88fbe5ded3515"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-link"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0805222e57f7521d6a62e36fa9163bc891acd422f971defe97d64e70d0a4fe5"

[[package]]
name = "windows-result"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d1043d8214f791817bab27572aaa8af63732e11bf84aa21a45a78d6c317ae0e"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-strings"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4cd9b125c486025df0eabcb585e62173c6c9eddcec5d117d3b6e8c30e2ee4d10"
dependencies = [
 "windows-result",
 "windows-targets",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-sys"
version = "0.61.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ae137229bcbd6cdf0f7b80a31df61766145077ddf49416a728b02cb3921ff3fc"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_gnullvm",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "zmij"
version = "1.0.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8848ee67ecc8aedbaf3e4122217aff892639231befc6a1b58d29fff4c2cabaa"

```

`Cargo.toml`:

```toml
[workspace]
resolver = "3"
members = ["crates/*", "examples/*"]

[workspace.package]
version = "0.1.6"
edition = "2024"
license = "MIT OR Apache-2.0"
repository = "https://github.com/naorhaziz/irql"
keywords = ["windows", "kernel", "irql", "driver"]
categories = ["no-std", "development-tools"]

```

`LICENSE-APACHE`:

```
                              Apache License
                        Version 2.0, January 2004
                     http://www.apache.org/licenses/

TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

1. Definitions.

   "License" shall mean the terms and conditions for use, reproduction,
   and distribution as defined by Sections 1 through 9 of this document.

   "Licensor" shall mean the copyright owner or entity authorized by
   the copyright owner that is granting the License.

   "Legal Entity" shall mean the union of the acting entity and all
   other entities that control, are controlled by, or are under common
   control with that entity. For the purposes of this definition,
   "control" means (i) the power, direct or indirect, to cause the
   direction or management of such entity, whether by contract or
   otherwise, or (ii) ownership of fifty percent (50%) or more of the
   outstanding shares, or (iii) beneficial ownership of such entity.

   "You" (or "Your") shall mean an individual or Legal Entity
   exercising permissions granted by this License.

   "Source" form shall mean the preferred form for making modifications,
   including but not limited to software source code, documentation
   source, and configuration files.

   "Object" form shall mean any form resulting from mechanical
   transformation or translation of a Source form, including but
   not limited to compiled object code, generated documentation,
   and conversions to other media types.

   "Work" shall mean the work of authorship, whether in Source or
   Object form, made available under the License, as indicated by a
   copyright notice that is included in or attached to the work
   (an example is provided in the Appendix below).

   "Derivative Works" shall mean any work, whether in Source or Object
   form, that is based on (or derived from) the Work and for which the
   editorial revisions, annotations, elaborations, or other modifications
   represent, as a whole, an original work of authorship. For the purposes
   of this License, Derivative Works shall not include works that remain
   separable from, or merely link (or bind by name) to the interfaces of,
   the Work and Derivative Works thereof.

   "Contribution" shall mean any work of authorship, including
   the original version of the Work and any modifications or additions
   to that Work or Derivative Works thereof, that is intentionally
   submitted to Licensor for inclusion in the Work by the copyright owner
   or by an individual or Legal Entity authorized to submit on behalf of
   the copyright owner. For the purposes of this definition, "submitted"
   means any form of electronic, verbal, or written communication sent
   to the Licensor or its representatives, including but not limited to
   communication on electronic mailing lists, source code control systems,
   and issue tracking systems that are managed by, or on behalf of, the
   Licensor for the purpose of discussing and improving the Work, but
   excluding communication that is conspicuously marked or otherwise
   designated in writing by the copyright owner as "Not a Contribution."

   "Contributor" shall mean Licensor and any individual or Legal Entity
   on behalf of whom a Contribution has been received by Licensor and
   subsequently incorporated within the Work.

2. Grant of Copyright License. Subject to the terms and conditions of
   this License, each Contributor hereby grants to You a perpetual,
   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
   copyright license to reproduce, prepare Derivative Works of,
   publicly display, publicly perform, sublicense, and distribute the
   Work and such Derivative Works in Source or Object form.

3. Grant of Patent License. Subject to the terms and conditions of
   this License, each Contributor hereby grants to You a perpetual,
   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
   (except as stated in this section) patent license to make, have made,
   use, offer to sell, sell, import, and otherwise transfer the Work,
   where such license applies only to those patent claims licensable
   by such Contributor that are necessarily infringed by their
   Contribution(s) alone or by combination of their Contribution(s)
   with the Work to which such Contribution(s) was submitted. If You
   institute patent litigation against any entity (including a
   cross-claim or counterclaim in a lawsuit) alleging that the Work
   or a Contribution incorporated within the Work constitutes direct
   or contributory patent infringement, then any patent licenses
   granted to You under this License for that Work shall terminate
   as of the date such litigation is filed.

4. Redistribution. You may reproduce and distribute copies of the
   Work or Derivative Works thereof in any medium, with or without
   modifications, and in Source or Object form, provided that You
   meet the following conditions:

   (a) You must give any other recipients of the Work or
       Derivative Works a copy of this License; and

   (b) You must cause any modified files to carry prominent notices
       stating that You changed the files; and

   (c) You must retain, in the Source form of any Derivative Works
       that You distribute, all copyright, patent, trademark, and
       attribution notices from the Source form of the Work,
       excluding those notices that do not pertain to any part of
       the Derivative Works; and

   (d) If the Work includes a "NOTICE" text file as part of its
       distribution, then any Derivative Works that You distribute must
       include a readable copy of the attribution notices contained
       within such NOTICE file, excluding those notices that do not
       pertain to any part of the Derivative Works, in at least one
       of the following places: within a NOTICE text file distributed
       as part of the Derivative Works; within the Source form or
       documentation, if provided along with the Derivative Works; or,
       within a display generated by the Derivative Works, if and
       wherever such third-party notices normally appear. The contents
       of the NOTICE file are for informational purposes only and
       do not modify the License. You may add Your own attribution
       notices within Derivative Works that You distribute, alongside
       or as an addendum to the NOTICE text from the Work, provided
       that such additional attribution notices cannot be construed
       as modifying the License.

   You may add Your own copyright statement to Your modifications and
   may provide additional or different license terms and conditions
   for use, reproduction, or distribution of Your modifications, or
   for any such Derivative Works as a whole, provided Your use,
   reproduction, and distribution of the Work otherwise complies with
   the conditions stated in this License.

5. Submission of Contributions. Unless You explicitly state otherwise,
   any Contribution intentionally submitted for inclusion in the Work
   by You to the Licensor shall be under the terms and conditions of
   this License, without any additional terms or conditions.
   Notwithstanding the above, nothing herein shall supersede or modify
   the terms of any separate license agreement you may have executed
   with Licensor regarding such Contributions.

6. Trademarks. This License does not grant permission to use the trade
   names, trademarks, service marks, or product names of the Licensor,
   except as required for reasonable and customary use in describing the
   origin of the Work and reproducing the content of the NOTICE file.

7. Disclaimer of Warranty. Unless required by applicable law or
   agreed to in writing, Licensor provides the Work (and each
   Contributor provides its Contributions) on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   implied, including, without limitation, any warranties or conditions
   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
   PARTICULAR PURPOSE. You are solely responsible for determining the
   appropriateness of using or redistributing the Work and assume any
   risks associated with Your exercise of permissions under this License.

8. Limitation of Liability. In no event and under no legal theory,
   whether in tort (including negligence), contract, or otherwise,
   unless required by applicable law (such as deliberate and grossly
   negligent acts) or agreed to in writing, shall any Contributor be
   liable to You for damages, including any direct, indirect, special,
   incidental, or consequential damages of any character arising as a
   result of this License or out of the use or inability to use the
   Work (including but not limited to damages for loss of goodwill,
   work stoppage, computer failure or malfunction, or any and all
   other commercial damages or losses), even if such Contributor
   has been advised of the possibility of such damages.

9. Accepting Warranty or Additional Liability. While redistributing
   the Work or Derivative Works thereof, You may choose to offer,
   and charge a fee for, acceptance of support, warranty, indemnity,
   or other liability obligations and/or rights consistent with this
   License. However, in accepting such obligations, You may act only
   on Your own behalf and on Your sole responsibility, not on behalf
   of any other Contributor, and only if You agree to indemnify,
   defend, and hold each Contributor harmless for any liability
   incurred by, or claims asserted against, such Contributor by reason
   of your accepting any such warranty or additional liability.

END OF TERMS AND CONDITIONS

APPENDIX: How to apply the Apache License to your work.

   To apply the Apache License to your work, attach the following
   boilerplate notice, with the fields enclosed by brackets "[]"
   replaced with your own identifying information. (Don't include
   the brackets!)  The text should be enclosed in the appropriate
   comment syntax for the file format. We also recommend that a
   file or class name and description of purpose be included on the
   same "printed page" as the copyright notice for easier
   identification within third-party archives.

Copyright 2026 Naor Haziz

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
```

`LICENSE-MIT`:

```
MIT License

Copyright (c) 2026 Naor Haziz

Permission is hereby granted, free of charge, to any
person obtaining a copy of this software and associated
documentation files (the "Software"), to deal in the
Software without restriction, including without
limitation the rights to use, copy, modify, merge,
publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software
is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice
shall be included in all copies or substantial portions
of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
```

`README.md`:

```md
<p align="center">
  <img src="https://github.com/naorhaziz/irql/blob/main/Logo.png?raw=true" alt="irql" width="350">
</p>

<h1 align="center">IRQL — Compile-Time IRQL Safety for Windows Kernel Drivers</h1>

<p align="center">
  <a href="https://crates.io/crates/irql"><img src="https://img.shields.io/crates/v/irql.svg" alt="Crates.io"></a>
  <a href="https://docs.rs/irql"><img src="https://docs.rs/irql/badge.svg" alt="Documentation"></a>
  <a href="https://github.com/naorhaziz/irql/actions/workflows/ci.yml"><img src="https://github.com/naorhaziz/irql/actions/workflows/ci.yml/badge.svg" alt="CI"></a>
  <a href="LICENSE-MIT"><img src="https://img.shields.io/badge/License-MIT-blue.svg" alt="License: MIT"></a>
  <a href="LICENSE-APACHE"><img src="https://img.shields.io/badge/License-Apache%202.0-blue.svg" alt="License: Apache 2.0"></a>
</p>

<p align="center">
  IRQL violations cause blue screens. This crate catches them at compile time.<br>
  <strong>Zero runtime cost. Zero binary overhead.</strong>
</p>

---

```toml
[dependencies]
irql = "0.1.6"
```

```rust
use irql::{irql, Dispatch, Passive};

#[irql(max = Dispatch)]
fn acquire_spinlock() { /* … */ }

#[irql(max = Passive)]
fn driver_routine() {
    call_irql!(acquire_spinlock()); // Passive can raise to Dispatch
}

#[irql(at = Passive)]
fn driver_entry() {
    call_irql!(driver_routine());
}
```

If it compiles, your IRQL transitions are valid.

## How it works

`#[irql(max = Dispatch)]` adds a hidden `IRQL` type parameter bounded by `IrqlCanRaiseTo<Dispatch>`. `call_irql!` threads it through every call as a turbofish argument. The compiler checks every transition — trying to lower IRQL is a compile error:

```text
error[E0277]: IRQL violation: cannot reach `Passive` from `Dispatch`
              -- would require lowering
```

## The `#[irql()]` attribute

| Form                        | Meaning                                    |
| --------------------------- | ------------------------------------------ |
| `#[irql(at = Level)]`       | Fixed entry point — known IRQL, no generic |
| `#[irql(max = Level)]`      | Callable from `Level` or below             |
| `#[irql(min = A, max = B)]` | Callable in \[A, B\]                       |

Works on **functions**, **impl blocks**, and **trait impl blocks**.

## IRQL levels

| Value | Type       | Description                    |
| ----- | ---------- | ------------------------------ |
| 0     | `Passive`  | Normal thread; paged memory OK |
| 1     | `Apc`      | APC delivery                   |
| 2     | `Dispatch` | DPC / spinlock                 |
| 3–26  | `Dirql`    | Device interrupts              |
| 27    | `Profile`  | Profiling timer                |
| 28    | `Clock`    | Clock interrupt                |
| 29    | `Ipi`      | Inter-processor interrupt      |
| 30    | `Power`    | Power failure                  |
| 31    | `High`     | Highest — machine check        |

## Impl blocks

Apply `#[irql]` to an entire `impl` block — every method gets the constraint:

```rust
struct Device { name: &'static str }

#[irql(max = Dispatch)]
impl Device {
    fn new(name: &'static str) -> Self { Device { name } }
    fn process(&self) { /* … */ }
}
```

## Function traits

`IrqlFn`, `IrqlFnMut`, `IrqlFnOnce` — IRQL-aware analogues of `Fn`, `FnMut`, `FnOnce`:

```rust
#[irql(max = Passive)]
impl IrqlFn<()> for Reader {
    type Output = u32;
    fn call(&self, _: ()) -> u32 { self.value }
}
```

The macro rewrites `IrqlFn<()>` to `IrqlFn<Passive, ()>` automatically.

## IRQL-aware allocation (nightly)

```toml
irql = { version = "0.1.6", features = ["alloc"] }
```

Requires nightly (`allocator_api`, `vec_push_within_capacity`, `auto_traits`, `negative_impls`).

### Pool types

| Pool           | Allocable at                 | Accessible at    |
| -------------- | ---------------------------- | ---------------- |
| `PagedPool`    | `Passive`, `Apc`             | `Passive`, `Apc` |
| `NonPagedPool` | `Passive`, `Apc`, `Dispatch` | Any IRQL         |

`IrqlBox::new` and `IrqlVec::new` pick the cheapest legal pool automatically.

### IrqlBox and IrqlVec

```rust
#[irql(max = Passive)]
fn example() -> Result<(), AllocError> {
    let data = call_irql!(IrqlBox::new(42))?;
    let val = call_irql!(data.get());

    let v = irql_vec![1, 2, 3]?;
    call_irql!(v.push(42))?;

    // FFI: transfer ownership via raw pointer
    let ptr = data.into_raw();
    let data = unsafe { IrqlBox::<_, PagedPool>::from_raw(ptr) };
    Ok(())
}
```

### Drop safety

Paged-pool containers cannot be dropped at `Dispatch` or above. The `#[irql]` macro injects `SafeToDropAt<Level>` bounds on by-value parameters, so passing paged-pool memory into elevated-IRQL code is a compile error. References (`&IrqlBox`) are not gated. Use `leak()` or `into_raw()` to transfer ownership across IRQL boundaries.

## Crate architecture

```text
irql           ← public facade (re-exports everything)
├── irql_core  ← levels, hierarchy traits, function traits, SafeToDropAt
├── irql_macro ← #[irql] proc macro, call_irql! rewriter
└── irql_alloc ← IrqlBox, IrqlVec, pool allocator (optional, nightly)
```

## Safety

All checks are compile-time only. You must ensure entry points (`#[irql(at = …)]`) match the actual runtime IRQL and that IRQL-raising operations are properly modelled.

## License

[MIT](LICENSE-MIT) or [Apache 2.0](LICENSE-APACHE), at your option.

```

`crates/irql/Cargo.toml`:

```toml
[package]
name = "irql"
version.workspace = true
edition.workspace = true
description = "Compile-time IRQL safety for Windows kernel drivers"
license.workspace = true
repository.workspace = true
documentation = "https://docs.rs/irql"
keywords.workspace = true
categories.workspace = true
readme = "../../README.md"

[package.metadata.docs.rs]
default-target = "x86_64-pc-windows-msvc"
targets = ["x86_64-pc-windows-msvc"]

[features]
default = []
## `SafeToDropAt*` auto traits for compile-time drop-safety checks.
## **Requires nightly** (`#![feature(auto_traits)]`).
## Automatically enabled by `alloc`.
drop-safety = ["irql_core/drop-safety"]
## IRQL-aware kernel pool allocator types (`IrqlBox`, `IrqlVec`).
## **Requires nightly** (`#![feature(allocator_api)]`).
alloc = ["dep:irql_alloc", "drop-safety"]

[dependencies]
irql_core = { version = "0.1.6", path = "../irql_core" }
irql_macro = { version = "0.1.6", path = "../irql_macro" }
irql_alloc = { version = "0.1.6", path = "../irql_alloc", optional = true }

```

`crates/irql/src/lib.rs`:

```rs
//! Compile-time IRQL safety for Windows kernel drivers.
//!
//! IRQL violations are caught at compile time using Rust's type system —
//! zero runtime cost, zero binary size overhead.
//!
//! # Quick start
//!
//! ```no_run
//! use irql::{irql, Dispatch, Passive};
//!
//! #[irql(max = Dispatch)]
//! fn acquire_spinlock() { /* … */ }
//!
//! #[irql(at = Passive)]
//! fn driver_entry() {
//!     call_irql!(acquire_spinlock());
//! }
//! ```
//!
//! # The `#[irql()]` attribute
//!
//! | Form | Meaning |
//! |------|---------|
//! | `#[irql(at = Level)]` | Fixed entry point — known IRQL, no generic |
//! | `#[irql(max = Level)]` | Callable from `Level` or below |
//! | `#[irql(min = A, max = B)]` | Callable in the range \[A, B\] |
//!
//! `max` is **required** unless using `at` — it defines the ceiling that
//! `call_irql!` relies on. `min` is optional and adds a floor constraint.
//! `at` is mutually exclusive with `min`/`max`.
//!
//! Works on **functions**, **inherent impl blocks**, and **trait impl blocks**.
//!
//! # IRQL levels
//!
//! | Value | Type | Description |
//! |-------|------|-------------|
//! | 0 | [`Passive`] | Normal thread execution; paged memory OK |
//! | 1 | [`Apc`] | APC delivery |
//! | 2 | [`Dispatch`] | DPC / spinlock level |
//! | 3–26 | [`Dirql`] | Device interrupt levels |
//! | 27 | [`Profile`] | Profiling timer |
//! | 28 | [`Clock`] | Clock interrupt |
//! | 29 | [`Ipi`] | Inter-processor interrupt |
//! | 30 | [`Power`] | Power failure |
//! | 31 | [`High`] | Highest — machine check |
//!
//! Each level is a zero-sized marker type implementing [`IrqlLevel`].
//!
//! # The golden rule
//!
//! **IRQL can only stay the same or be raised, never lowered.**
//!
//! Attempting to call a lower-IRQL function produces a compile error:
//!
//! ```compile_fail
//! use irql::{irql, Dispatch, Passive};
//!
//! #[irql(max = Passive)]
//! fn passive_only() {}
//!
//! #[irql(max = Dispatch)]
//! fn at_dispatch() {
//!     call_irql!(passive_only()); // ERROR: cannot lower IRQL
//! }
//! ```
//!
//! # IRQL-aware allocation (`alloc` feature)
//!
//! Enable with `irql = { features = ["alloc"] }`.
//!
//! **Requires a nightly Rust compiler** — depends on unstable
//! `allocator_api`, `vec_push_within_capacity`, `auto_traits`, and
//! `negative_impls`. Add a `rust-toolchain.toml` with
//! `channel = "nightly"` to your project.
//!
//! Pool allocations automatically use `ExAllocatePool2` / `ExFreePool`
//! from [`wdk-sys`](https://crates.io/crates/wdk-sys) in WDM/KMDF driver
//! builds. Outside a WDK build (e.g. testing), the global allocator is
//! used as a fallback.
//!
//! `IrqlBox` and `IrqlVec` enforce pool rules at compile time:
//!
//! ```ignore
//! #[irql(max = Passive)]
//! fn example() -> Result<(), AllocError> {
//!     let data = call_irql!(IrqlBox::new(42))?;  // PagedPool (automatic)
//!     let val = call_irql!(data.get());
//!
//!     let v = irql_vec![1, 2, 3]?;
//!     Ok(())
//! }
//! ```
//!
//! ## FFI interop
//!
//! `IrqlBox` provides raw pointer methods for passing allocations to
//! kernel APIs and C callbacks:
//!
//! ```ignore
//! let b = call_irql!(IrqlBox::new(data))?;
//! let ptr = b.into_raw();  // pass to kernel API
//! // later, reconstruct:
//! let b = unsafe { IrqlBox::<_, PagedPool>::from_raw(ptr) };
//! ```
//!
//! # Drop safety
//!
//! Paged-pool containers (`IrqlBox<T, PagedPool>`, `IrqlVec<T, PagedPool>`)
//! must not be dropped at `Dispatch` or above.  This is enforced at compile
//! time via `SafeToDropAt*` auto traits (enabled automatically with `alloc`).
//! The `#[irql]` macro injects `T: SafeToDropAt<Level>` bounds on by-value
//! parameters, so passing a paged-pool value (or any struct containing one)
//! by value into code at `Dispatch`+ is a compile error.
//!
//! References (`&IrqlBox`) are *not* gated — they don't trigger a drop.
//! Use `IrqlBox::leak()` or `IrqlBox::into_raw()` when you need to transfer
//! ownership across an IRQL boundary.
//!
//! # Safety
//!
//! All checks are compile-time only. You must ensure:
//! - Entry points (`#[irql(at = …)]`) match the actual runtime IRQL.
//! - IRQL-raising operations (spinlocks, etc.) are properly modelled.

#![no_std]
#![deny(missing_docs)]
#![deny(rustdoc::broken_intra_doc_links)]
#![cfg_attr(feature = "alloc", feature(allocator_api))]

// Re-export IRQL level types and hierarchy traits.
pub use irql_core::{
    Apc, Clock, Dirql, Dispatch, High, Ipi, IrqlCanLowerTo, IrqlCanRaiseTo, IrqlLevel, Passive,
    Power, Profile,
};

// SafeToDropAt<L> is always available (blanket-impl'd without `drop-safety`).
pub use irql_core::SafeToDropAt;

// Per-level auto traits (only with `drop-safety` / `alloc`).
#[cfg(feature = "drop-safety")]
pub use irql_core::{
    SafeToDropAtApc, SafeToDropAtClock, SafeToDropAtDirql, SafeToDropAtDispatch, SafeToDropAtHigh,
    SafeToDropAtIpi, SafeToDropAtPassive, SafeToDropAtPower, SafeToDropAtProfile,
};

// IRQL-safe function traits.
pub use irql_core::{IrqlFn, IrqlFnMut, IrqlFnOnce};

#[doc(hidden)]
pub use irql_macro::call_irql_inner;

/// Compile-time IRQL constraint.
///
/// Annotate functions and impl blocks to enforce IRQL rules at compile time.
///
/// # Forms
///
/// | Syntax | Meaning |
/// |--------|--------|
/// | `#[irql(at = Passive)]` | Fixed entry point (no generic added) |
/// | `#[irql(max = Dispatch)]` | Callable from Dispatch or below |
/// | `#[irql(min = Apc, max = Dispatch)]` | Callable in \[Apc, Dispatch\] |
///
/// `max` is **required** unless using `at`. `min` is optional.
///
/// # Supported targets
///
/// - **Functions** — adds an `IRQL` generic type parameter.
/// - **Inherent impl blocks** — each method gets its own `IRQL` generic.
/// - **Trait impl blocks** — e.g. `impl IrqlFn<()> for T` — the macro
///   rewrites the trait's generic arguments and constrains each method.
///
/// # How `call_irql!` works
///
/// Inside an `#[irql]` body, a local `call_irql!` macro is injected that
/// rewrites `call_irql!(f(args))` into `f::<IRQL>(args)`, threading the
/// IRQL type through every call in the chain.
pub use irql_macro::irql;

// IRQL-aware allocator types (optional `alloc` feature, requires nightly).
#[cfg(feature = "alloc")]
pub use irql_alloc::{
    AccessibleAt, AllocError, AllocableAt, DefaultPool, IrqlBox, IrqlVec, NonPagedPool, PagedPool,
    PoolAlloc, PoolAllocator, TryReserveError, irql_vec,
};

```

`crates/irql_alloc/Cargo.toml`:

```toml
[package]
name = "irql_alloc"
version.workspace = true
edition.workspace = true
license.workspace = true
repository.workspace = true
keywords.workspace = true
categories.workspace = true
documentation = "https://docs.rs/irql"
description = "IRQL-aware kernel pool allocator types (requires nightly)"
readme = "../../README.md"

[lints.rust]
unexpected_cfgs = { level = "warn", check-cfg = [
    'cfg(driver_model__driver_type, values("WDM", "KMDF"))',
] }

[package.metadata.docs.rs]
default-target = "x86_64-pc-windows-msvc"
targets = ["x86_64-pc-windows-msvc"]

[dependencies]
irql_core = { version = "0.1.6", path = "../irql_core", features = [
    "drop-safety",
] }
wdk-sys = { version = "0.5.1", default-features = false }

```

`crates/irql_alloc/src/irql_box.rs`:

```rs
//! IRQL-aware heap-allocated value.
//!
//! [`IrqlBox`] wraps a value in a kernel pool allocation (paged or non-paged)
//! and enforces IRQL constraints at compile time for both allocation and access.
//!
//! # Pool selection
//!
//! | Method | Pool chosen |
//! |--------|-------------|
//! | [`IrqlBox::new`] | Automatic — [`PagedPool`](crate::PagedPool) at `Passive`/`Apc`, [`NonPagedPool`](crate::NonPagedPool) at `Dispatch` |
//! | [`IrqlBox::new_in`] | Explicit — you specify the pool type parameter |
//!
//! # Drop safety
//!
//! `PagedPool` opts out of `SafeToDropAtDispatch` and above via negative
//! impls (auto traits defined in `irql_core`).  Because `IrqlBox` contains
//! `PagedPool` via `PhantomData`, it inherits those opt-outs automatically.
//! The `#[irql]` macro injects `SafeToDropAt<Level>` bounds on by-value
//! parameters, so passing an `IrqlBox<T, PagedPool>` by value to a
//! function at `Dispatch` or above is a compile error.
//!
//! Use [`leak()`](IrqlBox::leak) or [`into_raw()`](IrqlBox::into_raw)
//! to transfer ownership without dropping.

use alloc::boxed::Box;

use irql_core::IrqlLevel;

use core::alloc::AllocError;

use crate::pool::{AccessibleAt, AllocableAt, DefaultPool, PoolAlloc, PoolAllocator};

/// A heap-allocated value in a kernel pool, with compile-time IRQL access
/// control.
///
/// Wraps [`Box<T, PoolAlloc<P>>`](alloc::boxed::Box) so you get correct
/// allocation/deallocation automatically. Access goes through
/// [`get`](IrqlBox::get) / [`get_mut`](IrqlBox::get_mut), which enforce
/// IRQL constraints at compile time.
///
/// [`Deref`](core::ops::Deref) and [`DerefMut`](core::ops::DerefMut) are
/// intentionally **not** implemented — all access must go through the
/// IRQL-gated [`get`](IrqlBox::get) / [`get_mut`](IrqlBox::get_mut)
/// methods so the compiler can verify the access is safe at the current
/// IRQL.
///
/// # Construction
///
/// ```ignore
/// // Automatic pool (PagedPool at Passive, NonPagedPool at Dispatch):
/// let data = call_irql!(IrqlBox::new(42))?;
///
/// // Explicit pool:
/// let data = call_irql!(IrqlBox::<_, NonPagedPool>::new_in(42))?;
/// ```
pub struct IrqlBox<T, P: PoolAllocator + 'static> {
    inner: Box<T, PoolAlloc<P>>,
}

impl<T, P: PoolAllocator + 'static> IrqlBox<T, P> {
    /// Allocate a value using the default pool for the current IRQL.
    ///
    /// The pool is selected automatically via [`DefaultPool`]:
    /// - `Passive` / `Apc` → [`PagedPool`](crate::PagedPool)
    /// - `Dispatch` → [`NonPagedPool`](crate::NonPagedPool)
    /// - `Dirql`+ → **compile error**
    ///
    /// `call_irql!` injects the IRQL type; `T` and `P` are inferred.
    ///
    /// ```ignore
    /// let data = call_irql!(IrqlBox::new(42))?;
    /// ```
    pub fn new<IRQL: DefaultPool<Pool = P>>(value: T) -> Result<Self, AllocError>
    where
        P: AllocableAt<IRQL>,
    {
        let inner = Box::try_new_in(value, PoolAlloc::new())?;
        Ok(IrqlBox { inner })
    }

    /// Allocate a value in a specific pool, overriding [`DefaultPool`] selection.
    ///
    /// Use this when you need [`NonPagedPool`](crate::NonPagedPool) at low IRQL
    /// (e.g. memory that will be passed to a DPC or ISR).
    ///
    /// ```ignore
    /// let data = call_irql!(IrqlBox::<_, NonPagedPool>::new_in(42))?;
    /// ```
    pub fn new_in<IRQL: IrqlLevel>(value: T) -> Result<Self, AllocError>
    where
        P: AllocableAt<IRQL>,
    {
        let inner = Box::try_new_in(value, PoolAlloc::new())?;
        Ok(IrqlBox { inner })
    }

    /// Shared reference to the contained value.
    ///
    /// ```ignore
    /// let val = call_irql!(data.get());
    /// ```
    pub fn get<IRQL: IrqlLevel>(&self) -> &T
    where
        P: AccessibleAt<IRQL>,
    {
        &self.inner
    }

    /// Mutable reference to the contained value.
    ///
    /// ```ignore
    /// let val = call_irql!(data.get_mut());
    /// ```
    pub fn get_mut<IRQL: IrqlLevel>(&mut self) -> &mut T
    where
        P: AccessibleAt<IRQL>,
    {
        &mut self.inner
    }

    /// Consume the box and return the inner value.
    ///
    /// ```ignore
    /// let value = call_irql!(data.into_inner());
    /// ```
    pub fn into_inner<IRQL: IrqlLevel>(self) -> T
    where
        P: AccessibleAt<IRQL>,
    {
        *self.inner
    }

    /// Consume the box **without** deallocating, returning `&'static mut T`.
    ///
    /// Useful when you need to transfer a [`PagedPool`](crate::PagedPool)
    /// allocation to code running at elevated IRQL without triggering a
    /// drop.
    ///
    /// # Example
    ///
    /// ```ignore
    /// #[irql(max = Passive)]
    /// fn prepare_for_dpc() -> Result<&'static mut u32, AllocError> {
    ///     let b = call_irql!(IrqlBox::new(0u32))?;
    ///     Ok(b.leak()) // won't be freed when IRQL rises
    /// }
    /// ```
    #[must_use = "not using the reference will leak memory with no handle"]
    pub fn leak(self) -> &'static mut T {
        Box::leak(self.inner)
    }

    /// Consume the box and return a raw pointer without deallocating.
    ///
    /// The caller is responsible for eventually freeing the memory by
    /// reconstructing the `IrqlBox` via [`from_raw`](IrqlBox::from_raw).
    ///
    /// **No IRQL gate** — useful for transferring ownership across IRQL
    /// boundaries through raw pointers.
    #[must_use = "not using the pointer will leak memory"]
    pub fn into_raw(self) -> *mut T {
        let (ptr, _alloc) = Box::into_raw_with_allocator(self.inner);
        ptr
    }

    /// Reconstruct an `IrqlBox` from a raw pointer previously obtained via
    /// [`into_raw`](IrqlBox::into_raw).
    ///
    /// # Safety
    ///
    /// - `ptr` must have been produced by `IrqlBox::<T, P>::into_raw`.
    /// - The pool type `P` must match the original allocation — a mismatch
    ///   will free memory with the wrong pool, causing corruption or a bugcheck.
    /// - The pointer must not have been freed already.
    pub unsafe fn from_raw(ptr: *mut T) -> Self {
        IrqlBox {
            inner: unsafe { Box::from_raw_in(ptr, PoolAlloc::new()) },
        }
    }
}

// SAFETY: `IrqlBox` is `Send` when `T: Send` because the inner `Box` owns
// `T` exclusively, and pool memory itself has no thread affinity.  The
// `PoolAlloc<P>` allocator is a ZST with no state.
unsafe impl<T: Send, P: PoolAllocator + 'static> Send for IrqlBox<T, P> {}

// SAFETY: `IrqlBox` is `Sync` when `T: Sync` because shared access to the
// inner `T` is only possible through `&IrqlBox`, which yields `&T` via
// `get()`. The pool allocator is stateless.
unsafe impl<T: Sync, P: PoolAllocator + 'static> Sync for IrqlBox<T, P> {}

```

`crates/irql_alloc/src/irql_vec.rs`:

```rs
//! IRQL-aware dynamically-sized array.
//!
//! [`IrqlVec`] wraps a [`Vec`] with a kernel pool allocator and enforces
//! IRQL constraints at compile time for allocation, mutation, and access.
//!
//! All operations that may allocate are **fallible** — they return
//! `Result` instead of panicking on OOM. This is essential for kernel code
//! where allocation failure must be handled gracefully.
//!
//! # Quick start
//!
//! ```ignore
//! #[irql(max = Passive)]
//! fn example() -> Result<(), TryReserveError> {
//!     let v = irql_vec![1, 2, 3]?;
//!     let s = call_irql!(v.as_slice());       // &[1, 2, 3]
//!
//!     let mut v = irql_vec![0u8; 64]?;        // 64 zeroes
//!     call_irql!(v.push(0xFF))?;              // now 65 elements
//!     Ok(())
//! }
//! ```

use alloc::{collections::TryReserveError, vec::Vec};

use irql_core::IrqlLevel;

use crate::pool::{AccessibleAt, AllocableAt, DefaultPool, PoolAlloc, PoolAllocator};

/// A dynamically-sized array in a kernel pool, with compile-time IRQL access
/// control.
///
/// Thin wrapper around [`Vec<T, PoolAlloc<P>>`](alloc::vec::Vec) that gates
/// every method behind IRQL constraints. Only exposes fallible
/// (no-global-oom-handling) APIs — every operation that may allocate returns
/// a [`Result`].
///
/// [`Index`](core::ops::Index) and [`Deref`](core::ops::Deref) are
/// intentionally **not** implemented — all access must go through
/// IRQL-gated methods so the compiler can verify safety.
pub struct IrqlVec<T, P: PoolAllocator> {
    inner: Vec<T, PoolAlloc<P>>,
}

// ---------------------------------------------------------------------------
// Constructors
// ---------------------------------------------------------------------------

impl<T, P: PoolAllocator> IrqlVec<T, P> {
    /// Create a new empty `IrqlVec` (does **not** allocate).
    pub fn new<IRQL: DefaultPool<Pool = P>>() -> Self
    where
        P: AllocableAt<IRQL>,
    {
        IrqlVec {
            inner: Vec::new_in(PoolAlloc::new()),
        }
    }

    /// Create a new empty `IrqlVec` with pre-reserved capacity.
    pub fn with_capacity<IRQL: DefaultPool<Pool = P>>(cap: usize) -> Result<Self, TryReserveError>
    where
        P: AllocableAt<IRQL>,
    {
        let mut v = Vec::new_in(PoolAlloc::new());
        v.try_reserve(cap)?;
        Ok(IrqlVec { inner: v })
    }

    /// Build an `IrqlVec` from an iterator (backbone of `irql_vec!`).
    pub fn try_from_iter<IRQL: DefaultPool<Pool = P>>(
        iter: impl IntoIterator<Item = T>,
    ) -> Result<Self, TryReserveError>
    where
        P: AllocableAt<IRQL>,
    {
        let iter = iter.into_iter();
        let (hint, _) = iter.size_hint();
        let mut v = Vec::new_in(PoolAlloc::new());
        v.try_reserve(hint)?;
        for item in iter {
            v.try_reserve(1)?;
            // Infallible — we just reserved one slot.
            let _ = v.push_within_capacity(item);
        }
        Ok(IrqlVec { inner: v })
    }
}

// ---------------------------------------------------------------------------
// Capacity — forwards Vec::try_reserve / try_reserve_exact
// ---------------------------------------------------------------------------

impl<T, P: PoolAllocator> IrqlVec<T, P> {
    /// Forwards [`Vec::try_reserve`].
    pub fn try_reserve<IRQL: IrqlLevel>(&mut self, additional: usize) -> Result<(), TryReserveError>
    where
        P: AllocableAt<IRQL>,
    {
        self.inner.try_reserve(additional)
    }

    /// Forwards [`Vec::try_reserve_exact`].
    pub fn try_reserve_exact<IRQL: IrqlLevel>(
        &mut self,
        additional: usize,
    ) -> Result<(), TryReserveError>
    where
        P: AllocableAt<IRQL>,
    {
        self.inner.try_reserve_exact(additional)
    }
}

// ---------------------------------------------------------------------------
// Mutation — forwards Vec's no-oom-handling mutation methods
// ---------------------------------------------------------------------------

impl<T, P: PoolAllocator> IrqlVec<T, P> {
    /// Push a value if capacity is available (no allocation).
    ///
    /// Call [`try_reserve`](Self::try_reserve) first to ensure space.
    /// Returns `Ok(&mut T)` on success, or `Err(value)` if full.
    pub fn push_within_capacity<IRQL: IrqlLevel>(&mut self, value: T) -> Result<&mut T, T>
    where
        P: AccessibleAt<IRQL>,
    {
        self.inner.push_within_capacity(value)
    }

    /// Convenience: `try_reserve(1)` + `push_within_capacity`.
    ///
    /// ```ignore
    /// call_irql!(v.push(42))?;
    /// ```
    pub fn push<IRQL: IrqlLevel>(&mut self, value: T) -> Result<(), TryReserveError>
    where
        P: AccessibleAt<IRQL> + AllocableAt<IRQL>,
    {
        self.inner.try_reserve(1)?;
        // Infallible — we just reserved one slot.
        let _ = self.inner.push_within_capacity(value);
        Ok(())
    }

    /// Remove and return the last element, or `None` if empty.
    pub fn pop<IRQL: IrqlLevel>(&mut self) -> Option<T>
    where
        P: AccessibleAt<IRQL>,
    {
        self.inner.pop()
    }

    /// Shorten the vec to `len` elements, dropping the rest.
    pub fn truncate<IRQL: IrqlLevel>(&mut self, len: usize)
    where
        P: AccessibleAt<IRQL>,
    {
        self.inner.truncate(len);
    }

    /// Remove all elements (length becomes 0, capacity unchanged).
    pub fn clear<IRQL: IrqlLevel>(&mut self)
    where
        P: AccessibleAt<IRQL>,
    {
        self.inner.clear();
    }

    /// Insert an element at `index`, shifting subsequent elements right.
    ///
    /// # Panics
    ///
    /// Panics if `index > len`.
    pub fn insert<IRQL: IrqlLevel>(&mut self, index: usize, value: T) -> Result<(), TryReserveError>
    where
        P: AccessibleAt<IRQL> + AllocableAt<IRQL>,
    {
        self.inner.try_reserve(1)?;
        self.inner.insert(index, value);
        Ok(())
    }

    /// Remove and return the element at `index`, shifting subsequent elements left.
    ///
    /// # Panics
    ///
    /// Panics if `index >= len`.
    pub fn remove<IRQL: IrqlLevel>(&mut self, index: usize) -> T
    where
        P: AccessibleAt<IRQL>,
    {
        self.inner.remove(index)
    }

    /// Remove the element at `index` by swapping it with the last element.
    ///
    /// O(1) but does not preserve ordering.
    ///
    /// # Panics
    ///
    /// Panics if `index >= len`.
    pub fn swap_remove<IRQL: IrqlLevel>(&mut self, index: usize) -> T
    where
        P: AccessibleAt<IRQL>,
    {
        self.inner.swap_remove(index)
    }

    /// Retain only elements for which `f` returns `true`.
    ///
    /// Elements are visited in order and removed in place.
    pub fn retain<IRQL: IrqlLevel>(&mut self, f: impl FnMut(&T) -> bool)
    where
        P: AccessibleAt<IRQL>,
    {
        self.inner.retain(f);
    }

    /// Extend with all elements from a slice (requires `T: Clone`).
    ///
    /// Reserves capacity for the entire slice before copying.
    pub fn extend_from_slice<IRQL: IrqlLevel>(&mut self, other: &[T]) -> Result<(), TryReserveError>
    where
        T: Clone,
        P: AccessibleAt<IRQL> + AllocableAt<IRQL>,
    {
        self.inner.try_reserve(other.len())?;
        self.inner.extend_from_slice(other);
        Ok(())
    }
}

// ---------------------------------------------------------------------------
// Access — forwards Vec's read methods
// ---------------------------------------------------------------------------

impl<T, P: PoolAllocator> IrqlVec<T, P> {
    /// Returns a shared slice of the contents.
    pub fn as_slice<IRQL: IrqlLevel>(&self) -> &[T]
    where
        P: AccessibleAt<IRQL>,
    {
        &self.inner
    }

    /// Returns a mutable slice of the contents.
    pub fn as_mut_slice<IRQL: IrqlLevel>(&mut self) -> &mut [T]
    where
        P: AccessibleAt<IRQL>,
    {
        &mut self.inner
    }

    /// Returns a reference to the element at `index`, or `None` if out of bounds.
    pub fn get<IRQL: IrqlLevel>(&self, index: usize) -> Option<&T>
    where
        P: AccessibleAt<IRQL>,
    {
        self.inner.get(index)
    }

    /// Returns a mutable reference to the element at `index`, or `None` if out of bounds.
    pub fn get_mut<IRQL: IrqlLevel>(&mut self, index: usize) -> Option<&mut T>
    where
        P: AccessibleAt<IRQL>,
    {
        self.inner.get_mut(index)
    }

    /// Returns an iterator over shared references.
    ///
    /// ```ignore
    /// for val in call_irql!(v.iter()) {
    ///     // use val
    /// }
    /// ```
    pub fn iter<IRQL: IrqlLevel>(&self) -> core::slice::Iter<'_, T>
    where
        P: AccessibleAt<IRQL>,
    {
        self.inner.iter()
    }

    /// Returns an iterator over mutable references.
    pub fn iter_mut<IRQL: IrqlLevel>(&mut self) -> core::slice::IterMut<'_, T>
    where
        P: AccessibleAt<IRQL>,
    {
        self.inner.iter_mut()
    }

    /// Returns the first element, or `None` if empty.
    pub fn first<IRQL: IrqlLevel>(&self) -> Option<&T>
    where
        P: AccessibleAt<IRQL>,
    {
        self.inner.first()
    }

    /// Returns the last element, or `None` if empty.
    pub fn last<IRQL: IrqlLevel>(&self) -> Option<&T>
    where
        P: AccessibleAt<IRQL>,
    {
        self.inner.last()
    }

    /// Returns `true` if the vec contains the given value.
    pub fn contains<IRQL: IrqlLevel>(&self, x: &T) -> bool
    where
        T: PartialEq,
        P: AccessibleAt<IRQL>,
    {
        self.inner.contains(x)
    }
}

// ---------------------------------------------------------------------------
// Metadata — no IRQL gate (these don't touch heap memory)
// ---------------------------------------------------------------------------

impl<T, P: PoolAllocator> IrqlVec<T, P> {
    /// Number of elements in the vec.
    #[must_use]
    pub fn len(&self) -> usize {
        self.inner.len()
    }

    /// Returns `true` if the vec contains no elements.
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.inner.is_empty()
    }

    /// Number of elements the vec can hold without re-allocating.
    #[must_use]
    pub fn capacity(&self) -> usize {
        self.inner.capacity()
    }
}

// SAFETY: `IrqlVec` is `Send` when `T: Send` because the inner `Vec` owns
// its elements exclusively, and pool memory has no thread affinity.  The
// `PoolAlloc<P>` allocator is a stateless ZST.
unsafe impl<T: Send, P: PoolAllocator> Send for IrqlVec<T, P> {}

// SAFETY: `IrqlVec` is `Sync` when `T: Sync` because shared access to
// elements is only possible through `&IrqlVec`, which yields `&[T]` via
// `as_slice()`. The pool allocator is stateless.
unsafe impl<T: Sync, P: PoolAllocator> Sync for IrqlVec<T, P> {}

// ---------------------------------------------------------------------------
// irql_vec! macro
// ---------------------------------------------------------------------------

/// Create an [`IrqlVec`] with automatic pool selection, similar to `vec![]`.
///
/// Must be called inside an `#[irql]`-annotated function body where the
/// local `call_irql!` macro is available.
///
/// ```ignore
/// let v = irql_vec![1, 2, 3]?;
/// let v = irql_vec![0; 5]?;
/// ```
#[macro_export]
macro_rules! irql_vec {
    () => {
        call_irql!($crate::IrqlVec::try_from_iter(core::iter::empty()))
    };
    ($elem:expr; $count:expr) => {
        call_irql!($crate::IrqlVec::try_from_iter([$elem; $count]))
    };
    ($($elem:expr),+ $(,)?) => {
        call_irql!($crate::IrqlVec::try_from_iter([$($elem),+]))
    };
}

```

`crates/irql_alloc/src/lib.rs`:

```rs
//! IRQL-aware kernel pool allocator types.
//!
//! Provides [`IrqlBox`] and [`IrqlVec`] — heap-allocated containers that
//! enforce IRQL constraints at compile time for both allocation and access.
//!
//! **Internal crate** — use [`irql`](https://docs.rs/irql) with the `alloc`
//! feature instead.
//!
//! # Nightly requirement
//!
//! This crate uses the unstable `allocator_api`,
//! `vec_push_within_capacity`, and `negative_impls` features and
//! **requires a nightly Rust compiler**.
//!
//! # Kernel pool allocation
//!
//! In WDM/KMDF driver builds, pool allocations use `ExAllocatePool2` /
//! `ExFreePool` from [`wdk-sys`](https://crates.io/crates/wdk-sys).
//! [`PagedPool`] uses `POOL_FLAG_PAGED` and [`NonPagedPool`] uses
//! `POOL_FLAG_NON_PAGED`. All allocations are tagged with `"IrqL"` for
//! WinDbg diagnostics.
//!
//! Outside a WDK build (e.g. testing in user mode), the global allocator
//! is used as a fallback.
//!
//! # Pool types
//!
//! | Pool | Allocable at | Accessible at |
//! |------|-------------|---------------|
//! | [`PagedPool`] | `Passive`, `Apc` | `Passive`, `Apc` |
//! | [`NonPagedPool`] | `Passive`, `Apc`, `Dispatch` | Any IRQL |
//!
//! # Automatic pool selection
//!
//! [`IrqlBox::new`] and [`IrqlVec::new`] pick the cheapest legal pool for
//! the current IRQL:
//!
//! | IRQL | Default pool |
//! |------|-------------|
//! | `Passive` / `Apc` | [`PagedPool`] |
//! | `Dispatch` | [`NonPagedPool`] |
//! | `Dirql`+ | *compile error* |

#![no_std]
#![deny(missing_docs)]
#![feature(allocator_api)]
#![feature(vec_push_within_capacity)]
#![feature(negative_impls)]

extern crate alloc;

mod irql_box;
mod irql_vec;
mod pool;

pub use alloc::collections::TryReserveError;
pub use core::alloc::AllocError;
pub use irql_box::IrqlBox;
pub use irql_vec::IrqlVec;
pub use pool::{
    AccessibleAt, AllocableAt, DefaultPool, NonPagedPool, PagedPool, PoolAlloc, PoolAllocator,
};

```

`crates/irql_alloc/src/pool.rs`:

```rs
//! Kernel pool marker types and IRQL-aware traits.

use core::alloc::Layout;
use core::ptr::NonNull;
use irql_core::{Apc, Clock, Dirql, Dispatch, High, Ipi, IrqlLevel, Passive, Power, Profile};
use irql_core::{
    SafeToDropAtClock, SafeToDropAtDirql, SafeToDropAtDispatch, SafeToDropAtHigh, SafeToDropAtIpi,
    SafeToDropAtPower, SafeToDropAtProfile,
};

// ---------------------------------------------------------------------------
// Pool marker types
// ---------------------------------------------------------------------------

/// Paged pool memory.
///
/// - Allocable at `Passive` and `Apc` only.
/// - Accessible at `Passive` and `Apc` only — paged memory may be swapped out
///   at higher IRQLs.
/// - **Cannot be dropped** at `Dispatch` or above (enforced via auto traits).
pub struct PagedPool;

/// Non-paged pool memory.
///
/// - Allocable at `Passive`, `Apc`, and `Dispatch`.
/// - Accessible at any IRQL — non-paged memory is never swapped out.
pub struct NonPagedPool;

// ---------------------------------------------------------------------------
// Drop safety — PagedPool must not be freed at Dispatch or above
// ---------------------------------------------------------------------------
//
// Negative impls propagate automatically: any type containing `PagedPool`
// (or `PhantomData<PagedPool>`) also loses the corresponding auto trait.

impl !SafeToDropAtDispatch for PagedPool {}
impl !SafeToDropAtDirql for PagedPool {}
impl !SafeToDropAtProfile for PagedPool {}
impl !SafeToDropAtClock for PagedPool {}
impl !SafeToDropAtIpi for PagedPool {}
impl !SafeToDropAtPower for PagedPool {}
impl !SafeToDropAtHigh for PagedPool {}

// ---------------------------------------------------------------------------
// AllocableAt
// ---------------------------------------------------------------------------

/// Pool `Self` supports allocation at IRQL `I`.
#[diagnostic::on_unimplemented(
    message = "cannot allocate from `{Self}` at IRQL `{I}`",
    label = "allocation not allowed at this IRQL",
    note = "paged pool requires IRQL <= APC_LEVEL; non-paged pool requires IRQL <= DISPATCH_LEVEL"
)]
pub trait AllocableAt<I: IrqlLevel> {}

impl AllocableAt<Passive> for PagedPool {}
impl AllocableAt<Apc> for PagedPool {}

impl AllocableAt<Passive> for NonPagedPool {}
impl AllocableAt<Apc> for NonPagedPool {}
impl AllocableAt<Dispatch> for NonPagedPool {}

// ---------------------------------------------------------------------------
// AccessibleAt
// ---------------------------------------------------------------------------

/// Memory from pool `Self` can be safely dereferenced at IRQL `I`.
#[diagnostic::on_unimplemented(
    message = "cannot access `{Self}` memory at IRQL `{I}` -- paged memory may be swapped out",
    label = "memory access not safe at this IRQL",
    note = "paged pool memory is only safe to access at IRQL <= APC_LEVEL"
)]
pub trait AccessibleAt<I: IrqlLevel> {}

impl AccessibleAt<Passive> for PagedPool {}
impl AccessibleAt<Apc> for PagedPool {}

impl AccessibleAt<Passive> for NonPagedPool {}
impl AccessibleAt<Apc> for NonPagedPool {}
impl AccessibleAt<Dispatch> for NonPagedPool {}
impl AccessibleAt<Dirql> for NonPagedPool {}
impl AccessibleAt<Profile> for NonPagedPool {}
impl AccessibleAt<Clock> for NonPagedPool {}
impl AccessibleAt<Ipi> for NonPagedPool {}
impl AccessibleAt<Power> for NonPagedPool {}
impl AccessibleAt<High> for NonPagedPool {}

// ---------------------------------------------------------------------------
// DefaultPool
// ---------------------------------------------------------------------------

/// Maps an IRQL level to its default pool type.
///
/// `Passive`/`Apc` → [`PagedPool`], `Dispatch` → [`NonPagedPool`],
/// `Dirql`+ → compile error.
#[diagnostic::on_unimplemented(
    message = "cannot allocate at IRQL `{Self}` -- no kernel pool is available at this level",
    label = "no allocator for this IRQL",
    note = "memory allocation requires IRQL <= DISPATCH_LEVEL"
)]
pub trait DefaultPool: IrqlLevel {
    /// The pool type used by default at this IRQL.
    type Pool;
}

impl DefaultPool for Passive {
    type Pool = PagedPool;
}
impl DefaultPool for Apc {
    type Pool = PagedPool;
}
impl DefaultPool for Dispatch {
    type Pool = NonPagedPool;
}

// ---------------------------------------------------------------------------
// PoolAllocator
// ---------------------------------------------------------------------------

/// Low-level allocator for a kernel pool.
///
/// # Safety
///
/// Implementors must correctly allocate and deallocate memory from the
/// corresponding kernel pool.
pub unsafe trait PoolAllocator {
    /// Allocate memory. Returns null on failure.
    ///
    /// # Safety
    ///
    /// The caller must ensure the current IRQL is appropriate for this pool.
    unsafe fn alloc(layout: Layout) -> *mut u8;

    /// Deallocate memory previously allocated by [`alloc`](PoolAllocator::alloc).
    ///
    /// # Safety
    ///
    /// - `ptr` must have been allocated by this pool's `alloc`.
    /// - `layout` must match the original allocation.
    unsafe fn dealloc(ptr: *mut u8, layout: Layout);
}

// ---------------------------------------------------------------------------
// PoolAllocator impls — WDK kernel pool APIs
// ---------------------------------------------------------------------------

#[cfg(any(driver_model__driver_type = "WDM", driver_model__driver_type = "KMDF"))]
use wdk_sys::{
    POOL_FLAG_NON_PAGED, POOL_FLAG_PAGED, SIZE_T, ULONG,
    ntddk::{ExAllocatePool2, ExFreePool},
};

/// Pool tag: appears as `"IrqL"` in WinDbg (`!pool` / `!pooltag`).
#[cfg(any(driver_model__driver_type = "WDM", driver_model__driver_type = "KMDF"))]
const IRQL_POOL_TAG: ULONG = u32::from_ne_bytes(*b"IrqL");

#[cfg(any(driver_model__driver_type = "WDM", driver_model__driver_type = "KMDF"))]
macro_rules! impl_wdk_pool_allocator {
    ($pool:ty, $flag:expr) => {
        unsafe impl PoolAllocator for $pool {
            unsafe fn alloc(layout: Layout) -> *mut u8 {
                let ptr = unsafe { ExAllocatePool2($flag, layout.size() as SIZE_T, IRQL_POOL_TAG) };
                if ptr.is_null() {
                    return core::ptr::null_mut();
                }
                ptr.cast()
            }

            unsafe fn dealloc(ptr: *mut u8, _layout: Layout) {
                unsafe { ExFreePool(ptr.cast()) }
            }
        }
    };
}

#[cfg(any(driver_model__driver_type = "WDM", driver_model__driver_type = "KMDF"))]
impl_wdk_pool_allocator!(PagedPool, POOL_FLAG_PAGED);

#[cfg(any(driver_model__driver_type = "WDM", driver_model__driver_type = "KMDF"))]
impl_wdk_pool_allocator!(NonPagedPool, POOL_FLAG_NON_PAGED);

// ---------------------------------------------------------------------------
// PoolAllocator impls — global allocator fallback (non-WDK / testing)
// ---------------------------------------------------------------------------

#[cfg(not(any(driver_model__driver_type = "WDM", driver_model__driver_type = "KMDF")))]
macro_rules! impl_fallback_pool_allocator {
    ($pool:ty) => {
        unsafe impl PoolAllocator for $pool {
            unsafe fn alloc(layout: Layout) -> *mut u8 {
                unsafe { alloc::alloc::alloc(layout) }
            }
            unsafe fn dealloc(ptr: *mut u8, layout: Layout) {
                unsafe { alloc::alloc::dealloc(ptr, layout) }
            }
        }
    };
}

#[cfg(not(any(driver_model__driver_type = "WDM", driver_model__driver_type = "KMDF")))]
impl_fallback_pool_allocator!(PagedPool);

#[cfg(not(any(driver_model__driver_type = "WDM", driver_model__driver_type = "KMDF")))]
impl_fallback_pool_allocator!(NonPagedPool);

// ---------------------------------------------------------------------------
// PoolAlloc<P> — Allocator API adapter
// ---------------------------------------------------------------------------

/// Zero-sized [`Allocator`](core::alloc::Allocator) that delegates to
/// `P`'s [`PoolAllocator`] implementation.
#[derive(Debug, Copy, Clone)]
pub struct PoolAlloc<P>(core::marker::PhantomData<P>);

impl<P> PoolAlloc<P> {
    /// Create a new `PoolAlloc` instance.
    #[must_use]
    pub const fn new() -> Self {
        PoolAlloc(core::marker::PhantomData)
    }
}

impl<P> Default for PoolAlloc<P> {
    fn default() -> Self {
        Self::new()
    }
}

unsafe impl<P: PoolAllocator> core::alloc::Allocator for PoolAlloc<P> {
    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, core::alloc::AllocError> {
        if layout.size() == 0 {
            let ptr = NonNull::new(layout.align() as *mut u8).ok_or(core::alloc::AllocError)?;
            return Ok(NonNull::slice_from_raw_parts(ptr, 0));
        }
        let ptr = unsafe { P::alloc(layout) };
        let ptr = NonNull::new(ptr).ok_or(core::alloc::AllocError)?;
        Ok(NonNull::slice_from_raw_parts(ptr, layout.size()))
    }

    unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {
        if layout.size() == 0 {
            return;
        }
        unsafe { P::dealloc(ptr.as_ptr(), layout) };
    }
}

```

`crates/irql_core/Cargo.toml`:

```toml
[package]
name = "irql_core"
version.workspace = true
edition.workspace = true
description = "Core types and traits for IRQL safety"
license.workspace = true
repository.workspace = true
documentation = "https://docs.rs/irql"
keywords.workspace = true
categories.workspace = true
readme = "../../README.md"

[package.metadata.docs.rs]
default-target = "x86_64-pc-windows-msvc"
targets = ["x86_64-pc-windows-msvc"]

[features]
default = []
## Enable `SafeToDropAt*` auto traits for compile-time drop-safety checks.
## **Requires nightly** (`#![feature(auto_traits)]`).
## Automatically enabled by `irql/alloc`.
drop-safety = []

[dependencies]

```

`crates/irql_core/src/drop_safety.rs`:

```rs
//! Per-level auto traits for compile-time drop safety.
//!
//! Each auto trait is automatically implemented for any type whose fields all
//! implement it. Types unsafe to drop at a given IRQL opt out with negative
//! impls (e.g. `impl !SafeToDropAtDispatch for PagedPool {}`).

use super::levels::*;

macro_rules! define_drop_safety_traits {
    ($(($level:ident, $safe_trait:ident)),+) => {
        $(
            #[doc = concat!(
                "Memory owned by this type can be safely freed at **",
                stringify!($level), "** IRQL.\n",
                "\n",
                "This is an [auto trait]: it is automatically implemented for any\n",
                "type whose fields all implement it. Types that are unsafe to drop\n",
                "at this IRQL opt out with a negative impl.\n",
                "\n",
                "# Safety\n",
                "\n",
                "This is an auto trait — do not implement it manually. Opt out with\n",
                "a negative impl (`impl !",  stringify!($safe_trait), " for MyType {}`).\n",
                "\n",
                "[auto trait]: https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits",
            )]
            #[diagnostic::on_unimplemented(
                message = "`{Self}` cannot be safely dropped at this IRQL",
                label   = "not safe to drop here",
                note    = "this type (or a type it contains) has opted out via a negative impl.\nConsider passing by reference (`&`) or transferring ownership without dropping (e.g. `leak()` / `into_raw()`).",
            )]
            pub unsafe auto trait $safe_trait {}

            impl<T: $safe_trait> SafeToDropAt<$level> for T {}
        )+
    };
}

define_drop_safety_traits!(
    (Passive, SafeToDropAtPassive),
    (Apc, SafeToDropAtApc),
    (Dispatch, SafeToDropAtDispatch),
    (Dirql, SafeToDropAtDirql),
    (Profile, SafeToDropAtProfile),
    (Clock, SafeToDropAtClock),
    (Ipi, SafeToDropAtIpi),
    (Power, SafeToDropAtPower),
    (High, SafeToDropAtHigh)
);

```

`crates/irql_core/src/function_traits.rs`:

```rs
use crate::{IrqlCanLowerTo, IrqlCanRaiseTo, IrqlLevel, Passive};

/// IRQL-safe analogue of [`Fn`] — callable multiple times via shared reference.
///
/// Callable from any IRQL in the range \[`Min`, `Level`\]:
/// - The caller's IRQL must be ≤ `Level` (can raise to it).
/// - The caller's IRQL must be ≥ `Min` (is at or above the floor).
///
/// `Min` defaults to [`Passive`] (no floor) when omitted.
///
/// # Implementing
///
/// Use the `#[irql]` attribute on the trait impl block — the macro fills in
/// the `Level` (and `Min`) type parameters automatically:
///
/// ```ignore
/// #[irql(max = Dispatch)]
/// impl IrqlFn<()> for MyReader {
///     type Output = u32;
///     fn call(&self, _: ()) -> u32 { self.value }
/// }
/// // Expands to: impl IrqlFn<Dispatch, ()> for MyReader { … }
/// ```
pub trait IrqlFn<Level: IrqlLevel, Args, Min: IrqlLevel = Passive> {
    /// The return type produced by this callable.
    type Output;

    /// Call the function. Only compiles when the caller's IRQL satisfies both bounds.
    fn call<IRQL>(&self, args: Args) -> Self::Output
    where
        IRQL: IrqlCanRaiseTo<Level> + IrqlCanLowerTo<Min>;
}

/// IRQL-safe analogue of [`FnMut`] — callable multiple times via mutable reference.
///
/// Same IRQL semantics as [`IrqlFn`], but takes `&mut self`.
///
/// ```ignore
/// #[irql(max = Passive)]
/// impl IrqlFnMut<()> for Counter {
///     type Output = u32;
///     fn call_mut(&mut self, _: ()) -> u32 {
///         self.count += 1;
///         self.count
///     }
/// }
/// ```
pub trait IrqlFnMut<Level: IrqlLevel, Args, Min: IrqlLevel = Passive> {
    /// The return type produced by this callable.
    type Output;

    /// Call the function mutably.
    fn call_mut<IRQL>(&mut self, args: Args) -> Self::Output
    where
        IRQL: IrqlCanRaiseTo<Level> + IrqlCanLowerTo<Min>;
}

/// IRQL-safe analogue of [`FnOnce`] — callable exactly once, consuming `self`.
///
/// Same IRQL semantics as [`IrqlFn`], but takes `self` by value.
///
/// ```ignore
/// #[irql(max = Dispatch)]
/// impl IrqlFnOnce<()> for Message {
///     type Output = String;
///     fn call_once(self, _: ()) -> String { self.0 }
/// }
/// ```
pub trait IrqlFnOnce<Level: IrqlLevel, Args, Min: IrqlLevel = Passive> {
    /// The return type produced by this callable.
    type Output;

    /// Call the function, consuming it.
    fn call_once<IRQL>(self, args: Args) -> Self::Output
    where
        IRQL: IrqlCanRaiseTo<Level> + IrqlCanLowerTo<Min>;
}

```

`crates/irql_core/src/levels.rs`:

```rs
use crate::private;

/// Marker trait implemented by all IRQL level types.
///
/// Every IRQL level is a zero-sized type that implements this trait.
///
/// # Hierarchy (lowest → highest)
///
/// `Passive(0)` → `Apc(1)` → `Dispatch(2)` → `Dirql(3–26)` → `Profile(27)`
/// → `Clock(28)` → `Ipi(29)` → `Power(30)` → `High(31)`
///
/// The hierarchy is enforced at compile time through [`IrqlCanRaiseTo`] and
/// [`IrqlCanLowerTo`].
pub trait IrqlLevel: private::Sealed {}

/// The current IRQL can be raised to `Target`.
///
/// Holds when `Self <= Target` in the IRQL hierarchy.
///
/// # Example
///
/// ```ignore
/// // Passive can raise to Dispatch (impl exists):
/// fn ok<I: IrqlCanRaiseTo<Dispatch>>() {}
///
/// // Dispatch cannot raise to Passive (no impl — compile error):
/// // fn bad<I: IrqlCanRaiseTo<Passive>>() where Dispatch: IrqlCanRaiseTo<Passive> {}
/// ```
#[diagnostic::on_unimplemented(
    message = "IRQL violation: cannot reach `{Target}` from `{Self}` -- would require lowering",
    label = "cannot lower IRQL",
    note = "IRQL can only stay the same or be raised, never lowered"
)]
pub trait IrqlCanRaiseTo<Target: IrqlLevel>: private::Sealed {}

/// The current IRQL is at or above `Target`.
///
/// Holds when `Self >= Target` in the IRQL hierarchy.
/// Used by `#[irql(min = Level)]` to enforce a floor constraint.
///
/// # Example
///
/// ```ignore
/// // Dispatch is at or above Passive (impl exists):
/// fn ok<I: IrqlCanLowerTo<Passive>>() where Dispatch: IrqlCanLowerTo<Passive> {}
///
/// // Passive is not at or above Dispatch (no impl — compile error):
/// // fn bad<I: IrqlCanLowerTo<Dispatch>>() where Passive: IrqlCanLowerTo<Dispatch> {}
/// ```
#[diagnostic::on_unimplemented(
    message = "IRQL violation: `{Self}` is below the required minimum `{Target}`",
    label = "IRQL too low",
    note = "this operation requires IRQL >= `{Target}`"
)]
pub trait IrqlCanLowerTo<Target: IrqlLevel>: private::Sealed {}

/// `Self` can be safely dropped at IRQL `Level`.
///
/// With the `drop-safety` feature, this is backed by per-level auto traits
/// that propagate through struct fields automatically. Without it, this is
/// blanket-implemented for all types (no-op).
#[diagnostic::on_unimplemented(
    message = "`{Self}` cannot be safely dropped at IRQL `{Level}`",
    label = "not safe to drop at this IRQL",
    note = "this type (or a type it contains) has opted out via a negative impl.\nConsider passing by reference (`&`) or transferring ownership without dropping (e.g. `leak()` / `into_raw()`)."
)]
pub trait SafeToDropAt<Level: IrqlLevel> {}

macro_rules! define_irql_hierarchy {
    ($($level:ident),+) => {
        $(
            #[doc = concat!(
                "IRQL level: **", stringify!($level), "**.\n",
                "\n",
                "See [`IrqlLevel`] for the full hierarchy.",
            )]
            pub struct $level;

            impl private::Sealed for $level {}
            impl IrqlLevel for $level {}
        )+

        define_irql_hierarchy!(@raise_all $($level),+);
        define_irql_hierarchy!(@lower_all $($level),+);
    };

    // Each level can raise to itself and all higher levels.
    (@raise_all $head:ident, $($tail:ident),+) => {
        impl IrqlCanRaiseTo<$head> for $head {}
        $( impl IrqlCanRaiseTo<$tail> for $head {} )+
        define_irql_hierarchy!(@raise_all $($tail),+);
    };
    (@raise_all $last:ident) => {
        impl IrqlCanRaiseTo<$last> for $last {}
    };

    // Each level can lower to itself and all lower levels.
    (@lower_all $head:ident, $($tail:ident),+) => {
        impl IrqlCanLowerTo<$head> for $head {}
        $( impl IrqlCanLowerTo<$head> for $tail {} )+
        define_irql_hierarchy!(@lower_all $($tail),+);
    };
    (@lower_all $last:ident) => {
        impl IrqlCanLowerTo<$last> for $last {}
    };
}

define_irql_hierarchy!(
    Passive, Apc, Dispatch, Dirql, Profile, Clock, Ipi, Power, High
);

// Without drop-safety: blanket impl so SafeToDropAt<L> bounds are trivially satisfied.
#[cfg(not(feature = "drop-safety"))]
impl<T, L: IrqlLevel> SafeToDropAt<L> for T {}

```

`crates/irql_core/src/lib.rs`:

```rs
//! Core types and traits for compile-time IRQL safety.
//!
//! **Internal crate** — use [`irql`](https://docs.rs/irql) instead.
//!
//! This crate provides:
//!
//! - **IRQL level types**: [`Passive`], [`Apc`], [`Dispatch`], [`Dirql`],
//!   [`Profile`], [`Clock`], [`Ipi`], [`Power`], [`High`] — zero-sized marker
//!   types.
//!
//! - **Hierarchy traits**: [`IrqlCanRaiseTo`] and [`IrqlCanLowerTo`] encode
//!   which transitions are valid. Invalid transitions produce a compile error
//!   with a clear diagnostic message.
//!
//! - **Drop-safety auto traits** (`drop-safety` feature, requires nightly):
//!   `SafeToDropAtPassive`, `SafeToDropAtDispatch`, etc. — one per IRQL level.
//!   Types that are unsafe to drop above a certain IRQL opt out with negative
//!   impls (e.g. `PagedPool` in `irql_alloc`). Without `drop-safety`,
//!   [`SafeToDropAt`] is blanket-implemented for all types.
//!
//! - **Function traits**: [`IrqlFn`], [`IrqlFnMut`], [`IrqlFnOnce`] — IRQL-safe
//!   analogues of [`Fn`], [`FnMut`], [`FnOnce`].

#![no_std]
#![warn(missing_docs)]
#![cfg_attr(feature = "drop-safety", feature(auto_traits))]

mod function_traits;
mod levels;
mod private;

#[cfg(feature = "drop-safety")]
mod drop_safety;

pub use function_traits::{IrqlFn, IrqlFnMut, IrqlFnOnce};
pub use levels::{
    Apc, Clock, Dirql, Dispatch, High, Ipi, IrqlCanLowerTo, IrqlCanRaiseTo, IrqlLevel, Passive,
    Power, Profile, SafeToDropAt,
};

#[cfg(feature = "drop-safety")]
pub use drop_safety::{
    SafeToDropAtApc, SafeToDropAtClock, SafeToDropAtDirql, SafeToDropAtDispatch, SafeToDropAtHigh,
    SafeToDropAtIpi, SafeToDropAtPassive, SafeToDropAtPower, SafeToDropAtProfile,
};

```

`crates/irql_core/src/private.rs`:

```rs
//! Sealed trait to prevent external implementations of IRQL level types.
//!
//! This pattern ensures that only the types defined in [`crate::levels`] can
//! implement [`IrqlLevel`](crate::IrqlLevel), preventing downstream crates
//! from introducing invalid IRQL levels.

/// Sealed supertrait — cannot be implemented outside this crate.
pub trait Sealed {}

```

`crates/irql_macro/Cargo.toml`:

```toml
[package]
name = "irql_macro"
version.workspace = true
edition.workspace = true
description = "Procedural macros for IRQL safety"
license.workspace = true
repository.workspace = true
documentation = "https://docs.rs/irql"
keywords.workspace = true
categories.workspace = true
readme = "../../README.md"

[package.metadata.docs.rs]
default-target = "x86_64-pc-windows-msvc"
targets = ["x86_64-pc-windows-msvc"]

[lib]
proc-macro = true

[dependencies]
syn = { version = "2.0.115", features = ["full"] }
quote = "1.0.44"
proc-macro2 = "1.0.106"

```

`crates/irql_macro/src/apply.rs`:

```rs
//! Applying IRQL constraints to functions and impl blocks.
//!
//! Core transformation:
//! 1. Insert an `IRQL` generic parameter with `IrqlCanRaiseTo`/`IrqlCanLowerTo` bounds.
//! 2. Add `SafeToDropAt<Level>` bounds on by-value parameters.
//! 3. Inject a local `call_irql!` macro into function bodies.

use syn::{FnArg, GenericArgument, ImplItem, ItemFn, ItemImpl, PathArguments, Type, parse_quote};

use crate::constraints::IrqlConstraints;

/// Insert `IRQL` generic and add hierarchy where-clause bounds.
fn apply_irql_bounds(generics: &mut syn::Generics, c: &IrqlConstraints) {
    generics.params.insert(0, parse_quote! { IRQL });
    let wc = generics.make_where_clause();
    if let Some(ref max) = c.max {
        wc.predicates
            .push(parse_quote! { IRQL: ::irql::IrqlCanRaiseTo<#max> });
    }
    if let Some(ref min) = c.min {
        wc.predicates
            .push(parse_quote! { IRQL: ::irql::IrqlCanLowerTo<#min> });
    }
}

/// Add `T: SafeToDropAt<Level>` bounds for each by-value parameter.
///
/// References (`&T`, `&mut T`) are skipped — they don't own the value.
/// A bare `self` receiver gets a `Self: SafeToDropAt<Level>` bound.
pub(crate) fn inject_drop_bounds(
    generics: &mut syn::Generics,
    inputs: &syn::punctuated::Punctuated<FnArg, syn::Token![,]>,
    level: &Type,
) {
    let wc = generics.make_where_clause();

    for arg in inputs {
        match arg {
            FnArg::Typed(pat_type) => {
                if !matches!(&*pat_type.ty, Type::Reference(_)) {
                    let ty = &pat_type.ty;
                    wc.predicates.push(parse_quote! {
                        #ty: ::irql::SafeToDropAt<#level>
                    });
                }
            }
            FnArg::Receiver(receiver) => {
                if receiver.reference.is_none() {
                    wc.predicates.push(parse_quote! {
                        Self: ::irql::SafeToDropAt<#level>
                    });
                }
            }
        }
    }
}

/// Inject the local `call_irql!` macro (and optionally `PhantomData<IRQL>`).
///
/// `phantom` inserts `let _ = PhantomData::<IRQL>` to suppress "unused generic"
/// warnings. Trait methods don't need it because the trait definition uses `IRQL`.
pub(crate) fn inject_body(stmts: &mut Vec<syn::Stmt>, level: &Type, phantom: bool) {
    stmts.insert(
        0,
        parse_quote! {
            #[allow(unused_macros)]
            macro_rules! call_irql {
                ($($tt:tt)*) => {
                    ::irql::call_irql_inner!(#level, $($tt)*)
                };
            }
        },
    );
    if phantom {
        stmts.insert(
            0,
            parse_quote! { let _ = ::core::marker::PhantomData::<IRQL>; },
        );
    }
}

/// Apply all three transformations to a single method/function.
fn transform_method(
    sig: &mut syn::Signature,
    block: &mut syn::Block,
    c: &IrqlConstraints,
    phantom: bool,
) {
    apply_irql_bounds(&mut sig.generics, c);
    inject_drop_bounds(&mut sig.generics, &sig.inputs, c.call_level());
    inject_body(&mut block.stmts, c.call_level(), phantom);
}

/// Apply constraints to a standalone function.
pub(crate) fn apply_to_function(f: &mut ItemFn, c: &IrqlConstraints) {
    transform_method(&mut f.sig, &mut f.block, c, true);
}

/// Apply constraints to an inherent impl block (each method gets its own `IRQL` generic).
pub(crate) fn apply_to_impl_block(imp: &mut ItemImpl, c: &IrqlConstraints) {
    for item in &mut imp.items {
        if let ImplItem::Fn(m) = item {
            transform_method(&mut m.sig, &mut m.block, c, true);
        }
    }
}

/// Apply constraints to a trait impl block (e.g. `impl IrqlFn<()> for T`).
///
/// Rewrites the trait's generic arguments to include the IRQL level,
/// then constrains each method.
pub(crate) fn apply_to_trait_impl(imp: &mut ItemImpl, c: &IrqlConstraints) -> syn::Result<()> {
    let (_, path, _) = imp
        .trait_
        .as_mut()
        .ok_or_else(|| syn::Error::new_spanned(&imp.self_ty, "expected a trait impl"))?;
    let seg = path
        .segments
        .last_mut()
        .ok_or_else(|| syn::Error::new(proc_macro2::Span::call_site(), "empty trait path"))?;
    let name = seg.ident.to_string();

    // Extract the user-written Args type (the only generic the user provides).
    let args = match &seg.arguments {
        PathArguments::AngleBracketed(a) if a.args.len() == 1 => match &a.args[0] {
            GenericArgument::Type(ty) => ty.clone(),
            other => return Err(syn::Error::new_spanned(other, "expected a type for Args")),
        },
        PathArguments::AngleBracketed(a) => {
            return Err(syn::Error::new_spanned(
                a,
                format!(
                    "expected 1 type parameter (Args), found {}; \
                     IRQL level is added automatically",
                    a.args.len()
                ),
            ));
        }
        _ => {
            return Err(syn::Error::new_spanned(
                seg,
                format!("{name} requires an Args type, e.g. {name}<()>"),
            ));
        }
    };

    // Rewrite: IrqlFn<()> -> IrqlFn<Max, ()> or IrqlFn<Max, (), Min>
    let max = c.call_level();
    seg.arguments = if let Some(ref min) = c.min {
        PathArguments::AngleBracketed(parse_quote! { <#max, #args, #min> })
    } else {
        PathArguments::AngleBracketed(parse_quote! { <#max, #args> })
    };

    // No PhantomData: trait methods use IRQL through the trait's own generics.
    for item in &mut imp.items {
        if let ImplItem::Fn(m) = item {
            transform_method(&mut m.sig, &mut m.block, c, false);
        }
    }
    Ok(())
}

```

`crates/irql_macro/src/call_irql.rs`:

```rs
//! `call_irql_inner!` — turbofish IRQL injection.
//!
//! Rewrites `call_irql!(f(args))` → `f::<IRQL>(args)` and
//! `call_irql!(x.m(args))` → `x.m::<IRQL>(args)`.

use proc_macro::TokenStream;
use quote::quote;
use syn::{
    Expr, GenericArgument, PathArguments, Token, Type, parse::Parser, parse_quote,
    punctuated::Punctuated,
};

/// Prepend `irql_type` to the generic arguments of the given turbofish.
fn prepend_irql(
    irql_type: Type,
    existing: Option<&syn::AngleBracketedGenericArguments>,
) -> Punctuated<GenericArgument, Token![,]> {
    let mut args: Punctuated<GenericArgument, Token![,]> = Punctuated::new();
    args.push(GenericArgument::Type(irql_type));
    if let Some(existing) = existing {
        args.extend(existing.args.iter().cloned());
    }
    args
}

/// Rewrite a function or method call to inject the IRQL level as the first
/// turbofish type argument.
pub(crate) fn call_irql_inner_impl(input: TokenStream) -> syn::Result<TokenStream> {
    let mut exprs = Punctuated::<Expr, Token![,]>::parse_separated_nonempty.parse(input)?;

    if exprs.len() != 2 {
        return Err(syn::Error::new(
            proc_macro2::Span::call_site(),
            format!("expected (level, expr), got {} arguments", exprs.len()),
        ));
    }

    // Safe: length was verified to be exactly 2 above.
    let call_expr = exprs.pop().expect("len == 2").into_value();
    let irql_expr = exprs.pop().expect("len == 2").into_value();
    let irql_type: Type = parse_quote! { ::irql::#irql_expr };

    match call_expr {
        Expr::Call(mut call) => {
            if let Expr::Path(ref mut p) = *call.func {
                let seg = p.path.segments.last_mut().expect("non-empty path");
                let existing = match &seg.arguments {
                    PathArguments::AngleBracketed(a) => Some(a),
                    _ => None,
                };
                let args = prepend_irql(irql_type, existing);
                seg.arguments = PathArguments::AngleBracketed(parse_quote! { ::<#args> });
            } else {
                return Err(syn::Error::new_spanned(
                    &call.func,
                    "call_irql! requires a named function — indirect calls \
                     (closures, function pointers) are not supported",
                ));
            }
            Ok(quote! { #call }.into())
        }
        Expr::MethodCall(mut mc) => {
            let existing = mc.turbofish.as_ref();
            let args = prepend_irql(irql_type, existing);
            mc.turbofish = Some(parse_quote! { ::<#args> });
            Ok(quote! { #mc }.into())
        }
        other => Err(syn::Error::new_spanned(
            &other,
            "call_irql! expects a function or method call",
        )),
    }
}

```

`crates/irql_macro/src/constraints.rs`:

```rs
//! Parsing `#[irql(...)]` attribute arguments.
//!
//! Supports three forms:
//! - `#[irql(at = Level)]` — fixed entry point, no generic added.
//! - `#[irql(max = Level)]` — callable from `Level` or below.
//! - `#[irql(min = A, max = B)]` — callable in the range \[A, B\].
//!
//! Level names and hierarchy order are **not** validated here — the compiler
//! catches invalid levels through `IrqlCanRaiseTo` / `IrqlCanLowerTo` trait
//! bounds emitted by the macro.

use proc_macro::TokenStream;
use syn::{Meta, Token, Type, parse::Parser, parse_quote, punctuated::Punctuated};

/// Usage hint appended to error messages.
pub(crate) const USAGE: &str = "\
    valid forms:\n  \
    #[irql(at = Passive)]           — fixed entry point\n  \
    #[irql(max = Dispatch)]         — callable from Dispatch or below\n  \
    #[irql(min = Apc, max = Dispatch)] — callable in [Apc, Dispatch]";

/// Parsed `#[irql(at/min/max = Level)]` constraints.
pub(crate) struct IrqlConstraints {
    pub min: Option<Type>,
    pub max: Option<Type>,
    pub at: Option<Type>,
}

impl IrqlConstraints {
    /// Parse the token stream inside `#[irql(...)]`.
    pub fn parse(attr: TokenStream) -> syn::Result<Self> {
        let metas = Punctuated::<Meta, Token![,]>::parse_terminated.parse(attr)?;

        let (mut min, mut max, mut at) = (None, None, None);

        for meta in &metas {
            let nv = match meta {
                Meta::NameValue(nv) => nv,
                Meta::Path(p) => {
                    let ident = p.get_ident().map(|i| i.to_string()).unwrap_or_default();
                    return Err(syn::Error::new_spanned(
                        p,
                        format!(
                            "expected `key = Level`, got `{ident}` without a value.\n\
                             Did you mean `max = {ident}` or `at = {ident}`?\n{USAGE}"
                        ),
                    ));
                }
                other => {
                    return Err(syn::Error::new_spanned(
                        other,
                        format!("expected `key = Level`.\n{USAGE}"),
                    ));
                }
            };

            let key = nv.path.get_ident().ok_or_else(|| {
                syn::Error::new_spanned(
                    &nv.path,
                    format!("expected `at`, `min`, or `max`.\n{USAGE}"),
                )
            })?;

            let ty: Type = match &nv.value {
                syn::Expr::Path(p) => {
                    let path = &p.path;
                    parse_quote! { #path }
                }
                other => {
                    return Err(syn::Error::new_spanned(
                        other,
                        "expected an IRQL level name",
                    ));
                }
            };

            let slot = match key.to_string().as_str() {
                "at" => &mut at,
                "min" => &mut min,
                "max" => &mut max,
                _ => {
                    return Err(syn::Error::new_spanned(
                        key,
                        format!(
                            "unknown parameter `{key}`. Expected `at`, `min`, or `max`.\n{USAGE}"
                        ),
                    ));
                }
            };

            if slot.is_some() {
                return Err(syn::Error::new_spanned(
                    key,
                    format!("`{key}` specified twice"),
                ));
            }
            *slot = Some(ty);
        }

        // `at` is mutually exclusive with `min`/`max`.
        if at.is_some() && (min.is_some() || max.is_some()) {
            return Err(syn::Error::new(
                proc_macro2::Span::call_site(),
                format!(
                    "`at` cannot be combined with `min` or `max`.\n\
                     `at = Level` means a fixed entry point. Use `max` (with optional `min`) \
                     for callable functions.\n{USAGE}"
                ),
            ));
        }

        // Either `at` or `max` must be set.
        if at.is_none() && max.is_none() {
            let hint = if min.is_some() {
                "`min` alone is not sufficient — `max` is required to define the IRQL ceiling \
                 that `call_irql!` relies on."
            } else {
                "`max` is required (unless using `at`). It defines the IRQL ceiling that \
                 `call_irql!` relies on."
            };
            return Err(syn::Error::new(
                proc_macro2::Span::call_site(),
                format!("{hint}\n{USAGE}"),
            ));
        }

        Ok(Self { min, max, at })
    }

    /// The IRQL level used by `call_irql!` inside the annotated body.
    ///
    /// Returns `at` if set, otherwise `max`.
    pub fn call_level(&self) -> &Type {
        self.at
            .as_ref()
            .or(self.max.as_ref())
            .expect("BUG: either `at` or `max` must be set")
    }
}

```

`crates/irql_macro/src/lib.rs`:

```rs
//! Procedural macros for compile-time IRQL safety.
//!
//! **Internal crate** — use [`irql`](https://docs.rs/irql) instead.

use proc_macro::TokenStream;
use quote::quote;
use syn::{ItemFn, ItemImpl};

mod apply;
mod call_irql;
mod constraints;

use constraints::IrqlConstraints;

/// Compile-time IRQL constraint macro.
///
/// See the [`irql` crate docs](https://docs.rs/irql) for usage.
#[proc_macro_attribute]
pub fn irql(attr: TokenStream, item: TokenStream) -> TokenStream {
    match irql_impl(attr, item) {
        Ok(ts) => ts,
        Err(e) => e.to_compile_error().into(),
    }
}

fn irql_impl(attr: TokenStream, item: TokenStream) -> syn::Result<TokenStream> {
    if attr.is_empty() {
        return Err(syn::Error::new(
            proc_macro2::Span::call_site(),
            format!("missing IRQL constraint.\n{}", constraints::USAGE),
        ));
    }

    let c = IrqlConstraints::parse(attr)?;

    // Fixed entry point — IRQL level is known, no generic parameter added.
    if let Some(ref at) = c.at {
        let mut f: ItemFn = syn::parse(item).map_err(|_| {
            syn::Error::new(
                proc_macro2::Span::call_site(),
                "#[irql(at = ...)] can only be applied to functions",
            )
        })?;
        apply::inject_drop_bounds(&mut f.sig.generics, &f.sig.inputs, at);
        apply::inject_body(&mut f.block.stmts, at, false);
        return Ok(quote! { #f }.into());
    }

    // Generic IRQL — function or impl block.
    // syn::parse consumes the TokenStream, so clone once for the fallback.
    if let Ok(mut f) = syn::parse::<ItemFn>(item.clone()) {
        apply::apply_to_function(&mut f, &c);
        return Ok(quote! { #f }.into());
    }

    let mut imp: ItemImpl = syn::parse(item).map_err(|_| {
        syn::Error::new(
            proc_macro2::Span::call_site(),
            "#[irql] can only be applied to functions or impl blocks",
        )
    })?;
    if imp.trait_.is_some() {
        apply::apply_to_trait_impl(&mut imp, &c)?;
    } else {
        apply::apply_to_impl_block(&mut imp, &c);
    }
    Ok(quote! { #imp }.into())
}

/// Hidden helper for `call_irql!` — injects IRQL as turbofish type argument.
#[doc(hidden)]
#[proc_macro]
pub fn call_irql_inner(input: TokenStream) -> TokenStream {
    match call_irql::call_irql_inner_impl(input) {
        Ok(ts) => ts,
        Err(e) => e.to_compile_error().into(),
    }
}

```

`examples/alloc_example/Cargo.toml`:

```toml
[package]
name = "alloc_example"
version.workspace = true
edition.workspace = true
publish = false

[dependencies]
irql = { path = "../../crates/irql", features = ["alloc"] }

```

`examples/alloc_example/src/main.rs`:

```rs
#![feature(allocator_api)]

//! IRQL-aware allocation example.
//!
//! Demonstrates compile-time enforcement of:
//! - Automatic pool selection based on IRQL level
//! - Access control on pool memory
//! - Explicit pool selection
//!
//! Outside a WDK build, `PoolAllocator` impls delegate to the global
//! allocator. In a real driver build, they use `ExAllocatePool2` / `ExFreePool`
//! from `wdk-sys` automatically.

use irql::*;

// ---------------------------------------------------------------------------
// Driver code
// ---------------------------------------------------------------------------

/// At Passive level, automatic allocation uses PagedPool.
#[irql(max = Passive)]
fn allocate_at_passive() -> Result<(), AllocError> {
    // IrqlBox::new(value) automatically selects PagedPool at Passive
    let data = call_irql!(IrqlBox::new(42))?;

    // Access is allowed: PagedPool is accessible at Passive
    let val = call_irql!(data.get());
    assert_eq!(*val, 42);

    // Mutable access
    let mut data = call_irql!(IrqlBox::new(0))?;
    *call_irql!(data.get_mut()) = 99;
    assert_eq!(*call_irql!(data.get()), 99);

    println!("Passive allocation OK: PagedPool, value = {val}");
    Ok(())
}

/// At Dispatch level, automatic allocation uses NonPagedPool.
#[irql(max = Dispatch)]
fn allocate_at_dispatch() -> Result<(), AllocError> {
    // IrqlBox::new(value) automatically selects NonPagedPool at Dispatch
    let data = call_irql!(IrqlBox::new(99))?;

    // Access is allowed: NonPagedPool is accessible at Dispatch
    let val = call_irql!(data.get());
    assert_eq!(*val, 99);

    println!("Dispatch allocation OK: NonPagedPool, value = {val}");
    Ok(())
}

/// Explicit pool selection: force NonPagedPool even at Passive.
#[irql(max = Passive)]
fn explicit_nonpaged() -> Result<(), AllocError> {
    let data = call_irql!(IrqlBox::<_, NonPagedPool>::new_in(123))?;
    let val = call_irql!(data.get());
    assert_eq!(*val, 123);

    println!("Explicit NonPagedPool at Passive OK: value = {val}");
    Ok(())
}

/// Demonstrate into_inner (consumes the box).
#[irql(max = Passive)]
fn consume_box() -> Result<(), AllocError> {
    let data = call_irql!(IrqlBox::new(String::from("hello")))?;
    let s = call_irql!(data.into_inner());
    assert_eq!(s, "hello");

    println!("into_inner OK: {s}");
    Ok(())
}

/// Demonstrate leak (prevents deallocation).
#[irql(max = Passive)]
fn leak_box() -> Result<(), AllocError> {
    let data = call_irql!(IrqlBox::new(777))?;
    let leaked: &'static mut i32 = data.leak();
    assert_eq!(*leaked, 777);

    println!("leak OK: {leaked}");
    // NOTE: memory is intentionally leaked (useful for passing to elevated IRQL)
    Ok(())
}

/// Demonstrate IrqlVec with the irql_vec! macro.
#[irql(max = Passive)]
fn vec_example() -> Result<(), TryReserveError> {
    // irql_vec![...] works like vec![...]
    let v = irql_vec![10, 20, 30]?;
    let s = call_irql!(v.as_slice());
    assert_eq!(s, &[10, 20, 30]);
    println!("irql_vec! OK: {s:?}");

    // Repeat form
    let v = irql_vec![42; 4]?;
    assert_eq!(call_irql!(v.as_slice()), &[42, 42, 42, 42]);
    println!("irql_vec![42; 4] OK: len = {}", v.len());

    // Push / pop
    let mut v = irql_vec![1, 2]?;
    call_irql!(v.push(3))?;
    assert_eq!(call_irql!(v.as_slice()), &[1, 2, 3]);
    let last = call_irql!(v.pop());
    assert_eq!(last, Some(3));
    println!("push/pop OK: {:?}", call_irql!(v.as_slice()));

    Ok(())
}

// ---------------------------------------------------------------------------
// Compile-error demonstrations (uncomment to verify)
// ---------------------------------------------------------------------------

// ERROR: cannot allocate at Dirql (no DefaultPool impl)
// #[irql(max = Dirql)]
// fn cannot_alloc_at_dirql() {
//     let _ = call_irql!(IrqlBox::new(1));
// }

// ERROR: cannot drop PagedPool memory at Dispatch (SafeToDropAtDispatch)
// #[irql(max = Dispatch)]
// fn cannot_drop_paged_at_dispatch(paged_box: IrqlBox<i32, PagedPool>) {
//     // Compile error: IrqlBox<i32, PagedPool> is !SafeToDropAtDispatch
// }

// ---------------------------------------------------------------------------
// Entry point
// ---------------------------------------------------------------------------

#[irql(at = Passive)]
fn main() {
    call_irql!(allocate_at_passive()).expect("passive alloc failed");
    call_irql!(allocate_at_dispatch()).expect("dispatch alloc failed");
    call_irql!(explicit_nonpaged()).expect("explicit nonpaged failed");
    call_irql!(consume_box()).expect("consume box failed");
    call_irql!(leak_box()).expect("leak box failed");
    call_irql!(vec_example()).expect("vec example failed");

    println!("\nAll IRQL-aware allocation tests passed!");
}

```

`examples/basic/Cargo.toml`:

```toml
[package]
name = "basic"
version.workspace = true
edition.workspace = true
publish = false

[dependencies]
irql = { path = "../../crates/irql" }

```

`examples/basic/src/main.rs`:

```rs
//! Basic IRQL constraint examples.
//!
//! Demonstrates `#[irql(max = ...)]`, `#[irql(min = ..., max = ...)]`,
//! and `#[irql(at = ...)]` on standalone functions.

use irql::*;

// Callable from Dispatch or below.
#[irql(max = Dispatch)]
fn dispatch_work() {}

// Callable from Passive or below.
#[irql(max = Passive)]
fn passive_work() {
    // Passive can raise to Dispatch
    call_irql!(dispatch_work());
}

// Callable from Passive through Dispatch (not Dirql+).
#[irql(min = Passive, max = Dispatch)]
fn passive_to_dispatch_only() {}

// Uncomment to see a compile error: Dispatch cannot lower to Passive.
// #[irql(max = Dispatch)]
// fn dispatch_calls_passive() {
//     call_irql!(passive_work());  // ERROR: cannot lower IRQL
// }

#[irql(at = Passive)]
fn main() {
    call_irql!(passive_work());
    call_irql!(passive_to_dispatch_only());
}

```

`examples/function_traits/Cargo.toml`:

```toml
[package]
name = "function_traits"
version.workspace = true
edition.workspace = true
publish = false

[dependencies]
irql = { path = "../../crates/irql" }

```

`examples/function_traits/src/main.rs`:

```rs
//! IRQL-safe function traits: [`IrqlFn`], [`IrqlFnMut`], [`IrqlFnOnce`].

use irql::{Dispatch, IrqlFn, IrqlFnMut, IrqlFnOnce, Passive, irql};

// -- IrqlFn: immutable, callable multiple times -------------------------

struct Reader {
    value: u32,
}

#[irql(max = Passive)]
impl IrqlFn<()> for Reader {
    type Output = u32;
    fn call(&self, _: ()) -> u32 {
        self.value
    }
}

// -- IrqlFnMut: mutable state -------------------------------------------

struct Counter {
    count: u32,
}

#[irql(max = Passive)]
impl IrqlFnMut<()> for Counter {
    type Output = u32;
    fn call_mut(&mut self, _: ()) -> u32 {
        self.count += 1;
        self.count
    }
}

// -- IrqlFnOnce: consumes self ------------------------------------------

struct Message(String);

#[irql(max = Dispatch)]
impl IrqlFnOnce<()> for Message {
    type Output = String;
    fn call_once(self, _: ()) -> String {
        self.0
    }
}

// -----------------------------------------------------------------------

#[irql(at = Passive)]
fn main() {
    // IrqlFn — can call multiple times
    let reader = Reader { value: 42 };
    println!("Reader: {}", call_irql!(reader.call(())));
    println!("Reader: {}", call_irql!(reader.call(())));

    // IrqlFnMut — mutable calls
    let mut counter = Counter { count: 0 };
    println!("Counter: {}", call_irql!(counter.call_mut(())));
    println!("Counter: {}", call_irql!(counter.call_mut(())));
    println!("Counter: {}", call_irql!(counter.call_mut(())));

    // IrqlFnOnce — consumes self
    let msg = Message("Hello from Dispatch!".to_string());
    println!("Message: {}", call_irql!(msg.call_once(())));
}

```

`examples/struct_example/Cargo.toml`:

```toml
[package]
name = "struct_example"
version.workspace = true
edition.workspace = true
publish = false

[dependencies]
irql = { path = "../../crates/irql" }

```

`examples/struct_example/src/main.rs`:

```rs
//! Struct methods with IRQL constraints via impl blocks.

use irql::*;

struct Device {
    _name: &'static str,
}

#[irql(max = Dispatch)]
impl Device {
    fn new(name: &'static str) -> Self {
        Device { _name: name }
    }

    fn process_interrupt(&self) {
        // Runs at Dispatch or below.
    }
}

struct Driver {
    device: Device,
}

#[irql(max = Passive)]
impl Driver {
    fn new(device_name: &'static str) -> Self {
        let device = call_irql!(Device::new(device_name));
        Driver { device }
    }

    fn start(&self) {
        call_irql!(self.device.process_interrupt());
    }
}

#[irql(at = Passive)]
fn main() {
    let driver = call_irql!(Driver::new("example_device"));
    call_irql!(driver.start());
}

```

`rust-toolchain.toml`:

```toml
[toolchain]
channel = "nightly"

```