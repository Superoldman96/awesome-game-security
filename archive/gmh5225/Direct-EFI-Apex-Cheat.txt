Project Path: arc_gmh5225_Direct-EFI-Apex-Cheat__1uukgen

Source Tree:

```txt
arc_gmh5225_Direct-EFI-Apex-Cheat__1uukgen
├── CRZAimbot
│   ├── CRZAimbot.vcxproj
│   ├── CRZAimbot.vcxproj.filters
│   ├── Config.h
│   ├── Driver.cpp
│   ├── Driver.h
│   ├── Entity.cpp
│   ├── Entity.h
│   ├── Main.cpp
│   ├── Main.h
│   ├── Math.cpp
│   ├── Math.h
│   ├── MemProtector.cpp
│   ├── MemProtector.h
│   ├── Offsets.h
│   └── Vector.h
├── CRZAimbot.sln
└── CRZEFI
    ├── Makefile
    ├── definitions.h
    ├── dummy.h
    └── main.c

```

`CRZAimbot.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29926.136
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CRZAimbot", "CRZAimbot\CRZAimbot.vcxproj", "{4F591BCC-3E2D-4D50-9A74-3C0D162A939D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Production|x64 = Production|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4F591BCC-3E2D-4D50-9A74-3C0D162A939D}.Debug|x64.ActiveCfg = Debug|x64
		{4F591BCC-3E2D-4D50-9A74-3C0D162A939D}.Debug|x64.Build.0 = Debug|x64
		{4F591BCC-3E2D-4D50-9A74-3C0D162A939D}.Production|x64.ActiveCfg = Production|x64
		{4F591BCC-3E2D-4D50-9A74-3C0D162A939D}.Production|x64.Build.0 = Production|x64
		{4F591BCC-3E2D-4D50-9A74-3C0D162A939D}.Release|x64.ActiveCfg = Release|x64
		{4F591BCC-3E2D-4D50-9A74-3C0D162A939D}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {2827BCB3-AB5D-498C-BCCE-8367E670B9D8}
	EndGlobalSection
EndGlobal

```

`CRZAimbot/CRZAimbot.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Production|x64">
      <Configuration>Production</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{4F591BCC-3E2D-4D50-9A74-3C0D162A939D}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>CRZAimbot</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Production|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Production|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Production|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;_DEBUG;CRZAIMBOT_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;NDEBUG;CRZAIMBOT_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Production|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;NDEBUG;CRZAIMBOT_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <SubSystem>
      </SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <ProgramDatabaseFile />
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="Driver.cpp" />
    <ClCompile Include="Entity.cpp" />
    <ClCompile Include="Math.cpp" />
    <ClCompile Include="MemProtector.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Config.h" />
    <ClInclude Include="Driver.h" />
    <ClInclude Include="Entity.h" />
    <ClInclude Include="Main.h" />
    <ClInclude Include="Math.h" />
    <ClInclude Include="MemProtector.h" />
    <ClInclude Include="Offsets.h" />
    <ClInclude Include="Vector.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CRZAimbot/CRZAimbot.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Archivos de origen">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Archivos de encabezado">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Game">
      <UniqueIdentifier>{15a77666-c067-4594-adba-fc2147cb179d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Others">
      <UniqueIdentifier>{d346013b-a67c-4fbc-97a9-62bfff8afd40}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="MemProtector.cpp">
      <Filter>Archivos de origen</Filter>
    </ClCompile>
    <ClCompile Include="Driver.cpp">
      <Filter>Archivos de origen</Filter>
    </ClCompile>
    <ClCompile Include="Entity.cpp">
      <Filter>Game</Filter>
    </ClCompile>
    <ClCompile Include="Math.cpp">
      <Filter>Others</Filter>
    </ClCompile>
    <ClCompile Include="Main.cpp">
      <Filter>Archivos de origen</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="MemProtector.h">
      <Filter>Archivos de encabezado</Filter>
    </ClInclude>
    <ClInclude Include="Config.h">
      <Filter>Archivos de encabezado</Filter>
    </ClInclude>
    <ClInclude Include="Driver.h">
      <Filter>Archivos de encabezado</Filter>
    </ClInclude>
    <ClInclude Include="Entity.h">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="Offsets.h">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="Vector.h">
      <Filter>Others</Filter>
    </ClInclude>
    <ClInclude Include="Math.h">
      <Filter>Others</Filter>
    </ClInclude>
    <ClInclude Include="Main.h">
      <Filter>Archivos de encabezado</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`CRZAimbot/Config.h`:

```h
#pragma once

//MISC
#define SMOOTH 2.f //1~20
#define Max_Cheat_Distance 400.f


//XOR Keys
#define STRING_XOR_KEY 0x6F
```

`CRZAimbot/Driver.cpp`:

```cpp
#include "Driver.h"


HANDLE Driver::driverH = 0;
uintptr_t Driver::currentProcessId = 0;
GUID DummyGuid = { 2 };
mRtlAdjustPrivilege myRtlAdjustPrivilege = (mRtlAdjustPrivilege)NULL;
mNtSetSystemEnvironmentValueEx myNtSetSystemEnvironmentValueEx = (mNtSetSystemEnvironmentValueEx)NULL;
mNtQuerySystemInformation myNtQuerySystemInformation = (mNtQuerySystemInformation)NULL;

NTSTATUS SetSystemEnvironmentPrivilege(BOOLEAN Enable, PBOOLEAN WasEnabled)
{
	if (WasEnabled != nullptr)
		*WasEnabled = FALSE;

	BOOLEAN SeSystemEnvironmentWasEnabled;
	const NTSTATUS Status = myRtlAdjustPrivilege(SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
		Enable,
		FALSE,
		&SeSystemEnvironmentWasEnabled);

	SLog(std::wstring(L"Privilege status: " + std::to_wstring((DWORD)Status)).c_str());

	if (NT_SUCCESS(Status) && WasEnabled != nullptr)
		*WasEnabled = SeSystemEnvironmentWasEnabled;

	return Status;
}

void Driver::SendCommand(MemoryCommand* cmd) {
	Protect(_ReturnAddress());
    wchar_t VarName[] = { 'F','a','s','t','B','o','o','t','O','p','t','i','o','n','\0' };
	UNICODE_STRING FVariableName = UNICODE_STRING();
	FVariableName.Buffer = VarName;
	FVariableName.Length = 28;
	FVariableName.MaximumLength = 30;
	//UNICODE_STRING VariableName2 = { sizeof(VARIABLE_NAME) - sizeof(VARIABLE_NAME[0]),sizeof(VARIABLE_NAME),(PWSTR)VARIABLE_NAME };
	//UNICODE_STRING VariableName = RTL_CONSTANT_STRING(VARIABLE_NAME);
	myNtSetSystemEnvironmentValueEx(
		&FVariableName,
		&DummyGuid,
		cmd,
		sizeof(MemoryCommand),
		ATTRIBUTES);
	memset(VarName, 0, sizeof(VarName));
	//memset(VariableName.Buffer, 0, VariableName.Length);
	//VariableName.Length = 0;
	Unprotect(_ReturnAddress());
}


uintptr_t Driver::GetBaseAddress(uintptr_t pid) {
	Protect(_ReturnAddress());
	uintptr_t result = 0;
	MemoryCommand cmd = MemoryCommand();
	cmd.operation = baseOperation * 0x289;
	cmd.magic = COMMAND_MAGIC;
	cmd.data[0] = pid;
	cmd.data[1] = (uintptr_t)&result;
	Unprotect(SendCommand);
	SendCommand(&cmd);
	Protect(SendCommand);
	Unprotect(_ReturnAddress());
	return result;
}

NTSTATUS Driver::copy_memory(
	const uintptr_t	src_process_id,
	const uintptr_t src_address,
	const uintptr_t	dest_process_id,
	const uintptr_t	dest_address,
	const size_t	size) {
	Protect(_ReturnAddress());
	uintptr_t result = 0;
	MemoryCommand cmd = MemoryCommand();
	cmd.operation = baseOperation * 0x823;
	cmd.magic = COMMAND_MAGIC;
	cmd.data[0] = (uintptr_t)src_process_id;
	cmd.data[1] = (uintptr_t)src_address;
	cmd.data[2] = (uintptr_t)dest_process_id;
	cmd.data[3] = (uintptr_t)dest_address;
	cmd.data[4] = (uintptr_t)size;
	cmd.data[5] = (uintptr_t)&result;
	Unprotect(SendCommand);
	SendCommand(&cmd);
	Protect(SendCommand);
	Unprotect(_ReturnAddress());
	return (NTSTATUS)result;
}

uintptr_t GetKernelModuleExport(uintptr_t kernel_module_base, char* function_name)
{
	if (!kernel_module_base)
		return 0;

	IMAGE_DOS_HEADER dos_header = { 0 };
	IMAGE_NT_HEADERS64 nt_headers = { 0 };

	Unprotect(Driver::read_memory);
	Driver::read_memory(4, kernel_module_base, (uintptr_t)&dos_header, sizeof(dos_header));
	Protect(Driver::read_memory);
	if (dos_header.e_magic != IMAGE_DOS_SIGNATURE)
		return 0;

	Unprotect(Driver::read_memory);
	Driver::read_memory(4, kernel_module_base + dos_header.e_lfanew, (uintptr_t)&nt_headers, sizeof(nt_headers));
	Protect(Driver::read_memory);
	if (nt_headers.Signature != IMAGE_NT_SIGNATURE)
		return 0;

	const auto export_base = nt_headers.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
	const auto export_base_size = nt_headers.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

	if (!export_base || !export_base_size)
		return 0;

	const auto export_data = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(VirtualAlloc(nullptr, export_base_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));

	Unprotect(Driver::read_memory);
	Driver::read_memory(4, kernel_module_base + export_base, (uintptr_t)export_data, export_base_size);
	Protect(Driver::read_memory);
	//if (!ReadMemory(device_handle, kernel_module_base + export_base, export_data, export_base_size))
	//{
	//	VirtualFree(export_data, 0, MEM_RELEASE);
	//	return 0;
	//}

	const auto delta = reinterpret_cast<uintptr_t>(export_data) - export_base;

	const auto name_table = reinterpret_cast<UINT32*>(export_data->AddressOfNames + delta);
	const auto ordinal_table = reinterpret_cast<UINT16*>(export_data->AddressOfNameOrdinals + delta);
	const auto function_table = reinterpret_cast<UINT32*>(export_data->AddressOfFunctions + delta);

	for (auto i = 0u; i < export_data->NumberOfNames; ++i)
	{
		char * current_function_name = (char*)(name_table[i] + delta);

		if (!_stricmp(current_function_name, function_name))
		{
			const auto function_ordinal = ordinal_table[i];
			const auto function_address = kernel_module_base + function_table[function_ordinal];

			if (function_address >= kernel_module_base + export_base && function_address <= kernel_module_base + export_base + export_base_size)
			{
				VirtualFree(export_data, 0, MEM_RELEASE);
				return 0; // No forwarded exports on 64bit?
			}

			VirtualFree(export_data, 0, MEM_RELEASE);
			return function_address;
		}
	}

	VirtualFree(export_data, 0, MEM_RELEASE);
	return 0;
}

uintptr_t GetKernelModuleAddress(char* module_name)
{
	void* buffer = nullptr;
	DWORD buffer_size = 0;

	NTSTATUS status = myNtQuerySystemInformation(static_cast<SYSTEM_INFORMATION_CLASS>(SystemModuleInformation), buffer, buffer_size, &buffer_size);

	while (status == STATUS_INFO_LENGTH_MISMATCH)
	{
		VirtualFree(buffer, 0, MEM_RELEASE);

		buffer = VirtualAlloc(nullptr, buffer_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		if (buffer == 0){
			return 0;
		}
		status = myNtQuerySystemInformation(static_cast<SYSTEM_INFORMATION_CLASS>(SystemModuleInformation), buffer, buffer_size, &buffer_size);
	}

	if (!NT_SUCCESS(status))
	{
		VirtualFree(buffer, 0, MEM_RELEASE);
		return 0;
	}

	const PRTL_PROCESS_MODULES modules = (PRTL_PROCESS_MODULES)buffer;
	if (modules == nullptr) {
		VirtualFree(buffer, 0, MEM_RELEASE);
		return 0;
	}
	for (auto i = 0u; i < modules->NumberOfModules; ++i)
	{
		char* current_module_name = (char*)(modules->Modules[i].FullPathName + modules->Modules[i].OffsetToFileName);

		if (!_stricmp(current_module_name, module_name))
		{
			const uintptr_t result = (uintptr_t)(modules->Modules[i].ImageBase);

			VirtualFree(buffer, 0, MEM_RELEASE);
			return result;
		}
	}

	VirtualFree(buffer, 0, MEM_RELEASE);
	return 0;
}

bool Driver::initialize() {
	Protect(_ReturnAddress());
	currentProcessId = GetCurrentProcessId();
	BOOLEAN SeSystemEnvironmentWasEnabled;
	SLog(L"Driver Init");
	HMODULE ntmodule = LoadLibraryW(L"ntdll.dll");
	SLog(std::wstring(L"loaded ntdll "+ std::to_wstring((DWORD)ntmodule) +L" p "+ std::to_wstring(currentProcessId)).c_str());
	BYTE ntqsi[] = { 'N','t','Q','u','e','r','y','S','y','s','t','e','m','I','n','f','o','r','m','a','t','i','o','n',0 };
	BYTE nssevex[] = { 'N','t','S','e','t','S','y','s','t','e','m','E','n','v','i','r','o','n','m','e','n','t','V','a','l','u','e','E','x',0 };
	BYTE rtlajp[] = { 'R','t','l','A','d','j','u','s','t','P','r','i','v','i','l','e','g','e',0 };
	myNtQuerySystemInformation = (mNtQuerySystemInformation)GetProcAddress(ntmodule, (char*)ntqsi);
	myNtSetSystemEnvironmentValueEx = (mNtSetSystemEnvironmentValueEx)GetProcAddress(ntmodule, (char*)nssevex);
	myRtlAdjustPrivilege = (mRtlAdjustPrivilege)GetProcAddress(ntmodule, (char*)rtlajp);
	//memset(ntqsi, 0, sizeof(ntqsi));
	//memset(nssevex, 0, sizeof(nssevex));
	//memset(rtlajp, 0, sizeof(rtlajp));

	SLog(std::wstring(L"Funcs 1 " + std::to_wstring((uintptr_t)myNtQuerySystemInformation) + L" 2 " + std::to_wstring((uintptr_t)myNtSetSystemEnvironmentValueEx) + L" 3 " + std::to_wstring((uintptr_t)myRtlAdjustPrivilege)).c_str());

	Unprotect(SetSystemEnvironmentPrivilege);
	NTSTATUS status = SetSystemEnvironmentPrivilege(true, &SeSystemEnvironmentWasEnabled);
	Protect(SetSystemEnvironmentPrivilege);

	if (!NT_SUCCESS(status)) {
		Unprotect(_ReturnAddress());
		return false;
	}

	SLog(L"Cleared old");

	Unprotect(GetKernelModuleAddress);
	BYTE nstosname[] = {'n','t','o','s','k','r','n','l','.','e','x','e',0};
	uintptr_t kernelModuleAddress = GetKernelModuleAddress((char*)nstosname);
	memset(nstosname, 0, sizeof(nstosname));
	SLog(std::wstring(L"kernel module addr " + std::to_wstring((uintptr_t)kernelModuleAddress)).c_str());
	Protect(GetKernelModuleAddress);
	
	Unprotect(GetKernelModuleExport);
	BYTE pbid[] = { 'P','s','L','o','o','k','u','p','P','r','o','c','e','s','s','B','y','P','r','o','c','e','s','s','I','d',0 };
	BYTE gba[] = { 'P','s','G','e','t','P','r','o','c','e','s','s','S','e','c','t','i','o','n','B','a','s','e','A','d','d','r','e','s','s',0 };
	BYTE mmcp[] = { 'M','m','C','o','p','y','V','i','r','t','u','a','l','M','e','m','o','r','y',0 };
	uintptr_t kernel_PsLookupProcessByProcessId = GetKernelModuleExport(kernelModuleAddress, (char*)pbid);
	uintptr_t kernel_PsGetProcessSectionBaseAddress = GetKernelModuleExport(kernelModuleAddress, (char*)gba);
	uintptr_t kernel_MmCopyVirtualMemory = GetKernelModuleExport(kernelModuleAddress, (char*)mmcp);
	SLog(std::wstring(L"exports " + std::to_wstring((uintptr_t)kernel_PsLookupProcessByProcessId) + L" - " + std::to_wstring((uintptr_t)kernel_PsGetProcessSectionBaseAddress)+ L" - " + std::to_wstring((uintptr_t)kernel_MmCopyVirtualMemory)).c_str());
	memset(pbid, 0, sizeof(pbid));
	memset(gba, 0, sizeof(gba));
	memset(mmcp, 0, sizeof(mmcp));
	Protect(GetKernelModuleExport);
	
	uintptr_t result = 0;
	MemoryCommand cmd = MemoryCommand();
	cmd.operation = baseOperation * 0x612;
	cmd.magic = COMMAND_MAGIC;
	cmd.data[0] = kernel_PsLookupProcessByProcessId;
	cmd.data[1] = kernel_PsGetProcessSectionBaseAddress;
	cmd.data[2] = kernel_MmCopyVirtualMemory;
	cmd.data[3] = (uintptr_t)&result;
	Unprotect(SendCommand);
	SLog(L"Sending config");
	SendCommand(&cmd);
	SLog(L"configured");
	Protect(SendCommand);
	
	Unprotect(_ReturnAddress());
	return result;
}

NTSTATUS Driver::read_memory(
	const uintptr_t	process_id,
	const uintptr_t address,
	const uintptr_t buffer,
	const size_t	size) {
	Protect(_ReturnAddress());
	Unprotect(copy_memory);
	NTSTATUS result = copy_memory(process_id, address, currentProcessId, buffer, size);
	Protect(copy_memory);
	Unprotect(_ReturnAddress());
	return result;
}

NTSTATUS Driver::write_memory(
	const uintptr_t	process_id,
	const uintptr_t address,
	const uintptr_t buffer,
	const size_t	size) {
	Protect(_ReturnAddress());
	Unprotect(copy_memory);
	NTSTATUS result = copy_memory(currentProcessId, buffer, process_id, address, size);
	Protect(copy_memory);
	Unprotect(_ReturnAddress());
	return result;
}

```

`CRZAimbot/Driver.h`:

```h
#pragma once
#include <Windows.h>
#include <winternl.h>
//#pragma comment(lib, "ntdll.lib")
#include <stdio.h>
#include "MemProtector.h"
#include "Config.h"
//#include <string>

#define baseOperation 0x7980

//#define VARIABLE_NAME L"FastBootOption"
#define COMMAND_MAGIC baseOperation*0x5478

#define EFI_VARIABLE_NON_VOLATILE                          0x00000001
#define EFI_VARIABLE_BOOTSERVICE_ACCESS                    0x00000002
#define EFI_VARIABLE_RUNTIME_ACCESS                        0x00000004
#define EFI_VARIABLE_HARDWARE_ERROR_RECORD                 0x00000008
#define EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS            0x00000010
#define EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS 0x00000020
#define EFI_VARIABLE_APPEND_WRITE                          0x00000040
#define ATTRIBUTES (EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS)

#define SE_SYSTEM_ENVIRONMENT_PRIVILEGE (22L)
#define RTL_CONSTANT_STRING(s) { sizeof(s) - sizeof((s)[0]), sizeof(s), (PWSTR)s }

extern GUID DummyGuid;

typedef NTSTATUS (*mRtlAdjustPrivilege)(ULONG Privilege, BOOLEAN Enable, BOOLEAN Client, PBOOLEAN WasEnabled);
typedef NTSTATUS (*mNtSetSystemEnvironmentValueEx)(PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, ULONG ValueLength, ULONG Attributes);
typedef NTSTATUS (*mNtQuerySystemInformation)(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
extern mRtlAdjustPrivilege myRtlAdjustPrivilege;
extern mNtSetSystemEnvironmentValueEx myNtSetSystemEnvironmentValueEx;
extern mNtQuerySystemInformation myNtQuerySystemInformation;

//extern "C"
//{
//	NTSYSAPI
//		NTSTATUS
//		NTAPI
//		RtlAdjustPrivilege(
//			_In_ ULONG Privilege,
//			_In_ BOOLEAN Enable,
//			_In_ BOOLEAN Client,
//			_Out_ PBOOLEAN WasEnabled
//		);
//
//	NTSYSCALLAPI
//		NTSTATUS
//		NTAPI
//		NtSetSystemEnvironmentValueEx(
//			_In_ PUNICODE_STRING VariableName,
//			_In_ LPGUID VendorGuid,
//			_In_reads_bytes_opt_(ValueLength) PVOID Value,
//			_In_ ULONG ValueLength,
//			_In_ ULONG Attributes
//		);
//}

typedef struct _MemoryCommand {
	int magic;
	int operation;
	unsigned long long data[6];
} MemoryCommand;

constexpr auto STATUS_INFO_LENGTH_MISMATCH = 0xC0000004;

constexpr auto SystemModuleInformation = 11;
constexpr auto SystemHandleInformation = 16;
constexpr auto SystemExtendedHandleInformation = 64;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

uintptr_t GetKernelModuleAddress(char* module_name);
uintptr_t GetKernelModuleExport(uintptr_t kernel_module_base, char* function_name);
NTSTATUS SetSystemEnvironmentPrivilege(BOOLEAN Enable, PBOOLEAN WasEnabled);

namespace Driver
{
	bool	initialize();
	extern uintptr_t currentProcessId;
	extern HANDLE driverH;

	void SendCommand(MemoryCommand* cmd);
	NTSTATUS copy_memory(uintptr_t src_process_id, uintptr_t src_address, uintptr_t dest_process_id, uintptr_t dest_address, size_t size);
	NTSTATUS read_memory(uintptr_t process_id, uintptr_t address, uintptr_t buffer, size_t size);
	NTSTATUS write_memory(uintptr_t process_id, uintptr_t address, uintptr_t buffer, size_t size);
	uintptr_t GetBaseAddress(uintptr_t pid);

	template <typename T>
	T read(const uintptr_t process_id, const uintptr_t address, PNTSTATUS out_status = 0)
	{
		Protect(_ReturnAddress());
		T buffer{ };
		Unprotect(read_memory);
		NTSTATUS status = read_memory(process_id, address, uintptr_t(&buffer), sizeof(T));
		Protect(read_memory);
		if (out_status)
			*out_status = status;
		Unprotect(_ReturnAddress());
		return buffer;
	}

	template <typename T>
	void write(const uintptr_t process_id, const uintptr_t address, const T& buffer, PNTSTATUS out_status =0)
	{
		Protect(_ReturnAddress());
		Unprotect(write_memory);
		NTSTATUS status = write_memory(process_id, address, uintptr_t(&buffer), sizeof(T));
		Protect(write_memory);
		if (out_status)
			*out_status = status;
		Unprotect(_ReturnAddress());
	}
}


```

`CRZAimbot/Entity.cpp`:

```cpp
#include "Entity.h"

//unsigned long long offset_ran_var = OFFSET_RAN;

Entity* getEntity(uintptr_t g_PID, uintptr_t ptr) {
	Protect(_ReturnAddress());
	Entity* entity = new Entity();
	entity->ptr = ptr;
	Unprotect(Driver::read_memory);
	Driver::read_memory(g_PID, ptr, (uintptr_t)entity->buffer, TOFFSET(ENTITY_SIZE_DEF));
	Protect(Driver::read_memory);
	Unprotect(_ReturnAddress());
	return entity;
}

int paddingsub() {
	return NULL;
}

uintptr_t Entity::Observing(uintptr_t g_PID, uintptr_t entitylist) {

	if (*(int*)(buffer + TOFFSET(OFFSET_OBSERVER_MODE)) == 5) {
		unsigned long ot = *(unsigned long*)(buffer + TOFFSET(OFFSET_OBSERVING_TARGET));
		int index = ot & ENT_ENTRY_MASK;
		int ObserverID = index;
		if (ObserverID > 0) {
			uintptr_t centity2 = Driver::read<uintptr_t>(g_PID, entitylist + ((uintptr_t)ObserverID << 5));
			return centity2;
		}
		return 1;
	}
	return 0;
}
int Entity::getTeamId() {

	return *(int*)(buffer + TOFFSET(OFFSET_TEAM));
}
int Entity::getHealth() {

	return *(int*)(buffer + TOFFSET(OFFSET_HEALTH));
}

bool Entity::isOkLifeState() {

	return *(int*)(buffer + TOFFSET(OFFSET_LIFE_STATE)) == 0;
}

unsigned char Entity::getArmorType() {

	return *(unsigned char*)(buffer + TOFFSET(OFFSET_HELMET_TYPE) + 0x4);
}

bool Entity::isBleedOut() {
	return *(int*)(buffer + TOFFSET(OFFSET_BLEED_OUT_STATE)) != 0;
}

int Entity::getShield() {
	return *(int*)(buffer + TOFFSET(OFFSET_SHIELD));
}

int Entity::getMaxShield() {
	return *(int*)(buffer + TOFFSET(OFFSET_MAX_SHIELD));
}

unsigned char Entity::getHelmetType() {
	return *(unsigned char*)(buffer + TOFFSET(OFFSET_HELMET_TYPE));
}

Vector Entity::getPosition() {
	return *(Vector*)(buffer + TOFFSET(OFFSET_ORIGIN));
}
bool Entity::isPlayer() {
	return *(uintptr_t*)(buffer + TOFFSET(OFFSET_NAME)) == 125780153691248;
}
Vector Entity::getBonePosition(uintptr_t g_PID, int id) {

	Vector position = getPosition();
	uintptr_t boneArray = *(uintptr_t*)(buffer + TOFFSET(OFFSET_BONES));
	Vector bone = Vector();
	UINT32 boneloc = (id * 0x30);
	Bone bo = {};
	bo = Driver::read<Bone>(g_PID, boneArray + boneloc);

	bone.x = bo.x + position.x;
	bone.y = bo.y + position.y;
	bone.z = bo.z + position.z;
	return bone;
}

Vector Entity::GetViewAngles() {
	return *(Vector*)(buffer + TOFFSET(OFFSET_VIEWANGLES));
}

Vector Entity::GetBreathAngles() {
	return *(Vector*)(buffer + TOFFSET(OFFSET_BREATH_ANGLES));
}

Vector Entity::GetViewAnglesV() {
	return *(Vector*)(buffer + TOFFSET(OFFSET_VIEWANGLES));
}

void Entity::SetViewAngles(uintptr_t pid, Vector angles) {
	Driver::write<Vector>(pid, ptr + TOFFSET(OFFSET_VIEWANGLES), angles);
}


Vector Entity::GetCamPos()
{

	return *(Vector*)(buffer + TOFFSET(OFFSET_CAMERAPOS));
}

Vector Entity::GetRecoil()
{

	return *(Vector*)(buffer + TOFFSET(OFFSET_AIMPUNCH));
}

uintptr_t Entity::CurrentWeapon(uintptr_t pid, uintptr_t entityList) {

	uintptr_t ActWeaponId = *(uintptr_t*)(buffer + TOFFSET(OFFSET_CURRENT_WEAPON)) & 0xFFFF;
	if (ActWeaponId)
	{

		return Driver::read<uintptr_t>(pid, entityList + (ActWeaponId << 5));
	}
	return 0;
}
Vector Entity::GetVelocity() {

	return *(Vector*)(buffer + TOFFSET(OFFSET_ORIGIN) - 0xC);
}


```

`CRZAimbot/Entity.h`:

```h
#pragma once

#include <Windows.h>
#include "Vector.h"
#include "Offsets.h"
#include "Driver.h"

#define NUM_ENT_ENTRIES			(1 << 12)
#define ENT_ENTRY_MASK			(NUM_ENT_ENTRIES - 1)
int paddingsub();
class Entity {
public:
	uintptr_t ptr;
	BYTE buffer[ENTITY_SIZE_DEF];
	Vector getPosition();
	bool isPlayer();
	int getTeamId();
	int getHealth();
	int getShield();
	int getMaxShield();
	unsigned char getArmorType();
	unsigned char getHelmetType();
	bool isOkLifeState();
	bool isBleedOut();
	Vector GetViewAngles();
	Vector GetBreathAngles();
	Vector GetCamPos();
	Vector GetRecoil();
	Vector GetViewAnglesV();
	Vector GetVelocity();

	uintptr_t CurrentWeapon(uintptr_t pid, uintptr_t entityList);
	void SetViewAngles(uintptr_t pid, Vector angles);
	Vector getBonePosition(uintptr_t g_PID, int id);
	uintptr_t Observing(uintptr_t g_PID, uintptr_t entitylist);

private:
	struct Bone {
		BYTE shit[0xCC];
		float x;
		BYTE shit2[0xC];
		float y;
		BYTE shit3[0xC];
		float z;
	};
};
Entity* getEntity(uintptr_t g_PID, uintptr_t ptr);
```

`CRZAimbot/Main.cpp`:

```cpp

#include "Main.h"


uintptr_t GamePid = 0;
uintptr_t GameBaseAddress = 0;
uintptr_t entitylist = 0;

uintptr_t Spectators = 0;

uintptr_t nextAim = 0;
uintptr_t AimTarget = 0;
uintptr_t nextEntityInfoUpdate = 0;

float current_fov_limiter = 999.f;


bool printableOut = false;

int enable_aimbot = 1;
int enable_aimbot_lock_mode = 1;
int disable_aimbot_with_spectators = 0;
int disable_aimbot_lock_mode_with_spectators = 1;
int count_team_entities_as_spectators = 1;
int enable_glow_hack = 1;


typedef bool (Entity::* EntityPtrDef)();
uintptr_t eptr(EntityPtrDef method) {
    return *(uintptr_t*)&method;
}

void LoadProtectedFunctions() {
    uintptr_t t = milliseconds_now();
    BYTE xorkey = 0x0;
    for (DWORD i = 0; i < 8; i++) {
        xorkey = ((BYTE*)&t)[i];
        if (xorkey > 0x3 && xorkey < 0xf0) {
            break;
        }
    }
    if (xorkey <= 0x3 || xorkey >= 0xf0) {
        xorkey = 0x56;
    }

    addFunc({ LoadProtectedFunctions, (uintptr_t)CheckDriverStatus - (uintptr_t)LoadProtectedFunctions - 0x3, xorkey, false });
    addFunc({ CheckDriverStatus, (uintptr_t)GetProcessIdByName - (uintptr_t)CheckDriverStatus - 0x3, xorkey, false });
    addFunc({ GetProcessIdByName, (uintptr_t)milliseconds_now - (uintptr_t)GetProcessIdByName - 0x3, xorkey, false });
    addFunc({ milliseconds_now, (uintptr_t)ProcessPlayer - (uintptr_t)milliseconds_now - 0x3, xorkey, false });
    addFunc({ ProcessPlayer, (uintptr_t)UpdatePlayersInfo - (uintptr_t)ProcessPlayer - 0x3, xorkey, false });
    addFunc({ UpdatePlayersInfo, (uintptr_t)PredictPosition - (uintptr_t)UpdatePlayersInfo - 0x3, xorkey, false });
    addFunc({ PredictPosition, (uintptr_t)AutoBoneSwitch - (uintptr_t)PredictPosition - 0x3, xorkey, false });
    addFunc({ AutoBoneSwitch, (uintptr_t)SmoothType_Asist - (uintptr_t)AutoBoneSwitch - 0x3, xorkey, false });
    addFunc({ SmoothType_Asist, (uintptr_t)SmoothType_TargetLock - (uintptr_t)SmoothType_Asist - 0x3, xorkey, false });
    addFunc({ SmoothType_TargetLock, (uintptr_t)AimAngles - (uintptr_t)SmoothType_TargetLock - 0x3, xorkey, false });
    addFunc({ AimAngles, (uintptr_t)CheatLoop - (uintptr_t)AimAngles - 0x3, xorkey, false });
    addFunc({ CheatLoop, (uintptr_t)Configure - (uintptr_t)CheatLoop - 0x3, xorkey, false });
    addFunc({ Configure, (uintptr_t)mainThread - (uintptr_t)Configure - 0x3, xorkey, false });
    addFunc({ mainThread, (uintptr_t)DllMain - (uintptr_t)mainThread - 0x3, xorkey, false });
    addFunc({ DllMain, (uintptr_t)std::_Narrow_char_traits<char, int>::eof - (uintptr_t)DllMain - 0x3, xorkey, false });


    addFunc({ Driver::SendCommand, (uintptr_t)Driver::GetBaseAddress - (uintptr_t)Driver::SendCommand - 0x3, xorkey, false });
    addFunc({ Driver::GetBaseAddress, (uintptr_t)Driver::copy_memory - (uintptr_t)Driver::GetBaseAddress - 0x3, xorkey, false });
    addFunc({ Driver::copy_memory, (uintptr_t)GetKernelModuleExport - (uintptr_t)Driver::copy_memory - 0x3, xorkey, false });
    addFunc({ GetKernelModuleExport, (uintptr_t)GetKernelModuleAddress - (uintptr_t)GetKernelModuleExport - 0x3, xorkey, false });
    addFunc({ GetKernelModuleAddress, (uintptr_t)Driver::initialize - (uintptr_t)GetKernelModuleAddress - 0x3, xorkey, false });
    addFunc({ Driver::initialize, (uintptr_t)Driver::read_memory - (uintptr_t)Driver::initialize - 0x3, xorkey, false });
    addFunc({ Driver::read_memory, (uintptr_t)Driver::write_memory - (uintptr_t)Driver::read_memory - 0x3, xorkey, false });
    addFunc({ Driver::write_memory, (uintptr_t)getEntity - (uintptr_t)Driver::write_memory - 0x3, xorkey, false });
    addFunc({ getEntity, (uintptr_t)paddingsub - (uintptr_t)getEntity - 0x3, xorkey, false });

    
    addFunc({ (void*)eptr(&Entity::isPlayer), eptr((EntityPtrDef)&Entity::getBonePosition) - eptr(&Entity::isPlayer) - 0x3, xorkey, false });
    addFunc({ (void*)eptr((EntityPtrDef)&Entity::getBonePosition), eptr((EntityPtrDef)&Entity::GetViewAngles) - eptr((EntityPtrDef)&Entity::getBonePosition) - 0x3, xorkey, false });
    addFunc({ (void*)eptr((EntityPtrDef)&Entity::Observing), eptr((EntityPtrDef)&Entity::getTeamId) - eptr((EntityPtrDef)&Entity::Observing) - 0x3, xorkey, false });
    
    for (size_t i = 0; i < funcCount; i++) {
        if (functions[i].address != LoadProtectedFunctions)
            Protect(functions[i].address);
    }
    Unprotect(_ReturnAddress());
}

bool CheckDriverStatus() {
    int icheck = 29;
    NTSTATUS status = 0;
    SLog(L"getting base");
    Unprotect(Driver::GetBaseAddress);
    uintptr_t BaseAddr = Driver::GetBaseAddress(Driver::currentProcessId);
    SLog(std::wstring(L"base: "+std::to_wstring(BaseAddr)).c_str());
    if (BaseAddr == 0) {
        return false;
    }
    Protect(Driver::GetBaseAddress);

    SLog(L"reading var");
    int checked = Driver::read<int>(Driver::currentProcessId, (uintptr_t)&icheck, &status);
    SLog(std::wstring(L"readed: " + std::to_wstring(checked)).c_str());
    if (checked != icheck) {
        return false;
    }
    
    return true;
}

DWORD GetProcessIdByName(wchar_t * name) {
    Protect(_ReturnAddress());

    PROCESSENTRY32 entry;
    entry.dwSize = sizeof(PROCESSENTRY32);

    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

    if (Process32First(snapshot, &entry) == TRUE) {
        while (Process32Next(snapshot, &entry) == TRUE) {
            if (_wcsicmp(entry.szExeFile, name) == 0) {
                Unprotect(_ReturnAddress());
                return entry.th32ProcessID;
            }
        }
    }

    CloseHandle(snapshot);
    Unprotect(_ReturnAddress());
    return 0;
}



uintptr_t milliseconds_now() {
    static LARGE_INTEGER s_frequency;
    static BOOL s_use_qpc = QueryPerformanceFrequency(&s_frequency);
    if (s_use_qpc) {
        LARGE_INTEGER now;
        QueryPerformanceCounter(&now);
        return (1000LL * now.QuadPart) / s_frequency.QuadPart;
    }
    else {
        return GetTickCount();
    }
}

struct GColor {
    float r, g, b;
};
struct GlowMode {
    BYTE GeneralGlowMode, BorderGlowMode, BorderSize, TransparentLevel;
};
struct Fade {
    int a, b;
    float c, d, e, f;
};

void ProcessPlayer(Entity* LPlayer, Entity* target, UINT64 entitylist) {
    Protect(_ReturnAddress());
    auto fptr = &Entity::Observing;
    Unprotect((void*)*(uintptr_t*)&fptr);
    intptr_t obser = target->Observing(GamePid, entitylist);
    Protect((void*)*(uintptr_t*)&fptr);
    if (obser == LPlayer->ptr) {
        if (target->getTeamId() != LPlayer->getTeamId() ||
            target->getTeamId() == LPlayer->getTeamId() && count_team_entities_as_spectators == 1) {
            Spectators++;
        }
    }
    if (obser != 0) { // Is an observer... nothing to do
        Unprotect(_ReturnAddress());
        return;
    }
    auto fptrBone = &Entity::getBonePosition;
    Unprotect((void*)*(uintptr_t*)&fptrBone);
    Vector BonePosition = target->getBonePosition(GamePid, 3);
    Protect((void*)*(uintptr_t*)&fptrBone);
    Vector LocalPlayerPosition = LPlayer->getPosition();
    float dist = LocalPlayerPosition.DistTo(BonePosition) / 39.62f;
    if (dist > Max_Cheat_Distance || BonePosition.z > 22000.f) {
        Unprotect(_ReturnAddress());
        return;
    }

    int health = target->getHealth();
    if (health < 0 || health > 100) {
        Unprotect(_ReturnAddress());
        return;
    }

    int entity_team = target->getTeamId();
    if (entity_team < 0 || entity_team>31) {
        Unprotect(_ReturnAddress());
        return;
    }

    if (enable_glow_hack == 1) {
        if ((int)target->buffer[GLOW_CONTEXT] != 1 || (int)target->buffer[GLOW_VISIBLE_TYPE] != 1 || (int)target->buffer[GLOW_FADE] != 872415232) {
            float currentEntityTime = 5000.f;//(float)target->buffer[0xEE4];
            if (!isnan(currentEntityTime) && currentEntityTime > 0.f) {
                GlowMode mode = { 101,102,96,75 };
                GColor color;
                if (target->getTeamId() == LPlayer->getTeamId()) {
                    color = { 0.f, 2.f, 3.f };
                }
                else if (target->isBleedOut() || !target->isOkLifeState()) {
                    color = { 3.f, 3.f, 3.f };
                }
                else {
                    color = { 3.f, 0.f, 0.f };
                }
                //printf("Changed: %p\n", target->ptr);
                Driver::write<GlowMode>(GamePid, target->ptr + GLOW_TYPE, mode);
                Driver::write<GColor>(GamePid, target->ptr + GLOW_COLOR, color);

                Driver::write<float>(GamePid, target->ptr + GLOW_DISTANCE, 40000.f);
                Driver::write<float>(GamePid, target->ptr + GLOW_LIFE_TIME, currentEntityTime);
                currentEntityTime -= 1.f;
                Driver::write<int>(GamePid, target->ptr + GLOW_CONTEXT, 1);
                Driver::write<int>(GamePid, target->ptr + GLOW_VISIBLE_TYPE, 1);
                Driver::write<Fade>(GamePid, target->ptr + GLOW_FADE, { 872415232, 872415232, currentEntityTime, currentEntityTime, currentEntityTime, currentEntityTime });

            }
        }
    }



    if (enable_aimbot == 1){

        if (target->isBleedOut() || !target->isOkLifeState()) {
            Unprotect(_ReturnAddress());
            return;
        }

        if (entity_team == LPlayer->getTeamId()) {
            Unprotect(_ReturnAddress());
            return;
        }

        Vector BreathAngles = LPlayer->GetBreathAngles();
        Vector LocalCamera = LPlayer->GetCamPos();
        Vector Angle = Math::CalcAngle(LocalCamera, BonePosition);
        float fov = (float)Math::GetFov(BreathAngles, Angle, dist);
        if (fov < current_fov_limiter) {
            AimTarget = target->ptr;
            current_fov_limiter = fov;
        }
    }
    Unprotect(_ReturnAddress());
}

void UpdatePlayersInfo(Entity * LocalPlayer) {
    Protect(_ReturnAddress());

    current_fov_limiter = 999.f;
    AimTarget = 0;
    Spectators = 0;

    for (int i = 0; i <= 70; i++) {
        uintptr_t centity = Driver::read<uintptr_t>(GamePid, entitylist + ((uintptr_t)i << 5));
        if (centity == 0) continue;
        if (LocalPlayer->ptr == centity) continue;

        Unprotect(getEntity);
        Entity* Target = getEntity(GamePid, centity);
        Protect(getEntity);

        auto fptr = &Entity::isPlayer;
        Unprotect((void*)*(uintptr_t*)&fptr);
        if (!Target->isPlayer()) {
            Protect((void*)*(uintptr_t*)&fptr);
            delete Target;
            continue;
        }
        Protect((void*)*(uintptr_t*)&fptr);

        Unprotect(ProcessPlayer);
        ProcessPlayer(LocalPlayer, Target, entitylist);
        Protect(ProcessPlayer);
        delete Target;
    }

    Unprotect(_ReturnAddress());
}

void PredictPosition(Entity* LocalPlayer, Entity* target, Vector* BonePosition) {
    Protect(_ReturnAddress());
    uintptr_t current_weapon = LocalPlayer->CurrentWeapon(GamePid, entitylist);
    if (current_weapon != 0) { //if weapon found apply gravity & speed calculation
        float bulletSpeed = Driver::read<float>(GamePid, current_weapon + TOFFSET(OFFSET_BULLET_SPEED));
        float bulletGravity = Driver::read<float>(GamePid, current_weapon + TOFFSET(OFFSET_BULLET_GRAVITY));

        if (bulletSpeed > 1.0f) { //fix for charge rifle
            Vector muzzle = LocalPlayer->GetCamPos();
            float Time = BonePosition->DistTo(muzzle) / bulletSpeed;
            BonePosition->z += (700.f * bulletGravity * 0.5f) * (Time * Time);
            Vector velocity_delta = (target->GetVelocity() * Time);
            BonePosition->x += velocity_delta.x;
            BonePosition->y += velocity_delta.y;
            BonePosition->z += velocity_delta.z;
        }
    }
    Unprotect(_ReturnAddress());
}

uintptr_t nextBoneSwitch = 0;
uintptr_t StartTimeToAim = 0;
int CurrentTargetBone = 3;
int targets[] = { 7,5,3,2 };
int action = 1;
int boneIndex = 0;
Vector lastSet;
bool TargetLocked = false;

void AutoBoneSwitch() {
    Protect(_ReturnAddress());
    Unprotect(milliseconds_now);
    if (nextBoneSwitch < milliseconds_now()) {
        boneIndex += action;
        if (boneIndex == 3) {
            action = -1;
        }
        else if (boneIndex == 0) {
            action = 1;
        }
        CurrentTargetBone = targets[boneIndex];
        nextBoneSwitch = milliseconds_now() + 300;
    }
    Protect(milliseconds_now);
    Unprotect(_ReturnAddress());
}

void SmoothType_Asist(float fov, float TargetDistance, Vector* Delta, float smooth_multiplier) {
    Protect(_ReturnAddress());
    float smooth = 0.f;
    if (TargetDistance < 10.f) {
        smooth = 6.f + (smooth_multiplier - 1.f) * 3.f;
    }
    else {
        smooth = 6.f + (2.f + (smooth_multiplier - 1.f)) * fov;
    }
    if (smooth > 0.1f) {
        Delta->x /= smooth;
        Delta->y /= smooth;
        Delta->z /= smooth;
    }
    Unprotect(_ReturnAddress());
}

void SmoothType_TargetLock(float fov, float TargetDistance, Vector* Delta, float smooth_multiplier) {
    Protect(_ReturnAddress());
    if (!TargetLocked) {
        Unprotect(milliseconds_now);
        uintptr_t transcurrido = milliseconds_now() - StartTimeToAim;
        Protect(milliseconds_now);
        int max_time = (int)smooth_multiplier * 200;
        if (max_time > 1000) {
            max_time = 1000;
        }
        int restante = (int)(max_time - transcurrido);
        if (restante > 13) {
            float smooth = restante / 15.f;
            if (smooth > 1.f) {
                Delta->x /= smooth;
                Delta->y /= smooth;
                Delta->z /= smooth;
            }
        }
        else { //time passed
            TargetLocked = true;
        }
    }
    Unprotect(_ReturnAddress());
}

int AimAngles(Entity* LocalPlayer, Entity* target, Vector * out) {
    Protect(_ReturnAddress());
    Vector LocalCamera = LocalPlayer->GetCamPos();
    auto fptr = &Entity::getBonePosition;
    Unprotect((void*)*(uintptr_t*)&fptr);
    Vector BonePosition = target->getBonePosition(GamePid, CurrentTargetBone);
    Protect((void*)*(uintptr_t*)&fptr);
    Vector EntityPosition = target->getPosition();
    if (BonePosition.x == 0 || BonePosition.y == 0 || //check wrong player position and bone position
        LocalCamera.x == 0 || LocalCamera.y == 0 || //check wrong camera
        (BonePosition.x == EntityPosition.x && BonePosition.y == EntityPosition.y) //checks wrong bone position
        ) {
        Unprotect(_ReturnAddress());
        return 0;
    }
    Unprotect(PredictPosition);
    PredictPosition(LocalPlayer, target, &BonePosition);
    Protect(PredictPosition);

    Vector CalculatedAngles = Math::CalcAngle(LocalCamera, BonePosition);
    Vector ViewAngles = LocalPlayer->GetViewAngles();
    Vector DynBreath = LocalPlayer->GetBreathAngles();

    if (DynBreath.x == 0 || DynBreath.y == 0 || //Something was wrong
        ViewAngles.x == 0 || ViewAngles.y == 0) {
        Unprotect(_ReturnAddress());
        return 0;
    }
    Math::NormalizeAngles(DynBreath);

    Vector LocalPlayerPosition = LocalPlayer->getPosition();
    float TargetDistance = LocalPlayerPosition.DistTo(EntityPosition) / 39.62f;

    double fov = Math::GetFov(DynBreath, CalculatedAngles, TargetDistance); //fov based in distance to the target and angles (like create an sphere around the target, fov is the radius
    if (fov > 6.f || TargetDistance > Max_Cheat_Distance) {
        Unprotect(_ReturnAddress());
        return 0;
    }

    Vector Delta = CalculatedAngles - DynBreath;
    Math::NormalizeAngles(Delta);

    Unprotect(AutoBoneSwitch);
    AutoBoneSwitch();
    Protect(AutoBoneSwitch);

    Vector RecoilVec = LocalPlayer->GetRecoil();
    if (RecoilVec.x != 0 || RecoilVec.y != 0) {
        Delta -= (RecoilVec * 0.05f); //only a little as we are already fixing the recoil with breath angles
        Math::NormalizeAngles(Delta);
    }

    float fov2 = (float)Math::GetFov2(DynBreath, CalculatedAngles);
    if ((!(enable_aimbot_lock_mode==1)) || Spectators > 0 && disable_aimbot_lock_mode_with_spectators == 1) {
        Unprotect(SmoothType_Asist);
        SmoothType_Asist(fov2, TargetDistance , &Delta, SMOOTH);
        Protect(SmoothType_Asist);
    }
    else {
        Unprotect(SmoothType_TargetLock);
        SmoothType_TargetLock(fov2, TargetDistance, &Delta, SMOOTH);
        Protect(SmoothType_TargetLock);
    }

    Math::NormalizeAngles(Delta);


    Vector SmoothedAngles = ViewAngles + Delta;
    Math::NormalizeAngles(SmoothedAngles);
    if (lastSet == SmoothedAngles) {
        Unprotect(_ReturnAddress());
        return 2;
    }
    out->x = SmoothedAngles.x;
    out->y = SmoothedAngles.y;
    out->z = SmoothedAngles.z;
    Unprotect(_ReturnAddress());
    return 1;
}

void CheatLoop() {
    Protect(_ReturnAddress());
    entitylist = GameBaseAddress + TOFFSET(OFFSET_ENTITYLIST);
    uintptr_t lastAimTarget = 0;
    
    while (true) {
        
        uintptr_t lptr = Driver::read<uintptr_t>(GamePid, GameBaseAddress + TOFFSET(OFFSET_LOCAL_ENT));
        if (lptr == 0) break;
        
        Unprotect(getEntity);
        Entity* LocalPlayer = getEntity(GamePid, lptr);
        Protect(getEntity);
        
        
        //(char*)(LocalPlayer->buffer + OFFSET_NAME)

        auto fptr = &Entity::isPlayer;
        Unprotect((void*)*(uintptr_t*)&fptr);
        if (!LocalPlayer->isPlayer()) {
            Protect((void*)*(uintptr_t*)&fptr);
            delete LocalPlayer;
            break;
        }
        Protect((void*)*(uintptr_t*)&fptr);

        Unprotect(milliseconds_now);
        if (nextEntityInfoUpdate < milliseconds_now()) {
            Protect(milliseconds_now);
            
            Unprotect(UpdatePlayersInfo);
            UpdatePlayersInfo(LocalPlayer);
            Protect(UpdatePlayersInfo);

            if (Spectators > 0 && printableOut) {
                char sp_str[] = { 'S','p','e','c','t','a','t','o','r','s',':',' ','%','l','l','u','\0' };
                printf(sp_str, Spectators);
                memset(sp_str, 0, sizeof(sp_str));
            }
            
            Unprotect(milliseconds_now);
            nextEntityInfoUpdate = milliseconds_now() + 200; //update info every 200ms
            Protect(milliseconds_now);
        }

        

        if (enable_aimbot == 1) {
            Unprotect(milliseconds_now);
            bool key_pressed = (GetKeyState(VK_RBUTTON) & 0x8000);
            if (AimTarget > 0 && key_pressed && nextAim < milliseconds_now() && (Spectators > 0 && !(disable_aimbot_with_spectators==1) || Spectators == 0)) {
                Protect(milliseconds_now);

                if (lastAimTarget != AimTarget) {
                    TargetLocked = false;
                    Unprotect(milliseconds_now);
                    StartTimeToAim = milliseconds_now();
                    Protect(milliseconds_now);
                    lastAimTarget = AimTarget;
                }
                Unprotect(getEntity);
                Entity* target = getEntity(GamePid, AimTarget);
                Protect(getEntity);

                Vector result = { 0.f,0.f,0.f };

                Unprotect(AimAngles);
                int status = AimAngles(LocalPlayer, target, &result);
                Protect(AimAngles);
                if (status == 1) { // 1 = movement needed, 2 = view already there, 0 = some out of aimbot params
                    LocalPlayer->SetViewAngles(GamePid, result);
                }
                else if (status == 0) {
                    TargetLocked = false;
                    Unprotect(milliseconds_now);
                    StartTimeToAim = milliseconds_now();
                    Protect(milliseconds_now);
                }

                delete target;
                Unprotect(milliseconds_now);
                nextAim = milliseconds_now() + 16; //60 movements per second
                Protect(milliseconds_now);
            }
            else if (!key_pressed || AimTarget == 0) {

                TargetLocked = false;
                Unprotect(milliseconds_now);
                StartTimeToAim = milliseconds_now();
                Protect(milliseconds_now);

                ProtectedSleep(2);
            }
        }
        else {
            ProtectedSleep(100);
        }
        Protect(milliseconds_now);
        
        delete LocalPlayer;
    }
    Unprotect(_ReturnAddress());
}

void Configure() {

    HWND consoleWnd = GetConsoleWindow();
    if (consoleWnd == NULL)
    {
        AllocConsole();
        freopen("CONIN$", "r", stdin);
        freopen("CONOUT$", "w", stdout);
        freopen("CONOUT$", "w", stderr);
    }
    else {
        printableOut = true;
    }

    char hi_str[] = { 'H','i',',',' ','W','e','l','c','o','m','e',' ','t','o',' ','C','R','Z',' ','E','F','I',' ','C','h','e','a','t','\n','A','n','s','w','e','r',' ','a','l','l',' ','t','h','e',' ','q','u','e','s','t','i','o','n','s',' ','w','i','t','h',' ','1',' ','o','r',' ','0',' ','f','o','r',' ','t','r','u','e','/','f','a','l','s','e','\n','\0' };
    std::cout << hi_str;
    memset(hi_str, 0, sizeof(hi_str));
    char hi2_str[] = { 'T','h','i','s',' ','c','h','e','a','t',' ','i','s',' ','a','b','s','o','l','u','t','e','l','y',' ','f','r','e','e',' ','a','t',' ','U','n','k','n','o','w','n','C','h','e','a','t','s','\n','\0' };
    std::cout << hi2_str;
    memset(hi2_str, 0, sizeof(hi2_str));
    char aimbot_str[] = { 'D','o',' ','y','o','u',' ','w','a','n','t',' ','t','o',' ','e','n','a','b','l','e',' ','a','i','m','b','o','t','?',':',' ','\0' };
    std::cout << aimbot_str;
    memset(aimbot_str, 0, sizeof(aimbot_str));
    std::cin >> enable_aimbot;
    std::cin.ignore();
    std::cin.clear();
    if (enable_aimbot != 0) {
        char aimbot_lock_str[] = { 'D','o',' ','y','o','u',' ','w','a','n','t',' ','t','o',' ','e','n','a','b','l','e',' ','a','i','m','b','o','t',' ','l','o','c','k',' ','m','o','d','e','?',':',' ','\0' };
        std::cout << aimbot_lock_str;
        memset(aimbot_lock_str, 0, sizeof(aimbot_lock_str));
        std::cin >> enable_aimbot_lock_mode;
        std::cin.ignore();
        std::cin.clear();
        char disable_aimbot_str[] = { 'D','i','s','a','b','l','e',' ','a','i','m','b','o','t',' ','w','i','t','h',' ','s','p','e','c','t','a','t','o','r','s','?',':',' ','\0' };
        std::cout << disable_aimbot_str;
        memset(disable_aimbot_str, 0, sizeof(disable_aimbot_str));
        std::cin >> disable_aimbot_with_spectators;
        std::cin.ignore();
        std::cin.clear();
        if (disable_aimbot_with_spectators == 0 && enable_aimbot_lock_mode == 1) {
            char aimbot_disable_lock_str[] = { 'D','o',' ','y','o','u',' ','w','a','n','t',' ','t','o',' ','d','i','s','a','b','l','e',' ','a','i','m','b','o','t',' ','l','o','c','k',' ','m','o','d','e',' ','w','i','t','h',' ','s','p','e','c','t','a','t','o','r','s','?',':',' ','\0' };
            std::cout << aimbot_disable_lock_str;
            memset(aimbot_disable_lock_str, 0, sizeof(aimbot_disable_lock_str));
            std::cin >> disable_aimbot_lock_mode_with_spectators;
            std::cin.ignore();
            std::cin.clear();
        }
        else {
            disable_aimbot_lock_mode_with_spectators = 1;
        }
        char team_player_as_spectators_str[] = { 'C','o','u','n','t',' ','t','e','a','m',' ','p','l','a','y','e','r','s',' ','a','s',' ','s','p','e','c','t','a','t','o','r','s','?',':',' ','\0' };
        std::cout << team_player_as_spectators_str;
        memset(team_player_as_spectators_str, 0, sizeof(team_player_as_spectators_str));
        std::cin >> count_team_entities_as_spectators;
        std::cin.ignore();
        std::cin.clear();
    }
    char enable_glow_str[] = { 'D','o',' ','y','o','u',' ','w','a','n','t',' ','t','o',' ','e','n','a','b','l','e',' ','g','l','o','w',' ','h','a','c','k','?',':',' ','\0' };
    std::cout << enable_glow_str;
    memset(enable_glow_str, 0, sizeof(enable_glow_str));
    std::cin >> enable_glow_hack;
    std::cin.ignore();
    std::cin.clear();
    std::cout << "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n";
    system("cls");
   
    if (consoleWnd == NULL) {
        fclose(stdin);
        fclose(stdout);
        fclose(stderr);
        FreeConsole();
    }

}

DWORD WINAPI mainThread(PVOID) {
    SLog(L"Protecting");
    LoadProtectedFunctions();
    Protect(LoadProtectedFunctions);
    SLog(L"Connecting driver");
    Unprotect(Driver::initialize);
    Unprotect(CheckDriverStatus);
    if (!Driver::initialize() || !CheckDriverStatus()) {
        wchar_t VarName[] = { 'F','a','s','t','B','o','o','t','O','p','t','i','o','n','\0' };
        UNICODE_STRING FVariableName = UNICODE_STRING();
        FVariableName.Buffer = VarName;
        FVariableName.Length = 28;
        FVariableName.MaximumLength = 30;
        //UNICODE_STRING VariableName = RTL_CONSTANT_STRING(VARIABLE_NAME);
        myNtSetSystemEnvironmentValueEx(
            &FVariableName,
            &DummyGuid,
            0,
            0,
            ATTRIBUTES);//delete var
        memset(VarName, 0, sizeof(VarName));
        //memset(VariableName.Buffer, 0, VariableName.Length);
        //VariableName.Length = 0;
        Beep(600, 1000);
        char tx[] = { 'N','O',' ','E','F','I',' ',';','(','\n', 0 };
        printf(tx);
        ProtectedSleep(3000);
        exit(1);
        return 1;
    }
    Protect(Driver::initialize);
    Protect(CheckDriverStatus);

    Beep(900, 200);
    Beep(1100, 200);
    Beep(1300, 200);
    Beep(1500, 300);
    Beep(1700, 400);
    Beep(1900, 500);

    Unprotect(Configure);
    Configure();
    Protect(Configure);

    while (true) {
        wchar_t name[] = { 'r', '5', 'a', 'p', 'e', 'x', '.', 'e', 'x', 'e', 0 };
        //wchar_t name[] = { 'E', 'a', 's', 'y', 'A', 'n', 't', 'i', 'C', 'h', 'e', 'a', 't', '_', 'l', 'a', 'u', 'n', 'c', 'h', 'e', 'r', '.', 'e', 'x', 'e', 0 };
        Unprotect(GetProcessIdByName);
        DWORD pid = GetProcessIdByName(name);
        Protect(GetProcessIdByName);
        memset(name, 0, sizeof(name));

        Unprotect(Driver::GetBaseAddress);
        uintptr_t BaseAddr = Driver::GetBaseAddress(pid);
        Protect(Driver::GetBaseAddress);
       
        if (BaseAddr != 0) {
            GamePid = pid;
            GameBaseAddress = BaseAddr;
            
            Unprotect(CheatLoop);
            CheatLoop();
            Protect(CheatLoop);

            GamePid = 0;
            GameBaseAddress = 0;
        }
        ProtectedSleep(2000);
    }

    return 0;
}

BOOL APIENTRY DllMain(HMODULE, DWORD ul_reason_for_call, LPVOID) {
    if (ul_reason_for_call == DLL_PROCESS_ATTACH) {
        SLog(L"Attach");
        HANDLE thread = CreateThread(NULL, NULL, mainThread, NULL, NULL, NULL);
        if (thread) 
            CloseHandle(thread);
    }
    return TRUE;
}


```

`CRZAimbot/Main.h`:

```h
#pragma once
#include <Windows.h>
#include <stdio.h>
#include <iostream>
#include <tlhelp32.h>
#include "MemProtector.h"
#include "Config.h"
#include "Driver.h"
#include "Entity.h"
#include "Math.h"


void LoadProtectedFunctions();
DWORD WINAPI mainThread(PVOID);
BOOL APIENTRY DllMain(HMODULE, DWORD ul_reason_for_call, LPVOID);
bool CheckDriverStatus();
DWORD GetProcessIdByName(wchar_t* name);
uintptr_t milliseconds_now();
void ProcessPlayer(Entity* LPlayer, Entity* target, UINT64 entitylist);
void UpdatePlayersInfo(Entity* LocalPlayer);
void PredictPosition(Entity* LocalPlayer, Entity* target, Vector* BonePosition);
void AutoBoneSwitch();
void SmoothType_Asist(float fov, float TargetDistance, Vector* Delta, float smooth_multiplier);
void SmoothType_TargetLock(float fov, float TargetDistance, Vector* Delta, float smooth_multiplier);
int AimAngles(Entity* LocalPlayer, Entity* target, Vector* out);
void CheatLoop();
void Configure();
```

`CRZAimbot/Math.cpp`:

```cpp
#include "Math.h"

void Math::NormalizeAngles(Vector& angle)
{
	while (angle.x > 89.0f)
		angle.x -= 180.f;

	while (angle.x < -89.0f)
		angle.x += 180.f;

	while (angle.y > 180.f)
		angle.y -= 360.f;

	while (angle.y < -180.f)
		angle.y += 360.f;
}

Vector Math::CalcAngle(const Vector& src, const Vector& dst)
{
	Vector angle = Vector();
	Vector delta = Vector((src.x - dst.x), (src.y - dst.y), (src.z - dst.z));

	float hyp = sqrt(delta.x * delta.x + delta.y * delta.y);

	angle.x = atan(delta.z / hyp) * (float)(180.0 / M_PI);
	angle.y = atan(delta.y / delta.x) * (float)(180.0 / M_PI);
	angle.z = 0;
	if (delta.x >= 0.0) angle.y += 180.0f;

	return angle;
}
#define DegToRad(val1) ((val1 * M_PI) / 180)
double Math::GetFov(const Vector& viewAngle, const Vector& aimAngle, float distance) {
	Vector delta = aimAngle - viewAngle;
	NormalizeAngles(delta);
	float pitch = (float)sin(DegToRad(delta.x)) * distance;
	float yaw = (float)sin(DegToRad(delta.y)) * distance;

	return sqrt(powf(pitch, 2.0) + powf(yaw, 2.0));
}
double Math::GetFov2(const Vector& viewAngle, const Vector& aimAngle)
{
	Vector delta = aimAngle - viewAngle;
	NormalizeAngles(delta);

	return sqrt(pow(delta.x, 2.0f) + pow(delta.y, 2.0f));
}

```

`CRZAimbot/Math.h`:

```h
#pragma once
#include <math.h>
#include "vector.h"


namespace Math {
	void NormalizeAngles(Vector& angle);
	double GetFov(const Vector& viewAngle, const Vector& aimAngle, float distance);
	double GetFov2(const Vector& viewAngle, const Vector& aimAngle);
	Vector CalcAngle(const Vector& src, const Vector& dst);
}
```

`CRZAimbot/MemProtector.cpp`:

```cpp
#include "MemProtector.h"

//we will never go further than this buffer
//#pragma warning( disable : 6386 )
//#pragma warning( disable : 6385 )

int funcCount = 0;
ProtectedFunction functions[50];

void unsafe_unprotect(int index) {
	XOR((BYTE*)functions[index].address, functions[index].size, functions[index].lastXor);
}

void nextLastXor(int index) {
	BYTE xorByte = functions[index].lastXor;
	if (xorByte > 0xf3) {
		xorByte = 0x5;
	}
	xorByte += 0x01;
	functions[index].lastXor = xorByte;
}

void unsafe_protect(int index) {
	nextLastXor(index);
	unsafe_unprotect(index);
}

int GetFunctionIndex(void* FunctionAddress) {
	for (int i = 0; i < funcCount; i++) {
		if ((uintptr_t)functions[i].address <= (uintptr_t)FunctionAddress &&
			(uintptr_t)functions[i].address + functions[i].size >= (uintptr_t)FunctionAddress) {
			return i;
		}
	}
	return -1;
}

void Unprotect(void* FunctionAddress) {
	int function = GetFunctionIndex(FunctionAddress);
	//
	//if (function <= -1) {
	//	MessageBox(NULL, L"UNKNOWN FUNC!", L"SUPER DEBUG", 0);
	//}
	//
	if (function > -1 && functions[function].crypted == true) {
		unsafe_unprotect(function);
		functions[function].crypted = false;
	}
}

void Protect(void* FunctionAddress) {
	int function = GetFunctionIndex(FunctionAddress);
	if (function > -1 && functions[function].crypted == false) {
		unsafe_protect(function);
		functions[function].crypted = true;
	}
}

void ProtectedSleep(int ms) {
	Protect(_ReturnAddress());
	Sleep(ms);
	Unprotect(_ReturnAddress());
}


void addFunc(ProtectedFunction func) {
	functions[funcCount] = func;
	funcCount++;
}

void XOR(BYTE* data, size_t size, BYTE XOR_KEY) {
	for (size_t i = 0; i < size; i++) {
		data[i] = data[i] ^ XOR_KEY;
	}
}
```

`CRZAimbot/MemProtector.h`:

```h
#pragma once

#include <Windows.h>
#include <intrin.h>
#include "Config.h"
#pragma intrinsic(_ReturnAddress)

#define SLog(text) //MessageBox(NULL, text, L"SUPER DEBUG", 0);

struct ProtectedFunction {
	void* address;
	size_t size;
	BYTE lastXor;
	bool crypted;
};
extern int funcCount;
extern ProtectedFunction functions[50];
void addFunc(ProtectedFunction func);
void unsafe_unprotect(int index);
void unsafe_protect(int index);
int GetFunctionIndex(void* FunctionAddress);
void Unprotect(void* FunctionAddress);
void Protect(void* FunctionAddress);
void XOR(BYTE* data, size_t size, BYTE XOR_KEY = STRING_XOR_KEY);
void ProtectedSleep(int ms);
```

`CRZAimbot/Offsets.h`:

```h
#pragma once

//#define OFFSET_RAN 0//0x34LLU
#define TOFFSET(d1) d1 //((d1)+offset_ran_var)

extern unsigned long long offset_ran_var;

#define ENTITY_SIZE_DEF				0x42E0			//biggest entity offset

#define OFFSET_ENTITYLIST			0x18ad3a8		//cl_entitylist
#define OFFSET_LOCAL_ENT			0x1c5bcc8		//LocalPlayer


#define OFFSET_TEAM					0x0430			//m_iTeamNum
#define OFFSET_HEALTH				0x0420			//m_iHealth
#define OFFSET_NAME					0x0561			//m_iName
#define OFFSET_SIG_NAME				0x0558			//m_iSignifierName
#define OFFSET_SHIELD				0x170			//m_shieldHealth
#define OFFSET_MAX_SHIELD			0x174			//m_shieldHealth +0x4

#define OFFSET_LIFE_STATE			0x0770			//m_lifeState
#define OFFSET_BLEED_OUT_STATE		0x2610			//m_bleedoutState

#define OFFSET_ITEM_ID				0x1608			//m_customScriptInt

#define OFFSET_BULLET_SPEED			0x1e0c			//m_flProjectileSpeed
#define OFFSET_BULLET_GRAVITY		0x1e14			//m_flProjectileScale

#define OFFSET_CURRENT_WEAPON		0x1a0c			//m_latestPrimaryWeapons
#define OFFSET_ORIGIN				0x14C			//m_vecAbsOrigin
#define OFFSET_BONES				0xF18			//m_nForceBone + 0x50-0x8 -> 48 8B 97 ?? ?? ?? ?? 48 8D 04 5B 48 C1
#define OFFSET_AIMPUNCH				0x23c8			//m_vecPunchWeapon_Angle
#define OFFSET_CAMERAPOS			0x1E6C			//40 57 48 83 EC 20 F3 0F 10 0A 48 8B F9 0F 2E 89 first ucomiss result
#define OFFSET_VIEWANGLES			0x24A0			//m_ammoPoolCapacity - 0x14  -> 0F 57 C0 8B 86 ?? ?? ?? ?? F3 segundo uso de un 0x24AX
#define OFFSET_BREATH_ANGLES		(OFFSET_VIEWANGLES - 0x10)
#define OFFSET_OBSERVER_MODE		0x32bc			//m_iObserverMode
#define OFFSET_OBSERVING_TARGET		0x32c0			//m_hObserverTarget

#define OFFSET_HELMET_TYPE			0x42cc			//m_helmetType

#define GLOW_CONTEXT 0x350 //Script_Highlight_SetCurrentContext
#define GLOW_LIFE_TIME 0x32C //Script_Highlight_SetLifeTime + 4
#define GLOW_DISTANCE 0x33C //Script_Highlight_SetFarFadeDist
#define GLOW_TYPE 0x2AC //Script_Highlight_GetState + 4
#define GLOW_COLOR 0x1D0 //Script_CopyHighlightState mov tcx nº7 
#define GLOW_VISIBLE_TYPE 0x360 //Script_Highlight_SetVisibilityType
#define GLOW_FADE 0x310 //Script_Highlight_GetCurrentInsideOpacity 3º result of 3 offsets consecutive or first + 8~



#define OFFSET_MATRIX				0x1b3bd0		//ViewMatrix
#define OFFSET_RENDER				0x40d5d98 	 	//ViewRender 
```

`CRZAimbot/Vector.h`:

```h
#pragma once
#include <stdlib.h>
#include <cmath>

#define CHECK_VALID( _v ) 0
#define Assert( _exp ) ((void)0)

#define FastSqrt(x)			(sqrt)(x)

#define M_PI		3.14159265358979323846	// matches value in gcc v2 math.h

#define M_PI_F		((float)(M_PI))	// Shouldn't collide with anything.

#define M_PHI		1.61803398874989484820 // golden ratio

// NJS: Inlined to prevent floats from being autopromoted to doubles, as with the old system.
#ifndef RAD2DEG
#define RAD2DEG( x  )  ( (float)(x) * (float)(180.f / M_PI_F) )
#endif

#ifndef DEG2RAD
#define DEG2RAD( x  )  ( (float)(x) * (float)(M_PI_F / 180.f) )
#endif


class Vector
{
public:
	float x, y, z;
	Vector(void);
	Vector(float X, float Y, float Z);
	void Init(float ix = 0.0f, float iy = 0.0f, float iz = 0.0f);
	bool IsValid() const;
	float operator[](int i) const;
	float& operator[](int i);
	inline void Zero();
	bool operator==(const Vector& v) const;
	bool operator!=(const Vector& v) const;
	inline Vector& operator+=(const Vector& v);
	inline Vector& operator-=(const Vector& v);
	inline Vector& operator*=(const Vector& v);
	inline Vector& operator*=(float s);
	inline Vector& operator/=(const Vector& v);
	inline Vector& operator/=(float s);
	inline Vector& operator+=(float fl);
	inline Vector& operator-=(float fl);
	inline float Length() const;
	inline float LengthSqr(void) const
	{
		CHECK_VALID(*this);
		return (x * x + y * y + z * z);
	}
	bool IsZero(float tolerance = 0.01f) const
	{
		return (x > -tolerance && x < tolerance&&
			y > -tolerance && y < tolerance&&
			z > -tolerance && z < tolerance);
	}
	Vector	Normalize();
	float	NormalizeInPlace();
	inline float	DistTo(const Vector& vOther) const;
	inline float	DistToSqr(const Vector& vOther) const;
	float	Dot(const Vector& vOther) const;
	float	Length2D(void) const;
	float	Length2DSqr(void) const;
	Vector& operator=(const Vector& vOther);
	Vector	operator-(const Vector& v) const;
	Vector	operator+(const Vector& v) const;
	Vector	operator*(const Vector& v) const;
	Vector	operator/(const Vector& v) const;
	Vector	operator*(float fl) const;
	Vector	operator/(float fl) const;
	// Base address...
	float* Base();
	float const* Base() const;
};

//===============================================
inline void Vector::Init(float ix, float iy, float iz)
{
	x = ix; y = iy; z = iz;
	CHECK_VALID(*this);
}
//===============================================
inline Vector::Vector(float X, float Y, float Z)
{
	x = X; y = Y; z = Z;
	CHECK_VALID(*this);
}
//===============================================
inline Vector::Vector(void) { Zero(); }
//===============================================
inline void Vector::Zero()
{
	x = y = z = 0.0f;
}
//===============================================
inline void VectorClear(Vector& a)
{
	a.x = a.y = a.z = 0.0f;
}
//===============================================
inline Vector& Vector::operator=(const Vector& vOther)
{
	CHECK_VALID(vOther);
	x = vOther.x; y = vOther.y; z = vOther.z;
	return *this;
}
//===============================================
inline float& Vector::operator[](int i)
{
	Assert((i >= 0) && (i < 3));
	return ((float*)this)[i];
}
//===============================================
inline float Vector::operator[](int i) const
{
	Assert((i >= 0) && (i < 3));
	return ((float*)this)[i];
}
//===============================================
inline bool Vector::operator==(const Vector& src) const
{
	CHECK_VALID(src);
	CHECK_VALID(*this);
	return (src.x == x) && (src.y == y) && (src.z == z);
}
//===============================================
inline bool Vector::operator!=(const Vector& src) const
{
	CHECK_VALID(src);
	CHECK_VALID(*this);
	return (src.x != x) || (src.y != y) || (src.z != z);
}
//===============================================
inline void VectorCopy(const Vector& src, Vector& dst)
{
	CHECK_VALID(src);
	dst.x = src.x;
	dst.y = src.y;
	dst.z = src.z;
}
//===============================================
inline  Vector& Vector::operator+=(const Vector& v)
{
	CHECK_VALID(*this);
	CHECK_VALID(v);
	x += v.x; y += v.y; z += v.z;
	return *this;
}
//===============================================
inline  Vector& Vector::operator-=(const Vector& v)
{
	CHECK_VALID(*this);
	CHECK_VALID(v);
	x -= v.x; y -= v.y; z -= v.z;
	return *this;
}
//===============================================
inline  Vector& Vector::operator*=(float fl)
{
	x *= fl;
	y *= fl;
	z *= fl;
	CHECK_VALID(*this);
	return *this;
}
//===============================================
inline  Vector& Vector::operator*=(const Vector& v)
{
	CHECK_VALID(v);
	x *= v.x;
	y *= v.y;
	z *= v.z;
	CHECK_VALID(*this);
	return *this;
}
//===============================================
inline Vector& Vector::operator+=(float fl)
{
	x += fl;
	y += fl;
	z += fl;
	CHECK_VALID(*this);
	return *this;
}
//===============================================
inline Vector& Vector::operator-=(float fl)
{
	x -= fl;
	y -= fl;
	z -= fl;
	CHECK_VALID(*this);
	return *this;
}
//===============================================
inline  Vector& Vector::operator/=(float fl)
{
	Assert(fl != 0.0f);
	float oofl = 1.0f / fl;
	x *= oofl;
	y *= oofl;
	z *= oofl;
	CHECK_VALID(*this);
	return *this;
}
//===============================================
inline  Vector& Vector::operator/=(const Vector& v)
{
	CHECK_VALID(v);
	Assert(v.x != 0.0f && v.y != 0.0f && v.z != 0.0f);
	x /= v.x;
	y /= v.y;
	z /= v.z;
	CHECK_VALID(*this);
	return *this;
}
//===============================================
inline float Vector::Length(void) const
{
	CHECK_VALID(*this);

	float root = 0.0f;

	float sqsr = x * x + y * y + z * z;

	root = sqrt(sqsr);

	return root;
}
//===============================================
inline float Vector::Length2D(void) const
{
	CHECK_VALID(*this);

	float root = 0.0f;

	float sqst = x * x + y * y;

	root = sqrt(sqst);

	return root;
}
//===============================================
inline float Vector::Length2DSqr(void) const
{
	return (x * x + y * y);
}
//===============================================
inline Vector CrossProduct(const Vector& a, const Vector& b)
{
	return Vector(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}
//===============================================
float Vector::DistTo(const Vector& vOther) const
{
	Vector delta;

	delta.x = x - vOther.x;
	delta.y = y - vOther.y;
	delta.z = z - vOther.z;

	return delta.Length();
}
float Vector::DistToSqr(const Vector& vOther) const
{
	Vector delta;

	delta.x = x - vOther.x;
	delta.y = y - vOther.y;
	delta.z = z - vOther.z;

	return delta.LengthSqr();
}
//===============================================
inline Vector Vector::Normalize()
{
	Vector vector;
	float length = this->Length();

	if (length != 0)
	{
		vector.x = x / length;
		vector.y = y / length;
		vector.z = z / length;
	}
	else
	{
		vector.x = vector.y = 0.0f; vector.z = 1.0f;
	}

	return vector;
}
//===============================================
inline float Vector::NormalizeInPlace()
{
	Vector& v = *this;

	float iradius = 1.f / (this->Length() + 1.192092896e-07F); //FLT_EPSILON

	v.x *= iradius;
	v.y *= iradius;
	v.z *= iradius;
}
//===============================================
inline float VectorNormalize(Vector& v)
{
	Assert(v.IsValid());
	float l = v.Length();
	if (l != 0.0f)
	{
		v /= l;
	}
	else
	{
		// FIXME:
		// Just copying the existing implemenation; shouldn't res.z == 0?
		v.x = v.y = 0.0f; v.z = 1.0f;
	}
	return l;
}
//===============================================
inline float VectorNormalize(float* v)
{
	return VectorNormalize(*(reinterpret_cast<Vector*>(v)));
}
//===============================================
inline Vector Vector::operator+(const Vector& v) const
{
	Vector res;
	res.x = x + v.x;
	res.y = y + v.y;
	res.z = z + v.z;
	return res;
}

//===============================================
inline Vector Vector::operator-(const Vector& v) const
{
	Vector res;
	res.x = x - v.x;
	res.y = y - v.y;
	res.z = z - v.z;
	return res;
}
//===============================================
inline Vector Vector::operator*(float fl) const
{
	Vector res;
	res.x = x * fl;
	res.y = y * fl;
	res.z = z * fl;
	return res;
}
//===============================================
inline Vector Vector::operator*(const Vector& v) const
{
	Vector res;
	res.x = x * v.x;
	res.y = y * v.y;
	res.z = z * v.z;
	return res;
}
//===============================================
inline Vector Vector::operator/(float fl) const
{
	Vector res;
	res.x = x / fl;
	res.y = y / fl;
	res.z = z / fl;
	return res;
}
//===============================================
inline Vector Vector::operator/(const Vector& v) const
{
	Vector res;
	res.x = x / v.x;
	res.y = y / v.y;
	res.z = z / v.z;
	return res;
}
inline float Vector::Dot(const Vector& vOther) const
{
	const Vector& a = *this;

	return(a.x * vOther.x + a.y * vOther.y + a.z * vOther.z);
}

//-----------------------------------------------------------------------------
// length
//-----------------------------------------------------------------------------

inline float VectorLength(const Vector& v)
{
	CHECK_VALID(v);
	return (float)FastSqrt(v.x * v.x + v.y * v.y + v.z * v.z);
}

//VECTOR SUBTRAC
inline void VectorSubtract(const Vector& a, const Vector& b, Vector& c)
{
	CHECK_VALID(a);
	CHECK_VALID(b);
	c.x = a.x - b.x;
	c.y = a.y - b.y;
	c.z = a.z - b.z;
}

//VECTORADD
inline void VectorAdd(const Vector& a, const Vector& b, Vector& c)
{
	CHECK_VALID(a);
	CHECK_VALID(b);
	c.x = a.x + b.x;
	c.y = a.y + b.y;
	c.z = a.z + b.z;
}

//-----------------------------------------------------------------------------
// Base address...
//-----------------------------------------------------------------------------
inline float* Vector::Base()
{
	return (float*)this;
}

inline float const* Vector::Base() const
{
	return (float const*)this;
}

inline void VectorMAInline(const float* start, float scale, const float* direction, float* dest)
{
	dest[0] = start[0] + direction[0] * scale;
	dest[1] = start[1] + direction[1] * scale;
	dest[2] = start[2] + direction[2] * scale;
}

inline void VectorMAInline(const Vector& start, float scale, const Vector& direction, Vector& dest)
{
	dest.x = start.x + direction.x * scale;
	dest.y = start.y + direction.y * scale;
	dest.z = start.z + direction.z * scale;
}

inline void VectorMA(const Vector& start, float scale, const Vector& direction, Vector& dest)
{
	VectorMAInline(start, scale, direction, dest);
}

inline void VectorMA(const float* start, float scale, const float* direction, float* dest)
{
	VectorMAInline(start, scale, direction, dest);
}


inline unsigned long& FloatBits(float& f)
{
	return *reinterpret_cast<unsigned long*>(&f);
}

inline bool IsFinite(float f)
{
	return ((FloatBits(f) & 0x7F800000) != 0x7F800000);
}
```

`CRZEFI/Makefile`:

```
ARCH            = $(shell uname -m | sed s,i[3456789]86,ia32,)

OBJS            = main.o
TARGET          = memory.efi

EFIINC          = /usr/include/efi
EFIINCS         = -I$(EFIINC) -I$(EFIINC)/$(ARCH) -I$(EFIINC)/protocol
LIB32           = /usr/lib32
LIB64           = /usr/lib

CFLAGS          = $(EFIINCS) -fno-stack-protector -fpic \
		  -fshort-wchar -mno-red-zone -Wall

ifeq ($(ARCH),x86_64)
  CFLAGS += -DEFI_FUNCTION_WRAPPER
  LIB           = $(LIB64)
  EFILIB        = $(LIB64)
endif

ifeq ($(ARCH),ia32)
  LIB           = $(LIB32)
  EFILIB        = $(LIB32)
endif

EFI_CRT_OBJS    = $(EFILIB)/crt0-efi-$(ARCH).o
EFI_LDS         = $(EFILIB)/elf_$(ARCH)_efi.lds

LDFLAGS         = -nostdlib -znocombreloc -T $(EFI_LDS) -shared \
		  -Bsymbolic -L $(EFILIB) -L $(LIB) $(EFI_CRT_OBJS) 

all: $(TARGET)

memory.so: $(OBJS)
	ld $(LDFLAGS) $(OBJS) -s -o $@ -lefi -lgnuefi

%.efi: %.so
	objcopy -j .text -j .sdata -j .data -j .dynamic \
		-j .dynsym  -j .rel -j .rela -j .reloc \
		--target=efi-rtdrv-$(ARCH) $^ $@

clean:
	rm -f memory.efi memory.so main.o *~
```

`CRZEFI/definitions.h`:

```h

#ifndef _SUPER_EFI_INCLUDE_
#define _SUPER_EFI_INCLUDE_

#define GNU_EFI_USE_MS_ABI 1

#define MicrosoftCallingType __attribute__((ms_abi))

#include <efi.h>
#include <efilib.h>

// Dummy protocol struct
typedef struct _DummyProtocalData {
    UINTN blank;
} DummyProtocalData;

typedef unsigned long long ptr64;

// Pointers to original functions
extern EFI_GET_TIME oGetTime;
extern EFI_SET_TIME oSetTime;
extern EFI_GET_WAKEUP_TIME oGetWakeupTime;
extern EFI_SET_WAKEUP_TIME oSetWakeupTime;
extern EFI_SET_VIRTUAL_ADDRESS_MAP oSetVirtualAddressMap;
extern EFI_CONVERT_POINTER oConvertPointer;
extern EFI_GET_VARIABLE oGetVariable;
extern EFI_SET_VARIABLE oSetVariable;
extern EFI_GET_NEXT_VARIABLE_NAME oGetNextVariableName;
extern EFI_GET_NEXT_HIGH_MONO_COUNT oGetNextHighMonotonicCount;
extern EFI_RESET_SYSTEM oResetSystem;
extern EFI_UPDATE_CAPSULE oUpdateCapsule;
extern EFI_QUERY_CAPSULE_CAPABILITIES oQueryCapsuleCapabilities;
extern EFI_QUERY_VARIABLE_INFO oQueryVariableInfo;

// Struct containing data used to communicate with the client
typedef struct _MemoryCommand {
    int magic;
    int operation;
    ptr64 data[6];
} MemoryCommand;

// Functions (Windows only)
typedef int (MicrosoftCallingType* PsLookupProcessByProcessId)(
    void* ProcessId,
    void* OutPEProcess
    );
typedef void* (MicrosoftCallingType* PsGetProcessSectionBaseAddress)(
    void* PEProcess
    );
typedef int (MicrosoftCallingType* MmCopyVirtualMemory)(
    void* SourceProcess,
    void* SourceAddress,
    void* TargetProcess,
    void* TargetAddress,
    ptr64 BufferSize,
    char PreviousMode,
    void* ReturnSize
    );

EFI_STATUS RunCommand(MemoryCommand* cmd);
EFI_STATUS EFIAPI mySetVariable(IN CHAR16* VariableName, IN EFI_GUID* VendorGuid, IN UINT32 Attributes, IN UINTN DataSize, IN VOID* Data);
VOID EFIAPI SetVirtualAddressMapEvent(IN EFI_EVENT Event, IN VOID* Context);
VOID EFIAPI ExitBootServicesEvent(IN EFI_EVENT Event, IN VOID* Context);
VOID* SetServicePointer(IN OUT EFI_TABLE_HEADER* ServiceTableHeader, IN OUT VOID** ServiceTableFunction, IN VOID* NewFunction);
EFI_STATUS EFI_FUNCTION efi_unload(IN EFI_HANDLE ImageHandle);
EFI_STATUS efi_main(IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE* SystemTable);


#endif

```

`CRZEFI/dummy.h`:

```h
#include "definitions.h"

#ifndef _DUMMY_EFI_SHIT_
#define _DUMMY_EFI_SHIT_

EFI_STATUS EFIAPI HookedGetTime(EFI_TIME* time, EFI_TIME_CAPABILITIES* capabilities)
{
    return oGetTime(time, capabilities);
}

EFI_STATUS EFIAPI HookedSetTime(EFI_TIME* time)
{
    return oSetTime(time);
}

EFI_STATUS EFIAPI HookedGetWakeupTime(BOOLEAN* enabled, BOOLEAN* pending, EFI_TIME* time)
{
    return oGetWakeupTime(enabled, pending, time);
}

EFI_STATUS EFIAPI HookedSetWakeupTime(BOOLEAN enable, EFI_TIME* time)
{
    return oSetWakeupTime(enable, time);
}

EFI_STATUS EFIAPI HookedSetVirtualAddressMap(UINTN mapSize, UINTN descriptorSize, UINT32 version, EFI_MEMORY_DESCRIPTOR* virtualMap)
{
    return oSetVirtualAddressMap(mapSize, descriptorSize, version, virtualMap);
}

EFI_STATUS EFIAPI HookedConvertPointer(UINTN debug, void** address)
{
    return oConvertPointer(debug, address);
}

EFI_STATUS EFIAPI HookedGetVariable(CHAR16* variableName, EFI_GUID* vendorGuid, UINT32* attributes, UINTN* dataSize, void* data)
{
    return oGetVariable(variableName, vendorGuid, attributes, dataSize, data);
}

EFI_STATUS EFIAPI HookedSetVariable(CHAR16* variableName, EFI_GUID* vendorGuid, UINT32 attributes, UINTN dataSize, void* data)
{
    return mySetVariable(variableName, vendorGuid, attributes, dataSize, data);
}

EFI_STATUS EFIAPI HookedGetNextVariableName(UINTN* variableNameSize, CHAR16* variableName, EFI_GUID* vendorGuid)
{
    return oGetNextVariableName(variableNameSize, variableName, vendorGuid);
}

EFI_STATUS EFIAPI HookedGetNextHighMonotonicCount(UINT32* highCount)
{
    return oGetNextHighMonotonicCount(highCount);
}

EFI_STATUS EFIAPI HookedResetSystem(EFI_RESET_TYPE resetType, EFI_STATUS resetStatus, UINTN dataSize, CHAR16* resetData)
{
    return oResetSystem(resetType, resetStatus, dataSize, resetData);
}

EFI_STATUS EFIAPI HookedUpdateCapsule(EFI_CAPSULE_HEADER** capsuleHeaderArray, UINTN capsuleCount, EFI_PHYSICAL_ADDRESS scatterGatherList)
{
    return oUpdateCapsule(capsuleHeaderArray, capsuleCount, scatterGatherList);
}

EFI_STATUS EFIAPI HookedQueryCapsuleCapabilities(EFI_CAPSULE_HEADER** capsuleHeaderArray, UINTN capsuleCount, UINT64* maximumCapsuleSize, EFI_RESET_TYPE* resetType)
{
    return oQueryCapsuleCapabilities(capsuleHeaderArray, capsuleCount, maximumCapsuleSize, resetType);
}

EFI_STATUS EFIAPI HookedQueryVariableInfo(UINT32 attributes, UINT64* maximumVariableStorageSize, UINT64* remainingVariableStorageSize, UINT64* maximumVariableSize)
{
    return oQueryVariableInfo(attributes, maximumVariableStorageSize, remainingVariableStorageSize, maximumVariableSize);
}

#endif
```

`CRZEFI/main.c`:

```c
#include "definitions.h"
#include "dummy.h"

// Defines used to check if call is really coming from client
#define baseOperation 0x7980
#define VARIABLE_NAME L"FastBootOption"
#define COMMAND_MAGIC baseOperation*0x5478

// Our protocol GUID (should be different for every driver)
EFI_GUID ProtocolGuid = { 0x6f84894e, 0xdd6e, 0x18f8, {0x2d, 0x7e, 0x20, 0xa3, 0xaf, 0xac, 0xb2, 0xd1} };
// VirtualAddressMap GUID (gEfiEventVirtualAddressChangeGuid)
EFI_GUID VirtualGuid = { 0x13FA7698, 0xC831, 0x49C7, { 0x87, 0xEA, 0x8F, 0x43, 0xFC, 0xC2, 0x51, 0x96 } }; //we will remove later shouldn't be important
// ExitBootServices GUID (gEfiEventExitBootServicesGuid)
EFI_GUID ExitGuid = { 0x27ABF055, 0xB1B8, 0x4C26, { 0x80, 0x48, 0x74, 0x8F, 0x37, 0xBA, 0xA2, 0xDF } }; //we will remove later shouldn't be important

// Pointers to original functions
EFI_GET_TIME oGetTime = NULL;
EFI_SET_TIME oSetTime = NULL;
EFI_GET_WAKEUP_TIME oGetWakeupTime = NULL;
EFI_SET_WAKEUP_TIME oSetWakeupTime = NULL;
EFI_SET_VIRTUAL_ADDRESS_MAP oSetVirtualAddressMap = NULL;
EFI_CONVERT_POINTER oConvertPointer = NULL;
EFI_GET_VARIABLE oGetVariable = NULL;
EFI_SET_VARIABLE oSetVariable = NULL;
EFI_GET_NEXT_VARIABLE_NAME oGetNextVariableName = NULL;
EFI_GET_NEXT_HIGH_MONO_COUNT oGetNextHighMonotonicCount = NULL;
EFI_RESET_SYSTEM oResetSystem = NULL;
EFI_UPDATE_CAPSULE oUpdateCapsule = NULL;
EFI_QUERY_CAPSULE_CAPABILITIES oQueryCapsuleCapabilities = NULL;
EFI_QUERY_VARIABLE_INFO oQueryVariableInfo = NULL;

// Global declarations
EFI_EVENT NotifyEvent = NULL;
EFI_EVENT ExitEvent = NULL;
BOOLEAN Virtual = FALSE;
BOOLEAN Runtime = FALSE;
BOOLEAN Cleaned = FALSE;

PsLookupProcessByProcessId GetProcessByPid = (PsLookupProcessByProcessId)NULL;
PsGetProcessSectionBaseAddress GetBaseAddress = (PsGetProcessSectionBaseAddress)NULL;
MmCopyVirtualMemory MCopyVirtualMemory = (MmCopyVirtualMemory)NULL;

// Function that actually performs the r/w
EFI_STATUS RunCommand(MemoryCommand* cmd) {
    // Copy operation
    if (cmd->operation == baseOperation * 0x823)
    {
        void* src_process_id = (void*)cmd->data[0];
        void* src_address = (void*)cmd->data[1];
        void* dest_process_id = (void*)cmd->data[2];
        void* dest_address = (void*)cmd->data[3];
        ptr64 size = cmd->data[4];
        void* resultAddr = (void*)cmd->data[5];

        if (src_process_id == (void*)4ULL) {
            // Same as memcpy function
            CopyMem(dest_address, src_address, size);
        }
        else {
            void* SrcProc = 0;
            void* DstProc = 0;
            ptr64 size_out = 0;
            int status = 0;

            status = GetProcessByPid(src_process_id, &SrcProc);
            if (status < 0) {
                *(ptr64*)resultAddr = status;
                return EFI_SUCCESS;
            }

            status = GetProcessByPid(dest_process_id, &DstProc);
            if (status < 0) {
                *(ptr64*)resultAddr = status;
                return EFI_SUCCESS;
            }


            *(ptr64*)resultAddr = MCopyVirtualMemory(SrcProc, src_address, DstProc, dest_address, size, 1, &size_out);
        }
        return EFI_SUCCESS;
    }

    if (cmd->operation == baseOperation * 0x612)
    {
        GetProcessByPid = (PsLookupProcessByProcessId)cmd->data[0];
        GetBaseAddress = (PsGetProcessSectionBaseAddress)cmd->data[1];
        MCopyVirtualMemory = (MmCopyVirtualMemory)cmd->data[2];
        ptr64 resultAddr = cmd->data[3];
        *(ptr64*)resultAddr = 1;
        return EFI_SUCCESS;
    }

    //Get Process Base Address
    if (cmd->operation == baseOperation * 0x289)
    {
        void* pid = (void*)cmd->data[0];
        void* resultAddr = (void*)cmd->data[1];
        void* ProcessPtr = 0;

        //Find process by ID
        if (GetProcessByPid(pid, &ProcessPtr) < 0 || ProcessPtr == 0) {
            *(ptr64*)resultAddr = 0; // Process not found
            return EFI_SUCCESS;
        }

        //Find process Base Address
        *(ptr64*)resultAddr = (ptr64)GetBaseAddress(ProcessPtr); //Return Base Address
        return EFI_SUCCESS;
    }

    // Invalid command
    return EFI_UNSUPPORTED;
}

// Hooked EFI function SetVariable
// Can be called from Windows with NtSetSystemEnvironmentValueEx
EFI_STATUS EFIAPI mySetVariable(IN CHAR16* VariableName, IN EFI_GUID* VendorGuid, IN UINT32 Attributes, IN UINTN DataSize, IN VOID* Data) {
    // Use our hook only after we are in virtual address-space
    if (Virtual && Runtime)
    {
        // Check of input is not null
        if (VariableName != NULL && VariableName[0] != CHAR_NULL && VendorGuid != NULL)
        {
            // Check if variable name is same as our declared one
            // this is used to check if call is really from our program
            // running in the OS (client)
            if (StrnCmp(VariableName, VARIABLE_NAME,
                (sizeof(VARIABLE_NAME) / sizeof(CHAR16)) - 1) == 0)
            {
                if (DataSize == 0 && Data == NULL)
                {
                    // Skip no data
                    return EFI_SUCCESS;
                }

                // Check if the data size is correct
                if (DataSize == sizeof(MemoryCommand))
                {
                    // We did it!
                    // Now we can call the magic function
                    MemoryCommand* cmd = (MemoryCommand*)Data;
                    if (cmd->magic == COMMAND_MAGIC)
                    {
                        return RunCommand(cmd);
                    }
                }
            }
        }
    }

    // Call the original SetVariable() function
    return oSetVariable(VariableName, VendorGuid, Attributes, DataSize, Data);
}

// Event callback when SetVitualAddressMap() is called by OS
VOID EFIAPI SetVirtualAddressMapEvent(IN EFI_EVENT Event, IN VOID* Context) {
    // Convert all other addresses
    RT->ConvertPointer(0, &oGetTime);
    RT->ConvertPointer(0, &oSetTime);
    RT->ConvertPointer(0, &oGetWakeupTime);
    RT->ConvertPointer(0, &oSetWakeupTime);
    RT->ConvertPointer(0, &oSetVirtualAddressMap);
    RT->ConvertPointer(0, &oConvertPointer);
    RT->ConvertPointer(0, &oGetVariable);
    RT->ConvertPointer(0, &oGetNextVariableName);
    RT->ConvertPointer(0, &oSetVariable);
    RT->ConvertPointer(0, &oGetNextHighMonotonicCount);
    RT->ConvertPointer(0, &oResetSystem);
    RT->ConvertPointer(0, &oUpdateCapsule);
    RT->ConvertPointer(0, &oQueryCapsuleCapabilities);
    RT->ConvertPointer(0, &oQueryVariableInfo);

    // Convert runtime services pointer
    RtLibEnableVirtualMappings();

    // Null and close the event so it does not get called again
    NotifyEvent = NULL;

    // We are now working in virtual address-space
    Virtual = TRUE;
}

// Event callback after boot process is started
VOID EFIAPI ExitBootServicesEvent(IN EFI_EVENT Event, IN VOID* Context) {
    // This event is called only once so close it
    BS->CloseEvent(ExitEvent);
    ExitEvent = NULL;
    
    // Boot services are now not avaible
    BS = NULL;

    // We are booting the OS now
    Runtime = TRUE;

    // Print some text so we know it works (300iq)
    ST->ConOut->SetAttribute(ST->ConOut, EFI_WHITE | EFI_BACKGROUND_BLUE);
    ST->ConOut->ClearScreen(ST->ConOut);
    CHAR16* str = L"Driver seems to be working as expected! Windows is booting now...\n";
    Print(str);
    SetMem((ptr64)str, 67 * sizeof(short), 0);
}

// Replaces service table pointer with desired one
// returns original
VOID* SetServicePointer(IN OUT EFI_TABLE_HEADER* ServiceTableHeader, IN OUT VOID** ServiceTableFunction, IN VOID* NewFunction) {
    // We don't want to fuck up the system
    if (ServiceTableFunction == NULL || NewFunction == NULL)
        return NULL;

    // Make sure boot services pointers are not null
    ASSERT(BS != NULL);
    ASSERT(BS->CalculateCrc32 != NULL);

    // Raise task priority level
    CONST EFI_TPL Tpl = BS->RaiseTPL(TPL_HIGH_LEVEL);

    // Swap the pointers
    // GNU-EFI and InterlockedCompareExchangePointer 
    // are not friends
    VOID* OriginalFunction = *ServiceTableFunction;
    *ServiceTableFunction = NewFunction;

    // Change the table CRC32 signature
    ServiceTableHeader->CRC32 = 0;
    BS->CalculateCrc32((UINT8*)ServiceTableHeader, ServiceTableHeader->HeaderSize, &ServiceTableHeader->CRC32);

    // Restore task priority level
    BS->RestoreTPL(Tpl);

    return OriginalFunction;
}

// EFI driver unload routine
EFI_STATUS EFI_FUNCTION efi_unload(IN EFI_HANDLE ImageHandle) {
    // We don't want our driver to be unloaded 
    // until complete reboot
    return EFI_ACCESS_DENIED;
}

// EFI entry point
EFI_STATUS efi_main(IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE* SystemTable) {
    // Initialize internal GNU-EFI functions
    InitializeLib(ImageHandle, SystemTable);

    // Get handle to this image
    EFI_LOADED_IMAGE* LoadedImage = NULL;
    EFI_STATUS status = BS->OpenProtocol(ImageHandle, &LoadedImageProtocol,
        (void**)&LoadedImage, ImageHandle,
        NULL, EFI_OPEN_PROTOCOL_GET_PROTOCOL);

    CHAR16* fstr = L"Can't open protocol: %d\n";

    // Return if protocol failed to open
    if (EFI_ERROR(status))
    {
        Print(fstr, status);
        return status;
    }

    //Randomize protocol GUID
    EFI_TIME time = { 0 };
    SetMem(&time, sizeof(EFI_TIME), 0);
    gRT->GetTime(&time, NULL);
    ptr64 num = time.Nanosecond + time.Second;
    if (num == 0) {
        num = &ProtocolGuid;
    }
    unsigned char* gdata = (unsigned char*)&ProtocolGuid;
    for (int i = 0; i < 16; i++) {
        gdata[i] = num * gdata[i];
    }

    CHAR16 str[0x100] = { 0 };
    SetMem(str, 0x100, 0);
    GuidToString(str, &ProtocolGuid);
    Print(L"GUID: ");
    Print(str);
    Print(L"\n");

    // Install our protocol interface
    // This is needed to keep our driver loaded
    DummyProtocalData dummy = { 0 };
    status = LibInstallProtocolInterfaces(
        &ImageHandle, &ProtocolGuid,
        &dummy, NULL);

    // Return if interface failed to register
    if (EFI_ERROR(status))
    {
        Print(L"Can't register interface: %d\n", status);
        return status;
    }

    // Set our image unload routine
    LoadedImage->Unload = (EFI_IMAGE_UNLOAD)efi_unload;

    // Create global event for VirtualAddressMap
    status = BS->CreateEventEx(EVT_NOTIFY_SIGNAL,
        TPL_NOTIFY,
        SetVirtualAddressMapEvent,
        NULL,
        VirtualGuid,
        &NotifyEvent);

    // Return if event create failed
    if (EFI_ERROR(status))
    {
        Print(L"Can't create event (SetVirtualAddressMapEvent): %d\n", status);
        return status;
    }

    // Create global event for ExitBootServices
    status = BS->CreateEventEx(EVT_NOTIFY_SIGNAL,
        TPL_NOTIFY,
        ExitBootServicesEvent,
        NULL,
        ExitGuid,
        &ExitEvent);

    // Return if event create failed (yet again)
    if (EFI_ERROR(status))
    {
        Print(L"Can't create event (ExitBootServicesEvent): %d\n", status);
        return status;
    }

    // Hook all the other runtime services functions
    oGetTime = (EFI_GET_TIME)SetServicePointer(&RT->Hdr, (VOID**)&RT->GetTime, (VOID**)&HookedGetTime);
    oSetTime = (EFI_SET_TIME)SetServicePointer(&RT->Hdr, (VOID**)&RT->SetTime, (VOID**)&HookedSetTime);
    oGetWakeupTime = (EFI_SET_TIME)SetServicePointer(&RT->Hdr, (VOID**)&RT->GetWakeupTime, (VOID**)&HookedGetWakeupTime);
    oSetWakeupTime = (EFI_SET_WAKEUP_TIME)SetServicePointer(&RT->Hdr, (VOID**)&RT->SetWakeupTime, (VOID**)&HookedSetWakeupTime);
    oSetVirtualAddressMap = (EFI_SET_VIRTUAL_ADDRESS_MAP)SetServicePointer(&RT->Hdr, (VOID**)&RT->SetVirtualAddressMap, (VOID**)&HookedSetVirtualAddressMap);
    oConvertPointer = (EFI_CONVERT_POINTER)SetServicePointer(&RT->Hdr, (VOID**)&RT->ConvertPointer, (VOID**)&HookedConvertPointer);
    oGetVariable = (EFI_GET_VARIABLE)SetServicePointer(&RT->Hdr, (VOID**)&RT->GetVariable, (VOID**)&HookedGetVariable);
    oGetNextVariableName = (EFI_GET_NEXT_VARIABLE_NAME)SetServicePointer(&RT->Hdr, (VOID**)&RT->GetNextVariableName, (VOID**)&HookedGetNextVariableName);
    oSetVariable = (EFI_SET_VARIABLE)SetServicePointer(&RT->Hdr, (VOID**)&RT->SetVariable, (VOID**)&HookedSetVariable);
    oGetNextHighMonotonicCount = (EFI_GET_NEXT_HIGH_MONO_COUNT)SetServicePointer(&RT->Hdr, (VOID**)&RT->GetNextHighMonotonicCount, (VOID**)&HookedGetNextHighMonotonicCount);
    oResetSystem = (EFI_RESET_SYSTEM)SetServicePointer(&RT->Hdr, (VOID**)&RT->ResetSystem, (VOID**)&HookedResetSystem);
    oUpdateCapsule = (EFI_UPDATE_CAPSULE)SetServicePointer(&RT->Hdr, (VOID**)&RT->UpdateCapsule, (VOID**)&HookedUpdateCapsule);
    oQueryCapsuleCapabilities = (EFI_QUERY_CAPSULE_CAPABILITIES)SetServicePointer(&RT->Hdr, (VOID**)&RT->QueryCapsuleCapabilities, (VOID**)&HookedQueryCapsuleCapabilities);
    oQueryVariableInfo = (EFI_QUERY_VARIABLE_INFO)SetServicePointer(&RT->Hdr, (VOID**)&RT->QueryVariableInfo, (VOID**)&HookedQueryVariableInfo);
    
    // Print confirmation text
    Print(L"\n");
    Print(L"       __ _                                  \n");
    Print(L"  ___ / _(_)___ _ __  ___ _ __  ___ _ _ _  _ \n");
    Print(L" / -_)  _| |___| '  \\/ -_) '  \\/ _ \\ '_| || |\n");
    Print(L" \\___|_| |_|   |_|_|_\\___|_|_|_\\___/_|  \\_, |\n");
    Print(L"                                        |__/ \n");
    Print(L"Developed and improved by TheCruZ\n");
    Print(L"Based in efi-memory of Samuel Tulach\n");
    Print(L"Thanks to: @Mattiwatti (EfiGuard), Roderick W. Smith (rodsbooks.com)\n\n");
    Print(L"Driver has been loaded successfully. You can now boot to the OS.\n");
    CHAR16* pos2 = L"If you don't see a blue screen while booting disable Secure Boot!.\n";
    Print(pos2);
    SetMem((ptr64)fstr, ((ptr64)pos2 - (ptr64)fstr) + (68*sizeof(short)), 0);
    return EFI_SUCCESS;
}

```