Project Path: arc_gmh5225_makin_omxvbexz

Source Tree:

```txt
arc_gmh5225_makin_omxvbexz
├── LICENSE
├── README.md
├── asho
│   ├── Header.h
│   ├── asho.cpp
│   ├── asho.vcxproj
│   ├── asho.vcxproj.filters
│   ├── dllmain.cpp
│   ├── hook.h
│   ├── hookFunctions.h
│   ├── stdafx.cpp
│   ├── stdafx.h
│   ├── targetver.h
│   ├── utils.cpp
│   └── utils.h
├── external
│   ├── json
│   └── zydis
├── makin
│   ├── checks.json
│   ├── makin.cpp
│   ├── makin.vcxproj
│   ├── makin.vcxproj.filters
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
└── makin.sln

```

`LICENSE`:

```
MIT License

Copyright (c) 2017 Lasha Khasaia

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
I create `makin` to make initial malware assessment little bit easier for me, I think it's useful for others as well, It helps to reveal a debugger detection techniques used by a sample.

##### Any feedback is greatly appreciated: [@_qaz_qaz](https://twitter.com/_qaz_qaz)

### How does it work?
`makin` opens a sample as a debuggee and injects `asho.dll`(main module renames all `dlls` before injection), `asho.dll` hooks several functions at `ntdll.dll` and `kernelbase.dll` libraries and after parameters checkings, it sends the corresponding message to the debugger (`makin.exe`).

`makin` also generates a script for IDA Pro to set breakpoints at detected APIs.

At this moment, `makin` can reveal following techniques: 

`ntdll.dll`:
* `NtClose` - ref: [The "Ultimate" Anti-Debugging Reference: 7.B.ii](https://web.archive.org/web/20171212061916/http://pferrie.host22.com/papers/antidebug.pdf)
* `NtOpenProcess` - ref: [The "Ultimate" Anti-Debugging Reference: 7.B.i](https://web.archive.org/web/20171212061916/http://pferrie.host22.com/papers/antidebug.pdf)
* `NtCreateFile` - ref: [The "Ultimate" Anti-Debugging Reference: 7.B.iii (Open itself)](https://web.archive.org/web/20171212061916/http://pferrie.host22.com/papers/antidebug.pdf)
* `NtCreateFile` - ref: [The "Ultimate" Anti-Debugging Reference: 7.B.iii (Open a driver)](https://web.archive.org/web/20171212061916/http://pferrie.host22.com/papers/antidebug.pdf)
* `LdrLoadDll` - ref: [The "Ultimate" Anti-Debugging Reference: 7.B.iv](https://web.archive.org/web/20171212061916/http://pferrie.host22.com/papers/antidebug.pdf)
* `NtSetDebugFilterState` - ref: [The "Ultimate" Anti-Debugging Reference: 7.D.vi](https://web.archive.org/web/20171212061916/http://pferrie.host22.com/papers/antidebug.pdf)
* `NtQueryInformationProcess` - ref: [The "Ultimate" Anti-Debugging Reference: 7.D.viii.a, 7.D.viii.b, 7.D.viii.c](https://web.archive.org/web/20171212061916/http://pferrie.host22.com/papers/antidebug.pdf)
* `NtQuerySystemInformation` - ref: [The "Ultimate" Anti-Debugging Reference: 7.E.iii](https://web.archive.org/web/20171212061916/http://pferrie.host22.com/papers/antidebug.pdf)
* `NtSetInformationThread` - ref: [The "Ultimate" Anti-Debugging Reference 7.F.iii](https://web.archive.org/web/20171212061916/http://pferrie.host22.com/papers/antidebug.pdf)
* `NtCreateUserProcess` - ref: [The "Ultimate" Anti-Debugging Reference 7.G.i](https://web.archive.org/web/20171212061916/http://pferrie.host22.com/papers/antidebug.pdf)
* `NtCreateThreadEx` - ref: [ntuery blog post](https://web.archive.org/web/20171211143522/https://ntquery.wordpress.com/2014/03/29/anti-debug-ntcreatethreadex/)
* `NtSystemDebugControl` - ref: [@waleedassar - pastebin](https://goo.gl/j4g5pV)
* `NtYieldExecution` - ref: [The "Ultimate" Anti-Debugging Reference 7.D.xiii](https://web.archive.org/web/20171212061916/http://pferrie.host22.com/papers/antidebug.pdf)
* `NtSetLdtEntries` - ref: [ANTI-UNPACKER TRICKS: PART ONE - 2.1.2](https://web.archive.org/web/20171215191103/http://pferrie.tripod.com/papers/unpackers21.pdf)
* `NtQueryInformationThread` - ref: [ntquery - NtQueryInformationThread](https://web.archive.org/web/20180110063515/https://ntquery.wordpress.com/2014/03/29/anti-debug-ntsetinformationthread/)
* `NtCreateDebugObject` and `NtQueryObject` - ref: [Anti-Debug NtQueryObject](https://goo.gl/krE6JM)
* `RtlAdjustPrivilege` - ref: [Using RtlAdjustPrivilege to detect debugger by insid3codeteam](https://goo.gl/m46tQe) 
* ~~~`GetWriteWatch` - ref: [Anti-debug with VirtualAlloc’s write watch](https://web.archive.org/web/20180127193503/https://codeinsecurity.wordpress.com/2018/01/24/anti-debug-with-virtualallocs-write-watch/)~~~
* `PEB->BeingDebugged` - Instead of calling `IsDebuggerPresent()`, some programs manually check the `PEB` (Process Environment Block) for the [`BeingDebugged`](https://www.aldeid.com/wiki/PEB-Process-Environment-Block/BeingDebugged) flag.
* `PEB->NtGlobalFlag` - ref: [al-khaser](https://github.com/LordNoteworthy/al-khaser/blob/bbf020b39b28bfb2561408c276fb91db528fa4ca/al-khaser/Anti%20Debug/ProcessHeap_NtGlobalFlag.cpp)
* `UserSharedData->KdDebuggerEnabled` - ref: [al-khaser - SharedUserData_KernelDebugger](https://github.com/LordNoteworthy/al-khaser/blob/master/al-khaser/Anti%20Debug/SharedUserData_KernelDebugger.cpp)
*  Close `PROCTECTED` handle trick - ref: [al-khaser - HANDLE_FLAG_PROTECT_FROM_CLOSE](https://github.com/LordNoteworthy/al-khaser/blob/master/al-khaser/AntiDebug/SetHandleInformation_API.cpp)

`kernelbase.dll`:
* `IsDebuggerPresent` - ref: [MSDN](https://goo.gl/cg7Fkm)
* `CheckRemoteDebuggerPresent` - ref: [MSDN](https://goo.gl/LrUdaG)
* `SetUnhandledExceptionFilter` - ref: [The "Ultimate" Anti-Debugging Reference: D.xv](https://web.archive.org/web/20171212061916/http://pferrie.host22.com/papers/antidebug.pdf)
* `RegOpenKeyExInternalW` - checks registry keys
* `RegQueryValueExW` - checks registry key values

You can add more VM checks via editing `checks.json` file, without modification of the executable

That's all for now, you can add as much as you wish :) 

## Third-party
- Zydis ([MIT License](https://github.com/zyantific/zydis/blob/master/LICENSE))
- JSON for Modern C++ ([MIT License](https://github.com/nlohmann/json/blob/develop/LICENSE.MIT))

##### DEMO:

![makin_demo](https://user-images.githubusercontent.com/16405698/33871171-c6f8a156-df2a-11e7-8ffb-b9ae5c030c48.gif)

```

`asho/Header.h`:

```h
#pragma once

#define STATUS_SUCCESS                   0x00000000L
#define STATUS_ACCESS_DENIED             0xC0000022L
#define STATUS_NO_YIELD_PERFORMED        0x40000024L

typedef enum _PROCESSINFOCLASS
{
	ProcessBasicInformation = 0,
	ProcessQuotaLimits = 1,
	ProcessIoCounters = 2,
	ProcessVmCounters = 3,
	ProcessTimes = 4,
	ProcessBasePriority = 5,
	ProcessRaisePriority = 6,
	ProcessDebugPort = 7,
	ProcessExceptionPort = 8,
	ProcessAccessToken = 9,
	ProcessLdrInformation = 10,
	ProcessLdtSize = 11,
	ProcessDefaultHardErrorMode = 12,
	ProcessIoPortHandlers = 13,
	ProcessPooledUsageAndLimits = 14,
	ProcessWorkingSetWatch = 15,
	ProcessUserModeIOPL = 16,
	ProcessEnableAlignmentFaultFixup = 17,
	ProcessPriorityClass = 18,
	ProcessWx86Information = 19,
	ProcessHandleCount = 20,
	ProcessAffinityMask = 21,
	ProcessPriorityBoost = 22,
	ProcessDeviceMap = 23,
	ProcessSessionInformation = 24,
	ProcessForegroundInformation = 25,
	ProcessWow64Information = 26,
	ProcessImageFileName = 27,
	ProcessLUIDDeviceMapsEnabled = 28,
	ProcessBreakOnTermination = 29,
	ProcessDebugObjectHandle = 30,
	ProcessDebugFlags = 31,
	ProcessHandleTracing = 32,
	ProcessIoPriority = 33,
	ProcessExecuteFlags = 34,
	ProcessTlsInformation = 35,
	ProcessCookie = 36,
	ProcessImageInformation = 37,
	ProcessCycleTime = 38,
	ProcessPagePriority = 39,
	ProcessInstrumentationCallback = 40,
	ProcessThreadStackAllocation = 41,
	ProcessWorkingSetWatchEx = 42,
	ProcessImageFileNameWin32 = 43,
	ProcessImageFileMapping = 44,
	ProcessAffinityUpdateMode = 45,
	ProcessMemoryAllocationMode = 46,
	ProcessGroupInformation = 47,
	ProcessTokenVirtualizationEnabled = 48,
	ProcessConsoleHostProcess = 49,
	ProcessWindowInformation = 50,
	MaxProcessInfoClass // always last one so no need to add a value manually
} PROCESSINFOCLASS;

typedef enum _THREADINFOCLASS
{
	ThreadBasicInformation = 0,
	ThreadTimes = 1,
	ThreadPriority = 2,
	ThreadBasePriority = 3,
	ThreadAffinityMask = 4,
	ThreadImpersonationToken = 5,
	ThreadDescriptorTableEntry = 6,
	ThreadEnableAlignmentFaultFixup = 7,
	ThreadEventPair_Reusable = 8,
	ThreadQuerySetWin32StartAddress = 9,
	ThreadZeroTlsCell = 10,
	ThreadPerformanceCount = 11,
	ThreadAmILastThread = 12,
	ThreadIdealProcessor = 13,
	ThreadPriorityBoost = 14,
	ThreadSetTlsArrayAddress = 15,
	// Obsolete
	ThreadIsIoPending = 16,
	ThreadHideFromDebugger = 17,
	ThreadBreakOnTermination = 18,
	ThreadSwitchLegacyState = 19,
	ThreadIsTerminated = 20,
	ThreadLastSystemCall = 21,
	ThreadIoPriority = 22,
	ThreadCycleTime = 23,
	ThreadPagePriority = 24,
	ThreadActualBasePriority = 25,
	ThreadTebInformation = 26,
	ThreadCSwitchMon = 27,
	// Obsolete
	ThreadCSwitchPmu = 28,
	ThreadWow64Context = 29,
	ThreadGroupInformation = 30,
	ThreadUmsInformation = 31,
	// UMS
	ThreadCounterProfiling = 32,
	ThreadIdealProcessorEx = 33,
	ThreadCpuAccountingInformation = 34,
	ThreadSuspendCount = 35,
	ThreadActualGroupAffinity = 41,
	ThreadDynamicCodePolicyInfo = 42,
	ThreadSubsystemInformation = 45,

	MaxThreadInfoClass = 50,
} THREADINFOCLASS;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION
{
	BOOLEAN KernelDebuggerEnabled;
	BOOLEAN KernelDebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;


typedef struct _LSA_UNICODE_STRING
{
	USHORT Length;
	USHORT MaximumLength;
	PWSTR Buffer;
} LSA_UNICODE_STRING, *PLSA_UNICODE_STRING, UNICODE_STRING, *PUNICODE_STRING;

typedef struct _RTL_USER_PROCESS_PARAMETERS
{
	BYTE Reserved1[16];
	PVOID Reserved2[10];
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

typedef struct _CLIENT_ID
{
	HANDLE UniqueProcess;
	HANDLE UniqueThread;
} CLIENT_ID;

using PCLIENT_ID = CLIENT_ID *;

//typedef void xNtRaiseException(
//	IN PEXCEPTION_RECORD    ExceptionRecord,
//	IN PCONTEXT             ThreadContext,
//	IN BOOLEAN              HandleException);

typedef struct _OBJECT_ATTRIBUTES
{
	ULONG Length;
	HANDLE RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG Attributes;
	PVOID SecurityDescriptor; // Points to type SECURITY_DESCRIPTOR
	PVOID SecurityQualityOfService; // Points to type SECURITY_QUALITY_OF_SERVICE
} OBJECT_ATTRIBUTES;

using POBJECT_ATTRIBUTES = OBJECT_ATTRIBUTES *;


typedef struct _PEB
{
	BYTE Reserved1[2];
	BYTE BeingDebugged;
	BYTE Reserved2[1];
	PVOID Reserved3[2];
	LPVOID /*PPEB_LDR_DATA*/ Ldr;
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
	PVOID Reserved4[3];
	PVOID AtlThunkSListPtr;
	PVOID Reserved5;
	ULONG Reserved6;
	PVOID Reserved7;
	ULONG Reserved8;
	ULONG AtlThunkSListPtr32;
	PVOID Reserved9[45];
	BYTE Reserved10[96];
	LPVOID /*PPS_POST_PROCESS_INIT_ROUTINE*/ PostProcessInitRoutine;
	BYTE Reserved11[128];
	PVOID Reserved12[1];
	ULONG SessionId;
} PEB, *PPEB;


typedef enum _DEBUG_CONTROL_CODE
{
	DebugSysGetTraceInformation = 1,
	DebugSysSetInternalBreakpoint,
	DebugSysSetSpecialCall,
	DebugSysClerSpecialCalls,
	DebugSysQuerySpecialCalls,
	DebugSysBreakpointWithStatus,
	DebugSysGetVersion,
	DebugSysReadVirtual,
	DebugSysWriteVirtual,
	DebugSysReadPhysical,
	DebugSysWritePhysical,
	DebugSysReadControlSpace,
	DebugSysWriteControlSpace,
	DebugSysReadIoSpace,
	DebugSysSysWriteIoSpace,
	DebugSysReadMsr,
	DebugSysWriteMsr,
	DebugSysReadBusData,
	DebugSysWriteBusData,
	DebugSysCheckLowMemory,
} DEBUG_CONTROL_CODE;

typedef enum _OBJECT_INFORMATION_CLASS
{
	ObjectBasicInformation,
	// OBJECT_BASIC_INFORMATION
	ObjectNameInformation,
	// OBJECT_NAME_INFORMATION
	ObjectTypeInformation,
	// OBJECT_TYPE_INFORMATION
	ObjectTypesInformation,
	// OBJECT_TYPES_INFORMATION
	ObjectHandleFlagInformation,
	// OBJECT_HANDLE_FLAG_INFORMATION
	ObjectSessionInformation,
	ObjectSessionObjectInformation,
	MaxObjectInfoClass
} OBJECT_INFORMATION_CLASS;

typedef struct _OBJECT_TYPE_INFORMATION
{
	UNICODE_STRING TypeName;
	ULONG TotalNumberOfHandles;
	ULONG TotalNumberOfObjects;
} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;

typedef struct _OBJECT_ALL_INFORMATION {
	ULONG NumberOfObjects;
	OBJECT_TYPE_INFORMATION ObjectTypeInformation[1];
} OBJECT_ALL_INFORMATION, *POBJECT_ALL_INFORMATION;

typedef enum _SHUTDOWN_ACTION
{
	ShutdownNoReboot,
	ShutdownReboot,
	ShutdownPowerOff
} SHUTDOWN_ACTION, *PSHUTDOWN_ACTION;

```

`asho/asho.cpp`:

```cpp
// asho.cpp : Defines the exported functions for the DLL application.
//

#include "stdafx.h"

```

`asho/asho.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{B9B4C3F7-6805-4D14-B0AB-1E18D868E0CC}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>asho</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>true</RunCodeAnalysis>
    <IncludePath>$(SolutionDir)external\zydis\msvc;$(SolutionDir)external\zydis\include;$(SolutionDir)external\zydis\dependencies\zycore\include;$(SolutionDir)external\json\single_include;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>true</RunCodeAnalysis>
    <IncludePath>$(SolutionDir)external\zydis\msvc;$(SolutionDir)external\zydis\include;$(SolutionDir)external\zydis\dependencies\zycore\include;$(SolutionDir)external\json\single_include;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir)external\zydis\msvc;$(SolutionDir)external\zydis\include;$(SolutionDir)external\zydis\dependencies\zycore\include;$(SolutionDir)external\json\single_include;$(IncludePath)</IncludePath>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir)external\zydis\msvc;$(SolutionDir)external\zydis\include;$(SolutionDir)external\zydis\dependencies\zycore\include;$(SolutionDir)external\json\single_include;$(IncludePath)</IncludePath>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>ZYCORE_STATIC_DEFINE;ZYDIS_STATIC_DEFINE;WIN32;_DEBUG;ASHO_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <EnablePREfast>true</EnablePREfast>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>zydis.lib;zycore.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalLibraryDirectories>$(SolutionDir)external\zydis\msvc\bin\ReleaseX86</AdditionalLibraryDirectories>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>ZYCORE_STATIC_DEFINE;ZYDIS_STATIC_DEFINE;_DEBUG;ASHO_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <EnablePREfast>true</EnablePREfast>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(SolutionDir)external\zydis\msvc\bin\ReleaseX64</AdditionalLibraryDirectories>
      <AdditionalDependencies>zydis.lib;zycore.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>ZYCORE_STATIC_DEFINE;ZYDIS_STATIC_DEFINE;WIN32;NDEBUG;ASHO_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <DebugInformationFormat>None</DebugInformationFormat>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(SolutionDir)external\zydis\msvc\bin\ReleaseX86</AdditionalLibraryDirectories>
      <AdditionalDependencies>zydis.lib;zycore.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>ZYCORE_STATIC_DEFINE;ZYDIS_STATIC_DEFINE;NDEBUG;ASHO_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <DebugInformationFormat>None</DebugInformationFormat>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(SolutionDir)external\zydis\msvc\bin\ReleaseX64</AdditionalLibraryDirectories>
      <AdditionalDependencies>zydis.lib;zycore.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="Header.h" />
    <ClInclude Include="hook.h" />
    <ClInclude Include="hookFunctions.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
    <ClInclude Include="utils.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="asho.cpp" />
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="utils.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`asho/asho.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Header.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hookFunctions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="asho.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="dllmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="utils.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`asho/dllmain.cpp`:

```cpp
//
// author: Lasha Khasaia
// contact: @_qaz_qaz
// license: MIT License
//

#include "stdafx.h"

#include "hook.h"

#define NO_MSG_BOX


VOID DoWork()
{
#ifdef _DEBUG
#ifndef NO_MSG_BOX
	MessageBox(nullptr, L"DLL injected successfully", L"Debug Mode", MB_ICONINFORMATION);
#endif
#endif

	Hook hook;
	if (!hook.HookFuncs())
	{
		OutputDebugString(L"Hooking Failed");
		ExitProcess(ERROR_SUCCESS);
	}
}


BOOL APIENTRY DllMain(HMODULE hModule,
                      DWORD ul_reason_for_call,
                      LPVOID lpReserved
)
{
	UNREFERENCED_PARAMETER(hModule);
	UNREFERENCED_PARAMETER(lpReserved);

	if (ul_reason_for_call == DLL_PROCESS_ATTACH)
	{
		// Reduce the size of the working set for some applications https://blogs.msdn.microsoft.com/larryosterman/2004/06/03/little-known-win32-apis-disablethreadlibrarycalls/
		DisableThreadLibraryCalls(hModule);

		DoWork();
	}

	return TRUE;
}

```

`asho/hook.h`:

```h
#pragma once

#include "stdafx.h"

#include <Zydis/Zydis.h>
#include <nlohmann/json.hpp>
#include "hookFunctions.h"

class Hook
{
	HMODULE NtdllModule{};
	HMODULE KernelBaseModule{};
	ZydisDecoder decoder;

	void HookFunction(std::string targetFunction, DWORD_PTR hookFunc, std::string libModule) const;

public:
	Hook();
	bool HookFuncs() const;
};

inline void Hook::HookFunction(const std::string targetFunction, const DWORD_PTR hookFunc,
                               const std::string libModule) const
{
	HMODULE lib;
	if (libModule == "ntdll")
	{
		lib = NtdllModule;
	}
	else
	{
		lib = KernelBaseModule;
	}
	if (!lib)
	{
		return;
	}
	auto targetFuncAddress = static_cast<LPVOID>(GetProcAddress(lib, targetFunction.c_str()));

	const ZyanUSize length = 0x10; // MAX INSTR size
	ZydisDecodedInstruction instruction;
	if (!		ZYAN_SUCCESS(ZydisDecoderDecodeBuffer(&decoder, targetFuncAddress, length,
		&instruction)))
		return;

	auto nextInstruction = reinterpret_cast<DWORD_PTR>(targetFuncAddress);
	if (instruction.mnemonic == ZYDIS_MNEMONIC_MOV)
	{
		nextInstruction = reinterpret_cast<DWORD_PTR>(targetFuncAddress) + instruction.length;
	}


#if defined(_WIN64)
	byte jmp[] = {0x48, 0xB8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xFF, 0xE0};
	DWORD old;
	VirtualProtectEx(GetCurrentProcess(), reinterpret_cast<LPVOID>(nextInstruction), 100, PAGE_EXECUTE_READWRITE, &old);
	memcpy_s(reinterpret_cast<PVOID>(nextInstruction), 2, jmp, 2);
	*reinterpret_cast<DWORD_PTR*>(reinterpret_cast<byte*>(nextInstruction) + 2) = static_cast<DWORD_PTR>(hookFunc);
	memcpy_s(reinterpret_cast<byte*>(nextInstruction) + 10, 2, jmp + 10, 2);
	VirtualProtectEx(GetCurrentProcess(), reinterpret_cast<LPVOID>(nextInstruction), 100, old, &old);
#else
	byte jmp[] = { 0x68, 0xCC, 0xCC, 0xCC, 0xCC, 0xC3 };
	DWORD old;
	VirtualProtectEx(GetCurrentProcess(), reinterpret_cast<LPVOID>(nextInstruction), 100, PAGE_EXECUTE_READWRITE, &old);
	memcpy_s(reinterpret_cast<PVOID>(nextInstruction), 1, jmp, 1);
	*reinterpret_cast<DWORD32*>(reinterpret_cast<byte*>(nextInstruction) + 1) = static_cast<DWORD32>(hookFunc);
	memcpy_s(reinterpret_cast<byte*>(nextInstruction) + 5, 1, jmp + 5, 1);
	VirtualProtectEx(GetCurrentProcess(), reinterpret_cast<LPVOID>(nextInstruction), 100, old, &old);
#endif
}


inline Hook::Hook()
{
	TCHAR tmp[MAX_PATH + 2]{};
	GetTempPath(MAX_PATH + 2, tmp);
	TCHAR sys[MAX_PATH + 2]{};
	GetSystemDirectory(sys, MAX_PATH + 2);

	auto randomNtdllPath = std::wstring{tmp} + GenRandStr(4) + L".dll";
	auto ntdllPath = std::wstring{sys} + L"\\ntdll.dll";
	CopyFile(ntdllPath.c_str(), randomNtdllPath.c_str(), FALSE);
	ntdllCopyModule = LoadLibrary(randomNtdllPath.c_str()); // for us ;)
	NtdllModule = LoadLibrary(L"ntdll");
	if (!ntdllCopyModule || !NtdllModule)
	{
		OutputDebugString(L"Failed loading ntdll module");
		RaiseException(1, 0, 0, nullptr); // TODO: better exception
	}


	auto randomKernelBasePath = std::wstring{tmp} + GenRandStr(5) + L".dll";
	auto kernelBasePath = std::wstring{sys} + L"\\kernelbase.dll";
	CopyFile(kernelBasePath.c_str(), randomKernelBasePath.c_str(), FALSE);
	kernelBaseCopyModule = LoadLibrary(randomKernelBasePath.c_str()); // for us ;)
	KernelBaseModule = LoadLibrary(L"kernelbase");
	if (!kernelBaseCopyModule || !KernelBaseModule)
	{
		OutputDebugString(L"Failed loading kernelbase module");
		RaiseException(1, 0, 0, nullptr); // TODO: better exception
	}

	const auto currentModuleHandle = GetModuleHandle(nullptr);
	if (!currentModuleHandle)
		return;
	if (!GetModuleInformation(GetCurrentProcess(), currentModuleHandle, &currentModuleInfo, sizeof(MODULEINFO)))
	{
		OutputDebugString(L"Failed getting main module information");
		RaiseException(1, 0, 0, nullptr); // TODO: better exception
	}

	const auto hFile = CreateFile(L"checks.json", GENERIC_READ, 0, nullptr, OPEN_EXISTING, 0, nullptr);
	if (INVALID_HANDLE_VALUE != hFile)
	{
		LARGE_INTEGER li;
		GetFileSizeEx(hFile, &li);

		auto chBuffer = std::unique_ptr<char[]>(new char[li.QuadPart + sizeof(char)]{});
		ReadFile(hFile, chBuffer.get(), li.QuadPart + sizeof(char), nullptr, nullptr);
		jsObject = nlohmann::json::parse(chBuffer.get());
		CloseHandle(hFile);
	}

#if defined(_WIN64)
	ZydisDecoderInit(&decoder, ZYDIS_MACHINE_MODE_LONG_64, ZYDIS_ADDRESS_WIDTH_64);
#else
	ZydisDecoderInit(&decoder, ZYDIS_MACHINE_MODE_LEGACY_32, ZYDIS_ADDRESS_WIDTH_32);
#endif
}

inline bool Hook::HookFuncs() const
{
	//// ntdll
	HookFunction("NtClose", DWORD_PTR(HookNtClose), "ntdll");
	HookFunction("NtOpenProcess", DWORD_PTR(HookNtOpenProcess), "ntdll");
	HookFunction("NtCreateFile", DWORD_PTR(HookNtCreateFile), "ntdll");
	HookFunction("NtSetDebugFilterState", DWORD_PTR(HookNtSetDebugFilterState), "ntdll");
	HookFunction("NtQueryInformationProcess", DWORD_PTR(HookNtQueryInformationProcess), "ntdll");
	HookFunction("NtQuerySystemInformation", DWORD_PTR(HookNtQuerySystemInformation), "ntdll");
	HookFunction("NtSetInformationThread", DWORD_PTR(HookNtSetInformationThread), "ntdll");
	HookFunction("NtCreateUserProcess", DWORD_PTR(HookNtCreateUserProcess), "ntdll");
	HookFunction("NtCreateThreadEx", DWORD_PTR(HookNtCreateThreadEx), "ntdll");
	HookFunction("NtSystemDebugControl", DWORD_PTR(HookNtSystemDebugControl), "ntdll");
	HookFunction("NtYieldExecution", DWORD_PTR(HookNtYieldExecution), "ntdll");
	HookFunction("NtSetLdtEntries", DWORD_PTR(HookNtSetLdtEntries), "ntdll");
	HookFunction("NtQueryInformationThread", DWORD_PTR(HookNtQueryInformationThread), "ntdll");
	HookFunction("NtCreateDebugObject", DWORD_PTR(HookNtCreateDebugObject), "ntdll");
	HookFunction("NtQueryObject", DWORD_PTR(HookNtQueryObject), "ntdll");
	HookFunction("RtlAdjustPrivilege", DWORD_PTR(HookRtlAdjustPrivilege), "ntdll");
	HookFunction("NtShutdownSystem", DWORD_PTR(HookNtShutdownSystem), "ntdll");
	HookFunction("ZwGetContextThread", DWORD_PTR(HookGetThreadContext), "ntdll");

	//// Causes ZwAllocateVirtualMemory related errors TODO: FIX it
	////hookFunction("ZwAllocateVirtualMemory", DWORD_PTR(hookZwAllocateVirtualMemory), L"ntdll");
	////hookFunction("ZwGetWriteWatch", DWORD_PTR(hookZwGetWriteWatch), L"ntdll");

	//// kernelbase
	HookFunction("IsDebuggerPresent", DWORD_PTR(HookIsDebuggerPresent), "kernelbase");
	HookFunction("CheckRemoteDebuggerPresent", DWORD_PTR(HookCheckRemoteDebuggerPresent), "kernelbase");
	HookFunction("SetUnhandledExceptionFilter", DWORD_PTR(hookSetUnhandledExceptionFilter), "kernelbase");
	//// what about hooking Rtl version from ntdll?

	//// registry checks

	HookFunction("RegOpenKeyExInternalW", DWORD_PTR(HookRegOpenKeyExInternalW), "kernelbase"); // not stable
	HookFunction("RegQueryValueExW", DWORD_PTR(HookRegQueryValueExW), "RegQueryValueExW");
	//// don't forget "process_output_string" func

	return true;
}

```

`asho/hookFunctions.h`:

```h
#pragma once

#include "stdafx.h"

#include "utils.h"
#include "Header.h"

// hook functions
LONG WINAPI HookNtClose(_In_ HANDLE handle)
{
	typedef LONG WINAPI NtClose(
		_In_ HANDLE _Handle
	);

	// https://web.archive.org/web/20171214081815/http://winapi.freetechsecrets.com/win32/WIN32GetHandleInformation.htm

	DWORD flags{};
	const auto ret = GetHandleInformation(handle, &flags);

	if (!ret) // invalid handle
	{
		TCHAR msg[0x100]{};
#ifdef _WIN64
		swprintf_s(
			msg,
			L"[NtClose] Invalid HANDLE specified by the debuggee - 0x%llx\n\tref: The \"Ultimate\" Anti-Debugging Reference: 7.B.ii\n",
			DWORD_PTR(handle));
#else
		swprintf_s(
			msg,
			L"[NtClose] Invalid HANDLE specified by the debuggee - 0x%x\n\tref: The \"Ultimate\" Anti-Debugging Reference: 7.B.ii\n",
			DWORD32(handle));
#endif
		OutputDebugString(msg);
		return STATUS_INVALID_HANDLE; // return success
	}
	if (flags & HANDLE_FLAG_PROTECT_FROM_CLOSE)
	{
		TCHAR msg[0x100]{};
#ifdef _WIN64
		swprintf_s(
			msg,
			L"[NtClose] The debuggee tries to close PROTECTED HANDLE - 0x%llx\n", DWORD_PTR(handle));
#else
		swprintf_s(msg, L"[NtClose] The debuggee tries to close PROTECTED HANDLE - 0x%x\n", DWORD_PTR(handle));
#endif
		OutputDebugString(msg);
		return 0; // raise exception ??
	}


	const auto close = reinterpret_cast<NtClose*>(GetProcAddress(ntdllCopyModule, "NtClose"));
	return close(handle);
}


LONG WINAPI HookNtOpenProcess(_Out_ PHANDLE ProcessHandle, _In_ ACCESS_MASK DesiredAccess, _In_ LPVOID ObjectAttributes,
                              _In_opt_ PCLIENT_ID ClientId)
{
	typedef LONG WINAPI xZwOpenProcess(
		_Out_ PHANDLE xProcessHandle,
		_In_ ACCESS_MASK xDesiredAccess,
		_In_ LPVOID xObjectAttributes,
		_In_opt_ LPVOID xClientId
	);

	const auto xOP = reinterpret_cast<xZwOpenProcess*>(GetProcAddress(ntdllCopyModule, "NtOpenProcess"));

	TCHAR processName[0x100]{};
	// ProcID
	if (!ClientId)
		return xOP(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);
	const auto procID = DWORD_PTR(ClientId->UniqueProcess);
	const auto hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD, 0);
	if (hSnapshot == INVALID_HANDLE_VALUE)
		return xOP(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);

	PROCESSENTRY32 pe = {sizeof(pe)};
	if (Process32First(hSnapshot, &pe))
	{
		do
		{
			if (pe.th32ProcessID == procID)
			{
				_tcscpy_s(processName, 0x100, pe.szExeFile);
				break;
			}
		}
		while (Process32Next(hSnapshot, &pe));
	}
	CloseHandle(hSnapshot);


	auto files = jsObject["Processes"];

	for (auto& file : files)
	{
		auto str_file = file.get<std::string>();
		std::wstring wstr_file(str_file.begin(), str_file.end());

		if (StrStrI(processName, wstr_file.c_str()))
		{
			auto outStr = new TCHAR[0x100]{};
			wsprintf(outStr,
			         L"[NtOpenProcess] [Suspicious behavior] The debuggee attempts to open the following process: %s\n\tref: https://github.com/LordNoteworthy/al-khaser \n",
			         processName);
			OutputDebugString(outStr);

			delete[] outStr;
		}
	}

	return xOP(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);
}

LONG WINAPI HookNtCreateFile(
	_Out_ PHANDLE FileHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_ POBJECT_ATTRIBUTES ObjectAttributes,
	_Out_ LPVOID IoStatusBlock,
	_In_opt_ PLARGE_INTEGER AllocationSize,
	_In_ ULONG FileAttributes,
	_In_ ULONG ShareAccess,
	_In_ ULONG CreateDisposition,
	_In_ ULONG CreateOptions,
	_In_reads_bytes_opt_(EaLength) PVOID EaBuffer,
	_In_ ULONG EaLength
)
{
	typedef LONG WINAPI xZwCreateFile(
		_Out_ PHANDLE xFileHandle,
		_In_ ACCESS_MASK xDesiredAccess,
		_In_ POBJECT_ATTRIBUTES xObjectAttributes,
		_Out_ LPVOID xIoStatusBlock,
		_In_opt_ PLARGE_INTEGER xAllocationSize,
		_In_ ULONG xFileAttributes,
		_In_ ULONG xShareAccess,
		_In_ ULONG xCreateDisposition,
		_In_ ULONG xCreateOptions,
		_In_reads_bytes_opt_(xEaLength) PVOID
		xEaBuffer,
		_In_ ULONG xEaLength
	);

	// is there a better way to remove \??\ ?
	const auto size = ObjectAttributes->ObjectName->MaximumLength - (4 * sizeof(TCHAR));
	const auto fileName = new TCHAR[size]{};
	_tcscpy_s(fileName, size, ObjectAttributes->ObjectName->Buffer + 4);
	TCHAR cName[MAX_PATH + 2]{};
	DWORD retSize = MAX_PATH + 2;
	QueryFullProcessImageName(GetCurrentProcess(), 0, cName, &retSize);
	// GetModuleFileNameEx(GetCurrentProcess(), nullptr, cName, MAX_PATH + 2);

	if (!_tcscmp(fileName, cName))
	{
		OutputDebugString(
			L"[NtCreateFile] The debuggee attempts to open itself exclusively\n\tref: The \"Ultimate\" Anti-Debugging Reference: 7.B.iii\n");
	}

	const auto devName = new TCHAR[ObjectAttributes->ObjectName->MaximumLength]{};
	_tcscpy_s(devName, ObjectAttributes->ObjectName->MaximumLength, ObjectAttributes->ObjectName->Buffer);

	// The most commonly used I/O devices are as follows: 
	// file, file stream, directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe.


	auto files = jsObject["FileSystem"]["Files"];

	for (auto& file : files)
	{
		auto strFile = file.get<std::string>();
		std::wstring wstrFile(strFile.begin(), strFile.end());
		if (wstrFile.find(std::wstring(devName)) != std::wstring::npos) // TODO: case sens.
		{
			auto outStr = new TCHAR[0x100]{};
			wsprintf(outStr,
			         L"[NtCreateFile] The debuggee attempts to open the following suspicious file/directory or I/O device: %s\n\tref: https://github.com/LordNoteworthy/al-khaser \n",
			         devName);
			OutputDebugString(outStr);

			delete[] outStr;
		}
	}

	// Some debuggers open handle when debuggee loads dll and forget to close handle, we can use this behavior to detect a debugger (not all, but IDA Pro at least)
	// Anti-debugger trick: load a dll via LoadLibrary and try to open the same file for opened for exclusive access.
	TCHAR filePath[0x1000]{};
	_tcscpy_s(filePath, 0x1000, L"[_]");
	_tcscpy_s(filePath + 3, 0x1000 - 3, fileName);

	OutputDebugString(filePath);

	delete[] fileName;
	delete[] devName;
	const auto oCf = reinterpret_cast<xZwCreateFile*>(GetProcAddress(ntdllCopyModule, "NtCreateFile"));
	return oCf(FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, AllocationSize, FileAttributes, ShareAccess,
	           CreateDisposition, CreateOptions, EaBuffer, EaLength);
}

ULONG WINAPI HookNtSetDebugFilterState(ULONG ComponentId, ULONG Level, BOOLEAN State)
{
	UNREFERENCED_PARAMETER(ComponentId);
	UNREFERENCED_PARAMETER(Level);
	UNREFERENCED_PARAMETER(State);
	// typedef ULONG WINAPI NtSetDebugFilterState(ULONG ComponentId, ULONG Level, BOOLEAN State);
	// auto xNtSetDebugFilterState = reinterpret_cast<NtSetDebugFilterState*>(GetProcAddress(NtdllCopyModule, "NtSetDebugFilterState"));

	OutputDebugString(
		L"[NtSetDebugFilterState] The debuggee attempts to use NtSetDebugFilterState trick\n\tref: The \"Ultimate\" Anti-Debugging Reference: 7.D.vi\n");

	// return xNtSetDebugFilterState(ComponentId, Level, State);
	return 1; // fake it ;)
}

LONG WINAPI HookNtQueryInformationProcess(
	_In_ HANDLE ProcessHandle,
	_In_ PROCESSINFOCLASS ProcessInformationClass,
	_Out_ PVOID ProcessInformation,
	_In_ ULONG ProcessInformationLength,
	_Out_opt_ PULONG ReturnLength
)
{
	typedef LONG WINAPI NtQueryInformationProcess(
		_In_ HANDLE xProcessHandle,
		_In_ PROCESSINFOCLASS
		xProcessInformationClass,
		_Out_ PVOID xProcessInformation,
		_In_ ULONG xProcessInformationLength,
		_Out_opt_ PULONG xReturnLength
	);

	const auto oNQi = reinterpret_cast<NtQueryInformationProcess*>(GetProcAddress(
			ntdllCopyModule, "NtQueryInformationProcess")
	);

	const auto status = oNQi(ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength,
	                         ReturnLength);
	if (ProcessInformationClass == ProcessDebugPort)
	{
		OutputDebugString(
			L"[ProcessDebugPort] The debuggee attempts to detect a debugger\n\tref: The \"Ultimate\" Anti-Debugging Reference: 7.D.viii.a\n");
		*static_cast<DWORD_PTR*>(ProcessInformation) = 0; // fake it ;)
	}
	if (ProcessInformationClass == ProcessDebugObjectHandle)
	{
		OutputDebugString(
			L"[ProcessDebugObjectHandle] The debuggee attempts to detect a debugger\n\tref: The \"Ultimate\" Anti-Debugging Reference: 7.D.viii.b\n");
		*static_cast<DWORD_PTR*>(ProcessInformation) = 0; // fake it ;)
	}

	if (ProcessInformationClass == ProcessDebugFlags)
	{
		OutputDebugString(
			L"[ProcessDebugFlags] The debuggee attempts to detect a debugger\n\tref: The \"Ultimate\" Anti-Debugging Reference: 7.D.viii.c\n");
		*static_cast<DWORD*>(ProcessInformation) = 1; // fake it ;)
	}

	return status;
}

LONG WINAPI HookNtQuerySystemInformation(
	ULONG SystemInformationClass,
	PVOID SystemInformation,
	ULONG SystemInformationLength,
	PULONG ReturnLength)
{
	typedef LONG WINAPI pNtQuerySystemInformation(
		ULONG xSystemInformationClass,
		PVOID xSystemInformation,
		ULONG xSystemInformationLength,
		PULONG xReturnLength);

	const auto querySysInfo = reinterpret_cast<pNtQuerySystemInformation*>(GetProcAddress(
		ntdllCopyModule, "NtQuerySystemInformation"));
	const ULONG systemKernelDebuggerInformation = 0x23;

	const auto status = querySysInfo(SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength);

	if (SystemInformationClass == systemKernelDebuggerInformation)
	{
		OutputDebugString(
			L"[SystemKernelDebuggerInformation] The debuggee attempts to detect a kernel debugger\n\tref: The \"Ultimate\" Anti-Debugging Reference: 7.E.iii\n");

		SYSTEM_KERNEL_DEBUGGER_INFORMATION* sysKernelInfo = static_cast<SYSTEM_KERNEL_DEBUGGER_INFORMATION*>(
			SystemInformation);
		sysKernelInfo->KernelDebuggerEnabled = FALSE; // fake it ;)
		sysKernelInfo->KernelDebuggerNotPresent = TRUE;
	}

	return status;
}

LONG WINAPI HookNtSetInformationThread(
	_In_ HANDLE ThreadHandle,
	_In_ THREADINFOCLASS ThreadInformationClass,
	_In_ PVOID ThreadInformation,
	_In_ ULONG ThreadInformationLength
)
{
	typedef LONG WINAPI NtSetInformationThread(
		_In_ HANDLE xThreadHandle,
		_In_ THREADINFOCLASS xThreadInformationClass,
		_In_ PVOID xThreadInformation,
		_In_ ULONG xThreadInformationLength
	);
	const auto setInfoThread = reinterpret_cast<NtSetInformationThread*>(GetProcAddress(
		ntdllCopyModule, "NtSetInformationThread"));

	if (ThreadInformationClass == ThreadHideFromDebugger)
	{
		if (GetThreadId(ThreadHandle) == 0)
		{
			auto msg_out = "[ThreadHideFromDebugger:Invalid_Thread] Calling ThreadHideFromDebugger with invalid thread handle: " + AddressToHexString(DWORD_PTR(ThreadHandle)) + "\n";
			OutputDebugStringA(msg_out.c_str());

			return STATUS_INVALID_PARAMETER;
		}
		if (ThreadInformationLength > 0)
		{
			auto msg_out = "[ThreadHideFromDebugger:Invalid_Information_Size] Calling ThreadHideFromDebugger with invalid ThreadInfoSize: " + AddressToHexString(DWORD_PTR(ThreadInformationLength)) + "\n";
			OutputDebugStringA(msg_out.c_str());

			return STATUS_INVALID_PARAMETER;
		}

		OutputDebugString(
			L"[ThreadHideFromDebugger] The debuggee attempts to hide/escape\n\tref: The \"Ultimate\" Anti-Debugging Reference: 7.F.iii\n");
		return STATUS_SUCCESS;
	}
	// .... 
	return setInfoThread(ThreadHandle, ThreadInformationClass, ThreadInformation, ThreadInformationLength);
}

LONG WINAPI HookNtCreateUserProcess(PHANDLE ProcessHandle, PHANDLE ThreadHandle, ACCESS_MASK ProcessDesiredAccess,
                                    ACCESS_MASK ThreadDesiredAccess, POBJECT_ATTRIBUTES ProcessObjectAttributes,
                                    POBJECT_ATTRIBUTES ThreadObjectAttributes, ULONG ulProcessFlags,
                                    ULONG ulThreadFlags, PRTL_USER_PROCESS_PARAMETERS RtlUserProcessParameters,
                                    LPVOID PsCreateInfo, LPVOID PsAttributeList)
{
	typedef LONG WINAPI xNtCreateUserProcess(PHANDLE xProcessHandle, PHANDLE xThreadHandle,
	                                         ACCESS_MASK xProcessDesiredAccess, ACCESS_MASK xThreadDesiredAccess,
	                                         POBJECT_ATTRIBUTES xProcessObjectAttributes,
	                                         POBJECT_ATTRIBUTES xThreadObjectAttributes, ULONG xulProcessFlags,
	                                         ULONG xulThreadFlags,
	                                         PRTL_USER_PROCESS_PARAMETERS xRtlUserProcessParameters,
	                                         LPVOID xPsCreateInfo, LPVOID xPsAttributeList);

	//const auto createUserProc = reinterpret_cast<xNtCreateUserProcess*>(GetProcAddress(NtdllCopyModule, "NtCreateUserProcess"));

	//const LONG ret = createUserProc(ProcessHandle, ThreadHandle, ProcessDesiredAccess, ThreadDesiredAccess, ProcessObjectAttributes, ThreadObjectAttributes, ulProcessFlags, ulThreadFlags, RtlUserProcessParameters, PsCreateInfo, PsAttributeList);

	TCHAR msg[MSG_LEN]{};
	swprintf_s(msg, L"[NtCreateUserProcess] The debuggee creates a new process:\nPath: ");

	const auto procName = new TCHAR[RtlUserProcessParameters->ImagePathName.MaximumLength]{};
	_tcscpy_s(procName, RtlUserProcessParameters->ImagePathName.Length, RtlUserProcessParameters->ImagePathName.Buffer);
	_tcscat_s(msg, procName);

	_tcscat_s(msg, L"\nCommand Line: ");
	const auto cmdLine = new TCHAR[RtlUserProcessParameters->CommandLine.MaximumLength]{};
	_tcscpy_s(cmdLine, RtlUserProcessParameters->CommandLine.Length, RtlUserProcessParameters->CommandLine.Buffer);
	_tcscat_s(msg, cmdLine);

	OutputDebugString(msg);

	RtlSecureZeroMemory(msg, MSG_LEN);

	TCHAR proc[0x400]{};
	swprintf_s(proc, L"\"%s\"", procName);
	swprintf_s(msg, L"DBG_NEW_PROC:%s %s", proc, cmdLine);
	OutputDebugString(msg);

	return 0; // ???
}

LONG WINAPI HookNtCreateThreadEx(
	_Out_ PHANDLE ThreadHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ HANDLE ProcessHandle,
	_In_ PVOID StartRoutine, // PUSER_THREAD_START_ROUTINE
	_In_opt_ PVOID Argument,
	_In_ ULONG CreateFlags, // THREAD_CREATE_FLAGS_*
	_In_opt_ ULONG_PTR ZeroBits,
	_In_opt_ SIZE_T StackSize,
	_In_opt_ SIZE_T MaximumStackSize,
	_In_opt_ PVOID AttributeList
)
{
	typedef LONG WINAPI xNtCreateThreadEx(
		_Out_ PHANDLE xThreadHandle,
		_In_ ACCESS_MASK xDesiredAccess,
		_In_opt_ POBJECT_ATTRIBUTES
		xObjectAttributes,
		_In_ HANDLE xProcessHandle,
		_In_ PVOID xStartRoutine,
		// PUSER_THREAD_START_ROUTINE
		_In_opt_ PVOID xArgument,
		_In_ ULONG xCreateFlags,
		// THREAD_CREATE_FLAGS_*
		_In_opt_ ULONG_PTR xZeroBits,
		_In_opt_ SIZE_T xStackSize,
		_In_opt_ SIZE_T xMaximumStackSize,
		_In_opt_ PVOID xAttributeList
	);
#define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER 0x00000004

	const auto exThread = reinterpret_cast<xNtCreateThreadEx*>(GetProcAddress(ntdllCopyModule, "NtCreateThreadEx"));

	if (CreateFlags == THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER)
	{
		OutputDebugString(
			L"[NtCreateThreadEx] The debuggee attempts to use THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER flag to hide from us. [FLAG REMOVED]\n\tref: https://goo.gl/4auRMZ \n");

		CreateFlags ^= THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER;
	}

	return exThread(ThreadHandle, DesiredAccess, ObjectAttributes, ProcessHandle, StartRoutine, Argument, CreateFlags,
	                ZeroBits, StackSize, MaximumStackSize, AttributeList);
}

LONG WINAPI HookNtSystemDebugControl(
	IN DEBUG_CONTROL_CODE Command,
	IN PVOID InputBuffer,
	IN ULONG InputBufferLength,
	OUT PVOID OutputBuffer,
	IN ULONG OutputBufferLength,
	OUT PULONG ReturnLength
)
{
	typedef LONG WINAPI
		xNtSystemDebugControl(
			IN DEBUG_CONTROL_CODE xCommand,
			IN PVOID xInputBuffer,
			IN ULONG xInputBufferLength,
			OUT PVOID xOutputBuffer,
			IN ULONG xOutputBufferLength,
			OUT PULONG xReturnLength
		);

	const auto ntSysDbgCtrl = reinterpret_cast<xNtSystemDebugControl*>(GetProcAddress(
			ntdllCopyModule, "NtSystemDebugControl")
	);

	if (Command != 0x1d)
	{
		OutputDebugString(
			L"[NtSystemDebugControl] The debuggee attempts to detect a debugger\n\tref: https://goo.gl/j4g5pV \n");
	}

	return ntSysDbgCtrl(Command, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength, ReturnLength);
}

BOOL HookNtYieldExecution()
{
	typedef BOOL xNtYieldExecutionAPI();
	const auto nYExec = reinterpret_cast<xNtYieldExecutionAPI*>(GetProcAddress(ntdllCopyModule, "NtYieldExecution"));

	OutputDebugStringA(
		"[NtYieldExecutionAPI] Unreliable method for detecting a debugger\n\tref: The \"Ultimate\" Anti-Debugging Reference: 7.D.xiii\n");

	return nYExec();
}

LONG WINAPI HookNtSetLdtEntries(ULONG Selector1, LDT_ENTRY Entry1, ULONG Selector2, LDT_ENTRY Entry2)
{
	typedef LONG WINAPI xNtSetLdtEntries(
		ULONG xSelector1,
		LDT_ENTRY xEntry1,
		ULONG xSelector2,
		LDT_ENTRY xEntry2
	);
	const auto ntSetLdt = reinterpret_cast<xNtSetLdtEntries*>(GetProcAddress(ntdllCopyModule, "NtSetLdtEntries"));

	OutputDebugString(
		L"[NtSetLdtEntries] The debugee uses NtSetLdtEntries API\n\tref: https://goo.gl/HaKCfH - 2.1.2\n");

	return ntSetLdt(Selector1, Entry1, Selector2, Entry2);
}

ULONG NTAPI HookNtQueryInformationThread(
	_In_ HANDLE ThreadHandle,
	_In_ THREADINFOCLASS ThreadInformationClass,
	_Out_writes_bytes_(ThreadInformationLength) PVOID ThreadInformation,
	_In_ ULONG ThreadInformationLength,
	_Out_opt_ PULONG ReturnLength
)
{
	typedef ULONG
		NTAPI
		NtQueryInformationThread(
			_In_ HANDLE xThreadHandle,
			_In_ THREADINFOCLASS
			xThreadInformationClass,
			_Out_writes_bytes_(xThreadInformationLength
			) PVOID
			xThreadInformation,
			_In_ ULONG
			xThreadInformationLength,
			_Out_opt_ PULONG
			xReturnLength
		);
	const auto ntQrInfThr = reinterpret_cast<NtQueryInformationThread*>(GetProcAddress(
		ntdllCopyModule, "NtQueryInformationThread"));


	if (ThreadInformationClass == ThreadHideFromDebugger)
	{
		OutputDebugString(
			L"[NtQueryInformationThread] The debugee attempts to detect anti-anti-debug tool\n\tref: https://goo.gl/k4P2a3 \n");
	}

	return ntQrInfThr(ThreadHandle, ThreadInformationClass, ThreadInformation, ThreadInformationLength, ReturnLength);
}

BOOL WINAPI HookIsDebuggerPresent()
{
	bool isDbg = FALSE;
	const auto returnAddress = reinterpret_cast<DWORD_PTR>(_ReturnAddress());
	if (returnAddress < reinterpret_cast<DWORD_PTR>(currentModuleInfo.lpBaseOfDll) || returnAddress > (reinterpret_cast<
		DWORD_PTR>(currentModuleInfo.lpBaseOfDll) + currentModuleInfo.SizeOfImage))
	{
		return isDbg;
	}
	auto msg = "[IsDebuggerPresent] The debugee attempts to detect a debugger\nReturn address: " +
		AddressToHexString(returnAddress) + "\tref : https ://goo.gl/cg7Fkm \n";

	OutputDebugStringA(msg.c_str());

	return isDbg;
}

BOOL WINAPI HookCheckRemoteDebuggerPresent(
	_In_ HANDLE hProcess,
	_Inout_ PBOOL pbDebuggerPresent
)
{
	OutputDebugString(
		L"[CheckRemoteDebuggerPresent] The debugee attempts to detect a debugger\n\tref: https://goo.gl/LrUdaG \n");

	typedef BOOL WINAPI xCheckRemoteDebuggerPresent(
		_In_ HANDLE xhProcess,
		_Inout_ PBOOL xpbDebuggerPresent
	);

	if (hProcess == HANDLE(-1))
		return FALSE; // ;)

	const auto chkRemDbg = reinterpret_cast<xCheckRemoteDebuggerPresent*>(GetProcAddress(
		kernelBaseCopyModule, "CheckRemoteDebuggerPresent"));
	return chkRemDbg(hProcess, pbDebuggerPresent);
}

ULONG WINAPI HookNtCreateDebugObject(
	OUT PHANDLE DebugObjectHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN ULONG Flags
)
{
	typedef ULONG WINAPI xNtCreateDebugObject(
		OUT PHANDLE xDebugObjectHandle,
		IN ACCESS_MASK xDesiredAccess,
		IN POBJECT_ATTRIBUTES xObjectAttributes,
		IN ULONG xFlags);
	const auto createDbgObj = reinterpret_cast<xNtCreateDebugObject*>(GetProcAddress(
		ntdllCopyModule, "NtCreateDebugObject"));

	ntCreateDbgObjectCalled = TRUE;

	return createDbgObj(DebugObjectHandle, DesiredAccess, ObjectAttributes, Flags);
}

ULONG WINAPI HookNtQueryObject(
	_In_ HANDLE Handle,
	_In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
	_Out_writes_bytes_opt_(ObjectInformationLength) PVOID
	ObjectInformation,
	_In_ ULONG ObjectInformationLength,
	_Out_opt_ PULONG ReturnLength
)
{
	typedef ULONG WINAPI xNtQueryObject(
		_In_ HANDLE xHandle,
		_In_ OBJECT_INFORMATION_CLASS
		xObjectInformationClass,
		_Out_writes_bytes_opt_(xObjectInformationLength)
		PVOID
		xObjectInformation,
		_In_ ULONG xObjectInformationLength,
		_Out_opt_ PULONG xReturnLength);

	const auto queryObject = reinterpret_cast<xNtQueryObject*>(GetProcAddress(ntdllCopyModule, "NtQueryObject"));
	const auto Status = queryObject(Handle, ObjectInformationClass, ObjectInformation, ObjectInformationLength,
	                                ReturnLength);

	if (ntCreateDbgObjectCalled && ObjectInformationClass == ObjectTypeInformation)
	{
		OutputDebugString(
			L"[NtQueryObject:ObjectTypeInformation] The debugee attempts to detect a debugger\n\tref: https://goo.gl/krE6JM \n");

		POBJECT_TYPE_INFORMATION(ObjectInformation)->TotalNumberOfObjects = 1; // 0 is suspicious

	}
	else if (ntCreateDbgObjectCalled && ObjectInformationClass == ObjectTypesInformation)
	{
		OutputDebugString(
			L"[NtQueryObject:ObjectTypesInformation] The debugee attempts to detect a debugger\n");

		POBJECT_ALL_INFORMATION(ObjectInformation)->NumberOfObjects = 1; // 0 is suspicious
	}

	return Status;
}

ULONG WINAPI HookRtlAdjustPrivilege(
	_In_ ULONG Privilege,
	_In_ BOOLEAN Enable,
	_In_ BOOLEAN Client,
	_Out_ PBOOLEAN WasEnabled
)
{
#define SE_DEBUG_PRIVILEGE (20L)

	typedef ULONG WINAPI xRtlAdjustPrivilege(
		_In_ ULONG xPrivilege,
		_In_ BOOLEAN xEnable,
		_In_ BOOLEAN xClient,
		_Out_ PBOOLEAN xWasEnabled
	);
	const auto adjustDbg = reinterpret_cast<xRtlAdjustPrivilege*>(GetProcAddress(ntdllCopyModule, "RtlAdjustPrivilege")
	);

	const auto Status = adjustDbg(Privilege, Enable, Client, WasEnabled);

	if (Privilege == SE_DEBUG_PRIVILEGE)
	{
		OutputDebugString(
			L"[RtlAdjustPrivilege] The debugee attempts to detect a debugger\n\tref: https://goo.gl/m46tQe \n");
		*WasEnabled = FALSE; // ;)
	}

	return Status;
}

ULONG WINAPI HookNtShutdownSystem(
	IN SHUTDOWN_ACTION /*Action*/)
{
	OutputDebugString(L"[NtShutdownSystem] The debugee attempts to shutdown/reboot system\n");

	return 0; // STATUS_SUCCESS ;)
}

LPTOP_LEVEL_EXCEPTION_FILTER WINAPI hookSetUnhandledExceptionFilter(
	_In_ LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
)
{
	typedef LPTOP_LEVEL_EXCEPTION_FILTER WINAPI xSetUnhandledExceptionFilter(
		_In_ LPTOP_LEVEL_EXCEPTION_FILTER xlpTopLevelExceptionFilter);
	const auto UnhandledEx = reinterpret_cast<xSetUnhandledExceptionFilter*>(GetProcAddress(
		kernelBaseCopyModule, "SetUnhandledExceptionFilter"));

	OutputDebugString(
		L"[SetUnhandledExceptionFilter] [!]Unreliable[!] The debugee attempts to detect a debugger\n\tref: The \"Ultimate\" Anti-Debugging Reference: D.xv\n");

	return UnhandledEx(lpTopLevelExceptionFilter);
}

ULONG WINAPI HookZwAllocateVirtualMemory(
	_In_ HANDLE ProcessHandle,
	_Inout_ PVOID* BaseAddress,
	_In_ ULONG_PTR ZeroBits,
	_Inout_ PSIZE_T RegionSize,
	_In_ ULONG AllocationType,
	_In_ ULONG Protect
)
{
	typedef ULONG WINAPI xZwAllocateVirtualMemory(
		_In_ HANDLE xProcessHandle,
		_Inout_ PVOID* xBaseAddress,
		_In_ ULONG_PTR xZeroBits,
		_Inout_ PSIZE_T xRegionSize,
		_In_ ULONG xAllocationType,
		_In_ ULONG xProtect
	);
	const auto allocVirt = reinterpret_cast<xZwAllocateVirtualMemory*>(GetProcAddress(
		ntdllCopyModule, "ZwAllocateVirtualMemory"));

	allocVirt(ProcessHandle, BaseAddress, ZeroBits, RegionSize, AllocationType, Protect);
	memWatchAddress = DWORD_PTR(*BaseAddress);

	if (AllocationType & MEM_WRITE_WATCH)
		memWatch = TRUE;

	return static_cast<ULONG>(memWatchAddress);
}

ULONG WINAPI HookZwGetWriteWatch(
	_In_ HANDLE ProcessHandle,
	_In_ ULONG Flags,
	_In_ PVOID BaseAddress,
	_In_ SIZE_T RegionSize,
	_Out_writes_(*EntriesInUserAddressArray) PVOID* UserAddressArray,
	_Inout_ PULONG_PTR EntriesInUserAddressArray,
	_Out_ PULONG Granularity
)
{
	typedef ULONG
		WINAPI
		xhookZwGetWriteWatch(
			_In_ HANDLE xProcessHandle,
			_In_ ULONG xFlags,
			_In_ PVOID xBaseAddress,
			_In_ SIZE_T xRegionSize,
			_Out_writes_(*xEntriesInUserAddressArray
			) PVOID*
			xUserAddressArray,
			_Inout_ PULONG_PTR
			xEntriesInUserAddressArray,
			_Out_ PULONG xGranularity
		);

	const auto getWatch = reinterpret_cast<xhookZwGetWriteWatch*>(GetProcAddress(ntdllCopyModule, "ZwGetWriteWatch"));

	if (BaseAddress && memWatch && DWORD_PTR(BaseAddress) == memWatchAddress)
		OutputDebugString(
			L"[WriteWatch] The debugee attempts to detect a debugger [GetWriteWatch]\n\tref: https://goo.gl/jVoMjH \n");

	return getWatch(ProcessHandle, Flags, BaseAddress, RegionSize, UserAddressArray, EntriesInUserAddressArray,
	                Granularity);
}

LONG WINAPI HookRegOpenKeyExInternalW( // not stable !!!!
	_In_ HKEY hKey,
	_In_opt_ LPCTSTR lpSubKey,
	_In_ DWORD ulOptions,
	_In_ REGSAM samDesired,
	_Out_ PHKEY phkResult
#ifndef _WIN64
	,
	DWORD Unknown // on 0x32 there is 6th parameter
#endif
)
{
	typedef LONG WINAPI RegOpenKeyExW(
		_In_ HKEY xhKey,
		_In_opt_ LPCTSTR xlpSubKey,
		_In_ DWORD xulOptions,
		_In_ REGSAM xsamDesired,
		_Out_ PHKEY xphkResult
	);

	const auto regOpenKeyExW = reinterpret_cast<RegOpenKeyExW*>(GetProcAddress(kernelBaseCopyModule, "RegOpenKeyExW"));
	// on 0x64 RegOpenKeyExInternalW crashes


#define OUT_STR_SIZE 0x100
	TCHAR outStr[OUT_STR_SIZE]{}; // ? 
	TCHAR keyHandle[MAX_PATH]{};
	if (hKey)
		switch (reinterpret_cast<ULONG_PTR>(hKey))
		{
		case 0x80000000:
			memcpy_s(keyHandle, MAX_PATH, L"HKEY_CLASSES_ROOT", _countof(L"HKEY_CLASSES_ROOT") * sizeof(TCHAR));
			break;
		case 0x80000001:
			memcpy_s(keyHandle, MAX_PATH, L"HKEY_CURRENT_USER", _countof(L"HKEY_CURRENT_USER") * sizeof(TCHAR));
			break;
		case 0x80000002:
			memcpy_s(keyHandle, MAX_PATH, L"HKEY_LOCAL_MACHINE", _countof(L"HKEY_LOCAL_MACHINE") * sizeof(TCHAR));
			break;
		case 0x80000003:
			memcpy_s(keyHandle, MAX_PATH, L"HKEY_USERS", _countof(L"HKEY_USERS") * sizeof(TCHAR));
			break;
		default:
			break;
		}

	auto keyChecks = jsObject["Registry"]["KeyChecks"];
	TCHAR* normalPath = nullptr;

	if (lpSubKey)
		normalPath = NormalizeRegPath(lpSubKey);
	for (auto& keyArray : keyChecks)
	{
		for (auto& key : keyArray)
		{
			auto strKey = key.get<std::string>();
			std::wstring wstrKey(strKey.begin(), strKey.end());

			if (normalPath && StrStrI(normalPath, wstrKey.c_str()))
			{
				StringCchPrintf(outStr, OUT_STR_SIZE,
				                L"[RegOpenKeyExInternalW] The debugee checks against VM (Vmware, VirtualBox, etc) related registry keys: %s\\%s\n\tref: https://github.com/LordNoteworthy/al-khaser \n",
				                keyHandle, normalPath);

				OutputDebugString(outStr);

				RtlSecureZeroMemory(outStr, OUT_STR_SIZE);

				return ERROR_FILE_NOT_FOUND;
			}
		}
	}

	if (normalPath)
		delete normalPath;

	return regOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, phkResult);
}

LONG WINAPI HookRegQueryValueExW(
	_In_ HKEY hKey,
	_In_opt_ LPCTSTR lpValueName,
	_Reserved_ LPDWORD lpReserved,
	_Out_opt_ LPDWORD lpType,
	_Out_opt_ LPBYTE lpData,
	_Inout_opt_ LPDWORD lpcbData
)
{
	typedef LONG WINAPI xRegQueryValueEx(
		_In_ HKEY xhKey,
		_In_opt_ LPCTSTR xlpValueName,
		_Reserved_ LPDWORD xlpReserved,
		_Out_opt_ LPDWORD xlpType,
		_Out_opt_ LPBYTE xlpData,
		_Inout_opt_ LPDWORD xlpcbData
	);
	const auto regQueryValueExW = reinterpret_cast<xRegQueryValueEx*>(GetProcAddress(
			kernelBaseCopyModule, "RegQueryValueExW")
	);

	const auto retQueryValue = regQueryValueExW(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);

#define OUT_STR_SIZE 0x100
	TCHAR outStr[OUT_STR_SIZE]{}; // ? 

	auto values = jsObject["Registry"]["ValueChecks"];

	for (auto& key : values)
	{
		auto strKey = key.get<std::string>();
		std::wstring wstrKey(strKey.begin(), strKey.end());

		if (lpValueName && StrStrI(lpValueName, wstrKey.c_str()))
		{
			StringCchPrintf(outStr, OUT_STR_SIZE,
			                L"[RegQueryValueExW] The debugee checks following suspicious registry key value - %s:%s\n\tref: https://github.com/LordNoteworthy/al-khaser \n",
			                lpValueName, lpData);
			OutputDebugString(outStr);

			RtlSecureZeroMemory(outStr, OUT_STR_SIZE);
			break;
		}
	}

	return retQueryValue;
}


BOOL WINAPI HookGetThreadContext(
	_In_ HANDLE hThread,
	_Inout_ LPCONTEXT lpContext
)
{
	typedef BOOL WINAPI xGetThreadContext(
		_In_ HANDLE xhThread,
		_Inout_ LPCONTEXT xlpContext
	);

	const auto NtGetThreadContext = reinterpret_cast<xGetThreadContext*>(GetProcAddress(
			ntdllCopyModule, "ZwGetContextThread")
	);

	const auto ret = NtGetThreadContext(hThread, lpContext);

	lpContext->Dr0 = 0;
	lpContext->Dr1 = 0;
	lpContext->Dr2 = 0;
	lpContext->Dr3 = 0;

	lpContext->Dr6 = 0;
	lpContext->Dr7 = 0;

	return ret;
}

```

`asho/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// asho.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`asho/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
// Windows Header Files:
#include <windows.h>

#include <cstdio>
#include <tchar.h>

// TODO(MACHINE_32): reference additional headers your program requires here

#include <Psapi.h>
#include <Shlwapi.h>
#include <TlHelp32.h>
#include <vector>
#include <memory>
#include <ctime>
#include <Strsafe.h>
#include <intrin.h>
#include <string>

#pragma comment(lib, "Shlwapi.lib")

```

`asho/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`asho/utils.cpp`:

```cpp
#include "stdafx.h"

std::string AddressToHexString(const DWORD_PTR address)
{
	char hexAddress[2 + 2 * sizeof(DWORD_PTR) + 1]{};
#if defined(_WIN64)
	sprintf_s(hexAddress, "0x%I64x", address);
#else
	sprintf_s(hexAddress, "0x%I32x", address);
#endif
	std::string str{hexAddress};

	return str;
}

std::wstring GenRandStr(const size_t size) // just enough randomness
{
	srand(static_cast<unsigned int>(time(nullptr)));
	static const TCHAR ALPHABET[] =
		L"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		L"abcdefghijklmnopqrstuvwxyz";
	std::wstring randString(size, '\x0');
	for (auto& i : randString)
	{
		i = ALPHABET[rand() / (RAND_MAX / (_tcslen(ALPHABET) - 1) + 1)];
	}

	return randString;
}

TCHAR* NormalizeRegPath(const LPCTSTR regPath)
{
	const auto pathSize = _tcsclen(regPath);
	const auto normalPath = new TCHAR[pathSize + 1]{};
	for (size_t i = 0; i < pathSize; i++)
	{
		if (regPath[i] == *(L"/")) {
			normalPath[i] = *(L"\\");
		} else {
			normalPath[i] = regPath[i];
}
	}
	return normalPath;
}

```

`asho/utils.h`:

```h
#pragma once

#include "stdafx.h"

#include <nlohmann/json.hpp>

#define MSG_LEN 0x500

BOOL ntCreateDbgObjectCalled = FALSE;
DWORD_PTR memWatchAddress{};
BOOL memWatch = FALSE;

HMODULE ntdllCopyModule = nullptr;
HMODULE kernelBaseCopyModule = nullptr;
MODULEINFO currentModuleInfo{};
nlohmann::json jsObject{};

std::string AddressToHexString(DWORD_PTR address);
std::wstring GenRandStr(size_t size);
TCHAR* NormalizeRegPath(const LPCTSTR regPath);

```

`makin.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.27130.2003
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "makin", "makin\makin.vcxproj", "{92E1A34F-910D-47EB-A037-3F74D7509EFB}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "asho", "asho\asho.vcxproj", "{B9B4C3F7-6805-4D14-B0AB-1E18D868E0CC}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{92E1A34F-910D-47EB-A037-3F74D7509EFB}.Debug|x64.ActiveCfg = Debug|x64
		{92E1A34F-910D-47EB-A037-3F74D7509EFB}.Debug|x64.Build.0 = Debug|x64
		{92E1A34F-910D-47EB-A037-3F74D7509EFB}.Debug|x86.ActiveCfg = Debug|Win32
		{92E1A34F-910D-47EB-A037-3F74D7509EFB}.Debug|x86.Build.0 = Debug|Win32
		{92E1A34F-910D-47EB-A037-3F74D7509EFB}.Release|x64.ActiveCfg = Release|x64
		{92E1A34F-910D-47EB-A037-3F74D7509EFB}.Release|x64.Build.0 = Release|x64
		{92E1A34F-910D-47EB-A037-3F74D7509EFB}.Release|x86.ActiveCfg = Release|Win32
		{92E1A34F-910D-47EB-A037-3F74D7509EFB}.Release|x86.Build.0 = Release|Win32
		{B9B4C3F7-6805-4D14-B0AB-1E18D868E0CC}.Debug|x64.ActiveCfg = Debug|x64
		{B9B4C3F7-6805-4D14-B0AB-1E18D868E0CC}.Debug|x64.Build.0 = Debug|x64
		{B9B4C3F7-6805-4D14-B0AB-1E18D868E0CC}.Debug|x86.ActiveCfg = Debug|Win32
		{B9B4C3F7-6805-4D14-B0AB-1E18D868E0CC}.Debug|x86.Build.0 = Debug|Win32
		{B9B4C3F7-6805-4D14-B0AB-1E18D868E0CC}.Release|x64.ActiveCfg = Release|x64
		{B9B4C3F7-6805-4D14-B0AB-1E18D868E0CC}.Release|x64.Build.0 = Release|x64
		{B9B4C3F7-6805-4D14-B0AB-1E18D868E0CC}.Release|x86.ActiveCfg = Release|Win32
		{B9B4C3F7-6805-4D14-B0AB-1E18D868E0CC}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {EDB86005-78FF-4956-85D9-9B6BA272BA7B}
	EndGlobalSection
EndGlobal

```

`makin/checks.json`:

```json
{
  "title": "VM checks",

  "Registry": {
    "KeyChecks": {
      "VMware": [
        "vmware"
      ],

      "VirtualBox": [
        "virtualbox",
        "vbox"
      ],

      "misc": [
        "wine",
        "SOFTWARE\\Microsoft\\Virtual Machine\\Guest\\Parameters"
      ]
    },

    "ValueChecks": [
      "SystemManufacturer",
      "SystemProductName",
      "Identifier",
      "SystemBiosVersion",
      "SystemBiosDate",
      "VideoBiosVersion",
      "VideoBiosVersion"
    ]

  },

  "FileSystem": {
    "Files": [
      "virtualbox",
      "vmware",
      "vmbox",
      "vmmouse.sys",
      "vmhgfs.sys",
      "vm3dmp.sys",
      "vmci.sys",
      "vmhgfs.sys",
      "vmmemctl.sys",
      "vmmouse.sys",
      "vmrawdsk.sys",
      "vmusbmouse.sys"
    ]
  },

  "VirtualDevices": [
    "PROCEXP152",
    "hgfs",
    "vmci"
  ],

  "Processes": [
    "csrss.exe",
    "vmbox",
    "vmtoolsd.exe",
    "vmwaretray.exe",
    "vmwareuser.exe",
    "VGAuthService.exe",
    "vmacthlp.exe",
    "vmsrvc.exe",
    "vmusrvc.exe",
    "prl_cc.exe",
    "prl_tools.exe",
    "xenservice.exe",
    "qemu-ga.exe"
  ]
}
```

`makin/makin.cpp`:

```cpp
//
// author: Lasha Khasaia
// contact: @_qaz_qaz
// license: MIT License
//

#include "stdafx.h"
#include <Psapi.h>

enum DrReg
{
	Dr0,
	Dr1,
	Dr2,
	Dr3
};

typedef NTSTATUS (WINAPI *pNtQueryInformationProcess)(HANDLE, PROCESSINFOCLASS, PVOID, ULONG, PULONG);

std::vector<std::string> loadDll{};

std::vector<std::string> hookFunctions{};

inline void SetBits(DWORD_PTR& dw, const DWORD_PTR lowBit, const DWORD_PTR bits, const DWORD_PTR newValue)
{
	const auto mask = (1 << bits) - 1;

	dw = (dw & ~(mask << lowBit)) | (newValue << lowBit);
}

VOID ProcessOutputString(const PROCESS_INFORMATION pi, const OUTPUT_DEBUG_STRING_INFO out_info)
{
	std::unique_ptr<CHAR[]> pMsg{new CHAR[out_info.nDebugStringLength * sizeof(CHAR)]};

	ReadProcessMemory(pi.hProcess, out_info.lpDebugStringData, pMsg.get(), out_info.nDebugStringLength, nullptr);

	//const auto isUnicode = IsTextUnicode(pMsg.get(), out_info.nDebugStringLength, nullptr);

	//if (!isUnicode)
	//	printf("[OutputDebugString] msg: %s\n\n", reinterpret_cast<char*>(pMsg.get())); // as ASCII


	auto cmdSubStr = strstr(pMsg.get(), "DBG_NEW_PROC:");
	if (cmdSubStr != nullptr)
	{
		cmdSubStr += 13;
		printf_s("Monitor new process in a new console...\n\n");

		CHAR curExe[0x1000]{};
		GetModuleFileNameA(nullptr, curExe, 0x1000);

		sprintf_s(curExe, "%s %s", curExe, cmdSubStr);

		STARTUPINFOA nsi{sizeof(STARTUPINFOA)};
		PROCESS_INFORMATION npi{};

		CreateProcessA(nullptr, curExe, nullptr, nullptr, FALSE, CREATE_NEW_CONSOLE, nullptr, nullptr, &nsi, &npi);

		CloseHandle(npi.hProcess);
		CloseHandle(npi.hThread);

		return;
	}

	if (pMsg.get()[0] != '[')
	{
		printf_s("[OutputDebugString] msg: %s\n\n", pMsg.get()); // raw message from the sample
		return;
	}
	if (strlen(pMsg.get()) > 3 && (pMsg.get()[0] == '[' && pMsg.get()[1] == '_' && pMsg.get()[2] == ']'))
		// [_]
	{
		for (const auto& i : loadDll)
		{
			CHAR tmp[MAX_PATH + 2]{};
			strcpy_s(tmp, MAX_PATH + 2, pMsg.get() + 3);
			const std::string tmpStr(tmp);
			if (tmpStr == i) // #SOURCE - The "Ultimate" Anti-Debugging Reference: 7.B.iv
			{
				hookFunctions.emplace_back("LdrLoadDll");
				printf(
					"[LdrLoadDll] The debuggee attempts to use LdrLoadDll/NtCreateFile trick: %s\n\tref: The \"Ultimate\" Anti-Debugging Reference: 7.B.iv\n\n",
					tmpStr.data());
			}
		}
		return;
	}

	printf("%s\n", pMsg.get()); // from us, starts with [ symbol

	// save functions for IDA script
	std::string tmpStr(pMsg.get());

	// ntdll
	if (tmpStr.find("NtClose") != std::string::npos)
	{
		hookFunctions.emplace_back("NtClose");
	}
	else if (tmpStr.find("NtOpenProcess") != std::string::npos)
	{
		hookFunctions.emplace_back("NtOpenProcess");
	}
	else if (tmpStr.find("NtCreateFile") != std::string::npos)
	{
		hookFunctions.emplace_back("NtCreateFile");
	}
	else if (tmpStr.find("NtSetDebugFilterState") != std::string::npos)
	{
		hookFunctions.emplace_back("NtSetDebugFilterState");
	}
	else if (tmpStr.find("NtQueryInformationProcess") != std::string::npos)
	{
		hookFunctions.emplace_back("NtQueryInformationProcess");
	}
	else if (tmpStr.find("NtQuerySystemInformation") != std::string::npos)
	{
		hookFunctions.emplace_back("NtQuerySystemInformation");
	}
	else if (tmpStr.find("NtSetInformationThread") != std::string::npos)
	{
		hookFunctions.emplace_back("NtSetInformationThread");
	}
	else if (tmpStr.find("NtCreateUserProcess") != std::string::npos)
	{
		hookFunctions.emplace_back("NtCreateUserProcess");
	}
	else if (tmpStr.find("NtCreateThreadEx") != std::string::npos)
	{
		hookFunctions.emplace_back("NtCreateThreadEx");
	}
	else if (tmpStr.find("NtSystemDebugControl") != std::string::npos)
	{
		hookFunctions.emplace_back("NtSystemDebugControl");
	}
	else if (tmpStr.find("NtYieldExecution") != std::string::npos)
	{
		hookFunctions.emplace_back("NtYieldExecution");
	}
	else if (tmpStr.find("NtSetLdtEntries") != std::string::npos)
	{
		hookFunctions.emplace_back("NtSetLdtEntries");
	}
	else if (tmpStr.find("NtQueryInformationThread") != std::string::npos)
	{
		hookFunctions.emplace_back("NtQueryInformationThread");
	}
	else if (tmpStr.find("NtCreateDebugObject") != std::string::npos)
	{
		hookFunctions.emplace_back("NtCreateDebugObject");
	}
	else if (tmpStr.find("NtQueryObject") != std::string::npos)
	{
		hookFunctions.emplace_back("NtQueryObject");
	}
	else if (tmpStr.find("RtlAdjustPrivilege") != std::string::npos)
	{
		hookFunctions.emplace_back("RtlAdjustPrivilege");
	}
	else if (tmpStr.find("NtShutdownSystem") != std::string::npos)
	{
		hookFunctions.emplace_back("NtShutdownSystem");
	}
	else if (tmpStr.find("ZwAllocateVirtualMemory") != std::string::npos)
	{
		hookFunctions.emplace_back("ZwAllocateVirtualMemory");
	}
	else if (tmpStr.find("ZwGetWriteWatch") != std::string::npos)
	{
		hookFunctions.emplace_back("ZwGetWriteWatch");

		// kernelbase
	}
	else if (tmpStr.find("IsDebuggerPresent") != std::string::npos)
	{
		hookFunctions.emplace_back("IsDebuggerPresent");
	}
	else if (tmpStr.find("CheckRemoteDebuggerPresent") != std::string::npos)
	{
		hookFunctions.emplace_back("CheckRemoteDebuggerPresent");
	}
	else if (tmpStr.find("SetUnhandledExceptionFilter") != std::string::npos)
	{
		hookFunctions.emplace_back("SetUnhandledExceptionFilter");
	}
	else if (tmpStr.find("RegOpenKeyExInternalW") != std::string::npos)
	{
		hookFunctions.emplace_back("RegOpenKeyExInternalW");
	}
	else if (tmpStr.find("RegQueryValueExW") != std::string::npos)
	{
		hookFunctions.emplace_back("RegQueryValueExW");
	}
}

std::wstring GenRandStr(const size_t size) // just enough randomness
{
	srand(static_cast<unsigned int>(time(nullptr)));
	static const TCHAR ALPHABET[] =
		L"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		L"abcdefghijklmnopqrstuvwxyz";
	std::wstring randString(size, '\x0');
	for (auto& i : randString)
	{
		i = ALPHABET[rand() / (RAND_MAX / (_tcslen(ALPHABET) - 1) + 1)];
	}

	return randString;
}

void SetHardwareBreakpoint(HANDLE tHandle, CONTEXT& cxt, const DWORD_PTR addr, size_t size, DrReg dbgReg)
{
	cxt.ContextFlags = CONTEXT_DEBUG_REGISTERS;

	GetThreadContext(tHandle, &cxt);

	const DWORD_PTR m_index = dbgReg; // Dr_
	switch (dbgReg)
	{
	case Dr0:
		cxt.Dr0 = addr;
		break;
	case Dr1:
		cxt.Dr1 = addr;
		break;
	case Dr2:
		cxt.Dr2 = addr;
		break;
	case Dr3:
		cxt.Dr3 = addr;
		break;
	}

	SetBits(cxt.Dr7, 16 + (m_index * 4), 2, 3); // read/write
	SetBits(cxt.Dr7, 18 + (m_index * 4), 2, size); // size
	SetBits(cxt.Dr7, m_index * 2, 1, 1);

	SetThreadContext(tHandle, &cxt);
}

int _tmain()
{

	// welcome 
	const TCHAR welcome[] = L"makin --- Copyright (c) 2019 Lasha Khasaia\n"
		L"https://www.secrary.com - @_qaz_qaz\n"
		L"----------------------------------------------------\n\n";
	wprintf(L"%s\n", welcome);

	STARTUPINFO si{};
	si.cb = sizeof(si);
	PROCESS_INFORMATION pi{};
	DWORD err;
	DEBUG_EVENT d_event{};
	auto done = FALSE;
	TCHAR dll_path[MAX_PATH + 2]{};
	TCHAR proc_path[MAX_PATH + 2]{};
	auto first_its_me = FALSE;
	CHAR filePath[MAX_PATH + 2]{};
	CONTEXT cxt{};
	//PVOID ex_addr = nullptr;
	HANDLE tHandle{};
	DWORD_PTR expAddress{};

	int nArgs{};
	const auto pArgv = CommandLineToArgvW(GetCommandLine(), &nArgs);

	if (nArgs < 2)
	{
		printf("Usage: \n./makin.exe \"/path/to/sample\"\n");
		return 1;
	}

	TCHAR cmdLine[0x1000]{};
	for (auto i = 2; i < nArgs; ++i)
	{
		_tcscat_s(cmdLine, pArgv[i]);
		_tcscat_s(cmdLine, L" ");
	}

	_tcsncpy_s(proc_path, pArgv[1], MAX_PATH + 2);

	if (!PathFileExists(proc_path))
	{
		err = GetLastError();
		wprintf(L"[!] %s is not a valid file\n", proc_path);
		return err;
	}


	const auto hFile = CreateFile(proc_path, GENERIC_READ, FILE_SHARE_READ, nullptr, OPEN_EXISTING, 0, nullptr);

	if (hFile == INVALID_HANDLE_VALUE)
	{
		err = GetLastError();
		printf("CreateFile error: %lu\n", err);
		return err;
	}

	LARGE_INTEGER size{};
	GetFileSizeEx(hFile, &size);

	SYSTEM_INFO sysInfo{};
	GetSystemInfo(&sysInfo);

	const auto hMapFile = CreateFileMapping(hFile,
	                                        nullptr,
	                                        PAGE_READONLY,
	                                        size.HighPart,
	                                        size.LowPart,
	                                        nullptr);

	if (hMapFile == nullptr)
	{
		err = GetLastError();
		printf("CreateFileMapping is NULL: %lu", err);
		return err;
	}

	// Map just one page
	auto lpMapAddress = MapViewOfFile(hMapFile,
	                                  FILE_MAP_READ,
	                                  0,
	                                  0,
	                                  sysInfo.dwPageSize); // one page size is more than we need for now

	if (lpMapAddress == nullptr)
	{
		err = GetLastError();
		printf("MapViewOfFIle is NULL: %lu\n", err);
		return err;
	}
	// IMAGE_DOS_HEADER->e_lfanew
	const auto e_lfanew = *reinterpret_cast<DWORD*>(static_cast<byte*>(lpMapAddress) + sizeof(IMAGE_DOS_HEADER) - sizeof
		(
			DWORD));
	UnmapViewOfFile(lpMapAddress);


	const auto ntMapAddrLow = (e_lfanew / sysInfo.dwAllocationGranularity) * sysInfo.dwAllocationGranularity;
	lpMapAddress = MapViewOfFile(hMapFile,
	                             FILE_MAP_READ,
	                             0,
	                             ntMapAddrLow,
	                             sysInfo.dwPageSize);

	if (lpMapAddress == nullptr)
	{
		err = GetLastError();
		printf("MapViewOfFIle is NULL: %lu\n", err);
		return err;
	}

	auto ntHeaderAddr = lpMapAddress;
	if (ntMapAddrLow != e_lfanew)
	{
		ntHeaderAddr = static_cast<byte*>(ntHeaderAddr) + e_lfanew;
	}

	if (PIMAGE_NT_HEADERS(ntHeaderAddr)->OptionalHeader.DataDirectory[9].VirtualAddress != 0u)
	{
		printf(
			"[TLS] The executable contains TLS callback(s)\nI can not hook code executed by TLS callbacks\nPlease, abort execution and check it manually\n[c]ontinue / [A]bort: \n\n");
		const auto ic = getchar();
		if (ic != 'c')
		{
			ExitProcess(0);
		}
	}

	const DWORD_PTR sizeOfImage = PIMAGE_NT_HEADERS(ntHeaderAddr)->OptionalHeader.SizeOfImage;

	UnmapViewOfFile(lpMapAddress);
	CloseHandle(hMapFile);
	CloseHandle(hFile);

	wprintf(L"PROCESS NAME: %s\nCOMMAND LINE: %s\n\n", proc_path, cmdLine);

	if (!CreateProcess(proc_path, cmdLine, nullptr, nullptr, FALSE,
	                   DEBUG_ONLY_THIS_PROCESS | CREATE_SUSPENDED | DETACHED_PROCESS, nullptr, nullptr, &si, &pi))
	{
		err = GetLastError();
		printf_s("[!] CreateProces failed: %lu\n", err);
		return err;
	}

	// Detect memory accesses

	const auto ntQueryInformationProcess = pNtQueryInformationProcess(
		GetProcAddress(GetModuleHandle(L"ntdll"), "NtQueryInformationProcess"));

	PROCESS_BASIC_INFORMATION pbi{};
	ntQueryInformationProcess(pi.hProcess, ProcessBasicInformation, &pbi, sizeof(PROCESS_BASIC_INFORMATION), nullptr);

	auto peb = DWORD_PTR(pbi.PebBaseAddress);

	const auto pBeingDebugged = DWORD_PTR(reinterpret_cast<byte*>(peb) + 0x2); // PEB->BeingDebugged

#ifndef _WIN64
	peb -= 0x1000; // 32-bit PEB
#endif

	const auto pImageBaseAddress = DWORD_PTR(reinterpret_cast<byte*>(peb) + 0x10);
	// 0x010 ImageBaseAddress : Ptr64 Void

	DWORD_PTR imageBaseAddress{};
	SIZE_T ret{};
	if (pImageBaseAddress != 0u)
	{
		ReadProcessMemory(pi.hProcess, PVOID(pImageBaseAddress), &imageBaseAddress, sizeof(DWORD_PTR), &ret);
	}

	SetHardwareBreakpoint(pi.hThread, cxt, pBeingDebugged, 1, Dr0);

	// GlobalFlags
	DWORD_PTR pNtGlobalFlag{};
#ifdef _WIN64
	pNtGlobalFlag = DWORD_PTR(reinterpret_cast<byte*>(peb) + 0xBC);
#else
	pNtGlobalFlag = DWORD_PTR(reinterpret_cast<byte*>(peb) + 0x68);
	pNtGlobalFlag += 0x1000; // 32-bit PEB
#endif

	SetHardwareBreakpoint(pi.hThread, cxt, pNtGlobalFlag, 2, Dr1);

	// ref: https://github.com/LordNoteworthy/al-khaser/blob/master/al-khaser/Anti%20Debug/SharedUserData_KernelDebugger.cpp
	// KUSER_SHARED_DATA: https://www.geoffchappell.com/studies/windows/km/ntoskrnl/structs/kuser_shared_data.htm
	const ULONG_PTR userSharedData = 0x7FFE0000;
	const auto kdDebuggerEnabledByte = userSharedData + 0x2D4; // UserSharedData->KdDebuggerEnabled

	SetHardwareBreakpoint(pi.hThread, cxt, kdDebuggerEnabledByte, sizeof(BOOLEAN), Dr2);


	// Create Job object
	// UPDATE: dbg child proc.
	//JOBOBJECT_EXTENDED_LIMIT_INFORMATION jbli{0};
	//JOBOBJECT_BASIC_UI_RESTRICTIONS jbur;
	//const auto hJob = CreateJobObject(nullptr, L"makinAKAasho");
	//if (hJob)
	//{
	//   jbli.BasicLimitInformation.ActiveProcessLimit = 1; // Blocked new process creation
	//   jbli.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_ACTIVE_PROCESS | JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;

	//   jbur.UIRestrictionsClass = JOB_OBJECT_UILIMIT_DESKTOP | JOB_OBJECT_UILIMIT_EXITWINDOWS;
	//   /*| JOB_OBJECT_UILIMIT_HANDLES*/ // uncomment if you want

	//   SetInformationJobObject(hJob, JobObjectExtendedLimitInformation, &jbli, sizeof(jbli));

	//   SetInformationJobObject(hJob, JobObjectBasicUIRestrictions, &jbur, sizeof(jbur));

	//   if (!AssignProcessToJobObject(hJob, pi.hProcess))
	//   {
	//      printf("[!] AssignProcessToJobObject failed: %ul\n", GetLastError());
	//   }
	//}

#ifdef _DEBUG
	SetCurrentDirectory(L"../Debug");
#ifdef _WIN64
	SetCurrentDirectory(L"../x64/Debug");
#endif
#endif

	GetFullPathName(L"./asho.dll", MAX_PATH + 2, dll_path, nullptr);
	if (!PathFileExists(dll_path))
	{
		err = GetLastError();
		wprintf(L"[!] %s is not a valid file\n", dll_path);

		return err;
	}

	// generate random name for asho.dll ;)
	TCHAR ashoTmpDir[MAX_PATH + 2]{};
	GetTempPath(MAX_PATH + 2, ashoTmpDir);
	auto ashoPath = std::wstring{ashoTmpDir} + GenRandStr(6) + L".dll";
	const auto cStatus = CopyFile(dll_path, ashoPath.c_str(), FALSE);
	if (cStatus == 0)
	{
		err = GetLastError();
		wprintf(L"[!] CopyFile failed: %lu\n", err);

		return err;
	}
	if (!PathFileExists(ashoPath.c_str()))
	{
		err = GetLastError();
		wprintf(L"[!] %s is not a valid file\n", ashoPath.c_str());

		return err;
	}

	const auto p_alloc = VirtualAllocEx(pi.hProcess, nullptr, MAX_PATH + 2, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (p_alloc == nullptr)
	{
		err = GetLastError();
		printf("[!] Allocation failed: %lu\n", err);
		return err;
	}
	if (WriteProcessMemory(pi.hProcess, p_alloc, ashoPath.c_str(), MAX_PATH + 2, nullptr) == 0)
	{
		err = GetLastError();
		printf("WriteProcessMemory failed: %lu\n", err);
		return err;
	}
	const auto h_module = GetModuleHandle(L"kernel32");
	if (h_module == nullptr)
	{
		err = GetLastError();
		printf("GetmModuleHandle failed: %lu\n", err);
		return err;
	}
	const auto loadLibraryAddress = GetProcAddress(h_module, "LoadLibraryW");

	if (loadLibraryAddress == nullptr)
	{
		err = GetLastError();
		printf("GetProcAddress failed: %lu\n", err);
		return err;
	}

	const auto qStatus = QueueUserAPC(PAPCFUNC(loadLibraryAddress), pi.hThread, ULONG_PTR(p_alloc));
	if (qStatus == 0u)
	{
		err = GetLastError();
		printf("QueueUserAPC failed: %lu\n", err);
		return err;
	}

	ResumeThread(pi.hThread);

	while (done == 0)
	{
		auto contStatus = DBG_CONTINUE;
		if (WaitForDebugEvent(&d_event, INFINITE) != 0)
		{
			switch (d_event.dwDebugEventCode)
			{
			case OUTPUT_DEBUG_STRING_EVENT:
				ProcessOutputString(pi, d_event.u.DebugString);

				contStatus = DBG_CONTINUE;
				break;
			case LOAD_DLL_DEBUG_EVENT:
				// we get load dll as file handle 
				if (GetFinalPathNameByHandleA(d_event.u.LoadDll.hFile, filePath, MAX_PATH + 2, 0) != 0u)
				{
					const std::string tmpStr(filePath + 4);
					loadDll.emplace_back(tmpStr);
				}
				// to avoid LdrloadDll / NtCreateFile trick ;)
				CloseHandle(d_event.u.LoadDll.hFile);
				break;

			case EXCEPTION_DEBUG_EVENT:
				contStatus = DBG_EXCEPTION_NOT_HANDLED;
				if (d_event.u.Exception.dwFirstChance == 0u)
				{
					break;
				}
				switch (d_event.u.Exception.ExceptionRecord.ExceptionCode)
				{
				case EXCEPTION_ACCESS_VIOLATION:
					printf("[EXCEPTION] EXCEPTION_ACCESS_VIOLATION\n\n");
					system("pause");
					//cont_status = DBG_EXCEPTION_HANDLED;
					break;

				case EXCEPTION_BREAKPOINT:

					if (first_its_me == 0)
					{
						first_its_me = TRUE;
						break;
					}
					printf("[EXCEPTION] EXCEPTION_BREAKPOINT\n\n");
					// cont_status = DBG_EXCEPTION_HANDLED;

					break;

					/*case EXCEPTION_DATATYPE_MISALIGNMENT:
					printf("[EXCEPTION] EXCEPTION_DATATYPE_MISALIGNMENT\n");
	 
					break;*/

				case EXCEPTION_SINGLE_STEP:

					expAddress = DWORD_PTR(d_event.u.Exception.ExceptionRecord.ExceptionAddress);

					// HANDLE hardware accesses

					tHandle = OpenThread(GENERIC_ALL, FALSE, d_event.dwThreadId);
					if (tHandle == nullptr)
					{
						break;
					}
					cxt.ContextFlags = CONTEXT_ALL;
					GetThreadContext(tHandle, &cxt);

					if ((cxt.Dr6 & 0b1111) != 0u)
					{
						//  There are HBs
						contStatus = DBG_EXCEPTION_HANDLED;
					}
					else
					{
						printf("[EXCEPTION] EXCEPTION_SINGLE_STEP\n");
					}

					if (expAddress > imageBaseAddress && expAddress < imageBaseAddress + sizeOfImage)
					{
						if ((cxt.Dr6 & 0x1) != 0u)
						{
							printf(
								"[PEB->BeingDebugged] The debuggee attempts to detect a debugger.\nBase address of the image: 0x%p\nException address: 0x%p\nRVA: 0x%p\n\n",
								PVOID(imageBaseAddress), PVOID(expAddress), PVOID(expAddress - imageBaseAddress));
						}
						else if ((cxt.Dr6 & 0b10) != 0u)
						{
							printf(
								"[PEB->NtGlobalFlag] The debuggee attempts to detect a debugger.\nBase address of the image: 0x%p\nException address: 0x%p\nRVA: 0x%p\n\n",
								PVOID(imageBaseAddress), PVOID(expAddress), PVOID(expAddress - imageBaseAddress));
						}
						else if ((cxt.Dr6 & 0b100) != 0u)
						{
							printf(
								"[UserSharedData->KdDebuggerEnabled] The debuggee attempts to detect a debugger.\nBase address of the image: 0x%p\nException address: 0x%p\nRVA: 0x%p\n\n",
								PVOID(imageBaseAddress), PVOID(expAddress), PVOID(expAddress - imageBaseAddress));
						}
						else if ((cxt.Dr6 & 0b1000) != 0u)
						{
							printf("DR3\n"); // Not implemented yet
						}
#ifdef _WIN64
						cxt.Rax = 0; // maybe works on most cases
#else
						cxt.Eax = 0;
#endif
						SetThreadContext(tHandle, &cxt);

					}

					CloseHandle(tHandle);
					break;

				case DBG_CONTROL_C:
					printf("[EXCEPTION] DBG_CONTROL_C\n\n");

					break;

				case EXCEPTION_GUARD_PAGE:
					printf("[EXCEPTION] EXCEPTION_GUARD_PAGE\n\n");
					// cont_status = DBG_EXCEPTION_HANDLED;
					break;

				default:
					// Handle other exceptions. 
					break;
				}
				break;
			case EXIT_PROCESS_DEBUG_EVENT:
				done = TRUE;
				printf("[EOF] ========================================================================\n");
				system("pause");
				break;

			default:
				break;
			}

			ContinueDebugEvent(d_event.dwProcessId, d_event.dwThreadId, contStatus);
		}
	}

	CloseHandle(pi.hThread);
	CloseHandle(pi.hProcess);
	//if (hJob)
	//   CloseHandle(hJob);

	// IDA script TODO: FIX fn calls
	//char header[] =
	//	"import idc\n"
	//	"import idaapi\n"
	//	"import idautils\n"
	//	"\n"
	//	"hookFunctions = [\n";
	//char tail[] =
	//	"\n]\n"
	//	"\n"
	//	"def makinbp():\n"
	//	"	if not idaapi.is_debugger_on():\n"
	//	"		print \"Please run the process... and call makinbp() again\"\n"
	//	"		return\n"
	//	"	print \"\\n\\n---------- makin ----------- \\n\\n\"\n"
	//	"	for mods in idautils.Modules():\n"
	//	"		if \"ntdll.dll\" in mods.name.lower() or \"kernelbase.dll\" in mods.name.lower():\n"
	//	"			# idaapi.analyze_area(mods.base, mods.base + mods.size)\n"
	//	"			name_addr = idaapi.get_debug_names(mods.base, mods.base + mods.size)\n"
	//	"			for addr in name_addr:\n"
	//	"				func_name = Name(addr)\n"
	//	"				func_name = func_name.split(\"_\")[1]\n"
	//	"				for funcs in hookFunctions:\n"
	//	"					if funcs.lower() == func_name.lower():\n"
	//	"						print \"Adding bp on \", hex(addr), func_name\n"
	//	"						add_bpt(addr)\n"
	//	"						hookFunctions.remove(funcs)\n"
	//	"	print \"\\n\\n----------EOF makin EOF----------- \\n\""
	//	"\n\n"
	//	"def main():\n"
	//	"	if idaapi.is_debugger_on():\n"
	//	"		makinbp()\n"
	//	"	else:\n"
	//	"		print \"Please run the process... and call makinbp()\"\n"
	//	"\n"
	//	"main()\n";


	//const auto hFileIda = CreateFile(L"makin_ida_bp.py", GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, 0, nullptr);
	//if (hFileIda == INVALID_HANDLE_VALUE)
	//{
	//   err = GetLastError();
	//   wprintf(L"CreateFile failed: %lu", err);
	//}

	//WriteFile(hFileIda, header, strlen(header), nullptr, nullptr);

	//// http://en.cppreference.com/w/cpp/algorithm/unique
	//std::sort(hookFunctions.begin(), hookFunctions.end());
	//const auto last = std::unique(hookFunctions.begin(), hookFunctions.end());
	//hookFunctions.erase(last, hookFunctions.end());

	//for (auto func : hookFunctions)
	//{
	//   WriteFile(hFileIda, "\"", strlen("\""), nullptr, nullptr);
	//   WriteFile(hFileIda, func.data(), strlen(func.data()), nullptr, nullptr);
	//   WriteFile(hFileIda, "\",\n", strlen("\",\n"), nullptr, nullptr);
	//}

	//WriteFile(hFileIda, tail, strlen(tail), nullptr, nullptr);

	//CloseHandle(hFileIda);

	return 0;
}

```

`makin/makin.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{92E1A34F-910D-47EB-A037-3F74D7509EFB}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>makin</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <RunCodeAnalysis>true</RunCodeAnalysis>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>true</RunCodeAnalysis>
    <IncludePath>$(SolutionDir)external\zydis\msvc;$(SolutionDir)external\zydis\include;$(SolutionDir)external\zydis\dependencies\zycore\include;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <EnablePREfast>true</EnablePREfast>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>ZYCORE_STATIC_DEFINE;ZYDIS_STATIC_DEFINE;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
      <EnablePREfast>true</EnablePREfast>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(SolutionDir)external\zydis\msvc\bin\ReleaseX64</AdditionalLibraryDirectories>
      <AdditionalDependencies>zydis.lib;zycore.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <DebugInformationFormat>None</DebugInformationFormat>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <DebugInformationFormat>None</DebugInformationFormat>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="makin.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="checks.json" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`makin/makin.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="makin.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="checks.json" />
  </ItemGroup>
</Project>
```

`makin/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// makin.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`makin/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

#include <cstdio>
#include <tchar.h>


// TODO(MACHINE_32): reference additional headers your program requires here

#include <Windows.h>
#include <winternl.h>
#include <vector>
#include <algorithm>
#include <memory>
#include <string>
#include <Shlwapi.h>
#include <ctime>


#pragma comment(lib, "Shlwapi.lib")

```

`makin/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```