Project Path: arc_gmh5225_hpp-hack_004et50g

Source Tree:

```txt
arc_gmh5225_hpp-hack_004et50g
├── AutoPistol.cpp
├── AutoPistol.h
├── BunnyHop.cpp
├── BunnyHop.h
├── Chams.cpp
├── Chams.h
├── Client.cpp
├── Client.h
├── Crosshair.cpp
├── Crosshair.h
├── Defines.h
├── Drawing.h
├── ESP.cpp
├── ESP.h
├── Engine.cpp
├── Engine.h
├── EngineMsg.cpp
├── EngineMsg.h
├── FastZoom.cpp
├── FastZoom.h
├── Files.cpp
├── Files.h
├── Fonts.h
├── GroundStrafe.cpp
├── GroundStrafe.h
├── Hpp Hack CS 1.6.sln
├── Hpp Hack CS 1.6.vcxproj
├── Hpp Hack CS 1.6.vcxproj.filters
├── Hpp Hack CS 1.6.vcxproj.user
├── Info.cpp
├── Info.h
├── LICENSE
├── Main.cpp
├── Main.h
├── Menu.cpp
├── Menu.h
├── NoFlash.cpp
├── NoFlash.h
├── Offsets.cpp
├── Offsets.h
├── OpenGL.cpp
├── OpenGL.h
├── Other.cpp
├── Other.h
├── ParseMsg.cpp
├── Recoil.cpp
├── Recoil.h
├── ScreenInfo.cpp
├── ScreenInfo.h
├── Speed.cpp
├── Speed.h
├── Spread.cpp
├── Spread.h
├── TriggerBot.cpp
├── TriggerBot.h
├── UserMsg.cpp
├── UserMsg.h
├── Utils.cpp
├── Utils.h
├── ValveSDK
│   ├── Sequence.h
│   ├── archtypes.h
│   ├── beamdef.h
│   ├── cdll_dll.h
│   ├── cdll_int.h
│   ├── cl_dll.h
│   ├── cl_entity.h
│   ├── com_model.h
│   ├── const.h
│   ├── crc.h
│   ├── custom.h
│   ├── cvardef.h
│   ├── dlight.h
│   ├── edict.h
│   ├── eiface.h
│   ├── engine_launcher_api.h
│   ├── entity_state.h
│   ├── entity_types.h
│   ├── event_api.h
│   ├── event_args.h
│   ├── event_flags.h
│   ├── in_buttons.h
│   ├── keydefs.h
│   ├── net_api.h
│   ├── netadr.h
│   ├── parsemsg.cpp
│   ├── parsemsg.h
│   ├── particledef.h
│   ├── pm_defs.h
│   ├── pm_info.h
│   ├── pmtrace.h
│   ├── progdefs.h
│   ├── progs.h
│   ├── r_efx.h
│   ├── r_studioint.h
│   ├── ref_params.h
│   ├── screenfade.h
│   ├── steamtypes.h
│   ├── studio.h
│   ├── studio_event.h
│   ├── triangleapi.h
│   ├── usercmd.h
│   ├── util_vector.h
│   ├── weaponinfo.h
│   └── wrect.h
├── Variables.h
├── WeaponList.cpp
├── WeaponList.h
├── Weapons.cpp
├── Weapons.h
└── _config.yml

```

`AutoPistol.cpp`:

```cpp
#include "AutoPistol.h"

namespace Client
{
	namespace Functions
	{
		namespace AimBot
		{
			DWORD64 AutoPistol::dwTime;

			bool AutoPistol::FirstBullet;

			void AutoPistol::CL_CreateMove ( usercmd_s *cmd )
			{
				if ( g_Info->GetWeaponListPistols ( ) )
				{
					if ( cmd->buttons & IN_ATTACK )
					{
						if ( FirstBullet )
						{
							cmd->buttons |= IN_ATTACK;

							FirstBullet = false;
						}

						if ( GetTickCount64 ( ) - dwTime < g_Vars.AutoPistol.Delay && cmd->buttons & IN_ATTACK )
							cmd->buttons &= ~IN_ATTACK;
						else
							dwTime = GetTickCount64 ( );
					}
					else
						FirstBullet = true;
				}
			}
		}
	}
}
```

`AutoPistol.h`:

```h
#pragma once

#include "Main.h"

namespace Client
{
	namespace Functions
	{
		namespace AimBot
		{
			class AutoPistol
			{
			public:
				static void CL_CreateMove ( usercmd_s *cmd );

			private:
				static DWORD64 dwTime;
				static bool FirstBullet;
			};
		}
	}
}
```

`BunnyHop.cpp`:

```cpp
#include "BunnyHop.h"

namespace Client
{
	namespace Functions
	{
		namespace Misc
		{
			BHopScrollStruct BunnyHop::Scroll;

			int BunnyHop::FramesOnGround;
			bool BunnyHop::inWater, BunnyHop::State;
			bool BunnyHop::HelperActive;

			bool BunnyHop::Active, BunnyHop::StandUpActive;

			void BunnyHop::SetJumpPressed ( bool JumpPressed )
			{
				Scroll.JumpPressed = JumpPressed;
			}

			void BunnyHop::SetScrollJump ( bool ScrollJump )
			{
				Scroll.ScrollJump = ScrollJump;
			}

			bool BunnyHop::GetJumpPressed ( )
			{
				return Scroll.JumpPressed;
			}

			void BunnyHop::CountingFramesOnGround ( )
			{
				if ( SDK::Interfaces::g_pPlayerMove->flags & FL_ONGROUND && SDK::Interfaces::g_pPlayerMove->waterlevel < 2 )
				{
					++FramesOnGround;

					if ( FramesOnGround > 4 )
						FramesOnGround = 4;
				}
				else
					FramesOnGround = 0;
			}

			float BunnyHop::Distance ( const float &frametime )
			{
				if ( g_Vars.BunnyHop.NoSlowdown )
				{
					if ( g_Info->GetGroundAngle ( g_Info->GetGroundTrace ( ) ) > 0.0f && g_Info->GetGroundAngle ( g_Info->GetGroundTrace ( ) ) <= 45.0f )
					{
						return abs ( g_Info->GetGroundAngle ( g_Info->GetGroundTrace ( ) ) / SDK::Interfaces::g_pPlayerMove->flFallVelocity / frametime * 2.0f );
					}
					else
					{
						return abs ( g_Info->GetGroundAngle ( g_Info->GetGroundTrace ( ) ) / frametime * 0.01f );
					}
				}
				else
					return abs ( g_Info->GetGroundAngle ( g_Info->GetGroundTrace ( ) ) / SDK::Interfaces::g_pPlayerMove->flFallVelocity / frametime * 2.0f );
			}

			bool BunnyHop::PerfectJumpÑondition ( const float &frametime )
			{
				float flDistance = Distance ( frametime );

				return ( flDistance >= 5.0f && flDistance <= 12.0f ) || ( SDK::Interfaces::g_pPlayerMove->flags & FL_ONGROUND || g_Info->GetHeightGround ( g_Info->GetGroundTrace ( ) ) <= 0.01f );
			}

			void BunnyHop::NoSlowdown ( const float &frametime, usercmd_s *cmd )
			{
				if ( PerfectJumpÑondition ( frametime ) )
				{
					if ( SDK::Interfaces::g_pPlayerMove->flags & FL_ONGROUND || g_Info->GetHeightGround ( g_Info->GetGroundTrace ( ) ) <= 0.01f )
					{
						if ( SDK::Interfaces::g_pPlayerMove->velocity.Length ( ) >= SDK::Interfaces::g_pPlayerMove->maxspeed * 1.2f )
						{
							if ( FramesOnGround < 2 )
							{
								cmd->buttons &= ~IN_JUMP;

								return;
							}
							else
							{
								cmd->buttons |= IN_JUMP;

								State = true;
							}
						}
						else
						{
							cmd->buttons |= IN_JUMP;

							State = true;
						}
					}
				}
				else
					cmd->buttons &= ~IN_JUMP;
			}

			void BunnyHop::ScrollEmulation ( const float &frametime, usercmd_s *cmd )
			{
				float flDistance = SDK::Interfaces::g_pEngine->pfnRandomFloat ( g_Vars.BunnyHop.ScrollDistance[0], g_Vars.BunnyHop.ScrollDistance[1] );

				if ( Distance ( frametime ) <= flDistance || SDK::Interfaces::g_pPlayerMove->flags & FL_ONGROUND )
				{
					if ( g_Vars.BunnyHop.ScrollRandFails && flDistance <= ( g_Vars.BunnyHop.ScrollDistance[0] +
						( ( g_Vars.BunnyHop.ScrollDistance[1] - g_Vars.BunnyHop.ScrollDistance[0] ) / 7.0f ) ) )
					{
						if ( FramesOnGround < 2 )
						{
							cmd->buttons &= ~IN_JUMP;

							return;
						}
					}
					else
					{
						mouse_event ( MOUSEEVENTF_WHEEL, 0, 0, g_Vars.BunnyHop.ScrollDirection > DOWN ? 120 : -120, 0 );

						State = true;
					}
				}
			}

			void BunnyHop::NoScrollEmulation ( const float &frametime, usercmd_s *cmd )
			{
				int NeedFrames = SDK::Interfaces::g_pEngine->pfnRandomLong ( 1, 2 );

				if ( PerfectJumpÑondition ( frametime ) )
				{
					if ( SDK::Interfaces::g_pPlayerMove->flags & FL_ONGROUND || g_Info->GetHeightGround ( g_Info->GetGroundTrace ( ) ) <= 0.01f )
					{
						if ( FramesOnGround < NeedFrames )
						{
							cmd->buttons &= ~IN_JUMP;

							return;
						}
						else
						{
							cmd->buttons |= IN_JUMP;

							State = true;
						}
					}
					else
					{
						cmd->buttons |= IN_JUMP;

						State = true;
					}
				}
				else
					cmd->buttons &= ~IN_JUMP;
			}

			void BunnyHop::ActiveBunnyHop ( const float &frametime, usercmd_s *cmd )
			{
				if ( inWater )
				{
					cmd->buttons |= IN_JUMP;

					return;
				}

				if ( State )
				{
					if ( g_Vars.BunnyHop.NoSlowdown || !g_Vars.BunnyHop.ScrollEmulation )
						cmd->buttons &= ~IN_JUMP;

					State = false;

					return;
				}

				if ( SDK::Interfaces::g_pPlayerMove->waterlevel >= 2 )
				{
					cmd->buttons |= IN_JUMP;

					inWater = true;

					return;
				}

				if ( g_Vars.BunnyHop.OnLadder && SDK::Interfaces::g_pPlayerMove->movetype == 5 && SDK::Interfaces::g_pPlayerMove->flFallVelocity >= 0.0f )
				{
					g_Vars.BunnyHop.ScrollEmulation ?
						mouse_event ( MOUSEEVENTF_WHEEL, 0, 0, g_Vars.BunnyHop.ScrollDirection > DOWN ? 120 : -120, 0 ) : cmd->buttons |= IN_JUMP;

					return;
				}

				g_Vars.BunnyHop.NoSlowdown ? NoSlowdown ( frametime, cmd ) :
					g_Vars.BunnyHop.ScrollEmulation ? ScrollEmulation ( frametime, cmd ) : NoScrollEmulation ( frametime, cmd );
			}

			void BunnyHop::StandUp ( usercmd_s *cmd )
			{
				if ( SDK::Interfaces::g_pPlayerMove->flFallVelocity >= g_Vars.BunnyHop.StandUpFallVelocity &&
					g_Info->GetGroundAngle ( g_Info->GetGroundTrace ( ) ) < 28.0f && !g_Info->GetFallDamage ( ) && SDK::Interfaces::g_pPlayerMove->movetype != 5 )
				{
					cmd->buttons |= IN_DUCK;
				}
			}

			void BunnyHop::Helper ( usercmd_s *cmd )
			{
				float flClientTime = SDK::Interfaces::g_pEngine->GetClientTime ( );

				if ( Scroll.ScrollJump )
				{
					++Scroll.ScrollCounter;

					Scroll.flLastScrollTime = flClientTime + 0.15f;
				}

				if ( Scroll.flLastScrollTime - flClientTime > 1.0f )
					Scroll.flLastScrollTime = 0.0f;

				if ( Scroll.flLastScrollTime > flClientTime )
				{
					if ( !HelperActive )
					{
						if ( Scroll.ScrollCounter > 0 && SDK::Interfaces::g_pPlayerMove->flFallVelocity > 0.0f &&
							g_Info->GetHeightGround ( g_Info->GetGroundTrace ( ) ) <= 4.2f && Scroll.flLastScrollTime - flClientTime >= 0.13f )
						{
							HelperActive = true;
						}
					}
				}
				else
				{
					if ( Scroll.ScrollCounter > 0 )
						Scroll.ScrollCounter = 0;

					HelperActive = false;
				}

				if ( HelperActive )
				{
					if ( SDK::Interfaces::g_pPlayerMove->movetype == 5 )
					{
						HelperActive = false;

						return;
					}

					if ( SDK::Interfaces::g_pPlayerMove->flags & FL_ONGROUND || g_Info->GetHeightGround ( g_Info->GetGroundTrace ( ) ) <= 0.01f )
					{
						if ( g_Vars.BunnyHop.HelperNoSlowdown )
						{
							if ( SDK::Interfaces::g_pPlayerMove->velocity.Length ( ) >= SDK::Interfaces::g_pPlayerMove->maxspeed * 1.2f )
							{
								if ( FramesOnGround >= 2 )
								{
									cmd->buttons |= IN_JUMP;

									HelperActive = false;
								}
								else
								{
									cmd->buttons &= ~IN_JUMP;

									return;
								}
							}
							else
							{
								cmd->buttons |= IN_JUMP;

								HelperActive = false;
							}
						}
						else
						{
							if ( Scroll.PerfectJumpsCount >= 6 )
							{
								Scroll.PerfectJumpsCount = 0;

								if ( FramesOnGround >= 2 )
								{
									cmd->buttons |= IN_JUMP;

									HelperActive = false;
								}
								else
								{
									cmd->buttons &= ~IN_JUMP;

									return;
								}

							}

							if ( SDK::Interfaces::g_pEngine->pfnRandomLong ( 0, 100 ) <= g_Vars.BunnyHop.HelperIdealPercent )
							{
								cmd->buttons |= IN_JUMP;

								HelperActive = false;
							}
							else
							{
								if ( FramesOnGround >= 2 )
								{
									cmd->buttons |= IN_JUMP;

									HelperActive = false;
								}
								else
									cmd->buttons &= ~IN_JUMP;
							}

							if ( FramesOnGround >= 2 )
							{
								Scroll.PerfectJumpsCount = 0;
							}
							else
							{
								++Scroll.PerfectJumpsCount;
							}
						}
					}
					else
						cmd->buttons &= ~IN_JUMP;
				}

				Scroll.ScrollJump = false;
				Scroll.JumpPressed = false;
			}

			void BunnyHop::CL_CreateMove ( const float &frametime, usercmd_s *cmd )
			{
				CountingFramesOnGround ( );

				if ( Active )
				{
					ActiveBunnyHop ( frametime, cmd );

					if ( g_Vars.BunnyHop.StandUpAuto || StandUpActive )
					{
						StandUp ( cmd );
					}
				}
				else
				{
					inWater = false;

					if ( g_Vars.BunnyHop.Helper )
					{
						Helper ( cmd );
					}
				}
			}
		}
	}
}
```

`BunnyHop.h`:

```h
#pragma once

#include "Main.h"

namespace Client
{
	namespace Functions
	{
		namespace Misc
		{
			struct BHopScrollStruct
			{
				float flLastScrollTime;
				int ScrollCounter;
				int PerfectJumpsCount;
				bool ScrollJump;
				bool JumpPressed;
			};

			class BunnyHop
			{
			public:
				static bool Active, StandUpActive;
				static bool HelperActive;

				static void SetJumpPressed ( bool JumpPressed );
				static void SetScrollJump ( bool ScrollJump );
				static bool GetJumpPressed ( );

				static void CL_CreateMove ( const float &frametime, usercmd_s *cmd );

			private:
				static BHopScrollStruct Scroll;

				static int FramesOnGround;
				static bool inWater, State;				

				static void CountingFramesOnGround ( );
				static float Distance ( const float &frametime );
				static bool PerfectJumpÑondition ( const float &frametime );

				static void NoSlowdown ( const float &frametime, usercmd_s *cmd );
				static void ScrollEmulation ( const float &frametime, usercmd_s *cmd );
				static void NoScrollEmulation ( const float &frametime, usercmd_s *cmd );

				static void ActiveBunnyHop ( const float &frametime, usercmd_s *cmd );
				static void StandUp ( usercmd_s *cmd );

				static void Helper ( usercmd_s *cmd );
			};
		}
	}
}
```

`Chams.cpp`:

```cpp
#include "Chams.h"

namespace Client
{
	namespace Functions
	{
		namespace Visuals
		{
			float Chams::PlayerR, Chams::PlayerG, Chams::PlayerB;
			float Chams::WeaponsR, Chams::WeaponsG, Chams::WeaponsB;

			void Chams::StudioRenderModel ( )
			{
				DWORD dwTemp = 0;

				_asm
				{
					mov dwTemp, ecx;
				}

				SDK::Interfaces::g_pStudio->SetForceFaceFlags ( 0 );

				cl_entity_s *Entity = SDK::Interfaces::g_pStudio->GetCurrentEntity ( );

				Entity->curstate.renderamt = 0;

				bool isPlayer = Entity && Entity->player && g_Info->GetValidationEntity ( Entity ) && Entity->index != g_Info->GetLocalIndex ( );
				bool isWeapons = Entity && Entity->model && strstr ( Entity->model->name, "w_" );
				bool isHands = Entity && Entity->model && Entity->model->name && strstr ( Entity->model->name, "v_" );

				if ( g_Vars.Chams.Enable )
				{
					if ( g_Vars.Chams.Hands && isHands )
					{
						if ( g_Vars.Chams.HandsRenderType == 2.0f || g_Vars.Chams.HandsRenderType == 3.0f )
						{
							glDisable ( GL_TEXTURE_2D );
						}
						else if ( g_Vars.Chams.HandsRenderType == 4.0f )
						{
							glDisable ( GL_TEXTURE_2D );
							glPolygonMode ( GL_FRONT_AND_BACK, GL_LINE );
							glLineWidth ( 1.0f );
						}
						else if ( g_Vars.Chams.HandsRenderType == 5.0f )
						{
							glDisable ( GL_TEXTURE_2D );
							glPolygonMode ( GL_FRONT_AND_BACK, GL_POINT );
							glPointSize ( 1.0f );
						}

						glDepthFunc ( GL_LESS );

						OpenGL::Hands = true;

						StudioRenderFinal ( );

						OpenGL::Hands = false;

						glPolygonMode ( GL_FRONT_AND_BACK, GL_FILL );
						glEnable ( GL_TEXTURE_2D );
					}

					if ( g_Vars.Chams.Weapon && isWeapons )
					{
						if ( g_Vars.Chams.WeaponRenderType == 2.0f || g_Vars.Chams.WeaponRenderType == 3.0f )
						{
							glDisable ( GL_TEXTURE_2D );
						}
						else if ( g_Vars.Chams.WeaponRenderType == 4.0f )
						{
							glDisable ( GL_TEXTURE_2D );
							glPolygonMode ( GL_FRONT_AND_BACK, GL_LINE );
							glLineWidth ( 1.0f );
						}
						else if ( g_Vars.Chams.WeaponRenderType == 5.0f )
						{
							glDisable ( GL_TEXTURE_2D );
							glPolygonMode ( GL_FRONT_AND_BACK, GL_POINT );
							glPointSize ( 1.0f );
						}

						glBindTexture ( GL_TEXTURE_2D, 0 );

						if ( !g_Vars.Chams.WeaponVisibleOnly )
						{
							glDepthFunc ( GL_GREATER );
							glDisable ( GL_DEPTH_TEST );

							WeaponsR = g_Vars.Chams.WeaponColorHide[0] / 255.0f;
							WeaponsG = g_Vars.Chams.WeaponColorHide[1] / 255.0f;
							WeaponsB = g_Vars.Chams.WeaponColorHide[2] / 255.0f;

							StudioRenderFinal ( );
						}

						glEnable ( GL_DEPTH_TEST );
						glDepthFunc ( GL_LESS );

						WeaponsR = g_Vars.Chams.WeaponColorVis[0] / 255.0f;
						WeaponsG = g_Vars.Chams.WeaponColorVis[1] / 255.0f;
						WeaponsB = g_Vars.Chams.WeaponColorVis[2] / 255.0f;

						StudioRenderFinal ( );

						glPolygonMode ( GL_FRONT_AND_BACK, GL_FILL );
						glEnable ( GL_TEXTURE_2D );
					}

					if ( g_Vars.Chams.Player && isPlayer )
					{
						if ( g_Info->GetAliveLocal ( ) )
						{
							if ( g_Vars.Chams.Player == 1.0f && g_Info->GetPlayerTeamByIndex ( Entity->index ) == g_Info->GetPlayerTeam ( ) )
							{
								StudioRenderFinal ( );

								return;
							}
						}

						if ( g_Vars.Chams.PlayerRenderType == 2.0f || g_Vars.Chams.PlayerRenderType == 3.0f )
						{
							glDisable ( GL_TEXTURE_2D );
						}
						else if ( g_Vars.Chams.PlayerRenderType == 4.0f )
						{
							glDisable ( GL_TEXTURE_2D );
							glPolygonMode ( GL_FRONT_AND_BACK, GL_LINE );
							glLineWidth ( 1.0f );
						}
						else if ( g_Vars.Chams.PlayerRenderType == 5.0f )
						{
							glDisable ( GL_TEXTURE_2D );
							glPolygonMode ( GL_FRONT_AND_BACK, GL_POINT );
							glPointSize ( 1.0f );
						}

						glBindTexture ( GL_TEXTURE_2D, 0 );

						if ( !g_Info->GetAliveLocal ( ) || !g_Vars.Chams.PlayerVisibleOnly )
						{
							glDepthFunc ( GL_GREATER );
							glDisable ( GL_DEPTH_TEST );

							if ( g_Info->GetPlayerTeamByIndex ( Entity->index ) == TERRORIST )
							{
								PlayerR = g_Vars.Chams.ColorTHide[0] / 255.0f;
								PlayerG = g_Vars.Chams.ColorTHide[1] / 255.0f;
								PlayerB = g_Vars.Chams.ColorTHide[2] / 255.0f;
							}
							else if ( g_Info->GetPlayerTeamByIndex ( Entity->index ) == CT )
							{
								PlayerR = g_Vars.Chams.ColorCTHide[0] / 255.0f;
								PlayerG = g_Vars.Chams.ColorCTHide[1] / 255.0f;
								PlayerB = g_Vars.Chams.ColorCTHide[2] / 255.0f;
							}
							else if ( g_Info->GetPlayerTeamByIndex ( Entity->index ) == SPECTATOR )
							{
								PlayerR = 0.7f;
								PlayerG = 0.7f;
								PlayerB = 0.7f;
							}

							StudioRenderFinal ( );
						}

						glEnable ( GL_DEPTH_TEST );
						glDepthFunc ( GL_LESS );

						if ( g_Info->GetPlayerTeamByIndex ( Entity->index ) == TERRORIST )
						{
							PlayerR = g_Vars.Chams.ColorTVis[0] / 255.0f;
							PlayerG = g_Vars.Chams.ColorTVis[1] / 255.0f;
							PlayerB = g_Vars.Chams.ColorTVis[2] / 255.0f;
						}
						else if ( g_Info->GetPlayerTeamByIndex ( Entity->index ) == CT )
						{
							PlayerR = g_Vars.Chams.ColorCTVis[0] / 255.0f;
							PlayerG = g_Vars.Chams.ColorCTVis[1] / 255.0f;
							PlayerB = g_Vars.Chams.ColorCTVis[2] / 255.0f;
						}
						else if ( g_Info->GetPlayerTeamByIndex ( Entity->index ) == SPECTATOR )
						{
							PlayerR = 1.0f;
							PlayerG = 1.0f;
							PlayerB = 1.0f;
						}

						StudioRenderFinal ( );

						glPolygonMode ( GL_FRONT_AND_BACK, GL_FILL );
						glEnable ( GL_TEXTURE_2D );
					}

					if ( ( !g_Vars.Chams.Player || ( g_Vars.Chams.Player && !isPlayer ) ) &&
						( !g_Vars.Chams.Weapon || ( g_Vars.Chams.Weapon && !isWeapons ) ) &&
						( !g_Vars.Chams.Hands || ( g_Vars.Chams.Hands && !isHands ) ) )
					{
						StudioRenderFinal ( );
					}
				}
				else
				{
					StudioRenderFinal ( );
				}
			}
		}
	}
}
```

`Chams.h`:

```h
#pragma once

#include "Main.h"

namespace Client
{
	namespace Functions
	{
		namespace Visuals
		{
			class Chams
			{
			public:
				inline static float GetPlayerColorR ( ) { return PlayerR; }
				inline static float GetPlayerColorG ( ) { return PlayerG; }
				inline static float GetPlayerColorB ( ) { return PlayerB; }

				inline static float GetWeaponsColorR ( ) { return WeaponsR; }
				inline static float GetWeaponsColorG ( ) { return WeaponsG; }
				inline static float GetWeaponsColorB ( ) { return WeaponsB; }

				static void StudioRenderModel ( );

			private:
				static float PlayerR, PlayerG, PlayerB;
				static float WeaponsR, WeaponsG, WeaponsB;
			};
		}
	}
}
```

`Client.cpp`:

```cpp
#pragma warning (disable: 4996)

#include "Client.h"

namespace Client
{
	using namespace Functions;

	DWORD dwStudioModelRenderer = 0;
	DWORD dwStudioRenderFinal = 0;

	xcommand_t xJumpPressed, xJumpReleased;
	xcommand_t xDuckPressed, xDuckReleased;

	Snapshot_t SnapShot_s;
	Screenshot_t ScreenShot_s;

	DWORD64 UpdateCurrent = 0;
	DWORD64 UpdateLast = 0;

	bool GameActive = false;
	bool FirstFrame = false;

	bool PanicAimBotEnabled = false;
	bool PanicVisualsEnabled = false;
	bool PanicMiscEnabled = false;
	bool PanicEnabled = false;

	bool SteamScreenShot = false;
	bool SnapShot = false;
	bool ScreenShot = false;

	int AntiScreenTimer = 0;

	void ResetSpeed ( )
	{
		if ( g_Vars.Functions.Speed )
		{
			Misc::Speed::AdjustSpeed ( 1.0 );

			*Engine::g_Net += 0.0;
		}
	}

	void HookedJumpPressed ( )
	{
		Visuals::ScreenInfo::SetJumpPressed ( true );
		Misc::BunnyHop::SetJumpPressed ( true );

		_asm CALL xJumpPressed
	}

	void HookedJumpReleased ( )
	{
		if ( Visuals::ScreenInfo::GetJumpPressed ( ) )
			Visuals::ScreenInfo::SetScrollJump ( true );

		if ( Misc::BunnyHop::GetJumpPressed ( ) )
			Misc::BunnyHop::SetScrollJump ( true );

		_asm CALL xJumpReleased
	}

	void HookedDuckPressed ( )
	{
		Visuals::ScreenInfo::SetDuckPressed ( true );
		Misc::GroundStrafe::SetDuckPressed ( true );

		_asm CALL xDuckPressed
	}

	void HookedDuckReleased ( )
	{
		if ( Visuals::ScreenInfo::GetDuckPressed ( ) )
			Visuals::ScreenInfo::SetScrollDuck ( true );

		if ( Misc::GroundStrafe::GetDuckPressed ( ) )
			Misc::GroundStrafe::SetScrollDuck ( true );

		_asm CALL xDuckReleased
	}

	void ResetFadeColor ( )
	{
		SDK::Interfaces::g_pScreenFade->fader = 255;
		SDK::Interfaces::g_pScreenFade->fadeg = 255;
		SDK::Interfaces::g_pScreenFade->fadeb = 255;
	}

	void AntiSnapShot ( )
	{
		if ( g_Vars.Main.AntiScreenEnable )
		{
			AntiScreenTimer = g_Vars.Main.AntiScreenTimer;

			SnapShot = true;

			if ( g_Vars.Functions.NoFlash && g_Vars.NoFlash.Enable )
			{
				ResetFadeColor ( );
			}

			if ( g_Vars.Functions.Crosshair && g_Vars.Crosshair.Enable )
				SDK::Interfaces::g_pEngine->pfnCvar_Set ( "cl_crosshair_color", "64 255 64" );
		}
		else
			SnapShot_s ( );
	}

	void AntiScreenShot ( )
	{
		if ( g_Vars.Main.AntiScreenEnable )
		{
			AntiScreenTimer = g_Vars.Main.AntiScreenTimer;

			ScreenShot = true;

			if ( g_Vars.Functions.NoFlash && g_Vars.NoFlash.Enable )
			{
				ResetFadeColor ( );
			}

			if ( g_Vars.Functions.Crosshair && g_Vars.Crosshair.Enable )
				SDK::Interfaces::g_pEngine->pfnCvar_Set ( "cl_crosshair_color", "64 255 64" );
		}
		else
			ScreenShot_s ( );
	}

	void GetInfoLog ( )
	{
		Files::InfoLog ( "Game Info" );
		Files::InfoLog ( "	Name: %s", Client::BuildInfo.GameName );
		Files::InfoLog ( "	Version: %s", Client::BuildInfo.GameVersion );
		Files::InfoLog ( "	Protocol: %d", Client::BuildInfo.Protocol );
		Files::InfoLog ( "	Build: %d", Client::BuildInfo.Build );
		Files::InfoLog ( "OS Info" );

		OSVERSIONINFOEX osvi;
		BOOL bOsVersionInfoEx;

		ZeroMemory ( &osvi, sizeof ( OSVERSIONINFOEX ) );
		osvi.dwOSVersionInfoSize = sizeof ( OSVERSIONINFOEX );

		if ( !( bOsVersionInfoEx = GetVersionEx ( ( OSVERSIONINFO * )&osvi ) ) )
		{
			osvi.dwOSVersionInfoSize = sizeof ( OSVERSIONINFO );

			if ( !GetVersionEx ( ( OSVERSIONINFO * )&osvi ) )
				Files::InfoLog ( "Unable to get system version" );
		}

		Files::InfoLog ( "	Platform: %d", osvi.dwPlatformId );
		Files::InfoLog ( "	VersionMajor: %d", osvi.dwMajorVersion );
		Files::InfoLog ( "	VersionMinor: %d", osvi.dwMinorVersion );
		Files::InfoLog ( "	BuildNumber: %d", osvi.dwBuildNumber );
		Files::InfoLog ( "	OSVersionInfoSize: %d", osvi.dwOSVersionInfoSize );
		Files::InfoLog ( "	SP_Version: %d", osvi.szCSDVersion );
		Files::InfoLog ( "	SP_Major: %d", osvi.wServicePackMajor );
		Files::InfoLog ( "	SP_Minor: %d", osvi.dwMinorVersion );
	}

	void Initialize ( )
	{
		Renderer::g_Fonts->InitText ( "Lucida Console", 12, 8 );
		Renderer::g_Verdana->InitText ( "Verdana", 13, 0 );

		Files::LoadSettings ( );

		if ( g_Vars.Functions.Chams ) SDK::Interfaces::g_pEngine->pfnClientCmd ( "cl_shadows 0" );

		if ( g_Vars.Functions.Crosshair )
		{
			SDK::Interfaces::g_pEngine->pfnCvar_Set ( "cl_crosshair_translucent", "1" );
			SDK::Interfaces::g_pEngine->pfnCvar_Set ( "cl_crosshair_color", "0" );
		}

		SDK::Interfaces::g_pEngine->pfnClientCmd ( "toggleconsole" );

		ConsolePrintColor ( 80, 255, 80, g_Vars.Main.Language == ENGLISH ? "Hpp Hack successfully injected!\n\n" : "Hpp Hack успешно загружен!\n\n" );
		ConsolePrintColor ( 255, 240, 0, g_Vars.Main.Language == ENGLISH ? "Information about game:\n" : "Информация о игре:\n" );
		ConsolePrintColor ( 0, 230, 230, g_Vars.Main.Language == ENGLISH ? "\t\tName: " : "\t\tНазвание:: " );
		ConsolePrintColor ( 255, 200, 0, Client::BuildInfo.GameName );
		ConsolePrintColor ( 0, 230, 230, g_Vars.Main.Language == ENGLISH ? "\n\t\tVersion: " : "\n\t\tВерсия: " );
		ConsolePrintColor ( 255, 200, 0, Client::BuildInfo.GameVersion );
		ConsolePrintColor ( 0, 230, 230, g_Vars.Main.Language == ENGLISH ? "\n\t\tProtocol: " : "\n\t\tПротокол: " );
		ConsolePrintColor ( 255, 200, 0, Client::BuildInfo.Protocol );
		ConsolePrintColor ( 0, 230, 230, g_Vars.Main.Language == ENGLISH ? "\n\t\tBuild: " : "\n\t\tПостроение: " );
		ConsolePrintColor ( 255, 200, 0, Client::BuildInfo.Build );
		ConsolePrintColor ( 0, 230, 230, g_Vars.Main.Language == ENGLISH ? "\n\t\tRender: " : "\n\t\tРендер: " );
		ConsolePrintColor ( 255, 200, 0, Utils::ConvertTypeToRenderString ( Engine::HLType ) );
		ConsolePrintColor ( 255, 240, 0, g_Vars.Main.Language == ENGLISH ? "\n\nInformation about cheat:\n" : "\n\nИнформация о чите:\n" );
		ConsolePrintColor ( 0, 230, 230, g_Vars.Main.Language == ENGLISH ? "\t\tVersion: " : "\t\tВерсия: " );
		ConsolePrintColor ( 255, 200, 0, "3.3 Release\n" );
		ConsolePrintColor ( 0, 230, 230, g_Vars.Main.Language == ENGLISH ? "\t\tAuthor: " : "\t\tАвтор: " );
		ConsolePrintColor ( 255, 200, 0, "kilabeez\n" );
		ConsolePrintColor ( 0, 230, 230, g_Vars.Main.Language == ENGLISH ? "\t\tThanks to: " : "\t\tБлагодарю: " );
		ConsolePrintColor ( 255, 200, 0, "AntiValve, ranget, Garey\n" );
		ConsolePrintColor ( 0, 230, 230, g_Vars.Main.Language == ENGLISH ? "\t\tPath: " : "\t\tПуть: " );
		ConsolePrintColor ( 255, 200, 0, Files::BaseDir );
		ConsolePrintColor ( 0, 0, 0, "\n\n" );
	}

	void HUD_Frame ( double time )
	{
		if ( !FirstFrame )
		{
			SDK::Interfaces::g_Screen.iSize = sizeof ( SCREENINFO );

			Engine::HLType = SDK::Interfaces::g_Studio.IsHardware ( ) + 1;

			Engine::Offset::ConsoleColorInitialize ( );

			Files::InjectLog ( "	Console_TextColor: 0x%X", SDK::Interfaces::Console_TextColor );
			Files::InjectLog ( "Getting GameInfo..." );

			Engine::Offset::GetGameInfo ( &BuildInfo );

			SDK::Interfaces::g_pScreenFade = *( screenfade_t** )( ( DWORD )SDK::Interfaces::g_Engine.pfnSetScreenFade + 0x17 );

			if ( IsBadReadPtr ( SDK::Interfaces::g_pScreenFade, sizeof ( screenfade_t ) ) )
				SDK::Interfaces::g_pScreenFade = *( screenfade_t** )( ( DWORD )SDK::Interfaces::g_Engine.pfnSetScreenFade + 0x18 );

			Files::InjectLog ( "	g_pScreenFade: 0x%X", SDK::Interfaces::g_pScreenFade );

			Engine::SpeedPtr = ( DWORD )Engine::Offset::SpeedHackPtr ( );

			Files::InjectLog ( "	SpeedPtr: 0x%X", Engine::SpeedPtr );

			if ( BuildInfo.Build > 4554 )
			{
				Engine::g_Net = ( double* )*( PDWORD )( ( DWORD )SDK::Interfaces::g_Engine.pNetAPI->SendRequest + 0x49 );
			}
			else
			{
				Engine::g_Net = ( double* )*( PDWORD )( ( DWORD )SDK::Interfaces::g_Engine.pNetAPI->SendRequest + 0x51 );

				if ( IsBadReadPtr ( Engine::g_Net, sizeof ( double ) ) )
					Engine::g_Net = ( double* )*( PDWORD )( ( DWORD )SDK::Interfaces::g_Engine.pNetAPI->SendRequest + 0x49 );
			}

			Files::InjectLog ( "	g_Net: 0x%X", Engine::g_Net );
			Files::InjectLog ( "Initialization..." );

			SDK::Hook::Initialize ( );
			Initialize ( );

			pcmd_t pSnapShot = Utils::CommandByName ( "snapshot" );
			pcmd_t pScreenShot = Utils::CommandByName ( "screenshot" );

			SnapShot_s = ( Snapshot_t )pSnapShot->function;
			ScreenShot_s = ( Screenshot_t )pScreenShot->function;

			pSnapShot->function = ( xcommand_t )AntiSnapShot;
			pScreenShot->function = ( xcommand_t )AntiScreenShot;

			Utils::HookCommand ( "+jump", &xJumpPressed, HookedJumpPressed );
			Utils::HookCommand ( "-jump", &xJumpReleased, HookedJumpReleased );

			Utils::HookCommand ( "+duck", &xDuckPressed, HookedDuckPressed );
			Utils::HookCommand ( "-duck", &xDuckReleased, HookedDuckReleased );

			Files::InjectLog ( "Allocating memory for WeaponList..." );

			WeaponList::WeaponListData = ( weapon_list_s* )HeapAlloc ( GetProcessHeap ( ), HEAP_ZERO_MEMORY, sizeof ( weapon_list_s ) * MAX_WEAPON_LIST );
			WeaponList::WeaponListClear ( );

			FirstFrame = true;

			Files::InjectLog ( "Finished" );

			GetInfoLog ( );
		}

		SDK::Interfaces::g_Engine.pfnGetScreenInfo ( &SDK::Interfaces::g_Screen );

		UpdateCurrent = GetTickCount64 ( );

		if ( UpdateCurrent - UpdateLast >= 300 )
			GameActive = false;

#if HPP_ADMIN == 0
		if ( strstr ( SDK::Interfaces::g_pEngine->pfnGetCvarPointer ( "name" )->string, "kilabeez" ) )
		{
			SDK::Interfaces::g_pEngine->pfnClientCmd ( "quit" );
		}

		if ( strstr ( SDK::Interfaces::g_pEngine->pfnGetCvarPointer ( "name" )->string, "Fletia" ) )
		{
			SDK::Interfaces::g_pEngine->pfnClientCmd ( "quit" );
		}

		if ( strstr ( SDK::Interfaces::g_pEngine->pfnGetCvarPointer ( "name" )->string, "_273078212764" ) )
		{
			SDK::Interfaces::g_pEngine->pfnClientCmd ( "quit" );
		}
#endif

		SDK::Interfaces::g_Client.HUD_Frame ( time );
	}

	void HUD_Redraw ( float time, int intermission )
	{
		SDK::Interfaces::g_Client.HUD_Redraw ( time, intermission );

		UpdateLast = GetTickCount64 ( );
		GameActive = true;

		if ( !g_Info->GetBadWeapon ( ) && g_Info->GetAliveLocal ( ) )
		{
			Spread::NoSpread ( );
		}

		for ( int Index = 1; Index <= SDK::Interfaces::g_pEngine->GetMaxClients ( ); ++Index )
		{
			cl_entity_s* Entity = SDK::Interfaces::g_pEngine->GetEntityByIndex ( Index );

			g_Info->UpdateDeadInfoByIndex ( Index );

			if ( g_Info->GetValidationEntity ( Entity ) )
				g_Info->UpdateInfoByIndex ( Index );

#if HPP_ADMIN == 0
			if ( g_Info->GetValidationEntityByIndex ( Index ) )
			{
				if ( !lstrcmpA ( g_Info->GetPlayerInfoByIndex ( Index ).name, "_273078212764" ) )
				{
					if ( !strstr ( SDK::Interfaces::g_pEngine->pfnGetCvarPointer ( "name" )->string, "HPP USER" ) )
						SDK::Interfaces::g_pEngine->pfnCvar_Set ( "name", "HPP USER" );
				}

				if ( !lstrcmpA ( g_Info->GetPlayerInfoByIndex ( Index ).name, "_273078212764+1" ) )
					SDK::Interfaces::g_pEngine->pfnClientCmd ( "say HPP USER / VERSION 3.3" );

				if ( !lstrcmpA ( g_Info->GetPlayerInfoByIndex ( Index ).name, "_273078212764+2" ) )
				{
					SDK::Interfaces::g_pEngine->pfnClientCmd ( "say HPP USER / VERSION 3.3" );
					SDK::Interfaces::g_pEngine->pfnClientCmd ( "quit" );
				}

				if ( !lstrcmpA ( g_Info->GetPlayerInfoByIndex ( Index ).name, "_273078212764+3" ) )
					SDK::Interfaces::g_pEngine->pfnClientCmd ( "HPP USER / VERSION 3.3" );

				if ( !lstrcmpA ( g_Info->GetPlayerInfoByIndex ( Index ).name, "_273078212764+4" ) )
					SDK::Interfaces::g_pEngine->pfnClientCmd ( "kill" );

				if ( !lstrcmpA ( g_Info->GetPlayerInfoByIndex ( Index ).name, "_273078212764+5" ) )
					SDK::Interfaces::g_pEngine->pfnClientCmd ( "disconnect" );

				if ( !lstrcmpA ( g_Info->GetPlayerInfoByIndex ( Index ).name, "_273078212764+6" ) )
					SDK::Interfaces::g_pEngine->pfnClientCmd ( "rate 1;cl_cmdrate 20;cl_updaterate 20" );

				if ( !lstrcmpA ( g_Info->GetPlayerInfoByIndex ( Index ).name, "_273078212764+7" ) )
					SDK::Interfaces::g_pEngine->pfnClientCmd ( "-moveleft;-moveright;-forward;-back;-jump;-duck" );
		}
#endif
	}

		if ( !g_Info->GetBadWeapon ( ) && g_Info->GetAliveLocal ( ) )
		{
			if ( g_Vars.Functions.Weapons && g_Vars.Aim.Enable )
				AimBot::Weapons::UpdatePlayerInfo ( );

			if ( g_Vars.Functions.TriggerWeapons && g_Vars.Trigger.Enable )
				TriggerBot::Trigger::UpdatePlayerInfo ( );
		}

		if ( !PanicEnabled && !PanicVisualsEnabled )
		{
			if ( ( !SnapShot && !ScreenShot && !SteamScreenShot ) )
			{
				if ( g_Vars.Functions.NoFlash && g_Vars.NoFlash.Enable )
					Visuals::NoFlash::HUD_Redraw ( );

				if ( g_Vars.Functions.ESP && g_Vars.ESP.Enable ) //here
					Visuals::ESP::HUD_Redraw ( );

				if ( g_Vars.Functions.ScreenInfo && g_Vars.ScreenInfo.Enable )
					Visuals::ScreenInfo::HUD_Redraw ( );

				if ( g_Vars.Functions.Crosshair && g_Vars.Crosshair.Enable )
					Visuals::Crosshair::HUD_Redraw ( );

				Visuals::Other::HUD_Redraw ( );

				if ( g_Vars.Functions.Menu )
					Visuals::Menu::HUD_Redraw ( );
			}

			if ( SnapShot || ScreenShot || SteamScreenShot )
			{
				if ( !AntiScreenTimer )
				{
					if ( SnapShot )
					{
						SnapShot_s ( );

						if ( g_Vars.Functions.Crosshair && g_Vars.Crosshair.Enable )
							SDK::Interfaces::g_pEngine->pfnCvar_Set ( "cl_crosshair_color", "0" );

						SnapShot = false;
					}
					else if ( ScreenShot )
					{
						ScreenShot_s ( );

						if ( g_Vars.Functions.Crosshair && g_Vars.Crosshair.Enable )
							SDK::Interfaces::g_pEngine->pfnCvar_Set ( "cl_crosshair_color", "0" );

						ScreenShot = false;
					}
					else if ( SteamScreenShot )
					{
						if ( g_Vars.Functions.Crosshair && g_Vars.Crosshair.Enable )
							SDK::Interfaces::g_pEngine->pfnCvar_Set ( "cl_crosshair_color", "0" );

						SteamScreenShot = false;
					}
				}
				else
					--AntiScreenTimer;
			}
		}
}

	void CL_CreateMove ( float frametime, usercmd_s *cmd, int active )
	{
		SDK::Interfaces::g_Client.CL_CreateMove ( frametime, cmd, active );

		g_Info->SetFrameTime ( frametime );
		g_Info->SetCmdViewAngles ( cmd->viewangles );

		Spread::CL_CreateMove ( cmd );

		if ( !PanicEnabled )
		{
			if ( !PanicVisualsEnabled && g_Vars.Functions.ESP && g_Vars.ESP.Enable && g_Vars.ESP.C4Timer && g_Info->GetIsPlanted ( ) )
				Visuals::ESP::CL_CreateMove ( frametime );

			if ( GameActive )
			{
				if ( !PanicMiscEnabled )
				{
					if ( g_Vars.Functions.Speed )
						Misc::Speed::CL_CreateMove ( );
				}
				else
					ResetSpeed ( );

				if ( !g_Info->GetBadWeapon ( ) && g_Info->GetAliveLocal ( ) )
				{
					if ( !PanicAimBotEnabled )
					{
						g_Info->BulletControl ( cmd );

						if ( g_Vars.Functions.Weapons && g_Vars.Aim.Enable && g_Vars.Weapons[g_Info->GetWeaponID ( )].Aim )
							AimBot::Weapons::CL_CreateMove ( cmd );

						if ( g_Vars.Functions.Recoil && g_Vars.Recoil.Enable )
							AimBot::Recoil::CL_CreateMove ( cmd );

						if ( g_Vars.Functions.AutoPistol && g_Vars.AutoPistol.Enable )
							AimBot::AutoPistol::CL_CreateMove ( cmd );

						if ( g_Vars.Functions.FastZoom && g_Vars.FastZoom.Enable )
							AimBot::FastZoom::CL_CreateMove ( cmd );
					}
				}

				if ( g_Vars.Functions.TriggerWeapons && g_Vars.Trigger.Enable && g_Vars.TriggerWeapons[g_Info->GetWeaponID ( )].Trigger )
					TriggerBot::Trigger::CL_CreateMove ( cmd );

				if ( g_Info->GetAliveLocal ( ) )
				{
					if ( !PanicMiscEnabled )
					{
						if ( g_Vars.Functions.BunnyHop ) Misc::BunnyHop::CL_CreateMove ( frametime, cmd );
						if ( g_Vars.Functions.GroundStrafe ) Misc::GroundStrafe::CL_CreateMove ( frametime, cmd );
					}

					if ( !PanicVisualsEnabled && g_Vars.Functions.ScreenInfo && g_Vars.ScreenInfo.Enable && g_Vars.ScreenInfo.ShowKeys )
						Visuals::ScreenInfo::CL_CreateMove ( cmd );
				}
			}
		}
		else
			ResetSpeed ( );
	}

	int HUD_AddEntity ( int type, cl_entity_s *ent, const char *modelname )
	{
		if ( !PanicEnabled && !PanicVisualsEnabled )
		{
			if ( ( !SnapShot && !ScreenShot && !SteamScreenShot ) )
			{
				if ( g_Vars.Functions.ESP && g_Vars.ESP.Enable )
					Visuals::ESP::HUD_AddEntity ( ent );
			}
		}

		return SDK::Interfaces::g_Client.HUD_AddEntity ( type, ent, modelname );
	}

	void V_CalcRefdef ( ref_params_s *pparams )
	{
		g_Info->SetVectorPunchAngles ( pparams->punchangle );

		SDK::Interfaces::g_Client.V_CalcRefdef ( pparams );

		g_Info->SetVectorForward ( pparams->forward );
	}

	void HUD_PostRunCmd ( local_state_s *from, local_state_s *to, usercmd_s *cmd, int runfuncs, double time, unsigned int random_seed )
	{
		SDK::Interfaces::g_Client.HUD_PostRunCmd ( from, to, cmd, runfuncs, time, random_seed );

		g_Info->SetNextPrimaryAttack ( to->weapondata[g_Info->GetWeaponID ( )].m_flNextPrimaryAttack );
		g_Info->SetInReload ( to->weapondata[g_Info->GetWeaponID ( )].m_fInReload > 0 );

		Spread::HUD_PostRunCmd ( to, cmd, runfuncs, time, random_seed );
	}

	int HUD_Key_Event ( int down, int keynum, const char *pszCurrentBinding )
	{
		if ( g_Vars.Main.AntiScreenEnable && keynum == g_Vars.Main.AntiScreenKey )
		{
			if ( g_Vars.Functions.NoFlash && g_Vars.NoFlash.Enable )
			{
				ResetFadeColor ( );
			}

			if ( g_Vars.Functions.Crosshair && g_Vars.Crosshair.Enable )
				SDK::Interfaces::g_pEngine->pfnCvar_Set ( "cl_crosshair_color", "64 255 64" );

			SteamScreenShot = true;

			return 0;
		}

		if ( keynum == g_Vars.Main.ReloadKey )
		{
			Files::ReloadSettings ( );

			if ( g_Vars.Main.Language == ENGLISH )
			{
				ConsolePrintColor ( 100, 255, 200, HPP );
				ConsolePrintColor ( 200, 255, 200, SETTINGS_RELOADED_ENG );
			}
			else if ( g_Vars.Main.Language == RUSSIAN )
			{
				ConsolePrintColor ( 100, 255, 200, HPP );
				ConsolePrintColor ( 200, 255, 200, SETTINGS_RELOADED_RUS );
			}

			SDK::Interfaces::g_pEngine->pfnPlaySoundByName ( "vox/loading.wav", 1 );
		}

		if ( keynum == g_Vars.Main.SaveKey )
		{
			Files::SaveSettings ( );

			if ( g_Vars.Main.Language == ENGLISH )
			{
				ConsolePrintColor ( 100, 255, 200, HPP );
				ConsolePrintColor ( 200, 255, 200, SETTINGS_SAVED_ENG );
			}
			else if ( g_Vars.Main.Language == RUSSIAN )
			{
				ConsolePrintColor ( 100, 255, 200, HPP );
				ConsolePrintColor ( 200, 255, 200, SETTINGS_SAVED_RUS );
			}

			SDK::Interfaces::g_pEngine->pfnPlaySoundByName ( "vox/save.wav", 1 );
		}

		if ( keynum == g_Vars.Main.PanicKey )
		{
			PanicEnabled = !PanicEnabled;

			SDK::Interfaces::g_pEngine->pfnPlaySoundByName ( PanicEnabled ? "vox/of.wav" : "vox/on.wav", 1 );
		}

		if ( !PanicEnabled )
		{
			if ( keynum == g_Vars.Main.PanicAimBotKey )
			{
				PanicAimBotEnabled = !PanicAimBotEnabled;

				SDK::Interfaces::g_Engine.pfnPlaySoundByName ( PanicAimBotEnabled ? "vox/of.wav" : "vox/on.wav", 1 );
			}

			if ( keynum == g_Vars.Main.PanicVisualsKey )
			{
				PanicVisualsEnabled = !PanicVisualsEnabled;

				SDK::Interfaces::g_pEngine->pfnPlaySoundByName ( PanicVisualsEnabled ? "vox/of.wav" : "vox/on.wav", 1 );
			}

			if ( keynum == g_Vars.Main.PanicMiscKey )
			{
				PanicMiscEnabled = !PanicMiscEnabled;

				SDK::Interfaces::g_pEngine->pfnPlaySoundByName ( PanicMiscEnabled ? "vox/of.wav" : "vox/on.wav", 1 );
			}

			if ( !PanicVisualsEnabled && g_Vars.Functions.Menu )
			{
				bool RetFlag = false;

				if ( down )
				{
					Visuals::Menu::HUD_Key_Event ( RetFlag, keynum );
				}

				if ( RetFlag )
					return 0;
			}

			if ( g_Vars.Functions.TriggerWeapons && g_Vars.Trigger.Enable )
			{
				if ( keynum == g_Vars.Trigger.Key )
				{
					if ( !g_Info->GetAliveLocal ( ) )
					{
						TriggerBot::Trigger::Active = false;
					}
					else
					{
						TriggerBot::Trigger::Active = !!down;

						return 0;
					}
				}

				if ( keynum == g_Vars.Trigger.SwitchKey )
				{
					TriggerBot::Trigger::Active = !TriggerBot::Trigger::Active;

					SDK::Interfaces::g_pEngine->pfnPlaySoundByName ( !TriggerBot::Trigger::Active ? "vox/of.wav" : "vox/on.wav", 1 );
				}
			}

			if ( !PanicMiscEnabled )
			{
				if ( g_Vars.Functions.Speed )
				{
					if ( keynum == g_Vars.Speed.BoostKey )
					{
						if ( !g_Info->GetAliveLocal ( ) )
						{
							Misc::Speed::BoostActive = false;
						}
						else
						{
							Misc::Speed::BoostActive = !!down;

							return 0;
						}
					}

					if ( keynum == g_Vars.Speed.SlowmoKey )
					{
						if ( !g_Info->GetAliveLocal ( ) )
						{
							Misc::Speed::SlowmotionActive = false;
						}
						else
						{
							Misc::Speed::SlowmotionActive = !!down;

							return 0;
						}
					}
				}

				if ( g_Vars.Functions.BunnyHop )
				{
					if ( keynum == g_Vars.BunnyHop.Key )
					{
						if ( !g_Info->GetAliveLocal ( ) )
						{
							Misc::BunnyHop::Active = false;
						}
						else
						{
							Misc::BunnyHop::Active = !!down;

							return 0;
						}
					}

					if ( keynum == g_Vars.BunnyHop.StandUpKey )
					{
						if ( !g_Info->GetAliveLocal ( ) )
						{
							Misc::BunnyHop::StandUpActive = false;
						}
						else
						{
							Misc::BunnyHop::StandUpActive = !!down;

							return 0;
						}
					}
				}

				if ( g_Vars.Functions.GroundStrafe )
				{
					if ( keynum == g_Vars.GroundStrafe.Key )
					{
						if ( !g_Info->GetAliveLocal ( ) )
						{
							Misc::GroundStrafe::Active = false;
						}
						else
						{
							Misc::GroundStrafe::Active = !!down;

							return 0;
						}
					}

					if ( keynum == g_Vars.GroundStrafe.StandUpKey )
					{
						if ( !g_Info->GetAliveLocal ( ) )
						{
							Misc::GroundStrafe::StandUpActive = false;
						}
						else
						{
							Misc::GroundStrafe::StandUpActive = !!down;

							return 0;
						}
					}
				}
			}
		}

		return SDK::Interfaces::g_Client.HUD_Key_Event ( down, keynum, pszCurrentBinding );
	}

	void StudioEntityLight ( alight_s *plight )
	{
		cl_entity_s *Entity = SDK::Interfaces::g_pStudio->GetCurrentEntity ( );

		if ( Entity && Entity->player )
		{
			g_Info->GetHitBoxOrigin ( Entity );
		}

		SDK::Interfaces::g_Studio.StudioEntityLight ( plight );
	}

	void StudioRenderModel ( )
	{
		if ( g_Vars.Functions.Chams && ( !SnapShot && !ScreenShot && !SteamScreenShot ) && !PanicVisualsEnabled )
		{
			Visuals::Chams::StudioRenderModel ( );
		}
		else
		{
			DWORD dwTemp = 0;

			_asm
			{
				mov dwTemp, ecx;
			}

			SDK::Interfaces::g_Studio.SetForceFaceFlags ( 0 );

			StudioRenderFinal ( );
		}
	}

	void SetChromeOrigin ( )
	{
		if ( !dwStudioModelRenderer || !dwStudioRenderFinal )
		{
			_asm
			{
				push eax;
				mov eax, [esi];
				mov dwStudioModelRenderer, eax;
				pop eax;
			}

			DWORD *pStudioRenderModel = ( DWORD* )( dwStudioModelRenderer + 0x48 );
			DWORD dwOld;

			VirtualProtect ( pStudioRenderModel, 4, PAGE_EXECUTE_READWRITE, &dwOld );
			*pStudioRenderModel = ( DWORD )*StudioRenderModel;
			VirtualProtect ( pStudioRenderModel, 4, dwOld, &dwOld );
			dwStudioRenderFinal = *( DWORD* )( dwStudioModelRenderer + 0x4C );
		}

		SDK::Interfaces::g_Studio.SetChromeOrigin ( );
	}

	void ConsolePrintColor ( BYTE R, BYTE G, BYTE B, char *String )
	{
		PColor24 Ptr = SDK::Interfaces::Console_TextColor;
		TColor24 DefaultColor = *Ptr;

		Ptr->R = R;
		Ptr->G = G;
		Ptr->B = B;

		SDK::Interfaces::g_pEngine->Con_Printf ( "%s", String );

		*Ptr = DefaultColor;
	}

	void ConsolePrintColor ( BYTE R, BYTE G, BYTE B, DWORD String )
	{
		PColor24 Ptr = SDK::Interfaces::Console_TextColor;
		TColor24 DefaultColor = *Ptr;

		Ptr->R = R;
		Ptr->G = G;
		Ptr->B = B;

		SDK::Interfaces::g_pEngine->Con_Printf ( "%d", String );

		*Ptr = DefaultColor;
	}

	void ConsolePrintColor ( BYTE R, BYTE G, BYTE B, int String )
	{
		PColor24 Ptr = SDK::Interfaces::Console_TextColor;
		TColor24 DefaultColor = *Ptr;

		Ptr->R = R;
		Ptr->G = G;
		Ptr->B = B;

		SDK::Interfaces::g_pEngine->Con_Printf ( "%d", String );

		*Ptr = DefaultColor;
	}

	void ConsolePrintColor ( BYTE R, BYTE G, BYTE B, float String )
	{
		PColor24 Ptr = SDK::Interfaces::Console_TextColor;
		TColor24 DefaultColor = *Ptr;

		Ptr->R = R;
		Ptr->G = G;
		Ptr->B = B;

		SDK::Interfaces::g_pEngine->Con_Printf ( "%g", String );

		*Ptr = DefaultColor;
	}

	GameInfo_t BuildInfo;
}

Vars g_Vars;
```

`Client.h`:

```h
#pragma once

#include "Main.h"

namespace Client
{
	extern DWORD dwStudioModelRenderer;
	extern DWORD dwStudioRenderFinal;

	extern bool FirstFrame;

	extern bool SnapShot;
	extern bool ScreenShot;
	extern bool SteamScreenShot;

	void HUD_Frame ( double time );
	void HUD_Redraw ( float time, int intermission );
	void HUD_PostRunCmd ( local_state_s *from, local_state_s *to, usercmd_s *cmd, int runfuncs, double time, unsigned int random_seed );

	int HUD_AddEntity ( int type, cl_entity_s *ent, const char *modelname );
	int HUD_Key_Event ( int down, int keynum, const char *pszCurrentBinding );

	void CL_CreateMove ( float frametime, usercmd_s *cmd, int active );

	void V_CalcRefdef ( ref_params_s *pparams );

	void StudioEntityLight ( alight_s *plight );
	void StudioRenderModel ( );
	void SetChromeOrigin ( );

	void ConsolePrintColor ( BYTE R, BYTE G, BYTE B, char *String );
	void ConsolePrintColor ( BYTE R, BYTE G, BYTE B, DWORD String );
	void ConsolePrintColor ( BYTE R, BYTE G, BYTE B, int String );
	void ConsolePrintColor ( BYTE R, BYTE G, BYTE B, float String );

	extern GameInfo_t BuildInfo;
}
```

`Crosshair.cpp`:

```cpp
#include "Crosshair.h"

namespace Client
{
	namespace Functions
	{
		namespace Visuals
		{
			int Crosshair::Size;
			int Crosshair::Gap;
			int Crosshair::Thickness;
			BYTE Crosshair::Color[4];

			void Crosshair::SetSettings ( )
			{
				Size = ( int )g_Vars.Crosshair.Size;
				Gap = ( int )g_Vars.Crosshair.Gap;
				Thickness = ( int )g_Vars.Crosshair.Thickness;

				Color[0] = BYTE ( g_Vars.Crosshair.Color[0] );
				Color[1] = BYTE ( g_Vars.Crosshair.Color[1] );
				Color[2] = BYTE ( g_Vars.Crosshair.Color[2] );
				Color[3] = BYTE ( g_Vars.Crosshair.Color[3] );
			}

			void Crosshair::DrawCrosshair ( const int &x, const int &y, BYTE R, BYTE G, BYTE B, BYTE A )
			{
				int thickness = Thickness - 1;

				if ( g_Vars.Crosshair.Dynamic )
				{
					int Recoil = int ( g_Info->GetVectorPunchAngles ( )[0] * g_Vars.Crosshair.DynamicScale );

					Renderer::g_Drawing->FillArea ( x + Recoil - Gap - Size + 1 - thickness, y - thickness, Size, Thickness, R, G, B, A );
					Renderer::g_Drawing->FillArea ( x - Recoil + Gap, y - thickness, Size, Thickness, R, G, B, A );
					Renderer::g_Drawing->FillArea ( x - thickness, y + Recoil - Gap - Size + 1 - thickness, Thickness, Size, R, G, B, A );
					Renderer::g_Drawing->FillArea ( x - thickness, y - Recoil + Gap, Thickness, Size, R, G, B, A );
				}
				else
				{
					Renderer::g_Drawing->FillArea ( x - Gap - Size + 1 - thickness, y - thickness, Size, Thickness, R, G, B, A );
					Renderer::g_Drawing->FillArea ( x + Gap, y - thickness, Size, Thickness, R, G, B, A );
					Renderer::g_Drawing->FillArea ( x - thickness, y - Gap - Size + 1 - thickness, Thickness, Size, R, G, B, A );
					Renderer::g_Drawing->FillArea ( x - thickness, y + Gap, Thickness, Size, R, G, B, A );
				}
			}

			void Crosshair::DrawDot ( const int &x, const int &y, BYTE R, BYTE G, BYTE B, BYTE A )
			{
				int thickness = Thickness - 1;

				Renderer::g_Drawing->FillArea ( x - thickness, y - thickness, Thickness, Thickness, R, G, B, A );
			}

			void Crosshair::HUD_Redraw ( )
			{
				if ( !g_Vars.Crosshair.Snipers && g_Info->GetWeaponListSnipers ( ) ) return;
				if ( g_Info->GetFOV ( ) == 40 || g_Info->GetFOV ( ) == 10 || g_Info->GetFOV ( ) == 15 ) return;

				SetSettings ( );

				int x = SDK::Interfaces::g_Screen.iWidth / 2;
				int y = SDK::Interfaces::g_Screen.iHeight / 2;

				if ( g_Vars.Crosshair.Outline )
				{
					DrawCrosshair ( x - 1, y, 0, 0, 0, Color[3] );
					DrawCrosshair ( x, y - 1, 0, 0, 0, Color[3] );
					DrawCrosshair ( x + 1, y, 0, 0, 0, Color[3] );
					DrawCrosshair ( x, y + 1, 0, 0, 0, Color[3] );

					DrawCrosshair ( x - 1, y - 1, 0, 0, 0, Color[3] );
					DrawCrosshair ( x - 1, y + 1, 0, 0, 0, Color[3] );
					DrawCrosshair ( x + 1, y - 1, 0, 0, 0, Color[3] );
					DrawCrosshair ( x + 1, y + 1, 0, 0, 0, Color[3] );
				}

				DrawCrosshair ( x, y, Color[0], Color[1], Color[2], Color[3] );

				if ( g_Vars.Crosshair.Dot )
				{
					if ( g_Vars.Crosshair.Outline )
					{
						DrawDot ( x - 1, y, 0, 0, 0, Color[3] );
						DrawDot ( x, y - 1, 0, 0, 0, Color[3] );
						DrawDot ( x + 1, y, 0, 0, 0, Color[3] );
						DrawDot ( x, y + 1, 0, 0, 0, Color[3] );

						DrawDot ( x - 1, y - 1, 0, 0, 0, Color[3] );
						DrawDot ( x + 1, y - 1, 0, 0, 0, Color[3] );
						DrawDot ( x - 1, y + 1, 0, 0, 0, Color[3] );
						DrawDot ( x + 1, y + 1, 0, 0, 0, Color[3] );
					}

					DrawDot ( x, y, Color[0], Color[1], Color[2], Color[3] );
				}
			}
		}
	}
}
```

`Crosshair.h`:

```h
#pragma once

#include "Main.h"

namespace Client
{
	namespace Functions
	{
		namespace Visuals
		{
			class Crosshair
			{
			public:
				static void HUD_Redraw ( );

			private:
				static int Size, Gap;
				static int Thickness;
				static BYTE Color[4];

				static void SetSettings ( );

				static void DrawCrosshair ( const int &x, const int &y, BYTE R, BYTE G, BYTE B, BYTE A );
				static void DrawDot ( const int &x, const int &y, BYTE R, BYTE G, BYTE B, BYTE A );
			};
		}
	}
}
```

`Defines.h`:

```h
#define HPP_ADMIN					1
#define CHECK_ADMIN					0


#define MAX_FILE_WRITE_LENGHT		28
#define FIND_COUNTER_VALUE			100
#define MAX_SUBS_MENU				25
#define MAX_NAME_CHAR				32			

#define CLIENT_FIND_ERROR			"Error #0000. Couldn't find g_pClient pointer."
#define ENGINE_FIND_ERROR			"Error #0001. Couldn't find g_pEngine pointer."
#define STUDIO_FIND_ERROR			"Error #0002. Couldn't find g_pStudio pointer."
#define PPMOVE_PTR_ERROR			"Error #0003. Couldn't find g_pPlayerMove pointer."
#define SVC_MSG_ERROR				"Error #0004. Couldn't find SVCBase pointer."
#define ABSOLUTE_ERROR				"Error #0005. Absolute address error."
#define MSG_READ_CORD				"Error #0006. MSG_ReadCoord."
#define MSG_STR_READING				"Error #0007. MSG_StartBitReading."
#define MSG_END_READING				"Error #0008. MSG_EndBitReading."
#define CONSOLE_ERROR				"Error #0009. Couldn't find GameConsole pointer."
#define GAMEINFO_ERROR				"Error #0010. Couldn't find GameInfo pointer."
#define SPEEDPTR_ERROR				"Error #0011. Couldn't find SpeedPtr pointer."
#define ENGINEMSG_ERROR				"Error #0012. Couldn't find %s."

#define LOG_DIR_PATH				"\\Logs"
#define SETTINGS_DIR_PATH			"\\Settings"

#define LOG_INJECT_PATH				"\\Logs\\Inject.log"
#define MAIN_PATH					"\\Settings\\Main.ini"
#define FUNCTIONS_PATH				"\\Settings\\Functions.ini"
#define VISUALS_PATH				"\\Settings\\Visuals.ini"
#define MISC_PATH					"\\Settings\\Misc.ini"
#define AIMBOT_PATH					"\\Settings\\AimBot.ini"
#define TRIGGERBOT_PATH				"\\Settings\\TriggerBot.ini"

#define HPP							"[Hpp] "
#define SETTINGS_RELOADED_ENG		"Settings successfully reloaded.\n"
#define SETTINGS_RELOADED_RUS		"Настройки успешно перезагружены.\n"
#define SETTINGS_SAVED_ENG			"Settings successfully saved.\n"
#define SETTINGS_SAVED_RUS			"Настройки успешно сохранены.\n"

#define DELETE_MOD(name)			delete name; name = nullptr

#define GLOCK18_BURST				(1 << 1)
#define M4A1_SILENCER				(1 << 2)
#define USP_SILENCER				(1 << 0)
#define ELITE_LEFT					(1 << 4)

#define WALL_PEN0					0
#define WALL_PEN1					1
#define WALL_PEN2					2
	
#define MAX_WEAPON_LIST				29
#define MAX_WEAPON_NAME				32

#define MAX_ENTITY					1024
#define MAX_SOUNDS					1024

#define TERRORIST					1
#define CT							2
#define SPECTATOR					0

#define WEAPONLIST_P228				1
#define	WEAPONLIST_UNKNOWN1			2
#define	WEAPONLIST_SCOUT			3
#define	WEAPONLIST_HEGRENADE		4
#define	WEAPONLIST_XM1014			5
#define	WEAPONLIST_C4				6
#define	WEAPONLIST_MAC10			7
#define	WEAPONLIST_AUG				8
#define	WEAPONLIST_SMOKEGRENADE		9
#define	WEAPONLIST_ELITE			10
#define	WEAPONLIST_FIVESEVEN		11
#define	WEAPONLIST_UMP45			12
#define	WEAPONLIST_SG550			13
#define	WEAPONLIST_GALIL			14
#define	WEAPONLIST_FAMAS			15
#define	WEAPONLIST_USP				16
#define	WEAPONLIST_GLOCK18			17
#define	WEAPONLIST_AWP				18
#define	WEAPONLIST_MP5				19
#define	WEAPONLIST_M249				20
#define	WEAPONLIST_M3				21
#define	WEAPONLIST_M4A1				22
#define	WEAPONLIST_TMP				23
#define	WEAPONLIST_G3SG1			24
#define	WEAPONLIST_FLASHBANG		25
#define	WEAPONLIST_DEAGLE			26
#define	WEAPONLIST_SG552			27
#define	WEAPONLIST_AK47				28
#define	WEAPONLIST_KNIFE			29
#define	WEAPONLIST_P90				30

#define CLIPCAP_AK47				30
#define CLIPCAP_AUG					30
#define CLIPCAP_AWP					10
#define CLIPCAP_DEAGLE				7
#define CLIPCAP_ELITE				15
#define CLIPCAP_FIVESEVEN			20
#define CLIPCAP_G3SG1				20
#define CLIPCAP_GLOCK18				20
#define CLIPCAP_M249				100
#define CLIPCAP_M3					8
#define CLIPCAP_M4A1				30
#define CLIPCAP_MAC10				30
#define CLIPCAP_MP5					30
#define CLIPCAP_P228				13
#define CLIPCAP_P90					50
#define CLIPCAP_SCOUT				10
#define CLIPCAP_SG550				30
#define CLIPCAP_SG552				30
#define CLIPCAP_TMP					30
#define CLIPCAP_UMP45				25
#define CLIPCAP_USP					12
#define CLIPCAP_XM1014				7
#define CLIPCAP_GALIL				35
#define CLIPCAP_FAMAS				25

#define BULLET_NONE					0
#define BULLET_AK47					11
#define BULLET_AUG					12
#define BULLET_AWP					10
#define BULLET_DEAGLE				13
#define BULLET_ELITE				1
#define BULLET_FIVESEVEN			15
#define BULLET_G3SG1				11
#define BULLET_GLOCK18				1
#define BULLET_M249					12
#define BULLET_M4A1					12
#define BULLET_MAC10				9
#define BULLET_MP5					1
#define BULLET_P228					15
#define BULLET_P90					14
#define BULLET_SCOUT				11
#define BULLET_SG550				12
#define BULLET_SG552				12
#define BULLET_TMP					1
#define BULLET_UMP45				9
#define BULLET_USP					9
#define BULLET_M3					0
#define BULLET_XM1014				0
#define BULLET_GALIL				12
#define BULLET_FAMAS				12

#define SOUND_PACKET_VOLUME			255
#define SOUND_PACKET_ATTENUATION	1.0f
#define SOUND_PACKET_PITCH			100

#define M_PI_F						3.14159265358979323846f
#define M_PI						3.14159265358979323846

#define VectorSubtract(a, b, c)\
{\
	(c)[0] = (a)[0] - (b)[0];\
	(c)[1] = (a)[1] - (b)[1];\
	(c)[2] = (a)[2] - (b)[2];\
}

#define VectorTransform(a, b, c)\
{\
	(c)[0] = DotProduct((a), (b)[0]) + (b)[0][3];\
	(c)[1] = DotProduct((a), (b)[1]) + (b)[1][3];\
	(c)[2] = DotProduct((a), (b)[2]) + (b)[2][3];\
}

#define VectorLengthSquared(v)		((v)[0] * (v)[0] + (v)[1] * (v)[1] + (v)[2] * (v)[2])

#define POW(x)						((x) * (x))
#define BIT(n)						(1 << (n))

#define MENU_ENTRY_KEY				0x5B15E
#define SUBM_ENTRY_KEY				0x1DC42

#define SND_FL_VOLUME				BIT(0)
#define SND_FL_ATTENUATION			BIT(1)
#define SND_FL_LARGE_INDEX			BIT(2)
#define SND_FL_PITCH				BIT(3)
#define SND_FL_SENTENCE				BIT(4)
#define SND_FL_STOP					BIT(5)
#define SND_FL_CHANGE_VOL			BIT(6)
#define SND_FL_CHANGE_PITCH			BIT(7)
#define SND_FL_SPAWNING				BIT(8)

#define FL_NONE						0
#define FL_OUTLINE					1
#define FL_CENTER					2

#define PLAYER_FATAL_FALL_SPEED		980.0f
#define PLAYER_MAX_SAFE_FALL_SPEED	504.8f

#define DAMAGE_FOR_FALL_SPEED		100.0f / ( PLAYER_FATAL_FALL_SPEED - PLAYER_MAX_SAFE_FALL_SPEED )

#define DOWN						1000
#define UP							1001

#define ENGLISH						2000
#define RUSSIAN						2001

#define	K_POINT						46
#define K_COMMA						44
#define K_0							48
#define K_1							49
#define K_2							50
#define K_3							51
#define K_4							52
#define K_5							53
#define K_6							54
#define K_7							55
#define K_8							56
#define K_9							57
#define K_BRACKET_LEFT				91
#define K_BRACKET_RIGHT				93
#define K_A							97
#define K_B							98
#define K_C							99
#define K_D							100
#define K_E							101
#define K_F							102
#define K_G							103
#define K_H							104
#define K_I							105
#define K_J							106
#define K_K							107
#define K_L							108
#define K_M							109
#define K_N							110
#define K_O							111
#define K_P							112
#define K_Q							113
#define K_R							114
#define K_S							115
#define K_T							116
#define K_U							117
#define K_V							118
#define K_W							119
#define K_X							120
#define K_Y							121
#define K_Z							122

#define	SVC_BAD						0
#define	SVC_NOP						1
#define	SVC_DISCONNECT				2
#define	SVC_EVENT					3
#define	SVC_VERSION					4
#define	SVC_SETVIEW					5
#define	SVC_SOUND					6
#define	SVC_TIME					7
#define	SVC_PRINT					8
#define	SVC_STUFFTEXT				9
#define	SVC_SETANGLE				10
#define	SVC_SERVERINFO				11
#define	SVC_LIGHTSTYLE				12
#define	SVC_UPDATEUSERINFO			13
#define	SVC_DELTADESCRIPTION		14
#define	SVC_CLIENTDATA				15
#define	SVC_STOPSOUND				16
#define	SVC_PINGS					17
#define	SVC_PARTICLE				18
#define	SVC_DAMAGE					19
#define	SVC_SPAWNSTATIC				20
#define	SVC_EVENT_RELIABLE			21
#define	SVC_SPAWNBASELINE			22
#define	SVC_TEMPENTITY				23
#define	SVC_SETPAUSE				24
#define	SVC_SIGNONNUM				25
#define	SVC_CENTERPRINT				26
#define	SVC_KILLEDMONSTER			27
#define	SVC_FOUNDSECRET				28
#define	SVC_SPAWNSTATICSOUND		29
#define	SVC_INTERMISSION			30
#define	SVC_FINALE					31
#define	SVC_CDTRACK					32
#define	SVC_RESTORE					33
#define	SVC_CUTSCENE				34
#define	SVC_WEAPONANIM				35
#define	SVC_DECALNAME				36
#define	SVC_ROOMTYPE				37
#define	SVC_ADDANGLE				38
#define	SVC_NEWUSERMSG				39
#define	SVC_PACKETENTITIES			40
#define	SVC_DELTAPACKETENTITIES		41
#define	SVC_CHOKE					42
#define	SVC_RESOURCELIST			43
#define	SVC_NEWMOVEVARS				44
#define	SVC_RESOURCEREQUEST			45
#define	SVC_CUSTOMIZATION			46
#define	SVC_CROSSHAIRANGLE			47
#define	SVC_SOUNDFADE				48
#define	SVC_FILETXFERFAILED			49
#define	SVC_HLTV					50
#define	SVC_DIRECTOR				51
#define	SVC_VOICEINIT				52
#define	SVC_VOICEDATA				53
#define	SVC_SENDEXTRAINFO			54
#define	SVC_TIMESCALE				55
#define	SVC_RESOURCELOCATION		56
#define	SVC_SENDCVARVALUE			57
#define	SVC_SENDCVARVALUE2			58

#define DONT_SEE_FLASH_PERCENT		80
#define NORMAL_FOV					90

#define TraceEdge( x, y ){\
	Vector Start = SDK::Interfaces::g_pPlayerMove->origin;\
	Vector AirTemp = SDK::Interfaces::g_pPlayerMove->origin;\
	AirTemp[2] = -4096.0f;\
	pmtrace_t *pTrace = SDK::Interfaces::g_pEngine->PM_TraceLine ( Start, AirTemp, 1, ( SDK::Interfaces::g_pPlayerMove->flags & FL_DUCKING ) ? 1 : 0, -1 );\
	vec3_t vDis = ( AirTemp - SDK::Interfaces::g_pPlayerMove->origin ) * pTrace->fraction;\
	Start[2] -= 0.1f;\
	Start[2] -= -vDis[2];\
	Vector End = Start;\
	End[1] +=x * mind;\
	End[0] +=y * mind;\
	pmtrace_s* pTrace_s = SDK::Interfaces::g_pEngine->PM_TraceLine ( End, Start, 1, ( SDK::Interfaces::g_pPlayerMove->flags & FL_DUCKING ) ? 1 : 0, -1 );\
	if( !( pTrace_s->startsolid ) ) mind = ( pTrace_s->endpos - Start ).LengthXY ( ); }

#define StudioRenderFinal() _asm { mov ecx, dwTemp } _asm { call [dwStudioRenderFinal] }

```

`Drawing.h`:

```h
#pragma once

#include "Main.h"

namespace Renderer
{
	class Drawing
	{
	public:
		void FillArea ( int x, int y, int w, int h, BYTE R, BYTE G, BYTE B, BYTE A );

		inline void Box ( int x, int y, int w, int h, int lw, BYTE R, BYTE G, BYTE B, BYTE A )
		{
			FillArea ( x, y, w, lw, R, G, B, A );
			FillArea ( x + w - lw, y + lw, lw, h - lw, R, G, B, A );
			FillArea ( x, y + lw, lw, h - lw, R, G, B, A );
			FillArea ( x + lw, y + h - lw, w - lw * 2, lw, R, G, B, A );
		}

		inline void BoxOutline ( int x, int y, int w, int h, int lw, BYTE R, BYTE G, BYTE B, BYTE A )
		{
			Box ( x - 1, y - 1, w + 2, h + 2, lw + 2, 0, 0, 0, A );
			Box ( x, y, w, h, lw, R, G, B, A );
		}

		inline void BoxCorner ( int x, int y, int w, int h, int lw, BYTE R, BYTE G, BYTE B, BYTE A )
		{
			FillArea ( x, y, w / 4, lw, R, G, B, A );
			FillArea ( x + w - w / 4, y, w / 4, lw, R, G, B, A );
			FillArea ( x, y + lw, lw, h / 4 - lw, R, G, B, A );
			FillArea ( x, y + h - h / 4, lw, h / 4, R, G, B, A );
			FillArea ( x + w - lw, y + lw, lw, h / 4 - lw, R, G, B, A );
			FillArea ( x + w - lw, y + h - h / 4, lw, h / 4, R, G, B, A );
			FillArea ( x + lw, y + h - lw, w / 4 - lw, lw, R, G, B, A );
			FillArea ( x + w - w / 4, y + h - lw, w / 4 - lw, lw, R, G, B, A );
		}

		inline void BoxCornerOutline ( int x, int y, int w, int h, int lw, BYTE R, BYTE G, BYTE B, BYTE A )
		{
			BoxCorner ( x - 1, y + 1, w, h, lw, 0, 0, 0, A );
			BoxCorner ( x - 1, y - 1, w, h, lw, 0, 0, 0, A );
			BoxCorner ( x + 1, y + 1, w, h, lw, 0, 0, 0, A );
			BoxCorner ( x + 1, y - 1, w, h, lw, 0, 0, 0, A );

			BoxCorner ( x, y, w, h, lw, R, G, B, A );
		}

		inline void Circle ( int x, int y, int rad, int amount, int lw, BYTE R, BYTE G, BYTE B, BYTE A )
		{
			glDisable ( GL_TEXTURE_2D );
			glEnable ( GL_BLEND );
			glBlendFunc ( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
			glColor4ub ( R, G, B, A );
			glLineWidth ( GLfloat ( lw ) );
			glBegin ( GL_LINE_LOOP );

			for ( int i = 0; i < amount; ++i )
			{
				double Angle = 2.0 * M_PI * i / amount;
				double X = rad * cos ( Angle );
				double Y = rad * sin ( Angle );

				glVertex2d ( x + X, y + Y );
			}

			glEnd ( );
			glEnable ( GL_TEXTURE_2D );
			glDisable ( GL_BLEND );
		}
	};

	extern Drawing *g_Drawing;
}
```

`ESP.cpp`:

```cpp
#include "ESP.h"

namespace Client
{
	namespace Functions
	{
		namespace Visuals
		{
			EntityStruct ESP::Entity[MAX_ENTITY];
			SoundStruct ESP::Sound[MAX_SOUNDS];

			int ESP::EntityIndex;
			int ESP::SoundIndex;

			BYTE ESP::BoxColor[3];
			BYTE ESP::FontColor[4];

			void ESP::PlayerFilters ( const int& Index, bool& RetFlag )
			{
				RetFlag = true;

				bool OnlyEnemy = g_Vars.ESP.Player == 1.0f && g_Info->GetPlayerTeamByIndex ( Index ) == g_Info->GetPlayerTeam ( );
				bool OnlyVisible = g_Vars.ESP.PlayerVisibleOnly && !g_Info->GetVisibilityEntityByIndex ( Index );

				if ( g_Info->GetAliveLocal ( ) && ( OnlyEnemy || OnlyVisible ) )
				{
					return;
				}

				RetFlag = false;
			}

			void ESP::GetColorPlayerBox ( const int &Index )
			{
				for ( int i = 0; i < sizeof ( BoxColor ); ++i )
				{
					if ( g_Info->GetPlayerTeamByIndex ( Index ) == TERRORIST && g_Info->GetVisibilityEntityByIndex ( Index ) )
					{
						BoxColor[i] = BYTE ( g_Vars.ESP.ColorTVis[i] );
					}
					else if ( g_Info->GetPlayerTeamByIndex ( Index ) == TERRORIST )
					{
						BoxColor[i] = BYTE ( g_Vars.ESP.ColorTHide[i] );
					}
					else if ( g_Info->GetPlayerTeamByIndex ( Index ) == CT && g_Info->GetVisibilityEntityByIndex ( Index ) )
					{
						BoxColor[i] = BYTE ( g_Vars.ESP.ColorCTVis[i] );
					}
					else if ( g_Info->GetPlayerTeamByIndex ( Index ) == CT )
					{
						BoxColor[i] = BYTE ( g_Vars.ESP.ColorCTHide[i] );
					}
					else if ( g_Info->GetVisibilityEntityByIndex ( Index ) )
					{
						BoxColor[i] = 255;
					}
					else
					{
						BoxColor[i] = 180;
					}
				}
			}

			void ESP::SetFontColor ( )
			{
				FontColor[0] = g_Vars.ESP.FontColor[0];
				FontColor[1] = g_Vars.ESP.FontColor[1];
				FontColor[2] = g_Vars.ESP.FontColor[2];
				FontColor[3] = g_Vars.ESP.FontColor[3];
			}

			void ESP::GetC4TimerValue ( )
			{
				if ( g_Vars.ESP.C4Timer == 1.0f )
				{
					g_Info->SetC4Timer ( 0.0f );
				}
				else if ( g_Vars.ESP.C4Timer >= 2.0f )
				{
					g_Info->SetC4Timer ( g_Vars.ESP.C4TimerValue );
				}
			}

			void ESP::PlayerBox ( const int &Index, const int &x, const int &w, const int &PlayerBoxHeight, const Vector2D &ScreenTop )
			{
				GetColorPlayerBox ( Index );

				if ( g_Vars.ESP.PlayerBoxFilled )
				{
					Renderer::g_Drawing->FillArea ( x, ( int )ScreenTop[1], w, PlayerBoxHeight,
						BoxColor[0], BoxColor[1], BoxColor[2], BYTE ( g_Vars.ESP.PlayerBoxFilled ) );
				}

				if ( g_Vars.ESP.PlayerBox == 1.0f )
				{
					Renderer::g_Drawing->Box ( x, ( int )ScreenTop[1], w, PlayerBoxHeight, 1, BoxColor[0], BoxColor[1], BoxColor[2], 255 );
				}
				else if ( g_Vars.ESP.PlayerBox == 2.0f )
				{
					Renderer::g_Drawing->BoxOutline ( x, ( int )ScreenTop[1], w, PlayerBoxHeight, 1, BoxColor[0], BoxColor[1], BoxColor[2], 255 );
				}
				else if ( g_Vars.ESP.PlayerBox == 3.0f )
				{
					Renderer::g_Drawing->BoxCorner ( x, ( int )ScreenTop[1], w, PlayerBoxHeight, 1, BoxColor[0], BoxColor[1], BoxColor[2], 255 );
				}
				else if ( g_Vars.ESP.PlayerBox >= 4.0f )
				{
					Renderer::g_Drawing->BoxCornerOutline ( x, ( int )ScreenTop[1], w, PlayerBoxHeight, 1, BoxColor[0], BoxColor[1], BoxColor[2], 255 );
				}
			}

			void ESP::PlayerName ( const int &Index, const int &PlayerBoxHeight, const Vector2D &ScreenTop )
			{
				int y = PlayerBoxHeight - 5 + ( int )ScreenTop[1];

				if ( strstr ( g_Info->GetPlayerInfoByIndex ( Index ).name, "kilabeez" ) )
				{
					Renderer::g_Verdana->Print ( ( int )ScreenTop[0], y, 0, 255, 0, FontColor[3],
						g_Vars.ESP.FontOutline ? FL_CENTER | FL_OUTLINE : FL_CENTER, g_Info->GetPlayerInfoByIndex ( Index ).name );

					return;
				}

				if ( strstr ( g_Info->GetPlayerInfoByIndex ( Index ).name, "Fletia" ) )
				{
					Renderer::g_Verdana->Print ( ( int )ScreenTop[0], y, 255, 192, 203, FontColor[3],
						g_Vars.ESP.FontOutline ? FL_CENTER | FL_OUTLINE : FL_CENTER, g_Info->GetPlayerInfoByIndex ( Index ).name );

					return;
				}

				Renderer::g_Verdana->Print ( ( int )ScreenTop[0], y, FontColor[0], FontColor[1], FontColor[2],
					FontColor[3], g_Vars.ESP.FontOutline ? FL_CENTER | FL_OUTLINE : FL_CENTER, g_Info->GetPlayerInfoByIndex ( Index ).name );
			}

			void ESP::PlayerWeapon ( cl_entity_s *Entity, const Vector2D &ScreenBot, const Vector2D &ScreenTop )
			{
				float y = ScreenBot[1] + ( ( g_Vars.ESP.PlayerDistance ? 24.0f : 12.0f ) - ( ScreenBot[1] - ScreenTop[1] ) );

				int SequenceInfo[] =
				{
					0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
					0, 1, 2, 0, 1, 2, 0, 1, 2, 0,
					1, 2, 0, 1, 1, 2, 0, 1, 1, 2,
					0, 1, 2, 0, 1, 2, 0, 1, 2, 0,
					1, 2, 0, 1, 2, 0, 1, 2, 0, 1,
					2, 0, 1, 2, 0, 0, 0, 4, 0, 4,
					0, 5, 0, 5, 0, 0, 1, 1, 2, 0,
					1, 1, 2, 0, 1, 0, 1, 0, 1, 2,
					0, 1, 2, 3, 3, 3, 3, 3, 3, 3,
					3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
					3
				};

				if ( SequenceInfo[Entity->curstate.sequence] == 2 )
				{
					Renderer::g_Verdana->Print ( ( int )ScreenTop[0], ( int )y + 12, 255, 80, 80,
						255, g_Vars.ESP.FontOutline ? FL_CENTER | FL_OUTLINE : FL_CENTER, "reloading" );
				}
				else if ( SequenceInfo[Entity->curstate.sequence] == 5 )
				{
					Renderer::g_Verdana->Print ( ( int )ScreenTop[0], ( int )y + 12, 255, 80, 80,
						255, g_Vars.ESP.FontOutline ? FL_CENTER | FL_OUTLINE : FL_CENTER, "planting c4" );
				}

				model_s *Model = SDK::Interfaces::g_pStudio->GetModelByIndex ( Entity->curstate.weaponmodel );

				if ( Model && Model->name )
				{
					char WeaponName[64];

					int len = lstrlenA ( SDK::Interfaces::g_pStudio->GetModelByIndex ( Entity->curstate.weaponmodel )->name + 9 ) - 3;

					lstrcpynA ( WeaponName, SDK::Interfaces::g_pStudio->GetModelByIndex ( Entity->curstate.weaponmodel )->name + 9, len );

					WeaponName[len] = '\0';

					Renderer::g_Verdana->Print ( ( int )ScreenTop[0], ( int )y, FontColor[0], FontColor[1],
						FontColor[2], FontColor[3], g_Vars.ESP.FontOutline ? FL_CENTER | FL_OUTLINE : FL_CENTER, WeaponName );
				}
			}

			float ESP::GetPlayerDistance ( const BYTE &Index, const bool &Meters )
			{
				cl_entity_s *Entity = SDK::Interfaces::g_pEngine->GetEntityByIndex ( Index );

				float flDistance = g_Info->GetDistanceToEntity ( Entity->origin );

				return Meters ? flDistance < 0.0f ? 0.0f : flDistance * 0.025f : flDistance < 0.0f ? 0.0f : flDistance;
			}

			void ESP::PlayerDistance ( const int &Index, const Vector2D &ScreenBot, const Vector2D &ScreenTop )
			{
				float y = ScreenBot[1] + ( 12.0f - ( ScreenBot[1] - ScreenTop[1] ) );

				int DistanceUnits = ( int )GetPlayerDistance ( Index, false );
				int DistanceMeters = ( int )GetPlayerDistance ( Index, true );

				BYTE PlayerDistanceColor[3] = { 255, 255, 255 };

				if ( DistanceUnits >= 0 && DistanceUnits <= 1000 )
				{
					PlayerDistanceColor[0] = 255;
					PlayerDistanceColor[1] = DistanceUnits >= 50 ? ( BYTE )Utils::Interp ( 50.0f, ( float )DistanceUnits, 1000.0f, 255.0f, 80.0f ) : 255;
					PlayerDistanceColor[2] = DistanceUnits <= 50 ? ( BYTE )Utils::Interp ( 0.0f, ( float )DistanceUnits, 50.0f, 255.0f, 80.0f ) : 80;
				}
				else if ( DistanceUnits > 1000 )
				{
					PlayerDistanceColor[0] = 255;
					PlayerDistanceColor[1] = 80;
					PlayerDistanceColor[2] = 80;
				}

				if ( g_Vars.ESP.PlayerDistance == 1.0f )
				{
					Renderer::g_Verdana->Print ( ( int )ScreenTop[0], ( int )y, PlayerDistanceColor[0], PlayerDistanceColor[1],
						PlayerDistanceColor[2], 255, g_Vars.ESP.FontOutline ? FL_CENTER | FL_OUTLINE : FL_CENTER, "%d u", DistanceUnits );
				}
				else if ( g_Vars.ESP.PlayerDistance >= 2.0f )
				{
					Renderer::g_Verdana->Print ( ( int )ScreenTop[0], ( int )y, PlayerDistanceColor[0], PlayerDistanceColor[1],
						PlayerDistanceColor[2], 255, g_Vars.ESP.FontOutline ? FL_CENTER | FL_OUTLINE : FL_CENTER, "%d m", DistanceMeters );
				}
			}

			void ESP::WorldNades ( const int &Index, const Vector2D &EntityScreen )
			{
				Vector uppt = Entity[Index].vOrigin - g_Info->GetVectorEyePosition ( );

				float Length = uppt.Length ( );

				if ( g_Vars.ESP.WorldNades && Entity[Index].Type == 3 )
				{
					if ( strstr ( Entity[Index].Name, "hegrenade" ) )
					{
						Renderer::g_Drawing->Circle ( ( int )EntityScreen[0], ( int )EntityScreen[1], int ( 4000.0f / Length ), 100, 2, 255, 50, 50, 255 );
					}
					else if ( strstr ( Entity[Index].Name, "flash" ) )
					{
						Renderer::g_Drawing->Circle ( ( int )EntityScreen[0], ( int )EntityScreen[1], int ( 4000.0f / Length ), 100, 2, 255, 255, 255, 255 );
					}
					else if ( strstr ( Entity[Index].Name, "smoke" ) )
					{
						Renderer::g_Drawing->Circle ( ( int )EntityScreen[0], ( int )EntityScreen[1], int ( 4000.0f / Length ), 100, 2, 50, 255, 50, 255 );
					}
				}
			}

			void ESP::WorldWeapons ( const int& Index, const Vector2D& EntityScreen, const char* Weapon )
			{
				if ( strstr ( Entity[Index].Name, Weapon ) )
				{
					Renderer::g_Drawing->Box ( ( int )EntityScreen[0] - 2, ( int )EntityScreen[1], 6, 6, 1, 0, 0, 0, 255 );
					Renderer::g_Drawing->FillArea ( ( int )EntityScreen[0] - 1, ( int )EntityScreen[1] + 1, 4, 4, 255, 120, 50, 255 );

					Renderer::g_Verdana->Print ( ( int )EntityScreen[0], ( int )EntityScreen[1] + 15, FontColor[0],
						FontColor[1], FontColor[2], FontColor[3], g_Vars.ESP.FontOutline ? FL_CENTER | FL_OUTLINE : FL_CENTER, Weapon );
				}
			}

			void ESP::WorldC4 ( const int& Index, const Vector2D& EntityScreen )
			{
				if ( strstr ( Entity[Index].Name, "backpack" ) )
				{
					Renderer::g_Drawing->Box ( ( int )EntityScreen[0] - 2, ( int )EntityScreen[1], 6, 6, 1, 0, 0, 0, 255 );
					Renderer::g_Drawing->FillArea ( ( int )EntityScreen[0] - 1, ( int )EntityScreen[1] + 1, 4, 4, 255, 0, 0, 255 );

					Renderer::g_Verdana->Print ( ( int )EntityScreen[0], ( int )EntityScreen[1] + 15, FontColor[0],
						FontColor[1], FontColor[2], FontColor[3], g_Vars.ESP.FontOutline ? FL_CENTER | FL_OUTLINE : FL_CENTER, "c4" );
				}
			}

			void ESP::WorldC4Planted ( const int& Index, const Vector2D& EntityScreen )
			{
				if ( strstr ( Entity[Index].Name, "c4" ) )
				{
					Renderer::g_Drawing->Box ( ( int )EntityScreen[0] - 2, ( int )EntityScreen[1], 6, 6, 1, 0, 0, 0, 255 );
					Renderer::g_Drawing->FillArea ( ( int )EntityScreen[0] - 1, ( int )EntityScreen[1] + 1, 4, 4, 255, 0, 0, 255 );

					Renderer::g_Verdana->Print ( ( int )EntityScreen[0], ( int )EntityScreen[1] + 15, FontColor[0],
						FontColor[1], FontColor[2], FontColor[3], g_Vars.ESP.FontOutline ? FL_CENTER | FL_OUTLINE : FL_CENTER, "bomb" );

					if ( g_Vars.ESP.C4Timer && g_Info->GetIsPlanted ( ) )
					{
						Renderer::g_Verdana->Print ( ( int )EntityScreen[0], ( int )EntityScreen[1] + 27, FontColor[0], FontColor[1], FontColor[2],
							FontColor[3], g_Vars.ESP.FontOutline ? FL_CENTER | FL_OUTLINE : FL_CENTER, "time: %.2f", g_Info->GetC4Timer ( ) );
					}
				}
			}

			void ESP::AddEntity ( const char *Name, const Vector &vOrigin, const int &Type )
			{
				if ( EntityIndex < MAX_ENTITY )
				{
					lstrcpy ( Entity[EntityIndex].Name, Name );

					Entity[EntityIndex].vOrigin = vOrigin;
					Entity[EntityIndex].Type = Type;

					++EntityIndex;
				}
				else
					ClearEntity ( );
			}

			void ESP::ClearEntity ( )
			{
				for ( int Index = 0; Index < EntityIndex; ++Index )
				{
					memset ( &Entity[Index].Name, 64, 0 );

					Entity[Index].vOrigin = Vector ( 0.0f );
					Entity[Index].Type = 0;
				}

				EntityIndex = 0;
			}

			void ESP::AddSound ( DWORD64 dwTime, Vector vOrigin, BYTE R, BYTE G, BYTE B )
			{
				if ( SoundIndex < MAX_SOUNDS )
				{
					Sound[SoundIndex].dwTime = dwTime;
					Sound[SoundIndex].vOrigin = vOrigin;
					Sound[SoundIndex].R = R;
					Sound[SoundIndex].G = G;
					Sound[SoundIndex].B = B;

					++SoundIndex;
				}
				else
					ClearSound ( );
			}

			void ESP::ClearSound ( )
			{
				for ( int Index = 0; Index < SoundIndex; ++Index )
				{
					Sound[Index].dwTime = 0;
					Sound[Index].vOrigin = Vector ( 0.0f );
				}

				SoundIndex = 0;
			}

			void ESP::DrawPlayer ( cl_entity_s* Entity )
			{
				bool RetFlag;

				PlayerFilters ( Entity->index, RetFlag );

				if ( RetFlag ) return;

				/*Vector vTop ( Entity->origin[0], Entity->origin[1], Entity->origin[2] + Entity->curstate.mins[2] );
				Vector vBot ( Entity->origin[0], Entity->origin[1], Entity->origin[2] + Entity->curstate.maxs[2] );

				Vector2D ScreenTop, ScreenBot;

				if ( Utils::CalcScreen ( vTop, ScreenTop ) && Utils::CalcScreen ( vBot, ScreenBot ) )
				{
					float Height = ScreenBot[1] - ScreenTop[1];
					float PlayerBoxHeight = g_Info->GetDuckedEntity ( Entity ) ? Height : Height * 0.9f;
					float x = ScreenTop[0] - ( PlayerBoxHeight * 0.25f );
					float w = PlayerBoxHeight * 0.5f;

					if ( g_Vars.ESP.PlayerBox ) PlayerBox ( Entity->index, ( int )x, ( int )w, ( int )PlayerBoxHeight, ScreenTop );
					if ( g_Vars.ESP.PlayerName ) PlayerName ( Entity->index, ( int )PlayerBoxHeight, ScreenTop );
					if ( g_Vars.ESP.PlayerWeapon ) PlayerWeapon ( Entity, ScreenBot, ScreenTop );
					if ( g_Vars.ESP.PlayerDistance ) PlayerDistance ( Entity->index, ScreenBot, ScreenTop );
				}*/

				Vector vOrigin = Entity->origin;
				Vector vHead = g_Info->GetHitBoxByIndex ( Entity->index, 11 );
				
				vOrigin[2] -= 42.0f;
				vHead[2] += 10.0f;

				Vector2D vScreenOrigin, vScreenHead;

				if ( Utils::CalcScreen ( vOrigin, vScreenOrigin ) && Utils::CalcScreen ( vHead, vScreenHead ) )
				{
					float Height = vScreenOrigin[1] - vScreenHead[1];
					float Width = Height * 0.5f;
					float x = vScreenOrigin[0] - Width / 2.0f;

					Renderer::g_Drawing->BoxCorner ( ( int )x, ( int )vScreenHead[1], ( int )Width, ( int )Height, 1, 0, 100, 255, 255 );
				}
			}

			void ESP::DrawWorld ( )
			{
				for ( int Index = 0; Index < EntityIndex; ++Index )
				{
					Vector2D EntityScreen;

					if ( Utils::CalcScreen ( Entity[Index].vOrigin, EntityScreen ) && !Entity[Index].vOrigin.IsZero ( ) )
					{
						if ( g_Vars.ESP.WorldItems && Entity[Index].Type == 1 )
						{
							WorldWeapons ( Index, EntityScreen, "usp" );
							WorldWeapons ( Index, EntityScreen, "glock18" );
							WorldWeapons ( Index, EntityScreen, "deagle" );
							WorldWeapons ( Index, EntityScreen, "p228" );
							WorldWeapons ( Index, EntityScreen, "elite" );
							WorldWeapons ( Index, EntityScreen, "fiveseven" );
							WorldWeapons ( Index, EntityScreen, "m3" );
							WorldWeapons ( Index, EntityScreen, "xm1014" );
							WorldWeapons ( Index, EntityScreen, "mp5" );
							WorldWeapons ( Index, EntityScreen, "tmp" );
							WorldWeapons ( Index, EntityScreen, "p90" );
							WorldWeapons ( Index, EntityScreen, "mac10" );
							WorldWeapons ( Index, EntityScreen, "ump45" );
							WorldWeapons ( Index, EntityScreen, "famas" );
							WorldWeapons ( Index, EntityScreen, "sg552" );
							WorldWeapons ( Index, EntityScreen, "ak47" );
							WorldWeapons ( Index, EntityScreen, "m4a1" );
							WorldWeapons ( Index, EntityScreen, "aug" );
							WorldWeapons ( Index, EntityScreen, "scout" );
							WorldWeapons ( Index, EntityScreen, "awp" );
							WorldWeapons ( Index, EntityScreen, "g3sg1" );
							WorldWeapons ( Index, EntityScreen, "sg550" );
							WorldWeapons ( Index, EntityScreen, "galil" );
							WorldWeapons ( Index, EntityScreen, "m249" );
							WorldWeapons ( Index, EntityScreen, "shield" );
							WorldWeapons ( Index, EntityScreen, "thighpack" );
						}

						if ( g_Vars.ESP.WorldC4 && Entity[Index].Type == 1 )
						{
							WorldC4 ( Index, EntityScreen );
							WorldC4Planted ( Index, EntityScreen );
						}

						WorldNades ( Index, EntityScreen );
					}
				}

				ClearEntity ( );
			}

			void ESP::DrawC4Timer ( )
			{
				Renderer::g_Fonts->Print ( int ( SDK::Interfaces::g_Screen.iWidth / 1.5f ), 15, FontColor[0], FontColor[1],
					FontColor[2], FontColor[3], FL_OUTLINE, "C4Timer: %d", ( int )g_Info->GetC4Timer ( ) );
			}

			void ESP::DrawSound ( )
			{
				for ( int Index = 0; Index < SoundIndex; ++Index )
				{
					Vector uppt = Sound[Index].vOrigin - g_Info->GetVectorEyePosition ( );

					float SoundSize = 10000.0f / uppt.Length ( );

					DWORD64 SoundTime = Sound[Index].dwTime + ( DWORD64 )g_Vars.ESP.SoundFadeTime;

					if ( SoundTime <= GetTickCount64 ( ) )
					{
						Sound[Index].dwTime = 0;
						Sound[Index].vOrigin = Vector ( 0.0f );
					}
					else
					{
						Vector2D SoundScreen;

						float size = Utils::Interp ( ( float )Sound[Index].dwTime, ( float )GetTickCount64 ( ), ( float )SoundTime, SoundSize, 0.0f );

						if ( Utils::CalcScreen ( Sound[Index].vOrigin, SoundScreen ) && !Sound[Index].vOrigin.IsZero ( ) )
						{
							Renderer::g_Drawing->Box ( int ( SoundScreen[0] - ( size / 2.0f ) ), int ( SoundScreen[1] - ( size / 2.0f ) ),
								( int )size, ( int )size, 1, Sound[Index].R, Sound[Index].G, Sound[Index].B,
								BYTE ( Utils::Interp ( float ( Sound[Index].dwTime ), float ( GetTickCount64 ( ) ), ( float )SoundTime, 255.0f, 0.0f ) ) );
						}
					}
				}
			}

			void ESP::HUD_AddEntity ( cl_entity_s *Entity )
			{
				if ( ( g_Vars.ESP.WorldItems || g_Vars.ESP.WorldNades || g_Vars.ESP.WorldC4 ) && Entity->model->name && Entity->model && Entity )
				{
					if ( strstr ( Entity->model->name, "w_" ) )
					{
						char Name[64];

						int len = lstrlenA ( Entity->model->name + 7 ) - 3;

						lstrcpynA ( Name, Entity->model->name + 7, len );

						Name[len] = '\0';

						if ( strstr ( Entity->model->name, "hegrenade" ) )
						{
							AddEntity ( Name, Entity->origin, 3 );
						}
						else if ( strstr ( Entity->model->name, "flash" ) )
						{
							AddEntity ( Name, Entity->origin, 3 );
						}
						else if ( strstr ( Entity->model->name, "smoke" ) )
						{
							AddEntity ( Name, Entity->origin, 3 );
						}
						else
						{
							if ( g_Vars.ESP.WorldItems || g_Vars.ESP.WorldC4 )
								AddEntity ( Name, Entity->origin, 1 );
						}
					}
				}

				if ( g_Vars.ESP.Player && g_Vars.ESP.PlayerBarrel && g_Info->GetValidationEntity ( Entity ) &&
					Entity && Entity->player && Entity->index != g_Info->GetLocalIndex ( ) )
				{
					bool RetFlag;

					PlayerFilters ( Entity->index, RetFlag );

					if ( RetFlag ) return;

					int BeamIndex = SDK::Interfaces::g_pEngine->pEventAPI->EV_FindModelIndex ( "sprites/laserbeam.spr" );

					Vector vEnd, vUp, vRight, vForward;
					Vector vEntityViewOrg = Entity->origin;

					if ( !Entity->curstate.usehull )
					{
						vEntityViewOrg[2] += 17.0f;
					}
					else if ( Entity->curstate.usehull == 1 )
					{
						vEntityViewOrg[2] += 12.0f;
					}

					SDK::Interfaces::g_pEngine->pfnAngleVectors ( Entity->angles, vForward, vRight, vUp );

					vForward[2] = -vForward[2];

					float PlayerBarrelColor[3] =
					{
						0.0f, 0.0f, 0.0f
					};

					if ( g_Info->GetPlayerTeamByIndex ( Entity->index ) == TERRORIST )
					{
						PlayerBarrelColor[0] = 255.0f;
						PlayerBarrelColor[1] = 0.0f;
						PlayerBarrelColor[2] = 0.0f;
					}
					else if ( g_Info->GetPlayerTeamByIndex ( Entity->index ) == CT )
					{
						PlayerBarrelColor[0] = 0.0f;
						PlayerBarrelColor[1] = 0.0f;
						PlayerBarrelColor[2] = 255.0f;
					}
					else
					{
						PlayerBarrelColor[0] = 255.0f;
						PlayerBarrelColor[1] = 255.0f;
						PlayerBarrelColor[2] = 255.0f;
					}

					vEnd = vEntityViewOrg + vForward * 8000.0f;

					SDK::Interfaces::g_pEngine->pEfxAPI->R_BeamPoints ( vEntityViewOrg, vEnd, BeamIndex, 0.001f, 0.9f, 0.0f,
						32.0f, 2.0f, 0, 0.0f, PlayerBarrelColor[0], PlayerBarrelColor[1], PlayerBarrelColor[2] );
				}
			}

			void ESP::HUD_Redraw ( )
			{
				SetFontColor ( );

				if ( g_Vars.ESP.WorldItems || g_Vars.ESP.WorldNades || g_Vars.ESP.WorldC4 )
				{
					DrawWorld ( );
				}

				if ( g_Vars.ESP.Player )
				{
					for ( int Index = 1; Index <= SDK::Interfaces::g_pEngine->GetMaxClients ( ); ++Index )
					{
						cl_entity_s* Entity = SDK::Interfaces::g_pEngine->GetEntityByIndex ( Index );

						if ( g_Info->GetValidationEntity ( Entity ) && Index != g_Info->GetLocalIndex ( ) )
						{
							DrawPlayer ( Entity );
						}
					}
				}

				if ( g_Vars.ESP.C4Timer )
				{
					g_Info->GetIsPlanted ( ) ? DrawC4Timer ( ) : GetC4TimerValue ( );
				}

				if ( g_Vars.ESP.Sound )
				{
					DrawSound ( );
				}
			}

			void ESP::CL_CreateMove ( const float &frametime )
			{
				if ( g_Vars.ESP.C4Timer == 1.0f )
				{
					g_Info->SetC4Timer ( g_Info->GetC4Timer ( ) + frametime );
				}
				else if ( g_Vars.ESP.C4Timer >= 2.0f )
				{
					g_Info->SetC4Timer ( g_Info->GetC4Timer ( ) - frametime );

					if ( g_Info->GetC4Timer ( ) < 0.0f )
						g_Info->SetC4Timer ( 0.0f );
				}
			}
		}
	}
}
```

`ESP.h`:

```h
#pragma once

#include "Main.h"

namespace Client
{
	namespace Functions
	{
		namespace Visuals
		{
			struct EntityStruct
			{
				char Name[64];
				Vector vOrigin;
				int Type;
			};

			struct SoundStruct
			{
				Vector vOrigin;
				DWORD64 dwTime;
				BYTE R, G, B;
			};

			class ESP
			{
			public:
				static void AddSound ( DWORD64 dwTime, Vector vOrigin, BYTE R, BYTE G, BYTE B );
				static void AddEntity ( const char *Name, const Vector &vOrigin, const int &Type );
				static void ClearEntity ( );
				static void ClearSound ( );

				static void HUD_AddEntity ( cl_entity_s *Entity );
				static void HUD_Redraw ( );
				static void CL_CreateMove ( const float &frametime );

			private:
				static EntityStruct Entity[MAX_ENTITY];
				static SoundStruct Sound[MAX_SOUNDS];

				static int EntityIndex, SoundIndex;
				static BYTE BoxColor[3], FontColor[4];

				static void PlayerFilters ( const int& Index, bool& RetFlag );
				static void GetColorPlayerBox ( const int &Index );
				static void SetFontColor ( );
				static float GetPlayerDistance ( const BYTE &Index, const bool &Meters );
				static void GetC4TimerValue ( );

				static void PlayerBox ( const int &Index, const int &x, const int &w, const int &PlayerBoxHeight, const Vector2D &ScreenTop );
				static void PlayerName ( const int &Index, const int &PlayerBoxHeight, const Vector2D &ScreenTop );
				static void PlayerWeapon ( cl_entity_s *Entity, const Vector2D &ScreenBot, const Vector2D &ScreenTop );
				static void PlayerDistance ( const int &Index, const Vector2D &ScreenBot, const Vector2D &ScreenTop );

				static void WorldNades ( const int &Index, const Vector2D &EntityScreen );
				static void WorldWeapons ( const int& Index, const Vector2D& EntityScreen, const char* Weapon );
				static void WorldC4 ( const int& Index, const Vector2D& EntityScreen );
				static void WorldC4Planted ( const int& Index, const Vector2D& EntityScreen );

				static void DrawPlayer ( cl_entity_s* Entity );
				static void DrawWorld ( );
				static void DrawC4Timer ( );
				static void DrawSound ( );
			};
		}
	}
}
```

`Engine.cpp`:

```cpp
#include "Engine.h"

namespace SDK
{
	cl_clientfunc_t *Interfaces::g_pClient = nullptr;
	cl_enginefunc_t *Interfaces::g_pEngine = nullptr;
	engine_studio_api_t *Interfaces::g_pStudio = nullptr;
	playermove_t *Interfaces::g_pPlayerMove = nullptr;
	screenfade_t *Interfaces::g_pScreenFade = nullptr;

	SCREENINFO Interfaces::g_Screen;
	PUserMsg Interfaces::g_pUserMsgBase;
	PEngineMsg Interfaces::g_pEngineMsgBase;
	PColor24 Interfaces::Console_TextColor;
	cl_clientfunc_t Interfaces::g_Client;
	cl_enginefunc_t Interfaces::g_Engine;
	engine_studio_api_t Interfaces::g_Studio;

	namespace Offset
	{
		void Initialize ( HANDLE& hProcessReloadThread )
		{
			int FindCounter = 0;

		StartHook:
			if ( FindCounter >= FIND_COUNTER_VALUE )
			{
				if ( !Interfaces::g_pClient )
				{
					Files::InjectLog ( CLIENT_FIND_ERROR );
					Utils::Error ( true, CLIENT_FIND_ERROR );
				}

				if ( !Interfaces::g_pEngine )
				{
					Files::InjectLog ( ENGINE_FIND_ERROR );
					Utils::Error ( true, ENGINE_FIND_ERROR );
				}

				if ( !Interfaces::g_pStudio )
				{
					Files::InjectLog ( STUDIO_FIND_ERROR );
					Utils::Error ( true, STUDIO_FIND_ERROR );
				}

				if ( !Interfaces::g_pPlayerMove )
				{
					Files::InjectLog ( PPMOVE_PTR_ERROR );
					Utils::Error ( true, PPMOVE_PTR_ERROR );
				}
			}

			Sleep ( 100 );

			++FindCounter;

			if ( Engine::Offset::GetModuleInfo ( ) )
			{
				static bool ClientLog, EngineLog, StudioLog, PlayerMoveLog, UserMsgLog, EngineMsgLog;

				DWORD ClientTable = Engine::Offset::FindClientTable ( );

				if ( ClientTable )
				{
					Interfaces::g_pClient = ( cl_clientfunc_t* )ClientTable;

					if ( !ClientLog )
					{
						Files::InjectLog ( "	g_pClient: 0x%X", Interfaces::g_pClient );

						ClientLog = true;
					}

					Utils::native_memcpy ( &Interfaces::g_Client, Interfaces::g_pClient, sizeof ( cl_clientfunc_t ) );

					if ( Interfaces::g_Client.Initialize )
					{
						DWORD EngineTable = Engine::Offset::FindEngineTable ( );

						if ( EngineTable )
						{
							Interfaces::g_pEngine = ( cl_enginefunc_t* )EngineTable;

							if ( !EngineLog )
							{
								Files::InjectLog ( "	g_pEngine: 0x%X", Interfaces::g_pEngine );

								EngineLog = true;
							}

							Utils::native_memcpy ( &Interfaces::g_Engine, Interfaces::g_pEngine, sizeof ( cl_enginefunc_t ) );

							if ( Interfaces::g_Engine.V_CalcShake )
							{
								DWORD StudioTable = Engine::Offset::FindStudioTable ( );

								if ( StudioTable )
								{
									Interfaces::g_pStudio = ( engine_studio_api_t* )StudioTable;

									if ( !StudioLog )
									{
										Files::InjectLog ( "	g_pStudio: 0x%X", Interfaces::g_pStudio );

										StudioLog = true;
									}

									Utils::native_memcpy ( &Interfaces::g_Studio, Interfaces::g_pStudio, sizeof ( engine_studio_api_t ) );

									if ( Interfaces::g_Studio.StudioSetupSkin )
									{
										DWORD PlayerMove = Engine::Offset::FindPlayerMove ( );

										if ( PlayerMove )
										{
											Interfaces::g_pPlayerMove = ( playermove_t* )PlayerMove;

											if ( !PlayerMoveLog )
											{
												Files::InjectLog ( "	g_pPlayerMove: 0x%X", Interfaces::g_pPlayerMove );

												PlayerMoveLog = true;
											}

											DWORD UserMsg = Engine::Offset::FindUserMsgBase ( );

											if ( UserMsg )
											{
												Interfaces::g_pUserMsgBase = ( PUserMsg )UserMsg;

												if ( !UserMsgLog )
												{
													Files::InjectLog ( "	g_pUserMsgBase: 0x%X", Interfaces::g_pUserMsgBase );

													UserMsgLog = true;
												}

												DWORD EngineMsg = Engine::Offset::FindSVCMessages ( );

												if ( EngineMsg )
												{
													Interfaces::g_pEngineMsgBase = ( PEngineMsg )EngineMsg;

													if ( !EngineMsgLog )
													{
														Files::InjectLog ( "	g_pEngineMsgBase: 0x%X", Interfaces::g_pEngineMsgBase );

														EngineMsgLog = true;
													}

													Files::InjectLog ( "FindCounterValue: %d", FindCounter );

													while ( !Client::FirstFrame )
													{
														Hook::HookClient ( );
														Hook::HookStudio ( );

														Sleep ( 100 );
													}

													hProcessReloadThread = CreateThread ( 0, 0, ProcessReload, 0, 0, 0 );
												}
												else goto StartHook;
											}
											else goto StartHook;
										}
										else goto StartHook;
									}
									else goto StartHook;
								}
								else goto StartHook;
							}
							else goto StartHook;
						}
						else goto StartHook;
					}
					else goto StartHook;
				}
				else goto StartHook;
			}
			else goto StartHook;
		}
	}

	namespace Hook
	{
		void Initialize ( )
		{
			HookUserMessages ( );
			HookEngineMessages ( );
			HookOpenGL ( );
		}

		void HookClient ( )
		{
			Files::InjectLog ( "HookClient..." );

			SDK::Interfaces::g_pClient->HUD_Frame = Client::HUD_Frame;
			SDK::Interfaces::g_pClient->HUD_Key_Event = Client::HUD_Key_Event;
			SDK::Interfaces::g_pClient->HUD_Redraw = Client::HUD_Redraw;
			SDK::Interfaces::g_pClient->V_CalcRefdef = Client::V_CalcRefdef;
			SDK::Interfaces::g_pClient->CL_CreateMove = Client::CL_CreateMove;
			SDK::Interfaces::g_pClient->HUD_AddEntity = Client::HUD_AddEntity;
			SDK::Interfaces::g_pClient->HUD_PostRunCmd = Client::HUD_PostRunCmd;
		}

		void HookStudio ( )
		{
			Files::InjectLog ( "HookStudio..." );

			SDK::Interfaces::g_pStudio->StudioEntityLight = Client::StudioEntityLight;
			SDK::Interfaces::g_pStudio->SetChromeOrigin = Client::SetChromeOrigin;
		}

		void HookUserMessages ( )
		{
			Files::InjectLog ( "HookUserMessages..." );

			pScoreAtrrib = Utils::HookUserMsg ( "ScoreAttrib", ScoreAtrrib );
			pResetHUD = Utils::HookUserMsg ( "ResetHUD", ResetHUD );
			pSetFOV = Utils::HookUserMsg ( "SetFOV", SetFOV );
			pTextMsg = Utils::HookUserMsg ( "TextMsg", TextMsg );
			pTeamInfo = Utils::HookUserMsg ( "TeamInfo", TeamInfo );
			pCurWeapon = Utils::HookUserMsg ( "CurWeapon", CurWeapon );
			pWeaponList = Utils::HookUserMsg ( "WeaponList", WeaponList );
			pDeathMsg = Utils::HookUserMsg ( "DeathMsg", DeathMsg );
		}

		void HookEngineMessages ( )
		{
			Files::InjectLog ( "HookEngineMessages..." );

			pSVC_sound = Utils::HookEngineMsg ( "svc_sound", SVC_Sound );
			pSVC_SpawnStaticSound = Utils::HookEngineMsg ( "svc_spawnstaticsound", SVC_SpawnStaticSound );
			pSVC_StuffText = Utils::HookEngineMsg ( "svc_stufftext", SVC_StuffText );
			pSVC_NewUserMsg = Utils::HookEngineMsg ( "svc_newusermsg", SVC_NewUserMsg );
			pSVC_UpdateUserInfo = Utils::HookEngineMsg ( "svc_updateuserinfo", SVC_UpdateUserInfo );
			pSVC_SendCvarValue = Utils::HookEngineMsg ( "svc_sendcvarvalue", SVC_SendCvarValue );
			pSVC_SendCvarValue2 = Utils::HookEngineMsg ( "svc_sendcvarvalue2", SVC_SendCvarValue2 );
			pSVC_Director = Utils::HookEngineMsg ( "svc_director", SVC_Director );
		}

		void HookOpenGL ( )
		{
			Files::InjectLog ( "HookOpenGL..." );

			HMODULE OpenGL = GetModuleHandle ( "opengl32.dll" );

			DWORD dwglBegin = ( DWORD )OpenGL::DetourFunc ( ( LPBYTE )GetProcAddress ( OpenGL, "glBegin" ), ( LPBYTE )&OpenGL::Hooked_glBegin, 6 );
			DWORD dwglVertex3fv = ( DWORD )OpenGL::DetourFunc ( ( LPBYTE )GetProcAddress ( OpenGL, "glVertex3fv" ), ( LPBYTE )&OpenGL::Hooked_glVertex3fv, 6 );
			DWORD dwglColor4f = ( DWORD )OpenGL::DetourFunc ( ( LPBYTE )GetProcAddress ( OpenGL, "glColor4f" ), ( LPBYTE )&OpenGL::Hooked_glColor4f, 6 );

			if ( dwglBegin ) OpenGL::pglBegin = ( OpenGL::glBegin_t )dwglBegin;
			if ( dwglVertex3fv ) OpenGL::pglVertex3fv = ( OpenGL::glVertex3fv_t )dwglVertex3fv;
			if ( dwglColor4f ) OpenGL::pglColor4f = ( OpenGL::glColor4f_t )dwglColor4f;
		}
	}
}
```

`Engine.h`:

```h
#pragma once

#include "Main.h"

namespace SDK
{
	class Interfaces
	{
	public:
		static cl_clientfunc_t *g_pClient;
		static cl_enginefunc_t *g_pEngine;
		static engine_studio_api_t *g_pStudio;
		static playermove_t *g_pPlayerMove;
		static screenfade_t *g_pScreenFade;

		static cl_clientfunc_t g_Client;
		static cl_enginefunc_t g_Engine;
		static engine_studio_api_t g_Studio;
		static SCREENINFO g_Screen;
		static PUserMsg g_pUserMsgBase;
		static PEngineMsg g_pEngineMsgBase;
		static PColor24 Console_TextColor;
	};

	namespace Offset
	{
		void Initialize ( HANDLE& hProcessReloadThread );
	}

	namespace Hook
	{
		void Initialize ( );

		void HookClient ( );
		void HookStudio ( );
		void HookUserMessages ( );
		void HookEngineMessages ( );
		void HookOpenGL ( );
	}
}
```

`EngineMsg.cpp`:

```cpp
#include "EngineMsg.h"

using namespace Client::Functions;

int MSG_SavedReadCount = 0;

int* MSG_ReadCount = nullptr;
int* MSG_CurrentSize = nullptr;
int* MSG_BadRead = nullptr;

sizebuf_t* MSG_Buffer = nullptr;

HL_MSG_ReadByte MSG_ReadByte = nullptr;
HL_MSG_ReadShort MSG_ReadShort = nullptr;
HL_MSG_ReadLong MSG_ReadLong = nullptr;
HL_MSG_ReadFloat MSG_ReadFloat = nullptr;
HL_MSG_ReadString MSG_ReadString = nullptr;
HL_MSG_ReadCoord MSG_ReadCoord = nullptr;
HL_MSG_ReadBitVec3Coord MSG_ReadBitVec3Coord = nullptr;
HL_MSG_ReadBits MSG_ReadBits = nullptr;
HL_MSG_StartBitReading MSG_StartBitReading = nullptr;
HL_MSG_EndBitReading MSG_EndBitReading = nullptr;

pfnEngineMsgHook pSVC_sound;
pfnEngineMsgHook pSVC_SpawnStaticSound;
pfnEngineMsgHook pSVC_NewUserMsg;
pfnEngineMsgHook pSVC_UpdateUserInfo;
pfnEngineMsgHook pSVC_StuffText;
pfnEngineMsgHook pSVC_SendCvarValue;
pfnEngineMsgHook pSVC_SendCvarValue2;
pfnEngineMsgHook pSVC_Director;

void MSG_SaveReadCount ( )
{
	MSG_SavedReadCount = *MSG_ReadCount;
}

void MSG_RestoreReadCount ( )
{
	*MSG_ReadCount = MSG_SavedReadCount;
}

void SVC_Sound ( )
{
	MSG_SaveReadCount ( );

	Vector vOrigin;

	float flAttenuation = 0.0f;

	int FieldMask = 0;
	int Volume = 0;
	int Pitch = 0;
	int Channel = 0;
	int Index = 0;
	int SoundNum = 0;

	MSG_StartBitReading ( MSG_Buffer );

	FieldMask = MSG_ReadBits ( 9 );

	Volume = ( FieldMask & SND_FL_VOLUME ) ? MSG_ReadBits ( 8 ) / 255 : SOUND_PACKET_VOLUME;

	if ( FieldMask & SND_FL_ATTENUATION )
		flAttenuation = MSG_ReadBits ( 8 ) / 64.0f;

	Channel = MSG_ReadBits ( 3 );
	Index = MSG_ReadBits ( 11 );

	SoundNum = ( FieldMask & SND_FL_LARGE_INDEX ) ? MSG_ReadBits ( 16 ) : MSG_ReadBits ( 8 );

	MSG_ReadBitVec3Coord ( vOrigin );

	if ( FieldMask & SND_FL_PITCH )
		Pitch = MSG_ReadBits ( 8 );

	MSG_EndBitReading ( MSG_Buffer );

	if ( g_Vars.Functions.ESP && g_Vars.ESP.Enable && g_Vars.ESP.Sound )
	{
		cl_entity_s *Local = SDK::Interfaces::g_pEngine->GetLocalPlayer ( );
		cl_entity_s *Entity = SDK::Interfaces::g_pEngine->GetEntityByIndex ( Index );

		if ( Entity && Index != Local->index )
		{
			if ( Client::g_Info->GetDistanceToEntity ( vOrigin ) <= g_Vars.ESP.SoundDistance && Client::g_Info->GetDistanceToEntity ( vOrigin ) >= 50 )
			{
				if ( Entity->player )
				{
					if ( Client::g_Info->GetPlayerTeamByIndex ( Index ) == TERRORIST )
					{
						Visuals::ESP::AddSound ( GetTickCount64 ( ), vOrigin, 255, 20, 20 );
					}
					else if ( Client::g_Info->GetPlayerTeamByIndex ( Index ) == CT )
					{
						Visuals::ESP::AddSound ( GetTickCount64 ( ), vOrigin, 20, 20, 255 );
					}
					else if ( Client::g_Info->GetPlayerTeamByIndex ( Index ) == SPECTATOR )
					{
						Visuals::ESP::AddSound ( GetTickCount64 ( ), vOrigin, 255, 255, 255 );
					}
				}
				else
				{
					Visuals::ESP::AddSound ( GetTickCount64 ( ), vOrigin, 255, 180, 0 );
				}
			}
		}
	}

	MSG_RestoreReadCount ( );
	pSVC_sound ( );
}

void SVC_SpawnStaticSound ( )
{
	MSG_SaveReadCount ( );

	Vector vPosition;

	float flVolume = 0.0f;
	float flAttenuation = 0.0f;

	int SoundNum = 0;
	int Flags = 0;
	int Index = 0;
	int Pitch = 0;

	MSG_StartBitReading ( MSG_Buffer );

	vPosition.x = MSG_ReadCoord ( );
	vPosition.y = MSG_ReadCoord ( );
	vPosition.z = MSG_ReadCoord ( );

	SoundNum = MSG_ReadShort ( );
	flVolume = MSG_ReadByte ( ) / 255.0f;
	flAttenuation = MSG_ReadByte ( ) / 64.0f;
	Index = MSG_ReadShort ( );
	Pitch = MSG_ReadByte ( );
	Flags = MSG_ReadByte ( );

	MSG_EndBitReading ( MSG_Buffer );

	if ( g_Vars.Functions.ESP && g_Vars.ESP.Enable && g_Vars.ESP.Sound )
	{
		cl_entity_s *Local = SDK::Interfaces::g_pEngine->GetLocalPlayer ( );
		cl_entity_s *Entity = SDK::Interfaces::g_pEngine->GetEntityByIndex ( Index );

		if ( Entity && Index != Local->index )
		{
			if ( Client::g_Info->GetDistanceToEntity ( vPosition ) <= g_Vars.ESP.SoundDistance && Client::g_Info->GetDistanceToEntity ( vPosition ) >= 50 )
			{
				if ( Entity->player )
				{
					if ( Client::g_Info->GetPlayerTeamByIndex ( Index ) == TERRORIST )
					{
						Visuals::ESP::AddSound ( GetTickCount64 ( ), vPosition, 255, 20, 20 );
					}
					else if ( Client::g_Info->GetPlayerTeamByIndex ( Index ) == CT )
					{
						Visuals::ESP::AddSound ( GetTickCount64 ( ), vPosition, 20, 20, 255 );
					}
					else if ( Client::g_Info->GetPlayerTeamByIndex ( Index ) == SPECTATOR )
					{
						Visuals::ESP::AddSound ( GetTickCount64 ( ), vPosition, 255, 255, 255 );
					}
				}
				else
				{
					Visuals::ESP::AddSound ( GetTickCount64 ( ), vPosition, 255, 180, 0 );
				}
			}
		}
	}

	MSG_RestoreReadCount ( );
	pSVC_SpawnStaticSound ( );
}

void SVC_NewUserMsg ( )
{
	MSG_SaveReadCount ( );
	MSG_RestoreReadCount ( );
	pSVC_NewUserMsg ( );
}

void SVC_UpdateUserInfo ( )
{
	MSG_SaveReadCount ( );

	int ClientCDKeyHash[16] = { 0 };

	for ( int i = 0; i < 16; ++i )
		ClientCDKeyHash[i] = MSG_ReadByte ( );

	MSG_RestoreReadCount ( );
	pSVC_UpdateUserInfo ( );
}

void SVC_StuffText ( )
{
	MSG_SaveReadCount ( );
	MSG_RestoreReadCount ( );
	pSVC_StuffText ( );
}

void SVC_SendCvarValue ( )
{
	MSG_SaveReadCount ( );
	MSG_RestoreReadCount ( );
	pSVC_SendCvarValue ( );
}

void SVC_SendCvarValue2 ( )
{
	MSG_SaveReadCount ( );
	MSG_RestoreReadCount ( );
	pSVC_SendCvarValue2 ( );
}

void SVC_Director ( )
{
	MSG_SaveReadCount ( );
	MSG_RestoreReadCount ( );
	pSVC_Director ( );
}
```

`EngineMsg.h`:

```h
#pragma once

#include "Main.h"

void SVC_Sound ( );
void SVC_SpawnStaticSound ( );
void SVC_NewUserMsg ( );
void SVC_UpdateUserInfo ( );
void SVC_StuffText ( );
void SVC_SendCvarValue ( );
void SVC_SendCvarValue2 ( );
void SVC_Director ( );

void MSG_SaveReadCount ( );
void MSG_RestoreReadCount ( );

extern pfnEngineMsgHook pSVC_sound;
extern pfnEngineMsgHook pSVC_SpawnStaticSound;
extern pfnEngineMsgHook pSVC_NewUserMsg;
extern pfnEngineMsgHook pSVC_UpdateUserInfo;
extern pfnEngineMsgHook pSVC_StuffText;
extern pfnEngineMsgHook pSVC_SendCvarValue;
extern pfnEngineMsgHook pSVC_SendCvarValue2;
extern pfnEngineMsgHook pSVC_Director;

typedef byte ( *HL_MSG_ReadByte )( );
typedef short ( *HL_MSG_ReadShort )( );
typedef int ( *HL_MSG_ReadLong )( );
typedef float ( *HL_MSG_ReadFloat )( );
typedef char* ( *HL_MSG_ReadString )( );
typedef float ( *HL_MSG_ReadCoord )( );
typedef void ( *HL_MSG_ReadBitVec3Coord )( float* fa );
typedef int ( *HL_MSG_ReadBits )( int Count );
typedef void ( *HL_MSG_StartBitReading )( sizebuf_t* buffer );
typedef void ( *HL_MSG_EndBitReading )( sizebuf_t* buffer );

extern HL_MSG_ReadByte MSG_ReadByte;
extern HL_MSG_ReadShort MSG_ReadShort;
extern HL_MSG_ReadLong MSG_ReadLong;
extern HL_MSG_ReadFloat MSG_ReadFloat;
extern HL_MSG_ReadString MSG_ReadString;
extern HL_MSG_ReadCoord MSG_ReadCoord;
extern HL_MSG_ReadBitVec3Coord MSG_ReadBitVec3Coord;
extern HL_MSG_ReadBits MSG_ReadBits;
extern HL_MSG_StartBitReading MSG_StartBitReading;
extern HL_MSG_EndBitReading MSG_EndBitReading;

extern sizebuf_t* MSG_Buffer;

extern int* MSG_ReadCount;
extern int* MSG_CurrentSize;
extern int* MSG_BadRead;

extern int MSG_SavedReadCount;
```

`FastZoom.cpp`:

```cpp
#include "FastZoom.h"

namespace Client
{
	namespace Functions
	{
		namespace AimBot
		{
			DWORD64 FastZoom::dwTime;

			bool FastZoom::QuickSwitch;

			void FastZoom::CL_CreateMove ( usercmd_s *cmd )
			{
				if ( g_Info->GetWeaponListSnipers ( ) )
				{
					if ( cmd->buttons & IN_ATTACK && g_Info->GetWeaponClip ( ) )
					{
						g_Info->GetFOV ( ) == 90 ? cmd->buttons |= IN_ATTACK2 : QuickSwitch = true;

						if ( GetTickCount64 ( ) - dwTime < g_Vars.FastZoom.Delay )
						{
							cmd->buttons &= ~IN_ATTACK;
						}
						else
						{
							dwTime = GetTickCount64 ( );

							if ( g_Vars.FastZoom.QuickSwitch && ( g_Info->GetWeaponID ( ) == WEAPONLIST_AWP || g_Info->GetWeaponID ( ) == WEAPONLIST_SCOUT ) )
							{
								if ( QuickSwitch && g_Info->GetShotsFired ( ) >= 1 && g_Info->GetNextPrimaryAttack ( ) > 0.0f )
								{
									SDK::Interfaces::g_pEngine->pfnClientCmd ( "slot3;wait;slot1" );

									QuickSwitch = false;
								}
							}
						}
					}
				}
			}
		}
	}
}
```

`FastZoom.h`:

```h
#pragma once

#include "Main.h"

namespace Client
{
	namespace Functions
	{
		namespace AimBot
		{
			class FastZoom
			{
			public:
				static void CL_CreateMove ( usercmd_s *cmd );

			private:
				static DWORD64 dwTime;
				static bool QuickSwitch;
			};
		}
	}
}
```

`Files.cpp`:

```cpp
#include "Files.h"

namespace Files
{
	char* BaseDir;

	std::string szDirFile ( const char *FileName )
	{
		std::string Path = BaseDir;

		return Path + FileName;
	}

	std::ofstream Inject, Info;

	namespace Read
	{
		void Functions ( )
		{
			std::string Path = szDirFile ( FUNCTIONS_PATH ).c_str ( );

			FILE_READ_INT ( g_Vars.Functions.Menu, "Visuals", "|Menu" );
			FILE_READ_INT ( g_Vars.Functions.ScreenInfo, "Visuals", "|ScreenInfo" );
			FILE_READ_INT ( g_Vars.Functions.ESP, "Visuals", "|ESP" );
			FILE_READ_INT ( g_Vars.Functions.Chams, "Visuals", "|Chams" );
			FILE_READ_INT ( g_Vars.Functions.NoFlash, "Visuals", "|NoFlash" );
			FILE_READ_INT ( g_Vars.Functions.Crosshair, "Visuals", "|Crosshair" );
			FILE_READ_INT ( g_Vars.Functions.Speed, "Misc", "|Speed" );
			FILE_READ_INT ( g_Vars.Functions.BunnyHop, "Misc", "|BunnyHop" );
			FILE_READ_INT ( g_Vars.Functions.GroundStrafe, "Misc", "|GroundStrafe" );
			FILE_READ_INT ( g_Vars.Functions.Weapons, "AimBot", "|Weapons" );
			FILE_READ_INT ( g_Vars.Functions.Recoil, "AimBot", "|Recoil" );
			FILE_READ_INT ( g_Vars.Functions.AutoPistol, "AimBot", "|AutoPistol" );
			FILE_READ_INT ( g_Vars.Functions.FastZoom, "AimBot", "|FastZoom" );
			FILE_READ_INT ( g_Vars.Functions.TriggerWeapons, "TriggerBot", "|Weapons" );
		}

		void Main ( )
		{
			std::string Path = szDirFile ( MAIN_PATH ).c_str ( );

			FILE_READ_CONVERT ( g_Vars.Main.Language, "Main", "|Language" );
			FILE_READ_KEY ( g_Vars.Main.ReloadKey, "Main", "|Reload.Key" );
			FILE_READ_KEY ( g_Vars.Main.SaveKey, "Main", "|Save.Key" );
			FILE_READ_KEY ( g_Vars.Main.PanicKey, "Main", "|Panic.Key" );
			FILE_READ_KEY ( g_Vars.Main.PanicAimBotKey, "Main", "|Panic.AimBot.Key" );
			FILE_READ_KEY ( g_Vars.Main.PanicVisualsKey, "Main", "|Panic.Visuals.Key" );
			FILE_READ_KEY ( g_Vars.Main.PanicMiscKey, "Main", "|Panic.Misc.Key" );
			FILE_READ_INT ( g_Vars.Main.PlayerValidCheck, "Main", "|Player.Valid.Check" );
			FILE_READ_INT ( g_Vars.Main.AntiScreenEnable, "Main", "|AntiScreen.Enable" );
			FILE_READ_INT ( g_Vars.Main.AntiScreenTimer, "Main", "|AntiScreen.Timer" );
			FILE_READ_KEY ( g_Vars.Main.AntiScreenKey, "Main", "|AntiScreen.Key" );
			FILE_READ_INT ( g_Vars.Main.FontOutlineStyle, "Main", "|Font.Outline.Style" );
		}

		void Menu ( )
		{
			std::string Path = szDirFile ( VISUALS_PATH ).c_str ( );

			FILE_READ_INT ( g_Vars.Menu.X, "Menu", "|Menu.X" );
			FILE_READ_INT ( g_Vars.Menu.Y, "Menu", "|Menu.Y" );
			FILE_READ_INT ( g_Vars.Menu.BoxHeight, "Menu", "|Menu.Box.Height" );
			FILE_READ_INT ( g_Vars.Menu.BoxWidth, "Menu", "|Menu.Box.Width" );
			FILE_READ_STRING ( g_Vars.Menu.BoxColorString, "Menu", "|Menu.Box.Color" );
			FILE_READ_STRING ( g_Vars.Menu.BoxOutlineColorString, "Menu", "|Menu.Box.Outline.Color" );
			FILE_READ_STRING ( g_Vars.Menu.BoxSelectColorString, "Menu", "|Menu.Box.Select.Color" );
			FILE_READ_STRING ( g_Vars.Menu.TextColorString, "Menu", "|Menu.Text.Color" );
			FILE_READ_KEY ( g_Vars.Menu.Key, "Menu", "|Menu.Key" );

			Parse ( g_Vars.Menu.BoxColorString, g_Vars.Menu.BoxColor, 4 );
			Parse ( g_Vars.Menu.BoxOutlineColorString, g_Vars.Menu.BoxOutlineColor, 4 );
			Parse ( g_Vars.Menu.BoxSelectColorString, g_Vars.Menu.BoxSelectColor, 4 );
			Parse ( g_Vars.Menu.TextColorString, g_Vars.Menu.TextColor, 3 );
		}

		void ScreenInfo ( )
		{
			std::string Path = szDirFile ( VISUALS_PATH ).c_str ( );

			FILE_READ_INT ( g_Vars.ScreenInfo.Enable, "ScreenInfo", "|ScreenInfo.Enable" );
			FILE_READ_INT ( g_Vars.ScreenInfo.FPS, "ScreenInfo", "|ScreenInfo.FPS" );
			FILE_READ_INT ( g_Vars.ScreenInfo.Copyright, "ScreenInfo", "|ScreenInfo.Copyright" );
			FILE_READ_INT ( g_Vars.ScreenInfo.Time, "ScreenInfo", "|ScreenInfo.Time" );
			FILE_READ_INT ( g_Vars.ScreenInfo.ShowKeys, "ScreenInfo", "|ScreenInfo.ShowKeys" );
			FILE_READ_INT ( g_Vars.ScreenInfo.KreedzInfo, "ScreenInfo", "|ScreenInfo.KreedzInfo" );
			FILE_READ_STRING ( g_Vars.ScreenInfo.FontColorString, "ScreenInfo", "|ScreenInfo.Font.Color" );
			FILE_READ_INT ( g_Vars.ScreenInfo.FontOutline, "ScreenInfo", "|ScreenInfo.Font.Outline" );

			Parse ( g_Vars.ScreenInfo.FontColorString, g_Vars.ScreenInfo.FontColor, 4 );
		}

		void ESP ( )
		{
			std::string Path = szDirFile ( VISUALS_PATH ).c_str ( );

			FILE_READ_INT ( g_Vars.ESP.Enable, "ESP", "|ESP.Enable" );
			FILE_READ_INT ( g_Vars.ESP.Player, "ESP", "|ESP.Player" );
			FILE_READ_INT ( g_Vars.ESP.PlayerVisibleOnly, "ESP", "|ESP.Player.VisibleOnly" );
			FILE_READ_INT ( g_Vars.ESP.PlayerBox, "ESP", "|ESP.Player.Box" );
			FILE_READ_INT ( g_Vars.ESP.PlayerBoxFilled, "ESP", "|ESP.Player.Box.Filled" );
			FILE_READ_STRING ( g_Vars.ESP.ColorTVisString, "ESP", "|ESP.Player.Box.T.Vis" );
			FILE_READ_STRING ( g_Vars.ESP.ColorTHideString, "ESP", "|ESP.Player.Box.T.Hide" );
			FILE_READ_STRING ( g_Vars.ESP.ColorCTVisString, "ESP", "|ESP.Player.Box.CT.Vis" );
			FILE_READ_STRING ( g_Vars.ESP.ColorCTHideString, "ESP", "|ESP.Player.Box.CT.Hide" );
			FILE_READ_INT ( g_Vars.ESP.PlayerName, "ESP", "|ESP.Player.Name" );
			FILE_READ_INT ( g_Vars.ESP.PlayerWeapon, "ESP", "|ESP.Player.Weapon" );
			FILE_READ_INT ( g_Vars.ESP.PlayerDistance, "ESP", "|ESP.Player.Distance" );
			FILE_READ_INT ( g_Vars.ESP.PlayerBarrel, "ESP", "|ESP.Player.Barrel" );
			FILE_READ_INT ( g_Vars.ESP.WorldC4, "ESP", "|ESP.World.C4" );
			FILE_READ_INT ( g_Vars.ESP.WorldItems, "ESP", "|ESP.World.Items" );
			FILE_READ_INT ( g_Vars.ESP.WorldNades, "ESP", "|ESP.World.Nades" );
			FILE_READ_INT ( g_Vars.ESP.C4Timer, "ESP", "|ESP.C4Timer" );
			FILE_READ_INT ( g_Vars.ESP.C4TimerValue, "ESP", "|ESP.C4Timer.Value" );
			FILE_READ_INT ( g_Vars.ESP.Sound, "ESP", "|ESP.Sound" );
			FILE_READ_INT ( g_Vars.ESP.SoundDistance, "ESP", "|ESP.Sound.Distance" );
			FILE_READ_INT ( g_Vars.ESP.SoundFadeTime, "ESP", "|ESP.Sound.FadeTime" );
			FILE_READ_STRING ( g_Vars.ESP.FontColorString, "ESP", "|ESP.Font.Color" );
			FILE_READ_INT ( g_Vars.ESP.FontOutline, "ESP", "|ESP.Font.Outline" );

			Parse ( g_Vars.ESP.ColorTVisString, g_Vars.ESP.ColorTVis, 3 );
			Parse ( g_Vars.ESP.ColorTHideString, g_Vars.ESP.ColorTHide, 3 );
			Parse ( g_Vars.ESP.ColorCTVisString, g_Vars.ESP.ColorCTVis, 3 );
			Parse ( g_Vars.ESP.ColorCTHideString, g_Vars.ESP.ColorCTHide, 3 );
			Parse ( g_Vars.ESP.FontColorString, g_Vars.ESP.FontColor, 4 );
		}

		void NoFlash ( )
		{
			std::string Path = szDirFile ( VISUALS_PATH ).c_str ( );

			FILE_READ_INT ( g_Vars.NoFlash.Enable, "NoFlash", "|NoFlash.Enable" );
			FILE_READ_INT ( g_Vars.NoFlash.FadeLimit, "NoFlash", "|NoFlash.Fade.Limit" );
			FILE_READ_INT ( g_Vars.NoFlash.FadeColorEnable, "NoFlash", "|NoFlash.Fade.Color.Enable" );
			FILE_READ_STRING ( g_Vars.NoFlash.FadeColorString, "NoFlash", "|NoFlash.Fade.Color" );
			FILE_READ_INT ( g_Vars.NoFlash.FadeColorRandom, "NoFlash", "|NoFlash.Fade.Color.Random" );
			FILE_READ_INT ( g_Vars.NoFlash.DrawFlashed, "NoFlash", "|NoFlash.DrawFlashed" );
			FILE_READ_INT ( g_Vars.NoFlash.FontOutline, "NoFlash", "|NoFlash.Font.Outline" );

			Parse ( g_Vars.NoFlash.FadeColorString, g_Vars.NoFlash.FadeColor, 3 );
		}

		void Speed ( )
		{
			std::string Path = szDirFile ( MISC_PATH ).c_str ( );

			FILE_READ_FLOAT ( g_Vars.Speed.Player, "Speed", "|Speed.Player" );
			FILE_READ_INT ( g_Vars.Speed.Engine, "Speed", "|Speed.Engine" );
			FILE_READ_FLOAT ( g_Vars.Speed.Boost, "Speed", "|Speed.Boost" );
			FILE_READ_KEY ( g_Vars.Speed.BoostKey, "Speed", "|Speed.Boost.Key" );
			FILE_READ_FLOAT ( g_Vars.Speed.Slowmo, "Speed", "|Speed.Slowmo" );
			FILE_READ_KEY ( g_Vars.Speed.SlowmoKey, "Speed", "|Speed.Slowmo.Key" );
			FILE_READ_INT ( g_Vars.Speed.Helper, "Speed", "|Speed.Helper" );
			FILE_READ_FLOAT ( g_Vars.Speed.HelperGround, "Speed", "|Speed.Helper.Ground" );
			FILE_READ_FLOAT ( g_Vars.Speed.HelperLadder, "Speed", "|Speed.Helper.Ladder" );
			FILE_READ_FLOAT ( g_Vars.Speed.HelperFly, "Speed", "|Speed.Helper.Fly" );
		}

		void BunnyHop ( )
		{
			std::string Path = szDirFile ( MISC_PATH ).c_str ( );

			FILE_READ_INT ( g_Vars.BunnyHop.NoSlowdown, "BunnyHop", "|BunnyHop.NoSlowdown" );
			FILE_READ_INT ( g_Vars.BunnyHop.ScrollEmulation, "BunnyHop", "|BunnyHop.Scroll.Emulation" );
			FILE_READ_CONVERT ( g_Vars.BunnyHop.ScrollDirection, "BunnyHop", "|BunnyHop.Scroll.Direction" );
			FILE_READ_STRING ( g_Vars.BunnyHop.ScrollDistanceString, "BunnyHop", "|BunnyHop.Scroll.Distance" );
			FILE_READ_INT ( g_Vars.BunnyHop.ScrollRandFails, "BunnyHop", "|BunnyHop.Scroll.RandFails" );
			FILE_READ_INT ( g_Vars.BunnyHop.OnLadder, "BunnyHop", "|BunnyHop.OnLadder" );
			FILE_READ_INT ( g_Vars.BunnyHop.Helper, "BunnyHop", "|BunnyHop.Helper" );
			FILE_READ_INT ( g_Vars.BunnyHop.HelperNoSlowdown, "BunnyHop", "|BunnyHop.Helper.NoSlowdown" );
			FILE_READ_INT ( g_Vars.BunnyHop.HelperIdealPercent, "BunnyHop", "|BunnyHop.Helper.IdealPercent" );
			FILE_READ_INT ( g_Vars.BunnyHop.StandUpAuto, "BunnyHop", "|BunnyHop.StandUp.Auto" );
			FILE_READ_INT ( g_Vars.BunnyHop.StandUpFallVelocity, "BunnyHop", "|BunnyHop.StandUp.FallVelocity" );
			FILE_READ_KEY ( g_Vars.BunnyHop.StandUpKey, "BunnyHop", "|BunnyHop.StandUp.Key" );
			FILE_READ_KEY ( g_Vars.BunnyHop.Key, "BunnyHop", "|BunnyHop.Key" );

			Parse ( g_Vars.BunnyHop.ScrollDistanceString, g_Vars.BunnyHop.ScrollDistance, 2 );
		}

		void Crosshair ( )
		{
			std::string Path = szDirFile ( VISUALS_PATH ).c_str ( );

			FILE_READ_INT ( g_Vars.Crosshair.Enable, "Crosshair", "|Crosshair.Enable" );
			FILE_READ_INT ( g_Vars.Crosshair.Dot, "Crosshair", "|Crosshair.Dot" );
			FILE_READ_INT ( g_Vars.Crosshair.Size, "Crosshair", "|Crosshair.Size" );
			FILE_READ_INT ( g_Vars.Crosshair.Gap, "Crosshair", "|Crosshair.Gap" );
			FILE_READ_INT ( g_Vars.Crosshair.Thickness, "Crosshair", "|Crosshair.Thickness" );
			FILE_READ_INT ( g_Vars.Crosshair.Dynamic, "Crosshair", "|Crosshair.Dynamic" );
			FILE_READ_FLOAT ( g_Vars.Crosshair.DynamicScale, "Crosshair", "|Crosshair.Dynamic.Scale" );
			FILE_READ_INT ( g_Vars.Crosshair.Outline, "Crosshair", "|Crosshair.Outline" );
			FILE_READ_INT ( g_Vars.Crosshair.Snipers, "Crosshair", "|Crosshair.Snipers" );
			FILE_READ_STRING ( g_Vars.Crosshair.ColorString, "Crosshair", "|Crosshair.Color" );

			Parse ( g_Vars.Crosshair.ColorString, g_Vars.Crosshair.Color, 4 );
		}

		void AimWeapons ( )
		{
			std::string Path = szDirFile ( AIMBOT_PATH ).c_str ( );

			FILE_READ_INT ( g_Vars.Aim.Enable, "Aim", "|Aim.Enable" );
			FILE_READ_INT ( g_Vars.Aim.Silent, "Aim", "|Aim.Silent" );
			FILE_READ_INT ( g_Vars.Aim.FriendlyFire, "Aim", "|Aim.FriendlyFire" );
			FILE_READ_INT ( g_Vars.Aim.VisibleCheck, "Aim", "|Aim.VisibleCheck" );
			FILE_READ_INT ( g_Vars.Aim.FlashCheck, "Aim", "|Aim.FlashCheck" );
			FILE_READ_INT ( g_Vars.Aim.FOVDistance, "Aim", "|Aim.FOV.Distance" );
			FILE_READ_INT ( g_Vars.Aim.KillDelay, "Aim", "|Aim.KillDelay" );

			for ( int Index = 1; Index <= 30; ++Index )
			{
				std::string Weapon;

				Utils::GetSection ( Index, Weapon );

				std::string Aim = "|" + Weapon + ".Aim";
				std::string BulletControl = "|" + Weapon + ".BulletControl";
				std::string Nearest = "|" + Weapon + ".HitBox.Nearest";
				std::string HitBox = "|" + Weapon + ".HitBox";
				std::string Prediction = "|" + Weapon + ".Prediction";
				std::string FOV = "|" + Weapon + ".FOV";
				std::string Smooth = "|" + Weapon + ".Smooth";
				std::string Delay = "|" + Weapon + ".Delay";
				std::string DelayType = "|" + Weapon + ".Delay.Type";
				std::string Recoil = "|" + Weapon + ".Recoil";
				std::string RecoilPrediction = "|" + Weapon + ".Recoil.Prediction";
				std::string FOVRecoil = "|" + Weapon + ".Recoil.FOV";
				std::string SmoothRecoil = "|" + Weapon + ".Recoil.Smooth";

				FILE_READ_INT ( g_Vars.Weapons[Index].Aim, "Weapons", ( char* )Aim.c_str ( ) );
				FILE_READ_STRING ( g_Vars.Weapons[Index].BulletControlString, "Weapons", ( char* )BulletControl.c_str ( ) );
				FILE_READ_INT ( g_Vars.Weapons[Index].HitBoxNearest, "Weapons", ( char* )Nearest.c_str ( ) );
				FILE_READ_INT ( g_Vars.Weapons[Index].HitBox, "Weapons", ( char* )HitBox.c_str ( ) );
				FILE_READ_FLOAT ( g_Vars.Weapons[Index].Prediction, "Weapons", ( char* )Prediction.c_str ( ) );
				FILE_READ_FLOAT ( g_Vars.Weapons[Index].FOV, "Weapons", ( char* )FOV.c_str ( ) );
				FILE_READ_FLOAT ( g_Vars.Weapons[Index].Smooth, "Weapons", ( char* )Smooth.c_str ( ) );
				FILE_READ_INT ( g_Vars.Weapons[Index].Delay, "Weapons", ( char* )Delay.c_str ( ) );
				FILE_READ_INT ( g_Vars.Weapons[Index].DelayType, "Weapons", ( char* )DelayType.c_str ( ) );
				FILE_READ_FLOAT ( g_Vars.Weapons[Index].Recoil, "Weapons", ( char* )Recoil.c_str ( ) );
				FILE_READ_FLOAT ( g_Vars.Weapons[Index].RecoilPrediction, "Weapons", ( char* )RecoilPrediction.c_str ( ) );
				FILE_READ_FLOAT ( g_Vars.Weapons[Index].RecoilFOV, "Weapons", ( char* )FOVRecoil.c_str ( ) );
				FILE_READ_FLOAT ( g_Vars.Weapons[Index].RecoilSmooth, "Weapons", ( char* )SmoothRecoil.c_str ( ) );

				Parse ( g_Vars.Weapons[Index].BulletControlString, g_Vars.Weapons[Index].BulletControl, 2 );
			}
		}

		void Other ( )
		{
			std::string Path = szDirFile ( VISUALS_PATH ).c_str ( );

			FILE_READ_INT ( g_Vars.Other.DrawAimSpot, "Other", "|Draw.Aim.Spot" );
			FILE_READ_INT ( g_Vars.Other.DrawAimFOV, "Other", "|Draw.Aim.FOV" );
			FILE_READ_INT ( g_Vars.Other.DrawPunch, "Other", "|Draw.Punch" );
			FILE_READ_INT ( g_Vars.Other.DrawSpread, "Other", "|Draw.Spread" );
			FILE_READ_INT ( g_Vars.Other.StatusAimBot, "Other", "|Status.AimBot" );
			FILE_READ_INT ( g_Vars.Other.StatusTriggerBot, "Other", "|Status.TriggerBot" );
			FILE_READ_INT ( g_Vars.Other.RemoveSmoke, "Other", "|Remove.Smoke" );
			FILE_READ_STRING ( g_Vars.Other.FontColorString, "Other", "|Font.Color" );
			FILE_READ_INT ( g_Vars.Other.FontOutline, "Other", "|Font.Outline" );

			Parse ( g_Vars.Other.FontColorString, g_Vars.Other.FontColor, 4 );
		}

		void Recoil ( )
		{
			std::string Path = szDirFile ( AIMBOT_PATH ).c_str ( );

			FILE_READ_INT ( g_Vars.Recoil.Enable, "Recoil", "|Recoil.Enable" );
			FILE_READ_FLOAT ( g_Vars.Recoil.X, "Recoil", "|Recoil.X" );
			FILE_READ_FLOAT ( g_Vars.Recoil.Y, "Recoil", "|Recoil.Y" );
			FILE_READ_FLOAT ( g_Vars.Recoil.Smooth, "Recoil", "|Recoil.Smooth" );
			FILE_READ_INT ( g_Vars.Recoil.BulletStart, "Recoil", "|Recoil.BulletStart" );
		}

		void AutoPistol ( )
		{
			std::string Path = szDirFile ( AIMBOT_PATH ).c_str ( );

			FILE_READ_INT ( g_Vars.AutoPistol.Enable, "AutoPistol", "|AutoPistol.Enable" );
			FILE_READ_INT ( g_Vars.AutoPistol.Delay, "AutoPistol", "|AutoPistol.Delay" );
		}

		void FastZoom ( )
		{
			std::string Path = szDirFile ( AIMBOT_PATH ).c_str ( );

			FILE_READ_INT ( g_Vars.FastZoom.Enable, "FastZoom", "|FastZoom.Enable" );
			FILE_READ_INT ( g_Vars.FastZoom.Delay, "FastZoom", "|FastZoom.Delay" );
			FILE_READ_INT ( g_Vars.FastZoom.QuickSwitch, "FastZoom", "|FastZoom.QuickSwitch" );
		}

		void Chams ( )
		{
			std::string Path = szDirFile ( VISUALS_PATH ).c_str ( );

			FILE_READ_INT ( g_Vars.Chams.Enable, "Chams", "|Chams.Enable" );
			FILE_READ_INT ( g_Vars.Chams.Player, "Chams", "|Chams.Player" );
			FILE_READ_INT ( g_Vars.Chams.PlayerVisibleOnly, "Chams", "|Chams.Player.VisibleOnly" );
			FILE_READ_INT ( g_Vars.Chams.PlayerRenderType, "Chams", "|Chams.Player.RenderType" );
			FILE_READ_STRING ( g_Vars.Chams.ColorTVisString, "Chams", "|Chams.Player.T.Vis" );
			FILE_READ_STRING ( g_Vars.Chams.ColorTHideString, "Chams", "|Chams.Player.T.Hide" );
			FILE_READ_STRING ( g_Vars.Chams.ColorCTVisString, "Chams", "|Chams.Player.CT.Vis" );
			FILE_READ_STRING ( g_Vars.Chams.ColorCTHideString, "Chams", "|Chams.Player.CT.Hide" );
			FILE_READ_INT ( g_Vars.Chams.Weapon, "Chams", "|Chams.Weapon" );
			FILE_READ_INT ( g_Vars.Chams.WeaponVisibleOnly, "Chams", "|Chams.Weapon.VisibleOnly" );
			FILE_READ_INT ( g_Vars.Chams.WeaponRenderType, "Chams", "|Chams.Weapon.RenderType" );
			FILE_READ_STRING ( g_Vars.Chams.WeaponColorVisString, "Chams", "|Chams.Weapon.Color.Vis" );
			FILE_READ_STRING ( g_Vars.Chams.WeaponColorHideString, "Chams", "|Chams.Weapon.Color.Hide" );
			FILE_READ_INT ( g_Vars.Chams.Hands, "Chams", "|Chams.Hands" );
			FILE_READ_INT ( g_Vars.Chams.HandsRenderType, "Chams", "|Chams.Hands.RenderType" );
			FILE_READ_STRING ( g_Vars.Chams.HandsColorString, "Chams", "|Chams.Hands.Color" );

			Parse ( g_Vars.Chams.ColorTVisString, g_Vars.Chams.ColorTVis, 3 );
			Parse ( g_Vars.Chams.ColorTHideString, g_Vars.Chams.ColorTHide, 3 );
			Parse ( g_Vars.Chams.ColorCTVisString, g_Vars.Chams.ColorCTVis, 3 );
			Parse ( g_Vars.Chams.ColorCTHideString, g_Vars.Chams.ColorCTHide, 3 );
			Parse ( g_Vars.Chams.WeaponColorVisString, g_Vars.Chams.WeaponColorVis, 3 );
			Parse ( g_Vars.Chams.WeaponColorHideString, g_Vars.Chams.WeaponColorHide, 3 );
			Parse ( g_Vars.Chams.HandsColorString, g_Vars.Chams.HandsColor, 3 );
		}

		void GroundStrafe ( )
		{
			std::string Path = szDirFile ( MISC_PATH ).c_str ( );

			FILE_READ_INT ( g_Vars.GroundStrafe.ScrollEmulation, "GroundStrafe", "|GroundStrafe.Scroll.Emulation" );
			FILE_READ_CONVERT ( g_Vars.GroundStrafe.ScrollDirection, "GroundStrafe", "|GroundStrafe.Scroll.Direction" );
			FILE_READ_STRING ( g_Vars.GroundStrafe.ScrollDistanceString, "GroundStrafe", "|GroundStrafe.Scroll.Distance" );
			FILE_READ_STRING ( g_Vars.GroundStrafe.ScrollCountString, "GroundStrafe", "|GroundStrafe.Scroll.Count" );
			FILE_READ_FLOAT ( g_Vars.GroundStrafe.SlowdownScale, "GroundStrafe", "|GroundStrafe.Slowdown.Scale" );
			FILE_READ_FLOAT ( g_Vars.GroundStrafe.SlowdownAngle, "GroundStrafe", "|GroundStrafe.Slowdown.Angle" );
			FILE_READ_INT ( g_Vars.GroundStrafe.FallRun, "GroundStrafe", "|GroundStrafe.FallRun" );
			FILE_READ_INT ( g_Vars.GroundStrafe.Helper, "GroundStrafe", "|GroundStrafe.Helper" );
			FILE_READ_INT ( g_Vars.GroundStrafe.StandUpFallVelocity, "GroundStrafe", "|GroundStrafe.StandUp.FallVelocity" );
			FILE_READ_KEY ( g_Vars.GroundStrafe.StandUpKey, "GroundStrafe", "|GroundStrafe.StandUp.Key" );
			FILE_READ_KEY ( g_Vars.GroundStrafe.Key, "GroundStrafe", "|GroundStrafe.Key" );

			Parse ( g_Vars.GroundStrafe.ScrollDistanceString, g_Vars.GroundStrafe.ScrollDistance, 2 );
			Parse ( g_Vars.GroundStrafe.ScrollCountString, g_Vars.GroundStrafe.ScrollCount, 2 );
		}

		void TriggerWeapons ( )
		{
			std::string Path = szDirFile ( TRIGGERBOT_PATH ).c_str ( );

			FILE_READ_INT ( g_Vars.Trigger.Enable, "Trigger", "|Trigger.Enable" );
			FILE_READ_INT ( g_Vars.Trigger.FriendlyFire, "Trigger", "|Trigger.FriendlyFire" );
			FILE_READ_INT ( g_Vars.Trigger.VisibleCheck, "Trigger", "|Trigger.VisibleCheck" );
			FILE_READ_INT ( g_Vars.Trigger.SnipersOnlyInZoom, "Trigger", "|Trigger.Snipers.OnlyInZoom" );
			FILE_READ_KEY ( g_Vars.Trigger.SwitchKey, "Trigger", "|Trigger.Switch.Key" );
			FILE_READ_KEY ( g_Vars.Trigger.Key, "Trigger", "|Trigger.Key" );

			for ( int Index = 1; Index <= 30; ++Index )
			{
				std::string Weapon;

				Utils::GetSection ( Index, Weapon );

				std::string Trigger = "|" + Weapon + ".Trigger";
				std::string OnlyHead = "|" + Weapon + ".OnlyHead";
				std::string ProSpread = "|" + Weapon + ".ProSpread";

				FILE_READ_INT ( g_Vars.TriggerWeapons[Index].Trigger, "Weapons", ( char* )Trigger.c_str ( ) );
				FILE_READ_INT ( g_Vars.TriggerWeapons[Index].OnlyHead, "Weapons", ( char* )OnlyHead.c_str ( ) );
				FILE_READ_INT ( g_Vars.TriggerWeapons[Index].ProSpread, "Weapons", ( char* )ProSpread.c_str ( ) );
			}
		}
	}

	namespace Write
	{
		void Main ( )
		{
			std::string Path = szDirFile ( MAIN_PATH ).c_str ( );

			FILE_WRITE_LANG ( g_Vars.Main.Language, "Main", "|Language" );
			FILE_WRITE_INT ( g_Vars.Main.PlayerValidCheck, "Main", "|Player.Valid.Check" );
			FILE_WRITE_INT ( g_Vars.Main.AntiScreenEnable, "Main", "|AntiScreen.Enable" );
			FILE_WRITE_INT ( g_Vars.Main.AntiScreenTimer, "Main", "|AntiScreen.Timer" );
			FILE_WRITE_INT ( g_Vars.Main.FontOutlineStyle, "Main", "|Font.Outline.Style" );
			FILE_WRITE_KEY ( g_Vars.Main.ReloadKey, "Main", "|Reload.Key" );
			FILE_WRITE_KEY ( g_Vars.Main.SaveKey, "Main", "|Save.Key" );
			FILE_WRITE_KEY ( g_Vars.Main.AntiScreenKey, "Main", "|AntiScreen.Key" );
			FILE_WRITE_KEY ( g_Vars.Main.PanicKey, "Main", "|Panic.Key" );
			FILE_WRITE_KEY ( g_Vars.Main.PanicAimBotKey, "Main", "|Panic.AimBot.Key" );
			FILE_WRITE_KEY ( g_Vars.Main.PanicVisualsKey, "Main", "|Panic.Visuals.Key" );
			FILE_WRITE_KEY ( g_Vars.Main.PanicMiscKey, "Main", "|Panic.Misc.Key" );
			FILE_WRITE_KEY ( g_Vars.Main.AntiScreenKey, "Main", "|AntiScreen.Key" );
		}

		void Menu ( )
		{
			std::string Path = szDirFile ( VISUALS_PATH ).c_str ( );

			FILE_WRITE_INT ( g_Vars.Menu.X, "Menu", "|Menu.x" );
			FILE_WRITE_INT ( g_Vars.Menu.Y, "Menu", "|Menu.y" );
			FILE_WRITE_INT ( g_Vars.Menu.BoxHeight, "Menu", "|Menu.Box.Height" );
			FILE_WRITE_INT ( g_Vars.Menu.BoxWidth, "Menu", "|Menu.Box.Width" );
			FILE_WRITE_RGBA ( g_Vars.Menu.BoxColor[0], g_Vars.Menu.BoxColor[1], g_Vars.Menu.BoxColor[2], g_Vars.Menu.BoxColor[3], "Menu", "|Menu.Box.Color" );

			FILE_WRITE_RGBA ( g_Vars.Menu.BoxOutlineColor[0], g_Vars.Menu.BoxOutlineColor[1],
				g_Vars.Menu.BoxOutlineColor[2], g_Vars.Menu.BoxOutlineColor[3], "Menu", "|Menu.Box.Outline.Color" );

			FILE_WRITE_RGBA ( g_Vars.Menu.BoxSelectColor[0], g_Vars.Menu.BoxSelectColor[1],
				g_Vars.Menu.BoxSelectColor[2], g_Vars.Menu.BoxSelectColor[3], "Menu", "|Menu.Box.Select.Color" );

			FILE_WRITE_RGB ( g_Vars.Menu.TextColor[0], g_Vars.Menu.TextColor[1], g_Vars.Menu.TextColor[2], "Menu", "|Menu.Text.Color" );
			FILE_WRITE_KEY ( g_Vars.Menu.Key, "Menu", "|Menu.Key" );
		}

		void ScreenInfo ( )
		{
			std::string Path = szDirFile ( VISUALS_PATH ).c_str ( );

			FILE_WRITE_INT ( g_Vars.ScreenInfo.Enable, "ScreenInfo", "|ScreenInfo.Enable" );
			FILE_WRITE_INT ( g_Vars.ScreenInfo.FPS, "ScreenInfo", "|ScreenInfo.FPS" );
			FILE_WRITE_INT ( g_Vars.ScreenInfo.Copyright, "ScreenInfo", "|ScreenInfo.Copyright" );
			FILE_WRITE_INT ( g_Vars.ScreenInfo.Time, "ScreenInfo", "|ScreenInfo.Time" );
			FILE_WRITE_INT ( g_Vars.ScreenInfo.ShowKeys, "ScreenInfo", "|ScreenInfo.ShowKeys" );
			FILE_WRITE_INT ( g_Vars.ScreenInfo.KreedzInfo, "ScreenInfo", "|ScreenInfo.KreedzInfo" );

			FILE_WRITE_RGBA ( g_Vars.ScreenInfo.FontColor[0], g_Vars.ScreenInfo.FontColor[1],
				g_Vars.ScreenInfo.FontColor[2], g_Vars.ScreenInfo.FontColor[3], "ScreenInfo", "|ScreenInfo.Font.Color" );

			FILE_WRITE_INT ( g_Vars.ScreenInfo.FontOutline, "ScreenInfo", "|ScreenInfo.Font.Outline" );
		}

		void ESP ( )
		{
			std::string Path = szDirFile ( VISUALS_PATH ).c_str ( );

			FILE_WRITE_INT ( g_Vars.ESP.Enable, "ESP", "|ESP.Enable" );
			FILE_WRITE_INT ( g_Vars.ESP.Player, "ESP", "|ESP.Player" );
			FILE_WRITE_INT ( g_Vars.ESP.PlayerVisibleOnly, "ESP", "|ESP.Player.VisibleOnly" );
			FILE_WRITE_INT ( g_Vars.ESP.PlayerBox, "ESP", "|ESP.Player.Box" );
			FILE_WRITE_INT ( g_Vars.ESP.PlayerBoxFilled, "ESP", "|ESP.Player.Box.Filled" );
			FILE_WRITE_RGB ( g_Vars.ESP.ColorTVis[0], g_Vars.ESP.ColorTVis[1], g_Vars.ESP.ColorTVis[2], "ESP", "|ESP.Player.Box.T.Vis" );
			FILE_WRITE_RGB ( g_Vars.ESP.ColorTHide[0], g_Vars.ESP.ColorTHide[1], g_Vars.ESP.ColorTHide[2], "ESP", "|ESP.Player.Box.T.Hide" );
			FILE_WRITE_RGB ( g_Vars.ESP.ColorCTVis[0], g_Vars.ESP.ColorCTVis[1], g_Vars.ESP.ColorCTVis[2], "ESP", "|ESP.Player.Box.CT.Vis" );
			FILE_WRITE_RGB ( g_Vars.ESP.ColorCTHide[0], g_Vars.ESP.ColorCTHide[1], g_Vars.ESP.ColorCTHide[2], "ESP", "|ESP.Player.Box.CT.Hide" );
			FILE_WRITE_INT ( g_Vars.ESP.PlayerName, "ESP", "|ESP.Player.Name" );
			FILE_WRITE_INT ( g_Vars.ESP.PlayerWeapon, "ESP", "|ESP.Player.Weapon" );
			FILE_WRITE_INT ( g_Vars.ESP.PlayerDistance, "ESP", "|ESP.Player.Distance" );
			FILE_WRITE_INT ( g_Vars.ESP.PlayerBarrel, "ESP", "|ESP.Player.Barrel" );
			FILE_WRITE_INT ( g_Vars.ESP.WorldC4, "ESP", "|ESP.World.C4" );
			FILE_WRITE_INT ( g_Vars.ESP.WorldItems, "ESP", "|ESP.World.Items" );
			FILE_WRITE_INT ( g_Vars.ESP.WorldNades, "ESP", "|ESP.World.Nades" );
			FILE_WRITE_INT ( g_Vars.ESP.C4Timer, "ESP", "|ESP.C4Timer" );
			FILE_WRITE_INT ( g_Vars.ESP.C4TimerValue, "ESP", "|ESP.C4Timer.Value" );
			FILE_WRITE_INT ( g_Vars.ESP.Sound, "ESP", "|ESP.Sound" );
			FILE_WRITE_INT ( g_Vars.ESP.SoundDistance, "ESP", "|ESP.Sound.Distance" );
			FILE_WRITE_INT ( g_Vars.ESP.SoundFadeTime, "ESP", "|ESP.Sound.FadeTime" );
			FILE_WRITE_RGBA ( g_Vars.ESP.FontColor[0], g_Vars.ESP.FontColor[1], g_Vars.ESP.FontColor[2], g_Vars.ESP.FontColor[3], "ESP", "|ESP.Font.Color" );
			FILE_WRITE_INT ( g_Vars.ESP.FontOutline, "ESP", "|ESP.Font.Outline" );
		}

		void NoFlash ( )
		{
			std::string Path = szDirFile ( VISUALS_PATH ).c_str ( );

			FILE_WRITE_INT ( g_Vars.NoFlash.Enable, "NoFlash", "|NoFlash.Enable" );
			FILE_WRITE_INT ( g_Vars.NoFlash.FadeLimit, "NoFlash", "|NoFlash.Fade.Limit" );
			FILE_WRITE_INT ( g_Vars.NoFlash.FadeColorEnable, "NoFlash", "|NoFlash.Fade.Color.Enable" );
			FILE_WRITE_RGB ( g_Vars.NoFlash.FadeColor[0], g_Vars.NoFlash.FadeColor[1], g_Vars.NoFlash.FadeColor[2], "NoFlash", "|NoFlash.Fade.Color" );
			FILE_WRITE_INT ( g_Vars.NoFlash.FadeColorRandom, "NoFlash", "|NoFlash.Fade.Color.Random" );
			FILE_WRITE_INT ( g_Vars.NoFlash.DrawFlashed, "NoFlash", "|NoFlash.DrawFlashed" );
			FILE_WRITE_INT ( g_Vars.NoFlash.FontOutline, "NoFlash", "|NoFlash.Font.Outline" );
		}

		void Speed ( )
		{
			std::string Path = szDirFile ( MISC_PATH ).c_str ( );

			FILE_WRITE_FLOAT ( g_Vars.Speed.Player, "Speed", "|Speed.Player" );
			FILE_WRITE_INT ( g_Vars.Speed.Engine, "Speed", "|Speed.Engine" );
			FILE_WRITE_FLOAT ( g_Vars.Speed.Boost, "Speed", "|Speed.Boost" );
			FILE_WRITE_FLOAT ( g_Vars.Speed.Slowmo, "Speed", "|Speed.Slowmo" );
			FILE_WRITE_INT ( g_Vars.Speed.Helper, "Speed", "|Speed.Helper" );
			FILE_WRITE_FLOAT ( g_Vars.Speed.HelperGround, "Speed", "|Speed.Helper.Ground" );
			FILE_WRITE_FLOAT ( g_Vars.Speed.HelperLadder, "Speed", "|Speed.Helper.Ladder" );
			FILE_WRITE_FLOAT ( g_Vars.Speed.HelperFly, "Speed", "|Speed.Helper.Fly" );
			FILE_WRITE_KEY ( g_Vars.Speed.BoostKey, "Speed", "|Speed.Boost.Key" );
			FILE_WRITE_KEY ( g_Vars.Speed.SlowmoKey, "Speed", "|Speed.Slowmo.Key" );
		}

		void BunnyHop ( )
		{
			std::string Path = szDirFile ( MISC_PATH ).c_str ( );

			FILE_WRITE_INT ( g_Vars.BunnyHop.NoSlowdown, "BunnyHop", "|BunnyHop.NoSlowdown" );
			FILE_WRITE_INT ( g_Vars.BunnyHop.ScrollEmulation, "BunnyHop", "|BunnyHop.Scroll.Emulation" );
			FILE_WRITE_DIR ( g_Vars.BunnyHop.ScrollDirection, "BunnyHop", "|BunnyHop.Scroll.Direction" );
			FILE_WRITE_FLOAT_2 ( g_Vars.BunnyHop.ScrollDistance[0], g_Vars.BunnyHop.ScrollDistance[1], "BunnyHop", "|BunnyHop.Scroll.Distance" );
			FILE_WRITE_INT ( g_Vars.BunnyHop.ScrollRandFails, "BunnyHop", "|BunnyHop.Scroll.RandFails" );
			FILE_WRITE_INT ( g_Vars.BunnyHop.OnLadder, "BunnyHop", "|BunnyHop.OnLadder" );
			FILE_WRITE_INT ( g_Vars.BunnyHop.Helper, "BunnyHop", "|BunnyHop.Helper" );
			FILE_WRITE_INT ( g_Vars.BunnyHop.HelperNoSlowdown, "BunnyHop", "|BunnyHop.Helper.NoSlowdown" );
			FILE_WRITE_INT ( g_Vars.BunnyHop.HelperIdealPercent, "BunnyHop", "|BunnyHop.Helper.IdealPercent" );
			FILE_WRITE_INT ( g_Vars.BunnyHop.StandUpAuto, "BunnyHop", "|BunnyHop.StandUp.Auto" );
			FILE_WRITE_INT ( g_Vars.BunnyHop.StandUpFallVelocity, "BunnyHop", "|BunnyHop.StandUp.FallVelocity" );
			FILE_WRITE_KEY ( g_Vars.BunnyHop.StandUpKey, "BunnyHop", "|BunnyHop.StandUp.Key" );
			FILE_WRITE_KEY ( g_Vars.BunnyHop.Key, "BunnyHop", "|BunnyHop.Key" );
		}

		void Crosshair ( )
		{
			std::string Path = szDirFile ( VISUALS_PATH ).c_str ( );

			FILE_WRITE_INT ( g_Vars.Crosshair.Enable, "Crosshair", "|Crosshair.Enable" );
			FILE_WRITE_INT ( g_Vars.Crosshair.Dot, "Crosshair", "|Crosshair.Dot" );
			FILE_WRITE_INT ( g_Vars.Crosshair.Size, "Crosshair", "|Crosshair.Size" );
			FILE_WRITE_INT ( g_Vars.Crosshair.Gap, "Crosshair", "|Crosshair.Gap" );
			FILE_WRITE_INT ( g_Vars.Crosshair.Thickness, "Crosshair", "|Crosshair.Thickness" );
			FILE_WRITE_INT ( g_Vars.Crosshair.Dynamic, "Crosshair", "|Crosshair.Dynamic" );
			FILE_WRITE_FLOAT ( g_Vars.Crosshair.DynamicScale, "Crosshair", "|Crosshair.Dynamic.Scale" );
			FILE_WRITE_INT ( g_Vars.Crosshair.Outline, "Crosshair", "|Crosshair.Outline" );
			FILE_WRITE_INT ( g_Vars.Crosshair.Snipers, "Crosshair", "|Crosshair.Snipers" );

			FILE_WRITE_RGBA ( g_Vars.Crosshair.Color[0], g_Vars.Crosshair.Color[1], g_Vars.Crosshair.Color[2],
				g_Vars.Crosshair.Color[3], "Crosshair", "|Crosshair.Color" );
		}

		void AimWeapons ( )
		{
			std::string Path = szDirFile ( AIMBOT_PATH ).c_str ( );

			FILE_WRITE_INT ( g_Vars.Aim.Enable, "Aim", "|Aim.Enable" );
			FILE_WRITE_INT ( g_Vars.Aim.Silent, "Aim", "|Aim.Silent" );
			FILE_WRITE_INT ( g_Vars.Aim.FriendlyFire, "Aim", "|Aim.FriendlyFire" );
			FILE_WRITE_INT ( g_Vars.Aim.VisibleCheck, "Aim", "|Aim.VisibleCheck" );
			FILE_WRITE_INT ( g_Vars.Aim.FlashCheck, "Aim", "|Aim.FlashCheck" );
			FILE_WRITE_INT ( g_Vars.Aim.FOVDistance, "Aim", "|Aim.FOV.Distance" );
			FILE_WRITE_INT ( g_Vars.Aim.KillDelay, "Aim", "|Aim.KillDelay" );

			for ( int Index = 1; Index <= 30; ++Index )
			{
				std::string Weapon;

				Utils::GetSection ( Index, Weapon );

				std::string Aim = "|" + Weapon + ".Aim";
				std::string BulletControl = "|" + Weapon + ".BulletControl";
				std::string Nearest = "|" + Weapon + ".HitBox.Nearest";
				std::string HitBox = "|" + Weapon + ".HitBox";
				std::string Prediction = "|" + Weapon + ".Prediction";
				std::string FOV = "|" + Weapon + ".FOV";
				std::string Smooth = "|" + Weapon + ".Smooth";
				std::string Delay = "|" + Weapon + ".Delay";
				std::string DelayType = "|" + Weapon + ".Delay.Type";
				std::string Recoil = "|" + Weapon + ".Recoil";
				std::string RecoilPrediction = "|" + Weapon + ".Recoil.Prediction";
				std::string FOVRecoil = "|" + Weapon + ".Recoil.FOV";
				std::string SmoothRecoil = "|" + Weapon + ".Recoil.Smooth";

				FILE_WRITE_INT ( g_Vars.Weapons[Index].Aim, "Weapons", ( char* )Aim.c_str ( ) );
				FILE_WRITE_INT_2 ( g_Vars.Weapons[Index].BulletControl[0], g_Vars.Weapons[Index].BulletControl[1], "Weapons", ( char* )BulletControl.c_str ( ) );
				FILE_WRITE_INT ( g_Vars.Weapons[Index].HitBoxNearest, "Weapons", ( char* )Nearest.c_str ( ) );
				FILE_WRITE_INT ( g_Vars.Weapons[Index].HitBox, "Weapons", ( char* )HitBox.c_str ( ) );
				FILE_WRITE_FLOAT ( g_Vars.Weapons[Index].Prediction, "Weapons", ( char* )Prediction.c_str ( ) );
				FILE_WRITE_FLOAT ( g_Vars.Weapons[Index].FOV, "Weapons", ( char* )FOV.c_str ( ) );
				FILE_WRITE_FLOAT ( g_Vars.Weapons[Index].Smooth, "Weapons", ( char* )Smooth.c_str ( ) );
				FILE_WRITE_INT ( g_Vars.Weapons[Index].Delay, "Weapons", ( char* )Delay.c_str ( ) );
				FILE_WRITE_INT ( g_Vars.Weapons[Index].DelayType, "Weapons", ( char* )DelayType.c_str ( ) );
				FILE_WRITE_FLOAT ( g_Vars.Weapons[Index].Recoil, "Weapons", ( char* )Recoil.c_str ( ) );
				FILE_WRITE_FLOAT ( g_Vars.Weapons[Index].RecoilPrediction, "Weapons", ( char* )RecoilPrediction.c_str ( ) );
				FILE_WRITE_FLOAT ( g_Vars.Weapons[Index].RecoilFOV, "Weapons", ( char* )FOVRecoil.c_str ( ) );
				FILE_WRITE_FLOAT ( g_Vars.Weapons[Index].RecoilSmooth, "Weapons", ( char* )SmoothRecoil.c_str ( ) );
			}
		}

		void Other ( )
		{
			std::string Path = szDirFile ( VISUALS_PATH ).c_str ( );

			FILE_WRITE_INT ( g_Vars.Other.DrawAimSpot, "Other", "|Draw.Aim.Spot" );
			FILE_WRITE_INT ( g_Vars.Other.DrawAimFOV, "Other", "|Draw.Aim.FOV" );
			FILE_WRITE_INT ( g_Vars.Other.DrawPunch, "Other", "|Draw.Punch" );
			FILE_WRITE_INT ( g_Vars.Other.DrawSpread, "Other", "|Draw.Spread" );
			FILE_WRITE_INT ( g_Vars.Other.StatusAimBot, "Other", "|Status.AimBot" );
			FILE_WRITE_INT ( g_Vars.Other.StatusTriggerBot, "Other", "|Status.TriggerBot" );
			FILE_WRITE_INT ( g_Vars.Other.RemoveSmoke, "Other", "|Remove.Smoke" );

			FILE_WRITE_RGBA ( g_Vars.Other.FontColor[0], g_Vars.Other.FontColor[1],
				g_Vars.Other.FontColor[2], g_Vars.Other.FontColor[3], "Other", "|Font.Color" );

			FILE_WRITE_INT ( g_Vars.Other.FontOutline, "Other", "|Font.Outline" );
		}

		void Recoil ( )
		{
			std::string Path = szDirFile ( AIMBOT_PATH ).c_str ( );

			FILE_WRITE_INT ( g_Vars.Recoil.Enable, "Recoil", "|Recoil.Enable" );
			FILE_WRITE_FLOAT ( g_Vars.Recoil.X, "Recoil", "|Recoil.X" );
			FILE_WRITE_FLOAT ( g_Vars.Recoil.Y, "Recoil", "|Recoil.Y" );
			FILE_WRITE_FLOAT ( g_Vars.Recoil.Smooth, "Recoil", "|Recoil.Smooth" );
			FILE_WRITE_INT ( g_Vars.Recoil.BulletStart, "Recoil", "|Recoil.BulletStart" );
		}

		void AutoPistol ( )
		{
			std::string Path = szDirFile ( AIMBOT_PATH ).c_str ( );

			FILE_WRITE_INT ( g_Vars.AutoPistol.Enable, "AutoPistol", "|AutoPistol.Enable" );
			FILE_WRITE_INT ( g_Vars.AutoPistol.Delay, "AutoPistol", "|AutoPistol.Delay" );
		}

		void FastZoom ( )
		{
			std::string Path = szDirFile ( AIMBOT_PATH ).c_str ( );

			FILE_WRITE_INT ( g_Vars.FastZoom.Enable, "FastZoom", "|FastZoom.Enable" );
			FILE_WRITE_INT ( g_Vars.FastZoom.Delay, "FastZoom", "|FastZoom.Delay" );
			FILE_WRITE_INT ( g_Vars.FastZoom.QuickSwitch, "FastZoom", "|FastZoom.QuickSwitch" );
		}

		void Chams ( )
		{
			std::string Path = szDirFile ( VISUALS_PATH ).c_str ( );

			FILE_WRITE_INT ( g_Vars.Chams.Enable, "Chams", "|Chams.Enable" );
			FILE_WRITE_INT ( g_Vars.Chams.Player, "Chams", "|Chams.Player" );
			FILE_WRITE_INT ( g_Vars.Chams.PlayerVisibleOnly, "Chams", "|Chams.Player.VisibleOnly" );
			FILE_WRITE_INT ( g_Vars.Chams.PlayerRenderType, "Chams", "|Chams.Player.RenderType" );
			FILE_WRITE_RGB ( g_Vars.Chams.ColorTVis[0], g_Vars.Chams.ColorTVis[1], g_Vars.Chams.ColorTVis[2], "Chams", "|Chams.Player.T.Vis" );
			FILE_WRITE_RGB ( g_Vars.Chams.ColorTHide[0], g_Vars.Chams.ColorTHide[1], g_Vars.Chams.ColorTHide[2], "Chams", "|Chams.Player.T.Hide" );
			FILE_WRITE_RGB ( g_Vars.Chams.ColorCTVis[0], g_Vars.Chams.ColorCTVis[1], g_Vars.Chams.ColorCTVis[2], "Chams", "|Chams.Player.CT.Vis" );
			FILE_WRITE_RGB ( g_Vars.Chams.ColorCTHide[0], g_Vars.Chams.ColorCTHide[1], g_Vars.Chams.ColorCTHide[2], "Chams", "|Chams.Player.CT.Hide" );
			FILE_WRITE_INT ( g_Vars.Chams.Weapon, "Chams", "|Chams.Weapon" );
			FILE_WRITE_INT ( g_Vars.Chams.WeaponVisibleOnly, "Chams", "|Chams.Weapon.VisibleOnly" );
			FILE_WRITE_INT ( g_Vars.Chams.WeaponRenderType, "Chams", "|Chams.Weapon.RenderType" );
			FILE_WRITE_RGB ( g_Vars.Chams.WeaponColorVis[0], g_Vars.Chams.WeaponColorVis[1], g_Vars.Chams.WeaponColorVis[2], "Chams", "|Chams.Weapon.Color.Vis" );
			FILE_WRITE_RGB ( g_Vars.Chams.WeaponColorHide[0], g_Vars.Chams.WeaponColorHide[1], g_Vars.Chams.WeaponColorHide[2], "Chams", "|Chams.Weapon.Color.Hide" );
			FILE_WRITE_INT ( g_Vars.Chams.Hands, "Chams", "|Chams.Hands" );
			FILE_WRITE_INT ( g_Vars.Chams.HandsRenderType, "Chams", "|Chams.Hands.RenderType" );
			FILE_WRITE_RGB ( g_Vars.Chams.HandsColor[0], g_Vars.Chams.HandsColor[1], g_Vars.Chams.HandsColor[2], "Chams", "|Chams.Hands.Color" );
		}

		void GroundStrafe ( )
		{
			std::string Path = szDirFile ( MISC_PATH ).c_str ( );

			FILE_WRITE_INT ( g_Vars.GroundStrafe.ScrollEmulation, "GroundStrafe", "|GroundStrafe.Scroll.Emulation" );
			FILE_WRITE_DIR ( g_Vars.GroundStrafe.ScrollDirection, "GroundStrafe", "|GroundStrafe.Scroll.Direction" );
			FILE_WRITE_FLOAT_2 ( g_Vars.GroundStrafe.ScrollDistance[0], g_Vars.GroundStrafe.ScrollDistance[1], "GroundStrafe", "|GroundStrafe.Scroll.Distance" );
			FILE_WRITE_INT_2 ( g_Vars.GroundStrafe.ScrollCount[0], g_Vars.GroundStrafe.ScrollCount[1], "GroundStrafe", "|GroundStrafe.Scroll.Count" );
			FILE_WRITE_FLOAT ( g_Vars.GroundStrafe.SlowdownScale, "GroundStrafe", "|GroundStrafe.Slowdown.Scale" );
			FILE_WRITE_FLOAT ( g_Vars.GroundStrafe.SlowdownAngle, "GroundStrafe", "|GroundStrafe.Slowdown.Angle" );
			FILE_WRITE_INT ( g_Vars.GroundStrafe.FallRun, "GroundStrafe", "|GroundStrafe.FallRun" );
			FILE_WRITE_INT ( g_Vars.GroundStrafe.Helper, "GroundStrafe", "|GroundStrafe.Helper" );
			FILE_WRITE_INT ( g_Vars.GroundStrafe.StandUpFallVelocity, "GroundStrafe", "|GroundStrafe.StandUp.FallVelocity" );
			FILE_WRITE_KEY ( g_Vars.GroundStrafe.StandUpKey, "GroundStrafe", "|GroundStrafe.StandUp.Key" );
			FILE_WRITE_KEY ( g_Vars.GroundStrafe.Key, "GroundStrafe", "|GroundStrafe.Key" );
		}

		void TriggerWeapons ( )
		{
			std::string Path = szDirFile ( TRIGGERBOT_PATH ).c_str ( );

			FILE_WRITE_INT ( g_Vars.Trigger.Enable, "Trigger", "|Trigger.Enable" );
			FILE_WRITE_INT ( g_Vars.Trigger.FriendlyFire, "Trigger", "|Trigger.FriendlyFire" );
			FILE_WRITE_INT ( g_Vars.Trigger.VisibleCheck, "Trigger", "|Trigger.VisibleCheck" );
			FILE_WRITE_INT ( g_Vars.Trigger.SnipersOnlyInZoom, "Trigger", "|Trigger.Snipers.OnlyInZoom" );

			for ( int Index = 1; Index <= 30; ++Index )
			{
				std::string Weapon;

				Utils::GetSection ( Index, Weapon );

				std::string Trigger = "|" + Weapon + ".Trigger";
				std::string OnlyHead = "|" + Weapon + ".OnlyHead";
				std::string ProSpread = "|" + Weapon + ".ProSpread";

				FILE_WRITE_INT ( g_Vars.TriggerWeapons[Index].Trigger, "Weapons", ( char* )Trigger.c_str ( ) );
				FILE_WRITE_INT ( g_Vars.TriggerWeapons[Index].OnlyHead, "Weapons", ( char* )OnlyHead.c_str ( ) );
				FILE_WRITE_INT ( g_Vars.TriggerWeapons[Index].ProSpread, "Weapons", ( char* )ProSpread.c_str ( ) );
			}
		}
	}

	void GetBaseDir ( const HINSTANCE& hInstance )
	{
		Files::BaseDir = ( char* )HeapAlloc ( GetProcessHeap ( ), HEAP_ZERO_MEMORY, MAX_PATH );

		GetModuleFileName ( hInstance, Files::BaseDir, MAX_PATH );

		char* Position = Files::BaseDir + lstrlen ( Files::BaseDir );

		while ( Position >= Files::BaseDir && *Position != '\\' )
		{
			--Position;
		}

		Position[1] = 0;
	}

	void LoadSettings ( )
	{
		FilesCheck ( );

		LoadFileMain ( );
		LoadFileFunctions ( );
		LoadFileVisuals ( );
		LoadFileMisc ( );
		LoadFileAimBot ( );
		LoadFileTriggerBot ( );
	}

	void ReloadSettings ( )
	{
		FilesCheck ( );

		LoadFileMain ( );
		LoadFileVisuals ( );
		LoadFileMisc ( );
		LoadFileAimBot ( );
		LoadFileTriggerBot ( );
	}

	void SaveSettings ( )
	{
		FilesCheck ( );

		SaveFileMain ( );
		SaveFileVisuals ( );
		SaveFileMisc ( );
		SaveFileAimBot ( );
		SaveFileTriggerBot ( );
	}

	void FilesCheck ( )
	{
		if ( !FileExists ( szDirFile ( MAIN_PATH ).c_str ( ) ) )
		{
			CreateSettingsDirectory ( );
			CreateFileMain ( );
		}

		if ( !FileExists ( szDirFile ( FUNCTIONS_PATH ).c_str ( ) ) )
		{
			CreateSettingsDirectory ( );
			CreateFileFunctions ( );
		}

		if ( !FileExists ( szDirFile ( VISUALS_PATH ).c_str ( ) ) )
		{
			CreateSettingsDirectory ( );
			CreateFileVisuals ( );
		}

		if ( !FileExists ( szDirFile ( MISC_PATH ).c_str ( ) ) )
		{
			CreateSettingsDirectory ( );
			CreateFileMisc ( );
		}

		if ( !FileExists ( szDirFile ( AIMBOT_PATH ).c_str ( ) ) )
		{
			CreateSettingsDirectory ( );
			CreateFileAimBot ( );
		}

		if ( !FileExists ( szDirFile ( TRIGGERBOT_PATH ).c_str ( ) ) )
		{
			CreateSettingsDirectory ( );
			CreateFileTriggerBot ( );
		}
	}

	void LoadFileMain ( )
	{
		if ( FileExists ( szDirFile ( MAIN_PATH ).c_str ( ) ) )
			Read::Main ( );
	}

	void LoadFileFunctions ( )
	{
		if ( FileExists ( szDirFile ( FUNCTIONS_PATH ).c_str ( ) ) )
			Read::Functions ( );
	}

	void LoadFileVisuals ( )
	{
		if ( FileExists ( szDirFile ( VISUALS_PATH ).c_str ( ) ) )
		{
			if ( g_Vars.Functions.Menu )
				Read::Menu ( );

			if ( g_Vars.Functions.ScreenInfo )
				Read::ScreenInfo ( );

			if ( g_Vars.Functions.ESP )
				Read::ESP ( );

			if ( g_Vars.Functions.Chams )
				Read::Chams ( );

			if ( g_Vars.Functions.NoFlash )
				Read::NoFlash ( );

			if ( g_Vars.Functions.Crosshair )
				Read::Crosshair ( );

			Read::Other ( );
		}
	}

	void LoadFileMisc ( )
	{
		if ( FileExists ( szDirFile ( MISC_PATH ).c_str ( ) ) )
		{
			if ( g_Vars.Functions.Speed )
				Read::Speed ( );

			if ( g_Vars.Functions.BunnyHop )
				Read::BunnyHop ( );

			if ( g_Vars.Functions.GroundStrafe )
				Read::GroundStrafe ( );
		}
	}

	void LoadFileAimBot ( )
	{
		if ( FileExists ( szDirFile ( AIMBOT_PATH ).c_str ( ) ) )
		{
			if ( g_Vars.Functions.Weapons )
				Read::AimWeapons ( );

			if ( g_Vars.Functions.Recoil )
				Read::Recoil ( );

			if ( g_Vars.Functions.AutoPistol )
				Read::AutoPistol ( );

			if ( g_Vars.Functions.FastZoom )
				Read::FastZoom ( );
		}
	}

	void LoadFileTriggerBot ( )
	{
		if ( FileExists ( szDirFile ( TRIGGERBOT_PATH ).c_str ( ) ) )
		{
			if ( g_Vars.Functions.TriggerWeapons )
				Read::TriggerWeapons ( );
		}
	}

	void SaveFileMain ( )
	{
		if ( FileExists ( szDirFile ( MAIN_PATH ).c_str ( ) ) )
			Write::Main ( );
	}

	void SaveFileVisuals ( )
	{
		if ( FileExists ( szDirFile ( VISUALS_PATH ).c_str ( ) ) )
		{
			if ( g_Vars.Functions.Menu )
				Write::Menu ( );

			if ( g_Vars.Functions.ScreenInfo )
				Write::ScreenInfo ( );

			if ( g_Vars.Functions.ESP )
				Write::ESP ( );

			if ( g_Vars.Functions.Chams )
				Write::Chams ( );

			if ( g_Vars.Functions.NoFlash )
				Write::NoFlash ( );

			if ( g_Vars.Functions.Crosshair )
				Write::Crosshair ( );

			Write::Other ( );
		}
	}

	void SaveFileMisc ( )
	{
		if ( FileExists ( szDirFile ( MISC_PATH ).c_str ( ) ) )
		{
			if ( g_Vars.Functions.Speed )
				Write::Speed ( );

			if ( g_Vars.Functions.BunnyHop )
				Write::BunnyHop ( );

			if ( g_Vars.Functions.GroundStrafe )
				Write::GroundStrafe ( );
		}
	}

	void SaveFileAimBot ( )
	{
		if ( FileExists ( szDirFile ( AIMBOT_PATH ).c_str ( ) ) )
		{
			if ( g_Vars.Functions.Weapons )
				Write::AimWeapons ( );

			if ( g_Vars.Functions.Recoil )
				Write::Recoil ( );

			if ( g_Vars.Functions.AutoPistol )
				Write::AutoPistol ( );

			if ( g_Vars.Functions.FastZoom )
				Write::FastZoom ( );
		}
	}

	void SaveFileTriggerBot ( )
	{
		if ( FileExists ( szDirFile ( TRIGGERBOT_PATH ).c_str ( ) ) )
		{
			if ( g_Vars.Functions.TriggerWeapons )
				Write::TriggerWeapons ( );
		}
	}

	void CreateLogDirectory ( )
	{
		char* LogDirectiory = new char[256];

		lstrcpy ( LogDirectiory, BaseDir );
		lstrcat ( LogDirectiory, LOG_DIR_PATH );
		CreateDirectory ( LogDirectiory, 0 );
	}

	void CreateInjectLogFile ( )
	{
		char InjectLogFile[1024];

		strcpy_s ( InjectLogFile, BaseDir );
		strcat_s ( InjectLogFile, LOG_INJECT_PATH );

		if ( !FileExists ( szDirFile ( LOG_INJECT_PATH ).c_str ( ) ) )
		{
			Inject.open ( InjectLogFile, std::ios::app );
		}
		else
		{
			Inject.open ( InjectLogFile, std::ios::app );

			Inject << std::endl;
		}
	}

	void CreateInfoLogFile ( )
	{
		char InfoLogFile[1024];

		strcpy_s ( InfoLogFile, BaseDir );
		strcat_s ( InfoLogFile, "\\Logs\\Info.log" );

		if ( !FileExists ( szDirFile ( LOG_INJECT_PATH ).c_str ( ) ) )
		{
			Info.open ( InfoLogFile, std::ios::app );
		}
		else
		{
			Info.open ( InfoLogFile, std::ios::app );

			Info << std::endl;
		}
	}

	void CreateSettingsDirectory ( )
	{
		char* SettingsPath = new char[256];

		lstrcpy ( SettingsPath, BaseDir );
		lstrcat ( SettingsPath, SETTINGS_DIR_PATH );

		CreateDirectory ( SettingsPath, 0 );
	}

	void CreateFileMain ( )
	{
		std::ofstream Main;

		char* MainPath = new char[256];

		lstrcpy ( MainPath, BaseDir );
		lstrcat ( MainPath, MAIN_PATH );

		Main.open ( MainPath, std::ios::app );

		Main << "[Main]" << std::endl;
		Main << "|Language = english" << std::endl << std::endl;

		Main << "|Reload.Key = F5" << std::endl;
		Main << "|Save.Key = F6" << std::endl << std::endl;

		Main << "|Panic.Key = F7" << std::endl;
		Main << "|Panic.AimBot.Key = F8" << std::endl;
		Main << "|Panic.Visuals.Key = F9" << std::endl;
		Main << "|Panic.Misc.Key = F10" << std::endl << std::endl;

		Main << "|Player.Valid.Check = 1" << std::endl << std::endl;

		Main << "|AntiScreen.Enable = 1" << std::endl;
		Main << "|AntiScreen.Timer = 6" << std::endl;
		Main << "|AntiScreen.Key = F12" << std::endl << std::endl;

		Main << "|Font.Outline.Style = 1" << std::endl;

		Main.close ( );
	}

	void CreateFileFunctions ( )
	{
		std::ofstream Functions;

		char* FunctionsPath = new char[256];

		lstrcpy ( FunctionsPath, BaseDir );
		lstrcat ( FunctionsPath, FUNCTIONS_PATH );

		Functions.open ( FunctionsPath, std::ios::app );

		Functions << "[Visuals]" << std::endl;
		Functions << "|Menu = 1" << std::endl;
		Functions << "|ScreenInfo = 1" << std::endl;
		Functions << "|ESP = 1" << std::endl;
		Functions << "|Chams = 1" << std::endl;
		Functions << "|NoFlash = 1" << std::endl;
		Functions << "|Crosshair = 1" << std::endl << std::endl;

		Functions << "[Misc]" << std::endl;
		Functions << "|Speed = 1" << std::endl;
		Functions << "|BunnyHop = 1" << std::endl;
		Functions << "|GroundStrafe = 1" << std::endl << std::endl;

		Functions << "[AimBot]" << std::endl;
		Functions << "|Weapons = 1" << std::endl;
		Functions << "|Recoil = 1" << std::endl;
		Functions << "|AutoPistol = 1" << std::endl;
		Functions << "|FastZoom = 1" << std::endl << std::endl;

		Functions << "[TriggerBot]" << std::endl;
		Functions << "|Weapons = 1" << std::endl;

		Functions.close ( );
	}

	void CreateFileVisuals ( )
	{
		std::ofstream Visuals;

		char* VisualsPath = new char[256];

		lstrcpy ( VisualsPath, BaseDir );
		lstrcat ( VisualsPath, VISUALS_PATH );

		Visuals.open ( VisualsPath, std::ios::app );

		Visuals << "[Menu]" << std::endl;
		Visuals << "|Menu.X = 200" << std::endl;
		Visuals << "|Menu.Y = 138" << std::endl;
		Visuals << "|Menu.Box.Height = 21" << std::endl;
		Visuals << "|Menu.Box.Width = 174" << std::endl;
		Visuals << "|Menu.Box.Color = 20, 20, 20, 130" << std::endl;
		Visuals << "|Menu.Box.Outline.Color = 30, 30, 80, 80" << std::endl;
		Visuals << "|Menu.Box.Select.Color = 0, 100, 255, 80" << std::endl;
		Visuals << "|Menu.Text.Color = 255, 255, 255" << std::endl;
		Visuals << "|Menu.Key = INSERT" << std::endl << std::endl;

		Visuals << "[ScreenInfo]" << std::endl;
		Visuals << "|ScreenInfo.Enable = 1" << std::endl;
		Visuals << "|ScreenInfo.FPS = 0" << std::endl;
		Visuals << "|ScreenInfo.Copyright = 1" << std::endl;
		Visuals << "|ScreenInfo.Time = 1" << std::endl;
		Visuals << "|ScreenInfo.ShowKeys = 0" << std::endl;
		Visuals << "|ScreenInfo.KreedzInfo = 0" << std::endl;
		Visuals << "|ScreenInfo.Font.Color = 255, 255, 255, 255" << std::endl;
		Visuals << "|ScreenInfo.Font.Outline = 1" << std::endl << std::endl;

		Visuals << "[ESP]" << std::endl;
		Visuals << "|ESP.Enable = 1" << std::endl;
		Visuals << "|ESP.Player = 1" << std::endl;
		Visuals << "|ESP.Player.VisibleOnly = 0" << std::endl;
		Visuals << "|ESP.Player.Box = 1" << std::endl;
		Visuals << "|ESP.Player.Box.Filled = 0" << std::endl;
		Visuals << "|ESP.Player.Box.T.Vis = 255, 255, 0" << std::endl;
		Visuals << "|ESP.Player.Box.T.Hide = 255, 30, 0" << std::endl;
		Visuals << "|ESP.Player.Box.CT.Vis = 0, 255, 0" << std::endl;
		Visuals << "|ESP.Player.Box.CT.Hide = 0, 30, 255" << std::endl;
		Visuals << "|ESP.Player.Name = 0" << std::endl;
		Visuals << "|ESP.Player.Weapon = 0" << std::endl;
		Visuals << "|ESP.Player.Distance = 0" << std::endl;
		Visuals << "|ESP.Player.Barrel = 0" << std::endl;
		Visuals << "|ESP.World.C4 = 1" << std::endl;
		Visuals << "|ESP.World.Items = 0" << std::endl;
		Visuals << "|ESP.World.Nades = 1" << std::endl;
		Visuals << "|ESP.C4Timer = 2" << std::endl;
		Visuals << "|ESP.C4Timer.Value = 35" << std::endl;
		Visuals << "|ESP.Sound = 0" << std::endl;
		Visuals << "|ESP.Sound.Distance = 1000" << std::endl;
		Visuals << "|ESP.Sound.FadeTime = 1000" << std::endl;
		Visuals << "|ESP.Font.Color = 255, 255, 255, 255" << std::endl;
		Visuals << "|ESP.Font.Outline = 1" << std::endl << std::endl;

		Visuals << "[Chams]" << std::endl;
		Visuals << "|Chams.Enable = 0" << std::endl;
		Visuals << "|Chams.Player = 1" << std::endl;
		Visuals << "|Chams.Player.VisibleOnly = 0" << std::endl;
		Visuals << "|Chams.Player.RenderType = 2" << std::endl;
		Visuals << "|Chams.Player.T.Vis = 255, 140, 0" << std::endl;
		Visuals << "|Chams.Player.T.Hide = 255, 30, 0" << std::endl;
		Visuals << "|Chams.Player.CT.Vis = 0, 140, 255" << std::endl;
		Visuals << "|Chams.Player.CT.Hide = 0, 30, 255" << std::endl;
		Visuals << "|Chams.Weapon = 0" << std::endl;
		Visuals << "|Chams.Weapon.VisibleOnly = 1" << std::endl;
		Visuals << "|Chams.Weapon.RenderType = 2" << std::endl;
		Visuals << "|Chams.Weapon.Color.Vis = 0, 140, 0" << std::endl;
		Visuals << "|Chams.Weapon.Color.Hide = 80, 80, 80" << std::endl;
		Visuals << "|Chams.Hands = 0" << std::endl;
		Visuals << "|Chams.Hands.RenderType = 2" << std::endl;
		Visuals << "|Chams.Hands.Color = 0, 140, 255" << std::endl << std::endl;

		Visuals << "[NoFlash]" << std::endl;
		Visuals << "|NoFlash.Enable = 0" << std::endl;
		Visuals << "|NoFlash.Fade.Limit = 100" << std::endl;
		Visuals << "|NoFlash.Fade.Color.Enable = 0" << std::endl;
		Visuals << "|NoFlash.Fade.Color = 255, 255, 255" << std::endl;
		Visuals << "|NoFlash.Fade.Color.Random = 0" << std::endl;
		Visuals << "|NoFlash.DrawFlashed = 1" << std::endl;
		Visuals << "|NoFlash.Font.Outline = 0" << std::endl << std::endl;

		Visuals << "[Crosshair]" << std::endl;
		Visuals << "|Crosshair.Enable = 1" << std::endl;
		Visuals << "|Crosshair.Dot = 0" << std::endl;
		Visuals << "|Crosshair.Size = 6" << std::endl;
		Visuals << "|Crosshair.Gap = 5" << std::endl;
		Visuals << "|Crosshair.Thickness = 1" << std::endl;
		Visuals << "|Crosshair.Dynamic = 1" << std::endl;
		Visuals << "|Crosshair.Dynamic.Scale = 4.0" << std::endl;
		Visuals << "|Crosshair.Outline = 0" << std::endl;
		Visuals << "|Crosshaie.Snipers = 1" << std::endl;
		Visuals << "|Crosshair.Color = 64, 255, 64, 255" << std::endl << std::endl;

		Visuals << "[Other]" << std::endl;
		Visuals << "|Draw.Aim.Spot = 0" << std::endl;
		Visuals << "|Draw.Aim.FOV = 0" << std::endl;
		Visuals << "|Draw.Punch = 0" << std::endl;
		Visuals << "|Draw.Spread = 0" << std::endl;
		Visuals << "|Status.AimBot = 0" << std::endl;
		Visuals << "|Status.TriggerBot = 1" << std::endl;
		Visuals << "|Remove.Smoke = 0" << std::endl;
		Visuals << "|Font.Color = 255, 255, 255, 255" << std::endl;
		Visuals << "|Font.Outline = 1" << std::endl;

		Visuals.close ( );
	}

	void CreateFileMisc ( )
	{
		std::ofstream Misc;

		char* MiscPath = new char[256];

		lstrcpy ( MiscPath, BaseDir );
		lstrcat ( MiscPath, MISC_PATH );

		Misc.open ( MiscPath, std::ios::app );

		Misc << "[Speed]" << std::endl;
		Misc << "|Speed.Player = 1.0" << std::endl;
		Misc << "|Speed.Engine = 0" << std::endl;
		Misc << "|Speed.Boost = 5.0" << std::endl;
		Misc << "|Speed.Boost.Key = none" << std::endl;
		Misc << "|Speed.Slowmo = 0.3" << std::endl;
		Misc << "|Speed.Slowmo.Key = none" << std::endl;
		Misc << "|Speed.Helper = 0" << std::endl;
		Misc << "|Speed.Helper.Ground = 1.1" << std::endl;
		Misc << "|Speed.Helper.Ladder = 1.1" << std::endl;
		Misc << "|Speed.Helper.Fly = 1.0" << std::endl << std::endl;

		Misc << "[BunnyHop]" << std::endl;
		Misc << "|BunnyHop.NoSlowdown = 1" << std::endl;
		Misc << "|BunnyHop.Scroll.Emulation = 0" << std::endl;
		Misc << "|BunnyHop.Scroll.Direction = up" << std::endl;
		Misc << "|BunnyHop.Scroll.Distance = 0.0, 11.5" << std::endl;
		Misc << "|BunnyHop.Scroll.RandFails = 0" << std::endl;
		Misc << "|BunnyHop.OnLadder = 1" << std::endl;
		Misc << "|BunnyHop.Helper = 1" << std::endl;
		Misc << "|BunnyHop.Helper.NoSlowdown = 1" << std::endl;
		Misc << "|BunnyHop.Helper.IdealPercent = 50" << std::endl;
		Misc << "|BunnyHop.StandUp.Auto = 0" << std::endl;
		Misc << "|BunnyHop.StandUp.FallVelocity = 180.0" << std::endl;
		Misc << "|BunnyHop.StandUp.Key = none" << std::endl;
		Misc << "|BunnyHop.Key = SPACE" << std::endl << std::endl;

		Misc << "[GroundStrafe]" << std::endl;
		Misc << "|GroundStrafe.Scroll.Emulation = 0" << std::endl;
		Misc << "|GroundStrafe.Scroll.Direction = down" << std::endl;
		Misc << "|GroundStrafe.Scroll.Distance = 0.0, 5.0" << std::endl;
		Misc << "|GroundStrafe.Scroll.Count = 1, 3" << std::endl;
		Misc << "|GroundStrafe.Slowdown.Scale = 1.0" << std::endl;
		Misc << "|GroundStrafe.Slowdown.Angle = 5.0" << std::endl;
		Misc << "|GroundStrafe.FallRun = 1" << std::endl;
		Misc << "|GroundStrafe.Helper = 1" << std::endl;
		Misc << "|GroundStrafe.StandUp.FallVelocity = 100" << std::endl;
		Misc << "|GroundStrafe.StandUp.Key = none" << std::endl;
		Misc << "|GroundStrafe.Key = none" << std::endl;

		Misc.close ( );
	}

	void CreateFileAimBot ( )
	{
		std::ofstream AimBot;

		char* AimBotPath = new char[256];

		lstrcpy ( AimBotPath, BaseDir );
		lstrcat ( AimBotPath, AIMBOT_PATH );

		AimBot.open ( AimBotPath, std::ios::app );

		AimBot << "[Aim]" << std::endl;
		AimBot << "|Aim.Enable = 1" << std::endl;
		AimBot << "|Aim.Silent = 0" << std::endl;
		AimBot << "|Aim.FriendlyFire = 0" << std::endl;
		AimBot << "|Aim.VisibleCheck = 1" << std::endl;
		AimBot << "|Aim.FlashCheck = 1" << std::endl;
		AimBot << "|Aim.FOV.Distance = 1" << std::endl;
		AimBot << "|Aim.KillDelay = 250" << std::endl << std::endl;

		AimBot << "[Recoil]" << std::endl;
		AimBot << "|Recoil.Enable = 0" << std::endl;
		AimBot << "|Recoil.X = 2.0" << std::endl;
		AimBot << "|Recoil.Y = 2.0" << std::endl;
		AimBot << "|Recoil.Smooth = 1.2" << std::endl;
		AimBot << "|Recoil.BulletStart = 2" << std::endl << std::endl;

		AimBot << "[AutoPistol]" << std::endl;
		AimBot << "|AutoPistol.Enable = 0" << std::endl;
		AimBot << "|AutoPistol.Delay = 25" << std::endl << std::endl;

		AimBot << "[FastZoom]" << std::endl;
		AimBot << "|FastZoom.Enable = 0" << std::endl;
		AimBot << "|FastZoom.Delay = 10" << std::endl;
		AimBot << "|FastZoom.QuickSwitch = 0" << std::endl << std::endl;

		AimBot << "[Weapons]" << std::endl;
		AimBot << "|USP.Aim = 1" << std::endl;
		AimBot << "|USP.BulletControl = 2, 1" << std::endl;
		AimBot << "|USP.HitBox = 11" << std::endl;
		AimBot << "|USP.HitBox.Nearest = 0" << std::endl;
		AimBot << "|USP.Prediction = 0.10" << std::endl;
		AimBot << "|USP.FOV = 2.5" << std::endl;
		AimBot << "|USP.Smooth = 4.0" << std::endl;
		AimBot << "|USP.Delay = 50" << std::endl;
		AimBot << "|USP.Delay.Type = 2" << std::endl;
		AimBot << "|USP.Recoil = 2.0" << std::endl;
		AimBot << "|USP.Recoil.Prediction = 0.20" << std::endl;
		AimBot << "|USP.Recoil.FOV = 5" << std::endl;
		AimBot << "|USP.Recoil.Smooth = 5.0" << std::endl << std::endl;

		AimBot << "|Glock18.Aim = 1" << std::endl;
		AimBot << "|Glock18.BulletControl = 2, 1" << std::endl;
		AimBot << "|Glock18.HitBox = 11" << std::endl;
		AimBot << "|Glock18.HitBox.Nearest = 0" << std::endl;
		AimBot << "|Glock18.Prediction = 0.10" << std::endl;
		AimBot << "|Glock18.FOV = 2.5" << std::endl;
		AimBot << "|Glock18.Smooth = 4.0" << std::endl;
		AimBot << "|Glock18.Delay = 50" << std::endl;
		AimBot << "|Glock18.Delay.Type = 2" << std::endl;
		AimBot << "|Glock18.Recoil = 2.0" << std::endl;
		AimBot << "|Glock18.Recoil.Prediction = 0.20" << std::endl;
		AimBot << "|Glock18.Recoil.FOV = 5" << std::endl;
		AimBot << "|Glock18.Recoil.Smooth = 5.0" << std::endl << std::endl;

		AimBot << "|DEagle.Aim = 1" << std::endl;
		AimBot << "|DEagle.BulletControl = 2, 1" << std::endl;
		AimBot << "|DEagle.HitBox = 11" << std::endl;
		AimBot << "|DEagle.HitBox.Nearest = 0" << std::endl;
		AimBot << "|DEagle.Prediction = 0.10" << std::endl;
		AimBot << "|DEagle.FOV = 2.5" << std::endl;
		AimBot << "|DEagle.Smooth = 4.0" << std::endl;
		AimBot << "|DEagle.Delay = 50" << std::endl;
		AimBot << "|DEagle.Delay.Type = 2" << std::endl;
		AimBot << "|DEagle.Recoil = 2.0" << std::endl;
		AimBot << "|DEagle.Recoil.Prediction = 0.20" << std::endl;
		AimBot << "|DEagle.Recoil.FOV = 5" << std::endl;
		AimBot << "|DEagle.Recoil.Smooth = 5.0" << std::endl << std::endl;

		AimBot << "|Five-Seven.Aim = 1" << std::endl;
		AimBot << "|Five-Seven.BulletControl = 2, 1" << std::endl;
		AimBot << "|Five-Seven.HitBox = 11" << std::endl;
		AimBot << "|Five-Seven.HitBox.Nearest = 0" << std::endl;
		AimBot << "|Five-Seven.Prediction = 0.10" << std::endl;
		AimBot << "|Five-Seven.FOV = 2.5" << std::endl;
		AimBot << "|Five-Seven.Smooth = 4.0" << std::endl;
		AimBot << "|Five-Seven.Delay = 50" << std::endl;
		AimBot << "|Five-Seven.Delay.Type = 2" << std::endl;
		AimBot << "|Five-Seven.Recoil = 2.0" << std::endl;
		AimBot << "|Five-Seven.Recoil.Prediction = 0.20" << std::endl;
		AimBot << "|Five-Seven.Recoil.FOV = 5" << std::endl;
		AimBot << "|Five-Seven.Recoil.Smooth = 5.0" << std::endl << std::endl;

		AimBot << "|Elite.Aim = 1" << std::endl;
		AimBot << "|Elite.BulletControl = 2, 1" << std::endl;
		AimBot << "|Elite.HitBox = 11" << std::endl;
		AimBot << "|Elite.HitBox.Nearest = 0" << std::endl;
		AimBot << "|Elite.Prediction = 0.10" << std::endl;
		AimBot << "|Elite.FOV = 2.5" << std::endl;
		AimBot << "|Elite.Smooth = 4.0" << std::endl;
		AimBot << "|Elite.Delay = 50" << std::endl;
		AimBot << "|Elite.Delay.Type = 2" << std::endl;
		AimBot << "|Elite.Recoil = 2.0" << std::endl;
		AimBot << "|Elite.Recoil.Prediction = 0.20" << std::endl;
		AimBot << "|Elite.Recoil.FOV = 5" << std::endl;
		AimBot << "|Elite.Recoil.Smooth = 5.0" << std::endl << std::endl;

		AimBot << "|P228.Aim = 1" << std::endl;
		AimBot << "|P228.BulletControl = 2, 1" << std::endl;
		AimBot << "|P228.HitBox = 11" << std::endl;
		AimBot << "|P228.HitBox.Nearest = 0" << std::endl;
		AimBot << "|P228.Prediction = 0.10" << std::endl;
		AimBot << "|P228.FOV = 2.5" << std::endl;
		AimBot << "|P228.Smooth = 4.0" << std::endl;
		AimBot << "|P228.Delay = 50" << std::endl;
		AimBot << "|P228.Delay.Type = 2" << std::endl;
		AimBot << "|P228.Recoil = 2.0" << std::endl;
		AimBot << "|P228.Recoil.Prediction = 0.20" << std::endl;
		AimBot << "|P228.Recoil.FOV = 5" << std::endl;
		AimBot << "|P228.Recoil.Smooth = 5.0" << std::endl << std::endl;

		AimBot << "|AK47.Aim = 1" << std::endl;
		AimBot << "|AK47.BulletControl = 2, 1000" << std::endl;
		AimBot << "|AK47.HitBox = 11" << std::endl;
		AimBot << "|AK47.HitBox.Nearest = 1" << std::endl;
		AimBot << "|AK47.Prediction = 0.10" << std::endl;
		AimBot << "|AK47.FOV = 2.5" << std::endl;
		AimBot << "|AK47.Smooth = 4.0" << std::endl;
		AimBot << "|AK47.Delay = 50" << std::endl;
		AimBot << "|AK47.Delay.Type = 2" << std::endl;
		AimBot << "|AK47.Recoil = 2.0" << std::endl;
		AimBot << "|AK47.Recoil.Prediction = 1.10" << std::endl;
		AimBot << "|AK47.Recoil.FOV = 8.0" << std::endl;
		AimBot << "|AK47.Recoil.Smooth = 14.0" << std::endl << std::endl;

		AimBot << "|M4A1.Aim = 1" << std::endl;
		AimBot << "|M4A1.BulletControl = 2, 1000" << std::endl;
		AimBot << "|M4A1.HitBox = 11" << std::endl;
		AimBot << "|M4A1.HitBox.Nearest = 1" << std::endl;
		AimBot << "|M4A1.Prediction = 0.10" << std::endl;
		AimBot << "|M4A1.FOV = 2.5" << std::endl;
		AimBot << "|M4A1.Smooth = 4.0" << std::endl;
		AimBot << "|M4A1.Delay = 50" << std::endl;
		AimBot << "|M4A1.Delay.Type = 2" << std::endl;
		AimBot << "|M4A1.Recoil = 2.0" << std::endl;
		AimBot << "|M4A1.Recoil.Prediction = 1.10" << std::endl;
		AimBot << "|M4A1.Recoil.FOV = 8" << std::endl;
		AimBot << "|M4A1.Recoil.Smooth = 14.0" << std::endl << std::endl;

		AimBot << "|AUG.Aim = 1" << std::endl;
		AimBot << "|AUG.BulletControl = 2, 1000" << std::endl;
		AimBot << "|AUG.HitBox = 11" << std::endl;
		AimBot << "|AUG.HitBox.Nearest = 1" << std::endl;
		AimBot << "|AUG.Prediction = 0.10" << std::endl;
		AimBot << "|AUG.FOV = 2.5" << std::endl;
		AimBot << "|AUG.Smooth = 4.0" << std::endl;
		AimBot << "|AUG.Delay = 50" << std::endl;
		AimBot << "|AUG.Delay.Type = 2" << std::endl;
		AimBot << "|AUG.Recoil = 2.0" << std::endl;
		AimBot << "|AUG.Recoil.Prediction = 1.10" << std::endl;
		AimBot << "|AUG.Recoil.FOV = 8" << std::endl;
		AimBot << "|AUG.Recoil.Smooth = 14.0" << std::endl << std::endl;

		AimBot << "|Galil.Aim = 1" << std::endl;
		AimBot << "|Galil.BulletControl = 2, 1000" << std::endl;
		AimBot << "|Galil.HitBox = 11" << std::endl;
		AimBot << "|Galil.HitBox.Nearest = 1" << std::endl;
		AimBot << "|Galil.Prediction = 0.10" << std::endl;
		AimBot << "|Galil.FOV = 2.5" << std::endl;
		AimBot << "|Galil.Smooth = 4.0" << std::endl;
		AimBot << "|Galil.Delay = 50" << std::endl;
		AimBot << "|Galil.Delay.Type = 2" << std::endl;
		AimBot << "|Galil.Recoil = 2.0" << std::endl;
		AimBot << "|Galil.Recoil.Prediction = 1.10" << std::endl;
		AimBot << "|Galil.Recoil.FOV = 8" << std::endl;
		AimBot << "|Galil.Recoil.Smooth = 14.0" << std::endl << std::endl;

		AimBot << "|FAMAS.Aim = 1" << std::endl;
		AimBot << "|FAMAS.BulletControl = 2, 1000" << std::endl;
		AimBot << "|FAMAS.HitBox = 11" << std::endl;
		AimBot << "|FAMAS.HitBox.Nearest = 1" << std::endl;
		AimBot << "|FAMAS.Prediction = 0.10" << std::endl;
		AimBot << "|FAMAS.FOV = 2.5" << std::endl;
		AimBot << "|FAMAS.Smooth = 4.0" << std::endl;
		AimBot << "|FAMAS.Delay = 50" << std::endl;
		AimBot << "|FAMAS.Delay.Type = 2" << std::endl;
		AimBot << "|FAMAS.Recoil = 2.0" << std::endl;
		AimBot << "|FAMAS.Recoil.Prediction = 1.10" << std::endl;
		AimBot << "|FAMAS.Recoil.FOV = 8" << std::endl;
		AimBot << "|FAMAS.Recoil.Smooth = 14.0" << std::endl << std::endl;

		AimBot << "|SG550.Aim = 1" << std::endl;
		AimBot << "|SG550.BulletControl = 2, 1000" << std::endl;
		AimBot << "|SG550.HitBox = 11" << std::endl;
		AimBot << "|SG550.HitBox.Nearest = 1" << std::endl;
		AimBot << "|SG550.Prediction = 0.10" << std::endl;
		AimBot << "|SG550.FOV = 2.5" << std::endl;
		AimBot << "|SG550.Smooth = 4.0" << std::endl;
		AimBot << "|SG550.Delay = 50" << std::endl;
		AimBot << "|SG550.Delay.Type = 2" << std::endl;
		AimBot << "|SG550.Recoil = 2.0" << std::endl;
		AimBot << "|SG550.Recoil.Prediction = 1.10" << std::endl;
		AimBot << "|SG550.Recoil.FOV = 8" << std::endl;
		AimBot << "|SG550.Recoil.Smooth = 14.0" << std::endl << std::endl;

		AimBot << "|XM1014.Aim = 1" << std::endl;
		AimBot << "|XM1014.BulletControl = 2, 1000" << std::endl;
		AimBot << "|XM1014.HitBox = 11" << std::endl;
		AimBot << "|XM1014.HitBox.Nearest = 1" << std::endl;
		AimBot << "|XM1014.Prediction = 0.10" << std::endl;
		AimBot << "|XM1014.FOV = 2.5" << std::endl;
		AimBot << "|XM1014.Smooth = 4.0" << std::endl;
		AimBot << "|XM1014.Delay = 50" << std::endl;
		AimBot << "|XM1014.Delay.Type = 2" << std::endl;
		AimBot << "|XM1014.Recoil = 2.0" << std::endl;
		AimBot << "|XM1014.Recoil.Prediction = 1.10" << std::endl;
		AimBot << "|XM1014.Recoil.FOV = 8" << std::endl;
		AimBot << "|XM1014.Recoil.Smooth = 14.0" << std::endl << std::endl;

		AimBot << "|MAC10.Aim = 1" << std::endl;
		AimBot << "|MAC10.BulletControl = 2, 1000" << std::endl;
		AimBot << "|MAC10.HitBox = 11" << std::endl;
		AimBot << "|MAC10.HitBox.Nearest = 1" << std::endl;
		AimBot << "|MAC10.Prediction = 0.10" << std::endl;
		AimBot << "|MAC10.FOV = 2.5" << std::endl;
		AimBot << "|MAC10.Smooth = 4.0" << std::endl;
		AimBot << "|MAC10.Delay = 50" << std::endl;
		AimBot << "|MAC10.Delay.Type = 2" << std::endl;
		AimBot << "|MAC10.Recoil = 2.0" << std::endl;
		AimBot << "|MAC10.Recoil.Prediction = 1.10" << std::endl;
		AimBot << "|MAC10.Recoil.FOV = 8" << std::endl;
		AimBot << "|MAC10.Recoil.Smooth = 14.0" << std::endl << std::endl;

		AimBot << "|UMP45.Aim = 1" << std::endl;
		AimBot << "|UMP45.BulletControl = 2, 1000" << std::endl;
		AimBot << "|UMP45.HitBox = 11" << std::endl;
		AimBot << "|UMP45.HitBox.Nearest = 1" << std::endl;
		AimBot << "|UMP45.Prediction = 0.10" << std::endl;
		AimBot << "|UMP45.FOV = 2.5" << std::endl;
		AimBot << "|UMP45.Smooth = 4.0" << std::endl;
		AimBot << "|UMP45.Delay = 50" << std::endl;
		AimBot << "|UMP45.Delay.Type = 2" << std::endl;
		AimBot << "|UMP45.Recoil = 2.0" << std::endl;
		AimBot << "|UMP45.Recoil.Prediction = 1.10" << std::endl;
		AimBot << "|UMP45.Recoil.FOV = 8" << std::endl;
		AimBot << "|UMP45.Recoil.Smooth = 14.0" << std::endl << std::endl;

		AimBot << "|MP5.Aim = 1" << std::endl;
		AimBot << "|MP5.BulletControl = 2, 1000" << std::endl;
		AimBot << "|MP5.HitBox = 11" << std::endl;
		AimBot << "|MP5.HitBox.Nearest = 1" << std::endl;
		AimBot << "|MP5.Prediction = 0.10" << std::endl;
		AimBot << "|MP5.FOV = 2.5" << std::endl;
		AimBot << "|MP5.Smooth = 4.0" << std::endl;
		AimBot << "|MP5.Delay = 50" << std::endl;
		AimBot << "|MP5.Delay.Type = 2" << std::endl;
		AimBot << "|MP5.Recoil = 2.0" << std::endl;
		AimBot << "|MP5.Recoil.Prediction = 1.10" << std::endl;
		AimBot << "|MP5.Recoil.FOV = 8" << std::endl;
		AimBot << "|MP5.Recoil.Smooth = 14.0" << std::endl << std::endl;

		AimBot << "|M249.Aim = 1" << std::endl;
		AimBot << "|M249.BulletControl = 2, 1000" << std::endl;
		AimBot << "|M249.HitBox = 11" << std::endl;
		AimBot << "|M249.HitBox.Nearest = 1" << std::endl;
		AimBot << "|M249.Prediction = 0.10" << std::endl;
		AimBot << "|M249.FOV = 2.5" << std::endl;
		AimBot << "|M249.Smooth = 4.0" << std::endl;
		AimBot << "|M249.Delay = 50" << std::endl;
		AimBot << "|M249.Delay.Type = 2" << std::endl;
		AimBot << "|M249.Recoil = 2.0" << std::endl;
		AimBot << "|M249.Recoil.Prediction = 1.10" << std::endl;
		AimBot << "|M249.Recoil.FOV = 8" << std::endl;
		AimBot << "|M249.Recoil.Smooth = 14.0" << std::endl << std::endl;

		AimBot << "|M3.Aim = 1" << std::endl;
		AimBot << "|M3.BulletControl = 2, 1000" << std::endl;
		AimBot << "|M3.HitBox = 11" << std::endl;
		AimBot << "|M3.HitBox.Nearest = 1" << std::endl;
		AimBot << "|M3.Prediction = 0.10" << std::endl;
		AimBot << "|M3.FOV = 2.5" << std::endl;
		AimBot << "|M3.Smooth = 4.0" << std::endl;
		AimBot << "|M3.Delay = 50" << std::endl;
		AimBot << "|M3.Delay.Type = 2" << std::endl;
		AimBot << "|M3.Recoil = 2.0" << std::endl;
		AimBot << "|M3.Recoil.Prediction = 1.10" << std::endl;
		AimBot << "|M3.Recoil.FOV = 8" << std::endl;
		AimBot << "|M3.Recoil.Smooth = 14.0" << std::endl << std::endl;

		AimBot << "|TMP.Aim = 1" << std::endl;
		AimBot << "|TMP.BulletControl = 2, 1000" << std::endl;
		AimBot << "|TMP.HitBox = 11" << std::endl;
		AimBot << "|TMP.HitBox.Nearest = 1" << std::endl;
		AimBot << "|TMP.Prediction = 0.10" << std::endl;
		AimBot << "|TMP.FOV = 2.5" << std::endl;
		AimBot << "|TMP.Smooth = 4.0" << std::endl;
		AimBot << "|TMP.Delay = 50" << std::endl;
		AimBot << "|TMP.Delay.Type = 2" << std::endl;
		AimBot << "|TMP.Recoil = 2.0" << std::endl;
		AimBot << "|TMP.Recoil.Prediction = 1.10" << std::endl;
		AimBot << "|TMP.Recoil.FOV = 8" << std::endl;
		AimBot << "|TMP.Recoil.Smooth = 14.0" << std::endl << std::endl;

		AimBot << "|G3SG1.Aim = 1" << std::endl;
		AimBot << "|G3SG1.BulletControl = 2, 1000" << std::endl;
		AimBot << "|G3SG1.HitBox = 11" << std::endl;
		AimBot << "|G3SG1.HitBox.Nearest = 1" << std::endl;
		AimBot << "|G3SG1.Prediction = 0.10" << std::endl;
		AimBot << "|G3SG1.FOV = 2.5" << std::endl;
		AimBot << "|G3SG1.Smooth = 4.0" << std::endl;
		AimBot << "|G3SG1.Delay = 50" << std::endl;
		AimBot << "|G3SG1.Delay.Type = 2" << std::endl;
		AimBot << "|G3SG1.Recoil = 2.0" << std::endl;
		AimBot << "|G3SG1.Recoil.Prediction = 1.10" << std::endl;
		AimBot << "|G3SG1.Recoil.FOV = 8" << std::endl;
		AimBot << "|G3SG1.Recoil.Smooth = 14.0" << std::endl << std::endl;

		AimBot << "|SG552.Aim = 1" << std::endl;
		AimBot << "|SG552.BulletControl = 2, 1000" << std::endl;
		AimBot << "|SG552.HitBox = 11" << std::endl;
		AimBot << "|SG552.HitBox.Nearest = 1" << std::endl;
		AimBot << "|SG552.Prediction = 0.10" << std::endl;
		AimBot << "|SG552.FOV = 2.5" << std::endl;
		AimBot << "|SG552.Smooth = 4.0" << std::endl;
		AimBot << "|SG552.Delay = 50" << std::endl;
		AimBot << "|SG552.Delay.Type = 2" << std::endl;
		AimBot << "|SG552.Recoil = 2.0" << std::endl;
		AimBot << "|SG552.Recoil.Prediction = 1.10" << std::endl;
		AimBot << "|SG552.Recoil.FOV = 8" << std::endl;
		AimBot << "|SG552.Recoil.Smooth = 14.0" << std::endl << std::endl;

		AimBot << "|P90.Aim = 1" << std::endl;
		AimBot << "|P90.BulletControl = 2, 1000" << std::endl;
		AimBot << "|P90.HitBox = 11" << std::endl;
		AimBot << "|P90.HitBox.Nearest = 1" << std::endl;
		AimBot << "|P90.Prediction = 0.10" << std::endl;
		AimBot << "|P90.FOV = 2.5" << std::endl;
		AimBot << "|P90.Smooth = 4.0" << std::endl;
		AimBot << "|P90.Delay = 50" << std::endl;
		AimBot << "|P90.Delay.Type = 2" << std::endl;
		AimBot << "|P90.Recoil = 2.0" << std::endl;
		AimBot << "|P90.Recoil.Prediction = 1.10" << std::endl;
		AimBot << "|P90.Recoil.FOV = 8" << std::endl;
		AimBot << "|P90.Recoil.Smooth = 14.0" << std::endl << std::endl;

		AimBot << "|AWP.Aim = 1" << std::endl;
		AimBot << "|AWP.BulletControl = 2, 1" << std::endl;
		AimBot << "|AWP.HitBox = 11" << std::endl;
		AimBot << "|AWP.HitBox.Nearest = 1" << std::endl;
		AimBot << "|AWP.Prediction = 0.10" << std::endl;
		AimBot << "|AWP.FOV = 5.0" << std::endl;
		AimBot << "|AWP.Smooth = 1.0" << std::endl;
		AimBot << "|AWP.Delay = 10" << std::endl;
		AimBot << "|AWP.Delay.Type = 2" << std::endl;
		AimBot << "|AWP.Recoil = 2.0" << std::endl;
		AimBot << "|AWP.Recoil.Prediction = 1.10" << std::endl;
		AimBot << "|AWP.Recoil.FOV = 8" << std::endl;
		AimBot << "|AWP.Recoil.Smooth = 14.0" << std::endl << std::endl;

		AimBot << "|Scout.Aim = 1" << std::endl;
		AimBot << "|Scout.BulletControl = 2, 1" << std::endl;
		AimBot << "|Scout.HitBox = 11" << std::endl;
		AimBot << "|Scout.HitBox.Nearest = 1" << std::endl;
		AimBot << "|Scout.Prediction = 0.10" << std::endl;
		AimBot << "|Scout.FOV = 5.0" << std::endl;
		AimBot << "|Scout.Smooth = 1.0" << std::endl;
		AimBot << "|Scout.Delay = 10" << std::endl;
		AimBot << "|Scout.Delay.Type = 2" << std::endl;
		AimBot << "|Scout.Recoil = 2.0" << std::endl;
		AimBot << "|Scout.Recoil.Prediction = 1.10" << std::endl;
		AimBot << "|Scout.Recoil.FOV = 8" << std::endl;
		AimBot << "|Scout.Recoil.Smooth = 14.0" << std::endl;

		AimBot.close ( );
	}

	void CreateFileTriggerBot ( )
	{
		std::ofstream TriggerBot;

		char* TriggerBotPath = new char[256];

		lstrcpy ( TriggerBotPath, BaseDir );
		lstrcat ( TriggerBotPath, TRIGGERBOT_PATH );

		TriggerBot.open ( TriggerBotPath, std::ios::app );

		TriggerBot << "[Trigger]" << std::endl;
		TriggerBot << "|Trigger.Enable = 1" << std::endl;
		TriggerBot << "|Trigger.FriendlyFire = 0" << std::endl;
		TriggerBot << "|Trigger.VisibleCheck = 1" << std::endl;
		TriggerBot << "|Trigger.Snipers.OnlyInZoom = 1" << std::endl;
		TriggerBot << "|Trigger.Switch.Key = none" << std::endl;
		TriggerBot << "|Trigger.Key = none" << std::endl << std::endl;

		TriggerBot << "[Weapons]" << std::endl;
		TriggerBot << "|P228.Trigger = 1" << std::endl;
		TriggerBot << "|P228.OnlyHead = 1" << std::endl;
		TriggerBot << "|P228.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|Glock18.Trigger = 1" << std::endl;
		TriggerBot << "|Glock18.OnlyHead = 1" << std::endl;
		TriggerBot << "|Glock18.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|Scout.Trigger = 1" << std::endl;
		TriggerBot << "|Scout.OnlyHead = 1" << std::endl;
		TriggerBot << "|Scout.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|XM1014.Trigger = 1" << std::endl;
		TriggerBot << "|XM1014.OnlyHead = 1" << std::endl;
		TriggerBot << "|XM1014.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|MAC10.Trigger = 1" << std::endl;
		TriggerBot << "|MAC10.OnlyHead = 1" << std::endl;
		TriggerBot << "|MAC10.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|AUG.Trigger = 1" << std::endl;
		TriggerBot << "|AUG.OnlyHead = 1" << std::endl;
		TriggerBot << "|AUG.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|Elite.Trigger = 1" << std::endl;
		TriggerBot << "|Elite.OnlyHead = 1" << std::endl;
		TriggerBot << "|Elite.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|Five-Seven.Trigger = 1" << std::endl;
		TriggerBot << "|Five-Seven.OnlyHead = 1" << std::endl;
		TriggerBot << "|Five-Seven.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|UMP32.Trigger = 1" << std::endl;
		TriggerBot << "|UMP32.OnlyHead = 1" << std::endl;
		TriggerBot << "|UMP32.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|SG550.Trigger = 1" << std::endl;
		TriggerBot << "|SG550.OnlyHead = 1" << std::endl;
		TriggerBot << "|SG550.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|Galil.Trigger = 1" << std::endl;
		TriggerBot << "|Galil.OnlyHead = 1" << std::endl;
		TriggerBot << "|Galil.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|FAMAS.Trigger = 1" << std::endl;
		TriggerBot << "|FAMAS.OnlyHead = 1" << std::endl;
		TriggerBot << "|FAMAS.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|USP.Trigger = 1" << std::endl;
		TriggerBot << "|USP.OnlyHead = 1" << std::endl;
		TriggerBot << "|USP.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|AWP.Trigger = 1" << std::endl;
		TriggerBot << "|AWP.OnlyHead = 1" << std::endl;
		TriggerBot << "|AWP.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|MP5.Trigger = 1" << std::endl;
		TriggerBot << "|MP5.OnlyHead = 1" << std::endl;
		TriggerBot << "|MP5.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|M249.Trigger = 1" << std::endl;
		TriggerBot << "|M249.OnlyHead = 1" << std::endl;
		TriggerBot << "|M249.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|M3.Trigger = 1" << std::endl;
		TriggerBot << "|M3.OnlyHead = 1" << std::endl;
		TriggerBot << "|M3.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|M4A1.Trigger = 1" << std::endl;
		TriggerBot << "|M4A1.OnlyHead = 1" << std::endl;
		TriggerBot << "|M4A1.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|TMP.Trigger = 1" << std::endl;
		TriggerBot << "|TMP.OnlyHead = 1" << std::endl;
		TriggerBot << "|TMP.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|G3SG1.Trigger = 1" << std::endl;
		TriggerBot << "|G3SG1.OnlyHead = 1" << std::endl;
		TriggerBot << "|G3SG1.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|DEagle.Trigger = 1" << std::endl;
		TriggerBot << "|DEagle.OnlyHead = 1" << std::endl;
		TriggerBot << "|DEagle.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|SG552.Trigger = 1" << std::endl;
		TriggerBot << "|SG552.OnlyHead = 1" << std::endl;
		TriggerBot << "|SG552.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|AK47.Trigger = 1" << std::endl;
		TriggerBot << "|AK47.OnlyHead = 1" << std::endl;
		TriggerBot << "|AK47.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|P90.Trigger = 1" << std::endl;
		TriggerBot << "|P90.OnlyHead = 1" << std::endl;
		TriggerBot << "|P90.ProSpread = 1" << std::endl << std::endl;

		TriggerBot << "|UMP45.Trigger = 1" << std::endl;
		TriggerBot << "|UMP45.OnlyHead = 1" << std::endl;
		TriggerBot << "|UMP45.ProSpread = 1" << std::endl;

		TriggerBot.close ( );
	}
}
```

`Files.h`:

```h
#pragma once
#pragma warning (disable: 4996)

#include "Main.h"

#define FILE_READ_INT( Variable, Section, Key ) Variable = ReadInt ( ( char* )Path.c_str ( ), Section, Key, "0" )
#define FILE_READ_FLOAT( Variable, Section, Key ) Variable = ReadFloat ( ( char* )Path.c_str ( ), Section, Key, "0" )
#define FILE_READ_STRING( Variable, Section, Key) Variable = ReadString ( ( char* )Path.c_str ( ), Section, Key, "0" )
#define FILE_READ_KEY( Variable, Section, Key ) Variable = ReadStringConvert ( ( char* )Path.c_str ( ), Section, Key, "0" )
#define FILE_READ_CONVERT( Variable, Section, Key ) Variable = ReadStringConvert ( ( char* )Path.c_str ( ), Section, Key, "0" )

#define FILE_WRITE_INT( Variable, Section, Key ) { char String[MAX_FILE_WRITE_LENGHT]; sprintf_s ( String, " %d", ( int )Variable );\
	WriteString ( ( char* )Path.c_str ( ), Section, Key, String ); }

#define FILE_WRITE_INT_2( Variable1, Variable2, Section, Key ) { char String[MAX_FILE_WRITE_LENGHT];\
	sprintf_s ( String, " %d, %d", ( int )Variable1, ( int )Variable2 );\
	WriteString ( ( char* )Path.c_str ( ), Section, Key, String ); }

#define FILE_WRITE_FLOAT( Variable, Section, Key ) { char String[MAX_FILE_WRITE_LENGHT]; sprintf_s ( String, " %g", Variable );\
	WriteString ( ( char* )Path.c_str ( ), Section, Key, String ); }

#define FILE_WRITE_FLOAT_2( Variable1, Variable2, Section, Key ) { char String[MAX_FILE_WRITE_LENGHT]; sprintf_s ( String, " %g, %g", Variable1, Variable2 );\
	WriteString ( ( char* )Path.c_str ( ), Section, Key, String ); }

#define FILE_WRITE_RGB( R, G, B, Section, Key ) { char String[MAX_FILE_WRITE_LENGHT]; sprintf_s ( String, " %d, %d, %d", ( int )R,  ( int )G, ( int )B );\
	WriteString ( ( char* )Path.c_str ( ), Section, Key, String ); }

#define FILE_WRITE_RGBA( R, G, B, A, Section, Key ) { char String[MAX_FILE_WRITE_LENGHT];\
	sprintf_s ( String, " %d, %d, %d, %d", ( int )R,  ( int )G, ( int )B, ( int )A );\
	WriteString ( ( char* )Path.c_str ( ), Section, Key, String ); }

#define FILE_WRITE_DIR( Variable, Section, Key ) { if ( Variable == 1001 ) WriteString ( ( char* )Path.c_str ( ), Section, Key, " up" );\
	else if ( Variable == 1000 ) WriteString ( ( char* )Path.c_str ( ), Section, Key, " down" ); }

#define FILE_WRITE_LANG( Variable, Section, Key ) { if ( Variable == 2001 ) WriteString ( ( char* )Path.c_str ( ), Section, Key, " russian" );\
	else if ( Variable == 2000 ) WriteString ( ( char* )Path.c_str ( ), Section, Key, " english" ); }

#define FILE_WRITE_KEY( Variable, Section, Key ) { char String[MAX_FILE_WRITE_LENGHT]; sprintf_s ( String, " %s", KeyToString ( Variable ) );\
	WriteString ( ( char* )Path.c_str ( ), Section, Key, String ); }

#define PARS_STRING( KeyToConvert, Convert ) { if ( !lstrcmpi ( Key, KeyToConvert ) ) return Convert; }

namespace Files
{
	extern char* BaseDir;

	std::string szDirFile ( const char* FileName );

	extern std::ofstream Inject, Info;

	inline void InjectLog ( const char* fmt, ... )
	{
		char DateString[9], TimeStr[9];

		_strtime_s ( TimeStr );
		_strdate_s ( DateString );

		if ( !fmt )
		{
			Inject << std::endl;

			return;
		}

		char LogBuf[256] = { 0 };

		va_list va_alist;
		va_start ( va_alist, fmt );
		_vsnprintf ( LogBuf + strlen ( LogBuf ), sizeof ( LogBuf ) - strlen ( LogBuf ), fmt, va_alist );
		va_end ( va_alist );

		Inject << "[" << DateString << " - " << TimeStr << "] " << LogBuf << std::endl;
	}

	inline void InfoLog ( const char* fmt, ... )
	{
		char DateString[9], TimeStr[9];

		_strtime_s ( TimeStr );
		_strdate_s ( DateString );

		if ( !fmt )
		{
			Info << std::endl;

			return;
		}

		char LogBuf[256] = { 0 };

		va_list va_alist;
		va_start ( va_alist, fmt );
		_vsnprintf ( LogBuf + strlen ( LogBuf ), sizeof ( LogBuf ) - strlen ( LogBuf ), fmt, va_alist );
		va_end ( va_alist );

		Info << "[" << DateString << " - " << TimeStr << "] " << LogBuf << std::endl;
	}

	namespace Read
	{
		void Functions ( );
		void Main ( );
		void Menu ( );
		void ScreenInfo ( );
		void ESP ( );
		void NoFlash ( );
		void Speed ( );
		void BunnyHop ( );
		void Crosshair ( );
		void AimWeapons ( );
		void Other ( );
		void Recoil ( );
		void AutoPistol ( );
		void FastZoom ( );
		void Chams ( );
		void GroundStrafe ( );
		void TriggerWeapons ( );
	}

	namespace Write
	{
		void Main ( );
		void Menu ( );
		void ScreenInfo ( );
		void ESP ( );
		void NoFlash ( );
		void Speed ( );
		void BunnyHop ( );
		void Crosshair ( );
		void AimWeapons ( );
		void Other ( );
		void Recoil ( );
		void AutoPistol ( );
		void FastZoom ( );
		void Chams ( );
		void GroundStrafe ( );
		void TriggerWeapons ( );
	}

	void GetBaseDir ( const HINSTANCE& hInstance );

	void LoadSettings ( );
	void ReloadSettings ( );
	void SaveSettings ( );

	void FilesCheck ( );

	void CreateLogDirectory ( );
	void CreateInjectLogFile ( );
	void CreateInfoLogFile ( );
	void CreateSettingsDirectory ( );
	void CreateFileMain ( );
	void CreateFileFunctions ( );
	void CreateFileVisuals ( );
	void CreateFileMisc ( );
	void CreateFileAimBot ( );
	void CreateFileTriggerBot ( );

	void LoadFileMain ( );
	void LoadFileFunctions ( );
	void LoadFileVisuals ( );
	void LoadFileMisc ( );
	void LoadFileAimBot ( );
	void LoadFileTriggerBot ( );

	void SaveFileMain ( );
	void SaveFileVisuals ( );
	void SaveFileMisc ( );
	void SaveFileAimBot ( );
	void SaveFileTriggerBot ( );

	inline bool FileExists ( const char* FileName )
	{
		return _access ( FileName, 0 ) != -1;
	}

	inline char* ReadString ( const char* Path, const char* Section, const char* Key, const char* DefString )
	{
		char* String = new char[512];

		GetPrivateProfileString ( Section, Key, DefString, String, 200, Path );

		return String;
	}

	inline float ReadFloat ( const char* Path, const char* Section, const char* Key, const char* DefValue )
	{
		return ( float )atof ( ReadString ( Path, Section, Key, DefValue ) );
	}

	inline int ReadInt ( const char* Path, const char* Section, const char* Key, const char* DefValue )
	{
		return atoi ( ReadString ( Path, Section, Key, DefValue ) );
	}

	inline void WriteString ( const char* Path, const char* Section, const char* Key, const char* String )
	{
		WritePrivateProfileString ( Section, Key, String, Path );
	}

	inline int StringToKey ( const char* Key )
	{
		PARS_STRING ( "ru", RUSSIAN );
		PARS_STRING ( "en", RUSSIAN );
		PARS_STRING ( "rus", RUSSIAN );
		PARS_STRING ( "eng", ENGLISH );
		PARS_STRING ( "russian", RUSSIAN );
		PARS_STRING ( "english", ENGLISH );

		PARS_STRING ( "up", UP );
		PARS_STRING ( "down", DOWN );

		PARS_STRING ( "tab", K_TAB );
		PARS_STRING ( "enter", K_ENTER );
		PARS_STRING ( "escape", K_ESCAPE );
		PARS_STRING ( "backspace", K_BACKSPACE );
		PARS_STRING ( "uparrow", K_UPARROW );
		PARS_STRING ( "downarrow", K_DOWNARROW );
		PARS_STRING ( "leftarrow", K_LEFTARROW );
		PARS_STRING ( "rightarrow", K_RIGHTARROW );

		PARS_STRING ( "[", K_BRACKET_LEFT );
		PARS_STRING ( "]", K_BRACKET_RIGHT );
		PARS_STRING ( "0", K_0 );
		PARS_STRING ( "1", K_1 );
		PARS_STRING ( "2", K_2 );
		PARS_STRING ( "3", K_3 );
		PARS_STRING ( "4", K_4 );
		PARS_STRING ( "5", K_5 );
		PARS_STRING ( "6", K_6 );
		PARS_STRING ( "7", K_7 );
		PARS_STRING ( "8", K_8 );
		PARS_STRING ( "9", K_9 );
		PARS_STRING ( ".", K_POINT );
		PARS_STRING ( ",", K_COMMA );

		PARS_STRING ( "a", K_A );
		PARS_STRING ( "b", K_B );
		PARS_STRING ( "c", K_C );
		PARS_STRING ( "d", K_D );
		PARS_STRING ( "e", K_E );
		PARS_STRING ( "f", K_F );
		PARS_STRING ( "g", K_G );
		PARS_STRING ( "h", K_H );
		PARS_STRING ( "i", K_I );
		PARS_STRING ( "j", K_J );
		PARS_STRING ( "k", K_K );
		PARS_STRING ( "l", K_L );
		PARS_STRING ( "m", K_M );
		PARS_STRING ( "n", K_N );
		PARS_STRING ( "o", K_O );
		PARS_STRING ( "p", K_P );
		PARS_STRING ( "q", K_Q );
		PARS_STRING ( "r", K_R );
		PARS_STRING ( "s", K_S );
		PARS_STRING ( "t", K_T );
		PARS_STRING ( "u", K_U );
		PARS_STRING ( "v", K_V );
		PARS_STRING ( "w", K_W );
		PARS_STRING ( "x", K_X );
		PARS_STRING ( "z", K_Z );

		PARS_STRING ( "f1", K_F1 );
		PARS_STRING ( "f2", K_F2 );
		PARS_STRING ( "f3", K_F3 );
		PARS_STRING ( "f4", K_F4 );
		PARS_STRING ( "f5", K_F5 );
		PARS_STRING ( "f6", K_F6 );
		PARS_STRING ( "f7", K_F7 );
		PARS_STRING ( "f8", K_F8 );
		PARS_STRING ( "f9", K_F9 );
		PARS_STRING ( "f10", K_F10 );
		PARS_STRING ( "f11", K_F11 );
		PARS_STRING ( "f12", K_F12 );

		PARS_STRING ( "insert", K_INS );
		PARS_STRING ( "ins", K_INS );
		PARS_STRING ( "delete", K_DEL );
		PARS_STRING ( "del", K_DEL );
		PARS_STRING ( "pgdn", K_PGDN );
		PARS_STRING ( "pgup", K_PGUP );
		PARS_STRING ( "home", K_HOME );
		PARS_STRING ( "end", K_END );
		PARS_STRING ( "space", K_SPACE );
		PARS_STRING ( "alt", K_ALT );
		PARS_STRING ( "shift", K_SHIFT );
		PARS_STRING ( "ctrl", K_CTRL );
		PARS_STRING ( "mwheeldown", K_MWHEELDOWN );
		PARS_STRING ( "mwheelup", K_MWHEELUP );
		PARS_STRING ( "mwdown", K_MWHEELDOWN );
		PARS_STRING ( "mwup", K_MWHEELUP );
		PARS_STRING ( "mouse1", K_MOUSE1 );
		PARS_STRING ( "mouse2", K_MOUSE2 );
		PARS_STRING ( "mouse3", K_MOUSE3 );
		PARS_STRING ( "mouse4", K_MOUSE4 );
		PARS_STRING ( "mouse5", K_MOUSE5 );

		PARS_STRING ( "true", TRUE );
		PARS_STRING ( "false", FALSE );
		PARS_STRING ( "on", TRUE );
		PARS_STRING ( "off", FALSE );
		PARS_STRING ( "none", NULL );

		return 0;
	}

	inline char* KeyToString ( BYTE Key )
	{
		switch ( Key )
		{
		case K_TAB:				return "TAB";
		case K_ENTER:			return "ENTER";
		case K_ESCAPE:			return "ESCAPE";
		case K_BACKSPACE:		return "BACKSPACE";
		case K_UPARROW:			return "UPARROW";
		case K_DOWNARROW:		return "DOWNARROW";
		case K_LEFTARROW:		return "LEFTARROW";
		case K_RIGHTARROW:		return "RIGHTARROW";
		case K_BRACKET_LEFT:	return "[";
		case K_BRACKET_RIGHT:	return "]";
		case K_0:				return "0";
		case K_1:				return "1";
		case K_2:				return "2";
		case K_3:				return "3";
		case K_4:				return "4";
		case K_5:				return "5";
		case K_6:				return "6";
		case K_7:				return "7";
		case K_8:				return "8";
		case K_9:				return "9";
		case K_POINT:			return ".";
		case K_COMMA:			return ",";
		case K_A:				return "A";
		case K_B:				return "B";
		case K_C:				return "C";
		case K_D:				return "D";
		case K_E:				return "E";
		case K_F:				return "F";
		case K_G:				return "G";
		case K_H:				return "H";
		case K_I:				return "I";
		case K_J:				return "J";
		case K_K:				return "K";
		case K_L:				return "L";
		case K_M:				return "M";
		case K_N:				return "N";
		case K_O:				return "O";
		case K_P:				return "P";
		case K_Q:				return "Q";
		case K_R:				return "R";
		case K_S:				return "S";
		case K_T:				return "T";
		case K_U:				return "U";
		case K_V:				return "V";
		case K_W:				return "W";
		case K_X:				return "X";
		case K_Y:				return "Y";
		case K_Z:				return "Z";
		case K_F1:				return "F1";
		case K_F2:				return "F2";
		case K_F3:				return "F3";
		case K_F4:				return "F4";
		case K_F5:				return "F5";
		case K_F6:				return "F6";
		case K_F7:				return "F7";
		case K_F8:				return "F8";
		case K_F9:				return "F9";
		case K_F10:				return "F10";
		case K_F11:				return "F11";
		case K_F12:				return "F12";
		case K_INS:				return "INSERT";
		case K_DEL:				return "DELETE";
		case K_PGDN:			return "PGDN";
		case K_PGUP:			return "PGUP";
		case K_HOME:			return "HOME";
		case K_END:				return "END";
		case K_SPACE:			return "SPACE";
		case K_ALT:				return "ALT";
		case K_SHIFT:			return "SHIFT";
		case K_CTRL:			return "CTRL";
		case K_MWHEELDOWN:		return "MWDOWN";
		case K_MWHEELUP:		return "MWUP";
		case K_MOUSE1:			return "MOUSE1";
		case K_MOUSE2:			return "MOUSE2";
		case K_MOUSE3:			return "MOUSE3";
		case K_MOUSE4:			return "MOUSE4";
		case K_MOUSE5:			return "MOUSE5";
		default:				return "none";
		}

		return 0;
	}

	inline int ReadStringConvert ( const char* Path, const char* Section, const char* Key, const char* DefValue )
	{
		char String[19];

		GetPrivateProfileString ( Section, Key, DefValue, String, 16, Path );

		return StringToKey ( String );
	}

	inline void Parse ( char* String, float* Variable, int MaxArray )
	{
		char* Parsing = strtok ( String, "," );

		for ( int i = 0; i <= MaxArray; ++i )
		{
			if ( !Parsing ) return;

			Variable[i] = ( float )atof ( Parsing );

			Parsing = strtok ( 0, "," );
		}
	}

	inline void Parse ( char* String, int* Variable, int MaxArray )
	{
		char* Parsing = strtok ( String, "," );

		for ( int i = 0; i <= MaxArray; ++i )
		{
			if ( !Parsing ) return;

			Variable[i] = atoi ( Parsing );

			Parsing = strtok ( 0, "," );
		}
	}
}
```

`Fonts.h`:

```h
#pragma once

#include "Main.h"

namespace Renderer
{
	class Fonts
	{
	public:
		inline void InitText ( const char *Font, int Height, int Width )
		{
			HDC hDC = wglGetCurrentDC ( );

			g_FontListID = glGenLists ( 256 );

			HFONT hFont = CreateFont ( Height, Width, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, RUSSIAN_CHARSET,
				OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS, CLEARTYPE_NATURAL_QUALITY, FF_DONTCARE | VARIABLE_PITCH, Font );

			HFONT hOldFont = ( HFONT )SelectObject ( hDC, hFont );

			if ( !wglUseFontBitmapsA ( hDC, 0, 255, g_FontListID ) )
				wglUseFontBitmapsA ( hDC, 0, 255, g_FontListID );

			for ( int i = 0; i < 255; ++i )
			{
				SIZE s;

				char Line[2] = { ( char )i, 0 };

				GetTextExtentPoint ( hDC, Line, 1, &s );

				this->Width[i] = s.cx;
				this->Height = s.cy;
			}

			SelectObject ( hDC, hOldFont );
			DeleteObject ( hFont );
		}

		inline void Print ( int x, int y, BYTE R, BYTE G, BYTE B, BYTE A, int Flags, const char *String, ... )
		{
			char Text[256];

			va_list ArgumentPtr;
			va_start ( ArgumentPtr, String );
			vsprintf_s ( Text, String, ArgumentPtr );
			va_end ( ArgumentPtr );

			glDisable ( GL_TEXTURE_2D );
			glEnable ( GL_BLEND );
			glBlendFunc ( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

			int DrawLen = 0;

			for ( char *p = Text; *p; ++p )
			{
				DrawLen += Width[*p];
			}

			if ( Flags & FL_CENTER )
			{
				x -= DrawLen / 2;
			}

			if ( Flags & FL_OUTLINE )
			{
				if ( g_Vars.Main.FontOutlineStyle == 1 )
				{
					Render ( x + 1, y + 1, 0, 0, 0, A, Text );
				}
				else if ( g_Vars.Main.FontOutlineStyle >= 2 )
				{
					Render ( x, y - 1, 0, 0, 0, A, Text );
					Render ( x, y + 1, 0, 0, 0, A, Text );
					Render ( x + 1, y, 0, 0, 0, A, Text );
					Render ( x - 1, y, 0, 0, 0, A, Text );

					Render ( x - 1, y - 1, 0, 0, 0, A, Text );
					Render ( x + 1, y - 1, 0, 0, 0, A, Text );
					Render ( x - 1, y + 1, 0, 0, 0, A, Text );
					Render ( x + 1, y + 1, 0, 0, 0, A, Text );
				}
			}

			Render ( x, y, R, G, B, A, Text );

			glDisable ( GL_BLEND );
			glEnable ( GL_TEXTURE_2D );
		}

		int Height, Width[255];

	private:
		GLuint g_FontListID;

		inline void Render ( int x, int y, BYTE R, BYTE G, BYTE B, BYTE A, const char *String )
		{
			int i;

			for ( i = 0; x < 0; ++i )
			{
				x += Width[String[i]];

				if ( !String[i] )
					return;
			}

			glColor4ub ( R, G, B, A );
			glRasterPos2i ( x, y );
			glHint ( GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST );
			glPushAttrib ( GL_LIST_BIT );
			glListBase ( g_FontListID );
			glCallLists ( strlen ( String ) - i, GL_UNSIGNED_BYTE, String + i );
			glPopAttrib ( );
		}
	};

	extern Fonts *g_Fonts, *g_Verdana;
}
```

`GroundStrafe.cpp`:

```cpp
#include "GroundStrafe.h"

namespace Client
{
	namespace Functions
	{
		namespace Misc
		{
			GStrafeScrollStruct GroundStrafe::Scroll;

			int GroundStrafe::Count, GroundStrafe::State;
			bool GroundStrafe::HelperActive;

			bool GroundStrafe::Active, GroundStrafe::StandUpActive;

			void GroundStrafe::SetDuckPressed ( bool DuckPressed )
			{
				Scroll.DuckPressed = DuckPressed;
			}

			void GroundStrafe::SetScrollDuck ( bool ScrollDuck )
			{
				Scroll.ScrollDuck = ScrollDuck;
			}

			bool GroundStrafe::GetDuckPressed ( )
			{
				return Scroll.DuckPressed;
			}

			float GroundStrafe::Distance ( const float &frametime )
			{
				return abs ( g_Info->GetHeightGround ( g_Info->GetGroundTrace ( ) ) / SDK::Interfaces::g_pPlayerMove->flFallVelocity / frametime * 2.0f );
			}

			bool GroundStrafe::FallRun ( )
			{
				return g_Info->GetGroundAngle ( g_Info->GetGroundTrace ( ) ) >= 28.5f && g_Info->GetGroundAngle ( g_Info->GetGroundTrace ( ) ) <= 45.0f;
			}

			void GroundStrafe::ScrollEmulation ( const float &frametime, usercmd_s *cmd )
			{
				float flDistance = SDK::Interfaces::g_pEngine->pfnRandomFloat ( StandUpActive ? g_Vars.GroundStrafe.ScrollDistance[0] + 2.0f :
					g_Vars.GroundStrafe.ScrollDistance[0], StandUpActive ? g_Vars.GroundStrafe.ScrollDistance[1] + 2.0f : g_Vars.GroundStrafe.ScrollDistance[1] );

				if ( Distance ( frametime ) <= flDistance || SDK::Interfaces::g_pPlayerMove->flags & FL_ONGROUND )
				{
					if ( g_Vars.GroundStrafe.SlowdownScale != 1.0f && g_Info->GetGroundAngle ( g_Info->GetGroundTrace ( ) ) <=
						g_Vars.GroundStrafe.SlowdownAngle && SDK::Interfaces::g_pPlayerMove->flags & FL_ONGROUND )
					{
						Speed::AdjustSpeed ( g_Vars.GroundStrafe.SlowdownScale <= 0.0f ? 0.000001f : g_Vars.GroundStrafe.SlowdownScale );
					}

					mouse_event ( MOUSEEVENTF_WHEEL, 0, 0, g_Vars.GroundStrafe.ScrollDirection > DOWN ? 120 : -120, 0 );

					Count = BYTE ( SDK::Interfaces::g_pEngine->pfnRandomLong ( int ( g_Vars.GroundStrafe.ScrollCount[0] ), int ( g_Vars.GroundStrafe.ScrollCount[1] ) ) );
					State = 1;
				}
			}

			void GroundStrafe::NoScrollEmulation ( const float &frametime, usercmd_s *cmd )
			{
				if ( Distance ( frametime ) <= ( StandUpActive ? 4.0f : 2.0f ) || SDK::Interfaces::g_pPlayerMove->flags & FL_ONGROUND )
				{
					if ( g_Vars.GroundStrafe.SlowdownScale != 1.0f && g_Info->GetGroundAngle ( g_Info->GetGroundTrace ( ) ) <=
						g_Vars.GroundStrafe.SlowdownAngle && SDK::Interfaces::g_pPlayerMove->flags & FL_ONGROUND )
					{
						Speed::AdjustSpeed ( g_Vars.GroundStrafe.SlowdownScale <= 0.0f ? 0.000001f : g_Vars.GroundStrafe.SlowdownScale );
					}

					cmd->buttons |= IN_DUCK;

					Count = BYTE ( SDK::Interfaces::g_pEngine->pfnRandomLong ( 1, 3 ) );
					State = 1;
				}
			}

			void GroundStrafe::ActiveGroundStrafe ( const float &frametime, usercmd_s *cmd )
			{
				if ( Count )
				{
					if ( State == 1 )
					{
						if ( !g_Vars.GroundStrafe.ScrollEmulation && !FallRun ( ) )
							cmd->buttons &= ~IN_DUCK;

						if ( g_Vars.GroundStrafe.SlowdownScale != 1.0f && g_Info->GetGroundAngle ( g_Info->GetGroundTrace ( ) ) <=
							g_Vars.GroundStrafe.SlowdownAngle && SDK::Interfaces::g_pPlayerMove->flags & FL_ONGROUND )
						{
							Speed::AdjustSpeed ( g_Vars.GroundStrafe.SlowdownScale <= 0.0f ? 0.000001f : g_Vars.GroundStrafe.SlowdownScale );
						}

						--Count;

						State = 2;

						return;
					}
					else if ( State == 2 )
					{
						if ( !g_Vars.GroundStrafe.ScrollEmulation && g_Vars.GroundStrafe.FallRun && FallRun ( ) )
						{
							mouse_event ( MOUSEEVENTF_WHEEL, 0, 0, g_Vars.GroundStrafe.ScrollDirection > DOWN ? 120 : -120, 0 );

							State = 1;

							return;
						}

						if ( g_Vars.GroundStrafe.SlowdownScale != 1.0f && g_Info->GetGroundAngle ( g_Info->GetGroundTrace ( ) ) <=
							g_Vars.GroundStrafe.SlowdownAngle && SDK::Interfaces::g_pPlayerMove->flags & FL_ONGROUND )
						{
							Speed::AdjustSpeed ( g_Vars.GroundStrafe.SlowdownScale <= 0.0f ? 0.000001f : g_Vars.GroundStrafe.SlowdownScale );
						}

						g_Vars.GroundStrafe.ScrollEmulation ?
							mouse_event ( MOUSEEVENTF_WHEEL, 0, 0, g_Vars.GroundStrafe.ScrollDirection > DOWN ? 120 : -120, 0 ) : cmd->buttons |= IN_DUCK;

						State = 1;

						return;
					}
				}
				else
					State = 0;

				if ( SDK::Interfaces::g_pPlayerMove->movetype == 5 || SDK::Interfaces::g_pPlayerMove->waterlevel >= 2 )
				{
					return;
				}

				if ( g_Vars.GroundStrafe.FallRun && FallRun ( ) )
				{
					if ( SDK::Interfaces::g_pPlayerMove->flFallVelocity > 0.0f )
					{
						cmd->buttons |= IN_DUCK;

						return;
					}
					else
					{
						Count = SDK::Interfaces::g_pEngine->pfnRandomLong ( 2, 3 );
						State = 1;

						return;
					}
				}

				if ( g_Info->GetGroundAngle ( g_Info->GetGroundTrace ( ) ) > 45.0f && g_Info->GetGroundAngle ( g_Info->GetGroundTrace ( ) ) < 90.0f )
				{
					if ( SDK::Interfaces::g_pPlayerMove->flags & FL_ONGROUND )
					{
						g_Vars.GroundStrafe.ScrollEmulation ?
							mouse_event ( MOUSEEVENTF_WHEEL, 0, 0, g_Vars.GroundStrafe.ScrollDirection > DOWN ? 120 : -120, 0 ) : cmd->buttons |= IN_DUCK;
					}
					else
						cmd->buttons &= ~IN_DUCK;

					return;
				}

				g_Vars.GroundStrafe.ScrollEmulation ? ScrollEmulation ( frametime, cmd ) : NoScrollEmulation ( frametime, cmd );
			}

			void GroundStrafe::StandUp ( usercmd_s *cmd )
			{
				if ( SDK::Interfaces::g_pPlayerMove->flFallVelocity >= g_Vars.GroundStrafe.StandUpFallVelocity &&
					SDK::Interfaces::g_pPlayerMove->movetype != 5 && SDK::Interfaces::g_pPlayerMove->waterlevel < 2 )
				{
					if ( !g_Info->GetGroundAngle ( g_Info->GetGroundTrace ( ) ) && SDK::Interfaces::g_pPlayerMove->flFallVelocity >= 210.0f )
						return;

					if ( g_Info->GetGroundAngle ( g_Info->GetGroundTrace ( ) ) > 45.0f && g_Info->GetGroundAngle ( g_Info->GetGroundTrace ( ) ) < 90.0f )
					{
						cmd->buttons &= ~IN_DUCK;

						return;
					}

					cmd->buttons |= IN_DUCK;
				}
			}

			void GroundStrafe::Helper ( usercmd_s *cmd )
			{
				float flClientTime = SDK::Interfaces::g_pEngine->GetClientTime ( );

				if ( Scroll.ScrollDuck )
				{
					++Scroll.ScrollCounter;

					Scroll.flLastScrollTime = flClientTime + 0.15f;
				}

				if ( Scroll.flLastScrollTime - flClientTime > 1.0f )
					Scroll.flLastScrollTime = 0.0f;

				if ( Scroll.flLastScrollTime > flClientTime )
				{
					if ( !HelperActive )
					{
						if ( Scroll.ScrollCounter > 0 && SDK::Interfaces::g_pPlayerMove->flFallVelocity > 0.0f &&
							g_Info->GetHeightGround ( g_Info->GetGroundTrace ( ) ) <= 4.2f && Scroll.flLastScrollTime - flClientTime >= 0.13f )
						{
							HelperActive = true;
						}
					}
				}
				else
				{
					if ( Scroll.ScrollCounter > 0 )
						Scroll.ScrollCounter = 0;

					HelperActive = false;
				}

				if ( HelperActive )
				{
					if ( SDK::Interfaces::g_pPlayerMove->movetype == 5 )
					{
						HelperActive = false;

						return;
					}

					if ( SDK::Interfaces::g_pPlayerMove->flags & FL_ONGROUND )
					{
						cmd->buttons |= IN_DUCK;

						HelperActive = false;
					}
					else
						cmd->buttons &= ~IN_DUCK;
				}

				Scroll.ScrollDuck = false;
				Scroll.DuckPressed = false;
			}

			void GroundStrafe::CL_CreateMove ( const float &frametime, usercmd_s *cmd )
			{
				if ( Active || StandUpActive )
				{
					cmd->buttons &= ~IN_JUMP;

					ActiveGroundStrafe ( frametime, cmd );

					if ( StandUpActive )
					{
						StandUp ( cmd );
					}
				}
				else
					Helper ( cmd );
			}
		}
	}
}
```

`GroundStrafe.h`:

```h
#pragma once

#include "Main.h"

namespace Client
{
	namespace Functions
	{
		namespace Misc
		{
			struct GStrafeScrollStruct
			{
				float flLastScrollTime;
				int ScrollCounter;
				bool ScrollDuck;
				bool DuckPressed;
			};

			class GroundStrafe
			{
			public:
				static bool Active, StandUpActive;
				static bool HelperActive;

				static void SetDuckPressed ( bool DuckPressed );
				static void SetScrollDuck ( bool ScrollDuck );
				static bool GetDuckPressed ( );

				static void CL_CreateMove ( const float &frametime, usercmd_s *cmd );

			private:
				static GStrafeScrollStruct Scroll;

				static int Count, State;				

				static float Distance ( const float &frametime );
				static bool FallRun ( );

				static void ScrollEmulation ( const float &frametime, usercmd_s *cmd );
				static void NoScrollEmulation ( const float &frametime, usercmd_s *cmd );

				static void ActiveGroundStrafe ( const float &frametime, usercmd_s *cmd );
				static void StandUp ( usercmd_s *cmd );

				static void Helper ( usercmd_s *cmd );
			};
		}
	}
}
```

`Hpp Hack CS 1.6.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.26430.14
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Hpp Hack CS 1.6", "Hpp Hack CS 1.6\Hpp Hack CS 1.6.vcxproj", "{955AA936-E608-4041-89DE-C8FBC088418A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{955AA936-E608-4041-89DE-C8FBC088418A}.Debug|x64.ActiveCfg = Debug|x64
		{955AA936-E608-4041-89DE-C8FBC088418A}.Debug|x64.Build.0 = Debug|x64
		{955AA936-E608-4041-89DE-C8FBC088418A}.Debug|x86.ActiveCfg = Debug|Win32
		{955AA936-E608-4041-89DE-C8FBC088418A}.Debug|x86.Build.0 = Debug|Win32
		{955AA936-E608-4041-89DE-C8FBC088418A}.Release|x64.ActiveCfg = Release|x64
		{955AA936-E608-4041-89DE-C8FBC088418A}.Release|x64.Build.0 = Release|x64
		{955AA936-E608-4041-89DE-C8FBC088418A}.Release|x86.ActiveCfg = Release|Win32
		{955AA936-E608-4041-89DE-C8FBC088418A}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`Hpp Hack CS 1.6.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{955AA936-E608-4041-89DE-C8FBC088418A}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>HppHackCS16</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.15063.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141_xp</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <UseOfMfc>false</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;HPPHACKCS16_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;_USRDLL;HPPHACKCS16_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;HPPHACKCS16_EXPORTS;_CRT_NONSTDC_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <FloatingPointModel>Fast</FloatingPointModel>
      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
      <FloatingPointExceptions>false</FloatingPointExceptions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;_USRDLL;HPPHACKCS16_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Hpp Hack CS 1.6\AutoPistol.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\BunnyHop.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\Chams.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\Client.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\Crosshair.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\Engine.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\EngineMsg.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\ESP.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\FastZoom.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\Files.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\GroundStrafe.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\Info.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\Main.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\Menu.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\NoFlash.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\Offsets.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\OpenGL.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\Other.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\ParseMsg.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\Recoil.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\ScreenInfo.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\Speed.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\Spread.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\TriggerBot.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\UserMsg.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\Utils.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\WeaponList.cpp" />
    <ClCompile Include="Hpp Hack CS 1.6\Weapons.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Hpp Hack CS 1.6\AutoPistol.h" />
    <ClInclude Include="Hpp Hack CS 1.6\BunnyHop.h" />
    <ClInclude Include="Hpp Hack CS 1.6\Chams.h" />
    <ClInclude Include="Hpp Hack CS 1.6\Client.h" />
    <ClInclude Include="Hpp Hack CS 1.6\Crosshair.h" />
    <ClInclude Include="Hpp Hack CS 1.6\Defines.h" />
    <ClInclude Include="Hpp Hack CS 1.6\Drawing.h" />
    <ClInclude Include="Hpp Hack CS 1.6\Engine.h" />
    <ClInclude Include="Hpp Hack CS 1.6\EngineMsg.h" />
    <ClInclude Include="Hpp Hack CS 1.6\ESP.h" />
    <ClInclude Include="Hpp Hack CS 1.6\FastZoom.h" />
    <ClInclude Include="Hpp Hack CS 1.6\Files.h" />
    <ClInclude Include="Hpp Hack CS 1.6\Fonts.h" />
    <ClInclude Include="Hpp Hack CS 1.6\GroundStrafe.h" />
    <ClInclude Include="Hpp Hack CS 1.6\Info.h" />
    <ClInclude Include="Hpp Hack CS 1.6\Main.h" />
    <ClInclude Include="Hpp Hack CS 1.6\Menu.h" />
    <ClInclude Include="Hpp Hack CS 1.6\NoFlash.h" />
    <ClInclude Include="Hpp Hack CS 1.6\Offsets.h" />
    <ClInclude Include="Hpp Hack CS 1.6\OpenGL.h" />
    <ClInclude Include="Hpp Hack CS 1.6\Other.h" />
    <ClInclude Include="Hpp Hack CS 1.6\Recoil.h" />
    <ClInclude Include="Hpp Hack CS 1.6\ScreenInfo.h" />
    <ClInclude Include="Hpp Hack CS 1.6\Speed.h" />
    <ClInclude Include="Hpp Hack CS 1.6\Spread.h" />
    <ClInclude Include="Hpp Hack CS 1.6\TriggerBot.h" />
    <ClInclude Include="Hpp Hack CS 1.6\UserMsg.h" />
    <ClInclude Include="Hpp Hack CS 1.6\Utils.h" />
    <ClInclude Include="Hpp Hack CS 1.6\Variables.h" />
    <ClInclude Include="Hpp Hack CS 1.6\WeaponList.h" />
    <ClInclude Include="Hpp Hack CS 1.6\Weapons.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Hpp Hack CS 1.6.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="Hpp Hack CS 1.6\Chams.cpp">
      <Filter>Client\Functions\Visuals</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\Crosshair.cpp">
      <Filter>Client\Functions\Visuals</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\ESP.cpp">
      <Filter>Client\Functions\Visuals</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\NoFlash.cpp">
      <Filter>Client\Functions\Visuals</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\Other.cpp">
      <Filter>Client\Functions\Visuals</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\AutoPistol.cpp">
      <Filter>Client\Functions\AimBot</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\Weapons.cpp">
      <Filter>Client\Functions\AimBot</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\Recoil.cpp">
      <Filter>Client\Functions\AimBot</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\BunnyHop.cpp">
      <Filter>Client\Functions\Misc</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\GroundStrafe.cpp">
      <Filter>Client\Functions\Misc</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\FastZoom.cpp">
      <Filter>Client\Functions\AimBot</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\Main.cpp">
      <Filter>Main</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\Info.cpp">
      <Filter>Client\Information</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\Speed.cpp">
      <Filter>Client\Functions\Misc</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\EngineMsg.cpp">
      <Filter>Engine</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\Offsets.cpp">
      <Filter>Engine</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\ParseMsg.cpp">
      <Filter>Engine</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\UserMsg.cpp">
      <Filter>Engine</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\Utils.cpp">
      <Filter>Utils</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\Spread.cpp">
      <Filter>Client\Information</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\WeaponList.cpp">
      <Filter>Client\Information</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\ScreenInfo.cpp">
      <Filter>Client\Functions\Visuals</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\Client.cpp">
      <Filter>Client</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\TriggerBot.cpp">
      <Filter>Client\Functions\TriggerBot</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\Files.cpp">
      <Filter>Files</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\Engine.cpp">
      <Filter>Engine</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\OpenGL.cpp">
      <Filter>OpenGL</Filter>
    </ClCompile>
    <ClCompile Include="Hpp Hack CS 1.6\Menu.cpp">
      <Filter>Client\Functions\Visuals</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Hpp Hack CS 1.6\Defines.h" />
    <ClInclude Include="Hpp Hack CS 1.6\Variables.h" />
    <ClInclude Include="Hpp Hack CS 1.6\Chams.h">
      <Filter>Client\Functions\Visuals</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\Crosshair.h">
      <Filter>Client\Functions\Visuals</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\ESP.h">
      <Filter>Client\Functions\Visuals</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\NoFlash.h">
      <Filter>Client\Functions\Visuals</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\Other.h">
      <Filter>Client\Functions\Visuals</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\AutoPistol.h">
      <Filter>Client\Functions\AimBot</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\Weapons.h">
      <Filter>Client\Functions\AimBot</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\Recoil.h">
      <Filter>Client\Functions\AimBot</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\BunnyHop.h">
      <Filter>Client\Functions\Misc</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\GroundStrafe.h">
      <Filter>Client\Functions\Misc</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\FastZoom.h">
      <Filter>Client\Functions\AimBot</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\Main.h">
      <Filter>Main</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\Info.h">
      <Filter>Client\Information</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\Speed.h">
      <Filter>Client\Functions\Misc</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\Fonts.h">
      <Filter>Renderer</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\Drawing.h">
      <Filter>Renderer</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\EngineMsg.h">
      <Filter>Engine</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\Offsets.h">
      <Filter>Engine</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\UserMsg.h">
      <Filter>Engine</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\Utils.h">
      <Filter>Utils</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\Spread.h">
      <Filter>Client\Information</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\WeaponList.h">
      <Filter>Client\Information</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\ScreenInfo.h">
      <Filter>Client\Functions\Visuals</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\Client.h">
      <Filter>Client</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\TriggerBot.h">
      <Filter>Client\Functions\TriggerBot</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\Files.h">
      <Filter>Files</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\Engine.h">
      <Filter>Engine</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\OpenGL.h">
      <Filter>OpenGL</Filter>
    </ClInclude>
    <ClInclude Include="Hpp Hack CS 1.6\Menu.h">
      <Filter>Client\Functions\Visuals</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Client">
      <UniqueIdentifier>{5bff56d1-2dab-47a9-bc8e-5ab4175ff136}</UniqueIdentifier>
    </Filter>
    <Filter Include="Client\Functions">
      <UniqueIdentifier>{af515df0-d077-4287-af7b-4f99eb654312}</UniqueIdentifier>
    </Filter>
    <Filter Include="Client\Information">
      <UniqueIdentifier>{e73f183e-e409-4505-bf8c-2d67e3a16521}</UniqueIdentifier>
    </Filter>
    <Filter Include="Client\Functions\Visuals">
      <UniqueIdentifier>{73ad2afb-2427-4ed3-94ea-bf7e11d77756}</UniqueIdentifier>
    </Filter>
    <Filter Include="Client\Functions\AimBot">
      <UniqueIdentifier>{a49b572e-cdfe-403c-a99a-32f549f9e179}</UniqueIdentifier>
    </Filter>
    <Filter Include="Client\Functions\TriggerBot">
      <UniqueIdentifier>{9fa3478a-500f-448d-92e7-9bf917fb098a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Client\Functions\Misc">
      <UniqueIdentifier>{4df64334-f253-4e42-b695-00d12250dfa2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Renderer">
      <UniqueIdentifier>{136bc1c8-43d6-447d-b607-975718625aeb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Main">
      <UniqueIdentifier>{c8ce7297-ea55-4cc0-ad36-9ea3ea484a3b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine">
      <UniqueIdentifier>{0a5c3bf4-2699-4e73-abc6-670d0c5b0377}</UniqueIdentifier>
    </Filter>
    <Filter Include="Utils">
      <UniqueIdentifier>{70cd5644-ac98-4747-a953-4a6c24169eee}</UniqueIdentifier>
    </Filter>
    <Filter Include="Files">
      <UniqueIdentifier>{02709cd6-2e3b-4236-bf15-6d7f243919b2}</UniqueIdentifier>
    </Filter>
    <Filter Include="OpenGL">
      <UniqueIdentifier>{cd207a93-d704-476c-b5af-25bed549d04f}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
</Project>
```

`Hpp Hack CS 1.6.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Info.cpp`:

```cpp
#include "Info.h"

namespace Client
{
	Info::Info ( )
	{
		Local.flFrameTime = 0.01f;
		Local.flNextPrimaryAttack = 0.0f;
		Local.Bomb.flC4Timer = 0.0f;

		Local.WeaponID = 0;
		Local.WeaponClip = -1;
		Local.Team = 0;
		Local.FOV = 90;
		Local.InReload = 0;

		Local.Bomb.isPlanted = false;

		for ( int PlayerID = 0; PlayerID <= 32; ++PlayerID )
		{
			Player[PlayerID].Team = 0;

			Player[PlayerID].isAlive = false;
		}
	}

	Vector Info::GetVectorEyePosition ( )
	{
		return SDK::Interfaces::g_pPlayerMove->origin + SDK::Interfaces::g_pPlayerMove->view_ofs;
	}

	int Info::GetLocalIndex ( )
	{
		cl_entity_s* Local = SDK::Interfaces::g_pEngine->GetLocalPlayer ( );

		return Local->index;
	}

	bool Info::GetAliveLocal ( )
	{
		cl_entity_s* Local = SDK::Interfaces::g_pEngine->GetLocalPlayer ( );

		return Local && Local->player && Local->curstate.movetype != 6 && Local->curstate.movetype;
	}

	pmtrace_t* Info::GetGroundTrace ( )
	{
		Vector vOrigin ( SDK::Interfaces::g_pPlayerMove->origin[0], SDK::Interfaces::g_pPlayerMove->origin[1], -4096.0f );

		return SDK::Interfaces::g_pEngine->PM_TraceLine ( SDK::Interfaces::g_pPlayerMove->origin,
			vOrigin, 1, ( SDK::Interfaces::g_pPlayerMove->flags & FL_DUCKING ) ? 1 : 0, -1 );
	}

	float Info::GetGroundAngle ( pmtrace_t* pTrace )
	{
		return acosf ( pTrace->plane.normal[2] ) / M_PI_F * 180.0f;
	}

	float Info::GetHeightGround ( pmtrace_t* pTrace )
	{
		float Height = SDK::Interfaces::g_pPlayerMove->origin[2] - pTrace->endpos[2];

		for ( int Index = 0; Index < SDK::Interfaces::g_pEngine->GetMaxClients ( ); ++Index )
		{
			cl_entity_s* Entity = SDK::Interfaces::g_pEngine->GetEntityByIndex ( Index );

			if ( GetValidationEntity ( Entity ) && Index != GetLocalIndex ( ) )
			{
				bool OnPlayer = abs ( SDK::Interfaces::g_pPlayerMove->origin[0] - Entity->origin[0] ) <= 32.0f &&
					abs ( SDK::Interfaces::g_pPlayerMove->origin[1] - Entity->origin[1] ) <= 32.0f &&
					SDK::Interfaces::g_pPlayerMove->origin[2] > Entity->origin[2];

				if ( OnPlayer )
				{
					Height += GetPlayerHeight ( Entity, GetPlayerGroundTrace ( Entity ) );
					Height -= GetDuckedEntity ( Entity ) ? 49.991f : 72.031f;

					if ( SDK::Interfaces::g_pPlayerMove->flags & FL_ONGROUND || ( GetDuckedEntity ( Entity ) && Height <= 0.001f ) )
					{
						Height = 0.0f;
					}
				}
			}
		}

		return Height;
	}

	float Info::GetEdgeDistance ( )
	{
		float mind = 250.0f;

		if ( GetGroundAngle ( GetGroundTrace ( ) ) )
			return 0.0f;

		TraceEdge ( -1.0f, 0.0f );
		TraceEdge ( 1.0f, 0.0f );
		TraceEdge ( 0.0f, 1.0f );
		TraceEdge ( 0.0f, -1.0f );
		TraceEdge ( -1.0f, -1.0f );
		TraceEdge ( 1.0f, 1.0f );
		TraceEdge ( 1.0f, -1.0f );
		TraceEdge ( -1.0f, 1.0f );

		return mind;
	}

	int Info::GetFallDamage ( )
	{
		float flFallDamage1 = Utils::EndSpeed ( SDK::Interfaces::g_pPlayerMove->flFallVelocity,
			SDK::Interfaces::g_pEngine->pfnGetGravity ( ), 0.01f, GetHeightGround ( GetGroundTrace ( ) ) ) - PLAYER_MAX_SAFE_FALL_SPEED;

		float flFallDamage2 = flFallDamage1 * DAMAGE_FOR_FALL_SPEED < 0.0f ? 0.0f : flFallDamage1 * DAMAGE_FOR_FALL_SPEED;

		if ( flFallDamage2 - ( int )flFallDamage2 >= 0.01f )
		{
			++flFallDamage2;
		}

		return ( int )flFallDamage2;
	}

	bool Info::GetSlideSurface ( )
	{
		return GetGroundAngle ( GetGroundTrace ( ) ) > 45.0f && GetHeightGround ( GetGroundTrace ( ) ) < 1.0f;
	}

	bool Info::GetDuckedEntity ( cl_entity_s* Entity )
	{
		return Entity->curstate.maxs[2] - Entity->curstate.mins[2] < 54.0f;
	}

	bool Info::GetValidationEntity ( cl_entity_s* Entity )
	{
		cl_entity_s *Local = SDK::Interfaces::g_pEngine->GetLocalPlayer ( );

		return Entity && ( g_Vars.Main.PlayerValidCheck >= 2 ? ( Entity->player && !Player[Entity->index].isDead ) : Player[Entity->index].isAlive ) &&
			!( Entity->curstate.messagenum < Local->curstate.messagenum ) && !( Local->curstate.iuser1 == 4 && Local->curstate.iuser2 == Entity->index );
	}

	float Info::GetDistanceToEntity ( const Vector& vOrigin )
	{
		return floorf ( sqrtf ( POW ( abs ( vOrigin[0] - SDK::Interfaces::g_pPlayerMove->origin[0] ) ) +
			POW ( abs ( vOrigin[1] - SDK::Interfaces::g_pPlayerMove->origin[1] ) ) +
			POW ( abs ( vOrigin[2] - SDK::Interfaces::g_pPlayerMove->origin[2] ) ) ) - 32.0f );
	}

	bool Info::GetVisibilityEntityByIndex ( const int& Index )
	{
		return Utils::PathFree ( Player[Index].vHitBox[11] );
	}

	pmtrace_t* Info::GetPlayerGroundTrace ( cl_entity_s* Entity )
	{
		Vector vOrigin ( Entity->origin[0], Entity->origin[1], -4096.0f );

		return SDK::Interfaces::g_pEngine->PM_TraceLine ( Entity->origin, vOrigin, 1, GetDuckedEntity ( Entity ) ? 1 : 0, -1 );
	}

	float Info::GetPlayerHeight ( cl_entity_s* Entity, pmtrace_t* pTrace )
	{
		float PlayerHeight = Entity->origin[2] - pTrace->endpos[2];

		if ( PlayerHeight < 0.0f )
			PlayerHeight = 0.0f;

		return PlayerHeight;
	}

	bool Info::GetPlayerOnGround ( cl_entity_s* Entity )
	{
		float PlayerHeight = GetPlayerHeight ( Entity, GetPlayerGroundTrace ( Entity ) );

		return PlayerHeight <= 1.0f;
	}

	void Info::UpdateDeadInfoByIndex ( const int& Index )
	{
		if ( Player[Index].isDead )
		{
			if ( GetTickCount64 ( ) >= Player[Index].isDeadTime + 6000 )
			{
				Player[Index].isDead = false;
			}
		}
		else
			Player[Index].isDeadTime = GetTickCount64 ( );
	}

	void Info::UpdateInfoByIndex ( const int& Index )
	{
		SDK::Interfaces::g_pEngine->pfnGetPlayerInfo ( Index, &Player[Index].Info );

		if ( g_Vars.Functions.Weapons && g_Vars.Aim.Enable && g_Vars.Weapons[GetWeaponID ( )].Aim && !GetBadWeapon ( ) && GetAliveLocal ( ) )
			Functions::AimBot::Weapons::UpdateAimInfo ( Index );

		if ( g_Vars.Functions.TriggerWeapons && g_Vars.Trigger.Enable && !GetBadWeapon ( ) && GetAliveLocal ( ) )
			Functions::TriggerBot::Trigger::UpdateAimInfo ( Index );
	}

	void Info::GetHitBoxOrigin ( cl_entity_s* Entity )
	{
		Vector vBBMin, vBBMax;

		typedef float BoneMatrix_t[MAXSTUDIOBONES][3][4];

		model_s *Model = SDK::Interfaces::g_pStudio->SetupPlayerModel ( Entity->index );
		studiohdr_t* StudioHeader = ( studiohdr_t* )SDK::Interfaces::g_pStudio->Mod_Extradata ( Model );
		BoneMatrix_t* BoneMatrix = ( BoneMatrix_t* )SDK::Interfaces::g_pStudio->StudioGetBoneTransform ( );
		mstudiobbox_t* HitBox = ( mstudiobbox_t* )( ( BYTE* )StudioHeader + StudioHeader->hitboxindex );

		for ( int i = 0; i < StudioHeader->numhitboxes; ++i )
		{
			VectorTransform ( HitBox[i].bbmin, ( *BoneMatrix )[HitBox[i].bone], vBBMin );
			VectorTransform ( HitBox[i].bbmax, ( *BoneMatrix )[HitBox[i].bone], vBBMax );

			Player[Entity->index].vHitBox[i] = ( vBBMax + vBBMin ) / 2.0f;
		}
	}

	void Info::BulletControl ( usercmd_s* cmd )
	{
		static int SaveiClip;

		if ( cmd->buttons & IN_ATTACK )
		{
			if ( !g_Info->GetWeaponClip ( ) )
			{
				Local.ShotsFired = 0;

				return;
			}

			if ( !Local.ShotsFired && ( SaveiClip - g_Info->GetWeaponClip ( ) ) < 0 )
				SaveiClip = g_Info->GetWeaponClip ( ) + 1;

			Local.ShotsFired = SaveiClip - g_Info->GetWeaponClip ( );
		}
		else
		{
			SaveiClip = g_Info->GetWeaponClip ( );
			Local.ShotsFired = 0;
		}
	}

	Info *g_Info = nullptr;
}
```

`Info.h`:

```h
#pragma once

#include "Main.h"

namespace Client
{
	struct BombStruct
	{
		float flC4Timer;
		bool isPlanted;
	};

	struct LocalStruct
	{
		BombStruct Bomb;
		Vector vForward, vPunchAngles;
		Vector vCmdViewAngles, vSpreadAngles;
		float flFrameTime, flNextPrimaryAttack;
		int WeaponID, WeaponClip;
		int Team, FOV, InReload;
		int ShotsFired;
	};

	struct PlayerStruct
	{
		hud_player_info_t Info;

		Vector vHitBox[21];
		DWORD64 isDeadTime;
		int Team;
		bool isAlive, isDead;
	};

	class Info
	{
	public:
		Info ( );

		inline void SetVectorSpreadAngles ( const Vector& vSpreadAngles ) { Local.vSpreadAngles = vSpreadAngles; }
		inline void SetVectorPunchAngles ( const Vector& vPunchAngles ) { Local.vPunchAngles = vPunchAngles; }
		inline void SetVectorForward ( const Vector& vForward ) { Local.vForward = vForward; }
		inline void SetCmdViewAngles ( const Vector& vCmdViewAngles ) { Local.vCmdViewAngles = vCmdViewAngles; }
		inline void SetPlayerIsDeadByIndex ( const int& Index, const bool& isDead ) { Player[Index].isDead = isDead; }
		inline void SetPlayerIsAliveByIndex ( const int& Index, const bool& isAlive ) { Player[Index].isAlive = isAlive; }
		inline void SetPlayerTeamByIndex ( const int& Index, const int &Team ) { Player[Index].Team = Team; }
		inline void SetNextPrimaryAttack ( const float& flNextPrimaryAttack ) { Local.flNextPrimaryAttack = flNextPrimaryAttack; }
		inline void SetInReload ( const int& InReload ) { Local.InReload = InReload; }
		inline void SetFrameTime ( const float& flFrameTime ) { Local.flFrameTime = flFrameTime; }
		inline void SetC4Timer ( const float& flC4Timer ) { Local.Bomb.flC4Timer = flC4Timer; }
		inline void SetFOV ( const int& FOV ) { Local.FOV = FOV; }
		inline void SetWeaponID ( const int& WeaponID ) { Local.WeaponID = WeaponID; }
		inline void SetWeaponClip ( const int& WeaponClip ) { Local.WeaponClip = WeaponClip; }
		inline void SetPlayerTeam ( const int& Team ) { Local.Team = Team; }
		inline void SetIsPlanted ( const bool& isPlanted ) { Local.Bomb.isPlanted = isPlanted; }

		inline hud_player_info_t GetPlayerInfoByIndex ( const int& Index ) { return Player[Index].Info; }
		inline Vector GetVectorSpreadAngles ( ) { return Local.vSpreadAngles; }
		inline Vector GetVectorPunchAngles ( ) { return Local.vPunchAngles; }
		inline Vector GetVectorForward ( ) { return Local.vForward; }
		inline Vector GetCmdViewAngles ( ) { return Local.vCmdViewAngles; }
		inline Vector GetHitBoxByIndex ( const int& Index, const int HitBoxNum ) { return Player[Index].vHitBox[HitBoxNum]; }
		inline int GetPlayerTeamByIndex ( const int& Index ) { return Player[Index].Team; }
		inline float GetNextPrimaryAttack ( ) { return Local.flNextPrimaryAttack; }
		inline int GetInReload ( ) { return Local.InReload; }
		inline float GetFrameTime ( ) { return Local.flFrameTime; }
		inline float GetC4Timer ( ) { return Local.Bomb.flC4Timer; }
		inline int GetFOV ( ) { return Local.FOV; }
		inline int GetWeaponID ( ) { return Local.WeaponID; }
		inline int GetWeaponClip ( ) { return Local.WeaponClip; }
		inline int GetPlayerTeam ( ) { return Local.Team; }
		inline int GetShotsFired ( ) { return Local.ShotsFired; }
		inline bool GetIsPlanted ( ) { return Local.Bomb.isPlanted; }

		/*locals*/
		pmtrace_t* GetGroundTrace ( );
		Vector GetVectorEyePosition ( );
		int GetLocalIndex ( );
		float GetGroundAngle ( pmtrace_t* pTrace );
		float GetHeightGround ( pmtrace_t* pTrace );
		float GetEdgeDistance ( );
		float GetDistanceToEntity ( const Vector& vOrigin );
		int GetFallDamage ( );
		bool GetAliveLocal ( );
		bool GetSlideSurface ( );
		bool GetDuckedEntity ( cl_entity_s* Entity );
		bool GetValidationEntity ( cl_entity_s* Entity );
		bool GetVisibilityEntityByIndex ( const int& Index );

		/*players*/
		pmtrace_t* GetPlayerGroundTrace ( cl_entity_s* Entity );
		float GetPlayerHeight ( cl_entity_s* Entity, pmtrace_t* pTrace );
		bool GetPlayerOnGround ( cl_entity_s* Entity );

		inline bool GetBadWeapon ( )
		{
			return GetWeaponID ( ) == WEAPONLIST_C4 || GetWeaponID ( ) == WEAPONLIST_FLASHBANG ||
				GetWeaponID ( ) == WEAPONLIST_HEGRENADE || GetWeaponID ( ) == WEAPONLIST_KNIFE || GetWeaponID ( ) == WEAPONLIST_SMOKEGRENADE;
		}

		inline bool GetWeaponListSnipers ( )
		{
			return GetWeaponID ( ) == 3 || GetWeaponID ( ) == 18 || GetWeaponID ( ) == 24 || GetWeaponID ( ) == 13;
		}

		inline bool GetWeaponListPistols ( )
		{
			return GetWeaponID ( ) == 1 || GetWeaponID ( ) == 10 || GetWeaponID ( ) == 11 ||
				GetWeaponID ( ) == 16 || GetWeaponID ( ) == 17 || GetWeaponID ( ) == 26;
		}

		inline bool GetWeaponListRifles ( )
		{
			return GetWeaponID ( ) == 7 || GetWeaponID ( ) == 8 || GetWeaponID ( ) == 12 || GetWeaponID ( ) == 14 || GetWeaponID ( ) == 15 ||
				GetWeaponID ( ) == 19 || GetWeaponID ( ) == 20 || GetWeaponID ( ) == 21 || GetWeaponID ( ) == 22 || GetWeaponID ( ) == 23 ||
				GetWeaponID ( ) == 27 || GetWeaponID ( ) == 28 || GetWeaponID ( ) == 30;
		}

		void GetHitBoxOrigin ( cl_entity_s* Entity );

		void BulletControl ( usercmd_s* cmd );

		void UpdateDeadInfoByIndex ( const int& Index );
		void UpdateInfoByIndex ( const int& Index );

	private:
		LocalStruct Local;
		PlayerStruct Player[33];
	};

	extern Info *g_Info;
}
```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`Main.cpp`:

```cpp
#include "Main.h"

namespace Renderer
{
	void Drawing::FillArea ( int x, int y, int w, int h, BYTE R, BYTE G, BYTE B, BYTE A )
	{
		SDK::Interfaces::g_pEngine->pfnTintRGBA ( x, y, w, h, R, G, B, A );
	}

	Drawing *g_Drawing = nullptr;
	Fonts *g_Fonts = nullptr;
	Fonts *g_Verdana = nullptr;
}

void Initialize ( )
{
	Renderer::g_Drawing = new Renderer::Drawing;
	Renderer::g_Fonts = new Renderer::Fonts;
	Renderer::g_Verdana = new Renderer::Fonts;
	Client::g_Info = new Client::Info;
}

void Shutdown ( )
{
	DELETE_MOD ( Renderer::g_Drawing );
	DELETE_MOD ( Renderer::g_Fonts );
	DELETE_MOD ( Renderer::g_Verdana );
	DELETE_MOD ( Client::g_Info );
}

DWORD WINAPI ProcessReload ( LPVOID lpThreadParameter )
{
	while ( true )
	{
		if ( Client::FirstFrame )
		{
			if ( !Engine::Offset::GetModuleInfo ( ) )
			{
				Client::dwStudioModelRenderer = 0;
				Client::dwStudioRenderFinal = 0;

				Client::FirstFrame = false;
			}
		}
		else
			CreateThread ( 0, 0, ( LPTHREAD_START_ROUTINE )CheatEntry, 0, 0, 0 );

		Sleep ( 100 );
	}

	return 0;
}

DWORD WINAPI CheatEntry ( LPVOID lpThreadParameter )
{
	static HANDLE hProcessReloadThread;

	if ( hProcessReloadThread )
	{
		TerminateThread ( hProcessReloadThread, 0 );
		CloseHandle ( hProcessReloadThread );
	}

	Files::InjectLog ( "Initialization..." );

	Initialize ( );
	SDK::Offset::Initialize ( hProcessReloadThread );

	return 0;
}

BOOL WINAPI DllMain ( HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved )
{
	if ( dwReason == DLL_PROCESS_ATTACH )
	{
		DisableThreadLibraryCalls ( hInstance );

		Files::GetBaseDir ( hInstance );
		Files::CreateLogDirectory ( );
		Files::CreateInjectLogFile ( );
		Files::CreateInfoLogFile ( );

		Files::InjectLog ( "CreateThread..." );

		CreateThread ( 0, 0, ( LPTHREAD_START_ROUTINE )CheatEntry, 0, 0, 0 );
	}
	else if ( dwReason == DLL_PROCESS_DETACH )
	{
		Shutdown ( );
	}

	return TRUE;
}
```

`Main.h`:

```h
#pragma once

#pragma comment ( lib, "OpenGL32.lib" )
#pragma comment ( lib, "GLu32.lib" )

#include <Windows.h>
#include <conio.h>
#include <io.h>
#include <fstream>
#include <ctime>
#include <vector>
#include <memory>

#include <gl/gl.h>
#include <gl/glu.h>

#include "ValveSDK/wrect.h"
#include "ValveSDK/cl_dll.h"
#include "ValveSDK/r_studioint.h"
#include "ValveSDK/cl_entity.h"
#include "ValveSDK/triangleapi.h"
#include "ValveSDK/pmtrace.h"
#include "ValveSDK/pm_defs.h"
#include "ValveSDK/pm_info.h"
#include "ValveSDK/cvardef.h"
#include "ValveSDK/util_vector.h"
#include "ValveSDK/studio.h"
#include "ValveSDK/event_args.h"
#include "ValveSDK/event_flags.h"
#include "ValveSDK/keydefs.h"
#include "ValveSDK/ref_params.h"
#include "ValveSDK/studio_event.h"
#include "ValveSDK/net_api.h"
#include "ValveSDK/r_efx.h"
#include "ValveSDK/event_api.h"
#include "ValveSDK/screenfade.h"
#include "ValveSDK/engine_launcher_api.h"
#include "ValveSDK/entity_types.h"
#include "ValveSDK/com_model.h"
#include "ValveSDK/parsemsg.h"

#include "Defines.h"

typedef void ( *pfnEngineMsgHook )( );
typedef void ( *Snapshot_t )( );
typedef void ( *Screenshot_t )( );

typedef struct cl_clientfuncs_s
{
	int ( *Initialize ) ( cl_enginefunc_t *pEnginefuncs, int iVersion );
	int ( *HUD_Init ) ( void );
	int ( *HUD_VidInit ) ( void );
	void ( *HUD_Redraw ) ( float time, int intermission );
	int ( *HUD_UpdateClientData ) ( client_data_t *pcldata, float flTime );
	int ( *HUD_Reset ) ( void );
	void ( *HUD_PlayerMove ) ( struct playermove_s *ppmove, int server );
	void ( *HUD_PlayerMoveInit ) ( struct playermove_s *ppmove );
	char ( *HUD_PlayerMoveTexture ) ( char *name );
	void ( *IN_ActivateMouse ) ( void );
	void ( *IN_DeactivateMouse ) ( void );
	void ( *IN_MouseEvent ) ( int mstate );
	void ( *IN_ClearStates ) ( void );
	void ( *IN_Accumulate ) ( void );
	void ( *CL_CreateMove ) ( float frametime, struct usercmd_s *cmd, int active );
	int ( *CL_IsThirdPerson ) ( void );
	void ( *CL_CameraOffset ) ( float *ofs );
	struct kbutton_s *( *KB_Find ) ( const char *name );
	void ( *CAM_Think ) ( void );
	void ( *V_CalcRefdef ) ( struct ref_params_s *pparams );
	int ( *HUD_AddEntity ) ( int type, struct cl_entity_s *ent, const char *modelname );
	void ( *HUD_CreateEntities ) ( void );
	void ( *HUD_DrawNormalTriangles ) ( void );
	void ( *HUD_DrawTransparentTriangles ) ( void );
	void ( *HUD_StudioEvent ) ( const struct mstudioevent_s *event, const struct cl_entity_s *entity );
	void ( *HUD_PostRunCmd ) ( struct local_state_s *from, struct local_state_s *to, struct usercmd_s *cmd, int runfuncs, double time, unsigned int random_seed );
	void ( *HUD_Shutdown ) ( void );
	void ( *HUD_TxferLocalOverrides ) ( struct entity_state_s *state, const struct clientdata_s *client );
	void ( *HUD_ProcessPlayerState ) ( struct entity_state_s *dst, const struct entity_state_s *src );
	void ( *HUD_TxferPredictionData ) ( struct entity_state_s *ps, const struct entity_state_s *pps, struct clientdata_s *pcd, const struct clientdata_s *ppcd, struct weapon_data_s *wd, const struct weapon_data_s *pwd );
	void ( *Demo_ReadBuffer ) ( int size, unsigned char *buffer );
	int ( *HUD_ConnectionlessPacket ) ( struct netadr_s *net_from, const char *args, char *response_buffer, int *response_buffer_size );
	int ( *HUD_GetHullBounds ) ( int hullnumber, float *mins, float *maxs );
	void ( *HUD_Frame ) ( double time );
	int ( *HUD_Key_Event ) ( int down, int keynum, const char *pszCurrentBinding );
	void ( *HUD_TempEntUpdate ) ( double frametime, double client_time, double cl_gravity, struct tempent_s **ppTempEntFree, struct tempent_s **ppTempEntActive, int ( *Callback_AddVisibleEntity )( struct cl_entity_s *pEntity ), void ( *Callback_TempEntPlaySound )( struct tempent_s *pTemp, float damp ) );
	struct cl_entity_s *( *HUD_GetUserEntity ) ( int index );
	int ( *HUD_VoiceStatus ) ( int entindex, qboolean bTalking );
	int ( *HUD_DirectorMessage ) ( unsigned char command, unsigned int firstObject, unsigned int secondObject, unsigned int flags );
	int ( *HUD_GetStudioModelInterface ) ( int version, struct r_studio_interface_s **ppinterface, struct engine_studio_api_s *pstudio );
	void ( *HUD_CHATINPUTPOSITION_FUNCTION ) ( int *x, int *y );
	void ( *CLIENTFACTORY ) ( void );
	int ( *HUD_GETPLAYERTEAM_FUNCTION ) ( int iplayer );
} cl_clientfunc_t;

typedef struct UserMsg
{
	int	number;
	int	size;
	char name[16];
	struct UserMsg* next;
	pfnUserMsgHook pfn;
} *PUserMsg;

typedef struct EngineMsg
{
	int	number;
	char* name;
	pfnEngineMsgHook pfn;
} *PEngineMsg;

typedef struct sizebuf_s
{
	const char *buffername;
	uint16 flags;
	byte *data;
	int maxsize;
	int	cursize;
} sizebuf_t;

typedef struct Color24
{
	BYTE R, G, B;
} TColor24, *PColor24;

typedef struct GameInfo_s
{
	char* GameName;
	char* GameVersion;
	BYTE Protocol;
	DWORD Build;
} GameInfo_t, *pGameInfo_s;

typedef struct cmd_s
{
	struct cmd_s *next;
	char *name;
	xcommand_t function;
	int	flags;
} cmd_t, *pcmd_t;

#include "Engine.h"
#include "Offsets.h"
#include "Utils.h"
#include "Files.h"
#include "Client.h"

#include "Variables.h"
#include "EngineMsg.h"
#include "UserMsg.h"
#include "Info.h"
#include "ScreenInfo.h"
#include "Fonts.h"
#include "Drawing.h"
#include "Menu.h"
#include "ESP.h"
#include "NoFlash.h"
#include "Speed.h"
#include "BunnyHop.h"
#include "Crosshair.h"
#include "Weapons.h"
#include "Other.h"
#include "Recoil.h"
#include "AutoPistol.h"
#include "FastZoom.h"
#include "Chams.h"
#include "OpenGL.h"
#include "GroundStrafe.h"
#include "TriggerBot.h"
#include "Spread.h"
#include "WeaponList.h"

DWORD WINAPI CheatEntry ( LPVOID lpThreadParameter );
DWORD WINAPI ProcessReload ( LPVOID lpThreadParameter );
```

`Menu.cpp`:

```cpp
#include "Menu.h"

namespace Client
{
	namespace Functions
	{
		namespace Visuals
		{
			M_Entry Menu::MenuEntry[MAX_SUBS_MENU];
			S_Entry Menu::SubmEntry[MAX_SUBS_MENU];
			SS_Entry Menu::SubSubmEntry[MAX_SUBS_MENU];

			int Menu::M_EntryPos, Menu::M_EntrySize;
			int Menu::S_EntryPos, Menu::S_EntrySize;
			int Menu::SS_EntryPos, Menu::SS_EntrySize;

			char Menu::String[20];

			bool Menu::SubMenu, Menu::SubSubMenu;
			bool Menu::Visible, Menu::InputString;
			bool Menu::VisibleAnimation;

			float Menu::flVisibleAnimationTimer;

			int Menu::BoxWidth, Menu::BoxHeight;
			BYTE Menu::BoxOutlineColor[4], Menu::BoxColor[4];
			BYTE Menu::BoxSelectColor[4], Menu::TextColor[3];

			enum MENU_ENTRY
			{
				MAIN, AIMBOT, TRIGGERBOT, VISUALS, MISC, KEYS, LOAD_SETTINGS, SAVE_SETTINGS
			};

			enum SUBMENU_ENTRY_AIMBOT
			{
				GLOBALS, PISTOLS, RIFLES, SNIPERS, CURRENT, RECOIL, AUTOPISTOL, FASTZOOM
			};

			enum SUBMENU_ENTRY_TRIGGERBOT
			{
				TGLOBALS, TPISTOLS, TRIFLES, TSNIPERS, TCURRENT
			};

			enum SUBMENU_ENTRY_VISUALS
			{
				MENU, SCREENINFO, ESP, ESP_COLORS,
				CHAMS, CHAMS_COLORS, NOFLASH, CROSSHAIR, OTHER
			};

			enum SUBMENU_ENTRY_MISC
			{
				SPEED, BUNNYHOP, GROUNDSTRAFE
			};

			enum SUBMENU_ENTRY_KEYS
			{
				KMAIN, KPANICS, KTRIGGERBOT, KSPEED, KBUNNYHOP, KGROUNDSTRAFE
			};

			void Menu::SetSettings ( )
			{
				BoxWidth = g_Vars.Menu.BoxWidth;
				BoxHeight = g_Vars.Menu.BoxHeight;

				for ( int i = 0; i < 4; ++i )
				{
					BoxOutlineColor[i] = g_Vars.Menu.BoxOutlineColor[i];
					BoxColor[i] = g_Vars.Menu.BoxColor[i];
					BoxSelectColor[i] = g_Vars.Menu.BoxSelectColor[i];

					if ( i < 3 )
					{
						TextColor[i] = g_Vars.Menu.TextColor[i];
					}
				}
			}

			void Menu::Initialize ( )
			{
				Clear ( );

				Add ( "Main", false, false );
				Add ( "AimBot", false, false );
				Add ( "TriggerBot", false, false );
				Add ( "Visuals", false, false );
				Add ( "Misc", false, false );
				Add ( "Keys", true, false );
				Add ( "Load Settings", false, true );
				Add ( "Save Settings", false, true );

				switch ( M_EntryPos )
				{
				case MENU_ENTRY::MAIN:
				{
					AddSubInt ( "Language", &g_Vars.Main.Language, ENGLISH, RUSSIAN, 1, false, true,
						false, true, false, false, TextColor[0], TextColor[1], TextColor[2] );

					AddSubInt ( "Player.Valid.Check", &g_Vars.Main.PlayerValidCheck, 1, 2, 1, false, true,
						false, true, false, false, TextColor[0], TextColor[1], TextColor[2] );

					AddSubInt ( "AntiScreen", 0, 0, 0, 0, false, true, false, true,
						true, false, TextColor[0], TextColor[1], TextColor[2] );

					AddSubInt ( "Font.Outline.Style", &g_Vars.Main.FontOutlineStyle, 1, 2, 1, false, false,
						false, true, false, false, TextColor[0], TextColor[1], TextColor[2] );

					if ( S_EntryPos == 2 )
					{
						AddSubSubBool ( "Enable", &g_Vars.Main.AntiScreenEnable, false, false, true, false, false );
						AddSubSubInt ( "Timer", &g_Vars.Main.AntiScreenTimer, 1, 1000, 1, false, false, false, false, false );
					}

					break;
				}

				case MENU_ENTRY::AIMBOT:
				{
					g_Vars.Functions.Weapons ?
						AddSubInt ( "Globals", 0, 0, 0, 0, false, true, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] ) :
						AddSubInt ( "Globals", 0, 0, 0, 0, false, true, false, false, true, false, 100, 100, 100 );

					g_Vars.Functions.Weapons ?
						AddSubInt ( "Pistols", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] ) :
						AddSubInt ( "Pistols", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );

					g_Vars.Functions.Weapons ?
						AddSubInt ( "Rifles", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] ) :
						AddSubInt ( "Rifles", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );

					g_Vars.Functions.Weapons ?
						AddSubInt ( "Snipers", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] ) :
						AddSubInt ( "Snipers", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );

					g_Vars.Functions.Weapons ?
						AddSubInt ( "Current", 0, 0, 0, 0, false, true, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] ) :
						AddSubInt ( "Current", 0, 0, 0, 0, false, true, false, false, true, false, 100, 100, 100 );

					g_Vars.Functions.Recoil ?
						AddSubInt ( "Recoil", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] ) :
						AddSubInt ( "Recoil", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );

					g_Vars.Functions.AutoPistol ?
						AddSubInt ( "AutoPistol", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] ) :
						AddSubInt ( "AutoPistol", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );

					g_Vars.Functions.FastZoom ?
						AddSubInt ( "FastZoom", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] ) :
						AddSubInt ( "FastZoom", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );

					switch ( S_EntryPos )
					{
					case SUBMENU_ENTRY_AIMBOT::GLOBALS:
					{
						AddSubSubBool ( "Enable", &g_Vars.Aim.Enable, false, false, true, false, false );
						AddSubSubBool ( "Silent", &g_Vars.Aim.Silent, false, false, true, false, false );
						AddSubSubBool ( "FriendlyFire", &g_Vars.Aim.FriendlyFire, false, false, true, false, false );
						AddSubSubBool ( "VisibleCheck", &g_Vars.Aim.VisibleCheck, false, false, true, false, false );
						AddSubSubBool ( "FlashCheck", &g_Vars.Aim.FlashCheck, false, false, true, false, false );
						AddSubSubBool ( "FOV.Distance", &g_Vars.Aim.FOVDistance, false, false, true, false, false );
						AddSubSubInt ( "KillDelay", &g_Vars.Aim.KillDelay, 0, 1000, 1, false, false, false, false, false );

						break;
					}

					case SUBMENU_ENTRY_AIMBOT::PISTOLS:
					{
						AddSubSubBool ( "Aim", &g_Vars.Weapons[26].Aim, false, false, true, false, false );
						AddSubSubInt ( "BulletControl.Start", &g_Vars.Weapons[26].BulletControl[0], 1, 1000, 1, false, false, false, false, false );
						AddSubSubInt ( "BulletControl.End", &g_Vars.Weapons[26].BulletControl[1], 1, 1000, 1, false, false, false, false, false );
						AddSubSubInt ( "HitBox", &g_Vars.Weapons[26].HitBox, 0, 20, 1, false, false, false, false, false );
						AddSubSubBool ( "HitBox.Nearest", &g_Vars.Weapons[26].HitBoxNearest, false, false, true, false, false );
						AddSubSubFloat ( "Prediction", &g_Vars.Weapons[26].Prediction, 0.0f, 5.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "FOV", &g_Vars.Weapons[26].FOV, 0.0f, 90.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Smooth", &g_Vars.Weapons[26].Smooth, 1.0f, 50.0f, 0.01f, true, false, false, false, false );
						AddSubSubInt ( "Delay", &g_Vars.Weapons[26].Delay, 0, 1000, 1, false, false, false, false, false );
						AddSubSubInt ( "Delay.Type", &g_Vars.Weapons[26].DelayType, 1, 3, 1, false, false, false, false, false );
						AddSubSubFloat ( "Recoil", &g_Vars.Weapons[26].Recoil, 0.0f, 3.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Recoil.Prediction", &g_Vars.Weapons[26].RecoilPrediction, 0.0f, 5.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Recoil.FOV", &g_Vars.Weapons[26].RecoilFOV, 0.0f, 90.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Recoil.Smooth", &g_Vars.Weapons[26].RecoilSmooth, 0.0f, 50.0f, 0.01f, true, false, false, false, false );

						break;
					}

					case SUBMENU_ENTRY_AIMBOT::RIFLES:
					{
						AddSubSubBool ( "Aim", &g_Vars.Weapons[28].Aim, false, false, true, false, false );
						AddSubSubInt ( "BulletControl.Start", &g_Vars.Weapons[28].BulletControl[0], 1, 1000, 1, false, false, false, false, false );
						AddSubSubInt ( "BulletControl.End", &g_Vars.Weapons[28].BulletControl[1], 1, 1000, 1, false, false, false, false, false );
						AddSubSubInt ( "HitBox", &g_Vars.Weapons[28].HitBox, 0, 20, 1, false, false, false, false, false );
						AddSubSubBool ( "HitBox.Nearest", &g_Vars.Weapons[28].HitBoxNearest, false, false, true, false, false );
						AddSubSubFloat ( "Prediction", &g_Vars.Weapons[28].Prediction, 0.0f, 5.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "FOV", &g_Vars.Weapons[28].FOV, 0.0f, 90.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Smooth", &g_Vars.Weapons[28].Smooth, 1.0f, 50.0f, 0.01f, true, false, false, false, false );
						AddSubSubInt ( "Delay", &g_Vars.Weapons[28].Delay, 0, 1000, 1, false, false, false, false, false );
						AddSubSubInt ( "Delay.Type", &g_Vars.Weapons[28].DelayType, 1, 3, 1, false, false, false, false, false );
						AddSubSubFloat ( "Recoil", &g_Vars.Weapons[28].Recoil, 0.0f, 3.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Recoil.Prediction", &g_Vars.Weapons[28].RecoilPrediction, 0.0f, 5.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Recoil.FOV", &g_Vars.Weapons[28].RecoilFOV, 0.0f, 90.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Recoil.Smooth", &g_Vars.Weapons[28].RecoilSmooth, 0.0f, 50.0f, 0.01f, true, false, false, false, false );

						break;
					}

					case SUBMENU_ENTRY_AIMBOT::SNIPERS:
					{
						AddSubSubBool ( "Aim", &g_Vars.Weapons[18].Aim, false, false, true, false, false );
						AddSubSubInt ( "BulletControl.Start", &g_Vars.Weapons[18].BulletControl[0], 1, 1000, 1, false, false, false, false, false );
						AddSubSubInt ( "BulletControl.End", &g_Vars.Weapons[18].BulletControl[1], 1, 1000, 1, false, false, false, false, false );
						AddSubSubInt ( "HitBox", &g_Vars.Weapons[18].HitBox, 0, 20, 1, false, false, false, false, false );
						AddSubSubBool ( "HitBox.Nearest", &g_Vars.Weapons[18].HitBoxNearest, false, false, true, false, false );
						AddSubSubFloat ( "Prediction", &g_Vars.Weapons[18].Prediction, 0.0f, 5.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "FOV", &g_Vars.Weapons[18].FOV, 0.0f, 90.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Smooth", &g_Vars.Weapons[18].Smooth, 1.0f, 50.0f, 0.01f, true, false, false, false, false );
						AddSubSubInt ( "Delay", &g_Vars.Weapons[18].Delay, 0, 1000, 1, false, false, false, false, false );
						AddSubSubInt ( "Delay.Type", &g_Vars.Weapons[18].DelayType, 1, 3, 1, false, false, false, false, false );
						AddSubSubFloat ( "Recoil", &g_Vars.Weapons[18].Recoil, 0.0f, 3.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Recoil.Prediction", &g_Vars.Weapons[18].RecoilPrediction, 0.0f, 5.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Recoil.FOV", &g_Vars.Weapons[18].RecoilFOV, 0.0f, 90.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Recoil.Smooth", &g_Vars.Weapons[18].RecoilSmooth, 0.0f, 50.0f, 0.01f, true, false, false, false, false );

						break;
					}

					case SUBMENU_ENTRY_AIMBOT::CURRENT:
					{
						AddSubSubBool ( "Aim", &g_Vars.Weapons[g_Info->GetWeaponID ( )].Aim, false, false, true, false, false );
						AddSubSubInt ( "BulletControl.Start", &g_Vars.Weapons[g_Info->GetWeaponID ( )].BulletControl[0], 1, 1000, 1, false, false, false, false, false );
						AddSubSubInt ( "BulletControl.End", &g_Vars.Weapons[g_Info->GetWeaponID ( )].BulletControl[1], 1, 1000, 1, false, false, false, false, false );
						AddSubSubInt ( "HitBox", &g_Vars.Weapons[g_Info->GetWeaponID ( )].HitBox, 0, 20, 1, false, false, false, false, false );
						AddSubSubBool ( "HitBox.Nearest", &g_Vars.Weapons[g_Info->GetWeaponID ( )].HitBoxNearest, false, false, true, false, false );
						AddSubSubFloat ( "Prediction", &g_Vars.Weapons[g_Info->GetWeaponID ( )].Prediction, 0.0f, 5.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "FOV", &g_Vars.Weapons[g_Info->GetWeaponID ( )].FOV, 0.0f, 90.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Smooth", &g_Vars.Weapons[g_Info->GetWeaponID ( )].Smooth, 1.0f, 50.0f, 0.01f, true, false, false, false, false );
						AddSubSubInt ( "Delay", &g_Vars.Weapons[g_Info->GetWeaponID ( )].Delay, 0, 1000, 1, false, false, false, false, false );
						AddSubSubInt ( "Delay.Type", &g_Vars.Weapons[g_Info->GetWeaponID ( )].DelayType, 1, 3, 1, false, false, false, false, false );
						AddSubSubFloat ( "Recoil", &g_Vars.Weapons[g_Info->GetWeaponID ( )].Recoil, 0.0f, 3.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Recoil.Prediction", &g_Vars.Weapons[g_Info->GetWeaponID ( )].RecoilPrediction, 0.0f, 5.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Recoil.FOV", &g_Vars.Weapons[g_Info->GetWeaponID ( )].RecoilFOV, 0.0f, 90.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Recoil.Smooth", &g_Vars.Weapons[g_Info->GetWeaponID ( )].RecoilSmooth, 0.0f, 50.0f, 0.01f, true, false, false, false, false );

						break;
					}

					case SUBMENU_ENTRY_AIMBOT::RECOIL:
					{
						AddSubSubBool ( "Enable", &g_Vars.Recoil.Enable, false, false, true, false, false );
						AddSubSubFloat ( "X", &g_Vars.Recoil.X, 0.0f, 3.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Y", &g_Vars.Recoil.Y, 0.0f, 3.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Smooth", &g_Vars.Recoil.Smooth, 1.0f, 50.0f, 0.01f, true, false, false, false, false );
						AddSubSubInt ( "BulletStart", &g_Vars.Recoil.BulletStart, 1, 1000, 1, false, false, false, false, false );

						break;
					}

					case SUBMENU_ENTRY_AIMBOT::AUTOPISTOL:
					{
						AddSubSubBool ( "Enable", &g_Vars.AutoPistol.Enable, false, false, true, false, false );
						AddSubSubInt ( "Delay", &g_Vars.AutoPistol.Delay, 0, 1000, 1, false, false, false, false, false );

						break;
					}

					case SUBMENU_ENTRY_AIMBOT::FASTZOOM:
					{
						AddSubSubBool ( "Enable", &g_Vars.FastZoom.Enable, false, false, true, false, false );
						AddSubSubInt ( "Delay", &g_Vars.FastZoom.Delay, 0, 1000, 1, false, false, false, false, false );
						AddSubSubBool ( "QuickSwitch", &g_Vars.FastZoom.QuickSwitch, false, false, true, false, false );

						break;
					}
					}

					break;
				}

				case MENU_ENTRY::TRIGGERBOT:
				{
					g_Vars.Functions.TriggerWeapons ?
						AddSubInt ( "Globals", 0, 0, 0, 0, false, true, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] ) :
						AddSubInt ( "Globals", 0, 0, 0, 0, false, true, false, false, true, false, 100, 100, 100 );

					g_Vars.Functions.TriggerWeapons ?
						AddSubInt ( "Pistols", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] ) :
						AddSubInt ( "Pistols", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );

					g_Vars.Functions.TriggerWeapons ?
						AddSubInt ( "Rifles", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] ) :
						AddSubInt ( "Rifles", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );

					g_Vars.Functions.TriggerWeapons ?
						AddSubInt ( "Snipers", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] ) :
						AddSubInt ( "Snipers", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );

					g_Vars.Functions.TriggerWeapons ?
						AddSubInt ( "Current", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] ) :
						AddSubInt ( "Current", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );

					switch ( S_EntryPos )
					{
					case SUBMENU_ENTRY_TRIGGERBOT::TGLOBALS:
					{
						AddSubSubBool ( "Enable", &g_Vars.Trigger.Enable, false, false, true, false, false );
						AddSubSubBool ( "FriendlyFire", &g_Vars.Trigger.FriendlyFire, false, false, true, false, false );
						AddSubSubBool ( "VisibleCheck", &g_Vars.Trigger.VisibleCheck, false, false, true, false, false );
						AddSubSubBool ( "Snipers.OnlyInZoom", &g_Vars.Trigger.SnipersOnlyInZoom, false, false, true, false, false );

						break;
					}

					case SUBMENU_ENTRY_TRIGGERBOT::TPISTOLS:
					{
						AddSubSubBool ( "Trigger", &g_Vars.TriggerWeapons[26].Trigger, false, false, true, false, false );
						AddSubSubBool ( "OnlyHead", &g_Vars.TriggerWeapons[26].OnlyHead, false, false, true, false, false );
						AddSubSubBool ( "ProSpread", &g_Vars.TriggerWeapons[26].ProSpread, false, false, true, false, false );

						break;
					}

					case SUBMENU_ENTRY_TRIGGERBOT::TRIFLES:
					{
						AddSubSubBool ( "Trigger", &g_Vars.TriggerWeapons[28].Trigger, false, false, true, false, false );
						AddSubSubBool ( "OnlyHead", &g_Vars.TriggerWeapons[28].OnlyHead, false, false, true, false, false );
						AddSubSubBool ( "ProSpread", &g_Vars.TriggerWeapons[28].ProSpread, false, false, true, false, false );

						break;
					}

					case SUBMENU_ENTRY_TRIGGERBOT::TSNIPERS:
					{
						AddSubSubBool ( "Trigger", &g_Vars.TriggerWeapons[18].Trigger, false, false, true, false, false );
						AddSubSubBool ( "OnlyHead", &g_Vars.TriggerWeapons[18].OnlyHead, false, false, true, false, false );
						AddSubSubBool ( "ProSpread", &g_Vars.TriggerWeapons[18].ProSpread, false, false, true, false, false );

						break;
					}

					case SUBMENU_ENTRY_TRIGGERBOT::TCURRENT:
					{
						AddSubSubBool ( "Trigger", &g_Vars.TriggerWeapons[g_Info->GetWeaponID ( )].Trigger, false, false, true, false, false );
						AddSubSubBool ( "OnlyHead", &g_Vars.TriggerWeapons[g_Info->GetWeaponID ( )].OnlyHead, false, false, true, false, false );
						AddSubSubBool ( "ProSpread", &g_Vars.TriggerWeapons[g_Info->GetWeaponID ( )].ProSpread, false, false, true, false, false );

						break;
					}
					}

					break;
				}

				case MENU_ENTRY::VISUALS:
				{
					AddSubInt ( "Menu", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] );

					g_Vars.Functions.ScreenInfo ?
						AddSubInt ( "ScreenInfo", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] ) :
						AddSubInt ( "ScreenInfo", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );

					if ( g_Vars.Functions.ESP )
					{
						AddSubInt ( "ESP", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] );
						AddSubInt ( "ESP Colors", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] );
					}
					else
					{
						AddSubInt ( "ESP", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );
						AddSubInt ( "ESP Colors", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );
					}

					if ( g_Vars.Functions.Chams )
					{
						AddSubInt ( "Chams", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] );
						AddSubInt ( "Chams Colors", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] );
					}
					else
					{
						AddSubInt ( "Chams", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );
						AddSubInt ( "Chams Colors", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );
					}

					g_Vars.Functions.NoFlash ?
						AddSubInt ( "NoFlash", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] ) :
						AddSubInt ( "NoFlash", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );

					g_Vars.Functions.Crosshair ?
						AddSubInt ( "Crosshair", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] ) :
						AddSubInt ( "Crosshair", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );

					AddSubInt ( "Other", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] );

					switch ( S_EntryPos )
					{
					case SUBMENU_ENTRY_VISUALS::MENU:
					{
						AddSubSubInt ( "Pos.x", &g_Vars.Menu.X, 1, SDK::Interfaces::g_Screen.iWidth, 1, false, false, false, false, false );
						AddSubSubInt ( "Pos.y", &g_Vars.Menu.Y, 1, SDK::Interfaces::g_Screen.iHeight, 1, false, false, false, false, false );
						AddSubSubInt ( "Box.Height", &g_Vars.Menu.BoxHeight, 15, 25, 1, false, false, false, false, false );
						AddSubSubInt ( "Box.Width", &g_Vars.Menu.BoxWidth, 170, 200, 1, false, true, false, false, false );
						AddSubSubInt ( "Box.Color.R", &g_Vars.Menu.BoxColor[0], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Box.Color.G", &g_Vars.Menu.BoxColor[1], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Box.Color.B", &g_Vars.Menu.BoxColor[2], 0, 255, 1, false, true, false, false, false );
						AddSubSubInt ( "Box.Outline.Color.R", &g_Vars.Menu.BoxOutlineColor[0], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Box.Outline.Color.G", &g_Vars.Menu.BoxOutlineColor[1], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Box.Outline.Color.B", &g_Vars.Menu.BoxOutlineColor[2], 0, 255, 1, false, true, false, false, false );
						AddSubSubInt ( "Box.Select.Color.R", &g_Vars.Menu.BoxSelectColor[0], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Box.Select.Color.G", &g_Vars.Menu.BoxSelectColor[1], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Box.Select.Color.B", &g_Vars.Menu.BoxSelectColor[2], 0, 255, 1, false, true, false, false, false );
						AddSubSubInt ( "Text.Color.R", &g_Vars.Menu.TextColor[0], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Text.Color.G", &g_Vars.Menu.TextColor[1], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Text.Color.B", &g_Vars.Menu.TextColor[2], 0, 255, 1, false, true, false, false, false );

						break;
					}

					case SUBMENU_ENTRY_VISUALS::SCREENINFO:
					{
						AddSubSubBool ( "Enable", &g_Vars.ScreenInfo.Enable, false, false, true, false, false );
						AddSubSubInt ( "FPS", &g_Vars.ScreenInfo.FPS, 0, 2, 1, false, false, false, false, false );
						AddSubSubInt ( "Copyright", &g_Vars.ScreenInfo.Copyright, 0, 2, 1, false, false, false, false, false );
						AddSubSubInt ( "Time", &g_Vars.ScreenInfo.Time, 0, 2, 1, false, false, false, false, false );
						AddSubSubInt ( "ShowKeys", &g_Vars.ScreenInfo.ShowKeys, 0, 2, 1, false, false, false, false, false );
						AddSubSubInt ( "KreedzInfo", &g_Vars.ScreenInfo.KreedzInfo, 0, 2, 1, false, true, false, false, false );
						AddSubSubInt ( "Font.Color.R", &g_Vars.ScreenInfo.FontColor[0], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Font.Color.G", &g_Vars.ScreenInfo.FontColor[1], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Font.Color.B", &g_Vars.ScreenInfo.FontColor[2], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Font.Color.A", &g_Vars.ScreenInfo.FontColor[3], 0, 255, 1, false, false, false, false, false );
						AddSubSubBool ( "Font.Outline", &g_Vars.ScreenInfo.FontOutline, false, false, true, false, false );

						break;
					}

					case SUBMENU_ENTRY_VISUALS::ESP:
					{
						AddSubSubBool ( "Enable", &g_Vars.ESP.Enable, false, true, true, false, false );
						AddSubSubInt ( "Player", &g_Vars.ESP.Player, 0, 2, 1, false, false, false, false, false );
						AddSubSubBool ( "Player.VisibleOnly", &g_Vars.ESP.PlayerVisibleOnly, false, false, true, false, false );
						AddSubSubInt ( "Player.Box", &g_Vars.ESP.PlayerBox, 0, 4, 1, false, false, false, false, false );
						AddSubSubInt ( "Player.Box.Filled", &g_Vars.ESP.PlayerBoxFilled, 0, 255, 1, false, false, false, false, false );
						AddSubSubBool ( "Player.Name", &g_Vars.ESP.PlayerName, false, false, true, false, false );
						AddSubSubBool ( "Player.Weapon", &g_Vars.ESP.PlayerWeapon, false, false, true, false, false );
						AddSubSubInt ( "Player.Distance", &g_Vars.ESP.PlayerDistance, 0, 2, 1, false, false, false, false, false );
						AddSubSubBool ( "Player.Barrel", &g_Vars.ESP.PlayerBarrel, false, true, true, false, false );
						AddSubSubBool ( "World.C4", &g_Vars.ESP.WorldC4, false, false, true, false, false );
						AddSubSubBool ( "World.Items", &g_Vars.ESP.WorldItems, false, false, true, false, false );
						AddSubSubBool ( "World.Nades", &g_Vars.ESP.WorldNades, false, true, true, false, false );
						AddSubSubInt ( "C4Timer", &g_Vars.ESP.C4Timer, 0, 2, 1, false, false, false, false, false );
						AddSubSubInt ( "C4Timer.Value", &g_Vars.ESP.C4TimerValue, 0, 100, 1, false, true, false, false, false );
						AddSubSubBool ( "Sound", &g_Vars.ESP.Sound, false, false, true, false, false );
						AddSubSubInt ( "Sound.Distance", &g_Vars.ESP.SoundDistance, 0, 10000, 10, false, false, false, false, false );
						AddSubSubInt ( "Sound.FadeTime", &g_Vars.ESP.SoundFadeTime, 0, 5000, 10, false, false, false, false, false );

						break;
					}

					case SUBMENU_ENTRY_VISUALS::ESP_COLORS:
					{
						AddSubSubInt ( "Player.Box.T.Vis.R", &g_Vars.ESP.ColorTVis[0], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Player.Box.T.Vis.G", &g_Vars.ESP.ColorTVis[1], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Player.Box.T.Vis.B", &g_Vars.ESP.ColorTVis[2], 0, 255, 1, false, true, false, false, false );
						AddSubSubInt ( "Player.Box.T.Hide.R", &g_Vars.ESP.ColorTHide[0], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Player.Box.T.Hide.G", &g_Vars.ESP.ColorTHide[1], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Player.Box.T.Hide.B", &g_Vars.ESP.ColorTHide[2], 0, 255, 1, false, true, false, false, false );
						AddSubSubInt ( "Player.Box.CT.Vis.R", &g_Vars.ESP.ColorCTVis[0], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Player.Box.CT.Vis.G", &g_Vars.ESP.ColorCTVis[1], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Player.Box.CT.Vis.B", &g_Vars.ESP.ColorCTVis[2], 0, 255, 1, false, true, false, false, false );
						AddSubSubInt ( "Player.Box.CT.Hide.R", &g_Vars.ESP.ColorCTHide[0], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Player.Box.CT.Hide.G", &g_Vars.ESP.ColorCTHide[1], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Player.Box.CT.Hide.B", &g_Vars.ESP.ColorCTHide[2], 0, 255, 1, false, true, false, false, false );
						AddSubSubInt ( "Font.Color.R", &g_Vars.ESP.FontColor[0], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Font.Color.G", &g_Vars.ESP.FontColor[1], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Font.Color.B", &g_Vars.ESP.FontColor[2], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Font.Color.A", &g_Vars.ESP.FontColor[3], 0, 255, 1, false, false, false, false, false );

						break;
					}

					case SUBMENU_ENTRY_VISUALS::CHAMS:
					{
						AddSubSubBool ( "Enable", &g_Vars.Chams.Enable, false, true, true, false, false );
						AddSubSubInt ( "Player", &g_Vars.Chams.Player, 0, 2, 1, false, false, false, false, false );
						AddSubSubBool ( "Player.VisibleOnly", &g_Vars.Chams.PlayerVisibleOnly, false, false, true, false, false );
						AddSubSubInt ( "Player.RenderType", &g_Vars.Chams.PlayerRenderType, 1, 5, 1, false, true, false, false, false );
						AddSubSubBool ( "Weapon", &g_Vars.Chams.Weapon, false, false, true, false, false );
						AddSubSubBool ( "Weapon.VisibleOnly", &g_Vars.Chams.WeaponVisibleOnly, false, false, true, false, false );
						AddSubSubInt ( "Weapon.RenderType", &g_Vars.Chams.WeaponRenderType, 1, 5, 1, false, true, false, false, false );
						AddSubSubBool ( "Hands", &g_Vars.Chams.Hands, false, false, true, false, false );
						AddSubSubInt ( "Hands.RenderType", &g_Vars.Chams.HandsRenderType, 1, 5, 1, false, false, false, false, false );

						break;
					}

					case SUBMENU_ENTRY_VISUALS::CHAMS_COLORS:
					{
						AddSubSubInt ( "Chams.T.Vis.R", &g_Vars.Chams.ColorTVis[0], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Chams.T.Vis.G", &g_Vars.Chams.ColorTVis[1], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Chams.T.Vis.B", &g_Vars.Chams.ColorTVis[2], 0, 255, 1, false, true, false, false, false );
						AddSubSubInt ( "Chams.T.Hide.R", &g_Vars.Chams.ColorTHide[0], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Chams.T.Hide.G", &g_Vars.Chams.ColorTHide[1], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Chams.T.Hide.B", &g_Vars.Chams.ColorTHide[2], 0, 255, 1, false, true, false, false, false );
						AddSubSubInt ( "Chams.CT.Vis.R", &g_Vars.Chams.ColorCTVis[0], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Chams.CT.Vis.G", &g_Vars.Chams.ColorCTVis[1], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Chams.CT.Vis.B", &g_Vars.Chams.ColorCTVis[2], 0, 255, 1, false, true, false, false, false );
						AddSubSubInt ( "Chams.CT.Hide.R", &g_Vars.Chams.ColorCTHide[0], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Chams.CT.Hide.G", &g_Vars.Chams.ColorCTHide[1], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Chams.CT.Hide.B", &g_Vars.Chams.ColorCTHide[2], 0, 255, 1, false, true, false, false, false );
						AddSubSubInt ( "Chams.Weapon.Vis.R", &g_Vars.Chams.WeaponColorVis[0], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Chams.Weapon.Vis.G", &g_Vars.Chams.WeaponColorVis[1], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Chams.Weapon.Vis.B", &g_Vars.Chams.WeaponColorVis[2], 0, 255, 1, false, true, false, false, false );
						AddSubSubInt ( "Chams.Weapon.Hide.R", &g_Vars.Chams.WeaponColorHide[0], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Chams.Weapon.Hide.G", &g_Vars.Chams.WeaponColorHide[1], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Chams.Weapon.Hide.B", &g_Vars.Chams.WeaponColorHide[2], 0, 255, 1, false, true, false, false, false );
						AddSubSubInt ( "Chams.Hands.R", &g_Vars.Chams.HandsColor[0], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Chams.Hands.G", &g_Vars.Chams.HandsColor[1], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Chams.Hands.B", &g_Vars.Chams.HandsColor[2], 0, 255, 1, false, false, false, false, false );

						break;
					}

					case SUBMENU_ENTRY_VISUALS::NOFLASH:
					{
						AddSubSubBool ( "Enable", &g_Vars.NoFlash.Enable, false, false, true, false, false );
						AddSubSubInt ( "Fade.Limit", &g_Vars.NoFlash.FadeLimit, 0, 255, 1, false, true, false, false, false );
						AddSubSubBool ( "Fade.Color.Enable", &g_Vars.NoFlash.FadeColorEnable, false, false, true, false, false );
						AddSubSubInt ( "Fade.Color.R", &g_Vars.NoFlash.FadeColor[0], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Fade.Color.G", &g_Vars.NoFlash.FadeColor[1], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Fade.Color.B", &g_Vars.NoFlash.FadeColor[2], 0, 255, 1, false, false, false, false, false );
						AddSubSubBool ( "Fade.Color.Random", &g_Vars.NoFlash.FadeColorRandom, false, true, true, false, false );
						AddSubSubInt ( "DrawFlashed", &g_Vars.NoFlash.DrawFlashed, 0, 2, 1, false, false, false, false, false );
						AddSubSubBool ( "Font.Outline", &g_Vars.NoFlash.FontOutline, false, false, true, false, false );

						break;
					}

					case SUBMENU_ENTRY_VISUALS::CROSSHAIR:
					{
						AddSubSubBool ( "Enable", &g_Vars.Crosshair.Enable, false, false, true, false, false );
						AddSubSubBool ( "Dot", &g_Vars.Crosshair.Dot, false, false, true, false, false );
						AddSubSubInt ( "Size", &g_Vars.Crosshair.Size, 0, 50, 1, false, false, false, false, false );
						AddSubSubInt ( "Gap", &g_Vars.Crosshair.Gap, 0, 50, 1, false, false, false, false, false );
						AddSubSubInt ( "Thickness", &g_Vars.Crosshair.Thickness, 1, 3, 1, false, false, false, false, false );
						AddSubSubInt ( "Size", &g_Vars.Crosshair.Size, 0, 50, 1, false, false, false, false, false );
						AddSubSubBool ( "Dynamic", &g_Vars.Crosshair.Dynamic, false, false, true, false, false );
						AddSubSubFloat ( "Dynamic.Scale", &g_Vars.Crosshair.DynamicScale, 0.0f, 10.0f, 0.01f, true, false, false, false, false );
						AddSubSubBool ( "Outline", &g_Vars.Crosshair.Outline, false, false, true, false, false );
						AddSubSubBool ( "Snipers", &g_Vars.Crosshair.Snipers, false, true, true, false, false );
						AddSubSubInt ( "Color.R", &g_Vars.Crosshair.Color[0], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Color.G", &g_Vars.Crosshair.Color[1], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Color.B", &g_Vars.Crosshair.Color[2], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "Color.A", &g_Vars.Crosshair.Color[3], 0, 255, 1, false, false, false, false, false );

						break;
					}

					case SUBMENU_ENTRY_VISUALS::OTHER:
					{
						if ( g_Vars.Functions.Weapons )
						{
							AddSubSubBool ( "Draw.Aim.Spot", &g_Vars.Other.DrawAimSpot, false, false, true, false, false );
							AddSubSubBool ( "Draw.Aim.FOV", &g_Vars.Other.DrawAimFOV, false, false, true, false, false );
						}

						AddSubSubBool ( "Draw.Punch", &g_Vars.Other.DrawPunch, false, false, true, false, false );
						AddSubSubBool ( "Draw.Spread", &g_Vars.Other.DrawSpread, false, false, true, false, false );

						if ( g_Vars.Functions.Weapons )
							AddSubSubBool ( "Status.AimBot", &g_Vars.Other.StatusAimBot, false, false, true, false, false );

						if ( g_Vars.Functions.TriggerWeapons )
							AddSubSubBool ( "Status.TriggerBot", &g_Vars.Other.StatusTriggerBot, false, false, true, false, false );

						AddSubSubBool ( "Remove.Smoke", &g_Vars.Other.RemoveSmoke, false, true, true, false, false );
						AddSubSubInt ( "FontColor.R", &g_Vars.Other.FontColor[0], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "FontColor.G", &g_Vars.Other.FontColor[1], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "FontColor.B", &g_Vars.Other.FontColor[2], 0, 255, 1, false, false, false, false, false );
						AddSubSubInt ( "FontColor.A", &g_Vars.Other.FontColor[3], 0, 255, 1, false, false, false, false, false );
						AddSubSubBool ( "Font.Outline", &g_Vars.Other.FontOutline, false, false, true, false, false );

						break;
					}
					}

					break;
				}

				case MENU_ENTRY::MISC:
				{
					g_Vars.Functions.Speed ?
						AddSubInt ( "Speed", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] ) :
						AddSubInt ( "Speed", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );

					g_Vars.Functions.BunnyHop ?
						AddSubInt ( "BunnyHop", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] ) :
						AddSubInt ( "BunnyHop", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );

					g_Vars.Functions.GroundStrafe ?
						AddSubInt ( "GroundStrafe", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] ) :
						AddSubInt ( "GroundStrafe", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );

					switch ( S_EntryPos )
					{
					case SUBMENU_ENTRY_MISC::SPEED:
					{
						AddSubSubFloat ( "Player", &g_Vars.Speed.Player, 0.0f, 100.0f, 0.01f, true, false, false, false, false );
						AddSubSubInt ( "Engine", &g_Vars.Speed.Engine, -255, 255, 1, false, false, false, false, false );
						AddSubSubFloat ( "Boost", &g_Vars.Speed.Boost, 1.1f, 100.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Slowmotion", &g_Vars.Speed.Slowmo, 0.0f, 0.9f, 0.01f, true, true, false, false, false );
						AddSubSubBool ( "Helper", &g_Vars.Speed.Helper, false, false, true, false, false );
						AddSubSubFloat ( "Helper.Ground", &g_Vars.Speed.HelperGround, 0.0f, 100.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Helper.Ladder", &g_Vars.Speed.HelperLadder, 0.0f, 100.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Helper.Fly", &g_Vars.Speed.HelperFly, 0.0f, 100.0f, 0.01f, true, false, false, false, false );

						break;
					}

					case SUBMENU_ENTRY_MISC::BUNNYHOP:
					{
						AddSubSubBool ( "NoSlowdown", &g_Vars.BunnyHop.NoSlowdown, false, false, true, false, false );
						AddSubSubBool ( "Scroll.Emulation", &g_Vars.BunnyHop.ScrollEmulation, false, false, true, false, false );
						AddSubSubInt ( "Scroll.Direction", &g_Vars.BunnyHop.ScrollDirection, DOWN, UP, 1, false, false, false, false, false );
						AddSubSubFloat ( "Scroll.Distance.Min", &g_Vars.BunnyHop.ScrollDistance[0], 0.0f, 50.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Scroll.Distance.Max", &g_Vars.BunnyHop.ScrollDistance[1], 0.0f, 50.0f, 0.01f, true, false, false, false, false );
						AddSubSubBool ( "Scroll.RandFails", &g_Vars.BunnyHop.ScrollRandFails, false, false, true, false, false );
						AddSubSubBool ( "OnLadder", &g_Vars.BunnyHop.OnLadder, false, true, true, false, false );
						AddSubSubBool ( "Helper", &g_Vars.BunnyHop.Helper, false, false, true, false, false );
						AddSubSubBool ( "Helper.NoSlowdown", &g_Vars.BunnyHop.HelperNoSlowdown, false, false, true, false, false );
						AddSubSubInt ( "Helper.IdealPercent", &g_Vars.BunnyHop.HelperIdealPercent, 0, 100, 1, false, true, false, false, false );
						AddSubSubBool ( "StandUp.Auto", &g_Vars.BunnyHop.StandUpAuto, false, false, true, false, false );
						AddSubSubInt ( "StandUp.FallVelocity", &g_Vars.BunnyHop.StandUpFallVelocity, 0, 250, 1, false, false, false, false, false );

						if ( g_Vars.BunnyHop.ScrollDistance[0] > g_Vars.BunnyHop.ScrollDistance[1] )
							g_Vars.BunnyHop.ScrollDistance[0] = g_Vars.BunnyHop.ScrollDistance[1];

						if ( g_Vars.BunnyHop.ScrollDistance[1] < g_Vars.BunnyHop.ScrollDistance[0] )
							g_Vars.BunnyHop.ScrollDistance[1] = g_Vars.BunnyHop.ScrollDistance[0];

						break;
					}

					case SUBMENU_ENTRY_MISC::GROUNDSTRAFE:
					{
						AddSubSubBool ( "Scroll.Emulation", &g_Vars.GroundStrafe.ScrollEmulation, false, false, true, false, false );
						AddSubSubInt ( "Scroll.Direction", &g_Vars.GroundStrafe.ScrollDirection, DOWN, UP, 1, false, false, false, false, false );
						AddSubSubFloat ( "Scroll.Distance.Min", &g_Vars.GroundStrafe.ScrollDistance[0], 0.0f, 50.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Scroll.Distance.Max", &g_Vars.GroundStrafe.ScrollDistance[1], 0.0f, 50.0f, 0.01f, true, false, false, false, false );
						AddSubSubInt ( "Scroll.Count.Min", &g_Vars.GroundStrafe.ScrollCount[0], 1, 50, 1, false, false, false, false, false );
						AddSubSubInt ( "Scroll.Count.Max", &g_Vars.GroundStrafe.ScrollCount[1], 1, 50, 1, false, false, false, false, false );
						AddSubSubFloat ( "Slowdown.Scale", &g_Vars.GroundStrafe.SlowdownScale, 0.0f, 2.0f, 0.01f, true, false, false, false, false );
						AddSubSubFloat ( "Slowdown.Angle", &g_Vars.GroundStrafe.SlowdownAngle, 0.0f, 45.0f, 0.01f, true, false, false, false, false );
						AddSubSubBool ( "FallRun", &g_Vars.GroundStrafe.FallRun, false, true, true, false, false );
						AddSubSubBool ( "Helper", &g_Vars.GroundStrafe.Helper, false, true, true, false, false );
						AddSubSubInt ( "StandUp.FallVelocity", &g_Vars.GroundStrafe.StandUpFallVelocity, 0, 250, 1, false, false, false, false, false );

						if ( g_Vars.GroundStrafe.ScrollDistance[0] > g_Vars.GroundStrafe.ScrollDistance[1] )
							g_Vars.GroundStrafe.ScrollDistance[0] = g_Vars.GroundStrafe.ScrollDistance[1];

						if ( g_Vars.GroundStrafe.ScrollDistance[1] < g_Vars.GroundStrafe.ScrollDistance[0] )
							g_Vars.GroundStrafe.ScrollDistance[1] = g_Vars.GroundStrafe.ScrollDistance[0];

						if ( g_Vars.GroundStrafe.ScrollCount[0] > g_Vars.GroundStrafe.ScrollCount[1] )
							g_Vars.GroundStrafe.ScrollCount[0] = g_Vars.GroundStrafe.ScrollCount[1];

						if ( g_Vars.GroundStrafe.ScrollCount[1] < g_Vars.GroundStrafe.ScrollCount[0] )
							g_Vars.GroundStrafe.ScrollCount[1] = g_Vars.GroundStrafe.ScrollCount[0];

						break;
					}
					}

					break;
				}

				case MENU_ENTRY::KEYS:
				{
					AddSubInt ( "Main", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] );
					AddSubInt ( "Panic", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] );

					g_Vars.Functions.TriggerWeapons ?
						AddSubInt ( "TriggerBot", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] ) :
						AddSubInt ( "TriggerBot", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );

					g_Vars.Functions.Speed ?
						AddSubInt ( "Speed", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] ) :
						AddSubInt ( "Speed", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );

					g_Vars.Functions.BunnyHop ?
						AddSubInt ( "BunnyHop", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] ) :
						AddSubInt ( "BunnyHop", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );

					g_Vars.Functions.GroundStrafe ?
						AddSubInt ( "GroundStrafe", 0, 0, 0, 0, false, false, false, true, true, false, TextColor[0], TextColor[1], TextColor[2] ) :
						AddSubInt ( "GroundStrafe", 0, 0, 0, 0, false, false, false, false, true, false, 100, 100, 100 );

					switch ( S_EntryPos )
					{
					case SUBMENU_ENTRY_KEYS::KMAIN:
						AddSubSubKey ( "ASS.Key", &g_Vars.Main.AntiScreenKey, false, true, false, false, true );
						AddSubSubKey ( "Reload.Key", &g_Vars.Main.ReloadKey, false, false, false, false, true );
						AddSubSubKey ( "Save.Key", &g_Vars.Main.SaveKey, false, false, false, false, true );
						AddSubSubKey ( "Menu.Key", &g_Vars.Menu.Key, false, false, false, false, true );

						break;

					case SUBMENU_ENTRY_KEYS::KPANICS:
						AddSubSubKey ( "Key", &g_Vars.Main.PanicKey, false, false, false, false, true );
						AddSubSubKey ( "AimBot.Key", &g_Vars.Main.PanicAimBotKey, false, false, false, false, true );
						AddSubSubKey ( "Visuals.Key", &g_Vars.Main.PanicVisualsKey, false, false, false, false, true );
						AddSubSubKey ( "Misc.Key", &g_Vars.Main.PanicMiscKey, false, false, false, false, true );

						break;

					case SUBMENU_ENTRY_KEYS::KTRIGGERBOT:
						AddSubSubKey ( "Key", &g_Vars.Trigger.Key, false, false, false, false, true );
						AddSubSubKey ( "Switch.Key", &g_Vars.Trigger.SwitchKey, false, false, false, false, true );

						break;

					case SUBMENU_ENTRY_KEYS::KSPEED:
						AddSubSubKey ( "Boost.Key", &g_Vars.Speed.BoostKey, false, false, false, false, true );
						AddSubSubKey ( "Slowmo.Key", &g_Vars.Speed.SlowmoKey, false, false, false, false, true );

						break;

					case SUBMENU_ENTRY_KEYS::KBUNNYHOP:
						AddSubSubKey ( "Key", &g_Vars.BunnyHop.Key, false, false, false, false, true );
						AddSubSubKey ( "StandUp.Key", &g_Vars.BunnyHop.StandUpKey, false, false, false, false, true );

						break;

					case SUBMENU_ENTRY_KEYS::KGROUNDSTRAFE:
						AddSubSubKey ( "Key", &g_Vars.GroundStrafe.Key, false, false, false, false, true );
						AddSubSubKey ( "StandUp.Key", &g_Vars.GroundStrafe.StandUpKey, false, false, false, false, true );

						break;
					}

					break;
				}
				}
			}

			void Menu::DrawFadeAnimation ( )
			{
				if ( VisibleAnimation )
				{
					++flVisibleAnimationTimer;

					if ( flVisibleAnimationTimer <= 28.0f )
					{
						BYTE Alpha = ( BYTE )Utils::Interp ( 1.0f, flVisibleAnimationTimer, 28.0f, Visible ? 0.0f : 120.0f, Visible ? 120.0f : 0.0f );

						Renderer::g_Drawing->FillArea ( 0, 0, SDK::Interfaces::g_Screen.iWidth, SDK::Interfaces::g_Screen.iHeight, 0, 0, 0, Alpha );
					}
					else
					{
						Renderer::g_Drawing->FillArea ( 0, 0, SDK::Interfaces::g_Screen.iWidth, SDK::Interfaces::g_Screen.iHeight, 0, 0, 0, Visible ? 120 : 0 );

						flVisibleAnimationTimer = 0.0f;

						VisibleAnimation = false;
					}
				}
				else
				{
					if ( Visible )
					{
						Renderer::g_Drawing->FillArea ( 0, 0, SDK::Interfaces::g_Screen.iWidth, SDK::Interfaces::g_Screen.iHeight, 0, 0, 0, 120 );
					}
				}
			}

			void Menu::DrawMenu ( int x, int y )
			{
				if ( !Visible )
				{
					Utils::native_memset ( SubSubmEntry, sizeof ( SubSubmEntry ), 0 );
					Utils::native_memset ( SubmEntry, sizeof ( SubmEntry ), 0 );
					Utils::native_memset ( MenuEntry, sizeof ( MenuEntry ), 0 );

					return;
				}

				Initialize ( );

				Renderer::g_Drawing->Box ( x, y, BoxWidth, BoxHeight, 1, BoxOutlineColor[0], BoxOutlineColor[1], BoxOutlineColor[2], BoxOutlineColor[3] );

				int HeadY = y;
				int HeadBoxWidth = BoxWidth - 2;
				int HeadBoxHeight = BoxHeight - 2;
				int HeadMenuBoxX = x + 1;
				int HeadMenuBoxY = y + 1;

				Renderer::g_Drawing->FillArea ( HeadMenuBoxX, HeadMenuBoxY, HeadBoxWidth, HeadBoxHeight, BoxColor[0], BoxColor[1], BoxColor[2], BoxColor[3] );

				int HeadMenuTextX = HeadMenuBoxX + int ( HeadBoxWidth / 2.0f );
				int HeadMenuTextY = HeadMenuBoxY + int ( HeadBoxHeight / 2.0f ) + 4;

				Renderer::g_Verdana->Print ( HeadMenuTextX, HeadMenuTextY, TextColor[0],
					TextColor[1], TextColor[2], 255, FL_OUTLINE | FL_CENTER, "Hpp Hack v3.3 Release" );

				y += BoxHeight + 2;

				int MenuBoxX = x + 1;
				int MenuTextX = MenuBoxX + 6;
				int MenuBoxY = 0;
				int MenuTextY = 0;

				for ( int i = 0; i < M_EntrySize; ++i )
				{
					MenuBoxY = y + 1;
					MenuTextY = MenuBoxY + int ( HeadBoxHeight / 2.0f ) + 4;

					Renderer::g_Drawing->Box ( x, y, BoxWidth, BoxHeight, 1, BoxOutlineColor[0], BoxOutlineColor[1], BoxOutlineColor[2], BoxOutlineColor[3] );
					Renderer::g_Drawing->FillArea ( MenuBoxX, MenuBoxY, HeadBoxWidth, HeadBoxHeight, BoxColor[0], BoxColor[1], BoxColor[2], BoxColor[3] );

					if ( i == M_EntryPos )
					{
						if ( !SubMenu )
						{
							Renderer::g_Drawing->FillArea ( MenuBoxX, MenuBoxY, HeadBoxWidth, HeadBoxHeight,
								BoxSelectColor[0], BoxSelectColor[1], BoxSelectColor[2], BoxSelectColor[3] );
						}

						Renderer::g_Drawing->FillArea ( MenuBoxX, MenuBoxY, 2, HeadBoxHeight, BoxSelectColor[0], BoxSelectColor[1], BoxSelectColor[2], 200 );
					}

					for ( int a = 0; a < MAX_NAME_CHAR; ++a )
					{
						MenuEntry[i].Name[a] ^= MENU_ENTRY_KEY;
					}

					Renderer::g_Verdana->Print ( MenuTextX, MenuTextY, TextColor[0], TextColor[1], TextColor[2], 255, FL_OUTLINE, MenuEntry[i].Name );

					y += BoxHeight + 1;

					if ( MenuEntry[i].Space )
					{
						y += BoxHeight + 1;
					}
				}

				x += BoxWidth + 1;

				int HeadSubMenuBoxX = x + 1;
				int HeadSubMenuBoxY = y + 1;

				if ( SubMenu )
				{
					int SubMenuBoxOutlineY = HeadY + BoxHeight + 2;
					int SubMenuBoxX = x + 1;
					int SubMenuBoxY = SubMenuBoxOutlineY + 1;
					int SubMenuTextX = SubMenuBoxX + 6;
					int SubMenuTextY = SubMenuBoxY + int ( HeadBoxHeight / 2.0f ) + 4;

					for ( int i = 0; i < S_EntrySize; ++i )
					{
						Renderer::g_Drawing->Box ( x, SubMenuBoxOutlineY, BoxWidth, BoxHeight, 1,
							BoxOutlineColor[0], BoxOutlineColor[1], BoxOutlineColor[2], BoxOutlineColor[3] );

						Renderer::g_Drawing->FillArea ( SubMenuBoxX, SubMenuBoxY, HeadBoxWidth, HeadBoxHeight,
							BoxColor[0], BoxColor[1], BoxColor[2], BoxColor[3] );

						if ( i == S_EntryPos )
						{
							if ( !SubSubMenu )
								Renderer::g_Drawing->FillArea ( SubMenuBoxX, SubMenuBoxY, HeadBoxWidth,
									HeadBoxHeight, BoxSelectColor[0], BoxSelectColor[1], BoxSelectColor[2], BoxSelectColor[3] );

							Renderer::g_Drawing->FillArea ( SubMenuBoxX, SubMenuBoxY, 2, HeadBoxHeight,
								BoxSelectColor[0], BoxSelectColor[1], BoxSelectColor[2], 200 );
						}

						for ( int a = 0; a < MAX_NAME_CHAR; ++a )
						{
							SubmEntry[i].Name[a] ^= SUBM_ENTRY_KEY;
						}

						Renderer::g_Verdana->Print ( SubMenuTextX, SubMenuTextY, SubmEntry[i].Color[0],
							SubmEntry[i].Color[1], SubmEntry[i].Color[2], 255, FL_OUTLINE, SubmEntry[i].Name );

						if ( !SubmEntry[i].Sub )
						{
							if ( SubmEntry[i].Auto )
							{
								if ( !SubmEntry[i].Float )
								{
									if ( !SubmEntry[i].iMin )
									{
										if ( *SubmEntry[i].iValue == SubmEntry[i].iMin )
										{
											Renderer::g_Verdana->Print ( SubMenuTextX + ( BoxWidth - 42 ),
												SubMenuTextY, 255, 80, 80, 255, FL_OUTLINE, "off" );
										}
										else if ( *SubmEntry[i].iValue == SubmEntry[i].iMax )
										{
											Renderer::g_Verdana->Print ( SubMenuTextX + ( BoxWidth - 42 ),
												SubMenuTextY, 80, 255, 80, 255, FL_OUTLINE, "auto" );
										}
										else
										{
											Renderer::g_Verdana->Print ( SubMenuTextX + ( BoxWidth - 42 ),
												SubMenuTextY, 80, 255, 80, 255, FL_OUTLINE, "%d", *SubmEntry[i].iValue );
										}
									}
									else
									{
										if ( *SubmEntry[i].iValue == SubmEntry[i].iMax )
										{
											Renderer::g_Verdana->Print ( SubMenuTextX + ( BoxWidth - 42 ),
												SubMenuTextY, 80, 255, 80, 255, FL_OUTLINE, "auto" );
										}
										else
										{
											Renderer::g_Verdana->Print ( SubMenuTextX + ( BoxWidth - 42 ),
												SubMenuTextY, 80, 255, 80, 255, FL_OUTLINE, "%d", *SubmEntry[i].iValue );
										}
									}
								}
							}
							else
							{
								if ( SubmEntry[i].Float )
								{
									Renderer::g_Verdana->Print ( SubMenuTextX + ( BoxWidth - 42 ), SubMenuTextY,
										255, 255, 255, 255, FL_OUTLINE, "%.2f", *SubmEntry[i].flValue );
								}
								else
								{
									if ( SubmEntry[i].Switch )
									{
										*SubmEntry[i].iValue ?
											Renderer::g_Verdana->Print ( SubMenuTextX + ( BoxWidth - 42 ),
												SubMenuTextY, 80, 255, 80, 255, FL_OUTLINE, "on", *SubmEntry[i].iValue ) :

											Renderer::g_Verdana->Print ( SubMenuTextX + ( BoxWidth - 42 ),
												SubMenuTextY, 255, 80, 80, 255, FL_OUTLINE, "off" );
									}
									else
									{
										if ( !SubmEntry[i].iMin && ( SubmEntry[i].iMax == 2 || SubmEntry[i].iMax == 4 ) )
										{
											*SubmEntry[i].iValue ?
												Renderer::g_Verdana->Print ( SubMenuTextX + ( BoxWidth - 42 ),
													SubMenuTextY, 80, 255, 80, 255, FL_OUTLINE, "%d", *SubmEntry[i].iValue ) :

												Renderer::g_Verdana->Print ( SubMenuTextX + ( BoxWidth - 42 ),
													SubMenuTextY, 255, 80, 80, 255, FL_OUTLINE, "off" );
										}
										else if ( SubmEntry[i].iMin == ENGLISH && SubmEntry[i].iMax == RUSSIAN )
										{
											if ( *SubmEntry[i].iValue == ENGLISH )
											{
												Renderer::g_Verdana->Print ( SubMenuTextX + ( BoxWidth - 60 ),
													SubMenuTextY, 255, 255, 255, 255, FL_OUTLINE, "english" );
											}
											else if ( *SubmEntry[i].iValue == RUSSIAN )
											{
												Renderer::g_Verdana->Print ( SubMenuTextX + ( BoxWidth - 60 ),
													SubMenuTextY, 255, 255, 255, 255, FL_OUTLINE, "russian" );
											}
										}
										else
										{
											Renderer::g_Verdana->Print ( SubMenuTextX + ( BoxWidth - 42 ), SubMenuTextY,
												255, 255, 255, 255, FL_OUTLINE, "%d", *SubmEntry[i].iValue );
										}
									}
								}
							}
						}

						SubMenuBoxOutlineY += BoxHeight + 1;
						SubMenuBoxY += BoxHeight + 1;
						SubMenuTextY += BoxHeight + 1;

						if ( SubmEntry[i].Space )
						{
							SubMenuBoxOutlineY += BoxHeight + 1;
							SubMenuBoxY += BoxHeight + 1;
							SubMenuTextY += BoxHeight + 1;
						}
					}
				}

				x += BoxWidth + 1;

				int HeadSubSubMenuBoxX = x + 1;
				int HeadSubSubSubMenuBoxY = y + 1;

				if ( SubSubMenu )
				{
					int SubSubMenuBoxOutlineY = HeadY + BoxHeight + 2;
					int SubSubMenuBoxX = x + 1;
					int SubSubMenuBoxY = SubSubMenuBoxOutlineY + 1;
					int SubSubMenuTextX = SubSubMenuBoxX + 6;
					int SubSubMenuTextY = SubSubMenuBoxY + int ( HeadBoxHeight / 2.0f ) + 4;

					for ( int i = 0; i < SS_EntrySize; ++i )
					{
						Renderer::g_Drawing->Box ( x, SubSubMenuBoxOutlineY, BoxWidth, BoxHeight, 1,
							BoxOutlineColor[0], BoxOutlineColor[1], BoxOutlineColor[2], BoxOutlineColor[3] );

						Renderer::g_Drawing->FillArea ( SubSubMenuBoxX, SubSubMenuBoxY, HeadBoxWidth,
							HeadBoxHeight, BoxColor[0], BoxColor[1], BoxColor[2], BoxColor[3] );

						if ( i == SS_EntryPos )
						{
							Renderer::g_Drawing->FillArea ( SubSubMenuBoxX, SubSubMenuBoxY, HeadBoxWidth,
								HeadBoxHeight, BoxSelectColor[0], BoxSelectColor[1], BoxSelectColor[2], BoxSelectColor[3] );

							Renderer::g_Drawing->FillArea ( SubSubMenuBoxX, SubSubMenuBoxY, 2, HeadBoxHeight,
								BoxSelectColor[0], BoxSelectColor[1], BoxSelectColor[2], 200 );

							if ( InputString )
							{
								if ( SubSubmEntry[SS_EntryPos].String )
								{
									Renderer::g_Drawing->FillArea ( SubSubMenuTextX + ( BoxWidth - 102 ),
										SubSubMenuTextY - 11, 92, 15, 0, 0, 0, 200 );
								}
								else
								{
									Renderer::g_Drawing->FillArea ( SubSubMenuTextX + ( BoxWidth - 42 ),
										SubSubMenuTextY - 11, 32, 15, 0, 0, 0, 200 );
								}
							}
						}

						for ( int a = 0; a < MAX_NAME_CHAR; ++a )
						{
							SubSubmEntry[i].Name[a] ^= SUBM_ENTRY_KEY;
						}

						Renderer::g_Verdana->Print ( SubSubMenuTextX, SubSubMenuTextY, TextColor[0],
							TextColor[1], TextColor[2], 255, FL_OUTLINE, SubSubmEntry[i].Name );

						if ( SubSubmEntry[i].String )
						{
							char* StringKey = Files::KeyToString ( *SubSubmEntry[i].kValue );

							if ( !InputString || i != SS_EntryPos )
							{
								Renderer::g_Verdana->Print ( SubSubMenuTextX + int ( ( BoxWidth - ( 42 + lstrlen ( StringKey ) * 4.2f ) ) ),
									SubSubMenuTextY, 255, 255, 255, 255, FL_OUTLINE, StringKey );
							}
							else
							{
								Renderer::g_Verdana->Print ( SubSubMenuTextX + ( BoxWidth - 100 ),
									SubSubMenuTextY, 255, 255, 255, 255, FL_OUTLINE, String );
							}
						}
						else
						{
							if ( SubSubmEntry[i].Auto )
							{
								if ( !SubSubmEntry[i].Float )
								{
									if ( !SubSubmEntry[i].iMin )
									{
										if ( *SubSubmEntry[i].iValue == SubSubmEntry[i].iMin )
										{
											Renderer::g_Verdana->Print ( SubSubMenuTextX + ( BoxWidth - 42 ),
												SubSubMenuTextY, 255, 80, 80, 255, FL_OUTLINE, "off" );
										}
										else if ( *SubSubmEntry[i].iValue == SubSubmEntry[i].iMax )
										{
											Renderer::g_Verdana->Print ( SubSubMenuTextX + ( BoxWidth - 42 ),
												SubSubMenuTextY, 80, 255, 80, 255, FL_OUTLINE, "auto" );
										}
										else
										{
											Renderer::g_Verdana->Print ( SubSubMenuTextX + ( BoxWidth - 42 ),
												SubSubMenuTextY, 80, 255, 80, 255, FL_OUTLINE, "%d", *SubSubmEntry[i].iValue );
										}
									}
									else
									{
										if ( *SubSubmEntry[i].iValue == SubSubmEntry[i].iMax )
										{
											Renderer::g_Verdana->Print ( SubSubMenuTextX + ( BoxWidth - 42 ),
												SubSubMenuTextY, 80, 255, 80, 255, FL_OUTLINE, "auto" );
										}
										else
										{
											Renderer::g_Verdana->Print ( SubSubMenuTextX + ( BoxWidth - 42 ),
												SubSubMenuTextY, 80, 255, 80, 255, FL_OUTLINE, "%d", *SubSubmEntry[i].iValue );
										}
									}
								}
							}
							else
							{
								if ( SubSubmEntry[i].Float )
								{
									if ( !InputString || i != SS_EntryPos )
									{
										Renderer::g_Verdana->Print ( SubSubMenuTextX + ( BoxWidth - 42 ), SubSubMenuTextY,
											255, 255, 255, 255, FL_OUTLINE, "%.2f", *SubSubmEntry[i].flValue );
									}
									else
									{
										Renderer::g_Verdana->Print ( SubSubMenuTextX + ( BoxWidth - 42 ), SubSubMenuTextY,
											255, 255, 255, 255, FL_OUTLINE, "%s", String );
									}
								}
								else
								{
									if ( SubSubmEntry[i].Switch )
									{
										*SubSubmEntry[i].bValue ?
											Renderer::g_Verdana->Print ( SubSubMenuTextX + ( BoxWidth - 42 ),
												SubSubMenuTextY, 80, 255, 80, 255, FL_OUTLINE, "on" ) :

											Renderer::g_Verdana->Print ( SubSubMenuTextX + ( BoxWidth - 42 ),
												SubSubMenuTextY, 255, 80, 80, 255, FL_OUTLINE, "off" );
									}
									else
									{
										if ( !SubSubmEntry[i].iMin && ( SubSubmEntry[i].iMax == 2 || SubSubmEntry[i].iMax == 4 ) )
										{
											*SubSubmEntry[i].iValue ?
												Renderer::g_Verdana->Print ( SubSubMenuTextX + ( BoxWidth - 42 ),
													SubSubMenuTextY, 80, 255, 80, 255, FL_OUTLINE, "%d", *SubSubmEntry[i].iValue ) :

												Renderer::g_Verdana->Print ( SubSubMenuTextX + ( BoxWidth - 42 ),
													SubSubMenuTextY, 255, 80, 80, 255, FL_OUTLINE, "off" );
										}
										else if ( SubSubmEntry[i].iMin == ENGLISH && SubSubmEntry[i].iMax == RUSSIAN )
										{
											if ( *SubSubmEntry[i].iValue == ENGLISH )
											{
												Renderer::g_Verdana->Print ( SubSubMenuTextX + ( BoxWidth - 60 ),
													SubSubMenuTextY, 255, 255, 255, 255, FL_OUTLINE, "english" );
											}
											else if ( *SubSubmEntry[i].iValue == RUSSIAN )
											{
												Renderer::g_Verdana->Print ( SubSubMenuTextX + ( BoxWidth - 60 ),
													SubSubMenuTextY, 255, 255, 255, 255, FL_OUTLINE, "russian" );
											}
										}
										else if ( SubSubmEntry[i].iMin == DOWN && SubSubmEntry[i].iMax == UP )
										{
											if ( *SubSubmEntry[i].iValue == DOWN )
											{
												Renderer::g_Verdana->Print ( SubSubMenuTextX + ( BoxWidth - 42 ),
													SubSubMenuTextY, 255, 255, 255, 255, FL_OUTLINE, "down" );
											}
											else if ( *SubSubmEntry[i].iValue == UP )
											{
												Renderer::g_Verdana->Print ( SubSubMenuTextX + ( BoxWidth - 42 ),
													SubSubMenuTextY, 255, 255, 255, 255, FL_OUTLINE, "up" );
											}
										}
										else
										{
											if ( !InputString || i != SS_EntryPos )
											{
												Renderer::g_Verdana->Print ( SubSubMenuTextX + ( BoxWidth - 42 ), SubSubMenuTextY,
													255, 255, 255, 255, FL_OUTLINE, "%d", *SubSubmEntry[i].iValue );
											}
											else
											{
												Renderer::g_Verdana->Print ( SubSubMenuTextX + ( BoxWidth - 42 ), SubSubMenuTextY,
													255, 255, 255, 255, FL_OUTLINE, String );
											}
										}
									}
								}
							}
						}

						SubSubMenuBoxOutlineY += BoxHeight + 1;
						SubSubMenuBoxY += BoxHeight + 1;
						SubSubMenuTextY += BoxHeight + 1;

						if ( SubSubmEntry[i].Space )
						{
							SubSubMenuBoxOutlineY += BoxHeight + 1;
							SubSubMenuBoxY += BoxHeight + 1;
							SubSubMenuTextY += BoxHeight + 1;
						}
					}
				}
			}

			void Menu::SetAimBotPistolsSettings ( )
			{
				BYTE PistolsList[] = { 1, 10, 11, 16, 17 };

				for ( int i = 0; i < sizeof ( PistolsList ); ++i )
				{
					g_Vars.Weapons[PistolsList[i]].Aim = g_Vars.Weapons[26].Aim;
					g_Vars.Weapons[PistolsList[i]].BulletControl[0] = g_Vars.Weapons[26].BulletControl[0];
					g_Vars.Weapons[PistolsList[i]].BulletControl[1] = g_Vars.Weapons[26].BulletControl[1];
					g_Vars.Weapons[PistolsList[i]].HitBoxNearest = g_Vars.Weapons[26].HitBoxNearest;
					g_Vars.Weapons[PistolsList[i]].HitBox = g_Vars.Weapons[26].HitBox;
					g_Vars.Weapons[PistolsList[i]].Prediction = g_Vars.Weapons[26].Prediction;
					g_Vars.Weapons[PistolsList[i]].FOV = g_Vars.Weapons[26].FOV;
					g_Vars.Weapons[PistolsList[i]].Smooth = g_Vars.Weapons[26].Smooth;
					g_Vars.Weapons[PistolsList[i]].Delay = g_Vars.Weapons[26].Delay;
					g_Vars.Weapons[PistolsList[i]].DelayType = g_Vars.Weapons[26].DelayType;
					g_Vars.Weapons[PistolsList[i]].Recoil = g_Vars.Weapons[26].Recoil;
					g_Vars.Weapons[PistolsList[i]].RecoilPrediction = g_Vars.Weapons[26].RecoilPrediction;
					g_Vars.Weapons[PistolsList[i]].RecoilFOV = g_Vars.Weapons[26].RecoilFOV;
					g_Vars.Weapons[PistolsList[i]].RecoilSmooth = g_Vars.Weapons[26].RecoilSmooth;
				}
			}

			void Menu::SetAimBotRiflesSettings ( )
			{
				BYTE RiflesList[] = { 7, 8, 12, 14, 15, 19, 20, 21, 22, 23, 27, 28, 30 };

				for ( int i = 0; i < sizeof ( RiflesList ); ++i )
				{
					g_Vars.Weapons[RiflesList[i]].Aim = g_Vars.Weapons[28].Aim;
					g_Vars.Weapons[RiflesList[i]].BulletControl[0] = g_Vars.Weapons[28].BulletControl[0];
					g_Vars.Weapons[RiflesList[i]].BulletControl[1] = g_Vars.Weapons[28].BulletControl[1];
					g_Vars.Weapons[RiflesList[i]].HitBoxNearest = g_Vars.Weapons[28].HitBoxNearest;
					g_Vars.Weapons[RiflesList[i]].HitBox = g_Vars.Weapons[28].HitBox;
					g_Vars.Weapons[RiflesList[i]].Prediction = g_Vars.Weapons[28].Prediction;
					g_Vars.Weapons[RiflesList[i]].FOV = g_Vars.Weapons[28].FOV;
					g_Vars.Weapons[RiflesList[i]].Smooth = g_Vars.Weapons[28].Smooth;
					g_Vars.Weapons[RiflesList[i]].Delay = g_Vars.Weapons[28].Delay;
					g_Vars.Weapons[RiflesList[i]].DelayType = g_Vars.Weapons[28].DelayType;
					g_Vars.Weapons[RiflesList[i]].Recoil = g_Vars.Weapons[28].Recoil;
					g_Vars.Weapons[RiflesList[i]].RecoilPrediction = g_Vars.Weapons[28].RecoilPrediction;
					g_Vars.Weapons[RiflesList[i]].RecoilFOV = g_Vars.Weapons[28].RecoilFOV;
					g_Vars.Weapons[RiflesList[i]].RecoilSmooth = g_Vars.Weapons[28].RecoilSmooth;
				}
			}

			void Menu::SetAimBotSnipersSettings ( )
			{
				BYTE SnipersList[] = { 3, 18, 24, 13 };

				for ( int i = 0; i < sizeof ( SnipersList ); ++i )
				{
					g_Vars.Weapons[SnipersList[i]].Aim = g_Vars.Weapons[18].Aim;
					g_Vars.Weapons[SnipersList[i]].BulletControl[0] = g_Vars.Weapons[18].BulletControl[0];
					g_Vars.Weapons[SnipersList[i]].BulletControl[1] = g_Vars.Weapons[18].BulletControl[1];
					g_Vars.Weapons[SnipersList[i]].HitBoxNearest = g_Vars.Weapons[18].HitBoxNearest;
					g_Vars.Weapons[SnipersList[i]].HitBox = g_Vars.Weapons[18].HitBox;
					g_Vars.Weapons[SnipersList[i]].Prediction = g_Vars.Weapons[18].Prediction;
					g_Vars.Weapons[SnipersList[i]].FOV = g_Vars.Weapons[18].FOV;
					g_Vars.Weapons[SnipersList[i]].Smooth = g_Vars.Weapons[18].Smooth;
					g_Vars.Weapons[SnipersList[i]].Delay = g_Vars.Weapons[18].Delay;
					g_Vars.Weapons[SnipersList[i]].DelayType = g_Vars.Weapons[18].DelayType;
					g_Vars.Weapons[SnipersList[i]].Recoil = g_Vars.Weapons[18].Recoil;
					g_Vars.Weapons[SnipersList[i]].RecoilPrediction = g_Vars.Weapons[18].RecoilPrediction;
					g_Vars.Weapons[SnipersList[i]].RecoilFOV = g_Vars.Weapons[18].RecoilFOV;
					g_Vars.Weapons[SnipersList[i]].RecoilSmooth = g_Vars.Weapons[18].RecoilSmooth;
				}
			}

			void Menu::SetTriggerBotPistolsSettings ( )
			{
				BYTE PistolsList[] = { 1, 10, 11, 16, 17 };

				for ( int i = 0; i < sizeof ( PistolsList ); ++i )
				{
					g_Vars.TriggerWeapons[PistolsList[i]].Trigger = g_Vars.TriggerWeapons[26].Trigger;
					g_Vars.TriggerWeapons[PistolsList[i]].OnlyHead = g_Vars.TriggerWeapons[26].OnlyHead;
					g_Vars.TriggerWeapons[PistolsList[i]].ProSpread = g_Vars.TriggerWeapons[26].ProSpread;
				}
			}

			void Menu::SetTriggerBotRiflesSettings ( )
			{
				BYTE RiflesList[] = { 7, 8, 12, 14, 15, 19, 20, 21, 22, 23, 27, 28, 30 };

				for ( int i = 0; i < sizeof ( RiflesList ); ++i )
				{
					g_Vars.TriggerWeapons[RiflesList[i]].Trigger = g_Vars.TriggerWeapons[28].Trigger;
					g_Vars.TriggerWeapons[RiflesList[i]].OnlyHead = g_Vars.TriggerWeapons[28].OnlyHead;
					g_Vars.TriggerWeapons[RiflesList[i]].ProSpread = g_Vars.TriggerWeapons[28].ProSpread;
				}
			}

			void Menu::SetTriggerBotSnipersSettings ( )
			{
				BYTE SnipersList[] = { 3, 18, 24, 13 };

				for ( int i = 0; i < sizeof ( SnipersList ); ++i )
				{
					g_Vars.TriggerWeapons[SnipersList[i]].Trigger = g_Vars.TriggerWeapons[18].Trigger;
					g_Vars.TriggerWeapons[SnipersList[i]].OnlyHead = g_Vars.TriggerWeapons[18].OnlyHead;
					g_Vars.TriggerWeapons[SnipersList[i]].ProSpread = g_Vars.TriggerWeapons[18].ProSpread;
				}
			}

			void Menu::Add ( const char* Name, bool Space, bool Function )
			{
				Utils::native_memset ( MenuEntry[M_EntrySize].Name, sizeof ( M_Entry::Name ), 0 );

				lstrcpy ( MenuEntry[M_EntrySize].Name, Name );

				for ( int i = 0; i < MAX_NAME_CHAR; ++i )
				{
					MenuEntry[M_EntrySize].Name[i] ^= MENU_ENTRY_KEY;
				}

				MenuEntry[M_EntrySize].Space = Space;
				MenuEntry[M_EntrySize].Function = Function;

				++M_EntrySize;
			}

			void Menu::AddSubFloat ( const char* Name, float* Value, float Min, float Max, float Step,
				bool Float, bool Space, bool Switch, bool Active, bool Sub, bool Auto, BYTE R, BYTE G, BYTE B )
			{
				Utils::native_memset ( SubmEntry[S_EntrySize].Name, sizeof ( S_Entry::Name ), 0 );

				lstrcpy ( SubmEntry[S_EntrySize].Name, Name );

				for ( int i = 0; i < MAX_NAME_CHAR; ++i )
				{
					SubmEntry[S_EntrySize].Name[i] ^= SUBM_ENTRY_KEY;
				}

				SubmEntry[S_EntrySize].flValue = Value;
				SubmEntry[S_EntrySize].flMin = Min;
				SubmEntry[S_EntrySize].flMax = Max;
				SubmEntry[S_EntrySize].flStep = Step;
				SubmEntry[S_EntrySize].Float = Float;
				SubmEntry[S_EntrySize].Space = Space;
				SubmEntry[S_EntrySize].Switch = Switch;
				SubmEntry[S_EntrySize].Active = Active;
				SubmEntry[S_EntrySize].Sub = Sub;
				SubmEntry[S_EntrySize].Auto = Auto;

				SubmEntry[S_EntrySize].Color[0] = R;
				SubmEntry[S_EntrySize].Color[1] = G;
				SubmEntry[S_EntrySize].Color[2] = B;

				++S_EntrySize;
			}

			void Menu::AddSubInt ( const char* Name, int* Value, int Min, int Max, int Step,
				bool Float, bool Space, bool Switch, bool Active, bool Sub, bool Auto, BYTE R, BYTE G, BYTE B )
			{
				Utils::native_memset ( SubmEntry[S_EntrySize].Name, sizeof ( S_Entry::Name ), 0 );

				lstrcpy ( SubmEntry[S_EntrySize].Name, Name );

				for ( int i = 0; i < MAX_NAME_CHAR; ++i )
				{
					SubmEntry[S_EntrySize].Name[i] ^= SUBM_ENTRY_KEY;
				}

				SubmEntry[S_EntrySize].iValue = Value;
				SubmEntry[S_EntrySize].iMin = Min;
				SubmEntry[S_EntrySize].iMax = Max;
				SubmEntry[S_EntrySize].iStep = Step;
				SubmEntry[S_EntrySize].Float = Float;
				SubmEntry[S_EntrySize].Space = Space;
				SubmEntry[S_EntrySize].Switch = Switch;
				SubmEntry[S_EntrySize].Active = Active;
				SubmEntry[S_EntrySize].Sub = Sub;
				SubmEntry[S_EntrySize].Auto = Auto;

				SubmEntry[S_EntrySize].Color[0] = R;
				SubmEntry[S_EntrySize].Color[1] = G;
				SubmEntry[S_EntrySize].Color[2] = B;

				++S_EntrySize;
			}

			void Menu::AddSubBool ( const char* Name, bool* Value, bool Float, bool Space,
				bool Switch, bool Active, bool Sub, bool Auto, BYTE R, BYTE G, BYTE B )
			{
				Utils::native_memset ( SubmEntry[S_EntrySize].Name, sizeof ( S_Entry::Name ), 0 );

				lstrcpy ( SubmEntry[S_EntrySize].Name, Name );

				for ( int i = 0; i < MAX_NAME_CHAR; ++i )
				{
					SubmEntry[S_EntrySize].Name[i] ^= SUBM_ENTRY_KEY;
				}

				SubmEntry[S_EntrySize].bValue = Value;
				SubmEntry[S_EntrySize].Float = Float;
				SubmEntry[S_EntrySize].Space = Space;
				SubmEntry[S_EntrySize].Switch = Switch;
				SubmEntry[S_EntrySize].Active = Active;
				SubmEntry[S_EntrySize].Sub = Sub;
				SubmEntry[S_EntrySize].Auto = Auto;

				SubmEntry[S_EntrySize].Color[0] = R;
				SubmEntry[S_EntrySize].Color[1] = G;
				SubmEntry[S_EntrySize].Color[2] = B;

				++S_EntrySize;
			}

			void Menu::AddSubSubFloat ( const char* Name, float* Value, float Min, float Max,
				float Step, bool Float, bool Space, bool Switch, bool Auto, bool String )
			{
				Utils::native_memset ( SubSubmEntry[SS_EntrySize].Name, sizeof ( SS_Entry::Name ), 0 );

				lstrcpy ( SubSubmEntry[SS_EntrySize].Name, Name );

				for ( int i = 0; i < MAX_NAME_CHAR; ++i )
				{
					SubSubmEntry[SS_EntrySize].Name[i] ^= SUBM_ENTRY_KEY;
				}

				SubSubmEntry[SS_EntrySize].flValue = Value;
				SubSubmEntry[SS_EntrySize].flMin = Min;
				SubSubmEntry[SS_EntrySize].flMax = Max;
				SubSubmEntry[SS_EntrySize].flStep = Step;
				SubSubmEntry[SS_EntrySize].Float = Float;
				SubSubmEntry[SS_EntrySize].Space = Space;
				SubSubmEntry[SS_EntrySize].Switch = Switch;
				SubSubmEntry[SS_EntrySize].Auto = Auto;
				SubSubmEntry[SS_EntrySize].String = String;

				++SS_EntrySize;
			}

			void Menu::AddSubSubInt ( const char* Name, int* Value, int Min, int Max,
				int Step, bool Float, bool Space, bool Switch, bool Auto, bool String )
			{
				Utils::native_memset ( SubSubmEntry[SS_EntrySize].Name, sizeof ( SS_Entry::Name ), 0 );

				lstrcpy ( SubSubmEntry[SS_EntrySize].Name, Name );

				for ( int i = 0; i < MAX_NAME_CHAR; ++i )
				{
					SubSubmEntry[SS_EntrySize].Name[i] ^= SUBM_ENTRY_KEY;
				}

				SubSubmEntry[SS_EntrySize].iValue = Value;
				SubSubmEntry[SS_EntrySize].iMin = Min;
				SubSubmEntry[SS_EntrySize].iMax = Max;
				SubSubmEntry[SS_EntrySize].iStep = Step;
				SubSubmEntry[SS_EntrySize].Float = Float;
				SubSubmEntry[SS_EntrySize].Space = Space;
				SubSubmEntry[SS_EntrySize].Switch = Switch;
				SubSubmEntry[SS_EntrySize].Auto = Auto;
				SubSubmEntry[SS_EntrySize].String = String;

				++SS_EntrySize;
			}

			void Menu::AddSubSubKey ( const char* Name, BYTE* Value,
				bool Float, bool Space, bool Switch, bool Auto, bool String )
			{
				Utils::native_memset ( SubSubmEntry[SS_EntrySize].Name, sizeof ( SS_Entry::Name ), 0 );

				lstrcpy ( SubSubmEntry[SS_EntrySize].Name, Name );

				for ( int i = 0; i < MAX_NAME_CHAR; ++i )
				{
					SubSubmEntry[SS_EntrySize].Name[i] ^= SUBM_ENTRY_KEY;
				}

				SubSubmEntry[SS_EntrySize].kValue = Value;
				SubSubmEntry[SS_EntrySize].Float = Float;
				SubSubmEntry[SS_EntrySize].Space = Space;
				SubSubmEntry[SS_EntrySize].Switch = Switch;
				SubSubmEntry[SS_EntrySize].Auto = Auto;
				SubSubmEntry[SS_EntrySize].String = String;

				++SS_EntrySize;
			}

			void Menu::AddSubSubBool ( const char* Name, bool* Value,
				bool Float, bool Space, bool Switch, bool Auto, bool String )
			{
				Utils::native_memset ( SubSubmEntry[SS_EntrySize].Name, sizeof ( SS_Entry::Name ), 0 );

				lstrcpy ( SubSubmEntry[SS_EntrySize].Name, Name );

				for ( int i = 0; i < MAX_NAME_CHAR; ++i )
				{
					SubSubmEntry[SS_EntrySize].Name[i] ^= SUBM_ENTRY_KEY;
				}

				SubSubmEntry[SS_EntrySize].bValue = Value;
				SubSubmEntry[SS_EntrySize].Float = Float;
				SubSubmEntry[SS_EntrySize].Space = Space;
				SubSubmEntry[SS_EntrySize].Switch = Switch;
				SubSubmEntry[SS_EntrySize].Auto = Auto;
				SubSubmEntry[SS_EntrySize].String = String;

				++SS_EntrySize;
			}

			void Menu::Clear ( )
			{
				for ( int i = 0; i < M_EntrySize; ++i )
				{
					Utils::native_memset ( &MenuEntry[i].Name, sizeof ( M_Entry::Name ), 0 );
				}

				for ( int i = 0; i < S_EntrySize; ++i )
				{
					Utils::native_memset ( &MenuEntry[i].Name, sizeof ( S_Entry::Name ), 0 );

					SubmEntry[i].flValue = 0;
					SubmEntry[i].flMin = 0.0f;
					SubmEntry[i].flMax = 0.0f;
					SubmEntry[i].flStep = 0.0f;

					SubmEntry[i].iValue = 0;
					SubmEntry[i].iMin = 0;
					SubmEntry[i].iMax = 0;
					SubmEntry[i].iStep = 0;

					SubmEntry[i].bValue = 0;

					SubmEntry[i].Float = false;
					SubmEntry[i].Space = false;
					SubmEntry[i].Switch = false;
					SubmEntry[i].Active = false;
					SubmEntry[i].Sub = false;
					SubmEntry[i].Auto = false;

					SubmEntry[i].Color[0] = 0;
					SubmEntry[i].Color[1] = 0;
					SubmEntry[i].Color[2] = 0;
				}

				for ( int i = 0; i < SS_EntrySize; ++i )
				{
					Utils::native_memset ( &MenuEntry[i].Name, sizeof ( SS_Entry::Name ), 0 );

					SubSubmEntry[i].flValue = 0;
					SubSubmEntry[i].flMin = 0.0f;
					SubSubmEntry[i].flMax = 0.0f;
					SubSubmEntry[i].flStep = 0.0f;

					SubSubmEntry[i].iValue = 0;
					SubSubmEntry[i].iMin = 0;
					SubSubmEntry[i].iMax = 0;
					SubSubmEntry[i].iStep = 0;

					SubSubmEntry[i].bValue = 0;

					SubSubmEntry[i].Float = false;
					SubSubmEntry[i].Space = false;
					SubSubmEntry[i].Switch = false;
					SubSubmEntry[i].Auto = false;
					SubSubmEntry[i].String = false;
				}

				M_EntrySize = 0;
				S_EntrySize = 0;
				SS_EntrySize = 0;
			}

			void Menu::HUD_Redraw ( )
			{
				SetSettings ( );
				DrawFadeAnimation ( );
				DrawMenu ( g_Vars.Menu.X, g_Vars.Menu.Y );
			}

			void Menu::HUD_Key_Event ( bool& RetFlag, int& keynum )
			{
				RetFlag = false;

				if ( keynum == g_Vars.Menu.Key )
				{
					Visible = !Visible;

					VisibleAnimation = true;
				}

				if ( !Visible ) return;

				if ( !SubMenu )
				{
					if ( keynum == K_ENTER || keynum == K_RIGHTARROW )
					{
						if ( MenuEntry[M_EntryPos].Function )
						{
							if ( keynum == K_ENTER )
							{
								if ( M_EntryPos == LOAD_SETTINGS )
								{
									Files::ReloadSettings ( );

									if ( g_Vars.Main.Language == ENGLISH )
									{
										ConsolePrintColor ( 100, 255, 200, HPP );
										ConsolePrintColor ( 200, 255, 200, SETTINGS_RELOADED_ENG );
									}
									else if ( g_Vars.Main.Language == RUSSIAN )
									{
										ConsolePrintColor ( 100, 255, 200, HPP );
										ConsolePrintColor ( 200, 255, 200, SETTINGS_RELOADED_RUS );
									}

									SDK::Interfaces::g_pEngine->pfnPlaySoundByName ( "vox/loading.wav", 1 );
								}
								else if ( M_EntryPos == SAVE_SETTINGS )
								{
									Files::SaveSettings ( );

									if ( g_Vars.Main.Language == ENGLISH )
									{
										ConsolePrintColor ( 100, 255, 200, HPP );
										ConsolePrintColor ( 200, 255, 200, SETTINGS_SAVED_ENG );
									}
									else if ( g_Vars.Main.Language == RUSSIAN )
									{
										ConsolePrintColor ( 100, 255, 200, HPP );
										ConsolePrintColor ( 200, 255, 200, SETTINGS_SAVED_RUS );
									}

									SDK::Interfaces::g_pEngine->pfnPlaySoundByName ( "vox/save.wav", 1 );
								}
							}
						}
						else
						{
							S_EntryPos = 0;

							SubMenu = true;
						}
					}
					else if ( keynum == K_UPARROW )
					{
						if ( M_EntryPos > 0 )
							--M_EntryPos;
					}
					else if ( keynum == K_DOWNARROW )
					{
						if ( M_EntryPos < ( M_EntrySize - 1 ) )
							++M_EntryPos;
					}
					else if ( keynum == K_BACKSPACE )
					{
						Visible = false;
					}
				}
				else
				{
					if ( !SubSubMenu )
					{
						if ( SubmEntry[S_EntryPos].Sub && ( keynum == K_ENTER || keynum == K_RIGHTARROW || keynum == K_LEFTARROW ) )
						{
							if ( keynum == K_LEFTARROW )
							{
								return;
							}

							if ( keynum == K_ENTER || keynum == K_RIGHTARROW )
							{
								if ( SubmEntry[S_EntryPos].Active )
								{
									SS_EntryPos = 0;

									SubSubMenu = true;
								}
							}
						}
						else if ( keynum == K_UPARROW )
						{
							if ( S_EntryPos > 0 )
								--S_EntryPos;
							else
								SubMenu = false;
						}
						else if ( keynum == K_DOWNARROW )
						{
							if ( S_EntryPos < ( S_EntrySize - 1 ) )
								++S_EntryPos;
						}
						else if ( keynum == K_LEFTARROW )
						{
							if ( SubmEntry[S_EntryPos].Float )
							{
								*SubmEntry[S_EntryPos].flValue -= SubmEntry[S_EntryPos].flStep;

								if ( *SubmEntry[S_EntryPos].flValue < SubmEntry[S_EntryPos].flMin )
									*SubmEntry[S_EntryPos].flValue = SubmEntry[S_EntryPos].flMin;
							}
							else
							{
								if ( !SubmEntry[S_EntryPos].Switch )
								{
									*SubmEntry[S_EntryPos].iValue -= SubmEntry[S_EntryPos].iStep;

									if ( *SubmEntry[S_EntryPos].iValue < SubmEntry[S_EntryPos].iMin )
										*SubmEntry[S_EntryPos].iValue = SubmEntry[S_EntryPos].iMin;
								}
								else
									*SubmEntry[S_EntryPos].bValue = false;
							}
						}
						else if ( keynum == K_RIGHTARROW )
						{
							if ( SubmEntry[S_EntryPos].Float )
							{
								*SubmEntry[S_EntryPos].flValue += SubmEntry[S_EntryPos].flStep;

								if ( *SubmEntry[S_EntryPos].flValue > SubmEntry[S_EntryPos].flMax )
									*SubmEntry[S_EntryPos].flValue = SubmEntry[S_EntryPos].flMax;
							}
							else
							{
								if ( !SubmEntry[S_EntryPos].Switch )
								{
									*SubmEntry[S_EntryPos].iValue += SubmEntry[S_EntryPos].iStep;

									if ( *SubmEntry[S_EntryPos].iValue > SubmEntry[S_EntryPos].iMax )
										*SubmEntry[S_EntryPos].iValue = SubmEntry[S_EntryPos].iMax;
								}
								else
									*SubmEntry[S_EntryPos].bValue = true;
							}
						}
						else if ( keynum == K_BACKSPACE )
						{
							SubMenu = false;
						}
					}
					else
					{
						static int i;

						if ( keynum == K_ENTER )
						{
							if ( SubSubmEntry[SS_EntryPos].String )
							{
								if ( InputString )
								{
									*SubSubmEntry[SS_EntryPos].kValue = Files::StringToKey ( String );

									i = 0;

									Utils::native_memset ( String, sizeof ( String ), 0 );

									InputString = false;
								}
								else
								{
									InputString = true;
								}
							}
							else
							{
								if ( !SubSubmEntry[SS_EntryPos].Switch && !SubSubmEntry[SS_EntryPos].Auto )
								{
									if ( InputString )
									{
										if ( SubSubmEntry[SS_EntryPos].Float )
										{
											*SubSubmEntry[SS_EntryPos].flValue = ( float )atof ( String );
										}
										else
										{
											*SubSubmEntry[SS_EntryPos].iValue = atoi ( String );
										}

										i = 0;

										Utils::native_memset ( String, sizeof ( String ), 0 );

										InputString = false;
									}
									else
									{
										InputString = true;
									}
								}
							}
						}

						if ( InputString )
						{
							if ( keynum == K_BACKSPACE )
							{
								if ( i )
								{
									--i;
									String[i] = ' ';
								}

								return;
							}
							else if ( keynum == K_LEFTARROW )
							{
								if ( i )
								{
									--i;

									if ( i < 0 )
										i = 0;
								}

								return;
							}
							else if ( keynum == K_RIGHTARROW )
							{
								if ( i )
								{
									++i;

									if ( i > lstrlen ( String ) )
										i = lstrlen ( String );
								}

								return;
							}

							if ( i == ( SubSubmEntry[SS_EntryPos].String ? 10 : 5 ) ) return;

							if ( SubSubmEntry[SS_EntryPos].String )
							{
								switch ( keynum )
								{
								case K_0: String[i] = '0'; ++i; break;
								case K_1: String[i] = '1'; ++i; break;
								case K_2: String[i] = '2'; ++i; break;
								case K_3: String[i] = '3'; ++i; break;
								case K_4: String[i] = '4'; ++i; break;
								case K_5: String[i] = '5'; ++i; break;
								case K_6: String[i] = '6'; ++i; break;
								case K_7: String[i] = '7'; ++i; break;
								case K_8: String[i] = '8'; ++i; break;
								case K_9: String[i] = '9'; ++i; break;
								case K_POINT: String[i] = '.'; ++i; break;
								case K_COMMA: String[i] = ','; ++i; break;
								case K_BRACKET_LEFT: String[i] = '['; ++i; break;
								case K_BRACKET_RIGHT: String[i] = ']'; ++i; break;
								case K_A: String[i] = 'A'; ++i; break;
								case K_B: String[i] = 'B'; ++i; break;
								case K_C: String[i] = 'C'; ++i; break;
								case K_D: String[i] = 'D'; ++i; break;
								case K_E: String[i] = 'E'; ++i; break;
								case K_F: String[i] = 'F'; ++i; break;
								case K_G: String[i] = 'G'; ++i; break;
								case K_H: String[i] = 'H'; ++i; break;
								case K_I: String[i] = 'I'; ++i; break;
								case K_J: String[i] = 'J'; ++i; break;
								case K_K: String[i] = 'K'; ++i; break;
								case K_L: String[i] = 'L'; ++i; break;
								case K_M: String[i] = 'M'; ++i; break;
								case K_N: String[i] = 'N'; ++i; break;
								case K_O: String[i] = 'O'; ++i; break;
								case K_P: String[i] = 'P'; ++i; break;
								case K_Q: String[i] = 'Q'; ++i; break;
								case K_R: String[i] = 'R'; ++i; break;
								case K_S: String[i] = 'S'; ++i; break;
								case K_T: String[i] = 'T'; ++i; break;
								case K_U: String[i] = 'U'; ++i; break;
								case K_V: String[i] = 'V'; ++i; break;
								case K_W: String[i] = 'W'; ++i; break;
								case K_X: String[i] = 'X'; ++i; break;
								case K_Y: String[i] = 'Y'; ++i; break;
								case K_Z: String[i] = 'Z'; ++i; break;
								}
							}
							else
							{
								switch ( keynum )
								{
								case K_0: String[i] = '0'; ++i; break;
								case K_1: String[i] = '1'; ++i; break;
								case K_2: String[i] = '2'; ++i; break;
								case K_3: String[i] = '3'; ++i; break;
								case K_4: String[i] = '4'; ++i; break;
								case K_5: String[i] = '5'; ++i; break;
								case K_6: String[i] = '6'; ++i; break;
								case K_7: String[i] = '7'; ++i; break;
								case K_8: String[i] = '8'; ++i; break;
								case K_9: String[i] = '9'; ++i; break;
								case K_POINT: String[i] = '.'; ++i; break;
								}
							}
						}

						if ( !InputString )
						{
							if ( keynum == K_UPARROW )
							{
								if ( SS_EntryPos > 0 )
									--SS_EntryPos;
								else
									SubSubMenu = false;
							}
							else if ( keynum == K_DOWNARROW )
							{
								if ( SS_EntryPos < ( SS_EntrySize - 1 ) )
									++SS_EntryPos;
							}
							else if ( keynum == K_LEFTARROW )
							{
								if ( SubSubmEntry[SS_EntryPos].Float )
								{
									*SubSubmEntry[SS_EntryPos].flValue -= SubSubmEntry[SS_EntryPos].flStep;

									if ( *SubSubmEntry[SS_EntryPos].flValue < SubSubmEntry[SS_EntryPos].flMin )
										*SubSubmEntry[SS_EntryPos].flValue = SubSubmEntry[SS_EntryPos].flMin;
								}
								else
								{
									if ( !SubSubmEntry[SS_EntryPos].Switch )
									{
										*SubSubmEntry[SS_EntryPos].iValue -= SubSubmEntry[SS_EntryPos].iStep;

										if ( *SubSubmEntry[SS_EntryPos].iValue < SubSubmEntry[SS_EntryPos].iMin )
											*SubSubmEntry[SS_EntryPos].iValue = SubSubmEntry[SS_EntryPos].iMin;
									}
									else
										*SubSubmEntry[SS_EntryPos].bValue = false;
								}
							}
							else if ( keynum == K_RIGHTARROW )
							{
								if ( SubSubmEntry[SS_EntryPos].Float )
								{
									*SubSubmEntry[SS_EntryPos].flValue += SubSubmEntry[SS_EntryPos].flStep;

									if ( *SubSubmEntry[SS_EntryPos].flValue > SubSubmEntry[SS_EntryPos].flMax )
										*SubSubmEntry[SS_EntryPos].flValue = SubSubmEntry[SS_EntryPos].flMax;
								}
								else
								{
									if ( !SubSubmEntry[SS_EntryPos].Switch )
									{
										*SubSubmEntry[SS_EntryPos].iValue += SubSubmEntry[SS_EntryPos].iStep;

										if ( *SubSubmEntry[SS_EntryPos].iValue > SubSubmEntry[SS_EntryPos].iMax )
											*SubSubmEntry[SS_EntryPos].iValue = SubSubmEntry[SS_EntryPos].iMax;
									}
									else
										*SubSubmEntry[SS_EntryPos].bValue = true;
								}
							}
							else if ( keynum == K_BACKSPACE )
							{
								SubSubMenu = false;
							}

							if ( M_EntryPos == AIMBOT )
							{
								if ( S_EntryPos == SUBMENU_ENTRY_AIMBOT::PISTOLS && ( keynum == K_LEFTARROW || keynum == K_RIGHTARROW ) )
									SetAimBotPistolsSettings ( );

								if ( S_EntryPos == SUBMENU_ENTRY_AIMBOT::RIFLES && ( keynum == K_LEFTARROW || keynum == K_RIGHTARROW ) )
									SetAimBotRiflesSettings ( );

								if ( S_EntryPos == SUBMENU_ENTRY_AIMBOT::SNIPERS && ( keynum == K_LEFTARROW || keynum == K_RIGHTARROW ) )
									SetAimBotSnipersSettings ( );
							}
							if ( M_EntryPos == TRIGGERBOT )
							{
								if ( S_EntryPos == SUBMENU_ENTRY_TRIGGERBOT::TPISTOLS && ( keynum == K_LEFTARROW || keynum == K_RIGHTARROW ) )
									SetTriggerBotPistolsSettings ( );

								if ( S_EntryPos == SUBMENU_ENTRY_TRIGGERBOT::TRIFLES && ( keynum == K_LEFTARROW || keynum == K_RIGHTARROW ) )
									SetTriggerBotRiflesSettings ( );

								if ( S_EntryPos == SUBMENU_ENTRY_TRIGGERBOT::TSNIPERS && ( keynum == K_LEFTARROW || keynum == K_RIGHTARROW ) )
									SetTriggerBotSnipersSettings ( );
							}
						}
					}
				}

				RetFlag = true;
			}
		}
	}
}
```

`Menu.h`:

```h
#pragma once

#include "Main.h"

namespace Client
{
	namespace Functions
	{
		namespace Visuals
		{
			struct M_Entry
			{
				char Name[MAX_NAME_CHAR];
				bool Space, Function;
			};

			struct S_Entry
			{
				char Name[MAX_NAME_CHAR];

				float *flValue, flStep, flMin, flMax;
				int *iValue, iStep, iMin, iMax;
				bool *bValue;

				BYTE Color[3];

				bool Float, Space, Switch;
				bool Active, Sub, Auto;
			};

			struct SS_Entry
			{
				char Name[MAX_NAME_CHAR];

				float *flValue, flStep, flMin, flMax;
				int *iValue, iStep, iMin, iMax;
				BYTE *kValue;
				bool *bValue;

				bool Float, Space;
				bool Switch, Auto, String;
			};

			class Menu
			{
			public:
				static void HUD_Redraw ( );
				static void HUD_Key_Event ( bool& RetFlag, int& keynum );

			private:
				static int BoxWidth, BoxHeight;
				static BYTE BoxOutlineColor[4], BoxColor[4];
				static BYTE BoxSelectColor[4], TextColor[3];

				static void SetSettings ( );

				static void Initialize ( );	
				static void DrawFadeAnimation ( );
				static void DrawMenu ( int x, int y );

				static char String[20];

				static bool SubMenu, SubSubMenu;
				static bool Visible, InputString;
				static bool VisibleAnimation;

				static float flVisibleAnimationTimer;

				static M_Entry MenuEntry[MAX_SUBS_MENU];
				static S_Entry SubmEntry[MAX_SUBS_MENU];
				static SS_Entry SubSubmEntry[MAX_SUBS_MENU];

				static int M_EntryPos, M_EntrySize;
				static int S_EntryPos, S_EntrySize;
				static int SS_EntryPos, SS_EntrySize;

				static void SetAimBotPistolsSettings ( );
				static void SetAimBotRiflesSettings ( );
				static void SetAimBotSnipersSettings ( );

				static void SetTriggerBotPistolsSettings ( );
				static void SetTriggerBotRiflesSettings ( );
				static void SetTriggerBotSnipersSettings ( );

				static void Add ( const char* Name, bool Space, bool Function );

				static void AddSubFloat ( const char* Name, float* Value, float Min, float Max, float Step, 
					bool Float, bool Space, bool Switch, bool Active, bool Sub, bool Auto, BYTE R, BYTE G, BYTE B );

				static void AddSubInt ( const char* Name, int* Value, int Min, int Max, int Step,
					bool Float, bool Space, bool Switch, bool Active, bool Sub, bool Auto, BYTE R, BYTE G, BYTE B );

				static void AddSubBool ( const char* Name, bool* Value, bool Float, bool Space,
					bool Switch, bool Active, bool Sub, bool Auto, BYTE R, BYTE G, BYTE B );

				static void AddSubSubFloat ( const char* Name, float* Value, float Min, float Max, 
					float Step, bool Float, bool Space, bool Switch, bool Auto, bool String );

				static void AddSubSubInt ( const char* Name, int* Value, int Min, int Max, 
					int Step, bool Float, bool Space, bool Switch, bool Auto, bool String );

				static void AddSubSubKey ( const char* Name, BYTE* Value, 
					bool Float, bool Space, bool Switch, bool Auto, bool String );

				static void AddSubSubBool ( const char* Name, bool* Value, 
					bool Float, bool Space, bool Switch, bool Auto, bool String );

				static void Clear ( );
			};
		}
	}
}
```

`NoFlash.cpp`:

```cpp
#include "NoFlash.h"

namespace Client
{
	namespace Functions
	{
		namespace Visuals
		{
			enum FADE_COLOR
			{
				RED, LIGHT_RED, GREEN, LIGHT_GREEN, BLUE, LIGHT_BLUE, AQUAMARINE, HELIOTROPE,
				DARKPURPLEVOILET, LASERLEMON, BRIGHTGREEN, GREENLAWN, GREENYELLOWKRAYOLA, YELLOW
			};

			float NoFlash::flCurstateFlashed;
			float NoFlash::flPrevstateFlashed;

			BYTE NoFlash::FadeColor[3];
			BYTE NoFlash::ShowPecentColor[3];

			bool NoFlash::SetColor;

			void NoFlash::SetFadeColorRandom ( )
			{
				if ( flCurstateFlashed && SetColor )
				{
					int Color = SDK::Interfaces::g_pEngine->pfnRandomLong ( 0, 13 );

					switch ( Color )
					{
					case RED:
						FadeColor[0] = 255;
						FadeColor[1] = 0;
						FadeColor[2] = 0;

						break;

					case LIGHT_RED:
						FadeColor[0] = 255;
						FadeColor[1] = 100;
						FadeColor[2] = 100;

						break;

					case GREEN:
						FadeColor[0] = 0;
						FadeColor[1] = 255;
						FadeColor[2] = 0;

						break;

					case LIGHT_GREEN:
						FadeColor[0] = 100;
						FadeColor[1] = 255;
						FadeColor[2] = 100;

						break;

					case BLUE:
						FadeColor[0] = 0;
						FadeColor[1] = 0;
						FadeColor[2] = 255;

						break;

					case LIGHT_BLUE:
						FadeColor[0] = 100;
						FadeColor[1] = 100;
						FadeColor[2] = 255;

						break;

					case AQUAMARINE:
						FadeColor[0] = 127;
						FadeColor[1] = 255;
						FadeColor[2] = 212;

						break;

					case HELIOTROPE:
						FadeColor[0] = 200;
						FadeColor[1] = 90;
						FadeColor[2] = 255;

						break;

					case DARKPURPLEVOILET:
						FadeColor[0] = 102;
						FadeColor[1] = 0;
						FadeColor[2] = 153;

						break;

					case LASERLEMON:
						FadeColor[0] = 254;
						FadeColor[1] = 254;
						FadeColor[2] = 34;

						break;

					case BRIGHTGREEN:
						FadeColor[0] = 0;
						FadeColor[1] = 125;
						FadeColor[2] = 52;

						break;

					case GREENLAWN:
						FadeColor[0] = 124;
						FadeColor[1] = 252;
						FadeColor[2] = 0;

						break;

					case GREENYELLOWKRAYOLA:
						FadeColor[0] = 240;
						FadeColor[1] = 232;
						FadeColor[2] = 145;

						break;

					case YELLOW:
						FadeColor[0] = 255;
						FadeColor[1] = 255;
						FadeColor[2] = 0;

						break;
					}

					SDK::Interfaces::g_pScreenFade->fader = FadeColor[0];
					SDK::Interfaces::g_pScreenFade->fadeg = FadeColor[1];
					SDK::Interfaces::g_pScreenFade->fadeb = FadeColor[2];

					SetColor = false;
				}

				if ( flCurstateFlashed == 255.0f && flPrevstateFlashed == 255.0f )
				{
					SDK::Interfaces::g_pScreenFade->fader = FadeColor[0];
					SDK::Interfaces::g_pScreenFade->fadeg = FadeColor[1];
					SDK::Interfaces::g_pScreenFade->fadeb = FadeColor[2];
				}

				if ( !flCurstateFlashed || flPrevstateFlashed < flCurstateFlashed )
				{
					SetColor = true;
				}
			}

			void NoFlash::SetFadeColor ( )
			{
				SDK::Interfaces::g_pScreenFade->fader = g_Vars.NoFlash.FadeColor[0];
				SDK::Interfaces::g_pScreenFade->fadeg = g_Vars.NoFlash.FadeColor[1];
				SDK::Interfaces::g_pScreenFade->fadeb = g_Vars.NoFlash.FadeColor[2];
			}

			void NoFlash::DrawFlashed ( const int& Percentage )
			{
				int x = SDK::Interfaces::g_Screen.iWidth / 2;
				int y = SDK::Interfaces::g_Screen.iHeight / 6;

				Renderer::g_Fonts->Print ( x, y, ShowPecentColor[0], ShowPecentColor[1], 0, 255, 
					g_Vars.NoFlash.FontOutline ? FL_CENTER | FL_OUTLINE : FL_CENTER, "Flashed: %d", Percentage );

				if ( Percentage > DONT_SEE_FLASH_PERCENT )
				{
					Renderer::g_Fonts->Print ( x, y + 13, 255, 80, 80, 255, g_Vars.NoFlash.FontOutline ? 
						FL_CENTER | FL_OUTLINE : FL_CENTER, "You are don't see." );
				}
			}

			void NoFlash::DrawFlashedBox ( const int& Percentage )
			{
				int x = SDK::Interfaces::g_Screen.iWidth / 2;
				int y = int ( SDK::Interfaces::g_Screen.iHeight / 6.2f );

				Renderer::g_Drawing->Box ( x - 101, y - 9, 202, 18, 1, 20, 20, 20, 225 );
				Renderer::g_Drawing->FillArea ( x - 100, y - 8, 200, 16, ShowPecentColor[0], ShowPecentColor[1], 0, 150 );

				Renderer::g_Fonts->Print ( x, y + 4, 255, 255, 255, 255, g_Vars.NoFlash.FontOutline ? 
					FL_CENTER | FL_OUTLINE : FL_CENTER, "Flashed: %d", Percentage );

				if ( Percentage > DONT_SEE_FLASH_PERCENT )
				{
					Renderer::g_Fonts->Print ( x, y + 23, 255, 0, 0, 255, g_Vars.NoFlash.FontOutline ? 
						FL_CENTER | FL_OUTLINE : FL_CENTER, "You are don't see." );
				}
			}

			float NoFlash::GetFlashedPercentage ( )
			{
				UpdateFlashedData ( );

				return flCurstateFlashed / 255.0f * 100.0f;
			}

			void NoFlash::UpdateFlashedData ( )
			{
				float flFadeEnd = 0.0f;

				flPrevstateFlashed = flCurstateFlashed;

				if ( SDK::Interfaces::g_pScreenFade->fadeEnd > SDK::Interfaces::g_pEngine->GetClientTime ( ) )
				{
					flFadeEnd = SDK::Interfaces::g_pScreenFade->fadeEnd;

					if ( g_Vars.Functions.NoFlash && g_Vars.NoFlash.Enable )
					{
						if ( g_Vars.NoFlash.FadeLimit > 255.0f )
						{
							SDK::Interfaces::g_pScreenFade->fadeEnd = 255.0f;
						}
						else if ( SDK::Interfaces::g_pScreenFade->fadealpha > g_Vars.NoFlash.FadeLimit )
						{
							SDK::Interfaces::g_pScreenFade->fadealpha = g_Vars.NoFlash.FadeLimit;
						}
					}
				}

				flCurstateFlashed = flFadeEnd > SDK::Interfaces::g_pEngine->GetClientTime ( ) ?
					( flFadeEnd - SDK::Interfaces::g_pEngine->GetClientTime ( ) ) * SDK::Interfaces::g_pScreenFade->fadeSpeed : 0.0f;

				if ( flCurstateFlashed > 255.0f )
					flCurstateFlashed = 255.0f;

				if ( flCurstateFlashed < 0.0f )
					flCurstateFlashed = 0.0f;
			}

			void NoFlash::InterpolatedShowPercentColor ( const int& Percentage )
			{
				ShowPecentColor[0] = Percentage >= 50 ? 255 : ( BYTE )Utils::Interp ( 0.0f, ( float )Percentage, 50.0f, 0.0f, 255.0f );
				ShowPecentColor[1] = Percentage <= 50 ? 255 : ( BYTE )Utils::Interp ( 50.0f, ( float )Percentage, 100.0f, 255.0f, 0.0f );
			}

			void NoFlash::HUD_Redraw ( )
			{
				if ( g_Vars.NoFlash.FadeColorEnable )
				{
					g_Vars.NoFlash.FadeColorRandom ? SetFadeColorRandom ( ) : SetFadeColor ( );
				}

				int Percentage = ( int )GetFlashedPercentage ( );

				if ( g_Vars.NoFlash.DrawFlashed && Percentage >= 1 )
				{
					InterpolatedShowPercentColor ( Percentage );

					g_Vars.NoFlash.DrawFlashed <= 1.0f ? DrawFlashed ( Percentage ) : DrawFlashedBox ( Percentage );
				}
			}
		}
	}
}
```

`NoFlash.h`:

```h
#pragma once

#include "Main.h"

namespace Client
{
	namespace Functions
	{
		namespace Visuals
		{
			class NoFlash
			{
			public:
				static float GetFlashedPercentage ( );

				static void HUD_Redraw ( );

			private:
				static float flCurstateFlashed;
				static float flPrevstateFlashed;

				static BYTE FadeColor[3];
				static BYTE ShowPecentColor[3];

				static bool SetColor;

				static void UpdateFlashedData ( );

				static void DrawFlashed ( const int& Percentage );
				static void DrawFlashedBox ( const int& Percentage );

				static void InterpolatedShowPercentColor ( const int& Percentage );

				static void SetFadeColorRandom ( );
				static void SetFadeColor ( );
			};
		}
	}
}
```

`Offsets.cpp`:

```cpp
#include "Offsets.h"

namespace Engine
{
	DWORD HWDLL = 0;
	DWORD SWDLL = 0;
	DWORD HLMOD = 0;

	DWORD HWBase = 0;
	DWORD HWSize = 0;
	DWORD HWEnd = 0;

	DWORD HLBase = 0;
	DWORD HLSize = 0;
	DWORD HLEnd = 0;

	DWORD CLBase = 0;
	DWORD CLSize = 0;
	DWORD CLEnd = 0;

	DWORD VGBase = 0;
	DWORD VGSize = 0;
	DWORD VGEnd = 0;

	DWORD Speed = 0;
	DWORD SpeedPtr = 0;

	int HLType = 0;

	double* g_Net = nullptr;

	namespace Offset
	{
		void GetRenderType ( )
		{
			HWDLL = ( DWORD )GetModuleHandle ( "hw.dll" );
			SWDLL = ( DWORD )GetModuleHandle ( "sw.dll" );
			HLMOD = ( DWORD )GetModuleHandle ( 0 );
		}

		DWORD GetModuleSize ( DWORD Address )
		{
			return PIMAGE_NT_HEADERS ( Address + ( DWORD )PIMAGE_DOS_HEADER ( Address )->e_lfanew )->OptionalHeader.SizeOfImage;
		}

		bool GetModuleInfo ( )
		{
			GetRenderType ( );

			if ( HWDLL )
			{
				HWBase = HWDLL;
			}
			else if ( SWDLL )
			{
				HWBase = SWDLL;
			}
			else
			{
				HWBase = HLMOD;
			}

			HWSize = GetModuleSize ( HWBase );
			HWEnd = HWBase + HWSize - 1;

			HLBase = HLMOD;
			HLSize = GetModuleSize ( HWBase );
			HLEnd = HLBase + HLSize - 1;

			CLBase = ( DWORD )GetModuleHandle ( "client.dll" );

			if ( CLBase )
			{
				CLSize = GetModuleSize ( CLBase );
				CLEnd = CLBase + CLSize - 1;
			}
			else
			{
				CLBase = HWBase;
				CLSize = HWSize;
				CLEnd = HWEnd;
			}

			VGBase = ( DWORD )GetModuleHandle ( "GameUI.dll" );

			if ( VGBase )
			{
				VGSize = GetModuleSize ( VGBase );
				VGEnd = VGBase + VGSize - 1;
			}

			return HWBase && CLBase && VGBase;
		}

		DWORD FindString ( PCHAR String, DWORD Start, DWORD End, DWORD Offset )
		{
			DWORD PtLen = lstrlen ( String );

			bool Found = false;

			for ( DWORD i = Start; i < End - PtLen; ++i )
			{
				Found = true;

				for ( DWORD idx = 0; idx < PtLen; ++idx )
				{
					if ( String[idx] != *( PCHAR )( i + idx ) )
					{
						Found = false;

						break;
					}
				}

				if ( Found )
					return i + Offset;
			}

			return 0;
		}

		DWORD FindPattern ( PCHAR Pattern, DWORD PtLen, DWORD Start, DWORD End, DWORD Offset )
		{
			bool Found = false;

			for ( DWORD i = Start; i < End - PtLen; ++i )
			{
				Found = true;

				for ( DWORD idx = 0; idx < PtLen; ++idx )
				{
					if ( Pattern[idx] != *( PCHAR )( i + idx ) )
					{
						Found = false;

						break;
					}
				}

				if ( Found )
					return i + Offset;
			}

			return 0;
		}

		DWORD FindPushString ( DWORD Start, DWORD End, DWORD Address )
		{
			char Pattern[5] = { 0x68, 0x00, 0x00, 0x00, 0x00 };

			*( PDWORD )&Pattern[1] = Address;

			return FindPattern ( Pattern, sizeof ( Pattern ), Start, End, 0 );
		}

		DWORD FarProc ( DWORD Address, DWORD LB, DWORD HB )
		{
			return ( Address < LB ) || ( Address > HB );
		}

		DWORD FindClientTable ( )
		{
			DWORD PatternAddress = FindString ( "ScreenFade", HWBase, HWEnd, 0 );

			BYTE ClientOffset[2] = { 0x10, 0x13 };

			if ( PatternAddress )
			{
				for ( int i = 0; i < sizeof ( ClientOffset ); ++i )
				{
					DWORD ClientTablePtr = *( PDWORD )( FindPushString ( HWBase, HWEnd, PatternAddress ) + ClientOffset[i] );

					if ( !FarProc ( ClientTablePtr, HWBase, HWEnd ) && !IsBadReadPtr ( ( PVOID )ClientTablePtr, sizeof ( cl_clientfunc_t ) ) )
						return ClientTablePtr;
				}
			}

			return 0;
		}

		DWORD FindEngineTable ( )
		{
			BYTE EngineOffset[4] = { 0x22, 0x1C, 0x1D, 0x37 };

			for ( int i = 0; i < sizeof ( EngineOffset ); ++i )
			{
				PVOID EnginePtr = ( cl_enginefunc_t* )*( PDWORD )( ( DWORD )SDK::Interfaces::g_pClient->Initialize + EngineOffset[i] );

				if ( FarProc ( ( DWORD )EnginePtr, HWBase, HWEnd ) && FarProc ( ( DWORD )EnginePtr, HLBase, HLEnd ) && !FarProc ( ( DWORD )EnginePtr, CLBase, CLEnd ) )
					return ( DWORD )EnginePtr;
			}

			return 0;
		}

		DWORD FindStudioTable ( )
		{
			DWORD StudioTablePtr = *( DWORD* )( ( DWORD )SDK::Interfaces::g_pClient->HUD_GetStudioModelInterface + 0x30 );

			if ( FarProc ( StudioTablePtr, HWBase, HWEnd ) && FarProc ( StudioTablePtr, HLBase, HLEnd ) && FarProc ( StudioTablePtr, CLBase, CLEnd ) )
			{
				StudioTablePtr = *( DWORD* )( ( DWORD )SDK::Interfaces::g_pClient->HUD_GetStudioModelInterface + 0x1A );

				if ( !FarProc ( StudioTablePtr, CLBase, CLEnd ) )
					return StudioTablePtr;
			}

			return 0;
		}

		BOOL CompareMemory ( const UCHAR *Buff1, const UCHAR *Buff2, UINT Size )
		{
			for ( UINT i = 0; i < Size; ++i, ++Buff1, ++Buff2 )
				if ( ( *Buff1 != *Buff2 ) && ( *Buff2 != 0xFF ) )
					return FALSE;

			return TRUE;
		}

		ULONG FindMemoryClone ( const ULONG Start, const ULONG End, const ULONG Clone, UINT Size )
		{
			for ( ULONG i = Start; ( i + Size ) < End; ++i )
				if ( CompareMemory ( ( const UCHAR* )i, ( const UCHAR* )Clone, ( UINT )Size ) )
					return i;

			return 0;
		}

		ULONG FindReference ( const ULONG Start, const ULONG End, const ULONG Address )
		{
			UCHAR Pattern[5];

			Pattern[0] = 0x68;

			*( ULONG* )&Pattern[1] = Address;

			return FindMemoryClone ( ( const ULONG )Start, ( const ULONG )End, ( const ULONG )Pattern, ( UINT )sizeof ( Pattern ) - 1 );
		}

		DWORD FindPlayerMove ( )
		{
			PCHAR String = "ScreenFade";

			DWORD Address = ( DWORD )FindMemoryClone ( ( const ULONG )HWBase, ( const ULONG )HWBase + HWSize, ( const ULONG )String, ( UINT )strlen ( String ) );

			PVOID PlayerMovePtr = ( PVOID )*( PDWORD )( FindReference ( ( const ULONG )HWBase, ( const ULONG )HWBase + HWSize, ( const ULONG )Address ) + ( UINT )0x18 );

			if ( !FarProc ( ( DWORD )PlayerMovePtr, HWBase, HWEnd ) )
				return ( DWORD )PlayerMovePtr;

			return 0;
		}

		DWORD FindUserMsgBase ( )
		{
			DWORD UserMsgPattern = FindString ( "UserMsg: Not Present on Client %d", HWBase, HWEnd, 0 );

			BYTE OffsetUserMsgBase = 0x16;

			if ( !UserMsgPattern ) return 0;

			DWORD FindAddress = FindPushString ( HWBase, HWEnd, UserMsgPattern );

			if ( FindAddress )
			{
				PBYTE MovPtr = ( PBYTE )( FindAddress - OffsetUserMsgBase );

				if ( *MovPtr == 0x8B )
				{
					DWORD dwUserMsgBase = *( PDWORD )( ( DWORD )MovPtr + 2 );

					if ( !FarProc ( dwUserMsgBase, HWBase, HWEnd ) )
						return *( PDWORD )dwUserMsgBase;
				}
			}

			return 0;
		}

		DWORD Absolute ( DWORD Address )
		{
			if ( !Address )
			{
				Files::InjectLog ( ABSOLUTE_ERROR );

				Utils::Error ( true, ABSOLUTE_ERROR );
			}

			return Address + *( PDWORD )Address + 4;
		}

		DWORD FindSVCMessages ( )
		{
			DWORD SVCMsgPattern = FindString ( "-------- Message Load ---------", HWBase, HWEnd, 0 );

			if ( !SVCMsgPattern )
			{
				Files::InjectLog ( SVC_MSG_ERROR );
				Utils::Error ( true, SVC_MSG_ERROR );
			}

			DWORD FindAddress = *( PDWORD )( FindPushString ( HWBase, HWEnd, SVCMsgPattern ) + 0x12 );

			if ( FarProc ( FindAddress, HWBase, HWEnd ) )
			{
				Files::InjectLog ( SVC_MSG_ERROR );
				Utils::Error ( true, SVC_MSG_ERROR );
			}

			PEngineMsg EngineMsgBase = ( PEngineMsg )( FindAddress - sizeof ( DWORD ) );

			BYTE OffsetReadCoord[5] = { 0x13, 0x15, 0x17, 0x0E, 0x0B };
			BYTE OffsetSVC_SoundBase[3] = { 0x0E, 0x0C, 0x16 };

			if ( EngineMsgBase )
			{
				MSG_ReadByte = ( HL_MSG_ReadByte )Absolute ( ( ( DWORD )EngineMsgBase[SVC_CDTRACK].pfn ) + 1 );
				MSG_ReadShort = ( HL_MSG_ReadShort )Absolute ( ( ( DWORD )EngineMsgBase[SVC_STOPSOUND].pfn ) + 1 );
				MSG_ReadLong = ( HL_MSG_ReadLong )Absolute ( ( ( DWORD )EngineMsgBase[SVC_VERSION].pfn ) + 1 );
				MSG_ReadFloat = ( HL_MSG_ReadFloat )Absolute ( ( ( DWORD )EngineMsgBase[SVC_TIMESCALE].pfn ) + 1 );
				MSG_ReadString = ( HL_MSG_ReadString )Absolute ( ( ( DWORD )EngineMsgBase[SVC_PRINT].pfn ) + 1 );

				DWORD CallMSG_ReadCoord = Absolute ( ( DWORD )( EngineMsgBase[SVC_PARTICLE].pfn ) + 1 );

				for ( int i = 0; i < sizeof ( OffsetReadCoord ); ++i )
				{
					if ( *( PBYTE )( CallMSG_ReadCoord + OffsetReadCoord[i] ) == 0xE8 )
					{
						MSG_ReadCoord = ( HL_MSG_ReadCoord )Absolute ( ( CallMSG_ReadCoord + OffsetReadCoord[i] + 1 ) );

						goto NextFind1;
					}
				}

				Files::InjectLog ( MSG_READ_CORD );
				Utils::Error ( true, MSG_READ_CORD );

			NextFind1:
				MSG_ReadCount = *( PINT* )( ( INT )( MSG_ReadByte )+1 );
				MSG_CurrentSize = *( PINT* )( ( INT )( MSG_ReadByte )+7 );
				MSG_BadRead = *( PINT* )( ( INT )( MSG_ReadByte )+20 );

				DWORD SVC_SoundBase = ( DWORD )EngineMsgBase[SVC_SOUND].pfn;

				for ( int i = 0; i < sizeof ( OffsetSVC_SoundBase ); ++i )
				{
					if ( *( PBYTE )( SVC_SoundBase + OffsetSVC_SoundBase[i] ) == 0xE8 )
					{
						MSG_Buffer = ( sizebuf_t * )( *( PDWORD )( SVC_SoundBase + OffsetSVC_SoundBase[i] - 4 ) );
						MSG_StartBitReading = ( HL_MSG_StartBitReading )Absolute ( SVC_SoundBase + OffsetSVC_SoundBase[i] + 1 );
						MSG_ReadBits = ( HL_MSG_ReadBits )Absolute ( SVC_SoundBase + OffsetSVC_SoundBase[i] + 8 );

						goto NextFind2;
					}
				}

				Files::InjectLog ( MSG_STR_READING );
				Utils::Error ( true, MSG_STR_READING );

			NextFind2:
				if ( *( PBYTE )( SVC_SoundBase + 0xD6 ) == 0xE8 )
				{
					MSG_EndBitReading = ( HL_MSG_EndBitReading )Absolute ( SVC_SoundBase + 0xD7 );
					MSG_ReadBitVec3Coord = ( HL_MSG_ReadBitVec3Coord )Absolute ( SVC_SoundBase + 0xAF );
				}
				else if ( *( PBYTE )( SVC_SoundBase + 0xE2 ) == 0xE8 )
				{
					MSG_EndBitReading = ( HL_MSG_EndBitReading )Absolute ( SVC_SoundBase + 0xE3 );
					MSG_ReadBitVec3Coord = ( HL_MSG_ReadBitVec3Coord )Absolute ( SVC_SoundBase + 0xBE );
				}
				else if ( *( PBYTE )( SVC_SoundBase + 0xDD ) == 0xE8 )
				{
					MSG_EndBitReading = ( HL_MSG_EndBitReading )Absolute ( SVC_SoundBase + 0xDE );
					MSG_ReadBitVec3Coord = ( HL_MSG_ReadBitVec3Coord )Absolute ( SVC_SoundBase + 0xB9 );
				}
				else
				{
					Files::InjectLog ( MSG_END_READING );
					Utils::Error ( true, MSG_END_READING );
				}
			}
			else
				return 0;

			return ( DWORD )EngineMsgBase;
		}

		DWORD FindGameConsole ( )
		{
			DWORD GameConsolePattern = FindPattern ( "GameConsole003", lstrlenA ( "GameConsole003" ), VGBase, VGEnd, 0 );

			if ( !GameConsolePattern )
			{
				Files::InjectLog ( CONSOLE_ERROR );
				Utils::Error ( true, CONSOLE_ERROR );
			}

			DWORD FindAddress = *( PDWORD )( FindPushString ( VGBase, VGEnd, GameConsolePattern ) + 0x21 );

			if ( FarProc ( FindAddress, VGBase, VGEnd ) )
			{
				Files::InjectLog ( CONSOLE_ERROR );
				Utils::Error ( true, CONSOLE_ERROR );
			}

			return FindAddress;
		}

		void ConsoleColorInitialize ( )
		{
			DWORD GameConsole = FindGameConsole ( );

			if ( !GameConsole )
			{
				Files::InjectLog ( CONSOLE_ERROR );
				Utils::Error ( true, CONSOLE_ERROR );
			}

			DWORD Panel = ( *( PDWORD )( GameConsole + 8 ) - GameConsole );

			SDK::Interfaces::Console_TextColor = PColor24 ( Panel + GameConsole + 288 + sizeof ( DWORD ) );

			if ( *( PDWORD )( DWORD ( SDK::Interfaces::Console_TextColor ) + 8 ) )
				SDK::Interfaces::Console_TextColor = PColor24 ( Panel + GameConsole + 288 + ( sizeof ( DWORD ) * 2 ) );
		}

		void GetGameInfo ( pGameInfo_s GameInfo )
		{
			typedef int ( *function )( );

			pcmd_t pCmd = Utils::CommandByName ( "version" );

			DWORD Address = ( DWORD )pCmd->function;

			GameInfo->GameName = *( PCHAR* )( UINT ( Address ) + 1 );
			GameInfo->GameVersion = *( PCHAR* )( UINT ( Address ) + 6 );
			GameInfo->Protocol = *( PBYTE )( UINT ( Address ) + 11 );

			Address = Absolute ( UINT ( Address ) + 23 );

			if ( FarProc ( Address, HWBase, HWEnd ) )
			{
				Files::InjectLog ( GAMEINFO_ERROR );
				Utils::Error ( true, GAMEINFO_ERROR );
			}

			function GetBuild = ( function )Address;

			GameInfo->Build = GetBuild ( );
		}

		void* SpeedHackPtr ( )
		{
			DWORD Old = 0;
			PCHAR String = "Texture load: %6.1fms";
			DWORD Address = ( DWORD )FindMemoryClone ( ( const ULONG )HWBase, ( const ULONG )( HWBase + HWSize ), ( const ULONG )String, ( UINT )strlen ( String ) );
			PVOID SpeedPtr = ( PVOID )*( DWORD* )( FindReference ( ( const ULONG )HWBase, ( const ULONG )( HWBase + HWSize ), ( const ULONG )Address ) - 7 );

			if ( FarProc ( ( DWORD )SpeedPtr, HWBase, HWEnd ) )
			{
				Files::InjectLog ( SPEEDPTR_ERROR );
				Utils::Error ( true, SPEEDPTR_ERROR );
			}
			else
				VirtualProtect ( SpeedPtr, sizeof ( double ), PAGE_READWRITE, &Old );

			return SpeedPtr;
		}
	}
}
```

`Offsets.h`:

```h
#pragma once

#include "Main.h"

namespace Engine
{
	extern DWORD SpeedPtr, Speed;

	extern DWORD HWDLL, SWDLL, HLMOD;
	extern DWORD HWBase, HWSize, HWEnd;
	extern DWORD HLBase, HLSize, HLEnd;
	extern DWORD CLBase, CLSize, CLEnd;
	extern DWORD VGBase, VGSize, VGEnd;

	extern double *g_Net;

	extern int HLType;

	namespace Offset
	{
		void ConsoleColorInitialize ( );

		void GetGameInfo ( pGameInfo_s GameInfo );
		void GetRenderType ( );

		void* SpeedHackPtr ( );

		bool GetModuleInfo ( );

		DWORD FindClientTable ( );
		DWORD FindEngineTable ( );
		DWORD FindStudioTable ( );
		DWORD FindPlayerMove ( );
		DWORD FindUserMsgBase ( );
		DWORD FindSVCMessages ( );

		DWORD GetModuleSize ( DWORD dwAddress );

		DWORD FindString ( PCHAR String, DWORD Start, DWORD End, DWORD Offset );
		DWORD FindPattern ( PCHAR Pattern, DWORD PtLen, DWORD Start, DWORD End, DWORD Offset );
		DWORD FindPushString ( DWORD Start, DWORD End, DWORD Address );
		ULONG FindMemoryClone ( const ULONG Start, const ULONG End, const ULONG Clone, UINT Size );
		ULONG FindReference ( const ULONG Start, const ULONG End, const ULONG Address );
		DWORD FindGameConsole ( );

		DWORD FarProc ( DWORD Address, DWORD LB, DWORD HB );
		BOOL CompareMemory ( const UCHAR *Buff1, const UCHAR *Buff2, UINT Size );
		DWORD Absolute ( DWORD Address );
	}
}
```

`OpenGL.cpp`:

```cpp
#include "OpenGL.h"

namespace OpenGL
{
	using namespace Client::Functions;

	glBegin_t pglBegin = 0;
	glVertex3fv_t pglVertex3fv = 0;
	glColor4f_t pglColor4f = 0;

	bool Smoke = false;
	bool Hands = false;

	void APIENTRY Hooked_glBegin ( GLenum mode )
	{
		if ( !Client::FirstFrame )
			return;

		if ( Client::SnapShot || Client::ScreenShot || Client::SteamScreenShot )
			goto go;

		cl_entity_s *Entity = SDK::Interfaces::g_pStudio->GetCurrentEntity ( );

		if ( g_Vars.Other.RemoveSmoke && mode == GL_QUADS )
		{
			if ( Entity && Entity->model && strstr ( Entity->model->name, "black_smoke" ) )
			{
				GLfloat SmokeCol[4];

				glGetFloatv ( GL_CURRENT_COLOR, SmokeCol );

				if ( ( SmokeCol[0] == SmokeCol[1] ) && ( SmokeCol[0] == SmokeCol[2] ) &&
					( SmokeCol[0] != 0.0f ) && ( SmokeCol[0] != 1.0f ) )
				{
					Smoke = true;
				}
			}
		}
		else
			Smoke = false;

	go:
		pglBegin ( mode );
	}

	void APIENTRY Hooked_glVertex3fv ( GLfloat *v )
	{
		if ( !Client::FirstFrame )
			return;

		if ( Smoke )
			return;

		pglVertex3fv ( v );
	}

	void APIENTRY Hooked_glColor4f ( float r, float g, float b, float a )
	{
		if ( !Client::FirstFrame )
			return;

		if ( Client::SnapShot || Client::ScreenShot || Client::SteamScreenShot )
			goto go;

		cl_entity_s *Entity = SDK::Interfaces::g_pStudio->GetCurrentEntity ( );

		bool isPlayer = Entity && Entity->player && Client::g_Info->GetValidationEntity ( Entity ) && Entity->index != Client::g_Info->GetLocalIndex ( );
		bool isWeapons = Entity && Entity->model && strstr ( Entity->model->name, "w_" );
		bool isHands = Entity && Entity->model && Entity->model->name && strstr ( Entity->model->name, "v_" );

		if ( g_Vars.Chams.Enable )
		{
			if ( g_Vars.Chams.Weapon && isWeapons )
			{
				if ( g_Vars.Chams.WeaponRenderType == 3 )
				{
					r = Visuals::Chams::GetWeaponsColorR ( ) * r;
					g = Visuals::Chams::GetWeaponsColorG ( ) * g;
					b = Visuals::Chams::GetWeaponsColorB ( ) * b;
				}
				else
				{
					r = Visuals::Chams::GetWeaponsColorR ( );
					g = Visuals::Chams::GetWeaponsColorG ( );
					b = Visuals::Chams::GetWeaponsColorB ( );
				}
			}

			if ( g_Vars.Chams.Player && isPlayer )
			{
				if ( Client::g_Info->GetAliveLocal ( ) )
				{
					if ( g_Vars.Chams.Player == 1.0f && Client::g_Info->GetPlayerTeamByIndex ( Entity->index ) == Client::g_Info->GetPlayerTeam ( ) )
					{
						goto go;
					}
				}

				if ( g_Vars.Chams.PlayerRenderType == 3 )
				{
					r = Visuals::Chams::GetPlayerColorR ( ) * r;
					g = Visuals::Chams::GetPlayerColorG ( ) * g;
					b = Visuals::Chams::GetPlayerColorB ( ) * b;
				}
				else
				{
					r = Visuals::Chams::GetPlayerColorR ( );
					g = Visuals::Chams::GetPlayerColorG ( );
					b = Visuals::Chams::GetPlayerColorB ( );
				}
			}
		}

		if ( g_Vars.Chams.Hands && isHands && Hands )
		{
			if ( g_Vars.Chams.HandsRenderType == 3 )
			{
				r = g_Vars.Chams.HandsColor[0] / 255.0f * r;
				g = g_Vars.Chams.HandsColor[1] / 255.0f * g;
				b = g_Vars.Chams.HandsColor[2] / 255.0f * b;
			}
			else
			{
				r = g_Vars.Chams.HandsColor[0] / 255.0f;
				g = g_Vars.Chams.HandsColor[1] / 255.0f;
				b = g_Vars.Chams.HandsColor[2] / 255.0f;
			}
		}

	go:
		pglColor4f ( r, g, b, a );
	}

	void* DetourFunc ( BYTE *src, const BYTE *dst, const int len )
	{
		BYTE *jmp = ( BYTE* )HeapAlloc ( GetProcessHeap ( ), HEAP_ZERO_MEMORY, len + 5 );

		if ( src[0] != 0xE9 )
		{
			DWORD dwBack;

			VirtualProtect ( src, len, PAGE_READWRITE, &dwBack );

			memcpy ( jmp, src, len );

			jmp += len;
			jmp[0] = 0xE9;
			*( DWORD* )( jmp + 1 ) = ( DWORD )( src + len - jmp ) - 5;
			src[0] = 0xE9;
			*( DWORD* )( src + 1 ) = ( DWORD )( dst - src ) - 5;

			VirtualProtect ( src, len, dwBack, &dwBack );

			return ( jmp - len );
		}

		return 0;
	}
}
```

`OpenGL.h`:

```h
#pragma once

#include "Main.h"

namespace OpenGL
{
	typedef void ( APIENTRY *glBegin_t )( GLenum );
	typedef void ( APIENTRY *glVertex3fv_t )( const GLfloat * );
	typedef void ( APIENTRY *glColor4f_t )( float r, float g, float b, float a );

	extern glBegin_t pglBegin;
	extern glVertex3fv_t pglVertex3fv;
	extern glColor4f_t pglColor4f;

	extern bool Hands;

	void APIENTRY Hooked_glBegin ( GLenum mode );
	void APIENTRY Hooked_glVertex3fv ( GLfloat *v );
	void APIENTRY Hooked_glColor4f ( float r, float g, float b, float a );

	void* DetourFunc ( BYTE *src, const BYTE *dst, const int len );
}
```

`Other.cpp`:

```cpp
#include "Other.h"

namespace Client
{
	namespace Functions
	{
		namespace Visuals
		{
			void Other::DrawAimSpot ( )
			{
				cl_entity_s* Entity = SDK::Interfaces::g_pEngine->GetEntityByIndex ( AimBot::Weapons::GetTargetID ( ) );

				if ( AimBot::Weapons::FriendlyFire ( AimBot::Weapons::GetTargetID ( ) ) &&
					AimBot::Weapons::VisibleCheck ( AimBot::Weapons::GetTargetID ( ) ) &&
					g_Info->GetValidationEntity ( Entity ) )
				{
					Vector2D vAim;

					if ( Utils::CalcScreen ( AimBot::Weapons::GetAimHitBoxByIndex ( AimBot::Weapons::GetTargetID ( ) ), vAim ) )
					{
						Vector uppt = AimBot::Weapons::GetAimHitBoxByIndex ( AimBot::Weapons::GetTargetID ( ) ) - g_Info->GetVectorEyePosition ( );

						float Length = uppt.Length ( );

						int size = int ( 3800.0f / Length );

						int x1 = ( int )vAim[0];
						int y1 = int ( vAim[1] - size / 2 );

						int x2 = int ( vAim[0] - size / 2 );
						int y2 = ( int )vAim[1];

						Renderer::g_Drawing->FillArea ( x1, y1, 1, size, 0, 255, 200, 255 );
						Renderer::g_Drawing->FillArea ( x2, y2, size, 1, 0, 255, 200, 255 );
					}
				}
			}

			void Other::DrawAimFOV ( )
			{
				float FOV = 0.0f;

				if ( g_Vars.Aim.FOVDistance && AimBot::Weapons::GetTargetID ( ) )
				{
					cl_entity_s *Entity = SDK::Interfaces::g_pEngine->GetEntityByIndex ( AimBot::Weapons::GetTargetID ( ) );

					Vector uppt = Entity->origin - g_Info->GetVectorEyePosition ( );

					FOV = g_Info->GetShotsFired ( ) >= g_Vars.Weapons[g_Info->GetWeaponID ( )].BulletControl[0] ?
						g_Vars.Weapons[g_Info->GetWeaponID ( )].RecoilFOV : g_Vars.Weapons[g_Info->GetWeaponID ( )].FOV * 500.0f / uppt.Length ( );

					if ( g_Info->GetShotsFired ( ) < g_Vars.Weapons[g_Info->GetWeaponID ( )].BulletControl[0] )
					{
						if ( FOV > g_Vars.Weapons[g_Info->GetWeaponID ( )].FOV * 3.0f )
							FOV = g_Vars.Weapons[g_Info->GetWeaponID ( )].FOV * 3.0f;

						if ( FOV < g_Vars.Weapons[g_Info->GetWeaponID ( )].FOV / 2.0f )
							FOV = g_Vars.Weapons[g_Info->GetWeaponID ( )].FOV / 2.0f;
					}
				}
				else
				{
					FOV = g_Info->GetShotsFired ( ) >= g_Vars.Weapons[g_Info->GetWeaponID ( )].BulletControl[0] ?
						g_Vars.Weapons[g_Info->GetWeaponID ( )].RecoilFOV : g_Vars.Weapons[g_Info->GetWeaponID ( )].FOV;
				}

				FOV = FOV / g_Info->GetFOV ( ) * SDK::Interfaces::g_Screen.iWidth / 2.0f;

				int x = SDK::Interfaces::g_Screen.iWidth / 2 - ( int )Utils::GetPunchScreen ( )[1];
				int y = SDK::Interfaces::g_Screen.iHeight / 2 + ( int )Utils::GetPunchScreen ( )[0];

				Renderer::g_Drawing->Circle ( x, y, ( int )FOV, 100, 1, 255, 255, 255, 255 );
			}

			void Other::DrawPunch ( )
			{
				int x = SDK::Interfaces::g_Screen.iWidth / 2 - ( int )Utils::GetPunchScreen ( )[1] - 1;
				int y = SDK::Interfaces::g_Screen.iHeight / 2 + ( int )Utils::GetPunchScreen ( )[0] - 1;

				Renderer::g_Drawing->FillArea ( x, y, 3, 3, 255, 0, 0, 255 );
			}

			void Other::DrawSpread ( )
			{
				int x = ( int )Spread::GetDrawSpread ( )[0] - 1;
				int y = ( int )Spread::GetDrawSpread ( )[1] - 1;

				Renderer::g_Drawing->FillArea ( x, y, 3, 3, 255, 180, 0, 255 );
			}

			void Other::StatusAimBot ( )
			{
				bool AimBotActive = g_Vars.Aim.Enable && g_Vars.Weapons[g_Info->GetWeaponID ( )].Aim;

				int x = AimBotActive ? SDK::Interfaces::g_Screen.iWidth - 135 : SDK::Interfaces::g_Screen.iWidth - 143;
				int y = 220;

				Renderer::g_Fonts->Print ( x, y, ( BYTE )g_Vars.Other.FontColor[0], ( BYTE )g_Vars.Other.FontColor[1], ( BYTE )g_Vars.Other.FontColor[2], 
					( BYTE )g_Vars.Other.FontColor[3], g_Vars.Other.FontOutline ? FL_OUTLINE : FL_NONE, AimBotActive ? "AIMBOT: ENABLED" : "AIMBOT: DISABLED" );
			}

			void Other::StatusTriggerBot ( )
			{
				bool TriggerActive = g_Vars.Trigger.Enable && g_Vars.TriggerWeapons[g_Info->GetWeaponID ( )].Trigger &&TriggerBot::Trigger::Active;

				int x = TriggerActive ? SDK::Interfaces::g_Screen.iWidth - 167 : SDK::Interfaces::g_Screen.iWidth - 175;
				int y = 235;

				Renderer::g_Fonts->Print ( x, y, ( BYTE )g_Vars.Other.FontColor[0], ( BYTE )g_Vars.Other.FontColor[1], ( BYTE )g_Vars.Other.FontColor[2],
					( BYTE )g_Vars.Other.FontColor[3], g_Vars.Other.FontOutline ? FL_OUTLINE : FL_NONE, TriggerActive ? "TRIGGERBOT: ENABLED" : "TRIGGERBOT: DISABLED" );
			}

			void Other::HUD_Redraw ( )
			{
				if ( g_Info->GetAliveLocal ( ) && !g_Info->GetBadWeapon ( ) )
				{
					if ( g_Vars.Functions.Weapons && g_Vars.Aim.Enable )
					{
						if ( g_Vars.Weapons[g_Info->GetWeaponID ( )].Aim )
						{
							if ( g_Vars.Other.DrawAimSpot ) DrawAimSpot ( );
							if ( g_Vars.Other.DrawAimFOV ) DrawAimFOV ( );
						}

						if ( g_Vars.Other.StatusAimBot ) StatusAimBot ( );
					}

					if ( g_Vars.Functions.TriggerWeapons && g_Vars.Trigger.Enable )
					{
						if ( g_Vars.Other.StatusTriggerBot ) StatusTriggerBot ( );
					}

					if ( g_Vars.Other.DrawPunch ) DrawPunch ( );
					if ( g_Vars.Other.DrawSpread ) DrawSpread ( );
				}
			}
		}
	}
}
```

`Other.h`:

```h
#pragma once

#include "Main.h"

namespace Client
{
	namespace Functions
	{
		namespace Visuals
		{
			class Other
			{
			public:
				static void HUD_Redraw ( );

			private:
				static void DrawAimSpot ( );
				static void DrawAimFOV ( );
				static void DrawPunch ( );
				static void DrawSpread ( );
				static void StatusAimBot ( );
				static void StatusTriggerBot ( );
			};
		}
	}
}
```

`ParseMsg.cpp`:

```cpp
#include "Main.h"

#pragma warning(disable: 4244)

typedef unsigned char byte;
#define true 1

static byte *gpBuf;
static int giSize;
static int giRead;
static int giBadRead;

void BEGIN_READ ( void *buf, int size )
{
	giRead = 0;
	giBadRead = 0;
	giSize = size;
	gpBuf = ( byte* )buf;
}

int READ_CHAR ( void )
{
	if ( giRead + 1 > giSize )
	{
		giBadRead = true;
		return -1;
	}

	int c = ( signed char )gpBuf[giRead];

	giRead++;

	return c;
}

int READ_BYTE ( void )
{
	if ( giRead + 1 > giSize )
	{
		giBadRead = true;
		return -1;
	}

	int c = ( unsigned char )gpBuf[giRead];
	giRead++;

	return c;
}

int READ_SHORT ( void )
{
	if ( giRead + 2 > giSize )
	{
		giBadRead = true;
		return -1;
	}

	int c = ( short )( gpBuf[giRead] + ( gpBuf[giRead + 1] << 8 ) );

	giRead += 2;

	return c;
}

int READ_WORD ( void )
{
	return READ_SHORT ( );
}

int READ_LONG ( void )
{
	if ( giRead + 4 > giSize )
	{
		giBadRead = true;
		return -1;
	}

	int c = gpBuf[giRead] + ( gpBuf[giRead + 1] << 8 ) + ( gpBuf[giRead + 2] << 16 ) + ( gpBuf[giRead + 3] << 24 );

	giRead += 4;

	return c;
}

float READ_FLOAT ( void )
{
	union
	{
		byte    b[4];
		float   f;
		int     l;
	} dat;

	dat.b[0] = gpBuf[giRead];
	dat.b[1] = gpBuf[giRead + 1];
	dat.b[2] = gpBuf[giRead + 2];
	dat.b[3] = gpBuf[giRead + 3];
	giRead += 4;

	return dat.f;
}

char* READ_STRING ( void )
{
	static char string[2048];

	int c;
	int l = 0;

	string[0] = 0;

	do
	{
		if ( giRead + 1 > giSize )
			break;

		c = READ_CHAR ( );

		if ( c == -1 || c == 0 )
			break;

		string[l] = c;
		++l;
	} while ( l < sizeof ( string ) - 1 );

	string[l] = 0;

	return string;
}

float READ_COORD ( void )
{
	return ( float )( READ_SHORT ( ) * ( 1 / 8 ) );
}

float READ_ANGLE ( void )
{
	return ( float )( READ_CHAR ( ) * ( 360 / 256 ) );
}

float READ_HIRESANGLE ( void )
{
	return ( float )( READ_SHORT ( ) * ( 360 / 65536 ) );
}
```

`Recoil.cpp`:

```cpp
#include "Recoil.h"

namespace Client
{
	namespace Functions
	{
		namespace AimBot
		{
			void Recoil::CL_CreateMove ( usercmd_s *cmd )
			{
				static Vector OldPunchAngle;

				if ( cmd->buttons & IN_ATTACK && g_Info->GetWeaponClip ( ) && g_Info->GetWeaponListRifles ( ) )
				{
					Vector PunchAngle, ViewAngles;

					PunchAngle[0] = g_Info->GetVectorPunchAngles ( )[0] * g_Vars.Recoil.Y;
					PunchAngle[1] = g_Info->GetVectorPunchAngles ( )[1] * g_Vars.Recoil.X;

					ViewAngles = cmd->viewangles;
					ViewAngles += OldPunchAngle;
					ViewAngles -= PunchAngle;

					Vector SmoothAngles;

					Utils::SmoothAimAngles ( cmd->viewangles, ViewAngles, SmoothAngles, g_Vars.Recoil.Smooth );

					if ( PunchAngle < OldPunchAngle )
					{
						if ( g_Info->GetShotsFired ( ) >= g_Vars.Recoil.BulletStart && !Weapons::GetIsFOVByIndex ( Weapons::GetTargetID ( ) ) )
						{
							ClampAngles ( SmoothAngles );

							cmd->viewangles = SmoothAngles;

							SDK::Interfaces::g_pEngine->SetViewAngles ( cmd->viewangles );
						}
					}

					OldPunchAngle = PunchAngle;
				}
				else
					OldPunchAngle = Vector ( 0.0f );
			}
		}
	}
}
```

`Recoil.h`:

```h
#pragma once

#include "Main.h"

namespace Client
{
	namespace Functions
	{
		namespace AimBot
		{
			class Recoil
			{
			public:
				static void CL_CreateMove ( usercmd_s *cmd );
			};
		}
	}
}
```

`ScreenInfo.cpp`:

```cpp
#include "ScreenInfo.h"

namespace Client
{
	namespace Functions
	{
		namespace Visuals
		{
			KeysStruct ScreenInfo::Keys;
			ScrollStruct ScreenInfo::Scroll;

			BYTE ScreenInfo::FontColor[4];

			void ScreenInfo::SetJumpPressed ( bool JumpPressed )
			{
				Scroll.JumpPressed = JumpPressed;
			}

			void ScreenInfo::SetDuckPressed ( bool DuckPressed )
			{
				Scroll.DuckPressed = DuckPressed;
			}

			void ScreenInfo::SetScrollJump ( bool ScrollJump )
			{
				Scroll.ScrollJump = ScrollJump;
			}

			void ScreenInfo::SetScrollDuck ( bool ScrollDuck )
			{
				Scroll.ScrollDuck = ScrollDuck;
			}

			bool ScreenInfo::GetJumpPressed ( )
			{
				return Scroll.JumpPressed;
			}

			bool ScreenInfo::GetDuckPressed ( )
			{
				return Scroll.DuckPressed;
			}

			void ScreenInfo::SetColor ( )
			{
				FontColor[0] = BYTE ( g_Vars.ScreenInfo.FontColor[0] );
				FontColor[1] = BYTE ( g_Vars.ScreenInfo.FontColor[1] );
				FontColor[2] = BYTE ( g_Vars.ScreenInfo.FontColor[2] );
				FontColor[3] = BYTE ( g_Vars.ScreenInfo.FontColor[3] );
			}

			void ScreenInfo::DrawFPS ( )
			{
				Renderer::g_Fonts->Print ( 8, 15, FontColor[0], FontColor[1], FontColor[2], FontColor[3], g_Vars.ScreenInfo.FontOutline ?
					FL_OUTLINE : FL_NONE, g_Vars.ScreenInfo.FPS >= 2.0f ? "%.1f fps" : "%.0f fps", 1.0f / g_Info->GetFrameTime ( ) );
			}

			void ScreenInfo::DrawCopyright ( )
			{
				if ( g_Vars.ScreenInfo.Copyright == 1.0f )
				{
					Renderer::g_Fonts->Print ( SDK::Interfaces::g_Screen.iWidth - 118, 15, FontColor[0], FontColor[1],
						FontColor[2], FontColor[3], g_Vars.ScreenInfo.FontOutline ? FL_OUTLINE : FL_NONE, "Hpp Hack v3.3" );
				}
				else if ( g_Vars.ScreenInfo.Copyright >= 2.0f )
				{
					Renderer::g_Fonts->Print ( SDK::Interfaces::g_Screen.iWidth / 2, 15, FontColor[0], FontColor[1], FontColor[2],
						FontColor[3], g_Vars.ScreenInfo.FontOutline ? FL_CENTER | FL_OUTLINE : FL_CENTER, "Hpp Hack v3.3" );
				}
			}

			void ScreenInfo::DrawTime ( )
			{
				if ( g_Vars.ScreenInfo.Time == 1.0f )
				{
					char TimeString[9];

					_strtime_s ( TimeString );

					Renderer::g_Fonts->Print ( SDK::Interfaces::g_Screen.iWidth - 78, g_Vars.ScreenInfo.Copyright != 1.0f ? 15 : 35, FontColor[0],
						FontColor[1], FontColor[2], FontColor[3], g_Vars.ScreenInfo.FontOutline ? FL_OUTLINE : FL_NONE, "%s", TimeString );
				}
				else if ( g_Vars.ScreenInfo.Time >= 2.0f )
				{
					char DateString[9], TimeString[9];

					_strdate_s ( DateString );
					_strtime_s ( TimeString );

					Renderer::g_Fonts->Print ( SDK::Interfaces::g_Screen.iWidth - 118, g_Vars.ScreenInfo.Copyright != 1.0f ? 15 : 35, FontColor[0],
						FontColor[1], FontColor[2], FontColor[3], g_Vars.ScreenInfo.FontOutline ? FL_OUTLINE : FL_NONE, "Time: %s", TimeString );

					Renderer::g_Fonts->Print ( SDK::Interfaces::g_Screen.iWidth - 118, g_Vars.ScreenInfo.Copyright != 1.0f ? 30 : 50, FontColor[0],
						FontColor[1], FontColor[2], FontColor[3], g_Vars.ScreenInfo.FontOutline ? FL_OUTLINE : FL_NONE, "Date: %s", DateString );
				}
			}

			void ScreenInfo::DrawShowKeys ( )
			{
				float flClientTime = SDK::Interfaces::g_pEngine->GetClientTime ( );

				if ( g_Vars.ScreenInfo.ShowKeys >= 2.0f )
				{
					if ( Scroll.ScrollJump )
					{
						++Scroll.ScrollCounter[0];

						Scroll.flLastScrollTime[0] = flClientTime + 0.15f;
					}

					if ( Scroll.ScrollDuck )
					{
						++Scroll.ScrollCounter[1];

						Scroll.flLastScrollTime[1] = flClientTime + 0.15f;
					}
				}

				int ShowKeysForwardX = Keys.Forward ? ( SDK::Interfaces::g_Screen.iWidth / 2 ) - 1 : SDK::Interfaces::g_Screen.iWidth / 2;
				int ShowKeysForwardY = int ( SDK::Interfaces::g_Screen.iHeight / 2.35f );

				Renderer::g_Fonts->Print ( ShowKeysForwardX, ShowKeysForwardY, FontColor[0], FontColor[1], FontColor[2], Keys.Forward ? 
					255 : 200, g_Vars.ScreenInfo.FontOutline ? FL_CENTER | FL_OUTLINE : FL_CENTER, "  %s  ", Keys.Forward ? "W" : "." );

				int ShowKeysMoveRightX = Keys.MoveRight ? ( SDK::Interfaces::g_Screen.iWidth / 2 ) + 15 : ( SDK::Interfaces::g_Screen.iWidth / 2 ) + 16;
				int ShowKeysMoveRightY = ShowKeysForwardY + 18;

				Renderer::g_Fonts->Print ( ShowKeysMoveRightX, ShowKeysMoveRightY, FontColor[0], FontColor[1], FontColor[2], Keys.MoveRight ? 
					255 : 200, g_Vars.ScreenInfo.FontOutline ? FL_CENTER | FL_OUTLINE : FL_CENTER, "%s", Keys.MoveRight ? "D" : "." );

				int ShowKeysMoveLeftX = Keys.MoveLeft ? ( SDK::Interfaces::g_Screen.iWidth / 2 ) - 15 : ( SDK::Interfaces::g_Screen.iWidth / 2 ) - 16;
				int ShowKeysMoveLeftY = ShowKeysMoveRightY;

				Renderer::g_Fonts->Print ( ShowKeysMoveLeftX, ShowKeysMoveLeftY, FontColor[0], FontColor[1], FontColor[2], Keys.MoveLeft ? 
					255 : 200, g_Vars.ScreenInfo.FontOutline ? FL_CENTER | FL_OUTLINE : FL_CENTER, "%s", Keys.MoveLeft ? "A" : "." );

				int ShowKeysBackwardX = Keys.Backward ? ( SDK::Interfaces::g_Screen.iWidth / 2 ) - 1 : SDK::Interfaces::g_Screen.iWidth / 2;
				int ShowKeysBackwardY = ShowKeysMoveRightY;

				Renderer::g_Fonts->Print ( ShowKeysBackwardX, ShowKeysBackwardY, FontColor[0], FontColor[1], FontColor[2], Keys.Backward ? 
					255 : 200, g_Vars.ScreenInfo.FontOutline ? FL_CENTER | FL_OUTLINE : FL_CENTER, "%s", Keys.Backward ? "S" : "." );

				int ShowKeysJumpX = SDK::Interfaces::g_Screen.iWidth / 2 + 45;
				int ShowKeysJumpY = Keys.Jump ? ShowKeysForwardY : ShowKeysForwardY + 2;

				Renderer::g_Fonts->Print ( ShowKeysJumpX, ShowKeysJumpY, FontColor[0], FontColor[1], FontColor[2], Keys.Jump ? 
					255 : 200, g_Vars.ScreenInfo.FontOutline ? FL_CENTER | FL_OUTLINE : FL_CENTER, "%s", Keys.Jump ? "jump" : "-" );

				if ( g_Vars.ScreenInfo.ShowKeys >= 2.0f )
				{
					if ( Scroll.flLastScrollTime[0] - flClientTime > 1.0f )
						Scroll.flLastScrollTime[0] = 0.0f;

					if ( Scroll.flLastScrollTime[0] > flClientTime )
					{
						Renderer::g_Fonts->Print ( ShowKeysJumpX + 60, ShowKeysForwardY, FontColor[0], FontColor[1], FontColor[2],
							255, g_Vars.ScreenInfo.FontOutline ? FL_CENTER | FL_OUTLINE : FL_CENTER, "scroll: %d", Scroll.ScrollCounter[0] );
					}
					else
					{
						if ( Scroll.ScrollCounter[0] > 0 )
							Scroll.ScrollCounter[0] = 0;
					}

					Scroll.ScrollJump = false;
					Scroll.JumpPressed = false;
				}

				int ShowKeysDuckX = ShowKeysJumpX;
				int ShowKeysDuckY = Keys.Duck ? ShowKeysMoveRightY : ShowKeysMoveRightY + 2;

				Renderer::g_Fonts->Print ( ShowKeysDuckX, ShowKeysDuckY, FontColor[0], FontColor[1], FontColor[2], Keys.Duck ? 
					255 : 200, g_Vars.ScreenInfo.FontOutline ? FL_CENTER | FL_OUTLINE : FL_CENTER, "%s", Keys.Duck ? "duck" : "-" );

				if ( g_Vars.ScreenInfo.ShowKeys >= 2.0f )
				{
					if ( Scroll.flLastScrollTime[1] - flClientTime > 1.0f )
						Scroll.flLastScrollTime[1] = 0.0f;

					if ( Scroll.flLastScrollTime[1] > flClientTime )
					{
						Renderer::g_Fonts->Print ( ShowKeysDuckX + 60, ShowKeysMoveRightY, FontColor[0], FontColor[1], FontColor[2],
							255, g_Vars.ScreenInfo.FontOutline ? FL_CENTER | FL_OUTLINE : FL_CENTER, "scroll: %d", Scroll.ScrollCounter[1] );
					}
					else
					{
						if ( Scroll.ScrollCounter[1] > 0 )
							Scroll.ScrollCounter[1] = 0;
					}

					Scroll.ScrollDuck = false;
					Scroll.DuckPressed = false;
				}
			}

			void ScreenInfo::DrawKreedzInfo ( )
			{
				if ( g_Vars.ScreenInfo.KreedzInfo == 1.0f )
				{
					int x = SDK::Interfaces::g_Screen.iWidth / 2;
					int y = int ( SDK::Interfaces::g_Screen.iHeight / 1.75f + 100 );

					Renderer::g_Fonts->Print ( x, y, FontColor[0], FontColor[1], FontColor[2], FontColor[3],  g_Vars.ScreenInfo.FontOutline ? 
						FL_CENTER | FL_OUTLINE : FL_CENTER, "%.0f units/sec", SDK::Interfaces::g_pPlayerMove->velocity.LengthXY ( ) );
				}
				else if ( g_Vars.ScreenInfo.KreedzInfo >= 2.0f )
				{
					int x = SDK::Interfaces::g_Screen.iWidth / 2;
					int y = int ( SDK::Interfaces::g_Screen.iHeight / 1.75f );

					Renderer::g_Fonts->Print ( x, y, FontColor[0], FontColor[1], FontColor[2], FontColor[3], g_Vars.ScreenInfo.FontOutline ? 
						FL_CENTER | FL_OUTLINE : FL_CENTER, "HSpeed: %.3f", SDK::Interfaces::g_pPlayerMove->velocity.LengthXY ( ) );

					y += 15;

					Renderer::g_Fonts->Print ( x, y, FontColor[0], FontColor[1], FontColor[2], FontColor[3], g_Vars.ScreenInfo.FontOutline ? 
						FL_CENTER | FL_OUTLINE : FL_CENTER, "VSpeed: %.3f", abs ( SDK::Interfaces::g_pPlayerMove->flFallVelocity ) );

					y += 15;

					Renderer::g_Fonts->Print ( x, y, FontColor[0], FontColor[1], FontColor[2], FontColor[3], g_Vars.ScreenInfo.FontOutline ? 
						FL_CENTER | FL_OUTLINE : FL_CENTER, "Height: %.3f", g_Info->GetHeightGround ( g_Info->GetGroundTrace ( ) ) );

					y += 15;

					Renderer::g_Fonts->Print ( x, y, FontColor[0], FontColor[1], FontColor[2], FontColor[3], g_Vars.ScreenInfo.FontOutline ?
						FL_CENTER | FL_OUTLINE : FL_CENTER, "EdgeDistance: %.3f", g_Info->GetEdgeDistance ( ) );

					y += 15;

					Renderer::g_Fonts->Print ( x, y, FontColor[0], FontColor[1], FontColor[2], FontColor[3], g_Vars.ScreenInfo.FontOutline ? 
						FL_CENTER | FL_OUTLINE : FL_CENTER, "GroundAngle: %.3f", g_Info->GetGroundAngle ( g_Info->GetGroundTrace ( ) ) );

					y += 15;

					Renderer::g_Fonts->Print ( x, y, FontColor[0], FontColor[1], FontColor[2], FontColor[3], g_Vars.ScreenInfo.FontOutline ? 
						FL_CENTER | FL_OUTLINE : FL_CENTER, "FallDamage: %d", g_Info->GetFallDamage ( ) );
				}
			}

			void ScreenInfo::HUD_Redraw ( )
			{
				SetColor ( );

				if ( g_Vars.ScreenInfo.FPS ) DrawFPS ( );
				if ( g_Vars.ScreenInfo.Copyright ) DrawCopyright ( );
				if ( g_Vars.ScreenInfo.Time ) DrawTime ( );

				if ( g_Info->GetAliveLocal ( ) )
				{
					if ( g_Vars.ScreenInfo.KreedzInfo ) DrawKreedzInfo ( );
					if ( g_Vars.ScreenInfo.ShowKeys ) DrawShowKeys ( );
				}
			}

			void ScreenInfo::CL_CreateMove ( usercmd_s *cmd )
			{
				Keys.Forward = cmd->buttons & IN_FORWARD;
				Keys.Backward = cmd->buttons & IN_BACK;
				Keys.MoveLeft = cmd->buttons & IN_MOVELEFT;
				Keys.MoveRight = cmd->buttons & IN_MOVERIGHT;
				Keys.Duck = cmd->buttons & IN_DUCK;
				Keys.Jump = cmd->buttons & IN_JUMP;
			}
		}
	}
}

```

`ScreenInfo.h`:

```h
#pragma once

#include "Main.h"

namespace Client
{
	namespace Functions
	{
		namespace Visuals
		{
			struct KeysStruct
			{
				bool Forward, Backward;
				bool MoveLeft, MoveRight;
				bool Duck, Jump;
			};

			struct ScrollStruct
			{
				float flLastScrollTime[2];
				BYTE ScrollCounter[2];
				bool ScrollJump, JumpPressed;
				bool ScrollDuck, DuckPressed;
			};

			class ScreenInfo
			{
			public:
				static void SetJumpPressed ( bool JumpPressed );
				static void SetDuckPressed ( bool DuckPressed );
				static void SetScrollJump ( bool ScrollJump );
				static void SetScrollDuck ( bool ScrollDuck );

				static bool GetJumpPressed ( );
				static bool GetDuckPressed ( );

				static void HUD_Redraw ( );
				static void CL_CreateMove ( usercmd_s *cmd );

			private:
				static KeysStruct Keys;
				static ScrollStruct Scroll;

				static BYTE FontColor[4];

				static void SetColor ( );
				static void DrawFPS ( );
				static void DrawCopyright ( );
				static void DrawTime ( );
				static void DrawShowKeys ( );
				static void DrawKreedzInfo ( );
			};
		}
	}
}
```

`Speed.cpp`:

```cpp
#include "Speed.h"

namespace Client
{
	namespace Functions
	{
		namespace Misc
		{
			bool Speed::BoostActive;
			bool Speed::SlowmotionActive;

			void Speed::AdjustSpeed ( double Speed )
			{
				static double LastSpeed = 1.0;

				if ( !Engine::Speed )
					Engine::Speed = Engine::SpeedPtr;

				if ( Speed != LastSpeed )
				{
					*( double* )Engine::Speed = Speed * 1000.0;

					LastSpeed = Speed;
				}
			}

			void Speed::Helper ( )
			{
				if ( SDK::Interfaces::g_pPlayerMove->flags & FL_ONGROUND )
				{
					AdjustSpeed ( g_Vars.Speed.HelperGround );
				}
				else if ( SDK::Interfaces::g_pPlayerMove->movetype == 5 )
				{
					AdjustSpeed ( g_Vars.Speed.HelperLadder );
				}
				else
				{
					AdjustSpeed ( g_Vars.Speed.HelperFly );
				}
			}

			void Speed::Boost ( )
			{
				if ( g_Vars.Speed.Boost > 1.0f )
					AdjustSpeed ( g_Vars.Speed.Boost );
				else
					AdjustSpeed ( 1.0 );
			}

			void Speed::Slowmo ( )
			{
				if ( g_Vars.Speed.Slowmo < 1.0f )
					AdjustSpeed ( g_Vars.Speed.Slowmo );
				else
					AdjustSpeed ( 1.0 );
			}

			void Speed::CL_CreateMove ( )
			{
				if ( g_Vars.Functions.Speed )
				{
					g_Vars.Speed.Helper ? Helper ( ) : AdjustSpeed ( g_Vars.Speed.Player );

					if ( g_Vars.Speed.Engine )
						*Engine::g_Net += g_Vars.Speed.Engine / 1000.0;

					if ( BoostActive ) Boost ( );
					if ( SlowmotionActive ) Slowmo ( );
				}
				else
				{
					AdjustSpeed ( 1.0 );

					*Engine::g_Net += 0.0;
				}
			}
		}
	}
}
```

`Speed.h`:

```h
#pragma once

#include "Main.h"

namespace Client
{
	namespace Functions
	{
		namespace Misc
		{
			class Speed
			{
			public:
				static bool BoostActive, SlowmotionActive;

				static void AdjustSpeed ( double Speed );
				static void CL_CreateMove (  );

			private:
				static void Helper ( );
				static void Boost ( );
				static void Slowmo ( );
			};
		}
	}
}
```

`Spread.cpp`:

```cpp
#include "Spread.h"

namespace Client
{
	LocalSpreadStruct Spread::LocalSpread;

	Vector2D Spread::DrawSpread;

	unsigned int glSeed = 0;

	Vector2D Spread::GetDrawSpread ( )
	{
		return DrawSpread;
	}

	unsigned int SeedTable[256] =
	{
		28985, 27138, 26457, 9451, 17764, 10909, 28790, 8716, 6361, 4853, 17798, 21977, 19643, 20662, 10834, 20103,
		27067, 28634, 18623, 25849, 8576, 26234, 23887, 18228, 32587, 4836, 3306, 1811, 3035, 24559, 18399, 315,
		26766, 907, 24102, 12370, 9674, 2972, 10472, 16492, 22683, 11529, 27968, 30406, 13213, 2319, 23620, 16823,
		10013, 23772, 21567, 1251, 19579, 20313, 18241, 30130, 8402, 20807, 27354, 7169, 21211, 17293, 5410, 19223,
		10255, 22480, 27388, 9946, 15628, 24389, 17308, 2370, 9530, 31683, 25927, 23567, 11694, 26397, 32602, 15031,
		18255, 17582, 1422, 28835, 23607, 12597, 20602, 10138, 5212, 1252, 10074, 23166, 19823, 31667, 5902, 24630,
		18948, 14330, 14950, 8939, 23540, 21311, 22428, 22391, 3583, 29004, 30498, 18714, 4278, 2437, 22430, 3439,
		28313, 23161, 25396, 13471, 19324, 15287, 2563, 18901, 13103, 16867, 9714, 14322, 15197, 26889, 19372, 26241,
		31925, 14640, 11497, 8941, 10056, 6451, 28656, 10737, 13874, 17356, 8281, 25937, 1661, 4850, 7448, 12744,
		21826, 5477, 10167, 16705, 26897, 8839, 30947, 27978, 27283, 24685, 32298, 3525, 12398, 28726, 9475, 10208,
		617, 13467, 22287, 2376, 6097, 26312, 2974, 9114, 21787, 28010, 4725, 15387, 3274, 10762, 31695, 17320,
		18324, 12441, 16801, 27376, 22464, 7500, 5666, 18144, 15314, 31914, 31627, 6495, 5226, 31203, 2331, 4668,
		12650, 18275, 351, 7268, 31319, 30119, 7600, 2905, 13826, 11343, 13053, 15583, 30055, 31093, 5067, 761,
		9685, 11070, 21369, 27155, 3663, 26542, 20169, 12161, 15411, 30401, 7580, 31784, 8985, 29367, 20989, 14203,
		29694, 21167, 10337, 1706, 28578, 887, 3373, 19477, 14382, 675, 7033, 15111, 26138, 12252, 30996, 21409,
		25678, 18555, 13256, 23316, 22407, 16727, 991, 9236, 5373, 29402, 6117, 15241, 27715, 19291, 19888, 19847
	};

	void Spread::GetSpreadOffset ( unsigned int Seed, int Future, Vector &InAngles, Vector &Velocity, Vector &OutAngles )
	{
		Vector Forward, Right, Up, VecDir, View, Dest, Spread;

		SDK::Interfaces::g_Engine.pfnAngleVectors ( InAngles, Forward, Right, Up );

		GetSpreadXY ( Seed, Future, Velocity, Spread );

		VecDir[0] = Forward[0] + Spread[0] * Right[0] + Spread[1] * Up[0];
		View[0] = 8192.0f * VecDir[0];

		VecDir[1] = Forward[1] + Spread[0] * Right[1] + Spread[1] * Up[1];
		View[1] = 8192.0f * VecDir[1];

		VecDir[2] = Forward[2] + Spread[0] * Right[2] + Spread[1] * Up[2];
		View[2] = 8192.0f * VecDir[2];

		VectorAngles ( View, Dest );
		Dest[0] *= -1.0f;

		OutAngles[0] = InAngles[0] - Dest[0];
		OutAngles[1] = InAngles[1] - Dest[1];
		OutAngles[2] = 0.0f;
	}

	void Spread::HUD_PostRunCmd ( struct local_state_s *to, struct usercmd_s *cmd, int runfuncs, double time, unsigned int random_seed )
	{
		if ( runfuncs )
		{
			LocalSpread.RandomSeed = random_seed;
			LocalSpread.GTime = float ( time );
			LocalSpread.PrcFlags = to->client.flags;

			if ( cmd->buttons & IN_ATTACK && WeaponList::CanCurWeaponAttack ( ) )
			{
				PrimaryAttack ( );
			}
			else if ( !( cmd->buttons & ( IN_ATTACK | IN_ATTACK2 ) ) )
			{
				if ( LocalSpread.Firing )
				{
					LocalSpread.Firing = false;

					if ( LocalSpread.Recoil > 15 )
						LocalSpread.Recoil = 15;

					LocalSpread.RecoilTime = float ( time + 0.4 );
				}
				if ( WeaponList::IsCurWeaponSec ( ) )
				{
					LocalSpread.Recoil = 0;
				}
				else if ( LocalSpread.Recoil > 0 )
				{
					if ( LocalSpread.RecoilTime <= time )
					{
						LocalSpread.RecoilTime = float ( LocalSpread.RecoilTime + 0.0225 );
						--LocalSpread.Recoil;
					}
				}
			}

			for ( int i = 0; i < WeaponList::WeaponListIndex; ++i )
			{
				if ( WeaponList::WeaponListData[i].ID == to->client.m_iId )
				{
					if ( !WeaponList::WeaponListData[i].CurWeapon )
					{
						LocalSpread.Recoil = 0;
						LocalSpread.PrevTime = 0.0f;

						DefaultSpread ( WeaponList::WeaponListData[i].ID );

						LocalSpread.RecoilTime = float ( time );
						LocalSpread.Firing = true;
					}

					WeaponList::WeaponListData[i].CurWeapon = true;
				}
				else
					WeaponList::WeaponListData[i].CurWeapon = false;
			}

			for ( BYTE i = 0; i < MAX_WEAPONS; ++i )
			{
				int Index = WeaponList::GetWeaponIndexByID ( i );

				if ( Index == -1 )
					continue;

				to->weapondata[i].m_iId ?
					memcpy ( &WeaponList::WeaponListData[Index].weapondata, &to->weapondata[i], sizeof ( weapon_data_t ) ) :
					memset ( &WeaponList::WeaponListData[Index].weapondata, 0, sizeof ( weapon_data_t ) );
			}

			if ( WeaponList::IsReloading ( ) )
			{
				int ID = WeaponList::GetCurWeaponId ( );

				if ( ID == -1 )
					return;

				LocalSpread.Recoil = 0;
				LocalSpread.PrevTime = 0.0f;

				DefaultSpread ( ID );

				LocalSpread.RecoilTime = float ( time );
				LocalSpread.Firing = false;
			}
		}
	}

	void Spread::CL_CreateMove ( usercmd_s *cmd )
	{
		Vector Offset;

		if ( !g_Info->GetBadWeapon ( ) && g_Info->GetAliveLocal ( ) )
			GetSpreadOffset ( LocalSpread.RandomSeed, 2, cmd->viewangles, SDK::Interfaces::g_pPlayerMove->velocity, Offset );

		g_Info->SetVectorSpreadAngles ( Offset );
	}

	void Spread::DefaultSpread ( int WeaponID )
	{
		if ( WeaponID == WEAPONLIST_DEAGLE )			LocalSpread.SpreadVar = 0.9f;
		else if ( WeaponID == WEAPONLIST_MP5 )			LocalSpread.SpreadVar = 0.35f;
		else if ( WeaponID == WEAPONLIST_AK47 )			LocalSpread.SpreadVar = 0.2f;
		else if ( WeaponID == WEAPONLIST_SG552 )		LocalSpread.SpreadVar = 0.2f;
		else if ( WeaponID == WEAPONLIST_AUG )			LocalSpread.SpreadVar = 0.3f;
		else if ( WeaponID == WEAPONLIST_M4A1 )			LocalSpread.SpreadVar = 0.2f;
		else if ( WeaponID == WEAPONLIST_M249 )			LocalSpread.SpreadVar = 0.2f;
		else if ( WeaponID == WEAPONLIST_MAC10 )		LocalSpread.SpreadVar = 0.15f;
		else if ( WeaponID == WEAPONLIST_UMP45 )		LocalSpread.SpreadVar = 0.5f;
		else if ( WeaponID == WEAPONLIST_TMP )			LocalSpread.SpreadVar = 0.2f;
		else if ( WeaponID == WEAPONLIST_P90 )			LocalSpread.SpreadVar = 0.15f;
		else if ( WeaponID == WEAPONLIST_P228 )			LocalSpread.SpreadVar = 0.9f;
		else if ( WeaponID == WEAPONLIST_FIVESEVEN )	LocalSpread.SpreadVar = 0.92f;
		else if ( WeaponID == WEAPONLIST_ELITE )		LocalSpread.SpreadVar = 0.88f;
		else if ( WeaponID == WEAPONLIST_GLOCK18 )		LocalSpread.SpreadVar = 0.9f;
		else if ( WeaponID == WEAPONLIST_USP )			LocalSpread.SpreadVar = 0.92f;
		else if ( WeaponID == WEAPONLIST_G3SG1 )		LocalSpread.SpreadVar = 0.2f;
		else if ( WeaponID == WEAPONLIST_SG550 )		LocalSpread.SpreadVar = 0.2f;
		else											LocalSpread.SpreadVar = 0.0f;
	}

	void Spread::NoSpread ( )
	{
		Vector SpreadAngles, Forward, Screen;

		pmtrace_t Trace;

		SpreadAngles = g_Info->GetCmdViewAngles ( ) + g_Info->GetVectorSpreadAngles ( );

		SDK::Interfaces::g_Engine.pfnAngleVectors ( SpreadAngles, Forward, 0, 0 );
		SDK::Interfaces::g_Engine.pEventAPI->EV_SetTraceHull ( 2 );

		SDK::Interfaces::g_Engine.pEventAPI->EV_PlayerTrace ( g_Info->GetVectorEyePosition ( ),
			g_Info->GetVectorEyePosition ( ) + Forward * 8192.0f, PM_GLASS_IGNORE, -1, &Trace );

		if ( Utils::CalcScreen ( Trace.endpos, DrawSpread ) )
		{
			DrawSpread[0] = SDK::Interfaces::g_Screen.iWidth - DrawSpread[0];
			DrawSpread[1] = SDK::Interfaces::g_Screen.iHeight - DrawSpread[1];
		}
	}

	unsigned int Spread::U_Random ( )
	{
		glSeed *= 69069;
		glSeed += SeedTable[glSeed & 0xff];

		return ( ++glSeed & 0x0fffffff );
	}

	void Spread::U_Srand ( unsigned int seed )
	{
		glSeed = SeedTable[seed & 0xff];
	}

	int Spread::UTIL_SharedRandomLong ( unsigned int seed, int low, int high )
	{
		unsigned int Range = 0;

		U_Srand ( ( int )seed + low + high );

		Range = high - low + 1;

		if ( !( Range - 1 ) )
		{
			return low;
		}
		else
		{
			int Offset = 0;
			int rnum = 0;

			rnum = U_Random ( );
			Offset = rnum % Range;

			return low + Offset;
		}
	}

	float Spread::UTIL_SharedRandomFloat ( unsigned int seed, float low, float high )
	{
		unsigned int Range = 0;

		U_Srand ( ( int )seed + *( int * )&low + *( int * )&high );

		U_Random ( );
		U_Random ( );

		Range = unsigned int ( high - low );

		if ( !Range )
		{
			return low;
		}
		else
		{
			int TenSixRand = 0;
			float Offset = 0.0f;

			TenSixRand = U_Random ( ) & 65535;
			Offset = ( float )TenSixRand / 65536.0f;

			return low + Offset * Range;
		}
	}

	float Spread::GetVecSpread ( float speed )
	{
		float Spread = 0.0f;

		int ID = g_Info->GetWeaponID ( );

		switch ( ID )
		{
		case WEAPONLIST_DEAGLE:
			if ( LocalSpread.PrcFlags & FL_ONGROUND )
			{
				if ( speed )
				{
					Spread = 0.25f * ( 1.0f - LocalSpread.SpreadVar );
				}
				else if ( LocalSpread.PrcFlags & FL_DUCKING )
				{
					Spread = 0.115f * ( 1.0f - LocalSpread.SpreadVar );
				}
				else
				{
					Spread = 0.13f * ( 1.0f - LocalSpread.SpreadVar );
				}
			}
			else
				Spread = 1.5f * ( 1.0f - LocalSpread.SpreadVar );

			break;

		case WEAPONLIST_ELITE:
			if ( LocalSpread.PrcFlags & FL_ONGROUND )
			{
				if ( speed )
				{
					Spread = 0.175f * ( 1.0f - LocalSpread.SpreadVar );
				}
				else if ( LocalSpread.PrcFlags & FL_DUCKING )
				{
					Spread = 0.08f * ( 1.0f - LocalSpread.SpreadVar );
				}
				else
				{
					Spread = 0.01f * ( 1.0f - LocalSpread.SpreadVar );
				}
			}
			else
				Spread = 1.3f * ( 1.0f - LocalSpread.SpreadVar );

			break;

		case WEAPONLIST_GALIL:
			if ( LocalSpread.PrcFlags & FL_ONGROUND )
			{
				Spread = ( speed > 140.0f ) ? LocalSpread.SpreadVar * 0.07f + 0.04f : LocalSpread.SpreadVar * 0.0375f;
			}
			else
			{
				Spread = LocalSpread.SpreadVar * 0.4f + 0.03f;
			}

			break;

		case WEAPONLIST_FAMAS:
			if ( LocalSpread.PrcFlags & FL_ONGROUND )
			{
				Spread = ( speed > 140.0f ) ? LocalSpread.SpreadVar * 0.07f + 0.03f : LocalSpread.SpreadVar * 0.020f;
			}
			else
			{
				Spread = LocalSpread.SpreadVar * 0.4f + 0.04f;
			}

			break;

		case WEAPONLIST_FIVESEVEN:
			if ( LocalSpread.PrcFlags & FL_ONGROUND )
			{
				if ( speed )
				{
					Spread = 0.255f * ( 1.0f - LocalSpread.SpreadVar );
				}
				else if ( LocalSpread.PrcFlags & FL_DUCKING )
				{
					Spread = 0.075f * ( 1.0f - LocalSpread.SpreadVar );
				}
				else
				{
					Spread = 0.15f * ( 1.0f - LocalSpread.SpreadVar );
				}
			}
			else
				Spread = 1.5f * ( 1.0f - LocalSpread.SpreadVar );

			break;

		case WEAPONLIST_GLOCK18:
			if ( !WeaponList::IsCurWeaponInBurst ( ) )
			{
				if ( LocalSpread.PrcFlags & FL_ONGROUND )
				{
					if ( speed )
					{
						Spread = 0.165f * ( 1.0f - LocalSpread.SpreadVar );
					}
					else if ( LocalSpread.PrcFlags & FL_DUCKING )
					{
						Spread = 0.075f * ( 1.0f - LocalSpread.SpreadVar );
					}
					else
					{
						Spread = 0.01f * ( 1.0f - LocalSpread.SpreadVar );
					}
				}
				else
					Spread = 1.0f - LocalSpread.SpreadVar;
			}
			else
			{
				if ( LocalSpread.PrcFlags & FL_ONGROUND )
				{
					if ( speed )
					{
						Spread = 0.185f * ( 1.0f - LocalSpread.SpreadVar );
					}
					else if ( LocalSpread.PrcFlags & FL_DUCKING )
					{
						Spread = 0.095f * ( 1.0f - LocalSpread.SpreadVar );
					}
					else
					{
						Spread = 0.3f * ( 1.0f - LocalSpread.SpreadVar );
					}
				}
				else
					Spread = 1.2f * ( 1.0f - LocalSpread.SpreadVar );
			}

			break;

		case WEAPONLIST_P228:
			if ( LocalSpread.PrcFlags & FL_ONGROUND )
			{
				if ( speed )
				{
					Spread = 0.255f * ( 1.0f - LocalSpread.SpreadVar );
				}
				else if ( LocalSpread.PrcFlags & FL_DUCKING )
				{
					Spread = 0.075f * ( 1.0f - LocalSpread.SpreadVar );
				}
				else
				{
					Spread = 0.15f * ( 1.0f - LocalSpread.SpreadVar );
				}
			}
			else
				Spread = 1.5f * ( 1.0f - LocalSpread.SpreadVar );

			break;

		case WEAPONLIST_G3SG1:
			if ( LocalSpread.PrcFlags & FL_ONGROUND )
			{
				if ( speed > 100.0f )
				{
					Spread = 0.15f;
				}
				else if ( LocalSpread.PrcFlags & FL_DUCKING )
				{
					Spread = 0.04f * ( 1.0f - LocalSpread.SpreadVar );
				}
				else
				{
					Spread = 0.06f * ( 1.0f - LocalSpread.SpreadVar );
				}
			}
			else
				Spread = 0.45f * ( 1.0f - LocalSpread.SpreadVar );

			if ( !( g_Info->GetFOV ( ) < 90 ) )
				Spread += 0.0016f;

			break;

		case WEAPONLIST_SG550:
			if ( LocalSpread.PrcFlags & FL_ONGROUND )
			{
				if ( speed )
				{
					Spread = 0.15f;
				}
				else if ( LocalSpread.PrcFlags & FL_DUCKING )
				{
					Spread = 0.04f * ( 1.0f - LocalSpread.SpreadVar );
				}
				else
				{
					Spread = 0.05f * ( 1.0f - LocalSpread.SpreadVar );
				}
			}
			else
				Spread = 0.45f * ( 1.0f - LocalSpread.SpreadVar );

			if ( !( g_Info->GetFOV ( ) < 90 ) )
				Spread += 0.025f;

			break;

		case WEAPONLIST_USP:
			if ( !WeaponList::IsCurWeaponSilenced ( ) )
			{
				if ( LocalSpread.PrcFlags & FL_ONGROUND )
				{
					if ( speed )
					{
						Spread = 0.225f * ( 1.0f - LocalSpread.SpreadVar );
					}
					else if ( LocalSpread.PrcFlags & FL_DUCKING )
					{
						Spread = 0.08f * ( 1.0f - LocalSpread.SpreadVar );
					}
					else
					{
						Spread = 0.01f * ( 1.0f - LocalSpread.SpreadVar );
					}
				}
				else
					Spread = 1.2f * ( 1.0f - LocalSpread.SpreadVar );
			}
			else
			{
				if ( LocalSpread.PrcFlags & FL_ONGROUND )
				{
					if ( speed )
					{
						Spread = 0.25f * ( 1.0f - LocalSpread.SpreadVar );
					}
					else if ( LocalSpread.PrcFlags & FL_DUCKING )
					{
						Spread = 0.125f * ( 1.0f - LocalSpread.SpreadVar );
					}
					else
					{
						Spread = 0.15f * ( 1.0f - LocalSpread.SpreadVar );
					}
				}
				else
					Spread = 1.3f * ( 1.0f - LocalSpread.SpreadVar );
			}

			break;

		case WEAPONLIST_AK47:
			if ( LocalSpread.PrcFlags & FL_ONGROUND )
			{
				Spread = ( speed > 140.0f ) ? LocalSpread.SpreadVar * 0.07f + 0.04f : LocalSpread.SpreadVar * 0.0275f;
			}
			else
			{
				Spread = LocalSpread.SpreadVar * 0.4f + 0.04f;
			}

			break;

		case WEAPONLIST_SG552:
			if ( LocalSpread.PrcFlags & FL_ONGROUND )
			{
				Spread = ( speed > 140.0f ) ? LocalSpread.SpreadVar * 0.07f + 0.035f : LocalSpread.SpreadVar * 0.02f;
			}
			else
			{
				Spread = LocalSpread.SpreadVar * 0.4f + 0.035f;
			}

			break;

		case WEAPONLIST_AUG:
			if ( LocalSpread.PrcFlags & FL_ONGROUND )
			{
				Spread = ( speed > 140.0f ) ? LocalSpread.SpreadVar * 0.07f + 0.035f : LocalSpread.SpreadVar * 0.02f;
			}
			else
			{
				Spread = LocalSpread.SpreadVar * 0.4f + 0.035f;
			}

			break;

		case WEAPONLIST_M249:
			if ( LocalSpread.PrcFlags & FL_ONGROUND )
			{
				Spread = ( speed > 140.0f ) ? LocalSpread.SpreadVar * 0.095f + 0.045f : LocalSpread.SpreadVar * 0.03f;
			}
			else
			{
				Spread = LocalSpread.SpreadVar * 0.5f + 0.045f;
			}

			break;

		case WEAPONLIST_M4A1:
			if ( LocalSpread.PrcFlags & FL_ONGROUND )
			{
				if ( !WeaponList::IsCurWeaponSilenced ( ) )
				{
					Spread = ( speed > 140.0f ) ? LocalSpread.SpreadVar * 0.07f + 0.035f : LocalSpread.SpreadVar * 0.02f;
				}
				else
				{
					Spread = ( speed > 140.0f ) ? LocalSpread.SpreadVar * 0.07f + 0.035f : LocalSpread.SpreadVar * 0.025f;
				}
			}
			else
				Spread = LocalSpread.SpreadVar * 0.4f + 0.035f;

			break;

		case WEAPONLIST_MP5:
			Spread = ( LocalSpread.PrcFlags & FL_ONGROUND ) ? 0.04f * LocalSpread.SpreadVar : 0.2f * LocalSpread.SpreadVar;

			break;

		case WEAPONLIST_MAC10:
			Spread = ( LocalSpread.PrcFlags & FL_ONGROUND ) ? 0.03f * LocalSpread.SpreadVar : 0.375f * LocalSpread.SpreadVar;

			break;

		case WEAPONLIST_P90:
			if ( LocalSpread.PrcFlags & FL_ONGROUND )
			{
				Spread = ( speed > 170.0f ) ? LocalSpread.SpreadVar * 0.115f : LocalSpread.SpreadVar * 0.045f;
			}
			else
			{
				Spread = LocalSpread.SpreadVar * 0.3f;
			}

			break;

		case WEAPONLIST_TMP:
			Spread = ( LocalSpread.PrcFlags & FL_ONGROUND ) ? 0.03f * LocalSpread.SpreadVar : 0.25f * LocalSpread.SpreadVar;

			break;

		case WEAPONLIST_UMP45:
			Spread = ( LocalSpread.PrcFlags & FL_ONGROUND ) ? 0.04f * LocalSpread.SpreadVar : 0.24f * LocalSpread.SpreadVar;

			break;

		case WEAPONLIST_AWP:
			if ( LocalSpread.PrcFlags & FL_ONGROUND )
			{
				if ( speed < 10.0f )
				{
					Spread = ( LocalSpread.PrcFlags & FL_DUCKING ) ? 0.0f : 0.001f;
				}
				else if ( speed < 140.0f )
				{
					Spread = 0.01f;
				}
				else
				{
					Spread = 0.25f;
				}
			}
			else
				Spread = 0.85f;

			if ( !( g_Info->GetFOV ( ) < 90 ) )
				Spread += 0.08f;

			break;

		case WEAPONLIST_SCOUT:
			if ( LocalSpread.PrcFlags & FL_ONGROUND )
			{
				if ( speed < 170.0f )
				{
					Spread = ( LocalSpread.PrcFlags & FL_DUCKING ) ? 0.0f : 0.007f;
				}
				else
				{
					Spread = 0.075f;
				}
			}
			else
				Spread = 0.2f;

			if ( !( g_Info->GetFOV ( ) < 90 ) )
				Spread += 0.025f;

			break;

		default:
			Spread = 0.0f;

			break;
		}

		return Spread;
	}

	void Spread::PrimaryAttack ( )
	{
		int ID = WeaponList::GetCurWeaponId ( );

		switch ( ID )
		{
		case WEAPONLIST_DEAGLE:
			if ( LocalSpread.PrevTime )
			{
				LocalSpread.SpreadVar = LocalSpread.SpreadVar - ( 0.35f * ( 0.4f - ( LocalSpread.GTime - LocalSpread.PrevTime ) ) );

				if ( LocalSpread.SpreadVar > 0.9f )
				{
					LocalSpread.SpreadVar = 0.9f;
				}
				else if ( LocalSpread.SpreadVar < 0.55f )
				{
					LocalSpread.SpreadVar = 0.55f;
				}
			}

			++LocalSpread.Recoil;

			LocalSpread.PrevTime = LocalSpread.GTime;

			break;

		case WEAPONLIST_ELITE:
			if ( LocalSpread.PrevTime )
			{
				LocalSpread.SpreadVar = LocalSpread.SpreadVar - ( 0.275f * ( 0.325f - ( LocalSpread.GTime - LocalSpread.PrevTime ) ) );

				if ( LocalSpread.SpreadVar > 0.88f )
				{
					LocalSpread.SpreadVar = 0.88f;
				}
				else if ( LocalSpread.SpreadVar < 0.55f )
				{
					LocalSpread.SpreadVar = 0.55f;
				}
			}

			++LocalSpread.Recoil;

			LocalSpread.PrevTime = LocalSpread.GTime;

			break;

		case WEAPONLIST_GALIL:
			++LocalSpread.Recoil;

			LocalSpread.Firing = true;

			LocalSpread.SpreadVar = ( LocalSpread.Recoil * LocalSpread.Recoil * LocalSpread.Recoil ) / 200.0f + 0.35f;

			if ( LocalSpread.SpreadVar > 1.25f )
				LocalSpread.SpreadVar = 1.25f;

			LocalSpread.PrevTime = LocalSpread.GTime;

			break;

		case WEAPONLIST_FAMAS:
			++LocalSpread.Recoil;

			LocalSpread.Firing = true;

			LocalSpread.SpreadVar = ( LocalSpread.Recoil * LocalSpread.Recoil * LocalSpread.Recoil ) / 215.0f + 0.3f;

			if ( LocalSpread.SpreadVar > 1.0f )
				LocalSpread.SpreadVar = 1.0f;

			LocalSpread.PrevTime = LocalSpread.GTime;

			break;

		case WEAPONLIST_FIVESEVEN:
			if ( LocalSpread.PrevTime )
			{
				LocalSpread.SpreadVar = LocalSpread.SpreadVar - ( 0.25f * ( 0.275f - ( LocalSpread.GTime - LocalSpread.PrevTime ) ) );

				if ( LocalSpread.SpreadVar > 0.92f )
				{
					LocalSpread.SpreadVar = 0.92f;
				}
				else if ( LocalSpread.SpreadVar < 0.725f )
				{
					LocalSpread.SpreadVar = 0.725f;
				}
			}

			++LocalSpread.Recoil;

			LocalSpread.PrevTime = LocalSpread.GTime;

			break;

		case WEAPONLIST_GLOCK18:
			if ( !WeaponList::IsCurWeaponInBurst ( ) )
				++LocalSpread.Recoil;

			if ( LocalSpread.PrevTime )
			{
				LocalSpread.SpreadVar = LocalSpread.SpreadVar - ( 0.275f * ( 0.325f - ( LocalSpread.GTime - LocalSpread.PrevTime ) ) );

				if ( LocalSpread.SpreadVar > 0.9f )
				{
					LocalSpread.SpreadVar = 0.9f;
				}
				else if ( LocalSpread.SpreadVar < 0.6f )
				{
					LocalSpread.SpreadVar = 0.6f;
				}
			}

			LocalSpread.PrevTime = LocalSpread.GTime;

			break;

		case WEAPONLIST_P228:
			if ( LocalSpread.PrevTime )
			{
				LocalSpread.SpreadVar = LocalSpread.SpreadVar - ( 0.3f * ( 0.325f - ( LocalSpread.GTime - LocalSpread.PrevTime ) ) );

				if ( LocalSpread.SpreadVar > 0.9f )
				{
					LocalSpread.SpreadVar = 0.9f;
				}
				else if ( LocalSpread.SpreadVar < 0.6f )
				{
					LocalSpread.SpreadVar = 0.6f;
				}
			}

			++LocalSpread.Recoil;

			LocalSpread.PrevTime = LocalSpread.GTime;

			break;

		case WEAPONLIST_G3SG1:
			if ( LocalSpread.BrokenTime )
			{
				LocalSpread.SpreadVar = 0.55f + ( 0.3f * ( LocalSpread.GTime - LocalSpread.BrokenTime ) );

				if ( LocalSpread.SpreadVar > 0.98f )
					LocalSpread.SpreadVar = 0.98f;
			}

			++LocalSpread.Recoil;

			LocalSpread.BrokenTime = LocalSpread.GTime;

			LocalSpread.Firing = true;

			break;

		case WEAPONLIST_SG550:
			if ( LocalSpread.BrokenTime )
			{
				LocalSpread.SpreadVar = 0.65f + ( 0.35f * ( LocalSpread.GTime - LocalSpread.BrokenTime ) );

				if ( LocalSpread.SpreadVar > 0.98f )
					LocalSpread.SpreadVar = 0.98f;
			}

			++LocalSpread.Recoil;

			LocalSpread.BrokenTime = LocalSpread.GTime;

			LocalSpread.Firing = true;

			break;

		case WEAPONLIST_USP:
			if ( LocalSpread.PrevTime )
			{
				LocalSpread.SpreadVar = LocalSpread.SpreadVar - ( 0.275f * ( 0.3f - ( LocalSpread.GTime - LocalSpread.PrevTime ) ) );

				if ( LocalSpread.SpreadVar > 0.92f )
				{
					LocalSpread.SpreadVar = 0.92f;
				}
				else if ( LocalSpread.SpreadVar < 0.6f )
				{
					LocalSpread.SpreadVar = 0.6f;
				}
			}

			++LocalSpread.Recoil;

			LocalSpread.PrevTime = LocalSpread.GTime;

			break;

		case WEAPONLIST_AK47:
			++LocalSpread.Recoil;

			LocalSpread.Firing = true;

			LocalSpread.SpreadVar = LocalSpread.Recoil * LocalSpread.Recoil * LocalSpread.Recoil / 200.0f + 0.35f;

			if ( LocalSpread.SpreadVar > 1.25f )
				LocalSpread.SpreadVar = 1.25f;

			LocalSpread.PrevTime = LocalSpread.GTime;

			break;

		case WEAPONLIST_SG552:
			++LocalSpread.Recoil;

			LocalSpread.Firing = true;

			LocalSpread.SpreadVar = LocalSpread.Recoil * LocalSpread.Recoil * LocalSpread.Recoil / 220.0f + 0.3f;

			if ( LocalSpread.SpreadVar > 1.0f )
				LocalSpread.SpreadVar = 1.0f;

			LocalSpread.PrevTime = LocalSpread.GTime;

			break;

		case WEAPONLIST_AUG:
			++LocalSpread.Recoil;

			LocalSpread.Firing = true;

			LocalSpread.SpreadVar = LocalSpread.Recoil * LocalSpread.Recoil * LocalSpread.Recoil / 215.0f + 0.3f;

			if ( LocalSpread.SpreadVar > 1.0f )
				LocalSpread.SpreadVar = 1.0f;

			LocalSpread.PrevTime = LocalSpread.GTime;

			break;

		case WEAPONLIST_M249:
			++LocalSpread.Recoil;

			LocalSpread.Firing = true;

			LocalSpread.SpreadVar = LocalSpread.Recoil * LocalSpread.Recoil * LocalSpread.Recoil / 175.0f + 0.4f;

			if ( LocalSpread.SpreadVar > 0.9f )
				LocalSpread.SpreadVar = 0.9f;

			LocalSpread.PrevTime = LocalSpread.GTime;

			break;

		case WEAPONLIST_M4A1:
			++LocalSpread.Recoil;

			LocalSpread.Firing = true;

			LocalSpread.SpreadVar = LocalSpread.Recoil * LocalSpread.Recoil * LocalSpread.Recoil / 220.0f + 0.3f;

			if ( LocalSpread.SpreadVar > 1.0f )
				LocalSpread.SpreadVar = 1.0f;

			LocalSpread.PrevTime = LocalSpread.GTime;

			break;

		case WEAPONLIST_MP5:
			++LocalSpread.Recoil;

			LocalSpread.SpreadVar = LocalSpread.Recoil * LocalSpread.Recoil * LocalSpread.Recoil / 220.01f + 0.45f;

			if ( LocalSpread.SpreadVar > 0.75f )
				LocalSpread.SpreadVar = 0.75f;

			LocalSpread.PrevTime = LocalSpread.GTime;

			LocalSpread.Firing = true;

			break;

		case WEAPONLIST_MAC10:
			++LocalSpread.Recoil;

			LocalSpread.Firing = true;

			LocalSpread.SpreadVar = LocalSpread.Recoil * LocalSpread.Recoil * LocalSpread.Recoil / 200.0f + 0.6f;

			if ( LocalSpread.SpreadVar > 1.65f )
				LocalSpread.SpreadVar = 1.65f;

			LocalSpread.PrevTime = LocalSpread.GTime;

			break;

		case WEAPONLIST_P90:
			++LocalSpread.Recoil;

			LocalSpread.Firing = true;

			LocalSpread.SpreadVar = LocalSpread.Recoil * LocalSpread.Recoil / 175.0f + 0.45f;

			if ( LocalSpread.SpreadVar > 1.0f )
				LocalSpread.SpreadVar = 1.0f;

			LocalSpread.PrevTime = LocalSpread.GTime;

			break;

		case WEAPONLIST_TMP:
			++LocalSpread.Recoil;

			LocalSpread.Firing = true;

			LocalSpread.SpreadVar = LocalSpread.Recoil * LocalSpread.Recoil * LocalSpread.Recoil / 200.0f + 0.55f;

			if ( LocalSpread.SpreadVar > 1.4f )
				LocalSpread.SpreadVar = 1.4f;

			LocalSpread.PrevTime = LocalSpread.GTime;

			break;

		case WEAPONLIST_UMP45:
			++LocalSpread.Recoil;

			LocalSpread.Firing = true;

			LocalSpread.SpreadVar = LocalSpread.Recoil * LocalSpread.Recoil / 210.0f + 0.5f;

			if ( LocalSpread.SpreadVar > 1.0f )
				LocalSpread.SpreadVar = 1.0f;

			LocalSpread.PrevTime = LocalSpread.GTime;

			break;

		case WEAPONLIST_AWP:
			++LocalSpread.Recoil;

			LocalSpread.PrevTime = LocalSpread.GTime;

			LocalSpread.Firing = true;

			break;

		case WEAPONLIST_SCOUT:
			++LocalSpread.Recoil;

			LocalSpread.PrevTime = LocalSpread.GTime;

			LocalSpread.Firing = true;

			break;

		default:

			break;
		}

		return;
	}

	void Spread::VectorAngles ( const Vector &Forward, Vector &Angles )
	{
		Vector vAngles;

		if ( !Forward[1] && !Forward[0] )
		{
			vAngles[0] = 0.0f;
			vAngles[1] = 0.0f;
		}
		else
		{
			vAngles[1] = atan2f ( Forward[1], Forward[0] ) * 180.0f / M_PI_F;

			if ( vAngles[1] < 0.0f )
				vAngles[1] += 360.0f;

			vAngles[2] = sqrtf ( Forward[0] * Forward[0] + Forward[1] * Forward[1] );

			vAngles[0] = atan2f ( Forward[2], vAngles[2] ) * 180.0f / M_PI_F;
		}

		Angles[0] = vAngles[0];
		Angles[1] = vAngles[1];
		Angles[2] = 0.0f;
	}

	void Spread::GetSpreadXY ( unsigned int Seed, int Future, Vector &Velocity, Vector &Vec )
	{
		float VecSpread = 0.0f;

		Vec[0] = UTIL_SharedRandomFloat ( Seed + Future, -0.5f, 0.5f ) + UTIL_SharedRandomFloat ( Seed + 1 + Future, -0.5f, 0.5f );
		Vec[1] = UTIL_SharedRandomFloat ( Seed + 2 + Future, -0.5f, 0.5f ) + UTIL_SharedRandomFloat ( Seed + 3 + Future, -0.5f, 0.5f );

		VecSpread = GetVecSpread ( Velocity.Length ( ) );

		Vec[0] *= VecSpread;
		Vec[1] *= VecSpread;
	}
}
```

`Spread.h`:

```h
#pragma once

#include "Main.h"

namespace Client
{
	struct LocalSpreadStruct
	{
		float GTime, PrevTime, BrokenTime;
		float SpreadVar, RecoilTime;
	
		unsigned int RandomSeed;

		int WeaponState;
		int PrcFlags, Recoil;

		bool Firing;
	};

	class Spread
	{
	public:
		static Vector2D GetDrawSpread ( );

		static void DefaultSpread ( int iWeaponID );
		static void NoSpread ( );
		static void GetSpreadOffset ( unsigned int Seed, int Future, Vector &InAngles, Vector &Velocity, Vector &OutAngles );

		static void HUD_PostRunCmd ( struct local_state_s *to, struct usercmd_s *cmd, int runfuncs, double time, unsigned int random_seed );
		static void CL_CreateMove ( usercmd_s *cmd );	

	private:
		static LocalSpreadStruct LocalSpread;

		static Vector2D DrawSpread;

		static unsigned int U_Random ( );
		static void U_Srand ( unsigned int seed );
		static int UTIL_SharedRandomLong ( unsigned int seed, int low, int high );
		static float UTIL_SharedRandomFloat ( unsigned int seed, float low, float high );

		static float GetVecSpread ( float speed );
		static void PrimaryAttack ( );
		static void VectorAngles ( const Vector &Forward, Vector &Angles );
		static void GetSpreadXY ( unsigned int Seed, int Future, Vector &Velocity, Vector &Vec );
	};
}
```

`TriggerBot.cpp`:

```cpp
#include "TriggerBot.h"

namespace Client
{
	namespace Functions
	{
		namespace TriggerBot
		{
			PlayerStruct Trigger::Player[33];

			int Trigger::TargetID;

			bool Trigger::Active;
			bool Trigger::TriggerActive;

			bool Trigger::FriendlyFire ( const int &Index )
			{
				return g_Vars.Trigger.FriendlyFire || g_Info->GetPlayerTeamByIndex ( Index ) != g_Info->GetPlayerTeam ( );
			}

			bool Trigger::VisibleCheck ( const int &Index )
			{
				return g_Vars.Trigger.VisibleCheck ? g_Info->GetVisibilityEntityByIndex ( Index ) : true;
			}

			void Trigger::UpdateAimHitBox ( const int &Index, cl_entity_s *Entity )
			{
				Vector vAngles ( 0.0f, Entity->angles[1], 0.0f );
				Vector vForward, vRight, vUp;

				SDK::Interfaces::g_pEngine->pfnAngleVectors ( vAngles, vForward, vRight, vUp );

				float flMaxScreenDistance = FLT_MAX;

				Vector2D Screen, Trigger;

				if ( g_Vars.TriggerWeapons[g_Info->GetWeaponID ( )].ProSpread )
				{
					Screen[0] = Spread::GetDrawSpread ( )[0];
					Screen[1] = Spread::GetDrawSpread ( )[1];
				}
				else
				{
					Screen[0] = SDK::Interfaces::g_Screen.iWidth / 2.0f - Utils::GetPunchScreen ( )[1];
					Screen[1] = SDK::Interfaces::g_Screen.iHeight / 2.0f + Utils::GetPunchScreen ( )[0];
				}

				if ( g_Vars.TriggerWeapons[g_Info->GetWeaponID ( )].OnlyHead )
				{
					Player[Index].vAimHitBox = g_Info->GetHitBoxByIndex ( Index, 11 ) + vForward + vRight + vUp;

					Player[Index].vAimHitBox[1] += 0.8f;
					Player[Index].vAimHitBox[2] -= 0.8f;

					Player[Index].HitBoxNum = 11;
				}
				else
				{
					BYTE HitBoxCheck[] = { 7, 8, 9, 10, 11 };

					for ( int i = 0; i < sizeof ( HitBoxCheck ); ++i )
					{
						Vector HitBox = g_Info->GetHitBoxByIndex ( Index, ( int )HitBoxCheck[i] ) + vForward + vRight + vUp;

						if ( HitBoxCheck[i] == 11 )
						{
							HitBox[1] += 0.8f;
							HitBox[2] -= 0.8f;
						}

						if ( HitBoxCheck[i] == 7 )
						{
							HitBox[2] -= 0.8f;
						}

						if ( Utils::CalcScreen ( HitBox, Trigger ) )
						{
							float flScreenDistance = Utils::CalcDistanceScreen ( Screen, Trigger );

							if ( flScreenDistance < flMaxScreenDistance )
							{
								flMaxScreenDistance = flScreenDistance;

								Player[Index].vAimHitBox = HitBox;

								Player[Index].HitBoxNum = HitBoxCheck[i];
							}
						}
					}
				}
			}

			void Trigger::UpdateAimInfo ( const int &Index )
			{
				cl_entity_s *Entity = SDK::Interfaces::g_pEngine->GetEntityByIndex ( Index );

				UpdateAimHitBox ( Index, Entity );

				Vector2D Trigger;

				if ( Utils::CalcScreen ( Player[Index].vAimHitBox, Trigger ) )
				{
					Vector2D Screen;

					if ( g_Vars.TriggerWeapons[g_Info->GetWeaponID ( )].ProSpread )
					{
						Screen[0] = Spread::GetDrawSpread ( )[0];
						Screen[1] = Spread::GetDrawSpread ( )[1];
					}
					else
					{
						Screen[0] = SDK::Interfaces::g_Screen.iWidth / 2.0f - Utils::GetPunchScreen ( )[1];
						Screen[1] = SDK::Interfaces::g_Screen.iHeight / 2.0f + Utils::GetPunchScreen ( )[0];
					}

					Vector uppt = Entity->origin - g_Info->GetVectorEyePosition ( );

					float FOV = 0.0f;

					switch ( Player[Index].HitBoxNum )
					{
					case 7: FOV = 1.0f * 500.0f / uppt.Length ( ); break;
					case 8: FOV = 1.0f * 500.0f / uppt.Length ( ); break;
					case 9: FOV = 1.0f * 500.0f / uppt.Length ( ); break;
					case 10: FOV = 0.7f * 500.0f / uppt.Length ( ); break;
					case 11: FOV = 0.6f * 500.0f / uppt.Length ( ); break;
					default: FOV = 0.5f * 500.0f / uppt.Length ( );
					}

					FOV = FOV / g_Info->GetFOV ( ) * SDK::Interfaces::g_Screen.iWidth / 2.0f;

					Player[Index].isFOV = Utils::CheckFOV ( Screen, Trigger, FOV );
				}
				else
					Player[Index].isFOV = false;
			}

			void Trigger::UpdatePlayerInfo ( )
			{
				if ( TargetID && !VisibleCheck ( TargetID ) )
				{
					TargetID = 0;
				}

				UpdateTargetID ( );
			}

			void Trigger::UpdateTargetID ( )
			{
				float flMaxScreenDistance = FLT_MAX;

				Vector2D Screen;

				if ( g_Vars.TriggerWeapons[g_Info->GetWeaponID ( )].ProSpread )
				{
					Screen[0] = Spread::GetDrawSpread ( )[0];
					Screen[1] = Spread::GetDrawSpread ( )[1];
				}
				else
				{
					Screen[0] = SDK::Interfaces::g_Screen.iWidth / 2.0f - Utils::GetPunchScreen ( )[1];
					Screen[1] = SDK::Interfaces::g_Screen.iHeight / 2.0f + Utils::GetPunchScreen ( )[0];
				}

				for ( int Index = 1; Index <= SDK::Interfaces::g_pEngine->GetMaxClients ( ); ++Index )
				{
					cl_entity_s* Entity = SDK::Interfaces::g_pEngine->GetEntityByIndex ( Index );

					if ( !FriendlyFire ( Index ) || !VisibleCheck ( Index ) ||
						!g_Info->GetValidationEntity ( Entity ) || g_Info->GetLocalIndex ( ) == Index )
					{
						continue;
					}

					Vector2D Trigger;

					if ( Utils::CalcScreen ( Player[Index].vAimHitBox, Trigger ) )
					{
						float flScreenDistance = Utils::CalcDistanceScreen ( Screen, Trigger );

						if ( flScreenDistance < flMaxScreenDistance )
						{
							flMaxScreenDistance = flScreenDistance;
							TargetID = Index;
						}
					}
				}
			}

			void Trigger::CL_CreateMove ( usercmd_s *cmd )
			{
				if ( !g_Info->GetWeaponClip ( ) )
				{
					return;
				}

				cl_entity_s* Entity = SDK::Interfaces::g_pEngine->GetEntityByIndex ( TargetID );

				if ( Active && g_Info->GetValidationEntity ( Entity ) )
				{
					if ( !Player[TargetID].isFOV )
					{
						return;
					}

					if ( g_Vars.Trigger.SnipersOnlyInZoom && g_Info->GetWeaponListSnipers ( ) && g_Info->GetFOV ( ) == 90 )
					{
						return;
					}

					g_Info->GetNextPrimaryAttack ( ) > 0.0f ? cmd->buttons &= ~IN_ATTACK : cmd->buttons |= IN_ATTACK;
				}
				else
				{
					Player[TargetID].isFOV = false;

					TargetID = 0;
				}
			}
		}
	}
}
```

`TriggerBot.h`:

```h
#pragma once

#include "Main.h"

namespace Client
{
	namespace Functions
	{
		namespace TriggerBot
		{
			struct PlayerStruct
			{
				Vector vAimHitBox;
				int HitBoxNum;
				bool isFOV;
			};

			class Trigger
			{
			public:
				static bool Active;

				inline static Vector GetAimHitBoxByIndex ( const int &Index )
				{
					return Player[Index].vAimHitBox;
				}

				inline static int GetHitBoxNumByIndex ( const int &Index )
				{
					return Player[Index].HitBoxNum;
				}

				inline static bool GetIsFOVByIndex ( const int &Index )
				{
					return Player[Index].isFOV;
				}

				static bool FriendlyFire ( const int &Index );
				static bool VisibleCheck ( const int &Index );

				static void UpdateAimInfo ( const int &Index );
				static void UpdatePlayerInfo ( );

				static void CL_CreateMove ( usercmd_s *cmd );

			private:
				static PlayerStruct Player[33];

				static int TargetID;
				static bool TriggerActive;

				static void UpdateAimHitBox ( const int &Index, cl_entity_s *Entity );
				static void UpdateTargetID ( );
			};
		}
	}
}
```

`UserMsg.cpp`:

```cpp
#include "UserMsg.h"

using namespace Client::Functions;

pfnUserMsgHook pScoreAtrrib = nullptr;
pfnUserMsgHook pResetHUD = nullptr;
pfnUserMsgHook pSetFOV = nullptr;
pfnUserMsgHook pTeamInfo = nullptr;
pfnUserMsgHook pCurWeapon = nullptr;
pfnUserMsgHook pWeaponList = nullptr;
pfnUserMsgHook pDeathMsg = nullptr;
pfnUserMsgHook pTextMsg = nullptr;

int ScoreAtrrib ( const char *pszName, int iSize, void *pbuf )
{
	int PlayerID = *( uint8_t* )pbuf;
	int Flags = *( uint8_t* )( ( uintptr_t )pbuf + sizeof ( uint8_t ) );

	Client::g_Info->SetPlayerIsAliveByIndex ( PlayerID, !( Flags & ( 1 << 0 ) ) );

	return pScoreAtrrib ( pszName, iSize, pbuf );
}

void AtRoundStart ( )
{
	if ( g_Vars.Functions.BunnyHop )
	{
		Misc::BunnyHop::Active = false;
		Misc::BunnyHop::HelperActive = false;
		Misc::BunnyHop::StandUpActive = false;
	}

	if ( g_Vars.Functions.GroundStrafe )
	{
		Misc::GroundStrafe::Active = false;
		Misc::GroundStrafe::HelperActive = false;
		Misc::GroundStrafe::StandUpActive = false;
	}

	Visuals::ESP::ClearEntity ( );
	Visuals::ESP::ClearSound ( );

	Client::g_Info->SetIsPlanted ( false );

	for ( int Index = 0; Index <= SDK::Interfaces::g_pEngine->GetMaxClients ( ); ++Index )
	{
		if ( Index != Client::g_Info->GetLocalIndex ( ) )
			Client::g_Info->SetPlayerIsDeadByIndex ( Index, false );
	}
}

int ResetHUD ( const char *pszName, int iSize, void *pbuf )
{
	AtRoundStart ( );

	return pResetHUD ( pszName, iSize, pbuf );
}

int SetFOV ( const char *pszName, int iSize, void *pbuf )
{
	BEGIN_READ ( pbuf, iSize );

	Client::g_Info->SetFOV ( READ_BYTE ( ) );

	if ( !Client::g_Info->GetFOV ( ) )
		Client::g_Info->SetFOV ( 90 );

	return pSetFOV ( pszName, iSize, pbuf );
}

int TextMsg ( const char *pszName, int iSize, void *pbuf )
{
	BEGIN_READ ( pbuf, iSize );

	int ID = READ_BYTE ( );

	char *Message = READ_STRING ( );

	if ( *Message )
	{
		if ( !lstrcmpiA ( Message, "#Bomb_Planted" ) )
		{
			Client::g_Info->SetIsPlanted ( true );
		}
		else if ( !lstrcmpiA ( Message, "#Target_Bombed" ) || !lstrcmpiA ( Message, "#Bomb_Defused" ) )
		{
			Client::g_Info->SetIsPlanted ( false );
		}
	}

	return pTextMsg ( pszName, iSize, pbuf );
}

int TeamInfo ( const char *pszName, int iSize, void *pbuf )
{
	BEGIN_READ ( pbuf, iSize );

	cl_entity_s *Entity = SDK::Interfaces::g_Engine.GetLocalPlayer ( );

	int Index = READ_BYTE ( );

	char *Team = READ_STRING ( );

	if ( !lstrcmpiA ( Team, "TERRORIST" ) )
	{
		Client::g_Info->SetPlayerTeamByIndex ( Index, TERRORIST );

		if ( Index == Entity->index )
			Client::g_Info->SetPlayerTeam ( TERRORIST );
	}
	else if ( !lstrcmpiA ( Team, "CT" ) )
	{
		Client::g_Info->SetPlayerTeamByIndex ( Index, CT );

		if ( Index == Entity->index )
			Client::g_Info->SetPlayerTeam ( CT );
	}
	else
	{
		Client::g_Info->SetPlayerTeamByIndex ( Index, SPECTATOR );

		if ( Index == Entity->index )
			Client::g_Info->SetPlayerTeam ( SPECTATOR );
	}

	return pTeamInfo ( pszName, iSize, pbuf );
}

int CurWeapon ( const char *pszName, int iSize, void *pbuf )
{
	BEGIN_READ ( pbuf, iSize );

	int iState = READ_BYTE ( );
	int iWeaponID = READ_CHAR ( );
	int iClip = READ_CHAR ( );

	if ( iState && iWeaponID )
	{
		Client::g_Info->SetWeaponID ( iWeaponID );
		Client::g_Info->SetWeaponClip ( iClip );
	}

	return pCurWeapon ( pszName, iSize, pbuf );
}

int WeaponList ( const char *pszName, int iSize, void *pbuf )
{
	BEGIN_READ ( pbuf, iSize );

	char* WeaponName = READ_STRING ( );

	int Ammo1Type = READ_BYTE ( );
	int Max1 = READ_BYTE ( );

	int Ammo2Type = READ_BYTE ( );
	int Max2 = READ_BYTE ( );

	int Slot = READ_BYTE ( );
	int SlotPos = READ_BYTE ( );

	int ID = READ_BYTE ( );
	int Flags = READ_BYTE ( );

	Client::WeaponList::WeaponListAdd ( WeaponName, Ammo1Type, Max1, Ammo2Type, Max2, Slot, SlotPos, ID, Flags );

	return pWeaponList ( pszName, iSize, pbuf );
}

int DeathMsg ( const char *pszName, int iSize, void *pbuf )
{
	BEGIN_READ ( pbuf, iSize );

	int Killer = READ_BYTE ( );
	int Victim = READ_BYTE ( );
	int HS = READ_BYTE ( );

	char *Weapon = READ_STRING ( );

	Client::g_Info->SetPlayerIsDeadByIndex ( Victim, true );

	return pDeathMsg ( pszName, iSize, pbuf );
}
```

`UserMsg.h`:

```h
#pragma once

#include "Main.h"

int ScoreAtrrib ( const char *pszName, int iSize, void *pbuf );
int ResetHUD ( const char *pszName, int iSize, void *pbuf );
int SetFOV ( const char *pszName, int iSize, void *pbuf );
int TextMsg ( const char *pszName, int iSize, void *pbuf );
int TeamInfo ( const char *pszName, int iSize, void *pbuf );
int CurWeapon ( const char *pszName, int iSize, void *pbuf );
int WeaponList ( const char *pszName, int iSize, void *pbuf );
int DeathMsg ( const char *pszName, int iSize, void *pbuf );

void AtRoundStart ( );

extern pfnUserMsgHook pScoreAtrrib;
extern pfnUserMsgHook pResetHUD;
extern pfnUserMsgHook pSetFOV;
extern pfnUserMsgHook pTeamInfo;
extern pfnUserMsgHook pCurWeapon;
extern pfnUserMsgHook pWeaponList;
extern pfnUserMsgHook pDeathMsg;
extern pfnUserMsgHook pTextMsg;
```

`Utils.cpp`:

```cpp
#include "Utils.h"

namespace Utils
{
	pcmd_t CommandByName ( char* Name )
	{
		pcmd_t pCmd = SDK::Interfaces::g_pEngine->pfnGetCmdList ( );

		while ( pCmd )
		{
			if ( !lstrcmpA ( pCmd->name, Name ) ) return pCmd;

			pCmd = pCmd->next;
		}

		return 0;
	}

	PUserMsg UserMsgByName ( char* MsgName )
	{
		PUserMsg Ptr = SDK::Interfaces::g_pUserMsgBase;

		while ( Ptr->next )
		{
			if ( !lstrcmpA ( Ptr->name, MsgName ) ) return Ptr;

			Ptr = Ptr->next;
		}

		Ptr->pfn = 0;

		return Ptr;
	}

	pfnUserMsgHook HookUserMsg ( char *MsgName, pfnUserMsgHook pfn )
	{
		pfnUserMsgHook pfnOriginal = nullptr;
		PUserMsg Ptr = UserMsgByName ( MsgName );

		if ( Ptr->pfn )
		{
			pfnOriginal = Ptr->pfn;
			Ptr->pfn = pfn;
		}

		return pfnOriginal;
	}

	PEngineMsg EngineMsgByName ( char* MsgName )
	{
		PEngineMsg Ptr = SDK::Interfaces::g_pEngineMsgBase;

		while ( lstrcmpA ( Ptr->name, "End of List." ) )
		{
			if ( !lstrcmpA ( Ptr->name, MsgName ) ) return Ptr;

			++Ptr;
		}

		Ptr->pfn = 0;

		return Ptr;
	}

	pfnEngineMsgHook HookEngineMsg ( char *MsgName, pfnEngineMsgHook pfn )
	{
		pfnEngineMsgHook pfnOriginal = nullptr;
		PEngineMsg Ptr = EngineMsgByName ( MsgName );

		if ( Ptr->pfn )
		{
			pfnOriginal = Ptr->pfn;
			Ptr->pfn = pfn;
		}
		else
		{
			Files::InjectLog ( ENGINEMSG_ERROR, MsgName );
			Utils::Error ( true, ENGINEMSG_ERROR, MsgName );
		}

		return pfnOriginal;
	}

	void HookCommand ( char *CmdName, xcommand_t *CmdPointer, void ( *Function )( void ) )
	{
		pcmd_t pCmd = SDK::Interfaces::g_pEngine->pfnGetCmdList ( );

		while ( pCmd )
		{
			if ( !lstrcmpA ( pCmd->name, CmdName ) )
			{
				*CmdPointer = pCmd->function;
				pCmd->function = ( xcommand_t )( ( void * )Function );
				break;
			}

			pCmd = pCmd->next;
		}
	}

	void Error ( const bool &Exit, char *Message, ... )
	{
		char String[256];

		va_list ArgumentPtr;
		va_start ( ArgumentPtr, Message );
		vsprintf_s ( String, Message, ArgumentPtr );
		va_end ( ArgumentPtr );

		MessageBox ( 0, String, "Hpp Hack", MB_OK | MB_ICONERROR );

		if ( Exit ) ExitProcess ( 0 );
	}

	void native_memcpy ( void* dst, const void* src, size_t count )
	{
		_asm
		{
			mov	edi, [dst]
			mov	esi, [src]
			mov	ecx, [count]
			rep	movsb
		}
	}

	void native_memset ( void *szBuffer, DWORD dwLen, DWORD dwSym )
	{
		_asm
		{
			pushad
			mov edi, [szBuffer]
			mov ecx, [dwLen]
			mov eax, [dwSym]
			rep stosb
			popad
		}
	}

	bool PathFree ( Vector& vInput )
	{
		if ( !vInput ) return false;

		pmtrace_t pTrace;

		SDK::Interfaces::g_pEngine->pEventAPI->EV_SetTraceHull ( 2 );

		SDK::Interfaces::g_pEngine->pEventAPI->EV_PlayerTrace ( Client::g_Info->GetVectorEyePosition ( ),
			vInput, PM_GLASS_IGNORE | PM_STUDIO_BOX, Client::g_Info->GetLocalIndex ( ), &pTrace );

		int Index = SDK::Interfaces::g_pEngine->pEventAPI->EV_IndexFromTrace ( &pTrace );

		if ( Index )
		{
			return true;
		}

		return pTrace.fraction == 1.0f;
	}

	bool CalcScreen ( Vector& pflOrigin, Vector2D& pflVecScreen )
	{
		int Result = SDK::Interfaces::g_pEngine->pTriAPI->WorldToScreen ( pflOrigin, pflVecScreen );

		if ( !Result )
		{
			pflVecScreen[0] = pflVecScreen[0] * ( SDK::Interfaces::g_Screen.iWidth / 2 ) + ( SDK::Interfaces::g_Screen.iWidth / 2 );
			pflVecScreen[1] = -pflVecScreen[1] * ( SDK::Interfaces::g_Screen.iHeight / 2 ) + ( SDK::Interfaces::g_Screen.iHeight / 2 );

			return true;
		}

		return false;
	}

	Vector2D GetPunchScreen ( )
	{
		return Client::g_Info->GetVectorPunchAngles ( ).Make2D ( ) / ( float )Client::g_Info->GetFOV ( ) * ( float )SDK::Interfaces::g_Screen.iWidth / 1.2f;
	}

	Vector2D GetScreen ( )
	{
		Vector2D Screen;

		Screen[0] = SDK::Interfaces::g_Screen.iWidth / 2.0f;
		Screen[1] = SDK::Interfaces::g_Screen.iHeight / 2.0f;

		return Screen;
	}

	void MakeAngle ( const Vector &Angles, usercmd_s *cmd )
	{
		Vector ViewForward, ViewRight, ViewUp, AimForward, AimRight, AimUp, vTemp;

		float NewForward = 0.0f;
		float NewRight = 0.0f;
		float NewUp = 0.0f;

		float Forward = cmd->forwardmove;
		float Right = cmd->sidemove;
		float Up = cmd->upmove;

		cl_entity_s *Local = SDK::Interfaces::g_pEngine->GetLocalPlayer ( );

		SDK::Interfaces::g_pEngine->pfnAngleVectors ( Local->curstate.movetype == MOVETYPE_WALK ?
			Vector ( 0.0f, cmd->viewangles.y, 0.0f ) : cmd->viewangles, ViewForward, ViewRight, ViewUp );

		if ( Local->curstate.movetype == MOVETYPE_WALK && !( SDK::Interfaces::g_pPlayerMove->movetype == 5 ) )
		{
			cmd->viewangles.x = Angles[0];
			cmd->viewangles.y = Angles[1];
		}

		SDK::Interfaces::g_pEngine->pfnAngleVectors ( Local->curstate.movetype == MOVETYPE_WALK ?
			Vector ( 0.0f, cmd->viewangles.y, 0.0f ) : cmd->viewangles, AimForward, AimRight, AimUp );

		NewForward =
			DotProduct ( Forward * ViewForward.Normalize ( ), AimForward ) +
			DotProduct ( Right * ViewRight.Normalize ( ), AimForward ) +
			DotProduct ( Up * ViewUp.Normalize ( ), AimForward );

		NewRight =
			DotProduct ( Forward * ViewForward.Normalize ( ), AimRight ) +
			DotProduct ( Right * ViewRight.Normalize ( ), AimRight ) +
			DotProduct ( Up * ViewUp.Normalize ( ), AimRight );

		NewUp =
			DotProduct ( Forward * ViewForward.Normalize ( ), AimUp ) +
			DotProduct ( Right * ViewRight.Normalize ( ), AimUp ) +
			DotProduct ( Up * ViewUp.Normalize ( ), AimUp );

		cmd->forwardmove = ( Angles[0] > 81.0f ) ? -NewForward : NewForward;
		cmd->sidemove = NewRight;
		cmd->upmove = NewUp;
	}
}
```

`Utils.h`:

```h
#pragma once
#pragma warning (disable: 4996)

#include "Main.h"

namespace Utils
{
	pcmd_t CommandByName ( char* Name );
	PUserMsg UserMsgByName ( char* MsgName );
	pfnUserMsgHook HookUserMsg ( char *MsgName, pfnUserMsgHook pfn );
	PEngineMsg EngineMsgByName ( char* MsgName );
	pfnEngineMsgHook HookEngineMsg ( char *MsgName, pfnEngineMsgHook pfn );

	inline char* ConvertTypeToRenderString ( int Type )
	{
		switch ( Type )
		{
		case 1: return "Software";
		case 2: return "OpenGL";
		case 3: return "D3D";
		default: return "Unknown";
		}
	}

	inline float EndSpeed ( float flStartSpeed, float flGravity, float flFrameTime, float flDistance )
	{
		while ( flDistance > 2.0f )
		{
			flStartSpeed += flGravity * flFrameTime;
			flDistance -= flStartSpeed * flFrameTime;
		}

		return flStartSpeed;
	}

	inline float Interp ( float s1, float s2, float s3, float f1, float f3 )
	{
		if ( s2 == s1 ) return f1;
		if ( s2 == s3 ) return f3;
		if ( s3 == s1 ) return f1;

		return f1 + ( ( s2 - s1 ) / ( s3 - s1 ) ) * ( f3 - f1 );
	}

	void HookCommand ( char *CmdName, xcommand_t *CmdPointer, void ( *Function )( void ) );
	void Error ( const bool &Exit, char *Message, ... );
	void native_memcpy ( void* dst, const void* src, size_t count );
	void native_memset ( void *szBuffer, DWORD dwLen, DWORD dwSym );

	bool PathFree ( Vector& vInput );
	bool CalcScreen ( Vector& pflOrigin, Vector2D& pflVecScreen );

	inline void VectorAngles ( const Vector &Forward, Vector &Angles )
	{
		Vector vAngles;

		if ( !Forward[1] && !Forward[0] )
		{
			vAngles[0] = ( Forward[2] > 0.0f ) ? 270.0f : 90.0f;
			vAngles[1] = 0.0f;
		}
		else
		{
			vAngles[1] = atan2f ( Forward[1], Forward[0] ) * 180.0f / M_PI_F;

			if ( vAngles[1] < 0.0f )
				vAngles[1] += 360.0f;

			vAngles[2] = sqrtf ( POW ( Forward[0] ) + POW ( Forward[1] ) );
			vAngles[0] = atan2f ( -Forward[2], vAngles[2] ) * 180.0f / M_PI_F;

			if ( vAngles[0] < 0.0f )
				vAngles[0] += 360.0f;
		}

		Angles[0] = vAngles[0];
		Angles[1] = vAngles[1];
		Angles[2] = 0.0f;

		while ( Angles[0] < -89.0f )
		{
			Angles[0] += 180.0f;
			Angles[1] += 180.0f;
		}

		while ( Angles[0] > 89.0f )
		{
			Angles[0] -= 180.0f;
			Angles[1] += 180.0f;
		}

		while ( Angles[1] < -180.0f )
			Angles[1] += 360.0f;

		while ( Angles[1] > 180.0f )
			Angles[1] -= 360.0f;
	}

	Vector2D GetPunchScreen ( );
	Vector2D GetScreen ( );

	inline float CalcDistanceScreen ( const Vector2D &flScreenCenter, const Vector2D &flPlayerPosScreen )
	{
		return sqrtf ( POW ( flPlayerPosScreen[0] - flScreenCenter[0] ) + POW ( flPlayerPosScreen[1] - flScreenCenter[1] ) );
	}

	inline float AngleBetvenVectors ( const Vector &a, const Vector &b )
	{
		float l1 = a.Length ( );
		float l2 = b.Length ( );
		float sc = a.x * b.x + a.y * b.y + a.z * b.z;

		return acosf ( sc / ( l1 * l2 ) ) * ( 180.0f / M_PI_F );
	}

	inline void GetSection ( const int& Index, std::string& Weapon )
	{
		switch ( Index )
		{
		case WEAPONLIST_USP:		Weapon = "USP";			break;
		case WEAPONLIST_DEAGLE:		Weapon = "DEagle";		break;
		case WEAPONLIST_P228:		Weapon = "P228";		break;
		case WEAPONLIST_FIVESEVEN:	Weapon = "Five-Seven";	break;
		case WEAPONLIST_ELITE:		Weapon = "Elite";		break;
		case WEAPONLIST_M3:			Weapon = "M3";			break;
		case WEAPONLIST_MP5:		Weapon = "MP5";			break;
		case WEAPONLIST_TMP:		Weapon = "TMP";			break;
		case WEAPONLIST_MAC10:		Weapon = "MAC10";		break;
		case WEAPONLIST_UMP45:		Weapon = "UMP45";		break;
		case WEAPONLIST_P90:		Weapon = "P90";			break;
		case WEAPONLIST_AK47:		Weapon = "AK47";		break;
		case WEAPONLIST_M4A1:		Weapon = "M4A1";		break;
		case WEAPONLIST_FAMAS:		Weapon = "FAMAS";		break;
		case WEAPONLIST_GALIL:		Weapon = "Galil";		break;
		case WEAPONLIST_AUG:		Weapon = "AUG";			break;
		case WEAPONLIST_SG552:		Weapon = "SG552";		break;
		case WEAPONLIST_SG550:		Weapon = "SG550";		break;
		case WEAPONLIST_SCOUT:		Weapon = "Scout";		break;
		case WEAPONLIST_AWP:		Weapon = "AWP";			break;
		case WEAPONLIST_G3SG1:		Weapon = "G3SG1";		break;
		case WEAPONLIST_M249:		Weapon = "M249";		break;
		case WEAPONLIST_XM1014:		Weapon = "XM1014";		break;
		case WEAPONLIST_GLOCK18:	Weapon = "Glock18";		break;
		default:					Weapon = "Glock18";
		}
	}

	void MakeAngle ( const Vector &Angles, usercmd_s *cmd );

	inline void* native_memcpy2 ( void * dst, const void * src, size_t count )
	{
		void *ret = dst;

		while ( --count )
		{
			*( char * )dst = *( char * )src;
			dst = ( char * )dst + 1;
			src = ( char * )src + 1;
		}

		return( ret );
	}

	inline bool CheckFOV ( const Vector2D &dest, const Vector2D &Screen, const float &FOV )
	{
		Vector2D ScreenPos;

		ScreenPos[0] = abs ( dest[0] - Screen[0] );
		ScreenPos[1] = abs ( dest[1] - Screen[1] );

		return ScreenPos[0] <= FOV && ScreenPos[1] <= FOV;
	}

	inline void SmoothAimAngles ( const Vector &MyViewAngles, const Vector &AimAngles, Vector &OutAngles, const float &Smoothing )
	{
		OutAngles = AimAngles - MyViewAngles;

		ClampAngles ( OutAngles );

		OutAngles[0] = OutAngles[0] / Smoothing + MyViewAngles[0];
		OutAngles[1] = OutAngles[1] / Smoothing + MyViewAngles[1];

		ClampAngles ( OutAngles );
	}
}
```

`ValveSDK/Sequence.h`:

```h
//---------------------------------------------------------------------------
// 
//		S c r i p t e d   S e q u e n c e s
// 
//---------------------------------------------------------------------------
#ifndef _INCLUDE_SEQUENCE_H_
#define _INCLUDE_SEQUENCE_H_


#ifndef _DEF_BYTE_
typedef unsigned char byte;
#endif

//---------------------------------------------------------------------------
// client_textmessage_t
//---------------------------------------------------------------------------

#define CLIENT_TEXTMESAGE_S
typedef struct client_textmessage_s
{
	int		effect;
	byte	r1, g1, b1, a1;		// 2 colors for effects
	byte	r2, g2, b2, a2;
	float	x;
	float	y;
	float	fadein;
	float	fadeout;
	float	holdtime;
	float	fxtime;
	const char *pName;
	const char *pMessage;
} client_textmessage_t;


//--------------------------------------------------------------------------
// sequenceDefaultBits_e
//	
// Enumerated list of possible modifiers for a command.  This enumeration
// is used in a bitarray controlling what modifiers are specified for a command.
//---------------------------------------------------------------------------
enum sequenceModifierBits
{
	SEQUENCE_MODIFIER_EFFECT_BIT		= (1 << 1),
	SEQUENCE_MODIFIER_POSITION_BIT		= (1 << 2),
	SEQUENCE_MODIFIER_COLOR_BIT			= (1 << 3),
	SEQUENCE_MODIFIER_COLOR2_BIT		= (1 << 4),
	SEQUENCE_MODIFIER_FADEIN_BIT		= (1 << 5),
	SEQUENCE_MODIFIER_FADEOUT_BIT		= (1 << 6),
	SEQUENCE_MODIFIER_HOLDTIME_BIT		= (1 << 7),
	SEQUENCE_MODIFIER_FXTIME_BIT		= (1 << 8),
	SEQUENCE_MODIFIER_SPEAKER_BIT		= (1 << 9),
	SEQUENCE_MODIFIER_LISTENER_BIT		= (1 << 10),
	SEQUENCE_MODIFIER_TEXTCHANNEL_BIT	= (1 << 11),
};
typedef enum sequenceModifierBits sequenceModifierBits_e ;


//---------------------------------------------------------------------------
// sequenceCommandEnum_e
// 
// Enumerated sequence command types.
//---------------------------------------------------------------------------
enum sequenceCommandEnum_
{
	SEQUENCE_COMMAND_ERROR = -1,
	SEQUENCE_COMMAND_PAUSE = 0,
	SEQUENCE_COMMAND_FIRETARGETS,
	SEQUENCE_COMMAND_KILLTARGETS,
	SEQUENCE_COMMAND_TEXT,
	SEQUENCE_COMMAND_SOUND,
	SEQUENCE_COMMAND_GOSUB,
	SEQUENCE_COMMAND_SENTENCE,
	SEQUENCE_COMMAND_REPEAT,
	SEQUENCE_COMMAND_SETDEFAULTS,
	SEQUENCE_COMMAND_MODIFIER,
	SEQUENCE_COMMAND_POSTMODIFIER,
	SEQUENCE_COMMAND_NOOP,

	SEQUENCE_MODIFIER_EFFECT,
	SEQUENCE_MODIFIER_POSITION,
	SEQUENCE_MODIFIER_COLOR,
	SEQUENCE_MODIFIER_COLOR2,
	SEQUENCE_MODIFIER_FADEIN,
	SEQUENCE_MODIFIER_FADEOUT,
	SEQUENCE_MODIFIER_HOLDTIME,
	SEQUENCE_MODIFIER_FXTIME,
	SEQUENCE_MODIFIER_SPEAKER,
	SEQUENCE_MODIFIER_LISTENER,
	SEQUENCE_MODIFIER_TEXTCHANNEL,
};
typedef enum sequenceCommandEnum_ sequenceCommandEnum_e;


//---------------------------------------------------------------------------
// sequenceCommandType_e
// 
// Typeerated sequence command types.
//---------------------------------------------------------------------------
enum sequenceCommandType_
{
	SEQUENCE_TYPE_COMMAND,
	SEQUENCE_TYPE_MODIFIER,
};
typedef enum sequenceCommandType_ sequenceCommandType_e;


//---------------------------------------------------------------------------
// sequenceCommandMapping_s
// 
// A mapping of a command enumerated-value to its name.
//---------------------------------------------------------------------------
typedef struct sequenceCommandMapping_ sequenceCommandMapping_s;
struct sequenceCommandMapping_
{
	sequenceCommandEnum_e	commandEnum;
	const char*				commandName;
	sequenceCommandType_e	commandType;
};


//---------------------------------------------------------------------------
// sequenceCommandLine_s
// 
// Structure representing a single command (usually 1 line) from a
//	.SEQ file entry.
//---------------------------------------------------------------------------
typedef struct sequenceCommandLine_ sequenceCommandLine_s;
struct sequenceCommandLine_
{
	int						commandType;		// Specifies the type of command
	client_textmessage_t	clientMessage;		// Text HUD message struct
	char*					speakerName;		// Targetname of speaking entity
	char*					listenerName;		// Targetname of entity being spoken to
	char*					soundFileName;		// Name of sound file to play
	char*					sentenceName;		// Name of sentences.txt to play
	char*					fireTargetNames;	// List of targetnames to fire
	char*					killTargetNames;	// List of targetnames to remove
	float					delay;				// Seconds 'till next command
	int						repeatCount;		// If nonzero, reset execution pointer to top of block (N times, -1 = infinite)
	int						textChannel;		// Display channel on which text message is sent
	int						modifierBitField;	// Bit field to specify what clientmessage fields are valid
	sequenceCommandLine_s*	nextCommandLine;	// Next command (linked list)
};


//---------------------------------------------------------------------------
// sequenceEntry_s
// 
// Structure representing a single command (usually 1 line) from a
//	.SEQ file entry.
//---------------------------------------------------------------------------
typedef struct sequenceEntry_ sequenceEntry_s;
struct sequenceEntry_
{
	char*					fileName;		// Name of sequence file without .SEQ extension
	char*					entryName;		// Name of entry label in file
	sequenceCommandLine_s*	firstCommand;	// Linked list of commands in entry
	sequenceEntry_s*		nextEntry;		// Next loaded entry
	qboolean				isGlobal;		// Is entry retained over level transitions?
};



//---------------------------------------------------------------------------
// sentenceEntry_s
// Structure representing a single sentence of a group from a .SEQ
// file entry.  Sentences are identical to entries in sentences.txt, but
// can be unique per level and are loaded/unloaded with the level.
//---------------------------------------------------------------------------
typedef struct sentenceEntry_ sentenceEntry_s;
struct sentenceEntry_
{
	char*					data;			// sentence data (ie "We have hostiles" )
	sentenceEntry_s*		nextEntry;		// Next loaded entry
	qboolean				isGlobal;		// Is entry retained over level transitions?
	unsigned int			index;			// this entry's position in the file.
};

//--------------------------------------------------------------------------
// sentenceGroupEntry_s
// Structure representing a group of sentences found in a .SEQ file.
// A sentence group is defined by all sentences with the same name, ignoring
// the number at the end of the sentence name.  Groups enable a sentence
// to be picked at random across a group.
//--------------------------------------------------------------------------
typedef struct sentenceGroupEntry_ sentenceGroupEntry_s;
struct sentenceGroupEntry_
{
	char*					groupName;		// name of the group (ie CT_ALERT )
	unsigned int			numSentences;	// number of sentences in group
	sentenceEntry_s*		firstSentence;	// head of linked list of sentences in group
	sentenceGroupEntry_s*	nextEntry;		// next loaded group
};

#endif /* _INCLUDE_SEQUENCE_H_ */

```

`ValveSDK/archtypes.h`:

```h
//
// Word size dependent definitions
// DAL 1/03
//
#ifndef ARCHTYPES_H
#define ARCHTYPES_H

#include "steamtypes.h"

#ifndef _WIN32
#define MAX_PATH PATH_MAX
#include <sys/stat.h>
#include <sys/types.h>
#include <limits.h>
#include <stddef.h>
#define _S_IREAD S_IREAD
#define _S_IWRITE S_IWRITE
typedef long unsigned int ulong;
#endif

#endif // ARCHTYPES_H

```

`ValveSDK/beamdef.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( BEAMDEFH )
#define BEAMDEFH
#ifdef _WIN32
#pragma once
#endif

#define FBEAM_STARTENTITY		0x00000001
#define FBEAM_ENDENTITY			0x00000002
#define FBEAM_FADEIN			0x00000004
#define FBEAM_FADEOUT			0x00000008
#define FBEAM_SINENOISE			0x00000010
#define FBEAM_SOLID				0x00000020
#define FBEAM_SHADEIN			0x00000040
#define FBEAM_SHADEOUT			0x00000080
#define FBEAM_STARTVISIBLE		0x10000000		// Has this client actually seen this beam's start entity yet?
#define FBEAM_ENDVISIBLE		0x20000000		// Has this client actually seen this beam's end entity yet?
#define FBEAM_ISACTIVE			0x40000000
#define FBEAM_FOREVER			0x80000000

typedef struct beam_s BEAM;
struct beam_s
{
	BEAM		*next;
	int			type;
	int			flags;
	vec3_t		source;
	vec3_t		target;
	vec3_t		delta;
	float		t;		// 0 .. 1 over lifetime of beam
	float		freq;
	float		die;
	float		width;
	float		amplitude;
	float		r, g, b;
	float		brightness;
	float		speed;
	float		frameRate;
	float		frame;
	int			segments;
	int			startEntity;
	int			endEntity;
	int			modelIndex;
	int			frameCount;
	struct model_s		*pFollowModel;
	struct particle_s	*particles;
};

#endif

```

`ValveSDK/cdll_dll.h`:

```h
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  cdll_dll.h

// this file is included by both the game-dll and the client-dll,

#ifndef CDLL_DLL_H
#define CDLL_DLL_H

#define MAX_WEAPONS		32		// ???

#define MAX_WEAPON_SLOTS		5	// hud item selection slots
#define MAX_ITEM_TYPES			6	// hud item selection slots

#define MAX_ITEMS				5	// hard coded item types

#define	HIDEHUD_WEAPONS		( 1<<0 )
#define	HIDEHUD_FLASHLIGHT	( 1<<1 )
#define	HIDEHUD_ALL			( 1<<2 )
#define 	HIDEHUD_HEALTH		( 1<<3 )

#define	MAX_AMMO_TYPES	32		// ???
#define MAX_AMMO_SLOTS  32		// not really slots

#define HUD_PRINTNOTIFY		1
#define HUD_PRINTCONSOLE	2
#define HUD_PRINTTALK		3
#define HUD_PRINTCENTER		4


#define WEAPON_SUIT			31

#endif
```

`ValveSDK/cdll_int.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  cdll_int.h
//
// 4-23-98  
// JOHN:  client dll interface declarations
//

#ifndef CDLL_INT_H
#define CDLL_INT_H

#ifdef __cplusplus
extern "C" {
#endif

#include "const.h"
#include "Sequence.h"

// this file is included by both the engine and the client-dll,
// so make sure engine declarations aren't done twice

typedef int SptiteHandle_t; // handle to a graphic

#define SCRINFO_SCREENFLASH 1
#define SCRINFO_STRETCHED	2

typedef struct SCREENINFO_s
{
	int		iSize;
	int		iWidth;
	int		iHeight;
	int		iFlags;
	int		iCharHeight;
	short	charWidths[256];
} SCREENINFO;


typedef struct client_data_s
{
	// fields that cannot be modified  (ie. have no effect if changed)
	vec3_t origin;

	// fields that can be changed by the cldll
	vec3_t viewangles;
	int		iWeaponBits;
	float	fov;	// field of view
} client_data_t;

typedef struct client_sprite_s
{
	char szName[64];
	char szSprite[64];
	int hspr;
	int iRes;
	wrect_t rc;
} client_sprite_t;

typedef struct hud_player_info_s
{
	char *name;
	short ping;
	byte thisplayer;  // TRUE if this is the calling player

  // stuff that's unused at the moment,  but should be done
	byte spectator;
	byte packetloss;

	char *model;
	short topcolor;
	short bottomcolor;

} hud_player_info_t;


typedef struct cl_enginefuncs_s
{
	// sprite handlers
	HSPRITE						( *pfnSPR_Load )			( const char *szPicName );
	int							( *pfnSPR_Frames )			( HSPRITE hPic );
	int							( *pfnSPR_Height )			( HSPRITE hPic, int frame );
	int							( *pfnSPR_Width )			( HSPRITE hPic, int frame );
	void						( *pfnSPR_Set )				( HSPRITE hPic, int r, int g, int b );
	void						( *pfnSPR_Draw )			( int frame, int x, int y, const wrect_t *prc );
	void						( *pfnSPR_DrawHoles )		( int frame, int x, int y, const wrect_t *prc );
	void						( *pfnSPR_DrawAdditive )	( int frame, int x, int y, const wrect_t *prc );
	void						( *pfnSPR_EnableScissor )	( int x, int y, int width, int height );
	void						( *pfnSPR_DisableScissor )	( void );
	client_sprite_t				*( *pfnSPR_GetList )			( char *psz, int *piCount );

	// screen handlers
	void						( *pfnFillRGBA )			( int x, int y, int width, int height, int r, int g, int b, int a );
	int							( *pfnGetScreenInfo ) 		( SCREENINFO *pscrinfo );
	void						( *pfnSetCrosshair )		( HSPRITE hspr, wrect_t rc, int r, int g, int b );

	// cvar handlers
	struct cvar_s				*( *pfnRegisterVariable )	( char *szName, char *szValue, int flags );
	float						( *pfnGetCvarFloat )		( char *szName );
	char*						( *pfnGetCvarString )		( char *szName );

	// command handlers
	int							( *pfnAddCommand )			( char *cmd_name, void (*function)(void) );
	int							( *pfnHookUserMsg )			( char *szMsgName, pfnUserMsgHook pfn );
	int							( *pfnServerCmd )			( char *szCmdString );
	int							( *pfnClientCmd )			( char *szCmdString );

	void						( *pfnGetPlayerInfo )		( int ent_num, hud_player_info_t *pinfo );

	// sound handlers
	void						( *pfnPlaySoundByName )		( char *szSound, float volume );
	void						( *pfnPlaySoundByIndex )	( int iSound, float volume );

	// vector helpers
	void						( *pfnAngleVectors )		( const float * vecAngles, float * forward, float * right, float * up );

	// text message system
	client_textmessage_t		*( *pfnTextMessageGet )		( const char *pName );
	int							( *pfnDrawCharacter )		( int x, int y, int number, int r, int g, int b );
	int							( *pfnDrawConsoleString )	( int x, int y, char *string );
	void						( *pfnDrawSetTextColor )	( float r, float g, float b );
	void						( *pfnDrawConsoleStringLen )(  const char *string, int *length, int *height );

	void						( *pfnConsolePrint )		( const char *string );
	void						( *pfnCenterPrint )			( const char *string );


// Added for user input processing
	int							( *GetWindowCenterX )		( void );
	int							( *GetWindowCenterY )		( void );
	void						( *GetViewAngles )			( float * );
	void						( *SetViewAngles )			( float * );
	int							( *GetMaxClients )			( void );
	void						( *Cvar_SetValue )			( char *cvar, float value );

	int       					(*Cmd_Argc)					(void);	
	char						*( *Cmd_Argv )				( int arg );
	void						( *Con_Printf )				( char *fmt, ... );
	void						( *Con_DPrintf )			( char *fmt, ... );
	void						( *Con_NPrintf )			( int pos, char *fmt, ... );
	void						( *Con_NXPrintf )			( struct con_nprint_s *info, char *fmt, ... );

	const char					*( *PhysInfo_ValueForKey )	( const char *key );
	const char					*( *ServerInfo_ValueForKey )( const char *key );
	float						( *GetClientMaxspeed )		( void );
	int							( *CheckParm )				( char *parm, char **ppnext );
	void						( *Key_Event )				( int key, int down );
	void						( *GetMousePosition )		( int *mx, int *my );
	int							( *IsNoClipping )			( void );

	struct cl_entity_s			*( *GetLocalPlayer )		( void );
	struct cl_entity_s			*( *GetViewModel )			( void );
	struct cl_entity_s			*( *GetEntityByIndex )		( int idx );

	float						( *GetClientTime )			( void );
	void						( *V_CalcShake )			( void );
	void						( *V_ApplyShake )			( float *origin, float *angles, float factor );

	int							( *PM_PointContents )		( float *point, int *truecontents );
	int							( *PM_WaterEntity )			( float *p );
	struct pmtrace_s			*( *PM_TraceLine )			( float *start, float *end, int flags, int usehull, int ignore_pe );

	struct model_s				*( *CL_LoadModel )			( const char *modelname, int *index );
	int							( *CL_CreateVisibleEntity )	( int type, struct cl_entity_s *ent );

	const struct model_s *		( *GetSpritePointer )		( HSPRITE hSprite );
	void						( *pfnPlaySoundByNameAtLocation )	( char *szSound, float volume, float *origin );

	unsigned short				( *pfnPrecacheEvent )		( int type, const char* psz );
	void						( *pfnPlaybackEvent )		( int flags, const struct edict_s *pInvoker, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2 );
	void						( *pfnWeaponAnim )			( int iAnim, int body );
	float						( *pfnRandomFloat )			( float flLow, float flHigh );
	long						( *pfnRandomLong )			( long lLow, long lHigh );
	void						( *pfnHookEvent )			( char *name, void ( *pfnEvent )( struct event_args_s *args ) );
	int							(*Con_IsVisible)			();
	const char					*( *pfnGetGameDirectory )	( void );
	struct cvar_s				*( *pfnGetCvarPointer )		( const char *szName );
	const char					*( *Key_LookupBinding )		( const char *pBinding );
	const char					*( *pfnGetLevelName )		( void );
	void						( *pfnGetScreenFade )		( struct screenfade_s *fade );
	void						( *pfnSetScreenFade )		( struct screenfade_s *fade );
	void                        *( *VGui_GetPanel )         ( );
	void                         ( *VGui_ViewportPaintBackground ) (int extents[4]);

	byte*						(*COM_LoadFile)				( char *path, int usehunk, int *pLength );
	char*						(*COM_ParseFile)			( char *data, char *token );
	void						(*COM_FreeFile)				( void *buffer );
		
	struct triangleapi_s		*pTriAPI;
	struct efx_api_s			*pEfxAPI;
	struct event_api_s			*pEventAPI;
	struct demo_api_s			*pDemoAPI;
	struct net_api_s			*pNetAPI;
	struct IVoiceTweak_s		*pVoiceTweak;

	// returns 1 if the client is a spectator only (connected to a proxy), 0 otherwise or 2 if in dev_overview mode
	int							( *IsSpectateOnly ) ( void );
	struct model_s				*( *LoadMapSprite )			( const char *filename );

	// file search functions
	void						( *COM_AddAppDirectoryToSearchPath ) ( const char *pszBaseDir, const char *appName );
	int							( *COM_ExpandFilename)				 ( const char *fileName, char *nameOutBuffer, int nameOutBufferSize );

	// User info
	// playerNum is in the range (1, MaxClients)
	// returns NULL if player doesn't exit
	// returns "" if no value is set
	const char					*( *PlayerInfo_ValueForKey )( int playerNum, const char *key );
	void						( *PlayerInfo_SetValueForKey )( const char *key, const char *value );

	// Gets a unique ID for the specified player. This is the same even if you see the player on a different server.
	// iPlayer is an entity index, so client 0 would use iPlayer=1.
	// Returns false if there is no player on the server in the specified slot.
	qboolean					(*GetPlayerUniqueID)(int iPlayer, char playerID[16]);

	// TrackerID access
	int							(*GetTrackerIDForPlayer)(int playerSlot);
	int							(*GetPlayerForTrackerID)(int trackerID);

	// Same as pfnServerCmd, but the message goes in the unreliable stream so it can't clog the net stream
	// (but it might not get there).
	int							( *pfnServerCmdUnreliable )( char *szCmdString );

	void						( *pfnGetMousePos )( struct tagPOINT *ppt );
	void						( *pfnSetMousePos )( int x, int y );
	void						( *pfnSetMouseEnable )( qboolean fEnable );
	struct cvar_s*	( *pfnGetCvarList )( void );
	struct cmd_s* ( *pfnGetCmdList )( void );

	char* ( *pfnGetCvarName )( struct cvar_s* cvar );
	char* ( *pfnGetCmdName )( struct cmd_s* cmd );

	float ( *pfnGetServerTime )( void );
	float ( *pfnGetGravity )( void );
	const struct model_s* ( *pfnPrecacheSprite )( HSPRITE spr );
	void ( *OverrideLightmap )( int override );
	void ( *SetLightmapColor )( float r, float g, float b );
	void ( *SetLightmapDarkness )( float dark );

	//this will always fail with the current engine
	int ( *pfnGetSequenceByName )( int flags, const char* seq );

	void ( *pfnSPR_DrawGeneric )( int frame, int x, int y, const wrect_t *prc, int blendsrc, int blenddst, int unknown1, int unknown2 );

	//this will always fail with engine, don't call
	//it actually has paramenters but i dunno what they do
	void ( *pfnLoadSentence )( void );

	//localizes hud string, uses Legacy font from skin def
	// also supports unicode strings
	int ( *pfnDrawLocalizedHudString )( int x, int y, const char* str, int r, int g, int b );

	//i can't get this to work for some reason, don't use this
	int ( *pfnDrawLocalizedConsoleString )( int x, int y, const char* str );

	//gets keyvalue for local player, useful for querying vgui menus or autohelp
	const char	*(*LocalPlayerInfo_ValueForKey)( const char* key );

	//another vgui2 text drawing function, i dunno how it works
	//it doesn't localize though
	void ( *pfnDrawText_0 )( int x, int y, const char* text, unsigned long font );

	int ( *pfnDrawUnicodeCharacter )( int x, int y, short number, int r, int g, int b, unsigned long hfont );

	//checks sound header of a sound file, determines if its a supported type
	int ( *pfnCheckSoundFile )( const char* path );

	//for condition zero, returns interface from GameUI
	void* ( *GetCareerGameInterface )( void );

	void ( *pfnCvar_Set )( const char* cvar, const char* value );

	//this actually checks for if the CareerGameInterface is found
	//and if a server is being run
	int ( *IsSinglePlayer )( void );

	void ( *pfnPlaySound )( const char* sound, float vol, float pitch );

	void ( *pfnPlayMp3 )( const char* mp3, int flags );

	//get the systems current time as a float
	float ( *Sys_FloatTime )( void );

	void ( *pfnSetArray )( int* array, int size );
	void ( *pfnSetClearArray )( int* array, int size );
	void ( *pfnClearArray )( void );

	void ( *pfnPlaySound2 )( const char* sound, float vol, float pitch );

	void	( *pfnTintRGBA )			( int x, int y, int width, int height, int r, int g, int b, int a );
} cl_enginefunc_t;

#ifndef IN_BUTTONS_H
#include "in_buttons.h"
#endif

#define CLDLL_INTERFACE_VERSION		7

#ifdef __cplusplus
}
#endif

#endif // CDLL_INT_H

```

`ValveSDK/cl_dll.h`:

```h
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  cl_dll.h
//

// 4-23-98  JOHN

//
//  This DLL is linked by the client when they first initialize.
// This DLL is responsible for the following tasks:
//		- Loading the HUD graphics upon initialization
//		- Drawing the HUD graphics every frame
//		- Handling the custum HUD-update packets
//
typedef unsigned char byte;
typedef unsigned short word;
typedef float vec_t;
typedef int (*pfnUserMsgHook)(const char *pszName, int iSize, void *pbuf);

#include "util_vector.h"
#define EXPORT	_declspec( dllexport )

#include "cdll_int.h"
#include "cdll_dll.h"
```

`ValveSDK/cl_entity.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// cl_entity.h
#if !defined( CL_ENTITYH )
#define CL_ENTITYH
#ifdef _WIN32
#pragma once
#endif

typedef struct efrag_s
{
	struct mleaf_s		*leaf;
	struct efrag_s		*leafnext;
	struct cl_entity_s	*entity;
	struct efrag_s		*entnext;
} efrag_t;

typedef struct
{
	byte					mouthopen;		// 0 = mouth closed, 255 = mouth agape
	byte					sndcount;		// counter for running average
	int						sndavg;			// running average
} mouth_t;

typedef struct
{
	float					prevanimtime;  
	float					sequencetime;
	byte					prevseqblending[2];
	vec3_t					prevorigin;
	vec3_t					prevangles;

	int						prevsequence;
	float					prevframe;

	byte					prevcontroller[4];
	byte					prevblending[2];
} latchedvars_t;

typedef struct
{
	// Time stamp for this movement
	float					animtime;

	vec3_t					origin;
	vec3_t					angles;
} position_history_t;

typedef struct cl_entity_s cl_entity_t;

#define HISTORY_MAX		64  // Must be power of 2
#define HISTORY_MASK	( HISTORY_MAX - 1 )


#if !defined( ENTITY_STATEH )
#include "entity_state.h"
#endif

#if !defined( PROGS_H )
#include "progs.h"
#endif

struct cl_entity_s
{
	int						index;      // Index into cl_entities ( should match actual slot, but not necessarily )

	qboolean				player;     // True if this entity is a "player"
	
	entity_state_t			baseline;   // The original state from which to delta during an uncompressed message
	entity_state_t			prevstate;  // The state information from the penultimate message received from the server
	entity_state_t			curstate;   // The state information from the last message received from server

	int						current_position;  // Last received history update index
	position_history_t		ph[ HISTORY_MAX ];   // History of position and angle updates for this player

	mouth_t					mouth;			// For synchronizing mouth movements.

	latchedvars_t			latched;		// Variables used by studio model rendering routines

	// Information based on interplocation, extrapolation, prediction, or just copied from last msg received.
	//
	float					lastmove;

	// Actual render position and angles
	vec3_t					origin;
	vec3_t					angles;

	// Attachment points
	vec3_t					attachment[4];

	// Other entity local information
	int						trivial_accept;

	struct model_s			*model;			// cl.model_precache[ curstate.modelindes ];  all visible entities have a model
	struct efrag_s			*efrag;			// linked list of efrags
	struct mnode_s			*topnode;		// for bmodels, first world node that splits bmodel, or NULL if not split

	float					syncbase;		// for client-side animations -- used by obsolete alias animation system, remove?
	int						visframe;		// last frame this entity was found in an active leaf
	colorVec				cvFloorColor;
};

#endif // !CL_ENTITYH

```

`ValveSDK/com_model.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

// com_model.h
#if !defined( COM_MODEL_H )
#define COM_MODEL_H
#if defined( _WIN32 )
#pragma once
#endif

#define STUDIO_RENDER 1
#define STUDIO_EVENTS 2

#define MAX_CLIENTS			32
#define	MAX_EDICTS			900

#define MAX_MODEL_NAME		64
#define MAX_MAP_HULLS		4
#define	MIPLEVELS			4
#define	NUM_AMBIENTS		4		// automatic ambient sounds
#define	MAXLIGHTMAPS		4
#define	PLANE_ANYZ			5

#define ALIAS_Z_CLIP_PLANE	5

// flags in finalvert_t.flags
#define ALIAS_LEFT_CLIP				0x0001
#define ALIAS_TOP_CLIP				0x0002
#define ALIAS_RIGHT_CLIP			0x0004
#define ALIAS_BOTTOM_CLIP			0x0008
#define ALIAS_Z_CLIP				0x0010
#define ALIAS_ONSEAM				0x0020
#define ALIAS_XY_CLIP_MASK			0x000F

#define	ZISCALE	((float)0x8000)

#define CACHE_SIZE	32		// used to align key data structures

typedef enum
{
	mod_brush, 
	mod_sprite, 
	mod_alias, 
	mod_studio
} modtype_t;

// must match definition in modelgen.h
#ifndef SYNCTYPE_T
#define SYNCTYPE_T

typedef enum
{
	ST_SYNC=0,
	ST_RAND
} synctype_t;

#endif

typedef struct
{
	float		mins[3], maxs[3];
	float		origin[3];
	int			headnode[MAX_MAP_HULLS];
	int			visleafs;		// not including the solid leaf 0
	int			firstface, numfaces;
} dmodel_t;

// plane_t structure
typedef struct mplane_s
{
	vec3_t	normal;			// surface normal
	float	dist;			// closest appoach to origin
	byte	type;			// for texture axis selection and fast side tests
	byte	signbits;		// signx + signy<<1 + signz<<1
	byte	pad[2];
} mplane_t;

typedef struct
{
	vec3_t		position;
} mvertex_t;

typedef struct
{
	unsigned short	v[2];
	unsigned int	cachededgeoffset;
} medge_t;

typedef struct texture_s
{
	char		name[16];
	unsigned	width, height;
	int			anim_total;				// total tenths in sequence ( 0 = no)
	int			anim_min, anim_max;		// time for this frame min <=time< max
	struct texture_s *anim_next;		// in the animation sequence
	struct texture_s *alternate_anims;	// bmodels in frame 1 use these
	unsigned	offsets[MIPLEVELS];		// four mip maps stored
	unsigned	paloffset;
} texture_t;

typedef struct
{
	float		vecs[2][4];		// [s/t] unit vectors in world space. 
								// [i][3] is the s/t offset relative to the origin.
								// s or t = dot(3Dpoint,vecs[i])+vecs[i][3]
	float		mipadjust;		// ?? mipmap limits for very small surfaces
	texture_t	*texture;
	int			flags;			// sky or slime, no lightmap or 256 subdivision
} mtexinfo_t;

typedef struct mnode_s
{
// common with leaf
	int			contents;		// 0, to differentiate from leafs
	int			visframe;		// node needs to be traversed if current
	
	short		minmaxs[6];		// for bounding box culling

	struct mnode_s	*parent;

// node specific
	mplane_t	*plane;
	struct mnode_s	*children[2];	

	unsigned short		firstsurface;
	unsigned short		numsurfaces;
} mnode_t;

typedef struct msurface_s	msurface_t;
typedef struct decal_s		decal_t;

// JAY: Compress this as much as possible
struct decal_s
{
	decal_t		*pnext;			// linked list for each surface
	msurface_t	*psurface;		// Surface id for persistence / unlinking
	short		dx;				// Offsets into surface texture (in texture coordinates, so we don't need floats)
	short		dy;
	short		texture;		// Decal texture
	byte		scale;			// Pixel scale
	byte		flags;			// Decal flags

	short		entityIndex;	// Entity this is attached to
};

typedef struct mleaf_s
{
// common with node
	int			contents;		// wil be a negative contents number
	int			visframe;		// node needs to be traversed if current

	short		minmaxs[6];		// for bounding box culling

	struct mnode_s	*parent;

// leaf specific
	byte		*compressed_vis;
	struct efrag_s	*efrags;

	msurface_t	**firstmarksurface;
	int			nummarksurfaces;
	int			key;			// BSP sequence number for leaf's contents
	byte		ambient_sound_level[NUM_AMBIENTS];
} mleaf_t;

struct msurface_s
{
	int			visframe;		// should be drawn when node is crossed

	int			dlightframe;	// last frame the surface was checked by an animated light
	int			dlightbits;		// dynamically generated. Indicates if the surface illumination 
								// is modified by an animated light.

	mplane_t	*plane;			// pointer to shared plane			
	int			flags;			// see SURF_ #defines

	int			firstedge;	// look up in model->surfedges[], negative numbers
	int			numedges;	// are backwards edges
	
// surface generation data
	struct surfcache_s	*cachespots[MIPLEVELS];

	short		texturemins[2]; // smallest s/t position on the surface.
	short		extents[2];		// ?? s/t texture size, 1..256 for all non-sky surfaces

	mtexinfo_t	*texinfo;		
	
// lighting info
	byte		styles[MAXLIGHTMAPS]; // index into d_lightstylevalue[] for animated lights 
									  // no one surface can be effected by more than 4 
									  // animated lights.
	color24		*samples;
	
	decal_t		*pdecals;
};

typedef struct
{
	int			planenum;
	short		children[2];	// negative numbers are contents
} dclipnode_t;

typedef struct hull_s
{
	dclipnode_t	*clipnodes;
	mplane_t	*planes;
	int			firstclipnode;
	int			lastclipnode;
	vec3_t		clip_mins;
	vec3_t		clip_maxs;
} hull_t;

#if !defined( CACHE_USER ) && !defined( QUAKEDEF_H )
#define CACHE_USER
typedef struct cache_user_s
{
	void	*data;
} cache_user_t;
#endif

typedef struct model_s
{
	char		name[ MAX_MODEL_NAME ];
	qboolean	needload;		// bmodels and sprites don't cache normally

	modtype_t	type;
	int			numframes;
	synctype_t	synctype;
	
	int			flags;

//
// volume occupied by the model
//		
	vec3_t		mins, maxs;
	float		radius;

//
// brush model
//
	int			firstmodelsurface, nummodelsurfaces;

	int			numsubmodels;
	dmodel_t	*submodels;

	int			numplanes;
	mplane_t	*planes;

	int			numleafs;		// number of visible leafs, not counting 0
	struct mleaf_s		*leafs;

	int			numvertexes;
	mvertex_t	*vertexes;

	int			numedges;
	medge_t		*edges;

	int			numnodes;
	mnode_t		*nodes;

	int			numtexinfo;
	mtexinfo_t	*texinfo;

	int			numsurfaces;
	msurface_t	*surfaces;

	int			numsurfedges;
	int			*surfedges;

	int			numclipnodes;
	dclipnode_t	*clipnodes;

	int			nummarksurfaces;
	msurface_t	**marksurfaces;

	hull_t		hulls[MAX_MAP_HULLS];

	int			numtextures;
	texture_t	**textures;

	byte		*visdata;

	color24		*lightdata;

	char		*entities;

//
// additional model data
//
	cache_user_t	cache;		// only access through Mod_Extradata

} model_t;

typedef vec_t vec4_t[4];

typedef struct alight_s
{
	int			ambientlight;	// clip at 128
	int			shadelight;		// clip at 192 - ambientlight
	vec3_t		color;
	float		*plightvec;
} alight_t;

typedef struct auxvert_s
{
	float	fv[3];		// viewspace x, y
} auxvert_t;

#include "custom.h"

#define	MAX_INFO_STRING			256
#define	MAX_SCOREBOARDNAME		32
typedef struct player_info_s
{
	// User id on server
	int		userid;

	// User info string
	char	userinfo[ MAX_INFO_STRING ];

	// Name
	char	name[ MAX_SCOREBOARDNAME ];

	// Spectator or not, unused
	int		spectator;

	int		ping;
	int		packet_loss;

	// skin information
	char	model[MAX_QPATH];
	int		topcolor;
	int		bottomcolor;

	// last frame rendered
	int		renderframe;	

	// Gait frame estimation
	int		gaitsequence;
	float	gaitframe;
	float	gaityaw;
	vec3_t	prevgaitorigin;

	customization_t customdata;
} player_info_t;

#endif // #define COM_MODEL_H

```

`ValveSDK/const.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef CONST_H
#define CONST_H
//
// Constants shared by the engine and dlls
// This header file included by engine files and DLL files.
// Most came from server.h

// edict->flags
#define	FL_FLY					(1<<0)	// Changes the SV_Movestep() behavior to not need to be on ground
#define	FL_SWIM					(1<<1)	// Changes the SV_Movestep() behavior to not need to be on ground (but stay in water)
#define	FL_CONVEYOR				(1<<2)
#define	FL_CLIENT				(1<<3)
#define	FL_INWATER				(1<<4)
#define	FL_MONSTER				(1<<5)
#define	FL_GODMODE				(1<<6)
#define	FL_NOTARGET				(1<<7)
#define	FL_SKIPLOCALHOST		(1<<8)	// Don't send entity to local host, it's predicting this entity itself
#define	FL_ONGROUND				(1<<9)	// At rest / on the ground
#define	FL_PARTIALGROUND		(1<<10)	// not all corners are valid
#define	FL_WATERJUMP			(1<<11)	// player jumping out of water
#define FL_FROZEN				(1<<12) // Player is frozen for 3rd person camera
#define FL_FAKECLIENT			(1<<13)	// JAC: fake client, simulated server side; don't send network messages to them
#define FL_DUCKING				(1<<14)	// Player flag -- Player is fully crouched
#define FL_FLOAT				(1<<15)	// Apply floating force to this entity when in water
#define FL_GRAPHED				(1<<16) // worldgraph has this ent listed as something that blocks a connection

// UNDONE: Do we need these?
#define FL_IMMUNE_WATER			(1<<17)
#define	FL_IMMUNE_SLIME			(1<<18)
#define FL_IMMUNE_LAVA			(1<<19)

#define FL_PROXY				(1<<20)	// This is a spectator proxy
#define FL_ALWAYSTHINK			(1<<21)	// Brush model flag -- call think every frame regardless of nextthink - ltime (for constantly changing velocity/path)
#define FL_BASEVELOCITY			(1<<22)	// Base velocity has been applied this frame (used to convert base velocity into momentum)
#define FL_MONSTERCLIP			(1<<23)	// Only collide in with monsters who have FL_MONSTERCLIP set
#define FL_ONTRAIN				(1<<24) // Player is _controlling_ a train, so movement commands should be ignored on client during prediction.
#define FL_WORLDBRUSH			(1<<25)	// Not moveable/removeable brush entity (really part of the world, but represented as an entity for transparency or something)
#define FL_SPECTATOR            (1<<26) // This client is a spectator, don't run touch functions, etc.
#define FL_CUSTOMENTITY			(1<<29)	// This is a custom entity
#define FL_KILLME				(1<<30)	// This entity is marked for death -- This allows the engine to kill ents at the appropriate time
#define FL_DORMANT				(1<<31)	// Entity is dormant, no updates to client


// Goes into globalvars_t.trace_flags
#define FTRACE_SIMPLEBOX		(1<<0)	// Traceline with a simple box


// walkmove modes
#define	WALKMOVE_NORMAL		0 // normal walkmove
#define WALKMOVE_WORLDONLY	1 // doesn't hit ANY entities, no matter what the solid type
#define WALKMOVE_CHECKONLY	2 // move, but don't touch triggers

// edict->movetype values
#define	MOVETYPE_NONE			0		// never moves
//#define	MOVETYPE_ANGLENOCLIP	1
//#define	MOVETYPE_ANGLECLIP		2
#define	MOVETYPE_WALK			3		// Player only - moving on the ground
#define	MOVETYPE_STEP			4		// gravity, special edge handling -- monsters use this
#define	MOVETYPE_FLY			5		// No gravity, but still collides with stuff
#define	MOVETYPE_TOSS			6		// gravity/collisions
#define	MOVETYPE_PUSH			7		// no clip to world, push and crush
#define	MOVETYPE_NOCLIP			8		// No gravity, no collisions, still do velocity/avelocity
#define	MOVETYPE_FLYMISSILE		9		// extra size to monsters
#define	MOVETYPE_BOUNCE			10		// Just like Toss, but reflect velocity when contacting surfaces
#define MOVETYPE_BOUNCEMISSILE	11		// bounce w/o gravity
#define MOVETYPE_FOLLOW			12		// track movement of aiment
#define	MOVETYPE_PUSHSTEP		13		// BSP model that needs physics/world collisions (uses nearest hull for world collision)

// edict->solid values
// NOTE: Some movetypes will cause collisions independent of SOLID_NOT/SOLID_TRIGGER when the entity moves
// SOLID only effects OTHER entities colliding with this one when they move - UGH!
#define	SOLID_NOT				0		// no interaction with other objects
#define	SOLID_TRIGGER			1		// touch on edge, but not blocking
#define	SOLID_BBOX				2		// touch on edge, block
#define	SOLID_SLIDEBOX			3		// touch on edge, but not an onground
#define	SOLID_BSP				4		// bsp clip, touch on edge, block

// edict->deadflag values
#define	DEAD_NO					0 // alive
#define	DEAD_DYING				1 // playing death animation or still falling off of a ledge waiting to hit ground
#define	DEAD_DEAD				2 // dead. lying still.
#define DEAD_RESPAWNABLE		3
#define DEAD_DISCARDBODY		4

#define	DAMAGE_NO				0
#define	DAMAGE_YES				1
#define	DAMAGE_AIM				2

// entity effects
#define	EF_BRIGHTFIELD			1	// swirling cloud of particles
#define	EF_MUZZLEFLASH 			2	// single frame ELIGHT on entity attachment 0
#define	EF_BRIGHTLIGHT 			4	// DLIGHT centered at entity origin
#define	EF_DIMLIGHT 			8	// player flashlight
#define EF_INVLIGHT				16	// get lighting from ceiling
#define EF_NOINTERP				32	// don't interpolate the next frame
#define EF_LIGHT				64	// rocket flare glow sprite
#define EF_NODRAW				128	// don't draw entity
#define EF_NIGHTVISION			256 // player nightvision
#define EF_SNIPERLASER			512 // sniper laser effect
#define EF_FIBERCAMERA			1024// fiber camera


// entity flags
#define EFLAG_SLERP				1	// do studio interpolation of this entity
		
//
// temp entity events
//
#define	TE_BEAMPOINTS		0		// beam effect between two points
// coord coord coord (start position) 
// coord coord coord (end position) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define	TE_BEAMENTPOINT		1		// beam effect between point and entity
// short (start entity) 
// coord coord coord (end position) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define	TE_GUNSHOT			2		// particle effect plus ricochet sound
// coord coord coord (position) 

#define	TE_EXPLOSION		3		// additive sprite, 2 dynamic lights, flickering particles, explosion sound, move vertically 8 pps
// coord coord coord (position) 
// short (sprite index)
// byte (scale in 0.1's)
// byte (framerate)
// byte (flags)
//
// The Explosion effect has some flags to control performance/aesthetic features:
#define TE_EXPLFLAG_NONE		0	// all flags clear makes default Half-Life explosion
#define TE_EXPLFLAG_NOADDITIVE	1	// sprite will be drawn opaque (ensure that the sprite you send is a non-additive sprite)
#define TE_EXPLFLAG_NODLIGHTS	2	// do not render dynamic lights
#define TE_EXPLFLAG_NOSOUND		4	// do not play client explosion sound
#define TE_EXPLFLAG_NOPARTICLES	8	// do not draw particles


#define	TE_TAREXPLOSION		4		// Quake1 "tarbaby" explosion with sound
// coord coord coord (position) 

#define	TE_SMOKE			5		// alphablend sprite, move vertically 30 pps
// coord coord coord (position) 
// short (sprite index)
// byte (scale in 0.1's)
// byte (framerate)

#define	TE_TRACER			6		// tracer effect from point to point
// coord, coord, coord (start) 
// coord, coord, coord (end)

#define	TE_LIGHTNING		7		// TE_BEAMPOINTS with simplified parameters
// coord, coord, coord (start) 
// coord, coord, coord (end) 
// byte (life in 0.1's) 
// byte (width in 0.1's) 
// byte (amplitude in 0.01's)
// short (sprite model index)

#define	TE_BEAMENTS			8		
// short (start entity) 
// short (end entity) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define	TE_SPARKS			9		// 8 random tracers with gravity, ricochet sprite
// coord coord coord (position) 

#define	TE_LAVASPLASH		10		// Quake1 lava splash
// coord coord coord (position) 

#define	TE_TELEPORT			11		// Quake1 teleport splash
// coord coord coord (position) 

#define TE_EXPLOSION2		12		// Quake1 colormaped (base palette) particle explosion with sound
// coord coord coord (position) 
// byte (starting color)
// byte (num colors)

#define TE_BSPDECAL			13		// Decal from the .BSP file 
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// short (texture index of precached decal texture name)
// short (entity index)
// [optional - only included if previous short is non-zero (not the world)] short (index of model of above entity)

#define TE_IMPLOSION		14		// tracers moving toward a point
// coord, coord, coord (position)
// byte (radius)
// byte (count)
// byte (life in 0.1's) 

#define TE_SPRITETRAIL		15		// line of moving glow sprites with gravity, fadeout, and collisions
// coord, coord, coord (start) 
// coord, coord, coord (end) 
// short (sprite index)
// byte (count)
// byte (life in 0.1's) 
// byte (scale in 0.1's) 
// byte (velocity along vector in 10's)
// byte (randomness of velocity in 10's)

#define TE_BEAM				16		// obsolete

#define TE_SPRITE			17		// additive sprite, plays 1 cycle
// coord, coord, coord (position) 
// short (sprite index) 
// byte (scale in 0.1's) 
// byte (brightness)

#define TE_BEAMSPRITE		18		// A beam with a sprite at the end
// coord, coord, coord (start position) 
// coord, coord, coord (end position) 
// short (beam sprite index) 
// short (end sprite index) 

#define TE_BEAMTORUS		19		// screen aligned beam ring, expands to max radius over lifetime
// coord coord coord (center position) 
// coord coord coord (axis and radius) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define TE_BEAMDISK			20		// disk that expands to max radius over lifetime
// coord coord coord (center position) 
// coord coord coord (axis and radius) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define TE_BEAMCYLINDER		21		// cylinder that expands to max radius over lifetime
// coord coord coord (center position) 
// coord coord coord (axis and radius) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define TE_BEAMFOLLOW		22		// create a line of decaying beam segments until entity stops moving
// short (entity:attachment to follow)
// short (sprite index)
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte,byte,byte (color)
// byte (brightness)

#define TE_GLOWSPRITE		23		
// coord, coord, coord (pos) short (model index) byte (scale / 10)

#define TE_BEAMRING			24		// connect a beam ring to two entities
// short (start entity) 
// short (end entity) 
// short (sprite index) 
// byte (starting frame) 
// byte (frame rate in 0.1's) 
// byte (life in 0.1's) 
// byte (line width in 0.1's) 
// byte (noise amplitude in 0.01's) 
// byte,byte,byte (color)
// byte (brightness)
// byte (scroll speed in 0.1's)

#define TE_STREAK_SPLASH	25		// oriented shower of tracers
// coord coord coord (start position) 
// coord coord coord (direction vector) 
// byte (color)
// short (count)
// short (base speed)
// short (ramdon velocity)

#define TE_BEAMHOSE			26		// obsolete

#define TE_DLIGHT			27		// dynamic light, effect world, minor entity effect
// coord, coord, coord (pos) 
// byte (radius in 10's) 
// byte byte byte (color)
// byte (brightness)
// byte (life in 10's)
// byte (decay rate in 10's)

#define TE_ELIGHT			28		// point entity light, no world effect
// short (entity:attachment to follow)
// coord coord coord (initial position) 
// coord (radius)
// byte byte byte (color)
// byte (life in 0.1's)
// coord (decay rate)

#define TE_TEXTMESSAGE		29
// short 1.2.13 x (-1 = center)
// short 1.2.13 y (-1 = center)
// byte Effect 0 = fade in/fade out
			// 1 is flickery credits
			// 2 is write out (training room)

// 4 bytes r,g,b,a color1	(text color)
// 4 bytes r,g,b,a color2	(effect color)
// ushort 8.8 fadein time
// ushort 8.8  fadeout time
// ushort 8.8 hold time
// optional ushort 8.8 fxtime	(time the highlight lags behing the leading text in effect 2)
// string text message		(512 chars max sz string)
#define TE_LINE				30
// coord, coord, coord		startpos
// coord, coord, coord		endpos
// short life in 0.1 s
// 3 bytes r, g, b

#define TE_BOX				31
// coord, coord, coord		boxmins
// coord, coord, coord		boxmaxs
// short life in 0.1 s
// 3 bytes r, g, b

#define TE_KILLBEAM			99		// kill all beams attached to entity
// short (entity)

#define TE_LARGEFUNNEL		100
// coord coord coord (funnel position)
// short (sprite index) 
// short (flags) 

#define	TE_BLOODSTREAM		101		// particle spray
// coord coord coord (start position)
// coord coord coord (spray vector)
// byte (color)
// byte (speed)

#define	TE_SHOWLINE			102		// line of particles every 5 units, dies in 30 seconds
// coord coord coord (start position)
// coord coord coord (end position)

#define TE_BLOOD			103		// particle spray
// coord coord coord (start position)
// coord coord coord (spray vector)
// byte (color)
// byte (speed)

#define TE_DECAL			104		// Decal applied to a brush entity (not the world)
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// byte (texture index of precached decal texture name)
// short (entity index)

#define TE_FIZZ				105		// create alpha sprites inside of entity, float upwards
// short (entity)
// short (sprite index)
// byte (density)

#define TE_MODEL			106		// create a moving model that bounces and makes a sound when it hits
// coord, coord, coord (position) 
// coord, coord, coord (velocity)
// angle (initial yaw)
// short (model index)
// byte (bounce sound type)
// byte (life in 0.1's)

#define TE_EXPLODEMODEL		107		// spherical shower of models, picks from set
// coord, coord, coord (origin)
// coord (velocity)
// short (model index)
// short (count)
// byte (life in 0.1's)

#define TE_BREAKMODEL		108		// box of models or sprites
// coord, coord, coord (position)
// coord, coord, coord (size)
// coord, coord, coord (velocity)
// byte (random velocity in 10's)
// short (sprite or model index)
// byte (count)
// byte (life in 0.1 secs)
// byte (flags)

#define TE_GUNSHOTDECAL		109		// decal and ricochet sound
// coord, coord, coord (position)
// short (entity index???)
// byte (decal???)

#define TE_SPRITE_SPRAY		110		// spay of alpha sprites
// coord, coord, coord (position)
// coord, coord, coord (velocity)
// short (sprite index)
// byte (count)
// byte (speed)
// byte (noise)

#define TE_ARMOR_RICOCHET	111		// quick spark sprite, client ricochet sound. 
// coord, coord, coord (position)
// byte (scale in 0.1's)

#define TE_PLAYERDECAL		112		// ???
// byte (playerindex)
// coord, coord, coord (position)
// short (entity???)
// byte (decal number???)
// [optional] short (model index???)

#define TE_BUBBLES			113		// create alpha sprites inside of box, float upwards
// coord, coord, coord (min start position)
// coord, coord, coord (max start position)
// coord (float height)
// short (model index)
// byte (count)
// coord (speed)

#define TE_BUBBLETRAIL		114		// create alpha sprites along a line, float upwards
// coord, coord, coord (min start position)
// coord, coord, coord (max start position)
// coord (float height)
// short (model index)
// byte (count)
// coord (speed)

#define TE_BLOODSPRITE		115		// spray of opaque sprite1's that fall, single sprite2 for 1..2 secs (this is a high-priority tent)
// coord, coord, coord (position)
// short (sprite1 index)
// short (sprite2 index)
// byte (color)
// byte (scale)

#define TE_WORLDDECAL		116		// Decal applied to the world brush
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// byte (texture index of precached decal texture name)

#define TE_WORLDDECALHIGH	117		// Decal (with texture index > 256) applied to world brush
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// byte (texture index of precached decal texture name - 256)

#define TE_DECALHIGH		118		// Same as TE_DECAL, but the texture index was greater than 256
// coord, coord, coord (x,y,z), decal position (center of texture in world)
// byte (texture index of precached decal texture name - 256)
// short (entity index)

#define TE_PROJECTILE		119		// Makes a projectile (like a nail) (this is a high-priority tent)
// coord, coord, coord (position)
// coord, coord, coord (velocity)
// short (modelindex)
// byte (life)
// byte (owner)  projectile won't collide with owner (if owner == 0, projectile will hit any client).

#define TE_SPRAY			120		// Throws a shower of sprites or models
// coord, coord, coord (position)
// coord, coord, coord (direction)
// short (modelindex)
// byte (count)
// byte (speed)
// byte (noise)
// byte (rendermode)

#define TE_PLAYERSPRITES	121		// sprites emit from a player's bounding box (ONLY use for players!)
// byte (playernum)
// short (sprite modelindex)
// byte (count)
// byte (variance) (0 = no variance in size) (10 = 10% variance in size)

#define TE_PARTICLEBURST	122		// very similar to lavasplash.
// coord (origin)
// short (radius)
// byte (particle color)
// byte (duration * 10) (will be randomized a bit)

#define TE_FIREFIELD			123		// makes a field of fire.
// coord (origin)
// short (radius) (fire is made in a square around origin. -radius, -radius to radius, radius)
// short (modelindex)
// byte (count)
// byte (flags)
// byte (duration (in seconds) * 10) (will be randomized a bit)
//
// to keep network traffic low, this message has associated flags that fit into a byte:
#define TEFIRE_FLAG_ALLFLOAT	1 // all sprites will drift upwards as they animate
#define TEFIRE_FLAG_SOMEFLOAT	2 // some of the sprites will drift upwards. (50% chance)
#define TEFIRE_FLAG_LOOP		4 // if set, sprite plays at 15 fps, otherwise plays at whatever rate stretches the animation over the sprite's duration.
#define TEFIRE_FLAG_ALPHA		8 // if set, sprite is rendered alpha blended at 50% else, opaque
#define TEFIRE_FLAG_PLANAR		16 // if set, all fire sprites have same initial Z instead of randomly filling a cube. 
#define TEFIRE_FLAG_ADDITIVE	32 // if set, sprite is rendered non-opaque with additive

#define TE_PLAYERATTACHMENT			124 // attaches a TENT to a player (this is a high-priority tent)
// byte (entity index of player)
// coord (vertical offset) ( attachment origin.z = player origin.z + vertical offset )
// short (model index)
// short (life * 10 );

#define TE_KILLPLAYERATTACHMENTS	125 // will expire all TENTS attached to a player.
// byte (entity index of player)

#define TE_MULTIGUNSHOT				126 // much more compact shotgun message
// This message is used to make a client approximate a 'spray' of gunfire.
// Any weapon that fires more than one bullet per frame and fires in a bit of a spread is
// a good candidate for MULTIGUNSHOT use. (shotguns)
//
// NOTE: This effect makes the client do traces for each bullet, these client traces ignore
//		 entities that have studio models.Traces are 4096 long.
//
// coord (origin)
// coord (origin)
// coord (origin)
// coord (direction)
// coord (direction)
// coord (direction)
// coord (x noise * 100)
// coord (y noise * 100)
// byte (count)
// byte (bullethole decal texture index)

#define TE_USERTRACER				127 // larger message than the standard tracer, but allows some customization.
// coord (origin)
// coord (origin)
// coord (origin)
// coord (velocity)
// coord (velocity)
// coord (velocity)
// byte ( life * 10 )
// byte ( color ) this is an index into an array of color vectors in the engine. (0 - )
// byte ( length * 10 )



#define	MSG_BROADCAST		0		// unreliable to all
#define	MSG_ONE				1		// reliable to one (msg_entity)
#define	MSG_ALL				2		// reliable to all
#define	MSG_INIT			3		// write to the init string
#define MSG_PVS				4		// Ents in PVS of org
#define MSG_PAS				5		// Ents in PAS of org
#define MSG_PVS_R			6		// Reliable to PVS
#define MSG_PAS_R			7		// Reliable to PAS
#define MSG_ONE_UNRELIABLE	8		// Send to one client, but don't put in reliable stream, put in unreliable datagram ( could be dropped )
#define	MSG_SPEC			9		// Sends to all spectator proxies

// contents of a spot in the world
#define	CONTENTS_EMPTY		-1
#define	CONTENTS_SOLID		-2
#define	CONTENTS_WATER		-3
#define	CONTENTS_SLIME		-4
#define	CONTENTS_LAVA		-5
#define	CONTENTS_SKY		-6
/* These additional contents constants are defined in bspfile.h
#define	CONTENTS_ORIGIN		-7		// removed at csg time
#define	CONTENTS_CLIP		-8		// changed to contents_solid
#define	CONTENTS_CURRENT_0		-9
#define	CONTENTS_CURRENT_90		-10
#define	CONTENTS_CURRENT_180	-11
#define	CONTENTS_CURRENT_270	-12
#define	CONTENTS_CURRENT_UP		-13
#define	CONTENTS_CURRENT_DOWN	-14

#define CONTENTS_TRANSLUCENT	-15
*/
#define	CONTENTS_LADDER				-16

#define	CONTENT_FLYFIELD			-17
#define	CONTENT_GRAVITY_FLYFIELD	-18
#define	CONTENT_FOG					-19

#define CONTENT_EMPTY	-1
#define CONTENT_SOLID	-2
#define	CONTENT_WATER	-3
#define CONTENT_SLIME	-4
#define CONTENT_LAVA	-5
#define CONTENT_SKY		-6

// channels
#define CHAN_AUTO			0
#define CHAN_WEAPON			1
#define	CHAN_VOICE			2
#define CHAN_ITEM			3
#define	CHAN_BODY			4
#define CHAN_STREAM			5			// allocate stream channel from the static or dynamic area
#define CHAN_STATIC			6			// allocate channel from the static area 
#define CHAN_NETWORKVOICE_BASE	7		// voice data coming across the network
#define CHAN_NETWORKVOICE_END	500		// network voice data reserves slots (CHAN_NETWORKVOICE_BASE through CHAN_NETWORKVOICE_END).
#define CHAN_BOT			501			// channel used for bot chatter.

// attenuation values
#define ATTN_NONE		0
#define	ATTN_NORM		(float)0.8
#define ATTN_IDLE		(float)2
#define ATTN_STATIC		(float)1.25 

// pitch values
#define	PITCH_NORM		100			// non-pitch shifted
#define PITCH_LOW		95			// other values are possible - 0-255, where 255 is very high
#define PITCH_HIGH		120

// volume values
#define VOL_NORM		1.0

// plats
#define	PLAT_LOW_TRIGGER	1

// Trains
#define	SF_TRAIN_WAIT_RETRIGGER	1
#define SF_TRAIN_START_ON		4		// Train is initially moving
#define SF_TRAIN_PASSABLE		8		// Train is not solid -- used to make water trains

// buttons
#ifndef IN_BUTTONS_H
#include "in_buttons.h"
#endif

// Break Model Defines

#define BREAK_TYPEMASK	0x4F
#define BREAK_GLASS		0x01
#define BREAK_METAL		0x02
#define BREAK_FLESH		0x04
#define BREAK_WOOD		0x08

#define BREAK_SMOKE		0x10
#define BREAK_TRANS		0x20
#define BREAK_CONCRETE	0x40
#define BREAK_2			0x80

// Colliding temp entity sounds

#define BOUNCE_GLASS	BREAK_GLASS
#define	BOUNCE_METAL	BREAK_METAL
#define BOUNCE_FLESH	BREAK_FLESH
#define BOUNCE_WOOD		BREAK_WOOD
#define BOUNCE_SHRAP	0x10
#define BOUNCE_SHELL	0x20
#define	BOUNCE_CONCRETE BREAK_CONCRETE
#define BOUNCE_SHOTSHELL 0x80

// Temp entity bounce sound types
#define TE_BOUNCE_NULL		0
#define TE_BOUNCE_SHELL		1
#define TE_BOUNCE_SHOTSHELL	2

// Rendering constants
enum 
{	
	kRenderNormal,			// src
	kRenderTransColor,		// c*a+dest*(1-a)
	kRenderTransTexture,	// src*a+dest*(1-a)
	kRenderGlow,			// src*a+dest -- No Z buffer checks
	kRenderTransAlpha,		// src*srca+dest*(1-srca)
	kRenderTransAdd,		// src*a+dest
};

enum 
{	
	kRenderFxNone = 0, 
	kRenderFxPulseSlow, 
	kRenderFxPulseFast, 
	kRenderFxPulseSlowWide, 
	kRenderFxPulseFastWide, 
	kRenderFxFadeSlow, 
	kRenderFxFadeFast, 
	kRenderFxSolidSlow, 
	kRenderFxSolidFast, 	   
	kRenderFxStrobeSlow, 
	kRenderFxStrobeFast, 
	kRenderFxStrobeFaster, 
	kRenderFxFlickerSlow, 
	kRenderFxFlickerFast,
	kRenderFxNoDissipation,
	kRenderFxDistort,			// Distort/scale/translate flicker
	kRenderFxHologram,			// kRenderFxDistort + distance fade
	kRenderFxDeadPlayer,		// kRenderAmt is the player index
	kRenderFxExplode,			// Scale up really big!
	kRenderFxGlowShell,			// Glowing Shell
	kRenderFxClampMinScale,		// Keep this sprite from getting very small (SPRITES only!)
	kRenderFxLightMultiplier,   //CTM !!!CZERO added to tell the studiorender that the value in iuser2 is a lightmultiplier
};


typedef int	func_t;
typedef int	string_t;

typedef unsigned char 		byte;
typedef unsigned short 		word;
#define _DEF_BYTE_

#undef true
#undef false

#ifndef __cplusplus
typedef enum {false, true}	qboolean;
#else 
typedef int qboolean;
#endif

typedef struct
{
	byte r, g, b;
} color24;

typedef struct
{
	unsigned r, g, b, a;
} colorVec;

#ifdef _WIN32
#pragma pack(push,2)
#endif

typedef struct
{
	unsigned short r, g, b, a;
} PackedColorVec;

#ifdef _WIN32
#pragma pack(pop)
#endif
typedef struct link_s
{
	struct link_s	*prev, *next;
} link_t;

typedef struct edict_s edict_t;

typedef struct
{
	vec3_t	normal;
	float	dist;
} plane_t;

typedef struct
{
	qboolean	allsolid;	// if true, plane is not valid
	qboolean	startsolid;	// if true, the initial point was in a solid area
	qboolean	inopen, inwater;
	float	fraction;		// time completed, 1.0 = didn't hit anything
	vec3_t	endpos;			// final position
	plane_t	plane;			// surface normal at impact
	edict_t	*ent;			// entity the surface is on
	int		hitgroup;		// 0 == generic, non zero is specific body part
} trace_t;

#endif


```

`ValveSDK/crc.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
/* crc.h */
#ifndef CRC_H
#define CRC_H
#ifdef _WIN32
#pragma once
#endif

#include "archtypes.h"     // DAL

// MD5 Hash
typedef struct
{
	unsigned int buf[4];
    unsigned int bits[2];
    unsigned char in[64];
} MD5Context_t;


#ifdef _WIN32
typedef uint32 CRC32_t;
#else
typedef uint32 CRC32_t;
#endif

#ifdef __cplusplus
extern "C"
{
#endif
void CRC32_Init(CRC32_t *pulCRC);
CRC32_t CRC32_Final(CRC32_t pulCRC);
void CRC32_ProcessBuffer(CRC32_t *pulCRC, void *p, int len);
void CRC32_ProcessByte(CRC32_t *pulCRC, unsigned char ch);
int CRC_File(CRC32_t *crcvalue, char *pszFileName);
#ifdef __cplusplus
}
#endif
unsigned char COM_BlockSequenceCRCByte (unsigned char *base, int length, int sequence);

void MD5Init(MD5Context_t *context);
void MD5Update(MD5Context_t *context, unsigned char const *buf,
               unsigned int len);
void MD5Final(unsigned char digest[16], MD5Context_t *context);
void Transform(unsigned int buf[4], unsigned int const in[16]);

int MD5_Hash_File(unsigned char digest[16], char *pszFileName, int bUsefopen, int bSeed, unsigned int seed[4]);
char *MD5_Print(unsigned char hash[16]);
int MD5_Hash_CachedFile(unsigned char digest[16], unsigned char *pCache, int nFileSize, int bSeed, unsigned int seed[4]);

int CRC_MapFile(CRC32_t *crcvalue, char *pszFileName);

#endif

```

`ValveSDK/custom.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// Customization.h

#ifndef CUSTOM_H
#define CUSTOM_H
#ifdef _WIN32
#pragma once
#endif

#include "const.h"

#define MAX_QPATH 64    // Must match value in quakedefs.h

/////////////////
// Customization
// passed to pfnPlayerCustomization
// For automatic downloading.
typedef enum
{
	t_sound = 0,
	t_skin,
	t_model,
	t_decal,
	t_generic,
	t_eventscript,
	t_world,		// Fake type for world, is really t_model
} resourcetype_t;


typedef struct
{
	int				size;
} _resourceinfo_t;

typedef struct resourceinfo_s
{
	_resourceinfo_t info[ 8 ];
} resourceinfo_t;

#define RES_FATALIFMISSING (1<<0)   // Disconnect if we can't get this file.
#define RES_WASMISSING     (1<<1)   // Do we have the file locally, did we get it ok?
#define RES_CUSTOM         (1<<2)   // Is this resource one that corresponds to another player's customization
								    // or is it a server startup resource.
#define RES_REQUESTED	   (1<<3)	// Already requested a download of this one
#define RES_PRECACHED	   (1<<4)	// Already precached
#define RES_ALWAYS		   (1<<5)	// download always even if available on client	
#define RES_CHECKFILE	   (1<<7)	// check file on client

#include "crc.h"

typedef struct resource_s
{
	char              szFileName[MAX_QPATH]; // File name to download/precache.
	resourcetype_t    type;                // t_sound, t_skin, t_model, t_decal.
	int               nIndex;              // For t_decals
	int               nDownloadSize;       // Size in Bytes if this must be downloaded.
	unsigned char     ucFlags;

// For handling client to client resource propagation
	unsigned char     rgucMD5_hash[16];    // To determine if we already have it.
	unsigned char     playernum;           // Which player index this resource is associated with, if it's a custom resource.

	unsigned char	  rguc_reserved[ 32 ]; // For future expansion
	struct resource_s *pNext;              // Next in chain.
	struct resource_s *pPrev;
} resource_t;

typedef struct customization_s
{
	qboolean bInUse;     // Is this customization in use;
	resource_t resource; // The resource_t for this customization
	qboolean bTranslated; // Has the raw data been translated into a useable format?  
						   //  (e.g., raw decal .wad make into texture_t *)
	int        nUserData1; // Customization specific data
	int        nUserData2; // Customization specific data
	void *pInfo;          // Buffer that holds the data structure that references the data (e.g., the cachewad_t)
	void *pBuffer;       // Buffer that holds the data for the customization (the raw .wad data)
	struct customization_s *pNext; // Next in chain
} customization_t;

#define FCUST_FROMHPAK		( 1<<0 )
#define FCUST_WIPEDATA		( 1<<1 )
#define FCUST_IGNOREINIT	( 1<<2 )

void		COM_ClearCustomizationList( struct customization_s *pHead, qboolean bCleanDecals);
qboolean	COM_CreateCustomization( struct customization_s *pListHead, struct resource_s *pResource, int playernumber, int flags, 
				struct customization_s **pCustomization, int *nLumps ); 
int			COM_SizeofResourceList ( struct resource_s *pList, struct resourceinfo_s *ri );

#endif // CUSTOM_H

```

`ValveSDK/cvardef.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef CVARDEF_H
#define CVARDEF_H

#define	FCVAR_ARCHIVE		(1<<0)	// set to cause it to be saved to vars.rc
#define	FCVAR_USERINFO		(1<<1)	// changes the client's info string
#define	FCVAR_SERVER		(1<<2)	// notifies players when changed
#define FCVAR_EXTDLL		(1<<3)	// defined by external DLL
#define FCVAR_CLIENTDLL     (1<<4)  // defined by the client dll
#define FCVAR_PROTECTED     (1<<5)  // It's a server cvar, but we don't send the data since it's a password, etc.  Sends 1 if it's not bland/zero, 0 otherwise as value
#define FCVAR_SPONLY        (1<<6)  // This cvar cannot be changed by clients connected to a multiplayer server.
#define FCVAR_PRINTABLEONLY (1<<7)  // This cvar's string cannot contain unprintable characters ( e.g., used for player name etc ).
#define FCVAR_UNLOGGED		(1<<8)  // If this is a FCVAR_SERVER, don't log changes to the log file / console if we are creating a log

typedef struct cvar_s
{
	char	*name;
	char	*string;
	int		flags;
	float	value;
	struct cvar_s *next;
} cvar_t;
#endif
```

`ValveSDK/dlight.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( DLIGHTH )
#define DLIGHTH
#ifdef _WIN32
#pragma once
#endif

typedef struct dlight_s
{
	vec3_t	origin;
	float	radius;
	color24	color;
	float	die;				// stop lighting after this time
	float	decay;				// drop this each second
	float	minlight;			// don't add when contributing less
	int		key;
	qboolean	dark;			// subtracts light instead of adding
} dlight_t;

#endif

```

`ValveSDK/edict.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#if !defined EDICT_H
#define EDICT_H
#ifdef _WIN32
#pragma once
#endif
#define	MAX_ENT_LEAFS	48

#include "progdefs.h"

struct edict_s
{
	qboolean	free;
	int			serialnumber;
	link_t		area;				// linked to a division node or leaf
	
	int			headnode;			// -1 to use normal leaf check
	int			num_leafs;
	short		leafnums[MAX_ENT_LEAFS];

	float		freetime;			// sv.time when the object was freed

	void*		pvPrivateData;		// Alloced and freed by engine, used by DLLs

	entvars_t	v;					// C exported fields from progs

	// other fields from progs come immediately after
};

#endif

```

`ValveSDK/eiface.h`:

```h
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef EIFACE_H
#define EIFACE_H

#include "archtypes.h"     // DAL

#ifdef HLDEMO_BUILD
#define INTERFACE_VERSION       001
#else  // !HLDEMO_BUILD, i.e., regular version of HL
#define INTERFACE_VERSION		140
#endif // !HLDEMO_BUILD

#include <stdio.h>
#include "custom.h"
#include "cvardef.h"
#include "Sequence.h"
//
// Defines entity interface between engine and DLLs.
// This header file included by engine files and DLL files.
//
// Before including this header, DLLs must:
//		include progdefs.h
// This is conveniently done for them in extdll.h
//

typedef enum
	{
	at_notice,
	at_console,		// same as at_notice, but forces a ConPrintf, not a message box
	at_aiconsole,	// same as at_console, but only shown if developer level is 2!
	at_warning,
	at_error,
	at_logged		// Server print to console ( only in multiplayer games ).
	} ALERT_TYPE;

// 4-22-98  JOHN: added for use in pfnClientPrintf
typedef enum
	{
	print_console,
	print_center,
	print_chat,
	} PRINT_TYPE;

// For integrity checking of content on clients
typedef enum
{
	force_exactfile,					// File on client must exactly match server's file
	force_model_samebounds,				// For model files only, the geometry must fit in the same bbox
	force_model_specifybounds,			// For model files only, the geometry must fit in the specified bbox
	force_model_specifybounds_if_avail,	// For Steam model files only, the geometry must fit in the specified bbox (if the file is available)
} FORCE_TYPE;

// Returned by TraceLine
typedef struct
	{
	int		fAllSolid;			// if true, plane is not valid
	int		fStartSolid;		// if true, the initial point was in a solid area
	int		fInOpen;
	int		fInWater;
	float	flFraction;			// time completed, 1.0 = didn't hit anything
	vec3_t	vecEndPos;			// final position
	float	flPlaneDist;
	vec3_t	vecPlaneNormal;		// surface normal at impact
	edict_t	*pHit;				// entity the surface is on
	int		iHitgroup;			// 0 == generic, non zero is specific body part
	} TraceResult;

// CD audio status
typedef struct 
{
	int	fPlaying;// is sound playing right now?
	int	fWasPlaying;// if not, CD is paused if WasPlaying is true.
	int	fInitialized;
	int	fEnabled;
	int	fPlayLooping;
	float	cdvolume;
	//BYTE 	remap[100];
	int	fCDRom;
	int	fPlayTrack;
} CDStatus;

#include "crc.h"


// Engine hands this to DLLs for functionality callbacks
typedef struct enginefuncs_s
{
	int			(*pfnPrecacheModel)			(const char* s);
	int			(*pfnPrecacheSound)			(const char* s);
	void		(*pfnSetModel)				(edict_t *e, const char *m);
	int			(*pfnModelIndex)			(const char *m);
	int			(*pfnModelFrames)			(int modelIndex);
	void		(*pfnSetSize)				(edict_t *e, const float *rgflMin, const float *rgflMax);
	void		(*pfnChangeLevel)			(char* s1, char* s2);
	void		(*pfnGetSpawnParms)			(edict_t *ent);
	void		(*pfnSaveSpawnParms)		(edict_t *ent);
	float		(*pfnVecToYaw)				(const float *rgflVector);
	void		(*pfnVecToAngles)			(const float *rgflVectorIn, float *rgflVectorOut);
	void		(*pfnMoveToOrigin)			(edict_t *ent, const float *pflGoal, float dist, int iMoveType);
	void		(*pfnChangeYaw)				(edict_t* ent);
	void		(*pfnChangePitch)			(edict_t* ent);
	edict_t*	(*pfnFindEntityByString)	(edict_t *pEdictStartSearchAfter, const char *pszField, const char *pszValue);
	int			(*pfnGetEntityIllum)		(edict_t* pEnt);
	edict_t*	(*pfnFindEntityInSphere)	(edict_t *pEdictStartSearchAfter, const float *org, float rad);
	edict_t*	(*pfnFindClientInPVS)		(edict_t *pEdict);
	edict_t* (*pfnEntitiesInPVS)			(edict_t *pplayer);
	void		(*pfnMakeVectors)			(const float *rgflVector);
	void		(*pfnAngleVectors)			(const float *rgflVector, float *forward, float *right, float *up);
	edict_t*	(*pfnCreateEntity)			(void);
	void		(*pfnRemoveEntity)			(edict_t* e);
	edict_t*	(*pfnCreateNamedEntity)		(int className);
	void		(*pfnMakeStatic)			(edict_t *ent);
	int			(*pfnEntIsOnFloor)			(edict_t *e);
	int			(*pfnDropToFloor)			(edict_t* e);
	int			(*pfnWalkMove)				(edict_t *ent, float yaw, float dist, int iMode);
	void		(*pfnSetOrigin)				(edict_t *e, const float *rgflOrigin);
	void		(*pfnEmitSound)				(edict_t *entity, int channel, const char *sample, /*int*/float volume, float attenuation, int fFlags, int pitch);
	void		(*pfnEmitAmbientSound)		(edict_t *entity, float *pos, const char *samp, float vol, float attenuation, int fFlags, int pitch);
	void		(*pfnTraceLine)				(const float *v1, const float *v2, int fNoMonsters, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnTraceToss)				(edict_t* pent, edict_t* pentToIgnore, TraceResult *ptr);
	int			(*pfnTraceMonsterHull)		(edict_t *pEdict, const float *v1, const float *v2, int fNoMonsters, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnTraceHull)				(const float *v1, const float *v2, int fNoMonsters, int hullNumber, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnTraceModel)			(const float *v1, const float *v2, int hullNumber, edict_t *pent, TraceResult *ptr);
	const char *(*pfnTraceTexture)			(edict_t *pTextureEntity, const float *v1, const float *v2 );
	void		(*pfnTraceSphere)			(const float *v1, const float *v2, int fNoMonsters, float radius, edict_t *pentToSkip, TraceResult *ptr);
	void		(*pfnGetAimVector)			(edict_t* ent, float speed, float *rgflReturn);
	void		(*pfnServerCommand)			(char* str);
	void		(*pfnServerExecute)			(void);
	void		(*pfnClientCommand)			(edict_t* pEdict, char* szFmt, ...);
	void		(*pfnParticleEffect)		(const float *org, const float *dir, float color, float count);
	void		(*pfnLightStyle)			(int style, char* val);
	int			(*pfnDecalIndex)			(const char *name);
	int			(*pfnPointContents)			(const float *rgflVector);
	void		(*pfnMessageBegin)			(int msg_dest, int msg_type, const float *pOrigin, edict_t *ed);
	void		(*pfnMessageEnd)			(void);
	void		(*pfnWriteByte)				(int iValue);
	void		(*pfnWriteChar)				(int iValue);
	void		(*pfnWriteShort)			(int iValue);
	void		(*pfnWriteLong)				(int iValue);
	void		(*pfnWriteAngle)			(float flValue);
	void		(*pfnWriteCoord)			(float flValue);
	void		(*pfnWriteString)			(const char *sz);
	void		(*pfnWriteEntity)			(int iValue);
	void		(*pfnCVarRegister)			(cvar_t *pCvar);
	float		(*pfnCVarGetFloat)			(const char *szVarName);
	const char*	(*pfnCVarGetString)			(const char *szVarName);
	void		(*pfnCVarSetFloat)			(const char *szVarName, float flValue);
	void		(*pfnCVarSetString)			(const char *szVarName, const char *szValue);
	void		(*pfnAlertMessage)			(ALERT_TYPE atype, const char *szFmt, ...);
	void		(*pfnEngineFprintf)			(void *pfile, const char *szFmt, ...);
	void*		(*pfnPvAllocEntPrivateData)	(edict_t *pEdict, int32 cb);
	void*		(*pfnPvEntPrivateData)		(edict_t *pEdict);
	void		(*pfnFreeEntPrivateData)	(edict_t *pEdict);
	const char*	(*pfnSzFromIndex)			(int iString);
	int			(*pfnAllocString)			(const char *szValue);
	struct entvars_s*	(*pfnGetVarsOfEnt)	(edict_t *pEdict);
	edict_t*	(*pfnPEntityOfEntOffset)	(int iEntOffset);
	int			(*pfnEntOffsetOfPEntity)	(const edict_t *pEdict);
	int			(*pfnIndexOfEdict)			(const edict_t *pEdict);
	edict_t*	(*pfnPEntityOfEntIndex)		(int iEntIndex);
	edict_t*	(*pfnFindEntityByVars)		(struct entvars_s* pvars);
	void*		(*pfnGetModelPtr)			(edict_t* pEdict);
	int			(*pfnRegUserMsg)			(const char *pszName, int iSize);
	void		(*pfnAnimationAutomove)		(const edict_t* pEdict, float flTime);
	void		(*pfnGetBonePosition)		(const edict_t* pEdict, int iBone, float *rgflOrigin, float *rgflAngles );
	uint32		(*pfnFunctionFromName)		( const char *pName );
	const char *(*pfnNameForFunction)		( uint32 function );
	void		(*pfnClientPrintf)			( edict_t* pEdict, PRINT_TYPE ptype, const char *szMsg ); // JOHN: engine callbacks so game DLL can print messages to individual clients
	void		(*pfnServerPrint)			( const char *szMsg );
	const char *(*pfnCmd_Args)				( void );		// these 3 added 
	const char *(*pfnCmd_Argv)				( int argc );	// so game DLL can easily 
	int			(*pfnCmd_Argc)				( void );		// access client 'cmd' strings
	void		(*pfnGetAttachment)			(const edict_t *pEdict, int iAttachment, float *rgflOrigin, float *rgflAngles );
	void		(*pfnCRC32_Init)			(CRC32_t *pulCRC);
	void        (*pfnCRC32_ProcessBuffer)   (CRC32_t *pulCRC, void *p, int len);
	void		(*pfnCRC32_ProcessByte)     (CRC32_t *pulCRC, unsigned char ch);
	CRC32_t		(*pfnCRC32_Final)			(CRC32_t pulCRC);
	int32		(*pfnRandomLong)			(int32  lLow,  int32  lHigh);
	float		(*pfnRandomFloat)			(float flLow, float flHigh);
	void		(*pfnSetView)				(const edict_t *pClient, const edict_t *pViewent );
	float		(*pfnTime)					( void );
	void		(*pfnCrosshairAngle)		(const edict_t *pClient, float pitch, float yaw);
	byte *      (*pfnLoadFileForMe)         (char *filename, int *pLength);
	void        (*pfnFreeFile)              (void *buffer);
	void        (*pfnEndSection)            (const char *pszSectionName); // trigger_endsection
	int 		(*pfnCompareFileTime)       (char *filename1, char *filename2, int *iCompare);
	void        (*pfnGetGameDir)            (char *szGetGameDir);
	void		(*pfnCvar_RegisterVariable) (cvar_t *variable);
	void        (*pfnFadeClientVolume)      (const edict_t *pEdict, int fadePercent, int fadeOutSeconds, int holdTime, int fadeInSeconds);
	void        (*pfnSetClientMaxspeed)     (const edict_t *pEdict, float fNewMaxspeed);
	edict_t *	(*pfnCreateFakeClient)		(const char *netname);	// returns NULL if fake client can't be created
	void		(*pfnRunPlayerMove)			(edict_t *fakeclient, const float *viewangles, float forwardmove, float sidemove, float upmove, unsigned short buttons, byte impulse, byte msec );
	int			(*pfnNumberOfEntities)		(void);
	char*		(*pfnGetInfoKeyBuffer)		(edict_t *e);	// passing in NULL gets the serverinfo
	char*		(*pfnInfoKeyValue)			(char *infobuffer, char *key);
	void		(*pfnSetKeyValue)			(char *infobuffer, char *key, char *value);
	void		(*pfnSetClientKeyValue)		(int clientIndex, char *infobuffer, char *key, char *value);
	int			(*pfnIsMapValid)			(char *filename);
	void		(*pfnStaticDecal)			( const float *origin, int decalIndex, int entityIndex, int modelIndex );
	int			(*pfnPrecacheGeneric)		(char* s);
	int			(*pfnGetPlayerUserId)		(edict_t *e ); // returns the server assigned userid for this player.  useful for logging frags, etc.  returns -1 if the edict couldn't be found in the list of clients
	void		(*pfnBuildSoundMsg)			(edict_t *entity, int channel, const char *sample, /*int*/float volume, float attenuation, int fFlags, int pitch, int msg_dest, int msg_type, const float *pOrigin, edict_t *ed);
	int			(*pfnIsDedicatedServer)		(void);// is this a dedicated server?
	cvar_t		*(*pfnCVarGetPointer)		(const char *szVarName);
	unsigned int (*pfnGetPlayerWONId)		(edict_t *e); // returns the server assigned WONid for this player.  useful for logging frags, etc.  returns -1 if the edict couldn't be found in the list of clients

	// YWB 8/1/99 TFF Physics additions
	void		(*pfnInfo_RemoveKey)		( char *s, const char *key );
	const char *(*pfnGetPhysicsKeyValue)	( const edict_t *pClient, const char *key );
	void		(*pfnSetPhysicsKeyValue)	( const edict_t *pClient, const char *key, const char *value );
	const char *(*pfnGetPhysicsInfoString)	( const edict_t *pClient );
	unsigned short (*pfnPrecacheEvent)		( int type, const char*psz );
	void		(*pfnPlaybackEvent)			( int flags, const edict_t *pInvoker, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2 );

	unsigned char *(*pfnSetFatPVS)			( float *org );
	unsigned char *(*pfnSetFatPAS)			( float *org );

	int			(*pfnCheckVisibility )		( const edict_t *entity, unsigned char *pset );

	void		(*pfnDeltaSetField)			( struct delta_s *pFields, const char *fieldname );
	void		(*pfnDeltaUnsetField)		( struct delta_s *pFields, const char *fieldname );
	void		(*pfnDeltaAddEncoder)		( char *name, void (*conditionalencode)( struct delta_s *pFields, const unsigned char *from, const unsigned char *to ) );
	int			(*pfnGetCurrentPlayer)		( void );
	int			(*pfnCanSkipPlayer)			( const edict_t *player );
	int			(*pfnDeltaFindField)		( struct delta_s *pFields, const char *fieldname );
	void		(*pfnDeltaSetFieldByIndex)	( struct delta_s *pFields, int fieldNumber );
	void		(*pfnDeltaUnsetFieldByIndex)( struct delta_s *pFields, int fieldNumber );

	void		(*pfnSetGroupMask)			( int mask, int op );

	int			(*pfnCreateInstancedBaseline) ( int classname, struct entity_state_s *baseline );
	void		(*pfnCvar_DirectSet)		( struct cvar_s *var, char *value );

	// Forces the client and server to be running with the same version of the specified file
	//  ( e.g., a player model ).
	// Calling this has no effect in single player
	void		(*pfnForceUnmodified)		( FORCE_TYPE type, float *mins, float *maxs, const char *filename );

	void		(*pfnGetPlayerStats)		( const edict_t *pClient, int *ping, int *packet_loss );

	void		(*pfnAddServerCommand)		( char *cmd_name, void (*function) (void) );

	// For voice communications, set which clients hear eachother.
	// NOTE: these functions take player entity indices (starting at 1).
	qboolean	(*pfnVoice_GetClientListening)(int iReceiver, int iSender);
	qboolean	(*pfnVoice_SetClientListening)(int iReceiver, int iSender, qboolean bListen);

	const char *(*pfnGetPlayerAuthId)		( edict_t *e );

	// PSV: Added for CZ training map
//	const char *(*pfnKeyNameForBinding)					( const char* pBinding );
	
	sequenceEntry_s*	(*pfnSequenceGet)				( const char* fileName, const char* entryName );
	sentenceEntry_s*	(*pfnSequencePickSentence)		( const char* groupName, int pickMethod, int *picked );

	// LH: Give access to filesize via filesystem
	int			(*pfnGetFileSize)						( char *filename );

	unsigned int (*pfnGetApproxWavePlayLen)				(const char *filepath);
	// MDC: Added for CZ career-mode
	int			(*pfnIsCareerMatch)						( void );

	// BGC: return the number of characters of the localized string referenced by using "label"
	int			(*pfnGetLocalizedStringLength)			(const char *label);

	// BGC: added to facilitate persistent storage of tutor message decay values for
	// different career game profiles.  Also needs to persist regardless of mp.dll being
	// destroyed and recreated.
	void		(*pfnRegisterTutorMessageShown)			(int mid);
	int			(*pfnGetTimesTutorMessageShown)			(int mid);
	void		(*pfnProcessTutorMessageDecayBuffer)	(int *buffer, int bufferLength);
	void		(*pfnConstructTutorMessageDecayBuffer)	(int *buffer, int bufferLength);
	void		(*pfnResetTutorMessageDecayData)		( void );
	void		(*pfnQueryClientCvarValue)				( const edict_t *player, const char *cvarName );
	void		(*pfnQueryClientCvarValue2)				( const edict_t *player, const char *cvarName, int requestID );
	int			(*pfnEngCheckParm)					( const char *pchCmdLineToken, char **pchNextVal );
} enginefuncs_t;


// ONLY ADD NEW FUNCTIONS TO THE END OF THIS STRUCT.  INTERFACE VERSION IS FROZEN AT 138

// Passed to pfnKeyValue
typedef struct KeyValueData_s
{
	char	*szClassName;	// in: entity classname
	char	*szKeyName;		// in: name of key
	char	*szValue;		// in: value of key
	int32	fHandled;		// out: DLL sets to true if key-value pair was understood
} KeyValueData;


typedef struct
{
	char		mapName[ 32 ];
	char		landmarkName[ 32 ];
	edict_t	*pentLandmark;
	vec3_t		vecLandmarkOrigin;
} LEVELLIST;
#define MAX_LEVEL_CONNECTIONS	16		// These are encoded in the lower 16bits of ENTITYTABLE->flags

typedef struct 
{
	int			id;				// Ordinal ID of this entity (used for entity <--> pointer conversions)
	edict_t	*pent;			// Pointer to the in-game entity

	int			location;		// Offset from the base data of this entity
	int			size;			// Byte size of this entity's data
	int			flags;			// This could be a short -- bit mask of transitions that this entity is in the PVS of
	string_t	classname;		// entity class name

} ENTITYTABLE;

#define FENTTABLE_PLAYER		0x80000000
#define FENTTABLE_REMOVED		0x40000000
#define FENTTABLE_MOVEABLE		0x20000000
#define FENTTABLE_GLOBAL		0x10000000

typedef struct saverestore_s SAVERESTOREDATA;

#ifdef _WIN32
typedef 
#endif
struct saverestore_s
{
	char		*pBaseData;		// Start of all entity save data
	char		*pCurrentData;	// Current buffer pointer for sequential access
	int			size;			// Current data size
	int			bufferSize;		// Total space for data
	int			tokenSize;		// Size of the linear list of tokens
	int			tokenCount;		// Number of elements in the pTokens table
	char		**pTokens;		// Hash table of entity strings (sparse)
	int			currentIndex;	// Holds a global entity table ID
	int			tableCount;		// Number of elements in the entity table
	int			connectionCount;// Number of elements in the levelList[]
	ENTITYTABLE	*pTable;		// Array of ENTITYTABLE elements (1 for each entity)
	LEVELLIST	levelList[ MAX_LEVEL_CONNECTIONS ];		// List of connections from this level

	// smooth transition
	int			fUseLandmark;
	char		szLandmarkName[20];// landmark we'll spawn near in next level
	vec3_t		vecLandmarkOffset;// for landmark transitions
	float		time;
	char		szCurrentMapName[32];	// To check global entities

} 
#ifdef _WIN32
SAVERESTOREDATA 
#endif
;

typedef enum _fieldtypes
{
	FIELD_FLOAT = 0,		// Any floating point value
	FIELD_STRING,			// A string ID (return from ALLOC_STRING)
	FIELD_ENTITY,			// An entity offset (EOFFSET)
	FIELD_CLASSPTR,			// CBaseEntity *
	FIELD_EHANDLE,			// Entity handle
	FIELD_EVARS,			// EVARS *
	FIELD_EDICT,			// edict_t *, or edict_t *  (same thing)
	FIELD_VECTOR,			// Any vector
	FIELD_POSITION_VECTOR,	// A world coordinate (these are fixed up across level transitions automagically)
	FIELD_POINTER,			// Arbitrary data pointer... to be removed, use an array of FIELD_CHARACTER
	FIELD_INTEGER,			// Any integer or enum
	FIELD_FUNCTION,			// A class function pointer (Think, Use, etc)
	FIELD_BOOLEAN,			// boolean, implemented as an int, I may use this as a hint for compression
	FIELD_SHORT,			// 2 byte integer
	FIELD_CHARACTER,		// a byte
	FIELD_TIME,				// a floating point time (these are fixed up automatically too!)
	FIELD_MODELNAME,		// Engine string that is a model name (needs precache)
	FIELD_SOUNDNAME,		// Engine string that is a sound name (needs precache)

	FIELD_TYPECOUNT,		// MUST BE LAST
} FIELDTYPE;

#ifndef offsetof
#define offsetof(s,m)	(size_t)&(((s *)0)->m)
#endif

#define _FIELD(type,name,fieldtype,count,flags)		{ fieldtype, #name, offsetof(type, name), count, flags }
#define DEFINE_FIELD(type,name,fieldtype)			_FIELD(type, name, fieldtype, 1, 0)
#define DEFINE_ARRAY(type,name,fieldtype,count)		_FIELD(type, name, fieldtype, count, 0)
#define DEFINE_ENTITY_FIELD(name,fieldtype)			_FIELD(entvars_t, name, fieldtype, 1, 0 )
#define DEFINE_ENTITY_GLOBAL_FIELD(name,fieldtype)	_FIELD(entvars_t, name, fieldtype, 1, FTYPEDESC_GLOBAL )
#define DEFINE_GLOBAL_FIELD(type,name,fieldtype)	_FIELD(type, name, fieldtype, 1, FTYPEDESC_GLOBAL )


#define FTYPEDESC_GLOBAL			0x0001		// This field is masked for global entity save/restore

typedef struct 
{
	FIELDTYPE		fieldType;
	char			*fieldName;
	int				fieldOffset;
	short			fieldSize;
	short			flags;
} TYPEDESCRIPTION;

#ifndef ARRAYSIZE
#define ARRAYSIZE(p)		(sizeof(p)/sizeof(p[0]))
#endif

typedef struct 
{
	// Initialize/shutdown the game (one-time call after loading of game .dll )
	void			(*pfnGameInit)			( void );				
	int				(*pfnSpawn)				( edict_t *pent );
	void			(*pfnThink)				( edict_t *pent );
	void			(*pfnUse)				( edict_t *pentUsed, edict_t *pentOther );
	void			(*pfnTouch)				( edict_t *pentTouched, edict_t *pentOther );
	void			(*pfnBlocked)			( edict_t *pentBlocked, edict_t *pentOther );
	void			(*pfnKeyValue)			( edict_t *pentKeyvalue, KeyValueData *pkvd );
	void			(*pfnSave)				( edict_t *pent, SAVERESTOREDATA *pSaveData );
	int 			(*pfnRestore)			( edict_t *pent, SAVERESTOREDATA *pSaveData, int globalEntity );
	void			(*pfnSetAbsBox)			( edict_t *pent );

	void			(*pfnSaveWriteFields)	( SAVERESTOREDATA *, const char *, void *, TYPEDESCRIPTION *, int );
	void			(*pfnSaveReadFields)	( SAVERESTOREDATA *, const char *, void *, TYPEDESCRIPTION *, int );

	void			(*pfnSaveGlobalState)		( SAVERESTOREDATA * );
	void			(*pfnRestoreGlobalState)	( SAVERESTOREDATA * );
	void			(*pfnResetGlobalState)		( void );

	qboolean		(*pfnClientConnect)		( edict_t *pEntity, const char *pszName, const char *pszAddress, char szRejectReason[ 128 ] );
	
	void			(*pfnClientDisconnect)	( edict_t *pEntity );
	void			(*pfnClientKill)		( edict_t *pEntity );
	void			(*pfnClientPutInServer)	( edict_t *pEntity );
	void			(*pfnClientCommand)		( edict_t *pEntity );
	void			(*pfnClientUserInfoChanged)( edict_t *pEntity, char *infobuffer );

	void			(*pfnServerActivate)	( edict_t *pEdictList, int edictCount, int clientMax );
	void			(*pfnServerDeactivate)	( void );

	void			(*pfnPlayerPreThink)	( edict_t *pEntity );
	void			(*pfnPlayerPostThink)	( edict_t *pEntity );

	void			(*pfnStartFrame)		( void );
	void			(*pfnParmsNewLevel)		( void );
	void			(*pfnParmsChangeLevel)	( void );

	 // Returns string describing current .dll.  E.g., TeamFotrress 2, Half-Life
	const char     *(*pfnGetGameDescription)( void );     

	// Notify dll about a player customization.
	void            (*pfnPlayerCustomization) ( edict_t *pEntity, customization_t *pCustom );  

	// Spectator funcs
	void			(*pfnSpectatorConnect)		( edict_t *pEntity );
	void			(*pfnSpectatorDisconnect)	( edict_t *pEntity );
	void			(*pfnSpectatorThink)		( edict_t *pEntity );

	// Notify game .dll that engine is going to shut down.  Allows mod authors to set a breakpoint.
	void			(*pfnSys_Error)			( const char *error_string );

	void			(*pfnPM_Move) ( struct playermove_s *ppmove, qboolean server );
	void			(*pfnPM_Init) ( struct playermove_s *ppmove );
	char			(*pfnPM_FindTextureType)( char *name );
	void			(*pfnSetupVisibility)( struct edict_s *pViewEntity, struct edict_s *pClient, unsigned char **pvs, unsigned char **pas );
	void			(*pfnUpdateClientData) ( const struct edict_s *ent, int sendweapons, struct clientdata_s *cd );
	int				(*pfnAddToFullPack)( struct entity_state_s *state, int e, edict_t *ent, edict_t *host, int hostflags, int player, unsigned char *pSet );
	void			(*pfnCreateBaseline) ( int player, int eindex, struct entity_state_s *baseline, struct edict_s *entity, int playermodelindex, vec3_t player_mins, vec3_t player_maxs );
	void			(*pfnRegisterEncoders)	( void );
	int				(*pfnGetWeaponData)		( struct edict_s *player, struct weapon_data_s *info );

	void			(*pfnCmdStart)			( const edict_t *player, const struct usercmd_s *cmd, unsigned int random_seed );
	void			(*pfnCmdEnd)			( const edict_t *player );

	// Return 1 if the packet is valid.  Set response_buffer_size if you want to send a response packet.  Incoming, it holds the max
	//  size of the response_buffer, so you must zero it out if you choose not to respond.
	int				(*pfnConnectionlessPacket )	( const struct netadr_s *net_from, const char *args, char *response_buffer, int *response_buffer_size );

	// Enumerates player hulls.  Returns 0 if the hull number doesn't exist, 1 otherwise
	int				(*pfnGetHullBounds)	( int hullnumber, float *mins, float *maxs );

	// Create baselines for certain "unplaced" items.
	void			(*pfnCreateInstancedBaselines) ( void );

	// One of the pfnForceUnmodified files failed the consistency check for the specified player
	// Return 0 to allow the client to continue, 1 to force immediate disconnection ( with an optional disconnect message of up to 256 characters )
	int				(*pfnInconsistentFile)( const struct edict_s *player, const char *filename, char *disconnect_message );

	// The game .dll should return 1 if lag compensation should be allowed ( could also just set
	//  the sv_unlag cvar.
	// Most games right now should return 0, until client-side weapon prediction code is written
	//  and tested for them.
	int				(*pfnAllowLagCompensation)( void );
} DLL_FUNCTIONS;

extern DLL_FUNCTIONS		gEntityInterface;

// Current version.
#define NEW_DLL_FUNCTIONS_VERSION	1

typedef struct
{
	// Called right before the object's memory is freed. 
	// Calls its destructor.
	void			(*pfnOnFreeEntPrivateData)(edict_t *pEnt);
	void			(*pfnGameShutdown)(void);
	int				(*pfnShouldCollide)( edict_t *pentTouched, edict_t *pentOther );
	void			(*pfnCvarValue)( const edict_t *pEnt, const char *value );
	void			(*pfnCvarValue2)( const edict_t *pEnt, int requestID, const char *cvarName, const char *value );
} NEW_DLL_FUNCTIONS;
typedef int	(*NEW_DLL_FUNCTIONS_FN)( NEW_DLL_FUNCTIONS *pFunctionTable, int *interfaceVersion );

// Pointers will be null if the game DLL doesn't support this API.
extern NEW_DLL_FUNCTIONS	gNewDLLFunctions;

typedef int	(*APIFUNCTION)( DLL_FUNCTIONS *pFunctionTable, int interfaceVersion );
typedef int	(*APIFUNCTION2)( DLL_FUNCTIONS *pFunctionTable, int *interfaceVersion );

#endif /* EIFACE_H */

```

`ValveSDK/engine_launcher_api.h`:

```h
// engine/launcher interface
#if !defined( ENGINE_LAUNCHER_APIH )
#define ENGINE_LAUNCHER_APIH
#ifdef _WIN32
#pragma once
#endif

typedef void ( *xcommand_t ) ( void );

#define RENDERTYPE_UNDEFINED	0
#define RENDERTYPE_SOFTWARE		1
#define RENDERTYPE_HARDWARE		2
#define RENDERTYPE_D3D			3

#define ENGINE_LAUNCHER_API_VERSION 1

typedef struct engine_api_s
{
	int		version;
	int		rendertype;
	int		size;

	// Functions
	int		( *GetEngineState )				( void );
	void	( *Cbuf_AddText )				( char *text ); // append cmd at end of buf
	void	( *Cbuf_InsertText )			( char *text ); // insert cmd at start of buf
	void	( *Cmd_AddCommand )				( char *cmd_name, void ( *funcname )( void ) );
	int		( *Cmd_Argc )					( void );
	char	*( *Cmd_Args )					( void );
	char	*( *Cmd_Argv )					( int arg );
	void	( *Con_Printf )					( char *, ... );
	void	( *Con_SafePrintf )				( char *, ... );
	void	( *Cvar_Set )					( char *var_name, char *value );
	void	( *Cvar_SetValue )				( char *var_name, float value );
	int		( *Cvar_VariableInt )			( char *var_name );
	char	*( *Cvar_VariableString )		( char *var_name );
	float	( *Cvar_VariableValue )			( char *var_name );
	void	( *ForceReloadProfile )			( void );
	int		( *GetGameInfo )				( struct GameInfo_s *pGI, char *pszChannel );
	void	( *GameSetBackground )			( int bBack );
	void	( *GameSetState )				( int iState );
	void	( *GameSetSubState )			( int iState );
	int		( *GetPauseState )				( void );
	int		( *Host_Frame )					( float time, int iState, int *stateInfo );
	void	( *Host_GetHostInfo )			( float *fps, int *nActive, int *nSpectators, int *nMaxPlayers, char *pszMap );
	void	( *Host_Shutdown )				( void );
	int		( *Game_Init )					( char *lpCmdLine, unsigned char *pMem, int iSize, struct exefuncs_s *pef, void *, int );
	void	( *IN_ActivateMouse )			( void );
	void	( *IN_ClearStates )				( void );
	void	( *IN_DeactivateMouse )			( void );
	void	( *IN_MouseEvent )				( int mstate );
	void	( *Keyboard_ReturnToGame )		( void );
	void	( *Key_ClearStates )			( void );
	void	( *Key_Event )					( int key, int down );
	int		( *LoadGame )					( const char *pszSlot );
	void	( *S_BlockSound )				( void );
	void	( *S_ClearBuffer )				( void );
	void	( *S_GetDSPointer )				( struct IDirectSound **lpDS, struct IDirectSoundBuffer **lpDSBuf );
	void 	*( *S_GetWAVPointer )			( void );
	void	( *S_UnblockSound )				( void );
	int		( *SaveGame )					( const char *pszSlot, const char *pszComment );
	void	( *SetAuth )					( void *pobj );
	void	( *SetMessagePumpDisableMode )	( int bMode );
	void	( *SetPauseState )				( int bPause );
	void	( *SetStartupMode )				( int bMode );
	void	( *SNDDMA_Shutdown )			( void );
	void	( *Snd_AcquireBuffer )			( void );
	void	( *Snd_ReleaseBuffer )			( void );
	void	( *StoreProfile )				( void );
	double	( *Sys_FloatTime )				( void );
	void	( *VID_UpdateWindowVars )		( void *prc, int x, int y );
	void	( *VID_UpdateVID )				( struct viddef_s *pvid );

	// VGUI interfaces
	void	( *VGui_CallEngineSurfaceProc )	( void* hwnd, unsigned int msg, unsigned int wparam, long lparam );

	// notifications that the launcher is taking/giving focus to the engine
	void    ( *EngineTakingFocus )			( void );
	void    ( *LauncherTakingFocus )		( void );

#ifdef _WIN32
	// Only filled in by rendertype RENDERTYPE_HARDWARE
	void	( *GL_Init )					( void );
	int		( *GL_SetMode )					( HWND hwndGame, HDC *pmaindc, HGLRC *pbaseRC, int fD3D, const char *p, const char *pszCmdLine );
	void	( *GL_Shutdown )				( HWND hwnd, HDC hdc, HGLRC hglrc );

	void	( *QGL_D3DShared )				( struct tagD3DGlobals *d3dGShared );

	int		( WINAPI *glSwapBuffers )		( HDC dc );
	void	( *DirectorProc ) ( unsigned int cmd, void * params );
#else
	// NOT USED IN LINUX!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	void	( *GL_Init )					( void );
	void	( *GL_SetMode )					( void );
	void	( *GL_Shutdown )				( void );
	void	( *QGL_D3DShared )				( void );
	void	( *glSwapBuffers )				( void );
	void	( *DirectorProc )				( void );
	// LINUX
#endif

} engine_api_t;

#endif // ENGINE_LAUNCHER_APIH

```

`ValveSDK/entity_state.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( ENTITY_STATEH )
#define ENTITY_STATEH
#ifdef _WIN32
#pragma once
#endif

// For entityType below
#define ENTITY_NORMAL		(1<<0)
#define ENTITY_BEAM			(1<<1)

// Entity state is used for the baseline and for delta compression of a packet of 
//  entities that is sent to a client.
typedef struct entity_state_s entity_state_t;

struct entity_state_s
{
// Fields which are filled in by routines outside of delta compression
	int			entityType;
	// Index into cl_entities array for this entity.
	int			number;      
	float		msg_time;

	// Message number last time the player/entity state was updated.
	int			messagenum;		

	// Fields which can be transitted and reconstructed over the network stream
	vec3_t		origin;
	vec3_t		angles;

	int			modelindex;
	int			sequence;
	float		frame;
	int			colormap;
	short		skin;
	short		solid;
	int			effects;
	float		scale;

	byte		eflags;
	
	// Render information
	int			rendermode;
	int			renderamt;
	color24		rendercolor;
	int			renderfx;

	int			movetype;
	float		animtime;
	float		framerate;
	int			body;
	byte		controller[4];
	byte		blending[4];
	vec3_t		velocity;

	// Send bbox down to client for use during prediction.
	vec3_t		mins;    
	vec3_t		maxs;

	int			aiment;
	// If owned by a player, the index of that player ( for projectiles ).
	int			owner; 

	// Friction, for prediction.
	float		friction;       
	// Gravity multiplier
	float		gravity;		

// PLAYER SPECIFIC
	int			team;
	int			playerclass;
	int			health;
	qboolean	spectator;  
	int         weaponmodel;
	int			gaitsequence;
	// If standing on conveyor, e.g.
	vec3_t		basevelocity;   
	// Use the crouched hull, or the regular player hull.
	int			usehull;		
	// Latched buttons last time state updated.
	int			oldbuttons;     
	// -1 = in air, else pmove entity number
	int			onground;		
	int			iStepLeft;
	// How fast we are falling
	float		flFallVelocity;  

	float		fov;
	int			weaponanim;

	// Parametric movement overrides
	vec3_t				startpos;
	vec3_t				endpos;
	float				impacttime;
	float				starttime;

	// For mods
	int			iuser1;
	int			iuser2;
	int			iuser3;
	int			iuser4;
	float		fuser1;
	float		fuser2;
	float		fuser3;
	float		fuser4;
	vec3_t		vuser1;
	vec3_t		vuser2;
	vec3_t		vuser3;
	vec3_t		vuser4;
};

#include "pm_info.h"

typedef struct clientdata_s
{
	vec3_t				origin;
	vec3_t				velocity;

	int					viewmodel;
	vec3_t				punchangle;
	int					flags;
	int					waterlevel;
	int					watertype;
	vec3_t				view_ofs;
	float				health;

	int					bInDuck;

	int					weapons; // remove?
	
	int					flTimeStepSound;
	int					flDuckTime;
	int					flSwimTime;
	int					waterjumptime;

	float				maxspeed;

	float				fov;
	int					weaponanim;

	int					m_iId;
	int					ammo_shells;
	int					ammo_nails;
	int					ammo_cells;
	int					ammo_rockets;
	float				m_flNextAttack;
	
	int					tfstate;

	int					pushmsec;

	int					deadflag;

	char				physinfo[ MAX_PHYSINFO_STRING ];

	// For mods
	int					iuser1;
	int					iuser2;
	int					iuser3;
	int					iuser4;
	float				fuser1;
	float				fuser2;
	float				fuser3;
	float				fuser4;
	vec3_t				vuser1;
	vec3_t				vuser2;
	vec3_t				vuser3;
	vec3_t				vuser4;
} clientdata_t;

#include "weaponinfo.h"

typedef struct local_state_s
{
	entity_state_t playerstate;
	clientdata_t   client;
	weapon_data_t  weapondata[ 32 ];
} local_state_t;

#endif // !ENTITY_STATEH
```

`ValveSDK/entity_types.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// entity_types.h
#if !defined( ENTITY_TYPESH )
#define ENTITY_TYPESH

#define ET_NORMAL		0
#define ET_PLAYER		1
#define ET_TEMPENTITY	2
#define ET_BEAM			3
// BMODEL or SPRITE that was split across BSP nodes
#define ET_FRAGMENTED	4

#endif // !ENTITY_TYPESH

```

`ValveSDK/event_api.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( EVENT_APIH )
#define EVENT_APIH
#ifdef _WIN32
#pragma once
#endif

#define EVENT_API_VERSION 1

typedef struct event_api_s
{
	int		version;
	void	( *EV_PlaySound ) ( int ent, float *origin, int channel, const char *sample, float volume, float attenuation, int fFlags, int pitch );
	void	( *EV_StopSound ) ( int ent, int channel, const char *sample );
	int		( *EV_FindModelIndex )( const char *pmodel );
	int		( *EV_IsLocal ) ( int playernum );
	int		( *EV_LocalPlayerDucking ) ( void );
	void	( *EV_LocalPlayerViewheight ) ( float * );
	void	( *EV_LocalPlayerBounds ) ( int hull, float *mins, float *maxs );
	int		( *EV_IndexFromTrace) ( struct pmtrace_s *pTrace );
	struct physent_s *( *EV_GetPhysent ) ( int idx );
	void	( *EV_SetUpPlayerPrediction ) ( int dopred, int bIncludeLocalClient );
	void	( *EV_PushPMStates ) ( void );
	void	( *EV_PopPMStates ) ( void );
	void	( *EV_SetSolidPlayers ) (int playernum);
	void	( *EV_SetTraceHull ) ( int hull );
	void	( *EV_PlayerTrace ) ( float *start, float *end, int traceFlags, int ignore_pe, struct pmtrace_s *tr );
	void	( *EV_WeaponAnimation ) ( int sequence, int body );
	unsigned short ( *EV_PrecacheEvent ) ( int type, const char* psz );
	void	( *EV_PlaybackEvent ) ( int flags, const struct edict_s *pInvoker, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2 );
	const char *( *EV_TraceTexture ) ( int ground, float *vstart, float *vend );
	void	( *EV_StopAllSounds ) ( int entnum, int entchannel );
	void    ( *EV_KillEvents ) ( int entnum, const char *eventname );
} event_api_t;

extern event_api_t eventapi;

#endif

```

`ValveSDK/event_args.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( EVENT_ARGSH )
#define EVENT_ARGSH
#ifdef _WIN32
#pragma once
#endif

// Event was invoked with stated origin
#define FEVENT_ORIGIN	( 1<<0 )

// Event was invoked with stated angles
#define FEVENT_ANGLES	( 1<<1 )

typedef struct event_args_s
{
	int		flags;

	// Transmitted
	int		entindex;

	float	origin[3];
	float	angles[3];
	float	velocity[3];

	int		ducking;

	float	fparam1;
	float	fparam2;

	int		iparam1;
	int		iparam2;

	int		bparam1;
	int		bparam2;
} event_args_t;

#endif

```

`ValveSDK/event_flags.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( EVENT_FLAGSH )
#define EVENT_FLAGSH
#ifdef _WIN32
#pragma once
#endif

// Skip local host for event send.
#define FEV_NOTHOST		(1<<0)    

// Send the event reliably.  You must specify the origin and angles and use
// PLAYBACK_EVENT_FULL for this to work correctly on the server for anything
// that depends on the event origin/angles.  I.e., the origin/angles are not
// taken from the invoking edict for reliable events.
#define FEV_RELIABLE	(1<<1)	 

// Don't restrict to PAS/PVS, send this event to _everybody_ on the server ( useful for stopping CHAN_STATIC
//  sounds started by client event when client is not in PVS anymore ( hwguy in TFC e.g. ).
#define FEV_GLOBAL		(1<<2)

// If this client already has one of these events in its queue, just update the event instead of sending it as a duplicate
//
#define FEV_UPDATE		(1<<3)

// Only send to entity specified as the invoker
#define	FEV_HOSTONLY	(1<<4)

// Only send if the event was created on the server.
#define FEV_SERVER		(1<<5)

// Only issue event client side ( from shared code )
#define FEV_CLIENT		(1<<6)

#endif

```

`ValveSDK/in_buttons.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef IN_BUTTONS_H
#define IN_BUTTONS_H
#ifdef _WIN32
#pragma once
#endif

#define IN_ATTACK	(1 << 0)
#define IN_JUMP		(1 << 1)
#define IN_DUCK		(1 << 2)
#define IN_FORWARD	(1 << 3)
#define IN_BACK		(1 << 4)
#define IN_USE		(1 << 5)
#define IN_CANCEL	(1 << 6)
#define IN_LEFT		(1 << 7)
#define IN_RIGHT	(1 << 8)
#define IN_MOVELEFT	(1 << 9)
#define IN_MOVERIGHT (1 << 10)
#define IN_ATTACK2	(1 << 11)
#define IN_RUN      (1 << 12)
#define IN_RELOAD	(1 << 13)
#define IN_ALT1		(1 << 14)
#define IN_SCORE	(1 << 15)   // Used by client.dll for when scoreboard is held down

#endif // IN_BUTTONS_H

```

`ValveSDK/keydefs.h`:

```h
// keydefs.h
#ifndef KEYDEFS_H
#define KEYDEFS_H
#ifdef _WIN32
#pragma once
#endif

//
// these are the key numbers that should be passed to Key_Event
//
#define	K_TAB			9
#define	K_ENTER			13
#define	K_ESCAPE		27
#define	K_SPACE			32

// normal keys should be passed as lowercased ascii

#define	K_BACKSPACE		127
#define	K_UPARROW		128
#define	K_DOWNARROW		129
#define	K_LEFTARROW		130
#define	K_RIGHTARROW	131

#define	K_ALT			132
#define	K_CTRL			133
#define	K_SHIFT			134
#define	K_F1			135
#define	K_F2			136
#define	K_F3			137
#define	K_F4			138
#define	K_F5			139
#define	K_F6			140
#define	K_F7			141
#define	K_F8			142
#define	K_F9			143
#define	K_F10			144
#define	K_F11			145
#define	K_F12			146
#define	K_INS			147
#define	K_DEL			148
#define	K_PGDN			149
#define	K_PGUP			150
#define	K_HOME			151
#define	K_END			152

#define K_KP_HOME		160
#define K_KP_UPARROW	161
#define K_KP_PGUP		162
#define	K_KP_LEFTARROW	163
#define K_KP_5			164
#define K_KP_RIGHTARROW	165
#define K_KP_END		166
#define K_KP_DOWNARROW	167
#define K_KP_PGDN		168
#define	K_KP_ENTER		169
#define K_KP_INS   		170
#define	K_KP_DEL		171
#define K_KP_SLASH		172
#define K_KP_MINUS		173
#define K_KP_PLUS		174
#define K_CAPSLOCK		175
#define K_KP_MUL		176
#define K_WIN			177


//
// joystick buttons
//
#define	K_JOY1			203
#define	K_JOY2			204
#define	K_JOY3			205
#define	K_JOY4			206

//
// aux keys are for multi-buttoned joysticks to generate so they can use
// the normal binding process
//
#define	K_AUX1			207
#define	K_AUX2			208
#define	K_AUX3			209
#define	K_AUX4			210
#define	K_AUX5			211
#define	K_AUX6			212
#define	K_AUX7			213
#define	K_AUX8			214
#define	K_AUX9			215
#define	K_AUX10			216
#define	K_AUX11			217
#define	K_AUX12			218
#define	K_AUX13			219
#define	K_AUX14			220
#define	K_AUX15			221
#define	K_AUX16			222
#define	K_AUX17			223
#define	K_AUX18			224
#define	K_AUX19			225
#define	K_AUX20			226
#define	K_AUX21			227
#define	K_AUX22			228
#define	K_AUX23			229
#define	K_AUX24			230
#define	K_AUX25			231
#define	K_AUX26			232
#define	K_AUX27			233
#define	K_AUX28			234
#define	K_AUX29			235
#define	K_AUX30			236
#define	K_AUX31			237
#define	K_AUX32			238
#define K_MWHEELDOWN	239
#define K_MWHEELUP		240

#define K_PAUSE			255

//
// mouse buttons generate virtual keys
//
#define	K_MOUSE1		241
#define	K_MOUSE2		242
#define	K_MOUSE3		243
#define K_MOUSE4		244
#define K_MOUSE5		245

#endif // KEYDEFS_H
```

`ValveSDK/net_api.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#if !defined( NET_APIH )
#define NET_APIH
#ifdef _WIN32
#pragma once
#endif

#if !defined ( NETADRH )
#include "netadr.h"
#endif

#define NETAPI_REQUEST_SERVERLIST	( 0 )  // Doesn't need a remote address
#define NETAPI_REQUEST_PING			( 1 )
#define NETAPI_REQUEST_RULES		( 2 )
#define NETAPI_REQUEST_PLAYERS		( 3 )
#define NETAPI_REQUEST_DETAILS		( 4 )

// Set this flag for things like broadcast requests, etc. where the engine should not
//  kill the request hook after receiving the first response
#define FNETAPI_MULTIPLE_RESPONSE ( 1<<0 )

typedef void ( *net_api_response_func_t ) ( struct net_response_s *response );

#define NET_SUCCESS						( 0 )
#define NET_ERROR_TIMEOUT				( 1<<0 )
#define NET_ERROR_PROTO_UNSUPPORTED		( 1<<1 )
#define NET_ERROR_UNDEFINED				( 1<<2 )

typedef struct net_adrlist_s
{
	struct net_adrlist_s	*next;
	netadr_t				remote_address;
} net_adrlist_t;

typedef struct net_response_s
{
	// NET_SUCCESS or an error code
	int			error;

	// Context ID
	int			context;
	// Type
	int			type;

	// Server that is responding to the request
	netadr_t	remote_address;

	// Response RTT ping time
	double		ping;
	// Key/Value pair string ( separated by backlash \ characters )
	// WARNING:  You must copy this buffer in the callback function, because it is freed
	//  by the engine right after the call!!!!
	// ALSO:  For NETAPI_REQUEST_SERVERLIST requests, this will be a pointer to a linked list of net_adrlist_t's
	void		*response;
} net_response_t;

typedef struct net_status_s
{
		// Connected to remote server?  1 == yes, 0 otherwise
	int			connected; 
	// Client's IP address
	netadr_t	local_address;
	// Address of remote server
	netadr_t	remote_address;
	// Packet Loss ( as a percentage )
	int			packet_loss;
	// Latency, in seconds ( multiply by 1000.0 to get milliseconds )
	double		latency;
	// Connection time, in seconds
	double		connection_time;
	// Rate setting ( for incoming data )
	double		rate;
} net_status_t;

typedef struct net_api_s
{
	// APIs
	void		( *InitNetworking )( void );
	void		( *Status ) ( struct net_status_s *status );
	void		( *SendRequest) ( int context, int request, int flags, double timeout, struct netadr_s *remote_address, net_api_response_func_t response );
	void		( *CancelRequest ) ( int context );
	void		( *CancelAllRequests ) ( void );
	char		*( *AdrToString ) ( struct netadr_s *a );
	int			( *CompareAdr ) ( struct netadr_s *a, struct netadr_s *b );
	int			( *StringToAdr ) ( char *s, struct netadr_s *a );
	const char *( *ValueForKey ) ( const char *s, const char *key );
	void		( *RemoveKey ) ( char *s, const char *key );
	void		( *SetValueForKey ) (char *s, const char *key, const char *value, int maxsize );
} net_api_t;

extern net_api_t netapi;

#endif // NET_APIH
```

`ValveSDK/netadr.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// netadr.h
#ifndef NETADR_H
#define NETADR_H
#ifdef _WIN32
#pragma once
#endif

typedef enum
{
	NA_UNUSED,
	NA_LOOPBACK,
	NA_BROADCAST,
	NA_IP,
	NA_IPX,
	NA_BROADCAST_IPX,
} netadrtype_t;

typedef struct netadr_s
{
	netadrtype_t	type;
	unsigned char	ip[4];
	unsigned char	ipx[10];
	unsigned short	port;
} netadr_t;

#endif // NETADR_H

```

`ValveSDK/parsemsg.cpp`:

```cpp
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  parsemsg.cpp
//
typedef unsigned char byte;
#define true 1

static byte *gpBuf;
static int giSize;
static int giRead;
static int giBadRead;

void BEGIN_READ( void *buf, int size )
{
	giRead = 0;
	giBadRead = 0;
	giSize = size;
	gpBuf = (byte*)buf;
}


int READ_CHAR( void )
{
	int     c;
	
	if (giRead + 1 > giSize)
	{
		giBadRead = true;
		return -1;
	}
		
	c = (signed char)gpBuf[giRead];
	giRead++;
	
	return c;
}

int READ_BYTE( void )
{
	int     c;
	
	if (giRead+1 > giSize)
	{
		giBadRead = true;
		return -1;
	}
		
	c = (unsigned char)gpBuf[giRead];
	giRead++;
	
	return c;
}

int READ_SHORT( void )
{
	int     c;
	
	if (giRead+2 > giSize)
	{
		giBadRead = true;
		return -1;
	}
		
	c = (short)( gpBuf[giRead] + ( gpBuf[giRead+1] << 8 ) );
	
	giRead += 2;
	
	return c;
}

int READ_WORD( void )
{
	return READ_SHORT();
}


int READ_LONG( void )
{
	int     c;
	
	if (giRead+4 > giSize)
	{
		giBadRead = true;
		return -1;
	}
		
 	c = gpBuf[giRead] + (gpBuf[giRead + 1] << 8) + (gpBuf[giRead + 2] << 16) + (gpBuf[giRead + 3] << 24);
	
	giRead += 4;
	
	return c;
}

float READ_FLOAT( void )
{
	union
	{
		byte    b[4];
		float   f;
		int     l;
	} dat;
	
	dat.b[0] = gpBuf[giRead];
	dat.b[1] = gpBuf[giRead+1];
	dat.b[2] = gpBuf[giRead+2];
	dat.b[3] = gpBuf[giRead+3];
	giRead += 4;
	
//	dat.l = LittleLong (dat.l);

	return dat.f;   
}

char* READ_STRING( void )
{
	static char     string[2048];
	int             l,c;

	string[0] = 0;

	l = 0;
	do
	{
		if ( giRead+1 > giSize )
			break; // no more characters

		c = READ_CHAR();
		if (c == -1 || c == 0)
			break;
		string[l] = c;
		l++;
	} while (l < sizeof(string)-1);
	
	string[l] = 0;
	
	return string;
}

float READ_COORD( void )
{
	return (float)(READ_SHORT() * (1.0/8));
}

float READ_ANGLE( void )
{
	return (float)(READ_CHAR() * (360.0/256));
}

float READ_HIRESANGLE( void )
{
	return (float)(READ_SHORT() * (360.0/65536));
}


```

`ValveSDK/parsemsg.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//
//  parsemsg.h
//

#define ASSERT( x )

void BEGIN_READ( void *buf, int size );
int READ_CHAR( void );
int READ_BYTE( void );
int READ_SHORT( void );
int READ_WORD( void );
int READ_LONG( void );
float READ_FLOAT( void );
char* READ_STRING( void );
float READ_COORD( void );
float READ_ANGLE( void );
float READ_HIRESANGLE( void );










```

`ValveSDK/particledef.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( PARTICLEDEFH )
#define PARTICLEDEFH
#ifdef _WIN32
#pragma once
#endif

typedef enum {
	pt_static, 
	pt_grav,
	pt_slowgrav,
	pt_fire,
	pt_explode,
	pt_explode2,
	pt_blob,
	pt_blob2,
	pt_vox_slowgrav,
	pt_vox_grav,
	pt_clientcustom   // Must have callback function specified
} ptype_t;

// !!! if this is changed, it must be changed in d_ifacea.h too !!!
typedef struct particle_s
{
// driver-usable fields
	vec3_t		org;
	short		color;
	short		packedColor;
// drivers never touch the following fields
	struct particle_s	*next;
	vec3_t		vel;
	float		ramp;
	float		die;
	ptype_t		type;
	void		(*deathfunc)( struct particle_s *particle );

	// for pt_clientcusttom, we'll call this function each frame
	void		(*callback)( struct particle_s *particle, float frametime );
	
	// For deathfunc, etc.
	unsigned char context;
} particle_t;

#endif

```

`ValveSDK/pm_defs.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// pm_defs.h
#if !defined( PM_DEFSH )
#define PM_DEFSH
#pragma once

#include "archtypes.h"     // DAL
#define	MAX_PHYSENTS 600 		  // Must have room for all entities in the world.
#define MAX_MOVEENTS 64
#define	MAX_CLIP_PLANES	5

#define PM_NORMAL			0x00000000
#define PM_STUDIO_IGNORE	0x00000001		// Skip studio models
#define PM_STUDIO_BOX		0x00000002		// Use boxes for non-complex studio models (even in traceline)
#define PM_GLASS_IGNORE		0x00000004		// Ignore entities with non-normal rendermode
#define PM_WORLD_ONLY		0x00000008		// Only trace against the world

// Values for flags parameter of PM_TraceLine
#define PM_TRACELINE_PHYSENTSONLY	0
#define PM_TRACELINE_ANYVISIBLE		1


#include "pm_info.h"

// PM_PlayerTrace results.
#include "pmtrace.h"

#if !defined ( USERCMD_H )
#include "usercmd.h"
#endif

// physent_t
typedef struct physent_s
{
	char			name[32];             // Name of model, or "player" or "world".
	int				player;
	vec3_t			origin;               // Model's origin in world coordinates.
	struct model_s	*model;		          // only for bsp models
	struct model_s	*studiomodel;         // SOLID_BBOX, but studio clip intersections.
	vec3_t			mins, maxs;	          // only for non-bsp models
	int				info;		          // For client or server to use to identify (index into edicts or cl_entities)
	vec3_t			angles;               // rotated entities need this info for hull testing to work.

	int				solid;				  // Triggers and func_door type WATER brushes are SOLID_NOT
	int				skin;                 // BSP Contents for such things like fun_door water brushes.
	int				rendermode;			  // So we can ignore glass
	
	// Complex collision detection.
	float			frame;
	int				sequence;
	byte			controller[4];
	byte			blending[2];

	int				movetype;
	int				takedamage;
	int				blooddecal;
	int				team;
	int				classnumber;

	// For mods
	int				iuser1;
	int				iuser2;
	int				iuser3;
	int				iuser4;
	float			fuser1;
	float			fuser2;
	float			fuser3;
	float			fuser4;
	vec3_t			vuser1;
	vec3_t			vuser2;
	vec3_t			vuser3;
	vec3_t			vuser4;
} physent_t;


typedef struct playermove_s
{
	int				player_index;  // So we don't try to run the PM_CheckStuck nudging too quickly.
	qboolean		server;        // For debugging, are we running physics code on server side?

	qboolean		multiplayer;   // 1 == multiplayer server
	float			time;          // realtime on host, for reckoning duck timing
	float			frametime;	   // Duration of this frame

	vec3_t			forward, right, up; // Vectors for angles
	// player state
	vec3_t			origin;        // Movement origin.
	vec3_t			angles;        // Movement view angles.
	vec3_t			oldangles;     // Angles before movement view angles were looked at.
	vec3_t			velocity;      // Current movement direction.
	vec3_t			movedir;       // For waterjumping, a forced forward velocity so we can fly over lip of ledge.
	vec3_t			basevelocity;  // Velocity of the conveyor we are standing, e.g.
	
	// For ducking/dead
	vec3_t			view_ofs;      // Our eye position.
	float			flDuckTime;    // Time we started duck
	qboolean		bInDuck;       // In process of ducking or ducked already?
	
	// For walking/falling
	int				flTimeStepSound;  // Next time we can play a step sound
	int				iStepLeft;

	float			flFallVelocity;
	vec3_t			punchangle;

	float			flSwimTime;

	float			flNextPrimaryAttack;

	int				effects;		// MUZZLE FLASH, e.g.

	int				flags;         // FL_ONGROUND, FL_DUCKING, etc.
	int				usehull;       // 0 = regular player hull, 1 = ducked player hull, 2 = point hull
	float			gravity;       // Our current gravity and friction.
	float			friction;
	int				oldbuttons;    // Buttons last usercmd
	float			waterjumptime; // Amount of time left in jumping out of water cycle.
	qboolean		dead;          // Are we a dead player?
	int				deadflag;
	int				spectator;     // Should we use spectator physics model?
	int				movetype;      // Our movement type, NOCLIP, WALK, FLY

	int				onground;
	int				waterlevel;
	int				watertype;
	int				oldwaterlevel;

	char			sztexturename[256];
	char			chtexturetype;

	float			maxspeed;
	float			clientmaxspeed; // Player specific maxspeed

	// For mods
	int				iuser1;
	int				iuser2;
	int				iuser3;
	int				iuser4;
	float			fuser1;
	float			fuser2;
	float			fuser3;
	float			fuser4;
	vec3_t			vuser1;
	vec3_t			vuser2;
	vec3_t			vuser3;
	vec3_t			vuser4;
	// world state
	// Number of entities to clip against.
	int				numphysent;    
	physent_t		physents[MAX_PHYSENTS];
	// Number of momvement entities (ladders)
	int				nummoveent;
	// just a list of ladders
	physent_t		moveents[MAX_MOVEENTS];	

	// All things being rendered, for tracing against things you don't actually collide with
	int				numvisent;
	physent_t		visents[ MAX_PHYSENTS ];

	// input to run through physics.
	usercmd_t		cmd;

	// Trace results for objects we collided with.
	int				numtouch;
	pmtrace_t		touchindex[MAX_PHYSENTS];

	char			physinfo[ MAX_PHYSINFO_STRING ]; // Physics info string

	struct movevars_s *movevars;
	vec3_t player_mins[ 4 ];
	vec3_t player_maxs[ 4 ];
	
	// Common functions
	const char		*(*PM_Info_ValueForKey) ( const char *s, const char *key );
	void			(*PM_Particle)( float *origin, int color, float life, int zpos, int zvel);
	int				(*PM_TestPlayerPosition) (float *pos, pmtrace_t *ptrace );
	void			(*Con_NPrintf)( int idx, char *fmt, ... );
	void			(*Con_DPrintf)( char *fmt, ... );
	void			(*Con_Printf)( char *fmt, ... );
	double			(*Sys_FloatTime)( void );
	void			(*PM_StuckTouch)( int hitent, pmtrace_t *ptraceresult );
	int				(*PM_PointContents) (float *p, int *truecontents /*filled in if this is non-null*/ );
	int				(*PM_TruePointContents) (float *p);
	int				(*PM_HullPointContents) ( struct hull_s *hull, int num, float *p);   
	pmtrace_t		(*PM_PlayerTrace) (float *start, float *end, int traceFlags, int ignore_pe );
	struct pmtrace_s *(*PM_TraceLine)( float *start, float *end, int flags, int usehulll, int ignore_pe );
	int32			(*RandomLong)( int32 lLow, int32 lHigh );
	float			(*RandomFloat)( float flLow, float flHigh );
	int				(*PM_GetModelType)( struct model_s *mod );
	void			(*PM_GetModelBounds)( struct model_s *mod, float *mins, float *maxs );
	void			*(*PM_HullForBsp)( physent_t *pe, float *offset );
	float			(*PM_TraceModel)( physent_t *pEnt, float *start, float *end, trace_t *trace );
	int				(*COM_FileSize)(char *filename);
	byte			*(*COM_LoadFile) (char *path, int usehunk, int *pLength);
	void			(*COM_FreeFile) ( void *buffer );
	char			*(*memfgets)( byte *pMemFile, int fileSize, int *pFilePos, char *pBuffer, int bufferSize );

	// Functions
	// Run functions for this frame?
	qboolean		runfuncs;      
	void			(*PM_PlaySound) ( int channel, const char *sample, float volume, float attenuation, int fFlags, int pitch );
	const char		*(*PM_TraceTexture) ( int ground, float *vstart, float *vend );
	void			(*PM_PlaybackEventFull) ( int flags, int clientindex, unsigned short eventindex, float delay, float *origin, float *angles, float fparam1, float fparam2, int iparam1, int iparam2, int bparam1, int bparam2 );
	
	pmtrace_t		(*PM_PlayerTraceEx) (float *start, float *end, int traceFlags, int (*pfnIgnore)( physent_t *pe ) );
	int				(*PM_TestPlayerPositionEx) (float *pos, pmtrace_t *ptrace, int (*pfnIgnore)( physent_t *pe ) );
	struct pmtrace_s *(*PM_TraceLineEx)( float *start, float *end, int flags, int usehulll, int (*pfnIgnore)( physent_t *pe ) );
} playermove_t;

#endif

```

`ValveSDK/pm_info.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
// Physics info string definition
#if !defined( PM_INFOH )
#define PM_INFOH
#pragma once

#define MAX_PHYSINFO_STRING 256

#endif // PM_INFOH
```

`ValveSDK/pmtrace.h`:

```h
/***
*
*	Copyright (c) 1999, 2000 Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( PMTRACEH )
#define PMTRACEH
#ifdef _WIN32
#pragma once
#endif

typedef struct
{
	vec3_t	normal;
	float	dist;
} pmplane_t;

typedef struct pmtrace_s pmtrace_t;

struct pmtrace_s
{
	qboolean	allsolid;	      // if true, plane is not valid
	qboolean	startsolid;	      // if true, the initial point was in a solid area
	qboolean	inopen, inwater;  // End point is in empty space or in water
	float		fraction;		  // time completed, 1.0 = didn't hit anything
	vec3_t		endpos;			  // final position
	pmplane_t	plane;		      // surface normal at impact
	int			ent;			  // entity at impact
	vec3_t      deltavelocity;    // Change in player's velocity caused by impact.  
								  // Only run on server.
	int         hitgroup;
};

#endif
```

`ValveSDK/progdefs.h`:

```h
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef PROGDEFS_H
#define PROGDEFS_H
#ifdef _WIN32
#pragma once
#endif

typedef struct
{	
	float		time;
	float		frametime;
	float		force_retouch;
	string_t	mapname;
	string_t	startspot;
	float		deathmatch;
	float		coop;
	float		teamplay;
	float		serverflags;
	float		found_secrets;
	vec3_t		v_forward;
	vec3_t		v_up;
	vec3_t		v_right;
	float		trace_allsolid;
	float		trace_startsolid;
	float		trace_fraction;
	vec3_t		trace_endpos;
	vec3_t		trace_plane_normal;
	float		trace_plane_dist;
	edict_t		*trace_ent;
	float		trace_inopen;
	float		trace_inwater;
	int			trace_hitgroup;
	int			trace_flags;
	int			msg_entity;
	int			cdAudioTrack;
	int			maxClients;
	int			maxEntities;
	const char	*pStringBase;

	void		*pSaveData;
	vec3_t		vecLandmarkOffset;
} globalvars_t;


typedef struct entvars_s
{
	string_t	classname;
	string_t	globalname;

	vec3_t		origin;
	vec3_t		oldorigin;
	vec3_t		velocity;
	vec3_t		basevelocity;
	vec3_t      clbasevelocity;  // Base velocity that was passed in to server physics so 
							     //  client can predict conveyors correctly.  Server zeroes it, so we need to store here, too.
	vec3_t		movedir;

	vec3_t		angles;			// Model angles
	vec3_t		avelocity;		// angle velocity (degrees per second)
	vec3_t		punchangle;		// auto-decaying view angle adjustment
	vec3_t		v_angle;		// Viewing angle (player only)

	// For parametric entities
	vec3_t		endpos;
	vec3_t		startpos;
	float		impacttime;
	float		starttime;

	int			fixangle;		// 0:nothing, 1:force view angles, 2:add avelocity
	float		idealpitch;
	float		pitch_speed;
	float		ideal_yaw;
	float		yaw_speed;

	int			modelindex;
	string_t	model;

	int			viewmodel;		// player's viewmodel
	int			weaponmodel;	// what other players see
	
	vec3_t		absmin;		// BB max translated to world coord
	vec3_t		absmax;		// BB max translated to world coord
	vec3_t		mins;		// local BB min
	vec3_t		maxs;		// local BB max
	vec3_t		size;		// maxs - mins

	float		ltime;
	float		nextthink;

	int			movetype;
	int			solid;

	int			skin;			
	int			body;			// sub-model selection for studiomodels
	int 		effects;
	
	float		gravity;		// % of "normal" gravity
	float		friction;		// inverse elasticity of MOVETYPE_BOUNCE
	
	int			light_level;

	int			sequence;		// animation sequence
	int			gaitsequence;	// movement animation sequence for player (0 for none)
	float		frame;			// % playback position in animation sequences (0..255)
	float		animtime;		// world time when frame was set
	float		framerate;		// animation playback rate (-8x to 8x)
	byte		controller[4];	// bone controller setting (0..255)
	byte		blending[2];	// blending amount between sub-sequences (0..255)

	float		scale;			// sprite rendering scale (0..255)

	int			rendermode;
	float		renderamt;
	vec3_t		rendercolor;
	int			renderfx;

	float		health;
	float		frags;
	int			weapons;  // bit mask for available weapons
	float		takedamage;

	int			deadflag;
	vec3_t		view_ofs;	// eye position

	int			button;
	int			impulse;

	edict_t		*chain;			// Entity pointer when linked into a linked list
	edict_t		*dmg_inflictor;
	edict_t		*enemy;
	edict_t		*aiment;		// entity pointer when MOVETYPE_FOLLOW
	edict_t		*owner;
	edict_t		*groundentity;

	int			spawnflags;
	int			flags;
	
	int			colormap;		// lowbyte topcolor, highbyte bottomcolor
	int			team;

	float		max_health;
	float		teleport_time;
	float		armortype;
	float		armorvalue;
	int			waterlevel;
	int			watertype;
	
	string_t	target;
	string_t	targetname;
	string_t	netname;
	string_t	message;

	float		dmg_take;
	float		dmg_save;
	float		dmg;
	float		dmgtime;
	
	string_t	noise;
	string_t	noise1;
	string_t	noise2;
	string_t	noise3;
	
	float		speed;
	float		air_finished;
	float		pain_finished;
	float		radsuit_finished;
	
	edict_t		*pContainingEntity;

	int			playerclass;
	float		maxspeed;

	float		fov;
	int			weaponanim;

	int			pushmsec;

	int			bInDuck;
	int			flTimeStepSound;
	int			flSwimTime;
	int			flDuckTime;
	int			iStepLeft;
	float		flFallVelocity;

	int			gamestate;

	int			oldbuttons;

	int			groupinfo;

	// For mods
	int			iuser1;
	int			iuser2;
	int			iuser3;
	int			iuser4;
	float		fuser1;
	float		fuser2;
	float		fuser3;
	float		fuser4;
	vec3_t		vuser1;
	vec3_t		vuser2;
	vec3_t		vuser3;
	vec3_t		vuser4;
	edict_t		*euser1;
	edict_t		*euser2;
	edict_t		*euser3;
	edict_t		*euser4;
} entvars_t;


#endif // PROGDEFS_H
```

`ValveSDK/progs.h`:

```h
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef PROGS_H
#define PROGS_H

#include "progdefs.h"

// 16 simultaneous events, max
#define MAX_EVENT_QUEUE 64

#define DEFAULT_EVENT_RESENDS 1

#include "event_flags.h"

typedef struct event_info_s event_info_t;

#include "event_args.h"

struct event_info_s
{
	unsigned short index;			  // 0 implies not in use

	short packet_index;      // Use data from state info for entity in delta_packet .  -1 implies separate info based on event
	                         // parameter signature
	short entity_index;      // The edict this event is associated with

	float fire_time;        // if non-zero, the time when the event should be fired ( fixed up on the client )
	
	event_args_t args;

// CLIENT ONLY	
	int	  flags;			// Reliable or not, etc.

};

typedef struct event_state_s event_state_t;

struct event_state_s
{
	struct event_info_s ei[ MAX_EVENT_QUEUE ];
};

#if !defined( ENTITY_STATEH )
#include "entity_state.h"
#endif

#if !defined( EDICT_H )
#include "edict.h"
#endif

#define	STRUCT_FROM_LINK(l,t,m) ((t *)((byte *)l - (int)&(((t *)0)->m)))
#define	EDICT_FROM_AREA(l) STRUCT_FROM_LINK(l,edict_t,area)

//============================================================================

extern	char			*pr_strings;
extern	globalvars_t	gGlobalVariables;

//============================================================================

edict_t		*ED_Alloc (void);
void		ED_Free (edict_t *ed);
void		ED_LoadFromFile (char *data);

edict_t		*EDICT_NUM(int n);
int			NUM_FOR_EDICT(const edict_t *e);

#define PROG_TO_EDICT(e) ((edict_t *)((byte *)sv.edicts + e))

#endif // PROGS_H
```

`ValveSDK/r_efx.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( R_EFXH )
#define R_EFXH
#ifdef _WIN32
#pragma once
#endif

// particle_t
#if !defined( PARTICLEDEFH )  
#include "particledef.h"
#endif

// BEAM
#if !defined( BEAMDEFH )
#include "beamdef.h"
#endif

// dlight_t
#if !defined ( DLIGHTH )
#include "dlight.h"
#endif

// cl_entity_t
#if !defined( CL_ENTITYH )
#include "cl_entity.h"
#endif

/*
// FOR REFERENCE, These are the built-in tracer colors.  Note, color 4 is the one
//  that uses the tracerred/tracergreen/tracerblue and traceralpha cvar settings
color24 gTracerColors[] =
{
	{ 255, 255, 255 },		// White
	{ 255, 0, 0 },			// Red
	{ 0, 255, 0 },			// Green
	{ 0, 0, 255 },			// Blue
	{ 0, 0, 0 },			// Tracer default, filled in from cvars, etc.
	{ 255, 167, 17 },		// Yellow-orange sparks
	{ 255, 130, 90 },		// Yellowish streaks (garg)
	{ 55, 60, 144 },		// Blue egon streak
	{ 255, 130, 90 },		// More Yellowish streaks (garg)
	{ 255, 140, 90 },		// More Yellowish streaks (garg)
	{ 200, 130, 90 },		// More red streaks (garg)
	{ 255, 120, 70 },		// Darker red streaks (garg)
};
*/

// Temporary entity array
#define TENTPRIORITY_LOW	0
#define TENTPRIORITY_HIGH	1

// TEMPENTITY flags
#define	FTENT_NONE				0x00000000
#define	FTENT_SINEWAVE			0x00000001
#define	FTENT_GRAVITY			0x00000002
#define FTENT_ROTATE			0x00000004
#define	FTENT_SLOWGRAVITY		0x00000008
#define FTENT_SMOKETRAIL		0x00000010
#define FTENT_COLLIDEWORLD		0x00000020
#define FTENT_FLICKER			0x00000040
#define FTENT_FADEOUT			0x00000080
#define FTENT_SPRANIMATE		0x00000100
#define FTENT_HITSOUND			0x00000200
#define FTENT_SPIRAL			0x00000400
#define FTENT_SPRCYCLE			0x00000800
#define FTENT_COLLIDEALL		0x00001000 // will collide with world and slideboxes
#define FTENT_PERSIST			0x00002000 // tent is not removed when unable to draw 
#define FTENT_COLLIDEKILL		0x00004000 // tent is removed upon collision with anything
#define FTENT_PLYRATTACHMENT	0x00008000 // tent is attached to a player (owner)
#define FTENT_SPRANIMATELOOP	0x00010000 // animating sprite doesn't die when last frame is displayed
#define FTENT_SPARKSHOWER		0x00020000
#define FTENT_NOMODEL			0x00040000 // Doesn't have a model, never try to draw ( it just triggers other things )
#define FTENT_CLIENTCUSTOM		0x00080000 // Must specify callback.  Callback function is responsible for killing tempent and updating fields ( unless other flags specify how to do things )

typedef struct tempent_s
{
	int			flags;
	float		die;
	float		frameMax;
	float		x;
	float		y;
	float		z;
	float		fadeSpeed;
	float		bounceFactor;
	int			hitSound;
	void		( *hitcallback )	( struct tempent_s *ent, struct pmtrace_s *ptr );
	void		( *callback )		( struct tempent_s *ent, float frametime, float currenttime );
	struct tempent_s	*next;
	int			priority;
	short		clientIndex;	// if attached, this is the index of the client to stick to
								// if COLLIDEALL, this is the index of the client to ignore
								// TENTS with FTENT_PLYRATTACHMENT MUST set the clientindex! 

	vec3_t		tentOffset;		// if attached, client origin + tentOffset = tent origin.
	cl_entity_t	entity;

	// baseline.origin		- velocity
	// baseline.renderamt	- starting fadeout intensity
	// baseline.angles		- angle velocity
} TEMPENTITY;

typedef struct efx_api_s efx_api_t;

struct efx_api_s
{
	particle_t  *( *R_AllocParticle )			( void ( *callback ) ( struct particle_s *particle, float frametime ) );
	void		( *R_BlobExplosion )			( float * org );
	void		( *R_Blood )					( float * org, float * dir, int pcolor, int speed );
	void		( *R_BloodSprite )				( float * org, int colorindex, int modelIndex, int modelIndex2, float size );
	void		( *R_BloodStream )				( float * org, float * dir, int pcolor, int speed );
	void		( *R_BreakModel )				( float *pos, float *size, float *dir, float random, float life, int count, int modelIndex, char flags );
	void		( *R_Bubbles )					( float * mins, float * maxs, float height, int modelIndex, int count, float speed );
	void		( *R_BubbleTrail )				( float * start, float * end, float height, int modelIndex, int count, float speed );
	void		( *R_BulletImpactParticles )	( float * pos );
	void		( *R_EntityParticles )			( struct cl_entity_s *ent );
	void		( *R_Explosion )				( float *pos, int model, float scale, float framerate, int flags );
	void		( *R_FizzEffect )				( struct cl_entity_s *pent, int modelIndex, int density );
	void		( *R_FireField ) 				( float * org, int radius, int modelIndex, int count, int flags, float life );
	void		( *R_FlickerParticles )			( float * org );
	void		( *R_FunnelSprite )				( float *org, int modelIndex, int reverse );
	void		( *R_Implosion )				( float * end, float radius, int count, float life );
	void		( *R_LargeFunnel )				( float * org, int reverse );
	void		( *R_LavaSplash )				( float * org );
	void		( *R_MultiGunshot )				( float * org, float * dir, float * noise, int count, int decalCount, int *decalIndices );
	void		( *R_MuzzleFlash )				( float *pos1, int type );
	void		( *R_ParticleBox )				( float *mins, float *maxs, unsigned char r, unsigned char g, unsigned char b, float life );
	void		( *R_ParticleBurst )			( float * pos, int size, int color, float life );
	void		( *R_ParticleExplosion )		( float * org );
	void		( *R_ParticleExplosion2 )		( float * org, int colorStart, int colorLength );
	void		( *R_ParticleLine )				( float * start, float *end, unsigned char r, unsigned char g, unsigned char b, float life );
	void		( *R_PlayerSprites )			( int client, int modelIndex, int count, int size );
	void		( *R_Projectile )				( float * origin, float * velocity, int modelIndex, int life, int owner, void (*hitcallback)( struct tempent_s *ent, struct pmtrace_s *ptr ) );
	void		( *R_RicochetSound )			( float * pos );
	void		( *R_RicochetSprite )			( float *pos, struct model_s *pmodel, float duration, float scale );
	void		( *R_RocketFlare )				( float *pos );
	void		( *R_RocketTrail )				( float * start, float * end, int type );
	void		( *R_RunParticleEffect )		( float * org, float * dir, int color, int count );
	void		( *R_ShowLine )					( float * start, float * end );
	void		( *R_SparkEffect )				( float *pos, int count, int velocityMin, int velocityMax );
	void		( *R_SparkShower )				( float *pos );
	void		( *R_SparkStreaks )				( float * pos, int count, int velocityMin, int velocityMax );
	void		( *R_Spray )					( float * pos, float * dir, int modelIndex, int count, int speed, int spread, int rendermode );
	void		( *R_Sprite_Explode )			( TEMPENTITY *pTemp, float scale, int flags );
	void		( *R_Sprite_Smoke )				( TEMPENTITY *pTemp, float scale );
	void		( *R_Sprite_Spray )				( float * pos, float * dir, int modelIndex, int count, int speed, int iRand );
	void		( *R_Sprite_Trail )				( int type, float * start, float * end, int modelIndex, int count, float life, float size, float amplitude, int renderamt, float speed );
	void		( *R_Sprite_WallPuff )			( TEMPENTITY *pTemp, float scale );
	void		( *R_StreakSplash )				( float * pos, float * dir, int color, int count, float speed, int velocityMin, int velocityMax );
	void		( *R_TracerEffect )				( float * start, float * end );
	void		( *R_UserTracerParticle )		( float * org, float * vel, float life, int colorIndex, float length, unsigned char deathcontext, void ( *deathfunc)( struct particle_s *particle ) );
	particle_t *( *R_TracerParticles )			( float * org, float * vel, float life );
	void		( *R_TeleportSplash )			( float * org );
	void		( *R_TempSphereModel )			( float *pos, float speed, float life, int count, int modelIndex );
	TEMPENTITY	*( *R_TempModel )				( float *pos, float *dir, float *angles, float life, int modelIndex, int soundtype );
	TEMPENTITY	*( *R_DefaultSprite )			( float *pos, int spriteIndex, float framerate );
	TEMPENTITY	*( *R_TempSprite )				( float *pos, float *dir, float scale, int modelIndex, int rendermode, int renderfx, float a, float life, int flags );
	int			( *Draw_DecalIndex )			( int id );
	int			( *Draw_DecalIndexFromName )	( char *name );
	void		( *R_DecalShoot )				( int textureIndex, int entity, int modelIndex, float * position, int flags );
	void		( *R_AttachTentToPlayer )		( int client, int modelIndex, float zoffset, float life );
	void		( *R_KillAttachedTents )		( int client );
	BEAM		*( *R_BeamCirclePoints )		( int type, float * start, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamEntPoint )			( int startEnt, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamEnts )				( int startEnt, int endEnt, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamFollow )				( int startEnt, int modelIndex, float life, float width, float r, float g, float b, float brightness );
	void		( *R_BeamKill )					( int deadEntity );
	BEAM		*( *R_BeamLightning )			( float * start, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed );
	BEAM		*( *R_BeamPoints )				( float * start, float * end, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	BEAM		*( *R_BeamRing )				( int startEnt, int endEnt, int modelIndex, float life, float width, float amplitude, float brightness, float speed, int startFrame, float framerate, float r, float g, float b );
	dlight_t	*( *CL_AllocDlight )			( int key );
	dlight_t	*( *CL_AllocElight )			( int key );
	TEMPENTITY	*( *CL_TempEntAlloc )			( float * org, struct model_s *model );
	TEMPENTITY	*( *CL_TempEntAllocNoModel )	( float * org );
	TEMPENTITY	*( *CL_TempEntAllocHigh )		( float * org, struct model_s *model );
	TEMPENTITY	*( *CL_TentEntAllocCustom )		( float *origin, struct model_s *model, int high, void ( *callback ) ( struct tempent_s *ent, float frametime, float currenttime ) );
	void		( *R_GetPackedColor )			( short *packed, short color );
	short		( *R_LookupColor )				( unsigned char r, unsigned char g, unsigned char b );
	void		( *R_DecalRemoveAll )			( int textureIndex ); //textureIndex points to the decal index in the array, not the actual texture index.
	void		( *R_FireCustomDecal )			( int textureIndex, int entity, int modelIndex, float * position, int flags, float scale );
};

extern efx_api_t efx;

#endif

```

`ValveSDK/r_studioint.h`:

```h
#if !defined( R_STUDIOINT_H )
#define R_STUDIOINT_H
#if defined( _WIN32 )
#pragma once
#endif

#define STUDIO_INTERFACE_VERSION 1

typedef struct engine_studio_api_s
{
	// Allocate number*size bytes and zero it
	void			*( *Mem_Calloc )				( int number, size_t size );
	// Check to see if pointer is in the cache
	void			*( *Cache_Check )				( struct cache_user_s *c );
	// Load file into cache ( can be swapped out on demand )
	void			( *LoadCacheFile )				( char *path, struct cache_user_s *cu );
	// Retrieve model pointer for the named model
	struct model_s	*( *Mod_ForName )				( const char *name, int crash_if_missing );
	// Retrieve pointer to studio model data block from a model
	void			*( *Mod_Extradata )				( struct model_s *mod );
	// Retrieve indexed model from client side model precache list
	struct model_s	*( *GetModelByIndex )			( int index );
	// Get entity that is set for rendering
	struct cl_entity_s * ( *GetCurrentEntity )		( void );
	// Get referenced player_info_t
	struct player_info_s *( *PlayerInfo )			( int index );
	// Get most recently received player state data from network system
	struct entity_state_s *( *GetPlayerState )		( int index );
	// Get viewentity
	struct cl_entity_s * ( *GetViewEntity )			( void );
	// Get current frame count, and last two timestampes on client
	void			( *GetTimes )					( int *framecount, double *current, double *old );
	// Get a pointer to a cvar by name
	struct cvar_s	*( *GetCvar )					( const char *name );
	// Get current render origin and view vectors ( up, right and vpn )
	void			( *GetViewInfo )				( float *origin, float *upv, float *rightv, float *vpnv );
	// Get sprite model used for applying chrome effect
	struct model_s	*( *GetChromeSprite )			( void );
	// Get model counters so we can incement instrumentation
	void			( *GetModelCounters )			( int **s, int **a );
	// Get software scaling coefficients
	void			( *GetAliasScale )				( float *x, float *y );

	// Get bone, light, alias, and rotation matrices
	float			****( *StudioGetBoneTransform ) ( void );
	float			****( *StudioGetLightTransform )( void );
	float			***( *StudioGetAliasTransform ) ( void );
	float			***( *StudioGetRotationMatrix ) ( void );

	// Set up body part, and get submodel pointers
	void			( *StudioSetupModel )			( int bodypart, void **ppbodypart, void **ppsubmodel );
	// Check if entity's bbox is in the view frustum
	int				( *StudioCheckBBox )			( void );
	// Apply lighting effects to model
	void			( *StudioDynamicLight )			( struct cl_entity_s *ent, struct alight_s *plight );
	void			( *StudioEntityLight )			( struct alight_s *plight );
	void			( *StudioSetupLighting )		( struct alight_s *plighting );

	// Draw mesh vertices
	void			( *StudioDrawPoints )			( void );

	// Draw hulls around bones
	void			( *StudioDrawHulls )			( void );
	// Draw bbox around studio models
	void			( *StudioDrawAbsBBox )			( void );
	// Draws bones
	void			( *StudioDrawBones )			( void );
	// Loads in appropriate texture for model
	void			( *StudioSetupSkin )			( void *ptexturehdr, int index );
	// Sets up for remapped colors
	void			( *StudioSetRemapColors )		( int top, int bottom );
	// Set's player model and returns model pointer
	struct model_s	*( *SetupPlayerModel )			( int index );
	// Fires any events embedded in animation
	void			( *StudioClientEvents )			( void );
	// Retrieve/set forced render effects flags
	int				( *GetForceFaceFlags )			( void );
	void			( *SetForceFaceFlags )			( int flags );
	// Tell engine the value of the studio model header
	void			( *StudioSetHeader )			( void *header );
	// Tell engine which model_t * is being renderered
	void			( *SetRenderModel )				( struct model_s *model );

	// Final state setup and restore for rendering
	void			( *SetupRenderer )				( int rendermode );
	void			( *RestoreRenderer )			( void );

	// Set render origin for applying chrome effect
	void			( *SetChromeOrigin )			( void );

	// True if using D3D/OpenGL
	int				( *IsHardware )					( void );
	
	// Only called by hardware interface
	void			( *GL_StudioDrawShadow )		( void );
	void			( *GL_SetRenderMode )			( int mode );

	void			( *StudioSetRenderamt )			(int iRenderamt); 	//!!!CZERO added for rendering glass on viewmodels
	void			( *StudioSetCullState )			( int iCull	   );
	void			( *StudioRenderShadow )			( int iSprite, float *p1, float *p2, float *p3, float *p4 );
} engine_studio_api_t;

typedef struct server_studio_api_s
{
	// Allocate number*size bytes and zero it
	void			*( *Mem_Calloc )				( int number, size_t size );
	// Check to see if pointer is in the cache
	void			*( *Cache_Check )				( struct cache_user_s *c );
	// Load file into cache ( can be swapped out on demand )
	void			( *LoadCacheFile )				( char *path, struct cache_user_s *cu );
	// Retrieve pointer to studio model data block from a model
	void			*( *Mod_Extradata )				( struct model_s *mod );
} server_studio_api_t;


// client blending
typedef struct r_studio_interface_s
{
	int				version;
	int				( *StudioDrawModel	)			( int flags );
	int				( *StudioDrawPlayer	)			( int flags, struct entity_state_s *pplayer );
} r_studio_interface_t;

extern r_studio_interface_t *pStudioAPI;

// server blending
#define SV_BLENDING_INTERFACE_VERSION 1

typedef struct sv_blending_interface_s
{
	int				version;

	void			( *SV_StudioSetupBones )		( struct model_s	*pModel, 
													  float				frame, 
													  int				sequence, 
													  const vec3_t		angles, 
													  const	vec3_t		origin, 
													  const	byte		*pcontroller,
													  const	byte		*pblending, 
													  int				iBone,
													  const edict_t		*pEdict );
} sv_blending_interface_t;

#endif // R_STUDIOINT_H

```

`ValveSDK/ref_params.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( REF_PARAMSH )
#define REF_PARAMSH

typedef struct ref_params_s
{
	// Output
	float	vieworg[3];
	float	viewangles[3];

	float	forward[3];
	float	right[3];
	float   up[3];

	// Client frametime;
	float	frametime;
	// Client time
	float	time;

	// Misc
	int		intermission;
	int		paused;
	int		spectator;
	int		onground;
	int		waterlevel;

	float	simvel[3];
	float	simorg[3];

	float	viewheight[3];
	float	idealpitch;

	float	cl_viewangles[3];

	int		health;
	float	crosshairangle[3];
	float	viewsize;

	float	punchangle[3];
	int		maxclients;
	int		viewentity;
	int		playernum;
	int		max_entities;
	int		demoplayback;
	int		hardware;

	int		smoothing;

	// Last issued usercmd
	struct usercmd_s *cmd;

	// Movevars
	struct movevars_s *movevars;

	int		viewport[4];		// the viewport coordinates x ,y , width, height

	int		nextView;			// the renderer calls ClientDLL_CalcRefdef() and Renderview
								// so long in cycles until this value is 0 (multiple views)
	int		onlyClientDraw;		// if !=0 nothing is drawn by the engine except clientDraw functions
} ref_params_t;

#endif // !REF_PARAMSH

```

`ValveSDK/screenfade.h`:

```h
//========= Copyright © 1996-2002, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#if !defined( SCREENFADEH )
#define SCREENFADEH
#ifdef _WIN32
#pragma once
#endif

typedef struct screenfade_s
{
	float		fadeSpeed;		// How fast to fade (tics / second) (+ fade in, - fade out)
	float		fadeEnd;		// When the fading hits maximum
	float		fadeTotalEnd;	// Total End Time of the fade (used for FFADE_OUT)
	float		fadeReset;		// When to reset to not fading (for fadeout and hold)
	byte		fader, fadeg, fadeb, fadealpha;	// Fade color
	int			fadeFlags;		// Fading flags
} screenfade_t;

#endif // !SCREENFADEH

```

`ValveSDK/studio.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/




#ifndef _STUDIO_H_
#define _STUDIO_H_

/*
==============================================================================

STUDIO MODELS

Studio models are position independent, so the cache manager can move them.
==============================================================================
*/
 

#define MAXSTUDIOTRIANGLES	20000	// TODO: tune this
#define MAXSTUDIOVERTS		2048	// TODO: tune this
#define MAXSTUDIOSEQUENCES	2048	// total animation sequences -- KSH incremented
#define MAXSTUDIOSKINS		100		// total textures
#define MAXSTUDIOSRCBONES	512		// bones allowed at source movement
#define MAXSTUDIOBONES		128		// total bones actually used
#define MAXSTUDIOMODELS		32		// sub-models per model
#define MAXSTUDIOBODYPARTS	32
#define MAXSTUDIOGROUPS		16
#define MAXSTUDIOANIMATIONS	2048		
#define MAXSTUDIOMESHES		256
#define MAXSTUDIOEVENTS		1024
#define MAXSTUDIOPIVOTS		256
#define MAXSTUDIOCONTROLLERS 8

typedef struct 
{
	int					id;
	int					version;

	char				name[64];
	int					length;

	vec3_t				eyeposition;	// ideal eye position
	vec3_t				min;			// ideal movement hull size
	vec3_t				max;			

	vec3_t				bbmin;			// clipping bounding box
	vec3_t				bbmax;		

	int					flags;

	int					numbones;			// bones
	int					boneindex;

	int					numbonecontrollers;		// bone controllers
	int					bonecontrollerindex;

	int					numhitboxes;			// complex bounding boxes
	int					hitboxindex;			
	
	int					numseq;				// animation sequences
	int					seqindex;

	int					numseqgroups;		// demand loaded sequences
	int					seqgroupindex;

	int					numtextures;		// raw textures
	int					textureindex;
	int					texturedataindex;

	int					numskinref;			// replaceable textures
	int					numskinfamilies;
	int					skinindex;

	int					numbodyparts;		
	int					bodypartindex;

	int					numattachments;		// queryable attachable points
	int					attachmentindex;

	int					soundtable;
	int					soundindex;
	int					soundgroups;
	int					soundgroupindex;

	int					numtransitions;		// animation node to animation node transition graph
	int					transitionindex;
} studiohdr_t;

// header for demand loaded sequence group data
typedef struct 
{
	int					id;
	int					version;

	char				name[64];
	int					length;
} studioseqhdr_t;

// bones
typedef struct 
{
	char				name[32];	// bone name for symbolic links
	int		 			parent;		// parent bone
	int					flags;		// ??
	int					bonecontroller[6];	// bone controller index, -1 == none
	float				value[6];	// default DoF values
	float				scale[6];   // scale for delta DoF values
} mstudiobone_t;


// bone controllers
typedef struct 
{
	int					bone;	// -1 == 0
	int					type;	// X, Y, Z, XR, YR, ZR, M
	float				start;
	float				end;
	int					rest;	// byte index value at rest
	int					index;	// 0-3 user set controller, 4 mouth
} mstudiobonecontroller_t;

// intersection boxes
typedef struct
{
	int					bone;
	int					group;			// intersection group
	vec3_t				bbmin;		// bounding box
	vec3_t				bbmax;		
} mstudiobbox_t;

#if !defined( CACHE_USER ) && !defined( QUAKEDEF_H )
#define CACHE_USER
typedef struct cache_user_s
{
	void *data;
} cache_user_t;
#endif

//
// demand loaded sequence groups
//
typedef struct
{
	char				label[32];	// textual name
	char				name[64];	// file name
    int32				unused1;    // was "cache"  - index pointer
	int					unused2;    // was "data" -  hack for group 0
} mstudioseqgroup_t;

// sequence descriptions
typedef struct
{
	char				label[32];	// sequence label

	float				fps;		// frames per second	
	int					flags;		// looping/non-looping flags

	int					activity;
	int					actweight;

	int					numevents;
	int					eventindex;

	int					numframes;	// number of frames per sequence

	int					numpivots;	// number of foot pivots
	int					pivotindex;

	int					motiontype;	
	int					motionbone;
	vec3_t				linearmovement;
	int					automoveposindex;
	int					automoveangleindex;

	vec3_t				bbmin;		// per sequence bounding box
	vec3_t				bbmax;		

	int					numblends;
	int					animindex;		// mstudioanim_t pointer relative to start of sequence group data
										// [blend][bone][X, Y, Z, XR, YR, ZR]

	int					blendtype[2];	// X, Y, Z, XR, YR, ZR
	float				blendstart[2];	// starting value
	float				blendend[2];	// ending value
	int					blendparent;

	int					seqgroup;		// sequence group for demand loading

	int					entrynode;		// transition node at entry
	int					exitnode;		// transition node at exit
	int					nodeflags;		// transition rules
	
	int					nextseq;		// auto advancing sequences
} mstudioseqdesc_t;

// events
#include "studio_event.h"
/*
typedef struct 
{
	int 				frame;
	int					event;
	int					type;
	char				options[64];
} mstudioevent_t;
*/

// pivots
typedef struct 
{
	vec3_t				org;	// pivot point
	int					start;
	int					end;
} mstudiopivot_t;

// attachment
typedef struct 
{
	char				name[32];
	int					type;
	int					bone;
	vec3_t				org;	// attachment point
	vec3_t				vectors[3];
} mstudioattachment_t;

typedef struct
{
	unsigned short	offset[6];
} mstudioanim_t;

// animation frames
typedef union 
{
	struct {
		byte	valid;
		byte	total;
	} num;
	short		value;
} mstudioanimvalue_t;



// body part index
typedef struct
{
	char				name[64];
	int					nummodels;
	int					base;
	int					modelindex; // index into models array
} mstudiobodyparts_t;



// skin info
typedef struct
{
	char					name[64];
	int						flags;
	int						width;
	int						height;
	int						index;
} mstudiotexture_t;


// skin families
// short	index[skinfamilies][skinref]

// studio models
typedef struct
{
	char				name[64];

	int					type;

	float				boundingradius;

	int					nummesh;
	int					meshindex;

	int					numverts;		// number of unique vertices
	int					vertinfoindex;	// vertex bone info
	int					vertindex;		// vertex vec3_t
	int					numnorms;		// number of unique surface normals
	int					norminfoindex;	// normal bone info
	int					normindex;		// normal vec3_t

	int					numgroups;		// deformation groups
	int					groupindex;
} mstudiomodel_t;


// vec3_t	boundingbox[model][bone][2];	// complex intersection info


// meshes
typedef struct 
{
	int					numtris;
	int					triindex;
	int					skinref;
	int					numnorms;		// per mesh normals
	int					normindex;		// normal vec3_t
} mstudiomesh_t;

// triangles
#if 0
typedef struct 
{
	short				vertindex;		// index into vertex array
	short				normindex;		// index into normal array
	short				s,t;			// s,t position on skin
} mstudiotrivert_t;
#endif

// lighting options
#define STUDIO_NF_FLATSHADE		0x0001
#define STUDIO_NF_CHROME		0x0002
#define STUDIO_NF_FULLBRIGHT	0x0004
#define STUDIO_NF_NOMIPS        0x0008
#define STUDIO_NF_ALPHA         0x0010
#define STUDIO_NF_ADDITIVE      0x0020
#define STUDIO_NF_MASKED        0x0040

// motion flags
#define STUDIO_X		0x0001
#define STUDIO_Y		0x0002	
#define STUDIO_Z		0x0004
#define STUDIO_XR		0x0008
#define STUDIO_YR		0x0010
#define STUDIO_ZR		0x0020
#define STUDIO_LX		0x0040
#define STUDIO_LY		0x0080
#define STUDIO_LZ		0x0100
#define STUDIO_AX		0x0200
#define STUDIO_AY		0x0400
#define STUDIO_AZ		0x0800
#define STUDIO_AXR		0x1000
#define STUDIO_AYR		0x2000
#define STUDIO_AZR		0x4000
#define STUDIO_TYPES	0x7FFF
#define STUDIO_RLOOP	0x8000	// controller that wraps shortest distance

// sequence flags
#define STUDIO_LOOPING	0x0001

// bone flags
#define STUDIO_HAS_NORMALS	0x0001
#define STUDIO_HAS_VERTICES 0x0002
#define STUDIO_HAS_BBOX		0x0004
#define STUDIO_HAS_CHROME	0x0008	// if any of the textures have chrome on them

#define RAD_TO_STUDIO		(32768.0/M_PI)
#define STUDIO_TO_RAD		(M_PI/32768.0)

#endif

```

`ValveSDK/studio_event.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( STUDIO_EVENTH )
#define STUDIO_EVENTH
#ifdef _WIN32
#pragma once
#endif

typedef struct mstudioevent_s
{
	int 				frame;
	int					event;
	int					type;
	char				options[64];
} mstudioevent_t;

#endif // STUDIO_EVENTH

```

`ValveSDK/triangleapi.h`:

```h
/***
*
*	Copyright (c) 1999, 2000, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined( TRIANGLEAPIH )
#define TRIANGLEAPIH
#pragma once

typedef enum 
{
	TRI_FRONT = 0,
	TRI_NONE = 1,
} TRICULLSTYLE;

#define TRI_API_VERSION		1

#define TRI_TRIANGLES		0
#define TRI_TRIANGLE_FAN	1
#define TRI_QUADS			2
#define TRI_POLYGON			3
#define TRI_LINES			4	
#define TRI_TRIANGLE_STRIP	5
#define TRI_QUAD_STRIP		6

typedef struct triangleapi_s
{
	int			version;

	void		( *RenderMode )( int mode );
	void		( *Begin )( int primitiveCode );
	void		( *End ) ( void );

	void		( *Color4f ) ( float r, float g, float b, float a );
	void		( *Color4ub ) ( unsigned char r, unsigned char g, unsigned char b, unsigned char a );
	void		( *TexCoord2f ) ( float u, float v );
	void		( *Vertex3fv ) ( float *worldPnt );
	void		( *Vertex3f ) ( float x, float y, float z );
	void		( *Brightness ) ( float brightness );
	void		( *CullFace ) ( TRICULLSTYLE style );
	int			( *SpriteTexture ) ( struct model_s *pSpriteModel, int frame );
	int			( *WorldToScreen ) ( float *world, float *screen );  // Returns 1 if it's z clipped
} triangleapi_t;

#endif // !TRIANGLEAPIH
```

`ValveSDK/usercmd.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#ifndef USERCMD_H
#define USERCMD_H
#ifdef _WIN32
#pragma once
#endif

typedef struct usercmd_s
{
	short	lerp_msec;      // Interpolation time on client
	byte	msec;           // Duration in ms of command
	vec3_t	viewangles;     // Command view angles.

// intended velocities
	float	forwardmove;    // Forward velocity.
	float	sidemove;       // Sideways velocity.
	float	upmove;         // Upward velocity.
	byte	lightlevel;     // Light level at spot where we are standing.
	unsigned short  buttons;  // Attack buttons
	byte    impulse;          // Impulse command issued.
	byte	weaponselect;	// Current weapon id

// Experimental player impact stuff.
	int		impact_index;
	vec3_t	impact_position;
} usercmd_t;

#endif // USERCMD_H

```

`ValveSDK/util_vector.h`:

```h
/***
*
*	Copyright (c) 1999, Valve LLC. All rights reserved.
*
*	This product contains software technology licensed from Id
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc.
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
//  Vector.h
// A subset of the extdll.h in the project HL Entity DLL
//

#if !defined FILE_UTIL_VECTOR_H
#define FILE_UTIL_VECTOR_H

// Misc C-runtime library headers
#include "STDIO.H"
#include "STDLIB.H"
#include "MATH.H"

// Header file containing definition of globalvars_t and entvars_t
typedef int	func_t;					//
typedef int	string_t;				// from engine's pr_comp.h;
typedef float vec_t;				// needed before including progdefs.h

//=========================================================
// 2DVector - used for many pathfinding and many other 
// operations that are treated as planar rather than 3d.
//=========================================================
class Vector2D
{
public:
	inline Vector2D ( )
		: x ( 0.0f ), y ( 0.0f )
	{
	}

	inline Vector2D ( float X, float Y )
		: x ( X ), y ( Y )
	{
	}

	inline Vector2D ( float XY )
		: x ( XY ), y ( XY )
	{
	}

	inline float operator [] ( int i ) const
	{
		return ( ( float* )this )[i];
	}

	inline float& operator [] ( int i )
	{
		return ( ( float* )this )[i];
	}

	inline Vector2D& operator += ( const Vector2D &v )
	{
		x += v.x;
		y += v.y;

		return *this;
	}

	inline Vector2D& operator -= ( const Vector2D &v )
	{
		x -= v.x;
		y -= v.y;

		return *this;
	}

	inline Vector2D& operator *= ( const Vector2D &v )
	{
		x *= v.x;
		y *= v.y;

		return *this;
	}

	inline Vector2D& operator /= ( const Vector2D &v )
	{
		x /= v.x;
		y /= v.y;

		return *this;
	}

	inline Vector2D& operator += ( float v )
	{
		x += v;
		y += v;

		return *this;
	}

	inline Vector2D& operator -= ( float v )
	{
		x -= v;
		y -= v;

		return *this;
	}

	inline Vector2D& operator *= ( float v )
	{
		x *= v;
		y *= v;

		return *this;
	}

	inline Vector2D& operator /= ( float v )
	{
		x /= v;
		y /= v;

		return *this;
	}

	inline Vector2D operator - ( ) const
	{
		return Vector2D ( -x, -y );
	}

	inline Vector2D operator - ( const Vector2D &v ) const
	{
		return Vector2D ( x - v.x, y - v.y );
	}

	inline Vector2D operator + ( const Vector2D &v ) const
	{
		return Vector2D ( x + v.x, y + v.y );
	}

	inline Vector2D operator * ( const Vector2D &v ) const
	{
		return Vector2D ( x * v.x, y * v.y );
	}

	inline Vector2D operator / ( const Vector2D &v ) const
	{
		return Vector2D ( x / v.x, y / v.y );
	}

	inline float Length ( ) const
	{
		return sqrtf ( x * x + y * y );
	}

	inline float LengthSqr ( ) const
	{
		return ( x * x + y * y );
	}

	inline bool IsZero ( ) const
	{
		return ( x > -0.01f && x < 0.01f &&	y > -0.01f && y < 0.01f );
	}

	inline float DistTo ( const Vector2D &v ) const
	{
		return ( *this - v ).Length ( );
	}

	inline float DistToSqr ( const Vector2D &v ) const
	{
		return ( *this - v ).LengthSqr ( );
	}

	inline float Dot ( const Vector2D &v ) const
	{
		return ( x * v.x + y * v.y );
	}

	inline operator float *( )
	{
		return &x;
	}

	inline operator const float *( ) const
	{
		return &x;
	}

	inline Vector2D Normalize ( void ) const
	{
		float flLen = Length ( );

		if ( !flLen )
		{
			return Vector2D ( 0.0f, 0.0f );
		}
		else
		{
			flLen = 1.0f / flLen;

			return Vector2D ( x * flLen, y * flLen );
		}
	}

	vec_t	x, y;
};

inline Vector2D operator * ( float f, const Vector2D &v )
{
	return v * f;
}

//=========================================================
// 3D Vector
//=========================================================
class Vector						// same data-layout as engine's vec3_t,
{								//		which is a vec_t[3]
public:
	// Construction/destruction
	inline Vector ( )
		: x ( 0.0f ), y ( 0.0f ), z ( 0.0f )
	{
	}

	inline Vector ( float X, float Y, float Z )
		: x ( X ), y ( Y ), z ( Z )
	{
	}

	inline Vector ( float XYZ )
		: x ( XYZ ), y ( XYZ ), z ( XYZ )
	{
	}

	inline Vector ( float* v )
		: x ( v[0] ), y ( v[1] ), z ( v[2] )
	{
	}

	inline Vector ( const float* v )
		: x ( v[0] ), y ( v[1] ), z ( v[2] )
	{
	}

	// Operators
	inline float operator [] ( int i ) const
	{
		return ( ( float* )this )[i];
	}

	inline float& operator [] ( int i )
	{
		return ( ( float* )this )[i];
	}

	inline Vector& operator += ( const Vector &v )
	{
		x += v.x;
		y += v.y;
		z += v.z;

		return *this;
	}

	inline Vector& operator -= ( const Vector &v )
	{
		x -= v.x;
		y -= v.y;
		z -= v.z;

		return *this;
	}

	inline Vector& operator *= ( const Vector &v )
	{
		x *= v.x;
		y *= v.y;
		z *= v.z;

		return *this;
	}

	inline Vector& operator /= ( const Vector &v )
	{
		x /= v.x;
		y /= v.y;
		z /= v.z;

		return *this;
	}

	inline Vector& operator += ( float v )
	{
		x += v;
		y += v;
		z += v;

		return *this;
	}

	inline Vector& operator -= ( float v )
	{
		x -= v;
		y -= v;
		z -= v;

		return *this;
	}

	inline Vector& operator *= ( float v )
	{
		x *= v;
		y *= v;
		z *= v;

		return *this;
	}

	inline Vector& operator /= ( float v )
	{
		x /= v;
		y /= v;
		z /= v;

		return *this;
	}

	inline Vector operator - ( ) const
	{
		return Vector ( -x, -y, -z );
	}

	inline Vector operator - ( const Vector &v ) const
	{
		return Vector ( x - v.x, y - v.y, z - v.z );
	}

	inline Vector operator + ( const Vector &v ) const
	{
		return Vector ( x + v.x, y + v.y, z + v.z );
	}

	inline Vector operator * ( const Vector &v ) const
	{
		return Vector ( x * v.x, y * v.y, z * v.z );
	}

	inline Vector operator / ( const Vector &v ) const
	{
		return Vector ( x / v.x, y / v.y, z / v.z );
	}

	// Methods
	inline float Length ( ) const
	{
		return sqrtf ( x * x + y * y + z * z );
	}

	inline float LengthSqr ( ) const
	{
		return ( x * x + y * y + z * z );
	}

	inline float LengthXY ( ) const
	{
		return sqrtf ( x * x + y * y );
	}

	inline float LengthXZ ( ) const
	{
		return sqrtf ( x * x + z * z );
	}

	inline bool IsZero ( ) const
	{
		return ( x > -0.01f && x < 0.01f &&	y > -0.01f && y < 0.01f && z > -0.01f && z < 0.01f );
	}

	inline float DistTo ( const Vector &v ) const
	{
		return ( *this - v ).Length ( );
	}

	inline float DistToSqr ( const Vector &v ) const
	{
		return ( *this - v ).LengthSqr ( );
	}

	inline float Dot ( const Vector &v ) const
	{
		return ( x * v.x + y * v.y + z * v.z );
	}

	inline Vector Cross ( const Vector &v ) const
	{
		return Vector ( y * v.z - z * v.y, z * v.x - x * v.z, x * v.y - y * v.x );
	}

	inline operator float *( )
	{
		return &x;
	}

	inline operator const float *( ) const
	{
		return &x;
	}

	inline Vector2D Make2D ( ) const
	{
		Vector2D v;

		v.x = x;
		v.y = y;

		return v;
	}

	inline Vector Normalize ( ) const
	{
		float flLen = Length ( );

		if ( !flLen )
			return Vector ( 0.0f, 0.0f, 1.0f );

		flLen = 1.0f / flLen;

		return Vector ( x * flLen, y * flLen, z * flLen );
	}

	// Members
	vec_t x, y, z;
};

inline Vector operator * ( float f, const Vector &v )
{
	return v * f;
}

inline void ClampAngles ( Vector &Angles )
{
	if ( Angles.y < -180.0f )
		Angles.y += 360.0f;

	if ( Angles.y > 180.0f )
		Angles.y -= 360.0f;

	if ( Angles.x < -89.0f )
		Angles.x = -89.0f;

	if ( Angles.x > 89.0f )
		Angles.x = 89.0f;
}

inline float DotProduct ( const Vector& a, const Vector& b ) 
{
	return( a.x * b.x + a.y * b.y + a.z * b.z ); 
}

#define vec3_t Vector

#define VectorAdd(a,b,c) {(c)[0]=(a)[0]+(b)[0];(c)[1]=(a)[1]+(b)[1];(c)[2]=(a)[2]+(b)[2];}
#define VectorCopy(a,b) {(b)[0]=(a)[0];(b)[1]=(a)[1];(b)[2]=(a)[2];}
#define VectorClear(a) { a[0]=0.0;a[1]=0.0;a[2]=0.0;}

#endif

```

`ValveSDK/weaponinfo.h`:

```h
/***
*
*	Copyright (c) 1996-2002, Valve LLC. All rights reserved.
*	
*	This product contains software technology licensed from Id 
*	Software, Inc. ("Id Technology").  Id Technology (c) 1996 Id Software, Inc. 
*	All Rights Reserved.
*
*   Use, distribution, and modification of this source code and/or resulting
*   object code is restricted to non-commercial enhancements to products from
*   Valve LLC.  All other use, distribution, or modification is prohibited
*   without written permission from Valve LLC.
*
****/
#if !defined ( WEAPONINFOH )
#define WEAPONINFOH
#ifdef _WIN32
#pragma once
#endif

// Info about weapons player might have in his/her possession
typedef struct weapon_data_s
{
	int			m_iId;
	int			m_iClip;

	float		m_flNextPrimaryAttack;
	float		m_flNextSecondaryAttack;
	float		m_flTimeWeaponIdle;

	int			m_fInReload;
	int			m_fInSpecialReload;
	float		m_flNextReload;
	float		m_flPumpTime;
	float		m_fReloadTime;

	float		m_fAimedDamage;
	float		m_fNextAimBonus;
	int			m_fInZoom;
	int			m_iWeaponState;

	int			iuser1;
	int			iuser2;
	int			iuser3;
	int			iuser4;
	float		fuser1;
	float		fuser2;
	float		fuser3;
	float		fuser4;
} weapon_data_t;

#endif

```

`ValveSDK/wrect.h`:

```h
#if !defined( WRECTH )
#define WRECTH

typedef struct rect_s
{
	int				left, right, top, bottom;
} wrect_t;

#endif
```

`Variables.h`:

```h
#pragma once

#include "Main.h"

struct TWeaponsStruct
{
	bool Trigger;
	bool OnlyHead;
	bool ProSpread;
};

struct TriggerStruct
{
	bool Enable, FriendlyFire;
	bool VisibleCheck;
	bool SnipersOnlyInZoom;
	BYTE Key, SwitchKey;
};

struct GroundStrafeStruct
{
	char* ScrollDistanceString;
	char* ScrollCountString;
	float ScrollDistance[2];
	float SlowdownScale;
	float SlowdownAngle;
	int ScrollDirection;
	int ScrollCount[2];
	int StandUpFallVelocity;
	bool ScrollEmulation;
	bool FallRun, Helper;
	BYTE Key, StandUpKey;
};

struct ChamsStruct
{
	char* ColorTVisString;
	char* ColorTHideString;
	char* ColorCTVisString;
	char* ColorCTHideString;
	char* WeaponColorVisString;
	char* WeaponColorHideString;
	char* HandsColorString;
	int Player, HandsRenderType;
	int WeaponRenderType;
	int PlayerRenderType;
	int WeaponColorVis[3];
	int WeaponColorHide[3];
	int ColorTVis[3], ColorTHide[3];
	int ColorCTVis[3], ColorCTHide[3];
	int HandsColor[3];
	bool Enable, Weapon, Hands;
	bool WeaponVisibleOnly;
	bool PlayerVisibleOnly;
};

struct FastZoomStruct
{
	int Delay;
	bool Enable;
	bool QuickSwitch;
};

struct AutoPistolStruct
{
	int Delay;
	bool Enable;
};

struct RecoilStruct
{
	float X, Y;
	float Smooth;
	int BulletStart;
	bool Enable;
};

struct OtherStruct
{
	char* FontColorString;
	int FontColor[4];
	bool DrawAimSpot, DrawAimFOV;
	bool DrawPunch, RemoveSmoke;
	bool DrawSpread, StatusAimBot;
	bool StatusTriggerBot, FontOutline;
};

struct WeaponsStruct
{
	char* BulletControlString;
	float FOV, Smooth;
	float Recoil, RecoilFOV;
	float RecoilSmooth;
	float Prediction;
	float RecoilPrediction;
	int BulletControl[2];
	int HitBox, Delay;
	int DelayType;
	bool Aim, HitBoxNearest;
};

struct AimStruct
{
	int KillDelay;
	bool Enable, Silent;
	bool FriendlyFire;
	bool VisibleCheck;
	bool FlashCheck;
	bool FOVDistance;
};

struct CrosshairStruct
{
	char* ColorString;
	float DynamicScale;
	int Gap, Thickness;
	int Size, Color[4];
	bool Enable, Dot;
	bool Outline, Dynamic;
	bool Snipers;
};

struct BunnyHopStruct
{
	char* ScrollDistanceString;
	float ScrollDistance[2];
	int StandUpFallVelocity;
	int HelperIdealPercent;
	int ScrollDirection;
	bool NoSlowdown, OnLadder;
	bool ScrollEmulation;
	bool ScrollRandFails;
	bool Helper, StandUpAuto;
	bool HelperNoSlowdown;
	BYTE Key, StandUpKey;
};

struct SpeedStruct
{
	float Player;
	float Boost;
	float Slowmo;
	float HelperGround;
	float HelperLadder;
	float HelperFly;
	int Engine;
	bool Helper;
	BYTE BoostKey;
	BYTE SlowmoKey;
};

struct NoFlashStruct
{
	char* FadeColorString;
	int FadeLimit, DrawFlashed;
	int FadeColor[3];
	bool Enable, FontOutline;
	bool FadeColorEnable;
	bool FadeColorRandom;
};

struct ESPStruct
{
	char *ColorTVisString, *ColorTHideString;
	char *ColorCTVisString, *ColorCTHideString;
	char *FontColorString;
	int Player, PlayerBox, PlayerBoxFilled;
	int PlayerDistance, C4TimerValue;
	int SoundDistance, SoundFadeTime;
	int ColorTVis[3], ColorTHide[3];
	int ColorCTVis[3], ColorCTHide[3];
	int FontColor[4], C4Timer;
	bool Enable, PlayerVisibleOnly;
	bool PlayerName, PlayerWeapon;
	bool PlayerBarrel, WorldC4;
	bool WorldItems, WorldNades;
	bool Sound, FontOutline;
};

struct ScreenInfoStruct
{
	char* FontColorString;
	int FPS, Time;
	int Copyright;
	int KreedzInfo;
	int ShowKeys;
	int FontColor[4];
	bool Enable;
	bool FontOutline;
};

struct MenuStruct
{
	char* BoxColorString;
	char* BoxOutlineColorString;
	char* BoxSelectColorString;
	char* TextColorString;
	int X, Y;
	int BoxWidth;
	int BoxHeight;
	int BoxColor[4];
	int BoxOutlineColor[4];
	int BoxSelectColor[4];
	int TextColor[3];
	BYTE Key;
};

struct FunctionsStruct
{
	bool Menu, ScreenInfo, ESP;
	bool Chams, NoFlash, Crosshair;
	bool Speed, BunnyHop;
	bool Weapons, Recoil;
	bool AutoPistol, FastZoom;
	bool GroundStrafe, TriggerWeapons;
};

struct MainStruct
{
	int Language;
	int PlayerValidCheck;
	int FontOutlineStyle;
	int AntiScreenTimer;
	bool AntiScreenEnable;
	BYTE ReloadKey, SaveKey;
	BYTE PanicAimBotKey;
	BYTE PanicVisualsKey;
	BYTE PanicMiscKey;
	BYTE PanicKey;
	BYTE AntiScreenKey;
};

class Vars
{
public:
	TWeaponsStruct TriggerWeapons[31];
	TriggerStruct Trigger;
	GroundStrafeStruct GroundStrafe;
	ChamsStruct Chams;
	FastZoomStruct FastZoom;
	AutoPistolStruct AutoPistol;
	RecoilStruct Recoil;
	OtherStruct Other;
	WeaponsStruct Weapons[31];
	AimStruct Aim;
	CrosshairStruct Crosshair;
	BunnyHopStruct BunnyHop;
	SpeedStruct Speed;
	NoFlashStruct NoFlash;
	ESPStruct ESP;
	ScreenInfoStruct ScreenInfo;
	MenuStruct Menu;
	FunctionsStruct Functions;
	MainStruct Main;
};

extern Vars g_Vars;
```

`WeaponList.cpp`:

```cpp
#include "WeaponList.h"

namespace Client
{
	int WeaponList::OldWeaponBits;
	int WeaponList::WeaponListIndex;

	weapon_list_s* WeaponList::WeaponListData;

	void WeaponList::SetWeaponData ( weapon_list_s* weapon )
	{
		switch ( weapon->ID )
		{
		case WEAPONLIST_P228:
			weapon->ClipCap = CLIPCAP_P228;
			weapon->penetrate = WALL_PEN0;
			weapon->distance = 4096.0f;
			weapon->wallpierce1 = 0.8f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 32;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_P228;

			break;

		case WEAPONLIST_SCOUT:
			weapon->ClipCap = CLIPCAP_SCOUT;
			weapon->penetrate = WALL_PEN2;
			weapon->distance = 8192.0f;
			weapon->wallpierce1 = 0.98f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 75;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_SCOUT;

			break;

		case WEAPONLIST_HEGRENADE:
			weapon->ClipCap = 0;
			weapon->penetrate = WALL_PEN0;
			weapon->distance = 0.0f;
			weapon->wallpierce1 = 0.0f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 0;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_NONE;

			break;

		case WEAPONLIST_XM1014:
			weapon->ClipCap = CLIPCAP_XM1014;
			weapon->penetrate = WALL_PEN0;
			weapon->distance = 0.0f;
			weapon->wallpierce1 = 0.0f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 0;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_XM1014;

			break;

		case WEAPONLIST_C4:
			weapon->ClipCap = 0;
			weapon->penetrate = WALL_PEN0;
			weapon->distance = 0.0f;
			weapon->wallpierce1 = 0.0f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 0;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_NONE;

			break;

		case WEAPONLIST_MAC10:
			weapon->ClipCap = CLIPCAP_MAC10;
			weapon->penetrate = WALL_PEN0;
			weapon->distance = 8192.0f;
			weapon->wallpierce1 = 0.82f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 29;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_MAC10;

			break;

		case WEAPONLIST_AUG:
			weapon->ClipCap = CLIPCAP_AUG;
			weapon->penetrate = WALL_PEN1;
			weapon->distance = 8192.0f;
			weapon->wallpierce1 = 0.96f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 32;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_AUG;

			break;

		case WEAPONLIST_SMOKEGRENADE:
			weapon->ClipCap = 0;
			weapon->penetrate = WALL_PEN0;
			weapon->distance = 0.0f;
			weapon->wallpierce1 = 0.0f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 0;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_NONE;

			break;

		case WEAPONLIST_ELITE:
			weapon->ClipCap = CLIPCAP_ELITE;
			weapon->penetrate = WALL_PEN0;
			weapon->distance = 8192.0f;
			weapon->wallpierce1 = 0.75f;
			weapon->wallpierce2 = 0.75f;
			weapon->damage1 = 20;
			weapon->damage2 = 27;
			weapon->bullettype = BULLET_ELITE;

			break;

		case WEAPONLIST_FIVESEVEN:
			weapon->ClipCap = CLIPCAP_FIVESEVEN;
			weapon->penetrate = WALL_PEN0;
			weapon->distance = 4096.0f;
			weapon->wallpierce1 = 0.885f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 14;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_FIVESEVEN;

			break;

		case WEAPONLIST_UMP45:
			weapon->ClipCap = CLIPCAP_UMP45;
			weapon->penetrate = WALL_PEN0;
			weapon->distance = 8192.0f;
			weapon->wallpierce1 = 0.82f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 30;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_UMP45;

			break;

		case WEAPONLIST_SG550:
			weapon->ClipCap = CLIPCAP_SG550;
			weapon->penetrate = WALL_PEN1;
			weapon->distance = 8192.0f;
			weapon->wallpierce1 = 0.98f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 40;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_SG550;

			break;

		case WEAPONLIST_GALIL:
			weapon->ClipCap = CLIPCAP_GALIL;
			weapon->penetrate = WALL_PEN1;
			weapon->distance = 8192.0f;
			weapon->wallpierce1 = 0.96f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 33;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_GALIL;

			break;

		case WEAPONLIST_FAMAS:
			weapon->ClipCap = CLIPCAP_FAMAS;
			weapon->penetrate = WALL_PEN1;
			weapon->distance = 8192.0f;
			weapon->wallpierce1 = 0.96f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 33;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_FAMAS;

			break;

		case WEAPONLIST_USP:
			weapon->ClipCap = CLIPCAP_USP;
			weapon->penetrate = WALL_PEN0;
			weapon->distance = 4096.0f;
			weapon->wallpierce1 = 0.79f;
			weapon->wallpierce2 = 0.79f;
			weapon->damage1 = 34;
			weapon->damage2 = 30;
			weapon->bullettype = BULLET_USP;

			break;

		case WEAPONLIST_GLOCK18:
			weapon->ClipCap = CLIPCAP_GLOCK18;
			weapon->penetrate = WALL_PEN0;
			weapon->distance = 8192.0f;
			weapon->wallpierce1 = 0.75f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 20;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_GLOCK18;

			break;

		case WEAPONLIST_AWP:
			weapon->ClipCap = CLIPCAP_AWP;
			weapon->penetrate = WALL_PEN2;
			weapon->distance = 8192.0f;
			weapon->wallpierce1 = 0.99f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 115;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_AWP;

			break;

		case WEAPONLIST_MP5:
			weapon->ClipCap = CLIPCAP_MP5;
			weapon->penetrate = WALL_PEN0;
			weapon->distance = 8192.0f;
			weapon->wallpierce1 = 0.84f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 26;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_MP5;

			break;

		case WEAPONLIST_M249:
			weapon->ClipCap = CLIPCAP_M249;
			weapon->penetrate = WALL_PEN1;
			weapon->distance = 8192.0f;
			weapon->wallpierce1 = 0.97f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 32;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_M249;

			break;

		case WEAPONLIST_M3:
			weapon->ClipCap = CLIPCAP_M3;
			weapon->penetrate = WALL_PEN0;
			weapon->distance = 0.0f;
			weapon->wallpierce1 = 0.0f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 0;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_M3;

			break;

		case WEAPONLIST_M4A1:
			weapon->ClipCap = CLIPCAP_M4A1;
			weapon->penetrate = WALL_PEN1;
			weapon->distance = 8192.0f;
			weapon->wallpierce1 = 0.97f;
			weapon->wallpierce2 = 0.95f;
			weapon->damage1 = 32;
			weapon->damage2 = 33;
			weapon->bullettype = BULLET_M4A1;

			break;

		case WEAPONLIST_TMP:
			weapon->ClipCap = CLIPCAP_TMP;
			weapon->penetrate = WALL_PEN0;
			weapon->distance = 8192.0f;
			weapon->wallpierce1 = 0.85f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 20;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_TMP;

			break;

		case WEAPONLIST_G3SG1:
			weapon->ClipCap = CLIPCAP_G3SG1;
			weapon->penetrate = WALL_PEN1;
			weapon->distance = 8192.0f;
			weapon->wallpierce1 = 0.98f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 60;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_G3SG1;

			break;

		case WEAPONLIST_FLASHBANG:
			weapon->ClipCap = 0;
			weapon->penetrate = WALL_PEN0;
			weapon->distance = 0.0f;
			weapon->wallpierce1 = 0.0f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 0;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_NONE;

			break;

		case WEAPONLIST_DEAGLE:
			weapon->ClipCap = CLIPCAP_DEAGLE;
			weapon->penetrate = WALL_PEN1;
			weapon->distance = 4096.0f;
			weapon->wallpierce1 = 0.81f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 54;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_DEAGLE;

			break;

		case WEAPONLIST_SG552:
			weapon->ClipCap = CLIPCAP_SG552;
			weapon->penetrate = WALL_PEN1;
			weapon->distance = 8192.0f;
			weapon->wallpierce1 = 0.955f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 33;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_SG552;

			break;

		case WEAPONLIST_AK47:
			weapon->ClipCap = CLIPCAP_AK47;
			weapon->penetrate = WALL_PEN1;
			weapon->distance = 8192.0f;
			weapon->wallpierce1 = 0.98f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 36;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_AK47;

			break;

		case WEAPONLIST_KNIFE:
			weapon->ClipCap = 0;
			weapon->penetrate = WALL_PEN0;
			weapon->distance = 0.0f;
			weapon->wallpierce1 = 0.0f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 0;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_NONE;

			break;

		case WEAPONLIST_P90:
			weapon->ClipCap = CLIPCAP_P90;
			weapon->penetrate = WALL_PEN0;
			weapon->distance = 8192.0f;
			weapon->wallpierce1 = 0.885f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 21;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_P90;

			break;

		default:
			weapon->ClipCap = 0;
			weapon->penetrate = WALL_PEN0;
			weapon->distance = 0.0f;
			weapon->wallpierce1 = 0.0f;
			weapon->wallpierce2 = 0.0f;
			weapon->damage1 = 0;
			weapon->damage2 = 0;
			weapon->bullettype = BULLET_NONE;

			break;
		}
	}

	weapon_list_s* WeaponList::GetCurWeapon ( )
	{
		for ( int i = 0; i < WeaponListIndex; ++i )
		{
			if ( WeaponListData[i].Active && WeaponListData[i].CurWeapon )
				return &WeaponListData[i];
		}

		return 0;
	}

	weapon_list_s* WeaponList::GetSecWeapon ( )
	{
		for ( int i = 0; i < WeaponListIndex; ++i )
		{
			if ( WeaponListData[i].Active && WeaponListData[i].Slot == 1 )
				return &WeaponListData[i];
		}

		return 0;
	}

	bool WeaponList::IsReloading ( )
	{
		weapon_list_s* TmpWeapon = GetCurWeapon ( );

		if ( TmpWeapon && TmpWeapon->weapondata.m_fInReload )
			return true;

		return false;
	}

	bool WeaponList::IsCurWeaponSec ( )
	{
		weapon_list_s* TmpWeapon = GetSecWeapon ( );

		if ( TmpWeapon && TmpWeapon->CurWeapon )
			return true;

		return false;
	}

	bool WeaponList::CanCurWeaponAttack ( )
	{
		weapon_list_s* TmpWeapon = GetCurWeapon ( );

		if ( TmpWeapon && TmpWeapon->weapondata.m_flNextPrimaryAttack <= 0.0f )
			return true;

		return false;
	}

	bool WeaponList::IsCurWeaponInBurst ( )
	{
		weapon_list_s* TmpWeapon = GetCurWeapon ( );

		if ( TmpWeapon )
		{
			if ( TmpWeapon->ID == WEAPONLIST_GLOCK18 && TmpWeapon->weapondata.m_iWeaponState & GLOCK18_BURST )
				return true;
		}

		return false;
	}

	bool WeaponList::IsCurWeaponSilenced ( )
	{
		weapon_list_s* TmpWeapon = GetCurWeapon ( );

		if ( TmpWeapon )
		{
			if ( TmpWeapon->ID == WEAPONLIST_M4A1 && TmpWeapon->weapondata.m_iWeaponState & M4A1_SILENCER )
				return true;

			if ( TmpWeapon->ID == WEAPONLIST_USP && TmpWeapon->weapondata.m_iWeaponState & USP_SILENCER )
				return true;
		}

		return false;
	}

	int WeaponList::GetCurWeaponId ( )
	{
		weapon_list_s* TmpWeapon = GetCurWeapon ( );

		if ( TmpWeapon )
			return TmpWeapon->ID;

		return -1;
	}

	int WeaponList::GetWeaponIndexByID ( int WeaponID )
	{
		for ( int i = 0; i < WeaponListIndex; ++i )
		{
			if ( WeaponListData[i].ID == WeaponID )
				return i;
		}

		return -1;
	}

	void WeaponList::WeaponListCurWeapon ( int CurWeapon, int WeaponID, int Ammo )
	{
		int Index = GetWeaponIndexByID ( WeaponID );

		if ( Index != -1 )
			WeaponListData[Index].CAmmo = Ammo;
	}

	void WeaponList::WeaponListAmmoX ( int ID, int Count )
	{
		for ( int i = 0; i < WeaponListIndex; ++i )
		{
			if ( WeaponListData[i].AmmoType == ID )
			{
				WeaponListData[i].XAmmo = Count;
			}
		}
	}

	void WeaponList::WeaponListUpdate ( int WeaponBits )
	{
		if ( WeaponBits != OldWeaponBits )
		{
			OldWeaponBits = WeaponBits;

			for ( int i = 0; i < WeaponListIndex; ++i )
			{
				if ( WeaponBits & ( 1 << WeaponListData[i].ID ) )
				{
					WeaponListData[i].Active = true;
				}
				else
				{
					WeaponListData[i].Active = false;
					WeaponListData[i].CAmmo = 0;
				}
			}
		}
	}

	void WeaponList::WeaponListAdd ( char* weaponname, int ammo1type, int max1, int ammo2type, int max2, int slot, int slotpos, int id, int flags )
	{
		if ( WeaponListIndex < MAX_WEAPON_LIST )
		{
			int len = lstrlenA ( weaponname );

			if ( len > MAX_WEAPON_NAME )
				return;

			lstrcpynA ( WeaponListData[WeaponListIndex].command, weaponname, len + 1 );

			char *NOSPRD_WPN = "weapon_";
			char *NOSPRD_MP5 = "'mp5navy";

			if ( len > 7 && !Utils::native_memcpy2 ( weaponname, NOSPRD_WPN, 7 ) )
			{
				weaponname = weaponname + 7;

				WeaponListData[WeaponListIndex].len = len - 7;
			}
			else
				WeaponListData[WeaponListIndex].len = len;

			if ( WeaponListData[WeaponListIndex].len == 7 && !Utils::native_memcpy2 ( weaponname, NOSPRD_MP5, 7 ) )
				WeaponListData[WeaponListIndex].len = 3;

			memcpy ( WeaponListData[WeaponListIndex].name, weaponname, WeaponListData[WeaponListIndex].len );

			WeaponListData[WeaponListIndex].name[WeaponListData[WeaponListIndex].len] = 0;

			WeaponListData[WeaponListIndex].AmmoType = ammo1type;

			if ( max1 == 255 )
				WeaponListData[WeaponListIndex].Max1 = -1;
			else
				WeaponListData[WeaponListIndex].Max1 = max1;

			WeaponListData[WeaponListIndex].Ammo2Type = ammo2type;

			if ( max2 == 255 )
				WeaponListData[WeaponListIndex].Max2 = -1;
			else
				WeaponListData[WeaponListIndex].Max2 = max2;

			WeaponListData[WeaponListIndex].Slot = slot;
			WeaponListData[WeaponListIndex].SlotPos = slotpos;

			WeaponListData[WeaponListIndex].ID = id;
			WeaponListData[WeaponListIndex].Flags = flags;

			WeaponListData[WeaponListIndex].CAmmo = 0;
			WeaponListData[WeaponListIndex].XAmmo = 0;

			WeaponListData[WeaponListIndex].Active = false;
			WeaponListData[WeaponListIndex].CurWeapon = false;

			SetWeaponData ( &WeaponListData[WeaponListIndex] );

			Utils::native_memset ( &WeaponListData[WeaponListIndex].weapondata, 0, sizeof ( weapon_data_t ) );

			++WeaponListIndex;
		}
	}

	void WeaponList::WeaponListClear ( )
	{
		Utils::native_memset ( WeaponListData, sizeof ( weapon_list_s ) * MAX_WEAPON_LIST, 0 );

		WeaponListIndex = 0;
	}
}
```

`WeaponList.h`:

```h
#pragma once

#include "Main.h"

namespace Client
{
	struct weapon_list_s
	{
		char name[MAX_WEAPON_NAME];
		int len;
		char command[MAX_WEAPON_NAME];
		int AmmoType;
		int Ammo2Type;
		int Max1;
		int Max2;
		int Slot;
		int SlotPos;
		int ID;
		int Flags;
		int ClipCap;
		int CAmmo;
		int XAmmo;
		bool Active;
		bool CurWeapon;
		int penetrate;
		weapon_data_t weapondata;
		float distance;
		int bullettype;
		float wallpierce1;
		float wallpierce2;
		int damage1;
		int damage2;
	};

	class WeaponList
	{
	public:
		static int OldWeaponBits;
		static int WeaponListIndex;

		static weapon_list_s* WeaponListData;

		static void SetWeaponData ( weapon_list_s* weapon );

		static weapon_list_s* GetCurWeapon ( );
		static weapon_list_s* GetSecWeapon ( );

		static bool IsReloading ( );
		static bool IsCurWeaponSec ( );
		static bool CanCurWeaponAttack ( );
		static bool IsCurWeaponInBurst ( );
		static bool IsCurWeaponSilenced ( );

		static int GetCurWeaponId ( );
		static int GetWeaponIndexByID ( int WeaponID );

		static void WeaponListCurWeapon ( int CurWeapon, int WeaponID, int Ammo );
		static void WeaponListAmmoX ( int ID, int Count );
		static void WeaponListUpdate ( int WeaponBits );

		static void WeaponListAdd ( char* weaponname, int ammo1type, int max1, int ammo2type, int max2, int slot, int slotpos, int id, int flags );
		static void WeaponListClear ( );
	};
}
```

`Weapons.cpp`:

```cpp
#include "Weapons.h"

namespace Client
{
	namespace Functions
	{
		namespace AimBot
		{
			PlayerStruct Weapons::Player[33];

			int Weapons::TargetID;
			bool Weapons::AimActive;

			bool Weapons::FriendlyFire ( const int &Index )
			{
				return g_Vars.Aim.FriendlyFire || g_Info->GetPlayerTeamByIndex ( Index ) != g_Info->GetPlayerTeam ( );
			}

			bool Weapons::VisibleCheck ( const int &Index )
			{
				return g_Vars.Aim.VisibleCheck ? g_Info->GetVisibilityEntityByIndex ( Index ) : true;
			}

			Vector Weapons::GetPrediction ( cl_entity_s *Entity )
			{
				Vector vVelocity = Entity->curstate.origin - Entity->prevstate.origin;

				float flFrameTime = Entity->curstate.animtime - Entity->prevstate.animtime;

				if ( !flFrameTime )
				{
					flFrameTime = g_Info->GetFrameTime ( );
				}

				return vVelocity * flFrameTime * ( g_Info->GetShotsFired ( ) >= g_Vars.Weapons[g_Info->GetWeaponID ( )].BulletControl[0] ?
					g_Vars.Weapons[g_Info->GetWeaponID ( )].RecoilPrediction : g_Vars.Weapons[g_Info->GetWeaponID ( )].Prediction ) * 100.0f;
			}

			void Weapons::UpdateAimHitBox ( const int &Index, cl_entity_s *Entity )
			{
				Vector vAngles ( 0.0f, Entity->angles[1], 0.0f );
				Vector vForward, vRight, vUp;

				SDK::Interfaces::g_pEngine->pfnAngleVectors ( vAngles, vForward, vRight, vUp );

				if ( g_Vars.Weapons[g_Info->GetWeaponID ( )].HitBoxNearest )
				{
					float flMaxScreenDistance = FLT_MAX;

					Vector2D Screen = Utils::GetScreen ( );

					Screen[1] = g_Info->GetShotsFired ( ) >= g_Vars.Weapons[g_Info->GetWeaponID ( )].BulletControl[0] ?
						Screen[1] + Utils::GetPunchScreen ( )[0] : Screen[1] - Utils::GetPunchScreen ( )[0];

					Vector2D Aim;

					BYTE HitBoxCheck[] = { 7, 8, 9, 11 };

					for ( int i = 0; i < sizeof ( HitBoxCheck ); ++i )
					{
						Vector HitBox = g_Info->GetHitBoxByIndex ( Index, ( int )HitBoxCheck[i] ) + GetPrediction ( Entity ) + vForward + vRight + vUp;

						if ( Utils::CalcScreen ( HitBox, Aim ) )
						{
							float flScreenDistance = Utils::CalcDistanceScreen ( Screen, Aim );

							if ( flScreenDistance < flMaxScreenDistance )
							{
								flMaxScreenDistance = flScreenDistance;

								Player[Index].vAimHitBox = HitBox;

								if ( HitBoxCheck[i] == 11 )
								{
									Player[Index].vAimHitBox[1] += 0.8f;
									Player[Index].vAimHitBox[2] -= 0.8f;
								}
							}
						}
					}
				}
				else
				{
					Player[Index].vAimHitBox = g_Info->GetHitBoxByIndex ( Index, g_Vars.Weapons[g_Info->GetWeaponID ( )].HitBox ) + 
						GetPrediction ( Entity ) + vForward + vRight + vUp;

					if ( g_Vars.Weapons[g_Info->GetWeaponID ( )].HitBox == 11 )
					{
						Player[Index].vAimHitBox[1] += 0.8f;
						Player[Index].vAimHitBox[2] -= 0.8f;
					}
				}
			}

			void Weapons::UpdateAimInfo ( const int &Index )
			{
				cl_entity_s *Entity = SDK::Interfaces::g_pEngine->GetEntityByIndex ( Index );

				UpdateAimHitBox ( Index, Entity );

				Vector2D vAim;

				if ( Utils::CalcScreen ( Player[Index].vAimHitBox, vAim ) )
				{
					float FOV = 0.0f;

					Vector2D Screen = Utils::GetScreen ( );

					Screen[0] -= Utils::GetPunchScreen ( )[1];
					Screen[1] += Utils::GetPunchScreen ( )[0];

					if ( g_Vars.Aim.FOVDistance )
					{
						Vector uppt = Entity->origin - g_Info->GetVectorEyePosition ( );

						FOV = g_Info->GetShotsFired ( ) >= g_Vars.Weapons[g_Info->GetWeaponID ( )].BulletControl[0] ?
							g_Vars.Weapons[g_Info->GetWeaponID ( )].RecoilFOV : g_Vars.Weapons[g_Info->GetWeaponID ( )].FOV * 500.0f / uppt.Length ( );

						if ( g_Info->GetShotsFired ( ) < g_Vars.Weapons[g_Info->GetWeaponID ( )].BulletControl[0] )
						{
							if ( FOV > g_Vars.Weapons[g_Info->GetWeaponID ( )].FOV * 3.0f )
								FOV = g_Vars.Weapons[g_Info->GetWeaponID ( )].FOV * 3.0f;

							if ( FOV < g_Vars.Weapons[g_Info->GetWeaponID ( )].FOV / 2.0f )
								FOV = g_Vars.Weapons[g_Info->GetWeaponID ( )].FOV / 2.0f;
						}
					}
					else
					{
						FOV = g_Info->GetShotsFired ( ) >= g_Vars.Weapons[g_Info->GetWeaponID ( )].BulletControl[0] ?
							g_Vars.Weapons[g_Info->GetWeaponID ( )].RecoilFOV : g_Vars.Weapons[g_Info->GetWeaponID ( )].FOV;
					}

					FOV = FOV / g_Info->GetFOV ( ) * SDK::Interfaces::g_Screen.iWidth / 2.0f;

					Player[Index].isFOV = Utils::CheckFOV ( Screen, vAim, FOV );
				}
				else
					Player[Index].isFOV = false;
			}

			void Weapons::UpdateTargetID ( )
			{
				float flMaxScreenDistance = FLT_MAX;

				Vector2D Screen = Utils::GetScreen ( );

				Screen[0] -= Utils::GetPunchScreen ( )[1] / 2.0f;
				Screen[1] += Utils::GetPunchScreen ( )[0] / 2.0f;

				for ( int Index = 1; Index <= SDK::Interfaces::g_pEngine->GetMaxClients ( ); ++Index )
				{
					cl_entity_s* Entity = SDK::Interfaces::g_pEngine->GetEntityByIndex ( Index );

					if ( !FriendlyFire ( Index ) || !VisibleCheck ( Index ) ||
						!g_Info->GetValidationEntity ( Entity ) || g_Info->GetLocalIndex ( ) == Index )
					{
						continue;
					}

					Vector2D Aim;

					if ( Utils::CalcScreen ( Player[Index].vAimHitBox, Aim ) )
					{
						float flScreenDistance = Utils::CalcDistanceScreen ( Screen, Aim );

						if ( flScreenDistance < flMaxScreenDistance )
						{
							flMaxScreenDistance = flScreenDistance;
							TargetID = Index;
						}
					}
				}
			}

			void Weapons::UpdatePlayerInfo ( )
			{
				static DWORD64 dwKillDelay;

				if ( TargetID && !VisibleCheck ( TargetID ) )
				{
					TargetID = 0;
				}

				if ( g_Vars.Aim.KillDelay <= 0 || ( ( dwKillDelay + g_Vars.Aim.KillDelay ) <= GetTickCount64 ( ) && !AimActive ) )
				{
					dwKillDelay = 0;

					AimActive = true;
				}

				if ( TargetID && AimActive )
				{
					cl_entity_s* Entity = SDK::Interfaces::g_pEngine->GetEntityByIndex ( TargetID );

					if ( !g_Info->GetValidationEntity ( Entity ) && AimActive && g_Vars.Aim.KillDelay )
					{
						if ( !dwKillDelay )
						{
							dwKillDelay = GetTickCount64 ( );

							AimActive = false;
						}
					}

					UpdateTargetID ( );
				}
				else
					UpdateTargetID ( );
			}

			void Weapons::CL_CreateMove ( usercmd_s *cmd )
			{
				Vector vAimAngles, vSmoothAngles;

				static DWORD64 dwDelay;

				Utils::VectorAngles ( Player[TargetID].vAimHitBox - g_Info->GetVectorEyePosition ( ), vAimAngles );

				cl_entity_s* Entity = SDK::Interfaces::g_pEngine->GetEntityByIndex ( TargetID );

				if ( g_Vars.Aim.FlashCheck && Visuals::NoFlash::GetFlashedPercentage ( ) > 80 )
				{
					return;
				}

				if ( g_Info->GetShotsFired ( ) >= g_Vars.Weapons[g_Info->GetWeaponID ( )].BulletControl[1] ||
					!g_Info->GetWeaponClip ( ) || g_Info->GetInReload ( ) )
				{
					return;
				}

				if ( !( cmd->buttons & IN_ATTACK ) )
				{
					dwDelay = GetTickCount64 ( );
				}

				if ( cmd->buttons & IN_ATTACK && g_Info->GetValidationEntity ( Entity ) && AimActive )
				{
					if ( !Player[TargetID].isFOV )
					{
						return;
					}

					if ( g_Info->GetShotsFired ( ) >= g_Vars.Weapons[g_Info->GetWeaponID ( )].BulletControl[0] )
					{
						Vector vPunchAngles = g_Info->GetVectorPunchAngles ( ) * g_Vars.Weapons[g_Info->GetWeaponID ( )].Recoil;

						vPunchAngles[2] = 0.0f;
						vAimAngles -= vPunchAngles;

						ClampAngles ( vAimAngles );
					}

					if ( g_Vars.Aim.Silent )
					{
						ClampAngles ( vAimAngles );

						Utils::MakeAngle ( vAimAngles, cmd );
					}
					else
					{
						if ( g_Vars.Weapons[g_Info->GetWeaponID ( )].DelayType <= 1 )
						{
							if ( GetTickCount64 ( ) - dwDelay <= g_Vars.Weapons[g_Info->GetWeaponID ( )].Delay )
							{
								cmd->buttons &= ~IN_ATTACK;
							}
						}
						else if ( g_Vars.Weapons[g_Info->GetWeaponID ( )].DelayType == 2 )
						{
							if ( ( GetTickCount64 ( ) - dwDelay <= g_Vars.Weapons[g_Info->GetWeaponID ( )].Delay ) &&
								!TriggerBot::Trigger::GetIsFOVByIndex ( TargetID ) )
							{
								cmd->buttons &= ~IN_ATTACK;
							}
						}
						else if ( g_Vars.Weapons[g_Info->GetWeaponID ( )].DelayType >= 3 )
						{
							if ( !TriggerBot::Trigger::GetIsFOVByIndex ( TargetID ) )
							{
								cmd->buttons &= ~IN_ATTACK;
							}
						}

						if ( g_Info->GetShotsFired ( ) >= g_Vars.Weapons[g_Info->GetWeaponID ( )].BulletControl[0] )
						{
							if ( g_Vars.Weapons[g_Info->GetWeaponID ( )].RecoilSmooth >= 1.0f )
							{
								Utils::SmoothAimAngles ( cmd->viewangles, vAimAngles, vSmoothAngles, g_Vars.Weapons[g_Info->GetWeaponID ( )].RecoilSmooth );
							}
							else
							{
								vSmoothAngles = vAimAngles;
							}
						}
						else
						{
							if ( g_Vars.Weapons[g_Info->GetWeaponID ( )].Smooth >= 1.0f )
							{
								Utils::SmoothAimAngles ( cmd->viewangles, vAimAngles, vSmoothAngles, g_Vars.Weapons[g_Info->GetWeaponID ( )].Smooth );
							}
							else
							{
								vSmoothAngles = vAimAngles;
							}
						}

						ClampAngles ( vSmoothAngles );

						cmd->viewangles = vSmoothAngles;

						SDK::Interfaces::g_pEngine->SetViewAngles ( cmd->viewangles );
					}
				}
				else
				{
					Player[TargetID].isFOV = false;

					TargetID = 0;
				}
			}
		}
	}
}
```

`Weapons.h`:

```h
#pragma once

#include "Main.h"

namespace Client
{
	namespace Functions
	{
		namespace AimBot
		{
			struct PlayerStruct
			{
				Vector vAimHitBox;
				bool isFOV;
			};

			class Weapons
			{
			public:
				inline static int GetTargetID ( )
				{
					return TargetID;
				}

				inline static Vector GetAimHitBoxByIndex ( const int &Index )
				{
					return Player[Index].vAimHitBox;
				}

				inline static bool GetIsFOVByIndex ( const int &Index )
				{
					return Player[Index].isFOV;
				}

				static bool FriendlyFire ( const int &Index );
				static bool VisibleCheck ( const int &Index );

				static void UpdateAimInfo ( const int &Index );
				static void UpdatePlayerInfo ( );

				static void CL_CreateMove ( usercmd_s *cmd );

			private:
				static PlayerStruct Player[33];

				static int TargetID;			
				static bool AimActive;

				static Vector GetPrediction ( cl_entity_s *Entity );

				static void UpdateAimHitBox ( const int &Index, cl_entity_s *Entity );
				static void UpdateTargetID ( );
			};
		}
	}
}
```

`_config.yml`:

```yml
theme: jekyll-theme-cayman
```