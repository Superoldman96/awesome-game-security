Project Path: arc_gmh5225_csgo-external-esp_cmllwsi5

Source Tree:

```txt
arc_gmh5225_csgo-external-esp_cmllwsi5
├── LICENSE
├── README.md
├── csgo_sdk
│   ├── csgo_sdk.cpp
│   ├── csgo_sdk.h
│   └── entity.cpp
├── dx_overlay
│   ├── dx_overlay.cpp
│   └── dx_overlay.h
├── dx_renderer
│   ├── dx_renderer.cpp
│   └── dx_renderer.h
├── esp
│   ├── esp.cpp
│   └── esp.h
├── main.cpp
└── memory_manager
    ├── memory_manager.cpp
    └── memory_manager.h

```

`LICENSE`:

```
MIT License

Copyright (c) 2020 Damian Wierbiel

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# External ESP for CS:GO using a DirectX9 Overlay

This is an external ESP for CS:GO written in C++.

## Preview
![](https://i.imgur.com/4Vo5dem.png)

## Getting Started

Download the source, update the offsets, configure your project and finally compile.

### Prerequisites

You will need the DirectX9 SDK and a basic understanding of gamehacking/memory to compile and update this.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details

```

`csgo_sdk/csgo_sdk.cpp`:

```cpp
#include "csgo_sdk.h"
#include <cmath>

namespace sdk {
	modules_t::modules_t( forceinline::memory_manager* memory ) {
		client_dll = memory->get_module_base( "client_panorama.dll" );
		engine_dll = memory->get_module_base( "engine.dll" );
	}

	vec3_t::vec3_t( ) {
		x = y = z = 0;
	}

	vec3_t::vec3_t( float _x, float _y, float _z ) {
		x = _x;
		y = _y;
		z = _z;
	}

	vec3_t vec3_t::operator+( const vec3_t& other ) {
		return { x + other.x, y + other.y, z + other.z };
	}

	vec3_t vec3_t::operator+=( const vec3_t& other ) {
		x += other.x;
		y += other.y;
		z += other.z;
		
		return *this;
	}

	vec3_t vec3_t::operator-( const vec3_t& other ) {
		return { x - other.x, y - other.y, z - other.z };
	}

	vec3_t vec3_t::operator-=( const vec3_t& other ) {
		x -= other.x;
		y -= other.y;
		z -= other.z;
		
		return *this;
	}

	vec3_t vec3_t::operator*( float factor ) {
		return { x * factor, y * factor, z * factor };
	}

	vec3_t vec3_t::operator*( const vec3_t& other ) {
		return { x * other.x, y * other.y, z * other.z };
	}

	vec3_t vec3_t::operator*=( float factor ) {
		x *= factor;
		y *= factor;
		z *= factor;

		return *this;
	}

	vec3_t vec3_t::operator*=( const vec3_t& other ) {
		x *= other.x;
		y *= other.y;
		z *= other.z;

		return *this;
	}

	vec3_t vec3_t::operator/( float factor ) {
		return { x / factor, y / factor, z / factor };
	}

	vec3_t vec3_t::operator/( const vec3_t& other ) {
		return { x / other.x, y / other.y, z / other.z };
	}

	vec3_t vec3_t::operator/=( float factor ) {
		x /= factor;
		y /= factor;
		z /= factor;

		return *this;
	}

	vec3_t vec3_t::operator/=( const vec3_t& other ) {
		x /= other.x;
		y /= other.y;
		z /= other.z;

		return *this;
	}

	bool vec3_t::is_zero( ) {
		return x == 0 && y == 0 && z == 0;
	}

	float vec3_t::dot( const vec3_t& other ) {
		return x * other.x + y * other.y + z * other.z;
	}

	float vec3_t::dist( const vec3_t& other ) {
		return ( *this - other ).length( );
	}

	float vec3_t::length( ) {
		return sqrt( length_sqr( ) );
	}

	float vec3_t::length_sqr( ) {
		return x * x + y * y + z * z;
	}

	bool world_to_screen( const vec3_t& screen_size, const vec3_t& pos, vec3_t& out, sdk::view_matrix_t matrix ) {
		out.x = matrix[ 0 ][ 0 ] * pos.x + matrix[ 0 ][ 1 ] * pos.y + matrix[ 0 ][ 2 ] * pos.z + matrix[ 0 ][ 3 ];
		out.y = matrix[ 1 ][ 0 ] * pos.x + matrix[ 1 ][ 1 ] * pos.y + matrix[ 1 ][ 2 ] * pos.z + matrix[ 1 ][ 3 ];

		float w = matrix[ 3 ][ 0 ] * pos.x + matrix[ 3 ][ 1 ] * pos.y + matrix[ 3 ][ 2 ] * pos.z + matrix[ 3 ][ 3 ];

		if ( w < 0.01f )
			return false;

		float inv_w = 1.f / w;
		out.x *= inv_w;
		out.y *= inv_w;

		float x = screen_size.x * .5f;
		float y = screen_size.y * .5f;

		x += 0.5f * out.x * screen_size.x + 0.5f;
		y -= 0.5f * out.y * screen_size.y + 0.5f;

		out.x = x;
		out.y = y;

		return true;
	}
}
```

`csgo_sdk/csgo_sdk.h`:

```h
#pragma once
#include <cstdint>

#include "../memory_manager/memory_manager.h"

namespace sdk {
	class modules_t {
	public:
		modules_t( ) { }
		modules_t( forceinline::memory_manager* memory );
		~modules_t( ) { }

		std::uintptr_t client_dll = 0x0;
		std::uintptr_t engine_dll = 0x0;
	};

	struct vec3_t {
		float x = 0, y = 0, z = 0;

		vec3_t( );
		vec3_t( float _x, float _y, float _z );

		vec3_t operator+( const vec3_t& other );
		vec3_t operator+=( const vec3_t& other );

		vec3_t operator-( const vec3_t& other );
		vec3_t operator-=( const vec3_t& other );

		vec3_t operator*( float factor );
		vec3_t operator*( const vec3_t& other );
		vec3_t operator*=( float factor );
		vec3_t operator*=( const vec3_t& other );

		vec3_t operator/( float factor );
		vec3_t operator/( const vec3_t& other );
		vec3_t operator/=( float factor );
		vec3_t operator/=( const vec3_t& other );

		bool is_zero( );

		float dot( const vec3_t& other );
		float dist( const vec3_t& other );
		float length( );
		float length_sqr( );
	};

	struct ent_info_t {
		std::uintptr_t entity_ptr = 0x0;
		__int32 serial_number = 0;
		ent_info_t* prev = nullptr;
		ent_info_t* next = nullptr;
	};

	class entity_t {
	public:
		entity_t( forceinline::memory_manager* memory, sdk::modules_t* modules, std::uintptr_t ptr );

		bool dormant( );

		int health( );
		int index( );
		int life_state( );
		int team( );

		vec3_t origin( );

		void get_name( std::string& out );

		bool is_alive( );

	private:
		std::uintptr_t m_ptr = 0x0;
		sdk::modules_t* m_modules = nullptr;
		forceinline::memory_manager* m_memory = nullptr;
	};

	struct view_matrix_t {
		float* operator[ ]( int index ) {
			return matrix[ index ];
		}

		float matrix[ 4 ][ 4 ];
	};

	bool world_to_screen( const vec3_t& screen_size, const vec3_t& pos, vec3_t& out, sdk::view_matrix_t matrix );
}
```

`csgo_sdk/entity.cpp`:

```cpp
#include "csgo_sdk.h"

//Macro to implement simple netvars quickly
#define ent_netvar( nv_type, nv_name, nv_offset ) nv_type entity_t::##nv_name( ) { return m_memory->read< nv_type >( m_ptr + nv_offset );  }

namespace sdk {
	entity_t::entity_t( forceinline::memory_manager* memory, sdk::modules_t* modules, std::uintptr_t ent_ptr ) {
		m_memory = memory;
		m_modules = modules;
		m_ptr = ent_ptr;
	}

	ent_netvar( bool, dormant, 0xED );

	ent_netvar( int, health, 0x100 );
	ent_netvar( int, index, 0x64 );
	ent_netvar( int, life_state, 0x25F );
	ent_netvar( int, team, 0xF4 );

	ent_netvar( vec3_t, origin, 0x138 );

	void entity_t::get_name( std::string& out ) {
		struct player_info_t {
			char __pad[ 0x10 ];
			char name[ 32 ];
		};

		std::uintptr_t client_state = m_memory->read< std::uintptr_t >( m_modules->engine_dll + 0x590D8C ); //m_dwClientState
		std::uintptr_t user_info_table = m_memory->read< std::uintptr_t >( client_state + 0x52B8 ); //m_dwClientState_PlayerInfo
		std::uintptr_t x = m_memory->read< std::uintptr_t >( m_memory->read< std::uintptr_t >( user_info_table + 0x40 ) + 0xC );
		player_info_t p = m_memory->read< player_info_t >( m_memory->read< uintptr_t >( x + 0x28 + 0x34 * ( index( ) - 1 ) ) );

		out.resize( 32 );
		memcpy( out.data( ), p.name, 32 );
	}

	bool entity_t::is_alive( ) {
		return life_state( ) == 0;
	}
}
```

`dx_overlay/dx_overlay.cpp`:

```cpp
#include "dx_overlay.h"

#include <iostream>
#include <dwmapi.h>
#pragma comment(lib, "dwmapi.lib")

namespace forceinline {
	/*
		Regarding the not_topmost argument:
		Some games/anti-cheats specifically check if a window has the WS_EX_TOPMOST and WS_VISIBLE flags, or has the game window as its parent.
		By setting not_topmost to true, we will use a trick to make our window act similar to having the WS_EX_TOPMOST style without it actually having it, 
		therefore making that window harder to detect (or easier, it depends on the anti-cheat. Before doing anything you should become familiar with the
		anti-cheat the game has to avoid being banned.
	*/
	dx_overlay::dx_overlay( std::wstring_view target_class, std::wstring_view target_window, bool not_topmost ) {
		m_not_topmost = not_topmost;

		if ( target_window.empty( ) && target_class.empty( ) )
			throw std::invalid_argument( "dx_overlay::dx_overlay: target_class and target_window empty" );

		if ( !FindWindowW( target_class.empty( ) ? NULL : target_class.data( ), target_window.empty( ) ? NULL : target_window.data( ) ) ) {
			std::string target_class_mb( target_class.begin( ), target_class.end( ) );
			std::string target_window_mb( target_window.begin( ), target_window.end( ) );

			throw std::invalid_argument( "dx_overlay::dx_overlay: target window \"" + target_window_mb + "\" with target class \"" + target_class_mb + "\" could not be found" );
		}

		create_overlay( target_class, target_window );
	}

	dx_overlay::~dx_overlay( ) {
		if ( m_overlay_wnd )
			DestroyWindow( m_overlay_wnd );

		if ( m_d3d )
			m_d3d->Release( );

		if ( m_device )
			m_device->Release( );
	}

	dx_renderer dx_overlay::create_renderer( ) {
		return dx_renderer( m_device );	//Return a renderer object
	}

	HWND dx_overlay::get_overlay_wnd( ) {
		return m_overlay_wnd;	//Return our window handle
	}

	bool dx_overlay::is_initialized( ) {
		return m_initialized;	//Is our overlay initialized properly?
	}

	void dx_overlay::create_overlay( std::wstring_view target_class, std::wstring_view target_window ) {
		WNDCLASSEX wc;
		wc.cbSize = sizeof( wc );

		//Create our window class
		wc.style = CS_HREDRAW | CS_VREDRAW;
		wc.lpfnWndProc = m_wnd_proc;
		wc.cbClsExtra = 0;
		wc.cbWndExtra = 0;
		wc.hInstance = NULL;
		wc.hIcon = NULL;
		wc.hCursor = LoadCursor( NULL, IDC_ARROW );
		wc.hbrBackground = HBRUSH( RGB( 0, 0, 0 ) );
		wc.lpszMenuName = "";
		wc.lpszClassName = "forceinline::dx_overlay";
		wc.hIconSm = NULL;

		//Register our window class
		if ( !RegisterClassExA( &wc ) )
			throw std::exception( "dx_overlay::create_overlay: failed to register wndclassex" );

		//Find our target window
		m_target_wnd = FindWindowW( target_class.data( ), target_window.data( ) );

		//Get the size of our target window
		GetWindowRect( m_target_wnd, &m_target_wnd_size );

		//Make the window transparent
		DWORD ex_styles = WS_EX_LAYERED | WS_EX_TRANSPARENT;

		//Add WS_EX_TOPMOST if we choose
		if ( !m_not_topmost )
			ex_styles |= WS_EX_TOPMOST;

		//Create our window
		m_overlay_wnd = CreateWindowExA( ex_styles, "forceinline::dx_overlay", "", WS_POPUP | WS_VISIBLE,
										 m_target_wnd_size.left, m_target_wnd_size.top, m_target_wnd_size.width( ), m_target_wnd_size.height( ), NULL, NULL, NULL, NULL );

		if ( !m_overlay_wnd )
			throw std::exception( "dx_overlay::create_overlay: failed to create overlay window" );

		//Let DWM handle our window
		MARGINS m = { m_target_wnd_size.left, m_target_wnd_size.top, m_target_wnd_size.width( ), m_target_wnd_size.height( ) };
		DwmExtendFrameIntoClientArea( m_overlay_wnd, &m );

		//Set window to use alpha channel
		SetLayeredWindowAttributes( m_overlay_wnd, RGB( 0, 0, 0 ), 255, LWA_ALPHA );

		//Show our window
		ShowWindow( m_overlay_wnd, SW_SHOW );

		//Initialize DirectX
		init_dx9( );
	}

	void dx_overlay::init_dx9( ) {
		//Create DirectX object
		m_d3d = Direct3DCreate9( D3D_SDK_VERSION );

		if ( !m_d3d )
			throw std::exception( "dx_overlay::init_dx9: failed to create dx3d9 object" );

		//Create DirectX present parameters struct
		D3DPRESENT_PARAMETERS d3d_pp;
		ZeroMemory( &d3d_pp, sizeof( d3d_pp ) );

		//Set our device parameters
		d3d_pp.Windowed = true;
		d3d_pp.SwapEffect = D3DSWAPEFFECT_DISCARD;
		d3d_pp.BackBufferFormat = D3DFMT_A8R8G8B8;
		d3d_pp.BackBufferWidth = m_target_wnd_size.width( );
		d3d_pp.BackBufferHeight = m_target_wnd_size.height( );
		d3d_pp.hDeviceWindow = m_overlay_wnd;
		d3d_pp.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

		//Create DirectX device
		if ( FAILED( m_d3d->CreateDevice( D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, m_overlay_wnd, D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3d_pp, &m_device ) ) ) {
			m_d3d->Release( );
			throw std::exception( "dx_overlay::init_dx9: failed to create device" );
		}

		//Overlay successfully initialized
		m_initialized = true;
	}

	bool dx_overlay::m_not_topmost = false;
	HWND dx_overlay::m_target_wnd, dx_overlay::m_overlay_wnd;

	LRESULT CALLBACK dx_overlay::m_wnd_proc( HWND wnd, UINT msg, WPARAM wparam, LPARAM lparam ) {
		//Imitate WS_EX_TOPMOST if specified
		if ( m_not_topmost ) {
			//Grab target window RECT
			wnd_rect_t r;
			GetWindowRect( m_target_wnd, &r );

			//Set the target windows z position to be under our overlay
			SetWindowPos( m_target_wnd, m_overlay_wnd, r.left, r.top, r.width( ), r.height( ), SWP_NOMOVE | SWP_NOSIZE );
		}

		switch ( msg ) {
			case WM_DESTROY:
				exit( 0 );
				break;
			default:
				return DefWindowProc( wnd, msg, wparam, lparam );
		}
	}
}

```

`dx_overlay/dx_overlay.h`:

```h
#pragma once
#include "../dx_renderer/dx_renderer.h"

namespace forceinline {
	class dx_overlay {
	private:
		struct wnd_rect_t : public RECT {
			int width( ) { return right - left; }
			int height( ) { return bottom - top; }
		};

	public:
		dx_overlay( ) { }
		dx_overlay( std::wstring_view target_class, std::wstring_view target_window, bool not_topmost = false );
		~dx_overlay( );

		dx_renderer create_renderer( );
		HWND get_overlay_wnd( );

		bool is_initialized( );

	private:
		void create_overlay( std::wstring_view target_class, std::wstring_view target_window );
		void init_dx9( );

		int m_fps = 0;
		bool m_initialized = false;
		
		static bool m_not_topmost;

		static HWND m_overlay_wnd, m_target_wnd;
		wnd_rect_t m_overlay_wnd_size, m_target_wnd_size;

		IDirect3D9* m_d3d = nullptr;
		IDirect3DDevice9* m_device = nullptr;

		static LRESULT CALLBACK m_wnd_proc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam );
	};
}
```

`dx_renderer/dx_renderer.cpp`:

```cpp
#include "dx_renderer.h"
#include <iostream>

namespace forceinline {
	//Customize your font here
	dx_renderer::dx_renderer( IDirect3DDevice9* device ) {
		if ( !device )
			throw std::invalid_argument( "dx_renderer::dx_renderer: device is nullptr" );

		m_device = device;

		if ( FAILED( D3DXCreateLine( m_device, &m_line ) ) )
			throw std::exception( "dx_renderer::dx_renderer: failed to create line" );

		if ( FAILED( D3DXCreateFont( m_device, 12, NULL, FW_HEAVY, 1, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, ANTIALIASED_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "Tahoma", &m_font ) ) )
			throw std::exception( "dx_renderer::dx_renderer: failed to create font" );
	}

	dx_renderer::~dx_renderer( ) {
		if ( m_font )
			m_font->Release( );

		if ( m_line )
			m_line->Release( );
	}

	void dx_renderer::begin_rendering( ) {
		m_device->Clear( NULL, NULL, D3DCLEAR_TARGET, D3DCOLOR_ARGB( 0, 0, 0, 0 ), 1.f, 0 );
		m_device->BeginScene( );
	}

	void dx_renderer::end_rendering( ) {
		static int fps = 0;
		static float last_tick_count = 0.f;

		//Increase FPS
		fps++;

		//Get current time
		float cur_tick_count = clock( ) * 0.001f;

		//Check if the FPS haven't been updated for 1s or longer
		if ( cur_tick_count - last_tick_count >= 1.f ) {
			//Update our FPS
			last_tick_count = cur_tick_count;
			m_fps = fps;
			fps = 0;
		}

		m_device->EndScene( );
		m_device->Present( NULL, NULL, NULL, NULL );
	}

	int dx_renderer::get_fps( ) {
		return m_fps; //Return our overlay's FPS
	}

	void dx_renderer::draw_line( int x0, int y0, int x1, int y1, unsigned long color ) {
		/*D3DTLVERTEX qV[ 2 ] = {
			{ float( x0 ), float( y0 ), 0.f, 1.f, color },
			{ float( x1 ), float( y1 ), 0.f, 1.f, color },
		};

		m_device->SetRenderState( D3DRS_ALPHABLENDENABLE, true );
		m_device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
		m_device->SetFVF( D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1 );
		m_device->SetTexture( 0, nullptr );
		m_device->DrawPrimitiveUP( D3DPT_LINELIST, 2, qV, sizeof( D3DTLVERTEX ) );*/
		
		D3DXVECTOR2 lines[ 2 ] = {
			D3DXVECTOR2( x0, y0 ),
			D3DXVECTOR2( x1, y1 )
		};

		m_line->Begin( );
		m_line->Draw( lines, 2, color );
		m_line->End( );
	}

	void dx_renderer::draw_rect( int x, int y, int w, int h, unsigned long color ) {
		draw_line( x, y, x + w, y, color );
		draw_line( x, y, x, y + h, color );
		draw_line( x + w, y, x + w, y + h, color );
		draw_line( x, y + h, x + w + 1, y + h, color );
	}

	void dx_renderer::draw_filled_rect( int x, int y, int w, int h, unsigned long color ) {
		D3DTLVERTEX qV[ 4 ] = {
			{ float( x ), float( y + h ), 0.f, 1.f, color },
			{ float( x ), float( y ), 0.f, 1.f, color },
			{ float( x + w ), float( y + h ), 0.f, 1.f, color },
			{ float( x + w ), float( y ) , 0.f, 1.f, color }
		};
		
		m_device->SetRenderState( D3DRS_ALPHABLENDENABLE, true );
		m_device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
		m_device->SetFVF( D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1 );
		m_device->SetTexture( 0, nullptr );
		m_device->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, qV, sizeof( D3DTLVERTEX ) );
	}

	void dx_renderer::draw_outlined_rect( int x, int y, int w, int h, unsigned long color ) {
		draw_rect( x - 1, y - 1, w + 2, h + 2, D3DCOLOR_RGBA( 1, 1, 1, 255 ) );
		draw_rect( x + 1, y + 1, w - 2, h - 2, D3DCOLOR_RGBA( 1, 1, 1, 255 ) );
		draw_rect( x, y, w, h, color );
	}

	void dx_renderer::draw_text( std::string_view text, int x, int y, unsigned long color, bool center, bool outline ) {
		if ( center ) {
			RECT dimensions = get_text_dimensions( text );
			x -= ( dimensions.right - dimensions.left ) / 2;
		}

		auto _text = [ & ]( std::string_view _text, int _x, int _y, unsigned long _color ) {
			RECT r{ _x, _y, _x, _y };
			m_font->DrawTextA( NULL, _text.data( ), -1, &r, DT_NOCLIP, _color );
		};

		if ( outline ) {
			_text( text, x - 1, y, D3DCOLOR_RGBA( 1, 1, 1, 255 ) );
			_text( text, x + 1, y, D3DCOLOR_RGBA( 1, 1, 1, 255 ) );
			_text( text, x, y - 1, D3DCOLOR_RGBA( 1, 1, 1, 255 ) );
			_text( text, x, y + 1, D3DCOLOR_RGBA( 1, 1, 1, 255 ) );
		}

		_text( text, x, y, color );
	}

	RECT dx_renderer::get_text_dimensions( std::string_view text ) {
		RECT r;
		m_font->DrawTextA( NULL, text.data( ), -1, &r, DT_CALCRECT, 0xFFFFFFFF );
		return r;
	}
}
```

`dx_renderer/dx_renderer.h`:

```h
#pragma once
#include <string>
#include <thread>

#include <Windows.h>

#include <d3d9.h>
#include <d3dx9.h>
#pragma comment (lib, "d3d9.lib")
#pragma comment (lib, "d3dx9.lib")

namespace forceinline {
	class dx_renderer {
	private: 
		struct D3DTLVERTEX {
			float x, y, z, rhw;
			unsigned long color;
		};

	public:
		dx_renderer( ) { }
		dx_renderer( IDirect3DDevice9* device );
		~dx_renderer( );

		void begin_rendering( );
		void end_rendering( );

		int get_fps( );

		void draw_line( int x0, int y0, int x1, int y1, unsigned long color );
		void draw_rect( int x, int y, int w, int h, unsigned long color );
		void draw_filled_rect( int x, int y, int w, int h, unsigned long color );
		void draw_outlined_rect( int x, int y, int w, int h, unsigned long color );
		void draw_text( std::string_view text, int x, int y, unsigned long color, bool center = true, bool outline = true );

		RECT get_text_dimensions( std::string_view text );

	private:
		int m_fps = 0;

		IDirect3DDevice9* m_device = nullptr;

		ID3DXFont* m_font = nullptr;
		ID3DXLine* m_line = nullptr;
	};
}
```

`esp/esp.cpp`:

```cpp
#include "esp.h"

//TODO: Add dynamic way of screen size getting
sdk::vec3_t screen_size( 1920, 1080, 0 );

namespace esp {
	std::vector< esp_entity_t > entities( 64 );

	void draw( forceinline::memory_manager* memory, forceinline::dx_renderer* renderer ) {
		//Create our vectors for the 2D screen position
		sdk::vec3_t screen_bottom, screen_top;

		//Get the module base for client_panorama.dll
		static std::uintptr_t client_dll = memory->get_module_base( "client_panorama.dll" );

		//Grab the view matrix
		sdk::view_matrix_t view_matrix = memory->read< sdk::view_matrix_t >( client_dll + 0x4CF86E4 ); //view_matrix

		//Doesn't work; flickers a LOT for some reason.
		//static std::uintptr_t crender_bytes = memory->find_pattern( "engine.dll", "B9 ? ? ? ? A1 ? ? ? ? FF 60 38" ) + 1;
		//static std::uintptr_t crender_offset = memory->read< std::uintptr_t >( crender_bytes );

		//sdk::view_matrix_t view_matrix = memory->read< sdk::view_matrix_t >( crender_offset + 39 * 4 );

		//Loop our vector containing the entities
		for ( auto& ent : entities ) {
			//If our entity isn't valid, skip it
			if ( !ent.valid )
				continue;
			
			//Convert 3D space coordinates to 2D screen coordinates
			if ( !sdk::world_to_screen( screen_size, ent.origin, screen_bottom, view_matrix ) || !sdk::world_to_screen( screen_size, ent.top_origin, screen_top, view_matrix ) )
				 continue;

			//Box properties
			int box_height = screen_bottom.y - screen_top.y;
			int box_width = box_height / 2;

			//Draw the ESP
			renderer->draw_outlined_rect( screen_top.x - box_width / 2, screen_top.y, box_width, box_height, D3DCOLOR_RGBA( 65, 135, 245, 255 ) );
			renderer->draw_text( ent.name, screen_top.x, screen_top.y - 14, 0xFFFFFFFF );
			renderer->draw_text( std::to_string( ent.health ) + " HP", screen_top.x, screen_bottom.y, 0xFFFFFFFF );
		}
	}
}
```

`esp/esp.h`:

```h
#pragma once
#include <vector>
#include "../csgo_sdk/csgo_sdk.h"
#include "../dx_overlay/dx_overlay.h"

namespace esp {
	struct esp_entity_t {
		bool valid = false;

		int health = 0;
		std::string name = "";
		sdk::vec3_t origin, top_origin;
	};

	extern std::vector< esp_entity_t > entities;

	extern void draw( forceinline::memory_manager* memory, forceinline::dx_renderer* renderer );
}
```

`main.cpp`:

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include "memory_manager/memory_manager.h"
#include "dx_overlay/dx_overlay.h"
#include "csgo_sdk/csgo_sdk.h"
#include "esp/esp.h"

#include <mutex>
#include <iostream>
#include <cassert>

//Custom logging functions
void log( std::string_view message ) {
	std::cout << "[+] " << message << std::endl;
}

void log_and_exit( std::string_view message ) {
	log( message );
	std::this_thread::sleep_for( std::chrono::seconds( 3 ) );
	exit( -1 );
}

int APIENTRY wWinMain( _In_ HINSTANCE instance, _In_opt_ HINSTANCE prev_instance, _In_ LPWSTR p_cmd_line, _In_ int cmd_show ) {
	AllocConsole( );
	freopen( "conout$", "w", stdout );

	try {
		//Create overlay and memory objects
		forceinline::memory_manager memory( "csgo.exe" );
		forceinline::dx_overlay overlay( L"Valve001", L"Counter-Strike: Global Offensive", false );

		//If our constructor didn't throw, these will have to be true
		assert( memory.is_attached( ) );
		assert( overlay.is_initialized( ) );

		log( "Attached to process" );
		log( "Created overlay" );

		//Create a mutex so we can multithread safely
		std::mutex ent_mtx;

		//Grab the base of the modules
		sdk::modules_t modules( &memory );

		//Create a thread to read info so we don't slow down our rendering part
		std::thread read_ent_info( [ & ]( ) -> void {
			std::vector< sdk::ent_info_t > ent_info( 64 );

			while ( 1 ) {
				std::this_thread::sleep_for( std::chrono::milliseconds( 1 ) );

				//Lock our mutex so our ESP thread doesn't do dumb shit
				std::unique_lock lock( ent_mtx );

				//Invalidate all ESP entities as we're updating them
				for ( auto& esp_ent : esp::entities )
					esp_ent.valid = false;

				//Get clientstate for the entitylist
				std::uintptr_t client_state = memory.read< std::uintptr_t >( modules.engine_dll + 0x590D8C ); //m_dwClientState

				//Read the whole entity list at once
				memory.read_ex< sdk::ent_info_t >( ent_info.data( ), modules.client_dll + 0x4D06CB4, ent_info.size( ) ); //m_dwEntityList

				//Get our local player ptr
				int local_player_idx = memory.read< int >( client_state + 0x180 ); //m_dwClientState_GetLocalPlayer
				std::uintptr_t local_ptr = ent_info[ local_player_idx ].entity_ptr;

				//Is our local player ptr valid?
				if ( !local_ptr )
					continue;

				//Get our local player
				sdk::entity_t local( &memory, &modules, local_ptr );

				//Gather entity information for our ESP
				for ( std::size_t i = 0; i < ent_info.size( ); i++ ) {
					std::uintptr_t ent_ptr = ent_info[ i ].entity_ptr;

					//Entity is invalid, don't draw on ESP
					if ( !ent_ptr )
						continue;

					//Create an entity object so we can get information the easy way
					sdk::entity_t entity( &memory, &modules, ent_ptr );

					//Continue if entity is dormant or dead
					if ( entity.dormant( ) || !entity.is_alive( ) )
						continue;

					//We don't want to draw ESP on our team
					if ( entity.team( ) == local.team( ) )
						continue;

					//We have a valid entity, get a reference to it for ease of use
					esp::esp_entity_t& esp_entity = esp::entities[ i ];

					//Get entity information for our ESP
					esp_entity.health = entity.health( );
					entity.get_name( esp_entity.name );
					esp_entity.origin = entity.origin( );
					esp_entity.top_origin = esp_entity.origin + sdk::vec3_t( 0.f, 0.f, 75.f );

					//Our ESP entity is now valid to draw
					esp_entity.valid = true;
				}
			}
		} );

		log( "Started reading thread, starting rendering" );

		//MSG struct for WndProc
		MSG m;
		ZeroMemory( &m, sizeof m );

		//Get our overlay renderer
		forceinline::dx_renderer renderer = overlay.create_renderer( );

		//Message and rendering loop
		do {
			if ( PeekMessage( &m, overlay.get_overlay_wnd( ), NULL, NULL, PM_REMOVE ) ) {
				TranslateMessage( &m );
				DispatchMessage( &m );
			}
			
			//Lock the mutex so we don't fuck shit up
			std::unique_lock lock( ent_mtx );

			//Render our ESP
			renderer.begin_rendering( );
			renderer.draw_text( std::to_string( renderer.get_fps( ) ), 2, 2, 0xFFFFFFFF, false );
			esp::draw( &memory, &renderer );
			renderer.end_rendering( );

			std::this_thread::sleep_for( std::chrono::milliseconds( 1 ) );
		} while ( m.message != WM_QUIT );

		log( "Exiting..." );
		std::this_thread::sleep_for( std::chrono::seconds( 3 ) );

		return 0;
	} catch ( const std::exception& e ) {
		//Catch and log any exceptions
		log_and_exit( e.what( ) );
	}
}
```

`memory_manager/memory_manager.cpp`:

```cpp
#include "memory_manager.h"

#include <iostream>
#include <vector>
#include <algorithm>

namespace forceinline {
	memory_manager::memory_manager( std::string_view process ) {
		if ( process.empty( ) )
			throw std::invalid_argument( "memory_manager::memory_manager: process argument is empty" );

		attach_to_process( process );
	}

	memory_manager::~memory_manager( ) {
		if ( m_proc_handle )
			CloseHandle( m_proc_handle );
	}

	MODULEENTRY32 memory_manager::get_module_entry( std::string_view module ) {
		//Create snapshot that includes 32 and 64 bit modules
		HANDLE snapshot = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, m_proc_id );

		//Create MODULEENTRY32 struct
		MODULEENTRY32 me;
		me.dwSize = sizeof me;

		//Is our snapshot valid?
		if ( !snapshot )
			throw std::exception( "memory_manager::get_module_entry: failed to create snapshot" );

		//Iterate through the processes modules
		for ( Module32First( snapshot, &me ); Module32Next( snapshot, &me ); ) {
			//We found our module, stop iterating
			if ( module.compare( me.szModule ) == 0 )
				break;
		}

		//Close our snapshot handle and return the MODULEENTRY32 struct
		CloseHandle( snapshot );
		return me;
	}

	std::uintptr_t memory_manager::get_module_base( std::string_view module ) {
		return std::uintptr_t( get_module_entry( module ).modBaseAddr ); //Convenience
	}

	//Wrapper for find_pattern below
	std::uintptr_t memory_manager::find_pattern( std::string_view module, std::string_view pattern ) {
		//Get the target modules info
		auto module_entry = get_module_entry( module );

		//Get module begin and size
		std::size_t module_size = std::size_t( module_entry.modBaseSize );
		std::uintptr_t module_begin = std::uintptr_t( module_entry.modBaseAddr );
		
		//Scan for our pattern
		return find_pattern( module_begin, module_size, pattern );
	}

	/*
		Find pattern in given module
		Example pattern: "E8 ?? ?? ?? ?? CC"
		Pattern can NOT be without spaces. Wildcars can be single or double question marks, but they have to be seperated with spaces. 
	*/
	std::uintptr_t memory_manager::find_pattern( std::uintptr_t module_begin, std::size_t module_size, std::string_view pattern ) {
		//Allocate sizeof module bytes
		std::vector< std::uint8_t > module_bytes( module_size );

		std::size_t page_size = 4096;
		std::size_t num_pages = module_size / page_size;
		std::size_t page_remainder = module_size % page_size;

		//Function to read a page
		std::uintptr_t total_bytes_read = 0x0;
		auto read_page = [ & ]( std::uintptr_t start, std::size_t size ) -> bool {
			//Modify the page so we can read it, also add execute and write rights so we don't crash our process
			DWORD old_protect;
			VirtualProtectEx( m_proc_handle, reinterpret_cast< void* >( start ), size, PAGE_EXECUTE_READWRITE, &old_protect );

			//Read a whole page (or the remainder of it)
			SIZE_T bytes_read;
			if ( !ReadProcessMemory( m_proc_handle, reinterpret_cast< LPCVOID >( start ), module_bytes.data( ) + total_bytes_read, size, &bytes_read ) )
				return 0x0;

			//Add the read bytes
			total_bytes_read += bytes_read;

			//Restore the old protection flags
			VirtualProtectEx( m_proc_handle, reinterpret_cast< void* >( start ), size, old_protect, &old_protect );

			//Did we read as much as we requested to?
			return bytes_read == size;
		};

		//Read each page seperately
		for ( std::size_t i = 0; i < num_pages; i++ ) {
			//Return 0 if we failed to read
			if ( !read_page( module_begin + i * page_size, page_size ) )
				return 0x0;
		}

		//Read remainder of page
		if ( !read_page( module_begin + --num_pages * page_size, page_remainder ) )
			return 0x0;

		//We didn't read the whole module
		if ( total_bytes_read != module_size )
			return 0x0;

		auto get_byte_vector_and_mask = [ ]( const std::string& pattern, std::vector< std::uint8_t >& byte_vec, std::string& mask ) {
			for ( std::size_t i = 0; i < pattern.length( ); i++ ) {
				//Skip spaces
				if ( pattern[ i ] == ' ' )
					continue;

				//Add wildcard
				if ( pattern[ i ] == '?' ) {
					while ( pattern[ i + 1 ] == '?' )
						i++;

					mask.append( "?" );
					byte_vec.push_back( 0x0 );
					continue;
				}

				//Add converted byte
				byte_vec.push_back( std::stoi( pattern.substr( i++, 2 ), nullptr, 16 ) );
				mask.append( "x" );
			}
		};
		
		//Generate pattern bytes and mask from signature
		std::string pattern_mask;
		std::vector< std::uint8_t > pattern_bytes;
		get_byte_vector_and_mask( pattern.data( ), pattern_bytes, pattern_mask );

		//Scan for our pattern
		std::uintptr_t pattern_offset = 0x0;
		for ( std::size_t i = 0; i < module_size; i++ ) {
			//Found a matching byte
			if ( module_bytes[ i ] == pattern_bytes[ 0 ] ) {
				//Save offset
				pattern_offset = i;

				//Check the pattern further
				for ( std::size_t j = 1; j < pattern_bytes.size( ); j++ ) {
					auto pattern_byte = pattern_bytes[ j ];
					auto mask_byte = pattern_mask[ j ];

					//Is current mask byte a wildcard?
					if ( mask_byte != '?' ) {
						//Bytes don't match and pattern at current position, start over
						if ( pattern_byte != module_bytes[ i + j ] )
							break;
					}

					//Pattern matches, return offset
					if ( j + 1 == pattern_bytes.size( ) )
						return module_begin + pattern_offset;
				}

				//Didn't find pattern, reset our pattern offset
				pattern_offset = 0;
			}
		}

		//Return 0 as we didn't find anything
		return 0x0;
	}

	bool memory_manager::is_attached( ) {
		return m_proc_handle != nullptr; //Are we attached to our target process?
	}

	std::uintptr_t memory_manager::operator[ ]( std::string_view module ) {
		return get_module_base( module ); //Convenience
	}

	void memory_manager::attach_to_process( std::string_view process ) {
		//Create snapshot
		HANDLE snapshot = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, NULL );

		if ( !snapshot )
			throw std::exception( "memory_manager::attach_to_process: failed to create snapshot" );

		//Create PROCESSENTRY structure
		PROCESSENTRY32 pe;
		pe.dwSize = sizeof pe;

		//Enumerate running processes
		for ( Process32First( snapshot, &pe ); Process32Next( snapshot, &pe ); ) {
			//Have we found our target process?
			if ( process.compare( pe.szExeFile ) == 0 ) {
				//Open handle with rights to read, write, allocate memory and create remote threads
				m_proc_id = pe.th32ProcessID;
				m_proc_handle = OpenProcess( PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION | PROCESS_CREATE_THREAD, FALSE, m_proc_id );
				break;
			}
		}

		//Close snapshot handle
		CloseHandle( snapshot );
		
		if ( !m_proc_handle )
			throw std::exception( "memory_manager::attach_to_process: process not found" );
	}
}
```

`memory_manager/memory_manager.h`:

```h
#pragma once
#include <string>

#include <Windows.h>
#include <Psapi.h>
#include <TlHelp32.h>

namespace forceinline {
	class memory_manager {
	public:
		memory_manager( ) { }
		memory_manager( std::string_view process );
		~memory_manager( );

		MODULEENTRY32 get_module_entry( std::string_view module );
		std::uintptr_t get_module_base( std::string_view module );

		std::uintptr_t find_pattern( std::string_view module, std::string_view pattern );
		std::uintptr_t find_pattern( std::uintptr_t module_begin, std::size_t module_size, std::string_view pattern );

		bool is_attached( );

		template < typename T >
		T read( std::uintptr_t address ) {
			T temp_val;
			ReadProcessMemory( m_proc_handle, reinterpret_cast< LPCVOID >( address ), &temp_val, sizeof T, nullptr );

			return temp_val;
		}

		/*
			Reads custom length.
			Example: you want to read a float[ 64 ].
			you'd use this as follows:
			read_ex< float >( float_arr_ptr, 0xDEADBEEF, 64 )
		*/
		template < typename T >
		void read_ex( T* out_object_ptr, std::uintptr_t address, std::size_t object_count ) {
			ReadProcessMemory( m_proc_handle, reinterpret_cast< LPCVOID >( address ), out_object_ptr, sizeof T * object_count, nullptr );
		}

		template < typename T >
		bool write( std::uintptr_t address, T value ) {
			SIZE_T bytes_written;
			WriteProcessMemory( m_proc_handle, reinterpret_cast< LPCVOID >( address ), &value, sizeof T, &bytes_written );

			return bytes_written == sizeof T;
		}

		//See read_ex
		template < typename T >
		bool write_ex( T* object_ptr, std::uintptr_t address, std::size_t object_count ) {
			SIZE_T bytes_written;
			WriteProcessMemory( m_proc_handle, reinterpret_cast< LPCVOID >( address ), object_ptr, sizeof T * object_count, &bytes_written );

			return bytes_written == sizeof T * object_count;
		}

		std::uintptr_t operator[ ]( std::string_view module );

	private:
		void attach_to_process( std::string_view process );

		HANDLE m_proc_handle = nullptr;
		std::uintptr_t m_proc_id = 0;
	};
}
```