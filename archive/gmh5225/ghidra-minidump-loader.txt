Project Path: arc_gmh5225_ghidra-minidump-loader_syviievc

Source Tree:

```txt
arc_gmh5225_ghidra-minidump-loader_syviievc
├── LICENSE
├── MinidumpLoader
│   ├── Module.manifest
│   ├── build.gradle
│   ├── data
│   │   └── README.txt
│   ├── extension.properties
│   ├── ghidra_scripts
│   │   └── README.txt
│   ├── lib
│   │   └── README.txt
│   ├── os
│   │   ├── linux64
│   │   │   └── README.txt
│   │   ├── osx64
│   │   │   └── README.txt
│   │   └── win64
│   │       └── README.txt
│   └── src
│       ├── main
│       │   ├── help
│       │   │   └── help
│       │   │       ├── TOC_Source.xml
│       │   │       ├── shared
│       │   │       │   └── Frontpage.css
│       │   │       └── topics
│       │   │           └── minidumploader
│       │   │               └── help.html
│       │   ├── java
│       │   │   └── net
│       │   │       └── jubjubnest
│       │   │           └── minidump
│       │   │               ├── analyzer
│       │   │               │   ├── FindSymbolsFileChooser.java
│       │   │               │   ├── ModuleParser.java
│       │   │               │   ├── ModulePdbAnalyzer.java
│       │   │               │   ├── PdbResolver.java
│       │   │               │   ├── SubTaskMonitor.java
│       │   │               │   ├── SymbolInfo.java
│       │   │               │   └── SymbolLocationDialog.java
│       │   │               ├── contrib
│       │   │               │   ├── new_
│       │   │               │   │   ├── AbstractModuleBaseOffsetDataType.java
│       │   │               │   │   ├── ImageLoadInfo.java
│       │   │               │   │   ├── ModuleBaseMap.java
│       │   │               │   │   ├── ModuleBaseOffset32DataType.java
│       │   │               │   │   └── ModuleBaseOffset64DataType.java
│       │   │               │   ├── opinion
│       │   │               │   │   ├── AbstractPeDebugLoader.java
│       │   │               │   │   └── PeLoader.java
│       │   │               │   └── pe
│       │   │               │       ├── ArchitectureDataDirectory.java
│       │   │               │       ├── BaseRelocation.java
│       │   │               │       ├── BaseRelocationDataDirectory.java
│       │   │               │       ├── BoundImportDataDirectory.java
│       │   │               │       ├── BoundImportDescriptor.java
│       │   │               │       ├── BoundImportForwarderRef.java
│       │   │               │       ├── COMDescriptorDataDirectory.java
│       │   │               │       ├── Constants.java
│       │   │               │       ├── ControlFlowGuard.java
│       │   │               │       ├── DataDirectory.java
│       │   │               │       ├── DebugDataDirectory.java
│       │   │               │       ├── DefaultDataDirectory.java
│       │   │               │       ├── DelayImportDataDirectory.java
│       │   │               │       ├── DelayImportDescriptor.java
│       │   │               │       ├── DelayImportInfo.java
│       │   │               │       ├── DllCharacteristics.java
│       │   │               │       ├── ExceptionDataDirectory.java
│       │   │               │       ├── ExportDataDirectory.java
│       │   │               │       ├── ExportInfo.java
│       │   │               │       ├── FileHeader.java
│       │   │               │       ├── GlobalPointerDataDirectory.java
│       │   │               │       ├── ImageCor20Header.java
│       │   │               │       ├── ImportAddressTableDataDirectory.java
│       │   │               │       ├── ImportByName.java
│       │   │               │       ├── ImportDataDirectory.java
│       │   │               │       ├── ImportDescriptor.java
│       │   │               │       ├── ImportInfo.java
│       │   │               │       ├── InvalidNTHeaderException.java
│       │   │               │       ├── LoadConfigDataDirectory.java
│       │   │               │       ├── LoadConfigDirectory.java
│       │   │               │       ├── MachineConstants.java
│       │   │               │       ├── MachineName.java
│       │   │               │       ├── NTHeader.java
│       │   │               │       ├── OffsetValidator.java
│       │   │               │       ├── OptionalHeader.java
│       │   │               │       ├── OptionalHeaderImpl.java
│       │   │               │       ├── OptionalHeaderROM.java
│       │   │               │       ├── PeMarkupable.java
│       │   │               │       ├── PeSubsystem.java
│       │   │               │       ├── PeUtils.java
│       │   │               │       ├── PortableExecutable.java
│       │   │               │       ├── ROMHeader.java
│       │   │               │       ├── ResourceDataDirectory.java
│       │   │               │       ├── RichHeader.java
│       │   │               │       ├── RichTable.java
│       │   │               │       ├── SectionFlags.java
│       │   │               │       ├── SectionHeader.java
│       │   │               │       ├── SecurityCertificate.java
│       │   │               │       ├── SecurityDataDirectory.java
│       │   │               │       ├── SeparateDebugHeader.java
│       │   │               │       ├── TLSDataDirectory.java
│       │   │               │       ├── TLSDirectory.java
│       │   │               │       ├── ThunkData.java
│       │   │               │       ├── cli
│       │   │               │       │   ├── CliMetadataDirectory.java
│       │   │               │       │   ├── CliMetadataRoot.java
│       │   │               │       │   ├── CliRepresentable.java
│       │   │               │       │   ├── CliStreamHeader.java
│       │   │               │       │   ├── blobs
│       │   │               │       │   │   ├── CliAbstractSig.java
│       │   │               │       │   │   ├── CliBlob.java
│       │   │               │       │   │   ├── CliBlobMarshalSpec.java
│       │   │               │       │   │   ├── CliSigField.java
│       │   │               │       │   │   ├── CliSigLocalVar.java
│       │   │               │       │   │   ├── CliSigMethodDef.java
│       │   │               │       │   │   ├── CliSigMethodRef.java
│       │   │               │       │   │   ├── CliSigMethodSpec.java
│       │   │               │       │   │   ├── CliSigProperty.java
│       │   │               │       │   │   ├── CliSigStandAloneMethod.java
│       │   │               │       │   │   └── CliSigTypeSpec.java
│       │   │               │       │   ├── methods
│       │   │               │       │   │   ├── CliMethodDef.java
│       │   │               │       │   │   └── CliMethodExtraSections.java
│       │   │               │       │   ├── streams
│       │   │               │       │   │   ├── CliAbstractStream.java
│       │   │               │       │   │   ├── CliStreamBlob.java
│       │   │               │       │   │   ├── CliStreamGuid.java
│       │   │               │       │   │   ├── CliStreamMetadata.java
│       │   │               │       │   │   ├── CliStreamStrings.java
│       │   │               │       │   │   └── CliStreamUserStrings.java
│       │   │               │       │   └── tables
│       │   │               │       │       ├── CliAbstractTable.java
│       │   │               │       │       ├── CliAbstractTableRow.java
│       │   │               │       │       ├── CliTableAssembly.java
│       │   │               │       │       ├── CliTableAssemblyOS.java
│       │   │               │       │       ├── CliTableAssemblyProcessor.java
│       │   │               │       │       ├── CliTableAssemblyRef.java
│       │   │               │       │       ├── CliTableAssemblyRefOS.java
│       │   │               │       │       ├── CliTableAssemblyRefProcessor.java
│       │   │               │       │       ├── CliTableClassLayout.java
│       │   │               │       │       ├── CliTableConstant.java
│       │   │               │       │       ├── CliTableCustomAttribute.java
│       │   │               │       │       ├── CliTableDeclSecurity.java
│       │   │               │       │       ├── CliTableEvent.java
│       │   │               │       │       ├── CliTableEventMap.java
│       │   │               │       │       ├── CliTableExportedType.java
│       │   │               │       │       ├── CliTableField.java
│       │   │               │       │       ├── CliTableFieldLayout.java
│       │   │               │       │       ├── CliTableFieldMarshall.java
│       │   │               │       │       ├── CliTableFieldRVA.java
│       │   │               │       │       ├── CliTableFile.java
│       │   │               │       │       ├── CliTableGenericParam.java
│       │   │               │       │       ├── CliTableGenericParamConstraint.java
│       │   │               │       │       ├── CliTableImplMap.java
│       │   │               │       │       ├── CliTableInterfaceImpl.java
│       │   │               │       │       ├── CliTableManifestResource.java
│       │   │               │       │       ├── CliTableMemberRef.java
│       │   │               │       │       ├── CliTableMethodDef.java
│       │   │               │       │       ├── CliTableMethodImpl.java
│       │   │               │       │       ├── CliTableMethodSemantics.java
│       │   │               │       │       ├── CliTableMethodSpec.java
│       │   │               │       │       ├── CliTableModule.java
│       │   │               │       │       ├── CliTableModuleRef.java
│       │   │               │       │       ├── CliTableNestedClass.java
│       │   │               │       │       ├── CliTableParam.java
│       │   │               │       │       ├── CliTableProperty.java
│       │   │               │       │       ├── CliTablePropertyMap.java
│       │   │               │       │       ├── CliTableStandAloneSig.java
│       │   │               │       │       ├── CliTableTypeDef.java
│       │   │               │       │       ├── CliTableTypeRef.java
│       │   │               │       │       ├── CliTableTypeSpec.java
│       │   │               │       │       ├── CliTypeTable.java
│       │   │               │       │       ├── flags
│       │   │               │       │       │   └── CliFlags.java
│       │   │               │       │       └── indexes
│       │   │               │       │           ├── CliCodedIndexUtils.java
│       │   │               │       │           ├── CliIndexCustomAttributeType.java
│       │   │               │       │           ├── CliIndexHasConstant.java
│       │   │               │       │           ├── CliIndexHasCustomAttribute.java
│       │   │               │       │           ├── CliIndexHasDeclSecurity.java
│       │   │               │       │           ├── CliIndexHasFieldMarshall.java
│       │   │               │       │           ├── CliIndexHasSemantics.java
│       │   │               │       │           ├── CliIndexImplementation.java
│       │   │               │       │           ├── CliIndexMemberForwarded.java
│       │   │               │       │           ├── CliIndexMemberRefParent.java
│       │   │               │       │           ├── CliIndexMethodDefOrRef.java
│       │   │               │       │           ├── CliIndexResolutionScope.java
│       │   │               │       │           ├── CliIndexTypeDefOrRef.java
│       │   │               │       │           └── CliIndexTypeOrMethodDef.java
│       │   │               │       ├── debug
│       │   │               │       │   ├── DataSym32.java
│       │   │               │       │   ├── DataSym32_new.java
│       │   │               │       │   ├── DebugCOFFLineNumber.java
│       │   │               │       │   ├── DebugCOFFSymbol.java
│       │   │               │       │   ├── DebugCOFFSymbolAux.java
│       │   │               │       │   ├── DebugCOFFSymbolTable.java
│       │   │               │       │   ├── DebugCOFFSymbolsHeader.java
│       │   │               │       │   ├── DebugCodeView.java
│       │   │               │       │   ├── DebugCodeViewConstants.java
│       │   │               │       │   ├── DebugCodeViewSymbolTable.java
│       │   │               │       │   ├── DebugDirectory.java
│       │   │               │       │   ├── DebugDirectoryParser.java
│       │   │               │       │   ├── DebugFixup.java
│       │   │               │       │   ├── DebugFixupElement.java
│       │   │               │       │   ├── DebugMisc.java
│       │   │               │       │   ├── DebugSymbol.java
│       │   │               │       │   ├── DebugSymbolSelector.java
│       │   │               │       │   ├── OMFAlignSym.java
│       │   │               │       │   ├── OMFDirEntry.java
│       │   │               │       │   ├── OMFDirHeader.java
│       │   │               │       │   ├── OMFFileIndex.java
│       │   │               │       │   ├── OMFGlobal.java
│       │   │               │       │   ├── OMFLibrary.java
│       │   │               │       │   ├── OMFModule.java
│       │   │               │       │   ├── OMFSegDesc.java
│       │   │               │       │   ├── OMFSegMap.java
│       │   │               │       │   ├── OMFSegMapDesc.java
│       │   │               │       │   ├── OMFSrcModule.java
│       │   │               │       │   ├── OMFSrcModuleFile.java
│       │   │               │       │   ├── OMFSrcModuleLine.java
│       │   │               │       │   ├── PrimitiveTypeListing.java
│       │   │               │       │   ├── S_ALIGN.java
│       │   │               │       │   ├── S_BLOCK32.java
│       │   │               │       │   ├── S_BPREL32_NEW.java
│       │   │               │       │   ├── S_COMPILE.java
│       │   │               │       │   ├── S_CONSTANT32.java
│       │   │               │       │   ├── S_DATAREF.java
│       │   │               │       │   ├── S_END.java
│       │   │               │       │   ├── S_GDATA32_NEW.java
│       │   │               │       │   ├── S_GPROC32_NEW.java
│       │   │               │       │   ├── S_LABEL32.java
│       │   │               │       │   ├── S_LDATA32_NEW.java
│       │   │               │       │   ├── S_OBJNAME.java
│       │   │               │       │   ├── S_PROCREF.java
│       │   │               │       │   ├── S_UDT32.java
│       │   │               │       │   ├── S_UDT32_NEW.java
│       │   │               │       │   └── UnknownSymbol.java
│       │   │               │       ├── package.html
│       │   │               │       ├── resource
│       │   │               │       │   ├── ResourceDataEntry.java
│       │   │               │       │   ├── ResourceDirectory.java
│       │   │               │       │   ├── ResourceDirectoryEntry.java
│       │   │               │       │   ├── ResourceDirectoryString.java
│       │   │               │       │   ├── ResourceDirectoryStringU.java
│       │   │               │       │   ├── ResourceInfo.java
│       │   │               │       │   ├── ResourceStringInfo.java
│       │   │               │       │   ├── VS_VERSION_CHILD.java
│       │   │               │       │   ├── VS_VERSION_INFO.java
│       │   │               │       │   └── package.html
│       │   │               │       └── rich
│       │   │               │           ├── CompId.java
│       │   │               │           ├── MSProductType.java
│       │   │               │           ├── MSRichProductBuildNumberDataType.java
│       │   │               │           ├── MSRichProductIDDataType.java
│       │   │               │           ├── MSRichProductInfoDataType.java
│       │   │               │           ├── PERichTableDataType.java
│       │   │               │           ├── RichHeaderRecord.java
│       │   │               │           ├── RichHeaderUtils.java
│       │   │               │           ├── RichObjectCountDataType.java
│       │   │               │           ├── RichProduct.java
│       │   │               │           ├── RichProductIdLoader.java
│       │   │               │           └── RichTableRecordDataType.java
│       │   │               ├── data
│       │   │               │   ├── Context64.java
│       │   │               │   ├── ModuleData.java
│       │   │               │   ├── ObjectMapResolver.java
│       │   │               │   ├── ThreadContext.java
│       │   │               │   └── ThreadData.java
│       │   │               ├── loader
│       │   │               │   ├── MinidumpLoader.java
│       │   │               │   ├── MinidumpMemoryProvider.java
│       │   │               │   └── parser
│       │   │               │       ├── MinidumpDirectory.java
│       │   │               │       ├── MinidumpHeader.java
│       │   │               │       ├── MinidumpLocationDescriptor.java
│       │   │               │       ├── MinidumpMemory64Descriptor.java
│       │   │               │       ├── MinidumpMemory64List.java
│       │   │               │       ├── MinidumpMemoryDescriptor.java
│       │   │               │       ├── MinidumpMemoryInfo.java
│       │   │               │       ├── MinidumpMemoryInfoList.java
│       │   │               │       ├── MinidumpModule.java
│       │   │               │       ├── MinidumpModuleList.java
│       │   │               │       ├── MinidumpThread.java
│       │   │               │       ├── MinidumpThreadList.java
│       │   │               │       ├── StringReader.java
│       │   │               │       ├── ThreadInformationBlock.java
│       │   │               │       └── VsFixedFileInfo.java
│       │   │               └── plugin
│       │   │                   ├── MinidumpPluginPackage.java
│       │   │                   ├── ModuleList.java
│       │   │                   ├── ModuleListItem.java
│       │   │                   ├── ModuleListModel.java
│       │   │                   ├── ModuleViewPlugin.java
│       │   │                   ├── ModuleViewProvider.java
│       │   │                   ├── StackList.java
│       │   │                   ├── StackListItem.java
│       │   │                   ├── StackListModel.java
│       │   │                   ├── ThreadViewPlugin.java
│       │   │                   ├── ThreadViewProvider.java
│       │   │                   └── parser
│       │   │                       ├── RuntimeFunction.java
│       │   │                       ├── RuntimeInfo.java
│       │   │                       └── UnwindCode.java
│       │   └── resources
│       │       └── images
│       │           └── README.txt
│       └── test
│           └── java
│               └── README.test.txt
├── NOTICE
├── README.md
└── images
    └── readme.png

```

`LICENSE`:

```

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

```

`MinidumpLoader/build.gradle`:

```gradle
// Builds a Ghidra Extension for a given Ghidra installation.
//
// An absolute path to the Ghidra installation directory must be supplied either by setting the 
// GHIDRA_INSTALL_DIR environment variable or Gradle project property:
//
//     > export GHIDRA_INSTALL_DIR=<Absolute path to Ghidra> 
//     > gradle
//
//         or
//
//     > gradle -PGHIDRA_INSTALL_DIR=<Absolute path to Ghidra>
//
// Gradle should be invoked from the directory of the project to build.  Please see the
// application.gradle.version property in <GHIDRA_INSTALL_DIR>/Ghidra/application.properties
// for the correction version of Gradle to use for the Ghidra installation you specify.

//----------------------START "DO NOT MODIFY" SECTION------------------------------
def ghidraInstallDir

if (System.env.GHIDRA_INSTALL_DIR) {
	ghidraInstallDir = System.env.GHIDRA_INSTALL_DIR
}
else if (project.hasProperty("GHIDRA_INSTALL_DIR")) {
	ghidraInstallDir = project.getProperty("GHIDRA_INSTALL_DIR")
}

if (ghidraInstallDir) {
	apply from: new File(ghidraInstallDir).getCanonicalPath() + "/support/buildExtension.gradle"
}
else {
	throw new GradleException("GHIDRA_INSTALL_DIR is not defined!")
}
//----------------------END "DO NOT MODIFY" SECTION-------------------------------

```

`MinidumpLoader/data/README.txt`:

```txt
The "data" directory is intended to hold data files that will be used by this module and will
not end up in the .jar file, but will be present in the zip or tar file.  Typically, data
files are placed here rather than in the resources directory if the user may need to edit them.

An optional data/languages directory can exist for the purpose of containing various Sleigh language
specification files and importer opinion files.  

The data/buildLanguage.xml is used for building the contents of the data/languages directory.

The skel language definition has been commented-out within the skel.ldefs file so that the 
skeleton language does not show-up within Ghidra.

See the Sleigh language documentation (docs/languages/index.html) for details Sleigh language 
specification syntax.
 
```

`MinidumpLoader/extension.properties`:

```properties
name=@extname@
description=Tools for analyzing Windows Minidump files.
author=Mikko Rantanen
createdOn=
version=@extversion@

```

`MinidumpLoader/ghidra_scripts/README.txt`:

```txt
Java source directory to hold module-specific Ghidra scripts.

```

`MinidumpLoader/lib/README.txt`:

```txt
The "lib" directory is intended to hold Jar files which this module
is dependent upon.  This directory may be eliminated from a specific
module if no other Jar files are needed.

```

`MinidumpLoader/os/linux64/README.txt`:

```txt
The "os/linux64" directory is intended to hold Linux native binaries
which this module is dependent upon.   This directory may be eliminated for a specific 
module if native binaries are not provided for the corresponding platform.

```

`MinidumpLoader/os/osx64/README.txt`:

```txt
The "os/osx64" directory is intended to hold macOS (OS X) native binaries
which this module is dependent upon.   This directory may be eliminated for a specific 
module if native binaries are not provided for the corresponding platform.

```

`MinidumpLoader/os/win64/README.txt`:

```txt
The "os/win64" directory is intended to hold MS Windows native binaries (.exe)
which this module is dependent upon.   This directory may be eliminated for a specific 
module if native binaries are not provided for the corresponding platform.

```

`MinidumpLoader/src/main/help/help/TOC_Source.xml`:

```xml
<?xml version='1.0' encoding='ISO-8859-1' ?>
<!-- 

	This is an XML file intended to be parsed by the Ghidra help system.  It is loosely based 
	upon the JavaHelp table of contents document format.  The Ghidra help system uses a 
	TOC_Source.xml file to allow a module with help to define how its contents appear in the 
	Ghidra help viewer's table of contents.  The main document (in the Base module) 
	defines a basic structure for the 
	Ghidra table of contents system.  Other TOC_Source.xml files may use this structure to insert
	their files directly into this structure (and optionally define a substructure).
	
	
	In this document, a tag can be either a <tocdef> or a <tocref>.  The former is a definition
	of an XML item that may have a link and may contain other <tocdef> and <tocref> children.  
	<tocdef> items may be referred to in other documents by using a <tocref> tag with the 
	appropriate id attribute value.  Using these two tags allows any module to define a place 
	in the table of contents system (<tocdef>), which also provides a place for 
	other TOC_Source.xml files to insert content (<tocref>).  
	
	During the help build time, all TOC_Source.xml files will be parsed and	validated to ensure
	that all <tocref> tags point to valid <tocdef> tags.  From these files will be generated
	<module name>_TOC.xml files, which are table of contents files written in the format 
	desired by the JavaHelp system.   Additionally, the genated files will be merged together
	as they are loaded by the JavaHelp system.  In the end, when displaying help in the Ghidra
	help GUI, there will be on table of contents that has been created from the definitions in 
	all of the modules' TOC_Source.xml files.

	
	Tags and Attributes
	
	<tocdef>
	-id          - the name of the definition (this must be unique across all TOC_Source.xml files)	
	-text        - the display text of the node, as seen in the help GUI
	-target**    - the file to display when the node is clicked in the GUI
	-sortgroup   - this is a string that defines where a given node should appear under a given
	               parent.  The string values will be sorted by the JavaHelp system using
	               a javax.text.RulesBasedCollator.  If this attribute is not specified, then
	               the text of attribute will be used.

	<tocref>
	-id			 - The id of the <tocdef> that this reference points to 
	
	**The URL for the target is relative and should start with 'help/topics'.  This text is 
	used by the Ghidra help system to provide a universal starting point for all links so that
	they can be resolved at runtime, across modules.
	
	
-->


<tocroot>
	<!-- Uncomment and adjust fields to add help topic to help system's Table of Contents
	<tocref id="Ghidra Functionality">
		<tocdef id="HelpAnchor" text="My Feature" target="help/topics/my_topic/help.html" />
	</tocref>
	-->
</tocroot>

```

`MinidumpLoader/src/main/help/help/shared/Frontpage.css`:

```css
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
									WARNING!
    This file is copied to all help directories.  If you change this file, you must copy it 
    to each src/main/help/help/shared directory.									
									
	
	Java Help Note:  JavaHelp does not accept sizes (like in 'margin-top') in anything but 
	px (pixel) or with no type marking. 

*/ 

body { margin-bottom: 50px; margin-left: 10px; margin-right: 10px; margin-top: 10px; } /* some padding to improve readability */ 
li { font-family:times new roman; font-size:14pt; }
h1 { color:#000080; font-family:times new roman; font-size:36pt; font-style:italic; font-weight:bold; text-align:center; }
h2 { margin: 10px; margin-top: 20px; color:#984c4c; font-family:times new roman; font-size:18pt; font-weight:bold; }
h3 { margin-left: 10px; margin-top: 20px; color:#0000ff; font-family:times new roman; `font-size:14pt; font-weight:bold;  }
h4 { margin-left: 10px; margin-top: 20px; font-family:times new roman; font-size:14pt; font-style:italic; }
 
/*
	 P tag code.  Most of the help files nest P tags inside of blockquote tags (the was the 
	 way it had been done in the beginning).  The net effect is that the text is indented.  In 
	 modern HTML we would use CSS to do this.  We need to support the Ghidra P tags, nested in
	 blockquote tags, as well as naked P tags.  The following two lines accomplish this.  Note
	 that the 'blockquote p' definition will inherit from the first 'p' definition.
*/
p { margin-left: 40px; font-family:times new roman; font-size:14pt; }
blockquote p { margin-left: 10px; }

p.providedbyplugin { color:#7f7f7f; margin-left: 10px; font-size:14pt; margin-top:100px  }
p.ProvidedByPlugin { color:#7f7f7f; margin-left: 10px; font-size:14pt; margin-top:100px }
p.relatedtopic { color:#800080; margin-left: 10px; font-size:14pt; }
p.RelatedTopic { color:#800080; margin-left: 10px; font-size:14pt; }

/* 
	We wish for a tables to have space between it and the preceding element, so that text
	is not too close to the top of the table.  Also, nest the table a bit so that it is clear
	the table relates to the preceding text.
*/
table { margin-left: 20px; margin-top: 10px; width: 80%;}
td { font-family:times new roman; font-size:14pt; vertical-align: top; }
th { font-family:times new roman; font-size:14pt; font-weight:bold; background-color: #EDF3FE; }

/*
	Code-like formatting for things such as file system paths and proper names of classes, 
	methods, etc.  To apply this to a file path, use this syntax:
		<CODE CLASS="path">...</CODE>
*/
code { color: black; font-weight: bold; font-family: courier new, monospace; font-size: 14pt; white-space: nowrap; }
code.path { color: #4682B4; font-weight: bold; font-family: courier new, monospace; font-size: 14pt; white-space: nowrap; }

```

`MinidumpLoader/src/main/help/help/topics/minidumploader/help.html`:

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>
  <HEAD>
    <META name="generator" content=
    "HTML Tidy for Java (vers. 2009-12-01), see jtidy.sourceforge.net">
    <META http-equiv="Content-Language" content="en-us">
    <META http-equiv="Content-Type" content="text/html; charset=windows-1252">
    <META name="GENERATOR" content="Microsoft FrontPage 4.0">
    <META name="ProgId" content="FrontPage.Editor.Document">

    <TITLE>Skeleton Help File for a Module</TITLE>
    <LINK rel="stylesheet" type="text/css" href="../../shared/Frontpage.css">
  </HEAD>

  <BODY>
    <H1><a name="HelpAnchor"></a>Skeleton Help File for a Module</H1>

    <P>This is a simple skeleton help topic. For a better description of what should and should not
    go in here, see the "sample" Ghidra extension in the Extensions/Ghidra directory, or see your 
    favorite help topic. In general, language modules do not have their own help topics.</P>
  </BODY>
</HTML>

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/analyzer/FindSymbolsFileChooser.java`:

```java
package net.jubjubnest.minidump.analyzer;

import java.awt.Component;
import java.io.File;

import docking.widgets.filechooser.GhidraFileChooser;
import docking.widgets.filechooser.GhidraFileChooserMode;
import ghidra.app.util.pdb.PdbProgramAttributes;
import ghidra.util.SystemUtilities;
import ghidra.util.filechooser.ExtensionFileFilter;
import ghidra.util.task.TaskMonitor;
import ghidra.util.worker.Job;
import ghidra.util.worker.Worker;
import net.jubjubnest.minidump.analyzer.PdbResolver.PdbResult;

class FindSymbolsFileChooser extends GhidraFileChooser {
	
	private final PdbProgramAttributes pdbAttributes;
	private Worker worker = Worker.createGuiWorker();
	private boolean useModulePdbPath;

	private File rootDirectory;
	private PdbResult result;
	
	public FindSymbolsFileChooser(Component parent, PdbProgramAttributes pdbAttributes, boolean useModulePdbPath) {
		super(parent);
		this.pdbAttributes = pdbAttributes;
		this.useModulePdbPath = useModulePdbPath;

		setTitle("Locate " + pdbAttributes.getPdbFile());
		setApproveButtonText("Select PDB");
		setFileSelectionMode(GhidraFileChooserMode.FILES_ONLY);
		setFileFilter(new ExtensionFileFilter(new String[] { "pdb" }, "Program Database Files"));
	}
	
	@Override
	public void setCurrentDirectory(File directory) {
		super.setCurrentDirectory(directory);
		
		if (useModulePdbPath) {
			worker.schedule(new CheckPdbPath(directory));
		}
	}
	
	public PdbResult getValidatedResult() {
		return result;
	}
	
	public File getValidatedRoot() {
		return rootDirectory;
	}

	private class CheckPdbPath extends Job {
		
		private File currentDirectory;
		public CheckPdbPath(File currentDirectory) {
			this.currentDirectory = currentDirectory;
		}

		@Override
		public void run(TaskMonitor monitor) {
			
			PdbResult candidateResult = PdbResolver.tryFindSymbols(currentDirectory, pdbAttributes, monitor);
			if (candidateResult != null) {
				SystemUtilities.runSwingLater(() -> {
					rootDirectory = currentDirectory;
					result = candidateResult;
					setSelectedFile(result.file);
					close();
				});
			}
		}
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/analyzer/ModuleParser.java`:

```java
package net.jubjubnest.minidump.analyzer;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.ByteProvider;
import ghidra.app.util.bin.MemoryByteProvider;
import ghidra.app.util.datatype.microsoft.GuidUtil;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;

class ModuleParser {
	public static class PdbInfo {
		String guid;
		int age;
		String pdbName;
	}
	
	public static PdbInfo getPdbInfo(Program program, Address moduleBase) throws IOException {
		Address codeviewAddress = optionalHeader(program, moduleBase);
		if (codeviewAddress == null) {
			return null;
		}

		String guid = GuidUtil.getGuidString(program, codeviewAddress.add(4), false);

		ByteProvider provider = new MemoryByteProvider(program.getMemory(), moduleBase);
		BinaryReader reader = new BinaryReader(provider, true);
		
		long offset = codeviewAddress.subtract(moduleBase);
		int age = reader.readInt(offset + 0x14);
		String pdbName = reader.readAsciiString(offset + 0x18);
		
		PdbInfo info = new PdbInfo();
		info.guid = guid;
		info.age = age;
		info.pdbName = pdbName;
		return info;
	}

	private static Address optionalHeader(Program program, Address moduleBase) throws IOException {
		ByteProvider provider = new MemoryByteProvider(program.getMemory(), moduleBase);
		BinaryReader reader = new BinaryReader(provider, true);
		
		// Validate magic bytes at the start of the PE image.
		if (!reader.readAsciiString(0, 2).equals("MZ")) {
			return null;
		}

		// Validate magic bytes at the start of the PE portion of the image.
		int peOffset = reader.readInt(0x3C);
		if (!reader.readAsciiString(peOffset, 4).equals("PE")) {
			return null;
		}
		
		int optOffset = peOffset + 0x18;
		if (reader.readShort(optOffset) != 0x020b) {
			return null;
		}

		int directoryCount = reader.readInt(optOffset + 0x6c);
		if (directoryCount < 7) {
			return null;
		}
		
		int debugStart = optOffset + 0x70 + 8 * 6;
		reader.setPointerIndex(debugStart);
		int debugRva = reader.readNextInt();
		int debugSize = reader.readNextInt();
		
		int codeviewAddress = 0;
		for (int debugCursor = debugRva; debugCursor < debugRva + debugSize; debugCursor += 0x1C) {
			int type = reader.readInt(debugCursor + 0xC);
			if (type != 2) {
				continue;
			}

			codeviewAddress = reader.readInt(debugCursor + 0x14);
			break;
		}
		
		if (codeviewAddress == 0) {
			return null;
		}
		
		return moduleBase.add(codeviewAddress);
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/analyzer/ModulePdbAnalyzer.java`:

```java
package net.jubjubnest.minidump.analyzer;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import ghidra.app.services.AbstractAnalyzer;
import ghidra.app.services.AnalysisPriority;
import ghidra.app.services.AnalyzerType;
import ghidra.app.util.bin.format.pdb2.pdbreader.PdbException;
import ghidra.app.util.bin.format.pdb2.pdbreader.PdbReaderOptions;
import ghidra.app.util.importer.MessageLog;
import ghidra.app.util.pdb.PdbLocator;
import ghidra.app.util.pdb.PdbProgramAttributes;
import ghidra.app.util.pdb.pdbapplicator.PdbApplicator;
import ghidra.app.util.pdb.pdbapplicator.PdbApplicatorOptions;
import ghidra.framework.options.OptionType;
import ghidra.framework.options.Options;
import ghidra.program.model.address.AddressSetView;
import ghidra.program.model.listing.Program;
import ghidra.util.SystemUtilities;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.TaskMonitor;
import net.jubjubnest.minidump.data.ModuleData;
import net.jubjubnest.minidump.loader.MinidumpLoader;

public class ModulePdbAnalyzer extends AbstractAnalyzer {
	
	public final static String NAME = "Module PDB Loader";
	public final static String DESCRIPTION = "Attempts to locate and apply PDBs for individual modules in a Minidump.";
	static final boolean DEFAULT_ENABLEMENT = true;
	
	private static final String INTERACTIVE_OPTION_NAME = "Interactive";
	private static final String INTERACTIVE_OPTION_DESCRIPTION = "Confirm missing symbols using an interactive dialog.";
	
	private static final String SYMBOLPATH_OPTION_NAME = "Symbol Server";
	private static final String SYMBOLPATH_OPTION_DESCRIPTION = "Symbol path in the symbol server format: srv*..*...";
	
	private static final String USEPDBPATH_OPTION_NAME = "Unsafe: Use PDB path from modules";
	private static final String USEPDBPATH_OPTION_DESCRIPTION = "Use the PDB path embedded in the modules when searching PDB files.";

	PdbReaderOptions pdbReaderOptions = new PdbReaderOptions();
	PdbApplicatorOptions pdbApplicatorOptions = new PdbApplicatorOptions();
	long lastTransactionId = -1;
	
	String symbolPath;
	boolean isInteractive;
	boolean useModulePdbPath;

	public ModulePdbAnalyzer() {
		super(NAME, DESCRIPTION, AnalyzerType.BYTE_ANALYZER);
		setDefaultEnablement(DEFAULT_ENABLEMENT);
		setPriority(AnalysisPriority.FORMAT_ANALYSIS.after());
		setSupportsOneTimeAnalysis();
	}
	
	static boolean isEnabled(Program program) {
		Options analysisOptions = program.getOptions(Program.ANALYSIS_PROPERTIES);
		return analysisOptions.getBoolean(NAME, DEFAULT_ENABLEMENT);
	}
	
	@Override
	public boolean added(Program program, AddressSetView set, TaskMonitor monitor, MessageLog log)
			throws CancelledException {
		
		// Avoid repeating for the same transaction.
		long txId = program.getCurrentTransaction().getID();
		if (txId == lastTransactionId) {
			return false;
		}
		lastTransactionId = txId;
		
		List<SymbolInfo> symbols = new ArrayList<>();
		boolean missingSymbols = false;
		for (ModuleData md : ModuleData.getAllModules(program) ) {
			if (md.loadedSymbols != null) {
				continue;
			}

			monitor.setMessage(md.name + ": Locating PDB...");
			SymbolInfo info = locateModulePdb(program, md, log, monitor);
			if (info != null) {
				missingSymbols = missingSymbols || (info.result == null);
				symbols.add(info);
			}
		}
		
		// If we're not in a headless mode, ask the user for input if there are missing symbols.
		if (isInteractive && !SystemUtilities.isInHeadlessMode() && missingSymbols) {
			monitor.setMessage("Waiting for user confirmation...");
			SymbolLocationDialog locationDialog = new SymbolLocationDialog(symbols, useModulePdbPath);
			if (!locationDialog.confirm()) {
				return false;
			}
		}
		
		for (SymbolInfo info : symbols) {
			if (info.result == null) {
				continue;
			}

			monitor.setMessage(info.module.name + ": Loading PDB...");
			loadModulePdb(program, info.module, info.result, log, monitor);
		}
		
		return true;
	}
	
	public SymbolInfo locateModulePdb(Program program, ModuleData md, MessageLog log, TaskMonitor monitor) throws CancelledException {
		PdbProgramAttributes pdbAttributes;
		try {
			pdbAttributes = PdbResolver.getAttributes(program, md.baseAddress);
			if (pdbAttributes == null) {
				return null;
			}
		} catch (IOException e) {
			log.appendMsg(getName(), "Exception parsing PDB information from the module: " + md.name);
			log.appendException(e);
			return null;
		}
		
		SymbolInfo info = new SymbolInfo(md, pdbAttributes, null);

		// Attempt to locate the PDB via non-interactive means.
		try {
			info.result = PdbResolver.locatePdb(pdbAttributes, symbolPath, useModulePdbPath, monitor);
		} catch (IOException | PdbException e) {
			log.appendMsg(getName(), "Error locating PDB for " + md.name);
			log.appendException(e);
		}
		
		return info;
	}
	
	public void loadModulePdb(Program program, ModuleData md, PdbResolver.PdbResult pdbResult, MessageLog log, TaskMonitor monitor) throws CancelledException {

		try {

			String pdbName = pdbResult.file.getName();

			SubTaskMonitor subMonitor = new SubTaskMonitor(pdbName, "Parsing...", monitor);
			pdbResult.pdb.deserialize(subMonitor);

			subMonitor = new SubTaskMonitor(pdbName, "Applying...", monitor);
			subMonitor.addReplaceRule("^PDB: ", "");
			PdbApplicator applicator = new PdbApplicator(pdbResult.file.getAbsolutePath(), pdbResult.pdb);
			applicator.applyTo(program, null, md.baseAddress, null, subMonitor, new MessageLog());

			monitor.setMessage(pdbName + ": Committing...");
			ModuleData moduleData = ModuleData.getModuleData(program, md.baseAddress);
			moduleData.loadedSymbols = pdbResult.file.getAbsolutePath();
			ModuleData.setModuleData(program, moduleData);

		} catch (IOException | PdbException e) {
			log.appendMsg(getName(), "Error applying PDB " + pdbResult.file.getName());
			log.appendException(e);
		}
	}

	@Override
	public boolean canAnalyze(Program program) {
		String executableFormat = program.getExecutableFormat();
		return executableFormat != null && executableFormat.equals(MinidumpLoader.NAME);
	}
	
	@Override
	public void registerOptions(Options options, Program program) {
		symbolPath = System.getenv("_NT_SYMBOL_PATH");
		if (symbolPath == null || symbolPath.isEmpty()) {
			symbolPath = "srv*~/symbolcache*https://msdl.microsoft.com/download/symbols";
		}

		options.registerOption(SYMBOLPATH_OPTION_NAME,
				symbolPath,
				null,
				SYMBOLPATH_OPTION_DESCRIPTION);

		isInteractive = true;
		options.registerOption(INTERACTIVE_OPTION_NAME,
				OptionType.BOOLEAN_TYPE,
				isInteractive,
				null,
				INTERACTIVE_OPTION_DESCRIPTION);

		useModulePdbPath = false;
		options.registerOption(USEPDBPATH_OPTION_NAME,
				OptionType.BOOLEAN_TYPE,
				useModulePdbPath,
				null,
				USEPDBPATH_OPTION_NAME);
	}
	
	@Override
	public void optionsChanged(Options options, Program program) {
		symbolPath = options.getString(SYMBOLPATH_OPTION_NAME, symbolPath);
		isInteractive = options.getBoolean(INTERACTIVE_OPTION_NAME, isInteractive);
		useModulePdbPath = options.getBoolean(USEPDBPATH_OPTION_NAME, useModulePdbPath);
	}
}
```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/analyzer/PdbResolver.java`:

```java
package net.jubjubnest.minidump.analyzer;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import ghidra.app.util.bin.format.pdb2.pdbreader.AbstractPdb;
import ghidra.app.util.bin.format.pdb2.pdbreader.PdbException;
import ghidra.app.util.bin.format.pdb2.pdbreader.PdbParser;
import ghidra.app.util.bin.format.pdb2.pdbreader.PdbReaderOptions;
import ghidra.app.util.pdb.PdbProgramAttributes;
import ghidra.net.http.HttpUtil;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidra.util.exception.CancelledException;
import ghidra.util.exception.NotYetImplementedException;
import ghidra.util.task.TaskMonitor;

class PdbResolver {

	public static PdbProgramAttributes getAttributes(Program program, Address moduleBase) throws IOException {

		boolean analyzed = program.getOptions(Program.PROGRAM_INFO).getBoolean(Program.ANALYZED, false);
		ModuleParser.PdbInfo pdbInfo = ModuleParser.getPdbInfo(program, moduleBase);
		if (pdbInfo == null) {
			return null;
		}

		PdbProgramAttributes pdbAttributes = new PdbProgramAttributes(
				pdbInfo.guid, Integer.toString(pdbInfo.age),
				false, analyzed, null, pdbInfo.pdbName, "RSDS");

		return pdbAttributes;
	}

	public static class PdbResult {
		public PdbResult(File file, AbstractPdb pdb) {
			this.file = file;
			this.pdb = pdb;
		}

		public File file;
		public AbstractPdb pdb;
	}

	public static PdbResult locatePdb(PdbProgramAttributes pdbAttributes, String symbolServer, boolean useModulePdbPath, TaskMonitor monitor)
			throws IOException, CancelledException, PdbException {

		if (symbolServer == null || symbolServer.isEmpty()) {
			return null;
		}

		if (useModulePdbPath && pdbAttributes.getPdbFile() != null) {
			File candidate = new File(pdbAttributes.getPdbFile());
			PdbResult result = validatePdbCandidate(candidate, true, pdbAttributes, monitor);
			if (result != null) {
				return result;
			}
		}
		
		PdbResolver.SymbolPath symbolPath = PdbResolver.parseSymbolPath(symbolServer);
		File symbolServerMatch = PdbResolver.loadSymbols(symbolPath, pdbAttributes);
		if (symbolServerMatch != null) {
			return new PdbResult(
				symbolServerMatch, 
				PdbParser.parse(symbolServerMatch.getAbsolutePath(), new PdbReaderOptions(), monitor)
			);
		}

		return null;
	}

	public static PdbResult validatePdbCandidate(File candidate, boolean verifyGuidAge, PdbProgramAttributes pdbAttributes, TaskMonitor monitor) throws CancelledException, IOException, PdbException {

		if (candidate == null || !candidate.exists()) {
			return null;
		}

		AbstractPdb pdb = PdbParser.parse(candidate.getAbsolutePath(), new PdbReaderOptions(), monitor);
		if (verifyGuidAge) {
			if (!pdbAttributes.getPdbGuid().equals(pdb.getGuid().toString())) {
				throw new PdbException("PDB GUID mismatch");
			}

			if (!pdbAttributes.getPdbAge().equals(Integer.toHexString(pdb.getAge()))) {
				throw new PdbException("PDB age mismatch");
			}
		}
		
		return new PdbResult(candidate, pdb);
	}
	
	public static class SymbolServerResult {
		File file;
		String path;
	}
	
	public static File loadSymbols(SymbolPath path, PdbProgramAttributes pdbAttributes) throws IOException {

		for (SymbolPathItem item : path.items) {
			switch (item.type) { 
			case SymbolServer:
				String[] servers = item.path.split("\\*");
				return loadSymbolsFromSymbolServers(servers, pdbAttributes);
			default:
				throw new NotYetImplementedException();
			}
		}
		
		return null;
	}
	
	public static PdbResult tryFindSymbols(File root, PdbProgramAttributes pdbAttributes, TaskMonitor monitor) {

		String candidate = pdbAttributes.getPdbFile().replace('\\', '/');
		for (int nextDir = candidate.indexOf('/'); monitor.isCancelled() == false && nextDir != -1; nextDir = candidate.indexOf('/')) {
			candidate = candidate.substring(nextDir + 1);
			Path p = root.toPath().resolve(candidate);
			if (!Files.exists(p)) {
				continue;
			}
			
			try {
				PdbResult candidateResult = PdbResolver.validatePdbCandidate(p.toFile(), true, pdbAttributes, monitor);
				if (candidateResult == null) {
					continue;
				}

				return candidateResult;
			} catch (CancelledException | IOException | PdbException e) {
				// Ignore the candidate on errors.
				continue;
			}
		}
		
		return null;
	}

	private static File loadSymbolsFromSymbolServers(String[] servers, PdbProgramAttributes pdbAttributes) throws IOException {
		List<String> cascadeServers = new ArrayList<>();
		SymbolServerResult result = null;
		String tempPath = null;
		for (String server : servers) {

			// Support home directories.
			server = server.replaceFirst("^~\\B", Matcher.quoteReplacement(System.getProperty("user.home")));

			result = loadSymbolsFromSymbolServer(server, tempPath, pdbAttributes);

			if (result != null) break;
			cascadeServers.add(server);

			// Use the previous physical server as the temp path to avoid having to make a temporary copy of possible downloads.
			// We'll end up extracting the files anyway later.
			if (!server.startsWith("http:") && !server.startsWith("https:")) {
				tempPath = server;
			}
		}
		
		if (result == null) {
			return null;
		}
		
		for (String cascade : cascadeServers) {
			Path cascadedFile = Paths.get(cascade, result.path);
			if (!Files.exists(cascadedFile)) {
				Files.createDirectories(cascadedFile.getParent());
				Files.copy(result.file.toPath(), cascadedFile);
				result.file = cascadedFile.toFile();
			}
		}
		
		return result.file;
	}

	private static SymbolServerResult loadSymbolsFromSymbolServer(String server, String tempPath, PdbProgramAttributes pdbAttributes) throws IOException {

		for (String candidate : pdbAttributes.getPotentialPdbFilenames()) {
			return loadSymbolsFromSymbolServerForCandidate(server, candidate, tempPath, pdbAttributes);
		}
		
		return null;
	}
	
	private static SymbolServerResult loadSymbolsFromSymbolServerForCandidate(String server, String candidate, String tempPath, PdbProgramAttributes pdbAttributes) throws IOException {

		if (!server.endsWith("/")) {
			server += "/";
		}
		String path = candidate + "/" + pdbAttributes.getGuidAgeCombo() + "/" + candidate;
		
		if (server.startsWith("http:") || server.startsWith("https:")) {
			return downloadFile(server, path, tempPath);
		}

		File file = new File(server, path);
		if (file.exists()) {
			SymbolServerResult result = new SymbolServerResult();
			result.file = file;
			result.path = path;
			return result;
		}
		
		return null;
	}
	
	private static SymbolServerResult downloadFile(String server, String path, String target) throws IOException {
		if (target == null) {
			File tmp = File.createTempFile("symbol", "pdb");
			tmp.delete();
			tmp.mkdirs();
			target = tmp.getAbsolutePath() + "/";
		}
		
		File targetFile = new File(target, path);
		targetFile.getParentFile().mkdirs();

		String url = server + path;
		try {
			HttpUtil.getFile(url, null, true, targetFile);
		} catch (IOException e) {
			return null;
		}
		
		if (targetFile.exists()) {
			SymbolServerResult result = new SymbolServerResult();
			result.file = targetFile;
			result.path = path;
			return result;
		}
		return null;
	}
	
	public static SymbolPath parseSymbolPath(String path) {

		String currentCache = null;
		List<SymbolPathItem> items = new ArrayList<>();
		for (String segment : path.split(";")) {
			if (segment.toLowerCase().startsWith("cache*")) {
				currentCache = segment.substring("cache*".length());
				continue;
			}
			
			items.add(parseSegment(segment, currentCache));
		}
		
		return new SymbolPath(items);
	}
	
	private static SymbolPathItem parseSegment(String segment, String globalCache) {

		SymbolPathType type = SymbolPathType.Directory;
		if (segment.toLowerCase().startsWith("srv*")) {
			type = SymbolPathType.SymbolServer;
			segment = segment.substring("srv*".length());
		}
		
		SymbolPathItem item = new SymbolPathItem();
		item.path = segment;
		item.type = type;
		item.cache = globalCache;
		return item;
	}
	
	static class SymbolPath {
		public SymbolPath(List<SymbolPathItem> items) {
			this.items = items;
		}

		public List<SymbolPathItem> items;
	}
	
	static class SymbolPathItem {
		public String path;
		public SymbolPathType type;
		public String cache;
	}
	
	enum SymbolPathType { SymbolServer, Directory }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/analyzer/SubTaskMonitor.java`:

```java
package net.jubjubnest.minidump.analyzer;

import java.util.ArrayList;
import java.util.List;

import ghidra.util.task.TaskMonitor;
import ghidra.util.task.WrappingTaskMonitor;

class SubTaskMonitor extends WrappingTaskMonitor {
	
	private String title;
	private String message;
	
	private List<RegexRule> replaceRules = new ArrayList<>();
	
	static class RegexRule {
		public RegexRule(String pattern, String replace) {
			this.pattern = pattern;
			this.replace = replace;
		}

		public String pattern;
		public String replace;
	}

	public SubTaskMonitor(String title, TaskMonitor delegate) {
		this(title, null, delegate);
	}

	public SubTaskMonitor(String title, String message, TaskMonitor delegate) {
		super(delegate);
		this.title = title;
		this.message = message;
		updateMessage();
	}
	
	public void addReplaceRule(String pattern, String replace) {
		this.replaceRules.add(new RegexRule(pattern, replace));
	}

	public void setMessage(String message) {
		this.message = message;
		updateMessage();
	}
	
	@Override
	public String getMessage() {
		return message;
	}
	
	private void updateMessage() {
		StringBuilder builder = new StringBuilder(this.title);
		if (message != null) {
			String replacedMessage = message;
			for (RegexRule rule : replaceRules) {
				replacedMessage = replacedMessage.replaceAll(rule.pattern, rule.replace);
			}
			builder.append(": ").append(replacedMessage);
		} else {
			builder.append("...");
		}
		
		super.setMessage(builder.toString());
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/analyzer/SymbolInfo.java`:

```java
package net.jubjubnest.minidump.analyzer;

import ghidra.app.util.pdb.PdbProgramAttributes;
import net.jubjubnest.minidump.analyzer.PdbResolver.PdbResult;
import net.jubjubnest.minidump.data.ModuleData;

class SymbolInfo {

	SymbolInfo(ModuleData m, PdbProgramAttributes attributes, PdbResult result) {
		if (m == null || attributes == null) {
			throw new IllegalArgumentException();
		}

		module = m;
		this.attributes = attributes;
		if (result != null) {
			this.result = result;
		}
	}

	ModuleData module;
	PdbProgramAttributes attributes;
	PdbResult result;
	String message;
}
```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/analyzer/SymbolLocationDialog.java`:

```java
package net.jubjubnest.minidump.analyzer;

import java.awt.BorderLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import javax.swing.BorderFactory;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;

import docking.DialogComponentProvider;
import docking.DockingWindowManager;
import docking.widgets.table.AbstractGTableModel;
import docking.widgets.table.GTable;
import ghidra.app.util.bin.format.pdb2.pdbreader.PdbException;
import ghidra.util.exception.CancelledException;
import ghidra.util.exception.NotYetImplementedException;
import ghidra.util.task.Task;
import ghidra.util.task.TaskMonitor;
import ghidra.util.worker.Job;
import ghidra.util.worker.Worker;

class SymbolLocationDialog extends DialogComponentProvider {
	
	GTable table;
	List<SymbolInfo> allRows;
	List<SymbolInfo> incompleteRows = new ArrayList<>();
	boolean useModulePdbPath;
	
	boolean wasCancelled;
	Worker worker = Worker.createGuiWorker();
	
	static final String[] COLUMN_NAMES = new String[] {
		"Module", "Symbols"
	};

	public SymbolLocationDialog(List<SymbolInfo> symbols, boolean useModulePdbPath) {
		super("Confirm Symbols", true, false, true, true);
		setPreferredSize(600, 300);

		this.useModulePdbPath = useModulePdbPath;
		allRows = symbols;
		for (SymbolInfo info : symbols) {
			if (info.result == null) {
				incompleteRows.add(info);
			}
		}
		
		table = new GTable(new AbstractGTableModel<SymbolInfo>() {

			@Override
			public String getName() {
				return "Symbols";
			}
			
			@Override
			public String getColumnName(int column) {
				return COLUMN_NAMES[column];
			}

			@Override
			public List<SymbolInfo> getModelData() {
				return incompleteRows;
			}

			@Override
			public Object getColumnValueForRow(SymbolInfo row, int columnIndex) {
				switch (columnIndex) {
					case 0:
						return row.module.name;
					case 1:
						if (row.result != null) {
							return row.result.file.getAbsolutePath();
						}
						if (row.message != null) {
							return row.message;
						}
						return "Double-click to specify symbols";
					default:
						throw new NotYetImplementedException();
				}
			}

			@Override
			public int getColumnCount() {
				return 2;
			}
		});
		table.getColumnModel().getColumn(0).setPreferredWidth(75);
		table.getColumnModel().getColumn(1).setPreferredWidth(175);

		table.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				if (e.getClickCount() == 2) {
					changeSymbols(table.getSelectedRow());
				}
			}
		});
		
		JLabel label = new JLabel("No symbols were found for the following modules:");
		label.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

		JPanel panel = new JPanel(new BorderLayout(10, 10));
		panel.add(label, BorderLayout.NORTH);
		panel.add(new JScrollPane(table));

		this.addWorkPanel(panel);
		this.addOKButton();
		this.addCancelButton();
	}
	
	public void changeSymbols(int idx) {
		SymbolInfo row = this.incompleteRows.get(idx);

		FindSymbolsFileChooser pdbChooser = new FindSymbolsFileChooser(null, row.attributes, useModulePdbPath);
		
		if (useModulePdbPath && row.attributes != null) {
			pdbChooser.setCurrentDirectory(new File(row.attributes.getPdbFile()));
		}

		File pdbFile = pdbChooser.getSelectedFile();
		if (pdbChooser.getValidatedResult() != null) {
			row.result = pdbChooser.getValidatedResult();
			worker.schedule(new TryFindMissingSymbols(pdbChooser.getValidatedRoot()));
			return;
		}
		
		if (pdbFile == null) {
			return;
		}

		executeProgressTask(new Task("Processing PDB") {
			@Override
			public void run(TaskMonitor monitor) throws CancelledException {
				try {
					row.result = PdbResolver.validatePdbCandidate(pdbFile, true, row.attributes, monitor);
				} catch (IOException | PdbException e) {
					row.message = "Error: " + e.getMessage() + " (" + pdbFile.getPath() + ")";
				}
				table.repaint();
			}
		}, 0);
	}
	
	class TryFindMissingSymbols extends Job {
		
		private File root;
		public TryFindMissingSymbols(File root) {
			this.root = root;
		}

		@Override
		public void run(TaskMonitor monitor) throws CancelledException {
			for (SymbolInfo row : incompleteRows) {
				if (row.result != null) {
					continue;
				}

				row.result = PdbResolver.tryFindSymbols(root, row.attributes, monitor);
				table.repaint();
			}
		}
	}
	
	@Override
	protected void cancelCallback() {
		wasCancelled = true;
		super.cancelCallback();
	}
	
	@Override
	protected void okCallback() {
		super.okCallback();
		close();
	}

	public boolean confirm() {
		DockingWindowManager.showDialog(null, this);
		return !wasCancelled;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/new_/AbstractModuleBaseOffsetDataType.java`:

```java
package net.jubjubnest.minidump.contrib.new_;

import ghidra.docking.settings.Settings;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressOutOfBoundsException;
import ghidra.program.model.data.BuiltIn;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.mem.MemBuffer;
import ghidra.program.model.scalar.Scalar;

abstract class AbstractModuleBaseOffsetDataType extends BuiltIn {
	
	public AbstractModuleBaseOffsetDataType(CategoryPath path, String name, DataTypeManager dtm) {
		super(path, name, dtm);
	}
	
	abstract DataType getScalarDataType();
	
	static String generateName(DataType dt) {
		return "ModuleBaseOffset" + dt.getLength() * 8;
	}
	
	static String generateMnemonic(DataType dt) {
		return "mbo" + dt.getLength() * 8;
	}
	
	static String generateDescription(DataType dt) {
		return (dt.getLength() * 8) + "-bit Module Base Offset";
	}
	
	@Override
	public String getDescription() {
		DataType dt = getScalarDataType();
		return generateDescription(dt);
	}
	
	@Override
	public String getMnemonic(Settings settings) {
		DataType dt = getScalarDataType();
		return generateMnemonic(dt);
	}

	@Override
	public int getLength() {
		return getScalarDataType().getLength();
	}
	
	@Override
	public boolean hasLanguageDependantLength() {
		return false;
	}
	
	@Override
	public String getRepresentation(MemBuffer buf, Settings settings, int length) {
		Address addr = (Address) getValue(buf, settings, length);
		if (addr == null)
			return "NaP";
		return addr.toString();
	}

	@Override
	public Object getValue(MemBuffer buf, Settings settings, int length) {
		Address moduleBase = ModuleBaseMap.getModuleBase(buf.getMemory().getProgram(), buf.getAddress());
		if (moduleBase == null) {
			return null;
		}
		
		Scalar value = (Scalar) getScalarDataType().getValue(buf, settings, length);
		if (value == null || value.getUnsignedValue() == 0) {
			return null;
		}
		
		try {
			return moduleBase.add(value.getUnsignedValue());
		} catch (AddressOutOfBoundsException e) {
			return null;
		}
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/new_/ImageLoadInfo.java`:

```java
package net.jubjubnest.minidump.contrib.new_;

import ghidra.framework.options.Options;
import ghidra.program.model.listing.Program;
import net.jubjubnest.minidump.contrib.pe.PortableExecutable.SectionLayout;

public class ImageLoadInfo {
	public String imageName;
	public long imageBase;
	public boolean sharedProgram;
	public SectionLayout sectionLayout;
	
	public ImageLoadInfo() {
		imageName = null;
		imageBase = 0;
		sharedProgram = false;
		sectionLayout = SectionLayout.FILE;
	}
	
	public ImageLoadInfo(String moduleName, long moduleOffset) {
		imageName = moduleName;
		imageBase = moduleOffset;
		sharedProgram = true;
		sectionLayout = SectionLayout.MEMORY;
	}
	
	public String prefixName(String name) {
		return name;
		
		/*
		if (sharedProgram == false)
			return name;
		return imageName.toUpperCase() + "::" + name;
		*/
	}
	
	public Options getModuleOptions(Program program) {
		Options programOptions = program.getOptions(Program.PROGRAM_INFO);
		if (sharedProgram == false) {
			return programOptions;
		}
		
		Options moduleOptions = programOptions.getOptions("Module Information");
		return moduleOptions.getOptions(imageName.replace('.', '_'));
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/new_/ModuleBaseMap.java`:

```java
package net.jubjubnest.minidump.contrib.new_;

import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressIterator;
import ghidra.program.model.listing.Program;
import ghidra.program.model.util.IntPropertyMap;
import ghidra.program.model.util.PropertyMapManager;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.exception.NoValueException;

public class ModuleBaseMap {

	static final String MODULE_LIMITS_MAP_NAME = "MODULEBASEOFFSET_MODULE_LIMITS";
	static final int MODULE_START = 1;
	static final int MODULE_END = 0;
	
	public static void markModule(Program program, Address start, Address end) {
		PropertyMapManager manager = program.getUsrPropertyManager();

		IntPropertyMap map = manager.getIntPropertyMap(MODULE_LIMITS_MAP_NAME);
		if (map == null) {
			try {
				map = manager.createIntPropertyMap(MODULE_LIMITS_MAP_NAME);
			} catch (DuplicateNameException e) {
				map = manager.getIntPropertyMap(MODULE_LIMITS_MAP_NAME);
			}
		}
		
		map.add(start, MODULE_START);
		map.add(end, MODULE_END);
	}
	
	public static Address getModuleBase(Program program, Address addr) {
		PropertyMapManager manager = program.getUsrPropertyManager();

		IntPropertyMap map = manager.getIntPropertyMap(MODULE_LIMITS_MAP_NAME);
		if (map == null) {
			return null;
		}

		AddressIterator iter = map.getPropertyIterator(addr, false);
		Address closest = iter.next();

		int flag;
		try {
			flag = map.getInt(closest);
		} catch (NoValueException e) {
			// The address used in lookup should have value according to the map.
			throw new RuntimeException(e);
		}
		
		// If the previous record is start of module we'll return that.
		if (flag == MODULE_START) {
			return closest;
		}

		// No start of module record found.
		
		// There's a chance the user queried the exact end-of-module address, which is still
		// inclusive to the current module. If this happened, we'll continue iterating backwards
		// to acquire the start-of-module address.
		if (closest.equals(addr)) {
			return iter.next();
		}

		return null;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/new_/ModuleBaseOffset32DataType.java`:

```java
package net.jubjubnest.minidump.contrib.new_;

import ghidra.program.model.data.DWordDataType;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;

public class ModuleBaseOffset32DataType extends AbstractModuleBaseOffsetDataType {
	
	private static DataType datatype = DWordDataType.dataType;
	public ModuleBaseOffset32DataType() {
		this(null);
	}
	
	public ModuleBaseOffset32DataType(DataTypeManager dtm) {
		super(null, generateName(datatype), dtm);
	}

	@Override
	DataType getScalarDataType() {
		return datatype;
	}

	@Override
	public DataType clone(DataTypeManager dtm) {
		if (dtm == getDataTypeManager()) {
			return this;
		}
		
		return new ModuleBaseOffset32DataType(dtm);
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/new_/ModuleBaseOffset64DataType.java`:

```java
package net.jubjubnest.minidump.contrib.new_;

import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.QWordDataType;

public class ModuleBaseOffset64DataType extends AbstractModuleBaseOffsetDataType {
	
	private static DataType datatype = QWordDataType.dataType;
	public ModuleBaseOffset64DataType() {
		this(null);
	}
	
	public ModuleBaseOffset64DataType(DataTypeManager dtm) {
		super(null, generateName(datatype), dtm);
	}

	@Override
	DataType getScalarDataType() {
		return datatype;
	}

	@Override
	public DataType clone(DataTypeManager dtm) {
		if (dtm == getDataTypeManager()) {
			return this;
		}
		
		return new ModuleBaseOffset64DataType(dtm);
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/opinion/AbstractPeDebugLoader.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.opinion;
import ghidra.app.util.opinion.*;

import java.util.*;

import ghidra.app.util.bin.format.pdb.*;
import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;
import net.jubjubnest.minidump.contrib.pe.FileHeader;
import net.jubjubnest.minidump.contrib.pe.SectionHeader;
import net.jubjubnest.minidump.contrib.pe.debug.*;
import ghidra.app.util.datatype.microsoft.GUID;
import ghidra.app.util.demangler.DemangledObject;
import ghidra.app.util.demangler.DemanglerUtil;
import ghidra.framework.options.Options;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DWordDataType;
import ghidra.program.model.data.StringDataType;
import ghidra.program.model.listing.*;
import ghidra.program.model.symbol.*;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.Conv;
import ghidra.util.Msg;
import ghidra.util.exception.InvalidInputException;
import ghidra.util.task.TaskMonitor;

abstract class AbstractPeDebugLoader extends AbstractLibrarySupportLoader {
	private HashMap<Address, StringBuffer> plateCommentMap = new HashMap<>();
	private HashMap<Address, StringBuffer> preCommentMap = new HashMap<>();
	private HashMap<Address, StringBuffer> postCommentMap = new HashMap<>();
	private HashMap<Address, StringBuffer> eolCommentMap = new HashMap<>();
	protected ImageLoadInfo loadInfo;
	
	protected AbstractPeDebugLoader(ImageLoadInfo loadInfo) {
		this.loadInfo = loadInfo;
	}

	protected void processComments(Listing listing, TaskMonitor monitor) {
		List<HashMap<Address, StringBuffer>> maps = new ArrayList<>();
		maps.add(plateCommentMap);
		maps.add(preCommentMap);
		maps.add(postCommentMap);
		maps.add(eolCommentMap);

		int[] types = new int[] { CodeUnit.PLATE_COMMENT, CodeUnit.PRE_COMMENT,
			CodeUnit.POST_COMMENT, CodeUnit.EOL_COMMENT };
		String[] typeNames = new String[] { "PLATE", "PRE", "POST", "EOL" };
		int index = 0;
		for (HashMap<Address, StringBuffer> map : maps) {
			List<Address> list = convertSetToSortedList(map.keySet());
			for (Address addr : list) {
				if (monitor.isCancelled()) {
					break;
				}
				monitor.setMessage("Setting " + typeNames[index] + " comments at " + addr);
				StringBuffer buffer = map.get(addr);
				if (buffer != null) {
					listing.setComment(addr, types[index], buffer.toString());
				}
			}
			if (monitor.isCancelled()) {
				break;
			}
			++index;
		}
		for (HashMap<Address, StringBuffer> map : maps) {
			map.clear();
		}
	}

	private List<Address> convertSetToSortedList(Set<Address> set) {
		List<Address> list = new ArrayList<>(set);
		Collections.sort(list);
		return list;
	}

	protected void processDebug(DebugDirectoryParser parser, FileHeader fileHeader,
			Map<SectionHeader, Address> sectionToAddress, Program program, TaskMonitor monitor) {

		if (parser == null) {
			return;
		}

		monitor.setMessage("Processing misc debug...");
		processDebugMisc(program, parser.getDebugMisc());

		monitor.setMessage("Processing fixup debug...");
		processDebugFixup(parser.getDebugFixup());

		monitor.setMessage("Processing code view debug...");
		processDebugCodeView(parser.getDebugCodeView(), fileHeader, sectionToAddress, program,
			monitor);

		monitor.setMessage("Processing coff debug...");
		processDebugCOFF(parser.getDebugCOFFSymbolsHeader(), fileHeader, sectionToAddress, program,
			monitor);
	}

	private void processDebugCodeView(DebugCodeView dcv, FileHeader fileHeader,
			Map<SectionHeader, Address> sectionToAddress, Program program, TaskMonitor monitor) {

		if (dcv == null) {
			return;
		}

		Options proplist = program.getOptions(Program.PROGRAM_INFO);

		PdbInfoCodeView cvPdbInfo = dcv.getPdbInfo();
		if (cvPdbInfo != null) {
			cvPdbInfo.serializeToOptions(proplist);
		}

		PdbInfoDotNet dotnetPdbInfo = dcv.getDotNetPdbInfo();
		if (dotnetPdbInfo != null) {
			dotnetPdbInfo.serializeToOptions(proplist);
		}

		DebugCodeViewSymbolTable dcvst = dcv.getSymbolTable();
		if (dcvst == null) {
			return;
		}

		List<OMFSrcModule> srcModules = dcvst.getOMFSrcModules();
		for (OMFSrcModule module : srcModules) {
			short[] segs = module.getSegments();
			int segIndex = 0;

			OMFSrcModuleFile[] files = module.getOMFSrcModuleFiles();
			for (OMFSrcModuleFile file : files) {
				processFiles(file, segs[segIndex++], fileHeader, sectionToAddress, monitor);
				processLineNumbers(fileHeader, sectionToAddress, file.getOMFSrcModuleLines(),
					monitor);

				if (monitor.isCancelled()) {
					return;
				}
			}
			if (monitor.isCancelled()) {
				return;
			}
		}

		/*TODO
		List<OMFSegMap> segMaps = dcvst.getOMFSegMaps();
		for (OMFSegMap map : segMaps) {
			if (monitor.isCancelled()) return;
		}
		*/

		/*TODO
		List<OMFModule> modules = dcvst.getOMFModules();
		for (OMFModule module : modules) {
			OMFSegDesc [] descs = module.getOMFSegDescs();
			for (OMFSegDesc desc : descs) {
				if (monitor.isCancelled()) return;
			}
			if (monitor.isCancelled()) return;
		}
		*/

		SymbolTable symTable = program.getSymbolTable();

		int errorCount = 0;
		List<OMFGlobal> globals = dcvst.getOMFGlobals();
		for (OMFGlobal global : globals) {
			List<DebugSymbol> symbols = global.getSymbols();
			for (DebugSymbol symbol : symbols) {
				if (monitor.isCancelled()) {
					return;
				}

				String name = symbol.getName();
				if (name == null) {
					continue;
				}

				short segVal = symbol.getSection();
				int offVal = symbol.getOffset();
				if (segVal == 0 && offVal == 0) {
					continue;
				}

				Address address = sectionToAddress.get(fileHeader.getSectionHeader(segVal - 1));
				if (address != null) {
					address = address.add(Conv.intToLong(offVal));

					try {
						symTable.createLabel(address, name, SourceType.IMPORTED);
					}
					catch (InvalidInputException e) {
						Msg.error(this, "Error creating label " + name + "at address " + address +
							": " + e.getMessage());
					}

					demangle(address, name, program);
				}
				else {
					++errorCount;
				}
			}
		}

		if (errorCount != 0) {
			Msg.error(this, "Failed to apply " + errorCount +
				" debug Code View symbols contained within unknown sections.");
		}
	}

	private void demangle(Address address, String name, Program program) {
		DemangledObject demangledObj = null;
		try {
			demangledObj = DemanglerUtil.demangle(program, name);
		}
		catch (Exception e) {
			//log.appendMsg("Unable to demangle: "+name);
		}
		if (demangledObj != null) {
			setComment(CodeUnit.PLATE_COMMENT, address, demangledObj.getSignature(true));
		}
	}

	private void processFiles(OMFSrcModuleFile file, short segment, FileHeader fileHeader,
			Map<SectionHeader, Address> sectionToAddress, TaskMonitor monitor) {

		int[] starts = file.getStarts();
		int[] ends = file.getEnds();

		for (int k = 0; k < starts.length; ++k) {
			if (starts[k] == 0 || ends[k] == 0) {
				continue;
			}

			Address addr = sectionToAddress.get(fileHeader.getSectionHeader(segment - 1));
			if (addr == null) {
				continue;
			}

			Address startAddr = addr.add(Conv.intToLong(starts[k]));
			String cmt = "START-> " + file.getName() + ": " + "?";
			setComment(CodeUnit.PRE_COMMENT, startAddr, cmt);

			Address endAddr = addr.add(Conv.intToLong(ends[k]));
			cmt = "END-> " + file.getName() + ": " + "?";
			setComment(CodeUnit.PRE_COMMENT, endAddr, cmt);

			if (monitor.isCancelled()) {
				return;
			}
		}
	}

	private void processLineNumbers(FileHeader fileHeader,
			Map<SectionHeader, Address> sectionToAddress, OMFSrcModuleLine[] lines,
			TaskMonitor monitor) {//TODO revisit this method for accuracy
		for (OMFSrcModuleLine line : lines) {
			if (monitor.isCancelled()) {
				return;
			}
			Address addr =
				sectionToAddress.get(fileHeader.getSectionHeader(line.getSegmentIndex() - 1));
			if (addr != null) {
				int[] offsets = line.getOffsets();
				short[] lineNumbers = line.getLinenumbers();
				for (int j = 0; j < offsets.length; j++) {
					if (monitor.isCancelled()) {
						return;
					}
					if (offsets[j] == 0) {
						System.out.println("");
					}
					if (offsets[j] == 1) {
						System.out.println("");
					}
					if (offsets[j] > 0) {
						addLineComment(addr.add(Conv.intToLong(offsets[j])),
							Conv.shortToInt(lineNumbers[j]));
					}
				}
			}
		}
	}

	private void processDebugCOFF(DebugCOFFSymbolsHeader dcsh, FileHeader fileHeader,
			Map<SectionHeader, Address> sectionToAddress, Program program, TaskMonitor monitor) {
		if (dcsh == null) {
			return;
		}
		DebugCOFFSymbolTable dcst = dcsh.getSymbolTable();
		if (dcst == null) {
			return;
		}
		DebugCOFFSymbol[] symbols = dcst.getSymbols();
		int errorCount = 0;
		for (DebugCOFFSymbol symbol : symbols) {
			if (monitor.isCancelled()) {
				return;
			}
			if (!processDebugCoffSymbol(symbol, fileHeader, sectionToAddress, program, monitor)) {
				++errorCount;
			}
		}

		if (errorCount != 0) {
			Msg.error(this, "Failed to apply " + errorCount +
				" debug COFF symbols contained within unknown sections.");
		}

		DebugCOFFLineNumber[] lineNumbers = dcsh.getLineNumbers();
		if (lineNumbers != null) {
			for (DebugCOFFLineNumber lineNumber : lineNumbers) {
				if (monitor.isCancelled()) {
					return;
				}

				if (lineNumber.getLineNumber() == 0) {
					//TODO: lookup function name
				}
				else {
					addLineComment(
						program.getImageBase().add(loadInfo.imageBase).add(Conv.intToLong(lineNumber.getVirtualAddress())),
						lineNumber.getLineNumber());
				}
			}
		}
	}

	protected boolean processDebugCoffSymbol(DebugCOFFSymbol symbol, FileHeader fileHeader,
			Map<SectionHeader, Address> sectionToAddress, Program program,
			TaskMonitor monitor) {

		if (symbol.getSectionNumber() == 0) {
			return true;
		}

		String sym = symbol.getName();
		if (sym == null || sym.length() == 0) {
			return true;
		}

		int val = symbol.getValue();
		if (val == 0) {
			return true;
		}

		if (symbol.getSectionNumber() == DebugCOFFSymbol.IMAGE_SYM_ABSOLUTE) {
			return true;
		}

		if (symbol.getSectionNumber() == DebugCOFFSymbol.IMAGE_SYM_DEBUG) {
			return true;
		}

		SectionHeader section = fileHeader.getSectionHeader(symbol.getSectionNumber() - 1);
		if (section == null) {
			return false;
		}
		Address address = sectionToAddress.get(section);
		if (address == null) {
			return false;
		}

		address = address.add(Conv.intToLong(val));

		try {
			Symbol newSymbol =
				program.getSymbolTable().createLabel(address, sym, SourceType.IMPORTED);

			// Force non-section symbols to be primary.  We never want section symbols (.text, 
			// .text$func_name) to be primary because we don't want to use them for function names
			// or demangling.
			if (!sym.equals(section.getName()) && !sym.startsWith(section.getName() + "$")) {
				newSymbol.setPrimary();
			}
		}
		catch (InvalidInputException e) {
			Msg.error(this, "Error creating label named " + sym + " at address " + address + ": " +
				e.getMessage());
		}

		demangle(address, sym, program);

		DebugCOFFSymbolAux[] auxs = symbol.getAuxiliarySymbols();
		for (DebugCOFFSymbolAux aux : auxs) {
			if (monitor.isCancelled()) {
				break;
			}
			if (aux == null) {
				continue;
			}
			setComment(CodeUnit.PRE_COMMENT, address, aux.toString());
		}

		return true;
	}

	private void processDebugFixup(DebugFixup df) {
		if (df == null) {
			return;
		}

		//TODO: determine how to use fixup information
		//DebugFixupElement [] elements = df.getDebugFixupElements();
	}

	private void processDebugMisc(Program program, DebugMisc dm) {
		if (dm == null) {
			return;
		}

		String actualData = dm.getActualData();
		int datatype = dm.getDataType();

		DebugDirectory dd = dm.getDebugDirectory();

		if (dd.getAddressOfRawData() > 0) {
			Address address = program.getImageBase().add(loadInfo.imageBase).add(dd.getAddressOfRawData());
			try {
				program.getListing().createData(address, new StringDataType(), actualData.length());
				program.getListing().setComment(address, CodeUnit.PLATE_COMMENT, "Debug Misc");
				address = address.add(actualData.length());
				program.getListing().createData(address, new DWordDataType());
			}
			catch (CodeUnitInsertionException e) {
				// ignore
			}
		}

		Options proplist = program.getOptions(Program.PROGRAM_INFO);

		proplist.setString("Debug Misc", actualData);
		proplist.setString("Debug Misc Datatype", "0x" + Conv.toHexString(datatype));
	}

	private void addLineComment(Address addr, int line) {
		String cmt = addr + " -> " + "Line #" + line;
		setComment(CodeUnit.PRE_COMMENT, addr, cmt);
	}

	protected boolean hasComment(int type, Address address) {
		switch (type) {
			case CodeUnit.PLATE_COMMENT:
				return plateCommentMap.get(address) != null;
			case CodeUnit.PRE_COMMENT:
				return preCommentMap.get(address) != null;
			case CodeUnit.POST_COMMENT:
				return postCommentMap.get(address) != null;
			case CodeUnit.EOL_COMMENT:
				return eolCommentMap.get(address) != null;
		}
		return false;
	}

	protected void setComment(int type, Address address, String comment) {
		StringBuffer buffer = null;
		switch (type) {
			case CodeUnit.PLATE_COMMENT:
				buffer = plateCommentMap.get(address);
				if (buffer == null) {
					buffer = new StringBuffer();
					plateCommentMap.put(address, buffer);
				}
				break;
			case CodeUnit.PRE_COMMENT:
				buffer = preCommentMap.get(address);
				if (buffer == null) {
					buffer = new StringBuffer();
					preCommentMap.put(address, buffer);
				}
				break;
			case CodeUnit.POST_COMMENT:
				buffer = postCommentMap.get(address);
				if (buffer == null) {
					buffer = new StringBuffer();
					postCommentMap.put(address, buffer);
				}
				break;
			case CodeUnit.EOL_COMMENT:
				buffer = eolCommentMap.get(address);
				if (buffer == null) {
					buffer = new StringBuffer();
					eolCommentMap.put(address, buffer);
				}
				break;
		}
		if (buffer != null) {
			if (buffer.length() > 0) {
				buffer.append('\n');
			}
			buffer.append(comment);
		}
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/opinion/PeLoader.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.opinion;
import ghidra.app.util.opinion.*;

import java.io.IOException;
import java.math.BigInteger;
import java.util.*;

import generic.continues.GenericFactory;
import generic.continues.RethrowContinuesFactory;
import ghidra.app.util.MemoryBlockUtils;
import ghidra.app.util.Option;
import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.ByteProvider;
import ghidra.app.util.bin.format.mz.DOSHeader;
import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;
import net.jubjubnest.minidump.contrib.pe.*;
import net.jubjubnest.minidump.contrib.pe.PortableExecutable.SectionLayout;
import net.jubjubnest.minidump.contrib.pe.debug.DebugCOFFSymbol;
import net.jubjubnest.minidump.contrib.pe.debug.DebugDirectoryParser;
import ghidra.app.util.importer.MessageLog;
import ghidra.app.util.importer.MessageLogContinuesFactory;
import ghidra.framework.model.DomainObject;
import ghidra.framework.options.Options;
import ghidra.program.database.mem.FileBytes;
import ghidra.program.model.address.*;
import ghidra.program.model.data.*;
import ghidra.program.model.lang.Register;
import ghidra.program.model.lang.RegisterValue;
import ghidra.program.model.listing.*;
import ghidra.program.model.mem.Memory;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.program.model.reloc.RelocationTable;
import ghidra.program.model.symbol.*;
import ghidra.program.model.util.AddressSetPropertyMap;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.*;
import ghidra.util.exception.*;
import ghidra.util.task.TaskMonitor;

/**
 * Microsoft Portable Executable (PE) loader.
 */
public class PeLoader extends AbstractPeDebugLoader {

	/** The name of the PE loader */
	public final static String PE_NAME = "Patched Portable Executable (PE)";

	/** The name of the PE headers memory block. */
	public static final String HEADERS = "Headers";

	/** The minimum length a file has to be for it to qualify as a possible PE. */
	private static final long MIN_BYTE_LENGTH = 4;

	/** PE loader option to control parsing CLI headers */
	public static final String PARSE_CLI_HEADERS_OPTION_NAME = "Parse CLI headers (if present)";
	static final boolean PARSE_CLI_HEADERS_OPTION_DEFAULT = true;

    public PeLoader() {
        super(new ImageLoadInfo());
    }

    public PeLoader(ImageLoadInfo loadInfo) {
    	super(loadInfo);
    }

	@Override
	public Collection<LoadSpec> findSupportedLoadSpecs(ByteProvider provider) throws IOException {
		List<LoadSpec> loadSpecs = new ArrayList<>();

		if (provider.length() < MIN_BYTE_LENGTH) {
			return loadSpecs;
		}

		PortableExecutable pe = PortableExecutable.createPortableExecutable(
			RethrowContinuesFactory.INSTANCE, provider, this.loadInfo, false, false);
		NTHeader ntHeader = pe.getNTHeader();
		if (ntHeader != null && ntHeader.getOptionalHeader() != null) {
			long imageBase = ntHeader.getOptionalHeader().getImageBase();
			String machineName = ntHeader.getFileHeader().getMachineName();
			String compiler = CompilerOpinion.stripFamily(CompilerOpinion.getOpinion(pe, provider));
			for (QueryResult result : QueryOpinionService.query("Portable Executable (PE)", machineName, compiler)) {
				loadSpecs.add(new LoadSpec(this, imageBase, result));
			}
			if (loadSpecs.isEmpty()) {
				loadSpecs.add(new LoadSpec(this, imageBase, true));
			}
		}

		return loadSpecs;
	}
	
	public class ImageInfo
	{
		public PeLoader loader;
		public PortableExecutable pe;
		public Map<SectionHeader, Address> sectionToAddress;
	}

	@Override
	protected void load(ByteProvider provider, LoadSpec loadSpec, List<Option> options,
			Program program, TaskMonitor monitor, MessageLog log)
			throws IOException, CancelledException {
		
		if (loadInfo.imageName == null)
			loadInfo.imageName = program.getName();

		ImageInfo image = this.loadImage(provider, loadSpec, options, program, monitor, log);
		if( image == null ) {
			return;
		}
		
		processImage(provider, image, options, program, monitor, log);
	}

	public ImageInfo loadImage(ByteProvider provider, LoadSpec loadSpec, List<Option> options,
			Program program, TaskMonitor monitor, MessageLog log)
			throws IOException, CancelledException {

		if (monitor.isCancelled()) {
			return null;
		}

		ImageInfo imageInfo = new ImageInfo();
		imageInfo.loader = this;
		GenericFactory factory = MessageLogContinuesFactory.create(log);
		imageInfo.pe = PortableExecutable.createPortableExecutable(factory, provider,
			this.loadInfo, false, shouldParseCliHeaders(options));

		NTHeader ntHeader = imageInfo.pe.getNTHeader();
		if (ntHeader == null) {
			return null;
		}

		monitor.setMessage("Completing PE header parsing...");
		FileBytes fileBytes = MemoryBlockUtils.createFileBytes(program, provider, monitor);
		try {
			imageInfo.sectionToAddress =
				processMemoryBlocks(imageInfo.pe, program, fileBytes, monitor, log);
		}
		catch (AddressOverflowException e) {
			throw new IOException(e);
		}
		catch (DataTypeConflictException e) {
			throw new IOException(e);
		}
		monitor.setMessage("[" + program.getName() + "]: loaded!");
		
		return imageInfo;
	}

	public void processImage(ByteProvider provider, ImageInfo imageInfo, List<Option> options,
			Program program, TaskMonitor monitor, MessageLog log)
			throws IOException {

		if (monitor.isCancelled()) {
			return;
		}
		
		PortableExecutable pe = imageInfo.pe;
		Map<SectionHeader, Address> sectionToAddress = imageInfo.sectionToAddress;

		NTHeader ntHeader = pe.getNTHeader();
		OptionalHeader optionalHeader = ntHeader.getOptionalHeader();
		FileHeader fileHeader = ntHeader.getFileHeader();

		monitor.setMessage("Completing PE header parsing...");
		try {
			monitor.setCancelEnabled(false);
			optionalHeader.processDataDirectories(monitor, loadInfo);
			monitor.setCancelEnabled(true);
			optionalHeader.validateDataDirectories(program, loadInfo);

			DataDirectory[] datadirs = optionalHeader.getDataDirectories();
			layoutHeaders(program, pe, ntHeader, datadirs);
			for (DataDirectory datadir : datadirs) {
				if (datadir == null || !datadir.hasParsedCorrectly()) {
					continue;
				}
				if (datadir.hasParsedCorrectly()) {
					datadir.markup(program, false, monitor, log, ntHeader);
				}
			}

			setProcessorContext(fileHeader, program, monitor, log);

			processExports(optionalHeader, program, monitor, log);
			processImports(optionalHeader, program, monitor, log);
			processRelocations(optionalHeader, program, monitor, log);
			processDebug(optionalHeader, fileHeader, sectionToAddress, program, monitor);
			processProperties(optionalHeader, program, monitor);
			processComments(program.getListing(), monitor);
			processSymbols(fileHeader, sectionToAddress, program, monitor, log);

			// processEntryPoints(ntHeader, program, monitor);
			String compiler = CompilerOpinion.getOpinion(pe, provider).toString();
			program.setCompiler(compiler);

		}
		catch (DuplicateNameException e) {
			throw new IOException(e);
		}
		catch (CodeUnitInsertionException e) {
			throw new IOException(e);
		}
		catch (DataTypeConflictException e) {
			throw new IOException(e);
		}
		catch (MemoryAccessException e) {
			throw new IOException(e);
		}
		monitor.setMessage("[" + program.getName() + "]: done!");
	}

	@Override
	public List<Option> getDefaultOptions(ByteProvider provider, LoadSpec loadSpec,
			DomainObject domainObject, boolean loadIntoProgram) {
		List<Option> list =
			super.getDefaultOptions(provider, loadSpec, domainObject, loadIntoProgram);
		if (!loadIntoProgram) {
			list.add(new Option(PARSE_CLI_HEADERS_OPTION_NAME, PARSE_CLI_HEADERS_OPTION_DEFAULT,
				Boolean.class, Loader.COMMAND_LINE_ARG_PREFIX + "-parseCliHeaders"));
		}
		return list;
	}

	@Override
	public String validateOptions(ByteProvider provider, LoadSpec loadSpec, List<Option> options,
			Program program) {
		if (options != null) {
			for (Option option : options) {
				String name = option.getName();
				if (name.equals(PARSE_CLI_HEADERS_OPTION_NAME)) {
					if (!Boolean.class.isAssignableFrom(option.getValueClass())) {
						return "Invalid type for option: " + name + " - " + option.getValueClass();
					}
				}
			}
		}
		return super.validateOptions(provider, loadSpec, options, program);
	}

	@Override
	protected boolean isCaseInsensitiveLibraryFilenames() {
		return true;
	}

	private boolean shouldParseCliHeaders(List<Option> options) {
		if (options != null) {
			for (Option option : options) {
				String optName = option.getName();
				if (optName.equals(PARSE_CLI_HEADERS_OPTION_NAME)) {
					return (Boolean) option.getValue();
				}
			}
		}
		return PARSE_CLI_HEADERS_OPTION_DEFAULT;
	}

	private void layoutHeaders(Program program, PortableExecutable pe, NTHeader ntHeader,
			DataDirectory[] datadirs) {
		try {
			DataType dt = pe.getDOSHeader().toDataType();
			Address start = program.getImageBase().add(loadInfo.imageBase);
			DataUtilities.createData(program, start, dt, -1, false,
				DataUtilities.ClearDataMode.CHECK_FOR_SPACE);

			dt = pe.getRichHeader().toDataType();
			if (dt != null) {
				start = program.getImageBase().add(loadInfo.imageBase).add(pe.getRichHeader().getOffset());
				DataUtilities.createData(program, start, dt, -1, false,
					DataUtilities.ClearDataMode.CHECK_FOR_SPACE);
			}

			dt = ntHeader.toDataType();
			start = program.getImageBase().add(loadInfo.imageBase).add(pe.getDOSHeader().e_lfanew());
			DataUtilities.createData(program, start, dt, -1, false,
				DataUtilities.ClearDataMode.CHECK_FOR_SPACE);

			FileHeader fh = ntHeader.getFileHeader();
			SectionHeader[] sections = fh.getSectionHeaders();
			int index = fh.getPointerToSections();
			start = program.getImageBase().add(loadInfo.imageBase).add(index);
			for (SectionHeader section : sections) {
				dt = section.toDataType();
				DataUtilities.createData(program, start, dt, -1, false,
					DataUtilities.ClearDataMode.CHECK_FOR_SPACE);
				setComment(CodeUnit.EOL_COMMENT, start, section.getName());
				start = start.add(dt.getLength());
			}

//			for (int i = 0; i < datadirs.length; ++i) {
//				if (datadirs[i] == null || datadirs[i].getSize() == 0) {
//					continue;
//				}
//
//				if (datadirs[i].hasParsedCorrectly()) {
//					start = datadirs[i].getMarkupAddress(program, true);
//					dt = datadirs[i].toDataType();
//					DataUtilities.createData(program, start, dt, true, DataUtilities.ClearDataMode.CHECK_FOR_SPACE);
//				}
//			}
		}
		catch (Exception e1) {
			Msg.error(this, "Error laying down header structures " + e1);
		}
	}

	private void processSymbols(FileHeader fileHeader, Map<SectionHeader, Address> sectionToAddress,
			Program program, TaskMonitor monitor, MessageLog log) {
		List<DebugCOFFSymbol> symbols = fileHeader.getSymbols();
		int errorCount = 0;
		for (DebugCOFFSymbol symbol : symbols) {
			if (!processDebugCoffSymbol(symbol, fileHeader, sectionToAddress, program, monitor)) {
				++errorCount;
			}
		}

		if (errorCount != 0) {
			log.appendMsg(
				"Failed to apply " + errorCount + " symbols contained within unknown sections.");
		}
	}

	private void processProperties(OptionalHeader optionalHeader, Program prog,
			TaskMonitor monitor) {
		if (monitor.isCancelled()) {
			return;
		}
		Options props = prog.getOptions(Program.PROGRAM_INFO);
		props.setInt("SectionAlignment", optionalHeader.getSectionAlignment());
		props.setBoolean(RelocationTable.RELOCATABLE_PROP_NAME,
			prog.getRelocationTable().getSize() > 0);
	}

	private void processRelocations(OptionalHeader optionalHeader, Program prog,
			TaskMonitor monitor, MessageLog log) {

		if (monitor.isCancelled()) {
			return;
		}
		monitor.setMessage("[" + prog.getName() + "]: processing relocation tables...");

		DataDirectory[] dataDirectories = optionalHeader.getDataDirectories();
		if (dataDirectories.length <= OptionalHeader.IMAGE_DIRECTORY_ENTRY_BASERELOC) {
			return;
		}
		BaseRelocationDataDirectory brdd =
			(BaseRelocationDataDirectory) dataDirectories[OptionalHeader.IMAGE_DIRECTORY_ENTRY_BASERELOC];
		if (brdd == null) {
			return;
		}

		AddressSpace space = prog.getAddressFactory().getDefaultAddressSpace();
		RelocationTable relocTable = prog.getRelocationTable();

		Memory memory = prog.getMemory();

		BaseRelocation[] relocs = brdd.getBaseRelocations();
		long originalImageBase = optionalHeader.getOriginalImageBase();
		AddressRange brddRange =
			new AddressRangeImpl(space.getAddress(originalImageBase + brdd.getVirtualAddress()),
				space.getAddress(originalImageBase + brdd.getVirtualAddress() + brdd.getSize()));
		AddressRange headerRange = new AddressRangeImpl(space.getAddress(originalImageBase),
			space.getAddress(originalImageBase + optionalHeader.getSizeOfHeaders()));
		DataConverter conv = LittleEndianDataConverter.INSTANCE;

		for (BaseRelocation reloc : relocs) {
			if (monitor.isCancelled()) {
				return;
			}
			int baseAddr = reloc.getVirtualAddress();
			int count = reloc.getCount();
			for (int j = 0; j < count; ++j) {
				int type = reloc.getType(j);
				if (type == BaseRelocation.IMAGE_REL_BASED_ABSOLUTE) {
					continue;
				}
				int offset = reloc.getOffset(j);
				long addr = Conv.intToLong(baseAddr + offset) + optionalHeader.getImageBase();
				Address relocAddr = space.getAddress(addr);

				try {
					byte[] bytes = optionalHeader.is64bit() ? new byte[8] : new byte[4];
					memory.getBytes(relocAddr, bytes);
					if (optionalHeader.wasRebased()) {
						long val = optionalHeader.is64bit() ? conv.getLong(bytes)
								: conv.getInt(bytes) & 0xFFFFFFFFL;
						val =
							val - (originalImageBase & 0xFFFFFFFFL) + optionalHeader.getImageBase();
						byte[] newbytes = optionalHeader.is64bit() ? conv.getBytes(val)
								: conv.getBytes((int) val);
						if (type == BaseRelocation.IMAGE_REL_BASED_HIGHLOW) {
							memory.setBytes(relocAddr, newbytes);
						}
						else if (type == BaseRelocation.IMAGE_REL_BASED_DIR64) {
							memory.setBytes(relocAddr, newbytes);
						}
						else {
							Msg.error(this, "Non-standard relocation type " + type);
						}
					}

					relocTable.add(relocAddr, type, null, bytes, null);

				}
				catch (MemoryAccessException e) {
					log.appendMsg("Relocation does not exist in memory: " + relocAddr);
				}
				if (brddRange.contains(relocAddr)) {
					Msg.error(this, "Self-modifying relocation table at " + relocAddr);
					return;
				}
				if (headerRange.contains(relocAddr)) {
					Msg.error(this, "Header modified at " + relocAddr);
					return;
				}
			}
		}
	}

	private void processImports(OptionalHeader optionalHeader, Program program, TaskMonitor monitor,
			MessageLog log) {

		if (monitor.isCancelled()) {
			return;
		}
		monitor.setMessage("[" + program.getName() + "]: processing imports...");

		DataDirectory[] dataDirectories = optionalHeader.getDataDirectories();
		if (dataDirectories.length <= OptionalHeader.IMAGE_DIRECTORY_ENTRY_IMPORT) {
			return;
		}
		ImportDataDirectory idd =
			(ImportDataDirectory) dataDirectories[OptionalHeader.IMAGE_DIRECTORY_ENTRY_IMPORT];
		if (idd == null) {
			return;
		}

		AddressFactory af = program.getAddressFactory();
		AddressSpace space = af.getDefaultAddressSpace();

		Listing listing = program.getListing();
		ReferenceManager refManager = program.getReferenceManager();
		Memory memory = program.getMemory();

		ImportInfo[] imports = idd.getImports();
		for (ImportInfo importInfo : imports) {
			if (monitor.isCancelled()) {
				return;
			}

			long addr = Conv.intToLong(importInfo.getAddress()) + optionalHeader.getImageBase();

			//If not 64bit make sure address is not larger
			//than 32bit. On WindowsCE some sections are
			//declared to roll over.
			if (!optionalHeader.is64bit()) {
				addr &= Conv.INT_MASK;
			}

			Address address = space.getAddress(addr);

			setComment(CodeUnit.PRE_COMMENT, address, importInfo.getComment());

			Data data = listing.getDefinedDataAt(address);
			if (data == null || !(data.getValue() instanceof Address)) {
				continue;
			}

			Address extAddr = (Address) data.getValue();
			if (extAddr != null) {
				// remove the existing mem reference that was created
				// when making a pointer
				data.removeOperandReference(0, extAddr);
//	            symTable.removeSymbol(symTable.getDynamicSymbol(extAddr));

				try {
					if( this.loadInfo.sectionLayout == SectionLayout.MEMORY && memory.contains( extAddr ) ) {
						refManager.addMemoryReference(address, extAddr, RefType.DATA, SourceType.IMPORTED, 0);
					} else {
						refManager.addExternalReference(address, importInfo.getDLL().toUpperCase(),
							importInfo.getName(), extAddr, SourceType.IMPORTED, 0, RefType.DATA);
					}
				}
				catch (DuplicateNameException e) {
					log.appendMsg("External location not created: " + e.getMessage());
				}
				catch (InvalidInputException e) {
					log.appendMsg("External location not created: " + e.getMessage());
				}
			}
		}
	}

	/**
	 * Mark this location as code in the CodeMap.
	 * The analyzers will pick this up and disassemble the code.
	 *
	 * TODO: this should be in a common place, so all importers can communicate that something
	 * is code or data.
	 *
	 * @param program The program to mark up.
	 * @param address The location.
	 */
	private void markAsCode(Program program, Address address) {
		AddressSetPropertyMap codeProp = program.getAddressSetPropertyMap("CodeMap");
		if (codeProp == null) {
			try {
				codeProp = program.createAddressSetPropertyMap("CodeMap");
			}
			catch (DuplicateNameException e) {
				codeProp = program.getAddressSetPropertyMap("CodeMap");
			}
		}

		if (codeProp != null) {
			codeProp.add(address, address);
		}
	}

	private void setProcessorContext(FileHeader fileHeader, Program program, TaskMonitor monitor,
			MessageLog log) {

		try {
			String machineName = fileHeader.getMachineName();
			if ("450".equals(machineName) || "452".equals(machineName)) {
				Register tmodeReg = program.getProgramContext().getRegister("TMode");
				if (tmodeReg == null) {
					return;
				}
				RegisterValue thumbMode = new RegisterValue(tmodeReg, BigInteger.ONE);
				AddressSpace space = program.getAddressFactory().getDefaultAddressSpace();
				program.getProgramContext().setRegisterValue(space.getMinAddress(),
					space.getMaxAddress(), thumbMode);
			}
		}
		catch (ContextChangeException e) {
			throw new AssertException("instructions should not exist");
		}
	}

	private void processExports(OptionalHeader optionalHeader, Program program, TaskMonitor monitor,
			MessageLog log) {

		if (monitor.isCancelled()) {
			return;
		}
		monitor.setMessage("[" + program.getName() + "]: processing exports...");

		DataDirectory[] dataDirectories = optionalHeader.getDataDirectories();
		if (dataDirectories.length <= OptionalHeader.IMAGE_DIRECTORY_ENTRY_EXPORT) {
			return;
		}
		ExportDataDirectory edd =
			(ExportDataDirectory) dataDirectories[OptionalHeader.IMAGE_DIRECTORY_ENTRY_EXPORT];

		if (edd == null) {
			return;
		}

		AddressFactory af = program.getAddressFactory();
		AddressSpace space = af.getDefaultAddressSpace();
		SymbolTable symTable = program.getSymbolTable();
		Memory memory = program.getMemory();
		Listing listing = program.getListing();
		ReferenceManager refManager = program.getReferenceManager();

		ExportInfo[] exports = edd.getExports();
		for (ExportInfo export : exports) {
			if (monitor.isCancelled()) {
				return;
			}

			Address address = space.getAddress(export.getAddress());
			setComment(CodeUnit.PRE_COMMENT, address, export.getComment());
			symTable.addExternalEntryPoint(address);

			String name = export.getName();
			try {
				symTable.createLabel(address, loadInfo.prefixName(name), SourceType.IMPORTED);
			}
			catch (InvalidInputException e) {
				// Don't create invalid symbol
			}

			try {
				symTable.createLabel(address, loadInfo.prefixName(SymbolUtilities.ORDINAL_PREFIX + export.getOrdinal()),
					SourceType.IMPORTED);
			}
			catch (InvalidInputException e) {
				// Don't create invalid symbol
			}

			// When exported symbol is a forwarder,
			// a string exists at the address of the export
			// Therefore, create a string data object to prevent
			// disassembler from attempting to create
			// code here. If code was created, it would be incorrect
			// and offcut.
			if (export.isForwarded()) {
				try {
					listing.createData(address, TerminatedStringDataType.dataType, -1);
					Data data = listing.getDataAt(address);
					if (data != null) {
						Object obj = data.getValue();
						if (obj instanceof String) {
							String str = (String) obj;
							int dotpos = str.indexOf('.');

							if (dotpos < 0) {
								dotpos = 0;//TODO
							}

							// get the name of the dll
							String dllName = str.substring(0, dotpos) + ".dll";

							// get the name of the symbol
							String expName = str.substring(dotpos + 1);

							try {
								refManager.addExternalReference(address, dllName.toUpperCase(),
									expName, null, SourceType.IMPORTED, 0, RefType.DATA);
							}
							catch (DuplicateNameException e) {
								log.appendMsg("External location not created: " + e.getMessage());
							}
							catch (InvalidInputException e) {
								log.appendMsg("External location not created: " + e.getMessage());
							}
						}
					}
				}
				catch (CodeUnitInsertionException e) {
					// Nothing to do...just continue on
				}
			}
		}
	}

	private Map<SectionHeader, Address> processMemoryBlocks(PortableExecutable pe, Program prog,
			FileBytes fileBytes, TaskMonitor monitor, MessageLog log)
			throws AddressOverflowException, IOException {

		AddressFactory af = prog.getAddressFactory();
		AddressSpace space = af.getDefaultAddressSpace();
		Map<SectionHeader, Address> sectionToAddress = new HashMap<>();

		if (monitor.isCancelled()) {
			return sectionToAddress;
		}
		monitor.setMessage("[" + prog.getName() + "]: processing memory blocks...");

		NTHeader ntHeader = pe.getNTHeader();
		FileHeader fileHeader = ntHeader.getFileHeader();
		OptionalHeader optionalHeader = ntHeader.getOptionalHeader();

		SectionHeader[] sections = fileHeader.getSectionHeaders();
		if (sections.length == 0) {
			Msg.warn(this, "No sections found");
		}

		// Header block
		int virtualSize = (int) Math.min(getVirtualSize(pe, sections, space), fileBytes.getSize());
		long addr = optionalHeader.getImageBase();
		Address address = space.getAddress(addr);

		boolean r = true;
		boolean w = false;
		boolean x = false;
		MemoryBlockUtils.createInitializedBlock(prog, false, HEADERS, address, fileBytes, 0,
			virtualSize, "", "", r, w, x, log);

		// Section blocks
		try {
			for (int i = 0; i < sections.length; ++i) {
				if (monitor.isCancelled()) {
					return sectionToAddress;
				}

				addr = sections[i].getVirtualAddress() + optionalHeader.getImageBase();

				address = space.getAddress(addr);

				r = ((sections[i].getCharacteristics() &
					SectionFlags.IMAGE_SCN_MEM_READ.getMask()) != 0x0);
				w = ((sections[i].getCharacteristics() &
					SectionFlags.IMAGE_SCN_MEM_WRITE.getMask()) != 0x0);
				x = ((sections[i].getCharacteristics() &
					SectionFlags.IMAGE_SCN_MEM_EXECUTE.getMask()) != 0x0);

				int sourceDataSize = loadInfo.sectionLayout == SectionLayout.FILE
						? sections[i].getSizeOfRawData()
						: sections[i].getVirtualSize();
				int sourceDataPtr = loadInfo.sectionLayout == SectionLayout.FILE
						? sections[i].getPointerToRawData()
						: sections[i].getVirtualAddress();
				virtualSize = sections[i].getVirtualSize();
				if (sourceDataSize != 0 && sourceDataPtr != 0) {
					int dataSize =
						((sourceDataSize > virtualSize && virtualSize > 0) || sourceDataSize < 0)
								? virtualSize
								: sourceDataSize;
					if (ntHeader.checkRVA(dataSize) ||
						(0 < dataSize && dataSize < pe.getFileLength())) {
						if (!ntHeader.checkRVA(dataSize)) {
							Msg.warn(this, "OptionalHeader.SizeOfImage < size of " +
								sections[i].getName() + " section");
						}
						String sectionName = sections[i].getReadableName();
						if (sectionName.isBlank()) {
							sectionName = "SECTION." + i;
						}
						MemoryBlockUtils.createInitializedBlock(prog, false, sectionName, address,
							fileBytes, sourceDataPtr, dataSize, "", "", r, w, x, log);
						sectionToAddress.put(sections[i], address);
					}
					if (sourceDataSize == virtualSize) {
						continue;
					}
					else if (sourceDataSize > virtualSize) {
						// virtual size fully initialized
						continue;
					}
					// remainder of virtual size is uninitialized
					if (sourceDataSize < 0) {
						Msg.error(this,
							"Section[" + i + "] has invalid size " +
								Integer.toHexString(sourceDataSize) + " (" +
								Integer.toHexString(virtualSize) + ")");
						break;
					}
					virtualSize -= sourceDataSize;
					address = address.add(sourceDataSize);
				}

				if (virtualSize == 0) {
					Msg.error(this, "Section[" + i + "] has size zero");
				}
				else {
					int dataSize = (virtualSize > 0 || sourceDataSize < 0) ? virtualSize : 0;
					if (dataSize > 0) {
						MemoryBlockUtils.createUninitializedBlock(prog, false,
							sections[i].getReadableName(), address, dataSize, "", "", r, w, x, log);
						sectionToAddress.put(sections[i], address);
					}
				}

			}
		}
		catch (IllegalStateException ise) {
			if (optionalHeader.getFileAlignment() != optionalHeader.getSectionAlignment()) {
				throw new IllegalStateException(ise);
			}
			Msg.warn(this, "Section header processing aborted");
		}

		return sectionToAddress;
	}

	private int getVirtualSize(PortableExecutable pe, SectionHeader[] sections,
			AddressSpace space) {
		DOSHeader dosHeader = pe.getDOSHeader();
		OptionalHeader optionalHeader = pe.getNTHeader().getOptionalHeader();
		int virtualSize = optionalHeader.is64bit() ? Constants.IMAGE_SIZEOF_NT_OPTIONAL64_HEADER
				: Constants.IMAGE_SIZEOF_NT_OPTIONAL32_HEADER;
		virtualSize += FileHeader.IMAGE_SIZEOF_FILE_HEADER + 4;
		virtualSize += dosHeader.e_lfanew();
		if (optionalHeader.getSizeOfHeaders() > virtualSize) {
			virtualSize = (int) optionalHeader.getSizeOfHeaders();
		}

		if (optionalHeader.getFileAlignment() == optionalHeader.getSectionAlignment()) {
			if (optionalHeader.getFileAlignment() <= 0x800) {
				Msg.warn(this,
					"File and section alignments identical - possible driver or sectionless image");
			}
		}
		//long max = space.getMaxAddress().getOffset() - optionalHeader.getImageBase();
		//if (virtualSize > max) {
		//	virtualSize = (int) max;
		//	Msg.error(this, "Possible truncation of image at "+Long.toHexString(optionalHeader.getImageBase()));
		//}
		return virtualSize;
	}

	private void processEntryPoints(NTHeader ntHeader, Program prog, TaskMonitor monitor) {
		if (monitor.isCancelled()) {
			return;
		}
		monitor.setMessage("[" + prog.getName() + "]: processing entry points...");

		OptionalHeader optionalHeader = ntHeader.getOptionalHeader();
		AddressFactory af = prog.getAddressFactory();
		AddressSpace space = af.getDefaultAddressSpace();
		SymbolTable symTable = prog.getSymbolTable();

		long entry = optionalHeader.getAddressOfEntryPoint();
		int ptr = ntHeader.rvaToPointer((int) entry);
		if (ptr < 0) {
			if (entry != 0 ||
				(ntHeader.getFileHeader().getCharacteristics() & FileHeader.IMAGE_FILE_DLL) == 0) {
				Msg.warn(this, "Virtual entry point at " + Long.toHexString(entry));
			}
		}
		Address baseAddr = space.getAddress(entry);
		long imageBase = optionalHeader.getImageBase();
		Address entryAddr = baseAddr.addWrap(imageBase);
		entry += optionalHeader.getImageBase();
		try {
			symTable.createLabel(entryAddr, "entry", SourceType.IMPORTED);
			markAsCode(prog, entryAddr);
		}
		catch (InvalidInputException e) {
			// ignore
		}
		symTable.addExternalEntryPoint(entryAddr);
	}

	private void processDebug(OptionalHeader optionalHeader, FileHeader fileHeader,
			Map<SectionHeader, Address> sectionToAddress, Program program, TaskMonitor monitor) {
		if (monitor.isCancelled()) {
			return;
		}
		monitor.setMessage("[" + program.getName() + "]: processing debug information...");

		DataDirectory[] dataDirectories = optionalHeader.getDataDirectories();
		if (dataDirectories.length <= OptionalHeader.IMAGE_DIRECTORY_ENTRY_DEBUG) {
			return;
		}
		DebugDataDirectory ddd =
			(DebugDataDirectory) dataDirectories[OptionalHeader.IMAGE_DIRECTORY_ENTRY_DEBUG];

		if (ddd == null) {
			return;
		}

		DebugDirectoryParser parser = ddd.getParser();
		if (parser == null) {
			return;
		}

		processDebug(parser, fileHeader, sectionToAddress, program, monitor);
	}

	@Override
	public String getName() {
		return PE_NAME;
	}

	public static class CompilerOpinion {
		static final char[] errString_borland =
			"This program must be run under Win32\r\n$".toCharArray();
		static final char[] errString_GCC_VS =
			"This program cannot be run in DOS mode.\r\r\n$".toCharArray();
		static final char[] errString_Clang =
			"This program cannot be run in DOS mode.$".toCharArray();
		static final int[] asm16_Borland = { 0xBA, 0x10, 0x00, 0x0E, 0x1F, 0xB4, 0x09, 0xCD, 0x21,
			0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x90, 0x90 };
		static final int[] asm16_GCC_VS_Clang =
			{ 0x0e, 0x1f, 0xba, 0x0e, 0x00, 0xb4, 0x09, 0xcd, 0x21, 0xb8, 0x01, 0x4c, 0xcd, 0x21 };

		public enum CompilerEnum {

			VisualStudio("visualstudio:unknown"),
			GCC("gcc:unknown"),
			Clang("clang:unknown"),
			GCC_VS("visualstudiogcc"),
			GCC_VS_Clang("visualstudiogccclang"),
			BorlandPascal("borland:pascal"),
			BorlandCpp("borland:c++"),
			BorlandUnk("borland:unknown"),
			CLI("cli"),
			Unknown("unknown");

			private String label;

			private CompilerEnum(String label) {
				this.label = label;
			}

			@Override
			public String toString() {
				return label;
			}
		}

		// Treat string as upto 3 colon separated fields describing a compiler  --   <product>:<language>:version
		public static String stripFamily(CompilerEnum val) {
			if (val == CompilerEnum.BorlandCpp) {
				return "borlandcpp";
			}
			if (val == CompilerEnum.BorlandPascal) {
				return "borlanddelphi";
			}
			if (val == CompilerEnum.BorlandUnk) {
				return "borlandcpp";
			}
			String compilerid = val.toString();
			int colon = compilerid.indexOf(':');
			if (colon > 0) {
				return compilerid.substring(0, colon);
			}
			return compilerid;
		}

		private static SectionHeader getSectionHeader(String name, SectionHeader[] list) {
			for (SectionHeader element : list) {
				if (element.getName().equals(name)) {
					return element;
				}
			}
			return null;
		}

		/**
		 * Return true if chararray appears in full, starting at offset bytestart in bytearray
		 * @param bytearray the array of bytes containing the potential match
		 * @param bytestart the potential start of the match
		 * @param chararray the array of characters to match
		 * @return true if there is a full match
		 */
		private static boolean compareBytesToChars(byte[] bytearray, int bytestart,
				char[] chararray) {
			int i = 0;
			if (bytestart + chararray.length < bytearray.length) {
				for (; i < chararray.length; ++i) {
					if (chararray[i] != (char) bytearray[bytestart + i]) {
						break;
					}
				}
			}
			return (i == chararray.length);
		}

		public static CompilerEnum getOpinion(PortableExecutable pe, ByteProvider provider)
				throws IOException {
			CompilerEnum compilerType = CompilerEnum.Unknown;
			CompilerEnum offsetChoice = CompilerEnum.Unknown;
			CompilerEnum asmChoice = CompilerEnum.Unknown;
			CompilerEnum errStringChoice = CompilerEnum.Unknown;
			BinaryReader br = new BinaryReader(provider, true);

			DOSHeader dh = pe.getDOSHeader();

			// Check for managed code (.NET)
			if (pe.getNTHeader().getOptionalHeader().isCLI()) {
				return CompilerEnum.CLI;
			}

			// Determine based on PE Header offset
			if (dh.e_lfanew() == 0x80) {
				offsetChoice = CompilerEnum.GCC_VS;
			}
			else if (dh.e_lfanew() == 0x78) {
				offsetChoice = CompilerEnum.Clang;
			}
			else if (dh.e_lfanew() < 0x80) {
				offsetChoice = CompilerEnum.Unknown;
			}
			else {

				// Check for "DanS"
				int val1 = br.readInt(0x80);
				int val2 = br.readInt(0x80 + 4);

				if (val1 != 0 && val2 != 0 && (val1 ^ val2) == 0x536e6144) {
					compilerType = CompilerEnum.VisualStudio;
					return compilerType;
				}
				else if (dh.e_lfanew() == 0x100) {
					offsetChoice = CompilerEnum.BorlandPascal;
				}
				else if (dh.e_lfanew() == 0x200) {
					offsetChoice = CompilerEnum.BorlandCpp;
				}
				else if (dh.e_lfanew() > 0x300) {
					compilerType = CompilerEnum.Unknown;
					return compilerType;
				}
				else {
					offsetChoice = CompilerEnum.Unknown;
				}
			} // End PE header offset check

			int counter;
			byte[] asm = provider.readBytes(0x40, 256);
			for (counter = 0; counter < asm16_Borland.length; counter++) {
				if ((asm[counter] & 0xff) != (asm16_Borland[counter] & 0xff)) {
					break;
				}
			}
			if (counter == asm16_Borland.length) {
				asmChoice = CompilerEnum.BorlandUnk;
			}
			else {
				for (counter = 0; counter < asm16_GCC_VS_Clang.length; counter++) {
					if ((asm[counter] & 0xff) != (asm16_GCC_VS_Clang[counter] & 0xff)) {
						break;
					}
				}
				if (counter == asm16_GCC_VS_Clang.length) {
					asmChoice = CompilerEnum.GCC_VS_Clang;
				}
				else {
					asmChoice = CompilerEnum.Unknown;
				}
			}
			// Check for error message
			int errStringOffset = -1;
			for (int i = 10; i < asm.length - 3; i++) {
				if (asm[i] == 'T' && asm[i + 1] == 'h' && asm[i + 2] == 'i' && asm[i + 3] == 's') {
					errStringOffset = i;
					break;
				}
			}

			if (errStringOffset == -1) {
				asmChoice = CompilerEnum.Unknown;
			}
			else {
				if (compareBytesToChars(asm, errStringOffset, errString_borland)) {
					errStringChoice = CompilerEnum.BorlandUnk;
					if (offsetChoice == CompilerEnum.BorlandCpp ||
						offsetChoice == CompilerEnum.BorlandPascal) {
						compilerType = offsetChoice;
						return compilerType;
					}
				}
				else if (compareBytesToChars(asm, errStringOffset, errString_GCC_VS)) {
					errStringChoice = CompilerEnum.GCC_VS;
				}
				else if (compareBytesToChars(asm, errStringOffset, errString_Clang)) {
					errStringChoice = CompilerEnum.Clang;
				}
				else {
					errStringChoice = CompilerEnum.Unknown;
				}
			}

			// Check for AddressOfStart and PointerToSymbol
			if (errStringChoice == CompilerEnum.GCC_VS && asmChoice == CompilerEnum.GCC_VS_Clang &&
				dh.e_lfanew() == 0x80) {
				// Trying to determine if we have gcc or old VS

				// Look for the "Visual Studio" library identifier
//				if (mem.findBytes(mem.getMinAddress(), "Visual Studio".getBytes(),
//						null, true, monitor) != null) {
//					compilerType = COMPIL_VS;
//					return compilerType;
//				}

				// Now look for offset to code (0x1000 for gcc) and PointerToSymbols
				// (0 for VS, non-zero for gcc)
				int addrCode = br.readInt(dh.e_lfanew() + 40);
				if (addrCode != 0x1000) {
					compilerType = CompilerEnum.VisualStudio;
					return compilerType;
				}

				int ptrSymTable = br.readInt(dh.e_lfanew() + 12);
				if (ptrSymTable != 0) {
					compilerType = CompilerEnum.GCC;
					return compilerType;
				}
			}
			else if ((offsetChoice == CompilerEnum.Clang ||
				errStringChoice == CompilerEnum.Clang) && asmChoice == CompilerEnum.GCC_VS_Clang) {
				compilerType = CompilerEnum.Clang;
				return compilerType;
			}
			else if (errStringChoice == CompilerEnum.Unknown || asmChoice == CompilerEnum.Unknown) {
				compilerType = CompilerEnum.Unknown;
				return compilerType;
			}

			if (errStringChoice == CompilerEnum.BorlandUnk ||
				asmChoice == CompilerEnum.BorlandUnk) {
				// Pretty sure it's Borland, but didn't get 0x100 or 0x200
				compilerType = CompilerEnum.BorlandUnk;
				return compilerType;
			}

			if ((offsetChoice == CompilerEnum.GCC_VS) || (errStringChoice == CompilerEnum.GCC_VS)) {
				// Pretty sure it's either gcc or Visual Studio
				compilerType = CompilerEnum.GCC_VS;
			}
			else {
				// Not sure what it is
				compilerType = CompilerEnum.Unknown;
			}

			// Reaching this point implies that we did not find "DanS and we didn't
			// see the Borland DOS complaint
			boolean probablyNotVS = false;
			// TODO: See if we have an .idata segment and what type it is
			// Need to make sure that this is the right check to be making
			SectionHeader[] headers = pe.getNTHeader().getFileHeader().getSectionHeaders();
			if (getSectionHeader(".idata", headers) != null) {
				probablyNotVS = true;
			}

			if (getSectionHeader("CODE", headers) != null) {
				compilerType = CompilerEnum.BorlandPascal;
				return compilerType;
			}

			SectionHeader segment = getSectionHeader(".bss", headers);
			if ((segment != null)/* && segment.getType() == BSS_TYPE */) {
				compilerType = CompilerEnum.GCC;
				return compilerType;
//			} else if (segment != null) {
//				compilerType = CompilerEnum.BorlandCpp;
//				return compilerType;
			}
			else if (!probablyNotVS) {
				compilerType = CompilerEnum.VisualStudio;
				return compilerType;
			}

			if (getSectionHeader(".tls", headers) != null) {
				// expect Borland - prefer cpp since CODE segment didn't occur
				compilerType = CompilerEnum.BorlandCpp;
			}

			return compilerType;
		}
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/ArchitectureDataDirectory.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;

import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Program;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;
import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;

public class ArchitectureDataDirectory extends DataDirectory {
    private final static String NAME = "IMAGE_DIRECTORY_ENTRY_ARCHITECTURE";

    private String copyright;

    static ArchitectureDataDirectory createArchitectureDataDirectory(
            NTHeader ntHeader, FactoryBundledWithBinaryReader reader)
            throws IOException {
        ArchitectureDataDirectory architectureDataDirectory = (ArchitectureDataDirectory) reader.getFactory().create(ArchitectureDataDirectory.class);
        architectureDataDirectory.initArchitectureDataDirectory(ntHeader, reader);
        return architectureDataDirectory;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public ArchitectureDataDirectory() {}

	private void initArchitectureDataDirectory(NTHeader ntHeader, FactoryBundledWithBinaryReader reader) throws IOException {
		processDataDirectory(ntHeader, reader);
	}

	@Override
	public String getDirectoryName() {
		return NAME;
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor,
			MessageLog log, NTHeader ntHeader) throws DuplicateNameException, CodeUnitInsertionException {
		monitor.setMessage(program.getName()+": architecture...");
		Address addr = PeUtils.getMarkupAddress(program, isBinary, ntHeader, virtualAddress);
		if (!program.getMemory().contains(addr)) {
			return;
		}
		createDirectoryBookmark(program, addr);
		PeUtils.createData(program, addr, toDataType(), log);
	}

	@Override
	public boolean parse() throws IOException {
		int ptr = getPointer();
		if (ptr < 0) {
			return false;
		}
        if (getSize() > 1000) {
        	Msg.info(this, "Requesting ASCII string of size "+getSize());
        	return false;
        }
        copyright = reader.readAsciiString(ptr, getSize());
        return true;
    }

	/**
	 * Returns the copyright string defined in this directory.
	 * @return the copyright string defined in this directory
	 */
    public String getCopyright() {
        return copyright;
    }

    /**
     * @see ghidra.app.util.bin.StructConverter#toDataType()
     */
    @Override
    public DataType toDataType() throws DuplicateNameException {
        StructureDataType struct = new StructureDataType(NAME, 0);
        if (size > 0) {
        	struct.add(new StringDataType(), size, "Copyright", null);
        }
        struct.setCategoryPath(new CategoryPath("/PE"));
        return struct;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/BaseRelocation.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.program.model.data.*;
import ghidra.util.DataConverter;
import ghidra.util.exception.DuplicateNameException;

/**
 * A class to represent the <code>IMAGE_BASE_RELOCATION</code>
 * data structure defined in <b><code>winnt.h</code></b>.
 * <pre>
 * typedef struct _IMAGE_BASE_RELOCATION {
 *     DWORD   VirtualAddress;
 *     DWORD   SizeOfBlock;
 * //  WORD    TypeOffset[1];
 * } IMAGE_BASE_RELOCATION;
 * typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;
 * </pre>
 * 
 * 
 */
public class BaseRelocation implements StructConverter, ByteArrayConverter {
	/**
	 * The name to use when converting into a structure data type.
	 */
    public final static String NAME = "IMAGE_BASE_RELOCATION";
    /**
     * The size of the <code>IMAGE_BASE_RELOCATION</code> in bytes.
     */
    public final static int IMAGE_SIZEOF_BASE_RELOCATION = 8;

	public final static int IMAGE_REL_BASED_NOOP             =  0;
    public final static int IMAGE_REL_BASED_ABSOLUTE          =  0;
    public final static int IMAGE_REL_BASED_HIGH              =  1;
    public final static int IMAGE_REL_BASED_LOW               =  2;
    public final static int IMAGE_REL_BASED_HIGHLOW           =  3;
    public final static int IMAGE_REL_BASED_HIGHADJ           =  4;

    public final static int IMAGE_REL_BASED_MIPS_JMPADDR      =  5;
    public final static int IMAGE_REL_BASED_SECTION           =  6;
    public final static int IMAGE_REL_BASED_REL32             =  7;
    public final static int IMAGE_REL_BASED_MIPS_JMPADDR16    =  9;
    public final static int IMAGE_REL_BASED_IA64_IMM64        =  9;
    public final static int IMAGE_REL_BASED_DIR64             = 10;
    public final static int IMAGE_REL_BASED_HIGH3ADJ          = 11;

	/**
	 * Names of the available base relocations.
	 */
    public final static String [] TYPE_STRINGS = {
                        "ABSOLUTE",             // 0
                        "HIGH",                 // 1
                        "LOW",                  // 2
                        "HIGHLOW",              // 3
                        "HIGHADJ",              // 4
                        "MIPS_JMPADDR",         // 5
                         "???6",
                         "???7",
                         "???8",
                        "IA64_IMM64",           // 9
                        "DIR64",                // 10
    };

    private int virtualAddress;
    private int sizeOfBlock;
    private List<TypeOffset> typeOffsetList = new ArrayList<TypeOffset>();

    static BaseRelocation createBaseRelocation(
            FactoryBundledWithBinaryReader reader, int index)
            throws IOException {
        BaseRelocation baseRelocation = (BaseRelocation) reader.getFactory().create(BaseRelocation.class);
        baseRelocation.initBaseRelocation(reader, index);
        return baseRelocation;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public BaseRelocation() {}

    private void initBaseRelocation(FactoryBundledWithBinaryReader reader, int index) throws IOException {
        virtualAddress = reader.readInt(index); index += BinaryReader.SIZEOF_INT;
        sizeOfBlock    = reader.readInt(index); index += BinaryReader.SIZEOF_INT;
        if (virtualAddress < 0) return;
        if (sizeOfBlock < 0 || sizeOfBlock > NTHeader.MAX_SANE_COUNT) return;

		int len = (sizeOfBlock-IMAGE_SIZEOF_BASE_RELOCATION)/BinaryReader.SIZEOF_SHORT;

		for (int i = 0 ; i < len ; ++i) {
			short typeOffset = reader.readShort(index);
			index += BinaryReader.SIZEOF_SHORT;

			typeOffsetList.add(new TypeOffset(typeOffset));
        }
    }

	BaseRelocation(int virtualAddress) {
		this.virtualAddress = virtualAddress;
		this.sizeOfBlock = IMAGE_SIZEOF_BASE_RELOCATION;
	}

	/**
	 * Adds a relocation to this base relocation block.
	 * @param type   the relocation type
	 * @param offset the relocation offset
	 */
	public void addRelocation(int type, int offset) {
		typeOffsetList.add(new TypeOffset(type, offset));
		sizeOfBlock += BinaryReader.SIZEOF_SHORT;
	}

    /**
     * Returns the base address of the relocations in this block.
     * @return the base address of the relocations in this block
     */
    public int getVirtualAddress() {
        return virtualAddress;
    }

    /**
     * Returns the size (in bytes) of this relocation block.
     * @return the size (in bytes) of this relocation block
     */
    public int getSizeOfBlock() {
        return sizeOfBlock;
    }

    /**
     * Returns the number of relocation in this block.
     * @return the number of relocation in this block
     */
    public int getCount() {
        return typeOffsetList.size();
    }

    /**
     * Returns the lower 12 bits of the offset.
     *
     * @param index the ith relocation
     * @return int the offset of the relocation
     */
    public int getOffset(int index) {
        return typeOffsetList.get(index).offset;
    }

	/**
	 * Returns the upper 4 bits of the offset.
	 *
	 * @param index the ith relocation
	 * @return int the type of the relocation
,	 */
    public int getType(int index) {
        return typeOffsetList.get(index).type;
    }

    /**
     * @see ghidra.app.util.bin.StructConverter#toDataType()
     */
    public DataType toDataType() throws DuplicateNameException {
        StructureDataType struct = new StructureDataType(NAME, 0);

        struct.add(DWORD,"VirtualAddress",null);
        struct.add(DWORD,"SizeOfBlock",null);
        struct.add(new ArrayDataType(WORD, typeOffsetList.size(), WORD.getLength()),"TypeOffset",null);

        struct.setCategoryPath(new CategoryPath("/PE"));

        return struct;
    }

	/**
	 * @see ghidra.app.util.bin.ByteArrayConverter#toBytes(ghidra.util.DataConverter)
	 */
	public byte[] toBytes(DataConverter dc) {
		byte [] bytes = new byte[sizeOfBlock];
		int pos = 0;
		dc.getBytes(virtualAddress, bytes, pos);
		pos += BinaryReader.SIZEOF_INT;
		dc.getBytes(sizeOfBlock, bytes, pos);
		pos += BinaryReader.SIZEOF_INT;
		for (int i = 0; i < typeOffsetList.size(); i++) {
			short typeOffset = typeOffsetList.get(i).typeOffset;
			dc.getBytes(typeOffset, bytes, pos);
			pos += BinaryReader.SIZEOF_SHORT;
		}
		return bytes;
	}

	private class TypeOffset {
		short typeOffset;
		int type;
		int offset;

		TypeOffset(short typeOffset) {
			this.typeOffset = typeOffset;
			this.type = ((typeOffset & 0xF000) >> 12) & 0x000F;
			this.offset = typeOffset & 0x0FFF;
		}

		TypeOffset(int type, int offset) {
			this.typeOffset = (short)(((type&0xf) << 12) | (offset & 0xfff));
			this.type = type;
			this.offset = offset;
		}
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/BaseRelocationDataDirectory.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import ghidra.app.util.bin.ByteArrayConverter;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Program;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.DataConverter;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;
import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;

/**
 * Points to the base relocation information.
 */
public class BaseRelocationDataDirectory extends DataDirectory implements ByteArrayConverter {
    private final static String NAME = "IMAGE_DIRECTORY_ENTRY_BASERELOC";

    private BaseRelocation [] relocs;

    static BaseRelocationDataDirectory createBaseRelocationDataDirectory(
            NTHeader ntHeader, FactoryBundledWithBinaryReader reader)
            throws IOException {
        BaseRelocationDataDirectory baseRelocationDataDirectory = (BaseRelocationDataDirectory) reader.getFactory().create(BaseRelocationDataDirectory.class);
        baseRelocationDataDirectory.initBaseRelocationDataDirectory(ntHeader, reader);
        return baseRelocationDataDirectory;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public BaseRelocationDataDirectory() {}

	private void initBaseRelocationDataDirectory(NTHeader ntHeader, FactoryBundledWithBinaryReader reader) throws IOException {
		processDataDirectory(ntHeader, reader);
        if (relocs == null) relocs = new BaseRelocation[0];
	}

	@Override
	public String getDirectoryName() {
		return NAME;
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor,
			MessageLog log, NTHeader ntHeader) throws CodeUnitInsertionException {

		monitor.setMessage(program.getName()+": base relocation(s)...");
		Address addr = PeUtils.getMarkupAddress(program, isBinary, ntHeader, virtualAddress);
		if (!program.getMemory().contains(addr)) {
			return;
		}
		createDirectoryBookmark(program, addr);

        for (BaseRelocation reloc : relocs) {
            if (monitor.isCancelled()) {
                return;
            }

			PeUtils.createData(program, addr, DWORD, log);
            addr = addr.add(DWORD.getLength());

			PeUtils.createData(program, addr, DWORD, log);
            addr = addr.add(DWORD.getLength());

            int count = reloc.getCount();
            for (int j = 0 ; j < count ; ++j) {
                if (monitor.isCancelled()) {
                    return;
                }
				PeUtils.createData(program, addr, WORD, log);
               	addr = addr.add(WORD.getLength());
            }
        }
	}

	@Override
	public boolean parse() throws IOException {
		int addr = getPointer();
		if (addr < 0) {
			return false;
		}
        int stop = addr + getSize();

        List<BaseRelocation> relocsList = new ArrayList<BaseRelocation>();

        while (true) {
            if (addr >= stop) break;

            BaseRelocation br = BaseRelocation.createBaseRelocation(reader, addr);

            // Sanity check to make sure the data looks OK.
            if (br.getVirtualAddress() == 0)
                break;
            if (br.getSizeOfBlock() < BaseRelocation.IMAGE_SIZEOF_BASE_RELOCATION)
                break;
            if (br.getSizeOfBlock() == 0)
                break;

            relocsList.add(br);
            addr += br.getSizeOfBlock();
        }

        relocs = new BaseRelocation[relocsList.size()];
        relocsList.toArray(relocs);
        return true;
    }

	/**
	 * Returns the array of base relocations defined in this base relocation data directory.
	 * @return the array of base relocations defined in this base relocation data directory
	 */
    public BaseRelocation [] getBaseRelocations() {
        return relocs;
    }

    /**
     * @see ghidra.app.util.bin.StructConverter#toDataType()
     */
    @Override
    public DataType toDataType() throws DuplicateNameException {
        StructureDataType struct = new StructureDataType(NAME, 0);
        for (BaseRelocation reloc : relocs) {
            struct.add(reloc.toDataType());
        }
        struct.setCategoryPath(new CategoryPath("/PE"));
        return struct;
    }

	/**
	 * Removes all base relocations from this base relocation
	 * directory.
	 */
	public void removeAllRelocations() {
		relocs = new BaseRelocation[0];
		size = 0;
	}

	/**
	 * Create a new base relocation using the specified
	 * virtual address.
	 * @param va the virtual address of the new base relocation
	 * @return the new base relocation
	 */
	public BaseRelocation createBaseRelocation(int va) {
		return new BaseRelocation(va);
	}

	/**
	 * Adds the specified base relocation.
	 * @param reloc the new base relocation
	 */
	public void addBaseRelocation(BaseRelocation reloc) {
		size += reloc.getSizeOfBlock();

		BaseRelocation [] tmp = new BaseRelocation[relocs.length+1];
		System.arraycopy(relocs, 0, tmp, 0, relocs.length);
		tmp[tmp.length-1] = reloc;
		relocs = tmp;
	}

	/**
	 * @see ghidra.app.util.bin.ByteArrayConverter#toBytes(ghidra.util.DataConverter)
	 */
	public byte[] toBytes(DataConverter dc) {
		int lsize = 0;
		for (BaseRelocation reloc : relocs) {
			lsize += reloc.getSizeOfBlock();
		}

		byte [] bytes = new byte[lsize];
		int pos = 0;
		for (BaseRelocation reloc : relocs) {
			byte [] relocBytes = reloc.toBytes(dc);
			System.arraycopy(relocBytes, 0, bytes, pos, relocBytes.length);
			pos += relocBytes.length;
		}

		return bytes;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/BoundImportDataDirectory.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.*;

import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressSpace;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Program;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.DataConverter;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;
import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;

/**
 * Points to an array of IMAGE_BOUND_IMPORT_DESCRIPTORs.
 */
public class BoundImportDataDirectory extends DataDirectory {
    private final static String NAME = "IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT";

    private BoundImportDescriptor [] descriptors;
    private LinkedHashMap<String,Short> nameHash;

    static BoundImportDataDirectory createBoundImportDataDirectory(
            NTHeader ntHeader, FactoryBundledWithBinaryReader reader)
            throws IOException {
        BoundImportDataDirectory boundImportDataDirectory = (BoundImportDataDirectory) reader.getFactory().create(BoundImportDataDirectory.class);
        boundImportDataDirectory.initBoundImportDataDirectory(ntHeader, reader);
        return boundImportDataDirectory;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public BoundImportDataDirectory() {}

	private void initBoundImportDataDirectory(NTHeader ntHeader, FactoryBundledWithBinaryReader reader) throws IOException {
		processDataDirectory(ntHeader, reader);

        if (descriptors == null) descriptors = new BoundImportDescriptor[0];
	}

    /**
     * @see ghidra.app.util.bin.StructConverter#toDataType()
     */
    @Override
    public DataType toDataType() throws DuplicateNameException, IOException {
        StructureDataType struct = new StructureDataType(NAME, 0);
        for (BoundImportDescriptor descriptor : descriptors) {
            struct.add(descriptor.toDataType());
        }
        struct.setCategoryPath(new CategoryPath("/PE"));
        return struct;
    }

	/**
	 * Returns the array of bound import descriptors defined in this bound import data directory.
	 * @return the array of bound import descriptors defined in this bound import data directory
	 */
    public BoundImportDescriptor [] getBoundImportDescriptors() {
        return descriptors;
    }

    @Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor,
			MessageLog log, NTHeader ntHeader) throws DuplicateNameException, CodeUnitInsertionException {

    	monitor.setMessage(program.getName()+": bound import(s)...");
		Address addr = PeUtils.getMarkupAddress(program, isBinary, ntHeader, virtualAddress);
		if (!program.getMemory().contains(addr)) {
			return;
		}
		createDirectoryBookmark(program, addr);

		AddressSpace space = program.getAddressFactory().getDefaultAddressSpace();

		for (BoundImportDescriptor descriptor : descriptors) {
            if (monitor.isCancelled()) {
                return;
            }
            DataType dt = descriptor.toDataType();
			PeUtils.createData(program, addr, dt, log);
            addr = addr.add(dt.getLength());

            long namePtr = descriptor.getOffsetModuleName()+virtualAddress;
            Address nameAddr = space.getAddress(va(namePtr, isBinary));
            createTerminatedString(program, nameAddr, false, log);
        }

		BoundImportDescriptor terminator = new BoundImportDescriptor();
		PeUtils.createData(program, addr, terminator.toDataType(), log);
    }

    @Override
    public String getDirectoryName() {
    	return NAME;
    }

    @Override
	public boolean parse() throws IOException {
    	nameHash = new LinkedHashMap<String,Short>();
    	
        int rva = getVirtualAddress();
        int ptr = getVirtualAddress();
        if (rva <= 0) {
        	if (rva < 0) {
        		Msg.error(this, "Invalid RVA "+rva);
        	}
        	return false;
        }

        List<BoundImportDescriptor> descriptorsList = new ArrayList<BoundImportDescriptor>();
        while (true) {
        	if (ptr < 0) { 
            	Msg.error(this, "Invalid file index "+ptr);
            	break;
        	}
            BoundImportDescriptor bid = BoundImportDescriptor.createBoundImportDescriptor(reader, ptr, rva);

            if (bid.getTimeDateStamp() == 0) break;
            if (bid.getNumberOfModuleForwarderRefs() < 0) break;

            descriptorsList.add(bid);

            // increment ptr by 1 BoundImportDescriptor and
            // the number of forwards refs located
            //
            ptr += BoundImportDescriptor.IMAGE_SIZEOF_BOUND_IMPORT_DESCRIPTOR;
            ptr += (bid.getNumberOfModuleForwarderRefs() * BoundImportForwarderRef.IMAGE_SIZEOF_BOUND_IMPORT_FORWARDER_REF);
        }

        descriptors = new BoundImportDescriptor[descriptorsList.size()];
        descriptorsList.toArray(descriptors);

		buildNameHash();
		return true;
    }

	@Override
    int rvaToPointer() {
		return virtualAddress;
	}

	@Override
    public void writeBytes(RandomAccessFile raf, DataConverter dc, PortableExecutable template) throws IOException {
		if (size == 0) {
			return;
		}

		//this is the actual byte position in the file
		raf.seek(rvaToPointer());

		//write the descriptors...
		for (BoundImportDescriptor descriptor : descriptors) {
			raf.write(dc.getBytes(descriptor.getTimeDateStamp()));
			raf.write(dc.getBytes(descriptor.getOffsetModuleName()));
			raf.write(dc.getBytes(descriptor.getNumberOfModuleForwarderRefs()));
			for (int j = 0 ; j < descriptor.getNumberOfModuleForwarderRefs() ; ++j) {
				BoundImportForwarderRef forwarder = descriptor.getBoundImportForwarderRef(j);
				raf.write(dc.getBytes(forwarder.getTimeDateStamp()));
				raf.write(dc.getBytes(forwarder.getOffsetModuleName()));
				raf.write(dc.getBytes(forwarder.getReserved()));
			}
		}

		int zeroInt = 0;
		short zeroShort = 0;

		//write a terminating descriptor...
		raf.write(dc.getBytes(zeroInt));
		raf.write(dc.getBytes(zeroShort));
		raf.write(dc.getBytes(zeroShort));

		//write the dll names...
		Iterator<String> iter = nameHash.keySet().iterator();
		short prevOffset = 0;
		while (iter.hasNext()) {
			String name = iter.next();
			Short currOffset = nameHash.get(name);
			if (currOffset.shortValue() < prevOffset) {
				throw new IllegalArgumentException();
			}
			prevOffset = currOffset.shortValue();

			raf.write(name.getBytes());
			raf.write((byte)0);//null-terminator
		}
	}

	void updatePointers(int offset) {
		virtualAddress += offset;
	}

	public void addDescriptor(BoundImportDescriptor bid) {
		BoundImportDescriptor [] tmp = new BoundImportDescriptor[descriptors.length+1];
		System.arraycopy(descriptors, 0, tmp, 0, descriptors.length);
		tmp[tmp.length-1] = bid;
		descriptors = tmp;

		size +=  BoundImportDescriptor.IMAGE_SIZEOF_BOUND_IMPORT_DESCRIPTOR;
		size += (bid.getNumberOfModuleForwarderRefs() * BoundImportForwarderRef.IMAGE_SIZEOF_BOUND_IMPORT_FORWARDER_REF);
		size += (bid.getModuleName().length() + 1);

		buildNameHash();
	}

	private void buildNameHash() {
		nameHash.clear();

		int pos = (descriptors.length + 1) * BoundImportDescriptor.IMAGE_SIZEOF_BOUND_IMPORT_DESCRIPTOR;
		for (BoundImportDescriptor descriptor : descriptors) {
			pos += (descriptor.getNumberOfModuleForwarderRefs() * BoundImportForwarderRef.IMAGE_SIZEOF_BOUND_IMPORT_FORWARDER_REF);
		}

		for (BoundImportDescriptor descriptor : descriptors) {
			Short offset = nameHash.get(descriptor.getModuleName());
			if (offset != null) {
				descriptor.setOffsetModuleName(offset.shortValue());
			}
			else {
				String moduleName = descriptor.getModuleName();
				if (moduleName != null && moduleName.length() > 0) {
					nameHash.put(moduleName, new Short((short)pos));
					descriptor.setOffsetModuleName((short)pos);
					pos += (descriptor.getModuleName().length() + 1);
				}
			}
			
			for (int j = 0 ; j < descriptor.getNumberOfModuleForwarderRefs() ; ++j) {
				BoundImportForwarderRef forwarder = descriptor.getBoundImportForwarderRef(j);
				if (forwarder == null) {
					continue;
				}
				offset = nameHash.get(forwarder.getModuleName());
				if (offset != null) {
					forwarder.setOffsetModuleName(offset.shortValue());
				}
				else {
					String moduleName = forwarder.getModuleName();
					if (moduleName != null && moduleName.length() > 0) {
						nameHash.put(moduleName, new Short((short)pos));
						forwarder.setOffsetModuleName((short)pos);
						pos += (forwarder.getModuleName().length() + 1);
					}
				}
			}
		}
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/BoundImportDescriptor.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.program.model.data.*;
import ghidra.util.*;
import ghidra.util.exception.DuplicateNameException;

/**
 * A class to represent the 
 * <code>IMAGE_BOUND_IMPORT_DESCRIPTOR</code>
 * data structure defined in <b><code>winnt.h</code></b>.
 * <p>
 * <pre>
 * typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
 *     DWORD   TimeDateStamp;
 *     WORD    OffsetModuleName;
 *     WORD    NumberOfModuleForwarderRefs;
 *     // Array of zero or more IMAGE_BOUND_FORWARDER_REF follows
 * } IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;
 * </pre>
 */
public class BoundImportDescriptor implements StructConverter, ByteArrayConverter {
	/**
	 * The name to use when converting into a structure data type.
	 */
    public final static String NAME = "IMAGE_BOUND_IMPORT_DESCRIPTOR";
	/**
	 * The size of the <code>IMAGE_BOUND_IMPORT_DESCRIPTOR</code> in bytes.
	 */
    public final static int IMAGE_SIZEOF_BOUND_IMPORT_DESCRIPTOR = 8;

    private String moduleName;
    private int    timeDateStamp;
    private short  offsetModuleName;
    private short  numberOfModuleForwarderRefs;

    private List<BoundImportForwarderRef> forwarders = new ArrayList<BoundImportForwarderRef>();

    static BoundImportDescriptor createBoundImportDescriptor(
            FactoryBundledWithBinaryReader reader, int readerIndex,
            int biddIndex) throws IOException {
        BoundImportDescriptor boundImportDescriptor = (BoundImportDescriptor) reader.getFactory().create(BoundImportDescriptor.class);
        boundImportDescriptor.initBoundImportDescriptor(reader, readerIndex, biddIndex);
        return boundImportDescriptor;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public BoundImportDescriptor() {}

    private void initBoundImportDescriptor(FactoryBundledWithBinaryReader reader, int readerIndex, int biddIndex) throws IOException {
        timeDateStamp               = reader.readInt  (readerIndex); readerIndex += BinaryReader.SIZEOF_INT;
        offsetModuleName            = reader.readShort(readerIndex); readerIndex += BinaryReader.SIZEOF_SHORT;
        numberOfModuleForwarderRefs = reader.readShort(readerIndex); readerIndex += BinaryReader.SIZEOF_SHORT;
        if (offsetModuleName < 0) {
        	Msg.error(this, "Invalid offsetModuleName "+offsetModuleName);
        	return;
        }

        moduleName = reader.readAsciiString(biddIndex + offsetModuleName);

        for (int i = 0 ; i < numberOfModuleForwarderRefs ; ++i) {
            forwarders.add(BoundImportForwarderRef.createBoundImportForwarderRef(reader, readerIndex, biddIndex));
            readerIndex += BoundImportForwarderRef.IMAGE_SIZEOF_BOUND_IMPORT_FORWARDER_REF;
        }
    }

	public BoundImportDescriptor(String name, int timeDateStamp) {
		this.moduleName = name;
		this.timeDateStamp = timeDateStamp;
	}

	/**
	 * Returns the time/data stamp of the imported DLL.
	 * @return the time/data stamp of the imported DLL
	 */
    public int getTimeDateStamp() {
        return timeDateStamp;
    }

	/**
	 * Returns an offset to a string with the name of the imported DLL. 
	 * @return an offset to a string with the name
	 */
    public short getOffsetModuleName() {
        return offsetModuleName;
    }

	void setOffsetModuleName(short offset) {
		this.offsetModuleName = offset;
	}

	/**
	 * Returns the number of IMAGE_BOUND_FORWARDER_REF 
	 * structures that immediately follow this structure. 
	 * @return the number of IMAGE_BOUND_FORWARDER_REF structures that immediately follow this structure
	 */
    public short getNumberOfModuleForwarderRefs() {
        return numberOfModuleForwarderRefs;
    }

	/**
	 * Returns the module name of the imported DLL.
	 * @return the module name of the imported DLL
	 */
    public String getModuleName() {
        return moduleName;
    }

	/**
	 * Returns the forwarder ref at the specified index
	 * @param index the index of the forwarder ref
	 * @return the forwarder ref at the specified index
	 */
    public BoundImportForwarderRef getBoundImportForwarderRef(int index) {
    	if (index >= forwarders.size()) {
    		return null;
    	}
        return forwarders.get(index);
    }

	/**
	 * @see java.lang.Object#toString()
	 */
	@Override
    public String toString() {
		StringBuffer buffer = new StringBuffer();
		buffer.append("TimeStamp:"+Integer.toHexString(timeDateStamp)+",");
		buffer.append("OffsetModuleName:"+Integer.toHexString(Conv.shortToInt(offsetModuleName))+"["+moduleName+"]"+",");
		buffer.append("NumberOfModuleForwarderRefs:"+Integer.toHexString(Conv.shortToInt(numberOfModuleForwarderRefs)));
		buffer.append("\n");
		for(int i=0;i<forwarders.size();i++) {
			BoundImportForwarderRef ref = forwarders.get(i);
			buffer.append("\t"+"TimeStamp:"+Integer.toHexString(ref.getTimeDateStamp())+",");
			buffer.append("\t"+"OffsetModuleName:"+Integer.toHexString(Conv.shortToInt(ref.getOffsetModuleName()))+"["+ref.getModuleName()+"]"+",");
			buffer.append("\t"+"Reserved:"+Integer.toHexString(Conv.shortToInt(ref.getReserved())));
			buffer.append("\n");
		}
		return buffer.toString();
	}

    /**
     * @see ghidra.app.util.bin.StructConverter#toDataType()
     */
    public DataType toDataType() throws DuplicateNameException {
        StructureDataType struct = new StructureDataType(NAME+"_"+forwarders.size(), 0);

        struct.add(DWORD,"TimeDateStamp",null);
        struct.add( WORD,"OffsetModuleName",null);
        struct.add( WORD,"NumberOfModuleForwarderRefs",null);

        for(int i=0;i<forwarders.size();i++) {
            BoundImportForwarderRef ref = forwarders.get(i);
            struct.add(ref.toDataType());
		}

        struct.setCategoryPath(new CategoryPath("/PE"));

        return struct;
    }

	/**
	 * @see ghidra.app.util.bin.ByteArrayConverter#toBytes(ghidra.util.DataConverter)
	 */
	public byte [] toBytes(DataConverter dc) {
		byte [] bytes = new byte[IMAGE_SIZEOF_BOUND_IMPORT_DESCRIPTOR + 
			(numberOfModuleForwarderRefs*BoundImportForwarderRef.IMAGE_SIZEOF_BOUND_IMPORT_FORWARDER_REF)];
		int pos = 0;
		dc.getBytes(timeDateStamp, bytes, pos);
		pos += BinaryReader.SIZEOF_INT;
		dc.getBytes(offsetModuleName, bytes, pos);
		pos += BinaryReader.SIZEOF_SHORT;
		dc.getBytes(numberOfModuleForwarderRefs, bytes, pos);
		pos += BinaryReader.SIZEOF_SHORT;
		for (int i = 0; i < numberOfModuleForwarderRefs; i++) {
			byte [] refBytes = forwarders.get(i).toBytes(dc);
			System.arraycopy(refBytes, 0, bytes, pos, refBytes.length);
			pos += refBytes.length;
		}
		return bytes;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/BoundImportForwarderRef.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.program.model.data.*;
import ghidra.util.DataConverter;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;

/**
 * A class to represent the 
 * <code>IMAGE_BOUND_FORWARDER_REF</code>
 * data structure defined in <b><code>winnt.h</code></b>.
 * <p>
 * <pre>
 * typedef struct _IMAGE_BOUND_FORWARDER_REF {
 *     DWORD   TimeDateStamp;
 *     WORD    OffsetModuleName;
 *     WORD    Reserved;
 * } IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;
 * </pre>
 */
public class BoundImportForwarderRef implements StructConverter, ByteArrayConverter {
	/**
	 * The name to use when converting into a structure data type.
	 */
    public final static String NAME = "IMAGE_BOUND_FORWARDER_REF";
	/**
	 * The size of the <code>IMAGE_BOUND_FORWARDER_REF</code> in bytes.
	 */
    public final static int IMAGE_SIZEOF_BOUND_IMPORT_FORWARDER_REF = 8;

    private int timeDateStamp;
    private short offsetModuleName;
    private short reserved;
    private String moduleName;

	/**
	 * 
	 * @param reader      the binary reader
	 * @param readerIndex the index into the binary reader
	 * @param biddIndex   the index where the bound import data directory begins
	 */
    static BoundImportForwarderRef createBoundImportForwarderRef(
            FactoryBundledWithBinaryReader reader, int readerIndex,
            int biddIndex) throws IOException {
        BoundImportForwarderRef boundImportForwarderRef = (BoundImportForwarderRef) reader.getFactory().create(BoundImportForwarderRef.class);
        boundImportForwarderRef.initBoundImportForwarderRef(reader, readerIndex, biddIndex);
        return boundImportForwarderRef;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public BoundImportForwarderRef() {}

    private void initBoundImportForwarderRef(FactoryBundledWithBinaryReader reader, int readerIndex, int biddIndex) throws IOException {
        timeDateStamp    = reader.readInt  (readerIndex); readerIndex += BinaryReader.SIZEOF_INT;
        offsetModuleName = reader.readShort(readerIndex); readerIndex += BinaryReader.SIZEOF_SHORT;
        reserved         = reader.readShort(readerIndex); readerIndex += BinaryReader.SIZEOF_SHORT;
        if (offsetModuleName < 0) {
        	Msg.error(this, "Invalid offsetModuleName "+Integer.toHexString(offsetModuleName));
        	return;
        }

        moduleName = reader.readAsciiString(biddIndex + offsetModuleName);
    }

    /**
     * @see ghidra.app.util.bin.ByteArrayConverter#toBytes(ghidra.util.DataConverter)
     */
	public byte [] toBytes(DataConverter dc) {
		byte [] bytes = new byte[IMAGE_SIZEOF_BOUND_IMPORT_FORWARDER_REF];
		int pos = 0;
		dc.getBytes(timeDateStamp, bytes, pos);
		pos += BinaryReader.SIZEOF_INT;
		dc.getBytes(offsetModuleName, bytes, pos);
		pos += BinaryReader.SIZEOF_SHORT;
		dc.getBytes(reserved, bytes, pos);
		pos += BinaryReader.SIZEOF_SHORT;
		return bytes;
	}

	/**
	 * Returns the time stamp.
	 * @return the time stamp
	 */
    public int getTimeDateStamp() {
        return timeDateStamp;
    }

	/**
	 * Returns the offset, relative the beginning of the Bound Import Table,
	 * to the import name.
	 * @return the offset to the import name
	 */
    public short getOffsetModuleName() {
        return offsetModuleName;
    }

	void setOffsetModuleName(short offset) {
		this.offsetModuleName = offset;
	}

	/**
	 * Returns the reserved word (use unknown).
	 * @return the reserved word
	 */
    public short getReserved() {
        return reserved;
    }

	/**
	 * Returns the imported module name.
	 * @return the imported module name
	 */
    public String getModuleName() {
        return moduleName;
    }

    /**
     * @see ghidra.app.util.bin.StructConverter#toDataType()
     */
    public DataType toDataType() throws DuplicateNameException {
        StructureDataType struct = new StructureDataType(NAME, 0);

        struct.add(DWORD,"TimeDateStamp",null);
        struct.add(WORD,"OffsetModuleName",null);
        struct.add(WORD,"Reserved",null);

        struct.setCategoryPath(new CategoryPath("/PE"));

        return struct;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/COMDescriptorDataDirectory.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;

import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;
import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;

/**
 * This value has been renamed to IMAGE_DIRECTORY_ENTRY_COMHEADER.
 */
public class COMDescriptorDataDirectory extends DataDirectory {
	private final static String NAME = "IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR";

	private ImageCor20Header header;

	static COMDescriptorDataDirectory createCOMDescriptorDataDirectory(NTHeader ntHeader,
			FactoryBundledWithBinaryReader reader) throws IOException {
		COMDescriptorDataDirectory comDescriptorDataDirectory =
			(COMDescriptorDataDirectory) reader.getFactory().create(
				COMDescriptorDataDirectory.class);
		comDescriptorDataDirectory.initCOMDescriptorDataDirectory(ntHeader, reader);
		return comDescriptorDataDirectory;
	}

	/**
	 * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
	 */
	public COMDescriptorDataDirectory() {
	}

	private void initCOMDescriptorDataDirectory(NTHeader ntHeader,
			FactoryBundledWithBinaryReader reader) throws IOException {
		this.ntHeader = ntHeader;
		processDataDirectory(ntHeader, reader);
	}

	public ImageCor20Header getHeader() {
		return header;
	}

	@Override
	public String getDirectoryName() {
		return NAME;
	}

	@Override
	public boolean parse() throws IOException {
		int ptr = getPointer();
		if (ptr < 0) {
			return false;
		}

		header = ImageCor20Header.createImageCor20Header(reader, ptr, ntHeader);

		boolean ret = false;
		if (ntHeader.shouldParseCliHeaders()) {
			ret = header.parse();
		}
		return ret;
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor,
			MessageLog log, NTHeader ntHeader) throws DuplicateNameException, CodeUnitInsertionException,
			IOException, MemoryAccessException {

		monitor.setMessage("[" + program.getName() + "]: com descriptor(s)...");
		Address addr = PeUtils.getMarkupAddress(program, isBinary, ntHeader, virtualAddress);
		if (!program.getMemory().contains(addr)) {
			return;
		}
		createDirectoryBookmark(program, addr);
		DataType dt = header.toDataType();
		PeUtils.createData(program, addr, dt, log);

		if (hasParsed) {
			header.markup(program, isBinary, monitor, log, ntHeader);
		}
	}

	/**
	 * @see ghidra.app.util.bin.StructConverter#toDataType()
	 */
	@Override
	public DataType toDataType() throws DuplicateNameException {
		StructureDataType struct = new StructureDataType(NAME, 0);
		struct.add(new ArrayDataType(BYTE, size, 1), "COM", null);
		struct.setCategoryPath(new CategoryPath("/PE"));
		return struct;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/Constants.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;
/**
 * Constants used in the data structures of the PE.
 * 
 * 
 */
public interface Constants {
	/**A 64-bit flag.*/
	public final static long IMAGE_ORDINAL_FLAG64 = 0x8000000000000000L;
	/**A 32-bit flag.*/
	public final static long IMAGE_ORDINAL_FLAG32 =         0x80000000L;

	/**
	 * The magic number for PE files..
	 */
	public final static int IMAGE_NT_SIGNATURE =  0x00004550; // PE00
	/**
	 * The magic number for OS/2 files.
	 */
	public final static int IMAGE_OS2_SIGNATURE = 0x454E; // NE
	/**
	 * The magic number for little endian OS/2 files.
	 */
	public final static int IMAGE_OS2_SIGNATURE_LE = 0x454C; // LE
	/**
	 * The magic number for VXD files.
	 */
	public final static int IMAGE_VXD_SIGNATURE = 0x454C; // LE

	/**
	 * The 32-bit optional header magic number.
	 */
	public final static short IMAGE_NT_OPTIONAL_HDR32_MAGIC = 0x10b;
	/**
	 * The 64-bit optional header magic number.
	 */
	public final static short IMAGE_NT_OPTIONAL_HDR64_MAGIC = 0x20b;
	/**
	 * The ROM optional header magic number.
	 */
	public final static short IMAGE_ROM_OPTIONAL_HDR_MAGIC = 0x107;


	/**
	 * The size of the ROM optional header.
	 */
	public final static int IMAGE_SIZEOF_ROM_OPTIONAL_HEADER = 56;
	/**
	 * The size of the standard optional header.
	 */
	public final static int IMAGE_SIZEOF_STD_OPTIONAL_HEADER = 28;
	/**
	 * The size of the 32-bit optional header, in bytes.
	 */
	public final static int IMAGE_SIZEOF_NT_OPTIONAL32_HEADER =  224;
	/**
	 * The size of the 64-bit optional header, in bytes.
	 */
	public final static int IMAGE_SIZEOF_NT_OPTIONAL64_HEADER =  240;


	/**
	 * The size of the archive start header.
	 */
	public final static byte IMAGE_ARCHIVE_START_SIZE = 8;
	/**
	 * The archive start magic value.
	 */
	public final static String IMAGE_ARCHIVE_START = "!<arch>\n";
	/**
	 * The archive end magic value.
	 */
	public final static String IMAGE_ARCHIVE_END = "`\n";
	/**
	 * The archive padding.
	 */
	public final static String IMAGE_ARCHIVE_PAD = "\n";
	/**
	 * The archive linker member.
	 */
	public final static String IMAGE_ARCHIVE_LINKER_MEMBER = "/               ";
	/**
	 * The archive long names member.
	 */
	public final static String IMAGE_ARCHIVE_LONGNAMES_MEMBER = "//              ";

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/ControlFlowGuard.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;
import net.jubjubnest.minidump.contrib.new_.ModuleBaseOffset32DataType;
import net.jubjubnest.minidump.contrib.pe.LoadConfigDirectory.GuardFlags;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.*;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.ImageBaseOffset32DataType;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.Memory;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.program.model.symbol.SourceType;
import ghidra.program.model.symbol.SymbolTable;
import ghidra.util.Msg;
import ghidra.util.exception.InvalidInputException;

/**
 * ControlFlowGuard is a platform security feature that was created to combat memory
 * corruption vulnerabilities.
 * <p>
 * ReturnFlowGuard was introduced as an addition to ControlFlowGuard in the Windows 10
 * Creator's update. 
 */
public class ControlFlowGuard {

	/**
	 * Perform markup on the supported ControlFlowGuard and ReturnFlowGuard functions and 
	 * tables, if they exist.
	 * 
	 * @param lcd The PE LoadConfigDirectory.
	 * @param program The program.
	 * @param log The log.
	 * @param ntHeader The PE NTHeader.
	 */
	public static void markup(LoadConfigDirectory lcd, Program program, MessageLog log,
			NTHeader ntHeader) {

		boolean is64bit = ntHeader.getOptionalHeader().is64bit();
		AddressSpace space = program.getAddressFactory().getDefaultAddressSpace();
		Memory mem = program.getMemory();
		SymbolTable symbolTable = program.getSymbolTable();

		// ControlFlowGuard
		markupCfgCheckFunction(lcd, is64bit, space, mem, symbolTable);
		markupCfgDispatchFunction(lcd, is64bit, space, mem, symbolTable);
		markupCfgFunctionTable(lcd, ntHeader.getLoadInfo().sharedProgram, program, log);
		
		// ReturnFlowGuard
		markupRfgFailureRoutine(lcd, space, symbolTable);
		markupRfgDefaultFailureRoutine(lcd, is64bit, space, mem, symbolTable);
		markupRfgDefaultStackPointerFunction(lcd, is64bit, space, mem, symbolTable);
	}

	/**
	 * Performs markup on the ControlFlowGuard check function, if it exists.
	 * 
	 * @param lcd The PE LoadConfigDirectory.
	 * @param is64bit True if the PE is 64-bit; false if it's 32-bit.
	 * @param space The program's address space.
	 * @param mem The program's memory.
	 * @param symbolTable The program's symbol table.
	 */
	private static void markupCfgCheckFunction(LoadConfigDirectory lcd, boolean is64bit,
			AddressSpace space,
			Memory mem, SymbolTable symbolTable) {

		if (lcd.getCfgCheckFunctionPointer() == 0) {
			return;
		}

		try {
			Address functionPointerAddr = space.getAddress(lcd.getCfgCheckFunctionPointer());
			Address functionAddr = space.getAddress(
				is64bit ? mem.getLong(functionPointerAddr) : mem.getInt(functionPointerAddr));
			symbolTable.createLabel(functionAddr, "_guard_check_icall", SourceType.IMPORTED);
		}
		catch (MemoryAccessException | AddressOutOfBoundsException | InvalidInputException e) {
			Msg.warn(ControlFlowGuard.class, "Unable to label ControlFlowGuard check function.", e);
		}
	}

	/**
	 * Performs markup on the ControlFlowGuard dispatch function, if it exists.
	 * 
	 * @param lcd The PE LoadConfigDirectory.
	 * @param is64bit True if the PE is 64-bit; false if it's 32-bit.
	 * @param space The program's address space.
	 * @param mem The program's memory.
	 * @param symbolTable The program's symbol table.
	 */
	private static void markupCfgDispatchFunction(LoadConfigDirectory lcd, boolean is64bit,
			AddressSpace space, Memory mem, SymbolTable symbolTable) {

		if (lcd.getCfgDispatchFunctionPointer() == 0) {
			return;
		}

		try {
			Address functionPointerAddr = space.getAddress(lcd.getCfgDispatchFunctionPointer());
			Address functionAddr = space.getAddress(
				is64bit ? mem.getLong(functionPointerAddr) : mem.getInt(functionPointerAddr));
			symbolTable.createLabel(functionAddr, "_guard_dispatch_icall", SourceType.IMPORTED);
		}
		catch (MemoryAccessException | AddressOutOfBoundsException | InvalidInputException e) {
			Msg.warn(ControlFlowGuard.class, "Unable to label ControlFlowGuard dispatch function.",
				e);
		}
	}

	/**
	 * Performs markup on the ControlFlowGuard function table, if it exists.
	 * 
	 * @param lcd The PE LoadConfigDirectory.
	 * @param loadInfo True if the Program is shared between multiple modules.
	 * @param program The program.
	 * @param log The log.
	 */
	private static void markupCfgFunctionTable(LoadConfigDirectory lcd, boolean sharedProgram, Program program,
			MessageLog log) {

		final int IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK = 0xf0000000;
		final int IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT = 28;

		long tablePointer = lcd.getCfgFunctionTablePointer();
		long functionCount = lcd.getCfgFunctionCount();

		if (tablePointer == 0 || functionCount <= 0) {
			return;
		}

		try {
			Address tableAddr =
				program.getAddressFactory().getDefaultAddressSpace().getAddress(tablePointer);

			// Label the start of the table
			program.getSymbolTable().createLabel(tableAddr, "GuardCFFunctionTable",
				SourceType.IMPORTED);

			// Each table entry is an RVA (32-bit image base offset), followed by 'n' extra bytes
			GuardFlags guardFlags = lcd.getCfgGuardFlags();
			int n = (guardFlags.getFlags() &
				IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK) >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT;
			DataType xbo32 = sharedProgram
					? new ModuleBaseOffset32DataType()
					: new ImageBaseOffset32DataType();
			for (long i = 0; i < functionCount; i++) {
				Data d = PeUtils.createData(program, tableAddr.add(i * (xbo32.getLength() + n)),
					xbo32, log);
				if (d == null) {
					// If we failed to create data on a table entry, just assume the rest will fail
					break;
				}
			}
		}
		catch (AddressOutOfBoundsException | InvalidInputException e) {
			Msg.warn(ControlFlowGuard.class, "Unable to label ControlFlowGuard function table.", e);
		}
	}

	/**
	 * Performs markup on the ReturnFlowGuard failure routine, if it exists.
	 * 
	 * @param lcd The PE LoadConfigDirectory.
	 * @param space The program's address space.
	 * @param symbolTable The program's symbol table.
	 */
	private static void markupRfgFailureRoutine(LoadConfigDirectory lcd, AddressSpace space,
			SymbolTable symbolTable) {

		if (lcd.getRfgFailureRoutine() == 0) {
			return;
		}

		try {
			Address routineAddr = space.getAddress(lcd.getRfgFailureRoutine());
			symbolTable.createLabel(routineAddr, "_guard_ss_verify_failure", SourceType.IMPORTED);
		}
		catch (AddressOutOfBoundsException | InvalidInputException e) {
			Msg.warn(ControlFlowGuard.class, "Unable to label ReturnFlowGuard failure routine.", e);
		}
	}

	/**
	 * Performs markup on the ReturnFlowGuard "default" failure routine function, if it exists.
	 * 
	 * @param lcd The PE LoadConfigDirectory.
	 * @param is64bit True if the PE is 64-bit; false if it's 32-bit.
	 * @param space The program's address space.
	 * @param mem The program's memory.
	 * @param symbolTable The program's symbol table.
	 */
	private static void markupRfgDefaultFailureRoutine(LoadConfigDirectory lcd, boolean is64bit,
			AddressSpace space, Memory mem, SymbolTable symbolTable) {

		if (lcd.getRfgFailureRoutineFunctionPointer() == 0) {
			return;
		}

		try {
			Address functionPointerAddr =
				space.getAddress(lcd.getRfgFailureRoutineFunctionPointer());
			Address functionAddr = space.getAddress(
				is64bit ? mem.getLong(functionPointerAddr) : mem.getInt(functionPointerAddr));
			symbolTable.createLabel(functionAddr, "_guard_ss_verify_failure_default",
				SourceType.IMPORTED);
		}
		catch (MemoryAccessException | AddressOutOfBoundsException | InvalidInputException e) {
			Msg.warn(ControlFlowGuard.class,
				"Unable to label ReturnFlowGuard default failure routine.", e);
		}
	}

	/**
	 * Performs markup on the ReturnFlowGuard verify stack pointer function, if it exists.
	 * 
	 * @param lcd The PE LoadConfigDirectory.
	 * @param is64bit True if the PE is 64-bit; false if it's 32-bit.
	 * @param space The program's address space.
	 * @param mem The program's memory.
	 * @param symbolTable The program's symbol table.
	 */
	private static void markupRfgDefaultStackPointerFunction(LoadConfigDirectory lcd,
			boolean is64bit, AddressSpace space, Memory mem, SymbolTable symbolTable) {

		if (lcd.getRfgVerifyStackPointerFunctionPointer() == 0) {
			return;
		}

		try {
			Address functionPointerAddr =
				space.getAddress(lcd.getRfgVerifyStackPointerFunctionPointer());
			Address functionAddr = space.getAddress(
				is64bit ? mem.getLong(functionPointerAddr) : mem.getInt(functionPointerAddr));
			symbolTable.createLabel(functionAddr, "_guard_ss_verify_sp_default",
				SourceType.IMPORTED);
		}
		catch (MemoryAccessException | AddressOutOfBoundsException | InvalidInputException e) {
			Msg.warn(ControlFlowGuard.class,
				"Unable to label ReturnFlowGuard verify stack pointer function.", e);
		}
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/DataDirectory.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;
import java.io.RandomAccessFile;

import ghidra.app.util.bin.StructConverter;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.TerminatedStringDataType;
import ghidra.program.model.listing.*;
import ghidra.util.DataConverter;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;
import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;

/**
 * An abstract base class to represent the
 * <code>IMAGE_DATA_DIRECTORY</code>
 * data structure defined in <b><code>winnt.h</code></b>.
 * <pre>
 * typedef struct _IMAGE_DATA_DIRECTORY {
 *     DWORD   VirtualAddress;
 *     DWORD   Size;
 * } IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; {
 * </pre>
 *
 *
 */
public abstract class DataDirectory implements StructConverter, PeMarkupable {
	/**
	 * The name to use when converting into a structure data type.
	 */
	protected final static String TITLE = "IMAGE_DATA_DIRECTORY";

	/**
	 * The size of the data directory, in bytes.
	 */
	public final static byte IMAGE_SIZEOF_IMAGE_DIRECTORY_ENTRY = 8;

	protected NTHeader ntHeader;
	protected FactoryBundledWithBinaryReader reader;
	protected int virtualAddress;
	protected int size;
	protected boolean hasParsed = false;

	protected void processDataDirectory(NTHeader ntHeader, FactoryBundledWithBinaryReader reader)
			throws IOException {
		this.ntHeader = ntHeader;
		this.reader = reader;

		virtualAddress = reader.readNextInt();
		size = reader.readNextInt();

		if (size < 0 || !ntHeader.checkRVA(virtualAddress)) {
			if (size != 0) {
				Msg.warn(this,
					"DataDirectory RVA outside of image (RVA: 0x" +
						Integer.toHexString(virtualAddress) + ", Size: 0x" +
						Integer.toHexString(size) + ").  Could be a file-only data directory.");
				size = 0;
			}
			return;
		}
		hasParsed = parse();
	}

	public abstract String getDirectoryName();

	/**
	 * Parses this data directory.
	 *
	 * @return True if parsing completed successfully; otherwise, false.
	 * @throws IOException If there was an IO problem while parsing.
	 */
	public abstract boolean parse() throws IOException;

	protected long va(long va, boolean isBinary) {
		if (isBinary) {
			long ptr = ntHeader.rvaToPointer(va);
			if (ptr < 0 && virtualAddress > 0) { //directory does not appear inside a loadable section
				return va;
			}
			return ptr;
		}

		long new_va = va + ntHeader.getOptionalHeader().getImageBase();
		// make sure didn't wrap
		if (ntHeader.getOptionalHeader().is64bit()) {
			return new_va;
		}
		return (new_va & 0xffffffffL);
	}

	protected void createTerminatedString(Program program, Address addr, boolean label,
			MessageLog log) {
		PeUtils.createData(program, addr, new TerminatedStringDataType(), log);
	}

	protected void createDirectoryBookmark(Program program, Address addr) {
		program.getBookmarkManager().setBookmark(addr, BookmarkType.INFO, "PE Header",
			getDirectoryName());
	}

	protected void setBookmark(Program prog, Address addr, String comment) {
		prog.getBookmarkManager().setBookmark(addr, BookmarkType.INFO, "PE Header", comment);
	}

	protected void setPlateComment(Program prog, Address addr, String comment) {
		prog.getListing().setComment(addr, CodeUnit.PLATE_COMMENT, comment);
	}

	protected void setEolComment(Program prog, Address addr, String comment) {
		prog.getListing().setComment(addr, CodeUnit.EOL_COMMENT, comment);
	}

	protected void setPreComment(Program prog, Address addr, String comment) {
		prog.getListing().setComment(addr, CodeUnit.PRE_COMMENT, comment);
	}

	/**
	 * Creates a fragment with the given name (if it does not already exist).
	 * Move the address range into the fragment.
	 * Note: the end address is not inclusive!
	 */
	protected boolean createFragment(Program program, String fragmentName, Address start,
			Address end) {
		try {
			ProgramModule module = program.getListing().getDefaultRootModule();
			ProgramFragment fragment = findFragment(module, fragmentName);
			if (fragment == null) {
				fragment = module.createFragment(fragmentName);
			}
			fragment.move(start, end.subtract(1));
			return true;
		}
		catch (Exception e) {
		}
		return false;
	}

	private ProgramFragment findFragment(ProgramModule module, String fragmentName) {
		Group[] groups = module.getChildren();
		for (Group group : groups) {
			if (group.getName().equals(fragmentName)) {
				return (ProgramFragment) group;
			}
		}
		return null;
	}

	/**
	 * Returns the relative virtual address of this data directory.
	 * @return the relative virtual address of this data directory
	 */
	public int getVirtualAddress() {
		return virtualAddress;
	}

	/**
	 * Sets the relative virtual address of this data directory.
	 * @param addr the new relative virtual address
	 */
	public void setVirtualAddress(int addr) {
		this.virtualAddress = addr;
	}

	/**
	 * Returns the size of this data directory.
	 * @return the size of this data directory
	 */
	public int getSize() {
		return size;
	}

	/**
	 * Sets the size of this data directory.
	 * @param size the new size of this data directory
	 */
	public void setSize(int size) {
		this.size = size;
	}

	/**
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		return "VirtualAddress: 0x" + Integer.toHexString(virtualAddress) + " " + "Size: " + size +
			" bytes";
	}

	/**
	 * Converts the relative virtual address of this data directory
	 * into a file pointer.
	 * @return the file pointer
	 */
	int rvaToPointer() {
		return ntHeader.rvaToPointer(virtualAddress);
	}

	/**
	 * Returns true if this data directory is contained inside of a section.
	 * If true, that means that the section is loaded into memory
	 * at runtime.
	 * @return true if this data directory is contained inside of a section
	 */
	boolean isContainedInSection() {
		return rvaToPointer() != getVirtualAddress();
	}

	/**
	 * This method should return a datatype representing the data stored
	 * in this directory.
	 */
	@Override
	public abstract DataType toDataType() throws DuplicateNameException, IOException;

	/**
	 * Directories that are not contained inside of sections
	 * should override this method to write their bytes into the
	 * specified file.
	 * @param raf        the random access file used for output
	 * @param dc         the data converter for endianness
	 * @param template   the original unadulterated PE
	 * @throws IOException if an I/O error occurs
	 */
	public void writeBytes(RandomAccessFile raf, DataConverter dc, PortableExecutable template)
			throws IOException {
	}

	public boolean hasParsedCorrectly() {
		return hasParsed;
	}

	public int getPointer() {
		if (virtualAddress == 0) {
			return -1;
		}
		int ptr = ntHeader.rvaToPointer(getVirtualAddress());
		if (ptr < 0) {
			Msg.error(this, "Invalid file index for " + Integer.toHexString(getVirtualAddress()));
		}
		return ptr;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/DebugDataDirectory.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;
import java.io.RandomAccessFile;

import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.app.util.bin.format.pdb.PdbInfoCodeView;
import ghidra.app.util.bin.format.pdb.PdbInfoDotNet;
import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;
import net.jubjubnest.minidump.contrib.pe.debug.*;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressSpace;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Program;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.DataConverter;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;

/**
 * Points to an array of IMAGE_DEBUG_DIRECTORY structures.
 */
public class DebugDataDirectory extends DataDirectory {
    private final static String NAME = "IMAGE_DIRECTORY_ENTRY_DEBUG";

    private DebugDirectoryParser parser;

    static DebugDataDirectory createDebugDataDirectory(
            NTHeader ntHeader, FactoryBundledWithBinaryReader reader)
            throws IOException {
        DebugDataDirectory debugDataDirectory = (DebugDataDirectory) reader.getFactory().create(DebugDataDirectory.class);
        debugDataDirectory.initDebugDataDirectory(ntHeader, reader);
        return debugDataDirectory;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public DebugDataDirectory() {}

	private void initDebugDataDirectory(NTHeader ntHeader, FactoryBundledWithBinaryReader reader) throws IOException {
		processDataDirectory(ntHeader, reader);
	}

	@Override
	public String getDirectoryName() {
		return NAME;
	}

	@Override
	public boolean parse() throws IOException {
		int ptr = getPointer();
		if (ptr < 0) {
			return false;
		}
		
    	parser = DebugDirectoryParser.createDebugDirectoryParser(
    			ntHeader.getLoadInfo().sectionLayout, reader, ptr, size, ntHeader);
    	return true;
    }

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor,
			MessageLog log, NTHeader ntHeader) throws DuplicateNameException, CodeUnitInsertionException,
			DataTypeConflictException, IOException {

		monitor.setMessage(program.getName()+": debug...");
		Address addr = PeUtils.getMarkupAddress(program, isBinary, ntHeader, virtualAddress);
		if (!program.getMemory().contains(addr)) {
			return;
		}
		createDirectoryBookmark(program, addr);

		AddressSpace space = program.getAddressFactory().getDefaultAddressSpace();

		DebugDirectory [] ddarr = parser.getDebugDirectories();
		for (DebugDirectory dd : ddarr) {
			PeUtils.createData(program, addr, dd.toDataType(), log);
			addr = addr.add(DebugDirectory.IMAGE_SIZEOF_DEBUG_DIRECTORY);

			Address dataAddr = getDataAddress(dd, isBinary, space, ntHeader);
			if (dataAddr != null) {
				boolean success = createFragment(program, "Debug Data", dataAddr, dataAddr.add(dd.getSizeOfData()));
				if (!success) {
					log.appendMsg("Unable to create fragment: Debug Data");
				}
			}
		}

		markupDebigMisc(program, isBinary, log, space);
		markupDebugCodeView(program, isBinary, log, space);
	}

	private void markupDebugCodeView(Program program, boolean isBinary,
			MessageLog log, AddressSpace space) throws DuplicateNameException, IOException {
		DebugCodeView dcv = parser.getDebugCodeView();
		if (dcv != null) {
			Address dataAddr = getDataAddress(dcv.getDebugDirectory(), isBinary, space, ntHeader);
			if (dataAddr != null) {
				PdbInfoCodeView pdbInfo = dcv.getPdbInfo();
				if (pdbInfo != null) {
					setPlateComment(program, dataAddr, "CodeView PDB Info");
					PeUtils.createData(program, dataAddr, pdbInfo.toDataType(), log);
				}
				PdbInfoDotNet dotNetPdbInfo = dcv.getDotNetPdbInfo();
				if (dotNetPdbInfo != null) {
					setPlateComment(program, dataAddr, ".NET PDB Info");
					PeUtils.createData(program, dataAddr, dotNetPdbInfo.toDataType(), log);
				}
			}
		}
	}

	private void markupDebigMisc(Program program, boolean isBinary,
			MessageLog log, AddressSpace space) throws DuplicateNameException {
		DebugMisc dm = parser.getDebugMisc();
		if (dm != null) {
			Address dataAddr = getDataAddress(dm.getDebugDirectory(), isBinary, space, ntHeader);
			if (dataAddr != null) {
				setPlateComment(program, dataAddr, "Misc Debug Info");
				PeUtils.createData(program, dataAddr, dm.toDataType(), log);
			}
		}
	}

    private Address getDataAddress(DebugDirectory dd, boolean isBinary,
						AddressSpace space, NTHeader ntHeader) {

		long ptr = 0;
		if (isBinary) {
			ptr = dd.getPointerToRawData();
	        if (ptr != 0 && !ntHeader.checkPointer(ptr)) {
	        	Msg.error(this, "Invalid pointer "+Long.toHexString(ptr));
	        	return null;
	        }
		}
		else {
			ptr = dd.getAddressOfRawData();
		}
		if (ptr != 0) {
			if (isBinary) {
				return space.getAddress(ptr);
			}
			return space.getAddress(ptr + ntHeader.getOptionalHeader().getImageBase());
		}
		return null;
	}

	/**
     * Returns the debug parser used by this debug directory.
     * @return the debug parser used by this debug directory
     */
	public DebugDirectoryParser getParser() {
		return parser;
	}

    /**
     * @see ghidra.app.util.bin.StructConverter#toDataType()
     */
    @Override
    public DataType toDataType() throws DuplicateNameException, IOException {
        StructureDataType struct = new StructureDataType(NAME, 0);
        DebugDirectory [] ddArr = parser.getDebugDirectories();
        for (DebugDirectory sc : ddArr) {
            struct.add(sc.toDataType(),sc.getDescription(),null );
        }
        struct.setCategoryPath(new CategoryPath("/PE"));
        return struct;
    }

	/**
	 * @see net.jubjubnest.minidump.contrib.pe.DataDirectory#writeBytes(java.io.RandomAccessFile, ghidra.util.DataConverter, ghidra.app.util.bin.format.pe.PortableExecutable)
	 */
	@Override
    public void writeBytes(RandomAccessFile raf, DataConverter dc, PortableExecutable template) 
		throws IOException {
		OptionalHeader optionalHeader = template.getNTHeader().getOptionalHeader();
		DataDirectory [] originalDataDirs = optionalHeader.getDataDirectories();
		if (optionalHeader.getNumberOfRvaAndSizes() <= OptionalHeader.IMAGE_DIRECTORY_ENTRY_DEBUG) {
			return;
		}
		if (originalDataDirs[OptionalHeader.IMAGE_DIRECTORY_ENTRY_DEBUG] == null || 
			originalDataDirs[OptionalHeader.IMAGE_DIRECTORY_ENTRY_DEBUG].getSize() == 0) {
			return;
		}
		DebugDataDirectory templateDDD = (DebugDataDirectory) template.getNTHeader().getOptionalHeader().getDataDirectories()[OptionalHeader.IMAGE_DIRECTORY_ENTRY_DEBUG];
		DebugDirectory [] templateDD = templateDDD.getParser().getDebugDirectories();
		DebugDirectory [] dd = parser.getDebugDirectories();
		for (int i = 0; i < dd.length; i++) {
			dd[i].writeHeader(raf, dc);

			if (dd[i].getSizeOfData() == 0 || dd[i].getPointerToRawData() == 0) {
				continue;
			}

			int ptr = dd[i].getPointerToRawData();
	        if (!ntHeader.checkPointer(ptr)) {
	        	Msg.error(this, "Invalid pointer "+Long.toHexString(ptr));
	        	continue;
	        }
			raf.seek(ptr);
			raf.write(templateDD[i].toBytes(dc));
		}	
	}
	
	void updatePointers(int offset, int postOffset) {
		DebugDirectory [] debugDirs = parser.getDebugDirectories();
		for (DebugDirectory debugDir : debugDirs) {
			if (debugDir.getSizeOfData() == 0 || debugDir.getPointerToRawData() == 0) {
				continue;
			}
			debugDir.updatePointers(offset, postOffset);
		}
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/DefaultDataDirectory.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;

import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Program;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;
import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;

public class DefaultDataDirectory extends DataDirectory {

	static DefaultDataDirectory createDefaultDataDirectory(
            NTHeader ntHeader, FactoryBundledWithBinaryReader reader)
            throws IOException {
	    DefaultDataDirectory defaultDataDirectory = (DefaultDataDirectory) reader.getFactory().create(DefaultDataDirectory.class);
	    defaultDataDirectory.initDefaultDataDirectory(ntHeader, reader);
	    return defaultDataDirectory;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public DefaultDataDirectory() {}

    private void initDefaultDataDirectory(NTHeader ntHeader, FactoryBundledWithBinaryReader reader) throws IOException {
		processDataDirectory(ntHeader, reader);
	}

	@Override
	public String getDirectoryName() {
		return TITLE;
	}

	@Override
	public boolean parse() throws IOException {
		//do nothing
		return true;
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor,
			MessageLog log, NTHeader ntHeader) {
		//do nothing
	}

	@Override
    public DataType toDataType() throws DuplicateNameException, IOException {
        StructureDataType ddstruct = new StructureDataType(DataDirectory.TITLE,0);
        ddstruct.add(DWORD, "VirtualAddress", null);
        ddstruct.add(DWORD, "Size", null);
        ddstruct.setCategoryPath(new CategoryPath("/PE"));
        return ddstruct;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/DelayImportDataDirectory.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;
import java.util.*;

import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressSpace;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.SourceType;
import ghidra.program.model.symbol.SymbolUtilities;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;
import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;

/**
 * Points to the delayload information. 
 * See DELAYIMP.H from Visual C++. 
 */
public class DelayImportDataDirectory extends DataDirectory {
    private final static String NAME = "IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT";

    private DelayImportDescriptor [] descriptors; 

    static DelayImportDataDirectory createDelayImportDataDirectory(
            NTHeader ntHeader, ImageLoadInfo loadInfo, FactoryBundledWithBinaryReader reader)
            throws IOException {
        DelayImportDataDirectory delayImportDataDirectory = (DelayImportDataDirectory) reader.getFactory().create(DelayImportDataDirectory.class);
        delayImportDataDirectory.initDelayImportDataDirectory(ntHeader, reader);
        return delayImportDataDirectory;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public DelayImportDataDirectory() {}

	private void initDelayImportDataDirectory(NTHeader ntHeader, FactoryBundledWithBinaryReader reader) throws IOException {
		processDataDirectory(ntHeader, reader);

        if (descriptors == null) descriptors = new DelayImportDescriptor[0];
	}

	/**
	 * Returns the array of delay import descriptors defined in this delay import data directory.
	 * @return the array of delay import descriptors defined in this delay import data directory
	 */
    public DelayImportDescriptor [] getDelayImportDescriptors() {
        return descriptors;
    }

    @Override
    public String getDirectoryName() {
    	return NAME;
    }

    @Override
	public boolean parse() throws IOException {
		int ptr = getPointer();
		if (ptr < 0) {
			return false;
		}

        List<DelayImportDescriptor> list = new ArrayList<DelayImportDescriptor>();
        while (true) {
            DelayImportDescriptor did = DelayImportDescriptor.createDelayImportDescriptor(ntHeader, reader, ptr);

            if (!did.isValid() || did.getPointerToDLLName() == 0) break;

            list.add(did);

            ptr += did.sizeof();
        }

        descriptors = new DelayImportDescriptor[list.size()];
        list.toArray(descriptors);
        return true;
    }

    @Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor,
			MessageLog log, NTHeader ntHeader) throws DuplicateNameException, CodeUnitInsertionException,
			DataTypeConflictException, IOException {

    	monitor.setMessage(program.getName()+": delay import(s)...");
		Address addr = PeUtils.getMarkupAddress(program, isBinary, ntHeader, virtualAddress);
		if (!program.getMemory().contains(addr)) {
			return;
		}
		createDirectoryBookmark(program, addr);
		AddressSpace space = program.getAddressFactory().getDefaultAddressSpace();
		for (DelayImportDescriptor descriptor : descriptors) {
			if (monitor.isCancelled()) {
				return;
			}
			//apply descriptor structure
			PeUtils.createData(program, addr, descriptor.toDataType(), log);
			createSymbol(program, addr,
				SymbolUtilities.getAddressAppendedName(DelayImportDescriptor.NAME, addr));

			Data data = program.getListing().getDataAt(addr);
			if (data == null || !data.isDefined()) continue;
			if (data.getNumComponents() < 7) {
				Msg.info(this, "Unexpected data at "+addr);
				continue;
			}

			//create string for descriptor dll name
			Address tmpAddr = addr(space, isBinary, descriptor, descriptor.getPointerToDLLName());
			createTerminatedString(program, tmpAddr, true, log);

			tmpAddr = addr(space, isBinary, descriptor, descriptor.getAddressOfModuleHandle());
			createSymbol(program, tmpAddr, SymbolUtilities.getAddressAppendedName(
				DelayImportDescriptor.NAME + "_Module_Handle", tmpAddr));

			tmpAddr = addr(space, isBinary, descriptor, descriptor.getAddressOfIAT());
			createSymbol(program, tmpAddr, SymbolUtilities.getAddressAppendedName(
				DelayImportDescriptor.NAME + "_IAT", tmpAddr));
			markupThunk(program, isBinary, space, descriptor, descriptor.getAddressOfIAT(),
				descriptor.getThunksIAT(), monitor, log);

			tmpAddr = addr(space, isBinary, descriptor, descriptor.getAddressOfINT());
			createSymbol(program, tmpAddr, SymbolUtilities.getAddressAppendedName(
				DelayImportDescriptor.NAME + "_INT", tmpAddr));
			markupThunk(program, isBinary, space, descriptor, descriptor.getAddressOfINT(),
				descriptor.getThunksINT(), monitor, log);

			// This table is optional
			if (descriptor.getAddressOfBoundIAT() != 0) {
				tmpAddr = addr(space, isBinary, descriptor, descriptor.getAddressOfBoundIAT());
				createSymbol(program, tmpAddr, SymbolUtilities.getAddressAppendedName(
					DelayImportDescriptor.NAME + "_Bound_IAT", tmpAddr));
				markupThunk(program, isBinary, space, descriptor, descriptor.getAddressOfBoundIAT(),
					descriptor.getThunksBoundIAT(), monitor, log);
			}

			// This table is optional
			if (descriptor.getAddressOfOriginalIAT() != 0) {
				tmpAddr = addr(space, isBinary, descriptor, descriptor.getAddressOfOriginalIAT());
				createSymbol(program, tmpAddr, SymbolUtilities.getAddressAppendedName(
					DelayImportDescriptor.NAME + "_Unload_IAT", tmpAddr));
				markupThunk(program, isBinary, space, descriptor,
					descriptor.getAddressOfOriginalIAT(), descriptor.getThunksUnloadIAT(), monitor,
					log);
			}


			markupImportByName(program, isBinary, space, descriptor, monitor, log);

			addr = addr.add(descriptor.sizeof());
		}
    }

    private void createSymbol(Program program, Address addr, String name) {
		try {
			program.getSymbolTable().createLabel(addr, name, SourceType.IMPORTED);
		}
		catch (Exception e) {}
	}

    private Address addr(AddressSpace space, boolean isBinary, 
			DelayImportDescriptor descriptor, long addr) {

    	if (!isBinary) {
    		if (descriptor.isUsingRVA()) {
    			return space.getAddress(addr + ntHeader.getOptionalHeader().getImageBase());
    		}
    		return space.getAddress(addr);
    	}
		if (!descriptor.isUsingRVA()) {
			addr -= ntHeader.getOptionalHeader().getImageBase();
		}
    	long va = va(addr, isBinary);
		return space.getAddress(va);
	}

	private void markupImportByName(Program program, 
									boolean isBinary, 
									AddressSpace space, 
									DelayImportDescriptor descriptor, 
									TaskMonitor monitor,
									MessageLog log)
			throws DataTypeConflictException, DuplicateNameException {

		Map<ThunkData, ImportByName> map = descriptor.getImportByNameMap();
		Iterator<ThunkData> thunks = map.keySet().iterator();
		while (thunks.hasNext()) {
			if (monitor.isCancelled()) {
				return;
			}
			ThunkData thunk = thunks.next();
			long thunkPtr = va(thunk.getAddressOfData(), isBinary);
			if (!descriptor.isUsingRVA()) {
				thunkPtr -= ntHeader.getOptionalHeader().getImageBase();
			}
			Address thunkAddress = space.getAddress(thunkPtr);
			ImportByName ibn = map.get(thunk);
			PeUtils.createData(program, thunkAddress, ibn.toDataType(), log);
		}
	}

	private void markupThunk(Program program, 
						boolean isBinary, 
						AddressSpace space, 
						DelayImportDescriptor descriptor,
						long ptr,
						List<ThunkData> thunks,
						TaskMonitor monitor,
						MessageLog log) {

		DataType dt = ntHeader.getOptionalHeader().is64bit() 
				? (DataType)QWORD 
				: (DataType)DWORD;
		
		long thunkPtr = va(ptr, isBinary);
		if (!descriptor.isUsingRVA()) {
			thunkPtr -= ntHeader.getOptionalHeader().getImageBase();
		}

		for (ThunkData thunk : thunks) {
			if (monitor.isCancelled()) {
				return;
			}
			Address thunkAddress = space.getAddress(thunkPtr);
			PeUtils.createData(program, thunkAddress, dt, log);
			setEolComment(program, thunkAddress, thunk.getStructName());
			thunkPtr += thunk.getStructSize();
		}
	}

    /**
     * @see ghidra.app.util.bin.StructConverter#toDataType()
     */
    @Override
    public DataType toDataType() throws DuplicateNameException, IOException {
        StructureDataType struct = new StructureDataType(NAME, 0);
        for (DelayImportDescriptor descriptor : descriptors) {
			struct.add(descriptor.toDataType(), DelayImportDescriptor.NAME, null);
		}
        struct.setCategoryPath(new CategoryPath("/PE"));
        return struct;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/DelayImportDescriptor.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;
import java.util.*;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.StructConverter;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.program.model.data.*;
import ghidra.util.Conv;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;
import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;
import net.jubjubnest.minidump.contrib.new_.ModuleBaseOffset32DataType;

/**
 * A class to represent the 
 * <code>ImgDelayDescr</code>
 * data structure defined in <b><code>DELAYIMP.H</code></b>.
 * <p>
 * <pre>
 * typedef struct ImgDelayDescr {
 *     DWORD           grAttrs;        // attributes
 *     LPCSTR          szName;         // pointer to dll name
 *     HMODULE *       phmod;          // address of module handle
 *     PImgThunkData   pIAT;           // address of the IAT
 *     PCImgThunkData  pINT;           // address of the INT
 *     PCImgThunkData  pBoundIAT;      // address of the optional bound IAT
 *     PCImgThunkData  pUnloadIAT;     // address of optional copy of original IAT
 *     DWORD           dwTimeStamp;    // 0 if not bound,
 *                                     // O.W. date/time stamp of DLL bound to (old BIND)
 * } ImgDelayDescr, * PImgDelayDescr;
 * </pre>
 */
public class DelayImportDescriptor implements StructConverter {
	public final static String NAME = "ImgDelayDescr";

	private int grAttrs;
	private long szName;
	private long phmod;
	private long pIAT;
	private long pINT;
	private long pBoundIAT;
	private long pUnloadIAT;
	private int dwTimeStamp;

	private String dllName;

	private List<ThunkData> thunksIAT = new ArrayList<ThunkData>();
	private List<ThunkData> thunksINT = new ArrayList<ThunkData>();
	private List<ThunkData> thunksBoundIAT = new ArrayList<ThunkData>();
	private List<ThunkData> thunksUnloadIAT = new ArrayList<ThunkData>();

	private List<DelayImportInfo> delayImportInfoList = new ArrayList<DelayImportInfo>();
	private Map<ThunkData, ImportByName> importByNameMap = new HashMap<ThunkData, ImportByName>();
	
	private boolean sharedProgram;
	private boolean isValid;

	static DelayImportDescriptor createDelayImportDescriptor(NTHeader ntHeader,
			FactoryBundledWithBinaryReader reader, int index) throws IOException {
		DelayImportDescriptor delayImportDescriptor =
			(DelayImportDescriptor) reader.getFactory().create(DelayImportDescriptor.class);
		delayImportDescriptor.initDelayImportDescriptor(ntHeader, reader, index);
		return delayImportDescriptor;
	}

	/**
	 * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
	 */
	public DelayImportDescriptor() {
	}

	private void initDelayImportDescriptor(NTHeader ntHeader,
			FactoryBundledWithBinaryReader reader, int index) throws IOException {
		
		sharedProgram = ntHeader.getLoadInfo().sharedProgram;
        if (!ntHeader.checkPointer(index)) {
			Msg.error(this, "Invalid file index for " + Integer.toHexString(index));
			return;
        }

		readFields(reader, index);
		readName(ntHeader, reader);

		thunksIAT = readThunks(ntHeader, reader, pIAT, false);
		if (thunksIAT == null) {
			return;
		}
		thunksINT = readThunks(ntHeader, reader, pINT, true);
		if (thunksINT == null) {
			return;
		}
		thunksBoundIAT = readThunks(ntHeader, reader, pBoundIAT, false);
		if (thunksBoundIAT == null) {
			return;
		}
		thunksUnloadIAT = readThunks(ntHeader, reader, pUnloadIAT, false);
		if (thunksUnloadIAT == null) {
			return;
		}
		isValid = true;
	}

	private List<ThunkData> readThunks(NTHeader ntHeader, FactoryBundledWithBinaryReader reader,
			long ptr, boolean isName) throws IOException {
		List<ThunkData> thunkList = new ArrayList<ThunkData>();
		if (ptr == 0) {
			return thunkList;
		}

		long thunkPtr = 0;
		if (isUsingRVA()) {
			thunkPtr = ntHeader.rvaToPointer(ptr);
		}
		else {
			thunkPtr = ntHeader.vaToPointer(ptr);
		}

		while (true) {
			if (!ntHeader.checkPointer(thunkPtr)) {
				Msg.error(this, "Invalid thunkPtr for "+Long.toHexString(ptr));
				return null;
			}
			ThunkData thunk =
				ThunkData.createThunkData(reader, (int) thunkPtr,
					ntHeader.getOptionalHeader().is64bit());
			thunkList.add(thunk);
			if (thunk.getAddressOfData() == 0)
				break;

			thunkPtr += thunk.getStructSize();

			if (!isName) {
				continue;
			}

			if (thunk.isOrdinal()) {
				long ordinal = thunk.getOrdinal();
				delayImportInfoList.add(new DelayImportInfo(ordinal));
			}
			else {
				long ibnPtr = 0;
				if (isUsingRVA()) {
					ibnPtr = ntHeader.rvaToPointer(thunk.getAddressOfData());
				}
				else {
					ibnPtr = ntHeader.vaToPointer(thunk.getAddressOfData());
				}
				if (ibnPtr < 0) {
					Msg.error(this, "Invalid import pointer for "+thunk.getAddressOfData());
					return thunkList;
				}
				ImportByName ibn = ImportByName.createImportByName(reader, (int) ibnPtr);
				importByNameMap.put(thunk, ibn);
				int ordinal = ibn.getHint();
				String name = ibn.getName();
				delayImportInfoList.add(new DelayImportInfo(ordinal, name));
				thunk.setImportByName(ibn);
			}
		}

		return thunkList;
	}

	private void readName(NTHeader ntHeader, FactoryBundledWithBinaryReader reader)
			throws IOException {
		if (szName == 0) {
			return;
		}
		long namePtr =
			(isUsingRVA() ? ntHeader.rvaToPointer(szName) : ntHeader.vaToPointer(szName));
		if (!ntHeader.checkPointer(namePtr)) {
			Msg.warn(this, "Invalid namePtr for "+Long.toHexString(szName));
			return;
		}
		dllName = reader.readAsciiString((int) namePtr);
	}

	private void readFields(FactoryBundledWithBinaryReader reader, int index) throws IOException {
		grAttrs = reader.readInt(index);
		index += BinaryReader.SIZEOF_INT;
		szName = reader.readInt(index) & Conv.INT_MASK;
		index += BinaryReader.SIZEOF_INT;
		phmod = reader.readInt(index) & Conv.INT_MASK;
		index += BinaryReader.SIZEOF_INT;
		pIAT = reader.readInt(index) & Conv.INT_MASK;
		index += BinaryReader.SIZEOF_INT;
		pINT = reader.readInt(index) & Conv.INT_MASK;
		index += BinaryReader.SIZEOF_INT;
		pBoundIAT = reader.readInt(index) & Conv.INT_MASK;
		index += BinaryReader.SIZEOF_INT;
		pUnloadIAT = reader.readInt(index) & Conv.INT_MASK;
		index += BinaryReader.SIZEOF_INT;
		dwTimeStamp = reader.readInt(index);
		index += BinaryReader.SIZEOF_INT;
	}

	/**
	 * Returns true if the "using relative virtual address" is flag is set
	 * @return true if the "using relative virtual address" is flag is set
	 */
	public boolean isUsingRVA() {
		return (grAttrs & 1) == 1;
	}

	/**
	 * Returns the attributes.
	 * @return the attributes
	 */
	public int getAttibutes() {
		return grAttrs;
	}

	/**
	 * Returns the pointer to the DLL name.
	 * @return the pointer to the DLL name
	 */
	public long getPointerToDLLName() {
		return szName;
	}

	/**
	 * Returns the address of the module handle.
	 * @return the address of the module handle
	 */
	public long getAddressOfModuleHandle() {
		return phmod;
	}

	/**
	 * Returns the address of the import address table.
	 * @return the address of the import address table
	 */
	public long getAddressOfIAT() {
		return pIAT;
	}

	/**
	 * Returns the address of the import name table.
	 * @return the address of the import name table
	 */
	public long getAddressOfINT() {
		return pINT;
	}

	/**
	 * Returns the address of the optional bound IAT.
	 * @return the address of the optional bound IAT
	 */
	public long getAddressOfBoundIAT() {
		return pBoundIAT;
	}

	/**
	 * Returns the address of the optional copy of original IAT.
	 * @return the address of the optional copy of original IAT
	 */
	public long getAddressOfOriginalIAT() {
		return pUnloadIAT;
	}

	/**
	 * Returns the date/time stamp of DLL bound to (Old BIND),
	 * otherwise 0 if not bound.
	 * @return if bound returns the time stamp, otherwise 0
	 */
	public int getTimeStamp() {
		return dwTimeStamp;
	}

	/**
	 * Returns the DLL name.
	 * @return the DLL name
	 */
	public String getDLLName() {
		return dllName;
	}

	public Map<ThunkData, ImportByName> getImportByNameMap() {
		return new HashMap<ThunkData, ImportByName>(importByNameMap);
	}

	public List<DelayImportInfo> getImportList() {
		return new ArrayList<DelayImportInfo>(delayImportInfoList);
	}

	public List<ThunkData> getThunksIAT() {
		return new ArrayList<ThunkData>(thunksIAT);
	}

	public List<ThunkData> getThunksINT() {
		return new ArrayList<ThunkData>(thunksINT);
	}

	public List<ThunkData> getThunksBoundIAT() {
		return new ArrayList<ThunkData>(thunksBoundIAT);
	}

	public List<ThunkData> getThunksUnloadIAT() {
		return new ArrayList<ThunkData>(thunksUnloadIAT);
	}

	public DataType toDataType() throws DuplicateNameException, IOException {
		DataType ibo32 = sharedProgram
				? new ModuleBaseOffset32DataType()
				: new ImageBaseOffset32DataType();
		StructureDataType struct = new StructureDataType(NAME, 0);
		struct.add(DWORD, "grAttrs", null);
		struct.add(ibo32, "szName", null);
		struct.add(ibo32, "phmod", null);
		struct.add(ibo32, "pIAT", null);
		struct.add(ibo32, "pINT", null);
		struct.add(ibo32, "pBoundIAT", null);
		struct.add(ibo32, "pUnloadIAT", null);
		struct.add(DWORD, "dwTimeStamp", null);
		struct.setCategoryPath(new CategoryPath("/PE"));
		return struct;
	}

	/**
	 * Returns the size of this structure. It accounts for 32 vs 64 bit.
	 * @return the size of this structure
	 */
	public int sizeof() {
		return 32;
	}

	public boolean isValid() {
		return isValid;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/DelayImportInfo.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

/**
 * A class to hold the information extracted from a 
 * delay import descriptor.
 * 
 * NOTE:
 * This class is simply a storage class created for 
 * parsing the PE header data structures.
 * It does not map back to a PE data data structure.
 * 
 * 
 */
public class DelayImportInfo {
    private long ordinal;
    private String name;

    DelayImportInfo(long ordinal) {
        this.ordinal = ordinal;
    }

    DelayImportInfo(int ordinal, String name) {
        this.ordinal = ordinal;
        this.name = name;
    }

	/**
	 * Returns the ordinal number of the imported DLL.
	 * @return the ordinal number of the imported DLL
	 */
    public long getOrdinal() {
        return ordinal;
    }

	/**
	 * Returns the name of the imported DLL.
	 * @return the name of the imported DLL
	 */
    public String getName() {
        return name;
    }

	/**
	 * Returns true if the import is 'by name'.
	 * @return true if the import is 'by name'
	 */
    public boolean hasName() {
        return name != null;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/DllCharacteristics.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.util.HashSet;
import java.util.Set;

public enum DllCharacteristics {

	IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA("IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA", 0x0020, "Image can handle a high entropy 64-bit virtual address space."),
	IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE("IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE", 0x0040, "DLL can be relocated at load time."),
	IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY("IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY", 0x0080, "Code Integrity checks are enforced."),
	IMAGE_DLLCHARACTERISTICS_NX_COMPAT("IMAGE_DLLCHARACTERISTICS_NX_COMPAT", 0x0100, "Image is NX compatible."),
	IMAGE_DLLCHARACTERISTICS_NO_ISOLATION("IMAGE_DLLCHARACTERISTICS_NO_ISOLATION", 0x0200, "Isolation aware, but do not isolate the image."),
	IMAGE_DLLCHARACTERISTICS_NO_SEH("IMAGE_DLLCHARACTERISTICS_NO_SEH", 0x0400, "Does not use structured exception (SE) handling. No SE handler may be called in this image."),
	IMAGE_DLLCHARACTERISTICS_NO_BIND("IMAGE_DLLCHARACTERISTICS_NO_BIND", 0x0800, "Do not bind the image."),
	IMAGE_DLLCHARACTERISTICS_APPCONTAINER("IMAGE_DLLCHARACTERISTICS_APPCONTAINER", 0x1000, "Image must execute in an AppContainer."),
	IMAGE_DLLCHARACTERISTICS_WDM_DRIVER("IMAGE_DLLCHARACTERISTICS_WDM_DRIVER", 0x2000, "A WDM driver."),
	IMAGE_DLLCHARACTERISTICS_GUARD_CF("IMAGE_DLLCHARACTERISTICS_GUARD_CF", 0x4000, "Image supports Control Flow Guard."),
	IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE("IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE", 0x8000, "Terminal Server aware.");

	private final String alias;
	private final int mask;
	private final String description;

	private DllCharacteristics(String alias, int mask, String description) {
		this.alias = alias;
		this.mask = mask;
		this.description = description;
	}

	public String getAlias() {
		return alias;
	}

	public int getMask() {
		return mask;
	}

	public String getDescription() {
		return description;
	}

	public static Set<DllCharacteristics> resolveCharacteristics(int value) {
		Set<DllCharacteristics> applied = new HashSet<>();
		for (DllCharacteristics ch : values()) {
			if ((ch.getMask() & value) == ch.getMask()) {
				applied.add(ch);
			}
		}
		return applied;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/ExceptionDataDirectory.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;

import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Program;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;
import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;

public class ExceptionDataDirectory extends DataDirectory {
    private final static String NAME = "IMAGE_DIRECTORY_ENTRY_EXCEPTION";

	static ExceptionDataDirectory createExceptionDataDirectory(
            NTHeader ntHeader, FactoryBundledWithBinaryReader reader)
            throws IOException {
	    ExceptionDataDirectory exceptionDataDirectory = (ExceptionDataDirectory) reader.getFactory().create(ExceptionDataDirectory.class);
	    exceptionDataDirectory.initExceptionDataDirectory(ntHeader, reader);
	    return exceptionDataDirectory;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public ExceptionDataDirectory() {}

    private void initExceptionDataDirectory(NTHeader ntHeader, FactoryBundledWithBinaryReader reader) throws IOException {
		processDataDirectory(ntHeader, reader);
	}

	@Override
	public String getDirectoryName() {
		return NAME;
	}

	@Override
	public boolean parse() {
		int ptr = getPointer();
		if (ptr < 0) {
			return false;
		}
		return true;
    }

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor,
			MessageLog log, NTHeader ntHeader) throws DuplicateNameException, CodeUnitInsertionException,
			DataTypeConflictException, IOException {
		monitor.setMessage(program.getName()+": exceptions...");
		Address addr = PeUtils.getMarkupAddress(program, isBinary, ntHeader, virtualAddress);
		if (!program.getMemory().contains(addr)) {
			return;
		}
		createDirectoryBookmark(program, addr);
	}

    /**
     * @see ghidra.app.util.bin.StructConverter#toDataType()
     */
    @Override
    public DataType toDataType() throws DuplicateNameException {
        StructureDataType struct = new StructureDataType(NAME, size);
        struct.setCategoryPath(new CategoryPath("/PE"));
        return struct;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/ExportDataDirectory.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressSpace;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.Program;
import ghidra.program.model.scalar.Scalar;
import ghidra.program.model.symbol.*;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.Conv;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;

/**
 * A class to represent the <code>IMAGE_EXPORT_DIRECTORY</code>
 * data structure defined in <b><code>winnt.h</code></b>.
 * <pre>
 * typedef struct _IMAGE_EXPORT_DIRECTORY {
 *     DWORD   Characteristics;
 *     DWORD   TimeDateStamp;
 *     WORD    MajorVersion;
 *     WORD    MinorVersion;
 *     DWORD   Name;
 *     DWORD   Base;
 *     DWORD   NumberOfFunctions;
 *     DWORD   NumberOfNames;
 *     DWORD   AddressOfFunctions;     // RVA from base of image
 *     DWORD   AddressOfNames;         // RVA from base of image
 *     DWORD   AddressOfNameOrdinals;  // RVA from base of image
 * };
 * </pre>
 */
public class ExportDataDirectory extends DataDirectory {
	private final static String NAME = "IMAGE_DIRECTORY_ENTRY_EXPORT";
	/**
	 * The size of the <code>IMAGE_EXPORT_DIRECTORY</code> in bytes.
	 */
	public final static int IMAGE_SIZEOF_EXPORT_DIRECTORY = 40;

	private int characteristics;
	private int timeDateStamp;
	private short majorVersion;
	private short minorVersion;
	private int name;
	private int base;
	private int numberOfFunctions;
	private int numberOfNames;
	private int addressOfFunctions;
	private int addressOfNames;
	private int addressOfNameOrdinals;

	private int exportsStartRVA;
	private int exportsEndRVA;

	private ExportInfo[] exports;

	private String exportName;

	static ExportDataDirectory createExportDataDirectory(NTHeader ntHeader,
			FactoryBundledWithBinaryReader reader) throws IOException {
		ExportDataDirectory exportDataDirectory =
			(ExportDataDirectory) reader.getFactory().create(ExportDataDirectory.class);
		exportDataDirectory.initExportDataDirectory(ntHeader, reader);
		return exportDataDirectory;
	}

	/**
	 * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
	 */
	public ExportDataDirectory() {
	}

	private void initExportDataDirectory(NTHeader ntHeader, FactoryBundledWithBinaryReader reader)
			throws IOException {
		processDataDirectory(ntHeader, reader);

		if (exports == null) {
			exports = new ExportInfo[0];
		}
	}

	/**
	 * Returns an array of the exports defined in this export data directory.
	 * @return an array of the exports defined in this export data directory
	 */
	public ExportInfo[] getExports() {
		return exports;
	}

	public int getAddressOfFunctions() {
		return addressOfFunctions;
	}

	public int getAddressOfNames() {
		return addressOfNames;
	}

	public int getAddressOfNameOrdinals() {
		return addressOfNameOrdinals;
	}

	public int getNumberOfFunctions() {
		return numberOfFunctions;
	}

	public int getNumberOfNames() {
		return numberOfNames;
	}

	public int getName() {
		return name;
	}

	public int getBase() {
		return base;
	}

	public int getCharacteristics() {
		return characteristics;
	}

	public int getTimeDateStamp() {
		return timeDateStamp;
	}

	public short getMajorVersion() {
		return majorVersion;
	}

	public short getMinorVersion() {
		return minorVersion;
	}

	public String getExportName() {
		return exportName;
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor,
			MessageLog log, NTHeader ntHeader) throws DuplicateNameException, CodeUnitInsertionException,
			DataTypeConflictException, IOException {
		monitor.setMessage("[" + program.getName() + "]: exports...");

		Address addr = PeUtils.getMarkupAddress(program, isBinary, ntHeader, virtualAddress);
		if (!program.getMemory().contains(addr)) {
			return;
		}
		createDirectoryBookmark(program, addr);

		AddressSpace space = program.getAddressFactory().getDefaultAddressSpace();
		ReferenceManager referenceManager = program.getReferenceManager();

		//apply the export directory data structure
		PeUtils.createData(program, addr, toDataType(), log);

		//apply string datatype on export name
		int ptrToName = getName();
		if (ptrToName > 0) {
			Address strAddr = space.getAddress(va(ptrToName, isBinary));
			createTerminatedString(program, strAddr, false, log);
			setPlateComment(program, strAddr, "Export Library Name");
		}

		long funcAddr = va(getAddressOfFunctions(), isBinary);
		long nameAddr = va(getAddressOfNames(), isBinary);
		long ordinalAddr = va(getAddressOfNameOrdinals(), isBinary);

		for (int i = 0; i < getNumberOfFunctions(); ++i) {
			if (monitor.isCancelled()) {
				break;
			}
			Address address = space.getAddress(funcAddr);
			if (i == 0) {
				setPlateComment(program, address, "Export Function Pointers");
			}
			PeUtils.createData(program, address, new DWordDataType(), log);
			Data data = program.getListing().getDataAt(address);
			if (data == null || !(data.getValue() instanceof Scalar)) {
				Msg.warn(this, "Invalid or missing function at " + address);
				break;
			}
			Scalar scalar = (Scalar) data.getValue();
			Address refAddr = space.getAddress(va(scalar.getUnsignedValue(), isBinary));
			data.addOperandReference(0, refAddr, RefType.DATA, SourceType.IMPORTED);
			Reference[] refs = data.getOperandReferences(0);
			for (Reference ref : refs) {
				referenceManager.setPrimary(ref, false);
			}
			funcAddr += 4;
		}
		for (int i = 0; i < getNumberOfNames(); ++i) {
			if (monitor.isCancelled()) {
				break;
			}
			Address address = space.getAddress(ordinalAddr);
			if (i == 0) {
				setPlateComment(program, address, "Export Ordinal Values");
			}
			PeUtils.createData(program, address, new WordDataType(), log);
			ordinalAddr += 2;
		}
		for (int i = 0; i < getNumberOfNames(); ++i) {
			if (monitor.isCancelled()) {
				break;
			}
			Address address = space.getAddress(nameAddr);
			if (i == 0) {
				setPlateComment(program, address, "Export Name Pointers");
			}
			PeUtils.createData(program, address, new DWordDataType(), log);
			Data data = program.getListing().getDataAt(address);
			if (data == null) {
				Msg.warn(this, "Invalid or missing data at " + address);
				break;
			}
			Scalar scalar = (Scalar) data.getValue();
			Address strAddr = space.getAddress(va(scalar.getUnsignedValue(), isBinary));
			data.addOperandReference(0, strAddr, RefType.DATA, SourceType.IMPORTED);
			Reference[] refs = data.getOperandReferences(0);
			for (Reference ref : refs) {
				referenceManager.setPrimary(ref, false);
			}
			createTerminatedString(program, strAddr, true, log);
			nameAddr += 4;
		}
	}

	@Override
	public String getDirectoryName() {
		return NAME;
	}

	@Override
	public boolean parse() throws IOException {
		long oldIndex = reader.getPointerIndex();
		try {
			int ptr = getPointer();
			if (ptr < 0) {
				return false;
			}
			reader.setPointerIndex(ptr);

			characteristics = reader.readNextInt();
			timeDateStamp = reader.readNextInt();
			majorVersion = reader.readNextShort();
			minorVersion = reader.readNextShort();
			name = reader.readNextInt();
			ptr = ntHeader.rvaToPointer(name);
			if (name > 0 && ptr < 0) {
				Msg.error(this, "Invalid RVA " + Integer.toHexString(name));
				return false;
			}
			base = reader.readNextInt();
			numberOfFunctions = reader.readNextInt();
			numberOfNames = reader.readNextInt();
			addressOfFunctions = reader.readNextInt();
			addressOfNames = reader.readNextInt();
			addressOfNameOrdinals = reader.readNextInt();

			exportsStartRVA = getVirtualAddress();
			exportsEndRVA = exportsStartRVA + getSize();

			exportName = (ptr > 0) ? reader.readAsciiString(ptr) : "";

			// convert RVA's into pointers
			int pointerToFunctions = ntHeader.rvaToPointer(addressOfFunctions);
			if (numberOfFunctions > 0 && pointerToFunctions < 0) {
				Msg.error(this, "Invalid RVA " + Integer.toHexString(addressOfFunctions));
				numberOfFunctions = 0;
			}
			if (numberOfFunctions > NTHeader.MAX_SANE_COUNT) {
				Msg.error(this,
					"Large number of functions " + Integer.toHexString(numberOfFunctions));
				numberOfFunctions = 0;
			}
			int pointerToNames = ntHeader.rvaToPointer(addressOfNames);
			if (numberOfNames > 0 && pointerToNames < 0) {
				Msg.error(this, "Invalid RVA " + Integer.toHexString(addressOfNames));
				numberOfNames = 0;
			}
			int pointerToOrdinals = ntHeader.rvaToPointer(addressOfNameOrdinals);
			if (numberOfNames > 0 && pointerToOrdinals < 0) {
				Msg.error(this, "Invalid RVA " + Integer.toHexString(addressOfNameOrdinals));
				numberOfNames = 0;
			}
			if (numberOfNames > NTHeader.MAX_SANE_COUNT) {
				Msg.error(this, "Large number of names " + Integer.toHexString(numberOfNames));
				numberOfNames = 0;
			}

			List<ExportInfo> exportList = new ArrayList<>();

			for (int i = 0; i < numberOfFunctions; ++i) {
				int entryPointRVA = reader.readInt(pointerToFunctions);
				pointerToFunctions += 4;

				// Skip over gaps in exported function
				// ordinals (the entrypoint is 0 for
				// these functions).
				if (entryPointRVA == 0) {
					continue;
				}

				long addr =
					Conv.intToLong(entryPointRVA) + ntHeader.getOptionalHeader().getImageBase();

				if (!ntHeader.getOptionalHeader().is64bit()) {
					addr &= 0xffffffffL;
				}

				String lname = "";

				// See if this function has an associated name exported for it.
				for (int j = 0; j < numberOfNames; ++j) {
					int jthOrdinalVal = reader.readShort(pointerToOrdinals + (j * 2));
					if (jthOrdinalVal == i) {
						int jthNameRVA = reader.readInt(pointerToNames + (j * 4));
						int jthNamePtr = ntHeader.rvaToPointer(jthNameRVA);
						if (jthNamePtr < 0) {
							Msg.error(this, "Invalid RVA " + Integer.toHexString(jthNameRVA));
							return false;
						}
						// locate corresponding name
						lname = reader.readAsciiString(jthNamePtr);
						break;
					}
				}

				String cmt = "0x" + Integer.toHexString(entryPointRVA) + "  " +
					Integer.toString(i + base) + "  " + lname;

				boolean forwarded = false;

				if (entryPointRVA >= exportsStartRVA && entryPointRVA < exportsEndRVA) {
					int entryPointPtr = ntHeader.rvaToPointer(entryPointRVA);
					if (entryPointPtr < 0) {
						Msg.error(this, "Invalid RVA " + Integer.toHexString(entryPointRVA));
						return false;
					}
					String forwarder = reader.readAsciiString(entryPointPtr);

					cmt += "  ";
					cmt += "(forwarder -> " + forwarder + ")";

					forwarded = true;
				}

				exportList.add(new ExportInfo(addr, i + base, lname, cmt, forwarded));
			}

			exports = new ExportInfo[exportList.size()];
			exportList.toArray(exports);
		}
		finally {
			reader.setPointerIndex(oldIndex);
		}
		return true;
	}

	/**
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		StringBuffer buff = new StringBuffer();
		buff.append("\t\t" + "Export Directory: [" + super.toString() + "]" + "\n");
		for (ExportInfo info : exports) {
			buff.append("\t\t\t" + "0x" + Long.toHexString(info.getAddress()) + "  " +
				info.getOrdinal() + "  " + info.getName() + "\n");
		}
		return buff.toString();
	}

	@Override
	public DataType toDataType() throws DuplicateNameException {
		StructureDataType struct = new StructureDataType(NAME, 0);
		struct.add(new DWordDataType(), "Characteristics", null);
		struct.add(new DWordDataType(), "TimeDateStamp", null);
		struct.add(new WordDataType(), "MajorVersion", null);
		struct.add(new WordDataType(), "MinorVersion", null);
		struct.add(new DWordDataType(), "Name", null);
		struct.add(new DWordDataType(), "Base", null);
		struct.add(new DWordDataType(), "NumberOfFunctions", null);
		struct.add(new DWordDataType(), "NumberOfNames", null);
		struct.add(new DWordDataType(), "AddressOfFunctions", null);
		struct.add(new DWordDataType(), "AddressOfNames", null);
		struct.add(new DWordDataType(), "AddressOfNameOrdinals", null);
		struct.setCategoryPath(new CategoryPath("/PE"));
		return struct;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/ExportInfo.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

/**
 * A class to hold the information extracted from a 
 * export data directory.
 * 
 * NOTE:
 * This class is simply a storage class created for 
 * parsing the PE header data structures.
 * It does not map back to a PE data data structure.
 * 
 * 
 */
public class ExportInfo {
	private long address;
    private int ordinal;
	private String name;
    private String comment;
    private boolean forwarded;

    ExportInfo(long address, int ordinal, String name, String cmt, boolean forwarded) {
        this.address   = address;
        this.ordinal   = ordinal;
        this.name      = name;
        this.comment   = cmt;
        this.forwarded = forwarded;
    }

	/**
	 * Returns the adjusted address where the export occurs.
	 * @return the adjusted address where the export occurs
	 */
	public long getAddress() {
		return address;
	}

	/**
	 * Returns the ordinal value of the export.
	 * @return the ordinal value of the export
	 */
    public int getOrdinal() {
        return ordinal;
    }

	/**
	 * Returns the name of the export.
	 * @return the name of the export
	 */
    public String getName() {
        return name;
    }

	/**
	 * Returns a comment string containing extra information about the export.
	 * @return a comment string containing extra information about the export
	 */
    public String getComment() {
        return comment;
    }

	/**
	 * Returns true of this export is going to be forwarded.
	 * Generally, a forwarded export just through another export.
	 * @return true of this export is going to be forwarded
	 */
    public boolean isForwarded() {
        return forwarded;
    }

	/**
	 * @see java.lang.Object#toString()
	 */
	@Override
    public String toString() {
		return ordinal+" "+name+" at "+Long.toHexString(address);
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/FileHeader.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.ArrayList;
import java.util.List;

import ghidra.app.util.bin.StructConverter;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;
import net.jubjubnest.minidump.contrib.pe.debug.DebugCOFFSymbol;
import net.jubjubnest.minidump.contrib.pe.debug.DebugCOFFSymbolAux;
import ghidra.program.model.data.*;
import ghidra.program.model.mem.MemoryBlock;
import ghidra.util.DataConverter;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;

/**
 * A class to represent the IMAGE_FILE_HEADER struct as
 * defined in <code>winnt.h</code>.
 * <br>
 * <pre>
 * typedef struct _IMAGE_FILE_HEADER {
 *     WORD    Machine;								// MANDATORY
 *     WORD    NumberOfSections;					// USED
 *     DWORD   TimeDateStamp;
 *     DWORD   PointerToSymbolTable;
 *     DWORD   NumberOfSymbols;
 *     WORD    SizeOfOptionalHeader;				// USED
 *     WORD    Characteristics;						// MANDATORY
 * } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
 * </pre>
 * 
 */
public class FileHeader implements StructConverter {
	/**
	 * The name to use when converting into a structure data type.
	 */
	public final static String NAME = "IMAGE_FILE_HEADER";
	/**
	 * The size of the <code>IMAGE_FILE_HEADER</code> in bytes.
	 */
    public final static int IMAGE_SIZEOF_FILE_HEADER = 20;

	/**
	 * Relocation info stripped from file.
	 */
    public final static int IMAGE_FILE_RELOCS_STRIPPED           = 0x0001;
    /**
     * File is executable (no unresolved externel references).
     */
    public final static int IMAGE_FILE_EXECUTABLE_IMAGE          = 0x0002;
    /**
     * Line nunbers stripped from file.
     */
    public final static int IMAGE_FILE_LINE_NUMS_STRIPPED        = 0x0004;
    /**
     * Local symbols stripped from file.
     */
    public final static int IMAGE_FILE_LOCAL_SYMS_STRIPPED       = 0x0008;
    /**
     * Agressively trim working set
     */
    public final static int IMAGE_FILE_AGGRESIVE_WS_TRIM         = 0x0010;
    /**
     * App can handle &gt;2gb addresses
     */
    public final static int IMAGE_FILE_LARGE_ADDRESS_AWARE       = 0x0020;
    /**
     * Bytes of machine word are reversed.
     */
    public final static int IMAGE_FILE_BYTES_REVERSED_LO         = 0x0080;
    /**
     * 32 bit word machine.
     */
    public final static int IMAGE_FILE_32BIT_MACHINE             = 0x0100;
    /**
     * Debugging info stripped from file in .DBG file
     */
    public final static int IMAGE_FILE_DEBUG_STRIPPED            = 0x0200;
    /**
     * If Image is on removable media, copy and run from the swap file.
     */
    public final static int IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   = 0x0400;
    /**
     * If Image is on Net, copy and run from the swap file.
     */
    public final static int IMAGE_FILE_NET_RUN_FROM_SWAP         = 0x0800;
    /**
     * System File.
     */
    public final static int IMAGE_FILE_SYSTEM                    = 0x1000;
    /**
     * File is a DLL.
     */
    public final static int IMAGE_FILE_DLL                       = 0x2000;
    /**
     * File should only be run on a UP machine
     */
    public final static int IMAGE_FILE_UP_SYSTEM_ONLY            = 0x4000;
    /**
     * Bytes of machine word are reversed.
     */
    public final static int IMAGE_FILE_BYTES_REVERSED_HI         = 0x8000;

     public final static String [] CHARACTERISTICS = {
            "Relocation info stripped from file",
            "File is executable  (i.e. no unresolved externel references)",
            "Line nunbers stripped from file",
            "Local symbols stripped from file",
            "Agressively trim working set",
            "App can handle >2gb addresses",
            "Bytes of machine word are reversed",
            "32 bit word machine",
            "Debugging info stripped from file in .DBG file",
            "If Image is on removable media, copy and run from the swap file",
            "If Image is on Net, copy and run from the swap file",
            "System file",
            "File is a DLL",
            "File should only be run on a UP machine",
            "Bytes of machine word are reversed"
	};

    private short machine;
    private short numberOfSections;
    private int   timeDateStamp;
    private int   pointerToSymbolTable;
    private int   numberOfSymbols;
    private short sizeOfOptionalHeader; 	// delta between start of OptionalHeader and start of section table
    private short characteristics;

    private SectionHeader [] sectionHeaders;
    private List<DebugCOFFSymbol>symbols = new ArrayList<>();

    private FactoryBundledWithBinaryReader reader;
    private int startIndex;
    private NTHeader ntHeader;

    static FileHeader createFileHeader(
            FactoryBundledWithBinaryReader reader, int startIndex,
            NTHeader ntHeader) throws IOException {
        FileHeader fileHeader = (FileHeader) reader.getFactory().create(FileHeader.class);
        fileHeader.initFileHeader(reader, startIndex, ntHeader);
        return fileHeader;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public FileHeader() {}

    private void initFileHeader(FactoryBundledWithBinaryReader reader, int startIndex, NTHeader ntHeader) throws IOException {
        this.reader = reader;
        this.startIndex = startIndex;
        this.ntHeader = ntHeader;

        parse();
    }
    
	/**
	 * Returns the architecture type of the computer.
	 * @return the architecture type of the computer
	 */
    public short getMachine() {
		return machine;
	}

	/**
	 * Returns a string representation of the architecture type of the computer.
	 * @return a string representation of the architecture type of the computer
	 */
    public String getMachineName() {
    	return MachineName.getName(machine);
    }
    
	/**
	 * Returns the number of sections. 
	 * Sections equate to Ghidra memory blocks.
	 * @return the number of sections
	 */
    public int getNumberOfSections() {
        return numberOfSections;
    }

	/**
	 * Returns the array of section headers.
	 * @return the array of section headers
	 */
    public SectionHeader [] getSectionHeaders() {
    	if (sectionHeaders == null) {
    		return new SectionHeader[0];
    	}
        return sectionHeaders;
    }

	/**
	 * Returns the array of symbols.
	 * @return the array of symbols
	 */
    public List<DebugCOFFSymbol> getSymbols() {
		return symbols;
	}

	/**
	 * Returns the section header that contains the specified virtual address.
	 * @param virtualAddr the virtual address
	 * @return the section header that contains the specified virtual address
	 */
    public SectionHeader getSectionHeaderContaining(int virtualAddr) {
        for (SectionHeader sectionHeader : sectionHeaders) {
        	int start = sectionHeader.getVirtualAddress();
        	int   end = sectionHeader.getVirtualAddress()+sectionHeader.getVirtualSize()-1;
            if (virtualAddr >= start && virtualAddr <= end) {
                return sectionHeader;
            }
        }
        return null;
    }

	/**
	 * Returns the section header at the specified position in the array.
	 * @param index index of section header to return
	 * @return the section header at the specified position in the array, or null if invalid
	 */
    public SectionHeader getSectionHeader(int index) {
		if (index >= 0 && index < sectionHeaders.length) {
    		return sectionHeaders[index];
    	}
    	return null;
    }

	/**
	 * Returns the time stamp of the image.
	 * @return the time stamp of the image
	 */
    public int getTimeDateStamp() {
        return timeDateStamp;
    }

	/**
	 * Returns the file offset of the COFF symbol table
	 * @return the file offset of the COFF symbol table
	 */
    public int getPointerToSymbolTable() {
        return pointerToSymbolTable;
    }

	/**
	 * Returns the number of symbols in the COFF symbol table
	 * @return  the number of symbols in the COFF symbol table
	 */
    public int getNumberOfSymbols() {
        return numberOfSymbols;
    }

	/**
	 * Returns the size of the optional header data
	 * @return the size of the optional header, in bytes
	 */
    public int getSizeOfOptionalHeader() {
		return sizeOfOptionalHeader;
	}

	/**
	 * Returns a set of bit flags indicating attributes of the file. 
	 * @return a set of bit flags indicating attributes
	 */
    public int getCharacteristics() {
        return characteristics;
    }

	/**
	 * Returns the file pointer to the section headers.
	 * @return the file pointer to the section headers
	 */
    public int getPointerToSections() {
    	short sizeOptHdr = ntHeader.getFileHeader().sizeOfOptionalHeader;
		int ptrToSections = startIndex + IMAGE_SIZEOF_FILE_HEADER + sizeOptHdr;
    	int testSize = ntHeader.getOptionalHeader().is64bit()
              ? Constants.IMAGE_SIZEOF_NT_OPTIONAL64_HEADER
              : Constants.IMAGE_SIZEOF_NT_OPTIONAL32_HEADER;
    	if (sizeOptHdr != testSize) {
			Msg.warn(this, "Non-standard optional header size: " + sizeOptHdr + " bytes");
    	}
		return ptrToSections;
    }

    void processSections(OptionalHeader optHeader) throws IOException {
        long oldIndex = reader.getPointerIndex();

        int tmpIndex = getPointerToSections();
        if (numberOfSections < 0) {
        	Msg.error(this, "Number of sections = "+numberOfSections);
        } else if (optHeader.getFileAlignment() == 0) {
        	Msg.error(this, "File alignment == 0: section processing skipped");
        } else {
			sectionHeaders = new SectionHeader[numberOfSections];
			for (int i = 0; i < numberOfSections; ++i) {
				sectionHeaders[i] = SectionHeader.createSectionHeader(reader, ntHeader.getLoadInfo(), tmpIndex);

				// Ensure PointerToRawData + SizeOfRawData doesn't exceed the length of the file
				int pointerToRawData = sectionHeaders[i].getPointerToRawData();
				int sizeOfRawData = (int) Math.min(reader.length() - pointerToRawData,
					sectionHeaders[i].getSizeOfRawData());

				// Ensure VirtualSize is large enough to accommodate SizeOfRawData, but do not
				// exceed the next alignment boundary.  We can only do this if the VirtualAddress is
				// already properly aligned, since we currently don't support moving sections to
				// different addresses to enforce alignment.
				int virtualAddress = sectionHeaders[i].getVirtualAddress();
				int virtualSize = sectionHeaders[i].getVirtualSize();
				int alignedVirtualAddress = PortableExecutable.computeAlignment(virtualAddress,
					optHeader.getSectionAlignment());
				int alignedVirtualSize = PortableExecutable.computeAlignment(virtualSize,
					optHeader.getSectionAlignment());
				if (virtualAddress == alignedVirtualAddress) {
					if (sizeOfRawData > virtualSize) {
						sectionHeaders[i].setVirtualSize(
							Math.min(sizeOfRawData, alignedVirtualSize));
					}
				}
				else {
					Msg.warn(this, "Section " + sectionHeaders[i].getName() + " is not aligned!");
				}
				tmpIndex += SectionHeader.IMAGE_SIZEOF_SECTION_HEADER;
			}
		}

        reader.setPointerIndex(oldIndex);
    }

    void processSymbols() throws IOException {
        if (isLordPE()) {
            return;
        }

        long oldIndex = reader.getPointerIndex();

        int tmpIndex = getPointerToSymbolTable();
    	if (!ntHeader.checkRVA(tmpIndex)) {
        	Msg.error(this, "Invalid file index "+Integer.toHexString(tmpIndex));
    		return;	
    	}

        if ( numberOfSymbols < 0 || numberOfSymbols > reader.length()) {
        	Msg.error(this, "Invalid symbol count "+Integer.toHexString(numberOfSymbols));
        	return;
        }

        int stringTableIndex = tmpIndex + DebugCOFFSymbol.IMAGE_SIZEOF_SYMBOL * numberOfSymbols;
        
        for (int i = 0; i < numberOfSymbols; ++i) {
        	if (!ntHeader.checkRVA(tmpIndex)) {
            	Msg.error(this, "Invalid file index "+Integer.toHexString(tmpIndex));
        		break;	
        	}

        	DebugCOFFSymbol symbol = DebugCOFFSymbol.createDebugCOFFSymbol(reader, tmpIndex, stringTableIndex);

            tmpIndex += DebugCOFFSymbol.IMAGE_SIZEOF_SYMBOL;

            tmpIndex += (DebugCOFFSymbolAux.IMAGE_SIZEOF_AUX_SYMBOL * symbol.getNumberOfAuxSymbols());

            int numberOfAuxSymbols = symbol.getNumberOfAuxSymbols();
			i += numberOfAuxSymbols > 0 ? numberOfAuxSymbols : 0;

            symbols.add( symbol );
        }

        reader.setPointerIndex(oldIndex);
    }

    public boolean isLordPE() {
        if (getPointerToSymbolTable() == 0x726F4C5B && getNumberOfSymbols() == 0x5D455064) {
            return true;
        }
        return false;
    }

    private void parse() throws IOException {
        reader.setPointerIndex(startIndex);

        machine              = reader.readNextShort();
        numberOfSections     = reader.readNextShort();
        timeDateStamp        = reader.readNextInt  ();
        pointerToSymbolTable = reader.readNextInt  ();
        numberOfSymbols      = reader.readNextInt  ();
        sizeOfOptionalHeader = reader.readNextShort();
        characteristics      = reader.readNextShort();
    }

	/**
	 * @see ghidra.app.util.bin.StructConverter#toDataType()
	 */
	@Override
	public DataType toDataType() throws DuplicateNameException {
		StructureDataType struct = new StructureDataType(NAME, 0);

		struct.add(WORD,2,"Machine",getMachineName());
		struct.add(WORD,2,"NumberOfSections",null);
		struct.add(DWORD,4,"TimeDateStamp",null);
		struct.add(DWORD,4,"PointerToSymbolTable",null);
		struct.add(DWORD,4,"NumberOfSymbols",null);
		struct.add(WORD,2,"SizeOfOptionalHeader",null);
		struct.add(WORD,2,"Characteristics",null);

		struct.setCategoryPath(new CategoryPath("/PE"));

		return struct;
	}

	private void setSectionHeaders(SectionHeader [] sectionHeaders) {
		this.sectionHeaders = sectionHeaders;
		numberOfSections = (short)sectionHeaders.length;
	}

	void writeHeader(RandomAccessFile raf, DataConverter dc) throws IOException {
		raf.write(dc.getBytes(machine));
		raf.write(dc.getBytes(numberOfSections));
		raf.write(dc.getBytes(timeDateStamp));
		raf.write(dc.getBytes(pointerToSymbolTable));
		raf.write(dc.getBytes(numberOfSymbols));
		raf.write(dc.getBytes(sizeOfOptionalHeader));
		raf.write(dc.getBytes(characteristics));		
	}

	/**
	 * Adds a new section to this file header. Uses the given memory block
	 * as the section template. The section will have the memory block's name, start address,
	 * size, etc. The optional header is needed to determine the free byte position in the
	 * file.
	 * @param block the memory block template
	 * @param optionalHeader the related optional header
	 * @throws RuntimeException if the memory block is uninitialized
	 */
	public void addSection(MemoryBlock block, OptionalHeader optionalHeader) {
		DataDirectory [] directories = optionalHeader.getDataDirectories();

		DataDirectory [] dataDirectories = optionalHeader.getDataDirectories();


		SecurityDataDirectory sdd = null;
		if (dataDirectories.length > OptionalHeader.IMAGE_DIRECTORY_ENTRY_SECURITY) {
			sdd = (SecurityDataDirectory)dataDirectories[OptionalHeader.IMAGE_DIRECTORY_ENTRY_SECURITY];
			if (sdd != null && sdd.getSize() > 0) {
				sdd.updatePointers( PortableExecutable.computeAlignment( (int)block.getSize( ), optionalHeader.getFileAlignment( ) ) );
			}
		}


		int lastPos = computeAlignedNewPosition( optionalHeader, directories );

		SectionHeader newSection = new SectionHeader(block, optionalHeader, lastPos);

		SectionHeader [] newSectionHeaders = new SectionHeader[sectionHeaders.length + 1];
		System.arraycopy(sectionHeaders, 0, newSectionHeaders, 0, sectionHeaders.length);		
		newSectionHeaders[sectionHeaders.length] = newSection;
		setSectionHeaders(newSectionHeaders);

		int firstSectionStart = sectionHeaders[0].getPointerToRawData();
		int lastSectionEnd = sectionHeaders[sectionHeaders.length-1].getPointerToRawData()
									+sectionHeaders[sectionHeaders.length-1].getSizeOfRawData();

		for (int i = 0 ; i < directories.length ; i++) {
			if (directories[i] == null ||
				directories[i].getSize() == 0 || 
				directories[i].isContainedInSection()) {
				continue;
			}
			if (directories[i].getVirtualAddress() < firstSectionStart) {
				if (i != OptionalHeader.IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT) {
					throw new RuntimeException("PE - Unexpected directory before sections: "+i);
				}
			}
			if (directories[i].getVirtualAddress() > lastSectionEnd) {
				if (i != OptionalHeader.IMAGE_DIRECTORY_ENTRY_SECURITY) {
					throw new RuntimeException("PE - Unexpected directory after sections: "+i);
				}
			}
		}

		int offset = 0;

		
		if (dataDirectories.length > OptionalHeader.IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT) {
			BoundImportDataDirectory bidd = (BoundImportDataDirectory)dataDirectories[OptionalHeader.IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT];
			if (bidd != null && bidd.getSize() > 0) {
				bidd.updatePointers(SectionHeader.IMAGE_SIZEOF_SECTION_HEADER);
				int endptr = bidd.getVirtualAddress() + bidd.getSize() - 1;
				if (endptr >= sectionHeaders[0].getPointerToRawData()) {
					int alignedPtr = PortableExecutable.computeAlignment(endptr, optionalHeader.getFileAlignment());
					offset = alignedPtr - sectionHeaders[0].getPointerToRawData();
					for (SectionHeader sectionHeader : sectionHeaders) {
						sectionHeader.updatePointers(offset);
					}
					//reset the sizeOfHeaders...
					optionalHeader.setSizeOfHeaders(sectionHeaders[0].getPointerToRawData());
				}
			}
		}


		if (dataDirectories.length > OptionalHeader.IMAGE_DIRECTORY_ENTRY_DEBUG) {
			DebugDataDirectory ddd = (DebugDataDirectory)dataDirectories[OptionalHeader.IMAGE_DIRECTORY_ENTRY_DEBUG];
			if (ddd != null && ddd.getSize() > 0) {
				if (ddd.getVirtualAddress() > newSection.getVirtualAddress()) {
					if (sdd != null && sdd.getSize() > 0) {
						ddd.updatePointers(offset, sdd.getVirtualAddress() + sdd.getSize());
					}
					else {
						ddd.updatePointers(offset, newSection.getSizeOfRawData());
					}
				}
			}
		}

		if (block.isExecute()) {
			optionalHeader.setSizeOfCode(optionalHeader.getSizeOfCode() +
										newSection.getSizeOfRawData());
		}
		else {
			optionalHeader.setSizeOfInitializedData(optionalHeader.getSizeOfInitializedData() +
													newSection.getSizeOfRawData());
		}

		int soi = newSection.getVirtualAddress() + newSection.getSizeOfRawData();
		soi = PortableExecutable.computeAlignment(soi, optionalHeader.getSectionAlignment());
		optionalHeader.setSizeOfImage(soi);
	}

	private int computeAlignedNewPosition( OptionalHeader optionalHeader, DataDirectory [] directories ) {
		int lastPos = 0;
		for (SectionHeader sectionHeader : sectionHeaders) {
			if (sectionHeader.getPointerToRawData() + sectionHeader.getSizeOfRawData() > lastPos) {
				lastPos = sectionHeader.getPointerToRawData() + sectionHeader.getSizeOfRawData();
			}
		}
		for (DataDirectory directorie : directories) {
			if (directorie == null ||
				directorie.getSize() == 0) {
				continue;
			}
			if (directorie.rvaToPointer() + directorie.getSize() > lastPos) {
				lastPos = directorie.rvaToPointer() + directorie.getSize();
			}
		}
		return PortableExecutable.computeAlignment( lastPos, optionalHeader.getFileAlignment( ) );
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/GlobalPointerDataDirectory.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;

import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Program;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;

public class GlobalPointerDataDirectory extends DataDirectory {
    private final static String NAME = "IMAGE_DIRECTORY_ENTRY_GLOBALPTR";

	static GlobalPointerDataDirectory createGlobalPointerDataDirectory(
            NTHeader ntHeader, FactoryBundledWithBinaryReader reader)
            throws IOException {
	    GlobalPointerDataDirectory globalPointerDataDirectory = (GlobalPointerDataDirectory) reader.getFactory().create(GlobalPointerDataDirectory.class);
	    globalPointerDataDirectory.initGlobalPointerDataDirectory(ntHeader, reader);
	    return globalPointerDataDirectory;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public GlobalPointerDataDirectory() {}

    private void initGlobalPointerDataDirectory(NTHeader ntHeader, FactoryBundledWithBinaryReader reader) throws IOException {
		processDataDirectory(ntHeader, reader);
	}

	@Override
	public String getDirectoryName() {
		return NAME;
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor,
			MessageLog log, NTHeader ntHeader) throws DuplicateNameException, CodeUnitInsertionException,
			DataTypeConflictException, IOException {
		monitor.setMessage(program.getName()+": global pointers...");
		Address addr = PeUtils.getMarkupAddress(program, isBinary, ntHeader, virtualAddress);
		if (!program.getMemory().contains(addr)) {
			return;
		}
		createDirectoryBookmark(program, addr);
	}

	@Override
	public boolean parse() {
		int ptr = getPointer();
		if (ptr < 0) {
			return false;
		}
		return true;
    }

    /**
     * @see ghidra.app.util.bin.StructConverter#toDataType()
     */
    @Override
    public DataType toDataType() throws DuplicateNameException {
        StructureDataType struct = new StructureDataType(NAME, 0);
        struct.add(new ArrayDataType(BYTE,size,1), "GLOBAL_PTR", null);
        struct.setCategoryPath(new CategoryPath("/PE"));
        return struct;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/ImageCor20Header.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;

import ghidra.app.util.bin.StructConverter;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.CliMetadataDirectory;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.CliTableMethodDef.CliMethodDefRow;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;

/**
 * <pre>
 * typedef struct IMAGE_COR20_HEADER
 * {
 *     // Header versioning
 *    DWORD                   cb;                      // Size of the structure              
 *    WORD                    MajorRuntimeVersion;     // Version of the CLR Runtime
 *    WORD                    MinorRuntimeVersion;     // Version of the CLR Runtime
 *
 *    // Symbol table and startup information
 *    IMAGE_DATA_DIRECTORY    MetaData;                // A Data Directory giving RVA and Size of MetaData      
 *    DWORD                   Flags;
 *    union {
 *      DWORD                 EntryPointRVA;           // Points to the .NET native EntryPoint method
 *      DWORD                 EntryPointToken;         // Points to the .NET IL EntryPoint method
 *    };
 *
 *    // Binding information
 *    IMAGE_DATA_DIRECTORY    Resources;               // A Data Directory for Resources, which are referenced in the MetaData
 *    IMAGE_DATA_DIRECTORY    StrongNameSignature;     // A Data Directory for unique .NET assembly signatures
 *
 *    // Regular fixup and binding information
 *    IMAGE_DATA_DIRECTORY    CodeManagerTable;        // Always 0
 *    IMAGE_DATA_DIRECTORY    VTableFixups;            // Not well documented VTable used by languages who don't follow the common type system runtime model
 *    IMAGE_DATA_DIRECTORY    ExportAddressTableJumps; // Always 0 in normal .NET assemblies, only present in native images
 *
 *    // Precompiled image info (internal use only - set to zero)
 *    IMAGE_DATA_DIRECTORY    ManagedNativeHeader;
 *
 *};
 *</pre>
 *
 */
public class ImageCor20Header implements StructConverter, PeMarkupable {
	private static final String NAME = "IMAGE_COR20_HEADER";

    private int                      cb;
	private short                    majorRuntimeVersion;
	private short                    minorRuntimeVersion;
	private CliMetadataDirectory metadata;
	private int                      flags;
	private int                      entryPointToken;
	private DefaultDataDirectory     resources;
	private DefaultDataDirectory     strongNameSignature;
	private DefaultDataDirectory     codeManagerTable;
	private DefaultDataDirectory     vTableFixups;
	private DefaultDataDirectory     exportAddressTableJumps;
	private DefaultDataDirectory     managedNativeHeader;

	static ImageCor20Header createImageCor20Header(FactoryBundledWithBinaryReader reader,
			long index, NTHeader ntHeader) throws IOException {
		ImageCor20Header imageCor20Header =
			(ImageCor20Header) reader.getFactory().create(ImageCor20Header.class);
		imageCor20Header.initIMAGE_COR20_HEADER(reader, index, ntHeader);
		return imageCor20Header;
    }
    
	/**
	 * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
	 */
	public ImageCor20Header() {
	}

    private void initIMAGE_COR20_HEADER(FactoryBundledWithBinaryReader reader, long index, NTHeader ntHeader) throws IOException {
		long origIndex = reader.getPointerIndex();

		reader.setPointerIndex(index);

		cb                       = reader.readNextInt();
		majorRuntimeVersion      = reader.readNextShort();
		minorRuntimeVersion      = reader.readNextShort();
		metadata                 = CliMetadataDirectory.createCliMetadataDirectory(ntHeader, reader);
		flags                    = reader.readNextInt();
		entryPointToken          = reader.readNextInt();
		resources                = DefaultDataDirectory.createDefaultDataDirectory(ntHeader, reader);
		strongNameSignature      = DefaultDataDirectory.createDefaultDataDirectory(ntHeader, reader);
		codeManagerTable         = DefaultDataDirectory.createDefaultDataDirectory(ntHeader, reader);
		vTableFixups             = DefaultDataDirectory.createDefaultDataDirectory(ntHeader, reader);
		exportAddressTableJumps  = DefaultDataDirectory.createDefaultDataDirectory(ntHeader, reader);
		managedNativeHeader      = DefaultDataDirectory.createDefaultDataDirectory(ntHeader, reader);

		reader.setPointerIndex(origIndex);
	}
	
	/**
	 * Parses this header
	 * 
	 * @return True if parsing completed successfully; otherwise, false.
	 * @throws IOException If there was an IO problem while parsing.
	 */
	public boolean parse() throws IOException {
		boolean success = true;

		success &= metadata.parse();
		success &= resources.parse();
		success &= strongNameSignature.parse();
		success &= codeManagerTable.parse();
		success &= vTableFixups.parse();
		success &= exportAddressTableJumps.parse();
		success &= managedNativeHeader.parse();

		return success;
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor,
			MessageLog log, NTHeader ntHeader) throws DuplicateNameException, CodeUnitInsertionException,
			IOException, MemoryAccessException {

		if (!metadata.hasParsedCorrectly()) {
			return;
		}

		metadata.markup(program, isBinary, monitor, log, ntHeader);

		if (entryPointToken > 0) { // DLL's won't have an entry point
			try {
				if ((flags &
					ImageCor20Flags.COMIMAGE_FLAGS_NATIVE_ENTRYPOINT) == ImageCor20Flags.COMIMAGE_FLAGS_NATIVE_ENTRYPOINT) {
					// Add new symbol for the native entry point
					program.getSymbolTable().addExternalEntryPoint(
						program.getImageBase().add(ntHeader.getLoadInfo().imageBase).add(entryPointToken));
				}
				else {
					// Add a new symbol for the .NET entry point
					CliStreamMetadata stream =
						(CliStreamMetadata) metadata.getMetadataRoot().getStreamHeader(
							CliStreamMetadata.getName()).getStream();
					CliMethodDefRow row = (CliMethodDefRow) stream.getTable(
						(entryPointToken & 0xff000000) >> 24).getRow(entryPointToken & 0x00ffffff);
					program.getSymbolTable().addExternalEntryPoint(
						program.getImageBase().add(row.RVA));
				}
			}
			catch (Exception e) {
				log.appendException(e);
			}
		}
	}

	@Override
	public DataType toDataType() throws DuplicateNameException, IOException {
		StructureDataType struct = new StructureDataType(NAME, 0);
		struct.add(new DWordDataType(), "cb", "Size of the structure");
		struct.add(new WordDataType(), "MajorRuntimeVersion", "Version of CLR Runtime");
		struct.add(new WordDataType(), "MinorRuntimeVersion", null);
		struct.add(metadata.toDataType(), "MetaData", "RVA and size of MetaData");
		struct.add(new ImageCor20Flags(), "Flags", null);
		struct.add(new DWordDataType(), "EntryPointToken", null);
		struct.add(resources.toDataType(), "Resources", null);
		struct.add(strongNameSignature.toDataType(), "StrongNameSignature", null);
		struct.add(codeManagerTable.toDataType(), "CodeManagerTable", "Should be 0");
		struct.add(vTableFixups.toDataType(), "VTableFixups", null);
		struct.add(exportAddressTableJumps.toDataType(), "ExportAddressTableJumps", "Should be 0");
		struct.add(managedNativeHeader.toDataType(), "ManagedNativeHeader",
			"0 unless this is a native image");
		struct.setCategoryPath(new CategoryPath("/PE"));
		return struct;
	}

	/**
	 * Gets the size of this structure in bytes.
	 * 
	 * @return The size of this structure in bytes.
	 */
	public int getCb() {
		return cb;
	}

	/**
	 * Gets the major runtime version.
	 * 
	 * @return The major runtime version.
	 */
	public short getMajorRuntimeVersion() {
		return majorRuntimeVersion;
	}

	/**
	 * Gets the major runtime version.
	 * 
	 * @return The major runtime version.
	 */
	public short getMinorRuntimeVersion() {
		return minorRuntimeVersion;
	}

	/**
	 * Gets the MetaData directory.
	 * 
	 * @return The MetaData directory.
	 */
	public CliMetadataDirectory getMetadata() {
		return metadata;
	}

	/**
	 * Gets the flags.
	 * 
	 * @return The flags.
	 */
	public int getFlags() {
		return flags;
	}

	/**
	 * Gets the entry point token (or RVA).
	 * 
	 * @return The entry point token (or RVA).
	 */
	public int getEntryPointToken() {
		return entryPointToken;
	}

	/**
	 * Gets the Resources directory.
	 * 
	 * @return The Resources directory.
	 */
	public DefaultDataDirectory getResources() {
		return resources;
	}

	/**
	 * Gets the StrongNameSignature directory.
	 * @return The StrongNameSignature directory.
	 */
	public DefaultDataDirectory getStrongNameSignature() {
		return strongNameSignature;
	}

	/**
	 * Gets the CodeManagerTable directory.
	 * @return The CodeManagerTable directory.
	 */
	public DefaultDataDirectory getCodeManagerTable() {
		return codeManagerTable;
	}

	/**
	 * Gets the VTableFixups directory.
	 * @return The VTableFixups directory.
	 */
	public DefaultDataDirectory getVTableFixups() {
		return vTableFixups;
	}

	/**
	 * Gets the ExportAddressTableJumps directory.
	 * @return The ExportAddressTableJumps directory.
	 */
	public DefaultDataDirectory getExportAddressTableJumps() {
		return exportAddressTableJumps;
	}

	/**
	 * Gets the ManagedNativeHeader directory.
	 * @return The ManagedNativeHeader directory.
	 */
	public DefaultDataDirectory getManagedNativeHeader() {
		return managedNativeHeader;
	}

	/**
	 * Data type for {@link ImageCor20Header#flags}.
	 */
	public static class ImageCor20Flags extends EnumDataType {

		public static final String PATH = "/PE/CLI/Flags";

		public static final int COMIMAGE_FLAGS_ILONLY = 0x00000001;
		public static final int COMIMAGE_FLAGS_32BITREQUIRED = 0x00000002;
		public static final int COMIMAGE_FLAGS_IL_LIBRARY = 0x00000004;
		public static final int COMIMAGE_FLAGS_STRONGNAMESIGNED = 0x00000008;
		public static final int COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 0x00000010;
		public static final int COMIMAGE_FLAGS_TRACKDEBUGDATA = 0x00010000;

		public ImageCor20Flags() {
			super(new CategoryPath(PATH), "COR20_Flags", 4);
			String prefix = "COMIMAGE_FLAGS_";
			add(prefix + "ILONLY", COMIMAGE_FLAGS_ILONLY);
			add(prefix + "32BITREQUIRED", COMIMAGE_FLAGS_32BITREQUIRED);
			add(prefix + "IL_LIBRARY", COMIMAGE_FLAGS_IL_LIBRARY);
			add(prefix + "STRONGNAMESIGNED", COMIMAGE_FLAGS_STRONGNAMESIGNED);
			add(prefix + "NATIVE_ENTRYPOINT", COMIMAGE_FLAGS_NATIVE_ENTRYPOINT);
			add(prefix + "TRACKDEBUGDATA", COMIMAGE_FLAGS_TRACKDEBUGDATA);
		}
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/ImportAddressTableDataDirectory.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;

public class ImportAddressTableDataDirectory extends DataDirectory {
    private final static String NAME = "IMAGE_DIRECTORY_ENTRY_IAT";

    private List<ThunkData []> thunkDataSetList;

    static ImportAddressTableDataDirectory createImportAddressTableDataDirectory(
            NTHeader ntHeader, FactoryBundledWithBinaryReader reader)
            throws IOException {
        ImportAddressTableDataDirectory importAddressTableDataDirectory = (ImportAddressTableDataDirectory) reader.getFactory().create(ImportAddressTableDataDirectory.class);
        importAddressTableDataDirectory.initImportAddressTableDataDirectory(ntHeader, reader);
        return importAddressTableDataDirectory;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public ImportAddressTableDataDirectory() {}

	private void initImportAddressTableDataDirectory(NTHeader ntHeader, FactoryBundledWithBinaryReader reader) throws IOException {
		processDataDirectory(ntHeader, reader);
	}

	/**
	 * Returns the thunk data set at the specified index.
	 * @param index the desired thunk data index
	 * @return the thunk data array at the specified index
	 */
	public ThunkData [] getThunkDataSet(int index) {
		return thunkDataSetList.get(index);
	}

	@Override
	public String getDirectoryName() {
		return NAME;
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor,
			MessageLog log, NTHeader ntHeader) throws CodeUnitInsertionException, MemoryAccessException {

		monitor.setMessage(program.getName()+": IAT...");
		Address addr = PeUtils.getMarkupAddress(program, isBinary, ntHeader, virtualAddress);
		if (!program.getMemory().contains(addr)) {
			return;
		}
		createDirectoryBookmark(program, addr);
	}

	@Override
	public boolean parse() throws IOException {
		thunkDataSetList = new ArrayList<ThunkData []>();

		int ptr = getPointer();
		if (ptr < 0) {
			return false;
		}

		List<ThunkData> thunkList = new ArrayList<ThunkData>();

		if (size > NTHeader.MAX_SANE_COUNT * 8) {
			Msg.error(this, "Large ImportAddressTable not parsed, size = "+size);
			return false;
		}
		int tmp = size;

    	while (tmp > 0) {
			ThunkData thunk = ThunkData.createThunkData(reader, ptr, ntHeader.getOptionalHeader().is64bit());

			if (thunk.getAddressOfData() == 0) {
				ThunkData [] set = new ThunkData[thunkList.size()];
				thunkList.toArray(set);
				thunkList.clear();
				thunkDataSetList.add(set);
			}
			else {
				thunkList.add(thunk);
			}

			ptr += thunk.getStructSize();
			tmp -= thunk.getStructSize();
    	}
    	return true;
    }

    /**
     * @see ghidra.app.util.bin.StructConverter#toDataType()
     */
    @Override
    public DataType toDataType() throws DuplicateNameException {
        StructureDataType struct = new StructureDataType(NAME, 0);
        struct.add(new ArrayDataType(BYTE, size, 1), "IAT", null);
        struct.setCategoryPath(new CategoryPath("/PE"));
        return struct;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/ImportByName.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;
import ghidra.program.model.data.*;
import ghidra.util.*;
import ghidra.util.exception.*;

import java.io.*;

/**
 * A class to represent the <code>IMAGE_IMPORT_BY_NAME</code>
 * data structure defined in <b><code>winnt.h</code></b>.
 *
 * <pre>
 * typedef struct _IMAGE_IMPORT_BY_NAME {
 *     WORD    Hint;
 *     BYTE    Name[1];
 * };
 * </pre>
 * 
 * 
 */
public class ImportByName implements StructConverter, ByteArrayConverter {
	public final static String NAME = "IMAGE_IMPORT_BY_NAME";

    private short  hint;
    private String name;

    static ImportByName createImportByName(
            FactoryBundledWithBinaryReader reader, int index)
            throws IOException {
        ImportByName importByName = (ImportByName) reader.getFactory().create(ImportByName.class);
        importByName.initImportByName(reader, index);
        return importByName;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public ImportByName() {}

	private void initImportByName(FactoryBundledWithBinaryReader reader, int index) throws IOException {
        hint = reader.readShort(index);
        name = reader.readAsciiString(index+BinaryReader.SIZEOF_SHORT);
    }

	/**
	 * @param hint the import hint (ordinal)
	 * @param name the name of the imported function.
	 */
	public ImportByName(short hint, String name) {
		this.hint = hint;
		this.name = name;
	}

    /**
     * @return the export ordinal for the imported function
     */
	public short getHint() {
        return hint;
    }

    /**
     * Returns an ASCIIZ string with the name of the imported function.
     * @return an ASCIIZ string with the name of the imported function
     */
	public String getName() {
        return name;
    }

	/**
	 * @see ghidra.app.util.bin.StructConverter#toDataType()
	 */
	public DataType toDataType() throws DuplicateNameException {
		int len = name.length()+1;
		StructureDataType struct = new StructureDataType(NAME+"_"+len, 0);
		struct.add(WORD, "Hint", null);
		struct.add(STRING, len, "Name", null);
		struct.setCategoryPath(new CategoryPath("/PE"));
		return struct;
	}

	/**
	 * @see ghidra.app.util.bin.ByteArrayConverter#toBytes(ghidra.util.DataConverter)
	 */
	public byte [] toBytes(DataConverter dc) {
		byte [] bytes = new byte[getSizeOf()];
		dc.getBytes(hint, bytes, 0);
		byte [] nameBytes = name.getBytes();
		System.arraycopy(nameBytes, 0, bytes, 2, nameBytes.length);
		return bytes;
	}

	/**
	 * Returns the actual number of bytes consumed by this structure in memory.
	 * @return the actual number of bytes consumed by this structure in memory
	 */
	public int getSizeOf() {
		return BinaryReader.SIZEOF_SHORT+name.length()+1;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/ImportDataDirectory.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.*;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.*;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;

/**
 * Points to the imports (an array of IMAGE_IMPORT_DESCRIPTOR structures).
 */
public class ImportDataDirectory extends DataDirectory {
	private final static String NAME = "IMAGE_DIRECTORY_ENTRY_IMPORT";

	private ImportDescriptor[] descriptors;
	private ImportInfo[] imports;

	ExportDataDirectory exportDirectory;
	DataConverter conv = LittleEndianDataConverter.INSTANCE;

	static ImportDataDirectory createImportDataDirectory(NTHeader ntHeader,
			FactoryBundledWithBinaryReader reader) throws IOException {
		ImportDataDirectory importDataDirectory =
			(ImportDataDirectory) reader.getFactory().create(ImportDataDirectory.class);
		importDataDirectory.initImportDataDirectory(ntHeader, reader);
		return importDataDirectory;
	}

	/**
	 * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
	 */
	public ImportDataDirectory() {
	}

	private void initImportDataDirectory(NTHeader ntHeader, FactoryBundledWithBinaryReader reader)
			throws IOException {
		processDataDirectory(ntHeader, reader);

		if (imports == null) {
			imports = new ImportInfo[0];
		}
		if (descriptors == null) {
			descriptors = new ImportDescriptor[0];
		}
	}

	/**
	 * Returns the array of ImportInfo defined in this import directory.
	 * @return the array of ImportInfo defined in this import directory
	 */
	public ImportInfo[] getImports() {
		return imports;
	}

	/**
	 * Returns the array of ImportDescriptor defined in this import directory.
	 * @return the array of ImportDescriptor defined in this import directory
	 */
	public ImportDescriptor[] getImportDescriptors() {
		return descriptors;
	}

	@Override
	public String getDirectoryName() {
		return NAME;
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor,
			MessageLog log, NTHeader ntHeader) throws DuplicateNameException, CodeUnitInsertionException,
			DataTypeConflictException, IOException, MemoryAccessException {

		if (imports == null || descriptors == null) {
			return;
		}
		monitor.setMessage("[" + program.getName() + "]: import(s)...");
		Address addr = PeUtils.getMarkupAddress(program, isBinary, ntHeader, virtualAddress);
		if (!program.getMemory().contains(addr)) {
			return;
		}
		createDirectoryBookmark(program, addr);

		TerminatedStringDataType tsdt = new TerminatedStringDataType();
		AddressSpace space = program.getAddressFactory().getDefaultAddressSpace();

		for (ImportDescriptor descriptor : descriptors) {//markup the import descriptor(s)...
			if (monitor.isCancelled()) {
				break;
			}

			setPlateComment(program, addr, ImportDescriptor.NAME);
			for (int j = 0; j < 5; ++j) {
				PeUtils.createData(program, addr, DWORD, log);
				addr = addr.add(DWORD.getLength());
			}

			if (descriptor.getName() == 0 && descriptor.getTimeDateStamp() == 0) {
				continue;
			}

			String dll = descriptor.getDLL();
			if (dll != null && dll.startsWith(program.getName())) {
				Msg.warn(this,
					program.getName() + " potentially modified via import of local exports");
				DataDirectory[] dataDirectories = ntHeader.getOptionalHeader().getDataDirectories();
				exportDirectory =
					(ExportDataDirectory) dataDirectories[OptionalHeader.IMAGE_DIRECTORY_ENTRY_EXPORT];
			}

			long nameAddr = va(descriptor.getName(), isBinary);

			Address nameAddress = space.getAddress(nameAddr);
			setPlateComment(program, nameAddress, ImportDescriptor.NAME + " - DLL NAME");
			PeUtils.createData(program, nameAddress, tsdt, log);

			int intptr =
				descriptor.getOriginalFirstThunk() != 0 ? descriptor.getOriginalFirstThunk()
						: descriptor.getFirstThunk();

			int iatptr = descriptor.getFirstThunk();

			ThunkData[] thunks = descriptor.getImportNameTableThunkData();
			for (int j = 0; j < thunks.length; ++j) {
				if (monitor.isCancelled()) {
					break;
				}

				try {
					markupINT(intptr, iatptr, isBinary, program, thunks[j], log);
					markupIAT(iatptr, isBinary, program, log);
				}
				catch (MemoryAccessException mae) {
					Msg.error(this,
						"Invalid memory access for iaptr " + Integer.toHexString(iatptr));
					break;
				}

				// OK, this is kind of a hack and maybe unnecessary, but it adds some value in the import-of-export case
				if (descriptor.getDLL().startsWith(program.getName())) {
					ExportInfo exportInfo = exportDirectory.getExports()[j];
					long address = exportInfo.getAddress();
					long thunkAddr = va(intptr, isBinary);
					byte[] bytes = ntHeader.getOptionalHeader().is64bit() ? conv.getBytes(address)
							: conv.getBytes((int) address);
					try {
						program.getMemory().setBytes(
							program.getImageBase().getAddress(Long.toHexString(thunkAddr)), bytes);
					}
					catch (AddressFormatException e) {
						Msg.warn(this, "Unable to convert " + thunkAddr);
					}
				}

				intptr += thunks[j].getStructSize();
				iatptr += thunks[j].getStructSize();

				ImportByName ibn = thunks[j].getImportByName();
				if (!thunks[j].isOrdinal() && ibn != null) {
					long ibnAddr = va(thunks[j].getAddressOfData(), isBinary);
					Address ibnAddress = space.getAddress(ibnAddr);
					setPlateComment(program, ibnAddress, ImportByName.NAME);
					PeUtils.createData(program, ibnAddress, WORD, log);
					Address ibnNameAddress = ibnAddress.add(WORD.getLength());
					PeUtils.createData(program, ibnNameAddress, tsdt, log);
				}

			}
		}
	}

	private void markupIAT(int iatptr, boolean isBinary, Program program, MessageLog log)
			throws MemoryAccessException {
		DataType dt = null;
		if (isBinary) {
			dt = ntHeader.getOptionalHeader().is64bit() ? (DataType) QWORD : (DataType) DWORD;
		}
		else {
			dt = PointerDataType.getPointer(null, -1);
		}
		AddressSpace space = program.getAddressFactory().getDefaultAddressSpace();
		long thunkAddr = va(iatptr, isBinary);
		Address thunkAddress = space.getAddress(thunkAddr);
		if (program.getMemory().getInt(thunkAddress) != 0) {
			PeUtils.createData(program, thunkAddress, dt, log);
		}
	}

	private void markupINT(int intptr, int iatptr, boolean isBinary, Program program,
			ThunkData thunk, MessageLog log) {

		AddressSpace space = program.getAddressFactory().getDefaultAddressSpace();
		long thunkAddr = va(intptr, isBinary);
		Address thunkAddress = space.getAddress(thunkAddr);
		setEolComment(program, thunkAddress, thunk.getStructName());

		DataType dt = null;
		if (intptr == iatptr && !isBinary) {
			dt = PointerDataType.getPointer(null, program.getMinAddress().getPointerSize());
		}
		else {
			dt = ntHeader.getOptionalHeader().is64bit() ? (DataType) QWORD : (DataType) DWORD;
		}
		PeUtils.createData(program, thunkAddress, dt, log);
	}

	@Override
	public boolean parse() throws IOException {
		List<ImportInfo> importList = new ArrayList<>();
		List<ImportDescriptor> descriptorsList = new ArrayList<>();

		int ptr = getPointer();
		if (ptr < 0) {
			return false;
		}

		ImportDescriptor id = ImportDescriptor.createImportDescriptor(reader, ptr);
		while (!id.isNullEntry()) {

			ptr += ImportDescriptor.SIZEOF;
			if (descriptorsList.size() > NTHeader.MAX_SANE_COUNT) {
				Msg.error(this, "Too many import descriptors");
				return false;
			}
			descriptorsList.add(id);

			if (id.getName() == 0 && id.getTimeDateStamp() == 0) {
				break;
			}

			int tmpPtr = ntHeader.rvaToPointer(id.getName());
			if (tmpPtr < 0) {
				//Msg.error(this, "Invalid RVA "+id.getName());
				id = ImportDescriptor.createImportDescriptor(reader, ptr);
				continue;
			}
			String dllName = reader.readAsciiString(tmpPtr);
			id.setDLL(dllName);

			if (id.getOriginalFirstThunk() == 0 && id.getFirstThunk() == 0) {
				return false;
			}

			int intptr = -1;
			if (id.getOriginalFirstThunk() != 0) {
				intptr = ntHeader.rvaToPointer(id.getOriginalFirstThunk());
			}
			if (intptr < 0) {
				intptr = ntHeader.rvaToPointer(id.getFirstThunk());
			}
			if (intptr < 0) {
				Msg.error(this, "Invalid RVA " + Integer.toHexString(id.getOriginalFirstThunk()) +
					" : " + Integer.toHexString(id.getFirstThunk()));
				id = ImportDescriptor.createImportDescriptor(reader, ptr);
				return false;
			}
			int iatptr = ntHeader.rvaToPointer(id.getFirstThunk());

			int nextPosToCreateExternalRef = 0;
			while (true) {
				if (!ntHeader.checkPointer(intptr)) {
					Msg.error(this, "Invalid file index " + Integer.toHexString(intptr));
					break;
				}
				if (!ntHeader.checkPointer(iatptr)) {
					Msg.error(this, "Invalid file index " + Integer.toHexString(iatptr));
					break;
				}

				ThunkData intThunk = ThunkData.createThunkData(reader, intptr,
					ntHeader.getOptionalHeader().is64bit());
				intptr += intThunk.getStructSize();

				ThunkData iatThunk = ThunkData.createThunkData(reader, iatptr,
					ntHeader.getOptionalHeader().is64bit());
				iatptr += iatThunk.getStructSize();

				if (intThunk.getAddressOfData() == 0) {
					break;
				}
				id.addImportNameTableThunkData(intThunk);
				id.addImportAddressTableThunkData(iatThunk);

				int addr = id.getFirstThunk() + nextPosToCreateExternalRef;
				nextPosToCreateExternalRef += intThunk.getStructSize();

				String boundName = null;
				long ordinal = -1;

				if (intThunk.isOrdinal()) {
					ordinal = intThunk.getOrdinal();
					String ordinalStr = "Ordinal" + "_" + ordinal;
					boundName = ordinalStr;
				}
				else {
					// retrieve the IMAGE_IMPORT_BY_NAME struct, but do so in pieces
					int ptrToData = ntHeader.rvaToPointer((int) intThunk.getAddressOfData());
					if (ptrToData < 0) {
						Msg.error(this,
							"Invalid RVA " + Long.toHexString(intThunk.getAddressOfData()));
						break;
					}
					ImportByName ibn = ImportByName.createImportByName(reader, ptrToData);

					intThunk.setImportByName(ibn);

					boundName = ibn.getName();
					ordinal = ibn.getHint();
				}

				StringBuffer cmt = new StringBuffer();
				if (ordinal != -1) {
					cmt.append(Long.toString(ordinal) + "  ");
				}
				if (boundName != null) {
					cmt.append(boundName + "  ");
				}
				if (id.isBound()) {
					long boundAddr = iatThunk.getAddressOfData();
					cmt.append("[Bound to: 0x" + Long.toHexString(boundAddr) + "]");
				}
				else {
					cmt.append("<<not bound>>");
				}
				if (importList.size() > NTHeader.MAX_SANE_COUNT) {
					Msg.error(this, "Too many imports");
					return false;
				}
				importList.add(
					new ImportInfo(addr, cmt.toString(), dllName, boundName, id.isBound()));
			}
			id = ImportDescriptor.createImportDescriptor(reader, ptr);
		}

		imports = new ImportInfo[importList.size()];
		importList.toArray(imports);

		descriptors = new ImportDescriptor[descriptorsList.size()];
		descriptorsList.toArray(descriptors);
		return true;
	}

	/**
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		StringBuffer buff = new StringBuffer();
		buff.append("\t\t" + "Import Directory: [" + super.toString() + "]" + "\n");
		for (ImportInfo info : imports) {
			buff.append("\t\t\t" + "0x" + Long.toHexString(info.getAddress()) + "  " +
				info.getDLL() + " " + info.getName() + "\n");
		}
		return buff.toString();
	}

	/**
	 * @see ghidra.app.util.bin.StructConverter#toDataType()
	 */
	@Override
	public DataType toDataType() throws DuplicateNameException {
		StructureDataType struct = new StructureDataType(NAME, 0);
		DataType array = new ArrayDataType(BYTE, size, 1);
		struct.add(array, array.getLength(), "IMPORT", null);
		struct.setCategoryPath(new CategoryPath("/PE"));
		return struct;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/ImportDescriptor.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.program.model.data.*;
import ghidra.util.DataConverter;
import ghidra.util.exception.DuplicateNameException;

/**
 * <pre>
 * typedef struct _IMAGE_IMPORT_DESCRIPTOR {
 *     union {
 *         DWORD   Characteristics;            // 0 for terminating null import descriptor
 *         DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
 *     };
 *     DWORD   TimeDateStamp;
 *     DWORD   ForwarderChain;                 // -1 if no forwarders
 *     DWORD   Name;
 *     DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
 * }
 * </pre>
 * 
 * 
 */
public class ImportDescriptor implements StructConverter, ByteArrayConverter {
    public final static String NAME = "IMAGE_IMPORT_DESCRIPTOR";
    public final static int SIZEOF = 20; //bytes
	public final static int NOT_BOUND = 0;

    private int characteristics;
    private int originalFirstThunk;
    private int timeDateStamp;
    private int forwarderChain;
    private int name;
    private int firstThunk;

	private String dll;

	private List<ThunkData> intList = new ArrayList<ThunkData>();
	private List<ThunkData> iatList = new ArrayList<ThunkData>();

    static ImportDescriptor createImportDescriptor(
            FactoryBundledWithBinaryReader reader, int index)
            throws IOException {
        ImportDescriptor importDescriptor = (ImportDescriptor) reader.getFactory().create(ImportDescriptor.class);
        importDescriptor.initImportDescriptor(reader, index);
        return importDescriptor;
    }

    private void initImportDescriptor(FactoryBundledWithBinaryReader reader, int index) throws IOException {
        characteristics    = reader.readInt(index); index += BinaryReader.SIZEOF_INT;
        originalFirstThunk = characteristics;
        timeDateStamp      = reader.readInt(index); index += BinaryReader.SIZEOF_INT;
        forwarderChain     = reader.readInt(index); index += BinaryReader.SIZEOF_INT;
        name               = reader.readInt(index); index += BinaryReader.SIZEOF_INT;
        firstThunk         = reader.readInt(index); index += BinaryReader.SIZEOF_INT;
    }

    /**
     * Constructs a new import descriptor initialized to zero.
     */
	public ImportDescriptor() {
		this.characteristics    = 0;
		this.originalFirstThunk = 0;
		this.timeDateStamp      = 0;
		this.forwarderChain     = 0;
		this.name               = 0;
		this.firstThunk         = 0;
	}

	void setDLL(String dll) {
		this.dll = dll;
	}

	public String getDLL() {
		return dll;
	}

	void addImportNameTableThunkData(ThunkData thunk) {
		intList.add(thunk);
	}

	void addImportAddressTableThunkData(ThunkData thunk) {
		iatList.add(thunk);
	}

	/**
	 * Returns the array of thunks from the import name table.
	 * @return the array of thunks from the import name table
	 */
	public ThunkData [] getImportNameTableThunkData() {
		ThunkData [] data = new ThunkData[intList.size()];
		intList.toArray(data);
		return data;
	}

	/**
	 * Returns the array of thunks from the import address table.
	 * @return the array of thunks from the import address table
	 */
	public ThunkData [] getImportAddressTableThunkData() {
		ThunkData [] data = new ThunkData[iatList.size()];
		iatList.toArray(data);
		return data;
	}

    /**
     * At one time, this may have been a set of flags. 
     * However, Microsoft changed its meaning and 
     * never bothered to update WINNT.H. 
     * This field is really an offset (an RVA) to an 
     * array of pointers. Each of these pointers points 
     * to an IMAGE_IMPORT_BY_NAME structure. 
     * @return an offset (an RVA) to an array of pointers
     */
    public int getCharacteristics() {
        return characteristics;
    }

	/**
	 * At one time, this may have been a set of flags. 
	 * However, Microsoft changed its meaning and 
	 * never bothered to update WINNT.H. 
	 * This field is really an offset (an RVA) to an 
	 * array of pointers. Each of these pointers points 
	 * to an IMAGE_IMPORT_BY_NAME structure. 
	 * @return an offset (an RVA) to an array of pointers
	 */
	public int getOriginalFirstThunk() {
		return originalFirstThunk;
	}

    /**
     * This field is an offset (an RVA) to an 
     * IMAGE_THUNK_DATA union. In almost every case, 
     * the union is interpreted as a pointer to an 
     * IMAGE_IMPORT_BY_NAME structure. If the field 
     * isn't one of these pointers, then it's supposedly 
     * treated as an export ordinal value for the DLL 
     * that's being imported. It's not clear from the 
     * documentation if you really can import a function 
     * by ordinal rather than by name. 
     * @return an offset (an RVA) to an IMAGE_THUNK_DATA union
     */
    public int getFirstThunk() {
        return firstThunk;
    }

    /**
     * This field relates to forwarding. 
     * Forwarding involves one DLL sending on 
     * references to one of its functions to 
     * another DLL. For example, in Windows NT, 
     * NTDLL.DLL appears to forward some of its 
     * exported functions to KERNEL32.DLL. An 
     * application may think it's calling a function 
     * in NTDLL.DLL, but it actually ends up calling 
     * into KERNEL32.DLL. This field contains an index 
     * into FirstThunk array (described momentarily). 
     * The function indexed by this field will be 
     * forwarded to another DLL. Unfortunately, the 
     * format of how a function is forwarded isn't 
     * documented, and examples of forwarded functions 
     * are hard to find. 
     * @return the forwarder chain
     */
    public int getForwarderChain() {
        return forwarderChain;
    }

    /**
     * Returns an RVA to a NULL-terminated 
     * ASCII string containing the imported 
     * DLL's name. Common examples are 
     * "KERNEL32.DLL" and "USER32.DLL".
     * @return an RVA to a NULL-terminated ASCII string
     */
    public int getName() {
        return name;
    }

    /**
     * Returns the time/date stamp indicating when the file was built. 
     * @return the time/date stamp indicating when the file was built 
     */
    public int getTimeDateStamp() {
        return timeDateStamp;
    }

    /**
     * Returns true if the import descriptor is bound to an imported library.
     * Being bound implies that the import has the function's preferred address
     * @return true if the import descriptor is bound
     */
	public boolean isBound() {
		return timeDateStamp != NOT_BOUND;
	}

    /**
     * @see ghidra.app.util.bin.StructConverter#toDataType()
     */
    public DataType toDataType() throws DuplicateNameException {
        UnionDataType union = new UnionDataType("union");
        union.add(DWORD, "Characteristics",    null);
        union.add(DWORD, "OriginalFirstThunk", null);
        union.setCategoryPath(new CategoryPath("/PE"));

        StructureDataType struct = new StructureDataType(NAME, 0);
        struct.add(union, "union",          null);
        struct.add(DWORD, "TimeDateStamp",  null);
        struct.add(DWORD, "ForwarderChain", null);
        struct.add(DWORD, "Name",           null);
        struct.add(DWORD, "FirstThunk",     null);
        struct.setCategoryPath(new CategoryPath("/PE"));
        return struct;
    }

    /**
     * @see ghidra.app.util.bin.ByteArrayConverter#toBytes(ghidra.util.DataConverter)
     */
	public byte [] toBytes(DataConverter dc) {
		byte [] bytes = new byte[SIZEOF];

		int pos = 0;

		dc.getBytes(originalFirstThunk, bytes, pos);
		pos += BinaryReader.SIZEOF_INT;

		dc.getBytes(timeDateStamp, bytes, pos);
		pos += BinaryReader.SIZEOF_INT;

		dc.getBytes(forwarderChain, bytes, pos);
		pos += BinaryReader.SIZEOF_INT;

		dc.getBytes(name, bytes, pos);
		pos += BinaryReader.SIZEOF_INT;

		dc.getBytes(firstThunk, bytes, pos);
		pos += BinaryReader.SIZEOF_INT;

		return bytes;
	}

	/**
	 * Sets the original first thunk to the specifed value. 
	 * @param i the new original first thunk value.
	 * @see #getOriginalFirstThunk()
	 */
	public void setOriginalFirstThunk(int i) {
		originalFirstThunk = i;
	}

	/**
	 * Sets the time/date stamp to the specifed value. 
	 * @param i the new time/date stamp value.
	 * @see #getTimeDateStamp()
	 */
	public void setTimeDateStamp(int i) {
		timeDateStamp = i;
	}

	/**
	 * Sets the forwarder to the specifed value. 
	 * @param i the new forwarder value.
	 * @see #getForwarderChain()
	 */
	public void setForwarderChain(int i) {
		forwarderChain = i;
	}

	/**
	 * Sets the name to the specifed value. 
	 * @param i the new name value.
	 * @see #getName()
	 */
	public void setName(int i) {
		name = i;
	}

	/**
	 * Sets the first thunk to the specifed value. 
	 * @param i the new first thunk value.
	 * @see #getFirstThunk()
	 */
	public void setFirstThunk(int i) {
		firstThunk = i;
	}

	/**
	 * Checks to see if this descriptor is a null entry.  A null entry
	 * indicates that no more descriptors follow in the import table.
	 * 
	 * @return True if this descriptor is a null entry; otherwise, false.
	 */
	public boolean isNullEntry() {
		return characteristics == 0 && timeDateStamp == 0 && forwarderChain == 0 && name == 0 &&
			firstThunk == 0;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/ImportInfo.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

public class ImportInfo {
    private int address;
    private String comment;
    private String dll;
    private String name;
    private boolean isBound;

    ImportInfo(int address, String cmt, String dll, String name, boolean isBound) {
        this.address = address;
        this.comment = cmt;
        this.dll     = dll.toUpperCase();
        this.name    = name;
        this.isBound = isBound;
    }

	/**
	 * Returns the adjusted address where the import occurs.
	 * @return the adjusted address where the import occurs
	 */
    public int getAddress() {
        return address;
    }

	/**
	 * Returns a comment string containing extra information about the import.
	 * @return a comment string containing extra information about the import
	 */
    public String getComment() {
        return comment;
    }

	/**
	 * Returns the name of the imported DLL.
	 * @return the name of the imported DLL
	 */
    public String getDLL() {
        return dll;
    }

	/**
	 * Returns the name of the imported symbol.
	 * @return the name of the imported symbol
	 */
    public String getName() {
        return name;
    }

	/**
	 * Returns true if this is a bound import.
	 * @return true if this is a bound import
	 */
    public boolean isBound() {
        return isBound;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/InvalidNTHeaderException.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

/**
 * An exception class to handle encountering
 * invalid NT Headers.
 * 
 * @see net.jubjubnest.minidump.contrib.pe.NTHeader
 * 
 * 
 */
public class InvalidNTHeaderException extends Exception {
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/LoadConfigDataDirectory.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;

import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeConflictException;
import ghidra.program.model.data.ImageBaseOffset32DataType;
import ghidra.program.model.data.ImageBaseOffset64DataType;
import ghidra.program.model.listing.Program;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;
import net.jubjubnest.minidump.contrib.new_.ModuleBaseOffset32DataType;
import net.jubjubnest.minidump.contrib.new_.ModuleBaseOffset64DataType;

public class LoadConfigDataDirectory extends DataDirectory {
    private final static String NAME = "IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG";

    private LoadConfigDirectory lcd;

    static LoadConfigDataDirectory createLoadConfigDataDirectory(
            NTHeader ntHeader, FactoryBundledWithBinaryReader reader)
            throws IOException {
        LoadConfigDataDirectory loadConfigDataDirectory = (LoadConfigDataDirectory) reader.getFactory().create(LoadConfigDataDirectory.class);
        loadConfigDataDirectory.initLoadConfigDataDirectory(ntHeader, reader);
        return loadConfigDataDirectory;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public LoadConfigDataDirectory() {}

	private void initLoadConfigDataDirectory(NTHeader ntHeader, FactoryBundledWithBinaryReader reader) throws IOException {
		processDataDirectory(ntHeader, reader);
	}

	/**
	 * Returns the load config directory object defined in this data directory.
	 * @return the load config directory object
	 */
	public LoadConfigDirectory getLoadConfigDirectory() {
		return lcd;
	}

	@Override
	public String getDirectoryName() {
		return NAME;
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor,
			MessageLog log, NTHeader ntHeader) throws DuplicateNameException, CodeUnitInsertionException,
			DataTypeConflictException, IOException {

		monitor.setMessage(program.getName()+": load config directory...");
		Address addr = PeUtils.getMarkupAddress(program, isBinary, ntHeader, virtualAddress);
		if (!program.getMemory().contains(addr)) {
			return;
		}
		createDirectoryBookmark(program, addr);
		
		PeUtils.createData(program, addr, lcd.toDataType(), log);

		markupSeHandler(program, isBinary, monitor, log, ntHeader);
		ControlFlowGuard.markup(lcd, program, log, ntHeader);
	}

	private void markupSeHandler(Program program, boolean isBinary, TaskMonitor monitor,
			MessageLog log, NTHeader ntHeader) {
		long exceptionCount = lcd.getSeHandlerCount();
		long exceptionTable = lcd.getSeHandlerTable() - ntHeader.getOptionalHeader().getImageBase();
		if (exceptionCount > NTHeader.MAX_SANE_COUNT) {
			// a heuristic but...
			return;
		}

		Address addr = program.getAddressFactory().getDefaultAddressSpace().getAddress(
			va(exceptionTable, isBinary));
		setPlateComment(program, addr,
			"SEHandlerTable (0x" + Long.toHexString(exceptionCount) + " entries)");

		for (int i = 0; i < (int) exceptionCount; ++i) {
			if (monitor.isCancelled()) {
				return;
			}
			DataType dt;
			if (ntHeader.getLoadInfo().sharedProgram) {
				dt = ntHeader.getOptionalHeader().is64bit() ? new ModuleBaseOffset64DataType() : new ModuleBaseOffset32DataType();
			} else {
				dt = ntHeader.getOptionalHeader().is64bit() ? new ImageBaseOffset64DataType() : new ImageBaseOffset32DataType();
			}

			PeUtils.createData(program, addr, dt, log);

			addr = addr.add(dt.getLength());
		}
	}

	@Override
	public boolean parse() throws IOException {
		int ptr = getPointer();
		if (ptr < 0) {
			return false;
		}

        lcd = LoadConfigDirectory.createLoadConfigDirectory(reader, ptr, ntHeader.getOptionalHeader());
        return true;
    }

    /**
     * @see ghidra.app.util.bin.StructConverter#toDataType()
     */
    @Override
    public DataType toDataType() throws DuplicateNameException {
    	return lcd.toDataType();
    }
}



```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/LoadConfigDirectory.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.StructConverter;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.program.model.data.*;
import ghidra.util.Conv;
import ghidra.util.exception.DuplicateNameException;

/**
 * A class to represent the <code>IMAGE_LOAD_CONFIG_DIRECTORY</code>
 * data structure which is defined in <b><code>winnt.h</code></b>.
 */
public class LoadConfigDirectory implements StructConverter {
	public final static String NAME32 = "IMAGE_LOAD_CONFIG_DIRECTORY32";
	public final static String NAME64 = "IMAGE_LOAD_CONFIG_DIRECTORY64";

	private int size;
	private int timeDateStamp;
	private short majorVersion;
	private short minorVersion;
	private int globalFlagsClear;
	private int globalFlagsSet;
	private int criticalSectionDefaultTimeout;
	private long deCommitFreeBlockThreshold;
	private long deCommitTotalFreeThreshold;
	private long lockPrefixTable;
	private long maximumAllocationSize;
	private long virtualMemoryThreshold;
	private long processAffinityMask;
	private int processHeapFlags;
	private short csdVersion;
	private short dependentLoadFlags;
	private long editList;
	private long securityCookie;
	private long seHandlerTable;
	private long seHandlerCount;
	private long guardCfcCheckFunctionPointer;
	private long guardCfDispatchFunctionPointer;
	private long guardCfFunctionTable;
	private long guardCfFunctionCount;
	private GuardFlags guardFlags;
	private CodeIntegrity codeIntegrity;
	private long guardAddressTakenIatEntryTable;
	private long guardAddressTakenIatEntryCount;
	private long guardLongJumpTargetTable;
	private long guardLongJumpTargetCount;
	private long dynamicValueRelocTable;
	private long chpeMetadataPointer;
	private long guardRfFailureRoutine;
	private long guardRfFailureRoutineFunctionPointer;
	private int dynamicValueRelocTableOffset;
	private short dynamicValueRelocTableSection;
	private short reserved1;
	private long guardRfVerifyStackPointerFunctionPointer;
	private int hotPatchTableOffset;
	private int reserved2;
	private long reserved3;

	private boolean is64bit;

	static LoadConfigDirectory createLoadConfigDirectory(FactoryBundledWithBinaryReader reader,
			int index, OptionalHeader oh) throws IOException {
		LoadConfigDirectory loadConfigDirectory =
			(LoadConfigDirectory) reader.getFactory().create(LoadConfigDirectory.class);
		loadConfigDirectory.initLoadConfigDirectory(reader, index, oh);
		return loadConfigDirectory;
	}

	/**
	 * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
	 */
	public LoadConfigDirectory() {
	}

	private void initLoadConfigDirectory(FactoryBundledWithBinaryReader reader, int index,
			OptionalHeader oh) throws IOException {
		is64bit = oh.is64bit();

		long oldIndex = reader.getPointerIndex();
		reader.setPointerIndex(index);

		// Read original fields
		size = reader.readNextInt();
		timeDateStamp = reader.readNextInt();
		majorVersion = reader.readNextShort();
		minorVersion = reader.readNextShort();
		globalFlagsClear = reader.readNextInt();
		globalFlagsSet = reader.readNextInt();
		criticalSectionDefaultTimeout = reader.readNextInt();
		deCommitFreeBlockThreshold = readPointer(reader);
		deCommitTotalFreeThreshold = readPointer(reader);
		lockPrefixTable = readPointer(reader);
		maximumAllocationSize = readPointer(reader);
		virtualMemoryThreshold = readPointer(reader);
		if (is64bit) {
			processAffinityMask = readPointer(reader);
			processHeapFlags = reader.readNextInt();
		}
		else {
			processHeapFlags = reader.readNextInt();
			processAffinityMask = readPointer(reader);
		}
		csdVersion = reader.readNextShort();
		dependentLoadFlags = reader.readNextShort();
		editList = readPointer(reader);

		// If the structure size indicates there are more fields, we are dealing with
		// a newer version of the structure.  Each size check represents a new version
		// of the structure.
		if (reader.getPointerIndex() - index < size) {
			securityCookie = readPointer(reader);
			seHandlerTable = readPointer(reader);
			seHandlerCount = readPointer(reader);
		}
		if (reader.getPointerIndex() - index < size) {
			guardCfcCheckFunctionPointer = readPointer(reader);
			guardCfDispatchFunctionPointer = readPointer(reader);
			guardCfFunctionTable = readPointer(reader);
			guardCfFunctionCount = readPointer(reader);
			guardFlags = new GuardFlags(reader.readNextInt());
		}
		if (reader.getPointerIndex() - index < size) {
			codeIntegrity = new CodeIntegrity(reader);
		}
		if (reader.getPointerIndex() - index < size) {
			guardAddressTakenIatEntryTable = readPointer(reader);
			guardAddressTakenIatEntryCount = readPointer(reader);
			guardLongJumpTargetTable = readPointer(reader);
			guardLongJumpTargetCount = readPointer(reader);
		}
		if (reader.getPointerIndex() - index < size) {
			dynamicValueRelocTable = readPointer(reader);
			chpeMetadataPointer = readPointer(reader);
		}
		if (reader.getPointerIndex() - index < size) {
			guardRfFailureRoutine = readPointer(reader);
			guardRfFailureRoutineFunctionPointer = readPointer(reader);
			dynamicValueRelocTableOffset = reader.readNextInt();
			dynamicValueRelocTableSection = reader.readNextShort();
			reserved1 = reader.readNextShort();
		}
		if (reader.getPointerIndex() - index < size) {
			guardRfVerifyStackPointerFunctionPointer = readPointer(reader);
			hotPatchTableOffset = reader.readNextInt();
		}
		if (reader.getPointerIndex() - index < size) {
			reserved2 = reader.readNextInt();
			reserved3 = readPointer(reader);
		}

		reader.setPointerIndex(oldIndex);
	}

	/**
	 * Returns the size (in bytes) of this structure.
	 *
	 * @return the size (in bytes) of this structure
	 */
	public int getSize() {
		return size;
	}

	/**
	 * Returns the critical section default time-out value.
	 *
	 * @return the critical section default time-out value
	 */
	public int getCriticalSectionDefaultTimeout() {
		return criticalSectionDefaultTimeout;
	}

	/**
	 * Gets the safe exception handler table.
	 *
	 * @return the safe exception handler table.
	 */
	public long getSeHandlerTable() {
		return seHandlerTable;
	}

	/**
	 * Gets the safe exception handler table count.
	 *
	 * @return the safe exception handler table count.
	 */
	public long getSeHandlerCount() {
		return seHandlerCount;
	}

	/**
	 * Gets the ControlFlowGuard {@link GuardFlags}.
	 * 
	 * @return The ControlFlowGuard {@link GuardFlags}.
	 */
	public GuardFlags getCfgGuardFlags() {
		return guardFlags;
	}

	/**
	 * Gets the ControlFlowGuard check function pointer address.
	 * 
	 * @return The ControlFlowGuard check function pointer address.  
	 *   Could be 0 if ControlFlowGuard is not being used.
	 */
	public long getCfgCheckFunctionPointer() {
		return guardCfcCheckFunctionPointer;
	}

	/**
	 * Gets the ControlFlowGuard dispatch function pointer address.
	 * 
	 * @return The ControlFlowGuard dispatch function pointer address.  
	 *   Could be 0 if ControlFlowGuard is not being used.
	 */
	public long getCfgDispatchFunctionPointer() {
		return guardCfDispatchFunctionPointer;
	}

	/**
	 * Gets the ControlFlowGuard function table pointer address.
	 * 
	 * @return The ControlFlowGuard function table function pointer address.  
	 *   Could be 0 if ControlFlowGuard is not being used.
	 */
	public long getCfgFunctionTablePointer() {
		return guardCfFunctionTable;
	}

	/**
	 * Gets the ControlFlowGuard function count.
	 * 
	 * @return The ControlFlowGuard function count.  Could be 0 if ControlFlowGuard is 
	 *   not being used.
	 */
	public long getCfgFunctionCount() {
		return guardCfFunctionCount;
	}

	/**
	 * Gets the ReturnFlowGuard failure routine address.
	 * 
	 * @return The ReturnFlowGuard failure routine address.
	 *   Could be 0 if ReturnFlowGuard is not being used.
	 */
	public long getRfgFailureRoutine() {
		return guardRfFailureRoutine;
	}

	/**
	 * Gets the ReturnFlowGuard failure routine function pointer address.
	 * 
	 * @return The ReturnFlowGuard failure routine function pointer address.
	 *   Could be 0 if ReturnFlowGuard is not being used.
	 */
	public long getRfgFailureRoutineFunctionPointer() {
		return guardRfFailureRoutineFunctionPointer;
	}

	/**
	 * Gets the ReturnFlowGuard verify stack pointer function pointer address.
	 * 
	 * @return The ReturnFlowGuard verify stack pointer function pointer address.
	 *   Could be 0 if ReturnFlowGuard is not being used.
	 */
	public long getRfgVerifyStackPointerFunctionPointer() {
		return guardRfVerifyStackPointerFunctionPointer;
	}

	@Override
	public DataType toDataType() throws DuplicateNameException {
		StructureDataType struct = new StructureDataType(is64bit ? NAME64 : NAME32, 0);

		DataType counter = is64bit ? QWORD : DWORD;
		DataType ptr = is64bit ? new Pointer64DataType() : new Pointer32DataType();

		// Add original fields
		struct.add(DWORD, "Size", null);
		struct.add(DWORD, "TimeDateStamp", null);
		struct.add(WORD, "MajorVersion", null);
		struct.add(WORD, "MinorVersion", null);
		struct.add(DWORD, "GlobalFlagsClear", null);
		struct.add(DWORD, "GlobalFlagsSet", null);
		struct.add(DWORD, "CriticalSectionDefaultTimeout", null);
		struct.add(counter, "DeCommitFreeBlockThreshold", null);
		struct.add(counter, "DeCommitTotalFreeThreshold", null);
		struct.add(ptr, "LockPrefixTable", null);
		struct.add(counter, "MaximumAllocationSize", null);
		struct.add(counter, "VirtualMemoryThreshold", null);
		if (is64bit) {
			struct.add(counter, "ProcessAffinityMask", null);
			struct.add(DWORD, "ProcessHeapFlags", null);
		}
		else {
			struct.add(DWORD, "ProcessHeapFlags", null);
			struct.add(counter, "ProcessAffinityMask", null);
		}
		struct.add(WORD, "CsdVersion", null);
		struct.add(WORD, "DependentLoadFlags", null);
		struct.add(ptr, "EditList", null);

		// If the structure size indicates there are more fields, we are dealing with
		// a newer version of the structure.  Each size check represents a new version
		// of the structure.
		if (struct.getLength() < size) {
			struct.add(ptr, "SecurityCookie", null);
			struct.add(ptr, "SEHandlerTable", null);
			struct.add(counter, "SEHandlerCount", null);
		}
		if (struct.getLength() < size) {
			struct.add(ptr, "GuardCFCCheckFunctionPointer", null);
			struct.add(ptr, "GuardCFDispatchFunctionPointer", null);
			struct.add(ptr, "GuardCFFunctionTable", null);
			struct.add(counter, "GuardCFFunctionCount", null);
			struct.add(guardFlags.toDataType(), "GuardFlags", null);
		}
		if (struct.getLength() < size) {
			struct.add(codeIntegrity.toDataType(), "CodeIntegrity", null);
		}
		if (struct.getLength() < size) {
			struct.add(ptr, "GuardAddressTakenIatEntryTable", null);
			struct.add(counter, "GuardAddressTakenIatEntryCount", null);
			struct.add(ptr, "GuardLongJumpTargetTable", null);
			struct.add(counter, "GuardLongJumpTargetCount", null);
		}
		if (struct.getLength() < size) {
			struct.add(ptr, "DynamicValueRelocTable", null);
			struct.add(ptr, "CHPEMetadataPointer", null);
		}
		if (struct.getLength() < size) {
			struct.add(ptr, "GuardRFFailureRoutine", null);
			struct.add(ptr, "GuardRFFailureRoutineFunctionPointer", null);
			struct.add(DWORD, "DynamicValueRelocTableOffset", null);
			struct.add(WORD, "DynamicValueRelocTableSection", null);
			struct.add(WORD, "Reserved1", null);
		}
		if (struct.getLength() < size) {
			struct.add(ptr, "GuardRFVerifyStackPointerFunctionPointer", null);
			struct.add(DWORD, "HotPatchTableOffset", null);
		}
		if (struct.getLength() < size) {
			struct.add(DWORD, "Reserved2", null);
			struct.add(counter, "Reserved3", null);
		}

		struct.setCategoryPath(new CategoryPath("/PE"));
		return struct;
	}

	private long readPointer(BinaryReader reader) throws IOException {
		if (is64bit) {
			return reader.readNextLong();
		}
		return reader.readNextInt() & Conv.INT_MASK;
	}

	/**
	 * Control Flow Guard flags.
	 */
	static class GuardFlags implements StructConverter {

		public final static String NAME = "IMAGE_GUARD_FLAGS";

		private int flags;

		public GuardFlags(int flags) {
			this.flags = flags;
		}

		public int getFlags() {
			return flags;
		}

		@Override
		public DataType toDataType() throws DuplicateNameException {
			EnumDataType enumDt = new EnumDataType(NAME, 4);
			enumDt.add("IMAGE_GUARD_CF_INSTRUMENTED", 0x00000100L);
			enumDt.add("IMAGE_GUARD_CFW_INSTRUMENTED", 0x00000200L);
			enumDt.add("IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT", 0x00000400L);
			enumDt.add("IMAGE_GUARD_SECURITY_COOKIE_UNUSED", 0x00000800L);
			enumDt.add("IMAGE_GUARD_PROTECT_DELAYLOAD_IAT", 0x00001000L);
			enumDt.add("IMAGE_GUARD_DELAYLOAD_IAT_IN_ITS_OWN_SECTION", 0x00002000L);
			enumDt.add("IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT", 0x00004000L);
			enumDt.add("IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION", 0x00008000L);
			enumDt.add("IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT", 0x00010000L);
			enumDt.add("IMAGE_GUARD_RF_INSTRUMENTED", 0x00020000L);
			enumDt.add("IMAGE_GUARD_RF_ENABLE", 0x00040000L);
			enumDt.add("IMAGE_GUARD_RF_STRICT", 0x00080000L);
			enumDt.add("IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK_1", 0x10000000L);
			enumDt.add("IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK_2", 0x20000000L);
			enumDt.add("IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK_4", 0x40000000L);
			enumDt.add("IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK_8", 0x80000000L);

			enumDt.setCategoryPath(new CategoryPath("/PE"));
			return enumDt;
		}
	}

	/**
	 * Not sure yet what this is used for.
	 */
	static class CodeIntegrity implements StructConverter {

		public final static String NAME = "IMAGE_LOAD_CONFIG_CODE_INTEGRITY";

		private short flags;
		private short catalog;
		private int catalogOffset;
		private int reserved;

		public CodeIntegrity(BinaryReader reader) throws IOException {
			flags = reader.readNextShort();
			catalog = reader.readNextShort();
			catalogOffset = reader.readNextInt();
			reserved = reader.readNextInt();
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder();
			sb.append("flags=0x" + Integer.toHexString(Conv.shortToInt(flags)));
			sb.append(", catalog=0x" + Integer.toHexString(Conv.shortToInt(catalog)));
			sb.append(", catalogOffset=0x" + Integer.toHexString(catalogOffset));
			sb.append(", reserved=0x" + Integer.toHexString(reserved));
			return sb.toString();
		}

		@Override
		public DataType toDataType() throws DuplicateNameException {
			StructureDataType struct = new StructureDataType(NAME, 0);
			struct.add(WORD, "Flags", null);
			struct.add(WORD, "Catalog", null);
			struct.add(DWORD, "CatalogOffset", null);
			struct.add(DWORD, "Reserved", null);

			struct.setCategoryPath(new CategoryPath("/PE"));
			return struct;
		}
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/MachineConstants.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

/**
 * PE machine ID constants defined by standard header file 'ntimage.h'
 * 
 * @see <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/mt804345%28v=vs.85%29.aspx">Image File Machine Constants</a>
 */
public class MachineConstants {

	public final static short IMAGE_FILE_MACHINE_UNKNOWN           =         0x0000;
	public final static short IMAGE_FILE_MACHINE_I386              =         0x014c;// Intel 386.
	public final static short IMAGE_FILE_MACHINE_R3000             =         0x0162;// MIPS little-endian, 0x160 big-endian
	public final static short IMAGE_FILE_MACHINE_R4000             =         0x0166;// MIPS little-endian
	public final static short IMAGE_FILE_MACHINE_R10000            =         0x0168;// MIPS little-endian
	public final static short IMAGE_FILE_MACHINE_WCEMIPSV2         =         0x0169;// MIPS little-endian WCE v2
	public final static short IMAGE_FILE_MACHINE_ALPHA             =         0x0184;// Alpha_AXP
	public final static short IMAGE_FILE_MACHINE_SH3               =         0x01a2;// SH3 little-endian
	public final static short IMAGE_FILE_MACHINE_SH3DSP            =         0x01a3;
	public final static short IMAGE_FILE_MACHINE_SH3E              =         0x01a4;// SH3E little-endian
	public final static short IMAGE_FILE_MACHINE_SH4               =         0x01a6;// SH4 little-endian
	public final static short IMAGE_FILE_MACHINE_SH5               =         0x01a8;// SH5
	public final static short IMAGE_FILE_MACHINE_ARM               =         0x01c0;// ARM Little-Endian
	public final static short IMAGE_FILE_MACHINE_THUMB             =         0x01c2;// ARM Thumb/Thumb-2 Little-Endian
	public final static short IMAGE_FILE_MACHINE_ARMNT             =         0x01c4;// ARM Thumb-2 Little-Endian
	public final static short IMAGE_FILE_MACHINE_AM33              =         0x01d3;
	public final static short IMAGE_FILE_MACHINE_POWERPC           =         0x01F0;// PowerPC Little-Endian
	public final static short IMAGE_FILE_MACHINE_POWERPCFP         =         0x01f1;// PowerPC w/ Floating Point Support 
	public final static short IMAGE_FILE_MACHINE_IA64              =         0x0200;// Intel 64
	public final static short IMAGE_FILE_MACHINE_MIPS16            =         0x0266;// MIPS
	public final static short IMAGE_FILE_MACHINE_ALPHA64           =         0x0284;// ALPHA64
	public final static short IMAGE_FILE_MACHINE_MIPSFPU           =         0x0366;// MIPS
	public final static short IMAGE_FILE_MACHINE_MIPSFPU16         =         0x0466;// MIPS
	public final static short IMAGE_FILE_MACHINE_TRICORE           =         0x0520;// Infineon
	public final static short IMAGE_FILE_MACHINE_CEF               =         0x0CEF;
	public final static short IMAGE_FILE_MACHINE_EBC               =         0x0EBC;// EFI Byte Code

	public final static short IMAGE_FILE_MACHINE_AMD64             = (short) 0x8664;// AMD64 (K8)
	public final static short IMAGE_FILE_MACHINE_M32R              = (short) 0x9041;// M32R little-endian
	public final static short IMAGE_FILE_MACHINE_ARM64             = (short) 0xaa64;// ARM v8 64-bit;
	public final static short IMAGE_FILE_MACHINE_CEE               = (short) 0xC0EE;

	public final static short IMAGE_FILE_MACHINE_AXP64             =         IMAGE_FILE_MACHINE_ALPHA64;
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/MachineName.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import ghidra.util.Conv;

/**
 * 
 */
class MachineName {

	static String getName(short machine) {
		return getName(machine & Conv.SHORT_MASK);
	}

	static String getName(int machine) {
		return new String("" + machine);
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/NTHeader.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;
import java.io.RandomAccessFile;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.StructConverter;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;
import net.jubjubnest.minidump.contrib.pe.PortableExecutable.SectionLayout;
import ghidra.program.model.data.*;
import ghidra.util.*;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.exception.NotYetImplementedException;
import ghidra.util.task.TaskMonitorAdapter;

/**
 * A class to represent the <b><code>IMAGE_NT_HEADERS32</code></b> and
 * IMAGE_NT_HEADERS64 structs as defined in 
 * <code>winnt.h</code>.
 * <pre>
 * typedef struct _IMAGE_NT_HEADERS {
 *    DWORD Signature;
 *    IMAGE_FILE_HEADER FileHeader;
 *    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
 * };
 * </pre>
 * 
 * 
 */
public class NTHeader implements StructConverter, OffsetValidator {
	/**
	 * The size of the NT header signature.
	 */
	public final static int SIZEOF_SIGNATURE = BinaryReader.SIZEOF_INT;
	public final static int MAX_SANE_COUNT = 0x10000;

	private int signature;
	private FileHeader fileHeader;
	private OptionalHeader optionalHeader;
	private FactoryBundledWithBinaryReader reader;
	private int index;
	private boolean advancedProcess = true;
	private boolean parseCliHeaders = false;

	private ImageLoadInfo loadInfo;

	/**
	 * Constructs a new NT header.
	 * @param reader the binary reader
	 * @param index the index into the reader to the start of the NT header
	 * @param advancedProcess if true, information rafside of the base header will be processed
	 * @param parseCliHeaders if true, CLI headers are parsed (if present)
	 * @throws InvalidNTHeaderException if the bytes the specified index
	 * do not constitute an accurate NT header.
	 */
	public static NTHeader createNTHeader(FactoryBundledWithBinaryReader reader, int index,
			ImageLoadInfo loadInfo, boolean advancedProcess, boolean parseCliHeaders)
			throws InvalidNTHeaderException, IOException {
		NTHeader ntHeader = (NTHeader) reader.getFactory().create(NTHeader.class);
		ntHeader.initNTHeader(reader, index, loadInfo, advancedProcess, parseCliHeaders);
		return ntHeader;
	}

	/**
	 * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
	 */
	public NTHeader() {
	}

	private void initNTHeader(FactoryBundledWithBinaryReader reader, int index, ImageLoadInfo loadInfo,
			boolean advancedProcess, boolean parseCliHeaders)
			throws InvalidNTHeaderException, IOException {
		this.reader = reader;
		this.index = index;
		this.loadInfo = loadInfo;
		this.advancedProcess = advancedProcess;
		this.parseCliHeaders = parseCliHeaders;

		parse();
	}

	/**
	 * Returns the name to use when converting into a structure data type.
	 * @return the name to use when converting into a structure data type
	 */
	public String getName() {
		return "IMAGE_NT_HEADERS" + (optionalHeader.is64bit() ? "64" : "32");
	}

	public boolean isRVAResoltionSectionAligned() {
		return loadInfo.sectionLayout == SectionLayout.MEMORY;
	}

	/**
	 * Returns the file header.
	 * @return the file header
	 */
	public FileHeader getFileHeader() {
		return fileHeader;
	}

	/**
	 * Returns the optional header.
	 * @return the optional header
	 */
	public OptionalHeader getOptionalHeader() {
		return optionalHeader;
	}

	/**
	 * @see ghidra.app.util.bin.StructConverter#toDataType()
	 */
	@Override
	public DataType toDataType() throws DuplicateNameException, IOException {
		StructureDataType struct = new StructureDataType(getName(), 0);

		struct.add(new ArrayDataType(ASCII, 4, 1), "Signature", null);
		struct.add(fileHeader.toDataType(), "FileHeader", null);
		struct.add(optionalHeader.toDataType(), "OptionalHeader", null);

		struct.setCategoryPath(new CategoryPath("/PE"));

		return struct;
	}

	/**
	 * Converts a relative virtual address (RVA) into a pointer.
	 * @see #rvaToPointer(long)
	 */
	public int rvaToPointer(int rva) {
		return (int) rvaToPointer(rva & Conv.INT_MASK);
	}

	/**
	 * @param rva the relative virtual address
	 * @return the pointer into binary image, 0 if not valid
	 */
	public long rvaToPointer(long rva) {
		SectionHeader[] sections = fileHeader.getSectionHeaders();
		for (SectionHeader section : sections) {
			long sectionVA = section.getVirtualAddress() & Conv.INT_MASK;
			long rawSize = section.getSizeOfRawData() & Conv.INT_MASK;
			long rawPtr = section.getPointerToRawData() & Conv.INT_MASK;

			switch (loadInfo.sectionLayout) {
				case MEMORY:
					return rva;
				case FILE:
				default:
					if (rva >= sectionVA && rva < sectionVA + rawSize) {
						return rva + rawPtr - sectionVA;
					}
					break;
			}
		}
		//
		//low alignment mode?
		//
		if (optionalHeader != null) {
			if (optionalHeader.getFileAlignment() == optionalHeader.getSectionAlignment()
					&& optionalHeader.getSectionAlignment() < 800
					&& optionalHeader.getFileAlignment() > 1) {
				return rva;
			}
		}
		return -1;
	}
	
	/**
	 * Gets the load info used to load the file containing this header.
	 * @return the load info
	 */
	public ImageLoadInfo getLoadInfo() {
		return loadInfo;
	}

	@Override
	public boolean checkPointer(long ptr) {
		SectionHeader[] sections = fileHeader.getSectionHeaders();
		for (SectionHeader section : sections) {
			long virtPtr = section.getVirtualAddress() & Conv.INT_MASK;
			long virtSize = section.getVirtualSize() & Conv.INT_MASK;
			long rawSize = section.getSizeOfRawData() & Conv.INT_MASK;
			long rawPtr = section.getPointerToRawData() & Conv.INT_MASK;

			long sectionBasePtr = loadInfo.sectionLayout == SectionLayout.MEMORY ? virtPtr : rawPtr;
			long sectionSize = loadInfo.sectionLayout == SectionLayout.MEMORY ? virtSize : rawSize;

			if (ptr >= sectionBasePtr && ptr <= sectionBasePtr + sectionSize) { // <= allows data after the last section, which is OK
				return true;
			}
		}
		if (optionalHeader != null) {
			if (optionalHeader.getFileAlignment() == optionalHeader.getSectionAlignment()) {
				return checkRVA(ptr);
			}
		}
		return false;
	}

	@Override
	public boolean checkRVA(long rva) {
		if (optionalHeader != null) {
			return (0 <= rva) && (rva <= optionalHeader.getSizeOfImage());
		}
		return true;
	}

	/**
	 * Converts a virtual address (VA) into a pointer.
	 * @see #vaToPointer(long)
	 */
	public int vaToPointer(int va) {
		return (int) vaToPointer(va & Conv.INT_MASK);
	}

	/**
	 * @param va the virtual address
	 * @return the pointer into binary image, 0 if not valid
	 */
	public long vaToPointer(long va) {
		return rvaToPointer(va - getOptionalHeader().getImageBase());
	}

	/**
	 * @throws InvalidNTHeaderException
	 * @throws IOException
	 */
	private void parse() throws InvalidNTHeaderException, IOException {

		if (index < 0 || index > reader.length()) {
			return;
		}

		int tmpIndex = index;

		try {
			signature = reader.readInt(tmpIndex);
		}
		catch (IndexOutOfBoundsException ioobe) {
		}

		// if not correct signature, then return...
		if (signature != Constants.IMAGE_NT_SIGNATURE) {
			throw new InvalidNTHeaderException();
		}

		tmpIndex += 4;

		fileHeader = FileHeader.createFileHeader(reader, tmpIndex, this);
		if (fileHeader.getSizeOfOptionalHeader() == 0) {
			Msg.warn(this, "Section headers overlap optional header");
		}
		tmpIndex += FileHeader.IMAGE_SIZEOF_FILE_HEADER;

		try {
			optionalHeader = OptionalHeaderImpl.createOptionalHeader(this, reader, tmpIndex);
		}
		catch (NotYetImplementedException e) {//TODO
			Msg.error(this, "Unexpected Exception: " + e.getMessage());
			return;
		}

		fileHeader.processSections(optionalHeader);
		fileHeader.processSymbols();

		if (advancedProcess) {
			optionalHeader.processDataDirectories(TaskMonitorAdapter.DUMMY_MONITOR, loadInfo);
		}
	}

	void writeHeader(RandomAccessFile raf, DataConverter dc) throws IOException {

		raf.seek( index );

		raf.write(dc.getBytes(signature));

		fileHeader.writeHeader(raf, dc);

		optionalHeader.writeHeader(raf, dc);

		SectionHeader[] sections = fileHeader.getSectionHeaders();
		for (SectionHeader section : sections) {
			section.writeHeader(raf, dc);
		}
	}

	boolean shouldParseCliHeaders() {
		return parseCliHeaders;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/OffsetValidator.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

public interface OffsetValidator {

	public boolean checkPointer(long ptr);

	public boolean checkRVA(long rva);

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/OptionalHeader.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;
import java.io.RandomAccessFile;

import ghidra.app.util.bin.StructConverter;
import ghidra.program.model.listing.Program;
import ghidra.util.DataConverter;
import ghidra.util.task.TaskMonitor;
import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;

public interface OptionalHeader extends StructConverter {
	/**
	 * The count of data directories in the optional header.
	 */
	public final static byte IMAGE_NUMBEROF_DIRECTORY_ENTRIES = 16;

	/**
	 * Export directory index
	 */
	public final static byte IMAGE_DIRECTORY_ENTRY_EXPORT = 0;
	/**
	 * Import directory index
	 */
	public final static byte IMAGE_DIRECTORY_ENTRY_IMPORT = 1;
	/**
	 * Resource directory index
	 */
	public final static byte IMAGE_DIRECTORY_ENTRY_RESOURCE = 2;
	/**
	 * Exception directory index
	 */
	public final static byte IMAGE_DIRECTORY_ENTRY_EXCEPTION = 3;
	/**
	 * Security directory index
	 */
	public final static byte IMAGE_DIRECTORY_ENTRY_SECURITY = 4;
	/**
	 * Base Relocation Table directory index
	 */
	public final static byte IMAGE_DIRECTORY_ENTRY_BASERELOC = 5;
	/**
	 * Debug directory index
	 */
	public final static byte IMAGE_DIRECTORY_ENTRY_DEBUG = 6;
	/**
	 * Architecture Specific Data directory index
	 */
	public final static byte IMAGE_DIRECTORY_ENTRY_ARCHITECTURE = 7;
	/**
	 * Global Pointer directory index
	 */
	public final static byte IMAGE_DIRECTORY_ENTRY_GLOBALPTR = 8;//RVA of GP
	/**
	 * TLS directory index
	 */
	public final static byte IMAGE_DIRECTORY_ENTRY_TLS = 9;
	/**
	 * Load Configuration directory index
	 */
	public final static byte IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG = 10;
	/**
	 * Bound Import directory  index
	 */
	public final static byte IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT = 11;
	/**
	 * Import Address Table directory index
	 */
	public final static byte IMAGE_DIRECTORY_ENTRY_IAT = 12;
	/**
	 * Delay Load Import Descriptors directory index
	 */
	public final static byte IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT = 13;
	/**
	 * COM Runtime Descriptor directory index
	 */
	public final static byte IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR = 14;
	/**
	 * New name for the COM Descriptor directory index
	 */
	public final static byte IMAGE_DIRECTORY_ENTRY_COMHEADER = 14;

	/**
	 * Returns true of this optional header is 64-bit.
	 * @return true of this optional header is 64-bit
	 */
	public boolean is64bit();

	/**
	 * Return the major version number of the linker that built this binary.
	 * @return
	 */
	public byte getMajorLinkerVersion();

	/**
	 * Return the minor version number of the linker that built this binary.
	 * @return
	 */
	public byte getMinorLinkerVersion();

	/**
	 * Return the major version number of the required operating system.
	 * @return
	 */
	public short getMajorOperatingSystemVersion();

	/**
	 * Return the minor version number of the required operating system.
	 * @return
	 */
	public short getMinorOperatingSystemVersion();

	/**
	 * Get the major version number of the image.
	 * @return
	 */
	public short getMajorImageVersion();

	/**
	 * Get the minor version number of the image.
	 * @return
	 */
	public short getMinorImageVersion();

	/**
	 * Get the major version number of the subsystem.
	 */
	public short getMajorSubsystemVersion();

	/**
	 * Get the minor version number of the subsystem.
	 * @return
	 */
	public short getMinorSubsystemVersion();

	/**
	 * This value is reserved, and must be 0
	 */
	public int getWin32VersionValue();

	/**
	 * Get the image file checksum.
	 * @return
	 */
	public int getChecksum();

	/**
	* Get the subsystem that is required to run this image.
	* @return
	*/
	public int getSubsystem();

	/**
	 * Return flags that describe properties of and features of this binary.
	 * @see net.jubjubnest.minidump.contrib.pe.DllCharacteristics
	 * @return
	 */
	public short getDllCharacteristics();

	/**
	 * Return the size of the stack reservation
	 * @return
	 */
	public long getSizeOfStackReserve();

	/**
	 * Return the size of the stack to commit
	 * @return
	 */
	public long getSizeOfStackCommit();

	/**
	 * Return the size of the heap reservation
	 * @return
	 */
	public long getSizeOfHeapReserve();

	/**
	 * Return the size of the heap to commit
	 * @return
	 */
	public long getSizeOfHeapCommit();

	/**
	 * Return the flags passed to the loader. Obsolete.
	 * @return
	 */
	public int getLoaderFlags();

	/**
	 * @return the RVA of the first code byte in the file that will be executed
	 */
	public long getAddressOfEntryPoint();

	/**
	 * @return the preferred load address of this file in memory
	 */
	public long getImageBase();

	public long getOriginalImageBase();

	public boolean wasRebased();

	/**
	 * @return the RVA that would be assigned to the next section following the last section
	 */
	public long getSizeOfImage();

	/**
	 * @see #getSizeOfImage()
	 */
	public void setSizeOfImage(long size);

	/**
	 * @return the combined size of all headers
	 */
	public long getSizeOfHeaders();

	/**
	 * @see #getSizeOfHeaders()
	 */
	public void setSizeOfHeaders(long size);

	/**
	 * Returns the combined total size of all sections with
	 * the <code>IMAGE_SCN_CNT_CODE</code> attribute.
	 * @return the combined total size of all sections with
	 * the <code>IMAGE_SCN_CNT_CODE</code> attribute.
	 */
	public long getSizeOfCode();

	/**
	 * @see #getSizeOfCode()
	 */
	public void setSizeOfCode(long size);

	public long getNumberOfRvaAndSizes();

	/**
	 * Returns the combined size of all initialized data sections.
	 * @return the combined size of all initialized data sections
	 */
	public long getSizeOfInitializedData();

	/**
	 * @see #getSizeOfInitializedData()
	 */
	public void setSizeOfInitializedData(long size);

	/**
	 * Returns the size of all sections with the uninitialized 
	 * data attributes.
	 * @return the size of all sections with the uninitialized data attributes
	 */
	public long getSizeOfUninitializedData();

	/**
	 * @see #getSizeOfUninitializedData()
	 */
	public void setSizeOfUninitializedData(long size);

	/**
	 * Returns the RVA of the first byte of code when loaded in memory.
	 * @return the RVA of the first byte of code when loaded in memory
	 */
	public long getBaseOfCode();

	/**
	 * @return the RVA of the first byte of data when loaded into memory
	 */
	public long getBaseOfData();

	/**
	 * This methods tells this optional header to process its data directories.
	 */
	public void processDataDirectories(TaskMonitor monitor, ImageLoadInfo loadInfo) throws IOException;

	/**
	 * Returns the array of data directories.
	 * @return the array of data directories
	 */
	public DataDirectory[] getDataDirectories();

	/**
	 * @return the section alignment
	 */
	public int getSectionAlignment();

	/**
	 * @return the file alignment
	 */
	public int getFileAlignment();

	/**
	 * Writes this optional header to the specified random access file.
	 * 
	 * @param raf the random access file
	 * @param dc  the data converter
	 * 
	 * @throws IOException
	 */
	public void writeHeader(RandomAccessFile raf, DataConverter dc) throws IOException;

	public void validateDataDirectories(Program program, ImageLoadInfo loadInfo);

	/**
	 * @return true if the PE uses predominantly CLI code; otherwise, false.
	 */
	public boolean isCLI() throws IOException;
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/OptionalHeaderImpl.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;
import java.io.RandomAccessFile;

import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;
import net.jubjubnest.minidump.contrib.new_.ModuleBaseOffset32DataType;
import net.jubjubnest.minidump.contrib.pe.ImageCor20Header.ImageCor20Flags;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressOutOfBoundsException;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.Memory;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.util.*;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.exception.NotYetImplementedException;
import ghidra.util.task.TaskMonitor;

/**
 * <pre>
 * typedef struct _IMAGE_OPTIONAL_HEADER {
 *     WORD    Magic;									// MANDATORY
 *     BYTE    MajorLinkerVersion;
 *     BYTE    MinorLinkerVersion;
 *     DWORD   SizeOfCode;
 *     DWORD   SizeOfInitializedData;
 *     DWORD   SizeOfUninitializedData;
 *     DWORD   AddressOfEntryPoint;						// MANDATORY
 *     DWORD   BaseOfCode;
 *     DWORD   BaseOfData;
 *     DWORD   ImageBase;								// MANDATORY
 *     DWORD   SectionAlignment;						// MANDATORY
 *     DWORD   FileAlignment;							// MANDATORY
 *     WORD    MajorOperatingSystemVersion;				// MANDATORY
 *     WORD    MinorOperatingSystemVersion;
 *     WORD    MajorImageVersion;
 *     WORD    MinorImageVersion;
 *     WORD    MajorSubsystemVersion;
 *     WORD    MinorSubsystemVersion;
 *     DWORD   Win32VersionValue;
 *     DWORD   SizeOfImage;								// MANDATORY
 *     DWORD   SizeOfHeaders;							// MANDATORY
 *     DWORD   CheckSum;
 *     WORD    Subsystem;								// MANDATORY
 *     WORD    DllCharacteristics;
 *     DWORD   SizeOfStackReserve;
 *     DWORD   SizeOfStackCommit;
 *     DWORD   SizeOfHeapReserve;
 *     DWORD   SizeOfHeapCommit;
 *     DWORD   LoaderFlags;
 *     DWORD   NumberOfRvaAndSizes;						// USED
 *     IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
 * };
 * </pre>
 * 
 * <pre>
 * typedef struct _IMAGE_OPTIONAL_HEADER64 {
 *     WORD        Magic;
 *     BYTE        MajorLinkerVersion;
 *     BYTE        MinorLinkerVersion;
 *     DWORD       SizeOfCode;
 *     DWORD       SizeOfInitializedData;
 *     DWORD       SizeOfUninitializedData;
 *     DWORD       AddressOfEntryPoint;
 *     DWORD       BaseOfCode;
 *     ULONGLONG   ImageBase;
 *     DWORD       SectionAlignment;
 *     DWORD       FileAlignment;
 *     WORD        MajorOperatingSystemVersion;
 *     WORD        MinorOperatingSystemVersion;
 *     WORD        MajorImageVersion;
 *     WORD        MinorImageVersion;
 *     WORD        MajorSubsystemVersion;
 *     WORD        MinorSubsystemVersion;
 *     DWORD       Win32VersionValue;
 *     DWORD       SizeOfImage;
 *     DWORD       SizeOfHeaders;
 *     DWORD       CheckSum;
 *     WORD        Subsystem;
 *     WORD        DllCharacteristics;
 *     ULONGLONG   SizeOfStackReserve;
 *     ULONGLONG   SizeOfStackCommit;
 *     ULONGLONG   SizeOfHeapReserve;
 *     ULONGLONG   SizeOfHeapCommit;
 *     DWORD       LoaderFlags;
 *     DWORD       NumberOfRvaAndSizes;
 *     IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
 * };
 * </pre>
 * 
 * 
 */
public class OptionalHeaderImpl implements OptionalHeader {
	protected short magic;
	protected byte majorLinkerVersion;
	protected byte minorLinkerVersion;
	protected int sizeOfCode;
	protected int sizeOfInitializedData;
	protected int sizeOfUninitializedData;
	protected int addressOfEntryPoint;
	protected int baseOfCode;
	protected int baseOfData;
	protected long imageBase;
	protected int sectionAlignment;
	protected int fileAlignment;
	protected short majorOperatingSystemVersion;
	protected short minorOperatingSystemVersion;
	protected short majorImageVersion;
	protected short minorImageVersion;
	protected short majorSubsystemVersion;
	protected short minorSubsystemVersion;
	protected int win32VersionValue;
	protected int sizeOfImage;
	protected int sizeOfHeaders;
	protected int checkSum;
	protected short subsystem;
	protected short dllCharacteristics;
	protected long sizeOfStackReserve;
	protected long sizeOfStackCommit;
	protected long sizeOfHeapReserve;
	protected long sizeOfHeapCommit;
	protected int loaderFlags;
	protected int numberOfRvaAndSizes;
	protected DataDirectory[] dataDirectory;

	protected NTHeader ntHeader;
	protected FactoryBundledWithBinaryReader reader;
	protected int startIndex;
	private long startOfDataDirs;

	protected long originalImageBase;
	protected boolean wasRebased;

	static OptionalHeader createOptionalHeader(NTHeader ntHeader,
			FactoryBundledWithBinaryReader reader, int startIndex) throws IOException {
		OptionalHeaderImpl optionalHeaderImpl =
			(OptionalHeaderImpl) reader.getFactory().create(OptionalHeaderImpl.class);
		optionalHeaderImpl.initOptionalHeaderImpl(ntHeader, reader, startIndex);
		return optionalHeaderImpl;
	}

	/**
	 * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
	 */
	public OptionalHeaderImpl() {
	}

	private void initOptionalHeaderImpl(NTHeader ntHeader, FactoryBundledWithBinaryReader reader,
			int startIndex) throws IOException {
		this.ntHeader = ntHeader;
		this.reader = reader;
		this.startIndex = startIndex;

		parse();
	}

	private String getName() {
		return "IMAGE_OPTIONAL_HEADER" + (is64bit() ? "64" : "32");
	}

	@Override
	public boolean is64bit() {
		switch (magic) {
			case Constants.IMAGE_NT_OPTIONAL_HDR32_MAGIC:
				return false;

			case Constants.IMAGE_NT_OPTIONAL_HDR64_MAGIC:
				return true;
		}
		int characteristics = ntHeader.getFileHeader().getCharacteristics();
		if ((characteristics & FileHeader.IMAGE_FILE_DLL) == FileHeader.IMAGE_FILE_DLL &&
			(characteristics & FileHeader.IMAGE_FILE_EXECUTABLE_IMAGE) == 0) {
			Msg.warn(this, "Invalid magic " + magic + " but potentially data-only DLL");
			return false;
		}
		throw new NotYetImplementedException(
			"Optional header of type [" + Integer.toHexString(magic) + "] is not supported");
	}

	@Override
	public long getImageBase() {
		return imageBase;
	}

	@Override
	public long getOriginalImageBase() {
		return originalImageBase;
	}

	@Override
	public long getAddressOfEntryPoint() {
		return Conv.intToLong(addressOfEntryPoint);
	}

	@Override
	public long getSizeOfCode() {
		return sizeOfCode;
	}

	@Override
	public void setSizeOfCode(long size) {
		this.sizeOfCode = (int) size;
	}

	@Override
	public long getSizeOfInitializedData() {
		return Conv.intToLong(sizeOfInitializedData);
	}

	@Override
	public void setSizeOfInitializedData(long size) {
		this.sizeOfInitializedData = (int) size;
	}

	@Override
	public long getSizeOfUninitializedData() {
		return Conv.intToLong(sizeOfUninitializedData);
	}

	@Override
	public void setSizeOfUninitializedData(long size) {
		this.sizeOfUninitializedData = (int) size;
	}

	@Override
	public long getBaseOfCode() {
		return Conv.intToLong(baseOfCode);
	}

	@Override
	public long getBaseOfData() {
		return Conv.intToLong(baseOfData);
	}

	@Override
	public long getSizeOfImage() {
		return Conv.intToLong(sizeOfImage);
	}

	@Override
	public void setSizeOfImage(long size) {
		this.sizeOfImage = (int) size;
	}

	@Override
	public long getSizeOfHeaders() {
		return Conv.intToLong(sizeOfHeaders);
	}

	@Override
	public void setSizeOfHeaders(long size) {
		this.sizeOfHeaders = (int) size;
	}

	@Override
	public long getNumberOfRvaAndSizes() {
		return Conv.intToLong(numberOfRvaAndSizes);
	}

	@Override
	public short getMajorOperatingSystemVersion() {
		return majorOperatingSystemVersion;
	}

	@Override
	public short getMinorOperatingSystemVersion() {
		return minorOperatingSystemVersion;
	}

	@Override
	public void processDataDirectories(TaskMonitor monitor, ImageLoadInfo loadInfo) throws IOException {
		monitor.setMessage("Parsing exports...");

		dataDirectory = new DataDirectory[numberOfRvaAndSizes];
		int ndata = 0;

		try {
			dataDirectory[ndata] = ExportDataDirectory.createExportDataDirectory(ntHeader, reader);
		}
		catch (RuntimeException re) {
			if (PortableExecutable.DEBUG) {
				throw re;
			}
		}
		if (++ndata == numberOfRvaAndSizes) {
			return;
		}

		monitor.setMessage("Parsing imports...");
		try {
			dataDirectory[ndata] = ImportDataDirectory.createImportDataDirectory(ntHeader, reader);
		}
		catch (RuntimeException re) {
			if (PortableExecutable.DEBUG) {
				throw re;
			}
		}
		if (++ndata == numberOfRvaAndSizes) {
			return;
		}

		monitor.setMessage("Parsing resources...");
		try {
			dataDirectory[ndata] =
				ResourceDataDirectory.createResourceDataDirectory(ntHeader, reader);
		}
		catch (RuntimeException re) {
			if (PortableExecutable.DEBUG) {
				throw re;
			}
		}
		if (++ndata == numberOfRvaAndSizes) {
			return;
		}

		monitor.setMessage("Parsing exceptions...");
		try {
			dataDirectory[ndata] =
				ExceptionDataDirectory.createExceptionDataDirectory(ntHeader, reader);
		}
		catch (RuntimeException re) {
			if (PortableExecutable.DEBUG) {
				throw re;
			}
		}
		if (++ndata == numberOfRvaAndSizes) {
			return;
		}

		monitor.setMessage("Parsing security...");
		try {
			dataDirectory[ndata] =
				SecurityDataDirectory.createSecurityDataDirectory(ntHeader, reader);
		}
		catch (RuntimeException re) {
			if (PortableExecutable.DEBUG) {
				throw re;
			}
		}
		if (++ndata == numberOfRvaAndSizes) {
			return;
		}

		monitor.setMessage("Parsing relocations...");
		try {
			dataDirectory[ndata] =
				BaseRelocationDataDirectory.createBaseRelocationDataDirectory(ntHeader, reader);
		}
		catch (RuntimeException re) {
			if (PortableExecutable.DEBUG) {
				throw re;
			}
		}
		if (++ndata == numberOfRvaAndSizes) {
			return;
		}

		monitor.setMessage("Parsing debug information...");
		try {
			dataDirectory[ndata] = DebugDataDirectory.createDebugDataDirectory(ntHeader, reader);
		}
		catch (RuntimeException re) {
			if (PortableExecutable.DEBUG) {
				throw re;
			}
		}
		if (++ndata == numberOfRvaAndSizes) {
			return;
		}

		monitor.setMessage("Parsing architecture...");
		try {
			dataDirectory[ndata] =
				ArchitectureDataDirectory.createArchitectureDataDirectory(ntHeader, reader);
		}
		catch (RuntimeException re) {
			if (PortableExecutable.DEBUG) {
				throw re;
			}
		}
		if (++ndata == numberOfRvaAndSizes) {
			return;
		}

		monitor.setMessage("Parsing global pointer...");
		try {
			dataDirectory[ndata] =
				GlobalPointerDataDirectory.createGlobalPointerDataDirectory(ntHeader, reader);
		}
		catch (RuntimeException re) {
			if (PortableExecutable.DEBUG) {
				throw re;
			}
		}
		if (++ndata == numberOfRvaAndSizes) {
			return;
		}

		monitor.setMessage("Parsing TLS data...");
		try {
			dataDirectory[ndata] = TLSDataDirectory.createTLSDataDirectory(ntHeader, reader);
		}
		catch (RuntimeException re) {
			if (PortableExecutable.DEBUG) {
				throw re;
			}
		}
		if (++ndata == numberOfRvaAndSizes) {
			return;
		}

		monitor.setMessage("Parsing load config data...");
		try {
			dataDirectory[ndata] =
				LoadConfigDataDirectory.createLoadConfigDataDirectory(ntHeader, reader);
		}
		catch (RuntimeException re) {
			if (PortableExecutable.DEBUG) {
				throw re;
			}
		}
		if (ndata++ == numberOfRvaAndSizes) {
			return;
		}

		monitor.setMessage("Parsing bound imports...");
		try {
			dataDirectory[ndata] =
				BoundImportDataDirectory.createBoundImportDataDirectory(ntHeader, reader);
		}
		catch (RuntimeException re) {
			if (PortableExecutable.DEBUG) {
				throw re;
			}
		}
		if (++ndata == numberOfRvaAndSizes) {
			return;
		}

		monitor.setMessage("Parsing import address table...");
		try {
			dataDirectory[ndata] =
				ImportAddressTableDataDirectory.createImportAddressTableDataDirectory(ntHeader,
					reader);
		}
		catch (RuntimeException re) {
			if (PortableExecutable.DEBUG) {
				throw re;
			}
		}
		if (++ndata == numberOfRvaAndSizes) {
			return;
		}

		monitor.setMessage("Parsing delay imports...");
		try {
			dataDirectory[ndata] =
				DelayImportDataDirectory.createDelayImportDataDirectory(ntHeader, loadInfo, reader);
		}
		catch (RuntimeException re) {
			if (PortableExecutable.DEBUG) {
				throw re;
			}
		}
		if (++ndata == numberOfRvaAndSizes) {
			return;
		}

		monitor.setMessage("Parsing COM descriptors...");
		try {
			dataDirectory[ndata] =
				COMDescriptorDataDirectory.createCOMDescriptorDataDirectory(ntHeader, reader);
		}
		catch (RuntimeException re) {
			if (PortableExecutable.DEBUG) {
				throw re;
			}
		}
		if (++ndata == numberOfRvaAndSizes) {
			return;
		}

		dataDirectory[ndata] = null;
	}

	@Override
	public DataDirectory[] getDataDirectories() {
		return dataDirectory;
	}

	@Override
	public int getSectionAlignment() {
		return sectionAlignment;
	}

	@Override
	public int getFileAlignment() {
		return fileAlignment;
	}

	protected void parse() throws IOException {
		reader.setPointerIndex(startIndex);

		magic = reader.readNextShort();
		majorLinkerVersion = reader.readNextByte();
		minorLinkerVersion = reader.readNextByte();
		sizeOfCode = reader.readNextInt();
		sizeOfInitializedData = reader.readNextInt();
		sizeOfUninitializedData = reader.readNextInt();
		addressOfEntryPoint = reader.readNextInt();
		// NB: 0 or negative addressOfEntryPoint is legal
		if (addressOfEntryPoint < 0) {
			Msg.warn(this, "Negative entry point " + Integer.toHexString(addressOfEntryPoint));
		}
		if (addressOfEntryPoint == 0) {
			int characteristics = ntHeader.getFileHeader().getCharacteristics();
			if ((characteristics & FileHeader.IMAGE_FILE_DLL) == 0) {
				Msg.warn(this, "Zero entry point for non-DLL");
			}
		}
		baseOfCode = reader.readNextInt();

		if (is64bit()) {
			baseOfData = -1;//not used
			imageBase = reader.readNextLong();
			if (imageBase <= 0) {
				Msg.warn(this, "Non-standard image base: 0x" + Long.toHexString(imageBase));
				originalImageBase = imageBase;
				imageBase = 0x10000;
				wasRebased = true;
			}
		}
		else {
			baseOfData = reader.readNextInt();
			int imgBase = reader.readNextInt();
			imageBase = imgBase & Conv.INT_MASK;
			if (imgBase <= 0) {
				Msg.warn(this, "Non-standard image base " + Integer.toHexString(imgBase));
				originalImageBase = imageBase;
				imageBase = 0x10000;
				wasRebased = true;
			}
		}

		sectionAlignment = reader.readNextInt();
		fileAlignment = reader.readNextInt();
		if (fileAlignment < 0x200) {
			Msg.warn(this, "Unusual file alignment: 0x" + Integer.toHexString(fileAlignment));
		}
		majorOperatingSystemVersion = reader.readNextShort();
		minorOperatingSystemVersion = reader.readNextShort();
		majorImageVersion = reader.readNextShort();
		minorImageVersion = reader.readNextShort();
		majorSubsystemVersion = reader.readNextShort();
		minorSubsystemVersion = reader.readNextShort();
		win32VersionValue = reader.readNextInt();
		sizeOfImage = reader.readNextInt();
		sizeOfHeaders = reader.readNextInt();
		if (sizeOfHeaders >= sizeOfImage) {
			Msg.warn(this, "Size of headers >= size of image: forced load");
		}
		checkSum = reader.readNextInt();
		subsystem = reader.readNextShort();
		dllCharacteristics = reader.readNextShort();

		if (is64bit()) {
			sizeOfStackReserve = reader.readNextLong();
			sizeOfStackCommit = reader.readNextLong();
			sizeOfHeapReserve = reader.readNextLong();
			sizeOfHeapCommit = reader.readNextLong();
		}
		else {
			sizeOfStackReserve = reader.readNextInt() & Conv.INT_MASK;
			sizeOfStackCommit = reader.readNextInt() & Conv.INT_MASK;
			sizeOfHeapReserve = reader.readNextInt() & Conv.INT_MASK;
			sizeOfHeapCommit = reader.readNextInt() & Conv.INT_MASK;
		}

		loaderFlags = reader.readNextInt();
		numberOfRvaAndSizes = reader.readNextInt();

		if (numberOfRvaAndSizes != IMAGE_NUMBEROF_DIRECTORY_ENTRIES) {
			Msg.warn(this, "Non-standard # of data directories: " + numberOfRvaAndSizes);
			if (numberOfRvaAndSizes > IMAGE_NUMBEROF_DIRECTORY_ENTRIES || numberOfRvaAndSizes < 0) {
				Msg.warn(this,
					"Forcing # of data directories to: " + IMAGE_NUMBEROF_DIRECTORY_ENTRIES);
				numberOfRvaAndSizes = IMAGE_NUMBEROF_DIRECTORY_ENTRIES;
			}
		}

		startOfDataDirs = reader.getPointerIndex();
	}

	/**
	 * @see ghidra.app.util.bin.StructConverter#toDataType()
	 */
	@Override
	public DataType toDataType() throws DuplicateNameException {
		DataType xbo32 = ntHeader.getLoadInfo().sharedProgram ? new ModuleBaseOffset32DataType() : IBO32;

		StructureDataType ddstruct = new StructureDataType(DataDirectory.TITLE, 0);
		ddstruct.add(xbo32, "VirtualAddress", null);
		ddstruct.add(DWORD, "Size", null);
		ddstruct.setCategoryPath(new CategoryPath("/PE"));

		StructureDataType struct = new StructureDataType(getName(), 0);

		struct.add(WORD, "Magic", null);
		struct.add(BYTE, "MajorLinkerVersion", null);
		struct.add(BYTE, "MinorLinkerVersion", null);
		struct.add(DWORD, "SizeOfCode", null);
		struct.add(DWORD, "SizeOfInitializedData", null);
		struct.add(DWORD, "SizeOfUninitializedData", null);
		struct.add(xbo32, "AddressOfEntryPoint", null);
		struct.add(xbo32, "BaseOfCode", null);
		if (is64bit()) {
			//BaseOfData does not exist in 64 bit
			struct.add(new Pointer64DataType(), "ImageBase", null);
		}
		else {
			struct.add(xbo32, "BaseOfData", null);
			struct.add(new Pointer32DataType(), "ImageBase", null);
		}
		struct.add(DWORD, "SectionAlignment", null);
		struct.add(DWORD, "FileAlignment", null);
		struct.add(WORD, "MajorOperatingSystemVersion", null);
		struct.add(WORD, "MinorOperatingSystemVersion", null);
		struct.add(WORD, "MajorImageVersion", null);
		struct.add(WORD, "MinorImageVersion", null);
		struct.add(WORD, "MajorSubsystemVersion", null);
		struct.add(WORD, "MinorSubsystemVersion", null);
		struct.add(DWORD, "Win32VersionValue", null);
		struct.add(DWORD, "SizeOfImage", null);
		struct.add(DWORD, "SizeOfHeaders", null);
		struct.add(DWORD, "CheckSum", null);
		struct.add(WORD, "Subsystem", null);
		struct.add(WORD, "DllCharacteristics", null);
		if (is64bit()) {
			struct.add(QWORD, "SizeOfStackReserve", null);
			struct.add(QWORD, "SizeOfStackCommit", null);
			struct.add(QWORD, "SizeOfHeapReserve", null);
			struct.add(QWORD, "SizeOfHeapCommit", null);
		}
		else {
			struct.add(DWORD, "SizeOfStackReserve", null);
			struct.add(DWORD, "SizeOfStackCommit", null);
			struct.add(DWORD, "SizeOfHeapReserve", null);
			struct.add(DWORD, "SizeOfHeapCommit", null);
		}
		struct.add(DWORD, "LoaderFlags", null);
		struct.add(DWORD, "NumberOfRvaAndSizes", null);
		struct.add(
			new ArrayDataType(ddstruct, numberOfRvaAndSizes, ddstruct.getLength()),
			"DataDirectory", null);

		struct.setCategoryPath(new CategoryPath("/PE"));
		return struct;
	}

	@Override
	public void writeHeader(RandomAccessFile raf, DataConverter dc) throws IOException {
		raf.write(dc.getBytes(magic));
		raf.write(new byte[] { majorLinkerVersion });
		raf.write(new byte[] { minorLinkerVersion });
		raf.write(dc.getBytes(sizeOfCode));
		raf.write(dc.getBytes(sizeOfInitializedData));
		raf.write(dc.getBytes(sizeOfUninitializedData));
		raf.write(dc.getBytes(addressOfEntryPoint));
		raf.write(dc.getBytes(baseOfCode));
		if (is64bit()) {
			//BaseOfData does not exist in 64 bit
			raf.write(dc.getBytes(imageBase));
		}
		else {
			raf.write(dc.getBytes(baseOfData));
			raf.write(dc.getBytes((int) imageBase));
		}
		raf.write(dc.getBytes(sectionAlignment));
		raf.write(dc.getBytes(fileAlignment));
		raf.write(dc.getBytes(majorOperatingSystemVersion));
		raf.write(dc.getBytes(minorOperatingSystemVersion));
		raf.write(dc.getBytes(majorImageVersion));
		raf.write(dc.getBytes(minorImageVersion));
		raf.write(dc.getBytes(majorSubsystemVersion));
		raf.write(dc.getBytes(minorSubsystemVersion));
		raf.write(dc.getBytes(win32VersionValue));
		raf.write(dc.getBytes(sizeOfImage));
		raf.write(dc.getBytes(sizeOfHeaders));
		raf.write(dc.getBytes(checkSum));
		raf.write(dc.getBytes(subsystem));
		raf.write(dc.getBytes(dllCharacteristics));
		if (is64bit()) {
			raf.write(dc.getBytes(sizeOfStackReserve));
			raf.write(dc.getBytes(sizeOfStackCommit));
			raf.write(dc.getBytes(sizeOfHeapReserve));
			raf.write(dc.getBytes(sizeOfHeapCommit));
		}
		else {
			raf.write(dc.getBytes((int) sizeOfStackReserve));
			raf.write(dc.getBytes((int) sizeOfStackCommit));
			raf.write(dc.getBytes((int) sizeOfHeapReserve));
			raf.write(dc.getBytes((int) sizeOfHeapCommit));
		}
		raf.write(dc.getBytes(loaderFlags));
		raf.write(dc.getBytes(numberOfRvaAndSizes));

		//the last one is null ...
		for (int i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; ++i) {
			if (dataDirectory[i] != null) {
				raf.write(dc.getBytes(dataDirectory[i].getVirtualAddress()));
				raf.write(dc.getBytes(dataDirectory[i].getSize()));
			}
			else {
				raf.write(dc.getBytes(0));
				raf.write(dc.getBytes(0));
			}
		}
	}

	@Override
	public void validateDataDirectories(Program program, ImageLoadInfo loadInfo) {
		Memory memory = program.getMemory();
		int sizeint = Integer.SIZE / 8;
		Address addr = program.getImageBase().add(loadInfo.imageBase).add(startOfDataDirs);
		for (int i = 0; i < numberOfRvaAndSizes; i++) {
			try {
				int virtualAddress = memory.getInt(addr, false);
				addr = addr.add(sizeint);
				int size = memory.getInt(addr, false);
				addr = addr.add(sizeint);
				if (dataDirectory[i] != null && dataDirectory[i].hasParsedCorrectly()) {
					if (dataDirectory[i].getVirtualAddress() != virtualAddress) {
						Msg.warn(this,
							"Correcting dataDirectory[" + i + "] va:" +
								Integer.toHexString(dataDirectory[i].getVirtualAddress()) + "->" +
								Integer.toHexString(virtualAddress));
						dataDirectory[i].setVirtualAddress(virtualAddress);
					}
					if (dataDirectory[i].getSize() != size) {
						Msg.warn(this,
							"Correcting dataDirectory[" + i + "] sz:" +
								Integer.toHexString(dataDirectory[i].getSize()) + "->" +
								Integer.toHexString(size));
						dataDirectory[i].setSize(size);
					}
				}
			}
			catch (MemoryAccessException e) {
				e.printStackTrace();
			}
			catch (AddressOutOfBoundsException e) {
				e.printStackTrace();
			}
		}
	}

	@Override
	public boolean wasRebased() {
		return wasRebased;
	}

	@Override
	public boolean isCLI() throws IOException {
		long origPointerIndex = reader.getPointerIndex();

		reader.setPointerIndex(startOfDataDirs + (DataDirectory.IMAGE_SIZEOF_IMAGE_DIRECTORY_ENTRY *
			IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR));

		ImageCor20Header cor20 =
			COMDescriptorDataDirectory.createCOMDescriptorDataDirectory(ntHeader,
				reader).getHeader();

		reader.setPointerIndex(origPointerIndex);

		if (cor20 == null) {
			return false;
		}

		boolean intermediateLanguageOnly = (cor20.getFlags() &
			ImageCor20Flags.COMIMAGE_FLAGS_ILONLY) == ImageCor20Flags.COMIMAGE_FLAGS_ILONLY;

		return intermediateLanguageOnly && cor20.getManagedNativeHeader().getVirtualAddress() == 0;
	}

	@Override
	public byte getMajorLinkerVersion() {
		return majorLinkerVersion;
	}

	@Override
	public byte getMinorLinkerVersion() {
		return minorLinkerVersion;
	}

	@Override
	public short getMajorImageVersion() {
		return majorImageVersion;
	}

	@Override
	public short getMinorImageVersion() {
		return minorImageVersion;
	}

	@Override
	public short getMajorSubsystemVersion() {
		return majorSubsystemVersion;
	}

	@Override
	public short getMinorSubsystemVersion() {
		return minorSubsystemVersion;
	}

	@Override
	public int getWin32VersionValue() {
		return win32VersionValue;
	}

	@Override
	public int getChecksum() {
		return checkSum;
	}

	@Override
	public int getSubsystem() {
		return subsystem;
	}

	@Override
	public short getDllCharacteristics() {
		return dllCharacteristics;
	}

	@Override
	public long getSizeOfStackReserve() {
		return sizeOfStackReserve;
	}

	@Override
	public long getSizeOfStackCommit() {
		return sizeOfStackCommit;
	}

	@Override
	public long getSizeOfHeapReserve() {
		return sizeOfHeapReserve;
	}

	@Override
	public long getSizeOfHeapCommit() {
		return sizeOfHeapCommit;
	}

	@Override
	public int getLoaderFlags() {
		return loaderFlags;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/OptionalHeaderROM.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

/**
 * A class to represent the IMAGE_ROM_OPTIONAL_HEADER 
 * data structure.
 * <br>
 * <pre>
 * typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
 *     WORD   Magic;
 *     BYTE   MajorLinkerVersion;
 *     BYTE   MinorLinkerVersion;
 *     DWORD  SizeOfCode;
 *     DWORD  SizeOfInitializedData;
 *     DWORD  SizeOfUninitializedData;
 *     DWORD  AddressOfEntryPoint;
 *     DWORD  BaseOfCode;
 *     DWORD  BaseOfData;
 *     DWORD  BaseOfBss;
 *     DWORD  GprMask;
 *     DWORD  CprMask[4];
 *     DWORD  GpValue;
 * } IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;
 * </pre>
 */
public class OptionalHeaderROM {
    private short    magic;
    private byte     majorLinkerVersion;
    private byte     minorLinkerVersion;
    private int      sizeOfCode;
    private int      sizeOfInitializedData;
    private int      sizeOfUninitializedData;
    private int      addressOfEntryPoint;
    private int      baseOfCode;
    private int      baseOfData;
    private int      baseOfBss;
    private int      gprMask;
    private int []   cprMask;
    private int      gpValue;

    public short getMagic() {
		return magic;
	}
    public byte getMajorLinkerVersion() {
		return majorLinkerVersion;
	}
    public byte getMinorLinkerVersion() {
		return minorLinkerVersion;
	}
    public int getSizeOfCode() {
		return sizeOfCode;
	}
    public int getSizeOfInitializedData() {
		return sizeOfInitializedData;
	}
    public int getSizeOfUninitializedData() {
		return sizeOfUninitializedData;
	}
    public int getAddressOfEntryPoint() {
		return addressOfEntryPoint;
	}
    public int getBaseOfCode() {
		return baseOfCode;
	}
    public int getBaseOfData() {
		return baseOfData;
	}
    public int getBaseOfBss() {
		return baseOfBss;
	}
    public int getGprMask() {
		return gprMask;
	}
    public int[] getCprMask() {
		return cprMask;
	}
    public int getGpValue() {
		return gpValue;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/PeMarkupable.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;

import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;

/**
 * Common interface for standardizing the markup of a PE structure.
 */
public interface PeMarkupable {

	/**
	 * Marks up a PE structure.
	 * 
	 * @param program The program to markup.
	 * @param isBinary True if the program is binary; otherwise, false.
	 * @param monitor The monitor.
	 * @param log The log.
	 * @param ntHeader The PE's NT Header structure.
	 * @throws DuplicateNameException
	 * @throws CodeUnitInsertionException
	 * @throws IOException
	 * @throws MemoryAccessException
	 */
	public void markup(Program program, boolean isBinary, TaskMonitor monitor, MessageLog log,
			NTHeader ntHeader) throws DuplicateNameException, CodeUnitInsertionException,
			IOException, MemoryAccessException;
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/PeSubsystem.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

public enum PeSubsystem {

	// @formatter:off
	 IMAGE_SUBSYSTEM_UNKNOWN("IMAGE_SUBSYSTEM_UNKNOWN", 0, 
		 "An unknown subsystem"),
	 IMAGE_SUBSYSTEM_NATIVE("IMAGE_SUBSYSTEM_NATIVE", 1, 
		 "Device drivers and native Windows processes"),
	 IMAGE_SUBSYSTEM_WINDOWS_GUI("IMAGE_SUBSYSTEM_WINDOWS_GUI", 2, 
		 "The Windows graphical user interface (GUI) subsystem"),
	 IMAGE_SUBSYSTEM_WINDOWS_CUI("IMAGE_SUBSYSTEM_WINDOWS_CUI", 3, 
		 "The Windows character subsystem"),
	 IMAGE_SUBSYSTEM_OS2_CUI("IMAGE_SUBSYSTEM_OS2_CUI", 5, 
		 "The OS/2 character subsystem"),
	 IMAGE_SUBSYSTEM_POSIX_CUI("IMAGE_SUBSYSTEM_POSIX_CUI", 7, 
		 "The Posix character subsystem"),
	 IMAGE_SUBSYSTEM_NATIVE_WINDOWS("IMAGE_SUBSYSTEM_NATIVE_WINDOWS", 8, 
		 "Native Win9x driver"),
	 IMAGE_SUBSYSTEM_WINDOWS_CE_GUI("IMAGE_SUBSYSTEM_WINDOWS_CE_GUI", 9, 
		 "Windows CE"),
	 IMAGE_SUBSYSTEM_EFI_APPLICATION("IMAGE_SUBSYSTEM_EFI_APPLICATION", 10, 
		 "An Extensible Firmware Interface (EFI) application"),
	 IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER("IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER", 11, 
		 "An Extensible Firmware Interface (EFI) driver with boot services"),
	 IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER("IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER", 12, 
		 "An Extensible Firmware Interface (EFI) driver with run-time services"),
	 IMAGE_SUBSYSTEM_EFI_ROM("IMAGE_SUBSYSTEM_EFI_ROM", 13, 
		 "An Extensible Firmware Interface (EFI) ROM image"),
	 IMAGE_SUBSYSTEM_XBOX("IMAGE_SUBSYSTEM_XBOX", 14, 
		 "XBOX Image"),
	 IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION("IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION", 16, 
		 "Windows boot application.");
	// @formatter:on

	private final String alias;
	private final int value;
	private final String description;

	private PeSubsystem(String alias, int value, String description) {
		this.alias = alias;
		this.value = value;
		this.description = description;
	}

	public String getAlias() {
		return alias;
	}

	public int getValue() {
		return value;
	}

	public String getDescription() {
		return description;
	}

	public static PeSubsystem parse(int id) {
		for (PeSubsystem ss : values()) {
			if (ss.getValue() == id) {
				return ss;
			}
		}
		throw new IllegalArgumentException("Can't resolve '" + id + "' to known PeSubsystem");
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/PeUtils.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressSpace;
import ghidra.program.model.data.DataType;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.Program;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.Msg;

public class PeUtils {

	public static Address getMarkupAddress(Program program, boolean isBinary, NTHeader ntHeader,
			int offset) {
		AddressSpace space = program.getAddressFactory().getDefaultAddressSpace();
		if (isBinary) {
			int ptr = ntHeader.rvaToPointer(offset);
			if (ptr < 0 && offset > 0) {//directory does not appear inside a loadable section
				Msg.error(PeUtils.class, "Invalid RVA " + Integer.toHexString(offset));
				return space.getAddress(offset);
			}
			return space.getAddress(ptr);
		}
		return space.getAddress(offset + ntHeader.getOptionalHeader().getImageBase());
	}

	public static Data createData(Program program, Address addr, DataType datatype,
			MessageLog log) {
		Data existingData = program.getListing().getDefinedDataAt(addr);
		if (existingData != null) {
			DataType existingDataType = existingData.getDataType();
			if (existingDataType.isEquivalent(datatype)) {
				return existingData;
			}
		}
		try {
			program.getListing().createData(addr, datatype);
			return program.getListing().getDefinedDataAt(addr);
		}
		catch (CodeUnitInsertionException e) {
			log.appendMsg("[" + program.getName() + "]: failed to create " +
				datatype.getDisplayName() + " at " + addr + ": " + e.getMessage());
		}
		catch (Exception e) {
			log.appendMsg(e.getMessage());
		}
		return null;
	}

	public static void createData(Program program, Address addr, DataType datatype,
			int datatypeLength, MessageLog log) {
		try {
			program.getListing().createData(addr, datatype, datatypeLength);
		}
		catch (Exception e) {
			log.appendMsg(e.getMessage());
		}
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/PortableExecutable.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;
import java.io.RandomAccessFile;

import generic.continues.GenericFactory;
import ghidra.app.util.bin.ByteProvider;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.app.util.bin.format.mz.DOSHeader;
import ghidra.util.DataConverter;
import ghidra.util.Msg;
import ghidra.util.exception.NotYetImplementedException;
import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;

/**
 * A class to manage loading Portable Executables (PE).
 * 
 * 
 */
public class PortableExecutable {
	public static final String NAME = "PORTABLE_EXECUTABLE";
	public static boolean DEBUG = false;

	/**
	 * Indicates how sections of this PE are laid out in the underlying ByteProvider.
	 * Use {@link SectionLayout#FILE} when loading from a file, and {@link SectionLayout#MEMORY} when
	 * loading from a memory model (like an already-loaded program in Ghidra).
	 */
	public static enum SectionLayout {
		/** Indicates the sections of this PE are laid out as stored in a file. **/
		FILE,
		/** Indicates the sections of this PE are laid out as loaded into memory **/
		MEMORY
	}

	private FactoryBundledWithBinaryReader reader;
	private DOSHeader dosHeader;
	private RichHeader richHeader;
	private NTHeader ntHeader;

	//private FileHeader fileHeader;

	/**
	 * Constructs a new Portable Executable using the specified byte provider and layout.
	 *  <p>
	 * Same as calling <code>createFileAlignedPortableExecutable(factory, bp, layout, true, false)</code>
	 * @param factory generic factory instance
	 * @param bp the byte provider
	 * @param layout specifies the layout of the underlying provider and governs RVA resolution
	 * @throws IOException if an I/O error occurs.
	 * @see #createPortableExecutable(GenericFactory, ByteProvider, SectionLayout, boolean, boolean)
	 **/
	public static PortableExecutable createPortableExecutable(GenericFactory factory,
			ByteProvider bp, ImageLoadInfo loadInfo) throws IOException {
		return createPortableExecutable(factory, bp, loadInfo, true, false);
	}

	/**
	 * Constructs a new Portable Executable using the specified byte provider and layout.
	 * @param factory generic factory instance
	 * @param bp the byte provider
	 * @param layout specifies the layout of the underlying provider and governs RVA resolution
	 * @param advancedProcess if true, the data directories are also processed
	 * @param parseCliHeaders if true, CLI headers are parsed (if present)
	 * @throws IOException if an I/O error occurs.
	 */
	public static PortableExecutable createPortableExecutable(GenericFactory factory,
			ByteProvider bp, ImageLoadInfo loadInfo, boolean advancedProcess, boolean parseCliHeaders)
			throws IOException {
		PortableExecutable portableExecutable =
			(PortableExecutable) factory.create(PortableExecutable.class);
		portableExecutable.initPortableExecutable(factory, bp, loadInfo, advancedProcess,
			parseCliHeaders);
		return portableExecutable;
	}

	/**
	 * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
	 */
	public PortableExecutable() {
	}

	private void initPortableExecutable(GenericFactory factory, ByteProvider bp,
			ImageLoadInfo loadInfo, boolean advancedProcess, boolean parseCliHeaders)
			throws IOException {
		reader = new FactoryBundledWithBinaryReader(factory, bp, true);

		dosHeader = DOSHeader.createDOSHeader(reader);
		if (dosHeader.isDosSignature()) {
			richHeader = RichHeader.createRichHeader(reader);
			if (richHeader.getSize() > 0) {
				dosHeader.decrementStub(richHeader.getOffset());
			}

			try {
				ntHeader = NTHeader.createNTHeader(reader, dosHeader.e_lfanew(), loadInfo,
					advancedProcess, parseCliHeaders);
			}
			catch (InvalidNTHeaderException e) {
				Msg.debug(this, "Expected InvalidNTHeaderException, ignoring");
			}
			catch (NotYetImplementedException e) {
				Msg.debug(this, "Expected NotYetImplementedException, ignoring");
			}
			catch (ArrayIndexOutOfBoundsException e) {
				Msg.error(this, "Unexpected Exception: " + e.getMessage(), e);
			}
			return;
		}

		//fileHeader = new FileHeader(reader);
		//
		//if (fileHeader.getMachineName() != null) {
		//    if (fileHeader.getSizeOfOptionalHeader() == 0) {
		//        Err.debug(this, "This is a .OBJ file...");
		//    }
		//    else if (fileHeader.getSizeOfOptionalHeader() == Constants.IMAGE_SIZEOF_ROM_OPTIONAL_HEADER) {
		//        Err.debug(this, "This is a ROM image...");
		//    }
		//}
		//if (isValidLibrary(reader)) {
		//    Err.debug(this, "This is a library/archive file...");
		//}
	}

	/**
	 * Returns the DOS header from the PE image.
	 * @return the DOS header from the PE image
	 */
	public DOSHeader getDOSHeader() {
		return dosHeader;
	}

	/**
	 * Returns the Rich header from the PE image.
	 * @return the Rich header from the PE image
	 */
	public RichHeader getRichHeader() {
		return richHeader;
	}

	/**
	 * Returns the NT header from the PE image.
	 * @return the NT header from the PE image
	 */
	public NTHeader getNTHeader() {
		return ntHeader;
	}

	//private boolean isValidLibrary(BinaryReader reader) throws IOException {
	//    String s = reader.readAsciiString(0);
	//    if (s != null && s.length() >= Constants.IMAGE_ARCHIVE_START_SIZE) {
	//        return s.substring(0, Constants.IMAGE_ARCHIVE_START_SIZE).equals(Constants.IMAGE_ARCHIVE_START);
	//    }
	//    return false;
	//}

	public void writeHeader(RandomAccessFile raf, DataConverter dc) throws IOException {

		raf.seek(0);
		if (dosHeader != null) {
			dosHeader.write(raf, dc);
		}
		if (richHeader != null) {
			richHeader.write(raf, dc);
		}
		if (ntHeader != null) {
			ntHeader.writeHeader(raf, dc);
		}
	}

	public static int computeAlignment(int value, int alignment) {
		if (alignment == 0 || (value % alignment) == 0) {
			return value;
		}
		int a = ((value + alignment) / alignment) * alignment;
		return a;
	}
	
	public long getFileLength() {
		if (reader != null) {
			try {
				return reader.length();
			} catch (IOException e) {
				// IGNORE
				return  0;
			}
		}
		return  0;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/ROMHeader.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

/**
 * A class to represent the 
 * <code>IMAGE_ROM_HEADERS</code>
 * struct as defined in 
 * <b><code>winnt.h</code></b>.
 *
 * <pre>
 * typedef struct _IMAGE_ROM_HEADERS {
 *    IMAGE_FILE_HEADER FileHeader;
 *    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
 * } IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;
 * </pre> 
 */
class ROMHeader {
    private FileHeader fileHeader;
    private OptionalHeaderROM optionalHeader;

    public FileHeader getFileHeader() {
		return fileHeader;
	}
    public OptionalHeaderROM getOptionalHeader() {
		return optionalHeader;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/ResourceDataDirectory.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;
import java.util.*;

import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;
import net.jubjubnest.minidump.contrib.pe.resource.*;
import ghidra.app.util.datatype.microsoft.*;
import ghidra.app.util.importer.MessageLog;
import ghidra.framework.options.Options;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressSpace;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.DumbMemBufferImpl;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.program.model.symbol.SourceType;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.exception.InvalidInputException;
import ghidra.util.task.TaskMonitor;

/**
 * Points to the root resource directory.
 */
public class ResourceDataDirectory extends DataDirectory {
	private final static String NAME = "IMAGE_DIRECTORY_ENTRY_RESOURCE";
	/**
	 * The size of a resource directory entry, in bytes.
	 */
	public final static int IMAGE_SIZEOF_RESOURCE_DIRECTORY_ENTRY = 8;
	/**
	 * The size of a resource directory, in bytes.
	 */
	public final static int IMAGE_SIZEOF_RESOURCE_DIRECTORY = 16;
	/**
	 * A flag indicating that a resources is a string.
	 */
	public final static int IMAGE_RESOURCE_NAME_IS_STRING = 0x80000000;
	/**
	 * A flag indicating that a resources is a directory.
	 */
	public final static int IMAGE_RESOURCE_DATA_IS_DIRECTORY = 0x80000000;
	/**
	 * A lookup table to obtain a string name for a resource type.
	 */
	public final static String[] PREDEFINED_RESOURCE_NAMES = { "0", "Cursor", "Bitmap", "Icon",
		"Menu", "Dialog", "StringTable", "FontDir", "Font", "Accelerator", "RC_Data",
		"MessageTable", "GroupCursor", "13", "GroupIcon", "15", "Version", "DialogInclude", "18",
		"PlugAndPlay", "VXD", "ANI_Cursor", "ANI_Icon", "HTML", "Manifest" };

	/**
	 * Not defined in documentation but PNGs and WAVs are both this type
	 */
	public final static byte RT_NOTDEFINED = 0;
	/**
	/**
	 * Hardware-dependent cursor resource.
	 */
	public final static byte RT_CURSOR = 1;
	/**
	 * Bitmap resource.
	 */
	public final static byte RT_BITMAP = 2;
	/**
	 * Hardware-dependent icon resource.
	 */
	public final static byte RT_ICON = 3;
	/**
	 * Menu resource.
	 */
	public final static byte RT_MENU = 4;
	/**
	 * Dialog box.
	 */
	public final static byte RT_DIALOG = 5;
	/**
	 * String-table entry.
	 */
	public final static byte RT_STRING = 6;
	/**
	 * Font directory resource.
	 */
	public final static byte RT_FONTDIR = 7;
	/**
	 * Font resource.
	 */
	public final static byte RT_FONT = 8;
	/**
	 * Accelerator table.
	 */
	public final static byte RT_ACCELERATOR = 9;
	/**
	 * Application-defined resource (raw data).
	 */
	public final static byte RT_RCDATA = 10;
	/**
	 * Message-table entry.
	 */
	public final static byte RT_MESSAGETABLE = 11;
	/**
	 * Hardware-independent cursor resource.
	 */
	public final static byte RT_GROUP_CURSOR = 12;
	// 13 is not defined...
	/**
	 * Hardware-independent icon resource.
	 */
	public final static byte RT_GROUP_ICON = 14;
	// 15 is not defined...
	/**
	 * Version resource.
	 */
	public final static byte RT_VERSION = 16;

	public final static byte RT_DLGINCLUDE = 17;
	// 18 is not defined...
	/**
	 * Plug and Play resource.
	 */
	public final static byte RT_PLUGPLAY = 19;
	/**
	 * VXD resource.
	 */
	public final static byte RT_VXD = 20;
	/**
	 * Animated cursor resource.
	 */
	public final static byte RT_ANICURSOR = 21;
	/**
	 * Animated icon resource.
	 */
	public final static byte RT_ANIICON = 22;
	/**
	 * HTML resource.
	 */
	public final static byte RT_HTML = 23;
	/**
	 * Manifest resource
	 */
	public final static byte RT_MANIFEST = 24;

	private ResourceDirectory rootDirectory;

	public static Set<Integer> directoryMap;

	static ResourceDataDirectory createResourceDataDirectory(NTHeader ntHeader,
			FactoryBundledWithBinaryReader reader) throws IOException {
		ResourceDataDirectory resourceDataDirectory =
			(ResourceDataDirectory) reader.getFactory().create(ResourceDataDirectory.class);
		resourceDataDirectory.initResourceDataDirectory(ntHeader, reader);
		return resourceDataDirectory;
	}

	/**
	 * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
	 */
	public ResourceDataDirectory() {
	}

	private void initResourceDataDirectory(NTHeader ntHeader, FactoryBundledWithBinaryReader reader)
			throws IOException {
		directoryMap = new HashSet<>();
		processDataDirectory(ntHeader, reader);
	}

	public ResourceDirectory getRootDirectory() {
		return rootDirectory;
	}

	@Override
	public String getDirectoryName() {
		return NAME;
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor,
			MessageLog log, NTHeader ntHeader) throws DuplicateNameException, CodeUnitInsertionException,
			DataTypeConflictException, IOException {

		if (rootDirectory == null) {
			return;
		}
		monitor.setMessage("[" + program.getName() + "]: resources...");
		Address addr = PeUtils.getMarkupAddress(program, isBinary, ntHeader, virtualAddress);
		if (!program.getMemory().contains(addr)) {
			return;
		}
		createDirectoryBookmark(program, addr);

		AddressSpace space = program.getAddressFactory().getDefaultAddressSpace();

		HashMap<Integer, Integer> countMap = new HashMap<>();

		List<ResourceInfo> resources = getResources();
		if (resources == null) {
			return;
		}

		try {
			for (ResourceInfo info : resources) {
				if (monitor.isCancelled()) {
					return;
				}

				Integer cnt = countMap.get(info.getTypeID());
				if (cnt == null) {
					countMap.put(info.getTypeID(), 1);
				}
				else {
					countMap.put(info.getTypeID(), cnt + 1);
				}

				addr = space.getAddress(va(info.getAddress(), isBinary));

				try {
					program.getSymbolTable().createLabel(addr, info.getName(), SourceType.IMPORTED);
				}
				catch (InvalidInputException e) {
					Msg.error(this, "Invalid Input Exception: " + e.getMessage(), e);
				}

				String cmt =
					"Size of resource: 0x" + Integer.toHexString(info.getSize()) + " bytes";
				StringBuilder extraComment = new StringBuilder();

				if (info.getTypeID() == ResourceDataDirectory.RT_NOTDEFINED) {
					if (info.getName().startsWith("Rsrc_IMAGE") ||
						info.getName().startsWith("Rsrc_PNG")) {
						DataType dataType = null;
						try {
							// Check for PNG magic number
							if (program.getMemory().getInt(addr) == 0x474e5089) {
								dataType = new PngDataType();
							}
							// Check for GIF magic number
							else if (program.getMemory().getInt(addr) == 0x47494638) {
								dataType = new GifDataType();
							}

						}
						catch (MemoryAccessException e) {
							// ignore - let createData produce error
						}
						PeUtils.createData(program, addr, dataType, log);
					}
					else if (info.getName().startsWith("Rsrc_WAV")) {
						DataType dataType = null;
						// Check for WAV magic number
						try {
							if (program.getMemory().getInt(addr) == 0x46464952) {
								dataType = new WAVEDataType();
							}
						}
						catch (MemoryAccessException e) {
							// ignore - let createData produce error
						}
						PeUtils.createData(program, addr, dataType, log);
					}
					else if (info.getName().startsWith("Rsrc_WEVT")) {
						DataType dataType = null;
						// Check for WEVT magic number "CRIM"
						try {
							if (program.getMemory().getInt(addr) == 0x4d495243) {
								dataType = new WEVTResourceDataType();
							}
						}
						catch (MemoryAccessException e) {
							// ignore - let createData produce error
						}
						PeUtils.createData(program, addr, dataType, log);
					}
					else if (info.getName().startsWith("Rsrc_MUI")) {
						DataType dataType = null;
						// Check for MUI magic number
						try {
							if (program.getMemory().getInt(addr) == 0xfecdfecd) {
								dataType = new MUIResourceDataType();
							}
						}
						catch (MemoryAccessException e) {
							// ignore - let createData produce error
						}
						PeUtils.createData(program, addr, dataType, log);
					}
					else {
						//add byte array of correct size until data type can be created for missing types- this will keep auto analysis from incorrectly analyzing here
						ArrayDataType byteArray =
							new ArrayDataType(ByteDataType.dataType, info.getSize(), 1);
						PeUtils.createData(program, addr, byteArray, log);
					}
				}
				else if (info.getTypeID() == ResourceDataDirectory.RT_STRING) {
					for (int s = 0; s < 0x10; ++s) {
						int id = ((info.getID() - 1) * 0x10) + s;
						setEolComment(program, addr, "Rsrc String ID " + id);
						PascalUnicodeDataType str = new PascalUnicodeDataType();
						PeUtils.createData(program, addr, str, log);
						Data data = program.getListing().getDataAt(addr);
						if (data != null) {
							addr = data.getMaxAddress().add(1);
						}
					}
				}
				else if (info.getTypeID() == ResourceDataDirectory.RT_BITMAP) {
					BitmapResourceDataType bitmapDatatype = new BitmapResourceDataType();
					PeUtils.createData(program, addr, bitmapDatatype, log);
				}
				else if (info.getTypeID() == ResourceDataDirectory.RT_ICON) {
					DataType iconDataType = null;
					try {
						// Check for PNG magic number
						if (program.getMemory().getInt(addr) == 0x474e5089) {
							iconDataType = new PngDataType();
						}
						// Check for GIF magic number
						else if (program.getMemory().getInt(addr) == 0x47494638) {
							iconDataType = new GifDataType();
						}
					}
					catch (MemoryAccessException e) {
						// ignore - let createData produce error
					}
					if (iconDataType == null) {
						// assume Icon resource by default if not PNG
						iconDataType = new IconResourceDataType();
					}
					PeUtils.createData(program, addr, iconDataType, log);
				}
				//			else if (info.getTypeID() == ResourceDataDirectory.RT_CURSOR) {
				//
				//			}
				else if (info.getTypeID() == ResourceDataDirectory.RT_GROUP_ICON) {
					GroupIconResourceDataType groupIconDataType = new GroupIconResourceDataType();
					PeUtils.createData(program, addr, groupIconDataType, log);
				}
				//else if (info.getTypeID() == ResourceDataDirectory.RT_GROUP_CURSOR) {
				//
				//			}
				else if (info.getTypeID() == ResourceDataDirectory.RT_MENU) {
					MenuResourceDataType menuResourceDataType = new MenuResourceDataType();
					Data createData = PeUtils.createData(program, addr, menuResourceDataType, log);
					if (createData != null) {
						extraComment.append("\n" + setExtraCommentForMenuResource(createData));
					}
				}
				else if (info.getTypeID() == ResourceDataDirectory.RT_DIALOG) {
					DialogResourceDataType dialogResourceDataType = new DialogResourceDataType();
					Data createData =
						PeUtils.createData(program, addr, dialogResourceDataType, log);
					if (createData != null) {
						extraComment.append("\n" + setExtraCommentForDialogResource(createData));
					}
				}
				else if (info.getTypeID() == ResourceDataDirectory.RT_VERSION) {
					processVersionInfo(addr, info, program, log, monitor);
				}
				else if (info.getTypeID() == ResourceDataDirectory.RT_MANIFEST) { // XML manifest string
					PeUtils.createData(program, addr, TerminatedStringDataType.dataType, log);
				}
				else if (info.getTypeID() == ResourceDataDirectory.RT_HTML) {
					HTMLResourceDataType htmlResourceDataType = new HTMLResourceDataType();
					PeUtils.createData(program, addr, htmlResourceDataType, info.getSize(), log);
				}
				else {
					//add byte array of correct size until data type can be created for missing types- this will keep auto analysis from incorrectly analyzing here
					ArrayDataType byteArray =
						new ArrayDataType(ByteDataType.dataType, info.getSize(), 1);
					PeUtils.createData(program, addr, byteArray, log);
				}

				setPlateComment(program, addr, info.getName() + " " + cmt + extraComment);
			}

		}
		catch (Exception e) {
			Msg.error(this, "Invalid resource data: " + e.getMessage(), e);
		}

		Address resourceBase =
			PeUtils.getMarkupAddress(program, isBinary, ntHeader, virtualAddress);
		markupDirectory(rootDirectory, resourceBase, resourceBase, program, isBinary, monitor, log);
	}

	private void processVersionInfo(Address addr, ResourceInfo info, Program program,
			MessageLog log, TaskMonitor monitor) throws IOException {
		Options infoList = ntHeader.getLoadInfo().getModuleOptions(program);
		VS_VERSION_INFO versionInfo = null;
		try {
			int ptr = ntHeader.rvaToPointer(info.getAddress());
			if (ptr < 0) {
				Msg.error(this, "Invalid RVA " + Integer.toHexString(info.getAddress()));
				return;
			}
			versionInfo = new VS_VERSION_INFO(reader, ptr);
			PeUtils.createData(program, addr, versionInfo.toDataType(), log);
		}
		catch (DuplicateNameException e) {
			Msg.error(this, "Unexpected Exception: VS_VERSION_INFO structure previously defined",
				e);
		}
		VS_VERSION_CHILD[] children = versionInfo.getChildren();
		for (VS_VERSION_CHILD child : children) {
			if (monitor.isCancelled()) {
				return;
			}
			markupChild(child, addr, program, log, monitor);
		}

		String[] keys = versionInfo.getKeys();
		for (String key : keys) {
			if (monitor.isCancelled()) {
				return;
			}
			String value = versionInfo.getValue(key);
			infoList.setString(key, value);
		}
	}

	private void markupChild(VS_VERSION_CHILD child, Address parentAddr, Program program,
			MessageLog log, TaskMonitor monitor) {
		Address childAddr = parentAddr.add(child.getRelativeOffset());
		try {
			DataType infoType = child.toDataType();
			if (infoType == null) {
				return;
			}
			PeUtils.createData(program, childAddr, infoType, log);

			// child name string
			PeUtils.createData(program, childAddr.add(child.getNameRelativeOffset()),
				TerminatedUnicodeDataType.dataType, log);

			if (child.valueIsUnicodeString()) {
				// unicode value
				PeUtils.createData(program, childAddr.add(child.getValueRelativeOffset()),
					TerminatedUnicodeDataType.dataType, log);
			}
			else if (child.valueIsDWord()) {
				// dword value
				PeUtils.createData(program, childAddr.add(child.getValueRelativeOffset()),
					DWordDataType.dataType, log);
			}
			else if (child.hasChildren()) {
				// markup nested children
				VS_VERSION_CHILD[] children = child.getChildren();
				for (VS_VERSION_CHILD element : children) {
					if (monitor.isCancelled()) {
						return;
					}
					markupChild(element, childAddr, program, log, monitor);
				}
			}
		}
		catch (DuplicateNameException e) {
			Msg.error(this,
				"Unexpected Exception: " + child.getChildName() + " structure previously defined",
				e);
		}
	}

	private void markupDirectory(ResourceDirectory directory, Address directoryAddr,
			Address resourceBase, Program program, boolean isBinary, TaskMonitor monitor,
			MessageLog log) throws IOException, DuplicateNameException, CodeUnitInsertionException {

		PeUtils.createData(program, directoryAddr, directory.toDataType(), log);
		directoryAddr = directoryAddr.add(ResourceDirectory.SIZEOF);

		List<ResourceDirectoryEntry> entries = directory.getEntries();
		for (ResourceDirectoryEntry entry : entries) {
			if (monitor.isCancelled()) {
				return;
			}

			PeUtils.createData(program, directoryAddr, entry.toDataType(), log);
			directoryAddr = directoryAddr.add(ResourceDirectoryEntry.SIZEOF);

			ResourceDirectory subDirectory = entry.getSubDirectory();
			if (subDirectory != null) {
				Address subDirectoryAddr = resourceBase.add(entry.getOffsetToDirectory());
				markupDirectory(subDirectory, subDirectoryAddr, resourceBase, program, isBinary,
					monitor, log);
			}

			ResourceDataEntry data = entry.getData();
			if (data != null) {
				Address dataAddr = resourceBase.add(entry.getOffsetToData());
				PeUtils.createData(program, dataAddr, data.toDataType(), log);
			}

			ResourceDirectoryStringU string = entry.getDirectoryString();
			if (string != null && string.getLength() > 0) {
				Address strAddr = resourceBase.add(entry.getNameOffset() & 0x7fffffff);
				PeUtils.createData(program, strAddr, string.toDataType(), log);
			}
		}
	}

	@Override
	public boolean parse() throws IOException {
		int ptr = getPointer();
		if (ptr < 0) {
			return false;
		}
		int resourceBase = ptr;

		rootDirectory = new ResourceDirectory(reader, ptr, resourceBase, true, ntHeader);
		return true;
	}

	//parse Dialog data type to pull out nice header comment
	private String setExtraCommentForDialogResource(Data data) throws MemoryAccessException {

		final String[] afterTemplate = { "Menu", "Class", "Title", "Font Size", "Font Name" };
		final String[] templateType0 = { "None", "Predefined", "None" };
		final String[] afterItem = { "Class", "Title", "Data" };

		//just need this to use a method from the class
		DialogResourceDataType temp = new DialogResourceDataType();

		DumbMemBufferImpl buffer = new DumbMemBufferImpl(data.getMemory(), data.getAddress());

		StringBuilder comment = new StringBuilder();
		if (data.getBaseDataType().getName().equals("DialogResource")) {

			int offset = 0;
			//get first structure
			Data componentAt = data.getComponentAt(offset);
			if (componentAt.isStructure() &&
				componentAt.getBaseDataType().getName().equals("DLGTEMPLATE")) {

				//determine if 3 or 5 components after initial structure
				int numAfter = 3;
				if ((buffer.getByte(0) & 0x40) > 0) {
					numAfter += 2;
				}

				int numItems = buffer.getShort(offset + 8);
				int currentItem = 0;
				comment.append("\nNumber of Items in Dialog: " + numItems);

				//get three or five components after initial structure
				for (int i = 0; i < numAfter; i++) {
					offset += componentAt.getLength();
					componentAt = data.getComponentAt(offset);
					comment.append("\n" + afterTemplate[i] + ": ");
					if (componentAt.getBaseDataType().getName().equals("short")) {
						comment.append(componentAt.getDefaultValueRepresentation());
					}
					if (componentAt.getBaseDataType().getName().equals("short[1]")) {
						if (buffer.getShort(offset) == 0x0000) {
							comment.append(templateType0[i]);
						}
					}
					if (componentAt.getBaseDataType().getName().equals("short[2]")) {
						if ((buffer.getShort(offset) & 0xffff) == 0xffff) {
							int ordinal = buffer.getShort(offset + 2);
							comment.append("External Ordinal Number " + ordinal);
						}
					}

					if (componentAt.getBaseDataType().getName().equals("unicode")) {
						comment.append(
							fixupStringRepForDisplay(componentAt.getDefaultValueRepresentation()));
					}
				}
				//loop over item structures
				comment.append("\n");
				while (currentItem < numItems) {
					offset += componentAt.getLength();
					componentAt = data.getComponentAt(offset);
					if (componentAt.getBaseDataType().getName().equals("DLGITEMTEMPLATE")) {
						currentItem++;
						comment.append("\nItem " + currentItem + ": ");
						//loop over three items after each item structure
						for (int i = 0; i < 3; i++) {
							offset += componentAt.getLength();
							componentAt = data.getComponentAt(offset);
							comment.append("\n   " + afterItem[i] + ": ");
							if (componentAt.getBaseDataType().getName().startsWith("short[")) {
								//no other info
								if (buffer.getShort(offset) == 0x0000) {
									comment.append("None");
								}
								//followed by ordinal
								else if ((buffer.getShort(offset) & 0xffff) == 0xffff) {
									int ordinal = buffer.getShort(offset + 2);
									comment.append(temp.getItemType(ordinal));
								}
								//first item is size array
								else {
									int sizeArray = buffer.getShort(offset);
									comment.append(
										"Size " + sizeArray + " (see internals of structure)");
								}
							}

							if (componentAt.getBaseDataType().getName().equals("unicode")) {
								comment.append(fixupStringRepForDisplay(
									componentAt.getDefaultValueRepresentation()));
							}
						}
					}

				}
			}

		}
		return comment.toString();

	}

	private String fixupStringRepForDisplay(String s) {
		// fixup the formatted string before embedding in PE loader artifacts
		// typically var s will look like u"blahblah".  Result will be "blahblah".
		return s.startsWith("u\"") || s.startsWith("U\"") ? s.substring(1 /* skip the leading 'u'*/)
				: s;
	}

	//parse Dialog data type to pull out nice header comment
	private String setExtraCommentForMenuResource(Data data) throws MemoryAccessException {

		short MF_POPUP = 0x0010;
		short LAST = 0x0090;

		DumbMemBufferImpl buffer = new DumbMemBufferImpl(data.getMemory(), data.getAddress());

		StringBuilder comment = new StringBuilder();
		if (data.getBaseDataType().getName().equals("MenuResource")) {

			//get first structure

			int numComponents = data.getNumComponents();
			boolean topLevel = false;
			for (int i = 0; i < numComponents; i++) {
				DataType dt = data.getComponent(i).getBaseDataType();
				int offset = data.getComponent(i).getRootOffset();

				if (dt.getName().equals("MENUITEM_TEMPLATE_HEADER")) {

					int version = buffer.getShort(offset);
					if (version != 0x0000) {
						return null;
					}

					int menuItemOffset = buffer.getShort(offset + 2);
					if (menuItemOffset < 0) {
						return null;
					}

				}
				if (dt.getName().equals("word")) {
					short option = buffer.getShort(offset);

					if (option == MF_POPUP) {
						topLevel = true; //this type has no mtID to skip
					}
					else if (option == LAST) {
						topLevel = true;
						i++; //skip the mtID
					}
					else {
						topLevel = false;
						i++; //skip the mtID
					}
				}
				if (dt.getName().equals("unicode")) {
					if (topLevel) {
						comment.append("\n");
					}
					else {
						comment.append("  ");
					}

					String menuString = fixupStringRepForDisplay(
						data.getComponentAt(offset).getDefaultValueRepresentation());
					menuString = menuString.replaceAll("\"", "");
					if (menuString.equals("")) {
						comment.append("-------------------\n");
					}
					else {
						comment.append(menuString + "\n");
					}
				}

			}

		}
		return comment.toString();

	}

	public List<ResourceInfo> getResources() {
		ArrayList<ResourceInfo> resources = new ArrayList<>();

		List<ResourceDirectoryEntry> entries = rootDirectory.getEntries();
		for (ResourceDirectoryEntry entry : entries) {
			List<ResourceInfo> entryResources = entry.getResources(0);
			for (ResourceInfo info : entryResources) {
				info.setName("Rsrc_" + info.getName());
				resources.add(info);
			}
		}

		Collections.sort(resources);

		return resources;
	}

	@Override
	public String toString() {
		StringBuffer buff = new StringBuffer();
		if (hasParsed) {
			buff.append("\t\t" + "Resource Directory: [" + super.toString() + "]" + "\n");
			List<ResourceInfo> resources = getResources();
			for (ResourceInfo info : resources) {
				buff.append(
					"\t\t\t" + "0x" + Long.toHexString(info.getAddress()) + "  " + info.getName() +
						"  Size: 0x" + Integer.toHexString(info.getSize()) + " bytes" + "\n");
			}
		}
		return buff.toString();
	}

	/**
	 * @see ghidra.app.util.bin.StructConverter#toDataType()
	 */
	@Override
	public DataType toDataType() throws DuplicateNameException, IOException {
		return rootDirectory.toDataType();
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/RichHeader.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;
import java.io.RandomAccessFile;

import ghidra.app.util.bin.StructConverter;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.app.util.bin.format.Writeable;
import net.jubjubnest.minidump.contrib.pe.rich.RichHeaderRecord;
import ghidra.program.model.data.DataType;
import ghidra.util.DataConverter;

/**
 * The "Rich" header contains encoded metadata about the tool chain used to generate the binary.
 * This class decodes and writes the Rich header (if it exists).
 */
public class RichHeader implements StructConverter, Writeable {

	public final static int IMAGE_RICH_SIGNATURE = 0x68636952; // Rich
	public final static int IMAGE_DANS_SIGNATURE = 0x536E6144; // DanS
	public final static String NAME = "IMAGE_RICH_HEADER_2";

	private FactoryBundledWithBinaryReader reader;
	private RichTable table;

	/**
	 * Create and returns the Rich header found from the given reader.  The reader should be
	 * positioned directly after the DOS header.
	 * 
	 * @param reader The reader to read the PE with.
	 * @return The Rich header associated with the given reader.
	 */
	public static RichHeader createRichHeader(FactoryBundledWithBinaryReader reader) {
		RichHeader richHeader = (RichHeader) reader.getFactory().create(RichHeader.class);
		richHeader.initRichHeader(reader);
		return richHeader;
	}

	/**
	 * Do not directly call this constructor.
	 * <p>  
	 * Use {@link #createRichHeader(FactoryBundledWithBinaryReader)}
	 */
	public RichHeader() {
		// Constructor needs to exist, but shouldn't do anything.
	}

	private void initRichHeader(FactoryBundledWithBinaryReader binaryReader) {
		this.reader = binaryReader;
		parse();
	}

	private void parse() {

		long currPos = reader.getPointerIndex();

		table = new RichTable(reader);

		if (table.getSize() == 0) {
			reader.setPointerIndex(currPos);
			return;
		}

		reader.setPointerIndex(table.getOffset() + table.getSize());
	}

	/**
	 * Gets the offset of the Rich header.
	 * 
	 * @return the offset of the Rich header, or -1 if a Rich header was not found.
	 */
	public int getOffset() {
		return table == null ? -1 : (int) table.getOffset();
	}

	/**
	 * Gets the size of the Rich header.
	 * 
	 * @return the size of the Rich header.  Will be 0 if a Rich header was not found.
	 */
	public int getSize() {
		return table == null ? 0 : table.getSize();
	}

	/**
	 * Gets the Rich header mask.
	 * 
	 * @return the Rich header mask, or -1 if a Rich header was not found.
	 */
	public int getMask() {
		return table == null ? -1 : table.getMask();
	}

	/**
	 * Gets the Rich header records.
	 * 
	 * @return the Rich header records.  Could be empty if a Rich header was not found.
	 */
	public RichHeaderRecord[] getRecords() {
		return table == null ? new RichHeaderRecord[0] : table.getRecords();
	}

	@Override
	public DataType toDataType() {
		if (table.getSize() == 0) {
			return null;
		}
		return table.toDataType();
	}

	@Override
	public void write(RandomAccessFile raf, DataConverter dc) throws IOException {

		if (table != null) {
			raf.write(dc.getBytes(IMAGE_DANS_SIGNATURE));

			raf.write(dc.getBytes(table.getMask())); // 0 ^ mask
			raf.write(dc.getBytes(table.getMask())); // 0 ^ mask
			raf.write(dc.getBytes(table.getMask())); // 0 ^ mask

			for (RichHeaderRecord rec : table.getRecords()) {
				raf.write(dc.getBytes(rec.getCompId().getValue() ^ table.getMask()));
				raf.write(dc.getBytes(rec.getObjectCount() ^ table.getMask()));
			}

			raf.write(dc.getBytes(IMAGE_RICH_SIGNATURE));
			raf.write(dc.getBytes(table.getMask()));
		}
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/RichTable.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.rich.PERichTableDataType;
import net.jubjubnest.minidump.contrib.pe.rich.RichHeaderRecord;
import ghidra.program.model.data.DataType;
import ghidra.program.model.mem.MemBuffer;
import ghidra.program.model.mem.MemoryAccessException;

/**
 * Top level object model of the {@link RichHeader}.  Stores an array of
 * {@link RichHeaderRecord}.
 */
public class RichTable {

	private static int MAX_TABLE_SEARCH_COUNT = 100;

	private int mask;
	private long imageOffset;
	private int size;
	private RichHeaderRecord[] records = new RichHeaderRecord[0];

	public RichTable(MemBuffer buf) {
		parse(buf, 0);
	}

	public RichTable(BinaryReader reader) {
		parse(reader, reader.getPointerIndex());
	}

	private void parse(Object src, final long base) {
		boolean valid = false;

		long offset = base;
		long startOffset = offset;
		long endOffset = base;

		int nSignDwords = 0;

		try {

			// Scan forward looking for the Rich signature (or the PE signature, 
			// and we've gone too far) -- this sets the upper-bound (endOffset) of the table 
			for (int i = 0; i < MAX_TABLE_SEARCH_COUNT; i++, offset += 4) {
				int dw = readInt(src, offset);
				if (dw == RichHeader.IMAGE_RICH_SIGNATURE) {
					endOffset = offset + 8;// space for the signature and mask
					break;
				}
				if (dw == Constants.IMAGE_NT_SIGNATURE) {
					break;
				}
			}

			// Ensure we've determined the table-end
			if (endOffset != startOffset) {

				// The table mask follows; read it next
				offset += 4;
				mask = readInt(src, offset);

				// Now scan backwards until we find the DanS signature -- the lower-bound
				// of the table (startOffset);
				long _scanOffset = offset - 8;
				for (int i = 0; i < MAX_TABLE_SEARCH_COUNT; i--) {
					int dw = readInt(src, _scanOffset);
					if ((dw ^ mask) == RichHeader.IMAGE_DANS_SIGNATURE) {
						startOffset = (int) _scanOffset;
						nSignDwords++;
						valid = true;
						break;
					}
					_scanOffset -= 4;
					nSignDwords++;

					if (_scanOffset < base) {
						break;
					}
				}

				if (valid) {
					// Now that we know the bounds of the table, verify the padding bytes 
					offset = startOffset + 4;
					for (int i = 0; i < 3; i++, offset += 4) {
						int v = readInt(src, offset);
						if ((v ^ mask) != 0) {
							valid = false;
							break;
						}
					}
				}
			}

		}
		catch (IOException ioe) {
			valid = false;
		}

		if (!valid) {
			this.mask = -1;
			this.imageOffset = -1;
			this.size = 0;
			return;
		}

		// nSignDwords includes the 4 dwords of the header (DanS & padding dwords)...
		int numRecords = (nSignDwords / 2) - 2;

		this.imageOffset = startOffset;
		this.size = (int) (endOffset - imageOffset);

		records = new RichHeaderRecord[numRecords];

		offset = imageOffset + 16;// skip the DanS signature and padding dwords

		try {
			for (int i = 0; i < numRecords; i++) {

				int data1 = readInt(src, offset);
				int data2 = readInt(src, offset + 4);
				offset += 8;

				data1 ^= mask;
				data2 ^= mask;

				RichHeaderRecord rec = new RichHeaderRecord(i, data1, data2);

				records[i] = rec;
			}
		}
		catch (IOException ioe) {
			valid = false;
		}

		if (!valid) {
			records = new RichHeaderRecord[0];
			this.mask = -1;
			this.imageOffset = -1;
			this.size = 0;
			return;
		}

	}

	private static int readInt(Object src, long offset) throws IOException {
		if (src instanceof MemBuffer) {
			return readInt((MemBuffer) src, offset);
		}
		else if (src instanceof BinaryReader) {
			return readInt((BinaryReader) src, offset);
		}
		throw new IOException("Source must be a MemBuffer or BinaryReader");
	}

	private static int readInt(MemBuffer buf, long offset) throws IOException {
		try {
			return buf.getInt((int) offset) & 0xFFFFFFFF;
		}
		catch (MemoryAccessException mae) {
			throw new IOException(mae);
		}
	}

	private static int readInt(BinaryReader reader, long offset) throws IOException {
		return reader.readInt(offset) & 0xFFFFFFFF;
	}

	public RichHeaderRecord[] getRecords() {
		return records;
	}

	public long getOffset() {
		return imageOffset;
	}

	public int getMask() {
		return mask;
	}

	public int getSize() {
		return size;
	}

	@Override
	public String toString() {
		return RichHeader.NAME + "[mask=" + Integer.toHexString(mask) + "h, numRecords=" +
			records.length + "]";
	}

	public DataType toDataType() {
		return new PERichTableDataType();
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/SectionFlags.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.util.HashSet;
import java.util.Set;

public enum SectionFlags {

	IMAGE_SCN_TYPE_NO_PAD("IMAGE_SCN_TYPE_NO_PAD", 0x00000008, "The section should not be padded to the next boundary."),
	IMAGE_SCN_RESERVED_0001("IMAGE_SCN_RESERVED_0001", 0x00000010, "Reserved for future use."),
	IMAGE_SCN_CNT_CODE("IMAGE_SCN_CNT_CODE", 0x00000020, "The section contains executable code."),
	IMAGE_SCN_CNT_INITIALIZED_DATA("IMAGE_SCN_CNT_INITIALIZED_DATA", 0x00000040, "The section contains initialized data."),
	IMAGE_SCN_CNT_UNINITIALIZED_DATA("IMAGE_SCN_CNT_UNINITIALIZED_DATA", 0x00000080, "The section contains uninitialized data."),
	IMAGE_SCN_LNK_OTHER("IMAGE_SCN_LNK_OTHER", 0x00000100, "Reserved for future use."),
	IMAGE_SCN_LNK_INFO("IMAGE_SCN_LNK_INFO", 0x00000200, "The section contains comments or other information.This is valid for object files only."),
	IMAGE_SCN_RESERVED_0040("IMAGE_SCN_RESERVED_0040", 0x00000400, "Reserved for future use."),
	IMAGE_SCN_LNK_REMOVE("IMAGE_SCN_LNK_REMOVE", 0x00000800, "The section will not become part of the image. This is valid only for object files."),
	IMAGE_SCN_LNK_COMDAT("IMAGE_SCN_LNK_COMDAT", 0x00001000, "The section contains COMDAT data. This is valid only for object files."),
	IMAGE_SCN_GPREL("IMAGE_SCN_GPREL", 0x00008000, "The section contains data referenced through the global pointer (GP)."),
	IMAGE_SCN_MEM_PURGEABLE("IMAGE_SCN_MEM_PURGEABLE", 0x00020000, "Reserved for future use."),
	IMAGE_SCN_MEM_16BIT("IMAGE_SCN_MEM_16BIT", 0x00020000, "Reserved for future use."),
	IMAGE_SCN_MEM_LOCKED("IMAGE_SCN_MEM_LOCKED", 0x00040000, "Reserved for future use."),
	IMAGE_SCN_MEM_PRELOAD("IMAGE_SCN_MEM_PRELOAD", 0x00080000, "Reserved for future use."),
	IMAGE_SCN_ALIGN_1BYTES("IMAGE_SCN_ALIGN_1BYTES", 0x00100000, "Align data on a 1-byte boundary. Valid only for object files."),
	IMAGE_SCN_ALIGN_2BYTES("IMAGE_SCN_ALIGN_2BYTES", 0x00200000, "Align data on a 2-byte boundary. Valid only for object files."),
	IMAGE_SCN_ALIGN_4BYTES("IMAGE_SCN_ALIGN_4BYTES", 0x00300000, "Align data on a 4-byte boundary. Valid only for object files."),
	IMAGE_SCN_ALIGN_8BYTES("IMAGE_SCN_ALIGN_8BYTES", 0x00400000, "Align data on an 8-byte boundary. Valid only for object files."),
	IMAGE_SCN_ALIGN_16BYTES("IMAGE_SCN_ALIGN_16BYTES", 0x00500000, "Align data on a 16-byte boundary. Valid only for object files."),
	IMAGE_SCN_ALIGN_32BYTES("IMAGE_SCN_ALIGN_32BYTES", 0x00600000, "Align data on a 32-byte boundary. Valid only for object files."),
	IMAGE_SCN_ALIGN_64BYTES("IMAGE_SCN_ALIGN_64BYTES", 0x00700000, "Align data on a 64-byte boundary. Valid only for object files."),
	IMAGE_SCN_ALIGN_128BYTES("IMAGE_SCN_ALIGN_128BYTES", 0x00800000, "Align data on a 128-byte boundary. Valid only for object files."),
	IMAGE_SCN_ALIGN_256BYTES("IMAGE_SCN_ALIGN_256BYTES", 0x00900000, "Align data on a 256-byte boundary. Valid only for object files."),
	IMAGE_SCN_ALIGN_512BYTES("IMAGE_SCN_ALIGN_512BYTES", 0x00A00000, "Align data on a 512-byte boundary. Valid only for object files."),
	IMAGE_SCN_ALIGN_1024BYTES("IMAGE_SCN_ALIGN_1024BYTES", 0x00B00000, "Align data on a 1024-byte boundary. Valid only for object files."),
	IMAGE_SCN_ALIGN_2048BYTES("IMAGE_SCN_ALIGN_2048BYTES", 0x00C00000, "Align data on a 2048-byte boundary. Valid only for object files."),
	IMAGE_SCN_ALIGN_4096BYTES("IMAGE_SCN_ALIGN_4096BYTES", 0x00D00000, "Align data on a 4096-byte boundary. Valid only for object files."),
	IMAGE_SCN_ALIGN_8192BYTES("IMAGE_SCN_ALIGN_8192BYTES", 0x00E00000, "Align data on an 8192-byte boundary. Valid only for object files."),
	IMAGE_SCN_LNK_NRELOC_OVFL("IMAGE_SCN_LNK_NRELOC_OVFL", 0x01000000, "The section contains extended relocations."),
	IMAGE_SCN_MEM_DISCARDABLE("IMAGE_SCN_MEM_DISCARDABLE", 0x02000000, "The section can be discarded as needed."),
	IMAGE_SCN_MEM_NOT_CACHED("IMAGE_SCN_MEM_NOT_CACHED", 0x04000000, "The section cannot be cached."),
	IMAGE_SCN_MEM_NOT_PAGED("IMAGE_SCN_MEM_NOT_PAGED", 0x08000000, "The section is not pageable."),
	IMAGE_SCN_MEM_SHARED("IMAGE_SCN_MEM_SHARED", 0x10000000, "The section can be shared in memory."),
	IMAGE_SCN_MEM_EXECUTE("IMAGE_SCN_MEM_EXECUTE", 0x20000000, "The section can be executed as code."),
	IMAGE_SCN_MEM_READ("IMAGE_SCN_MEM_READ", 0x40000000, "The section can be read."),
	IMAGE_SCN_MEM_WRITE("IMAGE_SCN_MEM_WRITE", 0x80000000, "The section can be written to.");

	private final String alias;
	private final int mask;
	private final String description;

	private SectionFlags(String alias, int mask, String description) {
		this.alias = alias;
		this.mask = mask;
		this.description = description;
	}

	public String getAlias() {
		return alias;
	}

	public int getMask() {
		return mask;
	}

	public String getDescription() {
		return description;
	}

	public static Set<SectionFlags> resolveFlags(int value) {
		Set<SectionFlags> applied = new HashSet<>();
		for (SectionFlags ch : values()) {
			if ((ch.getMask() & value) == ch.getMask()) {
				applied.add(ch);
			}
		}
		return applied;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/SectionHeader.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.*;

import ghidra.app.util.bin.ByteArrayConverter;
import ghidra.app.util.bin.StructConverter;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.program.model.data.*;
import ghidra.program.model.mem.*;
import ghidra.util.Conv;
import ghidra.util.DataConverter;
import ghidra.util.exception.DuplicateNameException;
import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;
import net.jubjubnest.minidump.contrib.new_.ModuleBaseOffset32DataType;

/**
 * A class to the represent the IMAGE_SECTION_HEADER
 * struct as defined in <code>winnt.h</code>.
 * <br>
 * <pre>
 * typedef struct _IMAGE_SECTION_HEADER {
 *    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
 *    union {
 *            DWORD   PhysicalAddress;
 *            DWORD   VirtualSize;			// MANDATORY
 *    } Misc;
 *    DWORD   VirtualAddress;				// MANDATORY
 *    DWORD   SizeOfRawData;				// MANDATORY
 *    DWORD   PointerToRawData;				// MANDATORY
 *    DWORD   PointerToRelocations;
 *    DWORD   PointerToLinenumbers;
 *    WORD    NumberOfRelocations;
 *    WORD    NumberOfLinenumbers;
 *    DWORD   Characteristics;				// MANDATORY
 * } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; * 
 * </pre>
 * <br>
 * <code>#define IMAGE_SIZEOF_SECTION_HEADER 40</code> * 
 * 
 * 
 */
public class SectionHeader implements StructConverter, ByteArrayConverter {
	/**
	 * The name to use when converting into a structure data type.
	 */
	public final static String NAME = "IMAGE_SECTION_HEADER";
	/**
	 * The size of the section header short name.
	 */
	public final static int IMAGE_SIZEOF_SHORT_NAME = 8;
	/**
	 * The size of the section header.
	 */
	public final static int IMAGE_SIZEOF_SECTION_HEADER = 40;

//  public final static int IMAGE_SCN_TYPE_REG                   = 0x00000000;
//  public final static int IMAGE_SCN_TYPE_DSECT                 = 0x00000001;
//  public final static int IMAGE_SCN_TYPE_NOLOAD                = 0x00000002;
//  public final static int IMAGE_SCN_TYPE_GROUP                 = 0x00000004;
//  public final static int IMAGE_SCN_TYPE_NO_PAD                = 0x00000008;
//  public final static int IMAGE_SCN_TYPE_COPY                  = 0x00000010;
	/**
	 * Section contains code.
	 */
	public final static int IMAGE_SCN_CNT_CODE = 0x00000020;
	/**
	 * Section contains initialized data.
	 */
	public final static int IMAGE_SCN_CNT_INITIALIZED_DATA = 0x00000040;
	/**
	 * Section contains uninitialized data.
	 */
	public final static int IMAGE_SCN_CNT_UNINITIALIZED_DATA = 0x00000080;
//  public final static int IMAGE_SCN_LNK_OTHER                  = 0x00000100;
	/**
	 * Section contains information for use by the linker. 
	 * Only exists in OBJs.
	 */
	public final static int IMAGE_SCN_LNK_INFO = 0x00000200;
//  public final static int IMAGE_SCN_TYPE_OVER                  = 0x00000400;
	/**
	 * Section contents will not become part of the image. 
	 * This only appears in OBJ files.
	 */
	public final static int IMAGE_SCN_LNK_REMOVE = 0x00000800;
	/**
	 * Section contents is communal data (comdat). 
	 * Communal data is data (or code) that can be 
	 * defined in multiple OBJs. The linker will select 
	 * one copy to include in the executable. Comdats 
	 * are vital for support of C++ template functions 
	 * and function-level linking. Comdat sections only 
	 * appear in OBJ files.
	 */
	public final static int IMAGE_SCN_LNK_COMDAT = 0x00001000;
//  Reserved.                                                    = 0x00002000; 
//  public final static int IMAGE_SCN_MEM_PROTECTED - Obsolete   = 0x00004000;
	/**
	 * Reset speculative exceptions handling bits in the TLB entries for this section.
	 */
	public final static int IMAGE_SCN_NO_DEFER_SPEC_EXC = 0x00004000;
	/**
	 * Section content can be accessed relative to GP.
	 */
	public final static int IMAGE_SCN_GPREL = 0x00008000;
//  public final static int IMAGE_SCN_MEM_FARDATA                = 0x00008000;
//  public final static int IMAGE_SCN_MEM_SYSHEAP  - Obsolete    = 0x00010000;
//  public final static int IMAGE_SCN_MEM_PURGEABLE              = 0x00020000;
//  public final static int IMAGE_SCN_MEM_16BIT                  = 0x00020000;
//  public final static int IMAGE_SCN_MEM_LOCKED                 = 0x00040000;
//  public final static int IMAGE_SCN_MEM_PRELOAD                = 0x00080000;
	/**
	 * Align on 1-byte boundary.
	 */
	public final static int IMAGE_SCN_ALIGN_1BYTES = 0x00100000;
	/**
	 * Align on 2-byte boundary.
	 */
	public final static int IMAGE_SCN_ALIGN_2BYTES = 0x00200000;
	/**
	 * Align on 4-byte boundary.
	 */
	public final static int IMAGE_SCN_ALIGN_4BYTES = 0x00300000;
	/**
	 * Align on 8-byte boundary.
	 */
	public final static int IMAGE_SCN_ALIGN_8BYTES = 0x00400000;
	/**
	 * Align on 16-byte boundary.
	 */
	public final static int IMAGE_SCN_ALIGN_16BYTES = 0x00500000;
	/**
	 * Align on 32-byte boundary.
	 */
	public final static int IMAGE_SCN_ALIGN_32BYTES = 0x00600000;
	/**
	 * Align on 64-byte boundary.
	 */
	public final static int IMAGE_SCN_ALIGN_64BYTES = 0x00700000;
	/**
	 * Align on 128-byte boundary.
	 */
	public final static int IMAGE_SCN_ALIGN_128BYTES = 0x00800000;
	/**
	 * Align on 256-byte boundary.
	 */
	public final static int IMAGE_SCN_ALIGN_256BYTES = 0x00900000;
	/**
	 * Align on 512-byte boundary.
	 */
	public final static int IMAGE_SCN_ALIGN_512BYTES = 0x00A00000;
	/**
	 * Align on 1024-byte boundary.
	 */
	public final static int IMAGE_SCN_ALIGN_1024BYTES = 0x00B00000;
	/**
	 * Align on 2048-byte boundary.
	 */
	public final static int IMAGE_SCN_ALIGN_2048BYTES = 0x00C00000;
	/**
	 * Align on 4096-byte boundary.
	 */
	public final static int IMAGE_SCN_ALIGN_4096BYTES = 0x00D00000;
	/**
	 * Align on 8192-byte boundary.
	 */
	public final static int IMAGE_SCN_ALIGN_8192BYTES = 0x00E00000;
//  Unused                                                       = 0x00F00000;
//  public final static int IMAGE_SCN_ALIGN_MASK                 = 0x00F00000;
	/**
	 * Section contains extended relocations.
	 */
	public final static int IMAGE_SCN_LNK_NRELOC_OVFL = 0x01000000;
	/**
	 * The section can be discarded from the final executable. 
	 * Used to hold information for the linker's use, 
	 * including the .debug$ sections.
	 */
	public final static int IMAGE_SCN_MEM_DISCARDABLE = 0x02000000;
	/**
	 * Section is not cachable.
	 */
	public final static int IMAGE_SCN_MEM_NOT_CACHED = 0x04000000;
	/**
	 * The section is not pageable, so it should 
	 * always be physically present in memory. 
	 * Often used for kernel-mode drivers.
	 */
	public final static int IMAGE_SCN_MEM_NOT_PAGED = 0x08000000;
	/**
	 * Section is shareable. The physical pages containing this 
	 * section's data will be shared between all processes 
	 * that have this executable loaded. Thus, every process 
	 * will see the exact same values for data in this section. 
	 * Useful for making global variables shared between all 
	 * instances of a process. To make a section shared, 
	 * use the /section:name,S linker switch.
	 */
	public final static int IMAGE_SCN_MEM_SHARED = 0x10000000;
	/**
	 * Section is executable.
	 */
	public final static int IMAGE_SCN_MEM_EXECUTE = 0x20000000;
	/**
	 * Section is readable.
	 */
	public final static int IMAGE_SCN_MEM_READ = 0x40000000;
	/**
	 * Section is writeable.
	 */
	public final static int IMAGE_SCN_MEM_WRITE = 0x80000000;

	public final static int NOT_SET = -1;

	private String name;
	private int physicalAddress;
	private int virtualSize;
	private int virtualAddress;
	private int sizeOfRawData;
	private int pointerToRawData;
	private int pointerToRelocations;
	private int pointerToLinenumbers;
	private short numberOfRelocations;
	private short numberOfLinenumbers;
	private int characteristics;

	private FactoryBundledWithBinaryReader reader;
	private long index;
	private ImageLoadInfo loadInfo;

	static SectionHeader createSectionHeader(FactoryBundledWithBinaryReader reader, ImageLoadInfo loadInfo, long index)
			throws IOException {
		SectionHeader sectionHeader =
			(SectionHeader) reader.getFactory().create(SectionHeader.class);
		sectionHeader.initSectionHeader(reader, loadInfo, index);
		return sectionHeader;
	}

	/**
	 * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
	 */
	public SectionHeader() {
	}

	private void initSectionHeader(FactoryBundledWithBinaryReader reader, ImageLoadInfo loadInfo, long index)
			throws IOException {
		this.reader = reader;
		this.index = index;
		this.loadInfo = loadInfo;

		parse();
	}

	SectionHeader(MemoryBlock block, OptionalHeader optHeader, int ptr) {
		name = block.getName();
		physicalAddress = virtualSize = (int) block.getSize();
		virtualAddress = (int) block.getStart().getOffset() - (int) optHeader.getImageBase();
		sizeOfRawData =
			PortableExecutable.computeAlignment(virtualSize, optHeader.getFileAlignment());
		pointerToRawData = ptr;
		pointerToLinenumbers = 0;
		pointerToRelocations = 0;
		numberOfLinenumbers = 0;
		numberOfRelocations = 0;
		characteristics = 0;
		if (block.isRead()) {
			characteristics |= SectionFlags.IMAGE_SCN_MEM_READ.getMask();
		}
		if (block.isWrite()) {
			characteristics |= SectionFlags.IMAGE_SCN_MEM_WRITE.getMask();
		}
		if (block.isExecute()) {
			characteristics |= SectionFlags.IMAGE_SCN_MEM_EXECUTE.getMask() |
				SectionFlags.IMAGE_SCN_CNT_CODE.getMask();
		}
		if (block.isExecute()) {
			characteristics |=
				SectionHeader.IMAGE_SCN_MEM_EXECUTE | SectionHeader.IMAGE_SCN_CNT_CODE;
		}
		else if (block.getType() == MemoryBlockType.DEFAULT) {//not executable, then must be data...
			if (block.isInitialized()) {
				characteristics |= SectionFlags.IMAGE_SCN_CNT_INITIALIZED_DATA.getMask();
			}
			else {
				characteristics |= SectionFlags.IMAGE_SCN_CNT_UNINITIALIZED_DATA.getMask();
			}
		}
	}

	/**
	 * Returns the ASCII name of the section. A 
	 * section name is not guaranteed to be 
	 * null-terminated. If you specify a section name 
	 * longer than eight characters, the linker 
	 * truncates it to eight characters in the 
	 * executable. A mechanism exists for allowing 
	 * longer section names in OBJ files. Section 
	 * names often start with a period, but this is 
	 * not a requirement. Section names with a $ in 
	 * the name get special treatment from the linker. 
	 * Sections with identical names prior to the $ 
	 * character are merged. The characters following 
	 * the $ provide an alphabetic ordering for how the 
	 * merged sections appear in the final section. 
	 * There's quite a bit more to the subject of sections 
	 * with $ in the name and how they're combined, but 
	 * the details are outside the scope of this article
	 * 
	 * @return the ASCII name of the section
	 */
	public String getName() {
		return name;
	}

	/**
	 * Returns a readable ascii version of the name.
	 * All non-readable characters
	 * are replaced with underscores.
	 * @return a readable ascii version of the name
	 */
	public String getReadableName() {
		StringBuffer buffer = new StringBuffer();
		for (int i = 0; i < name.length(); ++i) {
			char ch = name.charAt(i);
			if (ch >= 0x20 && ch <= 0x7e) {//is readable ascii?
				buffer.append(ch);
			}
			else {
				buffer.append('_');
			}
		}
		return buffer.toString();
	}

	/**
	 * Returns the physical (file) address of this section.
	 * @return the physical (file) address of this section
	 */
	public int getPhysicalAddress() {
		return physicalAddress;
	}

	/**
	 * In executables, returns the RVA where 
	 * the section begins in memory. Should be set to 0 in OBJs.
	 * this section should be loaded into memory.
	 * @return the RVA where the section begins in memory.
	 */
	public int getVirtualAddress() {
		return virtualAddress;
	}

	/**
	 * Returns the actual, used size of the section. 
	 * This field may be larger or 
	 * smaller than the SizeOfRawData field. 
	 * If the VirtualSize is larger, the 
	 * SizeOfRawData field is the size of the 
	 * initialized data from the executable, 
	 * and the remaining bytes up to the VirtualSize 
	 * should be zero-padded. This field is set 
	 * to 0 in OBJ files.
	 * @return the actual, used size of the section
	 */
	public int getVirtualSize() {
		if (virtualSize == 0) {
			return sizeOfRawData;
		}
		return virtualSize;
	}

	/**
	 * Returns the size (in bytes) of data stored for the section 
	 * in the executable or OBJ. 
	 * @return the size (in bytes) of data stored for the section
	 */
	public int getSizeOfRawData() {
		return sizeOfRawData;
	}

	/**
	 * Returns the file offset where the data 
	 * for the section begins. For executables, 
	 * this value must be a multiple of the file 
	 * alignment given in the PE header.
	 * <p>
	 * If a section is uninitialized, this value will be 0.
	 * 
	 * @return the file offset where the data for the section begins
	 */
	public int getPointerToRawData() {
		if (pointerToRawData < 0x200) {
			return 0;
		}
		return pointerToRawData;
	}

	/**
	 * Returns the file offset of relocations for this section. 
	 * @return the file offset of relocations for this section
	 */
	public int getPointerToRelocations() {
		return pointerToRelocations;
	}

	/**
	 * Returns the number of relocations pointed 
	 * to by the PointerToRelocations field. 
	 * @return the number of relocations
	 */
	public short getNumberOfRelocations() {
		return numberOfRelocations;
	}

	/**
	 * Return the file offset for COFF-style line 
	 * numbers for this section. 
	 * @return the file offset for COFF-style line numbers for this section
	 */
	public int getPointerToLinenumbers() {
		return pointerToLinenumbers;
	}

	/**
	 * Returns the flags OR'ed together, indicating the 
	 * attributes of this section. Many of these flags 
	 * can be set with the linker's /SECTION option. 
	 * Common values include those listed in Figure 7.
	 * @return the flags OR'ed together, indicating the attributes of this section
	 */
	public int getCharacteristics() {
		return characteristics;
	}

	/**
	 * Returns the number of line numbers pointed to by the 
	 * NumberOfRelocations field. 
	 * @return the number of line numbers
	 */
	public short getNumberOfLinenumbers() {
		return numberOfLinenumbers;
	}

	@Override
	public byte[] toBytes(DataConverter dc) throws IOException {
		return reader.readByteArray(getPointerToRawData(), getSizeOfRawData());
	}

	/**
	 * Returns an input stream to underlying bytes of this section.
	 * @return an input stream to underlying bytes of this section
	 * @throws IOException if an i/o error occurs.
	 */
	public InputStream getDataStream() throws IOException {
		return reader.getByteProvider().getInputStream(getPointerToRawData());
	}

	/**
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		StringBuffer buff = new StringBuffer();

		buff.append("Section Header:" + "\n");
		buff.append("\t" + "name:                 " + name + "\n");
		buff.append("\t" + "physicalAddress:      " + Integer.toHexString(physicalAddress) + "\n");
		buff.append("\t" + "virtualSize:          " + Integer.toHexString(virtualSize) + "\n");
		buff.append("\t" + "virtualAddress:       " + Integer.toHexString(virtualAddress) + "\n");
		buff.append("\t" + "sizeOfRawData:        " + Integer.toHexString(sizeOfRawData) + "\n");
		buff.append("\t" + "pointerToRawData:     " + Integer.toHexString(pointerToRawData) + "\n");
		buff.append(
			"\t" + "pointerToRelocations: " + Integer.toHexString(pointerToRelocations) + "\n");
		buff.append(
			"\t" + "pointerToLinenumbers: " + Integer.toHexString(pointerToLinenumbers) + "\n");
		buff.append(
			"\t" + "numberOfRelocations:  " + Integer.toHexString(numberOfRelocations) + "\n");
		buff.append(
			"\t" + "numberOfLinenumbers:  " + Integer.toHexString(numberOfLinenumbers) + "\n");
		buff.append("\t" + "characteristics:      " + Integer.toHexString(characteristics) + "\n");

		return buff.toString();
	}

	private void parse() throws IOException {
		name = reader.readAsciiString(index, IMAGE_SIZEOF_SHORT_NAME).trim();

		// we need to skip IMAGE_SIZEOF_SHORT_NAME chars no matter what,
		// since those bytes are always allocated
		reader.setPointerIndex(index + IMAGE_SIZEOF_SHORT_NAME);

		physicalAddress = virtualSize = reader.readNextInt();
		virtualAddress = reader.readNextInt();
		sizeOfRawData = reader.readNextInt();
		pointerToRawData = reader.readNextInt();
		pointerToRelocations = reader.readNextInt();
		pointerToLinenumbers = reader.readNextInt();
		numberOfRelocations = reader.readNextShort();
		numberOfLinenumbers = reader.readNextShort();
		characteristics = reader.readNextInt();
	}

	@Override
	public DataType toDataType() throws DuplicateNameException {
		DataType xbo32 = loadInfo.sharedProgram ? new ModuleBaseOffset32DataType() : IBO32;

		UnionDataType union = new UnionDataType("Misc");
		union.add(DWORD, "PhysicalAddress", null);
		union.add(DWORD, "VirtualSize", null);
		union.setCategoryPath(new CategoryPath("/PE"));

		StructureDataType struct = new StructureDataType(NAME, 0);
		struct.add(new ArrayDataType(ASCII, 8, 1), "Name", null);
		struct.add(union, "Misc", null);
		struct.add(xbo32, "VirtualAddress", null);
		struct.add(DWORD, "SizeOfRawData", null);
		struct.add(DWORD, "PointerToRawData", null);
		struct.add(DWORD, "PointerToRelocations", null);
		struct.add(DWORD, "PointerToLinenumbers", null);
		struct.add(WORD, "NumberOfRelocations", null);
		struct.add(WORD, "NumberOfLinenumbers", null);
		EnumDataType characteristicsEnum = new EnumDataType("SectionFlags", 4);
		characteristicsEnum.setCategoryPath(new CategoryPath("/PE"));
		for (SectionFlags flag : SectionFlags.values()) {
			characteristicsEnum.add(flag.name(), Conv.intToLong(flag.getMask()));
		}
		struct.add(characteristicsEnum, "Characteristics", null);
		struct.setCategoryPath(new CategoryPath("/PE"));
		return struct;
	}

	/**
	 * Writes this section header to the specified random access file. 
	 * @param raf the random access file
	 * @param dc  the data converter
	 * @throws IOException if an I/O error occurs
	 */
	public void writeHeader(RandomAccessFile raf, DataConverter dc) throws IOException {
		byte[] paddedName = new byte[IMAGE_SIZEOF_SHORT_NAME];
		byte[] nameBytes = name.getBytes();
		System.arraycopy(nameBytes, 0, paddedName, 0,
			Math.min(nameBytes.length, IMAGE_SIZEOF_SHORT_NAME));

		raf.write(paddedName);
		raf.write(dc.getBytes(virtualSize));
		raf.write(dc.getBytes(virtualAddress));
		raf.write(dc.getBytes(sizeOfRawData));
		raf.write(dc.getBytes(pointerToRawData));
		raf.write(dc.getBytes(pointerToRelocations));
		raf.write(dc.getBytes(pointerToLinenumbers));
		raf.write(dc.getBytes(numberOfRelocations));
		raf.write(dc.getBytes(numberOfLinenumbers));
		raf.write(dc.getBytes(characteristics));
	}

	/**
	 * Writes the bytes from this section into the specified random access file.
	 * The bytes will be written starting at the byte position
	 * specified by <code>getPointerToRawData()</code>.
	 * 
	 * @param raf           the random access file
	 * @param rafIndex      the index into the RAF where the bytes will be written
	 * @param dc            the data converter
	 * @param block         the memory block corresponding to this section
	 * @param useBlockBytes if true, then use the bytes from the memory block, 
	 *                      otherwise use the bytes from this section.
	 *  
	 * @throws IOException if there are errors writing to the file
	 * @throws MemoryAccessException if the byte from the memory block cannot be accesses
	 */
	public void writeBytes(RandomAccessFile raf, int rafIndex, DataConverter dc, MemoryBlock block,
			boolean useBlockBytes) throws IOException, MemoryAccessException {

		if (getSizeOfRawData() == 0) {
			return;
		}

		raf.seek(rafIndex);

		//if ((block.getType() == MemoryBlock.INITIALIZED) || (block.getType() == MemoryBlock.LIVE)) {

		if (useBlockBytes) {
			byte[] blockBytes = new byte[(int) block.getSize()];
			block.getBytes(block.getStart(), blockBytes);
			raf.write(blockBytes);
		}
		else {
			raf.write(toBytes(dc));
		}

		int padLength = getSizeOfRawData() - getVirtualSize();
		if (padLength > 0) {
			raf.write(new byte[padLength]);
		}
		//}
	}

	void updatePointers(int offset) {
		if (pointerToRawData > 0) {
			pointerToRawData += offset;
		}
		if (pointerToRelocations > 0) {
			pointerToRelocations += offset;
		}
		if (pointerToLinenumbers > 0) {
			pointerToLinenumbers += offset;
		}
	}

	public void setVirtualSize(int size) {
		this.virtualSize = size;
	}

	public void setSizeOfRawData(int size) {
		this.sizeOfRawData = size;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/SecurityCertificate.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.StructConverter;
import ghidra.program.model.data.*;
import ghidra.util.NumericUtilities;
import ghidra.util.exception.DuplicateNameException;

/**
 * A class to represent the <code>WIN_CERTIFICATE</code>
 * struct as defined in <b><code>winbase.h</code></b>.
 * <p>
 * This structure encapsulates a signature used in verifying executables.
 * <p>
 * <pre>
 * typedef struct _WIN_CERTIFICATE {
 *     DWORD       dwLength;
 *     WORD        wRevision;
 *     WORD        wCertificateType;   // WIN_CERT_TYPE_xxx
 *     BYTE        bCertificate[ANYSIZE_ARRAY];
 * } WIN_CERTIFICATE, *LPWIN_CERTIFICATE;
 * </pre> 
 * 
 * 
 */
public class SecurityCertificate implements StructConverter {
	/**
	 * The name to use when converting into a structure data type.
	 */
	public final static String NAME = "WIN_CERTIFICATE";

    //
    // Currently, the only defined certificate revision is WIN_CERT_REVISION_1_0
    //
    public final static int WIN_CERT_REVISION_1_0 = 0x0100;
    public final static int WIN_CERT_REVISION_2_0 = 0x0200;

    //
    // Possible certificate types are specified by the following values
    //
    /**
     * bCertificate contains an X.509 Certificate.
     */
    public final static int WIN_CERT_TYPE_X509             = 0x0001;
    /**
     * bCertificate contains a PKCS SignedData structure.
     */
    public final static int WIN_CERT_TYPE_PKCS_SIGNED_DATA = 0x0002;
    /**
     * Reserved.
     */
    public final static int WIN_CERT_TYPE_RESERVED_1       = 0x0003;
    /**
     * bCertificate contains PKCS1_MODULE_SIGN fields.
     */
    public final static int WIN_CERT_TYPE_PKCS1_SIGN      = 0x0009;

    private int dwLength;
    private short wRevision;
    private short wCertificateType;
    private byte [] bCertificate;

	/**
	 * Read a SecurityCertificate.
	 * 
	 * @param reader BinaryReader to use
	 * @param index offset where the SecurityCertificate starts
	 * @param sizeLimit maximum number of bytes that can be read from the reader
	 * @return new SecurityCertificate, or null if invalid or bad data
	 * @throws IOException if io error when reading data
	 */
	static SecurityCertificate read(BinaryReader reader, long index, int sizeLimit)
			throws IOException {
		if (sizeLimit < 8) {
			return null;
		}
		reader = reader.clone(index);

		SecurityCertificate result = new SecurityCertificate();
		result.dwLength = reader.readNextInt();
		result.wRevision = reader.readNextShort();
		result.wCertificateType = reader.readNextShort();

		if (result.dwLength < 8 || sizeLimit < result.dwLength) {
			return null;
		}

		int certByteCount = result.dwLength - 4 - 2 - 2;
		result.bCertificate = reader.readNextByteArray(certByteCount);

		return result;
	}

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public SecurityCertificate() {}

	int getNumberOfBytesConsumed() {
		return (int) NumericUtilities.getUnsignedAlignedValue(dwLength, 8);
	}

	/**
	 * Returns the length, in bytes, of the signature.
	 * @return the length, in bytes, of the signature
	 */
    public int getLength() {
        return dwLength;
    }

	/**
	 * Returns the certificate revision. Currently, 
	 * the only defined certificate revision is 
	 * WIN_CERT_REVISION_1_0 (0x0100). 
	 * @return the certificate revision
	 */
    public int getRevision() {
        return wRevision;
    }

	/**
	 * Returns the certificate type.
	 * @return the certificate type
	 */
    public int getType()  {
        return wCertificateType;
    }

	/**
	 * Returns a string representation of the certificate type.
	 * @return a string representation of the certificate type
	 */
    public String getTypeAsString() {
        switch (wCertificateType) {
            case WIN_CERT_TYPE_X509:
                return "X.509";
            case WIN_CERT_TYPE_PKCS_SIGNED_DATA:
                return "PKCS Signed";
//todo:
//locate...
//            case WIN_CERT_TYPE_TS_STACK_SIGNED:
//                return "TS Stack Signed";
            case WIN_CERT_TYPE_RESERVED_1:
                return "Reserved";
            default:
                return "Unknown Certificate Type";
        }
    }

	/**
	 * An array of certificates. The format of this member 
	 * depends on the value of wCertificateType.
	 * @return an array of certificates
	 */
    public byte [] getData() {
        return bCertificate;
    }

    /**
     * @see ghidra.app.util.bin.StructConverter#toDataType()
     */
    @Override
	public DataType toDataType() throws DuplicateNameException {
        StructureDataType struct = new StructureDataType(NAME+"_"+dwLength, 0);
        struct.add(DWORD,"dwLength",null);
        struct.add( WORD,"wRevision",null);
        struct.add( WORD,"wCertificateType",getTypeAsString());

        if ( bCertificate != null && bCertificate.length > 0 ) {
	    	DataType array = new ArrayDataType(BYTE, bCertificate.length, 1);
	        struct.add(array,"bCertificate",null);
        }

        struct.setCategoryPath(new CategoryPath("/PE"));
        return struct;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/SecurityDataDirectory.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.ArrayList;
import java.util.List;

import ghidra.app.util.bin.ByteArrayConverter;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressSpace;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Program;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.DataConverter;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;
import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;

// See https://docs.microsoft.com/en-us/windows/desktop/debug/pe-format

public class SecurityDataDirectory extends DataDirectory implements ByteArrayConverter {
    private final static String NAME = "IMAGE_DIRECTORY_ENTRY_SECURITY";

    private SecurityCertificate [] certificates;

    static SecurityDataDirectory createSecurityDataDirectory(
            NTHeader ntHeader, FactoryBundledWithBinaryReader reader)
            throws IOException {
        SecurityDataDirectory securityDataDirectory = (SecurityDataDirectory) reader.getFactory().create(SecurityDataDirectory.class);
        securityDataDirectory.initSecurityDataDirectory(ntHeader, reader);
        return securityDataDirectory;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public SecurityDataDirectory() {}

	private void initSecurityDataDirectory(NTHeader ntHeader, FactoryBundledWithBinaryReader reader) throws IOException {
		processDataDirectory(ntHeader, reader);

        if (certificates == null) {
			certificates = new SecurityCertificate[0];
		}
	}

	/**
	 * Returns an array of security certificates.
	 * @return an array of security certificates
	 */
	public SecurityCertificate [] getCertificate() {
		return certificates;
	}

	@Override
	public String getDirectoryName() {
		return NAME;
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor,
			MessageLog log, NTHeader ntHeader) throws DuplicateNameException, CodeUnitInsertionException,
			DataTypeConflictException, IOException {

		if (!isBinary) {//certificates are never mapped into running program...
			return;
		}

		monitor.setMessage(program.getName()+": security data...");

		AddressSpace space = program.getAddressFactory().getDefaultAddressSpace();
		Address addr = space.getAddress(virtualAddress);//NOTE: virtualAddress is only a binary offset inside file!!!

		createDirectoryBookmark(program, addr);

		program.getListing().clearCodeUnits(addr, addr, false);

		for (SecurityCertificate cert : certificates) {
			DataType dt = cert.toDataType();
			program.getListing().createData(addr, dt);
			addr = addr.add(dt.getLength());
		}
	}

	@Override
	public boolean parse() throws IOException {
		List<SecurityCertificate> list = new ArrayList<>();

        // Sanity check...
        // Sometimes the cert address is not valid

        if (!reader.isValidIndex(getVirtualAddress())) {
            Msg.warn(this, "Certificate address is not valid.");
            return false;
        }

        // Note:
        // This data directory entry gives a file offset rather than an RVA

        int certOffset = getVirtualAddress();
        int certSize   = getSize();
		if (certOffset + certSize > reader.length()) {
			Msg.warn(this, "Certificate length " + certSize + " exceeds EOF.");
			return false;
		}

        while (certSize > 0 && certSize < NTHeader.MAX_SANE_COUNT) {
			SecurityCertificate cert = SecurityCertificate.read(reader, certOffset, certSize);
			if (cert == null) {
            	return false;
            }
            list.add(cert);

			int certBytesUsed = cert.getNumberOfBytesConsumed();
			certOffset += certBytesUsed;
			certSize -= certBytesUsed;
        }

        certificates = new SecurityCertificate[list.size()];
        list.toArray(certificates);
        return true;
    }
	
    /**
     * @see ghidra.app.util.bin.StructConverter#toDataType()
     */
    @Override
    public DataType toDataType() throws DuplicateNameException {
        StructureDataType struct = new StructureDataType(NAME, 0);
        for (SecurityCertificate certificate : certificates) {
            struct.add(certificate.toDataType());
        }
        struct.setCategoryPath(new CategoryPath("/PE"));
        return struct;
    }

	/**
	 * @see ghidra.app.util.bin.ByteArrayConverter#toBytes(ghidra.util.DataConverter)
	 */
	@Override
	public byte [] toBytes(DataConverter dc) {
		try {
			return reader.readByteArray( virtualAddress, size );
		}
		catch ( IOException e) {
		}
		return new byte[size];//TODO: need to implement!
	}

	/**
	 * @see net.jubjubnest.minidump.contrib.pe.DataDirectory#writeBytes(java.io.RandomAccessFile, ghidra.util.DataConverter, ghidra.app.util.bin.format.pe.PortableExecutable)
	 */
	@Override
    public void writeBytes(RandomAccessFile raf, DataConverter dc, PortableExecutable template) 
		throws IOException {

		if (size == 0) {
			return;
		}

		DataDirectory [] originalDataDirs = template.getNTHeader().getOptionalHeader().getDataDirectories();
		if (originalDataDirs.length > OptionalHeader.IMAGE_DIRECTORY_ENTRY_SECURITY) {
			if (originalDataDirs[OptionalHeader.IMAGE_DIRECTORY_ENTRY_SECURITY] == null || 
				originalDataDirs[OptionalHeader.IMAGE_DIRECTORY_ENTRY_SECURITY].getSize() == 0) {
				return;
			}
		}

		if (originalDataDirs.length > OptionalHeader.IMAGE_DIRECTORY_ENTRY_SECURITY) {
			SecurityDataDirectory originalSDD = (SecurityDataDirectory)originalDataDirs[OptionalHeader.IMAGE_DIRECTORY_ENTRY_SECURITY];
			raf.seek(rvaToPointer());
			raf.write(originalSDD.toBytes(dc));
		}
	}

	@Override
    int rvaToPointer() {
		return virtualAddress;
	}

	void updatePointers(int offset) {
		virtualAddress += offset;
	}

	/**
	 * virtualAddress is always a binary offset
	 */
	public Address getMarkupAddress(Program program, boolean isBinary) {
		AddressSpace space = program.getAddressFactory().getDefaultAddressSpace();
		return space.getAddress( virtualAddress);
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/SeparateDebugHeader.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import generic.continues.GenericFactory;
import ghidra.app.util.bin.ByteProvider;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;
import net.jubjubnest.minidump.contrib.pe.debug.DebugDirectoryParser;
import ghidra.util.Conv;
import ghidra.util.Msg;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * <pre>
 * typedef struct _IMAGE_SEPARATE_DEBUG_HEADER {
 *     WORD        Signature;
 *     WORD        Flags;
 *     WORD        Machine;
 *     WORD        Characteristics;
 *     DWORD       TimeDateStamp;
 *     DWORD       CheckSum;
 *     DWORD       ImageBase;
 *     DWORD       SizeOfImage;
 *     DWORD       NumberOfSections;
 *     DWORD       ExportedNamesSize;
 *     DWORD       DebugDirectorySize;
 *     DWORD       SectionAlignment;
 *     DWORD       Reserved[2];
 * } IMAGE_SEPARATE_DEBUG_HEADER, *PIMAGE_SEPARATE_DEBUG_HEADER;
 * </pre> 
 * 
 * 
 */
public class SeparateDebugHeader implements OffsetValidator {
	/**
	 * The magic number for separate debug files.
	 */
	public final static int IMAGE_SEPARATE_DEBUG_SIGNATURE = 0x4944; //ID
	/**
	 * The magic number for separate debug files on MAC.
	 */
	public final static int IMAGE_SEPARATE_DEBUG_SIGNATURE_MAC = 0x4449; //DI

	private short signature;
	private short flags;
	private short machine;
	private short characteristics;
	private int timeDateStamp;
	private int checkSum;
	private int imageBase;
	private int sizeOfImage;
	private int numberOfSections;
	private int exportedNamesSize;
	private int debugDirectorySize;
	private int sectionAlignment;
	private int[] reserved = new int[2];

	private SectionHeader[] sections;
	private String[] exportedNames;
	private DebugDirectoryParser parser;

	/**
	 * Constructs a new separate debug header using the specified byte provider.
	 * @param bp the byte provider
	 * @throws IOException if an I/O error occurs.
	 */
	public SeparateDebugHeader(ImageLoadInfo loadInfo, GenericFactory factory, ByteProvider bp) throws IOException {
		FactoryBundledWithBinaryReader reader =
			new FactoryBundledWithBinaryReader(factory, bp, true);

		reader.setPointerIndex(0);

		signature = reader.readNextShort();

		if (signature != IMAGE_SEPARATE_DEBUG_SIGNATURE) {
			return;
		}

		flags = reader.readNextShort();
		machine = reader.readNextShort();
		characteristics = reader.readNextShort();
		timeDateStamp = reader.readNextInt();
		checkSum = reader.readNextInt();
		imageBase = reader.readNextInt();
		sizeOfImage = reader.readNextInt();
		numberOfSections = reader.readNextInt();
		exportedNamesSize = reader.readNextInt();
		debugDirectorySize = reader.readNextInt();
		sectionAlignment = reader.readNextInt();
		reserved = reader.readNextIntArray(2);

		if (numberOfSections > NTHeader.MAX_SANE_COUNT) {
			Msg.error(this, "Number of sections " + numberOfSections);
			return;
		}

		long ptr = reader.getPointerIndex();

		sections = new SectionHeader[numberOfSections];
		for (int i = 0; i < numberOfSections; ++i) {
			sections[i] = SectionHeader.createSectionHeader(reader, loadInfo, ptr);
			ptr += SectionHeader.IMAGE_SIZEOF_SECTION_HEADER;
		}

		long tmp = ptr;
		List<String> exportedNameslist = new ArrayList<String>();
		while (true) {
			String str = reader.readAsciiString(tmp);
			if (str == null || str.length() == 0) {
				break;
			}
			tmp += str.length() + 1;
			exportedNameslist.add(str);
		}
		exportedNames = new String[exportedNameslist.size()];
		exportedNameslist.toArray(exportedNames);

		ptr += exportedNamesSize;

		parser = DebugDirectoryParser.createDebugDirectoryParser(
				loadInfo.sectionLayout, reader, ptr, debugDirectorySize, this);
	}

	/**
	 * Returns the characteristics.
	 * @return the characteristics
	 */
	public short getCharacteristics() {
		return characteristics;
	}

	/**
	 * Returns the check sum.
	 * @return the check sum
	 */
	public int getCheckSum() {
		return checkSum;
	}

	/**
	 * Returns the debug directory size.
	 * @return the debug directory size
	 */
	public int getDebugDirectorySize() {
		return debugDirectorySize;
	}

	/**
	 * Returns the exported names size.
	 * @return the exported names size
	 */
	public int getExportedNamesSize() {
		return exportedNamesSize;
	}

	/**
	 * Returns the flags.
	 * @return the flags
	 */
	public short getFlags() {
		return flags;
	}

	/**
	 * Returns the image base.
	 * @return the image base
	 */
	public int getImageBase() {
		return imageBase;
	}

	/**
	 * Returns the machine type (or processor).
	 * @return the machine type
	 */
	public short getMachine() {
		return machine;
	}

	/**
	 * Returns the machine name (or processor name).
	 * @return the machine name
	 */
	public String getMachineName() {
		return MachineName.getName(machine);
	}

	/**
	 * Returns the number of sections.
	 * @return the number of sections
	 */
	public int getNumberOfSections() {
		return numberOfSections;
	}

	/**
	 * Returns the reserved int array.
	 * @return the reserved int array
	 */
	public int[] getReserved() {
		return reserved;
	}

	/**
	 * Returns the section alignment value.
	 * @return the section alignment value
	 */
	public int getSectionAlignment() {
		return sectionAlignment;
	}

	/**
	 * Returns the signature (or magic number).
	 * @return the signature
	 */
	public short getSignature() {
		return signature;
	}

	/**
	 * Returns the size of the image.
	 * @return the size of the image
	 */
	public int getSizeOfImage() {
		return sizeOfImage;
	}

	/**
	 * Returns the time date stamp.
	 * @return the time date stamp
	 */
	public int getTimeDateStamp() {
		return timeDateStamp;
	}

	/**
	 * Returns the debug directory parser.
	 * @return the debug directory parser
	 */
	public DebugDirectoryParser getParser() {
		return parser;
	}

	public boolean checkPointer(long ptr) {
		for (int i = 0; i < sections.length; ++i) {
			long rawSize = sections[i].getSizeOfRawData() & Conv.INT_MASK;
			long rawPtr = sections[i].getPointerToRawData() & Conv.INT_MASK;

			if (ptr >= rawPtr && ptr <= rawPtr + rawSize) { // <= allows data after the last section, which is OK
				return true;
			}
		}
		return false;
	}

	public boolean checkRVA(long rva) {
		return (0 <= rva) && (rva <= sizeOfImage);
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/TLSDataDirectory.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;

import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressSpace;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.DumbMemBufferImpl;
import ghidra.program.model.symbol.SourceType;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.exception.InvalidInputException;
import ghidra.util.task.TaskMonitor;
import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;

/**
 * Points to the Thread Local Storage initialization section.
 */
public class TLSDataDirectory extends DataDirectory {
    private final static String NAME = "IMAGE_DIRECTORY_ENTRY_TLS";

    private TLSDirectory tls;

    static TLSDataDirectory createTLSDataDirectory(NTHeader ntHeader,
            FactoryBundledWithBinaryReader reader) throws IOException {
        TLSDataDirectory tlsDataDirectory = (TLSDataDirectory) reader.getFactory().create(TLSDataDirectory.class);
        tlsDataDirectory.initTLSDataDirectory(ntHeader, reader);
        return tlsDataDirectory;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public TLSDataDirectory() {}

	private void initTLSDataDirectory(NTHeader ntHeader, FactoryBundledWithBinaryReader reader) throws IOException {
		processDataDirectory(ntHeader, reader);
	}

	/**
	 * Returns the thread local storage directory.
	 * @return the thread local storage directory
	 */
	public TLSDirectory getTLSDirectory() {
		return tls;
	}

	@Override
	public String getDirectoryName() {
		return NAME;
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor,
			MessageLog log, NTHeader ntHeader) throws DuplicateNameException, CodeUnitInsertionException,
			DataTypeConflictException, IOException {

		monitor.setMessage(program.getName()+": TLS...");
		Address addr = PeUtils.getMarkupAddress(program, isBinary, ntHeader, virtualAddress);
		if (!program.getMemory().contains(addr)) {
			return;
		}
		createDirectoryBookmark(program, addr);
		PeUtils.createData(program, addr, tls.toDataType(), log);

		// Markup TLS callback functions
		if (tls.getAddressOfCallBacks() != 0) {
			AddressSpace space = program.getImageBase().getAddressSpace();
			DataType pointerDataType = PointerDataType.dataType.clone(program.getDataTypeManager());
			try {
				for (int i = 0; i < 20; i++) { // cap # of TLS callbacks as a precaution (1 is the norm)
					Address nextCallbackPtrAddr = space.getAddress(
						tls.getAddressOfCallBacks() + i * pointerDataType.getLength());
					Address nextCallbackAddr = PointerDataType.getAddressValue(
						new DumbMemBufferImpl(program.getMemory(), nextCallbackPtrAddr),
						pointerDataType.getLength(), space);
					if (nextCallbackAddr.getOffset() == 0) {
						break;
					}
					PeUtils.createData(program, nextCallbackPtrAddr, pointerDataType, log);
					program.getSymbolTable().createLabel(nextCallbackAddr, "tls_callback_" + i,
						SourceType.IMPORTED);
					program.getSymbolTable().addExternalEntryPoint(nextCallbackAddr);
				}
			}
			catch (InvalidInputException e) {
				log.appendMsg("TLS", "Failed to markup TLS callback functions: " + e.getMessage());
			}
		}
	}

	@Override
	public boolean parse() throws IOException {
		int ptr = getPointer();
		if (ptr < 0) {
			return false;
		}

        tls = TLSDirectory.createTLSDirectory(reader, ptr, ntHeader.getOptionalHeader().is64bit());
        return true;
    }

    /**
     * @see ghidra.app.util.bin.StructConverter#toDataType()
     */
    @Override
    public DataType toDataType() throws DuplicateNameException {
		return tls.toDataType();
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/TLSDirectory.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.StructConverter;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.program.model.data.*;
import ghidra.util.Conv;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;

/**
 * A class to represent the IMAGE_TLS_DIRECTORY32 and
 * IMAGE_TLS_DIRECTORY64 data structures.
 * <br>
 * <pre>
 * typedef struct _IMAGE_TLS_DIRECTORY32 {
 *     DWORD   StartAddressOfRawData;
 *     DWORD   EndAddressOfRawData;
 *     DWORD   AddressOfIndex;             // PDWORD
 *     DWORD   AddressOfCallBacks;         // PIMAGE_TLS_CALLBACK *
 *     DWORD   SizeOfZeroFill;
 *     DWORD   Characteristics;
 * } IMAGE_TLS_DIRECTORY32;
 * typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;
 * </pre>
 * <br>
 * <pre>
 * typedef struct _IMAGE_TLS_DIRECTORY64 {
 *     ULONGLONG   StartAddressOfRawData;
 *     ULONGLONG   EndAddressOfRawData;
 *     PDWORD      AddressOfIndex;
 *     PIMAGE_TLS_CALLBACK * AddressOfCallBacks;
 *     DWORD       SizeOfZeroFill;
 *     DWORD       Characteristics;
 * } IMAGE_TLS_DIRECTORY64;
 * typedef IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;
 * </pre>
 * <br>
 * 
 */
public class TLSDirectory implements StructConverter {
    private boolean is64bit;
    private long  startAddressOfRawData;
    private long  endAddressOfRawData;
    private long  addressOfIndex;
    private long  addressOfCallBacks;
    private int   sizeOfZeroFill;
    private int   characteristics;

    static TLSDirectory createTLSDirectory(
            FactoryBundledWithBinaryReader reader, int index, boolean is64bit)
            throws IOException {
        TLSDirectory tlsDirectory = (TLSDirectory) reader.getFactory().create(TLSDirectory.class);
        tlsDirectory.initTLSDirectory(reader, index, is64bit);
        return tlsDirectory;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public TLSDirectory() {}

    private void initTLSDirectory(FactoryBundledWithBinaryReader reader, int index, boolean is64bit) throws IOException {
        this.is64bit = is64bit;
        if (is64bit) {
	        startAddressOfRawData = reader.readLong(index); index += BinaryReader.SIZEOF_LONG;
	        endAddressOfRawData   = reader.readLong(index); index += BinaryReader.SIZEOF_LONG;
	        addressOfIndex        = reader.readLong(index); index += BinaryReader.SIZEOF_LONG;
	        addressOfCallBacks    = reader.readLong(index); index += BinaryReader.SIZEOF_LONG;
        }
        else {
	        startAddressOfRawData = reader.readInt(index) & Conv.INT_MASK; index += BinaryReader.SIZEOF_INT;
	        endAddressOfRawData   = reader.readInt(index) & Conv.INT_MASK; index += BinaryReader.SIZEOF_INT;
	        addressOfIndex        = reader.readInt(index) & Conv.INT_MASK; index += BinaryReader.SIZEOF_INT;
	        addressOfCallBacks    = reader.readInt(index) & Conv.INT_MASK; index += BinaryReader.SIZEOF_INT;
        }
        Msg.info(this, "TLS callbacks at "+Long.toHexString(addressOfCallBacks));
        sizeOfZeroFill        = reader.readInt(index); index += BinaryReader.SIZEOF_INT;
        characteristics       = reader.readInt(index); index += BinaryReader.SIZEOF_INT;
    }

	/**
	 * Returns the beginning address of a range of memory used to initialize a new thread's TLS data in memory.
	 * @return the beginning address of a range of memory used to initialize a new thread's TLS data in memory.
	 */
    public long getStartAddressOfRawData() {
        return startAddressOfRawData;
    }

	/**
	 * Returns the ending address of the range of memory used to initialize a new thread's TLS data in memory.
	 * @return the ending address of the range of memory used to initialize a new thread's TLS data in memory.
	 */
    public long getEndAddressOfRawData() {
        return endAddressOfRawData;
    }

	/**
	 * @return the index to locate the thread local data.
	 */
    public long getAddressOfIndex() {
        return addressOfIndex;
    }

	/**
	 * @return the address of an array of <code>PIMAGE_TLS_CALLBACK</code> function pointers
	 */
    public long getAddressOfCallBacks() {
        return addressOfCallBacks;
    }

	/**
	 * @return the size in bytes of the initialization data
	 */
    public int getSizeOfZeroFill() {
        return sizeOfZeroFill;
    }

	/**
	 * Reserved, currently set to 0.
	 * @return reserved, currently set to 0
	 */
    public int getCharacteristics() {
        return characteristics;
    }

    /**
     * @see ghidra.app.util.bin.StructConverter#toDataType()
     */
    public DataType toDataType() throws DuplicateNameException {
        StructureDataType struct = new StructureDataType(getName(), 0);

        DataType dt = is64bit ? QWORD : DWORD;

        struct.add(dt, "StartAddressOfRawData", null);
        struct.add(dt, "EndAddressOfRawData", null);
        struct.add(dt, "AddressOfIndex", null);
        struct.add(dt, "AddressOfCallBacks", null);

        struct.add(DWORD, "SizeOfZeroFill", null);
        struct.add(DWORD, "Characteristics", null);

        struct.setCategoryPath(new CategoryPath("/PE"));

        return struct;
    }

	/**
	 * Returns the name of the structure.
	 * @return the name of the structure
	 */
	public String getName() {
	    return "IMAGE_THUNK_DATA"+(is64bit ? "64" : "32");
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/ThunkData.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe;

import ghidra.app.util.bin.ByteArrayConverter;
import ghidra.app.util.bin.StructConverter;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.program.model.data.*;
import ghidra.util.Conv;
import ghidra.util.DataConverter;
import ghidra.util.exception.DuplicateNameException;

import java.io.IOException;

/**
 * A class to represent the 
 * <b><code>IMAGE_THUNK_DATA32 struct</code></b>
 * as defined in 
 * <b><code>winnt.h</code></b>.
 * 
 * <pre>
 * typedef struct _IMAGE_THUNK_DATA32 {
 *     union {
 *         DWORD ForwarderString;  // PBYTE
 *         DWORD Function;         // PDWORD
 *         DWORD Ordinal;
 *         DWORD AddressOfData;    // PIMAGE_IMPORT_BY_NAME
 *     } u1;
 * } IMAGE_THUNK_DATA32;
 * typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;
 * </pre>
 * 
 * <pre>
 * typedef struct _IMAGE_THUNK_DATA64 {
 *     union {
 *         PBYTE  ForwarderString;
 *         PDWORD Function;
 *         ULONGLONG Ordinal;
 *         PIMAGE_IMPORT_BY_NAME  AddressOfData;
 *     } u1;
 * } IMAGE_THUNK_DATA64;
 * typedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;
 * </pre>
 *
 * 
 */
public class ThunkData implements StructConverter, ByteArrayConverter {
	private boolean is64bit;
	private long value;
	private ImportByName ibn;

	static ThunkData createThunkData(FactoryBundledWithBinaryReader reader, int index,
			boolean is64bit) throws IOException {
		ThunkData thunkData = (ThunkData) reader.getFactory().create(ThunkData.class);
		thunkData.initThunkData(reader, index, is64bit);
		return thunkData;
	}

	/**
	 * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
	 */
	public ThunkData() {
	}

	private void initThunkData(FactoryBundledWithBinaryReader reader, int index, boolean is64bit)
			throws IOException {
		this.is64bit = is64bit;
		if (is64bit) {
			value = reader.readLong(index);
		}
		else {
			value = reader.readInt(index) & Conv.INT_MASK;
		}
	}

	/**
	 * Constructs a new thunk data with the specified value
	 * @param value the new thunk value
	 */
	public ThunkData(int value) {
		setValue(value);
	}

	/**
	 * Returns the size of the thunk (in bytes) based on the size of the
	 * executable (32 vs 64 bit).
	 * @return the size of the thunk (in bytes)
	 */
	public int getStructSize() {
		return is64bit ? 8 : 4;
	}

	/**
	 * Returns the struct name.
	 * @return the struct name
	 */
	public String getStructName() {
		return "IMAGE_THUNK_DATA" + (is64bit ? "64" : "32");
	}

	/**
	 * Sets the value of the thunk.
	 * @param value the new thunk value
	 */
	public void setValue(int value) {
		this.value = value & Conv.INT_MASK;
	}

	/**
	 * Returns the forward string pointer.
	 * @return the forward string pointer
	 */
	public long getForwarderString() {
		return value;
	}

	/**
	 * Returns the function pointer.
	 * @return the function pointer
	 */
	public long getFunction() {
		return value;
	}

	/**
	 * Returns the ordinal.
	 * @return the ordinal
	 */
	public long getOrdinal() {
		return value & 0xffff;
	}

	public boolean isOrdinal() {
		if (is64bit) {
			return (value & Constants.IMAGE_ORDINAL_FLAG64) != 0;
		}
		return (value & Constants.IMAGE_ORDINAL_FLAG32) != 0;
	}

	/**
	 * Returns the address of the data.
	 * @return the address of the data
	 */
	public long getAddressOfData() {
		return value;
	}

	void setImportByName(ImportByName ibn) {
		this.ibn = ibn;
	}

	/**
	 * Returns the underlying import by name structure.
	 * @return the underlying import by name structure
	 */
	public ImportByName getImportByName() {
		return ibn;
	}

	/**
	 * @see ghidra.app.util.bin.StructConverter#toDataType()
	 */
	public DataType toDataType() throws DuplicateNameException {
		UnionDataType union = new UnionDataType("u1");
		union.setCategoryPath(new CategoryPath("/PE"));

		DataType dt = is64bit ? QWORD : DWORD;

		union.add(dt, "ForwarderString", null);
		union.add(dt, "Function", null);
		union.add(dt, "Ordinal", null);
		union.add(dt, "AddressOfData", null);

		StructureDataType struct = new StructureDataType(getStructName(), 0);
		struct.add(union, "u1", null);
		struct.setCategoryPath(new CategoryPath("/PE"));
		return struct;
	}

	/**
	 * @see ghidra.app.util.bin.ByteArrayConverter#toBytes(ghidra.util.DataConverter)
	 */
	public byte[] toBytes(DataConverter dc) {
		if (is64bit) {
			return dc.getBytes(value);
		}
		int tmp = (int) value;
		return dc.getBytes(tmp);
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/CliMetadataDirectory.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli;

import java.io.IOException;

import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import net.jubjubnest.minidump.contrib.pe.*;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;

/**
 * The Metadata directory pointed found in {@link ImageCor20Header}.
 */
public class CliMetadataDirectory extends DataDirectory {

	private final static String NAME = "CLI_METADATA_DIRECTORY";

	private CliMetadataRoot metadataRoot;

	public static CliMetadataDirectory createCliMetadataDirectory(NTHeader ntHeader,
			FactoryBundledWithBinaryReader reader) throws IOException {
		CliMetadataDirectory cliMetadataDirectory =
			(CliMetadataDirectory) reader.getFactory().create(CliMetadataDirectory.class);
		cliMetadataDirectory.initCliMetadataDirectory(ntHeader, reader);
		return cliMetadataDirectory;
	}

	/**
	 * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
	 */
	public CliMetadataDirectory() {
	}

	private void initCliMetadataDirectory(NTHeader ntHeader, FactoryBundledWithBinaryReader reader)
			throws IOException {
		this.ntHeader = ntHeader;
		this.reader = reader;

		this.virtualAddress = reader.readNextInt();
		this.size = reader.readNextInt();
	}

	/**
	 * Gets the Metadata root.
	 * 
	 * @return header The Metadata root.
	 */
	public CliMetadataRoot getMetadataRoot() {
		return metadataRoot;
	}

	@Override
	public String getDirectoryName() {
		return NAME;
	}

	@Override
	public boolean parse() throws IOException {
		int ptr = getPointer();
		if (ptr < 0 || this.size == 0) {
			return false;
		}

		long origIndex = reader.getPointerIndex();
		reader.setPointerIndex(ptr);
		metadataRoot = new CliMetadataRoot(reader, virtualAddress);
		hasParsed = metadataRoot.parse();
		reader.setPointerIndex(origIndex);
		return hasParsed;
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor,
			MessageLog log, NTHeader ntHeader) throws DuplicateNameException, CodeUnitInsertionException,
			IOException, MemoryAccessException {

		if (metadataRoot == null) {
			return;
		}

		monitor.setMessage("[" + program.getName() + "]: CLI metadata...");

		// Get our program address
		Address addr = PeUtils.getMarkupAddress(program, isBinary, ntHeader, virtualAddress);
		if (!program.getMemory().contains(addr)) {
			return;
		}

		// Create bookmark
		createDirectoryBookmark(program, addr);

		// Create data type
		DataType dt = metadataRoot.toDataType();
		dt.setCategoryPath(new CategoryPath("/PE/CLI"));
		PeUtils.createData(program, addr, dt, log);

		// Markup metadata header
		metadataRoot.markup(program, isBinary, monitor, log, ntHeader);
	}

	@Override
	public DataType toDataType() throws DuplicateNameException {
		StructureDataType ddstruct = new StructureDataType(NAME, 0);
		ddstruct.add(DWordDataType.dataType, "VirtualAddress", null);
		ddstruct.add(DWordDataType.dataType, "Size", null);
		ddstruct.setCategoryPath(new CategoryPath("/PE/CLI"));
		return ddstruct;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/CliMetadataRoot.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli;

import java.io.IOException;
import java.nio.charset.Charset;
import java.util.*;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.StructConverter;
import net.jubjubnest.minidump.contrib.pe.NTHeader;
import net.jubjubnest.minidump.contrib.pe.PeMarkupable;
import net.jubjubnest.minidump.contrib.pe.cli.streams.*;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.program.model.symbol.SourceType;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.exception.InvalidInputException;
import ghidra.util.task.TaskMonitor;

/**
 * The header of a {@link CliMetadataDirectory}.
 */
public class CliMetadataRoot implements StructConverter, PeMarkupable {

	public static final String NAME = "CLI_METADATA_HEADER";
	public static final String PATH = "/PE/CLI";
    
	private BinaryReader reader;
    private long fileOffset;
    private int rva;
    
    private int signature;
    private short majorVersion;
    private short minorVersion;
    private int reserved;
	private int versionLength;
    private String version;
    private short flags;
    private short streamsCount;
	private Map<String, CliStreamHeader> streamHeaderMap;
	private CliStreamHeader metadataHeader;

	private CliStreamGuid guidStream;
	private CliStreamUserStrings userStringsStream;
	private CliStreamStrings stringsStream;
	private CliStreamBlob blobStream;
	private CliStreamMetadata metadataStream;
    
    /**
	 * Constructs a new CLI Metadata Root datatype. Matches ISO 23271 II.24.2.
	 * 
	 * @param reader A binary reader set to start reading at the start of this header.
	 * @param rva The RVA of this header.
	 * @throws IOException if there is a problem reading the header.
	 */
	public CliMetadataRoot(BinaryReader reader, int rva)
			throws IOException {
		this.reader = reader;
		this.fileOffset = reader.getPointerIndex();
		this.rva = rva;
		
		this.signature = reader.readNextInt();
		this.majorVersion = reader.readNextShort();
		this.minorVersion = reader.readNextShort();
		this.reserved = reader.readNextInt();
		this.versionLength = reader.readNextInt();
		if (versionLength > 0 && versionLength < NTHeader.MAX_SANE_COUNT) {
			this.version =
				new String(reader.readNextByteArray(this.versionLength), Charset.forName("UTF-8"));
		}
		this.flags = reader.readNextShort();
		this.streamsCount = reader.readNextShort();

		this.streamHeaderMap = new LinkedHashMap<>();
		for (short i = 0; i < this.streamsCount; i++) {
			CliStreamHeader streamHeader = new CliStreamHeader(this, reader);
			streamHeaderMap.put(streamHeader.getName(), streamHeader);
			if (streamHeader.getName().equals(CliStreamMetadata.getName())) {
				metadataHeader = streamHeader;
			}
		}
	}

	public boolean parse() throws IOException {
		boolean success = true;
	
		// #GUID
		CliStreamHeader header = streamHeaderMap.get(CliStreamGuid.getName());
		if (header != null) {
			guidStream = new CliStreamGuid(header, getFileOffset() + header.getOffset(),
				getRva() + header.getOffset(), reader);
			header.setStream(guidStream);
			success &= guidStream.parse();
		}

		// #US
		header = streamHeaderMap.get(CliStreamUserStrings.getName());
		if (header != null) {
			userStringsStream = new CliStreamUserStrings(header,
				getFileOffset() + header.getOffset(), getRva() + header.getOffset(), reader);
			header.setStream(userStringsStream);
			success &= userStringsStream.parse();
		}

		// #Strings
		header = streamHeaderMap.get(CliStreamStrings.getName());
		if (header != null) {
			stringsStream = new CliStreamStrings(header, getFileOffset() + header.getOffset(),
				getRva() + header.getOffset(), reader);
			header.setStream(stringsStream);
			success &= stringsStream.parse();
		}

		// #Blob
		header = streamHeaderMap.get(CliStreamBlob.getName());
		if (header != null) {
			blobStream = new CliStreamBlob(header,
				getFileOffset() + header.getOffset(), getRva() + header.getOffset(), reader);
			header.setStream(blobStream);
			success &= blobStream.parse();
		}

		// #~ (must be done last)
		header = streamHeaderMap.get(CliStreamMetadata.getName());
		if (header != null) {
			metadataStream = new CliStreamMetadata(header, guidStream, userStringsStream,
				stringsStream, blobStream, getFileOffset() + header.getOffset(),
				getRva() + header.getOffset(), reader);
			header.setStream(metadataStream);
			success &= metadataStream.parse();
		}

		return success;
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor,
			MessageLog log, NTHeader ntHeader) throws DuplicateNameException, CodeUnitInsertionException,
			IOException, MemoryAccessException {
		Address start = program.getImageBase().add(ntHeader.getLoadInfo().imageBase).add(getRva());
		try {
			program.getSymbolTable().createLabel(start, NAME, SourceType.ANALYSIS);
		}
		catch (InvalidInputException e) {
			Msg.warn(this, "Invalid symbol name: \"" + NAME + "\"");
		}

		// Markup streams.  Must markup Metadata stream last.
		for (CliStreamHeader header : streamHeaderMap.values()) {
			if (header != metadataHeader) {
				header.markup(program, isBinary, monitor, log, ntHeader);
			}
		}
		if (metadataHeader != null) {
			metadataHeader.markup(program, isBinary, monitor, log, ntHeader);
		}
	}

	@Override
	public DataType toDataType() throws DuplicateNameException, IOException {
		Structure struct = new StructureDataType(NAME, 0);
		struct.setCategoryPath(new CategoryPath(PATH));
		struct.add(DWORD, "Signature", "must be 0x424a5342");
		struct.add(WORD, "MajorVersion", null);
		struct.add(WORD, "MinorVersion", null);
		struct.add(DWORD, "Reserved", "should be 0");
		struct.add(DWORD, "VersionLength", null);
		struct.add(new ArrayDataType(CharDataType.dataType, this.versionLength, 1), "Version",
			null);
		struct.add(WORD, "Flags", "should be 0");
		struct.add(WORD, "StreamsCount", "number of stream headers to follow");
		for (CliStreamHeader hdr : streamHeaderMap.values()) {
			struct.add(hdr.toDataType(), hdr.getName(), null);
		}
		return struct;
	}

	/**
	 * Gets the file offset of this header.
	 * 
	 * @return The file offset of this header.
	 */
	public long getFileOffset() {
		return fileOffset;
	}
	
	/**
	 * Gets the relative virtual address of this header.
	 * 
	 * @return The relative virtual address of this header.
	 */
	public int getRva() {
		return rva;
	}

	/**
	 * Gets the signature.  
	 * <p>
	 * Should always be 0x424a5342.
	 * 
	 * @return The signature.
	 */
	public int getSignature() {
		return signature;
	}

	/**
	 * Gets the major version.
	 * 
	 * @return The major version.
	 */
	public short getMajorVersion() {
		return majorVersion;
	}

	/**
	 * Gets the minor version.
	 * 
	 * @return The minor version.
	 */
	public short getMinorVersion() {
		return minorVersion;
	}

	/**
	 * Gets the reserved field.  
	 * <p>
	 * Should always be 0.
	 * 
	 * @return The reserved field.
	 */
	public int getReserved() {
		return reserved;
	}

	/**
	 * Gets the length of the version string that follows the length field.
	 * 
	 * @return The length of the version string that follows the length field.
	 */
	public int getVersionLength() {
		return versionLength;
	}

	/**
	 * Gets the version string.
	 * 
	 * @return The version string.  Could be null if the version length appeared
	 *   too long during parsing of the header.
	 */
	public String getVersion() {
		return version;
	}

	/**
	 * Gets the flags.
	 * <p>
	 * Should always be 0.
	 * 
	 * @return The flags.
	 */
	public short getFlags() {
		return flags;
	}

	/**
	 * Gets the number of streams present in the metadata.
	 * 
	 * @return The number of streams present in the metadata.
	 */
	public short getStreamsCount() {
		return streamsCount;
	}

	/**
	 * Gets the GUID stream.
	 * 
	 * @return The GUID stream.  Could be null if it did not parse correctly.
	 */
	public CliStreamGuid getGuidStream() {
		return guidStream;
	}

	/**
	 * Gets the user strings stream.
	 * 
	 * @return The user strings stream.  Could be null if it did not parse correctly.
	 */
	public CliStreamUserStrings getUserStringsStream() {
		return userStringsStream;
	}

	/**
	 * Gets the strings stream.
	 * 
	 * @return The strings stream.  Could be null if it did not parse correctly.
	 */
	public CliStreamStrings getStringsStream() {
		return stringsStream;
	}

	/**
	 * Gets the blob stream.
	 * 
	 * @return The blob stream.  Could be null if it did not parse correctly.
	 */
	public CliStreamBlob getBlobStream() {
		return blobStream;
	}

	/**
	 * Gets the Metadata stream.
	 * 
	 * @return The Metadata stream.  Could be null if it did not parse correctly.
	 */
	public CliStreamMetadata getMetadataStream() {
		return metadataStream;
	}

	/**
	 * Gets the stream headers.
	 * 
	 * @return A collection of stream headers.
	 */
	public Collection<CliStreamHeader> getStreamHeaders() {
		return streamHeaderMap.values();
	}
	
	/**
	 * Gets the stream header with the given name.
	 * 
	 * @param name The name of the stream header to get.
	 * @return The stream header that matches the given name, or null if it wasn't found.
	 */
	public CliStreamHeader getStreamHeader(String name) {
		return streamHeaderMap.get(name);
	}
	
	public int getBlobOffsetAtIndex(int index) {
		CliStreamHeader blobHdr = getStreamHeader("#Blob");
		if (blobHdr == null) return -1; // TODO: this isn't a nice way of doing this
		int offset = (int) this.fileOffset + blobHdr.getOffset() + index;
		return offset;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/CliRepresentable.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli;

import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;

/**
 * Describes the methods necessary to get a long and short representation, with or without an metadata stream.
 * This is used in the token analyzer to cut down on duplication across modules.
 */
public interface CliRepresentable {
	public String getRepresentation();
	public String getShortRepresentation();
	public String getRepresentation(CliStreamMetadata stream);
	public String getShortRepresentation(CliStreamMetadata stream);
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/CliStreamHeader.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.StructConverter;
import net.jubjubnest.minidump.contrib.pe.NTHeader;
import net.jubjubnest.minidump.contrib.pe.PeMarkupable;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliAbstractStream;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;

/**
 * A structure used by a {@link CliMetadataRoot} describe a {@link CliAbstractStream}.
 * <p>
 * Note that this type of "header" isn't found at the start of the stream, but as
 * elements of a list of headers at the end of a {@link CliMetadataRoot}.  They 
 * are kind of like PE section headers.
 */
public class CliStreamHeader implements StructConverter, PeMarkupable {
	
	private static String NAME = "CLI_Stream_Header";
	private static String PATH = "/PE/CLI/Streams/Headers";

	private CliMetadataRoot metadataRoot;
	private CliAbstractStream stream;
	
	private int offset;
	private int size;
	private String name;
	private int nameLen;
	
	/**
	 * Constructs a new CLI Stream Header datatype.
	 * 
	 * @param metadataRoot the metadata root.
	 * @param reader A binary reader set to start reading at the start of this header.
	 * @throws IOException if there is a problem reading the header.
	 */
	public CliStreamHeader(CliMetadataRoot metadataRoot, BinaryReader reader)
			throws IOException {
		this.metadataRoot = metadataRoot;
		
		long headerStartIndex = reader.getPointerIndex();

		this.offset = reader.readNextInt();
		this.size = reader.readNextInt();
		
		// name is an ASCII string aligned to the next 4-byte boundary
		long startIndex = reader.getPointerIndex();
		this.name = reader.readNextAsciiString();
		long endIndex = reader.getPointerIndex(); // Gives us the index of the byte after the first null terminator
		long stringBytes = endIndex - startIndex;
		long bytesToRoundUp = 0;
		if ((stringBytes % 4) != 0) {
			bytesToRoundUp += 4 - (stringBytes % 4);
		}
		this.nameLen = (int) (stringBytes + bytesToRoundUp);
		
		int totalLen = 2 * DWordDataType.dataType.getLength() + this.nameLen;

		reader.setPointerIndex(headerStartIndex + totalLen);
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor,
			MessageLog log, NTHeader ntHeader) throws DuplicateNameException, IOException, MemoryAccessException {
		if (stream != null) {
			stream.markup(program, isBinary, monitor, log, ntHeader);
		}
	}

	@Override
	public DataType toDataType() throws DuplicateNameException, IOException {
		Structure struct = new StructureDataType(NAME + "_" + name, 0);
		struct.setCategoryPath(new CategoryPath(PATH));
		struct.add(DWORD, "offset", null);
		struct.add(DWORD, "size", null);
		struct.add(new ArrayDataType(CharDataType.dataType, this.nameLen, 1), "name", null);
		return struct;
	}

	/**
	 * Gets the {@link CliMetadataRoot} that contains us.
	 * 
	 * @return The {@link CliMetadataRoot} that contains us.
	 */
	public CliMetadataRoot getMetadataRoot() {
		return metadataRoot;
	}
	
	/**
	 * Gets the {@link CliAbstractStream} that this is a header for.
	 * 
	 * @return The {@link CliAbstractStream} that this is a header for.  Could be null if we
	 *   don't support the stream type.
	 */
	public CliAbstractStream getStream() {
		return stream;
	}

	/**
	 * Gets the offset.  This is not a file offset, but an offset that gets added to 
	 * the metadata header's offset to obtain a file offset.
	 * 
	 * @return The offset.
	 */
	public int getOffset() {
		return offset;
	}

	/**
	 * Gets the size of this header's stream.
	 * 
	 * @return The size of this header's stream.
	 */
	public int getSize() {
		return size;
	}

	/**
	 * Gets the name of this header's stream.
	 * 
	 * @return The name of this header's stream.
	 */
	public String getName() {
		return name;
	}

	/**
	 * Gets the name length.
	 * <p>
	 * The name length may be larger than necessary because the name string is must
	 * be aligned to the next 4-byte boundary.
	 * 
	 * @return The name length.
	 */
	public int getNameLength() {
		return nameLen;
	}

	@Override
	public String toString() {
		return getName();
	}

	/**
	 * Sets this header's stream.
	 * 
	 * @param stream The stream associated with this header.
	 */
	protected void setStream(CliAbstractStream stream) {
		this.stream = stream;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/blobs/CliAbstractSig.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.blobs;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.CliRepresentable;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.*;
import net.jubjubnest.minidump.contrib.pe.cli.tables.indexes.CliIndexTypeDefOrRef;
import ghidra.program.model.data.*;
import ghidra.util.exception.InvalidInputException;

public abstract class CliAbstractSig extends CliBlob implements CliRepresentable {

	public static final String PATH = "/PE/CLI/Blobs/Signatures";

	public CliAbstractSig(CliBlob blob) {
		super(blob);
	}

	@Override
	public abstract DataType getContentsDataType();

	@Override
	public abstract String getContentsName();

	@Override
	public abstract String getContentsComment();

	/** This is the method that subclasses should override. If stream is null, the method must not cause a NullPointerException,
	 * i.e. it must handle this as if there was no stream to begin with.
	 */
	protected abstract String getRepresentationCommon(CliStreamMetadata stream, boolean isShort);

	@Override
	public final String getRepresentation() {
		return getRepresentationCommon(null, false);
	}

	@Override
	public final String getShortRepresentation() {
		return getRepresentationCommon(null, true);
	}

	@Override
	public final String getRepresentation(CliStreamMetadata stream) {
		return getRepresentationCommon(stream, false);
	}

	@Override
	public final String getShortRepresentation(CliStreamMetadata stream) {
		return getRepresentationCommon(stream, true);
	}

	protected String getRepresentationOf(CliRepresentable obj, CliStreamMetadata stream,
			boolean isShort) {
		if (isShort) {
			if (stream != null) {
				return obj.getShortRepresentation(stream);
			}
			return obj.getShortRepresentation();
		}

		if (stream != null) {
			return obj.getRepresentation(stream);
		}

		return obj.getRepresentation();
	}

	public static class CliTypeCodeDataType extends EnumDataType {
		private static final long serialVersionUID = 1L;

		public static final String PATH = "/PE/CLI/Types";

		public final static CliTypeCodeDataType dataType = new CliTypeCodeDataType();

		public CliTypeCodeDataType() {
			super(new CategoryPath(PATH), "TypeCode", 1);

			for (CliElementType c : CliElementType.values()) {
				add(c.toString(), c.id());
			}
		}
	}

	public static DataType convertTypeCodeToDataType(CliElementType typeCode) {
		/*
		TODO:
		ELEMENT_TYPE_VALUETYPE(0x11),
		ELEMENT_TYPE_VAR(0x13), // "Class type variable VAR"
		(0x16),

		ELEMENT_TYPE_MVAR(0x1e), // Method type variable MVAR

		ELEMENT_TYPE_INTERNAL(0x21), // Internal (generated internally, "will not be persisted in any way")
		ELEMENT_TYPE_MAX(0x22),

		*/

		switch (typeCode) {
			case ELEMENT_TYPE_VOID:
				return VoidDataType.dataType;

			case ELEMENT_TYPE_BOOLEAN:
				return BooleanDataType.dataType;
			case ELEMENT_TYPE_CHAR:
				return StringUTF8DataType.dataType;
			case ELEMENT_TYPE_I1:
				return SignedByteDataType.dataType;
			case ELEMENT_TYPE_U1:
				return ByteDataType.dataType;

			case ELEMENT_TYPE_I2:
				return ShortDataType.dataType;
			case ELEMENT_TYPE_U2:
				return UnsignedShortDataType.dataType;

			case ELEMENT_TYPE_I4:
				return IntegerDataType.dataType;
			case ELEMENT_TYPE_U4:
				return UnsignedIntegerDataType.dataType;

			case ELEMENT_TYPE_R4:
				return Float4DataType.dataType;
			case ELEMENT_TYPE_R8:
				return Float8DataType.dataType;

			case ELEMENT_TYPE_I8:
				return LongLongDataType.dataType;
			case ELEMENT_TYPE_U8:
				return UnsignedLongLongDataType.dataType;

			// TODO: Does this change for native architectures other than 32-bit?
			case ELEMENT_TYPE_I:
				return IntegerDataType.dataType;
			case ELEMENT_TYPE_U:
				return UnsignedIntegerDataType.dataType;

			case ELEMENT_TYPE_PTR:
				return PointerDataType.dataType;
			case ELEMENT_TYPE_FNPTR:
				return PointerDataType.dataType;

			case ELEMENT_TYPE_SZARRAY:
			case ELEMENT_TYPE_STRING:
				return new PointerDataType(new CharDataType());
			case ELEMENT_TYPE_ARRAY:
				return new PointerDataType(new ByteDataType());

			case ELEMENT_TYPE_OBJECT: // System.Object
			case ELEMENT_TYPE_CLASS:
				return PointerDataType.dataType;

			case ELEMENT_TYPE_SENTINEL:
				return Undefined1DataType.dataType;

			default:
				return VoidDataType.dataType;
		}
	}

	public enum CliElementType {
		ELEMENT_TYPE_END(0x0), // "Marks end of list"
		ELEMENT_TYPE_VOID(0x1),
		ELEMENT_TYPE_BOOLEAN(0x2),
		ELEMENT_TYPE_CHAR(0x3),
		ELEMENT_TYPE_I1(0x4), // CLI names these by number of bytes (e.g. I4, U2, I1)
		ELEMENT_TYPE_U1(0x5),
		ELEMENT_TYPE_I2(0x6),
		ELEMENT_TYPE_U2(0x7),
		ELEMENT_TYPE_I4(0x8),
		ELEMENT_TYPE_U4(0x9),
		ELEMENT_TYPE_I8(0xa),
		ELEMENT_TYPE_U8(0xb),
		ELEMENT_TYPE_R4(0xc), // R refers to float types
		ELEMENT_TYPE_R8(0xd),
		ELEMENT_TYPE_STRING(0xe),

		ELEMENT_TYPE_PTR(0xf),
		ELEMENT_TYPE_BYREF(0x10), // ByRef flag in paramters

		ELEMENT_TYPE_VALUETYPE(0x11),
		ELEMENT_TYPE_CLASS(0x12),
		ELEMENT_TYPE_VAR(0x13), // "Class type variable VAR"
		ELEMENT_TYPE_ARRAY(0x14),
		ELEMENT_TYPE_GENERICINST(0x15), // Signifies a variable uses a Generic
		ELEMENT_TYPE_TYPEDBYREF(0x16), // A fully specified ByRef type

		ELEMENT_TYPE_I(0x18), // native integer size
		ELEMENT_TYPE_U(0x19), // native unsigned integer size
		ELEMENT_TYPE_FNPTR(0x1b),
		ELEMENT_TYPE_OBJECT(0x1c), // System.Object
		ELEMENT_TYPE_SZARRAY(0x1d), // Single dimension zero lower bound array
		ELEMENT_TYPE_MVAR(0x1e), // Method type variable MVAR

		ELEMENT_TYPE_CMOD_REQD(0x1f), // only for binding. C modifier required.
		ELEMENT_TYPE_CMOD_OPT(0x20), // only for binding. C modifier optional.

		ELEMENT_TYPE_INTERNAL(0x21), // Internal (generated internally, "will not be persisted in any way")
		ELEMENT_TYPE_MAX(0x22),

		ELEMENT_TYPE_MODIFIER(0x40),
		ELEMENT_TYPE_SENTINEL(0x41), // Sentinel in MethodRefs
		ELEMENT_TYPE_PINNED(0x45); // Constrained variable

		private final int id;

		CliElementType(int id) {
			this.id = id;
		}

		public int id() {
			return id;
		}

		public static CliElementType fromInt(int id) {
			CliElementType[] values = CliElementType.values();
			for (CliElementType value : values) {
				if (value.id == id) {
					return value;
				}
			}
			return null;
		}
	}

	public abstract class CliSigType implements CliRepresentable {
		protected CliElementType baseTypeCode;

		public static final String PATH = "/PE/CLI/Types";

		public CliSigType(CliElementType typeCode) {
			this.baseTypeCode = typeCode;
		}

		@Override
		public abstract String getRepresentation();

		@Override
		public String getRepresentation(CliStreamMetadata stream) {
			return getRepresentation();
		}

		@Override
		public String getShortRepresentation() {
			return getRepresentation();
		}

		@Override
		public String getShortRepresentation(CliStreamMetadata stream) {
			return getRepresentation(stream);
		}

		public abstract DataType getDefinitionDataType();

		public DataType getExecutionDataType() {
			return convertTypeCodeToDataType(baseTypeCode);
		}
	}

	public class CliTypePrimitive extends CliSigType {
		public CliTypePrimitive(CliElementType typeCode) {
			super(typeCode);
		}

		@Override
		public String getRepresentation() {
			return baseTypeCode.toString();
		}

		@Override
		public DataType getDefinitionDataType() {
			return CliTypeCodeDataType.dataType;
		}
	}

	public class CliTypeArray extends CliSigType {
		private CliElementType arrayType;
		private CliArrayShape arrayShape;

		public CliTypeArray(BinaryReader reader, CliElementType typeCode) throws IOException {
			super(typeCode);
			arrayType = CliElementType.fromInt(reader.readNextByte());
			arrayShape = new CliArrayShape(reader);
		}

		@Override
		public String getRepresentation() {
			return String.format("Array %s %s", arrayType.toString(),
				arrayShape.getRepresentation());
		}

		@Override
		public DataType getDefinitionDataType() {
			StructureDataType struct = new StructureDataType(new CategoryPath(PATH), "Array", 0);
			struct.add(CliTypeCodeDataType.dataType, "Array",
				String.format("Fixed value: 0x%x", CliElementType.ELEMENT_TYPE_ARRAY.id()));
			struct.add(CliTypeCodeDataType.dataType, "Type", "Type of array");
			struct.add(arrayShape.getDefinitionDataType(), "ArrayShape", null);
			return struct;
		}
	}

	public class CliTypeClass extends CliSigType {
		private int encodedType;
		private int typeBytes;

		public CliTypeClass(BinaryReader reader, CliElementType typeCode) throws IOException {
			super(typeCode);
			long origIndex = reader.getPointerIndex();
			encodedType = decodeCompressedUnsignedInt(reader);
			typeBytes = (int) (reader.getPointerIndex() - origIndex);
		}

		@Override
		public String getRepresentation() {
			return Integer.toHexString(encodedType);
		}

		private String getRepresentation(CliStreamMetadata stream, boolean shortRep) {
			try {
				if (stream != null) {
					CliAbstractTable table =
						stream.getTable(CliIndexTypeDefOrRef.getTableName(encodedType));
					if (table == null) {
						return "[ErrorRetrievingTable]";
					}
					CliAbstractTableRow row =
						table.getRow(CliIndexTypeDefOrRef.getRowIndex(encodedType));
					if (row == null) {
						return "[ErrorRetrievingRow]";
					}
					if (shortRep) {
						return row.getShortRepresentation();
					}
					return row.getRepresentation();
				}
				return "[ErrorRepresentingClassReference]";
			}
			catch (InvalidInputException e) {
				e.printStackTrace();
			}
			return "[ErrorRepresentingClassReference]";
		}

		@Override
		public String getRepresentation(CliStreamMetadata stream) {
			return getRepresentation(null, false);
		}

		@Override
		public String getShortRepresentation(CliStreamMetadata stream) {
			return getRepresentation(stream, true);
		}

		@Override
		public DataType getDefinitionDataType() {
			StructureDataType struct = new StructureDataType(new CategoryPath(PATH), "Class", 0);
			struct.add(CliTypeCodeDataType.dataType, "Class", "Class");
			struct.add(getDataTypeForBytes(typeBytes), "Type", "TypeDefOrRefOrSpecEncoded");
			return struct;
		}
	}

	public class CliTypeFnPtr extends CliSigType {
		private CliAbstractSig sig;
		private boolean isDefSig; // true => MethodDef, false => MethodRef

		public CliTypeFnPtr(BinaryReader reader, CliElementType typeCode) throws IOException {
			super(typeCode);
			// TODO: MethodDef and MethodRef sig need to have static isX(reader) methods so I can tell the difference
			//sig = new CliSigMethodRef(blob); // MethodRef is just Def plus possible sentinel and minus potential XORed args in the first byte
		}

		@Override
		public String getRepresentation() {
			return "FnPtr " + sig.getRepresentation();
		}

		@Override
		public String getShortRepresentation() {
			return "FnPtr " + sig.getShortRepresentation();
		}

		@Override
		public DataType getDefinitionDataType() {
			StructureDataType struct = new StructureDataType(new CategoryPath(PATH), "FnPtr", 0);
			struct.add(CliTypeCodeDataType.dataType, "FnPtr", "FnPtr");
			struct.add(DWORD, "MethodDefOrRef", "index into blob heap");
			return struct;
			// TODO: Return the correct size of a signature reference (always 4B in this context perchance?)
		}
	}

	public class CliTypeGenericInst extends CliSigType {
		private CliElementType firstType;
		private int encodedType;
		private int typeSizeBytes;
		private int genArgCount;
		private int countSizeBytes;
		private List<CliSigType> argTypes = new ArrayList<>();

		public CliTypeGenericInst(BinaryReader reader, CliElementType typeCode) throws IOException {
			super(typeCode);
			firstType = CliElementType.fromInt(reader.readNextByte()); // Should be Class or ValueType
			long origIndex = reader.getPointerIndex();
			encodedType = decodeCompressedUnsignedInt(reader);
			typeSizeBytes = (int) (reader.getPointerIndex() - origIndex);
			origIndex = reader.getPointerIndex();
			genArgCount = decodeCompressedUnsignedInt(reader);
			countSizeBytes = (int) (reader.getPointerIndex() - origIndex);
			for (int i = 0; i < genArgCount; i++) {
				try {
					argTypes.add(readCliType(reader));
				}
				catch (InvalidInputException e) {
					e.printStackTrace();
					// Do not add to types
				}
			}
		}

		private String getRepresentation(CliStreamMetadata stream, boolean shortRep) {
			String argTypesRep = "";
			for (int i = 0; i < genArgCount; i++) {
				argTypesRep += argTypes.get(i).getRepresentation();
				if (i != genArgCount - 1) {
					argTypesRep += ", ";
				}
			}

			String typeRep = Integer.toHexString(encodedType);
			if (stream != null) {
				try {
					CliAbstractTableRow row =
						stream.getTable(CliIndexTypeDefOrRef.getTableName(encodedType))
								.getRow(CliIndexTypeDefOrRef.getRowIndex(encodedType));
					if (shortRep) {
						typeRep = row.getShortRepresentation();
					}
					else {
						typeRep = row.getRepresentation();
					}
				}
				catch (InvalidInputException e) {
					e.printStackTrace();
				}
			}

			return String.format("%s %s %d %s", firstType.toString(), typeRep, genArgCount,
				argTypesRep);
		}

		@Override
		public String getRepresentation() {
			return getRepresentation(null);
		}

		@Override
		public String getRepresentation(CliStreamMetadata stream) {
			return getRepresentation(stream, false);
		}

		@Override
		public String getShortRepresentation(CliStreamMetadata stream) {
			return getRepresentation(stream, true);
		}

		@Override
		public DataType getDefinitionDataType() {
			StructureDataType struct = new StructureDataType(new CategoryPath(PATH),
				"GenericInstType" + argTypes.toString(), 0);
			// TODO: the toString() is included in the above line so GenericInst types can contain other GenericInst's, otherwise this is prohibited by StructureDataType
			struct.add(CliTypeCodeDataType.dataType, "GenericInst", "GenericInst");
			struct.add(CliTypeCodeDataType.dataType, "ClassOrValueType", "Class or ValueType");
			struct.add(getDataTypeForBytes(typeSizeBytes), "Type", "TypeDefOrRefOrSpecEncoded");
			struct.add(getDataTypeForBytes(countSizeBytes), "GenArgCount",
				"Number of generics to follow");
			for (CliSigType type : argTypes) {
				struct.add(type.getDefinitionDataType(), "Type", "Generic Type");
			}
			return struct;
		}
	}

	public class CliTypeVarOrMvar extends CliSigType {
		private int number;
		private int numberBytes;

		public CliTypeVarOrMvar(BinaryReader reader, CliElementType typeCode) throws IOException {
			super(typeCode);

			long origIndex = reader.getPointerIndex();
			number = decodeCompressedUnsignedInt(reader);

			long endIndex = reader.getPointerIndex();
			numberBytes = (int) (endIndex - origIndex);
		}

		@Override
		public String getRepresentation() {
			return String.format("%s %d", baseTypeCode.toString(), number);
		}

		@Override
		public DataType getDefinitionDataType() {
			StructureDataType struct =
				new StructureDataType(new CategoryPath(PATH), "VarOrMvar", 0);
			struct.add(BYTE, "Type", "Var or Mvar");
			struct.add(getDataTypeForBytes(numberBytes), "number", null);
			return struct;
		}
	}

	public class CliTypePtr extends CliSigType {
		private List<CliCustomMod> customMods = new ArrayList<>();
		private CliElementType typeCode;

		public CliTypePtr(BinaryReader reader, CliElementType typeCode) throws IOException {
			super(typeCode);

			while (CliCustomMod.isCustomMod(reader)) {
				customMods.add(new CliCustomMod(reader));
			}

			typeCode = CliElementType.fromInt(reader.readNextByte());
		}

		@Override
		public String getRepresentation() {
			String modsRep = "";
			for (CliCustomMod mod : customMods) {
				modsRep += mod.toString() + ", ";
			}
			modsRep = modsRep.substring(0, modsRep.length() - 2);
			return String.format("Ptr %s %s", modsRep, typeCode.toString());
		}

		@Override
		public DataType getDefinitionDataType() {
			StructureDataType struct = new StructureDataType(new CategoryPath(PATH), "Ptr", 0);
			struct.add(CliTypeCodeDataType.dataType, "TypeCode", "Ptr");
			for (CliCustomMod mod : customMods) {
				struct.add(mod.getDefinitionDataType());
			}
			struct.add(CliTypeCodeDataType.dataType, "Type", "type or void");
			return struct;
		}
	}

	public class CliTypeSzArray extends CliSigType {
		private List<CliCustomMod> customMods = new ArrayList<>();
		private CliSigType type;

		public CliTypeSzArray(BinaryReader reader, CliElementType typeCode)
				throws IOException, InvalidInputException {
			super(typeCode);

			while (CliCustomMod.isCustomMod(reader)) {
				customMods.add(new CliCustomMod(reader));
			}

			type = readCliType(reader);
		}

		@Override
		public String getRepresentation(CliStreamMetadata stream) {
			String typeRep;
			if (stream == null) {
				typeRep = type.getRepresentation();
			}
			else {
				typeRep = type.getRepresentation(stream);
			}

			String modsRep = "";
			for (CliCustomMod mod : customMods) {
				modsRep += mod.toString() + ", ";
			}
			if (customMods.size() > 0) {
				modsRep.substring(0, modsRep.length() - 2); // Remove last comma+space
			}
			return String.format("SzArray %s %s", modsRep, typeRep);
		}

		@Override
		public String getRepresentation() {
			return getRepresentation(null);
		}

		@Override
		public DataType getDefinitionDataType() {
			StructureDataType struct = new StructureDataType(new CategoryPath(PATH), "SzArray", 0);
			struct.add(CliTypeCodeDataType.dataType, "TypeCode", "SzArray");
			for (CliCustomMod mod : customMods) {
				struct.add(mod.getDefinitionDataType());
			}
			struct.add(type.getDefinitionDataType(), "Type", "type or void");
			return struct;
		}
	}

	public class CliTypeValueType extends CliSigType {
		private int encodedType;
		private int typeBytes;

		public CliTypeValueType(BinaryReader reader, CliElementType typeCode) throws IOException {
			super(typeCode);

			long origIndex = reader.getPointerIndex();
			encodedType = decodeCompressedUnsignedInt(reader);

			long endIndex = reader.getPointerIndex();
			typeBytes = (int) (endIndex - origIndex);
		}

		@Override
		public String getRepresentation() {
			return "ValueType " + Integer.toHexString(encodedType);
		}

		public String getRepresentation(CliStreamMetadata stream, boolean shortRep) {
			try {
				CliAbstractTableRow row =
					stream.getTable(CliIndexTypeDefOrRef.getTableName(encodedType))
							.getRow(CliIndexTypeDefOrRef.getRowIndex(encodedType));

				return "ValueType " +
					(shortRep ? row.getShortRepresentation() : row.getRepresentation());
			}
			catch (InvalidInputException e) {
				e.printStackTrace();
			}
			return "";
		}

		@Override
		public String getRepresentation(CliStreamMetadata stream) {
			return getRepresentation(stream, false);
		}

		@Override
		public String getShortRepresentation(CliStreamMetadata stream) {
			return getRepresentation(stream, true);
		}

		@Override
		public DataType getDefinitionDataType() {
			StructureDataType struct =
				new StructureDataType(new CategoryPath(PATH), "ValueType", 0);
			struct.add(CliTypeCodeDataType.dataType, "ValueType", "ValueType");
			struct.add(getDataTypeForBytes(typeBytes), "Type", "TypeDefOrRefOrSpecEncoded");
			return struct;
		}
	}

	public CliSigType readCliType(BinaryReader reader) throws IOException, InvalidInputException {
		byte typeByte = reader.readNextByte();
		CliElementType typeCode = CliElementType.fromInt(typeByte);
		if (typeCode == null) {
			throw new InvalidInputException("TypeCode not found at reader index " +
				reader.getPointerIndex() + ". Are you in the right place? (" + typeByte + ")");
		}
		switch (typeCode) {
			case ELEMENT_TYPE_ARRAY:
				return new CliTypeArray(reader, typeCode);

			case ELEMENT_TYPE_CLASS:
				return new CliTypeClass(reader, typeCode);

			case ELEMENT_TYPE_FNPTR:
				return new CliTypeFnPtr(reader, typeCode);

			case ELEMENT_TYPE_GENERICINST:
				return new CliTypeGenericInst(reader, typeCode);

			case ELEMENT_TYPE_MVAR:
			case ELEMENT_TYPE_VAR:
				return new CliTypeVarOrMvar(reader, typeCode);

			case ELEMENT_TYPE_PTR:
				return new CliTypePtr(reader, typeCode);

			case ELEMENT_TYPE_SZARRAY: // Single dimensional, zero-based array, e.g. a vector
				return new CliTypeSzArray(reader, typeCode);

			case ELEMENT_TYPE_VALUETYPE:
				return new CliTypeValueType(reader, typeCode);

			default:
				// Other types: nothing follows
				return new CliTypePrimitive(typeCode);
		}
	}

	// The CustomMod signature part contains a required CMOD option (CMOD_OPT or CMOD_REQD) then a compressed TypeDefOrRefOrSpecEncoded
	public static class CliCustomMod {
		private CliElementType cmod;
		private int typeEncoded;
		private int sizeOfCount;

		public static boolean isCustomMod(BinaryReader reader) throws IOException {
			return (reader.peekNextByte() == CliElementType.ELEMENT_TYPE_CMOD_OPT.id() ||
				reader.peekNextByte() == CliElementType.ELEMENT_TYPE_CMOD_REQD.id());
		}

		public CliCustomMod(BinaryReader reader) throws IOException {
			cmod = CliElementType.fromInt(reader.readNextByte());

			long origIndex = reader.getPointerIndex();
			typeEncoded = decodeCompressedUnsignedInt(reader);

			long endIndex = reader.getPointerIndex();
			sizeOfCount = (int) (endIndex - origIndex);
		}

		public CliElementType getCMOD() {
			return cmod;
		}

		public int getTypeEncoded() {
			return typeEncoded;
		}

		public CliTypeTable getTable() {
			try {
				return CliIndexTypeDefOrRef.getTableName(typeEncoded);
			}
			catch (InvalidInputException e) {
				return null;
			}
		}

		public int getRowIndex() {
			return CliIndexTypeDefOrRef.getRowIndex(typeEncoded);
		}

		public CliAbstractTableRow getRow(CliStreamMetadata stream) {
			return stream.getTable(getTable()).getRow(getRowIndex());
		}

		public DataType getDefinitionDataType() {
			StructureDataType struct = new StructureDataType(new CategoryPath(PATH),
				CliCustomMod.class.getSimpleName(), 0);
			struct.add(BYTE, "CMOD", "CMOD_OPT or CMOD_REQD");
			struct.add(getDataTypeForBytes(this.sizeOfCount), "Type",
				"TypeDefOrRefOrSpec encoded type");
			return struct;
		}

		public String getRepresentation(CliStreamMetadata stream) {
			return String.format("%s %s", cmod.toString(), getRow(stream));
		}

		public String getRepresentation() {
			return String.format("%s %x", cmod.toString(), typeEncoded);
		}
	}

	// The only possible constraint is ELEMENT_TYPE_PINNED (CliTypeCode.Pinned)
	public static class CliConstraint {
		private CliElementType constraint;

		public static boolean isConstraint(BinaryReader reader) throws IOException {
			return (reader.peekNextByte() == CliElementType.ELEMENT_TYPE_PINNED.id());
		}

		public CliConstraint(BinaryReader reader) throws IOException {
			constraint = CliElementType.fromInt(reader.readNextByte());
		}

		public CliElementType getConstraint() {
			return constraint;
		}

		public String getRepresentation() {
			if (constraint == CliElementType.ELEMENT_TYPE_PINNED) {
				return constraint.toString();
			}
			return String.format("Invalid Constraint (%s - %x)", constraint.toString(),
				constraint.id());
		}
	}

	public class CliTypeBase implements CliRepresentable {
		private List<CliCustomMod> customMods = new ArrayList<>();
		private boolean constraint = false;
		private boolean byRef = false;
		private CliSigType type;

		private boolean isVoidAllowed = false;

		public CliTypeBase(BinaryReader reader, boolean isRetType)
				throws IOException, InvalidInputException {
			this.isVoidAllowed = isRetType;

			// Get any custom modifiers
			while (CliCustomMod.isCustomMod(reader)) {
				customMods.add(new CliCustomMod(reader));
			}

			// Check to see if it's a constrained variable
			if (CliConstraint.isConstraint(reader)) {
				constraint = true;
				reader.readNextByte();
			}

			// Check to see if it's a ByRef
			byte byRefCheck = reader.peekNextByte();
			if (byRefCheck == CliElementType.ELEMENT_TYPE_BYREF.id()) {
				byRef = true;
				reader.readNextByte();
			}

			type = readCliType(reader);
		}

		public CliSigType getType() {
			return type;
		}

		public List<CliCustomMod> getCustomMods() {
			return customMods;
		}

		public boolean isByRef() {
			return byRef;
		}

		public boolean isConstrained() {
			return constraint;
		}

		private String getRepresentationCommon(CliStreamMetadata stream, boolean shortRep) {
			String rep = "";

			for (CliCustomMod mod : customMods) {
				rep += mod.getRepresentation() + "; ";
			}

			if (customMods.size() > 0) {
				rep = rep.substring(0, rep.length() - 2) + " ";
			}

			if (constraint) {
				rep += "constrained ";
			}

			if (byRef) {
				rep += "byref ";
			}

			// The one special case value we have is the SENTINEL, which
			// we represent as "..." to denote that VarArgs might be passed
			// after the declared parameters
			if (type.baseTypeCode == CliElementType.ELEMENT_TYPE_SENTINEL) {
				rep = "...";
			}
			else {
				rep += getRepresentationOf(type, stream, shortRep);
			}

			return rep;
		}

		@Override
		public String getRepresentation() {
			return getRepresentationCommon(null, false);
		}

		@Override
		public String getRepresentation(CliStreamMetadata stream) {
			return getRepresentationCommon(stream, false);
		}

		@Override
		public String getShortRepresentation() {
			return getRepresentationCommon(null, true);
		}

		@Override
		public String getShortRepresentation(CliStreamMetadata stream) {
			return getRepresentationCommon(stream, true);
		}

		public DataType getDefinitionDataType() {
			StructureDataType struct = new StructureDataType(new CategoryPath(PATH), "Type", 0);

			for (CliCustomMod mod : customMods) {
				struct.add(mod.getDefinitionDataType(), "CustomMod", null);
			}

			if (constraint) {
				struct.add(BYTE, "CONSTRAINT", "Constrained");
			}

			if (byRef) {
				struct.add(BYTE, "BYREF", "By reference");
			}
			struct.add(type.getDefinitionDataType(), "Type", null);
			return struct;
		}

		public DataType getExecutionDataType() {
			return type.getExecutionDataType();
		}
	}

	public class CliParam extends CliTypeBase {
		public CliParam(BinaryReader reader) throws IOException, InvalidInputException {
			super(reader, false);
		}
	}

	public class CliRetType extends CliTypeBase {
		public CliRetType(BinaryReader reader) throws IOException, InvalidInputException {
			super(reader, true);
		}
	}

	public class CliArrayShape {
		private int rank;
		private int rankBytes;
		private int numSizes;
		private int numSizesBytes;
		private int size[];
		private int sizeBytes[];
		private int numLoBounds;
		private int numLoBoundsBytes;
		private int loBound[];
		private int loBoundBytes[];

		public CliArrayShape(BinaryReader reader) throws IOException {
			long origIndex = reader.getPointerIndex();
			rank = decodeCompressedUnsignedInt(reader);
			rankBytes = (int) (reader.getPointerIndex() - origIndex);
			origIndex = reader.getPointerIndex();

			numSizes = decodeCompressedUnsignedInt(reader);
			numSizesBytes = (int) (reader.getPointerIndex() - origIndex);
			origIndex = reader.getPointerIndex();

			size = new int[numSizes];
			sizeBytes = new int[numSizes];
			for (int i = 0; i < numSizes; i++) {
				size[i] = decodeCompressedUnsignedInt(reader);
				sizeBytes[i] = (int) (reader.getPointerIndex() - origIndex);
				origIndex = reader.getPointerIndex();
			}

			numLoBounds = decodeCompressedUnsignedInt(reader);
			numLoBoundsBytes = (int) (reader.getPointerIndex() - origIndex);
			origIndex = reader.getPointerIndex();

			loBound = new int[numLoBounds];
			loBoundBytes = new int[numLoBounds];
			for (int i = 0; i < numLoBounds; i++) {
				loBound[i] = decodeCompressedUnsignedInt(reader);
				loBoundBytes[i] = (int) (reader.getPointerIndex() - origIndex);
				origIndex = reader.getPointerIndex();
			}
		}

		public DataType getDefinitionDataType() {
			StructureDataType struct =
				new StructureDataType(new CategoryPath(PATH), "ArrayShape", 0);
			struct.add(getDataTypeForBytes(rankBytes), "Rank", "Number of dimensions in array");
			struct.add(getDataTypeForBytes(numSizesBytes), "NumSizes", "Number of sizes to follow");
			for (int i = 0; i < sizeBytes.length; i++) {
				struct.add(getDataTypeForBytes(sizeBytes[i]), "Size" + i, "Coded integer size");
			}
			struct.add(getDataTypeForBytes(numLoBoundsBytes), "NumLoBounds",
				"Number of lower bounds in array");
			for (int i = 0; i < loBoundBytes.length; i++) {
				struct.add(getDataTypeForBytes(loBoundBytes[i]), "LoBound" + i,
					"Coded integer lower bound");
			}
			return struct;
		}

		public String getRepresentation() {
			return "ArrayShapeNotYetRepresented"; // TODO: Give back  a pretty representation of ArrayShape
		}
	}
}
```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/blobs/CliBlob.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.blobs;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.StructConverter;
import ghidra.program.model.data.*;
import ghidra.util.exception.AssertException;

/**
 * Describes a blob in the #Blob heap. Format is a coded size then the blob contents.
 * <p>
 * Paraphrasing from ISO 23271:2012 11.24.2.4 (p272):
 * - If the first one byte of the 'blob' is 0bbbbbbb_2: size is bbbbbbb_2 bytes.
 * - {@literal If the first two bytes are 10bbbbbb_2 and x: size is (bbbbbb_2 << 8 + x) bytes.}
 * - {@literal If the first four bytes are 110bbbbb_2, x, y, and z: size is (bbbbb_2<<24 + x<<16 + y<<8 + z) bytes.}
 * The first entry in the heap is the empty 'blob' consisting of a single zero byte.
 */
public class CliBlob implements StructConverter {

	public static final String PATH = "/PE/CLI/Blobs";

	private int streamIndex;
	private BinaryReader reader;

	protected long blobOffset;
	protected long contentsOffset;
	protected int contentsSize;

	/**
	 * Creates a new blob from the given reader, which should be positioned at the start
	 * of the blob.  The reader will be positioned directly after the blob upon completion
	 * of the constructor.
	 * 
	 * @param streamIndex The blob's stream index.
	 * @param reader The reader to use to read the blob.
	 * @throws IOException if there was a problem reading the blob.
	 */
	public CliBlob(int streamIndex, BinaryReader reader) throws IOException {
		this.streamIndex = streamIndex;
		this.reader = reader;

		blobOffset = reader.getPointerIndex();
		contentsSize = parseCodedSize(reader);
		contentsOffset = reader.getPointerIndex();
		reader.setPointerIndex(reader.getPointerIndex() + contentsSize);
	}

	/**
	 * Creates a new blob that is a copy of the given blob.
	 * 
	 * @param blob The blob to copy.
	 */
	protected CliBlob(CliBlob blob) {
		this.streamIndex = blob.streamIndex;
		this.reader = blob.reader;
		this.blobOffset = blob.blobOffset;
		this.contentsSize = blob.contentsSize;
		this.contentsOffset = blob.contentsOffset;
	}

	/**
	 * Creates a new blob that is a copy of the given blob but with a new reader.  
	 * The provided reader must be positioned to the start of the new blob.
	 * 
	 * @param blob The blob to copy.
	 * @param reader The reader to use to read the new blob.  It must be positioned
	 *   to the start of the new blob.
	 */
	protected CliBlob(CliBlob blob, BinaryReader reader) {
		this.streamIndex = blob.streamIndex;
		this.reader = reader;
		this.blobOffset = reader.getPointerIndex();
		this.contentsSize = blob.contentsSize;
		this.contentsOffset = this.blobOffset + this.contentsSize;
	}

	/**
	 * Gets the blob's size in bytes (includes all fields).
	 * 
	 * @return The blob's size in bytes.
	 */
	public int getSize() {
		return (int) (contentsOffset - blobOffset) + contentsSize;
	}

	/**
	 * Gets a new binary reader positioned at the start of this blob's contents.
	 * 
	 * @return A new binary reader positioned at the start of this blob's contents.
	 */
	public BinaryReader getContentsReader() {
		BinaryReader contentsReader =
			new BinaryReader(reader.getByteProvider(), reader.isLittleEndian());
		contentsReader.setPointerIndex(contentsOffset);
		return contentsReader;
	}

	/**
	 * Gets the blob's contents size in bytes.
	 * 
	 * @return The blob's contents size in bytes.
	 */
	public int getContentsSize() {
		return contentsSize;
	}

	/**
	 * Gets the blob's contents.
	 * 
	 * @return the blob's contents.  Could be null if there was a problem reading the 
	 *   contents.
	 */
	public byte[] getContents() {
		long origPointerIndex = reader.getPointerIndex();
		try {
			return reader.readByteArray(contentsOffset, contentsSize);
		}
		catch (IOException e) {
			return null;
		}
		finally {
			reader.setPointerIndex(origPointerIndex);
		}
	}

	/**
	 * Gets the string representation of this blob.
	 * 
	 * @return The string representation of this blob.
	 */
	public String getRepresentation() {
		return "Blob (" + getContentsDataType().getDisplayName() + ")";
	}

	/**
	 * Checks to see whether or not this blob is little endian.
	 * 
	 * @return True if this blob is little endian; false if big endian.
	 */
	public boolean isLittleEndian() {
		return reader.isLittleEndian();
	}

	@Override
	public DataType toDataType() {
		Structure struct = new StructureDataType(new CategoryPath(PATH), "Blob_" + getName(), 0);
		struct.add(getSizeDataType(), "Size", "coded integer - blob size");
		struct.add(getContentsDataType(), getContentsName(), getContentsComment());
		return struct;
	}

	/**
	 * Gets the index into the blob stream of this blob.
	 * 
	 * @return The index into the blob stream of this blob.
	 */
	public int getStreamIndex() {
		return streamIndex;
	}

	/**
	 * Gets the name of this blob.
	 * 
	 * @return The name of this blob.
	 */
	public String getName() {
		return getContentsName() + "_" + streamIndex;
	}

	/**
	 * Gets the name associated with this blob's contents.
	 * 
	 * @return The name associated with this blob's contents.
	 */
	public String getContentsName() {
		return "Generic";
	}

	/**
	 * Gets the data type associated with this blob's contents.
	 * 
	 * @return The data type associated with this blob's contents.
	 */
	public DataType getContentsDataType() {
		return new ArrayDataType(BYTE, this.contentsSize, 1);
	}
	
	/**
	 * Gets the comment associated with this blob's contents.
	 * 
	 * @return The comment associated with this blob's contents.
	 */
	public String getContentsComment() {
		return "Undefined blob contents";
	}

	/**
	 * Gets the proper data type for the blob's size field.
	 * 
	 * @return The proper data type for the blob's size field.
	 */
	public DataType getSizeDataType() {
		int n = (int) (contentsOffset - blobOffset);
		switch (n) {
			case 4:
				return DWORD;
			case 2:
				return WORD;
			case 1:
				return BYTE;
			default:
				throw new AssertException("Unsupported CLI blob size: " + n);
		}
	}

	/**
	 * Parses the coded blob size that the given reader is positioned at.
	 * 
	 * @param reader The reader to use to read the coded blob size.
	 * @return The size of the blob contents in bytes.
	 * @throws IOException if there is a problem reading the coded size field.
	 */
	static int parseCodedSize(BinaryReader reader) throws IOException {
		byte one = reader.readNextByte();
		int size = 0;
		if ((one & 0x80) == 0) {
			size = (one & ~0x80) & 0xff; // 0xff to force this to be positive
		}
		else if ((one & 0xC0) == 0x80) {
			byte two = reader.readNextByte();
			size = (((one & ~0xC0) & 0xff )<< 8) + (two & 0xff); 
		}
		else if ((one & 0xE0) == 0xC0) {
			byte two = reader.readNextByte();
			byte three = reader.readNextByte();
			byte four = reader.readNextByte();
			size = (((one & ~0xE0) & 0xff) << 24) + ((two & 0xff) << 16) + ((three & 0xff) << 8) + (four & 0xff);
		}
		return size;
	}
	
	/* The following methods deal with compressed unsigned/signed integers stored in blobs and signatures -- not the Blob size itself. */
	
	// Uses the test cases in the CLI ISO spec to test our bit manipulation
	public static void testSizeDecoding() {
		System.out.println(decodeCompressedUnsigned((byte)0x03) + " " + decodeCompressedUnsigned((byte)0x7F) + " " + decodeCompressedUnsigned((short)0x8080) + " " + 
				decodeCompressedUnsigned((short)0xAE57) + " " + decodeCompressedUnsigned((short)0xBFFF) + " " + decodeCompressedUnsigned(0xC0004000) + " " + decodeCompressedUnsigned(0xDFFFFFFF) + " ");
		System.out.println(decodeCompressedSigned((byte)0x06) + " " + decodeCompressedSigned((byte)0x7B) + " " + decodeCompressedSigned((short)0x8080) + " " + decodeCompressedSigned((byte)0x01) + " " +  
				decodeCompressedSigned(0xC0004000) + " " + decodeCompressedSigned((short)0x8001) + " " + decodeCompressedSigned(0xDFFFFFFE) + " " + decodeCompressedSigned(0xC0000001) + " ");
	}
	
	private static int getNumberBytesInCodedInt(byte firstByte) {
		if ((firstByte & 0x80) == 0)
			return 1;
		if ((firstByte & 0xc0) == 0x80)
			return 2;
		if ((firstByte & 0xe0) == 0xc0)
			return 4;
		return 0;
	}
	
	/**
	 * Rotates toRotate circularly right using a maximum of bitSize bits for the numeric representation.
	 * Bits must be in the rightmost (least significant) positions.
	 */
	private static int rotateCircularRight(int toRotate, int bitSize) {
		toRotate &= ((1 << bitSize) - 1); // Mask any bits more than bitSize.
		if ((toRotate & 0x1) != 0)
			toRotate |= (1 << bitSize); // Right rotate the least significant bit.
		toRotate = toRotate >> 1;
		if ((toRotate & (1 << (bitSize - 1))) != 0) { // negative number
			toRotate = ~toRotate;
			toRotate += 1;
			toRotate &= ((1 << bitSize) - 1);
			toRotate *= -1;
		}
		return toRotate;
	}
	
	/* For all decoding, note that per ESO 23271.II.23.2, CLI Compressed Integers are physically encoded using big endian byte order. */
	public static int decodeCompressedSigned(byte codedSize) {
		return rotateCircularRight(codedSize, 7);
	}
	
	public static int decodeCompressedSigned(short codedSize) {
		return rotateCircularRight(codedSize, 14);
	}
	
	public static int decodeCompressedSigned(int codedSize) {
		return rotateCircularRight(codedSize, 29);
	}
	
	public static int decodeCompressedUnsigned(byte codedSize) {
		// Header bit is 0, so no need to mask it off.
		return (codedSize & 0xff); // enforce signedness
	}
	
	public static int decodeCompressedUnsigned(short codedSize) {
		codedSize &= (~(0xc000)); // Get rid of header bits "10"
		return (codedSize & 0xffff); // enforce signedness
	}
	
	public static int decodeCompressedUnsigned(int codedSize) {
		codedSize = codedSize & (~(0xe0000000));
		return (codedSize &= 0xffffffff); // enforce signedness
	}

	private static int decodeCompressedInt(BinaryReader reader, boolean signed) throws IOException {
		byte firstByte = reader.peekNextByte();
		boolean isLittleEndian = reader.isLittleEndian();
		reader.setLittleEndian(false);
		int numBytes = getNumberBytesInCodedInt(firstByte);
		int decodedSize = 0;
		switch (numBytes) {
			case 1:
				byte codedByte = reader.readNextByte();
				if (signed)
					decodedSize = decodeCompressedSigned(codedByte);
				else
					decodedSize = decodeCompressedUnsigned(codedByte);
				break;
				
			case 2:
				short codedShort = reader.readNextShort();
				if (signed)
					decodedSize = decodeCompressedSigned(codedShort);
				else
					decodedSize = decodeCompressedUnsigned(codedShort);
				break;
				
			case 4:
				int codedInt = reader.readNextInt();
				if (signed)
					decodedSize = decodeCompressedSigned(codedInt);
				else
					decodedSize = decodeCompressedUnsigned(codedInt);
				break;
				
			default:
				break;
		}
		reader.setLittleEndian(isLittleEndian);
		return decodedSize;
	}
	
	public static int decodeCompressedSignedInt(BinaryReader reader) throws IOException {
		return decodeCompressedInt(reader, true);
	}
	
	public static int decodeCompressedUnsignedInt(BinaryReader reader) throws IOException {
		return decodeCompressedInt(reader, false);
	}
	
	public static DataType getDataTypeForBytes(int numBytes) {
		switch (numBytes) {
			case 1:
				return BYTE;
				
			case 2:
				return WORD;
				
			case 4:
				return DWORD;
				
			default:
				return null;
		}
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/blobs/CliBlobMarshalSpec.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.blobs;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.blobs.CliAbstractSig.CliElementType;
import ghidra.program.model.data.*;

public class CliBlobMarshalSpec extends CliBlob {
	private static final int INIT_VALUE = -1;

	private CliNativeType nativeIntrinsic;
	private CliNativeType arrayElemType;
	private int paramNum = INIT_VALUE;
	private int paramNumBytes;
	private int numElem = INIT_VALUE;
	private int numElemBytes;

	public enum CliNativeType {
		NATIVE_TYPE_END(0x00),
		NATIVE_TYPE_VOID(0x01),
		NATIVE_TYPE_BOOLEAN(0x02),
		NATIVE_TYPE_I1(0x03),
		NATIVE_TYPE_U1(0x04),
		NATIVE_TYPE_I2(0x05),
		NATIVE_TYPE_U2(0x06),
		NATIVE_TYPE_I4(0x07),
		NATIVE_TYPE_U4(0x08),
		NATIVE_TYPE_I8(0x09),
		NATIVE_TYPE_U8(0xa),
		NATIVE_TYPE_R4(0x0b),
		NATIVE_TYPE_R8(0x0c),
		NATIVE_TYPE_SYSCHAR(0x0d),
		NATIVE_TYPE_VARIANT(0x0e),
		NATIVE_TYPE_CURRENCY(0x0f),
		NATIVE_TYPE_PTR(0x10),

		NATIVE_TYPE_DECIMAL(0x11),
		NATIVE_TYPE_DATE(0x12),
		NATIVE_TYPE_BSTR(0x13),
		NATIVE_TYPE_LPSTR(0x14),
		NATIVE_TYPE_LPWSTR(0x15),
		NATIVE_TYPE_LPTSTR(0x16),
		NATIVE_TYPE_FIXEDSYSSTRING(0x17),
		NATIVE_TYPE_OBJECTREF(0x18),
		NATIVE_TYPE_IUNKNOWN(0x19),
		NATIVE_TYPE_IDISPATCH(0x1a),
		NATIVE_TYPE_STRUCT(0x1b),
		NATIVE_TYPE_INTF(0x1c),
		NATIVE_TYPE_SAFEARRAY(0x1d),
		NATIVE_TYPE_FIXEDARRAY(0x1e),
		NATIVE_TYPE_INT(0x1f),
		NATIVE_TYPE_UINT(0x20),

		NATIVE_TYPE_NESTEDSTRUCT(0x21),
		NATIVE_TYPE_BYVALSTR(0x22),
		NATIVE_TYPE_ANSIBSTR(0x23),
		NATIVE_TYPE_TBSTR(0x24),
		NATIVE_TYPE_VARIANTBOOL(0x25),
		NATIVE_TYPE_FUNC(0x26),

		NATIVE_TYPE_ASANY(0x28),
		NATIVE_TYPE_ARRAY(0x2a),
		NATIVE_TYPE_LPSTRUCT(0x2b),
		NATIVE_TYPE_CUSTOMMARSHALER(0x2c),
		NATIVE_TYPE_ERROR(0x2d),
		NATIVE_TYPE_IINSPECTABLE(0x2e),
		NATIVE_TYPE_HSTRING(0x2f),

		NATIVE_TYPE_MAX(0x50);

		private final int id;

		CliNativeType(int id) {
			this.id = id;
		}

		public int id() {
			return id;
		}

		public static CliNativeType fromInt(int id) {
			CliNativeType[] values = CliNativeType.values();
			for (CliNativeType value : values) {
				if (value.id == id) {
					return value;
				}
			}
			return null;
		}
	}

	public static class CliNativeTypeDataType extends EnumDataType {

		public final static CliNativeTypeDataType dataType = new CliNativeTypeDataType();

		public CliNativeTypeDataType() {
			super(new CategoryPath(PATH), "NativeType", 1);

			for (CliElementType c : CliElementType.values()) {
				add(c.toString(), c.id());
			}
		}
	}

	public CliBlobMarshalSpec(CliBlob blob) throws IOException {
		super(blob);

		BinaryReader reader = blob.getContentsReader();
		nativeIntrinsic = CliNativeType.fromInt(reader.readNextByte());
		if (nativeIntrinsic == CliNativeType.NATIVE_TYPE_ARRAY ||
			nativeIntrinsic == CliNativeType.NATIVE_TYPE_FIXEDARRAY) {
			arrayElemType = CliNativeType.fromInt(reader.readNextByte());

			// There is no sentinel other than blob size that indicates whether 0, 1, or 2 compressed unsigned ints follow
			if (contentsSize > 2) {
				long origIndex = reader.getPointerIndex();
				paramNum = decodeCompressedUnsignedInt(reader);
				paramNumBytes = (int) (reader.getPointerIndex() - origIndex);
				if (contentsSize > (2 + paramNumBytes)) {
					origIndex = reader.getPointerIndex();
					numElem = decodeCompressedUnsignedInt(reader);
					numElemBytes = (int) (reader.getPointerIndex() - origIndex);
				}
			}
		}
	}

	@Override
	public DataType getContentsDataType() {
		StructureDataType struct = new StructureDataType(new CategoryPath(PATH), getName(), 0);
		struct.add(CliNativeTypeDataType.dataType, "NativeIntrinsic", "Type");
		if (arrayElemType != null) {
			struct.add(CliNativeTypeDataType.dataType, "ArrayElemTyp", null);
			if (paramNum != INIT_VALUE) {
				struct.add(getDataTypeForBytes(paramNumBytes), "ParamNum",
					"which parameter provides number of elems for this array");
				if (numElem != INIT_VALUE) {
					struct.add(getDataTypeForBytes(numElemBytes), "NumElem",
						"number of elements or additional elements");
				}
			}
		}
		return struct;
	}

	@Override
	public String getContentsName() {
		return "MarshalSpec";
	}

	@Override
	public String getContentsComment() {
		return "Defines a native type for marshalling between managed/unmanaged code";
	}

	@Override
	public String getRepresentation() {
		return "Blob (" + getContentsDataType().getDisplayName() + ")";
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/blobs/CliSigField.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.blobs;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import ghidra.program.model.data.*;
import ghidra.util.Msg;
import ghidra.util.exception.InvalidInputException;

public class CliSigField extends CliAbstractSig {
	private CliParam type;

	private static final byte CLISIGFIELD_PROLOG = 0x06;

	public CliSigField(CliBlob blob) throws IOException {
		super(blob);

		BinaryReader reader = getContentsReader();

		byte prolog = reader.readNextByte();
		if (prolog != CLISIGFIELD_PROLOG) {
			Msg.warn(this,
				"CliSigField had unexpected prolog (0x" + Integer.toHexString(prolog) + ").");
			return;
		}

		try {
			type = new CliParam(reader);
		}
		catch (InvalidInputException e) {
			type = null;
		}
	}

	/**
	 * Checks whether this could *possibly* be a FieldSig. Only looks at the identifier byte. Useful for signature index
	 * that could be to different kinds of signatures.
	 * @param blob
	 * @return
	 * @throws IOException
	 */
	public static boolean isFieldSig(CliBlob blob) throws IOException {
		return blob.getContentsReader().readNextByte() == CLISIGFIELD_PROLOG;
	}

	public CliParam getType() {
		return type;
	}

	@Override
	public DataType getContentsDataType() {
		StructureDataType struct = new StructureDataType(new CategoryPath(PATH), getName(), 0);
		struct.add(BYTE, "FIELD", "Magic (0x06)");
		struct.add(type.getDefinitionDataType(), "Type", null);
		return struct;
	}

	@Override
	public String getContentsName() {
		return "FieldSig";
	}

	@Override
	public String getContentsComment() {
		return "Type information for Field";
	}

	@Override
	public String getRepresentationCommon(CliStreamMetadata stream, boolean isShort) {
		return getRepresentationOf(type, stream, isShort);
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/blobs/CliSigLocalVar.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.blobs;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import ghidra.program.model.data.*;
import ghidra.util.Msg;
import ghidra.util.exception.InvalidInputException;

public class CliSigLocalVar extends CliAbstractSig {
	private int sizeOfCount;
	private CliParam types[];

	private static final int CLISIGLOCALVAR_PROLOG = 0x07;

	public CliSigLocalVar(CliBlob blob) throws IOException {
		super(blob);

		BinaryReader reader = getContentsReader();

		// Check the prolog byte
		byte prolog = reader.readNextByte();
		if (prolog != CLISIGLOCALVAR_PROLOG) {
			Msg.warn(this,
				"LocalVarSig had unexpected prolog (0x" + Integer.toHexString(prolog) + ")");
			return;
		}

		long origIndex = reader.getPointerIndex();
		int typesCount = decodeCompressedUnsignedInt(reader);
		sizeOfCount = (int) (reader.getPointerIndex() - origIndex);
		types = new CliParam[typesCount];

		// CliParam will parse modifiers, constraints, and ByRef notations
		for (byte i = 0; i < typesCount; i++) {
			try {
				types[i] = new CliParam(reader);
			}
			catch (InvalidInputException e) {
				types[i] = null;
				e.printStackTrace();
			}
		}
	}

	/**
	 * Checks whether this could *possibly* be a LocalVarSig. Only looks at the identifier byte. Useful for signature index
	 * that could be to different kinds of signatures.
	 * @param blob
	 * @return
	 * @throws IOException
	 */
	public static boolean isLocalVarSig(CliBlob blob) throws IOException {
		return blob.getContentsReader().readNextByte() == CLISIGLOCALVAR_PROLOG;
	}

	@Override
	public String getContentsName() {
		return "LocalVarSig";
	}

	@Override
	public String getContentsComment() {
		return "Contains signature for function locals";
	}

	@Override
	public DataType getContentsDataType() {
		StructureDataType struct = new StructureDataType(new CategoryPath(PATH), getName(), 0);
		struct.add(BYTE, "LOCAL_SIG", "Magic (0x07)");
		struct.add(getDataTypeForBytes(sizeOfCount), "Count", "Number of types to follow");
		for (CliParam param : types) {
			struct.add(param.getDefinitionDataType(), "Type", null);
		}
		return struct;
	}

	@Override
	public String getRepresentationCommon(CliStreamMetadata stream, boolean isShort) {
		String rep = "";
		for (CliParam param : types) {
			rep += getRepresentationOf(param, stream, isShort) + ", ";
		}
		if (types.length > 0) {
			rep = rep.substring(0, rep.length() - 2); // remove comma+space
		}
		return rep;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/blobs/CliSigMethodDef.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.blobs;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import ghidra.program.model.data.*;
import ghidra.util.exception.InvalidInputException;

public class CliSigMethodDef extends CliAbstractSig {

	private CliRetType retType;
	private CliParam params[];
	private int sizeOfCount;
	private int genericParamCount;
	private byte flags;
	private int sizeOfGenericCount;

	private final int METHODDEFSIG_FLAGS_DEFAULT = 0x00;
	private final int METHODDEFSIG_FLAGS_VARARG = 0x05;
	private final int METHODDEFSIG_FLAGS_GENERIC = 0x10;
	private final int METHODDEFSIG_FLAGS_HASTHIS = 0x20;
	private final int METHODDEFSIG_FLAGS_EXPLICITTHIS = 0x40;

	public CliSigMethodDef(CliBlob blob) throws IOException {
		super(blob);

		// Read and determine meaning of flag byte
		BinaryReader reader = getContentsReader();
		flags = reader.readNextByte();

		if ((flags & METHODDEFSIG_FLAGS_GENERIC) == METHODDEFSIG_FLAGS_GENERIC) {
			long origIndex = reader.getPointerIndex();
			genericParamCount = decodeCompressedUnsignedInt(reader);
			sizeOfGenericCount = (int) (reader.getPointerIndex() - origIndex);
		}

		// Get parameter count and return type
		long origIndex = reader.getPointerIndex();
		int paramCount = decodeCompressedUnsignedInt(reader);
		this.sizeOfCount = (int) (reader.getPointerIndex() - origIndex);
		try {
			retType = new CliRetType(reader);
		}
		catch (InvalidInputException e) {
			retType = null;
		}

		// Get parameters
		params = new CliParam[paramCount];
		for (int i = 0; i < paramCount; i++) {
			try {
				params[i] = new CliParam(reader);
			}
			catch (InvalidInputException e) {
				/* Do not add to params[] */ }
		}
	}

	@Override
	public String getContentsName() {
		return "MethodDefSig";
	}

	@Override
	public String getContentsComment() {
		return "Type info for method return and params";
	}

	@Override
	public DataType getContentsDataType() {
		StructureDataType struct = new StructureDataType(new CategoryPath(PATH), getName(), 0);
		struct.add(BYTE, "flags", "ORed calling convention and THIS presence"); // TODO: enum
		if (genericParamCount > 0) {
			struct.add(getDataTypeForBytes(sizeOfGenericCount), "GenParamCount",
				"Number of generic paramameters for the method");
		}
		struct.add(getDataTypeForBytes(sizeOfCount), "Count",
			"Number of param types to follow RetType");
		struct.add(retType.getDefinitionDataType(), "RetType", null);
		for (CliParam param : params) {
			struct.add(param.getDefinitionDataType(), null, null);
		}
		return struct;
	}

	public CliRetType getReturnType() {
		return retType;
	}

	public CliParam[] getParamTypes() {
		return params.clone();
	}

	public boolean hasThis() {
		return (flags & METHODDEFSIG_FLAGS_HASTHIS) == METHODDEFSIG_FLAGS_HASTHIS;
	}

	public boolean hasExplicitThis() {
		return (flags & METHODDEFSIG_FLAGS_EXPLICITTHIS) == METHODDEFSIG_FLAGS_EXPLICITTHIS;
	}

	public boolean hasVarArgs() {
		return (flags & METHODDEFSIG_FLAGS_VARARG) == METHODDEFSIG_FLAGS_VARARG;
	}

	public Boolean hasGenericArgs() {
		return (flags & METHODDEFSIG_FLAGS_GENERIC) == METHODDEFSIG_FLAGS_GENERIC;
	}

	@Override
	protected String getRepresentationCommon(CliStreamMetadata stream, boolean isShort) {
		String rep = getRepresentationOf(retType, stream, isShort);
		rep += " fn(";
		for (CliParam param : params) {
			if (param == null) {
				rep += "unidentified_param_type, ";
			}
			else {
				rep += getRepresentationOf(param, stream, isShort) + ", ";
			}
		}
		if (params.length > 0) {
			rep = rep.substring(0, rep.length() - 2); // Take off last comma+space
		}
		rep += ")";
		return rep;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/blobs/CliSigMethodRef.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.blobs;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import ghidra.program.model.data.*;
import ghidra.util.exception.InvalidInputException;

public class CliSigMethodRef extends CliAbstractSig {

	private CliRetType retType;
	private CliParam params[];
	private int sizeOfCount;
	private byte flags;
	private int sentinelIndex; // SENTINEL is before the parameter index in this field

	private final int METHODREFSIG_FLAGS_DEFAULT = 0x00;
	private final int METHODREFSIG_FLAGS_VARARG = 0x05;
	private final int METHODREFSIG_FLAGS_HASTHIS = 0x20;
	private final int METHODREFSIG_FLAGS_EXPLICITTHIS = 0x40;

	public CliSigMethodRef(CliBlob blob) throws IOException {
		super(blob);
		sentinelIndex = -1;

		// Flags is similar to a MethodDef unless vararg is used.
		BinaryReader reader = getContentsReader();
		flags = reader.readNextByte();

		long origIndex = reader.getPointerIndex();
		int paramCount = decodeCompressedUnsignedInt(reader);
		this.sizeOfCount = (int) (reader.getPointerIndex() - origIndex);
		try {
			retType = new CliRetType(reader);
		}
		catch (InvalidInputException e) {
			retType = null;
		}
		params = new CliParam[paramCount];
		for (int i = 0; i < paramCount; i++) {
			if (reader.peekNextByte() == CliElementType.ELEMENT_TYPE_SENTINEL.id()) {
				reader.readNextByte();
				sentinelIndex = i;
			}
			try {
				params[i] = new CliParam(reader);
			}
			catch (InvalidInputException e) {
				params[i] = null;
			}
		}
	}

	@Override
	public String getContentsName() {
		return "MethodRefSig";
	}

	@Override
	public String getContentsComment() {
		return "Type info for imported method return and params";
	}

	@Override
	public DataType getContentsDataType() {
		StructureDataType struct = new StructureDataType(new CategoryPath(PATH), getName(), 0);
		struct.add(BYTE, "flags", "ORed VARARG and HASTHIS/EXPLICITTHIS");
		struct.add(getDataTypeForBytes(sizeOfCount), "ParamCount",
			"Number of param types to follow RetType");
		struct.add(retType.getDefinitionDataType(), "RetType", null);
		for (int i = 0; i < params.length; i++) {
			struct.add(params[i].getDefinitionDataType(), "Type" + i, null);
		}
		return struct;
	}

	public CliRetType getReturnType() {
		return retType;
	}

	public CliParam[] getParams() {
		return params.clone();
	}

	public boolean hasThis() {
		return (flags & METHODREFSIG_FLAGS_HASTHIS) == METHODREFSIG_FLAGS_HASTHIS;
	}

	public boolean hasExplicitThis() {
		return (flags & METHODREFSIG_FLAGS_EXPLICITTHIS) == METHODREFSIG_FLAGS_EXPLICITTHIS;
	}

	public boolean hasVarArgs() {
		return (flags & METHODREFSIG_FLAGS_VARARG) == METHODREFSIG_FLAGS_VARARG;
	}

	@Override
	protected String getRepresentationCommon(CliStreamMetadata stream, boolean isShort) {
		String rep = getRepresentationOf(retType, stream, isShort);
		rep += " fn(";

		for (CliParam param : params) {
			if (param == null) {
				rep += "unidentified_param_type, ";
			}
			else {
				rep += getRepresentationOf(param, stream, isShort) + ", ";
			}
		}
		if (params.length > 0) {
			rep = rep.substring(0, rep.length() - 2); // Take off last comma+space
		}
		rep += ")";
		return rep;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/blobs/CliSigMethodSpec.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.blobs;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import ghidra.program.model.data.*;
import ghidra.util.Msg;
import ghidra.util.exception.InvalidInputException;

public class CliSigMethodSpec extends CliAbstractSig {
	private int genArgCount;
	private int genArgCountBytes;
	private CliSigType types[];

	private static final byte CLISIGMETHODSPEC_PROLOG = 0x0A;

	public CliSigMethodSpec(CliBlob blob) throws IOException {
		super(blob);

		BinaryReader reader = getContentsReader();

		// Check that the identifier is correct
		byte prolog = reader.readNextByte();
		if (prolog != CLISIGMETHODSPEC_PROLOG) {
			Msg.warn(this,
				"MethodSpec had unexpected prolog (0x" + Integer.toHexString(prolog) + ").");
			return;
		}

		long origIndex = reader.getPointerIndex();
		genArgCount = decodeCompressedUnsignedInt(reader);
		genArgCountBytes = (int) (reader.getPointerIndex() - origIndex);

		types = new CliSigType[genArgCount];
		for (int i = 0; i < genArgCount; i++) {
			try {
				types[i] = readCliType(reader);
			}
			catch (InvalidInputException e) {
				types[i] = null;
			}
		}
	}

	@Override
	public String getContentsName() {
		return "MethodSpecSig";
	}

	@Override
	public String getContentsComment() {
		return "Specifies a generic method with GenArgCount types";
	}

	@Override
	public DataType getContentsDataType() {
		StructureDataType struct = new StructureDataType(new CategoryPath(PATH), getName(), 0);
		struct.add(BYTE, "GENRICINST", "Magic (0x0a)");
		struct.add(getDataTypeForBytes(genArgCountBytes), "GenArgCount",
			"Number of types to follow");
		for (int i = 0; i < types.length; i++) {
			struct.add(types[i].getDefinitionDataType(), "Type" + i, null);
		}
		return struct;
	}

	@Override
	public String getRepresentationCommon(CliStreamMetadata stream, boolean isShort) {
		String typesRep = "";
		for (CliSigType type : types) {
			if (type == null) {
				typesRep += "unidentified_param_type, ";
			}
			else {
				typesRep += getRepresentationOf(type, stream, isShort) + ", ";
			}
		}
		if (types.length > 0) {
			typesRep = typesRep.substring(0, typesRep.length() - 2); // Take off last comma+space
		}
		String rep = String.format("GenericInst %d %s", genArgCount, typesRep);
		return rep;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/blobs/CliSigProperty.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.blobs;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import ghidra.program.model.data.*;
import ghidra.util.Msg;
import ghidra.util.exception.InvalidInputException;

public class CliSigProperty extends CliAbstractSig {
	private int sizeOfCount;
	private byte flags;
	private CliRetType returnType;
	private CliParam params[];

	private final int CLISIGPROPERTY_PROLOG = 0x08;
	private final int CLISIGPROPERTY_FLAGS_HASTHIS = 0x20;

	public CliSigProperty(CliBlob blob) throws IOException {
		super(blob);

		BinaryReader reader = getContentsReader();

		// Check for the prolog value and interpret any flags present
		flags = reader.readNextByte();
		if ((flags & CLISIGPROPERTY_PROLOG) != CLISIGPROPERTY_PROLOG) {
			Msg.warn(this,
				"PropertySig had unexpected prolog (0x" + Integer.toHexString(flags) + ")");
			return;
		}

		// Remove the prolog bit, leaving only HASTHIS if present
		flags ^= CLISIGPROPERTY_PROLOG;

		long origIndex = reader.getPointerIndex();
		int paramsCount = decodeCompressedUnsignedInt(reader);
		this.sizeOfCount = (int) (reader.getPointerIndex() - origIndex);

		try {
			returnType = new CliRetType(reader);
		}
		catch (InvalidInputException e) {
			returnType = null;
		}

		params = new CliParam[paramsCount];
		for (int i = 0; i < paramsCount; i++) {
			try {
				params[i] = new CliParam(reader);
			}
			catch (InvalidInputException e) {
				params[i] = null;
				e.printStackTrace();
			}
		}
	}

	public boolean hasThis() {
		return (flags & CLISIGPROPERTY_FLAGS_HASTHIS) == CLISIGPROPERTY_FLAGS_HASTHIS;
	}

	@Override
	public String getContentsName() {
		return "PropertySig";
	}

	@Override
	public String getContentsComment() {
		return "Contains signature for properties. Gives params for getters/setters.";
	}

	@Override
	public DataType getContentsDataType() {
		StructureDataType struct = new StructureDataType(new CategoryPath(PATH), getName(), 0);
		struct.add(BYTE, "PROPERTY", "Magic (0x08) optionalled OR'd with HASTHIS (0x20)");
		struct.add(getDataTypeForBytes(sizeOfCount), "Count", "Number of params to follow RetType");
		struct.add(returnType.getDefinitionDataType(), "RetType", "Return type");
		for (CliParam param : params) {
			struct.add(param.getDefinitionDataType(), "Param", null);
		}
		return struct;
	}

	@Override
	public String getRepresentationCommon(CliStreamMetadata stream, boolean isShort) {
		String paramsStr = "";
		for (CliParam param : params) {
			paramsStr += getRepresentationOf(param, stream, isShort) + ", ";
		}
		if (params.length > 0) {
			paramsStr = paramsStr.substring(0, paramsStr.length() - 2); // remove comma+space
		}
		return String.format("%s get(%s)", getRepresentationOf(returnType, stream, isShort),
			paramsStr);
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/blobs/CliSigStandAloneMethod.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.blobs;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import ghidra.program.model.data.*;
import ghidra.util.exception.InvalidInputException;

public class CliSigStandAloneMethod extends CliAbstractSig {

	private CliRetType retType;
	private CliParam params[];
	private byte flags;
	private int sizeOfCount;
	private int sentinelIndex; // SENTINEL is before the parameter index in this field

	// Note: The only difference between this and the MethodRefSig is the number of
	// values that can be included in the first byte

	private final int STANDALONEMETHODSIG_FLAGS_DEFAULT = 0x0;
	private final int STANDALONEMETHODSIG_FLAGS_HASTHIS = 0x20;
	private final int STANDALONEMETHODSIG_FLAGS_EXPLICITTHIS = 0x40;
	private final int STANDALONEMETHODSIG_FLAGS_VARARG = 0x5;
	private final int STANDALONEMETHODSIG_FLAGS_C = 0x01;
	private final int STANDALONEMETHODSIG_FLAGS_STDCALL = 0x02;
	private final int STANDALONEMETHODSIG_FLAGS_THISCALL = 0x03;
	private final int STANDALONEMETHODSIG_FLAGS_FASTCALL = 0x04;

	public enum CallingConvention {
		MANAGED, C, STDCALL, THISCALL, FASTCALL
	}

	public CliSigStandAloneMethod(CliBlob blob) throws IOException {
		super(blob);
		sentinelIndex = -1;

		// Read the flags
		BinaryReader reader = getContentsReader();
		flags = reader.readNextByte();

		long origIndex = reader.getPointerIndex();
		int paramCount = decodeCompressedUnsignedInt(reader);
		this.sizeOfCount = (int) (reader.getPointerIndex() - origIndex);

		try {
			retType = new CliRetType(reader);
		}
		catch (InvalidInputException e) {
			retType = null;
		}

		params = new CliParam[paramCount];
		for (int i = 0; i < paramCount; i++) {
			if (reader.peekNextByte() == CliElementType.ELEMENT_TYPE_SENTINEL.id()) {
				reader.readNextByte();
				sentinelIndex = i;
			}
			try {
				params[i] = new CliParam(reader);
			}
			catch (InvalidInputException e) {
				params[i] = null;
			}
		}
	}

	@Override
	public String getContentsName() {
		return "StandAloneMethodSig";
	}

	@Override
	public String getContentsComment() {
		return "Typically for calli instruction; Type info for method return and params";
	}

	@Override
	public DataType getContentsDataType() {
		StructureDataType struct = new StructureDataType(new CategoryPath(PATH), getName(), 0);
		struct.add(BYTE, "flags",
			"ORed VARARG/DEFAULT/C/STDCALL/THISCALL/FASTCALL and HASTHIS/EXPLICITTHIS");
		struct.add(getDataTypeForBytes(sizeOfCount), "Count",
			"Number of param types to follow RetType");
		struct.add(retType.getDefinitionDataType(), "RetType", null);
		for (CliParam param : params) {
			struct.add(param.getDefinitionDataType(), null, null);
		}
		return struct;
	}

	public CliRetType getReturnType() {
		return retType;
	}

	public CliParam[] getParams() {
		return params.clone();
	}

	public boolean hasThis() {
		return (flags & STANDALONEMETHODSIG_FLAGS_HASTHIS) == STANDALONEMETHODSIG_FLAGS_HASTHIS;
	}

	public boolean hasExplicitThis() {
		return (flags &
			STANDALONEMETHODSIG_FLAGS_EXPLICITTHIS) == STANDALONEMETHODSIG_FLAGS_EXPLICITTHIS;
	}

	public boolean hasVarArgs() {
		return (flags & STANDALONEMETHODSIG_FLAGS_VARARG) == STANDALONEMETHODSIG_FLAGS_VARARG;
	}

	public CallingConvention getCallingConvention() {
		if ((flags & STANDALONEMETHODSIG_FLAGS_C) == STANDALONEMETHODSIG_FLAGS_C) {
			// cdecl
			return CallingConvention.C;
		}
		else if ((flags & STANDALONEMETHODSIG_FLAGS_STDCALL) == STANDALONEMETHODSIG_FLAGS_STDCALL) {
			// stdcall
			return CallingConvention.STDCALL;
		}
		else if ((flags &
			STANDALONEMETHODSIG_FLAGS_THISCALL) == STANDALONEMETHODSIG_FLAGS_THISCALL) {
			// ecx/rcx is this pointer
			return CallingConvention.THISCALL;
		}
		else if ((flags &
			STANDALONEMETHODSIG_FLAGS_FASTCALL) == STANDALONEMETHODSIG_FLAGS_FASTCALL) {
			// ecx/rcx and edx/rdx are the first two parameters, standard x64 convention
			return CallingConvention.FASTCALL;
		}

		// Managed code call
		return CallingConvention.MANAGED;
	}

	@Override
	public String getRepresentationCommon(CliStreamMetadata stream, boolean isShort) {
		String rep = getRepresentationOf(retType, stream, isShort) + " fn(";

		for (CliParam param : params) {
			if (param == null) {
				rep += "unidentified_param_type, ";
			}
			else {
				rep += getRepresentationOf(param, stream, isShort) + ", ";
			}
		}
		if (params.length > 0) {
			rep = rep.substring(0, rep.length() - 2); // Take off last comma+space
		}
		rep += ")";
		return rep;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/blobs/CliSigTypeSpec.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.blobs;

import java.io.IOException;

import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import ghidra.program.model.data.DataType;
import ghidra.util.exception.InvalidInputException;

public class CliSigTypeSpec extends CliAbstractSig {

	public CliSigType type;

	public CliSigTypeSpec(CliBlob blob) throws IOException {
		super(blob);

		try {
			type = readCliType(blob.getContentsReader());
		}
		catch (InvalidInputException e) {
			type = null;
		}
	}

	@Override
	public String getContentsName() {
		return "TypeSpec";
	}

	@Override
	public String getContentsComment() {
		return "Describes a type.";
	}

	@Override
	public DataType getContentsDataType() {
		return type.getDefinitionDataType();
	}

	@Override
	public String getRepresentationCommon(CliStreamMetadata stream, boolean isShort) {
		return "TypeSpec: " + getRepresentationOf(type, stream, isShort);
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/methods/CliMethodDef.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.methods;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.StructConverter;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.*;
import ghidra.util.exception.DuplicateNameException;

public class CliMethodDef implements StructConverter {
	
	public static final String PATH = "/PE/CLI/Methods/MethodDefs";

	private Address addr;

	private boolean isFatHeader;
	private boolean hasMoreSections;
	private boolean initLocals;
	private int maxStack; // Max number of items on operand stack
	private int methodSize; // Size of method body (code)
	private int localVarSigTok;
	
	private static final byte CorILMethod_TinyFormat = 0x2;
	private static final byte CorILMethod_FatFormat = 0x3;
	private static final byte CorILMethod_MoreSects = 0x8;
	private static final byte CorILMethod_InitLocals = 0x10;
	
	public CliMethodDef(Address addr, BinaryReader reader) throws IOException {
		this.addr = addr;

		// Read first byte, see if tiny or fat.
		byte one = reader.readNextByte();
		if ((one & CorILMethod_FatFormat) == CorILMethod_FatFormat) {
			isFatHeader = true;
			if ((one & CorILMethod_MoreSects) == CorILMethod_MoreSects)
				hasMoreSections = true;
			if ((one & CorILMethod_InitLocals) == CorILMethod_InitLocals)
				initLocals = true;
			byte two = reader.readNextByte(); // TODO: need to read byte two? Seems to only have header length (in the wrong order?? >_<)
			maxStack = reader.readNextShort();
			methodSize = reader.readNextInt();
			localVarSigTok = reader.readNextInt();
		}
		else if ((one & CorILMethod_TinyFormat) == CorILMethod_TinyFormat) {
			isFatHeader = false;
			hasMoreSections = false;
			initLocals = false;
			maxStack = 8;
			methodSize = (((one & ~0x3) & 0xff) >> 2); // Mask off first 2 bits, right shift to get 6 length bits. 0xff mask to convert to right sign.
		}
	}
	
	private void fillTinyHeaderType(Structure struct) {
		struct.add(BYTE, "Size+Flags", "L.S. Bits 0:1 Flags, Bits 2:7 Size of method in Bytes");
	}
	
	private void fillFatHeaderType(Structure struct) {
		struct.add( WORD, "Size+Flags", "L.S. Bits 0:3 Size of hdr in B, Bits 4:15 Flags");
		struct.add( WORD, "MaxStack", "Maximum number of items on the operand stack");
		struct.add(DWORD, "CodeSize", "Size of actual method body in B");
		struct.add(DWORD, "LocalVarSigTok", "Signature for the local variables of the method. 0 means no locals. References standalone signature in Metadata tables, which references #Blob heap.");
	}
	
	@Override
	public DataType toDataType() throws DuplicateNameException, IOException {
		StructureDataType struct =
			new StructureDataType(new CategoryPath(PATH), "MethodDefHdr_" + addr, 0);
		if (isFatHeader) {
			fillFatHeaderType(struct);
		}
		else {
			fillTinyHeaderType(struct);
		}
		return struct;
	}

	public int getMethodSize() {
		return methodSize;
	}

	public boolean hasMoreSections() {
		return hasMoreSections;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/methods/CliMethodExtraSections.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.methods;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.StructConverter;
import ghidra.program.model.data.*;
import ghidra.util.exception.DuplicateNameException;

public class CliMethodExtraSections implements StructConverter {

	public static final String PATH = "/PE/CLI/Methods/ExtraSections";

	private List<ExtraSection> extraSections = new ArrayList<>();

	private class ExtraSection {
		public boolean isEHTable;
		public boolean isFat;
		public boolean hasMoreSections;
		public int dataSize;
		public boolean isFilterBasedException;

		public static final int CorILMethod_Sect_EHTable = 0x1;
		public static final int CorILMethod_Sect_OptIL = 0x2;
		public static final int CorILMethod_Sect_FatFormat = 0x40;
		public static final int CorILMethod_Sect_MoreSects = 0x80;

		public static final short COR_ILEXCEPTION_CLAUSE_EXCEPTION = 0x0000;
		public static final short COR_ILEXCEPTION_CLAUSE_FILTER = 0x0001;
		public static final short COR_ILEXCEPTION_CLAUSE_FINALLY = 0x0002;
		public static final short COR_ILEXCEPTION_CLAUSE_FAULT = 0x0004;

		public ExtraSection(BinaryReader reader) throws IOException {
			byte sectionFlags = reader.readNextByte();
			isEHTable = (sectionFlags & CorILMethod_Sect_EHTable) == CorILMethod_Sect_EHTable;
			isFat = ((sectionFlags & CorILMethod_Sect_FatFormat) == CorILMethod_Sect_FatFormat);
			hasMoreSections =
				((sectionFlags & CorILMethod_Sect_MoreSects) == CorILMethod_Sect_MoreSects);

			// Read size
			if (isFat) {
				// This seems counterintuitive but it looks like they're ordering bytes like this
				byte firstSize = reader.readNextByte();
				short secondThirdSize = reader.readNextShort();
				dataSize = (secondThirdSize << 8) + (firstSize & 0xff);
			}
			else {
				dataSize = reader.readNextByte();
			}

			// Read Flags for exception handlers
			if (isFat) {
				int exceptionHandlingFlags = reader.readNextInt();
				isFilterBasedException = ((exceptionHandlingFlags &
					COR_ILEXCEPTION_CLAUSE_FILTER) == COR_ILEXCEPTION_CLAUSE_FILTER);
			}
			else {
				short exceptionHandlingFlags = reader.readNextShort();
				isFilterBasedException = ((exceptionHandlingFlags &
					COR_ILEXCEPTION_CLAUSE_FILTER) == COR_ILEXCEPTION_CLAUSE_FILTER);
			}
		}

		public StructureDataType getSmallExceptionClauseDataType() {
			StructureDataType struct =
				new StructureDataType(new CategoryPath(PATH), "SmallExceptionHandlerClause", 0);
			struct.add(WORD, "Flags", "COR_ILEXCEPTION_CLAUSE_*"); //  TODO: explain flags
			struct.add(WORD, "TryOffset", "Offset in bytes of try block from start of header");
			struct.add(BYTE, "TryLength", "Length in bytes of try block");
			struct.add(WORD, "HandlerOffset", "Location of handler for this try block");
			struct.add(BYTE, "HandlerLength", "Size of handler code in bytes");
			if (isFilterBasedException) {
				struct.add(DWORD, "FilterOffset",
					"Offset in method body for filter-based exception handler");
			}
			else {
				struct.add(DWORD, "ClassToken", "Metadata token for type-based exception handler");
			}
			return struct;
		}

		public StructureDataType getFatExceptionClauseDataType() {
			StructureDataType struct =
				new StructureDataType(new CategoryPath(PATH), "FatExceptionHandlerClause", 0);
			struct.add(DWORD, "Flags", "COR_ILEXCEPTION_CLAUSE_*"); //  TODO: explain flags
			struct.add(DWORD, "TryOffset", "Offset in bytes of try block from start of header");
			struct.add(DWORD, "TryLength", "Length in bytes of try block");
			struct.add(DWORD, "HandlerOffset", "Location of handler for this try block");
			struct.add(DWORD, "HandlerLength", "Size of handler code in bytes");
			if (isFilterBasedException) {
				struct.add(DWORD, "FilterOffset",
					"Offset in method body for filter-based exception handler");
			}
			else {
				struct.add(DWORD, "ClassToken", "Metadata token for type-based exception handler");
			}
			return struct;
		}

		public DataType toDataType() {
			// Default to skinny clause size
			int clauseSize = 12;
			if (isFat) {
				clauseSize = 24;
			}

			int numberClauses = (dataSize - 4) / clauseSize;
			StructureDataType struct =
				new StructureDataType(new CategoryPath(PATH), "ExtraSection", 0);
			struct.add(BYTE, "Kind", "flags: EH, OptIL, FatFormat, MoreSects"); // TODO: explain flags
			if (isFat) {
				struct.add(BYTE, "size byte 1", "first byte");
				struct.add(WORD, "size bytes 2-3", "size continued. n*24+4 clauses follow.");
				struct.add(
					new ArrayDataType(getFatExceptionClauseDataType(), numberClauses, clauseSize),
					"Clauses", null);
			}
			else {
				struct.add(BYTE, "DataSize", "section size inc. header; n*12+4 clauses follow");
				struct.add(WORD, "Padding", "always 0");
				struct.add(
					new ArrayDataType(getSmallExceptionClauseDataType(), numberClauses, clauseSize),
					"Clauses", null);
			}
			return struct;
		}
	}

	public CliMethodExtraSections(BinaryReader reader) throws IOException {
		ExtraSection section;
		do {
			section = new ExtraSection(reader);
			extraSections.add(section);
		}
		while (section.hasMoreSections);
	}

	@Override
	public DataType toDataType() throws DuplicateNameException, IOException {
		StructureDataType struct =
			new StructureDataType(new CategoryPath(PATH), "ExtraSections", 0);
		for (ExtraSection section : extraSections) {
			struct.add(section.toDataType(), "ExtraSection", null);
		}
		return struct;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/streams/CliAbstractStream.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.streams;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.StructConverter;
import net.jubjubnest.minidump.contrib.pe.*;
import net.jubjubnest.minidump.contrib.pe.cli.CliStreamHeader;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.DataType;
import ghidra.program.model.listing.BookmarkType;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.SourceType;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.exception.InvalidInputException;
import ghidra.util.task.TaskMonitor;

/**
 * A abstract CLI stream type for convenience.  Streams that we support should subclass 
 * this class and override the {@link #parse}, {@link #markup}, and {@link #toDataType} 
 * methods appropriately.  
 * <p>
 * When streams are laid down in memory they are referred to as heaps, but we'll just stick 
 * with calling them streams because using both terms can get confusing. 
 */
public abstract class CliAbstractStream implements StructConverter, PeMarkupable {

	public static final String PATH = "/PE/CLI/Streams";

	protected CliStreamHeader header;
	protected long offset;
	protected int rva;
	protected BinaryReader reader;

	/**
	 * Creates a new generic CLI stream type.  This is intended to be called by a subclass
	 * stream during its creation.
	 *  
	 * @param header The stream header associated with this stream.
	 * @param offset The reader offset where this stream starts. 
	 * @param rva The relative virtual address where this stream starts.
	 * @param reader A reader that is used to read the stream.
	 * @throws IOException if there is a problem reading the stream.
	 */
	public CliAbstractStream(CliStreamHeader header, long offset, int rva, BinaryReader reader)
			throws IOException {
		this.header = header;
		this.offset = offset;
		this.rva = rva;
		this.reader = reader;
	}

	/**
	 * Parses this stream.
	 * 
	 * @return True if parsing completed successfully; otherwise, false.
	 * @throws IOException If there was an IO problem while parsing.
	 */
	public abstract boolean parse() throws IOException;

	/**
	 * Does basic markup that all streams will want:
	 * <ul>
	 *   <li>Set monitor message</li>
	 *   <li>Validate addresses</li>
	 *   <li>Add bookmark</li>
	 *   <li>Add symbol</li>
	 *   <li>Create data type</li>
	 * </ul>
	 * Subclass should first call this and then provide any custom markup they need. 
	 */
	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor, MessageLog log,
			NTHeader ntHeader) throws DuplicateNameException, IOException {

		monitor.setMessage("[" + program.getName() + "]: CLI stream...");
		Address addr = PeUtils.getMarkupAddress(program, isBinary, ntHeader, rva);

		program.getBookmarkManager().setBookmark(addr, BookmarkType.INFO, "CLI Stream",
			header.getName());

		try {
			program.getSymbolTable().createLabel(addr, "CLI_Stream_" + header.getName(),
				SourceType.ANALYSIS);
		}
		catch (InvalidInputException e) {
			Msg.error(this, "Error marking up CLI stream \"" + header.getName() + "\"", e);
			return;
		}

		if (!program.getMemory().contains(addr)) {
			return;
		}

		DataType dt = this.toDataType();
		dt.setCategoryPath(new CategoryPath(PATH));
		PeUtils.createData(program, addr, dt, log);
	}

	/**
	 * Gets this stream's header.
	 * 
	 * @return This stream's header.
	 */
	public CliStreamHeader getStreamHeader() {
		return header;
	}

	/**
	 * Gets the markup address of an offset in a given stream.
	 * 
	 * @param program 
	 * @param isBinary
	 * @param monitor
	 * @param log
	 * @param ntHeader
	 * @param stream The stream to offset into.
	 * @param streamIndex The index into the stream.
	 * @return The markup address of the given offset in the provided stream.
	 */
	public static Address getStreamMarkupAddress(Program program, boolean isBinary,
			TaskMonitor monitor, MessageLog log, NTHeader ntHeader, CliAbstractStream stream,
			int streamIndex) {
		CliStreamHeader streamHeader = stream.getStreamHeader();
		return PeUtils.getMarkupAddress(program, isBinary, ntHeader,
			streamHeader.getMetadataRoot().getRva() + streamHeader.getOffset() + streamIndex);
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/streams/CliStreamBlob.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.streams;

import java.io.IOException;
import java.util.LinkedHashMap;
import java.util.Map;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.CliStreamHeader;
import net.jubjubnest.minidump.contrib.pe.cli.blobs.CliBlob;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;

/**
 * The Blob stream contains ???.
 * When the stream is present, the first entry is always the byte 0x00.
 * This stream may contain garbage in its unreachable parts.
 */
public class CliStreamBlob extends CliAbstractStream {

	protected Map<Integer, CliBlob> blobMap;

	/**
	 * Gets the name of this stream.
	 * 
	 * @return The name of this stream.
	 */
	public static String getName() {
		return "#Blob";
	}

	/**
	 * Creates a new Blob stream.
	 * 
	 * @param header The stream header associated with this stream.
	 * @param offset The reader offset where this stream starts. 
	 * @param rva The relative virtual address where this stream starts.
	 * @param reader A reader that is used to read the stream.
	 * @throws IOException if there is a problem reading the stream.
	 */
	public CliStreamBlob(CliStreamHeader header, long offset, int rva, BinaryReader reader)
			throws IOException {
		super(header, offset, rva, reader);

		blobMap = new LinkedHashMap<>();
	}

	@Override
	public boolean parse() throws IOException {
		reader.setPointerIndex(offset);

		// First byte is always 0x00
		reader.readNextByte();

		int bytesRead = 1;
		while (bytesRead < header.getSize()) {
			CliBlob blob = new CliBlob(bytesRead, reader);
			if (blob.getContentsSize() > 0) {
				blobMap.put(bytesRead, blob);
			}
			bytesRead += blob.getSize();
		}

		return true;
	}

	/**
	 * Gets the blob at the given index.
	 * 
	 * @param index The index of the blob to get.
	 * @return The blob at the given index.  Could be null if the index was invalid or
	 *   there was a problem reading the blob.
	 */
	public CliBlob getBlob(int index) {
		return blobMap.get(index);
	}

	/**
	 * Updates the blob at the given address with the new blob.
	 * 
	 * @param updatedBlob The updated blob.
	 * @param addr The address of the blob to update.
	 * @param program The program that will get the update.
	 */
	public boolean updateBlob(CliBlob updatedBlob, Address addr, Program program) {

		// Get and validate the containing structure at the given address
		Data containingData = program.getListing().getDefinedDataContaining(addr);
		if (containingData == null || !containingData.isStructure()) {
			Msg.error(this, "Containing data of " + updatedBlob.getName() + " at address " + addr +
				" is not a structure.");
			return false;
		}
		Structure containingStructure = (Structure) containingData.getDataType();

		// Make sure there is an old blob at the given address
		int structureOffset = (int) addr.subtract(containingData.getAddress());
		DataTypeComponent oldBlobDataComponent = containingStructure.getComponentAt(structureOffset);
		if (oldBlobDataComponent == null) {
			Msg.error(this, "Existing blob at address " + addr + " was not found.");
			return false;
		}
		
		// Make sure the old blob has the same size as the new blob
		DataType oldBlobDataType = oldBlobDataComponent.getDataType();
		DataType newBlobDataType = updatedBlob.toDataType();
		if (oldBlobDataType.getLength() != newBlobDataType.getLength()) {
			Msg.error(this, "Cannot replace existing blob at address " + addr + " with " +
				updatedBlob.getName() + " because they have different sizes.");
			return false;
		}

		// Update the blob
		containingStructure.replaceAtOffset(structureOffset, newBlobDataType, updatedBlob.getSize(),
			updatedBlob.getName(), updatedBlob.getContentsComment());

		return true;
	}

	@Override
	public DataType toDataType() throws DuplicateNameException, IOException {
		Structure struct = new StructureDataType(new CategoryPath(PATH), header.getName(), 0);
		struct.add(BYTE, "Reserved", "Always 0");
		for (Map.Entry<Integer, CliBlob> entry : blobMap.entrySet()) {
			int index = entry.getKey();
			CliBlob blob = entry.getValue();
			struct.add(blob.toDataType(), blob.getSize(), "[" + Integer.toHexString(index) + "]",
				null);
		}
		return struct;
	}
}


```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/streams/CliStreamGuid.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.streams;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.CliStreamHeader;
import ghidra.app.util.datatype.microsoft.GUID;
import ghidra.app.util.datatype.microsoft.GuidDataType;
import ghidra.program.model.data.*;
import ghidra.util.exception.DuplicateNameException;

/**
 * The GUID stream points to a sequence of 128-bit GUIDs.  There might be unreachable
 * GUIDs stored in the stream.
 */
public class CliStreamGuid extends CliAbstractStream {

	private int numGuids;

	/**
	 * Gets the name of this stream.
	 * 
	 * @return The name of this stream.
	 */
	public static String getName() {
		return "#GUID";
	}

	/**
	 * Creates a new GUID stream.
	 * 
	 * @param header The stream header associated with this stream.
	 * @param offset The reader offset where this stream starts. 
	 * @param rva The relative virtual address where this stream starts.
	 * @param reader A reader that is used to read the stream.
	 * @throws IOException if there is a problem reading the stream.
	 */
	public CliStreamGuid(CliStreamHeader header, long offset, int rva, BinaryReader reader)
			throws IOException {
		super(header, offset, rva, reader);
		
		numGuids = header.getSize() / GuidDataType.SIZE;
	}
		
	@Override
	public boolean parse() throws IOException {
		return true;
	}

	/**
	 * Gets the GUID at the given index.
	 * 
	 * @param index The index of the GUID to get.
	 * @return The string at the given index.  Could be null if the index was invalid or
	 *   there was a problem reading the GUID.
	 */
	public GUID getGuid(int index) {

		if (index < 0 || index >= numGuids * GuidDataType.SIZE) {
			return null;
		}

		try {
			reader.setPointerIndex(offset + index);
			return new GUID(reader);
		}
		catch (IOException e) {
			return null;
		}
	}

	@Override
	public DataType toDataType() throws DuplicateNameException, IOException {
		Structure struct = new StructureDataType(new CategoryPath(PATH), header.getName(), 0);
		DataType guidDT = new GuidDataType();
		for (int i = 0; i < numGuids; i++) {
			struct.add(guidDT, "[" + Integer.toHexString(i) + "]", null);
		}
		return struct;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/streams/CliStreamMetadata.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.streams;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.NTHeader;
import net.jubjubnest.minidump.contrib.pe.PeUtils;
import net.jubjubnest.minidump.contrib.pe.cli.CliStreamHeader;
import net.jubjubnest.minidump.contrib.pe.cli.tables.*;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.BookmarkType;
import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;

/**
 * The Metadata stream is giant and complicated.  It is made up of {@link CliAbstractTable}s.
 * 
 * @see CliTypeTable
 */
public class CliStreamMetadata extends CliAbstractStream {

	private byte majorVersion;
	private byte minorVersion;
	private byte heapSizes;
	private long valid;
	private long sorted;
	private HashMap<CliTypeTable, Integer> rows;
	private ArrayList<CliAbstractTable> tables = new ArrayList<>();

	private CliStreamGuid guidStream;
	private CliStreamUserStrings userStringsStream;
	private CliStreamStrings stringsStream;
	private CliStreamBlob blobStream;

	/**
	 * Gets the name of this stream.
	 * 
	 * @return The name of this stream.
	 */
	public static String getName() {
		return "#~";
	}

	/**
	 * Creates a new Metadata stream.
	 * 
	 * @param header The stream header associated with this stream.
	 * @param guidStream The GUID stream.
	 * @param userStringsStream The user strings stream.
	 * @param stringsStream The strings stream.
	 * @param blobStream The blob stream.
	 * @param fileOffset The file offset where this stream starts. 
	 * @param rva The relative virtual address where this stream starts.
	 * @param reader A reader that is set to the start of the stream.
	 * @throws IOException if there is a problem reading the stream.
	 */
	public CliStreamMetadata(CliStreamHeader header, CliStreamGuid guidStream,
			CliStreamUserStrings userStringsStream, CliStreamStrings stringsStream,
			CliStreamBlob blobStream, long fileOffset, int rva, BinaryReader reader)
			throws IOException {
		super(header, fileOffset, rva, reader);

		this.rows = new HashMap<>();
		this.tables = new ArrayList<>();

		this.guidStream = guidStream;
		this.userStringsStream = userStringsStream;
		this.stringsStream = stringsStream;
		this.blobStream = blobStream;
	}

	@Override
	public boolean parse() throws IOException {
		reader.setPointerIndex(offset);

		reader.readNextInt(); // reserved
		majorVersion = reader.readNextByte();
		minorVersion = reader.readNextByte();
		heapSizes = reader.readNextByte();
		reader.readNextByte(); // reserved
		valid = reader.readNextLong();
		sorted = reader.readNextLong();

		// Next is an array of n 4-byte unsigned integers indicating the number of rows for each present table
		for (int i = 0; i < 64; i++) {
			if ((valid & (1L << i)) != 0) {
				CliTypeTable tableType = CliTypeTable.fromId(i);
				if (tableType != null) {
					rows.put(tableType, reader.readNextInt());
				}
				else {
					Msg.warn(this, "CLI metadata table with id " + i + " is not supported");
				}
			}
		}

		// Now the tables follow directly after
		for (int i = 0; i < 64; i++) {
			if ((valid & (1L << i)) != 0) {
				CliTypeTable tableType = CliTypeTable.fromId(i);
				if (tableType != null) {
					long origIndex = reader.getPointerIndex();
					CliAbstractTable table = createTableObject(tableType);
					tables.add(table);
					reader.setPointerIndex(origIndex + table.toDataType().getLength());
				}
			}
		}

		return true;
	}

	/**
	 * Gets the GUID stream.
	 * 
	 * @return The GUID stream.  Could be null if one doesn't exist.
	 */
	public CliStreamGuid getGuidStream() {
		return guidStream;
	}

	/**
	 * Gets the user strings stream.
	 * 
	 * @return The user strings stream.  Could be null if one doesn't exist.
	 */
	public CliStreamUserStrings getUserStringsStream() {
		return userStringsStream;
	}

	/**
	 * Gets the strings stream.
	 * 
	 * @return The strings stream.  Could be null if one doesn't exist.
	 */
	public CliStreamStrings getStringsStream() {
		return stringsStream;
	}

	/**
	 * Gets the blob stream.
	 * 
	 * @return The blob stream.  Could be null if one doesn't exist.
	 */
	public CliStreamBlob getBlobStream() {
		return blobStream;
	}

	/**
	 * Creates a new {@link CliAbstractTable} from the table at the current reader index
	 * with the given table type.
	 * 
	 * @param tableType The type of table to create.
	 * @return A new table with the given type.  Could be null if we don't support the table type.
	 * @throws IOException if there was an issue reading the new table.
	 */
	private CliAbstractTable createTableObject(CliTypeTable tableType) throws IOException {
		switch (tableType) {
			case Module:
				return new CliTableModule(reader, this, tableType);

			case TypeRef:
				return new CliTableTypeRef(reader, this, tableType);

			case TypeDef:
				return new CliTableTypeDef(reader, this, tableType);

			case Field:
				return new CliTableField(reader, this, tableType);

			case MethodDef:
				return new CliTableMethodDef(reader, this, tableType);

			case Param:
				return new CliTableParam(reader, this, tableType);

			case InterfaceImpl:
				return new CliTableInterfaceImpl(reader, this, tableType);

			case MemberRef:
				return new CliTableMemberRef(reader, this, tableType);

			case Constant:
				return new CliTableConstant(reader, this, tableType);

			case CustomAttribute:
				return new CliTableCustomAttribute(reader, this, tableType);

			case FieldMarshal:
				return new CliTableFieldMarshall(reader, this, tableType);

			case DeclSecurity:
				return new CliTableDeclSecurity(reader, this, tableType);

			case ClassLayout:
				return new CliTableClassLayout(reader, this, tableType);

			case FieldLayout:
				return new CliTableFieldLayout(reader, this, tableType);

			case StandAloneSig:
				return new CliTableStandAloneSig(reader, this, tableType);

			case EventMap:
				return new CliTableEventMap(reader, this, tableType);

			case Event:
				return new CliTableEvent(reader, this, tableType);

			case PropertyMap:
				return new CliTablePropertyMap(reader, this, tableType);

			case Property:
				return new CliTableProperty(reader, this, tableType);

			case MethodSemantics:
				return new CliTableMethodSemantics(reader, this, tableType);

			case MethodImpl:
				return new CliTableMethodImpl(reader, this, tableType);

			case ModuleRef:
				return new CliTableModuleRef(reader, this, tableType);

			case TypeSpec:
				return new CliTableTypeSpec(reader, this, tableType);

			case ImplMap:
				return new CliTableImplMap(reader, this, tableType);

			case FieldRVA:
				return new CliTableFieldRVA(reader, this, tableType);

			case Assembly:
				return new CliTableAssembly(reader, this, tableType);

			case AssemblyProcessor:
				return new CliTableAssemblyProcessor(reader, this, tableType);

			case AssemblyOS:
				return new CliTableAssemblyOS(reader, this, tableType);

			case AssemblyRef:
				return new CliTableAssemblyRef(reader, this, tableType);

			case AssemblyRefProcessor:
				return new CliTableAssemblyRefProcessor(reader, this, tableType);

			case AssemblyRefOS:
				return new CliTableAssemblyRefOS(reader, this, tableType);

			case File:
				return new CliTableFile(reader, this, tableType);

			case ExportedType:
				return new CliTableExportedType(reader, this, tableType);

			case ManifestResource:
				return new CliTableManifestResource(reader, this, tableType);

			case NestedClass:
				return new CliTableNestedClass(reader, this, tableType);

			case GenericParam:
				return new CliTableGenericParam(reader, this, tableType);

			case MethodSpec:
				return new CliTableMethodSpec(reader, this, tableType);

			case GenericParamConstraint:
				return new CliTableGenericParamConstraint(reader, this, tableType);

			default:
				Msg.warn(this,
					"Parsing table type \"" + tableType.toString() + "\" is not supported.");
				return null;
		}
	}

	/**
	 * Gets the major version.
	 * 
	 * @return The major version.
	 */
	public short getMajorVersion() {
		return majorVersion;
	}

	/**
	 * Gets the minor version.
	 * 
	 * @return The minor version.
	 */
	public short getMinorVersion() {
		return minorVersion;
	}

	/**
	 * Gets the sorted field.
	 * 
	 * @return The sorted field.
	 */
	public long getSorted() {
		return sorted;
	}

	/**
	 * Gets the valid field.
	 * 
	 * @return The valid field.
	 */
	public long getValid() {
		return valid;
	}

	/**
	 * Gets the table with the provided table type from the metadata stream.
	 * 
	 * @param tableType The type of table to get.
	 * @return The table with the provided table type.  Could be null if it doesn't exist.
	 */
	public CliAbstractTable getTable(CliTypeTable tableType) {
		// Make sure it is present
		if (!isTablePresent(tableType)) {
			return null;
		}

		// Get the already-created table
		int tableIndex = getPresentTableIndex(tableType);
		if (tableIndex < tables.size()) {
			CliAbstractTable tableObj = tables.get(tableIndex);
			if (tableObj.getTableType() == tableType) {
				return tableObj;
			}
		}

		return null;
	}

	/**
	 * Gets the table with the provided table type id from the metadata stream.
	 * 
	 * @param tableId The id of the table type to get.
	 * @return The table with the provided table id.  Could be null if it doesn't exist.
	 */
	public CliAbstractTable getTable(int tableId) {
		return getTable(CliTypeTable.fromId(tableId));
	}

	/**
	 * Gets the number of rows in the table with the given table type.
	 * 
	 * @param tableType The type of table to get the number of rows of.
	 * @return The number of rows in the table with the given table type.  Could be 0 if 
	 *   the table of the given type was not found.
	 */
	public int getNumberRowsForTable(CliTypeTable tableType) {
		Integer ret = rows.get(tableType);
		return (ret != null) ? ret : 0;
	}

	/**
	 * Gets the data type of the index into the string stream.  Will be either
	 * {@link DWordDataType} or {@link WordDataType}.
	 * 
	 * @return The data type of the index into the string stream.
	 */
	public DataType getStringIndexDataType() {
		return ((heapSizes & 0x01) != 0) ? DWordDataType.dataType : WordDataType.dataType;
	}

	/**
	 * Gets the data type of the index into the GUID stream.  Will be either
	 * {@link DWordDataType} or {@link WordDataType}.
	 * 
	 * @return The data type of the index into the string stream.
	 */
	public DataType getGuidIndexDataType() {
		return ((heapSizes & 0x02) != 0) ? DWordDataType.dataType : WordDataType.dataType;
	}

	/**
	 * Gets the data type of the index into the Blob stream.  Will be either
	 * {@link DWordDataType} or {@link WordDataType}.
	 * 
	 * @return The data type of the index into the string stream.
	 */
	public DataType getBlobIndexDataType() {
		return ((heapSizes & 0x04) != 0) ? DWordDataType.dataType : WordDataType.dataType;
	}

	/**
	 * Gets the data type of the index into a metadata table.  Will be either
	 * {@link DWordDataType} or {@link WordDataType}.
	 * 
	 * @return The data type of the index into the string stream.
	 */
	public DataType getTableIndexDataType(CliTypeTable table) {
		return (getNumberRowsForTable(table) >= (1 << 16)) ? DWordDataType.dataType
				: WordDataType.dataType;
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor, MessageLog log,
			NTHeader ntHeader) throws DuplicateNameException, IOException {
		super.markup(program, isBinary, monitor, log, ntHeader);
		for (CliAbstractTable table : tables) {
			try {
				Address addr = PeUtils.getMarkupAddress(program, isBinary, ntHeader,
					rva + getTableOffset(table.getTableType()));
				program.getBookmarkManager()
						.setBookmark(addr, BookmarkType.INFO, "CLI Table", table.toString());

				table.markup(program, isBinary, monitor, log, ntHeader);
			}
			catch (Exception e) {
				Msg.error(this, "Failed to markup " + table);
			}
		}
	}

	@Override
	public DataType toDataType() {
		Structure struct = new StructureDataType(new CategoryPath(PATH), header.getName(), 0);
		struct.add(DWORD, "Reserved", "Always 0");
		struct.add(BYTE, "MajorVersion", null);
		struct.add(BYTE, "MinorVersion", null);
		struct.add(BYTE, "HeapSizes", "Bit vector for heap sizes");
		struct.add(BYTE, "Reserved", "Always 1");
		struct.add(QWORD, "Valid", "Bit vector of present tables");
		struct.add(QWORD, "Sorted", "Bit vector of sorted tables");
		struct.add(new ArrayDataType(DWORD, Long.bitCount(valid), DWORD.getLength()), "Rows",
			"# of rows for each corresponding present table");
		for (CliAbstractTable table : tables) {
			struct.add(table.toDataType(), table.toString(),
				"CLI Metadata Table: " + table.toString());
		}
		return struct;
	}

	private boolean isTablePresent(CliTypeTable tableType) {
		return ((valid & (1L << tableType.id())) != 0);
	}

	private int getTableOffset(CliTypeTable table) {
		StructureDataType struct = (StructureDataType) this.toDataType();
		int structOffset = 8; // Struct offset (0-indexed) of first metadata table
		structOffset += getPresentTableIndex(table);
		return struct.getComponent(structOffset).getOffset();
	}

	private int getPresentTableIndex(CliTypeTable table) {
		int tableId = table.id();
		long mask = valid & ((1L << tableId) - 1); // mask tables that come after this one. Start with all present tables, 0 out any that are after tableId.
		int tablesBefore = Long.bitCount(mask);
		return tablesBefore;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/streams/CliStreamStrings.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.streams;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.*;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.CliStreamHeader;
import ghidra.program.model.data.*;
import ghidra.util.exception.DuplicateNameException;

/**
 * The Strings stream contains null-terminated UTF8 strings.
 * When the stream is present, the first entry is always the empty string.
 * This stream may contain garbage in its unreachable parts.
 */
public class CliStreamStrings extends CliAbstractStream {

	private List<Integer> stringIndexes;
	private List<Integer> stringSizes;

	/**
	 * Gets the name of this stream.
	 * 
	 * @return The name of this stream.
	 */
	public static String getName() {
		return "#Strings";
	}

	/**
	 * Creates a new Strings stream.
	 * 
	 * @param header The stream header associated with this stream.
	 * @param offset The reader offset where this stream starts. 
	 * @param rva The relative virtual address where this stream starts.
	 * @param reader A reader that is used to read the stream.
	 * @throws IOException if there is a problem reading the stream.
	 */
	public CliStreamStrings(CliStreamHeader header, long offset, int rva, BinaryReader reader)
			throws IOException {
		super(header, offset, rva, reader);
		stringIndexes = new ArrayList<>();
		stringSizes = new ArrayList<>();
	}

	@Override
	public boolean parse() throws IOException {
		reader.setPointerIndex(offset);

		int bytesRead = 0;
		int stringLength = 0;
		int prevOffset = 0;

		// Loop through the data looking for NULL terminators
		while (bytesRead < header.getSize()) {
			int currentByte = reader.readNextUnsignedByte();
			stringLength++;
			bytesRead++;

			if (currentByte == 0) {
				stringIndexes.add(prevOffset);
				prevOffset = bytesRead;

				// Record the length of the UTF-8 string including the NULL terminator
				stringSizes.add(stringLength);

				// We're moving on to the next string so reset to 0
				stringLength = 0;
			}
		}

		return true;
	}

	/**
	 * Gets the string at the given index.
	 * 
	 * @param index The index of the string to get.
	 * @return The string at the given index.  Could be null if the index was invalid or there was
	 *   a problem reading the string.
	 */
	public String getString(int index) {

		if (stringIndexes.size() == 0 || stringSizes.size() == 0) {
			return null;
		}

		int lastIndex = stringIndexes.get(stringIndexes.size() - 1);
		int lastSize = stringSizes.get(stringSizes.size() - 1);

		if (index < 0 || index >= lastIndex + lastSize) {
			return null;
		}

		int stringLength = 0;
		int stringLengthIndex = Collections.binarySearch(stringIndexes, index);
		if (stringLengthIndex >= 0) {
			stringLength = stringSizes.get(stringLengthIndex);
		}
		else {
			// Reinterpret to the closest offset of a complete string prior
			// to the offset, then get the remainder string length
			stringLengthIndex = (-stringLengthIndex - 1) - 1;
			stringLength =
				stringSizes.get(stringLengthIndex) - (index - stringIndexes.get(stringLengthIndex));
		}

		try {
			// Grab an array of bytes at the index and convert to UTF-8, and don't
			// include the NULL terminator
			return new String(reader.readByteArray(offset + index, stringLength - 1),
				StandardCharsets.UTF_8);
		}
		catch (IOException e) {
			return null;
		}
	}

	@Override
	public DataType toDataType() throws DuplicateNameException, IOException {
		Structure struct = new StructureDataType(new CategoryPath(PATH), header.getName(), 0);

		for (int i = 0; i < stringSizes.size(); i++) {
			struct.add(UTF8, stringSizes.get(i),
				"[" + Integer.toHexString(stringIndexes.get(i)) + "]", null);
		}
		return struct;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/streams/CliStreamUserStrings.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.streams;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.Map;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.CliStreamHeader;
import net.jubjubnest.minidump.contrib.pe.cli.blobs.CliBlob;
import ghidra.program.model.data.*;
import ghidra.util.exception.DuplicateNameException;

/**
 * The User Strings stream contains blobs of 16-bit Unicode strings.
 * When the stream is present, the first entry is always the byte 0x00.
 * This stream may contain garbage in its unreachable parts.
 */
public class CliStreamUserStrings extends CliStreamBlob {

	/**
	 * Gets the name of this stream.
	 * 
	 * @return The name of this stream.
	 */
	public static String getName() {
		return "#US";
	}

	/**
	 * Creates a new {@link CliStreamUserStrings}.
	 * 
	 * @param header The stream header associated with this stream.
	 * @param fileOffset The file offset where this stream starts. 
	 * @param rva The relative virtual address where this stream starts.
	 * @param reader A reader that is set to the start of the stream.
	 * @throws IOException if there is a problem reading the stream.
	 */
	public CliStreamUserStrings(CliStreamHeader header, long fileOffset, int rva,
			BinaryReader reader) throws IOException {
		super(header, fileOffset, rva, reader);
	}

	/**
	 * Gets the user string at the given index.
	 * 
	 * @param index The index of the user string to get.
	 * @return The user string at the given index.  Could be null if the index was invalid or
	 *   there was a problem reading the user string.
	 */
	public String getUserString(int index) {
		byte[] bytes = blobMap.get(index).getContents();
		// Must explicitly specify UTF_16LE or the string gets mangled
		return new String(bytes, 0, bytes.length - 1, StandardCharsets.UTF_16LE);
	}

	@Override
	public DataType toDataType() throws DuplicateNameException, IOException {
		Structure struct = new StructureDataType(new CategoryPath(PATH), header.getName(), 0);
		struct.add(BYTE, "Reserved", "Always 0");
		for (Map.Entry<Integer, CliBlob> entry : blobMap.entrySet()) {
			int index = entry.getKey();
			CliBlob blob = entry.getValue();
			struct.add(blob.getSizeDataType(), "Next string size", null);
			if (blob.getContentsSize() > 0) {
				if (blob.getContentsSize() - 1 > 0) {
					struct.add(UTF16, blob.getContentsSize() - 1,
						"[" + Integer.toHexString(index) + "]", null);
				}
				struct.add(BYTE, "Extra byte", "0x01 if string contains non-ASCII");
			}
		}
		return struct;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliAbstractTable.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.StructConverter;
import net.jubjubnest.minidump.contrib.pe.NTHeader;
import net.jubjubnest.minidump.contrib.pe.PeMarkupable;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;

/**
 * Generic Metadata table.  Subclasses should provided implementations for the actual
 * tables.
 */
public abstract class CliAbstractTable implements StructConverter, PeMarkupable {
	public static final String PATH = "/PE/CLI/Metadata/Tables";

	protected long readerOffset;

	protected CliTypeTable tableType;
	protected int numRows;
	protected ArrayList<CliAbstractTableRow> rows;

	protected CliStreamMetadata metadataStream;
	protected List<Integer> strings = new ArrayList<Integer>();
	protected List<Integer> blobs = new ArrayList<Integer>();
	protected List<Integer> userStrings = new ArrayList<Integer>();

	/**
	 * Creates a new generic CLI metadata table.  This is intended to be called by a subclass
	 * metadata table during its creation.
	 * 
	 * @param reader A reader that is used to read the table.
	 * @param metadataStream The metadata stream that the table lives in.
	 * @param tableType The type of table to create.
	 */
	public CliAbstractTable(BinaryReader reader, CliStreamMetadata metadataStream,
			CliTypeTable tableType) {
		this.readerOffset = reader.getPointerIndex();
		this.metadataStream = metadataStream;
		this.tableType = tableType;
		this.numRows = metadataStream.getNumberRowsForTable(tableType);
		this.rows = new ArrayList<>(this.numRows);
	}

	/**
	 * Gets this table's table type.
	 * 
	 * @return This table's table type.
	 */
	public CliTypeTable getTableType() {
		return tableType;
	}

	/**
	 * Gets the number of rows in this table.
	 * 
	 * return The number of rows in this table.
	 */
	public int getNumRows() {
		return numRows;
	}

	/**
	 * Gets the size in bytes of a row in this table.
	 * 
	 * return The size in bytes of a row in this table.
	 */
	public int getRowSize() {
		return getRowDataType().getLength();
	}

	/**
	 * Gets the size in bytes of this table.
	 * 
	 * @return The size in bytes of this table.
	 */
	public int getTableSize() {
		return getRowSize() * getNumRows();
	}

	/**
	 * Gets the row at the given index.
	 * <p>
	 * NOTE: Per ISO/IEC 23271:2012(E) III.1.9, Row indices start from 1, while heap/stream indices start from 0.
	 * 
	 * @param rowIndex The index of the row to get (starting at 1). 
	 * @return The row at the given index.
	 * @throws IndexOutOfBoundsException if the row index is invalid.
	 */
	public CliAbstractTableRow getRow(int rowIndex) throws IndexOutOfBoundsException {
		return rows.get(rowIndex - 1);
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor,
			MessageLog log, NTHeader ntHeader) throws DuplicateNameException,
			CodeUnitInsertionException, IOException, MemoryAccessException {
		// Markup is not required
	}

	/**
	 * Gets the data type of a row in this table.
	 * 
	 * @return The data type of a row in this table.
	 */
	public abstract DataType getRowDataType();

	@Override
	public DataType toDataType() {
		DataType rowDt = getRowDataType();
		int count = (numRows == 0) ? 1 : numRows;
		DataType array = new ArrayDataType(rowDt, count, rowDt.getLength());
		try {
			array.setCategoryPath(new CategoryPath(PATH));
		}
		catch (DuplicateNameException e) {
			Msg.warn(this, "Duplication category path: " + PATH);
		}
		return array;
	}


	@Override
	public String toString() {
		return tableType.toString();
	}

	/**
	 * Reads the blob index that the reader is positioned at.
	 * 
	 * @param reader A reader that is positioned at the blob index to read.
	 * @return The blob index that the reader is positioned at.
	 * @throws IOException if there is a problem reading the blob index.
	 */
	protected int readBlobIndex(BinaryReader reader) throws IOException {
		return metadataStream.getBlobIndexDataType() == DWordDataType.dataType
				? reader.readNextInt()
				: reader.readNextShort() & 0xffff;
	}

	/**
	 * Reads the string index that the reader is positioned at.
	 * 
	 * @param reader A reader that is positioned at the string index to read.
	 * @return The string index that the reader is positioned at.
	 * @throws IOException if there is a problem reading the string index.
	 */
	protected int readStringIndex(BinaryReader reader) throws IOException {
		return metadataStream.getStringIndexDataType() == DWordDataType.dataType
				? reader.readNextInt()
				: reader.readNextShort() & 0xffff;
	}

	/**
	 * Reads the GUID index that the reader is positioned at.
	 * 
	 * @param reader A reader that is positioned at the GUID index to read.
	 * @return The GUID index that the reader is positioned at.
	 * @throws IOException if there is a problem reading the GUID index.
	 */
	protected int readGuidIndex(BinaryReader reader) throws IOException {
		return metadataStream.getGuidIndexDataType() == DWordDataType.dataType
				? reader.readNextInt()
				: reader.readNextShort() & 0xffff;
	}

	/**
	 * Reads the table index that the reader is positioned at.
	 * 
	 * @param reader A reader that is positioned at the table index to read.
	 * @return The table index that the reader is positioned at.
	 * @throws IOException if there is a problem reading the table index.
	 */
	protected int readTableIndex(BinaryReader reader, CliTypeTable table) throws IOException {
		return metadataStream.getTableIndexDataType(table) == DWordDataType.dataType
				? reader.readNextInt()
				: reader.readNextShort() & 0xffff;
	}

	/**
	 * Convenience method for getting the row representation of a table.
	 * 
	 * @param table The table that has the row.
	 * @param index The index of the row.
	 * @return The row representation of a table.
	 */
	protected String getRowRepresentationSafe(CliTypeTable table, int index) {
		return metadataStream.getTable(table).getRow(index).getRepresentation();
	}

	/**
	 * Convenience method for getting a safe row representation of a table.
	 * 
	 * @param otherTable The table that has the row.
	 * @param index The index of the row.
	 * @return The safe row representation of a table.
	 */
	protected String getRowShortRepSafe(CliTypeTable otherTable, int index) {
		return metadataStream.getTable(otherTable).getRow(index).getShortRepresentation();
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliAbstractTableRow.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import net.jubjubnest.minidump.contrib.pe.cli.CliRepresentable;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;

/**
 * Generic Metadata table row.  Subclasses should provided implementations for the actual
 * table rows.
 */
public abstract class CliAbstractTableRow implements CliRepresentable {

	@Override
	public abstract String getRepresentation();
	
	@Override
	public String getShortRepresentation() {
		return getRepresentation();
	}
	
	@Override
	public String getRepresentation(CliStreamMetadata stream) {
		return getRepresentation();
	}
	
	@Override
	public String getShortRepresentation(CliStreamMetadata stream) {
		return getRepresentation(stream);
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableAssembly.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.flags.CliFlags.CliEnumAssemblyFlags;
import net.jubjubnest.minidump.contrib.pe.cli.tables.flags.CliFlags.CliEnumAssemblyHashAlgorithm;
import ghidra.program.model.data.*;

/**
 * Describes the Assembly table. One-row table stores information about the current assembly.
 */
public class CliTableAssembly extends CliAbstractTable {
	
	public class CliAssemblyRow extends CliAbstractTableRow {
		public int hashAlg;
		public short majorVersion;
		public short minorVersion;
		public short buildNumber;
		public short revisionNumber;
		public int flags;
		public int publicKeyIndex;
		public int nameIndex;
		public int cultureIndex;
		
		public CliAssemblyRow(int hashAlg, short majorVersion, short minorVersion,
				short buildNumber, short revisionNumber, int flags, int publicKeyIndex,
				int nameIndex, int cultureIndex) {
			super();
			this.hashAlg = hashAlg;
			this.majorVersion = majorVersion;
			this.minorVersion = minorVersion;
			this.buildNumber = buildNumber;
			this.revisionNumber = revisionNumber;
			this.flags = flags;
			this.publicKeyIndex = publicKeyIndex;
			this.nameIndex = nameIndex;
			this.cultureIndex = cultureIndex;
		}

		@Override
		public String getRepresentation() {
			return String.format(
				"%s v%d.%d build%d rev%d pubkey index %x culture index %x flags %s",
				metadataStream.getStringsStream().getString(nameIndex),
				majorVersion, minorVersion, buildNumber, revisionNumber, publicKeyIndex,
				cultureIndex, CliEnumAssemblyFlags.dataType.getName(flags & 0xffffffff));
		}
	}
	
	public CliTableAssembly(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		StructureDataType rowDt = (StructureDataType) this.toDataType();
		for (int i = 0; i < this.numRows; i++) {
			reader.setPointerIndex(this.readerOffset + rowDt.getLength() * i);
			CliAssemblyRow row = new CliAssemblyRow(reader.readNextInt(), reader.readNextShort(), reader.readNextShort(), reader.readNextShort(), 
				reader.readNextShort(), reader.readNextInt(), readBlobIndex(reader), readStringIndex(reader), readStringIndex(reader));
			rows.add(row);
			blobs.add(row.publicKeyIndex);
			strings.add(row.nameIndex);
			strings.add(row.cultureIndex);
		}
		reader.setPointerIndex(this.readerOffset);
	}
	
	@Override
	public DataType getRowDataType() {
		return toDataType();
	}
	
	@Override
	public DataType toDataType() {
		Structure table = new StructureDataType(new CategoryPath(PATH), "Assembly Table", 0);
		table.add(CliEnumAssemblyHashAlgorithm.dataType, "HashAlg", "Type of hash present");
		table.add( WORD, "MajorVersion", null);
		table.add( WORD, "MinorVersion", null);
		table.add( WORD, "BuildNumber", null);
		table.add( WORD, "RevisionNumber", null);
		table.add(CliEnumAssemblyFlags.dataType, "Flags", "Bitmask of type AssemblyFlags");
		table.add(metadataStream.getBlobIndexDataType(), "PublicKey", "index into Blob heap");
		table.add(metadataStream.getStringIndexDataType(), "Name", "index into String heap");
		table.add(metadataStream.getStringIndexDataType(), "Culture", "index into String heap");
		return table;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableAssemblyOS.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import ghidra.program.model.data.*;

/**
 * Describes the AssemblyOS table. Apparently it is ignored by the CLI and shouldn't be found in an Assembly.
 */
public class CliTableAssemblyOS extends CliAbstractTable {
	public class CliAssemblyOSRow extends CliAbstractTableRow {
		public int osPlatformID;
		public int osMajorVersion;
		public int osMinorVersion;
		
		public CliAssemblyOSRow(int osPlatformID, int osMajorVersion, int osMinorVersion) {
			super();
			this.osPlatformID = osPlatformID;
			this.osMajorVersion = osMajorVersion;
			this.osMinorVersion = osMinorVersion;
		}

		@Override
		public String getRepresentation() {
			return String.format("Platform %d v%d.%d", osPlatformID, osMajorVersion, osMinorVersion);
		}
	}
	
	public CliTableAssemblyOS(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			rows.add(new CliAssemblyOSRow(reader.readNextInt(), reader.readNextInt(), reader.readNextInt()));
		}
	}
	
	@Override
	public DataType getRowDataType() {
		return toDataType();
	}

	@Override
	public DataType toDataType() {
		Structure rowDt = new StructureDataType(new CategoryPath(PATH), "AssemblyOS Row", 0);
		rowDt.add(DWORD, "OSPlatformID", null);
		rowDt.add(DWORD, "OSMajorVersion", null);
		rowDt.add(DWORD, "OSMinorVersion", null);
		return new ArrayDataType(rowDt, this.numRows, rowDt.getLength());
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableAssemblyProcessor.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import ghidra.program.model.data.*;

/**
 * Describes the AssemblyProcessor table. It is apparently ignored by the CLI and shouldn't be found in an assembly.
 */
public class CliTableAssemblyProcessor extends CliAbstractTable {
	public class CliAssemblyProcessorRow extends CliAbstractTableRow {
		public int processor;
		
		public CliAssemblyProcessorRow(int processor) {
			this.processor = processor;
		}
		
		@Override
		public String getRepresentation() {
			return String.format("Processor %d", processor);
		}
	}
	public CliTableAssemblyProcessor(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			rows.add(new CliAssemblyProcessorRow(reader.readNextInt()));
		}
	}

	@Override
	public DataType getRowDataType() {
		return toDataType();
	}
	
	@Override
	public DataType toDataType() {
		Structure rowDt = new StructureDataType(new CategoryPath(PATH), "AssemblyProcessor Row", 0);
		rowDt.add(DWORD, "Processor", null);
		return new ArrayDataType(rowDt, this.numRows, rowDt.getLength());
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableAssemblyRef.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.flags.CliFlags.CliEnumAssemblyFlags;
import ghidra.program.model.data.*;

/**
 * Describes the AssemblyRef table. Each row is a reference to an external assembly.
 */
public class CliTableAssemblyRef extends CliAbstractTable {
	public class CliAssemblyRefRow extends CliAbstractTableRow {
		public short majorVersion;
		public short minorVersion;
		public short buildNumber;
		public short revisionNumber;
		public int flags;
		public int publicKeyOrTokenIndex;
		public int nameIndex;
		public int cultureIndex;
		public int hashValueIndex;
		
		public CliAssemblyRefRow(short majorVersion, short minorVersion, short buildNumber,
				short revisionNumber, int flags, int publicKeyOrTokenIndex, int nameIndex,
				int cultureIndex, int hashValueIndex) {
			super();
			this.majorVersion = majorVersion;
			this.minorVersion = minorVersion;
			this.buildNumber = buildNumber;
			this.revisionNumber = revisionNumber;
			this.flags = flags;
			this.publicKeyOrTokenIndex = publicKeyOrTokenIndex;
			this.nameIndex = nameIndex;
			this.cultureIndex = cultureIndex;
			this.hashValueIndex = hashValueIndex;
		}

		@Override
		public String getRepresentation() {
			return String.format(
				"AsmRef: %s v%d.%d build%d rev%d pubkey index %x culture index %x hash index %x flags %s",
				metadataStream.getStringsStream().getString(nameIndex),
				majorVersion, minorVersion, buildNumber, revisionNumber, publicKeyOrTokenIndex,
				cultureIndex, hashValueIndex,
				CliEnumAssemblyFlags.dataType.getName(flags & 0xffffffff));
		}
		
		@Override
		public String getShortRepresentation() {
			return String.format("%s v%d.%d build%d rev%d",
				metadataStream.getStringsStream().getString(nameIndex),
				majorVersion, minorVersion, buildNumber, revisionNumber);
		}
	}
	
	public CliTableAssemblyRef(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		StructureDataType rowDt = this.getRowDataType();
		for (int i = 0; i < this.numRows; i++) {
			reader.setPointerIndex(this.readerOffset + rowDt.getLength() * i);
			CliAssemblyRefRow row = new CliAssemblyRefRow(reader.readNextShort(), reader.readNextShort(), reader.readNextShort(), reader.readNextShort(), 
				reader.readNextInt(), readBlobIndex(reader), readStringIndex(reader), readStringIndex(reader), readBlobIndex(reader)); 
			rows.add(row);
			blobs.add(row.publicKeyOrTokenIndex);
			strings.add(row.nameIndex);
			strings.add(row.cultureIndex);
			blobs.add(row.hashValueIndex);
		}
		reader.setPointerIndex(this.readerOffset);
	}
	
	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "AssemblyRef Row", 0);
		rowDt.add( WORD, "MajorVersion", null);
		rowDt.add( WORD, "MinorVersion", null);
		rowDt.add( WORD, "BuildNumber", null);
		rowDt.add( WORD, "RevisionNumber", null);
		rowDt.add(CliEnumAssemblyFlags.dataType, "Flags", "Bitmask of type AssemblyFlags"); // TODO: AssemblyFlags
		rowDt.add(metadataStream.getBlobIndexDataType(), "PublicKeyOrToken", "Public Key or token identifying the author of the assembly.");
		rowDt.add(metadataStream.getStringIndexDataType(), "Name", "index into String heap");
		rowDt.add(metadataStream.getStringIndexDataType(), "Culture", "index into String heap");
		rowDt.add(metadataStream.getBlobIndexDataType(), "HashValue", "index into Blob heap");
		return rowDt;
	}
	
	@Override
	public DataType toDataType() {
		DataType rowDt = getRowDataType();
		return new ArrayDataType(rowDt, this.numRows, rowDt.getLength());
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableAssemblyRefOS.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import ghidra.program.model.data.*;

/**
 * Describes the AssemblyRefOS table. Apparently it is ignored by the CLI and shouldn't be found in an assembly.
 */
public class CliTableAssemblyRefOS extends CliAbstractTable {
	public class CliAssemblyRefOSRow extends CliAbstractTableRow {
		public int osPlatformID;
		public int osMajorVersion;
		public int osMinorVersion;
		public int assemblyRefIndex;
		
		public CliAssemblyRefOSRow(int osPlatformID, int osMajorVersion, int osMinorVersion, int assemblyRefIndex) {
			super();
			this.osPlatformID = osPlatformID;
			this.osMajorVersion = osMajorVersion;
			this.osMinorVersion = osMinorVersion;
			this.assemblyRefIndex = assemblyRefIndex;
		}

		@Override
		public String getRepresentation() {
			return String.format("%d v%d.%d", osPlatformID, osMajorVersion, osMinorVersion);
		}
	}
	
	public CliTableAssemblyRefOS(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			rows.add(new CliAssemblyRefOSRow(reader.readNextInt(), reader.readNextInt(), reader.readNextInt(), readTableIndex(reader, CliTypeTable.AssemblyRef)));
		}
	}
	
	@Override
	public DataType getRowDataType() {
		return toDataType();
	}

	@Override
	public DataType toDataType() {
		Structure rowDt = new StructureDataType(new CategoryPath(PATH), "AssemblyRefOS Row", 0);
		rowDt.add(DWORD, "OSPlatformID", null);
		rowDt.add(DWORD, "OSMajorVersion", null);
		rowDt.add(DWORD, "OSMinorVersion", null);
		rowDt.add(metadataStream.getTableIndexDataType(CliTypeTable.AssemblyRef), "AssemblyRef", "index into AssemblyRef table");
		return new ArrayDataType(rowDt, this.numRows, rowDt.getLength());
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableAssemblyRefProcessor.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import ghidra.program.model.data.*;

/**
 * Describes the AssemblyRefProcessor table. Apparently it is ignored by the CLI and shouldn't be present in an assembly.
 */
public class CliTableAssemblyRefProcessor extends CliAbstractTable {
	public class CliAssemblyRefProcessorRow extends CliAbstractTableRow {
		public int processor;
		public int assemblyRefIndex;
		
		public CliAssemblyRefProcessorRow(int processor, int assemblyRefIndex) {
			super();
			this.processor = processor;
			this.assemblyRefIndex = assemblyRefIndex;
		}

		@Override
		public String getRepresentation() {
			return String.format("Processor %d AssemblyRef: %s", processor,
				getRowRepresentationSafe(CliTypeTable.AssemblyRef, assemblyRefIndex));
		}
	}
	
	public CliTableAssemblyRefProcessor(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			rows.add(new CliAssemblyRefProcessorRow(reader.readNextInt(), readTableIndex(reader, CliTypeTable.AssemblyRef)));
		}
	}

	@Override
	public DataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "AssemblyRefProcessor Row", 0);
		rowDt.add(DWORD, "Processor", null);
		rowDt.add(metadataStream.getTableIndexDataType(CliTypeTable.AssemblyRef), "AssemblyRef", "index into AssemblyRef table");
		return rowDt;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableClassLayout.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;

/**
 * Describes the ClassLayout table. Each row has information that's useful when handing something from managed to unmanaged code.
 */
public class CliTableClassLayout extends CliAbstractTable {
	public class CliClassLayoutRow extends CliAbstractTableRow {
		public short packingSize;
		public int classSize;
		public int parentIndex;
		
		public CliClassLayoutRow(short packingSize, int classSize, int parentIndex) {
			super();
			this.packingSize = packingSize;
			this.classSize = classSize;
			this.parentIndex = parentIndex;
		}

		@Override
		public String getRepresentation() {
			return String.format("Packing %d ClassSize %d Parent %s", packingSize, classSize,
				getRowRepresentationSafe(CliTypeTable.TypeDef, parentIndex));
		}
	}
	
	public CliTableClassLayout(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			rows.add(new CliClassLayoutRow(reader.readNextShort(), reader.readNextInt(), readTableIndex(reader, CliTypeTable.TypeDef)));
		}
	}
	
	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "ClassLayout Row", 0);
		rowDt.add( WORD, "PackingSize", null);
		rowDt.add(DWORD, "ClassSize", null);
		rowDt.add(metadataStream.getTableIndexDataType(CliTypeTable.TypeDef), "Parent", null);
		return rowDt;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableConstant.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.blobs.CliAbstractSig.CliTypeCodeDataType;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.indexes.CliIndexHasConstant;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;
import ghidra.util.exception.InvalidInputException;

/**
 * Describes the Constant table. Each row represents a constant value for a Param, Field, or Property.
 */
public class CliTableConstant extends CliAbstractTable {
	public class CliConstantRow extends CliAbstractTableRow {
		public byte type;
		public byte reserved;
		public int parentIndex;
		public int valueIndex;
		
		public CliConstantRow(byte type, byte reserved, int parentIndex, int valueIndex) {
			super();
			this.type = type;
			this.reserved = reserved;
			this.parentIndex = parentIndex;
			this.valueIndex = valueIndex;
		}

		@Override
		public String getRepresentation() {
			String parentRep;
			try {
				parentRep =
					getRowRepresentationSafe(CliIndexHasConstant.getTableName(parentIndex),
						CliIndexHasConstant.getRowIndex(parentIndex));
			}
			catch (InvalidInputException e) {
				parentRep = Integer.toHexString(parentIndex);
			}
			return String.format("Type %d Parent %s Value %x", type, parentRep, valueIndex);
		}
	}

	public CliTableConstant(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			CliConstantRow row = new CliConstantRow(reader.readNextByte(), reader.readNextByte(), CliIndexHasConstant.readCodedIndex(reader, stream), readBlobIndex(reader));
			rows.add(row);
			blobs.add(row.valueIndex);
		}
		reader.setPointerIndex(this.readerOffset);
	}
	
	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "Constant Row", 0);
		rowDt.add(CliTypeCodeDataType.dataType, "Type", "if Class, indicates nullref");
		rowDt.add( BYTE, "Reserved", "should be 0");
		rowDt.add(CliIndexHasConstant.toDataType(metadataStream), "Parent", "index - coded HasConstant");
		rowDt.add(metadataStream.getBlobIndexDataType(), "Value", "index into Blob heap");
		return rowDt;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableCustomAttribute.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.indexes.CliIndexCustomAttributeType;
import net.jubjubnest.minidump.contrib.pe.cli.tables.indexes.CliIndexHasCustomAttribute;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;
import ghidra.util.exception.InvalidInputException;

/**
 * Describes the CustomAttribute table. 
 */
public class CliTableCustomAttribute extends CliAbstractTable {
	public class CliCustomAttributeRow extends CliAbstractTableRow {
		public int parentIndex;
		public int typeIndex;
		public int valueIndex;
		
		public CliCustomAttributeRow(int parentIndex, int typeIndex, int valueIndex) {
			super();
			this.parentIndex = parentIndex;
			this.typeIndex = typeIndex;
			this.valueIndex = valueIndex;
		}

		@Override
		public String getRepresentation() {
			String parentRep, typeRep;
			try {
				parentRep = getRowRepresentationSafe(CliIndexHasCustomAttribute.getTableName(parentIndex), CliIndexHasCustomAttribute.getRowIndex(parentIndex));
			}
			catch (InvalidInputException e) {
				parentRep = Integer.toHexString(parentIndex);
			}
			try {
				typeRep = getRowRepresentationSafe(CliIndexCustomAttributeType.getTableName(parentIndex), CliIndexCustomAttributeType.getRowIndex(parentIndex));
			}
			catch (InvalidInputException e) {
				typeRep = Integer.toHexString(typeIndex);
			}
			return String.format("Parent %s Type %s Value %x", parentRep, typeRep, valueIndex);
		}
	}
	public CliTableCustomAttribute(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			CliCustomAttributeRow row = new CliCustomAttributeRow(CliIndexHasCustomAttribute.readCodedIndex(reader, stream), 
				CliIndexCustomAttributeType.readCodedIndex(reader, stream), readBlobIndex(reader));
			rows.add(row);
			blobs.add(row.valueIndex);
		}
		reader.setPointerIndex(this.readerOffset);
	}
	
	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "CustomAttribute Row", 0);
		rowDt.add(CliIndexHasCustomAttribute.toDataType(metadataStream), "Parent", null);
		rowDt.add(CliIndexCustomAttributeType.toDataType(metadataStream), "Type", null);
		rowDt.add(metadataStream.getBlobIndexDataType(), "Value", null);
		return rowDt;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableDeclSecurity.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.indexes.CliIndexHasDeclSecurity;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;
import ghidra.util.exception.InvalidInputException;

/**
 * Describes the DeclSecurity table. Each row attaches security attributes to a class, method, or assembly.
 */
public class CliTableDeclSecurity extends CliAbstractTable {
	public class CliDeclSecurityRow extends CliAbstractTableRow {
		public short action;
		public int parentIndex;
		public int permissionSetIndex;
		
		public CliDeclSecurityRow(short action, int parentIndex, int permissionSetIndex) {
			super();
			this.action = action;
			this.parentIndex = parentIndex;
			this.permissionSetIndex = permissionSetIndex;
		}

		@Override
		public String getRepresentation() {
			String parentRep;
			try {
				parentRep = getRowRepresentationSafe(CliIndexHasDeclSecurity.getTableName(parentIndex), CliIndexHasDeclSecurity.getRowIndex(parentIndex));
			}
			catch (InvalidInputException e) {
				parentRep = Integer.toHexString(parentIndex);
			}
			return String.format("Action %d Parent %s PermissionSet %x", action, parentRep, permissionSetIndex);
		}
	}
	
	public CliTableDeclSecurity(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			CliDeclSecurityRow row = new CliDeclSecurityRow(reader.readNextShort(), CliIndexHasDeclSecurity.readCodedIndex(reader, stream), readBlobIndex(reader));
			blobs.add(row.permissionSetIndex);
		}
		reader.setPointerIndex(this.readerOffset);
	}
	
	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "DeclSecurity Row", 0);
		rowDt.add( WORD, "Action", "Points to a System.Security.SecurityAction as described in ISO23271 IV");
		rowDt.add(CliIndexHasDeclSecurity.toDataType(metadataStream), "Parent", null);
		rowDt.add(metadataStream.getBlobIndexDataType(), "PermissionSet", null);
		return rowDt;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableEvent.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.flags.CliFlags.CliEnumEventAttributes;
import net.jubjubnest.minidump.contrib.pe.cli.tables.indexes.CliIndexTypeDefOrRef;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;
import ghidra.util.exception.InvalidInputException;

/**
 * Describes the Event table. Each row represents an event. References to this table are to contiguous runs of events.
 * The "run" begins at the specified index and ends at the next place a reference from EventMap points, or the end of this table. 
 */
public class CliTableEvent extends CliAbstractTable {
	public class CliEventRow extends CliAbstractTableRow {
		public short eventFlags;
		public int nameIndex;
		public int eventTypeIndex;
		
		public CliEventRow(short eventFlags, int nameIndex, int eventTypeIndex) {
			super();
			this.eventFlags = eventFlags;
			this.nameIndex = nameIndex;
			this.eventTypeIndex = eventTypeIndex;
		}

		@Override
		public String getRepresentation() {
			String eventRep;
			try {
				eventRep = getRowRepresentationSafe(CliIndexTypeDefOrRef.getTableName(eventTypeIndex), CliIndexTypeDefOrRef.getRowIndex(eventTypeIndex));
			}
			catch (InvalidInputException e) {
				eventRep = Integer.toHexString(eventTypeIndex);
			}
			return String.format("%s Flags %s Type %s",
				metadataStream.getStringsStream().getString(nameIndex),
				CliEnumEventAttributes.dataType.getName(eventFlags & 0xffff), eventRep);
		}
	}
	
	public CliTableEvent(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			CliEventRow row = new CliEventRow(reader.readNextShort(), readStringIndex(reader), CliIndexTypeDefOrRef.readCodedIndex(reader, stream));
			rows.add(row);
			strings.add(row.nameIndex);
		}
		reader.setPointerIndex(this.readerOffset);
	}
	
	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "Event Row", 0);
		rowDt.add(CliEnumEventAttributes.dataType, "EventFlags", null);
		rowDt.add(metadataStream.getStringIndexDataType(), "Name", null);
		rowDt.add(CliIndexTypeDefOrRef.toDataType(metadataStream), "EventType", "type of Event, not of owning class");
		return rowDt;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableEventMap.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;

/**
 * Describes the EventMap table. Each row is an event list for a class.
 */
public class CliTableEventMap extends CliAbstractTable {
	public class CliEventMapRow extends CliAbstractTableRow {
		public int parentIndex;
		public int eventIndex;
		
		public CliEventMapRow(int parentIndex, int eventIndex) {
			super();
			this.parentIndex = parentIndex;
			this.eventIndex = eventIndex;
		}

		@Override
		public String getRepresentation() {
			return String.format("Parent %s EventList %s", getRowRepresentationSafe(CliTypeTable.TypeDef, parentIndex), getRowRepresentationSafe(CliTypeTable.Event, eventIndex));
		}
	}
	
	public CliTableEventMap(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			rows.add(new CliEventMapRow(readTableIndex(reader, CliTypeTable.TypeDef), readTableIndex(reader, CliTypeTable.Event)));
		}
	}
	
	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "EventMap Row", 0);
		rowDt.add(metadataStream.getTableIndexDataType(CliTypeTable.TypeDef), "Parent", null);
		rowDt.add(metadataStream.getTableIndexDataType(CliTypeTable.Event), "EventList", "First of a contiguous run in Event table, ending with next EventMap reference or end of table.");
		return rowDt;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableExportedType.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.flags.CliFlags.CliEnumTypeAttributes;
import net.jubjubnest.minidump.contrib.pe.cli.tables.indexes.CliIndexHasConstant;
import net.jubjubnest.minidump.contrib.pe.cli.tables.indexes.CliIndexImplementation;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;
import ghidra.util.exception.InvalidInputException;

/**
 * Describes the ExportedType table.
 */
public class CliTableExportedType extends CliAbstractTable {
	public class CliExportedTypeRow extends CliAbstractTableRow {
		public int flags;
		public int typeDefIdIndex;
		public int typeNameIndex;
		public int typeNamespaceIndex;
		public int implementationIndex;
		
		public CliExportedTypeRow(int flags, int typeDefIdIndex, int typeNameIndex,
				int typeNamespaceIndex, int implementationIndex) {
			super();
			this.flags = flags;
			this.typeDefIdIndex = typeDefIdIndex;
			this.typeNameIndex = typeNameIndex;
			this.typeNamespaceIndex = typeNamespaceIndex;
			this.implementationIndex = implementationIndex;
		}

		@Override
		public String getRepresentation() {
			String implRep;
			try {
				implRep = getRowRepresentationSafe(CliIndexImplementation.getTableName(implementationIndex), CliIndexHasConstant.getRowIndex(implementationIndex));
			}
			catch (InvalidInputException e) {
				implRep = Integer.toHexString(implementationIndex);
			}
			return String.format("%s Namespace %s Flags %s TypeDef %s Implementation %s",
				metadataStream.getStringsStream().getString(typeNameIndex),
				metadataStream.getStringsStream().getString(typeNamespaceIndex),
				CliEnumTypeAttributes.dataType.getName(flags & 0xffffffff), "", implRep);
				// TODO: getRowFromTable(TableName.TypeDef, typeDefIdIndex) instead of "", need to verify the meaning of the field. can there be multiple modules per assembly?
		}
	}
	
	public CliTableExportedType(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			CliExportedTypeRow row = new CliExportedTypeRow(reader.readNextInt(), reader.readNextInt(), readStringIndex(reader), readStringIndex(reader),
				CliIndexImplementation.readCodedIndex(reader, stream));
			rows.add(row);
			strings.add(row.typeNameIndex);
			strings.add(row.typeNamespaceIndex);
		}
		reader.setPointerIndex(this.readerOffset);
	}
	
	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "ExportedType Row", 0);
		rowDt.add(CliEnumTypeAttributes.dataType, "Flags", "Bitmask of type TypeAttributes");
		rowDt.add(DWORD, "TypeDefId", "4B index into TypeDef table of another module in this Assembly. Hint only. Must match other fields in this row.");
		rowDt.add(metadataStream.getStringIndexDataType(), "TypeName", "index into String heap");
		rowDt.add(metadataStream.getStringIndexDataType(), "TypeNamespace", "index into String heap");
		rowDt.add(CliIndexImplementation.toDataType(metadataStream), "Implementation", "index into File or ExportedType table.");
		return rowDt;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableField.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.NTHeader;
import net.jubjubnest.minidump.contrib.pe.cli.blobs.CliBlob;
import net.jubjubnest.minidump.contrib.pe.cli.blobs.CliSigField;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliAbstractStream;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.flags.CliFlags.CliEnumFieldAttributes;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;
import ghidra.program.model.listing.Program;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;

/**
 * Describes the Field table. Each row represents a field in a TypeDef class. Fields are stored one after the other, grouped by class.
 * References to the Field table encode where the fields for a class start and end.
 */
public class CliTableField extends CliAbstractTable {
	public class CliFieldRow extends CliAbstractTableRow {
		public short flags;
		public int nameIndex;
		public int sigIndex;

		public static final int TYPEDEF_OWNER_INIT_VALUE = -1;
		public int typeDefOwnerIndex = TYPEDEF_OWNER_INIT_VALUE;

		public CliFieldRow(short flags, int nameIndex, int sigIndex) {
			super();
			this.flags = flags;
			this.nameIndex = nameIndex;
			this.sigIndex = sigIndex;
		}

		@Override
		public String getRepresentation() {
			String sigRep = Integer.toHexString(sigIndex);
			CliBlob sigBlob = metadataStream.getBlobStream().getBlob(sigIndex);
			try {
				CliSigField fieldSig;
				fieldSig = new CliSigField(sigBlob);
				sigRep = fieldSig.getShortRepresentation(metadataStream);
			}
			catch (IOException e) {
			}

			String ownerRep;
			if (typeDefOwnerIndex == TYPEDEF_OWNER_INIT_VALUE) {
				ownerRep = "";
			}
			else {
				ownerRep = getRowShortRepSafe(CliTypeTable.TypeDef, typeDefOwnerIndex) + "::";
			}

			return String.format("%s %s%s Flags %s", sigRep, ownerRep,
				metadataStream.getStringsStream().getString(nameIndex),
				CliEnumFieldAttributes.dataType.getName(flags & 0xffff));
		}
	}

	public CliTableField(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId)
			throws IOException {
		super(reader, stream, tableId);
		CliTableTypeDef typeDefTable =
			(CliTableTypeDef) metadataStream.getTable(CliTypeTable.TypeDef);
		for (int i = 0; i < this.numRows; i++) {
			CliFieldRow row = new CliFieldRow(reader.readNextShort(), readStringIndex(reader),
				readBlobIndex(reader));
			rows.add(row);
			strings.add(row.nameIndex);

			// Figure out owner of this field
			row.typeDefOwnerIndex = typeDefTable.getOwnerOfFieldIndex(i);
		}
		reader.setPointerIndex(this.readerOffset);
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor, MessageLog log,
			NTHeader ntHeader)
			throws DuplicateNameException, CodeUnitInsertionException, IOException {
		for (CliAbstractTableRow row : rows) {
			CliFieldRow fieldRow = (CliFieldRow) row;

			// Create FieldSig object and bookmark it
			Address sigAddr = CliAbstractStream.getStreamMarkupAddress(program, isBinary, monitor,
				log, ntHeader, metadataStream.getBlobStream(), fieldRow.sigIndex);

			CliSigField fieldSig =
				new CliSigField(metadataStream.getBlobStream().getBlob(fieldRow.sigIndex));
			metadataStream.getBlobStream().updateBlob(fieldSig, sigAddr, program);
		}
	}

	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "Field Row", 0);
		rowDt.add(CliEnumFieldAttributes.dataType, "Flags", "see CorFieldAttr");
		rowDt.add(metadataStream.getStringIndexDataType(), "Name", "index into String heap");
		rowDt.add(metadataStream.getBlobIndexDataType(), "Signature", "index into Blob heap");
		return rowDt;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableFieldLayout.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;

/**
 * Describes the FieldLayout table. Serves a similar purpose to ClassLayout; it's useful when passing to unmanaged code.
 */
public class CliTableFieldLayout extends CliAbstractTable {
	public class CliFieldLayoutRow extends CliAbstractTableRow {
		public int offset;
		public int fieldIndex;
		
		public CliFieldLayoutRow(int offset, int fieldIndex) {
			super();
			this.offset = offset;
			this.fieldIndex = fieldIndex;
		}

		@Override
		public String getRepresentation() {
			return String.format("Field %s Offset %d", getRowRepresentationSafe(CliTypeTable.Field, fieldIndex), offset);
		}
	}
	
	public CliTableFieldLayout(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			rows.add(new CliFieldLayoutRow(reader.readNextInt(), readTableIndex(reader, CliTypeTable.Field)));
		}
		reader.setPointerIndex(this.readerOffset);
	}
	
	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "FieldLayout Row", 0);
		rowDt.add(DWORD, "Offset", null);
		rowDt.add(metadataStream.getTableIndexDataType(CliTypeTable.Field), "Field", null);
		return rowDt;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableFieldMarshall.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.NTHeader;
import net.jubjubnest.minidump.contrib.pe.cli.blobs.CliBlobMarshalSpec;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliAbstractStream;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.indexes.CliIndexHasFieldMarshall;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;
import ghidra.program.model.listing.Program;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.exception.InvalidInputException;
import ghidra.util.task.TaskMonitor;

/**
 * Describes the FieldMarshall table. Each row indicates how a Param or Field should be treated when calling from or to unmanaged code.
 */
public class CliTableFieldMarshall extends CliAbstractTable {
	public class CliFieldMarshallRow extends CliAbstractTableRow {
		public int parentIndex;
		public int nativeTypeIndex;

		public CliFieldMarshallRow(int parentIndex, int nativeTypeIndex) {
			super();
			this.parentIndex = parentIndex;
			this.nativeTypeIndex = nativeTypeIndex;
		}

		@Override
		public String getRepresentation() {
			String parentRep;
			try {
				parentRep =
					getRowRepresentationSafe(CliIndexHasFieldMarshall.getTableName(parentIndex),
						CliIndexHasFieldMarshall.getRowIndex(parentIndex));
			}
			catch (InvalidInputException e) {
				parentRep = Integer.toHexString(parentIndex);
			}
			String nativeTypeRep = Integer.toHexString(nativeTypeIndex); // TODO: Implement NativeType Blob
			return String.format("Parent %s Native Type %s", parentRep, nativeTypeRep);
		}
	}

	public CliTableFieldMarshall(BinaryReader reader, CliStreamMetadata stream,
			CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			CliFieldMarshallRow row = new CliFieldMarshallRow(
				CliIndexHasFieldMarshall.readCodedIndex(reader, stream), readBlobIndex(reader));
			rows.add(row);
		}
		reader.setPointerIndex(this.readerOffset);
	}

	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt =
			new StructureDataType(new CategoryPath(PATH), "FieldMarshall Row", 0);
		rowDt.add(CliIndexHasFieldMarshall.toDataType(metadataStream), "Parent", null);
		rowDt.add(metadataStream.getBlobIndexDataType(), "NativeType", null);
		return rowDt;
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor, MessageLog log,
			NTHeader ntHeader)
			throws DuplicateNameException, CodeUnitInsertionException, IOException {
		for (CliAbstractTableRow row : rows) {
			Integer nativeTypeIndex = ((CliFieldMarshallRow) row).nativeTypeIndex;
			Address addr = CliAbstractStream.getStreamMarkupAddress(program, isBinary, monitor, log,
				ntHeader, metadataStream.getBlobStream(), nativeTypeIndex);

			// Create MarshalSpec Blob object
			CliBlobMarshalSpec blob =
				new CliBlobMarshalSpec(metadataStream.getBlobStream().getBlob(nativeTypeIndex));
			metadataStream.getBlobStream().updateBlob(blob, addr, program);
		}
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableFieldRVA.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;

/**
 * Describes the FieldRVA table. Each row gives the RVA location of an initial value for each Field.
 */
public class CliTableFieldRVA extends CliAbstractTable {
	public class CliFieldRVARow extends CliAbstractTableRow {
		public int rva;
		public int fieldIndex;
		
		public CliFieldRVARow(int rva, int fieldIndex) {
			super();
			this.rva = rva;
			this.fieldIndex = fieldIndex;
		}

		@Override
		public String getRepresentation() {
			return String.format("Field %s RVA %x", getRowRepresentationSafe(CliTypeTable.Field, fieldIndex), rva);
		}
	}
	
	public CliTableFieldRVA(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			rows.add(new CliFieldRVARow(reader.readNextInt(), readTableIndex(reader, CliTypeTable.Field)));
		}
		reader.setPointerIndex(this.readerOffset);
	}

	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "FieldRVA Row", 0);
		rowDt.add(DWORD, "RVA", null);
		rowDt.add(metadataStream.getTableIndexDataType(CliTypeTable.Field), "Field", "index into Field table");
		return rowDt;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableFile.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.flags.CliFlags.CliEnumFileAttributes;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;

/**
 * Describes the File table. Each row is a reference to an external file.
 */
public class CliTableFile extends CliAbstractTable {
	public class CliFileRow extends CliAbstractTableRow {
		public int flags;
		public int nameIndex;
		public int hashIndex;
		
		public CliFileRow(int flags, int nameIndex, int hashIndex) {
			super();
			this.flags = flags;
			this.nameIndex = nameIndex;
			this.hashIndex = hashIndex;
		}

		@Override
		public String getRepresentation() {
			String hashRep = "Index " + Integer.toHexString(hashIndex); // TODO: Make this reflect the blob contents (encoded hash? byte array?)
			return String.format("%s Hash %s Flags %s",
				metadataStream.getStringsStream().getString(nameIndex), hashRep,
				CliEnumFileAttributes.dataType.getName(flags & 0xffffffff));
		}
	}
	
	public CliTableFile(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			CliFileRow row = new CliFileRow(reader.readNextInt(), readStringIndex(reader), readBlobIndex(reader));
			rows.add(row);
			strings.add(row.nameIndex);
			blobs.add(row.hashIndex);
		}
		reader.setPointerIndex(this.readerOffset);

	}
	
	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "File Row", 0);
		rowDt.add(CliEnumFileAttributes.dataType, "Flags", "Bitmask of type FileAttributes");
		rowDt.add(metadataStream.getStringIndexDataType(), "Name", "index into String heap");
		rowDt.add(metadataStream.getBlobIndexDataType(), "Hash", "index into Blob heap");
		return rowDt;
	}
	
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableGenericParam.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.flags.CliFlags.CliEnumGenericParamAttributes;
import net.jubjubnest.minidump.contrib.pe.cli.tables.indexes.CliIndexTypeOrMethodDef;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;
import ghidra.util.exception.InvalidInputException;

/**
 * Describes the GenericParam table.
 */
public class CliTableGenericParam extends CliAbstractTable {
	public class CliGenericParamRow extends CliAbstractTableRow {
		public short number;
		public short flags;
		public int ownerIndex;
		public int nameIndex;
		
		public CliGenericParamRow(short number, short flags, int ownerIndex, int nameIndex) {
			super();
			this.number = number;
			this.flags = flags;
			this.ownerIndex = ownerIndex;
			this.nameIndex = nameIndex;
		}

		@Override
		public String getRepresentation() {
			String ownerRep;
			try {
				ownerRep = getRowRepresentationSafe(CliIndexTypeOrMethodDef.getTableName(ownerIndex), CliIndexTypeOrMethodDef.getRowIndex(ownerIndex));
			}
			catch (InvalidInputException e) {
				ownerRep = Integer.toHexString(ownerIndex);
			}
			return String.format("%s Owner %s Number %d Flags %s",
				metadataStream.getStringsStream().getString(nameIndex),
				ownerRep, number,
				CliEnumGenericParamAttributes.dataType.getName(flags & 0xffff));
		}
	}
	
	public CliTableGenericParam(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			CliGenericParamRow row = new CliGenericParamRow(reader.readNextShort(), reader.readNextShort(), 
				CliIndexTypeOrMethodDef.readCodedIndex(reader, stream), readStringIndex(reader));
			rows.add(row);
			strings.add(row.nameIndex);
		}
		reader.setPointerIndex(this.readerOffset);
	}

	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "GenericParam Row", 0);
		rowDt.add( WORD, "Number", "index of the generic param, numbered left-to-right, from 0");
		rowDt.add(CliEnumGenericParamAttributes.dataType, "Flags", "Bitmask of type GenericParamAttributes");
		rowDt.add(CliIndexTypeOrMethodDef.toDataType(metadataStream), "Owner", "TypeOrMethodDef coded index");
		rowDt.add(metadataStream.getStringIndexDataType(), "Name", "index into String heap, for description only");
		return rowDt;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableGenericParamConstraint.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.indexes.CliIndexTypeDefOrRef;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;
import ghidra.util.exception.InvalidInputException;

/**
 * Describes the GenericParamConstraint table.
 */
public class CliTableGenericParamConstraint extends CliAbstractTable {
	public class CliGenericParamConstraintRow extends CliAbstractTableRow {
		public int ownerIndex;
		public int constraintIndex;
		
		public CliGenericParamConstraintRow(int ownerIndex, int constraintIndex) {
			super();
			this.ownerIndex = ownerIndex;
			this.constraintIndex = constraintIndex;
		}

		@Override
		public String getRepresentation() {
			String constraintRep;
			try {
				constraintRep = getRowRepresentationSafe(CliIndexTypeDefOrRef.getTableName(constraintIndex), CliIndexTypeDefOrRef.getRowIndex(constraintIndex));
			}
			catch (InvalidInputException e) {
				constraintRep = Integer.toHexString(constraintIndex);
			}
			return String.format("Constraint %s Owner %s", constraintRep, getRowRepresentationSafe(CliTypeTable.GenericParam, ownerIndex));
		}
	}
	
	public CliTableGenericParamConstraint(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			rows.add(new CliGenericParamConstraintRow(readTableIndex(reader, CliTypeTable.GenericParam), CliIndexTypeDefOrRef.readCodedIndex(reader, stream)));
		}
		reader.setPointerIndex(this.readerOffset);
	}

	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "GenericParamConstraint Row", 0);
		rowDt.add(metadataStream.getTableIndexDataType(CliTypeTable.GenericParam), "Owner", "index into GenericParam table");
		rowDt.add(CliIndexTypeDefOrRef.toDataType(metadataStream), "Constraint", "class/interface this param is constrained to derive/implement");
		return rowDt;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableImplMap.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.flags.CliFlags.CliEnumPInvokeAttributes;
import net.jubjubnest.minidump.contrib.pe.cli.tables.indexes.CliIndexMemberForwarded;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;
import ghidra.util.exception.InvalidInputException;

/**
 * Describes the ImplMap table.
 */
public class CliTableImplMap extends CliAbstractTable {
	public class CliImplMapRow extends CliAbstractTableRow {
		public short mappingFlags;
		public int memberForwardedIndex;
		public int importNameIndex;
		public int importScopeIndex;
		
		public CliImplMapRow(short mappingFlags, int memberForwardedIndex, int importNameIndex,
				int importScopeIndex) {
			super();
			this.mappingFlags = mappingFlags;
			this.memberForwardedIndex = memberForwardedIndex;
			this.importNameIndex = importNameIndex;
			this.importScopeIndex = importScopeIndex;
		}

		@Override
		public String getRepresentation() {
			String memberRep;
			try {
				memberRep = getRowRepresentationSafe(CliIndexMemberForwarded.getTableName(memberForwardedIndex), CliIndexMemberForwarded.getRowIndex(memberForwardedIndex));
			}
			catch (InvalidInputException e) {
				memberRep = Integer.toHexString(memberForwardedIndex);
			}
			return String.format(
				"MemberForwarded %s Routine ImportName %s Unmanaged ImportScope %s Flags %s",
				memberRep,
				metadataStream.getStringsStream().getString(importNameIndex),
				getRowRepresentationSafe(CliTypeTable.ModuleRef, importScopeIndex),
				CliEnumPInvokeAttributes.dataType.getName(mappingFlags & 0xffff));
		}
	}
	
	public CliTableImplMap(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			CliImplMapRow row = new CliImplMapRow(reader.readNextShort(), CliIndexMemberForwarded.readCodedIndex(reader, stream),
				readStringIndex(reader), readTableIndex(reader, CliTypeTable.ModuleRef));
			rows.add(row);
			strings.add(row.importNameIndex);
		}
		reader.setPointerIndex(this.readerOffset);
	}

	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "ImplMap Row", 0);
		rowDt.add(CliEnumPInvokeAttributes.dataType, "MappingFlags", "Bitmask of type PInvokeAttributes");
		rowDt.add(CliIndexMemberForwarded.toDataType(metadataStream), "MemberForwarded", "MemberForwarded Coded Index");
		rowDt.add(metadataStream.getStringIndexDataType(), "ImportName", "index into String heap");
		rowDt.add(metadataStream.getTableIndexDataType(CliTypeTable.ModuleRef), "ImportScope", "Index into ModuleRef table");
		return rowDt;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableInterfaceImpl.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.indexes.CliIndexTypeDefOrRef;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;
import ghidra.util.exception.InvalidInputException;

/**
 * Describes the InterfaceImpl table. Each row informs the framework of a class that implements a specific interface.
 */
public class CliTableInterfaceImpl extends CliAbstractTable {
	public class CliInterfaceImplRow extends CliAbstractTableRow {
		public int classIndex;
		public int interfaceIndex;
		
		public CliInterfaceImplRow(int classIndex, int interfaceIndex) {
			super();
			this.classIndex = classIndex;
			this.interfaceIndex = interfaceIndex;
		}

		@Override
		public String getRepresentation() {
			String interfaceRep;
			try {
				interfaceRep = getRowRepresentationSafe(CliIndexTypeDefOrRef.getTableName(interfaceIndex), CliIndexTypeDefOrRef.getRowIndex(interfaceIndex));
			}
			catch (InvalidInputException e) {
				interfaceRep = Integer.toHexString(interfaceIndex);
			}
			return String.format("Class %s implements Interface %s", getRowRepresentationSafe(CliTypeTable.TypeDef, classIndex), interfaceRep);
		}
	}

	public CliTableInterfaceImpl(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			rows.add(new CliInterfaceImplRow(readTableIndex(reader, CliTypeTable.TypeDef), CliIndexTypeDefOrRef.readCodedIndex(reader, stream)));
		}
		reader.setPointerIndex(this.readerOffset);
	}

	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "InterfaceImpl Row",0);
		rowDt.add(metadataStream.getTableIndexDataType(CliTypeTable.TypeDef), "Class", "index into TypeDef table");
		rowDt.add(CliIndexTypeDefOrRef.toDataType(metadataStream), "Interface", "index into TypeDef/TypeRef/TypeSpec - TypeDefOrRef coded");
		return rowDt;
	}
	
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableManifestResource.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.flags.CliFlags.CliEnumManifestResourceAttributes;
import net.jubjubnest.minidump.contrib.pe.cli.tables.indexes.CliIndexImplementation;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;
import ghidra.util.exception.InvalidInputException;

/**
 * Describes the ManifestResources table. Each row is a reference to an external or internal resource.
 */
public class CliTableManifestResource extends CliAbstractTable {	
	public class CliManifestResourceRow extends CliAbstractTableRow {
		public int offset;
		public int flags;
		public int nameIndex;
		public int implIndex;
		
		public CliManifestResourceRow(int offset, int flags, int nameIndex, int implIndex) {
			this.offset = offset;
			this.flags = flags;
			this.nameIndex = nameIndex;
			this.implIndex = implIndex;
		}
		
		@Override
		public String getRepresentation() {
			String implRep;
			try {
				implRep = getRowRepresentationSafe(CliIndexImplementation.getTableName(implIndex), CliIndexImplementation.getRowIndex(implIndex));
			}
			catch (InvalidInputException e) {
				implRep = Integer.toHexString(implIndex);
			}
			return String.format("%s Offset %x Flags %s Implementation %s",
				metadataStream.getStringsStream().getString(nameIndex),
				offset, CliEnumManifestResourceAttributes.dataType.getName(flags & 0xffffffff),
				implRep);
		}
	}
	
	public CliTableManifestResource(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			CliManifestResourceRow row = new CliManifestResourceRow(reader.readNextInt(), reader.readNextInt(), readStringIndex(reader), 
				CliIndexImplementation.readCodedIndex(reader, stream));
			rows.add(row);
			strings.add(row.nameIndex);
		}
		reader.setPointerIndex(this.readerOffset);

	}

	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "ManifestResource Row", 0);
		rowDt.add(DWORD, "Offset", null);
		rowDt.add(CliEnumManifestResourceAttributes.dataType, "Flags", "Bitmask of type ManifestResourceAttributes");
		rowDt.add(metadataStream.getStringIndexDataType(), "Name", "index into String heap");
		rowDt.add(CliIndexImplementation.toDataType(metadataStream), "Implementation", "Implementation coded index");
		return rowDt;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableMemberRef.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.NTHeader;
import net.jubjubnest.minidump.contrib.pe.cli.blobs.*;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliAbstractStream;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.indexes.CliIndexMemberRefParent;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;
import ghidra.program.model.listing.Program;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.exception.InvalidInputException;
import ghidra.util.task.TaskMonitor;

/**
 * Describes the MemberRef/MethodRef table. Each row represents an imported method.
 */
public class CliTableMemberRef extends CliAbstractTable {
	public class CliMemberRefRow extends CliAbstractTableRow {
		public int classIndex;
		public int nameIndex;
		public int signatureIndex;

		public CliMemberRefRow(int classIndex, int nameIndex, int signatureIndex) {
			this.classIndex = classIndex;
			this.nameIndex = nameIndex;
			this.signatureIndex = signatureIndex;
		}

		@Override
		public String getRepresentation() {
			String classRep;
			try {
				classRep =
					getRowRepresentationSafe(CliIndexMemberRefParent.getTableName(classIndex),
						CliIndexMemberRefParent.getRowIndex(classIndex));
			}
			catch (InvalidInputException e) {
				classRep = Integer.toHexString(classIndex);
			}
			String sigRep = Integer.toHexString(signatureIndex);
			CliBlob sigBlob = metadataStream.getBlobStream().getBlob(signatureIndex);
			try {
				if (CliSigField.isFieldSig(sigBlob)) {
					CliSigField fieldSig = new CliSigField(sigBlob);
					sigRep = fieldSig.getRepresentation();
				}
				else {
					CliSigMethodRef methodSig = new CliSigMethodRef(sigBlob);
					sigRep = methodSig.getRepresentation();
				}
			}
			catch (IOException e) {
			}
			return String.format("Class(%s) Member(%s) Signature %s", classRep,
				metadataStream.getStringsStream().getString(nameIndex), sigRep);
		}

		@Override
		public String getRepresentation(CliStreamMetadata stream) {
			String classRep;
			try {
				classRep = getRowShortRepSafe(CliIndexMemberRefParent.getTableName(classIndex),
					CliIndexMemberRefParent.getRowIndex(classIndex));
			}
			catch (InvalidInputException e) {
				classRep = Integer.toHexString(classIndex);
			}
			String sigRep = Integer.toHexString(signatureIndex);
			CliBlob sigBlob = stream.getBlobStream().getBlob(signatureIndex);
			try {
				if (CliSigField.isFieldSig(sigBlob)) {
					CliSigField fieldSig = new CliSigField(sigBlob);
					sigRep = fieldSig.getShortRepresentation(stream);
				}
				else {
					CliSigMethodRef methodSig = new CliSigMethodRef(sigBlob);
					sigRep = methodSig.getRepresentation();
				}
			}
			catch (IOException e) {
			}
			return String.format("%s.%s %s", classRep,
				stream.getStringsStream().getString(nameIndex), sigRep);
		}
	}

	public CliTableMemberRef(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId)
			throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			CliMemberRefRow row =
				new CliMemberRefRow(CliIndexMemberRefParent.readCodedIndex(reader, stream),
					readStringIndex(reader), readBlobIndex(reader));
			rows.add(row);
			strings.add(row.nameIndex);
		}
		reader.setPointerIndex(this.readerOffset);

	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor, MessageLog log,
			NTHeader ntHeader)
			throws DuplicateNameException, CodeUnitInsertionException, IOException {
		for (CliAbstractTableRow row : rows) {
			CliMemberRefRow memberRow = (CliMemberRefRow) row;

			// Get the address and create one of several kinds of *Sig objects
			Address sigAddr = CliAbstractStream.getStreamMarkupAddress(program, isBinary, monitor,
				log, ntHeader, metadataStream.getBlobStream(), memberRow.signatureIndex);

			CliBlob sigBlob = metadataStream.getBlobStream().getBlob(memberRow.signatureIndex);
			if (CliSigField.isFieldSig(sigBlob)) {
				CliSigField fieldSig = new CliSigField(sigBlob);
				metadataStream.getBlobStream().updateBlob(fieldSig, sigAddr, program);
			}
			else {
				CliSigMethodRef methodSig = new CliSigMethodRef(sigBlob);
				metadataStream.getBlobStream().updateBlob(methodSig, sigAddr, program);
			}
		}
	}

	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "MemberRef Row", 0);
		rowDt.add(CliIndexMemberRefParent.toDataType(metadataStream), "Class",
			"index-MemberRefParent coded");
		rowDt.add(metadataStream.getStringIndexDataType(), "Name", "index into String heap");
		rowDt.add(metadataStream.getBlobIndexDataType(), "Signature", "index into Blob heap");
		return rowDt;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableMethodDef.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.MemoryByteProvider;
import net.jubjubnest.minidump.contrib.pe.NTHeader;
import net.jubjubnest.minidump.contrib.pe.PeUtils;
import net.jubjubnest.minidump.contrib.pe.cli.blobs.CliAbstractSig.CliParam;
import net.jubjubnest.minidump.contrib.pe.cli.blobs.CliBlob;
import net.jubjubnest.minidump.contrib.pe.cli.blobs.CliSigMethodDef;
import net.jubjubnest.minidump.contrib.pe.cli.methods.CliMethodDef;
import net.jubjubnest.minidump.contrib.pe.cli.methods.CliMethodExtraSections;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliAbstractStream;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.CliTableParam.CliParamRow;
import net.jubjubnest.minidump.contrib.pe.cli.tables.flags.CliFlags.CliEnumMethodAttributes;
import net.jubjubnest.minidump.contrib.pe.cli.tables.flags.CliFlags.CliEnumMethodImplAttributes;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.database.function.OverlappingFunctionException;
import ghidra.program.model.address.*;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.*;
import ghidra.program.model.listing.Function.FunctionUpdateType;
import ghidra.program.model.symbol.SourceType;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.exception.InvalidInputException;
import ghidra.util.task.TaskMonitor;

/**
 * Describes the MethodDef table. Each row represents a method in a specific class. Each row is stored one after the other grouped by class.
 * References to the MethodDef table are coded to indicate where the methods for a class start and end.
 */
public class CliTableMethodDef extends CliAbstractTable {

	public class CliMethodDefRow extends CliAbstractTableRow {
		public int RVA;
		public short ImplFlags; // MethodImplAttributes
		public short Flags; // MethodAttribute
		public int nameIndex;
		public int sigIndex;
		private int paramIndex;

		private static final int NEXT_ROW_PARAM_INIT_VALUE = -1;
		private int nextRowParamIndex = NEXT_ROW_PARAM_INIT_VALUE;

		public CliMethodDefRow(int rva, short implFlags, short flags, int nameIndex, int sigIndex,
				int paramIndex) {
			this.RVA = rva;
			this.ImplFlags = implFlags;
			this.Flags = flags;
			this.nameIndex = nameIndex;
			this.sigIndex = sigIndex;
			this.paramIndex = paramIndex;
			this.nextRowParamIndex = NEXT_ROW_PARAM_INIT_VALUE;
		}

		@Override
		public String getRepresentation() {
			String methodRep = "error retrieving method representation";
			CliBlob blob = metadataStream.getBlobStream().getBlob(sigIndex);
			try {
				CliSigMethodDef methodSig;
				methodSig = new CliSigMethodDef(blob);
				methodRep = methodSig.getRepresentation();
			}
			catch (IOException e) {
			}

			String paramsStr;
			if (this.nextRowParamIndex == NEXT_ROW_PARAM_INIT_VALUE) {
				this.nextRowParamIndex =
					metadataStream.getTable(CliTypeTable.Param).getNumRows() + 1;
			}
			if (this.nextRowParamIndex == this.paramIndex) {
				paramsStr = "";
			}
			else {
				String params[] = new String[this.nextRowParamIndex - this.paramIndex];
				for (int i = 0; i < params.length; i++) {
					params[i] = getRowRepresentationSafe(CliTypeTable.Param, paramIndex + i);
				}
				paramsStr = commaifyList(Arrays.asList(params));
			}

			return String.format("%s %s Params: %s [RVA %x] Impl: %s Attr: %s",
				metadataStream.getStringsStream().getString(nameIndex), methodRep, paramsStr, RVA,
				CliEnumMethodImplAttributes.dataType.getName(ImplFlags & 0xffff),
				CliEnumMethodAttributes.dataType.getName(Flags & 0xffff));
		}

		@Override
		public String getRepresentation(CliStreamMetadata stream) {
			String methodRep = "error retrieving method representation";
			CliBlob blob = stream.getBlobStream().getBlob(sigIndex);
			try {
				CliSigMethodDef methodSig;
				methodSig = new CliSigMethodDef(blob);
				methodRep = methodSig.getRepresentation(stream);
			}
			catch (IOException e) {
			}

			String paramsStr;
			if (this.nextRowParamIndex == NEXT_ROW_PARAM_INIT_VALUE) {
				this.nextRowParamIndex =
					metadataStream.getTable(CliTypeTable.Param).getNumRows() + 1;
			}
			if (this.nextRowParamIndex == this.paramIndex) {
				paramsStr = "";
			}
			else {
				String params[] = new String[this.nextRowParamIndex - this.paramIndex];
				for (int i = 0; i < params.length; i++) {
					params[i] = getRowShortRepSafe(CliTypeTable.Param, paramIndex + i);
				}
				paramsStr = commaifyList(Arrays.asList(params));
			}

			return String.format("%s %s Params: %s [RVA %x] Impl: %s Attr: %s",
				stream.getStringsStream().getString(nameIndex), methodRep, paramsStr, RVA,
				CliEnumMethodImplAttributes.dataType.getName(ImplFlags & 0xffff),
				CliEnumMethodAttributes.dataType.getName(Flags & 0xffff));
		}
	}

	public CliTableMethodDef(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId)
			throws IOException {
		super(reader, stream, tableId);
		CliMethodDefRow lastRow = null;
		for (int i = 0; i < this.numRows; i++) {
			CliMethodDefRow row = new CliMethodDefRow(reader.readNextInt(), reader.readNextShort(),
				reader.readNextShort(), readStringIndex(reader), readBlobIndex(reader),
				readTableIndex(reader, CliTypeTable.Param));
			rows.add(row);
			strings.add(row.nameIndex);

			if (lastRow != null) {
				lastRow.nextRowParamIndex = row.paramIndex;
			}
			lastRow = row;
		}
		reader.setPointerIndex(this.readerOffset); // TODO: why do this, also elsewhere
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor, MessageLog log,
			NTHeader ntHeader)
			throws DuplicateNameException, CodeUnitInsertionException, IOException {

		int rvaZero = 0;

		for (CliAbstractTableRow method : rows) {
			CliMethodDefRow methodRow = (CliMethodDefRow) method;

			// This indicates the method is abstract, runtime, or PInvokeImpl
			if (methodRow.RVA == 0) {
				rvaZero++;
				continue;
			}

			Address addr = PeUtils.getMarkupAddress(program, isBinary, ntHeader, methodRow.RVA);

			// Create MethodDef at this RVA
			BinaryReader reader =
				new BinaryReader(new MemoryByteProvider(program.getMemory(), addr),
					!program.getMemory().isBigEndian());
			CliMethodDef methodDef = new CliMethodDef(addr, reader);

			PeUtils.createData(program, addr, methodDef.toDataType(), log);

			// Get the function's address space, default to zero-length just in case
			Address startAddr = addr.add(methodDef.toDataType().getLength());
			Address endAddr = startAddr;
			if (methodDef.getMethodSize() > 0) {
				endAddr = startAddr.add(methodDef.getMethodSize() - 1);
			}
			AddressSetView funcAddrSet = new AddressSet(startAddr, endAddr);

			// Let Ghidra assign a default function name and then try to decode the
			// real one if it exists
			String funcName = null;
			if (methodRow.nameIndex > 0) {
				funcName = metadataStream.getStringsStream().getString(methodRow.nameIndex);
			}

			// Do extra data sections in MethodDef
			if (methodDef.hasMoreSections()) {
				int extraSectionOffset =
					methodDef.toDataType().getLength() + methodDef.getMethodSize();

				// Round up to the next offset divisible by 4
				extraSectionOffset = ((extraSectionOffset + 3) / 4) * 4;

				reader.setPointerIndex(extraSectionOffset);
				CliMethodExtraSections extraSections = new CliMethodExtraSections(reader);
				Address extraSectionAddr = addr.add(extraSectionOffset);
				PeUtils.createData(program, extraSectionAddr, extraSections.toDataType(), log);
			}

			// Get the function signature blob
			CliBlob blob = metadataStream.getBlobStream().getBlob(methodRow.sigIndex);
			Address sigAddr = CliAbstractStream.getStreamMarkupAddress(program, isBinary, monitor,
				log, ntHeader, metadataStream.getBlobStream(), methodRow.sigIndex);

			// Get the return type from the function signature
			CliSigMethodDef methodSig = new CliSigMethodDef(blob);
			metadataStream.getBlobStream().updateBlob(methodSig, sigAddr, program);
			DataType returnType = methodSig.getReturnType().getExecutionDataType();

			// Pull apart the function parameter names and types
			int stackOffset = 0;
			CliParam paramTypes[] = methodSig.getParamTypes();
			CliTableParam paramTable = (CliTableParam) metadataStream.getTable(CliTypeTable.Param);
			ParameterImpl parameters[] = new ParameterImpl[paramTypes.length];

			for (int i = 0; i < paramTypes.length; i++) {
				CliParamRow paramRow = (CliParamRow) paramTable.getRow(methodRow.paramIndex + i);

				String paramName = metadataStream.getStringsStream().getString(paramRow.nameIndex);
				DataType dataType = paramTypes[i].getExecutionDataType();

				try {
					parameters[i] = new ParameterImpl(paramName, dataType, stackOffset, program);
				}
				catch (InvalidInputException e) {
					Msg.warn(this, "Error processing parameter \"" + paramName +
						"\" in function \"" + funcName + "\"");
				}

				stackOffset += dataType.getLength();
			}

			try {
				Function newFunc = program.getFunctionManager()
						.createFunction(funcName, startAddr, funcAddrSet, SourceType.ANALYSIS);
				newFunc.setReturnType(returnType, SourceType.ANALYSIS);
				newFunc.updateFunction(null, null, FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS,
					true, SourceType.ANALYSIS, parameters);
			}
			catch (InvalidInputException e) {
				Msg.warn(this, "Error processing function \"" + funcName + "\"");
			}
			catch (OverlappingFunctionException e) {
				Msg.warn(this, "Error processing function \"" + funcName + "\"");
			}
		}
		if (rvaZero > 0) {
			Msg.warn(this, rvaZero + " methods with RVA 0");
		}
	}

	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "MethodDef Row", 0);
		rowDt.add(DWORD, "RVA", null);
		rowDt.add(CliEnumMethodImplAttributes.dataType, "ImplFlags",
			"Bitmask of type MethodImplAttributes");
		rowDt.add(CliEnumMethodAttributes.dataType, "Flags", "Bitmask of type MethodAttribute");
		rowDt.add(metadataStream.getStringIndexDataType(), "Name", "index into String heap");
		rowDt.add(metadataStream.getBlobIndexDataType(), "Signature", "index into Blob heap");
		rowDt.add(metadataStream.getTableIndexDataType(CliTypeTable.Param), "ParamList",
			"index into Param table");
		return rowDt;
	}

	private String commaifyList(List<?> list) {
		String commaSeparated = "";
		for (Object item : list) {
			commaSeparated += item + ", ";
		}
		if (list.size() > 0) {
			commaSeparated = commaSeparated.substring(0, commaSeparated.length() - 2);
		}
		return commaSeparated;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableMethodImpl.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.indexes.CliIndexMethodDefOrRef;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;
import ghidra.util.exception.InvalidInputException;

/**
 * Describes the MethodImpl table.
 */
public class CliTableMethodImpl extends CliAbstractTable {
	public class CliMethodImplRow extends CliAbstractTableRow {
		public int classIndex;
		public int methodBodyIndex;
		public int methodDeclarationIndex;
		
		public CliMethodImplRow(int classIndex, int methodBodyIndex, int methodDeclarationIndex) {
			super();
			this.classIndex = classIndex;
			this.methodBodyIndex = methodBodyIndex;
			this.methodDeclarationIndex = methodDeclarationIndex;
		}

		@Override
		public String getRepresentation() {
			String methodBodyRep;
			try {
				methodBodyRep = getRowRepresentationSafe(CliIndexMethodDefOrRef.getTableName(methodBodyIndex), CliIndexMethodDefOrRef.getRowIndex(methodBodyIndex));
			}
			catch (InvalidInputException e) {
				methodBodyRep = Integer.toHexString(methodBodyIndex);
			}
			String methodDeclarationRep;
			try {
				methodDeclarationRep = getRowRepresentationSafe(CliIndexMethodDefOrRef.getTableName(methodDeclarationIndex), CliIndexMethodDefOrRef.getRowIndex(methodDeclarationIndex));
			}
			catch (InvalidInputException e) {
				methodDeclarationRep = Integer.toHexString(methodDeclarationIndex);
			}
			return String.format("Class %s MethodBody %s MethodDeclaration %s", getRowRepresentationSafe(CliTypeTable.TypeDef, classIndex), methodBodyRep, methodDeclarationRep);
		}
	}
	
	public CliTableMethodImpl(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			rows.add(new CliMethodImplRow(readTableIndex(reader, CliTypeTable.TypeDef), CliIndexMethodDefOrRef.readCodedIndex(reader, stream), CliIndexMethodDefOrRef.readCodedIndex(reader, stream)));
		}
		reader.setPointerIndex(this.readerOffset);
	}
	
	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "MethodImpl Row", 0);
		rowDt.add(metadataStream.getTableIndexDataType(CliTypeTable.TypeDef), "Class", "index into TypeDef");
		rowDt.add(CliIndexMethodDefOrRef.toDataType(metadataStream), "MethodBody", "MethodDefOrRef coded index");
		rowDt.add(CliIndexMethodDefOrRef.toDataType(metadataStream), "MethodDeclaration", "MethodDefOrRef coded index");
		return rowDt;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableMethodSemantics.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.flags.CliFlags.CliEnumMethodSemanticsAttributes;
import net.jubjubnest.minidump.contrib.pe.cli.tables.indexes.CliIndexHasSemantics;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;
import ghidra.util.exception.InvalidInputException;

/**
 * Describes the MethodSemantics table. Each row is a link between a property or event and a specific method.
 * Events are routinely associated with more than one method, and properties use this for get/set methods.
 */
public class CliTableMethodSemantics extends CliAbstractTable {
	public class CliMethodSemanticsRow extends CliAbstractTableRow {
		public short semantics;
		public int methodIndex;
		public int associationIndex;
		
		public CliMethodSemanticsRow(short semantics, int methodIndex, int associationIndex) {
			super();
			this.semantics = semantics;
			this.methodIndex = methodIndex;
			this.associationIndex = associationIndex;
		}

		@Override
		public String getRepresentation() {
			String assocRep;
			try {
				assocRep = getRowRepresentationSafe(CliIndexHasSemantics.getTableName(associationIndex), CliIndexHasSemantics.getRowIndex(associationIndex));
			}
			catch (InvalidInputException e) {
				assocRep = Integer.toHexString(associationIndex);
			}
			return String.format("Method %s Association %s Semantics %s", getRowRepresentationSafe(CliTypeTable.MethodDef, methodIndex), assocRep, 
				CliEnumMethodSemanticsAttributes.dataType.getName(semantics & 0xffff));
		}
	}
	
	public CliTableMethodSemantics(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			rows.add(new CliMethodSemanticsRow(reader.readNextShort(), readTableIndex(reader, CliTypeTable.MethodDef), CliIndexHasSemantics.readCodedIndex(reader, stream)));
		}
		reader.setPointerIndex(this.readerOffset);
	}

	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "MethodSemantics Row", 0);
		rowDt.add(CliEnumMethodSemanticsAttributes.dataType, "Semantics", "Bitmask of type MethodSemanticsAttributes");
		rowDt.add(metadataStream.getTableIndexDataType(CliTypeTable.MethodDef), "Method", "index into MethodDef table");
		rowDt.add(CliIndexHasSemantics.toDataType(metadataStream), "Association", "HasSemantics coded index into Event or Property");
		return rowDt;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableMethodSpec.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.NTHeader;
import net.jubjubnest.minidump.contrib.pe.cli.blobs.CliBlob;
import net.jubjubnest.minidump.contrib.pe.cli.blobs.CliSigMethodSpec;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliAbstractStream;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.indexes.CliIndexMethodDefOrRef;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;
import ghidra.program.model.listing.Program;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.exception.InvalidInputException;
import ghidra.util.task.TaskMonitor;

/**
 * Describes the MethodSpec table. Each row is a unique instantiation of a generic method.
 */
public class CliTableMethodSpec extends CliAbstractTable {
	public class CliMethodSpecRow extends CliAbstractTableRow {
		public int methodIndex;
		public int instantiationIndex;

		public CliMethodSpecRow(int methodIndex, int instantiationIndex) {
			super();
			this.methodIndex = methodIndex;
			this.instantiationIndex = instantiationIndex;
		}

		@Override
		public String getRepresentation() {
			String methodRep;
			try {
				methodRep =
					getRowRepresentationSafe(CliIndexMethodDefOrRef.getTableName(methodIndex),
						CliIndexMethodDefOrRef.getRowIndex(methodIndex));
			}
			catch (InvalidInputException e) {
				methodRep = Integer.toHexString(methodIndex);
			}
			String instantiationRep = Integer.toHexString(instantiationIndex);
			CliBlob blob = metadataStream.getBlobStream().getBlob(instantiationIndex);
			try {
				CliSigMethodSpec sig = new CliSigMethodSpec(blob);
				instantiationRep = sig.getRepresentation();
			}
			catch (Exception e) {
			}
			return String.format("Method %s Instantiation %s", methodRep, instantiationRep);
		}
	}

	public CliTableMethodSpec(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId)
			throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			CliMethodSpecRow row = new CliMethodSpecRow(
				CliIndexMethodDefOrRef.readCodedIndex(reader, stream), readBlobIndex(reader));
			rows.add(row);
		}
		reader.setPointerIndex(this.readerOffset);
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor, MessageLog log,
			NTHeader ntHeader)
			throws DuplicateNameException, CodeUnitInsertionException, IOException {
		for (CliAbstractTableRow row : rows) {
			CliMethodSpecRow methodRow = (CliMethodSpecRow) row;
			CliBlob blob = metadataStream.getBlobStream().getBlob(methodRow.instantiationIndex);

			// Create the MethodSpecSig
			Address sigAddr = CliAbstractStream.getStreamMarkupAddress(program, isBinary, monitor,
				log, ntHeader, metadataStream.getBlobStream(), methodRow.instantiationIndex);

			CliSigMethodSpec methodSig = new CliSigMethodSpec(blob);
			metadataStream.getBlobStream().updateBlob(methodSig, sigAddr, program);
		}
	}

	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt =
			new StructureDataType(new CategoryPath(PATH), "MethodSpec Row", 0);
		rowDt.add(CliIndexMethodDefOrRef.toDataType(metadataStream), "Method",
			"MethodDefOrRef coded index");
		rowDt.add(metadataStream.getBlobIndexDataType(), "Instantiation",
			"index into Blob heap, signature of this instantiation");
		return rowDt;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableModule.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import ghidra.program.model.data.*;

/**
 * Describes the Module Table, which contains information about the current assembly.
 */
public class CliTableModule extends CliAbstractTable {
	public class CliModuleRow extends CliAbstractTableRow {
		public short generation;
		public int nameIndex;
		public int mvIdIndex;
		public int encIdIndex;
		public int encBaseIdIndex;
		
		public CliModuleRow(short generation, int nameIndex, int mvIdIndex, int encIdIndex,
				int encBaseIdIndex) {
			super();
			this.generation = generation;
			this.nameIndex = nameIndex;
			this.mvIdIndex = mvIdIndex;
			this.encIdIndex = encIdIndex;
			this.encBaseIdIndex = encBaseIdIndex;
		}

		@Override
		public String getRepresentation() {
			return String.format("%s MvID %s EncID %s EncBaseID %s",
				metadataStream.getGuidStream().getGuid(nameIndex),
				metadataStream.getGuidStream().getGuid(mvIdIndex),
				metadataStream.getGuidStream().getGuid(encIdIndex),
				metadataStream.getGuidStream().getGuid(encBaseIdIndex));
		}
		
		@Override
		public String getShortRepresentation() {
			return String.format("%s", metadataStream.getStringsStream().getString(nameIndex));
		}
	}
	
	public CliTableModule(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			CliModuleRow row = new CliModuleRow(reader.readNextShort(), readStringIndex(reader), readBlobIndex(reader), readBlobIndex(reader), readBlobIndex(reader));
			rows.add(row);
			strings.add(row.nameIndex);
		}
		reader.setPointerIndex(this.readerOffset);
	}

	@Override
	public StructureDataType getRowDataType() {
		StructureDataType struct = new StructureDataType(new CategoryPath(PATH), "Module Row", 0);
		struct.add( WORD, "Generation", "reserved, shall be 0");
		struct.add(metadataStream.getStringIndexDataType(), "Name", "index into String heap");
		struct.add(metadataStream.getGuidIndexDataType(), "MvId", "used to distinguish between versions of same module");
		struct.add(metadataStream.getGuidIndexDataType(), "EncId", "reserved, shall be 0");
		struct.add(metadataStream.getGuidIndexDataType(), "EncBaseId", "reserved, shall be 0");
		return struct;
	}
	
	@Override
	public DataType toDataType() {
		DataType rowDt = getRowDataType();
		return rowDt;
	}

	@Override
	public int getNumRows() {
		return 1;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableModuleRef.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;

/**
 * Describes the ModuleRef table. Each row is a reference to an external module.
 */
public class CliTableModuleRef extends CliAbstractTable {
	public class CliModuleRefRow extends CliAbstractTableRow {
		public int nameIndex;
		
		public CliModuleRefRow(int nameIndex) {
			this.nameIndex = nameIndex;
		}
		
		@Override
		public String getRepresentation() {
			return String.format("ModuleRef %s", metadataStream.getStringsStream().getString(nameIndex));
		}
	}
	
	public CliTableModuleRef(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			CliModuleRefRow row = new CliModuleRefRow(readStringIndex(reader));
			rows.add(row);
			strings.add(row.nameIndex);
		}
		reader.setPointerIndex(this.readerOffset);
	}
	
	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "ModuleRef Row", 0);
		rowDt.add(metadataStream.getStringIndexDataType(), "Name", "index into String heap");
		return rowDt;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableNestedClass.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;

/**
 * Describes the NestedClass table. Each row is a nested class.
 */
public class CliTableNestedClass extends CliAbstractTable {
	public class CliNestedClassRow extends CliAbstractTableRow {
		public int nestedClassIndex;
		public int enclosingClassIndex;
		
		public CliNestedClassRow(int nestedClassIndex, int enclosingClassIndex) {
			super();
			this.nestedClassIndex = nestedClassIndex;
			this.enclosingClassIndex = enclosingClassIndex;
		}

		@Override
		public String getRepresentation() {
			return String.format("%s is nested in %s", getRowRepresentationSafe(CliTypeTable.TypeDef, nestedClassIndex), getRowRepresentationSafe(CliTypeTable.TypeDef, enclosingClassIndex));
		}
	}
	
	public CliTableNestedClass(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			rows.add(new CliNestedClassRow(readTableIndex(reader, CliTypeTable.TypeDef), readTableIndex(reader, CliTypeTable.TypeDef)));
		}
		reader.setPointerIndex(this.readerOffset);
	}

	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "NestedClass Row", 0);
		rowDt.add(metadataStream.getTableIndexDataType(CliTypeTable.TypeDef), "NestedClass", "TypeDef index");
		rowDt.add(metadataStream.getTableIndexDataType(CliTypeTable.TypeDef), "EnclosingClass", "TypeDef index");
		return rowDt;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableParam.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.flags.CliFlags.CliEnumParamAttributes;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;

/**
 * Describes the Param table. Each row represents a method's parameter.
 */
public class CliTableParam extends CliAbstractTable {
	public class CliParamRow extends CliAbstractTableRow {
		public short flags;
		public short sequence;
		public int nameIndex;
		
		public CliParamRow(short flags, short sequence, int nameIndex) {
			super();
			this.flags = flags;
			this.sequence = sequence;
			this.nameIndex = nameIndex;
		}

		@Override
		public String getRepresentation() {
			return String.format("%s Flags %s Sequence %x",
				metadataStream.getStringsStream().getString(nameIndex),
				CliEnumParamAttributes.dataType.getName(flags & 0xffff), sequence);
		}
	}
	
	public CliTableParam(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			CliParamRow row = new CliParamRow(reader.readNextShort(), reader.readNextShort(), readStringIndex(reader));
			rows.add(row);
			strings.add(row.nameIndex);
		}
		reader.setPointerIndex(this.readerOffset);
	}

	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "ParamRow",0);
		rowDt.add(CliEnumParamAttributes.dataType, "Flags", "bitmask of type ParamAttributes");
		rowDt.add( WORD, "Sequence", "constant");
		rowDt.add(metadataStream.getStringIndexDataType(), "Name", "index into String heap");
		return rowDt;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableProperty.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.NTHeader;
import net.jubjubnest.minidump.contrib.pe.cli.blobs.CliBlob;
import net.jubjubnest.minidump.contrib.pe.cli.blobs.CliSigProperty;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliAbstractStream;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.flags.CliFlags.CliEnumPropertyAttributes;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;
import ghidra.program.model.listing.Program;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;

/**
 * Describes the Property table. Each row describes a property. Indices into this table point to contiguous runs of properties
 * ending with the next index from the PropertyMap table or with the end of this table.
 */
public class CliTableProperty extends CliAbstractTable {
	private class CliPropertyRow extends CliAbstractTableRow {
		public short flags;
		public int nameIndex;
		public int sigIndex;

		public CliPropertyRow(short flags, int nameIndex, int sigIndex) {
			this.flags = flags;
			this.nameIndex = nameIndex;
			this.sigIndex = sigIndex;
		}

		@Override
		public String getRepresentation() {
			String sigRep = Integer.toHexString(sigIndex);
			CliBlob blob = metadataStream.getBlobStream().getBlob(sigIndex);
			try {
				CliSigProperty propertySig;
				propertySig = new CliSigProperty(blob);
				sigRep = propertySig.getShortRepresentation(metadataStream);
			}
			catch (IOException e) {
			}
			return String.format("Property %s Signature %s Flags %s",
				metadataStream.getStringsStream().getString(nameIndex), sigRep,
				CliEnumPropertyAttributes.dataType.getName(flags & 0xffff));
		}
	}

	public CliTableProperty(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId)
			throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			CliPropertyRow row = new CliPropertyRow(reader.readNextShort(), readStringIndex(reader),
				readBlobIndex(reader));
			rows.add(row);
			strings.add(row.nameIndex);
		}
		reader.setPointerIndex(this.readerOffset);
	}

	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "Property Row", 0);
		rowDt.add(CliEnumPropertyAttributes.dataType, "Flags",
			"Bitmask of type PropertyAttributes");
		rowDt.add(metadataStream.getStringIndexDataType(), "Name", null);
		rowDt.add(metadataStream.getBlobIndexDataType(), "Type",
			"Blob index to the signature, not a TypeDef/TypeRef");
		return rowDt;
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor, MessageLog log,
			NTHeader ntHeader)
			throws DuplicateNameException, CodeUnitInsertionException, IOException {
		for (CliAbstractTableRow row : rows) {
			CliPropertyRow property = (CliPropertyRow) row;
			CliBlob blob = metadataStream.getBlobStream().getBlob(property.sigIndex);
			Address addr = CliAbstractStream.getStreamMarkupAddress(program, isBinary, monitor, log,
				ntHeader, metadataStream.getBlobStream(), property.sigIndex);

			// Create PropertySig object
			CliSigProperty propSig = new CliSigProperty(blob);
			metadataStream.getBlobStream().updateBlob(propSig, addr, program);
		}
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTablePropertyMap.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;

/**
 * Describes the PropertyMap class. Each row points to a list of properties in the Property table owned by a class.
 */
public class CliTablePropertyMap extends CliAbstractTable {
	public class CliPropertyMapRow extends CliAbstractTableRow {
		public int parentIndex;
		public int propertyListIndex;
		
		public CliPropertyMapRow(int parentIndex, int propertyListIndex) {
			super();
			this.parentIndex = parentIndex;
			this.propertyListIndex = propertyListIndex;
		}

		@Override
		public String getRepresentation() {
			// TODO: plist index points to contiguous run of properties
			return String.format("Parent %s Properties %x", getRowRepresentationSafe(CliTypeTable.TypeDef, parentIndex), propertyListIndex);
		}
	}
	
	public CliTablePropertyMap(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			rows.add(new CliPropertyMapRow(readTableIndex(reader, CliTypeTable.TypeDef), readTableIndex(reader, CliTypeTable.Property)));
		}
		reader.setPointerIndex(this.readerOffset);
	}
	
	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "PropertyMap Row", 0);
		rowDt.add(metadataStream.getTableIndexDataType(CliTypeTable.TypeDef), "Parent", null);
		rowDt.add(metadataStream.getTableIndexDataType(CliTypeTable.Property), "options", "Index into Property table. Points to contiguous run of Properties until next ref from PropertyMap or end of table.");
		return rowDt;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableStandAloneSig.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.NTHeader;
import net.jubjubnest.minidump.contrib.pe.cli.blobs.*;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliAbstractStream;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;
import ghidra.program.model.listing.Program;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;

/**
 * Describes the StandAloneSig table. Each row represents a signature that isn't referenced by any other Table.
 */
public class CliTableStandAloneSig extends CliAbstractTable {
	public class CliStandAloneSigRow extends CliAbstractTableRow {
		public int signatureIndex;

		public CliStandAloneSigRow(int signatureIndex) {
			this.signatureIndex = signatureIndex;
		}

		@Override
		public String getRepresentation() {
			String sigRep = Integer.toHexString(signatureIndex);
			CliBlob sigBlob = metadataStream.getBlobStream().getBlob(signatureIndex);
			try {
				CliAbstractSig sig;
				if (CliSigLocalVar.isLocalVarSig(sigBlob)) {
					sig = new CliSigLocalVar(sigBlob);
				}
				else if (CliSigField.isFieldSig(sigBlob)) {
					// UNDOCUMENTED FEATURE ALERT! Contrary to ISO standards Microsoft compilers
					// will sometimes put FieldSig references in this table.
					sig = new CliSigField(sigBlob);
				}
				else {
					sig = new CliSigStandAloneMethod(sigBlob);
				}
				sigRep = sig.getRepresentation();
			}
			catch (Exception e) {
			}
			return String.format("%s", sigRep);
		}
	}

	public CliTableStandAloneSig(BinaryReader reader, CliStreamMetadata stream,
			CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			rows.add(new CliStandAloneSigRow(readBlobIndex(reader)));
		}
		reader.setPointerIndex(this.readerOffset);
	}

	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt =
			new StructureDataType(new CategoryPath(PATH), "StandAloneSig Row", 0);
		rowDt.add(metadataStream.getBlobIndexDataType(), "Signature", null);
		return rowDt;
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor, MessageLog log,
			NTHeader ntHeader)
			throws DuplicateNameException, CodeUnitInsertionException, IOException {
		for (CliAbstractTableRow row : rows) {
			Integer sigIndex = ((CliStandAloneSigRow) row).signatureIndex;
			CliBlob blob =
				metadataStream.getBlobStream().getBlob(((CliStandAloneSigRow) row).signatureIndex);
			Address sigAddr = CliAbstractStream.getStreamMarkupAddress(program, isBinary, monitor,
				log, ntHeader, metadataStream.getBlobStream(), sigIndex);

			// Create one of several *Sig objects
			if (CliSigLocalVar.isLocalVarSig(blob)) {
				CliSigLocalVar localSig = new CliSigLocalVar(blob);
				metadataStream.getBlobStream().updateBlob(localSig, sigAddr, program);
			}
			else if (CliSigField.isFieldSig(blob)) {
				// UNDOCUMENTED FEATURE ALERT! Contrary to ISO standards Microsoft compilers
				// will sometimes put FieldSig references in this table.
				CliSigField fieldSig = new CliSigField(blob);
				metadataStream.getBlobStream().updateBlob(fieldSig, sigAddr, program);
			}
			else {
				CliSigStandAloneMethod standAloneSig = new CliSigStandAloneMethod(blob);
				metadataStream.getBlobStream().updateBlob(standAloneSig, sigAddr, program);
			}
		}
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableTypeDef.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.flags.CliFlags.CliEnumTypeAttributes;
import net.jubjubnest.minidump.contrib.pe.cli.tables.indexes.CliIndexTypeDefOrRef;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;
import ghidra.util.exception.InvalidInputException;

/**
 * Describes the TypeDef table. Each row represents a class in the current assembly.
 */
public class CliTableTypeDef extends CliAbstractTable {
	public class CliTypeDefRow extends CliAbstractTableRow {
		public int flags;
		public int typeNameIndex;
		public int typeNamespaceIndex;
		public int extendsIndex;
		public int fieldListIndex;
		public int methodListIndex;
		
		public CliTypeDefRow(int flags, int typeNameIndex, int typeNamespaceIndex,
				int extendsIndex, int fieldListIndex, int methodListIndex) {
			super();
			this.flags = flags;
			this.typeNameIndex = typeNameIndex;
			this.typeNamespaceIndex = typeNamespaceIndex;
			this.extendsIndex = extendsIndex;
			this.fieldListIndex = fieldListIndex;
			this.methodListIndex = methodListIndex;
		}

		@Override
		public String getShortRepresentation() {
			return String.format("%s.%s",
				metadataStream.getStringsStream().getString(typeNamespaceIndex),
				metadataStream.getStringsStream().getString(typeNameIndex));
		}
		
		@Override
		public String getRepresentation() {
			String extendsRep;
			if (extendsIndex == 0) {
				extendsRep = "Nothing";
			}
			else {
				try {
					extendsRep = getRowRepresentationSafe(CliIndexTypeDefOrRef.getTableName(extendsIndex), CliIndexTypeDefOrRef.getRowIndex(extendsIndex));
				}
				catch (InvalidInputException e) {
					extendsRep = Integer.toHexString(extendsIndex);
				}
			}
			// TODO: FieldList and MethodList point to contiguous runs of fields and methods, not just singles
			return String.format("Type %s Namespace %s Extends %s Fields %s MethodList %s Flags %s",
				metadataStream.getStringsStream().getString(typeNameIndex),
				metadataStream.getStringsStream().getString(typeNamespaceIndex),
				extendsRep, getRowRepresentationSafe(CliTypeTable.Field, fieldListIndex),
				getRowRepresentationSafe(CliTypeTable.MethodDef, methodListIndex), CliEnumTypeAttributes.dataType.getName(flags & 0xffffffff));
		}
	}
	
	public CliTableTypeDef(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			CliTypeDefRow row = new CliTypeDefRow(reader.readNextInt(), readStringIndex(reader), readStringIndex(reader), CliIndexTypeDefOrRef.readCodedIndex(reader, stream),
				readTableIndex(reader, CliTypeTable.Field), readTableIndex(reader, CliTypeTable.MethodDef));
			rows.add(row);
			strings.add(row.typeNameIndex);
			strings.add(row.typeNamespaceIndex);
		}
		reader.setPointerIndex(this.readerOffset);
	}
	
	public int getOwnerOfFieldIndex(int fieldIndex) {
		for (int i = 0; i < this.numRows; i++) {
			CliTypeDefRow row = (CliTypeDefRow) rows.get(i);
			if (i == this.numRows - 1) {
				if (fieldIndex >= row.fieldListIndex)
					return i + 1;
				return -1;
			}
			CliTypeDefRow nextRow = (CliTypeDefRow) rows.get(i+1);
			if (fieldIndex >= row.fieldListIndex && fieldIndex < nextRow.fieldListIndex)
				return i + 1;
		}
		return -1;
	}
	
	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "TypeDef Row", 0);
		rowDt.add(CliEnumTypeAttributes.dataType, "Flags", "see CorTypeAttr");
		rowDt.add(metadataStream.getStringIndexDataType(), "TypeName", "index into String heap");
		rowDt.add(metadataStream.getStringIndexDataType(), "TypeNamespace", "index into String heap");
		rowDt.add(CliIndexTypeDefOrRef.toDataType(metadataStream), "Extends", "index: coded TypeDefOrRef");
		rowDt.add(metadataStream.getTableIndexDataType(CliTypeTable.Field), "FieldList", "index into Field table");
		rowDt.add(metadataStream.getTableIndexDataType(CliTypeTable.MethodDef), "MethodList", "index into MethodDef table");
		return rowDt;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableTypeRef.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.indexes.CliIndexResolutionScope;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;
import ghidra.util.exception.InvalidInputException;

/**
 * Describes the TypeRef table. Each row represents an imported class, its namespace, and the assembly which contains it.
 */
public class CliTableTypeRef extends CliAbstractTable {
	public class CliTypeRefRow extends CliAbstractTableRow {
		public int resolutionScopeIndex;
		public int typeNameIndex;
		public int typeNamespaceIndex;
		
		public CliTypeRefRow(int resolutionScopeIndex, int typeNameIndex, int typeNamespaceIndex) {
			super();
			this.resolutionScopeIndex = resolutionScopeIndex;
			this.typeNameIndex = typeNameIndex;
			this.typeNamespaceIndex = typeNamespaceIndex;
		}

		@Override
		public String getRepresentation() {
			String scopeRep;
			try {
				scopeRep = getRowShortRepSafe(CliIndexResolutionScope.getTableName(resolutionScopeIndex), CliIndexResolutionScope.getRowIndex(resolutionScopeIndex));
			}
			catch (InvalidInputException e) {
				scopeRep = Integer.toHexString(resolutionScopeIndex);
			}
			return String.format("%s.%s (ResolutionScope %s)",
				metadataStream.getStringsStream().getString(typeNameIndex),
				metadataStream.getStringsStream().getString(typeNamespaceIndex),
				scopeRep);
		}
		
		@Override
		public String getShortRepresentation() {
			return String.format("%s.%s",
				metadataStream.getStringsStream().getString(typeNamespaceIndex),
				metadataStream.getStringsStream().getString(typeNameIndex));
		}
		
	}
	
	public CliTableTypeRef(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId) throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			CliTypeRefRow row = new CliTypeRefRow(CliIndexResolutionScope.readCodedIndex(reader, stream), readStringIndex(reader), readStringIndex(reader));
			rows.add(row);
			strings.add(row.typeNameIndex);
			strings.add(row.typeNamespaceIndex);
		}
		reader.setPointerIndex(this.readerOffset);
	}
	
	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "TypeRef Row", 0);
		rowDt.add(CliIndexResolutionScope.toDataType(metadataStream), "ResolutionScope", null);
		rowDt.add(metadataStream.getStringIndexDataType(), "TypeName", null);
		rowDt.add(metadataStream.getStringIndexDataType(), "TypeNamespace", null);
		return rowDt;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTableTypeSpec.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.NTHeader;
import net.jubjubnest.minidump.contrib.pe.cli.blobs.CliBlob;
import net.jubjubnest.minidump.contrib.pe.cli.blobs.CliSigTypeSpec;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliAbstractStream;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import ghidra.app.util.importer.MessageLog;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.StructureDataType;
import ghidra.program.model.listing.Program;
import ghidra.program.model.util.CodeUnitInsertionException;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.task.TaskMonitor;

/**
 * Describes the TypeSpec table. Each row represents a specification for a TypeDef or TypeRef which is contained in the Blob stream.
 */
public class CliTableTypeSpec extends CliAbstractTable {
	public class CliTypeSpecRow extends CliAbstractTableRow {
		public int signatureIndex;

		public CliTypeSpecRow(int signatureIndex) {
			super();
			this.signatureIndex = signatureIndex;
		}

		@Override
		public String getRepresentation() {
			String sigRep = Integer.toHexString(signatureIndex);
			CliBlob blob = metadataStream.getBlobStream().getBlob(signatureIndex);
			try {
				CliSigTypeSpec sig = new CliSigTypeSpec(blob);
				sigRep = sig.getRepresentation();
			}
			catch (Exception e) {
			}
			return String.format("%s", sigRep);
		}

		@Override
		public String getRepresentation(CliStreamMetadata stream) {
			String sigRep = Integer.toHexString(signatureIndex);
			CliBlob blob = stream.getBlobStream().getBlob(signatureIndex);
			try {
				CliSigTypeSpec sig = new CliSigTypeSpec(blob);
				sigRep = sig.getRepresentation(stream);
			}
			catch (Exception e) {
			}
			return String.format("%s", sigRep);
		}
	}

	public CliTableTypeSpec(BinaryReader reader, CliStreamMetadata stream, CliTypeTable tableId)
			throws IOException {
		super(reader, stream, tableId);
		for (int i = 0; i < this.numRows; i++) {
			CliTypeSpecRow row = new CliTypeSpecRow(readBlobIndex(reader));
			rows.add(row);
		}
		reader.setPointerIndex(this.readerOffset);
	}

	@Override
	public void markup(Program program, boolean isBinary, TaskMonitor monitor, MessageLog log,
			NTHeader ntHeader)
			throws DuplicateNameException, CodeUnitInsertionException, IOException {
		for (CliAbstractTableRow row : rows) {
			CliTypeSpecRow typeRow = (CliTypeSpecRow) row;
			CliBlob blob = metadataStream.getBlobStream().getBlob(typeRow.signatureIndex);

			// Get the address of the signature, create the TypeSpec object
			Address sigAddr = CliAbstractStream.getStreamMarkupAddress(program, isBinary, monitor,
				log, ntHeader, metadataStream.getBlobStream(), typeRow.signatureIndex);

			CliSigTypeSpec typeSig = new CliSigTypeSpec(blob);
			metadataStream.getBlobStream().updateBlob(typeSig, sigAddr, program);
		}
	}

	@Override
	public StructureDataType getRowDataType() {
		StructureDataType rowDt = new StructureDataType(new CategoryPath(PATH), "TypeSpec Row", 0);
		rowDt.add(metadataStream.getBlobIndexDataType(), "Signature", "index into Blob heap");
		return rowDt;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/CliTypeTable.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables;

/**
 * Possible Metadata table types.
 */
public enum CliTypeTable {
	Module(0x00),
	TypeRef(0x01),
	TypeDef(0x02),
	Field(0x04),
	MethodDef(0x06),
	Param(0x08),
	InterfaceImpl(0x09),
	MemberRef(0x0a),
	Constant(0x0b),
	CustomAttribute(0x0c),
	FieldMarshal(0x0d),
	DeclSecurity(0x0e),
	ClassLayout(0x0f),
	FieldLayout(0x10),
	StandAloneSig(0x11),
	EventMap(0x12),
	Event(0x14),
	PropertyMap(0x15),
	Property(0x17),
	MethodSemantics(0x18),
	MethodImpl(0x19),
	ModuleRef(0x1a),
	TypeSpec(0x1b),
	ImplMap(0x1c),
	FieldRVA(0x1d),
	Assembly(0x20),
	AssemblyProcessor(0x21),
	AssemblyOS(0x22),
	AssemblyRef(0x23),
	AssemblyRefProcessor(0x24),
	AssemblyRefOS(0x25),
	File(0x26),
	ExportedType(0x27),
	ManifestResource(0x28),
	NestedClass(0x29),
	GenericParam(0x2a),
	MethodSpec(0x2b),
	GenericParamConstraint(0x2c);

	private final int id;

	/**
	 * Creates a new table type from the given ID.
	 * 
	 * @param id The ID of the table type to create.
	 */
	private CliTypeTable(int id) {
		this.id = id;
	}

	/**
	 * Gets the ID associated with this table type.
	 * 
	 * @return The ID associated with this table type.
	 */
	public int id() {
		return id;
	}

	/**
	 * Gets a table type from the given ID.
	 * 
	 * @param id The ID of the table type to get.
	 * @return A table type with the given ID, or null if one doesn't exist.
	 */
	public static CliTypeTable fromId(int id) {
		CliTypeTable[] values = CliTypeTable.values();
		for (CliTypeTable value : values) {
			if (value.id == id)
				return value;
		}
		return null;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/flags/CliFlags.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables.flags;

import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.EnumDataType;

public class CliFlags {
	public static final String PATH = "/PE/CLI/Flags";
	
	public static class CliEnumAssemblyFlags extends EnumDataType {
		private static final long serialVersionUID = 1L;
		
		/** A statically defined instance.*/
	    public final static CliEnumAssemblyFlags dataType = new CliEnumAssemblyFlags();
		
		public CliEnumAssemblyFlags() {
			super(new CategoryPath(PATH), "AssemblyFlags", 4);
			// TODO: specify CategoryPath, etc.
			String prefix = "";
			add(prefix+"PublicKey", 0x00000001);
			add(prefix+"Retargetable", 0x00000100);
			add(prefix+"DisableJITcompileOptimizer", 0x00004000);
			add(prefix+"EnableJITcompileTracking", 0x00008000);
		}
	}
	
	public static class CliEnumAssemblyHashAlgorithm extends EnumDataType {
		private static final long serialVersionUID = 1L;
		
		/** A statically defined instance.*/
	    public final static CliEnumAssemblyHashAlgorithm dataType = new CliEnumAssemblyHashAlgorithm();
		
		public CliEnumAssemblyHashAlgorithm() {
			super(new CategoryPath(PATH), "AssemblyHash", 4);
			// TODO: specify CategoryPath, etc.
			String prefix = "";
			add(prefix+"None", 0x00000000);
			add(prefix+"Reserved (MD5)", 0x00008003);
			add(prefix+"SHA1", 0x00008004);
		}
	}
	
	public static class CliEnumEventAttributes extends EnumDataType {
		private static final long serialVersionUID = 1L;
		
		/** A statically defined instance.*/
	    public final static CliEnumEventAttributes dataType = new CliEnumEventAttributes();
		
		public CliEnumEventAttributes() {
			super(new CategoryPath(PATH), "EventAttributes", 2);
			// TODO: specify CategoryPath, etc.
			String prefix = "";
			add(prefix+"SpecialName", 0x0200);
			add(prefix+"RTSpecialName", 0x0400);
		}
	}
	
	public static class CliEnumFieldAttributes extends EnumDataType {
		private static final long serialVersionUID = 1L;
		
		/** A statically defined instance.*/
	    public final static CliEnumFieldAttributes dataType = new CliEnumFieldAttributes();
		
		public CliEnumFieldAttributes() {
			super(new CategoryPath(PATH), "FieldAttributes", 2);
			// TODO: specify CategoryPath, etc.
			String prefix = "";
			add(prefix+"Access_CompilerControlled", 0x0000);
			add(prefix+"Access_Private", 0x0001);
			add(prefix+"Access_FamANDAssem", 0x0002);
			add(prefix+"Access_Assembly", 0x0003);
			add(prefix+"Access_Family", 0x0004);
			add(prefix+"Access_FamORAssem", 0x0005);
			add(prefix+"Access_Public", 0x0006);
			add(prefix+"Static", 0x0010);
			add(prefix+"InitOnly", 0x0020);
			add(prefix+"Literal", 0x0040);
			add(prefix+"NotSerialized", 0x0080);
			add(prefix+"SpecialName", 0x0200);
			add(prefix+"PInvokeImpl", 0x2000);
			add(prefix+"RTSpecialName", 0x0400);
			add(prefix+"HasFieldMarshal", 0x1000);
			add(prefix+"HasDefault", 0x8000);
			add(prefix+"HasFieldRVA", 0x0100);
		}
	}
	
	public static class CliEnumFileAttributes extends EnumDataType {
		private static final long serialVersionUID = 1L;
		
		/** A statically defined instance.*/
	    public final static CliEnumFileAttributes dataType = new CliEnumFileAttributes();
		
		public CliEnumFileAttributes() {
			super(new CategoryPath(PATH), "FileAttributes", 4);
			// TODO: specify CategoryPath, etc.
			String prefix = "";
			add(prefix+"ContainsMetaData", 0x0000);
			add(prefix+"ContainsNoMetaData", 0x0001);
		}
	}
	
	public static class CliEnumGenericParamAttributes extends EnumDataType {
		private static final long serialVersionUID = 1L;
		
		/** A statically defined instance.*/
	    public final static CliEnumGenericParamAttributes dataType = new CliEnumGenericParamAttributes();
		
		public CliEnumGenericParamAttributes() {
			super(new CategoryPath(PATH), "GenericParamAttributes", 2);
			// TODO: specify CategoryPath, etc.
			String prefix = "";
			add(prefix+"Variance_None", 0x0000);
			add(prefix+"Covariant", 0x0001);
			add(prefix+"Contravariant", 0x0002);
			add(prefix+"ReferenceTypeConstraint", 0x0004);
			add(prefix+"NotNullableValueTypeConstraint", 0x0008);
			add(prefix+"DefaultConstructorContstraint", 0x0010);
		}
	}
	
	public static class CliEnumPInvokeAttributes extends EnumDataType {
		private static final long serialVersionUID = 1L;
		
		/** A statically defined instance.*/
	    public final static CliEnumPInvokeAttributes dataType = new CliEnumPInvokeAttributes();
		
		public CliEnumPInvokeAttributes() {
			super(new CategoryPath(PATH), "PInvokeAttributes", 2);
			// TODO: specify CategoryPath, etc.
			String prefix = "";
			add(prefix+"NoMangle", 0x0001);

			add(prefix+"CharSetNotSpec", 0x0000);
			add(prefix+"CharSetAnsi", 0x0002);
			add(prefix+"CharSetUnicode", 0x0004);
			add(prefix+"CharSetAuto", 0x0006);
			
			add(prefix+"SupportsLastError", 0x0040);
			
			add(prefix+"CallConvPlatformapi", 0x0100);
			add(prefix+"CallConvCdecl", 0x0200);
			add(prefix+"CallConvStdcall", 0x0300);
			add(prefix+"CallConvThiscall", 0x0400);
			add(prefix+"CallConvFastcall", 0x0500);
		}
	}
	
	public static class CliEnumManifestResourceAttributes extends EnumDataType {
		private static final long serialVersionUID = 1L;
		
		/** A statically defined instance.*/
	    public final static CliEnumManifestResourceAttributes dataType = new CliEnumManifestResourceAttributes();
		
		public CliEnumManifestResourceAttributes() {
			super(new CategoryPath(PATH), "ManifestResourceAttributes", 4);
			// TODO: specify CategoryPath, etc.
			String prefix = "";
			add(prefix+"Public", 0x0001);
			add(prefix+"Private", 0x0002);
		}
	}

	public static class CliEnumMethodAttributes extends EnumDataType {
		private static final long serialVersionUID = 1L;
		
		/** A statically defined instance.*/
	    public final static CliEnumMethodAttributes dataType = new CliEnumMethodAttributes();
		
		public CliEnumMethodAttributes() {
			super(new CategoryPath(PATH), "MethodAttributes", 2);
			// TODO: specify CategoryPath, etc.
			String prefix = "MAccess_";
			add(prefix+"CompilerControlled", 0x0000);
			add(prefix+"Private", 0x0001);
			add(prefix+"FamANDAssem", 0x0002);
			add(prefix+"Assem", 0x0003);
			add(prefix+"Family", 0x0004);
			add(prefix+"FamORAssem", 0x0005);
			add(prefix+"Public", 0x0006);
			
			prefix = "";
			add(prefix+"Static", 0x0010);
			add(prefix+"Final", 0x0020);
			add(prefix+"Virtual", 0x0040);
			add(prefix+"HideBySig", 0x0080);
			
			prefix = "VtableLayout_";
//			add(prefix+"ReuseSlot", 0x0000); // TODO: this will not work (it will conflict with CompilerControlled)
			add(prefix+"NewSlot", 0x0100);

			prefix = "";
			add(prefix+"Strict", 0x0200);
			add(prefix+"Abstract", 0x0400);
			add(prefix+"SpecialName", 0x0800);
			
			add(prefix+"PInvokeImpl", 0x2000);
			add(prefix+"UnmanagedExport", 0x0008);

			add(prefix+"RTSpecialName", 0x1000);
			add(prefix+"HasSecurity", 0x4000);
			add(prefix+"RequireSecObject", 0x8000);
		}
	}

	public static class CliEnumMethodImplAttributes extends EnumDataType {
		private static final long serialVersionUID = 1L;
		
		/** A statically defined instance.*/
	    public final static CliEnumMethodImplAttributes dataType = new CliEnumMethodImplAttributes();
		
		public CliEnumMethodImplAttributes() {
			super(new CategoryPath(PATH), "MethodImplAttributes", 2);
			// TODO: specify CategoryPath, etc.
			String prefix = "CodeType_";
			add(prefix+"IL", 0x0000);
			add(prefix+"Native", 0x0001);
			add(prefix+"OPTIL", 0x0002);
			add(prefix+"Runtime", 0x0003);
			
			prefix = "";
			add(prefix+"Unmanaged", 0x0004);
//			add(prefix+"Managed", 0x0000); // TODO: This will not work (Will conflict with IL)
			
			add(prefix+"ForwardRef", 0x0010);
			add(prefix+"PreserveSig", 0x0080);
			add(prefix+"InternalCall", 0x1000);
			add(prefix+"Synchronized", 0x0020);
			add(prefix+"NoInlining", 0x0008);
			add(prefix+"MaxMethodImplVal", 0xffff);
			add(prefix+"NoOptimization", 0x0040);
		}
	}

	public static class CliEnumMethodSemanticsAttributes extends EnumDataType {
		private static final long serialVersionUID = 1L;
		
		/** A statically defined instance.*/
	    public final static CliEnumMethodSemanticsAttributes dataType = new CliEnumMethodSemanticsAttributes();
		
		public CliEnumMethodSemanticsAttributes() {
			super(new CategoryPath(PATH), "MethodSemanticsAttributes", 2);
			// TODO: specify CategoryPath, etc.
			String prefix = "";
			add(prefix+"Setter", 0x0001);
			add(prefix+"Getter", 0x0002);
			add(prefix+"Other", 0x0004);
			add(prefix+"AddOn", 0x0008);
			add(prefix+"RemoveOn", 0x0010);
			add(prefix+"Fire", 0x0020);
		}
	}

	public static class CliEnumParamAttributes extends EnumDataType {
		private static final long serialVersionUID = 1L;
		
		/** A statically defined instance.*/
	    public final static CliEnumParamAttributes dataType = new CliEnumParamAttributes();
		
		public CliEnumParamAttributes() {
			super(new CategoryPath(PATH), "ParamAttributes", 2);
			// TODO: specify CategoryPath, etc.
			String prefix = "";
			add(prefix+"In", 0x0001);
			add(prefix+"Out", 0x0002);
			add(prefix+"Optional", 0x0010);
			add(prefix+"HasDefault", 0x1000);
			add(prefix+"HasFieldMarshal", 0x2000);
			add(prefix+"Unused", 0xcfe0);
		}
	}

	public static class CliEnumPropertyAttributes extends EnumDataType {
		private static final long serialVersionUID = 1L;
		
		/** A statically defined instance.*/
	    public final static CliEnumPropertyAttributes dataType = new CliEnumPropertyAttributes();
		
		public CliEnumPropertyAttributes() {
			super(new CategoryPath(PATH), "PropertyAttributes", 2);
			// TODO: specify CategoryPath, etc.
			String prefix = "";
			add(prefix+"SpecialName", 0x0200);
			add(prefix+"RTSpecialName", 0x0400);
			add(prefix+"HasDefault", 0x1000);
			add(prefix+"Unused", 0xe9ff);
		}
	}

	public static class CliEnumTypeAttributes extends EnumDataType {
		private static final long serialVersionUID = 1L;
		
		/** A statically defined instance.*/
	    public final static CliEnumTypeAttributes dataType = new CliEnumTypeAttributes();
		
		public CliEnumTypeAttributes() {
			super(new CategoryPath(PATH), "TypeAttributes", 4);
			// TODO: specify CategoryPath, etc.
			String prefix = "Visibility_";
			add(prefix+"NotPublic", 0x00000000);
			add(prefix+"Public", 0x00000001);
			add(prefix+"NestedPublic", 0x00000002);
			add(prefix+"NestedPrivate", 0x00000003);
			add(prefix+"NestedFamily", 0x00000004);
			add(prefix+"NestedAssembly", 0x00000005);
			add(prefix+"NestedFamANDAssem", 0x00000006);
			add(prefix+"NestedFamORAssem", 0x00000007);

			prefix = "";
//			add(prefix+"AutoLayout", 0x00000000); // TODO: Will not work, will conflict with Visibility_NotPublic
			add(prefix+"SequentialLayout", 0x00000008);
			add(prefix+"ExplicitLayout", 0x00000010);

//			add(prefix+"Class", 0x00000000); // TODO: Will not work, will conflict with Visibility_NotPublic
			add(prefix+"Interface", 0x00000020);

			add(prefix+"Abstract", 0x00000080);
			add(prefix+"Sealed", 0x00000100);
			add(prefix+"SpecialName", 0x00000400);

			add(prefix+"Import", 0x00001000);
			add(prefix+"Serializable", 0x00002000);

//			add(prefix+"AnsiClass", 0x00000000); // TODO: Will not work, will conflict with Visibility_NotPublic
			add(prefix+"UnicodeClass", 0x00010000);
			add(prefix+"AutoClass", 0x00020000);
			add(prefix+"CustomFormatClass", 0x00030000);

			add(prefix+"CustomStringFormatMask", 0x00C00000);

			add(prefix+"BeforeFieldInit", 0x00100000);

			add(prefix+"RTSpecialName", 0x00000800);
			add(prefix+"HasSecurity", 0x00040000);
			add(prefix+"IsTypeForwarder", 0x00200000);

		}
	}
	
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/indexes/CliCodedIndexUtils.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables.indexes;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.CliTypeTable;
import ghidra.program.model.data.*;
import ghidra.util.exception.InvalidInputException;

public class CliCodedIndexUtils {	
	public static DataType toDataType(CliStreamMetadata stream, int bitsUsed, CliTypeTable tables[]) {
		int maxForWord = (1 << (WordDataType.dataType.getLength()*8 - bitsUsed)) - 1;
		for (CliTypeTable table : tables) {
			if (table != null && stream.getNumberRowsForTable(table) > maxForWord)
				return DWordDataType.dataType;
		}
		return WordDataType.dataType;
	}
	
	public static CliTypeTable getTableName(int codedIndex, int bitsUsed, CliTypeTable tables[]) throws InvalidInputException {
		int mask = (2 << (bitsUsed - 1)) - 1; // 2 << (bitsUsed-1) == 2^(bitsUsed)
		int tableBits = codedIndex & mask;
		if (tableBits >= tables.length)
			throw new InvalidInputException("The coded index is not valid for this index type. There is no TableName for the bit pattern.");
		return tables[tableBits];
	}
	
	public static int getRowIndex(int codedIndex, int bitsUsed) {
		return codedIndex >> bitsUsed;
	}
	
	public static int readCodedIndex(BinaryReader reader, CliStreamMetadata stream, int bitsUsed, CliTypeTable tables[]) throws IOException {
		if (toDataType(stream, bitsUsed, tables).getLength() == WordDataType.dataType.getLength()) {
			return reader.readNextShort();
		}
		return reader.readNextInt();
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/indexes/CliIndexCustomAttributeType.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables.indexes;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.CliTypeTable;
import ghidra.program.model.data.DataType;
import ghidra.util.exception.InvalidInputException;

public class CliIndexCustomAttributeType {
	private static final int bitsUsed = 3;
	private static final CliTypeTable tables[] = { null, null, CliTypeTable.MethodDef, CliTypeTable.MemberRef };
	
	public static DataType toDataType(CliStreamMetadata stream) {
		return CliCodedIndexUtils.toDataType(stream, bitsUsed, tables);
	}
	
	public static int getRowIndex(int codedIndex) {
		return CliCodedIndexUtils.getRowIndex(codedIndex, bitsUsed);
	}
	
	public static CliTypeTable getTableName(int codedIndex) throws InvalidInputException {
		return CliCodedIndexUtils.getTableName(codedIndex, bitsUsed, tables);
	}
	
	public static int readCodedIndex(BinaryReader reader, CliStreamMetadata stream) throws IOException {
		return CliCodedIndexUtils.readCodedIndex(reader, stream, bitsUsed, tables);
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/indexes/CliIndexHasConstant.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables.indexes;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.CliTypeTable;
import ghidra.program.model.data.DataType;
import ghidra.util.exception.InvalidInputException;

public class CliIndexHasConstant {
	private static final int bitsUsed = 2;
	private static final CliTypeTable tables[] = { CliTypeTable.Field, CliTypeTable.Param, CliTypeTable.Property };
	
	public static DataType toDataType(CliStreamMetadata stream) {
		return CliCodedIndexUtils.toDataType(stream, bitsUsed, tables);
	}
	
	public static int getRowIndex(int codedIndex) {
		return CliCodedIndexUtils.getRowIndex(codedIndex, bitsUsed);
	}
	
	public static CliTypeTable getTableName(int codedIndex) throws InvalidInputException {
		return CliCodedIndexUtils.getTableName(codedIndex, bitsUsed, tables);
	}
	
	public static int readCodedIndex(BinaryReader reader, CliStreamMetadata stream) throws IOException {
		return CliCodedIndexUtils.readCodedIndex(reader, stream, bitsUsed, tables);
	}

}


```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/indexes/CliIndexHasCustomAttribute.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables.indexes;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.CliTypeTable;
import ghidra.program.model.data.DataType;
import ghidra.util.exception.InvalidInputException;

public class CliIndexHasCustomAttribute {
	private static final int bitsUsed = 5;
	private static final CliTypeTable tables[] = { CliTypeTable.MethodDef, CliTypeTable.Field, CliTypeTable.TypeRef, CliTypeTable.TypeDef, CliTypeTable.Param, 
		CliTypeTable.InterfaceImpl, CliTypeTable.MemberRef, CliTypeTable.Module, null, CliTypeTable.Property, CliTypeTable.Event, CliTypeTable.StandAloneSig,
		CliTypeTable.ModuleRef, CliTypeTable.TypeSpec, CliTypeTable.Assembly, CliTypeTable.AssemblyRef, CliTypeTable.File, CliTypeTable.ExportedType, 
		CliTypeTable.ManifestResource }; // TODO: null should be TableName.Permission, but this is not well-described in the standard
	
	public static DataType toDataType(CliStreamMetadata stream) {
		return CliCodedIndexUtils.toDataType(stream, bitsUsed, tables);
	}
	
	public static int getRowIndex(int codedIndex) {
		return CliCodedIndexUtils.getRowIndex(codedIndex, bitsUsed);
	}
	
	public static CliTypeTable getTableName(int codedIndex) throws InvalidInputException {
		return CliCodedIndexUtils.getTableName(codedIndex, bitsUsed, tables);
	}
	
	public static int readCodedIndex(BinaryReader reader, CliStreamMetadata stream) throws IOException {
		return CliCodedIndexUtils.readCodedIndex(reader, stream, bitsUsed, tables);
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/indexes/CliIndexHasDeclSecurity.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables.indexes;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.CliTypeTable;
import ghidra.program.model.data.DataType;
import ghidra.util.exception.InvalidInputException;

public class CliIndexHasDeclSecurity {
	private static final int bitsUsed = 2;
	private static final CliTypeTable tables[] = { CliTypeTable.TypeDef, CliTypeTable.MethodDef, CliTypeTable.Assembly };
	
	public static DataType toDataType(CliStreamMetadata stream) {
		return CliCodedIndexUtils.toDataType(stream, bitsUsed, tables);
	}
	
	public static int getRowIndex(int codedIndex) {
		return CliCodedIndexUtils.getRowIndex(codedIndex, bitsUsed);
	}
	
	public static CliTypeTable getTableName(int codedIndex) throws InvalidInputException {
		return CliCodedIndexUtils.getTableName(codedIndex, bitsUsed, tables);
	}
	
	public static int readCodedIndex(BinaryReader reader, CliStreamMetadata stream) throws IOException {
		return CliCodedIndexUtils.readCodedIndex(reader, stream, bitsUsed, tables);
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/indexes/CliIndexHasFieldMarshall.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables.indexes;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.CliTypeTable;
import ghidra.program.model.data.DataType;
import ghidra.util.exception.InvalidInputException;

public class CliIndexHasFieldMarshall {
	private static final int bitsUsed = 1;
	private static final CliTypeTable tables[] = { CliTypeTable.Field, CliTypeTable.Param };
	
	public static DataType toDataType(CliStreamMetadata stream) {
		return CliCodedIndexUtils.toDataType(stream, bitsUsed, tables);
	}
	
	public static int getRowIndex(int codedIndex) {
		return CliCodedIndexUtils.getRowIndex(codedIndex, bitsUsed);
	}
	
	public static CliTypeTable getTableName(int codedIndex) throws InvalidInputException {
		return CliCodedIndexUtils.getTableName(codedIndex, bitsUsed, tables);
	}
	
	public static int readCodedIndex(BinaryReader reader, CliStreamMetadata stream) throws IOException {
		return CliCodedIndexUtils.readCodedIndex(reader, stream, bitsUsed, tables);
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/indexes/CliIndexHasSemantics.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables.indexes;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.CliTypeTable;
import ghidra.program.model.data.DataType;
import ghidra.util.exception.InvalidInputException;

public class CliIndexHasSemantics {
	private static final int bitsUsed = 1;
	private static final CliTypeTable tables[] = { CliTypeTable.Event, CliTypeTable.Property };
	
	public static DataType toDataType(CliStreamMetadata stream) {
		return CliCodedIndexUtils.toDataType(stream, bitsUsed, tables);
	}
	
	public static int getRowIndex(int codedIndex) {
		return CliCodedIndexUtils.getRowIndex(codedIndex, bitsUsed);
	}
	
	public static CliTypeTable getTableName(int codedIndex) throws InvalidInputException {
		return CliCodedIndexUtils.getTableName(codedIndex, bitsUsed, tables);
	}
	
	public static int readCodedIndex(BinaryReader reader, CliStreamMetadata stream) throws IOException {
		return CliCodedIndexUtils.readCodedIndex(reader, stream, bitsUsed, tables);
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/indexes/CliIndexImplementation.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables.indexes;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.CliTypeTable;
import ghidra.program.model.data.DataType;
import ghidra.util.exception.InvalidInputException;

public class CliIndexImplementation {
	private static final int bitsUsed = 2;
	private static final CliTypeTable tables[] = { CliTypeTable.File, CliTypeTable.AssemblyRef, CliTypeTable.ExportedType };
	
	public static DataType toDataType(CliStreamMetadata stream) {
		return CliCodedIndexUtils.toDataType(stream, bitsUsed, tables);
	}
	
	public static int getRowIndex(int codedIndex) {
		return CliCodedIndexUtils.getRowIndex(codedIndex, bitsUsed);
	}
	
	public static CliTypeTable getTableName(int codedIndex) throws InvalidInputException {
		return CliCodedIndexUtils.getTableName(codedIndex, bitsUsed, tables);
	}
	
	public static int readCodedIndex(BinaryReader reader, CliStreamMetadata stream) throws IOException {
		return CliCodedIndexUtils.readCodedIndex(reader, stream, bitsUsed, tables);
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/indexes/CliIndexMemberForwarded.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables.indexes;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.CliTypeTable;
import ghidra.program.model.data.DataType;
import ghidra.util.exception.InvalidInputException;

public class CliIndexMemberForwarded {
	private static final int bitsUsed = 1;
	private static final CliTypeTable tables[] = { CliTypeTable.Field, CliTypeTable.MethodDef };
	
	public static DataType toDataType(CliStreamMetadata stream) {
		return CliCodedIndexUtils.toDataType(stream, bitsUsed, tables);
	}
	
	public static int getRowIndex(int codedIndex) {
		return CliCodedIndexUtils.getRowIndex(codedIndex, bitsUsed);
	}
	
	public static CliTypeTable getTableName(int codedIndex) throws InvalidInputException {
		return CliCodedIndexUtils.getTableName(codedIndex, bitsUsed, tables);
	}
	
	public static int readCodedIndex(BinaryReader reader, CliStreamMetadata stream) throws IOException {
		return CliCodedIndexUtils.readCodedIndex(reader, stream, bitsUsed, tables);
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/indexes/CliIndexMemberRefParent.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables.indexes;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.CliTypeTable;
import ghidra.program.model.data.DataType;
import ghidra.util.exception.InvalidInputException;

public class CliIndexMemberRefParent extends CliCodedIndexUtils {
	private static final int bitsUsed = 3;
	private static final CliTypeTable tables[] = { CliTypeTable.TypeDef, CliTypeTable.TypeRef, CliTypeTable.ModuleRef, CliTypeTable.MethodDef, CliTypeTable.TypeSpec };
	
	public static DataType toDataType(CliStreamMetadata stream) {
		return CliCodedIndexUtils.toDataType(stream, bitsUsed, tables);
	}
	
	public static int getRowIndex(int codedIndex) {
		return CliCodedIndexUtils.getRowIndex(codedIndex, bitsUsed);
	}
	
	public static CliTypeTable getTableName(int codedIndex) throws InvalidInputException {
		return CliCodedIndexUtils.getTableName(codedIndex, bitsUsed, tables);
	}
	
	public static int readCodedIndex(BinaryReader reader, CliStreamMetadata stream) throws IOException {
		return CliCodedIndexUtils.readCodedIndex(reader, stream, bitsUsed, tables);
	}
	
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/indexes/CliIndexMethodDefOrRef.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables.indexes;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.CliTypeTable;
import ghidra.program.model.data.DataType;
import ghidra.util.exception.InvalidInputException;

public class CliIndexMethodDefOrRef {
	private static final int bitsUsed = 1;
	private static final CliTypeTable tables[] = { CliTypeTable.MethodDef, CliTypeTable.MemberRef };
	
	public static DataType toDataType(CliStreamMetadata stream) {
		return CliCodedIndexUtils.toDataType(stream, bitsUsed, tables);
	}
	
	public static int getRowIndex(int codedIndex) {
		return CliCodedIndexUtils.getRowIndex(codedIndex, bitsUsed);
	}
	
	public static CliTypeTable getTableName(int codedIndex) throws InvalidInputException {
		return CliCodedIndexUtils.getTableName(codedIndex, bitsUsed, tables);
	}
	
	public static int readCodedIndex(BinaryReader reader, CliStreamMetadata stream) throws IOException {
		return CliCodedIndexUtils.readCodedIndex(reader, stream, bitsUsed, tables);
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/indexes/CliIndexResolutionScope.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables.indexes;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.CliTypeTable;
import ghidra.program.model.data.DataType;
import ghidra.util.exception.InvalidInputException;

public class CliIndexResolutionScope {
	private static final int bitsUsed = 2;
	private static final CliTypeTable tables[] = { CliTypeTable.Module, CliTypeTable.ModuleRef, CliTypeTable.AssemblyRef, CliTypeTable.TypeRef };
	
	public static DataType toDataType(CliStreamMetadata stream) {
		return CliCodedIndexUtils.toDataType(stream, bitsUsed, tables);
	}
	
	public static int getRowIndex(int codedIndex) {
		return CliCodedIndexUtils.getRowIndex(codedIndex, bitsUsed);
	}
	
	public static CliTypeTable getTableName(int codedIndex) throws InvalidInputException {
		return CliCodedIndexUtils.getTableName(codedIndex, bitsUsed, tables);
	}
	
	public static int readCodedIndex(BinaryReader reader, CliStreamMetadata stream) throws IOException {
		return CliCodedIndexUtils.readCodedIndex(reader, stream, bitsUsed, tables);
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/indexes/CliIndexTypeDefOrRef.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables.indexes;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.CliTypeTable;
import ghidra.program.model.data.DataType;
import ghidra.util.exception.InvalidInputException;

public class CliIndexTypeDefOrRef {
	private static final int bitsUsed = 2;
	private static final CliTypeTable tables[] = { CliTypeTable.TypeDef, CliTypeTable.TypeRef, CliTypeTable.TypeSpec };
	
	public static DataType toDataType(CliStreamMetadata stream) {
		return CliCodedIndexUtils.toDataType(stream, bitsUsed, tables);
	}
	
	public static int getRowIndex(int codedIndex) {
		return CliCodedIndexUtils.getRowIndex(codedIndex, bitsUsed);
	}
	
	public static CliTypeTable getTableName(int codedIndex) throws InvalidInputException {
		return CliCodedIndexUtils.getTableName(codedIndex, bitsUsed, tables);
	}
	
	public static int readCodedIndex(BinaryReader reader, CliStreamMetadata stream) throws IOException {
		return CliCodedIndexUtils.readCodedIndex(reader, stream, bitsUsed, tables);
	}
	
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/cli/tables/indexes/CliIndexTypeOrMethodDef.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.cli.tables.indexes;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import net.jubjubnest.minidump.contrib.pe.cli.streams.CliStreamMetadata;
import net.jubjubnest.minidump.contrib.pe.cli.tables.CliTypeTable;
import ghidra.program.model.data.DataType;
import ghidra.util.exception.InvalidInputException;

public class CliIndexTypeOrMethodDef {
	private static final int bitsUsed = 1;
	private static final CliTypeTable tables[] = { CliTypeTable.TypeDef, CliTypeTable.MethodDef };
	
	public static DataType toDataType(CliStreamMetadata stream) {
		return CliCodedIndexUtils.toDataType(stream, bitsUsed, tables);
	}
	
	public static int getRowIndex(int codedIndex) {
		return CliCodedIndexUtils.getRowIndex(codedIndex, bitsUsed);
	}
	
	public static CliTypeTable getTableName(int codedIndex) throws InvalidInputException {
		return CliCodedIndexUtils.getTableName(codedIndex, bitsUsed, tables);
	}
	
	public static int readCodedIndex(BinaryReader reader, CliStreamMetadata stream) throws IOException {
		return CliCodedIndexUtils.readCodedIndex(reader, stream, bitsUsed, tables);
	}
	
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/DataSym32.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;

import java.io.*;

/**
 * <pre>
 * typedef struct DATASYM32 {
 *     unsigned short  reclen;         // Record length
 *     unsigned short  rectyp;         // S_LDATA32, S_GDATA32 or S_PUB32
 *     CV_uoff32_t     off;            // (unsigned long)
 *     unsigned short  seg;
 *     CV_typ_t        typind;         // Type index (unsigned short)
 *     unsigned char   name[1];        // Length-prefixed name
 * } DATASYM32;
 * </pre>
 * 
 * 
 */
class DataSym32 extends DebugSymbol {
    private short   typeIndex;
    private byte    nameChar;

    static DataSym32 createDataSym32(short length, short type,
            FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
        DataSym32 dataSym32 = (DataSym32) reader.getFactory().create(DataSym32.class);
        dataSym32.initDataSym32(length, type, reader, ptr);
        return dataSym32;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public DataSym32() {}

    private void initDataSym32(short length, short type, FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
    	processDebugSymbol(length, type);

        this.offset    = reader.readInt  (ptr); ptr += BinaryReader.SIZEOF_INT;
        this.section   = reader.readShort(ptr); ptr += BinaryReader.SIZEOF_SHORT;
        this.typeIndex = reader.readShort(ptr); ptr += BinaryReader.SIZEOF_SHORT;
        this.nameChar  = reader.readByte (ptr); ptr += BinaryReader.SIZEOF_BYTE;
        this.name      = reader.readAsciiString(ptr); ptr += name.length();
    }

    int getTypeIndex() {
    	return typeIndex;
    }
    byte getNameChar() {
    	return nameChar;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/DataSym32_new.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;
import ghidra.util.*;

import java.io.*;

/**
 * <pre>
 * typedef struct DATASYM32_NEW {
 *     unsigned short  reclen;         // Record length
 *     unsigned short  rectyp;         // S_LDATA32, S_GDATA32 or S_PUB32
 *     CVTYPEINDEX     typind;
 *     unsigned long   off;
 *     unsigned short  seg;
 *     unsigned char   name[1];        // Length-prefixed name
 * } DATASYM32_NEW;
 * </pre>
 * 
 * 
 */
class DataSym32_new extends DebugSymbol {
    private int  typeIndex;
    private byte nameChar;

    static DataSym32_new createDataSym32_new(short length, short type,
            FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
        DataSym32_new dataSym32_new = (DataSym32_new) reader.getFactory().create(DataSym32_new.class);
        dataSym32_new.initDataSym32_new(length, type, reader, ptr);
        return dataSym32_new;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public DataSym32_new() {}

    private void initDataSym32_new(short length, short type, FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
    	processDebugSymbol(length, type);

        this.typeIndex = reader.readInt  (ptr); ptr += BinaryReader.SIZEOF_INT;
        this.offset    = reader.readInt  (ptr); ptr += BinaryReader.SIZEOF_INT;
        this.section   = reader.readShort(ptr); ptr += BinaryReader.SIZEOF_SHORT;

        byte nameLen = reader.readByte(ptr); ptr += BinaryReader.SIZEOF_BYTE;

        this.name = reader.readAsciiString(ptr, Conv.byteToInt(nameLen));
    }

    int getTypeIndex() {
    	return typeIndex;
    }
    byte getNameChar() {
    	return nameChar;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/DebugCOFFLineNumber.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.util.Conv;

/**
 * A class to represent the COFF Line number data structure.
 * <br>
 * <pre>
 * typedef struct _IMAGE_LINENUMBER {
 *    union {
 *        DWORD   SymbolTableIndex; // Symbol table index of function name if Linenumber is 0.
 *        DWORD   VirtualAddress;   // Virtual address of line number.
 *    } Type;
 *    WORD    Linenumber;           // Line number.
 * } IMAGE_LINENUMBER;
 * </pre>
 */
public class DebugCOFFLineNumber {
	/**
	 * The size of the <code>IMAGE_LINENUMBER</code> structure.
	 */
    public final static int IMAGE_SIZEOF_LINENUMBER = 6;

    private int symbolTableIndex;
    private int virtualAddress;
    private int lineNumber;

    public static DebugCOFFLineNumber createDebugCOFFLineNumber(
            FactoryBundledWithBinaryReader reader, int index)
            throws IOException {
        DebugCOFFLineNumber debugCOFFLineNumber = (DebugCOFFLineNumber) reader.getFactory().create(DebugCOFFLineNumber.class);
        debugCOFFLineNumber.initDebugCOFFLineNumber(reader, index);
        return debugCOFFLineNumber;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public DebugCOFFLineNumber() {}

    private void initDebugCOFFLineNumber(FactoryBundledWithBinaryReader reader, int index) throws IOException {
        symbolTableIndex = reader.readInt(index);
        virtualAddress   = reader.readInt(index);
        index += BinaryReader.SIZEOF_INT;
		lineNumber = Conv.shortToInt(reader.readShort(index));
    }

	/**
	 * Returns the symbol table index of function name, if linenumber is 0.
	 * @return the symbol table index of function name, if linenumber is 0
	 */
    public int getSymbolTableIndex() {
        return symbolTableIndex;
    }
    /**
     * Returns the virtual address of the line number.
     * @return the virtual address of the line number
     */
    public int getVirtualAddress() {
        return virtualAddress;
    }
    /**
     * Returns the line number.
     * @return the line number
     */
    public int getLineNumber() {
        return lineNumber;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/DebugCOFFSymbol.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;
import ghidra.program.model.data.*;
import ghidra.util.*;
import ghidra.util.exception.*;

import java.io.*;

/**
 * A class to represent the COFF symbol data structure.
 * <br>
 * <pre>
 * typedef struct _IMAGE_SYMBOL {
 *     union {
 *         BYTE    ShortName[8];
 *         struct {
 *             DWORD   Short;     // if 0, use LongName
 *             DWORD   Long;      // offset into string table
 *         } Name;
 *         DWORD   LongName[2];    // PBYTE [2]
 *     } N;
 *     DWORD   Value;
 *     SHORT   SectionNumber;
 *     WORD    Type;
 *     BYTE    StorageClass;
 *     BYTE    NumberOfAuxSymbols;
 * } IMAGE_SYMBOL;
 * </pre>
 */
public class DebugCOFFSymbol implements StructConverter {
	private static final int NAME_LENGTH = 8;

	/**
	 * The size of the <code>IMAGE_SYMBOL</code> structure.
	 */
    public final static int IMAGE_SIZEOF_SYMBOL = 18;

    //
    // Section values.
    //
    //
    public final static short IMAGE_SYM_UNDEFINED =  0; // Symbol is undefined or is common.
    public final static short IMAGE_SYM_ABSOLUTE  = -1; // Symbol is an absolute value.
    public final static short IMAGE_SYM_DEBUG     = -2; // Symbol is a special debug item.

    //
    // Type (fundamental) values.
    //
    public final static short IMAGE_SYM_TYPE_NULL      = 0x0000;  // no type.
    public final static short IMAGE_SYM_TYPE_VOID      = 0x0001;  //
    public final static short IMAGE_SYM_TYPE_CHAR      = 0x0002;  // type character.
    public final static short IMAGE_SYM_TYPE_SHORT     = 0x0003;  // type short integer.
    public final static short IMAGE_SYM_TYPE_INT       = 0x0004;  //
    public final static short IMAGE_SYM_TYPE_LONG      = 0x0005;  //
    public final static short IMAGE_SYM_TYPE_FLOAT     = 0x0006;  //
    public final static short IMAGE_SYM_TYPE_DOUBLE    = 0x0007;  //
    public final static short IMAGE_SYM_TYPE_STRUCT    = 0x0008;  //
    public final static short IMAGE_SYM_TYPE_UNION     = 0x0009;  //
    public final static short IMAGE_SYM_TYPE_ENUM      = 0x000A;  // enumeration.
    public final static short IMAGE_SYM_TYPE_MOE       = 0x000B;  // member of enumeration.
    public final static short IMAGE_SYM_TYPE_BYTE      = 0x000C;  //
    public final static short IMAGE_SYM_TYPE_WORD      = 0x000D;  //
    public final static short IMAGE_SYM_TYPE_UINT      = 0x000E;  //
    public final static short IMAGE_SYM_TYPE_DWORD     = 0x000F;  //
    public final static short IMAGE_SYM_TYPE_PCODE     = (short)0x8000;

    //
    // Type (derived) values.
    //
    public final static short IMAGE_SYM_DTYPE_NULL       = 0;  // no derived type.
    public final static short IMAGE_SYM_DTYPE_POINTER    = 1;  // pointer.
    public final static short IMAGE_SYM_DTYPE_FUNCTION   = 2;  // function.
    public final static short IMAGE_SYM_DTYPE_ARRAY      = 3;  // array.

    //
    // Storage classes.
    //
    public final static byte IMAGE_SYM_CLASS_END_OF_FUNCTION     = (byte)0xff;
    public final static byte IMAGE_SYM_CLASS_NULL                = 0x00;
    public final static byte IMAGE_SYM_CLASS_AUTOMATIC           = 0x01;
    public final static byte IMAGE_SYM_CLASS_EXTERNAL            = 0x02;
    public final static byte IMAGE_SYM_CLASS_STATIC              = 0x03;
    public final static byte IMAGE_SYM_CLASS_REGISTER            = 0x04;
    public final static byte IMAGE_SYM_CLASS_EXTERNAL_DEF        = 0x05;
    public final static byte IMAGE_SYM_CLASS_LABEL               = 0x06;
    public final static byte IMAGE_SYM_CLASS_UNDEFINED_LABEL     = 0x07;
    public final static byte IMAGE_SYM_CLASS_MEMBER_OF_STRUCT    = 0x08;
    public final static byte IMAGE_SYM_CLASS_ARGUMENT            = 0x09;
    public final static byte IMAGE_SYM_CLASS_STRUCT_TAG          = 0x0A;
    public final static byte IMAGE_SYM_CLASS_MEMBER_OF_UNION     = 0x0B;
    public final static byte IMAGE_SYM_CLASS_UNION_TAG           = 0x0C;
    public final static byte IMAGE_SYM_CLASS_TYPE_DEFINITION     = 0x0D;
    public final static byte IMAGE_SYM_CLASS_UNDEFINED_STATIC    = 0x0E;
    public final static byte IMAGE_SYM_CLASS_ENUM_TAG            = 0x0F;
    public final static byte IMAGE_SYM_CLASS_MEMBER_OF_ENUM      = 0x10;
    public final static byte IMAGE_SYM_CLASS_REGISTER_PARAM      = 0x11;
    public final static byte IMAGE_SYM_CLASS_BIT_FIELD           = 0x12;
    public final static byte IMAGE_SYM_CLASS_FAR_EXTERNAL        = 0x44;
    public final static byte IMAGE_SYM_CLASS_BLOCK               = 0x64;
    public final static byte IMAGE_SYM_CLASS_FUNCTION            = 0x65;
    public final static byte IMAGE_SYM_CLASS_END_OF_STRUCT       = 0x66;
    public final static byte IMAGE_SYM_CLASS_FILE                = 0x67;
    public final static byte IMAGE_SYM_CLASS_SECTION             = 0x68;
    public final static byte IMAGE_SYM_CLASS_WEAK_EXTERNAL       = 0x69;
  //public final static byte IMAGE_SYM_CLASS_CLR_TOKEN           = ??

    private String name;
    private int value;
    private short sectionNumber;
    private short type;
    private byte storageClass;
    private byte numberOfAuxSymbols;
    private DebugCOFFSymbolAux [] auxSymbols;

    public static DebugCOFFSymbol createDebugCOFFSymbol(
            FactoryBundledWithBinaryReader reader, int index,
            DebugCOFFSymbolTable symbolTable) throws IOException {
        return createDebugCOFFSymbol(reader, index, symbolTable.getStringTableIndex());
    }

    public static DebugCOFFSymbol createDebugCOFFSymbol(
            FactoryBundledWithBinaryReader reader, int index,
            int stringTableIndex) throws IOException {
        DebugCOFFSymbol debugCOFFSymbol = (DebugCOFFSymbol) reader.getFactory().create(DebugCOFFSymbol.class);
        debugCOFFSymbol.initDebugCOFFSymbol(reader, index, stringTableIndex);
        return debugCOFFSymbol;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public DebugCOFFSymbol() {}

    private void initDebugCOFFSymbol(FactoryBundledWithBinaryReader reader, int index, int stringTableIndex) throws IOException {
        // read the union first...
        //
        int shortVal = reader.readInt(index);
        if (shortVal != 0) {
            name = reader.readAsciiString(index, NAME_LENGTH);
            index += 8;
        }
        else {
            index += BinaryReader.SIZEOF_INT;
            int longVal = reader.readInt(index);
            index += BinaryReader.SIZEOF_INT;
            if (longVal > 0) {
            	name = reader.readAsciiString(stringTableIndex + longVal);
            } 
        }

        value              = reader.readInt  (index); index += BinaryReader.SIZEOF_INT;
        sectionNumber      = reader.readShort(index); index += BinaryReader.SIZEOF_SHORT;
        type               = reader.readShort(index); index += BinaryReader.SIZEOF_SHORT;
        storageClass       = reader.readByte (index); index += BinaryReader.SIZEOF_BYTE;
        numberOfAuxSymbols = reader.readByte (index); index += BinaryReader.SIZEOF_BYTE;

        // process auxiliary symbols...
        auxSymbols = new DebugCOFFSymbolAux[Conv.byteToInt(numberOfAuxSymbols)];

        for (int i = 0 ; i < numberOfAuxSymbols ; ++i) {

            auxSymbols[i] = DebugCOFFSymbolAux.createDebugCOFFSymbolAux(reader, index, this);
            index += DebugCOFFSymbolAux.IMAGE_SIZEOF_AUX_SYMBOL;
        }
    }

	/**
	 * Returns the auxiliary symbols related to this symbol.
	 * @return the auxiliary symbols related to this symbol
	 */
    public DebugCOFFSymbolAux [] getAuxiliarySymbols() {
        return auxSymbols;
    }
    /**
     * Returns the name of this symbol.
     * @return the name of this symbol
     */
    public String getName() {
        return name;
    }
    /**
     * Returns the value of this symbol.
     * @return the value of this symbol
     */
    public int getValue() {
        return value;
    }
    /**
     * Returns a string equivalent of the value of this symbol.
     * @return a string equivalent of the value of this symbol
     */
    public String getValueAsString() {
        return Integer.toHexString(value);
    }
    /**
     * Returns the section number if this symbol.
     * @return the section number if this symbol
     */
    public int getSectionNumber() {
        return sectionNumber;
    }
	/**
	 * Returns a string equivalent of the section number of this symbol.
	 * @return a string equivalent of the section number of this symbol
	 */
    public String getSectionNumberAsString() {
        switch (sectionNumber) {
            case IMAGE_SYM_UNDEFINED: return "UNDEF";
            case IMAGE_SYM_ABSOLUTE:  return "ABS";
            case IMAGE_SYM_DEBUG:     return "DEBUG";
        }
        return Integer.toHexString(sectionNumber&0xffff);
    }
    /**
     * Returns the type of this symbol.
     * @return the type of this symbol
     */
    public int getType() {
        return type;
    }
	/**
	 * Returns a string equivalent of the type of this symbol.
	 * @return a string equivalent of the type of this symbol
	 */
    public String getTypeAsString() {
        return Integer.toHexString(type&0xffff);
    }
	/**
	 * Returns the storage class of this symbol.
	 * @return the storage class of this symbol
	 */
    public int getStorageClass() {
        return storageClass;
    }
	/**
	 * Returns a string equivalent of the storage class of this symbol.
	 * @return a string equivalent of the storage class of this symbol
	 */
    public String getStorageClassAsString() {
        switch( storageClass ) {
            case IMAGE_SYM_CLASS_END_OF_FUNCTION:  return "END_OF_FUNCTION";
            case IMAGE_SYM_CLASS_NULL:             return "NULL";
            case IMAGE_SYM_CLASS_AUTOMATIC:        return "AUTOMATIC";
            case IMAGE_SYM_CLASS_EXTERNAL:         return "EXTERNAL";
            case IMAGE_SYM_CLASS_STATIC:           return "STATIC";
            case IMAGE_SYM_CLASS_REGISTER:         return "REGISTER";
            case IMAGE_SYM_CLASS_EXTERNAL_DEF:     return "EXTERNAL_DEF";
            case IMAGE_SYM_CLASS_LABEL:            return "LABEL";
            case IMAGE_SYM_CLASS_UNDEFINED_LABEL:  return "UNDEFINED_LABEL";
            case IMAGE_SYM_CLASS_MEMBER_OF_STRUCT: return "MEMBER_OF_STRUCT";
            case IMAGE_SYM_CLASS_ARGUMENT:         return "ARGUMENT";
            case IMAGE_SYM_CLASS_STRUCT_TAG:       return "STRUCT_TAG";
            case IMAGE_SYM_CLASS_MEMBER_OF_UNION:  return "MEMBER_OF_UNION";
            case IMAGE_SYM_CLASS_UNION_TAG:        return "UNION_TAG";
            case IMAGE_SYM_CLASS_TYPE_DEFINITION:  return "TYPE_DEFINITION";
            case IMAGE_SYM_CLASS_UNDEFINED_STATIC: return "UNDEFINED_STATIC";
            case IMAGE_SYM_CLASS_ENUM_TAG:         return "ENUM_TAG";
            case IMAGE_SYM_CLASS_MEMBER_OF_ENUM:   return "MEMBER_OF_ENUM";
            case IMAGE_SYM_CLASS_REGISTER_PARAM:   return "REGISTER_PARAM";
            case IMAGE_SYM_CLASS_BIT_FIELD:        return "BIT_FIELD";
            case IMAGE_SYM_CLASS_FAR_EXTERNAL:     return "FAR_EXTERNAL";
            case IMAGE_SYM_CLASS_BLOCK:            return "BLOCK";
            case IMAGE_SYM_CLASS_FUNCTION:         return "FUNCTION";
            case IMAGE_SYM_CLASS_END_OF_STRUCT:    return "END_OF_STRUCT";
            case IMAGE_SYM_CLASS_FILE:             return "FILE";
            case IMAGE_SYM_CLASS_SECTION:          return "SECTION";
            case IMAGE_SYM_CLASS_WEAK_EXTERNAL:    return "WEAK_EXTERNAL";
          //case IMAGE_SYM_CLASS_CLR_TOKEN:        return "CLR_TOKEN";
        }
        return "STORAGE_CLASS_"+Integer.toHexString(storageClass&0xff);
    }

	/**
	 * Returns the number of auxiliary symbols defined with this symbol.
	 * @return the number of auxiliary symbols defined with this symbol
	 */
    public int getNumberOfAuxSymbols() {
        return numberOfAuxSymbols;
    }

    public DataType toDataType() throws DuplicateNameException, IOException {
    	String structureName = StructConverterUtil.parseName(DebugCOFFSymbol.class);
    	
    	Structure structure = new StructureDataType(structureName + "_" +numberOfAuxSymbols, 0);
    	structure.add(STRING, NAME_LENGTH, "name", null);
    	structure.add(DWORD, "value", null);
    	structure.add(WORD, "sectionNumber", null);
    	structure.add(WORD, "type", null);
    	structure.add(BYTE, "storageClass", null);
    	structure.add(BYTE, "numberOfAuxSymbols", null);

    	for ( DebugCOFFSymbolAux auxSymbol : auxSymbols ) {
			structure.add( auxSymbol.toDataType() );
		}
    	return structure;
    }

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/DebugCOFFSymbolAux.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import java.io.IOException;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.program.model.data.*;
import ghidra.util.exception.DuplicateNameException;

/**
 * A class to represent the COFF Auxiliary Symbol data structure.
 * <br>
 * <pre>
 * typedef union _IMAGE_AUX_SYMBOL {
 *     struct {
 *         DWORD    TagIndex;                      // struct, union, or enum tag index
 *         union {
 *             struct {
 *                 WORD    Linenumber;             // declaration line number
 *                 WORD    Size;                   // size of struct, union, or enum
 *             } LnSz;
 *            DWORD    TotalSize;
 *         }Misc;
 *         union {
 *             struct {                            // if ISFCN, tag, or .bb
 *                 DWORD    PointerToLinenumber;
 *                 DWORD    PointerToNextFunction;
 *             } Function;
 *             struct {                            // if ISARY, up to 4 dimen.
 *                 WORD     Dimension[4];
 *             } Array;
 *         } FcnAry;
 *         WORD    TvIndex;                        // tv index
 *     } Sym;
 *     struct {
 *         BYTE    Name[IMAGE_SIZEOF_SYMBOL];
 *     } File;
 *     struct {
 *         DWORD   Length;                         // section length
 *         WORD    NumberOfRelocations;            // number of relocation entries
 *         WORD    NumberOfLinenumbers;            // number of line numbers
 *         DWORD   CheckSum;                       // checksum for communal
 *         SHORT   Number;                         // section number to associate with
 *         BYTE    Selection;                      // communal selection type
 *     } Section;
 * } IMAGE_AUX_SYMBOL;
 * </pre>
 */
public class DebugCOFFSymbolAux implements StructConverter {
    public final static byte IMAGE_SIZEOF_AUX_SYMBOL = 18;

    private AuxSym sym;
    private AuxFile file;
    private AuxSection section;

    static DebugCOFFSymbolAux createDebugCOFFSymbolAux(
            FactoryBundledWithBinaryReader reader, int index,
            DebugCOFFSymbol symbol) throws IOException {
        DebugCOFFSymbolAux debugCOFFSymbolAux = (DebugCOFFSymbolAux) reader.getFactory().create(DebugCOFFSymbolAux.class);
        debugCOFFSymbolAux.initDebugCOFFSymbolAux(reader, index, symbol);
        return debugCOFFSymbolAux;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public DebugCOFFSymbolAux() {}

	private void initDebugCOFFSymbolAux(FactoryBundledWithBinaryReader reader, int index, DebugCOFFSymbol symbol) throws IOException {
        switch (symbol.getStorageClass()) {
            case DebugCOFFSymbol.IMAGE_SYM_CLASS_FILE:
                file = AuxFile.createAuxFile(reader, index);
                break;
            case DebugCOFFSymbol.IMAGE_SYM_CLASS_EXTERNAL:
            case DebugCOFFSymbol.IMAGE_SYM_CLASS_FUNCTION:
                sym = AuxSym.createAuxSym(reader, index);
                break;
            case DebugCOFFSymbol.IMAGE_SYM_CLASS_STATIC:
                section = AuxSection.createAuxSection(reader, index);
                break;
//          case IMAGE_SYM_CLASS_CLR_TOKEN:
//              break:
            default:
                // unhandled aux symbol...
                break;
        }
	}

	/**
	 * @see java.lang.Object#toString()
	 */
    @Override
    public String toString() {
        if (file != null) {
            return file.getName();
        }
        else if (sym != null) {
            return  "Tag="+Integer.toHexString(sym.getTagIndex())+"  "+
                    "TvIndex="+Integer.toHexString(sym.getTvIndex());
//TODO:
//there are other cases here!
        }
        else if (section != null) {
            return  "Section="+Integer.toHexString(section.getNumber())+"  "+
                    "Len="+Integer.toHexString(section.getLength())+"  "+
                    "NumOfRelocs="+section.getNumberOfRelocations()+"  "+
                    "NumOfLineNums="+section.getNumberOfLinenumbers()+"  "+
                    "Checksum="+Integer.toHexString(section.getCheckSum());
        }
        return super.toString();
    }

    @Override
	public DataType toDataType() throws DuplicateNameException, IOException {
    	String structureName = StructConverterUtil.parseName(DebugCOFFSymbolAux.class);
    	Structure structure = new StructureDataType(structureName, IMAGE_SIZEOF_AUX_SYMBOL);
    	/*
    	if (sym != null) {
    		structure.add(sym.toDataType());
    	}
    	if (file != null) {
    		structure.add(file.toDataType());
    	}
    	if (section != null) {
    		structure.add(section.toDataType());
    	}
    	*/
    	return structure;
    }

    private static class AuxSym implements StructConverter {
        private int      tagIndex;
        private short    miscLnSzLinenumber;
        private short    miscLnSzSize;
        private int      miscTotalSize;
        private int      fncAryFunctionPointerToLinenumber;
        private int      fncAryFunctionPointerToNextFunction;
        private short [] fncAryArrayDimension = new short[4];
        private short    tvIndex;

        private static AuxSym createAuxSym(FactoryBundledWithBinaryReader reader, int index) throws IOException {
            AuxSym auxSym = (AuxSym) reader.getFactory().create(AuxSym.class);
            auxSym.initAuxSym(reader, index);
            return auxSym;
        }

		/**
		 * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
		 */
		public AuxSym() {
		}

        private void initAuxSym(FactoryBundledWithBinaryReader reader, int index) throws IOException {
            tagIndex = reader.readInt(index); index += BinaryReader.SIZEOF_INT;

            miscLnSzLinenumber = reader.readShort(index);
            miscLnSzSize       = reader.readShort(index + BinaryReader.SIZEOF_SHORT);
            miscTotalSize      = reader.readInt  (index); index += BinaryReader.SIZEOF_INT;

            fncAryFunctionPointerToLinenumber   = reader.readInt(index);
            fncAryFunctionPointerToNextFunction = reader.readInt(index + BinaryReader.SIZEOF_INT);
            fncAryArrayDimension                = reader.readShortArray(index, 4); index += (4 * BinaryReader.SIZEOF_SHORT);

            tvIndex = reader.readShort(index); index += BinaryReader.SIZEOF_SHORT;
        }

        int getTagIndex() {
            return tagIndex;
        }
        short getMiscLnSzLinenumber() {
            return miscLnSzLinenumber;
        }
        short getMiscLnSzSize() {
            return miscLnSzSize;
        }
        int getMiscTotalSize() {
            return miscTotalSize;
        }
        int getFncAryFunctionPointerToLinenumber() {
            return fncAryFunctionPointerToLinenumber;
        }
        int getFncAryFunctionPointerToNextFunction() {
            return fncAryFunctionPointerToNextFunction;
        }
        short [] getFncAryArrayDimension() {
            return fncAryArrayDimension;
        }
        short getTvIndex() {
            return tvIndex;
        }
        @Override
		public DataType toDataType() throws DuplicateNameException, IOException {
        	return StructConverterUtil.toDataType(this);
        }
    }

    private static class AuxFile implements StructConverter {
        private String name;

        private static AuxFile createAuxFile(FactoryBundledWithBinaryReader reader, int index) throws IOException {
            AuxFile auxFile = (AuxFile) reader.getFactory().create(AuxFile.class);
            auxFile.initAuxFile(reader, index);
            return auxFile;
        }

		/**
		 * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
		 */
		public AuxFile() {
		}

        private void initAuxFile(FactoryBundledWithBinaryReader reader, int index) throws IOException {
            name = reader.readAsciiString(index, DebugCOFFSymbol.IMAGE_SIZEOF_SYMBOL);
        }

        String getName() {
            return name;
        }
        @Override
		public DataType toDataType() throws DuplicateNameException, IOException {
        	String structureName = StructConverterUtil.parseName(DebugCOFFSymbolAux.class);
        	Structure structure = new StructureDataType(structureName, 0);
        	structure.add(STRING, DebugCOFFSymbol.IMAGE_SIZEOF_SYMBOL, "name", null);
        	return structure;
        }
    }

    private static class AuxSection implements StructConverter {
        private int   length;
        private short numberOfRelocations;
        private short numberOfLinenumbers;
        private int   checkSum;
        private short number;
        private byte  selection;

        private static AuxSection createAuxSection(FactoryBundledWithBinaryReader reader, int index) throws IOException {
            AuxSection auxSection = (AuxSection) reader.getFactory().create(AuxSection.class);
            auxSection.initAuxSection(reader, index);
            return auxSection;
        }

		/**
		 * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
		 */
		public AuxSection() {
		}

        private void initAuxSection(FactoryBundledWithBinaryReader reader, int index) throws IOException {
            length              = reader.readInt  (index); index += BinaryReader.SIZEOF_INT;
            numberOfRelocations = reader.readShort(index); index += BinaryReader.SIZEOF_SHORT;
            numberOfLinenumbers = reader.readShort(index); index += BinaryReader.SIZEOF_SHORT;
            checkSum            = reader.readInt  (index); index += BinaryReader.SIZEOF_INT;
            number              = reader.readShort(index); index += BinaryReader.SIZEOF_SHORT;
            selection           = reader.readByte (index); index += BinaryReader.SIZEOF_BYTE;
        }

        int getLength() {
            return length;
        }
        int getNumberOfRelocations() {
            return numberOfRelocations;
        }
        int getNumberOfLinenumbers() {
            return numberOfLinenumbers;
        }
        int getCheckSum() {
            return checkSum;
        }
        int getNumber() {
            return number;
        }
        int getSelection() {
            return selection;
        }
        @Override
		public DataType toDataType() throws DuplicateNameException, IOException {
        	return StructConverterUtil.toDataType(this);
        }
    }
}


```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/DebugCOFFSymbolTable.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.format.*;
import net.jubjubnest.minidump.contrib.pe.NTHeader;

import java.io.*;

/**
 * A class to represent the COFF Symbol Table.
 */
public class DebugCOFFSymbolTable {
    private int ptrToSymbolTable;
    private int symbolCount;

    private DebugCOFFSymbol [] symbols;

    public static DebugCOFFSymbolTable createDebugCOFFSymbolTable(
            FactoryBundledWithBinaryReader reader,
            DebugCOFFSymbolsHeader coffHeader, int offset) throws IOException {
        DebugCOFFSymbolTable debugCOFFSymbolTable = (DebugCOFFSymbolTable) reader.getFactory().create(DebugCOFFSymbolTable.class);
        debugCOFFSymbolTable.initDebugCOFFSymbolTable(reader, coffHeader, offset);
        return debugCOFFSymbolTable;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public DebugCOFFSymbolTable() {}

    private void initDebugCOFFSymbolTable(FactoryBundledWithBinaryReader reader, DebugCOFFSymbolsHeader coffHeader, int offset) throws IOException {
        this.ptrToSymbolTable = coffHeader.getFirstSymbolLVA() + offset;
        this.symbolCount      = coffHeader.getNumberOfSymbols();

//TODO:
//should symbol table info in NT Header agree with info in COFF Header?

        if (symbolCount > 0 && symbolCount < NTHeader.MAX_SANE_COUNT) {
	        symbols = new DebugCOFFSymbol[symbolCount];
	        for (int i = 0 ; i < symbolCount ; ++i) {
	            symbols[i] = DebugCOFFSymbol.createDebugCOFFSymbol(reader, ptrToSymbolTable + (i * DebugCOFFSymbol.IMAGE_SIZEOF_SYMBOL), this);
	        }
        }
    }

    int getStringTableIndex() {
        return ptrToSymbolTable + (symbolCount * DebugCOFFSymbol.IMAGE_SIZEOF_SYMBOL);
    }

	/**
	 * Returns the COFF symbols defined in this COFF symbol table.
	 * @return the COFF symbols defined in this COFF symbol table
	 */
    public DebugCOFFSymbol [] getSymbols() {
        return symbols;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/DebugCOFFSymbolsHeader.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import net.jubjubnest.minidump.contrib.pe.NTHeader;
import net.jubjubnest.minidump.contrib.pe.OffsetValidator;
import ghidra.util.Msg;

import java.io.IOException;

/**
 * A class to represent the COFF Symbols Header.
 * <br>
 * <pre>
 * typedef struct _IMAGE_COFF_SYMBOLS_HEADER {
 *   DWORD   NumberOfSymbols;
 *   DWORD   LvaToFirstSymbol;
 *   DWORD   NumberOfLinenumbers;
 *   DWORD   LvaToFirstLinenumber;
 *   DWORD   RvaToFirstByteOfCode;
 *   DWORD   RvaToLastByteOfCode;
 *   DWORD   RvaToFirstByteOfData;
 *   DWORD   RvaToLastByteOfData;
 * } IMAGE_COFF_SYMBOLS_HEADER, *PIMAGE_COFF_SYMBOLS_HEADER;
 * </pre>
 */
public class DebugCOFFSymbolsHeader {
	private int numberOfSymbols;
	private int lvaToFirstSymbol;
	private int numberOfLinenumbers;
	private int lvaToFirstLinenumber;
	private int rvaToFirstByteOfCode;
	private int rvaToLastByteOfCode;
	private int rvaToFirstByteOfData;
	private int rvaToLastByteOfData;

	private DebugCOFFSymbolTable symbolTable;
	private DebugCOFFLineNumber[] lineNumbers;

	/**
	 * Constructor
	 * @param reader the binary reader
	 * @param debugDir the debug directory associated to this COFF symbol header
	 * @param ntHeader 
	 */
	static DebugCOFFSymbolsHeader createDebugCOFFSymbolsHeader(
			FactoryBundledWithBinaryReader reader, DebugDirectory debugDir,
			OffsetValidator validator) throws IOException {
		DebugCOFFSymbolsHeader debugCOFFSymbolsHeader =
			(DebugCOFFSymbolsHeader) reader.getFactory().create(DebugCOFFSymbolsHeader.class);
		debugCOFFSymbolsHeader.initDebugCOFFSymbolsHeader(reader, debugDir, validator);
		return debugCOFFSymbolsHeader;
	}

	/**
	 * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
	 */
	public DebugCOFFSymbolsHeader() {
	}

	private void initDebugCOFFSymbolsHeader(FactoryBundledWithBinaryReader reader,
			DebugDirectory debugDir, OffsetValidator validator) throws IOException {
		int ptr = debugDir.getPointerToRawData();
		if (!validator.checkPointer(ptr)) {
			Msg.error(this, "Invalid pointer " + Long.toHexString(ptr));
			return;
		}

		numberOfSymbols = reader.readInt(ptr);
		ptr += BinaryReader.SIZEOF_INT;
		lvaToFirstSymbol = reader.readInt(ptr);
		ptr += BinaryReader.SIZEOF_INT;
		numberOfLinenumbers = reader.readInt(ptr);
		ptr += BinaryReader.SIZEOF_INT;
		lvaToFirstLinenumber = reader.readInt(ptr);
		ptr += BinaryReader.SIZEOF_INT;
		rvaToFirstByteOfCode = reader.readInt(ptr);
		ptr += BinaryReader.SIZEOF_INT;
		rvaToLastByteOfCode = reader.readInt(ptr);
		ptr += BinaryReader.SIZEOF_INT;
		rvaToFirstByteOfData = reader.readInt(ptr);
		ptr += BinaryReader.SIZEOF_INT;
		rvaToLastByteOfData = reader.readInt(ptr);
		ptr += BinaryReader.SIZEOF_INT;

		if (numberOfLinenumbers > 0 && numberOfLinenumbers < NTHeader.MAX_SANE_COUNT) {
			lineNumbers = new DebugCOFFLineNumber[numberOfLinenumbers];
			for (int i = 0; i < numberOfLinenumbers; ++i) {
				lineNumbers[i] = DebugCOFFLineNumber.createDebugCOFFLineNumber(reader, ptr);
				ptr += DebugCOFFLineNumber.IMAGE_SIZEOF_LINENUMBER;
			}
		}

		symbolTable =
			DebugCOFFSymbolTable.createDebugCOFFSymbolTable(reader, this,
				debugDir.getPointerToRawData());
	}

	/**
	 * Returns the COFF symbol table.
	 * @return the COFF symbol table
	 */
	public DebugCOFFSymbolTable getSymbolTable() {
		return symbolTable;
	}

	/**
	 * Returns the COFF line numbers.
	 * @return the COFF line numbers
	 */
	public DebugCOFFLineNumber[] getLineNumbers() {
		return lineNumbers;
	}

	/**
	 * Returns the number of symbols in this header.
	 * @return the number of symbols in this header
	 */
	public int getNumberOfSymbols() {
		return numberOfSymbols;
	}

	/**
	 * Returns the LVA of the first symbol.
	 * @return the LVA of the first symbol
	 */
	public int getFirstSymbolLVA() {
		return lvaToFirstSymbol;
	}

	/**
	 * Returns the number of line numbers in this header.
	 * @return the number of line numbers in this header
	 */
	public int getNumberOfLinenumbers() {
		return numberOfLinenumbers;
	}

	/**
	 * Returns the LVA of the first line number.
	 * @return the LVA of the first line number
	 */
	public int getFirstLinenumberLVA() {
		return lvaToFirstLinenumber;
	}

	/**
	 * Returns the RVA of the first code byte.
	 * @return the RVA of the first code byte
	 */
	public int getFirstByteOfCodeRVA() {
		return rvaToFirstByteOfCode;
	}

	/**
	 * Returns the RVA of the last code byte.
	 * @return the RVA of the last code byte
	 */
	public int getLastByteOfCodeRVA() {
		return rvaToLastByteOfCode;
	}

	/**
	 * Returns the RVA of the first data byte.
	 * @return the RVA of the first data byte
	 */
	public int getFirstByteOfDataRVA() {
		return rvaToFirstByteOfData;
	}

	/**
	 * Returns the RVA of the last data byte.
	 * @return the RVA of the last data byte
	 */
	public int getLastByteOfDataRVA() {
		return rvaToLastByteOfData;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/DebugCodeView.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.StructConverter;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.app.util.bin.format.pdb.PdbInfoCodeView;
import ghidra.app.util.bin.format.pdb.PdbInfoDotNet;
import net.jubjubnest.minidump.contrib.pe.OffsetValidator;
import net.jubjubnest.minidump.contrib.pe.PortableExecutable.SectionLayout;
import ghidra.program.model.data.ArrayDataType;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.Structure;
import ghidra.program.model.data.StructureDataType;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;

import java.io.IOException;

/**
 * A class to represent the code view debug information.
 */
public class DebugCodeView implements StructConverter {
	private DebugDirectory debugDir;
	private DebugCodeViewSymbolTable symbolTable;
	private PdbInfoCodeView pdbInfo;
	private PdbInfoDotNet dotNetPdbInfo;

	/**
	 * Constructor.
	 * @param reader the binary reader
	 * @param debugDir the code view debug directory
	 * @param ntHeader 
	 */
	static DebugCodeView createDebugCodeView(FactoryBundledWithBinaryReader reader,
			SectionLayout layout, DebugDirectory debugDir, OffsetValidator validator) throws IOException {
		DebugCodeView debugCodeView =
			(DebugCodeView) reader.getFactory().create(DebugCodeView.class);
		debugCodeView.initDebugCodeView(reader, layout, debugDir, validator);
		return debugCodeView;
	}

	/**
	 * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
	 */
	public DebugCodeView() {
	}

	private void initDebugCodeView(FactoryBundledWithBinaryReader reader, SectionLayout layout, DebugDirectory debugDir,
			OffsetValidator validator) throws IOException {
		this.debugDir = debugDir;

		int ptr = debugDir.getPointerToRawData();
		if (layout == SectionLayout.MEMORY) {
			ptr = debugDir.getAddressOfRawData();
		}
		if (!validator.checkPointer(ptr)) {
			Msg.error(this, "Invalid pointer " + Long.toHexString(ptr));
			return;
		}

		dotNetPdbInfo = PdbInfoDotNet.isMatch(reader, ptr) ? PdbInfoDotNet.read(reader, ptr) : null;
		pdbInfo = PdbInfoCodeView.isMatch(reader, ptr) ? PdbInfoCodeView.read(reader, ptr) : null;
		if (DebugCodeViewSymbolTable.isMatch(reader, ptr)) {
			symbolTable =
				DebugCodeViewSymbolTable.createDebugCodeViewSymbolTable(reader,
					debugDir.getSizeOfData(), debugDir.getPointerToRawData(), ptr);
		}
		else {
			//TODO??
//            Err.warn(this, null, "Warning", "Unhandled CodeView Information Format: "+
//			                        Integer.toHexString(reader.readShort(ptr+0)&0xffff)+
//			                        " "+
//			                        Integer.toHexString(reader.readShort(ptr+1)&0xffff));
		}
	}

	/**
	 * Returns the code view debug directory.
	 * @return the code view debug directory
	 */
	public DebugDirectory getDebugDirectory() {
		return debugDir;
	}

	/**
	 * Returns the code view symbol table.
	 * @return the code view symbol table
	 */
	public DebugCodeViewSymbolTable getSymbolTable() {
		return symbolTable;
	}

	/**
	 * Returns the code view .PDB info.
	 * @return the code view .PDB info
	 */
	public PdbInfoCodeView getPdbInfo() {
		return pdbInfo;
	}

	public PdbInfoDotNet getDotNetPdbInfo() {
		return dotNetPdbInfo;
	}

	/**
	 * @see ghidra.app.util.bin.StructConverter#toDataType()
	 */
	public DataType toDataType() throws DuplicateNameException {
		Structure es = new StructureDataType("DebugCodeView", 0);
		es.add(WORD, "Signature", null);
		es.add(WORD, "Version", null);
		if (symbolTable != null) {
			DataType dt = symbolTable.toDataType();
			es.add(dt, "CodeViewSymbolTable", null);
		}
		else {
			DataType dt = new ArrayDataType(BYTE, debugDir.getSizeOfData() - 4, 1);
			es.add(dt, "<<unknown>>", null);
		}
		es.setCategoryPath(new CategoryPath("/PE"));
		return es;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/DebugCodeViewConstants.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

/**
 * Constants defined in Code View Debug information.
 */
public interface DebugCodeViewConstants {
	/*
	 * * * * * * * * * * * * * * * * * * * *
	 */

	public final static int SIGNATURE_DOT_NET = 0x5253; //RS
	public final static int SIGNATURE_N1      = 0x4e31; //N1
	public final static int SIGNATURE_NB      = 0x4e42; //NB

	public final static int VERSION_09        = 0x3039; //09
	public final static int VERSION_10        = 0x3130; //10
	public final static int VERSION_11        = 0x3131; //11
	public final static int VERSION_12        = 0x3140; //12
	public final static int VERSION_13        = 0x30f0; //13
	public final static int VERSION_DOT_NET   = 0x4453; //DS

	/*
	 * * * * * * * * * * * * * * * * * * * *
	 */

	public final static int sstModule           = 0x120;
	public final static int sstTypes            = 0x121;
	public final static int sstPublic           = 0x122;
	/**publics as symbol (waiting for link)*/
	public final static int sstPublicSym        = 0x123;
	public final static int sstSymbols          = 0x124;
	public final static int sstAlignSym         = 0x125;
	/**because link doesn't emit SrcModule*/
	public final static int sstSrcLnSeg         = 0x126;
	public final static int sstSrcModule        = 0x127;
	public final static int sstLibraries        = 0x128;
	public final static int sstGlobalSym        = 0x129;
	public final static int sstGlobalPub        = 0x12a;
	public final static int sstGlobalTypes      = 0x12b;
	public final static int sstMPC              = 0x12c;
	public final static int sstSegMap           = 0x12d;
	public final static int sstSegName          = 0x12e;
	/**precompiled types*/
	public final static int sstPreComp          = 0x12f;
	/**map precompiled types in global types*/
	public final static int sstPreCompMap       = 0x130;
	public final static int sstOffsetMap16      = 0x131;
	public final static int sstOffsetMap32      = 0x132;
	/**Index of file names*/
	public final static int sstFileIndex        = 0x133;
	public final static int sstStaticSym        = 0x134;

	/**Compile flags symbol*/
	public final static int S_COMPILE    =  0x0001;
	/**Register variable*/
	public final static int S_REGISTER   =  0x0002;
	/**Constant symbol*/
	public final static int S_CONSTANT   =  0x0003;
	/**User defined type*/
	public final static int S_UDT        =  0x0004;
	/**Start Search*/
	public final static int S_SSEARCH    =  0x0005;
	/**Block, procedure, "with" or thunk end*/
	public final static int S_END        =  0x0006;
	/**Reserve symbol space in $$Symbols table*/
	public final static int S_SKIP       =  0x0007;
	/**Reserved symbol for CV internal use*/
	public final static int S_CVRESERVE  =  0x0008;
	/**Path to object file name*/
	public final static int S_OBJNAME    =  0x0009;
	/**End of argument/return list*/
	public final static int S_ENDARG     =  0x000a;
	/**SApecial UDT for cobol that does not symbol pack*/
	public final static int S_COBOLUDT   =  0x000b;
	/**multiple register variable*/
	public final static int S_MANYREG    =  0x000c;
	/**Return description symbol*/
	public final static int S_RETURN     =  0x000d;
	/**Description of this pointer on entry*/
	public final static int S_ENTRYTHIS  =  0x000e;

	/**BP-relative*/
	public final static int S_BPREL16    =  0x0100;
	/**Module-local symbol*/
	public final static int S_LDATA16    =  0x0101;
	/**Global data symbol*/
	public final static int S_GDATA16    =  0x0102;
	/**a public symbol*/
	public final static int S_PUB16      =  0x0103;
	/**Local procedure start*/
	public final static int S_LPROC16    =  0x0104;
	/**Global procedure start*/
	public final static int S_GPROC16    =  0x0105;
	/**Thunk Start*/
	public final static int S_THUNK16    =  0x0106;
	/**block start*/
	public final static int S_BLOCK16    =  0x0107;
	/**With start*/
	public final static int S_WITH16     =  0x0108;
	/**Code label*/
	public final static int S_LABEL16    =  0x0109;
	/**Change execution model*/
	public final static int S_CEXMODEL16 =  0x010a;
	/**Address of virtual function table*/
	public final static int S_VFTABLE16  =  0x010b;
	/**Register relative address*/
	public final static int S_REGREL16   =  0x010c;

	/**BP-relative*/
	public final static int S_BPREL32    =  0x0200;
	/**Module-local symbol*/
	public final static int S_LDATA32    =  0x0201;
	/**Global data symbol*/
	public final static int S_GDATA32    =  0x0202;
	/**a public symbol (CV internal reserved)*/
	public final static int S_PUB32      =  0x0203;
	/**Local procedure start*/
	public final static int S_LPROC32    =  0x0204;
	/**Global procedure start*/
	public final static int S_GPROC32    =  0x0205;
	/**Thunk Start*/
	public final static int S_THUNK32    =  0x0206;
	/**block start*/
	public final static int S_BLOCK32    =  0x0207;
	/**with start*/
	public final static int S_WITH32     =  0x0208;
	/**code label*/
	public final static int S_LABEL32    =  0x0209;
	/**change execution model*/
	public final static int S_CEXMODEL32 =  0x020a;
	/**address of virtual function table*/
	public final static int S_VFTABLE32  =  0x020b;
	/**register relative address*/
	public final static int S_REGREL32   =  0x020c;
	/**local thread storage*/
	public final static int S_LTHREAD32  =  0x020d;
	/**global thread storage*/
	public final static int S_GTHREAD32  =  0x020e;
	/**static link for MIPS EH implementation*/
	public final static int S_SLINK32    =  0x020f;

	/**Local procedure start*/
	public final static int S_LPROCMIPS  =  0x0300;
	/**Global procedure start*/
	public final static int S_GPROCMIPS  =  0x0301;

	/**Reference to a procedure*/
	public final static int S_PROCREF    =  0x0400;
	/**Reference to data*/
	public final static int S_DATAREF    =  0x0401;
	/**Used for page alignment of symbol*/
	public final static int S_ALIGN      =  0x0402;
	/**Maybe reference to a local procedure*/
	public final static int S_LPROCREF   =  0x0403;

	/**Register variable*/
	public final static int S_REGISTER32    = 0x1001;
	/**Constant symbol*/
	public final static int S_CONSTANT32    = 0x1002;
	/**User defined type*/
	public final static int S_UDT32         = 0x1003;
	/**special UDT for cobol that does not symbol pack*/
	public final static int S_COBOLUDT32    = 0x1004;
	/**Multiple register variable*/
	public final static int S_MANYREG32     = 0x1005;
	/**New CV info for BP-relative*/
	public final static int S_BPREL32_NEW   = 0x1006;
	/**New CV info for module-local symbol*/
	public final static int S_LDATA32_NEW   = 0x1007;
	/**New CV info for global data symbol*/
	public final static int S_GDATA32_NEW   = 0x1008;
	/**Newer CV info, defined after 1994*/
	public final static int S_PUBSYM32_NEW  = 0x1009;
	/**New CV info for reference to a local procedure*/
	public final static int S_LPROC32_NEW   = 0x100a;
	/**New CV info for global procedure start*/
	public final static int S_GPROC32_NEW   = 0x100b;
	/**New CV info for address of virtual function table*/
	public final static int S_VFTABLE32_NEW = 0x100c;
	/**New CV info for register relative address*/
	public final static int S_REGREL32_NEW  = 0x100d;
	/**New CV info for local thread storage*/
	public final static int S_LTHREAD32_NEW = 0x100e;
	/**New CV info for global thread storage*/
	public final static int S_GTHREAD32_NEW = 0x100f;
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/DebugCodeViewSymbolTable.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;
import ghidra.program.model.data.*;
import ghidra.util.exception.*;

import java.io.*;
import java.util.*;

/**
 * A class to represent the Object Module Format (OMF)
 * code view symbol table.
 */
public class DebugCodeViewSymbolTable implements StructConverter {
	public final static int MAGIC_NB_09 = 
		DebugCodeViewConstants.SIGNATURE_NB << 16 |
		DebugCodeViewConstants.VERSION_09;
	public final static int MAGIC_NB_11 = 
		DebugCodeViewConstants.SIGNATURE_NB << 16 |
		DebugCodeViewConstants.VERSION_11;
	public final static int MAGIC_N1_12 = 
		DebugCodeViewConstants.SIGNATURE_N1 << 16 |
		DebugCodeViewConstants.VERSION_12;
	public final static int MAGIC_N1_13 = 
		DebugCodeViewConstants.SIGNATURE_N1 << 16 |
		DebugCodeViewConstants.VERSION_13;

	public static boolean isMatch(FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
		//read value out as big endian
		int value = reader.readByte(ptr  ) << 24 |
					reader.readByte(ptr+1) << 16 |
					reader.readByte(ptr+2) << 8 |
					reader.readByte(ptr+3);
		return (MAGIC_NB_09 == value) || (MAGIC_NB_11 == value) || 
			   (MAGIC_N1_12 == value) || (MAGIC_N1_13 == value);
	}

    private byte [] magic;
    private int lfoDirectoryPos;
    private int omfDirHeaderPos;
    private OMFDirHeader header;
    private int omfDirEntryPos;

    private ArrayList<OMFDirEntry>    entriesList = new ArrayList<OMFDirEntry>();
    private ArrayList<OMFModule>      modulesList = new ArrayList<OMFModule>();
    private ArrayList<OMFGlobal>      globalsList = new ArrayList<OMFGlobal>();
    private ArrayList<OMFSegMap>      segMapsList = new ArrayList<OMFSegMap>();
    private ArrayList<OMFSrcModule> srcModuleList = new ArrayList<OMFSrcModule>();
    private ArrayList<OMFFileIndex> fileIndexList = new ArrayList<OMFFileIndex>();
    private ArrayList<OMFAlignSym>  alignSymsList = new ArrayList<OMFAlignSym>();

	private OMFLibrary library;

    static DebugCodeViewSymbolTable createDebugCodeViewSymbolTable(
            FactoryBundledWithBinaryReader reader, int size, int base, int ptr)
            throws IOException {
        DebugCodeViewSymbolTable debugCodeViewSymbolTable = (DebugCodeViewSymbolTable) reader.getFactory().create(DebugCodeViewSymbolTable.class);
        debugCodeViewSymbolTable.initDebugCodeViewSymbolTable(reader, size, base, ptr);
        return debugCodeViewSymbolTable;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public DebugCodeViewSymbolTable() {}

    private void initDebugCodeViewSymbolTable(FactoryBundledWithBinaryReader reader, int size, int base, int ptr) throws IOException {
    	magic = reader.readByteArray(ptr, 4); ptr += 4;
        lfoDirectoryPos = reader.readInt(ptr);
        omfDirHeaderPos = base + lfoDirectoryPos;
        header = OMFDirHeader.createOMFDirHeader(reader, omfDirHeaderPos);
        omfDirEntryPos = omfDirHeaderPos + OMFDirHeader.IMAGE_SIZEOF_OMF_DIR_HEADER;

        for (int i = 0 ; i < header.getNumberOfEntries() ; ++i) {
            OMFDirEntry entry = OMFDirEntry.createOMFDirEntry(reader, omfDirEntryPos);
            entriesList.add(entry);
            switch (entry.getSubSectionType()) {
                case DebugCodeViewConstants.sstModule:
                    modulesList.add(OMFModule.createOMFModule(reader, entry.getLargeFileOffset()+base, entry.getNumberOfBytes()));
                    break;
                case DebugCodeViewConstants.sstSegMap:
                    segMapsList.add(OMFSegMap.createOMFSegMap(reader, entry.getLargeFileOffset()+base));
                    break;
                case DebugCodeViewConstants.sstGlobalPub:
				case DebugCodeViewConstants.sstGlobalSym:
				case DebugCodeViewConstants.sstStaticSym:
					globalsList.add(OMFGlobal.createOMFGlobal(reader, entry.getLargeFileOffset()+base));
                    break;
				case DebugCodeViewConstants.sstSrcModule:
					srcModuleList.add(OMFSrcModule.createOMFSrcModule(reader, entry.getLargeFileOffset()+base));
					break;
				case DebugCodeViewConstants.sstFileIndex:
					fileIndexList.add(OMFFileIndex.createOMFFileIndex(reader, entry.getLargeFileOffset()+base));
					break;
				case DebugCodeViewConstants.sstAlignSym:
					alignSymsList.add(OMFAlignSym.createOMFAlignSym(reader, entry.getLargeFileOffset()+base));
					break;
				case DebugCodeViewConstants.sstLibraries:
					library = OMFLibrary.createOMFLibrary(reader, entry.getLargeFileOffset()+base, entry.getNumberOfBytes());
					break;
				case DebugCodeViewConstants.sstGlobalTypes:
					//int type = entry.getLargeFileOffset()+base;
					break;
                default:
					//TODO handle rest of possible types
                    break;
            }
            omfDirEntryPos += OMFDirEntry.IMAGE_SIZEOF_OMF_DIR_ENTRY;
        }
    }

    public byte[] getMagic() {
		return magic;
	}

	public OMFLibrary getOMFLibrary() {
		return library;
	}

	/**
	 * Returns the OMF directory entries.
	 * @return the OMF directory entries
	 */
    public List<OMFDirEntry> getOMFDirectoryEntries() {
        return entriesList;
    }

    /**
     * Returns the OMF modules.
     * @return the OMF modules
     */
    public List<OMFModule> getOMFModules() {
        return modulesList;

    }
    /**
     * Returns the OMF segment maps.
     * @return the OMF segment maps
     */
    public List<OMFSegMap> getOMFSegMaps() {
        return segMapsList;
    }

    /**
     * Returns the OMF globals.
     * @return the OMF globals
     */
    public List<OMFGlobal> getOMFGlobals() {
        return globalsList;
    }

	/**
	 * Returns the OMF Source Modules.
	 * @return the OMF Source Modules
	 */
	public List<OMFSrcModule> getOMFSrcModules() {
		return srcModuleList;
	}

	/**
	 * Returns the OMF Source Files.
	 * @return the OMF Source Files
	 */
	public List<OMFFileIndex> getOMFFiles() {
		return fileIndexList;
	}

	/**
	 * Returns the OMF Align Symbols.
	 * @return the OMF Align Symbols
	 */
	public List<OMFAlignSym> getOMFAlignSym() {
		return alignSymsList;
	}
    /**
     * @see ghidra.app.util.bin.StructConverter#toDataType()
     */
    public DataType toDataType() throws DuplicateNameException {
        return null;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/DebugDirectory.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import java.io.IOException;
import java.io.RandomAccessFile;

import ghidra.app.util.bin.ByteArrayConverter;
import ghidra.app.util.bin.StructConverter;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import net.jubjubnest.minidump.contrib.pe.OffsetValidator;
import ghidra.program.model.data.*;
import ghidra.util.DataConverter;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;

/**
 * A class to represent the Debug Directory data structure.
 * <br>
 * <pre>
 * typedef struct _IMAGE_DEBUG_DIRECTORY {
 *     DWORD   Characteristics;
 *     DWORD   TimeDateStamp;
 *     WORD    MajorVersion;
 *     WORD    MinorVersion;
 *     DWORD   Type;
 *     DWORD   SizeOfData;
 *     DWORD   AddressOfRawData;
 *     DWORD   PointerToRawData;
 * } IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;
 * </pre>
 * <br>
 */
public class DebugDirectory implements StructConverter, ByteArrayConverter {
	/**
	 * The name to use when converting into a structure data type.
	 */
	public final static String NAME = "IMAGE_DEBUG_DIRECTORY";
	/**
	 * The size of the <code>IMAGE_DEBUG_DIRECTORY</code>, in bytes.
	 */
	public final static int IMAGE_SIZEOF_DEBUG_DIRECTORY = 28;

	private int characteristics;
	private int timeDateStamp;
	private short majorVersion;
	private short minorVersion;
	private int type;
	private int sizeOfData;
	private int addressOfRawData;
	private int pointerToRawData;

	private String description;

	private byte[] blobBytes;
	private long index = 0;

	/**
	 * Constuctor.
	 * @param reader the binary reader
	 * @param index the index where this debug directory begins
	 * @param ntHeader 
	 */
	static DebugDirectory createDebugDirectory(FactoryBundledWithBinaryReader reader, long index,
			OffsetValidator validator) throws IOException {
		DebugDirectory debugDirectory =
			(DebugDirectory) reader.getFactory().create(DebugDirectory.class);
		debugDirectory.initDebugDirectory(reader, index, validator);
		return debugDirectory;
	}

	/**
	 * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
	 */
	public DebugDirectory() {
	}

	private void initDebugDirectory(FactoryBundledWithBinaryReader reader, long index,
			OffsetValidator validator) throws IOException {
		long oldIndex = reader.getPointerIndex();
		reader.setPointerIndex(index);

		characteristics = reader.readNextInt();
		timeDateStamp = reader.readNextInt();
		majorVersion = reader.readNextShort();
		minorVersion = reader.readNextShort();
		type = reader.readNextInt();
		sizeOfData = reader.readNextInt();
		addressOfRawData = reader.readNextInt();
		pointerToRawData = reader.readNextInt();

		if (type < 0 || (type > 16 && type != 20) || sizeOfData < 0) {
			Msg.error(this, "Invalid DebugDirectory");
			sizeOfData = 0;
			reader.setPointerIndex(oldIndex);
			return;
		}
		if (sizeOfData > 0) {
			if (!validator.checkPointer(pointerToRawData)) {
				Msg.error(this, "Invalid pointerToRawData " + pointerToRawData);
				sizeOfData = 0;
				reader.setPointerIndex(oldIndex);
				return;
			}
			blobBytes = reader.readByteArray(pointerToRawData, sizeOfData);
		}

		this.index = index;
		reader.setPointerIndex(oldIndex);
	}

	/**
	 * Reserved.
	 * @return reserved value
	 */
	public int getCharacteristics() {
		return characteristics;
	}

	/**
	 * Returns the time and date the debugging information was created. 
	 * @return the time and date the debugging information was created
	 */
	public int getTimeDateStamp() {
		return timeDateStamp;
	}

	/**
	 * Returns the major version number of the debugging information format.
	 * @return the major version number of the debugging information format
	 */
	public int getMajorVersion() {
		return majorVersion;
	}

	/**
	 * Returns the minor version number of the debugging information format.
	 * @return the minor version number of the debugging information format
	 */
	public int getMinorVersion() {
		return minorVersion;
	}

	/**
	 * Returns the format of the debugging information.
	 * @return the format of the debugging information
	 */
	public int getType() {
		return type;
	}

	/**
	 * Returns the size of the debugging information, in bytes. 
	 * This value does not include the debug directory itself.
	 * @return the size of the debugging information, in bytes
	 */
	public int getSizeOfData() {
		return sizeOfData;
	}

	/**
	 * Returns the address of the debugging information when the image is loaded, relative to the image base.
	 * @return the address of the debugging information when the image is loaded, relative to the image base
	 */
	public int getAddressOfRawData() {
		return addressOfRawData;
	}

	/**
	 * Returns the file pointer to the debugging information.
	 * @return the file pointer to the debugging information
	 */
	public int getPointerToRawData() {
		return pointerToRawData;
	}

	/**
	 * Returns a description of this debug directory.
	 * @return a description of this debug directory
	 */
	public String getDescription() {
		return description;
	}

	/**
	 * Sets the description of this debug directory.
	 * @param desc the description of this debug directory
	 */
	public void setDescription(String desc) {
		this.description = desc;
	}

	/**
	 * @see ghidra.app.util.bin.StructConverter#toDataType()
	 */
	@Override
	public DataType toDataType() throws DuplicateNameException {
		StructureDataType struct = new StructureDataType(NAME, 0);
		struct.add(DWORD, "Characteristics", null);
		struct.add(DWORD, "TimeDateStamp", null);
		struct.add(WORD, "MajorVersion", null);
		struct.add(WORD, "MinorVersion", null);
		struct.add(DWORD, "Type", null);
		struct.add(DWORD, "SizeOfData", null);
		struct.add(DWORD, "AddressOfRawData", null);
		struct.add(DWORD, "PointerToRawData", null);
		struct.setCategoryPath(new CategoryPath("/PE"));
		return struct;
	}

	public void writeHeader(RandomAccessFile raf, DataConverter dc) throws IOException {
		//TODO: This is no longer correct
		raf.seek(index);
		raf.write(dc.getBytes(characteristics));
		raf.write(dc.getBytes(timeDateStamp));
		raf.write(dc.getBytes(majorVersion));
		raf.write(dc.getBytes(minorVersion));
		raf.write(dc.getBytes(type));
		raf.write(dc.getBytes(sizeOfData));
		raf.write(dc.getBytes(addressOfRawData));
		raf.write(dc.getBytes(pointerToRawData));
	}

	@Override
	public byte[] toBytes(DataConverter dc) {
		if (blobBytes == null) {
			return new byte[0];
		}
		return blobBytes;
	}

	public void updatePointers(int offset, int postOffset) {
		Msg.debug(this, index + "+" + offset + " " + pointerToRawData + "+" + postOffset);
		index += offset;
		pointerToRawData += postOffset;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/DebugDirectoryParser.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import net.jubjubnest.minidump.contrib.pe.OffsetValidator;
import net.jubjubnest.minidump.contrib.pe.PortableExecutable.SectionLayout;

import java.io.IOException;
import java.util.ArrayList;

/**
 * A helper class to parsing different types of 
 * debug information from a debug directory
 */
public class DebugDirectoryParser {

	/**
	 * Unknown debug type.
	 */
	public final static byte IMAGE_DEBUG_TYPE_UNKNOWN = 0;
	/**
	 * COFF debug type.
	 */
	public final static byte IMAGE_DEBUG_TYPE_COFF = 1;
	/**
	 * CodeView debug type.
	 */
	public final static byte IMAGE_DEBUG_TYPE_CODEVIEW = 2;
	/**
	 * FPO debug type.
	 */
	public final static byte IMAGE_DEBUG_TYPE_FPO = 3;
	/**
	 * Misc debug type.
	 */
	public final static byte IMAGE_DEBUG_TYPE_MISC = 4;
	/**
	 * Exception debug type.
	 */
	public final static byte IMAGE_DEBUG_TYPE_EXCEPTION = 5;
	/**
	 * Fixup debug type.
	 */
	public final static byte IMAGE_DEBUG_TYPE_FIXUP = 6;
	/**
	 * OMAP-To-Source debug type.
	 */
	public final static byte IMAGE_DEBUG_TYPE_OMAP_TO_SRC = 7;
	/**
	 * OMAP-From-Source debug type.
	 */
	public final static byte IMAGE_DEBUG_TYPE_OMAP_FROM_SRC = 8;
	/**
	 * Borland debug type.
	 */
	public final static byte IMAGE_DEBUG_TYPE_BORLAND = 9;
	/**
	 * Reserved debug type.
	 */
	public final static byte IMAGE_DEBUG_TYPE_RESERVED10 = 10;
	/**
	 * CLS ID debug type.
	 */
	public final static byte IMAGE_DEBUG_TYPE_CLSID = 11;

	private ArrayList<DebugDirectory> debugFormatList = new ArrayList<DebugDirectory>();
	private DebugMisc miscDebug;
	private DebugCodeView codeViewDebug;
	private DebugCOFFSymbolsHeader coffDebug;
	private DebugFixup fixupDebug;

	/**
	 * Constructs a new debug directory parser.
	 * @param reader the binary reader
	 * @param ptr the pointer into the binary reader
	 * @param size the size of the directory
	 * @param validator the validator for the directory
	 * @throws IOException if an I/O error occurs
	 */
	public static DebugDirectoryParser createDebugDirectoryParser(SectionLayout layout,
			FactoryBundledWithBinaryReader reader, long ptr, int size, OffsetValidator validator)
			throws IOException {
		DebugDirectoryParser debugDirectoryParser =
			(DebugDirectoryParser) reader.getFactory().create(DebugDirectoryParser.class);
		debugDirectoryParser.initDebugDirectoryParser(layout, reader, ptr, size, validator);
		return debugDirectoryParser;
	}

	/**
	 * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
	 */
	public DebugDirectoryParser() {
	}

	private void initDebugDirectoryParser(SectionLayout layout, FactoryBundledWithBinaryReader reader,
			long ptr, int size, OffsetValidator validator) throws IOException {
		int debugFormatsCount = size / DebugDirectory.IMAGE_SIZEOF_DEBUG_DIRECTORY;

		for (int i = 0; i < debugFormatsCount; ++i) {
			DebugDirectory debugDir = DebugDirectory.createDebugDirectory(reader, ptr, validator);
			if (debugDir.getSizeOfData() == 0)
				break;

			ptr += DebugDirectory.IMAGE_SIZEOF_DEBUG_DIRECTORY;

			switch (debugDir.getType()) {
				case IMAGE_DEBUG_TYPE_CLSID:
					debugDir.setDescription("CLSID");
					break;
				case IMAGE_DEBUG_TYPE_RESERVED10:
					debugDir.setDescription("Reserved");
					break;
				case IMAGE_DEBUG_TYPE_BORLAND:
					debugDir.setDescription("Borland");
					break;
				case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:
					debugDir.setDescription("OMAPfromSrc");
					break;
				case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
					debugDir.setDescription("OMAPtoSrc");
					break;
				case IMAGE_DEBUG_TYPE_FIXUP:
					debugDir.setDescription("Fixup");
					fixupDebug = DebugFixup.createDebugFixup(reader, debugDir, validator);
					break;
				case IMAGE_DEBUG_TYPE_EXCEPTION:
					debugDir.setDescription("Exception");
					break;
				case IMAGE_DEBUG_TYPE_MISC:
					debugDir.setDescription("Misc");
					miscDebug = DebugMisc.createDebugMisc(reader, debugDir, validator);
					break;
				case IMAGE_DEBUG_TYPE_FPO:
					debugDir.setDescription("FPO");
					break;
				case IMAGE_DEBUG_TYPE_CODEVIEW:
					debugDir.setDescription("CodeView");
					codeViewDebug = DebugCodeView.createDebugCodeView(reader, layout, debugDir, validator);
					break;
				case IMAGE_DEBUG_TYPE_COFF:
					debugDir.setDescription("COFF");
					coffDebug =
						DebugCOFFSymbolsHeader.createDebugCOFFSymbolsHeader(reader, debugDir,
							validator);
					break;
				case IMAGE_DEBUG_TYPE_UNKNOWN:
					debugDir.setDescription("Unknown");
					break;
				default:
					debugDir.setDescription("DebugType-" + debugDir.getType());
					break;
			}
			debugFormatList.add(debugDir);
		}
	}

	public DebugDirectory[] getDebugDirectories() {
		DebugDirectory[] ddArr = new DebugDirectory[debugFormatList.size()];
		debugFormatList.toArray(ddArr);
		return ddArr;
	}

	/**
	 * Returns the miscellaneous debug information, or null if it does not exists.
	 * @return the miscellaneous debug information
	 */
	public DebugMisc getDebugMisc() {
		return miscDebug;
	}

	/**
	 * Returns the CodeView debug information, or null if it does not exists.
	 * @return the CodeView debug information
	 */
	public DebugCodeView getDebugCodeView() {
		return codeViewDebug;
	}

	/**
	 * Returns the COFF debug information, or null if it does not exists.
	 * @return the COFF debug information
	 */
	public DebugCOFFSymbolsHeader getDebugCOFFSymbolsHeader() {
		return coffDebug;
	}

	/**
	 * Returns the Fixup debug information, or null if it does not exists.
	 * @return the Fixup debug information
	 */
	public DebugFixup getDebugFixup() {
		return fixupDebug;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/DebugFixup.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import net.jubjubnest.minidump.contrib.pe.OffsetValidator;
import ghidra.util.Msg;

import java.io.IOException;
import java.util.ArrayList;

/**
 * A possible implementation of the FIXUP debug directory. 
 * It may be inaccurate and/or incomplete.
 */
public class DebugFixup {
	private DebugFixupElement[] elements;

	/**
	 * Constructor
	 * @param reader the binary reader
	 * @param debugDir the debug directory associated to this FIXUP
	 * @param ntHeader 
	 */
	static DebugFixup createDebugFixup(FactoryBundledWithBinaryReader reader,
			DebugDirectory debugDir, OffsetValidator validator) throws IOException {
		DebugFixup debugFixup = (DebugFixup) reader.getFactory().create(DebugFixup.class);
		debugFixup.initDebugFixup(reader, debugDir, validator);
		return debugFixup;
	}

	/**
	 * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
	 */
	public DebugFixup() {
	}

	private void initDebugFixup(FactoryBundledWithBinaryReader reader, DebugDirectory debugDir,
			OffsetValidator validator) throws IOException {
		int ptr = debugDir.getPointerToRawData();
		if (!validator.checkPointer(ptr)) {
			Msg.error(this, "Invalid pointer " + Long.toHexString(ptr));
			return;
		}
		int size = debugDir.getSizeOfData();

		ArrayList<DebugFixupElement> list = new ArrayList<DebugFixupElement>();

		while (size > 0) {
			list.add(DebugFixupElement.createDebugFixupElement(reader, ptr));
			ptr += DebugFixupElement.SIZEOF;
			size -= DebugFixupElement.SIZEOF;
		}

		elements = new DebugFixupElement[list.size()];
		list.toArray(elements);
	}

	/**
	 * Returns the array of FIXUP elements associated with this fixup debug directory.
	 * @return the array of FIXUP elements associated with this fixup debug directory
	 */
	public DebugFixupElement[] getDebugFixupElements() {
		return elements;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/DebugFixupElement.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.format.*;

/**
 * A possible implementation of the FIXUP debug directory elements. 
 * It may be inaccurate and/or incomplete.
 * 
 * 
 */
public class DebugFixupElement {
    final static int SIZEOF = 12;

    private int type;
    private int addr1;
    private int addr2;

    static DebugFixupElement createDebugFixupElement(
            FactoryBundledWithBinaryReader reader, int index)
            throws IOException {
        DebugFixupElement debugFixupElement = (DebugFixupElement) reader.getFactory().create(DebugFixupElement.class);
        debugFixupElement.initDebugFixupElement(reader, index);
        return debugFixupElement;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public DebugFixupElement() {}

    private void initDebugFixupElement(FactoryBundledWithBinaryReader reader, int index) throws IOException {
        type  = reader.readInt(index); index += BinaryReader.SIZEOF_INT;
        addr1 = reader.readInt(index); index += BinaryReader.SIZEOF_INT;
        addr2 = reader.readInt(index); index += BinaryReader.SIZEOF_INT;
    }

	/**
	 * Returns the FIXUP element type.
	 * @return the FIXUP element type
	 */
    public int getType() {
        return type;
    }
    /**
     * Returns the first address of this FIXUP element.
     * @return the first address of this FIXUP element
     */
    public int getAddress1() {
        return addr1;
    }
	/**
	 * Returns the second address of this FIXUP element.
	 * @return the second address of this FIXUP element
	 */
    public int getAddress2() {
        return addr2;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/DebugMisc.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import java.io.IOException;

import ghidra.app.util.bin.StructConverter;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import net.jubjubnest.minidump.contrib.pe.OffsetValidator;
import ghidra.program.model.data.*;
import ghidra.util.Conv;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;

/**
 * A class to represent the <code>IMAGE_DEBUG_MISC</code> struct
 * as defined in <b><code>winnt.h</code></b>.
 * <br>
 * 
 * <pre>
 * typedef struct _IMAGE_DEBUG_MISC {
 *     DWORD       DataType;               // type of misc data, see defines
 *     DWORD       Length;                 // total length of record, rounded to four
 *                                         // byte multiple.
 *     BOOLEAN     Unicode;                // TRUE if data is unicode string
 *     BYTE        Reserved[ 3 ];
 *     BYTE        Data[ 1 ];              // Actual data
 * }
 * </pre>
 */
public class DebugMisc implements StructConverter {
	/**
	 * The name to use when converting into a structure data type.
	 */
	public final static String NAME = "IMAGE_DEBUG_MISC";

	private final static byte IMAGE_DEBUG_MISC_EXENAME = 1;

	private DebugDirectory debugDir;
	private int dataType;
	private int length;
	private boolean unicode;
	private byte[] reserved;
	private String actualData;

	/**
	 * Constructor
	 * @param reader the binary reader
	 * @param debugDir the debug directory associated to this MISC debug
	 * @param ntHeader 
	 */
	static DebugMisc createDebugMisc(FactoryBundledWithBinaryReader reader,
			DebugDirectory debugDir, OffsetValidator validator) throws IOException {
		DebugMisc debugMisc = (DebugMisc) reader.getFactory().create(DebugMisc.class);
		debugMisc.initDebugMisc(reader, debugDir, validator);
		return debugMisc;
	}

	/**
	 * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
	 */
	public DebugMisc() {
	}

	private void initDebugMisc(FactoryBundledWithBinaryReader reader, DebugDirectory debugDir,
			OffsetValidator validator) throws IOException {
		this.debugDir = debugDir;

		long oldIndex = reader.getPointerIndex();

		long index = debugDir.getPointerToRawData() & Conv.INT_MASK;
		if (!validator.checkPointer(index)) {
			Msg.error(this, "Invalid file index " + Long.toHexString(index));
			return;
		}
		reader.setPointerIndex(index);

		dataType = reader.readNextInt();
		length = reader.readNextInt();
		unicode = reader.readNextByte() == 1;
		reserved = reader.readNextByteArray(3);
		if (length > 0) {
			actualData =
				(unicode ? reader.readNextUnicodeString(length) : reader.readNextAsciiString());
		}
		else {
			Msg.error(this, "Bad string length " + Integer.toHexString(length));
		}

		reader.setPointerIndex(oldIndex);
	}

	/**
	 * Returns the data type of this misc debug.
	 * @return the data type of this misc debug
	 */
	public int getDataType() {
		return dataType;
	}

	/**
	 * Returns the length of this misc debug.
	 * @return the length of this misc debug
	 */
	public int getLength() {
		return length;
	}

	/**
	 * Returns true if this misc debug is unicode.
	 * @return true if this misc debug is unicode
	 */
	public boolean isUnicode() {
		return unicode;
	}

	/**
	 * Returns the array of reserved bytes.
	 * @return the array of reserved bytes
	 */
	public byte[] getReserved() {
		return reserved;
	}

	/**
	 * Returns a string equivalent of the actual misc debug data.
	 * @return a string equivalent of the actual misc debug data
	 */
	public String getActualData() {
		return actualData;
	}

	/**
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		if (getDataType() == DebugMisc.IMAGE_DEBUG_MISC_EXENAME) {
			return "Misc Debug Information: " + getActualData();
		}
		return "Unknown Misc Debug Information Type: " + getDataType();
	}

	/**
	 * Returns the debug directory associated with this misc debug.
	 * @return the debug directory associated with this misc debug
	 */
	public DebugDirectory getDebugDirectory() {
		return debugDir;
	}

	/**
	 * @see ghidra.app.util.bin.StructConverter#toDataType()
	 */
	public DataType toDataType() throws DuplicateNameException {

		StructureDataType struct = new StructureDataType(NAME, 0);

		struct.add(DWORD, "DataType", "type of misc data, see defines");
		struct.add(DWORD, "Length", "total length of record, rounded to four byte multiple");
		struct.add(BYTE, "Unicode", "TRUE if data is unicode string");
		struct.add(new ArrayDataType(BYTE, 3, 1), "Reserved[3]", null);
		if (isUnicode()) {
			struct.add(new UnicodeDataType(), length - 12, "Data[]", "Actual data");
		}
		else {
			struct.add(new StringDataType(), length - 12, "Data[]", "Actual data");
		}

		return struct;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/DebugSymbol.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

/**
 * A base class for Object Module Format (OMF) symbols.
 * 
 */
public abstract class DebugSymbol {
	protected short  length;
	protected short  type;
	protected String name;
	protected short  section;
	protected int    offset;

	protected DebugSymbol() { }

	protected void processDebugSymbol(short length, short type) {
		this.length = length;
		this.type   = type;
	}

	/**
	 * Returns the length of the symbol.
	 * @return the length of the symbol
	 */
	public short getLength() {
		return length;
	}

	/**
	 * Returns the type of the symbol.
	 * @return the type of the symbol
	 */
	public short getType() {
		return type;
	}

    /**
     * Returns the name of the symbol.
     * @return the name of the symbol
     */
    public String getName() {
    	return name;
    }

    /**
     * Returns the section number.
     * @return the section number
     */
    public short getSection() {
    	return section;
    }

    /**
     * Returns the offset.
     * @return the offset
     */
    public int getOffset() {
    	return offset;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/DebugSymbolSelector.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.format.*;

/**
 * 
 */
public class DebugSymbolSelector {

	public static DebugSymbol selectSymbol(FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
		short length = reader.readShort(ptr); ptr+=BinaryReader.SIZEOF_SHORT;
		short type   = reader.readShort(ptr); ptr+=BinaryReader.SIZEOF_SHORT;

		if (length == 0 || type < 0) {
			return null;
		}

		switch (type) {
			case DebugCodeViewConstants.S_LDATA32:
			case DebugCodeViewConstants.S_GDATA32:
			case DebugCodeViewConstants.S_PUB32:
				return DataSym32.createDataSym32(length, type, reader, ptr);                   

			case DebugCodeViewConstants.S_PUBSYM32_NEW:
				return DataSym32_new.createDataSym32_new(length, type, reader, ptr);

			case DebugCodeViewConstants.S_PROCREF:
			case DebugCodeViewConstants.S_LPROCREF:
				return S_PROCREF.createS_PROCREF(length, type, reader, ptr);

			case DebugCodeViewConstants.S_DATAREF:
				return S_DATAREF.createS_DATAREF(length, type, reader, ptr);

			case DebugCodeViewConstants.S_ALIGN:
				return S_ALIGN.createS_ALIGN(length, type, reader, ptr);

			case DebugCodeViewConstants.S_UDT32:
				return S_UDT32_NEW.createS_UDT32_NEW(length, type, reader, ptr);

			case DebugCodeViewConstants.S_LDATA32_NEW:
				return S_LDATA32_NEW.createS_LDATA32_NEW(length, type, reader, ptr);

			case DebugCodeViewConstants.S_LPROC32_NEW:
			case DebugCodeViewConstants.S_GPROC32_NEW:
				return S_GPROC32_NEW.createS_GPROC32_NEW(length, type, reader, ptr);

			case DebugCodeViewConstants.S_BPREL32_NEW:
				return S_BPREL32_NEW.createS_BPREL32_NEW(length, type, reader, ptr);

			case DebugCodeViewConstants.S_END:
				return S_END.createS_END(length, type, reader, ptr);

			case DebugCodeViewConstants.S_BLOCK32:
				return S_BLOCK32.createS_BLOCK32(length, type);

			case DebugCodeViewConstants.S_COMPILE:
				return S_COMPILE.createS_COMPILE(length, type);

			case DebugCodeViewConstants.S_OBJNAME:
				return S_OBJNAME.createS_OBJNAME(length, type, reader, ptr);

			case DebugCodeViewConstants.S_CONSTANT32:
				return S_CONSTANT32.createS_CONSTANT32(length, type, reader, ptr);

			case DebugCodeViewConstants.S_GDATA32_NEW:
				return S_GDATA32_NEW.createS_GDATA32_NEW(length, type, reader, ptr);
			
			case DebugCodeViewConstants.S_LABEL32:
				return S_LABEL32.createS_LABEL32(length, type, reader, ptr);
			
			default:
				return UnknownSymbol.createUnknownSymbol(length, type, reader, ptr);
		}
	}
}


```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/OMFAlignSym.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;

import java.io.*;

/**
 * A class to represent the Object Module Format (OMF) alignment symbol.
 * 
 */
public class OMFAlignSym {
    private short length;
	private byte [] pad;

    static OMFAlignSym createOMFAlignSym(
            FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
        OMFAlignSym omfAlignSym = (OMFAlignSym) reader.getFactory().create(OMFAlignSym.class);
        omfAlignSym.initOMFAlignSym(reader, ptr);
        return omfAlignSym;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public OMFAlignSym() {}

	private void initOMFAlignSym(FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
		length = reader.readShort(ptr); ptr+=BinaryReader.SIZEOF_SHORT;
		pad = reader.readByteArray(ptr, length);
	}

	/**
	 * Returns the alignment padding bytes.
	 * @return the alignment padding bytes
	 */
	public byte [] getPad() {
		return pad;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/OMFDirEntry.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;

import java.io.*;

/**
 * <pre>
 * typedef struct OMFDirEntry {
 *     unsigned short  SubSection;     // subsection type (sst...)
 *     unsigned short  iMod;           // module index
 *     long            lfo;            // large file offset of subsection
 *     unsigned long   cb;             // number of bytes in subsection
 * };
 * </pre>
 */
class OMFDirEntry {
    final static int IMAGE_SIZEOF_OMF_DIR_ENTRY = 12;

    private short subsection;
    private short imod;
    private int   lfo;
    private int   cb;

    static OMFDirEntry createOMFDirEntry(
            FactoryBundledWithBinaryReader reader, int index)
            throws IOException {
        OMFDirEntry omfDirEntry = (OMFDirEntry) reader.getFactory().create(OMFDirEntry.class);
        omfDirEntry.initOMFDirEntry(reader, index);
        return omfDirEntry;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public OMFDirEntry() {}

    private void initOMFDirEntry(FactoryBundledWithBinaryReader reader, int index) throws IOException {
        subsection = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;
        imod       = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;
        lfo        = reader.readInt  (index); index+=BinaryReader.SIZEOF_INT;
        cb         = reader.readInt  (index); index+=BinaryReader.SIZEOF_INT;
    }

    short getSubSectionType() {
        return subsection;
    }
    short getModuleIndex() {
        return imod;
    }
    int getLargeFileOffset() {
        return lfo;
    }
    int getNumberOfBytes() {
        return cb;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/OMFDirHeader.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;

import java.io.*;

/**
 * <pre>
 * typedef struct OMFDirHeader {
 *     unsigned short cbDirHeader; // length of this structure unsigned           
 *              short cbDirEntry;  // number of bytes in each directory entry 
 *     unsigned long  cDir;        // number of directorie entries 
 *              long lfoNextDir;   // offset from base of next directory 
 *     unsigned long flags;        // status flags
 * } OMFDirHeader;
 * </pre>
 * 
 * 
 */
class OMFDirHeader {
    final static int IMAGE_SIZEOF_OMF_DIR_HEADER = 16;

    private short cbDirHeader;
    private short cbDirEntry;
    private int   cDir;
    private int   lfoNextDir;
    private int   flags;

    static OMFDirHeader createOMFDirHeader(
            FactoryBundledWithBinaryReader reader, int index)
            throws IOException {
        OMFDirHeader omfDirHeader = (OMFDirHeader) reader.getFactory().create(OMFDirHeader.class);
        omfDirHeader.initOMFDirHeader(reader, index);
        return omfDirHeader;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public OMFDirHeader() {}

    private void initOMFDirHeader(FactoryBundledWithBinaryReader reader, int index) throws IOException {
        cbDirHeader = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;
        cbDirEntry  = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;
        cDir        = reader.readInt  (index); index+=BinaryReader.SIZEOF_INT;
        lfoNextDir  = reader.readInt  (index); index+=BinaryReader.SIZEOF_INT;
        flags       = reader.readInt  (index); index+=BinaryReader.SIZEOF_INT;
    }

    int getFlags() {
		return flags;
	}

    short getLengthInBytes() {
        return cbDirHeader;
    }
    short getNumberOfByteInEntries() {
        return cbDirEntry;
    }
    int getNumberOfEntries() {
        return cDir;
    }
    int getBaseOfNextEntry() {
        return lfoNextDir;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/OMFFileIndex.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;
import ghidra.util.*;

import java.io.*;
import java.util.*;

/**
 * A class to represent the Object Module Format (OMF) File Index data structure.
 * <br>
 * <pre>
 * short cMod 		 - Count or number of modules in the executable.
 * short cRef 		 - Count or number of file name references.
 * short [] modStart - array of indices into the nameoffset table for each module.  Each index is the start of the file name references for each module.
 * short cRefCnt 	 - number of file name references per module.
 * int [] nameRef 	 - array of offsets in to the names table.  For each module the offset to the first references file name is at nameRef[modStart] and continues for cRefCnt entries.
 * String names 	 - file names.
 * </pre>
 * 
 * 
 */
public class OMFFileIndex {
    private short cMod;
	private short cRef;
	private short [] modStart;
	private short [] cRefCnt;
	private int [] nameRef;
	private String [] names;

    static OMFFileIndex createOMFFileIndex(
            FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
        OMFFileIndex omfFileIndex = (OMFFileIndex) reader.getFactory().create(OMFFileIndex.class);
        omfFileIndex.initOMFFileIndex(reader, ptr);
        return omfFileIndex;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public OMFFileIndex() {}

	private void initOMFFileIndex(FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
		int index = ptr;

		cMod = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;
		cRef = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;

		modStart = new short[Conv.shortToInt(cMod)];
		for(int i = 0; i < cMod; ++i){
			modStart[i] = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;
		}

		cRefCnt = new short[Conv.shortToInt(cMod)];
		for(int i = 0; i < cMod; i++){
			cRefCnt[i] = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;
		}

		nameRef = new int[Conv.shortToInt(cRef)];
		for(int i = 0; i < cRef; ++i){
			nameRef[i] = reader.readInt(index); index+=BinaryReader.SIZEOF_INT;
		}

		ArrayList<String> namesList = new ArrayList<String>();
		for (int i = 0 ; i < Conv.shortToInt(cRef) ; ++i) {
			int nameIndex = index + nameRef[i];

			byte len = reader.readByte(nameIndex); nameIndex+=BinaryReader.SIZEOF_BYTE;
			int length = Conv.byteToInt(len);

			String name = reader.readAsciiString(nameIndex, length);
			namesList.add(name);
		}
		names = new String[namesList.size()];
		namesList.toArray(names);
	}
	
	/**
	 * Returns the number of modules in the executable.
	 * @return the number of modules in the executable
	 */
	public short getCMod() {
		return cMod;
	}

	/**
	 * Returns the number of file name references in the executable.
	 * @return the number of file name references in the executable
	 */
	public short getCRef() {
		return cRef;
	}

	/**
	 * Returns the array of offsets into the names table.
	 * @return the array of offsets in to the names table
	 */
	public int[] getNameRef() {
		return nameRef;
	}

	/**
	 * Returns the file names referenced in the executable.
	 * @return the file names referenced in the executable
	 */
	public String [] getNames() {
		return names;
	}

	/**
	 * Returns the indices into the nameoffset table for each file.
	 * @return the indices into the nameoffset table for each file
	 */
	public short[] getCRefCnt() {
		return cRefCnt;
	}

	/**
	 * Returns the array of indices into the nameoffset table for each module.
	 * @return the array of indices into the nameoffset table for each module
	 */
	public short[] getModStart() {
		return modStart;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/OMFGlobal.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;
import ghidra.util.*;

import java.io.*;
import java.util.*;

/**
 * A class to represent the Object Module Format (OMF) Global data structure.
 * 
 */
public class OMFGlobal {
    private short symHash;
	private short addrHash;
	private int   cbSymbol;
	private int   cbSymHash;
	private int   cbAddrHash;
	private ArrayList<DebugSymbol> symbols = new ArrayList<DebugSymbol>();

    static OMFGlobal createOMFGlobal(
            FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
        OMFGlobal omfGlobal = (OMFGlobal) reader.getFactory().create(OMFGlobal.class);
        omfGlobal.initOMFGlobal(reader, ptr);
        return omfGlobal;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public OMFGlobal() {}

	private void initOMFGlobal(FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
		symHash    = reader.readShort(ptr); ptr+=BinaryReader.SIZEOF_SHORT;
		addrHash   = reader.readShort(ptr); ptr+=BinaryReader.SIZEOF_SHORT;
		cbSymbol   = reader.readInt  (ptr); ptr+=BinaryReader.SIZEOF_INT;
		cbSymHash  = reader.readInt  (ptr); ptr+=BinaryReader.SIZEOF_INT;
		cbAddrHash = reader.readInt  (ptr); ptr+=BinaryReader.SIZEOF_INT;

		int bytesLeft = cbSymbol;

		while (bytesLeft > 0) {
			DebugSymbol sym = DebugSymbolSelector.selectSymbol(reader, ptr);

			ptr       += 2*BinaryReader.SIZEOF_SHORT;
			bytesLeft -= 2*BinaryReader.SIZEOF_SHORT; 

			if (sym != null) {
				symbols.add(sym);

				int recLen = Conv.shortToInt(sym.getLength());
				bytesLeft -= recLen;
				ptr       += recLen-2;
			}
		}
	}

	public short getAddrHash() {
		return addrHash;
	}
	public int getCbAddrHash() {
		return cbAddrHash;
	}
	public int getCbSymbol() {
		return cbSymbol;
	}
	public int getCbSymHash() {
		return cbSymHash;
	}
	public short getSymHash() {
		return symHash;
	}

	/**
	 * Returns the debug symbols in this OMF Global.
	 * @return the debug symbols in this OMF Global
	 */
	public List<DebugSymbol> getSymbols() {
		return symbols;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/OMFLibrary.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;
import ghidra.util.*;

import java.io.*;
import java.util.*;

/**
 * A class to represent the Object Module Format (OMF) Library data structure.
 * 
 */
public class OMFLibrary {
    private String [] libs;

    static OMFLibrary createOMFLibrary(
            FactoryBundledWithBinaryReader reader, int ptr, int numBytes)
            throws IOException {
        OMFLibrary omfLibrary = (OMFLibrary) reader.getFactory().create(OMFLibrary.class);
        omfLibrary.initOMFLibrary(reader, ptr, numBytes);
        return omfLibrary;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public OMFLibrary() {}

	private void initOMFLibrary(FactoryBundledWithBinaryReader reader, int ptr, int numBytes) throws IOException {
		ArrayList<String> libList = new ArrayList<String>();
		while (numBytes > 0) {
			byte len = reader.readByte(ptr);
				ptr+=BinaryReader.SIZEOF_BYTE;
				numBytes-=BinaryReader.SIZEOF_BYTE;
			int length = Conv.byteToInt(len);
			String lib = reader.readAsciiString(ptr, length);
				ptr+=length;
				numBytes-=length;
			libList.add(lib);
		}
		libs = new String[libList.size()];
		libList.toArray(libs);
	}

	/**
	 * Returns the array of library names.
	 * @return the array of library name
	 */
	public String [] getLibraries() {
		return libs;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/OMFModule.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;

import java.io.*;

/**
 * <pre>
 * typedef struct OMFModule {
 *     unsigned short  ovlNumber;      // overlay number
 *     unsigned short  iLib;           // library that the module was linked from
 *     unsigned short  cSeg;           // count of number of segments in module
 *     char            Style[2];       // debugging style "CV"
 *     OMFSegDesc      SegInfo[1];     // describes segments in module
 *     char            Name[];         // length prefixed module name padded to long word boundary
 * } OMFModule;
 * </pre>
 */
public class OMFModule {
    private short ovlNumber;
    private short iLib;
    private short cSeg;
    private short style;
    private OMFSegDesc [] segDescArr;
    private String name;

    static OMFModule createOMFModule(
            FactoryBundledWithBinaryReader reader, int ptr, int byteCount)
            throws IOException {
        OMFModule omfModule = (OMFModule) reader.getFactory().create(OMFModule.class);
        omfModule.initOMFModule(reader, ptr, byteCount);
        return omfModule;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public OMFModule() {}

    private void initOMFModule(FactoryBundledWithBinaryReader reader, int ptr, int byteCount) throws IOException {
        int index = ptr;

        this.ovlNumber = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;
        this.iLib      = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;
        this.cSeg      = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;
        this.style     = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;

        this.segDescArr = new OMFSegDesc[cSeg];

        for (int i = 0 ; i < cSeg ; ++i) {
            segDescArr[i] = OMFSegDesc.createOMFSegDesc(reader, index);

            index += OMFSegDesc.IMAGE_SIZEOF_OMF_SEG_DESC;
        }

        ++index; // why do we need to increment?????

        name = reader.readAsciiString(index);
    }

    public short getOvlNumber() {
		return ovlNumber;
	}
    public short getILib() {
		return iLib;
	}
    public short getStyle() {
		return style;
	}
    public String getName() {
		return name;
	}

	/**
	 * Returns the OMF segment descriptions in this OMF module.
	 * @return the OMF segment descriptions in this OMF module
	 */
    public OMFSegDesc [] getOMFSegDescs() {
        return segDescArr;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/OMFSegDesc.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;

import java.io.*;

/**
 * A class to represent the Object Module Format (OMF) Segment Descriptor data structure.
 * Information describing each segment in a module.
 * <br>
 * <pre>
 * typedef struct OMFSegDesc {
 *     unsigned short  Seg;            // segment index
 *     unsigned short  pad;            // pad to maintain alignment
 *     unsigned long   Off;            // offset of code in segment
 *     unsigned long   cbSeg;          // number of bytes in segment
 * } OMFSegDesc;
 * </pre>
 * 
 * 
 */
public class OMFSegDesc {
    final static int IMAGE_SIZEOF_OMF_SEG_DESC = 12;

    private short seg;
    private short pad;
    private int   offset;
    private int   cbSeg;

    static OMFSegDesc createOMFSegDesc(
            FactoryBundledWithBinaryReader reader, int index)
            throws IOException {
        OMFSegDesc omfSegDesc = (OMFSegDesc) reader.getFactory().create(OMFSegDesc.class);
        omfSegDesc.initOMFSegDesc(reader, index);
        return omfSegDesc;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public OMFSegDesc() {}

    private void initOMFSegDesc(FactoryBundledWithBinaryReader reader, int index) throws IOException {
        seg    = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;
        pad    = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;
        offset = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;
        cbSeg  = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;
    }

	/**
	 * Returns the segment index.
	 * @return the segment index
	 */
    public short getSegmentIndex() {
        return seg;
    }
    /**
     * Returns the pad to maintain alignment.
     * @return the pad to maintain alignment
     */
    public short getAlignmentPad() {
        return pad;
    }
    /**
     * Returns the offset of code in segment.
     * @return the offset of code in segment
     */
    public int getOffset() {
        return offset;
    }
    /**
     * Returns the number of bytes in segment.
     * @return the number of bytes in segment
     */
    public int getNumberOfBytes() {
        return cbSeg;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/OMFSegMap.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;

import java.io.*;

/**
 * <pre>
 * typedef struct OMFSegMap {
 *     unsigned short  cSeg;        // total number of segment descriptors
 *     unsigned short  cSegLog;     // number of logical segment descriptors
 *     OMFSegMapDesc   rgDesc[0];   // array of segment descriptors
 * };
 * </pre>
 * 
 * 
 */
public class OMFSegMap {
    private short cSeg;
    private short cSegLog;
    private OMFSegMapDesc [] segmentMapDesc;

    static OMFSegMap createOMFSegMap(
            FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
        OMFSegMap omfSegMap = (OMFSegMap) reader.getFactory().create(OMFSegMap.class);
        omfSegMap.initOMFSegMap(reader, ptr);
        return omfSegMap;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public OMFSegMap() {}

    private void initOMFSegMap(FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
        cSeg    = reader.readShort(ptr); ptr+=BinaryReader.SIZEOF_SHORT;
        cSegLog = reader.readShort(ptr); ptr+=BinaryReader.SIZEOF_SHORT;
        segmentMapDesc = new OMFSegMapDesc[cSeg];
        for (int i = 0 ; i < cSeg ; ++i) {
            segmentMapDesc[i] = OMFSegMapDesc.createOMFSegMapDesc(reader, ptr);
            ptr += OMFSegMapDesc.IMAGE_SIZEOF_OMF_SEG_MAP_DESC;
        }
    }

	/**
	 * Returns the total number of segment descriptors.
	 * @return the total number of segment descriptors
	 */
    public short getSegmentDescriptorCount() {
        return cSeg;
    }
    /**
     * Returns the number of logical segment descriptors.
     * @return the number of logical segment descriptors
     */
    public short getLogicalSegmentDescriptorCount() {
        return cSegLog;
    }
    /**
     * Returns the array of segment descriptors.
     * @return the array of segment descriptors
     */
    public OMFSegMapDesc [] getSegmentDescriptor() {
        return segmentMapDesc;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/OMFSegMapDesc.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;

import java.io.*;

/**
 * A class to represent the Object Module Format (OMF) Segment Mapping Descriptor data structure.
 * <br>
 * <pre>
 * typedef struct OMFSegMapDesc {
 *     unsigned short  flags;       // descriptor flags bit field
 *     unsigned short  ovl;         // the logical overlay number
 *     unsigned short  group;       // group index into the descriptor array
 *     unsigned short  frame;       // logical segment index - interpreted via flags
 *     unsigned short  iSegName;    // segment or group name - index into sstSegName
 *     unsigned short  iClassName;  // class name - index into sstSegName
 *     unsigned long   offset;      // byte offset of the logical within the physical segment
 *     unsigned long   cbSeg;       // byte count of the logical segment or group
 * } OMFSegMapDesc;
 * </pre>
 * 
 * 
 */
public class OMFSegMapDesc {
    final static int IMAGE_SIZEOF_OMF_SEG_MAP_DESC = 20;

    private short  flags;
    private short  ovl;
    private short  group;
    private short  frame;
    private short  iSegName;
    private short  iClassName;
    private int    offset;
    private int    cbSeg;

    static OMFSegMapDesc createOMFSegMapDesc(
            FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
        OMFSegMapDesc omfSegMapDesc = (OMFSegMapDesc) reader.getFactory().create(OMFSegMapDesc.class);
        omfSegMapDesc.initOMFSegMapDesc(reader, ptr);
        return omfSegMapDesc;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public OMFSegMapDesc() {}

    private void initOMFSegMapDesc(FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
        flags      = reader.readShort(ptr); ptr+=BinaryReader.SIZEOF_SHORT;
        ovl        = reader.readShort(ptr); ptr+=BinaryReader.SIZEOF_SHORT;
        group      = reader.readShort(ptr); ptr+=BinaryReader.SIZEOF_SHORT;
        frame      = reader.readShort(ptr); ptr+=BinaryReader.SIZEOF_SHORT;
        iSegName   = reader.readShort(ptr); ptr+=BinaryReader.SIZEOF_SHORT;
        iClassName = reader.readShort(ptr); ptr+=BinaryReader.SIZEOF_SHORT;
        offset     = reader.readInt  (ptr); ptr+=BinaryReader.SIZEOF_INT;
        cbSeg      = reader.readInt  (ptr); ptr+=BinaryReader.SIZEOF_INT;
    }

	/**
	 * Returns the descriptor flags bit field.
	 * @return the descriptor flags bit field
	 */
    public short getFlags() {
        return flags;
    }
    /**
     * Returns the logical overlay number.
     * @return the logical overlay number
     */
    public short getLogicalOverlayNumber() {
        return ovl;
    }
    /**
     * Returns the group index into the descriptor array.
     * @return the group index into the descriptor array
     */
    public short getGroupIndex() {
        return group;
    }
    /**
     * Returns the logical segment index - interpreted via flags.
     * @return the logical segment index - interpreted via flags
     */
    public short getLogicalSegmentIndex() {
        return frame;
    }
    /**
     * Returns the segment or group name - index into sstSegName.
     * @return the segment or group name - index into sstSegName
     */
    public short getSegmentName() {
        return iSegName;
    }
    /**
     * Returns the class name - index into sstSegName.
     * @return the class name - index into sstSegName
     */
    public short getClassName() {
        return iClassName;
    }
    /**
     * Returns the byte offset of the logical within the physical segment.
     * @return the byte offset of the logical within the physical segment
     */
    public int getByteOffset() {
        return offset;
    }
    /**
     * Returns the byte count of the logical segment or group.
     * @return the byte count of the logical segment or group
     */
    public int getByteCount() {
        return cbSeg;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/OMFSrcModule.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;
import ghidra.util.*;

import java.io.*;
import java.util.*;

/**
 * A class to represent the Object Module Format (OMF) Source Module data structure.
 * <br>
 * short cFile 		  - Number of source files contributing code to segments
 * <br>
 * short cSeg		  - Number of code segments receiving code from module
 * <br>
 * int [] baseSrcFile -  An array of base offsets
 * <br>
 * int [] starts 	  - start offset within the segment of the first byte of code from the module
 * <br>
 * int [] ends        - ending address of code from the module
 * <br>
 * short [] segs      - Array of segment indicies that receive code from the module
 */
public class OMFSrcModule {

    private short cFile;
	private short cSeg;
	private int [] baseSrcFile;
	private int [] starts;
	private int [] ends;
	private short [] segs;

	private ArrayList<OMFSrcModuleFile> moduleFileList = new ArrayList<OMFSrcModuleFile>();

    static OMFSrcModule createOMFSrcModule(
            FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
        OMFSrcModule omfSrcModule = (OMFSrcModule) reader.getFactory().create(OMFSrcModule.class);
        omfSrcModule.initOMFSrcModule(reader, ptr);
        return omfSrcModule;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public OMFSrcModule() {}

	private void initOMFSrcModule(FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
		int index = ptr;

		cFile = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;
		cSeg  = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;

		baseSrcFile = new int[Conv.shortToInt(cFile)];
		for (int i = 0 ; i < Conv.shortToInt(cFile) ; ++i) {
			baseSrcFile[i] = reader.readInt(index); index+=BinaryReader.SIZEOF_INT;
		}

		starts = new int[Conv.shortToInt(cSeg)];
		ends   = new int[Conv.shortToInt(cSeg)];

		for (int i = 0 ; i < Conv.shortToInt(cSeg) ; ++i) {
			starts[i] = reader.readInt(index); index+=BinaryReader.SIZEOF_INT;
			ends  [i] = reader.readInt(index); index+=BinaryReader.SIZEOF_INT;
		}

		segs = new short[Conv.shortToInt(cSeg)];
		for (int i = 0 ; i < Conv.shortToInt(cSeg) ; ++i) {
			segs[i] = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;
		}

		for (int i = 0 ; i < Conv.shortToInt(cFile) ; ++i) {
			moduleFileList.add(OMFSrcModuleFile.createOMFSrcModuleFile(reader, ptr+baseSrcFile[i]));
		}
	}

	/**
	 * Returns the array of source files.
	 * @return the array of source files
	 */
	public OMFSrcModuleFile [] getOMFSrcModuleFiles() {
		OMFSrcModuleFile [] arr = new OMFSrcModuleFile[moduleFileList.size()];
		moduleFileList.toArray(arr);
		return arr;
	}

	/**
	 * Returns an array of base offsets.
	 * @return an array of base offsets
	 */
	public int[] getBaseSrcFile() {
		return baseSrcFile;
	}

	/**
	 * Returns the number of source files contributing code to segments.
	 * @return the number of source files contributing code to segments
	 */
	public short getFileCount() {
		return cFile;
	}

	/**
	 * Returns the number of code segments receiving code from module.
	 * @return the number of code segments receiving code from module
	 */
	public short getSegmentCount() {
		return cSeg;
	}

	/**
	 * Returns an array of ending addresses of code from the module.
	 * @return an array of ending addresses of code from the module
	 */
	public int[] getEnds() {
		return ends;
	}

	/**
	 * Returns an array of segment indicies that receive code from the module.
	 * @return an array of segment indicies that receive code from the module
	 */
	public short[] getSegments() {
		return segs;
	}

	/**
	 * Returns an array of start offsets within the segment of the first byte of code from the module.
	 * @return an array of start offsets within the segment of the first byte of code from the module
	 */
	public int[] getStarts() {
		return starts;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/OMFSrcModuleFile.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;
import ghidra.util.*;

import java.io.*;
import java.util.*;

/**
 * A class to represent the Object Module Format (OMF) Source Module File data structure. 
 * <br>
 * This class describes the code segments that receive code from a source file.
 * <br>
 * short cSeg 		- Number of segments that receive code from the source file.
 * <br>
 * short pad 		- pad field to maintain alignment
 * <br>
 * int [] baseSrcLn - array of offsets for the line or address mapping for each segment that receives code from the source file.
 * <br>
 * int [] starts 	- starting addresses within the segment of the first byte of code from the module.
 * <br>
 * int [] ends 		- ending addresses of the code from the module.
 * <br>
 * byte cbName 		- count or number of bytes in source file name.
 * <br>
 * String name 		- name of source file.
 * <br>
 */
public class OMFSrcModuleFile {

    private short cSeg;
	private short pad;
	private int [] baseSrcLn;
	private int [] starts;
	private int [] ends;
	private byte cbName;
	private String name;

	private ArrayList<OMFSrcModuleLine> moduleLineList = new ArrayList<OMFSrcModuleLine>();

    static OMFSrcModuleFile createOMFSrcModuleFile(
            FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
        OMFSrcModuleFile omfSrcModuleFile = (OMFSrcModuleFile) reader.getFactory().create(OMFSrcModuleFile.class);
        omfSrcModuleFile.initOMFSrcModuleFile(reader, ptr);
        return omfSrcModuleFile;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public OMFSrcModuleFile() {}

	private void initOMFSrcModuleFile(FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
		int index = ptr;

		cSeg = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;
		pad  = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;

		baseSrcLn = new int[Conv.shortToInt(cSeg)];
		for (int i = 0 ; i < cSeg ; ++i) {
			baseSrcLn[i] = reader.readInt(index); index+=BinaryReader.SIZEOF_INT;
		}

		starts = new int[Conv.shortToInt(cSeg)];
		ends   = new int[Conv.shortToInt(cSeg)];

		for (int i = 0 ; i < Conv.shortToInt(cSeg) ; ++i) {
			starts[i] = reader.readInt(index); index+=BinaryReader.SIZEOF_INT;
			ends  [i] = reader.readInt(index); index+=BinaryReader.SIZEOF_INT;
		}

		cbName = reader.readByte(index); index+=BinaryReader.SIZEOF_BYTE;

		name = reader.readAsciiString(index, cbName); index+=cbName;

		for (int i = 0 ; i < Conv.shortToInt(cSeg) ; ++i) {
			//OMFSrcModuleLine line = new OMFSrcModuleLine(reader, index);
			OMFSrcModuleLine line = OMFSrcModuleLine.createOMFSrcModuleLine(reader, ptr+baseSrcLn[i]);
			moduleLineList.add(line);
			index+=line.getByteCount();	
		}
	}

	/**
	 * Returns an array of the source module lines.
	 * @return an array of the source module lines
	 */
	public OMFSrcModuleLine [] getOMFSrcModuleLines() {
		OMFSrcModuleLine [] arr = new OMFSrcModuleLine[moduleLineList.size()];
		moduleLineList.toArray(arr);
		return arr;
	}

	/**
	 * Returns an array of offsets for the line or address mapping for each segment 
	 * that receives code from the source file.
	 * @return an array of offsets for the line or address mapping for each segment
	 */
	public int[] getBaseSrcLn() {
		return baseSrcLn;
	}

	/**
	 * Returns the number of segments that receive code from the source file.
	 * @return the number of segments that receive code from the source file
	 */
	public short getSegmentCount() {
		return cSeg;
	}

	/**
	 * Returns the ending addresses of the code from the module.
	 * @return the ending addresses of the code from the module
	 */
	public int[] getEnds() {
		return ends;
	}

	/**
	 * Returns the name of source file.
	 * @return the name of source file
	 */
	public String getName() {
		return name;
	}

	/**
	 * Returns the pad field to maintain alignment.
	 * @return the pad field to maintain alignment
	 */
	public short getPad() {
		return pad;
	}

	/**
	 * Returns the starting addresses within the segment of the first byte of code from the module.
	 * @return the starting addresses within the segment of the first byte of code from the module
	 */
	public int[] getStarts() {
		return starts;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/OMFSrcModuleLine.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;
import ghidra.util.*;

import java.io.*;

/**
 * A class to represent the Object Module Format (OMF) Source Module Line data structure.
 * <br>
 * short seg            - segment index.
 * <br>
 * short cPair          - Count or number of source line pairs to follow.
 * <br>
 * int [] offsets       - offset within the code segment of the start of the line.
 * <br>
 * short [] linenumbers - line numbers that are in the source file that cause code to be emitted to the code segment.
 * <br>
 **/
public class OMFSrcModuleLine {

    private short seg;
	private short cPair;
	private int [] offsets;
	private short [] linenumbers;

    static OMFSrcModuleLine createOMFSrcModuleLine(
            FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
        OMFSrcModuleLine omfSrcModuleLine = (OMFSrcModuleLine) reader.getFactory().create(OMFSrcModuleLine.class);
        omfSrcModuleLine.initOMFSrcModuleLine(reader, ptr);
        return omfSrcModuleLine;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public OMFSrcModuleLine() {}

	private void initOMFSrcModuleLine(FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
		int index = ptr;
		
		seg   = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;
		cPair = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;
		
		offsets = new int[Conv.shortToInt(cPair)];
		for (int i = 0 ; i < Conv.shortToInt(cPair) ; ++i) {
			offsets[i] = reader.readInt(index); index+=BinaryReader.SIZEOF_INT;
		}
		
		linenumbers = new short[Conv.shortToInt(cPair)];
		for (int i = 0 ; i < Conv.shortToInt(cPair) ; ++i) {
			linenumbers[i] = reader.readShort(index); index+=BinaryReader.SIZEOF_SHORT;
		}
	}

	/**
	 * Returns the count or number of source line pairs to follow.
	 * @return the count or number of source line pairs to follow
	 */
	public short getPairCount() {
		return cPair;
	}

	/**
	 * Returns the line numbers that are in the source file that cause code to be emitted to the code segment.
	 * @return the line numbers that are in the source file that cause code to be emitted to the code segment
	 */
	public short[] getLinenumbers() {
		return linenumbers;
	}

	/**
	 * Returns the offset within the code segment of the start of the line.
	 * @return the offset within the code segment of the start of the line
	 */
	public int[] getOffsets() {
		return offsets;
	}

	/**
	 * Returns the segment index.
	 * @return the segment index
	 */
	public short getSegmentIndex() {
		return seg;
	}

	int getByteCount() {
		return BinaryReader.SIZEOF_SHORT
				+BinaryReader.SIZEOF_SHORT
				+BinaryReader.SIZEOF_INT*cPair
				+BinaryReader.SIZEOF_SHORT*cPair;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/PrimitiveTypeListing.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.program.model.data.*;
import ghidra.util.Msg;

/**
 * A class to convert from debug data types into Ghidra data types.
 * 
 */
public class PrimitiveTypeListing {

	// Special Types
    /**Uncharacterized type (no type)*/
    public final static short T_NOTYPE    = 0x0000;
    /**Absolute symbol*/
    public final static short T_ABS       = 0x0001;
    /**Segment Type*/
    public final static short T_SEGMENT   = 0x0002;
    /**VOID*/
    public final static short T_VOID      = 0x0003;
    /**Near Pointer to a void*/
    public final static short T_PVOID     = 0x0103;
    /**Far pointer to a void*/
    public final static short T_PFOID     = 0x0203;
    /**Huge pointer to a VOID*/
    public final static short T_PHVOID    = 0x0303;
    /**32-bit near pointer to a void*/
    public final static short T_32PVOID   = 0x0403;
    /**32-bit far pointer to a void*/
    public final static short T_32PFVOID  = 0x0503;
    /**Basic 8-byte currency value*/
    public final static short T_CURRENCY  = 0x0004;
    /**Near basic string*/
    public final static short T_NBASICSTR = 0x0005;
    /**Far basic string*/
    public final static short T_FBASICSTR = 0x0006;
    /**Untranslated type record from Microsoft symbol format*/
    public final static short T_NOTTRANS  = 0x0007;
    /**Bit*/
    public final static short T_BIT       = 0x0060;
    /**Pascal CHAR*/
    public final static short T_PASCHAR   = 0x0061;
	
	// Character Types
    /**8-bit signed*/
    public final static short T_CHAR       = 0x0010;
    /**8-bit unsigned*/
    public final static short T_UCHAR      = 0x0020;
    /**Near pointer to 8-bit signed*/
    public final static short T_PCHAR      = 0x0110;
    /**Near pointer to 8-bit unsigned*/
    public final static short T_PUCHAR	   = 0x0120;
    /**Far pointer to 8-bit signed*/
    public final static short T_PFCHAR	   = 0x0210;
    /**Far pointer to 8-bit unsigned*/
    public final static short T_PFUCHAR	   = 0x0220;
    /**Huge pointer to 8-bit signed*/
    public final static short T_PHCHAR	   = 0x0310;
    /**Huge pointer to 8-bit unsigned*/
    public final static short T_PHUCHAR	   = 0x0320;
    /**16:32 near pointer to 8-bit signed*/
    public final static short T_32PCHAR	   = 0x0410;
    /**16:32 near pointer to 8-bit unsigned*/
    public final static short T_32PUCHAR   = 0x0420;
    /**16:32 far pointer to 8-bit signed*/
    public final static short T_32PFCHAR   = 0x0510;
    /**16:32 far pointer to 8-bit unsigned*/
    public final static short T_32PFUCHAR  = 0x0520;
	
	// Real Character Types
    /**Real char*/
    public final static short T_RCHAR	  = 0x0070;
    /**Near pointer to a real char*/
    public final static short T_PRCHAR    = 0x0170;
    /**Far pointer to a real char*/
    public final static short T_PFRCHAR   = 0x0270;
    /**Huge pointer to a real char*/
    public final static short T_PHRCHAR   = 0x0370;
    /**16:32 near pointer to a real char*/
    public final static short T_32PRCHAR  = 0x0470;
    /**16:32 far pointer to a real char*/
    public final static short T_32PFRCHAR = 0x0570;

	// Wide Character Types
    /**wide char*/
    public final static short T_WCHAR     = 0x0071;
    /**Near pointer to a wide char*/
    public final static short T_PWCHAR    = 0x0171;
    /**far pointer to a wide char*/
    public final static short T_PFWCHAR   = 0x0271;
    /**Huge pointer to a wide char*/
    public final static short T_PHWCHAR   = 0x0371;
    /**16:32 near pointer to a wide char*/
    public final static short T_32PWCHAR  = 0x0471;
    /**16:32 far pointer to a wide char*/
    public final static short T_32PFWCHAR = 0x0571;

	// Real 16-bit Integer Types
    /**Real 16-bit signed short*/
    public final static short T_INT2 	  = 0x0072;
    /**Real 16-bit unsigned short*/
    public final static short T_UINT2 	  = 0x0073;
    /**Near pointer to 16-bit signed short*/
    public final static short T_PINT2 	  = 0x0172;
    /**Near pointer to 16-bit unsigned short*/
    public final static short T_PUINT2 	  = 0x0173;
    /**Far pointer to 16-bit signed short*/
    public final static short T_PFINT2 	  = 0x0272;
    /**Far point to  16-bit unsigned short*/
    public final static short T_PFUINT2   = 0x0273;
    /**Huge pointer to 16-bit signed short*/
    public final static short T_PHINT2    = 0x0372;
    /**Huge pointer to 16-bit unsigned short*/
    public final static short T_PHUINT2   = 0x0373;
    /**16:32 near pointer to 16-bit signed short*/
    public final static short T_32PINT2   = 0x0472;
    /**16:32 near pointer to 16-bit unsigned short*/
    public final static short T_32PUINT2  = 0x0473;
    /**16:32 far pointer to 16-bit signed short*/
    public final static short T_32PFINT2  = 0x0572;
    /**16:32 far pointer to 16-bit unsigned short*/
    public final static short T_32PFUINT2 = 0x0573;
	
	// 16-bit Short Types
    /**16-bit signed*/
    public final static short T_SHORT      = 0x0011;
    /**16-bit unsigned*/
    public final static short T_USHORT     = 0x0021;
    /**Near pointer to 16-bit signed*/
    public final static short T_PSHORT     = 0x0111;
    /**Near pointer to 16-bit unsigned*/
    public final static short T_PUSHORT    = 0x0121;
    /**Far pointer to16-bit signed*/
    public final static short T_PFSHORT    = 0x0211;
    /**Far pointer to 16-bit unsigned*/
    public final static short T_PFUSHORT   = 0x0221;
    /**Huge pointer to 16-bit signed*/
    public final static short T_PHSHORT    = 0x0311;
    /**Huge pointer 16-bit unsigned*/
    public final static short T_PHUSHORT   = 0x0321;
    /**16:32 near pointer to 16-bit signed*/
    public final static short T_32PSHORT   = 0x0411;
    /**16:32 near pointer to 16-bit unsigned*/
    public final static short T_32PUSHORT  = 0x0421;
    /**16:32 far pointer to 16-bit signed*/
    public final static short T_32PFSHORT  = 0x0511;
    /**16:32 far pointer to 16-bit unsigned*/
    public final static short T_32PFUSHORT = 0x0521;
	
	// Real 32-bit Integer Types
    /**Real 32-bit signed short*/
    public final static short T_INT4      = 0x0074;
    /**Real 32-bit unsigned short*/
    public final static short T_UINT4 	  = 0x0075;
    /**Near pointer to 32-bit signed short*/
    public final static short T_PINT4 	  = 0x0174;
    /**Near pointer to 32-bit unsigned short*/
    public final static short T_PUINT4 	  = 0x0175;
    /**Far pointer to 32-bit signed short*/
    public final static short T_PFINT4 	  = 0x0274;
    /**Far pointer to 32-bit unsigned short*/
    public final static short T_PFUINT4   = 0x0275;
    /**Huge pointer to 32-bit signed short*/
    public final static short T_PHINT4    = 0x0374;
    /**Huge pointer to 32-bit unsigned short*/
    public final static short T_PHUINT4   = 0x0375;
    /**16:32 near pointer to 32-bit signed short*/
    public final static short T_32PINT4   = 0x0474;
    /**16:32 near pointer to 32-bit unsigned short*/
    public final static short T_32PUINT4  = 0x0475;
    /**16:32 far pointer to 32-bit signed short*/
    public final static short T_32PFINT4  = 0x0574;
    /**16:32 far pointer to 32-bit unsigned short*/
    public final static short T_32PFUINT4 = 0x0575;
	
	// 32-bit Long Types
    /**32-bit signed*/
    public final static short T_LONG 	  = 0x0012;
    /**32-bit unsigned*/
    public final static short T_ULONG 	  = 0x0022;
    /**Near pointer to 32-bit signed*/
    public final static short T_PLONG 	  = 0x0112;
    /**Near Pointer to 32-bit unsigned*/
    public final static short T_PULONG 	  = 0x0122;
    /**Far pointer to 32-bit signed*/
    public final static short T_PFLONG 	  = 0x0212;
    /**Far pointer to 32-bit unsigned*/
    public final static short T_PFULONG   = 0x0222;
    /**Huge pointer to 32-bit signed*/
    public final static short T_PHLONG 	  = 0x0312;
    /**Huge pointer to 32-bit unsigned*/
    public final static short T_PHULONG   = 0x0322;
    /**16:32 near pointer to 32-bit signed*/
    public final static short T_32PLONG   = 0x0412;
    /**16:32 near pointer to 32-bit unsigned*/
    public final static short T_32PULONG  = 0x0422;
    /**16:32 far pointer to 32-bit signed*/
    public final static short T_P2PFLONG  = 0x0512;
    /**16:32 far pointer to 32-bit unsigned*/
    public final static short T_32PFULONG = 0x0522;
	
	// Real 64-bit short Types
    /**64-bit signed*/
    public final static short T_INT8 	  = 0x0076;
    /**64-bit unsigned*/
    public final static short T_UINT8 	  = 0x0077;
    /**Near pointer to 64-bit signed*/
    public final static short T_PINT8 	  = 0x0176;
    /**Near Pointer to 64-bit unsigned*/
    public final static short T_PUINT8 	  = 0x0177;
    /**Far pointer to 64-bit signed*/
    public final static short T_PFINT8 	  = 0x0276;
    /**Far pointer to 64-bit unsigned*/
    public final static short T_PFUINT8   = 0x0277;
    /**Huge pointer to 64-bit signed*/
    public final static short T_PHINT8 	  = 0x0376;
    /**Huge pointer to 64-bit unsigned*/
    public final static short T_PHUINT8   = 0x0377;
    /**16:32 near pointer to 64-bit signed*/
    public final static short T_32PINT8   = 0x0476;
    /**16:32 near pointer to 64-bit unsigned*/
    public final static short T_32PUINT8  = 0x0477;
    /**16:32 far pointer to 64-bit signed*/
    public final static short T_32PFINT8  = 0x0576;
    /**16:32 far pointer to 64-bit unsigned*/
    public final static short T_32PFUINT8 = 0x0577;
		
	// 64-bit Integral Types
    /**64-bit signed*/
    public final static short T_QUAD 	  = 0x0013;
    /**64-bit unsigned*/
    public final static short T_UQUAD 	  = 0x0023;
    /**Near pointer to 64-bit signed*/
    public final static short T_PQUAD 	  = 0x0113;
    /**Near pointer to 64-bit unsigned*/
    public final static short T_PUQUAD 	  = 0x0123;
    /**Far pointer to 64-bit signed*/
    public final static short T_PFQUAD 	  = 0x0213;
    /**Far pointer to 64-bit unsigned*/
    public final static short T_PFUQUAD   = 0x0223;
    /**Huge pointer to 64-bit signed*/
    public final static short T_PHQUAD 	  = 0x0313;
    /**Huge pointer to 64-bit unsigned*/
    public final static short T_PHUQUAD   = 0x0323;
    /**16:32 near pointer to 64-bit signed*/
    public final static short T_32PQUAD   = 0x0413;
    /**16:32 near pointer to 64-bit unsigned*/
    public final static short T_32PUQUAD  = 0x0423;
    /**16:32 far pointer to 64-bit signed*/
    public final static short T_32PFQUAD  = 0x0513;
    /**16:32 far pointer to 64-bit unsigned*/
    public final static short T_32PFUQUAD = 0x0523;
	
	// 32-bit Real Types
    /**32-bit real*/
    public final static short T_REAL32     = 0x0040;
    /**Near pointer to 32-bit real*/
    public final static short T_PREAL32    = 0x0140;
    /**Far pointer to 32-bit real*/
    public final static short T_PFREAL32   = 0x0240;
    /**Huge pointer to 32-bit real*/
    public final static short T_PHREAL32   = 0x0340;
    /**16:32 near pointer to 32-bit real*/
    public final static short T_32PREAL32  = 0x0440;
    /**16:32 far pointer to 32-bit real*/
    public final static short T_32PFREAL32 = 0x0540;
	
	// 64-bit Real Types
    /**64-bit real*/
    public final static short T_REAL64     = 0x0041;
    /**Near pointer to 64-bit real*/
    public final static short T_PREAL64    = 0x0141;
    /**Far pointer to 64-bit real*/
    public final static short T_PFREAL64   = 0x0241;
    /**Huge pointer to 64-bit real*/
    public final static short T_PHREAL64   = 0x0341;
    /**16:32 near pointer to 64-bit real*/
    public final static short T_32PREAL64  = 0x0441;
    /**16:32 far pointer to 64-bit real*/
    public final static short T_32PFREAL64 = 0x0541;
	
	// 32-bit Complex Types
    /**32-bit complex*/
    public final static short T_CPLX32     = 0x0050;
    /**Near pointer to 32-bit complex*/
    public final static short T_PCPLX32    = 0x0150;
    /**Far pointer to 32-bit complex*/
    public final static short T_PFCPLX32   = 0x0250;
    /**Huge pointer to 32-bit complex*/
    public final static short T_PHCPLX32   = 0x0350;
    /**16:32 near pointer to 32-bit complex*/
    public final static short T_32PCPLX32  = 0x0450;
    /**16:32 far pointer to 32-bit complex*/
    public final static short T_32PFCPLX32 = 0x0550;
	
	//64-bit Complex Types
    /**32-bit complex*/
    public final static short T_CPLX64     = 0x0051;
    /**Near pointer to 64-bit complex*/
    public final static short T_PCPLX64    = 0x0151;
    /**Far Pointer to 64-bit complex*/
    public final static short T_PFCPLX64   = 0x0251;
    /**Huge pointer to 64-bit complex*/
    public final static short T_PHCPLX64   = 0x0351;
    /**16:32 near pointer to 64-bit complex*/
    public final static short T_32PCPLX64  = 0x0451;
    /**16:32 far pointer to 64-bit complex*/
    public final static short T_32PFCPLX64 = 0x0551;
	
	// Boolean Types
    /**8-bit boolean*/
    public final static short T_BOOL08     = 0x0030;
    /**16-bit boolean*/
    public final static short T_BOOL16     = 0x0031;
    /**32-bit boolean*/
    public final static short T_BOOL32     = 0x0032;
    /**64-bit boolean*/
    public final static short T_BOOL64     = 0x0033;
    /**Near pointer to 8-bit boolean*/
    public final static short T_PBOOL08    = 0x0130;
    /**Near pointer to 16-bit boolean*/
    public final static short T_PBOOL16    = 0x0131;
    /**Near pointer to 32-bit boolean*/
    public final static short T_PBOOL32    = 0x0132;
    /**Near pointer to 64-bit boolean*/
    public final static short T_PBOOL64    = 0x0133;
    /**Far Pointer to 8-bit boolean*/
    public final static short T_PFBOOL08   = 0x0230;
    /**Far Pointer to 16-bit boolean*/
    public final static short T_PFBOOL16   = 0x0231;
    /**Far Pointer to 32-bit boolean*/
    public final static short T_PFBOOL32   = 0x0232;
    /**Far Pointer to 64-bit boolean*/
    public final static short T_PFBOOL64   = 0x0233;
    /**Huge pointer to 8-bit boolean*/
    public final static short T_PHBOOL08   = 0x0330;
    /**Huge pointer to 16-bit boolean*/
    public final static short T_PHBOOL16   = 0x0331;
    /**Huge pointer to 32-bit boolean*/
    public final static short T_PHBOOL32   = 0x0332;
    /**Huge pointer to 64-bit boolean*/
    public final static short T_PHBOOL64   = 0x0333;
    /**16:32 near pointer to 8-bit boolean*/
    public final static short T_32PBOOL08  = 0x0430;
    /**16:32 near pointer to 16-bit boolean*/
    public final static short T_32PBOOL16  = 0x0431;
    /**16:32 near pointer to 32-bit boolean*/
    public final static short T_32PBOOL32  = 0x0432;
    /**16:32 near pointer to 64-bit boolean*/
    public final static short T_32PBOOL64  = 0x0433;
    /**16:32 far pointer to 8-bit boolean*/
    public final static short T_32PFBOOL08 = 0x0530;
    /**16:32 far pointer to 16-bit boolean*/
    public final static short T_32PFBOOL16 = 0x0531;
    /**16:32 far pointer to 32-bit boolean*/
    public final static short T_32PFBOOL32 = 0x0532;
    /**16:32 far pointer to 64-bit boolean*/
    public final static short T_32PFBOOL64 = 0x0533;
	
    /**HANDLE*/
    public final static short T_HINSTANCE = 0x10fd;

	public static DataType getDataType(short type) {

		switch (type) {
			case T_SHORT :
			case T_USHORT :
				return new WordDataType();
			case T_PSHORT :
			case T_PUSHORT :
			case T_PFSHORT :
			case T_PFUSHORT :
			case T_PHSHORT :
			case T_PHUSHORT :
			case T_32PSHORT :
			case T_32PUSHORT :
			case T_32PFSHORT :
			case T_32PFUSHORT :
				return new Pointer32DataType(new WordDataType());
			case T_INT8 :
			case T_UINT8 :
				return new QWordDataType();
			case T_PINT8 :
			case T_PUINT8 :
			case T_PFINT8 :
			case T_PFUINT8 :
			case T_PHINT8 :
			case T_PHUINT8 :
			case T_32PINT8 :
			case T_32PUINT8 :
			case T_32PFINT8 :
			case T_32PFUINT8 :
				return new Pointer32DataType(new QWordDataType());
			case T_INT4 :
			case T_UINT4 :
				return new DWordDataType();
			case T_PINT4 :
			case T_PUINT4 :
			case T_PFINT4 :
			case T_PFUINT4 :
			case T_PHINT4 :
			case T_PHUINT4 :
			case T_32PINT4 :
			case T_32PUINT4 :
			case T_32PFINT4 :
			case T_32PFUINT4 :
				return new Pointer32DataType(new DWordDataType());
			case T_LONG :
			case T_ULONG :
				return new DWordDataType();
			case T_PLONG :
			case T_PULONG :
			case T_PFLONG :
			case T_PFULONG :
			case T_PHLONG :
			case T_PHULONG :
			case T_32PLONG :
			case T_32PULONG :
			case T_P2PFLONG :
			case T_32PFULONG :
				return new Pointer32DataType(new DWordDataType());
			case T_QUAD :
			case T_UQUAD :
				return new QWordDataType();
			case T_PQUAD :
			case T_PUQUAD :
			case T_PFQUAD :
			case T_PFUQUAD :
			case T_PHQUAD :
			case T_PHUQUAD :
			case T_32PQUAD :
			case T_32PUQUAD :
			case T_32PFQUAD :
			case T_32PFUQUAD :
				return new Pointer32DataType(new QWordDataType());
			case T_REAL32 :
			case T_PREAL32 :
				return new FloatDataType();
			case T_PFREAL32 :
			case T_PHREAL32 :
			case T_32PREAL32 :
			case T_32PFREAL32 :
				return new Pointer32DataType(new FloatDataType());
			case T_REAL64 :
			case T_PREAL64 :
				return new DoubleDataType();
			case T_PFREAL64 :
			case T_PHREAL64 :
			case T_32PREAL64 :
			case T_32PFREAL64 :
				return new Pointer32DataType(new DoubleDataType());
			case T_32PVOID:
				return new TypedefDataType("VOID", new Pointer32DataType());
			case T_BOOL08 :
				return new TypedefDataType("bool08", new ByteDataType());
			case T_BOOL16 :
				return new TypedefDataType("bool16", new WordDataType());
			case T_BOOL32 :
				return new TypedefDataType("bool32", new DWordDataType());
			case T_BOOL64 :
				return new TypedefDataType("bool32", new QWordDataType());
			case T_HINSTANCE :
				return new TypedefDataType("HINSTANCE", new Pointer32DataType());
			case T_CHAR :
			case T_UCHAR :
				return new CharDataType();
			case T_PCHAR :
			case T_PUCHAR :
			case T_PFCHAR :
			case T_PFUCHAR :
			case T_PHCHAR :
			case T_PHUCHAR :
			case T_32PCHAR :
			case T_32PUCHAR :
			case T_32PFCHAR :
			case T_32PFUCHAR :
				return new Pointer32DataType(new CharDataType());
			case T_RCHAR :
				return new CharDataType();
			case T_PRCHAR :
			case T_PFRCHAR :
			case T_PHRCHAR :
			case T_32PRCHAR :
			case T_32PFRCHAR :
				return new Pointer32DataType(new CharDataType());
			case T_WCHAR :
				return new UnicodeDataType();
			case T_PWCHAR :
			case T_PFWCHAR :
			case T_PHWCHAR :
			case T_32PWCHAR :
			case T_32PFWCHAR :
				return new Pointer32DataType(new UnicodeDataType());
			default :
//TODO: unknown types??
			    Msg.warn(PrimitiveTypeListing.class, "PrimitiveTypeListing: unrecognized  data type ["
                        + "] - 0x" + Integer.toHexString(type));
				return DataType.DEFAULT;
		}
	}
	
		
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/S_ALIGN.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.format.*;

import java.io.*;

/**
 * 
 * 
 */
class S_ALIGN extends DebugSymbol {
    private byte [] pad;

    static S_ALIGN createS_ALIGN(short length, short type,
            FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
        S_ALIGN s_align = (S_ALIGN) reader.getFactory().create(S_ALIGN.class);
        s_align.initS_ALIGN(length, type, reader, ptr);
        return s_align;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public S_ALIGN() {}

	private void initS_ALIGN(short length, short type, FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
		processDebugSymbol(length, type);

		if (type != DebugCodeViewConstants.S_ALIGN) {
			throw new IllegalArgumentException("Incorrect type!");
		}

		this.pad = reader.readByteArray(ptr, length);
	}

	public boolean isEOT() {
		for (int i = 0 ; i < pad.length ; ++i) {
			if (pad[i] != 0xff) {
				return false;
			}
		}
		return true;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/S_BLOCK32.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

/**
 * 
 */
class S_BLOCK32 extends DebugSymbol {

	static S_BLOCK32 createS_BLOCK32(short length, short type) {
        return new S_BLOCK32(length, type);
    }

    private S_BLOCK32(short length, short type) {
		processDebugSymbol(length, type);
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/S_BPREL32_NEW.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;
import ghidra.util.*;

import java.io.*;

/**
 * A class to represent the S_BPREL32_NEW data structure.
 * 
 */
public class S_BPREL32_NEW extends DebugSymbol {
    private short  variableType;
	private short  symbolType;

    static S_BPREL32_NEW createS_BPREL32_NEW(short length, short type,
            FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
        S_BPREL32_NEW s_bprel32_new = (S_BPREL32_NEW) reader.getFactory().create(S_BPREL32_NEW.class);
        s_bprel32_new.initS_BPREL32_NEW(length, type, reader, ptr);
        return s_bprel32_new;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public S_BPREL32_NEW() {}

    private void initS_BPREL32_NEW(short length, short type, FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
		processDebugSymbol(length, type);

		offset        = reader.readInt  (ptr); ptr+=BinaryReader.SIZEOF_INT;
		variableType  = reader.readShort(ptr); ptr+=BinaryReader.SIZEOF_SHORT;
		symbolType    = reader.readShort(ptr); ptr+=BinaryReader.SIZEOF_SHORT;

		byte nameLen = reader.readByte (ptr); ptr+=BinaryReader.SIZEOF_BYTE;

		name = reader.readAsciiString(ptr, Conv.byteToInt(nameLen));
	}

	/**
	 * Returns the variable type.
	 * @return the variable type
	 */
	public short getVariableType() {
	    return variableType;
	}
	short getSymbolType() {
		return symbolType;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/S_COMPILE.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

/**
 * 
 */
class S_COMPILE extends DebugSymbol {

	static S_COMPILE createS_COMPILE(short length, short type) {
        return new S_COMPILE(length, type);
    }

    private S_COMPILE(short length, short type) {
		processDebugSymbol(length, type);
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/S_CONSTANT32.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;
import ghidra.util.*;

import java.io.*;

/**
 * 
 */
class S_CONSTANT32 extends DebugSymbol {

	static S_CONSTANT32 createS_CONSTANT32(short length, short type,
            FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
	    S_CONSTANT32 s_constant32 = (S_CONSTANT32) reader.getFactory().create(S_CONSTANT32.class);
	    s_constant32.initS_CONSTANT32(length, type, reader, ptr);
	    return s_constant32;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public S_CONSTANT32() {}

    private void initS_CONSTANT32(short length, short type, FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
		processDebugSymbol(length, type);

		int   unknown1 = reader.readInt  (ptr); ptr+=BinaryReader.SIZEOF_INT;
		short unknown2 = reader.readShort(ptr); ptr+=BinaryReader.SIZEOF_SHORT;

		byte nameLen = reader.readByte(ptr); ptr+=BinaryReader.SIZEOF_BYTE;

		name = reader.readAsciiString(ptr, Conv.byteToInt(nameLen));

		Msg.debug(this, "S_CONSTANT32: "+unknown1+" - "+unknown2);
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/S_DATAREF.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;

import java.io.*;

/**
 * 
 * 
 */
class S_DATAREF extends DebugSymbol {
    private int checksum;

    static S_DATAREF createS_DATAREF(short length, short type,
            FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
        S_DATAREF s_dataref = (S_DATAREF) reader.getFactory().create(S_DATAREF.class);
        s_dataref.initS_DATAREF(length, type, reader, ptr);
        return s_dataref;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public S_DATAREF() {}

	private void initS_DATAREF(short length, short type, FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
		processDebugSymbol(length, type);

		if (type != DebugCodeViewConstants.S_DATAREF) {
			throw new IllegalArgumentException("Incorrect type!");
		}

		this.checksum = reader.readInt  (ptr); ptr += BinaryReader.SIZEOF_INT;
		this.offset   = reader.readInt  (ptr); ptr += BinaryReader.SIZEOF_INT;
		this.section  = reader.readShort(ptr); ptr += BinaryReader.SIZEOF_SHORT;
	}

	public int getChecksum() {
		return checksum;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/S_END.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.format.*;
import ghidra.util.*;

/**
 * 
 */
class S_END extends DebugSymbol {

	static S_END createS_END(short length, short type,
            FactoryBundledWithBinaryReader reader, int ptr) {
	    S_END s_end = (S_END) reader.getFactory().create(S_END.class);
	    s_end.initS_END(length, type, reader, ptr);
	    return s_end;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public S_END() {}

    private void initS_END(short length, short type, FactoryBundledWithBinaryReader reader, int ptr) {
		processDebugSymbol(length, type);
		Msg.debug(this, reader.getPointerIndex()+" -- "+ptr);
		this.name = "END";
		this.offset = 0;
		this.section = 0;		
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/S_GDATA32_NEW.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;
import ghidra.util.*;

import java.io.*;

/**
 * 
 */
class S_GDATA32_NEW extends DebugSymbol {

	static S_GDATA32_NEW createS_GDATA32_NEW(short length, short type,
            FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
	    S_GDATA32_NEW s_gdata32_new = (S_GDATA32_NEW) reader.getFactory().create(S_GDATA32_NEW.class);
	    s_gdata32_new.initS_GDATA32_NEW(length, type, reader, ptr);
	    return s_gdata32_new;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public S_GDATA32_NEW() {}

    private void initS_GDATA32_NEW(short length, short type, FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
		processDebugSymbol(length, type);

		int unknown = reader.readInt  (ptr); ptr+=BinaryReader.SIZEOF_INT;

		offset  = reader.readInt  (ptr); ptr+=BinaryReader.SIZEOF_INT;
		section = reader.readShort(ptr); ptr+=BinaryReader.SIZEOF_SHORT;

		byte nameLen = reader.readByte(ptr); ptr+=BinaryReader.SIZEOF_BYTE;

		name = reader.readAsciiString(ptr, Conv.byteToInt(nameLen));

		Msg.debug(this, "S_DATA32_NEW: "+unknown);
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/S_GPROC32_NEW.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;

import java.io.*;

/** 
 * A class to represent the S_GPROC32_NEW data structure.
 * 
 */
public class S_GPROC32_NEW extends DebugSymbol{
    private int    pParent;
	private int    pEnd;
	private int    pNext;
	private int    procLen;
	private int    debugStart;
	private int    debugEnd;
	private int    procOffset; //offset to start of procedure...
	private short  procType;
	
    static S_GPROC32_NEW createS_GPROC32_NEW(short length, short type,
            FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
        S_GPROC32_NEW s_gproc32_new = (S_GPROC32_NEW) reader.getFactory().create(S_GPROC32_NEW.class);
        s_gproc32_new.initS_GPROC32_NEW(length, type, reader, ptr);
        return s_gproc32_new;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public S_GPROC32_NEW() {}

	private void initS_GPROC32_NEW(short length, short type, FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
		processDebugSymbol(length, type);
		pParent      = reader.readInt(ptr); ptr += BinaryReader.SIZEOF_INT;
		pEnd         = reader.readInt(ptr); ptr += BinaryReader.SIZEOF_INT;
		pNext        = reader.readInt(ptr); ptr += BinaryReader.SIZEOF_INT;
		procLen      = reader.readInt(ptr); ptr += BinaryReader.SIZEOF_INT;
		debugStart   = reader.readInt(ptr); ptr += BinaryReader.SIZEOF_INT;
		debugEnd     = reader.readInt(ptr); ptr += BinaryReader.SIZEOF_INT;
		offset       = reader.readInt(ptr); ptr += BinaryReader.SIZEOF_INT;
		procOffset   = reader.readInt(ptr); ptr += BinaryReader.SIZEOF_INT;
		section      = reader.readShort(ptr); ptr += BinaryReader.SIZEOF_SHORT;
		procType     = reader.readShort(ptr); ptr += BinaryReader.SIZEOF_SHORT;
		name         = reader.readAsciiString(ptr); ptr += name.length();
	}

	public int getParent() {
		return pParent;
	}
	public int getEnd() {
		return pEnd;
	}
	public int getNext() {
		return pNext;
	}
	public int getDebugStart() {
		return debugStart;
	}
	public int getDebugEnd() {
		return debugEnd;
	}

	/**
	 * Returns the procedure length.
	 * @return the procedure length
	 */
	public int getProcLen() {
		return procLen;
	}

	/**
	 * Returns the procedure type.
	 * @return the procedure type
	 */
	public short getProcType() {
		return procType;
	}

	/**
	 * Returns the procedure offset.
	 * @return the procedure offset
	 */
	public int getProcOffset() {
		return procOffset;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/S_LABEL32.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;
import ghidra.util.*;

import java.io.*;

/**
 * 
 */
class S_LABEL32 extends DebugSymbol {
    private byte flags;
	
    static S_LABEL32 createS_LABEL32(short length, short type,
            FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
        S_LABEL32 s_label32 = (S_LABEL32) reader.getFactory().create(S_LABEL32.class);
        s_label32.initS_LABEL32(length, type, reader, ptr);
        return s_label32;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public S_LABEL32() {}

    private void initS_LABEL32(short length, short type, FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
		processDebugSymbol(length, type);
		
		offset  = reader.readInt(ptr);   ptr += BinaryReader.SIZEOF_INT;
		section = reader.readShort(ptr); ptr += BinaryReader.SIZEOF_SHORT;
		flags   = reader.readByte(ptr);  ptr += BinaryReader.SIZEOF_BYTE;
		
		byte nameLen = reader.readByte(ptr); ptr += BinaryReader.SIZEOF_BYTE;
		name = reader.readAsciiString(ptr, Conv.byteToInt(nameLen)); 
		Msg.debug(this, "Created label symbol: " +name);
		
	}
	/**
	 * @return the flags of this S_LABEL32 symbol
	 */
	byte getFlags() {
		return flags;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/S_LDATA32_NEW.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;
import ghidra.util.*;

import java.io.*;

/**
 * 
 */
class S_LDATA32_NEW extends DebugSymbol{
    private int reserved;
	private byte [] padding;

    static S_LDATA32_NEW createS_LDATA32_NEW(short length, short type,
            FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
        S_LDATA32_NEW s_ldata32_new = (S_LDATA32_NEW) reader.getFactory().create(S_LDATA32_NEW.class);
        s_ldata32_new.initS_LDATA32_NEW(length, type, reader, ptr);
        return s_ldata32_new;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public S_LDATA32_NEW() {}

    private void initS_LDATA32_NEW(short length, short type, FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
		processDebugSymbol(length, type);
		reserved = reader.readInt  (ptr); ptr+=BinaryReader.SIZEOF_INT;
		offset   = reader.readInt  (ptr); ptr+=BinaryReader.SIZEOF_INT;
		section  = reader.readShort(ptr); ptr+=BinaryReader.SIZEOF_SHORT;

		byte nameLen = reader.readByte(ptr); ptr += BinaryReader.SIZEOF_BYTE;

		this.name = reader.readAsciiString(ptr, Conv.byteToInt(nameLen));
		ptr+=nameLen;

		int sizeOfPadding = Conv.shortToInt(length) - 
							BinaryReader.SIZEOF_SHORT - 
							BinaryReader.SIZEOF_INT - 
							BinaryReader.SIZEOF_INT - 
							BinaryReader.SIZEOF_SHORT - 
							BinaryReader.SIZEOF_BYTE - 
							Conv.byteToInt(nameLen);
		
		padding = reader.readByteArray(ptr, sizeOfPadding);
	}

	public int getReserved() {
		return reserved;
	}
	public byte [] getPadding() {
		return padding;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/S_OBJNAME.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;
import ghidra.util.*;

import java.io.*;

/**
 * 
 */
class S_OBJNAME extends DebugSymbol {
    private int signature;
	private byte nameLen;
	private byte [] padding;
	
    static S_OBJNAME createS_OBJNAME(short length, short type,
            FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
        S_OBJNAME s_objname = (S_OBJNAME) reader.getFactory().create(S_OBJNAME.class);
        s_objname.initS_OBJNAME(length, type, reader, ptr);
        return s_objname;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public S_OBJNAME() {}

    private void initS_OBJNAME(short length, short type, FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
		processDebugSymbol(length, type);

		signature = reader.readInt(ptr);  ptr += BinaryReader.SIZEOF_INT;
		nameLen = reader.readByte(ptr); ptr += BinaryReader.SIZEOF_BYTE;
		name = reader.readAsciiString(ptr, Conv.byteToInt(nameLen)); ptr += nameLen + 1;

		int sizeOfPadding = BinaryReader.SIZEOF_SHORT+ 
							BinaryReader.SIZEOF_INT+
							BinaryReader.SIZEOF_INT+
							BinaryReader.SIZEOF_INT+
							BinaryReader.SIZEOF_BYTE+
							Conv.byteToInt(nameLen)+1;

		padding = reader.readByteArray(ptr, sizeOfPadding);
	}

	public int getSignature() {
		return signature;
	}
	public byte getNameLen() {
		return nameLen;
	}
	public byte [] getPadding() {
		return padding;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/S_PROCREF.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;
import ghidra.util.*;

import java.io.*;

class S_PROCREF extends DebugSymbol {
    private int module;
	private int checksum;
	private int paddingLen;

    static S_PROCREF createS_PROCREF(short length, short type,
            FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
        S_PROCREF s_procref = (S_PROCREF) reader.getFactory().create(S_PROCREF.class);
        s_procref.initS_PROCREF(length, type, reader, ptr);
        return s_procref;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public S_PROCREF() {}

	private void initS_PROCREF(short length, short type, FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
		processDebugSymbol(length, type);

//		if (type != DebugCodeViewConstants.S_PROCREF) {
//			throw new IllegalArgumentException("Incorrect type!");
//		}

		checksum = reader.readInt(ptr); ptr += BinaryReader.SIZEOF_INT;
		offset   = reader.readInt(ptr); ptr += BinaryReader.SIZEOF_INT;
		module   = reader.readInt(ptr); ptr += BinaryReader.SIZEOF_INT;

		if (checksum == 0) {
			byte nameLen = reader.readByte (ptr); ptr += BinaryReader.SIZEOF_BYTE;

			name = reader.readAsciiString(ptr, Conv.byteToInt(nameLen));

			ptr += Conv.byteToInt(nameLen);

			int val = ptr & 0xf; 

			switch (val) {
				case 0x1:
				case 0x2:
				case 0x3:
					paddingLen = 0x4 - val;
					break;
				case 0x5:
				case 0x6:
				case 0x7:
					paddingLen = 0x8 - val;
					break;
				case 0x9:
				case 0xa:
				case 0xb:
					paddingLen = 0xc - val;
					break;
				case 0xd:
				case 0xe:
				case 0xf:
					paddingLen = 0x10 - val;
					break;
			}

			ptr += paddingLen;
		} 
	}

	public int getModule() {
		return module;
	}
	public int getChecksum() {
		return checksum;
	}

	@Override
    public short getLength() {
		short len = super.getLength();
		if (checksum == 0) {
			 len += BinaryReader.SIZEOF_BYTE + name.length()+ paddingLen;
		}
		return len;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/S_UDT32.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;
import ghidra.util.*;

import java.io.*;

/**
 * 
 */
class S_UDT32 extends DebugSymbol {
    private int checksum;
	private byte typeLen;
	
    static S_UDT32 createS_UDT32(short length, short type,
            FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
        S_UDT32 s_udt32 = (S_UDT32) reader.getFactory().create(S_UDT32.class);
        s_udt32.initS_UDT32(length, type, reader, ptr);
        return s_udt32;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public S_UDT32() {}

	private void initS_UDT32(short length, short type, FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
		processDebugSymbol(length, type);

		if (type != DebugCodeViewConstants.S_UDT32) {
			throw new IllegalArgumentException("Incorrect type!");
		}

		this.checksum = reader.readInt(ptr); ptr += BinaryReader.SIZEOF_INT;
		this.typeLen  = reader.readByte(ptr); ptr += BinaryReader.SIZEOF_BYTE;
		this.name     = reader.readAsciiString(ptr, Conv.byteToInt(typeLen));
	}

	public int getChecksum() {
		return checksum;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/S_UDT32_NEW.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.*;
import ghidra.app.util.bin.format.*;
import ghidra.util.*;

import java.io.*;

/**
 * 
 */
class S_UDT32_NEW extends DebugSymbol {
    private int symType;

    static S_UDT32_NEW createS_UDT32_NEW(short length, short type,
            FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
        S_UDT32_NEW s_udt32_new = (S_UDT32_NEW) reader.getFactory().create(S_UDT32_NEW.class);
        s_udt32_new.initS_UDT32_NEW(length, type, reader, ptr);
        return s_udt32_new;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public S_UDT32_NEW() {}

	private void initS_UDT32_NEW(short length, short type, FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
		processDebugSymbol(length, type);

		symType = reader.readInt(ptr); ptr += BinaryReader.SIZEOF_INT;

		byte nameLen = reader.readByte(ptr); ptr += BinaryReader.SIZEOF_BYTE;

		name = reader.readAsciiString(ptr, Conv.byteToInt(nameLen));	
	}

	/**
	 * @return symType - the type of symbol
	 */
	int getSymType() {
		return symType;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/debug/UnknownSymbol.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.debug;

import ghidra.app.util.bin.format.*;
import ghidra.util.*;

import java.io.*;

/**
 * 
*/
class UnknownSymbol extends DebugSymbol{
    private byte [] unknown;

    static UnknownSymbol createUnknownSymbol(short length, short type,
            FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
        UnknownSymbol unknownSymbol = (UnknownSymbol) reader.getFactory().create(UnknownSymbol.class);
        unknownSymbol.initUnknownSymbol(length, type, reader, ptr);
        return unknownSymbol;
    }

    /**
     * DO NOT USE THIS CONSTRUCTOR, USE create*(GenericFactory ...) FACTORY METHODS INSTEAD.
     */
    public UnknownSymbol() {}

	private void initUnknownSymbol(short length, short type, FactoryBundledWithBinaryReader reader, int ptr) throws IOException {
		processDebugSymbol(length, type);
		try {
			unknown = reader.readByteArray(ptr, Conv.shortToInt(length));
		}
		catch (RuntimeException e) {
		    Msg.error(this, "Unexpected Exception: " + e.getMessage(), e);
		}
	}

	public byte[] getUnknown() {
		return unknown;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/package.html`:

```html
<html>
<body>
Classes for parsing PE headers.
</body>
</html>

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/resource/ResourceDataEntry.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.resource;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.StructConverter;
import ghidra.app.util.bin.format.*;
import ghidra.program.model.data.*;
import ghidra.util.exception.DuplicateNameException;

import java.io.IOException;

/**
 * <pre>
 * typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
 *     DWORD   OffsetToData;
 *     DWORD   Size;
 *     DWORD   CodePage;
 *     DWORD   Reserved;
 * };
 * </pre>
 */
public class ResourceDataEntry implements StructConverter {
	public final static String NAME = "IMAGE_RESOURCE_DATA_ENTRY";
	public final static int SIZEOF = 16;

    private int offsetToData;
    private int size;
    private int codePage;
    private int reserved;
	/**
	 * Constructor.
	 * @param reader the binary reader
	 * @param index the index where this entry begins
	 */
    public ResourceDataEntry(FactoryBundledWithBinaryReader reader, int index) throws IOException {
        offsetToData = reader.readInt(index);
        size         = reader.readInt(index += BinaryReader.SIZEOF_INT);
        codePage     = reader.readInt(index += BinaryReader.SIZEOF_INT);
        reserved     = reader.readInt(index += BinaryReader.SIZEOF_INT);
    }
	/**
	 * Returns the offset, relative to the beginning of the resource
	 * directory of the data for the resource.
	 * @return the offset, relative to the beginning of the resource directory
	 */
    public int getOffsetToData() {
        return offsetToData;
    }
    /**
     * Returns a size field that gives the number of bytes of data at that offset.
     * @return a size field that gives the number of bytes of data at that offset,
     */
    public int getSize() {
        return size;
    }
    /**
     * @return a CodePage that should be used when decoding the resource data
     */
    public int getCodePage() {
        return codePage;
    }
    /**
     * Reserved, use unknown.
     * @return reserved, use unknown
     */
    public int getReserved() {
        return reserved;
    }

	public DataType toDataType() throws DuplicateNameException, IOException {
		StructureDataType struct = new StructureDataType(NAME, 0);
		struct.add(DWORD, "OffsetToData", null);
		struct.add(DWORD, "Size",         null);
		struct.add(DWORD, "CodePage",     null);
		struct.add(DWORD, "Reserved",     null);
		struct.setCategoryPath(new CategoryPath("/PE"));
		return struct;
	}

    @Override
    public String toString() {
    	return "0x"+Integer.toHexString(offsetToData)+" - 0x"+Integer.toHexString(size);
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/resource/ResourceDirectory.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.resource;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.StructConverter;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import net.jubjubnest.minidump.contrib.pe.NTHeader;
import net.jubjubnest.minidump.contrib.pe.ResourceDataDirectory;
import ghidra.program.model.data.CategoryPath;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.StructureDataType;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * <pre>
 * typedef struct _IMAGE_RESOURCE_DIRECTORY {
 *     DWORD   Characteristics;
 *     DWORD   TimeDateStamp;
 *     WORD    MajorVersion;
 *     WORD    MinorVersion;
 *     WORD    NumberOfNamedEntries;
 *     WORD    NumberOfIdEntries;
 * };
 * </pre>
 */
public class ResourceDirectory implements StructConverter {
	public final static String NAME = "IMAGE_RESOURCE_DIRECTORY";
	public final static int SIZEOF = 16;

    private int    characteristics;
    private int    timeDataStamp;
    private short  majorVersion;
    private short  minorVersion;
    private short  numberOfNamedEntries;
    private short  numberOfIdEntries;
    private ArrayList<ResourceDirectoryEntry> entries = new ArrayList<ResourceDirectoryEntry>();

    public ResourceDirectory(FactoryBundledWithBinaryReader reader, 
    						int index, 
    						int resourceBase, 
    						boolean isFirstLevel,
    						NTHeader ntHeader) throws IOException {

    	if (!ntHeader.checkPointer(index)) {
        	Msg.error(this, "Invalid file index "+Integer.toHexString(index));
        	return;	
    	}
    	if (ResourceDataDirectory.directoryMap.contains(index)) {
    		Msg.error(this, "Duplicate ResourceDirectory at "+index+" ignored.");
    		return;
    	}
    	ResourceDataDirectory.directoryMap.add(index);
    	
    	characteristics      = reader.readInt  (index); index += BinaryReader.SIZEOF_INT;
        timeDataStamp        = reader.readInt  (index); index += BinaryReader.SIZEOF_INT;
        majorVersion         = reader.readShort(index); index += BinaryReader.SIZEOF_SHORT;
        minorVersion         = reader.readShort(index); index += BinaryReader.SIZEOF_SHORT;
        numberOfNamedEntries = reader.readShort(index); index += BinaryReader.SIZEOF_SHORT;
        numberOfIdEntries    = reader.readShort(index); index += BinaryReader.SIZEOF_SHORT;

        long rva = index + (numberOfNamedEntries+numberOfIdEntries) * ResourceDataDirectory.IMAGE_SIZEOF_RESOURCE_DIRECTORY_ENTRY;
	    if (!ntHeader.checkRVA(rva) || (0 > rva || rva > reader.length())) {
	   		Msg.error(this, "Too many resource entries "+Integer.toHexString(numberOfNamedEntries+numberOfIdEntries));
	   		numberOfNamedEntries = numberOfIdEntries = 0;
	    }
	    for (int i = 0 ; i < numberOfNamedEntries ; ++i) {
        	if (!ntHeader.checkPointer(index)) {
            	Msg.error(this, "Invalid file index "+Integer.toHexString(index));
        		return;	
        	}
	    	ResourceDirectoryEntry entry = new ResourceDirectoryEntry(reader, index, resourceBase, true, isFirstLevel, ntHeader);
	    	if (!entry.isValid()) {
	           	return;
	    	}
			entries.add(entry);
	        index += ResourceDataDirectory.IMAGE_SIZEOF_RESOURCE_DIRECTORY_ENTRY;
		}
		for (int i = 0 ; i < numberOfIdEntries ; ++i) {
        	if (!ntHeader.checkPointer(index)) {
            	Msg.error(this, "Invalid file index "+Integer.toHexString(index));
        		return;	
        	}
			ResourceDirectoryEntry entry = new ResourceDirectoryEntry(reader, index, resourceBase, false, isFirstLevel, ntHeader);
	    	if (!entry.isValid()) {
	           	return;
	    	}
			entries.add(entry);
		    index += ResourceDataDirectory.IMAGE_SIZEOF_RESOURCE_DIRECTORY_ENTRY;
		}
    }

    public List<ResourceDirectoryEntry> getEntries() {
		return new ArrayList<ResourceDirectoryEntry>(entries);
	}

    /**
     * Theoretically, this field could hold flags for the resource, but appears to always be 0. 
     * @return the flags for the resource
     */
    public int getCharacteristics() {
        return characteristics;
    }
    /**
     * Returns the time/date stamp describing the creation time of the resource.
     * @return the time/date stamp describing the creation time of the resource
     */
    public int getTimeDataStamp() {
        return timeDataStamp;
    }
    /**
     * Returns the number of array elements that use names and that follow this structure. 
     * @return the number of array elements that use names and that follow this structure
     */
    public int getNumberOfNamedEntries() {
        return numberOfNamedEntries;
    }
    /**
     * Returns the number of array elements that use integer IDs, and which follow this structure. 
     * @return the number of array elements that use integer IDs, and which follow this structure
     */
    public int getNumberOfIdEntries() {
        return numberOfIdEntries;
    }
	/**
	 * Theoretically these fields would hold a version number for the resource.
	 * These field appear to always be set to 0.
	 * @return the major version number
	 */
	public short getMajorVersion() {
		return majorVersion;
	}
	/**
	 * Theoretically these fields would hold a version number for the resource.
	 * These field appear to always be set to 0.
	 * @return the minor version number
	 */
	public short getMinorVersion() {
		return minorVersion;
	}

	public DataType toDataType() throws DuplicateNameException, IOException {
		StructureDataType struct = new StructureDataType(NAME, 0);
		struct.add(DWORD, "Characteristics",      null);
		struct.add(DWORD, "TimeDateStamp",        null);
		struct.add( WORD, "MajorVersion",         null);
		struct.add( WORD, "MinorVersion",         null);
		struct.add( WORD, "NumberOfNamedEntries", null);
		struct.add( WORD, "NumberOfIdEntries",    null);
		struct.setCategoryPath(new CategoryPath("/PE"));
		return struct;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/resource/ResourceDirectoryEntry.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.resource;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.StructConverter;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import net.jubjubnest.minidump.contrib.pe.NTHeader;
import net.jubjubnest.minidump.contrib.pe.ResourceDataDirectory;
import ghidra.program.model.data.*;
import ghidra.util.Msg;
import ghidra.util.exception.DuplicateNameException;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * <pre>
 * typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
 *     union {
 *         struct {
 *             DWORD NameOffset:31;
 *             DWORD NameIsString:1;
 *         };
 *         DWORD   Name;
 *         WORD    Id;
 *     };
 *     union {
 *         DWORD   OffsetToData;
 *         struct {
 *             DWORD   OffsetToDirectory:31;
 *             DWORD   DataIsDirectory:1;
 *         };
 *     };
 * };
 * </pre>
 */
public class ResourceDirectoryEntry implements StructConverter {
	private final static String NAME = "IMAGE_RESOURCE_DIRECTORY_ENTRY";
	public final static int SIZEOF = 8;

	private boolean isNameEntry;
	private boolean isFirstLevel;
	private ResourceDirectoryStringU dirString;
	private ResourceDirectory subDirectory;
	private ResourceDataEntry data;

	private int nameOffset;
	private boolean nameIsString;
	private int name;
	private int id;
	private int offsetToData;
	private int offsetToDirectory;
	private boolean dataIsDirectory;

	private boolean isValid;

	/**
	 * Constructor.
	 * @param reader the binary reader
	 * @param index the index where this directory begins
	 */
	public ResourceDirectoryEntry(FactoryBundledWithBinaryReader reader, int index,
			int resourceBase, boolean isNameEntry, boolean isFirstLevel, NTHeader ntHeader)
			throws IOException {

		this.isNameEntry = isNameEntry;
		this.isFirstLevel = isFirstLevel;

		int irde1 = reader.readInt(index);
		int irde2 = reader.readInt(index + BinaryReader.SIZEOF_INT);

		nameOffset = irde1 & 0x7FFFFFFF;
		nameIsString = (irde1 & 0x80000000) != 0;
		if (nameOffset < 0) {
			Msg.error(this, "Invalid nameOffset " + nameOffset);
			return;
		}
		name = irde1;
		id = irde1 & 0xFFFF;

		offsetToData = irde2;
		offsetToDirectory = irde2 & 0x7FFFFFFF;
		dataIsDirectory = (irde2 & 0x80000000) != 0;

		if (nameIsString) {
			int nameptr = nameOffset + resourceBase;
			if (ntHeader.checkRVA(nameptr) || (0 < nameptr && nameptr < reader.length())) {
				dirString = new ResourceDirectoryStringU(reader, nameptr);
			}
			else {
				Msg.error(this, "Invalid nameOffset " + Integer.toHexString(nameOffset));
				return;
			}
		}
		else { // name is ID

		}
		if (dataIsDirectory) {
			int dirptr = offsetToDirectory + resourceBase;
			if (ntHeader.checkRVA(dirptr) || (0 < dirptr && dirptr < reader.length())) {
				subDirectory = new ResourceDirectory(reader, dirptr, resourceBase, false, ntHeader);
			}
			else {
				Msg.error(this,
					"Invalid offsetToDirectory " + Integer.toHexString(offsetToDirectory));
				return;
			}
		}
		else {
			int dataptr = offsetToData + resourceBase;
			if (ntHeader.checkRVA(dataptr) || (0 < dataptr && dataptr < reader.length())) {
				data = new ResourceDataEntry(reader, dataptr);
			}
			else {
				Msg.error(this, "Invalid offsetToData " + Integer.toHexString(offsetToData));
				return;
			}
		}

		isValid = true;
	}

	public List<ResourceInfo> getResources(int level) {
		ArrayList<ResourceInfo> resources = new ArrayList<ResourceInfo>();

		if (data != null) {
			resources.add(new ResourceInfo(data.getOffsetToData(), toString(), data.getSize()));
		}
		if (subDirectory != null) {
			List<ResourceDirectoryEntry> entries = subDirectory.getEntries();
			for (ResourceDirectoryEntry entry : entries) {
				List<ResourceInfo> entryResources = entry.getResources(level + 1);
				for (ResourceInfo info : entryResources) {
					resources.add(info);
					info.setName(toString() + "_" + info.getName());
					if (!isNameEntry) {
						if (level == 0) {
							info.setTypeID(id);
						}
						else if (level == 1) {
							info.setID(id);
						}
					}
				}
			}
		}
		return resources;
	}

	/**
	 * Returns true if the parent resource directory is named,
	 * false indicates an ID.
	 */
	public boolean isNameEntry() {
		return isNameEntry;
	}

	public ResourceDirectoryStringU getDirectoryString() {
		return dirString;
	}

	public ResourceDataEntry getData() {
		return data;
	}

	public ResourceDirectory getSubDirectory() {
		return subDirectory;
	}

	@Override
	public String toString() {
		if (isNameEntry && dirString != null) {
			return dirString.getNameString();
		}
		if (!isNameEntry && isFirstLevel && id <= ResourceDataDirectory.RT_MANIFEST) {
			return ResourceDataDirectory.PREDEFINED_RESOURCE_NAMES[id];
		}
		return Integer.toHexString(id);
	}

	/**
	 * Returns the offset to the name of this resource.
	 * @return the offset to the name of this resource
	 * @see #getName()
	 */
	public int getNameOffset() {
		return nameOffset;
	}

	/**
	 * Returns the ID of the name of this resource.
	 * @return the ID of the name of this resource
	 * @see #getName()
	 */
	public boolean getNameIsString() {
		return nameIsString;
	}

	/**
	 * @return either an integer ID or a pointer to a structure that contains a string name
	 */
	public int getName() {
		return name;
	}

	/**
	 * Returns a resource ID.
	 * @return a resource ID
	 * @see #getName()
	 */
	public int getId() {
		return id;
	}

	/**
	 * @return either an offset to another resource directory 
	 *         or a pointer to information about a specific resource instance
	 */
	public int getOffsetToData() {
		return offsetToData;
	}

	/**
	 * Returns an offset to another resource directory.
	 * @return an offset to another resource directory
	 * @see #getOffsetToData()
	 */
	public int getOffsetToDirectory() {
		return offsetToDirectory;
	}

	/**
	 * Returns a pointer to information about a specific resource instance.
	 * @return a pointer to information about a specific resource instance
	 * @see #getOffsetToData()
	 */
	public boolean getDataIsDirectory() {
		return dataIsDirectory;
	}

	@Override
	public DataType toDataType() throws DuplicateNameException, IOException {
		StructureDataType nameStruct = new StructureDataType(NAME + "_" + "NameStruct", 0);
		nameStruct.add(DWORD, "NameOffset", null);
		nameStruct.add(DWORD, "NameIsString", null);
		nameStruct.setCategoryPath(new CategoryPath("/PE"));

		UnionDataType union1 = new UnionDataType(NAME + "_" + "NameUnion");
		union1.add(nameStruct, nameStruct.getName(), null);
		union1.add(DWORD, "Name", null);
		union1.add(WORD, "Id", null);
		union1.setCategoryPath(new CategoryPath("/PE"));

		StructureDataType offsetStruct = new StructureDataType(NAME + "_" + "DirectoryStruct", 0);
		offsetStruct.add(DWORD, "OffsetToDirectory", null);
		offsetStruct.add(DWORD, "DataIsDirectory", null);

		UnionDataType union2 = new UnionDataType(NAME + "_" + "DirectoryUnion");
		union2.add(DWORD, "OffsetToData", null);
		union2.add(offsetStruct, offsetStruct.getName(), null);

		UnionDataType union3 = new UnionDataType(NAME);
		union3.add(union1, "NameUnion", null);
		union3.add(union2, "DirectoryUnion", null);

		union3.setCategoryPath(new CategoryPath("/PE"));
		return union3;
	}

	public boolean isValid() {
		return isValid;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/resource/ResourceDirectoryString.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.resource;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.StructConverter;
import ghidra.program.model.data.*;
import ghidra.util.exception.DuplicateNameException;

import java.io.IOException;

/**
 * <pre>
 * typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {
 *     WORD    Length;
 *     CHAR    NameString[ 1 ];
 * };
 * </pre>
 */
public class ResourceDirectoryString implements StructConverter {
	public final static String NAME = "IMAGE_RESOURCE_DIRECTORY_STRING";

    private short  length;
    private String nameString;

    /**
     * Constructor.
     * @param reader the binary reader
     * @param index the index where this resource string begins
     */
    public ResourceDirectoryString(BinaryReader reader, int index) throws IOException {
        length = reader.readShort(index);
        nameString = reader.readAsciiString(index+BinaryReader.SIZEOF_SHORT);
        if (nameString.length() != length) {
            //todo:
            throw new IllegalArgumentException("name string length != length");
        }
    }

    /**
     * Returns the length of the string, in bytes.
     * @return the length of the string, in bytes
     */
    public short getLength() {
        return length;
    }

    /**
     * Returns the resource name string.
     * @return the resource name string
     */
    public String getNameString() {
        return nameString;
    }

	public DataType toDataType() throws DuplicateNameException, IOException {
		StructureDataType struct = new StructureDataType(NAME+"_"+length, 0);
		struct.add(WORD, "Length", null);
		struct.add(STRING, length, "NameString", null);
		struct.setCategoryPath(new CategoryPath("/PE"));
		return struct;
	}

    @Override
    public String toString() {
    	return nameString;
    }
}


```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/resource/ResourceDirectoryStringU.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.resource;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.StructConverter;
import ghidra.app.util.bin.format.*;
import ghidra.program.model.data.*;
import ghidra.util.exception.DuplicateNameException;

/**
 * <pre>
 * typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
 *     WORD    Length;
 *     WCHAR   NameString[ 1 ];
 * };
 * </pre>
 */
public class ResourceDirectoryStringU implements StructConverter {
	public final static String NAME = "IMAGE_RESOURCE_DIR_STRING_U";

    private short  length;
    private String nameString;

    /**
	 * Constructor.
	 * @param reader the binary reader
	 * @param index the index where this resource string begins
	 */
    public ResourceDirectoryStringU(FactoryBundledWithBinaryReader reader, int index) throws IOException {
        length = reader.readShort(index);
        nameString = reader.readUnicodeString(index+BinaryReader.SIZEOF_SHORT, length);
    }

    /**
	 * Returns the length of the string, in bytes.
	 * @return the length of the string, in bytes
	 */
    public short getLength() {
        return length;
    }

    /**
	 * Returns the resource name string.
	 * @return the resource name string
	 */
    public String getNameString() {
        return nameString;
    }

	public DataType toDataType() throws DuplicateNameException, IOException {
		StructureDataType struct = new StructureDataType(NAME+"_"+(length*2), 0);
		struct.add(WORD, "Length", null);
		struct.add(UTF16, length*2, "NameString", null);
		struct.setCategoryPath(new CategoryPath("/PE"));
		return struct;
	}

    @Override
    public String toString() {
    	return nameString;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/resource/ResourceInfo.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.resource;

/**
 * A class to hold the information extracted from a 
 * resource data directory.
 * 
 * NOTE:
 * This class is simply a storage class created for 
 * parsing the PE header data structures.
 * It does not map back to a PE data data structure.
 */
public class ResourceInfo implements Comparable<ResourceInfo> {
    private int address;
    private String name;
    private int size;
    private int typeID;
    private int id;

    /**
     * Constructor.
     * @param address the adjusted address where the resource exists
     * @param name    the name of the resource
     * @param size    the size of the resource
     */
    public ResourceInfo(int address, String name, int size) {
        this.address   = address;
        this.name      = name;
        this.size      = size;
    }
	/**
	 * Returns the adjusted address where the resource exists.
	 * @return the adjusted address where the resource exists
	 */
    public int getAddress() {
        return address;
    }
	/**
	 * Returns the name of the resource.
	 * @return the name of the resource
	 */
    public String getName() {
        return name;
    }
	public void setName(String name) {
		this.name = name;
	}
    /**
     * Returns the size of the resource.
     * @return the size of the resource
     */
    public int getSize() {
        return size;
    }
    /**
     * Returns the ID of the resource.
     * @return the ID of the resource
     */
    public int getID() {
        return id;
    }
    public void setID(int id) {
		this.id = id;
	}
    /**
     * Returns the resource type ID.
     * For example, RT_CURSOR, RT_BITMAP, etc.
     * Returns -1 if this is a named resource.
     */
    public int getTypeID() {
		return typeID;
	}
    public void setTypeID(int typeID) {
		this.typeID = typeID;
	}

    @Override
    public String toString() {
    	return name+" - 0x"+Integer.toHexString(address);
    }

    public int compareTo(ResourceInfo that) {
    	return this.typeID - that.typeID;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/resource/ResourceStringInfo.java`:

```java
/* ###
 * IP: GHIDRA
 * REVIEWED: YES
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.resource;

/**
 * A class to hold the information extracted from a 
 * resource data directory.
 * 
 * NOTE:
 * This class is simply a storage class created for 
 * parsing the PE header data structures.
 * It does not map back to a PE data data structure.
 * 
 * 
 */
public class ResourceStringInfo {
    private int address;
    private String string;
    private int length;
    /**
     * Constructor.
     * @param address the adjusted address where the resource exists
     * @param string the resource string
     * @param length the length of the resource
     */
	public ResourceStringInfo(int address, String string, int length) {
        this.address = address;
        this.string = string;
        this.length = length;
	}
	/**
	 * Returns the adjusted address where the resource exists.
	 * @return the adjusted address where the resource exists
	 */
    public int getAddress() {
        return address;
    }
    /**
     * Returns the resource string.
     * @return the resource string
     */
    public String getString() {
        return string;
    }
    /**
     * Returns the length of the resource.
     * @return the length of the resource
     */
    public int getLength() {
        return length;
    }
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/resource/VS_VERSION_CHILD.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.resource;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;

import ghidra.app.util.bin.StructConverter;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.program.model.data.*;
import ghidra.util.exception.DuplicateNameException;

/**
 * A class to represent the VS_VERSION_CHILD data structure which generally corresponds 
 * to either StringFileInfo or VarFileInfo.  Only a single instance of each childName
 * is expected.
 */
public class VS_VERSION_CHILD implements StructConverter {
	private String parentName;
	private long relativeOffset; // offset relative to start of parent structure
	private String childName;
	private short childSize;
	private short childValueSize;
	private short childValueType;

	private String childDataType;

	private int valueAlignment;
	private String childValue; // will be null if this has children

	private ArrayList<VS_VERSION_CHILD> children;

	VS_VERSION_CHILD(FactoryBundledWithBinaryReader reader, long relativeOffset, String parentName,
			HashMap<String, String> valueMap) throws IOException {
		this.relativeOffset = relativeOffset;
		this.parentName = parentName;
		long origIndex = reader.getPointerIndex();

		childSize = reader.readNextShort();

		if (childSize == 0) {
			return;
		}

		childValueSize = reader.readNextShort();
		childValueType = reader.readNextShort();

		childName = reader.readNextUnicodeString();

		valueAlignment = reader.align(4);

		boolean hasChildren = false;
		if (parentName == null) {
			childDataType = childName;
			hasChildren = true;
		}
		else if ("StringFileInfo".equals(parentName)) {
			childDataType = "StringTable";
			hasChildren = true;
		}
		else if ("VarFileInfo".equals(parentName)) {
			childDataType = "Var";
			if (childValueSize > 0) {
				childValue = Integer.toHexString(reader.readNextInt());
			}
		}
		else if ("StringTable".equals(parentName)) {
			// Should be called "String" but this may conflict with other String types
			// Also, we have seen some PE's where the childValueType of this is 0, so we can't
			// rely on that to know if we should read an integer or a string.  This field is 
			// always a string regardless of the specified type.
			childDataType = "StringInfo";
			if (childValueSize > 0) {
				childValue = reader.readNextUnicodeString();
			}
		}


		if (hasChildren) {
			while (reader.getPointerIndex() < origIndex + childSize) {
				VS_VERSION_CHILD child = new VS_VERSION_CHILD(reader,
					reader.getPointerIndex() - origIndex, childDataType, valueMap);
				if (children == null) {
					children = new ArrayList<VS_VERSION_CHILD>();
				}
				children.add(child);
			}
		}
		else {
			if (childValueSize > 0 && childValue != null) {
				valueMap.put(childName, childValue);
			}
		}
	}

	@Override
	public DataType toDataType() throws DuplicateNameException {
		if (childName == null || childDataType == null) {
			return null;
		}
		StructureDataType struct = new StructureDataType(childDataType, 0);
		struct.add(WORD, "wLength", null);
		struct.add(WORD, "wValueLength", null);
		struct.add(WORD, "wType", null);
		struct.setCategoryPath(new CategoryPath("/PE"));
		return struct;
	}

	/**
	 * Returns the array of children
	 * @return the array of children
	 */
	public VS_VERSION_CHILD[] getChildren() {
		VS_VERSION_CHILD[] arr = new VS_VERSION_CHILD[children.size()];
		children.toArray(arr);
		return arr;
	}

	/**
	 * Return structure offset relative to parent structure start
	 * @return relative offset
	 */
	public long getRelativeOffset() {
		return relativeOffset;
	}

	/**
	 * Returns the version child name.
	 * @return the version child name
	 */
	public String getChildName() {
		return childName;
	}

	/**
	 * Returns the version child size.
	 * @return the version child size
	 */
	public short getChildSize() {
		return childSize;
	}

	/**
	 * Return value offset relative to parent structure start.
	 * @return relative value offset or 0 if no value exists
	 */
	public long getValueRelativeOffset() {
		if (childValue == null) {
			return 0;
		}
		return ((childName.length() + 1) * 2) + valueAlignment + 6;
	}

	/**
	 * Return unicode name string offset relative to parent structure start
	 * @return relative name offset or 0 if data type is unknown
	 */
	public long getNameRelativeOffset() {
		if (childSize == 0) {
			return 0;
		}
		return 6;
	}

	/**
	 * @return true if value is unicode string
	 */
	public boolean valueIsUnicodeString() {
		return childValue != null && "StringInfo".equals(childDataType);
	}

	/**
	 * @return true if value is 4-byte integer value in memory 
	 * while string value return by {@link DataType#getValue(ghidra.program.model.mem.MemBuffer, ghidra.docking.settings.Settings, int)
	 * DataType.getValue(MemBuffer, Settings, int)} is a numeric hex string.
	 */
	public boolean valueIsDWord() {
		return childValue != null && "Var".equals(childDataType);
	}

	/**
	 * @return true if this child has children
	 */
	public boolean hasChildren() {
		return children != null;
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/resource/VS_VERSION_INFO.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.resource;

import ghidra.app.util.bin.StructConverter;
import ghidra.app.util.bin.format.FactoryBundledWithBinaryReader;
import ghidra.program.model.data.*;
import ghidra.util.exception.DuplicateNameException;

import java.io.IOException;
import java.util.*;

/**
 * A class to represent the VS_VERSION_INFO data structure.
 */
public class VS_VERSION_INFO implements StructConverter {
	public final static String NAME = "VS_VERSION_INFO";
	public final static int SIZEOF = 92;

	private short structLength;
	private short valueLength;
	private short structType;
	private String info;
	private int alignment;
	private int signature;
	private String structVersion;
	private String fileVersion;
	private String productVersion;
	private String fileFlagsMask;
	private int fileFlags;
	private int fileOS;
	private int fileType;
	private int fileSubtype;
	private int fileTimestamp;

	private ArrayList<VS_VERSION_CHILD> children = new ArrayList<VS_VERSION_CHILD>();
	private HashMap<String, String> valueMap = new HashMap<String, String>();

	/**
	 * Constructs a new VS_VERSION_INFO object.
	 * @param reader the binary reader
	 * @param index the index where the VS_VERSION_INFO begins
	 * @throws IOException if an I/O error occurs
	 */
	public VS_VERSION_INFO(FactoryBundledWithBinaryReader reader, int index) throws IOException {
		long oldIndex = reader.getPointerIndex();
		reader.setPointerIndex(index);

		structLength = reader.readNextShort();
		valueLength = reader.readNextShort();
		structType = reader.readNextShort();
		info = reader.readNextUnicodeString();

		alignment = reader.align(4);

		// start of VS_FIXEDFILEINFO
		signature = reader.readNextInt();
		structVersion = shortArrayToString(reader, 2);
		fileVersion = shortArrayToString(reader, 4);
		productVersion = shortArrayToString(reader, 4);
		fileFlagsMask = intArrayToString(reader, 2);
		fileFlags = reader.readNextInt();
		fileOS = reader.readNextInt();
		fileType = reader.readNextInt();
		fileSubtype = reader.readNextInt();
		fileTimestamp = reader.readNextInt();

		while (reader.getPointerIndex() < index + structLength) {
			// TODO: is alignment needed?
			children.add(new VS_VERSION_CHILD(reader, reader.getPointerIndex() - index, null,
				valueMap));
		}

		reader.setPointerIndex(oldIndex);
	}

	public DataType toDataType() throws DuplicateNameException {
		StructureDataType struct = new StructureDataType(NAME, 0);
		struct.add(WORD, "StructLength", null);
		struct.add(WORD, "ValueLength", null);
		struct.add(WORD, "StructType", null);
		struct.add(UTF16, (info.length() + 1) * 2, "Info", null);
		if (alignment > 0) {
			struct.add(new ArrayDataType(BYTE, alignment, BYTE.getLength()), "Padding", null);
		}
		struct.add(DWORD, "Signature", null);
		struct.add(new ArrayDataType(WORD, 2, WORD.getLength()), "StructVersion", null);
		struct.add(new ArrayDataType(WORD, 4, WORD.getLength()), "FileVersion", null);
		struct.add(new ArrayDataType(WORD, 4, WORD.getLength()), "ProductVersion", null);
		struct.add(new ArrayDataType(DWORD, 2, DWORD.getLength()), "FileFlagsMask", null);
		struct.add(DWORD, "FileFlags", null);
		struct.add(DWORD, "FileOS", null);
		struct.add(DWORD, "FileType", null);
		struct.add(DWORD, "FileSubtype", null);
		struct.add(DWORD, "FileTimestamp", null);
		struct.setCategoryPath(new CategoryPath("/PE"));
		return struct;
	}

	/**
	 * Returns the array of VS_VERSION_CHILD defined in this VS_VERSION_INFO object.
	 * @return the array of VS_VERSION_CHILD defined in this VS_VERSION_INFO object
	 */
	public VS_VERSION_CHILD[] getChildren() {
		VS_VERSION_CHILD[] arr = new VS_VERSION_CHILD[children.size()];
		children.toArray(arr);
		return arr;
	}

	/**
	 * Returns the file flags.
	 * @return the file flags
	 */
	public int getFileFlags() {
		return fileFlags;
	}

	/**
	 * Returns the file flags mask.
	 * @return the file flags mask
	 */
	public String getFileFlagsMask() {
		return fileFlagsMask;
	}

	/**
	 * Returns the file OS.
	 * @return the file OS
	 */
	public int getFileOS() {
		return fileOS;
	}

	/**
	 * Returns the file sub-type.
	 * @return the file sub-type
	 */
	public int getFileSubtype() {
		return fileSubtype;
	}

	/**
	 * Returns the file timestamp.
	 * @return the file timestamp
	 */
	public int getFileTimestamp() {
		return fileTimestamp;
	}

	/**
	 * Returns the file type.
	 * @return the file type
	 */
	public int getFileType() {
		return fileType;
	}

	/**
	 * Returns the file version.
	 * @return the file version
	 */
	public String getFileVersion() {
		return fileVersion;
	}

	/**
	 * Returns the info.
	 * @return the info
	 */
	public String getInfo() {
		return info;
	}

	/**
	 * Returns the product version.
	 * @return the product version
	 */
	public String getProductVersion() {
		return productVersion;
	}

	/**
	 * Returns the signature.
	 * @return the signature
	 */
	public int getSignature() {
		return signature;
	}

	/**
	 * Returns the structure length.
	 * @return the structure length
	 */
	public short getStructLength() {
		return structLength;
	}

	/**
	 * Returns the structure type.
	 * @return the structure type
	 */
	public short getStructType() {
		return structType;
	}

	/**
	 * Returns the structure version.
	 * @return the structure version
	 */
	public String getStructVersion() {
		return structVersion;
	}

	/**
	 * Returns the value length.
	 * @return the value length
	 */
	public short getValueLength() {
		return valueLength;
	}

	/**
	 * Returns the array of keys in this version child.
	 * @return the array of keys in this version child
	 */
	public String[] getKeys() {
		String[] keys = new String[valueMap.size()];
		Iterator<String> iter = valueMap.keySet().iterator();
		int i = 0;
		while (iter.hasNext()) {
			keys[i++] = iter.next();
		}
		Arrays.sort(keys);
		return keys;
	}

	/**
	 * Returns the value for the specified key.
	 * @param key the key
	 * @return the value for the specified key
	 */
	public String getValue(String key) {
		return valueMap.get(key);
	}

	static String shortArrayToString(FactoryBundledWithBinaryReader reader, int nElements)
			throws IOException {
		if (nElements == 2) {
			short[] arr = reader.readNextShortArray(2);
			return arr[1] + "." + arr[0];
		}
		else if (nElements == 4) {
			short[] arr = reader.readNextShortArray(4);
			return arr[1] + "." + arr[0] + "." + arr[3] + "." + arr[2];
		}
		return null;
	}

	static String intArrayToString(FactoryBundledWithBinaryReader reader, int nElements)
			throws IOException {
		if (nElements == 2) {
			int[] arr = reader.readNextIntArray(2);
			return arr[1] + "." + arr[0];
		}
		else if (nElements == 4) {
			int[] arr = reader.readNextIntArray(4);
			return arr[1] + "." + arr[0] + "." + arr[3] + "." + arr[2];
		}
		return null;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/resource/package.html`:

```html
<html>
<body>
Classes for parsing PE resource data structures.
</body>
</html>

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/rich/CompId.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.rich;

public class CompId {
	private final int id;
	private final int productId;
	private final int buildNumber;

	public CompId(int id) {
		this.id = id;
		this.productId = id >> 16;
		this.buildNumber = id & 0x0000FFFF;
	}

	public int getValue() {
		return id;
	}

	public int getProductId() {
		return productId;
	}

	public String getProductDescription() {

		RichProduct prod = RichHeaderUtils.getProduct(getProductId());

		StringBuilder sb = new StringBuilder();

		String prodVersion =
			prod == null ? "Unknown Product (" + Integer.toHexString(getProductId()) + ")"
					: prod.getProductVersion();
		MSProductType prodType = prod == null ? MSProductType.Unknown : prod.getProductType();

		if (prodType != MSProductType.Unknown) {
			sb.append(prodType).append(" from ").append(prodVersion);
		}
		else {
			sb.append(prodVersion);
		}

		return sb.toString();

	}

	public int getBuildNumber() {
		return buildNumber;
	}

	@Override
	public String toString() {
		return getProductDescription() + ", build " + getBuildNumber();
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/rich/MSProductType.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.rich;

public enum MSProductType {
	CXX_Compiler("C++ Compiler"),
	C_Compiler("C Compiler"),
	Assembler("Assembler"),
	Import("Linker"),
	Export("Linker"),
	ImportExport("Linker"),
	Linker("Linker"),
	CVTRes("CVTRes"),

	Unknown("Unknown");

	private final String desc;

	private MSProductType(String d) {
		this.desc = d;
	}

	public String toString() {
		return desc;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/rich/MSRichProductBuildNumberDataType.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.rich;

import ghidra.docking.settings.Settings;
import ghidra.program.model.data.*;
import ghidra.program.model.mem.MemBuffer;
import ghidra.util.InvalidNameException;
import ghidra.util.exception.DuplicateNameException;

class MSRichProductBuildNumberDataType extends DataTypeImpl {

	private final CompId compid;

	public MSRichProductBuildNumberDataType(CompId compid) {
		this(compid, null);
	}

	public MSRichProductBuildNumberDataType(CompId compid, DataTypeManager dtm) {
		super(new CategoryPath("/PE"), "MSProductBuildNumber", dtm);
		this.compid = compid;
	}

	@Override
	public boolean hasLanguageDependantLength() {
		return false;
	}

	@Override
	public DataType clone(DataTypeManager dtm) {
		if (dtm == getDataTypeManager()) {
			return this;
		}
		return new MSRichProductBuildNumberDataType(compid, dtm);
	}

	@Override
	public DataType copy(DataTypeManager dtm) {
		return clone(dtm);
	}

	@Override
	public void setCategoryPath(CategoryPath path) throws DuplicateNameException {
		// ignored
	}

	@Override
	public void setName(String name) throws InvalidNameException {
		// ignored
	}

	@Override
	public void setNameAndCategory(CategoryPath path, String name)
			throws InvalidNameException, DuplicateNameException {
		// ignored
	}

	@Override
	public String getMnemonic(Settings settings) {
		return "xordw";
	}

	@Override
	public int getLength() {
		return 2;
	}

	@Override
	public String getDescription() {
		return "Product Build Number";
	}

	@Override
	public Object getValue(MemBuffer buf, Settings settings, int length) {
		return compid.getBuildNumber();
	}

	@Override
	public String getRepresentation(MemBuffer buf, Settings settings, int length) {
		Integer prodId = (Integer) getValue(buf, settings, length);

		return "" + prodId;
	}

	@Override
	public boolean isEquivalent(DataType dt) {
		if (dt == this) {
			return true;
		}
		if (dt == null) {
			return false;
		}
		return getClass() == dt.getClass();
	}

	@Override
	public void dataTypeSizeChanged(DataType dt) {
		// ignored
	}

	@Override
	public void dataTypeDeleted(DataType dt) {
		// ignored			
	}

	@Override
	public void dataTypeReplaced(DataType oldDt, DataType newDt) {
		// ignored
	}

	@Override
	public void dataTypeNameChanged(DataType dt, String oldName) {
		// ignored
	}

	@Override
	public boolean dependsOn(DataType dt) {
		return false;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/rich/MSRichProductIDDataType.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.rich;

import ghidra.docking.settings.Settings;
import ghidra.program.model.data.*;
import ghidra.program.model.mem.MemBuffer;
import ghidra.util.InvalidNameException;
import ghidra.util.exception.DuplicateNameException;

class MSRichProductIDDataType extends DataTypeImpl {

	private final CompId compid;

	public MSRichProductIDDataType(CompId compid) {
		this(compid, null);
	}

	public MSRichProductIDDataType(CompId compid, DataTypeManager dtm) {
		super(new CategoryPath("/PE"), "MSProductID", dtm);
		this.compid = compid;
	}

	@Override
	public boolean hasLanguageDependantLength() {
		return false;
	}

	@Override
	public DataType clone(DataTypeManager dtm) {
		if (dtm == getDataTypeManager()) {
			return this;
		}
		return new MSRichProductIDDataType(compid, dtm);
	}

	@Override
	public DataType copy(DataTypeManager dtm) {
		return clone(dtm);
	}

	@Override
	public void setCategoryPath(CategoryPath path) throws DuplicateNameException {
		// ignored
	}

	@Override
	public void setName(String name) throws InvalidNameException {
		// ignored
	}

	@Override
	public void setNameAndCategory(CategoryPath path, String name)
			throws InvalidNameException, DuplicateNameException {
		// ignored
	}

	@Override
	public String getMnemonic(Settings settings) {
		return "Product ID";
	}

	@Override
	public int getLength() {
		return 2;
	}

	@Override
	public String getDescription() {
		return "Product ID";
	}

	@Override
	public Object getValue(MemBuffer buf, Settings settings, int length) {
		return compid.getProductId();
	}

	@Override
	public String getRepresentation(MemBuffer buf, Settings settings, int length) {

		return compid.getProductDescription();

	}

	@Override
	public boolean isEquivalent(DataType dt) {
		if (dt == this) {
			return true;
		}
		if (dt == null) {
			return false;
		}
		return getClass() == dt.getClass();
	}

	@Override
	public void dataTypeSizeChanged(DataType dt) {
		// ignored
	}

	@Override
	public void dataTypeDeleted(DataType dt) {
		// ignored			
	}

	@Override
	public void dataTypeReplaced(DataType oldDt, DataType newDt) {
		// ignored
	}

	@Override
	public void dataTypeNameChanged(DataType dt, String oldName) {
		// ignored
	}

	@Override
	public boolean dependsOn(DataType dt) {
		return false;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/rich/MSRichProductInfoDataType.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.rich;

import ghidra.docking.settings.Settings;
import ghidra.program.model.data.*;
import ghidra.program.model.mem.MemBuffer;

class MSRichProductInfoDataType extends StructureDataType {

	private final CompId compid;

	public MSRichProductInfoDataType(CompId compid) {
		this(compid, null);
	}

	public MSRichProductInfoDataType(CompId compid, DataTypeManager dtm) {
		super(new CategoryPath("/PE"), "ProductInfo", 0, dtm);
		this.compid = compid;
		initialize();
	}

	@Override
	public boolean hasLanguageDependantLength() {
		return false;
	}

	@Override
	public MSRichProductInfoDataType clone(DataTypeManager dtm) {
		if (dtm == getDataTypeManager()) {
			return this;
		}
		return new MSRichProductInfoDataType(compid, dtm);
	}

	@Override
	public String getMnemonic(Settings settings) {
		return "Product Info";
	}

	@Override
	public int getLength() {
		return 4;
	}

	@Override
	public String getDescription() {
		return "Product Info";
	}

	@Override
	public Object getValue(MemBuffer buf, Settings settings, int length) {
		return compid;
	}

	private void initialize() {
		add(new MSRichProductIDDataType(compid), 2, "product", null);
		add(new MSRichProductBuildNumberDataType(compid), 2, "buildNumber", null);
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/rich/PERichTableDataType.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.rich;

import java.util.ArrayList;
import java.util.List;

import net.jubjubnest.minidump.contrib.pe.RichHeader;
import net.jubjubnest.minidump.contrib.pe.RichTable;
import ghidra.docking.settings.Settings;
import ghidra.program.model.data.*;
import ghidra.program.model.mem.MemBuffer;
import ghidra.program.model.mem.MemoryAccessException;
import ghidra.util.StringUtilities;

public class PERichTableDataType extends DynamicDataType {

	public PERichTableDataType() {
		this(null);
	}

	public PERichTableDataType(DataTypeManager dtm) {
		super(CategoryPath.ROOT, RichHeader.NAME, dtm);
	}

	@Override
	public DataType clone(DataTypeManager dtm) {
		if (dtm == getDataTypeManager()) {
			return this;
		}
		return new PERichTableDataType(dtm);
	}

	@Override
	public String getMnemonic(Settings settings) {
		return RichHeader.NAME;
	}

	@Override
	public String getDescription() {
		return RichHeader.NAME;
	}

	@Override
	public Object getValue(MemBuffer buf, Settings settings, int length) {
		return new RichTable(buf);
	}

	@Override
	public String getRepresentation(MemBuffer buf, Settings settings, int length) {
		return "";
	}

	protected final synchronized int addComp(DataType dataType, int length, String fieldName,
			List<DataTypeComponent> comps, int offset, String comment) {
		comps.add(new ReadOnlyDataTypeComponent(dataType, this, length, comps.size(), offset,
			fieldName, comment));
		return offset + length;
	}

	@Override
	protected DataTypeComponent[] getAllComponents(MemBuffer buf) {

		final RichTable table = new RichTable(buf);

		List<DataTypeComponent> comps = new ArrayList<>();

		PERichXorDataType xor = new PERichXorDataType(table.getMask());

		int offset = 0;
		offset = addComp(new PERichDanSDataType(table.getMask()), 4, "", comps, offset, null);
		offset = addComp(xor, 4, "__pad0", comps, offset, null);
		offset = addComp(xor, 4, "__pad1", comps, offset, null);
		offset = addComp(xor, 4, "__pad2", comps, offset, null);

		RichHeaderRecord[] records = table.getRecords();

		int productFieldNameWidth = 1;
		{
			int numRecs = records.length;
			while (numRecs > 10) {
				productFieldNameWidth++;
				numRecs /= 10;
			}
		}

		for (int i = 0; i < records.length; i++) {
			RichHeaderRecord record = records[i];
			RichTableRecordDataType recType = new RichTableRecordDataType(record);

			String fieldName = String.format("product_%0" + productFieldNameWidth + "d", i);

			String comment = String.format("%s; %d %s", record.getCompId().toString(),
				record.getObjectCount(), record.getObjectCount() == 1 ? "Object" : "Objects");

			offset = addComp(recType, 8, fieldName, comps, offset, comment);
		}

		offset = addComp(new PERichSignatureDataType(), 4, "signature", comps, offset, null);
		offset = addComp(DWordDataType.dataType, 4, "mask", comps, offset, null);

		return comps.toArray(new DataTypeComponent[comps.size()]);
	}

	private class PERichDanSDataType extends BuiltIn {
		private final int mask;

		public PERichDanSDataType(int mask) {
			this(null, mask);
		}

		public PERichDanSDataType(DataTypeManager dtm, int mask) {
			super(new CategoryPath("/PE"), "DanS Field", dtm);
			this.mask = mask;
		}

		@Override
		public boolean hasLanguageDependantLength() {
			return false;
		}

		@Override
		public DataType clone(DataTypeManager dtm) {
			if (dtm == getDataTypeManager()) {
				return this;
			}
			return new PERichDanSDataType(dtm, mask);
		}

		@Override
		public String getMnemonic(Settings settings) {
			return "";
		}

		@Override
		public int getLength() {
			return 4;
		}

		@Override
		public String getDescription() {
			return "";
		}

		@Override
		public Object getValue(MemBuffer buf, Settings settings, int length) {
			try {
				return buf.getInt(0) ^ mask;
			}
			catch (MemoryAccessException mae) {
				return 0;
			}
		}

		@Override
		public String getRepresentation(MemBuffer buf, Settings settings, int length) {

			Integer value = (Integer) getValue(buf, settings, length);

			byte[] bytes = new byte[4];
			bytes[3] = (byte) ((value >> 24) & 0xFF);
			bytes[2] = (byte) ((value >> 16) & 0xFF);
			bytes[1] = (byte) ((value >> 8) & 0xFF);
			bytes[0] = (byte) ((value) & 0xFF);

			return StringUtilities.toQuotedString(bytes, 1);

		}
	}

	private class PERichSignatureDataType extends BuiltIn {

		public PERichSignatureDataType() {
			this(null);
		}

		public PERichSignatureDataType(DataTypeManager dtm) {
			super(new CategoryPath("/PE"), "Signature Field", dtm);

		}

		@Override
		public boolean hasLanguageDependantLength() {
			return false;
		}

		@Override
		public DataType clone(DataTypeManager dtm) {
			if (dtm == getDataTypeManager()) {
				return this;
			}
			return new PERichSignatureDataType(dtm);
		}

		@Override
		public String getMnemonic(Settings settings) {
			return "";
		}

		@Override
		public int getLength() {
			return 4;
		}

		@Override
		public String getDescription() {
			return "";
		}

		@Override
		public Object getValue(MemBuffer buf, Settings settings, int length) {
			try {
				return buf.getInt(0);
			}
			catch (MemoryAccessException mae) {
				return 0;
			}
		}

		@Override
		public String getRepresentation(MemBuffer buf, Settings settings, int length) {

			Integer value = (Integer) getValue(buf, settings, length);

			byte[] bytes = new byte[4];
			bytes[3] = (byte) ((value >> 24) & 0xFF);
			bytes[2] = (byte) ((value >> 16) & 0xFF);
			bytes[1] = (byte) ((value >> 8) & 0xFF);
			bytes[0] = (byte) ((value) & 0xFF);

			return StringUtilities.toQuotedString(bytes, 1);
		}
	}

	private class PERichXorDataType extends BuiltIn {

		private final int mask;

		public PERichXorDataType(int mask) {
			this(null, mask);
		}

		public PERichXorDataType(DataTypeManager dtm, int mask) {
			super(new CategoryPath("/PE"), "XOR Field", dtm);
			this.mask = mask;
		}

		@Override
		public boolean hasLanguageDependantLength() {
			return false;
		}

		@Override
		public DataType clone(DataTypeManager dtm) {
			if (dtm == getDataTypeManager()) {
				return this;
			}
			return new PERichXorDataType(dtm, mask);
		}

		@Override
		public String getMnemonic(Settings settings) {
			return "xorddw";
		}

		@Override
		public int getLength() {
			return 4;
		}

		@Override
		public String getDescription() {
			return "";
		}

		@Override
		public Object getValue(MemBuffer buf, Settings settings, int length) {
			try {
				return buf.getInt(0) ^ mask;
			}
			catch (MemoryAccessException mae) {
				return 0;
			}
		}

		@Override
		public String getRepresentation(MemBuffer buf, Settings settings, int length) {
			try {
				return new Integer(buf.getInt(0) ^ mask).toString();
			}
			catch (MemoryAccessException mae) {
				return "0";
			}
		}

	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/rich/RichHeaderRecord.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.rich;

import net.jubjubnest.minidump.contrib.pe.RichTable;

/**
 * An element of a {@link RichTable}
 */
public class RichHeaderRecord {

	private final int recordIndex;
	private final CompId compid;
	private final int count;

	public RichHeaderRecord(int recordIndex, int compid, int count) {
		this.recordIndex = recordIndex;
		this.compid = new CompId(compid);
		this.count = count;
	}

	public int getIndex() {
		return recordIndex;
	}

	public CompId getCompId() {
		return this.compid;
	}

	public int getObjectCount() {
		return count;
	}

	@Override
	public String toString() {
		return compid + " Count: " + count;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/rich/RichHeaderUtils.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.rich;

import java.util.Map;

public class RichHeaderUtils {

	private static Map<Integer, RichProduct> richIds = null;

	private RichHeaderUtils() {
		// Prevent instantiation of static utility class
	}

	public static RichProduct getProduct(int id) {
		if (richIds == null) {
			richIds = RichProductIdLoader.loadProductIdStore();
			if (richIds == null) {
				return null;
			}
		}

		return richIds.get(id);
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/rich/RichObjectCountDataType.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.rich;

import ghidra.docking.settings.Settings;
import ghidra.program.model.data.*;
import ghidra.program.model.mem.MemBuffer;
import ghidra.util.InvalidNameException;
import ghidra.util.exception.DuplicateNameException;

class RichObjectCountDataType extends DataTypeImpl {

	private final int count;

	public RichObjectCountDataType(int count) {
		this(count, null);
	}

	public RichObjectCountDataType(int count, DataTypeManager dtm) {
		super(new CategoryPath("/PE"), "RichObjectCount", dtm);
		this.count = count;
	}

	@Override
	public boolean hasLanguageDependantLength() {
		return false;
	}

	@Override
	public DataType clone(DataTypeManager dtm) {
		if (dtm == getDataTypeManager()) {
			return this;
		}
		return new RichObjectCountDataType(count, dtm);
	}

	@Override
	public DataType copy(DataTypeManager dtm) {
		return clone(dtm);
	}

	@Override
	public void setCategoryPath(CategoryPath path) throws DuplicateNameException {
		// ignored
	}

	@Override
	public void setName(String name) throws InvalidNameException {
		// ignored
	}

	@Override
	public void setNameAndCategory(CategoryPath path, String name)
			throws InvalidNameException, DuplicateNameException {
		// ignored
	}

	@Override
	public String getMnemonic(Settings settings) {
		return "xorddw";
	}

	@Override
	public int getLength() {
		return 4;
	}

	@Override
	public String getDescription() {
		return null;
	}

	@Override
	public Object getValue(MemBuffer buf, Settings settings, int length) {
		return count;
	}

	@Override
	public String getRepresentation(MemBuffer buf, Settings settings, int length) {
		return "" + count;
	}

	@Override
	public boolean isEquivalent(DataType dt) {
		if (dt == this) {
			return true;
		}
		if (dt == null) {
			return false;
		}
		return getClass() == dt.getClass();
	}

	@Override
	public void dataTypeSizeChanged(DataType dt) {
		// ignored
	}

	@Override
	public void dataTypeDeleted(DataType dt) {
		// ignored			
	}

	@Override
	public void dataTypeReplaced(DataType oldDt, DataType newDt) {
		// ignored
	}

	@Override
	public void dataTypeNameChanged(DataType dt, String oldName) {
		// ignored
	}

	@Override
	public boolean dependsOn(DataType dt) {
		return false;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/rich/RichProduct.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.rich;

public class RichProduct {
	private final CompId compid;
	private final String productVersion;
	private final MSProductType productType;

	public RichProduct(int compid, String version, MSProductType type) {
		this.compid = new CompId(compid);
		this.productVersion = version;
		this.productType = type;
	}

	public CompId getCompid() {
		return compid;
	}

	public String getProductVersion() {
		return productVersion;
	}

	public MSProductType getProductType() {
		return productType;
	}

	public String toString() {
		return getProductVersion() + " -- " + getProductType();
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/rich/RichProductIdLoader.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.rich;

import java.io.*;
import java.util.*;

import org.apache.commons.io.FilenameUtils;
import org.xml.sax.*;

import generic.jar.ResourceFile;
import ghidra.framework.Application;
import ghidra.util.Msg;
import ghidra.xml.*;

class RichProductIdLoader {

	public static Map<Integer, RichProduct> loadProductIdStore() {

		List<ResourceFile> fileList = new ArrayList<>();

		try {
			ResourceFile builtIn = Application.getModuleDataFile("ms_pe_rich_products.xml");

			if (builtIn != null) {
				fileList.add(builtIn);
			}

			File userFile = Application.getUserSettingsDirectory().getParentFile();
			String userFilePath =
				userFile.getAbsolutePath().concat(File.separator).concat("rich_ids.xml");

			ResourceFile user = new ResourceFile(new File(userFilePath));

			if (user.exists()) {
				fileList.add(user);
			}
		}
		catch (FileNotFoundException fnfe) {
			// ignored;
		}

		Map<Integer, RichProduct> store = new HashMap<>();
		for (ResourceFile file : fileList) {
			if (file.exists()) {
				try {
					loadFile(file, store);
				}
				catch (IOException ioe) {
					Msg.error(RichProductIdLoader.class, "Error loading " + file.getName(), ioe);
				}
			}
		}
		return store;
	}

	private static MSProductType resolveProductType(String toolDescription) {
		String descr = toolDescription.toLowerCase();

		if (descr.contains("import") || toolDescription.equals("IMP")) {
			return MSProductType.Import;
		}
		if (descr.contains("export") || toolDescription.equals("EXP")) {
			return MSProductType.Export;
		}
		if (descr.contains("imp/exp")) {
			return MSProductType.ImportExport;
		}
		if (descr.contains("linker")) {
			return MSProductType.Linker;
		}
		if (toolDescription.contains("link ") || toolDescription.equals("LNK")) {
			return MSProductType.Linker;
		}
		if (descr.contains("masm") || toolDescription.equals("ASM")) {
			return MSProductType.Assembler;
		}
		if (descr.contains("cvtres") || toolDescription.equals("RES")) {
			return MSProductType.CVTRes;
		}
		if (descr.contains("c++ compiler")) {
			return MSProductType.CXX_Compiler;
		}
		if (descr.contains("c compiler")) {
			return MSProductType.C_Compiler;
		}

		if (toolDescription.equals("C++")) {
			return MSProductType.CXX_Compiler;
		}
		if (toolDescription.equals("C")) {
			return MSProductType.C_Compiler;
		}

		return MSProductType.Unknown;
	}

	private static void loadFile(ResourceFile file, Map<Integer, RichProduct> store)
			throws FileNotFoundException, IOException {

		String fileExtension = FilenameUtils.getExtension(file.getAbsolutePath()).toLowerCase();
		if (fileExtension.equals("xml")) {
			try {
				loadXMLFile(file, store);
			}
			catch (XmlParseException xpe) {
				throw new IOException("Error loading XML file: " + xpe.getMessage(), xpe);
			}
		}
	}

	private static void loadXMLFile(ResourceFile file, Map<Integer, RichProduct> store)
			throws FileNotFoundException, IOException, XmlParseException {

		InputStream stream = file.getInputStream();
		String name = file.getName();

		loadXMLFile(name, stream, store);

		stream.close();

	}

	private static void loadXMLFile(String name, InputStream stream,
			Map<Integer, RichProduct> store) throws IOException, XmlParseException {

		XmlPullParser parser;
		try {
			parser = new NonThreadedXmlPullParserImpl(stream, name, new XMLErrorHandler(), false);
		}
		catch (SAXException e) {
			throw new XmlParseException("Sax Exception", e);
		}
		parser.next();// skip root element start
		try {
			processProducts(parser, store);
		}
		catch (SAXParseException spe) {
			Msg.error(RichProductIdLoader.class, "Error occurred while parsing XML file " + name,
				spe);
		}
	}

	private static void processProducts(XmlPullParser parser, Map<Integer, RichProduct> store)
			throws SAXParseException {
		XmlElement element = parser.next();
		while (!element.isEnd()) {
			String name = element.getName();
			if (name.equals("product")) {
				RichProduct product = loadRichProduct(element);
				if (product != null) {
					store.put(product.getCompid().getValue(), product);
				}
			}
			else {
				throw new SAXParseException("Unexpected element: " + name, null, null,
					parser.getLineNumber(), parser.getColumnNumber());
			}
			element = parser.next();// read end tag
			element = parser.next();// advance to next start
		}
	}

	private static RichProduct loadRichProduct(XmlElement element) {

		String prodidStr = element.getAttribute("prodid");
		String tool = element.getAttribute("tool");
		String name = element.getAttribute("name");

		int id = Integer.parseInt(prodidStr, 16);

		MSProductType type = resolveProductType(tool);

		return new RichProduct(id, name, type);

	}

	private static class XMLErrorHandler implements ErrorHandler {
		@Override
		public void error(SAXParseException exception) throws SAXException {
			throw new SAXException("Error: " + exception);
		}

		@Override
		public void fatalError(SAXParseException exception) throws SAXException {
			throw new SAXException("Fatal error: " + exception);
		}

		@Override
		public void warning(SAXParseException exception) throws SAXException {
			throw new SAXException("Warning: " + exception);
		}
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/contrib/pe/rich/RichTableRecordDataType.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.contrib.pe.rich;

import ghidra.docking.settings.Settings;
import ghidra.program.model.data.*;
import ghidra.program.model.mem.MemBuffer;

class RichTableRecordDataType extends StructureDataType {

	private final RichHeaderRecord record;

	public RichTableRecordDataType(RichHeaderRecord record) {
		this(null, record);
	}

	public RichTableRecordDataType(DataTypeManager dtm, RichHeaderRecord record) {
		super(new CategoryPath("/PE"), "MSRichRecord", 0, dtm);
		this.record = record;

		initialize();
	}

	@Override
	public boolean hasLanguageDependantLength() {
		return false;
	}

	@Override
	public RichTableRecordDataType clone(DataTypeManager dtm) {
		if (dtm == getDataTypeManager()) {
			return this;
		}
		return new RichTableRecordDataType(dtm, record);
	}

	@Override
	public String getMnemonic(Settings settings) {
		return "MSRichRecord";
	}

	@Override
	public int getLength() {
		return 8;
	}

	@Override
	public String getDescription() {
		return "MS Rich Table Record";
	}

	@Override
	public Object getValue(MemBuffer buf, Settings settings, int length) {
		return record;
	}

	@Override
	public String getRepresentation(MemBuffer buf, Settings settings, int length) {
		return "";
	}

	@Override
	public DataType copy(DataTypeManager dtm) {
		return clone(dtm);
	}

	private void initialize() {
		add(new MSRichProductInfoDataType(record.getCompId()), 4, "productInfo", null);
		add(new RichObjectCountDataType(record.getObjectCount()), 4, "objectCount", null);
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/data/Context64.java`:

```java
package net.jubjubnest.minidump.data;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

import ghidra.app.util.bin.ByteProvider;

/**
 * 64-bit CPU context
 * 
 * https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-context
 */
public class Context64 implements ThreadContext {

	public static final int CONTEXT_TYPE = 1;
	public static final int RECORD_SIZE = 
			6 * 8 +
			2 * 4 +
			6 * 2 + 4 +
			6 * 8 +
			16 * 8 +
			8 + 
			18 * 16 +
			26 * 16 + 8 +
			5 * 8;

	public static Context64 parse(long offset, ByteProvider provider) throws IOException {
		var bytes = provider.readBytes(offset, RECORD_SIZE);
		var byteBuffer = ByteBuffer.wrap(bytes);
		byteBuffer.order(ByteOrder.LITTLE_ENDIAN);
		return parse(byteBuffer);
	}

	@Override
	public int getType() {
		return CONTEXT_TYPE;
	}

	public static ThreadContext fromBytes(byte[] bytes) {
		var byteBuffer = ByteBuffer.wrap(bytes);
		byteBuffer.order(ByteOrder.LITTLE_ENDIAN);
		return parse(byteBuffer);
	}

	@Override
	public byte[] toBytes() {

		ByteBuffer buffer = ByteBuffer.allocate(1200);
		buffer.order(ByteOrder.LITTLE_ENDIAN);
		
		buffer.putLong(p1Home);
		buffer.putLong(p2Home);
		buffer.putLong(p3Home);
		buffer.putLong(p4Home);
		buffer.putLong(p5Home);
		buffer.putLong(p6Home);
		
		buffer.putInt(contextFlags);
		buffer.putInt(mxCsr);
		
		buffer.putShort(segCs);
		buffer.putShort(segDs);
		buffer.putShort(segEs);
		buffer.putShort(segFs);
		buffer.putShort(segGs);
		buffer.putShort(segSs);
		buffer.putInt(eFlags);

		buffer.putLong(dr0);
		buffer.putLong(dr1);
		buffer.putLong(dr2);
		buffer.putLong(dr3);
		buffer.putLong(dr6);
		buffer.putLong(dr7);

		buffer.putLong(rax);
		buffer.putLong(rcx);
		buffer.putLong(rdx);
		buffer.putLong(rbx);
		buffer.putLong(rsp);
		buffer.putLong(rbp);
		buffer.putLong(rsi);
		buffer.putLong(rdi);
		buffer.putLong(r8);
		buffer.putLong(r9);
		buffer.putLong(r10);
		buffer.putLong(r11);
		buffer.putLong(r12);
		buffer.putLong(r13);
		buffer.putLong(r14);
		buffer.putLong(r15);
		
		buffer.putLong(rip);
		
		buffer.put(xmms);

		buffer.put(vectorRegister);
		buffer.putLong(vectorControl);

		buffer.putLong(debugControl);
		buffer.putLong(lastBranchToRip);
		buffer.putLong(lastBranchFromRip);
		buffer.putLong(lastExceptionToRip);
		buffer.putLong(lastExceptionFromRip);

		return buffer.array();
	}

	public static Context64 parse(ByteBuffer byteBuffer) {
		var ctx = new Context64();

		ctx.p1Home = byteBuffer.getLong();
		ctx.p2Home = byteBuffer.getLong();
		ctx.p3Home = byteBuffer.getLong();
		ctx.p4Home = byteBuffer.getLong();
		ctx.p5Home = byteBuffer.getLong();
		ctx.p6Home = byteBuffer.getLong();

		ctx.contextFlags = byteBuffer.getInt();
		ctx.mxCsr = byteBuffer.getInt();

		ctx.segCs = byteBuffer.getShort();
		ctx.segDs = byteBuffer.getShort();
		ctx.segEs = byteBuffer.getShort();
		ctx.segFs = byteBuffer.getShort();
		ctx.segGs = byteBuffer.getShort();
		ctx.segSs = byteBuffer.getShort();
		ctx.eFlags = byteBuffer.getInt();

		ctx.dr0 = byteBuffer.getLong();
		ctx.dr1 = byteBuffer.getLong();
		ctx.dr2 = byteBuffer.getLong();
		ctx.dr3 = byteBuffer.getLong();
		ctx.dr6 = byteBuffer.getLong();
		ctx.dr7 = byteBuffer.getLong();

		ctx.rax = byteBuffer.getLong();
		ctx.rcx = byteBuffer.getLong();
		ctx.rdx = byteBuffer.getLong();
		ctx.rbx = byteBuffer.getLong();
		ctx.rsp = byteBuffer.getLong();
		ctx.rbp = byteBuffer.getLong();
		ctx.rsi = byteBuffer.getLong();
		ctx.rdi = byteBuffer.getLong();
		ctx.r8 = byteBuffer.getLong();
		ctx.r9 = byteBuffer.getLong();
		ctx.r10 = byteBuffer.getLong();
		ctx.r11 = byteBuffer.getLong();
		ctx.r12 = byteBuffer.getLong();
		ctx.r13 = byteBuffer.getLong();
		ctx.r14 = byteBuffer.getLong();
		ctx.r15 = byteBuffer.getLong();
		
		ctx.rip = byteBuffer.getLong();
		
		ctx.xmms = new byte[18 * 16];
		for( int i = 0; i < ctx.xmms.length; i++)
			ctx.xmms[i] = byteBuffer.get();

		ctx.vectorRegister = new byte[26 * 16];
		for( int i = 0; i < ctx.vectorRegister.length; i++)
			ctx.vectorRegister[i] = byteBuffer.get();
		ctx.vectorControl = byteBuffer.getLong();

		ctx.debugControl = byteBuffer.getLong();
		ctx.lastBranchToRip = byteBuffer.getLong();
		ctx.lastBranchFromRip = byteBuffer.getLong();
		ctx.lastExceptionToRip = byteBuffer.getLong();
		ctx.lastExceptionFromRip = byteBuffer.getLong();

		return ctx;
	}

	public long p1Home;
	public long p2Home;
	public long p3Home;
	public long p4Home;
	public long p5Home;
	public long p6Home;
	
	public int contextFlags;
	public int mxCsr;
	
	public short segCs;
	public short segDs;
	public short segEs;
	public short segFs;
	public short segGs;
	public short segSs;
	public int eFlags;
	
	public long dr0;
	public long dr1;
	public long dr2;
	public long dr3;
	public long dr6;
	public long dr7;
	
	public long rax;
	public long rcx;
	public long rdx;
	public long rbx;
	public long rsp;
	public long rbp;
	public long rsi;
	public long rdi;
	public long r8;
	public long r9;
	public long r10;
	public long r11;
	public long r12;
	public long r13;
	public long r14;
	public long r15;
	
	public long rip;
	
	// 18 x 128-bit registers.
	public byte xmms[];
	
	// 26 x 128-bit register
	public byte vectorRegister[];
	public long vectorControl;
	
	public long debugControl;
	public long lastBranchToRip;
	public long lastBranchFromRip;
	public long lastExceptionToRip;
	public long lastExceptionFromRip;
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/data/ModuleData.java`:

```java
package net.jubjubnest.minidump.data;

import java.util.ArrayList;
import java.util.List;

import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressIterator;
import ghidra.program.model.listing.Program;
import ghidra.program.model.util.ObjectPropertyMap;
import ghidra.util.ObjectStorage;
import ghidra.util.Saveable;

public class ModuleData {
	
	public static final String PROPERTY_NAME = "MODULE_DATA";
	
	public String name;
	public String loadedSymbols;
	public Address baseAddress;
	public Address rtiStartAddress;
	public Address rtiEndAddress;
	
	public ModuleData(String name, Address baseAddress, Address rtiStart, Address rtiEnd) {
		this.name = name;
		this.loadedSymbols = null;
		this.baseAddress = baseAddress;
		this.rtiStartAddress = rtiStart;
		this.rtiEndAddress = rtiEnd;
	}
	
	private ModuleData(Program program, Record record) {
		this.name = record.name;
		this.loadedSymbols = record.loadedSymbols;
		this.baseAddress = program.getImageBase().getNewAddress(record.baseAddress);
		this.rtiStartAddress = baseAddress.getNewAddress(record.rtiStartAddress);
		this.rtiEndAddress = baseAddress.getNewAddress(record.rtiEndAddress);
	}
	
	public static ModuleData getContainingModuleData(Program program, Address address) {
		ObjectPropertyMap objectMap = getModuleDataMap(program,  false);
		if (objectMap == null)
			return null;
		
		// The modules shouldn't be interleaved and the data is set at the start of the module so we'll first try the specific
		// address but when that eventually fails we'll find the previous address that has data and trust that's the data for this module.
		Record record = (Record)objectMap.getObject(address);
		if (record == null) {
			Address previousAddress = objectMap.getPreviousPropertyAddress(address);
			if (previousAddress == null) {
				return null;
			}

			record = (Record)objectMap.getObject(previousAddress);
		}

		return new ModuleData(program, record);

	}
	
	public static List<ModuleData> getAllModules(Program program) {
		ObjectPropertyMap objectMap = getModuleDataMap(program, false);
		if (objectMap == null)
			return null;
		
		List<ModuleData> modules = new ArrayList<>();
		AddressIterator iterator = objectMap.getPropertyIterator();
		for (Address addr = iterator.next(); addr != null; addr = iterator.next()) {
			ModuleData moduleData = new ModuleData(program, (Record)objectMap.getObject(addr));
			modules.add(moduleData);
		}

		return modules;
	}
	
	public static ModuleData getModuleData(Program program, Address address) {
		ObjectPropertyMap objectMap = getModuleDataMap(program, false);
		Record record = (Record)objectMap.getObject(address);
		return record == null ? null : new ModuleData(program, record);
	}

	public static void setModuleData(Program program, ModuleData data) {
		ObjectPropertyMap objectMap = getModuleDataMap(program, true);
		objectMap.add(data.baseAddress, new Record(data));
	}

	private static ObjectPropertyMap getModuleDataMap(Program program, boolean create) {
		return ObjectMapResolver.getModuleDataMap(program, PROPERTY_NAME, Record.class, create);
	}
	
	public static class Record implements Saveable {
		
		private String name;
		private String loadedSymbols;
		private long baseAddress;
		private long rtiStartAddress;
		private long rtiEndAddress;
		
		public Record(ModuleData data) {
			this.name = data.name;
			this.loadedSymbols = data.loadedSymbols;
			this.baseAddress = data.baseAddress.getOffset();
			this.rtiStartAddress = data.rtiStartAddress.getOffset();
			this.rtiEndAddress = data.rtiEndAddress.getOffset();
		}
		
		public Record() {}

		@Override
		public Class<?>[] getObjectStorageFields() {
			return new Class[] {
				String.class,
				String.class,
				long.class,
				long.class,
				long.class,
			};
		}

		@Override
		public void save(ObjectStorage objStorage) {
			objStorage.putString(name);
			objStorage.putString(loadedSymbols);
			objStorage.putLong(baseAddress);
			objStorage.putLong(rtiStartAddress);
			objStorage.putLong(rtiEndAddress);
		}

		@Override
		public void restore(ObjectStorage objStorage) {
			name = objStorage.getString();
			loadedSymbols = objStorage.getString();
			baseAddress = objStorage.getLong();
			rtiStartAddress = objStorage.getLong();
			rtiEndAddress = objStorage.getLong();
		}

		@Override
		public int getSchemaVersion() {
			return 0;
		}

		@Override
		public boolean isUpgradeable(int oldSchemaVersion) {
			return false;
		}

		@Override
		public boolean upgrade(ObjectStorage oldObjStorage, int oldSchemaVersion, ObjectStorage currentObjStorage) {
			return false;
		}

		@Override
		public boolean isPrivate() {
			return false;
		}
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/data/ObjectMapResolver.java`:

```java
package net.jubjubnest.minidump.data;

import ghidra.program.model.listing.Program;
import ghidra.program.model.util.ObjectPropertyMap;
import ghidra.program.model.util.PropertyMapManager;
import ghidra.util.Saveable;
import ghidra.util.exception.DuplicateNameException;

public class ObjectMapResolver {
	
	public static ObjectPropertyMap getModuleDataMap(Program program, String name, Class<? extends Saveable> recordClass, boolean create) {
		PropertyMapManager manager = program.getUsrPropertyManager();
		ObjectPropertyMap map = manager.getObjectPropertyMap(name);
		if (map != null || !create) {
			return map;
		}
		
		try {
			return manager.createObjectPropertyMap(name, recordClass);
		} catch (DuplicateNameException e) {
			return manager.getObjectPropertyMap(name);
		}
	}
	
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/data/ThreadContext.java`:

```java
package net.jubjubnest.minidump.data;

public interface ThreadContext {

	public int getType();
	public byte[] toBytes();
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/data/ThreadData.java`:

```java
package net.jubjubnest.minidump.data;

import java.util.ArrayList;
import java.util.List;

import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidra.program.model.util.ObjectPropertyMap;
import ghidra.util.ObjectStorage;
import ghidra.util.Saveable;

public class ThreadData {
	
	public int id;
	public Address stackBase;
	public Address stackLimit;
	public Address stackPointer;
	public Address sp;
	public Address ip;

	public ThreadContext context;
	
	private static final String OBJECT_MAP_KEY = ThreadData.class.getCanonicalName();
	
	// Address with which the thread data is associated.
	// stackLimit should be at "top" which makes more sense if this is ever visible in the UI.
	// The program is given as a parameter in the case this ever needs to take stack direction into account.
	private Address key(Program program) { return this.stackLimit; }
	
	public ThreadData(int id, Address stackBase, Address stackLimit, Address stackPointer,
			Address sp, Address ip, ThreadContext context) {

		this.id = id;
		this.stackBase = stackBase;
		this.stackLimit = stackLimit;
		this.stackPointer = stackPointer;
		this.sp = sp;
		this.ip = ip;
		this.context = context;
	}
	
	private ThreadData(Program program, Record record) {
		id = record.id;
		stackBase = program.getImageBase().getNewAddress(record.stackBase);
		stackLimit = stackBase.getNewAddress(record.stackLimit);
		stackPointer = stackBase.getNewAddress(record.stackPointer);
		sp = stackBase.getNewAddress(record.sp);
		ip = stackBase.getNewAddress(record.ip);
		
		switch (record.contextType) {
		case Context64.CONTEXT_TYPE:
			context = Context64.fromBytes(record.context);
			break;
		}
	}
	
	public static List<ThreadData> getAllThreadData(Program program) {
		List<ThreadData> list = new ArrayList<>();

		ObjectPropertyMap map = getObjectMap(program, false);
		if (map != null) {
			for (Address addr : map.getPropertyIterator()) {
				list.add(new ThreadData(program, (Record)map.getObject(addr)));
			}
		}
		
		return list;
	}

	public static void storeThreadData(Program program, ThreadData data) {
		ObjectPropertyMap map = getObjectMap(program, true);
		map.add(data.key(program), new Record(data));
	}

	private static ObjectPropertyMap getObjectMap(Program program, boolean create) {
		return ObjectMapResolver.getModuleDataMap(program, OBJECT_MAP_KEY, Record.class, create);
	}
	
	public static class Record implements Saveable {
		
		// Version 0
		public int id;
		public long stackBase;
		public long stackLimit;
		public long stackPointer;
		public long sp;
		public long ip;
		
		// Version 1
		public int contextType;
		public byte[] context;
		
		public Record(ThreadData data) {
			id = data.id;
			stackBase = data.stackBase.getOffset();
			stackLimit = data.stackLimit.getOffset();
			stackPointer = data.stackPointer.getOffset();
			sp = data.sp.getOffset();
			ip = data.ip.getOffset();
			
			if (data.context == null) {
				contextType = 0;
				context = new byte[0];
			} else {
				contextType = data.context.getType();
				context = data.context.toBytes();
			}
		}
		
		public Record() {}

		@Override
		public Class<?>[] getObjectStorageFields() {
			return new Class[] {
				int.class,
				long.class,
				long.class,
				long.class,
				long.class,
				long.class,

				int.class,
				String.class,
			};
		}

		@Override
		public void save(ObjectStorage objStorage) {
			objStorage.putInt(id);
			objStorage.putLong(stackBase);
			objStorage.putLong(stackLimit);
			objStorage.putLong(stackPointer);
			objStorage.putLong(sp);
			objStorage.putLong(ip);
			
			objStorage.putInt(contextType);
			objStorage.putBytes(context);
		}

		@Override
		public void restore(ObjectStorage objStorage) {
			id = objStorage.getInt();
			stackBase = objStorage.getLong();
			stackLimit = objStorage.getLong();
			stackPointer = objStorage.getLong();
			sp = objStorage.getLong();
			ip = objStorage.getLong();
			
			contextType = objStorage.getInt();
			context = objStorage.getBytes();
		}

		@Override
		public int getSchemaVersion() {
			return 1;
		}

		@Override
		public boolean isUpgradeable(int oldSchemaVersion) {
			return true;
		}

		@Override
		public boolean upgrade(ObjectStorage oldObjStorage, int oldSchemaVersion, ObjectStorage currentObjStorage) {

			currentObjStorage.putInt(oldObjStorage.getInt());
			currentObjStorage.putLong(oldObjStorage.getLong());
			currentObjStorage.putLong(oldObjStorage.getLong());
			currentObjStorage.putLong(oldObjStorage.getLong());
			currentObjStorage.putLong(oldObjStorage.getLong());
			currentObjStorage.putLong(oldObjStorage.getLong());

			if (oldSchemaVersion < 1) {
				currentObjStorage.putInt(0);
				currentObjStorage.putBytes(new byte[0]);
			} else {
				currentObjStorage.putInt(oldObjStorage.getInt());
				currentObjStorage.putBytes(oldObjStorage.getBytes());
			}
			
			return true;
		}

		@Override
		public boolean isPrivate() {
			return false;
		}
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/loader/MinidumpLoader.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.loader;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;

import ghidra.app.util.MemoryBlockUtils;
import ghidra.app.util.Option;
import ghidra.app.util.bin.ByteProvider;
import ghidra.app.util.bin.ByteProviderWrapper;
import ghidra.app.util.bin.format.pdb.PdbParserConstants;
import ghidra.app.util.importer.MessageLog;
import ghidra.app.util.opinion.AbstractLibrarySupportLoader;
import ghidra.app.util.opinion.LoadSpec;
import ghidra.framework.model.DomainObject;
import ghidra.framework.options.Options;
import ghidra.program.database.mem.FileBytes;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressFactory;
import ghidra.program.model.address.AddressOutOfBoundsException;
import ghidra.program.model.address.AddressOverflowException;
import ghidra.program.model.address.AddressSpace;
import ghidra.program.model.lang.LanguageCompilerSpecPair;
import ghidra.program.model.listing.DuplicateGroupException;
import ghidra.program.model.listing.Program;
import ghidra.program.model.listing.ProgramFragment;
import ghidra.program.model.listing.ProgramModule;
import ghidra.program.model.reloc.RelocationTable;
import ghidra.util.Msg;
import ghidra.util.exception.CancelledException;
import ghidra.util.exception.DuplicateNameException;
import ghidra.util.exception.NotEmptyException;
import ghidra.util.exception.NotFoundException;
import ghidra.util.task.TaskMonitor;
import net.jubjubnest.minidump.contrib.new_.ImageLoadInfo;
import net.jubjubnest.minidump.contrib.new_.ModuleBaseMap;
import net.jubjubnest.minidump.contrib.opinion.PeLoader;
import net.jubjubnest.minidump.contrib.pe.DataDirectory;
import net.jubjubnest.minidump.contrib.pe.ExceptionDataDirectory;
import net.jubjubnest.minidump.contrib.pe.NTHeader;
import net.jubjubnest.minidump.contrib.pe.OptionalHeader;
import net.jubjubnest.minidump.contrib.pe.PortableExecutable;
import net.jubjubnest.minidump.contrib.pe.PortableExecutable.SectionLayout;
import net.jubjubnest.minidump.data.Context64;
import net.jubjubnest.minidump.data.ModuleData;
import net.jubjubnest.minidump.data.ThreadData;
import net.jubjubnest.minidump.loader.parser.MinidumpDirectory;
import net.jubjubnest.minidump.loader.parser.MinidumpHeader;
import net.jubjubnest.minidump.loader.parser.MinidumpLocationDescriptor;
import net.jubjubnest.minidump.loader.parser.MinidumpMemory64List;
import net.jubjubnest.minidump.loader.parser.MinidumpMemoryInfo;
import net.jubjubnest.minidump.loader.parser.MinidumpMemoryInfoList;
import net.jubjubnest.minidump.loader.parser.MinidumpModule;
import net.jubjubnest.minidump.loader.parser.MinidumpModuleList;
import net.jubjubnest.minidump.loader.parser.ThreadInformationBlock;
import net.jubjubnest.minidump.loader.parser.MinidumpThreadList;

/**
 * Loads Windows Minidump files into Ghidra
 */
public class MinidumpLoader extends AbstractLibrarySupportLoader {
	
	public final static String NAME = "Windows Minidump";

	@Override
	public String getName() {
		return NAME;
	}

	@Override
	public Collection<LoadSpec> findSupportedLoadSpecs(ByteProvider provider) throws IOException {
		List<LoadSpec> loadSpecs = new ArrayList<>();

		var bytes = provider.readBytes(0, 4);
		if (bytes[0] != 'M' || bytes[1] != 'D' || bytes[2] != 'M' || bytes[3] != 'P')
			return loadSpecs;

		loadSpecs.add(new LoadSpec(this, 0, new LanguageCompilerSpecPair("x86:LE:64:default", "windows"), true));
		return loadSpecs;
	}

	@Override
	protected void load(ByteProvider provider, LoadSpec loadSpec, List<Option> options, Program program,
			TaskMonitor monitor, MessageLog log) throws CancelledException, IOException {

		log.appendMsg(this.getClass().getName(), String.format("Loading minidump: %s", provider.getAbsolutePath()));
		var header = MinidumpHeader.parse(0, provider);
		log.appendMsg(this.getClass().getName(), String.format("Total streams: %s", header.streamsCount));

		// Index all streams. We'll need to be a bit careful in what order we process
		// these so we'll first figure out what we have.
		var directories = new HashMap<Integer, List<MinidumpDirectory>>();
		for (int i = 0; i < header.streamsCount; i++) {
			var offset = header.streamsOffset + MinidumpDirectory.RECORD_SIZE * i;
			var directory = MinidumpDirectory.parse(offset, provider);
			var list = directories.computeIfAbsent(directory.streamType, (key) -> new ArrayList<MinidumpDirectory>());
			list.add(directory);

			log.appendMsg(this.getClass().getName(),
					String.format("- Stream %s: %s (location: %s)", i, directory.streamType, directory.location));
		}

		// First load the memory in the program. More or less everything else depends on memory addresses
		// for which we'll want a byte provider that can access the bytes based on in-memory addresses.
		var memoryList = directories.get(MinidumpDirectory.TYPE_MEMORY64LISTSTREAM);
		if (memoryList == null)
			throw new IllegalArgumentException("Minidump contains no memory segments");
		if (memoryList.size() != 1)
			throw new IllegalArgumentException("Minidump contains multiple memory lists");

		var memory = readMemory64(provider, memoryList.get(0).location, program, monitor, log);
		var memoryProvider = new MinidumpMemoryProvider(provider, memory);

		// The modules and private memory are somewhat well defined and should not overlap
		// so the order in which they are loaded doesn't really matter.
		var moduleList = directories.get(MinidumpDirectory.TYPE_MODULELISTSTREAM);
		if (moduleList != null) {
			for (var m : moduleList) {
				loadModules(provider, loadSpec, memoryProvider, m.location, program, monitor, log);
			}
		}
		
		var memoryInfoList = directories.get(MinidumpDirectory.TYPE_MEMORYINFOLISTSTREAM);
		if (memoryInfoList != null) {
			for (var m : memoryInfoList)
				loadPrivateMemory(provider, memoryProvider, m.location, program, monitor, log);
		}

		// The thread list must be processed after the private memory is loaded. The memory loading
		// can't tell stack apart from the heap so instead loading the threads assumes the stack
		// memory has been loaded already and 'steals' it away from the heap.
		var threadList = directories.get(MinidumpDirectory.TYPE_THREADLISTSTREAM);
		if (threadList != null) {
			for (var m : threadList) {
				loadThreads(provider, memoryProvider, loadSpec, m.location, program, monitor, log);
			}
		}
	}

	private MinidumpMemory64List readMemory64(ByteProvider provider, MinidumpLocationDescriptor location, Program program,
			TaskMonitor monitor, MessageLog log) throws IOException {
		if (monitor.isCancelled())
			return new MinidumpMemory64List();

		var list = MinidumpMemory64List.parse(location.offset, provider);
		log.appendMsg(this.getClass().getName(), String.format("  -> Memory segments: %s", list.memoryRangeCount));
		return list;
	}

	private void loadPrivateMemory(ByteProvider provider, ByteProvider memoryProvider, MinidumpLocationDescriptor location,
			Program program, TaskMonitor monitor, MessageLog log) throws IOException, CancelledException {
		if (monitor.isCancelled())
			return;

		AddressFactory af = program.getAddressFactory();
		AddressSpace space = af.getDefaultAddressSpace();

		var list = MinidumpMemoryInfoList.parse(location.offset, provider);
		for (var memoryInfo : list.descriptors) {
			if (memoryInfo.type != MinidumpMemoryInfo.MEM_TYPE_PRIVATE)
				continue;
			if (memoryInfo.state != MinidumpMemoryInfo.MEM_STATE_COMMIT)
				continue;

			FileBytes regionBytes = MemoryBlockUtils.createFileBytes(program, memoryProvider, memoryInfo.baseAddress,
					memoryInfo.regionSize, monitor);

			boolean r = memoryInfo.protect == MinidumpMemoryInfo.PAGE_EXECUTE_READ
					|| memoryInfo.protect == MinidumpMemoryInfo.PAGE_EXECUTE_READWRITE
					|| memoryInfo.protect == MinidumpMemoryInfo.PAGE_EXECUTE_WRITECOPY
					|| memoryInfo.protect == MinidumpMemoryInfo.PAGE_READONLY || memoryInfo.protect == MinidumpMemoryInfo.PAGE_READWRITE
					|| memoryInfo.protect == MinidumpMemoryInfo.PAGE_WRITECOPY;
			boolean w = memoryInfo.protect == MinidumpMemoryInfo.PAGE_EXECUTE_READWRITE
					|| memoryInfo.protect == MinidumpMemoryInfo.PAGE_EXECUTE_WRITECOPY
					|| memoryInfo.protect == MinidumpMemoryInfo.PAGE_READWRITE
					|| memoryInfo.protect == MinidumpMemoryInfo.PAGE_WRITECOPY;
			boolean x = memoryInfo.protect == MinidumpMemoryInfo.PAGE_EXECUTE_READ
					|| memoryInfo.protect == MinidumpMemoryInfo.PAGE_EXECUTE_READWRITE
					|| memoryInfo.protect == MinidumpMemoryInfo.PAGE_EXECUTE_WRITECOPY;
			Address baseAddress = space.getAddress(memoryInfo.baseAddress);
			try {
				MemoryBlockUtils.createInitializedBlock(program, false, "private_memory", baseAddress, regionBytes, 0,
						memoryInfo.regionSize, "", "", r, w, x, log);
			} catch (AddressOverflowException e) {
				throw new IOException(e);
			}
		}
	}

	class PeImageData {
		PeLoader loader;
		PeLoader.ImageInfo info;
		ByteProvider peBytes;
		MinidumpModule module;
	}

	private void loadModules(ByteProvider provider, LoadSpec loadSpec, ByteProvider memoryProvider, MinidumpLocationDescriptor location,
			Program program, TaskMonitor monitor, MessageLog log) throws CancelledException, IOException {
		if (monitor.isCancelled())
			return;

		var list = MinidumpModuleList.parse(location.offset, provider);
		var progress = 0;
		var images = new ArrayList<PeImageData>();
		for (var module : list.modules) {
			if (monitor.isCancelled())
				return;
			
			log.appendMsg(this.getClass().getName(), String.format("- Module %s", module.name));

			var baseName = module.getBaseName();

			var root = program.getListing().getDefaultRootModule();
			ProgramModule programModule = null;
			var fileName = baseName;
			int counter = 0;
			while (true) {
				try {
					programModule = root.createModule(fileName);
					break;
				} catch (DuplicateNameException e) {
					counter += 1;
					fileName = String.format("%s (%s)", baseName, counter);
				}
			}

			monitor.setMessage(
					String.format("[%s]: Loading PE image: %s...", program.getName(), module.getBaseName()));
			monitor.setProgress(progress * 100 / list.moduleCount);
			var peBytes = new ByteProviderWrapper(memoryProvider, module.imageBase, module.imageSize);
			images.add(loadPeImage(peBytes, loadSpec, programModule, module, program, monitor, log));
			progress++;
		}
		
		for (var image : images)
			processPeImage(image, program, monitor, log);
	}
	
	private PeImageData loadPeImage(ByteProvider peBytes, LoadSpec loadSpec, ProgramModule programModule, MinidumpModule module,
			Program program, TaskMonitor monitor, MessageLog log)
			throws IOException, CancelledException {

		if (monitor.isCancelled())
			return null;

		var loadInfo = new ImageLoadInfo();
		loadInfo.imageBase = module.imageBase;
		loadInfo.imageName = module.getBaseName();
		loadInfo.sharedProgram = true;
		loadInfo.sectionLayout = SectionLayout.MEMORY;
		var peLoader = new PeLoader(loadInfo);
		var image = peLoader.loadImage(peBytes, loadSpec, new ArrayList<>(), program, monitor, log);
		if (monitor.isCancelled())
			return null;
		
		Address moduleStart = program.getImageBase().getNewAddress(module.imageBase);
		Address moduleEnd = moduleStart.add(module.imageSize - 1);
		ModuleBaseMap.markModule(program, moduleStart, moduleEnd);
		
		// Move the sections to the module folder.
		var baseAddr = module.imageBase;
		AddressFactory af = program.getAddressFactory();
		AddressSpace space = af.getDefaultAddressSpace();
		var imageAddr = space.getAddress(baseAddr);
		moveFragment(program, imageAddr, programModule);
		for (var s : image.pe.getNTHeader().getFileHeader().getSectionHeaders()) {
			moveFragment(program, space.getAddress(baseAddr + s.getVirtualAddress()), programModule);
		}
		moveFragment(program, "Debug Data", programModule);

		var result = new PeImageData();
		result.loader = peLoader;
		result.info = image;
		result.peBytes = peBytes;
		result.module = module;

		return result;
	}

	private void moveProgramOptions(MinidumpModule module, Program program) {
		Options programOptions = program.getOptions(Program.PROGRAM_INFO);
		Options allModuleOptions = programOptions.getOptions("Module Information");
		Options moduleOptions = allModuleOptions.getOptions(module.getBaseName().replace('.', '_'));
		
		for (String opt : new String[] {
			PdbParserConstants.PDB_AGE,
			PdbParserConstants.PDB_FILE,
			PdbParserConstants.PDB_GUID,
			PdbParserConstants.PDB_SIGNATURE,
			PdbParserConstants.PDB_VERSION,
			"Debug Misc",
			"Debug Misc Datatype",
		}) {
			if (!programOptions.contains(opt))
				continue;
			
			moduleOptions.setString(opt, programOptions.getString(opt, null));
			programOptions.removeOption(opt);
		}
		
		for (String opt : new String[] {
			"SectionAlignment"
		}) {
			if (!programOptions.contains(opt))
				continue;
			
			moduleOptions.setInt(opt, programOptions.getInt(opt, 0));
			programOptions.removeOption(opt);
		}
		
		for (String opt : new String[] {
			PdbParserConstants.PDB_LOADED,
			RelocationTable.RELOCATABLE_PROP_NAME,
		}) {
			if (!programOptions.contains(opt))
				continue;
			
			moduleOptions.setBoolean(opt, programOptions.getBoolean(opt, false));
			programOptions.removeOption(opt);
		}
	}
	
	private void storeModuleData(PeImageData data, Program program) {

		AddressFactory af = program.getAddressFactory();
		AddressSpace space = af.getDefaultAddressSpace();
		
		var image = data.info;
		var baseAddr = data.module.imageBase;
		
		var rti = getRuntimeInfoAddress(baseAddr, image.pe);
		if (rti == null)
			return;
		var moduleData = new ModuleData(data.module.getBaseName(),
				space.getAddress(baseAddr),
				space.getAddress(rti.start),
				space.getAddress(rti.end));
		ModuleData.setModuleData(program, moduleData);
	}
	
	class AddressRange { long start; long end; }
	private AddressRange getRuntimeInfoAddress(long baseAddress, PortableExecutable pe) {
		NTHeader ntHeader = pe.getNTHeader();
		if (ntHeader == null) {
			return null;
		}
		
		OptionalHeader optionalHeader = ntHeader.getOptionalHeader();
		if (optionalHeader == null) {
			return null;
		}

		DataDirectory[] dataDirectories = optionalHeader.getDataDirectories();
		if (dataDirectories == null) {
			
		}
		if (dataDirectories.length <= OptionalHeader.IMAGE_DIRECTORY_ENTRY_EXCEPTION) {
			return null;
		}
		ExceptionDataDirectory idd =
			(ExceptionDataDirectory) dataDirectories[OptionalHeader.IMAGE_DIRECTORY_ENTRY_EXCEPTION];
		if (idd == null) {
			return null;
		}
		
		AddressRange range = new AddressRange();
		range.start = baseAddress + idd.getVirtualAddress();
		range.end = range.start + idd.getSize();
		return range;
	}
		
	private void processPeImage(PeImageData image, Program program, TaskMonitor monitor, MessageLog log)
			throws IOException {
		
		image.loader.processImage(image.peBytes, image.info, new ArrayList<>(), program, monitor, log);
		moveProgramOptions(image.module, program);
		storeModuleData(image, program);
	}
	
	private void loadThreads(ByteProvider provider, ByteProvider memoryProvider, LoadSpec loadSpec, MinidumpLocationDescriptor location,
			Program program, TaskMonitor monitor, MessageLog log) throws IOException {
		if (monitor.isCancelled())
			return;

		AddressFactory af = program.getAddressFactory();
		AddressSpace space = af.getDefaultAddressSpace();
		
		var threadList = MinidumpThreadList.parse(location.offset, provider);
		for (var thread : threadList.threads) {
			var tib = ThreadInformationBlock.parse(loadSpec, thread.teb, memoryProvider);
			
			var ctx = Context64.parse(thread.threadContext.offset, provider);
			
			var threadData = new ThreadData(
				thread.threadId,
				space.getAddress(tib.stackBase - 1),
				space.getAddress(tib.stackLimit),
				space.getAddress(thread.stack.startOfMemoryRange),
				space.getAddress(ctx.rsp),
				space.getAddress(ctx.rip),
				ctx
			);
			ThreadData.storeThreadData(program, threadData);
			
			var listing = program.getListing();
			var root = listing.getDefaultRootModule();
			ProgramFragment threadStack;
			try {
				threadStack = root.createFragment(String.format("Stack:t%s", thread.threadId));
			} catch (DuplicateNameException e) {
				Msg.warn(this, "Duplicate thread ID: " + thread.threadId);
				continue;
			}
			
			long stackStart = tib.stackLimit;
			long stackEnd = tib.stackBase - 1;
			try {
				threadStack.move(space.getAddress(stackStart), space.getAddress(stackEnd));
			} catch (AddressOutOfBoundsException | NotFoundException e) {
				Msg.warn(this, String.format("Stack for thread %s was not part of the dump.", thread.threadId));
			}
		}
	}

	@Override
	public List<Option> getDefaultOptions(ByteProvider provider, LoadSpec loadSpec, DomainObject domainObject,
			boolean isLoadIntoProgram) {
		List<Option> list = super.getDefaultOptions(provider, loadSpec, domainObject, isLoadIntoProgram);
		return list;
	}

	@Override
	public String validateOptions(ByteProvider provider, LoadSpec loadSpec, List<Option> options, Program program) {
		return super.validateOptions(provider, loadSpec, options, program);
	}

	private void moveFragment(Program program, Address addr, ProgramModule module) {
		var listing = program.getListing();
		for (String tree : listing.getTreeNames()) {
			ProgramFragment fragment = listing.getFragment(tree, addr);
			if (fragment == null)
				continue;

			moveFragment(program, fragment, module);
		}
	}

	private void moveFragment(Program program, String name, ProgramModule module) {
		var listing = program.getListing();
		for (String tree : listing.getTreeNames()) {
			ProgramFragment fragment = listing.getFragment(tree, name);
			if (fragment == null)
				continue;
			
			moveFragment(program, fragment, module);
		}
	}

	private void moveFragment(Program program, ProgramFragment fragment, ProgramModule module) {
		ProgramModule[] oldParents = fragment.getParents();
		try {
			module.add(fragment);
		} catch (DuplicateGroupException e) {
			// Log error and continue, the fragment will remain in the old place.
			Msg.error(this, e);
			return;
		}

		for (var p : oldParents) {
			try {
				p.removeChild(fragment.getName());
			} catch (NotEmptyException e) {
				throw new IllegalStateException("Fragment could not be moved", e);
			}
		}
		
		try {
			fragment.setName(String.format("%s (%s)", fragment.getName(), module.getName()));
		} catch (DuplicateNameException e) {
			throw new IllegalStateException("Fragment name wasn't unique to begin with", e);
		}
	}
}
```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/loader/MinidumpMemoryProvider.java`:

```java
package net.jubjubnest.minidump.loader;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collections;

import org.bouncycastle.util.Arrays;

import ghidra.app.util.bin.ByteProvider;
import net.jubjubnest.minidump.loader.parser.MinidumpMemory64Descriptor;
import net.jubjubnest.minidump.loader.parser.MinidumpMemory64List;


/**
 * Byte provider that allows reading minidumps as virtual memory.
 *
 * The provider assumes the memory is infinite and uninitialized with zeros.
 * This allows other components to read memory as if it was contiguous even if
 * the minidump itself is missing certain memory pages.
 * 
 * Note that APIs such as 'length()' still return the total memory size.
 */
class MinidumpMemoryProvider implements ByteProvider {

	public MinidumpMemoryProvider(ByteProvider provider, MinidumpMemory64List memoryList) {
		this.provider = provider;
		this.segments = new ArrayList<MinidumpMemory64Descriptor>();
		this.segments.addAll(memoryList.descriptors);
		this.segments.sort((a, b) -> Long.signum(a.baseAddress - b.baseAddress));

		this.totalMemSize = 0;
		this.segmentStarts = new ArrayList<Long>();
		for (var s : segments) {
			if (s.baseAddress + s.segmentSize > totalMemSize)
				totalMemSize = s.baseAddress + s.segmentSize;
			this.segmentStarts.add(s.baseAddress - 1);
		}
	}

	ByteProvider provider;
	ArrayList<MinidumpMemory64Descriptor> segments;
	ArrayList<Long> segmentStarts;
	long totalMemSize;

	@Override
	public File getFile() {
		return provider.getFile();
	}

	@Override
	public String getName() {
		return provider.getName();
	}

	@Override
	public String getAbsolutePath() {
		return provider.getAbsolutePath();
	}

	@Override
	public long length() throws IOException {
		return this.totalMemSize;
	}

	@Override
	public boolean isValidIndex(long index) {
		return index >= 0 && index <= this.totalMemSize;
	}

	@Override
	public void close() throws IOException {
		// Do nothing.
	}

	@Override
	public byte readByte(long index) throws IOException {
		return readBytes(index, 1)[0];
	}

	@Override
	public byte[] readBytes(long index, long length) throws IOException {
		byte[] buffer = new byte[(int) length];

		var written = 0;
		while (written < length) {
			var tail = index + written;
			var remaining = length - written;

			int newlyWritten = this.fillBuffer(buffer, written, tail, (int) remaining);
			if (newlyWritten == -1)
				throw new IOException("EOF");
			written += newlyWritten;
		}

		return buffer;
	}

	private int fillBuffer(byte[] buffer, int dstOffset, long offset, int length) throws IOException {
		length = Integer.min(length, buffer.length);

		// Find the segment.
		// The binary search will find the segment the start of which is at the given start or the last one before it.
		int idx = Collections.binarySearch(this.segmentStarts, offset);
		if (idx < 0)
			idx = -idx - 1;
		if (idx == 0)
			return -1;
		idx -= 1;
		var segment = this.segments.get(idx);

		// Check whether the found segment has bytes available for the given range.
		var segmentOffset = offset - segment.baseAddress;
		var segmentAvailable = segment.segmentSize - segmentOffset;
		if (segmentAvailable > 0)
		{
			// Bytes available. We should try to write as much as asked, but cap at the amount of bytes available.
			var bytesToWrite = (int) Long.min(segmentAvailable, length);
			var chunk = this.provider.readBytes(segment.dataOffset + segmentOffset, bytesToWrite);
			System.arraycopy(chunk, 0, buffer, dstOffset, bytesToWrite);
			return bytesToWrite;
		}
		else if( idx + 1 < this.segments.size() )
		{
			// No bytes available, but a next segment exists.
			// We'll assume the bytes from this segment to the next are 0.
			var nextSegment = this.segments.get(idx + 1);
			var bytesToNextSegment = nextSegment.baseAddress - offset;
			var bytesToWrite = (int) Long.min(bytesToNextSegment, length);
			Arrays.fill(buffer, 0, bytesToWrite, (byte)0);
			return bytesToWrite;
		}
		else
		{
			// No further segments.
			// Just keep returning zero bytes.
			Arrays.fill(buffer, 0, length, (byte)0);
			return length;
		}
	}

	@Override
	public InputStream getInputStream(long index) throws IOException {
		return new MemoryStream(index);
	}

	class MemoryStream extends InputStream {

		MemoryStream(long index) {
			this.index = index;
		}

		long index;

		@Override
		public int read() throws IOException {
			int i = readByte(this.index);
			this.index += 1;
			return i;
		}

		@Override
		public int read(byte[] b, int off, int len) throws IOException {
			if (b == null)
				throw new NullPointerException();
			if (off < 0 || len < 0 || len > b.length - off)
				throw new IndexOutOfBoundsException();

			int written = fillBuffer(b, off, this.index, len);
			if (written != -1)
				this.index += written;
			return written;
		}
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/loader/parser/MinidumpDirectory.java`:

```java
package net.jubjubnest.minidump.loader.parser;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

import ghidra.app.util.bin.ByteProvider;

public class MinidumpDirectory {
	public static final int RECORD_SIZE = 4 + MinidumpLocationDescriptor.RECORD_SIZE;

	public static MinidumpDirectory parse(long offset, ByteProvider provider) throws IOException {
		var bytes = provider.readBytes(offset, RECORD_SIZE);
		var byteBuffer = ByteBuffer.wrap(bytes);
		byteBuffer.order(ByteOrder.LITTLE_ENDIAN);
		return parse(byteBuffer);
	}

	public static MinidumpDirectory parse(ByteBuffer byteBuffer) {
		var directory = new MinidumpDirectory();
		directory.streamType = byteBuffer.getInt();
		directory.location = MinidumpLocationDescriptor.parse(byteBuffer);
		return directory;
	}

	public int streamType;
	public MinidumpLocationDescriptor location;

	public static final int TYPE_UNUSED = 0;
	public static final int TYPE_RESERVED0 = 1;
	public static final int TYPE_RESERVED1 = 2;
	public static final int TYPE_THREADLISTSTREAM = 3;
	public static final int TYPE_MODULELISTSTREAM = 4;
	public static final int TYPE_MEMORYLISTSTREAM = 5;
	public static final int TYPE_EXCEPTIONSTREAM = 6;
	public static final int TYPE_SYSTEMINFOSTREAM = 7;
	public static final int TYPE_THREADEXLISTSTREAM = 8;
	public static final int TYPE_MEMORY64LISTSTREAM = 9;
	public static final int TYPE_COMMENTSTREAMA = 10;
	public static final int TYPE_COMMENTSTREAMW = 11;
	public static final int TYPE_HANDLEDATASTREAM = 12;
	public static final int TYPE_FUNCTIONTABLESTREAM = 13;
	public static final int TYPE_UNLOADEDMODULELISTSTREAM = 14;
	public static final int TYPE_MISCINFOSTREAM = 15;
	public static final int TYPE_MEMORYINFOLISTSTREAM = 16;
	public static final int TYPE_THREADINFOLISTSTREAM = 17;
	public static final int TYPE_HANDLEOPERATIONLISTSTREAM = 18;
	public static final int TYPE_TOKENSTREAM = 19;
	public static final int TYPE_JAVASCRIPTDATASTREAM = 20;
	public static final int TYPE_SYSTEMMEMROYINFOSTREAM = 21;
	public static final int TYPE_PROCESSVMCOUNTERSTREAM = 22;
	public static final int TYPE_IPTTRACESTREAM = 23;
	public static final int TYPE_THREADNAMESTREAM = 24;
	public static final int TYPE_CESTREAMNULL = 25;
	public static final int TYPE_CESTREAMSYSTEMINFO = 26;
	public static final int TYPE_CESTREAMEXCEPTION = 27;
	public static final int TYPE_CESTREAMMODULELIST = 28;
	public static final int TYPE_CESTREAMPROCESSLIST = 29;
	public static final int TYPE_CESTREAMTHREADLIST = 30;
	public static final int TYPE_CESTREAMTHREADCONTEXTLIST = 31;
	public static final int TYPE_CESTREAMTHREADCALLSTACKLIST = 32;
	public static final int TYPE_CESTREAMMEMORYVIRTUALLIST = 33;
	public static final int TYPE_CESTREAMMEMROYPHYSICALLIST = 34;
	public static final int TYPE_CESTREAMBUCKETPARAMETERS = 35;
	public static final int TYPE_CESTREAMPROCESSMODULEMAP = 36;
	public static final int TYPE_CESTREAMDIAGNOSISLIST = 37;
	public static final int TYPE_LASTRESERVEDSTREAM = 38;
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/loader/parser/MinidumpHeader.java`:

```java
package net.jubjubnest.minidump.loader.parser;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

import ghidra.app.util.bin.ByteProvider;

public class MinidumpHeader {
	public static final long RECORD_SIZE = 4 + 2 + 2 + 4 + 4 + 4 + 4 + 8;

	public static MinidumpHeader parse(long offset, ByteProvider provider) throws IOException {
		var bytes = provider.readBytes(offset, RECORD_SIZE);
		var byteBuffer = ByteBuffer.wrap(bytes);
		byteBuffer.order(ByteOrder.LITTLE_ENDIAN);
		return parse(byteBuffer);
	}

	public static MinidumpHeader parse(ByteBuffer byteBuffer) {
		@SuppressWarnings("unused")
		int _signature = byteBuffer.getInt();
		@SuppressWarnings("unused")
		short _internalVersion = byteBuffer.getShort();

		var header = new MinidumpHeader();
		header.version = byteBuffer.getShort();
		header.streamsCount = byteBuffer.getInt();
		header.streamsOffset = byteBuffer.getInt();
		header.checksum = byteBuffer.getInt();
		header.timestamp = byteBuffer.getInt();
		header.flags = byteBuffer.getLong();
		return header;
	}

	public int version;
	public int streamsCount;
	public int streamsOffset;
	public int checksum;
	public int timestamp;
	public long flags;
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/loader/parser/MinidumpLocationDescriptor.java`:

```java
package net.jubjubnest.minidump.loader.parser;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

import ghidra.app.util.bin.ByteProvider;

public class MinidumpLocationDescriptor {
	public static final int RECORD_SIZE = 4 + 4;

	public static MinidumpLocationDescriptor parse(long offset, ByteProvider provider) throws IOException {
		var bytes = provider.readBytes(offset, RECORD_SIZE);
		var byteBuffer = ByteBuffer.wrap(bytes);
		byteBuffer.order(ByteOrder.LITTLE_ENDIAN);
		return parse(byteBuffer);
	}

	public static MinidumpLocationDescriptor parse(ByteBuffer byteBuffer) {
		var descriptor = new MinidumpLocationDescriptor();
		descriptor.size = byteBuffer.getInt();
		descriptor.offset = byteBuffer.getInt();
		return descriptor;
	}

	public int size;
	public int offset;
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/loader/parser/MinidumpMemory64Descriptor.java`:

```java
package net.jubjubnest.minidump.loader.parser;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

import ghidra.app.util.bin.ByteProvider;

public class MinidumpMemory64Descriptor {

	public static final int RECORD_SIZE = 8 + 8;

	public static MinidumpMemory64Descriptor parse(long offset, ByteProvider provider, long dataOffset) throws IOException {
		var bytes = provider.readBytes(offset, RECORD_SIZE);
		var byteBuffer = ByteBuffer.wrap(bytes);
		byteBuffer.order(ByteOrder.LITTLE_ENDIAN);
		return parse(byteBuffer, dataOffset);
	}

	public static MinidumpMemory64Descriptor parse(ByteBuffer byteBuffer, long dataOffset) {
		var descriptor = new MinidumpMemory64Descriptor();
		descriptor.baseAddress = byteBuffer.getLong();
		descriptor.segmentSize = byteBuffer.getLong();
		descriptor.dataOffset = dataOffset;
		return descriptor;
	}

	public long baseAddress;
	public long segmentSize;
	public long dataOffset;
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/loader/parser/MinidumpMemory64List.java`:

```java
package net.jubjubnest.minidump.loader.parser;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.List;

import ghidra.app.util.bin.ByteProvider;

public class MinidumpMemory64List {

	public static final int DESCRIPTOR_SIZE = 8 + 8;

	public static MinidumpMemory64List parse(long offset, ByteProvider provider) throws IOException {
		var bytes = provider.readBytes(offset, DESCRIPTOR_SIZE);
		var byteBuffer = ByteBuffer.wrap(bytes);
		byteBuffer.order(ByteOrder.LITTLE_ENDIAN);

		var list = new MinidumpMemory64List();
		list.memoryRangeCount = byteBuffer.getLong();
		list.dataOffset = byteBuffer.getLong();

		list.descriptors = new ArrayList<MinidumpMemory64Descriptor>((int) list.memoryRangeCount);
		var segmentBytes = provider.readBytes(offset + DESCRIPTOR_SIZE,
				list.memoryRangeCount * MinidumpMemory64Descriptor.RECORD_SIZE);
		var segmentBuffer = ByteBuffer.wrap(segmentBytes);
		segmentBuffer.order(ByteOrder.LITTLE_ENDIAN);

		var dataOffset = list.dataOffset;
		for (int i = 0; i < list.memoryRangeCount; i++) {
			var descriptor = MinidumpMemory64Descriptor.parse(segmentBuffer, dataOffset);
			dataOffset += descriptor.segmentSize;
			list.descriptors.add(descriptor);
		}

		return list;
	}

	public long memoryRangeCount;
	public long dataOffset;

	public List<MinidumpMemory64Descriptor> descriptors;
}
```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/loader/parser/MinidumpMemoryDescriptor.java`:

```java
package net.jubjubnest.minidump.loader.parser;

import java.nio.ByteBuffer;

public class MinidumpMemoryDescriptor {

	public static final int RECORD_SIZE = 8 + MinidumpLocationDescriptor.RECORD_SIZE;

	public static MinidumpMemoryDescriptor parse(ByteBuffer byteBuffer) {
		var mem = new MinidumpMemoryDescriptor();
		
		mem.startOfMemoryRange = byteBuffer.getLong();
		mem.memory = MinidumpLocationDescriptor.parse(byteBuffer);

		return mem;
	}

	public long startOfMemoryRange;
	public MinidumpLocationDescriptor memory;
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/loader/parser/MinidumpMemoryInfo.java`:

```java
package net.jubjubnest.minidump.loader.parser;

import java.nio.ByteBuffer;

public class MinidumpMemoryInfo {

	// Memory info doesn't have definite record size, instead the module info struct
	// specifies the size of the entries.

	public static MinidumpMemoryInfo parse(ByteBuffer byteBuffer) {
		var module = new MinidumpMemoryInfo();

		module.baseAddress = byteBuffer.getLong();
		module.allocationBase = byteBuffer.getLong();
		module.allocationProtect = byteBuffer.getInt();
		module.__alignment1 = byteBuffer.getInt();
		module.regionSize = byteBuffer.getLong();
		module.state = byteBuffer.getInt();
		module.protect = byteBuffer.getInt();
		module.type = byteBuffer.getInt();
		module.__alignment2 = byteBuffer.getInt();

		return module;
	}

	public long baseAddress;
	public long allocationBase;
	public int allocationProtect;
	public int __alignment1;
	public long regionSize;
	public int state;
	public int protect;
	public int type;
	public int __alignment2;

	public final static int MEM_STATE_COMMIT = 0x1000;
	public final static int MEM_STATE_FREE = 0x10000;
	public final static int MEM_STATE_RESERVE = 0x2000;

	public final static int MEM_TYPE_IMAGE = 0x1000000;
	public final static int MEM_TYPE_MAPPED = 0x40000;
	public final static int MEM_TYPE_PRIVATE = 0x20000;

	public final static int PAGE_EXECUTE = 0x10;
	public final static int PAGE_EXECUTE_READ = 0x20;
	public final static int PAGE_EXECUTE_READWRITE = 0x40;
	public final static int PAGE_EXECUTE_WRITECOPY = 0x80;
	public final static int PAGE_NOACCESS = 0x01;
	public final static int PAGE_READONLY = 0x02;
	public final static int PAGE_READWRITE = 0x04;
	public final static int PAGE_WRITECOPY = 0x08;
	public final static int PAGE_TARGETS_INVALID = 0x40000000;
	public final static int PAGE_TARGETS_NO_UPDATE = 0x40000000;
	public final static int PAGE_GUARD = 0x100;
	public final static int PAGE_NOCACHE = 0x200;
	public final static int PAGE_WRITECOMBINE = 0x400;
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/loader/parser/MinidumpMemoryInfoList.java`:

```java
package net.jubjubnest.minidump.loader.parser;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.List;

import ghidra.app.util.bin.ByteProvider;

public class MinidumpMemoryInfoList {

	// Memory info list doesn't have fixed size, instead it carries size information
	// as part of the data.

	public static MinidumpMemoryInfoList parse(long offset, ByteProvider provider) throws IOException {
		var bytes = provider.readBytes(offset, 4 + 4 + 8);
		var byteBuffer = ByteBuffer.wrap(bytes);
		byteBuffer.order(ByteOrder.LITTLE_ENDIAN);

		var list = new MinidumpMemoryInfoList();
		list.headerSize = byteBuffer.getInt();
		list.entrySize = byteBuffer.getInt();
		list.entryCount = byteBuffer.getLong();

		list.descriptors = new ArrayList<MinidumpMemoryInfo>((int) list.entryCount);
		long entriesStart = offset + list.headerSize;
		for (int i = 0; i < list.entryCount; i++) {

			var segmentBytes = provider.readBytes(entriesStart + list.entrySize * i, list.entrySize);
			var segmentBuffer = ByteBuffer.wrap(segmentBytes);
			segmentBuffer.order(ByteOrder.LITTLE_ENDIAN);

			list.descriptors.add(MinidumpMemoryInfo.parse(segmentBuffer));
		}

		return list;
	}

	public int headerSize;
	public int entrySize;
	public long entryCount;

	public List<MinidumpMemoryInfo> descriptors;
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/loader/parser/MinidumpModule.java`:

```java
package net.jubjubnest.minidump.loader.parser;

import java.io.File;
import java.io.IOException;
import java.nio.ByteBuffer;

import ghidra.app.util.bin.ByteProvider;

public class MinidumpModule {

	public static final int RECORD_SIZE = 8 + 4 + 4 + 4 + 4 + VsFixedFileInfo.RECORD_SIZE + MinidumpLocationDescriptor.RECORD_SIZE
			+ MinidumpLocationDescriptor.RECORD_SIZE + 8 + 8;

	public static MinidumpModule parse(ByteBuffer byteBuffer, ByteProvider provider) throws IOException {
		var module = new MinidumpModule();
		module.imageBase = byteBuffer.getLong();
		module.imageSize = byteBuffer.getInt();
		module.checksum = byteBuffer.getInt();
		module.timestamp = byteBuffer.getInt();
		module.moduleNameRva = byteBuffer.getInt();
		module.versionInfo = VsFixedFileInfo.parse(byteBuffer);
		module.cvRecord = MinidumpLocationDescriptor.parse(byteBuffer);
		module.miscRecord = MinidumpLocationDescriptor.parse(byteBuffer);
		module.reserved0 = byteBuffer.getLong();
		module.reserved1 = byteBuffer.getLong();

		module.name = StringReader.readString(module.moduleNameRva, provider);

		return module;
	}

	public String getBaseName() {
		return getFilename(new File(this.name).getPath());
	}

	private String getFilename(String fullPath) {
		// Remove any trailing slashes
		String editedPath = fullPath;
		editedPath = editedPath.replaceAll("[\\/]$", "");

		int lastIndexForwardSlash = editedPath.lastIndexOf('/');
		int lastIndexBackSlash = editedPath.lastIndexOf('\\');

		if (lastIndexForwardSlash == -1 && lastIndexBackSlash == -1) {
			return editedPath;
		}

		int indexToUse = (lastIndexForwardSlash > lastIndexBackSlash) ? lastIndexForwardSlash
				: lastIndexBackSlash;

		return editedPath.substring(indexToUse + 1);
	}
	

	public long imageBase;
	public int imageSize;
	public int checksum;
	public int timestamp;
	public int moduleNameRva;
	public VsFixedFileInfo versionInfo;
	public MinidumpLocationDescriptor cvRecord;
	public MinidumpLocationDescriptor miscRecord;
	public long reserved0;
	public long reserved1;

	public String name;
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/loader/parser/MinidumpModuleList.java`:

```java
package net.jubjubnest.minidump.loader.parser;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.List;

import ghidra.app.util.bin.ByteProvider;

public class MinidumpModuleList {

	public static final int DESCRIPTOR_SIZE = 4;

	public static MinidumpModuleList parse(long offset, ByteProvider provider) throws IOException {
		var bytes = provider.readBytes(offset, DESCRIPTOR_SIZE);
		var byteBuffer = ByteBuffer.wrap(bytes);
		byteBuffer.order(ByteOrder.LITTLE_ENDIAN);

		var list = new MinidumpModuleList();
		list.moduleCount = byteBuffer.getInt();

		var moduleBytes = provider.readBytes(offset + DESCRIPTOR_SIZE, MinidumpModule.RECORD_SIZE * list.moduleCount);
		var moduleBuffer = ByteBuffer.wrap(moduleBytes);
		moduleBuffer.order(ByteOrder.LITTLE_ENDIAN);

		var modules = new ArrayList<MinidumpModule>();
		for (int i = 0; i < list.moduleCount; i++) {
			modules.add(MinidumpModule.parse(moduleBuffer, provider));
		}
		list.modules = modules;

		return list;
	}

	public int moduleCount;
	public List<MinidumpModule> modules;
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/loader/parser/MinidumpThread.java`:

```java
package net.jubjubnest.minidump.loader.parser;

import java.nio.ByteBuffer;

public class MinidumpThread {

	public static final int RECORD_SIZE = 4 + 4 + 4 + 4 + 8 + MinidumpMemoryDescriptor.RECORD_SIZE
			+ MinidumpLocationDescriptor.RECORD_SIZE;

	public static MinidumpThread parse(ByteBuffer byteBuffer) {
		var thread = new MinidumpThread();
		
		thread.threadId = byteBuffer.getInt();
		thread.suspendCount = byteBuffer.getInt();
		thread.priorityClass = byteBuffer.getInt();
		thread.priority = byteBuffer.getInt();
		thread.teb = byteBuffer.getLong();
		thread.stack = MinidumpMemoryDescriptor.parse(byteBuffer);
		thread.threadContext = MinidumpLocationDescriptor.parse(byteBuffer);

		return thread;
	}

	public int threadId;
	public int suspendCount;
	public int priorityClass;
	public int priority;
	public long teb;
	public MinidumpMemoryDescriptor stack;
	public MinidumpLocationDescriptor threadContext;
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/loader/parser/MinidumpThreadList.java`:

```java
package net.jubjubnest.minidump.loader.parser;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.List;

import ghidra.app.util.bin.ByteProvider;

public class MinidumpThreadList {

	public static final int DESCRIPTOR_SIZE = 4;

	public static MinidumpThreadList parse(long offset, ByteProvider provider) throws IOException {
		var bytes = provider.readBytes(offset, DESCRIPTOR_SIZE);
		var byteBuffer = ByteBuffer.wrap(bytes);
		byteBuffer.order(ByteOrder.LITTLE_ENDIAN);

		var list = new MinidumpThreadList();
		list.numberOfThreads = byteBuffer.getInt();

		long entriesStart = offset + DESCRIPTOR_SIZE;
		var segmentBytes = provider.readBytes(entriesStart, list.numberOfThreads * MinidumpThread.RECORD_SIZE);
		var segmentBuffer = ByteBuffer.wrap(segmentBytes);
		segmentBuffer.order(ByteOrder.LITTLE_ENDIAN);

		list.threads = new ArrayList<MinidumpThread>(list.numberOfThreads);
		for (int i = 0; i < list.numberOfThreads; i++) {
			list.threads.add(MinidumpThread.parse(segmentBuffer));
		}

		return list;
	}

	public int numberOfThreads;
	public List<MinidumpThread> threads;
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/loader/parser/StringReader.java`:

```java
package net.jubjubnest.minidump.loader.parser;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.charset.Charset;

import ghidra.app.util.bin.ByteProvider;

public class StringReader {
	public static String readString(long offset, ByteProvider provider) throws IOException {
		var headerBytes = provider.readBytes(offset, 4);
		var byteBuffer = ByteBuffer.wrap(headerBytes);
		byteBuffer.order(ByteOrder.LITTLE_ENDIAN);

		var size = byteBuffer.getInt();
		if (size % 2 == 1)
			throw new IOException("Invalid string data");

		var dataBytes = provider.readBytes(offset + 4, size);
		var charset = Charset.forName("UTF-16LE");
		var dataBuffer = ByteBuffer.wrap(dataBytes);
		return charset.decode(dataBuffer).toString();
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/loader/parser/ThreadInformationBlock.java`:

```java
package net.jubjubnest.minidump.loader.parser;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

import ghidra.app.util.bin.ByteProvider;
import ghidra.app.util.opinion.LoadSpec;
import ghidra.program.model.lang.LanguageNotFoundException;

/**
 * Windows TIB
 */
public class ThreadInformationBlock {

	public static final int RECORD_SIZE = 8 + 8 + 8;

	public static ThreadInformationBlock parse(LoadSpec loadSpec, long offset, ByteProvider provider) throws IOException {
		var bytes = provider.readBytes(offset, RECORD_SIZE);
		var byteBuffer = ByteBuffer.wrap(bytes);
		byteBuffer.order(ByteOrder.LITTLE_ENDIAN);
		return parse(loadSpec, byteBuffer);
	}

	public static ThreadInformationBlock parse(LoadSpec loadSpec, ByteBuffer byteBuffer) {
		boolean is64 = true;
		try {
			is64 = loadSpec.getLanguageCompilerSpec().getLanguage().getLanguageDescription().getSize() == 64;
		} catch (LanguageNotFoundException e) {
			// Assume 64.
		}

		var info = new ThreadInformationBlock();
		if(is64) {
			info.sehFrame = byteBuffer.getLong();
			info.stackBase = byteBuffer.getLong();
			info.stackLimit = byteBuffer.getLong();
		} else {
			info.sehFrame = byteBuffer.getInt();
			info.stackBase = byteBuffer.getInt();
			info.stackLimit = byteBuffer.getInt();
		}
		return info;
	}

	public long sehFrame;
	public long stackBase;
	public long stackLimit;
	// ... and more. The stack limits are what we are interested in.
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/loader/parser/VsFixedFileInfo.java`:

```java
package net.jubjubnest.minidump.loader.parser;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

import ghidra.app.util.bin.ByteProvider;

/**
 * VS_FIXEDFILEINFO
 * 
 * https://docs.microsoft.com/en-us/windows/win32/api/verrsrc/ns-verrsrc-vs_fixedfileinfo
 */
public class VsFixedFileInfo {

	public static final int RECORD_SIZE = 4 + 4 + 8 + 8 + 4 + 4 + 4 + 4 + 4 + 8;

	public static VsFixedFileInfo parse(long offset, ByteProvider provider) throws IOException {
		var bytes = provider.readBytes(offset, RECORD_SIZE);
		var byteBuffer = ByteBuffer.wrap(bytes);
		byteBuffer.order(ByteOrder.LITTLE_ENDIAN);
		return parse(byteBuffer);
	}

	public static VsFixedFileInfo parse(ByteBuffer byteBuffer) {
		var info = new VsFixedFileInfo();
		info.signature = byteBuffer.getInt();
		info.structVersion = byteBuffer.getInt();
		info.fileVersion = byteBuffer.getLong();
		info.productVersion = byteBuffer.getLong();
		info.flagsMask = byteBuffer.getInt();
		info.flags = byteBuffer.getInt();
		info.fileOs = byteBuffer.getInt();
		info.fileType = byteBuffer.getInt();
		info.fileSubtype = byteBuffer.getInt();
		info.fileDate = byteBuffer.getLong();
		return info;
	}

	public int signature;
	public int structVersion;
	public long fileVersion;
	public long productVersion;
	public int flagsMask;
	public int flags;
	public int fileOs;
	public int fileType;
	public int fileSubtype;
	public long fileDate;
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/plugin/MinidumpPluginPackage.java`:

```java
package net.jubjubnest.minidump.plugin;

import javax.swing.Icon;

import ghidra.framework.plugintool.util.PluginPackage;
import resources.ResourceManager;

public class MinidumpPluginPackage extends PluginPackage {
	public static final String NAME = "Minidump";

	protected MinidumpPluginPackage(String name, Icon icon, String description) {
		super(NAME, ResourceManager.loadImage("images/vcard.png"),
				"Plugins for working with Windows Minidump files.");
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/plugin/ModuleList.java`:

```java
package net.jubjubnest.minidump.plugin;

import java.util.List;

import docking.widgets.table.GTable;
import ghidra.program.model.listing.Program;

class ModuleList extends GTable {
	
	private List<ModuleListItem> items;
	private ModuleListModel model;
	
	public ModuleList() {
	}
	
	public void setFrames(List<ModuleListItem> items, Program program) {

		this.items = items;
		model = new ModuleListModel(items);
		this.setModel(model);
	}
	
	public ModuleListItem getModule(int idx) {
		return items.get(idx);
	}

	@Override
	public boolean isCellEditable(int row, int column) {
		return false;
	}
	
	@Override
	public boolean getColumnSelectionAllowed() {
		return false;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/plugin/ModuleListItem.java`:

```java
package net.jubjubnest.minidump.plugin;

import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import net.jubjubnest.minidump.data.ModuleData;

class ModuleListItem {
	
	public String name;
	public Address baseAddress;
	public String symbolPath;
	public boolean symbolsLoaded;
	
	public ModuleListItem(Program program, ModuleData data) {
		this.name = data.name;
		this.symbolPath = data.loadedSymbols;
		this.symbolsLoaded = data.loadedSymbols != null;
		this.baseAddress = data.baseAddress;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/plugin/ModuleListModel.java`:

```java
package net.jubjubnest.minidump.plugin;

import java.util.List;

import javax.swing.table.AbstractTableModel;

import ghidra.util.exception.NotYetImplementedException;

class ModuleListModel extends AbstractTableModel {
	
	private List<ModuleListItem> items;
	private String[] headers = new String[] {
		"Name",
		"Symbols",
	};
	
	public ModuleListModel(List<ModuleListItem> items) {
		this.items = items;
	}
	
	@Override
	public String getColumnName(int column) {
		return headers[column];
	}

	@Override
	public int getRowCount() {
		return items.size();
	}

	@Override
	public int getColumnCount() {
		return 2;
	}

	@Override
	public Object getValueAt(int rowIndex, int columnIndex) {
		ModuleListItem item = items.get(rowIndex);
		
		switch (columnIndex) {
		case 0:
			return item.name;
		case 1:
			if (item.symbolPath == null) {
				return "No symbols";
			}
			
			if (item.symbolsLoaded) {
				return "Loaded: " + item.symbolPath;
			}
			return "Located: " + item.symbolPath;
		default:
			throw new NotYetImplementedException();
		}
	}

}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/plugin/ModuleViewPlugin.java`:

```java
package net.jubjubnest.minidump.plugin;

import ghidra.app.events.ProgramActivatedPluginEvent;
import ghidra.app.plugin.PluginCategoryNames;
import ghidra.app.plugin.ProgramPlugin;
import ghidra.app.services.GoToService;
import ghidra.framework.plugintool.PluginEvent;
import ghidra.framework.plugintool.PluginInfo;
import ghidra.framework.plugintool.PluginTool;
import ghidra.framework.plugintool.util.PluginStatus;
import ghidra.program.model.listing.Program;

//@formatter:off
@PluginInfo(
	status = PluginStatus.STABLE,
	packageName = MinidumpPluginPackage.NAME,
	category = PluginCategoryNames.NAVIGATION,
	shortDescription = "Display Minidump loaded module information.",
	description = "Display Minidump loaded module information."
)
//@formatter:on
public class ModuleViewPlugin extends ProgramPlugin {

	ModuleViewProvider modulesProvider;
	GoToService goToService;
	Program program;

	public ModuleViewPlugin(PluginTool tool) {
		super(tool, false, false);
		modulesProvider = new ModuleViewProvider(this, getName());
	}

	@Override
	public void init() {
		super.init();
		goToService = tool.getService(GoToService.class);
	}
	
	@Override
	public void processEvent(PluginEvent event)
	{
		if (event instanceof ProgramActivatedPluginEvent)
		{
			var ev = (ProgramActivatedPluginEvent)event;
			program = ev.getActiveProgram();
			modulesProvider.programActivated(program);
		}
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/plugin/ModuleViewProvider.java`:

```java
package net.jubjubnest.minidump.plugin;

import java.awt.BorderLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;

import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.SwingConstants;
import javax.swing.table.DefaultTableModel;

import docking.ActionContext;
import docking.ComponentProvider;
import docking.action.DockingAction;
import docking.action.ToolBarData;
import ghidra.framework.model.DomainObjectChangeRecord;
import ghidra.framework.model.DomainObjectChangedEvent;
import ghidra.framework.model.DomainObjectListener;
import ghidra.program.model.listing.Program;
import ghidra.program.util.ChangeManager;
import ghidra.program.util.CodeUnitPropertyChangeRecord;
import net.jubjubnest.minidump.data.ModuleData;
import resources.Icons;

class ModuleViewProvider extends ComponentProvider implements DomainObjectListener {
	
	public static final String NAME = "Memory Dump Modules";
	
	private ModuleViewPlugin plugin;
	private JPanel panel;
	private ModuleList table;
	private Program program;
	private DockingAction action;

	public ModuleViewProvider(ModuleViewPlugin plugin, String owner) {
		super(plugin.getTool(), NAME, owner);
		this.plugin = plugin;

		buildPanel();
		createActions();
	}

	// Customize GUI
	private void buildPanel() {

		table = new ModuleList();
		panel = new JPanel(new BorderLayout());

		addToTool();
		programActivated(null);
	}
	
	static int counter = 0;
	
	

	// TODO: Customize actions
	private void createActions() {
		action = new DockingAction("Load Located Symbols", getName()) {
			@Override
			public void actionPerformed(ActionContext context) {
			}
		};
		action.setToolBarData(new ToolBarData(Icons.ADD_ICON, null));
		action.setEnabled(true);
		action.markHelpUnnecessary();
		dockingTool.addLocalAction(this, action);

		table.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				if (e.getClickCount() == 2) {
					navigateModule(table.getSelectedRow());
				}
			}
		});
	}
	
	public void programActivated(Program newProgram) {
		if (this.program != null) {
			this.program.removeListener(this);
		}

		this.program = newProgram;
		
		if (this.program != null) {
			this.program.addListener(this);
		}

		refreshModules();
	}

	void navigateModule(int idx) {
		var module = table.getModule(idx);
		if (module == null)
			return;
		plugin.goToService.goTo(module.baseAddress);
	}

	public void refreshModules() {
		if (program == null) {
			panel.removeAll();
			panel.add(new JLabel("No program loaded", SwingConstants.CENTER));
			this.table.setModel(new DefaultTableModel());
			return;
		}

		List<ModuleData> moduleData = ModuleData.getAllModules(program);
		if (moduleData == null) {
			panel.removeAll();
			panel.add(new JLabel("No module information present in the loaded program", SwingConstants.CENTER));
			this.table.setModel(new DefaultTableModel());
			return;
		}
		
		panel.removeAll();
		panel.add(new JScrollPane(table));
		
		List<ModuleListItem> items = new ArrayList<>();
		for (ModuleData md : moduleData) {
			items.add(new ModuleListItem(program, md));
		}
		this.table.setFrames(items, program);
	}

	@Override
	public JComponent getComponent() {
		return panel;
	}

	@Override
	public void domainObjectChanged(DomainObjectChangedEvent ev) {
		if (!ev.containsEvent(ChangeManager.DOCR_CODE_UNIT_PROPERTY_CHANGED)) {
			return;
		}
		
		for (DomainObjectChangeRecord e : ev) {
			switch (e.getEventType()) {
			case ChangeManager.DOCR_CODE_UNIT_PROPERTY_CHANGED:
				CodeUnitPropertyChangeRecord propChange = (CodeUnitPropertyChangeRecord)e;
				if (propChange.getPropertyName().equals(ModuleData.PROPERTY_NAME)) {
					refreshModules();
				}
				break;
			}
		}
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/plugin/StackList.java`:

```java
package net.jubjubnest.minidump.plugin;

import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.List;

import javax.swing.table.TableColumnModel;

import docking.widgets.table.GTable;
import ghidra.program.model.listing.Program;

class StackList extends GTable {
	
	private ThreadViewPlugin plugin;
	private List<StackListItem> frames;
	private StackListModel model;
	
	public StackList(ThreadViewPlugin plugin) {
		this.plugin = plugin;

		this.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				if (e.getClickCount() == 2) {
					boolean goToStack = StackList.this.getSelectedColumn() == 0;
					navigateStack(StackList.this.getSelectedRow(), goToStack);
				}
			}
		});
	}
	
	public void setFrames(List<StackListItem> frames, Program program) {

		this.frames = frames;
		model = new StackListModel(frames, program);
		this.setModel(model);
		TableColumnModel columns = getColumnModel();
		columns.getColumn(0).setPreferredWidth(100);
		columns.getColumn(1).setPreferredWidth(1000);
		columns.getColumn(2).setPreferredWidth(100);
		columns.getColumn(3).setPreferredWidth(100);
	}
	
	public void updateAnalysis(Program program) {
		if (model != null) {
			model.updateAnalysis(program);
		}
	}
	
	private void navigateStack(int item, boolean goToStack) {
		var frame = frames.get(item);
		if (frame == null)
			return;
		if (goToStack) {
			plugin.goToService.goTo(frame.stackPointer);
		} else {
			plugin.goToService.goTo(frame.instructionPointer);
		}
	}

	@Override
	public boolean isCellEditable(int row, int column) {
		return false;
	}
	
	@Override
	public boolean getColumnSelectionAllowed() {
		return false;
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/plugin/StackListItem.java`:

```java
package net.jubjubnest.minidump.plugin;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidra.program.model.mem.MemoryAccessException;

class StackListItem {
	Address stackPointer;
	Address instructionPointer;
	Address returnPointer;
	long functionOffset;
	String module;
	
	public StackListItem(
			Address stackPointer,
			Address instructionPointer,
			Address returnPointer,
			long functionOffset,
			String module) {
		this.stackPointer = stackPointer;
		this.instructionPointer = instructionPointer;
		this.returnPointer = returnPointer;
		this.functionOffset = functionOffset;
		this.module = module;
	}
	
	public Address getReturnAddress(Program program) {
		var langDesc = program.getLanguage().getLanguageDescription();
		var ptrSize = langDesc.getSize();
		var buffer = new byte[ptrSize / 8];
		try {
			program.getMemory().getBytes(this.returnPointer, buffer);
		} catch (MemoryAccessException e) {
			return null;
		}
		
		long addr = 0;
		var bb = ByteBuffer.wrap(buffer);
		bb.order(ByteOrder.LITTLE_ENDIAN);
		if (buffer.length == 8) {
			addr = bb.getLong();
		} else {
			addr = bb.getInt();
		}
		return this.returnPointer.getNewAddress(addr);
	}
}
```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/plugin/StackListModel.java`:

```java
package net.jubjubnest.minidump.plugin;

import java.util.ArrayList;
import java.util.List;

import javax.swing.table.AbstractTableModel;

import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;

class StackListModel extends AbstractTableModel {
	
	private static final String[] HEADERS = new String[] {
		"Stack Frame",
		"Function",
		"Frame Size",
		"Module",
	};
	
	static class Item {
		StackListItem frame;
		String function;
	}
	private List<Item> items;

	public StackListModel(List<StackListItem> frames, Program program) {
		items = new ArrayList<>(frames.size());
		for (StackListItem f : frames) {
			Item item = new Item();
			item.frame = f;
			items.add(item);
		}

		updateAnalysis(program);
	}
	
	public void updateAnalysis(Program program) {
		int min = Integer.MAX_VALUE;
		int max = 0;

		for (int i = 0; i < items.size(); i++) {
			Item item = items.get(i);

			String newName = null;
			Function newFn = program.getListing().getFunctionContaining(item.frame.instructionPointer);
			if (newFn != null) {
				newName = newFn.getName();
			}
				
			if (newName != item.function) {
				item.function = newName;
				max = i;
				if (i < min) {
					min = i;
				}
			}
		}
		
		if (min != Integer.MAX_VALUE) {
			fireTableRowsUpdated(min, max);
		}
	}
	
	@Override
	public String getColumnName(int column) {
		return HEADERS[column];
	}

	@Override
	public int getRowCount() {
		return items.size();
	}

	@Override
	public int getColumnCount() {
		return 4;
	}

	@Override
	public Object getValueAt(int rowIndex, int columnIndex) {

		Item item = items.get(rowIndex);
		StackListItem frame = item.frame;

		switch (columnIndex) {
		case 0:
			return frame.stackPointer.toString();
		case 1:
			if (item.function != null)
				return item.function + " + " + Long.toHexString(frame.functionOffset);
			return frame.instructionPointer.subtract(frame.functionOffset) + " + " + Long.toHexString(frame.functionOffset);
		case 2:
			return Long.toString(frame.returnPointer.subtract(frame.stackPointer));
		case 3:
			return frame.module;
		}

		throw new IndexOutOfBoundsException();
	}
	
	@Override
	public boolean isCellEditable(int rowIndex, int columnIndex) {
		return false;
	}
}
```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/plugin/ThreadViewPlugin.java`:

```java
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.jubjubnest.minidump.plugin;

import ghidra.app.events.ProgramActivatedPluginEvent;
import ghidra.app.plugin.PluginCategoryNames;
import ghidra.app.plugin.ProgramPlugin;
import ghidra.app.services.GoToService;
import ghidra.framework.plugintool.*;
import ghidra.framework.plugintool.util.PluginStatus;
import ghidra.program.model.listing.Program;

//@formatter:off
@PluginInfo(
	status = PluginStatus.STABLE,
	packageName = MinidumpPluginPackage.NAME,
	category = PluginCategoryNames.NAVIGATION,
	shortDescription = "Displays Minidump Thread information.",
	description = "Lists Thread information contained in the Minidump and resolves the call stacks for each thread."
)
//@formatter:on
public class ThreadViewPlugin extends ProgramPlugin {

	ThreadViewProvider threadsProvider;
	GoToService goToService;
	Program program;

	/**
	 * Plugin constructor.
	 * 
	 * @param tool The plugin tool that this plugin is added to.
	 */
	public ThreadViewPlugin(PluginTool tool) {
		super(tool, false, false);
		threadsProvider = new ThreadViewProvider(this, getName());
	}

	@Override
	public void init() {
		super.init();
		goToService = tool.getService(GoToService.class);
	}
	
	@Override
	public void processEvent(PluginEvent event)
	{
		if (event instanceof ProgramActivatedPluginEvent)
		{
			var ev = (ProgramActivatedPluginEvent)event;
			program = ev.getActiveProgram();
			threadsProvider.programActivated(program);
		}
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/plugin/ThreadViewProvider.java`:

```java
package net.jubjubnest.minidump.plugin;

import java.awt.BorderLayout;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.List;

import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.ListSelectionModel;
import javax.swing.SwingConstants;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.table.DefaultTableModel;

import javax.swing.JScrollPane;
import javax.swing.JSplitPane;

import docking.ComponentProvider;
import docking.widgets.table.GTable;
import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.ByteProvider;
import ghidra.app.util.bin.MemoryByteProvider;
import ghidra.framework.model.DomainObjectChangedEvent;
import ghidra.framework.model.DomainObjectListener;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import net.jubjubnest.minidump.data.ModuleData;
import net.jubjubnest.minidump.data.ThreadData;
import net.jubjubnest.minidump.plugin.parser.RuntimeFunction;
import net.jubjubnest.minidump.plugin.parser.RuntimeInfo;

// TODO: If provider is desired, it is recommended to move it to its own file
class ThreadViewProvider extends ComponentProvider implements DomainObjectListener {
	
	public static final String NAME = "Memory Dump Threads";

	private JPanel panel;
	private GTable threadTable;
	private StackList stackList;
	private Program program;
	private List<ThreadData> threadList;
	private ThreadViewPlugin plugin;
	private ThreadData activeThread;
	
	private JSplitPane activePanel;

	public ThreadViewProvider(ThreadViewPlugin plugin, String owner) {
		super(plugin.getTool(), NAME, owner);
		this.plugin = plugin;
		buildPanel();
	}
	
	// Customize GUI
	private void buildPanel() {

		threadTable = new GTable() {
			@Override
			public boolean isCellEditable(int row, int column) {
				return false;
			}	
		};
		threadTable.setColumnSelectionAllowed(false);
		threadTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		threadTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {
			public void valueChanged(ListSelectionEvent event) {
				if( event.getValueIsAdjusting())
					return;
				
				threadActivated(threadTable.getSelectionModel().getAnchorSelectionIndex());
			}
		});

		stackList = new StackList(this.plugin);

		activePanel = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, new JScrollPane(threadTable), new JScrollPane(stackList));
		panel = new JPanel(new BorderLayout());
		
		addToTool();
		programActivated(null);
	}
	
	public void programActivated(Program newProgram)
	{
		if (program != null) {
			program.removeListener(this);
			program = null;
		}

		if( newProgram == null ) {
			setInactive("No program loaded");
			return;
		}

		program = newProgram;
		program.addListener(this);
	
		threadList = ThreadData.getAllThreadData(program);
		if (threadList == null || threadList.size() == 0) {
			setInactive("No thread information present in the loaded program");
			return;
		}
		
		setActive();
		
		String[] headers = { "Thread ID", "StackP.", "InstP." };
		String[][] data = new String[threadList.size()][headers.length];
		for (int i = 0; i < threadList.size(); i++) {
			var thread = threadList.get(i);
			data[i][0] = Integer.toString(thread.id);
			data[i][1] = thread.sp.toString();
			data[i][2] = thread.ip.toString();
		}
		var model = new DefaultTableModel(data, headers);
		threadTable.setModel(model);
		threadTable.setRowSelectionInterval(0, 0);
	}
	
	public void threadActivated(int threadIdx) {
		if (threadIdx == -1) {
			activeThread = null;
		} else {
			activeThread = threadList.get(threadIdx);
		}

		refreshStack();
	}
	
	private void refreshStack() {
		var frames = new ArrayList<StackListItem>();
		if (activeThread == null) {
			stackList.setFrames(frames, program);
			return;
		}

		// Set up a pointer-sized byte buffer for re-using when reading addresses.
		var pointerSize = program.getLanguage().getLanguageDescription().getSize();
		byte[] ptr = new byte[pointerSize / 8];
		var buffer = ByteBuffer.wrap(ptr);
		buffer.order(ByteOrder.LITTLE_ENDIAN);

		// Thread info will give us the top-of-the-stack register values so we'll start with those and then
		// attempt to walk the stack back from there.
		try {
			var firstFrame = getCaller(activeThread.sp, activeThread.ip, buffer);
			while (firstFrame != null) {
				frames.add(firstFrame);
				
				var rip =  firstFrame.getReturnAddress(program);
				if (rip == null)
					break;
				firstFrame = getCaller(firstFrame.returnPointer.add(ptr.length), rip, buffer);
			}
		} catch (IOException e1) {
			// In case of an IO error we'll log it but don't do anything else.
			// Show as much of the stack as we managed to gather.
			Msg.warn(this, "Memory violation when resolving the call stack");
		}
		
		stackList.setFrames(frames, program);
	}
	
	private void setInactive(String message) {
		panel.removeAll();
		panel.add(new JLabel(message, SwingConstants.CENTER));

		threadTable.setModel(new DefaultTableModel());
		threadTable.clearSelection();

		return;
	}
	
	private void setActive() {
		panel.removeAll();
		panel.add(activePanel);
	}
	
	StackListItem getCaller(Address stackPtr, Address instructionPtr, ByteBuffer buffer) throws IOException {

		var memoryProvider = new MemoryByteProvider(program.getMemory(), instructionPtr.getAddressSpace());
		var data = new byte[4*3];
		var rtBuffer = ByteBuffer.wrap(data);
		rtBuffer.order(ByteOrder.LITTLE_ENDIAN);
		
		ModuleData moduleData = ModuleData.getContainingModuleData(program, instructionPtr);
		if (moduleData == null) {
			return null;
		}

		RuntimeFunction runtimeFunction = getRuntimeFunction(instructionPtr, moduleData, memoryProvider);
		if (runtimeFunction == null)
			return null;
		
		UnwindResult unwind = unwindStackPtr(stackPtr, instructionPtr, runtimeFunction, memoryProvider);
		long functionOffset = instructionPtr.subtract(unwind.finalFunction.startOfFunction);
		
		return new StackListItem(stackPtr, instructionPtr, unwind.finalStack, functionOffset, moduleData.name);
	}
	
	static class UnwindResult { Address finalStack; RuntimeFunction finalFunction; }
	UnwindResult unwindStackPtr(Address current, Address instructionPtr, RuntimeFunction rtFunction, ByteProvider memory) throws IOException {

		RuntimeInfo runtimeInfo = rtFunction.readRuntimeInfo(memory);
		RuntimeFunction finalFunction = rtFunction;
		while (runtimeInfo != null) {

			var functionOffset = instructionPtr.subtract(finalFunction.startOfFunction);
			for (var unwindCode : runtimeInfo.unwindCodes ) {
				if (unwindCode.prologOffset <= functionOffset) {
					current = current.add(unwindCode.spEffect);
				}
			}
			
			if (runtimeInfo.parentFunction == null)
				break;

			finalFunction = runtimeInfo.parentFunction;
			runtimeInfo = finalFunction.readRuntimeInfo(memory);
		}
		
		UnwindResult result = new UnwindResult();
		result.finalStack = current;
		result.finalFunction = finalFunction;
		return result;
	}
	
	RuntimeFunction getRuntimeFunction(Address instructionPtr, ModuleData moduleData, ByteProvider memoryProvider) throws IOException {

		Address moduleBaseAddress = moduleData.baseAddress;
		BinaryReader reader = new BinaryReader(memoryProvider, true);
		reader.setPointerIndex(moduleData.rtiStartAddress.getOffset());
		for (;reader.getPointerIndex() < moduleData.rtiEndAddress.getOffset();) {
			
			RuntimeFunction rf = RuntimeFunction.parse(moduleBaseAddress, reader);

			if (rf.startOfFunction.compareTo(instructionPtr) > 0)
				continue;
			if (rf.endOfFunction.compareTo(instructionPtr) < 0)
				continue;
			
			return rf;
		}
		
		return null;
	}

	@Override
	public JComponent getComponent() {
		return panel;
	}

	@Override
	public void domainObjectChanged(DomainObjectChangedEvent ev) {
		this.stackList.updateAnalysis(program);
	}
}
```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/plugin/parser/RuntimeFunction.java`:

```java
package net.jubjubnest.minidump.plugin.parser;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import ghidra.app.util.bin.ByteProvider;
import ghidra.program.model.address.Address;

public class RuntimeFunction {
	
	public Address imageBase;
	public Address startOfFunction;
	public Address endOfFunction;
	public Address runtimeInfo;

	public static RuntimeFunction parse(Address imageBase, BinaryReader reader) throws IOException {
		return new RuntimeFunction(
			imageBase,
			imageBase.add(reader.readNextInt()),
			imageBase.add(reader.readNextInt()),
			imageBase.add(reader.readNextInt()));
	}
	
	public RuntimeFunction(Address base, Address startFn, Address endFn, Address rtInfo) {
		imageBase = base;
		startOfFunction = startFn;
		endOfFunction = endFn;
		runtimeInfo = rtInfo;
	}
	
	public RuntimeInfo readRuntimeInfo(ByteProvider bytes) throws IOException {
		BinaryReader reader = new BinaryReader(bytes, true);
		reader.setPointerIndex(runtimeInfo.getOffset());
		return RuntimeInfo.parse(imageBase, reader);
	}
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/plugin/parser/RuntimeInfo.java`:

```java
package net.jubjubnest.minidump.plugin.parser;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import ghidra.app.util.bin.BinaryReader;
import ghidra.program.model.address.Address;

public class RuntimeInfo {

	public static final long HEADER_SIZE = 4;

	public static RuntimeInfo parse(Address baseAddress, BinaryReader reader) throws IOException {

		var ri = new RuntimeInfo();
		int versionAndFlags = reader.readNextByte();
		ri.version = (byte)(versionAndFlags & 0x03);
		ri.flags = (byte)((versionAndFlags & 0xf4) >> 3);

		ri.prolog = reader.readNextByte();
		ri.unwindCodesCount = reader.readNextByte();

		int frameRegisterData = reader.readNextByte();
		ri.frameRegister = (byte)(frameRegisterData & 0x0f);
		ri.frameRegisterOffset = (byte)((frameRegisterData & 0xf0) >> 4);
		
		List<UnwindCode> unwindCodes = new ArrayList<>();
		for (byte i = 0; i < ri.unwindCodesCount; ) {
			var code = UnwindCode.parse(reader, ri.frameRegisterOffset);
			if (code == null)
				break;
			unwindCodes.add(code);
			i += code.opcodeSize;
			if (i > ri.unwindCodesCount)
				throw new IOException("Too many unwind codes");
		}
		ri.unwindCodes = unwindCodes;
		
		// Check for chained unwind info.
		if ((ri.flags & 0x04) != 0) {
			ri.parentFunction = RuntimeFunction.parse(baseAddress, reader);
		}
		
		return ri;
	}

	public byte version;
	public byte flags;
	public byte prolog;
	public byte unwindCodesCount;
	public byte frameRegister;
	public byte frameRegisterOffset;
	public RuntimeFunction parentFunction;
	
	public List<UnwindCode> unwindCodes;
}

```

`MinidumpLoader/src/main/java/net/jubjubnest/minidump/plugin/parser/UnwindCode.java`:

```java
package net.jubjubnest.minidump.plugin.parser;

import java.io.IOException;

import ghidra.app.util.bin.BinaryReader;
import ghidra.util.exception.NotYetImplementedException;

public class UnwindCode {
	public static UnwindCode parse(BinaryReader reader, byte fpreg) throws IOException {
		var code = new UnwindCode();
		code.prologOffset = reader.readNextByte();
		var op = reader.readNextByte();
		byte opcode = (byte)(op & 0x0f);
		byte opinfo = (byte)((op & 0xf0) >> 4);
		
		switch (opcode) {
		case 0:
			// UWOP_PUSH_NONVOL
			code.spEffect = 8;
			code.opcodeSize = 1;
			break;
		case 1:
			// UWPO_ALLOC_LARGE
			if (opinfo == 0) {
				// Single scaled uint16le
				code.spEffect = (reader.readNextByte() & 0xff) + ((reader.readNextByte() & 0xff) << 8);
				code.spEffect *= 8;
				code.opcodeSize = 2;
			} else {
				// Single unscaled uint32le
				code.spEffect =
						reader.readNextByte() +
						(reader.readNextByte() << 8) +
						(reader.readNextByte() << 16) +
						(reader.readNextByte() << 24);
				code.opcodeSize = 3;
			}
			break;
		case 2:
			// UWPO_ALLOC_SMALL
			code.spEffect = opinfo * 8 + 8;
			code.opcodeSize = 1;
			break;
		case 3:
			code.spEffect = fpreg * 16;
			code.opcodeSize = 1;
			break;
		case 4:
			// Save register into previously allocated stack space.
			reader.readNextShort();
			code.spEffect = 0;
			code.opcodeSize = 2;
			break;
		case 5:
			// Save register into previously allocated stack space.
			reader.readNextShort();
			reader.readNextShort();
			code.spEffect = 0;
			code.opcodeSize = 3;
			break;
		case 6:
			// Save register into previously allocated stack space.
			reader.readNextShort();
			code.spEffect = 0;
			code.opcodeSize = 2;
			break;
		case 7:
			// Save register into previously allocated stack space.
			reader.readNextShort();
			code.spEffect = 0;
			code.opcodeSize = 3;
			break;
		case 8:
			// Save register into previously allocated stack space.
			reader.readNextShort();
			code.spEffect = 0;
			code.opcodeSize = 2;
			break;
		case 9:
			// Save register into previously allocated stack space.
			reader.readNextShort();
			reader.readNextShort();
			code.spEffect = 0;
			code.opcodeSize = 3;
			break;
		case 10:
			if (opcode == 0) {
				code.spEffect = 5 * 8;
			} else if (opinfo == 1) {
				code.spEffect = 6 * 8;
			} else {
				throw new NotYetImplementedException("Machine frame " + opinfo);
			}
			code.opcodeSize = 1;
			break;
			
		default:
			return null;
		}
		
		return code;
	}
	
	public byte prologOffset;
	public int spEffect;
	public byte opcodeSize;
}

```

`MinidumpLoader/src/main/resources/images/README.txt`:

```txt
The "src/resources/images" directory is intended to hold all image/icon files used by
this module.

```

`MinidumpLoader/src/test/java/README.test.txt`:

```txt
The "test" directory is intended to hold unit test cases.  The package structure within
this folder should correspond to that found in the "src" folder.

```

`NOTICE`:

```
Ghidra Minidump Loader

The Ghidra Minidump Loader is released under Apache License, Version 2.0.

Copyright 2020 Mikko Rantanen and Contributors.

---

Ghidra

This product includes software developed at National Security Agency
(https://www.nsa.gov)

Portions of this product were created by the U.S. Government and not subject to
U.S. copyright protections under 17 U.S.C.

The remaining portions are copyright their respective authors and have been
contributed under the terms of one or more open source licenses, and made
available to you under the terms of those licenses. (See LICENSE)

```

`README.md`:

```md
# Windows Minidump loader for Ghidra

### Work in progress

![Ghidra UI](images/readme.png)

# Feature status

## Loader

- [x] Find the modules in the Minidump and load each module separately with the
  PE loader.
- [x] Position the modules to their correct runtime addresses.
- [x] Replace the use of `ImageBaseOffset..` data types with
  `ModuleBaseOffset..`.
- [x] Store the module boundaries in the `UserData`.
- [x] Load the private memory as its own fragment.
- [x] Parse the thread information and separate the thread stacks as their own
  fragments.
- [x] Find the thread information from the dump and store that into `UserData`.

## Thread view

- [x] Display threads and their RSP/RIP registers.
- [x] Implement stack walking based on exception handling `UNWIND_INFO`
  - [x] `UNWIND_CODE` based walking.
  - [x] Chained `RUNTIME_FUNCTION` support.
  - [ ] Frame register support.
  - [ ] 32-bit support.

## Other

See open issues on GitHub.

# Changes to Ghidra packages

The implementation depends heavily on the built-in `PeLoader` and
`PortableExecutable` but required some changes to them:

- Support loading modules to other base addresses than `Program.imageBase`.
- Support loading modules separately from processing them.
- Support linking import symbols directly into memory locations if target
  memory is present.
- Support for `ModuleBaseOffsetXY` data types.

The goal would be to have these changes upstreamed to Ghidra in the future to
avoid the need to duplicate the implementation of the whole `..format.pe.*`
package in the repository. However this work might need some clean up to bring
the current changes up to Ghidra standard. The current changes to the Ghidra
files are made with the goal to keep actual code changes to minimum with no
concern for single-responsibility principle, etc.

## License

The majority of the source code under this repository is covered by the Apache
2.0 License as described in the LICENSE file. The `contrib` package (excluding
the `contrib.new_` contents) is copied over from Ghidra and is covered under
[Ghidra's Apache 2.0 License][apache-ghidra].

[apache-ghidra]:
https://github.com/NationalSecurityAgency/ghidra/blob/8f8c3cfa1406cc4a78b55dac4bb284ab01333bae/LICENSE

```