Project Path: arc_gmh5225_MountSystemPartition_h7o1zdt1

Source Tree:

```txt
arc_gmh5225_MountSystemPartition_h7o1zdt1
├── Files
│   └── MountSystemPartition.cpp
├── MountSystemPartition.sln
├── MountSystemPartition.vcxproj
├── MountSystemPartition.vcxproj.filters
└── README.md

```

`Files/MountSystemPartition.cpp`:

```cpp
#include <Windows.h>
#include <winternl.h>
#include <stdio.h>

/*
	Partial credits: https://stackoverflow.com/a/40217846
	and Louis Bernard in the comments.
*/

NTSTATUS(*ZWQuerySystemInformation)(ULONG, PVOID, ULONG, PULONG) = nullptr;

#define BOOTMGFW_PATH "EFI\\Microsoft\\Boot\\bootmgfw.efi"
#define SYSTEM_SYSTEM_PARTITION_INFORMATION 0x62

struct SystemSystemPartitionInformation
{
	char pad1[16];
	wchar_t buffer[32];
};

/*
	Finds an available volume mount point using GetLogicalDrives.

	@return A string containing the volume mount point if success, nullptr otherwise
*/
char* GetVolumeMountPoint()
{
	static char driveString[4] = "A:\\";

	constexpr char numAlphabet = 26;
	static char drive = -1;

	if (drive != -1)
		return driveString;

	DWORD drives = GetLogicalDrives();
	for (char i = 0; i < numAlphabet; ++i)
	{
		char bit = (drives >> i) & 1;
		if (!bit)
		{
			drive = i;
			break;
		}
	}

	if (drive == -1)
		return nullptr;

	driveString[0] += drive;
	return driveString;
}

/*
	Finds NTDLL functions not contained in the Windows SDK.

	@return True if the functions were found, false otherwise
*/
bool FindNTDLLFunctions()
{
	HMODULE ntdll = LoadLibraryA("ntdll.dll");
	if (!ntdll)
	{
		printf("Failed to load ntdll\n");
		return false;
	}

	ZWQuerySystemInformation = reinterpret_cast<decltype(ZWQuerySystemInformation)>(
		GetProcAddress(ntdll, "ZwQuerySystemInformation"));

	if (!ZWQuerySystemInformation)
	{
		printf("Failed to find ZWQuerySystemInformation\n");
		return false;
	}

	return true;
}

/*
	Opens a handle to the system partition volume.

	@return A handle to the system partition volume if success, INVALID_HANDLE_VALUE otherwise
*/
HANDLE OpenSystemPartitionVolume()
{
	SystemSystemPartitionInformation info{ 0 };
	ULONG returnLength = 0;
	NTSTATUS status = ZWQuerySystemInformation(SYSTEM_SYSTEM_PARTITION_INFORMATION, &info, sizeof(info), &returnLength);

	if (NT_ERROR(status))
	{
		printf("Failed to get partition information (ZWQuerySystemInformation)\n");
		return INVALID_HANDLE_VALUE;
	}
	
	/*
		info.buffer = L"\\Device\\(SomeVolumeHere)
		(https://stackoverflow.com/a/31017010)
	*/
	wchar_t* devicePath = wcsstr(info.buffer + 1, L"\\");
	if (!devicePath)
	{
		printf("Failed to find valid device path\n");
		return INVALID_HANDLE_VALUE;
	}
	
	wchar_t finalPath[256] = L"\\\\?";
	wcscat_s(finalPath, devicePath);
	HANDLE file = CreateFileW(finalPath, FILE_GENERIC_READ, FILE_SHARE_WRITE | 
		FILE_SHARE_READ, nullptr, OPEN_EXISTING, 0, nullptr);

	return file;
}

/*
	Unmounts the system partition.

	@return True if the system partition is unmounted, false otherwise
*/
bool UnMountSystemPartition()
{
	return DeleteVolumeMountPointA(GetVolumeMountPoint());
}

/*
	Mounts a volume using the specified partitionInfo.

	@param partitionInfo - The partition information to use for mounting the volume

	@return True if the volume is mounted, false otherwise
*/
bool MountVolume(PARTITION_INFORMATION_EX* partitionInfo)
{
	char volumeName[256]{ 0 };
	sprintf_s(volumeName, "\\\\?\\Volume{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\\",
		partitionInfo->Gpt.PartitionId.Data1,
		partitionInfo->Gpt.PartitionId.Data2,
		partitionInfo->Gpt.PartitionId.Data3,
		partitionInfo->Gpt.PartitionId.Data4[0],
		partitionInfo->Gpt.PartitionId.Data4[1],
		partitionInfo->Gpt.PartitionId.Data4[2],
		partitionInfo->Gpt.PartitionId.Data4[3],
		partitionInfo->Gpt.PartitionId.Data4[4],
		partitionInfo->Gpt.PartitionId.Data4[5],
		partitionInfo->Gpt.PartitionId.Data4[6],
		partitionInfo->Gpt.PartitionId.Data4[7]);

	char* volume = GetVolumeMountPoint();
	if (!volume)
	{
		printf("Failed to find volume mount point\n");
		return false;
	}

	if (!SetVolumeMountPointA(GetVolumeMountPoint(), volumeName))
	{
		printf("Failed to set volume mount point\n");
		return false;
	}

	return true;
}

/*
	Mounts the system partition.

	@return True if the system partition is mounted, false otherwise
*/
bool MountSystemPartition()
{
	if (!FindNTDLLFunctions())
	{
		printf("Failed to find ntdll functions\n");
		return false;
	}

	HANDLE file = OpenSystemPartitionVolume();
	if (file == INVALID_HANDLE_VALUE)
	{
		printf("Failed to open system partition volume\n");
		return false;
	}

	PARTITION_INFORMATION_EX partitionInfo{};
	DWORD bytes = 0;
	if (!DeviceIoControl(file, IOCTL_DISK_GET_PARTITION_INFO_EX, nullptr,
		0, &partitionInfo, sizeof(partitionInfo), &bytes, nullptr))
	{
		printf("Failed to get partition information (DeviceIoControl)\n");
		CloseHandle(file);
		return false;
	}

	CloseHandle(file);

	return MountVolume(&partitionInfo);
}

/*
	Opens a handle to the bootmgfw.efi file located on the system partition.

	@return A handle to the bootmgfw.efi file if success, INVALID_HANDLE_VALUE otherwise
*/
HANDLE OpenBootmgfw()
{
	char* volume = GetVolumeMountPoint();
	size_t size = strlen(volume) + sizeof(BOOTMGFW_PATH);
	char* bootmgfwPath = new char[size];

	if (!bootmgfwPath)
	{
		printf("Failed to attain bootmgfw.efi path\n");
		return INVALID_HANDLE_VALUE;
	}

	ZeroMemory(bootmgfwPath, size);

	strcpy_s(bootmgfwPath, size, volume);
	strcat_s(bootmgfwPath, size, BOOTMGFW_PATH);

	HANDLE file = CreateFileA(bootmgfwPath, FILE_GENERIC_READ,
		FILE_SHARE_WRITE | FILE_SHARE_READ, nullptr, OPEN_EXISTING, 0, nullptr);

	delete[] bootmgfwPath;

	if (file == INVALID_HANDLE_VALUE)
	{
		printf("Failed to open bootmgfw.efi\n");
		return INVALID_HANDLE_VALUE;
	}

	return file;
}

/*
	The main entry point of the program.

	@return 0 if success, -1 otherwise
*/
int main()
{
	if (!MountSystemPartition())
	{
		printf("Failed to mount system partition\n");
		return -1;
	}

	HANDLE file = OpenBootmgfw();
	if (file == INVALID_HANDLE_VALUE)
	{
		printf("Failed to open bootmgfw.efi\n");
		UnMountSystemPartition();
		return -1;
	}

	WORD signature = 0;
	DWORD bytesRead = 0;
	if (!ReadFile(file, &signature, 2, &bytesRead, nullptr) || bytesRead != 2)
	{
		printf("Failed to read bootmgfw.efi\n");
		CloseHandle(file);
		UnMountSystemPartition();
		return -1;
	}

	if (signature == IMAGE_DOS_SIGNATURE)
	{
		printf("Correctly read bootmgfw.efi\n");
	}
	else
	{
		printf("Incorrectly read bootmgfw.efi\n");
		CloseHandle(file);
		UnMountSystemPartition();
		return -1;
	}

	CloseHandle(file);
	UnMountSystemPartition();

	return 0;
}
```

`MountSystemPartition.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.10.35122.118
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MountSystemPartition", "MountSystemPartition.vcxproj", "{784AFC3E-06B3-47FA-A4A4-6FA8B4AC635C}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{784AFC3E-06B3-47FA-A4A4-6FA8B4AC635C}.Debug|x64.ActiveCfg = Debug|x64
		{784AFC3E-06B3-47FA-A4A4-6FA8B4AC635C}.Debug|x64.Build.0 = Debug|x64
		{784AFC3E-06B3-47FA-A4A4-6FA8B4AC635C}.Debug|x86.ActiveCfg = Debug|Win32
		{784AFC3E-06B3-47FA-A4A4-6FA8B4AC635C}.Debug|x86.Build.0 = Debug|Win32
		{784AFC3E-06B3-47FA-A4A4-6FA8B4AC635C}.Release|x64.ActiveCfg = Release|x64
		{784AFC3E-06B3-47FA-A4A4-6FA8B4AC635C}.Release|x64.Build.0 = Release|x64
		{784AFC3E-06B3-47FA-A4A4-6FA8B4AC635C}.Release|x86.ActiveCfg = Release|Win32
		{784AFC3E-06B3-47FA-A4A4-6FA8B4AC635C}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {E40D8530-BEA4-46F0-87EA-D6CD591C6EAC}
	EndGlobalSection
EndGlobal

```

`MountSystemPartition.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{784afc3e-06b3-47fa-a4a4-6fa8b4ac635c}</ProjectGuid>
    <RootNamespace>MountSystemPartition</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Files\MountSystemPartition.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`MountSystemPartition.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Files\MountSystemPartition.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`README.md`:

```md
# MountSystemPartition

This project demonstrates a method of mounting the system (hidden EFI partition) on Windows only using the Windows API.

## Motivation

I couldn't find any good examples of how to programmatically mount the system partition on Windows, so I decided to
release an example of how to do it in case anyone else finds themselves in a similar situtation in the future.
```