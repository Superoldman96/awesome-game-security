Project Path: arc_gmh5225_owned_alignment_kf90kxxd

Source Tree:

```txt
arc_gmh5225_owned_alignment_kf90kxxd
├── README.md
├── owned_alignment
│   ├── disk_hooker.cpp
│   ├── disk_hooker.hpp
│   ├── driver.cpp
│   ├── driver.hpp
│   ├── entry.cpp
│   ├── ioctl_helper.hpp
│   ├── nt.hpp
│   ├── nt_image.hpp
│   ├── nt_ioctl.hpp
│   ├── nt_pagetable.hpp
│   ├── owned_alignment.vcxproj
│   ├── owned_alignment.vcxproj.filters
│   ├── physical_memory.cpp
│   ├── physical_memory.hpp
│   ├── portable_executable.cpp
│   ├── portable_executable.hpp
│   └── shellcode_generator.hpp
└── owned_alignment.sln

```

`README.md`:

```md
# owned_alignment
Hooking kernel functions by abusing alignment in text sections.

See https://secret.club/2019/11/06/kernel-code-alignment.html

```

`owned_alignment.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.27428.2015
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "owned_alignment", "owned_alignment\owned_alignment.vcxproj", "{68BC6052-80BF-4525-9877-2FA4D3111E39}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Debug|ARM.ActiveCfg = Debug|ARM
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Debug|ARM.Build.0 = Debug|ARM
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Debug|ARM.Deploy.0 = Debug|ARM
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Debug|ARM64.Build.0 = Debug|ARM64
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Debug|x64.ActiveCfg = Debug|x64
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Debug|x64.Build.0 = Debug|x64
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Debug|x64.Deploy.0 = Debug|x64
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Debug|x86.ActiveCfg = Debug|Win32
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Debug|x86.Build.0 = Debug|Win32
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Debug|x86.Deploy.0 = Debug|Win32
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Release|ARM.ActiveCfg = Release|ARM
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Release|ARM.Build.0 = Release|ARM
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Release|ARM.Deploy.0 = Release|ARM
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Release|ARM64.ActiveCfg = Release|ARM64
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Release|ARM64.Build.0 = Release|ARM64
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Release|ARM64.Deploy.0 = Release|ARM64
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Release|x64.ActiveCfg = Release|x64
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Release|x64.Build.0 = Release|x64
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Release|x64.Deploy.0 = Release|x64
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Release|x86.ActiveCfg = Release|Win32
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Release|x86.Build.0 = Release|Win32
		{68BC6052-80BF-4525-9877-2FA4D3111E39}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {3BC1A931-825A-44A8-9CA1-54DB38889DFC}
	EndGlobalSection
EndGlobal

```

`owned_alignment/disk_hooker.cpp`:

```cpp
#include "disk_hooker.hpp"
#include <cstdint>
#include "physical_memory.hpp"
#include "driver.hpp"
#include "ioctl_helper.hpp"
#include "nt_ioctl.hpp"

uint8_t disk_hooker::xor_key = 0;
PDRIVER_DISPATCH disk_hooker::g_original_disk_dispatch = nullptr;
PDRIVER_DISPATCH disk_hooker::g_original_scsi_dispatch = nullptr;

bool disk_hooker::hook_disk_driver()
{
	auto disk_driver = driver::find_from_name(L"\\Driver\\Disk", false);	
	if (!disk_driver.valid())
	{
		DbgPrint("Failed to find driver.\n");
		return false;
	}

	disk_driver.hook_ioctl<true>(disk_hooker::g_original_disk_dispatch, [](DEVICE_OBJECT* device_object, IRP* irp){

		auto current_stack_location = irp->Tail.Overlay.CurrentStackLocation;
		const auto control_code = current_stack_location->Parameters.DeviceIoControl.IoControlCode;
		switch (control_code)
		{
		case IOCTL_STORAGE_QUERY_PROPERTY:
		{
			DbgPrint("[dispatch_hook] IOCTL_STORAGE_QUERY_PROPERTY\n");

			auto property_query = reinterpret_cast<STORAGE_PROPERTY_QUERY*>(irp->AssociatedIrp.SystemBuffer);

			if (property_query && property_query->PropertyId == StorageDeviceProperty)
				ioctl_helper::set_completion_callback(irp, current_stack_location, disk_hooker::storage_query_callback);

			break;
		}
		case DFP_READ_VERSION:
		{
			DbgPrint("[dispatch_hook] DFP_READ_VERSION\n");
			break;
		}
		case SMART_RCV_DRIVE_DATA:
		{
			DbgPrint("[dispatch_hook] SMART_RCV_DRIVE_DATA, handle in SCSI hook!\n");

			break;
		}
		default:
		{
			if (control_code)
				DbgPrint("[dispatch_hook] Control code: %lx\n", control_code);

			break;
		}

		}

		return g_original_disk_dispatch(device_object, irp);
	});

	return true;
}


bool disk_hooker::hook_scsi_driver()
{
	auto scsi_device = driver::find_device(L"\\Device\\ScsiPort0");

	if (!scsi_device)
	{
		DbgPrint("Failed to find device.\n");
		return false;
	}

	auto scsi_driver = driver(scsi_device->DriverObject);

	if (!scsi_driver.valid())
	{
		DbgPrint("Failed to find driver.\n");
		return false;
	}

	scsi_driver.hook_ioctl<true>(disk_hooker::g_original_scsi_dispatch, [](DEVICE_OBJECT* device_object, IRP* irp) {

		auto current_stack_location = irp->Tail.Overlay.CurrentStackLocation;
		const auto control_code = current_stack_location->Parameters.DeviceIoControl.IoControlCode;
		switch (control_code)
		{
		case IOCTL_SCSI_MINIPORT:
		{
			DbgPrint("[dispatch_hook] IOCTL_SCSI_MINIPORT\n");

			auto miniport_query = reinterpret_cast<SRB_IO_CONTROL*>(irp->AssociatedIrp.SystemBuffer);

			if (miniport_query->ControlCode == IOCTL_SCSI_MINIPORT_IDENTIFY)
			{
				DbgPrint("[dispatch_hook] IOCTL_SCSI_MINIPORT_IDENTIFY\n");
				ioctl_helper::set_completion_callback(irp, current_stack_location, disk_hooker::scsi_callback);
			}

			break;
		}
		default:
		{
			if (control_code)
				DbgPrint("[dispatch_hook] Control code: %lx\n", control_code);

			break;
		}

		}

		return g_original_scsi_dispatch(device_object, irp);
	});

	return true;
}

void disk_hooker::setup_xor()
{
	// SET UP XOR KEY
	disk_hooker::xor_key = static_cast<uint8_t>(__rdtsc());
	DbgPrint("Xor key: %x\n", disk_hooker::xor_key);
}


NTSTATUS disk_hooker::storage_query_callback(DEVICE_OBJECT* device_object, IRP* irp, void* context)
{
	if (context == nullptr)
	{
		DbgPrint("storage_query_callback context == nullptr\n");
		return STATUS_SUCCESS;
	}

	// GET CALLBACK DATA
	const auto data = ioctl_helper::fetch_callback_data<STORAGE_DEVICE_DESCRIPTOR>(context);

	if (data.buffer_length < FIELD_OFFSET(STORAGE_DEVICE_DESCRIPTOR, RawDeviceProperties))
	{
		DbgPrint("Requested size\n");
	}
	else if (data.buffer->SerialNumberOffset < FIELD_OFFSET(STORAGE_DEVICE_DESCRIPTOR, RawDeviceProperties))
	{
		DbgPrint("Device doesn't have a serial\n");
	} 
	else if (data.buffer_length < FIELD_OFFSET(STORAGE_DEVICE_DESCRIPTOR, RawDeviceProperties) + data.buffer->RawPropertiesLength || data.buffer->SerialNumberOffset >= data.buffer_length)
	{
		DbgPrint("Unexpected buffer error\n");
	}
	else
	{
		auto serial = reinterpret_cast<unsigned char*>(data.buffer) + data.buffer->SerialNumberOffset;
		DbgPrint("Old serial: %s\n", serial);

		disk_hooker::spoof_serial(serial);

		DbgPrint("New serial: %s\n", serial);
	}

	// CALL NEXT CALLBACK
	if (irp->StackCount > 1ul && data.old_routine)
		return data.old_routine(device_object, irp, data.old_context);


	return STATUS_SUCCESS;
}


NTSTATUS disk_hooker::scsi_callback(DEVICE_OBJECT* device_object, IRP* irp, void* context)
{
	if (context == nullptr)
	{
		DbgPrint("scsi_callback context == nullptr\n");
		return STATUS_SUCCESS;
	}

	// GET CALLBACK DATA
	const auto data = ioctl_helper::fetch_callback_data<SENDCMDOUTPARAMS>(context);

	if (data.buffer_length < FIELD_OFFSET(SENDCMDOUTPARAMS, bBuffer)
		|| FIELD_OFFSET(SENDCMDOUTPARAMS, bBuffer) + data.buffer->cBufferSize > data.buffer_length
		|| data.buffer->cBufferSize < sizeof(IDINFO)
		)
	{
		DbgPrint("Unexpected buffer error\n");
	}
	else
	{
		const auto params = reinterpret_cast<SENDCMDOUTPARAMS*>(data.buffer->bBuffer + sizeof(SRB_IO_CONTROL));
		const auto info = reinterpret_cast<IDINFO*>(params->bBuffer);

		auto serial = reinterpret_cast<unsigned char*>(info->sSerialNumber);

		DbgPrint("Old serial: %s\n", serial);

		disk_hooker::spoof_serial(serial);

		DbgPrint("New serial: %s\n", serial);
	}

	// CALL NEXT CALLBACK
	if (irp->StackCount > 1ul && data.old_routine)
		return data.old_routine(device_object, irp, data.old_context);

	return STATUS_SUCCESS;
}

```

`owned_alignment/disk_hooker.hpp`:

```hpp
#pragma once
#include "nt.hpp"
#include "nt_ioctl.hpp"

namespace disk_hooker
{
	// HOOK DISK DRIVER IOCTL
	bool hook_disk_driver();

	// HOOK SCSI IOCTL
	bool hook_scsi_driver();

	// XOR KEY GENERATED FORM CPU CLOCK TIME, USED TO SPOOF SERIAL
	void setup_xor();
	extern uint8_t xor_key;

	// IOCTL HOOK
	extern PDRIVER_DISPATCH g_original_disk_dispatch;
	extern PDRIVER_DISPATCH g_original_scsi_dispatch;

	// IRP CALLBACKS, THESE ARE CALLED BEFORE IOCTL RETURNS VALUE TO CALLER
	NTSTATUS storage_query_callback(DEVICE_OBJECT* device_object, IRP* irp, void* context);
	//NTSTATUS smart_query_callback(DEVICE_OBJECT* device_object, IRP* irp, void* context);
	NTSTATUS scsi_callback(DEVICE_OBJECT* device_object, IRP* irp, void* context);

	// SPOOFING ROUTINE
	__forceinline void spoof_serial(unsigned char* serial)
	{
		// SPOOF
		for (uint8_t i = 0; serial[i] != 0x00; i++)
		{
			serial[i] = (disk_hooker::xor_key + serial[i]) * i;	// GENERATE RANDOM VALUE FROM INDEX, VALUE AND XOR KEY
			serial[i] %= 'Z' - 'A';								// LIMIT TO A-Z RANGE
			serial[i] += 'A';									// ADD BASE TO DELTA
		}
	}
}
```

`owned_alignment/driver.cpp`:

```cpp
#include "driver.hpp"

portable_executable driver::get_pe()
{
	return portable_executable(this->base_address());
}

uint8_t* driver::base_address()
{
	return reinterpret_cast<uint8_t*>(this->get_object()->DriverStart);
}

uint64_t driver::size()
{
	return this->get_object()->Size;
}

bool driver::valid()
{
	return this->get_object() != nullptr;
}

DRIVER_OBJECT* driver::get_object()
{
	return driver_obj.get();
}

PDRIVER_DISPATCH* driver::major_function(int index)
{
	return &this->get_object()->MajorFunction[index];
}
```

`owned_alignment/driver.hpp`:

```hpp
#pragma once
#include "nt.hpp"
#include "shellcode_generator.hpp"
#include "portable_executable.hpp"

class driver
{
public:
	explicit driver(DRIVER_OBJECT* new_driver_obj) 
	{
		this->driver_obj = referenced_object<DRIVER_OBJECT>();
		this->driver_obj.reset(new_driver_obj);
	}

	template<size_t N>
	[[nodiscard]]
	__forceinline static driver find_from_name(const wchar_t(&name)[N], bool is_device)
	{
		UNICODE_STRING uname;
		uname.Buffer = const_cast<wchar_t*>(name);
		uname.Length = uname.MaximumLength = (N - 1) * sizeof(wchar_t);

		if (is_device)
		{
			DEVICE_OBJECT* device_object;
			ObReferenceObjectByName(&uname,
				OBJ_CASE_INSENSITIVE,
				nullptr,
				0,
				IoDeviceObjectType,
				KernelMode,
				nullptr,
				reinterpret_cast<void**>(&device_object));

			DbgPrint("Device: %p\n", device_object);

			return device_object ? driver(device_object->DriverObject) : driver(nullptr);
		}
		else
		{
			DRIVER_OBJECT* driver_object = nullptr;
			ObReferenceObjectByName(&uname,
				OBJ_CASE_INSENSITIVE,
				nullptr,
				0,
				IoDriverObjectType,
				KernelMode,
				nullptr,
				reinterpret_cast<void**>(&driver_object));

			return driver(driver_object);
		}

	}

	template <size_t N>
	[[nodiscard]]
	__forceinline static DEVICE_OBJECT* find_device(const wchar_t(&name)[N])
	{
		();

		UNICODE_STRING uname;
		uname.Buffer = const_cast<wchar_t*>(name);
		uname.Length = uname.MaximumLength = (N - 1) * sizeof(wchar_t);

		DEVICE_OBJECT* device_object = nullptr;
		FILE_OBJECT* file = nullptr;

		IoGetDeviceObjectPointer(&uname, 0, &file, &device_object);

		return device_object;
	}

	// WRAPPERS
	portable_executable get_pe();

	// DRIVER OBJECT DATA
	uint8_t* base_address();
	uint64_t size();
	DRIVER_OBJECT* get_object();
	PDRIVER_DISPATCH* major_function(int index);

	// SANITY
	bool valid();

	// MODULES

	template <class Fn>
	__forceinline void enumerate_function_calls(Fn fn)
	{
		auto text_section = this->get_pe().get_section(".text");

		for (auto data_pointer = text_section.start;
			data_pointer < text_section.start + text_section.size - 5/*SIZE OF CALL*/;
			data_pointer++)
		{
			// CALL INSTRUCTION
			if (*data_pointer == 0xE8)
			{
				// READ CALL TARGET
				std::uint8_t* operand = data_pointer + *reinterpret_cast<int32_t*>(data_pointer + 1) + 5;

				if (operand < this->base_address() ||
					operand > this->base_address() + this->size())
				{
					if (fn(operand, data_pointer))
						break;
				}
			}
		}
	}

	template <bool trampoline>
	__forceinline bool hook_ioctl(PDRIVER_DISPATCH& original_handler, PDRIVER_DISPATCH fn)
	{
		// FIND TRAMPOLINE INSIDE OF DRIVER TEXT SECTION
		if constexpr(trampoline)
		{
			uint8_t* trampoline_location = nullptr;
			uint8_t* detour_location = nullptr;

			this->enumerate_function_calls([&](uint8_t* operand, uint8_t* data_pointer) {

				DbgPrint("Found call to %llx at %llx\n", operand, data_pointer);

				const auto table_info = physical_memory::query_hardware_table_information(operand);

				if (table_info.pde == nullptr)
				{
					DbgPrint("Call destination has invalid PXE/PPE :(\n");
					return false;
				}

				DbgPrint("Call destination has valid PXE/PPE\n");

				if (physical_memory::is_valid_address(operand))
				{
					DbgPrint("Call destination is already in use :(\n");
					return false;
				}

				DbgPrint("Call destination not in use!\n");

				trampoline_location = operand;
				detour_location = data_pointer;
				return true;

			});

			if (trampoline_location == nullptr)
			{
				DbgPrint("Failed to find possible location, abort!\n");
				return false;
			}

			// SET AS WRITABLE AND EXECUTABLE

			// MAKE PAGE VALID

			if (!physical_memory::protect_memory(trampoline_location, true, true, true))
			{
				DbgPrint("Failed to overwrite memory, abort!\n");
				return false; 
			}

			// GET PAGE INFO
			auto info = physical_memory::query_hardware_table_information(trampoline_location);

			// GET PFN
			auto page_frame_number_pte = MiGetPage(reinterpret_cast<uint32_t*>(MiSystemPartition), 0, 8);
			auto page_frame_number_pde = MiGetPage(reinterpret_cast<uint32_t*>(MiSystemPartition), 0, 8);

			// INITIALIZE PFN
			auto pfn_result_pte = MiInitializePfn(MmPfnDatabase + page_frame_number_pte * 0x30, info.pte, 4, 4);
			auto pfn_result_pde = MiInitializePfn(MmPfnDatabase + page_frame_number_pde * 0x30, info.pde, 4, 4);

			DbgPrint("Pfn result: %02X\n", pfn_result_pte);
			DbgPrint("Pfn result: %02X\n", pfn_result_pde);

			MiMapSinglePage(reinterpret_cast<uint64_t>(trampoline_location), page_frame_number_pte, 0x40000020, 0);

			// UPDATE PDE
			info.pde->u.Hard.PageFrameNumber = page_frame_number_pde;

			// SET EXECUTABLE
			info.pte->u.Hard.NoExecute = 0;
			DbgPrint("Overwrote page protection\n");

			// WRITE TRAMPOLINE WITH OUR DESIRED HOOK AS DESTINATION
			shellcode_generator::call_proxy(trampoline_location, fn);

			// OVERWRITE (DKOM) IOCTL OF DRIVER OBJECT WITH ALLOCATED TRAMPOLINE
			original_handler = *this->major_function(IRP_MJ_DEVICE_CONTROL);

			*this->major_function(IRP_MJ_DEVICE_CONTROL) = reinterpret_cast<PDRIVER_DISPATCH>(detour_location);

			return true;
		}
		// JUST OVERWRITE FUNCTION POINTER
		else
		{
			original_handler = *this->major_function(IRP_MJ_DEVICE_CONTROL);
			*this->major_function(IRP_MJ_DEVICE_CONTROL) = fn;
			return true;
		}
	}

private:
	referenced_object<DRIVER_OBJECT> driver_obj;
};
```

`owned_alignment/entry.cpp`:

```cpp
#include "disk_hooker.hpp"

extern "C" int64_t DriverEntry(void* start_context)
{
	disk_hooker::hook_disk_driver();
}
```

`owned_alignment/ioctl_helper.hpp`:

```hpp
#pragma once
#include "nt.hpp"

struct REQUEST_STRUCT
{
	IO_COMPLETION_ROUTINE* old_routine;
	void* old_context;
	uint32_t output_buffer_length;
	void* system_buffer;
};

// DATA READ FROM ALLOCATED POOL IN COMPLETION HOOKS
template <class T>
struct callback_data
{
	REQUEST_STRUCT*				request;
	uint32_t					buffer_length;
	T*	buffer;
	IO_COMPLETION_ROUTINE*		old_routine;
	void*						old_context;
};

namespace ioctl_helper
{
	// SET UP COMPLETION CALLBACK, THAT IS CALLED BEFORE IOCTL RETURNS VALUE TO CALLER
	__forceinline void set_completion_callback(IRP* irp, IO_STACK_LOCATION* io_stack_location, IO_COMPLETION_ROUTINE* callback)
	{
		// RUN CALLBACK ON SUCCESS
		io_stack_location->Control = SL_INVOKE_ON_SUCCESS;
		auto old_context = io_stack_location->Context;
		io_stack_location->Context = ExAllocatePoolWithTag(NonPagedPool, sizeof(REQUEST_STRUCT), 0);

		auto request = reinterpret_cast<REQUEST_STRUCT*>(io_stack_location->Context);
		request->old_context = old_context;
		request->old_routine = io_stack_location->CompletionRoutine;
		request->system_buffer = irp->AssociatedIrp.SystemBuffer;
		request->output_buffer_length = io_stack_location->Parameters.DeviceIoControl.OutputBufferLength;

		// setup callback
		io_stack_location->CompletionRoutine = callback;
	}

	// READ CALLBACK DATA FROM ALLOCATED POOl TO STACK, THEN FREES POOL
	template <class T>
	__forceinline callback_data<T> fetch_callback_data(void* context)
	{
		callback_data<T> result{};

		result.request = reinterpret_cast<REQUEST_STRUCT*>(context);
		result.buffer_length = result.request->output_buffer_length;
		result.buffer = reinterpret_cast<T*>(result.request->system_buffer);
		result.old_routine = result.request->old_routine;
		result.old_context = result.request->old_context;
		nt_fn::ExFreePoolWithTag(context, 0);

		return result;
	}
}
```

`owned_alignment/nt.hpp`:

```hpp
#pragma once

#include <ntdef.h>
#include <ntifs.h>
#include <ntddk.h>
#include <ntdddisk.h>
#include <intrin.h>
#include <cstdint>

/* MACROS / DEFINITIONS */
using UINT = unsigned int;
//using ULONG = unsigned int;
using DWORD = unsigned int;
using WORD = __int16;
using BYTE = __int8;
using BOOL = bool;

#define PFN_TO_PAGE(pfn) (pfn << 12)
#define PAGE_TO_PFN(page) (page >> 12)
#define IMAGE_SIZEOF_SHORT_NAME              8




```

`owned_alignment/nt_image.hpp`:

```hpp
#pragma once
#include <cstdint>

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	union
	{
		LIST_ENTRY HashLinks;
		struct
		{
			PVOID SectionPointer;
			ULONG CheckSum;
		} data;
	};
	union
	{
		ULONG TimeDateStamp;
		PVOID LoadedImports;
	};
	struct _ACTIVATION_CONTEXT * EntryPointActivationContext;
	PVOID PatchInformation;
	LIST_ENTRY ForwarderLinks;
	LIST_ENTRY ServiceTagLinks;
	LIST_ENTRY StaticLinks;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

// PARTIAL
typedef struct _IMAGE_SECTION_HEADER {
	uint8_t Name[IMAGE_SIZEOF_SHORT_NAME];
	union {
		uint32_t   PhysicalAddress;
		uint32_t   VirtualSize;
	} Misc;
	uint32_t VirtualAddress;
	uint32_t SizeOfRawData;
	uint32_t PointerToRawData;
	uint32_t PointerToRelocations;
	uint32_t PointerToLinenumbers;
	uint16_t NumberOfRelocations;
	uint16_t NumberOfLinenumbers;
	uint32_t Characteristics;
	/* STRUCTS */
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

struct IMAGE_DOS_HEADER { // DOS .EXE header
	uint16_t e_magic; // Magic number
	uint16_t e_cblp; // Bytes on last page of file
	uint16_t e_cp; // Pages in file
	uint16_t e_crlc; // Relocations
	uint16_t e_cparhdr; // Size of header in paragraphs
	uint16_t e_minalloc; // Minimum extra paragraphs needed
	uint16_t e_maxalloc; // Maximum extra paragraphs needed
	uint16_t e_ss; // Initial (relative) SS value
	uint16_t e_sp; // Initial SP value
	uint16_t e_csum; // Checksum
	uint16_t e_ip; // Initial IP value
	uint16_t e_cs; // Initial (relative) CS value
	uint16_t e_lfarlc; // File address of relocation table
	uint16_t e_ovno; // Overlay number
	uint16_t e_res[4]; // Reserved words
	uint16_t e_oemid; // OEM identifier (for e_oeminfo)
	uint16_t e_oeminfo; // OEM information; e_oemid specific
	uint16_t e_res2[10]; // Reserved words
	long     e_lfanew; // File address of new exe header
};

struct IMAGE_FILE_HEADER {
	uint16_t      Machine;
	uint16_t      NumberOfSections;
	unsigned long TimeDateStamp;
	unsigned long PointerToSymbolTable;
	unsigned long NumberOfSymbols;
	uint16_t      SizeOfOptionalHeader;
	uint16_t      Characteristics;
};

struct IMAGE_EXPORT_DIRECTORY {
	unsigned long Characteristics;
	unsigned long TimeDateStamp;
	uint16_t      MajorVersion;
	uint16_t      MinorVersion;
	unsigned long Name;
	unsigned long Base;
	unsigned long NumberOfFunctions;
	unsigned long NumberOfNames;
	unsigned long AddressOfFunctions; // RVA from base of image
	unsigned long AddressOfNames; // RVA from base of image
	unsigned long AddressOfNameOrdinals; // RVA from base of image
};

struct IMAGE_DATA_DIRECTORY {
	unsigned long VirtualAddress;
	unsigned long Size;
};

struct IMAGE_OPTIONAL_HEADER64 {
	uint16_t             Magic;
	uint8_t              MajorLinkerVersion;
	uint8_t              MinorLinkerVersion;
	unsigned long        SizeOfCode;
	unsigned long        SizeOfInitializedData;
	unsigned long        SizeOfUninitializedData;
	unsigned long        AddressOfEntryPoint;
	unsigned long        BaseOfCode;
	uint64_t             ImageBase;
	unsigned long        SectionAlignment;
	unsigned long        FileAlignment;
	uint16_t             MajorOperatingSystemVersion;
	uint16_t             MinorOperatingSystemVersion;
	uint16_t             MajorImageVersion;
	uint16_t             MinorImageVersion;
	uint16_t             MajorSubsystemVersion;
	uint16_t             MinorSubsystemVersion;
	unsigned long        Win32VersionValue;
	unsigned long        SizeOfImage;
	unsigned long        SizeOfHeaders;
	unsigned long        CheckSum;
	uint16_t             Subsystem;
	uint16_t             DllCharacteristics;
	uint64_t             SizeOfStackReserve;
	uint64_t             SizeOfStackCommit;
	uint64_t             SizeOfHeapReserve;
	uint64_t             SizeOfHeapCommit;
	unsigned long        LoaderFlags;
	unsigned long        NumberOfRvaAndSizes;
	IMAGE_DATA_DIRECTORY DataDirectory[16];
};

struct IMAGE_NT_HEADERS {
	unsigned long     Signature;
	IMAGE_FILE_HEADER FileHeader;
	IMAGE_OPTIONAL_HEADER64 OptionalHeader;
};

```

`owned_alignment/nt_ioctl.hpp`:

```hpp
#pragma once

// DEFINITIONS
#define  FILE_DEVICE_SCSI 0x0000001b
#define  IOCTL_SCSI_MINIPORT_IDENTIFY  ((FILE_DEVICE_SCSI << 16) + 0x0501)
#define  IOCTL_SCSI_MINIPORT 0x0004D008  //  see NTDDSCSI.H for definition

#define DFP_READ_VERSION 0x00074080


// STRUCTURES
typedef struct _IDINFO
{
	USHORT	wGenConfig;
	USHORT	wNumCyls;
	USHORT	wReserved;
	USHORT	wNumHeads;
	USHORT	wBytesPerTrack;
	USHORT	wBytesPerSector;
	USHORT	wNumSectorsPerTrack;
	USHORT	wVendorUnique[3];
	CHAR	sSerialNumber[20];
	USHORT	wBufferType;
	USHORT	wBufferSize;
	USHORT	wECCSize;
	CHAR	sFirmwareRev[8];
	CHAR	sModelNumber[40];
	USHORT	wMoreVendorUnique;
	USHORT	wDoubleWordIO;
	struct {
		USHORT	Reserved : 8;
		USHORT	DMA : 1;
		USHORT	LBA : 1;
		USHORT	DisIORDY : 1;
		USHORT	IORDY : 1;
		USHORT	SoftReset : 1;
		USHORT	Overlap : 1;
		USHORT	Queue : 1;
		USHORT	InlDMA : 1;
	} wCapabilities;
	USHORT	wReserved1;
	USHORT	wPIOTiming;
	USHORT	wDMATiming;
	struct {
		USHORT	CHSNumber : 1;
		USHORT	CycleNumber : 1;
		USHORT	UnltraDMA : 1;
		USHORT	Reserved : 13;
	} wFieldValidity;
	USHORT	wNumCurCyls;
	USHORT	wNumCurHeads;
	USHORT	wNumCurSectorsPerTrack;
	USHORT	wCurSectorsLow;
	USHORT	wCurSectorsHigh;
	struct {
		USHORT	CurNumber : 8;
		USHORT	Multi : 1;
		USHORT	Reserved : 7;
	} wMultSectorStuff;
	ULONG	dwTotalSectors;
	USHORT	wSingleWordDMA;
	struct {
		USHORT	Mode0 : 1;
		USHORT	Mode1 : 1;
		USHORT	Mode2 : 1;
		USHORT	Reserved1 : 5;
		USHORT	Mode0Sel : 1;
		USHORT	Mode1Sel : 1;
		USHORT	Mode2Sel : 1;
		USHORT	Reserved2 : 5;
	} wMultiWordDMA;
	struct {
		USHORT	AdvPOIModes : 8;
		USHORT	Reserved : 8;
	} wPIOCapacity;
	USHORT	wMinMultiWordDMACycle;
	USHORT	wRecMultiWordDMACycle;
	USHORT	wMinPIONoFlowCycle;
	USHORT	wMinPOIFlowCycle;
	USHORT	wReserved69[11];
	struct {
		USHORT	Reserved1 : 1;
		USHORT	ATA1 : 1;
		USHORT	ATA2 : 1;
		USHORT	ATA3 : 1;
		USHORT	ATA4 : 1;
		USHORT	ATA5 : 1;
		USHORT	ATA6 : 1;
		USHORT	ATA7 : 1;
		USHORT	ATA8 : 1;
		USHORT	ATA9 : 1;
		USHORT	ATA10 : 1;
		USHORT	ATA11 : 1;
		USHORT	ATA12 : 1;
		USHORT	ATA13 : 1;
		USHORT	ATA14 : 1;
		USHORT	Reserved2 : 1;
	} wMajorVersion;
	USHORT	wMinorVersion;
	USHORT	wReserved82[6];
	struct {
		USHORT	Mode0 : 1;
		USHORT	Mode1 : 1;
		USHORT	Mode2 : 1;
		USHORT	Mode3 : 1;
		USHORT	Mode4 : 1;
		USHORT	Mode5 : 1;
		USHORT	Mode6 : 1;
		USHORT	Mode7 : 1;
		USHORT	Mode0Sel : 1;
		USHORT	Mode1Sel : 1;
		USHORT	Mode2Sel : 1;
		USHORT	Mode3Sel : 1;
		USHORT	Mode4Sel : 1;
		USHORT	Mode5Sel : 1;
		USHORT	Mode6Sel : 1;
		USHORT	Mode7Sel : 1;
	} wUltraDMA;
	USHORT	wReserved89[167];
} IDINFO, *PIDINFO;

typedef struct _SRB_IO_CONTROL
{
	ULONG HeaderLength;
	UCHAR Signature[8];
	ULONG Timeout;
	ULONG ControlCode;
	ULONG ReturnCode;
	ULONG Length;
} SRB_IO_CONTROL, *PSRB_IO_CONTROL;



```

`owned_alignment/nt_pagetable.hpp`:

```hpp
#pragma once
#include <cstdint>

// DEFINITIONS
#define VIRTUAL_ADDRESS_BITS 48
#define VIRTUAL_ADDRESS_MASK ((((ULONG_PTR)1) << VIRTUAL_ADDRESS_BITS) - 1)

#define PXE_PER_PAGE 512

#define PXI_MASK (PXE_PER_PAGE - 1)

#define MiGetPxeOffset(va) \
    ((ULONG)(((ULONG_PTR)(va) >> PXI_SHIFT) & PXI_MASK))

#define MiGetPxeAddress(va)   \
    ((PMMPTE)PXE_BASE + MiGetPxeOffset(va))

#define MiGetPpeAddress(va)   \
    ((PMMPTE)(((((ULONG_PTR)(va) & VIRTUAL_ADDRESS_MASK) >> PPI_SHIFT) << PTE_SHIFT) + PPE_BASE))

#define MiGetPdeAddress(va) \
    ((PMMPTE)(((((ULONG_PTR)(va) & VIRTUAL_ADDRESS_MASK) >> PDI_SHIFT) << PTE_SHIFT) + PDE_BASE))

#define MiGetPteAddress(va) \
    ((PMMPTE)(((((ULONG_PTR)(va) & VIRTUAL_ADDRESS_MASK) >> PTI_SHIFT) << PTE_SHIFT) + PTE_BASE))

#define VA_SHIFT (63 - 47)              // address sign extend shift count

#define MiGetVirtualAddressMappedByPte(PTE) \
    ((PVOID)((LONG_PTR)(((LONG_PTR)(PTE) - PTE_BASE) << (PAGE_SHIFT + VA_SHIFT - PTE_SHIFT)) >> VA_SHIFT))

#define MI_IS_PHYSICAL_ADDRESS(Va) \
    ((MiGetPxeAddress(Va)->u.Hard.Valid == 1) && \
     (MiGetPpeAddress(Va)->u.Hard.Valid == 1) && \
     ((MiGetPdeAddress(Va)->u.Long & 0x81) == 0x81) || (MiGetPteAddress(Va)->u.Hard.Valid == 1))

#ifndef PTE_SHIFT
#define PTE_SHIFT 3
#endif
#ifndef PTI_SHIFT
#define PTI_SHIFT 12
#endif
#ifndef PDI_SHIFT
#define PDI_SHIFT 21
#endif
#ifndef PPI_SHIFT
#define PPI_SHIFT 30
#endif
#ifndef PXI_SHIFT
#define PXI_SHIFT 39
#endif

#ifndef PXE_BASE
#define PXE_BASE    0xFFFFF6FB7DBED000UI64
#endif
#ifndef PXE_SELFMAP
#define PXE_SELFMAP 0xFFFFF6FB7DBEDF68UI64
#endif
#ifndef PPE_BASE
#define PPE_BASE    0xFFFFF6FB7DA00000UI64
#endif
#ifndef PDE_BASE
#define PDE_BASE    0xFFFFF6FB40000000UI64
#endif
#ifndef PTE_BASE
#define PTE_BASE    0xFFFFF68000000000UI64
#endif



// STRUCT
typedef struct _MMPTE_SOFTWARE
{
	ULONG Valid : 1;
	ULONG PageFileLow : 4;
	ULONG Protection : 5;
	ULONG Prototype : 1;
	ULONG Transition : 1;
	ULONG Unused : 20;
	ULONG PageFileHigh : 32;
} MMPTE_SOFTWARE, *PMMPTE_SOFTWARE;
typedef struct _HARDWARE_PTE                                                    // 16 / 16 elements; 0x0008 / 0x0008 Bytes
{
	UINT64                      Valid : 1; // ------ / 0x0000; Bit:   0
	UINT64                      Write : 1; // ------ / 0x0000; Bit:   1
	UINT64                      Owner : 1; // ------ / 0x0000; Bit:   2
	UINT64                      WriteThrough : 1; // ------ / 0x0000; Bit:   3
	UINT64                      CacheDisable : 1; // ------ / 0x0000; Bit:   4
	UINT64                      Accessed : 1; // ------ / 0x0000; Bit:   5
	UINT64                      Dirty : 1; // ------ / 0x0000; Bit:   6
	UINT64                      LargePage : 1; // ------ / 0x0000; Bit:   7
	UINT64                      Global : 1; // ------ / 0x0000; Bit:   8
	UINT64                      CopyOnWrite : 1; // ------ / 0x0000; Bit:   9
	UINT64                      Prototype : 1; // ------ / 0x0000; Bit:  10
	UINT64                      reserved0 : 1; // ------ / 0x0000; Bit:  11
	UINT64                      PageFrameNumber : 36; // ------ / 0x0000; Bits: 12 - 47
	UINT64                      reserved1 : 4; // ------ / 0x0000; Bits: 48 - 51
	UINT64                      SoftwareWsIndex : 11; // ------ / 0x0000; Bits: 52 - 62
	UINT64                      NoExecute : 1; // ------ / 0x0000; Bit:  63
} HARDWARE_PTE, *PHARDWARE_PTE;
typedef enum _MI_SYSTEM_VA_TYPE                                                 // 17 / 16 elements; 0x0004 / 0x0004 Bytes
{
	MiVaUnused = 0,
	MiVaSessionSpace = 1,
	MiVaProcessSpace = 2,
	MiVaBootLoaded = 3,
	MiVaPfnDatabase = 4,
	MiVaNonPagedPool = 5,
	MiVaPagedPool = 6,
	MiVaSpecialPoolPaged = 7,
	MiVaSystemCache = 8,
	MiVaSystemPtes = 9,
	MiVaHal = 10,
	MiVaSessionGlobalSpace = 11,
	MiVaDriverImages = 12,
	MiVaSpecialPoolNonPaged = 13,
#if defined(_M_X64)
	MiVaMaximumType = 14,
	MiVaSystemPtesLarge = 15
#else                                                                           // #if defined(_M_X64)
	MiVaPagedProtoPool = 14,
	MiVaMaximumType = 15,
	MiVaSystemPtesLarge = 16
#endif                                                                          // #if defined(_M_X64)
} MI_SYSTEM_VA_TYPE, *PMI_SYSTEM_VA_TYPE;
typedef struct _MMPTE
{
	union
	{
		UINT64                  Long;
		UINT64                  VolatileLong;
		HARDWARE_PTE			Hard;
		MMPTE_SOFTWARE			Soft;
	}u;
} MMPTE, *PMMPTE;
typedef struct _RTL_BITMAP_EX
{
	UINT64                      SizeOfBitMap;
	PUINT64                     Buffer;
} RTL_BITMAP_EX, *PRTL_BITMAP_EX;
typedef struct _MI_SYSTEM_PTE_TYPE
{
	RTL_BITMAP_EX Bitmap;
	PMMPTE                      BasePte;
	ULONG32                     Flags;
	MI_SYSTEM_VA_TYPE           VaType;
	PULONG32                    FailureCount;
	ULONG32                     PteFailures;
	UINT8                       _PADDING0_[4];
	union
	{
		UINT_PTR                SpinLock;
		PULONG_PTR           GlobalPushLock;
	};
	void*						Vm;
	UINT_PTR                    TotalSystemPtes;
	UINT_PTR                    Hint;
	void*						CachedPtes;
	UINT_PTR                    TotalFreeSystemPtes;
} MI_SYSTEM_PTE_TYPE, *PMI_SYSTEM_PTE_TYPE;

#pragma pack(push, 1)
union PML4_BASE {
	uint64_t value;
#pragma warning(disable : 4201)
	struct {
		uint64_t ignored_1 : 3;
		uint64_t write_through : 1;
		uint64_t cache_disable : 1;
		uint64_t ignored_2 : 7;
		uint64_t pml4_p : 40;
		uint64_t reserved : 12;
	};
};

typedef union VIRT_ADDR_ {
	uint64_t  value;
	void*    pointer;
#pragma warning(disable : 4201)
	struct {
		uint64_t offset : 12;
		uint64_t pt_index : 9;
		uint64_t pd_index : 9;
		uint64_t pdpt_index : 9;
		uint64_t pml4_index : 9;
		uint64_t reserved : 16;
	};
} VIRT_ADDR;

typedef uint64_t PHYS_ADDR;

typedef union PML4E_ {
	uint64_t value;
#pragma warning(disable : 4201)
	struct {
		uint64_t present : 1;
		uint64_t rw : 1;
		uint64_t user : 1;
		uint64_t write_through : 1;
		uint64_t cache_disable : 1;
		uint64_t accessed : 1;
		uint64_t ignored_1 : 1;
		uint64_t reserved_1 : 1;
		uint64_t ignored_2 : 4;
		uint64_t pdpt_p : 40;
		uint64_t ignored_3 : 11;
		uint64_t xd : 1;
	};
} PML4E;

typedef union PDPTE_ {
	uint64_t value;
#pragma warning(disable : 4201)
	struct {
		uint64_t present : 1;
		uint64_t rw : 1;
		uint64_t user : 1;
		uint64_t write_through : 1;
		uint64_t cache_disable : 1;
		uint64_t accessed : 1;
		uint64_t dirty : 1;
		uint64_t page_size : 1;
		uint64_t ignored_2 : 4;
		uint64_t pd_p : 40;
		uint64_t ignored_3 : 11;
		uint64_t xd : 1;
	};
} PDPTE;

typedef union PDE_ {
	uint64_t value;
#pragma warning(disable : 4201)
	struct {
		uint64_t present : 1;
		uint64_t rw : 1;
		uint64_t user : 1;
		uint64_t write_through : 1;
		uint64_t cache_disable : 1;
		uint64_t accessed : 1;
		uint64_t dirty : 1;
		uint64_t page_size : 1;
		uint64_t ignored_2 : 4;
		uint64_t pt_p : 40;
		uint64_t ignored_3 : 11;
		uint64_t xd : 1;
	};
} PDE;

typedef union PTE_ {
	uint64_t  value;
	VIRT_ADDR vaddr;
#pragma warning(disable : 4201)
	struct {
		uint64_t present : 1;
		uint64_t rw : 1;
		uint64_t user : 1;
		uint64_t write_through : 1;
		uint64_t cache_disable : 1;
		uint64_t accessed : 1;
		uint64_t dirty : 1;
		uint64_t pat : 1;
		uint64_t global : 1;
		uint64_t ignored_1 : 3;
		uint64_t page_frame : 40;
		uint64_t ignored_3 : 11;
		uint64_t xd : 1;
	};
} PTE;
#pragma pack(pop)
```

`owned_alignment/owned_alignment.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="disk_hooker.cpp" />
    <ClCompile Include="driver.cpp" />
    <ClCompile Include="entry.cpp" />
    <ClCompile Include="physical_memory.cpp" />
    <ClCompile Include="portable_executable.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="disk_hooker.hpp" />
    <ClInclude Include="driver.hpp" />
    <ClInclude Include="ioctl_helper.hpp" />
    <ClInclude Include="nt.hpp" />
    <ClInclude Include="nt_image.hpp" />
    <ClInclude Include="nt_ioctl.hpp" />
    <ClInclude Include="nt_pagetable.hpp" />
    <ClInclude Include="physical_memory.hpp" />
    <ClInclude Include="portable_executable.hpp" />
    <ClInclude Include="shellcode_generator.hpp" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{68BC6052-80BF-4525-9877-2FA4D3111E39}</ProjectGuid>
    <TemplateGuid>{497e31cb-056b-4f31-abb8-447fd55ee5a5}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>owned_alignment</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
    <TimeStampServer />
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WppEnabled>false</WppEnabled>
      <WppRecorderEnabled>false</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <ControlFlowGuard>false</ControlFlowGuard>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <Optimization>MaxSpeed</Optimization>
      <DisableSpecificWarnings>5040;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <OmitFramePointers>true</OmitFramePointers>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <DebugInformationFormat>None</DebugInformationFormat>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <FloatingPointModel>Fast</FloatingPointModel>
      <FloatingPointExceptions>false</FloatingPointExceptions>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <LinkTimeCodeGeneration>UseFastLinkTimeCodeGeneration</LinkTimeCodeGeneration>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`owned_alignment/owned_alignment.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
    <Filter Include="Header Files\Hooks">
      <UniqueIdentifier>{eb87c49a-a7e5-4c6d-b0cf-667180d8b0ee}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Kernel helpers">
      <UniqueIdentifier>{cd7239da-23f9-4648-afed-24cbbd8d6b77}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\Native helper">
      <UniqueIdentifier>{cc08a117-0b55-4c62-93e5-dc34fb2a0d09}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Kernel helpers">
      <UniqueIdentifier>{df09ac33-b128-430f-b63c-bd452ff88087}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Hooks">
      <UniqueIdentifier>{9c6882f6-8ef8-4f02-b99c-f38098ed130e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\OS helpers">
      <UniqueIdentifier>{726309a1-f176-4e0b-9b34-cc7e14c02b72}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\OS helpers">
      <UniqueIdentifier>{ddebc846-4800-47e8-9088-cae5fff77fa6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\Native helpers">
      <UniqueIdentifier>{972c182e-51c5-4830-b4f6-6bd1d075e131}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="physical_memory.hpp">
      <Filter>Header Files\Kernel helpers</Filter>
    </ClInclude>
    <ClInclude Include="nt.hpp">
      <Filter>Header Files\Native helper</Filter>
    </ClInclude>
    <ClInclude Include="disk_hooker.hpp">
      <Filter>Header Files\Hooks</Filter>
    </ClInclude>
    <ClInclude Include="ioctl_helper.hpp">
      <Filter>Header Files\Kernel helpers</Filter>
    </ClInclude>
    <ClInclude Include="shellcode_generator.hpp">
      <Filter>Header Files\Native helper</Filter>
    </ClInclude>
    <ClInclude Include="driver.hpp">
      <Filter>Header Files\OS helpers</Filter>
    </ClInclude>
    <ClInclude Include="nt_pagetable.hpp">
      <Filter>Header Files\Native helper</Filter>
    </ClInclude>
    <ClInclude Include="nt_ioctl.hpp">
      <Filter>Header Files\Native helper</Filter>
    </ClInclude>
    <ClInclude Include="portable_executable.hpp">
      <Filter>Header Files\Native helper</Filter>
    </ClInclude>
    <ClInclude Include="nt_image.hpp">
      <Filter>Header Files\Native helper</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="physical_memory.cpp">
      <Filter>Source Files\Kernel helpers</Filter>
    </ClCompile>
    <ClCompile Include="disk_hooker.cpp">
      <Filter>Source Files\Hooks</Filter>
    </ClCompile>
    <ClCompile Include="driver.cpp">
      <Filter>Source Files\OS helpers</Filter>
    </ClCompile>
    <ClCompile Include="entry.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="portable_executable.cpp">
      <Filter>Source Files\Native helpers</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`owned_alignment/physical_memory.cpp`:

```cpp
#include "physical_memory.hpp"

hardware_pt_info physical_memory::query_hardware_table_information(const void* virtual_address)
{
	hardware_pt_info result{};

	// THIS IS ONLY FOR SUB RS2 WINDOWS VERSIONS, THANKS TO EXPLOIT MITIGATION 

	auto temp_pde = MiGetPdeAddress(virtual_address);

	if (!MI_IS_PHYSICAL_ADDRESS(temp_pde))
		return result;

	result.pde = temp_pde;

	if (result.pde->u.Hard.LargePage)
	{
		result.is_large_page = true;
		return result;
	}

	auto temp_pte = MiGetPteAddress(virtual_address);

	if (!MI_IS_PHYSICAL_ADDRESS(temp_pte))
		return result;

	result.pte = temp_pte;

	return result;
}

bool physical_memory::protect_memory(const void* virtual_address, bool write, bool execute, bool fix_invalid)
{
	auto page_info = physical_memory::query_hardware_table_information(virtual_address);
	bool refetch = false;

	DbgPrint("Fetched page info\n");

	if (page_info.pde == nullptr)
	{
		DbgPrint("Invalid PDE!\n");
		return false;
	}

	// RECONSTRUCT TABLE ENTRY?
	if (fix_invalid)
	{
		DbgPrint("Fixing invalid\n");
		if (page_info.pde->u.Hard.Valid == 0)
		{
			DbgPrint("Invalid PDE. Fixing...\n");
			page_info.pde->u.Hard.Dirty = 1;
			page_info.pde->u.Hard.Accessed = 1;
			page_info.pde->u.Hard.Owner = 0;
			page_info.pde->u.Hard.Write = 1;
			page_info.pde->u.Hard.NoExecute = 0;
			page_info.pde->u.Hard.Valid = 1;
			refetch = true;
		}
	}

	// REFETCH AFTER PDE RECONSTRUCTION TO GET PROPER PTE
	if (refetch)
	{
		page_info = physical_memory::query_hardware_table_information(virtual_address);
	}

	// NO PTE?
	if (page_info.pte == nullptr || !physical_memory::is_valid_address(reinterpret_cast<uint8_t*>(page_info.pte)))
	{
		DbgPrint("Lookup of PTE failed!\n");
		return false;
	}
	// VALID PTE
	else if (page_info.pte->u.Hard.Valid == 1)
	{
		DbgPrint("Found valid page!\n");
		page_info.pte->u.Hard.NoExecute = execute ? 0ull : 1ull;
		page_info.pte->u.Hard.Write = write ? 1ull : 0ull;
		return true;
	}
	// FIX INVALID PAGE AND SET PROTECTION
	else if (fix_invalid && page_info.pte->u.Hard.Valid == 0)
	{
		DbgPrint("Patching PTE.\n");

		*page_info.pte = MMPTE{};
	
		page_info.pte->u.Hard.Dirty = 1;
		page_info.pte->u.Hard.Accessed = 1;
		page_info.pte->u.Hard.Owner = 0;
		page_info.pte->u.Hard.Write = write ? 1ull : 0ull;
		page_info.pte->u.Hard.NoExecute = execute ? 0ull : 1ull;
		page_info.pte->u.Hard.Valid = 1;
		return true;
	}

	// SHOULD NEVER HAPPEN
	DbgPrint("UNEXPECTED Lookup of PTE failed!\n");
	return false;
}

bool physical_memory::is_valid_address(const void* virtual_address)
{
	if (virtual_address == nullptr)
		return false;

	return MmIsAddressValid(const_cast<void*>(virtual_address));
}


```

`owned_alignment/physical_memory.hpp`:

```hpp
#pragma once
#include "nt.hpp"
#include <cstdint>
#include "nt_pagetable.hpp"

struct page_table_info {
    PML4E* pml4_entry;
    PDPTE* pdpt_entry;
    PDE*   pd_entry;
    PTE*   pt_entry;
};

struct hardware_pt_info
{
	MMPTE* pde;
	MMPTE* pte;
	bool is_large_page;
};

namespace physical_memory {

	hardware_pt_info query_hardware_table_information(const void* virtual_address);

	bool protect_memory(const void* virtual_address, bool write, bool execute, bool fix_invalid);

	bool is_valid_address(const void* virtual_address);

    template<class Fn>
    void iterate_region(const uint8_t* start, const uint64_t size, Fn fn)
    {
        // ITERATE PHYSICAL MEMORY REGION (IN ALIGNED CHUNKS)
        const auto address_end  = start + size;
        auto       address_iter = start;

        while(address_iter < address_end) {
            // CALCULATE DEFAULT PAGE SIZE
            auto page_size =
                reinterpret_cast<uint8_t*>(
                    (reinterpret_cast<uint64_t>(address_iter) + 0x1000) & (~0xFFF)) -
                address_iter;

            // IF DEFAULT PAGE SIZE EXCEEDS END, TRUNCATE SIZE
            if(address_iter + page_size > address_end)
                page_size = address_end - address_iter;

            // CALL RESPESCTIVE HANDLER FUNCTION
            fn(address_iter, page_size);

            // ADD SIZE TO POINTER
            address_iter += page_size;
        }
    }
} // namespace physical_memory
```

`owned_alignment/portable_executable.cpp`:

```cpp
#include "portable_executable.hpp"

portable_executable::portable_executable(uint8_t* address) : buffer(address)
{
	this->dos_header = reinterpret_cast<IMAGE_DOS_HEADER*>(address);
	this->nt_headers = reinterpret_cast<IMAGE_NT_HEADERS*>(address + this->dos_header->e_lfanew);
	this->file_header = this->nt_headers->FileHeader;
	this->optional_header = this->nt_headers->OptionalHeader;
}

IMAGE_DOS_HEADER* portable_executable::get_dos_header()
{
	return this->dos_header;
}

IMAGE_NT_HEADERS* portable_executable::get_nt_headers()
{
	return this->nt_headers;
}

IMAGE_FILE_HEADER portable_executable::get_file_header()
{
	return this->file_header;
}

IMAGE_OPTIONAL_HEADER64 portable_executable::get_optional_header()
{
	return this->optional_header;
}

uintptr_t portable_executable::get_image_base()
{
	return this->optional_header.ImageBase;
}

```

`owned_alignment/portable_executable.hpp`:

```hpp
#pragma once
#include <cstdint>
#include "nt.hpp"
#include "nt_image.hpp"

struct section_data
{
	uint8_t* start;
	uint64_t size;
};

class portable_executable
{
public:
	portable_executable(uint8_t* address);

	// INFORMATION
	IMAGE_DOS_HEADER* get_dos_header();
	IMAGE_NT_HEADERS* get_nt_headers();
	IMAGE_FILE_HEADER get_file_header();
	IMAGE_OPTIONAL_HEADER64 get_optional_header();
	uintptr_t get_image_base();

	template <SIZE_T N>
	__forceinline section_data get_section(const char(&section_name)[N])
	{
		auto section_pointer = reinterpret_cast<IMAGE_SECTION_HEADER*>(this->nt_headers + 1);

		for (auto index = 0; index < this->file_header.NumberOfSections; index++)
		{
			auto section = &section_pointer[index];

			if (unr::memeq<N>(section->Name, section_name))
			{
				return section_data{
					buffer + section->VirtualAddress,
					section->Misc.VirtualSize
				};
			}
		}

		return section_data{};
	}

private:
	IMAGE_DOS_HEADER* dos_header;
	IMAGE_NT_HEADERS* nt_headers;
	IMAGE_OPTIONAL_HEADER64 optional_header;
	IMAGE_FILE_HEADER file_header;
	uint8_t* buffer;
};
```

`owned_alignment/shellcode_generator.hpp`:

```hpp
#pragma once
#include <cstdint>

namespace shellcode_generator
{
	__forceinline void call_proxy(uint8_t* buffer, void* fn)
	{
		uint8_t trampoline_data[]{
			0x58,														// pop rax
			0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // movabs rax,0x0000000000000000
			0xFF, 0xE0 };												// jmp rax


		*reinterpret_cast<uint64_t*>(trampoline_data + 3) = reinterpret_cast<uint64_t>(fn);

		// MEMCPY
		for (size_t i = 0; i < sizeof(trampoline_data); i++)
			buffer[i] = trampoline_data[i];
	};
}
```