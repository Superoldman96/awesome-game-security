Project Path: arc_gmh5225_eft-external_01z2g7fr

Source Tree:

```txt
arc_gmh5225_eft-external_01z2g7fr
├── EFT Kernel
│   ├── LICENSE
│   ├── README.md
│   ├── km-um-communication.sln
│   └── socket-km
│       ├── clean.hpp
│       ├── imports.h
│       ├── ksocket
│       │   ├── berkeley.c
│       │   ├── berkeley.h
│       │   ├── ksocket.c
│       │   └── ksocket.h
│       ├── log.h
│       ├── main.cpp
│       ├── packet_handler.cpp
│       ├── server.cpp
│       ├── server_shared.h
│       ├── socket-km.inf
│       ├── socket-km.vcxproj
│       ├── socket-km.vcxproj.filters
│       ├── sockets.h
│       ├── stdint.h
│       └── struct.h
├── EFT Usermode
│   ├── MemoryOperationSample
│   │   ├── MemoryOperationSample.vcxproj
│   │   ├── MemoryOperationSample.vcxproj.filters
│   │   ├── MemoryOperationSample.vcxproj.user
│   │   ├── Overlay.cpp
│   │   ├── Overlay.h
│   │   ├── PMemHelper.cpp
│   │   ├── PMemHelper.h
│   │   ├── eftstructs.cpp
│   │   ├── eftstructs.h
│   │   ├── main.cpp
│   │   ├── math.cpp
│   │   ├── math.hpp
│   │   ├── server_shared.h
│   │   ├── visuals.cpp
│   │   ├── visuals.h
│   │   ├── x64
│   │   │   └── Release
│   │   │       └── MemoryOperationSample.vcxproj.FileListAbsolute.txt
│   │   └── xorstr.hpp
│   └── MemoryOperationSample.sln
└── README.md

```

`EFT Kernel/LICENSE`:

```
MIT License

Copyright (c) 2019 Alexander Bruun

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`EFT Kernel/km-um-communication.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29209.152
MinimumVisualStudioVersion = 10.0.40219.1
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "socket", "socket", "{EF2228E9-38EE-4A65-A210-6AD68B3F27C9}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "socket-km", "socket-km\socket-km.vcxproj", "{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|ARM.ActiveCfg = Debug|ARM
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|ARM.Build.0 = Debug|ARM
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|ARM.Deploy.0 = Debug|ARM
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|ARM64.Build.0 = Debug|ARM64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|x64.ActiveCfg = Debug|x64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|x64.Build.0 = Debug|x64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|x64.Deploy.0 = Debug|x64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|x86.ActiveCfg = Debug|Win32
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|x86.Build.0 = Debug|Win32
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Debug|x86.Deploy.0 = Debug|Win32
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|ARM.ActiveCfg = Release|ARM
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|ARM.Build.0 = Release|ARM
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|ARM.Deploy.0 = Release|ARM
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|ARM64.ActiveCfg = Release|ARM64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|ARM64.Build.0 = Release|ARM64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|ARM64.Deploy.0 = Release|ARM64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|x64.ActiveCfg = Release|x64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|x64.Build.0 = Release|x64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|x64.Deploy.0 = Release|x64
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|x86.ActiveCfg = Release|Win32
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|x86.Build.0 = Release|Win32
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{1BB91B25-67A5-4CB7-8379-DF7C886CE06A} = {EF2228E9-38EE-4A65-A210-6AD68B3F27C9}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {8AD1A633-9639-48D1-8251-3FC8CA1F7357}
	EndGlobalSection
EndGlobal

```

`EFT Kernel/socket-km/clean.hpp`:

```hpp
#pragma once
#include "struct.h"
#include "log.h"

#define BB_POOL_TAG 'Esk'
UCHAR PiDDBLockPtr_sig[] = "\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x4C\x8B\x8C";
UCHAR PiDDBCacheTablePtr_sig[] = "\x66\x03\xD2\x48\x8D\x0D";
//you can also put the sig within the function, but some of the sig ends up on the stack and in the .text section, and causes issues when zeroing the sig memory.

EXTERN_C PVOID ResolveRelativeAddress(
	_In_ PVOID Instruction,
	_In_ ULONG OffsetOffset,
	_In_ ULONG InstructionSize
)
{
	ULONG_PTR Instr = (ULONG_PTR)Instruction;
	LONG RipOffset = *(PLONG)(Instr + OffsetOffset);
	PVOID ResolvedAddr = (PVOID)(Instr + InstructionSize + RipOffset);

	return ResolvedAddr;
}

NTSTATUS BBSearchPattern(IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, IN const VOID* base, IN ULONG_PTR size, OUT PVOID* ppFound, int index = 0)
{
	ASSERT(ppFound != NULL && pattern != NULL && base != NULL);
	if (ppFound == NULL || pattern == NULL || base == NULL)
		return STATUS_ACCESS_DENIED; //STATUS_INVALID_PARAMETER;
	int cIndex = 0;
	for (ULONG_PTR i = 0; i < size - len; i++)
	{
		BOOLEAN found = TRUE;
		for (ULONG_PTR j = 0; j < len; j++)
		{
			if (pattern[j] != wildcard && pattern[j] != ((PCUCHAR)base)[i + j])
			{
				found = FALSE;
				break;
			}
		}

		if (found != FALSE && cIndex++ == index)
		{
			*ppFound = (PUCHAR)base + i;
			return STATUS_SUCCESS;
		}
	}

	return STATUS_NOT_FOUND;
}

PVOID g_KernelBase = NULL;
ULONG g_KernelSize = 0;

PVOID GetKernelBase(OUT PULONG pSize)
{
	NTSTATUS status = STATUS_SUCCESS;
	ULONG bytes = 0;
	PRTL_PROCESS_MODULES pMods = NULL;
	PVOID checkPtr = NULL;
	UNICODE_STRING routineName;

	// Already found
	if (g_KernelBase != NULL)
	{
		if (pSize)
			*pSize = g_KernelSize;
		return g_KernelBase;
	}

	RtlUnicodeStringInit(&routineName, L"NtOpenFile");

	checkPtr = MmGetSystemRoutineAddress(&routineName);
	if (checkPtr == NULL)
		return NULL;

	// Protect from UserMode AV
	status = ZwQuerySystemInformation(SystemModuleInformation, 0, bytes, &bytes);
	if (bytes == 0)
	{
		log("Invalid SystemModuleInformation size");
		return NULL;
	}

	pMods = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, bytes, BB_POOL_TAG);
	RtlZeroMemory(pMods, bytes);

	status = ZwQuerySystemInformation(SystemModuleInformation, pMods, bytes, &bytes);

	if (NT_SUCCESS(status))
	{
		PRTL_PROCESS_MODULE_INFORMATION pMod = pMods->Modules;

		for (ULONG i = 0; i < pMods->NumberOfModules; i++)
		{
			// System routine is inside module
			if (checkPtr >= pMod[i].ImageBase &&
				checkPtr < (PVOID)((PUCHAR)pMod[i].ImageBase + pMod[i].ImageSize))
			{
				g_KernelBase = pMod[i].ImageBase;
				g_KernelSize = pMod[i].ImageSize;
				if (pSize)
					*pSize = g_KernelSize;
				break;
			}
		}
	}

	if (pMods)
		ExFreePoolWithTag(pMods, BB_POOL_TAG);
	//log("g_KernelBase: %x", g_KernelBase);
	//log("g_KernelSize: %x", g_KernelSize);
	return g_KernelBase;
}

NTSTATUS BBScanSection(IN PCCHAR section, IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, OUT PVOID* ppFound, PVOID base = nullptr)
{
	//ASSERT(ppFound != NULL);
	if (ppFound == NULL)
		return STATUS_ACCESS_DENIED; //STATUS_INVALID_PARAMETER

	if (nullptr == base)
		base = GetKernelBase(&g_KernelSize);
	if (base == nullptr)
		return STATUS_ACCESS_DENIED; //STATUS_NOT_FOUND;

	PIMAGE_NT_HEADERS64 pHdr = RtlImageNtHeader(base);
	if (!pHdr)
		return STATUS_ACCESS_DENIED; // STATUS_INVALID_IMAGE_FORMAT;

	//PIMAGE_SECTION_HEADER pFirstSection = (PIMAGE_SECTION_HEADER)(pHdr + 1);
	PIMAGE_SECTION_HEADER pFirstSection = (PIMAGE_SECTION_HEADER)((uintptr_t)&pHdr->FileHeader + pHdr->FileHeader.SizeOfOptionalHeader + sizeof(IMAGE_FILE_HEADER));

	for (PIMAGE_SECTION_HEADER pSection = pFirstSection; pSection < pFirstSection + pHdr->FileHeader.NumberOfSections; pSection++)
	{
		//DbgPrint("section: %s\r\n", pSection->Name);
		ANSI_STRING s1, s2;
		RtlInitAnsiString(&s1, section);
		RtlInitAnsiString(&s2, (PCCHAR)pSection->Name);
		if (RtlCompareString(&s1, &s2, TRUE) == 0)
		{
			PVOID ptr = NULL;
			NTSTATUS status = BBSearchPattern(pattern, wildcard, len, (PUCHAR)base + pSection->VirtualAddress, pSection->Misc.VirtualSize, &ptr);
			if (NT_SUCCESS(status)) {
				*(PULONG64)ppFound = (ULONG_PTR)(ptr); //- (PUCHAR)base
				//DbgPrint("found\r\n");
				return status;
			}
			//we continue scanning because there can be multiple sections with the same name.
		}
	}

	return STATUS_ACCESS_DENIED; //STATUS_NOT_FOUND;
}
extern "C" bool LocatePiDDB(PERESOURCE * lock, PRTL_AVL_TABLE * table)
{
	PVOID PiDDBLockPtr = nullptr, PiDDBCacheTablePtr = nullptr;
	if (!NT_SUCCESS(BBScanSection("PAGE", PiDDBLockPtr_sig, 0, sizeof(PiDDBLockPtr_sig) - 1, reinterpret_cast<PVOID*>(&PiDDBLockPtr)))) {
		log("Unable to find PiDDBLockPtr sig.");
		return false;
	}

	if (!NT_SUCCESS(BBScanSection("PAGE", PiDDBCacheTablePtr_sig, 0, sizeof(PiDDBCacheTablePtr_sig) - 1, reinterpret_cast<PVOID*>(&PiDDBCacheTablePtr)))) {
		log("Unable to find PiDDBCacheTablePtr sig");
		return false;
	}

	PiDDBCacheTablePtr = PVOID((uintptr_t)PiDDBCacheTablePtr + 3);

	*lock = (PERESOURCE)(ResolveRelativeAddress(PiDDBLockPtr, 3, 7));
	*table = (PRTL_AVL_TABLE)(ResolveRelativeAddress(PiDDBCacheTablePtr, 3, 7));

	return true;
}





PMM_UNLOADED_DRIVER MmUnloadedDrivers;
PULONG				MmLastUnloadedDriver;

BOOLEAN bDataCompare(const BYTE* pData, const BYTE* bMask, const char* szMask)
{
	for (; *szMask; ++szMask, ++pData, ++bMask)
		if (*szMask == 'x' && *pData != *bMask)
			return 0;

	return (*szMask) == 0;
}

UINT64 FindPattern(UINT64 dwAddress, UINT64 dwLen, BYTE* bMask, char* szMask)
{
	for (UINT64 i = 0; i < dwLen; i++)
		if (bDataCompare((BYTE*)(dwAddress + i), bMask, szMask))
			return (UINT64)(dwAddress + i);

	return 0;
}
NTSTATUS FindMmDriverData(
	VOID
)
{
	/*
	 *	nt!MmLocateUnloadedDriver:
	 *	fffff801`51c70394 4c8b15a57e1500  mov     r10,qword ptr [nt!MmUnloadedDrivers (fffff801`51dc8240)]
	 *	fffff801`51c7039b 4c8bc9          mov     r9 ,rcx
	 */
	PVOID MmUnloadedDriversInstr = (PVOID)FindPattern((UINT64)g_KernelBase, g_KernelSize,
		(BYTE*)"\x4C\x8B\x15\x00\x00\x00\x00\x4C\x8B\xC9",
		"xxx????xxx"
	);

	/*
	 *	nt!MiRememberUnloadedDriver+0x59:
	 *	fffff801`5201a4c5 8b057ddddaff    mov     eax,dword ptr [nt!MmLastUnloadedDriver (fffff801`51dc8248)]
	 *	fffff801`5201a4cb 83f832          cmp     eax,32h
	*/
	PVOID MmLastUnloadedDriverInstr = (PVOID)FindPattern((UINT64)g_KernelBase, g_KernelSize,
		(BYTE*)"\x8B\x05\x00\x00\x00\x00\x83\xF8\x32",
		"xx????xxx"
	);

	if (MmUnloadedDriversInstr == NULL || MmLastUnloadedDriverInstr == NULL)
	{
		return STATUS_NOT_FOUND;
	}

	MmUnloadedDrivers = *(PMM_UNLOADED_DRIVER*)ResolveRelativeAddress(MmUnloadedDriversInstr, 3, 7);
	MmLastUnloadedDriver = (PULONG)ResolveRelativeAddress(MmLastUnloadedDriverInstr, 2, 6);
	/*log("MmUnloadedDrivers ModuleEnd: %x", MmUnloadedDrivers->ModuleEnd);
	log("MmUnloadedDrivers ModuleStart: %x", MmUnloadedDrivers->ModuleStart);
	log("MmUnloadedDrivers Name: %s", MmUnloadedDrivers->Name);
	log("MmUnloadedDrivers UnloadTime: %x", MmUnloadedDrivers->UnloadTime);*/

	//log("MmUnloadedDrivers Addr: %x", MmUnloadedDrivers);
	//log("MmLastUnloadedDriver Addr: %x", MmLastUnloadedDriver);
	return STATUS_SUCCESS;
}

BOOLEAN IsUnloadedDriverEntryEmpty(
	_In_ PMM_UNLOADED_DRIVER Entry
)
{
	if (Entry->Name.MaximumLength == 0 ||
		Entry->Name.Length == 0 ||
		Entry->Name.Buffer == NULL)
	{
		return TRUE;
	}

	return FALSE;
}

BOOLEAN IsMmUnloadedDriversFilled(
	VOID
)
{
	for (ULONG Index = 0; Index < MM_UNLOADED_DRIVERS_SIZE; ++Index)
	{
		PMM_UNLOADED_DRIVER Entry = &MmUnloadedDrivers[Index];
		if (IsUnloadedDriverEntryEmpty(Entry))
		{
			return FALSE;
		}
	}

	return TRUE;
}



ERESOURCE PsLoadedModuleResource;




namespace clear {

	void clearCache(UNICODE_STRING DriverName, ULONG timeDateStamp)
	{
		// first locate required variables
		PERESOURCE PiDDBLock; PRTL_AVL_TABLE PiDDBCacheTable;
		if (!LocatePiDDB(&PiDDBLock, &PiDDBCacheTable)) {
			log("ClearCache Failed");
			return;
		}

		//log("Found PiDDBLock and PiDDBCacheTable");
		//log("Found PiDDBLock %x", PiDDBLock);
		//log("Found PiDDBCacheTable %x", PiDDBCacheTable);

		// build a lookup entry

		PiDDBCacheEntry lookupEntry = { };
		lookupEntry.DriverName = DriverName;
		lookupEntry.TimeDateStamp = timeDateStamp;

		// acquire the ddb resource lock
		ExAcquireResourceExclusiveLite(PiDDBLock, TRUE);

		// search our entry in the table
		auto pFoundEntry = (PiDDBCacheEntry*)RtlLookupElementGenericTableAvl(PiDDBCacheTable, &lookupEntry);
		if (pFoundEntry == nullptr)
		{
			// release the ddb resource lock
			ExReleaseResourceLite(PiDDBLock);
			log("ClearCache Failed (Not found)");
			return;
		}

		// first, unlink from the list
		RemoveEntryList(&pFoundEntry->List);
		// then delete the element from the avl table
		RtlDeleteElementGenericTableAvl(PiDDBCacheTable, pFoundEntry);

		// release the ddb resource lock
		ExReleaseResourceLite(PiDDBLock);
		log("chache cleared");
	}




	NTSTATUS ClearUnloadedDriver(
		_In_ PUNICODE_STRING	DriverName,
		_In_ BOOLEAN			AccquireResource
	)
	{
		if (AccquireResource)
		{
			ExAcquireResourceExclusiveLite(&PsLoadedModuleResource, TRUE);
		}

		BOOLEAN Modified = FALSE;
		BOOLEAN Filled = IsMmUnloadedDriversFilled();

		for (ULONG Index = 0; Index < MM_UNLOADED_DRIVERS_SIZE; ++Index)
		{
			PMM_UNLOADED_DRIVER Entry = &MmUnloadedDrivers[Index];
			if (Modified)
			{
				//
				// Shift back all entries after modified one.
				//
				PMM_UNLOADED_DRIVER PrevEntry = &MmUnloadedDrivers[Index - 1];
				RtlCopyMemory(PrevEntry, Entry, sizeof(MM_UNLOADED_DRIVER));

				//
				// Zero last entry.
				//
				if (Index == MM_UNLOADED_DRIVERS_SIZE - 1)
				{
					RtlFillMemory(Entry, sizeof(MM_UNLOADED_DRIVER), 0);
				}
			}
			else if (RtlEqualUnicodeString(DriverName, &Entry->Name, TRUE))
			{
				//
				// Erase driver entry.
				//
				PVOID BufferPool = Entry->Name.Buffer;
				RtlFillMemory(Entry, sizeof(MM_UNLOADED_DRIVER), 0);
				ExFreePoolWithTag(BufferPool, 'TDmM');

				//
				// Because we are erasing last entry we want to set MmLastUnloadedDriver to 49
				// if list have been already filled.
				//
				*MmLastUnloadedDriver = (Filled ? MM_UNLOADED_DRIVERS_SIZE : *MmLastUnloadedDriver) - 1;
				Modified = TRUE;
			}
		}

		if (Modified)
		{
			ULONG64 PreviousTime = 0;

			//
			// Make UnloadTime look right.
			//
			for (LONG Index = MM_UNLOADED_DRIVERS_SIZE - 2; Index >= 0; --Index)
			{
				PMM_UNLOADED_DRIVER Entry = &MmUnloadedDrivers[Index];
				if (IsUnloadedDriverEntryEmpty(Entry))
				{
					continue;
				}

				if (PreviousTime != 0 && Entry->UnloadTime > PreviousTime)
				{
					//
					// Decrease by random value here maybe.
					//
					Entry->UnloadTime = PreviousTime - 100;
				}

				PreviousTime = Entry->UnloadTime;
			}

			//
			// Clear remaining entries.
			//
			ClearUnloadedDriver(DriverName, FALSE);
		}

		if (AccquireResource)
		{
			ExReleaseResourceLite(&PsLoadedModuleResource);
		}

		return Modified ? STATUS_SUCCESS : STATUS_NOT_FOUND;
	}
}
```

`EFT Kernel/socket-km/imports.h`:

```h
#pragma once
#include <ntddk.h>
#include <intrin.h>
#include <stdlib.h>
#include <Ntstrsafe.h>
#include <windef.h>

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation = 0x0,
	SystemProcessorInformation = 0x1,
	SystemPerformanceInformation = 0x2,
	SystemTimeOfDayInformation = 0x3,
	SystemPathInformation = 0x4,
	SystemProcessInformation = 0x5,
	SystemCallCountInformation = 0x6,
	SystemDeviceInformation = 0x7,
	SystemProcessorPerformanceInformation = 0x8,
	SystemFlagsInformation = 0x9,
	SystemCallTimeInformation = 0xa,
	SystemModuleInformation = 0xb,
	SystemLocksInformation = 0xc,
	SystemStackTraceInformation = 0xd,
	SystemPagedPoolInformation = 0xe,
	SystemNonPagedPoolInformation = 0xf,
	SystemHandleInformation = 0x10,
	SystemObjectInformation = 0x11,
	SystemPageFileInformation = 0x12,
	SystemVdmInstemulInformation = 0x13,
	SystemVdmBopInformation = 0x14,
	SystemFileCacheInformation = 0x15,
	SystemPoolTagInformation = 0x16,
	SystemInterruptInformation = 0x17,
	SystemDpcBehaviorInformation = 0x18,
	SystemFullMemoryInformation = 0x19,
	SystemLoadGdiDriverInformation = 0x1a,
	SystemUnloadGdiDriverInformation = 0x1b,
	SystemTimeAdjustmentInformation = 0x1c,
	SystemSummaryMemoryInformation = 0x1d,
	SystemMirrorMemoryInformation = 0x1e,
	SystemPerformanceTraceInformation = 0x1f,
	SystemObsolete0 = 0x20,
	SystemExceptionInformation = 0x21,
	SystemCrashDumpStateInformation = 0x22,
	SystemKernelDebuggerInformation = 0x23,
	SystemContextSwitchInformation = 0x24,
	SystemRegistryQuotaInformation = 0x25,
	SystemExtendServiceTableInformation = 0x26,
	SystemPrioritySeperation = 0x27,
	SystemVerifierAddDriverInformation = 0x28,
	SystemVerifierRemoveDriverInformation = 0x29,
	SystemProcessorIdleInformation = 0x2a,
	SystemLegacyDriverInformation = 0x2b,
	SystemCurrentTimeZoneInformation = 0x2c,
	SystemLookasideInformation = 0x2d,
	SystemTimeSlipNotification = 0x2e,
	SystemSessionCreate = 0x2f,
	SystemSessionDetach = 0x30,
	SystemSessionInformation = 0x31,
	SystemRangeStartInformation = 0x32,
	SystemVerifierInformation = 0x33,
	SystemVerifierThunkExtend = 0x34,
	SystemSessionProcessInformation = 0x35,
	SystemLoadGdiDriverInSystemSpace = 0x36,
	SystemNumaProcessorMap = 0x37,
	SystemPrefetcherInformation = 0x38,
	SystemExtendedProcessInformation = 0x39,
	SystemRecommendedSharedDataAlignment = 0x3a,
	SystemComPlusPackage = 0x3b,
	SystemNumaAvailableMemory = 0x3c,
	SystemProcessorPowerInformation = 0x3d,
	SystemEmulationBasicInformation = 0x3e,
	SystemEmulationProcessorInformation = 0x3f,
	SystemExtendedHandleInformation = 0x40,
	SystemLostDelayedWriteInformation = 0x41,
	SystemBigPoolInformation = 0x42,
	SystemSessionPoolTagInformation = 0x43,
	SystemSessionMappedViewInformation = 0x44,
	SystemHotpatchInformation = 0x45,
	SystemObjectSecurityMode = 0x46,
	SystemWatchdogTimerHandler = 0x47,
	SystemWatchdogTimerInformation = 0x48,
	SystemLogicalProcessorInformation = 0x49,
	SystemWow64SharedInformationObsolete = 0x4a,
	SystemRegisterFirmwareTableInformationHandler = 0x4b,
	SystemFirmwareTableInformation = 0x4c,
	SystemModuleInformationEx = 0x4d,
	SystemVerifierTriageInformation = 0x4e,
	SystemSuperfetchInformation = 0x4f,
	SystemMemoryListInformation = 0x50,
	SystemFileCacheInformationEx = 0x51,
	SystemThreadPriorityClientIdInformation = 0x52,
	SystemProcessorIdleCycleTimeInformation = 0x53,
	SystemVerifierCancellationInformation = 0x54,
	SystemProcessorPowerInformationEx = 0x55,
	SystemRefTraceInformation = 0x56,
	SystemSpecialPoolInformation = 0x57,
	SystemProcessIdInformation = 0x58,
	SystemErrorPortInformation = 0x59,
	SystemBootEnvironmentInformation = 0x5a,
	SystemHypervisorInformation = 0x5b,
	SystemVerifierInformationEx = 0x5c,
	SystemTimeZoneInformation = 0x5d,
	SystemImageFileExecutionOptionsInformation = 0x5e,
	SystemCoverageInformation = 0x5f,
	SystemPrefetchPatchInformation = 0x60,
	SystemVerifierFaultsInformation = 0x61,
	SystemSystemPartitionInformation = 0x62,
	SystemSystemDiskInformation = 0x63,
	SystemProcessorPerformanceDistribution = 0x64,
	SystemNumaProximityNodeInformation = 0x65,
	SystemDynamicTimeZoneInformation = 0x66,
	SystemCodeIntegrityInformation = 0x67,
	SystemProcessorMicrocodeUpdateInformation = 0x68,
	SystemProcessorBrandString = 0x69,
	SystemVirtualAddressInformation = 0x6a,
	SystemLogicalProcessorAndGroupInformation = 0x6b,
	SystemProcessorCycleTimeInformation = 0x6c,
	SystemStoreInformation = 0x6d,
	SystemRegistryAppendString = 0x6e,
	SystemAitSamplingValue = 0x6f,
	SystemVhdBootInformation = 0x70,
	SystemCpuQuotaInformation = 0x71,
	SystemNativeBasicInformation = 0x72,
	SystemErrorPortTimeouts = 0x73,
	SystemLowPriorityIoInformation = 0x74,
	SystemBootEntropyInformation = 0x75,
	SystemVerifierCountersInformation = 0x76,
	SystemPagedPoolInformationEx = 0x77,
	SystemSystemPtesInformationEx = 0x78,
	SystemNodeDistanceInformation = 0x79,
	SystemAcpiAuditInformation = 0x7a,
	SystemBasicPerformanceInformation = 0x7b,
	SystemQueryPerformanceCounterInformation = 0x7c,
	SystemSessionBigPoolInformation = 0x7d,
	SystemBootGraphicsInformation = 0x7e,
	SystemScrubPhysicalMemoryInformation = 0x7f,
	SystemBadPageInformation = 0x80,
	SystemProcessorProfileControlArea = 0x81,
	SystemCombinePhysicalMemoryInformation = 0x82,
	SystemEntropyInterruptTimingInformation = 0x83,
	SystemConsoleInformation = 0x84,
	SystemPlatformBinaryInformation = 0x85,
	SystemThrottleNotificationInformation = 0x86,
	SystemHypervisorProcessorCountInformation = 0x87,
	SystemDeviceDataInformation = 0x88,
	SystemDeviceDataEnumerationInformation = 0x89,
	SystemMemoryTopologyInformation = 0x8a,
	SystemMemoryChannelInformation = 0x8b,
	SystemBootLogoInformation = 0x8c,
	SystemProcessorPerformanceInformationEx = 0x8d,
	SystemSpare0 = 0x8e,
	SystemSecureBootPolicyInformation = 0x8f,
	SystemPageFileInformationEx = 0x90,
	SystemSecureBootInformation = 0x91,
	SystemEntropyInterruptTimingRawInformation = 0x92,
	SystemPortableWorkspaceEfiLauncherInformation = 0x93,
	SystemFullProcessInformation = 0x94,
	SystemKernelDebuggerInformationEx = 0x95,
	SystemBootMetadataInformation = 0x96,
	SystemSoftRebootInformation = 0x97,
	SystemElamCertificateInformation = 0x98,
	SystemOfflineDumpConfigInformation = 0x99,
	SystemProcessorFeaturesInformation = 0x9a,
	SystemRegistryReconciliationInformation = 0x9b,
	MaxSystemInfoClass = 0x9c,
} SYSTEM_INFORMATION_CLASS;

typedef struct _DYNDATA
{
	UINT64 CallbackListOffset;
}DYNDATA, * PDYNDATA;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;         // Not filled in
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[MAXIMUM_FILENAME_LENGTH];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef struct _CALLBACK_ENTRY {
	UINT16 Version; // 0x0
	UINT16 OperationRegistrationCount; // 0x2
	UINT32 unk1; // 0x4
	PVOID RegistrationContext; // 0x8
	UNICODE_STRING Altitude; // 0x10
} CALLBACK_ENTRY, * PCALLBACK_ENTRY;

typedef struct _OBJECT_CALLBACK_ENTRY {
	LIST_ENTRY CallbackList;
	OB_OPERATION Operations;
	ULONG Active;
	/*OB_HANDLE*/ PCALLBACK_ENTRY CallbackEntry;
	POBJECT_TYPE ObjectType;
	POB_PRE_OPERATION_CALLBACK  PreOperation;
	POB_POST_OPERATION_CALLBACK PostOperation;
} OBJECT_CALLBACK_ENTRY, * POBJECT_CALLBACK_ENTRY;

struct REQUEST_STRUCT
{
	PIO_COMPLETION_ROUTINE OldRoutine;
	PVOID OldContext;
	ULONG OutputBufferLength;
	PVOID SystemBuffer;
};

typedef struct _PS_CALLBACK_ENTRY
{
	PVOID* Callback;
	LARGE_INTEGER* Fillz;
} PS_CALLBACK_ENTRY, * PPS_CALLBACK_ENTRY;

typedef struct _OB_CALLBACK_ADDRESSES
{
	UINT64* pProcPreCallback, * pProcPostCallback;
	UINT64* pThreadPreCallback, * pThreadPostCallback;
	UINT64 OrigProcPre, OrigProcPost;
	UINT64 OrigThreadPre, OrigThreadPost;
}OB_CALLBACK_ADDRESSES, * POB_CALLBACK_ADDRESSES;

typedef struct _IDINFO
{
	USHORT	wGenConfig;
	USHORT	wNumCyls;
	USHORT	wReserved;
	USHORT	wNumHeads;
	USHORT	wBytesPerTrack;
	USHORT	wBytesPerSector;
	USHORT	wNumSectorsPerTrack;
	USHORT	wVendorUnique[3];
	CHAR	sSerialNumber[20];
	USHORT	wBufferType;
	USHORT	wBufferSize;
	USHORT	wECCSize;
	CHAR	sFirmwareRev[8];
	CHAR	sModelNumber[40];
	USHORT	wMoreVendorUnique;
	USHORT	wDoubleWordIO;
	struct {
		USHORT	Reserved : 8;
		USHORT	DMA : 1;
		USHORT	LBA : 1;
		USHORT	DisIORDY : 1;
		USHORT	IORDY : 1;
		USHORT	SoftReset : 1;
		USHORT	Overlap : 1;
		USHORT	Queue : 1;
		USHORT	InlDMA : 1;
	} wCapabilities;
	USHORT	wReserved1;
	USHORT	wPIOTiming;
	USHORT	wDMATiming;
	struct {
		USHORT	CHSNumber : 1;
		USHORT	CycleNumber : 1;
		USHORT	UnltraDMA : 1;
		USHORT	Reserved : 13;
	} wFieldValidity;
	USHORT	wNumCurCyls;
	USHORT	wNumCurHeads;
	USHORT	wNumCurSectorsPerTrack;
	USHORT	wCurSectorsLow;
	USHORT	wCurSectorsHigh;
	struct {
		USHORT	CurNumber : 8;
		USHORT	Multi : 1;
		USHORT	Reserved : 7;
	} wMultSectorStuff;
	ULONG	dwTotalSectors;
	USHORT	wSingleWordDMA;
	struct {
		USHORT	Mode0 : 1;
		USHORT	Mode1 : 1;
		USHORT	Mode2 : 1;
		USHORT	Reserved1 : 5;
		USHORT	Mode0Sel : 1;
		USHORT	Mode1Sel : 1;
		USHORT	Mode2Sel : 1;
		USHORT	Reserved2 : 5;
	} wMultiWordDMA;
	struct {
		USHORT	AdvPOIModes : 8;
		USHORT	Reserved : 8;
	} wPIOCapacity;
	USHORT	wMinMultiWordDMACycle;
	USHORT	wRecMultiWordDMACycle;
	USHORT	wMinPIONoFlowCycle;
	USHORT	wMinPOIFlowCycle;
	USHORT	wReserved69[11];
	struct {
		USHORT	Reserved1 : 1;
		USHORT	ATA1 : 1;
		USHORT	ATA2 : 1;
		USHORT	ATA3 : 1;
		USHORT	ATA4 : 1;
		USHORT	ATA5 : 1;
		USHORT	ATA6 : 1;
		USHORT	ATA7 : 1;
		USHORT	ATA8 : 1;
		USHORT	ATA9 : 1;
		USHORT	ATA10 : 1;
		USHORT	ATA11 : 1;
		USHORT	ATA12 : 1;
		USHORT	ATA13 : 1;
		USHORT	ATA14 : 1;
		USHORT	Reserved2 : 1;
	} wMajorVersion;
	USHORT	wMinorVersion;
	USHORT	wReserved82[6];
	struct {
		USHORT	Mode0 : 1;
		USHORT	Mode1 : 1;
		USHORT	Mode2 : 1;
		USHORT	Mode3 : 1;
		USHORT	Mode4 : 1;
		USHORT	Mode5 : 1;
		USHORT	Mode6 : 1;
		USHORT	Mode7 : 1;
		USHORT	Mode0Sel : 1;
		USHORT	Mode1Sel : 1;
		USHORT	Mode2Sel : 1;
		USHORT	Mode3Sel : 1;
		USHORT	Mode4Sel : 1;
		USHORT	Mode5Sel : 1;
		USHORT	Mode6Sel : 1;
		USHORT	Mode7Sel : 1;
	} wUltraDMA;
	USHORT	wReserved89[167];
} IDINFO, * PIDINFO;

typedef struct _SYSTEM_MODULE   // Information Class 11
{
	ULONG_PTR Reserved[2];
	PVOID Base;
	ULONG Size;
	ULONG Flags;
	USHORT Index;
	USHORT Unknown;
	USHORT LoadCount;
	USHORT ModuleNameOffset;
	CHAR ImageName[256];
} SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct _SYSTEM_MODULE_INFORMATION   // Information Class 11
{
	ULONG_PTR ulModuleCount;
	SYSTEM_MODULE Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

struct piddbcache
{
	LIST_ENTRY		List;
	UNICODE_STRING	DriverName;
	ULONG			TimeDateStamp;
	NTSTATUS		LoadStatus;
	char			_0x0028[16]; // data from the shim engine, or uninitialized memory for custom drivers
};


typedef struct _PEB_LDR_DATA {
	ULONG Length;
	BOOLEAN Initialized;
	PVOID SsHandle;
	LIST_ENTRY ModuleListLoadOrder;
	LIST_ENTRY ModuleListMemoryOrder; 
	LIST_ENTRY ModuleListInitOrder;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
	BYTE Reserved1[16];
	PVOID Reserved2[10];
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef void(__stdcall* PPS_POST_PROCESS_INIT_ROUTINE)(void);

typedef struct _PEB {
	BYTE Reserved1[2];
	BYTE BeingDebugged;
	BYTE Reserved2[1];
	PVOID Reserved3[2];
	PPEB_LDR_DATA Ldr;
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
	PVOID Reserved4[3];
	PVOID AtlThunkSListPtr;
	PVOID Reserved5;
	ULONG Reserved6;
	PVOID Reserved7;
	ULONG Reserved8;
	ULONG AtlThunkSListPtr32;
	PVOID Reserved9[45];
	BYTE Reserved10[96];
	PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
	BYTE Reserved11[128];
	PVOID Reserved12[1];
	ULONG SessionId;
} PEB, * PPEB;

typedef struct _LDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;  // in bytes
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;  // LDR_*
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	PVOID SectionPointer;
	ULONG CheckSum;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

extern "C"
{
	NTKERNELAPI PPEB PsGetProcessPeb(IN PEPROCESS Process);

	NTKERNELAPI NTSTATUS MmCopyVirtualMemory(
		IN PEPROCESS		SourceProcess,
		IN PVOID			SourceAddress,
		IN PEPROCESS		TargetProcess,
		IN PVOID			TargetAddress,
		IN SIZE_T			BufferSize,
		IN KPROCESSOR_MODE  PreviousMode,
		OUT PSIZE_T			ReturnSize
	);

	NTKERNELAPI NTSTATUS PsLookupProcessByProcessId(
		IN HANDLE			ProcessId,
		OUT PEPROCESS*		Process
	);

	NTKERNELAPI PVOID PsGetProcessSectionBaseAddress(
		IN PEPROCESS		Process
	);

	NTKERNELAPI NTSTATUS ZwQuerySystemInformation(
		SYSTEM_INFORMATION_CLASS SystemInformationClass, 
		PVOID SystemInformation, 
		ULONG SystemInformationLength, 
		PULONG ReturnLength
	);

	NTSYSAPI ULONG RtlRandomEx(
		PULONG Seed
	);
}

template <typename t = void*>
t find_pattern(void* start, size_t length, const char* pattern, const char* mask) {
	const auto data = static_cast<const char*>(start);
	const auto pattern_length = strlen(mask);

	for (size_t i = 0; i <= length - pattern_length; i++)
	{
		bool accumulative_found = true;

		for (size_t j = 0; j < pattern_length; j++)
		{
			if (!MmIsAddressValid(reinterpret_cast<void*>(reinterpret_cast<uintptr_t>(data) + i + j)))
			{
				accumulative_found = false;
				break;
			}

			if (data[i + j] != pattern[j] && mask[j] != '?')
			{
				accumulative_found = false;
				break;
			}
		}

		if (accumulative_found)
		{
			return (t)(reinterpret_cast<uintptr_t>(data) + i);
		}
	}

	return (t)nullptr;
}

uintptr_t dereference(uintptr_t address, unsigned int offset) {
	if (address == 0)
		return 0;

	return address + (int)((*(int*)(address + offset) + offset) + sizeof(int));
}
```

`EFT Kernel/socket-km/ksocket/berkeley.c`:

```c
#include "berkeley.h"
#include "ksocket.h"

//////////////////////////////////////////////////////////////////////////
// Definitions.
//////////////////////////////////////////////////////////////////////////

#define MEMORY_TAG            'bcE'
#define SOCKETFD_MAX          128
#define TO_SOCKETFD(index)    ((index % SOCKETFD_MAX)  + 1)
#define FROM_SOCKETFD(sockfd) ((sockfd)                - 1)

//////////////////////////////////////////////////////////////////////////
// Function prototypes.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
KspUtilAddrInfoToAddrInfoEx(
    _In_ PADDRINFOA AddrInfo,
    _Out_ PADDRINFOEXW* AddrInfoEx
);

NTSTATUS
NTAPI
KspUtilAddrInfoExToAddrInfo(
    _In_ PADDRINFOEXW AddrInfoEx,
    _Out_ PADDRINFOA* AddrInfo
);

VOID
NTAPI
KspUtilFreeAddrInfo(
    _In_ PADDRINFOA AddrInfo
);

VOID
NTAPI
KspUtilFreeAddrInfoEx(
    _In_ PADDRINFOEXW AddrInfo
);

//////////////////////////////////////////////////////////////////////////
// Variables.
//////////////////////////////////////////////////////////////////////////

//
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// This is complete bollocks and ideally it should be replaced with
// something like RTL_AVL_TABLE.
//
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!! NOTE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//

PKSOCKET KsArray[SOCKETFD_MAX] = { 0 };
ULONG    KsIndex = 0;

//////////////////////////////////////////////////////////////////////////
// Private functions.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
KspUtilAddrInfoToAddrInfoEx(
    _In_ PADDRINFOA AddrInfo,
    _Out_ PADDRINFOEXW* AddrInfoEx
)
{
    NTSTATUS Status;

    //
    // Convert NULL input into NULL output.
    //

    if (AddrInfo == NULL)
    {
        *AddrInfoEx = NULL;
        return STATUS_SUCCESS;
    }

    //
    // Allocate memory for the output structure.
    //

    PADDRINFOEXW Result = ExAllocatePoolWithTag(PagedPool, sizeof(ADDRINFOEXW), MEMORY_TAG);

    if (Result == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error1;
    }

    //
    // Copy numeric values.
    //

    RtlZeroMemory(Result, sizeof(ADDRINFOEXW));
    Result->ai_flags = AddrInfo->ai_flags;
    Result->ai_family = AddrInfo->ai_family;
    Result->ai_socktype = AddrInfo->ai_socktype;
    Result->ai_protocol = AddrInfo->ai_protocol;
    Result->ai_addrlen = AddrInfo->ai_addrlen;

    //
    // Copy canonical name.
    //

    ANSI_STRING CanonicalNameAnsi;
    UNICODE_STRING CanonicalNameUnicode;

    if (AddrInfo->ai_canonname)
    {
        RtlInitAnsiString(&CanonicalNameAnsi, AddrInfo->ai_canonname);

        Status = RtlAnsiStringToUnicodeString(&CanonicalNameUnicode, &CanonicalNameAnsi, TRUE);

        if (!NT_SUCCESS(Status))
        {
            goto Error2;
        }

        Result->ai_canonname = CanonicalNameUnicode.Buffer;
    }

    //
    // Copy address.
    //

    Result->ai_addr = AddrInfo->ai_addr;

    //
    // Copy the next structure (recursively).
    //

    PADDRINFOEXW NextAddrInfo;
    Status = KspUtilAddrInfoToAddrInfoEx(AddrInfo->ai_next, &NextAddrInfo);

    if (!NT_SUCCESS(Status))
    {
        goto Error3;
    }

    Result->ai_next = NextAddrInfo;

    //
    // All done!
    //

    *AddrInfoEx = Result;

    return Status;

Error3:
    RtlFreeAnsiString(&CanonicalNameAnsi);

Error2:
    ExFreePoolWithTag(Result, MEMORY_TAG);

Error1:
    return Status;
}

NTSTATUS
NTAPI
KspUtilAddrInfoExToAddrInfo(
    _In_ PADDRINFOEXW AddrInfoEx,
    _Out_ PADDRINFOA* AddrInfo
)
{
    NTSTATUS Status;

    //
    // Convert NULL input into NULL output.
    //

    if (AddrInfoEx == NULL)
    {
        *AddrInfo = NULL;
        return STATUS_SUCCESS;
    }

    //
    // Allocate memory for the output structure.
    //

    PADDRINFOA Result = ExAllocatePoolWithTag(PagedPool, sizeof(ADDRINFOA), MEMORY_TAG);

    if (Result == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error1;
    }

    //
    // Copy numeric values.
    //

    RtlZeroMemory(Result, sizeof(ADDRINFOA));
    Result->ai_flags = AddrInfoEx->ai_flags;
    Result->ai_family = AddrInfoEx->ai_family;
    Result->ai_socktype = AddrInfoEx->ai_socktype;
    Result->ai_protocol = AddrInfoEx->ai_protocol;
    Result->ai_addrlen = AddrInfoEx->ai_addrlen;

    //
    // Copy canonical name.
    //

    UNICODE_STRING CanonicalNameUnicode;
    ANSI_STRING CanonicalNameAnsi;

    if (AddrInfoEx->ai_canonname)
    {
        RtlInitUnicodeString(&CanonicalNameUnicode, AddrInfoEx->ai_canonname);
        Status = RtlUnicodeStringToAnsiString(&CanonicalNameAnsi, &CanonicalNameUnicode, TRUE);

        if (!NT_SUCCESS(Status))
        {
            goto Error2;
        }

        Result->ai_canonname = CanonicalNameAnsi.Buffer;
    }

    //
    // Copy address.
    //

    Result->ai_addr = AddrInfoEx->ai_addr;

    //
    // Copy the next structure (recursively).
    //

    PADDRINFOA NextAddrInfo;
    Status = KspUtilAddrInfoExToAddrInfo(AddrInfoEx->ai_next, &NextAddrInfo);

    if (!NT_SUCCESS(Status))
    {
        goto Error3;
    }

    Result->ai_next = NextAddrInfo;

    //
    // All done!
    //

    *AddrInfo = Result;

    return Status;

Error3:
    RtlFreeAnsiString(&CanonicalNameAnsi);

Error2:
    ExFreePoolWithTag(Result, MEMORY_TAG);

Error1:
    return Status;
}

VOID
NTAPI
KspUtilFreeAddrInfo(
    _In_ PADDRINFOA AddrInfo
)
{
    //
    // Free all structures recursively.
    //

    if (AddrInfo->ai_next)
    {
        KspUtilFreeAddrInfo(AddrInfo->ai_next);
    }

    //
    // Free the canonical name buffer.
    //

    if (AddrInfo->ai_canonname)
    {
        ANSI_STRING CanonicalName;
        RtlInitAnsiString(&CanonicalName, AddrInfo->ai_canonname);
        RtlFreeAnsiString(&CanonicalName);
    }

    //
    // Finally, free the structure itself.
    //

    ExFreePoolWithTag(AddrInfo, MEMORY_TAG);
}

VOID
NTAPI
KspUtilFreeAddrInfoEx(
    _In_ PADDRINFOEXW AddrInfo
)
{
    //
    // Free all structures recursively.
    //

    if (AddrInfo->ai_next)
    {
        KspUtilFreeAddrInfoEx(AddrInfo->ai_next);
    }

    //
    // Free the canonical name buffer.
    //

    if (AddrInfo->ai_canonname)
    {
        UNICODE_STRING CanonicalName;
        RtlInitUnicodeString(&CanonicalName, AddrInfo->ai_canonname);
        RtlFreeUnicodeString(&CanonicalName);
    }

    //
    // Finally, free the structure itself.
    //

    ExFreePoolWithTag(AddrInfo, MEMORY_TAG);
}

//////////////////////////////////////////////////////////////////////////
// Public functions.
//////////////////////////////////////////////////////////////////////////

uint32_t htonl(uint32_t hostlong)
{
    return RtlUlongByteSwap(hostlong);
}

uint16_t htons(uint16_t hostshort)
{
    return RtlUshortByteSwap(hostshort);
}

uint32_t ntohl(uint32_t netlong)
{
    return RtlUlongByteSwap(netlong);
}

uint16_t ntohs(uint16_t netshort)
{
    return RtlUshortByteSwap(netshort);
}

int getaddrinfo(const char* node, const char* service, const struct addrinfo* hints, struct addrinfo** res)
{
    NTSTATUS Status;

    //
    // Convert node name to the UNICODE_STRING (if present).
    //

    ANSI_STRING NodeNameAnsi;
    UNICODE_STRING NodeNameUnicode;
    PUNICODE_STRING NodeName = NULL;

    if (node)
    {
        RtlInitAnsiString(&NodeNameAnsi, node);
        Status = RtlAnsiStringToUnicodeString(&NodeNameUnicode, &NodeNameAnsi, TRUE);

        if (!NT_SUCCESS(Status))
        {
            goto Error1;
        }

        NodeName = &NodeNameUnicode;
    }

    //
    // Convert service name to the UNICODE_STRING (if present).
    //

    ANSI_STRING ServiceNameAnsi;
    UNICODE_STRING ServiceNameUnicode;
    PUNICODE_STRING ServiceName = NULL;

    if (service)
    {
        RtlInitAnsiString(&ServiceNameAnsi, service);
        Status = RtlAnsiStringToUnicodeString(&ServiceNameUnicode, &ServiceNameAnsi, TRUE);

        if (!NT_SUCCESS(Status))
        {
            goto Error2;
        }

        ServiceName = &ServiceNameUnicode;
    }

    //
    // Convert "struct addrinfo" to the "ADDRINFOEXW".
    //

    PADDRINFOEXW Hints;
    Status = KspUtilAddrInfoToAddrInfoEx((PADDRINFOA)hints, &Hints);

    if (!NT_SUCCESS(Status))
    {
        goto Error3;
    }

    //
    // All data is prepared, call the underlying API.
    //

    PADDRINFOEXW Result;
    Status = KsGetAddrInfo(NodeName, ServiceName, Hints, &Result);

    //
    // Free the memory of the converted "Hints".
    //

    KspUtilFreeAddrInfoEx(Hints);

    if (!NT_SUCCESS(Status))
    {
        goto Error3;
    }

    //
    // Convert the result "ADDRINFOEXW" to the "struct addrinfo".
    //

    Status = KspUtilAddrInfoExToAddrInfo(Result, res);

    //
    // Free the original result.
    //

    KsFreeAddrInfo(Result);

    if (!NT_SUCCESS(Status))
    {
        goto Error3;
    }

    return STATUS_SUCCESS;

Error3:
    RtlFreeUnicodeString(&ServiceNameUnicode);

Error2:
    RtlFreeUnicodeString(&NodeNameUnicode);

Error1:
    return Status;
}

void freeaddrinfo(struct addrinfo* res)
{
    //
    // Call our implementation.
    //

    KspUtilFreeAddrInfo(res);
}

int socket_connection(int domain, int type, int protocol)
{
    NTSTATUS Status;
    PKSOCKET Socket;

    Status = KsCreateConnectionSocket(
        &Socket,
        (ADDRESS_FAMILY)domain,
        (USHORT)type,
        (ULONG)protocol
    );

    if (NT_SUCCESS(Status))
    {
        int sockfd = TO_SOCKETFD(KsIndex++);

        KsArray[FROM_SOCKETFD(sockfd)] = Socket;

        return sockfd;
    }

    return -1;
}

int socket_listen(int domain, int type, int protocol)
{
    NTSTATUS Status;
    PKSOCKET Socket;

    //
    // WskSocket() returns STATUS_PROTOCOL_UNREACHABLE (0xC000023E)
    // when Protocol == 0, so coerce this value to IPPROTO_TCP here.
    //

    Status = KsCreateListenSocket(
        &Socket,
        (ADDRESS_FAMILY)domain,
        (USHORT)type,
        protocol ? (ULONG)protocol : IPPROTO_TCP
    );

    if (NT_SUCCESS(Status))
    {
        int sockfd = TO_SOCKETFD(KsIndex++);

        KsArray[FROM_SOCKETFD(sockfd)] = Socket;

        return sockfd;
    }

    return -1;
}

int socket_datagram(int domain, int type, int protocol)
{
    NTSTATUS Status;
    PKSOCKET Socket;

    Status = KsCreateDatagramSocket(
        &Socket,
        (ADDRESS_FAMILY)domain,
        (USHORT)type,
        (ULONG)protocol
    );

    if (NT_SUCCESS(Status))
    {
        int sockfd = TO_SOCKETFD(KsIndex++);

        KsArray[FROM_SOCKETFD(sockfd)] = Socket;

        return sockfd;
    }

    return -1;
}

int connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen)
{
    UNREFERENCED_PARAMETER(addrlen);

    NTSTATUS Status;
    PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

    Status = KsConnect(Socket, (PSOCKADDR)addr);

    return NT_SUCCESS(Status)
        ? 0
        : -1;
}

int listen(int sockfd, int backlog)
{
    UNREFERENCED_PARAMETER(sockfd);
    UNREFERENCED_PARAMETER(backlog);
    return 0;
}

int bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen)
{
    UNREFERENCED_PARAMETER(addrlen);

    NTSTATUS Status;
    PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

    Status = KsBind(Socket, (PSOCKADDR)addr);

    return NT_SUCCESS(Status)
        ? 0
        : -1;
}

int accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen)
{
    NTSTATUS Status;
    PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

    PKSOCKET NewSocket;
    Status = KsAccept(Socket, &NewSocket, NULL, (PSOCKADDR)addr);
    *addrlen = sizeof(SOCKADDR);

    if (NT_SUCCESS(Status))
    {
        int newsockfd = TO_SOCKETFD(KsIndex++);

        KsArray[FROM_SOCKETFD(newsockfd)] = NewSocket;

        return newsockfd;
    }

    return -1;
}

int send(int sockfd, const void* buf, size_t len, int flags)
{
    NTSTATUS Status;
    PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

    ULONG Length = (ULONG)len;
    Status = KsSend(Socket, (PVOID)buf, &Length, (ULONG)flags);

    return NT_SUCCESS(Status)
        ? (int)Length
        : -1;
}

int sendto(int sockfd, const void* buf, size_t len, int flags, const struct sockaddr* dest_addr, socklen_t addrlen)
{
    UNREFERENCED_PARAMETER(addrlen);

    NTSTATUS Status;
    PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

    ULONG Length = (ULONG)len;
    Status = KsSendTo(Socket, (PVOID)buf, &Length, (ULONG)flags, (PSOCKADDR)dest_addr);

    return NT_SUCCESS(Status)
        ? (int)Length
        : -1;
}

int recv(int sockfd, void* buf, size_t len, int flags)
{
    NTSTATUS Status;
    PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

    ULONG Length = (ULONG)len;
    Status = KsRecv(Socket, (PVOID)buf, &Length, (ULONG)flags);

    return NT_SUCCESS(Status)
        ? (int)Length
        : -1;
}

int recvfrom(int sockfd, void* buf, size_t len, int flags, struct sockaddr* src_addr, socklen_t* addrlen)
{
    UNREFERENCED_PARAMETER(addrlen);

    NTSTATUS Status;
    PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

    ULONG Length = (ULONG)len;
    Status = KsSendTo(Socket, (PVOID)buf, &Length, (ULONG)flags, (PSOCKADDR)src_addr);
    *addrlen = sizeof(SOCKADDR);

    return NT_SUCCESS(Status)
        ? (int)Length
        : -1;
}

int closesocket(int sockfd)
{
    NTSTATUS Status;
    PKSOCKET Socket = KsArray[FROM_SOCKETFD(sockfd)];

    Status = KsCloseSocket(Socket);

    KsArray[FROM_SOCKETFD(sockfd)] = NULL;

    return NT_SUCCESS(Status)
        ? 0
        : -1;
}
```

`EFT Kernel/socket-km/ksocket/berkeley.h`:

```h
#pragma once
#include <ntddk.h>
#include <wsk.h>
#include "../stdint.h"

	typedef int       socklen_t;
	typedef intptr_t  ssize_t;

	uint32_t htonl(uint32_t hostlong);
	uint16_t htons(uint16_t hostshort);
	uint32_t ntohl(uint32_t netlong);
	uint16_t ntohs(uint16_t netshort);

	int getaddrinfo(const char* node, const char* service, const struct addrinfo* hints, struct addrinfo** res);
	void freeaddrinfo(struct addrinfo* res);

	int socket_connection(int domain, int type, int protocol);
	int socket_listen(int domain, int type, int protocol);
	int socket_datagram(int domain, int type, int protocol);
	int connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen);
	int listen(int sockfd, int backlog);
	int bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen);
	int accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen);
	int send(int sockfd, const void* buf, size_t len, int flags);
	int sendto(int sockfd, const void* buf, size_t len, int flags, const struct sockaddr* dest_addr, socklen_t addrlen);
	int recv(int sockfd, void* buf, size_t len, int flags);
	int recvfrom(int sockfd, void* buf, size_t len, int flags, struct sockaddr* src_addr, socklen_t* addrlen);
	int closesocket(int sockfd);

#define socket  socket_connection


```

`EFT Kernel/socket-km/ksocket/ksocket.c`:

```c
#include "ksocket.h"

//////////////////////////////////////////////////////////////////////////
// Definitions.
//////////////////////////////////////////////////////////////////////////

#define MEMORY_TAG            'cE'

//////////////////////////////////////////////////////////////////////////
// Structures.
//////////////////////////////////////////////////////////////////////////

typedef struct _KSOCKET_ASYNC_CONTEXT
{
    KEVENT CompletionEvent;
    PIRP Irp;
} KSOCKET_ASYNC_CONTEXT, * PKSOCKET_ASYNC_CONTEXT;

typedef struct _KSOCKET
{
    PWSK_SOCKET	WskSocket;

    union
    {
        PVOID WskDispatch;

        PWSK_PROVIDER_CONNECTION_DISPATCH WskConnectionDispatch;
        PWSK_PROVIDER_LISTEN_DISPATCH WskListenDispatch;
        PWSK_PROVIDER_DATAGRAM_DISPATCH WskDatagramDispatch;
#if (NTDDI_VERSION >= NTDDI_WIN10_RS2)
        PWSK_PROVIDER_STREAM_DISPATCH WskStreamDispatch;
#endif
    };

    KSOCKET_ASYNC_CONTEXT AsyncContext;
} KSOCKET, * PKSOCKET;

//////////////////////////////////////////////////////////////////////////
// Variables.
//////////////////////////////////////////////////////////////////////////

WSK_REGISTRATION     WskRegistration;
WSK_PROVIDER_NPI     WskProvider;
WSK_CLIENT_DISPATCH  WskDispatch = { MAKE_WSK_VERSION(1,0), 0, NULL };

//////////////////////////////////////////////////////////////////////////
// Function prototypes.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
KspAsyncContextAllocate(
    _Out_ PKSOCKET_ASYNC_CONTEXT AsyncContext
);

VOID
NTAPI
KspAsyncContextFree(
    _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext
);

VOID
NTAPI
KspAsyncContextReset(
    _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext
);

NTSTATUS
NTAPI
KspAsyncContextCompletionRoutine(
    _In_ PDEVICE_OBJECT	DeviceObject,
    _In_ PIRP Irp,
    _In_ PKEVENT CompletionEvent
);

NTSTATUS
NTAPI
KspAsyncContextWaitForCompletion(
    _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext,
    _Inout_ PNTSTATUS Status
);

//////////////////////////////////////////////////////////////////////////
// Private functions.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
KspAsyncContextAllocate(
    _Out_ PKSOCKET_ASYNC_CONTEXT AsyncContext
)
{
    //
    // Initialize the completion event.
    //

    KeInitializeEvent(
        &AsyncContext->CompletionEvent,
        SynchronizationEvent,
        FALSE
    );

    //
    // Initialize the IRP.
    //

    AsyncContext->Irp = IoAllocateIrp(1, FALSE);

    if (AsyncContext->Irp == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // KspAsyncContextCompletionRoutine will set
    // the CompletionEvent.
    //

    IoSetCompletionRoutine(
        AsyncContext->Irp,
        &KspAsyncContextCompletionRoutine,
        &AsyncContext->CompletionEvent,
        TRUE,
        TRUE,
        TRUE
    );

    return STATUS_SUCCESS;
}

VOID
NTAPI
KspAsyncContextFree(
    _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext
)
{
    //
    // Free the IRP.
    //

    IoFreeIrp(AsyncContext->Irp);
}

VOID
NTAPI
KspAsyncContextReset(
    _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext
)
{
    //
    // If the WSK application allocated the IRP, or is reusing an IRP
    // that it previously allocated, then it must set an IoCompletion
    // routine for the IRP before calling a WSK function.  In this
    // situation, the WSK application must specify TRUE for the
    // InvokeOnSuccess, InvokeOnError, and InvokeOnCancel parameters that
    // are passed to the IoSetCompletionRoutine function to ensure that
    // the IoCompletion routine is always called. Furthermore, the IoCompletion
    // routine that is set for the IRP must always return
    // STATUS_MORE_PROCESSING_REQUIRED to terminate the completion processing
    // of the IRP.  If the WSK application is done using the IRP after the
    // IoCompletion routine has been called, then it should call the IoFreeIrp
    // function to free the IRP before returning from the IoCompletion routine.
    // If the WSK application does not free the IRP then it can reuse the IRP
    // for a call to another WSK function.
    //
    // (ref: https://docs.microsoft.com/en-us/windows-hardware/drivers/network/using-irps-with-winsock-kernel-functions)
    //

    //
    // Reset the completion event.
    //

    KeResetEvent(&AsyncContext->CompletionEvent);

    //
    // Reuse the IRP.
    //

    IoReuseIrp(AsyncContext->Irp, STATUS_UNSUCCESSFUL);

    IoSetCompletionRoutine(
        AsyncContext->Irp,
        &KspAsyncContextCompletionRoutine,
        &AsyncContext->CompletionEvent,
        TRUE,
        TRUE,
        TRUE
    );
}

NTSTATUS
NTAPI
KspAsyncContextCompletionRoutine(
    _In_ PDEVICE_OBJECT	DeviceObject,
    _In_ PIRP Irp,
    _In_ PKEVENT CompletionEvent
)
{
    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    KeSetEvent(CompletionEvent, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
NTAPI
KspAsyncContextWaitForCompletion(
    _In_ PKSOCKET_ASYNC_CONTEXT AsyncContext,
    _Inout_ PNTSTATUS Status
)
{
    if (*Status == STATUS_PENDING)
    {
        KeWaitForSingleObject(
            &AsyncContext->CompletionEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
        );

        *Status = AsyncContext->Irp->IoStatus.Status;
    }

    return *Status;
}

//////////////////////////////////////////////////////////////////////////
// Public functions.
//////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
KsInitialize(
    VOID
)
{
    NTSTATUS Status;

    //
    // Register as a WSK client.
    //

    WSK_CLIENT_NPI WskClient;
    WskClient.ClientContext = NULL;
    WskClient.Dispatch = &WskDispatch;

    Status = WskRegister(&WskClient, &WskRegistration);

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    //
    // Capture the provider NPI.
    //

    return WskCaptureProviderNPI(
        &WskRegistration,
        WSK_INFINITE_WAIT,
        &WskProvider
    );
}

VOID
NTAPI
KsDestroy(
    VOID
)
{
    //
    // Release the provider NPI instance.
    //

    WskReleaseProviderNPI(&WskRegistration);

    //
    // Deregister as a WSK client.
    //

    WskDeregister(&WskRegistration);
}

NTSTATUS
NTAPI
KsGetAddrInfo(
    _In_ PUNICODE_STRING NodeName,
    _In_ PUNICODE_STRING ServiceName,
    _In_ PADDRINFOEXW Hints,
    _Out_ PADDRINFOEXW* Result
)
{
    NTSTATUS Status;

    //
    // Allocate async context.
    //

    KSOCKET_ASYNC_CONTEXT AsyncContext;
    Status = KspAsyncContextAllocate(&AsyncContext);

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    //
    // Call the WSK API.
    //

    Status = WskProvider.Dispatch->WskGetAddressInfo(
        WskProvider.Client,         // Client
        NodeName,                   // NodeName
        ServiceName,                // ServiceName
        0,                          // NameSpace
        NULL,                       // Provider
        Hints,                      // Hints
        Result,                     // Result
        NULL,                       // OwningProcess
        NULL,                       // OwningThread
        AsyncContext.Irp            // Irp
    );

    KspAsyncContextWaitForCompletion(&AsyncContext, &Status);

    //
    // Free the async context.
    //

    KspAsyncContextFree(&AsyncContext);

    return Status;
}

VOID
NTAPI
KsFreeAddrInfo(
    _In_ PADDRINFOEXW AddrInfo
)
{
    WskProvider.Dispatch->WskFreeAddressInfo(
        WskProvider.Client,         // Client
        AddrInfo                    // AddrInfo
    );
}

NTSTATUS
NTAPI
KsCreateSocket(
    _Out_ PKSOCKET* Socket,
    _In_ ADDRESS_FAMILY AddressFamily,
    _In_ USHORT SocketType,
    _In_ ULONG Protocol,
    _In_ ULONG Flags
)
{
    NTSTATUS Status;

    //
    // Allocate memory for the socket structure.
    //

    PKSOCKET NewSocket = ExAllocatePoolWithTag(PagedPool, sizeof(KSOCKET), MEMORY_TAG);

    if (!NewSocket)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Allocate async context for the socket.
    //

    Status = KspAsyncContextAllocate(&NewSocket->AsyncContext);

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    //
    // Create the WSK socket.
    //

    Status = WskProvider.Dispatch->WskSocket(
        WskProvider.Client,         // Client
        AddressFamily,              // AddressFamily
        SocketType,                 // SocketType
        Protocol,                   // Protocol
        Flags,                      // Flags
        NULL,                       // SocketContext
        NULL,                       // Dispatch
        NULL,                       // OwningProcess
        NULL,                       // OwningThread
        NULL,                       // SecurityDescriptor
        NewSocket->AsyncContext.Irp // Irp
    );

    KspAsyncContextWaitForCompletion(&NewSocket->AsyncContext, &Status);

    //
    // Save the socket instance and the socket dispatch table.
    //

    if (NT_SUCCESS(Status))
    {
        NewSocket->WskSocket = (PWSK_SOCKET)NewSocket->AsyncContext.Irp->IoStatus.Information;
        NewSocket->WskDispatch = (PVOID)NewSocket->WskSocket->Dispatch;

        *Socket = NewSocket;
    }

    return Status;
}

NTSTATUS
NTAPI
KsCreateConnectionSocket(
    _Out_ PKSOCKET* Socket,
    _In_ ADDRESS_FAMILY AddressFamily,
    _In_ USHORT SocketType,
    _In_ ULONG Protocol
)
{
    return KsCreateSocket(Socket, AddressFamily, SocketType, Protocol, WSK_FLAG_CONNECTION_SOCKET);
}

NTSTATUS
NTAPI
KsCreateListenSocket(
    _Out_ PKSOCKET* Socket,
    _In_ ADDRESS_FAMILY AddressFamily,
    _In_ USHORT SocketType,
    _In_ ULONG Protocol
)
{
    return KsCreateSocket(Socket, AddressFamily, SocketType, Protocol, WSK_FLAG_LISTEN_SOCKET);
}

NTSTATUS
NTAPI
KsCreateDatagramSocket(
    _Out_ PKSOCKET* Socket,
    _In_ ADDRESS_FAMILY AddressFamily,
    _In_ USHORT SocketType,
    _In_ ULONG Protocol
)
{
    return KsCreateSocket(Socket, AddressFamily, SocketType, Protocol, WSK_FLAG_DATAGRAM_SOCKET);
}

NTSTATUS
NTAPI
KsCloseSocket(
    _In_ PKSOCKET Socket
)
{
    NTSTATUS Status;

    //
    // Reset the async context.
    //

    KspAsyncContextReset(&Socket->AsyncContext);

    //
    // Close the WSK socket.
    //

    Status = Socket->WskConnectionDispatch->WskCloseSocket(
        Socket->WskSocket,
        Socket->AsyncContext.Irp
    );

    KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

    //
    // Free the async context.
    //

    KspAsyncContextFree(&Socket->AsyncContext);

    //
    // Free memory for the socket structure.
    //

    ExFreePoolWithTag(Socket, MEMORY_TAG);

    return Status;
}

NTSTATUS
NTAPI
KsBind(
    _In_ PKSOCKET Socket,
    _In_ PSOCKADDR LocalAddress
)
{
    NTSTATUS Status;

    //
    // Reset the async context.
    //

    KspAsyncContextReset(&Socket->AsyncContext);

    //
    // Bind the socket.
    //

    Status = Socket->WskListenDispatch->WskBind(
        Socket->WskSocket,          // Socket
        LocalAddress,               // LocalAddress
        0,                          // Flags (reserved)
        Socket->AsyncContext.Irp    // Irp
    );

    KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

    return Status;
}

NTSTATUS
NTAPI
KsAccept(
    _In_ PKSOCKET Socket,
    _Out_ PKSOCKET* NewSocket,
    _Out_opt_ PSOCKADDR LocalAddress,
    _Out_opt_ PSOCKADDR RemoteAddress
)
{
    NTSTATUS Status;

    //
    // Reset the async context.
    //

    KspAsyncContextReset(&Socket->AsyncContext);

    //
    // Accept the connection.
    //

    Status = Socket->WskListenDispatch->WskAccept(
        Socket->WskSocket,          // ListenSocket
        0,                          // Flags
        NULL,                       // AcceptSocketContext
        NULL,                       // AcceptSocketDispatch
        LocalAddress,               // LocalAddress
        RemoteAddress,              // RemoteAddress
        Socket->AsyncContext.Irp    // Irp
    );

    KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

    //
    // Save the socket instance and the socket dispatch table.
    //

    if (NT_SUCCESS(Status))
    {
        PKSOCKET KNewSocket = ExAllocatePoolWithTag(PagedPool, sizeof(KSOCKET), MEMORY_TAG);

        if (!KNewSocket)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        KNewSocket->WskSocket = (PWSK_SOCKET)Socket->AsyncContext.Irp->IoStatus.Information;
        KNewSocket->WskDispatch = (PVOID)KNewSocket->WskSocket->Dispatch;
        KspAsyncContextAllocate(&KNewSocket->AsyncContext);

        *NewSocket = KNewSocket;
    }

    return Status;
}

NTSTATUS
NTAPI
KsConnect(
    _In_ PKSOCKET Socket,
    _In_ PSOCKADDR RemoteAddress
)
{
    NTSTATUS Status;

    //
    // Reset the async context.
    //

    KspAsyncContextReset(&Socket->AsyncContext);

    //
    // Bind the socket to the local address.
    //

    SOCKADDR_IN LocalAddress;
    LocalAddress.sin_family = AF_INET;
    LocalAddress.sin_addr.s_addr = INADDR_ANY;
    LocalAddress.sin_port = 0;

    Status = Socket->WskConnectionDispatch->WskBind(
        Socket->WskSocket,          // Socket
        (PSOCKADDR)&LocalAddress,   // LocalAddress
        0,                          // Flags (reserved)
        Socket->AsyncContext.Irp    // Irp
    );

    KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    //
    // Reset the async context (again).
    //

    KspAsyncContextReset(&Socket->AsyncContext);

    //
    // Connect to the remote host.
    //
    // N.B.: Instead of calling WskSocket(), WskBind() and WskConnect(),
    // it is possible to just call WskSocketConnect().
    //

    Status = Socket->WskConnectionDispatch->WskConnect(
        Socket->WskSocket,          // Socket
        RemoteAddress,              // RemoteAddress
        0,                          // Flags (reserved)
        Socket->AsyncContext.Irp    // Irp
    );

    KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

    return Status;
}

NTSTATUS
NTAPI
KsSendRecv(
    _In_ PKSOCKET Socket,
    _In_ PVOID Buffer,
    _Inout_ PULONG Length,
    _In_ ULONG Flags,
    _In_ BOOLEAN Send
)
{
    NTSTATUS Status;

    //
    // Wrap the buffer into the "WSK buffer".
    //

    WSK_BUF WskBuffer;
    WskBuffer.Offset = 0;
    WskBuffer.Length = *Length;
    WskBuffer.Mdl = IoAllocateMdl(Buffer, (ULONG)WskBuffer.Length, FALSE, FALSE, NULL);

    __try
    {
        MmProbeAndLockPages(WskBuffer.Mdl, KernelMode, IoWriteAccess);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = STATUS_ACCESS_VIOLATION;
        goto Error;
    }

    //
    // Reset the async context.
    //

    KspAsyncContextReset(&Socket->AsyncContext);

    //
    // Send / receive the data.
    //

    if (Send)
    {
        Status = Socket->WskConnectionDispatch->WskSend(
            Socket->WskSocket,        // Socket
            &WskBuffer,               // Buffer
            Flags,                    // Flags
            Socket->AsyncContext.Irp  // Irp
        );
    }
    else
    {
        Status = Socket->WskConnectionDispatch->WskReceive(
            Socket->WskSocket,        // Socket
            &WskBuffer,               // Buffer
            Flags,                    // Flags
            Socket->AsyncContext.Irp  // Irp
        );
    }

    KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

    //
    // Set the number of bytes sent / received.
    //

    if (NT_SUCCESS(Status))
    {
        *Length = (ULONG)Socket->AsyncContext.Irp->IoStatus.Information;
    }

    //
    // Free the MDL.
    //

    MmUnlockPages(WskBuffer.Mdl);

Error:
    IoFreeMdl(WskBuffer.Mdl);
    return Status;
}

NTSTATUS
NTAPI
KsSendRecvUdp(
    _In_ PKSOCKET Socket,
    _In_ PVOID Buffer,
    _Inout_ PULONG Length,
    _In_ ULONG Flags,
    _In_ PSOCKADDR RemoteAddress,
    _In_ BOOLEAN Send
)
{
    NTSTATUS Status;

    //
    // Wrap the buffer into the "WSK buffer".
    //

    WSK_BUF WskBuffer;
    WskBuffer.Offset = 0;
    WskBuffer.Length = *Length;
    WskBuffer.Mdl = IoAllocateMdl(Buffer, (ULONG)WskBuffer.Length, FALSE, FALSE, NULL);

    __try
    {
        MmProbeAndLockPages(WskBuffer.Mdl, KernelMode, IoWriteAccess);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = STATUS_ACCESS_VIOLATION;
        goto Error;
    }

    //
    // Reset the async context.
    //

    KspAsyncContextReset(&Socket->AsyncContext);

    //
    // Send / receive the data.
    //

    if (Send)
    {
        Status = Socket->WskDatagramDispatch->WskSendTo(
            Socket->WskSocket,        // Socket
            &WskBuffer,               // Buffer
            Flags,                    // Flags (reserved)
            RemoteAddress,            // RemoteAddress
            0,                        // ControlInfoLength
            NULL,                     // ControlInfo
            Socket->AsyncContext.Irp  // Irp
        );
    }
    else
    {
        //
        // Use #pragma prefast (suppress: ...), because SAL annotation is wrong
        // for this function.
        //
        // From MSDN:
        //   ControlLength
        //   ControlInfo
        //
        //   ... This pointer is optional and can be NULL.  If the ControlInfoLength
        //   parameter is NULL, the ControlInfo parameter should be NULL.
        //

#pragma prefast (                                                                           \
    suppress:__WARNING_INVALID_PARAM_VALUE_1,                                               \
    "If the ControlInfoLength parameter is NULL, the ControlInfo parameter should be NULL." \
    )

        Status = Socket->WskDatagramDispatch->WskReceiveFrom(
            Socket->WskSocket,        // Socket
            &WskBuffer,               // Buffer
            Flags,                    // Flags (reserved)
            RemoteAddress,            // RemoteAddress
            NULL,                     // ControlInfoLength
            NULL,                     // ControlInfo
            NULL,                     // ControlFlags
            Socket->AsyncContext.Irp  // Irp
        );
    }

    KspAsyncContextWaitForCompletion(&Socket->AsyncContext, &Status);

    //
    // Set the number of bytes sent / received.
    //

    if (NT_SUCCESS(Status))
    {
        *Length = (ULONG)Socket->AsyncContext.Irp->IoStatus.Information;
    }

    //
    // Free the MDL.
    //

    MmUnlockPages(WskBuffer.Mdl);

Error:
    IoFreeMdl(WskBuffer.Mdl);
    return Status;
}

NTSTATUS
NTAPI
KsSend(
    _In_ PKSOCKET Socket,
    _In_ PVOID Buffer,
    _Inout_ PULONG Length,
    _In_ ULONG Flags
)
{
    return KsSendRecv(Socket, Buffer, Length, Flags, TRUE);
}

NTSTATUS
NTAPI
KsRecv(
    _In_ PKSOCKET Socket,
    _In_ PVOID Buffer,
    _Inout_ PULONG Length,
    _In_ ULONG Flags
)
{
    return KsSendRecv(Socket, Buffer, Length, Flags, FALSE);
}

NTSTATUS
NTAPI
KsSendTo(
    _In_ PKSOCKET Socket,
    _In_ PVOID Buffer,
    _Inout_ PULONG Length,
    _In_ ULONG Flags,
    _In_ PSOCKADDR RemoteAddress
)
{
    return KsSendRecvUdp(Socket, Buffer, Length, Flags, RemoteAddress, TRUE);
}

NTSTATUS
NTAPI
KsRecvFrom(
    _In_ PKSOCKET Socket,
    _In_ PVOID Buffer,
    _Inout_ PULONG Length,
    _In_ ULONG Flags,
    _In_ PSOCKADDR RemoteAddress
)
{
    return KsSendRecvUdp(Socket, Buffer, Length, Flags, RemoteAddress, FALSE);
}
```

`EFT Kernel/socket-km/ksocket/ksocket.h`:

```h
#pragma once
#include <ntddk.h>
#include <wsk.h>



    typedef struct _KSOCKET KSOCKET, * PKSOCKET;

    NTSTATUS
        NTAPI
        KsInitialize(
            VOID
        );

    VOID
        NTAPI
        KsDestroy(
            VOID
        );

    NTSTATUS
        NTAPI
        KsGetAddrInfo(
            _In_ PUNICODE_STRING NodeName,
            _In_ PUNICODE_STRING ServiceName,
            _In_ PADDRINFOEXW Hints,
            _Out_ PADDRINFOEXW* Result
        );

    VOID
        NTAPI
        KsFreeAddrInfo(
            _In_ PADDRINFOEXW AddrInfo
        );

    NTSTATUS
        NTAPI
        KsCreateSocket(
            _Out_ PKSOCKET* Socket,
            _In_ ADDRESS_FAMILY AddressFamily,
            _In_ USHORT SocketType,
            _In_ ULONG Protocol,
            _In_ ULONG Flags
        );

    NTSTATUS
        NTAPI
        KsCreateConnectionSocket(
            _Out_ PKSOCKET* Socket,
            _In_ ADDRESS_FAMILY AddressFamily,
            _In_ USHORT SocketType,
            _In_ ULONG Protocol
        );

    NTSTATUS
        NTAPI
        KsCreateListenSocket(
            _Out_ PKSOCKET* Socket,
            _In_ ADDRESS_FAMILY AddressFamily,
            _In_ USHORT SocketType,
            _In_ ULONG Protocol
        );

    NTSTATUS
        NTAPI
        KsCreateDatagramSocket(
            _Out_ PKSOCKET* Socket,
            _In_ ADDRESS_FAMILY AddressFamily,
            _In_ USHORT SocketType,
            _In_ ULONG Protocol
        );

    NTSTATUS
        NTAPI
        KsCloseSocket(
            _In_ PKSOCKET Socket
        );

    NTSTATUS
        NTAPI
        KsBind(
            _In_ PKSOCKET Socket,
            _In_ PSOCKADDR LocalAddress
        );

    NTSTATUS
        NTAPI
        KsAccept(
            _In_ PKSOCKET Socket,
            _Out_ PKSOCKET* NewSocket,
            _Out_opt_ PSOCKADDR LocalAddress,
            _Out_opt_ PSOCKADDR RemoteAddress
        );

    NTSTATUS
        NTAPI
        KsConnect(
            _In_ PKSOCKET Socket,
            _In_ PSOCKADDR RemoteAddress
        );

    NTSTATUS
        NTAPI
        KsSendRecv(
            _In_ PKSOCKET Socket,
            _In_ PVOID Buffer,
            _Inout_ PULONG Length,
            _In_ ULONG Flags,
            _In_ BOOLEAN Send
        );

    NTSTATUS
        NTAPI
        KsSendRecvUdp(
            _In_ PKSOCKET Socket,
            _In_ PVOID Buffer,
            _Inout_ PULONG Length,
            _In_ ULONG Flags,
            _In_ PSOCKADDR RemoteAddress,
            _In_ BOOLEAN Send
        );

    NTSTATUS
        NTAPI
        KsSend(
            _In_ PKSOCKET Socket,
            _In_ PVOID Buffer,
            _Inout_ PULONG Length,
            _In_ ULONG Flags
        );

    NTSTATUS
        NTAPI
        KsRecv(
            _In_ PKSOCKET Socket,
            _In_ PVOID Buffer,
            _Inout_ PULONG Length,
            _In_ ULONG Flags
        );

    NTSTATUS
        NTAPI
        KsSendTo(
            _In_ PKSOCKET Socket,
            _In_ PVOID Buffer,
            _Inout_ PULONG Length,
            _In_ ULONG Flags,
            _In_ PSOCKADDR RemoteAddress
        );

    NTSTATUS
        NTAPI
        KsRecvFrom(
            _In_ PKSOCKET Socket,
            _In_ PVOID Buffer,
            _Inout_ PULONG Length,
            _In_ ULONG Flags,
            _In_ PSOCKADDR RemoteAddress
        );


```

`EFT Kernel/socket-km/log.h`:

```h
#pragma once
#include <ntddk.h>

template <typename... Args>
void log(const char* format, Args... args)
{
	DbgPrintEx(0, 0, format, args...);
}
```

`EFT Kernel/socket-km/main.cpp`:

```cpp
#include "clean.hpp"
#include "log.h"


extern void NTAPI initiliaze_sys(void*);

extern "C" NTSTATUS DriverEntry(
	PDRIVER_OBJECT  driver_object,
	PUNICODE_STRING registry_path
)
{
	KeEnterGuardedRegion();

	UNREFERENCED_PARAMETER(driver_object);
	UNREFERENCED_PARAMETER(registry_path);

	UNICODE_STRING driver_int = RTL_CONSTANT_STRING(L"iqvw64e.sys");//iqvw64e.sys 0x5284EAC3 (timeDateStamp)

	clear::clearCache(driver_int, 0x5284EAC3);

	FindMmDriverData();


	PWORK_QUEUE_ITEM WorkItem = (PWORK_QUEUE_ITEM)ExAllocatePool(NonPagedPool, sizeof(WORK_QUEUE_ITEM));

	ExInitializeWorkItem(WorkItem, initiliaze_sys, WorkItem);

	ExQueueWorkItem(WorkItem, DelayedWorkQueue);

	if (clear::ClearUnloadedDriver(&driver_int, true) == STATUS_SUCCESS)
	{
		log("dr int cleared");
	}
	else {
		log("dr int not found");
	}

	KeLeaveGuardedRegion();

	return STATUS_SUCCESS;
}
```

`EFT Kernel/socket-km/packet_handler.cpp`:

```cpp
#include "ntifs.h"
#include "server_shared.h"
#include "sockets.h"
#include "imports.h"
#include "log.h"


uint64_t RDrvGetModuleEntry(PEPROCESS Process, UNICODE_STRING
	module_name)
{
	if (!Process) return STATUS_INVALID_PARAMETER_1;
	PPEB peb = PsGetProcessPeb(Process);

	if (!peb) {
		DbgPrintEx(0, 0, "Error pPeb not found \n");
		return 0;
	}
	KAPC_STATE state;
	KeStackAttachProcess(Process, &state);
	PPEB_LDR_DATA ldr = peb->Ldr;

	if (!ldr) 
	{
		DbgPrintEx(0, 0, "Error pLdr not found \n");
		KeUnstackDetachProcess(&state);
		return 0; // failed
	}

	for (PLIST_ENTRY listEntry = (PLIST_ENTRY)ldr->ModuleListLoadOrder.Flink;
		listEntry != &ldr->ModuleListLoadOrder;
		listEntry = (PLIST_ENTRY)listEntry->Flink)
	{

		PLDR_DATA_TABLE_ENTRY ldrEntry = CONTAINING_RECORD(listEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderModuleList);
		if (RtlCompareUnicodeString(&ldrEntry->BaseDllName, &module_name, TRUE) ==
			0) {
			ULONG64 baseAddr = (ULONG64)ldrEntry->DllBase;
			KeUnstackDetachProcess(&state);
			return baseAddr;
		}

	}

	DbgPrintEx(0, 0, "Error exiting funcion nothing was found found \n");
	KeUnstackDetachProcess(&state);

	return 0;
}


static uint64_t handle_copy_memory(const PacketCopyMemory& packet)
{
	PEPROCESS dest_process = nullptr;
	PEPROCESS src_process = nullptr;

	if (!NT_SUCCESS(PsLookupProcessByProcessId(HANDLE(packet.dest_process_id), &dest_process)))
	{
		return uint64_t(STATUS_INVALID_CID);
	}

	if (!NT_SUCCESS(PsLookupProcessByProcessId(HANDLE(packet.src_process_id), &src_process)))
	{
		ObDereferenceObject(dest_process);
		return uint64_t(STATUS_INVALID_CID);
	}


	SIZE_T   return_size = 0;
	NTSTATUS status = MmCopyVirtualMemory(
		src_process,
		(void*)packet.src_address,
		dest_process,
		(void*)packet.dest_address,
		packet.size,
		UserMode,
		&return_size
	);


	ObDereferenceObject(dest_process);
	ObDereferenceObject(src_process);

	return uint64_t(status);
}

static uint64_t handle_get_base_address(const PacketGetBaseAddress& packet)
{
	PEPROCESS process = nullptr;
	NTSTATUS  status = PsLookupProcessByProcessId(HANDLE(packet.process_id), &process);

	if (!NT_SUCCESS(status))
		return 0;

	const auto base_address = uint64_t(PsGetProcessSectionBaseAddress(process));
	ObDereferenceObject(process);

	return base_address;
}

static uint64_t handle_get_peb(const PacketGetBasePeb& packet)
{
	PEPROCESS process = nullptr;
	NTSTATUS  status = PsLookupProcessByProcessId(HANDLE(packet.process_id), &process);

	if (!NT_SUCCESS(status))
		return false;

	UNICODE_STRING DLLName;
	RtlInitUnicodeString(&DLLName, L"UnityPlayer.dll");
	const auto base_address = RDrvGetModuleEntry(process, DLLName);

	ObDereferenceObject(process);

	return base_address;
}

// Send completion packet.
bool complete_request(const SOCKET client_connection, const uint64_t result)
{
	Packet packet{ };

	packet.header.magic = packet_magic;
	packet.header.type = PacketType::packet_completed;
	packet.data.completed.result = result;

	return send(client_connection, &packet, sizeof(packet), 0) != SOCKET_ERROR;
}

static uintptr_t get_kernel_address(const char* name, size_t& size) {
	NTSTATUS status = STATUS_SUCCESS;
	ULONG neededSize = 0;

	ZwQuerySystemInformation(
		SystemModuleInformation,
		&neededSize,
		0,
		&neededSize
	);

	PSYSTEM_MODULE_INFORMATION pModuleList;

	pModuleList = (PSYSTEM_MODULE_INFORMATION)ExAllocatePool(NonPagedPool, neededSize);

	if (!pModuleList) {
		log("ExAllocatePoolWithTag failed(kernel addr)\n");
		return 0;
	}

	status = ZwQuerySystemInformation(SystemModuleInformation,
		pModuleList,
		neededSize,
		0
	);

	ULONG i = 0;
	uintptr_t address = 0;

	for (i = 0; i < pModuleList->ulModuleCount; i++)
	{
		SYSTEM_MODULE mod = pModuleList->Modules[i];

		address = uintptr_t(pModuleList->Modules[i].Base);
		size = uintptr_t(pModuleList->Modules[i].Size);
		if (strstr(mod.ImageName, name) != NULL)
			break;
	}

	ExFreePool(pModuleList);

	return address;
}

uint64_t handle_incoming_packet(const Packet& packet)
{
	switch (packet.header.type)
	{
	case PacketType::packet_copy_memory:
		return handle_copy_memory(packet.data.copy_memory);

	case PacketType::packet_get_base_address:
		return handle_get_base_address(packet.data.get_base_address);

	case PacketType::packet_get_peb:
		return handle_get_peb(packet.data.get_base_peb);

	default:
		break;
	}

	return uint64_t(STATUS_NOT_IMPLEMENTED);
}

```

`EFT Kernel/socket-km/server.cpp`:

```cpp
#include "server_shared.h"
#include "sockets.h"
#include "log.h"

extern uint64_t handle_incoming_packet(const Packet& packet);
extern bool		complete_request(SOCKET client_connection, uint64_t result);

static SOCKET create_listen_socket()
{
	SOCKADDR_IN address{ };

	address.sin_family	= AF_INET;
	address.sin_port	= htons(server_port);

	const auto listen_socket = socket_listen(AF_INET, SOCK_STREAM, 0);
	if (listen_socket == INVALID_SOCKET)
	{
		log("Failed to create listen socket.");
		return INVALID_SOCKET;
	}

	if (bind(listen_socket, (SOCKADDR*)&address, sizeof(address)) == SOCKET_ERROR)
	{
		log("Failed to bind socket.");

		closesocket(listen_socket);
		return INVALID_SOCKET;
	}

	if (listen(listen_socket, 10) == SOCKET_ERROR)
	{
		log("Failed to set socket mode to listening.");

		closesocket(listen_socket);
		return INVALID_SOCKET;
	}

	return listen_socket;
}

// Connection handling thread.
static void NTAPI connection_thread(void* connection_socket)
{
	const auto client_connection = SOCKET(ULONG_PTR(connection_socket));
	log("New connection.");

	Packet packet{ };
	while (true)
	{
		const auto result = recv(client_connection, (void*)&packet, sizeof(packet), 0);
		if (result <= 0)
			break;

		if (result < sizeof(PacketHeader))
			continue;

		if (packet.header.magic != packet_magic)
			continue;

		const auto packet_result = handle_incoming_packet(packet);
		if (!complete_request(client_connection, packet_result))
			break;
	}

	log("Connection closed.");
	closesocket(client_connection);
}

// Main server thread.
void NTAPI initiliaze_sys(void*)
{
	auto status = KsInitialize();
	if (!NT_SUCCESS(status))
	{
		log("Failed to initialize KSOCKET. Status code: %X.", status);
		return;
	}

	const auto listen_socket = create_listen_socket();
	if (listen_socket == INVALID_SOCKET)
	{
		log("Failed to initialize listening socket.");

		KsDestroy();
		return;
	}

	log("Listening on port %d.", server_port);

	while (true)
	{
		sockaddr  socket_addr{ };
		socklen_t socket_length{ };

		const auto client_connection = accept(listen_socket, &socket_addr, &socket_length);
		if (client_connection == INVALID_SOCKET)
		{
			log("Failed to accept client connection.");
			break;
		}

		PWORK_QUEUE_ITEM WorkItem = (PWORK_QUEUE_ITEM)ExAllocatePool(NonPagedPool, sizeof(WORK_QUEUE_ITEM));

		ExInitializeWorkItem(WorkItem, connection_thread, (void*)client_connection);

		ExQueueWorkItem(WorkItem, DelayedWorkQueue);
	}

	closesocket(listen_socket);
}
```

`EFT Kernel/socket-km/server_shared.h`:

```h
#pragma once
#include "stdint.h"
#include <ntdef.h>

constexpr auto packet_magic = 0x12345568;
constexpr auto server_ip = 0x7F000001; // 127.0.0.1
constexpr auto server_port = 28125;

enum class PacketType
{
	packet_copy_memory,
	packet_get_base_address,
	packet_get_peb,
	packet_completed
};

struct PacketCopyMemory
{
	uint32_t dest_process_id;
	uint64_t dest_address;

	uint32_t src_process_id;
	uint64_t src_address;

	uint32_t size;
};

struct PacketGetBaseAddress
{
	uint32_t process_id;
};

struct PacketGetBasePeb
{
	uint32_t process_id;
};

struct PackedCompleted
{
	uint64_t result;
};

struct PacketHeader
{
	uint32_t   magic;
	PacketType type;
};

struct Packet
{
	PacketHeader header;
	union
	{
		PacketCopyMemory	 copy_memory;
		PacketGetBaseAddress get_base_address;
		PacketGetBasePeb get_base_peb;
		PackedCompleted		 completed;
	} data;
};

```

`EFT Kernel/socket-km/socket-km.inf`:

```inf
;
; socket-km.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=socket-km.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
socket-km_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
socket-km.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%socket-km.DeviceDesc%=socket-km_Device, Root\socket-km ; TODO: edit hw-id

[socket-km_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
socket-km.sys

;-------------- Service installation
[socket-km_Device.NT.Services]
AddService = socket-km,%SPSVCINST_ASSOCSERVICE%, socket-km_Service_Inst

; -------------- socket-km driver install sections
[socket-km_Service_Inst]
DisplayName    = %socket-km.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\socket-km.sys

;
;--- socket-km_Device Coinstaller installation ------
;

[socket-km_Device.NT.CoInstallers]
AddReg=socket-km_Device_CoInstaller_AddReg
CopyFiles=socket-km_Device_CoInstaller_CopyFiles

[socket-km_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[socket-km_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[socket-km_Device.NT.Wdf]
KmdfService =  socket-km, socket-km_wdfsect
[socket-km_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "socket-km Installation Disk"
socket-km.DeviceDesc = "socket-km Device"
socket-km.SVCDESC = "socket-km Service"

```

`EFT Kernel/socket-km/socket-km.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{1BB91B25-67A5-4CB7-8379-DF7C886CE06A}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>socket_km</RootNamespace>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <TreatWarningAsError>false</TreatWarningAsError>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <AdditionalDependencies>Netio.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ksocket\berkeley.c" />
    <ClCompile Include="ksocket\ksocket.c" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="packet_handler.cpp" />
    <ClCompile Include="server.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="clean.hpp" />
    <ClInclude Include="imports.h" />
    <ClInclude Include="ksocket\berkeley.h" />
    <ClInclude Include="ksocket\ksocket.h" />
    <ClInclude Include="log.h" />
    <ClInclude Include="server_shared.h" />
    <ClInclude Include="sockets.h" />
    <ClInclude Include="stdint.h" />
    <ClInclude Include="struct.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EFT Kernel/socket-km/socket-km.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="server.cpp" />
    <ClCompile Include="ksocket\berkeley.c" />
    <ClCompile Include="ksocket\ksocket.c" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="packet_handler.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="server_shared.h" />
    <ClInclude Include="sockets.h" />
    <ClInclude Include="stdint.h" />
    <ClInclude Include="ksocket\berkeley.h" />
    <ClInclude Include="ksocket\ksocket.h" />
    <ClInclude Include="imports.h" />
    <ClInclude Include="log.h" />
    <ClInclude Include="clean.hpp">
      <Filter>Cleaner</Filter>
    </ClInclude>
    <ClInclude Include="struct.h">
      <Filter>Cleaner</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Cleaner">
      <UniqueIdentifier>{61504a04-a09b-4632-a752-9eef98809979}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
</Project>
```

`EFT Kernel/socket-km/sockets.h`:

```h
#pragma once

extern "C"
{
	#include "ksocket/ksocket.h"
	#include "ksocket/berkeley.h"
}

typedef int SOCKET;

#define INVALID_SOCKET  (SOCKET)(-1)
#define SOCKET_ERROR            (-1)
```

`EFT Kernel/socket-km/stdint.h`:

```h
#pragma once

typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;
```

`EFT Kernel/socket-km/struct.h`:

```h
#pragma once
#include <ntdef.h>
#include <ntifs.h>
#include <ntddk.h>
#include <ntimage.h>
#include <ntstrsafe.h>

typedef unsigned char       BYTE;
typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;         // Not filled in
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[MAXIMUM_FILENAME_LENGTH];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;
typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;
struct PiDDBCacheEntry
{
	LIST_ENTRY		List;
	UNICODE_STRING	DriverName;
	ULONG			TimeDateStamp;
	NTSTATUS		LoadStatus;
	char			_0x0028[16]; // data from the shim engine, or uninitialized memory for custom drivers
};
typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation = 0x0,
	SystemProcessorInformation = 0x1,
	SystemPerformanceInformation = 0x2,
	SystemTimeOfDayInformation = 0x3,
	SystemPathInformation = 0x4,
	SystemProcessInformation = 0x5,
	SystemCallCountInformation = 0x6,
	SystemDeviceInformation = 0x7,
	SystemProcessorPerformanceInformation = 0x8,
	SystemFlagsInformation = 0x9,
	SystemCallTimeInformation = 0xa,
	SystemModuleInformation = 0xb,
	SystemLocksInformation = 0xc,
	SystemStackTraceInformation = 0xd,
	SystemPagedPoolInformation = 0xe,
	SystemNonPagedPoolInformation = 0xf,
	SystemHandleInformation = 0x10,
	SystemObjectInformation = 0x11,
	SystemPageFileInformation = 0x12,
	SystemVdmInstemulInformation = 0x13,
	SystemVdmBopInformation = 0x14,
	SystemFileCacheInformation = 0x15,
	SystemPoolTagInformation = 0x16,
	SystemInterruptInformation = 0x17,
	SystemDpcBehaviorInformation = 0x18,
	SystemFullMemoryInformation = 0x19,
	SystemLoadGdiDriverInformation = 0x1a,
	SystemUnloadGdiDriverInformation = 0x1b,
	SystemTimeAdjustmentInformation = 0x1c,
	SystemSummaryMemoryInformation = 0x1d,
	SystemMirrorMemoryInformation = 0x1e,
	SystemPerformanceTraceInformation = 0x1f,
	SystemObsolete0 = 0x20,
	SystemExceptionInformation = 0x21,
	SystemCrashDumpStateInformation = 0x22,
	SystemKernelDebuggerInformation = 0x23,
	SystemContextSwitchInformation = 0x24,
	SystemRegistryQuotaInformation = 0x25,
	SystemExtendServiceTableInformation = 0x26,
	SystemPrioritySeperation = 0x27,
	SystemVerifierAddDriverInformation = 0x28,
	SystemVerifierRemoveDriverInformation = 0x29,
	SystemProcessorIdleInformation = 0x2a,
	SystemLegacyDriverInformation = 0x2b,
	SystemCurrentTimeZoneInformation = 0x2c,
	SystemLookasideInformation = 0x2d,
	SystemTimeSlipNotification = 0x2e,
	SystemSessionCreate = 0x2f,
	SystemSessionDetach = 0x30,
	SystemSessionInformation = 0x31,
	SystemRangeStartInformation = 0x32,
	SystemVerifierInformation = 0x33,
	SystemVerifierThunkExtend = 0x34,
	SystemSessionProcessInformation = 0x35,
	SystemLoadGdiDriverInSystemSpace = 0x36,
	SystemNumaProcessorMap = 0x37,
	SystemPrefetcherInformation = 0x38,
	SystemExtendedProcessInformation = 0x39,
	SystemRecommendedSharedDataAlignment = 0x3a,
	SystemComPlusPackage = 0x3b,
	SystemNumaAvailableMemory = 0x3c,
	SystemProcessorPowerInformation = 0x3d,
	SystemEmulationBasicInformation = 0x3e,
	SystemEmulationProcessorInformation = 0x3f,
	SystemExtendedHandleInformation = 0x40,
	SystemLostDelayedWriteInformation = 0x41,
	SystemBigPoolInformation = 0x42,
	SystemSessionPoolTagInformation = 0x43,
	SystemSessionMappedViewInformation = 0x44,
	SystemHotpatchInformation = 0x45,
	SystemObjectSecurityMode = 0x46,
	SystemWatchdogTimerHandler = 0x47,
	SystemWatchdogTimerInformation = 0x48,
	SystemLogicalProcessorInformation = 0x49,
	SystemWow64SharedInformationObsolete = 0x4a,
	SystemRegisterFirmwareTableInformationHandler = 0x4b,
	SystemFirmwareTableInformation = 0x4c,
	SystemModuleInformationEx = 0x4d,
	SystemVerifierTriageInformation = 0x4e,
	SystemSuperfetchInformation = 0x4f,
	SystemMemoryListInformation = 0x50,
	SystemFileCacheInformationEx = 0x51,
	SystemThreadPriorityClientIdInformation = 0x52,
	SystemProcessorIdleCycleTimeInformation = 0x53,
	SystemVerifierCancellationInformation = 0x54,
	SystemProcessorPowerInformationEx = 0x55,
	SystemRefTraceInformation = 0x56,
	SystemSpecialPoolInformation = 0x57,
	SystemProcessIdInformation = 0x58,
	SystemErrorPortInformation = 0x59,
	SystemBootEnvironmentInformation = 0x5a,
	SystemHypervisorInformation = 0x5b,
	SystemVerifierInformationEx = 0x5c,
	SystemTimeZoneInformation = 0x5d,
	SystemImageFileExecutionOptionsInformation = 0x5e,
	SystemCoverageInformation = 0x5f,
	SystemPrefetchPatchInformation = 0x60,
	SystemVerifierFaultsInformation = 0x61,
	SystemSystemPartitionInformation = 0x62,
	SystemSystemDiskInformation = 0x63,
	SystemProcessorPerformanceDistribution = 0x64,
	SystemNumaProximityNodeInformation = 0x65,
	SystemDynamicTimeZoneInformation = 0x66,
	SystemCodeIntegrityInformation = 0x67,
	SystemProcessorMicrocodeUpdateInformation = 0x68,
	SystemProcessorBrandString = 0x69,
	SystemVirtualAddressInformation = 0x6a,
	SystemLogicalProcessorAndGroupInformation = 0x6b,
	SystemProcessorCycleTimeInformation = 0x6c,
	SystemStoreInformation = 0x6d,
	SystemRegistryAppendString = 0x6e,
	SystemAitSamplingValue = 0x6f,
	SystemVhdBootInformation = 0x70,
	SystemCpuQuotaInformation = 0x71,
	SystemNativeBasicInformation = 0x72,
	SystemErrorPortTimeouts = 0x73,
	SystemLowPriorityIoInformation = 0x74,
	SystemBootEntropyInformation = 0x75,
	SystemVerifierCountersInformation = 0x76,
	SystemPagedPoolInformationEx = 0x77,
	SystemSystemPtesInformationEx = 0x78,
	SystemNodeDistanceInformation = 0x79,
	SystemAcpiAuditInformation = 0x7a,
	SystemBasicPerformanceInformation = 0x7b,
	SystemQueryPerformanceCounterInformation = 0x7c,
	SystemSessionBigPoolInformation = 0x7d,
	SystemBootGraphicsInformation = 0x7e,
	SystemScrubPhysicalMemoryInformation = 0x7f,
	SystemBadPageInformation = 0x80,
	SystemProcessorProfileControlArea = 0x81,
	SystemCombinePhysicalMemoryInformation = 0x82,
	SystemEntropyInterruptTimingInformation = 0x83,
	SystemConsoleInformation = 0x84,
	SystemPlatformBinaryInformation = 0x85,
	SystemThrottleNotificationInformation = 0x86,
	SystemHypervisorProcessorCountInformation = 0x87,
	SystemDeviceDataInformation = 0x88,
	SystemDeviceDataEnumerationInformation = 0x89,
	SystemMemoryTopologyInformation = 0x8a,
	SystemMemoryChannelInformation = 0x8b,
	SystemBootLogoInformation = 0x8c,
	SystemProcessorPerformanceInformationEx = 0x8d,
	SystemSpare0 = 0x8e,
	SystemSecureBootPolicyInformation = 0x8f,
	SystemPageFileInformationEx = 0x90,
	SystemSecureBootInformation = 0x91,
	SystemEntropyInterruptTimingRawInformation = 0x92,
	SystemPortableWorkspaceEfiLauncherInformation = 0x93,
	SystemFullProcessInformation = 0x94,
	SystemKernelDebuggerInformationEx = 0x95,
	SystemBootMetadataInformation = 0x96,
	SystemSoftRebootInformation = 0x97,
	SystemElamCertificateInformation = 0x98,
	SystemOfflineDumpConfigInformation = 0x99,
	SystemProcessorFeaturesInformation = 0x9a,
	SystemRegistryReconciliationInformation = 0x9b,
	MaxSystemInfoClass = 0x9c,
} SYSTEM_INFORMATION_CLASS;

EXTERN_C NTSYSAPI
PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(
	IN PVOID   ModuleAddress);
EXTERN_C NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySystemInformation(
	IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
	OUT PVOID SystemInformation,
	IN ULONG SystemInformationLength,
	OUT PULONG ReturnLength OPTIONAL
);

#define MM_UNLOADED_DRIVERS_SIZE 50
typedef struct _MM_UNLOADED_DRIVER
{
	UNICODE_STRING 	Name;
	PVOID 			ModuleStart;
	PVOID 			ModuleEnd;
	ULONG64 		UnloadTime;
} MM_UNLOADED_DRIVER, * PMM_UNLOADED_DRIVER;

```

`EFT Usermode/MemoryOperationSample.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.27004.2002
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MemoryOperationSample", "MemoryOperationSample\MemoryOperationSample.vcxproj", "{68DB5666-C323-4D77-AE31-26F4805AB4AB}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{68DB5666-C323-4D77-AE31-26F4805AB4AB}.Debug|x64.ActiveCfg = Debug|x64
		{68DB5666-C323-4D77-AE31-26F4805AB4AB}.Debug|x64.Build.0 = Debug|x64
		{68DB5666-C323-4D77-AE31-26F4805AB4AB}.Debug|x86.ActiveCfg = Debug|Win32
		{68DB5666-C323-4D77-AE31-26F4805AB4AB}.Debug|x86.Build.0 = Debug|Win32
		{68DB5666-C323-4D77-AE31-26F4805AB4AB}.Release|x64.ActiveCfg = Release|x64
		{68DB5666-C323-4D77-AE31-26F4805AB4AB}.Release|x64.Build.0 = Release|x64
		{68DB5666-C323-4D77-AE31-26F4805AB4AB}.Release|x86.ActiveCfg = Release|Win32
		{68DB5666-C323-4D77-AE31-26F4805AB4AB}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {180B7CD0-21E9-43C1-80FD-6F9D004773C9}
	EndGlobalSection
EndGlobal

```

`EFT Usermode/MemoryOperationSample/MemoryOperationSample.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{68DB5666-C323-4D77-AE31-26F4805AB4AB}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>MemoryOperationSample</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Include;$(IncludePath)</IncludePath>
    <LibraryPath>C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x64;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalDependencies>d3d9.lib;d3dx9.lib;dwmapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="eftstructs.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="math.cpp" />
    <ClCompile Include="Overlay.cpp" />
    <ClCompile Include="PMemHelper.cpp" />
    <ClCompile Include="visuals.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="eftstructs.h" />
    <ClInclude Include="math.hpp" />
    <ClInclude Include="Overlay.h" />
    <ClInclude Include="PMemHelper.h" />
    <ClInclude Include="server_shared.h" />
    <ClInclude Include="visuals.h" />
    <ClInclude Include="xorstr.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EFT Usermode/MemoryOperationSample/MemoryOperationSample.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\Utils">
      <UniqueIdentifier>{9c77498e-670e-4579-b2e5-47c1a7ff1504}</UniqueIdentifier>
    </Filter>
    <Filter Include="Header Files\driverload">
      <UniqueIdentifier>{165339dc-b7dd-45e7-a8c9-055db160845f}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PMemHelper.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Overlay.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="math.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="visuals.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="eftstructs.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="PMemHelper.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Overlay.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="xorstr.hpp">
      <Filter>Header Files\Utils</Filter>
    </ClInclude>
    <ClInclude Include="math.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="server_shared.h">
      <Filter>Header Files\driverload</Filter>
    </ClInclude>
    <ClInclude Include="visuals.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="eftstructs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`EFT Usermode/MemoryOperationSample/MemoryOperationSample.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`EFT Usermode/MemoryOperationSample/Overlay.cpp`:

```cpp
#include "overlay.h"
#include <string>
#include <cstdarg>
#include <d3dtypes.h>
#include <time.h>       /* clock_t, clock, CLOCKS_PER_SEC */
#include <vector>


//defining data
int s_width = 1920;
int s_height = 1080;
LPDIRECT3D9 d3d;
LPDIRECT3DDEVICE9 d3ddev;
LPDIRECT3DVERTEXBUFFER9 g_pVB;
HWND hWnd;
HWND twnd;
MARGINS  margin = { 0,0,s_width,s_height };
LPD3DXFONT pFont;
LPD3DXFONT pFont2;
ID3DXLine* d3dLine;


//ESP stuff
void initD3D(HWND hWnd)
{
	d3d = Direct3DCreate9(D3D_SDK_VERSION);    // create the Direct3D interface

	D3DPRESENT_PARAMETERS d3dpp;    // create a struct to hold various device information

	ZeroMemory(&d3dpp, sizeof(d3dpp));    // clear out the struct for use
	d3dpp.Windowed = TRUE;    // program windowed, not fullscreen
	d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;    // discard old frames
	d3dpp.hDeviceWindow = hWnd;    // set the window to be used by Direct3D
	d3dpp.BackBufferFormat = D3DFMT_A8R8G8B8;     // set the back buffer format to 32-bit
	d3dpp.BackBufferWidth = s_width;    // set the width of the buffer
	d3dpp.BackBufferHeight = s_height;    // set the height of the buffer

	d3dpp.EnableAutoDepthStencil = TRUE;
	d3dpp.AutoDepthStencilFormat = D3DFMT_D16;

	// create a device class using this information and the info from the d3dpp stuct
	d3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hWnd, D3DCREATE_SOFTWARE_VERTEXPROCESSING, &d3dpp, &d3ddev);

	D3DXCreateFontA(d3ddev, 12, 0, FW_MEDIUM, 1, 0, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, ANTIALIASED_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "Purista-light", &pFont);
	D3DXCreateFontA(d3ddev, 15, 0, FW_MEDIUM, 1, 0, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, ANTIALIASED_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "icomoon", &pFont2);
	D3DXCreateLine(d3ddev, &d3dLine);
}


void draw_line(float x, float y, float xx, float yy, D3DCOLOR color)
{
	D3DXVECTOR2 dLine[2];

	d3dLine->SetWidth(1.f);

	dLine[0].x = x;
	dLine[0].y = y;

	dLine[1].x = xx;
	dLine[1].y = yy;

	d3dLine->Draw(dLine, 2, color);

}



void DrawLine2(float x1, float y1, float x2, float y2, float size, bool antiAlias, D3DCOLOR COLOR)
{
	D3DXVECTOR2 dLine[2];

	d3dLine->SetWidth(size);

	dLine[1] = { x1, y1 };
	dLine[0] = { x2, y2 };

	if (antiAlias)
		d3dLine->SetAntialias(1);
	else
		d3dLine->SetAntialias(0);

	d3dLine->Begin();
	d3dLine->Draw(dLine, 2, COLOR);
	d3dLine->End();
}

void draw_box(float x, float y, float width, float height, D3DCOLOR color)
{
	D3DXVECTOR2 points[5];
	points[0] = D3DXVECTOR2(x, y);
	points[1] = D3DXVECTOR2(x + width, y);
	points[2] = D3DXVECTOR2(x + width, y + height);
	points[3] = D3DXVECTOR2(x, y + height);
	points[4] = D3DXVECTOR2(x, y);
	d3dLine->SetWidth(1);
	d3dLine->Draw(points, 5, color);
}


void String(int x, int y, D3DCOLOR colour, ID3DXFont* font, bool outlined, const char* string, ...)
{
	va_list args;
	char cBuffer[256];

	va_start(args, string);
	vsprintf_s(cBuffer, string, args);
	va_end(args);

	RECT pRect;
	if (outlined) {
		pRect.left = x - 1;
		pRect.top = y;
		font->DrawTextA(NULL, cBuffer, strlen(cBuffer), &pRect, DT_NOCLIP, D3DCOLOR_RGBA(0, 0, 0, 255));
		pRect.left = x + 1;
		pRect.top = y;
		font->DrawTextA(NULL, cBuffer, strlen(cBuffer), &pRect, DT_NOCLIP, D3DCOLOR_RGBA(0, 0, 0, 255));
		pRect.left = x;
		pRect.top = y - 1;
		font->DrawTextA(NULL, cBuffer, strlen(cBuffer), &pRect, DT_NOCLIP, D3DCOLOR_RGBA(0, 0, 0, 255));
		pRect.left = x;
		pRect.top = y + 1;
		font->DrawTextA(NULL, cBuffer, strlen(cBuffer), &pRect, DT_NOCLIP, D3DCOLOR_RGBA(0, 0, 0, 255));
	}
	pRect.left = x;
	pRect.top = y;
	font->DrawTextA(NULL, cBuffer, strlen(cBuffer), &pRect, DT_NOCLIP, colour);
}

void FilledBox(int x, int y, int width, int height, D3DCOLOR colour)
{
	SD3DVertex pVertex[4] = { { x, y + height, 0.0f, 1.0f, colour }, { x, y, 0.0f, 1.0f, colour }, { x + width, y + height, 0.0f, 1.0f, colour }, { x + width, y, 0.0f, 1.0f, colour } };
	d3ddev->SetFVF(D3DFVF_XYZRHW | D3DFVF_DIFFUSE);
	d3ddev->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, pVertex, sizeof(SD3DVertex));
}


void BorderedBox(int x, int y, int width, int height, int thickness, D3DCOLOR colour) {
	FilledBox(x, y, width, thickness, colour);
	FilledBox(x, y, thickness, height, colour);
	FilledBox(x + width - thickness, y, thickness, height, colour);
	FilledBox(x, y + height - thickness, width, thickness, colour);
}

void GradientBox(int x, int y, int width, int height, D3DCOLOR colour, D3DCOLOR color2, bool vertical) {
	SD3DVertex pVertex[4] = { { x, y, 0.0f, 1.0f, colour }, { x + width, y, 0.0f, 1.0f, vertical ? colour : color2 }, { x, y + height, 0.0f, 1.0f, vertical ? color2 : colour }, { x + width, y + height, 0.0f, 1.0f, color2 } };
	d3ddev->SetFVF(D3DFVF_XYZRHW | D3DFVF_DIFFUSE);
	d3ddev->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, pVertex, sizeof(SD3DVertex));
}
void GradientBoxOutlined(int x, int y, int width, int height, int thickness, D3DCOLOR colour, D3DCOLOR color2, D3DCOLOR outlinecolor, bool vertical) {
	BorderedBox(x, y, width, height, thickness, outlinecolor);
	GradientBox(x + thickness, y + thickness, width - (thickness * 2), height - (thickness * 2), colour, color2, vertical);
}

int StringWidth(ID3DXFont* font, char* string) {
	RECT pRect = RECT();
	font->DrawTextA(NULL, string, strlen(string), &pRect, DT_CALCRECT, D3DCOLOR_RGBA(0, 0, 0, 0));
	return pRect.right - pRect.left;
}

int FrameRate()
{
	static int iFps, iLastFps;
	static float flLastTickCount, flTickCount;
	flTickCount = clock() * 0.001f;
	iFps++;
	if ((flTickCount - flLastTickCount) >= 1.0f) {
		flLastTickCount = flTickCount;
		iLastFps = iFps;
		iFps = 0;
	}
	return iLastFps;
}


void DrawBar(int x, int y, int value)
{
	float l, r, g;

	g = value * 2.55;
	r = 255 - g;
	l = value / 3;
	FillRGB(x - (l / 2) - 1, y - 1, l + 2 + 13, 5, 0, 0, 0, 255);
	FillRGB(x - (l / 2), y, l + 13, 3, r, g, 0, 255);
}

void FillRGB(float x, float y, float w, float h, int r, int g, int b, int a)
{
	D3DXVECTOR2 vLine[2];

	d3dLine->SetWidth(w);

	vLine[0].x = x + w / 2;
	vLine[0].y = y;
	vLine[1].x = x + w / 2;
	vLine[1].y = y + h;

	d3dLine->Begin();
	d3dLine->Draw(vLine, 2, D3DCOLOR_RGBA(r, g, b, a));
	d3dLine->End();
}

void Circle(float x, float y, float radius, int rotate, int type, bool smoothing, int resolution, DWORD color)
{
	std::vector<SD3DVertex> circle(resolution + 2);

	float angle = rotate * D3DX_PI / 180;
	float pi;

	if (type == 1) pi = D3DX_PI;        // Full circle
	if (type == 2) pi = D3DX_PI / 2;      // 1/2 circle
	if (type == 3) pi = D3DX_PI / 4;   // 1/4 circle

	for (int i = 0; i < resolution + 2; i++)
	{
		circle[i].x = (float)(x - radius * cos(i * (2 * pi / resolution)));
		circle[i].y = (float)(y - radius * sin(i * (2 * pi / resolution)));
		circle[i].z = 0;
		circle[i].rhw = 1;
		circle[i].colour = color;
	}

	// Rotate matrix
	int _res = resolution + 2;
	for (int i = 0; i < _res; i++)
	{
		circle[i].x = x + cos(angle) * (circle[i].x - x) - sin(angle) * (circle[i].y - y);
		circle[i].y = y + sin(angle) * (circle[i].x - x) + cos(angle) * (circle[i].y - y);
	}

	d3ddev->CreateVertexBuffer((resolution + 2) * sizeof(SD3DVertex), D3DUSAGE_WRITEONLY, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &g_pVB, NULL);

	VOID* pVertices;
	g_pVB->Lock(0, (resolution + 2) * sizeof(SD3DVertex), (void**)&pVertices, 0);
	memcpy(pVertices, &circle[0], (resolution + 2) * sizeof(SD3DVertex));
	g_pVB->Unlock();


	d3ddev->SetTexture(0, NULL);
	d3ddev->SetPixelShader(NULL);
	if (smoothing)
	{
		d3ddev->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE);
		d3ddev->SetRenderState(D3DRS_ANTIALIASEDLINEENABLE, TRUE);
	}
	d3ddev->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	d3ddev->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	d3ddev->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

	d3ddev->SetStreamSource(0, g_pVB, 0, sizeof(SD3DVertex));
	d3ddev->SetFVF(D3DFVF_XYZRHW | D3DFVF_DIFFUSE);

	d3ddev->DrawPrimitive(D3DPT_LINESTRIP, 0, resolution);
	if (g_pVB != NULL) g_pVB->Release();
}



LRESULT CALLBACK WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
	case WM_PAINT:
		render_scene();
		break;
	case WM_CREATE:
		DwmExtendFrameIntoClientArea(hWnd, &margin);
		break;

	case WM_DESTROY:
		PostQuitMessage(0);
		return 0;
	}

	return DefWindowProc(hWnd, message, wParam, lParam);
}

```

`EFT Usermode/MemoryOperationSample/Overlay.h`:

```h
#include <d3d9.h>
#include <d3dx9.h>
#include <Dwmapi.h> 




//ESP data
extern int s_width;
extern int s_height;
extern LPDIRECT3D9 d3d;    // the pointer to our Direct3D interface
extern LPDIRECT3DDEVICE9 d3ddev;
extern LPDIRECT3DVERTEXBUFFER9 g_pVB;
extern HWND hWnd;
extern HWND twnd;
extern MARGINS  margin;
extern LPD3DXFONT pFont;
extern LPD3DXFONT pFont2;
extern ID3DXLine* d3dLine;

LRESULT CALLBACK WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
void FilledBox(int x, int y, int width, int height, D3DCOLOR colour);
void String(int x, int y, D3DCOLOR colour, ID3DXFont* font, bool outlined, const char* string, ...);
void DrawLine2(float x1, float y1, float x2, float y2, float size, bool antiAlias, D3DCOLOR COLOR);
void BorderedBox(int x, int y, int width, int height, int thickness, D3DCOLOR colour);
void GradientBox(int x, int y, int width, int height, D3DCOLOR colour, D3DCOLOR color2, bool vertical);
void GradientBoxOutlined(int x, int y, int width, int height, int thickness, D3DCOLOR colour, D3DCOLOR color2, D3DCOLOR outlinecolor, bool vertical);
void DrawBar(int x, int y, int value);
void FillRGB(float x, float y, float w, float h, int r, int g, int b, int a);
void Circle(float x, float y, float radius, int rotate, int type, bool smoothing, int resolution, DWORD color);
int StringWidth(ID3DXFont* font, char* string);
int FrameRate();
void draw_line(float x, float y, float xx, float yy, D3DCOLOR color);
void draw_box(float x, float y, float width, float height, D3DCOLOR color);
void initD3D(HWND hWnd);
void render_scene();
//

class CVertexList
{
public:
    FLOAT X, Y, Z;
    DWORD colour;
};


	struct SD3DVertex {
	float x, y, z, rhw;
	DWORD colour;
};


```

`EFT Usermode/MemoryOperationSample/PMemHelper.cpp`:

```cpp
#include "PMemHelper.h"

#include "server_shared.h"
#include "eftstructs.h"
#include <codecvt>
#pragma comment(lib, "Ws2_32")
#pragma warning(disable : 4996)
static bool send_packet(
	const SOCKET	connection,
	const Packet& packet,
	uint64_t& out_result)
{
	Packet completion_packet{ };

	if (send(connection, (const char*)&packet, sizeof(Packet), 0) == SOCKET_ERROR)
		return false;

	const auto result = recv(connection, (char*)&completion_packet, sizeof(Packet), 0);
	if (result < sizeof(PacketHeader) ||
		completion_packet.header.magic != packet_magic ||
		completion_packet.header.type != PacketType::packet_completed)
		return false;

	out_result = completion_packet.data.completed.result;
	return true;
}

static uint32_t copy_memory(
	const SOCKET	connection,
	const uint32_t	src_process_id,
	const uintptr_t src_address,
	const uint32_t	dest_process_id,
	const uintptr_t	dest_address,
	const size_t	size)
{
	Packet packet{ };

	packet.header.magic = packet_magic;
	packet.header.type = PacketType::packet_copy_memory;

	auto& data = packet.data.copy_memory;
	data.src_process_id = src_process_id;
	data.src_address = uint64_t(src_address);
	data.dest_process_id = dest_process_id;
	data.dest_address = uint64_t(dest_address);
	data.size = uint64_t(size);

	uint64_t result = 0;
	if (send_packet(connection, packet, result))
		return uint32_t(result);

	return 0;
}

PMem::PMem()
{
	this->initialize();
}

PMem::~PMem()
{
	//this->deinitialize();
}

void PMem::initialize()
{
	WSADATA wsa_data;
	WSAStartup(MAKEWORD(2, 2), &wsa_data);
}

void PMem::deinitialize()
{
	WSACleanup();
}

SOCKET PMem::connectsystem()
{
	SOCKADDR_IN address{ };

	address.sin_family = AF_INET;
	address.sin_addr.s_addr = htonl(server_ip);
	address.sin_port = htons(server_port);

	const auto connection = socket(AF_INET, SOCK_STREAM, 0);
	if (connection == INVALID_SOCKET)
		return INVALID_SOCKET;

	if (connect(connection, (SOCKADDR*)&address, sizeof(address)) == SOCKET_ERROR)
	{
		closesocket(connection);
		return INVALID_SOCKET;
	}

	return connection;
}

void PMem::disconnect(const SOCKET connection)
{
	closesocket(connection);
}



uint64_t PMem::get_process_base_address(const SOCKET connection, const uint32_t process_id)
{
	Packet packet{ };

	packet.header.magic = packet_magic;
	packet.header.type = PacketType::packet_get_base_address;

	auto& data = packet.data.get_base_address;
	data.process_id = process_id;

	uint64_t result = 0;
	if (send_packet(connection, packet, result))
		return result;

	return 0;
}

uint64_t PMem::get_process_peb(SOCKET connection, uint32_t process_id)
{
	Packet packet{ };

	packet.header.magic = packet_magic;
	packet.header.type = PacketType::packet_get_peb;

	auto& data = packet.data.get_base_peb;
	data.process_id = process_id;

	uint64_t result = 0;
	if (send_packet(connection, packet, result))
		return result;

	return 0;
}


MemoryIO::MemoryIO(PMem& physmem_api, SOCKET connection) :physmem_api(physmem_api)
{
	cached_connection = connection;
	if (connection == INVALID_SOCKET)
	{
		printf("connection failed");
		return;
	}

	cached_dwPID = find_process_by_id(_xor_(L"EscapeFromTarkov.exe").operator const wchar_t *());
	cached_peb = physmem_api.get_process_peb(cached_connection, cached_dwPID);

	//uint64_t gom = this->read<uint64_t>(cached_peb + 0x15181E8);
	//cached_peb = this->get_module_address(string.operator const wchar_t* ());
	//catched_twnd = FindWindow(_xor_(L"UnityWndClass"), 0);
	//debugging

//	printf(_xor_("baseaddress : 0x%X\n"), cached_process_base_address);
	//printf(_xor_("PEB : 0x%X\n"), cached_peb);
	//printf(_xor_("gom : 0x%X\n"), gom);
	//printf(_xor_("peb : 0x%X\n"), cached_peb);
}


uint32_t MemoryIO::readbuffer(uint64_t address, PVOID buffer, size_t size)
{
	if (address == 0)
		return false;
	return copy_memory(cached_connection, cached_dwPID, address, GetCurrentProcessId(), uintptr_t(buffer), size);
}

uint64_t MemoryIO::ReadChain(uint64_t base, const std::vector<uint64_t>& offsets) {
	uint64_t result = read<uint64_t>(base + offsets.at(0));
	for (int i = 1; i < offsets.size(); i++) {
		result = read<uint64_t>(result + offsets.at(i));
	}
	return result;
}


std::string MemoryIO::GetUnicodeString(uint64_t addr, int stringLength)
{
	char16_t wcharTemp[64] = { '\0' };
	readbuffer(addr, wcharTemp, stringLength * 2);
	std::string u8_conv = std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t>{}.to_bytes(wcharTemp);
	return u8_conv;
}


uint64_t MemoryIO::find_process_by_id(const std::wstring& name)
{
	const auto snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (snap == INVALID_HANDLE_VALUE) {
		return 0;
	}

	PROCESSENTRY32 proc_entry{};
	proc_entry.dwSize = sizeof proc_entry;

	auto found_process = false;
	if (!!Process32First(snap, &proc_entry)) {
		do {
			if (name == proc_entry.szExeFile) {
				found_process = true;
				break;
			}
		} while (!!Process32Next(snap, &proc_entry));
	}

	CloseHandle(snap);
	return found_process
		? proc_entry.th32ProcessID
		: 0;
}


```

`EFT Usermode/MemoryOperationSample/PMemHelper.h`:

```h
#include <Windows.h>
#include <stdint.h>
#include <iostream>
#include <time.h>
#include <Psapi.h>
#include <functional>
#include <tlhelp32.h>
#include "xorstr.hpp"
#include "subauth.h"


class PMem
{
public:
	PMem();
	~PMem();

	void	initialize();
	void	deinitialize();

	SOCKET	connectsystem();
	void	disconnect(SOCKET connection);

	uint64_t get_process_base_address(SOCKET connection, uint32_t process_id);
	uint64_t get_process_peb(SOCKET connection, uint32_t process_id);

};



class MemoryIO;
class MemoryIO {
public:
	MemoryIO(PMem& physmem_api, SOCKET connection);
	uint32_t readbuffer(uint64_t address, PVOID buffer, size_t size);
	uint64_t ReadChain(uint64_t base, const std::vector<uint64_t>& offsets);
	std::string GetUnicodeString(uint64_t addr, int stringLength);
	template <typename T>
	T read(uint64_t address);
	uint64_t get_process_base() const { return cached_process_base_address; };
	uint64_t get_process_peb() const { return cached_peb; };
	uint64_t find_process_by_id(const std::wstring& name);

private:
	uint64_t cached_process_base_address = 0, cached_dwPID = 0, cached_peb = 0;
	SOCKET cached_connection;
	PMem& physmem_api;
};

template<typename T>
inline T MemoryIO::read(uint64_t address)
{
	T buffer{ };
	readbuffer(address, &buffer, sizeof(T));
	return buffer;
}



extern MemoryIO* memio;
```

`EFT Usermode/MemoryOperationSample/eftstructs.cpp`:

```cpp
#include "eftstructs.h"
#include "xorstr.hpp"
#include "visuals.h"
#include <xmmintrin.h>  
#include <emmintrin.h>
#include <fstream>
#include <locale>
#include <codecvt>
#include "Overlay.h"
#include "PMemHelper.h"


std::list<uint64_t> bodypart = { BodyParts::Head, BodyParts::Thorax, BodyParts::Stomach, BodyParts::LeftArm, BodyParts::RightArm, BodyParts::LeftLeg, BodyParts::RightLeg };

EFTData* EFTData::Instance()
{
	static EFTData instance;
	return &instance;
}

/* All one time initialization in here*/
bool EFTData::InitOffsets()
{
	this->offsets.gameObjectManager = memio->read<uint64_t>(memio->get_process_peb() + this->offsets.offs_gameObjectManager);
	

	//printf("GOM: 0x%X\n", this->offsets.gameObjectManager);

	// Read pointer to activeObjects and lastActiveObject with 1 read, then find game world and local game world.
	auto active_objects = memio->read<std::array<uint64_t, 2>>(this->offsets.gameObjectManager + offsetof(EFTStructs::GameObjectManager, lastActiveObject));
	if (!active_objects[0] || !active_objects[1])
		return false;

	//printf("ActiveObjects: 0x%X\n", active_objects);

	if (!(this->offsets.gameWorld = GetObjectFromList(active_objects[1], active_objects[0], _xor_("GameWorld"))))
	return false;

	//printf("this->offsets.gameWorld: 0x%X\n", this->offsets.gameWorld);

	// Find fps camera.
	this->offsets.localGameWorld = memio->ReadChain(this->offsets.gameWorld, { 0x30, 0x18, 0x28 });

	//printf("localgameWorld: 0x%X\n", this->offsets.localGameWorld);

	// Get tagged objects and find fps camera.
	auto tagged_objects = memio->read<std::array<uint64_t, 2>>(this->offsets.gameObjectManager + offsetof(EFTStructs::GameObjectManager, lastTaggedObject));
	if (!tagged_objects[0] || !tagged_objects[1])
		return false;

	if (!(this->offsets.fpsCamera = GetObjectFromList(tagged_objects[1], tagged_objects[0], _xor_("FPS Camera"))))
		return false;



	return true;
}



FVector EFTData::GetPosition(uint64_t transform)
{
	auto transform_internal = memio->read<uint64_t>(transform + 0x10);

	auto matrices = memio->read<uint64_t>(transform_internal + 0x38);
	auto index = memio->read<int>(transform_internal + 0x40);

	memio->readbuffer((uintptr_t)(matrices + 0x18), &matrix_list_base, sizeof(matrix_list_base));

	memio->readbuffer((uintptr_t)(matrices + 0x20), &dependency_index_table_base, sizeof(dependency_index_table_base));

	static auto get_dependency_index = [this](uint64_t base, int32_t index) 
	{
		memio->readbuffer((uintptr_t)(base + index * 4), &index, sizeof(index));
		return index;
	};

	static auto get_matrix_blob = [this](uint64_t base, uint64_t offs, float* blob, uint32_t size) {
		memio->readbuffer((uintptr_t)(base + offs), blob, size);
	};

	int32_t index_relation = get_dependency_index(dependency_index_table_base, index);

	FVector ret_value;
	{
		float* base_matrix3x4 = (float*)malloc(64),
			* matrix3x4_buffer0 = (float*)((uint64_t)base_matrix3x4 + 16),
			* matrix3x4_buffer1 = (float*)((uint64_t)base_matrix3x4 + 32),
			* matrix3x4_buffer2 = (float*)((uint64_t)base_matrix3x4 + 48);

		get_matrix_blob(matrix_list_base, index * 48, base_matrix3x4, 16);

		__m128 xmmword_1410D1340 = { -2.f, 2.f, -2.f, 0.f };
		__m128 xmmword_1410D1350 = { 2.f, -2.f, -2.f, 0.f };
		__m128 xmmword_1410D1360 = { -2.f, -2.f, 2.f, 0.f };

		while (index_relation >= 0) 
		{
			uint32_t matrix_relation_index = 6 * index_relation;

			// paziuret kur tik 3 nureadina, ten translationas, kur 4 = quatas ir yra rotationas.
			get_matrix_blob(matrix_list_base, 8 * matrix_relation_index, matrix3x4_buffer2, 16);
			__m128 v_0 = *(__m128*)matrix3x4_buffer2;

			get_matrix_blob(matrix_list_base, 8 * matrix_relation_index + 32, matrix3x4_buffer0, 16);
			__m128 v_1 = *(__m128*)matrix3x4_buffer0;

			get_matrix_blob(matrix_list_base, 8 * matrix_relation_index + 16, matrix3x4_buffer1, 16);
			__m128i v9 = *(__m128i*)matrix3x4_buffer1;

			__m128* v3 = (__m128*)base_matrix3x4; // r10@1
			__m128 v10; // xmm9@2
			__m128 v11; // xmm3@2
			__m128 v12; // xmm8@2
			__m128 v13; // xmm4@2
			__m128 v14; // xmm2@2
			__m128 v15; // xmm5@2
			__m128 v16; // xmm6@2
			__m128 v17; // xmm7@2

			v10 = _mm_mul_ps(v_1, *v3);
			v11 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, 0));
			v12 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, 85));
			v13 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, -114));
			v14 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, -37));
			v15 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, -86));
			v16 = _mm_castsi128_ps(_mm_shuffle_epi32(v9, 113));

			v17 = _mm_add_ps(
				_mm_add_ps(
					_mm_add_ps(
						_mm_mul_ps(
							_mm_sub_ps(
								_mm_mul_ps(_mm_mul_ps(v11, (__m128)xmmword_1410D1350), v13),
								_mm_mul_ps(_mm_mul_ps(v12, (__m128)xmmword_1410D1360), v14)),
							_mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v10), -86))),
						_mm_mul_ps(
							_mm_sub_ps(
								_mm_mul_ps(_mm_mul_ps(v15, (__m128)xmmword_1410D1360), v14),
								_mm_mul_ps(_mm_mul_ps(v11, (__m128)xmmword_1410D1340), v16)),
							_mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v10), 85)))),
					_mm_add_ps(
						_mm_mul_ps(
							_mm_sub_ps(
								_mm_mul_ps(_mm_mul_ps(v12, (__m128)xmmword_1410D1340), v16),
								_mm_mul_ps(_mm_mul_ps(v15, (__m128)xmmword_1410D1350), v13)),
							_mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v10), 0))),
						v10)),
				v_0);

			*v3 = v17;

			index_relation = get_dependency_index(dependency_index_table_base, index_relation);
		}

		ret_value = *(FVector*)base_matrix3x4;
		delete[] base_matrix3x4;
	}

	return ret_value;
}


bool EFTData::Read()
{
	this->players.clear();


	// Accumulate players.
	{

		uint64_t onlineusers = memio->read<uint64_t>(this->offsets.localGameWorld + this->offsets.localGameWorld_offsets.registeredPlayers);

		if (!onlineusers)
			return false;

		uint64_t list_base = memio->read<uint64_t>(onlineusers + offsetof(EFTStructs::List, listBase));
		int player_count = memio->read<int>(onlineusers + offsetof(EFTStructs::List, itemCount));


		if (player_count <= 0 || !list_base)
			return false;

		constexpr auto BUFFER_SIZE = 128;

		uint64_t player_buffer[BUFFER_SIZE];
		memio->readbuffer(list_base + offsetof(EFTStructs::ListInternal, firstEntry), player_buffer, sizeof(uint64_t) * player_count);
	
		EFTPlayer player;

		for (int i = 0; i < player_count; i++)
		{
			player.instance = player_buffer[i];
			this->playercount = player_count;


			uint64_t bone_matrix = this->getbone_matrix(player.instance);

			if (bone_matrix)
			{
		
				uint64_t bone = memio->ReadChain(bone_matrix, { 0x20, 0x10, 0x38 });
				player.location = memio->read<FVector>(bone + 0xB0);

				player.headPos = GetPosition(memio->read<uint64_t>(bone_matrix + (0x20 + ((int)Bones::HumanHead * 8))));
				

			}

			// Leave this at the end to have all the data.
			if (memio->read<int>(player.instance + 0x18))
			{
				this->localPlayer = player;
				this->localPlayer.location = player.location;
			}
	
			this->players.emplace_back(player);
		}
	}

	this->extracts.clear();
	// Accumulate Extractions.
	{
		uint64_t exit_controller = memio->read<uint64_t>(this->offsets.localGameWorld + 0x18);

		if (!exit_controller)
		return false;

		uint64_t exit_point = memio->read<uint64_t>(exit_controller + 0x20);
		int exit_count = memio->read<int>(exit_point + 0x18);

		if (exit_count <= 0 || !exit_point)
			return false;

		constexpr auto BUFFER_SIZE = 24;

		uint64_t extract_buffer[BUFFER_SIZE];
		memio->readbuffer(exit_point + offsetof(EFTStructs::ListInternal, firstEntry), extract_buffer, sizeof(uint64_t) * exit_count);

		EFTExtract extract;

		for (int i = 0; i < exit_count; i++)
		{
			extract.instance = extract_buffer[i];

			if (!EFTData::Instance()->open_extract(extract.instance))
				continue;

			uint64_t transform = memio->ReadChain(extract.instance, { 0x10, 0x30, 0x30, 0x8, 0x28 });
			extract.location = GetPosition(transform);

			uint64_t extract_name = memio->ReadChain(extract.instance, { 0x58, 0x10 });

			if (extract_name )
			{
				int32_t nameLength = memio->read<int32_t>(extract_name + this->offsets.unicodeString.length);
				extract.name = memio->GetUnicodeString(extract_name + this->offsets.unicodeString.stringBase, nameLength);
				
			}

			this->extracts.emplace_back(extract);
			
		}

	}
	// Get view matrix.
	{
		uint64_t temp = this->offsets.fpsCamera;
		if (!(temp = memio->read<uint64_t>(temp + 0x30)) || !(temp = memio->read<uint64_t>(temp + 0x18)))
		   return false;

	//	printf("temp: 0x%X\n", temp);
		D3DXMATRIX temp_matrix;
		memio->readbuffer(temp + 0x00D8, &temp_matrix, sizeof(temp_matrix));
		D3DXMatrixTranspose(&this->viewMatrix, &temp_matrix);
	}
	return true;
}


uint64_t EFTData::GetObjectFromList(uint64_t listPtr, uint64_t lastObjectPtr, const char* objectName)
{
	using EFTStructs::BaseObject;
	char name[256];
	uint64_t classNamePtr = 0x0;

	BaseObject activeObject = memio->read<BaseObject>(listPtr);
	BaseObject lastObject = memio->read<BaseObject>(lastObjectPtr);

	if (activeObject.object != 0x0)
	{
		while (activeObject.object != 0 && activeObject.object != lastObject.object)
		{
			classNamePtr = memio->read<uint64_t>(activeObject.object + 0x60);
			memio->readbuffer(classNamePtr + 0x0, &name, sizeof(name));
			if (strcmp(name, objectName) == 0)
			{
				return activeObject.object;
			}

			activeObject = memio->read<BaseObject>(activeObject.nextObjectLink);
		}
	}
	if (lastObject.object != 0x0)
	{
		classNamePtr = memio->read<uint64_t>(lastObject.object + 0x60);
		memio->readbuffer(classNamePtr + 0x0, &name, 256);
		if (strcmp(name, objectName) == 0)
		{
			return lastObject.object;
		}
	}

	return uint64_t();
}


bool EFTData::IsAiming(uint64_t	 instance)
{
	uint64_t m_pbreath = memio->ReadChain(instance, { this->offsets.Player.proceduralWeaponAnimation, 0x28});
	return memio->read<bool>(m_pbreath + 0x88);
}

uint64_t EFTData::get_mpcamera(uint64_t instance)
{
	static std::vector<uint64_t> temp{ this->offsets.Player.proceduralWeaponAnimation, 0x88, 0x20 };

	return memio->ReadChain(instance, temp);
}

uint64_t EFTData::getbone_matrix(uint64_t instance)
{
	static std::vector<uint64_t> temp{ this->offsets.Player.playerBody, 0x28, 0x28, 0x10 };

	return memio->ReadChain(instance, temp);
}

bool EFTData::IsPlayer(uint64_t instance)
{
	static std::vector<uint64_t> tempchain{ this->offsets.Player.profile, this->offsets.profile.information };

	uint64_t information = memio->ReadChain(instance, tempchain);

	if (memio->read<int32_t>(information + 0x54) != 0)
		return true;

	return false;
}

D3DXMATRIX EFTData::getoptic_matrix(uint64_t instance)
{
	D3DXMATRIX temp_matrix;
	D3DXMATRIX outmatrix;

	static std::vector<uint64_t> tempchain{ this->offsets.Player.proceduralWeaponAnimation,0x88, 0x20, 0x28, 0x30 };

	uint64_t temp = memio->ReadChain(instance, tempchain);

	//printf(_xor_("temp : 0x%X\n"), temp);
	memio->readbuffer(temp + 0x00D8, &temp_matrix, sizeof(temp_matrix));
	D3DXMatrixTranspose(&outmatrix, &temp_matrix);

	return outmatrix;
}


bool EFTData::open_extract(uint64_t extract)
{
	if (!extract)
		return false;

	int32_t status = memio->read<int32_t>(extract + 0xA8); /* NotOpen = 1// Imcpmpleterequirement = 2 // Countdown = 3 // Open = 4 // Pending = 5 // Awaot ,amial Activation = 6*/

	if (status == 4)
		return true;


	return false;
}


```

`EFT Usermode/MemoryOperationSample/eftstructs.h`:

```h
#pragma once
#include <string>
#include "math.hpp"
#include <vector>
#include <list>

#include "visuals.h"


#include <d3dx9math.h>
#pragma comment (lib, "d3dx9.lib")



// This is retarded but fuck it, deal with it, all objects should have their full struct
// in the namespace EFTStructs.
struct EFTOffsets
{
	static constexpr uint64_t offs_gameObjectManager = 0x15181E8;

	uint64_t gameObjectManager = 0x0;
	uint64_t gameWorld = 0x0;
	uint64_t localGameWorld = 0x0;
	uint64_t fpsCamera = 0x0;
	uint64_t OpticCamera = 0x0;

	struct
	{
		static constexpr uint64_t itemList = 0x48; //UPDATED 1/11/2020
		static constexpr uint64_t registeredPlayers = 0x68; //UPDATED 1/11/2020
		static constexpr uint64_t m_LocalPlayerID = 0x30;
	} localGameWorld_offsets;

	struct
	{
		static constexpr uint64_t length = 0x10; //good
		static constexpr uint64_t stringBase = 0x14; //good
	} unicodeString;

	struct
	{
		static constexpr uint64_t information = 0x28; //updated
		static constexpr uint64_t id = 0x10; //updated
	} profile;

	struct
	{
		static constexpr uint64_t playerName = 0x10; //updated
	} information;

	struct
	{
		static constexpr uint64_t angles_0 = 0x1D0;
		static constexpr uint64_t angles_1 = 0x1D8;
		static constexpr uint64_t position = 0x1E0;
	} movementContext;

	struct
	{
		static constexpr uint64_t m_pPlayerProfile = 0x03A0;
		static constexpr uint64_t movementContext = 0x38;
		static constexpr uint64_t proceduralWeaponAnimation = 0x70; //updayed 1/11/2020
		static constexpr uint64_t playerBody = 0x88; //updated 1/11/2020
		static constexpr uint64_t m_pHealthController = 0x3D0; //updated 1/11/2020
		static constexpr uint64_t profile = 0x3A0; //updayed 1/11/2020

	} Player;
};

namespace EFTStructs
{
	struct BaseObject
	{
		uint64_t previousObjectLink; //0x0000
		uint64_t nextObjectLink; //0x0008
		uint64_t object; //0x0010
	};

	struct GameObjectManager
	{
		uint64_t lastTaggedObject; //0x0000
		uint64_t taggedObjects; //0x0008
		uint64_t lastActiveObject; //0x0010
		uint64_t activeObjects; //0x0018
	}; //Size: 0x0010

	class ListInternal
	{
	public:
		char pad_0x0000[0x20]; //0x0000
		uintptr_t* firstEntry; //0x0020 
	}; //Size=0x0028

	class List
	{
	public:
		char pad_0x0000[0x10]; //0x0000
		ListInternal* listBase; //0x0010 
		__int32 itemCount; //0x0018 
	}; //Size=0x001C
}

struct EFTPlayer
{
	uintptr_t	 instance;
	FVector		 headPos;
	FVector		 location;
};

struct EFTExtract
{
	uintptr_t	 instance;
	std::string  name;
	FVector		 location;
};

/*
struct EFTLoot
{
	uintptr_t	instance;
	std::string name;
	Vector3		origin;
};*/


enum BodyParts : uint64_t
{
	Head = 0x20,
	Thorax = 0x28,
	Stomach = 0x30,
	LeftArm = 0x38,
	RightArm = 0x40,
	LeftLeg = 0x48,
	RightLeg = 0x50,
	value_max
};


class EFTData
{
public:
	static EFTData* Instance();

	bool InitOffsets();

	FVector GetPosition(uint64_t transform);

	bool Read();

	D3DXMATRIX viewMatrix;
	EFTPlayer localPlayer;
	std::vector<EFTPlayer> players;
	std::vector<EFTExtract> extracts;

	int          playercount;


	bool IsAiming(uint64_t instance);

	uint64_t get_mpcamera(uint64_t instance);
	D3DXMATRIX getoptic_matrix(uint64_t instance);
	bool open_extract(uint64_t extract);


	EFTOffsets offsets;

	bool IsPlayer(uint64_t instance);
private:
	uint64_t matrix_list_base = 0;
	uint64_t dependency_index_table_base = 0;

	uint64_t GetObjectFromList(uint64_t list, uint64_t lastObject, const char* objectName);
	uint64_t getbone_matrix(uint64_t instance);





	//std::vector<std::wstring> names;
};

enum Bones : int
{
	HumanBase = 0,
	HumanPelvis = 14,
	HumanLThigh1 = 15,
	HumanLThigh2 = 16,
	HumanLCalf = 17,
	HumanLFoot = 18,
	HumanLToe = 19,
	HumanRThigh1 = 20,
	HumanRThigh2 = 21,
	HumanRCalf = 22,
	HumanRFoot = 23,
	HumanRToe = 24,
	HumanSpine1 = 29,
	HumanSpine2 = 36,
	HumanSpine3 = 37,
	HumanLCollarbone = 89,
	HumanLUpperarm = 90,
	HumanLForearm1 = 91,
	HumanLForearm2 = 92,
	HumanLForearm3 = 93,
	HumanLPalm = 94,
	HumanRCollarbone = 110,
	HumanRUpperarm = 111,
	HumanRForearm1 = 112,
	HumanRForearm2 = 113,
	HumanRForearm3 = 114,
	HumanRPalm = 115,
	HumanNeck = 132,
	HumanHead = 133
};


```

`EFT Usermode/MemoryOperationSample/main.cpp`:

```cpp
#include <Windows.h>
#include <iostream>
#include "PMemHelper.h"
#include "eftstructs.h"
#include "Overlay.h"


MemoryIO* memio = nullptr;
auto pRender = PRENDER::Instance();
auto gameData = EFTData::Instance();

//render function
void render_scene()
{
	// clear the window alpha
	d3ddev->Clear(0, NULL, D3DCLEAR_TARGET, D3DCOLOR_ARGB(0, 0, 0, 0), 1.0f, 0);

	d3ddev->BeginScene();    // begins the 3D scene

	static char cTitle[256];
	sprintf_s(cTitle, _xor_("getgoodv1 | EFT 0.12 \nFrame Rate: %i\nPlayers: %i").operator const char* (), FrameRate(), gameData->playercount);
	GradientBoxOutlined(40, 70, StringWidth(pFont, cTitle) + 4, 40, 1, D3DCOLOR_RGBA(100, 100, 100, 255), D3DCOLOR_RGBA(50, 50, 50, 255), D3DCOLOR_RGBA(0, 0, 0, 255), true);
	String(42, 72, D3DCOLOR_RGBA(255, 255, 255, 255), pFont, true, cTitle);

	//calculate and and draw esp stuff
	pRender->Render();
	
	//draw_string(10, 10, color, pFont, "output");

	d3ddev->EndScene();    // ends the 3D scene

	d3ddev->Present(NULL, NULL, NULL, NULL);   // displays the created frame on the screen
}

//set up overlay window
void start_window()
{
	RECT rc;

	twnd = NULL;
	while (!twnd)
		twnd = FindWindow(_xor_(L"UnityWndClass"), 0);
	if (twnd != NULL)
	{
		GetWindowRect(twnd, &rc);
		s_width = rc.right - rc.left;
		s_height = rc.bottom - rc.top;
	}

	WNDCLASSEX wndclass;
	ZeroMemory(&wndclass, sizeof(WNDCLASSEX)); // Initialises, sets all bits to 0 to remove garbage data
	wndclass.cbClsExtra = NULL;
	wndclass.cbWndExtra = NULL;
	wndclass.cbSize = sizeof(WNDCLASSEX);
	wndclass.style = CS_HREDRAW | CS_VREDRAW;
	wndclass.lpfnWndProc = WindowProc; // Function that will be executed when the window receives a "message" (input). Required! (crashes if set to NULL)
	wndclass.hInstance = NULL;
	wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
	wndclass.hIcon = LoadIcon(0, IDI_APPLICATION);
	wndclass.hIconSm = LoadIcon(0, IDI_APPLICATION);
	wndclass.hbrBackground = (HBRUSH)RGB(0, 0, 0);
	wndclass.lpszClassName = L"Class_RiotWnd";
	RegisterClassEx(&wndclass);

	hWnd = CreateWindowEx(WS_EX_LAYERED | WS_EX_TRANSPARENT, wndclass.lpszClassName, L"", WS_POPUP, rc.left, rc.top, s_width, s_height, NULL, NULL, wndclass.hInstance, NULL);

	// Activate transparency on color black.
	SetLayeredWindowAttributes(hWnd, RGB(0, 0, 0), 0, ULW_COLORKEY);
	SetLayeredWindowAttributes(hWnd, 0, 255, LWA_ALPHA);
//	SetLayeredWindowAttributes(hWnd, 0, 255, LWA_ALPHA);

	ShowWindow(hWnd, SW_SHOW);
	initD3D(hWnd);
}

uint32_t EntryMode()
{
	MSG msg;
	//RECT rc;

	while (TRUE)
	{
		ZeroMemory(&msg, sizeof(MSG));
		if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}

		if (msg.message == WM_QUIT)
			exit(0);


		SetWindowPos(twnd, hWnd, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

		UpdateWindow(hWnd);

		if (!gameData->Read())
			gameData->InitOffsets();

		//render your esp
		render_scene();

		Sleep(5);
	}
	return 0;
}


int main()
{
	printf(_xor_("Welcome , press enter to initialize systems"));
	getchar();

	PMem* mem = new PMem();

	const auto connection = mem->connectsystem();

	printf(_xor_("systems up.. press enter in game"));
	getchar();

	FreeConsole();

	memio = new MemoryIO(*mem, connection);

	start_window();


	uint32_t entry = (uint32_t)EntryMode();
	//getchar();
	return entry;
}
```

`EFT Usermode/MemoryOperationSample/math.cpp`:

```cpp
#include "math.hpp"
#include <cmath>
#include <cfloat>

#define M_PI       3.14159265358979323846   // pi

float DegToRad(float x)
{
	return x * ((float)M_PI / 180.f);
}

float RadToDeg(float x)
{
	return x * (180.f / (float)M_PI);
}

float DistancePointToLine(FVector Point, FVector LineOrigin, FVector Dir)
{
	FVector PointDir = Point - LineOrigin;

	float TempOffset = (PointDir * Dir) / Dir.GetMagnitudeSqr(); // Calculates the Offset for: LineOrigin + TempOffset*Dir; - if Dir is already normalized you can skip the dividing
	if (TempOffset < 0.000001f)
		return FLT_MAX;

	FVector PerpendicularPoint = LineOrigin + (Dir * TempOffset);

	return (Point - PerpendicularPoint).GetLength();
}

Vector4::Vector4()
{
	x = 0.0f;
	y = 0.0f;
	z = 0.0f;
	w = 1.0f;
	pointer = false;
}

Vector4::Vector4(float x, float y, float z, float w)
{
	this->x = x; this->y = y; this->z = z; this->w = w;
	pointer = false;
}

Vector4::Vector4(float x, float y, float z)
{
	this->x = x; this->y = y; this->z = z; this->w = 1.0f;
	pointer = false;
}

Vector4::Vector4(float* x, float* y, float* z, float* w)
{
	this->px = x; this->py = y; this->pz = z; this->pw = w;
	this->x = *x; this->y = *y; this->z = *z; this->w = *w;
	pointer = true;
}

Vector4 Vector4::operator= (const Vector4& v)
{
	if (pointer)
	{
		*px = x = v.x;
		*py = y = v.y;
		*pz = z = v.z;
		*pw = w = v.w;
	}
	else
	{
		x = v.x;
		y = v.y;
		z = v.z;
		w = v.w;
	}
}

const Vector4 Vector4::operator* (const float& scalar) const
{
	return Vector4(x * scalar, y * scalar, z * scalar, w * scalar);
}

const Vector4 Vector4::operator+ (const Vector4& v) const
{
	Vector4 vec;
	vec.x = this->x + v.x;
	vec.y = this->y + v.y;
	vec.z = this->z + v.z;
	vec.w = this->w + v.w;
	return vec;
}

float Vector3::Distance(Vector3 v)
{
	return float(sqrtf(powf(v.x - x, 2.0) + powf(v.y - y, 2.0) + powf(v.z - z, 2.0)));
}

Vector3 Vector3::operator+(Vector3 v)
{
	return Vector3(x + v.x, y + v.y, z + v.z);
}

float Vector3::Dot(Vector3 v)
{
	return x * v.x + y * v.y + z * v.z;
}

Vector3 Vector3::operator-(Vector3 v)
{
	return Vector3(x - v.x, y - v.y, z - v.z);
}

FVector::FVector() : x(0.f), y(0.f), z(0.f) {}

FVector::FVector(float x, float y, float z) : x(x), y(y), z(z) {}

FVector::FVector(const FVector& other) : x(other.x), y(other.y), z(other.z) {}

FVector FVector::operator+(const FVector& other) const
{
	return FVector(x + other.x, y + other.y, z + other.z);
}

FVector FVector::operator-(const FVector& other) const
{
	return FVector(x - other.x, y - other.y, z - other.z);
}

FVector FVector::operator*(const float other) const
{
	return FVector(x * other, y * other, z * other);
}

float FVector::operator*(const FVector& other) const
{
	return (x * other.x + y * other.y + z * other.z);
}

bool FVector::operator==(const FVector& other) const
{
	return x == other.x && y == other.y && z == other.z;
}

bool FVector::operator!=(const FVector& other) const
{
	return x != other.x || y != other.y || z != other.z;
}

FVector& FVector::operator=(const FVector& other)
{
	x = other.x;
	y = other.y;
	z = other.z;

	return *this;
}

FVector& FVector::operator+=(const FVector& other)
{
	x += other.x;
	y += other.y;
	z += other.z;

	return *this;
}

FVector& FVector::operator-=(const FVector& other)
{
	x -= other.x;
	y -= other.y;
	z -= other.z;

	return *this;
}

FVector& FVector::operator*=(const float other)
{
	x *= other;
	y *= other;
	z *= other;

	return *this;
}

float& FVector::operator[](size_t i)
{
	return reinterpret_cast<float*>(this)[i];
}

const float& FVector::operator[](size_t i) const
{
	return reinterpret_cast<const float*>(this)[i];
}

float FVector::GetLength() const
{
	return sqrt(x * x + y * y + z * z);
}

float FVector::Distance(FVector v)
{
	return float(sqrtf(powf(v.x - x, 2.0) + powf(v.y - y, 2.0) + powf(v.z - z, 2.0)));
}

float FVector::Distance2(FVector a, FVector b)

{

	float diff_x = a.x - b.x;

	float diff_y = a.y - b.y;

	float diff_z = a.z - b.z;

	return float(sqrtf(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z));

}
float FVector::GetMagnitudeSqr()
{
	return (x * x + y * y + z * z);
}

FRotator FVector::VectorAngles() const
{
	return FRotator(atan2(-x, z), atan2(y, sqrt(x * x + z * z)), 0.f);
}

FRotator::FRotator() : pitch(0.f), yaw(0.f), roll(0.f) {}

FRotator::FRotator(float pitch, float yaw, float roll) : pitch(pitch), yaw(yaw), roll(roll) {}

FRotator::FRotator(const FRotator& other) : pitch(other.pitch), yaw(other.yaw), roll(other.roll) {}

void FRotator::ToSourceAngles()
{
	yaw = -yaw + 90.f;
	Normalize();
}

void FRotator::ToUnityAngles()
{
	ToSourceAngles(); // Toggle behaviour.
}

void FRotator::Normalize()
{
	yaw = remainder(yaw, static_cast<float>(2 * M_PI));
	pitch = remainder(pitch, static_cast<float>(2 * M_PI));
}

FVector FRotator::AngleVector()
{
	float sp, sy, cp, cy;

	sy = sin(yaw / 180.f * (float)M_PI);
	cy = cos(yaw / 180.f * (float)M_PI);

	sp = sin(pitch / 180.f * (float)M_PI);
	cp = cos(pitch / 180.f * (float)M_PI);

	return FVector(cp * cy, cp * sy, -sp);
}

void FRotator::AngleVectors(FVector* x, FVector* y, FVector* z)
{
	float radPitch = (pitch * static_cast<float>(M_PI / 180.f));
	float radYaw = (yaw * static_cast<float>(M_PI / 180.f));
	float radRoll = (roll * static_cast<float>(M_PI / 180.f));

	float SP = sin(radPitch);
	float CP = cos(radPitch);
	float SY = sin(radYaw);
	float CY = cos(radYaw);
	float SR = sin(radRoll);
	float CR = cos(radRoll);


	x->x = CP * CY;
	x->y = CP * SY;
	x->z = SP;

	y->x = SR * SP * CY - CR * SY;
	y->y = SR * SP * SY + CR * CY;
	y->z = -SR * CP;

	z->x = -(CR * SP * CY + SR * SY);
	z->y = CY * SR - CR * SP * SY;
	z->z = CR * CP;
}

FQuat FQuat::operator*(const FQuat& other)
{
	FQuat ret;

	auto& q1 = *this;
	auto& q2 = other;

	ret.x = q1.x * q2.w + q1.y * q2.z - q1.z * q2.y + q1.w * q2.x;
	ret.y = -q1.x * q2.z + q1.y * q2.w + q1.z * q2.x + q1.w * q2.y;
	ret.z = q1.x * q2.y - q1.y * q2.x + q1.z * q2.w + q1.w * q2.z;
	ret.w = -q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w;

	return ret;
}
//
//FMatrix FMatrix::operator*(const FMatrix & other)
//{
//	FMatrix result;
//	for (int i = 0; i < 4; i++)
//	{
//		for (int j = 0; j < 4; j++)
//		{
//			result[i][j] = 0;
//
//			for (int k = 0; k < 4; k++)
//			{
//				result[i][j] += (*this)[i][k] * other[k][j];
//			}
//		}
//	}
//
//	return result;
//}

FVector FMatrix::operator*(const FVector& vec)
{
	/*
	FVector pOut;
	int a[3][3] = { { 2,4,3 },{ 1,5,7 },{ 0,2,3 } };
	int b[] = { 2,5,6 };
	FVector out;

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			out[i] += (a[i][j] * b[j]);
		}
	}

	return pOut;
	*/


	FMatrix m;

	m[3][0] = vec.x;
	m[3][1] = vec.y;
	m[3][2] = vec.z;

	m[0][0] = 1.f;
	m[1][1] = 1.f;
	m[2][2] = 1.f;


	m[0][3] = 0.0f;
	m[1][3] = 0.0f;
	m[2][3] = 0.0f;
	m[3][3] = 1.0f;

	auto result = m * (*this);

	return FVector(result[3][0], result[3][1], result[3][2]);

}

FMatrix FMatrix::operator*(const FMatrix& pM2)
{
	auto pM1 = *this;

	FMatrix pOut;
	pOut[0][0] = pM1[0][0] * pM2[0][0] + pM1[0][1] * pM2[1][0] + pM1[0][2] * pM2[2][0] + pM1[0][3] * pM2[3][0];
	pOut[0][1] = pM1[0][0] * pM2[0][1] + pM1[0][1] * pM2[1][1] + pM1[0][2] * pM2[2][1] + pM1[0][3] * pM2[3][1];
	pOut[0][2] = pM1[0][0] * pM2[0][2] + pM1[0][1] * pM2[1][2] + pM1[0][2] * pM2[2][2] + pM1[0][3] * pM2[3][2];
	pOut[0][3] = pM1[0][0] * pM2[0][3] + pM1[0][1] * pM2[1][3] + pM1[0][2] * pM2[2][3] + pM1[0][3] * pM2[3][3];
	pOut[1][0] = pM1[1][0] * pM2[0][0] + pM1[1][1] * pM2[1][0] + pM1[1][2] * pM2[2][0] + pM1[1][3] * pM2[3][0];
	pOut[1][1] = pM1[1][0] * pM2[0][1] + pM1[1][1] * pM2[1][1] + pM1[1][2] * pM2[2][1] + pM1[1][3] * pM2[3][1];
	pOut[1][2] = pM1[1][0] * pM2[0][2] + pM1[1][1] * pM2[1][2] + pM1[1][2] * pM2[2][2] + pM1[1][3] * pM2[3][2];
	pOut[1][3] = pM1[1][0] * pM2[0][3] + pM1[1][1] * pM2[1][3] + pM1[1][2] * pM2[2][3] + pM1[1][3] * pM2[3][3];
	pOut[2][0] = pM1[2][0] * pM2[0][0] + pM1[2][1] * pM2[1][0] + pM1[2][2] * pM2[2][0] + pM1[2][3] * pM2[3][0];
	pOut[2][1] = pM1[2][0] * pM2[0][1] + pM1[2][1] * pM2[1][1] + pM1[2][2] * pM2[2][1] + pM1[2][3] * pM2[3][1];
	pOut[2][2] = pM1[2][0] * pM2[0][2] + pM1[2][1] * pM2[1][2] + pM1[2][2] * pM2[2][2] + pM1[2][3] * pM2[3][2];
	pOut[2][3] = pM1[2][0] * pM2[0][3] + pM1[2][1] * pM2[1][3] + pM1[2][2] * pM2[2][3] + pM1[2][3] * pM2[3][3];
	pOut[3][0] = pM1[3][0] * pM2[0][0] + pM1[3][1] * pM2[1][0] + pM1[3][2] * pM2[2][0] + pM1[3][3] * pM2[3][0];
	pOut[3][1] = pM1[3][0] * pM2[0][1] + pM1[3][1] * pM2[1][1] + pM1[3][2] * pM2[2][1] + pM1[3][3] * pM2[3][1];
	pOut[3][2] = pM1[3][0] * pM2[0][2] + pM1[3][1] * pM2[1][2] + pM1[3][2] * pM2[2][2] + pM1[3][3] * pM2[3][2];
	pOut[3][3] = pM1[3][0] * pM2[0][3] + pM1[3][1] * pM2[1][3] + pM1[3][2] * pM2[2][3] + pM1[3][3] * pM2[3][3];

	return pOut;
}



FMatrix FTransform::ToMatrixWithScale()
{
	FMatrix OutMatrix = {};

	OutMatrix[3][0] = Translation.x;
	OutMatrix[3][1] = Translation.y;
	OutMatrix[3][2] = Translation.z;

	float x2 = Rotation.x + Rotation.x;
	float y2 = Rotation.y + Rotation.y;
	float z2 = Rotation.z + Rotation.z;
	{
		float xx2 = Rotation.x * x2;
		float yy2 = Rotation.y * y2;
		float zz2 = Rotation.z * z2;
		OutMatrix[0][0] = (1.0f - (yy2 + zz2)) * Scale3D.x;
		OutMatrix[1][1] = (1.0f - (xx2 + zz2)) * Scale3D.y;
		OutMatrix[2][2] = (1.0f - (xx2 + yy2)) * Scale3D.z;
	}
	{
		float yz2 = Rotation.y * z2;
		float wx2 = Rotation.w * x2;

		OutMatrix[2][1] = (yz2 - wx2) * Scale3D.z;
		OutMatrix[1][2] = (yz2 + wx2) * Scale3D.y;
	}
	{
		float xy2 = Rotation.x * y2;
		float wz2 = Rotation.w * z2;

		OutMatrix[1][0] = (xy2 - wz2) * Scale3D.y;
		OutMatrix[0][1] = (xy2 + wz2) * Scale3D.x;
	}
	{
		float xz2 = Rotation.x * z2;
		float wy2 = Rotation.w * y2;

		OutMatrix[2][0] = (xz2 + wy2) * Scale3D.z;
		OutMatrix[0][2] = (xz2 - wy2) * Scale3D.x;
	}

	OutMatrix[0][3] = 0.0f;
	OutMatrix[1][3] = 0.0f;
	OutMatrix[2][3] = 0.0f;
	OutMatrix[3][3] = 1.0f;

	return OutMatrix;
}

```

`EFT Usermode/MemoryOperationSample/math.hpp`:

```hpp
#pragma once
// Libraries
#include <math.h>
#include <assert.h>

class FVector;
class FRotator;
class Vector3;

float DegToRad(float x);
float RadToDeg(float x);
float DistancePointToLine(FVector Point, FVector LineOrigin, FVector Dir);



    // Class Vector2
    // This class represents a 2D vector.
    class Vector2 {

    public:

        // -------------------- Attributes -------------------- //

        // Components of the vector
        float x, y;


        // -------------------- Methods -------------------- //

        // Constructor
        Vector2(float x = 0, float y = 0) : x(x), y(y) {}

        // Constructor
        Vector2(const Vector2& vector) : x(vector.x), y(vector.y) {}

        // + operator
        Vector2 operator+(const Vector2& v) const {
            return Vector2(x + v.x, y + v.y);
        }

        // += operator
        Vector2& operator+=(const Vector2& v) {
            x += v.x; y += v.y;
            return *this;
        }

        // - operator
        Vector2 operator-(const Vector2& v) const {
            return Vector2(x - v.x, y - v.y);
        }

        // -= operator
        Vector2& operator-=(const Vector2& v) {
            x -= v.x; y -= v.y;
            return *this;
        }

        // = operator
        Vector2& operator=(const Vector2& vector) {
            if (&vector != this) {
                x = vector.x;
                y = vector.y;
            }
            return *this;
        }

        // == operator
        bool operator==(const Vector2& v) const {
            return x == v.x && y == v.y;
        }

        // * operator
        Vector2 operator*(float f) const {
            return Vector2(f * x, f * y);
        }

        // *= operator
        Vector2& operator*=(float f) {
            x *= f; y *= f;
            return *this;
        }

        // / operator
        Vector2 operator/(float f) const {
            assert(f != 0);
            float inv = 1.f / f;
            return Vector2(x * inv, y * inv);
        }

        // /= operator
        Vector2& operator/=(float f) {
            assert(f != 0);
            float inv = 1.f / f;
            x *= inv; y *= inv;
            return *this;
        }

        // - operator
        Vector2 operator-() const {
            return Vector2(-x, -y);
        }

        // [] operator
        float& operator[](int i) {
            assert(i >= 0 && i <= 1);
            switch (i) {
            case 0: return x;
            case 1: return y;
            }
            return y;
        }

        // Normalize the vector and return it
        Vector2 normalize() {
            float l = length();
            assert(l > 0);
            x /= l;
            y /= l;
            return *this;
        }

        // Clamp the vector values between 0 and 1
        Vector2 clamp01() {
            if (x > 1.f) x = 1.f;
            else if (x < 0.f) x = 0.f;
            if (y > 1.f) y = 1.f;
            else if (y < 0.f) y = 0.f;
            return *this;
        }

        // Return the squared length of the vector
        float lengthSquared() const { return x * x + y * y; }

        // Return the length of the vector
        float length() const { return sqrt(lengthSquared()); }
    };


//Vector3
class Vector3
{
public:
	Vector3() : x(0.f), y(0.f), z(0.f)
	{

	}

	Vector3(float _x, float _y, float _z) : x(_x), y(_y), z(_z)
	{

	}
	~Vector3()
	{

	}

	float x;
	float y;
	float z;

	float Dot(Vector3 v);
	Vector3 operator+(Vector3 v);
	Vector3 operator-(Vector3 v);
	float Distance(Vector3 v);
};

class Vector4
{
public:
    float x, z, y;

	Vector4();
	Vector4(float x, float y, float z, float w);
	Vector4(float x, float y, float z);
	Vector4(float* x, float* y, float* z, float* w);
	~Vector4() {}

	Vector4 operator= (const Vector4& v);
	const Vector4 operator* (const float& scalar) const;
	const Vector4 operator+ (const Vector4& v) const;

	//inline void show() { std::cout << this->x << " " << this->y << " " << this->z << " " << this->w << std::endl; }

private:

	float w;

	// only to allow do that: m(0) = Vector4(1,1,1,1) //
	float* px;
	float* py;
	float* pz;
	float* pw;

	bool pointer;  // to check what constructor was called //
};

class FVector
{
public:
	float x, z, y;

	FVector();
	FVector(float x, float y, float z);
	FVector(const FVector& other);

	FVector operator+ (const FVector& other) const;
	FVector operator- (const FVector& other) const;
	FVector operator* (const float other) const;
	float operator* (const FVector& other) const;

	bool operator == (const FVector& other) const;
	bool operator != (const FVector& other) const;

	FVector& operator= (const FVector& other);
	FVector& operator+= (const FVector& other);
	FVector& operator-= (const FVector& other);
	FVector& operator*= (const float other);

	float& operator[](size_t i);
	const float& operator[](size_t i) const;

	float GetLength() const;
    float Distance(FVector v);
    float Distance2(FVector a, FVector b);
    float GetMagnitudeSqr();

	FRotator VectorAngles() const;
};

class FMatrix
{
public:
	FMatrix() : m{
		{ 0.f, 0.f, 0.f, 0.f },
		{ 0.f, 0.f, 0.f, 0.f },
		{ 0.f, 0.f, 0.f, 0.f },
		{ 0.f, 0.f, 0.f, 0.f } }
	{
	}

	FMatrix(const FMatrix&) = default;


	float* operator[](size_t i) { return m[i]; }
	const float* operator[](size_t i) const { return m[i]; }


	FVector operator*(const FVector& vec);
	FMatrix operator*(const FMatrix& other);
	float m[4][4];
};

class FRotator
{
public:
	float yaw;
	float pitch;
	float roll;

	FRotator();
	FRotator(float pitch, float yaw, float roll);
	FRotator(const FRotator& other);

	void ToSourceAngles();
	void ToUnityAngles();
	void Normalize();
	FVector AngleVector();
	void AngleVectors(FVector* x, FVector* y, FVector* z);
};

struct FQuat
{
	float x;
	float y;
	float z;
	float w;

	FQuat operator*(const FQuat& other);
};

struct FTransform
{
public:
	FQuat Rotation;
	FVector Translation;
private:
	float pad0;
public:
	FVector Scale3D;
private:
	float pad1;

public:
	FMatrix ToMatrixWithScale();

};

struct FBoxSphereBounds
{
	FVector	Origin;
	FVector BoxExtent;
	float SphereRadius;
};

```

`EFT Usermode/MemoryOperationSample/server_shared.h`:

```h
#pragma once
#include "stdint.h"
#include "subauth.h"

constexpr auto packet_magic = 0x12345568;
constexpr auto server_ip = 0x7F000001; // 127.0.0.1
constexpr auto server_port = 28125;

enum class PacketType
{
	packet_copy_memory,
	packet_get_base_address,
	packet_get_peb,
	packet_completed
};

struct PacketCopyMemory
{
	uint32_t dest_process_id;
	uint64_t dest_address;

	uint32_t src_process_id;
	uint64_t src_address;

	uint32_t size;
};

struct PacketGetBaseAddress
{
	uint32_t process_id;
};

struct PacketGetBasePeb
{
	uint32_t process_id;
};

struct PackedCompleted
{
	uint64_t result;
};

struct PacketHeader
{
	uint32_t   magic;
	PacketType type;
};

struct Packet
{
	PacketHeader header;
	union
	{
		PacketCopyMemory	 copy_memory;
		PacketGetBaseAddress get_base_address;
		PacketGetBasePeb get_base_peb;
		PackedCompleted		 completed;
	} data;
};

```

`EFT Usermode/MemoryOperationSample/visuals.cpp`:

```cpp
#include "visuals.h"
#include "Overlay.h"
#include "xorstr.hpp"
#include "PMemHelper.h"
#include <string>
#include "math.hpp"

PRENDER* PRENDER::Instance()
{
	static PRENDER instance;
	return &instance;
}


void PRENDER::Render()
{

	auto& local_player = EFTData::Instance()->localPlayer;

	float distance;
	float distance2;
	float MaxDrawDistance = 300.f;
	D3DCOLOR color = 0;


	for (auto& extract : EFTData::Instance()->extracts)
	{
		if (!extract.instance)
			continue;

	
		distance2 = local_player.location.Distance(extract.location);

		D2D1_POINT_2F screen_pos;
		if (WorldToScreenv2(extract.location, screen_pos))
		{
			String((int)screen_pos.x, (int)screen_pos.y, D3DCOLOR_ARGB(255, 199, 45, 199), pFont, true, _xor_("%0.2fm").operator const char* (), distance2);
			String((int)screen_pos.x, (int)screen_pos.y + 13, D3DCOLOR_ARGB(199, 45, 236, 199), pFont, true, _xor_("%s").operator const char* (), extract.name);

		}
	}

	for (auto& player : EFTData::Instance()->players)
	{
		if (!player.instance)
			continue;

		if (player.instance == local_player.instance)
			continue;

		//EFTData::Instance()->DrawSkeleton(player.instance);

		distance = local_player.location.Distance(player.location);

		if (distance > MaxDrawDistance)
			continue;

		if (distance <= 150.f)
			color = D3DCOLOR_ARGB(255, 243, 77, 77); //color red, if less than 150m
		else if (distance > 150.f && distance <= 300.f)
			color = D3DCOLOR_ARGB(255, 130, 236, 23); //color yellow, if less than 300m and greater than 150m
		

		D2D1_POINT_2F screen_pos;
		if (WorldToScreenv2(player.location, screen_pos))
		{
			String((int)screen_pos.x, (int)screen_pos.y, color, pFont, true, _xor_("%0.2fm").operator const char* (), distance);

			if(EFTData::Instance()->IsPlayer(player.instance))
			String((int)screen_pos.x, (int)screen_pos.y + 13, D3DCOLOR_ARGB(250, 255, 91, 91), pFont2, true, _xor_("3").operator const char* ());
		}

		if (WorldToScreenv2(player.headPos, screen_pos))
		{
			Circle((int)screen_pos.x, (int)screen_pos.y, 4, 0, 1, true, 32, D3DCOLOR_ARGB(255, 255, 255, 255));
		}
		
	}
}



bool PRENDER::WorldToScreenv2(const FVector& point3D, D2D1_POINT_2F& point2D)
{
	D3DXVECTOR3 _point3D = D3DXVECTOR3(point3D.x, point3D.z, point3D.y);

	auto& matrix = EFTData::Instance()->viewMatrix;

	if (EFTData::Instance()->IsAiming(EFTData::Instance()->localPlayer.instance) && EFTData::Instance()->get_mpcamera(EFTData::Instance()->localPlayer.instance))
	{
    	 matrix = EFTData::Instance()->getoptic_matrix(EFTData::Instance()->localPlayer.instance);
	}

	D3DXVECTOR3 translationVector = D3DXVECTOR3(matrix._41, matrix._42, matrix._43);
	D3DXVECTOR3 up = D3DXVECTOR3(matrix._21, matrix._22, matrix._23);
	D3DXVECTOR3 right = D3DXVECTOR3(matrix._11, matrix._12, matrix._13);

	float w = D3DXVec3Dot(&translationVector, &_point3D) + matrix._44;

	if (w < 0.098f)
		return false;

	float y = D3DXVec3Dot(&up, &_point3D) + matrix._24;
	float x = D3DXVec3Dot(&right, &_point3D) + matrix._14;


	if (EFTData::Instance()->IsAiming(EFTData::Instance()->localPlayer.instance) && EFTData::Instance()->get_mpcamera(EFTData::Instance()->localPlayer.instance))
	{
		uint64_t chain = memio->ReadChain(EFTData::Instance()->offsets.fpsCamera, { 0x30, 0x18 });

			x /= memio->read<float>(chain + 0x12C);

			if(x < 2.f)
			x /= memio->read<float>(chain + 0xAC);

			y /= memio->read<float>(chain + 0x118);

			if(y < 2.f)
			y /= memio->read<float>(chain + 0x98);
	}

	point2D.x = (1920 / 2) * (1.f + x / w);
	point2D.y = (1080 / 2) * (1.f - y / w);

	return true;
}


```

`EFT Usermode/MemoryOperationSample/visuals.h`:

```h
#pragma once
#include <Windows.h>
#include <d2d1.h>
#include "math.hpp"

#include "eftstructs.h"
#include <list>

class PRENDER
{
public:
	static PRENDER* Instance();

	void Render();
	bool WorldToScreenv2(const FVector& point3D, D2D1_POINT_2F& point2D);
private:
	
};


```

`EFT Usermode/MemoryOperationSample/xorstr.hpp`:

```hpp
#pragma once
#include <string>
#include <utility>
#include <array>


#ifdef _DEBUG

template<typename _chartype, size_t _length>
class XorStr
{
public:
	constexpr  XorStr(const _chartype(&str)[_length]) : XorStr(str, std::make_index_sequence<length>()) {}

	// returns pointer to unencrypted string 
	// caution: invalid if object gets destructed
	operator const _chartype* ()
	{
		return data;
	}

	// length in characters (not including 0-terminator)
	static constexpr size_t length = _length - 1;

private:
	template<size_t... _indices>
	constexpr XorStr(const _chartype(&str)[_length], std::index_sequence<_indices...>) : data{ str[_indices]... }, encrypted(false) {}

	_chartype data[_length];
	bool encrypted;
};

template<typename _chartype, size_t _length>
constexpr auto _xor_(_chartype const (&str)[_length])
{
	return XorStr<_chartype, _length>(str);
}


#else


template<typename _chartype, size_t _length>
class XorStr
{
public:
	constexpr  XorStr(const _chartype(&str)[_length]) : XorStr(str, std::make_index_sequence<_length>()) {}

	~XorStr() { for (size_t t = 0; t < _length; t++) data[t] = 0; }

	// returns pointer to unencrypted string 
	// cation: invalid if object gets destructed
	operator const _chartype* ()
	{
		decrypt();
		return data;
	}

	// length in characters (not including 0-terminator)
	static constexpr size_t length = _length - 1;

private:
	template<size_t... _indices>
	constexpr XorStr(const _chartype(&str)[_length], std::index_sequence<_indices...>) : data{ crypt(str[_indices], _indices)... }, encrypted(true) {}

	static constexpr auto XOR_KEY = static_cast<_chartype>(
		(__TIME__[7] - '0') +
		(__TIME__[6] - '0') * 10 +
		(__TIME__[4] - '0') * 60 +
		(__TIME__[3] - '0') * 600 +
		(__TIME__[1] - '0') * 3600 +
		(__TIME__[0] - '0') * 36000
		);

	static constexpr auto crypt(_chartype c, size_t i)
	{
		return static_cast<_chartype>(c ^ (XOR_KEY + i));
	}

	inline void decrypt()
	{
		if (encrypted)
		{
			for (size_t t = 0; t < _length; t++)
			{
				data[t] = crypt(data[t], t);
			}
			encrypted = false;
		}
	}

	_chartype data[_length];
	bool encrypted;
};


template<typename _chartype, size_t _length>
constexpr auto _xor_(_chartype const (&str)[_length])
{
	return XorStr<_chartype, _length>(str);
}

#endif
```

`README.md`:

```md
# eft-external

c++ external trainer

## Project structure
![project structure](https://i.imgur.com/xlGVS7w.png)

```