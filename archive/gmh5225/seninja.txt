Project Path: arc_gmh5225_seninja_4ijp27o_

Source Tree:

```txt
arc_gmh5225_seninja_4ijp27o_
├── LICENSE
├── README.md
├── __init__.py
├── apis.py
├── apis_ui.py
├── arch
│   ├── arch_abstract.py
│   ├── arch_armv7.py
│   ├── arch_armv7_sph.py
│   ├── arch_x86.py
│   ├── arch_x86_64.py
│   ├── arch_x86_64_sph.py
│   └── arch_x86_sph.py
├── expr
│   ├── __init__.py
│   ├── bitvector.py
│   ├── bitvector_array.py
│   ├── bool_expr.py
│   ├── interval.py
│   └── simplifier.py
├── memory
│   ├── memory_abstract.py
│   ├── memory_object.py
│   ├── registers.py
│   ├── sym_file.py
│   ├── sym_flat_memory.py
│   ├── sym_flat_memory_not_paged.py
│   └── sym_memory.py
├── models
│   ├── function_models.py
│   ├── libc.py
│   ├── linux_syscalls.py
│   ├── others.py
│   ├── string.py
│   ├── teensy.py
│   └── unistd.py
├── multipath
│   ├── fringe.py
│   └── searcher.py
├── os_models
│   ├── linux.py
│   ├── os_abstract.py
│   ├── os_file.py
│   └── windows.py
├── pictures
│   ├── buffers_view.png
│   ├── commands.png
│   ├── flareon-11.png
│   ├── memory_view.png
│   ├── register_view.png
│   └── screenshot.png
├── plugin.json
├── requirements.txt
├── seninja_globals.py
├── settings.py
├── sym_executor.py
├── sym_solver.py
├── sym_state.py
├── sym_visitor.py
├── tests
│   ├── __init__.py
│   ├── file_tests.py
│   ├── memory_tests.py
│   ├── os_linux_tests.py
│   └── os_windows_tests.py
├── ui
│   ├── __init__.py
│   ├── argv_form.py
│   ├── buffer_view.py
│   ├── hexview.py
│   ├── memory_view.py
│   └── registers_view.py
└── utility
    ├── armv7_native_handlers_util.py
    ├── binary_ninja_cache.py
    ├── bninja_util.py
    ├── exceptions.py
    ├── expr_wrap_util.py
    ├── models_util.py
    ├── string_util.py
    ├── x86_native_handlers_util.py
    └── z3_wrap_util.py

```

`LICENSE`:

```
BSD 2-Clause License

Copyright (c) 2019-2022, Luca Borzacchiello
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`README.md`:

```md
# SENinja - Symbolic Execution Plugin for Binary Ninja
![](pictures/screenshot.png)
This is a binary ninja plugin that implements a symbolic execution engine based only on z3, highly inspired by the _angr framework_ (https://angr.io/). 
The plugin is implemented as an emulator of LLIL instructions that builds and manipulates z3 formulas. 

SENinja simulates a debugger: the execution is _path driven_, only one state is _active_ and executes instructions. The other states, generated at branches, are saved in a _deferred queue_. At any time, the active state can be changed with a deferred one.

### Commands
The plugin adds the following commands:
![](pictures/commands.png)

---

More APIs can be executed through the python shell. For example, we can use the solver to _prove_ a condition for the current state:
``` python
>>> import borzacchiello_seninja as seninja
>>> s = seninja.get_current_state()
>>> s.solver.satisfiable(extra_constraints=[s.regs.eax == 3])
```
the code will check the satisfiablity of `eax == 3` given the path constraint of the active state.

Consult the [wiki](https://github.com/borzacchiello/seninja/wiki) to have more info about the commands.

### Settings

SENinja gives to the user the possibility to configure many parts of the symbolic engine (e.g. dimension of pages, symbolic memory access strategy, etc.). 
All the available settings can be accessed and modified by clicking on `Edit/Preferences/Settings` and selecting `SENinja` in the left widget.

### UI Widgets

SENinja comes with two widgets that can be used to visualize the registers and a portion of memory of the active state. The widgets can be activated by clicking on `View/Show SENinja *`. 

#### Buffers View
![](pictures/buffers_view.png)
This widget allows the creation of buffers containing symbolic data.

#### Register View
![](pictures/register_view.png)

The Register View can be used to visualize the value of the registers of the active state. The value of a register can be modifyied by double-clicking on it. The right-click menu allows to:
- Copy the content of the register
- Concretize the value of the register
- Evaluate the value of the register using the solver
- Inject symbols
- Show the register expression
- Set the register to the address of a buffer created with the buffer view

#### Memory View
![](pictures/memory_view.png)

The Memory View can be used to visualize the value of a portion of memory of the active state. By clicking on "monitor memory", the user can specify a memory address to monitor. The widget will show 512 bytes starting from that address. 
The memory view is splitted in two sections: an hexview and an ascii view. The hexview shows the hex value of each byte only if the byte is mapped and concrete. If the byte is unmapped, the characted `_` is shown; if the byte is symbolic, the widget shows the character `.`. 

Double-clicking on a byte allows the user to modify its value in the active state.
The right-click menu allows to:
- Copy the selection (in various format, e.g. little-endian, binary, etc.)
- Concretize the value of the selection
- Evaluate the value of the selection using the solver
- Inject symbols

#### Version and Dependencies
Tested with 
- binary ninja `3.0` with personal license
- python `3.9.7`
- z3 `4.8.14`

To make it work, you need to install z3 with pip:
`$ pip3 install z3-solver`

```

`__init__.py`:

```py
import traceback
import os
from binaryninja import PluginCommand
from .utility.expr_wrap_util import split_bv_in_list
from .utility.bninja_util import get_address_after_merge
from .utility.string_util import (
    int_to_str,
    str_to_int,
    as_bytes,
    get_byte,
    str_to_bv_list,
    str_to_bv,
    constraint_alphanumeric_string,
    constraint_ascii_string
)
from .models import function_models as seninja_models
from .expr import BVV, BVS, BV, And, Or, ITE
from . import settings
from .apis_ui import (
    _async_start_se,
    _async_change_current_state,
    _async_step,
    _async_continue_until_branch,
    _async_continue_until_address,
    _async_merge_states,
    _async_save_active_state,
    _async_change_active_state_ip,
    _set_run_target,
    _set_run_avoid,
    _async_run_dfs_searcher,
    _async_run_dfs_searcher_findall,
    _async_run_bfs_searcher,
    _async_reset_se,
    _async_toggle_state_history,
    sync_ui
)
from .apis import (
    start_se,
    reset_se,
    continue_until_branch,
    continue_until_address,
    setup_argv,
    execute_one_instruction,
    stop,
    get_current_state,
    get_executor,
    register_hook,
    register_logger,
    get_stdin_bv,
    get_stdout_bv,
    synthesize_triton,
    reload_settings
)

PluginCommand.register_for_address(
    "SENinja\\0   Start symbolic execution",
    "create the first state for symbolic execution at current address",
    _async_start_se
)
PluginCommand.register_for_address(
    "SENinja\\1   Change current state",
    "change current state with the deferred one at current address (if any)",
    _async_change_current_state
)
PluginCommand.register(
    "SENinja\\2   Step",
    "execute one instruction with the current state",
    _async_step
)
PluginCommand.register_for_address(
    "SENinja\\3   Merge states",
    "merge all states at current address in one state",
    _async_merge_states
)
PluginCommand.register(
    "SENinja\\4   Save active state",
    "save active state in deferred queue",
    _async_save_active_state
)
PluginCommand.register_for_address(
    "SENinja\\5   Set IP to address",
    "set ip of active state to current address",
    _async_change_active_state_ip
)
PluginCommand.register(
    "SENinja\\6   Toggle state history",
    "highlight instructions executed by the current syaye",
    _async_toggle_state_history
)
PluginCommand.register(
    "SENinja\\7   Run\\1   Continue until branch",
    "execute instructions in the current state until a fork occurs",
    _async_continue_until_branch
)
PluginCommand.register_for_address(
    "SENinja\\7   Run\\2   Continue until address",
    "execute instructions in the current state until the currently selected address is reached",
    _async_continue_until_address
)
PluginCommand.register_for_address(
    "SENinja\\7   Run\\3   Set searcher target",
    "set run target",
    _set_run_target
)
PluginCommand.register_for_address(
    "SENinja\\7   Run\\4   Set searcher avoid",
    "set run avoid",
    _set_run_avoid
)
PluginCommand.register(
    "SENinja\\7   Run\\5   Run (DFS)",
    "run (target must be set)",
    _async_run_dfs_searcher
)
PluginCommand.register(
    "SENinja\\7   Run\\6   Run (DFS) findall",
    "run (target must be set)",
    _async_run_dfs_searcher_findall
)
PluginCommand.register(
    "SENinja\\7   Run\\7   Run (BFS)",
    "run (target must be set)",
    _async_run_bfs_searcher
)
PluginCommand.register(
    "SENinja\\8   Stop",
    "stop the current exploration (if any)",
    stop
)
PluginCommand.register_for_address(
    "SENinja\\9   Reset",
    "delete all states",
    _async_reset_se
)

```

`apis.py`:

```py
from .seninja_globals import globs
from binaryninja import (
    log_alert,
    log_info,
    BackgroundTaskThread,
    PluginCommand
)
from .sym_executor import SymbolicExecutor
from .multipath import searcher
from .sym_state import State
from .models import function_models as seninja_models
from .expr import BVV, BVS, BV, And, Or, ITE
from .expr.simplifier import TritonSimplifier
from .utility.string_util import (
    int_to_str,
    str_to_int,
    as_bytes,
    get_byte,
    str_to_bv_list,
    str_to_bv
)
from .utility.expr_wrap_util import split_bv_in_list
from .utility.bninja_util import get_address_after_merge


def __check_executor():
    if globs.executor is None:
        log_alert("seninja not running")
        return False
    return True


def start_se(bv, address):
    if globs.executor is not None:
        log_alert("seninja is already running")
        return False
    globs.executor = SymbolicExecutor(bv, address)
    globs.dfs_searcher = searcher.DFSSearcher(globs.executor)
    globs.bfs_searcher = searcher.BFSSearcher(globs.executor)


def continue_until_branch():
    if not __check_executor():
        return

    k = globs.executor.fringe.last_added
    i = k
    while not globs._stop and i == k:
        globs.executor.execute_one()
        if not globs.executor.state:
            break
        i = globs.executor.fringe.last_added

    globs._stop = False
    return globs.executor.state, globs.executor.fringe.last_added


def continue_until_address(address):
    ip = globs.executor.state.get_ip()

    while ip != address:
        globs.executor.execute_one()
        if not globs.executor.state:
            break
        ip = globs.executor.state.get_ip()

    return globs.executor.state


def run_dfs(target: int, avoid: list = None):
    if not __check_executor():
        return

    def callback(s):
        if globs._stop:
            globs._stop = False
            return False
        return True

    dfs_s = searcher.DFSSearcher(globs.executor)
    dfs_s.set_target(target)
    if avoid is not None:
        for a in avoid:
            dfs_s.add_avoid(a)

    res = dfs_s.run(callback)
    return res


def run_bfs(target: int, avoid: list = None):
    if not __check_executor():
        return

    def callback(s):
        if globs._stop:
            globs._stop = False
            return False
        return True

    bfs_s = searcher.BFSSearcher(globs.executor)
    bfs_s.set_target(target)
    if avoid is not None:
        for a in avoid:
            bfs_s.add_avoid(a)

    res = bfs_s.run(callback)
    return res


def execute_one_instruction():
    if not __check_executor():
        return

    globs.executor.execute_one()

    return globs.executor.state


def change_current_state(address_or_state):
    # take only the first one at the given address. TODO
    if not __check_executor():
        return

    if not isinstance(address_or_state, State):
        state = globs.executor.fringe.get_deferred_by_address(address_or_state)
    else:
        state = address_or_state
    if state is None:
        log_alert("no such deferred state")
        return

    globs.executor.set_current_state(state)


def focus_current_state(bv):
    if not __check_executor():
        return
    bv.file.navigate(bv.file.view, globs.executor.state.get_ip())


def setup_argv(*args, argc_loc=None, argv_loc=None):
    if not __check_executor():
        return

    filename = globs.executor.view.file.filename
    state = globs.executor.state
    argv_p = BVV(state.mem.allocate((len(args) + 1) *
                                    (state.arch.bits() // 8)), state.arch.bits())
    argv_1_p = BVV(state.mem.allocate(len(filename)), state.arch.bits())
    for i, b in enumerate(str_to_bv_list(filename, terminator=True)):
        state.mem.store(argv_1_p + i, b)
    state.mem.store(argv_p, argv_1_p, state.arch.endness())

    for i, arg in enumerate(args):
        if not isinstance(arg, BV):
            print("ERROR: %s is not a BitVector" % str(arg))
            return
        argv_el_p = BVV(state.mem.allocate(
            arg.size // 8 + 1), state.arch.bits())
        state.mem.store(argv_el_p, arg)
        state.mem.store(argv_p + (i + 1) *
                        (state.arch.bits() // 8), argv_el_p, state.arch.endness())

    argc = BVV(len(args) + 1, state.arch.bits())
    if argc_loc is None:
        current_function = globs.executor.bncache.get_function(
            globs.executor.ip)
        argc_loc = current_function.calling_convention.int_arg_regs[0]

    if isinstance(argc_loc, str):
        setattr(state.regs, argc_loc, argc)
    elif isinstance(argc_loc, BV):
        state.mem.store(argc_loc, argc, state.arch.endness())
    else:
        print("ERROR: invalid argc_loc %s" % str(argc_loc))
        return

    if argv_loc is None:
        current_function = globs.executor.bncache.get_function(
            globs.executor.ip)
        argv_loc = current_function.calling_convention.int_arg_regs[1]

    if isinstance(argv_loc, str):
        setattr(state.regs, argv_loc, argv_p)
    elif isinstance(argv_loc, BV):
        state.mem.store(argv_loc, argv_p, state.arch.endness())
    else:
        print("ERROR: invalid argv_loc %s" % str(argv_loc))
        return


def constraint_bv(bv_list: list, pattern: str):
    if not __check_executor():
        return

    state = globs.executor.state
    for bv in bv_list:
        assert bv.size == 8

        expr = Or(*list(map(lambda x: bv == BVV(x, 8), pattern)))
        state.solver.add_constraints(
            expr
        )


def reset_se(bv=None):
    if not __check_executor():
        return

    globs.executor.reset()
    globs.executor = None


def stop(bv=None):
    if globs._running:  # race conditions?
        globs._stop = True


def get_current_state():
    if not __check_executor():
        return None

    return globs.executor.state


def get_executor():
    if not __check_executor():
        return None

    return globs.executor


def mk_symb_buffer(state, name, size):
    buff = BVS(name, size * 8)
    address = state.mem.allocate(size)
    state.mem.store(address, buff)
    state.symbolic_buffers.append(
        (buff, address, "")
    )
    return buff


def get_stdin_bv(state):
    r = None
    for el in state.os.get_stdin_stream():
        if r is None:
            r = el
        else:
            r = r.Concat(el)
    return r


def get_stdout_bv(state):
    r = None
    for el in state.os.get_stdout_stream():
        if r is None:
            r = el
        else:
            r = r.Concat(el)
    return r


def register_hook(address, func):
    if not __check_executor():
        return

    globs.executor.user_hooks[address] = func


def register_logger(address, func):
    if not __check_executor():
        return

    globs.executor.user_loggers[address] = func


def reload_settings():
    if not __check_executor():
        return

    globs.executor.bncache.settings = {}

triton_simplifier = None
def synthesize_triton(expr):
    global triton_simplifier
    if triton_simplifier is None:
        triton_simplifier = TritonSimplifier()

    return triton_simplifier.simplify(expr)

```

`apis_ui.py`:

```py
from .seninja_globals import globs
from .ui import (
    ui_sync_view,
    ui_reset_view,
    enable_widgets,
    disable_widgets,
    ui_set_arch
)
from binaryninja import (
    log_alert,
    log_info,
    BackgroundTaskThread,
    PluginCommand,
    enums
)
from binaryninja.interaction import get_choice_input
from .sym_executor import SymbolicExecutor
from .multipath import searcher
from .sym_state import State
from .models import function_models as seninja_models
from .expr import BVV, BVS, BV, And, Or, ITE
from .utility.string_util import (
    int_to_str,
    str_to_int,
    as_bytes,
    get_byte,
    str_to_bv_list,
    str_to_bv
)
from .utility.expr_wrap_util import split_bv_in_list
from .utility.bninja_util import get_address_after_merge
from .utility.exceptions import SENinjaError

import time
import sys

NO_COLOR = enums.HighlightStandardColor(0)
HIGHLIGHTED_HISTORY_COLOR = enums.HighlightStandardColor.YellowHighlightColor


# TODO bring all logic from here to apis.py

class TaskInBackground(BackgroundTaskThread):
    def __init__(self, bv, msg, callback):
        BackgroundTaskThread.__init__(self, msg, False)
        self.bv = bv
        self.callback = callback
        self._i = 0

    def run(self):
        self.bv.update_analysis_and_wait()
        self.callback(self)


def __check_executor():
    if globs.executor is None:
        log_alert("seninja not running")
        return False
    return True


def ui_reset_state_history_highlight():
    if len(globs.highlighted_state_history) > 0:
        # Remove highlight
        for insn in globs.highlighted_state_history:
            func = globs.executor.bncache.get_function(insn)
            func.set_auto_instr_highlight(insn, NO_COLOR)

        globs.highlighted_state_history = list()


def sync_ui(bv, delta=True):
    if not __check_executor():
        return

    ui_reset_state_history_highlight()

    globs.executor.set_colors()
    if globs.executor.state is not None:
        ui_sync_view(globs.executor.state, delta)
        bv.file.navigate(bv.file.view, globs.executor.state.get_ip())
    else:
        disable_widgets()


def reset_ui():
    if not __check_executor():
        return
    ui_reset_state_history_highlight()
    ui_reset_view()


def get_target_tt(bv):
    if globs.TARGET_TAG_TYPE is not None:
        return globs.TARGET_TAG_TYPE
    globs.TARGET_TAG_TYPE = bv.create_tag_type("searcher_target", "O")
    return globs.TARGET_TAG_TYPE


def get_avoid_tt(bv):
    if globs.AVOID_TAG_TYPE is not None:
        return globs.AVOID_TAG_TYPE
    globs.AVOID_TAG_TYPE = bv.create_tag_type("searcher_avoid", "X")
    return globs.AVOID_TAG_TYPE


def initialize_ui():
    if not __check_executor():
        return
    ui_set_arch(globs.executor.arch, globs.executor.state)


def _async_start_se(bv, address):
    if globs.executor is not None:
        log_alert("seninja is already running")
        return False

    def f(tb):
        try:
            globs.executor = SymbolicExecutor(bv, address)
        except SENinjaError as e:
            sys.stderr.write(e.message + "\n")
            globs._running = False
            return

        globs.dfs_searcher = searcher.DFSSearcher(globs.executor)
        globs.bfs_searcher = searcher.BFSSearcher(globs.executor)
        globs._running = False

    if not globs._running:
        globs._running = True
        background_task = TaskInBackground(
            bv, "seninja: starting symbolic execution", f)
        background_task.start()
        background_task.join()

        if not __check_executor():
            # something wrong
            return

        initialize_ui()
        sync_ui(bv)
        enable_widgets()


def _async_toggle_state_history(bv):
    if not __check_executor():
        return

    if globs.executor.state is None:
        return

    if globs.executor.bncache.get_setting("save_state_history") == "false":
        log_alert("State history is not saved. This can be changed in settings")
        return

    if len(globs.highlighted_state_history) > 0:
        # Remove highlight
        ui_reset_state_history_highlight()

    else:
        # Set highlight
        for insn in globs.executor.state.insn_history:
            globs.highlighted_state_history.append(insn)
            func = globs.executor.bncache.get_function(insn)
            func.set_auto_instr_highlight(insn, HIGHLIGHTED_HISTORY_COLOR)


def _set_run_target(bv, address):
    if not __check_executor():
        return

    address = get_address_after_merge(bv, address)
    func = globs.executor.bncache.get_function(address)
    if address in globs.searcher_tags:
        func.remove_auto_address_tag(address, globs.searcher_tags[address])
        del globs.searcher_tags[address]

    tt = get_target_tt(bv)
    tag = func.create_auto_tag(tt, "SENINJA: target address")
    func.add_auto_address_tag(address, tag)
    globs.searcher_tags[address] = tag
    if address in globs.dfs_searcher.avoid:
        globs.dfs_searcher.avoid.remove(address)
        globs.bfs_searcher.avoid.remove(address)

    globs.dfs_searcher.set_target(address)
    globs.bfs_searcher.set_target(address)


def _set_run_avoid(bv, address):
    if not __check_executor():
        return

    address = get_address_after_merge(bv, address)
    func = globs.executor.bncache.get_function(address)
    if address in globs.searcher_tags:
        func.remove_auto_address_tag(address, globs.searcher_tags[address])
        del globs.searcher_tags[address]

    tt = get_avoid_tt(bv)
    tag = func.create_auto_tag(tt, "SENINJA: avoid address")
    func.add_auto_address_tag(address, tag)
    globs.searcher_tags[address] = tag
    if address == globs.dfs_searcher.target:
        globs.dfs_searcher.target = None
        globs.bfs_searcher.target = None

    globs.dfs_searcher.add_avoid(address)
    globs.bfs_searcher.add_avoid(address)


def _async_run_dfs_searcher(bv):
    if not __check_executor():
        return
    if not globs.dfs_searcher.ready_to_run():
        log_alert("no target set for searcher")
        return

    timeout = globs.executor.bncache.get_setting("exploration_timeout")
    timeout = int(timeout)

    def f(tb):
        start = time.time()
        def callback(s):
            tb.progress = "seninja: running DFS @ %s" % hex(s.get_ip())
            if timeout > 0 and time.time() - start > timeout:
                # Timeout elapsed
                print("[!] Timeout elapsed (%d sec)" % timeout)
                return False
            if globs._stop:
                globs._stop = False
                return False
            return True

        globs.dfs_searcher.run(step_callback=callback)

        enable_widgets()
        sync_ui(bv, globs.executor._last_error == None)
        globs._running = False

    if not globs._running:
        globs._running = True
        disable_widgets()
        background_task = TaskInBackground(bv, "seninja: running DFS", f)
        background_task.start()


def _async_run_dfs_searcher_findall(bv):
    if not __check_executor():
        return
    if not globs.dfs_searcher.ready_to_run():
        log_alert("no target set for searcher")
        return

    timeout = globs.executor.bncache.get_setting("exploration_timeout")
    timeout = int(timeout)

    def f(tb):
        start = time.time()
        def callback(s):
            tb.progress = "seninja: running DFS @ %s" % hex(s.get_ip())
            if timeout > 0 and time.time() - start > timeout:
                # Timeout elapsed
                print("[!] Timeout elapsed (%d sec)" % timeout)
                return False
            if globs._stop:
                globs._stop = False
                return False
            return True

        globs.dfs_searcher.run(step_callback=callback, findall=True)

        enable_widgets()
        sync_ui(bv, globs.executor._last_error == None)
        globs._running = False

    if not globs._running:
        disable_widgets()
        globs._running = True
        background_task = TaskInBackground(bv, "seninja: running DFS", f)
        background_task.start()


def _async_run_bfs_searcher(bv):
    if not __check_executor():
        return

    if not globs.bfs_searcher.ready_to_run():
        log_alert("no target set for searcher")
        return

    timeout = globs.executor.bncache.get_setting("exploration_timeout")
    timeout = int(timeout)

    def f(tb):
        start = time.time()
        def callback(s):
            tb.progress = "seninja: running BFS @ %s" % hex(s.get_ip())
            if timeout > 0 and time.time() - start > timeout:
                # Timeout elapsed
                print("[!] Timeout elapsed (%d sec)" % timeout)
                return False
            if globs._stop:
                globs._stop = False
                return False
            return True

        globs.bfs_searcher.run(callback)

        enable_widgets()
        sync_ui(bv, globs.executor._last_error == None)
        globs._running = False

    if not globs._running:
        disable_widgets()
        globs._running = True
        background_task = TaskInBackground(bv, "seninja: running BFS", f)
        background_task.start()


def _async_step(bv):
    if not __check_executor():
        return

    def f(tb):
        disable_widgets()

        globs.executor.execute_one()

        sync_ui(bv, globs.executor._last_error == None)
        enable_widgets()
        globs._running = False

    if not globs._running:
        globs._running = True
        background_task = TaskInBackground(bv, "seninja: stepping", f)
        background_task.start()


def _async_continue_until_branch(bv):
    if not __check_executor():
        return

    timeout = globs.executor.bncache.get_setting("exploration_timeout")
    timeout = int(timeout)

    def f(tb):
        disable_widgets()

        start = time.time()
        k = len(globs.executor.fringe.deferred)
        i = k
        count = 0
        while not globs._stop and i == k:
            globs.executor.execute_one()
            if not globs.executor.state:
                break

            if timeout > 0 and time.time() - start > timeout:
                # Timeout elapsed
                print("[!] Timeout elapsed (%d sec)" % timeout)
                break

            i = len(globs.executor.fringe.deferred)
            ip = globs.executor.state.get_ip()
            count = (count+1) % 20
            if count == 0:
                globs.executor.set_colors()
            tb.progress = "seninja: continue until branch: %s" % hex(ip)

        sync_ui(bv, globs.executor._last_error == None)
        enable_widgets()
        globs._running = False
        globs._stop = False

    if not globs._running:
        globs._running = True
        background_task = TaskInBackground(
            bv, "seninja: continue until branch", f)
        background_task.start()


def _async_continue_until_address(bv, address):
    if not __check_executor():
        return

    timeout = globs.executor.bncache.get_setting("exploration_timeout")
    timeout = int(timeout)

    address = get_address_after_merge(bv, address)

    def f(tb):
        disable_widgets()
        ip = globs.executor.state.get_ip()
        start = time.time()

        count = 0
        while not globs._stop and ip != address:
            globs.executor.execute_one()
            if not globs.executor.state:
                break

            if timeout > 0 and time.time() - start > timeout:
                # Timeout elapsed
                print("[!] Timeout elapsed (%d sec)" % timeout)
                break

            ip = globs.executor.state.get_ip()
            count = (count+1) % 20
            if count == 0:
                globs.executor.set_colors()
            tb.progress = "seninja: continue until address: %s" % hex(ip)

        sync_ui(bv, globs.executor._last_error == None)
        enable_widgets()
        globs._running = False
        globs._stop = False

    if not globs._running:
        globs._running = True
        background_task = TaskInBackground(
            bv, "seninja: continue until address", f)
        background_task.start()


def _async_merge_states(bv, address):
    # merge all states at address and put them in current state. Current state must be at address
    if not __check_executor():
        return

    if globs.executor.state.get_ip() != address:
        log_alert("current state is not at this address")
        return

    to_be_merged_all = globs.executor.fringe.get_all_deferred_by_address(
        address)
    if to_be_merged_all is None:
        log_alert("no deferred state at this address")
        return

    mergeable, not_mergeable = globs.executor.extract_mergeable_with_current_state(
        to_be_merged_all)
    if len(not_mergeable) > 0:
        print(
            "WARNING: %d states was not merged since they deviate from the current state after executing the current instruction" % len(not_mergeable))
        globs.executor.fringe._deferred[address] = not_mergeable

    if len(mergeable) == 0:
        return
    to_be_merged = mergeable

    def f(tb):
        disable_widgets()
        tot = len(to_be_merged)
        i = 0
        for s in to_be_merged:
            globs.executor.state.merge(s)
            i += 1
            tb.progress = "seninja: merging states %d/%d" % (i, tot)

        globs.executor.delete_comment_for_address(address)
        sync_ui(bv)
        enable_widgets()
        globs._running = False

    if not globs._running:
        globs._running = True
        background_task = TaskInBackground(bv, "seninja: merging states", f)
        background_task.start()


def _async_change_current_state(bv, address):
    if not __check_executor():
        return

    states = globs.executor.fringe.get_list_deferred_by_address(address)
    if len(states) == 0:
        log_alert("no such deferred state")
        return
    if len(states) == 1:
        state = globs.executor.fringe.get_deferred_by_address(address)
    else:
        state_idx = get_choice_input(
            "Select state", "states", list(map(str, states)))
        state = globs.executor.fringe.get_deferred_by_address(
            address, state_idx)

    disable_widgets()
    globs.executor.delete_comment_for_address(address)
    globs.executor.set_current_state(state)
    sync_ui(bv, delta=False)
    enable_widgets()


def _async_save_active_state(bv):
    if not __check_executor():
        return

    def f(tb):
        disable_widgets()

        saved_state = globs.executor.state.copy()
        globs.executor.put_in_deferred(saved_state)

        enable_widgets()
        globs._running = False

    if not globs._running:
        globs._running = True
        background_task = TaskInBackground(
            bv, "seninja: saving current state", f)
        background_task.start()


def _async_change_active_state_ip(bv, address):
    if not __check_executor():
        return

    def f(tb):
        disable_widgets()

        state = globs.executor.state
        state.set_ip(address)
        func_name = globs.executor.bncache.get_function_name(address)
        state.llil_ip = globs.executor.bncache.get_llil_address(
            func_name, address)

        globs.executor.state = None
        globs.executor.set_current_state(state)

        sync_ui(bv, delta=False)

        enable_widgets()
        globs._running = False

    if not globs._running:
        globs._running = True
        background_task = TaskInBackground(
            bv, "seninja: changing current state", f)
        background_task.start()


def _async_reset_se(bv, address):
    if not __check_executor():
        return

    def f(tb):
        for addr in globs.searcher_tags:
            tag = globs.searcher_tags[addr]
            func = globs.executor.bncache.get_function(addr)
            func.remove_auto_address_tag(addr, tag)
        globs.searcher_tags = dict()

        globs.executor.reset()
        globs.executor = None
        globs._running = False

    if not globs._running:
        globs._running = True

        disable_widgets()
        reset_ui()
        # just an hack to redraw widgets. find another way
        bv.file.navigate(bv.file.view, address)

        background_task = TaskInBackground(
            bv, "seninja: resetting symbolic execution", f)
        background_task.start()

```

`arch/arch_abstract.py`:

```py
class Arch(object):  # abstract class
    REGS = None

    def __init__(self):
        raise NotImplementedError

    def bits(self):
        raise NotImplementedError

    def regs_data(self):
        raise NotImplementedError

    def reg_names(self):
        raise NotImplementedError

    def flags_data(self):
        raise NotImplementedError

    def flags_default(self, flag):
        raise NotImplementedError

    def endness(self):
        raise NotImplementedError

    def save_return_address(self, state, return_address):
        raise NotImplementedError

    def get_return_address(self, state):
        raise NotImplementedError

    def getip_reg(self):
        raise NotImplementedError

    def get_base_pointer_reg(self):
        raise NotImplementedError

    def get_stack_pointer_reg(self):
        raise NotImplementedError

    def get_argument_regs(self, calling_convention):
        raise NotImplementedError

    def save_result_value(self, state, calling_convention, value):
        raise NotImplementedError

    def get_flag_cond_lambda(self, cond: str):
        raise NotImplementedError

    def execute_special_handler(self, disasm_str, sv):
        raise NotImplementedError

    @staticmethod
    def fix_reg_addressess(obj):
        assert obj.REGS is not None

        curr_addr = 0
        for reg in obj.REGS:
            if 'addr' in obj.REGS[reg]:
                # already done
                break
            obj.REGS[reg]['addr'] = curr_addr
            curr_addr += obj.REGS[reg]['size']


class SpecialInstructionHandler(object):
    def __init__(self):
        raise NotImplementedError  # do not instantiate this class

    def handle_instruction(self, disasm_str: str, sv):
        inst_name = disasm_str.split(" ")[0]
        parameters = ''.join(disasm_str.split(" ")[1:]).split(",")

        handle_name = "{}_handler".format(inst_name)
        if hasattr(self, handle_name):
            return getattr(self, handle_name)(sv, parameters)
        return False

```

`arch/arch_armv7.py`:

```py
from .arch_abstract import Arch
from .arch_armv7_sph import ArmV7SPH


class ArmV7Arch(Arch):
    REGS = {
        'r0': {
            'size': 4,
            'sub': {}
        },
        'r1': {
            'size': 4,
            'sub': {}
        },
        'r2': {
            'size': 4,
            'sub': {}
        },
        'r3': {
            'size': 4,
            'sub': {}
        },
        'r4': {
            'size': 4,
            'sub': {}
        },
        'r5': {
            'size': 4,
            'sub': {}
        },
        'r6': {
            'size': 4,
            'sub': {}
        },
        'r7': {
            'size': 4,
            'sub': {}
        },
        'r8': {
            'size': 4,
            'sub': {}
        },
        'r9': {
            'size': 4,
            'sub': {}
        },
        'r10': {
            'size': 4,
            'sub': {}
        },
        'r11': {
            'size': 4,
            'sub': {}
        },
        'r12': {
            'size': 4,
            'sub': {}
        },
        'sp': {
            'size': 4,
            'sub': {}
        },
        'lr': {
            'size': 4,
            'sub': {}
        },
        'pc': {
            'size': 4,
            'sub': {}
        }
    }

    FLAGS = {'n': 0, 'z': 0, 'c': 0, 'v': 0, 'e': 0, 't': 0, 'm': 0, 'j': 0}

    REG_NAMES = [
        "pc", "sp", "r0", "r1", "r2",  "r3",  "r4",  "r5",
        "r6", "r7", "r8", "r9", "r10", "r11", "r12", "lr"
    ]

    FLAGS_CONDS = {}

    sph = ArmV7SPH()

    def __init__(self):
        self._bits = 32

    def bits(self):
        return self._bits

    def regs_data(self):
        return ArmV7Arch.REGS

    def reg_names(self):
        return ArmV7Arch.REG_NAMES

    def flags_data(self):
        return ArmV7Arch.FLAGS

    def flags_default(self, flag):
        return None

    def endness(self):
        # is this correct? Not always...
        return 'little'

    def getip_reg(self):
        return 'pc'

    def get_base_pointer_reg(self):
        return 'r11'

    def get_stack_pointer_reg(self):
        return 'sp'

    def save_return_address(self, state, return_address):
        state.regs.lr = return_address

    def get_return_address(self, state):
        return state.regs.lr

    def get_argument_regs(self, calling_convention):
        assert calling_convention == 'cdecl'
        return ['r0', 'r1', 'r2', 'r3']

    def save_result_value(self, state, calling_convention, value):
        if value.size == 32:
            state.regs.r0 = value
        else:
            state.regs.r0 = value.ZeroExt(32 - value.size)

    def get_flag_cond_lambda(self, cond: str, state):
        assert cond in ArmV7Arch.FLAGS_CONDS
        return ArmV7Arch.FLAGS_CONDS[cond]

    def execute_special_handler(self, disasm_str, sv):
        res = ArmV7Arch.sph.handle_instruction(disasm_str, sv)
        return res


Arch.fix_reg_addressess(ArmV7Arch)

```

`arch/arch_armv7_sph.py`:

```py
from ..utility.armv7_native_handlers_util import (
    parse_mnemonic, parse_immediate,
    parse_rot_shift, ArmV7Mnemonic,
    ArmV7RotShift
)
from .arch_abstract import SpecialInstructionHandler


class ArmV7SPH(SpecialInstructionHandler):
    def __init__(self):
        pass

    # override
    def handle_instruction(self, disasm_str: str, sv):
        inst_name = disasm_str.split(" ")[0]
        parameters = ''.join(disasm_str.split(" ")[1:]).split(",")

        parsed_mnemonic = parse_mnemonic(inst_name)
        handle_name = "{}_handler".format(parsed_mnemonic.mnemonic)

        if hasattr(self, handle_name):
            return getattr(self, handle_name)(sv, parsed_mnemonic, parameters)
        return False

    def uxtb_handler(self, sv, parsed_mnemonic, parameters):
        dst_reg = parameters[0]
        src_reg = parameters[1]  # cannot be an immediate, right?

        src = getattr(sv.state.regs, src_reg)
        if len(parameters) == 3:
            # there is a rotation/shift
            op, v = parameters[2].split("#")
            if op == "ror":
                v = int(v)
                src.RotateRight(v)
            else:
                assert False  # TODO

        setattr(sv.state.regs, dst_reg, src.Extract(7, 0).ZeroExt(24))

        return True

```

`arch/arch_x86.py`:

```py
import z3

from .arch_abstract import Arch
from .arch_x86_sph import ArchX86SPH


class x86Arch(Arch):
    REGS = {
        'eax': {
            'size': 4,
            'sub': {
                'ax':  {'offset': 2,  'size': 2},
                'al':  {'offset': 3,  'size': 1},
                'ah':  {'offset': 2,  'size': 1}
            }
        },
        'ebx': {
            'size': 4,
            'sub': {
                'bx':  {'offset': 2, 'size': 2},
                'bl':  {'offset': 3, 'size': 1},
                'bh':  {'offset': 2, 'size': 1}
            }
        },
        'ecx': {
            'size': 4,
            'sub': {
                'cx':  {'offset': 2, 'size': 2},
                'cl':  {'offset': 3, 'size': 1},
                'ch':  {'offset': 2, 'size': 1}
            }
        },
        'edx': {
            'size': 4,
            'sub': {
                'dx':  {'offset': 2, 'size': 2},
                'dl':  {'offset': 3, 'size': 1},
                'dh':  {'offset': 2, 'size': 1}
            }
        },
        'esi': {
            'size': 4,
            'sub': {
                'si':  {'offset': 2, 'size': 2},
                'sil': {'offset': 3, 'size': 1},
            }
        },
        'edi': {
            'size': 4,
            'sub': {
                'di':  {'offset': 2, 'size': 2},
                'dil': {'offset': 3, 'size': 1}
            }
        },
        'ebp': {
            'size': 4,
            'sub': {
                'bp':  {'offset': 2, 'size': 2},
                'bpl': {'offset': 3, 'size': 1}
            }
        },
        'esp': {
            'size': 4,
            'sub': {
                'sp':  {'offset': 2, 'size': 2},
                'spl': {'offset': 3, 'size': 1}
            }
        },
        'eip': {
            'size': 4,
            'sub': {
                'ip':  {'offset': 2, 'size': 2}
            }
        },
        'eflags': {
            'size': 4,
            'sub': {
                'flags':  {'offset': 2, 'size': 2}
            }
        },
        'gsbase': {
            'size': 4,
            'sub': {}
        },
        'fsbase': {
            'size': 4,
            'sub': {}
        }
    }

    FLAGS = {'c': 0, 'p': 2, 'a': 4, 'z': 6, 's': 7, 'd': 10, 'o': 11, 'c0': 32,
             'c1': 33, 'c2': 34, 'c3': 35}

    REG_NAMES = [
        "eip", "esp", "ebp", "eax", "ebx", "ecx", "edx", "esi", "edi",
    ]

    FLAGS_CONDS = {
        'E': lambda s: s.regs.flags['z'] == 0,
        'NE': lambda s: s.regs.flags['z'] == 1,
        'NEG': lambda s: s.regs.flags['s'] == 1,
        'POS': lambda s: s.regs.flags['s'] == 0,
        'O': lambda s: s.regs.flags['o'] == 1,
        'NO': lambda s: s.regs.flags['o'] == 0,
        'SGE': lambda s: s.regs.flags['s'] == s.regs.flags['o'],
        'SGT': lambda s: z3.And(
            s.regs.flags['z'] == 0,
            s.regs.flags['s'] == s.regs.flags['o']),
        'SLE': lambda s: z3.And(
            s.regs.flags['z'] == 1,
            s.regs.flags['s'] != s.regs.flags['o']),
        'SLT': lambda s: s.regs.flags['s'] != s.regs.flags['o'],
        'UGE': lambda s: s.regs.flags['c'] == 0,
        'UGT': lambda s: z3.And(
            s.regs.flags['c'] == 0,
            s.regs.flags['z'] == 0),
        'ULE': lambda s: z3.Or(
            s.regs.flags['z'] == 1,
            s.regs.flags['c'] == 1),
        'ULT': lambda s: s.regs.flags['c'] == 1
    }

    sph = ArchX86SPH()

    def __init__(self):
        self._bits = 32

    def bits(self):
        return self._bits

    def regs_data(self):
        return x86Arch.REGS

    def reg_names(self):
        return x86Arch.REG_NAMES

    def flags_data(self):
        return x86Arch.FLAGS

    def flags_default(self, flag):
        if flag == 'd':
            return 0
        return None

    def endness(self):
        return 'little'

    def getip_reg(self):
        return 'eip'

    def get_base_pointer_reg(self):
        return 'ebp'

    def get_stack_pointer_reg(self):
        return 'esp'

    def save_return_address(self, state, return_address):
        state.stack_push(return_address)

    def get_return_address(self, state):
        return state.stack_pop()

    def save_result_value(self, state, calling_convention, value):
        if value.size == 8:
            state.regs.al = value
        elif value.size == 16:
            state.regs.ax = value
        elif value.size == 32:
            state.regs.eax = value
        else:
            raise Exception("Wrong size in save_result_value")

    def get_argument_regs(self, calling_convention):
        assert calling_convention == 'cdecl'
        return []

    def get_flag_cond_lambda(self, cond: str):
        assert cond in x86Arch.FLAGS_CONDS
        return x86Arch.FLAGS_CONDS[cond]

    def execute_special_handler(self, disasm_str, sv):
        res = x86Arch.sph.handle_instruction(disasm_str, sv)
        return res


Arch.fix_reg_addressess(x86Arch)

```

`arch/arch_x86_64.py`:

```py
from ..expr import And, Or
from .arch_abstract import Arch
from .arch_x86_64_sph import ArchX8664SPH


class x8664Arch(Arch):
    REGS = {
        'rax': {
            'size': 8,
            'sub': {
                'eax': {'offset': 4,  'size': 4},
                'ax':  {'offset': 6,  'size': 2},
                'al':  {'offset': 7,  'size': 1},
                'ah':  {'offset': 6,  'size': 1}
            }
        },
        'rbx': {
            'size': 8,
            'sub': {
                'ebx': {'offset': 4, 'size': 4},
                'bx':  {'offset': 6, 'size': 2},
                'bl':  {'offset': 7, 'size': 1},
                'bh':  {'offset': 6, 'size': 1}
            }
        },
        'rcx': {
            'size': 8,
            'sub': {
                'ecx': {'offset': 4, 'size': 4},
                'cx':  {'offset': 6, 'size': 2},
                'cl':  {'offset': 7, 'size': 1},
                'ch':  {'offset': 6, 'size': 1}
            }
        },
        'rdx': {
            'size': 8,
            'sub': {
                'edx': {'offset': 4, 'size': 4},
                'dx':  {'offset': 6, 'size': 2},
                'dl':  {'offset': 7, 'size': 1},
                'dh':  {'offset': 6, 'size': 1}
            }
        },
        'rsi': {
            'size': 8,
            'sub': {
                'esi': {'offset': 4, 'size': 4},
                'si':  {'offset': 6, 'size': 2},
                'sil': {'offset': 7, 'size': 1},
            }
        },
        'rdi': {
            'size': 8,
            'sub': {
                'edi': {'offset': 4, 'size': 4},
                'di':  {'offset': 6, 'size': 2},
                'dil': {'offset': 7, 'size': 1}
            }
        },
        'rbp': {
            'size': 8,
            'sub': {
                'ebp': {'offset': 4, 'size': 4},
                'bp':  {'offset': 6, 'size': 2},
                'bpl': {'offset': 7, 'size': 1}
            }
        },
        'rsp': {
            'size': 8,
            'sub': {
                'esp': {'offset': 4, 'size': 4},
                'sp':  {'offset': 6, 'size': 2},
                'spl': {'offset': 7, 'size': 1}
            }
        },
        'rip': {
            'size': 8,
            'sub': {
                'eip': {'offset': 4, 'size': 4},
                'ip':  {'offset': 6, 'size': 2},
            }
        },
        'rflags': {
            'size': 8,
            'sub': {
                'eflags': {'offset': 4, 'size': 4},
                'flags':  {'offset': 6, 'size': 2}
            }
        },
        'fsbase': {
            'size': 8,
            'sub': {}
        },
        'gsbase': {
            'size': 8,
            'sub': {}
        },
        'r8': {
            'size': 8,
            'sub': {
                'r8d': {'offset': 4, 'size': 4},
                'r8w': {'offset': 6, 'size': 2},
                'r8b': {'offset': 7, 'size': 1}
            }
        },
        'r9': {
            'size': 8,
            'sub': {
                'r9d': {'offset': 4, 'size': 4},
                'r9w': {'offset': 6, 'size': 2},
                'r9b': {'offset': 7, 'size': 1}
            }
        },
        'r10': {
            'size': 8,
            'sub': {
                'r10d': {'offset': 4, 'size': 4},
                'r10w': {'offset': 6, 'size': 2},
                'r10b': {'offset': 7, 'size': 1}
            }
        },
        'r11': {
            'size': 8,
            'sub': {
                'r11d': {'offset': 4, 'size': 4},
                'r11w': {'offset': 6, 'size': 2},
                'r11b': {'offset': 7, 'size': 1}
            }
        },
        'r12': {
            'size': 8,
            'sub': {
                'r12d': {'offset': 4, 'size': 4},
                'r12w': {'offset': 6, 'size': 2},
                'r12b': {'offset': 7, 'size': 1}
            }
        },
        'r13': {
            'size': 8,
            'sub': {
                'r13d': {'offset': 4, 'size': 4},
                'r13w': {'offset': 6, 'size': 2},
                'r13b': {'offset': 7, 'size': 1}
            }
        },
        'r14': {
            'size': 8,
            'sub': {
                'r14d': {'offset': 4, 'size': 4},
                'r14w': {'offset': 6, 'size': 2},
                'r14b': {'offset': 7, 'size': 1}
            }
        },
        'r15': {
            'size': 8,
            'sub': {
                'r15d': {'offset': 4, 'size': 4},
                'r15w': {'offset': 6, 'size': 2},
                'r15b': {'offset': 7, 'size': 1}
            }
        },
        'zmm0': {
            'size': 64,
            'sub': {
                'ymm0': {'offset': 32, 'size': 32},
                'xmm0': {'offset': 48, 'size': 16}
            }
        },
        'zmm1': {
            'size': 64,
            'sub': {
                'ymm1': {'offset': 32, 'size': 32},
                'xmm1': {'offset': 48, 'size': 16}
            }
        },
        'zmm2': {
            'size': 64,
            'sub': {
                'ymm2': {'offset': 32, 'size': 32},
                'xmm2': {'offset': 48, 'size': 16}
            }
        },
        'zmm3': {
            'size': 64,
            'sub': {
                'ymm3': {'offset': 32, 'size': 32},
                'xmm3': {'offset': 48, 'size': 16}
            }
        },
        'zmm4': {
            'size': 64,
            'sub': {
                'ymm4': {'offset': 32, 'size': 32},
                'xmm4': {'offset': 48, 'size': 16}
            }
        },
        'zmm5': {
            'size': 64,
            'sub': {
                'ymm5': {'offset': 32, 'size': 32},
                'xmm5': {'offset': 48, 'size': 16}
            }
        },
        'zmm6': {
            'size': 64,
            'sub': {
                'ymm6': {'offset': 32, 'size': 32},
                'xmm6': {'offset': 48, 'size': 16}
            }
        },
        'zmm7': {
            'size': 64,
            'sub': {
                'ymm7': {'offset': 32, 'size': 32},
                'xmm7': {'offset': 48, 'size': 16}
            }
        },
        'zmm8': {
            'size': 64,
            'sub': {
                'ymm8': {'offset': 32, 'size': 32},
                'xmm8': {'offset': 48, 'size': 16}
            }
        },
        'zmm9': {
            'size': 64,
            'sub': {
                'ymm9': {'offset': 32, 'size': 32},
                'xmm9': {'offset': 48, 'size': 16}
            }
        },
        'zmm10': {
            'size': 64,
            'sub': {
                'ymm10': {'offset': 32, 'size': 32},
                'xmm10': {'offset': 48, 'size': 16}
            }
        },
        'zmm11': {
            'size': 64,
            'sub': {
                'ymm11': {'offset': 32, 'size': 32},
                'xmm11': {'offset': 48, 'size': 16}
            }
        },
        'zmm12': {
            'size': 64,
            'sub': {
                'ymm12': {'offset': 32, 'size': 32},
                'xmm12': {'offset': 48, 'size': 16}
            }
        },
        'zmm13': {
            'size': 64,
            'sub': {
                'ymm13': {'offset': 32, 'size': 32},
                'xmm13': {'offset': 48, 'size': 16}
            }
        },
        'zmm14': {
            'size': 64,
            'sub': {
                'ymm14': {'offset': 32, 'size': 32},
                'xmm14': {'offset': 48, 'size': 16}
            }
        },
        'zmm15': {
            'size': 64,
            'sub': {
                'ymm15': {'offset': 32, 'size': 32},
                'xmm15': {'offset': 48, 'size': 16}
            }
        },
        'zmm16': {
            'size': 64,
            'sub': {
                'ymm16': {'offset': 32, 'size': 32},
                'xmm16': {'offset': 48, 'size': 16}
            }
        },
        'zmm17': {
            'size': 64,
            'sub': {
                'ymm17': {'offset': 32, 'size': 32},
                'xmm17': {'offset': 48, 'size': 16}
            }
        },
        'zmm18': {
            'size': 64,
            'sub': {
                'ymm18': {'offset': 32, 'size': 32},
                'xmm18': {'offset': 48, 'size': 16}
            }
        },
        'zmm19': {
            'size': 64,
            'sub': {
                'ymm19': {'offset': 32, 'size': 32},
                'xmm19': {'offset': 48, 'size': 16}
            }
        },
        'zmm20': {
            'size': 64,
            'sub': {
                'ymm20': {'offset': 32, 'size': 32},
                'xmm20': {'offset': 48, 'size': 16}
            }
        },
        'zmm21': {
            'size': 64,
            'sub': {
                'ymm21': {'offset': 32, 'size': 32},
                'xmm21': {'offset': 48, 'size': 16}
            }
        },
        'zmm22': {
            'size': 64,
            'sub': {
                'ymm22': {'offset': 32, 'size': 32},
                'xmm22': {'offset': 48, 'size': 16}
            }
        },
        'zmm23': {
            'size': 64,
            'sub': {
                'ymm23': {'offset': 32, 'size': 32},
                'xmm23': {'offset': 48, 'size': 16}
            }
        },
        'zmm24': {
            'size': 64,
            'sub': {
                'ymm24': {'offset': 32, 'size': 32},
                'xmm24': {'offset': 48, 'size': 16}
            }
        },
        'zmm25': {
            'size': 64,
            'sub': {
                'ymm25': {'offset': 32, 'size': 32},
                'xmm25': {'offset': 48, 'size': 16}
            }
        },
        'zmm26': {
            'size': 64,
            'sub': {
                'ymm26': {'offset': 32, 'size': 32},
                'xmm26': {'offset': 48, 'size': 16}
            }
        },
        'zmm27': {
            'size': 64,
            'sub': {
                'ymm27': {'offset': 32, 'size': 32},
                'xmm27': {'offset': 48, 'size': 16}
            }
        },
        'zmm28': {
            'size': 64,
            'sub': {
                'ymm28': {'offset': 32, 'size': 32},
                'xmm28': {'offset': 48, 'size': 16}
            }
        },
        'zmm29': {
            'size': 64,
            'sub': {
                'ymm29': {'offset': 32, 'size': 32},
                'xmm29': {'offset': 48, 'size': 16}
            }
        },
        'zmm30': {
            'size': 64,
            'sub': {
                'ymm30': {'offset': 32, 'size': 32},
                'xmm30': {'offset': 48, 'size': 16}
            }
        },
        'zmm31': {
            'size': 64,
            'sub': {
                'ymm31': {'offset': 32, 'size': 32},
                'xmm31': {'offset': 48, 'size': 16}
            }
        }
    }

    FLAGS = {'c': 0, 'p': 2, 'a': 4, 'z': 6, 's': 7, 'd': 10,
             'o': 11, 'c0': 32, 'c1': 33, 'c2': 34, 'c3': 35}

    REG_NAMES = [
        "rip", "rsp", "rbp", "rax", "rbx", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11", "r12", "r13",
        "r14", "r15", "zmm0", "zmm1", "zmm2",
        "zmm3", "zmm4", "zmm5", "zmm6", "zmm7", "zmm8", "zmm9", "zmm10", "zmm11", "zmm12", "zmm13", "zmm14",
        "zmm15", "zmm16", "zmm17", "zmm18", "zmm19", "zmm20", "zmm21", "zmm22", "zmm23", "zmm24", "zmm25",
        "zmm26", "zmm27", "zmm28", "zmm29", "zmm30", "zmm31"
    ]

    FLAGS_CONDS = {
        'E': lambda s: s.regs.flags['z'] == 0,
        'NE': lambda s: s.regs.flags['z'] == 1,
        'NEG': lambda s: s.regs.flags['s'] == 1,
        'POS': lambda s: s.regs.flags['s'] == 0,
        'O': lambda s: s.regs.flags['o'] == 1,
        'NO': lambda s: s.regs.flags['o'] == 0,
        'SGE': lambda s: s.regs.flags['s'] == s.regs.flags['o'],
        'SGT': lambda s: And(
            s.regs.flags['z'] == 0,
            s.regs.flags['s'] == s.regs.flags['o']),
        'SLE': lambda s: And(
            s.regs.flags['z'] == 1,
            s.regs.flags['s'] != s.regs.flags['o']),
        'SLT': lambda s: s.regs.flags['s'] != s.regs.flags['o'],
        'UGE': lambda s: s.regs.flags['c'] == 0,
        'UGT': lambda s: And(
            s.regs.flags['c'] == 0,
            s.regs.flags['z'] == 0),
        'ULE': lambda s: Or(
            s.regs.flags['z'] == 1,
            s.regs.flags['c'] == 1),
        'ULT': lambda s: s.regs.flags['c'] == 1
    }

    sph = ArchX8664SPH()

    def __init__(self):
        self._bits = 64

    def bits(self):
        return self._bits

    def regs_data(self):
        return x8664Arch.REGS

    def reg_names(self):
        return x8664Arch.REG_NAMES

    def flags_data(self):
        return x8664Arch.FLAGS

    def flags_default(self, flag):
        if flag == 'd':
            return 0
        return None

    def endness(self):
        return 'little'

    def getip_reg(self):
        return 'rip'

    def get_base_pointer_reg(self):
        return 'rbp'

    def get_stack_pointer_reg(self):
        return 'rsp'

    def save_return_address(self, state, return_address):
        state.stack_push(return_address)

    def get_return_address(self, state):
        return state.stack_pop()

    def get_argument_regs(self, calling_convention):
        if calling_convention == 'cdecl':
            return []
        elif calling_convention == 'sysv':
            return ['rdi', 'rsi', 'rdx', 'rcx', 'r8', 'r9']
        elif calling_convention == 'win64':
            return ['rcx', 'rdx', 'r8', 'r9']
        raise Exception("Unknown calling convention {name}".format(
            name=calling_convention
        ))

    def save_result_value(self, state, calling_convention, value):
        if value.size == 8:
            state.regs.al = value
        elif value.size == 16:
            state.regs.ax = value
        elif value.size == 32:
            state.regs.rax = value.ZeroExt(32)
        elif value.size == 64:
            state.regs.rax = value
        else:
            raise Exception("Wrong size in save_result_value")

    def get_flag_cond_lambda(self, cond: str, state):
        assert cond in x8664Arch.FLAGS_CONDS
        return x8664Arch.FLAGS_CONDS[cond]

    def execute_special_handler(self, disasm_str, sv):
        res = x8664Arch.sph.handle_instruction(disasm_str, sv)
        return res


Arch.fix_reg_addressess(x8664Arch)

```

`arch/arch_x86_64_sph.py`:

```py
from .arch_x86_sph import ArchX86SPH
from ..utility.x86_native_handlers_util import (
    get_src, store_to_dst
)
from ..utility.expr_wrap_util import split_bv_in_list
from ..expr import BVArray, ITE, BVV


class ArchX8664SPH(ArchX86SPH):
    def __init__(self):
        self._vpermd_idx = 0
        self._vpshufb_idx = 0

    def cpuid_handler(self, sv, parameters):
        return self.cpuid_util(sv, 64)

    def xgetbv_handler(self, sv, parameters):
        sv.state.regs.rax = BVV(7, 64)
        sv.state.regs.rdx = BVV(0, 64)
        return True

    # --- AVX2 ---
    def vmovdqu_handler(self, sv, parameters):
        dst_p = parameters[0]
        src_p = parameters[1]

        src = get_src(sv.state, src_p)
        store_to_dst(sv.state, dst_p, src)

        return True

    def vpmaddubsw_handler(self, sv, parameters):
        dst_p = parameters[0]
        src1_p = parameters[1]
        src2_p = parameters[2]

        src1 = get_src(sv.state, src1_p)
        src1_bytes = split_bv_in_list(src1, 8)
        src2 = get_src(sv.state, src2_p)
        src2_bytes = split_bv_in_list(src2, 8)

        res = None
        for i in range(0, 32, 2):
            a1 = src1_bytes[i].ZeroExt(8)
            a2 = src1_bytes[i+1].ZeroExt(8)
            b1 = src2_bytes[i].SignExt(8)
            b2 = src2_bytes[i+1].SignExt(8)

            w1 = a1 * b1
            w2 = a2 * b2

            res = (
                w1 + w2
            ) if res is None else (
                (w1 + w2).Concat(
                    res
                )
            )

        store_to_dst(sv.state, dst_p, res)
        return True

    def vpmaddwd_handler(self, sv, parameters):
        dst_p = parameters[0]
        src1_p = parameters[1]
        src2_p = parameters[2]

        src1 = get_src(sv.state, src1_p)
        src1_words = split_bv_in_list(src1, 16)
        src2 = get_src(sv.state, src2_p)
        src2_words = split_bv_in_list(src2, 16)

        res = None
        for i in range(0, 16, 2):
            a1 = src1_words[i].SignExt(16)
            a2 = src1_words[i+1].SignExt(16)
            b1 = src2_words[i].SignExt(16)
            b2 = src2_words[i+1].SignExt(16)

            d1 = a1 * b1
            d2 = a2 * b2

            res = (
                d1 + d2
            ) if res is None else (
                (d1 + d2).Concat(
                    res
                )
            )

        store_to_dst(sv.state, dst_p, res)
        return True

    def vpaddd_handler(self, sv, parameters):
        dst_p = parameters[0]
        src1_p = parameters[1]
        src2_p = parameters[2]

        src1 = get_src(sv.state, src1_p)
        src1_dwords = split_bv_in_list(src1, 32)
        src2 = get_src(sv.state, src2_p)
        src2_dwords = split_bv_in_list(src2, 32)

        res = None
        for i in range(32 // 4):
            res = (
                src1_dwords[i] + src2_dwords[i]
            ) if res is None else (
                (src1_dwords[i] + src2_dwords[i]).Concat(
                    res
                )
            )

        store_to_dst(sv.state, dst_p, res)
        return True

    def vpaddb_handler(self, sv, parameters):
        dst_p = parameters[0]
        src1_p = parameters[1]
        src2_p = parameters[2]

        src1 = get_src(sv.state, src1_p)
        src1_bytes = split_bv_in_list(src1, 8)
        src2 = get_src(sv.state, src2_p)
        src2_bytes = split_bv_in_list(src2, 8)

        res = None
        for i in range(32):
            res = (
                src1_bytes[i] + src2_bytes[i]
            ) if res is None else (
                (src1_bytes[i] + src2_bytes[i]).Concat(
                    res
                )
            )

        store_to_dst(sv.state, dst_p, res)
        return True

    def vpxor_handler(self, sv, parameters):
        dst_p = parameters[0]
        src1_p = parameters[1]
        src2_p = parameters[2]

        src1 = get_src(sv.state, src1_p)
        src2 = get_src(sv.state, src2_p)

        res = src1 ^ src2

        store_to_dst(sv.state, dst_p, res)
        return True

    def vpor_handler(self, sv, parameters):
        dst_p = parameters[0]
        src1_p = parameters[1]
        src2_p = parameters[2]

        src1 = get_src(sv.state, src1_p)
        src2 = get_src(sv.state, src2_p)

        res = src1 | src2

        store_to_dst(sv.state, dst_p, res)
        return True

    def vpand_handler(self, sv, parameters):
        dst_p = parameters[0]
        src1_p = parameters[1]
        src2_p = parameters[2]

        src1 = get_src(sv.state, src1_p)
        src2 = get_src(sv.state, src2_p)

        res = src1 & src2

        store_to_dst(sv.state, dst_p, res)
        return True

    def vpermd_handler(self, sv, parameters):
        dst_p = parameters[0]
        idx_p = parameters[1]
        src_p = parameters[2]

        # get src and store it in a BVArray
        src = get_src(sv.state, src_p)
        src_dwords = split_bv_in_list(src, 32)
        assert len(src_dwords) == 8
        array_src = BVArray(
            "vpermd_array_{}".format(self._vpermd_idx),
            3,
            32
        )
        for i in range(8):
            array_src.Store(i, src_dwords[i])

        # get idx
        idx = get_src(sv.state, idx_p)
        idx_dwords = split_bv_in_list(idx, 32)

        # compute permutation
        res = None
        for idx in idx_dwords:
            idx_value = idx.Extract(2, 0)
            res = (
                array_src.Select(idx_value)
            ) if res is None else (
                array_src.Select(idx_value).Concat(
                    res
                )
            )

        # save result
        store_to_dst(sv.state, dst_p, res)
        sv.state.solver.add_constraints(*array_src.get_assertions())

        self._vpermd_idx += 1
        return True

    def vpshufb_handler(self, sv, parameters):
        dst_p = parameters[0]
        idx_p = parameters[2]
        src_p = parameters[1]

        src = get_src(sv.state, src_p)
        src_bytes = split_bv_in_list(src, 8)
        idx = get_src(sv.state, idx_p)
        idx_bytes = split_bv_in_list(idx, 8)

        array_src_low = BVArray(
            "vpshufb_array_low_{}".format(self._vpshufb_idx),
            4,
            8
        )
        for i in range(16):
            array_src_low.Store(i, src_bytes[i])

        array_src_hig = BVArray(
            "vpshufb_array_hig_{}".format(self._vpshufb_idx),
            4,
            8
        )
        for i in range(16, 32):
            array_src_hig.Store(i, src_bytes[i])

        idx_bytes_low = idx_bytes[:16]
        idx_bytes_hig = idx_bytes[16:]

        res = None
        for idx in idx_bytes_low:
            idx_low4 = idx.Extract(3, 0)
            val = ITE(
                idx.Extract(7, 7) == 0,
                array_src_low.Select(idx_low4),
                BVV(0, 8)
            )
            res = (
                val
            ) if res is None else (
                val.Concat(
                    res
                )
            )
        for idx in idx_bytes_hig:
            idx_low4 = idx.Extract(3, 0)
            val = ITE(
                idx.Extract(7, 7) == 0,
                array_src_hig.Select(idx_low4),
                BVV(0, 8)
            )
            res = val.Concat(res)

        # save result
        store_to_dst(sv.state, dst_p, res)
        sv.state.solver.add_constraints(*array_src_low.get_assertions())
        sv.state.solver.add_constraints(*array_src_hig.get_assertions())

        self._vpshufb_idx += 1
        return True

    def vpsrld_handler(self, sv, parameters):
        dst_p = parameters[0]
        src_p = parameters[1]
        count_p = parameters[2]

        src = get_src(sv.state, src_p)
        src_dwords = split_bv_in_list(src, 32)

        count = get_src(sv.state, count_p)
        count = count.Extract(31, 0)

        res = None
        for dw in src_dwords:
            res = (
                dw.LShR(count)
            ) if res is None else(
                dw.LShR(count).Concat(
                    res
                )
            )

        store_to_dst(sv.state, dst_p, res)
        return True

    def vpslld_handler(self, sv, parameters):
        dst_p = parameters[0]
        src_p = parameters[1]
        count_p = parameters[2]

        src = get_src(sv.state, src_p)
        src_dwords = split_bv_in_list(src, 32)

        count = get_src(sv.state, count_p)
        count = count.Extract(31, 0)

        res = None
        for dw in src_dwords:
            res = (
                dw.LShL(count)
            ) if res is None else (
                dw.LShL(count).Concat(
                    res
                )
            )

        store_to_dst(sv.state, dst_p, res)
        return True

    def vpcmpeqb_handler(self, sv, parameters):
        dst_p = parameters[0]
        src1_p = parameters[1]
        src2_p = parameters[2]

        src1 = get_src(sv.state, src1_p)
        src1_bytes = split_bv_in_list(src1, 8)
        src2 = get_src(sv.state, src2_p)
        src2_bytes = split_bv_in_list(src2, 8)

        res = None
        for i in range(32):
            val = ITE(
                src1_bytes[i] == src2_bytes[i],
                BVV(0xff, 8),
                BVV(0x00, 8)
            )
            res = (
                val
            ) if res is None else (
                val.Concat(
                    res
                )
            )

        store_to_dst(sv.state, dst_p, res)
        return True

    def vpmovmskb_handler(self, sv, parameters):
        dst_p = parameters[0]
        src_p = parameters[1]

        src = get_src(sv.state, src_p)
        src_bytes = split_bv_in_list(src, 8)

        res = None
        for i in range(32):
            val = src_bytes[i].Extract(7, 7)
            res = (
                val
            ) if res is None else (
                val.Concat(res)
            )

        store_to_dst(sv.state, dst_p, res)
        return True

    # ------------

```

`arch/arch_x86_sph.py`:

```py
from ..utility.bninja_util import (
    get_function, get_addr_next_inst
)
from ..utility.x86_native_handlers_util import (
    store_to_dst, get_src
)
from ..utility.expr_wrap_util import split_bv_in_list
from ..utility.exceptions import ModelError
from ..expr import ITE, BVV, Bool
from .arch_abstract import SpecialInstructionHandler


class ArchX86SPH(SpecialInstructionHandler):
    flag_ops = ['a', 'ae', 'b', 'be', 'c', 'e', 'g', 'ge', 'l',
                'le', 'na', 'ae', 'nb', 'nbe', 'nc', 'ne', 'ng', 'nge',
                'nl', 'nle', 'no', 'np', 'ns', 'nz', 'o', 'p', 'pe',
                'po', 's', 'z']

    def __init__(self):
        setcc_format = "set{fo}_handler"
        cmovcc_format = "cmov{fo}_handler"
        for fo in ArchX86SPH.flag_ops:
            setattr(
                self,
                setcc_format.format(fo=fo),
                lambda sv, parameters: self._setCC(sv, parameters)
            )
            setattr(
                self,
                cmovcc_format.format(fo=fo),
                lambda sv, parameters: self._cmovCC(sv, parameters)
            )

    def _setCC(self, executor, parameters):
        func = executor.bncache.get_function(executor.ip)
        expr = func.llil[executor.llil_ip]
        if expr.operation.name != "LLIL_IF":
            return False

        # we have cmp/test + setCC. Avoid fork
        cond = executor.visitor.visit(expr.condition)
        if not isinstance(cond, Bool):
            assert cond.size == 1
            cond = cond == BVV(1, 1)  # to bool

        v = ITE(cond, BVV(1, 8), BVV(0, 8))
        store_to_dst(executor.state, parameters[0], v)

        return True

    def _cmovCC(self, executor, parameters):
        func = executor.bncache.get_function(executor.ip)
        expr = func.llil[executor.llil_ip]
        if expr.operation.name != "LLIL_IF":
            return False

        # we have cmp/test + cmovCC. Avoid fork
        cond = executor.visitor.visit(expr.condition)
        if not isinstance(cond, Bool):
            assert cond.size == 1
            cond = cond == BVV(1, 1)  # to bool

        new_data = get_src(executor.state, parameters[1])
        old_data = get_src(executor.state, parameters[0])
        cond_data = ITE(cond, new_data, old_data)

        store_to_dst(executor.state, parameters[0], cond_data)

        return True

    def cpuid_util(self, sv, bits):
        dst_eax = 'eax' if bits == 32 else 'rax'
        dst_ebx = 'ebx' if bits == 32 else 'rbx'
        dst_ecx = 'ecx' if bits == 32 else 'rcx'
        dst_edx = 'edx' if bits == 32 else 'rdx'

        eax_v = sv.state.regs.eax
        ecx_v = sv.state.regs.ecx
        if not isinstance(eax_v, BVV):
            raise ModelError("cpuid", "symbolic eax")
        if not isinstance(ecx_v, BVV):
            raise ModelError("cpuid", "symbolic ecx")
        eax_v = eax_v.value
        ecx_v = ecx_v.value
        if eax_v == 0 and ecx_v == 0:
            setattr(sv.state.regs, dst_eax, BVV(0x00000010, bits))
            setattr(sv.state.regs, dst_ebx, BVV(0x68747541, bits))
            setattr(sv.state.regs, dst_ecx, BVV(0x444d4163, bits))
            setattr(sv.state.regs, dst_edx, BVV(0x69746e65, bits))
        elif eax_v == 1 and ecx_v == 0:
            setattr(sv.state.regs, dst_eax, BVV(0x00870f10, bits))
            setattr(sv.state.regs, dst_ebx, BVV(0x000c0800, bits))
            setattr(sv.state.regs, dst_ecx, BVV(0x7ed8320b, bits))
            setattr(sv.state.regs, dst_edx, BVV(0x178bfbff, bits))
        elif eax_v == 7 and ecx_v == 0:
            setattr(sv.state.regs, dst_eax, BVV(0x00000000, bits))
            setattr(sv.state.regs, dst_ebx, BVV(0x219c91a9, bits))
            setattr(sv.state.regs, dst_ecx, BVV(0x00400004, bits))
            setattr(sv.state.regs, dst_edx, BVV(0x00000000, bits))
        else:
            raise ModelError(
                "cpuid", "unsupported (eax, ecx) value (%d, %d)" % (eax_v, ecx_v))

        return True

    def cpuid_handler(self, sv, parameters):
        return self.cpuid_util(sv, 32)

    def xgetbv_handler(self, sv, parameters):
        sv.state.regs.eax = BVV(7, 32)
        sv.state.regs.edx = BVV(0, 32)
        return True

    def paddb_handler(self, sv, parameters):
        src1 = get_src(sv.state, parameters[0])
        src1_bytes = split_bv_in_list(src1, 8)
        src2 = get_src(sv.state, parameters[1])
        src2_bytes = split_bv_in_list(src2, 8)

        res = None
        for b1, b2 in zip(src1_bytes, src2_bytes):
            if res is None:
                res = b1 + b2
            else:
                res = (b1 + b2).Concat(res)

        store_to_dst(sv.state, parameters[0], res)
        return True

    def paddw_handler(self, sv, parameters):
        return False

    def paddd_handler(self, sv, parameters):
        return False

    def paddq_handler(self, sv, parameters):
        return False

    def paddsb_handler(self, sv, parameters):
        return False

    def paddsw_handler(self, sv, parameters):
        return False

    def paddsd_handler(self, sv, parameters):
        return False

    def paddsq_handler(self, sv, parameters):
        return False

    # ----- mmx -----
    def movd_handler(self, sv, parameters):
        dst_p = parameters[0]
        src_p = parameters[1]

        # get src (32bit)
        src = get_src(sv.state, src_p)
        assert src.size == 32

        store_to_dst(sv.state, dst_p, src.ZeroExt(16*8-32))
        return True

    def movq_handler(self, sv, parameters):
        dst_p = parameters[0]
        src_p = parameters[1]

        # get src (64bit)
        src = get_src(sv.state, src_p)
        if src.size > 64:
            src = src.Extract(63, 0)

        if "[" not in dst_p:
            store_to_dst(sv.state, dst_p, src.ZeroExt(16*8-64))
        else:
            store_to_dst(sv.state, dst_p, src)
        return True
    # ----------------

```

`expr/__init__.py`:

```py
import z3

from .bitvector import BV, BVV, BVS, BVExpr
from .bool_expr import Bool, BoolExpr, BoolS, BoolV
from .bitvector_array import BVArray


def ITE(cond: Bool, iftrue: BV, iffalse: BV):
    assert iftrue.size == iffalse.size
    if isinstance(cond, BoolV):
        return iftrue if cond.value else iffalse
    return BVExpr(
        iftrue.size,
        z3.If(cond.z3obj, iftrue.z3obj, iffalse.z3obj)
    )


def Or(*conditions):
    res = None
    for cond in conditions:
        assert isinstance(cond, Bool)
        res = res.Or(cond) if res is not None else cond

    assert res is not None
    return res


def And(*conditions):
    res = None
    for cond in conditions:
        assert isinstance(cond, Bool)
        res = res.And(cond) if res is not None else cond

    assert res is not None
    return res


def Xor(*conditions):
    res = None
    for cond in conditions:
        assert isinstance(cond, Bool)
        res = res.Xor(cond) if res is not None else cond

    assert res is not None
    return res

```

`expr/bitvector.py`:

```py
import z3

from .bool_expr import BoolExpr, BoolV
from .interval import Interval


class BV(object):
    def __init__(self):
        # do not instantiate this class
        raise NotImplementedError

    def __repr__(self):
        return self.__str__()

    def __neg__(self):
        raise NotImplementedError

    def __add__(self, other):
        raise NotImplementedError

    def __sub__(self, other):
        raise NotImplementedError

    def __mul__(self, other):
        raise NotImplementedError

    def __radd__(self, other):
        return self.__add__(other)

    def __rsub__(self, other):
        return self.__neg__().__add__(other)

    def __rmul__(self, other):
        return self.__mul__(other)


class BVExpr(BV):
    def __init__(self, size: int, z3obj, interval=None):
        self.z3obj = z3obj
        self.size = size
        self.interval = interval if interval is not None else Interval(
            self.size)

    def __str__(self):
        return "<BVExpr{size} {obj}>".format(
            size=self.size, obj=str(self.z3obj)
        )

    def simplify(self):
        simplified = z3.simplify(self.z3obj)
        if simplified.decl().kind() == z3.Z3_OP_BNUM:
            return BVV(simplified.as_long(), self.size)
        if simplified.decl().kind() == z3.Z3_OP_UNINTERPRETED:
            return BVS(simplified.sexpr(), self.size)
        if not simplified.eq(self.z3obj):
            return BVExpr(self.size, simplified, self.interval)
        return self

    def eq(self, other):
        if not isinstance(other, BV):
            return False
        return self.z3obj.eq(other.z3obj)

    def __hash__(self):
        return self.z3obj.__hash__()

    def __add__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, self.z3obj + other.z3obj, self.interval + other.interval)

    def __sub__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, self.z3obj - other.z3obj, self.interval - other.interval)

    def __mul__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, self.z3obj * other.z3obj, self.interval * other.interval)

    def __truediv__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, self.z3obj / other.z3obj, self.interval / other.interval)

    def __mod__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, self.z3obj % other.z3obj, self.interval % other.interval)

    def __xor__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, self.z3obj ^ other.z3obj, self.interval ^ other.interval)

    def __and__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, self.z3obj & other.z3obj, self.interval & other.interval)

    def __or__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, self.z3obj | other.z3obj, self.interval | other.interval)

    def __lshift__(self, other):
        # arithmetic/logical left shift
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, self.z3obj << other.z3obj, self.interval << other.interval)

    def __rshift__(self, other):
        # arithmetic right shift
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        new_interval = self.interval.LShR(other.interval)
        if new_interval.low == new_interval.high:
            # concrete path
            return BVV(new_interval.low, self.size)
        return BVExpr(self.size, self.z3obj >> other.z3obj, new_interval)

    def __eq__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BoolExpr(self.z3obj == other.z3obj)

    def __ne__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BoolExpr(self.z3obj != other.z3obj)

    def __lt__(self, other):
        # signed
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BoolExpr(self.z3obj < other.z3obj)

    def __le__(self, other):
        # signed
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BoolExpr(self.z3obj <= other.z3obj)

    def __gt__(self, other):
        # signed
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BoolExpr(self.z3obj > other.z3obj)

    def __ge__(self, other):
        # signed
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BoolExpr(self.z3obj >= other.z3obj)

    def __invert__(self):
        return BVExpr(self.size, self.z3obj.__invert__(), self.interval.__invert__())

    def __neg__(self):
        return BVExpr(self.size, self.z3obj.__neg__(), self.interval.__neg__())

    def UDiv(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, z3.UDiv(self.z3obj, other.z3obj), self.interval.UDiv(other.interval))

    def SDiv(self, other):
        return self.__truediv__(other)

    def URem(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, z3.URem(self.z3obj, other.z3obj), self.interval.URem(other.interval))

    def SRem(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, z3.SRem(self.z3obj, other.z3obj), self.interval.SRem(other.interval))

    def LShL(self, other):
        return self.__lshift__(other)

    def AShL(self, other):
        # arithmetic and logical left shift are identical
        return self.__lshift__(other)

    def LShR(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        new_interval = self.interval.LShR(other.interval)
        if new_interval.low == new_interval.high:
            # concrete path
            return BVV(new_interval.low, self.size)
        return BVExpr(self.size, z3.LShR(self.z3obj, other.z3obj), new_interval)

    def AShR(self, other):
        return self.__rshift__(other)

    def ULT(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BoolExpr(z3.ULT(self.z3obj, other.z3obj))

    def ULE(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BoolExpr(z3.ULE(self.z3obj, other.z3obj))

    def UGT(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BoolExpr(z3.UGT(self.z3obj, other.z3obj))

    def UGE(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BoolExpr(z3.UGE(self.z3obj, other.z3obj))

    def SLT(self, other):
        return self.__lt__(other)

    def SLE(self, other):
        return self.__le__(other)

    def SGT(self, other):
        return self.__gt__(other)

    def SGE(self, other):
        return self.__ge__(other)

    def RotateLeft(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, z3.RotateLeft(self.z3obj, other.z3obj), self.interval.RotateLeft(other.interval))

    def RotateRight(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        return BVExpr(self.size, z3.RotateRight(self.z3obj, other.z3obj), self.interval.RotateRight(other.interval))

    def Concat(self, other: BV):
        return BVExpr(self.size + other.size, z3.Concat(self.z3obj, other.z3obj), self.interval.Concat(other.interval))

    def Extract(self, high: int, low: int):
        assert high >= low
        new_interval = self.interval.Extract(high, low)
        if new_interval.high == new_interval.low:
            # extract is concrete
            return BVV(new_interval.high, high-low+1)
        return BVExpr(high-low+1, z3.Extract(high, low, self.z3obj), new_interval)

    def SignExt(self, n: int):
        assert n >= 0
        return BVExpr(self.size + n, z3.SignExt(n, self.z3obj), self.interval.SignExt(n))

    def ZeroExt(self, n: int):
        assert n >= 0
        return BVExpr(self.size + n, z3.ZeroExt(n, self.z3obj), self.interval.ZeroExt(n))


class BVS(BVExpr):
    def __init__(self, name: str, size: int):
        self.name = name
        self.size = size
        self.z3obj = z3.BitVec(name, size)

    def __str__(self):
        return "<BVS{size} {obj}>".format(
            size=self.size, obj=str(self.z3obj)
        )

    def simplify(self):
        return self

    @property
    def interval(self):
        return Interval(self.size)


class BVV(BV):
    def __init__(self, value: int, size: int):
        self.size = size
        self.value = value & self._mask

    def as_bytes(self):
        assert self.size % 8 == 0
        res = b""
        for i in range(0, self.size, 8):
            bv = self.Extract(i+8-1, i)
            res = bytes([bv.value]) + res
        return res

    def simplify(self):
        return self

    @property
    def _mask(self):
        return (2 << (self.size-1)) - 1

    @property
    def _signMask(self):
        return 2 << (self.size-1-1) if self.size > 1 else 0

    @property
    def z3obj(self):
        return z3.BitVecVal(self.value, self.size)

    @property
    def interval(self):
        return Interval(self.size, self.value, self.value)

    def __str__(self):
        return "<BVV{size} 0x{obj:0{width}x}>".format(
            size=self.size, obj=self.value,
            width=(self.size+3) // 4
        )

    def eq(self, other):
        if not isinstance(other, BV):
            return False
        if isinstance(other, BVV):
            return self.value == other.value and \
                self.size == other.size
        return self.z3obj.eq(other.z3obj)

    def __hash__(self):
        return hash((self.value, self.size))

    def __add__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BVV((self.value + other.value) & self._mask, self.size)
        return BVExpr(self.size, self.value + other.z3obj, self.interval + other.interval)

    def __sub__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BVV((self.value - other.value) & self._mask, self.size)
        return BVExpr(self.size, self.value - other.z3obj, self.interval - other.interval)

    def __mul__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BVV((self.value * other.value) & self._mask, self.size)
        return BVExpr(self.size, self.value * other.z3obj, self.interval * other.interval)

    def __truediv__(self, other):
        # signed
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            signed_left = (self.value - 2**self.size) \
                if self.value & self._signMask else self.value
            signed_right = (other.value - 2**other.size) \
                if other.value & other._signMask else other.value
            # python round up -x.y to -(x+1). Z3 round up to -x
            # We want to be consistent with Z3
            sign = 1 if signed_left * signed_right > 0 else -1
            value = abs(signed_left) // abs(signed_right)
            return BVV((sign * value) & self._mask, self.size)
        return BVExpr(self.size, self.z3obj / other.z3obj, self.interval / other.interval)

    def __mod__(self, other):
        # signed
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            signed_left = (self.value - 2**self.size) \
                if self.value & self._signMask else self.value
            signed_right = (other.value - 2**other.size) \
                if other.value & other._signMask else other.value
            return BVV((signed_left % signed_right) & self._mask, self.size)
        return BVExpr(self.size, self.z3obj % other.z3obj, self.interval % other.interval)

    def __xor__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BVV((self.value ^ other.value) & self._mask, self.size)
        return BVExpr(self.size, self.value ^ other.z3obj, self.interval ^ other.interval)

    def __and__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BVV((self.value & other.value) & self._mask, self.size)
        return BVExpr(self.size, self.z3obj & other.z3obj, self.interval & other.interval)

    def __or__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BVV((self.value | other.value) & self._mask, self.size)
        return BVExpr(self.size, self.z3obj | other.z3obj, self.interval | other.interval)

    def __lshift__(self, other):
        # arithmetic/logical left shift
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BVV((self.value << other.value) & self._mask, self.size)
        return BVExpr(self.size, self.z3obj << other.z3obj, self.interval << other.interval)

    def __rshift__(self, other):
        # arithmetic right shift
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            tmp = self._signMask >> other.value
            new = ((self.value >> other.value) ^ tmp) - tmp
            return BVV(new & self._mask, self.size)
        return BVExpr(self.size, self.z3obj >> other.z3obj, self.interval >> other.interval)

    def __eq__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BoolV(self.value == other.value)
        return BoolExpr(self.z3obj == other.z3obj)

    def __ne__(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BoolV(self.value != other.value)
        return BoolExpr(self.z3obj != other.z3obj)

    def __lt__(self, other):
        # signed
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            signed_left = (self.value - 2**self.size) \
                if self.value & self._signMask else self.value
            signed_right = (other.value - 2**other.size) \
                if other.value & other._signMask else other.value
            return BoolV(signed_left < signed_right)
        return BoolExpr(self.z3obj < other.z3obj)

    def __le__(self, other):
        # signed
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            signed_left = (self.value - 2**self.size) \
                if self.value & self._signMask else self.value
            signed_right = (other.value - 2**other.size) \
                if other.value & other._signMask else other.value
            return BoolV(signed_left <= signed_right)
        return BoolExpr(self.z3obj <= other.z3obj)

    def __gt__(self, other):
        # signed
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            signed_left = (self.value - 2**self.size) \
                if self.value & self._signMask else self.value
            signed_right = (other.value - 2**other.size) \
                if other.value & other._signMask else other.value
            return BoolV(signed_left > signed_right)
        return BoolExpr(self.z3obj > other.z3obj)

    def __ge__(self, other):
        # signed
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            signed_left = (self.value - 2**self.size) \
                if self.value & self._signMask else self.value
            signed_right = (other.value - 2**other.size) \
                if other.value & other._signMask else other.value
            return BoolV(signed_left >= signed_right)
        return BoolExpr(self.z3obj >= other.z3obj)

    def __invert__(self):
        return BVV(~self.value, self.size)

    def __neg__(self):
        return BVV(-self.value, self.size)

    def UDiv(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BVV((self.value // other.value) & self._mask, self.size)
        return BVExpr(self.size, z3.UDiv(self.z3obj, other.z3obj), self.interval.UDiv(other.interval))

    def SDiv(self, other):
        return self.__truediv__(other)

    def URem(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BVV((self.value % other.value) & self._mask, self.size)
        return BVExpr(self.size, z3.URem(self.z3obj, other.z3obj), self.interval.URem(other.interval))

    def SRem(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            signed_left = (self.value - 2**self.size) \
                if self.value & self._signMask else self.value
            signed_right = (other.value - 2**other.size) \
                if other.value & other._signMask else other.value
            # sign div
            sign = 1 if signed_left * signed_right > 0 else -1
            div_abs = abs(signed_left) // abs(signed_right)
            div = sign * div_abs
            # sign rem
            rem = signed_left - (signed_right * div)
            return BVV(rem, self.size)
        return BVExpr(self.size, z3.SRem(self.z3obj, other.z3obj), self.interval.SRem(other.interval))

    def LShL(self, other):
        return self.__lshift__(other)

    def AShL(self, other):
        # arithmetic and logical left shift are identical
        return self.__lshift__(other)

    def LShR(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BVV((self.value >> other.value) & self._mask, self.size)
        return BVExpr(self.size, z3.LShR(self.z3obj, other.z3obj), self.interval.LShR(other.interval))

    def AShR(self, other):
        return self.__rshift__(other)

    def ULT(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BoolV(self.value < other.value)
        return BoolExpr(z3.ULT(self.z3obj, other.z3obj))

    def ULE(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BoolV(self.value <= other.value)
        return BoolExpr(z3.ULE(self.z3obj, other.z3obj))

    def UGT(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BoolV(self.value > other.value)
        return BoolExpr(z3.UGT(self.z3obj, other.z3obj))

    def UGE(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            return BoolV(self.value >= other.value)
        return BoolExpr(z3.UGE(self.z3obj, other.z3obj))

    def SLT(self, other):
        return self.__lt__(other)

    def SLE(self, other):
        return self.__le__(other)

    def SGT(self, other):
        return self.__gt__(other)

    def SGE(self, other):
        return self.__ge__(other)

    def RotateLeft(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            other_norm = other.value % self.size
            new = (((self.value << other_norm) & self._mask) |
                   ((self.value >> ((self.size - other_norm) & self._mask)) & self._mask))
            return BVV(new & self._mask, self.size)
        return BVExpr(self.size, z3.RotateLeft(self.z3obj, other.z3obj), self.interval.RotateLeft(other.interval))

    def RotateRight(self, other):
        if isinstance(other, int):
            other = BVV(other, self.size)
        else:
            assert isinstance(other, BV)
            assert self.size == other.size
        if isinstance(other, BVV):
            other_norm = other.value % self.size
            new = (((self.value >> other_norm) & self._mask) |
                   ((self.value << ((self.size - other_norm) & self._mask)) & self._mask))
            return BVV(new & self._mask, self.size)
        return BVExpr(self.size, z3.RotateRight(self.z3obj, other.z3obj), self.interval.RotateRight(other.interval))

    def Concat(self, other: BV):
        if isinstance(other, BVV):
            new_value = (self.value << other.size) + other.value
            new_size = self.size + other.size
            new_mask = 2**new_size-1
            return BVV(new_value & new_mask, new_size)
        return BVExpr(self.size + other.size, z3.Concat(self.z3obj, other.z3obj), self.interval.Concat(other.interval))

    def Extract(self, high: int, low: int):
        assert high >= low
        new_size = high-low+1
        new_value = (self.value >> low) & ((2 << (new_size-1))-1)
        return BVV(new_value, new_size)

    def SignExt(self, n: int):
        assert n >= 0
        if self._signMask & self.value:
            new = (((2 << (n-1))-1) << self.size) + self.value
        else:
            new = self.value
        mask = (2 << (self.size+n-1))-1
        return BVV(new & mask, self.size + n)

    def ZeroExt(self, n: int):
        assert n >= 0
        return BVV(self.value, self.size + n)

```

`expr/bitvector_array.py`:

```py
import z3

from enum import Enum
from copy import deepcopy
from .bitvector import BV, BVV, BVS, BVExpr
from .bool_expr import Bool, BoolV, BoolExpr


class BVArrayState(Enum):
    # Never registered a symbolic memory access (either Load or Store)
    CONCRETE_MODE = 0
    # Registered only a symbolic Load. Allowed concrete Load
    SEMI_CONCRETE_MODE = 1
    # Registered a symbolic Store
    SYMBOLIC_MODE = 2


class BVArray(object):
    """ Wrapper of z3's Array. Beware: this is not immutable, differently from z3 """

    def __init__(self, name: str, index_width: int, value_width: int):
        assert index_width > 0
        assert value_width > 0

        self.name = name
        self.uninit_id = 0
        self.index_width = index_width
        self.value_width = value_width
        self._conc_store = {}
        self._assertions = dict()
        self._z3obj = None
        self._z3objConcCache = None
        self._mode = BVArrayState.CONCRETE_MODE

    def __str__(self):
        return "<BVArray [BV{ind} -> BV{val}] {name}>".format(
            name=self.name,
            ind=self.index_width,
            val=self.value_width
        )

    def __repr__(self):
        return self.__str__()

    def get_mode(self):
        return self._mode

    def simplify(self):
        if self._z3obj is None:
            return
        self._z3obj = z3.simplify(self._z3obj)

    @property
    def z3obj(self):
        if self._z3obj is not None:
            # symbolic mode
            return self._z3obj

        # concrete mode
        if self._z3objConcCache is not None:
            return self._z3objConcCache
        res = z3.Array(
            self.name,
            z3.BitVecSort(self.index_width),
            z3.BitVecSort(self.value_width)
        )
        for index in self._conc_store:
            res = z3.Store(
                res,
                z3.BitVecVal(index, self.index_width),
                self._conc_store[index].z3obj
            )
        self._z3objConcCache = res
        return res

    def _switch_to_symbolic(self, soft=False):
        if self._mode == BVArrayState.SEMI_CONCRETE_MODE and soft:
            return

        if self._mode == BVArrayState.SEMI_CONCRETE_MODE and not soft:
            self._mode = BVArrayState.SYMBOLIC_MODE
            self._conc_store = None
            return

        if self._mode == BVArrayState.CONCRETE_MODE:
            assert self._z3obj is None
            self._z3obj = z3.Array(
                self.name,
                z3.BitVecSort(self.index_width),
                z3.BitVecSort(self.value_width)
            )
            # The solver needs to add those constraints! (even lazly)
            for index in self._conc_store:
                self._assertions[index] = \
                    BoolExpr(z3.Select(
                        self._z3obj, index) == self._conc_store[index].z3obj)

            if soft:
                self._mode = BVArrayState.SEMI_CONCRETE_MODE
            else:
                self._mode = BVArrayState.SYMBOLIC_MODE
                self._conc_store = None

    def get_assertions(self):
        return list(self._assertions.values())

    def Store(self, index, value):
        if isinstance(index, int):
            index = BVV(index, self.index_width)
        else:
            assert index.size == self.index_width
        if isinstance(value, int):
            value = BVV(value, self.value_width)
        else:
            assert value.size == self.value_width

        # invalidate cache
        self._z3objConcCache = None

        if (
            isinstance(index, BVV) and
            self._mode == BVArrayState.CONCRETE_MODE
        ):
            # concrete mode
            self._conc_store[index.value] = value
        else:
            # symbolic mode
            self._switch_to_symbolic(soft=False)
            self._z3obj = z3.Store(
                self._z3obj,
                index.z3obj,
                value.z3obj
            )

    def ConditionalStore(self, index, value, cond):
        if isinstance(index, int):
            index = BVV(index, self.index_width)
        else:
            assert index.size == self.index_width
        if isinstance(value, int):
            value = BVV(value, self.value_width)
        else:
            assert value.size == self.value_width
        if isinstance(cond, bool):
            cond = BoolV(cond)

        if isinstance(cond, BoolV):
            if cond.value:
                self.Store(index, value)
            return

        if (
            self._mode == BVArrayState.CONCRETE_MODE and
            isinstance(index, BVV) and
            index.value in self._conc_store and
            self._conc_store[index.value].eq(value)
        ):
            # the condition is symbolic, but the value is already in memory
            # we can safetely skip the store
            return

        self._switch_to_symbolic(soft=False)
        self._z3obj = z3.If(
            cond.z3obj,
            z3.Store(
                self._z3obj,
                index.z3obj,
                value.z3obj
            ),
            self._z3obj
        )
        # this can be quite inefficient.
        # Let's try to simplfy the expression.
        self._z3obj = z3.simplify(self._z3obj)

    def Select(self, index: BV) -> BV:
        if isinstance(index, int):
            index = BVV(index, self.index_width)
        else:
            assert index.size == self.index_width

        if (
            isinstance(index, BVV) and
            self._mode in {BVArrayState.CONCRETE_MODE, BVArrayState.SEMI_CONCRETE_MODE} and
            index.value in self._conc_store
        ):
            # concrete mode
            return self._conc_store[index.value]

        if (
            isinstance(index, BVV) and
            self._mode in {BVArrayState.CONCRETE_MODE, BVArrayState.SEMI_CONCRETE_MODE} and
            index.value not in self._conc_store
        ):
            res = BVS("uninit_read_%s_%d" % (self.name, self.uninit_id), self.value_width)
            self.uninit_id += 1
            return res

        # symbolic mode
        self._switch_to_symbolic(soft=True)
        return BVExpr(self.value_width, z3.Select(self._z3obj, index.z3obj))

    def copy(self):
        new = BVArray(self.name, self.index_width, self.value_width)
        new._conc_store = deepcopy(self._conc_store)
        new._z3obj = self._z3obj
        new._assertions = dict(self._assertions)
        new.uninit_id = self.uninit_id

        return new

    def merge(self, other, merge_condition: Bool):
        assert self.name == other.name
        assert self.index_width == other.index_width
        assert self.value_width == other.value_width
        if isinstance(merge_condition, BoolV):
            if merge_condition.value:
                return other.copy()
            return self

        self.uninit_id = max(self.uninit_id, other.uninit_id)

        if self.get_mode() == BVArrayState.CONCRETE_MODE and other.get_mode() == BVArrayState.CONCRETE_MODE:
            # Handle concrete mode merge (easy)
            all_indexes = set(self._conc_store.keys()) | set(other._conc_store.keys())
            for idx in all_indexes:
                self._conc_store[idx] = BVExpr(self.value_width, z3.If(
                    merge_condition.z3obj,
                    other.Select(BVV(idx, self.index_width)).z3obj,
                    self.Select(BVV(idx, self.index_width)).z3obj
                ))
        elif (
                self.get_mode() == BVArrayState.SEMI_CONCRETE_MODE and
                other.get_mode() in {BVArrayState.CONCRETE_MODE,
                                     BVArrayState.SEMI_CONCRETE_MODE}
            ) or (
                other.get_mode() == BVArrayState.SEMI_CONCRETE_MODE and
                self.get_mode() in {BVArrayState.CONCRETE_MODE,
                                    BVArrayState.SEMI_CONCRETE_MODE}
        ):
            # Handle semi-concrete mode merge
            other_copy = other.copy()
            other_copy._switch_to_symbolic(soft=True)
            self._switch_to_symbolic(soft=True)

            all_indexes = set(self._conc_store.keys()) | set(other._conc_store.keys())
            for idx in all_indexes:
                self._conc_store[idx] = BVExpr(self.value_width, z3.If(
                    merge_condition.z3obj,
                    other.Select(BVV(idx, self.index_width)).z3obj,
                    self.Select(BVV(idx, self.index_width)).z3obj
                ))

            all_indexes = set(self._assertions.keys()) | set(other._assertions.keys())
            new_assertions = dict()
            for idx in all_indexes:
                other_cond = other._assertions[idx] if idx in other._assertions else BoolV(True)
                self_cond  = self._assertions[idx] if idx in self._assertions else BoolV(True)
                new_assertions[idx] = z3.If(
                    merge_condition.z3obj,
                    other_cond.z3obj,
                    self_cond.z3obj
                )

            self._z3obj = z3.If(
                merge_condition.z3obj,
                other._z3obj,
                self._z3obj
            )

        else:
            # Handle symbolic mode merge
            other_copy = other.copy()
            other_copy._switch_to_symbolic(soft=False)
            self._switch_to_symbolic(soft=False)

            all_indexes = set(self._assertions.keys()) | set(other._assertions.keys())
            new_assertions = dict()
            for idx in all_indexes:
                other_cond = other._assertions[idx] if idx in other._assertions else BoolV(True)
                self_cond  = self._assertions[idx] if idx in self._assertions else BoolV(True)
                new_assertions[idx] = z3.If(
                    merge_condition.z3obj,
                    other_cond.z3obj,
                    self_cond.z3obj
                )

            self._z3obj = z3.If(
                merge_condition.z3obj,
                other._z3obj,
                self._z3obj
            )

        return self

```

`expr/bool_expr.py`:

```py
import z3


class Bool(object):
    def __init__(self):
        # do not instantiate this class
        raise NotImplementedError

    def __repr__(self):
        return self.__str__()


class BoolExpr(Bool):
    def __init__(self, z3obj):
        self.z3obj = z3obj

    def __str__(self):
        return "<BoolExpr {obj}>".format(
            obj=str(self.z3obj)
        )

    def __hash__(self):
        return self.z3obj.__hash__()

    def simplify(self):
        simplified = z3.simplify(self.z3obj)
        if simplified.decl().kind() == z3.Z3_OP_TRUE:
            return BoolV(True)
        elif simplified.decl().kind() == z3.Z3_OP_FALSE:
            return BoolV(False)

        if simplified.eq(self.z3obj):
            return self
        return BoolExpr(simplified)

    def eq(self, other: Bool):
        return self.z3obj.eq(other.z3obj)

    def __eq__(self, other: Bool):
        return BoolExpr(self.z3obj == other.z3obj)

    def __neq__(self, other: Bool):
        return BoolExpr(self.z3obj != other.z3obj)

    def Not(self):
        return BoolExpr(z3.Not(self.z3obj))

    def Or(self, other: Bool):
        return BoolExpr(z3.Or(self.z3obj, other.z3obj))

    def And(self, other: Bool):
        return BoolExpr(z3.And(self.z3obj, other.z3obj))

    def Xor(self, other: Bool):
        return BoolExpr(z3.Xor(self.z3obj, other.z3obj))


class BoolS(BoolExpr):
    def __init__(self, name):
        self.name = name
        self.z3obj = z3.Bool(name)

    def simplify(self):
        return self

    def __str__(self):
        return "<BoolS {name}>".format(
            name=str(self.name)
        )


class BoolV(Bool):
    def __init__(self, value: bool):
        self.value = value

    @property
    def z3obj(self):
        return z3.BoolVal(self.value)

    def simplify(self):
        return self

    def __str__(self):
        return "<BoolV {val}>".format(
            val=str(self.value)
        )

    def __hash__(self):
        return hash(self.value)

    def eq(self, other: Bool):
        return isinstance(other, BoolV) and other.value == self.value

    def __eq__(self, other: Bool):
        if isinstance(other, BoolV):
            return BoolV(self.value == other.value)
        return BoolExpr(self.z3obj == other.z3obj)

    def __neq__(self, other: Bool):
        if isinstance(other, BoolV):
            return BoolV(self.value != other.value)
        return BoolExpr(self.z3obj != other.z3obj)

    def Not(self):
        return BoolV(not self.value)

    def Or(self, other: Bool):
        if isinstance(other, BoolV):
            return BoolV(self.value or other.value)
        return BoolExpr(z3.Or(self.z3obj, other.z3obj))

    def And(self, other: Bool):
        if isinstance(other, BoolV):
            return BoolV(self.value and other.value)
        return BoolExpr(z3.And(self.z3obj, other.z3obj))

    def Xor(self, other: Bool):
        if isinstance(other, BoolV):
            return BoolV(
                (self.value or other.value) and not (
                    self.value and other.value)
            )
        return BoolExpr(z3.Xor(self.z3obj, other.z3obj))

```

`expr/interval.py`:

```py
class Interval(object):
    def __init__(self, bits, low=None, high=None):
        assert bits > 0
        self.bits = bits
        self.max = (2 << (bits - 1)) - 1
        self.low = low if low is not None else 0
        self.high = high if high is not None else self.max

        self.low = self.low & self.max
        self.high = self.high & self.max

        assert self.high >= self.low

    def __str__(self):
        return "<Interval%d [%s -> %s]>" % (
            self.bits, hex(self.low), hex(self.high)
        )

    def __repr__(self):
        return self.__str__()

    @property
    def is_top(self):
        return self.low == 0 and self.high == self.max

    def __add__(self, other):
        assert other.bits == self.bits

        new_low = self.low + other.low
        new_high = self.high + other.high
        if new_high > self.max:
            new_high = self.max
            new_low = 0

        return Interval(
            self.bits,
            new_low,
            new_high
        )

    def __sub__(self, other):
        assert other.bits == self.bits

        new_low = self.low - other.high
        new_high = self.high - other.low
        if new_low < 0:
            new_high = self.max
            new_low = 0

        return Interval(
            self.bits,
            new_low,
            new_high
        )

    def __mul__(self, other):
        assert other.bits == self.bits

        new_low = self.low * other.low
        new_high = self.high * other.high
        if new_high > self.max:
            new_high = self.max
            new_low = 0

        return Interval(
            self.bits,
            new_low,
            new_high
        )

    def __truediv__(self, other):
        assert other.bits == self.bits
        return Interval(self.bits)

    def __mod__(self, other):
        assert other.bits == self.bits

        new_low = 0
        new_high = other.high

        return Interval(
            self.bits,
            new_low,
            new_high
        )

    def __xor__(self, other):
        assert other.bits == self.bits

        new_low = 0
        new_high = max(self.high, other.high)

        return Interval(
            self.bits,
            new_low,
            new_high
        )

    def __and__(self, other):
        assert other.bits == self.bits

        new_low = 0
        new_high = self.high & other.high

        return Interval(
            self.bits,
            new_low,
            new_high
        )

    def __or__(self, other):
        assert other.bits == self.bits

        new_low = min(self.low, other.low)
        new_high = max(self.high, other.high, self.high | other.high)

        return Interval(
            self.bits,
            new_low,
            new_high
        )

    def __lshift__(self, other):
        # arithmetic/logical left shift
        assert other.bits == self.bits

        new_low = self.low << other.low
        new_high = self.high << other.high
        if new_high > self.max:
            new_high = self.max
            new_low = 0

        return Interval(
            self.bits,
            new_low,
            new_high
        )

    def __rshift__(self, other):
        # arithmetic right shift
        assert other.bits == self.bits

        new_low = self.low >> other.high
        # check sign
        if self.high >> (self.bits-1) == 1:
            new_high = self.high
        else:
            new_high = self.high >> other.low

        return Interval(
            self.bits,
            new_low,
            new_high
        )

    def __invert__(self):
        return Interval(self.bits)

    def __neg__(self):
        return Interval(self.bits)

    def UDiv(self, other):
        assert other.bits == self.bits
        if other.low == 0 or other.high == 0:
            return Interval(self.bits)

        new_low = self.low // other.high
        new_high = self.high // other.low

        return Interval(
            self.bits,
            new_low,
            new_high
        )

    def SDiv(self, other):
        return self.__truediv__(other)

    def URem(self, other):
        assert other.bits == self.bits
        return Interval(
            self.bits,
            0,
            min(self.high, other.high - 1)
        )

    def SRem(self, other):
        assert other.bits == self.bits
        return Interval(self.bits)

    def LShL(self, other):
        return self.__lshift__(other)

    def AShL(self, other):
        # arithmetic and logical left shift are identical
        return self.__lshift__(other)

    def LShR(self, other):
        assert other.bits == self.bits

        new_low = self.low >> other.high
        new_high = self.high >> other.low

        return Interval(
            self.bits,
            new_low,
            new_high
        )

    def AShR(self, other):
        return self.__rshift__(other)

    def RotateLeft(self, other):
        assert self.bits == other.bits
        return Interval(self.bits)

    def RotateRight(self, other):
        assert self.bits == other.bits
        return Interval(self.bits)

    def Concat(self, other):
        new_low = (self.low << other.bits) + other.low
        new_high = (self.high << other.bits) + other.high

        return Interval(
            self.bits + other.bits,
            new_low,
            new_high
        )

    def Extract(self, high: int, low: int):
        mask = (2 << (high - low)) - 1
        new_low = (self.low >> low) & mask
        new_high = (((self.high - self.low) >> low) & mask) + new_low

        if new_high > mask:
            new_high = mask

        return Interval(
            high - low + 1,
            new_low,
            new_high
        )

    def SignExt(self, n: int):
        assert n >= 0
        new_low = self.low
        if self.high >> (self.bits-1) == 1:
            new_high = (2 << (self.bits + n - 1)) - 1
        else:
            new_high = self.high

        return Interval(
            self.bits + n,
            new_low,
            new_high
        )

    def ZeroExt(self, n: int):
        assert n >= 0
        return Interval(
            self.bits + n,
            self.low,
            self.high
        )

```

`expr/simplifier.py`:

```py
import sys
import z3

from ..arch.arch_x86_64 import x8664Arch
from . import BVExpr

class TritonSimplifierException(Exception):
    def __init__(self, msg):
        self.message = msg
        super().__init__(msg)

class TritonSimplifier(object):
    def __init__(self):
        try:
            import triton
        except:
            sys.stderr.write("TritonSimplifier(): you must install the Triton symbolic engine\n")
            return

        self.ctx = triton.TritonContext(
            triton.ARCH.X86_64)
        self.ast_ctx = self.ctx.getAstContext()
        self.vars = dict()

    def _expr_to_triton(self, expr:z3.BitVecRef):
        # triton z3ToTriton API seems broken...

        if expr.decl().kind() == z3.Z3_OP_UNINTERPRETED:
            if expr.sort().kind() == z3.Z3_ARRAY_SORT:
                raise TritonSimplifierException("arrays unsupported")
            expr_name = expr.decl().name()
            if expr_name in self.vars:
                return self.vars[expr_name]
            self.vars[expr_name] = self.ast_ctx.variable(
                self.ctx.newSymbolicVariable(expr.size(), expr.decl().name()))
            return self.vars[expr_name]

        elif expr.decl().name() in {'select', 'store'}:
            raise TritonSimplifierException("arrays unsupported")

        elif expr.decl().name() == 'bv':
            return self.ast_ctx.bv(expr.as_long(), expr.size())

        elif expr.decl().name() == 'true':
            return self.ast_ctx.bvtrue()

        elif expr.decl().name() == 'false':
            return self.ast_ctx.bvfalse()

        elif expr.decl().name() == 'concat':
            return self.ast_ctx.concat(
                list(map(self._expr_to_triton, expr.children())))

        elif expr.decl().name() == 'extract':
            h, l = expr.params()
            e = expr.children()[0]
            return self.ast_ctx.extract(h, l, self._expr_to_triton(e))

        elif expr.decl().name() == 'bvadd':
            lhs, rhs = expr.children()
            return self.ast_ctx.bvadd(
                self._expr_to_triton(lhs), self._expr_to_triton(rhs))

        elif expr.decl().name() == 'bvsub':
            lhs, rhs = expr.children()
            return self.ast_ctx.bvsub(
                self._expr_to_triton(lhs), self._expr_to_triton(rhs))

        elif expr.decl().name() == 'bvmul':
            lhs, rhs = expr.children()
            return self.ast_ctx.bvmul(
                self._expr_to_triton(lhs), self._expr_to_triton(rhs))

        elif expr.decl().name() == 'bvxor':
            lhs, rhs = expr.children()
            return self.ast_ctx.bvxor(
                self._expr_to_triton(lhs), self._expr_to_triton(rhs))

        elif expr.decl().name() == 'bvand':
            lhs, rhs = expr.children()
            return self.ast_ctx.bvand(
                self._expr_to_triton(lhs), self._expr_to_triton(rhs))

        elif expr.decl().name() == 'bvor':
            lhs, rhs = expr.children()
            return self.ast_ctx.bvor(
                self._expr_to_triton(lhs), self._expr_to_triton(rhs))

        elif expr.decl().name() == 'bvnot':
            e = expr.children()[0]
            return self.ast_ctx.bvnot(self._expr_to_triton(e))

        elif expr.decl().name() == 'bvneg':
            e = expr.children()[0]
            return self.ast_ctx.bvneg(self._expr_to_triton(e))

        elif expr.decl().name() == 'and':
            return self.ast_ctx.land(
                list(map(self._expr_to_triton, expr.children())))

        elif expr.decl().name() == 'zero_extend':
            n = expr.params()[0]
            e = expr.children()[0]
            return self.ast_ctx.zx(n, self._expr_to_triton(e))

        elif expr.decl().name() == 'sign_extend':
            n = expr.params()[0]
            e = expr.children()[0]
            return self.ast_ctx.sx(n, self._expr_to_triton(e))

        elif expr.decl().name() == 'bvashr':
            expr, shift = expr.children()
            return self.ast_ctx.bvashr(
                self._expr_to_triton(expr), self._expr_to_triton(shift))

        elif expr.decl().name() == 'bvlshr':
            expr, shift = expr.children()
            return self.ast_ctx.bvlshr(
                self._expr_to_triton(expr), self._expr_to_triton(shift))

        elif expr.decl().name() == 'bvsge':
            lhs, rhs = expr.children()
            return self.ast_ctx.bvsge(
                self._expr_to_triton(lhs), self._expr_to_triton(rhs))

        elif expr.decl().name() == 'bvsgt':
            lhs, rhs = expr.children()
            return self.ast_ctx.bvsgt(
                self._expr_to_triton(lhs), self._expr_to_triton(rhs))

        elif expr.decl().name() == 'bvsle':
            lhs, rhs = expr.children()
            return self.ast_ctx.bvsle(
                self._expr_to_triton(lhs), self._expr_to_triton(rhs))

        elif expr.decl().name() == 'bvslt':
            lhs, rhs = expr.children()
            return self.ast_ctx.bvslt(
                self._expr_to_triton(lhs), self._expr_to_triton(rhs))

        elif expr.decl().name() == 'bvule':
            lhs, rhs = expr.children()
            return self.ast_ctx.bvule(
                self._expr_to_triton(lhs), self._expr_to_triton(rhs))

        elif expr.decl().name() == 'bvult':
            lhs, rhs = expr.children()
            return self.ast_ctx.bvult(
                self._expr_to_triton(lhs), self._expr_to_triton(rhs))

        elif expr.decl().name() == 'bvuge':
            lhs, rhs = expr.children()
            return self.ast_ctx.bvuge(
                self._expr_to_triton(lhs), self._expr_to_triton(rhs))

        elif expr.decl().name() == 'bvugt':
            lhs, rhs = expr.children()
            return self.ast_ctx.bvugt(
                self._expr_to_triton(lhs), self._expr_to_triton(rhs))

        elif expr.decl().name() == '=':
            lhs, rhs = expr.children()
            return self.ast_ctx.equal(
                self._expr_to_triton(lhs), self._expr_to_triton(rhs))

        else:
            raise TritonSimplifierException("unsupported decl %s" % expr.decl().name())

    def simplify(self, expr):
        if not hasattr(self, "ctx"):
            return expr

        self.vars = dict()
        try:
            triton_expr = self._expr_to_triton(expr.z3obj)
        except TritonSimplifierException as e:
            sys.stderr.write(repr(e) + "\n")
            return expr

        simplified = self.ctx.synthesize(triton_expr)
        if simplified is not None and not simplified.equalTo(triton_expr):
            # Yes, yes... It is horrible, but does the job
            s = z3.Solver()
            s.add(expr.z3obj == 0)
            fake_str = "(assert (= %s (_ bv0 %d)))" % \
                (repr(simplified), expr.size)
            fake_str = "%s\n%s" % (s.to_smt2(), fake_str)
            fake_str = fake_str.replace("(check-sat)\n", "")
            z3_expr = z3.parse_smt2_string(fake_str)[-1].children()[0]
            return BVExpr(z3_expr.size(), z3_expr)
        return expr

```

`memory/memory_abstract.py`:

```py
import z3


class MemoryAbstract(object):
    def mmap(self, address: int, size: int, init):
        raise NotImplementedError

    def is_mapped(self, address: int):
        raise NotImplementedError

    def store(self, address: z3.BitVecRef, value: z3.BitVecRef, endness):
        raise NotImplementedError

    def load(self, address: z3.BitVecRef, size: int, endness):
        raise NotImplementedError

    def get_unmapped(self, size: int, start_from: int, from_end: int):
        raise NotImplementedError

    def allocate(self, size: int, init):
        raise NotImplementedError

    def copy(self, state):
        raise NotImplementedError

    def merge(self, other, merge_condition):
        raise NotImplementedError

    def register_read_hook(self, function):
        raise NotImplementedError

    def register_store_hook(self, function):
        raise NotImplementedError

```

`memory/memory_object.py`:

```py
from ..expr import BV, BVArray, Bool, ITE


class MemoryObj(object):
    def __init__(self, name, bits=64, bvarray=None):
        self.bvarray = BVArray(
            "MEMOBJ_" + name, bits, 8
        ) if bvarray is None else bvarray

        self.name = name
        self.bits = bits

    def __str__(self):
        return "<MemoryObj{bits} {name}>".format(
            bits=self.bits,
            name=self.name
        )

    def __repr__(self):
        return self.__str__()

    def load(self, index: BV):
        return self.bvarray.Select(index)

    def store(self, index: BV, value: BV, condition: Bool = None):
        if condition is None:
            self.bvarray.Store(index, value)
        else:
            # this can be inefficient
            self.bvarray.ConditionalStore(index, value, condition)

    def copy(self):
        return MemoryObj(self.name, self.bits, self.bvarray.copy())

    def merge(self, other, merge_condition: Bool):
        self.bvarray = self.bvarray.merge(other.bvarray, merge_condition)

```

`memory/registers.py`:

```py
from copy import deepcopy
from .sym_flat_memory import MemoryConcreteFlat
from ..expr import BVV, BVS, Bool, ITE


class Regs(object):

    attr = set(['state', 'bits', '_mem', '_regs', '_tmp_regs', '_last_mod', 'flags', '__class__', '__delattr__',
                '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__',
                '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__',
                '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__',
                '__str__', '__subclasshook__', '__weakref__', 'attr', 'copy', 'has_reg', 'merge'])

    def __init__(self, state):
        self.state = state
        self.bits = state.arch.bits()
        self._mem = MemoryConcreteFlat(state, self.bits // 8, self.bits)
        self._regs = dict()
        self._tmp_regs = dict()
        self.flags = dict()

        regs_data = state.arch.regs_data()
        for reg_name in regs_data:
            reg_info = regs_data[reg_name]
            self._mem.mmap(reg_info["addr"], reg_info["size"])

            self._regs[reg_name] = BVV(
                reg_info["addr"], self.bits), reg_info["size"]
            for subreg_name in reg_info["sub"]:
                subreg_info = reg_info["sub"][subreg_name]
                self._regs[subreg_name] = BVV(
                    reg_info["addr"] + subreg_info["offset"], self.bits), subreg_info["size"]

        for flag_name in state.arch.flags_data():
            default = state.arch.flags_default(flag_name)
            self.flags[flag_name] = BVS(
                flag_name, 1) if default is None else BVV(default, 1)

    def has_reg(self, reg_name: str):
        return reg_name in self._regs

    def __getattribute__(self, k):
        if k in Regs.attr:
            return super().__getattribute__(k)
        elif k in self._regs:
            reg_addr, reg_size = self._regs[k]
            return self._mem.load(reg_addr, reg_size, endness='big')
        elif k in self._tmp_regs:
            return self._tmp_regs[k]
        raise AttributeError("'%s' object has not attribute '%s'" %
                             (self.__class__.__name__, k))

    def __setattr__(self, k, val):
        if k in Regs.attr:
            return super().__setattr__(k, val)
        elif k in self._regs:
            reg_addr, reg_size = self._regs[k]
            if reg_size * 8 < val.size:
                print("WARNING trimming value size in regs.setattr")
                val = val.Extract(reg_size * 8 - 1, 0)
            self._mem.store(reg_addr, val, endness='big')
        elif "temp" in k:
            self._tmp_regs[k] = val
        else:
            raise AttributeError("'%s' object has not attribute '%s'" % (
                self.__class__.__name__, k))

    def copy(self, state):
        new_regs = Regs(state)
        new_regs._mem = self._mem.copy(state)
        new_regs.flags = deepcopy(self.flags)
        new_regs._tmp_regs = deepcopy(self._tmp_regs)
        return new_regs

    def merge(self, other, merge_condition: Bool):
        assert isinstance(other, Regs)

        for reg in self.state.arch.regs_data():
            assert reg in other.state.arch.regs_data()

            self_reg = getattr(self, reg)
            other_reg = getattr(other, reg)

            if self_reg.eq(other_reg):
                continue

            setattr(self, reg,
                    ITE(
                        merge_condition,
                        other_reg,
                        self_reg
                    )
                    )

```

`memory/sym_file.py`:

```py
from ..expr import BV, BVV, BVS
from .sym_flat_memory_not_paged import MemoryConcreteFlatNotPaged


class SymFile(object):
    def __init__(self, filename, symfile=None):
        self.filename = filename
        if symfile is None:
            self.data = MemoryConcreteFlatNotPaged(filename)
            self.seek_idx = 0
            self.file_size = 0
        else:
            self.data = symfile.data.copy()
            self.seek_idx = symfile.seek_idx
            self.file_size = symfile.file_size

    def __str__(self):
        return "<SymFile %s, size: %s>" % (self.filename, self.file_size)

    def __repr__(self):
        return self.__str__()

    def seek(self, idx: int):
        self.seek_idx = idx

    def read(self, size: int) -> list:
        res = []
        for i in range(self.seek_idx, self.seek_idx + size):
            res.append(self.data.load(BVV(i, self.data.bits), 1))

        self.seek_idx += size
        self.file_size = max(self.file_size, self.seek_idx)
        return res

    def write(self, data: list):
        for i, el in enumerate(data):
            assert isinstance(el, BV) and el.size == 8
            self.data.store(
                BVV(self.seek_idx + i, 64),
                el
            )

        self.seek_idx += len(data)
        self.file_size = max(self.file_size, self.seek_idx)

    def merge(self, other, merge_condition):
        pass  # not implemented

    def copy(self, state=None):
        return SymFile(self.filename, self)

```

`memory/sym_flat_memory.py`:

```py
import math

from copy import deepcopy
from .memory_abstract import MemoryAbstract
from ..expr import BV, BVS
from ..utility.expr_wrap_util import symbolic


class Page(object):
    def __init__(self, addr, size, index_bits):
        self.addr = addr
        self.size = size
        self.index_bits = index_bits
        self.max_index = 2**index_bits - 1
        self._data = {}
        self._lazycopy = 0

    def read(self, index: int):
        assert 0 <= index <= self.max_index
        if index not in self._data:
            self._data[index] = BVS('page_%x_i%d' % (self.addr, index), 8)
        return self._data[index]

    def write(self, index: int, data: BV):
        assert 0 <= index <= self.max_index
        assert data.size == 8
        if self._lazycopy > 0:
            self._lazycopy -= 1
            new_page = Page(self.addr, self.size, self.index_bits)
            new_page._data = deepcopy(self._data)
            return new_page.write(index, data)

        self._data[index] = data
        return self

    def copy(self):
        self._lazycopy += 1
        return self


class MemoryConcreteFlat(MemoryAbstract):
    def __init__(self, state, page_size=0x100, bits=64):
        # page_size must be a power of 2
        assert (page_size & (page_size - 1)) == 0
        self.bits = bits
        self.state = state
        self.pages = dict()
        self.page_size = page_size
        self.index_bits = math.ceil(math.log(page_size, 2))

    def __str__(self):
        return "<SymMemoryFlat, %d pages>" % len(self.pages)

    def __repr__(self):
        return self.__str__()

    def mmap(self, address: int, size: int, init=None):
        assert address % self.page_size == 0
        assert size % self.page_size == 0
        for a in range(address // self.page_size, address // self.page_size + size // self.page_size, 1):
            self.pages[a] = Page(a * self.page_size,
                                 self.page_size, self.index_bits)

    def _store(self, page_address: int, page_index: int, value: BV):
        assert value.size == 8
        assert page_address in self.pages
        value = value.simplify()
        self.pages[page_address] = self.pages[page_address].write(
            page_index, value)

    def store(self, address: BV, value: BV, endness='big'):
        assert not symbolic(address)

        address = address.value
        size = value.size
        for i in range((size >> 3) - 1, -1, -1):
            if endness == 'little':
                addr = address + i
            else:
                addr = address + (size >> 3) - i - 1

            page_address = addr >> self.index_bits
            page_index = addr - (page_address << self.index_bits)

            self._store(page_address, page_index,
                        value.Extract(8*(i+1)-1, 8*i))

    def _load(self, page_address: int, page_index: int):
        assert page_address in self.pages
        return self.pages[page_address].read(page_index)

    def load(self, address: BV, size: int, endness='big'):
        assert not symbolic(address)

        address = address.value

        ran = range(size - 1, -1, -1) if endness == 'little' else range(size)
        res = None
        for i in ran:
            addr = address + i
            page_address = addr >> self.index_bits
            page_index = addr - (page_address << self.index_bits)

            tmp = self._load(page_address, page_index)
            res = tmp if res is None else res.Concat(tmp)

        return res.simplify()

    def is_mapped(self, address: int):
        return address >> self.index_bits in self.pages

    def get_unmapped(self, size, start_from, from_end):
        raise NotImplementedError

    def allocate(self, size):
        raise NotImplementedError

    def copy(self, state):
        new_memory = MemoryConcreteFlat(state, self.page_size, self.bits)
        new_pages = dict()
        for page_addr in self.pages:
            new_pages[page_addr] = self.pages[page_addr].copy()
        new_memory.pages = new_pages
        return new_memory

```

`memory/sym_flat_memory_not_paged.py`:

```py
from ..utility.expr_wrap_util import symbolic
from ..expr import BV, BVS
from .memory_abstract import MemoryAbstract


class MemoryConcreteFlatNotPaged(MemoryAbstract):
    def __init__(self, name, bits=64):
        self.name = name
        self.bits = bits
        self.values = {}
        self._lazycopy = False

    def __str__(self):
        return "<SymMemoryFlatNotPaged, %d values>" % len(self.values)

    def __repr__(self):
        return self.__str__()

    def _handle_lazycopy(self):
        if self._lazycopy:
            self._lazycopy = False
            old_dict = self.values
            self.values = {}
            for addr in old_dict:
                self.values[addr] = old_dict[addr]

    def mmap(self, address: int, size: int, init=None):
        pass  # do nothing

    def store(self, address: BV, value: BV, endness='big'):
        assert not symbolic(address)
        self._handle_lazycopy()

        address = address.value
        size = value.size

        for i in range(size // 8 - 1, -1, -1):
            if endness == 'little':
                addr = address + i
            else:
                addr = address + size // 8 - i - 1
            self.values[addr] = value.Extract(8*(i+1)-1, 8*i)

    def load(self, address: BV, size: int, endness='big'):
        assert not symbolic(address)

        address = address.value

        ran = range(size - 1, -1, -1) if endness == 'little' else range(size)
        res = None
        for i in ran:
            if (address+i) not in self.values:
                self.values[address+i] = BVS('unconstrained_{name}_{address}'.format(
                    name=self.name,
                    address=address + i,
                ), 8)

            tmp = self.values[address+i]
            res = tmp if res is None else res.Concat(tmp)

        return res

    def get_unmapped(self, size, start_from, from_end):
        raise NotImplementedError

    def allocate(self, size):
        raise NotImplementedError

    def copy(self, state=None):
        self._lazycopy = True
        res = MemoryConcreteFlatNotPaged(self.name, self.bits)
        res.values = self.values
        res._lazycopy = True
        return res

```

`memory/sym_memory.py`:

```py
import math

from collections import namedtuple
from ..utility.expr_wrap_util import symbolic, split_bv, heuristic_find_base
from ..utility import exceptions
from ..expr import BV, BVV, Bool, Or, ITE
from .memory_object import MemoryObj
from .memory_abstract import MemoryAbstract

# bytes: byte array; index: int
InitData = namedtuple('InitData', ['bytes', 'index'])


class Page(object):
    def __init__(self, addr: int, size: int = 0x1000, bits: int = 12, init: InitData = None):
        self.addr = addr
        self.size = size
        self.bits = bits
        self.dirty = False
        self.mo = MemoryObj("%Xh" % addr, bits)
        self._init = init
        self._lazycopy = 0

    def lazy_init(self):
        if self._init is not None:
            start = BVV(self._init.index, self.bits)
            val = self._init.bytes
            assert len(val) + self._init.index <= self.size
            for i in range(len(val)):
                subval = val[i]
                self.mo.store(start + i, BVV(subval, 8))
            self._init = None

    def store(self, index: BV, value: BV, condition: Bool = None):
        self.dirty = True

        self.lazy_init()
        if self._lazycopy > 0:
            self._lazycopy -= 1
            new_page = Page(self.addr, self.size, self.bits)
            new_page.mo = self.mo.copy()
            return new_page.store(index, value)

        index = index.simplify()
        self.mo.store(index, value, condition)
        return self

    def load(self, index: BV):
        self.lazy_init()
        return self.mo.load(index)

    def copy(self):
        self._lazycopy += 1
        return self


class Memory(MemoryAbstract):
    CHECK_SYMB_ADDR_WITH_SOLVER = False

    def __init__(self, state, page_size=0x1000, bits=64, symb_uninitialized=False):
        # page_size must be a power of 2
        assert (page_size & (page_size - 1)) == 0
        self.bits = bits
        self.state = state
        self.pages = dict()
        self.page_size = page_size
        self.index_bits = math.ceil(math.log(page_size, 2))
        self.symb_init = symb_uninitialized
        self.load_hooks = []
        self.store_hooks = []

    def __str__(self):
        return "<SymMemory, %d pages>" % len(self.pages)

    def __repr__(self):
        return self.__str__()

    def get_assertions_for_page(self, page_addr):
        if page_addr not in self.pages:
            return None

        return self.pages[page_addr].mo.bvarray.get_assertions()

    def mmap(self, address: int, size: int, init: InitData = None):
        assert address % self.page_size == 0
        assert size % self.page_size == 0

        init_val = None
        init_index = None
        if init is not None:
            init_val = init.bytes
            init_index = init.index
            data_index_i = 0
            data_index_f = self.page_size - init_index

        if not self.symb_init:
            # zero initialize
            if init_val is None:
                init_val = b"\x00" * size
                init_index = 0
            init_val = b"\x00" * init_index + init_val  # fill begin
            init_val = init_val + b"\x00" * \
                (self.page_size % len(init_val))  # fill end
            init_index = 0
            data_index_i = 0
            data_index_f = self.page_size

        i = 0
        for a in range(
            address // self.page_size,
            address // self.page_size + size // self.page_size,
            1
        ):
            if a not in self.pages:
                init_data = None
                if init_index is not None:
                    init_data = InitData(
                        init_val[data_index_i: data_index_f],
                        init_index)
                    init_index = 0  # only the first page has a starting index
                    data_index_i = data_index_f
                    data_index_f = data_index_i + self.page_size
                self.pages[a] = Page(
                    a, self.page_size, self.index_bits, init_data)
            else:
                print("remapping the same page '%s'" % hex(a))
            i += 1

    def is_mapped(self, address: int):
        return address >> self.index_bits in self.pages

    def _handle_symbolic_address(self, address: BV, size: int, op_type: str):

        if isinstance(address, BVV):
            return address, None, None
        if Memory.CHECK_SYMB_ADDR_WITH_SOLVER and not self.state.solver.symbolic(address):  # check with solver
            return self.state.solver.evaluate(address), None, None

        print("WARNING: memory %s, symbolic memory access" % op_type)
        symb_access_mode = self.state.executor.bncache.get_setting(
            "memory.symb_address_mode")
        page_limit = int(self.state.executor.bncache.get_setting(
            "memory.limit_pages_limit"))
        concretize_unconstrained = self.state.executor.bncache.get_setting(
            "memory.concretize_unconstrained") == 'true'
        use_heuristic_find_base = self.state.executor.bncache.get_setting(
            "memory.use_heuristic_find_base") == 'true'
        min_addr = None
        max_addr = None
        min_addr_approx = address.interval.low
        max_addr_approx = address.interval.high
        heuristic_base = None

        if concretize_unconstrained:
            min_addr_approx = address.interval.low
            max_addr_approx = address.interval.high

            if max_addr_approx - min_addr_approx == 2**self.state.arch.bits() - 1:
                # slow path. let's use the solver to validate
                min_addr = self.state.solver.min(address)
                max_addr = self.state.solver.max(address)

                if max_addr - min_addr == 2**self.state.arch.bits() - 1:
                    # unconstrained case
                    print(
                        "WARNING: memory %s, concretizing mem access to a newly allocated address (\"concretize_unconstrained\" policy)" % op_type)
                    address_conc = self.get_unmapped(
                        size // self.page_size + 1, from_end=False) * self.page_size
                    self.mmap(address_conc,
                              (size // self.page_size + 1) * self.page_size)
                    self.state.solver.add_constraints(address == address_conc)
                    address = BVV(address_conc, address.size)
                    return address, min_addr, max_addr

        if symb_access_mode == "concretization":
            print(
                "WARNING: memory %s, concretizing mem access (\"concretization\" policy)" % op_type)
            heuristic_base = heuristic_find_base(
                address) if heuristic_base is None else heuristic_base
            if use_heuristic_find_base and heuristic_base != -1 and self.state.solver.satisfiable([address == heuristic_base]):
                print("WARNING: memory %s, heuristic address 0x%x" %
                      (op_type, heuristic_base))
                address_conc = BVV(heuristic_base, address.size)
            else:
                address_conc = self.state.solver.evaluate(address)
            self.state.solver.add_constraints(address == address_conc)
            return address_conc, None, None

        if symb_access_mode == "fully_symbolic":
            return (
                address,
                min_addr_approx if min_addr is None else min_addr,
                max_addr_approx if max_addr is None else max_addr
            )

        assert symb_access_mode == "limit_pages"
        assert page_limit > 0

        if max_addr_approx - min_addr_approx == 2**self.state.arch.bits() - 1:
            # slow path. let's use the solver to validate
            min_addr = self.state.solver.min(
                address) if min_addr is None else min_addr
            max_addr = self.state.solver.max(
                address) if max_addr is None else max_addr
            if max_addr - min_addr > page_limit * self.page_size:
                print(
                    "WARNING: memory %s, limiting memory access (\"limit_pages\" policy)" % op_type)

                min_addr_page = min_addr >> self.index_bits
                max_addr_page = max_addr >> self.index_bits
                page_address, _ = split_bv(address, self.index_bits)

                heuristic_base = heuristic_find_base(
                    address) if heuristic_base is None else heuristic_base
                heuristic_base_page = heuristic_base >> self.index_bits

                if (
                    use_heuristic_find_base and
                    heuristic_base != -1 and
                    heuristic_base_page >= min_addr_page and
                    heuristic_base_page <= max_addr_page - page_limit and
                    self.state.solver.satisfiable([address == heuristic_base])
                ):
                    print("WARNING: memory %s, heuristic address 0x%x" %
                          (op_type, heuristic_base))
                    pivot = heuristic_base_page
                else:
                    # make it more efficient! (interval tree?)
                    pages_in_range = [page for page in self.pages if (
                        page >= min_addr_page and page <= max_addr_page)]

                    if pages_in_range:
                        pivot = min(pages_in_range)
                    else:
                        print(
                            "WARNING: memory %s, allocating pages (\"limit_pages\" policy)" % op_type)
                        pivot = self.get_unmapped(
                            self.page_size * page_limit, from_end=False)
                        self.mmap(pivot << self.index_bits,
                                  page_limit * self.page_size)

                condition = None
                for i in range(page_limit):
                    condition = (page_address == pivot + i) if condition is None else (
                        Or(condition, page_address == pivot + i))

                # I am not checking the satisfiability of every page, but at least the first one is satisfiable
                self.state.solver.add_constraints(condition)
                return address, min_addr, max_addr

        return (
            address,
            min_addr_approx if min_addr is None else min_addr,
            max_addr_approx if max_addr is None else max_addr
        )

    def _store(self, page_address: int, page_index: BV, value: BV, condition: Bool = None):
        assert page_address in self.pages
        assert value.size == 8

        value = value.simplify()
        self.pages[page_address] = self.pages[page_address].store(
            page_index, value, condition)

    def store(self, address, value: BV, endness='big'):
        if isinstance(address, int):
            address = BVV(address, self.state.arch.bits())
        assert address.size == self.bits

        for f in self.store_hooks:
            f(address, value.size)

        address, min_addr, max_addr = self._handle_symbolic_address(
            address, value.size, "store")

        conditions = list()
        size = value.size
        assert size % 8 == 0
        for i in range(size // 8 - 1, -1, -1):
            if endness == 'little':
                page_address, page_index = split_bv(
                    address + i, self.index_bits)
            else:
                page_address, page_index = split_bv(
                    address + size // 8 - i - 1, self.index_bits)

            # syntactic check + check with path constraint
            if not symbolic(page_address) or not self.state.solver.symbolic(page_address):
                if symbolic(page_address):
                    page_address = self.state.solver.evaluate(page_address)
                page_address = page_address.value
                if page_address not in self.pages:
                    self.state.executor.put_in_errored(
                        self.state, "write unmapped"
                    )
                    raise exceptions.UnmappedWrite(self.state.get_ip())
                self._store(page_address, page_index,
                            value.Extract(8*(i+1)-1, 8*i))
            else:  # symbolic access
                conditions = list()
                for p in self.pages:  # can be improved?
                    at_least_one_page = False
                    if p < (min_addr >> self.index_bits) or p > (max_addr >> self.index_bits):
                        continue
                    if self.state.solver.satisfiable(extra_constraints=[
                        page_address == p
                    ]):
                        at_least_one_page = True
                        condition = p == page_address
                        conditions.append(condition)
                        self._store(p, page_index, value.Extract(
                            8*(i+1)-1, 8*i), condition)
                if not at_least_one_page:
                    self.state.executor.put_in_errored(
                        self.state, "write unmapped"
                    )
                    raise exceptions.UnmappedWrite(self.state.get_ip())
            if conditions:
                check_unmapped = self.state.executor.bncache.get_setting(
                    "memory.check_unmapped") == 'true'
                if check_unmapped and self.state.solver.satisfiable(extra_constraints=[
                    Or(*conditions).Not()
                ]):
                    errored_state = self.state.copy()
                    errored_state.solver.add_constraints(Or(*conditions).Not())
                    self.state.executor.put_in_errored(
                        errored_state, "write unmapped"
                    )
                self.state.solver.add_constraints(Or(*conditions))

    def _load(self, page_address: int, page_index: BV):
        assert page_address in self.pages
        return self.pages[page_address].load(page_index)

    def load(self, address, size: int, endness='big'):
        if isinstance(address, int):
            address = BVV(address, self.state.arch.bits())
        assert address.size == self.bits

        for f in self.load_hooks:
            f(address, size)

        address, min_addr, max_addr = self._handle_symbolic_address(
            address, size, "load")

        res = None
        conditions = list()
        ran = range(size - 1, -1, -1) if endness == 'little' else range(size)
        for i in ran:
            page_address, page_index = split_bv(address + i, self.index_bits)
            # syntactic check + check with path constraint
            if not symbolic(page_address) or not self.state.solver.symbolic(page_address):
                if symbolic(page_address):
                    page_address = self.state.solver.evaluate(page_address)
                page_address = page_address.value
                if page_address not in self.pages:
                    self.state.executor.put_in_errored(
                        self.state, "read unmapped"
                    )
                    raise exceptions.UnmappedRead(self.state.get_ip())
                tmp = self._load(page_address, page_index)
            else:  # symbolic access
                conditions = list()
                tmp = None
                for p in self.pages:  # can be improved?
                    if p < (min_addr >> self.index_bits) or p > (max_addr >> self.index_bits):
                        continue
                    if self.state.solver.satisfiable(extra_constraints=[
                        page_address == p
                    ]):
                        condition = p == page_address
                        conditions.append(condition)
                        tmp = ITE(condition,
                                  self._load(p, page_index),
                                  tmp
                                  ) if tmp is not None else self._load(p, page_index)

                if tmp is None:
                    self.state.executor.put_in_errored(
                        self.state, "read unmapped"
                    )
                    raise exceptions.UnmappedRead(self.state.get_ip())
            res = tmp if res is None else res.Concat(tmp)

        if conditions:
            check_unmapped = self.state.executor.bncache.get_setting(
                "memory.check_unmapped") == 'true'
            if check_unmapped and self.state.solver.satisfiable(extra_constraints=[
                Or(*conditions).Not()
            ]):
                errored_state = self.state.copy()
                errored_state.solver.add_constraints(Or(*conditions).Not())
                self.state.executor.put_in_errored(
                    errored_state, "read unmapped"
                )
            self.state.solver.add_constraints(Or(*conditions))

        assert res is not None
        assert res.size // 8 == size

        return res.simplify()

    def get_unmapped(self, size: int, start_from: int = None, from_end: int = True):
        start_from = start_from >> self.index_bits if start_from is not None else None
        last_page = 2**(self.bits - self.index_bits) - 4
        first_page = 2

        if from_end:
            res = last_page if start_from is None else start_from
            count = 0

            while res >= first_page:
                if res not in self.pages:
                    count += 1
                    if count == size:
                        return res
                else:
                    count = 0
                res -= 1

            return -1

        else:
            idx = first_page if start_from is None else start_from
            res = first_page if start_from is None else start_from
            count = 0

            while idx <= last_page:
                if idx not in self.pages:
                    count += 1
                    if count == size:
                        return res
                else:
                    count = 0
                    idx += count+1
                    res = idx

            return -1

    def allocate(self, size: int, init: InitData = None):
        assert size > 0
        num_pages = (size + self.page_size - 1) >> self.index_bits
        page_addr = self.get_unmapped(num_pages)
        full_addr = page_addr << self.index_bits
        self.mmap(full_addr, num_pages * self.page_size, init)

        return full_addr

    def copy(self, state):
        new_memory = Memory(state, self.page_size, self.bits)
        new_pages = dict()
        for page_addr in self.pages:
            new_pages[page_addr] = self.pages[page_addr].copy()
        new_memory.pages = new_pages
        return new_memory

    def merge(self, other, merge_condition: Bool):
        assert isinstance(other, Memory)
        for page_addr in other.pages:
            other_page = other.pages[page_addr]

            if (
                page_addr in self.pages and
                self.pages[page_addr].mo.bvarray.z3obj.eq(
                    other_page.mo.bvarray.z3obj)
            ):
                continue  # very same page. No need to update

            if page_addr not in self.pages:
                self.mmap(page_addr, self.page_size)

            self.pages[page_addr].mo.merge(
                other_page.mo,
                merge_condition
            )

    def register_read_hook(self, function):
        self.read_hooks.append(function)

    def register_store_hook(self, function):
        self.store_hooks.append(function)

```

`models/function_models.py`:

```py
from ..expr import BVV, BVS
from . import others as models_other
from . import libc as models_libc
from . import unistd as models_unistd
from . import string as models_string
from . import teensy as models_teensy

def reval_model(val, nbits):
    return lambda state, view: BVV(val, nbits)

library_functions = {
    'printf':           models_libc.printf_handler,
    '__printf_chk':     models_libc.printf_chk_handler,
    'scanf':            models_libc.scanf_handler,
    '__isoc99_scanf':   models_libc.scanf_handler,
    'getchar':          models_libc.getchar_handler,
    'putchar':          models_libc.putchar_handler,
    'puts':             models_libc.puts_handler,
    'fgets':            models_libc.fgets_handler,
    'strcmp':           models_string.strcmp_handler,
    'strlen':           models_string.strlen_handler,
    'strcpy':           models_string.strcpy_handler,
    'strncpy':          models_string.strncpy_handler,
    'isxdigit':         models_libc.isxdigit_handler,
    'atoi':             models_libc.atoi_handler,
    'atol':             models_libc.atol_handler,
    'atoll':            models_libc.atol_handler,
    'malloc':           models_libc.malloc_handler,
    'calloc':           models_libc.calloc_handler,
    'read':             models_unistd.read_handler,
    'write':            models_unistd.write_handler,
    'memcmp':           models_string.memcmp_handler,
    'memset':           models_string.memset_handler,
    'time':             models_other.time_handler,
    'stat':             models_unistd.stat_handler,
    '__xstat':          models_unistd.xstat_handler,
    'exit':             models_libc.exit_handler,

    # C++
    '_Znwm':            models_libc.malloc_handler,
    '_Znwj':            models_libc.malloc_handler,

    # concrete models
    'strtoul':          models_libc.strtoul_handler,
    'srand':            models_libc.srand_handler,
    'rand':             models_libc.rand_handler,

    # models Teensy Board
    # Print::println(int)
    '_ZN5Print7printlnEi':   models_teensy.println_handler,
    # Print::println(char*)
    '_ZN5Print7printlnEPKc': models_teensy.println_handler
}

```

`models/libc.py`:

```py
from ..sym_state import State
from ..utility.expr_wrap_util import symbolic
from ..expr import BVV, BVS, BoolV, ITE, Or, And
from ..utility.models_util import get_arg_k
from ..utility.exceptions import ExitException, ModelError
from ..utility.string_util import as_bytes, str_to_bv_list
from ..memory.sym_memory import InitData
import re
import os
import ctypes
import ctypes.util

if os.name == 'nt':
    # windows
    libc_native_path = ctypes.util.find_library('msvcrt')
else:
    libc_native_path = ctypes.util.find_library('c')
libc_native = ctypes.cdll.LoadLibrary(libc_native_path)
ascii_numbers = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]

# ---- NATIVE CONCRETE HANDLERS -----

def srand_handler(state: State, view):
    seed = get_arg_k(state, 1, state.arch.bits() // 8, view)
    libc_native.srand(seed.value)
    return BVV(1, 32)

def rand_handler(state: State, view):
    val = libc_native.rand()
    return BVV(val, 32)

def strtoul_handler(state: State, view):
    str_p = get_arg_k(state, 1, state.arch.bits() // 8, view)
    endptr = get_arg_k(state, 2, state.arch.bits() // 8, view)
    base = get_arg_k(state, 3, 4, view)

    if symbolic(base) or symbolic(endptr) or symbolic(str_p):
        raise ModelError("strtoul", "symbolic arguments are not supported")

    i = 0
    str_data = b""
    b = state.mem.load(str_p, 1)
    while not symbolic(b) and i < 64:
        b = b.value
        str_data += bytes([b])
        if b == 0:
            break
        i += 1
        b = state.mem.load(str_p + i, 1)

    _native_buff = ctypes.c_char_p(str_data)
    _native_endptr = ctypes.c_ulong(0)
    _native_base = base.value

    _native_res = libc_native.strtoul(
        _native_buff,
        ctypes.byref(_native_endptr),
        _native_base
    )

    offset = (_native_endptr.value & 0xffffffff) - \
        (ctypes.cast(_native_buff, ctypes.c_void_p).value & 0xffffffff)
    assert offset >= 0
    state.mem.store(endptr, BVV((str_p.value + offset),
                                state.arch.bits()), 'little')
    return BVV(_native_res, state.arch.bits())
# -----------------------------------


def exit_handler(state: State, view):
    raise ExitException()


def _intbv_to_strbv16(intbv):
    # int bv to string bv in hex
    res = [BVV(ord("0"), 8), BVV(ord("x"), 8)]
    for b in as_bytes(intbv):
        low = b.Extract(3, 0).ZeroExt(4)
        hig = b.Extract(7, 4).ZeroExt(4)

        rb_low = ITE(
            low.ULT(10),
            BVV(ord("0"), 8) + low,
            BVV(ord("A"), 8) - 10 + low
        )
        rb_hig = ITE(
            hig.ULT(10),
            BVV(ord("0"), 8) + hig,
            BVV(ord("A"), 8) - 10 + hig
        )
        v = [rb_hig, rb_low]
        res.extend(v)

    return res


def _printf_common(state: State, format_str_p, param_idx_start, view):
    assert not symbolic(
        format_str_p) or not state.solver.symbolic(format_str_p)

    b = state.mem.load(format_str_p, 1)
    format_str = ""
    while not symbolic(b) and b.value != 0:
        format_str += chr(b.value)
        format_str_p += 1
        b = state.mem.load(format_str_p, 1)

    state.events.append(
        "printf with format '%s'" % format_str
    )

    match = ""
    res = list()
    last_idx = 0
    param_idx = param_idx_start
    params = re.finditer("%([0-9]*s|d|u|x|X|c)", format_str)  # TODO generalize
    for param in params:
        index = param.start()
        match = param.group()

        val = list()
        if match[-1] == "s":
            # string
            param_p = get_arg_k(state, param_idx, state.arch.bits() // 8, view)
            max_symb_str = int(state.executor.bncache.get_setting(
                "models.max_size_symb_string"))
            l = int(match[1:-1]) if len(match) > 2 else max_symb_str

            i = 0
            c = state.mem.load(param_p, 1)
            while i < l:
                if not symbolic(c) and c.value == 0:
                    break
                val.append(c)
                param_p += 1
                c = state.mem.load(param_p, 1)
                i += 1

        elif match == "%d" or match == "%u" or match == "%x" or match == "%X":
            int_val = get_arg_k(state, param_idx, 4, view)
            if symbolic(int_val):
                val = _intbv_to_strbv16(int_val)
            else:
                if match == "%d" or match == "%u":
                    val = str_to_bv_list(str(int_val.value))
                else:
                    val = str_to_bv_list(hex(int_val.value)[2:])

        elif match == "%c":
            c = get_arg_k(state, param_idx, 1, view)

            val = [c]

        param_idx += 1

        format_substr = format_str[last_idx:index]
        last_idx = index + len(match)
        res.extend(str_to_bv_list(format_substr))
        res.extend(val)

    format_substr = format_str[last_idx + len(match):]
    res.extend(str_to_bv_list(format_substr))

    return res, BVV(len(res), 32)


def printf_handler(state: State, view):  # only concrete
    format_str_p = get_arg_k(state, 1, state.arch.bits() // 8, view)
    data_list, res_n = _printf_common(state, format_str_p, 2, view)

    state.os.write(state.os.stdout_fd, data_list)
    return res_n


def printf_chk_handler(state: State, view):
    flag = get_arg_k(state, 1, 4, view)  # TODO ignored
    format_str_p = get_arg_k(state, 2, state.arch.bits() // 8, view)
    data_list, res_n = _printf_common(state, format_str_p, 3, view)

    state.os.write(state.os.stdout_fd, data_list)
    return res_n


def putchar_handler(state: State, view):
    res = get_arg_k(state, 1, 4, view)
    c = res.Extract(7, 0)

    state.os.write(state.os.stdout_fd, [c])
    return res


def puts_handler(state: State, view):
    string_p = get_arg_k(state, 1, state.arch.bits() // 8, view)

    max_symb_str = int(state.executor.bncache.get_setting(
        "models.max_size_symb_string"))
    i = 0
    c = state.mem.load(string_p, 1)
    while (not symbolic(c) and c.value != 0) or (symbolic(c) and i < max_symb_str):
        state.os.write(state.os.stdout_fd, [c])
        i += 1
        c = state.mem.load(string_p + i, 1)

    return BVV(0, 32)


def getchar_handler(state: State, view):
    state.events.append(
        "getchar called"
    )

    v = state.os.read(state.os.stdin_fd, 1)
    return v[0]


scanf_count = 0


def scanf_handler(state: State, view):
    # scanf does not support reading data from stdin... Too difficult to model
    # it will simply write on stdin the correct data
    global scanf_count
    format_str_p = get_arg_k(state, 1, state.arch.bits() // 8, view)

    assert not symbolic(
        format_str_p) or not state.solver.symbolic(format_str_p)

    b = state.mem.load(format_str_p, 1)
    format_str = ""
    while not symbolic(b) and b.value != 0:
        format_str += chr(b.value)
        format_str_p += 1
        b = state.mem.load(format_str_p, 1)

    state.events.append(
        "scanf with format '%s'" % format_str
    )

    match = ""
    bytes_read = list()
    last_idx = 0
    param_idx = 2
    params = re.finditer("%([0-9]*s|d|x)", format_str)  # TODO generalize
    for param in params:
        index = param.start()
        match = param.group()

        tmp_bytes_red = list()
        par_p = get_arg_k(state, param_idx, state.arch.bits() // 8, view)
        assert not symbolic(par_p) or not state.solver.symbolic(par_p)
        name = 'scanf_input_%d' % scanf_count

        if match[-1] == "d" or match[-1] == "x":
            data = BVS(name + "_INT", 32)
            state.mem.store(par_p, data, endness=state.arch.endness())
            tmp_bytes_red = _intbv_to_strbv16(data)
        elif match[-1] == "s":
            max_symb_str = int(state.executor.bncache.get_setting(
                "models.max_size_symb_string"))
            n = int(match[1:-1]) if len(match) > 2 else max_symb_str

            data = BVS(name + "_STR", 8*(n - 1))
            state.mem.store(par_p, data.Concat(BVV(0, 8)), 'big')
            for i in range(0, data.size, 8):
                b = data.Extract(i+7, i)
                state.solver.add_constraints(b != ord("\n"))
                tmp_bytes_red.append(b)

        param_idx += 1

        format_substr = format_str[last_idx:index]
        last_idx = index + len(match)
        bytes_read.extend(str_to_bv_list(format_substr))
        bytes_read.extend(tmp_bytes_red)

        scanf_count += 1

    format_substr = format_str[last_idx + len(match):]
    bytes_read.extend(str_to_bv_list(format_substr))
    state.os.write(state.os.stdin_fd, bytes_read)
    return BVV(1, 32)


def fgets_handler(state: State, view):
    s_p = get_arg_k(state, 1, state.arch.bits() // 8, view)
    size = get_arg_k(state, 2, 4, view)
    if symbolic(size):
        actual_size = state.solver.max(size)
        max_size = state.executor.bncache.get_setting(
            "models.max_size_symb_string")

        if actual_size > max_size:
            actual_size = max_size
            state.solver.add_constraints(size == actual_size)
    else:
        actual_size = size.value

    for i in range(actual_size):
        # TODO get correct FD
        v = state.os.read(state.os.stdin_fd, 1)[0]
        state.mem.store(s_p + i, v)
    state.mem.store(s_p + actual_size, BVV(0, 8))

    return s_p


def isxdigit_handler(state: State, view):
    c = get_arg_k(state, 1, 4, view)

    res = ITE(
        Or(
            And(c >= 48, c <= 57),  # 0 -> 9
            And(c >= 97, c <= 102),  # a -> f
            And(c >= 65, c <= 70)   # A -> F
        ), BVV(1, 32), BVV(0, 32)
    )
    return res

# ************** atoX models **************


# SLOW... but cool :)
atox_idx = 0


def _atox(state: State, view, size: int):
    atox_slow_model = state.executor.bncache.get_setting(
        "models.use_atox_slow_model") == 'true'
    if not atox_slow_model:
        global atox_idx
        atox_idx += 1
        return BVS('atox_unconstrained_{idx}'.format(atox_idx), size*8)

    input_p = get_arg_k(state, 1, state.arch.bits() // 8, view)

    if symbolic(input_p) and state.solver.symbolic(input_p):
        # FIXME: I should:
        #            1. return a fresh new symbol
        #            2. allocate a new buffer with a concrete address
        #            3. store the correct expression in the buffer for consistency
        raise ModelError("atox", "symbolic input pointer (not supported)")

    def build_or_expression(b):
        conditions = []
        for n in ascii_numbers:
            n = ord(n)
            conditions.append(b == n)
        return Or(*conditions)

    max_len = len(str(2**(size * 8)))  # max valid number

    first_char = state.mem.load(input_p, 1)
    state.solver.add_constraints(
        build_or_expression(first_char)
    )  # first char must be ascii

    i = 1
    char = state.mem.load(input_p + i, 1)
    chars = []
    while i <= max_len:

        cond_1 = build_or_expression(char)
        cond_2 = char == 0
        cond_3 = BoolV(False)
        for old_char in chars:
            cond_2 = And(
                cond_2,
                old_char != 0
            )
            cond_3 = Or(
                cond_3,
                old_char == 0
            )
        cond = Or(
            cond_1, cond_2, cond_3
        )
        state.solver.add_constraints(
            cond
        )

        chars.append(char)
        i += 1
        char = state.mem.load(input_p + i, 1)

    chars = [first_char] + chars

    # one bit more, to prevent overflow
    res = first_char.ZeroExt(size*8+1-8) - ord('0')
    for i in range(len(chars)-1, 0, -1):
        char = chars[i]

        expr = None
        for j in range(len(chars[:i])):
            # one bit more, to prevent overflow
            old_char = chars[i-j-1].ZeroExt(size*8+1-8)
            if expr is not None:
                expr += (10**j)*(old_char - ord('0'))
            else:
                expr = (10**j)*(old_char - ord('0'))

        res = ITE(
            char == 0,
            expr,
            res
        )

    # prevent overflow
    overflow_bit = res.Extract(size*8, size*8)
    state.solver.add_constraints(
        overflow_bit == 0
    )

    assert state.solver.satisfiable()
    return res.Extract(size*8-1, 0)


def atoi_handler(state: State, view):
    return _atox(state, view, 4)


def atol_handler(state: State, view):
    return _atox(state, view, 8)

# ********* MALLOC MODELS *********


def malloc_handler(state: State, view):
    size = get_arg_k(state, 1, 4, view)
    max_malloc = int(state.executor.bncache.get_setting(
        "models.max_malloc_size"))
    if symbolic(size):
        size = state.solver.max(size)
        if size > max_malloc:
            size = max_malloc
    else:
        size = size.value

    res = state.mem.allocate(size)
    return BVV(res, state.arch.bits())


def calloc_handler(state: State, view):
    size = get_arg_k(state, 1, 4, view)
    max_malloc = int(state.executor.bncache.get_setting(
        "models.max_malloc_size"))
    if symbolic(size):
        size = state.solver.max(size)
        if size > max_malloc:
            size = max_malloc
    else:
        size = size.value

    res = state.mem.allocate(
        size,
        InitData(bytes=b"\x00"*size, index=0)
    )
    return BVV(res, state.arch.bits())

# ***************************************

```

`models/linux_syscalls.py`:

```py
from ..utility.expr_wrap_util import symbolic
from ..expr import BVV, BVS

MAX_READ = 100


def read_handler(state):
    fd_reg = state.os.get_syscall_parameter(1)
    buf_reg = state.os.get_syscall_parameter(2)
    count_reg = state.os.get_syscall_parameter(3)

    fd = getattr(state.regs, fd_reg)
    buf = getattr(state.regs, buf_reg)
    count = getattr(state.regs, count_reg)

    assert not symbolic(fd) or not state.solver.symbolic(fd)
    fd = fd.value
    assert state.os.is_open(fd)

    if symbolic(count):
        count = state.solver.max(count)
        count = MAX_READ if count > MAX_READ else count
    else:
        count = count.value

    res = state.os.read(fd, count)
    for i, b in enumerate(res):
        state.mem.store(buf + i, b)

    state.events.append(
        "read from fd %d, count %d" % (fd, count)
    )
    return BVV(count, 32)


def write_handler(state):
    fd_reg = state.os.get_syscall_parameter(1)
    buf_reg = state.os.get_syscall_parameter(2)
    count_reg = state.os.get_syscall_parameter(3)

    fd = getattr(state.regs, fd_reg)
    buf = getattr(state.regs, buf_reg)
    count = getattr(state.regs, count_reg)

    assert not symbolic(fd) or not state.solver.symbolic(fd)
    fd = fd.value
    assert state.os.is_open(fd)

    if symbolic(count):
        count = state.solver.max(count)
        count = MAX_READ if count > MAX_READ else count
    else:
        count = count.value

    data = []
    for i in range(count):
        b = state.mem.load(buf + i, 1)
        data.append(b)
    state.os.write(fd, data)

    state.events.append(
        "write to fd %d, count %d" % (fd, count)
    )
    return BVV(count, 32)


def exit_handler(state):
    pass

```

`models/others.py`:

```py
from ..sym_state import State
from ..utility.expr_wrap_util import symbolic
from ..expr import BVV, BVS
from ..utility.models_util import get_arg_k

time_idx = 0


def time_handler(state: State, view):
    global time_idx
    res = BVS("time_%d" % time_idx, state.arch.bits())

    return res


pid_cache = None


def getpid_handler(state: State, view):
    res = pid_cache if pid_cache else BVS('pid_symb', 32)

    return res

```

`models/string.py`:

```py
from ..sym_state import State
from ..utility.expr_wrap_util import symbolic
from ..expr import BVV, BVS, BoolV, And, ITE
from ..utility.models_util import get_arg_k


def memcmp_handler(state: State, view):
    buff1 = get_arg_k(state, 1, state.arch.bits() // 8, view)
    buff2 = get_arg_k(state, 2, state.arch.bits() // 8, view)
    n = get_arg_k(state, 3, state.arch.bits() // 8, view)

    if symbolic(n):
        n = state.solver.max(n)
        max_memcmp = int(state.executor.bncache.get_setting(
            "models.max_memcmp_size"))
        if n > max_memcmp:
            n = max_memcmp
    else:
        n = n.value

    res = BoolV(True)
    for i in range(n):
        c1 = state.mem.load(buff1 + i, 1)
        c2 = state.mem.load(buff2 + i, 1)

        res = And(
            c1 == c2, res
        )

    return ITE(res, BVV(0, 32), BVV(1, 32))


def memset_handler(state: State, view):
    buff = get_arg_k(state, 1, state.arch.bits() // 8, view)
    val = get_arg_k(state, 2, 1, view)
    n = get_arg_k(state, 3, 4, view)

    if symbolic(n):
        n = state.solver.max(n)
        max_memset = int(state.executor.bncache.get_setting(
            "models.max_memset_size"))
        if n > max_memset:
            n = max_memset
    else:
        n = n.value

    for i in range(n):
        state.mem.store(buff+i, val)

    return buff


def strcmp_handler(state: State, view):
    str1 = get_arg_k(state, 1, state.arch.bits() // 8, view)
    str2 = get_arg_k(state, 2, state.arch.bits() // 8, view)

    assert not symbolic(str1) or not state.solver.symbolic(str1)
    assert not symbolic(str2) or not state.solver.symbolic(str2)
    if symbolic(str1):
        str1 = state.solver.evaluate(str1)
    if symbolic(str2):
        str1 = state.solver.evaluate(str2)

    max_sym_string = int(state.executor.bncache.get_setting(
        "models.max_size_symb_string"))

    b1 = state.mem.load(str1, 1)
    b2 = state.mem.load(str2, 1)
    cond = BoolV(True)
    i = 0
    while True:
        if not symbolic(b1) or not state.solver.symbolic(b1):
            b1 = state.solver.evaluate(b1) if symbolic(b1) else b1
            if b1.value == 0:
                break
        if not symbolic(b2) or not state.solver.symbolic(b2):
            b2 = state.solver.evaluate(b2) if symbolic(b2) else b2
            if b2.value == 0:
                break

        if symbolic(b1) and symbolic(b2) and i > max_sym_string:
            state.solver.add_constraints(b1 == 0, b2 == 0)
            break

        cond = (b1 == b2).And(cond)
        str1 += 1
        str2 += 1
        b1 = state.mem.load(str1, 1)
        b2 = state.mem.load(str2, 1)
        i += 1

    return ITE(cond, BVV(0, 32), BVV(1, 32))


def strlen_handler(state: State, view):
    str1 = get_arg_k(state, 1, state.arch.bits() // 8, view)

    assert not symbolic(str1) or not state.solver.symbolic(str1)
    if symbolic(str1):
        str1 = state.solver.evaluate(str1)

    max_sym_string = int(state.executor.bncache.get_setting(
        "models.max_size_symb_string"))

    b1 = state.mem.load(str1, 1)
    vals = []
    i = 0
    while True:
        if not symbolic(b1) or not state.solver.symbolic(b1):
            b1 = state.solver.evaluate(b1)
            if b1.value == 0:
                break
        elif i > max_sym_string:
            state.solver.add_constraints(b1 == 0)
            break

        vals.append((i, b1))
        i += 1
        str1 += 1
        b1 = state.mem.load(str1, 1)

    res = BVV(i, state.arch.bits())
    for i, b in vals[::-1]:
        res = ITE(b == 0, BVV(i, state.arch.bits()), res)
    return res


def strcpy_handler(state: State, view):
    dst = get_arg_k(state, 1, state.arch.bits() // 8, view)
    src = get_arg_k(state, 2, state.arch.bits() // 8, view)

    assert not symbolic(dst) or not state.solver.symbolic(dst)
    assert not symbolic(src) or not state.solver.symbolic(src)
    if symbolic(dst):
        dst = state.solver.evaluate(dst)
    if symbolic(src):
        src = state.solver.evaluate(src)

    max_sym_string = int(state.executor.bncache.get_setting(
        "models.max_size_symb_string"))

    i = 0
    src_b = state.mem.load(src, 1)
    while True:
        if not symbolic(src_b) or not state.solver.symbolic(src_b):
            src_b = state.solver.evaluate(src_b) if symbolic(src_b) else src_b
            if src_b.value == 0:
                break
        elif i > max_sym_string:
            state.solver.add_constraints(src_b == 0)
            break

        state.mem.store(dst + i, src_b)
        i += 1
        src_b = state.mem.load(src + i, 1)

    state.mem.store(dst + i, BVV(0, 8))
    return dst


def strncpy_handler(state: State, view):
    dst = get_arg_k(state, 1, state.arch.bits() // 8, view)
    src = get_arg_k(state, 2, state.arch.bits() // 8, view)
    n = get_arg_k(state, 3, state.arch.bits() // 8, view)

    assert not symbolic(dst) or not state.solver.symbolic(dst)
    assert not symbolic(src) or not state.solver.symbolic(src)
    assert not symbolic(n) or not state.solver.symbolic(n)
    if symbolic(dst):
        dst = state.solver.evaluate(dst)
    if symbolic(src):
        src = state.solver.evaluate(src)
    if symbolic(n):
        n = state.solver.evaluate(n)

    n = n.value
    print(src, dst, n)

    i = 0
    src_b = state.mem.load(src, 1)
    while i < n:
        if not symbolic(src_b) or not state.solver.symbolic(src_b):
            src_b = state.solver.evaluate(src_b) if symbolic(src_b) else src_b
            if src_b.value == 0:
                break
        state.mem.store(dst + i, src_b)
        i += 1
        src_b = state.mem.load(src + i, 1)

    while i < n:
        state.mem.store(dst + i, BVV(0, 8))
        i += 1

    return dst

```

`models/teensy.py`:

```py
from ..sym_state import State
from ..utility.expr_wrap_util import symbolic
from ..expr import BVV, BVS
from ..utility.models_util import get_arg_k


def println_handler(state: State, view):
    to_print = get_arg_k(state, 0, state.arch.bits() // 8, view)
    state.events.append(
        "println called with parameter: {to_print}".format(
            to_print=to_print
        )
    )
    return BVV(0, 32)

```

`models/unistd.py`:

```py
from ..utility.expr_wrap_util import symbolic
from ..expr import BVV, BVS
from ..utility.models_util import get_arg_k
from ..sym_state import State

MAX_READ = 100


def read_handler(state: State, view):
    fd = get_arg_k(state, 1, 4, view)
    buf = get_arg_k(state, 2, state.arch.bits() // 8, view)
    count = get_arg_k(state, 3, 4, view)

    assert not symbolic(fd) or not state.solver.symbolic(fd)
    fd = fd.value
    assert state.os.is_open(fd)

    if symbolic(count):
        count = state.solver.max(count)
        count = MAX_READ if count > MAX_READ else count
    else:
        count = count.value

    res = state.os.read(fd, count)
    for i, b in enumerate(res):
        state.mem.store(buf + i, b)

    state.events.append(
        "read from fd %d, count %d" % (fd, count)
    )
    return BVV(count, 32)


def write_handler(state: State, view):
    fd = get_arg_k(state, 1, 4, view)
    buf = get_arg_k(state, 2, state.arch.bits() // 8, view)
    count = get_arg_k(state, 3, 4, view)

    assert not symbolic(fd) or not state.solver.symbolic(fd)
    fd = fd.value
    if symbolic(count):
        count = state.solver.max(count)
        count = MAX_READ if count > MAX_READ else count
    else:
        count = count.value

    data = []
    for i in range(count):
        b = state.mem.load(buf + i, 1)
        data.append(b)
    state.os.write(fd, data)

    state.events.append(
        "write to fd %d, count %d" % (fd, count)
    )
    return BVV(count, 32)


stat_idx = 0


def _stat(state: State, statbuf):
    global stat_idx

    long_t = state.arch.bits()
    int_t = 32

    st_dev = BVS('stat_st_dev_%d' % stat_idx,     long_t)
    st_ino = BVS('stat_st_ino_%d' % stat_idx,     long_t)
    st_mode = BVS('stat_st_mode_%d' % stat_idx,    long_t)
    st_nlink = BVS('stat_st_nlink_%d' % stat_idx,   long_t)
    st_uid = BVS('stat_st_uid_%d' % stat_idx,     int_t)
    st_gid = BVS('stat_st_gid_%d' % stat_idx,     int_t)
    st_rdev = BVS('stat_st_rdev_%d' % stat_idx,    long_t)
    st_size = BVS('stat_st_size_%d' % stat_idx,    long_t)
    st_blksize = BVS('stat_st_blksize_%d' % stat_idx, long_t)
    st_blocks = BVS('stat_st_blocks_%d' % stat_idx,  long_t)
    st_atim_tv_sec = BVS('stat_atim.sec_%d' % stat_idx,   long_t)
    st_atim_tv_nsec = BVS('stat_atim.nsec_%d' % stat_idx,  long_t)
    st_mtim_tv_sec = BVS('stat_mtim.sec_%d' % stat_idx,   long_t)
    st_mtim_tv_nsec = BVS('stat_mtim.nsec_%d' % stat_idx,  long_t)
    st_ctim_tv_sec = BVS('stat_ctim.sec_%d' % stat_idx,   long_t)
    st_ctim_tv_nsec = BVS('stat_ctim.nsec_%d' % stat_idx,  long_t)

    stat_idx += 1

    state.mem.store(statbuf + 0, st_dev,          state.arch.endness())
    state.mem.store(statbuf + 8, st_ino,          state.arch.endness())
    state.mem.store(statbuf + 16, st_nlink,        state.arch.endness())
    state.mem.store(statbuf + 24, st_mode,         state.arch.endness())
    state.mem.store(statbuf + 32, st_uid,          state.arch.endness())
    state.mem.store(statbuf + 36, st_gid,          state.arch.endness())
    state.mem.store(statbuf + 40, BVV(0, 8*8))  # padding
    state.mem.store(statbuf + 48, st_rdev,         state.arch.endness())
    state.mem.store(statbuf + 56, st_size,         state.arch.endness())
    state.mem.store(statbuf + 64, st_blksize,      state.arch.endness())
    state.mem.store(statbuf + 72, st_blocks,       state.arch.endness())
    state.mem.store(statbuf + 80, st_atim_tv_sec,  state.arch.endness())
    state.mem.store(statbuf + 88, st_atim_tv_nsec, state.arch.endness())
    state.mem.store(statbuf + 96, st_mtim_tv_sec,  state.arch.endness())
    state.mem.store(statbuf + 104, st_mtim_tv_nsec, state.arch.endness())
    state.mem.store(statbuf + 112, st_ctim_tv_sec,  state.arch.endness())
    state.mem.store(statbuf + 120, st_ctim_tv_nsec, state.arch.endness())
    state.mem.store(statbuf + 128, BVV(0, 8*16))  # reserved (zero (?))

    return BVV(0, 32)


def stat_handler(state: State, view):
    global stat_idx

    pathname = get_arg_k(state, 1, state.arch.bits() // 8, view)
    statbuf = get_arg_k(state, 2, state.arch.bits() // 8, view)

    path = ""
    if not symbolic(pathname):
        i = 0
        c = state.mem.load(pathname, 1)
        while not symbolic(c) and c.value != 0 and i < 100:
            path += chr(c.value)
            i += 1
            c = state.mem.load(pathname+i, 1)
    else:
        path = "<symbolic>"

    state.events.append(
        "stat on %s" % path
    )

    return _stat(state, statbuf)


def xstat_handler(state: State, view):
    version = get_arg_k(state, 1, 4, view)
    pathname = get_arg_k(state, 2, state.arch.bits() // 8, view)
    statbuf = get_arg_k(state, 3, state.arch.bits() // 8, view)

    path = ""
    if not symbolic(pathname):
        i = 0
        c = state.mem.load(pathname, 1)
        while not symbolic(c) and c.value != 0 and i < 100:
            path += chr(c.value)
            i += 1
            c = state.mem.load(pathname+i, 1)
    else:
        path = "<symbolic>"

    if not symbolic(version):
        version = str(version.value)
    else:
        version = "<symbolic>"

    state.events.append(
        "__xstat on %s. version %s" % (path, version)
    )

    return _stat(state, statbuf)

```

`multipath/fringe.py`:

```py
import random


class Fringe(object):
    def __init__(self):
        self.unsat = list()
        self.errored = list()
        self.avoided = list()
        self.exited = list()
        self._deferred = dict()
        self.last_added = None

    def __str__(self):
        return "<Fringe id: 0x%x, unsat: %d, errored: %d, avoided: %d, deferred: %d, exited: %d>" % (
            id(self), len(self.unsat), len(self.errored), len(
                self.avoided), len(self.deferred), len(self.exited)
        )

    def __repr__(self):
        return self.__str__()

    @property
    def deferred(self):
        res = list()
        for addr in self._deferred:
            res.extend(self._deferred[addr])
        return res

    @property
    def num_states(self):
        return len(self.unsat) + len(self.errored) + \
            len(self.avoided) + len(self.deferred) + \
            len(self.exited)

    def is_empty(self):
        return len(self._deferred) == 0

    def get_list_deferred_by_address(self, address):
        if address in self._deferred:
            return self._deferred[address]
        return list()

    def get_deferred_by_address(self, address, idx=None):
        if address in self._deferred:
            if idx is None:
                res = self._deferred[address].pop()
            else:
                if idx >= len(self._deferred[address]):
                    return None
                res = self._deferred[address][idx]
                del self._deferred[address][idx]

            if len(self._deferred[address]) == 0:
                del self._deferred[address]
            return res
        return None

    def get_all_deferred_by_address(self, address):
        if address in self._deferred:
            res = self._deferred[address]
            del self._deferred[address]
            return res
        return None

    def get_one_deferred(self):
        assert not self.is_empty()
        addr, states = self._deferred.popitem()
        state = states.pop()
        if states:
            self._deferred[addr] = states
        return state

    def get_random_deferred(self):
        assert not self.is_empty()
        addresses = list(self._deferred.keys())
        random.shuffle(addresses)
        random_address = addresses[0]
        states = self._deferred[random_address]
        random.shuffle(states)
        random_state = states.pop()
        if not states:
            del self._deferred[random_address]

        return random_state

    def add_deferred(self, state):
        self.last_added = state
        if state.get_ip() not in self._deferred:
            self._deferred[state.get_ip()] = [state]
        else:
            self._deferred[state.get_ip()].append(state)

    def add_errored(self, state):
        self.errored.append(state)

    def add_unsat(self, state):
        self.unsat.append(state)

    def add_avoided(self, state):
        self.avoided.append(state)

    def add_exited(self, state):
        self.exited.append(state)

```

`multipath/searcher.py`:

```py
import traceback


class Searcher(object):
    def __init__(self, executor):
        self.target = None
        self.avoid = []
        self.executor = executor

    def __str__(self):
        return "<%s target: %s, %d avoid>" % \
            (
                self.__class__.__name__,
                hex(self.target) if self.target is not None else "None",
                len(self.avoid)
            )

    def __repr__(self):
        return self.__str__()

    def set_target(self, target: int):
        self.target = target

    def add_avoid(self, avoid: int):
        self.avoid.append(avoid)

    def ready_to_run(self):
        return self.target is not None

    def run(self, step_callback=None):
        raise NotImplementedError


class DFSSearcher(Searcher):
    def __init__(self, executor):
        Searcher.__init__(self, executor)

    # override
    def run(self, step_callback=None, findall=False):
        res = []
        while 1:
            if not self.executor.state:
                break
            ip = self.executor.state.get_ip()
            if ip in self.avoid:
                if self.executor.fringe.is_empty():
                    break
                old_state = self.executor.state
                self.executor.fringe.add_avoided(old_state)
                self.executor.state = None
                new_state = self.executor.fringe.get_one_deferred()
                self.executor.set_current_state(new_state)
            ip = self.executor.state.get_ip()
            if ip == self.target:
                res.append(self.executor.state)
                if not findall or self.executor.fringe.is_empty():
                    break
                self.executor.state = None
                new_state = self.executor.fringe.get_one_deferred()
                self.executor.set_current_state(new_state)

            try:
                self.executor.execute_one()
            except Exception as e:
                print("!ERROR!:")
                print(traceback.format_exc())
                break

            if step_callback is not None:
                if not step_callback(self.executor.state):
                    break

        if not findall:
            return res[0] if len(res) > 0 else None

        state_res = res[0]
        self.executor.set_current_state(state_res)
        for state in res[1:]:
            self.executor.fringe.add_deferred(state)
        return state_res


class BFSSearcher(Searcher):
    def __init__(self, executor):
        Searcher.__init__(self, executor)

    def _continue_until_branch(self, step_callback):
        k = self.executor.fringe.last_added
        i = k
        while i == k:
            if not self.executor.state:
                return None
            ip = self.executor.state.get_ip()
            if ip in self.avoid:
                if self.executor.fringe.is_empty():
                    return None
                old_state = self.executor.state
                self.executor.fringe.add_avoided(old_state)
                self.executor.state = None
                new_state = self.executor.fringe.get_one_deferred()
                self.executor.set_current_state(new_state)
            ip = self.executor.state.get_ip()
            if ip == self.target:
                return True

            try:
                self.executor.execute_one()
            except Exception as e:
                print("!ERROR!:")
                print(traceback.format_exc())
                return None

            if step_callback is not None:
                if not step_callback(self.executor.state):
                    return None

            i = self.executor.fringe.last_added

        return False

    # override
    def run(self, step_callback=None):
        while 1:
            res = self._continue_until_branch(step_callback)
            if res is None:
                return None
            if res:
                return self.executor.state

            new_state = self.executor.fringe.get_random_deferred()
            self.executor.set_current_state(new_state)

```

`os_models/linux.py`:

```py
from copy import deepcopy
from ..models import linux_syscalls as models
from ..expr import Bool
from .os_file import OsFileHandler


class Linux(OsFileHandler):
    SYSCALL_TABLE = {}
    SYSCALL_PARAMS = {}

    def __init__(self):
        super().__init__()
        self.stdin_fd = self.open("__stdin",  "r--")
        self.stdout_fd = self.open("__stdout", "-w-")

    def get_syscall_by_number(self, n: int):
        if n not in self.SYSCALL_TABLE:
            return None
        return self.SYSCALL_TABLE[n]

    def get_syscall_parameter(self, k: int):
        assert 0 < k <= 6
        return self.SYSCALL_PARAMS[k-1]

    def get_stdin_stream(self):
        session = self.descriptors_map[self.stdin_fd]
        session_idx = session.seek_idx
        session.seek(0)
        res = session.read(session.symfile.file_size)
        session.seek(session_idx)

        return res

    def get_stdout_stream(self):
        session = self.descriptors_map[self.stdout_fd]
        session_idx = session.seek_idx
        session.seek(0)
        res = session.read(session.symfile.file_size)
        session.seek(session_idx)

        return res

    def copy_to(self, other):
        super().copy_to(other)
        other.stdin_fd = self.stdin_fd
        other.stdout_fd = other.stdout_fd


class Linuxi386(Linux):
    SYSCALL_TABLE = {
        0: None,
        3: models.read_handler,
        4: models.write_handler
    }
    SYSCALL_PARAMS = [
        "ebx",   "ecx",   "edx",   "esi",   "edi",   "ebp"
    ]

    def get_syscall_n_reg(self):
        return "eax"

    def get_out_syscall_reg(self):
        return "eax"

    def copy(self):
        res = Linuxi386()
        super().copy_to(res)
        return res

    def merge(self, other, merge_condition: Bool):
        assert isinstance(other, Linuxi386)
        pass  # TODO implement this


class Linuxia64(Linux):
    SYSCALL_TABLE = {
        0: models.read_handler,
        1: models.write_handler,
        2: None
    }
    SYSCALL_PARAMS = [
        "rdi",	"rsi",	"rdx",	"r10",	"r8",	"r9"
    ]

    def get_syscall_n_reg(self):
        return "rax"

    def get_out_syscall_reg(self):
        return "rax"

    def copy(self):
        res = Linuxia64()
        super().copy_to(res)
        return res

    def merge(self, other, merge_condition: Bool):
        assert isinstance(other, Linuxia64)
        pass  # TODO implement this


class LinuxArmV7(Linux):

    SYSCALL_TABLE = {
        0x900003: models.read_handler,
        0x900004: models.write_handler
    }
    SYSCALL_PARAMS = [
        "r0", "r1", "r2", "r3", "r4", "r5", "r6"
    ]

    def get_syscall_n_reg(self):
        return "r7"

    def get_out_syscall_reg(self):
        return "r0"

    def copy(self):
        res = LinuxArmV7()
        super().copy_to(res)
        return res

    def merge(self, other, merge_condition: Bool):
        assert isinstance(other, LinuxArmV7)
        pass  # TODO implement this

```

`os_models/os_abstract.py`:

```py
class Os(object):
    # syscall
    def get_syscall_by_number(self, n):
        raise NotImplementedError

    def get_syscall_n_reg(self):
        raise NotImplementedError

    def get_syscall_parameter(self, k):
        raise NotImplementedError

    def get_out_syscall_reg(self):
        raise NotImplementedError
    # devices

    def open(self, filename, mode):
        raise NotImplementedError

    def read(self, fd, size):
        raise NotImplementedError

    def write(self, fd, data):
        raise NotImplementedError

    def is_open(self, fd: int):
        raise NotImplementedError

    def close(self, fd: int):
        raise NotImplementedError

    def get_stdin_stream(self):
        raise NotImplementedError

    def get_stdout_stream(self):
        raise NotImplementedError
    # other

    def copy(self):
        raise NotImplementedError

    def merge(self, other, merge_condition):
        raise NotImplementedError

```

`os_models/os_file.py`:

```py
from ..memory.sym_file import SymFile
from .os_abstract import Os


class FileSession(object):
    def __init__(self, fd, symfile, mode):
        self.fd = fd
        self.symfile = symfile
        self.mode = mode  # for now, ignored
        self.seek_idx = 0

    def __str__(self):
        return "<FileSession {filename} @ {seek} - {fd}>".format(
            filename=self.symfile.filename,
            fd=self.fd,
            seek=self.seek_idx
        )

    def __repr__(self):
        return self.__str__()

    def seek(self, idx):
        self.seek_idx = idx

    def read(self, size: int) -> list:
        self.symfile.seek(self.seek_idx)
        self.seek_idx += size
        return self.symfile.read(size)

    def write(self, data: list):
        self.symfile.seek(self.seek_idx)
        self.symfile.write(data)
        self.seek_idx += len(data)

    def copy(self, new_symfile):
        res = FileSession(self.fd, new_symfile, self.mode)
        res.seek(self.seek_idx)
        return res


class OsFileHandler(Os):
    # os that handles files
    def __init__(self):
        self.next_descriptor = 0
        self.descriptors_map = {}  # descriptor to file session
        self.filesystem = {}       # filename to symfile object

    def open(self, filename, mode):
        if filename in self.filesystem:
            symfile = self.filesystem[filename]
        else:
            symfile = SymFile(filename)
            self.filesystem[filename] = symfile

        fd = self.next_descriptor
        file_session = FileSession(fd, symfile, mode)
        self.descriptors_map[fd] = file_session

        self.next_descriptor += 1
        return fd

    def is_open(self, fd):
        return fd in self.descriptors_map

    def seek(self, fd: int, idx: int):
        assert fd in self.descriptors_map

        session = self.descriptors_map[fd]
        session.seek(idx)

    def read(self, fd: int, size: int):
        assert fd in self.descriptors_map

        session = self.descriptors_map[fd]
        return session.read(size)

    def write(self, fd: int, data: list):
        assert fd in self.descriptors_map

        session = self.descriptors_map[fd]
        return session.write(data)

    def close(self, fd: int):
        assert fd in self.descriptors_map
        del self.descriptors_map[fd]

    def copy_to(self, other):
        for filename in self.filesystem:
            other.filesystem[filename] = self.filesystem[filename].copy()
        for fd in self.descriptors_map:
            other.descriptors_map[fd] = self.descriptors_map[fd].copy(
                other.filesystem[self.descriptors_map[fd].symfile.filename]
            )

```

`os_models/windows.py`:

```py
from copy import deepcopy
from ..expr import Bool
from .os_file import OsFileHandler


class Windows(OsFileHandler):
    def __init__(self):
        super().__init__()
        self.stdin_fd = self.open("__stdin", "r--")
        self.stdout_fd = self.open("__stdout", "-w-")

    def get_syscall_by_number(self, n):
        raise NotImplementedError

    def get_syscall_n_reg(self):
        raise NotImplementedError

    def get_syscall_parameter(self, k):
        raise NotImplementedError

    def get_out_syscall_reg(self):
        raise NotImplementedError

    def get_stdin_stream(self):
        session = self.descriptors_map[self.stdin_fd]
        session_idx = session.seek_idx
        session.seek(0)
        res = session.read(session.symfile.file_size)
        session.seek(session_idx)

        return res

    def get_stdout_stream(self):
        session = self.descriptors_map[self.stdout_fd]
        session_idx = session.seek_idx
        session.seek(0)
        res = session.read(session.symfile.file_size)
        session.seek(session_idx)

        return res

    def copy(self):
        res = Windows()
        super().copy_to(res)
        return res

    def merge(self, other, merge_condition: Bool):
        assert isinstance(other, Windows)
        pass  # TODO implement this

```

`plugin.json`:

```json
{
   "pluginmetadataversion": 2,
   "name": "SENinja",
   "author": "Luca Borzacchiello",
   "type": [
      "helper"
   ],
   "api": [
      "python3"
   ],
   "description": "Symbolic execution plugin for BinaryNinja",
   "longdescription": "# SENinja - Symbolic Execution Plugin for Binary Ninja\n![](https://github.com/borzacchiello/seninja/raw/master/pictures/screenshot.png)\nThis is a binary ninja plugin that implements a symbolic execution engine based only on z3, highly inspired by the _angr framework_ (https://angr.io/). \nThe plugin is implemented as an emulator of LLIL instructions that builds and manipulates z3 formulas. \n\nSENinja simulates a debugger: the execution is _path driven_, only one state is _active_ and executes instructions. The other states, generated at branches, are saved in a _deferred queue_. At any time, the active state can be changed with a deferred one.\n\n### Commands\nThe plugin adds the following commands:\n![](https://github.com/borzacchiello/seninja/raw/master/pictures/commands.png)\n\n---\n\nMore APIs can be executed through the python shell. For example, we can use the solver to _prove_ a condition for the current state:\n``` python\n>>> import borzacchiello_seninja as seninja\n>>> s = seninja.get_current_state()\n>>> s.solver.satisfiable(extra_constraints=[s.regs.eax == 3])\n```\nthe code will check the satisfiablity of `eax == 3` given the path constraint of the active state.\n\nConsult the [wiki](https://github.com/borzacchiello/seninja/wiki) to have more info about the commands.\n\n### Settings\n\nSENinja gives to the user the possibility to configure many parts of the symbolic engine (e.g. dimension of pages, symbolic memory access strategy, etc.). \nAll the available settings can be accessed and modified by clicking on `Edit/Preferences/Settings` and selecting `SENinja` in the left widget.\n\n### UI Widgets\n\nSENinja comes with two widgets that can be used to visualize the registers and a portion of memory of the active state. The widgets can be activated by clicking on `View/Show SENinja *`. \n\n#### Buffers View\n![](https://github.com/borzacchiello/seninja/raw/master/pictures/buffers_view.png)\nThis widget allows the creation of buffers containing symbolic data.\n\n#### Register View\n![](https://github.com/borzacchiello/seninja/raw/master/pictures/register_view.png)\n\nThe Register View can be used to visualize the value of the registers of the active state. The value of a register can be modifyied by double-clicking on it. The right-click menu allows to:\n- Copy the content of the register\n- Concretize the value of the register\n- Evaluate the value of the register using the solver\n- Inject symbols\n- Show the register expression\n- Set the register to the address of a buffer created with the buffer view\n\n#### Memory View\n![](https://github.com/borzacchiello/seninja/raw/master/pictures/memory_view.png)\n\nThe Memory View can be used to visualize the value of a portion of memory of the active state. By clicking on \"monitor memory\", the user can specify a memory address to monitor. The widget will show 512 bytes starting from that address. \nThe memory view is splitted in two sections: an hexview and an ascii view. The hexview shows the hex value of each byte only if the byte is mapped and concrete. If the byte is unmapped, the characted `_` is shown; if the byte is symbolic, the widget shows the character `.`. \n\nDouble-clicking on a byte allows the user to modify its value in the active state.\nThe right-click menu allows to:\n- Copy the selection (in various format, e.g. little-endian, binary, etc.)\n- Concretize the value of the selection\n- Evaluate the value of the selection using the solver\n- Inject symbols\n\n#### Version and Dependencies\nTested with \n- binary ninja `3.0` with personal license\n- python `3.9.7` \n- z3 `4.8.14`\n\nTo make it work, you need to install z3 with pip:\n`$ pip3 install z3-solver`\n",
   "license": {
      "name": "2-Clause BSD",
      "text": "Copyright 2019-2022 Luca Borzacchiello\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
   },
   "platforms": [
      "Darwin",
      "Windows",
      "Linux"
   ],
   "installinstructions": {
      "Darwin": "Install `z3-solver` using pip: `pip install z3-solver`",
      "Windows": "Install `z3-solver` using pip: `pip install z3-solver`",
      "Linux": "Install `z3-solver` using pip: `pip install z3-solver`"
   },
   "dependencies": {
		"apt": [],
		"installers": [],
		"other": []
	},
   "version": "0.3.0",
   "minimumbinaryninjaversion": 3000
}

```

`requirements.txt`:

```txt
z3-solver

```

`seninja_globals.py`:

```py
class globs(object):
    executor = None
    dfs_searcher = None
    bfs_searcher = None
    searcher_tags = {}
    _stop = False
    _running = False
    TARGET_TAG_TYPE = None
    AVOID_TAG_TYPE = None

    highlighted_state_history = list()

```

`settings.py`:

```py
from binaryninja import Settings

Settings().register_group("seninja", "SENinja")
Settings().register_setting("seninja.memory.symb_address_mode", """
    {
        "title" : "Symbolic access mode",
        "type" : "string",
        "default" : "limit_pages",
        "description" : "Select the policy to use when a memory access from symbolic address occurs.",
        "enum": ["concretization", "limit_pages", "fully_symbolic"]
    }
    """)
Settings().register_setting("seninja.memory.limit_pages_limit", """
    {
        "title" : "Limit pages, page limit",
        "type" : "number",
        "default" : 3,
        "description" : "If the symbolic access policy is set to 'limit_pages', the maximum width of a symbolic access (in pages)."
    }
    """)
Settings().register_setting("seninja.memory.concretize_unconstrained", """
    {
        "title" : "Concretize unconstrained memory accesses",
        "type" : "boolean",
        "default" : true,
        "description" : "When a memory access on a unconstrained symbolic address occurs, allocate a new page and concretize the address to it."
    }
    """)
Settings().register_setting("seninja.memory.use_heuristic_find_base", """
    {
        "title" : "Use find-base heuristic on symbolic memory accesses",
        "type" : "boolean",
        "default" : true,
        "description" : "When a memory access on a symbolic address occurs, if the current policy impose concretization, use find-base heuristic to drive the concretization."
    }
    """)
Settings().register_setting("seninja.memory.check_unmapped", """
    {
        "title" : "Check unmapped symbolic memory accesses",
        "type" : "boolean",
        "default" : false,
        "description" : "Check if symbolic memory accesses can access unmapped memory pages. Performance may decrease."
    }
    """)
Settings().register_setting("seninja.memory.page_size", """
    {
        "title" : "Size of a memory page",
        "type" : "string",
        "default" : "2048",
        "description" : "Size (in bytes) of a memory page. It must be a power of 2."
    }
    """)

Settings().register_setting("seninja.stack_size", """
    {
        "title" : "Stack size (in pages)",
        "type" : "number",
        "default" : 4,
        "description" : "Number of pages allocated for the stack."
    }
    """)
Settings().register_setting("seninja.use_bn_jumptable_targets", """
    {
        "title" : "Use jump table targets computed by Binary Ninja",
        "type" : "boolean",
        "default" : true,
        "description" : "If true, the symbolic executor will use targets of jump tables computed by Binary Ninja."
    }
    """)
Settings().register_setting("seninja.save_unsat", """
    {
        "title" : "Save unsat states",
        "type" : "boolean",
        "default" : false,
        "description" : "Save unsatisfiable states. If True, performance will decrease drastically."
    }
    """)
Settings().register_setting("seninja.single_llil_step", """
    {
        "title" : "Single LLIL step",
        "type" : "boolean",
        "default" : false,
        "description" : "If true, a single step executes only one LLIL instruction, instead of an assembly instruction."
    }
    """)
Settings().register_setting("seninja.check_division_by_zero", """
    {
        "title" : "Check division by zero",
        "type" : "boolean",
        "default" : false,
        "description" : "If true, division by zero are checked. Performance may decrease."
    }
    """)
Settings().register_setting("seninja.dont_use_special_handlers", """
    {
        "title" : "Do not use special handlers",
        "type" : "boolean",
        "default" : false,
        "description" : "If true, architecture-specific handlers will not be used."
    }
    """)
Settings().register_setting("seninja.save_state_history", """
    {
        "title" : "Save instructions executed by the state",
        "type" : "boolean",
        "default" : false,
        "description" : "If true, each state will save the instruction that it executed."
    }
    """)
Settings().register_setting("seninja.exploration_timeout", """
    {
        "title" : "Timeout (seconds) during automatic exploration (0 for no timeout)",
        "type" : "number",
        "default" : 0,
        "description" : "If greater than 0, automatic explorations will terminate after X seconds"
    }
    """)

Settings().register_setting("seninja.models.use_atox_slow_model", """
    {
        "title" : "Use atoX slow model",
        "type" : "boolean",
        "default" : true,
        "description" : "If true, atoX functions are modelled in a sound and complete (but slow) way."
    }
    """)
Settings().register_setting("seninja.models.max_malloc_size", """
    {
        "title" : "Maximum malloc size when concretized",
        "type" : "string",
        "default" : "4096",
        "description" : "Maximum value to which a symbolic malloc size can be concretized."
    }
    """)
Settings().register_setting("seninja.models.max_memcmp_size", """
    {
        "title" : "Maximum memcmp size when concretized",
        "type" : "string",
        "default" : "4096",
        "description" : "Maximum value to which a symbolic memcmp size can be concretized."
    }
    """)
Settings().register_setting("seninja.models.max_memcpy_size", """
    {
        "title" : "Maximum memcpy size when concretized",
        "type" : "string",
        "default" : "4096",
        "description" : "Maximum value to which a symbolic memcpy size can be concretized."
    }
    """)
Settings().register_setting("seninja.models.max_size_symb_string", """
    {
        "title" : "Maximum length of symbolic string",
        "type" : "number",
        "default" : 30,
        "description" : "Maximum length of a string with symbolic characters."
    }
    """)

Settings().register_setting("seninja.init_reg_mem_with_zero", """
    {
        "title" : "Set uninitialized registers and memory to zero",
        "type" : "boolean",
        "default" : false,
        "description" : "If true, memory and registers are inizialized with zero. Otherwise, with symbols."
    }
""")

```

`sym_executor.py`:

```py
import sys

from binaryninja import (
    BinaryReader, BinaryWriter,
    RegisterValueType, enums
)
from .sym_visitor import SymbolicVisitor
from .sym_state import State
from .utility.bninja_util import (
    get_imported_functions_and_addresses,
    find_os
)
from .utility.expr_wrap_util import symbolic
from .arch.arch_x86 import x86Arch
from .arch.arch_x86_64 import x8664Arch
from .arch.arch_armv7 import ArmV7Arch
from .utility import exceptions
from .expr import BVV, BVS
from .utility.binary_ninja_cache import BNCache
from .memory.sym_memory import InitData
from .multipath.fringe import Fringe

NO_COLOR = enums.HighlightStandardColor(0)
CURR_STATE_COLOR = enums.HighlightStandardColor.GreenHighlightColor
DEFERRED_STATE_COLOR = enums.HighlightStandardColor.RedHighlightColor
ERRORED_STATE_COLOR = enums.HighlightStandardColor.BlackHighlightColor


def find_arch(view):
    if view.arch.name == "x86":
        return x86Arch()
    elif view.arch.name == "x86_64":
        return x8664Arch()
    elif view.arch.name == "armv7":
        return ArmV7Arch()

    raise exceptions.UnsupportedArch(view.arch.name)


class SymbolicExecutor(object):
    def __init__(self, view, addr):

        self.view = view
        self.bw = BinaryWriter(view)
        self.br = BinaryReader(view)
        self.visitor = SymbolicVisitor(self)
        self.bncache = BNCache(view)
        self.vars = set()
        self.fringe = Fringe()
        self.ip = addr
        self.llil_ip = None
        self.arch = None
        self.user_hooks = dict()
        self.user_loggers = dict()
        self.imported_functions, self.imported_addresses = \
            get_imported_functions_and_addresses(view)
        self._last_colored_ip = None
        self._last_error = None
        self.init_with_zero = self.bncache.get_setting(
            "init_reg_mem_with_zero") == "true"

        self._wasjmp = False

        self.arch = find_arch(self.view)
        page_size = int(self.bncache.get_setting("memory.page_size"))
        self.state = State(self, arch=self.arch,
                           os=find_os(view), page_size=page_size)

        # load memory
        print("loading segments...")
        for segment in self.view.segments:
            start = segment.start
            end = segment.end
            size = segment.data_length
            print(segment, hex(start), "->", hex(size))

            if size == 0 and end - start != 0:
                size = end - start
                data = b"\x00" * size
            elif size == 0:
                continue
            else:
                self.br.seek(start)
                data = self.br.read(end-start)

            self.state.mem.mmap(
                self.state.address_page_aligned(start),
                self.state.address_page_aligned(end + self.state.mem.page_size - 1) -
                self.state.address_page_aligned(start),
                InitData(data, start - self.state.address_page_aligned(start))
            )
        print("loading finished!")

        current_function = self.bncache.get_function(addr)

        # initialize stack

        stack_page_size = int(self.bncache.get_setting("stack_size"))

        unmapped_page_init = self.state.mem.get_unmapped(
            stack_page_size,
            start_from=(0x80 << (self.arch.bits() - 8)))
        self.state.mem.mmap(
            unmapped_page_init*self.state.page_size,
            self.state.page_size * stack_page_size)
        # leave one page for upper stack portion
        p = unmapped_page_init + stack_page_size - 1
        stack_base = p * self.state.page_size - self.arch.bits() // 8

        self.state.initialize_stack(stack_base)

        # initialize registers
        for reg in self.arch.regs_data():
            reg_dict = self.arch.regs_data()[reg]
            val = current_function.get_reg_value_after(addr, reg)

            if val.type.value == RegisterValueType.StackFrameOffset:
                setattr(self.state.regs, reg, BVV(
                    stack_base + val.offset, reg_dict['size'] * 8))
            elif (
                val.type.value == RegisterValueType.ConstantPointerValue or
                val.type.value == RegisterValueType.ConstantValue
            ):
                setattr(self.state.regs, reg, BVV(
                    val.value, reg_dict['size'] * 8))
            else:
                if not self.init_with_zero:
                    symb = BVS(reg + "_init", reg_dict['size'] * 8)
                    self.vars.add(symb)
                    setattr(self.state.regs, reg, symb)
                else:
                    setattr(self.state.regs, reg, BVV(0, reg_dict['size'] * 8))

        # initialize known local variables
        stack_vars = current_function.stack_layout
        for var in stack_vars:
            offset = var.storage
            s_type = var.type

            if abs(offset) > self.state.page_size * (stack_page_size - 1):
                print("ERROR: not enough space in stack. Increase stack size")
                raise Exception(
                    "Not enough space in stack. Increase stack size")

            if s_type.confidence != 255:
                continue

            width = s_type.width
            name = var.name
            val = current_function.get_stack_contents_at(addr, offset, width)
            if val.type.value == RegisterValueType.StackFrameOffset:
                assert width*8 == self.arch.bits()  # has to happen... right?
                self.state.mem.store(
                    BVV(stack_base + offset, self.arch.bits()),
                    BVV(stack_base + val.offset, width*8),
                    endness=self.arch.endness())
            elif (
                val.type.value == RegisterValueType.ConstantPointerValue or
                val.type.value == RegisterValueType.ConstantValue
            ):
                self.state.mem.store(
                    BVV(stack_base + offset, self.arch.bits()),
                    BVV(val.value, width*8),
                    endness=self.arch.endness())
            elif not self.init_with_zero:
                symb = BVS(name + "_init", self.arch.bits())
                self.vars.add(symb)
                self.state.mem.store(
                    BVV(stack_base + offset, self.arch.bits()),
                    symb,
                    endness=self.arch.endness())

        # set eip
        self.state.set_ip(addr)
        self.llil_ip = current_function.llil.get_instruction_start(addr)

    def __str__(self):
        return "<SymExecutor id: 0x%x, %d states>" % \
            (id(self), self.fringe.num_states + 1 if self.state is not None else 0)

    def __repr__(self):
        return self.__str__()

    def put_in_deferred(self, state):
        self.fringe.add_deferred(state)

    def put_in_exited(self, state):
        self.fringe.add_exited(state)

    def put_in_unsat(self, state):
        save_unsat = self.bncache.get_setting("save_unsat") == 'true'
        if save_unsat:
            self.fringe.add_unsat(state)

    def put_in_errored(self, state, msg: str):
        self.fringe.add_errored(
            (msg, state)
        )

    def delete_comment_for_address(self, address):
        # TODO write an UI manager, this does not belong to the executor
        func = self.bncache.get_function(address)
        func.set_comment_at(address, None)

    def set_colors(self, reset=False):
        # TODO write an UI manager, this does not belong to the executor
        old_ip = self._last_colored_ip
        if old_ip is not None:
            old_func = self.bncache.get_function(old_ip)
            old_func.set_auto_instr_highlight(old_ip, NO_COLOR)

        for ip in self.fringe._deferred:
            func = self.bncache.get_function(ip)
            func.set_auto_instr_highlight(
                ip, DEFERRED_STATE_COLOR if not reset else NO_COLOR)
            if reset:
                func.set_comment_at(ip, None)
            elif len(self.fringe._deferred[ip]) > 1 or (len(self.fringe._deferred[ip]) == 1 and self.ip == ip):
                func.set_comment_at(ip, "n deferred: %d" %
                                    len(self.fringe._deferred[ip]))

        for _, state in self.fringe.errored:
            func = self.bncache.get_function(state.get_ip())
            func.set_auto_instr_highlight(
                state.get_ip(), ERRORED_STATE_COLOR if not reset else NO_COLOR)

        if self.state:
            func = self.bncache.get_function(self.ip)
            func.set_auto_instr_highlight(
                self.ip, CURR_STATE_COLOR if not reset else NO_COLOR)
        if not reset:
            self._last_colored_ip = self.ip

    def reset(self):
        self.set_colors(reset=True)

    def extract_mergeable_with_current_state(self, to_merge):
        # returns the set of states that do not deviate from
        # the current state after executing the current instruction

        func_name = self.bncache.get_function_name(self.ip)
        expr = self.bncache.get_llil(func_name, self.llil_ip)

        if expr.operation.name in {"LLIL_JUMP", "LLIL_JUMP_TO", "LLIL_CALL", "LLIL_TAILCALL"}:
            curr_state_dst = self.visitor.visit(expr.dest)
            if symbolic(curr_state_dst):
                # I do not want to call the solver... Just return them all
                return to_merge, list()

            curr_state = self.state

            mergeable = list()
            not_mergeable = list()
            for s in to_merge:
                self.state = s
                s_dst = self.visitor.visit(expr.dest)
                if symbolic(s_dst) or s_dst.value == curr_state_dst.value:
                    mergeable.append(s)
                else:
                    not_mergeable.append(s)

            self.state = curr_state
            return mergeable, not_mergeable

        return to_merge, list()

    def set_current_state(self, state):
        if self.state is not None:
            self.state.llil_ip = self.llil_ip
            self.put_in_deferred(self.state)
            self.state = None

        ip = state.get_ip()
        llil_ip = state.llil_ip

        self.state = state
        new_func = self.bncache.get_function(ip)
        self.ip = ip
        self.llil_ip = new_func.llil.get_instruction_start(
            ip) if llil_ip is None else llil_ip

    def select_from_deferred(self):
        if self.fringe.is_empty():
            return False

        state = self.fringe.get_one_deferred()
        self.set_current_state(state)
        return True

    def update_ip(self, funcion_name, new_llil_ip):
        self.llil_ip = new_llil_ip
        self.ip = self.bncache.get_address(funcion_name, new_llil_ip)
        self.state.set_ip(self.ip)
        self.state.llil_ip = new_llil_ip

    def _update_state_history(self, state, addr):
        if self.bncache.get_setting("save_state_history") == 'true':
            state.insn_history.add(addr)

    def _execute_one(self):
        self._last_error = None
        func_name = self.bncache.get_function_name(self.ip)

        # handle user hooks and loggers
        if self.ip in self.user_loggers:
            self.user_loggers[self.ip](self.state)
        if self.ip in self.user_hooks:
            old_ip = self.ip
            new_state, new_deferred, new_errored = self.user_hooks[self.ip](
                self.state)

            for s in new_deferred:
                self._update_state_history(s, old_ip)
                self.put_in_deferred(s)
            for s, msg in new_errored:
                self._update_state_history(s, old_ip)
                self.put_in_errored(s, msg)

            if new_state is not None:
                self.state = new_state

                if old_ip == self.state.get_ip():
                    new_ip = self.ip + \
                        self.bncache.get_instruction_len(self.ip)
                else:
                    new_ip = self.state.get_ip()

                dest_func_name = self.bncache.get_function_name(
                    new_ip
                )
                self.update_ip(
                    dest_func_name,
                    self.bncache.get_llil_address(dest_func_name, new_ip)
                )
                self._update_state_history(new_state, old_ip)
                return self.ip

        else:
            # check if a special handler is defined

            dont_use_special_handlers = \
                self.bncache.get_setting("dont_use_special_handlers") == 'true'
            disasm_str = self.bncache.get_disasm(self.ip)
            old_ip = self.ip

            try:
                if (
                    dont_use_special_handlers or
                    not self.arch.execute_special_handler(disasm_str, self)
                ):
                    expr = self.bncache.get_llil(func_name, self.llil_ip)
                    self.visitor.visit(expr)
                else:
                    self._wasjmp = True
                    self.ip = self.ip + \
                        self.view.get_instruction_length(self.ip)
                    self.state.set_ip(self.ip)
                    self.llil_ip = self.bncache.get_function(
                        self.ip).llil.get_instruction_start(self.ip)
            except exceptions.ExitException:
                self._update_state_history(self.state, old_ip)
                self.put_in_exited(self.state)
                self.state = None
            except exceptions.SENinjaError as err:
                sys.stderr.write("An error occurred: %s\n" % err.message)
                self.put_in_errored(self.state, str(err))
                self.state = None
                self._last_error = err
                if err.is_fatal():
                    raise err

            if self.state is not None:
                self._update_state_history(self.state, old_ip)

        if self.state is None:
            if self.fringe.is_empty():
                print("WARNING: no more states")
                return -1
            else:
                self.select_from_deferred()
                self._wasjmp = True

        if not self._wasjmp:
            # go on by 1 instruction
            self.update_ip(func_name, self.llil_ip + 1)
        else:
            self._wasjmp = False

        return self.ip

    def execute_one(self):
        if not self.state:
            return

        res = None
        try:
            single_llil_step = self.bncache.get_setting(
                "single_llil_step") == 'true'
            if single_llil_step:
                res = self._execute_one()
            else:
                old_ip = self.ip
                res = old_ip
                while res == old_ip:
                    res = self._execute_one()
        except exceptions.SENinjaError:
            res = None
        except Exception as e:
            import os
            _, _, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            sys.stderr.write("Unknown exception in SymbolicExecutor.execute_one():\n")
            sys.stderr.write(" ".join(map(str, ["\t", repr(e), fname, exc_tb.tb_lineno, "\n"])))
            self.put_in_errored(self.state, "Unknown error")
            self.state = None

            res = None

        if res is None:
            if not self.fringe.is_empty():
                self.select_from_deferred()

        return res

```

`sym_solver.py`:

```py
import z3

from copy import deepcopy
from collections import OrderedDict
from .utility.expr_wrap_util import symbolic
from .expr import BV, BVV, Bool, And, Or, BoolExpr

USE_OPT_SOLVER = False
DBG            = False

class Solver(object):
    def __init__(self, state):
        self.state = state
        self.assertions = []
        self._added_mem_constraints = set()
        self._solver = z3.Optimize() if USE_OPT_SOLVER else z3.Solver()
        self._min_cache = OrderedDict()
        self._max_cache = OrderedDict()
        self._eval_cache = OrderedDict()
        self._symb_check_cache = OrderedDict()

        if DBG:
            self.dbg_idx = 0

    def __str__(self):
        return "<SymSolver id: 0x%x, %d assertions>" % \
            (id(self), len(self.assertions))

    def __repr__(self):
        return self.__str__()

    def _invalidate_cache(self):
        self._min_cache = OrderedDict()
        self._max_cache = OrderedDict()
        self._eval_cache = OrderedDict()
        self._symb_check_cache = OrderedDict()

    def _rejuvenate(self):
        self._solver = z3.Optimize() if USE_OPT_SOLVER else z3.Solver()
        for a in self.assertions:
            self._solver.add(a.z3obj)

    @staticmethod
    def _get_all_symbols_from_z3_formula(formula):
        processed_formulas = set()
        res = set()

        queue = [formula]
        while queue:
            formula = queue.pop()
            if formula in processed_formulas:
                continue
            processed_formulas.add(formula)

            decl = formula.decl()
            if decl.kind() == z3.Z3_OP_UNINTERPRETED:
                res.add(decl.name())

            for c in formula.children():
                queue.append(c)

        return res

    def _add_memory_constraints(self, *constraints):
        # If we find a page symbol, then we will add the
        # eventual concrete values as assertion to the solver
        for formula in constraints:
            for s in Solver._get_all_symbols_from_z3_formula(formula.z3obj):
                if s.startswith("MEMOBJ_") and s.endswith("h"):
                    page_addr = s.split("_")[1][:-1]
                    page_addr = int(page_addr, 16)

                    if page_addr in self._added_mem_constraints:
                        continue
                    self._added_mem_constraints.add(page_addr)
                    assertions = self.state.mem.get_assertions_for_page(page_addr)
                    for a in assertions:
                        self.add_constraints(a, simplify_constraint=False, check_mem=False)

    def get_path_constraint(self):
        return self.assertions

    def add_constraints(self, *constraints, simplify_constraint=True, check_mem=True):
        if len(constraints) == 0:
            return

        self._invalidate_cache()
        for c in constraints:
            assert isinstance(c, Bool)
            if simplify_constraint:
                c = c.simplify()
            cz3 = c.z3obj
            if not z3.BoolVal(True).eq(cz3):
                if check_mem:
                    self._add_memory_constraints(c)
                self._solver.add(cz3)
                self.assertions.append(c)

    def _add_tmp_constraints(self, *constraints):
        for c in constraints:
            assert isinstance(c, Bool)
            c = c.simplify()
            cz3 = c.z3obj
            if not z3.BoolVal(True).eq(cz3):
                self._solver.add(cz3)

    def satisfiable(self, extra_constraints: list = None):
        if extra_constraints:
            self._add_memory_constraints(*extra_constraints)
            self._solver.push()
            self._add_tmp_constraints(*extra_constraints)

        if DBG:
            fout = open("/dev/shm/seninja_q_%d" % self.dbg_idx, "w")
            self.dbg_idx += 1
            fout.write(self._solver.sexpr())
            fout.close()

        res = self._solver.check().r == 1

        if extra_constraints:
            self._solver.pop()
        return res

    def evaluate(self, var, extra_constraints: list = None) -> int:
        if extra_constraints:
            self._add_memory_constraints(*extra_constraints)
            self._solver.push()
            self._add_tmp_constraints(*extra_constraints)
        elif var in self._eval_cache:
            return self._eval_cache[var]

        self._add_memory_constraints(var)
        if not self.satisfiable():
            if extra_constraints:
                self._solver.pop()
            assert False  # not satisfiable!
        model = self._solver.model()
        res = model.evaluate(var.z3obj, model_completion=True)
        res = BVV(res.as_long(), var.size)

        if extra_constraints:
            self._solver.pop()
        else:
            self._eval_cache[var] = res
        return res

    def evaluate_upto(self, var, n, extra_constraints: list = None) -> list:
        self._solver.push()
        if extra_constraints:
            self._add_memory_constraints(*extra_constraints)
            self._add_tmp_constraints(*extra_constraints)

        self._add_memory_constraints(var)
        if not self.satisfiable():
            if extra_constraints:
                self._solver.pop()
            assert False  # not satisfiable!

        res = list()
        while n > 0 and self.satisfiable():
            model = self._solver.model()
            r = model.evaluate(var.z3obj, model_completion=True)
            r = BVV(r.as_long(), var.size)
            res.append(r)
            self._add_tmp_constraints(var != r)
            n -= 1

        self._solver.pop()
        return res

    def symbolic(self, val: BV):
        if val in self._symb_check_cache:
            return self._symb_check_cache[val]

        res = len(self.evaluate_upto(val, 2)) != 1
        self._symb_check_cache[val] = res
        return res

    def _max_binary_search(self, val: BV):
        lb = 0
        ub = 2 ** val.size - 1
        while lb <= ub:
            m = (lb + ub) // 2
            if not self.satisfiable(extra_constraints=[val.UGE(m)]):
                ub = m - 1
            else:
                lb = m + 1
        self._max_cache[val] = ub
        return ub

    def _max_z3_optimize(self, val: BV):
        if USE_OPT_SOLVER:
            self._solver.push()
            h = self._solver.maximize(val.z3obj)
            assert self._solver.check().r == 1
            res = self._solver.upper(h).as_long()
            self._solver.pop()
        else:
            opt = z3.Optimize()
            for c in self.assertions:
                opt.add(c.z3obj)
            h = opt.maximize(val.z3obj)
            assert opt.check().r == 1
            res = opt.upper(h).as_long()
        return res

    def max(self, val: BV):
        if not symbolic(val):
            return val.value
        if val in self._max_cache:
            return self._max_cache[val]

        self._add_memory_constraints(val)
        # res = self._max_binary_search(val)
        res = self._max_z3_optimize(val)
        val.interval.high = res

        self._max_cache[val] = res
        return res

    def _min_binary_search(self, val: BV):
        lb = 0
        ub = 2 ** val.size - 1
        while lb <= ub:
            m = (lb + ub) // 2
            if not self.satisfiable(extra_constraints=[val.ULE(m)]):
                lb = m + 1
            else:
                ub = m - 1
        return lb

    def _min_z3_optimize(self, val: BV):
        if USE_OPT_SOLVER:
            self._solver.push()
            h = self._solver.minimize(val.z3obj)
            assert self._solver.check().r == 1
            res = self._solver.lower(h).as_long()
            self._solver.pop()
        else:
            opt = z3.Optimize()
            for c in self.assertions:
                opt.add(c.z3obj)
            h = opt.minimize(val.z3obj)
            assert opt.check().r == 1
            res = opt.lower(h).as_long()
        return res

    def min(self, val: BV):
        if not symbolic(val):
            return val.value
        if val in self._min_cache:
            return self._min_cache[val]

        self._add_memory_constraints(val)
        # res = self._min_binary_search(val)
        res = self._min_z3_optimize(val)
        val.interval.low = res

        self._min_cache[val] = res
        return res

    def model(self, extra_constraints: list = None):
        if extra_constraints:
            self._add_memory_constraints(*extra_constraints)
            self._solver.push()
            self._add_tmp_constraints(*extra_constraints)

        assert self.satisfiable()
        res = self._solver.model()
        if extra_constraints:
            self._solver.pop()
        return res

    def _copy_cache(self, new, max_num_elem=3):
        i = 0
        for key in reversed(self._min_cache.keys()):
            if i > max_num_elem:
                break
            new._min_cache[key] = self._min_cache[key]
            i += 1
        i = 0
        for key in reversed(self._max_cache.keys()):
            if i > max_num_elem:
                break
            new._max_cache[key] = self._max_cache[key]
            i += 1
        i = 0
        for key in reversed(self._eval_cache.keys()):
            if i > max_num_elem:
                break
            new._eval_cache[key] = self._eval_cache[key]
            i += 1
        i = 0
        for key in reversed(self._symb_check_cache.keys()):
            if i > max_num_elem:
                break
            new._symb_check_cache[key] = self._symb_check_cache[key]
            i += 1

    def copy(self, state, fast_copy=False):
        fast_copy = True  # deepcopy seems broken

        res = Solver(state)
        if not fast_copy:
            # print("copying the solver slow")
            res._solver = self._solver.__deepcopy__()
            # print("copying done")
        else:
            for a in self._solver.assertions():
                res._solver.add(a)

        res.assertions = self.assertions[:]
        self._copy_cache(res, 3)
        return res

    def compute_solvers_difference(self, other):  # can be quite slow
        assert isinstance(other, Solver)

        i = 0
        for c1, c2 in zip(self.assertions, other.assertions):
            if not c1.eq(c2):
                break
            i += 1

        const1 = None
        for c in self.assertions[i:]:  # additional constraints self
            const1 = c if const1 is None else And(const1, c)

        const2 = None
        for c in other.assertions[i:]:  # additional constraints other
            const2 = c if const2 is None else And(const2, c)

        # common, consts only self, consts only other
        return self.assertions[:i], const1, const2

    def merge(self, other):
        assert isinstance(other, Solver)
        common, only_self, only_other = self.compute_solvers_difference(other)

        self._invalidate_cache()

        new_z3_solver = z3.Solver()
        self.assertions = []
        for const in common:
            new_z3_solver.add(const.z3obj)  # common constraints
            self.assertions.append(const)

        if only_self is not None and only_other is not None:
            cond = Or(only_self, only_other)
            cond = cond.simplify()
            if not cond.z3obj.eq(z3.BoolVal(True)):
                new_z3_solver.add(cond.z3obj)
                self.assertions.append(cond)
        else:
            raise Exception("Can this happen?")

        self._solver = new_z3_solver

```

`sym_state.py`:

```py
from .arch.arch_abstract import Arch
from .arch.arch_x86_64 import x8664Arch
from .os_models.os_abstract import Os
from .memory.registers import Regs
from .memory.sym_memory import Memory
from .sym_solver import Solver
from .utility.expr_wrap_util import symbolic
from .expr import BV, BVV


class State(object):
    def __init__(self, executor, os: Os, arch: Arch = x8664Arch(), page_size: int = 0x1000):
        self.page_size = page_size
        self.arch = arch
        self.mem = Memory(self, page_size, arch.bits(),
                          not executor.init_with_zero)
        self.regs = Regs(self)
        self.solver = Solver(self)
        self.os = os
        self.events = list()
        self.insn_history = set()
        self.llil_ip = None
        self.executor = executor
        self.symbolic_buffers = list()
        self._ipreg = self.arch.getip_reg()
        self._bits = self.arch.bits()

    def __str__(self):
        return "<SymState 0x{id:x} @ 0x{addr:0{width}X}>".format(
            id=id(self),
            addr=self.get_ip(),
            width=(self._bits+3) // 4
        )

    def __repr__(self):
        return self.__str__()

    def get_ip(self):
        ip = getattr(self.regs, self._ipreg)
        assert not symbolic(ip)
        return ip.value

    def address_page_aligned(self, addr):
        return addr >> self.mem.index_bits << self.mem.index_bits

    def initialize_stack(self, stack_base):
        setattr(self.regs, self.arch.get_stack_pointer_reg(),
                BVV(stack_base, self._bits))
        setattr(self.regs, self.arch.get_base_pointer_reg(),
                BVV(stack_base, self._bits))

    def stack_push(self, val: BV):
        stack_pointer = getattr(self.regs, self.arch.get_stack_pointer_reg())
        new_stack_pointer = stack_pointer - self._bits // 8
        self.mem.store(new_stack_pointer, val, endness=self.arch.endness())
        setattr(self.regs, self.arch.get_stack_pointer_reg(), new_stack_pointer)

    def stack_pop(self):
        stack_pointer = getattr(self.regs, self.arch.get_stack_pointer_reg())
        res = self.mem.load(stack_pointer, self._bits //
                            8, endness=self.arch.endness())
        new_stack_pointer = stack_pointer + self._bits // 8
        setattr(self.regs, self.arch.get_stack_pointer_reg(), new_stack_pointer)
        return res

    def set_ip(self, new_ip):
        ip = getattr(self.regs, self._ipreg)
        if not symbolic(ip):
            self.executor._update_state_history(self, ip.value)
        setattr(self.regs, self._ipreg, BVV(new_ip, self._bits))

    def copy(self, solver_copy_fast=False):
        new_state = State(self.executor, self.os.copy(),
                          self.arch, self.page_size)
        new_state.mem = self.mem.copy(new_state)
        new_state.regs = self.regs.copy(new_state)
        new_state.solver = self.solver.copy(new_state, solver_copy_fast)
        new_state.events = list(self.events)
        new_state.insn_history = set(self.insn_history)
        new_state.symbolic_buffers = list(self.symbolic_buffers)
        new_state.llil_ip = self.llil_ip

        return new_state

    def merge_symb_buffers(self, other):
        self_buffers_name = [b[0].name for b in self.symbolic_buffers]
        for el in other.symbolic_buffers:
            buff = el[0]
            if buff.name not in self_buffers_name:
                self.symbolic_buffers.append(el)

    def merge(self, other):
        assert isinstance(other, State)
        assert self.arch.__class__ == other.arch.__class__
        assert self.os.__class__ == other.os.__class__
        assert self.get_ip() == other.get_ip()
        assert self.llil_ip == other.llil_ip

        _, _, merge_condition = self.solver.compute_solvers_difference(
            other.solver)
        self.solver.merge(other.solver)
        self.mem.merge(other.mem, merge_condition)
        self.regs.merge(other.regs, merge_condition)
        self.os.merge(other.os, merge_condition)
        self.events.append(
            (
                "merged with %s" % str(other),
                other.events[:]  # TODO delete common events
            )
        )
        self.insn_history |= other.insn_history

```

`sym_visitor.py`:

```py
from binaryninja import (
    BinaryReader, BinaryWriter,
    RegisterValueType, enums
)
from .sym_state import State
from .arch.arch_x86 import x86Arch
from .arch.arch_x86_64 import x8664Arch
from .arch.arch_armv7 import ArmV7Arch
from .models.function_models import library_functions
from .utility.expr_wrap_util import (
    bvv_from_bytes, symbolic
)
from .utility.exceptions import (
    UnimplementedInstruction, DivByZero, NoDestination,
    UnconstrainedIp, UnsatState, ExitException,
    UnimplementedModel, UnimplementedSyscall
)
from .expr import BV, BVV, BVS, Bool, BoolV, ITE
from .utility.bninja_util import (
    get_imported_functions_and_addresses,
    find_os,
    parse_disasm_str
)
from .utility.binary_ninja_cache import BNCache
from .memory.sym_memory import InitData
from .multipath.fringe import Fringe


class BNILVisitor(object):
    # thanks joshwatson
    # https://github.com/joshwatson/f-ing-around-with-binaryninja/blob/master/ep4-emulator/vm_visitor.py
    def __init__(self, **kw):
        super(BNILVisitor, self).__init__()

    def visit(self, expression):
        method_name = 'visit_{}'.format(expression.operation.name)
        if hasattr(self, method_name):
            value = getattr(self, method_name)(expression)
        else:
            raise UnimplementedInstruction(expression.operation.name, self.executor.state.get_ip())
        return value


class SymbolicVisitor(BNILVisitor):
    def __init__(self, executor):
        super(SymbolicVisitor, self).__init__()
        self.executor = executor

    def __str__(self):
        return "<SymVisitor @ SymExecutor 0x%x>" % \
            id(self.executor)

    def __repr__(self):
        return self.__str__()

    def _handle_symbolic_ip(self, expr, max_sol):
        state = self.executor.state
        sols = state.solver.evaluate_upto(expr, max_sol)
        return len(sols), sols

    # --- HANDLERS ---

    def visit_LLIL_CONST(self, expr):
        return BVV(expr.constant, max(expr.size, 1) * 8)

    def visit_LLIL_CONST_PTR(self, expr):
        return BVV(expr.constant, self.executor.arch.bits())

    def visit_LLIL_SET_REG(self, expr):
        dest = expr.dest.name
        src = self.visit(expr.src)

        # X86_64 fix
        if isinstance(self.executor.arch, x8664Arch):
            if dest in {
                'eax',  'ebx',  'ecx',  'edx',
                'edi',  'esi',  'esp',  'ebp',
                'r8d',  'r9d',  'r10d', 'r11d',
                'r12d', 'r13d', 'r14d', 'r15d'
            }:
                dest = ("r" + dest[1:]) if dest[0] == 'e' else dest[:-1]
                src = src.ZeroExt(32)

        if isinstance(src, Bool):
            src = ITE(
                src,
                BVV(1, 1).ZeroExt(expr.dest.info.size*8-1),
                BVV(0, 1).ZeroExt(expr.dest.info.size*8-1)
            )

        setattr(self.executor.state.regs, dest, src)
        return True

    def visit_LLIL_REG(self, expr):
        src = expr.src
        return getattr(self.executor.state.regs, src.name)

    def visit_LLIL_REG_SPLIT(self, expr):
        lo = getattr(self.executor.state.regs, expr.lo.name)
        hi = getattr(self.executor.state.regs, expr.hi.name)

        return hi.Concat(lo)

    def visit_LLIL_SET_REG_SPLIT(self, expr):
        src = self.visit(expr.src)
        lo = expr.lo.name
        hi = expr.hi.name

        lo_val = src.Extract(src.size // 2 - 1, 0)
        hi_val = src.Extract(src.size - 1, src.size // 2)

        setattr(self.executor.state.regs, lo, lo_val)
        setattr(self.executor.state.regs, hi, hi_val)
        return True

    def visit_LLIL_SET_FLAG(self, expr):
        dest = expr.dest.name
        src = self.visit(expr.src)

        if isinstance(src, Bool):
            res = ITE(src, BVV(1, 1), BVV(0, 1))
        else:
            res = ITE(src == 0, BVV(0, 1), BVV(1, 1))
        self.executor.state.regs.flags[dest] = res
        return True

    def visit_LLIL_FLAG(self, expr):
        src = expr.src.name
        return self.executor.state.regs.flags[src]

    def visit_LLIL_LOW_PART(self, expr):
        src = self.visit(expr.src)
        size = expr.size

        return src.Extract(size*8-1, 0)

    def visit_LLIL_ADD(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        if right.size > left.size:
            left = left.SignExt(right.size - left.size)
        if left.size > right.size:
            right = right.SignExt(left.size - right.size)

        return left + right

    def visit_LLIL_ADC(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)
        carry = self.visit(expr.carry)

        if right.size > left.size:
            left = left.SignExt(right.size - left.size)
        if left.size > right.size:
            right = right.SignExt(left.size - right.size)

        return left + right + carry.ZeroExt(left.size - 1)

    def visit_LLIL_ADD_OVERFLOW(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        # add with one more bit
        res = (BVV(0, 1).Concat(left) + BVV(0, 1).Concat(right))
        # check if overflow
        res = res.Extract(left.size, left.size)
        return res

    def visit_LLIL_SUB(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        if right.size > left.size:
            left = left.SignExt(right.size - left.size)
        if left.size > right.size:
            right = right.SignExt(left.size - right.size)

        return left - right

    def visit_LLIL_SBB(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)
        carry = self.visit(expr.carry)

        if right.size > left.size:
            left = left.SignExt(right.size - left.size)
        if left.size > right.size:
            right = right.SignExt(left.size - right.size)
        if carry.size < left.size:
            carry = carry.ZeroExt(left.size - carry.size)

        return left - (right + carry)

    def visit_LLIL_MUL(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        if right.size > left.size:
            left = left.SignExt(right.size - left.size)
        if left.size > right.size:
            right = right.SignExt(left.size - right.size)

        return left * right

    def visit_LLIL_MULS_DP(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert left.size == right.size
        left = left.SignExt(left.size)
        right = right.SignExt(right.size)
        return left * right

    def visit_LLIL_MULU_DP(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert left.size == right.size
        left = left.ZeroExt(left.size)
        right = right.ZeroExt(right.size)
        return left * right

    def visit_LLIL_DIVU_DP(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert left.size == 2*right.size

        check_division_by_zero = self.executor.bncache.get_setting(
            "check_division_by_zero") == 'true'

        right = right.ZeroExt(left.size - right.size)
        if check_division_by_zero and self.executor.state.solver.satisfiable(extra_constraints=[right == 0]):
            print("WARNING: division by zero detected")
            errored = self.executor.state.copy(solver_copy_fast=True)
            errored.solver.add_constraints(right == 0)
            self.executor.put_in_errored(
                errored,
                "DIVU_DP at %s (%d LLIL) division by zero" % (
                    hex(errored.get_ip()), self.executor.llil_ip)
            )

        self.executor.state.solver.add_constraints(right != 0)
        if not self.executor.state.solver.satisfiable():
            self.executor.put_in_errored(
                self.executor.state, "division by zero")
            raise DivByZero(self.executor.state.get_ip())

        div = left.UDiv(right)
        return div.Extract(expr.size * 8 - 1, 0)

    def visit_LLIL_DIVS_DP(self, expr):  # is it correct?
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert left.size == 2*right.size

        check_division_by_zero = self.executor.bncache.get_setting(
            "check_division_by_zero") == 'true'

        right = right.SignExt(left.size - right.size)
        if check_division_by_zero and self.executor.state.solver.satisfiable(extra_constraints=[right == 0]):
            print("WARNING: division by zero detected")
            errored = self.executor.state.copy(solver_copy_fast=True)
            errored.solver.add_constraints(right == 0)
            self.executor.put_in_errored(
                errored,
                "DIVS_DP at %s (%d LLIL) division by zero" % (
                    hex(errored.get_ip()), self.executor.llil_ip)
            )

        self.executor.state.solver.add_constraints(right != 0)
        if not self.executor.state.solver.satisfiable():
            self.executor.put_in_errored(
                self.executor.state, "division by zero")
            raise DivByZero(self.executor.state.get_ip())

        div = left / right
        return div.Extract(expr.size * 8 - 1, 0)

    def visit_LLIL_MODU_DP(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert left.size == 2*right.size

        check_division_by_zero = self.executor.bncache.get_setting(
            "check_division_by_zero") == 'true'

        right = right.ZeroExt(left.size - right.size)
        if check_division_by_zero and self.executor.state.solver.satisfiable(extra_constraints=[right == 0]):
            print("WARNING: division by zero detected")
            errored = self.executor.state.copy(solver_copy_fast=True)
            errored.solver.add_constraints(right == 0)
            self.executor.put_in_errored(
                errored,
                "MODU_DP at %s (%d LLIL) division by zero" % (
                    hex(errored.get_ip()), self.executor.llil_ip)
            )

        self.executor.state.solver.add_constraints(right != 0)
        if not self.executor.state.solver.satisfiable():
            self.executor.put_in_errored(
                self.executor.state, "division by zero")
            raise DivByZero(self.executor.state.get_ip())

        mod = left.URem(right)
        return mod.Extract(expr.size * 8 - 1, 0)

    def visit_LLIL_MODS_DP(self, expr):  # is it correct?
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert left.size == 2*right.size

        check_division_by_zero = self.executor.bncache.get_setting(
            "check_division_by_zero") == 'true'

        right = right.SignExt(left.size - right.size)
        if check_division_by_zero and self.executor.state.solver.satisfiable(extra_constraints=[right == 0]):
            print("WARNING: division by zero detected")
            errored = self.executor.state.copy(solver_copy_fast=True)
            errored.solver.add_constraints(right == 0)
            self.executor.put_in_errored(
                errored,
                "MODS_DP at %s (%d LLIL) division by zero" % (
                    hex(errored.get_ip()), self.executor.llil_ip)
            )

        self.executor.state.solver.add_constraints(right != 0)
        if not self.executor.state.solver.satisfiable():
            self.executor.put_in_errored(
                self.executor.state, "division by zero")
            raise DivByZero(self.executor.state.get_ip())

        mod = left.SRem(right)
        return mod.Extract(expr.size * 8 - 1, 0)

    def visit_LLIL_AND(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        if right.size > left.size:
            left = left.ZeroExt(right.size - left.size)
        if left.size > right.size:
            right = right.ZeroExt(left.size - right.size)

        return left & right

    def visit_LLIL_OR(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        if right.size > left.size:
            left = left.ZeroExt(right.size - left.size)
        if left.size > right.size:
            right = right.ZeroExt(left.size - right.size)

        return left | right

    def visit_LLIL_XOR(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        if right.size > left.size:
            left = left.ZeroExt(right.size - left.size)
        if left.size > right.size:
            right = right.ZeroExt(left.size - right.size)

        return left ^ right

    def visit_LLIL_NOT(self, expr):
        src = self.visit(expr.src)

        return src.__invert__()

    def visit_LLIL_NEG(self, expr):
        src = self.visit(expr.src)

        return src.__neg__()

    def visit_LLIL_LOAD(self, expr):
        src = self.visit(expr.src)
        size = expr.size

        loaded = self.executor.state.mem.load(
            src, size, endness=self.executor.arch.endness())

        return loaded

    def visit_LLIL_STORE(self, expr):
        dest = self.visit(expr.dest)
        src = self.visit(expr.src)
        assert expr.size*8 == src.size

        self.executor.state.mem.store(
            dest, src, endness=self.executor.arch.endness())
        return True

    def visit_LLIL_LSL(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert right.size <= left.size

        # the logical and arithmetic left-shifts are exactly the same
        return left << right.ZeroExt(left.size - right.size)

    def visit_LLIL_LSR(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert right.size <= left.size

        return left.LShR(
            right.ZeroExt(left.size - right.size)
        )

    def visit_LLIL_ROR(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert right.size <= left.size

        return left.RotateRight(
            right.ZeroExt(left.size - right.size)
        )

    def visit_LLIL_ROL(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert right.size <= left.size

        return left.RotateLeft(
            right.ZeroExt(left.size - right.size)
        )

    def visit_LLIL_ASL(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert right.size <= left.size

        return left << right.ZeroExt(left.size - right.size)

    def visit_LLIL_ASR(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        assert right.size <= left.size

        return left >> right.ZeroExt(left.size - right.size)

    def visit_LLIL_CALL(self, expr):
        dest = self.visit(expr.dest)

        if symbolic(dest):
            raise UnconstrainedIp()

        curr_fun_name = self.executor.bncache.get_function_name(
            self.executor.ip)
        if dest.value in self.executor.imported_functions:
            dest_fun_name = self.executor.imported_functions[dest.value]
        else:
            dest_fun_name = self.executor.bncache.get_function_name(dest.value)
        ret_addr = self.executor.ip + \
            self.executor.bncache.get_instruction_len(self.executor.ip)

        # save ret address
        self.executor.arch.save_return_address(
            self.executor.state, BVV(ret_addr, self.executor.arch.bits()))

        # check if we have an handler
        if dest_fun_name in library_functions:
            res = library_functions[dest_fun_name](
                self.executor.state, self.executor.view)

            try:
                dest_fun = self.executor.bncache.get_function(dest.value)
                calling_convention = dest_fun.calling_convention
            except IndexError:
                # dest_fun is not a function (imported). We do not have the info about the calling convention..
                # Let's use the caller convention
                curr_fun = self.executor.bncache.get_function(self.executor.ip)
                calling_convention = curr_fun.calling_convention
            self.executor.arch.save_result_value(
                self.executor.state, calling_convention, res)

            # retrive return address
            dest = self.executor.arch.get_return_address(self.executor.state)
            dest_fun_name = curr_fun_name
            assert not symbolic(dest)  # cannot happen (right?)

        # check if imported
        elif dest.value in self.executor.imported_functions:
            name = self.executor.imported_functions[dest.value]
            if name not in library_functions:
                raise UnimplementedModel(name)

            res = library_functions[name](
                self.executor.state, self.executor.view)

            dest_fun = self.executor.bncache.get_function(dest.value)
            self.executor.arch.save_result_value(
                self.executor.state, dest_fun.calling_convention, res)

            # retrive return address
            dest = self.executor.arch.get_return_address(self.executor.state)
            dest_fun_name = curr_fun_name
            assert not symbolic(dest)  # cannot happen (right?)

        # change ip
        self.executor.update_ip(dest_fun_name, self.executor.bncache.get_llil_address(
            dest_fun_name, dest.value))

        self.executor._wasjmp = True
        return True

    def visit_LLIL_TAILCALL(self, expr):
        dest = self.visit(expr.dest)

        if symbolic(dest):
            raise UnconstrainedIp()

        if dest.value in self.executor.imported_functions:
            dest_fun_name = self.executor.imported_functions[dest.value]
        else:
            dest_fun_name = self.executor.bncache.get_function_name(dest.value)

        # check if we have an handler
        if dest_fun_name in library_functions:
            res = library_functions[dest_fun_name](
                self.executor.state, self.executor.view)

            dest_fun = self.executor.bncache.get_function(dest.value)
            self.executor.arch.save_result_value(
                self.executor.state, dest_fun.calling_convention, res)

            # retrive return address
            dest = self.executor.arch.get_return_address(self.executor.state)
            if symbolic(dest):
                raise UnconstrainedIp()

            dest_fun_name = self.executor.bncache.get_function_name(dest.value)

        # check if imported
        if dest.value in self.executor.imported_functions:
            name = self.executor.imported_functions[dest.value]
            if name not in library_functions:
                raise UnimplementedModel(name)

            res = library_functions[name](
                self.executor.state, self.executor.view)

            dest_fun = self.executor.bncache.get_function(dest.value)
            self.executor.arch.save_result_value(
                self.executor.state, dest_fun.calling_convention, res)

            # retrive return address
            dest = self.executor.arch.get_return_address(self.executor.state)
            if symbolic(dest):
                raise UnconstrainedIp()

            dest_fun_name = self.executor.bncache.get_function_name(dest.value)

        # change ip
        self.executor.update_ip(dest_fun_name, self.executor.bncache.get_llil_address(
            dest_fun_name, dest.value))

        self.executor._wasjmp = True
        return True

    def visit_LLIL_JUMP(self, expr):
        destination = self.visit(expr.dest)

        if not symbolic(destination):
            # fast path. The destination is concrete
            dest_fun_name = self.executor.bncache.get_function_name(
                destination.value)
            self.executor.update_ip(dest_fun_name, self.executor.bncache.get_llil_address(
                dest_fun_name, destination.value))
            self.executor._wasjmp = True
            return True

        assert False  # implement this

    def visit_LLIL_JUMP_TO(self, expr):
        destination = self.visit(expr.dest)

        curr_fun_name = self.executor.bncache.get_function_name(
            self.executor.ip)

        if not symbolic(destination):
            # fast path. The destination is concrete
            self.executor.update_ip(curr_fun_name, self.executor.bncache.get_llil_address(
                curr_fun_name, destination.value))
            self.executor._wasjmp = True
            return True

        # symbolic IP path
        if self.executor.bncache.get_setting("use_bn_jumptable_targets") == 'true':
            max_num = len(expr.targets)
        else:
            max_num = 256
        num_ips, dest_ips = self._handle_symbolic_ip(destination, max_num)

        if num_ips == 256:
            self.executor.put_in_errored(
                self.executor.state, "Probably unconstrained IP")
            raise UnconstrainedIp()

        if num_ips == 0:
            self.executor.put_in_errored(
                self.executor.state, "No valid destination")
            raise NoDestination()

        for ip in dest_ips[1:]:
            new_state = self.executor.state.copy()
            new_state.solver.add_constraints(
                destination == ip
            )
            new_state.set_ip(ip.value)
            new_state.llil_ip = self.executor.bncache.get_llil_address(
                curr_fun_name, ip.value)
            self.executor.put_in_deferred(new_state)

        self.executor.update_ip(curr_fun_name, self.executor.bncache.get_llil_address(
            curr_fun_name, dest_ips[0].value))
        self.executor.state.solver.add_constraints(dest_ips[0] == destination)
        self.executor._wasjmp = True
        return True

        # ips = expr.targets
        # current_constraint = None
        # for dst_ip in ips:
        #     llil_index = self.executor.bncache.get_llil_address(
        #         curr_fun_name, dst_ip)
        #     if self.executor.state.solver.satisfiable([
        #         destination == dst_ip
        #     ]):
        #         if current_constraint is None:
        #             current_constraint = destination == dst_ip
        #             self.executor.update_ip(
        #                 curr_fun_name, llil_index)
        #         else:
        #             new_state = self.executor.state.copy()
        #             new_state.solver.add_constraints(
        #                 destination == dst_ip
        #             )
        #             new_state.set_ip(dst_ip)
        #             new_state.llil_ip = llil_index
        #             self.executor.put_in_deferred(new_state)

        # if current_constraint is None:
        #     return ErrorInstruction.NO_DEST

        # self.executor.state.solver.add_constraints(current_constraint)
        # self.executor._wasjmp = True
        # return True

    def visit_LLIL_IF(self, expr):
        condition = self.visit(expr.condition)
        true_llil_index = expr.true
        false_llil_index = expr.false

        save_unsat = self.executor.bncache.get_setting("save_unsat") == 'true'

        true_sat = True
        false_sat = True
        if isinstance(condition, BV):
            assert condition.size == 1
            condition = condition == 1

        if isinstance(condition, BoolV):
            # Fast path
            true_sat = condition.value
            false_sat = not condition.value
        else:
            if not self.executor.state.solver.satisfiable(extra_constraints=[
                condition
            ]):
                true_sat = False
            if not self.executor.state.solver.satisfiable(extra_constraints=[
                condition.Not()
            ]):
                false_sat = False

        curr_fun_name = self.executor.bncache.get_function_name(
            self.executor.ip)

        if true_sat and false_sat:
            true_state = self.executor.state
            false_state = self.executor.state.copy()

            true_state.solver.add_constraints(condition)
            self.executor.update_ip(curr_fun_name, true_llil_index)

            false_state.solver.add_constraints(condition.Not())
            false_state.set_ip(self.executor.bncache.get_address(
                curr_fun_name, false_llil_index))
            false_state.llil_ip = false_llil_index
            self.executor.put_in_deferred(false_state)
        elif true_sat and not false_sat:
            true_state = self.executor.state
            false_state = self.executor.state.copy() if save_unsat else None

            true_state.solver.add_constraints(condition)
            self.executor.update_ip(curr_fun_name, true_llil_index)

            if save_unsat:
                false_state.solver.add_constraints(condition.Not())
                import z3; false_state.solver._solver = z3.Solver()

                false_state.set_ip(self.executor.bncache.get_address(
                    curr_fun_name, false_llil_index))
                false_state.llil_ip = false_llil_index
                self.executor.put_in_unsat(false_state)
        elif not true_sat and false_sat:
            false_state = self.executor.state
            true_state = self.executor.state.copy() if save_unsat else None

            false_state.solver.add_constraints(condition.Not())
            self.executor.state = false_state
            self.executor.update_ip(curr_fun_name, false_llil_index)

            if save_unsat:
                true_state.solver.add_constraints(condition)
                import z3; true_state.solver._solver = z3.Solver()

                true_state.set_ip(self.executor.bncache.get_address(
                    curr_fun_name, true_llil_index))
                true_state.llil_ip = true_llil_index
                self.executor.put_in_unsat(true_state)
        else:
            true_state = self.executor.state.copy() if save_unsat else None
            false_state = self.executor.state.copy() if save_unsat else None

            if save_unsat:
                true_state.solver.add_constraints(condition)
                import z3; true_state.solver._solver = z3.Solver()

                true_state.set_ip(self.executor.bncache.get_address(
                    curr_fun_name, true_llil_index))
                true_state.llil_ip = true_llil_index
                self.executor.put_in_unsat(true_state)

                false_state.solver.add_constraints(condition.Not())
                import z3; false_state.solver._solver = z3.Solver()

                false_state.set_ip(self.executor.bncache.get_address(
                    curr_fun_name, false_llil_index))
                false_state.llil_ip = false_llil_index
                self.executor.put_in_unsat(false_state)

            self.executor.put_in_unsat(self.executor.state)
            raise UnsatState(self.executor.state.get_ip())

        self.executor._wasjmp = True
        return True

    def visit_LLIL_CMP_E(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        return left == right

    def visit_LLIL_CMP_NE(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        return left != right

    def visit_LLIL_CMP_SLT(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        return left < right

    def visit_LLIL_CMP_ULT(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        return left.ULT(right)

    def visit_LLIL_CMP_SLE(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        return left <= right

    def visit_LLIL_CMP_ULE(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        return left.ULE(right)

    def visit_LLIL_CMP_SGT(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        return left > right

    def visit_LLIL_CMP_UGT(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        return left.UGT(right)

    def visit_LLIL_CMP_SGE(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        return left >= right

    def visit_LLIL_CMP_UGE(self, expr):
        left = self.visit(expr.left)
        right = self.visit(expr.right)

        return left.UGE(right)

    def visit_LLIL_GOTO(self, expr):
        dest = expr.dest

        curr_fun_name = self.executor.bncache.get_function_name(
            self.executor.ip)
        self.executor.update_ip(curr_fun_name, dest)

        self.executor._wasjmp = True
        return True

    def visit_LLIL_RET(self, expr):
        dest = self.visit(expr.dest)

        if symbolic(dest):
            num_ips, dest_ips = self._handle_symbolic_ip(dest, 256)

            if num_ips == 256:
                self.executor.put_in_errored(
                    self.executor.state, "Probably unconstrained IP")
                raise UnconstrainedIp()
            if num_ips == 0:
                self.executor.put_in_errored(
                    self.executor.state, "No valid destination")
                raise NoDestination()

            for ip in dest_ips[1:]:
                dest_fun_name = self.executor.bncache.get_function_name(
                    ip.value)
                new_state = self.executor.state.copy()
                new_state.solver.add_constraints(
                    dest == ip
                )
                new_state.set_ip(ip.value)
                new_state.llil_ip = self.executor.bncache.get_llil_address(
                    dest_fun_name, ip.value)
                self.executor.put_in_deferred(new_state)

            dest_ip = dest_ips[0].value
        else:
            dest_ip = dest.value

        dest_fun_name = self.executor.bncache.get_function_name(dest_ip)
        self.executor.update_ip(
            dest_fun_name, self.executor.bncache.get_llil_address(dest_fun_name, dest_ip))

        self.executor._wasjmp = True
        return True

    def visit_LLIL_PUSH(self, expr):
        src = self.visit(expr.src)

        self.executor.state.stack_push(src)
        return True

    def visit_LLIL_POP(self, expr):
        return self.executor.state.stack_pop()

    def visit_LLIL_SX(self, expr):
        src = self.visit(expr.src)
        dest_size = expr.size * 8

        assert src.size <= dest_size

        return src.SignExt(dest_size - src.size)

    def visit_LLIL_ZX(self, expr):
        src = self.visit(expr.src)
        dest_size = expr.size * 8

        assert src.size <= dest_size

        return src.ZeroExt(dest_size - src.size)

    def visit_LLIL_SYSCALL(self, expr):
        n_reg = self.executor.state.os.get_syscall_n_reg()
        n = getattr(self.executor.state.regs, n_reg)
        assert not symbolic(n)
        n = n.value

        handler = self.executor.state.os.get_syscall_by_number(n)
        if handler is None:
            raise UnimplementedSyscall(n)

        res = handler(self.executor.state)
        res_reg = self.executor.state.os.get_out_syscall_reg()
        setattr(self.executor.state.regs, res_reg, res)

        return True

    def visit_LLIL_NORET(self, expr):
        raise ExitException()

```

`tests/__init__.py`:

```py
from . import file_tests
from . import os_linux_tests
from . import os_windows_tests
from . import memory_tests


def handle_test(module, test):
    print(test + "\t", end="")
    try:
        getattr(module, test)()
        print("OK")
    except Exception as e:
        print("ERROR")
        # raise e


def handle_module(module_name, module):
    print(module_name)
    for test in dir(module):
        if "test" in test:
            handle_test(module, test)


def run():
    handle_module("memory tests", memory_tests)
    handle_module("file tests", file_tests)
    handle_module("os linux tests", os_linux_tests)
    handle_module("os windows tests", os_windows_tests)

```

`tests/file_tests.py`:

```py
from ..expr import BVS, BVV
from ..memory.sym_file import SymFile
from ..os_models.os_file import OsFileHandler


def test_1():  # read unconstrained
    f = SymFile("a")
    res = f.read(1)
    assert len(res) == 1
    assert isinstance(res[0], BVS)
    assert res[0].name == "unconstrained_a_0"


def test_2():  # read concrete
    f = SymFile("a")
    f.write([BVV(0xff, 8)])
    f.seek(0)
    res = f.read(1)
    assert len(res) == 1
    assert isinstance(res[0], BVV)
    assert res[0].value == 255


def test_3():
    os = OsFileHandler()
    fd = os.open("stdin", "r--")
    assert fd == 0


def test_4():
    os = OsFileHandler()
    fd = os.open("stdin", "r--")

    assert os.is_open(fd)
    os.close(fd)
    assert not os.is_open(fd)


def test_5():
    os = OsFileHandler()
    fd1 = os.open("A", "-w-")
    fd2 = os.open("A", "r--")

    os.write(fd1, [BVV(0xff, 8)])
    res = os.read(fd2, 1)

    assert len(res) == 1
    assert isinstance(res[0], BVV)
    assert res[0].value == 255


def test_6():
    os1 = OsFileHandler()
    os2 = OsFileHandler()

    fd1 = os1.open("A", "-w-")
    os1.write(fd1, [BVV(0xff, 8)])
    fd2 = os1.open("A", "r--")

    os1.copy_to(os2)

    res = os2.read(fd2, 1)
    assert len(res) == 1
    assert isinstance(res[0], BVV)
    assert res[0].value == 255

```

`tests/memory_tests.py`:

```py
from ..expr import BVV
from ..memory.sym_flat_memory_not_paged import MemoryConcreteFlatNotPaged


def test_1():
    m1 = MemoryConcreteFlatNotPaged("")
    m1.store(BVV(0, m1.bits), BVV(0xff, 8))

    m2 = m1.copy()

    assert id(m1.values) == id(m2.values)

    m2.store(BVV(1, m2.bits), BVV(0xfa, 8))

    r11 = m1.load(BVV(0, m1.bits), 1)
    r12 = m1.load(BVV(1, m1.bits), 1)

    r21 = m2.load(BVV(0, m2.bits), 1)
    r22 = m2.load(BVV(1, m2.bits), 1)

    assert isinstance(r11, BVV)
    assert r11.value == 0xff
    assert not isinstance(r12, BVV)

    assert isinstance(r21, BVV)
    assert r21.value == 0xff
    assert isinstance(r22, BVV)
    assert r22.value == 0xfa

```

`tests/os_linux_tests.py`:

```py
from ..expr import BVS, BVV
from ..os_models.linux import Linux, Linuxi386, Linuxia64, LinuxArmV7


def test_1():
    l = Linux()
    l.write(0, [BVV(0xaa, 8), BVV(0xbb, 8), BVV(0xcc, 8)])

    res = l.get_stdin_stream()
    assert len(res) == 3
    assert (
        isinstance(res[0], BVV) and
        isinstance(res[1], BVV) and
        isinstance(res[2], BVV)
    )
    assert (
        res[0].value == 0xaa and
        res[1].value == 0xbb and
        res[2].value == 0xcc
    )


def test_2():
    l = Linux()
    l.write(1, [BVV(0xaa, 8), BVV(0xbb, 8), BVV(0xcc, 8)])

    res = l.get_stdout_stream()
    assert len(res) == 3
    assert (
        isinstance(res[0], BVV) and
        isinstance(res[1], BVV) and
        isinstance(res[2], BVV)
    )
    assert (
        res[0].value == 0xaa and
        res[1].value == 0xbb and
        res[2].value == 0xcc
    )


def test_3():
    l = Linux()
    assert l.stdin_fd == 0
    assert l.stdout_fd == 1


def test_4():
    l1 = Linux()
    l1.write(0, [BVV(0xaa, 8)])

    l2 = Linux()
    l1.copy_to(l2)

    l2.write(0, [BVV(0xbb, 8)])

    res1 = l1.get_stdin_stream()
    res2 = l2.get_stdin_stream()

    assert len(res1) == 1
    assert isinstance(res1[0], BVV)
    assert res1[0].value == 0xaa

    assert len(res2) == 2
    assert (
        isinstance(res2[0], BVV) and
        isinstance(res2[1], BVV)
    )
    assert (
        res2[0].value == 0xaa and
        res2[1].value == 0xbb
    )

```

`tests/os_windows_tests.py`:

```py
from ..expr import BVS, BVV
from ..os_models.windows import Windows


def test_1():
    l = Windows()
    l.write(0, [BVV(0xaa, 8), BVV(0xbb, 8), BVV(0xcc, 8)])

    res = l.get_stdin_stream()
    assert len(res) == 3
    assert (
        isinstance(res[0], BVV) and
        isinstance(res[1], BVV) and
        isinstance(res[2], BVV)
    )
    assert (
        res[0].value == 0xaa and
        res[1].value == 0xbb and
        res[2].value == 0xcc
    )


def test_2():
    l = Windows()
    l.write(1, [BVV(0xaa, 8), BVV(0xbb, 8), BVV(0xcc, 8)])

    res = l.get_stdout_stream()
    assert len(res) == 3
    assert (
        isinstance(res[0], BVV) and
        isinstance(res[1], BVV) and
        isinstance(res[2], BVV)
    )
    assert (
        res[0].value == 0xaa and
        res[1].value == 0xbb and
        res[2].value == 0xcc
    )


def test_3():
    l = Windows()
    assert l.stdin_fd == 0
    assert l.stdout_fd == 1


def test_4():
    l1 = Windows()
    l1.write(0, [BVV(0xaa, 8)])

    l2 = l1.copy(None)

    l2.write(0, [BVV(0xbb, 8)])

    res1 = l1.get_stdin_stream()
    res2 = l2.get_stdin_stream()

    assert len(res1) == 1
    assert isinstance(res1[0], BVV)
    assert res1[0].value == 0xaa

    assert len(res2) == 2
    assert (
        isinstance(res2[0], BVV) and
        isinstance(res2[1], BVV)
    )
    assert (
        res2[0].value == 0xaa and
        res2[1].value == 0xbb
    )

```

`ui/__init__.py`:

```py
from ..seninja_globals import globs
from PySide6.QtWidgets import QApplication
from binaryninjaui import DockHandler, UIAction, UIActionHandler, Menu
from PySide6.QtCore import Qt
from .registers_view import RegisterView
from .memory_view import MemoryView
from .buffer_view import BufferView
from .argv_form import GetArgvDialog

class BNWidgets(object):
    RW = None
    MW = None
    BW = None


def _get_registerview_widget(name, parent, data):
    BNWidgets.RW = RegisterView(parent, name, data)
    BNWidgets.RW.setEnabled(False)
    return BNWidgets.RW


def _get_memoryview_widget(name, parent, data):
    BNWidgets.MW = MemoryView(parent, name, data, BNWidgets)
    BNWidgets.MW.setEnabled(False)
    return BNWidgets.MW


def _get_buffer_view_widget(name, parent, data):
    BNWidgets.BW = BufferView(parent, name, data)
    BNWidgets.BW.setEnabled(False)
    return BNWidgets.BW


def _launchArgvDialog(context):
    if globs.executor is None:
        return
    d = GetArgvDialog(globs.executor.state)
    d.exec_()
    ui_sync_view(globs.executor.state, True)


def _registerDynamicWidgets():
    dock_handler = DockHandler.getActiveDockHandler()
    dock_handler.addDockWidget(
        "SENinja Registers",
        _get_registerview_widget,
        Qt.RightDockWidgetArea,
        Qt.Vertical,
        False
    )
    dock_handler.addDockWidget(
        "SENinja Memory",
        _get_memoryview_widget,
        Qt.BottomDockWidgetArea,
        Qt.Horizontal,
        False
    )
    dock_handler.addDockWidget(
        "SENinja Buffers",
        _get_buffer_view_widget,
        Qt.RightDockWidgetArea,
        Qt.Vertical,
        False
    )


def _registerUIActions():
    UIAction.registerAction("SENinja\\Setup argv...")
    UIActionHandler.globalActions().bindAction(
        "SENinja\\Setup argv...", UIAction(_launchArgvDialog))
    Menu.mainMenu("Tools").addAction("SENinja\\Setup argv...", "Setup argv...")


def enable_widgets():
    assert BNWidgets.RW is not None
    assert BNWidgets.MW is not None
    assert BNWidgets.BW is not None

    BNWidgets.RW.setEnabled(True)
    BNWidgets.MW.setEnabled(True)
    BNWidgets.BW.setEnabled(True)


def disable_widgets():
    assert BNWidgets.RW is not None
    assert BNWidgets.MW is not None
    assert BNWidgets.BW is not None

    BNWidgets.RW.setEnabled(False)
    BNWidgets.MW.setEnabled(False)
    BNWidgets.BW.setEnabled(False)


def ui_set_arch(arch, state):
    assert BNWidgets.RW is not None
    assert BNWidgets.MW is not None
    assert BNWidgets.BW is not None

    BNWidgets.RW.init(arch, state)
    BNWidgets.MW.init(arch, state)
    BNWidgets.BW.init(state)

    dock_handler = DockHandler.getActiveDockHandler()
    dock_handler.setVisible("SENinja Registers", True)
    dock_handler.setVisible("SENinja Memory", True)
    dock_handler.setVisible("SENinja Buffers", True)


def ui_sync_view(state, delta=True):
    assert BNWidgets.RW is not None
    assert BNWidgets.MW is not None
    assert BNWidgets.BW is not None

    if BNWidgets.RW.isVisible():
        BNWidgets.RW.set_reg_values(state)
    if BNWidgets.MW.isVisible():
        if delta:
            BNWidgets.MW.update_mem_delta(state)
        else:
            BNWidgets.MW.update_mem(state)
    if BNWidgets.BW.isVisible():
        BNWidgets.BW.update_state(state)


def ui_reset_view():
    assert BNWidgets.RW is not None
    assert BNWidgets.MW is not None
    assert BNWidgets.BW is not None

    BNWidgets.RW.reset()
    BNWidgets.MW.reset()
    BNWidgets.BW.reset()

    dock_handler = DockHandler.getActiveDockHandler()
    dock_handler.setVisible("SENinja Registers", False)
    dock_handler.setVisible("SENinja Memory", False)
    dock_handler.setVisible("SENinja Buffers", False)


_registerDynamicWidgets()
_registerUIActions()

```

`ui/argv_form.py`:

```py
from PySide6.QtWidgets import (
    QDialog,
    QLineEdit,
    QPushButton,
    QGridLayout,
    QLabel,
    QComboBox
)
from binaryninja.interaction import show_message_box
from ..utility.string_util import str_to_bv
from ..apis import setup_argv
from ..expr import BVV


class GetArgvDialog(QDialog):
    def __init__(self, state, parent=None):
        super(GetArgvDialog, self).__init__(parent)
        self.state = state

        self.setWindowTitle('Setup argv')

        self._outerLayout = QGridLayout()
        self._layout = QGridLayout()
        self._outerLayout.addLayout(self._layout, 0, 0, 1, 2)

        self.okButton = QPushButton("Ok")
        self.okButton.clicked.connect(self.onOkClick)
        self.cancelButton = QPushButton("Cancel")
        self.cancelButton.clicked.connect(self.onCancelClick)

        self._outerLayout.addWidget(self.okButton, 2, 0, 1, 1)
        self._outerLayout.addWidget(self.cancelButton, 2, 1, 1, 1)

        self.n_args = 0
        self.args = list()

        self.add_conc_button = QPushButton("Add conc param")
        self.add_conc_button.clicked.connect(self.onConcClick)
        self.add_symb_button = QPushButton("Add symb param")
        self.add_symb_button.clicked.connect(self.onSymbClick)

        self.label = QLabel("Number of args: " + str(self.n_args))

        self._layout.addWidget(self.add_conc_button, 0, 0, 1, 5)
        self._layout.addWidget(self.add_symb_button, 0, 5, 1, 5)
        self._layout.addWidget(self.label, 1, 0, 1, 10)

        self.setLayout(self._outerLayout)

    def update_label_args(self):
        self.label.setText("Number of args: " + str(self.n_args))

    def onConcClick(self):
        self.n_args += 1
        self.update_label_args()

        label = QLabel(str(self.n_args) + ": ")
        line_edit = QLineEdit("arg value...")

        self._layout.addWidget(label, self.n_args + 2, 0, 1, 1)
        self._layout.addWidget(line_edit, self.n_args + 2, 1, 1, 9)

        self.args.append(
            ("conc", label, line_edit)
        )

    def onSymbClick(self):
        self.n_args += 1
        self.update_label_args()

        label = QLabel(str(self.n_args) + ": ")
        combo_box = QComboBox()
        buffer_names = [
            b[0].name for b in self.state.symbolic_buffers]

        if len(buffer_names) == 0:
            show_message_box("Error", "No symbolic buffer")
            return

        for name in buffer_names:
            combo_box.addItem(name)

        self._layout.addWidget(label, self.n_args + 2, 0, 1, 1)
        self._layout.addWidget(combo_box, self.n_args + 2, 1, 1, 9)

        self.args.append(
            ("symb", label, combo_box)
        )

    def _get_buff_from_name(self, name):
        for buff, _, _ in self.state.symbolic_buffers:
            if buff.name == name:
                return buff
        return None

    def _get_arguments(self):
        res = list()
        for t, _, obj in self.args:
            if t == "conc":
                res.append(str_to_bv(obj.text(), True))
            else:
                buff = self._get_buff_from_name(
                    obj.currentText())
                assert buff is not None
                res.append(buff.Concat(BVV(0, 8)))
        return res

    def onOkClick(self):
        args = self._get_arguments()
        setup_argv(*args)
        self.accept()

    def onCancelClick(self):
        self.reject()

```

`ui/buffer_view.py`:

```py
from binaryninja import BackgroundTaskThread
from binaryninja.interaction import (
    show_message_box,
    get_int_input,
    get_choice_input
)
from binaryninjaui import (
    DockContextHandler,
    getMonospaceFont,
    UIActionHandler
)
from PySide6 import QtCore
from PySide6.QtCore import Qt, QMimeData
from PySide6.QtWidgets import (
    QApplication,
    QVBoxLayout,
    QWidget,
    QTableWidget,
    QTableWidgetItem,
    QMenu,
    QDialog,
    QLineEdit,
    QRadioButton,
    QPushButton,
    QCheckBox
)

from ..utility.expr_wrap_util import symbolic
from ..utility.string_util import (
    constraint_alphanumeric_string,
    constraint_ascii_string
)
from ..expr.bitvector import BVS, BVV


NO_CONSTRAINTS = 0
ASCII_STRING = 1
ALPHANUMERIC_STRING = 2


def get_int(v):
    try:
        return int(v)
    except:
        try:
            return int(v, 16)
        except:
            pass
    return None


class BufferViewBT(BackgroundTaskThread):
    def __init__(self, msg, bw, callback, pars):
        BackgroundTaskThread.__init__(self, msg, False)
        self.bw = bw
        self.pars = pars
        self.callback = callback

    def run(self):
        self.bw.setEnabled(False)
        self.callback(*self.pars)
        self.bw.setEnabled(True)


class CreateBufferDialog(QDialog):
    constraint_list = {
        NO_CONSTRAINTS: "No constraint",
        ASCII_STRING: "ASCII string",
        ALPHANUMERIC_STRING: "Alphanumeric string"
    }

    def __init__(self, blacklisted_names=[], parent=None):
        super(CreateBufferDialog, self).__init__(parent)

        self.setWindowTitle('Create new buffer')

        self.blacklisted_names = blacklisted_names

        layout = QVBoxLayout()

        self.buff_name = QLineEdit("Buffer name")
        self.buff_width = QLineEdit("Buffer size (bytes)")

        layout.addWidget(self.buff_name)
        layout.addWidget(self.buff_width)

        self.constraints = dict()
        for cid in sorted(CreateBufferDialog.constraint_list.keys()):
            name = CreateBufferDialog.constraint_list[cid]
            item = QRadioButton(name)
            if cid == NO_CONSTRAINTS:
                item.setChecked(True)
            self.constraints[cid] = item
            layout.addWidget(item)

        self.checkbox_terminator = QCheckBox("Terminator")
        self.checkbox_terminator.setChecked(True)
        layout.addWidget(self.checkbox_terminator)

        self.ok = QPushButton("Ok")
        self.ok.clicked.connect(self.on_okClick)
        self.cancel = QPushButton("Cancel")
        self.cancel.clicked.connect(self.on_cancelClick)

        layout.addWidget(self.ok)
        layout.addWidget(self.cancel)

        self.setLayout(layout)

        self.res_name = None
        self.res_width = None
        self.res_constraints = None

    def on_okClick(self):
        width = get_int(self.buff_width.text())
        if width is None:
            show_message_box(
                "Error", "Invalid buffer width: must be an integer")
            return
        if self.buff_name.text() in self.blacklisted_names:
            show_message_box(
                "Error", "Name already used")
            return

        self.res_width = width
        self.res_name = self.buff_name.text()

        for cid in self.constraints:
            el = self.constraints[cid]
            if el.isChecked():
                self.res_constraints = cid
                break
        self.res_terminator = self.checkbox_terminator.isChecked()

        self.accept()

    def on_cancelClick(self):
        self.reject()


def _normalize_tab_name(tab_name):
    return tab_name[:tab_name.find("(")-1]


def _makewidget(parent, val, center=False):
    """ Small helper function that builds a TableWidgetItem and sets up the font the way we want"""
    out = QTableWidgetItem(str(val))
    out.setFlags(Qt.ItemIsEnabled)
    out.setFont(getMonospaceFont(parent))
    if center:
        out.setTextAlignment(Qt.AlignCenter)
    return out


class BufferView(QWidget, DockContextHandler):
    onNewBufferSignal = QtCore.Signal(object)

    def __init__(self, parent, name, data):
        QWidget.__init__(self, parent)
        DockContextHandler.__init__(self, self, name)

        self.onNewBufferSignal.connect(self.update)

        self.parent = parent
        self.current_state = None
        self.data = data
        self.tab_name = None

        self.actionHandler = UIActionHandler()
        self.actionHandler.setupActionHandler(self)

        self._layout = QVBoxLayout()

        # Set up register table
        self._table = QTableWidget()
        self._table.setColumnCount(4)
        self._table.setHorizontalHeaderLabels(
            ['Address', 'Name', 'Size', 'Constraints'])
        self._table.horizontalHeader().setStretchLastSection(True)
        self._table.verticalHeader().setVisible(False)

        self._table.setContextMenuPolicy(Qt.CustomContextMenu)
        self._table.customContextMenuRequested.connect(
            self.on_customContextMenuRequested)
        self._table.doubleClicked.connect(self.on_doubleClick)

        self.button = QPushButton("New Buffer")
        self.button.clicked.connect(self.on_newBufferClick)

        self._layout.addWidget(self.button)
        self._layout.addWidget(self._table)

        self.setLayout(self._layout)

    def on_newBufferClick(self):
        if self.current_state is None:
            return

        blacklisted_names = [
            b[0].name for b in self.current_state.symbolic_buffers]

        new_buff_dialog = CreateBufferDialog(
            blacklisted_names=blacklisted_names)
        new_buff_dialog.exec_()

        if new_buff_dialog.res_name is None:
            return

        buff = BVS(new_buff_dialog.res_name, new_buff_dialog.res_width * 8)
        if new_buff_dialog.res_terminator:
            buff_to_store = buff.Concat(BVV(0, 8))
        else:
            buff_to_store = buff

        address = self.current_state.mem.allocate(new_buff_dialog.res_width)
        if new_buff_dialog.res_constraints == ALPHANUMERIC_STRING:
            constraint_alphanumeric_string(buff, self.current_state)
        elif new_buff_dialog.res_constraints == ASCII_STRING:
            constraint_ascii_string(buff, self.current_state)

        constraint_str = ""
        if new_buff_dialog.res_constraints != NO_CONSTRAINTS:
            constraint_str = CreateBufferDialog.constraint_list[new_buff_dialog.res_constraints]
        self.current_state.mem.store(address, buff_to_store)
        self.current_state.symbolic_buffers.append(
            (buff, address, constraint_str)
        )
        self.update_state(self.current_state)

    def reset(self):
        self.tab_name = None
        self.current_state = None
        self._table.setRowCount(0)

    def init(self, state):
        self.current_state = state
        self.tab_name = _normalize_tab_name(self.parent.getTabName())
        self.update_state(state)

    def update_state(self, state):
        self.current_state = state
        self._table.setRowCount(0)
        self._table.setRowCount(len(self.current_state.symbolic_buffers))
        i = 0
        for buff, address, constraints in self.current_state.symbolic_buffers:
            self._table.setItem(i, 0, _makewidget(self, hex(address)))
            self._table.setItem(i, 1, _makewidget(self, buff.name))
            self._table.setItem(i, 2, _makewidget(self, buff.size // 8))
            self._table.setItem(i, 3, _makewidget(self, constraints))
            i += 1

    @staticmethod
    def _condom(f, *pars):
        def g():
            f(*pars)
        return g

    @staticmethod
    def _condom_async(bw, f, *pars):
        def g():
            bt = BufferViewBT("BufferView background task...", bw, f, pars)
            bt.start()
        return g

    # right click menu
    def on_customContextMenuRequested(self, pos):
        item = self._table.itemAt(pos)
        if item is None:
            return
        row_idx = item.row()
        menu = QMenu()

        copy_address = menu.addAction("Copy address")
        copy_address.triggered.connect(BufferView._condom(
            self._menuAction_copy_address, row_idx))
        eval_upto = menu.addAction("Evaluate upto")
        eval_upto.triggered.connect(BufferView._condom_async(
            self, self._menuAction_evaluate_upto_buffer, row_idx))
        eval_as_bytes = menu.addAction("Evaluate as bytes")
        eval_as_bytes.triggered.connect(BufferView._condom_async(
            self, self._menuAction_evaluate_buffer, row_idx))
        copy_eval = menu.addAction("Copy evaluated bytes")
        copy_eval.triggered.connect(BufferView._condom_async(
            self, self._menuAction_copy_evaluated_buffer, row_idx))
        add_constraint = menu.addAction("Add constraint")
        add_constraint.triggered.connect(BufferView._condom(
            self._menuAction_add_constraint, row_idx))

        menu.exec_(self._table.viewport().mapToGlobal(pos))

    def _menuAction_copy_address(self, buffer_id):
        mime = QMimeData()
        mime.setText(hex(self.current_state.symbolic_buffers[buffer_id][1]))
        QApplication.clipboard().setMimeData(mime)

    def _menuAction_evaluate_buffer(self, buffer_id):
        buff = self.current_state.symbolic_buffers[buffer_id][0]
        res = self.current_state.solver.evaluate(buff).as_bytes()
        res = repr(res)[2:-1]
        show_message_box("%s evaluate" % buff.name, res)

    def _menuAction_evaluate_upto_buffer(self, buffer_id):
        buff = self.current_state.symbolic_buffers[buffer_id][0]

        n_eval = get_int_input("How many values (upto) ?", "Number of distinct values")
        r = ""
        for i, v in enumerate(self.current_state.solver.evaluate_upto(buff, n_eval)):
            r += "solution %d: %s\n" % (i, hex(v.value))

        show_message_box("%s evaluate" % buff.name, r)

    def _menuAction_copy_evaluated_buffer(self, buffer_id):
        mime = QMimeData()
        buff = self.current_state.symbolic_buffers[buffer_id][0]
        res = self.current_state.solver.evaluate(buff).as_bytes()
        res = '"' + repr(res)[2:-1] + '"'
        mime.setText(res)
        QApplication.clipboard().setMimeData(mime)

    def _menuAction_add_constraint(self, buffer_id):
        buff = self.current_state.symbolic_buffers[buffer_id][0]
        constraints = self.current_state.symbolic_buffers[buffer_id][2]
        if constraints != "":
            show_message_box("Error", "The buffer already has a constraint.")
            return

        choices = [CreateBufferDialog.constraint_list[i]
                   for i in CreateBufferDialog.constraint_list.keys() if i != NO_CONSTRAINTS]
        res = get_choice_input(
            "Constraint buffer", "choices:", choices
        )
        if choices[res] == "Alphanumeric string":
            constraint_alphanumeric_string(buff, self.current_state)
        elif choices[res] == "ASCII string":
            constraint_ascii_string(buff, self.current_state)
        else:
            return

        t = self.current_state.symbolic_buffers[buffer_id]
        t = t[0], t[1], choices[res]
        self.current_state.symbolic_buffers[buffer_id] = t
        self.update_state(self.current_state)

    # double click event
    def on_doubleClick(self, item):
        # row_idx = item.row()
        pass

    def shouldBeVisible(self, view_frame):
        if view_frame is None:
            return False
        elif self.tab_name is None:
            return False
        elif _normalize_tab_name(view_frame.getTabName()) != self.tab_name:
            return False
        return True

    def notifyViewChanged(self, view_frame):
        if view_frame is None:
            pass
        else:
            pass

    def contextMenuEvent(self, event):
        self.m_contextMenuManager.show(self.m_menu, self.actionHandler)

```

`ui/hexview.py`:

```py
# based on https://github.com/williballenthin/python-pyqt5-hexview

from PySide6.QtCore import (
    Qt,
    Signal,
    QSize,
    QCoreApplication,
    QMetaObject,
    QModelIndex,
    QAbstractTableModel,
    QItemSelectionModel,
    QItemSelection
)
from PySide6.QtWidgets import (
    QTableView,
    QWidget,
    QVBoxLayout,
    QLabel,
    QSizePolicy,
    QAbstractItemView,
    QMenu,
    QItemDelegate,
    QSizePolicy
)
from PySide6.QtGui import (
    QMouseEvent,
    QKeySequence,
    QFontDatabase
)


def row_start_index(index):
    """ get index of the start of the 0x10 byte row containing the given index """
    return index - (index % 0x10)


def row_end_index(index):
    """ get index of the end of the 0x10 byte row containing the given index """
    return index - (index % 0x10) + 0xF


def row_number(index):
    """ get row number of the 0x10 byte row containing the given index """
    return index // 0x10


def column_number(index):
    return index % 0x10


def is_int(val):
    try:
        int(val, 16)
        return True
    except:
        pass
    return False


class HexItemDelegate(QItemDelegate):
    def __init__(self, model, parent, *args):
        super(HexItemDelegate, self).__init__(parent)
        self._model = model

    # def editorEvent(self, event, model, option, index):
    #     print(event, model, option, index)
    #     return True

    # def setEditorData(self, editor, index):
    #     pass


class HexTableModel(QAbstractTableModel):
    FILTER = ''.join([(len(repr(chr(x))) == 3 or chr(x) == "\\")
                      and chr(x) or '.' for x in range(256)])

    def __init__(self, parent=None, *args):
        super(HexTableModel, self).__init__(parent, *args)
        self.buf = {}
        self.rows = 512 // 16
        self.buf_size = 0
        self.start_address = 0
        self.parent = parent

    @staticmethod
    def qindex2index(index):
        """ from a QIndex (row/column coordinate system), get the buffer index of the byte """
        r = index.row()
        c = index.column()
        if c > 0x10:
            return (0x10 * r) + c - 0x11
        else:
            return (0x10 * r) + c

    def index2qindexb(self, index):
        """ from a buffer index, get the QIndex (row/column coordinate system) of the byte pane """
        r = index // 0x10
        c = index % 0x10
        return self.index(r, c)

    def index2qindexc(self, index):
        """ from a buffer index, get the QIndex (row/column coordinate system) of the char pane """
        r = (index // 0x10)
        c = index % 0x10 + 0x11
        return self.index(r, c)

    def rowCount(self, parent):
        return self.rows
        if self.buf_size % 0x10 != 0:
            return (self.buf_size // 0x10) + 1
        else:
            return self.buf_size // 0x10

    def columnCount(self, parent):
        return 0x21

    def data(self, index, role):
        if self.buf_size == 0:
            return
        if not index.isValid():
            return None

        elif self.qindex2index(index) >= self.buf_size:
            return None

        col = index.column()
        bindex = self.qindex2index(index)
        if role == Qt.DisplayRole:
            if col == 0x10:
                return ""
            c = self.buf[bindex]
            if col > 0x10:
                val = int(c, 16) if c != ".." and c != "__" else c
                return chr(val) if (
                    val != "__" and
                    val != ".." and
                    val >= 32 and
                    val <= 126
                ) else "."
            else:
                return c
        elif role == Qt.BackgroundRole:
            return None
        else:
            return None

    def setData(self, index, value, role=Qt.EditRole):
        if role == Qt.EditRole:
            if index.column() == 0x10:
                return False
            is_ascii = False
            if index.column() > 0x10:
                is_ascii = True
            if not is_ascii and is_int(value) and int(value, 16) <= 255 and int(value, 16) >= 0:
                off = self.qindex2index(index)
                self.buf[off] = value.lower()
                self.parent.data_edited.emit(off, int(value, 16))
                # memory_view will send a dataChanged signal
                return True
            elif is_ascii and len(value) == 1 and ord(value) < 128:
                off = self.qindex2index(index)
                self.buf[off] = "{:02x}".format(ord(value))
                self.parent.data_edited.emit(off, ord(value))
        return False

    @property
    def data_length(self):
        return self.buf_size

    def flags(self, index):
        return Qt.ItemIsEnabled | Qt.ItemIsSelectable | Qt.ItemIsEditable

    def headerData(self, section, orientation, role):
        if role != Qt.DisplayRole:
            return None
        elif orientation == Qt.Horizontal:
            if section < 0x10:
                return "%01X" % (section)
            else:
                return ""
        elif orientation == Qt.Vertical:
            return "%016X" % (section * 0x10 + self.start_address)
        else:
            return None

    def _emit_data_changed(self, start_bindex, end_bindex):
        for i in range(start_bindex, end_bindex):
            # mark data changed to encourage re-rendering of cell
            qib = self.index2qindexb(i)
            qic = self.index2qindexc(i)
            self.dataChanged.emit(qib, qib)
            self.dataChanged.emit(qic, qic)

    def _handle_range_changed(self, range_min, range_max):
        self._emit_data_changed(range_min, range_max)


class HexItemSelectionModel(QItemSelectionModel):
    selectionRangeChanged = Signal([int])

    def __init__(self, model, view):
        """
        :type view: HexTableView
        """
        super(HexItemSelectionModel, self).__init__(model)
        self._model = model
        self._view = view

        self._start_qindex = None
        self._view.leftMousePressedIndex.connect(self._handle_mouse_pressed)
        self._view.leftMouseMovedIndex.connect(self._handle_mouse_moved)
        self._view.leftMouseReleasedIndex.connect(self._handle_mouse_released)

        self.start = None
        self.end = None

    def _bselect(self, selection, start_bindex, end_bindex):
        """ add the given buffer indices to the given QItemSelection, both byte and char panes """
        selection.select(self._model.index2qindexb(
            start_bindex), self._model.index2qindexb(end_bindex))
        selection.select(self._model.index2qindexc(
            start_bindex), self._model.index2qindexc(end_bindex))

    def _do_select(self, start_bindex, end_bindex):
        """
        select the given range by buffer indices

        selects items like this:

            ..................
            ......xxxxxxxxxxxx
            xxxxxxxxxxxxxxxxxx
            xxxxxxxxxxxxxxxxxx
            xxxxxxxxxxxx......
            ..................

        *not* like this:

            ..................
            ......xxxxxx......
            ......xxxxxx......
            ......xxxxxx......
            ......xxxxxx......
            ..................
         """
        self.select(QItemSelection(), QItemSelectionModel.Clear)
        if start_bindex > end_bindex:
            start_bindex, end_bindex = end_bindex, start_bindex

        selection = QItemSelection()
        if row_number(end_bindex) - row_number(start_bindex) == 0:
            # all on one line
            self._bselect(selection, start_bindex, end_bindex)
        elif row_number(end_bindex) - row_number(start_bindex) == 1:
            # two lines
            self._bselect(selection, start_bindex, row_end_index(start_bindex))
            self._bselect(selection, row_start_index(end_bindex), end_bindex)
        else:
            # many lines
            self._bselect(selection, start_bindex, row_end_index(start_bindex))
            self._bselect(selection, row_start_index(
                start_bindex) + 0x10, row_end_index(end_bindex) - 0x10)
            self._bselect(selection, row_start_index(end_bindex), end_bindex)

        self.select(selection, QItemSelectionModel.SelectCurrent)
        self.start = start_bindex
        self.end = end_bindex
        self.selectionRangeChanged.emit(end_bindex)

    def bselect(self, start_bindex, end_bindex):
        """  the public interface to _do_select """
        return self._do_select(start_bindex, end_bindex)

    def handle_move_key(self, key):
        if self._start_qindex == self._model.index2qindexc(self.start) or \
                self._start_qindex == self._model.index2qindexb(self.start):
            i = self.end
        else:
            i = self.start
        if key == QKeySequence.MoveToEndOfDocument:
            i = self._model.data_length - 1
        elif key == QKeySequence.MoveToEndOfLine:
            i = row_end_index(i)
        elif key == QKeySequence.MoveToNextChar:
            i += 1
        elif key == QKeySequence.MoveToNextLine:
            i += 0x10
        elif key == QKeySequence.MoveToNextPage:
            i += 0x40
        elif key == QKeySequence.MoveToNextWord:
            i += 1
        elif key == QKeySequence.MoveToPreviousChar:
            i -= 1
        elif key == QKeySequence.MoveToPreviousLine:
            i -= 0x10
        elif key == QKeySequence.MoveToPreviousPage:
            i -= 0x40
        elif key == QKeySequence.MoveToPreviousWord:
            i -= 1
        elif key == QKeySequence.MoveToStartOfDocument:
            i = 0x0
        elif key == QKeySequence.MoveToStartOfLine:
            i = row_start_index(i)
        else:
            raise RuntimeError("Unexpected movement key: %s" % (key))

        # this behavior selects the smallest or largest cell in the
        #   same column as the out-of-bounds index
        if i < 0:
            i %= 0x10
        if i > self._model.data_length:
            i %= 0x10
            i = self._model.data_length - 0x10 + i

        self.bselect(i, i)

    def handle_select_key(self, key):
        i = None
        j = None
        if self._start_qindex == self._model.index2qindexc(self.start) or \
                self._start_qindex == self._model.index2qindexb(self.start):
            i = self.end
            j = self.start
        else:
            i = self.start
            j = self.end

        if key == QKeySequence.SelectEndOfDocument:
            i = self._model.data_length - 1
        elif key == QKeySequence.SelectEndOfLine:
            i = row_end_index(i)
        elif key == QKeySequence.SelectNextChar:
            i += 1
        elif key == QKeySequence.SelectNextLine:
            i += 0x10
        elif key == QKeySequence.SelectNextPage:
            i += 0x40
        elif key == QKeySequence.SelectNextWord:
            i += 1
        elif key == QKeySequence.SelectPreviousChar:
            i -= 1
        elif key == QKeySequence.SelectPreviousLine:
            i -= 0x10
        elif key == QKeySequence.SelectPreviousPage:
            i -= 0x40
        elif key == QKeySequence.SelectPreviousWord:
            i -= 1
        elif key == QKeySequence.SelectStartOfDocument:
            i = 0x0
        elif key == QKeySequence.SelectStartOfLine:
            i = row_start_index(i)
        else:
            raise RuntimeError("Unexpected select key: %s" % (key))

        # this behavior selects the smallest or largest cell in the
        #   same column as the out-of-bounds index
        if i < 0:
            i %= 0x10
        if i > self._model.data_length:
            i %= 0x10
            i = self._model.data_length - 0x10 + i

        # need to explicitly reset start_qindex so that the current index
        #   doesn't get confused when coming from a selection of a single cell
        #   (in the check at the start of this function to decide which end of
        #    the selection was most recently active)
        self._start_qindex = self._model.index2qindexc(j)

        self.bselect(i, j)

    def _update_selection(self, qindex1, qindex2):
        """  select the given range by qmodel indices """
        m = self.model()
        self._do_select(m.qindex2index(qindex1), m.qindex2index(qindex2))

    def _handle_mouse_pressed(self, qindex):
        self._start_qindex = qindex
        self._update_selection(qindex, qindex)

    def _handle_mouse_moved(self, qindex):
        self._update_selection(self._start_qindex, qindex)

    def _handle_mouse_released(self, qindex):
        self._update_selection(self._start_qindex, qindex)
        self._start_qindex = None


class HexTableView(QTableView):
    """ table view that handles click events for better selection handling """
    leftMousePressed = Signal([QMouseEvent])
    leftMousePressedIndex = Signal([QModelIndex])
    leftMouseMoved = Signal([QMouseEvent])
    leftMouseMovedIndex = Signal([QModelIndex])
    leftMouseReleased = Signal([QMouseEvent])
    leftMouseReleasedIndex = Signal([QModelIndex])
    moveKeyPressed = Signal([QKeySequence])
    selectKeyPressed = Signal([QKeySequence])

    def __init__(self, *args, **kwargs):
        super(HexTableView, self).__init__(*args, **kwargs)
        self.parent = kwargs["parent"]
        self.leftMousePressed.connect(self._handle_mouse_press)
        self.leftMouseMoved.connect(self._handle_mouse_move)
        self.leftMouseReleased.connect(self._handle_mouse_release)

        self._press_start_index = None
        self._press_current_index = None
        self._press_end_index = None
        self._is_tracking_mouse = False

    def _reset_press_state(self):
        self._press_start_index = None
        self._press_current_index = None
        self._press_end_index = None

    def mousePressEvent(self, event):
        super(HexTableView, self).mousePressEvent(event)
        if event.buttons() & Qt.LeftButton:
            self.leftMousePressed.emit(event)

    def mouseMoveEvent(self, event):
        super(HexTableView, self).mouseMoveEvent(event)
        if event.buttons() & Qt.LeftButton:
            self.leftMouseMoved.emit(event)

    def mouseReleaseEvent(self, event):
        super(HexTableView, self).mousePressEvent(event)
        if event.buttons() & Qt.LeftButton:
            self.leftMouseReleased.emit(event)

    def focusOutEvent(self, event):
        super(HexTableView, self).focusOutEvent(event)
        if not event.reason() & Qt.MenuBarFocusReason:
            self.parent._hsm.clearSelection()

    def keyPressEvent(self, event):
        move_keys = (
            QKeySequence.MoveToEndOfDocument,
            QKeySequence.MoveToEndOfLine,
            QKeySequence.MoveToNextChar,
            QKeySequence.MoveToNextLine,
            QKeySequence.MoveToNextPage,
            QKeySequence.MoveToNextWord,
            QKeySequence.MoveToPreviousChar,
            QKeySequence.MoveToPreviousLine,
            QKeySequence.MoveToPreviousPage,
            QKeySequence.MoveToPreviousWord,
            QKeySequence.MoveToStartOfDocument,
            QKeySequence.MoveToStartOfLine,
        )

        for move_key in move_keys:
            if event.matches(move_key):
                self.moveKeyPressed.emit(move_key)
                return

        select_keys = (
            QKeySequence.SelectAll,
            QKeySequence.SelectEndOfDocument,
            QKeySequence.SelectEndOfLine,
            QKeySequence.SelectNextChar,
            QKeySequence.SelectNextLine,
            QKeySequence.SelectNextPage,
            QKeySequence.SelectNextWord,
            QKeySequence.SelectPreviousChar,
            QKeySequence.SelectPreviousLine,
            QKeySequence.SelectPreviousPage,
            QKeySequence.SelectPreviousWord,
            QKeySequence.SelectStartOfDocument,
            QKeySequence.SelectStartOfLine,
        )

        for select_key in select_keys:
            if event.matches(select_key):
                self.selectKeyPressed.emit(select_key)
                return

    def _handle_mouse_press(self, key_event):
        self._reset_press_state()

        self._press_start_index = self.indexAt(key_event.pos())
        self._is_tracking_mouse = True

        self.leftMousePressedIndex.emit(self._press_start_index)

    def _handle_mouse_move(self, key_event):
        if self._is_tracking_mouse:
            i = self.indexAt(key_event.pos())
            if i != self._press_current_index:
                self._press_current_index = i
                self.leftMouseMovedIndex.emit(i)

    def _handle_mouse_release(self, key_event):
        self._press_end_index = self.indexAt(key_event.pos())
        self._is_tracking_mouse = False

        self.leftMouseReleasedIndex.emit(self._press_end_index)


class HexViewWidget(QWidget):
    full_data_changed = Signal(object, dict, int)
    single_data_changed = Signal(object, list)
    data_edited = Signal(object, int)

    def __init__(self, parent=None, menu_handler=None):
        super(HexViewWidget, self).__init__()
        self.setupUi(self)

        self._model = HexTableModel(self)
        self.view = HexTableView(parent=self)
        sizePolicy = QSizePolicy(
            QSizePolicy.MinimumExpanding, QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(
            self.view.sizePolicy().hasHeightForWidth())
        self.view.setSizePolicy(sizePolicy)
        # self.view.setMinimumSize(QSize(660, 0))
        self.view.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
        self.view.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.view.setSelectionMode(QAbstractItemView.NoSelection)
        self.view.setShowGrid(False)
        self.view.setWordWrap(False)
        self.view.setStyleSheet(
            "QHeaderView { } QTableView::item { } ")  # bypass stylesheet
        # self.view.setObjectName("view")
        # self.view.horizontalHeader().setDefaultSectionSize(10)
        self.view.horizontalHeader().setMinimumSectionSize(5)
        # self.view.verticalHeader().setDefaultSectionSize(21)
        # self.view.setMinimumWidth( self.view.width() )
        self.mainLayout.insertWidget(0, self.view)

        self.view.setModel(self._model)
        for i in range(0x10):
            self.view.setColumnWidth(i, 25)
        self.view.setColumnWidth(0x10, 5)
        for i in range(0x11, 0x22):
            self.view.setColumnWidth(i, 11)

        self._hsm = HexItemSelectionModel(self._model, self.view)
        self.view.setSelectionModel(self._hsm)

        self.view.setContextMenuPolicy(Qt.CustomContextMenu)
        self.view.customContextMenuRequested.connect(
            self._handle_context_menu_requested)
        if menu_handler is not None:
            self.get_context_menu = menu_handler

        self.optimal_width = self.view.verticalScrollBar(
        ).width()+self.view.verticalHeader().width()  # - 40
        for i in range(0x22):
            self.optimal_width += self.view.columnWidth(i)

        f = QFontDatabase.systemFont(QFontDatabase.FixedFont)
        f.setPointSize(8)
        self.view.horizontalHeader().setFont(f)
        self.view.verticalHeader().setFont(f)
        self.view.setFont(f)
        self.statusLabel.setFont(f)

        self.view.setMinimumWidth(self.optimal_width)
        self.view.setMaximumWidth(self.optimal_width)

        self._hsm.selectionRangeChanged.connect(
            self._handle_selection_range_changed)
        self.view.moveKeyPressed.connect(self._hsm.handle_move_key)
        self.view.selectKeyPressed.connect(self._hsm.handle_select_key)

        self.view.setItemDelegate(HexItemDelegate(self._model, self))

        self.full_data_changed.connect(self._handle_data_changed)
        self.single_data_changed.connect(self._handle_single_data_changed)
        # self.data_edited.connect(self._handle_data_edited)

        self.statusLabel.setText("")

    def _handle_data_edited(self, address, data):
        pass
        # print("edited address data", address, data)

    def _handle_data_changed(self, new_address, new_data, new_data_size):
        self._model.buf = new_data
        self._model.buf_size = new_data_size
        self._model.start_address = new_address
        self._model._handle_range_changed(0, 512)

    def _handle_single_data_changed(self, idx, new_val):
        self._model.buf[idx] = new_val
        self._model._handle_range_changed(idx, idx)

    def _handle_context_menu_requested(self, qpoint):
        menu = self.get_context_menu(qpoint)
        if menu is None:
            return
        menu.exec_(self.view.mapToGlobal(qpoint))

    def _print_selection(self):
        start = self._hsm.start
        end = self._hsm.end

        print(start, end)

    def get_context_menu(self, qpoint):
        """ override this method to customize the context menu """
        menu = QMenu(self)
        index = self.view.indexAt(qpoint)

        a = menu.addAction("Print selection")
        a.triggered.connect(self._print_selection)
        return menu

    def _render_status_text(self):
        txt = []
        start = self._hsm.start
        end = self._hsm.end
        if start not in (None, -1) and end not in (None, -1):
            txt.append("sel: [{:s}, {:s}]".format(hex(start), hex(end)))
            txt.append("len: {:s}".format(hex(end - start + 1)))
        self.statusLabel.setText(" ".join(txt))

    def _handle_selection_range_changed(self, end_bindex):
        self._render_status_text()

    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(400, 300)
        self.verticalLayout = QVBoxLayout(Form)
        self.verticalLayout.setObjectName("verticalLayout")
        self.mainLayout = QVBoxLayout()
        self.mainLayout.setObjectName("mainLayout")
        self.statusLabel = QLabel(Form)
        self.statusLabel.setMaximumSize(QSize(16777215, 15))
        self.statusLabel.setObjectName("statusLabel")
        self.mainLayout.addWidget(self.statusLabel)
        self.verticalLayout.addLayout(self.mainLayout)

        self.retranslateUi(Form)
        QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Form"))
        self.statusLabel.setText(_translate("Form", "TextLabel"))

```

`ui/memory_view.py`:

```py
from binaryninja import BackgroundTaskThread
from binaryninja.interaction import (
    show_message_box,
    get_int_input,
)
from binaryninjaui import (
    DockContextHandler,
    UIActionHandler
)
from PySide6.QtCore import QMimeData
from PySide6.QtWidgets import (
    QApplication,
    QGridLayout,
    QWidget,
    QMenu,
    QPushButton,
)

from ..utility.expr_wrap_util import symbolic, split_bv_in_list
from ..expr.bitvector import BVS, BVV
from .hexview import HexViewWidget

def _normalize_tab_name(tab_name):
    return tab_name[:tab_name.find("(")-1]


class MemoryViewBT(BackgroundTaskThread):
    def __init__(self, msg, mw, callback, pars):
        BackgroundTaskThread.__init__(self, msg, False)
        self.mw = mw
        self.pars = pars
        self.callback = callback

    def run(self):
        self.mw.setEnabled(False)
        self.callback(*self.pars)
        self.mw.setEnabled(True)


class MemoryView(QWidget, DockContextHandler):

    def __init__(self, parent, name, data, bnwidgets):
        QWidget.__init__(self, parent)
        DockContextHandler.__init__(self, self, name)

        self.actionHandler = UIActionHandler()
        self.actionHandler.setupActionHandler(self)
        self.data = data
        self.parent = parent
        self.bnwidgets = bnwidgets

        self.current_state = None
        self.arch = None
        self.address_start = None
        self.size = 512
        self.changes = set()
        self.tab_name = None

        self.monitor_history = list()

        self.symb_idx = 0

        self._layout = QGridLayout()
        self.button = QPushButton("Monitor Memory")
        self.button.setStyleSheet("margin-left: 10px;")
        self.button.clicked.connect(self._condom_async(
            self, self.on_monitor_button_click))
        self.back_button = QPushButton("Back")
        self.back_button.setStyleSheet("margin-right: 10px;")
        self.back_button.clicked.connect(self._condom_async(
            self, self.on_back_click))

        self.hexWidget = HexViewWidget(
            menu_handler=self.on_customContextMenuRequested)
        self.hexWidget.data_edited.connect(self._handle_data_edited)
        self.hexWidget.setEnabled(False)

        self._layout.addWidget(self.button, 0, 0, 1, 4)
        self._layout.addWidget(self.back_button, 0, 4, 1, 1)
        self._layout.addWidget(self.hexWidget, 1, 0, 1, 5)
        self._layout.setContentsMargins(0, 0, 0, 0)

        self.setMaximumWidth(self.hexWidget.optimal_width + 25)

        self.setLayout(self._layout)

    def _monitor_changes(self, address, size):
        if symbolic(address):
            self.changes.clear()
            self.changes.add((
                self.address_start, self.address_start + self.size
            ))
            return

        address = address.value
        if (
            self.address_start + self.size >= address and
            self.address_start <= address + size
        ):
            to_monitor_min = max(self.address_start,
                                 address) - self.address_start
            to_monitor_max = min(self.address_start + self.size,
                                 address + size) - self.address_start
            self.changes.add((to_monitor_min, to_monitor_max))

    def on_monitor_button_click(self):
        if self.current_state is None:
            return

        address = get_int_input("Memory address", "Set Memory Monitor")
        if address is None:
            return
        address = address & 0xffffffffffffffff  # signed to unsigned
        self.monitor_history.append(address)

        self.hexWidget.setEnabled(True)
        self.address_start = address
        self.size = 512
        self.current_state.mem.register_store_hook(self._monitor_changes)
        self.update_mem(self.current_state)

    def on_back_click(self):
        if self.current_state is None:
            return

        if len(self.monitor_history) < 2:
            return

        self.monitor_history.pop()
        address = self.monitor_history[-1]

        self.hexWidget.setEnabled(True)
        self.address_start = address
        self.size = 512
        self.current_state.mem.register_store_hook(self._monitor_changes)
        self.update_mem(self.current_state)

    def init(self, arch, state):
        self.arch = arch
        self.tab_name = _normalize_tab_name(self.parent.getTabName())
        self.update_mem(state)

    def update_mem(self, state):
        self.current_state = state
        if self.address_start is None:
            return
        self.changes.clear()
        data = {}
        for i in range(self.size):
            if not state.mem.is_mapped(self.address_start + i):
                val = "__"
            else:
                b = state.mem.load(self.address_start + i, 1)
                val = ".."
                if isinstance(b, BVV):
                    val = "{:02x}".format(b.value)
            data[i] = val

        self.hexWidget.full_data_changed.emit(
            self.address_start, data, self.size
        )

    def update_mem_delta(self, state):
        self.current_state = state
        if self.address_start is None:
            return

        load_cache = {}
        for begin, end in self.changes:
            for i in range(begin, end):
                if not state.mem.is_mapped(self.address_start + i):
                    val = "__"
                else:
                    if i in load_cache:
                        b = load_cache[i]
                    else:
                        b = state.mem.load(self.address_start + i, 1)
                        load_cache[i] = b
                    val = ".."
                    if isinstance(b, BVV):
                        val = "{:02x}".format(b.value)
                self.hexWidget.single_data_changed.emit(i, val)
        # self.hexWidget.view.viewport().update()
        self.changes.clear()

    def reset(self):
        self.tab_name = None
        self.current_state = None
        self.address_start = None
        self.size = None
        self.hexWidget.full_data_changed.emit(
            0, {}, 0
        )

    def _handle_data_edited(self, offset, value):
        if not self.current_state or not self.address_start:
            return

        self.current_state.mem.store(
            self.address_start + offset, BVV(value, 8))
        # self.hexWidget.single_data_changed.emit(address - self.address_start, hex(value)[2:])

    def _show_expression(self, address, expr):
        show_message_box("Expression at %s" %
                         hex(address), str(expr.z3obj.sexpr()))

    def _evaluate_with_solver(self, address, expr):
        val = ""
        if not self.current_state.solver.symbolic(expr):
            new_expr = self.current_state.solver.evaluate(expr)
            self.current_state.mem.store(address, new_expr)
            self.changes.add(
                (
                    address - self.address_start,
                    address-self.address_start+new_expr.size // 8
                )
            )
            self.update_mem_delta(self.current_state)
            show_message_box(
                "Expression at %s" % hex(address),
                "The value was indeed concrete! State modified"
            )
        else:
            val = self.current_state.solver.evaluate(expr).value
            show_message_box("Value at %s (with solver):" %
                             hex(address), hex(val))

    def _evaluate_upto_with_solver(self, address, expr):
        val = ""
        if not self.current_state.solver.symbolic(expr):
            new_expr = self.current_state.solver.evaluate(expr)
            self.current_state.mem.store(address, new_expr)
            self.changes.add(
                (
                    address - self.address_start,
                    address-self.address_start+new_expr.size // 8
                )
            )
            self.update_mem_delta(self.current_state)
            show_message_box(
                "Expression at %s" % hex(address),
                "The value was indeed concrete! State modified"
            )
        else:
            n_eval = get_int_input("How many values (upto) ?", "Number of distinct values")
            r = ""
            for i, v in enumerate(self.current_state.solver.evaluate_upto(expr, n_eval)):
                r += "solution %d: %s\n" % (i, hex(v.value))

            show_message_box("Value at %s (with solver):" %
                             hex(address), r)

    def _concretize(self, address, expr):
        new_expr = self.current_state.solver.evaluate(expr)
        self.current_state.mem.store(address, new_expr)
        self.current_state.solver.add_constraints(
            expr == new_expr
        )
        self.changes.add(
            (
                address - self.address_start,
                address - self.address_start+new_expr.size // 8
            )
        )
        self.update_mem_delta(self.current_state)

    def _concretize_ascii_str(self, address, expr):
        extra_constraints = []
        for i in range(expr.size // 8):
            b = expr.Extract(i*8+7, i*8)
            extra_constraints.extend(
                [b <= 0x7e, b >= 0x20]
            )
        if not self.current_state.solver.satisfiable(
            extra_constraints
        ):
            show_message_box(
                "Info", "The selected memory is not an ascii str (unsat)")
            return
        new_expr = self.current_state.solver.evaluate(
            expr, extra_constraints
        )
        self.current_state.mem.store(address, new_expr)
        self.current_state.solver.add_constraints(
            expr == new_expr
        )
        self.changes.add(
            (
                address - self.address_start,
                address - self.address_start+new_expr.size // 8
            )
        )
        self.update_mem_delta(self.current_state)

    def _make_symbolic(self, address, size):
        buff = BVS("b_ui_mem_%d" % self.symb_idx, size * 8)
        self.current_state.mem.store(address, buff)
        self.current_state.symbolic_buffers.append(
            (buff, address, "")
        )
        self.changes.add(
            (
                address - self.address_start,
                size
            )
        )
        self.symb_idx += 1
        self.update_mem_delta(self.current_state)
        self.bnwidgets.BW.onNewBufferSignal.emit(self.current_state)

    def _copy_big_endian(self, expr):
        mime = QMimeData()
        mime.setText(hex(expr.value))
        QApplication.clipboard().setMimeData(mime)

    def _copy_little_endian(self, expr):
        mime = QMimeData()
        expr_bytes = split_bv_in_list(expr, 8)
        res = 0
        i = 0
        for el in reversed(expr_bytes):
            res += el.value << i*8
            i += 1
        mime.setText(hex(res))
        QApplication.clipboard().setMimeData(mime)

    def _copy_string(self, expr):
        mime = QMimeData()
        expr_bytes = split_bv_in_list(expr, 8)
        res = ""
        for el in reversed(expr_bytes):
            res += chr(el.value) if el.value >= 32 and el.value <= 126 else "."

        mime.setText(res)
        QApplication.clipboard().setMimeData(mime)

    def _copy_expression(self, expr):
        mime = QMimeData()
        mime.setText(str(expr.z3obj.sexpr()))
        QApplication.clipboard().setMimeData(mime)

    def _copy_binary(self, expr):
        mime = QMimeData()
        expr_bytes = split_bv_in_list(expr, 8)
        res = "\""
        for el in reversed(expr_bytes):
            res += "\\x{:02x}".format(el.value)
        res += "\""

        mime.setText(res)
        QApplication.clipboard().setMimeData(mime)

    @staticmethod
    def _condom(f, *pars):
        def g():
            f(*pars)
        return g

    @staticmethod
    def _condom_async(mw, f, *pars):
        def g():
            bt = MemoryViewBT("MemoryView background task...", mw, f, pars)
            bt.start()
        return g

    def on_customContextMenuRequested(self, qpoint):
        if self.current_state is None:
            return
        menu = QMenu(self)

        sel_start = self.hexWidget._hsm.start
        sel_end = self.hexWidget._hsm.end
        if sel_start is None:
            return

        if not self.current_state.mem.is_mapped(
                self.address_start + sel_start):
            return
        if not self.current_state.mem.is_mapped(
                self.address_start + sel_end):
            return

        expr = self.current_state.mem.load(
            sel_start + self.address_start,
            sel_end - sel_start + 1
        )

        if symbolic(expr):
            a = menu.addAction("Show expression")
            a.triggered.connect(MemoryView._condom(
                self._show_expression, sel_start + self.address_start, expr))
            a = menu.addAction("Evaluate with solver")
            a.triggered.connect(MemoryView._condom_async(
                self, self._evaluate_with_solver, sel_start + self.address_start, expr))
            a = menu.addAction("Evaluate with solver (upto)")
            a.triggered.connect(MemoryView._condom_async(
                self, self._evaluate_upto_with_solver, sel_start + self.address_start, expr))
            a = menu.addAction("Concretize")
            a.triggered.connect(MemoryView._condom_async(
                self, self._concretize, sel_start + self.address_start, expr))
            a = menu.addAction("Concretize (ascii str)")
            a.triggered.connect(MemoryView._condom_async(
                self, self._concretize_ascii_str, sel_start + self.address_start, expr))
            a = menu.addAction("Copy expression")
            a.triggered.connect(MemoryView._condom(
                self._copy_expression, expr))
        else:
            a = menu.addAction("Make symbolic")
            a.triggered.connect(MemoryView._condom(
                self._make_symbolic, sel_start + self.address_start, sel_end - sel_start + 1))
            copy_menu = menu.addMenu("Copy...")
            a = copy_menu.addAction("Copy Little Endian")
            a.triggered.connect(MemoryView._condom(
                self._copy_little_endian, expr))
            a = copy_menu.addAction("Copy Big Endian")
            a.triggered.connect(MemoryView._condom(
                self._copy_big_endian, expr))
            a = copy_menu.addAction("Copy String")
            a.triggered.connect(MemoryView._condom(self._copy_string, expr))
            a = copy_menu.addAction("Copy Binary")
            a.triggered.connect(MemoryView._condom(self._copy_binary, expr))

        return menu

    def notifyOffsetChanged(self, offset):
        pass

    def shouldBeVisible(self, view_frame):
        if view_frame is None:
            return False
        elif self.tab_name is None:
            return False
        elif _normalize_tab_name(view_frame.getTabName()) != self.tab_name:
            return False
        return True

    def notifyViewChanged(self, view_frame):
        if view_frame is None:
            pass
        else:
            pass  # implement this

    def contextMenuEvent(self, event):
        self.m_contextMenuManager.show(self.m_menu, self.actionHandler)

```

`ui/registers_view.py`:

```py
from binaryninja.interaction import (
    show_message_box,
    get_int_input,
    get_choice_input
)
from binaryninjaui import (
    DockContextHandler,
    getMonospaceFont,
    UIActionHandler
)
from PySide6.QtCore import Qt, QMimeData
from PySide6.QtGui import QBrush, QColor
from PySide6.QtWidgets import (
    QApplication,
    QVBoxLayout,
    QWidget,
    QTableWidget,
    QTableWidgetItem,
    QMenu
)

from ..utility.expr_wrap_util import symbolic
from ..expr.bitvector import BVS, BVV


def _normalize_tab_name(tab_name):
    return tab_name[:tab_name.find("(")-1]


def _makewidget(parent, val, center=False):
    """ Small helper function that builds a TableWidgetItem and sets up the font the way we want"""
    out = QTableWidgetItem(str(val))
    out.setFlags(Qt.ItemIsEnabled)
    out.setFont(getMonospaceFont(parent))
    if center:
        out.setTextAlignment(Qt.AlignCenter)
    return out


class RegisterView(QWidget, DockContextHandler):

    dirty_color = QBrush(QColor(255, 153, 51))
    symbolic_color = QBrush(QColor(245, 66, 72))
    no_color = QBrush(QColor(255, 255, 255))

    def __init__(self, parent, name, data):
        QWidget.__init__(self, parent)
        DockContextHandler.__init__(self, self, name)

        self.parent = parent
        self.arch = None
        self.current_state = None
        self.symb_idx = 0
        self.reg_to_index = dict()
        self.index_to_reg = dict()
        self.reg_cache = dict()
        self.data = data
        self.tab_name = None

        self.actionHandler = UIActionHandler()
        self.actionHandler.setupActionHandler(self)

        self._layout = QVBoxLayout()

        # Set up register table
        self._table = QTableWidget()
        self._table.setColumnCount(2)
        self._table.setHorizontalHeaderLabels(['Register', 'Value'])
        self._table.horizontalHeader().setStretchLastSection(True)
        self._table.verticalHeader().setVisible(False)

        self._table.setContextMenuPolicy(Qt.CustomContextMenu)
        self._table.customContextMenuRequested.connect(
            self.on_customContextMenuRequested)
        self._table.doubleClicked.connect(self.on_doubleClick)

        self._layout.addWidget(self._table)

        self.setLayout(self._layout)

    def reset(self):
        self.tab_name = None
        self.arch = None
        self.reg_to_index = dict()
        self.symb_idx = 0
        self._table.setRowCount(0)

    def init(self, arch, state):
        self.arch = arch
        self.tab_name = _normalize_tab_name(self.parent.getTabName())

        regs = self.arch.reg_names()

        self._table.setRowCount(len(regs))
        for i, reg in enumerate(regs):
            self.reg_to_index[reg] = i
            self.index_to_reg[i] = reg
            self._table.setItem(i, 0, _makewidget(self, reg))
            self._table.setItem(i, 1, _makewidget(self, ""))

        self.set_reg_values(state)

    def set_reg_value(self, reg, value, color=None):
        assert self.arch is not None

        idx = self.reg_to_index[reg]

        if symbolic(value):
            if isinstance(value, BVS):
                val_str = value.name
            else:
                val_str = "< symbolic expression >"
                if color is None:
                    color = RegisterView.symbolic_color
        else:
            val_str = "0x{obj:0{width}x}".format(
                obj=value.value,
                width=(value.size+3) // 4
            )

        self.reg_cache[reg] = val_str
        table_item = self._table.item(idx, 1)
        table_item.setText(val_str)
        if color is not None:
            table_item.setForeground(color)
        else:
            table_item.setForeground(self.no_color)

    def set_reg_values(self, state):
        self.current_state = state
        for reg in self.reg_to_index:
            val = getattr(state.regs, reg)
            self.set_reg_value(reg, val)

    # right click menu
    def on_customContextMenuRequested(self, pos):
        item = self._table.itemAt(pos)
        if item is None:
            return
        row_idx = item.row()

        if self.index_to_reg[row_idx] == self.arch.getip_reg():
            return

        expr = getattr(self.current_state.regs, self.index_to_reg[row_idx])

        menu = QMenu()
        show_reg_expr = menu.addAction(
            "Show reg expression") if not isinstance(expr, BVV) else None
        make_reg_symb = menu.addAction(
            "Make reg symbolic") if isinstance(expr, BVV) else None
        set_reg_value = menu.addAction("Set reg value")
        eval_with_sol = menu.addAction(
            "Evaluate with solver") if not isinstance(expr, BVV) else None
        eval_upto_with_sol = menu.addAction(
            "Evaluate upto with solver") if not isinstance(expr, BVV) else None
        concretize = menu.addAction(
            "Concretize") if not isinstance(expr, BVV) else None
        copy = menu.addAction("Copy to clipboard") if not isinstance(
            expr, BVS) else None
        bind_to_buffer = menu.addAction("Bind to symbolic buffer")

        action = menu.exec_(self._table.viewport().mapToGlobal(pos))
        if action is None:
            return

        if action == bind_to_buffer:
            buffer_names = [
                b[0].name for b in self.current_state.symbolic_buffers]
            if len(buffer_names) == 0:
                return
            buff_id = get_choice_input(
                "Select a buffer", "choices", buffer_names)
            address = self.current_state.symbolic_buffers[buff_id][1]
            buff_p = BVV(address,
                         self.current_state.arch.bits())
            setattr(self.current_state.regs,
                    self.index_to_reg[row_idx],
                    buff_p)
            self.set_reg_value(
                self.index_to_reg[row_idx], buff_p, RegisterView.dirty_color)
        if action == show_reg_expr:
            show_message_box("Reg Expression", str(expr.z3obj.sexpr()))
        if action == make_reg_symb:
            new_expr = BVS('symb_injected_through_ui_%d' %
                           self.symb_idx, expr.size)
            setattr(self.current_state.regs,
                    self.index_to_reg[row_idx], new_expr)
            self.set_reg_value(
                self.index_to_reg[row_idx], new_expr, RegisterView.dirty_color)
            self.symb_idx += 1
        if action == set_reg_value:
            self.on_doubleClick(item)
        if action == eval_with_sol:
            expr = getattr(self.current_state.regs, self.index_to_reg[row_idx])
            if not self.current_state.solver.symbolic(expr):
                new_expr = self.current_state.solver.evaluate(expr)
                setattr(self.current_state.regs,
                        self.index_to_reg[row_idx], new_expr)
                self.set_reg_value(
                    self.index_to_reg[row_idx], new_expr, RegisterView.dirty_color)
                show_message_box(
                    "Reg Value (with solver)",
                    "The value was indeed concrete! State modified"
                )
            else:
                show_message_box(
                    "Reg Value (with solver)",
                    hex(self.current_state.solver.evaluate(expr).value)
                )
        if action == eval_upto_with_sol:
            expr = getattr(self.current_state.regs, self.index_to_reg[row_idx])
            if not self.current_state.solver.symbolic(expr):
                new_expr = self.current_state.solver.evaluate(expr)
                setattr(self.current_state.regs,
                        self.index_to_reg[row_idx], new_expr)
                self.set_reg_value(
                    self.index_to_reg[row_idx], new_expr, RegisterView.dirty_color)
                show_message_box(
                    "Reg Value (with solver)",
                    "The value was indeed concrete! State modified"
                )
            else:
                n_eval = get_int_input("How many values (upto) ?", "Number of distinct values")
                r = ""
                for i, v in enumerate(self.current_state.solver.evaluate_upto(expr, n_eval)):
                    r += "solution %d: %s\n" % (i, hex(v.value))
                show_message_box(
                    "Reg Value (with solver)",
                    r
                )
        if action == concretize:
            expr = getattr(self.current_state.regs, self.index_to_reg[row_idx])
            new_expr = self.current_state.solver.evaluate(expr)
            res = get_choice_input(
                "Concretize %s to %s?" % (
                    self.index_to_reg[row_idx], hex(new_expr.value)),
                "Concretize",
                ["Yes", "No"]
            )
            if res == 0:
                setattr(self.current_state.regs,
                        self.index_to_reg[row_idx], new_expr)
                self.current_state.solver.add_constraints(
                    expr == new_expr
                )
                self.set_reg_value(
                    self.index_to_reg[row_idx], new_expr, RegisterView.dirty_color)

        if action == copy:
            mime = QMimeData()
            if isinstance(expr, BVV):
                mime.setText(hex(expr.value))
            else:
                mime.setText(str(expr.z3obj.sexpr()))
            QApplication.clipboard().setMimeData(mime)

    # double click event
    def on_doubleClick(self, item):
        row_idx = item.row()
        if self.index_to_reg[row_idx] == self.arch.getip_reg():
            return

        old_expr = getattr(self.current_state.regs, self.index_to_reg[row_idx])
        new_val = get_int_input("value for %s" %
                                self.index_to_reg[row_idx], "Set Reg")
        if new_val is None:
            return
        new_expr = BVV(new_val, old_expr.size)
        setattr(self.current_state.regs, self.index_to_reg[row_idx], new_expr)
        self.set_reg_value(
            self.index_to_reg[row_idx], new_expr, RegisterView.dirty_color)

    def notifyOffsetChanged(self, offset):
        pass

    def shouldBeVisible(self, view_frame):
        if view_frame is None:
            return False
        elif self.tab_name is None:
            return False
        elif _normalize_tab_name(view_frame.getTabName()) != self.tab_name:
            return False
        return True

    def notifyViewChanged(self, view_frame):
        if view_frame is None:
            pass
        else:
            pass

    def contextMenuEvent(self, event):
        self.m_contextMenuManager.show(self.m_menu, self.actionHandler)

```

`utility/armv7_native_handlers_util.py`:

```py
from collections import namedtuple
import re

ArmV7Mnemonic = namedtuple("ArmV7Mnemonic",  ["mnemonic", "set_flag", "cond"])
ArmV7RotShift = namedtuple("ArmV7RotShift",  ["type", "size"])

conds = {
    'EQ', 'NE', 'GT', 'LT', 'GE', 'LE',
    'CS', 'CC', 'LO', 'MI', 'PL', 'AL',
    'NV', 'VS', 'VC', 'HI', 'LS'
}
shift_rot = {
    'ASR', 'LSL', 'LSR', 'ROR', 'RRX'
}
conds_regex = '|'.join(map(lambda x: x.lower(), conds))
shift_rot_regex = '|'.join(map(lambda x: x.lower(), shift_rot))


def parse_mnemonic(instr):
    regex_mnemonic = \
        r"^([a-z]+?)" + \
        r"(s?)" + \
        r"({conds_regex})?\b"  \
        .format(conds_regex=conds_regex)

    res = re.match(regex_mnemonic, instr)
    assert res is not None  # parse failed
    res = res.groups()

    return ArmV7Mnemonic(
        mnemonic=res[0],
        set_flag=res[1] != '',
        cond=res[2]
    )


def parse_rot_shift(par):
    regex_rot_shift = r"({shift_rot_regex})\s*\#(0x[0-9]+)".format(
        shift_rot_regex=shift_rot_regex
    )
    tokens = re.match(regex_rot_shift, par)
    assert tokens is not None  # parse failed
    tokens = tokens.groups()

    return ArmV7RotShift(
        type=tokens[0],
        size=int(tokens[1], 16) if tokens[1][:2] == '0x' else int(tokens[1])
    )


def parse_immediate(par):
    regex_imm = r"\#(0x[0-9]+)"
    tokens = re.match(regex_imm, par)
    assert tokens is not None  # parse failed
    tokens = tokens.groups()

    return int(tokens[0], 16) if tokens[0][:2] == '0x' else int(tokens[0])

```

`utility/binary_ninja_cache.py`:

```py
from binaryninja import Settings
from .bninja_util import (
    get_function
)


class BNCache(object):
    def __init__(self, bv):
        self.bv = bv
        self.addr_to_func_cache = dict()
        self.name_to_func_cache = dict()
        self.func_name_cache = dict()
        self.llil_cache = dict()
        self.llil_addr_cache = dict()
        self.addr_cache = dict()
        self.disasm_cache = dict()
        self.instruction_len_cache = dict()
        self.settings = dict()

    def reset(self):
        self.addr_to_func_cache = dict()
        self.name_to_func_cache = dict()
        self.func_name_cache = dict()
        self.llil_cache = dict()
        self.llil_addr_cache = dict()
        self.addr_cache = dict()
        self.disasm_cache = dict()
        self.instruction_len_cache = dict()
        self.settings = dict()

    def get_function(self, address):
        if address in self.addr_to_func_cache:
            return self.addr_to_func_cache[address]
        function = get_function(self.bv, address)
        self.addr_to_func_cache[address] = function
        return function

    def get_function_name(self, address):
        if address in self.func_name_cache:
            return self.func_name_cache[address]
        function = self.get_function(address)
        function_name = function.name
        self.func_name_cache[address] = function_name
        self.name_to_func_cache[function_name] = function
        return function_name

    def get_llil(self, func_name, llil_addr):
        if (func_name, llil_addr) in self.llil_cache:
            return self.llil_cache[
                (func_name, llil_addr)
            ]
        func = self.name_to_func_cache[func_name]
        expr = func.llil[llil_addr]
        self.llil_cache[
            (func_name, llil_addr)
        ] = expr
        return expr

    def get_llil_address(self, func_name, address):
        if (func_name, address) in self.llil_addr_cache:
            return self.llil_addr_cache[
                (func_name, address)
            ]
        func = self.name_to_func_cache[func_name]
        llil_addr = func.llil.get_instruction_start(address, func.arch)
        self.llil_addr_cache[
            (func_name, address)
        ] = llil_addr
        return llil_addr

    def get_address(self, func_name, llil_addr):
        if (func_name, llil_addr) in self.addr_cache:
            return self.addr_cache[
                (func_name, llil_addr)
            ]
        addr = self.get_llil(func_name, llil_addr).address
        self.addr_cache[
            (func_name, llil_addr)
        ] = addr
        return addr

    def get_disasm(self, address):
        if address in self.disasm_cache:
            return self.disasm_cache[address]
        func = self.get_function(address)
        disasm = self.bv.get_disassembly(address, func.arch)
        self.disasm_cache[address] = disasm
        return disasm

    def get_instruction_len(self, address):
        if address in self.instruction_len_cache:
            return self.instruction_len_cache[address]

        ret_len = self.bv.get_instruction_length(address)
        self.instruction_len_cache[address] = ret_len
        return ret_len

    def get_setting(self, name: str):
        if name in self.settings:
            return self.settings[name]

        val = Settings().get_string("seninja." + name)
        self.settings[name] = val
        return val

```

`utility/bninja_util.py`:

```py
from binaryninja import SymbolType
from .exceptions import UnsupportedOs
from ..os_models.linux import Linuxi386, Linuxia64, LinuxArmV7
from ..os_models.windows import Windows


def get_function(view, address):
    funcs = view.get_functions_at(address)
    if len(funcs) == 0:
        address = view.get_previous_function_start_before(address)
        funcs = view.get_functions_at(address)

    if len(funcs) > 1:
        print("WARNING: more than one function at {addr:x}".format(
            addr=address
        ))

    return funcs[0]


def get_imported_functions_and_addresses(view):
    res_functions = dict()
    res_addresses = dict()

    symbols = view.symbols
    for name in symbols:
        symb_types = symbols[name]
        if not isinstance(symb_types, list):
            symb_types = [symb_types]

        for symb_type in symb_types:
            if symb_type.type == SymbolType.ImportedFunctionSymbol:
                res_functions[symb_type.address] = symb_type.name
            if symb_type.type == SymbolType.ImportAddressSymbol:
                res_addresses[symb_type.address] = symb_type.name

                if "@IAT" in symb_type.name or "@GOT" in symb_type.name:
                    addr = int.from_bytes(
                        view.read(symb_type.address, view.arch.address_size),
                        'little' if view.arch.endianness.name == 'LittleEndian' else 'big'
                    )
                    res_functions[addr] = symb_type.name.replace(
                        "@IAT" if "@IAT" in symb_type.name else "@GOT", "")

    return res_functions, res_addresses


def get_addr_next_inst(view, addr):
    return addr + view.get_instruction_length(addr)


def parse_disasm_str(disasm_str):
    inst_name = disasm_str.split(" ")[0]
    parameters = ''.join(disasm_str.split(" ")[1:]).split(",")
    return inst_name, parameters


def get_address_after_merge(view, address):
    func = get_function(view, address)
    llil = func.llil.get_instruction_start(address, func.arch)
    return func.llil[llil].address


def find_os(view):
    platform_name = view.platform.name

    if platform_name == 'linux-x86_64':
        return Linuxia64()
    elif platform_name == 'linux-x86':
        return Linuxi386()
    elif platform_name == 'linux-armv7':
        return LinuxArmV7()
    elif platform_name == 'windows-x86':
        return Windows()
    elif platform_name == 'windows-x86_64':
        return Windows()

    raise UnsupportedOs(platform_name)

```

`utility/exceptions.py`:

```py
# ERRORS
class SENinjaError(Exception):
    def __init__(self, msg):
        self.message = msg
        super().__init__(msg)

    def is_fatal(self):
        raise NotImplementedError  # override


class DivByZero(SENinjaError):
    def __init__(self, pc):
        self.pc = pc
        self.message = "division by zero occurred at 0x%x" % pc
        super().__init__(self.message)

    def is_fatal(self):
        return False


class UnmappedRead(SENinjaError):
    def __init__(self, pc):
        self.pc = pc
        self.message = "unmapped read at 0x%x" % pc
        super().__init__(self.message)

    def is_fatal(self):
        return False


class UnmappedWrite(SENinjaError):
    def __init__(self, pc):
        self.pc = pc
        self.message = "unmapped write at 0x%x" % pc
        super().__init__(self.message)

    def is_fatal(self):
        return False


class NoDestination(SENinjaError):
    def __init__(self):
        self.message = "no destination"
        super().__init__(self.message)

    def is_fatal(self):
        return False


class UnconstrainedIp(SENinjaError):
    def __init__(self):
        self.message = "unconstrained ip"
        super().__init__(self.message)

    def is_fatal(self):
        return False


class UnsatState(SENinjaError):
    def __init__(self, pc):
        self.pc = pc
        self.message = "UNSAT state at 0x%x"
        super().__init__(self.message)

    def is_fatal(self):
        return True


class ModelError(SENinjaError):
    def __init__(self, model_name, msg):
        self.model_name = model_name
        self.message = "%s: %s" % (model_name, msg)
        super().__init__(self.message)

    def is_fatal(self):
        return True


class UnimplementedInstruction(SENinjaError):
    def __init__(self, instr_name, ip):
        self.instr_name = instr_name
        self.message = "%s instruction is unimplemented @ %#x" % (instr_name, ip)
        super().__init__(self.message)

    def is_fatal(self):
        return True


class UnimplementedModel(SENinjaError):
    def __init__(self, f_name):
        self.f_name = f_name
        self.message = "unimplemented model for function %s" % f_name
        super().__init__(self.message)

    def is_fatal(self):
        return True


class UnimplementedSyscall(SENinjaError):
    def __init__(self, syscall_n):
        self.syscall_n = syscall_n
        self.message = "unimplemented syscall %d" % syscall_n
        super().__init__(self.message)

    def is_fatal(self):
        return True


class UnsupportedOs(SENinjaError):
    def __init__(self, platform_name):
        self.platform_name = platform_name
        self.message = "unsupported os %s" % platform_name
        super().__init__(self.message)

    def is_fatal(self):
        return True


class UnsupportedArch(SENinjaError):
    def __init__(self, arch_name):
        self.arch_name = arch_name
        self.message = "unsupported arch %s" % arch_name
        super().__init__(self.message)

    def is_fatal(self):
        return True
# *****


class SENinjaExeption(Exception):
    pass


class ExitException(SENinjaExeption):
    pass

```

`utility/expr_wrap_util.py`:

```py
from ..expr import BV, BVV
import z3

MIN_BASE = 0x10000


def split_bv_in_list(bv: BV, size: int) -> list:
    assert size % 8 == 0
    res = []
    for i in range(0, bv.size, size):
        b = bv.Extract(i+size-1, i)
        res.append(b)
    return res


def bvv_from_bytes(val: bytes):  # DONT USE IT TO CREATE LONG BV!!
    res = None
    for c in val:
        v = BVV(c, 8)
        res = res.Concat(v) if res is not None else v
    return res


def split_bv(bv: BV, split_index: int):
    return (
        bv.Extract(bv.size - 1, split_index),  # most significant
        bv.Extract(split_index - 1, 0)         # least significant
    )


def symbolic(val: BV) -> bool:
    return not isinstance(val, BVV)


def heuristic_find_base(val: BV):  # this can be brough inside BVExpr
    z3val = val.z3obj
    fringe = z3val.children()
    while fringe:
        el = fringe.pop()
        if (
            not (z3.simplify(z3val).decl().kind() != z3.Z3_OP_BNUM) and
            el.value > MIN_BASE
        ):
            return el.value
        fringe.extend(el.children())
    return -1

```

`utility/models_util.py`:

```py
from ..arch.arch_x86 import x86Arch
from .expr_wrap_util import symbolic
from .bninja_util import get_function


def get_arg_k(state, k, size, view):

    ip = state.get_ip()
    func = get_function(view, ip)
    calling_convention = func.calling_convention.name

    args = state.arch.get_argument_regs(calling_convention)
    if k-1 < len(args):
        res = getattr(state.regs, args[k-1])
        return res.Extract(8*size-1, 0)
    else:
        stack_pointer = getattr(state.regs, state.arch.get_stack_pointer_reg())
        assert not symbolic(stack_pointer)

        return state.mem.load(stack_pointer + (state.arch.bits() // 8)*k, size, state.arch.endness())

```

`utility/string_util.py`:

```py
from ..expr import BV, BVV, And, Or
from .expr_wrap_util import split_bv_in_list


def str_to_int(s):
    res = ""
    for c in s:
        res += hex(ord(c))[2:]
    res += "00"
    return int(res, 16)


def str_to_bv_list(s, terminator=False):
    res = list()
    for c in s:
        res.append(BVV(ord(c), 8))
    if terminator:
        res += [BVV(0, 8)]
    return res


def str_to_bv(s, terminator=False):
    if len(s) == 0:
        return None

    res = BVV(ord(s[0]), 8)
    for c in s[1:]:
        res = res.Concat(BVV(ord(c), 8))
    if terminator:
        res = res.Concat(BVV(0, 8))
    return res


def int_to_str(i):
    s = hex(i)[2:]
    res = ""
    for i in range(0, len(s), 2):
        res += chr(int(s[i] + s[i+1], 16))
    return res


def as_bytes(bv: BV):
    for i in range(bv.size, 0, -8):
        yield bv.Extract(i-1, i-8)


def get_byte(bv: BV, i: int):
    return bv.Extract(bv.size-i*8-1, bv.size-i*8-8)


def constraint_alphanumeric_string(bv, state):
    for bv in split_bv_in_list(bv, 8):
        state.solver.add_constraints(
            Or(
                And(bv >= ord("a"), bv <= ord("z")),
                And(bv >= ord("A"), bv <= ord("Z")),
                And(bv >= ord("0"), bv <= ord("9"))
            )
        )


def constraint_ascii_string(bv, state):
    for bv in split_bv_in_list(bv, 8):
        state.solver.add_constraints(
            bv >= 0x20, bv <= 0x7E
        )

```

`utility/x86_native_handlers_util.py`:

```py
from ..expr import BVV

_size_dict = {
    "byte":     1,
    "word":     2,
    "dword":    4,
    "qword":    8,
    "xmmword": 16,
    "ymmword": 32,
    "zmmword": 64
}


def __is_hex(v):
    try:
        int(v, 16)
        return True
    except:
        return False


# hackish way of parsing a mem address. bad, bad, bad code
def __find_address_mem(state, parameter):
    assert "[" in parameter and "]" in parameter

    size = parameter[:parameter.find("[")]
    size = size.replace(" ", "")
    size = _size_dict[size]

    parameter = parameter.replace("rel", "")
    parameter = parameter[parameter.find("[")+1:]
    parameter = parameter[:parameter.find("]")]

    res = None
    was_add = False
    if "+" in parameter:
        parameter = parameter.split("+")
        was_add = True
    else:
        parameter = parameter.split("-")
        was_add = False
    for sub in parameter[::-1]:

        m_res = None
        m_subs = sub.split("*")
        for m_sub in m_subs:
            if state.regs.has_reg(m_sub):
                v = getattr(state.regs, m_sub)
                m_res = v if m_res is None else (m_res * v)
            elif __is_hex(m_sub):
                v = BVV(int(m_sub, 16), state.arch.bits())
                m_res = v if m_res is None else (m_res * v)
            else:
                raise Exception("Unknown subexpression")

        if was_add:
            res = m_res if res is None else (res + m_res)
        else:
            res = m_res if res is None else (m_res - res)

    return res, size


def get_src(state, parameter: str):
    if state.regs.has_reg(parameter):
        res = getattr(state.regs, parameter)
        return res

    addr, size = __find_address_mem(state, parameter)
    return state.mem.load(addr, size, state.arch.endness())


def store_to_dst(state, parameter: str, value):
    if state.regs.has_reg(parameter):
        setattr(state.regs, parameter, value)
        return

    assert "[" in parameter and "]" in parameter

    addr, _ = __find_address_mem(state, parameter)
    return state.mem.store(addr, value, state.arch.endness())

```

`utility/z3_wrap_util.py`:

```py
import z3

MIN_BASE = 0x10000


def bvs(name: str, size: int):
    return z3.BitVec(name, size)


def bvv(val: int, size: int):
    return z3.BitVecVal(val, size)


def split_bv_in_list(bv: z3.BitVecRef, size: int) -> list:
    assert size % 8 == 0
    res = []
    for i in range(0, bv.size, size):
        b = z3.simplify(z3.Extract(i+size-1, i, bv))
        res.append(b)
    return res


def bvv_from_bytes(val: bytes):  # DONT USE IT TO CREATE LONG BV!!
    res = None
    for c in val:
        v = z3.BitVecVal(c, 8)
        res = z3.Concat(res, v) if res is not None else v
    return res


def split_bv(bv: z3.BitVecRef, split_index: int):
    return (
        # most significant
        z3.simplify(z3.Extract(bv.size - 1, split_index, bv)),
        z3.simplify(z3.Extract(split_index - 1, 0, bv)
                    )         # least significant
    )


def symbolic(val: z3.BitVecRef) -> bool:
    return z3.simplify(val).decl().kind() != z3.Z3_OP_BNUM


def bvv_to_long(val: z3.BitVecRef):
    assert not symbolic(val)
    return z3.simplify(val).value


def heuristic_find_base(val: z3.BitVecRef):
    fringe = val.children()
    while fringe:
        el = fringe.pop()
        if not symbolic(el) and el.value > MIN_BASE:
            return el.value
        fringe.extend(el.children())
    return -1

```