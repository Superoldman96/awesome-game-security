Project Path: arc_gmh5225_UnSign_5cutbdx9

Source Tree:

```txt
arc_gmh5225_UnSign_5cutbdx9
├── Documents
│   ├── file signature before and after.png
│   ├── screenshot 001.png
│   └── screenshot 002.png
├── EULA.txt
├── README.md
├── unsign-exe-IA-32
├── unsign-exe-x86-64
├── unsign-obj-IA-32
├── unsign-obj-x86-64
├── unsign-src
│   ├── CommandLineInterface.c
│   ├── CommandLineInterface.h
│   ├── GlobalOptions.h
│   ├── LanguageRes.c
│   ├── LanguageRes.h
│   ├── Main.c
│   ├── Main.h
│   ├── SharedHeaders.h
│   ├── resource.h
│   ├── resource.rc
│   ├── unsign.vcxproj
│   ├── unsign.vcxproj.filters
│   └── unsign.vcxproj.user
├── unsign-test
└── unsign.sln

```

`EULA.txt`:

```txt
Copyright SV Foster, 2023-2024.
All rights reserved.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Redistribution and use in source and/or binary forms of the program, without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the disclaimer above.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the disclaimer above in the
   documentation and/or other materials provided with the distribution.
3. Source code, binary form of the program, documentation and/or other
   materials provided with the distribution of the program are used for
   personal, educational and/or non-profit usage.

```

`README.md`:

```md
# PE/COFF executable unsigning tool

Revolutionary command line tool for Windows that is set to change the way developers work with PE/COFF executable files like .exe, .dll, .sys, .drv and others. With the ability to completely remove embedded signatures, including all sections of the signature, this program allows for uncompromised control over the signing process!

![Screenshot](Documents/file%20signature%20before%20and%20after.png)

No longer will developers be limited by pesky embedded signatures that are difficult to remove. UnSign tool gives users the power to easily and effectively strip away all traces of a signature, leaving behind a clean and pristine executable file, library or driver.

But that's not all — UnSign tool also offers a solution to the frustrating PE header problem that has plagued developers for years. This problem often renders a PE/COFF executable file unsingable, leaving developers scratching their heads and searching for a solution. With UnSign tool, this issue becomes a thing of the past, as it provides a comprehensive fix for the problem, ensuring that executable files can be signed again without any hiccups.

Say goodbye to the limitations and frustrations that come with PE/COFF executable files signatures. UnSign tool takes the power back into the hands of developers, allowing for seamless and hassle-free unsigning processes. Whether you're a seasoned developer or just getting started, UnSign tool is a must-have tool for anyone working with PE/COFF executable files.


## Usage

UnSign is the command line tool. Open command prompt, navigate to UnSign folder with the `cd` command and start the tool with following parameters:

```
unsign /<switch 1> /<switch N> <PE/COFF executable file>

<Switches>
  /NoLogo       Don't print copyright logo
  /NoCertPrint  Don't exam and print certificates on the file
```	  

WARNING: This program will modify the file inplace on the disk. Please create a backup copy if you want to preserve the original file!

Any version of the tool, 32 or 64 bit, works with both 32 and 64 bit executables (in PE32 and PE32+ Optional Header format).

![Screenshot](Documents/screenshot%20001.png)
![Screenshot](Documents/screenshot%20002.png)


## What's new

### Version 1.1

* Added check for the number of directories in the PE/PE+ header, like documentation suggests


## Building

UnSign tool uses the `Microsoft Visual Studio 2022` for its builds.

To build UnSign tool from source files with Microsoft Visual Studio, you can use either the graphical or the command-line mode. Here are the instructions for both methods:

### Graphical mode
1. Open Microsoft Visual Studio and select `Open a project or solution` from the start page or the `File` menu
2. Browse to the folder where the `unsign.sln` file is located and select it. This will load the project in Microsoft Visual Studio
3. Select the `configuration` and `platform` for the project by using the drop-down menus on the toolbar. For example, you can choose Debug or Release for the configuration, and x86 or x64 for the platform
4. Build the project by clicking on the `Build` menu and selecting `Build Solution`. You can also use the keyboard shortcut `Ctrl+Shift+B`
5. Run the project by clicking on the `Debug` menu and selecting `Start Debugging`. You can also use the keyboard shortcut `F5`

### Command-line mode
1. Open a `Developer Command Prompt` for Microsoft Visual Studio. You can find it in the Start menu under Microsoft Visual Studio Tools
2. Navigate to the folder where the `unsign.sln` file is located by using the `cd` command
3. Invoke the MSBuild tool to build the project. You can specify various options and flags for the tool. For example, the following command builds the project with the Release configuration and the x64 platform:
```
msbuild unsign.sln /p:Configuration=Release /p:Platform=x64
```
4. Run your executable by typing its name and path in the command prompt. For example:
```
unsign-exe-x86-64\unsign /?
```


## Authors

This program was written and is maintained by SV Foster.


## License

This program is available under EULA, see [EULA text file](EULA.txt) for the complete text of the license. This program is free for personal, educational and/or non-profit usage.

```

`unsign-src/CommandLineInterface.c`:

```c
/***

Copyright SV Foster, 2023-2024. All rights reserved.

License:
    This program is free for personal, educational and/or non-profit usage    

Revision History:
	Rev 0, DEC 2023
	   First revision

	Rev 1, MAR 2024
	   Code refactoring

***/

#include <Windows.h>
#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include <tchar.h>
#include "SharedHeaders.h"
#include "resource.h"
#include "GlobalOptions.h"
#include "LanguageRes.h"
#include "CommandLineInterface.h"

#pragma comment(lib, "Version.lib")

#pragma warning( disable : 6255 )


VOID CLIWorkModeGet(CONST DWORD argc, LPCTSTR argv[], PGlobalOptions glo)
{
	glo->OperatingMode = OperatingModeHelp;

	if (argc <= 1)
	{
		return;
	}

	for (DWORD i = 1; i < argc; ++i)
	{
		if (_tcsicmp(argv[i], TEXT("/help")) == 0)
		{
			return;
		}

		if (_tcsicmp(argv[i], TEXT("/?")) == 0)
		{
			return;
		}
	}

	glo->OperatingMode = OperatingModeUnsigh;
}

BOOL CLISwitchesGet(CONST DWORD argc, LPCTSTR argv[], PGlobalOptions glo)
{
	for (DWORD i = 1; i < argc; ++i)
	{
		if (_tcsicmp(argv[i], TEXT("/NoLogo")) == 0)
		{
			glo->NoCopyrightLogo = TRUE;
			continue;
		}

		if (_tcsicmp(argv[i], TEXT("/NoCertPrint")) == 0)
		{
			glo->DontPrintCerificates = TRUE;
			continue;
		}

		if (argv[i][0] == TEXT('/'))
		{
			CLILogoPrint();
			_tprintf_s(LangGet(UIMSG_121_ERR_PARAMS_BAD_SW), argv[i]);
			return FALSE;
		}
	}

	return TRUE;
}

BOOL CLIPathsGet(CONST DWORD argc, LPCTSTR argv[], PGlobalOptions glo)
{
	for (DWORD i = 1; i < argc; ++i)
	{		
		if (argv[i][0] == TEXT('/'))
		{
			continue;
		}

		if (glo->PEFileName == NULL)
		{
			glo->PEFileName = (LPTSTR)argv[i];
			continue;
		}

		CLILogoPrint();
		_tprintf_s(LangGet(UIMSG_119_ERR_PARAMS_TOO_MANY_AGRS), argv[i]);
		return FALSE;
	}

	return TRUE;
}

VOID CLILogoPrint()
{
	TCHAR FileName[MAX_PATH + 1];
	DWORD FileNameSize;
	DWORD Handle;
	DWORD FileVersionInfoSize;
	LPVOID BufferData;
	UINT len;
	LPVOID CopyrightString;
	LPVOID ProductNameString;
	LPVOID versionInfo;
	VS_FIXEDFILEINFO* fileInfo;


	FileNameSize = GetModuleFileName(NULL, (LPTSTR)&FileName, MAX_PATH);
	if (!FileNameSize)
		return;
	if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
		return;
	FileName[FileNameSize] = TEXT('\0');

	FileVersionInfoSize = GetFileVersionInfoSize((LPTSTR)&FileName, &Handle);
	if (!FileVersionInfoSize)
		return;

	BufferData = _alloca(FileVersionInfoSize);

	if (!GetFileVersionInfo((LPTSTR)&FileName, 0, FileVersionInfoSize, BufferData))
		return;

	if (!VerQueryValue(BufferData, TEXT("\\"), &versionInfo, &len))
		return;

	fileInfo = (VS_FIXEDFILEINFO*)versionInfo;
	if (fileInfo->dwSignature != 0xfeef04bd)
		return;

	if (!VerQueryValue(BufferData, TEXT("\\StringFileInfo\\040904B0\\FileDescription"), &ProductNameString, &len))
		return;

	if (!VerQueryValue(BufferData, TEXT("\\StringFileInfo\\040904B0\\LegalCopyright"), &CopyrightString, &len))
		return;

	_tprintf_s(LangGet(UIMSG_118_LOGO_TEXT),
		ProductNameString,
		HIWORD(fileInfo->dwProductVersionMS),
		LOWORD(fileInfo->dwProductVersionMS),
		ArchString,
		CopyrightString
	);
}

VOID CLIHelpPrint()
{
	_tprintf_s(LangGet(UIMSG_117_HELP_TEXT));
}

VOID CLIWriteLN()
{
	_tprintf_s(TEXT("\n"));
}

BOOL CLISetModeUTF16()
{
	if (_setmode(_fileno(stdout), _O_U16TEXT) == -1)
		return FALSE;

	if (_setmode(_fileno(stdin), _O_U16TEXT) == -1)
		return FALSE;

	if (_setmode(_fileno(stderr), _O_U16TEXT) == -1)
		return FALSE;

	return TRUE;
}

```

`unsign-src/CommandLineInterface.h`:

```h
/***

Copyright SV Foster, 2023. All rights reserved.

License:
    This program is free for personal, educational and/or non-profit usage    

Revision History:
	See CommandLineInterface.c for details

***/

#pragma once


// File were processed without error
#define ExitCodeOK 0
// No file was found to process
#define ExitCodeErrorNoFiles 1
// File is not signed
#define ExitCodeErrorNotSigned 2
// Initialization error occurred. There is not enough memory or disk space, or you entered 
// an invalid file name or invalid syntax on the command line
#define ExitCodeErrorInit 4
//	File read/write error occurred or file has corrupted or incompatible format
#define ExitCodeErrorIO 5

#if defined(ENV64BIT)
	#define ArchString TEXT("x64 (x86-64)")
#elif defined (ENV32BIT)
	#define ArchString TEXT("x86 (IA-32)")
#else
	#error "Must define either ENV32BIT or ENV64BIT"
#endif


VOID  CLIWorkModeGet(CONST DWORD argc, LPCTSTR argv[], PGlobalOptions glo);
BOOL  CLISwitchesGet(CONST DWORD argc, LPCTSTR argv[], PGlobalOptions glo);
BOOL  CLIPathsGet(CONST DWORD argc, LPCTSTR argv[], PGlobalOptions glo);
VOID  CLILogoPrint();
VOID  CLIHelpPrint();
VOID  CLIWriteLN();
BOOL  CLISetModeUTF16();

```

`unsign-src/GlobalOptions.h`:

```h
/***

Copyright SV Foster, 2023. All rights reserved.

License:
    This program is free for personal, educational and/or non-profit usage    

Revision History:
	Rev 0, DEC 2023
	   First revision

***/

#pragma once


typedef enum _OperatingMode
{
	OperatingModeHelp,
	OperatingModeUnsigh
} TOperatingMode;

typedef struct _GlobalOptions
{
	TOperatingMode OperatingMode;	
	LPTSTR PEFileName;
	BOOL DontPrintCerificates;
	BOOL NoCopyrightLogo;
} TGlobalOptions, *PGlobalOptions;

```

`unsign-src/LanguageRes.c`:

```c
/***

Copyright SV Foster, 2023. All rights reserved.

License:
    This program is free for personal, educational and/or non-profit usage    

Revision History:
	Rev 0, DEC 2023
	   First revision

***/

#include <Windows.h>
#include "LanguageRes.h"


static CONST TCHAR MessageErrorNoString[] = LanguageResErrorNoString;

LPCTSTR LangGet(CONST UINT uID)
{
	LPCTSTR Result;
	int Length;

	Length = LoadString(GetModuleHandle(NULL), uID, (LPTSTR)&Result, 0);
	if (!Length)
		return (LPCTSTR)&MessageErrorNoString;

	return Result;
}

```

`unsign-src/LanguageRes.h`:

```h
/***

Copyright SV Foster, 2023. All rights reserved.

License:
    This program is free for personal, educational and/or non-profit usage    

Revision History:
	See LanguageRes.c for details

***/

#pragma once

#define LanguageResErrorNoString TEXT("<<I AM ERROR>>")


LPCTSTR LangGet(CONST UINT uID);

```

`unsign-src/Main.c`:

```c
/***

Copyright SV Foster, 2023-2024. All rights reserved.

License:
    This program is free for personal, educational and/or non-profit usage    

Revision History:
	Rev 0, DEC 2023
	   First revision

	Rev 1, MAR 2024
	   Added check for the number of directories in the PE/PE+ header, like documentation suggests
	   Code refactoring

***/

#include <Windows.h>
#include <ImageHlp.h>
#include <stdio.h>
#include <tchar.h>
#include "SharedHeaders.h"
#include "resource.h"
#include "GlobalOptions.h"
#include "LanguageRes.h"
#include "CommandLineInterface.h"
#include "Main.h"

#pragma comment(lib, "Imagehlp.lib")
#pragma comment(lib, "Crypt32.lib")

#pragma warning( disable : 6255 )


DWORD _tmain(DWORD argc, LPCTSTR argv[], LPCTSTR envp[])
{
	TGlobalOptions GlobalOptions = { 0 };


	CLISetModeUTF16();
	SetErrorMode(SEM_FAILCRITICALERRORS); // Don't popup on floppy query and etc.
	CLIWriteLN();

	// set options
	CLIWorkModeGet(argc, argv, &GlobalOptions);
	if (GlobalOptions.OperatingMode == OperatingModeHelp)
		return ModeHelp();
	if (!CLISwitchesGet(argc, argv, &GlobalOptions))
		return ExitCodeErrorInit;
	if (!CLIPathsGet(argc, argv, &GlobalOptions))
		return ExitCodeErrorInit;

	if (!GlobalOptions.NoCopyrightLogo)
		CLILogoPrint();
	_tprintf_s(LangGet(UIMSG_101_PROCESSINGFILE), GlobalOptions.PEFileName);

	return ModeUnsigh(&GlobalOptions);
}

DWORD ModeHelp()
{
	CLILogoPrint();
	CLIHelpPrint();

	return ExitCodeOK;
}

DWORD ModeUnsigh(PGlobalOptions GlobalOptions)
{
	DWORD Result = ExitCodeOK;
	HANDLE hFile;
	DWORD CertificateCount;
	PDWORD Indices = NULL;
	DWORD LastError;


	// open the file
	hFile = CreateFile(GlobalOptions->PEFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		_tprintf_s(LangGet(UIMSG_102_CANT_OPEN_FILE), GetLastError());
		return ExitCodeErrorNoFiles;
	}

	// get all ACEs and check for curruption at the same time
	// ACE = attribute certificate entry
	if (!ACEsFind(hFile, &CertificateCount, &Indices, &LastError))
		if (LastError == ERROR_INVALID_PARAMETER)
		{
			// PE file is corrupted
			_tprintf_s(LangGet(UIMSG_103_FILE_CORRUPTED));

			// apply fix
			if (!DirectoryEntrySecZero(hFile))
				ExitFunction(ExitCodeErrorIO);

			_tprintf_s(LangGet(UIMSG_104_APP_SUCCESS));
			ExitFunction(ExitCodeOK);
		}
		else
			ExitFunction(ExitCodeErrorIO);

	if (!CertificateCount)
	{
		// no sign found
		_tprintf_s(LangGet(UIMSG_105_PE_NOT_SIGNED));
		ExitFunction(ExitCodeErrorNotSigned);
	}
	_tprintf_s(LangGet(UIMSG_116_FOUND_IMAGECERTS_CNT), CertificateCount);

	// print certs to the console
	if (!GlobalOptions->DontPrintCerificates)
		if (!ImageCertificatesPrintAll(hFile, CertificateCount, Indices))
			_tprintf_s(LangGet(UIMSG_120_ERR_ENUM_CERTS));

	// remove all
	if (!ACEsRemoveAll(hFile, CertificateCount, Indices))
		ExitFunction(ExitCodeErrorIO);

	_tprintf_s(LangGet(UIMSG_104_APP_SUCCESS));


function_end:
	free(Indices);

	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	if (Result != ExitCodeOK)
		_tprintf_s(LangGet(UIMSG_106_APP_ERROR));

	return Result;
}

BOOL ACEsFind(CONST HANDLE hFile, PDWORD PCertificateCount, PDWORD* Indices, PDWORD LastError)
{
	*LastError = 0;

	if (!ImageEnumerateCertificates(hFile, CERT_SECTION_TYPE_ANY, PCertificateCount, NULL, 0))
	{
		*LastError = GetLastError();
		return FALSE;
	}

	if (!*PCertificateCount)
		return TRUE;

	*Indices = malloc(*PCertificateCount * sizeof(DWORD));
	if (!*Indices)
		return FALSE;

	if (!ImageEnumerateCertificates(hFile, CERT_SECTION_TYPE_ANY, PCertificateCount, *Indices, *PCertificateCount))
		return FALSE;

	return TRUE;
}

BOOL ImageCertificatesPrintAll(CONST HANDLE hFile, CONST DWORD CertificateCount, PDWORD Indices)
{
	DWORD Result = TRUE;
	LPWIN_CERTIFICATE PCertificate = NULL;
	DWORD RequiredLength = 0;
	CRYPT_DATA_BLOB p7Data;


	for (SIZE_T i = 0; i < CertificateCount; ++i)
	{
#pragma warning( push )
#pragma warning( disable : 6387 )
		ImageGetCertificateData(hFile, Indices[i], NULL, &RequiredLength);
		if (!RequiredLength)
			ExitFunction(FALSE);
#pragma warning( pop )

		PCertificate = malloc(RequiredLength);
		if (!PCertificate)
			ExitFunction(FALSE);

		if (!ImageGetCertificateData(hFile, Indices[i], PCertificate, &RequiredLength))
			ExitFunction(FALSE);

		p7Data.cbData = PCertificate->dwLength - sizeof(DWORD) - sizeof(WORD) - sizeof(WORD);
		p7Data.pbData = PCertificate->bCertificate;

		if (!StoreCertificatesPrintAll(Indices[i], p7Data))
			ExitFunction(FALSE);
	}


function_end:
	free(PCertificate);

	return Result;
}

BOOL StoreCertificatesPrintAll(CONST DWORD Index, CONST CRYPT_DATA_BLOB p7Data)
{
	HCERTSTORE CertStore;	
	CHAR signingOID[] = szOID_PKIX_KP_CODE_SIGNING;
	CERT_ENHKEY_USAGE keyUsage;
	keyUsage.cUsageIdentifier = 1;
	keyUsage.rgpszUsageIdentifier = _alloca(sizeof(LPSTR));
	keyUsage.rgpszUsageIdentifier[0] = &signingOID[0];	
	PCCERT_CONTEXT certContext = NULL;	
	int CertCount = 0;


	_tprintf_s(LangGet(UIMSG_107_EXAM_CERTSTORE), Index);
	CertStore = CertOpenStore(CERT_STORE_PROV_PKCS7, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0, 0, &p7Data);
	if (!CertStore)
		return FALSE;

	do
	{
		certContext = CertFindCertificateInStore
		(
			CertStore,
			X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
			CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
			CERT_FIND_ENHKEY_USAGE,
			&keyUsage,
			certContext
		);

		if (certContext)
		{			
			CertificatePrintSingle(CertCount, certContext);
			CertCount++;
		}
	} while (certContext);
	// only non-NULL CERT_CONTEXT that CertFindCertificateInStore() returns must be freed by CertFreeCertificateContext()

	if (CertCount == 0)
		_tprintf_s(LangGet(UIMSG_108_NO_CODESIGN));
	CLIWriteLN();
	
	CertCloseStore(CertStore, CERT_CLOSE_STORE_FORCE_FLAG);

	return TRUE;
}

VOID CertificatePrintSingle(CONST DWORD IndexStore, PCCERT_CONTEXT cert)
{
	DWORD CertType = CERT_X500_NAME_STR;
	DWORD StrSubjSize;
	LPTSTR StrSubj;


	_tprintf_s(LangGet(UIMSG_109_CODESIGN_CERTID), IndexStore);

	StrSubjSize = CertGetNameString(cert, CERT_NAME_RDN_TYPE, 0, &CertType, 0, 0);
	if (!StrSubjSize)
		return;

	StrSubj = _alloca(StrSubjSize * sizeof(TCHAR));
	StrSubjSize = CertGetNameString(cert, CERT_NAME_RDN_TYPE, 0, &CertType, StrSubj, StrSubjSize);
	if (StrSubjSize)
		_tprintf_s(TEXT("%s\n"), StrSubj);
}

BOOL ACEsRemoveAll(CONST HANDLE hFile, CONST DWORD CertificateCount, PDWORD Indices)
{
	_tprintf_s(LangGet(UIMSG_110_REMOVING_ACE));

	for (SIZE_T i = 0; i < CertificateCount; ++i)
	{
		_tprintf_s(LangGet(UIMSG_111_REMOVING_ACE_ID), Indices[i]);
		if (!ImageRemoveCertificate(hFile, Indices[i]))
			return FALSE;
	}

	CLIWriteLN();
	return TRUE;
}

BOOL DirectoryEntrySecZero(CONST HANDLE hFile)
{
	BOOL Result = TRUE;
	DWORD fileSize;
	HANDLE hFileMapping = NULL;
	LPVOID fileBase = NULL;
	PIMAGE_DOS_HEADER HeaderDOS;
	PIMAGE_NT_HEADERS32 ntHeader32;
	PIMAGE_NT_HEADERS64 ntHeader64;


	_tprintf_s(LangGet(UIMSG_112_REMOVING_IDES));

	// Get the file size
	fileSize = GetFileSize(hFile, NULL);
	if (!fileSize)
		ExitFunction(FALSE);

	// Create a file mapping object
	hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL);
	if (hFileMapping == NULL) 
		ExitFunction(FALSE);

	// Map the file into memory
	fileBase = MapViewOfFile(hFileMapping, FILE_MAP_ALL_ACCESS, 0, 0, 0);
	if (fileBase == NULL) 
		ExitFunction(FALSE);

	// check DOS header
	HeaderDOS = (PIMAGE_DOS_HEADER)fileBase;
	if (HeaderDOS->e_magic != IMAGE_DOS_SIGNATURE) {
		_tprintf_s(LangGet(UIMSG_122_PE_BAD_HEADERS));
		ExitFunction(FALSE);
	}
	if (HeaderDOS->e_lfanew == 0) {
		_tprintf_s(LangGet(UIMSG_122_PE_BAD_HEADERS));
		ExitFunction(FALSE);
	}

	// set variables for PE headers
	ntHeader64 = (PIMAGE_NT_HEADERS64)((LPBYTE)fileBase + HeaderDOS->e_lfanew);
	ntHeader32 = (PIMAGE_NT_HEADERS32)ntHeader64;

	// signatures for PE32 and PE32+ headers are on the same place, single check in enough
	if (ntHeader64->Signature != IMAGE_NT_SIGNATURE) {
		_tprintf_s(LangGet(UIMSG_122_PE_BAD_HEADERS));
		ExitFunction(FALSE);
	}

	// fix
	switch (ntHeader64->OptionalHeader.Magic)
	{
	// PE executable
	case IMAGE_NT_OPTIONAL_HDR32_MAGIC:
		// Note that the number of directories is not fixed. Before looking for a specific directory,
		// check the NumberOfRvaAndSizes field in the optional header
		// https://learn.microsoft.com/en-us/windows/win32/debug/pe-format
		if (ntHeader32->OptionalHeader.NumberOfRvaAndSizes < (IMAGE_DIRECTORY_ENTRY_SECURITY + 1))
		{
			_tprintf_s(LangGet(UIMSG_123_PE_BAD_DIRECTORY_COUNT));
			ExitFunction(FALSE);
		}

		_tprintf_s(LangGet(UIMSG_113_IDES_SIZE), ntHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size);
		_tprintf_s(LangGet(UIMSG_114_IDES_VA), ntHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress);

		ntHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size = 0;
		ntHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress = 0;
		ntHeader32->OptionalHeader.CheckSum = 0;

		break;

	// PE+ executable
	case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
		// Note that the number of directories is not fixed. Before looking for a specific directory,
		// check the NumberOfRvaAndSizes field in the optional header
		// https://learn.microsoft.com/en-us/windows/win32/debug/pe-format
		if (ntHeader64->OptionalHeader.NumberOfRvaAndSizes < (IMAGE_DIRECTORY_ENTRY_SECURITY + 1))
		{
			_tprintf_s(LangGet(UIMSG_123_PE_BAD_DIRECTORY_COUNT));
			ExitFunction(FALSE);
		}

		_tprintf_s(LangGet(UIMSG_113_IDES_SIZE), ntHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size);
		_tprintf_s(LangGet(UIMSG_114_IDES_VA), ntHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress);

		ntHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size = 0;
		ntHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress = 0;
		ntHeader64->OptionalHeader.CheckSum = 0;

		break;

	// unknown
	default:
		_tprintf_s(LangGet(UIMSG_122_PE_BAD_HEADERS));
		ExitFunction(FALSE);

		break;
	}

	_tprintf_s(LangGet(UIMSG_115_IDES_ZEROED));


function_end:
	// Unmap the file and close handles
	if (fileBase)
		UnmapViewOfFile(fileBase);

	if (hFileMapping)
		CloseHandle(hFileMapping);

	return Result;
}

```

`unsign-src/Main.h`:

```h
/***

Copyright SV Foster, 2023-2024. All rights reserved.

License:
    This program is free for personal, educational and/or non-profit usage    

Revision History:
    See Main.c for details

***/

#pragma once


DWORD ModeHelp();
DWORD ModeUnsigh(PGlobalOptions GlobalOptions);
BOOL  ACEsFind(CONST HANDLE hFile, PDWORD PCertificateCount, PDWORD* Indices, PDWORD LastError);
BOOL  ImageCertificatesPrintAll(CONST HANDLE hFile, CONST DWORD CertificateCount, PDWORD Indices);
BOOL  StoreCertificatesPrintAll(CONST DWORD Index, CONST CRYPT_DATA_BLOB p7Data);
VOID  CertificatePrintSingle(CONST DWORD IndexStore, PCCERT_CONTEXT cert);
BOOL  ACEsRemoveAll(CONST HANDLE hFile, CONST DWORD CertificateCount, PDWORD Indices);
BOOL  DirectoryEntrySecZero(CONST HANDLE hFile);

```

`unsign-src/SharedHeaders.h`:

```h
/***

Copyright SV Foster, 2023. All rights reserved.

License:
    This program is free for personal, educational and/or non-profit usage    

Revision History:
	Rev 0, DEC 2023
	   First revision

***/

#pragma once


#if _WIN32 || _WIN64
	#if _WIN64
		#define ENV64BIT
	#else
		#define ENV32BIT
	#endif
#endif

#define ExitFunction(e) {Result = e; goto function_end;}

```

`unsign-src/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by resource.rc
//
#define UIMSG_101_PROCESSINGFILE        101
#define UIMSG_102_CANT_OPEN_FILE        102
#define UIMSG_103_FILE_CORRUPTED        103
#define UIMSG_104_APP_SUCCESS           104
#define UIMSG_105_PE_NOT_SIGNED         105
#define UIMSG_106_APP_ERROR             106
#define UIMSG_107_EXAM_CERTSTORE        107
#define UIMSG_108_NO_CODESIGN           108
#define UIMSG_109_CODESIGN_CERTID       109
#define UIMSG_110_REMOVING_IMG_CERT     110
#define UIMSG_110_REMOVING_ACE          110
#define UIMSG_111_REMOVING_IMG_CERT_ID  111
#define UIMSG_111_REMOVING_ACE_ID       111
#define UIMSG_112_REMOVING_IDES         112
#define UIMSG_113_IDES_SIZE             113
#define UIMSG_114_IDES_VA               114
#define UIMSG_115_IDES_ZEROED           115
#define UIMSG_116_FOUND_IMAGECERTS_CNT  116
#define UIMSG_117_HELP_TEXT             117
#define UIMSG_118_LOGO_TEXT             118
#define UIMSG_119_ERR_PARAMS_TOO_MANY_AGRS 119
#define UIMSG_120_ERR_ENUM_CERTS        120
#define UIMSG_121_ERR_PARAMS_BAD_SW     121
#define UIMSG_122_PE_BAD_HEADERS        122
#define UIMSG_123_PE_BAD_DIRECTORY_COUNT 123

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`unsign-src/resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,1,0,0
 PRODUCTVERSION 1,1,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40000L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "SV Foster"
            VALUE "FileDescription", "PE/COFF executable unsign tool"
            VALUE "FileVersion", "1.1.0.0"
            VALUE "InternalName", "unsign"
            VALUE "LegalCopyright", "SV Foster, 2023-2024"
            VALUE "OriginalFilename", "unsign.exe"
            VALUE "ProductName", "UnSign"
            VALUE "ProductVersion", "1.1.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE
BEGIN
    UIMSG_101_PROCESSINGFILE "Now processing file: %s\n\n"
    UIMSG_102_CANT_OPEN_FILE "Can't open file, error %d\n"
    UIMSG_103_FILE_CORRUPTED "File discovered currupted, applying fix...\n\n"
    UIMSG_104_APP_SUCCESS   "Operation completed successfully. This PE/COFF executable file is now unsigned and can be signed again\n"
    UIMSG_105_PE_NOT_SIGNED "This PE/COFF executable file is not signed\n\n"
    UIMSG_106_APP_ERROR     "An error has occurred. File was not processed\n"
    UIMSG_107_EXAM_CERTSTORE 
                            "Examening certificates store in attribute certificate entry #%d\n"
    UIMSG_108_NO_CODESIGN   "No code signing certificates found\n"
    UIMSG_109_CODESIGN_CERTID "Codesign certificate #%d: "
    UIMSG_110_REMOVING_ACE  "Removing all attribute certificate entrys of the PE/COFF executable file\n"
    UIMSG_111_REMOVING_ACE_ID "Removing attribute certificate entry #%d\n"
END

STRINGTABLE
BEGIN
    UIMSG_112_REMOVING_IDES "Removing values from PE header table entry IMAGE_DIRECTORY_ENTRY_SECURITY\n"
    UIMSG_113_IDES_SIZE     "DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size was 0x%08X\n"
    UIMSG_114_IDES_VA       "DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VA was 0x%08X\n"
    UIMSG_115_IDES_ZEROED   "Set to zero now\n\n"
    UIMSG_116_FOUND_IMAGECERTS_CNT 
                            "Total attribute certificate entrys in the PE/COFF executable file: %d\n\n"
    UIMSG_117_HELP_TEXT     "Completely removes the embedded signature(s) (with all sections of the signature) from a PE/COFF executable file\nFixes PE header problem that makes a PE/COFF executable file unsignable\n\nWARNING: This program will modify the file inplace on the disk. Please create a backup copy if you want to preserve the original file!\n\nUsage: unsign /<switch 1> /<switch N> <PE/COFF executable file>\n\n<Switches>\n  /NoLogo       Don't print copyright logo\n  /NoCertPrint  Don't exam and print certificates on the file\n\n"
    UIMSG_118_LOGO_TEXT     "%s %d.%d %s\nCopyright %s. All rights reserved\nThis program is free for personal, educational and/or non-profit usage\n\n"
    UIMSG_119_ERR_PARAMS_TOO_MANY_AGRS "Too many arguments - %s\n\n"
    UIMSG_120_ERR_ENUM_CERTS 
                            "Can't enumerate all certificates, they are damaged or are in an unsupported format\n"
    UIMSG_121_ERR_PARAMS_BAD_SW "Invalid switch - %s\n\n"
    UIMSG_122_PE_BAD_HEADERS 
                            "Invalid PE/COFF executable headers, file is damaged, has unsupported format or it is not an executable\n\n"
    UIMSG_123_PE_BAD_DIRECTORY_COUNT 
                            "If the NumberOfRvaAndSizes value is too small, there are not enough entries in the DataDirectory array to accommodate the IMAGE_DIRECTORY_ENTRY_SECURITY directory. This error can occur if the file is corrupted or if it was not properly generated during the compilation process\n\n"
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`unsign-src/unsign.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-16"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{c5877396-66ea-456d-a728-35fb1c134ae5}</ProjectGuid>
    <RootNamespace>unsign</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)$(ProjectName)-exe-IA-32\</OutDir>
    <IntDir>$(SolutionDir)$(ProjectName)-obj-IA-32\</IntDir>
    <TargetName>unsign</TargetName>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)$(ProjectName)-exe-IA-32\</OutDir>
    <IntDir>$(SolutionDir)$(ProjectName)-obj-IA-32\</IntDir>
    <TargetName>unsign</TargetName>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)$(ProjectName)-exe-x86-64\</OutDir>
    <IntDir>$(SolutionDir)$(ProjectName)-obj-x86-64\</IntDir>
    <TargetName>unsign</TargetName>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)$(ProjectName)-exe-x86-64\</OutDir>
    <IntDir>$(SolutionDir)$(ProjectName)-obj-x86-64\</IntDir>
    <TargetName>unsign</TargetName>
    <CodeAnalysisRuleSet>NativeRecommendedRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <ErrorReporting>None</ErrorReporting>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <AdditionalOptions>/emittoolversioninfo:no /pdbaltpath:%_PDB% %(AdditionalOptions)</AdditionalOptions>
      <BaseAddress>0x10000</BaseAddress>
      <SetChecksum>false</SetChecksum>
      <GenerateMapFile>true</GenerateMapFile>
      <MapExports>true</MapExports>
      <StackReserveSize>262144</StackReserveSize>
      <StackCommitSize>8192</StackCommitSize>
      <LinkErrorReporting>NoErrorReport</LinkErrorReporting>
      <HeapReserveSize>1048576</HeapReserveSize>
      <HeapCommitSize>131072</HeapCommitSize>
    </Link>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
    <ResourceCompile>
      <NullTerminateStrings>true</NullTerminateStrings>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <ErrorReporting>None</ErrorReporting>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <AdditionalOptions>/emittoolversioninfo:no /pdbaltpath:%_PDB% %(AdditionalOptions)</AdditionalOptions>
      <BaseAddress>0x10000</BaseAddress>
      <SetChecksum>true</SetChecksum>
      <GenerateMapFile>true</GenerateMapFile>
      <MapExports>true</MapExports>
      <StackReserveSize>262144</StackReserveSize>
      <StackCommitSize>8192</StackCommitSize>
      <LinkErrorReporting>NoErrorReport</LinkErrorReporting>
      <HeapReserveSize>1048576</HeapReserveSize>
      <HeapCommitSize>131072</HeapCommitSize>
    </Link>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
    <ResourceCompile>
      <NullTerminateStrings>true</NullTerminateStrings>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <ErrorReporting>None</ErrorReporting>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <AdditionalOptions>/emittoolversioninfo:no /pdbaltpath:%_PDB% %(AdditionalOptions)</AdditionalOptions>
      <SetChecksum>false</SetChecksum>
      <GenerateMapFile>true</GenerateMapFile>
      <MapExports>true</MapExports>
      <StackReserveSize>524288</StackReserveSize>
      <StackCommitSize>8192</StackCommitSize>
      <LinkErrorReporting>NoErrorReport</LinkErrorReporting>
      <HeapReserveSize>1048576</HeapReserveSize>
      <HeapCommitSize>131072</HeapCommitSize>
    </Link>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
    <ResourceCompile>
      <NullTerminateStrings>true</NullTerminateStrings>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <ErrorReporting>None</ErrorReporting>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <AdditionalOptions>/emittoolversioninfo:no /pdbaltpath:%_PDB% %(AdditionalOptions)</AdditionalOptions>
      <SetChecksum>true</SetChecksum>
      <GenerateMapFile>true</GenerateMapFile>
      <MapExports>true</MapExports>
      <StackReserveSize>524288</StackReserveSize>
      <StackCommitSize>8192</StackCommitSize>
      <LinkErrorReporting>NoErrorReport</LinkErrorReporting>
      <HeapReserveSize>1048576</HeapReserveSize>
      <HeapCommitSize>131072</HeapCommitSize>
    </Link>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
    <ResourceCompile>
      <NullTerminateStrings>true</NullTerminateStrings>
    </ResourceCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="CommandLineInterface.c" />
    <ClCompile Include="LanguageRes.c" />
    <ClCompile Include="Main.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CommandLineInterface.h" />
    <ClInclude Include="GlobalOptions.h" />
    <ClInclude Include="LanguageRes.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="Main.h" />
    <ClInclude Include="SharedHeaders.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="resource.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`unsign-src/unsign.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-16"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="LanguageRes.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="CommandLineInterface.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Main.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="LanguageRes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="CommandLineInterface.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="GlobalOptions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="SharedHeaders.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="resource.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>

```

`unsign-src/unsign.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-16"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LocalDebuggerCommandArguments>
    </LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
    <LocalDebuggerWorkingDirectory>$(OutDir)</LocalDebuggerWorkingDirectory>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LocalDebuggerCommandArguments>
    </LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
    <LocalDebuggerWorkingDirectory>$(OutDir)</LocalDebuggerWorkingDirectory>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerWorkingDirectory>$(OutDir)</LocalDebuggerWorkingDirectory>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
    <LocalDebuggerCommandArguments>
    </LocalDebuggerCommandArguments>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LocalDebuggerWorkingDirectory>$(OutDir)</LocalDebuggerWorkingDirectory>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
    <LocalDebuggerCommandArguments>
    </LocalDebuggerCommandArguments>
  </PropertyGroup>
</Project>
```

`unsign.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.33801.447
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "unsign", "unsign-src\unsign.vcxproj", "{C5877396-66EA-456D-A728-35FB1C134AE5}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C5877396-66EA-456D-A728-35FB1C134AE5}.Debug|x64.ActiveCfg = Debug|x64
		{C5877396-66EA-456D-A728-35FB1C134AE5}.Debug|x64.Build.0 = Debug|x64
		{C5877396-66EA-456D-A728-35FB1C134AE5}.Debug|x86.ActiveCfg = Debug|Win32
		{C5877396-66EA-456D-A728-35FB1C134AE5}.Debug|x86.Build.0 = Debug|Win32
		{C5877396-66EA-456D-A728-35FB1C134AE5}.Release|x64.ActiveCfg = Release|x64
		{C5877396-66EA-456D-A728-35FB1C134AE5}.Release|x64.Build.0 = Release|x64
		{C5877396-66EA-456D-A728-35FB1C134AE5}.Release|x86.ActiveCfg = Release|Win32
		{C5877396-66EA-456D-A728-35FB1C134AE5}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {5CC75311-A362-4674-8DEA-5B8AEFB89FB8}
	EndGlobalSection
EndGlobal

```