Project Path: arc_gmh5225_edbgserver_19f3wvgg

Source Tree:

```txt
arc_gmh5225_edbgserver_19f3wvgg
├── Cargo.lock
├── Cargo.toml
├── LICENSE-APACHE
├── LICENSE-GPL2
├── LICENSE-MIT
├── README.md
├── README_zh.md
├── android_lib_pull.sh
├── demo.png
├── edbgserver-cli
│   ├── Cargo.toml
│   ├── build.rs
│   ├── src
│   │   ├── connection.rs
│   │   ├── event.rs
│   │   ├── main.rs
│   │   ├── resolve_target.rs
│   │   ├── target
│   │   │   ├── arch
│   │   │   │   ├── aarch64.rs
│   │   │   │   ├── aarch64_core.xml
│   │   │   │   └── x86_64.rs
│   │   │   ├── arch.rs
│   │   │   ├── auvx.rs
│   │   │   ├── breakpoint.rs
│   │   │   ├── execfile.rs
│   │   │   ├── host_io.rs
│   │   │   ├── libraries.rs
│   │   │   ├── memory_map.rs
│   │   │   └── multithread.rs
│   │   ├── target.rs
│   │   ├── utils.rs
│   │   └── virtual_file.rs
│   └── tests
│       ├── integration_test.rs
│       └── test_target
│           ├── test_target
│           └── test_target.c
├── edbgserver-common
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── edbgserver-ebpf
│   ├── Cargo.toml
│   ├── build.rs
│   └── src
│       ├── lib.rs
│       └── main.rs
├── rust-toolchain.toml
└── rustfmt.toml

```

`Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "adler2"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "320119579fcad9c21884f5c4861d16174d0e06250625266f50fe6898340abefa"

[[package]]
name = "aes"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b169f7a6d4742236a0a00c541b845991d0ac43e546831af1249753ab4c3aa3a0"
dependencies = [
 "cfg-if",
 "cipher",
 "cpufeatures",
]

[[package]]
name = "aho-corasick"
version = "1.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ddd31a130427c27518df266943a5308ed92d4b226cc639f5a8f1002816174301"
dependencies = [
 "memchr",
]

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "anstream"
version = "0.6.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "43d5b281e737544384e969a5ccad3f1cdd24b48086a0fc1b2a5262a26b8f4f4a"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "is_terminal_polyfill",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5192cca8006f1fd4f7237516f40fa183bb07f8fbdfedaa0036de5ea9b0b45e78"

[[package]]
name = "anstyle-parse"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4e7644824f0aa2c7b9384579234ef10eb7efb6a0deb83f9630a49594dd9c15c2"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40c48f72fd53cd289104fc64099abca73db4166ad86ea0b4341abe65af83dadc"
dependencies = [
 "windows-sys 0.61.2",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "291e6a250ff86cd4a820112fb8898808a366d8f9f58ce16d1f538353ad55747d"
dependencies = [
 "anstyle",
 "once_cell_polyfill",
 "windows-sys 0.61.2",
]

[[package]]
name = "anyhow"
version = "1.0.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a23eb6b1614318a8071c9b2521f36b424b2c83db5eb3a0fead4a6c0809af6e61"

[[package]]
name = "arbitrary"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3d036a3c4ab069c7b410a2ce876bd74808d2d0888a82667669f8e783a898bf1"
dependencies = [
 "derive_arbitrary",
]

[[package]]
name = "assert_matches"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b34d609dfbaf33d6889b2b7106d3ca345eacad44200913df5ba02bfd31d2ba9"

[[package]]
name = "atty"
version = "0.2.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8"
dependencies = [
 "hermit-abi",
 "libc",
 "winapi",
]

[[package]]
name = "autocfg"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08606f8c3cbf4ce6ec8e28fb0014a2c086708fe954eaa885384a6165172e7e8"

[[package]]
name = "aya"
version = "0.13.2"
source = "git+https://github.com/Satar07/aya/?rev=4af9109#4af91092840f95e8b91ac00476512ed4314e040c"
dependencies = [
 "assert_matches",
 "aya-obj",
 "bitflags",
 "bytes",
 "hashbrown",
 "libc",
 "log",
 "object",
 "once_cell",
 "thiserror",
]

[[package]]
name = "aya-build"
version = "0.1.3"
source = "git+https://github.com/Satar07/aya/?rev=4af9109#4af91092840f95e8b91ac00476512ed4314e040c"
dependencies = [
 "anyhow",
 "cargo_metadata",
]

[[package]]
name = "aya-ebpf"
version = "0.1.2"
source = "git+https://github.com/Satar07/aya/?rev=4af9109#4af91092840f95e8b91ac00476512ed4314e040c"
dependencies = [
 "aya-build",
 "aya-ebpf-bindings",
 "aya-ebpf-cty",
 "aya-ebpf-macros",
 "rustversion",
]

[[package]]
name = "aya-ebpf-bindings"
version = "0.1.2"
source = "git+https://github.com/Satar07/aya/?rev=4af9109#4af91092840f95e8b91ac00476512ed4314e040c"
dependencies = [
 "aya-build",
 "aya-ebpf-cty",
]

[[package]]
name = "aya-ebpf-cty"
version = "0.2.3"
source = "git+https://github.com/Satar07/aya/?rev=4af9109#4af91092840f95e8b91ac00476512ed4314e040c"
dependencies = [
 "aya-build",
]

[[package]]
name = "aya-ebpf-macros"
version = "0.1.2"
source = "git+https://github.com/Satar07/aya/?rev=4af9109#4af91092840f95e8b91ac00476512ed4314e040c"
dependencies = [
 "proc-macro2",
 "proc-macro2-diagnostics",
 "quote",
 "syn",
]

[[package]]
name = "aya-log"
version = "0.2.2"
source = "git+https://github.com/Satar07/aya/?rev=4af9109#4af91092840f95e8b91ac00476512ed4314e040c"
dependencies = [
 "aya",
 "aya-log-common",
 "log",
 "thiserror",
]

[[package]]
name = "aya-log-common"
version = "0.1.16"
source = "git+https://github.com/Satar07/aya/?rev=4af9109#4af91092840f95e8b91ac00476512ed4314e040c"
dependencies = [
 "num_enum",
]

[[package]]
name = "aya-log-ebpf"
version = "0.1.2"
source = "git+https://github.com/Satar07/aya/?rev=4af9109#4af91092840f95e8b91ac00476512ed4314e040c"
dependencies = [
 "aya-ebpf",
 "aya-log-common",
 "aya-log-ebpf-macros",
]

[[package]]
name = "aya-log-ebpf-macros"
version = "0.1.1"
source = "git+https://github.com/Satar07/aya/?rev=4af9109#4af91092840f95e8b91ac00476512ed4314e040c"
dependencies = [
 "aya-log-common",
 "aya-log-parser",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "aya-log-parser"
version = "0.1.14"
source = "git+https://github.com/Satar07/aya/?rev=4af9109#4af91092840f95e8b91ac00476512ed4314e040c"
dependencies = [
 "aya-log-common",
]

[[package]]
name = "aya-obj"
version = "0.2.2"
source = "git+https://github.com/Satar07/aya/?rev=4af9109#4af91092840f95e8b91ac00476512ed4314e040c"
dependencies = [
 "bytes",
 "hashbrown",
 "log",
 "object",
 "thiserror",
]

[[package]]
name = "bitflags"
version = "2.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "812e12b5285cc515a9c72a5c1d3b6d46a19dac5acfef5265968c166106e31dd3"

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "bumpalo"
version = "3.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"

[[package]]
name = "bytes"
version = "1.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b35204fbdc0b3f4446b89fc1ac2cf84a8a68971995d0bf2e925ec7cd960f9cb3"

[[package]]
name = "bzip2"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f3a53fac24f34a81bc9954b5d6cfce0c21e18ec6959f44f56e8e90e4bb7c346c"
dependencies = [
 "libbz2-rs-sys",
]

[[package]]
name = "camino"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "276a59bf2b2c967788139340c9f0c5b12d7fd6630315c15c217e559de85d2609"
dependencies = [
 "serde_core",
]

[[package]]
name = "capstone"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "015ef5d5ca1743e3f94af9509ba6bd2886523cfee46e48d15c2ef5216fd4ac9a"
dependencies = [
 "capstone-sys",
 "libc",
]

[[package]]
name = "capstone-sys"
version = "0.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2267cb8d16a1e4197863ec4284ffd1aec26fe7e57c58af46b02590a0235809a0"
dependencies = [
 "cc",
 "libc",
]

[[package]]
name = "cargo-platform"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "122ec45a44b270afd1402f351b782c676b173e3c3fb28d86ff7ebfb4d86a4ee4"
dependencies = [
 "serde",
]

[[package]]
name = "cargo_metadata"
version = "0.23.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef987d17b0a113becdd19d3d0022d04d7ef41f9efe4f3fb63ac44ba61df3ade9"
dependencies = [
 "camino",
 "cargo-platform",
 "semver",
 "serde",
 "serde_json",
 "thiserror",
]

[[package]]
name = "cc"
version = "1.2.48"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c481bdbf0ed3b892f6f806287d72acd515b352a4ec27a208489b8c1bc839633a"
dependencies = [
 "find-msvc-tools",
 "jobserver",
 "libc",
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9330f8b2ff13f34540b44e946ef35111825727b38d33286ef986142615121801"

[[package]]
name = "cfg_aliases"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "613afe47fcd5fac7ccf1db93babcb082c5994d996f20b8b159f2ad1658eb5724"

[[package]]
name = "chrono"
version = "0.4.42"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "145052bdd345b87320e369255277e3fb5152762ad123a901ef5c262dd38fe8d2"
dependencies = [
 "iana-time-zone",
 "num-traits",
 "windows-link",
]

[[package]]
name = "cipher"
version = "0.4.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773f3b9af64447d2ce9850330c473515014aa235e6a783b02db81ff39e4a3dad"
dependencies = [
 "crypto-common",
 "inout",
]

[[package]]
name = "clap"
version = "4.5.53"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c9e340e012a1bf4935f5282ed1436d1489548e8f72308207ea5df0e23d2d03f8"
dependencies = [
 "clap_builder",
 "clap_derive",
]

[[package]]
name = "clap-num"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "822c4000301ac390e65995c62207501e3ef800a1fc441df913a5e8e4dc374816"
dependencies = [
 "num-traits",
]

[[package]]
name = "clap_builder"
version = "4.5.53"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d76b5d13eaa18c901fd2f7fca939fefe3a0727a953561fefdf3b2922b8569d00"
dependencies = [
 "anstream",
 "anstyle",
 "clap_lex",
 "strsim",
]

[[package]]
name = "clap_derive"
version = "4.5.49"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2a0b5487afeab2deb2ff4e03a807ad1a03ac532ff5a2cee5d86884440c7f7671"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "clap_lex"
version = "0.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1d728cc89cf3aee9ff92b05e62b19ee65a02b5702cff7d5a377e32c6ae29d8d"

[[package]]
name = "colorchoice"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b05b61dc5112cbb17e4b6cd61790d9845d13888356391624cbe7e41efeac1e75"

[[package]]
name = "constant_time_eq"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c74b8349d32d297c9134b8c88677813a227df8f779daa29bfc29c183fe3dca6"

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "cpufeatures"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59ed5838eebb26a2bb2e58f6d5b5316989ae9d08bab10e0e6d103e656d1b0280"
dependencies = [
 "libc",
]

[[package]]
name = "crc"
version = "3.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5eb8a2a1cd12ab0d987a5d5e825195d372001a4094a0376319d5a0ad71c1ba0d"
dependencies = [
 "crc-catalog",
]

[[package]]
name = "crc-catalog"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19d374276b40fb8bbdee95aef7c7fa6b5316ec764510eb64b8dd0e2ed0d7e7f5"

[[package]]
name = "crc32fast"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9481c1c90cbf2ac953f07c8d4a58aa3945c425b7185c9154d67a65e4230da511"
dependencies = [
 "cfg-if",
]

[[package]]
name = "crypto-common"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78c8292055d1c1df0cce5d180393dc8cce0abec0a7102adb6c7b1eef6016d60a"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "deflate64"
version = "0.1.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26bf8fc351c5ed29b5c2f0cbbac1b209b74f60ecd62e675a998df72c49af5204"

[[package]]
name = "deranged"
version = "0.5.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ececcb659e7ba858fb4f10388c250a7252eb0a27373f1a72b8748afdd248e587"
dependencies = [
 "powerfmt",
]

[[package]]
name = "derive_arbitrary"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e567bd82dcff979e4b03460c307b3cdc9e96fde3d73bed1496d2bc75d9dd62a"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "crypto-common",
 "subtle",
]

[[package]]
name = "edbgserver-cli"
version = "1.0.1"
dependencies = [
 "anyhow",
 "aya",
 "aya-build",
 "aya-log",
 "capstone",
 "cargo_metadata",
 "clap",
 "clap-num",
 "edbgserver-common",
 "edbgserver-ebpf",
 "gdbstub",
 "gdbstub_arch",
 "goblin",
 "libc",
 "log",
 "nix",
 "pretty_env_logger",
 "process-memory",
 "procfs",
 "serial_test",
 "tagu",
 "tokio",
 "zerocopy",
 "zip",
]

[[package]]
name = "edbgserver-common"
version = "1.0.1"
dependencies = [
 "aya",
]

[[package]]
name = "edbgserver-ebpf"
version = "1.0.1"
dependencies = [
 "aya-ebpf",
 "aya-log-ebpf",
 "edbgserver-common",
 "which",
]

[[package]]
name = "either"
version = "1.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"

[[package]]
name = "env_logger"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "44533bbbb3bb3c1fa17d9f2e4e38bbbaf8396ba82193c4cb1b6445d711445d36"
dependencies = [
 "atty",
 "humantime",
 "log",
 "regex",
 "termcolor",
]

[[package]]
name = "equivalent"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"

[[package]]
name = "errno"
version = "0.3.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "39cab71617ae0d63f51a36d69f866391735b51691dbda63cf6f96d042b63efeb"
dependencies = [
 "libc",
 "windows-sys 0.61.2",
]

[[package]]
name = "find-msvc-tools"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3a3076410a55c90011c298b04d0cfa770b00fa04e1e3c97d3f6c9de105a03844"

[[package]]
name = "flate2"
version = "1.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfe33edd8e85a12a67454e37f8c75e730830d83e313556ab9ebf9ee7fbeb3bfb"
dependencies = [
 "crc32fast",
 "libz-rs-sys",
 "miniz_oxide",
]

[[package]]
name = "foldhash"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77ce24cb58228fbb8aa041425bb1050850ac19177686ea6e0f41a70416f56fdb"

[[package]]
name = "futures"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "65bc07b1a8bc7c85c5f2e110c476c7389b4554ba72af57d8445ea63a576b0876"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-executor",
 "futures-io",
 "futures-sink",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-channel"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2dff15bf788c671c1934e366d07e30c1814a8ef514e1af724a602e8a2fbe1b10"
dependencies = [
 "futures-core",
 "futures-sink",
]

[[package]]
name = "futures-core"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"

[[package]]
name = "futures-executor"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e28d1d997f585e54aebc3f97d39e72338912123a67330d723fdbb564d646c9f"
dependencies = [
 "futures-core",
 "futures-task",
 "futures-util",
]

[[package]]
name = "futures-io"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9e5c1b78ca4aae1ac06c48a526a655760685149f0d465d21f37abfe57ce075c6"

[[package]]
name = "futures-sink"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e575fab7d1e0dcb8d0c7bcf9a63ee213816ab51902e6d244a95819acacf1d4f7"

[[package]]
name = "futures-task"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f90f7dce0722e95104fcb095585910c0977252f286e354b5e3bd38902cd99988"

[[package]]
name = "futures-util"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81"
dependencies = [
 "futures-channel",
 "futures-core",
 "futures-io",
 "futures-sink",
 "futures-task",
 "memchr",
 "pin-project-lite",
 "pin-utils",
 "slab",
]

[[package]]
name = "gdbstub"
version = "0.7.8"
source = "git+https://github.com/Satar07/gdbstub/?rev=993a560#993a560bb6a20481e5b5e32e334be5daf68fd9d6"
dependencies = [
 "bitflags",
 "cfg-if",
 "log",
 "managed",
 "num-traits",
 "paste",
]

[[package]]
name = "gdbstub_arch"
version = "0.3.2"
source = "git+https://github.com/Satar07/gdbstub/?rev=993a560#993a560bb6a20481e5b5e32e334be5daf68fd9d6"
dependencies = [
 "gdbstub",
 "num-traits",
]

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "getrandom"
version = "0.3.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "899def5c37c4fd7b2664648c28120ecec138e4d395b459e5ca34f9cce2dd77fd"
dependencies = [
 "cfg-if",
 "libc",
 "r-efi",
 "wasip2",
]

[[package]]
name = "goblin"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4db6758c546e6f81f265638c980e5e84dfbda80cfd8e89e02f83454c8e8124bd"
dependencies = [
 "log",
 "plain",
 "scroll",
]

[[package]]
name = "hashbrown"
version = "0.16.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "841d1cc9bed7f9236f321df977030373f4a4163ae1a7dbfe1a51a2c1a51d9100"
dependencies = [
 "equivalent",
 "foldhash",
]

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "hermit-abi"
version = "0.1.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33"
dependencies = [
 "libc",
]

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "hmac"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c49c37c09c17a53d937dfbb742eb3a961d65a994e6bcdcf37e7399d0cc8ab5e"
dependencies = [
 "digest",
]

[[package]]
name = "home"
version = "0.5.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cc627f471c528ff0c4a49e1d5e60450c8f6461dd6d10ba9dcd3a61d3dff7728d"
dependencies = [
 "windows-sys 0.61.2",
]

[[package]]
name = "humantime"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df004cfca50ef23c36850aaaa59ad52cc70d0e90243c3c7737a4dd32dc7a3c4f"
dependencies = [
 "quick-error",
]

[[package]]
name = "iana-time-zone"
version = "0.1.64"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33e57f83510bb73707521ebaffa789ec8caf86f9657cad665b092b581d40e9fb"
dependencies = [
 "android_system_properties",
 "core-foundation-sys",
 "iana-time-zone-haiku",
 "js-sys",
 "log",
 "wasm-bindgen",
 "windows-core",
]

[[package]]
name = "iana-time-zone-haiku"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
dependencies = [
 "cc",
]

[[package]]
name = "indexmap"
version = "2.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ad4bb2b565bca0645f4d68c5c9af97fba094e9791da685bf83cb5f3ce74acf2"
dependencies = [
 "equivalent",
 "hashbrown",
]

[[package]]
name = "inout"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "879f10e63c20629ecabbb64a8010319738c66a5cd0c29b02d63d272b03751d01"
dependencies = [
 "generic-array",
]

[[package]]
name = "is_terminal_polyfill"
version = "1.70.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a6cb138bb79a146c1bd460005623e142ef0181e3d0219cb493e02f7d08a35695"

[[package]]
name = "itoa"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a5f13b858c8d314ee3e8f639011f7ccefe71f97f96e50151fb991f267928e2c"

[[package]]
name = "jobserver"
version = "0.1.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9afb3de4395d6b3e67a780b6de64b51c978ecf11cb9a462c66be7d4ca9039d33"
dependencies = [
 "getrandom",
 "libc",
]

[[package]]
name = "js-sys"
version = "0.3.83"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "464a3709c7f55f1f721e5389aa6ea4e3bc6aba669353300af094b29ffbdde1d8"
dependencies = [
 "once_cell",
 "wasm-bindgen",
]

[[package]]
name = "libbz2-rs-sys"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2c4a545a15244c7d945065b5d392b2d2d7f21526fba56ce51467b06ed445e8f7"

[[package]]
name = "libc"
version = "0.2.177"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2874a2af47a2325c2001a6e6fad9b16a53b802102b528163885171cf92b15976"

[[package]]
name = "libz-rs-sys"
version = "0.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "15413ef615ad868d4d65dce091cb233b229419c7c0c4bcaa746c0901c49ff39c"
dependencies = [
 "zlib-rs",
]

[[package]]
name = "linux-raw-sys"
version = "0.4.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d26c52dbd32dccf2d10cac7725f8eae5296885fb5703b261f7d0a0739ec807ab"

[[package]]
name = "linux-raw-sys"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df1d3c3b53da64cf5760482273a98e575c651a67eec7f77df96b5b642de8f039"

[[package]]
name = "lock_api"
version = "0.4.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "224399e74b87b5f3557511d98dff8b14089b3dadafcab6bb93eab67d3aace965"
dependencies = [
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34080505efa8e45a4b816c349525ebe327ceaa8559756f0356cba97ef3bf7432"

[[package]]
name = "lzma-rust2"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c60a23ffb90d527e23192f1246b14746e2f7f071cb84476dd879071696c18a4a"
dependencies = [
 "crc",
 "sha2",
]

[[package]]
name = "mach"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b823e83b2affd8f40a9ee8c29dbc56404c1e34cd2710921f2801e2cf29527afa"
dependencies = [
 "libc",
]

[[package]]
name = "managed"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ca88d725a0a943b096803bd34e73a4437208b6077654cc4ecb2947a5f91618d"

[[package]]
name = "memchr"
version = "2.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f52b00d39961fc5b2736ea853c9cc86238e165017a493d1d5c8eac6bdc4cc273"

[[package]]
name = "miniz_oxide"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fa76a2c86f704bdb222d66965fb3d63269ce38518b83cb0575fca855ebb6316"
dependencies = [
 "adler2",
 "simd-adler32",
]

[[package]]
name = "mio"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69d83b0086dc8ecf3ce9ae2874b2d1290252e2a30720bea58a5c6639b0092873"
dependencies = [
 "libc",
 "wasi",
 "windows-sys 0.61.2",
]

[[package]]
name = "nix"
version = "0.30.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "74523f3a35e05aba87a1d978330aef40f67b0304ac79c1c00b294c9830543db6"
dependencies = [
 "bitflags",
 "cfg-if",
 "cfg_aliases",
 "libc",
]

[[package]]
name = "num-conv"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "51d515d32fb182ee37cda2ccdcb92950d6a3c2893aa280e540671c2cd0f3b1d9"

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
]

[[package]]
name = "num_enum"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b1207a7e20ad57b847bbddc6776b968420d38292bbfe2089accff5e19e82454c"
dependencies = [
 "num_enum_derive",
 "rustversion",
]

[[package]]
name = "num_enum_derive"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff32365de1b6743cb203b710788263c44a03de03802daf96092f2da4fe6ba4d7"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "object"
version = "0.38.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8b28f24bd43920cd8e0bc4f9c6553e8b93221c512cb9a1014987fc89d36f830"
dependencies = [
 "crc32fast",
 "hashbrown",
 "indexmap",
 "memchr",
]

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "once_cell_polyfill"
version = "1.70.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "384b8ab6d37215f3c5301a95a4accb5d64aa607f1fcb26a11b5303878451b4fe"

[[package]]
name = "parking_lot"
version = "0.12.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93857453250e3077bd71ff98b6a65ea6621a19bb0f559a85248955ac12c45a1a"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2621685985a2ebf1c516881c026032ac7deafcda1a2c9b7850dc81e3dfcb64c1"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall",
 "smallvec",
 "windows-link",
]

[[package]]
name = "paste"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57c0d7b74b563b49d38dae00a0c37d4d6de9b432382b2892f0574ddcae73fd0a"

[[package]]
name = "pbkdf2"
version = "0.12.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f8ed6a7761f76e3b9f92dfb0a60a6a6477c61024b775147ff0973a02653abaf2"
dependencies = [
 "digest",
 "hmac",
]

[[package]]
name = "pin-project-lite"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "pkg-config"
version = "0.3.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7edddbd0b52d732b21ad9a5fab5c704c14cd949e5e9a1ec5929a24fded1b904c"

[[package]]
name = "plain"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b4596b6d070b27117e987119b4dac604f3c58cfb0b191112e24771b2faeac1a6"

[[package]]
name = "powerfmt"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "439ee305def115ba05938db6eb1644ff94165c5ab5e9420d1c1bcedbba909391"

[[package]]
name = "ppmd-rust"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d558c559f0450f16f2a27a1f017ef38468c1090c9ce63c8e51366232d53717b4"

[[package]]
name = "pretty_env_logger"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "926d36b9553851b8b0005f1275891b392ee4d2d833852c417ed025477350fb9d"
dependencies = [
 "env_logger",
 "log",
]

[[package]]
name = "proc-macro2"
version = "1.0.103"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5ee95bc4ef87b8d5ba32e8b7714ccc834865276eab0aed5c9958d00ec45f49e8"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "proc-macro2-diagnostics"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "af066a9c399a26e020ada66a034357a868728e72cd426f3adcd35f80d88d88c8"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "version_check",
]

[[package]]
name = "process-memory"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ae9599c34fcc8067c3105dc746c0ce85e3ea61784568b8234179fad490b1dcc1"
dependencies = [
 "libc",
 "mach",
 "winapi",
]

[[package]]
name = "procfs"
version = "0.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "25485360a54d6861439d60facef26de713b1e126bf015ec8f98239467a2b82f7"
dependencies = [
 "bitflags",
 "chrono",
 "flate2",
 "procfs-core",
 "rustix 1.1.2",
]

[[package]]
name = "procfs-core"
version = "0.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6401bf7b6af22f78b563665d15a22e9aef27775b79b149a66ca022468a4e405"
dependencies = [
 "bitflags",
 "chrono",
 "hex",
]

[[package]]
name = "quick-error"
version = "1.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1d01941d82fa2ab50be1e79e6714289dd7cde78eba4c074bc5a4374f650dfe0"

[[package]]
name = "quote"
version = "1.0.42"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a338cc41d27e6cc6dce6cefc13a0729dfbb81c262b1f519331575dd80ef3067f"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "r-efi"
version = "5.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69cdb34c158ceb288df11e18b4bd39de994f6657d83847bdffdbd7f346754b0f"

[[package]]
name = "redox_syscall"
version = "0.5.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed2bf2547551a7053d6fdfafda3f938979645c44812fbfcda098faae3f1a362d"
dependencies = [
 "bitflags",
]

[[package]]
name = "regex"
version = "1.12.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "843bc0191f75f3e22651ae5f1e72939ab2f72a4bc30fa80a066bd66edefc24d4"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "regex-automata"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5276caf25ac86c8d810222b3dbb938e512c55c6831a10f3e6ed1c93b84041f1c"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.8.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a2d987857b319362043e95f5353c0535c1f58eec5336fdfcf626430af7def58"

[[package]]
name = "rustix"
version = "0.38.44"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fdb5bc1ae2baa591800df16c9ca78619bf65c0488b41b96ccec5d11220d8c154"
dependencies = [
 "bitflags",
 "errno",
 "libc",
 "linux-raw-sys 0.4.15",
 "windows-sys 0.59.0",
]

[[package]]
name = "rustix"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd15f8a2c5551a84d56efdc1cd049089e409ac19a3072d5037a17fd70719ff3e"
dependencies = [
 "bitflags",
 "errno",
 "libc",
 "linux-raw-sys 0.11.0",
 "windows-sys 0.61.2",
]

[[package]]
name = "rustversion"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"

[[package]]
name = "ryu"
version = "1.0.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28d3b2b1366ec20994f1fd18c3c594f05c5dd4bc44d8bb0c1c632c8d6829481f"

[[package]]
name = "scc"
version = "2.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "46e6f046b7fef48e2660c57ed794263155d713de679057f2d0c169bfc6e756cc"
dependencies = [
 "sdd",
]

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "scroll"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c1257cd4248b4132760d6524d6dda4e053bc648c9070b960929bf50cfb1e7add"
dependencies = [
 "scroll_derive",
]

[[package]]
name = "scroll_derive"
version = "0.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed76efe62313ab6610570951494bdaa81568026e0318eaa55f167de70eeea67d"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "sdd"
version = "3.0.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "490dcfcbfef26be6800d11870ff2df8774fa6e86d047e3e8c8a76b25655e41ca"

[[package]]
name = "semver"
version = "1.0.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d767eb0aabc880b29956c35734170f26ed551a859dbd361d140cdbeca61ab1e2"
dependencies = [
 "serde",
 "serde_core",
]

[[package]]
name = "serde"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a8e94ea7f378bd32cbbd37198a4a91436180c5bb472411e48b5ec2e2124ae9e"
dependencies = [
 "serde_core",
 "serde_derive",
]

[[package]]
name = "serde_core"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41d385c7d4ca58e59fc732af25c3983b67ac852c1a25000afe1175de458b67ad"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.228"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d540f220d3187173da220f885ab66608367b6574e925011a9353e4badda91d79"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "serde_json"
version = "1.0.145"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "402a6f66d8c709116cf22f558eab210f5a50187f702eb4d7e5ef38d9a7f1c79c"
dependencies = [
 "itoa",
 "memchr",
 "ryu",
 "serde",
 "serde_core",
]

[[package]]
name = "serial_test"
version = "3.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b258109f244e1d6891bf1053a55d63a5cd4f8f4c30cf9a1280989f80e7a1fa9"
dependencies = [
 "futures",
 "log",
 "once_cell",
 "parking_lot",
 "scc",
 "serial_test_derive",
]

[[package]]
name = "serial_test_derive"
version = "3.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d69265a08751de7844521fd15003ae0a888e035773ba05695c5c759a6f89eef"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "sha1"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3bf829a2d51ab4a5ddf1352d8470c140cadc8301b2ae1789db023f01cedd6ba"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "sha2"
version = "0.10.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7507d819769d01a365ab707794a4084392c824f54a7a6a7862f8c3d0892b283"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "signal-hook-registry"
version = "1.4.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7664a098b8e616bdfcc2dc0e9ac44eb231eedf41db4e9fe95d8d32ec728dedad"
dependencies = [
 "libc",
]

[[package]]
name = "simd-adler32"
version = "0.3.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d66dc143e6b11c1eddc06d5c423cfc97062865baf299914ab64caa38182078fe"

[[package]]
name = "slab"
version = "0.4.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a2ae44ef20feb57a68b23d846850f861394c2e02dc425a50098ae8c90267589"

[[package]]
name = "smallvec"
version = "1.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03"

[[package]]
name = "socket2"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17129e116933cf371d018bb80ae557e889637989d8638274fb25622827b03881"
dependencies = [
 "libc",
 "windows-sys 0.60.2",
]

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "subtle"
version = "2.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13c2bddecc57b384dee18652358fb23172facb8a2c51ccc10d74c157bdea3292"

[[package]]
name = "syn"
version = "2.0.111"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "390cc9a294ab71bdb1aa2e99d13be9c753cd2d7bd6560c77118597410c4d2e87"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "tagu"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eddb6b06d20fba9ed21fca3d696ee1b6e870bca0bcf9fa2971f6ae2436de576a"

[[package]]
name = "termcolor"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06794f8f6c5c898b3275aebefa6b8a1cb24cd2c6c79397ab15774837a0bc5755"
dependencies = [
 "winapi-util",
]

[[package]]
name = "thiserror"
version = "2.0.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f63587ca0f12b72a0600bcba1d40081f830876000bb46dd2337a3051618f4fc8"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "2.0.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3ff15c8ecd7de3849db632e14d18d2571fa09dfc5ed93479bc4485c7a517c913"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "time"
version = "0.3.44"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91e7d9e3bb61134e77bde20dd4825b97c010155709965fedf0f49bb138e52a9d"
dependencies = [
 "deranged",
 "num-conv",
 "powerfmt",
 "serde",
 "time-core",
]

[[package]]
name = "time-core"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40868e7c1d2f0b8d73e4a8c7f0ff63af4f6d19be117e90bd73eb1d62cf831c6b"

[[package]]
name = "tokio"
version = "1.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff360e02eab121e0bc37a2d3b4d4dc622e6eda3a8e5253d5435ecf5bd4c68408"
dependencies = [
 "bytes",
 "libc",
 "mio",
 "parking_lot",
 "pin-project-lite",
 "signal-hook-registry",
 "socket2",
 "tokio-macros",
 "windows-sys 0.61.2",
]

[[package]]
name = "tokio-macros"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "af407857209536a95c8e56f8231ef2c2e2aff839b22e07a1ffcbc617e9db9fa5"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "typenum"
version = "1.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "562d481066bde0658276a35467c4af00bdc6ee726305698a55b86e61d7ad82bb"

[[package]]
name = "unicode-ident"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9312f7c4f6ff9069b165498234ce8be658059c6728633667c526e27dc2cf1df5"

[[package]]
name = "utf8parse"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "wasi"
version = "0.11.1+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccf3ec651a847eb01de73ccad15eb7d99f80485de043efb2f370cd654f4ea44b"

[[package]]
name = "wasip2"
version = "1.0.1+wasi-0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0562428422c63773dad2c345a1882263bbf4d65cf3f42e90921f787ef5ad58e7"
dependencies = [
 "wit-bindgen",
]

[[package]]
name = "wasm-bindgen"
version = "0.2.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0d759f433fa64a2d763d1340820e46e111a7a5ab75f993d1852d70b03dbb80fd"
dependencies = [
 "cfg-if",
 "once_cell",
 "rustversion",
 "wasm-bindgen-macro",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48cb0d2638f8baedbc542ed444afc0644a29166f1595371af4fecf8ce1e7eeb3"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cefb59d5cd5f92d9dcf80e4683949f15ca4b511f4ac0a6e14d4e1ac60c6ecd40"
dependencies = [
 "bumpalo",
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cbc538057e648b67f72a982e708d485b2efa771e1ac05fec311f9f63e5800db4"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "which"
version = "6.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b4ee928febd44d98f2f459a4a79bd4d928591333a494a10a868418ac1b39cf1f"
dependencies = [
 "either",
 "home",
 "rustix 0.38.44",
 "winsafe",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-util"
version = "0.1.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2a7b1c03c876122aa43f3020e6c3c3ee5c05081c9a00739faf7503aeba10d22"
dependencies = [
 "windows-sys 0.61.2",
]

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows-core"
version = "0.62.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8e83a14d34d0623b51dce9581199302a221863196a1dde71a7663a4c2be9deb"
dependencies = [
 "windows-implement",
 "windows-interface",
 "windows-link",
 "windows-result",
 "windows-strings",
]

[[package]]
name = "windows-implement"
version = "0.60.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "053e2e040ab57b9dc951b72c264860db7eb3b0200ba345b4e4c3b14f67855ddf"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-interface"
version = "0.59.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f316c4a2570ba26bbec722032c4099d8c8bc095efccdc15688708623367e358"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-link"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0805222e57f7521d6a62e36fa9163bc891acd422f971defe97d64e70d0a4fe5"

[[package]]
name = "windows-result"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7781fa89eaf60850ac3d2da7af8e5242a5ea78d1a11c49bf2910bb5a73853eb5"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-strings"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7837d08f69c77cf6b07689544538e017c1bfcf57e34b4c0ff58e6c2cd3b37091"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.60.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2f500e4d28234f72040990ec9d39e3a6b950f9f22d3dba18416c35882612bcb"
dependencies = [
 "windows-targets 0.53.5",
]

[[package]]
name = "windows-sys"
version = "0.61.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ae137229bcbd6cdf0f7b80a31df61766145077ddf49416a728b02cb3921ff3fc"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm 0.52.6",
 "windows_aarch64_msvc 0.52.6",
 "windows_i686_gnu 0.52.6",
 "windows_i686_gnullvm 0.52.6",
 "windows_i686_msvc 0.52.6",
 "windows_x86_64_gnu 0.52.6",
 "windows_x86_64_gnullvm 0.52.6",
 "windows_x86_64_msvc 0.52.6",
]

[[package]]
name = "windows-targets"
version = "0.53.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4945f9f551b88e0d65f3db0bc25c33b8acea4d9e41163edf90dcd0b19f9069f3"
dependencies = [
 "windows-link",
 "windows_aarch64_gnullvm 0.53.1",
 "windows_aarch64_msvc 0.53.1",
 "windows_i686_gnu 0.53.1",
 "windows_i686_gnullvm 0.53.1",
 "windows_i686_msvc 0.53.1",
 "windows_x86_64_gnu 0.53.1",
 "windows_x86_64_gnullvm 0.53.1",
 "windows_x86_64_msvc 0.53.1",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a9d8416fa8b42f5c947f8482c43e7d89e73a173cead56d044f6a56104a6d1b53"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_aarch64_msvc"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9d782e804c2f632e395708e99a94275910eb9100b2114651e04744e9b125006"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnu"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "960e6da069d81e09becb0ca57a65220ddff016ff2d6af6a223cf372a506593a3"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_gnullvm"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa7359d10048f68ab8b09fa71c3daccfb0e9b559aed648a8f95469c27057180c"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_i686_msvc"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e7ac75179f18232fe9c285163565a57ef8d3c89254a30685b57d83a38d326c2"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnu"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c3842cdd74a865a8066ab39c8a7a473c0778a3f29370b5fd6b4b9aa7df4a499"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0ffa179e2d07eee8ad8f57493436566c7cc30ac536a3379fdf008f47f6bb7ae1"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "windows_x86_64_msvc"
version = "0.53.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d6bbff5f0aada427a1e5a6da5f1f98158182f26556f345ac9e04d36d0ebed650"

[[package]]
name = "winsafe"
version = "0.0.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d135d17ab770252ad95e9a872d365cf3090e3be864a34ab46f48555993efc904"

[[package]]
name = "wit-bindgen"
version = "0.46.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f17a85883d4e6d00e8a97c586de764dabcc06133f7f1d55dce5cdc070ad7fe59"

[[package]]
name = "zerocopy"
version = "0.8.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fd74ec98b9250adb3ca554bdde269adf631549f51d8a8f8f0a10b50f1cb298c3"
dependencies = [
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.8.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d8a8d209fdf45cf5138cbb5a506f6b52522a25afccc534d1475dad8e31105c6a"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "zeroize"
version = "1.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b97154e67e32c85465826e8bcc1c59429aaaf107c1e4a9e53c8d8ccd5eff88d0"
dependencies = [
 "zeroize_derive",
]

[[package]]
name = "zeroize_derive"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ce36e65b0d2999d2aafac989fb249189a141aee1f53c612c1f37d72631959f69"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "zip"
version = "6.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eb2a05c7c36fde6c09b08576c9f7fb4cda705990f73b58fe011abf7dfb24168b"
dependencies = [
 "aes",
 "arbitrary",
 "bzip2",
 "constant_time_eq",
 "crc32fast",
 "deflate64",
 "flate2",
 "getrandom",
 "hmac",
 "indexmap",
 "lzma-rust2",
 "memchr",
 "pbkdf2",
 "ppmd-rust",
 "sha1",
 "time",
 "zeroize",
 "zopfli",
 "zstd",
]

[[package]]
name = "zlib-rs"
version = "0.5.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "51f936044d677be1a1168fae1d03b583a285a5dd9d8cbf7b24c23aa1fc775235"

[[package]]
name = "zopfli"
version = "0.8.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f05cd8797d63865425ff89b5c4a48804f35ba0ce8d125800027ad6017d2b5249"
dependencies = [
 "bumpalo",
 "crc32fast",
 "log",
 "simd-adler32",
]

[[package]]
name = "zstd"
version = "0.13.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e91ee311a569c327171651566e07972200e76fcfe2242a4fa446149a3881c08a"
dependencies = [
 "zstd-safe",
]

[[package]]
name = "zstd-safe"
version = "7.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f49c4d5f0abb602a93fb8736af2a4f4dd9512e36f7f570d66e65ff867ed3b9d"
dependencies = [
 "zstd-sys",
]

[[package]]
name = "zstd-sys"
version = "2.0.16+zstd.1.5.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91e19ebc2adc8f83e43039e79776e3fda8ca919132d68a1fed6a5faca2683748"
dependencies = [
 "cc",
 "pkg-config",
]

```

`Cargo.toml`:

```toml
[workspace]
resolver = "2"
members = [
    "edbgserver-cli",
    "edbgserver-common",
    "edbgserver-ebpf",
]
default-members = ["edbgserver-cli", "edbgserver-common"]

[workspace.package]
license = "MIT OR Apache-2.0"
edition = "2024"

[workspace.metadata.release]
shared-version = true
publish = false
tag-name = "v{{version}}"

[workspace.dependencies]
# TODO: switch back to official aya
# aya = { git = "https://github.com/aya-rs/aya", rev = "d238b2ea6f1b2c1aa09a9050415b1c96329af0aa", default-features = false }
# aya-build = { git = "https://github.com/aya-rs/aya", rev = "d238b2ea6f1b2c1aa09a9050415b1c96329af0aa", default-features = false }
# aya-ebpf = { git = "https://github.com/aya-rs/aya", rev = "d238b2ea6f1b2c1aa09a9050415b1c96329af0aa", default-features = false }
# aya-log = { git = "https://github.com/aya-rs/aya", rev = "d238b2ea6f1b2c1aa09a9050415b1c96329af0aa", default-features = false }
# aya-log-ebpf = { git = "https://github.com/aya-rs/aya", rev = "d238b2ea6f1b2c1aa09a9050415b1c96329af0aa", default-features = false }
aya = { git = "https://github.com/Satar07/aya/", rev = "4af9109", default-features = false }
aya-build = { git = "https://github.com/Satar07/aya/", rev = "4af9109", default-features = false }
aya-ebpf = { git = "https://github.com/Satar07/aya/", rev = "4af9109", default-features = false }
aya-log = { git = "https://github.com/Satar07/aya/", rev = "4af9109", default-features = false }
aya-log-ebpf = { git = "https://github.com/Satar07/aya/", rev = "4af9109", default-features = false }
# aya = { path = "/home/cyril/repo/aya/aya" }
# aya-build = { path = "/home/cyril/repo/aya/aya-build" }
# aya-ebpf = { path = "/home/cyril/repo/aya/ebpf/aya-ebpf" }
# aya-log = { path = "/home/cyril/repo/aya/aya-log" }
# aya-log-ebpf = { path = "/home/cyril/repo/aya/ebpf/aya-log-ebpf" }



anyhow = { version = "1", default-features = false }
cargo_metadata = { version = "0.23.0", default-features = false }

clap = { version = "4.5.20", default-features = false, features = ["std"] }
pretty_env_logger  = { version = "0.4", default-features = false }
libc = { version = "0.2.159", default-features = false }
log = { version = "0.4.22", default-features = false }
tokio = { version = "1.40.0", features = ["full"] }
which = { version = "6.0.0", default-features = false }

[profile.dev]
debug = true
opt-level = 0

[profile.release]
opt-level = 3
lto = true
codegen-units = 1

[profile.release.package.edbgserver-ebpf]
debug = 2
codegen-units = 1

```

`LICENSE-APACHE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

1. Definitions.

   "License" shall mean the terms and conditions for use, reproduction,
   and distribution as defined by Sections 1 through 9 of this document.

   "Licensor" shall mean the copyright owner or entity authorized by
   the copyright owner that is granting the License.

   "Legal Entity" shall mean the union of the acting entity and all
   other entities that control, are controlled by, or are under common
   control with that entity. For the purposes of this definition,
   "control" means (i) the power, direct or indirect, to cause the
   direction or management of such entity, whether by contract or
   otherwise, or (ii) ownership of fifty percent (50%) or more of the
   outstanding shares, or (iii) beneficial ownership of such entity.

   "You" (or "Your") shall mean an individual or Legal Entity
   exercising permissions granted by this License.

   "Source" form shall mean the preferred form for making modifications,
   including but not limited to software source code, documentation
   source, and configuration files.

   "Object" form shall mean any form resulting from mechanical
   transformation or translation of a Source form, including but
   not limited to compiled object code, generated documentation,
   and conversions to other media types.

   "Work" shall mean the work of authorship, whether in Source or
   Object form, made available under the License, as indicated by a
   copyright notice that is included in or attached to the work
   (an example is provided in the Appendix below).

   "Derivative Works" shall mean any work, whether in Source or Object
   form, that is based on (or derived from) the Work and for which the
   editorial revisions, annotations, elaborations, or other modifications
   represent, as a whole, an original work of authorship. For the purposes
   of this License, Derivative Works shall not include works that remain
   separable from, or merely link (or bind by name) to the interfaces of,
   the Work and Derivative Works thereof.

   "Contribution" shall mean any work of authorship, including
   the original version of the Work and any modifications or additions
   to that Work or Derivative Works thereof, that is intentionally
   submitted to Licensor for inclusion in the Work by the copyright owner
   or by an individual or Legal Entity authorized to submit on behalf of
   the copyright owner. For the purposes of this definition, "submitted"
   means any form of electronic, verbal, or written communication sent
   to the Licensor or its representatives, including but not limited to
   communication on electronic mailing lists, source code control systems,
   and issue tracking systems that are managed by, or on behalf of, the
   Licensor for the purpose of discussing and improving the Work, but
   excluding communication that is conspicuously marked or otherwise
   designated in writing by the copyright owner as "Not a Contribution."

   "Contributor" shall mean Licensor and any individual or Legal Entity
   on behalf of whom a Contribution has been received by Licensor and
   subsequently incorporated within the Work.

2. Grant of Copyright License. Subject to the terms and conditions of
   this License, each Contributor hereby grants to You a perpetual,
   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
   copyright license to reproduce, prepare Derivative Works of,
   publicly display, publicly perform, sublicense, and distribute the
   Work and such Derivative Works in Source or Object form.

3. Grant of Patent License. Subject to the terms and conditions of
   this License, each Contributor hereby grants to You a perpetual,
   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
   (except as stated in this section) patent license to make, have made,
   use, offer to sell, sell, import, and otherwise transfer the Work,
   where such license applies only to those patent claims licensable
   by such Contributor that are necessarily infringed by their
   Contribution(s) alone or by combination of their Contribution(s)
   with the Work to which such Contribution(s) was submitted. If You
   institute patent litigation against any entity (including a
   cross-claim or counterclaim in a lawsuit) alleging that the Work
   or a Contribution incorporated within the Work constitutes direct
   or contributory patent infringement, then any patent licenses
   granted to You under this License for that Work shall terminate
   as of the date such litigation is filed.

4. Redistribution. You may reproduce and distribute copies of the
   Work or Derivative Works thereof in any medium, with or without
   modifications, and in Source or Object form, provided that You
   meet the following conditions:

   (a) You must give any other recipients of the Work or
       Derivative Works a copy of this License; and

   (b) You must cause any modified files to carry prominent notices
       stating that You changed the files; and

   (c) You must retain, in the Source form of any Derivative Works
       that You distribute, all copyright, patent, trademark, and
       attribution notices from the Source form of the Work,
       excluding those notices that do not pertain to any part of
       the Derivative Works; and

   (d) If the Work includes a "NOTICE" text file as part of its
       distribution, then any Derivative Works that You distribute must
       include a readable copy of the attribution notices contained
       within such NOTICE file, excluding those notices that do not
       pertain to any part of the Derivative Works, in at least one
       of the following places: within a NOTICE text file distributed
       as part of the Derivative Works; within the Source form or
       documentation, if provided along with the Derivative Works; or,
       within a display generated by the Derivative Works, if and
       wherever such third-party notices normally appear. The contents
       of the NOTICE file are for informational purposes only and
       do not modify the License. You may add Your own attribution
       notices within Derivative Works that You distribute, alongside
       or as an addendum to the NOTICE text from the Work, provided
       that such additional attribution notices cannot be construed
       as modifying the License.

   You may add Your own copyright statement to Your modifications and
   may provide additional or different license terms and conditions
   for use, reproduction, or distribution of Your modifications, or
   for any such Derivative Works as a whole, provided Your use,
   reproduction, and distribution of the Work otherwise complies with
   the conditions stated in this License.

5. Submission of Contributions. Unless You explicitly state otherwise,
   any Contribution intentionally submitted for inclusion in the Work
   by You to the Licensor shall be under the terms and conditions of
   this License, without any additional terms or conditions.
   Notwithstanding the above, nothing herein shall supersede or modify
   the terms of any separate license agreement you may have executed
   with Licensor regarding such Contributions.

6. Trademarks. This License does not grant permission to use the trade
   names, trademarks, service marks, or product names of the Licensor,
   except as required for reasonable and customary use in describing the
   origin of the Work and reproducing the content of the NOTICE file.

7. Disclaimer of Warranty. Unless required by applicable law or
   agreed to in writing, Licensor provides the Work (and each
   Contributor provides its Contributions) on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   implied, including, without limitation, any warranties or conditions
   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
   PARTICULAR PURPOSE. You are solely responsible for determining the
   appropriateness of using or redistributing the Work and assume any
   risks associated with Your exercise of permissions under this License.

8. Limitation of Liability. In no event and under no legal theory,
   whether in tort (including negligence), contract, or otherwise,
   unless required by applicable law (such as deliberate and grossly
   negligent acts) or agreed to in writing, shall any Contributor be
   liable to You for damages, including any direct, indirect, special,
   incidental, or consequential damages of any character arising as a
   result of this License or out of the use or inability to use the
   Work (including but not limited to damages for loss of goodwill,
   work stoppage, computer failure or malfunction, or any and all
   other commercial damages or losses), even if such Contributor
   has been advised of the possibility of such damages.

9. Accepting Warranty or Additional Liability. While redistributing
   the Work or Derivative Works thereof, You may choose to offer,
   and charge a fee for, acceptance of support, warranty, indemnity,
   or other liability obligations and/or rights consistent with this
   License. However, in accepting such obligations, You may act only
   on Your own behalf and on Your sole responsibility, not on behalf
   of any other Contributor, and only if You agree to indemnify,
   defend, and hold each Contributor harmless for any liability
   incurred by, or claims asserted against, such Contributor by reason
   of your accepting any such warranty or additional liability.

END OF TERMS AND CONDITIONS

APPENDIX: How to apply the Apache License to your work.

   To apply the Apache License to your work, attach the following
   boilerplate notice, with the fields enclosed by brackets "[]"
   replaced with your own identifying information. (Don't include
   the brackets!)  The text should be enclosed in the appropriate
   comment syntax for the file format. We also recommend that a
   file or class name and description of purpose be included on the
   same "printed page" as the copyright notice for easier
   identification within third-party archives.

Copyright 2025 Cyril

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
   limitations under the License.

```

`LICENSE-GPL2`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

                    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

                            NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

                     END OF TERMS AND CONDITIONS

```

`LICENSE-MIT`:

```
Copyright (c) 2021 Alessandro Decina

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

```

`README.md`:

```md
# edbgserver

[English](README.md) | [中文](README_zh.md)

An eBPF-powered debugger server designed to achieve minimal intrusive characteristics by bypassing the `ptrace` system call. Currently supports **Arm64** and **x86_64** architectures on **Android** and **Linux**.

![](demo.png)

## Acknowledgments

Special thanks to [ShinoLeah](https://github.com/ShinoLeah) for the project [eDBG](https://github.com/ShinoLeah/eDBG). This project derives its name and core principles from eDBG. If you find this tool helpful, please consider giving [eDBG](https://github.com/ShinoLeah/eDBG) a star as well.

## Features

- Hardware and software breakpoints.
- Single-stepping (Step-over/Step-into, implementation depends on GDB logic).
- Signal delivery.
- Reading and modifying arbitrary memory addresses.
- Register reading.
- Reading and modifying files.
- Process library information retrieval (symbol information).
- Multi-thread debugging support (defaults to single-thread mode).

## Limitations

- **Register Modification**: Due to eBPF constraints, CPU register values cannot be modified directly (can be bypassed using the `patch` command).
- **Multi-threading**: Currently unable to read registers of threads other than the one that triggered the breakpoint (Work in Progress).
- **Attachment**: Cannot "attach" to a running process immediately; must set an initial file breakpoint first (Work in Progress).
- **Namespace Isolation**: Since eBPF programs run in kernel space and are unaware of namespaces, it is recommended **not** to run this in isolated environments like WSL or Docker, as thread IDs (TIDs) may be inaccurate. Linux VMs and Android `adb shell` are unaffected.
- **Stability**: Single-stepping on `x86_64` has not been fully tested and may contain bugs.

## Usage

```sh
edbgserver [OPTIONS] --target <TARGET> --break <BREAK_POINT>

Options:
  -t, --target <TARGET>      Path to the target binary or library
  -p, --package <PACKAGE>    [Android only] The package name of target application
  -b, --break <BREAK_POINT>  The initial breakpoint address (virtual address). The server will set a UProbe at this location to intercept execution and wait for GDB. Supports hexadecimal (e.g., 0x400000) or decimal input
      --port <PORT>          The TCP port where the GDB server will listen for incoming connections [default: 3333]
  -u, --uds [<UDS>]          Use Unix Domain Socket instead of TCP. If the path starts with '@', it is treated as an Abstract Namespace Socket. If no value is provided, it defaults to the abstract socket "@edbg"
  -P, --pid <PID>            The Process ID (PID) of the target process to attach to. If omitted, the server will automatically attach to the first process that triggers the breakpoint in the specified binary
  -m, --multi-thread         Run the server in multi-threaded mode
      --no-filter            Disable filtering of memory maps when attaching to the target process. By default, the server filters out irrelevant memory maps to improve performance
      --use-uprobe           force using uprobe implementation for single-step (perf by default)
  -h, --help                 Print help (see more with '--help')
  -V, --version              Print version

```

- **target**: Path to the target file. It must be discoverable by uprobe. For Android `.so` files, providing the filename is sufficient.
- **package**: Android Target application package name. Required if debugging a `.so` within an app (unless providing an absolute path to the `.so`).
- **break**: Initial breakpoint address. This must be a **Virtual Address** (the address shown on the left side in IDA), not the file offset.
- **pid**: Filter the initial breakpoint by a specific Process ID.
- **port**: TCP port (default: 3333). Remember to use `adb forward` for Android.
- **uds**: Use Unix Domain Sockets for slightly better performance. Abstract namespaces (starting with `@`) are supported.
- **multi-thread**: Reports multi-threading info to GDB. If you are only tracing a single thread, keeping this off is recommended for simplicity.
- **no-filter**: Disables memory map filtering. Enabling this may cause severe performance degradation. Use this only if `vmmap` fails to show information.
- **use-uprobe**: Forces uprobe for single-stepping (the default uses a hybrid strategy of `perf` and `uprobe`).

### Examples

**Basic Android Debugging:**

```sh
./edbgserver -u -p io.cyril.supervipplayer -t libsupervipplayer.so -b 0x1848
adb forward tcp:3333 localabstract:edbg
pwndbg
pwndbg> target remote :3333
pwndbg> breakrva 0x18A8 libsupervipplayer.so
```

**Optimization for Android:**
Pulling libraries from the device during debugging can be extremely slow. Use the `android_lib_pull.sh` script in the root directory to batch-pull common libraries and the target APK's libs to your local machine:

```sh
./android_lib_pull.sh io.cyril.supervipplayer
pwndbg
pwndbg> set sysroot android_sysroot/
pwndbg> set breakpoint auto-hw on
pwndbg> target remote :3333
```

## Installation

Download the corresponding binary for your architecture from the **Releases** page. The program is statically built with `musl` and requires no additional dependencies.

## Building from Source

### Prerequisites

1. Install rustup: `curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh`
2. Install Stable Rust: `rustup toolchain install stable`
3. Install Nightly Rust: `rustup toolchain install nightly --component rust-src`
4. Add target architecture: `rustup target add ${ARCH}-unknown-linux-musl`
5. Install LLVM:
    - **macOS**: `brew install llvm` (and add to PATH)
    - **Linux**: `bash -c "$(wget -O - https://apt.llvm.org/llvm.sh)"`
6. Install musl C toolchain:
    - **macOS**: `brew install filosottile/musl-cross/musl-cross`
    - **Linux**: Download and add `aarch64-linux-musl-cross.tgz` or `x86_64-linux-musl-cross.tgz` to your PATH.
7. Install bpf-linker: `cargo install bpf-linker`

### Build Commands

The project uses build scripts to automatically compile eBPF code and link it (based on the `aya` framework).

```sh
cargo check --target x86_64-unknown-linux-musl
cargo run --release --target aarch64-unknown-linux-musl
cargo build --release --target aarch64-unknown-linux-musl
```

_Note: Refer to `.cargo/config.toml` for cross-compilation configurations._

## License

With the exception of eBPF code, edbgserver is distributed under the terms
of either the [MIT license] or the [Apache License] (version 2.0), at your
option.

Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in this crate by you, as defined in the Apache-2.0 license, shall
be dual licensed as above, without any additional terms or conditions.

### eBPF

All eBPF code is distributed under either the terms of the
[GNU General Public License, Version 2] or the [MIT license], at your
option.

Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in this project by you, as defined in the GPL-2 license, shall be
dual licensed as above, without any additional terms or conditions.

[Apache license]: LICENSE-APACHE
[MIT license]: LICENSE-MIT
[GNU General Public License, Version 2]: LICENSE-GPL2

```

`README_zh.md`:

```md
# edbgserver

[English](README.md) | [中文](README_zh.md)

一个基于 **eBPF** 实现的调试器服务端，旨在脱离 `ptrace` 系统调用以实现最小侵入特征，无视大部分调试限制。目前支持 **Android** 与 **Linux** 下的 Arm64 和 x86_64 架构。

![](demo.png)

## 致谢

特别感谢学长 [ShinoLeah](https://github.com/ShinoLeah) 的项目 [eDBG](https://github.com/ShinoLeah/eDBG)。本项目的名字还有原理均出于此，如果本项目帮到你的话也请给 [eDBG](https://github.com/ShinoLeah/eDBG) 一个星吧。

## 支持功能

- 硬件软件断点
- 单步步进步过（和gdb实现有关）
- 信号发送
- 读取修改任意地址内存
- 读取寄存器
- 读取修改文件
- 进程库信息获取（符号信息）
- 多线程调试支持（默认多线程当成单线程调试）

## 局限

- 由于ebpf的限制，目前无法修改 CPU 寄存器的值（但是可以用 patch 指令代替操作）
- 无法读取当前触发中断以外的其他线程的寄存器（todo）
- 无法 attach 进程，只能先下文件断点（todo）
- 由于 ebpf 程序运行在内核态，对 namespace 无感知，所以最好不要在 WSL 或者 docker 等隔离环境下运行，否则获取到的线程号信息会不准确，可能影响部分功能。Linux 虚拟机和安卓 adb shell 无影响
- x86_64 单步断点未充分测试，可能会有些 bug

## 使用方法

```sh
edbgserver [OPTIONS] --target <TARGET> --break <BREAK_POINT>

Options:
  -t, --target <TARGET>      Path to the target binary or library
  -p, --package <PACKAGE>    [Android only] The package name of target application
  -b, --break <BREAK_POINT>  The initial breakpoint address (virtual address). The server will set a UProbe at this location to intercept execution and wait for GDB. Supports hexadecimal (e.g., 0x400000) or decimal input
      --port <PORT>          The TCP port where the GDB server will listen for incoming connections [default: 3333]
  -u, --uds [<UDS>]          Use Unix Domain Socket instead of TCP. If the path starts with '@', it is treated as an Abstract Namespace Socket. If no value is provided, it defaults to the abstract socket "@edbg"
  -P, --pid <PID>            The Process ID (PID) of the target process to attach to. If omitted, the server will automatically attach to the first process that triggers the breakpoint in the specified binary
  -m, --multi-thread         Run the server in multi-threaded mode
      --no-filter            Disable filtering of memory maps when attaching to the target process. By default, the server filters out irrelevant memory maps to improve performance
      --use-uprobe           force using uprobe implementation for single-step (perf by default)
  -h, --help                 Print help (see more with '--help')
  -V, --version              Print version
```

- **target**：目标文件路径，需要 uprobe 能够找得到。如果是安卓 app 的 so 就写名字就行
- **package**：指定包名，如果目标是安卓 app 下的 so 文件则需要提供包名（或者不提供直接写好so的绝对路径也行）
- **break**：指定初始断点地址，注意是虚拟地址，ida直接打开来左边显示的那个，不是文件偏移别搞错了。
- **port**：指定端口号，默认3333。安卓记得 adb forward
- **uds**：指定使用 Unix Domain Socket，如果路径以 '@' 开头，则被视为抽象命名空间套接字。如果未提供值，则默认为抽象套接字 "@edbg"。可以稍稍提高性能，安卓记得 forward localabstract
- **pid**：初始断点过滤指定的进程 ID
- **multi-thread**：指定需要传送多线程信息给gdb，如果你只是在一个线程上跟踪程序那就最好不用开（开了也只能感叹，哇，好多线程啊）
- **no-filter**：禁用对 /proc/pid/maps 文件信息过滤，这会导致性能严重下降。如果 vmmap 看不到信息了可以考虑开一下或者提个白名单 issue
- **use-uprobe**：强制使用 uprobe 实现单步调试（默认使用perf和uprobe综合策略）

一些例子：

```sh
./edbgserver -u -p io.cyril.supervipplayer -t libsupervipplayer.so -b 0x1848
adb forward tcp:3333 localabstract:edbg
pwndbg
pwndbg> target remote :3333
pwndbg> breakrva 0x18A8 libsupervipplayer.so
```

在调试安卓的时候因为本机拿不到远程的库文件，所以需要每次都从远端拉下来，这会非常非常慢。这个时候可以用根目录下的 `android_lib_pull.sh` 脚本先把一些常用库还有目标apk下的库给打包一次性拉下来，然后gdb设置查找路径。设置完成后每次调试都能够秒开了

```sh
./android_lib_pull.sh io.cyril.supervipplayer
pwndbg
pwndbg> set sysroot android_sysroot/
pwndbg> set breakpoint auto-hw on
pwndbg> target remote :3333
```

_建议配合 pwndbg 食用_

## 安装

在 release 里面下载对应架构的二进制文件运行即可，本程序基于 musl 静态构建，无需额外安装依赖。

## 构建

编译环境安装：

1. 安装 rustup：`curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh`
2. 安装 Stable Rust 工具链：`rustup toolchain install stable`
3. 安装 Nightly Rust 工具链：`rustup toolchain install nightly --component rust-src`
4. 添加 Rust 目标架构：`rustup target add ${ARCH}-unknown-linux-musl`
5. 安装 LLVM：
    - MacOS：`brew install llvm` 并添加到环境变量 PATH
    - Linux：`bash -c "$(wget -O - https://apt.llvm.org/llvm.sh)"`
6. 安装 musl C 工具链：
    - MacOS：`brew install filosottile/musl-cross/musl-cross`
    - Linux：下载并添加 `aarch64-linux-musl-cross.tgz` 或 `x86_64-linux-musl-cross.tgz` 到 PATH
7. 安装 bpf-linker：`cargo install bpf-linker`

之后 `cargo check`, `cargo build` 应该能够正常使用了

```sh
cargo check --target x86_64-unknown-linux-musl
cargo run --release --target aarch64-unknown-linux-musl
cargo build --release --target aarch64-unknown-linux-musl
```

项目使用构建脚本自动编译 eBPF 代码并将其链接至程序中，具体原理参考 aya。交叉编译部分可参考 `.cargo/config.toml` 文件

## 开源协议

除 eBPF 代码外，`edbgserver` 遵循 [MIT 协议] 或 [Apache 协议 (2.0版本)] 开源，您可以择其一使用。除非您另有明确说明，否则根据 Apache-2.0 协议定义，您有意提交并包含在本库中的任何贡献都将按照上述方式双重授权，且不附加任何额外条款或条件。

### eBPF

所有 eBPF 代码均遵循 [GNU 通用公共许可协议第 2 版 (GPLv2)] 或 [MIT 协议] 开源，您可以择其一使用。除非您另有明确说明，否则根据 GPL-2 协议定义，您有意提交并包含在本项目中的任何贡献都将按照上述方式双重授权，且不附加任何额外条款或条件。

[Apache 协议 (2.0版本)]: LICENSE-APACHE
[MIT 协议]: LICENSE-MIT
[GNU 通用公共许可协议第 2 版 (GPLv2)]: LICENSE-GPL2

```

`android_lib_pull.sh`:

```sh
#!/bin/bash

PKG_NAME=$1
SYSROOT="./android_sysroot"
TEMP_TAR="/data/local/tmp/sysroot_temp.tar"

PATHS_TO_PULL=(
    "/system/lib64"
    "/system/bin"
    "/vendor/lib64"
    "/apex/com.android.runtime"
    "/apex/com.android.art"
    "/apex/com.android.tethering"
)

adb get-state 1>/dev/null 2>&1
if [ $? -ne 0 ]; then
    echo "adb not connected"
    exit 1
fi

APP_LIB_PATHS=()
if [ ! -z "$PKG_NAME" ]; then

    APK_PATH=$(adb shell pm path "$PKG_NAME" 2>/dev/null | head -n 1 | cut -d : -f 2)

    if [ -z "$APK_PATH" ]; then
        echo "cannot find'$PKG_NAME'"
        echo "------------------------------------------------"
        adb shell pm list package -3 | cut -d : -f 2
        exit 1
    fi

    APP_BASE_DIR=$(dirname "$APK_PATH")
    LIB_EXISTS=$(adb shell "ls -d $APP_BASE_DIR/lib 2>/dev/null")
    if [ ! -z "$LIB_EXISTS" ]; then
        APP_LIB_PATHS+=("$APP_BASE_DIR/lib")
        APP_LIB_PATHS+=("$APP_BASE_DIR/oat")
    fi
fi

TOTAL_PATHS=("${PATHS_TO_PULL[@]}" "${APP_LIB_PATHS[@]}")
adb shell "tar -cvf $TEMP_TAR ${TOTAL_PATHS[*]} 2>/dev/null"
mkdir -p "$SYSROOT"
adb pull "$TEMP_TAR" "$SYSROOT/sysroot.tar"
tar -xvf "$SYSROOT/sysroot.tar" -C "$SYSROOT"
rm "$SYSROOT/sysroot.tar"
adb shell rm "$TEMP_TAR"

echo "------------------------------------------------"
echo "[*] pwndbg> set sysroot $(realpath "$SYSROOT")"

```

`edbgserver-cli/Cargo.toml`:

```toml
[package]
name = "edbgserver-cli"
version = "1.0.1"
edition.workspace = true
description = "CLI for edbgserver: A GDB stub powered by eBPF"
repository = "https://github.com/Satar07/edbgserver"
license.workspace = true

[dependencies]
edbgserver-common = { path = "../edbgserver-common", features = ["user"] }

anyhow = { workspace = true, default-features = true }
aya = { workspace = true }
aya-log = { workspace = true }
pretty_env_logger = { workspace = true }
libc = { workspace = true }
log = { workspace = true }
tokio = { workspace = true, features = [
    "macros",
    "rt",
    "rt-multi-thread",
    "net",
    "signal",
] }
clap = { workspace = true, features = ["cargo", "color", "default", "derive"] }
serial_test = "3.2.0"
# TODO: switch to official gdbstub
gdbstub = {git = "https://github.com/Satar07/gdbstub/", rev = "993a560"}
gdbstub_arch = {git = "https://github.com/Satar07/gdbstub/", rev = "993a560"}
procfs = "0.18.0"
process-memory = "0.5.0"
nix = {version = "0.30.1", features = ["resource", "poll"]}
capstone = "0.13.0"
clap-num = "1.2.0"
zip = "6.0.0"
zerocopy = {version= "0.8.31", features = ["derive"] }
goblin = "0.10.4"
tagu = "0.1.6"
[build-dependencies]
anyhow = { workspace = true }
aya-build = { workspace = true }
cargo_metadata = { workspace = true }
# TODO(https://github.com/rust-lang/cargo/issues/12375): this should be an artifact dependency, but
# it's not possible to tell cargo to use `-Z build-std` to build it. We cargo-in-cargo in the build
# script to build this, but we want to teach cargo about the dependecy so that cache invalidation
# works properly.
#
# Note also that https://github.com/rust-lang/cargo/issues/10593 occurs when `target = ...` is added
# to an artifact dependency; it seems possible to work around that by setting `resolver = "1"` in
# Cargo.toml in the workspace root.
#
# Finally note that *any* usage of `artifact = ...` in *any* Cargo.toml in the workspace breaks
# workflows with stable cargo; stable cargo outright refuses to load manifests that use unstable
# features.
edbgserver-ebpf = { path = "../edbgserver-ebpf" }

[[bin]]
name = "edbgserver"
path = "src/main.rs"

```

`edbgserver-cli/build.rs`:

```rs
use anyhow::{Context as _, anyhow};
use aya_build::Toolchain;

fn main() -> anyhow::Result<()> {
    let cargo_metadata::Metadata { packages, .. } = cargo_metadata::MetadataCommand::new()
        .no_deps()
        .exec()
        .context("MetadataCommand::exec")?;
    let ebpf_package = packages
        .into_iter()
        .find(|cargo_metadata::Package { name, .. }| name.as_str() == "edbgserver-ebpf")
        .ok_or_else(|| anyhow!("edbgserver-ebpf package not found"))?;
    let cargo_metadata::Package {
        name,
        manifest_path,
        ..
    } = ebpf_package;
    let ebpf_package = aya_build::Package {
        name: name.as_str(),
        root_dir: manifest_path
            .parent()
            .ok_or_else(|| anyhow!("no parent for {manifest_path}"))?
            .as_str(),
        ..Default::default()
    };
    aya_build::build_ebpf([ebpf_package], Toolchain::default())
}

```

`edbgserver-cli/src/connection.rs`:

```rs
use std::{
    io::{self, BufRead, BufReader, BufWriter, Read, Write},
    net::TcpStream,
    os::{fd::AsFd, unix::net::UnixStream},
};

pub struct BufferedConnection {
    stream_reader: BufReader<GdbStream>,
    stream_writer: BufWriter<GdbStream>,
}

pub enum GdbStream {
    Tcp(TcpStream),
    Unix(UnixStream),
}

impl Read for GdbStream {
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        match self {
            Self::Tcp(s) => s.read(buf),
            Self::Unix(s) => s.read(buf),
        }
    }
}

impl Write for GdbStream {
    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
        match self {
            Self::Tcp(s) => s.write(buf),
            Self::Unix(s) => s.write(buf),
        }
    }

    fn flush(&mut self) -> io::Result<()> {
        match self {
            Self::Tcp(s) => s.flush(),
            Self::Unix(s) => s.flush(),
        }
    }
}

impl AsFd for GdbStream {
    fn as_fd(&self) -> std::os::unix::prelude::BorrowedFd<'_> {
        match self {
            Self::Tcp(s) => s.as_fd(),
            Self::Unix(s) => s.as_fd(),
        }
    }
}

impl GdbStream {
    pub fn try_clone(&self) -> io::Result<Self> {
        match self {
            Self::Tcp(s) => Ok(Self::Tcp(s.try_clone()?)),
            Self::Unix(s) => Ok(Self::Unix(s.try_clone()?)),
        }
    }
}

impl BufferedConnection {
    pub fn new(stream: GdbStream) -> io::Result<Self> {
        if let GdbStream::Tcp(ref tcp) = stream {
            tcp.set_nodelay(true)?;
        }

        let writer_stream = stream.try_clone()?;
        Ok(Self {
            stream_reader: BufReader::with_capacity(4096, stream),
            stream_writer: BufWriter::with_capacity(4096, writer_stream),
        })
    }

    pub fn has_buffered_data(&self) -> bool {
        !self.stream_reader.buffer().is_empty()
    }
}

impl gdbstub::conn::Connection for BufferedConnection {
    type Error = io::Error;

    fn write(&mut self, byte: u8) -> Result<(), Self::Error> {
        self.stream_writer.write_all(&[byte])
    }

    fn write_all(&mut self, buf: &[u8]) -> Result<(), Self::Error> {
        self.stream_writer.write_all(buf)
    }

    fn flush(&mut self) -> Result<(), Self::Error> {
        Ok(())
    }
}

impl gdbstub::conn::ConnectionExt for BufferedConnection {
    fn read(&mut self) -> Result<u8, Self::Error> {
        self.stream_writer.flush()?;
        let mut buf = [0u8; 1];
        self.stream_reader.read_exact(&mut buf)?;
        Ok(buf[0])
    }

    fn peek(&mut self) -> Result<Option<u8>, Self::Error> {
        self.stream_writer.flush()?;
        let buf = self.stream_reader.fill_buf()?;
        if buf.is_empty() {
            return Ok(None);
        }
        Ok(Some(buf[0]))
    }
}

impl AsFd for BufferedConnection {
    fn as_fd(&self) -> std::os::unix::prelude::BorrowedFd<'_> {
        self.stream_reader.get_ref().as_fd()
    }
}

```

`edbgserver-cli/src/event.rs`:

```rs
use std::{io, os::fd::AsFd};

use edbgserver_common::DataT;
use gdbstub::{
    common::Signal,
    conn::ConnectionExt,
    stub::{
        MultiThreadStopReason,
        run_blocking::{BlockingEventLoop, Event, WaitForStopReasonError},
    },
    target::Target,
};
use log::{debug, info, warn};
use nix::poll::{PollFd, PollFlags, PollTimeout, poll};

use crate::{connection::BufferedConnection, target::EdbgTarget, utils::send_sig_to_process};

pub struct EdbgEventLoop {}

type StopError = WaitForStopReasonError<<EdbgTarget as Target>::Error, std::io::Error>;
type StopEvent = Event<MultiThreadStopReason<u64>>;

impl EdbgEventLoop {
    /// Polls both the connection and the target file descriptors.
    /// Returns a tuple of booleans: (connection_readable, target_readable).
    fn poll_resources(
        conn: &mut BufferedConnection,
        target: &EdbgTarget,
    ) -> Result<(bool, bool), StopError> {
        let conn_fd = conn.as_fd();
        let target_fd = target.notifier.as_fd();

        let mut fds = [
            PollFd::new(conn_fd, PollFlags::POLLIN),
            PollFd::new(target_fd, PollFlags::POLLIN),
        ];

        if let Err(e) = poll(&mut fds, PollTimeout::NONE) {
            if e == nix::errno::Errno::EINTR {
                return Ok((false, false));
            }
            return Err(WaitForStopReasonError::Connection(io::Error::from(e)));
        }

        let conn_revents = fds[0].revents();
        let target_revents = fds[1].revents();

        Ok((
            conn_revents.is_some_and(|r| r.contains(PollFlags::POLLIN)),
            target_revents.is_some_and(|r| r.contains(PollFlags::POLLIN)),
        ))
    }

    /// Checks if there is incoming data from GDB.
    fn check_connection(conn: &mut BufferedConnection) -> Result<Option<StopEvent>, StopError> {
        match conn.peek() {
            Ok(Some(byte)) => Ok(Some(Event::IncomingData(byte))),
            Ok(None) => Ok(None),
            Err(e) => Err(WaitForStopReasonError::Connection(e)),
        }
    }

    /// Consumes events from the ring buffer, applies PID/TID filtering logic,
    /// and returns a list of valid pending events.
    fn collect_valid_events(target: &mut EdbgTarget) -> Vec<DataT> {
        let mut pending_events = Vec::new();

        debug!(
            "bound tid: {:?}, bound pid: {:?}",
            target.bound_tid, target.bound_pid
        );

        // HACK: Handling PID/TID mismatch in Linux Namespaces (e.g., WSL, Docker).
        //
        // The PID/TID captured by eBPF are global IDs from the root namespace. However,
        // when edbgserver runs inside a child namespace, these IDs are invalid for
        // local operations. Since escaping the namespace to find the PID mapping is
        // difficult, we use a heuristic approach:
        //
        // 1. PID Overriding: We assume the event belongs to our target process and
        //    manually overwrite the event's PID with our locally known `bound_pid`.
        // 2. TID Limitation: We cannot reliably map the global TID back to the local
        //    namespace. Therefore, we prefer using PID-based operations (like memory
        //    reading) whenever possible.
        //
        // Note: This creates a strict one-way flow. Local IDs can be sent to eBPF,
        // but IDs received from eBPF must be treated as unreliable in this namespace.
        while let Some(item) = target.ring_buf.next() {
            let ptr = item.as_ptr() as *const DataT;
            let data = unsafe { std::ptr::read_unaligned(ptr) };

            debug!(
                "Received event: PID={}, TID={}, PC={:#x}, FA={:#x}, SRC={:?}",
                data.pid,
                data.tid,
                data.pc(),
                data.fault_addr,
                data.event_source
            );

            if let Some(b_tid) = target.bound_tid
                && !target.is_multi_thread
                && data.tid != b_tid
            {
                continue;
            }

            // don't check the pid
            pending_events.push(DataT {
                pid: target.bound_pid.unwrap(),
                ..data
            });
        }

        pending_events
    }

    /// Selects the best event from pending events (prioritizing Uprobes),
    /// updates the target context, and returns the StopEvent.
    fn resolve_stop_event(
        target: &mut EdbgTarget,
        pending_events: Vec<DataT>,
    ) -> Result<Option<StopEvent>, StopError> {
        if pending_events.is_empty() {
            return Ok(None);
        }

        // uprobe is preferred to prevent perf event in 'uprobe single step area'
        let best_event = pending_events
            .iter()
            .find(|e| e.event_source == edbgserver_common::EdbgSource::Uprobe)
            .or_else(|| pending_events.last());

        if let Some(data) = best_event {
            info!(
                "Event! PID: {}, TID: {}, PC: {:#x}",
                data.pid,
                data.tid,
                data.pc()
            );

            target.context = Some(*data);
            let stop_reason = target.determine_stop_reason(data.tid, data.pc(), data.fault_addr);

            target
                .handle_trap()
                .map_err(WaitForStopReasonError::Target)?;

            Ok(Some(Event::TargetStopped(stop_reason)))
        } else {
            warn!("Received events but all were kernel-space traps. Ignoring.");
            for e in pending_events {
                debug!("Ignored artifact: PC={:#x}", e.pc());
            }
            Ok(None)
        }
    }

    /// Handles the entire flow when the target fd is readable.
    fn handle_target_activity(target: &mut EdbgTarget) -> Result<Option<StopEvent>, StopError> {
        let pending_events = Self::collect_valid_events(target);

        if pending_events.is_empty() {
            // however, the target has been stopped. so we must continue it again
            if let Some(pid) = target.bound_pid {
                send_sig_to_process(pid, &Signal::SIGCONT);
            }
            return Ok(None);
        }

        Self::resolve_stop_event(target, pending_events)
    }
}

impl BlockingEventLoop for EdbgEventLoop {
    type Connection = BufferedConnection;
    type StopReason = MultiThreadStopReason<u64>;
    type Target = EdbgTarget;

    fn wait_for_stop_reason(
        target: &mut Self::Target,
        conn: &mut Self::Connection,
    ) -> Result<
        Event<Self::StopReason>,
        WaitForStopReasonError<<Self::Target as Target>::Error, std::io::Error>,
    > {
        info!("Waiting for target to stop...");

        loop {
            if conn.has_buffered_data()
                && let Some(event) = Self::check_connection(conn)?
            {
                return Ok(event);
            }
            let (conn_ready, target_ready) = Self::poll_resources(conn, target)?;

            // Handle Connection Activity
            if conn_ready && let Some(event) = Self::check_connection(conn)? {
                return Ok(event);
            }

            // Handle Target Activity
            if target_ready && let Some(event) = Self::handle_target_activity(target)? {
                return Ok(event);
            }
        }
    }

    fn on_interrupt(
        target: &mut Self::Target,
    ) -> Result<Option<Self::StopReason>, <Self::Target as Target>::Error> {
        debug!(
            "GDB sent interrupt (Ctrl-C), stopping target pid {}",
            target.get_pid()?
        );
        send_sig_to_process(target.get_pid()?, &Signal::SIGSTOP);
        Ok(Some(MultiThreadStopReason::Signal(Signal::SIGSTOP)))
    }
}

```

`edbgserver-cli/src/main.rs`:

```rs
use anyhow::{Context, Result, bail};
use clap::{
    Parser,
    builder::{
        Styles,
        styling::{AnsiColor, Effects},
    },
};
use clap_num::maybe_hex;
use gdbstub::stub::{DisconnectReason, GdbStubBuilder};
use log::{debug, error, info, warn};
use nix::sys::resource::{self, Resource, setrlimit};
use tokio::net::{TcpListener, UnixListener};

use crate::{
    connection::{BufferedConnection, GdbStream},
    event::EdbgEventLoop,
    target::EdbgTarget,
};
mod connection;
mod event;
mod resolve_target;
mod target;
mod utils;
mod virtual_file;

fn get_styles() -> Styles {
    Styles::styled()
        .header(AnsiColor::Green.on_default() | Effects::BOLD | Effects::UNDERLINE)
        .usage(AnsiColor::Green.on_default() | Effects::BOLD)
        .literal(AnsiColor::Cyan.on_default() | Effects::BOLD)
        .placeholder(AnsiColor::Cyan.on_default())
}

#[derive(Debug, Parser)]
#[command(
    version,
    about = "An eBPF-powered debugger server",
    styles = get_styles(),
    long_about = r#"An eBPF-powered debugger server

Operational Workflow:
  Step 1: Wait for Target Initial Trap
          The server installs a UProbe and waits for the target to hit the specified breakpoint.

  Step 2: Target Ready & GDB Connect
          Once the trap is caught, the server opens the TCP port and waits for a GDB client to connect.

Logging & Debugging:
  This tool uses `env_logger`. You can control log verbosity via the RUST_LOG environment variable.
  Available levels: error, warn, info, debug, trace.

  Example:
    RUST_LOG=info ./edbgserver -t ./target -b 0x401000
    ./edbgserver -p io.cyril.supervipplayer -t libsupervipplayer.so -b 0x17E0
"#
)]
struct Cli {
    /// Path to the target binary or library.
    #[arg(short, long, value_hint = clap::ValueHint::FilePath)]
    target: String,

    /// [Android only] The package name of target application.
    #[arg(short = 'p', long)]
    package: Option<String>,

    /// The initial breakpoint address (virtual address).
    /// The server will set a UProbe at this location to intercept execution and
    /// wait for GDB. Supports hexadecimal (e.g., 0x400000) or decimal
    /// input.
    #[arg(short = 'b', long = "break", value_parser = maybe_hex::<u64>)]
    break_point: u64,

    /// The TCP port where the GDB server will listen for incoming connections.
    #[arg(long, default_value_t = 3333)]
    port: u16,

    /// Use Unix Domain Socket instead of TCP.
    /// If the path starts with '@', it is treated as an Abstract Namespace
    /// Socket. If no value is provided, it defaults to the abstract socket
    /// "@edbg".
    #[arg(short, long, value_hint = clap::ValueHint::FilePath, num_args = 0..=1, default_missing_value = "@edbg")]
    uds: Option<String>,

    /// The Process ID (PID) of the target process to attach to.
    /// If omitted, the server will automatically attach to the first process
    /// that triggers the breakpoint in the specified binary.
    #[arg(short = 'P', long)]
    pid: Option<u32>,

    /// Run the server in multi-threaded mode.
    #[arg(short = 'm', long)]
    multi_thread: bool,

    /// Disable filtering of memory maps when attaching to the target process.
    /// By default, the server filters out irrelevant memory maps to improve
    /// performance.
    #[arg(long = "no-filter")]
    map_filter_off: bool,

    /// force using uprobe implementation for single-step (perf by default)
    #[arg(long = "use-uprobe")]
    step_use_uprobe: bool,
}

#[tokio::main]
async fn main() -> Result<()> {
    debug!("start edbgserver at pid: {}", std::process::id());
    pretty_env_logger::init();
    let opt = Cli::parse();
    let (init_uprobe_file_path, init_uprobe_file_offset) =
        resolve_target::resolve_target(&opt.target, opt.package.as_deref(), opt.break_point)?;

    let ebpf = init_aya();

    // main target new
    let mut edbg_target = EdbgTarget::new(
        ebpf,
        opt.multi_thread,
        !opt.map_filter_off,
        opt.step_use_uprobe,
    );
    edbg_target
        .attach_init_probe(init_uprobe_file_path, init_uprobe_file_offset, opt.pid)
        .context("Failed to attach init probe, make sure breakpoint and target is valid")?;

    println!("Step 1: Waiting for Target Initial Trap...");

    match edbg_target.wait_for_init_trap().await {
        Ok(_) => info!("Target context captured successfully via eBPF"),
        Err(e) => bail!("Failed to catch initial trap: {}", e),
    }

    let connection_stream = if let Some(uds_path) = opt.uds {
        let uds_path = if let Some(name) = uds_path.strip_prefix('@') {
            "\0".to_owned() + name
        } else {
            let _ = std::fs::remove_file(&uds_path);
            uds_path
        };
        let listener =
            UnixListener::bind(&uds_path).context("Failed to bind Unix Domain Socket listener")?;
        println!(
            "Step 2: Target Ready. Waiting for GDB connect on unix socket: {}",
            uds_path
        );
        let (stream, _addr) = listener
            .accept()
            .await
            .context("Failed to accept GDB connection on UDS")?;
        let std_stream = stream.into_std()?;
        std_stream.set_nonblocking(false)?;
        GdbStream::Unix(std_stream)
    } else {
        let listen_addr = format!("0.0.0.0:{}", opt.port);
        let listener = TcpListener::bind(&listen_addr)
            .await
            .context("Failed to bind TCP listener")?;
        println!(
            "Step 2: Target Ready. Waiting for GDB connect on {}",
            listen_addr
        );
        let (stream, a) = listener
            .accept()
            .await
            .context("Failed to accept GDB connection")?;
        info!("GDB connected from {}", a);

        let std_stream = stream.into_std()?;
        std_stream.set_nonblocking(false)?;

        GdbStream::Tcp(std_stream)
    };

    let connection = BufferedConnection::new(connection_stream)?;
    let gdb = GdbStubBuilder::new(connection)
        .packet_buffer_size(4096)
        .build()?;

    // main run
    match gdb.run_blocking::<EdbgEventLoop>(&mut edbg_target) {
        Ok(disconnect_reason) => match disconnect_reason {
            DisconnectReason::Disconnect => info!("GDB Disconnected"),
            DisconnectReason::TargetExited(code) => info!("Target exited with code {}", code),
            DisconnectReason::TargetTerminated(sig) => {
                info!("Target terminated with signal {}", sig)
            }
            DisconnectReason::Kill => {
                info!("GDB sent Kill command");
            }
        },
        Err(e) => warn!("GDBStub Error: {}", e),
    }
    Ok(())
}

fn init_aya() -> aya::Ebpf {
    pretty_env_logger::try_init().ok();
    if let Err(e) = setrlimit(
        Resource::RLIMIT_MEMLOCK,
        resource::RLIM_INFINITY,
        resource::RLIM_INFINITY,
    ) {
        error!("remove limit on locked memory failed: {}", e);
        error!("NOTE: run as root or with sudo");
    }
    let mut ebpf = aya::Ebpf::load(aya::include_bytes_aligned!(concat!(
        env!("OUT_DIR"),
        "/edbgserver"
    )))
    .expect("Failed to load eBPF program");
    match aya_log::EbpfLogger::init(&mut ebpf) {
        Err(e) => {
            // This can happen if you remove all log statements from your eBPF program.
            warn!("failed to initialize eBPF logger: {e}");
        }
        Ok(logger) => {
            let mut logger =
                tokio::io::unix::AsyncFd::with_interest(logger, tokio::io::Interest::READABLE)
                    .expect("Failed to create AsyncFd for logger");
            tokio::task::spawn(async move {
                loop {
                    let mut guard = logger.readable_mut().await.unwrap();
                    guard.get_inner_mut().flush();
                    guard.clear_ready();
                }
            });
        }
    }
    ebpf
}

```

`edbgserver-cli/src/resolve_target.rs`:

```rs
use std::{
    fs::{self, File},
    io,
    path::{Path, PathBuf},
    process::Command,
};

use anyhow::{Context, Result, anyhow, bail};
use goblin::elf::Elf;
use log::{debug, info};
use zip::ZipArchive;

/// Resolve the target library path and break point offset for uprobe to attach.
/// Returns a tuple of (library_path, resolved_file_offset).
pub fn resolve_target(
    target: &str,
    package: Option<&str>,
    break_point: u64,
) -> Result<(PathBuf, u64)> {
    let library_path = if let Some(pkg_name) = package {
        let apk_path = find_apk_path_for_package(pkg_name)
            .context(format!("Could not find APK for package: {}", pkg_name))?;

        info!("Found APK for package {}: {:?}", pkg_name, apk_path);

        if let Some(extracted_path) = try_find_extracted_library(&apk_path, target) {
            info!("Found extracted library on disk: {:?}", extracted_path);
            extracted_path
        } else {
            let out_path = extract_so_from_apk(&apk_path, target)
                .context("Failed to extract native library from APK")?;
            info!("Extracted {} to {:?}", target, out_path);
            out_path
        }
    } else {
        PathBuf::from(target)
    };

    let file_offset = translate_vaddr_to_offset(&library_path, break_point)
        .context("Failed to resolve virtual address to file offset")?;

    info!(
        "Resolved breakpoint: 0x{:x} (Virtual) -> 0x{:x} (Offset)",
        break_point, file_offset
    );

    Ok((library_path, file_offset))
}

fn translate_vaddr_to_offset(path: &Path, vaddr: u64) -> Result<u64> {
    let buffer = fs::read(path).context("Failed to read ELF file for parsing")?;

    let elf = Elf::parse(&buffer).context("Failed to parse ELF headers")?;

    for ph in elf.program_headers {
        if ph.p_type == goblin::elf::program_header::PT_LOAD {
            // [p_vaddr, p_vaddr + p_memsz)
            if vaddr >= ph.p_vaddr && vaddr < (ph.p_vaddr + ph.p_memsz) {
                // File Offset = Target VAddr - Segment VAddr + Segment File Offset
                let offset = vaddr - ph.p_vaddr + ph.p_offset;
                debug!(
                    "Found address 0x{:x} in segment [VAddr: 0x{:x}, Offset: 0x{:x}]. Calculated offset: 0x{:x}",
                    vaddr, ph.p_vaddr, ph.p_offset, offset
                );
                return Ok(offset);
            }
        }
    }

    bail!(
        "Address 0x{:x} is not within any LOAD segment of the ELF file. Please ensure you are using a Virtual Address (from readelf/nm).",
        vaddr
    );
}

fn try_find_extracted_library(apk_path: &Path, so_name: &str) -> Option<PathBuf> {
    let extracted_path = apk_path.parent()?.join("lib").join("arm64").join(so_name);
    debug!("Checking for extracted library at {:?}", extracted_path);
    if extracted_path.exists() {
        Some(extracted_path)
    } else {
        None
    }
}

fn find_apk_path_for_package(package: &str) -> Result<PathBuf> {
    let output = Command::new("pm").arg("path").arg(package).output()?;
    let out_str = String::from_utf8(output.stdout)?;
    // pm path output: package:/data/app/~~.../base.apk
    let path_str = out_str
        .trim()
        .strip_prefix("package:")
        .ok_or_else(|| anyhow!("Unexpected output from pm path: {}", out_str))?;

    Ok(PathBuf::from(path_str))
}

fn extract_so_from_apk(apk_path: &Path, so_name: &str) -> Result<PathBuf> {
    let file = File::open(apk_path).context("Open APK failed")?;
    let mut archive = ZipArchive::new(file).context("Parse ZIP failed")?;
    let target_in_zip = format!("lib/arm64-v8a/{}", so_name);
    let out_path = apk_path
        .parent()
        .ok_or_else(|| anyhow!("Invalid APK path"))?
        .join("lib")
        .join("arm64")
        .join(so_name);

    let mut zip_file = archive
        .by_name(&target_in_zip)
        .context(format!("'{}' not found in APK", target_in_zip))?;

    let mut out_file =
        File::create(&out_path).context(format!("Failed to create output file: {:?}", out_path))?;

    io::copy(&mut zip_file, &mut out_file).context("Failed to decompress file")?;

    use std::os::unix::fs::PermissionsExt;
    let mut perms = fs::metadata(&out_path)?.permissions();
    perms.set_mode(0o755);
    fs::set_permissions(&out_path, perms)?;

    Ok(out_path)
}

// fn find_so_offset_in_apk(apk_path: &Path, so_name: &str) -> Result<u64> {
//     let file = File::open(apk_path).context("Open APK failed")?;
//     let mut archive = ZipArchive::new(file).context("Parse ZIP failed")?;
//     let target_path = format!("lib/arm64-v8a/{}", so_name);
//     let file = archive
//         .by_name(&target_path)
//         .context(format!("'{}' not found in APK", target_path))?;
//     if file.compression() != zip::CompressionMethod::Stored {
//         bail!("Library is compressed! offset is invalid for mmap.");
//     }
//     Ok(file.data_start())
// }

```

`edbgserver-cli/src/target.rs`:

```rs
use std::{
    collections::HashMap,
    os::fd::{AsFd, OwnedFd},
    path::PathBuf,
};

use anyhow::Result;
use aya::{
    Ebpf,
    maps::{Array, MapData, RingBuf},
    programs::{PerfEvent, UProbe},
};
use edbgserver_common::{DataT, ThreadFilter};
use gdbstub::{
    common::Tid,
    target::{
        Target, TargetError, TargetResult,
        ext::{
            base::{
                BaseOps,
                multithread::{MultiThreadBase, MultiThreadResumeOps},
            },
            breakpoints::BreakpointsOps,
        },
    },
};
use log::{debug, error, trace, warn};

use crate::target::{arch::TargetArch, multithread::ThreadAction};

mod arch;
mod auvx;
mod breakpoint;
mod execfile;
mod host_io;
mod libraries;
mod memory_map;
mod multithread;

pub struct EdbgTarget {
    ebpf: Ebpf,
    pub context: Option<DataT>,
    pub ring_buf: RingBuf<MapData>,
    pub notifier: OwnedFd,
    thread_filter: Array<MapData, ThreadFilter>,
    active_sw_breakpoints: HashMap<u64, breakpoint::BreakpointHandle>,
    active_hw_breakpoints: HashMap<u64, breakpoint::BreakpointHandle>,
    active_watchpoint: HashMap<u64, breakpoint::WatchPointMeta>,
    temp_step_breakpoints: Option<(u64, breakpoint::BreakpointHandle)>,
    init_probe_link_id: Option<breakpoint::BreakpointHandle>,
    resume_actions: Vec<(Tid, ThreadAction)>,
    is_scheduler_lock: bool,
    exec_path: Option<PathBuf>,
    pub bound_pid: Option<u32>,
    pub bound_tid: Option<u32>,
    process_memory_handle: Option<process_memory::ProcessHandle>,
    host_io_files: HashMap<u32, crate::virtual_file::VirtualFile>,
    next_host_io_fd: u32,
    pub is_multi_thread: bool,
    step_use_uprobe: bool,
    need_filter_maps: bool,
    r_debug_addr: Option<u64>,
    cached_libraries_xml: String,
}

pub const HOST_IO_FD_START: u32 = 100;

impl EdbgTarget {
    pub fn new(
        mut ebpf: Ebpf,
        is_multi_thread: bool,
        need_filter_maps: bool,
        step_use_uprobe: bool,
    ) -> Self {
        let program: &mut UProbe = ebpf
            .program_mut("probe_callback")
            .expect("cannot find ebpf program probe_callback")
            .try_into()
            .expect("failed to convert ebpf program to uProbe");
        program.load().expect("failed to load uProbe program");
        let program: &mut PerfEvent = ebpf
            .program_mut("perf_callback")
            .expect("cannot find ebpf program perf_callback")
            .try_into()
            .expect("failed to convert ebpf program to PerfEvent");
        program.load().expect("failed to load PerfEvent program");
        let event_map = ebpf.take_map("EVENTS").expect("EVENTS map not found");
        let ringbuf = RingBuf::try_from(event_map).expect("failed to convert map to ringbuf");
        let thread_filter = ebpf
            .take_map("THREAD_FILTER")
            .expect("THREAD_FILTER map not found");
        let thread_filter: Array<MapData, ThreadFilter> =
            Array::try_from(thread_filter).expect("failed to convert filter map");
        let notifier = ringbuf
            .as_fd()
            .try_clone_to_owned()
            .expect("failed to clone ringbuf fd");
        Self {
            ebpf,
            context: None,
            ring_buf: ringbuf,
            notifier,
            thread_filter,
            active_sw_breakpoints: HashMap::new(),
            active_hw_breakpoints: HashMap::new(),
            active_watchpoint: HashMap::new(),
            temp_step_breakpoints: None,
            init_probe_link_id: None,
            resume_actions: Vec::new(),
            is_scheduler_lock: false,
            exec_path: None,
            bound_pid: None,
            bound_tid: None,
            process_memory_handle: None,
            host_io_files: HashMap::new(),
            next_host_io_fd: HOST_IO_FD_START,
            is_multi_thread,
            step_use_uprobe,
            need_filter_maps,
            r_debug_addr: None,
            cached_libraries_xml: String::new(),
        }
    }

    fn get_probe_program(&mut self) -> &mut UProbe {
        self.ebpf
            .program_mut("probe_callback")
            .expect("cannot find ebpf program probe_callback")
            .try_into()
            .expect("failed to convert ebpf program to uProbe")
    }

    fn get_perf_event_program(&mut self) -> &mut PerfEvent {
        self.ebpf
            .program_mut("perf_callback")
            .expect("cannot find ebpf program perf_callback")
            .try_into()
            .expect("failed to convert ebpf program to PerfEvent")
    }

    pub fn get_pid(&self) -> Result<u32> {
        self.bound_pid
            .ok_or_else(|| anyhow::anyhow!("Target process is not running or not attached"))
    }
}

impl Target for EdbgTarget {
    type Arch = TargetArch;
    type Error = anyhow::Error;

    fn base_ops(&mut self) -> BaseOps<'_, Self::Arch, Self::Error> {
        BaseOps::MultiThread(self)
    }

    #[inline(always)]
    fn support_breakpoints(&mut self) -> Option<BreakpointsOps<'_, Self>> {
        Some(self)
    }

    #[inline(always)]
    fn support_memory_map(
        &mut self,
    ) -> Option<gdbstub::target::ext::memory_map::MemoryMapOps<'_, Self>> {
        Some(self)
    }

    #[inline(always)]
    fn support_extended_mode(
        &mut self,
    ) -> Option<gdbstub::target::ext::extended_mode::ExtendedModeOps<'_, Self>> {
        Some(self)
    }

    #[inline(always)]
    fn support_host_io(&mut self) -> Option<gdbstub::target::ext::host_io::HostIoOps<'_, Self>> {
        Some(self)
    }

    #[inline(always)]
    fn support_exec_file(
        &mut self,
    ) -> Option<gdbstub::target::ext::exec_file::ExecFileOps<'_, Self>> {
        Some(self)
    }

    #[inline(always)]
    fn support_auxv(&mut self) -> Option<gdbstub::target::ext::auxv::AuxvOps<'_, Self>> {
        Some(self)
    }

    #[inline(always)]
    fn support_libraries_svr4(
        &mut self,
    ) -> Option<gdbstub::target::ext::libraries::LibrariesSvr4Ops<'_, Self>> {
        Some(self)
    }
}

impl MultiThreadBase for EdbgTarget {
    fn read_registers(
        &mut self,
        regs: &mut <Self::Arch as gdbstub::arch::Arch>::Registers,
        tid: gdbstub::common::Tid,
    ) -> TargetResult<(), Self> {
        if let Some(ctx) = &self.context {
            if !self.is_multi_thread || ctx.tid == tid.get() as u32 {
                arch::fill_regs(regs, ctx);
                return Ok(());
            } else {
                debug!("Req regs for TID {} but context is for {}", tid, ctx.tid);
            }
        }
        warn!(
            "Requesting registers for TID {} but no matching context",
            tid
        );
        debug!("last_context: {:?}", self.context);
        Ok(())
    }

    fn write_registers(
        &mut self,
        _regs: &<Self::Arch as gdbstub::arch::Arch>::Registers,
        _tid: gdbstub::common::Tid,
    ) -> TargetResult<(), Self> {
        warn!("write_registers not fully implemented (requires ptrace or inline hooking)");
        Err(TargetError::NonFatal)
    }

    fn read_addrs(
        &mut self,
        start_addr: <Self::Arch as gdbstub::arch::Arch>::Usize,
        data: &mut [u8],
        _tid: gdbstub::common::Tid,
    ) -> TargetResult<usize, Self> {
        use process_memory::CopyAddress;
        match self
            .process_memory_handle
            .ok_or_else(|| {
                error!("process handle not init! ");
                TargetError::NonFatal
            })?
            .copy_address(start_addr as usize, data)
        {
            Ok(_) => Ok(data.len()),
            Err(e) => {
                debug!("Failed to read memory at {:#x}: {}", start_addr, e); // that usual happends
                Err(TargetError::Io(e))
            }
        }
    }

    fn write_addrs(
        &mut self,
        start_addr: <Self::Arch as gdbstub::arch::Arch>::Usize,
        data: &[u8],
        _tid: gdbstub::common::Tid,
    ) -> TargetResult<(), Self> {
        let pid = self.get_pid().map_err(|e| {
            error!("Failed to get pid for writing memory: {}", e);
            TargetError::NonFatal
        })?;
        let path = format!("/proc/{}/mem", pid);
        use std::{
            fs::OpenOptions,
            io::{Seek, SeekFrom, Write},
        };
        let mut file = match OpenOptions::new().read(true).write(true).open(&path) {
            Ok(f) => f,
            Err(e) => {
                warn!("Failed to open {}: {:?}", path, e);
                return Err(TargetError::Io(e));
            }
        };
        if let Err(e) = file.seek(SeekFrom::Start(start_addr)) {
            warn!("Failed to seek to {:#x}: {:?}", start_addr, e);
            return Err(TargetError::Io(e));
        }
        match file.write_all(data) {
            Ok(_) => Ok(()),
            Err(e) => {
                warn!(
                    "Failed to write memory at {:#x} via /proc/mem: {:?}",
                    start_addr, e
                );
                Err(TargetError::Io(e))
            }
        }
    }

    fn list_active_threads(
        &mut self,
        thread_is_active: &mut dyn FnMut(gdbstub::common::Tid),
    ) -> Result<(), Self::Error> {
        trace!("listing active threads");
        let threads = self.get_active_threads()?;
        for tid in threads {
            thread_is_active(tid);
        }
        Ok(())
    }

    #[inline(always)]
    fn support_resume(&mut self) -> Option<MultiThreadResumeOps<'_, Self>> {
        Some(self)
    }

    #[inline(always)]
    fn support_single_register_access(
        &mut self,
    ) -> Option<
        gdbstub::target::ext::base::single_register_access::SingleRegisterAccessOps<'_, Tid, Self>,
    > {
        Some(self)
    }
}

```

`edbgserver-cli/src/target/arch.rs`:

```rs
#[cfg(target_arch = "aarch64")]
mod aarch64;
#[cfg(target_arch = "x86_64")]
mod x86_64;

#[cfg(target_arch = "aarch64")]
pub type TargetArch = aarch64::LinuxAArch64Core;
#[cfg(target_arch = "aarch64")]
pub use aarch64::fill_regs;
#[cfg(target_arch = "x86_64")]
pub type TargetArch = gdbstub_arch::x86::X86_64_SSE;
#[cfg(target_arch = "x86_64")]
pub use x86_64::fill_regs;

```

`edbgserver-cli/src/target/arch/aarch64.rs`:

```rs
use anyhow::{Result, anyhow, bail};
use capstone::{
    arch::arm64::{Arm64CC, Arm64Insn, Arm64InsnGroup, Arm64OperandType, Arm64Reg},
    prelude::*,
};
use edbgserver_common::DataT;
use gdbstub::{
    common::Tid,
    target::{TargetError, TargetResult, ext::base::single_register_access::SingleRegisterAccess},
};
use log::{debug, error, warn};

use crate::target::EdbgTarget;

pub struct LinuxAArch64Core {}

impl gdbstub::arch::Arch for LinuxAArch64Core {
    type BreakpointKind = usize;
    type RegId = gdbstub_arch::aarch64::reg::id::AArch64RegId;
    type Registers = AArch64MinimalRegs;
    type Usize = u64;

    fn target_description_xml() -> Option<&'static str> {
        static DESCRIPTION_XML: &str = concat!(
            r#"<target version="1.0">"#,
            "<architecture>aarch64</architecture>",
            "<osabi>GNU/Linux</osabi>",
            include_str!("aarch64_core.xml"),
            "</target>",
        );

        Some(DESCRIPTION_XML)
    }
}

#[derive(Debug, Default, Clone, Eq, PartialEq)]
pub struct AArch64MinimalRegs {
    pub x: [u64; 31],
    pub sp: u64,
    pub pc: u64,
    pub cpsr: u32,
}

impl gdbstub::arch::Registers for AArch64MinimalRegs {
    type ProgramCounter = u64;

    fn pc(&self) -> Self::ProgramCounter {
        self.pc
    }

    fn gdb_serialize(&self, mut write_byte: impl FnMut(Option<u8>)) {
        macro_rules! write_bytes {
            ($var: expr) => {
                for b in $var.to_le_bytes() {
                    write_byte(Some(b))
                }
            };
        }
        for reg in self.x.iter() {
            write_bytes!(reg);
        }
        write_bytes!(self.sp);
        write_bytes!(self.pc);
        write_bytes!(self.cpsr);
    }

    fn gdb_deserialize(&mut self, bytes: &[u8]) -> Result<(), ()> {
        const CPSR_OFF: usize = core::mem::size_of::<u64>() * 33;
        const END: usize = CPSR_OFF + core::mem::size_of::<u32>() * 2;

        if bytes.len() < END {
            return Err(());
        }

        let mut regs = bytes[0..CPSR_OFF]
            .chunks_exact(core::mem::size_of::<u64>())
            .map(|c| u64::from_le_bytes(c.try_into().unwrap()));

        for reg in self.x.iter_mut() {
            *reg = regs.next().ok_or(())?
        }
        self.sp = regs.next().ok_or(())?;
        self.pc = regs.next().ok_or(())?;

        let mut regs = bytes[CPSR_OFF..]
            .chunks_exact(core::mem::size_of::<u32>())
            .map(|c| u32::from_le_bytes(c.try_into().unwrap()));

        self.cpsr = regs.next().ok_or(())?;
        Ok(())
    }
}

pub fn fill_regs(regs: &mut AArch64MinimalRegs, ctx: &DataT) {
    regs.x = ctx.regs;
    regs.pc = ctx.pc;
    regs.sp = ctx.sp;
    regs.cpsr = ctx.pstate as u32;
}

impl SingleRegisterAccess<Tid> for EdbgTarget {
    fn read_register(
        &mut self,
        tid: Tid,
        reg_id: <Self::Arch as gdbstub::arch::Arch>::RegId,
        buf: &mut [u8],
    ) -> TargetResult<usize, Self> {
        let ctx = match &self.context {
            Some(c) if !self.is_multi_thread || c.tid == tid.get() as u32 => c,
            _ => {
                warn!("read_register: no context with tid {}", tid.get());
                return Ok(0);
            }
        };

        match reg_id {
            gdbstub_arch::aarch64::reg::id::AArch64RegId::X(n) => {
                buf.copy_from_slice(&ctx.regs[n as usize].to_le_bytes());
                Ok(8)
            }
            gdbstub_arch::aarch64::reg::id::AArch64RegId::Sp => {
                buf.copy_from_slice(&ctx.sp.to_le_bytes());
                Ok(8)
            }
            gdbstub_arch::aarch64::reg::id::AArch64RegId::Pc => {
                buf.copy_from_slice(&ctx.pc.to_le_bytes());
                Ok(8)
            }
            gdbstub_arch::aarch64::reg::id::AArch64RegId::Pstate => {
                buf.copy_from_slice(&ctx.pstate.to_le_bytes());
                Ok(8)
            }
            _ => Ok(0),
        }
    }

    fn write_register(
        &mut self,
        _tid: Tid,
        _reg_id: <Self::Arch as gdbstub::arch::Arch>::RegId,
        _val: &[u8],
    ) -> TargetResult<(), Self> {
        warn!("write single register not fully implemented (requires ptrace or inline hooking)");
        Err(TargetError::NonFatal)
    }
}

impl EdbgTarget {
    fn create_capstone() -> Result<Capstone> {
        Capstone::new()
            .arm64()
            .mode(arch::arm64::ArchMode::Arm)
            .detail(true)
            .build()
            .map_err(|e| anyhow!("Failed to create Capstone instance: {}", e))
    }

    fn read_instruction(&self, pc: u64) -> Result<u32> {
        let mut buf = [0u8; 4];
        use process_memory::{CopyAddress, TryIntoProcessHandle};
        let handle = (self.get_pid()? as i32).try_into_process_handle()?;
        handle.copy_address(pc as usize, &mut buf)?;
        Ok(u32::from_le_bytes(buf))
    }

    pub fn calculation_next_pc(&self, current_pc: u64) -> Result<u64> {
        debug!("Calculating next PC from current PC: {:#x}", current_pc);
        let code = self.read_instruction(current_pc)?;
        let code_byte = code.to_le_bytes();
        let cs = EdbgTarget::create_capstone()?;
        let insn = cs.disasm_count(&code_byte, current_pc, 1)?;
        if insn.is_empty() {
            bail!("Failed to disassemble instruction at {:#x}", current_pc);
        }
        let insn = insn.first().ok_or(anyhow!("Failed to get instruction"))?;
        debug!(
            "CalcNextPC {:#x}: {} {}",
            current_pc,
            insn.mnemonic().unwrap_or("???"),
            insn.op_str().unwrap_or("???")
        );
        let detail = cs.insn_detail(insn)?;
        let groups = detail.groups();
        let is_control_flow = groups.iter().any(|&g| {
            matches!(
                g.0 as u32,
                Arm64InsnGroup::ARM64_GRP_JUMP
                    | Arm64InsnGroup::ARM64_GRP_CALL
                    | Arm64InsnGroup::ARM64_GRP_RET
                    | Arm64InsnGroup::ARM64_GRP_BRANCH_RELATIVE
            )
        });

        if !is_control_flow {
            return Ok(insn.address() + insn.len() as u64);
        }

        let inst_id = insn.id().0;
        let insn_enum = Arm64Insn::from(inst_id);
        let arch_detail = detail.arch_detail();
        let arm64_detail = arch_detail.arm64().unwrap();
        let context = self
            .context
            .as_ref()
            .ok_or_else(|| anyhow!("fail to get context"))?;
        match insn_enum {
            // bl label | b lable
            Arm64Insn::ARM64_INS_B | Arm64Insn::ARM64_INS_BL => {
                let cc = arm64_detail.cc();
                let pstate = context.pstate;
                if !check_condition(cc, pstate) {
                    return Ok(insn.address() + insn.len() as u64);
                }
                if let Some(op) = arm64_detail.operands().next()
                    && let Arm64OperandType::Imm(target) = op.op_type
                {
                    return Ok(target as u64);
                }
                bail!("Failed to get target for B or BL");
            }
            // br x8 | blr x8 | ret
            Arm64Insn::ARM64_INS_BR | Arm64Insn::ARM64_INS_BLR => {
                let op = arm64_detail.operands().next().unwrap();
                let reg_id = match op.op_type {
                    Arm64OperandType::Reg(reg_id) => reg_id,
                    _ => bail!("Expected register operand for BR/BLR/RET"),
                };
                let res = get_reg_from_context(reg_id, context)?;
                Ok(res)
            }
            Arm64Insn::ARM64_INS_RET => {
                let link_reg = context.regs[30]; // LR is X30
                Ok(link_reg)
            }
            // cbz x0, label | cbnz x0, label
            Arm64Insn::ARM64_INS_CBZ | Arm64Insn::ARM64_INS_CBNZ => {
                let ops: Vec<_> = arm64_detail.operands().collect();
                if ops.len() < 2 {
                    bail!("Invalid CBZ/CBNZ operands")
                }
                let test_val = if let Arm64OperandType::Reg(reg_id) = ops[0].op_type {
                    get_reg_from_context(reg_id, context)?
                } else {
                    bail!("CBZ op1 not reg")
                };

                let test_res_z = test_val == 0;
                let target = if let Arm64OperandType::Imm(addr) = ops[1].op_type {
                    addr as u64
                } else {
                    bail!("CBZ op2 not imm")
                };

                let is_cbz = matches!(insn_enum, Arm64Insn::ARM64_INS_CBZ);
                if (is_cbz && test_res_z) || (!is_cbz && !test_res_z) {
                    Ok(target)
                } else {
                    Ok(insn.address() + insn.len() as u64)
                }
            }
            // tbz Rn, #imm, label | tbnz Rn, #imm, label
            Arm64Insn::ARM64_INS_TBZ | Arm64Insn::ARM64_INS_TBNZ => {
                let ops: Vec<_> = arm64_detail.operands().collect();
                if ops.len() < 3 {
                    bail!("Invalid TBZ/TBNZ operands")
                }
                let val = if let Arm64OperandType::Reg(reg_id) = ops.first().unwrap().op_type {
                    get_reg_from_context(reg_id, context)?
                } else {
                    bail!("TBZ op0 not reg");
                };

                let bit = if let Arm64OperandType::Imm(b) = ops[1].op_type {
                    b as u64
                } else {
                    bail!("TBZ op1 not imm")
                };

                // Op2: Target (Imm)
                let target = if let Arm64OperandType::Imm(addr) = ops[2].op_type {
                    addr as u64
                } else {
                    bail!("TBZ op2 not imm")
                };

                let bit_set_z = (val >> bit) & 1 == 0;
                let is_tbz = insn_enum == Arm64Insn::ARM64_INS_TBZ;
                if (is_tbz && bit_set_z) || (!is_tbz && !bit_set_z) {
                    Ok(target)
                } else {
                    Ok(insn.address() + insn.len() as u64)
                }
            }
            _ => {
                error!(
                    "Unsupported control flow instruction: {:?} at {:#x}",
                    insn_enum,
                    insn.address()
                );
                Ok(insn.address() + insn.len() as u64)
            }
        }
    }
}

fn check_condition(cc: Arm64CC, pstate: u64) -> bool {
    let n = (pstate >> 31) & 1 == 1;
    let z = (pstate >> 30) & 1 == 1;
    let c = (pstate >> 29) & 1 == 1;
    let v = (pstate >> 28) & 1 == 1;

    match cc {
        Arm64CC::ARM64_CC_EQ => z,              // Equal
        Arm64CC::ARM64_CC_NE => !z,             // Not Equal
        Arm64CC::ARM64_CC_HS => c,              // Unsigned higher or same (CS)
        Arm64CC::ARM64_CC_LO => !c,             // Unsigned lower (CC)
        Arm64CC::ARM64_CC_MI => n,              // Minus (Negative)
        Arm64CC::ARM64_CC_PL => !n,             // Plus (Positive or Zero)
        Arm64CC::ARM64_CC_VS => v,              // Overflow
        Arm64CC::ARM64_CC_VC => !v,             // No Overflow
        Arm64CC::ARM64_CC_HI => c && !z,        // Unsigned higher
        Arm64CC::ARM64_CC_LS => !c || z,        // Unsigned lower or same
        Arm64CC::ARM64_CC_GE => n == v,         // Signed greater or equal
        Arm64CC::ARM64_CC_LT => n != v,         // Signed less than
        Arm64CC::ARM64_CC_GT => !z && (n == v), // Signed greater than
        Arm64CC::ARM64_CC_LE => z || (n != v),  // Signed less or equal
        Arm64CC::ARM64_CC_AL => true,           // Always
        Arm64CC::ARM64_CC_NV => true, // Always (historically "Never", but behaves as AL in A64)
        Arm64CC::ARM64_CC_INVALID => true, // No condition specified, so always
    }
}

fn get_reg_from_context(reg_id: RegId, context: &DataT) -> Result<u64> {
    let reg_id = reg_id.0 as u32;
    let res = match reg_id {
        Arm64Reg::ARM64_REG_X0 => context.regs[0],
        Arm64Reg::ARM64_REG_X1 => context.regs[1],
        Arm64Reg::ARM64_REG_X2 => context.regs[2],
        Arm64Reg::ARM64_REG_X3 => context.regs[3],
        Arm64Reg::ARM64_REG_X4 => context.regs[4],
        Arm64Reg::ARM64_REG_X5 => context.regs[5],
        Arm64Reg::ARM64_REG_X6 => context.regs[6],
        Arm64Reg::ARM64_REG_X7 => context.regs[7],
        Arm64Reg::ARM64_REG_X8 => context.regs[8],
        Arm64Reg::ARM64_REG_X9 => context.regs[9],
        Arm64Reg::ARM64_REG_X10 => context.regs[10],
        Arm64Reg::ARM64_REG_X11 => context.regs[11],
        Arm64Reg::ARM64_REG_X12 => context.regs[12],
        Arm64Reg::ARM64_REG_X13 => context.regs[13],
        Arm64Reg::ARM64_REG_X14 => context.regs[14],
        Arm64Reg::ARM64_REG_X15 => context.regs[15],
        Arm64Reg::ARM64_REG_X16 => context.regs[16],
        Arm64Reg::ARM64_REG_X17 => context.regs[17],
        Arm64Reg::ARM64_REG_X18 => context.regs[18],
        Arm64Reg::ARM64_REG_X19 => context.regs[19],
        Arm64Reg::ARM64_REG_X20 => context.regs[20],
        Arm64Reg::ARM64_REG_X21 => context.regs[21],
        Arm64Reg::ARM64_REG_X22 => context.regs[22],
        Arm64Reg::ARM64_REG_X23 => context.regs[23],
        Arm64Reg::ARM64_REG_X24 => context.regs[24],
        Arm64Reg::ARM64_REG_X25 => context.regs[25],
        Arm64Reg::ARM64_REG_X26 => context.regs[26],
        Arm64Reg::ARM64_REG_X27 => context.regs[27],
        Arm64Reg::ARM64_REG_X28 => context.regs[28],
        Arm64Reg::ARM64_REG_X29 => context.regs[29], // FP
        Arm64Reg::ARM64_REG_X30 => context.regs[30], // LR
        Arm64Reg::ARM64_REG_W0 => context.regs[0] as u32 as u64,
        Arm64Reg::ARM64_REG_W1 => context.regs[1] as u32 as u64,
        Arm64Reg::ARM64_REG_W2 => context.regs[2] as u32 as u64,
        Arm64Reg::ARM64_REG_W3 => context.regs[3] as u32 as u64,
        Arm64Reg::ARM64_REG_W4 => context.regs[4] as u32 as u64,
        Arm64Reg::ARM64_REG_W5 => context.regs[5] as u32 as u64,
        Arm64Reg::ARM64_REG_W6 => context.regs[6] as u32 as u64,
        Arm64Reg::ARM64_REG_W7 => context.regs[7] as u32 as u64,
        Arm64Reg::ARM64_REG_W8 => context.regs[8] as u32 as u64,
        Arm64Reg::ARM64_REG_W9 => context.regs[9] as u32 as u64,
        Arm64Reg::ARM64_REG_W10 => context.regs[10] as u32 as u64,
        Arm64Reg::ARM64_REG_W11 => context.regs[11] as u32 as u64,
        Arm64Reg::ARM64_REG_W12 => context.regs[12] as u32 as u64,
        Arm64Reg::ARM64_REG_W13 => context.regs[13] as u32 as u64,
        Arm64Reg::ARM64_REG_W14 => context.regs[14] as u32 as u64,
        Arm64Reg::ARM64_REG_W15 => context.regs[15] as u32 as u64,
        Arm64Reg::ARM64_REG_W16 => context.regs[16] as u32 as u64,
        Arm64Reg::ARM64_REG_W17 => context.regs[17] as u32 as u64,
        Arm64Reg::ARM64_REG_W18 => context.regs[18] as u32 as u64,
        Arm64Reg::ARM64_REG_W19 => context.regs[19] as u32 as u64,
        Arm64Reg::ARM64_REG_W20 => context.regs[20] as u32 as u64,
        Arm64Reg::ARM64_REG_W21 => context.regs[21] as u32 as u64,
        Arm64Reg::ARM64_REG_W22 => context.regs[22] as u32 as u64,
        Arm64Reg::ARM64_REG_W23 => context.regs[23] as u32 as u64,
        Arm64Reg::ARM64_REG_W24 => context.regs[24] as u32 as u64,
        Arm64Reg::ARM64_REG_W25 => context.regs[25] as u32 as u64,
        Arm64Reg::ARM64_REG_W26 => context.regs[26] as u32 as u64,
        Arm64Reg::ARM64_REG_W27 => context.regs[27] as u32 as u64,
        Arm64Reg::ARM64_REG_W28 => context.regs[28] as u32 as u64,
        Arm64Reg::ARM64_REG_W29 => context.regs[29] as u32 as u64,
        Arm64Reg::ARM64_REG_W30 => context.regs[30] as u32 as u64,
        _ => bail!("Unsupported register id: {}", reg_id),
    };
    Ok(res)
}

```

`edbgserver-cli/src/target/arch/aarch64_core.xml`:

```xml
<!-- https://github.com/daniel5151/gdbstub/blob/master/gdbstub_arch/src/aarch64/core.xml -->
<feature name="org.gnu.gdb.aarch64.core">

<!-- source: binutils-gdb/blob/master/gdb/features/aarch64-core.xml -->

<!-- Copyright (C) 2009-2022 Free Software Foundation, Inc.
     Contributed by ARM Ltd.
     Copying and distribution of this file, with or without modification,
     are permitted in any medium without royalty provided the copyright
     notice and this notice are preserved.  -->

  <reg name="x0" bitsize="64" />
  <reg name="x1" bitsize="64" />
  <reg name="x2" bitsize="64" />
  <reg name="x3" bitsize="64" />
  <reg name="x4" bitsize="64" />
  <reg name="x5" bitsize="64" />
  <reg name="x6" bitsize="64" />
  <reg name="x7" bitsize="64" />
  <reg name="x8" bitsize="64" />
  <reg name="x9" bitsize="64" />
  <reg name="x10" bitsize="64" />
  <reg name="x11" bitsize="64" />
  <reg name="x12" bitsize="64" />
  <reg name="x13" bitsize="64" />
  <reg name="x14" bitsize="64" />
  <reg name="x15" bitsize="64" />
  <reg name="x16" bitsize="64" />
  <reg name="x17" bitsize="64" />
  <reg name="x18" bitsize="64" />
  <reg name="x19" bitsize="64" />
  <reg name="x20" bitsize="64" />
  <reg name="x21" bitsize="64" />
  <reg name="x22" bitsize="64" />
  <reg name="x23" bitsize="64" />
  <reg name="x24" bitsize="64" />
  <reg name="x25" bitsize="64" />
  <reg name="x26" bitsize="64" />
  <reg name="x27" bitsize="64" />
  <reg name="x28" bitsize="64" />
  <reg name="x29" bitsize="64" />
  <reg name="x30" bitsize="64" />
  <reg name="sp" bitsize="64" type="data_ptr" />

  <reg name="pc" bitsize="64" type="code_ptr" />

  <flags id="cpsr_flags" size="4">
    <!-- Stack Pointer.  -->
    <field name="SP" start="0" end="0" />

    <!-- Exception Level.  -->
    <field name="EL" start="2" end="3" />
    <!-- Execution state.  -->
    <field name="nRW" start="4" end="4" />

    <!-- FIQ interrupt mask.  -->
    <field name="F" start="6" end="6" />
    <!-- IRQ interrupt mask.  -->
    <field name="I" start="7" end="7" />
    <!-- SError interrupt mask.  -->
    <field name="A" start="8" end="8" />
    <!-- Debug exception mask.  -->
    <field name="D" start="9" end="9" />

    <!-- ARMv8.5-A: Branch Target Identification BTYPE.  -->
    <field name="BTYPE" start="10" end="11" />

    <!-- ARMv8.0-A: Speculative Store Bypass.  -->
    <field name="SSBS" start="12" end="12" />

    <!-- Illegal Execution state.  -->
    <field name="IL" start="20" end="20" />
    <!-- Software Step.  -->
    <field name="SS" start="21" end="21" />
    <!-- ARMv8.1-A: Privileged Access Never.  -->
    <field name="PAN" start="22" end="22" />
    <!-- ARMv8.2-A: User Access Override.  -->
    <field name="UAO" start="23" end="23" />
    <!-- ARMv8.4-A: Data Independent Timing.  -->
    <field name="DIT" start="24" end="24" />
    <!-- ARMv8.5-A: Tag Check Override.  -->
    <field name="TCO" start="25" end="25" />

    <!-- Overflow Condition flag.  -->
    <field name="V" start="28" end="28" />
    <!-- Carry Condition flag.  -->
    <field name="C" start="29" end="29" />
    <!-- Zero Condition flag.  -->
    <field name="Z" start="30" end="30" />
    <!-- Negative Condition flag.  -->
    <field name="N" start="31" end="31" />
  </flags>
  <reg name="cpsr" bitsize="32" type="cpsr_flags" />

</feature>

```

`edbgserver-cli/src/target/arch/x86_64.rs`:

```rs
use anyhow::{Result, anyhow, bail};
use capstone::{
    Capstone, RegId,
    arch::x86::{X86Insn, X86InsnGroup, X86OperandType, X86Reg},
    prelude::*,
};
use edbgserver_common::DataT;
use gdbstub::{
    common::Tid,
    target::{TargetError, TargetResult, ext::base::single_register_access::SingleRegisterAccess},
};
use gdbstub_arch::x86::reg::{
    X86_64CoreRegs,
    id::{X86_64CoreRegId, X86SegmentRegId},
};
use log::{debug, error, trace, warn};

use crate::target::EdbgTarget;

pub fn fill_regs(regs: &mut X86_64CoreRegs, ctx: &DataT) {
    regs.regs[0] = ctx.rax;
    regs.regs[1] = ctx.rbx;
    regs.regs[2] = ctx.rcx;
    regs.regs[3] = ctx.rdx;
    regs.regs[4] = ctx.rsi;
    regs.regs[5] = ctx.rdi;
    regs.regs[6] = ctx.rbp;
    regs.regs[7] = ctx.rsp;
    regs.regs[8] = ctx.r8;
    regs.regs[9] = ctx.r9;
    regs.regs[10] = ctx.r10;
    regs.regs[11] = ctx.r11;
    regs.regs[12] = ctx.r12;
    regs.regs[13] = ctx.r13;
    regs.regs[14] = ctx.r14;
    regs.regs[15] = ctx.r15;

    regs.rip = ctx.rip;
    regs.eflags = ctx.eflags as u32;
}

impl SingleRegisterAccess<Tid> for EdbgTarget {
    fn read_register(
        &mut self,
        tid: Tid,
        reg_id: <Self::Arch as gdbstub::arch::Arch>::RegId,
        buf: &mut [u8],
    ) -> TargetResult<usize, Self> {
        let ctx = match &self.context {
            Some(c) if !self.is_multi_thread || c.tid == tid.get() as u32 => c,
            _ => {
                warn!("read_register: no context with tid {}", tid.get());
                return Ok(0);
            }
        };

        match reg_id {
            X86_64CoreRegId::Gpr(i) => {
                // RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP, r8-r15
                let val = match i {
                    0 => ctx.rax,
                    1 => ctx.rbx,
                    2 => ctx.rcx,
                    3 => ctx.rdx,
                    4 => ctx.rsi,
                    5 => ctx.rdi,
                    6 => ctx.rbp,
                    7 => ctx.rsp,
                    8 => ctx.r8,
                    9 => ctx.r9,
                    10 => ctx.r10,
                    11 => ctx.r11,
                    12 => ctx.r12,
                    13 => ctx.r13,
                    14 => ctx.r14,
                    15 => ctx.r15,
                    _ => return Ok(0),
                };
                buf.copy_from_slice(&val.to_le_bytes());
                Ok(8)
            }
            X86_64CoreRegId::Rip => {
                buf.copy_from_slice(&ctx.rip.to_le_bytes());
                Ok(8)
            }
            X86_64CoreRegId::Eflags => {
                let val = ctx.eflags as u32;
                buf.copy_from_slice(&val.to_le_bytes());
                Ok(4)
            }
            X86_64CoreRegId::Segment(segments) => {
                let val = match segments {
                    X86SegmentRegId::CS => ctx.cs,
                    X86SegmentRegId::SS => ctx.ss,
                    _ => 0,
                };
                buf.copy_from_slice(&(val as u32).to_le_bytes());
                Ok(4)
            }
            _ => Ok(0),
        }
    }

    fn write_register(
        &mut self,
        _tid: Tid,
        _reg_id: <Self::Arch as gdbstub::arch::Arch>::RegId,
        _val: &[u8],
    ) -> TargetResult<(), Self> {
        warn!("write single register not fully implemented (requires ptrace or inline hooking)");
        Err(TargetError::NonFatal)
    }
}

impl EdbgTarget {
    fn create_capstone() -> Result<Capstone> {
        Capstone::new()
            .x86()
            .mode(capstone::arch::x86::ArchMode::Mode64)
            .detail(true)
            .build()
            .map_err(|e| anyhow!("Failed to create Capstone for x64: {}", e))
    }

    fn read_instruction_buf(&self, pc: u64) -> Result<[u8; 15]> {
        let mut buf = [0u8; 15];
        use process_memory::{CopyAddress, TryIntoProcessHandle};
        let pid = self.get_pid()?;
        // trace!("[ReadMem] Reading 15 bytes from PID {} at {:#x}", pid, pc);
        let handle = (pid as i32).try_into_process_handle()?;
        handle.copy_address(pc as usize, &mut buf)?;
        Ok(buf)
    }

    pub fn calculation_next_pc(&self, current_pc: u64) -> Result<u64> {
        let code_buf = self.read_instruction_buf(current_pc)?;
        let cs = Self::create_capstone()?;
        let insns = cs.disasm_count(&code_buf, current_pc, 1)?;

        let insn = insns
            .first()
            .ok_or(anyhow!("Failed to disassemble at {:#x}", current_pc))?;
        let detail = cs.insn_detail(insn)?;

        debug!(
            "CalcNextPC {:#x}: {} {}",
            current_pc,
            insn.mnemonic().unwrap_or("???"),
            insn.op_str().unwrap_or("???")
        );

        let is_control_flow = detail.groups().iter().any(|&g| {
            let gid = g.0 as u32;
            gid == X86InsnGroup::X86_GRP_JUMP
                || gid == X86InsnGroup::X86_GRP_CALL
                || gid == X86InsnGroup::X86_GRP_RET
                || gid == X86InsnGroup::X86_GRP_IRET
        });

        let next_inst_addr = insn.address() + insn.len() as u64;

        if !is_control_flow {
            trace!(
                "Not control flow, sequential execution -> {:#x}",
                next_inst_addr
            );
            return Ok(next_inst_addr);
        }

        let arch_detail = detail.arch_detail();
        let x86_detail = arch_detail.x86().ok_or_else(|| anyhow!("Not x86 detail"))?;
        let context = self
            .context
            .as_ref()
            .ok_or_else(|| anyhow!("fail to get context"))?;

        let insn_id = X86Insn::from(insn.id().0);

        match insn_id {
            X86Insn::X86_INS_RET | X86Insn::X86_INS_RETF | X86Insn::X86_INS_IRET => {
                let mut stack_buf = [0u8; 8];
                use process_memory::{CopyAddress, TryIntoProcessHandle};
                let handle = (self.get_pid()? as i32).try_into_process_handle()?;
                handle.copy_address(context.rsp as usize, &mut stack_buf)?;
                let ret_addr = u64::from_le_bytes(stack_buf);
                debug!(
                    "RET instruction. Reading stack at {:#x} -> Return Address: {:#x}",
                    context.rsp, ret_addr
                );
                Ok(ret_addr)
            }
            X86Insn::X86_INS_JMP | X86Insn::X86_INS_CALL => {
                let op = x86_detail
                    .operands()
                    .next()
                    .ok_or(anyhow!("No operand for JMP/CALL"))?;
                debug!("Unconditional JMP/CALL. Operand Type: {:?}", op.op_type);

                match op.op_type {
                    X86OperandType::Imm(addr) => {
                        debug!("Target is Immediate: {:#x}", addr);
                        Ok(addr as u64)
                    }
                    X86OperandType::Reg(reg_id) => {
                        let target = get_reg_from_context(reg_id, context)?;
                        debug!("Target is Register {:?}: {:#x}", reg_id, target);
                        Ok(target)
                    }
                    X86OperandType::Mem(mem) => {
                        debug!("Calculating Indirect Jump target from Mem: {:?}", mem);
                        let mut target_ptr_addr = mem.disp() as u64;
                        if mem.base().0 != 0 {
                            let base_reg = mem.base().0 as u32;
                            if base_reg == X86Reg::X86_REG_RIP {
                                target_ptr_addr = target_ptr_addr.wrapping_add(next_inst_addr);
                                debug!(
                                    "RIP-relative addressing. Base: RIP, Disp: {:#x}, Effective Addr: {:#x}",
                                    mem.disp(),
                                    target_ptr_addr
                                );
                            } else {
                                let val = get_reg_from_context(mem.base(), context)?;
                                target_ptr_addr = target_ptr_addr.wrapping_add(val);
                            }
                        }
                        if mem.index().0 != 0 {
                            let index_val = get_reg_from_context(mem.index(), context)?;
                            let scale = mem.scale() as u64;
                            target_ptr_addr =
                                target_ptr_addr.wrapping_add(index_val.wrapping_mul(scale));
                        }

                        debug!("Indirect Jump Pointer Address: {:#x}", target_ptr_addr);

                        let mut ptr_buf = [0u8; 8];
                        use process_memory::{CopyAddress, TryIntoProcessHandle};
                        let handle = (self.get_pid()? as i32).try_into_process_handle()?;

                        match handle.copy_address(target_ptr_addr as usize, &mut ptr_buf) {
                            Ok(_) => {
                                let final_target = u64::from_le_bytes(ptr_buf);
                                debug!(
                                    "Read memory at {:#x} -> Target: {:#x}",
                                    target_ptr_addr, final_target
                                );
                                Ok(final_target)
                            }
                            Err(e) => {
                                error!(
                                    "Failed to read jump target from memory at {:#x}: {}",
                                    target_ptr_addr, e
                                );
                                Err(anyhow!("Failed to read indirect jump target: {}", e))
                            }
                        }
                    }
                    _ => bail!("Unsupported JMP/CALL operand type: {:?}", op.op_type),
                }
            }
            id if is_jcc(id) => {
                let condition_met = check_x86_condition(id, context.eflags);
                debug!(
                    "Conditional Jump ({:?}). RFLAGS: {:#x}. Condition Met: {}",
                    id, context.eflags, condition_met
                );

                if condition_met {
                    let op = x86_detail
                        .operands()
                        .next()
                        .ok_or(anyhow!("No operand for Jcc"))?;
                    if let X86OperandType::Imm(addr) = op.op_type {
                        debug!("Condition met, jumping to {:#x}", addr);
                        return Ok(addr as u64);
                    }
                    warn!("Jcc taken but operand is not Imm? {:?}", op.op_type);
                } else {
                    debug!(
                        "Condition NOT met, falling through to {:#x}",
                        next_inst_addr
                    );
                }
                Ok(next_inst_addr)
            }
            _ => {
                error!(
                    "Unsupported control flow x86 instruction: {:?} at {:#x}",
                    insn.id(),
                    insn.address()
                );
                Ok(next_inst_addr)
            }
        }
    }
}

fn is_jcc(id: X86Insn) -> bool {
    matches!(
        id,
        X86Insn::X86_INS_JE
            | X86Insn::X86_INS_JNE
            | X86Insn::X86_INS_JG
            | X86Insn::X86_INS_JGE
            | X86Insn::X86_INS_JL
            | X86Insn::X86_INS_JLE
            | X86Insn::X86_INS_JA
            | X86Insn::X86_INS_JAE
            | X86Insn::X86_INS_JB
            | X86Insn::X86_INS_JBE
    )
}

fn check_x86_condition(insn: X86Insn, rflags: u64) -> bool {
    let zf = (rflags >> 6) & 1 == 1;
    let cf = rflags & 1 == 1;
    let sf = (rflags >> 7) & 1 == 1;
    let of = (rflags >> 11) & 1 == 1;

    match insn {
        X86Insn::X86_INS_JE => zf,
        X86Insn::X86_INS_JNE => !zf,
        X86Insn::X86_INS_JG => !zf && (sf == of),
        X86Insn::X86_INS_JGE => sf == of,
        X86Insn::X86_INS_JL => sf != of,
        X86Insn::X86_INS_JLE => zf || (sf != of),
        X86Insn::X86_INS_JA => !cf && !zf,
        X86Insn::X86_INS_JAE => !cf,
        X86Insn::X86_INS_JB => cf,
        X86Insn::X86_INS_JBE => cf || zf,
        _ => true,
    }
}

fn get_reg_from_context(reg_id: RegId, context: &DataT) -> Result<u64> {
    let id = reg_id.0 as u32;

    match id {
        X86Reg::X86_REG_CS => Ok(context.cs),
        X86Reg::X86_REG_SS => Ok(context.ss),
        X86Reg::X86_REG_EFLAGS => Ok(context.eflags),

        // --- 64-bit Registers ---
        X86Reg::X86_REG_RAX => Ok(context.rax),
        X86Reg::X86_REG_RBX => Ok(context.rbx),
        X86Reg::X86_REG_RCX => Ok(context.rcx),
        X86Reg::X86_REG_RDX => Ok(context.rdx),
        X86Reg::X86_REG_RDI => Ok(context.rdi),
        X86Reg::X86_REG_RSI => Ok(context.rsi),
        X86Reg::X86_REG_RBP => Ok(context.rbp),
        X86Reg::X86_REG_RSP => Ok(context.rsp),
        X86Reg::X86_REG_RIP => Ok(context.rip),
        X86Reg::X86_REG_R8 => Ok(context.r8),
        X86Reg::X86_REG_R9 => Ok(context.r9),
        X86Reg::X86_REG_R10 => Ok(context.r10),
        X86Reg::X86_REG_R11 => Ok(context.r11),
        X86Reg::X86_REG_R12 => Ok(context.r12),
        X86Reg::X86_REG_R13 => Ok(context.r13),
        X86Reg::X86_REG_R14 => Ok(context.r14),
        X86Reg::X86_REG_R15 => Ok(context.r15),

        // --- 32-bit Registers (EAX, EBX, etc.) ---
        X86Reg::X86_REG_EAX => Ok(context.rax as u32 as u64),
        X86Reg::X86_REG_EBX => Ok(context.rbx as u32 as u64),
        X86Reg::X86_REG_ECX => Ok(context.rcx as u32 as u64),
        X86Reg::X86_REG_EDX => Ok(context.rdx as u32 as u64),
        X86Reg::X86_REG_EDI => Ok(context.rdi as u32 as u64),
        X86Reg::X86_REG_ESI => Ok(context.rsi as u32 as u64),
        X86Reg::X86_REG_EBP => Ok(context.rbp as u32 as u64),
        X86Reg::X86_REG_ESP => Ok(context.rsp as u32 as u64),
        X86Reg::X86_REG_R8D => Ok(context.r8 as u32 as u64),
        X86Reg::X86_REG_R9D => Ok(context.r9 as u32 as u64),
        X86Reg::X86_REG_R10D => Ok(context.r10 as u32 as u64),
        X86Reg::X86_REG_R11D => Ok(context.r11 as u32 as u64),
        X86Reg::X86_REG_R12D => Ok(context.r12 as u32 as u64),
        X86Reg::X86_REG_R13D => Ok(context.r13 as u32 as u64),
        X86Reg::X86_REG_R14D => Ok(context.r14 as u32 as u64),
        X86Reg::X86_REG_R15D => Ok(context.r15 as u32 as u64),

        // --- 16-bit Registers (AX, BX, etc.) ---
        X86Reg::X86_REG_AX => Ok(context.rax as u16 as u64),
        X86Reg::X86_REG_BX => Ok(context.rbx as u16 as u64),
        X86Reg::X86_REG_CX => Ok(context.rcx as u16 as u64),
        X86Reg::X86_REG_DX => Ok(context.rdx as u16 as u64),
        X86Reg::X86_REG_R8W => Ok(context.r8 as u16 as u64),
        X86Reg::X86_REG_R9W => Ok(context.r9 as u16 as u64),
        X86Reg::X86_REG_R10W => Ok(context.r10 as u16 as u64),
        X86Reg::X86_REG_R11W => Ok(context.r11 as u16 as u64),
        X86Reg::X86_REG_R12W => Ok(context.r12 as u16 as u64),
        X86Reg::X86_REG_R13W => Ok(context.r13 as u16 as u64),
        X86Reg::X86_REG_R14W => Ok(context.r14 as u16 as u64),
        X86Reg::X86_REG_R15W => Ok(context.r15 as u16 as u64),

        // --- 8-bit Low Registers (AL, BL, CL, DL, SIL, DIL, BPL, SPL) ---
        X86Reg::X86_REG_AL => Ok(context.rax as u8 as u64),
        X86Reg::X86_REG_BL => Ok(context.rbx as u8 as u64),
        X86Reg::X86_REG_CL => Ok(context.rcx as u8 as u64),
        X86Reg::X86_REG_DL => Ok(context.rdx as u8 as u64),
        X86Reg::X86_REG_SIL => Ok(context.rsi as u8 as u64),
        X86Reg::X86_REG_DIL => Ok(context.rdi as u8 as u64),
        X86Reg::X86_REG_BPL => Ok(context.rbp as u8 as u64),
        X86Reg::X86_REG_SPL => Ok(context.rsp as u8 as u64),
        X86Reg::X86_REG_R8B => Ok(context.r8 as u8 as u64),
        X86Reg::X86_REG_R9B => Ok(context.r9 as u8 as u64),
        X86Reg::X86_REG_R10B => Ok(context.r10 as u8 as u64),
        X86Reg::X86_REG_R11B => Ok(context.r11 as u8 as u64),
        X86Reg::X86_REG_R12B => Ok(context.r12 as u8 as u64),
        X86Reg::X86_REG_R13B => Ok(context.r13 as u8 as u64),
        X86Reg::X86_REG_R14B => Ok(context.r14 as u8 as u64),
        X86Reg::X86_REG_R15B => Ok(context.r15 as u8 as u64),

        // --- 8-bit High Registers (AH, BH, CH, DH) ---
        X86Reg::X86_REG_AH => Ok((context.rax >> 8) as u8 as u64),
        X86Reg::X86_REG_BH => Ok((context.rbx >> 8) as u8 as u64),
        X86Reg::X86_REG_CH => Ok((context.rcx >> 8) as u8 as u64),
        X86Reg::X86_REG_DH => Ok((context.rdx >> 8) as u8 as u64),

        _ => bail!("Unsupported or unmapped x86 register id: {}", id),
    }
}

```

`edbgserver-cli/src/target/auvx.rs`:

```rs
use std::{fs::File, os::unix::fs::FileExt};

use gdbstub::target::{TargetError, TargetResult, ext::auxv::Auxv};
use log::{debug, error};

use crate::target::EdbgTarget;

impl Auxv for EdbgTarget {
    fn get_auxv(&self, offset: u64, length: usize, buf: &mut [u8]) -> TargetResult<usize, Self> {
        let pid = self.get_pid().map_err(|_| {
            error!("failed to get pid in get auxv");
            TargetError::NonFatal
        })?;
        let path = format!("/proc/{}/auxv", pid);
        debug!("get auxv: {}", path);
        let auvx_file = File::open(path).map_err(|e| {
            error!("failed to open auvx file: {}", e);
            TargetError::NonFatal
        })?;
        let len = std::cmp::min(length, buf.len());
        match auvx_file.read_at(&mut buf[..len], offset) {
            Ok(n) => Ok(n),
            Err(e) => Err(e.into()),
        }
    }
}

```

`edbgserver-cli/src/target/breakpoint.rs`:

```rs
use std::{os::fd::AsFd, path::PathBuf};

use anyhow::{Context, Result, anyhow, bail};
use aya::programs::{
    perf_event::{
        BreakpointConfig, PerfBreakpointLength, PerfBreakpointType, PerfEventConfig,
        PerfEventLinkId, PerfEventScope, SamplePolicy,
    },
    uprobe::UProbeLinkId,
};
use edbgserver_common::{DataT, ThreadFilter};
use gdbstub::{
    common::Tid,
    stub::MultiThreadStopReason,
    target::{
        TargetError, TargetResult,
        ext::breakpoints::{
            Breakpoints, HwBreakpoint, HwBreakpointOps, HwWatchpoint, HwWatchpointOps,
            SwBreakpoint, SwBreakpointOps, WatchKind,
        },
    },
};
use log::{debug, error, info, trace, warn};
use nix::poll::{PollFd, PollFlags, PollTimeout, poll};
use procfs::process::MMapPath;

use crate::target::EdbgTarget;

impl Breakpoints for EdbgTarget {
    #[inline(always)]
    fn support_sw_breakpoint(&mut self) -> Option<SwBreakpointOps<'_, Self>> {
        Some(self)
    }

    #[inline(always)]
    fn support_hw_breakpoint(&mut self) -> Option<HwBreakpointOps<'_, Self>> {
        Some(self)
    }

    #[inline(always)]
    fn support_hw_watchpoint(&mut self) -> Option<HwWatchpointOps<'_, Self>> {
        Some(self)
    }
}

#[derive(Debug)]
pub enum BreakpointHandle {
    UProbe(UProbeLinkId),
    Perf(Vec<PerfEventLinkId>),
}

impl SwBreakpoint for EdbgTarget {
    fn add_sw_breakpoint(
        &mut self,
        addr: u64,
        _kind: <Self::Arch as gdbstub::arch::Arch>::BreakpointKind,
    ) -> TargetResult<bool, Self> {
        debug!("gdb ask add swbreakpoint for addr {:#x}", addr);
        if self.active_sw_breakpoints.contains_key(&addr) {
            return Ok(false);
        }
        match self.internel_attach_uprobe(addr) {
            Ok(link_id) => {
                info!("Attached UProbe at VMA: {:#x}", addr);
                self.active_sw_breakpoints.insert(addr, link_id);
                Ok(true)
            }
            Err(e) => {
                warn!(
                    "Failed to add SW breakpoint at {:#x}: {:#}, fallback to HW breakpoint...",
                    addr, e
                );
                match self.internel_attach_perf_event_break_point(addr) {
                    Ok(link_ids) => {
                        info!("Attached perf event at VMA: {:#x}", addr);
                        self.active_sw_breakpoints.insert(addr, link_ids);
                        Ok(true)
                    }
                    Err(e) => {
                        error!("Failed to attach perf event at VMA {:#x}: {}", addr, e);
                        Ok(false)
                    }
                }
            }
        }
    }

    fn remove_sw_breakpoint(
        &mut self,
        addr: u64,
        _kind: <Self::Arch as gdbstub::arch::Arch>::BreakpointKind,
    ) -> TargetResult<bool, Self> {
        debug!("gdb ask remove swbreakpoint for addr {:#x}", addr);
        if let Some(link_id) = self.active_sw_breakpoints.remove(&addr) {
            log::info!("Detaching UProbe at VMA: {:#x}", addr);
            if let Err(e) = self.detach_breakpoint_handle(link_id) {
                error!("Failed to detach SW breakpoint at {:#x}: {:#}", addr, e);
                return Ok(false);
            }
            Ok(true)
        } else {
            Ok(false)
        }
    }
}

impl HwBreakpoint for EdbgTarget {
    fn add_hw_breakpoint(
        &mut self,
        addr: <Self::Arch as gdbstub::arch::Arch>::Usize,
        _kind: <Self::Arch as gdbstub::arch::Arch>::BreakpointKind,
    ) -> TargetResult<bool, Self> {
        debug!("gdb ask add hwbreakpoint for addr {:#x}", addr);
        if self.active_hw_breakpoints.contains_key(&addr) {
            return Ok(false);
        }
        match self.internel_attach_perf_event_break_point(addr) {
            Ok(link_ids) => {
                info!("Attached perf event at VMA: {:#x}", addr);
                self.active_hw_breakpoints.insert(addr, link_ids);
                Ok(true)
            }
            Err(e) => {
                error!("Failed to attach perf event at VMA {:#x}: {}", addr, e);
                Ok(false)
            }
        }
    }

    fn remove_hw_breakpoint(
        &mut self,
        addr: <Self::Arch as gdbstub::arch::Arch>::Usize,
        _kind: <Self::Arch as gdbstub::arch::Arch>::BreakpointKind,
    ) -> TargetResult<bool, Self> {
        debug!("gdb ask remove hwbreakpoint for addr {:#x}", addr);
        if let Some(link_ids) = self.active_hw_breakpoints.remove(&addr) {
            log::info!("Detaching perf events at VMA: {:#x}", addr);
            self.detach_breakpoint_handle(link_ids).map_err(|e| {
                error!("aya detach failed: {}", e);
                TargetError::NonFatal
            })?;
            Ok(true)
        } else {
            Ok(false)
        }
    }
}

pub struct WatchPointMeta {
    link_ids: Vec<PerfEventLinkId>,
    kind: WatchKind,
    len: u64,
}

impl HwWatchpoint for EdbgTarget {
    fn add_hw_watchpoint(
        &mut self,
        addr: <Self::Arch as gdbstub::arch::Arch>::Usize,
        len: <Self::Arch as gdbstub::arch::Arch>::Usize,
        kind: WatchKind,
    ) -> TargetResult<bool, Self> {
        debug!(
            "gdb ask add hwwatchpoint for addr {:#x}, len {}, kind {:?}",
            addr, len, kind
        );
        if self.active_watchpoint.contains_key(&addr) {
            return Ok(false);
        }
        // x86 debug registers cannot trigger on read-only watchpoints, so the
        // kernel rejects `HW_BREAKPOINT_R` outright, see
        // https://github.com/torvalds/linux/blob/v6.12/arch/x86/kernel/hw_breakpoint.c#L345-L377.
        // so convert read to read/write here
        #[cfg(target_arch = "x86_64")]
        let kind = match kind {
            WatchKind::Read => {
                warn!(
                    "x86 architecture does not support read-only watchpoints. Converting to read/write watchpoint at {:#x}",
                    addr
                );
                WatchKind::ReadWrite
            }
            other => other,
        };

        match self.internel_attach_perf_event_watch_point(addr, len, kind) {
            Ok(link_ids) => {
                info!("Attached perf event (watch point) at VMA: {:#x}", addr);
                self.active_watchpoint.insert(
                    addr,
                    WatchPointMeta {
                        link_ids,
                        kind,
                        len,
                    },
                );
                Ok(true)
            }
            Err(e) => {
                error!("Failed to attach perf event at VMA {:#x}: {}", addr, e);
                Ok(false)
            }
        }
    }

    fn remove_hw_watchpoint(
        &mut self,
        addr: <Self::Arch as gdbstub::arch::Arch>::Usize,
        _len: <Self::Arch as gdbstub::arch::Arch>::Usize,
        _kind: gdbstub::target::ext::breakpoints::WatchKind,
    ) -> TargetResult<bool, Self> {
        debug!("gdb ask remove hwwatchpoint for addr {:#x}", addr);
        let Some(watch_point_meta) = self.active_watchpoint.remove(&addr) else {
            return Ok(false);
        };
        log::info!("Detaching perf event (watch point) at VMA: {:#x}", addr);
        let prog = self.get_perf_event_program();
        let all_success = watch_point_meta
            .link_ids
            .into_iter()
            .map(|id| {
                prog.detach(id)
                    .map_err(|e| {
                        error!("aya detach failed: {}", e);
                        e
                    })
                    .is_ok()
            })
            .collect::<Vec<_>>()
            .into_iter()
            .all(|ok| ok);
        if !all_success {
            error!(
                "One or more perf event detachments failed at VMA: {:#x}",
                addr
            );
            return Ok(false);
        }
        Ok(true)
    }
}

impl EdbgTarget {
    fn resolve_vma_to_probe_location(&self, vma: u64) -> Result<(u64, PathBuf)> {
        let pid = self.get_pid()?;
        let process =
            procfs::process::Process::new(pid as i32).expect("Failed to open process info");
        let maps = process.maps().expect("Failed to read process maps");

        for map in maps {
            if vma < map.address.0 || vma >= map.address.1 {
                continue;
            }
            if let MMapPath::Path(path) = map.pathname {
                let file_offset = vma - map.address.0 + map.offset;
                return Ok((file_offset, path));
            } else {
                bail!(
                    "Cannot attach uprobe to anonymous/special memory at {:#x} (name: {:?})",
                    vma,
                    map.pathname
                );
            }
        }
        bail!("Failed to find mapping for VMA {:#x}", vma);
    }

    pub fn internel_attach_uprobe(&mut self, addr: u64) -> Result<BreakpointHandle> {
        let (location, target) = self
            .resolve_vma_to_probe_location(addr)
            .context(format!("Failed to resolve VMA {:#x}", addr))?;
        let target_pid = self.get_pid()?;
        debug!(
            "Attaching Temp/Internal UProbe to {:?} at offset {:#x} (VMA: {:#x})",
            target, location, addr
        );
        let link_id = self
            .get_probe_program()
            .attach(location, target.canonicalize()?, Some(target_pid), None)
            .map_err(|e| {
                error!(
                    "aya uprobe attach failed. location: {:#x}, target: {:?}, pid: {}. error: {:#?}",
                    location, target, target_pid, e
                );
                anyhow::anyhow!("aya urpobe attach failed: {}", e)
            })?;
        Ok(BreakpointHandle::UProbe(link_id))
    }

    pub fn internel_attach_perf_event_break_point(
        &mut self,
        addr: u64,
    ) -> Result<BreakpointHandle> {
        let pid = self.get_pid()?;
        debug!("Attaching perf event to {:#x} for process {}", addr, pid);
        let config = PerfEventConfig::Breakpoint(BreakpointConfig::Instruction { address: addr });
        let sample_policy = SamplePolicy::Period(1);
        let tasks = if self.is_multi_thread {
            procfs::process::Process::new(pid as i32)
                .map_err(|e| anyhow::anyhow!("Failed to open process {}: {}", pid, e))?
                .tasks()?
                .filter_map(|t| t.ok())
                .map(|t| t.tid as u32)
                .collect::<Vec<_>>()
        } else {
            vec![self.bound_tid.expect("bound_tid is not set")]
        };
        let mut links = Vec::new();
        let prog = self.get_perf_event_program();
        for tid in tasks {
            let scope = PerfEventScope::OneProcess {
                pid: tid,
                cpu: None,
            };
            let link_id = prog
                .attach(config, scope, sample_policy, true)
                .map_err(|e| {
                    error!(
                        "aya perf event attach failed. addr: {:#x}, tid: {}. error: {:#?}",
                        addr, tid, e
                    );
                    anyhow::anyhow!("aya perf event attach failed for tid {}: {}", tid, e)
                })?;
            trace!("Attached perf event to thread TID: {}", tid);
            links.push(link_id);
        }
        Ok(BreakpointHandle::Perf(links))
    }

    pub fn internel_attach_perf_event_watch_point(
        &mut self,
        address: u64,
        length: u64,
        kind: WatchKind,
    ) -> Result<Vec<PerfEventLinkId>> {
        debug!("Attaching perf event (watch point) to {:#x}", address);
        let rw_flags = match kind {
            WatchKind::Write => PerfBreakpointType::Write,
            WatchKind::Read => PerfBreakpointType::Read,
            WatchKind::ReadWrite => PerfBreakpointType::ReadWrite,
        };
        let length = match length {
            1 => PerfBreakpointLength::Len1,
            2 => PerfBreakpointLength::Len2,
            4 => PerfBreakpointLength::Len4,
            8 => PerfBreakpointLength::Len8,
            _ => {
                return Err(anyhow::anyhow!(
                    "Unsupported watchpoint length: {}. Supported lengths are 1, 2, 4, or 8 bytes.",
                    length
                ));
            }
        };
        let config = PerfEventConfig::Breakpoint(BreakpointConfig::Data {
            r#type: rw_flags,
            address,
            length,
        });
        let pid = self.get_pid()?;
        let tasks = if self.is_multi_thread {
            procfs::process::Process::new(pid as i32)
                .map_err(|e| anyhow::anyhow!("Failed to open process {}: {}", pid, e))?
                .tasks()?
                .filter_map(|t| t.ok())
                .map(|t| t.tid as u32)
                .collect::<Vec<_>>()
        } else {
            vec![self.bound_tid.expect("bound_tid is not set")]
        };
        let mut links = Vec::new();
        let prog = self.get_perf_event_program();
        let sample_policy = SamplePolicy::Period(1); // sample every events
        for tid in tasks {
            let scope = PerfEventScope::OneProcess {
                pid: tid,
                cpu: None,
            };
            let link_id = prog
                .attach(config, scope, sample_policy, true)
                .map_err(|e| {
                    error!(
                        "aya perf event attach (watch point) failed. addr: {:#x}, tid: {}. error: {:#?}",
                        address, tid, e
                    );
                    anyhow::anyhow!("aya perf event attach (watch point) failed for tid {}: {}", tid, e)
                })?;
            debug!("Attached watch point to thread TID: {}", tid);
            links.push(link_id);
        }
        Ok(links)
    }

    fn detach_breakpoint_handle(&mut self, handle: BreakpointHandle) -> Result<()> {
        match handle {
            BreakpointHandle::UProbe(id) => self
                .get_probe_program()
                .detach(id)
                .map_err(|e| anyhow!("UProbe detach failed: {}", e)),
            BreakpointHandle::Perf(ids) => {
                let prog = self.get_perf_event_program();
                let mut last_err = None;
                for id in ids {
                    if let Err(e) = prog.detach(id) {
                        last_err = Some(e);
                    }
                }
                if let Some(e) = last_err {
                    bail!("Perf detach failed: {}", e);
                }
                Ok(())
            }
        }
    }

    pub fn attach_init_probe(
        &mut self,
        binary_target: PathBuf,
        break_point: u64,
        target_pid: Option<u32>,
    ) -> Result<()> {
        info!(
            "Attaching Initial UProbe at {}:{:#x}",
            binary_target.canonicalize()?.as_os_str().display(),
            break_point
        );
        let link_id = self.get_probe_program().attach(
            break_point,
            binary_target.canonicalize()?,
            target_pid,
            None,
        )?;
        self.bound_pid = target_pid;

        self.init_probe_link_id = Some(BreakpointHandle::UProbe(link_id));
        Ok(())
    }

    pub async fn wait_for_init_trap(&mut self) -> Result<()> {
        info!("Waiting for target process to hit the initial breakpoint...");
        let target_fd = self.notifier.as_fd();
        let mut fds = [PollFd::new(target_fd, PollFlags::POLLIN)];
        loop {
            poll(&mut fds, PollTimeout::NONE)?;
            let Some(revents) = fds[0].revents() else {
                continue;
            };
            if !revents.contains(PollFlags::POLLIN) {
                continue;
            }

            let mut captured_events = Vec::new();
            while let Some(item) = self.ring_buf.next() {
                let ptr = item.as_ptr() as *const DataT;
                let data = unsafe { std::ptr::read_unaligned(ptr) };
                captured_events.push(data);
            }
            if captured_events.is_empty() {
                continue;
            }

            // first event is the one we care about
            let first_event = captured_events.first().unwrap();
            // if the target pid is specify and doesn't match, this will happen in namespace scenario (e.g WSL)
            // we just map it to the our target pid
            let target_pid = if let Some(target_pid) = self.bound_pid
                && first_event.pid != target_pid
            {
                warn!(
                    "Mapped PID: {} to specified target PID: {} (this may happen in namespace scenarios like WSL)",
                    first_event.pid, target_pid
                );
                target_pid
            } else {
                first_event.pid
            };
            let target_tid = first_event.tid;
            let trap_pc = first_event.pc();

            info!(
                "Initial UProbe Hit! Locking onto PID: {}. TID: {}, PC: {:#x}",
                target_pid, target_tid, trap_pc
            );
            self.context = Some(*first_event);

            let exe = procfs::process::Process::new(target_pid as i32).and_then(|p| p.exe())?;
            debug!(
                "Target process executable path: {}",
                exe.canonicalize()?.as_os_str().display()
            );
            self.exec_path = Some(exe);
            self.bound_pid = Some(target_pid);
            self.bound_tid = Some(target_tid);

            use process_memory::TryIntoProcessHandle;
            self.process_memory_handle = (target_pid as i32).try_into_process_handle().ok();

            if let Err(e) = self.update_libraries_cache() {
                error!("Failed to update libraries cache in init trap: {}", e);
            }

            if !self.is_multi_thread {
                self.thread_filter
                    .set(0, ThreadFilter::Some(target_tid), 0)
                    .context(anyhow!("thread filter set failed"))?;
            }

            if let Some(link_id) = self.init_probe_link_id.take() {
                info!("Removing initial temporary breakpoint");
                if let Err(e) = self.detach_breakpoint_handle(link_id) {
                    error!("Failed to detach initial probe: {}", e);
                }
            } else {
                warn!(
                    "Initial trap hit at {:#x}, but no init urpobe link id to remove.",
                    trap_pc
                );
            }

            // handle any extra events from other processes in the same target
            for event in captured_events.iter().skip(1) {
                if event.pid != target_pid {
                    warn!(
                        "Ignored process PID: {} (PC: {:#x}). We are locked to PID: {}",
                        event.pid, trap_pc, target_pid
                    );
                } else {
                    debug!("Skipping extra event for target PID in init batch.");
                }
            }

            return Ok(());
        }
    }

    pub fn determine_stop_reason(
        &self,
        tid: u32,
        pc: u64,
        fault_addr: u64,
    ) -> MultiThreadStopReason<u64> {
        let tid = Tid::new(tid as usize).unwrap();
        if let Some((step_pc, _)) = self.temp_step_breakpoints
            && pc == step_pc
        {
            debug!("Step breakpoint hit at {:#x} for TID: {}", pc, tid);
            return MultiThreadStopReason::DoneStep;
        }
        if let Some(breakpoint) = self.active_sw_breakpoints.get(&pc) {
            match breakpoint {
                BreakpointHandle::UProbe(_uprobe_link_id) => {
                    debug!(
                        "Software UProbe breakpoint hit at {:#x} for TID: {}",
                        pc, tid
                    );
                    return MultiThreadStopReason::SwBreak(tid);
                }
                BreakpointHandle::Perf(_perf_event_link_ids) => {
                    debug!(
                        "Software perf event breakpoint hit at {:#x} for TID: {}",
                        pc, tid
                    );
                    return MultiThreadStopReason::SwBreak(tid);
                }
            }
        }
        if let Some(_breakpoint) = self.active_hw_breakpoints.get(&pc) {
            debug!("Hardware breakpoint hit at {:#x} for TID: {}", pc, tid);
            return MultiThreadStopReason::HwBreak(tid);
        }
        for (watch_start, meta) in &self.active_watchpoint {
            if fault_addr >= *watch_start && fault_addr < *watch_start + meta.len {
                debug!(
                    "Watchpoint hit at {:#x} (watch range: {:#x} - {:#x}) for TID: {}",
                    fault_addr,
                    watch_start,
                    watch_start + meta.len,
                    tid
                );
                return MultiThreadStopReason::Watch {
                    tid,
                    kind: meta.kind,
                    addr: *watch_start,
                };
            }
        }

        warn!("stop reason fallback to SIGSTOP for TID: {}", tid);
        MultiThreadStopReason::SignalWithThread {
            tid,
            signal: gdbstub::common::Signal::SIGSTOP,
        }
    }

    pub fn handle_trap(&mut self) -> Result<()> {
        let Some(context) = &self.context else {
            bail!("No context available to handle trap.");
        };
        debug!(
            "Handling trap for TID: {}, PC: {:#x}",
            context.tid,
            context.pc()
        );
        self.bound_tid = Some(context.tid);
        if let Some((addr, link_id)) = self.temp_step_breakpoints.take() {
            if addr == context.pc() {
                debug!(
                    "Temp breakpoint hit at {:#x} for TID: {}. Detaching UProbe.",
                    addr, context.tid
                );
                if let Err(e) = self.detach_breakpoint_handle(link_id) {
                    error!("Failed to detach UProbe at {:#x}: {}", addr, e);
                }
            } else {
                debug!(
                    "Trap at {:#x} does not match temp breakpoint at {:#x}. Cleaning up temp breakpoint anyway.",
                    context.pc(),
                    addr
                );
                let _ = self.detach_breakpoint_handle(link_id);
            }
        }
        self.update_libraries_cache()
    }
}

```

`edbgserver-cli/src/target/execfile.rs`:

```rs
use gdbstub::target::{TargetError, ext::exec_file::ExecFile};
use log::debug;
use procfs::process::Process;

use crate::target::EdbgTarget;

impl ExecFile for EdbgTarget {
    fn get_exec_file(
        &self,
        pid: Option<gdbstub::common::Pid>,
        offset: u64,
        length: usize,
        buf: &mut [u8],
    ) -> gdbstub::target::TargetResult<usize, Self> {
        debug!("get exec file {:?}", pid);
        let path = if let Some(path) = &self.exec_path {
            path.clone()
        } else {
            let target_pid = pid
                .map(|p| p.get() as u32)
                .or(self.bound_pid)
                .ok_or(TargetError::NonFatal)?;

            Process::new(target_pid as i32)
                .and_then(|p| p.exe())
                .map_err(|_| TargetError::NonFatal)?
        };

        let path_str = path
            .canonicalize()
            .unwrap_or_else(|_| path.clone())
            .to_string_lossy()
            .to_string();
        let path_bytes = path_str.as_bytes();
        let total_len = path_bytes.len();
        let offset = offset as usize;

        if offset >= total_len {
            return Ok(0);
        }
        let available_len = total_len - offset;
        let copy_len = std::cmp::min(available_len, length);
        let copy_len = std::cmp::min(copy_len, buf.len());
        buf[..copy_len].copy_from_slice(&path_bytes[offset..offset + copy_len]);
        Ok(copy_len)
    }
}

```

`edbgserver-cli/src/target/host_io.rs`:

```rs
use std::{ffi::OsStr, os::unix::ffi::OsStrExt, path::Path};

use gdbstub::target::ext::host_io::{
    HostIo, HostIoClose, HostIoCloseOps, HostIoErrno, HostIoError, HostIoFstat, HostIoFstatOps,
    HostIoOpen, HostIoOpenFlags, HostIoOpenMode, HostIoOpenOps, HostIoPread, HostIoPreadOps,
    HostIoPwrite, HostIoPwriteOps, HostIoReadlink, HostIoReadlinkOps, HostIoResult, HostIoStat,
    HostIoUnlink, HostIoUnlinkOps,
};
use log::debug;

use crate::{target::EdbgTarget, virtual_file::VirtualFile};

impl HostIo for EdbgTarget {
    #[inline(always)]
    fn support_open(&mut self) -> Option<HostIoOpenOps<'_, Self>> {
        Some(self)
    }

    #[inline(always)]
    fn support_close(&mut self) -> Option<HostIoCloseOps<'_, Self>> {
        Some(self)
    }

    #[inline(always)]
    fn support_pread(&mut self) -> Option<HostIoPreadOps<'_, Self>> {
        Some(self)
    }

    #[inline(always)]
    fn support_pwrite(&mut self) -> Option<HostIoPwriteOps<'_, Self>> {
        Some(self)
    }

    #[inline(always)]
    fn support_fstat(&mut self) -> Option<HostIoFstatOps<'_, Self>> {
        Some(self)
    }

    #[inline(always)]
    fn support_readlink(&mut self) -> Option<HostIoReadlinkOps<'_, Self>> {
        Some(self)
    }

    #[inline(always)]
    fn support_unlink(&mut self) -> Option<HostIoUnlinkOps<'_, Self>> {
        Some(self)
    }
}

impl HostIoOpen for EdbgTarget {
    fn open(
        &mut self,
        filename: &[u8],
        flags: HostIoOpenFlags,
        mode: HostIoOpenMode,
    ) -> HostIoResult<u32, Self> {
        match VirtualFile::open(filename, flags, mode, self.need_filter_maps) {
            Ok(vfile) => {
                let fd = self.next_host_io_fd;
                self.next_host_io_fd = fd
                    .checked_add(1)
                    .ok_or(HostIoError::Errno(HostIoErrno::EMFILE))?;

                self.host_io_files.insert(fd, vfile);

                debug!("HostIo: Opened fd={} (flags={:?})", fd, flags);
                Ok(fd)
            }
            Err(e) => Err(HostIoError::from(e)),
        }
    }
}

impl HostIoClose for EdbgTarget {
    fn close(&mut self, fd: u32) -> HostIoResult<(), Self> {
        if self.host_io_files.remove(&fd).is_some() {
            debug!("HostIo: Closed fd={}", fd);
            Ok(())
        } else {
            Err(HostIoError::Errno(HostIoErrno::EBADF))
        }
    }
}

impl HostIoPread for EdbgTarget {
    fn pread(
        &mut self,
        fd: u32,
        count: usize,
        offset: u64,
        buf: &mut [u8],
    ) -> HostIoResult<usize, Self> {
        let file = self
            .host_io_files
            .get_mut(&fd)
            .ok_or(HostIoError::Errno(HostIoErrno::EBADF))?;

        let len = std::cmp::min(count, buf.len());
        file.read_at(offset, &mut buf[..len])
            .map_err(HostIoError::from)
    }
}

impl HostIoPwrite for EdbgTarget {
    fn pwrite(&mut self, fd: u32, offset: u64, data: &[u8]) -> HostIoResult<u64, Self> {
        let file = self
            .host_io_files
            .get_mut(&fd)
            .ok_or(HostIoError::Errno(HostIoErrno::EBADF))?;

        file.write_at(offset, data).map_err(HostIoError::from)
    }
}

impl HostIoFstat for EdbgTarget {
    fn fstat(&mut self, fd: u32) -> HostIoResult<HostIoStat, Self> {
        let file = self
            .host_io_files
            .get(&fd)
            .ok_or(HostIoError::Errno(HostIoErrno::EBADF))?;

        file.stat().map_err(HostIoError::from)
    }
}

impl HostIoReadlink for EdbgTarget {
    fn readlink(&mut self, filename: &[u8], buf: &mut [u8]) -> HostIoResult<usize, Self> {
        let path = Path::new(OsStr::from_bytes(filename));
        let target = std::fs::read_link(path).map_err(HostIoError::from)?;
        let bytes = target.as_os_str().as_bytes();
        let len = std::cmp::min(bytes.len(), buf.len());
        buf[..len].copy_from_slice(&bytes[..len]);
        Ok(len)
    }
}

impl HostIoUnlink for EdbgTarget {
    fn unlink(&mut self, filename: &[u8]) -> HostIoResult<(), Self> {
        std::fs::remove_file(Path::new(OsStr::from_bytes(filename))).map_err(HostIoError::from)
    }
}

```

`edbgserver-cli/src/target/libraries.rs`:

```rs
use std::{cmp::min, io::Read, iter};

use anyhow::{Result, anyhow};
use gdbstub::target::{TargetResult, ext::libraries::LibrariesSvr4};
use log::{debug, error, trace};
use tagu::{build, prelude::*};
use zerocopy::{FromBytes, Immutable, IntoBytes, KnownLayout};

use crate::target::EdbgTarget;

// https://github.com/lattera/glibc/blob/895ef79e04a953cac1493863bcae29ad85657ee1/elf/link.h#L42
// struct r_debug
//   {
//     int r_version;                /* Version number for this protocol.  */
//     struct link_map *r_map;        /* Head of the chain of loaded objects.  */
//     /* This is the address of a function internal to the run-time linker,
//        that will always be called when the linker begins to map in a
//        library or unmap it, and again when the mapping change is complete.
//        The debugger can set a breakpoint at this address if it wants to
//        notice shared object mapping changes.  */
//     ElfW(Addr) r_brk;
//     enum
//       {
//         /* This state value describes the mapping change taking place when
//            the `r_brk' address is called.  */
//         RT_CONSISTENT,                /* Mapping change is complete.  */
//         RT_ADD,                        /* Beginning to add a new object.  */
//         RT_DELETE                /* Beginning to remove an object mapping.  */
//       } r_state;
//     ElfW(Addr) r_ldbase;        /* Base address the linker is loaded at.  */
//   };

// /* This is the instance of that structure used by the dynamic linker.  */
// extern struct r_debug _r_debug;
// /* This symbol refers to the "dynamic structure" in the `.dynamic' section
//    of whatever module refers to `_DYNAMIC'.  So, to find its own
//    `struct r_debug', a program could do:
//      for (dyn = _DYNAMIC; dyn->d_tag != DT_NULL; ++dyn)
//        if (dyn->d_tag == DT_DEBUG)
//          r_debug = (struct r_debug *) dyn->d_un.d_ptr;
//    */
// extern ElfW(Dyn) _DYNAMIC[];

// /* Structure describing a loaded shared object.  The `l_next' and `l_prev'
//    members form a chain of all the shared objects loaded at startup.
//    These data structures exist in space used by the run-time dynamic linker;
//    modifying them may have disastrous results.  */
// struct link_map
//   {
//     /* These first few members are part of the protocol with the debugger.
//        This is the same format used in SVR4.  */
//     ElfW(Addr) l_addr;                /* Base address shared object is loaded at.  */
//     char *l_name;                /* Absolute file name object was found in.  */
//     ElfW(Dyn) *l_ld;                /* Dynamic section of the shared object.  */
//     struct link_map *l_next, *l_prev; /* Chain of loaded objects.  */
//   };

#[repr(C)]
#[derive(Debug, Clone, Copy, FromBytes, IntoBytes, Immutable, KnownLayout)]
pub struct RDebug {
    pub r_version: i32,
    pub _pad1: u32, // Padding
    pub r_map: u64,
    pub r_brk: u64,
    pub r_state: i32,
    pub _pad2: u32, // Padding
    pub r_ldbase: u64,
}

#[repr(C)]
#[derive(Debug, Clone, Copy, FromBytes, IntoBytes, Immutable, KnownLayout)]
pub struct LinkMap {
    pub l_addr: u64,
    pub l_name: u64,
    pub l_ld: u64,
    pub l_next: u64,
    pub l_prev: u64,
}

#[repr(C)]
#[derive(Debug, Clone, Copy, FromBytes, Immutable, KnownLayout)]
struct AuxvEntry {
    key: u64,
    val: u64,
}

#[repr(C)]
#[derive(Debug, Clone, Copy, FromBytes, Immutable, KnownLayout)]
struct ElfDyn {
    d_tag: i64,
    d_val: u64,
}

// https://github.com/lattera/glibc/blob/895ef79e04a953cac1493863bcae29ad85657ee1/elf/elf.h#L1148C1-L1148C40
const AT_PHDR: u64 = 3;

const DT_NULL: i64 = 0;
const DT_DEBUG: i64 = 21;

const MAX_LINK_MAP_COUNT: usize = 1024;
const MAX_DYN_ENTRIES_COUNT: usize = 1024;
const MAX_CSTRING_LEN: usize = 4096;

impl EdbgTarget {
    fn read_struct<T: FromBytes + Copy>(&self, addr: u64) -> Result<T> {
        let mut buf = vec![0u8; std::mem::size_of::<T>()];
        use process_memory::CopyAddress;
        self.process_memory_handle
            .ok_or(anyhow!("process handle is not init"))?
            .copy_address(addr as usize, buf.as_mut_slice())?;
        T::read_from_bytes(&buf).map_err(|_| anyhow!("Failed to parse struct from bytes"))
    }

    fn read_cstring(&self, addr: u64, max_len: usize) -> Result<String> {
        let mut buf = vec![0u8; max_len];
        use process_memory::CopyAddress;
        self.process_memory_handle
            .ok_or(anyhow!("process handle is not init"))?
            .copy_address(addr as usize, buf.as_mut_slice())?;
        if let Some(pos) = buf.iter().position(|&c| c == 0) {
            buf.truncate(pos);
        }
        Ok(String::from_utf8_lossy(&buf).to_string())
    }

    fn get_auxv_val(&self, target_key: u64) -> Result<u64> {
        let pid = self.get_pid()?;
        let auxv_path = format!("/proc/{}/auxv", pid);
        let mut auxv_file = std::fs::File::open(&auxv_path)?;

        iter::from_fn(|| {
            let mut buf = [0u8; 16];
            match auxv_file.read_exact(&mut buf) {
                Ok(_) => AuxvEntry::read_from_bytes(&buf).ok(),
                Err(_) => None, // EOF or Error
            }
        })
        .find(|entry| entry.key == target_key)
        .map(|entry| entry.val)
        .ok_or_else(|| anyhow!("Auxv key {} not found", target_key))
    }

    fn find_r_debug_addr(&self) -> Result<u64> {
        let path = self
            .exec_path
            .as_ref()
            .ok_or(anyhow!("exec_path not set"))?;
        let exec_binary = std::fs::read(path)?;
        let exec_elf = goblin::elf::Elf::parse(exec_binary.as_slice())?;

        // get exec dyn segment addr
        let real_phdr_addr = self.get_auxv_val(AT_PHDR)?;
        let phdr_entry = exec_elf
            .program_headers
            .iter()
            .find(|ph| ph.p_type == goblin::elf::program_header::PT_PHDR)
            .ok_or(anyhow!("No PT_PHDR found in executable"))?;
        let dynamic_entry = exec_elf
            .program_headers
            .iter()
            .find(|ph| ph.p_type == goblin::elf::program_header::PT_DYNAMIC)
            .ok_or(anyhow!("No PT_DYNAMIC found in executable"))?;
        let real_dyn_addr = real_phdr_addr
            .wrapping_add(dynamic_entry.p_vaddr)
            .wrapping_sub(phdr_entry.p_vaddr);
        debug!(
            "Calculated real dynamic segment address: {:#x} = {:#x} + {:#x} - {:#x}",
            real_dyn_addr, real_phdr_addr, dynamic_entry.p_vaddr, phdr_entry.p_vaddr
        );

        let mut now_real_dyn_addr = real_dyn_addr;
        iter::from_fn(|| match self.read_struct::<ElfDyn>(now_real_dyn_addr) {
            Ok(dyn_entry) => {
                now_real_dyn_addr += std::mem::size_of::<ElfDyn>() as u64;
                if dyn_entry.d_tag == DT_NULL {
                    None
                } else {
                    Some(dyn_entry)
                }
            }
            Err(e) => {
                error!(
                    "Failed to read _DYNAMIC entry at {:#x}: {}",
                    real_dyn_addr, e
                );
                None
            }
        })
        .take(MAX_DYN_ENTRIES_COUNT)
        .find(|entry| entry.d_tag == DT_DEBUG)
        .map(|entry| entry.d_val)
        .ok_or_else(|| anyhow!("DT_DEBUG entry not found in _DYNAMIC section"))
    }

    fn generate_xml_from_memory(&self, r_debug_addr: u64) -> Result<String> {
        debug!("generate_xml_from_memory called");
        let lib_elems = self
            .read_struct::<RDebug>(r_debug_addr)
            .inspect_err(|e| error!("Failed to read r_debug struct: {}", e))
            .map(|r_debug| {
                let mut next_link_map = r_debug.r_map;
                iter::from_fn(|| {
                    if next_link_map == 0 {
                        return None;
                    }
                    match self.read_struct::<LinkMap>(next_link_map) {
                        Ok(map) => {
                            trace!("Read link_map at {:#x}: {:?}", next_link_map, map);
                            let current_addr = next_link_map;
                            next_link_map = map.l_next;
                            Some((current_addr, map))
                        }
                        Err(e) => {
                            error!("Failed to read link_map at {:#x}: {}", next_link_map, e);
                            None
                        }
                    }
                })
                .take(MAX_LINK_MAP_COUNT)
                .map(|(addr, map)| {
                    let name = (map.l_name != 0)
                        .then(|| self.read_cstring(map.l_name, MAX_CSTRING_LEN).ok())
                        .flatten()
                        .unwrap_or_default();

                    // - name, the absolute file name from the l_name field of struct link_map.
                    // - lm with address of struct link_map used for TLS (Thread Local Storage) access.
                    // - l_addr, the displacement as read from the field l_addr of struct link_map. For prelinked libraries this is
                    //   not an absolute memory address. It is a displacement of absolute memory address against address the file was
                    //   prelinked to during the library load.
                    // - l_ld, which is memory address of the PT_DYNAMIC segment
                    // - lmid, which is an identifier for a linker namespace, such as the memory address of the r_debug object that
                    //   contains this namespace’s load map or the namespace identifier returned by dlinfo (3).
                    build::single("library").with(attrs!(
                        ("name", name),
                        ("lm", format_move!("{:#x}", addr)),
                        ("l_addr", format_move!("{:#x}", map.l_addr)),
                        ("l_ld", format_move!("{:#x}", map.l_ld)),
                        ("lmid", 0)
                    ))
                })
                .collect::<Vec<_>>()
            })
            .unwrap_or_default();

        let root = build::elem("library-list-svr4")
            .with(("version", "1.0"))
            .append(build::from_iter(lib_elems.into_iter()));

        let mut xml = String::new();
        tagu::render(root, &mut xml)?;
        Ok(xml)
    }

    pub fn update_libraries_cache(&mut self) -> Result<()> {
        if self.r_debug_addr.is_none() {
            debug!("r_debug_addr is None, parsing ELF to find it...");
            let addr = self.find_r_debug_addr()?;
            self.r_debug_addr = Some(addr);
        }
        let r_debug_addr = self.r_debug_addr.unwrap();
        let xml_content = self.generate_xml_from_memory(r_debug_addr)?;
        if self.cached_libraries_xml != xml_content {
            debug!(
                "Libraries list changed, updating cache. Len: {}",
                xml_content.len()
            );
            self.cached_libraries_xml = xml_content;
        }
        Ok(())
    }
}

impl LibrariesSvr4 for EdbgTarget {
    fn get_libraries_svr4(
        &self,
        offset: u64,
        length: usize,
        buf: &mut [u8],
    ) -> TargetResult<usize, Self> {
        debug!(
            "get_libraries_svr4 called with offset={} length={}",
            offset, length
        );
        let xml_bytes = self.cached_libraries_xml.as_bytes();
        let offset = offset as usize;
        let total_len = xml_bytes.len();
        if offset >= total_len {
            return Ok(0);
        }
        let available = total_len - offset;
        let bytes_to_write = min(available, min(length, buf.len()));
        buf[0..bytes_to_write].copy_from_slice(&xml_bytes[offset..offset + bytes_to_write]);
        Ok(bytes_to_write)
    }
}

```

`edbgserver-cli/src/target/memory_map.rs`:

```rs
use std::cmp::min;

use gdbstub::target::{TargetError, TargetResult, ext::memory_map::MemoryMap};
use log::error;
use procfs::process::MMPermissions;

impl MemoryMap for super::EdbgTarget {
    fn memory_map_xml(
        &self,
        offset: u64,
        length: usize,
        buf: &mut [u8],
    ) -> TargetResult<usize, Self> {
        let pid = self.get_pid().map_err(|e| {
            error!("Failed to get PID for memory map: {}", e);
            TargetError::NonFatal
        })?;

        let process = procfs::process::Process::new(pid as i32).map_err(|e| {
            error!("Failed to open process for memory map: {}", e);
            TargetError::NonFatal
        })?;

        let maps = process.maps().map_err(|e| {
            error!("Failed to read process maps: {}", e);
            TargetError::NonFatal
        })?;

        let mut xml = String::new();

        xml.push_str(r#"<?xml version="1.0"?>"#);
        xml.push_str(r#"<!DOCTYPE memory-map PUBLIC "+//IDN gnu.org//DTD GDB Memory Map V1.0//EN" "http://sourceware.org/gdb/gdb-memory-map.dtd">"#);
        xml.push_str(r#"<memory-map>"#);

        for map in maps {
            if map.perms.contains(MMPermissions::READ) {
                let start = map.address.0;
                let len = map.address.1 - map.address.0;
                // r-x, r-- -> rom
                // rw-, rwx -> ram
                let type_str = if map.perms.contains(MMPermissions::WRITE) {
                    "ram"
                } else {
                    // "rom"
                    "ram" // make gdb use soft breakpoints at text segments
                };

                xml.push_str(&format!(
                    r#"<memory type="{}" start="{:#x}" length="{:#x}"/>"#,
                    type_str, start, len
                ));
            }
        }

        xml.push_str(r#"</memory-map>"#);

        let xml_bytes = xml.as_bytes();
        let offset = offset as usize;
        if offset >= xml_bytes.len() {
            return Ok(0); // EOF
        }
        let available = xml_bytes.len() - offset;
        let bytes_to_write = min(available, min(length, buf.len()));
        buf[0..bytes_to_write].copy_from_slice(&xml_bytes[offset..offset + bytes_to_write]);

        Ok(bytes_to_write)
    }
}

```

`edbgserver-cli/src/target/multithread.rs`:

```rs
use std::{collections::HashSet, ffi::OsStr, num::NonZero, os::unix::ffi::OsStrExt, process};

use anyhow::{Result, anyhow, bail};
use gdbstub::{
    common::{Signal, Tid},
    target::{
        TargetError, TargetResult,
        ext::{
            base::multithread::{
                MultiThreadResume, MultiThreadSchedulerLocking, MultiThreadSingleStep,
            },
            extended_mode::{CurrentActivePid, ExtendedMode, ShouldTerminate},
        },
    },
};
use log::{debug, error, info, trace, warn};
use procfs::process::Process;

use crate::{
    target::EdbgTarget,
    utils::{send_sig_to_process, send_sig_to_thread, send_sigcont_to_thread},
};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ThreadAction {
    Continue(Option<Signal>),
    Step(Option<Signal>),
}

impl MultiThreadSingleStep for EdbgTarget {
    fn set_resume_action_step(
        &mut self,
        tid: Tid,
        signal: Option<Signal>,
    ) -> Result<(), Self::Error> {
        debug!("set resume action step for TID: {}", tid);
        self.resume_actions.push((tid, ThreadAction::Step(signal)));
        Ok(())
    }
}

impl MultiThreadSchedulerLocking for EdbgTarget {
    fn set_resume_action_scheduler_lock(&mut self) -> Result<(), Self::Error> {
        self.is_scheduler_lock = true;
        Ok(())
    }
}

impl MultiThreadResume for EdbgTarget {
    fn clear_resume_actions(&mut self) -> Result<(), Self::Error> {
        debug!("clear resume actions");
        self.resume_actions.clear();
        self.is_scheduler_lock = false;

        while self.ring_buf.next().is_some() {
            warn!("Draining stale event from ring buffer before resume");
        }
        Ok(())
    }

    fn set_resume_action_continue(
        &mut self,
        tid: Tid,
        signal: Option<Signal>,
    ) -> Result<(), Self::Error> {
        debug!("set resume action continue for TID: {}", tid);
        self.resume_actions
            .push((tid, ThreadAction::Continue(signal)));
        Ok(())
    }

    #[inline(always)]
    fn support_single_step(
        &mut self,
    ) -> Option<gdbstub::target::ext::base::multithread::MultiThreadSingleStepOps<'_, Self>> {
        Some(self)
    }

    #[inline(always)]
    fn support_scheduler_locking(
        &mut self,
    ) -> Option<gdbstub::target::ext::base::multithread::MultiThreadSchedulerLockingOps<'_, Self>>
    {
        Some(self)
    }

    fn resume(&mut self) -> Result<(), Self::Error> {
        let target_pid = self.get_pid()?;
        debug!("start handling resuming process {}", target_pid);

        let mut done_cont: HashSet<u32> = HashSet::new();

        let mut dispatch_signal = |tid: u32, signal: Option<&Signal>| {
            if let Some(sig) = signal {
                send_sig_to_thread(target_pid, tid, sig);
            } else {
                send_sigcont_to_thread(target_pid, tid);
                done_cont.insert(tid);
            }
        };

        for (tid, action) in &self.resume_actions.clone() {
            let tid = tid.get() as u32;
            match action {
                ThreadAction::Continue(signal) => {
                    debug!("Continuing thread {} with signal {:?}", tid, signal);
                    dispatch_signal(tid, signal.as_ref());
                }
                ThreadAction::Step(signal) => {
                    info!("Single stepping thread {} with signal {:?}", tid, signal);
                    self.single_step_thread(self.context.unwrap().pc())?;
                    dispatch_signal(tid, signal.as_ref());
                }
            }
        }

        if self.is_scheduler_lock {
            debug!("Scheduler locking is enabled; not continuing other threads");
            return Ok(());
        }

        if let Some(tid) = self.bound_tid
            && !done_cont.contains(&tid)
        {
            debug!("implicitly continue thread {}", tid);
            send_sigcont_to_thread(target_pid, tid);
        } else {
            debug!("no target need implicitly continue");
        }
        Ok(())
    }
}

impl ExtendedMode for EdbgTarget {
    fn run(
        &mut self,
        filename: Option<&[u8]>,
        args: gdbstub::target::ext::extended_mode::Args<'_, '_>,
    ) -> TargetResult<gdbstub::common::Pid, Self> {
        info!("run command");
        if let Some(filename) = filename {
            let filename = OsStr::from_bytes(filename);
            let mut cmd = process::Command::new(filename);
            for arg in args {
                cmd.arg(OsStr::from_bytes(arg));
            }
            debug!("Spawning process: {:?}", cmd);
            let handle = cmd.spawn()?;
            self.bound_pid = Some(handle.id());
            let pid =
                gdbstub::common::Pid::new(handle.id() as usize).ok_or(TargetError::NonFatal)?;
            Ok(pid)
        } else if let Some(exec_path) = self.exec_path.as_ref() {
            debug!("Start process {:?}", exec_path);
            let mut cmd = process::Command::new(exec_path);
            let handle = cmd.spawn()?;
            self.bound_pid = Some(handle.id());
            let pid =
                gdbstub::common::Pid::new(handle.id() as usize).ok_or(TargetError::NonFatal)?;
            debug!("Spawned process with PID {:?}", pid);
            Ok(pid)
        } else {
            error!("No filename provided and no existing process to run");
            Err(TargetError::NonFatal)
        }
    }

    fn attach(&mut self, pid: gdbstub::common::Pid) -> TargetResult<(), Self> {
        debug!("attach to pid {}", pid);
        Ok(())
    }

    fn query_if_attached(
        &mut self,
        pid: gdbstub::common::Pid,
    ) -> TargetResult<gdbstub::target::ext::extended_mode::AttachKind, Self> {
        if let Ok(current_pid) = self.get_pid()
            && current_pid as usize == pid.get()
        {
            debug!("Already attached to pid {}", pid);
            return Ok(gdbstub::target::ext::extended_mode::AttachKind::Attach);
        }
        Err(TargetError::NonFatal)
    }

    fn kill(&mut self, pid: Option<gdbstub::common::Pid>) -> TargetResult<ShouldTerminate, Self> {
        info!("Killing target process");
        if let Some(pid) = pid {
            debug!("Sending SIGKILL to process {}", pid.get());
            send_sig_to_process(pid.get() as u32, &Signal::SIGKILL);
            self.context.take();
            Ok(ShouldTerminate::No)
        } else if let Ok(pid) = self
            .get_pid()
            .map_err(|_| -> TargetError<Self::Error> { TargetError::NonFatal })
        {
            send_sig_to_process(pid, &Signal::SIGKILL);
            debug!("Sent SIGKILL to process {}", pid);
            self.context.take();
            Ok(ShouldTerminate::No)
        } else {
            debug!("No target process to kill");
            Err(TargetError::NonFatal)
        }
    }

    fn restart(&mut self) -> Result<(), Self::Error> {
        if let Ok(pid) = self
            .get_pid()
            .map_err(|_| -> TargetError<Self::Error> { TargetError::NonFatal })
        {
            debug!("Restarting process {}", pid);
            send_sig_to_process(pid, &Signal::SIGTERM);
            let exe = self
                .exec_path
                .as_ref()
                .ok_or_else(|| anyhow::anyhow!("no exec path to restart"))?;
            let mut cmd = process::Command::new(exe);
            let handle = cmd.spawn()?;
            self.bound_pid = Some(handle.id());
            return Ok(());
        }
        bail!("failed to restart")
    }

    #[inline(always)]
    fn support_current_active_pid(
        &mut self,
    ) -> Option<gdbstub::target::ext::extended_mode::CurrentActivePidOps<'_, Self>> {
        Some(self)
    }
}

impl CurrentActivePid for EdbgTarget {
    fn current_active_pid(&mut self) -> Result<gdbstub::common::Pid, Self::Error> {
        trace!("Getting current active PID");
        let pid = self.get_pid()?;
        Ok(gdbstub::common::Pid::new(pid as usize).unwrap())
    }
}

impl EdbgTarget {
    pub fn get_active_threads(&self) -> Result<Vec<NonZero<usize>>> {
        use anyhow::anyhow;
        if !self.is_multi_thread {
            return Ok(vec![
                NonZero::new(self.bound_tid.ok_or(anyhow!("bound tid not set"))? as usize)
                    .ok_or(anyhow!("tid is zero"))?,
            ]);
        }
        let pid = self.get_pid()? as i32;

        let process = Process::new(pid)?;

        let threads: Vec<NonZero<usize>> = process
            .tasks()?
            .flatten()
            .map(|t| NonZero::new(t.tid as usize).expect("TID 0 is invalid"))
            .collect();

        Ok(threads)
    }

    fn single_step_thread(&mut self, curr_pc: u64) -> Result<()> {
        let next_pc = self
            .calculation_next_pc(curr_pc)
            .map_err(|e| anyhow!("Failed to calculate next PC for single step: {}", e))?;
        debug!("Next PC calculated: {:#x}", next_pc);
        if self.active_sw_breakpoints.contains_key(&next_pc)
            || self.active_hw_breakpoints.contains_key(&next_pc)
        {
            return Ok(());
        }
        let add_breakpoint_func = if self.step_use_uprobe {
            EdbgTarget::internel_attach_uprobe
        } else {
            EdbgTarget::internel_attach_perf_event_break_point
        };
        match add_breakpoint_func(self, next_pc) {
            Ok(link_id) => {
                info!("Successfully attached step breakpoint at {:#x}", next_pc);
                self.temp_step_breakpoints = Some((next_pc, link_id));
            }
            Err(e) => {
                info!(
                    "Failed to attach step breakpoint at {:#x}: {}. Checking for special cases...",
                    next_pc, e
                );
                if next_pc == curr_pc {
                    bail!(
                        "Stuck in a loop: Cannot attach breakpoint at {:#x} and next PC is same.",
                        next_pc
                    );
                }
                info!(
                    "Skipping un-attachable instruction at {:#x}, recursively stepping...",
                    next_pc
                );
                self.single_step_thread(next_pc)?;
            }
        }
        Ok(())
    }
}

```

`edbgserver-cli/src/utils.rs`:

```rs
use std::io;

use gdbstub::common::Signal;
use log::{debug, error, warn};

fn sys_tgkill(tgid: i32, tid: i32, sig: i32) -> io::Result<()> {
    debug!("Sending signal {} to tgid {} tid {}", sig, tgid, tid);
    let ret = unsafe { libc::syscall(libc::SYS_tgkill, tgid, tid, sig) };

    if ret == 0 {
        Ok(())
    } else {
        Err(io::Error::last_os_error())
    }
}

fn gdb_sig_to_libc(sig: &Signal) -> Option<i32> {
    match *sig {
        Signal::SIGHUP => Some(libc::SIGHUP),
        Signal::SIGINT => Some(libc::SIGINT),
        Signal::SIGQUIT => Some(libc::SIGQUIT),
        Signal::SIGILL => Some(libc::SIGILL),
        Signal::SIGTRAP => Some(libc::SIGTRAP),
        Signal::SIGABRT => Some(libc::SIGABRT),
        Signal::SIGBUS => Some(libc::SIGBUS),
        Signal::SIGFPE => Some(libc::SIGFPE),
        Signal::SIGKILL => Some(libc::SIGKILL),
        Signal::SIGUSR1 => Some(libc::SIGUSR1),
        Signal::SIGSEGV => Some(libc::SIGSEGV),
        Signal::SIGUSR2 => Some(libc::SIGUSR2),
        Signal::SIGPIPE => Some(libc::SIGPIPE),
        Signal::SIGALRM => Some(libc::SIGALRM),
        Signal::SIGTERM => Some(libc::SIGTERM),
        Signal::SIGCHLD => Some(libc::SIGCHLD),
        Signal::SIGCONT => Some(libc::SIGCONT),
        Signal::SIGSTOP => Some(libc::SIGSTOP),
        Signal::SIGTSTP => Some(libc::SIGTSTP),
        Signal::SIGTTIN => Some(libc::SIGTTIN),
        Signal::SIGTTOU => Some(libc::SIGTTOU),
        Signal::SIGURG => Some(libc::SIGURG),
        Signal::SIGXCPU => Some(libc::SIGXCPU),
        Signal::SIGXFSZ => Some(libc::SIGXFSZ),
        Signal::SIGVTALRM => Some(libc::SIGVTALRM),
        Signal::SIGPROF => Some(libc::SIGPROF),
        Signal::SIGWINCH => Some(libc::SIGWINCH),
        Signal::SIGIO => Some(libc::SIGIO),
        Signal::SIGPWR => Some(libc::SIGPWR),
        Signal::SIGSYS => Some(libc::SIGSYS),
        _ => None,
    }
}

/// if the disposition of the signal is "stop", "continue", or"terminate",
/// this action will affect the whole process.
pub fn send_sigcont_to_thread(pid: u32, tid: u32) {
    debug!("Sending SIGCONT to pid {} tid {}", pid, tid);
    if let Err(e) = sys_tgkill(pid as i32, tid as i32, libc::SIGCONT) {
        warn!(
            "Failed to send SIGCONT to pid {} tid {}: {}. fallback to send process",
            pid, tid, e
        );
        if let Err(e) = sys_kill(pid as i32, libc::SIGCONT) {
            warn!("Failed to send SIGCONT to process {}: {}", pid, e);
        }
    }
}

/// Sends a signal to a specific thread.
///
/// Implementation Note: In a child namespace, the global TID received from eBPF
/// cannot be resolved to a local TID. This makes `tgkill` or thread-specific
/// signaling likely to fail (ESRCH).
///
/// Fallback Mechanism:
/// If sending a signal to the specific TID fails, we fall back to signaling
/// the entire process. While less granular, it ensures the signal reaches
/// the target in environments where TID mapping is unavailable.
pub fn send_sig_to_thread(pid: u32, tid: u32, sig: &Signal) {
    debug!("Sending signal {:?} to pid {} tid {}", sig, pid, tid);
    if let Some(libc_sig) = gdb_sig_to_libc(sig) {
        if let Err(e) = sys_tgkill(pid as i32, tid as i32, libc_sig) {
            warn!(
                "Failed to send {:?} (libc: {}) to tgid {} tid {}: {}. fallback to send process",
                sig, libc_sig, pid, tid, e
            );
            if let Err(e) = sys_kill(pid as i32, libc_sig) {
                error!(
                    "Failed to send {:?} (libc: {}) to process {}: {}",
                    sig, libc_sig, pid, e
                );
            }
        }
    } else {
        warn!(
            "Unsupported signal conversion for gdb signal: {:?} (tid: {})",
            sig, tid
        );
    }
}

fn sys_kill(pid: i32, sig: i32) -> io::Result<()> {
    debug!("Sending signal {} to pid {}", sig, pid);
    let ret = unsafe { libc::kill(pid, sig) };

    if ret == 0 {
        Ok(())
    } else {
        Err(io::Error::last_os_error())
    }
}

pub fn send_sig_to_process(pid: u32, sig: &Signal) {
    debug!("Sending signal {:?} to pid {}", sig, pid);
    if let Some(libc_sig) = gdb_sig_to_libc(sig) {
        if let Err(e) = sys_kill(pid as i32, libc_sig) {
            error!(
                "Failed to send {:?} (libc: {}) to process {}: {}",
                sig, libc_sig, pid, e
            );
        }
    } else {
        error!(
            "Unsupported signal conversion for gdb signal: {:?} (pid: {})",
            sig, pid
        );
    }
}

```

`edbgserver-cli/src/virtual_file.rs`:

```rs
use std::{
    ffi::OsStr,
    fs::{File, OpenOptions},
    io::{Cursor, Read, Seek, SeekFrom},
    os::unix::{
        ffi::OsStrExt,
        fs::{FileExt, MetadataExt, OpenOptionsExt},
    },
    path::Path,
};

use gdbstub::target::ext::host_io::*;
use log::{debug, trace};

trait MetadataToHostIoStat {
    fn to_gdb_stat(&self) -> HostIoStat;
}

impl MetadataToHostIoStat for std::fs::Metadata {
    fn to_gdb_stat(&self) -> HostIoStat {
        HostIoStat {
            st_dev: self.dev() as u32,
            st_ino: self.ino() as u32,
            st_mode: HostIoOpenMode::from_bits_truncate(self.mode()),
            st_nlink: self.nlink() as u32,
            st_uid: self.uid(),
            st_gid: self.gid(),
            st_rdev: self.rdev() as u32,
            st_size: self.size(),
            st_blksize: self.blksize(),
            st_blocks: self.blocks(),
            st_atime: self.atime() as u32,
            st_mtime: self.mtime() as u32,
            st_ctime: self.ctime() as u32,
        }
    }
}

pub enum VirtualFile {
    Real(File),
    Cached { data: Cursor<Vec<u8>> },
}

fn filter_maps_content(content: &str) -> String {
    let mut result = String::with_capacity(4096);
    for line in content.lines() {
        if line.contains(" ---p ") {
            continue;
        }
        if line.contains("/dev/__properties__") {
            continue;
        }
        if line.contains(".jar")
            || line.contains(".apk")
            || line.contains(".dex")
            || line.contains(".oat")
            || line.contains(".art")
            || line.contains(".res")
            || line.contains(".hyb")
            || line.contains("/overlay/")
            || line.contains("/resource-cache/")
            || line.contains(".ttf")
        {
            continue;
        }

        if line.contains("bionic_alloc")
            || line.contains("linker_alloc")
            || line.contains("scudo:")
            || line.contains("dalvik-")
            || line.contains("thread signal stack")
            || line.contains("InternalMmapVector")
            || line.contains("System property")
            || line.contains("gwp-asan")
            || line.contains("arc4random")
            || line.contains("ReadFileToBuffer")
        {
            continue;
        }

        let is_primary_special = line.contains("[stack]")
            || line.contains("[heap]")
            || line.contains("[vdso]")
            || line.contains("[vvar]");

        let is_thread_stack = line.contains("stack_and_tls");

        let is_user_lib = line.contains("/data/app/") || line.contains("/data/data/");

        let is_system_path =
            line.contains("/system/") || line.contains("/vendor/") || line.contains("/apex/");

        let is_infra_lib = line.contains("/libc.so")
            || line.contains("/libm.so")
            || line.contains("/libdl.so")
            || line.contains("/libart.so")
            || line.contains("linker");

        let is_exec = line.contains(" r-xp ");
        let is_write = line.contains(" rw-p ");
        let is_bbs = line.contains(" [anon:.bss]");

        let mut keep = false;
        let mut modified_line: Option<String> = None;

        if is_primary_special {
            keep = true;
        } else if is_thread_stack {
            keep = true;
            modified_line = Some(line.replace("[anon:stack_and_tls:", "[stack:"));
        } else if is_user_lib {
            keep = true;
        } else if is_infra_lib {
            if is_exec || is_write {
                keep = true;
            }
        } else if is_system_path {
            keep = false;
        } else if is_exec {
            keep = true;
        } else if is_bbs {
            keep = false;
        }

        if keep {
            let final_line = modified_line.as_deref().unwrap_or(line);
            result.push_str(final_line);
            result.push('\n');
        }
    }
    result
}

impl VirtualFile {
    pub fn open(
        filename: &[u8],
        flags: HostIoOpenFlags,
        mode: HostIoOpenMode,
        need_filter_maps: bool,
    ) -> std::io::Result<Self> {
        let path = Path::new(OsStr::from_bytes(filename));
        let path_str = path.to_string_lossy();

        debug!(
            "VirtualFile: Request open '{}' (flags={:?}, mode={:?})",
            path_str, flags, mode
        );

        if need_filter_maps && flags == HostIoOpenFlags::O_RDONLY && path.ends_with("maps") {
            debug!("VirtualFile: Smart filtering maps file...");
            let raw_content = std::fs::read_to_string(path)?;
            let filtered = filter_maps_content(&raw_content);
            debug!(
                "VirtualFile: Maps compressed {} -> {} bytes",
                raw_content.len(),
                filtered.len()
            );
            return Ok(VirtualFile::Cached {
                data: Cursor::new(filtered.into_bytes()),
            });
        }

        if flags == HostIoOpenFlags::O_RDONLY {
            debug!("VirtualFile: HIT CACHE STRATEGY for '{}'", path_str);
            let data = std::fs::read(path)?;
            return Ok(VirtualFile::Cached {
                data: Cursor::new(data),
            });
        }

        let mut options = OpenOptions::new();
        options
            .read(
                flags.contains(HostIoOpenFlags::O_RDONLY)
                    || flags.contains(HostIoOpenFlags::O_RDWR),
            )
            .write(
                flags.contains(HostIoOpenFlags::O_WRONLY)
                    || flags.contains(HostIoOpenFlags::O_RDWR),
            )
            .create(flags.contains(HostIoOpenFlags::O_CREAT))
            .create_new(flags.contains(HostIoOpenFlags::O_EXCL))
            .truncate(flags.contains(HostIoOpenFlags::O_TRUNC))
            .append(flags.contains(HostIoOpenFlags::O_APPEND))
            .mode(mode.bits());

        let file = options.open(path)?;
        Ok(VirtualFile::Real(file))
    }

    pub fn read_at(&mut self, offset: u64, buf: &mut [u8]) -> std::io::Result<usize> {
        match self {
            VirtualFile::Real(file) => {
                trace!(
                    "VirtualFile: read real file off={} len={}",
                    offset,
                    buf.len()
                );
                file.read_at(buf, offset)
            }
            VirtualFile::Cached { data, .. } => {
                trace!(
                    "VirtualFile: Cached read_at off={} len={}",
                    offset,
                    buf.len()
                );
                data.seek(SeekFrom::Start(offset))?;
                data.read(buf)
            }
        }
    }

    pub fn write_at(&mut self, offset: u64, buf: &[u8]) -> std::io::Result<u64> {
        debug!("VirtualFile: write_at off={} len={}", offset, buf.len());
        match self {
            VirtualFile::Real(file) => file.write_at(buf, offset).map(|n| n as u64),
            VirtualFile::Cached { .. } => Err(std::io::Error::new(
                std::io::ErrorKind::PermissionDenied,
                "Cannot write to cached file",
            )),
        }
    }

    pub fn stat(&self) -> std::io::Result<HostIoStat> {
        match self {
            VirtualFile::Real(file) => {
                let meta = file.metadata()?;
                Ok(meta.to_gdb_stat())
            }
            VirtualFile::Cached { data, .. } => {
                let len = data.get_ref().len() as u64;
                Ok(HostIoStat {
                    st_dev: 0,
                    st_ino: 0,
                    st_mode: HostIoOpenMode::S_IFREG | HostIoOpenMode::S_IRUSR,
                    st_nlink: 1,
                    st_uid: 0,
                    st_gid: 0,
                    st_rdev: 0,
                    st_size: len,
                    st_blksize: 4096,
                    st_blocks: len.div_ceil(512),
                    st_atime: 0,
                    st_mtime: 0,
                    st_ctime: 0,
                })
            }
        }
    }
}

```

`edbgserver-cli/tests/integration_test.rs`:

```rs
use std::{
    path::Path,
    process::{Command, Stdio},
    thread::sleep,
    time::Duration,
};

use aya::{maps::RingBuf, programs::UProbe};
use edbgserver_common::DataT;
use log::{debug, warn};
use serial_test::serial;

fn init_edbg_server() -> aya::Ebpf {
    pretty_env_logger::try_init().ok();
    let rlim = libc::rlimit {
        rlim_cur: libc::RLIM_INFINITY,
        rlim_max: libc::RLIM_INFINITY,
    };
    let ret = unsafe { libc::setrlimit(libc::RLIMIT_MEMLOCK, &rlim) };
    if ret != 0 {
        debug!("remove limit on locked memory failed, ret is: {}", ret);
    }
    let mut ebpf = aya::Ebpf::load(aya::include_bytes_aligned!(concat!(
        env!("OUT_DIR"),
        "/edbgserver"
    )))
    .expect("Failed to load eBPF program");
    match aya_log::EbpfLogger::init(&mut ebpf) {
        Err(e) => {
            // This can happen if you remove all log statements from your eBPF program.
            warn!("failed to initialize eBPF logger: {e}");
        }
        Ok(logger) => {
            let mut logger =
                tokio::io::unix::AsyncFd::with_interest(logger, tokio::io::Interest::READABLE)
                    .expect("Failed to create AsyncFd for logger");
            tokio::task::spawn(async move {
                loop {
                    let mut guard = logger.readable_mut().await.unwrap();
                    guard.get_inner_mut().flush();
                    guard.clear_ready();
                }
            });
        }
    }
    ebpf
}

#[tokio::test]
#[serial]
async fn test_breakpoint_signal() {
    // create test target process
    let target_prog = Path::new("./tests/test_target/test_target");
    #[allow(clippy::zombie_processes)]
    let mut child = Command::new(target_prog)
        .stdout(Stdio::piped())
        .spawn()
        .expect("Failed to spawn target");
    let target_pid = child.id();
    println!("Test target pid: {}", target_pid);
    sleep(Duration::from_millis(200));
    let mut ebpf = init_edbg_server();
    // Attach uprobe to the target function
    let program: &mut UProbe = ebpf
        .program_mut("edbgserver")
        .unwrap()
        .try_into()
        .expect("Failed to convert eBPF program to UProbe");
    program.load().expect("Failed to load eBPF program");
    program
        .attach(
            "trigger_breakpoint",
            "/home/cyril/dev/learn/rust/edbgserver/edbgserver/edbgserver/tests/test_target/test_target",
            None,
            None,
        )
        .expect("Failed to attach eBPF program");
    sleep(Duration::from_secs(1));
    // should stop the target process when the function is called
    let status = read_process_state(target_pid);
    assert!(status.to_uppercase() == "T", "Process should be stop");
    // send SIGCONT to continue the process
    unsafe {
        libc::kill(target_pid as i32, libc::SIGCONT);
    }
    let after_status = read_process_state(target_pid);
    // program should have continued
    assert!(
        after_status.to_uppercase() != "T",
        "Process should not be stop anymore"
    );
    let _ = child.kill();
}

#[tokio::test]
#[serial]
async fn test_breakpoint_ret_info() {
    // create test target process
    let target_prog = Path::new("./tests/test_target/test_target");
    #[allow(clippy::zombie_processes)]
    let mut child = Command::new(target_prog)
        .stdout(Stdio::piped())
        .spawn()
        .expect("Failed to spawn target");
    let target_pid = child.id();
    println!("Test target pid: {}", target_pid);
    sleep(Duration::from_millis(200));
    let mut ebpf = init_edbg_server();
    // 拿到event map

    // Attach uprobe to the target function
    let program: &mut UProbe = ebpf
        .program_mut("edbgserver")
        .unwrap()
        .try_into()
        .expect("Failed to convert eBPF program to UProbe");
    program.load().expect("Failed to load eBPF program");

    let _link = program
        .attach(
            "trigger_breakpoint",
            "/home/cyril/dev/learn/rust/edbgserver/edbgserver/edbgserver/tests/test_target/test_target",
            None,
            None,
        )
        .expect("Failed to attach eBPF program");
    sleep(Duration::from_secs(1));
    // should stop the target process when the function is called
    let status = read_process_state(target_pid);
    assert!(status.to_uppercase() == "T", "Process should be stop");

    let events_map = ebpf.map_mut("EVENTS").expect("Failed to find EVENTS map");
    let mut events =
        RingBuf::try_from(events_map).expect("Failed to create RingBuf from EVENTS map");

    if let Some(event) = events.next() {
        let data_ptr = event.as_ptr() as *const DataT;
        let data = unsafe { &*data_ptr }; // unsafe: dereference raw pointer to struct

        println!("Received event from RingBuf:");
        println!("  PID: {}", data.tid);
        println!("  PC:  0x{:x}", data.pc());
        println!("  SP:  0x{:x}", data.sp);

        assert_eq!(data.tid, target_pid, "RingBuf PID matches target PID");

        assert!(data.pc() > 0, "PC should be non-zero");

        assert!(data.sp > 0, "SP should be non-zero");

        let regs_sum: u64 = data.regs.iter().sum();
        assert!(regs_sum > 0, "Registers shouldn't be all empty");
    }
    let _ = child.kill();
}

fn read_process_state(pid: u32) -> String {
    let path = format!("/proc/{}/stat", pid);
    let content = std::fs::read_to_string(path).unwrap_or_default();
    content.split_whitespace().nth(2).unwrap_or("?").to_string()
}

```

`edbgserver-cli/tests/test_target/test_target.c`:

```c
// test_target.c
#include <stdio.h>
#include <unistd.h>

__attribute__((noinline)) void trigger_breakpoint() {
  printf("[Target] Trigger function called!\n");
  int a = 1;
  a = 2;
  a = 3;
}

int main() {
  printf("[Target] PID: %d\n", getpid());

  while (1) {
    trigger_breakpoint();
    getchar();
    // sleep(3);
  }
  return 0;
}

```

`edbgserver-common/Cargo.toml`:

```toml
[package]
name = "edbgserver-common"
version = "1.0.1"
edition.workspace = true
description = "Common library for edbgserver"
repository = "https://github.com/Satar07/edbgserver"
license.workspace = true

[features]
default = []
user = ["aya"]

[dependencies]
aya = { workspace = true, optional = true }

[lib]
path = "src/lib.rs"

[lints.rust]
unexpected_cfgs = { level = "warn", check-cfg = [
    'cfg(bpf_target_arch, values("x86_64", "aarch64"))'
] }

```

`edbgserver-common/src/lib.rs`:

```rs
#![no_std]

#[cfg(any(
    target_arch = "aarch64",
    all(target_arch = "bpf", bpf_target_arch = "aarch64")
))]
#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct DataT {
    pub tid: u32,
    pub pid: u32,
    pub regs: [u64; 31],
    pub sp: u64,
    pub pc: u64,
    pub pstate: u64,
    pub fault_addr: u64,
    pub event_source: EdbgSource,
}

#[cfg(any(
    target_arch = "x86_64",
    all(target_arch = "bpf", bpf_target_arch = "x86_64")
))]
#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct DataT {
    pub tid: u32,
    pub pid: u32,
    pub r15: u64,
    pub r14: u64,
    pub r13: u64,
    pub r12: u64,
    pub rbp: u64,
    pub rbx: u64,
    pub r11: u64,
    pub r10: u64,
    pub r9: u64,
    pub r8: u64,
    pub rax: u64,
    pub rcx: u64,
    pub rdx: u64,
    pub rsi: u64,
    pub rdi: u64,
    pub orig_rax: u64,
    pub rip: u64,
    pub cs: u64,
    pub eflags: u64,
    pub rsp: u64,
    pub ss: u64,
    pub fault_addr: u64,
    pub event_source: EdbgSource,
}

impl DataT {
    #[cfg(target_arch = "aarch64")]
    pub fn pc(&self) -> u64 {
        self.pc
    }

    #[cfg(target_arch = "x86_64")]
    pub fn pc(&self) -> u64 {
        self.rip
    }
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum EdbgSource {
    Uprobe,
    PerfEvent,
}

#[repr(C, u32)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum ThreadFilter {
    None,
    Some(u32),
}

#[cfg(feature = "user")]
unsafe impl aya::Pod for DataT {}

#[cfg(feature = "user")]
unsafe impl aya::Pod for ThreadFilter {}

```

`edbgserver-ebpf/Cargo.toml`:

```toml
[package]
name = "edbgserver-ebpf"
version = "1.0.1"
edition.workspace = true
description = "EBPF library for edbgserver"
repository = "https://github.com/Satar07/edbgserver"
publish = true

[dependencies]
edbgserver-common = { path = "../edbgserver-common" }

aya-ebpf = { workspace = true }
aya-log-ebpf = { workspace = true }

[build-dependencies]
which = { workspace = true }

[[bin]]
name = "edbgserver"
path = "src/main.rs"

[lints.rust]
unexpected_cfgs = { level = "warn", check-cfg = [
    'cfg(bpf_target_arch, values("x86_64", "aarch64"))'
] }

```

`edbgserver-ebpf/build.rs`:

```rs
use which::which;

/// Building this crate has an undeclared dependency on the `bpf-linker` binary. This would be
/// better expressed by [artifact-dependencies][bindeps] but issues such as
/// https://github.com/rust-lang/cargo/issues/12385 make their use impractical for the time being.
///
/// This file implements an imperfect solution: it causes cargo to rebuild the crate whenever the
/// mtime of `which bpf-linker` changes. Note that possibility that a new bpf-linker is added to
/// $PATH ahead of the one used as the cache key still exists. Solving this in the general case
/// would require rebuild-if-changed-env=PATH *and* rebuild-if-changed={every-directory-in-PATH}
/// which would likely mean far too much cache invalidation.
///
/// [bindeps]: https://doc.rust-lang.org/nightly/cargo/reference/unstable.html?highlight=feature#artifact-dependencies
fn main() {
    let bpf_linker = which("bpf-linker").unwrap();
    println!("cargo:rerun-if-changed={}", bpf_linker.to_str().unwrap());
}

```

`edbgserver-ebpf/src/lib.rs`:

```rs
#![no_std]

// This file exists to enable the library target.

```

`edbgserver-ebpf/src/main.rs`:

```rs
#![no_std]
#![no_main]

use aya_ebpf::{
    helpers::{bpf_get_current_pid_tgid, generated::bpf_send_signal},
    macros::{map, perf_event, uprobe},
    maps::{Array, RingBuf},
    programs::{PerfEventContext, ProbeContext},
};
use aya_log_ebpf::{debug, error};
use edbgserver_common::{DataT, ThreadFilter};

const SIGSTOP: u32 = 19;

const RINGBUF_SIZE: u32 = 64 * 1024;

#[map]
static EVENTS: RingBuf = RingBuf::with_byte_size(RINGBUF_SIZE, 0);

#[map]
/// index 0: thread id
static THREAD_FILTER: Array<ThreadFilter> = Array::with_max_entries(1, 0);

#[uprobe]
pub fn probe_callback(ctx: ProbeContext) -> i64 {
    match try_probe_callback(&ctx) {
        Ok(ret) => ret,
        Err(ret) => {
            error!(&ctx, "error num: {}", ret);
            ret
        }
    }
}

// #[cfg(bpf_target_arch = "aarch64")]
#[cfg(any(bpf_target_arch = "aarch64", debug_assertions))]
fn try_probe_callback(ctx: &ProbeContext) -> Result<i64, i64> {
    debug!(ctx, "entered probe callback");
    let current_tid = bpf_get_current_pid_tgid() as u32;
    let filter = THREAD_FILTER.get(0).unwrap_or(&ThreadFilter::None);
    match filter {
        ThreadFilter::None => debug!(ctx, "thread filter is none"),
        ThreadFilter::Some(t) => debug!(ctx, "thread filter tid: {}", *t),
    }
    if let ThreadFilter::Some(tid) = filter
        && *tid != current_tid
    {
        debug!(
            ctx,
            "thread id {} does not match filter {}", current_tid, *tid
        );
        return Ok(0);
    }
    if let Some(mut entry) = EVENTS.reserve::<DataT>(0) {
        let data_ptr = entry.as_mut_ptr();
        let regs = unsafe { &*ctx.regs };
        unsafe {
            (*data_ptr).tid = bpf_get_current_pid_tgid() as u32;
            (*data_ptr).pid = (bpf_get_current_pid_tgid() >> 32) as u32;
            for i in 0..31 {
                (*data_ptr).regs[i] = regs.regs[i];
            }
            (*data_ptr).pc = regs.pc;
            (*data_ptr).sp = regs.sp;
            (*data_ptr).pstate = regs.pstate;
            (*data_ptr).fault_addr = regs.pc;
            (*data_ptr).event_source = edbgserver_common::EdbgSource::Uprobe;
        }
        entry.submit(0);
    } else {
        error!(ctx, "failed to reserve ringbuf space");
    }
    debug!(ctx, "send data to event array");
    unsafe {
        bpf_send_signal(SIGSTOP);
    }
    debug!(ctx, "sent SIGSTOP to current process");
    Ok(0)
}

#[cfg(bpf_target_arch = "x86_64")]
// #[cfg(any(bpf_target_arch = "x86_64", debug_assertions))]
fn try_probe_callback(ctx: &ProbeContext) -> Result<i64, i64> {
    debug!(ctx, "entered probe callback");
    let current_tid = bpf_get_current_pid_tgid() as u32;
    let filter = THREAD_FILTER.get(0).unwrap_or(&ThreadFilter::None);
    match filter {
        ThreadFilter::None => debug!(ctx, "thread filter is none"),
        ThreadFilter::Some(t) => debug!(ctx, "thread filter tid: {}", *t),
    }
    if let ThreadFilter::Some(tid) = filter
        && *tid != current_tid
    {
        debug!(
            ctx,
            "thread id {} does not match filter {}", current_tid, *tid
        );
        return Ok(0);
    }
    if let Some(mut entry) = EVENTS.reserve::<DataT>(0) {
        let data_ptr = entry.as_mut_ptr();
        let regs = unsafe { *ctx.regs };
        unsafe {
            (*data_ptr).tid = bpf_get_current_pid_tgid() as u32;
            (*data_ptr).pid = (bpf_get_current_pid_tgid() >> 32) as u32;
            (*data_ptr).r15 = regs.r15;
            (*data_ptr).r14 = regs.r14;
            (*data_ptr).r13 = regs.r13;
            (*data_ptr).r12 = regs.r12;
            (*data_ptr).rbp = regs.rbp;
            (*data_ptr).rbx = regs.rbx;
            (*data_ptr).r11 = regs.r11;
            (*data_ptr).r10 = regs.r10;
            (*data_ptr).r9 = regs.r9;
            (*data_ptr).r8 = regs.r8;
            (*data_ptr).rax = regs.rax;
            (*data_ptr).rcx = regs.rcx;
            (*data_ptr).rdx = regs.rdx;
            (*data_ptr).rsi = regs.rsi;
            (*data_ptr).rdi = regs.rdi;
            (*data_ptr).orig_rax = regs.orig_rax;
            (*data_ptr).rip = regs.rip;
            (*data_ptr).cs = regs.cs;
            (*data_ptr).eflags = regs.eflags;
            (*data_ptr).ss = regs.ss;
            (*data_ptr).rsp = regs.rsp;
            (*data_ptr).fault_addr = regs.rip;
            (*data_ptr).event_source = edbgserver_common::EdbgSource::Uprobe;
        }
        entry.submit(0);
    } else {
        error!(ctx, "failed to reserve ringbuf space");
    }
    debug!(ctx, "send data to event array");
    unsafe {
        bpf_send_signal(SIGSTOP);
    }
    debug!(ctx, "sent SIGSTOP to current process");
    Ok(0)
}

#[perf_event]
pub fn perf_callback(ctx: PerfEventContext) -> i64 {
    match try_perf_callback(&ctx) {
        Ok(ret) => ret,
        Err(ret) => {
            error!(&ctx, "error num: {}", ret);
            ret
        }
    }
}

// #[cfg(bpf_target_arch = "aarch64")]
#[cfg(any(bpf_target_arch = "aarch64", debug_assertions))]
fn try_perf_callback(ctx: &PerfEventContext) -> Result<i64, i64> {
    debug!(ctx, "entered perf callback");
    let current_tid = bpf_get_current_pid_tgid() as u32;
    let filter = THREAD_FILTER.get(0).unwrap_or(&ThreadFilter::None);
    match filter {
        ThreadFilter::None => debug!(ctx, "thread filter is none"),
        ThreadFilter::Some(t) => debug!(ctx, "thread filter tid: {}", *t),
    }
    if let ThreadFilter::Some(tid) = filter
        && *tid != current_tid
    {
        debug!(
            ctx,
            "thread id {} does not match filter {}", current_tid, *tid
        );
        return Ok(0);
    }
    if let Some(mut entry) = EVENTS.reserve::<DataT>(0) {
        let data_ptr = entry.as_mut_ptr();
        let regs = unsafe { (*ctx.ctx).regs };
        unsafe {
            (*data_ptr).tid = bpf_get_current_pid_tgid() as u32;
            (*data_ptr).pid = (bpf_get_current_pid_tgid() >> 32) as u32;
            for i in 0..31 {
                (*data_ptr).regs[i] = regs.regs[i];
            }
            (*data_ptr).pc = regs.pc;
            (*data_ptr).sp = regs.sp;
            (*data_ptr).pstate = regs.pstate;
            (*data_ptr).fault_addr = (*ctx.ctx).addr;
            (*data_ptr).event_source = edbgserver_common::EdbgSource::PerfEvent;
        }
        entry.submit(0);
    } else {
        error!(ctx, "failed to reserve ringbuf space");
    }
    debug!(ctx, "send data to event array");
    unsafe {
        bpf_send_signal(SIGSTOP);
    }
    debug!(ctx, "sent SIGSTOP to current process");
    Ok(0)
}

#[cfg(bpf_target_arch = "x86_64")]
// #[cfg(any(bpf_target_arch = "x86_64", debug_assertions))]
fn try_perf_callback(ctx: &PerfEventContext) -> Result<i64, i64> {
    debug!(ctx, "entered perf callback");
    let current_tid = bpf_get_current_pid_tgid() as u32;
    let filter = THREAD_FILTER.get(0).unwrap_or(&ThreadFilter::None);
    if let ThreadFilter::Some(tid) = filter
        && *tid != current_tid
    {
        return Ok(0);
    }
    if let Some(mut entry) = EVENTS.reserve::<DataT>(0) {
        let data_ptr = entry.as_mut_ptr();
        let regs = unsafe { (*ctx.ctx).regs };
        unsafe {
            (*data_ptr).tid = bpf_get_current_pid_tgid() as u32;
            (*data_ptr).pid = (bpf_get_current_pid_tgid() >> 32) as u32;
            (*data_ptr).r15 = regs.r15;
            (*data_ptr).r14 = regs.r14;
            (*data_ptr).r13 = regs.r13;
            (*data_ptr).r12 = regs.r12;
            (*data_ptr).rbp = regs.rbp;
            (*data_ptr).rbx = regs.rbx;
            (*data_ptr).r11 = regs.r11;
            (*data_ptr).r10 = regs.r10;
            (*data_ptr).r9 = regs.r9;
            (*data_ptr).r8 = regs.r8;
            (*data_ptr).rax = regs.rax;
            (*data_ptr).rcx = regs.rcx;
            (*data_ptr).rdx = regs.rdx;
            (*data_ptr).rsi = regs.rsi;
            (*data_ptr).rdi = regs.rdi;
            (*data_ptr).orig_rax = regs.orig_rax;
            (*data_ptr).rip = regs.rip;
            (*data_ptr).cs = regs.cs;
            (*data_ptr).eflags = regs.eflags;
            (*data_ptr).ss = regs.ss;
            (*data_ptr).rsp = regs.rsp;
            (*data_ptr).fault_addr = (*ctx.ctx).addr;
            (*data_ptr).event_source = edbgserver_common::EdbgSource::PerfEvent;
        }
        entry.submit(0);
    } else {
        error!(ctx, "failed to reserve ringbuf space");
    }
    debug!(ctx, "send data to event array");
    unsafe {
        bpf_send_signal(SIGSTOP);
    }
    debug!(ctx, "sent SIGSTOP to current process");
    Ok(0)
}

#[cfg(not(test))]
#[panic_handler]
fn panic(_info: &core::panic::PanicInfo) -> ! {
    loop {}
}

#[unsafe(link_section = "license")]
#[unsafe(no_mangle)]
static LICENSE: [u8; 13] = *b"Dual MIT/GPL\0";

```

`rust-toolchain.toml`:

```toml
[toolchain]
channel = "nightly"
components = [ "rust-src", "rust-analyzer", "clippy" ]
targets = [ "aarch64-unknown-linux-musl", "x86_64-unknown-linux-musl" ]

```

`rustfmt.toml`:

```toml
group_imports = "StdExternalCrate"
imports_granularity = "Crate"
reorder_imports = true
unstable_features = true
style_edition = "2024"
edition = "2024"
reorder_impl_items = true
format_code_in_doc_comments = true

```